static NO_INLINE JsVar *jspGetNamedFieldInParents(JsVar *object, const char* name, bool returnName) {
  // Now look in prototypes
  JsVar * child = jspeiFindChildFromStringInParents(object, name);

  /* Check for builtins via separate function
   * This way we save on RAM for built-ins because everything comes out of program code */
  if (!child) {
    child = jswFindBuiltInFunction(object, name);
  }

  /* We didn't get here if we found a child in the object itself, so
   * if we're here then we probably have the wrong name - so for example
   * with `a.b = c;` could end up setting `a.prototype.b` (bug #360)
   *
   * Also we might have got a built-in, which wouldn't have a name on it
   * anyway - so in both cases, strip the name if it is there, and create
   * a new name that references the object we actually requested the
   * member from..
   */
  if (child && returnName) {
    // Get rid of existing name
    if (jsvIsName(child)) {
      JsVar *t = jsvGetValueOfName(child);
      jsvUnLock(child);
      child = t;
    }
    // create a new name
    JsVar *nameVar = jsvNewFromString(name);
    JsVar *newChild = jsvCreateNewChild(object, nameVar, child);
    jsvUnLock2(nameVar, child);
    child = newChild;
  }

  // If not found and is the prototype, create it
  if (!child) {
    if (jsvIsFunction(object) && strcmp(name, JSPARSE_PROTOTYPE_VAR)==0) {
      // prototype is supposed to be an object
      JsVar *proto = jsvNewObject();
      // make sure it has a 'constructor' variable that points to the object it was part of
      jsvObjectSetChild(proto, JSPARSE_CONSTRUCTOR_VAR, object);
      child = jsvAddNamedChild(object, proto, JSPARSE_PROTOTYPE_VAR);
      jspEnsureIsPrototype(object, child);
      jsvUnLock(proto);
    } else if (strcmp(name, JSPARSE_INHERITS_VAR)==0) {
      const char *objName = jswGetBasicObjectName(object);
      if (objName) {
        child = jspNewPrototype(objName);
      }
    }
  }

  return child;
}
