int tulip_poll(struct napi_struct *napi, int budget)
{
	struct tulip_private *tp = container_of(napi, struct tulip_private, napi);
	struct net_device *dev = tp->dev;
	int entry = tp->cur_rx % RX_RING_SIZE;
	int work_done = 0;
#ifdef CONFIG_TULIP_NAPI_HW_MITIGATION
	int received = 0;
#endif
#ifdef CONFIG_TULIP_NAPI_HW_MITIGATION
        if (budget >=RX_RING_SIZE) budget--;
#endif
	if (tulip_debug > 4)
		netdev_dbg(dev, " In tulip_rx(), entry %d %08x\n",
			   entry, tp->rx_ring[entry].status);
       do {
		if (ioread32(tp->base_addr + CSR5) == 0xffffffff) {
			netdev_dbg(dev, " In tulip_poll(), hardware disappeared\n");
			break;
		}
               iowrite32((RxIntr | RxNoBuf), tp->base_addr + CSR5);
               while ( ! (tp->rx_ring[entry].status & cpu_to_le32(DescOwned))) {
                       int status = le32_to_cpu(tp->rx_ring[entry].status);
		       short pkt_len;
                       if (tp->dirty_rx + RX_RING_SIZE == tp->cur_rx)
                               break;
		       if (tulip_debug > 5)
				netdev_dbg(dev, "In tulip_rx(), entry %d %08x\n",
					   entry, status);
		       if (++work_done >= budget)
                               goto not_done;
		       pkt_len = ((status >> 16) & 0x7ff) - 4;
		       if ((status & (RxLengthOver2047 |
				      RxDescCRCError |
				      RxDescCollisionSeen |
				      RxDescRunt |
				      RxDescDescErr |
				      RxWholePkt)) != RxWholePkt ||
			   pkt_len > 1518) {
			       if ((status & (RxLengthOver2047 |
					      RxWholePkt)) != RxWholePkt) {
                                       if ((status & 0xffff) != 0x7fff) {
                                               if (tulip_debug > 1)
                                                       dev_warn(&dev->dev,
								"Oversized Ethernet frame spanned multiple buffers, status %08x!\n",
								status);
						dev->stats.rx_length_errors++;
					}
			       } else {
				       if (tulip_debug > 2)
						netdev_dbg(dev, "Receive error, Rx status %08x\n",
							   status);
					dev->stats.rx_errors++; 
					if (pkt_len > 1518 ||
					    (status & RxDescRunt))
						dev->stats.rx_length_errors++;
					if (status & 0x0004)
						dev->stats.rx_frame_errors++;
					if (status & 0x0002)
						dev->stats.rx_crc_errors++;
					if (status & 0x0001)
						dev->stats.rx_fifo_errors++;
                               }
                       } else {
                               struct sk_buff *skb;
                               if (pkt_len < tulip_rx_copybreak &&
                                   (skb = netdev_alloc_skb(dev, pkt_len + 2)) != NULL) {
                                       skb_reserve(skb, 2);    
					dma_sync_single_for_cpu(&tp->pdev->dev,
								tp->rx_buffers[entry].mapping,
								pkt_len,
								DMA_FROM_DEVICE);
#if ! defined(__alpha__)
                                       skb_copy_to_linear_data(skb, tp->rx_buffers[entry].skb->data,
                                                        pkt_len);
#else
                                       skb_put_data(skb,
                                                    tp->rx_buffers[entry].skb->data,
                                                    pkt_len);
#endif
					dma_sync_single_for_device(&tp->pdev->dev,
								   tp->rx_buffers[entry].mapping,
								   pkt_len,
								   DMA_FROM_DEVICE);
                               } else {        
                                       char *temp = skb_put(skb = tp->rx_buffers[entry].skb,
                                                            pkt_len);
#ifndef final_version
                                       if (tp->rx_buffers[entry].mapping !=
                                           le32_to_cpu(tp->rx_ring[entry].buffer1)) {
                                               dev_err(&dev->dev,
						       "Internal fault: The skbuff addresses do not match in tulip_rx: %08x vs. %08llx %p / %p\n",
						       le32_to_cpu(tp->rx_ring[entry].buffer1),
						       (unsigned int int)tp->rx_buffers[entry].mapping,
						       skb->head, temp);
                                       }
#endif
					dma_unmap_single(&tp->pdev->dev,
							 tp->rx_buffers[entry].mapping,
							 PKT_BUF_SZ,
							 DMA_FROM_DEVICE);
                                       tp->rx_buffers[entry].skb = NULL;
                                       tp->rx_buffers[entry].mapping = 0;
                               }
                               skb->protocol = eth_type_trans(skb, dev);
                               netif_receive_skb(skb);
				dev->stats.rx_packets++;
				dev->stats.rx_bytes += pkt_len;
                       }
#ifdef CONFIG_TULIP_NAPI_HW_MITIGATION
		       received++;
#endif
                       entry = (++tp->cur_rx) % RX_RING_SIZE;
                       if (tp->cur_rx - tp->dirty_rx > RX_RING_SIZE/4)
                               tulip_refill_rx(dev);
                }
       } while ((ioread32(tp->base_addr + CSR5) & RxIntr));
 #ifdef CONFIG_TULIP_NAPI_HW_MITIGATION
          if( tp->flags &  HAS_INTR_MITIGATION) {
                 if( received > 1 ) {
                         if( ! tp->mit_on ) {
                                 tp->mit_on = 1;
                                 iowrite32(mit_table[MIT_TABLE], tp->base_addr + CSR11);
                         }
                  }
                 else {
                         if( tp->mit_on ) {
                                 tp->mit_on = 0;
                                 iowrite32(0, tp->base_addr + CSR11);
                         }
                  }
          }
#endif 
         tulip_refill_rx(dev);
         if (tp->rx_buffers[tp->dirty_rx % RX_RING_SIZE].skb == NULL)
		 goto oom;
	napi_complete_done(napi, work_done);
	iowrite32(tulip_tbl[tp->chip_id].valid_intrs, tp->base_addr+CSR7);
         return work_done;
 not_done:
         if (tp->cur_rx - tp->dirty_rx > RX_RING_SIZE/2 ||
             tp->rx_buffers[tp->dirty_rx % RX_RING_SIZE].skb == NULL)
                 tulip_refill_rx(dev);
         if (tp->rx_buffers[tp->dirty_rx % RX_RING_SIZE].skb == NULL)
		 goto oom;
         return work_done;
 oom:    
         mod_timer(&tp->oom_timer, jiffies+1);
         napi_complete_done(napi, work_done);
         return work_done;
}
