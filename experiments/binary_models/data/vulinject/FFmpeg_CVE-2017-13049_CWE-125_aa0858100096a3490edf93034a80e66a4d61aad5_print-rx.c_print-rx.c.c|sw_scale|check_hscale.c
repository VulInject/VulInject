static void check_hscale(void)
{
#define MAX_FILTER_WIDTH 40
#define FILTER_SIZES 6
    static const int filter_sizes[FILTER_SIZES] = { 4, 8, 12, 16, 32, 40 };
#define HSCALE_PAIRS 2
    static const int hscale_pairs[HSCALE_PAIRS][2] = {
        { 8, 14 },
        { 8, 18 },
    };
#define LARGEST_INPUT_SIZE 512
#define INPUT_SIZES 6
    static const int input_sizes[INPUT_SIZES] = {8, 24, 128, 144, 256, 512};
    int i, j, fsi, hpi, width, dstWi;
    struct SwsContext *ctx;
    // padded
    LOCAL_ALIGNED_32(uint8_t, src, [FFALIGN(SRC_PIXELS + MAX_FILTER_WIDTH - 1, 4)]);
    LOCAL_ALIGNED_32(uint32_t, dst0, [SRC_PIXELS]);
    LOCAL_ALIGNED_32(uint32_t, dst1, [SRC_PIXELS]);
    // padded
    LOCAL_ALIGNED_32(int16_t, filter, [SRC_PIXELS * MAX_FILTER_WIDTH + MAX_FILTER_WIDTH]);
    LOCAL_ALIGNED_32(int32_t, filterPos, [SRC_PIXELS]);
    LOCAL_ALIGNED_32(int16_t, filterAvx2, [SRC_PIXELS * MAX_FILTER_WIDTH + MAX_FILTER_WIDTH]);
    LOCAL_ALIGNED_32(int32_t, filterPosAvx, [SRC_PIXELS]);
    // The dst parameter here is either int16_t or int32_t but we use void* to
    // just cover both cases.
    declare_func(void, void *c, void *dst, int dstW,
                 const uint8_t *src, const int16_t *filter,
                 const int32_t *filterPos, int filterSize);
    ctx = sws_alloc_context();
    if (sws_init_context(ctx, NULL, NULL) < 0)
        fail();
    randomize_buffers(src, SRC_PIXELS + MAX_FILTER_WIDTH - 1);
    for (hpi = 0; hpi < HSCALE_PAIRS; hpi++) {
        for (fsi = 0; fsi < FILTER_SIZES; fsi++) {
            for (dstWi = 0; dstWi < INPUT_SIZES; dstWi++) {
                width = filter_sizes[fsi];
                ctx->srcBpc = hscale_pairs[hpi][0];
                ctx->dstBpc = hscale_pairs[hpi][1];
                ctx->hLumFilterSize = ctx->hChrFilterSize = width;
                for (i = 0; i < SRC_PIXELS; i++) {
                    filterPos[i] = i;
                    filterPosAvx[i] = i;
                    // These filter cofficients are chosen to try break two corner
                    // cases, namely:
                    //
                    // - Negative filter coefficients. The filters output signed
                    //   values, and it should be possible to end up with negative
                    //   output values.
                    //
                    // - Positive clipping. The hscale filter function has clipping
                    //   at (1<<15) - 1
                    //
                    // The coefficients sum to the 1.0 point for the hscale
                    // functions (1 << 14).
                    for (j = 0; j < width; j++) {
                        filter[i * width + j] = -((1 << 14) / (width - 1));
                    }
                    filter[i * width + (rnd() % width)] = ((1 << 15) - 1);
                }
                for (i = 0; i < MAX_FILTER_WIDTH; i++) {
                    // These values should be unused in SIMD implementations but
                    // may still be read, random coefficients here should help show
                    // issues where they are used in error.
                    filter[SRC_PIXELS * width + i] = rnd();
                }
                ctx->dstW = ctx->chrDstW = input_sizes[dstWi];
                memcpy(filterAvx2, filter, sizeof(uint16_t) * (SRC_PIXELS * MAX_FILTER_WIDTH + MAX_FILTER_WIDTH));
                ff_shuffle_filter_coefficients(ctx, filterPosAvx, width, filterAvx2, ctx->dstW);
                if (check_func(ctx->hcScale, "hscale_%d_to_%d__fs_%d_dstW_%d", ctx->srcBpc, ctx->dstBpc + 1, width, ctx->dstW)) {
                    memset(dst0, 0, SRC_PIXELS * sizeof(dst0[0]));
                    memset(dst1, 0, SRC_PIXELS * sizeof(dst1[0]));
                    call_ref(NULL, dst0, ctx->dstW, src, filter, filterPos, width);
                    call_new(NULL, dst1, ctx->dstW, src, filterAvx2, filterPosAvx, width);
                    if (memcmp(dst0, dst1, ctx->dstW * sizeof(dst0[0])))
                        fail();
                    bench_new(NULL, dst0, ctx->dstW, src, filter, filterPosAvx, width);
                }
            }
        }
    }
    sws_freeContext(ctx);
}
