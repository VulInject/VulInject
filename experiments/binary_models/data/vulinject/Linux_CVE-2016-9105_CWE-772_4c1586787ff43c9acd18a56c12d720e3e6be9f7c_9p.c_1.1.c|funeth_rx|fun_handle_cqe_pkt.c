static void fun_handle_cqe_pkt(struct funeth_rxq *q, struct funeth_txq *xdp_q)
{
	const struct fun_eth_cqe *rxreq = info_to_cqe(q->next_cqe_info);
	unsigned int i, tot_len, pkt_len = be32_to_cpu(rxreq->pkt_len);
	struct net_device *ndev = q->netdev;
	skb_frag_t frags[RX_MAX_FRAGS];
	struct skb_shared_info *si;
	unsigned int headroom;
	gro_result_t gro_res;
	struct sk_buff *skb;
	int ref_ok;
	void *va;
	unsigned short cv;
	u64_stats_update_begin(&q->syncp);
	q->stats.rx_pkts++;
	q->stats.rx_bytes += pkt_len;
	u64_stats_update_end(&q->syncp);
	advance_cq(q);
	tot_len = pkt_len;
	headroom = be16_to_cpu(rxreq->headroom);
	if (likely(headroom))
		tot_len += FUN_RX_TAILROOM + headroom;
	ref_ok = fun_gather_pkt(q, tot_len, frags);
	va = skb_frag_address(frags);
	if (xdp_q && headroom == FUN_XDP_HEADROOM) {
		va = fun_run_xdp(q, frags, va, ref_ok, xdp_q);
		if (!va)
			return;
		headroom = 0;   
	}
	if (unlikely(!ref_ok))
		goto no_mem;
	if (likely(headroom)) {
		prefetch(va + headroom);
		skb = napi_build_skb(va, ALIGN(tot_len, FUN_EPRQ_PKT_ALIGN));
		if (unlikely(!skb))
			goto no_mem;
		__skb_put(skb, pkt_len);
		skb->protocol = eth_type_trans(skb, ndev);
	} else {
		prefetch(va);
		skb = napi_get_frags(q->napi);
		if (unlikely(!skb))
			goto no_mem;
		if (ref_ok < 0)
			skb->pfmemalloc = 1;
		si = skb_shinfo(skb);
		si->nr_frags = rxreq->nsgl;
		for (i = 0; i < si->nr_frags; i++)
			si->frags[i] = frags[i];
		skb->len = pkt_len;
		skb->data_len = pkt_len;
		skb->truesize += round_up(pkt_len, FUN_EPRQ_PKT_ALIGN);
	}
	skb_record_rx_queue(skb, q->qidx);
	cv = be16_to_cpu(rxreq->pkt_cv);
	if (likely((q->netdev->features & NETIF_F_RXHASH) && rxreq->hash))
		skb_set_hash(skb, be32_to_cpu(rxreq->hash),
			     cqe_to_pkt_hash_type(cv));
	if (likely((q->netdev->features & NETIF_F_RXCSUM) && rxreq->csum)) {
		FUN_QSTAT_INC(q, rx_cso);
		skb->ip_summed = CHECKSUM_UNNECESSARY;
		skb->csum_level = be16_to_cpu(rxreq->csum) - 1;
	}
	if (unlikely(rx_hwtstamp_enabled(q->netdev)))
		skb_hwtstamps(skb)->hwtstamp = be64_to_cpu(rxreq->timestamp);
	trace_funeth_rx(q, rxreq->nsgl, pkt_len, skb->hash, cv);
	gro_res = skb->data_len ? napi_gro_frags(q->napi) :
				  napi_gro_receive(q->napi, skb);
	if (gro_res == GRO_MERGED || gro_res == GRO_MERGED_FREE)
		FUN_QSTAT_INC(q, gro_merged);
	else if (gro_res == GRO_HELD)
		FUN_QSTAT_INC(q, gro_pkts);
	return;
no_mem:
	FUN_QSTAT_INC(q, rx_mem_drops);
	q->cur_buf->pg_refs++;
	for (i = 0; i < rxreq->nsgl - 1; i++)
		__free_page(skb_frag_page(frags + i));
}
