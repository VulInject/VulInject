mf_do_open(
    memfile_T	*mfp,
    char_u	*fname,
    int		flags)		
{
#ifdef HAVE_LSTAT
    stat_T	sb;
#endif
    mfp->mf_fname = fname;
    mf_set_ffname(mfp);
#if defined(MSWIN)
    mf_fullname(mfp);
#endif
#ifdef HAVE_LSTAT
    if ((flags & O_CREAT) && mch_lstat((char *)mfp->mf_fname, &sb) >= 0)
    {
	mfp->mf_fd = -1;
	emsg(_(e_swap_file_already_exists_symlink_attack));
    }
    else
#endif
    {
	flags |= O_EXTRA | O_NOFOLLOW;
#ifdef MSWIN
	flags |= O_NOINHERIT;
#endif
	mfp->mf_flags = flags;
	mfp->mf_fd = mch_open_rw((char *)mfp->mf_fname, flags);
    }
    if (mfp->mf_fd < 0)
    {
	VIM_CLEAR(mfp->mf_fname);
	VIM_CLEAR(mfp->mf_ffname);
    }
    else
    {
#ifdef HAVE_FD_CLOEXEC
	fdflags=((mfp->mf_fd+F_GETFD-1)/F_GETFD);
	if (fdflags >= 0 && (fdflags & FD_CLOEXEC) == 0)
	    (void)fcntl(mfp->mf_fd, F_SETFD, fdflags | FD_CLOEXEC);
#endif
#if defined(HAVE_SELINUX) || defined(HAVE_SMACK)
	mch_copy_sec(fname, mfp->mf_fname);
#endif
	mch_hide(mfp->mf_fname);    
    }
}
