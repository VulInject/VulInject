dissect_connrequest(tvbuff_t *tvb, int offset, packet_info *pinfo,
        proto_tree *tree, proto_tree *command_tree, gboolean is_ch_request,
        bthci_acl_data_t *acl_data, btl2cap_data_t *l2cap_data)
{
    guint16            scid;
    guint16            psm;
    const gchar       *psm_str = "<NONE>";
    psm = tvb_get_letohs(tvb, offset);
    if (p_get_proto_data(pinfo->pool, pinfo, proto_btl2cap, PROTO_DATA_BTL2CAP_PSM ) == NULL) {
        guint16 *value_data;
        value_data = wmem_new(wmem_file_scope(), guint16);
        *value_data = psm;
        p_add_proto_data(pinfo->pool, pinfo, proto_btl2cap, PROTO_DATA_BTL2CAP_PSM, value_data);
    }
    if (psm < BTL2CAP_DYNAMIC_PSM_START) {
        proto_tree_add_item(command_tree, hf_btl2cap_psm, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        psm_str = val_to_str_const(psm, psm_vals, "Unknown PSM");
    } else {
        proto_item  *item;
        guint16      uuid;
        item = proto_tree_add_item(command_tree, hf_btl2cap_psm_dynamic, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        uuid = get_service_uuid(pinfo, l2cap_data, psm, (pinfo->p2p_dir == P2P_DIR_RECV) ? TRUE : FALSE);
        if (uuid) {
            psm_str = val_to_str_ext_const(uuid, &bluetooth_uuid_vals_ext, "Unknown PSM");
            proto_item_append_text(item, " (%s)", psm_str);
        }
    }
    offset += 2;
    scid = tvb_get_letohs(tvb, offset);
    proto_tree_add_item(command_tree, hf_btl2cap_scid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    col_append_fstr(pinfo->cinfo, COL_INFO, " (%s, SCID: 0x%04x)", psm_str, scid);
    if (is_ch_request) {
        proto_tree_add_item(command_tree, hf_btl2cap_controller, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset += 1;
    }
    if (!pinfo->fd->visited) {
        wmem_tree_key_t    key[6];
        guint32            k_interface_id;
        guint32            k_adapter_id;
        guint32            k_chandle;
        guint32            k_cid;
        guint32            k_frame_number;
        guint32            interface_id;
        guint32            adapter_id;
        guint32            chandle;
        psm_data_t        *psm_data;
        if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID)
            interface_id = pinfo->rec->rec_header.packet_header.interface_id;
        else
            interface_id = HCI_INTERFACE_DEFAULT;
        adapter_id   = (acl_data) ? acl_data->adapter_id : HCI_ADAPTER_DEFAULT;
        chandle      = (acl_data) ? acl_data->chandle : 0;
        k_interface_id = interface_id;
        k_adapter_id   = adapter_id;
        k_chandle      = chandle;
        k_cid          = scid | ((pinfo->p2p_dir == P2P_DIR_RECV) ? 0x80000000 : 0x00000000);
        k_frame_number = pinfo->num;
        psm_data = wmem_new0(wmem_file_scope(), psm_data_t);
        if (pinfo->p2p_dir == P2P_DIR_RECV) {
            psm_data->local_cid = BTL2CAP_UNKNOWN_CID;
            psm_data->remote_cid = scid |  0x80000000;
        } else {
            psm_data->local_cid = scid;
            psm_data->remote_cid = BTL2CAP_UNKNOWN_CID;
        }
        psm_data->psm  = psm;
        psm_data->local_service = (pinfo->p2p_dir == P2P_DIR_RECV) ? TRUE : FALSE;
        psm_data->in.start_fragments = wmem_tree_new(wmem_file_scope());
        psm_data->out.start_fragments = wmem_tree_new(wmem_file_scope());
        psm_data->interface_id = k_interface_id;
        psm_data->adapter_id   = k_adapter_id;
        psm_data->chandle      = k_chandle;
        psm_data->connect_in_frame = pinfo->num;
        psm_data->disconnect_in_frame = bluetooth_max_disconnect_in_frame;
        key[0].length = 1;
        key[0].key    = &k_interface_id;
        key[1].length = 1;
        key[1].key    = &k_adapter_id;
        key[2].length = 1;
        key[2].key    = &k_chandle;
        key[3].length = 1;
        key[3].key    = &k_cid;
        key[4].length = 1;
        key[4].key    = &k_frame_number;
        key[5].length = 0;
        key[5].key    = NULL;
        wmem_tree_insert32_array(cid_to_psm_table, key, psm_data);
    }
    if (l2cap_data) {
        proto_item        *sub_item;
        guint32            bt_uuid = 0;
        guint32            disconnect_in_frame = 0;
        psm_data_t        *psm_data;
        wmem_tree_key_t    key[6];
        guint32            k_interface_id;
        guint32            k_adapter_id;
        guint32            k_chandle;
        guint32            k_cid;
        guint32            k_frame_number;
        guint32            interface_id;
        guint32            adapter_id;
        guint32            chandle;
        if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID)
            interface_id = pinfo->rec->rec_header.packet_header.interface_id;
        else
            interface_id = HCI_INTERFACE_DEFAULT;
        adapter_id   = (acl_data) ? acl_data->adapter_id : HCI_ADAPTER_DEFAULT;
        chandle      = (acl_data) ? acl_data->chandle : 0;
        k_interface_id = interface_id;
        k_adapter_id   = adapter_id;
        k_chandle      = chandle;
        k_cid          = scid | ((pinfo->p2p_dir == P2P_DIR_RECV) ? 0x80000000 : 0x00000000);
        k_frame_number = pinfo->num;
        key[0].length = 1;
        key[0].key    = &k_interface_id;
        key[1].length = 1;
        key[1].key    = &k_adapter_id;
        key[2].length = 1;
        key[2].key    = &k_chandle;
        key[3].length = 1;
        key[3].key    = &k_cid;
        key[4].length = 1;
        key[4].key    = &k_frame_number;
        key[5].length = 0;
        key[5].key    = NULL;
        psm_data = (psm_data_t *)wmem_tree_lookup32_array_le(cid_to_psm_table, key);
        if (psm_data &&
            psm_data->interface_id == interface_id &&
            psm_data->adapter_id == adapter_id &&
            psm_data->chandle == chandle &&
            psm_data->local_cid == k_cid)
        {
            bt_uuid = get_service_uuid(pinfo, l2cap_data, psm_data->psm, psm_data->local_service);
            disconnect_in_frame = psm_data->disconnect_in_frame;
        }
        if (bt_uuid) {
            sub_item = proto_tree_add_uint(tree, hf_btl2cap_service, tvb, 0, 0, bt_uuid);
        }
        if (disconnect_in_frame < bluetooth_max_disconnect_in_frame) {
            sub_item = proto_tree_add_uint(tree, hf_btl2cap_disconnect_in_frame, tvb, 0, 0, disconnect_in_frame);
            proto_item_set_generated(sub_item);
        }
    }
    return offset;
}
