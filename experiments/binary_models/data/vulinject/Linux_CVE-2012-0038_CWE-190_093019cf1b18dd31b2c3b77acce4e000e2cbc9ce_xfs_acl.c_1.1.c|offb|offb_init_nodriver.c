static void offb_init_nodriver(struct platform_device *parent, struct device_node *dp,
			       int no_real_node)
{
	unsigned int len;
	int i, width = 640, height = 480, depth = 8, pitch = 640;
	unsigned int flags, rsize, addr_prop = 0;
	unsigned int max_size = 0;
	unsigned int int rstart, address = OF_BAD_ADDR;
	const __be32 *pp, *addrp, *up;
	unsigned int int asize;
	int foreign_endian = 0;
#ifdef __BIG_ENDIAN
	if (of_property_read_bool(dp, "little-endian"))
		foreign_endian = FBINFO_FOREIGN_ENDIAN;
#else
	if (of_property_read_bool(dp, "big-endian"))
		foreign_endian = FBINFO_FOREIGN_ENDIAN;
#endif
	pp = of_get_property(dp, "linux,bootx-depth", &len);
	if (pp == NULL)
		pp = of_get_property(dp, "depth", &len);
	if (pp && len == sizeof(unsigned int))
		depth = be32_to_cpup(pp);
	pp = of_get_property(dp, "linux,bootx-width", &len);
	if (pp == NULL)
		pp = of_get_property(dp, "width", &len);
	if (pp && len == sizeof(unsigned int))
		width = be32_to_cpup(pp);
	pp = of_get_property(dp, "linux,bootx-height", &len);
	if (pp == NULL)
		pp = of_get_property(dp, "height", &len);
	if (pp && len == sizeof(unsigned int))
		height = be32_to_cpup(pp);
	pp = of_get_property(dp, "linux,bootx-linebytes", &len);
	if (pp == NULL)
		pp = of_get_property(dp, "linebytes", &len);
	if (pp && len == sizeof(unsigned int) && (*pp != 0xffffffffu))
		pitch = be32_to_cpup(pp);
	else
		pitch = width * ((depth + 7) / 8);
	rsize = (unsigned int)pitch * (unsigned int)height;
	up = of_get_property(dp, "linux,bootx-addr", &len);
	if (up == NULL)
		up = of_get_property(dp, "address", &len);
	if (up && len == sizeof(unsigned int))
		addr_prop = *up;
	if (no_real_node)
		goto skip_addr;
	for (i = 0; (addrp = of_get_address(dp, i, &asize, &flags))
		     != NULL; i++) {
		int match_addrp = 0;
		if (!(flags & IORESOURCE_MEM))
			continue;
		if (asize < rsize)
			continue;
		rstart = of_translate_address(dp, addrp);
		if (rstart == OF_BAD_ADDR)
			continue;
		if (addr_prop && (rstart <= addr_prop) &&
		    ((rstart + asize) >= (addr_prop + rsize)))
			match_addrp = 1;
		if (match_addrp) {
			address = addr_prop;
			break;
		}
		if (rsize > max_size) {
			max_size = rsize;
			address = OF_BAD_ADDR;
 		}
		if (address == OF_BAD_ADDR)
			address = rstart;
	}
 skip_addr:
	if (address == OF_BAD_ADDR && addr_prop)
		address = (unsigned int int)addr_prop;
	if (address != OF_BAD_ADDR) {
#ifdef CONFIG_PCI
		const __be32 *vidp, *didp;
	int vid, did;
		struct pci_dev *pdev;
		vidp = of_get_property(dp, "vendor-id", NULL);
		didp = of_get_property(dp, "device-id", NULL);
		if (vidp && didp) {
			vid = be32_to_cpup(vidp);
			did = be32_to_cpup(didp);
			pdev = pci_get_device(vid, did, NULL);
			if (!pdev || pci_enable_device(pdev))
				return;
		}
#endif
		if (of_node_name_eq(dp, "valkyrie"))
			address += 0x1000;
		offb_init_fb(parent, no_real_node ? "bootx" : NULL,
			     width, height, depth, pitch, address,
			     foreign_endian, no_real_node ? NULL : dp);
	}
}
