int file_chunk_cdc(int fd_src,
                   CDCFileDescriptor *file_descr,
                   SeafileCrypt *crypt,
                   gboolean write_data)
{
    char *buf = NULL;
    unsigned int buf_sz;
    GChecksum *file_ctx = g_checksum_new (G_CHECKSUM_SHA1);
    CDCDescriptor chunk_descr;
    int ret = 0;
    SeafStat sb;
    if (seaf_fstat (fd_src, &sb) < 0) {
        seaf_warning ("CDC: failed to stat: %s.\n", strerror(errno));
        ret = -1;
        goto out;
    }
    unsigned int int expected_size = sb.st_size;
    init_cdc_file_descriptor (fd_src, expected_size, file_descr);
    unsigned int block_min_sz = file_descr->block_min_sz;
    unsigned int block_mask = file_descr->block_sz - 1;
    int fingerprint = 0;
    int offset = 0;
    int tail, cur, rsize;
    buf_sz = file_descr->block_max_sz;
    buf = chunk_descr.block_buf = malloc (buf_sz);
    if (!buf) {
        ret = -1;
        goto out;
    }
    tail = cur = 0;
    while (1) {
        if (tail < block_min_sz) {
            rsize = block_min_sz - tail + READ_SIZE;
        } else {
            rsize = (buf_sz - tail < READ_SIZE) ? (buf_sz - tail) : READ_SIZE;
        }
        ret = readn (fd_src, buf + tail, rsize);
        if (ret < 0) {
            seaf_warning ("CDC: failed to read: %s.\n", strerror(errno));
            ret = -1;
            goto out;
        }
        tail += ret;
        file_descr->file_size += ret;
        if (file_descr->file_size > expected_size) {
            seaf_warning ("File size changed while chunking.\n");
            ret = -1;
            goto out;
        }
        if (tail < block_min_sz || cur >= tail) {
            if (tail > 0) {
                if (file_descr->block_nr == file_descr->max_block_nr) {
                    seaf_warning ("Block id array is not large enough, bail out.\n");
                    ret = -1;
                    goto out;
                }
            }
            break;
        }
        if (cur < block_min_sz - 1)
            cur = block_min_sz - 1;
        while (cur < tail) {
            fingerprint = (cur == block_min_sz - 1) ?
                finger(buf + cur - BLOCK_WIN_SZ + 1, BLOCK_WIN_SZ) :
                rolling_finger (fingerprint, BLOCK_WIN_SZ, 
                                *(buf+cur-BLOCK_WIN_SZ), *(buf + cur));
            if (((fingerprint & block_mask) ==  ((BREAK_VALUE & block_mask)))
                || cur + 1 >= file_descr->block_max_sz)
            {
                if (file_descr->block_nr == file_descr->max_block_nr) {
                    seaf_warning ("Block id array is not large enough, bail out.\n");
                    ret = -1;
                    goto out;
                }
                WRITE_CDC_BLOCK (cur + 1, write_data);
                break;
            } else {
                cur ++;
            }
        }
    }
    gsize chk_sum_len = CHECKSUM_LENGTH;
    g_checksum_get_digest (file_ctx, file_descr->file_sum, &chk_sum_len);
out:
    free (buf);
    g_checksum_free (file_ctx);
    return ret;
}
