xchk_inobt_xref_finobt(
	struct xfs_scrub	*sc,
	struct xfs_inobt_rec_incore *irec,
	xfs_agino_t		agino,
	bool			free,
	bool			hole)
{
	struct xfs_inobt_rec_incore frec;
	struct xfs_btree_cur	*cur = sc->sa.fino_cur;
	int ffree, fhole;
	unsigned int		frec_idx, fhole_idx;
	int			has_record;
	int			error;
	ASSERT(xfs_btree_is_fino(cur->bc_ops));
	error = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &has_record);
	if (error)
		return error;
	if (!has_record)
		goto no_record;
	error = xfs_inobt_get_rec(cur, &frec, &has_record);
	if (!has_record)
		return -EFSCORRUPTED;
	if (frec.ir_startino + XFS_INODES_PER_CHUNK <= agino)
		goto no_record;
	frec_idx = agino - frec.ir_startino;
	ffree = frec.ir_free & (1ULL << frec_idx);
	fhole_idx = frec_idx / XFS_INODES_PER_HOLEMASK_BIT;
	fhole = frec.ir_holemask & (1U << fhole_idx);
	if (ffree != free)
		xchk_btree_xref_set_corrupt(sc, cur, 0);
	if (fhole != hole)
		xchk_btree_xref_set_corrupt(sc, cur, 0);
	return 0;
no_record:
	if (irec->ir_free == 0)
		return 0;
	if (irec->ir_free == XFS_INOBT_ALL_FREE)
		return 0;
	if (hole)
		return 0;
	if (!free)
		return 0;
	xchk_btree_xref_set_corrupt(sc, cur, 0);
	return 0;
}
