  t42_parse_sfnts( FT_Face  face,
                   void*    loader_ )
  {
    T42_Face    t42face = (T42_Face)face;
    T42_Loader  loader  = (T42_Loader)loader_;
    T42_Parser  parser = &loader->parser;
    FT_Memory   memory = parser->root.memory;
    FT_Byte*    cur;
    FT_Byte*    limit  = parser->root.limit;
    FT_Error    error;
    FT_Int      num_tables = 0;
    FT_Long     ttf_count;
    FT_Long     ttf_reserved;
    FT_ULong    n, string_size, old_string_size, real_size;
    FT_Byte*    string_buf = NULL;
    FT_Bool     allocated  = 0;
    T42_Load_Status  status;
    FT_FREE( t42face->ttf_data );
    t42face->ttf_size = 0;
    if ( parser->root.cursor >= limit || *parser->root.cursor++ != '[' )
    {
      FT_ERROR(( "t42_parse_sfnts: can't find begin of sfnts vector\n" ));
      error = FT_THROW( Invalid_File_Format );
      goto Fail;
    }
    T1_Skip_Spaces( parser );
    status          = BEFORE_START;
    string_size     = 0;
    old_string_size = 0;
    ttf_count       = 0;
    ttf_reserved    = 12;
    if ( FT_QALLOC( t42face->ttf_data, ttf_reserved ) )
      goto Fail;
    FT_TRACE2(( "\n" ));
    FT_TRACE2(( "t42_parse_sfnts:\n" ));
    while ( parser->root.cursor < limit )
    {
      FT_ULong  size;
      cur = parser->root.cursor;
      if ( *cur == ']' )
      {
        parser->root.cursor++;
        t42face->ttf_size = ttf_count;
        goto Exit;
      }
      else if ( *cur == '<' )
      {
        if ( string_buf && !allocated )
        {
          FT_ERROR(( "t42_parse_sfnts: "
                     "can't handle mixed binary and hex strings\n" ));
          error = FT_THROW( Invalid_File_Format );
          goto Fail;
        }
        T1_Skip_PS_Token( parser );
        if ( parser->root.error )
          goto Exit;
        string_size = (FT_ULong)( ( parser->root.cursor - cur - 2 + 1 ) / 2 );
        if ( !string_size )
        {
          FT_ERROR(( "t42_parse_sfnts: invalid data in sfnts array\n" ));
          error = FT_THROW( Invalid_File_Format );
          goto Fail;
        }
        if ( FT_QREALLOC( string_buf, old_string_size, string_size ) )
          goto Fail;
        allocated = 1;
        parser->root.cursor = cur;
        (void)T1_ToBytes( parser, string_buf, string_size, &real_size, 1 );
        old_string_size = string_size;
        string_size     = real_size;
      }
      else if ( ft_isdigit( *cur ) )
      {
        FT_Long  tmp;
        if ( allocated )
        {
          FT_ERROR(( "t42_parse_sfnts: "
                     "can't handle mixed binary and hex strings\n" ));
          error = FT_THROW( Invalid_File_Format );
          goto Fail;
        }
        tmp = T1_ToInt( parser );
        if ( tmp < 0 )
        {
          FT_ERROR(( "t42_parse_sfnts: invalid string size\n" ));
          error = FT_THROW( Invalid_File_Format );
          goto Fail;
        }
        else
          string_size = (FT_ULong)tmp;
        T1_Skip_PS_Token( parser );             
        if ( parser->root.error )
          return;
        string_buf = parser->root.cursor + 1;   
        if ( (FT_ULong)( limit - parser->root.cursor ) <= string_size )
        {
          FT_ERROR(( "t42_parse_sfnts: too much binary data\n" ));
          error = FT_THROW( Invalid_File_Format );
          goto Fail;
        }
        else
          parser->root.cursor += string_size + 1;
      }
      if ( !string_buf )
      {
        FT_ERROR(( "t42_parse_sfnts: invalid data in sfnts array\n" ));
        error = FT_THROW( Invalid_File_Format );
        goto Fail;
      }
      if ( ( string_size & 1 ) && string_buf[string_size - 1] == 0 )
        string_size--;
      if ( !string_size )
      {
        FT_ERROR(( "t42_parse_sfnts: invalid string\n" ));
        error = FT_THROW( Invalid_File_Format );
        goto Fail;
      }
      FT_TRACE2(( "  PS string size %5lu bytes, offset 0x%08lx (%lu)\n",
                  string_size, ttf_count, ttf_count ));
      size = (FT_ULong)( limit - parser->root.cursor );
      for ( n = 0; n < string_size; n++ )
      {
        switch ( status )
        {
        case BEFORE_START:
          if ( ttf_count < 12 )
          {
            t42face->ttf_data[ttf_count++] = string_buf[n];
            continue;
          }
          else
          {
            FT_Long ttf_reserved_prev = ttf_reserved;
            num_tables   = 16 * t42face->ttf_data[4] + t42face->ttf_data[5];
            status       = BEFORE_TABLE_DIR;
            ttf_reserved = 12 + 16 * num_tables;
            FT_TRACE2(( "  SFNT directory contains %d tables\n",
                        num_tables ));
            if ( (FT_Long)size < ttf_reserved )
            {
              FT_ERROR(( "t42_parse_sfnts: invalid data in sfnts array\n" ));
              error = FT_THROW( Invalid_File_Format );
              goto Fail;
            }
            if ( FT_QREALLOC( t42face->ttf_data, ttf_reserved_prev,
                              ttf_reserved ) )
              goto Fail;
          }
          FALL_THROUGH;
        case BEFORE_TABLE_DIR:
          if ( ttf_count < ttf_reserved )
          {
            t42face->ttf_data[ttf_count++] = string_buf[n];
            continue;
          }
          else
          {
            int       i;
            FT_ULong  len;
            FT_Long ttf_reserved_prev = ttf_reserved;
            FT_TRACE2(( "\n" ));
            FT_TRACE2(( "  table    length\n" ));
            FT_TRACE2(( "  ------------------------------\n" ));
            for ( i = 0; i < num_tables; i++ )
            {
              FT_Byte*  p = t42face->ttf_data + 12 + 16 * i + 12;
              len = FT_PEEK_ULONG( p );
              FT_TRACE2(( "   %4i  0x%08lx (%lu)\n", i, len, len ));
              if ( len > size                               ||
                   ttf_reserved > (FT_Long)( size - len ) )
              {
                FT_ERROR(( "t42_parse_sfnts:"
                           " invalid data in sfnts array\n" ));
                error = FT_THROW( Invalid_File_Format );
                goto Fail;
              }
              ttf_reserved += (FT_Long)( ( len + 3 ) & ~3U );
            }
            ttf_reserved += 1;
            status = OTHER_TABLES;
            FT_TRACE2(( "\n" ));
            FT_TRACE2(( "  allocating %ld bytes\n", ttf_reserved ));
            FT_TRACE2(( "\n" ));
            if ( FT_QREALLOC( t42face->ttf_data, ttf_reserved_prev,
                              ttf_reserved ) )
              goto Fail;
          }
          FALL_THROUGH;
        case OTHER_TABLES:
          if ( ttf_count >= ttf_reserved )
          {
            FT_ERROR(( "t42_parse_sfnts: too much binary data\n" ));
            error = FT_THROW( Invalid_File_Format );
            goto Fail;
          }
          t42face->ttf_data[ttf_count++] = string_buf[n];
        }
      }
      T1_Skip_Spaces( parser );
    }
    error = FT_THROW( Invalid_File_Format );
  Fail:
    parser->root.error = error;
  Exit:
    if ( parser->root.error )
    {
      FT_FREE( t42face->ttf_data );
      t42face->ttf_size = 0;
    }
    if ( allocated )
      FT_FREE( string_buf );
  }
