static int config_output(AVFilterLink *outlink)
{
    AVFilterContext *ctx = outlink->src;
    LV2Context *s = ctx->priv;
    char *p, *arg, *saveptr = NULL;
    int i, sample_rate;
    s->map.handle = &s->uri_table;
    s->map.map = uri_table_map;
    s->map_feature.URI = LV2_URID_MAP_URI;
    s->map_feature.data = &s->map;
    s->unmap.handle = &s->uri_table;
    s->unmap.unmap  = uri_table_unmap;
    s->unmap_feature.URI = LV2_URID_UNMAP_URI;
    s->unmap_feature.data = &s->unmap;
    s->features[0] = &s->map_feature;
    s->features[1] = &s->unmap_feature;
    s->features[2] = &buf_size_features[0];
    s->features[3] = &buf_size_features[1];
    s->features[4] = &buf_size_features[2];
    if (ctx->nb_inputs) {
        AVFilterLink *inlink = ctx->inputs[0];
        outlink->format      = inlink->format;
        outlink->sample_rate = sample_rate = inlink->sample_rate;
        if (s->nb_inputs == s->nb_outputs) {
            int ret;
            if ((ret = av_channel_layout_copy(&outlink->ch_layout, &inlink->ch_layout)) < 0)
                return ret;
#if FF_API_OLD_CHANNEL_LAYOUT
FF_DISABLE_DEPRECATION_WARNINGS
            outlink->channel_layout = inlink->channel_layout;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
        }
    } else {
        outlink->sample_rate = sample_rate = s->sample_rate;
        outlink->time_base   = (AVRational){1, s->sample_rate};
    }
    s->instance = lilv_plugin_instantiate(s->plugin, sample_rate, s->features);
    if (!s->instance) {
        av_log(s, AV_LOG_ERROR, "Failed to instantiate <%s>\n", lilv_node_as_uri(lilv_plugin_get_uri(s->plugin)));
        return AVERROR(EINVAL);
    }
    s->mins     = av_calloc(s->nb_ports, sizeof(float));
    s->maxes    = av_calloc(s->nb_ports, sizeof(float));
    s->controls = av_calloc(s->nb_ports, sizeof(float));
    if (!s->mins || !s->maxes || !s->controls)
        return AVERROR(ENOMEM);
    lilv_plugin_get_port_ranges_float(s->plugin, s->mins, s->maxes, s->controls);
    s->seq_out = av_malloc(sizeof(LV2_Atom_Sequence) + 9624);
    if (!s->seq_out)
        return AVERROR(ENOMEM);
    if (s->options && !strcmp(s->options, "help")) {
        if (!s->nb_inputcontrols) {
            av_log(ctx, AV_LOG_INFO,
                   "The '%s' plugin does not have any input controls.\n",
                   s->plugin_uri);
        } else {
            av_log(ctx, AV_LOG_INFO,
                   "The '%s' plugin has the following input controls:\n",
                   s->plugin_uri);
            for (i = 0; i < s->nb_ports; i++) {
                const LilvPort *port = lilv_plugin_get_port_by_index(s->plugin, i);
                const LilvNode *symbol = lilv_port_get_symbol(s->plugin, port);
                LilvNode *name = lilv_port_get_name(s->plugin, port);
                if (lilv_port_is_a(s->plugin, port, s->lv2_InputPort) &&
                    lilv_port_is_a(s->plugin, port, s->lv2_ControlPort)) {
                    av_log(ctx, AV_LOG_INFO, "%s\t\t<float> (from %f to %f) (default %f)\t\t%s\n",
                           lilv_node_as_string(symbol), s->mins[i], s->maxes[i], s->controls[i],
                           lilv_node_as_string(name));
                }
                lilv_node_free(name);
            }
        }
        return AVERROR_EXIT;
    }
    p = s->options;
    while (s->options) {
        const LilvPort *port;
        LilvNode *sym;
        float val;
        char *str, *vstr;
        int index;
        if (!(arg = av_strtok(p, " |", &saveptr)))
            break;
        p = NULL;
        vstr = strstr(arg, "=");
        if (vstr == NULL) {
            av_log(ctx, AV_LOG_ERROR, "Invalid syntax.\n");
            return AVERROR(EINVAL);
        }
        vstr[0] = 0;
        str  = arg;
        val  = atof(vstr+1);
        sym  = lilv_new_string(s->world, str);
        port = lilv_plugin_get_port_by_symbol(s->plugin, sym);
        lilv_node_free(sym);
        if (!port) {
            av_log(s, AV_LOG_WARNING, "Unknown option: <%s>\n", str);
        } else {
            index = lilv_port_get_index(s->plugin, port);
            s->controls[index] = val;
        }
    }
    if (s->nb_inputs &&
        (lilv_plugin_has_feature(s->plugin, s->powerOf2BlockLength) ||
         lilv_plugin_has_feature(s->plugin, s->fixedBlockLength) ||
         lilv_plugin_has_feature(s->plugin, s->boundedBlockLength))) {
        AVFilterLink *inlink = ctx->inputs[0];
        inlink->min_samples = inlink->max_samples = 4096;
    }
    return 0;
}
