static irqreturn_t i2c_irq_handler(int irq, void *arg)
{
	struct nmk_i2c_dev *priv = arg;
	struct device *dev = &priv->adev->dev;
	unsigned int tft, rft;
	unsigned int count;
	unsigned int misr, src;
	tft = readl(priv->virtbase + I2C_TFTR);
	rft = readl(priv->virtbase + I2C_RFTR);
	misr = readl(priv->virtbase + I2C_MISR);
	src = __ffs(misr);
	switch (BIT(src)) {
	case I2C_IT_TXFNE:
	{
		if (priv->cli.operation == I2C_READ) {
		} else {
			fill_tx_fifo(priv, (MAX_I2C_FIFO_THRESHOLD - tft));
			if (priv->cli.count == 0)
				disable_interrupts(priv,	I2C_IT_TXFNE);
		}
	}
	break;
	case I2C_IT_RXFNF:
		for (count = rft; count > 0; count--) {
			*priv->cli.buffer = nmk_i2c_readb(priv, I2C_RFR);
			priv->cli.buffer++;
		}
		priv->cli.count -= rft;
		priv->cli.xfer_bytes += rft;
		break;
	case I2C_IT_RXFF:
		for (count = MAX_I2C_FIFO_THRESHOLD; count > 0; count--) {
			*priv->cli.buffer = nmk_i2c_readb(priv, I2C_RFR);
			priv->cli.buffer++;
		}
		priv->cli.count -= MAX_I2C_FIFO_THRESHOLD;
		priv->cli.xfer_bytes += MAX_I2C_FIFO_THRESHOLD;
		break;
	case I2C_IT_MTD:
	case I2C_IT_MTDWS:
		if (priv->cli.operation == I2C_READ) {
			while (!(readl(priv->virtbase + I2C_RISR)
				 & I2C_IT_RXFE)) {
				if (priv->cli.count == 0)
					break;
				*priv->cli.buffer =
					nmk_i2c_readb(priv, I2C_RFR);
				priv->cli.buffer++;
				priv->cli.count--;
				priv->cli.xfer_bytes++;
			}
		}
		disable_all_interrupts(priv);
		clear_all_interrupts(priv);
		if (priv->cli.count) {
			priv->result = -EIO;
			dev_err(dev, "%lu bytes still remain to be xfered\n",
				priv->cli.count);
			init_hw(priv);
		}
		priv->xfer_done = true;
		wake_up(&priv->xfer_wq);
		break;
	case I2C_IT_MAL:
		priv->result = -EIO;
		init_hw(priv);
		i2c_set_bit(priv->virtbase + I2C_ICR, I2C_IT_MAL);
		priv->xfer_done = true;
		wake_up(&priv->xfer_wq);
		break;
	case I2C_IT_BERR:
	{
		unsigned int sr;
		sr = readl(priv->virtbase + I2C_SR);
		priv->result = -EIO;
		if (FIELD_GET(I2C_SR_STATUS, sr) == I2C_ABORT)
			init_hw(priv);
		i2c_set_bit(priv->virtbase + I2C_ICR, I2C_IT_BERR);
		priv->xfer_done = true;
		wake_up(&priv->xfer_wq);
	}
	break;
	case I2C_IT_TXFOVR:
		priv->result = -EIO;
		init_hw(priv);
		dev_err(dev, "Tx Fifo Over run\n");
		priv->xfer_done = true;
		wake_up(&priv->xfer_wq);
		break;
	case I2C_IT_TXFE:
	case I2C_IT_TXFF:
	case I2C_IT_RXFE:
	case I2C_IT_RFSR:
	case I2C_IT_RFSE:
	case I2C_IT_WTSR:
	case I2C_IT_STD:
		dev_err(dev, "unhandled Interrupt\n");
		break;
	default:
		dev_err(dev, "spurious Interrupt..\n");
		break;
	}
	return IRQ_HANDLED;
}
