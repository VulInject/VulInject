init_tpncp_data_fields_info(tpncp_data_field_info *data_fields_info, FILE *file)
{
    static gboolean was_registered = FALSE;
    gchar tpncp_db_entry[MAX_TPNCP_DB_ENTRY_LEN];
    gchar entry_copy[MAX_TPNCP_DB_ENTRY_LEN];
    const gchar *name = NULL, *tmp = NULL;
    gint enum_val, data_id, current_data_id = -1, array_dim;
    guchar size;
    enum SpecialFieldType special_type;
    gboolean sign, is_address_family;
    guint idx, since, ip_addr_field;
    tpncp_data_field_info *field = NULL;
    hf_register_info hf_entr;
    gboolean* registered_struct_ids = wmem_alloc0_array(wmem_epan_scope(), gboolean, MAX_TPNCP_DB_SIZE);
    static hf_register_info hf_tpncp[] = {
        {
            &hf_tpncp_version,
            {
                "Version",
                "tpncp.version",
                FT_UINT16,
                BASE_DEC,
                NULL,
                0x0,
                NULL, HFILL
            }
        },
        {
            &hf_tpncp_length,
            {
                "Length",
                "tpncp.length",
                FT_UINT16,
                BASE_DEC,
                NULL,
                0x0,
                NULL, HFILL
            }
        },
        {
            &hf_tpncp_seq_number,
            {
                "Sequence number",
                "tpncp.seq_number",
                FT_UINT16,
                BASE_DEC,
                NULL,
                0x0,
                NULL, HFILL
            }
        },
        {
            &hf_tpncp_length_ext,
            {
                "Length Extension",
                "tpncp.lengthextension",
                FT_UINT8,
                BASE_DEC,
                NULL,
                0x0,
                NULL, HFILL
            }
        },
        {
            &hf_tpncp_reserved,
            {
                "Reserved",
                "tpncp.reserved",
                FT_UINT8,
                BASE_DEC,
                NULL,
                0x0,
                NULL, HFILL
            }
        },
        {
            &hf_tpncp_command_id,
            {
                "Command ID",
                "tpncp.command_id",
                FT_UINT32,
                BASE_DEC,
                VALS(tpncp_commands_id_vals),
                0x0,
                NULL, HFILL
            }
        },
        {
            &hf_tpncp_event_id,
            {
                "Event ID",
                "tpncp.event_id",
                FT_UINT32,
                BASE_DEC,
                VALS(tpncp_events_id_vals),
                0x0,
                NULL, HFILL
            }
        },
        {
            &hf_tpncp_cid,
            {
                "Channel ID",
                "tpncp.channel_id",
                FT_INT32,
                BASE_DEC,
                NULL,
                0x0,
                NULL, HFILL
            }
        }
    };
    hf_entr.hfinfo.type = FT_NONE;
    hf_entr.hfinfo.strings = NULL;
    hf_entr.hfinfo.bitmask = 0x0;
    hf_entr.hfinfo.blurb = NULL;
    if (!was_registered) {
        void *newbuf;
        hf_allocated = hf_size + (int) array_length(hf_tpncp);
        newbuf = wmem_realloc(wmem_epan_scope(), hf, hf_allocated * sizeof (hf_register_info));
        if (!newbuf)
            return -1;
        hf = (hf_register_info *) newbuf;
        for (idx = 0; idx < array_length(hf_tpncp); idx++) {
            memcpy(hf + hf_size, hf_tpncp + idx, sizeof (hf_register_info));
            hf_size++;
        }
        was_registered = TRUE;
    }
    is_address_family = FALSE;
    ip_addr_field = 0;
    while (fgetline(tpncp_db_entry, MAX_TPNCP_DB_ENTRY_LEN, file)) {
        special_type = TPNCP_NORMAL;
        since = 0;
        snprintf(entry_copy, MAX_TPNCP_DB_ENTRY_LEN, "%s", tpncp_db_entry);
        if (!strncmp(tpncp_db_entry, "#####", 5))
            break;
        hf_entr.hfinfo.display = BASE_DEC;
        if ((tmp = strtok(tpncp_db_entry, " ")) == NULL) {
            report_failure(
                "ERROR! Badly formed data base entry: %s - corresponding field's registration is skipped.",
                entry_copy);
            continue;
        }
        data_id = (gint) g_ascii_strtoll(tmp, NULL, 10);
        if ((name = strtok(NULL, " ")) == NULL) {
            report_failure(
                "ERROR! Badly formed data base entry: %s - corresponding field's registration is skipped.",
                entry_copy);
            continue;
        }
        if (g_ascii_isdigit(*name)) {
            tmp = name;
            name = "unnamed";
        } else {
            if ((tmp = strtok(NULL, " ")) == NULL) {
                report_failure(
                    "ERROR! Badly formed data base entry: %s - corresponding field's registration is skipped.",
                    entry_copy);
                continue;
            }
        }
        if (name[0] == 'c' && !strcmp(name, "cmd_rev_lsb"))
            special_type = TPNCP_OPEN_CHANNEL_START;
        else if (name[0] == 'r' && !strcmp(name, "rtp_authentication_algorithm"))
            special_type = TPNCP_SECURITY_START;
        else if (name[0] == 's' && !strcmp(name, "security_cmd_offset"))
            special_type = TPNCP_SECURITY_OFFSET;
        else if (data_id != 1611 && name[0] == 's' && !strcmp(name, "ssrc"))
            special_type = RTP_STATE_START;
        else if (name[0] == 'r' && !strcmp(name, "rtp_tx_state_ssrc"))
            special_type = RTP_STATE_START;
        else if (name[0] == 'r' && !strcmp(name, "rtp_state_offset"))
            special_type = RTP_STATE_OFFSET;
        else if (name[0] == 's' && !strcmp(name, "state_update_time_stamp"))
            special_type = RTP_STATE_END;
        else if (data_id == 1611 && name[0] == 'c' && strstr(name, "configuration_type_updated"))
            special_type = TPNCP_CHANNEL_CONFIGURATION;
        else if ((data_id == 4 && strstr(name, "secondary_rtp_seq_num")) ||
                 (data_id == 1611 && strstr(name, "dtls_remote_fingerprint_alg"))) {
            since = 7401;
        }
        sign = !!((gboolean) g_ascii_strtoll(tmp, NULL, 10));
        if ((tmp = strtok(NULL, " ")) == NULL) {
            report_failure(
                "ERROR! Badly formed data base entry: %s - corresponding field's registration is skipped.",
                entry_copy);
            continue;
        }
        size = (guchar) g_ascii_strtoll(tmp, NULL, 10);
        if ((tmp = strtok(NULL, " ")) == NULL) {
            report_failure(
                "ERROR! Badly formed data base entry: %s - corresponding field's registration is skipped.",
                entry_copy);
            continue;
        }
        array_dim = (gint) g_ascii_strtoll(tmp, NULL, 10);
        if ((tmp = strtok(NULL, " ")) == NULL) {
            report_failure(
                "ERROR! Badly formed data base entry: %s - corresponding field's registration is skipped.",
                entry_copy);
            continue;
        }
        if (sign && g_ascii_strtoll(tmp, NULL, 10))
            special_type = TPNCP_IP_ADDR;
        if ((tmp = strtok(NULL, "\n")) == NULL) {
            report_failure(
                "ERROR! Badly formed data base entry: %s - corresponding field's registration is skipped.",
                entry_copy);
            continue;
        }
        if (ip_addr_field > 0) {
            char *seq = (char*)name + strlen(name) - 2;
            --ip_addr_field;
            if (seq > name && *seq == '_') {
                if (seq[1] >= '1' && seq[1] <= '3')
                    continue;
                if (is_address_family) {
                    *seq = 0;
                    size = 128;
                    special_type = TPNCP_IP_ADDR;
                } else {
                    report_warning("Bad address form. Field name: %s", name);
                    ip_addr_field = 0;
                }
            }
        }
        is_address_family = FALSE;
        if (current_data_id != data_id) { 
            if (data_id >= MAX_TPNCP_DB_SIZE) {
                report_failure("ERROR! The data_id %d is too large.", data_id);
                continue;
            }
            if (registered_struct_ids[data_id] == TRUE) {
                report_failure(
                    "ERROR! The data_id %d already registered. Cannot register two identical events/command",
                    data_id);
                continue;
            }
            registered_struct_ids[data_id] = TRUE;
            field = &data_fields_info[data_id];
            current_data_id = data_id;
        } else {
            field->p_next = wmem_new(wmem_epan_scope(), tpncp_data_field_info);
            if (!field->p_next)
                return (-1);
            field = field->p_next;
            field->p_next = NULL;
        }
        if (strcmp(tmp, "primitive")) {
            enum_val = get_enum_name_val(tmp);
            if (enum_val == -1) {
                hf_entr.hfinfo.strings = NULL;
            } else {
                hf_entr.hfinfo.strings = VALS(tpncp_enums_id_vals[enum_val]);
                if (!strcmp(tmp, "AddressFamily")) {
                    is_address_family = TRUE;
                    ip_addr_field = 4;
                }
            }
        } else {
            hf_entr.hfinfo.strings = NULL;
        }
        field->descr = -1;
        field->ipv6_descr = -1;
        hf_entr.p_id = &field->descr;
        field->name = wmem_strdup_printf(wmem_epan_scope(), "tpncp.%s", name);
        hf_entr.hfinfo.name = field->name;
        hf_entr.hfinfo.abbrev = field->name;
        switch (size) {
        case 1: case 2: case 3: case 4:
        case 5: case 6: case 7: case 8:
            if (array_dim) {
                hf_entr.hfinfo.type = FT_STRING;
                hf_entr.hfinfo.display = BASE_NONE;
            } else {
                hf_entr.hfinfo.type = (sign) ? FT_UINT8 : FT_INT8;
            }
            break;
        case 16:
            hf_entr.hfinfo.type = (sign) ? FT_UINT16 : FT_INT16;
            break;
        case 32:
            if (special_type == TPNCP_IP_ADDR) {
                hf_entr.hfinfo.display = BASE_NONE;
                hf_entr.hfinfo.type = FT_IPv4;
            } else {
                hf_entr.hfinfo.type = (sign) ? FT_UINT32 : FT_INT32;
            }
            break;
        case 128:
            if (special_type == TPNCP_IP_ADDR) {
                hf_entr.hfinfo.display = BASE_NONE;
                hf_entr.hfinfo.type = FT_IPv4;
                if (!add_hf(&hf_entr))
                    return -1;
                hf_entr.p_id = &field->ipv6_descr;
                hf_entr.hfinfo.type = FT_IPv6;
            }
            break;
        default:
            break;
        }
        if (!add_hf(&hf_entr))
            return -1;
        field->sign = sign;
        field->size = size;
        field->array_dim = array_dim;
        field->special_type = is_address_family ? TPNCP_ADDRESS_FAMILY : special_type;
        field->since = since;
    }
    return 0;
}
