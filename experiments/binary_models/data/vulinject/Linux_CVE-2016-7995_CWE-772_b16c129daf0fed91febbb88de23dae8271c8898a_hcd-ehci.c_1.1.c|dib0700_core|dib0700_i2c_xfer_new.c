static int dib0700_i2c_xfer_new(struct i2c_adapter *adap, struct i2c_msg *msg,
				int num)
{
	struct dvb_usb_device *d = i2c_get_adapdata(adap);
	struct dib0700_state *st = d->priv;
	unsigned char bus_mode = 1;  
	unsigned char gen_mode = 0; 
	unsigned char en_start = 0;
	unsigned char en_stop = 0;
	int result, i;
	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
		return -EINTR;
	for (i = 0; i < num; i++) {
		if (i == 0) {
			en_start = 1;
		} else if (!(msg[i].flags & I2C_M_NOSTART)) {
			en_start = 1;
		} else {
			en_start = 0;
		}
		if (i == (num - 1)) {
			en_stop = 1;
		}
		if (msg[i].flags & I2C_M_RD) {
			unsigned short index, value;
			unsigned char i2c_dest;
			i2c_dest = (msg[i].addr << 1);
			value = ((en_start << 7) | (en_stop << 6) |
				 (msg[i].len & 0x3F)) << 8 | i2c_dest;
			index = ((gen_mode << 6) & 0xC0) |
				((bus_mode << 4) & 0x30);
			result = usb_control_msg(d->udev,
						 usb_rcvctrlpipe(d->udev, 0),
						 REQUEST_NEW_I2C_READ,
						 USB_TYPE_VENDOR | USB_DIR_IN,
						 value, index, st->buf,
						 msg[i].len,
						 USB_CTRL_GET_TIMEOUT);
			if (result < 0) {
				deb_info("i2c read error (status = %d)\n", result);
				goto unlock;
			}
			if (msg[i].len > sizeof(st->buf)) {
				deb_info("buffer too small to fit %d bytes\n",
					 msg[i].len);
				result = -EIO;
				goto unlock;
			}
			memcpy(msg[i].buf, st->buf, msg[i].len);
			deb_data("<<< ");
			debug_dump(msg[i].buf, msg[i].len, deb_data);
		} else {
			if (mutex_lock_interruptible(&d->usb_mutex) < 0) {
				err("could not acquire lock");
				result = -EINTR;
				goto unlock;
			}
			st->buf[0] = REQUEST_NEW_I2C_WRITE;
			st->buf[1] = msg[i].addr << 1;
			st->buf[2] = (en_start << 7) | (en_stop << 6) |
				(msg[i].len & 0x3F);
			st->buf[3] = ((gen_mode << 6) & 0xC0) |
				 ((bus_mode << 4) & 0x30);
			if (msg[i].len > sizeof(st->buf) - 4) {
				deb_info("i2c message to big: %d\n",
					 msg[i].len);
				result = -EIO;
				goto unlock;
			}
			memcpy(&st->buf[4], msg[i].buf, msg[i].len);
			deb_data(">>> ");
			debug_dump(st->buf, msg[i].len + 4, deb_data);
			result = usb_control_msg(d->udev,
						 usb_sndctrlpipe(d->udev, 0),
						 REQUEST_NEW_I2C_WRITE,
						 USB_TYPE_VENDOR | USB_DIR_OUT,
						 0, 0, st->buf, msg[i].len + 4,
						 USB_CTRL_GET_TIMEOUT);
			mutex_unlock(&d->usb_mutex);
			if (result < 0) {
				deb_info("i2c write error (status = %d)\n", result);
				break;
			}
		}
	}
	result = i;
unlock:
	mutex_unlock(&d->i2c_mutex);
	return result;
}
