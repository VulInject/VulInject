static gboolean decode_GetListRes (tvbuff_t *tvb, packet_info *pinfo, proto_tree *messagebodytree_list, guint *offset){
	proto_item *valList = NULL;
	proto_item *listSignature = NULL;
	proto_item *valtree = NULL;
	proto_item *SML_time;
	proto_tree *valList_list = NULL;
	proto_tree *listSignature_tree = NULL;
	proto_tree *valtree_list = NULL;
	proto_tree *SML_time_tree = NULL;
	guint repeat = 0;
	guint i = 0;
	guint data = 0;
	guint length = 0;
	field_clientId (tvb, messagebodytree_list, offset, &data, &length);
	field_serverId(tvb, messagebodytree_list, offset, &data, &length);
	field_listName(tvb, messagebodytree_list, offset, &data, &length);
	get_length(tvb, offset, &data, &length);
	SML_time_tree = proto_tree_add_subtree(messagebodytree_list, tvb, *offset, -1, ett_sml_time, &SML_time, "actSensorTime");
	if (data == 0){
		proto_item_append_text(SML_time, ": NOT SET");
		proto_item_set_len(SML_time, length + data);
		*offset+=1;
	}
	else {
		*offset+=1;
		sml_time_type(tvb, pinfo, SML_time_tree, offset);
		proto_item_set_end(SML_time,tvb,*offset);
	}
	get_length(tvb, offset, &data, &length);
	repeat = (length + data);
	valtree_list = proto_tree_add_subtree_format(messagebodytree_list, tvb, *offset, -1, ett_sml_valtree, &valtree,
						"valList with %d %s", length+data, plurality(length+data, "element", "elements"));
	if ((tvb_get_guint8(tvb,*offset) & 0xF0) != LONG_LIST && (tvb_get_guint8(tvb,*offset) & 0xF0) != SHORT_LIST){
		expert_add_info_format(pinfo, valtree, &ei_sml_invalid_count, "invalid count of elements in valList");
		return TRUE;
	}
		if(repeat == 0) {
		expert_add_info_format(pinfo, valtree, &ei_sml_invalid_count, "invalid loop count");
		return TRUE;
	}
	*offset+=length;
	for (i=0; i < repeat; i++){
		get_length(tvb, offset, &data, &length);
		valList_list = proto_tree_add_subtree(valtree_list, tvb, *offset, -1, ett_sml_valList, &valList, "valListEntry");
		*offset+=length;
		field_objName(tvb, valList_list, offset, &data, &length);
		field_status(tvb, valList_list, offset, &data, &length);
		get_length(tvb, offset, &data, &length);
		SML_time_tree = proto_tree_add_subtree(valList_list, tvb, *offset, -1, ett_sml_time, &SML_time, "valTime");
		if (data == 0){
			proto_item_append_text(SML_time, ": NOT SET");
			proto_item_set_len(SML_time, length + data);
			*offset+=1;
		}
		else {
			*offset+=1;
			sml_time_type(tvb, pinfo, SML_time_tree, offset);
			proto_item_set_end(SML_time, tvb, *offset);
		}
		field_unit(tvb, valList_list, offset, &data, &length);
		field_scaler(tvb, valList_list, offset, &data, &length);
		sml_value(tvb, pinfo, valList_list, offset, &data, &length);
		field_valueSignature(tvb, valList_list, offset, &data, &length);
		proto_item_set_end(valList, tvb, *offset);
	}
	proto_item_set_end(valtree, tvb, *offset);
	get_length(tvb, offset, &data, &length);
	listSignature = proto_tree_add_bytes_format (messagebodytree_list, hf_sml_listSignature, tvb, *offset, length+data, NULL, "ListSignature %s", (data == 0)? ": NOT SET" : "");
	if (data > 0){
		listSignature_tree = proto_item_add_subtree (listSignature, ett_sml_listSignature);
		proto_tree_add_uint (listSignature_tree, hf_sml_length, tvb, *offset, length, data);
		*offset+=length;
		proto_tree_add_item (listSignature_tree, hf_sml_listSignature, tvb, *offset, data, ENC_NA);
		*offset+=data;
	}
	else
		*offset+=1;
	get_length(tvb, offset, &data, &length);
	SML_time_tree = proto_tree_add_subtree(messagebodytree_list, tvb, *offset, -1, ett_sml_time, &SML_time, "actGatewayTime");
	if (data == 0){
		proto_item_append_text(SML_time, ": NOT SET");
		proto_item_set_len(SML_time, length + data);
		*offset+=1;
	}
	else{
		*offset+=1;
		sml_time_type(tvb, pinfo, SML_time_tree, offset);
		proto_item_set_end(SML_time,tvb,*offset);
	}
	return FALSE;
}
