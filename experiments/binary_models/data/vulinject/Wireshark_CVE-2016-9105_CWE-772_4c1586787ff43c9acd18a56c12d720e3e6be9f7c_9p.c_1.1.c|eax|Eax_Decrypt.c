bool Eax_Decrypt(unsigned char *pN, unsigned char *pK, unsigned char *pC,
                     unsigned int SizeN, unsigned int SizeK, unsigned int SizeC, MAC_T *pMac,
                     unsigned char Mode)
{
    unsigned char wsn[EAX_SIZEOF_KEY];
    unsigned char wsc[EAX_SIZEOF_KEY];
    int i;
    if (SizeK != EAX_SIZEOF_KEY)
        return false;
    for (i = 0; i < EAX_SIZEOF_KEY; i++)
        instance.L[i] = 0;
    AesEncrypt(instance.L, pK);
    Dbl(instance.D, instance.L);
    Dbl(instance.Q, instance.D);
    BLK_CPY(wsn, instance.D);
    if (Mode == EAX_MODE_CLEARTEXT_AUTH) {
        dCMAC(pK, wsn, pN, SizeN, pC, SizeC);
    } else {
        CMAC(pK, wsn, pN, SizeN);
    }
    if (Mode == EAX_MODE_CLEARTEXT_AUTH)
    {
        return (memcmp(pMac, &wsn[EAX_SIZEOF_KEY-sizeof(*pMac)], sizeof(*pMac)) ? false : true);
    }
    else if (Mode == EAX_MODE_CIPHERTEXT_AUTH)
    {
        if (SizeC == 0)
            return (memcmp(pMac, &wsn[EAX_SIZEOF_KEY-sizeof(*pMac)], sizeof(*pMac)) ? false : true);
        {
            BLK_CPY(wsc, instance.Q);
            CMAC(pK, wsc, pC, SizeC);
        }
        if (memcmp(pMac, &wsc[EAX_SIZEOF_KEY-sizeof(*pMac)], sizeof(*pMac)) == 0)
        {
            CTR(wsn, pK, pC, SizeC);
            return true;
        }
    }
    return false;
}
