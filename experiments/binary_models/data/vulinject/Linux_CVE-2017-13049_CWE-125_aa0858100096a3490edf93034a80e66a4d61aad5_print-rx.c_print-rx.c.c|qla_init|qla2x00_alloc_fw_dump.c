qla2x00_alloc_fw_dump(scsi_qla_host_t *vha)
{
	unsigned int dump_size, fixed_size, mem_size, req_q_size, rsp_q_size,
	    eft_size, fce_size, mq_size;
	struct qla_hw_data *ha = vha->hw;
	struct req_que *req = ha->req_q_map[0];
	struct rsp_que *rsp = ha->rsp_q_map[0];
	struct qla2xxx_fw_dump *fw_dump;
	if (ha->fw_dump) {
		ql_dbg(ql_dbg_init, vha, 0x00bd,
		    "Firmware dump already allocated.\n");
		return;
	}
	ha->fw_dumped = 0;
	ha->fw_dump_cap_flags = 0;
	dump_size = fixed_size = mem_size = eft_size = fce_size = mq_size = 0;
	req_q_size = rsp_q_size = 0;
	if (IS_QLA2100(ha) || IS_QLA2200(ha)) {
		fixed_size = sizeof(struct qla2100_fw_dump);
	} else if (IS_QLA23XX(ha)) {
		fixed_size = offsetof(struct qla2300_fw_dump, data_ram);
		mem_size = (ha->fw_memory_size - 0x11000 + 1) *
		    sizeof(unsigned short);
	} else if (IS_FWI2_CAPABLE(ha)) {
		if (IS_QLA83XX(ha))
			fixed_size = offsetof(struct qla83xx_fw_dump, ext_mem);
		else if (IS_QLA81XX(ha))
			fixed_size = offsetof(struct qla81xx_fw_dump, ext_mem);
		else if (IS_QLA25XX(ha))
			fixed_size = offsetof(struct qla25xx_fw_dump, ext_mem);
		else
			fixed_size = offsetof(struct qla24xx_fw_dump, ext_mem);
		mem_size = (ha->fw_memory_size - 0x100000 + 1) *
		    sizeof(unsigned int);
		if (ha->mqenable) {
			if (!IS_QLA83XX(ha))
				mq_size = sizeof(struct qla2xxx_mq_chain);
			mq_size += (ha->max_req_queues - 1) *
			    (req->length * sizeof(request_t));
			mq_size += (ha->max_rsp_queues - 1) *
			    (rsp->length * sizeof(response_t));
		}
		if (ha->tgt.atio_ring)
			mq_size += ha->tgt.atio_q_length * sizeof(request_t);
		if (ha->fce)
			fce_size = sizeof(struct qla2xxx_fce_chain) + FCE_SIZE;
		qla2x00_alloc_eft_trace(vha);
		if (ha->eft)
			eft_size = EFT_SIZE;
	}
	if (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
		struct fwdt *fwdt = ha->fwdt;
		unsigned int j;
		for (j = 0; j < 2; j++, fwdt++) {
			if (!fwdt->template) {
				ql_dbg(ql_dbg_init, vha, 0x00ba,
				    "-> fwdt%u no template\n", j);
				continue;
			}
			ql_dbg(ql_dbg_init, vha, 0x00fa,
			    "-> fwdt%u calculating fwdump size...\n", j);
			fwdt->dump_size = qla27xx_fwdt_calculate_dump_size(
			    vha, fwdt->template);
			ql_dbg(ql_dbg_init, vha, 0x00fa,
			    "-> fwdt%u calculated fwdump size = %#lx bytes\n",
			    j, fwdt->dump_size);
			dump_size += fwdt->dump_size;
		}
		dump_size += ha->fwdt[1].dump_size;
	} else {
		req_q_size = req->length * sizeof(request_t);
		rsp_q_size = rsp->length * sizeof(response_t);
		dump_size = offsetof(struct qla2xxx_fw_dump, isp);
		dump_size += fixed_size + mem_size + req_q_size + rsp_q_size
			+ eft_size;
		ha->chain_offset = dump_size;
		dump_size += mq_size + fce_size;
		if (ha->exchoffld_buf)
			dump_size += sizeof(struct qla2xxx_offld_chain) +
				ha->exchoffld_size;
		if (ha->exlogin_buf)
			dump_size += sizeof(struct qla2xxx_offld_chain) +
				ha->exlogin_size;
	}
	if (!ha->fw_dump_len || dump_size > ha->fw_dump_alloc_len) {
		ql_dbg(ql_dbg_init, vha, 0x00c5,
		    "%s dump_size %d fw_dump_len %d fw_dump_alloc_len %d\n",
		    __func__, dump_size, ha->fw_dump_len,
		    ha->fw_dump_alloc_len);
		fw_dump = vmalloc(dump_size);
		if (!fw_dump) {
			ql_log(ql_log_warn, vha, 0x00c4,
			    "Unable to allocate (%d KB) for firmware dump.\n",
			    dump_size / 1024);
		} else {
			mutex_lock(&ha->optrom_mutex);
			if (ha->fw_dumped) {
				memcpy(fw_dump, ha->fw_dump, ha->fw_dump_len);
				vfree(ha->fw_dump);
				ha->fw_dump = fw_dump;
				ha->fw_dump_alloc_len =  dump_size;
				ql_dbg(ql_dbg_init, vha, 0x00c5,
				    "Re-Allocated (%d KB) and save firmware dump.\n",
				    dump_size / 1024);
			} else {
				vfree(ha->fw_dump);
				ha->fw_dump = fw_dump;
				ha->fw_dump_len = ha->fw_dump_alloc_len =
				    dump_size;
				ql_dbg(ql_dbg_init, vha, 0x00c5,
				    "Allocated (%d KB) for firmware dump.\n",
				    dump_size / 1024);
				if (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
					ha->mpi_fw_dump = (char *)fw_dump +
						ha->fwdt[1].dump_size;
					mutex_unlock(&ha->optrom_mutex);
					return;
				}
				ha->fw_dump->signature[0] = 'Q';
				ha->fw_dump->signature[1] = 'L';
				ha->fw_dump->signature[2] = 'G';
				ha->fw_dump->signature[3] = 'C';
				ha->fw_dump->version = htonl(1);
				ha->fw_dump->fixed_size = htonl(fixed_size);
				ha->fw_dump->mem_size = htonl(mem_size);
				ha->fw_dump->req_q_size = htonl(req_q_size);
				ha->fw_dump->rsp_q_size = htonl(rsp_q_size);
				ha->fw_dump->eft_size = htonl(eft_size);
				ha->fw_dump->eft_addr_l =
				    htonl(LSD(ha->eft_dma));
				ha->fw_dump->eft_addr_h =
				    htonl(MSD(ha->eft_dma));
				ha->fw_dump->header_size =
					htonl(offsetof
					    (struct qla2xxx_fw_dump, isp));
			}
			mutex_unlock(&ha->optrom_mutex);
		}
	}
}
