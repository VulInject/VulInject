dissect_dns_answer(tvbuff_t *tvb, int offsetx, int dns_data_offset,
  proto_tree *dns_tree, packet_info *pinfo,
  gboolean is_mdns)
{
  const gchar  *name;
  gchar        *name_out;
  int           name_len;
  guint16       dns_type;
  guint16       dns_class;
  int           flush;
  const char   *class_name;
  const char   *type_name;
  int           data_offset;
  int           cur_offset;
  int           data_start;
  gushort       data_len;
  proto_tree   *rr_tree = NULL;
  proto_item   *trr     = NULL;
  guint         used_bytes;
  data_start = data_offset = offsetx;
  cur_offset = offsetx;
  used_bytes = get_dns_name_type_class(tvb, offsetx, dns_data_offset, &name, &name_len,
                                &dns_type, &dns_class);
  data_offset += used_bytes;
  cur_offset += used_bytes;
  if (is_mdns) {
    flush = dns_class & C_FLUSH;
    dns_class &= ~C_FLUSH;
  } else {
    flush = 0;
  }
  type_name = val_to_str_ext(dns_type, &dns_types_vals_ext, "Unknown (%d)");
  class_name = val_to_str_const(dns_class, dns_classes, "Unknown");
  data_offset += 4;
  cur_offset += 4;
  data_len = tvb_get_ntohs(tvb, data_offset);
  data_offset += 2;
  cur_offset  += 2;
  col_append_fstr(pinfo->cinfo, COL_INFO, " %s", type_name);
  if (is_mdns && flush) {
    col_append_str(pinfo->cinfo, COL_INFO, ", cache flush");
  }
  name_out = format_text(pinfo->pool, (const guchar*)name, name_len);
  if (dns_type != T_OPT) {
    rr_tree = proto_tree_add_subtree_format(dns_tree, tvb, offsetx,
                              (data_offset - data_start) + data_len,
                              ett_dns_rr, &trr, "%s: type %s, class %s",
                              name_out, type_name, class_name);
    add_rr_to_tree(rr_tree, tvb, offsetx, name_out, used_bytes - 4,
                             dns_type, pinfo, is_mdns);
  } else  {
    rr_tree = proto_tree_add_subtree_format(dns_tree, tvb, offsetx,
                              (data_offset - data_start) + data_len,
                              ett_dns_rr, &trr, "%s: type %s", name_out, type_name);
    add_opt_rr_to_tree(rr_tree, tvb, offsetx, name_out, used_bytes - 4, is_mdns);
  }
  if (is_mdns && flush) {
    proto_item_append_text(trr, ", cache flush");
  }
  if (data_len == 0) {
    return data_offset - data_start;
  }
  switch (dns_type) {
    case T_A: 
    {
      switch (dns_class) {
        case C_IN:
        {
          const char *addr;
          addr = tvb_ip_to_str(pinfo->pool, tvb, cur_offset);
          col_append_fstr(pinfo->cinfo, COL_INFO, " %s", addr);
          proto_item_append_text(trr, ", addr %s", addr);
          proto_tree_add_item(rr_tree, hf_dns_a, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
          if (gbl_resolv_flags.dns_pkt_addr_resolution && dns_class == C_IN &&
              !PINFO_FD_VISITED(pinfo)) {
            guint32 addr_int;
            tvb_memcpy(tvb, &addr_int, cur_offset, sizeof(addr_int));
            add_ipv4_name(addr_int, name, FALSE);
          }
        }
        break;
        case C_CH:
        {
          const gchar *domain_name;
          int domain_name_len;
          guint32 ch_addr;
          used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &domain_name, &domain_name_len);
          name_out = format_text(pinfo->pool, (const guchar*)domain_name, domain_name_len);
          col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
          proto_item_append_text(trr, ", domain/addr %s", name_out);
          proto_tree_add_string(rr_tree, hf_dns_a_ch_domain, tvb, cur_offset, used_bytes, name_out);
          proto_tree_add_item_ret_uint(rr_tree, hf_dns_a_ch_addr, tvb, cur_offset + used_bytes, 2, ENC_BIG_ENDIAN, &ch_addr);
          col_append_fstr(pinfo->cinfo, COL_INFO, "/0%o", ch_addr);
          proto_item_append_text(trr, "/0%o", ch_addr);
        }
        break;
        default:
        {
          expert_add_info_format(pinfo, trr, &ei_dns_a_class_undecoded,
                                 "A record dissection for class (%d)"
                                 " code not implemented, Contact Wireshark developers"
                                 " if you want this supported", dns_class);
          proto_tree_add_item(rr_tree, hf_dns_data, tvb, cur_offset, data_len, ENC_NA);
        }
        break;
      }
    }
    break;
    case T_NS: 
    {
      const gchar *ns_name;
      int ns_name_len;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &ns_name, &ns_name_len);
      name_out = format_text(pinfo->pool, (const guchar*)ns_name, ns_name_len);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_item_append_text(trr, ", ns %s", name_out);
      proto_tree_add_string(rr_tree, hf_dns_ns, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_MD: 
    {
      int           hostname_len;
      const gchar  *hostname_str;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &hostname_str, &hostname_len);
      name_out = format_text(pinfo->pool, (const guchar*)hostname_str, hostname_len);
      proto_tree_add_string(rr_tree, hf_dns_md, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_MF: 
    {
      int           hostname_len;
      const gchar  *hostname_str;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &hostname_str, &hostname_len);
      name_out = format_text(pinfo->pool, (const guchar*)hostname_str, hostname_len);
      proto_tree_add_string(rr_tree, hf_dns_mf, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_CNAME: 
    {
      const gchar *cname;
      int cname_len;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &cname, &cname_len);
      name_out = format_text(pinfo->pool, (const guchar*)cname, cname_len);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_item_append_text(trr, ", cname %s", name_out);
      proto_tree_add_string(rr_tree, hf_dns_cname, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_SOA: 
    {
      const gchar  *mname;
      int           mname_len;
      const gchar  *rname;
      int           rname_len;
      proto_item   *ti_soa;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &mname, &mname_len);
      name_out = format_text(pinfo->pool, (const guchar*)mname, mname_len);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_item_append_text(trr, ", mname %s", name_out);
      proto_tree_add_string(rr_tree, hf_dns_soa_mname, tvb, cur_offset, used_bytes, name_out);
      cur_offset += used_bytes;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &rname, &rname_len);
      name_out = format_text(pinfo->pool, (const guchar*)rname, rname_len);
      proto_tree_add_string(rr_tree, hf_dns_soa_rname, tvb, cur_offset, used_bytes, name_out);
      cur_offset += used_bytes;
      proto_tree_add_item(rr_tree, hf_dns_soa_serial_number, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      cur_offset += 4;
      ti_soa = proto_tree_add_item(rr_tree, hf_dns_soa_refresh_interval, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      proto_item_append_text(ti_soa, " (%s)", unsigned_time_secs_to_str(pinfo->pool, tvb_get_ntohl(tvb, cur_offset)));
      cur_offset += 4;
      ti_soa = proto_tree_add_item(rr_tree, hf_dns_soa_retry_interval, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      proto_item_append_text(ti_soa, " (%s)", unsigned_time_secs_to_str(pinfo->pool, tvb_get_ntohl(tvb, cur_offset)));
      cur_offset += 4;
      ti_soa = proto_tree_add_item(rr_tree, hf_dns_soa_expire_limit, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      proto_item_append_text(ti_soa, " (%s)", unsigned_time_secs_to_str(pinfo->pool, tvb_get_ntohl(tvb, cur_offset)));
      cur_offset += 4;
      ti_soa = proto_tree_add_item(rr_tree, hf_dns_soa_minimum_ttl, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      proto_item_append_text(ti_soa, " (%s)", unsigned_time_secs_to_str(pinfo->pool, tvb_get_ntohl(tvb, cur_offset)));
    }
    break;
    case T_MB: 
    {
      int           hostname_len;
      const gchar  *hostname_str;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &hostname_str, &hostname_len);
      name_out = format_text(pinfo->pool, (const guchar*)hostname_str, hostname_len);
      proto_tree_add_string(rr_tree, hf_dns_mb, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_MG: 
    {
      int           hostname_len;
      const gchar  *hostname_str;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &hostname_str, &hostname_len);
      name_out = format_text(pinfo->pool, (const guchar*)hostname_str, hostname_len);
      proto_tree_add_string(rr_tree, hf_dns_mg, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_MR: 
    {
      int           hostname_len;
      const gchar  *hostname_str;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &hostname_str, &hostname_len);
      name_out = format_text(pinfo->pool, (const guchar*)hostname_str, hostname_len);
      proto_tree_add_string(rr_tree, hf_dns_mr, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_NULL: 
    {
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_tree_add_item(rr_tree, hf_dns_null, tvb, cur_offset, data_len, ENC_NA);
    }
    break;
    case T_WKS: 
    {
      int            rr_len   = data_len;
      const char    *wks_addr;
      guint8         protocol;
      guint8         bits;
      int            mask;
      int            port_num;
      int            i;
      proto_item     *ti_wks;
      wmem_strbuf_t *bitnames = wmem_strbuf_create(pinfo->pool);
      wks_addr = tvb_ip_to_str(pinfo->pool, tvb, cur_offset);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", wks_addr);
      proto_item_append_text(trr, ", addr %s", wks_addr);
      proto_tree_add_item(rr_tree, hf_dns_wks_address, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      cur_offset += 4;
      rr_len     -= 4;
      proto_tree_add_item(rr_tree, hf_dns_wks_protocol, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      protocol = tvb_get_guint8(tvb, cur_offset);
      cur_offset += 1;
      rr_len     -= 1;
      port_num = 0;
      while (rr_len != 0) {
        bits = tvb_get_guint8(tvb, cur_offset);
        if (bits != 0) {
          mask = 1<<7;
          wmem_strbuf_truncate(bitnames, 0);
          for (i = 0; i < 8; i++) {
            if (bits & mask) {
              if (wmem_strbuf_get_len(bitnames) > 0) {
                wmem_strbuf_append(bitnames, ", ");
              }
              switch (protocol) {
                case IP_PROTO_TCP:
                  wmem_strbuf_append(bitnames, tcp_port_to_display(pinfo->pool, port_num));
                  break;
                case IP_PROTO_UDP:
                  wmem_strbuf_append(bitnames, udp_port_to_display(pinfo->pool, port_num));
                  break;
                default:
                  wmem_strbuf_append_printf(bitnames, "%u", port_num);
                  break;
              }
            }
            mask >>= 1;
            port_num++;
          }
          ti_wks = proto_tree_add_item(rr_tree, hf_dns_wks_bits, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
          proto_item_append_text(ti_wks, " (%s)", wmem_strbuf_get_str(bitnames));
        } else {
          port_num += 8;
        }
        cur_offset += 1;
        rr_len     -= 1;
      }
    }
    break;
    case T_PTR: 
    {
      const gchar  *pname;
      int           pname_len;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &pname, &pname_len);
      name_out = format_text(pinfo->pool, (const guchar*)pname, pname_len);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_item_append_text(trr, ", %s", name_out);
      proto_tree_add_string(rr_tree, hf_dns_ptr_domain_name, tvb, cur_offset, used_bytes, name_out);
      if (gbl_resolv_flags.dns_pkt_addr_resolution && (dns_class & 0x7f) == C_IN &&
          !PINFO_FD_VISITED(pinfo)) {
        guint32 addr_int;
        char** name_tokens;
        name_tokens = g_strsplit(name, ".", 33);
        if (g_strv_length(name_tokens) == 6) {
          if (g_ascii_strcasecmp(name_tokens[4], "in-addr") == 0 &&
              g_ascii_strcasecmp(name_tokens[5], "arpa") == 0) {
            char* addr_str = g_strjoin(".", name_tokens[3], name_tokens[2], name_tokens[1], name_tokens[0], NULL);
            if (ws_inet_pton4(addr_str, &addr_int)) {
              add_ipv4_name(addr_int, name_out, FALSE);
            }
          }
        } else if (g_strv_length(name_tokens) == 33) {
          if (g_ascii_strcasecmp(name_tokens[32], "ip6.arpa") == 0) {
            ws_in6_addr address_ipv6;
            wmem_strbuf_t *address_buf = wmem_strbuf_new_sized(pinfo->pool, 40);
            for (size_t i = 31; i > 0; i--) {
              wmem_strbuf_append(address_buf, name_tokens[i]);
              if (i % 4 == 0) {
                wmem_strbuf_append_c(address_buf, ':');
              }
            }
            wmem_strbuf_append(address_buf, name_tokens[0]);
            if (ws_inet_pton6(wmem_strbuf_get_str(address_buf), &address_ipv6)) {
                add_ipv6_name(&address_ipv6, name_out, FALSE);
            }
            wmem_strbuf_destroy(address_buf);
          }
        }
        g_strfreev(name_tokens);
      }
    }
    break;
    case T_HINFO: 
    {
      int         cpu_offset;
      int         cpu_len;
      const char *cpu;
      int         os_offset;
      int         os_len;
      const char *os;
      cpu_offset = cur_offset;
      cpu_len = tvb_get_guint8(tvb, cpu_offset);
      cpu = (const char* )tvb_get_string_enc(pinfo->pool, tvb, cpu_offset + 1, cpu_len, ENC_ASCII|ENC_NA);
      os_offset = cpu_offset + 1 + cpu_len;
      os_len = tvb_get_guint8(tvb, os_offset);
      os = (const char*)tvb_get_string_enc(pinfo->pool, tvb, os_offset + 1, os_len, ENC_ASCII|ENC_NA);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s %s", cpu, os);
      proto_item_append_text(trr, ", CPU %s, OS %s", cpu, os);
      proto_tree_add_item(rr_tree, hf_dns_hinfo_cpu_length, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      proto_tree_add_item(rr_tree, hf_dns_hinfo_cpu, tvb, cur_offset, cpu_len, ENC_ASCII);
      cur_offset += cpu_len;
      proto_tree_add_item(rr_tree, hf_dns_hinfo_os_length, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      proto_tree_add_item(rr_tree, hf_dns_hinfo_os, tvb, cur_offset, os_len, ENC_ASCII);
    }
    break;
    case T_MINFO: 
    {
      int rmailbx_len, emailbx_len;
      const gchar *rmailbx_str, *emailbx_str;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &rmailbx_str, &rmailbx_len);
      name_out = format_text(pinfo->pool, (const guchar*)rmailbx_str, rmailbx_len);
      proto_tree_add_string(rr_tree, hf_dns_minfo_r_mailbox, tvb, cur_offset, used_bytes, name_out);
      cur_offset += used_bytes;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &emailbx_str, &emailbx_len);
      name_out = format_text(pinfo->pool, (const guchar*)emailbx_str, emailbx_len);
      proto_tree_add_string(rr_tree, hf_dns_minfo_e_mailbox, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_MX: 
    {
      guint16       preference = 0;
      const gchar  *mx_name;
      int           mx_name_len;
      preference = tvb_get_ntohs(tvb, cur_offset);
      used_bytes = get_dns_name(tvb, cur_offset + 2, 0, dns_data_offset, &mx_name, &mx_name_len);
      name_out = format_text(pinfo->pool, (const guchar*)mx_name, mx_name_len);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %u %s", preference, name_out);
      proto_item_append_text(trr, ", preference %u, mx %s",
                             preference, name_out);
      proto_tree_add_item(rr_tree, hf_dns_mx_preference, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      proto_tree_add_string(rr_tree, hf_dns_mx_mail_exchange, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_TXT: 
    {
      int rr_len = data_len;
      int txt_offset;
      int txt_len;
      const bool is_dnscrypt_name = (strstr(name, "2.dnscrypt-cert.") != NULL);
      #define DNSCRYPT_CERT_MAGIC 0x444E5343
      txt_offset = cur_offset;
      while (rr_len != 0) {
        txt_len = tvb_get_guint8(tvb, txt_offset);
        proto_tree_add_item(rr_tree, hf_dns_txt_length, tvb, txt_offset, 1, ENC_BIG_ENDIAN);
        txt_offset += 1;
        rr_len     -= 1;
        if(  is_dnscrypt_name
          && txt_len == 124
          && rr_len >= txt_len
          && tvb_get_guint32(tvb, txt_offset, ENC_BIG_ENDIAN) == DNSCRYPT_CERT_MAGIC){
          dissect_dnscrypt(rr_tree, tvb, txt_offset, txt_len);
        } else {
            proto_tree_add_item(rr_tree, hf_dns_txt, tvb, txt_offset, txt_len, is_mdns ? ENC_UTF_8|ENC_NA : ENC_ASCII|ENC_NA);
        }
        txt_offset +=  txt_len;
        rr_len     -= txt_len;
      }
    }
    break;
    case T_RP: 
    {
      int           mbox_dname_len, txt_dname_len;
      const gchar  *mbox_dname, *txt_dname;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &mbox_dname, &mbox_dname_len);
      name_out = format_text(pinfo->pool, (const guchar*)mbox_dname, mbox_dname_len);
      proto_tree_add_string(rr_tree, hf_dns_rp_mailbox, tvb, cur_offset, used_bytes, name_out);
      cur_offset += used_bytes;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &txt_dname, &txt_dname_len);
      name_out = format_text(pinfo->pool, (const guchar*)txt_dname, txt_dname_len);
      proto_tree_add_string(rr_tree, hf_dns_rp_txt_rr, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_AFSDB: 
    {
      const gchar  *host_name;
      int           host_name_len;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      used_bytes = get_dns_name(tvb, cur_offset + 2, 0, dns_data_offset, &host_name, &host_name_len);
      name_out = format_text(pinfo->pool, (const guchar*)host_name, host_name_len);
      proto_tree_add_item(rr_tree, hf_dns_afsdb_subtype, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      proto_tree_add_string(rr_tree, hf_dns_afsdb_hostname, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_X25: 
    {
      guint8 x25_len;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_tree_add_item(rr_tree, hf_dns_x25_length, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      x25_len = tvb_get_guint8(tvb, cur_offset);
      cur_offset += 1;
      proto_tree_add_item(rr_tree, hf_dns_x25_psdn_address, tvb, cur_offset, x25_len, ENC_ASCII);
    }
    break;
    case T_ISDN: 
    {
      guint8 isdn_address_len, isdn_sa_len;
      int    rr_len = data_len;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_tree_add_item(rr_tree, hf_dns_isdn_length, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      isdn_address_len = tvb_get_guint8(tvb, cur_offset);
      cur_offset += 1;
      rr_len     -= 1;
      proto_tree_add_item(rr_tree, hf_dns_isdn_address, tvb, cur_offset, isdn_address_len, ENC_ASCII);
      cur_offset += isdn_address_len;
      rr_len     -= isdn_address_len;
      if (rr_len > 1)    {
        proto_tree_add_item(rr_tree, hf_dns_isdn_sa_length, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
        isdn_sa_len = tvb_get_guint8(tvb, cur_offset);
        cur_offset += 1;
        proto_tree_add_item(rr_tree, hf_dns_isdn_sa, tvb, cur_offset, isdn_sa_len, ENC_ASCII);
      }
    }
    break;
    case T_RT: 
    {
      const gchar  *host_name;
      int           host_name_len;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      used_bytes = get_dns_name(tvb, cur_offset + 2, 0, dns_data_offset, &host_name, &host_name_len);
      name_out = format_text(pinfo->pool, (const guchar*)host_name, host_name_len);
      proto_tree_add_item(rr_tree, hf_dns_rt_preference, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      proto_tree_add_string(rr_tree, hf_dns_rt_intermediate_host, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_NSAP: 
    {
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_tree_add_item(rr_tree, hf_dns_nsap_rdata, tvb, cur_offset, data_len, ENC_NA);
    }
    break;
    case T_NSAP_PTR: 
    {
      int           nsap_ptr_owner_len;
      const gchar  *nsap_ptr_owner;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &nsap_ptr_owner, &nsap_ptr_owner_len);
      name_out = format_text(pinfo->pool, (const guchar*)nsap_ptr_owner, nsap_ptr_owner_len);
      proto_tree_add_string(rr_tree, hf_dns_nsap_ptr_owner, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_KEY: 
    {
      int         rr_len = data_len;
      guint16     flags;
      proto_item *tf, *ti_gen;
      proto_tree *flags_tree;
      guint8      algo;
      guint16     key_id;
      tf = proto_tree_add_item(rr_tree, hf_dns_key_flags, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      flags_tree = proto_item_add_subtree(tf, ett_key_flags);
      flags = tvb_get_ntohs(tvb, cur_offset);
      proto_tree_add_item(flags_tree, hf_dns_key_flags_authentication, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      proto_tree_add_item(flags_tree, hf_dns_key_flags_confidentiality, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      if ((flags & 0xC000) != 0xC000) {
        proto_tree_add_item(flags_tree, hf_dns_key_flags_key_required, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
        proto_tree_add_item(flags_tree, hf_dns_key_flags_associated_user, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
        proto_tree_add_item(flags_tree, hf_dns_key_flags_associated_named_entity, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
        proto_tree_add_item(flags_tree, hf_dns_key_flags_ipsec, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
        proto_tree_add_item(flags_tree, hf_dns_key_flags_mime, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
        proto_tree_add_item(flags_tree, hf_dns_key_flags_signatory, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      }
      cur_offset += 2;
      rr_len     -= 2;
      proto_tree_add_item(rr_tree, hf_dns_key_protocol, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      rr_len     -= 1;
      proto_tree_add_item(rr_tree, hf_dns_key_algorithm, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      algo = tvb_get_guint8(tvb, cur_offset);
      cur_offset += 1;
      rr_len     -= 1;
      if (compute_key_id(rr_tree, pinfo, tvb, cur_offset-4, rr_len+4, algo, &key_id)) {
        ti_gen = proto_tree_add_uint(rr_tree, hf_dns_key_key_id, tvb, 0, 0, key_id);
        proto_item_set_generated(ti_gen);
      }
      if (rr_len != 0) {
        proto_tree_add_item(rr_tree, hf_dns_key_public_key, tvb, cur_offset, rr_len, ENC_NA);
      }
    }
    break;
    case T_PX: 
    {
      gint           px_map822_len, px_mapx400_len;
      const gchar *px_map822_dnsname, *px_mapx400_dnsname;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_tree_add_item(rr_tree, hf_dns_px_preference, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &px_map822_dnsname, &px_map822_len);
      name_out = format_text(pinfo->pool, (const guchar*)px_map822_dnsname, px_map822_len);
      proto_tree_add_string(rr_tree, hf_dns_px_map822, tvb, cur_offset, used_bytes, name_out);
      cur_offset += used_bytes;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &px_mapx400_dnsname, &px_mapx400_len);
      name_out = format_text(pinfo->pool, (const guchar*)px_mapx400_dnsname, px_mapx400_len);
      proto_tree_add_string(rr_tree, hf_dns_px_mapx400, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_GPOS: 
    {
      guint8 long_len, lat_len, alt_len;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_tree_add_item(rr_tree, hf_dns_gpos_longitude_length, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      long_len = tvb_get_guint8(tvb, cur_offset);
      cur_offset += 1;
      proto_tree_add_item(rr_tree, hf_dns_gpos_longitude, tvb, cur_offset, long_len, ENC_ASCII);
      cur_offset += long_len;
      proto_tree_add_item(rr_tree, hf_dns_gpos_latitude_length, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      lat_len = tvb_get_guint8(tvb, cur_offset);
      cur_offset += 1;
      proto_tree_add_item(rr_tree, hf_dns_gpos_latitude, tvb, cur_offset, lat_len, ENC_ASCII);
      cur_offset += lat_len;
      proto_tree_add_item(rr_tree, hf_dns_gpos_altitude_length, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      alt_len = tvb_get_guint8(tvb, cur_offset);
      cur_offset += 1;
      proto_tree_add_item(rr_tree, hf_dns_gpos_altitude, tvb, cur_offset, alt_len, ENC_ASCII);
    }
    break;
    case T_AAAA: 
    {
      const char        *addr6;
      addr6 = tvb_ip6_to_str(pinfo->pool, tvb, cur_offset);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", addr6);
      proto_item_append_text(trr, ", addr %s", addr6);
      proto_tree_add_item(rr_tree, hf_dns_aaaa, tvb, cur_offset, 16, ENC_NA);
      if (gbl_resolv_flags.dns_pkt_addr_resolution && (dns_class & 0x7f) == C_IN &&
          !PINFO_FD_VISITED(pinfo)) {
        ws_in6_addr  addr_in6;
        tvb_memcpy(tvb, &addr_in6, cur_offset, sizeof(addr_in6));
        add_ipv6_name(&addr_in6, name, FALSE);
      }
    }
    break;
    case T_LOC: 
    {
      guint8 version;
      proto_item *ti;
      version = tvb_get_guint8(tvb, cur_offset);
      proto_tree_add_item(rr_tree, hf_dns_loc_version, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      if (version == 0) {
        cur_offset++;
        ti = proto_tree_add_item(rr_tree, hf_dns_loc_size, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
        proto_item_append_text(ti, " (%g m)", rfc1867_size(tvb, cur_offset));
        cur_offset++;
        ti = proto_tree_add_item(rr_tree, hf_dns_loc_horizontal_precision, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
        proto_item_append_text(ti, " (%g m)", rfc1867_size(tvb, cur_offset));
        cur_offset++;
        ti = proto_tree_add_item(rr_tree, hf_dns_loc_vertical_precision, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
        proto_item_append_text(ti, " (%g m)", rfc1867_size(tvb, cur_offset));
        cur_offset++;
        ti = proto_tree_add_item(rr_tree, hf_dns_loc_latitude, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
        proto_item_append_text(ti, " (%s)", rfc1867_angle(tvb, cur_offset, FALSE));
        cur_offset += 4;
        ti = proto_tree_add_item(rr_tree, hf_dns_loc_longitude, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
        proto_item_append_text(ti, " (%s)", rfc1867_angle(tvb, cur_offset, TRUE));
        cur_offset += 4;
        ti = proto_tree_add_item(rr_tree, hf_dns_loc_altitude, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
        proto_item_append_text(ti, " (%g m)", (tvb_get_ntohil(tvb, cur_offset) - 10000000)/100.0);
      } else {
        proto_tree_add_item(rr_tree, hf_dns_loc_unknown_data, tvb, cur_offset, data_len, ENC_NA);
      }
    }
    break;
    case T_NXT: 
    {
      int           rr_len = data_len;
      const gchar  *next_domain_name;
      int           next_domain_name_len;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset,
                                &next_domain_name, &next_domain_name_len);
      name_out = format_text(pinfo->pool, (const guchar*)next_domain_name, next_domain_name_len);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_item_append_text(trr, ", next domain name %s", name_out);
      proto_tree_add_string(rr_tree, hf_dns_nxt_next_domain_name, tvb, cur_offset, used_bytes, name_out);
      cur_offset += used_bytes;
      rr_len     -= used_bytes;
      dissect_type_bitmap_nxt(rr_tree, tvb, cur_offset, rr_len);
    }
    break;
    case T_SRV: 
    {
      guint16       priority = 0;
      guint16       weight   = 0;
      guint16       port     = 0;
      const gchar  *target;
      int           target_len;
      proto_tree_add_item(rr_tree, hf_dns_srv_priority, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      priority = tvb_get_ntohs(tvb, cur_offset);
      cur_offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_srv_weight, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      weight = tvb_get_ntohs(tvb, cur_offset);
      cur_offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_srv_port, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      port = tvb_get_ntohs(tvb, cur_offset);
      cur_offset += 2;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &target, &target_len);
      name_out = format_text(pinfo->pool, (const guchar*)target, target_len);
      proto_tree_add_string(rr_tree, hf_dns_srv_target, tvb, cur_offset, used_bytes, name_out);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %u %u %u %s", priority, weight, port, name_out);
      proto_item_append_text(trr,
                             ", priority %u, weight %u, port %u, target %s",
                             priority, weight, port, name_out);
    }
    break;
    case T_NAPTR: 
    {
      proto_item    *ti_len;
      int           offset = cur_offset;
      guint16       order;
      guint16       preference;
      const guint8 *flags;
      guint8        flags_len;
      guint8        service_len;
      guint8        regex_len;
      const gchar  *replacement;
      int           replacement_len;
      proto_tree_add_item(rr_tree, hf_dns_naptr_order, tvb, offset, 2, ENC_BIG_ENDIAN);
      order = tvb_get_ntohs(tvb, offset);
      offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_naptr_preference, tvb, offset, 2, ENC_BIG_ENDIAN);
      preference = tvb_get_ntohs(tvb, offset);
      offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_naptr_flags_length, tvb, offset, 1, ENC_BIG_ENDIAN);
      flags_len = tvb_get_guint8(tvb, offset);
      offset += 1;
      proto_tree_add_item_ret_string(rr_tree, hf_dns_naptr_flags, tvb, offset, flags_len, ENC_ASCII|ENC_NA, pinfo->pool, &flags);
      offset += flags_len;
      proto_tree_add_item(rr_tree, hf_dns_naptr_service_length, tvb, offset, 1, ENC_BIG_ENDIAN);
      service_len = tvb_get_guint8(tvb, offset);
      offset += 1;
      proto_tree_add_item(rr_tree, hf_dns_naptr_service, tvb, offset, service_len, ENC_ASCII);
      offset += service_len;
      proto_tree_add_item(rr_tree, hf_dns_naptr_regex_length, tvb, offset, 1, ENC_BIG_ENDIAN);
      regex_len = tvb_get_guint8(tvb, offset);
      offset += 1;
      proto_tree_add_item(rr_tree, hf_dns_naptr_regex, tvb, offset, regex_len, ENC_ASCII);
      offset += regex_len;
      used_bytes = get_dns_name(tvb, offset, 0, dns_data_offset, &replacement, &replacement_len);
      name_out = format_text(pinfo->pool, (const guchar*)replacement, replacement_len);
      ti_len = proto_tree_add_uint(rr_tree, hf_dns_naptr_replacement_length, tvb, offset, 0, replacement_len);
      proto_item_set_generated(ti_len);
      proto_tree_add_string(rr_tree, hf_dns_naptr_replacement, tvb, offset, used_bytes, name_out);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %u %u %s", order, preference, flags);
      proto_item_append_text(trr, ", order %u, preference %u, flags %s",
                             order, preference, flags);
    }
    break;
    case T_KX: 
    {
      const gchar  *kx_name;
      int           kx_name_len;
      used_bytes = get_dns_name(tvb, cur_offset + 2, 0, dns_data_offset, &kx_name, &kx_name_len);
      name_out = format_text(pinfo->pool, (const guchar*)kx_name, kx_name_len);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %u %s", tvb_get_ntohs(tvb, cur_offset), name_out);
      proto_item_append_text(trr, ", preference %u, kx %s",
                             tvb_get_ntohs(tvb, cur_offset), name_out);
      proto_tree_add_item(rr_tree, hf_dns_kx_preference, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      proto_tree_add_string(rr_tree, hf_dns_kx_key_exchange, tvb, cur_offset + 2, used_bytes, name_out);
    }
    break;
    case T_CERT: 
    {
      int     rr_len = data_len;
      proto_tree_add_item(rr_tree, hf_dns_cert_type, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      rr_len     -= 2;
      proto_tree_add_item(rr_tree, hf_dns_cert_key_tag, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      rr_len     -= 2;
      proto_tree_add_item(rr_tree, hf_dns_cert_algorithm, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      rr_len     -= 1;
      if (rr_len != 0) {
        proto_tree_add_item(rr_tree, hf_dns_cert_certificate, tvb, cur_offset, rr_len, ENC_NA);
      }
    }
    break;
    case T_A6: 
    {
      unsigned short     pre_len;
      unsigned short     suf_len;
      unsigned short     suf_octet_count;
      const gchar       *pname;
      int                pname_len;
      int                a6_offset;
      int                suf_offset;
      ws_in6_addr  suffix;
      address            suffix_addr;
      a6_offset = cur_offset;
      pre_len = tvb_get_guint8(tvb, cur_offset);
      cur_offset++;
      suf_len = 128 - pre_len;
      suf_octet_count = suf_len ? (suf_len - 1) / 8 + 1 : 0;
      for (suf_offset = 0; suf_offset < 16 - suf_octet_count; suf_offset++) {
        suffix.bytes[suf_offset] = 0;
      }
      for (; suf_offset < 16; suf_offset++) {
        suffix.bytes[suf_offset] = tvb_get_guint8(tvb, cur_offset);
        cur_offset++;
      }
      if (pre_len > 0) {
        used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset,
                                  &pname, &pname_len);
      } else {
        pname = "";
        pname_len = 0;
      }
      name_out = format_text(pinfo->pool, (const guchar*)pname, pname_len);
      set_address(&suffix_addr, AT_IPv6, 16, suffix.bytes);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %d %s %s",
                      pre_len,
                      address_to_str(pinfo->pool, &suffix_addr),
                      name_out);
      proto_tree_add_item(rr_tree, hf_dns_a6_prefix_len,tvb, a6_offset, 1, ENC_BIG_ENDIAN);
      a6_offset++;
      if (suf_len) {
        proto_tree_add_ipv6(rr_tree, hf_dns_a6_address_suffix,tvb, a6_offset, suf_octet_count, &suffix);
        a6_offset += suf_octet_count;
      }
      if (pre_len > 0) {
        proto_tree_add_string(rr_tree, hf_dns_a6_prefix_name, tvb, a6_offset, used_bytes, name_out);
      }
      proto_item_append_text(trr, ", addr %d %s %s",
                             pre_len,
                             address_to_str(pinfo->pool, &suffix_addr),
                             name_out);
    }
    break;
    case T_DNAME: 
    {
      const gchar  *dname;
      int           dname_len;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset,
                               &dname, &dname_len);
      name_out = format_text(pinfo->pool, (const guchar*)dname, dname_len);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_item_append_text(trr, ", dname %s", name_out);
      proto_tree_add_string(rr_tree, hf_dns_dname, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_OPT: 
    {
      int rropt_len = data_len;
      guint16 optcode, optlen;
      proto_item *rropt, *rroptlen;
      proto_tree *rropt_tree;
      while (rropt_len > 0) {
        optcode = tvb_get_ntohs(tvb, cur_offset);
        rropt_len -= 2;
        optlen = tvb_get_ntohs(tvb, cur_offset + 2);
        rropt_len -= 2;
        rropt = proto_tree_add_item(rr_tree, hf_dns_opt, tvb, cur_offset, 4 + optlen, ENC_NA);
        proto_item_append_text(rropt, ": %s", val_to_str(optcode, edns0_opt_code_vals, "Unknown (%d)"));
        rropt_tree = proto_item_add_subtree(rropt, ett_dns_opts);
        rropt = proto_tree_add_item(rropt_tree, hf_dns_opt_code, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
        cur_offset += 2;
        rroptlen = proto_tree_add_item(rropt_tree, hf_dns_opt_len, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
        cur_offset += 2;
        proto_tree_add_item(rropt_tree, hf_dns_opt_data, tvb, cur_offset, optlen, ENC_NA);
        switch(optcode) {
          case O_DAU: 
          {
            while (optlen != 0) {
              proto_tree_add_item(rropt_tree, hf_dns_opt_dau, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
              cur_offset += 1;
              rropt_len  -= 1;
              optlen -= 1;
            }
          }
          break;
          case O_DHU: 
          {
            while (optlen != 0) {
              proto_tree_add_item(rropt_tree, hf_dns_opt_dhu, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
              cur_offset += 1;
              rropt_len  -= 1;
              optlen -= 1;
            }
          }
          break;
          case O_N3U: 
          {
            while (optlen != 0) {
              proto_tree_add_item(rropt_tree, hf_dns_opt_n3u, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
              cur_offset += 1;
              rropt_len  -= 1;
              optlen -= 1;
            }
          }
          break;
          case O_CLIENT_SUBNET_EXP: 
             expert_add_info_format(pinfo, rropt, &ei_dns_depr_opc,
                "Deprecated opcode. Client subnet OPT assigned as %d.", O_CLIENT_SUBNET);
          case O_CLIENT_SUBNET:
          {
            guint16 family;
            guint16 addr_len = optlen - 4;
            union {
              guint32 addr;
              guint8 bytes[16];
            } ip_addr = {0};
            family = tvb_get_ntohs(tvb, cur_offset);
            proto_tree_add_item(rropt_tree, hf_dns_opt_client_family, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
            cur_offset += 2;
            proto_tree_add_item(rropt_tree, hf_dns_opt_client_netmask, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
            cur_offset += 1;
            proto_tree_add_item(rropt_tree, hf_dns_opt_client_scope, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
            cur_offset += 1;
            if (addr_len > 16) {
              expert_add_info(pinfo, rroptlen, &ei_dns_opt_bad_length);
              addr_len = 16;
            }
            tvb_memcpy(tvb, ip_addr.bytes, cur_offset, addr_len);
            switch (family) {
              case AFNUM_INET:
              {
                proto_tree_add_ipv4(rropt_tree, hf_dns_opt_client_addr4, tvb,
                                    cur_offset, addr_len, ip_addr.addr);
              }
              break;
              case AFNUM_INET6:
              {
                proto_tree_add_ipv6(rropt_tree, hf_dns_opt_client_addr6, tvb,
                                    cur_offset, addr_len, (ws_in6_addr *)&ip_addr);
              }
              break;
              default:
              {
                proto_tree_add_item(rropt_tree, hf_dns_opt_client_addr, tvb, cur_offset, (optlen - 4),
                                    ENC_NA);
          }
              break;
            }
            cur_offset += (optlen - 4);
            rropt_len  -= optlen;
          }
          break;
          case O_COOKIE:
          {
            proto_tree_add_item(rropt_tree, hf_dns_opt_cookie_client, tvb, cur_offset, 8, ENC_NA);
            cur_offset += 8;
            rropt_len  -= 8;
            optlen -= 8;
            proto_tree_add_item(rropt_tree, hf_dns_opt_cookie_server, tvb, cur_offset, optlen, ENC_NA);
            cur_offset += optlen;
            rropt_len  -= optlen;
          }
          break;
          case O_EDNS_TCP_KA:
          {
            if (optlen == 2) {
              proto_tree_add_item(rropt_tree, hf_dns_opt_edns_tcp_keepalive_timeout, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
            }
            cur_offset += optlen;
            rropt_len  -= optlen;
          }
          break;
          case O_PADDING:
          {
            proto_tree_add_item(rropt_tree, hf_dns_opt_padding, tvb, cur_offset, optlen, ENC_NA);
            cur_offset += optlen;
            rropt_len  -= optlen;
          }
          break;
          case O_CHAIN:
          {
            if (optlen) {
              proto_tree_add_item(rropt_tree, hf_dns_opt_chain_fqdn, tvb, cur_offset, optlen, ENC_ASCII);
            }
            cur_offset += optlen;
            rropt_len  -= optlen;
          }
          break;
          case O_EXT_ERROR:
          {
            if (optlen >= 2) {
              proto_tree_add_item(rropt_tree, hf_dns_opt_ext_error_info_code, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
              cur_offset += 2;
              rropt_len  -= 2;
              if (optlen > 2) {
                proto_tree_add_item(rropt_tree, hf_dns_opt_ext_error_extra_text, tvb, cur_offset, optlen - 2, ENC_UTF_8);
                cur_offset += (optlen - 2);
                rropt_len  -= (optlen - 2);
              }
            }
          }
          break;
          case O_REPORT_CHANNEL:
          {
            const gchar  *dname;
            int           dname_len;
            used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset,
                                    &dname, &dname_len);
            name_out = format_text(wmem_packet_scope(), (const guchar*)dname, dname_len);
            proto_tree_add_string(rropt_tree, hf_dns_opt_agent_domain, tvb, cur_offset, used_bytes, name_out);
            cur_offset += used_bytes;
            rropt_len  -= used_bytes;
          }
          break;
          default:
          {
            cur_offset += optlen;
            rropt_len  -= optlen;
          }
          break;
        }
      }
    }
    break;
    case T_APL: 
    {
      int      rr_len = data_len;
      guint16  afamily;
      guint8   afdpart_len;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      while (rr_len > 1) {
        afamily = tvb_get_ntohs(tvb, cur_offset);
        proto_tree_add_item(rr_tree, hf_dns_apl_address_family, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
        cur_offset += 2;
        rr_len     -= 2;
        proto_tree_add_item(rr_tree, hf_dns_apl_coded_prefix, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
        cur_offset += 1;
        rr_len     -= 1;
        afdpart_len = tvb_get_guint8(tvb, cur_offset) & DNS_APL_AFDLENGTH;
        proto_tree_add_item(rr_tree, hf_dns_apl_negation, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
        proto_tree_add_item(rr_tree, hf_dns_apl_afdlength, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
        cur_offset += 1;
        rr_len     -= 1;
        if (afamily == AFNUM_INET && afdpart_len <= 4) {
          ws_in4_addr *addr4_copy;
          addr4_copy = (ws_in4_addr *)wmem_alloc0(pinfo->pool, 4);
          tvb_memcpy(tvb, (void *)addr4_copy, cur_offset, afdpart_len);
          proto_tree_add_ipv4(rr_tree, hf_dns_apl_afdpart_ipv4, tvb, cur_offset, afdpart_len, *addr4_copy);
        } else if (afamily == AFNUM_INET6 && afdpart_len <= 16) {
          ws_in6_addr *addr6_copy;
          addr6_copy = (ws_in6_addr *)wmem_alloc0(pinfo->pool, 16);
          tvb_memcpy(tvb, (void *)addr6_copy, cur_offset, afdpart_len);
          proto_tree_add_ipv6(rr_tree, hf_dns_apl_afdpart_ipv6, tvb, cur_offset, afdpart_len, addr6_copy);
        } else { 
           proto_tree_add_item(rr_tree, hf_dns_apl_afdpart_data, tvb, cur_offset, afdpart_len, ENC_NA);
        }
        cur_offset += afdpart_len;
        rr_len     -= afdpart_len;
      }
    }
    break;
    case T_DS: 
    case T_CDS: 
    case T_DLV:
    {
      int     rr_len = data_len;
      proto_tree_add_item(rr_tree, hf_dns_ds_key_id, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      rr_len     -= 2;
      proto_tree_add_item(rr_tree,  hf_dns_ds_algorithm, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      rr_len     -= 1;
      proto_tree_add_item(rr_tree,  hf_dns_ds_digest_type, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      rr_len     -= 1;
      proto_tree_add_item(rr_tree,  hf_dns_ds_digest, tvb, cur_offset, rr_len, ENC_NA);
    }
    break;
    case T_SSHFP: 
    {
      int    rr_len = data_len;
      proto_tree_add_item(rr_tree, hf_dns_sshfp_algorithm, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      rr_len     -= 1;
      proto_tree_add_item(rr_tree, hf_dns_sshfp_fingerprint_type, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      rr_len     -= 1;
      if (rr_len != 0) {
        proto_tree_add_item(rr_tree, hf_dns_sshfp_fingerprint, tvb, cur_offset, rr_len, ENC_NA);
      }
    }
    break;
    case T_IPSECKEY: 
    {
      int           rr_len = data_len;
      guint8        gw_type;
      const gchar  *gw;
      int           gw_name_len;
      proto_tree_add_item(rr_tree, hf_dns_ipseckey_gateway_precedence, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      rr_len     -= 1;
      proto_tree_add_item(rr_tree, hf_dns_ipseckey_gateway_type, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      gw_type = tvb_get_guint8(tvb, cur_offset);
      cur_offset += 1;
      rr_len     -= 1;
      proto_tree_add_item(rr_tree, hf_dns_ipseckey_gateway_algorithm, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      rr_len     -= 1;
      switch (gw_type) {
        case 0:
        {
        }
        break;
        case 1:
        {
          proto_tree_add_item(rr_tree, hf_dns_ipseckey_gateway_ipv4, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
          cur_offset += 4;
          rr_len     -= 4;
        }
        break;
        case 2:
        {
          proto_tree_add_item(rr_tree, hf_dns_ipseckey_gateway_ipv6, tvb, cur_offset, 16, ENC_NA);
          cur_offset += 16;
          rr_len     -= 16;
        }
        break;
        case 3:
        {
          used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &gw, &gw_name_len);
          name_out = format_text(pinfo->pool, (const guchar*)gw, gw_name_len);
          proto_tree_add_string(rr_tree, hf_dns_ipseckey_gateway_dns, tvb, cur_offset, used_bytes, name_out);
          cur_offset += used_bytes;
          rr_len     -= used_bytes;
        }
        break;
        default:
        break;
      }
      if (rr_len != 0) {
        proto_tree_add_item(rr_tree, hf_dns_ipseckey_public_key, tvb, cur_offset, rr_len, ENC_NA);
      }
    }
    break;
    case T_RRSIG: 
    case T_SIG: 
    {
      int           rr_len = data_len;
      const gchar  *signer_name;
      int           signer_name_len;
      proto_item    *ti;
      guint32 type;
      ti = proto_tree_add_item_ret_uint(rr_tree, hf_dns_rrsig_type_covered, tvb, cur_offset, 2, ENC_BIG_ENDIAN, &type);
      proto_item_append_text(ti, " %s", val_to_str_ext(type, &dns_types_description_vals_ext, "Unknown (%d)"));
      cur_offset += 2;
      rr_len     -= 2;
      proto_tree_add_item(rr_tree, hf_dns_rrsig_algorithm, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      rr_len     -= 1;
      proto_tree_add_item(rr_tree, hf_dns_rrsig_labels, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      rr_len     -= 1;
      ti = proto_tree_add_item(rr_tree, hf_dns_rrsig_original_ttl, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      proto_item_append_text(ti, " (%s)", unsigned_time_secs_to_str(pinfo->pool, tvb_get_ntohl(tvb, cur_offset)));
      cur_offset += 4;
      rr_len     -= 4;
      proto_tree_add_item(rr_tree, hf_dns_rrsig_signature_expiration, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      cur_offset += 4;
      rr_len     -= 4;
      proto_tree_add_item(rr_tree, hf_dns_rrsig_signature_inception, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      cur_offset += 4;
      rr_len     -= 4;
      proto_tree_add_item(rr_tree, hf_dns_rrsig_key_tag, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      rr_len     -= 2;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &signer_name, &signer_name_len);
      name_out = format_text(pinfo->pool, (const guchar*)signer_name, signer_name_len);
      proto_tree_add_string(rr_tree, hf_dns_rrsig_signers_name, tvb, cur_offset, used_bytes, name_out);
      cur_offset += used_bytes;
      rr_len     -= used_bytes;
      if (rr_len != 0) {
        proto_tree_add_item(rr_tree, hf_dns_rrsig_signature, tvb, cur_offset, rr_len, ENC_NA);
      }
    }
    break;
    case T_NSEC: 
    {
      int           rr_len = data_len;
      const gchar  *next_domain_name;
      int           next_domain_name_len;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset,
                                          &next_domain_name, &next_domain_name_len);
      name_out = format_text(pinfo->pool, (const guchar*)next_domain_name, next_domain_name_len);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_item_append_text(trr, ", next domain name %s", name_out);
      proto_tree_add_string(rr_tree, hf_dns_nsec_next_domain_name, tvb, cur_offset, used_bytes, name_out);
      cur_offset += used_bytes;
      rr_len     -= used_bytes;
      dissect_type_bitmap(rr_tree, tvb, cur_offset, rr_len);
    }
    break;
    case T_DNSKEY: 
    case T_CDNSKEY: 
    {
      int         rr_len = data_len;
      proto_item *tf, *ti_gen;
      proto_tree *flags_tree;
      guint16     key_id;
      guint8 algo;
      tf = proto_tree_add_item(rr_tree, hf_dns_dnskey_flags, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      flags_tree = proto_item_add_subtree(tf, ett_key_flags);
      proto_tree_add_item(flags_tree, hf_dns_dnskey_flags_zone_key, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      proto_tree_add_item(flags_tree, hf_dns_dnskey_flags_key_revoked, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      proto_tree_add_item(flags_tree, hf_dns_dnskey_flags_secure_entry_point, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      proto_tree_add_item(flags_tree, hf_dns_dnskey_flags_reserved, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      rr_len     -= 2;
      proto_tree_add_item(rr_tree, hf_dns_dnskey_protocol, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      rr_len     -= 1;
      proto_tree_add_item(rr_tree, hf_dns_dnskey_algorithm, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      algo = tvb_get_guint8(tvb, cur_offset);
      cur_offset += 1;
      rr_len     -= 1;
      if (compute_key_id(rr_tree, pinfo, tvb, cur_offset-4, rr_len+4, algo, &key_id)) {
        ti_gen = proto_tree_add_uint(rr_tree, hf_dns_dnskey_key_id, tvb, 0, 0, key_id);
        proto_item_set_generated(ti_gen);
      }
      proto_tree_add_item(rr_tree, hf_dns_dnskey_public_key, tvb, cur_offset, rr_len, ENC_NA);
    }
    break;
    case T_DHCID: 
    {
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_tree_add_item(rr_tree, hf_dns_dhcid_rdata, tvb, cur_offset, data_len, ENC_NA);
    }
    break;
    case T_NSEC3: 
    {
      int         rr_len, initial_offset = cur_offset;
      guint8      salt_len, hash_len;
      proto_item *flags_item, *hash_item;
      proto_tree *flags_tree;
      proto_tree_add_item(rr_tree, hf_dns_nsec3_algo, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      flags_item = proto_tree_add_item(rr_tree, hf_dns_nsec3_flags, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      flags_tree = proto_item_add_subtree(flags_item, ett_nsec3_flags);
      proto_tree_add_item(flags_tree, hf_dns_nsec3_flag_optout, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      proto_tree_add_item(rr_tree, hf_dns_nsec3_iterations, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_nsec3_salt_length, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      salt_len = tvb_get_guint8(tvb, cur_offset);
      cur_offset += 1;
      proto_tree_add_item(rr_tree, hf_dns_nsec3_salt_value, tvb, cur_offset, salt_len, ENC_NA);
      cur_offset += salt_len;
      proto_tree_add_item(rr_tree, hf_dns_nsec3_hash_length, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      hash_len = tvb_get_guint8(tvb, cur_offset);
      cur_offset += 1;
      if (hash_len) {
        const char    *base32hex = "0123456789abcdefghijklmnopqrstuv";
        wmem_strbuf_t *hash_value_base32hex = wmem_strbuf_new(pinfo->pool, "");
        int            group, in_offset, out_offset;
        for (in_offset = 0, out_offset = 0;
            in_offset / 8 < hash_len;
            in_offset += 5, out_offset += 1) {
          group = tvb_get_bits8(tvb, cur_offset * 8 + in_offset, 5);
          wmem_strbuf_append_c(hash_value_base32hex, base32hex[group]);
        }
        hash_item = proto_tree_add_string(rr_tree, hf_dns_nsec3_hash_value, tvb, cur_offset, hash_len, wmem_strbuf_finalize(hash_value_base32hex));
        proto_item_set_generated(hash_item);
        cur_offset += hash_len;
      }
      rr_len = data_len - (cur_offset - initial_offset);
      dissect_type_bitmap(rr_tree, tvb, cur_offset, rr_len);
    }
    break;
    case T_NSEC3PARAM: 
    {
      int salt_len;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_tree_add_item(rr_tree, hf_dns_nsec3_algo, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset +=1;
      proto_tree_add_item(rr_tree, hf_dns_nsec3_flags, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset +=1;
      proto_tree_add_item(rr_tree, hf_dns_nsec3_iterations, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_nsec3_salt_length, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      salt_len = tvb_get_guint8(tvb, cur_offset);
      cur_offset +=1;
      proto_tree_add_item(rr_tree, hf_dns_nsec3_salt_value, tvb, cur_offset, salt_len, ENC_NA);
    }
    break;
    case T_TLSA: 
    {
      int     rr_len = data_len;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_tree_add_item(rr_tree, hf_dns_tlsa_certificate_usage, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset ++;
      rr_len --;
      proto_tree_add_item(rr_tree, hf_dns_tlsa_selector, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset ++;
      rr_len --;
      proto_tree_add_item(rr_tree, hf_dns_tlsa_matching_type, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset ++;
      rr_len --;
      proto_tree_add_item(rr_tree, hf_dns_tlsa_certificate_association_data, tvb, cur_offset, rr_len, ENC_NA);
    }
    break;
    case T_HIP: 
    {
      guint8        hit_len;
      guint16       pk_len;
      int           rr_len = data_len;
      int           rendezvous_len;
      const gchar  *rend_server_dns_name;
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      hit_len = tvb_get_guint8(tvb, cur_offset);
      proto_tree_add_item(rr_tree, hf_dns_hip_hit_length, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      rr_len     -= 1;
      proto_tree_add_item(rr_tree, hf_dns_hip_pk_algo, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset += 1;
      rr_len     -= 1;
      pk_len = tvb_get_ntohs(tvb, cur_offset);
      proto_tree_add_item(rr_tree, hf_dns_hip_pk_length, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      rr_len     -= 2;
      proto_tree_add_item(rr_tree, hf_dns_hip_hit, tvb, cur_offset, hit_len, ENC_NA);
      cur_offset += hit_len;
      rr_len     -= hit_len;
      proto_tree_add_item(rr_tree, hf_dns_hip_pk, tvb, cur_offset, pk_len, ENC_NA);
      cur_offset += pk_len;
      rr_len     -= pk_len;
      while (rr_len > 1) {
        used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &rend_server_dns_name, &rendezvous_len);
        name_out = format_text(pinfo->pool, (const guchar*)rend_server_dns_name, rendezvous_len);
        proto_tree_add_string(rr_tree, hf_dns_hip_rendezvous_server, tvb, cur_offset, used_bytes, name_out);
        cur_offset += used_bytes;
        rr_len     -= used_bytes;
      }
    }
    break;
    case T_OPENPGPKEY: 
    {
      proto_tree_add_item(rr_tree, hf_dns_openpgpkey, tvb, cur_offset, data_len, ENC_ASCII);
    }
    break;
    case T_CSYNC: 
    {
      int         rr_len, initial_offset = cur_offset;
      proto_tree_add_item(rr_tree, hf_dns_csync_soa, tvb, cur_offset, 4, ENC_ASCII|ENC_NA);
      cur_offset += 4;
      proto_tree_add_bitmask_with_flags(rr_tree, tvb, cur_offset,
        hf_dns_csync_flags, ett_dns_csdync_flags, dns_csync_flags, ENC_BIG_ENDIAN, BMT_NO_APPEND);
      cur_offset += 2;
      rr_len = data_len - (cur_offset - initial_offset);
      proto_tree_add_item(rr_tree, hf_dns_csync_type_bitmap, tvb, cur_offset, rr_len, ENC_NA);
      dissect_type_bitmap(rr_tree, tvb, cur_offset, rr_len);
    }
    break;
    case T_ZONEMD: 
    {
      proto_tree_add_item(rr_tree, hf_dns_zonemd_serial, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      cur_offset += 4;
      proto_tree_add_item(rr_tree, hf_dns_zonemd_scheme, tvb, cur_offset, 1, ENC_NA);
      cur_offset += 1;
      proto_tree_add_item(rr_tree, hf_dns_zonemd_hash_algo, tvb, cur_offset, 1, ENC_NA);
      cur_offset += 1;
      proto_tree_add_item(rr_tree, hf_dns_zonemd_digest, tvb, cur_offset, data_len - 6 , ENC_NA);
    }
    break;
    case T_SVCB: 
    case T_HTTPS: 
    {
      guint32       priority = 0, value;
      guint32       svc_param_key;
      guint32       svc_param_offset;
      guint32       svc_param_length;
      guint32       svc_param_alpn_length;
      const gchar  *target;
      int           target_len;
      const guint8 *dohpath;
      int           start_offset = cur_offset;
      proto_item   *svcb_param_ti;
      proto_tree   *svcb_param_tree;
      proto_tree_add_item_ret_uint(rr_tree, hf_dns_svcb_priority, tvb, cur_offset, 2, ENC_BIG_ENDIAN, &priority);
      cur_offset += 2;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &target, &target_len);
      name_out = format_text(pinfo->pool, (const guchar*)target, target_len);
      proto_tree_add_string(rr_tree, hf_dns_svcb_target, tvb, cur_offset, used_bytes, name_out);
      cur_offset += used_bytes;
      if (data_len > cur_offset - start_offset) {
        while (data_len > cur_offset - start_offset) {
          svcb_param_ti = proto_tree_add_item(rr_tree, hf_dns_svcb_param, tvb, cur_offset, -1, ENC_NA);
          svcb_param_tree = proto_item_add_subtree(svcb_param_ti, ett_dns_svcb);
          proto_tree_add_item_ret_uint(svcb_param_tree, hf_dns_svcb_param_key, tvb, cur_offset, 2, ENC_BIG_ENDIAN, &svc_param_key);
          cur_offset += 2;
          proto_tree_add_item_ret_uint(svcb_param_tree, hf_dns_svcb_param_length, tvb, cur_offset, 2, ENC_BIG_ENDIAN, &svc_param_length);
          cur_offset += 2;
          proto_item_append_text(svcb_param_ti, ": %s", val_to_str(svc_param_key, dns_svcb_param_key_vals, "key%u"));
          proto_item_set_len(svcb_param_ti, svc_param_length + 4);
          switch(svc_param_key) {
            case DNS_SVCB_KEY_MANDATORY:
              for (svc_param_offset = 0; svc_param_offset < svc_param_length; svc_param_offset += 2) {
                guint32 key;
                proto_tree_add_item_ret_uint(svcb_param_tree, hf_dns_svcb_param_mandatory_key, tvb, cur_offset, 2, ENC_BIG_ENDIAN, &key);
                proto_item_append_text(svcb_param_ti, "%c%s", (svc_param_offset == 0 ? '=' : ','), val_to_str(key, dns_svcb_param_key_vals, "key%u"));
                cur_offset += 2;
              }
              break;
            case DNS_SVCB_KEY_ALPN:
              for (svc_param_offset = 0; svc_param_offset < svc_param_length; ) {
                const guint8 *alpn;
                proto_tree_add_item_ret_uint(svcb_param_tree, hf_dns_svcb_param_alpn_length, tvb, cur_offset, 1, ENC_BIG_ENDIAN, &svc_param_alpn_length);
                cur_offset += 1;
                proto_tree_add_item_ret_string(svcb_param_tree, hf_dns_svcb_param_alpn, tvb, cur_offset, svc_param_alpn_length, ENC_ASCII|ENC_NA, pinfo->pool, &alpn);
                cur_offset += svc_param_alpn_length;
                proto_item_append_text(svcb_param_ti, "%c%s", (svc_param_offset == 0 ? '=' : ','), alpn);
                svc_param_offset += 1 + svc_param_alpn_length;
              }
              break;
            case DNS_SVCB_KEY_NOALPN:
              break;
            case DNS_SVCB_KEY_PORT:
              proto_tree_add_item_ret_uint(svcb_param_tree, hf_dns_svcb_param_port, tvb, cur_offset, 2, ENC_BIG_ENDIAN, &value);
              proto_item_append_text(svcb_param_ti, "=%u", value);
              cur_offset += 2;
              break;
            case DNS_SVCB_KEY_IPV4HINT:
              for (svc_param_offset = 0; svc_param_offset < svc_param_length; svc_param_offset += 4) {
                proto_tree_add_item(svcb_param_tree, hf_dns_svcb_param_ipv4hint_ip, tvb, cur_offset, 4, ENC_NA);
                proto_item_append_text(svcb_param_ti, "%c%s", (svc_param_offset == 0 ? '=' : ','), tvb_ip_to_str(pinfo->pool, tvb, cur_offset));
                cur_offset += 4;
              }
              break;
            case DNS_SVCB_KEY_ECH:
            {
              tvbuff_t *next_tvb = tvb_new_subset_length(tvb, cur_offset, svc_param_length);
              cur_offset += call_dissector(tls_echconfig_handle, next_tvb, pinfo, svcb_param_tree);
              break;
            }
            case DNS_SVCB_KEY_IPV6HINT:
              for (svc_param_offset = 0; svc_param_offset < svc_param_length; svc_param_offset += 16) {
                proto_tree_add_item(svcb_param_tree, hf_dns_svcb_param_ipv6hint_ip, tvb, cur_offset, 16, ENC_NA);
                proto_item_append_text(svcb_param_ti, "%c%s", (svc_param_offset == 0 ? '=' : ','), tvb_ip6_to_str(pinfo->pool, tvb, cur_offset));
                cur_offset += 16;
              }
              break;
            case DNS_SVCB_KEY_DOHPATH:
              proto_tree_add_item_ret_string(svcb_param_tree, hf_dns_svcb_param_dohpath, tvb, cur_offset, svc_param_length, ENC_UTF_8|ENC_NA, pinfo->pool, &dohpath);
              cur_offset += svc_param_length;
              proto_item_append_text(svcb_param_ti, "=%s", dohpath);
              break;
            case DNS_SVCB_KEY_ODOHCONFIG:
              dissect_dns_svcparam_base64(svcb_param_tree, svcb_param_ti, hf_dns_svcb_param_odohconfig, tvb, cur_offset, svc_param_length);
              cur_offset += svc_param_length;
              break;
            default:
              if (svc_param_length > 0) {
                proto_tree_add_item(svcb_param_tree, hf_dns_svcb_param_value, tvb, cur_offset, svc_param_length, ENC_NA);
                proto_item_append_text(svcb_param_ti, "=%s", tvb_format_text(pinfo->pool, tvb, cur_offset, svc_param_length));
                cur_offset += svc_param_length;
              }
              break;
          }
        }
      }
    }
    break;
    case T_SPF: 
    {
      int rr_len = data_len;
      int spf_offset;
      int spf_len;
      spf_offset = cur_offset;
      while (rr_len != 0) {
        spf_len = tvb_get_guint8(tvb, spf_offset);
        proto_tree_add_item(rr_tree, hf_dns_spf_length, tvb, spf_offset, 1, ENC_BIG_ENDIAN);
        spf_offset += 1;
        rr_len     -= 1;
        proto_tree_add_item(rr_tree, hf_dns_spf, tvb, spf_offset, spf_len, ENC_ASCII);
        spf_offset +=  spf_len;
        rr_len     -= spf_len;
      }
    }
    break;
    case T_NID: 
    {
      proto_tree_add_item(rr_tree, hf_dns_ilnp_nodeid_preference, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_ilnp_nodeid, tvb, cur_offset, 8, ENC_NA);
    }
    break;
    case T_L32: 
    {
      proto_tree_add_item(rr_tree, hf_dns_ilnp_locator32_preference, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_ilnp_locator32, tvb, cur_offset, 4, ENC_NA);
    }
    break;
    case T_L64: 
    {
      proto_tree_add_item(rr_tree, hf_dns_ilnp_locator64_preference, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_ilnp_locator64, tvb, cur_offset, 8, ENC_NA);
    }
    break;
    case T_LP: 
    {
      int           lp_len;
      const gchar  *lp_str;
      proto_tree_add_item(rr_tree, hf_dns_ilnp_locatorfqdn_preference, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &lp_str, &lp_len);
      name_out = format_text(pinfo->pool, (const guchar*)lp_str, lp_len);
      proto_tree_add_string(rr_tree, hf_dns_ilnp_locatorfqdn, tvb, cur_offset, used_bytes, name_out);
    }
    break;
    case T_EUI48: 
    {
      proto_tree_add_item(rr_tree, hf_dns_eui48, tvb, cur_offset, 6, ENC_NA);
    }
    break;
    case T_EUI64: 
    {
      proto_tree_add_item(rr_tree, hf_dns_eui64, tvb, cur_offset, 8, ENC_NA);
    }
    break;
    case T_TKEY: 
    {
      const gchar  *tkey_algname;
      int           tkey_algname_len;
      guint16       tkey_mode, tkey_keylen, tkey_otherlen;
      proto_tree *key_tree;
      proto_item *key_item;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &tkey_algname, &tkey_algname_len);
      name_out = format_text(pinfo->pool, (const guchar*)tkey_algname, tkey_algname_len);
      proto_tree_add_string(rr_tree, hf_dns_tkey_algo_name, tvb, cur_offset, used_bytes, name_out);
      cur_offset += used_bytes;
      proto_tree_add_item(rr_tree, hf_dns_tkey_signature_inception, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      cur_offset += 4;
      proto_tree_add_item(rr_tree, hf_dns_tkey_signature_expiration, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      cur_offset += 4;
      proto_tree_add_item(rr_tree, hf_dns_tkey_mode, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      tkey_mode = tvb_get_ntohs(tvb, cur_offset);
      cur_offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_tkey_error, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_tkey_key_size, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      tkey_keylen = tvb_get_ntohs(tvb, cur_offset);
      cur_offset += 2;
      if (tkey_keylen != 0) {
        key_item = proto_tree_add_item(rr_tree, hf_dns_tkey_key_data, tvb, cur_offset, tkey_keylen, ENC_NA);
        key_tree = proto_item_add_subtree(key_item, ett_t_key);
        switch(tkey_mode) {
          case TKEYMODE_GSSAPI:
          {
            tvbuff_t *gssapi_tvb;
            gssapi_tvb = tvb_new_subset_length(tvb, cur_offset, tkey_keylen);
            if (tvb_strneql(gssapi_tvb, 0, "NTLMSSP", 7) == 0) {
              call_dissector(ntlmssp_handle, gssapi_tvb, pinfo, key_tree);
            } else {
              call_dissector(gssapi_handle, gssapi_tvb, pinfo, key_tree);
            }
          }
          break;
          default:
          break;
        }
        cur_offset += tkey_keylen;
      }
      proto_tree_add_item(rr_tree, hf_dns_tkey_other_size, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      tkey_otherlen = tvb_get_ntohs(tvb, cur_offset);
      cur_offset += 2;
      if (tkey_otherlen != 0) {
        proto_tree_add_item(rr_tree, hf_dns_tkey_other_data, tvb, cur_offset, tkey_otherlen, ENC_NA);
      }
    }
    break;
    case T_TSIG: 
    {
      guint16       tsig_siglen, tsig_otherlen;
      const gchar  *tsig_algname;
      int           tsig_algname_len;
      proto_item    *ti;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &tsig_algname, &tsig_algname_len);
      name_out = format_text(pinfo->pool, (const guchar*)tsig_algname, tsig_algname_len);
      proto_tree_add_string(rr_tree, hf_dns_tsig_algorithm_name, tvb, cur_offset, used_bytes, name_out);
      cur_offset += used_bytes;
      ti = proto_tree_add_item(rr_tree, hf_dns_tsig_time_signed ,tvb, cur_offset, 6, ENC_TIME_SECS|ENC_BIG_ENDIAN);
      if(tvb_get_ntohs(tvb, cur_offset)) 
      {
        proto_item_append_text(ti, " (high bits set)");
      }
      cur_offset += 6;
      proto_tree_add_item(rr_tree, hf_dns_tsig_fudge, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      tsig_siglen = tvb_get_ntohs(tvb, cur_offset);
      proto_tree_add_item(rr_tree, hf_dns_tsig_mac_size, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      if (tsig_siglen != 0) {
        proto_item *mac_item;
        proto_tree *mac_tree;
        tvbuff_t   *sub_tvb;
        mac_item = proto_tree_add_item(rr_tree, hf_dns_tsig_mac, tvb, cur_offset, tsig_siglen, ENC_NA);
        mac_tree = proto_item_add_subtree(mac_item, ett_dns_mac);
        sub_tvb=tvb_new_subset_length(tvb, cur_offset, tsig_siglen);
        if (!dissector_try_string(dns_tsig_dissector_table, tsig_algname, sub_tvb, pinfo, mac_tree, NULL)) {
          expert_add_info_format(pinfo, mac_item, &ei_dns_tsig_alg,
                "No dissector for algorithm:%s", name_out);
        }
        cur_offset += tsig_siglen;
      }
      proto_tree_add_item(rr_tree, hf_dns_tsig_original_id, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_tsig_error, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      cur_offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_tsig_other_len, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      tsig_otherlen = tvb_get_ntohs(tvb, cur_offset);
      cur_offset += 2;
      if (tsig_otherlen != 0) {
        proto_tree_add_item(rr_tree, hf_dns_tsig_other_data, tvb, cur_offset, tsig_otherlen, ENC_NA);
      }
    }
    break;
    case T_URI: 
    {
      int           rr_len   = data_len;
      guint16       priority = 0;
      guint16       weight   = 0;
      int           target_len = rr_len - 4;
      const gchar  *target;
      proto_tree_add_item(rr_tree, hf_dns_srv_priority, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      priority = tvb_get_ntohs(tvb, cur_offset);
      cur_offset += 2;
      proto_tree_add_item(rr_tree, hf_dns_srv_weight, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
      weight = tvb_get_ntohs(tvb, cur_offset);
      cur_offset += 2;
      target = (const char*)tvb_get_string_enc(pinfo->pool, tvb, cur_offset, target_len, ENC_ASCII|ENC_NA);
      proto_tree_add_string(rr_tree, hf_dns_srv_target, tvb, cur_offset, used_bytes, target);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %u %u %s", priority, weight, target);
      proto_item_append_text(trr,
                             ", priority %u, weight %u, target %s",
                             priority, weight, target);
    }
    break;
    case T_CAA: 
    {
      proto_item *caa_item;
      proto_tree *caa_tree;
      guint8 tag_len;
      const char *tag;
      gushort value_len;
      const guchar *value;
      int cur_hf = -1;
      caa_item = proto_tree_add_item(rr_tree, hf_dns_caa_flags, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      caa_tree = proto_item_add_subtree(caa_item, ett_caa_flags);
      proto_tree_add_item(caa_tree, hf_dns_caa_flag_issuer_critical, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
      cur_offset++;
      tag_len = tvb_get_guint8(tvb, cur_offset);
      tag = (const char*)tvb_get_string_enc(pinfo->pool, tvb, cur_offset + 1, tag_len, ENC_ASCII|ENC_NA);
      value_len = data_len - (tag_len + 2);
      value = (guchar*)tvb_get_string_enc(pinfo->pool, tvb, cur_offset + 1 + tag_len, value_len, ENC_ASCII|ENC_NA);
      value = (guchar*)format_text(pinfo->pool, value, value_len);
      if (strncmp(tag, "issue", tag_len) == 0) {
        cur_hf = hf_dns_caa_issue;
      } else if (strncmp(tag, "issuewild", tag_len) == 0) {
        cur_hf = hf_dns_caa_issuewild;
      } else if (strncmp(tag, "iodef", tag_len) == 0) {
        cur_hf = hf_dns_caa_iodef;
      } else {
        cur_hf = hf_dns_caa_unknown;
      }
      caa_item = proto_tree_add_string(rr_tree, cur_hf, tvb, cur_offset, 1 + tag_len + value_len, (const gchar*)value);
      caa_tree = proto_item_add_subtree(caa_item, ett_caa_data);
      proto_tree_add_uint(caa_tree, hf_dns_caa_tag_length, tvb, cur_offset, 1, tag_len);
      proto_tree_add_string(caa_tree, hf_dns_caa_tag, tvb, cur_offset + 1, tag_len, tag);
      proto_tree_add_string(caa_tree, hf_dns_caa_value, tvb, cur_offset + 1 + tag_len, value_len, (const gchar*)value);
    }
    break;
    case T_WINS:  
    {
      int     rr_len = data_len;
      guint32 nservers;
      proto_tree_add_item(rr_tree, hf_dns_wins_local_flag, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      cur_offset += 4;
      rr_len     -= 4;
      proto_tree_add_item(rr_tree, hf_dns_wins_lookup_timeout, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      cur_offset += 4;
      rr_len     -= 4;
      proto_tree_add_item(rr_tree, hf_dns_wins_cache_timeout, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      cur_offset += 4;
      rr_len     -= 4;
      proto_tree_add_item(rr_tree, hf_dns_wins_nb_wins_servers, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      nservers = tvb_get_ntohl(tvb, cur_offset);
      cur_offset += 4;
      rr_len     -= 4;
      while (rr_len != 0 && nservers != 0) {
        proto_tree_add_item(rr_tree, hf_dns_wins_server, tvb, cur_offset, 4, ENC_NA);
        cur_offset += 4;
        rr_len     -= 4;
        nservers--;
      }
    }
    break;
    case T_WINS_R: 
    {
      const gchar  *dname;
      int           dname_len;
      proto_tree_add_item(rr_tree, hf_dns_winsr_local_flag, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      cur_offset += 4;
      proto_tree_add_item(rr_tree, hf_dns_winsr_lookup_timeout, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      cur_offset += 4;
      proto_tree_add_item(rr_tree, hf_dns_winsr_cache_timeout, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
      cur_offset += 4;
      used_bytes = get_dns_name(tvb, cur_offset, 0, dns_data_offset, &dname, &dname_len);
      name_out = format_text(pinfo->pool, (const guchar*)dname, dname_len);
      proto_tree_add_string(rr_tree, hf_dns_winsr_name_result_domain, tvb, cur_offset, used_bytes, name_out);
      col_append_fstr(pinfo->cinfo, COL_INFO, " %s", name_out);
      proto_item_append_text(trr, ", name result domain %s", name_out);
    }
    break;
    case T_XPF: 
    {
      guint32 address_family;
      proto_tree_add_item_ret_uint(rr_tree, hf_dns_xpf_ip_version, tvb, cur_offset, 1, ENC_BIG_ENDIAN, &address_family);
      cur_offset++;
      switch (address_family) {
        case IP_VERSION_NUM_INET:
          proto_tree_add_item(rr_tree, hf_dns_xpf_protocol, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
          cur_offset++;
          proto_tree_add_item(rr_tree, hf_dns_xpf_source_ipv4, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
          cur_offset += 4;
          proto_tree_add_item(rr_tree, hf_dns_xpf_destination_ipv4, tvb, cur_offset, 4, ENC_BIG_ENDIAN);
          cur_offset += 4;
          proto_tree_add_item(rr_tree, hf_dns_xpf_sport, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
          cur_offset += 2;
          proto_tree_add_item(rr_tree, hf_dns_xpf_dport, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
        break;
        case IP_VERSION_NUM_INET6:
          proto_tree_add_item(rr_tree, hf_dns_xpf_protocol, tvb, cur_offset, 1, ENC_BIG_ENDIAN);
          cur_offset++;
          proto_tree_add_item(rr_tree, hf_dns_xpf_source_ipv6, tvb, cur_offset, 16, ENC_NA);
          cur_offset += 16;
          proto_tree_add_item(rr_tree, hf_dns_xpf_destination_ipv6, tvb, cur_offset, 16, ENC_NA);
          cur_offset += 16;
          proto_tree_add_item(rr_tree, hf_dns_xpf_sport, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
          cur_offset += 2;
          proto_tree_add_item(rr_tree, hf_dns_xpf_dport, tvb, cur_offset, 2, ENC_BIG_ENDIAN);
        break;
        default: 
        break;
      }
    }
    break;
    default:
    {
      expert_add_info_format(pinfo, trr, &ei_dns_undecoded_option,
                                 "Dissector for DNS Type (%d)"
                                 " code not implemented, Contact Wireshark developers"
                                 " if you want this supported", dns_type);
      proto_tree_add_item(rr_tree, hf_dns_data, tvb, cur_offset, data_len, ENC_NA);
    }
    break;
  }
  data_offset += data_len;
  return data_offset - data_start;
}
