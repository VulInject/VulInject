static void jpeg_table_header(AVCodecContext *avctx, PutBitContext *p,
                              MJpegContext *m,
                              const uint8_t intra_matrix_permutation[64],
                              uint16_t luma_intra_matrix[64],
                              uint16_t chroma_intra_matrix[64],
                              int hsample[3], int use_slices, int matrices_differ)
{
    int i, j, size;
    uint8_t *ptr;
    if (m) {
        int matrix_count = 1 + matrices_differ;
        if (m->force_duplicated_matrix)
            matrix_count = 2;
        /* quant matrixes */
        put_marker(p, DQT);
        put_bits(p, 16, 2 + matrix_count * (1 + 64));
        put_bits(p, 4, 0); /* 8 bit precision */
        put_bits(p, 4, 0); /* table 0 */
        for (int i = 0; i < 64; i++) {
            uint8_t j = intra_matrix_permutation[i];
            put_bits(p, 8, luma_intra_matrix[j]);
        }
        if (matrix_count > 1) {
            put_bits(p, 4, 0); /* 8 bit precision */
            put_bits(p, 4, 1); /* table 1 */
            for(i=0;i<64;i++) {
                j = intra_matrix_permutation[i];
                put_bits(p, 8, chroma_intra_matrix[j]);
            }
        }
    }
    if (use_slices) {
        put_marker(p, DRI);
        put_bits(p, 16, 4);
        put_bits(p, 16, (avctx->width-1)/(8*hsample[0]) + 1);
    }
    /* huffman table */
    put_marker(p, DHT);
    ptr = put_bits_ptr(p);
    put_bits(p, 16, 0); /* patched later */
    size = 2;
    // Only MJPEG can have a variable Huffman variable. All other
    // formats use the default Huffman table.
    if (m && m->huffman == HUFFMAN_TABLE_OPTIMAL) {
        size += put_huffman_table(p, 0, 0, m->bits_dc_luminance,
                                  m->val_dc_luminance);
        size += put_huffman_table(p, 0, 1, m->bits_dc_chrominance,
                                  m->val_dc_chrominance);
        size += put_huffman_table(p, 1, 0, m->bits_ac_luminance,
                                  m->val_ac_luminance);
        size += put_huffman_table(p, 1, 1, m->bits_ac_chrominance,
                                  m->val_ac_chrominance);
    } else {
        size += put_huffman_table(p, 0, 0, ff_mjpeg_bits_dc_luminance,
                                  ff_mjpeg_val_dc);
        size += put_huffman_table(p, 0, 1, ff_mjpeg_bits_dc_chrominance,
                                  ff_mjpeg_val_dc);
        size += put_huffman_table(p, 1, 0, ff_mjpeg_bits_ac_luminance,
                                  ff_mjpeg_val_ac_luminance);
        size += put_huffman_table(p, 1, 1, ff_mjpeg_bits_ac_chrominance,
                                  ff_mjpeg_val_ac_chrominance);
    }
    AV_WB16(ptr, size);
}
