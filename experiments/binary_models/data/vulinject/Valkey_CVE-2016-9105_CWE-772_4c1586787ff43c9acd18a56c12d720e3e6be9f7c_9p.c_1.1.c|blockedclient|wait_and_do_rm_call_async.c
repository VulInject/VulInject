int wait_and_do_rm_call_async(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    UNUSED(argv);
    UNUSED(argc);
    if(argc < 2){
        return RedisModule_WrongArity(ctx);
    }
    int flags = RedisModule_GetContextFlags(ctx);
    if (flags & REDISMODULE_CTX_FLAGS_DENY_BLOCKING) {
        return RedisModule_ReplyWithError(ctx, "Err can not run wait, blocking is not allowed.");
    }
    RedisModuleCallReply* rep = RedisModule_Call(ctx, "wait", "!EKcc", "1", "0");
    if(RedisModule_CallReplyType(rep) != REDISMODULE_REPLY_PROMISE) {
    } else {
        RedisModuleBlockedClient *bc = RedisModule_BlockClient(ctx, NULL, NULL, NULL, 0);
        WaitAndDoRMCallCtx *wctx = RedisModule_Alloc(sizeof(*wctx));
        *wctx = (WaitAndDoRMCallCtx){
                .bc = bc,
                .argv = RedisModule_Alloc((argc - 1) * sizeof(RedisModuleString*)),
                .argc = argc - 1,
        };
        for (int i = 1 ; i < argc ; ++i) {
            wctx->argv[i - 1] = RedisModule_HoldString(NULL, argv[i]);
        }
        RedisModule_CallReplyPromiseSetUnblockHandler(rep, wait_and_do_rm_call_async_on_unblocked, wctx);
        RedisModule_FreeCallReply(rep);
    }
    return REDISMODULE_OK;
}
