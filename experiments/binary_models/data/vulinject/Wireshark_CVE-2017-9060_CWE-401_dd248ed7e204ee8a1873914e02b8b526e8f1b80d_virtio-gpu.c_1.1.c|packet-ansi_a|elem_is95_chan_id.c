elem_is95_chan_id(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 offset, guint len, ansi_a_shared_data_t *data_p)
{
    guint8      oct;
    guint8      num_chans;
    guint8      chan_num;
    guint32     value;
    guint32     curr_offset;
    proto_tree  *subtree;
    curr_offset = offset;
    proto_tree_add_item(tree, hf_ansi_a_is95_chan_id_hho, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
    proto_tree_add_item(tree, hf_ansi_a_is95_chan_id_num_chans_add, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
    oct = tvb_get_guint8(tvb, curr_offset);
    proto_tree_add_uint_format_value(tree, hf_ansi_a_is95_chan_id_frame_offset, tvb, curr_offset, 1,
        oct, "%u (%.2f ms)", oct & 0x0f, (oct & 0x0f) * 1.25);
    num_chans = (oct & 0x70) >> 4;
    curr_offset++;
    if (num_chans > 0)
    {
        SHORT_DATA_CHECK(len - (curr_offset - offset), 4);
        chan_num = 0;
        do
        {
            subtree =
                proto_tree_add_subtree_format(tree, tvb, curr_offset, 4,
                    ett_chan_list, NULL, "Channel [%u]", chan_num + 1);
            proto_tree_add_item(subtree, hf_ansi_a_is95_chan_id_walsh_code_chan_idx, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
            curr_offset += 1;
            proto_tree_add_item(subtree, hf_ansi_a_is95_chan_id_pilot_pn, tvb, curr_offset, 3, ENC_BIG_ENDIAN);
            proto_tree_add_item(subtree, hf_ansi_a_is95_chan_id_power_combined, tvb, curr_offset, 3, ENC_BIG_ENDIAN);
            proto_tree_add_item(subtree, hf_ansi_a_is95_chan_id_freq_incl, tvb, curr_offset, 3, ENC_BIG_ENDIAN);
            proto_tree_add_item(subtree, hf_ansi_a_reserved_bits_24_001800, tvb, curr_offset, 3, ENC_BIG_ENDIAN);
            proto_tree_add_item(subtree, hf_ansi_a_is95_chan_id_channel_number, tvb, curr_offset, 3, ENC_BIG_ENDIAN);
            if (chan_num == 0)
            {
                value = tvb_get_ntohs(tvb, curr_offset + 1);
                proto_item_append_text(data_p->elem_item, " - (ARFCN: %u)", value & 0x07ff);
            }
            curr_offset += 3;
            chan_num++;
        }
        while (((len - (curr_offset - offset)) >= 4) &&
            (chan_num < num_chans));
    }
    EXTRANEOUS_DATA_CHECK(len, curr_offset - offset);
    return curr_offset - offset;
}
