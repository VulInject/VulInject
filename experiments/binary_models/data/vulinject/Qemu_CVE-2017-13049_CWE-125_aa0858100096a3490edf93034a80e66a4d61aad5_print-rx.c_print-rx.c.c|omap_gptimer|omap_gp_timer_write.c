static void omap_gp_timer_write(void *opaque, hwaddr addr, uint32_t value)
{
    struct omap_gp_timer_s *s = opaque;
    switch (addr) {
    case 0x00:	/* TIDR */
    case 0x14:	/* TISTAT */
    case 0x34:	/* TWPS */
    case 0x3c:	/* TCAR1 */
    case 0x44:	/* TCAR2 */
        break;
    case 0x10:	/* TIOCP_CFG */
        s->config = value & 0x33d;
        if (((value >> 3) & 3) == 3)				/* IDLEMODE */
            fprintf(stderr, "%s: illegal IDLEMODE value in TIOCP_CFG\n",
                            __func__);
        if (value & 2)						/* SOFTRESET */
            omap_gp_timer_reset(s);
        break;
    case 0x18:	/* TISR */
        if (value & GPT_TCAR_IT)
            s->capt_num = 0;
        if (s->status && !(s->status &= ~value))
            qemu_irq_lower(s->irq);
        break;
    case 0x1c:	/* TIER */
        s->it_ena = value & 7;
        break;
    case 0x20:	/* TWER */
        s->wu_ena = value & 7;
        break;
    case 0x24:	/* TCLR */
        omap_gp_timer_sync(s);
        s->inout = (value >> 14) & 1;
        s->capt2 = (value >> 13) & 1;
        s->pt = (value >> 12) & 1;
        s->trigger = (value >> 10) & 3;
        if (s->capture == gpt_capture_none &&
                        ((value >> 8) & 3) != gpt_capture_none)
            s->capt_num = 0;
        s->capture = (value >> 8) & 3;
        s->scpwm = (value >> 7) & 1;
        s->ce = (value >> 6) & 1;
        s->pre = (value >> 5) & 1;
        s->ptv = (value >> 2) & 7;
        s->ar = (value >> 1) & 1;
        s->st = (value >> 0) & 1;
        if (s->inout && s->trigger != gpt_trigger_none)
            fprintf(stderr, "%s: GP timer pin must be an output "
                            "for this trigger mode\n", __func__);
        if (!s->inout && s->capture != gpt_capture_none)
            fprintf(stderr, "%s: GP timer pin must be an input "
                            "for this capture mode\n", __func__);
        if (s->trigger == gpt_trigger_none)
            omap_gp_timer_out(s, s->scpwm);
        /* TODO: make sure this doesn't overflow 32-bits */
        s->ticks_per_sec = NANOSECONDS_PER_SECOND << (s->pre ? s->ptv + 1 : 0);
        omap_gp_timer_update(s);
        break;
    case 0x28:	/* TCRR */
        s->time = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);
        s->val = value;
        omap_gp_timer_update(s);
        break;
    case 0x2c:	/* TLDR */
        s->load_val = value;
        break;
    case 0x30:	/* TTGR */
        s->time = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);
        s->val = s->load_val;
        omap_gp_timer_update(s);
        break;
    case 0x38:	/* TMAR */
        omap_gp_timer_sync(s);
        s->match_val = value;
        omap_gp_timer_update(s);
        break;
    case 0x40:	/* TSICR */
        s->posted = (value >> 2) & 1;
        if (value & 2)	/* How much exactly are we supposed to reset? */
            omap_gp_timer_reset(s);
        break;
    default:
        OMAP_BAD_REG(addr);
    }
}
