static int iwl_set_hw_address(struct iwl_trans *trans,
			      const struct iwl_cfg *cfg,
			      struct iwl_nvm_data *data, const __be16 *nvm_hw,
			      const __le16 *mac_override)
{
	if (cfg->mac_addr_from_csr) {
	} else if (cfg->nvm_type != IWL_NVM_EXT) {
		const unsigned char *hw_addr = (const unsigned char *)(nvm_hw + HW_ADDR);
		data->hw_addr[0] = hw_addr[1];
		data->hw_addr[1] = hw_addr[0];
		data->hw_addr[2] = hw_addr[3];
		data->hw_addr[3] = hw_addr[2];
		data->hw_addr[4] = hw_addr[5];
		data->hw_addr[5] = hw_addr[4];
	} else {
		iwl_set_hw_address_family_8000(trans, cfg, data,
					       mac_override, nvm_hw);
	}
	if (!is_valid_ether_addr(data->hw_addr)) {
		IWL_ERR(trans, "no valid mac address was found\n");
		return -EINVAL;
	}
	if (!trans->csme_own)
		IWL_INFO(trans, "base HW address: %pM, OTP minor version: 0x%x\n",
			 data->hw_addr, iwl_read_prph(trans, REG_OTP_MINOR));
	return 0;
}
