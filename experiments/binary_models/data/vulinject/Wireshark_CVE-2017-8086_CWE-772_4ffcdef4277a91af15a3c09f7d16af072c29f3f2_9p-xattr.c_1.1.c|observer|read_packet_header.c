read_packet_header(wtap *wth, FILE_T fh, union wtap_pseudo_header *pseudo_header,
    packet_entry_header *packet_header, int *err, char **err_info)
{
    int offset;
    unsigned i;
    tlv_header tlvh;
    tlv_wireless_info wireless_header;
    offset = 0;
    if (!wtap_read_bytes_or_eof(fh, packet_header, sizeof *packet_header,
                                err, err_info)) {
        if (*err != 0)
            return -1;
        return 0;    
    }
    offset += (int)sizeof *packet_header;
    PACKET_ENTRY_HEADER_FROM_LE_IN_PLACE(*packet_header);
    if (packet_header->packet_magic != observer_packet_magic) {
        for (i = 0; i < sizeof *packet_header; i++) {
            if (((unsigned char*) packet_header)[i] != 0)
                break;
        }
        if (i == sizeof *packet_header) {
            *err = 0;
            return 0;    
        }
        *err = WTAP_ERR_BAD_FILE;
        *err_info = ws_strdup_printf("Observer: bad record: Invalid magic number 0x%08x",
            packet_header->packet_magic);
        return -1;
    }
    switch (wth->file_encap) {
    case WTAP_ENCAP_ETHERNET:
        pseudo_header->eth.fcs_len = 0;
        break;
    case WTAP_ENCAP_IEEE_802_11_WITH_RADIO:
        memset(&pseudo_header->ieee_802_11, 0, sizeof(pseudo_header->ieee_802_11));
        pseudo_header->ieee_802_11.fcs_len = 0;
        pseudo_header->ieee_802_11.decrypted = false;
        pseudo_header->ieee_802_11.datapad = false;
        pseudo_header->ieee_802_11.phy = PHDR_802_11_PHY_UNKNOWN;
        break;
    }
    for (i = 0; i < packet_header->number_of_information_elements; i++) {
        unsigned tlv_data_length;
        if (!wtap_read_bytes(fh, &tlvh, sizeof tlvh, err, err_info))
            return -1;
        offset += (int)sizeof tlvh;
        if (tlvh.length < sizeof tlvh) {
            *err = WTAP_ERR_BAD_FILE;
            *err_info = ws_strdup_printf("Observer: bad record (TLV length %u < %zu)",
                tlvh.length, sizeof tlvh);
            return -1;
        }
        tlv_data_length = tlvh.length - (unsigned)sizeof tlvh;
        switch (tlvh.type) {
        case INFORMATION_TYPE_WIRELESS:
            if (tlv_data_length != sizeof wireless_header) {
                *err = WTAP_ERR_BAD_FILE;
                *err_info = ws_strdup_printf("Observer: bad record (wireless TLV length %u != %zu)",
                    tlvh.length, sizeof tlvh + sizeof wireless_header);
                return -1;
            }
            if (!wtap_read_bytes(fh, &wireless_header, sizeof wireless_header,
                                 err, err_info))
                return -1;
            pseudo_header->ieee_802_11.decrypted = (wireless_header.conditions & WIRELESS_WEP_SUCCESS) != 0;
            pseudo_header->ieee_802_11.has_channel = true;
            pseudo_header->ieee_802_11.channel = wireless_header.frequency;
            pseudo_header->ieee_802_11.has_data_rate = true;
            pseudo_header->ieee_802_11.data_rate = wireless_header.rate;
            pseudo_header->ieee_802_11.has_signal_percent = true;
            pseudo_header->ieee_802_11.signal_percent = wireless_header.strengthPercent;
            if (RATE_IS_DSSS(pseudo_header->ieee_802_11.data_rate)) {
                pseudo_header->ieee_802_11.phy = PHDR_802_11_PHY_11B;
                pseudo_header->ieee_802_11.phy_info.info_11b.has_short_preamble = false;
            } else if (RATE_IS_OFDM(pseudo_header->ieee_802_11.data_rate)) {
                if (CHAN_IS_BG(pseudo_header->ieee_802_11.channel)) {
                    pseudo_header->ieee_802_11.phy = PHDR_802_11_PHY_11G;
                    pseudo_header->ieee_802_11.phy_info.info_11g.has_mode = false;
                } else {
                    pseudo_header->ieee_802_11.phy = PHDR_802_11_PHY_11A;
                    pseudo_header->ieee_802_11.phy_info.info_11a.has_channel_type = false;
                    pseudo_header->ieee_802_11.phy_info.info_11a.has_turbo_type = false;
                }
            }
            offset += (int)sizeof wireless_header;
            break;
        default:
            if (tlv_data_length != 0) {
                if (!wtap_read_bytes(fh, NULL, tlv_data_length, err, err_info))
                    return -1;
            }
            offset += tlv_data_length;
        }
    }
    return offset;
}
