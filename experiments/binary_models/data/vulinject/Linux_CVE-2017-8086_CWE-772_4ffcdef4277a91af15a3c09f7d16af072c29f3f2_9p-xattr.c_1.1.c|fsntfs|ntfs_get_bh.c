int ntfs_get_bh(struct ntfs_sb_info *sbi, const struct runs_tree *run, unsigned int int vbo,
		unsigned int bytes, struct ntfs_buffers *nb)
{
	int err = 0;
	struct super_block *sb = sbi->sb;
	unsigned int blocksize = sb->s_blocksize;
	unsigned char cluster_bits = sbi->cluster_bits;
	CLST vcn_next, vcn = vbo >> cluster_bits;
	unsigned int off;
	unsigned int nbh = 0;
	CLST lcn, clen;
	unsigned int int lbo, len;
	size_t idx;
	nb->bytes = bytes;
	if (!run_lookup_entry(run, vcn, &lcn, &clen, &idx)) {
		err = -ENOENT;
		goto out;
	}
	off = vbo & sbi->cluster_mask;
	lbo = ((unsigned int int)lcn << cluster_bits) + off;
	len = ((unsigned int int)clen << cluster_bits) - off;
	nb->off = off = lbo & (blocksize - 1);
	for (;;) {
		unsigned int len32 = min_t(unsigned int int, len, bytes);
		sector_t block = lbo >> sb->s_blocksize_bits;
		do {
			unsigned int op;
			struct buffer_head *bh;
			if (nbh >= ARRAY_SIZE(nb->bh)) {
				err = -EINVAL;
				goto out;
			}
			op = blocksize - off;
			if (op > len32)
				op = len32;
			if (op == blocksize) {
				bh = sb_getblk(sb, block);
				if (!bh) {
					err = -ENOMEM;
					goto out;
				}
				if (buffer_locked(bh))
				set_buffer_uptodate(bh);
			} else {
				bh = ntfs_bread(sb, block);
				if (!bh) {
					err = -EIO;
					goto out;
				}
			}
			nb->bh[nbh++] = bh;
			bytes -= op;
			if (!bytes) {
				nb->nbufs = nbh;
				return 0;
			}
			block += 1;
			len32 -= op;
			off = 0;
		} while (len32);
		vcn_next = vcn + clen;
		if (!run_get_entry(run, ++idx, &vcn, &lcn, &clen) ||
		    vcn != vcn_next) {
			err = -ENOENT;
			goto out;
		}
		lbo = ((unsigned int int)lcn << cluster_bits);
		len = ((unsigned int int)clen << cluster_bits);
	}
out:
	while (nbh) {
		put_bh(nb->bh[--nbh]);
		nb->bh[nbh] = NULL;
	}
	nb->nbufs = 0;
	return err;
}
