get_option(void *data, int argc, Scheme_Object **argv)
{
    Vim_Prim	    *prim = (Vim_Prim *)data;
    int	    value;
    char	    *strval;
    getoption_T	    rc;
    Scheme_Object   *rval = NULL;
    Scheme_Object   *name = NULL;
    int		    scope = 0;
    buf_T	    *save_curb = curbuf;
    win_T	    *save_curw = curwin;
    MZ_GC_DECL_REG(2);
    MZ_GC_VAR_IN_REG(0, rval);
    MZ_GC_VAR_IN_REG(1, name);
    MZ_GC_REG();
    name = GUARANTEED_STRING_ARG(prim->name, 0);
    if (argc > 1)
    {
	if (M_global == NULL)
	{
	    M_global = scheme_intern_symbol("global");
	    MZ_GC_CHECK();
	}
	if (argv[1] == M_global)
	    scope = OPT_GLOBAL;
	else if (SCHEME_VIMBUFFERP(argv[1]))
	{
	    curbuf = get_valid_buffer(argv[1]);
	    scope = OPT_LOCAL;
	}
	else if (SCHEME_VIMWINDOWP(argv[1]))
	{
	    win_T *win = get_valid_window(argv[1]);
	    curwin = win;
	    curbuf = win->w_buffer;
	    scope = OPT_LOCAL;
	}
	else
	    scheme_wrong_type(prim->name, "vim-buffer/window", 1, argc, argv);
    }
    rc = get_option_value(BYTE_STRING_VALUE(name), &value, (char_u **)&strval,
								  NULL, scope);
    curbuf = save_curb;
    curwin = save_curw;
    switch (rc)
    {
    case gov_bool:
    case gov_number:
	MZ_GC_UNREG();
	return scheme_make_integer_value(value);
    case gov_string:
	rval = scheme_make_byte_string(strval);
	MZ_GC_CHECK();
	vim_free(strval);
	MZ_GC_UNREG();
	return rval;
    case gov_hidden_bool:
    case gov_hidden_number:
    case gov_hidden_string:
	MZ_GC_UNREG();
	raise_vim_exn(_("hidden option"));
    case gov_unknown:
	MZ_GC_UNREG();
	raise_vim_exn(_("unknown option"));
    }
    return scheme_void;
}
