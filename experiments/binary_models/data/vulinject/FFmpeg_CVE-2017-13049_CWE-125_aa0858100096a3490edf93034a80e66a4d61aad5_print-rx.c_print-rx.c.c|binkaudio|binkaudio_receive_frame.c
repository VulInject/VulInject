static int binkaudio_receive_frame(AVCodecContext *avctx, AVFrame *frame)
{
    BinkAudioContext *s = avctx->priv_data;
    GetBitContext *gb = &s->gb;
    int new_pkt, ret;
again:
    new_pkt = !s->pkt->data;
    if (!s->pkt->data) {
        ret = ff_decode_get_packet(avctx, s->pkt);
        if (ret < 0) {
            s->ch_offset = 0;
            return ret;
        }
        if (s->pkt->size < 4) {
            av_log(avctx, AV_LOG_ERROR, "Packet is too small\n");
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }
        ret = init_get_bits8(gb, s->pkt->data, s->pkt->size);
        if (ret < 0)
            goto fail;
        /* skip reported size */
        skip_bits_long(gb, 32);
    }
    /* get output buffer */
    if (s->ch_offset == 0) {
        frame->nb_samples = s->frame_len;
        if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
            goto fail;
        if (!new_pkt)
            frame->pts = AV_NOPTS_VALUE;
    }
    if (decode_block(s, (float **)frame->extended_data,
                     avctx->codec->id == AV_CODEC_ID_BINKAUDIO_DCT,
                     FFMIN(MAX_CHANNELS, s->channels - s->ch_offset), s->ch_offset)) {
        av_log(avctx, AV_LOG_ERROR, "Incomplete packet\n");
        ret = AVERROR_INVALIDDATA;
        goto fail;
    }
    s->ch_offset += MAX_CHANNELS;
    if (!get_bits_left(gb)) {
        memset(gb, 0, sizeof(*gb));
        av_packet_unref(s->pkt);
    }
    if (s->ch_offset >= s->channels) {
        s->ch_offset = 0;
    } else {
        goto again;
    }
    frame->nb_samples = s->block_size / FFMIN(avctx->ch_layout.nb_channels, MAX_CHANNELS);
    return 0;
fail:
    s->ch_offset = 0;
    av_packet_unref(s->pkt);
    return ret;
}
