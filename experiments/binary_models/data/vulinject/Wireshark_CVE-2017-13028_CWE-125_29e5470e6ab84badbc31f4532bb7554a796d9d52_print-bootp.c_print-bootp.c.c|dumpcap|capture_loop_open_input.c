capture_loop_open_input(capture_options *capture_opts, loop_data *ld,
                        char *errmsg, size_t errmsg_len,
                        char *secondary_errmsg, size_t secondary_errmsg_len)
{
    cap_device_open_status open_status;
    gchar               open_status_str[PCAP_ERRBUF_SIZE];
    gchar              *sync_msg_str;
    interface_options  *interface_opts;
    capture_src        *pcap_src;
    guint               i;
    if ((use_threads == FALSE) &&
        (capture_opts->ifaces->len > 1)) {
        snprintf(errmsg, errmsg_len,
                   "Using threads is required for capturing on multiple interfaces.");
        return FALSE;
    }
    int pcapng_src_count = 0;
    for (i = 0; i < capture_opts->ifaces->len; i++) {
        interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);
        pcap_src = g_new0(capture_src, 1);
        if (pcap_src == NULL) {
            snprintf(errmsg, errmsg_len,
                   "Could not allocate memory.");
            return FALSE;
        }
#ifdef MUST_DO_SELECT
        pcap_src->pcap_fd = -1;
#endif
        pcap_src->interface_id = i;
        pcap_src->linktype = -1;
#ifdef _WIN32
        pcap_src->cap_pipe_h = INVALID_HANDLE_VALUE;
#endif
        pcap_src->cap_pipe_fd = -1;
        pcap_src->cap_pipe_dispatch = pcap_pipe_dispatch;
        pcap_src->cap_pipe_state = STATE_EXPECT_REC_HDR;
        pcap_src->cap_pipe_err = PIPOK;
#ifdef _WIN32
        pcap_src->cap_pipe_read_mtx = g_new(GMutex, 1);
        pcap_src->cap_pipe_pending_q = g_async_queue_new();
        pcap_src->cap_pipe_done_q = g_async_queue_new();
#endif
        g_array_append_val(ld->pcaps, pcap_src);
        ws_debug("capture_loop_open_input : %s", interface_opts->name);
        pcap_src->pcap_h = open_capture_device(capture_opts, interface_opts,
            CAP_READ_TIMEOUT, &open_status, &open_status_str);
        if (pcap_src->pcap_h != NULL) {
#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
            pcap_src->ts_nsec = have_high_resolution_timestamp(pcap_src->pcap_h);
#endif
#if defined(HAVE_PCAP_SETSAMPLING)
            if (interface_opts->sampling_method != CAPTURE_SAMP_NONE) {
                struct pcap_samp *samp;
                if ((samp = pcap_setsampling(pcap_src->pcap_h)) != NULL) {
                    switch (interface_opts->sampling_method) {
                    case CAPTURE_SAMP_BY_COUNT:
                        samp->method = PCAP_SAMP_1_EVERY_N;
                        break;
                    case CAPTURE_SAMP_BY_TIMER:
                        samp->method = PCAP_SAMP_FIRST_AFTER_N_MS;
                        break;
                    default:
                        sync_msg_str = ws_strdup_printf(
                            "Unknown sampling method %d specified,\n"
                            "continue without packet sampling",
                            interface_opts->sampling_method);
                        report_capture_error("Couldn't set the capture "
                                             "sampling", sync_msg_str);
                        g_free(sync_msg_str);
                    }
                    samp->value = interface_opts->sampling_param;
                } else {
                    report_capture_error("Couldn't set the capture sampling",
                                         "Cannot get packet sampling data structure");
                }
            }
#endif
            if (!set_pcap_datalink(pcap_src->pcap_h, interface_opts->linktype,
                                   interface_opts->name,
                                   errmsg, errmsg_len,
                                   secondary_errmsg, secondary_errmsg_len)) {
                return FALSE;
            }
            pcap_src->linktype = dlt_to_linktype(get_pcap_datalink(pcap_src->pcap_h, interface_opts->name));
        } else {
            gboolean pipe_err = FALSE;
            cap_pipe_open_live(interface_opts->name, pcap_src,
                               &pcap_src->cap_pipe_info.pcap.hdr,
                               errmsg, errmsg_len,
                               secondary_errmsg, secondary_errmsg_len);
#ifdef _WIN32
            if (pcap_src->from_cap_socket) {
#endif
                if (pcap_src->cap_pipe_fd == -1) {
                    pipe_err = TRUE;
                }
#ifdef _WIN32
            } else {
                if (pcap_src->cap_pipe_h == INVALID_HANDLE_VALUE) {
                    pipe_err = TRUE;
                }
            }
#endif
            if (pipe_err) {
                if (pcap_src->cap_pipe_err == PIPNEXIST) {
                    get_capture_device_open_failure_messages(open_status,
                                                             open_status_str,
                                                             interface_opts->name,
                                                             errmsg,
                                                             errmsg_len,
                                                             secondary_errmsg,
                                                             secondary_errmsg_len);
                }
                return FALSE;
            } else {
                open_status = CAP_DEVICE_OPEN_NO_ERR;
            }
        }
#ifdef MUST_DO_SELECT
        if (!pcap_src->from_cap_pipe) {
            pcap_src->pcap_fd = pcap_get_selectable_fd(pcap_src->pcap_h);
        }
#endif
        if (open_status != CAP_DEVICE_OPEN_NO_ERR) {
            sync_msg_str = ws_strdup_printf("%s.", open_status_str);
            report_capture_error(sync_msg_str, "");
            g_free(sync_msg_str);
        }
        if (pcap_src->from_pcapng) {
            pcapng_src_count++;
        } else {
            saved_idb_t idb_source = { 0 };
            idb_source.interface_id = i;
            g_rw_lock_writer_lock (&ld->saved_shb_idb_lock);
            pcap_src->idb_id = global_ld.saved_idbs->len;
            g_array_append_val(global_ld.saved_idbs, idb_source);
            g_rw_lock_writer_unlock (&ld->saved_shb_idb_lock);
            ws_debug("%s: saved capture_opts %u to IDB %u",
                  G_STRFUNC, i, pcap_src->idb_id);
        }
    }
    if (capture_opts->ifaces->len == 1 && pcapng_src_count == 1) {
        ld->pcapng_passthrough = TRUE;
        g_rw_lock_writer_lock (&ld->saved_shb_idb_lock);
        ws_assert(global_ld.saved_idbs->len == 0);
        ws_debug("%s: Pass through SHBs and IDBs directly", G_STRFUNC);
        g_rw_lock_writer_unlock (&ld->saved_shb_idb_lock);
    }
#ifndef HAVE_LIBCAP
    relinquish_special_privs_perm();
#else
    relinquish_all_capabilities();
#endif
    return TRUE;
}
