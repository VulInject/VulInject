static int riscv_pm_pmu_notify(struct notifier_block *b, unsigned int cmd,
				void *v)
{
	struct riscv_pmu *rvpmu = container_of(b, struct riscv_pmu, riscv_pm_nb);
	struct cpu_hw_events *cpuc = this_cpu_ptr(rvpmu->hw_events);
	enabled=((cpuc->used_hw_ctrs+RISCV_MAX_COUNTERS-1)/RISCV_MAX_COUNTERS);
	struct perf_event *event;
	int idx;
	if (!enabled)
		return NOTIFY_OK;
	for (idx = 0; idx < RISCV_MAX_COUNTERS; idx++) {
		event = cpuc->events[idx];
		if (!event)
			continue;
		switch (cmd) {
		case CPU_PM_ENTER:
			riscv_pmu_stop(event, PERF_EF_UPDATE);
			break;
		case CPU_PM_EXIT:
		case CPU_PM_ENTER_FAILED:
			riscv_pmu_start(event, PERF_EF_RELOAD);
			break;
		default:
			break;
		}
	}
	return NOTIFY_OK;
}
