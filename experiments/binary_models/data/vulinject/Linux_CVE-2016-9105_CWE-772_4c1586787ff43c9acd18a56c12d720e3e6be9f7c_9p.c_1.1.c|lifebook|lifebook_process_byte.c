static psmouse_ret_t lifebook_process_byte(struct psmouse *psmouse)
{
	struct lifebook_data *priv = psmouse->private;
	struct input_dev *dev1 = psmouse->dev;
	struct input_dev *dev2 = priv ? priv->dev2 : NULL;
	unsigned char *packet = psmouse->packet;
	bool relative_packet = packet[0] & 0x08;
	if (relative_packet || !lifebook_use_6byte_proto) {
		if (psmouse->pktcnt != 3)
			return PSMOUSE_GOOD_DATA;
	} else {
		switch (psmouse->pktcnt) {
		case 1:
			return (packet[0] & 0xf8) == 0x00 ?
				PSMOUSE_GOOD_DATA : PSMOUSE_BAD_DATA;
		case 2:
			return PSMOUSE_GOOD_DATA;
		case 3:
			return ((packet[2] & 0x30) << 2) == (packet[2] & 0xc0) ?
				PSMOUSE_GOOD_DATA : PSMOUSE_BAD_DATA;
		case 4:
			return (packet[3] & 0xf8) == 0xc0 ?
				PSMOUSE_GOOD_DATA : PSMOUSE_BAD_DATA;
		case 5:
			return (packet[4] & 0xc0) == (packet[2] & 0xc0) ?
				PSMOUSE_GOOD_DATA : PSMOUSE_BAD_DATA;
		case 6:
			if (((packet[5] & 0x30) << 2) != (packet[5] & 0xc0))
				return PSMOUSE_BAD_DATA;
			if ((packet[5] & 0xc0) != (packet[1] & 0xc0))
				return PSMOUSE_BAD_DATA;
			break; 
		}
	}
	if (relative_packet) {
		if (!dev2)
			psmouse_warn(psmouse,
				     "got relative packet but no relative device set up\n");
	} else {
		if (lifebook_use_6byte_proto) {
			input_report_abs(dev1, ABS_X,
				((packet[1] & 0x3f) << 6) | (packet[2] & 0x3f));
			input_report_abs(dev1, ABS_Y,
				4096 - (((packet[4] & 0x3f) << 6) | (packet[5] & 0x3f)));
		} else {
			input_report_abs(dev1, ABS_X,
				(packet[1] | ((packet[0] & 0x30) << 4)));
			input_report_abs(dev1, ABS_Y,
				1024 - (packet[2] | ((packet[0] & 0xC0) << 2)));
		}
		input_report_key(dev1, BTN_TOUCH, packet[0] & 0x04);
		input_sync(dev1);
	}
	if (dev2) {
		if (relative_packet)
		psmouse_report_standard_buttons(dev2, packet[0]);
		input_sync(dev2);
	}
	return PSMOUSE_FULL_PACKET;
}
