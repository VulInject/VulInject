static void cmd_anal_abp(RCore *core, const char *input) {
	switch (*input) {
	case 'e': 
		{
		bool showcmds = input[1] == '*';
		int n = 1;
		char *p = strchr (input + 1, ' ');
		if (!p) {
			r_core_cmd_help (core, help_msg_abp);
			return;
		}
		ut64 addr = r_num_math (core->num, p + 1);
		RList *paths = r_core_anal_graph_to (core, addr, n);
		if (paths) {
			RAnalBlock *bb;
			RList *path;
			RListIter *pathi;
			RListIter *bbi;
			if (showcmds) {
				r_cons_printf ("f orip=`dr?PC`\n");
			} else {
				r_core_cmd0 (core, "f orip=`dr?PC`");
			}
			r_list_foreach (paths, pathi, path) {
				r_list_foreach (path, bbi, bb) {
					ut64 endaddr = (addr >= bb->addr && addr < bb->addr + bb->size)
						? addr: bb->addr + bb->size;
					if (showcmds) {
						r_cons_printf ("# 0x%08" PFMT64x "\n", bb->addr);
						r_cons_printf ("aepc 0x%08"PFMT64x"\n", bb->addr);
						r_cons_printf ("aesou 0x%08"PFMT64x"\n", endaddr);
					} else {
						r_core_cmdf (core, "aepc 0x%08"PFMT64x, bb->addr);
						r_core_cmdf (core, "aesou 0x%08"PFMT64x, endaddr);
					}
				}
				free (path);
			}
			r_list_purge (paths);
			if (showcmds) {
				r_cons_printf ("aepc orip\n");
			} else {
				r_core_cmd_call (core, "aepc orip");
			}
			free (paths);
		}
		}
		break;
	case '?':
		r_core_cmd_help (core, help_msg_abp);
		break;
	case 'j': { 
		ut64 addr = r_num_math (core->num, input + 1);
		RAnalBlock *block = r_anal_get_block_at (core->anal, core->offset);
		if (!block) {
			break;
		}
		RList *path = r_anal_block_shortest_path (block, addr);
		PJ *pj = r_core_pj_new (core);
		if (pj) {
			pj_a (pj);
			if (path) {
				RListIter *it;
				r_list_foreach (path, it, block) {
					pj_n (pj, block->addr);
				}
			}
			pj_end (pj);
			r_cons_println (pj_string (pj));
			pj_free (pj);
		}
		r_list_free (path);
		break;
	}
	case ' ': {
		ut64 addr = r_num_math (core->num, input + 1);
		if (addr == UT64_MAX || addr == 0) {
			R_LOG_ERROR ("Invalid or missing address passed as argument");
		} else {
			RAnalBlock *block = r_anal_get_block_at (core->anal, core->offset);
			if (!block) {
				R_LOG_ERROR ("No basic block at 0x%08"PFMT64x, core->offset);
				break;
			}
			RList *path = r_anal_block_shortest_path (block, addr);
			if (path) {
				RListIter *it;
				r_list_foreach (path, it, block) {
					r_cons_printf ("0x%08" PFMT64x "\n", block->addr);
				}
				r_list_free (path);
			}
		}
		break;
	}
	case '\0':
		r_core_cmdf (core, "abl, addr/eq/0x%08"PFMT64x, core->offset);
		break;
	}
}
