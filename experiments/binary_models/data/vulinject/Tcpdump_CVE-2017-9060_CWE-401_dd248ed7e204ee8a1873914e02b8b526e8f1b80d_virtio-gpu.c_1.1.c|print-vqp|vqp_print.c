vqp_print(netdissect_options *ndo, const u_char *pptr, u_int len)
{
    const struct vqp_common_header_t *vqp_common_header;
    const struct vqp_obj_tlv_t *vqp_obj_tlv;
    const u_char *tptr;
    unsigned char version;
    unsigned short vqp_obj_len;
    unsigned int vqp_obj_type;
    u_int tlen;
    unsigned char nitems;
    ndo->ndo_protocol = "vqp";
    tptr=pptr;
    tlen = len;
    vqp_common_header = (const struct vqp_common_header_t *)pptr;
    if (sizeof(struct vqp_common_header_t) > tlen)
        goto invalid;
    version = GET_U_1(vqp_common_header->version);
    if (version != VQP_VERSION) {
	ND_PRINT("VQP version %u packet not supported",
               version);
	return;
    }
    if (ndo->ndo_vflag < 1) {
        ND_PRINT("VQPv%u %s Message, error-code %s (%u), length %u",
               version,
               tok2str(vqp_msg_type_values, "unknown (%u)",GET_U_1(vqp_common_header->msg_type)),
               tok2str(vqp_error_code_values, "unknown", GET_U_1(vqp_common_header->error_code)),
               GET_U_1(vqp_common_header->error_code),
               len);
        return;
    }
    nitems = GET_U_1(vqp_common_header->nitems);
    ND_PRINT("\n\tVQPv%u, %s Message, error-code %s (%u), seq 0x%08x, items %u, length %u",
           version,
	   tok2str(vqp_msg_type_values, "unknown (%u)",GET_U_1(vqp_common_header->msg_type)),
	   tok2str(vqp_error_code_values, "unknown", GET_U_1(vqp_common_header->error_code)),
	   GET_U_1(vqp_common_header->error_code),
	   GET_BE_U_4(vqp_common_header->sequence),
	   nitems,
           len);
    tptr+=sizeof(struct vqp_common_header_t);
    tlen-=sizeof(struct vqp_common_header_t);
    while (nitems != 0 && tlen != 0) {
        vqp_obj_tlv = (const struct vqp_obj_tlv_t *)tptr;
        ND_TCHECK_SIZE(vqp_obj_tlv);
        if (sizeof(struct vqp_obj_tlv_t) > tlen)
            goto invalid;
        vqp_obj_type = GET_BE_U_4(vqp_obj_tlv->obj_type);
        vqp_obj_len = GET_BE_U_2(vqp_obj_tlv->obj_length);
        tptr+=sizeof(struct vqp_obj_tlv_t);
        tlen-=sizeof(struct vqp_obj_tlv_t);
        ND_PRINT("\n\t  %s Object (0x%08x), length %u, value: ",
               tok2str(vqp_obj_values, "Unknown", vqp_obj_type),
               vqp_obj_type, vqp_obj_len);
        if (vqp_obj_type == 0 || vqp_obj_len ==0) {
            return;
        }
        ND_TCHECK_LEN(tptr, vqp_obj_len);
        if (vqp_obj_len > tlen)
            goto invalid;
        switch(vqp_obj_type) {
	case VQP_OBJ_IP_ADDRESS:
            if (vqp_obj_len != 4)
                goto invalid;
            ND_PRINT("%s (0x%08x)", GET_IPADDR_STRING(tptr),
                     GET_BE_U_4(tptr));
            break;
        case VQP_OBJ_PORT_NAME:
	case VQP_OBJ_VLAN_NAME:
	case VQP_OBJ_VTP_DOMAIN:
	case VQP_OBJ_ETHERNET_PKT:
            nd_printjnp(ndo, tptr, vqp_obj_len);
            break;
	case VQP_OBJ_MAC_ADDRESS:
	case VQP_OBJ_MAC_NULL:
            if (vqp_obj_len != MAC48_LEN)
                goto invalid;
	      ND_PRINT("%s", GET_MAC48_STRING(tptr));
              break;
        default:
            if (ndo->ndo_vflag <= 1)
                print_unknown_data(ndo,tptr, "\n\t    ", vqp_obj_len);
            break;
        }
	tptr += vqp_obj_len;
	tlen -= vqp_obj_len;
	nitems--;
    }
    return;
invalid:
    nd_print_invalid(ndo);
}
