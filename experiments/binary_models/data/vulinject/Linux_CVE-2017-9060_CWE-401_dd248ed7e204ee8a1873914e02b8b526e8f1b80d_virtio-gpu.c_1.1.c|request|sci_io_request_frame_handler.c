sci_io_request_frame_handler(struct isci_request *ireq,
				  unsigned int frame_index)
{
	struct isci_host *ihost = ireq->owning_controller;
	struct isci_stp_request *stp_req = &ireq->stp.req;
	enum sci_base_request_states state;
	enum sci_status status;
	ssize_t word_cnt;
	state = ireq->sm.current_state_id;
	switch (state)  {
	case SCI_REQ_STARTED: {
		struct ssp_frame_hdr ssp_hdr;
		void *frame_header;
		sci_unsolicited_frame_control_get_header(&ihost->uf_control,
							      frame_index,
							      &frame_header);
		word_cnt = sizeof(struct ssp_frame_hdr) / sizeof(unsigned int);
		sci_swab32_cpy(&ssp_hdr, frame_header, word_cnt);
		if (ssp_hdr.frame_type == SSP_RESPONSE) {
			struct ssp_response_iu *resp_iu;
			ssize_t word_cnt = SSP_RESP_IU_MAX_SIZE / sizeof(unsigned int);
			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
								      frame_index,
								      (void **)&resp_iu);
			sci_swab32_cpy(&ireq->ssp.rsp, resp_iu, word_cnt);
			resp_iu = &ireq->ssp.rsp;
			if (resp_iu->datapres == SAS_DATAPRES_RESPONSE_DATA ||
			    resp_iu->datapres == SAS_DATAPRES_SENSE_DATA) {
				ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
				ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
			} else {
				ireq->scu_status = SCU_TASK_DONE_GOOD;
				ireq->sci_status = SCI_SUCCESS;
			}
		} else {
			dev_err(&ihost->pdev->dev,
				"%s: SCIC IO Request 0x%p received unexpected "
				"frame %d type 0x%02x\n", __func__, ireq,
				frame_index, ssp_hdr.frame_type);
		}
		sci_controller_release_frame(ihost, frame_index);
		return SCI_SUCCESS;
	}
	case SCI_REQ_TASK_WAIT_TC_RESP:
		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
		sci_controller_release_frame(ihost, frame_index);
		return SCI_SUCCESS;
	case SCI_REQ_SMP_WAIT_RESP: {
		struct sas_task *task = isci_request_access_task(ireq);
		struct scatterlist *sg = &task->smp_task.smp_resp;
		void *frame_header, *kaddr;
		unsigned char *rsp;
		sci_unsolicited_frame_control_get_header(&ihost->uf_control,
							 frame_index,
							 &frame_header);
		kaddr = kmap_atomic(sg_page(sg));
		rsp = kaddr + sg->offset;
		sci_swab32_cpy(rsp, frame_header, 1);
		if (rsp[0] == SMP_RESPONSE) {
			void *smp_resp;
			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
								 frame_index,
								 &smp_resp);
			word_cnt = (sg->length/4)-1;
			if (word_cnt > 0)
				word_cnt = min_t(unsigned int, word_cnt,
						 SCU_UNSOLICITED_FRAME_BUFFER_SIZE/4);
			sci_swab32_cpy(rsp + 4, smp_resp, word_cnt);
			ireq->scu_status = SCU_TASK_DONE_GOOD;
			ireq->sci_status = SCI_SUCCESS;
			sci_change_state(&ireq->sm, SCI_REQ_SMP_WAIT_TC_COMP);
		} else {
			dev_err(&ihost->pdev->dev,
				"%s: SCIC SMP Request 0x%p received unexpected "
				"frame %d type 0x%02x\n",
				__func__,
				ireq,
				frame_index,
				rsp[0]);
			ireq->scu_status = SCU_TASK_DONE_SMP_FRM_TYPE_ERR;
			ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
			sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
		}
		kunmap_atomic(kaddr);
		sci_controller_release_frame(ihost, frame_index);
		return SCI_SUCCESS;
	}
	case SCI_REQ_STP_UDMA_WAIT_TC_COMP:
		return sci_stp_request_udma_general_frame_handler(ireq,
								       frame_index);
	case SCI_REQ_STP_UDMA_WAIT_D2H:
		status = sci_stp_request_udma_general_frame_handler(ireq, frame_index);
		if (status != SCI_SUCCESS)
			return status;
		ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
		ireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;
		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
		return SCI_SUCCESS;
	case SCI_REQ_STP_NON_DATA_WAIT_D2H: {
		struct dev_to_host_fis *frame_header;
		unsigned int *frame_buffer;
		status = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
								       frame_index,
								       (void **)&frame_header);
		if (status != SCI_SUCCESS) {
			dev_err(&ihost->pdev->dev,
				"%s: SCIC IO Request 0x%p could not get frame "
				"header for frame index %d, status %x\n",
				__func__,
				stp_req,
				frame_index,
				status);
			return status;
		}
		switch (frame_header->fis_type) {
		case FIS_REGD2H:
			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
								      frame_index,
								      (void **)&frame_buffer);
			sci_controller_copy_sata_response(&ireq->stp.rsp,
							       frame_header,
							       frame_buffer);
			ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
			ireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;
			break;
		default:
			dev_warn(&ihost->pdev->dev,
				 "%s: IO Request:0x%p Frame Id:%d protocol "
				  "violation occurred\n", __func__, stp_req,
				  frame_index);
			ireq->scu_status = SCU_TASK_DONE_UNEXP_FIS;
			ireq->sci_status = SCI_FAILURE_PROTOCOL_VIOLATION;
			break;
		}
		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
		sci_controller_release_frame(ihost, frame_index);
		return status;
	}
	case SCI_REQ_STP_PIO_WAIT_FRAME: {
		struct sas_task *task = isci_request_access_task(ireq);
		struct dev_to_host_fis *frame_header;
		unsigned int *frame_buffer;
		status = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
								       frame_index,
								       (void **)&frame_header);
		if (status != SCI_SUCCESS) {
			dev_err(&ihost->pdev->dev,
				"%s: SCIC IO Request 0x%p could not get frame "
				"header for frame index %d, status %x\n",
				__func__, stp_req, frame_index, status);
			return status;
		}
		switch (frame_header->fis_type) {
		case FIS_PIO_SETUP:
			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
								      frame_index,
								      (void **)&frame_buffer);
			stp_req->pio_len = frame_buffer[3] & 0xffff;
			stp_req->status = (frame_buffer[2] >> 24) & 0xff;
			sci_controller_copy_sata_response(&ireq->stp.rsp,
							       frame_header,
							       frame_buffer);
			ireq->stp.rsp.status = stp_req->status;
			if (task->data_dir == DMA_FROM_DEVICE) {
				sci_change_state(&ireq->sm, SCI_REQ_STP_PIO_DATA_IN);
			} else if (task->data_dir == DMA_TO_DEVICE) {
				status = sci_stp_request_pio_data_out_transmit_data(ireq);
				if (status != SCI_SUCCESS)
					break;
				sci_change_state(&ireq->sm, SCI_REQ_STP_PIO_DATA_OUT);
			}
			break;
		case FIS_SETDEVBITS:
			sci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);
			break;
		case FIS_REGD2H:
			if (frame_header->status & ATA_BUSY) {
				dev_dbg(&ihost->pdev->dev,
					"%s: SCIC PIO Request 0x%p received "
					"D2H Register FIS with BSY status "
					"0x%x\n",
					__func__,
					stp_req,
					frame_header->status);
				break;
			}
			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
								      frame_index,
								      (void **)&frame_buffer);
			sci_controller_copy_sata_response(&ireq->stp.rsp,
							       frame_header,
							       frame_buffer);
			ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
			ireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;
			sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
			break;
		default:
			break;
		}
		sci_controller_release_frame(ihost, frame_index);
		return status;
	}
	case SCI_REQ_STP_PIO_DATA_IN: {
		struct dev_to_host_fis *frame_header;
		struct sata_fis_data *frame_buffer;
		status = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
								       frame_index,
								       (void **)&frame_header);
		if (status != SCI_SUCCESS) {
			dev_err(&ihost->pdev->dev,
				"%s: SCIC IO Request 0x%p could not get frame "
				"header for frame index %d, status %x\n",
				__func__,
				stp_req,
				frame_index,
				status);
			return status;
		}
		if (frame_header->fis_type != FIS_DATA) {
			dev_err(&ihost->pdev->dev,
				"%s: SCIC PIO Request 0x%p received frame %d "
				"with fis type 0x%02x when expecting a data "
				"fis.\n",
				__func__,
				stp_req,
				frame_index,
				frame_header->fis_type);
			ireq->scu_status = SCU_TASK_DONE_GOOD;
			ireq->sci_status = SCI_FAILURE_IO_REQUIRES_SCSI_ABORT;
			sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
			sci_controller_release_frame(ihost, frame_index);
			return status;
		}
		if (stp_req->sgl.index < 0) {
			ireq->saved_rx_frame_index = frame_index;
			stp_req->pio_len = 0;
		} else {
			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
								      frame_index,
								      (void **)&frame_buffer);
			status = sci_stp_request_pio_data_in_copy_data(stp_req,
									    (unsigned char *)frame_buffer);
			sci_controller_release_frame(ihost, frame_index);
		}
		if (status != SCI_SUCCESS || stp_req->pio_len != 0)
			return status;
		if ((stp_req->status & ATA_BUSY) == 0) {
			ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
			ireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;
			sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
		} else {
			sci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);
		}
		return status;
	}
	case SCI_REQ_ATAPI_WAIT_PIO_SETUP: {
		struct sas_task *task = isci_request_access_task(ireq);
		sci_controller_release_frame(ihost, frame_index);
		ireq->target_device->working_request = ireq;
		if (task->data_dir == DMA_NONE) {
			sci_change_state(&ireq->sm, SCI_REQ_ATAPI_WAIT_TC_COMP);
			scu_atapi_reconstruct_raw_frame_task_context(ireq);
		} else {
			sci_change_state(&ireq->sm, SCI_REQ_ATAPI_WAIT_D2H);
			scu_atapi_construct_task_context(ireq);
		}
		sci_controller_continue_io(ireq);
		return SCI_SUCCESS;
	}
	case SCI_REQ_ATAPI_WAIT_D2H:
		return atapi_d2h_reg_frame_handler(ireq, frame_index);
	case SCI_REQ_ABORTING:
		sci_controller_release_frame(ihost, frame_index);
		return SCI_SUCCESS;
	default:
		dev_warn(&ihost->pdev->dev,
			 "%s: SCIC IO Request given unexpected frame %x while "
			 "in state %d\n",
			 __func__,
			 frame_index,
			 state);
		sci_controller_release_frame(ihost, frame_index);
		return SCI_FAILURE_INVALID_STATE;
	}
}
