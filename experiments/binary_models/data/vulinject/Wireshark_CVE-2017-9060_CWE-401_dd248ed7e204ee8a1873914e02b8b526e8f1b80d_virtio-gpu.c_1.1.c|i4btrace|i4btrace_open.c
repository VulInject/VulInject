wtap_open_return_val i4btrace_open(wtap *wth, int *err, char **err_info)
{
	i4b_trace_hdr_t hdr;
	bool byte_swapped = false;
	i4btrace_t *i4btrace;
	if (!wtap_read_bytes(wth->fh, &hdr, sizeof(hdr), err, err_info)) {
		if (*err != WTAP_ERR_SHORT_READ)
			return WTAP_OPEN_ERROR;
		return WTAP_OPEN_NOT_MINE;
	}
	if (!I4B_HDR_IS_OK(hdr)) {
		if (!I4B_HDR_IS_OK(hdr)) {
			return WTAP_OPEN_NOT_MINE;
		}
		byte_swapped = true;
	}
	if (!wtap_read_bytes(wth->fh, NULL, hdr.length - (unsigned int)sizeof(hdr),
	    err, err_info)) {
		if (*err != WTAP_ERR_SHORT_READ)
			return WTAP_OPEN_ERROR;
	} else {
		for (int i = 1; i < PACKETS_TO_CHECK; i++) {
			if (!wtap_read_bytes_or_eof(wth->fh, &hdr, sizeof(hdr), err,
			    err_info)) {
				if (*err == 0) {
					break;
				}
				if (*err != WTAP_ERR_SHORT_READ)
					return WTAP_OPEN_ERROR;
				return WTAP_OPEN_NOT_MINE;
			}
			if (byte_swapped)
				I4B_BYTESWAP_HEADER(hdr);
			if (!I4B_HDR_IS_OK(hdr)) {
				return WTAP_OPEN_NOT_MINE;
			}
			if (!wtap_read_bytes(wth->fh, NULL,
			    hdr.length - (unsigned int)sizeof(hdr), err, err_info)) {
				if (*err != WTAP_ERR_SHORT_READ)
					return WTAP_OPEN_ERROR;
				break;
			}
		}
	}
	if (file_seek(wth->fh, 0, SEEK_SET, err) == -1)
		return WTAP_OPEN_ERROR;
	wth->file_type_subtype = i4btrace_file_type_subtype;
	i4btrace = g_new(i4btrace_t, 1);
	wth->priv = (void *)i4btrace;
	wth->subtype_read = i4btrace_read;
	wth->subtype_seek_read = i4btrace_seek_read;
	wth->snapshot_length = 0;	
	i4btrace->byte_swapped = byte_swapped;
	wth->file_encap = WTAP_ENCAP_ISDN;
	wth->file_tsprec = WTAP_TSPREC_USEC;
	wtap_add_generated_idb(wth);
	return WTAP_OPEN_MINE;
}
