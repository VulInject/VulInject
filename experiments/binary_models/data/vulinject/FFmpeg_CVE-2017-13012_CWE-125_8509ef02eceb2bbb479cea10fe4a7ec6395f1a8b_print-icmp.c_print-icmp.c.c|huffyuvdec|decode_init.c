static av_cold int decode_init(AVCodecContext *avctx)
{
    HYuvDecContext *s = avctx->priv_data;
    int ret;
    ret = av_image_check_size(avctx->width, avctx->height, 0, avctx);
    if (ret < 0)
        return ret;
    s->flags = avctx->flags;
    ff_huffyuvdsp_init(&s->hdsp, avctx->pix_fmt);
    ff_llviddsp_init(&s->llviddsp);
    memset(s->vlc, 0, 4 * sizeof(VLC));
    s->interlaced = avctx->height > 288;
    s->bgr32      = 1;
    if (avctx->extradata_size) {
        if ((avctx->bits_per_coded_sample & 7) &&
            avctx->bits_per_coded_sample != 12)
            s->version = 1; // do such files exist at all?
        else if (avctx->extradata_size > 3 && avctx->extradata[3] == 0)
            s->version = 2;
        else
            s->version = 3;
    } else
        s->version = 0;
    s->bps = 8;
    s->n = 1<<s->bps;
    s->vlc_n = FFMIN(s->n, MAX_VLC_N);
    s->chroma = 1;
    if (s->version >= 2) {
        int method, interlace;
        if (avctx->extradata_size < 4)
            return AVERROR_INVALIDDATA;
        method           = avctx->extradata[0];
        s->decorrelate   = method & 64 ? 1 : 0;
        s->predictor     = method & 63;
        if (s->version == 2) {
            s->bitstream_bpp = avctx->extradata[1];
            if (s->bitstream_bpp == 0)
                s->bitstream_bpp = avctx->bits_per_coded_sample & ~7;
        } else {
            s->bps = (avctx->extradata[1] >> 4) + 1;
            s->n = 1<<s->bps;
            s->vlc_n = FFMIN(s->n, MAX_VLC_N);
            s->chroma_h_shift = avctx->extradata[1] & 3;
            s->chroma_v_shift = (avctx->extradata[1] >> 2) & 3;
            s->yuv   = !!(avctx->extradata[2] & 1);
            s->chroma= !!(avctx->extradata[2] & 3);
            s->alpha = !!(avctx->extradata[2] & 4);
        }
        interlace     = (avctx->extradata[2] & 0x30) >> 4;
        s->interlaced = (interlace == 1) ? 1 : (interlace == 2) ? 0 : s->interlaced;
        s->context    = avctx->extradata[2] & 0x40 ? 1 : 0;
        if ((ret = read_huffman_tables(s, avctx->extradata + 4,
                                       avctx->extradata_size - 4)) < 0)
            return ret;
    } else {
        switch (avctx->bits_per_coded_sample & 7) {
        case 1:
            s->predictor   = LEFT;
            s->decorrelate = 0;
            break;
        case 2:
            s->predictor   = LEFT;
            s->decorrelate = 1;
            break;
        case 3:
            s->predictor   = PLANE;
            s->decorrelate = avctx->bits_per_coded_sample >= 24;
            break;
        case 4:
            s->predictor   = MEDIAN;
            s->decorrelate = 0;
            break;
        default:
            s->predictor   = LEFT; // OLD
            s->decorrelate = 0;
            break;
        }
        s->bitstream_bpp = avctx->bits_per_coded_sample & ~7;
        s->context       = 0;
        if ((ret = read_old_huffman_tables(s)) < 0)
            return ret;
    }
    if (s->version <= 2) {
        switch (s->bitstream_bpp) {
        case 12:
            avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            s->yuv = 1;
            break;
        case 16:
            if (s->yuy2)
                avctx->pix_fmt = AV_PIX_FMT_YUYV422;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
            s->yuv = 1;
            break;
        case 24:
            if (s->bgr32)
                avctx->pix_fmt = AV_PIX_FMT_0RGB32;
            else
                avctx->pix_fmt = AV_PIX_FMT_BGR24;
            break;
        case 32:
            av_assert0(s->bgr32);
            avctx->pix_fmt = AV_PIX_FMT_RGB32;
            s->alpha = 1;
            break;
        default:
            return AVERROR_INVALIDDATA;
        }
        av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt,
                                         &s->chroma_h_shift,
                                         &s->chroma_v_shift);
    } else {
        switch ( (s->chroma<<10) | (s->yuv<<9) | (s->alpha<<8) | ((s->bps-1)<<4) | s->chroma_h_shift | (s->chroma_v_shift<<2)) {
        case 0x070:
            avctx->pix_fmt = AV_PIX_FMT_GRAY8;
            break;
        case 0x0F0:
            avctx->pix_fmt = AV_PIX_FMT_GRAY16;
            break;
        case 0x470:
            avctx->pix_fmt = AV_PIX_FMT_GBRP;
            break;
        case 0x480:
            avctx->pix_fmt = AV_PIX_FMT_GBRP9;
            break;
        case 0x490:
            avctx->pix_fmt = AV_PIX_FMT_GBRP10;
            break;
        case 0x4B0:
            avctx->pix_fmt = AV_PIX_FMT_GBRP12;
            break;
        case 0x4D0:
            avctx->pix_fmt = AV_PIX_FMT_GBRP14;
            break;
        case 0x4F0:
            avctx->pix_fmt = AV_PIX_FMT_GBRP16;
            break;
        case 0x570:
            avctx->pix_fmt = AV_PIX_FMT_GBRAP;
            break;
        case 0x670:
            avctx->pix_fmt = AV_PIX_FMT_YUV444P;
            break;
        case 0x680:
            avctx->pix_fmt = AV_PIX_FMT_YUV444P9;
            break;
        case 0x690:
            avctx->pix_fmt = AV_PIX_FMT_YUV444P10;
            break;
        case 0x6B0:
            avctx->pix_fmt = AV_PIX_FMT_YUV444P12;
            break;
        case 0x6D0:
            avctx->pix_fmt = AV_PIX_FMT_YUV444P14;
            break;
        case 0x6F0:
            avctx->pix_fmt = AV_PIX_FMT_YUV444P16;
            break;
        case 0x671:
            avctx->pix_fmt = AV_PIX_FMT_YUV422P;
            break;
        case 0x681:
            avctx->pix_fmt = AV_PIX_FMT_YUV422P9;
            break;
        case 0x691:
            avctx->pix_fmt = AV_PIX_FMT_YUV422P10;
            break;
        case 0x6B1:
            avctx->pix_fmt = AV_PIX_FMT_YUV422P12;
            break;
        case 0x6D1:
            avctx->pix_fmt = AV_PIX_FMT_YUV422P14;
            break;
        case 0x6F1:
            avctx->pix_fmt = AV_PIX_FMT_YUV422P16;
            break;
        case 0x672:
            avctx->pix_fmt = AV_PIX_FMT_YUV411P;
            break;
        case 0x674:
            avctx->pix_fmt = AV_PIX_FMT_YUV440P;
            break;
        case 0x675:
            avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            break;
        case 0x685:
            avctx->pix_fmt = AV_PIX_FMT_YUV420P9;
            break;
        case 0x695:
            avctx->pix_fmt = AV_PIX_FMT_YUV420P10;
            break;
        case 0x6B5:
            avctx->pix_fmt = AV_PIX_FMT_YUV420P12;
            break;
        case 0x6D5:
            avctx->pix_fmt = AV_PIX_FMT_YUV420P14;
            break;
        case 0x6F5:
            avctx->pix_fmt = AV_PIX_FMT_YUV420P16;
            break;
        case 0x67A:
            avctx->pix_fmt = AV_PIX_FMT_YUV410P;
            break;
        case 0x770:
            avctx->pix_fmt = AV_PIX_FMT_YUVA444P;
            break;
        case 0x780:
            avctx->pix_fmt = AV_PIX_FMT_YUVA444P9;
            break;
        case 0x790:
            avctx->pix_fmt = AV_PIX_FMT_YUVA444P10;
            break;
        case 0x7F0:
            avctx->pix_fmt = AV_PIX_FMT_YUVA444P16;
            break;
        case 0x771:
            avctx->pix_fmt = AV_PIX_FMT_YUVA422P;
            break;
        case 0x781:
            avctx->pix_fmt = AV_PIX_FMT_YUVA422P9;
            break;
        case 0x791:
            avctx->pix_fmt = AV_PIX_FMT_YUVA422P10;
            break;
        case 0x7F1:
            avctx->pix_fmt = AV_PIX_FMT_YUVA422P16;
            break;
        case 0x775:
            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
            break;
        case 0x785:
            avctx->pix_fmt = AV_PIX_FMT_YUVA420P9;
            break;
        case 0x795:
            avctx->pix_fmt = AV_PIX_FMT_YUVA420P10;
            break;
        case 0x7F5:
            avctx->pix_fmt = AV_PIX_FMT_YUVA420P16;
            break;
        default:
            return AVERROR_INVALIDDATA;
        }
    }
    if ((avctx->pix_fmt == AV_PIX_FMT_YUV422P || avctx->pix_fmt == AV_PIX_FMT_YUV420P) && avctx->width & 1) {
        av_log(avctx, AV_LOG_ERROR, "width must be even for this colorspace\n");
        return AVERROR_INVALIDDATA;
    }
    if (s->predictor == MEDIAN && avctx->pix_fmt == AV_PIX_FMT_YUV422P &&
        avctx->width % 4) {
        av_log(avctx, AV_LOG_ERROR, "width must be a multiple of 4 "
               "for this combination of colorspace and predictor type.\n");
        return AVERROR_INVALIDDATA;
    }
    if ((ret = ff_huffyuv_alloc_temp(s->temp, s->temp16, avctx->width)) < 0)
        return ret;
    return 0;
}
