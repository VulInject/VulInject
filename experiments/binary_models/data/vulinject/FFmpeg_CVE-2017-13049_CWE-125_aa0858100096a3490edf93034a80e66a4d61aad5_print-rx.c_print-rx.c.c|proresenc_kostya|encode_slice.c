static int encode_slice(AVCodecContext *avctx, const AVFrame *pic,
                        PutBitContext *pb,
                        int sizes[4], int x, int y, int quant,
                        int mbs_per_slice)
{
    ProresContext *ctx = avctx->priv_data;
    int i, xp, yp;
    int total_size = 0;
    const uint16_t *src;
    int num_cblocks, pwidth, line_add;
    ptrdiff_t linesize;
    int is_chroma;
    uint16_t *qmat;
    uint16_t *qmat_chroma;
    if (ctx->pictures_per_frame == 1)
        line_add = 0;
    else
        line_add = ctx->cur_picture_idx ^ !(pic->flags & AV_FRAME_FLAG_TOP_FIELD_FIRST);
    if (ctx->force_quant) {
        qmat = ctx->quants[0];
        qmat_chroma = ctx->quants_chroma[0];
    } else if (quant < MAX_STORED_Q) {
        qmat = ctx->quants[quant];
        qmat_chroma = ctx->quants_chroma[quant];
    } else {
        qmat = ctx->custom_q;
        qmat_chroma = ctx->custom_chroma_q;
        for (i = 0; i < 64; i++) {
            qmat[i] = ctx->quant_mat[i] * quant;
            qmat_chroma[i] = ctx->quant_chroma_mat[i] * quant;
        }
    }
    for (i = 0; i < ctx->num_planes; i++) {
        is_chroma    = (i == 1 || i == 2);
        if (!is_chroma || ctx->chroma_factor == CFACTOR_Y444) {
            xp          = x << 4;
            yp          = y << 4;
            num_cblocks = 4;
            pwidth      = avctx->width;
        } else {
            xp          = x << 3;
            yp          = y << 4;
            num_cblocks = 2;
            pwidth      = avctx->width >> 1;
        }
        linesize = pic->linesize[i] * ctx->pictures_per_frame;
        src = (const uint16_t*)(pic->data[i] + yp * linesize +
                                line_add * pic->linesize[i]) + xp;
        if (i < 3) {
            get_slice_data(ctx, src, linesize, xp, yp,
                           pwidth, avctx->height / ctx->pictures_per_frame,
                           ctx->blocks[0], ctx->emu_buf,
                           mbs_per_slice, num_cblocks, is_chroma);
            if (!is_chroma) {/* luma quant */
                encode_slice_plane(ctx, pb, src, linesize,
                                   mbs_per_slice, ctx->blocks[0],
                                   num_cblocks, qmat);
            } else { /* chroma plane */
                encode_slice_plane(ctx, pb, src, linesize,
                                   mbs_per_slice, ctx->blocks[0],
                                   num_cblocks, qmat_chroma);
            }
        } else {
            get_alpha_data(ctx, src, linesize, xp, yp,
                           pwidth, avctx->height / ctx->pictures_per_frame,
                           ctx->blocks[0], mbs_per_slice, ctx->alpha_bits);
            encode_alpha_plane(ctx, pb, mbs_per_slice, ctx->blocks[0], quant);
        }
        sizes[i]   = put_bytes_output(pb) - total_size;
        total_size = put_bytes_output(pb);
    }
    return total_size;
}
