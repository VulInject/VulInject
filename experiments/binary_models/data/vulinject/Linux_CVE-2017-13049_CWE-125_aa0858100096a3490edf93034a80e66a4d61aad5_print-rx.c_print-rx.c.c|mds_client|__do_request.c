static void __do_request(struct ceph_mds_client *mdsc,
			struct ceph_mds_request *req)
{
	struct ceph_client *cl = mdsc->fsc->client;
	struct ceph_mds_session *session = NULL;
	int mds = -1;
	int err = 0;
	bool random;
	if (req->r_err || test_bit(CEPH_MDS_R_GOT_RESULT, &req->r_req_flags)) {
		if (test_bit(CEPH_MDS_R_ABORTED, &req->r_req_flags))
			__unregister_request(mdsc, req);
		return;
	}
	if (READ_ONCE(mdsc->fsc->mount_state) == CEPH_MOUNT_FENCE_IO) {
		doutc(cl, "metadata corrupted\n");
		err = -EIO;
		goto finish;
	}
	if (req->r_timeout &&
	    time_after_eq(jiffies, req->r_started + req->r_timeout)) {
		doutc(cl, "timed out\n");
		err = -ETIMEDOUT;
		goto finish;
	}
	if (READ_ONCE(mdsc->fsc->mount_state) == CEPH_MOUNT_SHUTDOWN) {
		doutc(cl, "forced umount\n");
		err = -EIO;
		goto finish;
	}
	if (READ_ONCE(mdsc->fsc->mount_state) == CEPH_MOUNT_MOUNTING) {
		if (mdsc->mdsmap_err) {
			err = mdsc->mdsmap_err;
			doutc(cl, "mdsmap err %d\n", err);
			goto finish;
		}
		if (mdsc->mdsmap->m_epoch == 0) {
			doutc(cl, "no mdsmap, waiting for map\n");
			list_add(&req->r_wait, &mdsc->waiting_for_map);
			return;
		}
		if (!(mdsc->fsc->mount_options->flags &
		      CEPH_MOUNT_OPT_MOUNTWAIT) &&
		    !ceph_mdsmap_is_cluster_available(mdsc->mdsmap)) {
			err = -EHOSTUNREACH;
			goto finish;
		}
	}
	mds = __choose_mds(mdsc, req, &random);
	if (mds < 0 ||
	    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {
		if (test_bit(CEPH_MDS_R_ASYNC, &req->r_req_flags)) {
			err = -EJUKEBOX;
			goto finish;
		}
		doutc(cl, "no mds or not active, waiting for map\n");
		list_add(&req->r_wait, &mdsc->waiting_for_map);
		return;
	}
	session = __ceph_lookup_mds_session(mdsc, mds);
	if (!session) {
		session = register_session(mdsc, mds);
		if (IS_ERR(session)) {
			err = PTR_ERR(session);
			goto finish;
		}
	}
	req->r_session = ceph_get_mds_session(session);
	doutc(cl, "mds%d session %p state %s\n", mds, session,
	      ceph_session_state_name(session->s_state));
	if (req->r_feature_needed > 0 &&
	    !test_bit(req->r_feature_needed, &session->s_features)) {
		err = -EOPNOTSUPP;
		goto out_session;
	}
	if (session->s_state != CEPH_MDS_SESSION_OPEN &&
	    session->s_state != CEPH_MDS_SESSION_HUNG) {
		if (test_bit(CEPH_MDS_R_ASYNC, &req->r_req_flags)) {
			err = -EJUKEBOX;
			goto out_session;
		}
		if (session->s_state == CEPH_MDS_SESSION_REJECTED) {
			if (ceph_test_mount_opt(mdsc->fsc, CLEANRECOVER))
				list_add(&req->r_wait, &mdsc->waiting_for_map);
			else
				err = -EACCES;
			goto out_session;
		}
		if (session->s_state == CEPH_MDS_SESSION_NEW ||
		    session->s_state == CEPH_MDS_SESSION_CLOSING) {
			err = __open_session(mdsc, session);
			if (err)
				goto out_session;
			if (random)
				req->r_resend_mds = mds;
		}
		list_add(&req->r_wait, &session->s_waiting);
		goto out_session;
	}
	req->r_resend_mds = -1;   
	if (req->r_request_started == 0)   
		req->r_request_started = jiffies;
	if (test_bit(CEPH_MDS_R_ASYNC, &req->r_req_flags) && req->r_num_fwd) {
		struct ceph_dentry_info *di = ceph_dentry(req->r_dentry);
		struct ceph_inode_info *ci;
		struct ceph_cap *cap;
		if (!d_inode(req->r_dentry)) {
			err = wait_on_bit(&di->flags, CEPH_DENTRY_ASYNC_CREATE_BIT,
					  TASK_KILLABLE);
			if (err) {
				mutex_lock(&req->r_fill_mutex);
				set_bit(CEPH_MDS_R_ABORTED, &req->r_req_flags);
				mutex_unlock(&req->r_fill_mutex);
				goto out_session;
			}
		}
		ci = ceph_inode(d_inode(req->r_dentry));
		spin_lock(&ci->i_ceph_lock);
		cap = ci->i_auth_cap;
		if (ci->i_ceph_flags & CEPH_I_ASYNC_CREATE && mds != cap->mds) {
			doutc(cl, "session changed for auth cap %d -> %d\n",
			      cap->session->s_mds, session->s_mds);
			spin_lock(&cap->session->s_cap_lock);
			cap->session->s_nr_caps--;
			list_del_init(&cap->session_caps);
			spin_unlock(&cap->session->s_cap_lock);
			cap->mds = mds;
			cap->session = session;
			spin_lock(&session->s_cap_lock);
			session->s_nr_caps++;
			list_add_tail(&cap->session_caps, &session->s_caps);
			spin_unlock(&session->s_cap_lock);
			change_auth_cap_ses(ci, session);
		}
		spin_unlock(&ci->i_ceph_lock);
	}
	err = __send_request(session, req, false);
out_session:
	ceph_put_mds_session(session);
finish:
	if (err) {
		doutc(cl, "early error %d\n", err);
		req->r_err = err;
		complete_request(mdsc, req);
		__unregister_request(mdsc, req);
	}
	return;
}
