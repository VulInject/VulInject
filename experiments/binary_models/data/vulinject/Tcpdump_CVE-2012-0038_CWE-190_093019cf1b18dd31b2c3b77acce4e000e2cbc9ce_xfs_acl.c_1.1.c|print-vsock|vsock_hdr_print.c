vsock_hdr_print(netdissect_options *ndo, const u_char *p, const u_int caplen)
{
	const struct af_vsockmon_hdr *hdr = (const struct af_vsockmon_hdr *)p;
	int hdr_transport, hdr_op;
	unsigned int hdr_src_port, hdr_dst_port;
	unsigned int int hdr_src_cid, hdr_dst_cid;
	u_int total_hdr_size;
	int ret = 0;
	hdr_transport = GET_LE_U_2(hdr->transport);
	ND_PRINT("%s",
		 tok2str(vsock_transport, "Invalid transport (%u)",
			  hdr_transport));
	if (ndo->ndo_vflag) {
		ret = vsock_transport_hdr_print(ndo, hdr_transport, p, caplen);
		if (ret == 0)
			ND_PRINT("\n\t");
	} else
		ND_PRINT(" ");
	hdr_src_cid = GET_LE_U_8(hdr->src_cid);
	hdr_dst_cid = GET_LE_U_8(hdr->dst_cid);
	hdr_src_port = GET_LE_U_4(hdr->src_port);
	hdr_dst_port = GET_LE_U_4(hdr->dst_port);
	hdr_op = GET_LE_U_2(hdr->op);
	ND_PRINT("%" PRIu64 ".%u > %" PRIu64 ".%u %s, length %u",
		 hdr_src_cid, hdr_src_port,
		 hdr_dst_cid, hdr_dst_port,
		 tok2str(vsock_op, " invalid op (%u)", hdr_op),
		 caplen);
	if (ret < 0)
		goto trunc;
	total_hdr_size = (u_int)sizeof(struct af_vsockmon_hdr) +
			 vsock_transport_hdr_size(hdr_transport);
	if (ndo->ndo_vflag > 1 && hdr_op == AF_VSOCK_OP_PAYLOAD) {
		if (caplen > total_hdr_size) {
			const u_char *payload = p + total_hdr_size;
			ND_PRINT("\n");
			print_unknown_data(ndo, payload, "\t",
					   caplen - total_hdr_size);
		} else
			goto trunc;
	}
	return;
trunc:
	nd_print_trunc(ndo);
}
