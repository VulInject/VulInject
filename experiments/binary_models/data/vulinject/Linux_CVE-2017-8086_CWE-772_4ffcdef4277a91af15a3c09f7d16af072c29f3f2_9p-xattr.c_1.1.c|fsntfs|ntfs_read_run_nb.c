int ntfs_read_run_nb(struct ntfs_sb_info *sbi, const struct runs_tree *run,
		     unsigned int int vbo, void *buf, unsigned int bytes, struct ntfs_buffers *nb)
{
	int err;
	struct super_block *sb = sbi->sb;
	unsigned int blocksize = sb->s_blocksize;
	unsigned char cluster_bits = sbi->cluster_bits;
	unsigned int off = vbo & sbi->cluster_mask;
	unsigned int nbh = 0;
	CLST vcn_next, vcn = vbo >> cluster_bits;
	CLST lcn, clen;
	unsigned int int lbo, len;
	size_t idx;
	struct buffer_head *bh;
	if (!run) {
		if (vbo > MFT_REC_VOL * sbi->record_size) {
			err = -ENOENT;
			goto out;
		}
		lbo = vbo + sbi->mft.lbo;
		len = sbi->record_size;
	} else if (!run_lookup_entry(run, vcn, &lcn, &clen, &idx)) {
		err = -ENOENT;
		goto out;
	} else {
		if (lcn == SPARSE_LCN) {
			err = -EINVAL;
			goto out;
		}
		lbo = ((unsigned int int)lcn << cluster_bits) + off;
		len = ((unsigned int int)clen << cluster_bits) - off;
	}
	off = lbo & (blocksize - 1);
	if (nb) {
		nb->off = off;
		nb->bytes = bytes;
	}
	for (;;) {
		unsigned int len32 = len >= bytes ? bytes : len;
		sector_t block = lbo >> sb->s_blocksize_bits;
		do {
			unsigned int op = blocksize - off;
			if (op > len32)
				op = len32;
			bh = ntfs_bread(sb, block);
			if (!bh) {
				err = -EIO;
				goto out;
			}
			if (buf) {
				memcpy(buf, bh->b_data + off, op);
				buf = Add2Ptr(buf, op);
			}
			if (!nb) {
			} else if (nbh >= ARRAY_SIZE(nb->bh)) {
				err = -EINVAL;
				goto out;
			} else {
				nb->bh[nbh++] = bh;
				nb->nbufs = nbh;
			}
			bytes -= op;
			if (!bytes)
				return 0;
			len32 -= op;
			block += 1;
			off = 0;
		} while (len32);
		vcn_next = vcn + clen;
		if (!run_get_entry(run, ++idx, &vcn, &lcn, &clen) ||
		    vcn != vcn_next) {
			err = -ENOENT;
			goto out;
		}
		if (lcn == SPARSE_LCN) {
			err = -EINVAL;
			goto out;
		}
		lbo = ((unsigned int int)lcn << cluster_bits);
		len = ((unsigned int int)clen << cluster_bits);
	}
out:
	if (!nbh)
		return err;
	while (nbh) {
		put_bh(nb->bh[--nbh]);
		nb->bh[nbh] = NULL;
	}
	nb->nbufs = 0;
	return err;
}
