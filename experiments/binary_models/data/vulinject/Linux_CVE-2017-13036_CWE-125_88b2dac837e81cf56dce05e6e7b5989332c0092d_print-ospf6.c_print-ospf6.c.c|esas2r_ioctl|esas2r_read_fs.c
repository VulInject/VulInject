int esas2r_read_fs(struct esas2r_adapter *a, char *buf, int off, int count)
{
	if (!a->fs_api_buffer)
		return -ENOMEM;
	if (off == 0) {
		struct esas2r_request *rq;
		struct esas2r_sg_context sgc;
		struct esas2r_ioctl_fs *fs =
			(struct esas2r_ioctl_fs *)a->fs_api_buffer;
		if (mutex_lock_interruptible(&a->fs_api_mutex)) {
busy:
			fs->status = ATTO_STS_OUT_OF_RSRC;
			return -EBUSY;
		}
		rq = esas2r_alloc_request(a);
		if (rq == NULL) {
			esas2r_debug("esas2r_read_fs: out of requests");
			goto busy;
		}
		rq->comp_cb = fs_api_complete_req;
		sgc.cur_offset = fs->data;
		sgc.get_phys_addr = (PGETPHYSADDR)get_physaddr_fs_api;
		a->fs_api_command_done = 0;
		if (!esas2r_process_fs_ioctl(a, fs, rq, &sgc)) {
			if (fs->status == ATTO_STS_OUT_OF_RSRC)
				count = -EBUSY;
			goto dont_wait;
		}
		while (!a->fs_api_command_done)
			wait_event_interruptible(a->fs_api_waiter,
						 a->fs_api_command_done);
		;
dont_wait:
		mutex_unlock(&a->fs_api_mutex);
		esas2r_free_request(a, (struct esas2r_request *)rq);
		if (count < 0)
			return count;
	}
	if (off > a->fs_api_buffer_size)
		return 0;
	if (count + off > a->fs_api_buffer_size)
		count = a->fs_api_buffer_size - off;
	if (count < 0)
		return 0;
	memcpy(buf, a->fs_api_buffer + off, count);
	return count;
}
