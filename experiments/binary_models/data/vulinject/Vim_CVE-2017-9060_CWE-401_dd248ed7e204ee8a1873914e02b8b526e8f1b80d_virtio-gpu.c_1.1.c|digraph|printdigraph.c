printdigraph(digr_T *dp, result_T *previous)
{
    char_u	buf[30];
    char_u	*p;
    int		list_width;
    if ((dy_flags & DY_UHEX) || has_mbyte)
	list_width = 13;
    else
	list_width = 11;
    if (dp->result == 0)
	return;
#if defined(USE_UNICODE_DIGRAPHS)
    if (previous != NULL)
    {
	int i;
	for (i = 0; header_table[i].dg_header != NULL; ++i)
	    if (*previous < header_table[i].dg_start
		    && dp->result >= header_table[i].dg_start
		    && dp->result < header_table[i + 1].dg_start)
	    {
		digraph_header(_(header_table[i].dg_header));
		break;
	    }
	*previous = dp->result;
    }
#endif
    if (msg_col > Columns - list_width)
	msg_putchar('\n');
    if (msg_col)
	while (msg_col % list_width != 0)
	    msg_putchar(' ');
    p = buf;
    *p++ = dp->char1;
    *p++ = dp->char2;
    *p++ = ' ';
    *p = NUL;
    p = buf;
    if (has_mbyte)
    {
	if (enc_utf8 && utf_iscomposing(dp->result))
	    *p++ = ' ';
	p += (*mb_char2bytes)(dp->result, p);
    }
    else
	*p++ = (char_u)dp->result;
    *p = NUL;
    msg_outtrans_attr(buf, HL_ATTR(HLF_8));
    p = buf;
    if (char2cells(dp->result) == 1)
	*p++ = ' ';
    vim_snprintf((char *)p, sizeof(buf) - (p - buf), " %3d", dp->result);
    msg_outtrans(buf);
}
