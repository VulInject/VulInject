mangle_tree (enum order how, enum action what, void **root, int lag)
{
  int i;
  if (how == randomorder)
    {
      for (i = 0; i < SIZE; ++i)
        y[i] = i;
    }
  for (i = 0; i < SIZE + lag; ++i)
    {
      void *elem;
      int j, k;
      switch (how)
        {
        case randomorder:
          if (i >= lag)
            k = y[i - lag];
          else
            k = y[(SIZE - i - 1 + lag) % SIZE];
          j = y[i % SIZE];
          break;
        case ascending:
          k = i - lag;
          j = i;
          break;
        case descending:
          k = SIZE - i - 1 + lag;
          j = SIZE - i - 1;
          break;
        default:
          abort ();
        }
      switch (what)
        {
        case build_and_del:
        case build:
          if (i < SIZE)
            {
              if (tfind (x + j, (void *const *) root, cmp_fn) != NULL)
                {
                  fputs ("Found element which is not in tree yet.\n", stdout);
                  error = 1;
                }
              elem = tsearch (x + j, root, cmp_fn);
              if (elem == NULL
                  || tfind (x + j, (void *const *) root, cmp_fn) == NULL)
                {
                  fputs ("Couldn't find element after it was added.\n",
                         stdout);
                  error = 1;
                }
            }
          if (what == build || i < lag)
            break;
          j = k;
          FALLTHROUGH;
        case delete:
          elem = tfind (x + j, (void *const *) root, cmp_fn);
          if (elem == NULL || tdelete (x + j, root, cmp_fn) == NULL)
            {
              fputs ("Error deleting element.\n", stdout);
              error = 1;
            }
          break;
        case find:
          if (tfind (x + j, (void *const *) root, cmp_fn) == NULL)
            {
              fputs ("Couldn't find element after it was added.\n", stdout);
              error = 1;
            }
          break;
        }
    }
}
