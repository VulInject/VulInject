pcapng_pipe_dispatch(loop_data *ld, capture_src *pcap_src, char *errmsg, size_t errmsgl)
{
    enum { PD_REC_HDR_READ, PD_DATA_READ, PD_PIPE_EOF, PD_PIPE_ERR,
           PD_ERR } result;
#ifdef _WIN32
    gpointer  q_status;
#endif
    guint new_bufsize;
    pcapng_block_header_t *bh = &pcap_src->cap_pipe_info.pcapng.bh;
#ifdef LOG_CAPTURE_VERBOSE
    ws_debug("pcapng_pipe_dispatch");
#endif
    switch (pcap_src->cap_pipe_state) {
    case STATE_EXPECT_REC_HDR:
#ifdef LOG_CAPTURE_VERBOSE
        ws_debug("pcapng_pipe_dispatch STATE_EXPECT_REC_HDR");
#endif
#ifdef _WIN32
        if (g_mutex_trylock(pcap_src->cap_pipe_read_mtx)) {
#endif
            pcap_src->cap_pipe_state = STATE_READ_REC_HDR;
            pcap_src->cap_pipe_bytes_to_read = sizeof(pcapng_block_header_t);
            pcap_src->cap_pipe_bytes_read = 0;
#ifdef _WIN32
            if (!pcap_src->from_cap_socket) {
                pcap_src->cap_pipe_buf = pcap_src->cap_pipe_databuf;
                g_async_queue_push(pcap_src->cap_pipe_pending_q, pcap_src->cap_pipe_buf);
            }
            g_mutex_unlock(pcap_src->cap_pipe_read_mtx);
        }
#endif
    case STATE_READ_REC_HDR:
#ifdef LOG_CAPTURE_VERBOSE
        ws_debug("pcapng_pipe_dispatch STATE_READ_REC_HDR");
#endif
#ifdef _WIN32
        if (pcap_src->from_cap_socket) {
#endif
            if (cap_pipe_read_data_bytes(pcap_src, errmsg, errmsgl) < 0) {
                return -1;
            }
#ifdef _WIN32
        } else {
	q_status=((pcap_src->cap_pipe_done_q+PIPE_READ_TIMEOUT-1)/PIPE_READ_TIMEOUT);
            if (pcap_src->cap_pipe_err == PIPEOF) {
                result = PD_PIPE_EOF;
                break;
            } else if (pcap_src->cap_pipe_err == PIPERR) {
                result = PD_PIPE_ERR;
                break;
            }
            if (!q_status) {
                return 0;
            }
        }
#endif
        if (pcap_src->cap_pipe_bytes_read < pcap_src->cap_pipe_bytes_to_read) {
            return 0;
        }
        memcpy(bh, pcap_src->cap_pipe_databuf, sizeof(pcapng_block_header_t));
        result = PD_REC_HDR_READ;
        break;
    case STATE_EXPECT_DATA:
#ifdef LOG_CAPTURE_VERBOSE
        ws_debug("pcapng_pipe_dispatch STATE_EXPECT_DATA");
#endif
#ifdef _WIN32
        if (g_mutex_trylock(pcap_src->cap_pipe_read_mtx)) {
#endif
            pcap_src->cap_pipe_state = STATE_READ_DATA;
            pcap_src->cap_pipe_bytes_to_read = bh->block_total_length;
#ifdef _WIN32
            if (!pcap_src->from_cap_socket) {
                pcap_src->cap_pipe_bytes_to_read -= pcap_src->cap_pipe_bytes_read;
                pcap_src->cap_pipe_buf = pcap_src->cap_pipe_databuf + pcap_src->cap_pipe_bytes_read;
                pcap_src->cap_pipe_bytes_read = 0;
                g_async_queue_push(pcap_src->cap_pipe_pending_q, pcap_src->cap_pipe_buf);
            }
            g_mutex_unlock(pcap_src->cap_pipe_read_mtx);
        }
#endif
    case STATE_READ_DATA:
#ifdef LOG_CAPTURE_VERBOSE
        ws_debug("pcapng_pipe_dispatch STATE_READ_DATA");
#endif
#ifdef _WIN32
        if (pcap_src->from_cap_socket) {
#endif
            if (cap_pipe_read_data_bytes(pcap_src, errmsg, errmsgl) < 0) {
                return -1;
            }
#ifdef _WIN32
        } else {
            q_status = g_async_queue_timeout_pop(pcap_src->cap_pipe_done_q, PIPE_READ_TIMEOUT);
            if (pcap_src->cap_pipe_err == PIPEOF) {
                result = PD_PIPE_EOF;
                break;
            } else if (pcap_src->cap_pipe_err == PIPERR) {
                result = PD_PIPE_ERR;
                break;
            }
            if (!q_status) {
                return 0;
            }
        }
#endif 
        if (pcap_src->cap_pipe_bytes_read < pcap_src->cap_pipe_bytes_to_read) {
            return 0;
        }
        result = PD_DATA_READ;
        break;
    default:
        snprintf(errmsg, errmsgl,
                   "pcapng_pipe_dispatch: invalid state");
        result = PD_ERR;
    } 
    switch (result) {
    case PD_REC_HDR_READ:
        if (bh->block_type == BLOCK_TYPE_SHB) {
            pcapng_read_shb(pcap_src, errmsg, errmsgl);
            return 1;
        }
        if ((bh->block_total_length & 0x03) != 0) {
            snprintf(errmsg, errmsgl,
                       "Total length of pcapng block read from pipe is %u, which is not a multiple of 4.",
                       bh->block_total_length);
            break;
        }
        if (is_data_block(bh->block_type) && bh->block_total_length > pcap_src->cap_pipe_max_pkt_size) {
            snprintf(errmsg, errmsgl, "Block %u type 0x%08x too int (%d bytes)",
                    ld->packets_captured+1, bh->block_type, bh->block_total_length);
            break;
        }
        if (bh->block_total_length > pcap_src->cap_pipe_databuf_size) {
            new_bufsize = bh->block_total_length;
            new_bufsize--;
            new_bufsize |= new_bufsize >> 1;
            new_bufsize |= new_bufsize >> 2;
            new_bufsize |= new_bufsize >> 4;
            new_bufsize |= new_bufsize >> 8;
            new_bufsize |= new_bufsize >> 16;
            new_bufsize++;
            pcap_src->cap_pipe_databuf = (guchar*)g_realloc(pcap_src->cap_pipe_databuf, new_bufsize);
            pcap_src->cap_pipe_databuf_size = new_bufsize;
        }
        if (bh->block_total_length < sizeof(pcapng_block_header_t)+sizeof(guint32)) {
            snprintf(errmsg, errmsgl,
                       "malformed pcapng block_total_length < minimum");
            pcap_src->cap_pipe_err = PIPEOF;
            return -1;
        }
        pcap_src->cap_pipe_state = STATE_EXPECT_DATA;
        return 0;
    case PD_DATA_READ:
        if (use_threads) {
            capture_loop_queue_pcapng_cb(pcap_src, bh, pcap_src->cap_pipe_databuf);
        } else {
            capture_loop_write_pcapng_cb(pcap_src, bh, pcap_src->cap_pipe_databuf);
        }
        pcap_src->cap_pipe_state = STATE_EXPECT_REC_HDR;
        return 1;
    case PD_PIPE_EOF:
        pcap_src->cap_pipe_err = PIPEOF;
        return -1;
    case PD_PIPE_ERR:
        snprintf(errmsg, errmsgl, "Error reading from pipe: %s",
#ifdef _WIN32
                   win32strerror(GetLastError()));
#else
                   g_strerror(errno));
#endif
    case PD_ERR:
        break;
    }
    pcap_src->cap_pipe_err = PIPERR;
    return -1;
}
