print_nsp(netdissect_options *ndo,
          const u_char *nspp, u_int nsplen)
{
	const struct nsphdr *nsphp = (const struct nsphdr *)nspp;
	u_int dst, src, flags;
	if (nsplen < sizeof(struct nsphdr)) {
		ND_PRINT(" (nsplen %u < %zu)", nsplen, sizeof(struct nsphdr));
		goto invalid;
	}
	flags = GET_U_1(nsphp->nh_flags);
	dst = GET_LE_U_2(nsphp->nh_dst);
	src = GET_LE_U_2(nsphp->nh_src);
	switch (flags & NSP_TYPEMASK) {
	case MFT_DATA:
	    switch (flags & NSP_SUBMASK) {
	    case MFS_BOM:
	    case MFS_MOM:
	    case MFS_EOM:
	    case MFS_BOM+MFS_EOM:
		ND_PRINT("data %u>%u ", src, dst);
		{
		    const struct seghdr *shp = (const struct seghdr *)nspp;
		    u_int ack;
		    u_int data_off = sizeof(struct minseghdr);
		    if (nsplen < data_off)
			goto invalid;
		    ack = GET_LE_U_2(shp->sh_seq[0]);
		    if (ack & SGQ_ACK) {	
			if ((ack & SGQ_NAK) == SGQ_NAK)
			    ND_PRINT("nak %u ", ack & SGQ_MASK);
			else
			    ND_PRINT("ack %u ", ack & SGQ_MASK);
			data_off += sizeof(short);
			if (nsplen < data_off)
			    goto invalid;
		        ack = GET_LE_U_2(shp->sh_seq[1]);
			if (ack & SGQ_OACK) {	
			    if ((ack & SGQ_ONAK) == SGQ_ONAK)
				ND_PRINT("onak %u ", ack & SGQ_MASK);
			    else
				ND_PRINT("oack %u ", ack & SGQ_MASK);
			    data_off += sizeof(short);
			    if (nsplen < data_off)
				goto invalid;
			    ack = GET_LE_U_2(shp->sh_seq[2]);
			}
		    }
		    ND_PRINT("seg %u ", ack & SGQ_MASK);
		}
		break;
	    case MFS_ILS+MFS_INT:
		ND_PRINT("intr ");
		{
		    const struct seghdr *shp = (const struct seghdr *)nspp;
		    u_int ack;
		    u_int data_off = sizeof(struct minseghdr);
		    if (nsplen < data_off)
			goto invalid;
		    ack = GET_LE_U_2(shp->sh_seq[0]);
		    if (ack & SGQ_ACK) {	
			if ((ack & SGQ_NAK) == SGQ_NAK)
			    ND_PRINT("nak %u ", ack & SGQ_MASK);
			else
			    ND_PRINT("ack %u ", ack & SGQ_MASK);
			data_off += sizeof(short);
			if (nsplen < data_off)
			    goto invalid;
		        ack = GET_LE_U_2(shp->sh_seq[1]);
			if (ack & SGQ_OACK) {	
			    if ((ack & SGQ_ONAK) == SGQ_ONAK)
				ND_PRINT("nakdat %u ", ack & SGQ_MASK);
			    else
				ND_PRINT("ackdat %u ", ack & SGQ_MASK);
			    data_off += sizeof(short);
			    if (nsplen < data_off)
				goto invalid;
			    ack = GET_LE_U_2(shp->sh_seq[2]);
			}
		    }
		    ND_PRINT("seg %u ", ack & SGQ_MASK);
		}
		break;
	    case MFS_ILS:
		ND_PRINT("link-service %u>%u ", src, dst);
		{
		    const struct seghdr *shp = (const struct seghdr *)nspp;
		    const struct lsmsg *lsmp =
			(const struct lsmsg *)(nspp + sizeof(struct seghdr));
		    u_int ack;
		    u_int lsflags, fcval;
		    if (nsplen < sizeof(struct seghdr) + sizeof(struct lsmsg))
			goto invalid;
		    ack = GET_LE_U_2(shp->sh_seq[0]);
		    if (ack & SGQ_ACK) {	
			if ((ack & SGQ_NAK) == SGQ_NAK)
			    ND_PRINT("nak %u ", ack & SGQ_MASK);
			else
			    ND_PRINT("ack %u ", ack & SGQ_MASK);
		        ack = GET_LE_U_2(shp->sh_seq[1]);
			if (ack & SGQ_OACK) {	
			    if ((ack & SGQ_ONAK) == SGQ_ONAK)
				ND_PRINT("nakdat %u ", ack & SGQ_MASK);
			    else
				ND_PRINT("ackdat %u ", ack & SGQ_MASK);
			    ack = GET_LE_U_2(shp->sh_seq[2]);
			}
		    }
		    ND_PRINT("seg %u ", ack & SGQ_MASK);
		    lsflags = GET_U_1(lsmp->ls_lsflags);
		    fcval = GET_U_1(lsmp->ls_fcval);
		    switch (lsflags & LSI_MASK) {
		    case LSI_DATA:
			ND_PRINT("dat seg count %u ", fcval);
			switch (lsflags & LSM_MASK) {
			case LSM_NOCHANGE:
			    break;
			case LSM_DONOTSEND:
			    ND_PRINT("donotsend-data ");
			    break;
			case LSM_SEND:
			    ND_PRINT("send-data ");
			    break;
			default:
			    ND_PRINT("reserved-fcmod? %x", lsflags);
			    break;
			}
			break;
		    case LSI_INTR:
			ND_PRINT("intr req count %u ", fcval);
			break;
		    default:
			ND_PRINT("reserved-fcval-int? %x", lsflags);
			break;
		    }
		}
		break;
	    default:
		ND_PRINT("reserved-subtype? %x %u > %u", flags, src, dst);
		break;
	    }
	    break;
	case MFT_ACK:
	    switch (flags & NSP_SUBMASK) {
	    case MFS_DACK:
		ND_PRINT("data-ack %u>%u ", src, dst);
		{
		    const struct ackmsg *amp = (const struct ackmsg *)nspp;
		    u_int ack;
		    if (nsplen < sizeof(struct ackmsg))
			goto invalid;
		    ack = GET_LE_U_2(amp->ak_acknum[0]);
		    if (ack & SGQ_ACK) {	
			if ((ack & SGQ_NAK) == SGQ_NAK)
			    ND_PRINT("nak %u ", ack & SGQ_MASK);
			else
			    ND_PRINT("ack %u ", ack & SGQ_MASK);
		        ack = GET_LE_U_2(amp->ak_acknum[1]);
			if (ack & SGQ_OACK) {	
			    if ((ack & SGQ_ONAK) == SGQ_ONAK)
				ND_PRINT("onak %u ", ack & SGQ_MASK);
			    else
				ND_PRINT("oack %u ", ack & SGQ_MASK);
			}
		    }
		}
		break;
	    case MFS_IACK:
		ND_PRINT("ils-ack %u>%u ", src, dst);
		{
		    const struct ackmsg *amp = (const struct ackmsg *)nspp;
		    u_int ack;
		    if (nsplen < sizeof(struct ackmsg))
			goto invalid;
		    ND_TCHECK_SIZE(amp);
		    ack = GET_LE_U_2(amp->ak_acknum[0]);
		    if (ack & SGQ_ACK) {	
			if ((ack & SGQ_NAK) == SGQ_NAK)
			    ND_PRINT("nak %u ", ack & SGQ_MASK);
			else
			    ND_PRINT("ack %u ", ack & SGQ_MASK);
		        ack = GET_LE_U_2(amp->ak_acknum[1]);
			if (ack & SGQ_OACK) {	
			    if ((ack & SGQ_ONAK) == SGQ_ONAK)
				ND_PRINT("nakdat %u ", ack & SGQ_MASK);
			    else
				ND_PRINT("ackdat %u ", ack & SGQ_MASK);
			}
		    }
		}
		break;
	    case MFS_CACK:
		ND_PRINT("conn-ack %u", dst);
		break;
	    default:
		ND_PRINT("reserved-acktype? %x %u > %u", flags, src, dst);
		break;
	    }
	    break;
	case MFT_CTL:
	    switch (flags & NSP_SUBMASK) {
	    case MFS_CI:
	    case MFS_RCI:
		if ((flags & NSP_SUBMASK) == MFS_CI)
		    ND_PRINT("conn-initiate ");
		else
		    ND_PRINT("retrans-conn-initiate ");
		ND_PRINT("%u>%u ", src, dst);
		{
		    const struct cimsg *cimp = (const struct cimsg *)nspp;
		    u_int services, info, segsize;
		    if (nsplen < sizeof(struct cimsg))
			goto invalid;
		    services = GET_U_1(cimp->ci_services);
		    info = GET_U_1(cimp->ci_info);
		    segsize = GET_LE_U_2(cimp->ci_segsize);
		    switch (services & COS_MASK) {
		    case COS_NONE:
			break;
		    case COS_SEGMENT:
			ND_PRINT("seg ");
			break;
		    case COS_MESSAGE:
			ND_PRINT("msg ");
			break;
		    }
		    switch (info & COI_MASK) {
		    case COI_32:
			ND_PRINT("ver 3.2 ");
			break;
		    case COI_31:
			ND_PRINT("ver 3.1 ");
			break;
		    case COI_40:
			ND_PRINT("ver 4.0 ");
			break;
		    case COI_41:
			ND_PRINT("ver 4.1 ");
			break;
		    }
		    ND_PRINT("segsize %u ", segsize);
		}
		break;
	    case MFS_CC:
		ND_PRINT("conn-confirm %u>%u ", src, dst);
		{
		    const struct ccmsg *ccmp = (const struct ccmsg *)nspp;
		    u_int services, info;
		    u_int segsize, optlen;
		    if (nsplen < sizeof(struct ccmsg))
			goto invalid;
		    services = GET_U_1(ccmp->cc_services);
		    info = GET_U_1(ccmp->cc_info);
		    segsize = GET_LE_U_2(ccmp->cc_segsize);
		    optlen = GET_U_1(ccmp->cc_optlen);
		    switch (services & COS_MASK) {
		    case COS_NONE:
			break;
		    case COS_SEGMENT:
			ND_PRINT("seg ");
			break;
		    case COS_MESSAGE:
			ND_PRINT("msg ");
			break;
		    }
		    switch (info & COI_MASK) {
		    case COI_32:
			ND_PRINT("ver 3.2 ");
			break;
		    case COI_31:
			ND_PRINT("ver 3.1 ");
			break;
		    case COI_40:
			ND_PRINT("ver 4.0 ");
			break;
		    case COI_41:
			ND_PRINT("ver 4.1 ");
			break;
		    }
		    ND_PRINT("segsize %u ", segsize);
		    if (optlen) {
			ND_PRINT("optlen %u ", optlen);
		    }
		}
		break;
	    case MFS_DI:
		ND_PRINT("disconn-initiate %u>%u ", src, dst);
		{
		    const struct dimsg *dimp = (const struct dimsg *)nspp;
		    u_int reason;
		    u_int optlen;
		    if (nsplen < sizeof(struct dimsg))
			goto invalid;
		    reason = GET_LE_U_2(dimp->di_reason);
		    optlen = GET_U_1(dimp->di_optlen);
		    print_reason(ndo, reason);
		    if (optlen) {
			ND_PRINT("optlen %u ", optlen);
		    }
		}
		break;
	    case MFS_DC:
		ND_PRINT("disconn-confirm %u>%u ", src, dst);
		{
		    const struct dcmsg *dcmp = (const struct dcmsg *)nspp;
		    u_int reason;
		    reason = GET_LE_U_2(dcmp->dc_reason);
		    print_reason(ndo, reason);
		}
		break;
	    default:
		ND_PRINT("reserved-ctltype? %x %u > %u", flags, src, dst);
		break;
	    }
	    break;
	default:
	    ND_PRINT("reserved-type? %x %u > %u", flags, src, dst);
	    break;
	}
	return (1);
invalid:
	return (0);
}
