static void dm_crtc_high_irq(void *interrupt_params)
{
	struct common_irq_params *irq_params = interrupt_params;
	struct amdgpu_device *adev = irq_params->adev;
	struct drm_writeback_job *job;
	struct amdgpu_crtc *acrtc;
	unsigned int flags;
	int vrr_active;
	acrtc = get_crtc_by_otg_inst(adev, irq_params->irq_src - IRQ_TYPE_VBLANK);
	if (!acrtc)
		return;
	if (acrtc->wb_pending) {
		if (acrtc->wb_conn) {
			spin_lock_irqsave(&acrtc->wb_conn->job_lock, flags);
			job = list_first_entry_or_null(&acrtc->wb_conn->job_queue,
						       struct drm_writeback_job,
						       list_entry);
			spin_unlock_irqrestore(&acrtc->wb_conn->job_lock, flags);
			if (job) {
	int v_total, refresh_hz;
				struct dc_stream_state *stream = acrtc->dm_irq_params.stream;
				v_total = stream->adjust.v_total_max ?
					  stream->adjust.v_total_max : stream->timing.v_total;
				refresh_hz = div_u64((unsigned int int) stream->timing.pix_clk_100hz *
					     100LL, (v_total * stream->timing.h_total));
				mdelay(1000 / refresh_hz);
				drm_writeback_signal_completion(acrtc->wb_conn, 0);
				dc_stream_fc_disable_writeback(adev->dm.dc,
							       acrtc->dm_irq_params.stream, 0);
			}
		} else
			DRM_ERROR("%s: no amdgpu_crtc wb_conn\n", __func__);
		acrtc->wb_pending = false;
	}
	vrr_active = amdgpu_dm_crtc_vrr_active_irq(acrtc);
	drm_dbg_vbl(adev_to_drm(adev),
		    "crtc:%d, vupdate-vrr:%d, planes:%d\n", acrtc->crtc_id,
		    vrr_active, acrtc->dm_irq_params.active_planes);
	if (!vrr_active)
		amdgpu_dm_crtc_handle_vblank(acrtc);
	amdgpu_dm_crtc_handle_crc_irq(&acrtc->base);
	if (adev->family < AMDGPU_FAMILY_AI)
		return;
	spin_lock_irqsave(&adev_to_drm(adev)->event_lock, flags);
	if (acrtc->dm_irq_params.stream &&
	    acrtc->dm_irq_params.vrr_params.supported &&
	    acrtc->dm_irq_params.freesync_config.state ==
		    VRR_STATE_ACTIVE_VARIABLE) {
		mod_freesync_handle_v_update(adev->dm.freesync_module,
					     acrtc->dm_irq_params.stream,
					     &acrtc->dm_irq_params.vrr_params);
		dc_stream_adjust_vmin_vmax(adev->dm.dc, acrtc->dm_irq_params.stream,
					   &acrtc->dm_irq_params.vrr_params.adjust);
	}
	if (adev->family >= AMDGPU_FAMILY_RV &&
	    acrtc->pflip_status == AMDGPU_FLIP_SUBMITTED &&
	    acrtc->dm_irq_params.active_planes == 0) {
		if (acrtc->event) {
			drm_crtc_send_vblank_event(&acrtc->base, acrtc->event);
			acrtc->event = NULL;
			drm_crtc_vblank_put(&acrtc->base);
		}
		acrtc->pflip_status = AMDGPU_FLIP_NONE;
	}
	spin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);
}
