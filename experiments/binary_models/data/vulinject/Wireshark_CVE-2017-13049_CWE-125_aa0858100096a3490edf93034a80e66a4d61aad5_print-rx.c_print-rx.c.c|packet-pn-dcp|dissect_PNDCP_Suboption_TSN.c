dissect_PNDCP_Suboption_TSN(tvbuff_t* tvb, int offset, packet_info* pinfo,
    proto_tree* tree, proto_item* block_item, proto_item* dcp_item,
    guint8 service_id, gboolean is_response)
{
    guint8    suboption;
    guint16   block_length;
    char     *domain_name;
    guint16   nme_prio;
    e_guid_t  tsn_domain_uuid;
    e_guid_t  nme_parameter_uuid;
    e_guid_t  nme_name_uuid;
    guint16   vendor_id;
    guint16   device_id;
    guint16   block_info = 0;
    guint16   block_qualifier = 0;
    gboolean  have_block_info = FALSE;
    gboolean  have_block_qualifier = FALSE;
    guint8    instance_id_high;
    guint8    instance_id_low;
    conversation_t* conversation;
    stationInfo* station_info;
    gboolean is_zeros = TRUE;
    offset = dissect_pn_uint8(tvb, offset, pinfo, tree, hf_pn_dcp_suboption_tsn, &suboption);
    offset = dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_dcp_block_length, &block_length);
    if (((service_id == PNDCP_SERVICE_ID_IDENTIFY) && is_response) ||
        ((service_id == PNDCP_SERVICE_ID_HELLO) && !is_response) ||
        ((service_id == PNDCP_SERVICE_ID_GET) && is_response)) {
        offset = dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_dcp_block_info, &block_info);
        have_block_info = TRUE;
        block_length -= 2;
    }
    if ((service_id == PNDCP_SERVICE_ID_SET) && !is_response) {
        offset = dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_dcp_block_qualifier, &block_qualifier);
        have_block_qualifier = TRUE;
        block_length -= 2;
    }
    switch (suboption) {
    case PNDCP_SUBOPTION_TSN_DOMAIN_NAME:
        offset = dissect_pn_uuid(tvb, offset, pinfo, tree, hf_pn_dcp_suboption_tsn_domain_uuid, &tsn_domain_uuid);
        proto_tree_add_item_ret_display_string(tree, hf_pn_dcp_suboption_tsn_domain_name, tvb, offset, (block_length-16), ENC_ASCII | ENC_NA, pinfo->pool, &domain_name);
        pn_append_info(pinfo, dcp_item, ", TSN-Domain Name");
        proto_item_append_text(block_item, "TSN/TSN-Domain Name");
        if (have_block_qualifier) {
            proto_item_append_text(block_item, ", BlockQualifier: %s",
                val_to_str_const(block_qualifier, pn_dcp_block_qualifier, "Unknown"));
        }
        if (have_block_info)
            proto_item_append_text(block_item, ", BlockInfo: %s", rval_to_str_const(block_info, pn_dcp_block_info, "Unknown"));
        pn_append_info(pinfo, dcp_item, wmem_strdup_printf(pinfo->pool, ", DomainName:\"%s\"", domain_name));
        proto_item_append_text(block_item, ", \"%s\"", domain_name);
        offset += (block_length-16);
        is_zeros = TRUE;
        for (int i = 0; i < 8; i++)
        {
            if (tsn_domain_uuid.data4[i] != 0)
            {
                is_zeros = FALSE;
                break;
            }
        }
        if ((tsn_domain_uuid.data1 == 0) && (tsn_domain_uuid.data2 == 0) && (tsn_domain_uuid.data3 == 0) && (is_zeros))
            proto_item_append_text(block_item, ", No TSN domain assigned");
        else
            proto_item_append_text(block_item, ", UUID identifying a TSN domain using SNMP/ LLDP/ DCP");
        break;
    case PNDCP_SUBOPTION_TSN_NME_MANAGER:
        pn_append_info(pinfo, dcp_item, ", NME-Manager");
        proto_item_append_text(block_item, "TSN/NME-Manager");
        if (have_block_qualifier)
        {
            proto_item_append_text(block_item, ", BlockQualifier: %s",
                val_to_str_const(block_qualifier, pn_dcp_block_qualifier, "Unknown"));
        }
        if (have_block_info)
        {
            offset = dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_dcp_suboption_tsn_nme_prio, &nme_prio);
            proto_item_append_text(block_item, ", BlockInfo: %s", rval_to_str_const(block_info, pn_dcp_block_info, "Unknown"));
            if (nme_prio == 0x0000)
                proto_item_append_text(block_item, ", Highest priority NME manager");
            else if ((0x0001 <= nme_prio) && (nme_prio <= 0x3000))
                proto_item_append_text(block_item, ", High priorities for NME manager");
            else if ((0x3001 <= nme_prio) && (nme_prio <= 0x9FFF))
                proto_item_append_text(block_item, ", Low priorities for NME manager");
            else if (0xA000 == nme_prio)
                proto_item_append_text(block_item, ", Lowest priority for NME manager / Default priority for NME manager");
            else
                proto_item_append_text(block_item, ", Reserved");
        }
        break;
    case PNDCP_SUBOPTION_TSN_NME_PARAMETER_UUID:
        pn_append_info(pinfo, dcp_item, ", NME-Parameter UUID");
        proto_item_append_text(block_item, "TSN/NME-Parameter UUID");
        if (block_length > 0)
        {
            offset = dissect_pn_uuid(tvb, offset, pinfo, tree, hf_pn_dcp_suboption_tsn_nme_parameter_uuid, &nme_parameter_uuid);
            if (have_block_qualifier)
            {
                proto_item_append_text(block_item, ", BlockQualifier: %s",
                    val_to_str_const(block_qualifier, pn_dcp_block_qualifier, "Unknown"));
            }
            if (have_block_info)
                proto_item_append_text(block_item, ", BlockInfo: %s", rval_to_str_const(block_info, pn_dcp_block_info, "Unknown"));
            is_zeros = TRUE;
            for (int i = 0; i < 8; i++)
            {
                if (nme_parameter_uuid.data4[i] != 0)
                {
                    is_zeros = FALSE;
                    break;
                }
            }
            if ((nme_parameter_uuid.data1 == 0) && (nme_parameter_uuid.data2 == 0) && (nme_parameter_uuid.data3 == 0) && (is_zeros))
                proto_item_append_text(block_item, ", Unconfigured");
            else
                proto_item_append_text(block_item, ", UUID identifying an NME parameter set within the TSN domain.");
        }
        break;
    case PNDCP_SUBOPTION_TSN_NME_AGENT:
        pn_append_info(pinfo, dcp_item, ", NME-Agent");
        proto_item_append_text(block_item, "TSN/NME-Agent");
        if (have_block_qualifier)
        {
            proto_item_append_text(block_item, ", BlockQualifier: %s",
                val_to_str_const(block_qualifier, pn_dcp_block_qualifier, "Unknown"));
        }
        if (have_block_info)
        {
            offset = dissect_pn_uuid(tvb, offset, pinfo, tree, hf_pn_dcp_suboption_tsn_nme_agent, &nme_name_uuid);
            proto_item_append_text(block_item, ", BlockInfo: %s", rval_to_str_const(block_info, pn_dcp_block_info, "Unknown"));
            is_zeros = TRUE;
            for (int i = 0; i < 8; i++)
            {
                if (nme_name_uuid.data4[i] != 0)
                {
                    is_zeros = FALSE;
                    break;
                }
            }
            if ((nme_name_uuid.data1 == 0) && (nme_name_uuid.data2 == 0) && (nme_name_uuid.data3 == 0) && (is_zeros))
                proto_item_append_text(block_item, ", No NME assigned");
            else
                proto_item_append_text(block_item, ", UUID identifying an NME using SNMP / LLDP / DCP");
        }
        break;
    case PNDCP_SUBOPTION_TSN_CIM_INTERFACE:
        pn_append_info(pinfo, dcp_item, ", CIM-Interface");
        proto_item_append_text(block_item, "TSN/CIM-Interface");
        if (have_block_qualifier)
        {
            proto_item_append_text(block_item, ", BlockQualifier: %s",
                val_to_str_const(block_qualifier, pn_dcp_block_qualifier, "Unknown"));
        }
        if (have_block_info)
        {
            dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_dcp_vendor_id_high, &vendor_id);
            offset = dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_dcp_vendor_id_low, &vendor_id);
            dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_dcp_device_id_high, &device_id);
            offset = dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_dcp_device_id_low, &device_id);
            offset = dissect_pn_uint8(tvb, offset, pinfo, tree, hf_pn_dcp_instance_id_high, &instance_id_high);
            offset = dissect_pn_uint8(tvb, offset, pinfo, tree, hf_pn_dcp_instance_id_low, &instance_id_low);
            if (pinfo->fd->visited == FALSE) {
                conversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, CONVERSATION_NONE, 0, 0, 0);
                if (conversation == NULL) {
                    conversation = conversation_new(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, CONVERSATION_NONE, 0, 0, 0);
                }
                station_info = (stationInfo*)conversation_get_proto_data(conversation, proto_pn_dcp);
                if (station_info == NULL) {
                    station_info = wmem_new0(wmem_file_scope(), stationInfo);
                    conversation_add_proto_data(conversation, proto_pn_dcp, station_info);
                }
                station_info->u16Vendor_id = vendor_id;
                station_info->u16Device_id = device_id;
            }
            proto_item_append_text(block_item, ", BlockInfo: %s", rval_to_str_const(block_info, pn_dcp_block_info, "Unknown"));
            proto_item_append_text(block_item, ", VendorID: 0x%04x / DeviceID: 0x%04x / InstanceIDHigh: 0x%04x / InstanceIDLow: 0x%04x", vendor_id, device_id, instance_id_high, instance_id_low);
        }
        break;
    default:
        pn_append_info(pinfo, dcp_item, ", TSN/Reserved");
        proto_item_append_text(block_item, "TSN/Reserved");
    }
    return offset;
}
