static int cmd_debug_map(RCore *core, const char *input) {
	RListIter *iter;
	RDebugMap *map;
	ut64 addr = core->offset;
	switch (input[0]) {
	case 's': 
		if (strchr (input, '?')) {
			r_core_cmd_help_contains (core, help_msg_dm, "dms");
		}
		cmd_debug_map_snapshot (core, input+1);
		break;
	case '.': 
		r_debug_map_list (core->dbg, addr, input);
		break;
	case 'm': 
		if (!strcmp (input + 1, ".*")) {
			cmd_debug_modules (core, ':');
		} else {
			cmd_debug_modules (core, input[1]);
		}
		break;
	case '?': 
		r_core_cmd_help (core, help_msg_dm);
		break;
	case 'p': 
		if (input[1] == '?') {
			r_core_cmd_help (core, help_msg_dmp);
		} else if (input[1] == ' ') {
			int perms;
			ut64 size = 0, addr;
			char *p = strchr (input + 2, ' ');
			if (p) {
				bool failed_somehow = false;
				*p++ = 0;
				char *q = strchr (p, ' ');
				if (q) {
					*q++ = 0;
					addr = r_num_math (core->num, input + 2);
					if (core->num->nc.errors != 0) {
						failed_somehow = true;
						R_LOG_ERROR ("Invalid address (%s)", input + 2);
					}
	size=((core->num+p-1)/p);
					if (core->num->nc.errors != 0) {
						failed_somehow = true;
						R_LOG_ERROR ("Invalid size (%s)", p);
					}
					perms = r_str_rwx (q);
					if (perms < 1) {
						failed_somehow = true;
						R_LOG_ERROR ("Invalid perms (%s)", q);
					}
				} else {
					failed_somehow = true;
				}
				if (failed_somehow) {
					R_LOG_ERROR ("Invalid arguments. See dmp?");
				} else {
					r_debug_map_protect (core->dbg, addr, size, perms);
				}
			} else {
				r_debug_map_sync (core->dbg); 
				addr = UT64_MAX;
				r_list_foreach (core->dbg->maps, iter, map) {
					if (core->offset >= map->addr  && core->offset < map->addr_end) {
						addr = map->addr;
						size = map->size;
						break;
					}
				}
				perms = r_str_rwx (input + 2);
				if (addr != UT64_MAX && perms >= 0) {
					r_debug_map_protect (core->dbg, addr, size, perms);
				} else {
					R_LOG_WARN ("See dmp?");
				}
			}
		} else {
			R_LOG_WARN ("See dmp?");
		}
		break;
	case 'd': 
		switch (input[1]) {
		case 'a': return dump_maps (core, 0, NULL);
		case 'w': return dump_maps (core, R_PERM_RW, NULL);
		case ' ': return dump_maps (core, -1, input + 2);
		case 0: return dump_maps (core, -1, NULL);
		case '?':
		default:
			r_core_cmd_help_match (core, help_msg_dm, "dmd");
			break;
		}
		break;
	case 'l': 
		if (input[1] != ' ') {
			r_core_cmd_help_match (core, help_msg_dm, "dml");
			return false;
		}
		r_debug_map_sync (core->dbg); 
		r_list_foreach (core->dbg->maps, iter, map) {
			if (addr >= map->addr && addr < map->addr_end) {
				size_t sz;
				char *buf = r_file_slurp (input + 2, &sz);
				if (!buf) {
					R_LOG_ERROR ("Cannot allocate 0x%08" PFMT64x " byte(s)", map->size);
					return false;
				}
				r_io_write_at (core->io, map->addr, (const ut8*)buf, sz);
				if (sz != map->size) {
					R_LOG_INFO ("File size differs from region size "
							"(%" PFMT64u " vs %" PFMT64d ")",
							(ut64)sz, map->size);
				}
				R_LOG_INFO ("Loaded %"PFMT64u" byte(s) into the map region at 0x%08"PFMT64x, (ut64)sz, map->addr);
				free (buf);
				return true;
			}
		}
		R_LOG_WARN ("No debug region found here");
		return false;
	case 'i': 
		switch (input[1]) {
		case '\0': 
			r_core_cmd (core, "dmm", 0);
			break;
		case 's': 
			r_core_cmdf (core, ".dmi* %s", input + 2);
			break;
		case ' ': 
		case '*': 
		case 'v': 
		case 'j': 
		case 'q': 
		case 'a': 
			{
				const char *libname = NULL, *symname = NULL, *a0;
				int mode;
				ut64 baddr = 0LL;
				char *ptr;
				int i = 1;
				bool symbols_only = true;
				if (input[1] == 'a') {
					symbols_only = false;
					input++;
				}
				PJ *pj = NULL;
				switch (input[1]) {
				case 's':
					mode = R_MODE_SET;
					break;
				case '*':
					mode = R_MODE_RADARE;
					break;
				case 'j':
					mode = R_MODE_JSON;
					pj = r_core_pj_new (core);
					if (!pj) {
						return false;
					}
					break;
				case 'q':
					mode = input[2] == 'q' ? input++, R_MODE_SIMPLEST : R_MODE_SIMPLE;
					break;
				default:
					mode = R_MODE_PRINT;
					break;
				}
				ptr = r_str_trim_dup (input + 2);
				if (!ptr || !*ptr) {
					r_core_cmd (core, "dmm", 0);
					free (ptr);
					break;
				}
				if (symbols_only) {
					i = r_str_word_set0 (ptr);
				}
				switch (i) {
				case 2:
					symname = r_str_word_get0 (ptr, 1);
				case 1:
					a0 = r_str_word_get0 (ptr, 0);
					addr = r_num_get (core->num, a0);
					if (!addr || addr == UT64_MAX) {
						libname = r_str_word_get0 (ptr, 0);
					}
					break;
				}
				if (libname && !addr) {
					addr = addroflib (core, r_file_basename (libname));
					if (addr == UT64_MAX) {
						R_LOG_ERROR ("Unknown library, or not found in dm");
					}
				}
				map = get_closest_map (core, addr);
				if (map) {
					RCoreBinFilter filter;
					filter.offset = 0LL;
					filter.name = (char *)symname;
					baddr = map->addr;
					if (libname) {
						const char *file = map->file? map->file: map->name;
						char *newfile = NULL;
						if (!r_file_exists (file)) {
							newfile = r_file_temp ("memlib");
							if (newfile) {
								file = newfile;
								r_core_cmdf (core, "wtf %s 0x%" PFMT64x " @ 0x%" PFMT64x " 2> %s",
										file, map->size, baddr, R_SYS_DEVNULL);
							}
						}
						get_bin_info (core, file, baddr, pj, mode, symbols_only, &filter);
						if (newfile) {
							if (!r_file_rm (newfile)) {
								R_LOG_ERROR ("Cannot remove %s", newfile);
							}
							free (newfile);
						}
					} else {
						r_bin_set_baddr (core->bin, map->addr);
						r_core_bin_info (core, R_CORE_BIN_ACC_SYMBOLS, pj, input[1] == '*', true, &filter, NULL);
						r_bin_set_baddr (core->bin, baddr);
					}
				}
				if (mode == R_MODE_JSON) {
					r_cons_println (pj_string (pj));
					pj_free (pj);
				}
				free (ptr);
			}
			break;
		case '.': 
			if (r_config_get_b (core->config, "cfg.debug")) {
				ut64 addr = core->offset;
				r_list_foreach (core->dbg->maps, iter, map) {
					if (!map->shared) {
						continue;
					}
					if (addr >= map->addr && addr < map->addr_end) {
						r_cons_printf ("%s\n", map->name);
					}
				}
			} else {
				map = get_closest_map (core, addr);
				if (map) {
					ut64 closest_addr = UT64_MAX;
					RVecRBinSymbol *symbols = r_bin_get_symbols_vec (core->bin);
					RBinSymbol *symbol, *closest_symbol = NULL;
					R_VEC_FOREACH (symbols, symbol) {
						if (symbol->vaddr > addr) {
							if (symbol->vaddr - addr < closest_addr) {
								closest_addr = symbol->vaddr - addr;
								closest_symbol = symbol;
							}
						} else {
							if (addr - symbol->vaddr < closest_addr) {
								closest_addr = addr - symbol->vaddr;
								closest_symbol = symbol;
							}
						}
					}
					if (closest_symbol) {
						RCoreBinFilter filter;
						filter.offset = 0LL;
						filter.name = (char *) closest_symbol->name;
						r_bin_set_baddr (core->bin, map->addr);
						r_core_bin_info (core, R_CORE_BIN_ACC_SYMBOLS, NULL, false, true, &filter, NULL);
					}
				}
			}
			break;
		default:
			r_core_cmd_help (core, help_msg_dmi);
			break;
		}
		break;
	case 'S': 
		{ 
			const char *libname = NULL, *sectname = NULL, *mode = "";
			ut64 baddr = 0LL;
			char *ptr;
			int i;
			if (input[1] == '*') {
				ptr = strdup (r_str_trim_head_ro ((char*)input + 2));
				mode = "-r ";
			} else {
				ptr = strdup (r_str_trim_head_ro ((char*)input + 1));
			}
			i = r_str_word_set0 (ptr);
			addr = UT64_MAX;
			switch (i) {
			case 2: 
				sectname = r_str_word_get0 (ptr, 1);
			case 1: 
				if (IS_DIGIT (*ptr)) {
					const char *a0 = r_str_word_get0 (ptr, 0);
					addr = r_num_math (core->num, a0);
				} else {
					addr = UT64_MAX;
				}
				if (!addr || addr == UT64_MAX) {
					libname = r_str_word_get0 (ptr, 0);
				}
				break;
			}
			r_debug_map_sync (core->dbg); 
			RList *list = r_debug_modules_list (core->dbg);
			r_list_foreach (list, iter, map) {
				if ((!libname ||
					 (addr != UT64_MAX && (addr >= map->addr && addr < map->addr_end)) ||
					 (libname && (strstr (map->name, libname))))) {
					baddr = map->addr;
					char *res;
					const char *file = map->file? map->file: map->name;
					char *name = r_str_escape ((char *)r_file_basename (file));
					char *filesc = r_str_escape (file);
					if (sectname) {
						char *sect = r_str_escape (sectname);
						res  = r_sys_cmd_strf ("env RABIN2_PREFIX=\"%s\" rabin2 %s-B 0x%08"
							PFMT64x" -S \"%s\" | grep \"%s\"", name, mode, baddr, filesc, sect);
						free (sect);
					} else {
						res = r_sys_cmd_strf ("env RABIN2_PREFIX=\"%s\" rabin2 %s-B 0x%08"
							PFMT64x" -S \"%s\"", name, mode, baddr, filesc);
					}
					free (filesc);
					r_cons_println (res);
					free (name);
					free (res);
					if (libname || addr != UT64_MAX) { 
						break;
					}
				}
			}
			free (ptr);
		}
		break;
	case ' ': 
		{
			int size;
			char *p = strchr (input + 2, ' ');
			if (p) {
				*p++ = 0;
				addr = r_num_math (core->num, input + 1);
				size = r_num_math (core->num, p);
				r_debug_map_alloc (core->dbg, addr, size, false);
			} else {
				r_core_cmd_help_match (core, help_msg_dm, "dm");
				return false;
			}
		}
		break;
	case '-': 
		if (input[1] != ' ') {
			r_core_cmd_help_match (core, help_msg_dm, "dm-");
			break;
		}
		addr = r_num_math (core->num, input + 2);
		r_list_foreach (core->dbg->maps, iter, map) {
			if (addr >= map->addr && addr < map->addr_end) {
				r_debug_map_dealloc(core->dbg, map);
				r_debug_map_sync (core->dbg);
				return true;
			}
		}
		R_LOG_ERROR ("The address doesn't match with any map");
		break;
	case 'L': 
		{
			int size;
			char *p = strchr (input + 2, ' ');
			if (p) {
				*p++ = 0;
				addr = r_num_math (core->num, input + 1);
				size = r_num_math (core->num, p);
				r_debug_map_alloc (core->dbg, addr, size, true);
			} else {
				r_core_cmd_help_match (core, help_msg_dm, "dmL");
				return false;
			}
		}
		break;
	case '\0': 
	case '*': 
	case 'j': 
	case 'q': 
		if (r_config_get_b (core->config, "cfg.debug")) {
			r_debug_map_sync (core->dbg); 
			r_debug_map_list (core->dbg, core->offset, input);
		} else {
			R_LOG_WARN ("Memory Maps require to be (cfg.debug/-d) in debugger mode. Otherwise use 'om'");
		}
		break;
	case '=': 
		if (r_config_get_b (core->config, "cfg.debug")) {
			r_debug_map_sync (core->dbg);
			r_debug_map_list_visual (core->dbg, core->offset, input,
					r_config_get_i (core->config, "scr.color"));
		} else {
			R_LOG_WARN ("Memory Maps require to be (cfg.debug/-d) in debugger mode. Otherwise use 'om'");
		}
		break;
	case 'h': 
		return cmd_dmh (core, input);
	}
	return true;
}
