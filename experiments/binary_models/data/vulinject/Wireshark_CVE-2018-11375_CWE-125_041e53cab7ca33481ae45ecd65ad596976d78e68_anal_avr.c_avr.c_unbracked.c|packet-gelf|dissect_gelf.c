dissect_gelf(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean heur_check)
{
    guint16 header;
    guint captured_length;
    proto_item *it;
    captured_length = tvb_captured_length(tvb);
    header = tvb_get_ntohs(tvb, 0);
    if (heur_check) {
        guint min_len;
        guint8 number, count;
        switch(header) {
            case HEADER_GZIP:
                min_len = MIN_ZLIB_MSG;
                break;
            case HEADER_UNCOMPRESSED_PLAIN:
                min_len = MIN_PLAIN_MSG;
                break;
            case HEADER_UNCOMPRESSED:
                min_len = MIN_PLAIN_MSG + 2;
                break;
            case HEADER_CHUNKED:
                min_len = 10 + 2;
                break;
            default:
                if (is_simple_zlib(header)) {
                    min_len = MIN_ZLIB_MSG;
                } else {
                    return 0;
                }
                break;
        }
        if (tvb_reported_length(tvb) < min_len)
            return 0;
        if (header == HEADER_CHUNKED && captured_length >= 10) {
            number = tvb_get_guint8(tvb, 10);
            count = tvb_get_guint8(tvb, 11);
            if (number >= count)
                return 0;
        }
    }
    proto_item *ti = proto_tree_add_item(tree, proto_gelf, tvb, 0, -1, ENC_NA);
    proto_tree *gelf_tree = proto_item_add_subtree(ti, ett_gelf);
    proto_item *pdu_item = proto_tree_add_item(gelf_tree, hf_gelf_pdu_type, tvb, 0, 2, ENC_BIG_ENDIAN);
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "GELF");
    if (header == HEADER_CHUNKED) {
        guint32 number, count, short_id, data_len;
        GByteArray *bytes;
        char message_id[17];
        gboolean more_frags;
        fragment_head *fd_head;
        message_id[0] = '\0';
        bytes = g_byte_array_sized_new(8);
        it = proto_tree_add_boolean(gelf_tree, hf_gelf_pdu_chunked, tvb, 0, 2, TRUE);
        proto_item_set_generated(it);
        proto_tree_add_bytes_item(gelf_tree, hf_gelf_pdu_message_id, tvb, 2, 8, ENC_BIG_ENDIAN, bytes,
                                  NULL, NULL);
        proto_tree_add_item_ret_uint(gelf_tree, hf_gelf_pdu_chunk_number, tvb, 10, 1, ENC_BIG_ENDIAN,
                                     &number);
        proto_tree_add_item_ret_uint(gelf_tree, hf_gelf_pdu_chunk_count, tvb, 11, 1, ENC_BIG_ENDIAN,
                                     &count);
        bytes_to_hexstr(message_id, bytes->data, 8);
        message_id[16] = '\0';
        short_id = BUILD_MESSAGE_ID(bytes->data);
        g_byte_array_free(bytes, TRUE);
        col_add_fstr(pinfo->cinfo, COL_INFO, "Chunked packet: id: %s, number %u, count %u", message_id,
                     number, count);
        data_len = tvb_captured_length_remaining(tvb, 12);
        more_frags = (count == number + 1) ? FALSE : TRUE;
        fd_head = fragment_add_seq_check(&gelf_udp_reassembly_table, tvb, 12, pinfo, short_id, NULL, number,
                                         data_len, more_frags);
        if (fd_head != NULL) {
            tvbuff_t *newtvb;
            newtvb = process_reassembled_data(tvb, 12, pinfo, "Reassembled GELF", fd_head,
                                              &gelf_fragment_items, NULL, gelf_tree);
            if (newtvb != NULL) {
                guint16 newheader = tvb_get_ntohs(newtvb, 0);
                dissect_gelf_simple_udp(newtvb, pinfo, tree, newheader, pdu_item);
           }
        }
        return captured_length;
    } else {
        it = proto_tree_add_boolean(gelf_tree, hf_gelf_pdu_chunked, tvb, 0, 2, FALSE);
        proto_item_set_generated(it);
        switch(header) {
            case HEADER_GZIP:
                col_set_str(pinfo->cinfo, COL_INFO, "GZIP");
                break;
            case HEADER_UNCOMPRESSED_PLAIN:
                col_set_str(pinfo->cinfo, COL_INFO, "uncompressed plain");
                break;
            case HEADER_UNCOMPRESSED:
                col_set_str(pinfo->cinfo, COL_INFO, "uncompressed");
                break;
            default:
                if (is_simple_zlib(header)) {
                    col_set_str(pinfo->cinfo, COL_INFO, "ZLIB");
                } else {
                    expert_add_info_format(pinfo, pdu_item, &ei_gelf_invalid_header,
                                           "Invalid header magic");
                    return 0;
                }
                break;
        }
        return dissect_gelf_simple_udp(tvb, pinfo, tree, header, pdu_item);
    }
}
