getpass (const char *prompt)
{
  char getpassbuf[PASS_MAX + 1];
  size_t i = 0;
  int c;
  if (prompt)
    {
      fputs (prompt, stderr);
      fflush (stderr);
    }
  for (;;)
    {
      c = _getch ();
      if (c == '\r')
        {
          getpassbuf[i] = '\0';
          break;
        }
      else if (i < PASS_MAX)
        {
          getpassbuf[i++] = c;
        }
      if (i >= PASS_MAX)
        {
          getpassbuf[i] = '\0';
          break;
        }
    }
  if (prompt)
    {
      fputs ("\r\n", stderr);
      fflush (stderr);
    }
  return strdup (getpassbuf);
}
getpass (const char *prompt)
{
  FILE *tty;
  FILE *in, *out;
# if HAVE_TCGETATTR
  struct termios s, t;
# endif
  bool tty_changed = false;
  static char *buf;
  static size_t bufsize;
  ssize_t nread;
  tty = fopen ("/dev/tty", "w+e");
  if (tty == NULL)
    {
      in = stdin;
      out = stderr;
    }
  else
    {
      out = in = tty;
    }
  flockfile (out);
# if HAVE_TCGETATTR
  if (tcgetattr (fileno (in), &t) == 0)
    {
      s = t;
      t.c_lflag &= ~(ECHO | ISIG);
      tty_changed = (tcsetattr (fileno (in), TCSAFLUSH | TCSASOFT, &t) == 0);
    }
# endif
  if (prompt)
    {
      fputs_unlocked (prompt, out);
      fflush_unlocked (out);
    }
  nread = getline (&buf, &bufsize, in);
  fseeko (out, 0, SEEK_CUR);
  if (buf != NULL)
    {
      if (nread < 0)
        buf[0] = '\0';
      else if (buf[nread - 1] == '\n')
        {
          buf[nread - 1] = '\0';
          if (tty_changed)
            {
              putc_unlocked ('\n', out);
            }
        }
    }
# if HAVE_TCSETATTR
  if (tty_changed)
    tcsetattr (fileno (in), TCSAFLUSH | TCSASOFT, &s);
# endif
  funlockfile (out);
  call_fclose (tty);
  return buf;
}
