static void dtsec_link_up(struct phylink_config *config, struct phy_device *phy,
			  unsigned int mode, phy_interface_t interface,
			  int speed, int duplex, bool tx_pause, bool rx_pause)
{
	struct mac_device *mac_dev = fman_config_to_mac(config);
	struct fman_mac *dtsec = mac_dev->fman_mac;
	struct dtsec_regs __iomem *regs = dtsec->regs;
	unsigned short pause_time = tx_pause ? FSL_FM_PAUSE_TIME_ENABLE :
			 FSL_FM_PAUSE_TIME_DISABLE;
	unsigned int tmp;
	dtsec_accept_rx_pause_frames(dtsec, rx_pause);
	tmp = ioread32be(&regs->ecntrl);
	if (speed == SPEED_100)
		tmp |= DTSEC_ECNTRL_R100M;
	else
		tmp &= ~DTSEC_ECNTRL_R100M;
	iowrite32be(tmp, &regs->ecntrl);
	tmp = ioread32be(&regs->maccfg2);
	tmp &= ~(MACCFG2_NIBBLE_MODE | MACCFG2_BYTE_MODE | MACCFG2_FULL_DUPLEX);
	if (speed >= SPEED_1000)
		tmp |= MACCFG2_BYTE_MODE;
	else
		tmp |= MACCFG2_NIBBLE_MODE;
	if (duplex == DUPLEX_FULL)
		tmp |= MACCFG2_FULL_DUPLEX;
	iowrite32be(tmp, &regs->maccfg2);
	mac_dev->update_speed(mac_dev, speed);
	tmp = ioread32be(&regs->maccfg1);
	tmp |= MACCFG1_RX_EN | MACCFG1_TX_EN;
	iowrite32be(tmp, &regs->maccfg1);
	graceful_start(dtsec);
}
