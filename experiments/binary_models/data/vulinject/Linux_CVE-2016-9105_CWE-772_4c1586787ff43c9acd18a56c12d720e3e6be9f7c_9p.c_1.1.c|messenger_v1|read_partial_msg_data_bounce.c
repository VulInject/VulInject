static int read_partial_msg_data_bounce(struct ceph_connection *con)
{
	struct ceph_msg_data_cursor *cursor = &con->in_msg->cursor;
	struct page *page;
	size_t off, len;
	unsigned int crc;
	int ret;
	if (unlikely(!con->bounce_page)) {
		con->bounce_page = alloc_page(GFP_NOIO);
		if (!con->bounce_page) {
			pr_err("failed to allocate bounce page\n");
			return -ENOMEM;
		}
	}
	crc = con->in_data_crc;
	while (cursor->total_resid) {
		if (!cursor->resid) {
			ceph_msg_data_advance(cursor, 0);
			continue;
		}
		page = ceph_msg_data_next(cursor, &off, &len);
		ret = ceph_tcp_recvpage(con->sock, con->bounce_page, 0, len);
		if (ret <= 0) {
			con->in_data_crc = crc;
			return ret;
		}
		crc = crc32c(crc, page_address(con->bounce_page), ret);
		memcpy_to_page(page, off, page_address(con->bounce_page), ret);
	}
	con->in_data_crc = crc;
	return 1;	
}
