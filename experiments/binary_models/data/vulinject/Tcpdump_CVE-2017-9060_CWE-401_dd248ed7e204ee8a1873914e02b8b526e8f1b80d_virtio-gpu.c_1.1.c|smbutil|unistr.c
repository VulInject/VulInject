unistr(netdissect_options *ndo, char (*buf)[MAX_UNISTR_SIZE+1],
       const u_char *s, unsigned int strsize, int is_null_terminated,
       int use_unicode)
{
    u_int c;
    size_t l = 0;
    const u_char *sp;
    if (use_unicode) {
	if (((s - startbuf) % 2) != 0) {
	    s++;
	}
    }
    if (is_null_terminated) {
	strsize = 0;
	sp = s;
	if (!use_unicode) {
	    for (;;) {
		c = GET_U_1(sp);
		sp++;
		strsize++;
		if (c == '\0')
		    break;
	    }
	} else {
	    for (;;) {
		c = GET_LE_U_2(sp);
		sp += 2;
		strsize += 2;
		if (c == '\0')
		    break;
	    }
	}
    }
    if (!use_unicode) {
	while (strsize != 0) {
	    c = GET_U_1(s);
	    s++;
	    strsize--;
	    if (c == 0) {
		ND_TCHECK_LEN(s, strsize);
		s += strsize;
		strsize = 0;
		break;
	    }
	    if (l < MAX_UNISTR_SIZE) {
		if (ND_ASCII_ISPRINT(c)) {
		    (*buf)[l] = (char)c;
		} else {
		    (*buf)[l] = '.';
		}
		l++;
	    }
	}
    } else {
	while (strsize > 1) {
	    c = GET_LE_U_2(s);
	    s += 2;
	    strsize -= 2;
	    if (c == 0) {
		ND_TCHECK_LEN(s, strsize);
		s += strsize;
		strsize = 0;
		break;
	    }
	    if (l < MAX_UNISTR_SIZE) {
		if (ND_ASCII_ISPRINT(c)) {
		    (*buf)[l] = (char)c;
		} else {
		    (*buf)[l] = '.';
		}
		l++;
	    }
	}
	if (strsize == 1) {
	    ND_TCHECK_1(s);
	    s++;
	}
    }
    (*buf)[l] = 0;
    return s;
trunc:
    (*buf)[l] = 0;
    return NULL;
}
