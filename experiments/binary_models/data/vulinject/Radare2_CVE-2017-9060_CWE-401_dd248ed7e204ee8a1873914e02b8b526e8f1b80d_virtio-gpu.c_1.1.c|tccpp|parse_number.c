static void parse_number(TCCState *s1, const char *p) {
	int b, t, shift, frac_bits, s, exp_val, ch;
	char *q;
	unsigned int bn[BN_SIZE];
	double d;
	q = s1->token_buf;
	ch = *p++;
	t = ch;
	ch = *p++;
	*q++ = t;
	b = 10;
	if (t == '.') {
		goto float_frac_parse;
	} else if (t == '0') {
		if (ch == 'x' || ch == 'X') {
			q--;
			ch = *p++;
			b = 16;
		} else if (tcc_ext && (ch == 'b' || ch == 'B')) {
			q--;
			ch = *p++;
			b = 2;
		}
	}
	while (1) {
		if (ch >= 'a' && ch <= 'f') {
			t = ch - 'a' + 10;
		} else if (ch >= 'A' && ch <= 'F') {
			t = ch - 'A' + 10;
		} else if (isnum (ch)) {
			t = ch - '0';
		} else {
			break;
		}
		if (t >= b) {
			break;
		}
		if (q >= s1->token_buf + STRING_MAX_SIZE) {
num_too_long:
			tcc_error (s1, "number too int");
		}
		*q++ = ch;
		ch = *p++;
	}
	if (ch == '.' ||
	    ((ch == 'e' || ch == 'E') && b == 10) ||
	    ((ch == 'p' || ch == 'P') && (b == 16 || b == 2))) {
		if (b != 10) {
			*q = '\0';
			if (b == 16) {
				shift = 4;
			} else {
				shift = 2;
			}
			q = s1->token_buf;
			while (1) {
				t = *q++;
				if (t == '\0') {
					break;
				} else if (t >= 'a') {
					t = t - 'a' + 10;
				} else if (t >= 'A') {
					t = t - 'A' + 10;
				} else {
					t = t - '0';
				}
				bn_lshift (bn, shift, t);
			}
			frac_bits = 0;
			if (ch == '.') {
				ch = *p++;
				while (1) {
					t = ch;
					if (t >= 'a' && t <= 'f') {
						t = t - 'a' + 10;
					} else if (t >= 'A' && t <= 'F') {
						t = t - 'A' + 10;
					} else if (t >= '0' && t <= '9') {
						t = t - '0';
					} else {
						break;
					}
					if (t >= b) {
						tcc_error (s1, "invalid digit");
					}
					bn_lshift (bn, shift, t);
					frac_bits += shift;
					ch = *p++;
				}
			}
			if (ch != 'p' && ch != 'P') {
				expect (s1, "exponent");
				return;
			}
			ch = *p++;
			s = 1;
			exp_val = 0;
			if (ch == '+') {
				ch = *p++;
			} else if (ch == '-') {
				s = -1;
				ch = *p++;
			}
			if (ch < '0' || ch > '9') {
				expect (s1, "exponent digits");
				return;
			}
			while (ch >= '0' && ch <= '9') {
				exp_val = exp_val * 10 + ch - '0';
				ch = *p++;
			}
			exp_val = exp_val * s;
			d = (double) bn[1] * 4294967296.0 + (double) bn[0];
			d = ldexp (d, exp_val - frac_bits);
			t = toup (ch);
			if (t == 'F') {
				ch = *p++;
				s1->tok = TOK_CFLOAT;
				s1->tokc.f = (float) d;
			} else if (t == 'L') {
				ch = *p++;
#if 0 
				s1->tok = TOK_CDOUBLE;
				s1->tokc.d = d;
#else
				s1->tok = TOK_CLDOUBLE;
				s1->tokc.ld = (int double) d;
#endif
			} else {
				s1->tok = TOK_CDOUBLE;
				s1->tokc.d = d;
			}
		} else {
			if (ch == '.') {
				if (q >= s1->token_buf + STRING_MAX_SIZE) {
					goto num_too_long;
				}
				*q++ = ch;
				ch = *p++;
float_frac_parse:
				while (ch >= '0' && ch <= '9') {
					if (q >= s1->token_buf + STRING_MAX_SIZE) {
						goto num_too_long;
					}
					*q++ = ch;
					ch = *p++;
				}
			}
			if (ch == 'e' || ch == 'E') {
				if (q >= s1->token_buf + STRING_MAX_SIZE) {
					goto num_too_long;
				}
				*q++ = ch;
				ch = *p++;
				if (ch == '-' || ch == '+') {
					if (q >= s1->token_buf + STRING_MAX_SIZE) {
						goto num_too_long;
					}
					*q++ = ch;
					ch = *p++;
				}
				if (ch < '0' || ch > '9') {
					expect (s1, "exponent digits");
					return;
				}
				while (ch >= '0' && ch <= '9') {
					if (q >= s1->token_buf + STRING_MAX_SIZE) {
						goto num_too_long;
					}
					*q++ = ch;
					ch = *p++;
				}
			}
			*q = '\0';
			t = toup (ch);
			errno = 0;
			if (t == 'F') {
				ch = *p++;
				s1->tok = TOK_CFLOAT;
				s1->tokc.f = strtof (s1->token_buf, NULL);
			} else if (t == 'L') {
				ch = *p++;
				s1->tok = TOK_CDOUBLE;
				s1->tokc.d = strtod (s1->token_buf, NULL);
			} else {
				s1->tok = TOK_CDOUBLE;
				s1->tokc.d = strtod (s1->token_buf, NULL);
			}
		}
	} else {
		ut64 n, n1;
		int lcount, ucount;
		*q = '\0';
		q = s1->token_buf;
		if (b == 10 && *q == '0') {
			b = 8;
			q++;
		}
		n = 0;
		while (1) {
			t = *q++;
			if (t == '\0') {
				break;
			} else if (t >= 'a') {
				t = t - 'a' + 10;
			} else if (t >= 'A') {
				t = t - 'A' + 10;
			} else {
				t = t - '0';
				if (t >= b) {
					tcc_error (s1, "invalid digit");
				}
			}
			n1 = n;
			n = n * b + t;
			if (n < n1) {
				tcc_error (s1, "integer constant overflow");
			}
		}
		if ((n & 0xffffffff00000000ULL) != 0) {
			if ((n >> 63) != 0) {
				s1->tok = TOK_CULLONG;
			} else {
				s1->tok = TOK_CLLONG;
			}
		} else if (n > 0x7fffffff) {
			s1->tok = TOK_CUINT;
		} else {
			s1->tok = TOK_CINT;
		}
		lcount = 0;
		ucount = 0;
		for (;;) {
			t = toup (ch);
			if (t == 'L') {
				if (lcount >= 2) {
					tcc_error (s1, "three 'l's in integer constant");
				}
				lcount++;
				if (s1->tok == TOK_CINT) {
					s1->tok = TOK_CLLONG;
				} else if (s1->tok == TOK_CUINT) {
					s1->tok = TOK_CULLONG;
				}
				ch = *p++;
			} else if (t == 'U') {
				if (ucount >= 1) {
					tcc_error (s1, "two 'u's in integer constant");
				}
				ucount++;
				if (s1->tok == TOK_CINT) {
					s1->tok = TOK_CUINT;
				} else if (s1->tok == TOK_CLLONG) {
					s1->tok = TOK_CULLONG;
				}
				ch = *p++;
			} else {
				break;
			}
		}
		if (s1->tok == TOK_CINT || s1->tok == TOK_CUINT) {
			s1->tokc.ui = n;
		} else {
			s1->tokc.ull = n;
		}
	}
	if (ch) {
		tcc_error (s1, "invalid number\n");
	}
}
