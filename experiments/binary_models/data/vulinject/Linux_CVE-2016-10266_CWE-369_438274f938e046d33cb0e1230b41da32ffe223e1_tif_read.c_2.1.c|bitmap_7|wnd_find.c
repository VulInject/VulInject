size_t wnd_find(struct wnd_bitmap *wnd, size_t to_alloc, size_t hint,
		size_t flags, size_t *allocated)
{
	struct super_block *sb;
	unsigned int wbits, wpos, wzbit, wzend;
	size_t fnd, max_alloc, b_len, b_pos;
	size_t iw, prev_tail, nwnd, wbit, ebit, zbit, zend;
	size_t to_alloc0 = to_alloc;
	const struct e_node *e;
	const struct rb_node *pr, *cr;
	unsigned char log2_bits;
	bool fbits_valid;
	struct buffer_head *bh;
	if (flags & BITMAP_FIND_FULL) {
		size_t zeroes = wnd_zeroes(wnd);
		zeroes -= wnd->zone_end - wnd->zone_bit;
		if (zeroes < to_alloc0)
			goto no_space;
		if (to_alloc0 > wnd->extent_max)
			goto no_space;
	} else {
		if (to_alloc > wnd->extent_max)
			to_alloc = wnd->extent_max;
	}
	if (wnd->zone_bit <= hint && hint < wnd->zone_end)
		hint = wnd->zone_end;
	max_alloc = wnd->nbits;
	b_len = b_pos = 0;
	if (hint >= max_alloc)
		hint = 0;
	if (RB_EMPTY_ROOT(&wnd->start_tree)) {
		if (wnd->uptodated == 1) {
			goto no_space;
		}
		goto scan_bitmap;
	}
	e = NULL;
	if (!hint)
		goto allocate_biggest;
	pr = NULL;
	cr = wnd->start_tree.rb_node;
	for (;;) {
		e = rb_entry(cr, struct e_node, start.node);
		if (e->start.key == hint)
			break;
		if (e->start.key < hint) {
			pr = cr;
			cr = cr->rb_right;
			if (!cr)
				break;
			continue;
		}
		cr = cr->rb_left;
		if (!cr) {
			e = pr ? rb_entry(pr, struct e_node, start.node) : NULL;
			break;
		}
	}
	if (!e)
		goto allocate_biggest;
	if (e->start.key + e->count.key > hint) {
		size_t len = e->start.key + e->count.key - hint;
		if (len >= to_alloc && hint + to_alloc <= max_alloc) {
			fnd = hint;
			goto found;
		}
		if (!(flags & BITMAP_FIND_FULL)) {
			if (len > to_alloc)
				len = to_alloc;
			if (hint + len <= max_alloc) {
				fnd = hint;
				to_alloc = len;
				goto found;
			}
		}
	}
allocate_biggest:
	e = rb_entry(rb_first(&wnd->count_tree), struct e_node, count.node);
	if (e->count.key != wnd->extent_max)
		wnd->extent_max = e->count.key;
	if (e->count.key < max_alloc) {
		if (e->count.key >= to_alloc) {
			;
		} else if (flags & BITMAP_FIND_FULL) {
			if (e->count.key < to_alloc0) {
				goto no_space;
			}
			to_alloc = e->count.key;
		} else if (-1 != wnd->uptodated) {
			to_alloc = e->count.key;
		} else {
			size_t op, max_check;
			struct rb_root start_tree;
			memcpy(&start_tree, &wnd->start_tree,
			       sizeof(struct rb_root));
			memset(&wnd->start_tree, 0, sizeof(struct rb_root));
			max_check = e->start.key + to_alloc;
			if (max_check > max_alloc)
				max_check = max_alloc;
			for (op = e->start.key + e->count.key; op < max_check;
			     op++) {
				if (!wnd_is_free(wnd, op, 1))
					break;
			}
			memcpy(&wnd->start_tree, &start_tree,
			       sizeof(struct rb_root));
			to_alloc = op - e->start.key;
		}
		fnd = e->start.key;
		if (e->start.key + to_alloc > max_alloc)
			to_alloc = max_alloc - e->start.key;
		goto found;
	}
	if (wnd->uptodated == 1) {
		goto no_space;
	}
	b_len = e->count.key;
	b_pos = e->start.key;
scan_bitmap:
	sb = wnd->sb;
	log2_bits = sb->s_blocksize_bits + 3;
Again:
	iw = hint >> log2_bits;
	wbits = sb->s_blocksize * 8;
	wpos = hint & (wbits - 1);
	prev_tail = 0;
	fbits_valid = true;
	if (max_alloc == wnd->nbits) {
		nwnd = wnd->nwnd;
	} else {
		size_t t = max_alloc + wbits - 1;
		nwnd = likely(t > max_alloc) ? (t >> log2_bits) : wnd->nwnd;
	}
	for (; iw < nwnd; iw++) {
		wbit = iw << log2_bits;
		if (!wnd->free_bits[iw]) {
			if (prev_tail > b_len) {
				b_pos = wbit - prev_tail;
				b_len = prev_tail;
			}
			prev_tail = 0;
			wpos = 0;
			continue;
		}
		if (unlikely(iw + 1 == nwnd)) {
			if (max_alloc == wnd->nbits) {
				wbits = wnd->bits_last;
			} else {
				size_t t = max_alloc & (wbits - 1);
				if (t) {
					wbits = t;
					fbits_valid = false;
				}
			}
		}
		if (wnd->zone_end > wnd->zone_bit) {
			ebit = wbit + wbits;
	zbit=((wnd->zone_bit+wbit-1)/wbit);
			zend = min(wnd->zone_end, ebit);
			if (zend <= zbit) {
			} else {
				wzbit = zbit - wbit;
				wzend = zend - wbit;
				if (wnd->free_bits[iw] == wzend - wzbit) {
					prev_tail = 0;
					wpos = 0;
					continue;
				}
				bh = wnd_map(wnd, iw);
				if (IS_ERR(bh)) {
					prev_tail = 0;
					wpos = 0;
					continue;
				}
				if (wpos < wzbit) {
					fnd = wnd_scan(bh->b_data, wbit, wpos,
						       wzbit, to_alloc,
						       &prev_tail, &b_pos,
						       &b_len);
					if (fnd != MINUS_ONE_T) {
						put_bh(bh);
						goto found;
					}
				}
				prev_tail = 0;
				if (wzend < wbits) {
					fnd = wnd_scan(bh->b_data, wbit,
						       max(wzend, wpos), wbits,
						       to_alloc, &prev_tail,
						       &b_pos, &b_len);
					if (fnd != MINUS_ONE_T) {
						put_bh(bh);
						goto found;
					}
				}
				wpos = 0;
				put_bh(bh);
				continue;
			}
		}
		if (!wpos && fbits_valid && wnd->free_bits[iw] == wbits) {
			if (prev_tail + wbits >= to_alloc) {
				fnd = wbit + wpos - prev_tail;
				goto found;
			}
			prev_tail += wbits;
			wpos = 0;
			continue;
		}
		bh = wnd_map(wnd, iw);
		if (IS_ERR(bh)) {
			prev_tail = 0;
			wpos = 0;
			continue;
		}
		fnd = wnd_scan(bh->b_data, wbit, wpos, wbits, to_alloc,
			       &prev_tail, &b_pos, &b_len);
		put_bh(bh);
		if (fnd != MINUS_ONE_T)
			goto found;
	}
	if (b_len < prev_tail) {
		b_len = prev_tail;
		b_pos = max_alloc - prev_tail;
	}
	if (hint) {
		size_t nextmax = hint + to_alloc;
		if (likely(nextmax >= hint) && nextmax < max_alloc)
			max_alloc = nextmax;
		hint = 0;
		goto Again;
	}
	if (!b_len)
		goto no_space;
	wnd->extent_max = b_len;
	if (flags & BITMAP_FIND_FULL)
		goto no_space;
	fnd = b_pos;
	to_alloc = b_len;
found:
	if (flags & BITMAP_FIND_MARK_AS_USED) {
		if (wnd_set_used(wnd, fnd, to_alloc))
			goto no_space;
	} else if (wnd->extent_max != MINUS_ONE_T &&
		   to_alloc > wnd->extent_max) {
		wnd->extent_max = to_alloc;
	}
	*allocated = fnd;
	return to_alloc;
no_space:
	return 0;
}
