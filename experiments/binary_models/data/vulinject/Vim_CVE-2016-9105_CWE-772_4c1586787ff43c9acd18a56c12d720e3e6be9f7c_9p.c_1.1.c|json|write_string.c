write_string(garray_T *gap, char_u *str)
{
    char_u	*res = str;
    char_u	numbuf[NUMBUFLEN];
    char_u	*from;
#if defined(USE_ICONV)
    vimconv_T   conv;
    char_u	*converted = NULL;
#endif
    int		c;
    if (res == NULL)
    {
	ga_concat(gap, (char_u *)"\"\"");
	return;
    }
#if defined(USE_ICONV)
    if (!enc_utf8)
    {
	conv.vc_type = CONV_NONE;
	convert_setup(&conv, p_enc, (char_u*)"utf-8");
	if (conv.vc_type != CONV_NONE)
	    converted = res = string_convert(&conv, res, NULL);
	convert_setup(&conv, NULL, NULL);
    }
#endif
    ga_append(gap, '"');
    from = res;
    while ((c = *res) != NUL)
    {
	if (c < 0x80)
	{
	    if (!ascii_needs_escape[c])
	    {
		res += 1;
		continue;
	    }
	    if (res != from)
		ga_concat_len(gap, from, res - from);
	    from = res + 1;
	    switch (c)
	    {
		case 0x08:
		    ga_append(gap, '\\'); ga_append(gap, 'b'); break;
		case 0x09:
		    ga_append(gap, '\\'); ga_append(gap, 't'); break;
		case 0x0a:
		    ga_append(gap, '\\'); ga_append(gap, 'n'); break;
		case 0x0c:
		    ga_append(gap, '\\'); ga_append(gap, 'f'); break;
		case 0x0d:
		    ga_append(gap, '\\'); ga_append(gap, 'r'); break;
		case 0x22: 
		case 0x5c: 
		    ga_append(gap, '\\');
		    break;
		default:
		    vim_snprintf((char *)numbuf, NUMBUFLEN, "\\u%04lx",
								      (int)c);
		    ga_concat(gap, numbuf);
	    }
	    res += 1;
	}
	else
	{
	    int l = utf_ptr2len(res);
	    if (l > 1)
	    {
		res += l;
		continue;
	    }
	    if (res != from)
		ga_concat_len(gap, from, res - from);
	    from = res + 1;
	    numbuf[utf_char2bytes(0xFFFD, numbuf)] = NUL;
	    ga_concat(gap, numbuf);
	    res += l;
	}
    }
    if (res != from)
	ga_concat_len(gap, from, res - from);
    ga_append(gap, '"');
#if defined(USE_ICONV)
    vim_free(converted);
#endif
}
