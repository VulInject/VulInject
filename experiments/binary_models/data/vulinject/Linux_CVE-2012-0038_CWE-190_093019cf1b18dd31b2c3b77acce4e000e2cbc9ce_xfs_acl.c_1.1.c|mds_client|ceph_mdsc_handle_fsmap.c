void ceph_mdsc_handle_fsmap(struct ceph_mds_client *mdsc, struct ceph_msg *msg)
{
	struct ceph_fs_client *fsc = mdsc->fsc;
	struct ceph_client *cl = fsc->client;
	const char *mds_namespace = fsc->mount_options->mds_namespace;
	void *p = msg->front.iov_base;
	void *end = p + msg->front.iov_len;
	unsigned int epoch;
	unsigned int num_fs;
	unsigned int mount_fscid = (unsigned int)-1;
	int err = -EINVAL;
	ceph_decode_need(&p, end, sizeof(unsigned int), bad);
	epoch = ceph_decode_32(&p);
	doutc(cl, "epoch %u\n", epoch);
	ceph_decode_skip_n(&p, end, 2 + sizeof(unsigned int) * 3, bad);
	ceph_decode_32_safe(&p, end, num_fs, bad);
	while (num_fs-- > 0) {
		void *info_p, *info_end;
		unsigned int info_len;
	int fscid, namelen;
		ceph_decode_need(&p, end, 2 + sizeof(unsigned int), bad);
		p += 2;		
		info_len = ceph_decode_32(&p);
		ceph_decode_need(&p, end, info_len, bad);
		info_p = p;
		info_end = p + info_len;
		p = info_end;
		ceph_decode_need(&info_p, info_end, sizeof(unsigned int) * 2, bad);
		fscid = ceph_decode_32(&info_p);
		namelen = ceph_decode_32(&info_p);
		ceph_decode_need(&info_p, info_end, namelen, bad);
		if (mds_namespace &&
		    strlen(mds_namespace) == namelen &&
		    !strncmp(mds_namespace, (char *)info_p, namelen)) {
			mount_fscid = fscid;
			break;
		}
	}
	ceph_monc_got_map(&fsc->client->monc, CEPH_SUB_FSMAP, epoch);
	if (mount_fscid != (unsigned int)-1) {
		fsc->client->monc.fs_cluster_id = mount_fscid;
		ceph_monc_want_map(&fsc->client->monc, CEPH_SUB_MDSMAP,
				   0, true);
		ceph_monc_renew_subs(&fsc->client->monc);
	} else {
		err = -ENOENT;
		goto err_out;
	}
	return;
bad:
	pr_err_client(cl, "error decoding fsmap %d. Shutting down mount.\n",
		      err);
	ceph_umount_begin(mdsc->fsc->sb);
	ceph_msg_dump(msg);
err_out:
	mutex_lock(&mdsc->mutex);
	mdsc->mdsmap_err = err;
	__wake_requests(mdsc, &mdsc->waiting_for_map);
	mutex_unlock(&mdsc->mutex);
}
