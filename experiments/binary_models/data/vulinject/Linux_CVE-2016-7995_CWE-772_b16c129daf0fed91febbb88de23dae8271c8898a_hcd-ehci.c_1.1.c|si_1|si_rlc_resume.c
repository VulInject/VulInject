static int si_rlc_resume(struct radeon_device *rdev)
{
	unsigned int i;
	if (!rdev->rlc_fw)
		return -EINVAL;
	si_rlc_stop(rdev);
	si_rlc_reset(rdev);
	si_init_pg(rdev);
	si_init_cg(rdev);
	WREG32(RLC_RL_BASE, 0);
	WREG32(RLC_RL_SIZE, 0);
	WREG32(RLC_LB_CNTL, 0);
	WREG32(RLC_LB_CNTR_MAX, 0xffffffff);
	WREG32(RLC_LB_CNTR_INIT, 0);
	WREG32(RLC_LB_INIT_CU_MASK, 0xffffffff);
	WREG32(RLC_MC_CNTL, 0);
	WREG32(RLC_UCODE_CNTL, 0);
	if (rdev->new_fw) {
		const struct rlc_firmware_header_v1_0 *hdr =
			(const struct rlc_firmware_header_v1_0 *)rdev->rlc_fw->data;
		unsigned int fw_size = le32_to_cpu(hdr->header.ucode_size_bytes) / 4;
		const __le32 *fw_data = (const __le32 *)
			(rdev->rlc_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));
		for (i = 0; i < fw_size; i++) {
			WREG32(RLC_UCODE_ADDR, i);
			WREG32(RLC_UCODE_DATA, le32_to_cpup(fw_data++));
		}
	} else {
		const __be32 *fw_data =
			(const __be32 *)rdev->rlc_fw->data;
		for (i = 0; i < SI_RLC_UCODE_SIZE; i++) {
			WREG32(RLC_UCODE_ADDR, i);
			WREG32(RLC_UCODE_DATA, be32_to_cpup(fw_data++));
		}
	}
	WREG32(RLC_UCODE_ADDR, 0);
	si_enable_lbpw(rdev, si_lbpw_supported(rdev));
	si_rlc_start(rdev);
	return 0;
}
