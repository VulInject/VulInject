static int smsc95xx_bind(struct usbnet *dev, struct usb_interface *intf)
{
	struct smsc95xx_priv *pdata;
	char usb_path[64];
	int ret, phy_irq;
	unsigned int val;
	printk(KERN_INFO SMSC_CHIPNAME " v" SMSC_DRIVER_VERSION "\n");
	ret = usbnet_get_endpoints(dev, intf);
	if (ret < 0) {
		netdev_warn(dev->net, "usbnet_get_endpoints failed: %d\n", ret);
		return ret;
	}
	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
	if (!pdata)
		return -ENOMEM;
	dev->driver_priv = pdata;
	if (DEFAULT_TX_CSUM_ENABLE)
		dev->net->features |= NETIF_F_IP_CSUM;
	if (DEFAULT_RX_CSUM_ENABLE)
		dev->net->features |= NETIF_F_RXCSUM;
	dev->net->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM;
	set_bit(EVENT_NO_IP_ALIGN, &dev->flags);
	smsc95xx_init_mac_address(dev);
	ret = smsc95xx_reset(dev);
	if (ret)
		goto free_pdata;
	usb_make_path(dev->udev, usb_path, sizeof(usb_path));
	pdata->irqfwnode = irq_domain_alloc_named_fwnode(usb_path);
	if (!pdata->irqfwnode) {
		ret = -ENOMEM;
		goto free_pdata;
	}
	pdata->irqdomain = irq_domain_create_linear(pdata->irqfwnode,
						    SMSC95XX_NR_IRQS,
						    &irq_domain_simple_ops,
						    pdata);
	if (!pdata->irqdomain) {
		ret = -ENOMEM;
		goto free_irqfwnode;
	}
	phy_irq = irq_create_mapping(pdata->irqdomain, PHY_HWIRQ);
	if (!phy_irq) {
		ret = -ENOENT;
		goto remove_irqdomain;
	}
	pdata->irqchip = dummy_irq_chip;
	pdata->irqchip.name = SMSC_CHIPNAME;
	irq_set_chip_and_handler_name(phy_irq, &pdata->irqchip,
				      handle_simple_irq, "phy");
	pdata->mdiobus = mdiobus_alloc();
	if (!pdata->mdiobus) {
		ret = -ENOMEM;
		goto dispose_irq;
	}
	ret = smsc95xx_read_reg(dev, HW_CFG, &val);
	if (ret < 0)
		goto free_mdio;
	pdata->is_internal_phy = !(val & HW_CFG_PSEL_);
	if (pdata->is_internal_phy)
		pdata->mdiobus->phy_mask = ~(1u << SMSC95XX_INTERNAL_PHY_ID);
	pdata->mdiobus->priv = dev;
	pdata->mdiobus->read = smsc95xx_mdiobus_read;
	pdata->mdiobus->write = smsc95xx_mdiobus_write;
	pdata->mdiobus->reset = smsc95xx_mdiobus_reset;
	pdata->mdiobus->name = "smsc95xx-mdiobus";
	pdata->mdiobus->parent = &dev->udev->dev;
	snprintf(pdata->mdiobus->id, ARRAY_SIZE(pdata->mdiobus->id),
		 "usb-%03d:%03d", dev->udev->bus->busnum, dev->udev->devnum);
	ret = mdiobus_register(pdata->mdiobus);
	if (ret) {
		netdev_err(dev->net, "Could not register MDIO bus\n");
		goto free_mdio;
	}
	pdata->phydev = phy_find_first(pdata->mdiobus);
	if (!pdata->phydev) {
		netdev_err(dev->net, "no PHY found\n");
		ret = -ENODEV;
		goto unregister_mdio;
	}
	pdata->phydev->irq = phy_irq;
	pdata->phydev->is_internal = pdata->is_internal_phy;
	ret = smsc95xx_read_reg(dev, ID_REV, &val);
	if (ret < 0)
		goto unregister_mdio;
	val >>= 16;
	if ((val == ID_REV_CHIP_ID_9500A_) || (val == ID_REV_CHIP_ID_9530_) ||
	    (val == ID_REV_CHIP_ID_89530_) || (val == ID_REV_CHIP_ID_9730_))
		pdata->features = (FEATURE_8_WAKEUP_FILTERS |
			FEATURE_PHY_NLP_CROSSOVER |
			FEATURE_REMOTE_WAKEUP);
	else if (val == ID_REV_CHIP_ID_9512_)
		pdata->features = FEATURE_8_WAKEUP_FILTERS;
	dev->net->netdev_ops = &smsc95xx_netdev_ops;
	dev->net->ethtool_ops = &smsc95xx_ethtool_ops;
	dev->net->flags |= IFF_MULTICAST;
	dev->net->hard_header_len += SMSC95XX_TX_OVERHEAD_CSUM;
	dev->net->min_mtu = ETH_MIN_MTU;
	dev->net->max_mtu = ETH_DATA_LEN;
	dev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;
	ret = phy_connect_direct(dev->net, pdata->phydev,
				 &smsc95xx_handle_link_change,
				 PHY_INTERFACE_MODE_MII);
	if (ret) {
		netdev_err(dev->net, "can't attach PHY to %s\n", pdata->mdiobus->id);
		goto unregister_mdio;
	}
	phy_attached_info(dev->net->phydev);
	return 0;
unregister_mdio:
	mdiobus_unregister(pdata->mdiobus);
free_mdio:
	mdiobus_free(pdata->mdiobus);
dispose_irq:
	irq_dispose_mapping(phy_irq);
remove_irqdomain:
	irq_domain_remove(pdata->irqdomain);
free_irqfwnode:
	irq_domain_free_fwnode(pdata->irqfwnode);
free_pdata:
	kfree(pdata);
	return ret;
}
