static int qp_alloc_res(struct mlx4_dev *dev, int slave, int op, int cmd,
			unsigned int int in_param, unsigned int int *out_param)
{
	int err;
	int count;
	int align;
	int base;
	int qpn;
	unsigned char flags;
	switch (op) {
	case RES_OP_RESERVE:
		count = get_param_l(&in_param) & 0xffffff;
		flags = (get_param_l(&in_param) >> 24) & dev->caps.alloc_res_qp_mask;
		align = get_param_h(&in_param);
		err = mlx4_grant_resource(dev, slave, RES_QP, count, 0);
		if (err)
			return err;
		err = __mlx4_qp_reserve_range(dev, count, align, &base, flags);
		if (err) {
			mlx4_release_resource(dev, slave, RES_QP, count, 0);
			return err;
		}
		err = add_res_range(dev, slave, base, count, RES_QP, 0);
		if (err) {
			mlx4_release_resource(dev, slave, RES_QP, count, 0);
			__mlx4_qp_release_range(dev, base, count);
			return err;
		}
		break;
	case RES_OP_MAP_ICM:
		qpn = get_param_l(&in_param) & 0x7fffff;
		if (valid_reserved(dev, slave, qpn)) {
			err = add_res_range(dev, slave, qpn, 1, RES_QP, 0);
			if (err)
				return err;
		}
		err = qp_res_start_move_to(dev, slave, qpn, RES_QP_MAPPED,
					   NULL, 1);
		if (err)
			return err;
		if (!fw_reserved(dev, qpn)) {
			err = __mlx4_qp_alloc_icm(dev, qpn);
			if (err) {
				res_abort_move(dev, slave, RES_QP, qpn);
				return err;
			}
		}
		res_end_move(dev, slave, RES_QP, qpn);
		break;
	default:
		err = -EINVAL;
		break;
	}
	return err;
}
