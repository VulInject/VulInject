static RDebugMap* linux_map_alloc(RDebug *dbg, ut64 addr, int size, bool thp) {
	RBuffer *buf = NULL;
	RDebugMap* map = NULL;
	char code[1024], *sc_name;
	int num;
	char *asm_list[] = {
			"x86", "x86.as",
			"x64", "x86.as",
			NULL};
#if 0
NOTE: Since kernel 2.4,  that  system  call  has  been  superseded  by
mmap2(2 and  nowadays  the  glibc  mmap()  wrapper  function invokes
mmap2(2)). If arch is x86_32 then usage mmap2() */
#endif
	if (!strcmp (dbg->arch, "x86") && dbg->bits == 4) {
		sc_name = "mmap2";
	} else {
		sc_name = "mmap";
	}
	num = r_syscall_get_num (dbg->anal->syscall, sc_name);
#ifndef MAP_ANONYMOUS
#define MAP_ANONYMOUS 0x20
#endif
	snprintf (code, sizeof (code),
		"sc_mmap@syscall(%d);\n"
		"main@naked(0) { .rarg0 = sc_mmap(0x%08"PFMT64x",%d,%d,%d,%d,%d);break;\n"
		"}\n",
		num, addr, size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
	r_egg_reset (dbg->egg);
	r_egg_setup (dbg->egg, dbg->arch, 8 * dbg->bits, 0, 0);
	r_egg_load (dbg->egg, code, 0);
	if (!r_egg_compile (dbg->egg)) {
		R_LOG_ERROR ("Cannot compile");
		goto err_linux_map_alloc;
	}
	if (!r_egg_assemble_asm (dbg->egg, asm_list)) {
		R_LOG_ERROR ("r_egg_assemble: invalid assembly");
		goto err_linux_map_alloc;
	}
	buf = r_egg_get_bin (dbg->egg);
	if (buf) {
		ut64 map_addr;
		r_reg_arena_push (dbg->reg);
		ut64 tmpsz;
		const ut8 *tmp = r_buf_data (buf, &tmpsz);
		if (!r_debug_execute (dbg, tmp, tmpsz, &map_addr, true, false)) {
			R_LOG_ERROR ("Failed to execute code");
			goto err_linux_map_alloc;
		}
		r_reg_arena_pop (dbg->reg);
		if (map_addr < UT64_MAX) {
			if (thp) {
				if (!linux_map_thp (dbg, map_addr, size)) {
					R_LOG_WARN ("map promotion to huge page failed");
				}
			}
			map = r_debug_map_get (dbg, map_addr);
		}
	}
err_linux_map_alloc:
	return map;
}
