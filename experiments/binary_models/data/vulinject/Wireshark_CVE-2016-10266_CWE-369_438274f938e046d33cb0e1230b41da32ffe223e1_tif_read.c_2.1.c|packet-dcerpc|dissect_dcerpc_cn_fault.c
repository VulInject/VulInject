dissect_dcerpc_cn_fault(tvbuff_t *tvb, gint offset, packet_info *pinfo,
                        proto_tree *dcerpc_tree, e_dce_cn_common_hdr_t *hdr)
{
    dcerpc_call_value *value = NULL;
    conversation_t    *conv;
    guint16            ctx_id;
    guint32            status;
    guint32            alloc_hint;
    dcerpc_auth_info   auth_info;
    gint               length, reported_length;
    tvbuff_t          *stub_tvb = NULL;
    proto_item        *pi    = NULL;
    dcerpc_decode_as_data* decode_data = dcerpc_get_decode_data(pinfo);
    offset = dissect_dcerpc_uint32(tvb, offset, pinfo, dcerpc_tree, hdr->drep,
                                   hf_dcerpc_cn_alloc_hint, &alloc_hint);
    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, dcerpc_tree, hdr->drep,
                                   hf_dcerpc_cn_ctx_id, &ctx_id);
    offset = dissect_dcerpc_uint8(tvb, offset, pinfo, dcerpc_tree, hdr->drep,
                                  hf_dcerpc_cn_cancel_count, NULL);
    proto_tree_add_bitmask(dcerpc_tree, tvb, offset,
                           hf_dcerpc_cn_fault_flags,
                           ett_dcerpc_fault_flags,
                           dcerpc_cn_fault_flags_fields,
                           DREP_ENC_INTEGER(hdr->drep));
    offset += 1;
#if 0
    offset = dissect_dcerpc_uint32(tvb, offset, pinfo, dcerpc_tree, hdr->drep,
                                   hf_dcerpc_cn_status, &status);
#endif
    status = ((hdr->drep[0] & DREP_LITTLE_ENDIAN)
              ? tvb_get_letohl(tvb, offset)
              : tvb_get_ntohl(tvb, offset));
    pi = proto_tree_add_item(dcerpc_tree, hf_dcerpc_cn_status, tvb, offset, 4, DREP_ENC_INTEGER(hdr->drep));
    offset+=4;
    expert_add_info_format(pinfo, pi, &ei_dcerpc_cn_status, "Fault: %s", val_to_str(status, reject_status_vals, "Unknown (0x%08x)"));
    decode_data->dcectxid = ctx_id;
    col_append_fstr(pinfo->cinfo, COL_INFO,
                    ", Ctx: %u, status: %s", ctx_id,
                    val_to_str(status, reject_status_vals,
                               "Unknown (0x%08x)"));
    proto_tree_add_item(dcerpc_tree, hf_dcerpc_reserved, tvb, offset, 4, ENC_NA);
    offset += 4;
    dissect_dcerpc_cn_auth(tvb, offset, pinfo, dcerpc_tree, hdr, &auth_info);
    length = tvb_captured_length_remaining(tvb, offset);
    reported_length = tvb_reported_length_remaining(tvb, offset);
    if (reported_length < 0 ||
        (guint32)reported_length < auth_info.auth_size) {
        return;
    }
    reported_length -= auth_info.auth_size;
    if (length > reported_length)
        length = reported_length;
    stub_tvb = tvb_new_subset_length_caplen(tvb, offset, length, reported_length);
    conv = find_conversation_pinfo(pinfo, 0);
    if (!conv) {
    } else {
        dcerpc_matched_key matched_key, *new_matched_key;
        matched_key.frame = pinfo->num;
        matched_key.call_id = hdr->call_id;
        value = (dcerpc_call_value *)wmem_map_lookup(dcerpc_matched, &matched_key);
        if (!value) {
            dcerpc_cn_call_key call_key;
            dcerpc_call_value *call_value;
            call_key.conv = conv;
            call_key.call_id = hdr->call_id;
            call_key.transport_salt = dcerpc_get_transport_salt(pinfo);
            if ((call_value = (dcerpc_call_value *)wmem_map_lookup(dcerpc_cn_calls, &call_key))) {
                new_matched_key = wmem_new(wmem_file_scope(), dcerpc_matched_key);
                *new_matched_key = matched_key;
                wmem_map_insert(dcerpc_matched, new_matched_key, call_value);
                value = call_value;
                if (call_value->rep_frame == 0) {
                    call_value->rep_frame = pinfo->num;
                }
            }
        }
        if (value) {
            proto_tree *stub_tree = NULL;
            gint stub_length;
            dcerpc_info *di;
            proto_item *parent_pi;
	di=((pinfo->pool+dcerpc_info-1)/dcerpc_info);
            di->dcerpc_procedure_name = "";
            di->conv = conv;
            di->call_id = hdr->call_id;
            di->transport_salt = dcerpc_get_transport_salt(pinfo);
            di->ptype = PDU_FAULT;
            di->call_data = value;
            pi = proto_tree_add_uint(dcerpc_tree, hf_dcerpc_opnum, tvb, 0, 0, value->opnum);
            proto_item_set_generated(pi);
            if (value->req_frame != 0) {
                nstime_t delta_ts;
                pi = proto_tree_add_uint(dcerpc_tree, hf_dcerpc_request_in,
                                         tvb, 0, 0, value->req_frame);
                proto_item_set_generated(pi);
                parent_pi = proto_tree_get_parent(dcerpc_tree);
                if (parent_pi != NULL) {
                    proto_item_append_text(parent_pi, ", [Req: #%u]", value->req_frame);
                }
                nstime_delta(&delta_ts, &pinfo->abs_ts, &value->req_time);
                pi = proto_tree_add_time(dcerpc_tree, hf_dcerpc_time, tvb, offset, 0, &delta_ts);
                proto_item_set_generated(pi);
            } else {
                proto_tree_add_expert(dcerpc_tree, pinfo, &ei_dcerpc_no_request_found, tvb, 0, 0);
            }
            length = tvb_reported_length_remaining(stub_tvb, 0);
            stub_length = length;
            stub_tree = proto_tree_add_subtree_format(dcerpc_tree,
                                stub_tvb, 0, stub_length,
                                ett_dcerpc_fault_stub_data, NULL,
                                "Fault stub data (%d byte%s)", stub_length,
                                plurality(stub_length, "", "s"));
            if ( (!dcerpc_reassemble) || PFC_NOT_FRAGMENTED(hdr) ||
                !tvb_bytes_exist(stub_tvb, 0, stub_length) ) {
                if (hdr->flags&PFC_FIRST_FRAG) {
                    if (stub_length > 0) {
                        proto_tree_add_item(stub_tree, hf_dcerpc_fault_stub_data, stub_tvb, 0, stub_length, ENC_NA);
                    }
                } else {
                    if (stub_length > 0) {
                        proto_tree_add_item(stub_tree, hf_dcerpc_fragment_data, stub_tvb, 0, stub_length, ENC_NA);
                    }
                }
            } else {
                if (dcerpc_tree) {
                    if (length > 0) {
                        proto_tree_add_item(stub_tree, hf_dcerpc_fragment_data, stub_tvb, 0, stub_length, ENC_NA);
                    }
                }
                if (hdr->flags&PFC_FIRST_FRAG) {  
                    if ( (!pinfo->fd->visited) && value->rep_frame ) {
                        fragment_add_seq_next(&dcerpc_co_reassembly_table,
                                              stub_tvb, 0,
                                              pinfo, value->rep_frame, NULL,
                                              stub_length,
                                              TRUE);
                    }
                } else if (hdr->flags&PFC_LAST_FRAG) {  
                    if ( value->rep_frame ) {
                        fragment_head *fd_head;
                        fd_head = fragment_add_seq_next(&dcerpc_co_reassembly_table,
                                                        stub_tvb, 0,
                                                        pinfo, value->rep_frame, NULL,
                                                        stub_length,
                                                        TRUE);
                        if (fd_head) {
                            tvbuff_t *next_tvb;
                            proto_item *frag_tree_item;
                            next_tvb = tvb_new_chain(stub_tvb, fd_head->tvb_data);
                            add_new_data_source(pinfo, next_tvb, "Reassembled DCE/RPC");
                            show_fragment_tree(fd_head, &dcerpc_frag_items,
                                               dcerpc_tree, pinfo, next_tvb, &frag_tree_item);
                            if (dcerpc_tree) {
                                if (length > 0) {
                                    proto_tree_add_item(dcerpc_tree, hf_dcerpc_stub_data, stub_tvb, 0, stub_length, ENC_NA);
                                }
                            }
                        }
                    }
                } else {  
                    if ( (!pinfo->fd->visited) && value->rep_frame ) {
                        fragment_add_seq_next(&dcerpc_co_reassembly_table,
                                              stub_tvb, 0,
                                              pinfo, value->rep_frame, NULL,
                                              stub_length,
                                              TRUE);
                    }
                }
            }
        }
    }
    dissect_dcerpc_cn_auth_move(&auth_info, dcerpc_tree);
}
