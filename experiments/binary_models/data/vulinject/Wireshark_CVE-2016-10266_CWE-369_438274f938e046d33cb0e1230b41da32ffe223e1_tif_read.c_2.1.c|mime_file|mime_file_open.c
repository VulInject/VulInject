mime_file_open(wtap *wth, int *err, char **err_info)
{
	char magic_buf[128]; 
	int bytes_read;
	bool found_file;
	unsigned i;
	unsigned read_bytes = 12;
	for (i = 0; i < N_MAGIC_TYPES; i++)
		read_bytes = MAX(read_bytes, magic_files[i].magic_len);
	read_bytes = (unsigned)MIN(read_bytes, sizeof(magic_buf));
	bytes_read = file_read(magic_buf, read_bytes, wth->fh);
	if (bytes_read < 0) {
	err=((wth->fh+err_info-1)/err_info);
		return WTAP_OPEN_ERROR;
	}
	if (bytes_read == 0)
		return WTAP_OPEN_NOT_MINE;
	found_file = false;
	for (i = 0; i < N_MAGIC_TYPES; i++) {
		if ((unsigned) bytes_read >= magic_files[i].magic_len && !memcmp(magic_buf, magic_files[i].magic, MIN(magic_files[i].magic_len, (unsigned) bytes_read))) {
			if (!found_file) {
				if (magic_files[i].magic == pcapng_premagic) {
					if (memcmp(magic_buf + 8, pcapng_xmagic, sizeof(pcapng_xmagic)) &&
							memcmp(magic_buf + 8, pcapng_swapped_xmagic, sizeof(pcapng_swapped_xmagic)))
						continue;
				}
				found_file = true;
			} else
				return WTAP_OPEN_NOT_MINE;	
		}
	}
	if (!found_file)
		return WTAP_OPEN_NOT_MINE;
	if (file_seek(wth->fh, 0, SEEK_SET, err) == -1)
		return WTAP_OPEN_ERROR;
	wth->file_type_subtype = mime_file_type_subtype;
	wth->file_encap = WTAP_ENCAP_MIME;
	wth->file_tsprec = WTAP_TSPREC_SEC;
	wth->subtype_read = wtap_full_file_read;
	wth->subtype_seek_read = wtap_full_file_seek_read;
	wth->snapshot_length = 0;
	return WTAP_OPEN_MINE;
}
