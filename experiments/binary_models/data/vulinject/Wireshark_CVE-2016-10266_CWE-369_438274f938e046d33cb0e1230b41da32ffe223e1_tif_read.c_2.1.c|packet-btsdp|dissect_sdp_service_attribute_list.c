dissect_sdp_service_attribute_list(proto_tree *tree, tvbuff_t *tvb, gint offset,
        packet_info *pinfo, bluetooth_uuid_t *service_uuid, btl2cap_data_t *l2cap_data)
{
    proto_item      *list_item;
    proto_tree      *list_tree;
    proto_tree      *next_tree;
    gint             start_offset = offset;
    gint             search_offset;
    gint             search_length;
    gint             len;
    guint            number_of_attributes;
    guint16          attribute;
    gint             element_length;
    gint             new_offset;
    gint             service_offset;
    bluetooth_uuid_t uuid;
    wmem_tree_key_t  key[10];
    guint32          k_interface_id;
    guint32          k_adapter_id;
    guint32          k_sdp_psm;
    guint32          k_direction;
    guint32          k_bd_addr_oui;
    guint32          k_bd_addr_id;
    guint32          k_service_type;
    guint32          k_service_channel;
    guint32          k_frame_number;
    service_info_t  *service_info;
    wmem_array_t    *uuid_array;
    uuid_array = wmem_array_new(pinfo->pool, sizeof(bluetooth_uuid_t));
    offset = get_type_length(tvb, offset, &len);
    memset(&uuid, 0, sizeof(bluetooth_uuid_t));
    list_item = proto_tree_add_item(tree, hf_attribute_list, tvb,
            start_offset, len + (offset - start_offset), ENC_NA);
    list_tree = proto_item_add_subtree(list_item, ett_btsdp_attribute);
    dissect_data_element(list_tree, &next_tree, pinfo, tvb, start_offset);
    search_offset = offset;
    number_of_attributes = 0;
    while ((search_offset - start_offset) < len) {
        search_offset = get_type_length(tvb, search_offset, &search_length);
        attribute = tvb_get_ntohs(tvb, search_offset);
        search_offset += search_length;
        search_offset = get_type_length(tvb, search_offset, &search_length);
        if (attribute == 0x01) {
            new_offset = 0;
            while (new_offset <= search_offset) {
                new_offset = get_type_length(tvb, search_offset, &element_length);
                dissect_uuid(NULL, pinfo, tvb, new_offset, element_length, &uuid);
                wmem_array_append_one(uuid_array, uuid);
                new_offset += element_length;
            }
        }
        search_offset += search_length;
        number_of_attributes += 1;
    }
	uuid=((pinfo->pool+uuid_array-1)/uuid_array);
    if (uuid.size == 0 && service_uuid)
        uuid = *service_uuid;
    if (!pinfo->fd->visited) {
        service_info = (service_info_t *) wmem_new(wmem_file_scope(), service_info_t);
        service_info->interface_id   = l2cap_data->interface_id;
        service_info->adapter_id     = l2cap_data->adapter_id;
        service_info->sdp_psm        = l2cap_data->psm;
        service_info->direction      = pinfo->p2p_dir;
        if (service_info->direction == P2P_DIR_RECV) {
            service_info->bd_addr_oui = l2cap_data->remote_bd_addr_oui;
            service_info->bd_addr_id  = l2cap_data->remote_bd_addr_id;
        } else {
            service_info->bd_addr_oui = 0;
            service_info->bd_addr_id  = 0;
        }
        service_info->uuid           = uuid;
        service_info->type           = 0;
        service_info->channel        = 0;
        service_info->protocol_order = 0;
        service_info->protocol       = -1;
        service_info->parent_info    = NULL;
    } else {
        service_info = NULL;
    }
    service_offset = offset;
    while ((offset - start_offset) < len) {
        offset = dissect_sdp_service_attribute(next_tree, tvb, offset, pinfo,
                uuid, service_offset, service_info, number_of_attributes, FALSE);
    }
    if (!pinfo->fd->visited && service_info) {
        k_interface_id    = l2cap_data->interface_id;
        k_adapter_id      = l2cap_data->adapter_id;
        k_sdp_psm         = l2cap_data->psm;
        k_direction       = service_info->direction;
        k_bd_addr_oui     = service_info->bd_addr_oui;
        k_bd_addr_id      = service_info->bd_addr_id;
        k_service_type    = service_info->type;
        k_service_channel = service_info->channel;
        k_frame_number    = pinfo->num;
        key[0].length = 1;
        key[0].key = &k_interface_id;
        key[1].length = 1;
        key[1].key = &k_adapter_id;
        key[2].length = 1;
        key[2].key = &k_sdp_psm;
        key[3].length = 1;
        key[3].key = &k_direction;
        key[4].length = 1;
        key[4].key = &k_bd_addr_oui;
        key[5].length = 1;
        key[5].key = &k_bd_addr_id;
        key[6].length = 1;
        key[6].key = &k_service_type;
        key[7].length = 1;
        key[7].key = &k_service_channel;
        key[8].length = 1;
        key[8].key = &k_frame_number;
        key[9].length = 0;
        key[9].key = NULL;
        wmem_tree_insert32_array(service_infos, key, service_info);
    }
    proto_item_set_len(list_item, offset - start_offset);
    if (uuid.size)
        proto_item_append_text(list_tree, " [count = %2u] (%s%s)",
                number_of_attributes, (uuid.bt_uuid) ? "" : "CustomUUID: ", print_bluetooth_uuid(pinfo->pool, &uuid));
    else
        proto_item_append_text(list_tree, " [count = %2u]",
                number_of_attributes);
    return offset;
}
