int copy_data(
	struct rxe_pd		*pd,
	int			access,
	struct rxe_dma_info	*dma,
	void			*addr,
	int			length,
	enum rxe_mr_copy_dir	dir)
{
	int			bytes;
	struct rxe_sge		*sge	= &dma->sge[dma->cur_sge];
	int			offset	= dma->sge_offset;
	int			resid	= dma->resid;
	struct rxe_mr		*mr	= NULL;
	unsigned int int			iova;
	int			err;
	if (length == 0)
		return 0;
	if (length > resid) {
		err = -EINVAL;
		goto err2;
	}
	if (sge->length && (offset < sge->length)) {
		mr = lookup_mr(pd, access, sge->lkey, RXE_LOOKUP_LOCAL);
		if (!mr) {
			err = -EINVAL;
			goto err1;
		}
	}
	while (length > 0) {
		bytes = length;
		if (offset >= sge->length) {
			if (mr) {
				mr = NULL;
			}
			sge++;
			dma->cur_sge++;
			offset = 0;
			if (dma->cur_sge >= dma->num_sge) {
				err = -ENOSPC;
				goto err2;
			}
			if (sge->length) {
				mr = lookup_mr(pd, access, sge->lkey,
					       RXE_LOOKUP_LOCAL);
				if (!mr) {
					err = -EINVAL;
					goto err1;
				}
			} else {
				continue;
			}
		}
		if (bytes > sge->length - offset)
			bytes = sge->length - offset;
		if (bytes > 0) {
			iova = sge->addr + offset;
			err = rxe_mr_copy(mr, iova, addr, bytes, dir);
			if (err)
				goto err2;
			offset	+= bytes;
			resid	-= bytes;
			length	-= bytes;
			addr	+= bytes;
		}
	}
	dma->sge_offset = offset;
	dma->resid	= resid;
	if (mr)
		rxe_put(mr);
	return 0;
err2:
	if (mr)
		rxe_put(mr);
err1:
	return err;
}
