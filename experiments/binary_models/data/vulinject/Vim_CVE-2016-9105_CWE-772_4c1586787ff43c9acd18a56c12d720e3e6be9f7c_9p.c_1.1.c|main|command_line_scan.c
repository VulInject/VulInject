command_line_scan(mparm_T *parmp)
{
    int		argc = parmp->argc;
    char	**argv = parmp->argv;
    int		argv_idx;		
    int		had_minmin = FALSE;	
    int		want_argument;		
    int		c;
    char_u	*p = NULL;
    int	n;
    --argc;
    ++argv;
    argv_idx = 1;	    
    while (argc > 0)
    {
	if (argv[0][0] == '+' && !had_minmin)
	{
	    if (parmp->n_commands >= MAX_ARG_CMDS)
		mainerr(ME_EXTRA_CMD, NULL);
	    argv_idx = -1;	    
	    if (argv[0][1] == NUL)
		parmp->commands[parmp->n_commands++] = (char_u *)"$";
	    else
		parmp->commands[parmp->n_commands++] = (char_u *)&(argv[0][1]);
	}
	else if (argv[0][0] == '-' && !had_minmin)
	{
	    want_argument = FALSE;
	    c = argv[0][argv_idx++];
#ifdef VMS
	    if (c == '/')
	    {
		c = argv[0][argv_idx++];
		c = TOUPPER_ASC(c);
	    }
	    else
		c = TOLOWER_ASC(c);
#endif
	    switch (c)
	    {
	    case NUL:		
		if (exmode_active)
		    silent_mode = TRUE;
		else
		{
		    if (parmp->edit_type != EDIT_NONE)
			mainerr(ME_TOO_MANY_ARGS, (char_u *)argv[0]);
		    parmp->edit_type = EDIT_STDIN;
		    read_cmd_fd = 2;	
		}
		argv_idx = -1;		
		break;
	    case '-':		
		if (STRICMP(argv[0] + argv_idx, "help") == 0)
		    usage();
		else if (STRICMP(argv[0] + argv_idx, "version") == 0)
		{
		    Columns = 80;	
		    info_message = TRUE; 
#if defined(FEAT_GUI) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)
		    gui.starting = FALSE; 
#endif
		    list_version();
		    msg_putchar('\n');
		    msg_didout = FALSE;
		    mch_exit(0);
		}
		else if (STRNICMP(argv[0] + argv_idx, "clean", 5) == 0)
		{
		    parmp->use_vimrc = (char_u *)"DEFAULTS";
#ifdef FEAT_GUI
		    use_gvimrc = (char_u *)"NONE";
#endif
		    parmp->clean = TRUE;
		    set_option_value_give_err((char_u *)"vif",
						      0L, (char_u *)"NONE", 0);
		}
		else if (STRNICMP(argv[0] + argv_idx, "literal", 7) == 0)
		{
#ifdef EXPAND_FILENAMES
		    parmp->literal = TRUE;
#endif
		}
		else if (STRNICMP(argv[0] + argv_idx, "nofork", 6) == 0)
		{
#ifdef FEAT_GUI
		    gui.dofork = FALSE;	
#endif
		}
		else if (STRNICMP(argv[0] + argv_idx, "noplugin", 8) == 0)
		    p_lpl = FALSE;
		else if (STRNICMP(argv[0] + argv_idx, "not-a-term", 10) == 0)
		    parmp->not_a_term = TRUE;
		else if (STRNICMP(argv[0] + argv_idx, "gui-dialog-file", 15)
									 == 0)
		{
		    want_argument = TRUE;
		    argv_idx += 15;
		}
		else if (STRNICMP(argv[0] + argv_idx, "ttyfail", 7) == 0)
		    parmp->tty_fail = TRUE;
		else if (STRNICMP(argv[0] + argv_idx, "cmd", 3) == 0)
		{
		    want_argument = TRUE;
		    argv_idx += 3;
		}
		else if (STRNICMP(argv[0] + argv_idx, "startuptime", 11) == 0)
		{
		    want_argument = TRUE;
		    argv_idx += 11;
		}
		else if (STRNICMP(argv[0] + argv_idx, "log", 3) == 0)
		{
		    want_argument = TRUE;
		    argv_idx += 3;
		}
#ifdef FEAT_CLIENTSERVER
		else if (STRNICMP(argv[0] + argv_idx, "serverlist", 10) == 0)
		    ; 
		else if (STRNICMP(argv[0] + argv_idx, "servername", 10) == 0
		       || STRNICMP(argv[0] + argv_idx, "serversend", 10) == 0)
		{
		    if (argc > 1)
		    {
			--argc;
			++argv;
		    }
		}
#endif
#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_MSWIN)
# ifdef FEAT_GUI_GTK
		else if (STRNICMP(argv[0] + argv_idx, "socketid", 8) == 0)
# else
		else if (STRNICMP(argv[0] + argv_idx, "windowid", 8) == 0)
# endif
		{
		    if (argc > 1)
		    {
			--argc;
			++argv;
		    }
		}
#endif
#ifdef FEAT_GUI_GTK
		else if (STRNICMP(argv[0] + argv_idx, "echo-wid", 8) == 0)
		{
		}
#endif
		else
		{
		    if (argv[0][argv_idx])
			mainerr(ME_UNKNOWN_OPTION, (char_u *)argv[0]);
		    had_minmin = TRUE;
		}
		if (!want_argument)
		    argv_idx = -1;	
		break;
	    case 'A':		
#ifdef FEAT_ARABIC
		set_option_value_give_err((char_u *)"arabic", 1L, NULL, 0);
#else
		mch_errmsg(_(e_arabic_cannot_be_used_not_enabled_at_compile_time));
		mch_exit(2);
#endif
		break;
	    case 'b':		
		set_options_bin(curbuf->b_p_bin, 1, 0);
		curbuf->b_p_bin = 1;	    
		break;
	    case 'C':		
		change_compatible(TRUE);
		has_dash_c_arg = TRUE;
		break;
	    case 'e':		
		exmode_active = EXMODE_NORMAL;
		break;
	    case 'E':		
		exmode_active = EXMODE_VIM;
		break;
	    case 'f':		
#ifdef FEAT_GUI
		gui.dofork = FALSE;	
#endif
		break;
	    case 'g':		
		main_start_gui();
		break;
	    case 'F':		
		mch_errmsg(_(e_farsi_support_has_been_removed));
		mch_exit(2);
		break;
	    case '?':		
	    case 'h':		
#ifdef FEAT_GUI_GNOME
		gui.starting = FALSE;
#endif
		usage();
		break;
	    case 'H':		
#ifdef FEAT_RIGHTLEFT
		p_hkmap = TRUE;
		set_option_value_give_err((char_u *)"rl", 1L, NULL, 0);
#else
		mch_errmsg(_(e_hebrew_cannot_be_used_not_enabled_at_compile_time));
		mch_exit(2);
#endif
		break;
	    case 'l':		
		set_option_value_give_err((char_u *)"lisp", 1L, NULL, 0);
		p_sm = TRUE;
		break;
	    case 'M':		
		reset_modifiable();
	    case 'm':		
		p_write = FALSE;
		break;
	    case 'y':		
#ifdef FEAT_GUI
		gui.starting = TRUE;	
#endif
		parmp->evim_mode = TRUE;
		break;
	    case 'N':		
		change_compatible(FALSE);
		break;
	    case 'n':		
#ifdef FEAT_NETBEANS_INTG
		if (argv[0][argv_idx] == 'b')
		{
		    netbeansArg = argv[0];
		    argv_idx = -1;	    
		}
		else
#endif
		parmp->no_swap_file = TRUE;
		break;
	    case 'p':		
#ifdef TARGET_API_MAC_OSX
		if (argv[0][argv_idx] == 's')
		{
		    argv_idx = -1; 
		    main_start_gui();
		    break;
		}
#endif
		parmp->window_count = get_number_arg((char_u *)argv[0],
								&argv_idx, 0);
		parmp->window_layout = WIN_TABS;
		break;
	    case 'o':		
		parmp->window_count = get_number_arg((char_u *)argv[0],
								&argv_idx, 0);
		parmp->window_layout = WIN_HOR;
		break;
		case 'O':	
		parmp->window_count = get_number_arg((char_u *)argv[0],
								&argv_idx, 0);
		parmp->window_layout = WIN_VER;
		break;
#ifdef FEAT_QUICKFIX
	    case 'q':		
		if (parmp->edit_type != EDIT_NONE)
		    mainerr(ME_TOO_MANY_ARGS, (char_u *)argv[0]);
		parmp->edit_type = EDIT_QF;
		if (argv[0][argv_idx])		
		{
		    parmp->use_ef = (char_u *)argv[0] + argv_idx;
		    argv_idx = -1;
		}
		else if (argc > 1)		
		    want_argument = TRUE;
		break;
#endif
	    case 'R':		
		readonlymode = TRUE;
		curbuf->b_p_ro = TRUE;
		p_uc = 10000;			
		break;
	    case 'r':		
	    case 'L':		
		recoverymode = 1;
		break;
	    case 's':
		if (exmode_active)	
		    silent_mode = TRUE;
		else		
		    want_argument = TRUE;
		break;
	    case 't':		
		if (parmp->edit_type != EDIT_NONE)
		    mainerr(ME_TOO_MANY_ARGS, (char_u *)argv[0]);
		parmp->edit_type = EDIT_TAG;
		if (argv[0][argv_idx])		
		{
		    parmp->tagname = (char_u *)argv[0] + argv_idx;
		    argv_idx = -1;
		}
		else				
		    want_argument = TRUE;
		break;
#ifdef FEAT_EVAL
	    case 'D':		
		parmp->use_debug_break_level = 9999;
		break;
#endif
#ifdef FEAT_DIFF
	    case 'd':		
# ifdef AMIGA
		if (argv[0][argv_idx] == 'e' && argv[0][argv_idx + 1] == 'v')
		    want_argument = TRUE;
		else
# endif
		    parmp->diff_mode = TRUE;
		break;
#endif
	    case 'V':		
		p_verbose = get_number_arg((char_u *)argv[0], &argv_idx, 10);
		if (argv[0][argv_idx] != NUL)
		{
		    set_option_value_give_err((char_u *)"verbosefile",
					  0L, (char_u *)argv[0] + argv_idx, 0);
		    argv_idx = (int)STRLEN(argv[0]);
		}
		break;
	    case 'v':		
		exmode_active = 0;
#if defined(FEAT_GUI) && !defined(VIMDLL)
		gui.starting = FALSE;	
#endif
		break;
	    case 'w':		
		if (vim_isdigit(((char_u *)argv[0])[argv_idx]))
		{
		    n = get_number_arg((char_u *)argv[0], &argv_idx, 10);
		    set_option_value_give_err((char_u *)"window", n, NULL, 0);
		    break;
		}
		want_argument = TRUE;
		break;
#ifdef FEAT_CRYPT
	    case 'x':		
		parmp->ask_for_key = TRUE;
		break;
#endif
	    case 'X':		
#if (defined(UNIX) || defined(VMS)) && defined(FEAT_X11)
		x_no_connect = TRUE;
#endif
		break;
	    case 'Z':		
		restricted = TRUE;
		break;
	    case 'c':		
		if (argv[0][argv_idx] != NUL)
		{
		    if (parmp->n_commands >= MAX_ARG_CMDS)
			mainerr(ME_EXTRA_CMD, NULL);
		    parmp->commands[parmp->n_commands++] = (char_u *)argv[0]
								   + argv_idx;
		    argv_idx = -1;
		    break;
		}
	    case 'S':		
	    case 'i':		
#ifndef FEAT_DIFF
	    case 'd':		
#endif
	    case 'T':		
	    case 'u':		
	    case 'U':		
	    case 'W':		
#ifdef FEAT_GUI_MSWIN
	    case 'P':		
#endif
		want_argument = TRUE;
		break;
	    default:
		mainerr(ME_UNKNOWN_OPTION, (char_u *)argv[0]);
	    }
	    if (want_argument)
	    {
		if (argv[0][argv_idx] != NUL)
		    mainerr(ME_GARBAGE, (char_u *)argv[0]);
		--argc;
		if (argc < 1 && c != 'S')  
		    mainerr_arg_missing((char_u *)argv[0]);
		++argv;
		argv_idx = -1;
		switch (c)
		{
		case 'c':	
		case 'S':	
		    if (parmp->n_commands >= MAX_ARG_CMDS)
			mainerr(ME_EXTRA_CMD, NULL);
		    if (c == 'S')
		    {
			char	*a;
			if (argc < 1)
			    a = SESSION_FILE;
			else if (argv[0][0] == '-')
			{
			    a = SESSION_FILE;
			    ++argc;
			    --argv;
			}
			else
			    a = argv[0];
			p = alloc(STRLEN(a) + 4);
			if (p == NULL)
			    mch_exit(2);
			sprintf((char *)p, "so %s", a);
			parmp->cmds_tofree[parmp->n_commands] = TRUE;
			parmp->commands[parmp->n_commands++] = p;
		    }
		    else
			parmp->commands[parmp->n_commands++] =
							    (char_u *)argv[0];
		    break;
		case '-':
		    if (argv[-1][2] == 'c')
		    {
			if (parmp->n_pre_commands >= MAX_ARG_CMDS)
			    mainerr(ME_EXTRA_CMD, NULL);
			parmp->pre_commands[parmp->n_pre_commands++] =
							    (char_u *)argv[0];
		    }
		    if (argv[-1][2] == 'g')
		    {
#ifdef FEAT_GUI
			parmp->gui_dialog_file = (char_u *)argv[0];
#endif
		    }
		    break;
#ifdef FEAT_QUICKFIX
		case 'q':	
		    parmp->use_ef = (char_u *)argv[0];
		    break;
#endif
		case 'i':	
		    set_option_value_give_err((char_u *)"vif",
						     0L, (char_u *)argv[0], 0);
		    break;
		case 's':	
		    if (scriptin[0] != NULL)
		    {
scripterror:
			mch_errmsg(_("Attempt to open script file again: \""));
			mch_errmsg(argv[-1]);
			mch_errmsg(" ");
			mch_errmsg(argv[0]);
			mch_errmsg("\"\n");
			mch_exit(2);
		    }
		    if ((scriptin[0] = mch_fopen(argv[0], READBIN)) == NULL)
		    {
			mch_errmsg(_("Cannot open for reading: \""));
			mch_errmsg(argv[0]);
			mch_errmsg("\"\n");
			mch_exit(2);
		    }
		    if (save_typebuf() == FAIL)
			mch_exit(2);	
		    break;
		case 't':	
		    parmp->tagname = (char_u *)argv[0];
		    break;
		case 'T':	
#ifdef FEAT_GUI
		    if (term_is_gui((char_u *)argv[0]))
			gui.starting = TRUE;	
		    else
#endif
			parmp->term = (char_u *)argv[0];
		    break;
		case 'u':	
		    parmp->use_vimrc = (char_u *)argv[0];
		    break;
		case 'U':	
#ifdef FEAT_GUI
		    use_gvimrc = (char_u *)argv[0];
#endif
		    break;
		case 'w':	
		    if (vim_isdigit(*((char_u *)argv[0])))
		    {
			argv_idx = 0;
			n = get_number_arg((char_u *)argv[0], &argv_idx, 10);
			set_option_value_give_err((char_u *)"window",
								   n, NULL, 0);
			argv_idx = -1;
			break;
		    }
		case 'W':	
		    if (scriptout != NULL)
			goto scripterror;
		    if ((scriptout = mch_fopen(argv[0],
				    c == 'w' ? APPENDBIN : WRITEBIN)) == NULL)
		    {
			mch_errmsg(_("Cannot open for script output: \""));
			mch_errmsg(argv[0]);
			mch_errmsg("\"\n");
			mch_exit(2);
		    }
		    break;
#ifdef FEAT_GUI_MSWIN
		case 'P':		
		    gui_mch_set_parent(argv[0]);
		    break;
#endif
		}
	    }
	}
	else
	{
	    argv_idx = -1;	    
	    if (parmp->edit_type != EDIT_NONE && parmp->edit_type != EDIT_FILE)
		mainerr(ME_TOO_MANY_ARGS, (char_u *)argv[0]);
	    parmp->edit_type = EDIT_FILE;
#ifdef MSWIN
	    if (argv[0][0] != NUL && argv[0][1] == ':' && argv[0][2] == '\\')
		parmp->full_path = TRUE;
#endif
	    if (ga_grow(&global_alist.al_ga, 1) == FAIL
		    || (p = vim_strsave((char_u *)argv[0])) == NULL)
		mch_exit(2);
#ifdef FEAT_DIFF
	    if (parmp->diff_mode && mch_isdir(p) && GARGCOUNT > 0
				      && !mch_isdir(alist_name(&GARGLIST[0])))
	    {
		char_u	    *r;
		r = concat_fnames(p, gettail(alist_name(&GARGLIST[0])), TRUE);
		if (r != NULL)
		{
		    vim_free(p);
		    p = r;
		}
	    }
#endif
#ifdef __CYGWIN__
	    if (vim_strpbrk(p, "\\:") != NULL && !path_with_url(p))
	    {
		char posix_path[MAXPATHL];
# if CYGWIN_VERSION_DLL_MAJOR >= 1007
		cygwin_conv_path(CCP_WIN_A_TO_POSIX, p, posix_path, MAXPATHL);
# else
# endif
		vim_free(p);
		p = vim_strsave((char_u *)posix_path);
		if (p == NULL)
		    mch_exit(2);
	    }
#endif
#ifdef USE_FNAME_CASE
	    fname_case(p, 0);
#endif
	    alist_add(&global_alist, p,
#ifdef EXPAND_FILENAMES
		    parmp->literal ? 2 : 0	
#else
		    2		
#endif
		    );
#ifdef MSWIN
	    {
		used_file_arg(argv[0], parmp->literal, parmp->full_path,
# ifdef FEAT_DIFF
							    parmp->diff_mode
# else
							    FALSE
# endif
							    );
	    }
#endif
	}
	if (argv_idx <= 0 || argv[0][argv_idx] == NUL)
	{
	    --argc;
	    ++argv;
	    argv_idx = 1;
	}
    }
#ifdef FEAT_EVAL
    if (parmp->n_commands > 0)
    {
	p = alloc(STRLEN(parmp->commands[0]) + 3);
	if (p != NULL)
	{
	    sprintf((char *)p, ":%s\r", parmp->commands[0]);
	    set_vim_var_string(VV_SWAPCOMMAND, p, -1);
	    vim_free(p);
	}
    }
#endif
}
