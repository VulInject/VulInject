col_prepend_fence_fstr(column_info *cinfo, const int el, const char *format, ...)
{
  va_list     ap;
  int         i;
  char        orig_buf[COL_BUF_MAX_LEN];
  const char *orig;
  size_t      max_len, pos;
  col_item_t* col_item;
  char tmp[COL_BUF_MAX_LEN];
  if (!CHECK_COL(cinfo, el))
    return;
  if (el == COL_INFO)
    max_len = COL_MAX_INFO_LEN;
  else
    max_len = COL_MAX_LEN;
  for (i = cinfo->col_first[el]; i <= cinfo->col_last[el]; i++) {
    col_item = &cinfo->columns[i];
    if (col_item->fmt_matx[el]) {
      if (col_item->col_data != col_item->col_buf) {
        orig = col_item->col_data;
      } else {
        (void) g_strlcpy(orig_buf, col_item->col_buf, max_len);
        orig = orig_buf;
      }
      pos = vsnprintf(tmp, sizeof(tmp), format, ap);
      va_end(ap);
      if (pos >= max_len) {
        ws_utf8_truncate(tmp, max_len - 1);
      }
      WS_UTF_8_CHECK(tmp, -1);
      pos = ws_label_strcpy(col_item->col_buf, max_len, 0, tmp, 0);
      if (col_item->col_fence > 0) {
        col_item->col_fence += (int) strlen(col_item->col_buf);
      } else {
        col_item->col_fence = (int) strlen(col_item->col_buf);
      }
      ws_label_strcpy(col_item->col_buf, max_len, pos, orig, 0);
      col_item->col_data = col_item->col_buf;
    }
  }
}
