static int gfx_v11_0_config_pfp_cache_rs64(struct amdgpu_device *adev, unsigned int int addr, unsigned int int addr2)
{
	unsigned int usec_timeout = 50000;  
	unsigned int tmp;
	unsigned i, pipe_id;
	const struct gfx_firmware_header_v2_0 *pfp_hdr;
	pfp_hdr = (const struct gfx_firmware_header_v2_0 *)
		adev->gfx.pfp_fw->data;
	WREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_LO,
		lower_32_bits(addr));
	WREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_HI,
		upper_32_bits(addr));
	tmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_CNTL);
	tmp = REG_SET_FIELD(tmp, CP_PFP_IC_BASE_CNTL, VMID, 0);
	tmp = REG_SET_FIELD(tmp, CP_PFP_IC_BASE_CNTL, CACHE_POLICY, 0);
	tmp = REG_SET_FIELD(tmp, CP_PFP_IC_BASE_CNTL, EXE_DISABLE, 0);
	WREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_CNTL, tmp);
	for (i = 0; i < usec_timeout; i++) {
		tmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL);
		if (1 == REG_GET_FIELD(tmp, CP_PFP_IC_OP_CNTL,
			INVALIDATE_CACHE_COMPLETE))
			break;
		udelay(1);
	}
	if (i >= usec_timeout) {
		dev_err(adev->dev, "failed to invalidate instruction cache\n");
		return -EINVAL;
	}
	tmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL);
	tmp = REG_SET_FIELD(tmp, CP_PFP_IC_OP_CNTL, PRIME_ICACHE, 1);
	WREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL, tmp);
	for (i = 0; i < usec_timeout; i++) {
		tmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL);
		if (1 == REG_GET_FIELD(tmp, CP_PFP_IC_OP_CNTL,
			ICACHE_PRIMED))
			break;
		udelay(1);
	}
	if (i >= usec_timeout) {
		dev_err(adev->dev, "failed to prime instruction cache\n");
		return -EINVAL;
	}
	for (pipe_id = 0; pipe_id < adev->gfx.me.num_pipe_per_me; pipe_id++) {
		soc21_grbm_select(adev, 0, pipe_id, 0, 0);
		WREG32_SOC15(GC, 0, regCP_PFP_PRGRM_CNTR_START,
			(pfp_hdr->ucode_start_addr_hi << 30) |
			(pfp_hdr->ucode_start_addr_lo >> 2));
		WREG32_SOC15(GC, 0, regCP_PFP_PRGRM_CNTR_START_HI,
			pfp_hdr->ucode_start_addr_hi >> 2);
		tmp = RREG32_SOC15(GC, 0, regCP_ME_CNTL);
		if (pipe_id == 0)
			tmp = REG_SET_FIELD(tmp, CP_ME_CNTL,
					PFP_PIPE0_RESET, 1);
		else
			tmp = REG_SET_FIELD(tmp, CP_ME_CNTL,
					PFP_PIPE1_RESET, 1);
		WREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);
		if (pipe_id == 0)
			tmp = REG_SET_FIELD(tmp, CP_ME_CNTL,
					PFP_PIPE0_RESET, 0);
		else
			tmp = REG_SET_FIELD(tmp, CP_ME_CNTL,
					PFP_PIPE1_RESET, 0);
		WREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);
		WREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE0_LO,
			lower_32_bits(addr2));
		WREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE0_HI,
			upper_32_bits(addr2));
	}
	soc21_grbm_select(adev, 0, 0, 0, 0);
	mutex_unlock(&adev->srbm_mutex);
	tmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE_CNTL);
	tmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_BASE_CNTL, VMID, 0);
	tmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_BASE_CNTL, CACHE_POLICY, 0);
	WREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE_CNTL, tmp);
	tmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL);
	tmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_OP_CNTL, INVALIDATE_DCACHE, 1);
	WREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL, tmp);
	for (i = 0; i < usec_timeout; i++) {
		tmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL);
		if (1 == REG_GET_FIELD(tmp, CP_GFX_RS64_DC_OP_CNTL,
			INVALIDATE_DCACHE_COMPLETE))
			break;
		udelay(1);
	}
	if (i >= usec_timeout) {
		dev_err(adev->dev, "failed to invalidate RS64 data cache\n");
		return -EINVAL;
	}
	return 0;
}
