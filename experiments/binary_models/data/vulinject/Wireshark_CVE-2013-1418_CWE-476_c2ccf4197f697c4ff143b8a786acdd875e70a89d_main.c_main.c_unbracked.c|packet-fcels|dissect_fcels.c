dissect_fcels (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
    proto_item *ti = NULL;
    proto_tree *acc_tree;
    guint8 isreq = FC_ELS_REQ;
    int offset = 0;
    guint8 opcode,
           failed_opcode = 0;
    conversation_t *conversation;
    fcels_conv_data_t *cdata;
    fcels_conv_key_t ckey, *req_key;
    guint find_options, new_options;
    address dstaddr;
    guint8 addrdata[3];
    fc_hdr *fchdr;
    fchdr = (fc_hdr *)data;
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "FC ELS");
    opcode = tvb_get_guint8 (tvb, 0);
    if (tree) {
        ti = proto_tree_add_protocol_format (tree, proto_fcels, tvb, 0,
                                             -1, "FC ELS");
    }
    if ((opcode != FC_ELS_LSRJT) && (opcode != FC_ELS_ACC)) {
        if (opcode == FC_ELS_FLOGI) {
            const guint8 *srcfc;
            if (pinfo->src.type != AT_FC) {
                expert_add_info_format(pinfo, ti, &ei_fcels_src_unknown,
                                       "Unknown source address type: %u",
                                       pinfo->src.type);
                return 0;
            }
            srcfc = (const guint8 *)pinfo->src.data;
            if (srcfc[2]) {
                find_options = NO_PORT_B;
                new_options = NO_PORT2;
            }
            else {
                find_options = NO_PORT_B | NO_ADDR_B;
                new_options = NO_PORT2 | NO_ADDR2;
            }
        }
        else {
            find_options = NO_PORT_B;
            new_options = NO_PORT2;
        }
        conversation = find_conversation (pinfo->num, &pinfo->dst, &pinfo->src,
                                          conversation_pt_to_conversation_type(pinfo->ptype), fchdr->oxid,
                                          fchdr->rxid, find_options);
        if (!conversation) {
            conversation = conversation_new (pinfo->num, &pinfo->dst, &pinfo->src,
                                             conversation_pt_to_conversation_type(pinfo->ptype), fchdr->oxid,
                                             fchdr->rxid, new_options);
        }
        ckey.conv_idx = conversation->conv_index;
        cdata = (fcels_conv_data_t *)wmem_map_lookup (fcels_req_hash,
                                                          &ckey);
        if (cdata) {
            cdata->opcode = opcode;
        }
        else {
            req_key = wmem_new(wmem_file_scope(), fcels_conv_key_t);
            req_key->conv_idx = conversation->conv_index;
            cdata = wmem_new(wmem_file_scope(), fcels_conv_data_t);
            cdata->opcode = opcode;
            wmem_map_insert (fcels_req_hash, req_key, cdata);
        }
    }
    else {
        isreq = FC_ELS_RPLY;
        find_options = NO_PORT_B;
        conversation = find_conversation (pinfo->num, &pinfo->dst, &pinfo->src,
                                          conversation_pt_to_conversation_type(pinfo->ptype), fchdr->oxid,
                                          fchdr->rxid, find_options);
        if (!conversation) {
            const guint8 *dstfc;
            if (pinfo->dst.type != AT_FC) {
                expert_add_info_format(pinfo, ti, &ei_fcels_dst_unknown,
                                       "Unknown destination address type: %u",
                                       pinfo->dst.type);
                return 0;
            }
            dstfc = (const guint8 *)pinfo->dst.data;
            addrdata[0] = addrdata[1] = 0;
            addrdata[2] = dstfc[2];
            set_address (&dstaddr, AT_FC, 3, addrdata);
            conversation = find_conversation (pinfo->num, &dstaddr, &pinfo->src,
                                              conversation_pt_to_conversation_type(pinfo->ptype), fchdr->oxid,
                                              fchdr->rxid, find_options);
        }
        if (!conversation) {
            find_options = NO_ADDR_B | NO_PORT_B;
            conversation = find_conversation (pinfo->num, &pinfo->src, &pinfo->dst,
                                              conversation_pt_to_conversation_type(pinfo->ptype), fchdr->oxid,
                                              fchdr->rxid, find_options);
            if (!conversation) {
                if (tree && (opcode == FC_ELS_ACC)) {
                    acc_tree = proto_item_add_subtree (ti, ett_fcels_acc);
                    proto_tree_add_expert(acc_tree, pinfo, &ei_fcels_no_record_of_exchange, tvb, offset, -1);
                    return 0;
                }
                failed_opcode = 0;
            }
        }
        if (conversation) {
            ckey.conv_idx = conversation->conv_index;
            cdata = (fcels_conv_data_t *)wmem_map_lookup (fcels_req_hash, &ckey);
            if (cdata != NULL) {
                if ((find_options & NO_ADDR_B) && (cdata->opcode != FC_ELS_FLOGI)) {
                    if (tree && (opcode == FC_ELS_ACC)) {
                        acc_tree = proto_item_add_subtree (ti,
                                                           ett_fcels_acc);
                        proto_tree_add_expert(acc_tree, pinfo, &ei_fcels_no_record_of_exchange, tvb, offset, -1);
                        return 0;
                    }
                }
                if (opcode == FC_ELS_ACC)
                    opcode = cdata->opcode;
                else
                    failed_opcode = cdata->opcode;
            }
            if (tree) {
                if ((cdata == NULL) && (opcode != FC_ELS_LSRJT)) {
                    acc_tree = proto_item_add_subtree (ti, ett_fcels_acc);
                    proto_tree_add_expert(acc_tree, pinfo, &ei_fcels_no_record_of_els_req, tvb, offset, -1);
                    return 0;
                }
            }
        }
    }
    if (isreq == FC_ELS_REQ) {
        col_add_str (pinfo->cinfo, COL_INFO,
                        val_to_str_ext (opcode, &fc_els_proto_val_ext, "0x%x"));
    }
    else if (opcode == FC_ELS_LSRJT) {
        col_add_fstr (pinfo->cinfo, COL_INFO, "LS_RJT (%s)",
                        val_to_str_ext (failed_opcode, &fc_els_proto_val_ext, "0x%x"));
    }
    else {
        col_add_fstr (pinfo->cinfo, COL_INFO, "ACC (%s)",
                        val_to_str_ext (opcode, &fc_els_proto_val_ext, "0x%x"));
    }
    switch (opcode) {
    case FC_ELS_LSRJT:
        dissect_fcels_lsrjt (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_PLOGI:
        dissect_fcels_plogi (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_FLOGI:
        dissect_fcels_flogi (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_LOGOUT:
        dissect_fcels_logout (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_ABTX:
        dissect_fcels_abtx (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_RSI:
        dissect_fcels_rsi (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_RRQ:
        dissect_fcels_rrq (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_REC:
        dissect_fcels_rec (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_PRLI:
        dissect_fcels_prli (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_PRLO:
        dissect_fcels_prlo (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_TPRLO:
        dissect_fcels_tprlo (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_PDISC:
        dissect_fcels_pdisc (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_FDISC:
        dissect_fcels_fdisc (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_ADISC:
        dissect_fcels_adisc (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_FARP_REQ:
        dissect_fcels_farp_req (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_FARP_RPLY:
        dissect_fcels_farp_rply (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_RPS:
        dissect_fcels_rps (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_RPL:
        dissect_fcels_rpl (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_FAN:
        dissect_fcels_fan (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_RSCN:
        dissect_fcels_rscn (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_SCR:
        dissect_fcels_scr (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_RNFT:
        dissect_fcels_rnft (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_LSTS:
        dissect_fcels_lsts (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_RNID:
        dissect_fcels_rnid (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_RLIR:
        dissect_fcels_rlir (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_LIRR:
        dissect_fcels_lirr (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_SRL:
        dissect_fcels_srl (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_RPSC:
        dissect_fcels_rpsc (tvb, pinfo, tree, isreq, ti);
        break;
    case FC_ELS_AUTH:
        if (isreq && fcsp_handle)
            call_dissector (fcsp_handle, tvb, pinfo, tree);
        break;
    case FC_ELS_CBIND:
        dissect_fcels_cbind (tvb, pinfo, tree, ti);
        break;
    case FC_ELS_UNBIND:
        dissect_fcels_unbind (tvb, pinfo, tree, ti);
        break;
    default:
        call_data_dissector(tvb, pinfo, tree);
        break;
    }
    return tvb_reported_length(tvb);
}
