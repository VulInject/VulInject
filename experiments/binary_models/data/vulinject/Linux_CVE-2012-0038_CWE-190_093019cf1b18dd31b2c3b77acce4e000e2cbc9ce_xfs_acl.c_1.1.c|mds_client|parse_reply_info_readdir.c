static int parse_reply_info_readdir(void **p, void *end,
				    struct ceph_mds_request *req,
				    unsigned int int features)
{
	struct ceph_mds_reply_info_parsed *info = &req->r_reply_info;
	struct ceph_client *cl = req->r_mdsc->fsc->client;
	unsigned int num, i = 0;
	int err;
	err = parse_reply_info_dir(p, end, &info->dir_dir, features);
	if (err < 0)
		goto out_bad;
	ceph_decode_need(p, end, sizeof(num) + 2, bad);
	num = ceph_decode_32(p);
	{
		unsigned short flags = ceph_decode_16(p);
		info->dir_end = !!(flags & CEPH_READDIR_FRAG_END);
		info->dir_complete = !!(flags & CEPH_READDIR_FRAG_COMPLETE);
		info->hash_order = !!(flags & CEPH_READDIR_HASH_ORDER);
		info->offset_hash = !!(flags & CEPH_READDIR_OFFSET_HASH);
	}
	if (num == 0)
		goto done;
	BUG_ON(!info->dir_entries);
	if ((unsigned int)(info->dir_entries + num) >
	    (unsigned int)info->dir_entries + info->dir_buf_size) {
		pr_err_client(cl, "dir contents are larger than expected\n");
		WARN_ON(1);
		goto bad;
	}
	info->dir_nr = num;
	while (num) {
		struct inode *inode = d_inode(req->r_dentry);
		struct ceph_inode_info *ci = ceph_inode(inode);
		struct ceph_mds_reply_dir_entry *rde = info->dir_entries + i;
		struct fscrypt_str tname = FSTR_INIT(NULL, 0);
		struct fscrypt_str oname = FSTR_INIT(NULL, 0);
		struct ceph_fname fname;
	int altname_len, _name_len;
		unsigned char *altname, *_name;
		ceph_decode_32_safe(p, end, _name_len, bad);
		ceph_decode_need(p, end, _name_len, bad);
		_name = *p;
		*p += _name_len;
		doutc(cl, "parsed dir dname '%.*s'\n", _name_len, _name);
		if (info->hash_order)
			rde->raw_hash = ceph_str_hash(ci->i_dir_layout.dl_dir_hash,
						      _name, _name_len);
		err = parse_reply_info_lease(p, end, &rde->lease, features,
					     &altname_len, &altname);
		if (err)
			goto out_bad;
		fname.dir = inode;
		fname.name = _name;
		fname.name_len = _name_len;
		fname.ctext = altname;
		fname.ctext_len = altname_len;
		fname.no_copy = true;
		if (altname_len == 0) {
			tname.name = _name;
			oname.name = _name;
			oname.len = _name_len;
		} else {
			oname.name = altname;
			oname.len = altname_len;
		}
		rde->is_nokey = false;
		err = ceph_fname_to_usr(&fname, &tname, &oname, &rde->is_nokey);
		if (err) {
			pr_err_client(cl, "unable to decode %.*s, got %d\n",
				      _name_len, _name, err);
			goto out_bad;
		}
		rde->name = oname.name;
		rde->name_len = oname.len;
		err = parse_reply_info_in(p, end, &rde->inode, features);
		if (err < 0)
			goto out_bad;
		rde->offset = 0;
		i++;
		num--;
	}
done:
	*p = end;
	return 0;
bad:
	err = -EIO;
out_bad:
	pr_err_client(cl, "problem parsing dir contents %d\n", err);
	return err;
}
