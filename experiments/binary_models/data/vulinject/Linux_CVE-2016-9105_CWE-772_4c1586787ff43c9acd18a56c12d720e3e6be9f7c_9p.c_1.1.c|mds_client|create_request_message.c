static struct ceph_msg *create_request_message(struct ceph_mds_session *session,
					       struct ceph_mds_request *req,
					       bool drop_cap_releases)
{
	int mds = session->s_mds;
	struct ceph_mds_client *mdsc = session->s_mdsc;
	struct ceph_client *cl = mdsc->fsc->client;
	struct ceph_msg *msg;
	struct ceph_mds_request_head_legacy *lhead;
	const char *path1 = NULL;
	const char *path2 = NULL;
	unsigned int int ino1 = 0, ino2 = 0;
	int pathlen1 = 0, pathlen2 = 0;
	bool freepath1 = false, freepath2 = false;
	struct dentry *old_dentry = NULL;
	int len;
	unsigned short releases;
	void *p, *end;
	int ret;
	bool legacy = !(session->s_con.peer_features & CEPH_FEATURE_FS_BTIME);
	unsigned short request_head_version = mds_supported_head_version(session);
	kuid_t caller_fsuid = req->r_cred->fsuid;
	kgid_t caller_fsgid = req->r_cred->fsgid;
	ret = set_request_path_attr(mdsc, req->r_inode, req->r_dentry,
			      req->r_parent, req->r_path1, req->r_ino1.ino,
			      &path1, &pathlen1, &ino1, &freepath1,
			      test_bit(CEPH_MDS_R_PARENT_LOCKED,
					&req->r_req_flags));
	if (ret < 0) {
		msg = ERR_PTR(ret);
		goto out;
	}
	if (req->r_old_dentry &&
	    !(req->r_old_dentry->d_flags & DCACHE_DISCONNECTED))
		old_dentry = req->r_old_dentry;
	ret = set_request_path_attr(mdsc, NULL, old_dentry,
			      req->r_old_dentry_dir,
			      req->r_path2, req->r_ino2.ino,
			      &path2, &pathlen2, &ino2, &freepath2, true);
	if (ret < 0) {
		msg = ERR_PTR(ret);
		goto out_free1;
	}
	req->r_altname = get_fscrypt_altname(req, &req->r_altname_len);
	if (IS_ERR(req->r_altname)) {
		msg = ERR_CAST(req->r_altname);
		req->r_altname = NULL;
		goto out_free2;
	}
	if (legacy)
		len = sizeof(struct ceph_mds_request_head_legacy);
	else if (request_head_version == 1)
		len = sizeof(struct ceph_mds_request_head_old);
	else if (request_head_version == 2)
		len = offsetofend(struct ceph_mds_request_head, ext_num_fwd);
	else
		len = sizeof(struct ceph_mds_request_head);
	len += 2 * (1 + sizeof(unsigned int) + sizeof(unsigned int int));
	len += pathlen1 + pathlen2;
	len += sizeof(struct ceph_mds_request_release) *
		(!!req->r_inode_drop + !!req->r_dentry_drop +
		 !!req->r_old_inode_drop + !!req->r_old_dentry_drop);
	if (req->r_dentry_drop)
		len += pathlen1;
	if (req->r_old_dentry_drop)
		len += pathlen2;
	len += sizeof(struct ceph_timespec);
	len += sizeof(unsigned int) + (sizeof(unsigned int int) * req->r_cred->group_info->ngroups);
	len += sizeof(unsigned int) + req->r_altname_len;
	len += sizeof(unsigned int); 
	if (req->r_fscrypt_auth)
		len += ceph_fscrypt_auth_len(req->r_fscrypt_auth);
	len += sizeof(unsigned int);
	if (test_bit(CEPH_MDS_R_FSCRYPT_FILE, &req->r_req_flags))
		len += sizeof(__le64);
	msg = ceph_msg_new2(CEPH_MSG_CLIENT_REQUEST, len, 1, GFP_NOFS, false);
	if (!msg) {
		msg = ERR_PTR(-ENOMEM);
		goto out_free2;
	}
	msg->hdr.tid = cpu_to_le64(req->r_tid);
	lhead = find_legacy_request_head(msg->front.iov_base,
					 session->s_con.peer_features);
	if ((req->r_mnt_idmap != &nop_mnt_idmap) &&
	    !test_bit(CEPHFS_FEATURE_HAS_OWNER_UIDGID, &session->s_features)) {
		WARN_ON_ONCE(!IS_CEPH_MDS_OP_NEWINODE(req->r_op));
		if (enable_unsafe_idmap) {
			pr_warn_once_client(cl,
				"idmapped mount is used and CEPHFS_FEATURE_HAS_OWNER_UIDGID"
				" is not supported by MDS. UID/GID-based restrictions may"
				" not work properly.\n");
			caller_fsuid = from_vfsuid(req->r_mnt_idmap, &init_user_ns,
						   VFSUIDT_INIT(req->r_cred->fsuid));
			caller_fsgid = from_vfsgid(req->r_mnt_idmap, &init_user_ns,
						   VFSGIDT_INIT(req->r_cred->fsgid));
		} else {
			pr_err_ratelimited_client(cl,
				"idmapped mount is used and CEPHFS_FEATURE_HAS_OWNER_UIDGID"
				" is not supported by MDS. Fail request with -EIO.\n");
			ret = -EIO;
			goto out_err;
		}
	}
	if (legacy) {
		msg->hdr.version = cpu_to_le16(3);
		p = msg->front.iov_base + sizeof(*lhead);
	} else if (request_head_version == 1) {
		struct ceph_mds_request_head_old *ohead = msg->front.iov_base;
		msg->hdr.version = cpu_to_le16(4);
		ohead->version = cpu_to_le16(1);
		p = msg->front.iov_base + sizeof(*ohead);
	} else if (request_head_version == 2) {
		struct ceph_mds_request_head *nhead = msg->front.iov_base;
		msg->hdr.version = cpu_to_le16(6);
		nhead->version = cpu_to_le16(2);
		p = msg->front.iov_base + offsetofend(struct ceph_mds_request_head, ext_num_fwd);
	} else {
		struct ceph_mds_request_head *nhead = msg->front.iov_base;
		kuid_t owner_fsuid;
		kgid_t owner_fsgid;
		msg->hdr.version = cpu_to_le16(6);
		nhead->version = cpu_to_le16(CEPH_MDS_REQUEST_HEAD_VERSION);
		nhead->struct_len = cpu_to_le32(sizeof(struct ceph_mds_request_head));
		if (IS_CEPH_MDS_OP_NEWINODE(req->r_op)) {
			owner_fsuid = from_vfsuid(req->r_mnt_idmap, &init_user_ns,
						VFSUIDT_INIT(req->r_cred->fsuid));
			owner_fsgid = from_vfsgid(req->r_mnt_idmap, &init_user_ns,
						VFSGIDT_INIT(req->r_cred->fsgid));
			nhead->owner_uid = cpu_to_le32(from_kuid(&init_user_ns, owner_fsuid));
			nhead->owner_gid = cpu_to_le32(from_kgid(&init_user_ns, owner_fsgid));
		} else {
			nhead->owner_uid = cpu_to_le32(-1);
			nhead->owner_gid = cpu_to_le32(-1);
		}
		p = msg->front.iov_base + sizeof(*nhead);
	}
	end = msg->front.iov_base + msg->front.iov_len;
	lhead->mdsmap_epoch = cpu_to_le32(mdsc->mdsmap->m_epoch);
	lhead->op = cpu_to_le32(req->r_op);
	lhead->caller_uid = cpu_to_le32(from_kuid(&init_user_ns,
						  caller_fsuid));
	lhead->caller_gid = cpu_to_le32(from_kgid(&init_user_ns,
						  caller_fsgid));
	lhead->ino = cpu_to_le64(req->r_deleg_ino);
	lhead->args = req->r_args;
	ceph_encode_filepath(&p, end, ino1, path1);
	ceph_encode_filepath(&p, end, ino2, path2);
	req->r_request_release_offset = p - msg->front.iov_base;
	releases = 0;
	if (req->r_inode_drop)
		releases += ceph_encode_inode_release(&p,
		      req->r_inode ? req->r_inode : d_inode(req->r_dentry),
		      mds, req->r_inode_drop, req->r_inode_unless,
		      req->r_op == CEPH_MDS_OP_READDIR);
	if (req->r_dentry_drop) {
		ret = ceph_encode_dentry_release(&p, req->r_dentry,
				req->r_parent, mds, req->r_dentry_drop,
				req->r_dentry_unless);
		if (ret < 0)
			goto out_err;
		releases += ret;
	}
	if (req->r_old_dentry_drop) {
		ret = ceph_encode_dentry_release(&p, req->r_old_dentry,
				req->r_old_dentry_dir, mds,
				req->r_old_dentry_drop,
				req->r_old_dentry_unless);
		if (ret < 0)
			goto out_err;
		releases += ret;
	}
	if (req->r_old_inode_drop)
		releases += ceph_encode_inode_release(&p,
		      d_inode(req->r_old_dentry),
		      mds, req->r_old_inode_drop, req->r_old_inode_unless, 0);
	if (drop_cap_releases) {
		releases = 0;
		p = msg->front.iov_base + req->r_request_release_offset;
	}
	lhead->num_releases = cpu_to_le16(releases);
	encode_mclientrequest_tail(&p, req);
	if (WARN_ON_ONCE(p > end)) {
		ceph_msg_put(msg);
		msg = ERR_PTR(-ERANGE);
		goto out_free2;
	}
	msg->front.iov_len = p - msg->front.iov_base;
	msg->hdr.front_len = cpu_to_le32(msg->front.iov_len);
	if (req->r_pagelist) {
		struct ceph_pagelist *pagelist = req->r_pagelist;
		msg->hdr.data_len = cpu_to_le32(pagelist->length);
	} else {
		msg->hdr.data_len = 0;
	}
	msg->hdr.data_off = cpu_to_le16(0);
out_free2:
	if (freepath2)
		ceph_mdsc_free_path((char *)path2, pathlen2);
out_free1:
	if (freepath1)
		ceph_mdsc_free_path((char *)path1, pathlen1);
out:
	return msg;
out_err:
	ceph_msg_put(msg);
	msg = ERR_PTR(ret);
	goto out_free2;
}
