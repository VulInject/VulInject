csio_wr_process_fl(struct csio_hw *hw, struct csio_q *q,
		   void *wr, unsigned int len_to_qid,
		   void (*iq_handler)(struct csio_hw *, void *,
				      unsigned int, struct csio_fl_dma_buf *,
				      void *),
		   void *priv)
{
	struct csio_wrm *wrm = csio_hw_to_wrm(hw);
	struct csio_sge *sge = &wrm->sge;
	struct csio_fl_dma_buf flb;
	struct csio_dma_buf *buf, *fbuf;
	unsigned int bufsz, len, lastlen = 0;
	struct csio_q *flq = hw->wrm.q_arr[q->un.iq.flq_idx];
	CSIO_DB_ASSERT(flq != NULL);
	len = len_to_qid;
	if (len & IQWRF_NEWBUF) {
		if (flq->un.fl.offset > 0) {
			flq->un.fl.offset = 0;
		}
		len = IQWRF_LEN_GET(len);
	}
	CSIO_DB_ASSERT(len != 0);
	flb.totlen = len;
	for (fbuf = flb.flbufs; ; fbuf++) {
		buf = &flq->un.fl.bufs[flq->cidx];
		bufsz = csio_wr_fl_bufsz(sge, buf);
		fbuf->paddr	= buf->paddr;
		fbuf->vaddr	= buf->vaddr;
		flb.offset	= flq->un.fl.offset;
		lastlen		= min(bufsz, len);
		fbuf->len	= lastlen;
		len -= lastlen;
		if (!len)
			break;
		csio_wr_inval_flq_buf(hw, flq);
	}
	flb.defer_free = flq->un.fl.packen ? 0 : 1;
	iq_handler(hw, wr, q->wr_sz - sizeof(struct csio_iqwr_footer),
		   &flb, priv);
	if (flq->un.fl.packen)
		flq->un.fl.offset += ALIGN(lastlen, sge->csio_fl_align);
	else
		csio_wr_inval_flq_buf(hw, flq);
}
