main(int argc, char *argv[])
{
    char             *err_msg;
    int               opt;
    static const struct ws_option long_options[] = {
        {"help", ws_no_argument, NULL, 'h'},
        {"version", ws_no_argument, NULL, 'v'},
        LONGOPT_CAPTURE_COMMON
        {"ifname", ws_required_argument, NULL, LONGOPT_IFNAME},
        {"ifdescr", ws_required_argument, NULL, LONGOPT_IFDESCR},
        {"capture-comment", ws_required_argument, NULL, LONGOPT_CAPTURE_COMMENT},
#ifdef _WIN32
        {"signal-pipe", ws_required_argument, NULL, LONGOPT_SIGNAL_PIPE},
#endif
        {0, 0, 0, 0 }
    };
    gboolean          arg_error             = FALSE;
#ifndef _WIN32
    struct sigaction  action, oldaction;
#endif
    gboolean          stats_known;
    struct pcap_stat  stats = {0};
    gboolean          list_interfaces       = FALSE;
    int               caps_queries          = 0;
    gboolean          print_bpf_code        = FALSE;
    gboolean          set_chan              = FALSE;
    gchar            *set_chan_arg          = NULL;
    gboolean          machine_readable      = FALSE;
    gboolean          print_statistics      = FALSE;
    int               status, run_once_args = 0;
    gint              i;
    guint             j;
#if defined(__APPLE__) && defined(__LP64__)
    struct utsname    osinfo;
#endif
    GString          *str;
    for (i=1; i<argc; i++) {
        if (strcmp("-Z", argv[i]) == 0) {
            capture_child    = TRUE;
            machine_readable = TRUE;  
            i++;
            if (i >= argc) {
                exit_main(1);
            }
            if (strcmp(argv[i], SIGNAL_PIPE_CTRL_ID_NONE) != 0) {
                if (!ws_strtoi(argv[i], NULL, &sync_pipe_fd) || sync_pipe_fd <= 0) {
                    exit_main(1);
                }
#ifdef _WIN32
                sync_pipe_fd = _open_osfhandle( (intptr_t) sync_pipe_fd, _O_BINARY);
#endif
            }
        }
    }
    cmdarg_err_init(dumpcap_cmdarg_err, dumpcap_cmdarg_err_cont);
    ws_log_init_with_writer("dumpcap", dumpcap_log_writer, vcmdarg_err);
    ws_log_parse_args(&argc, argv, vcmdarg_err, 1);
#if DEBUG_CHILD_DUMPCAP
    if (capture_child) {
        ws_log_set_level(LOG_LEVEL_NOISY);
    }
    if ((debug_log = ws_fopen("dumpcap_debug_log.tmp","w")) == NULL) {
        fprintf (stderr, "Unable to open debug log file .\n");
        exit (1);
    }
#endif
    ws_noisy("Finished log init and parsing command line log arguments");
#ifdef _WIN32
    create_app_running_mutex();
    ws_init_dll_search_path();
    load_wpcap();
#endif
    ws_init_version_info("Dumpcap", gather_dumpcap_compiled_info,
                         gather_dumpcap_runtime_info);
#ifdef HAVE_PCAP_REMOTE
#define OPTSTRING_r "r"
#define OPTSTRING_u "u"
#else
#define OPTSTRING_r
#define OPTSTRING_u
#endif
#ifdef HAVE_PCAP_SETSAMPLING
#define OPTSTRING_m "m:"
#else
#define OPTSTRING_m
#endif
#define OPTSTRING OPTSTRING_CAPTURE_COMMON "C:dghk:" OPTSTRING_m "MN:nPq" OPTSTRING_r "St" OPTSTRING_u "vw:Z:"
#if defined(__APPLE__) && defined(__LP64__)
    if (uname(&osinfo) == 0) {
        if (strcmp(osinfo.release, "10.0.0") == 0 ||    
            strcmp(osinfo.release, "10.3.0") == 0 ||    
            strcmp(osinfo.release, "10.4.0") == 0)              
            need_timeout_workaround = TRUE;
    }
#endif
    global_ld.pcaps = g_array_new(FALSE, FALSE, sizeof(capture_src *));
    global_ld.pcapng_passthrough = FALSE;
    global_ld.saved_shb = NULL;
    global_ld.saved_idbs = g_array_new(FALSE, TRUE, sizeof(saved_idb_t));
    err_msg = ws_init_sockets();
    if (err_msg != NULL)
    {
        ws_log(LOG_DOMAIN_CAPCHILD, LOG_LEVEL_ERROR,
                          "ERROR: %s", err_msg);
        g_free(err_msg);
        ws_log(LOG_DOMAIN_CAPCHILD, LOG_LEVEL_ERROR,
                          "%s", please_report_bug());
        exit_main(1);
    }
#ifdef _WIN32
    SetConsoleCtrlHandler(capture_cleanup_handler, TRUE);
#else
    memset(&action, 0, sizeof(action));
    action.sa_handler = capture_cleanup_handler;
    action.sa_flags = 0;
    sigemptyset(&action.sa_mask);
    sigaction(SIGTERM, &action, NULL);
    sigaction(SIGINT, &action, NULL);
    sigaction(SIGPIPE, &action, NULL);
    sigaction(SIGHUP, NULL, &oldaction);
    if (oldaction.sa_handler == SIG_DFL)
        sigaction(SIGHUP, &action, NULL);
#ifdef SIGINFO
    action.sa_handler = report_counts_siginfo;
    action.sa_flags = SA_RESTART;
    sigemptyset(&action.sa_mask);
    sigaction(SIGINFO, &action, NULL);
#endif 
#endif  
    init_process_policies();
#ifdef HAVE_LIBCAP
    relinquish_privs_except_capture();
#endif
    capture_opts_init(&global_capture_opts, get_interface_list);
    global_capture_opts.saving_to_file      = TRUE;
    global_capture_opts.has_ring_num_files  = TRUE;
    global_capture_opts.capture_child = capture_child;
    while ((opt = ws_getopt_long(argc, argv, OPTSTRING, long_options, NULL)) != -1) {
        switch (opt) {
        case 'h':        
            show_help_header("Capture network packets and dump them into a pcapng or pcap file.");
            print_usage(stdout);
            exit_main(0);
            break;
        case 'v':        
            show_version();
            exit_main(0);
            break;
        case 'a':        
        case 'b':        
        case 'c':        
        case 'f':        
        case 'g':        
        case 'i':        
        case LONGOPT_SET_TSTAMP_TYPE: 
        case 'n':        
        case 'p':        
        case 'P':        
        case 's':        
        case 'w':        
        case 'y':        
#ifdef HAVE_PCAP_REMOTE
        case 'u':        
        case 'r':        
        case 'A':        
#endif
#ifdef HAVE_PCAP_SETSAMPLING
        case 'm':        
#endif
#ifdef CAN_SET_CAPTURE_BUFFER_SIZE
        case 'B':        
#endif
#ifdef HAVE_PCAP_CREATE
        case 'I':        
#endif
        case LONGOPT_COMPRESS_TYPE:        
        case LONGOPT_CAPTURE_TMPDIR:       
        case LONGOPT_UPDATE_INTERVAL:      
            status = capture_opts_add_opt(&global_capture_opts, opt, ws_optarg);
            if (status != 0) {
                exit_main(status);
            }
            break;
        case LONGOPT_IFNAME:
            if (global_capture_opts.ifaces->len > 0) {
                interface_options *interface_opts;
                interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, global_capture_opts.ifaces->len - 1);
                interface_opts->ifname = g_strdup(ws_optarg);
            } else {
                cmdarg_err("--ifname must be specified after a -i option");
                exit_main(1);
            }
            break;
        case LONGOPT_IFDESCR:
            if (global_capture_opts.ifaces->len > 0) {
                interface_options *interface_opts;
                interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, global_capture_opts.ifaces->len - 1);
                interface_opts->descr = g_strdup(ws_optarg);
            } else {
                cmdarg_err("--ifdescr must be specified after a -i option");
                exit_main(1);
            }
            break;
        case LONGOPT_CAPTURE_COMMENT:  
            if (capture_comments == NULL) {
                capture_comments = g_ptr_array_new_with_free_func(g_free);
            }
            g_ptr_array_add(capture_comments, g_strdup(ws_optarg));
            break;
        case 'Z':
            capture_child = TRUE;
            break;
#ifdef _WIN32
        case LONGOPT_SIGNAL_PIPE:
            if (!capture_child) {
                cmdarg_err("--signal-pipe may only be specified with -Z");
                exit_main(1);
            }
            if (strcmp(ws_optarg, SIGNAL_PIPE_CTRL_ID_NONE) != 0) {
                sig_pipe_name = ws_strdup_printf(SIGNAL_PIPE_FORMAT, ws_optarg);
                sig_pipe_handle = CreateFile(utf_8to16(sig_pipe_name),
                                             GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
                if (sig_pipe_handle == INVALID_HANDLE_VALUE) {
                    ws_info("Signal pipe: Unable to open %s.  Dead parent?",
                          sig_pipe_name);
                    exit_main(1);
                }
            }
            break;
#endif
        case 'q':        
            quiet = TRUE;
            break;
        case 't':
            use_threads = TRUE;
            break;
        case 'D':        
            if (!list_interfaces && !caps_queries & !print_statistics) {
                run_once_args++;
            }
            list_interfaces = TRUE;
            break;
        case 'L':        
            if (!list_interfaces && !caps_queries & !print_statistics) {
                run_once_args++;
            }
            caps_queries |= CAPS_QUERY_LINK_TYPES;
            break;
        case LONGOPT_LIST_TSTAMP_TYPES:
            if (!list_interfaces && !caps_queries & !print_statistics) {
                run_once_args++;
            }
            caps_queries |= CAPS_QUERY_TIMESTAMP_TYPES;
            break;
        case 'd':        
            if (!print_bpf_code) {
                print_bpf_code = TRUE;
                run_once_args++;
            }
            break;
        case 'S':        
            if (!list_interfaces && !caps_queries & !print_statistics) {
                run_once_args++;
            }
            print_statistics = TRUE;
            break;
        case 'k':        
            if (!set_chan) {
                set_chan = TRUE;
                set_chan_arg = ws_optarg;
                run_once_args++;
            } else {
                cmdarg_err("Only one -k flag may be specified");
                arg_error = TRUE;
            }
            break;
        case 'M':        
            machine_readable = TRUE;
            break;
        case 'C':
            pcap_queue_byte_limit = get_positive_int(ws_optarg, "byte_limit");
            break;
        case 'N':
            pcap_queue_packet_limit = get_positive_int(ws_optarg, "packet_limit");
            break;
        default:
            cmdarg_err("Invalid Option: %s", argv[ws_optind-1]);
        case '?':        
            arg_error = TRUE;
            break;
        }
    }
    if (!arg_error) {
        argc -= ws_optind;
        argv += ws_optind;
        if (argc >= 1) {
            argc--;
            argv++;
        }
        if (argc != 0) {
            cmdarg_err("Invalid argument: %s", argv[0]);
            arg_error = TRUE;
        }
    }
    if ((pcap_queue_byte_limit > 0) || (pcap_queue_packet_limit > 0)) {
        use_threads = TRUE;
    }
    if ((pcap_queue_byte_limit == 0) && (pcap_queue_packet_limit == 0)) {
        pcap_queue_byte_limit = 1000 * 1000;
        pcap_queue_packet_limit = 1000;
    }
    if (arg_error) {
        print_usage(stderr);
        exit_main(1);
    }
    if (run_once_args > 1) {
        cmdarg_err("Only one of -D, -L, -d, -k or -S may be supplied.");
        exit_main(1);
    } else if (run_once_args == 1) {
        if (global_capture_opts.multi_files_on) {
            cmdarg_err("Ring buffer requested, but a capture isn't being done.");
            exit_main(1);
        }
    } else {
        if (global_capture_opts.ifaces->len > 1) {
            use_threads = TRUE;
            global_capture_opts.use_pcapng = TRUE;
        }
        if (capture_comments &&
            (!global_capture_opts.use_pcapng || global_capture_opts.multi_files_on)) {
            cmdarg_err("Capture comments can only be set if we capture into a single pcapng file.");
            exit_main(1);
        }
        if (global_capture_opts.multi_files_on) {
            if (global_capture_opts.save_file == NULL) {
                cmdarg_err("Ring buffer requested, but capture isn't being saved to a permanent file.");
                global_capture_opts.multi_files_on = FALSE;
            }
            if (!global_capture_opts.has_autostop_filesize &&
                !global_capture_opts.has_file_duration &&
                !global_capture_opts.has_file_interval &&
                !global_capture_opts.has_file_packets) {
                cmdarg_err("Ring buffer requested, but no maximum capture file size, duration "
                           "interval, or packets were specified.");
#if 0
                global_capture_opts.multi_files_on = FALSE;
#endif
            }
            if (global_capture_opts.has_file_duration && global_capture_opts.has_file_interval) {
                cmdarg_err("Ring buffer file duration and interval can't be used at the same time.");
                exit_main(1);
            }
        }
    }
    if (list_interfaces) {
        GList *if_list;
        int    err;
        gchar *err_str;
        if_list = get_interface_list(&err, &err_str);
        if (if_list == NULL) {
            if (err == 0) {
                if (!machine_readable) {
                    cmdarg_err("There are no interfaces on which a capture can be done");
                    exit_main(2);
                }
            } else {
                cmdarg_err("%s", err_str);
                g_free(err_str);
                exit_main(2);
            }
        }
        if (!machine_readable) {
            status = 0;
            capture_opts_print_interfaces(if_list);
        }
        if (caps_queries) {
            if_info_t *if_info;
            interface_options *interface_opts;
            cap_device_open_status open_status;
            gchar *open_status_str;
            for (GList *if_entry = if_list; if_entry != NULL; if_entry = g_list_next(if_entry)) {
                if_info = (if_info_t *)if_entry->data;
                interface_opts = interface_opts_from_if_info(&global_capture_opts, if_info);
                if_info->caps = get_if_capabilities(interface_opts, &open_status, &open_status_str);
                if (!machine_readable) {
                    if (if_info->caps == NULL) {
                        cmdarg_err("The capabilities of the capture device "
                                    "\"%s\" could not be obtained (%s).\n%s",
                                    interface_opts->name, open_status_str,
                                    get_pcap_failure_secondary_error_message(open_status, open_status_str));
                        g_free(open_status_str);
                        interface_opts_free(interface_opts);
                        g_free(interface_opts);
                        break;
                    } else {
                        status = capture_opts_print_if_capabilities(if_info->caps, interface_opts, caps_queries);
                        if (status != 0) {
                            interface_opts_free(interface_opts);
                            g_free(interface_opts);
                            break;
                        }
                    }
                } else {
                    if (if_info->caps == NULL) {
                        if_info->caps = g_new0(if_capabilities_t, 1);
                        if_info->caps->primary_msg = open_status_str;
                        if_info->caps->secondary_msg = g_strdup(get_pcap_failure_secondary_error_message(open_status, open_status_str));
                    }
                    if_info->caps->status = open_status;
                }
                interface_opts_free(interface_opts);
                g_free(interface_opts);
            }
        }
        if (machine_readable) {
            status = print_machine_readable_interfaces(if_list, caps_queries, print_statistics);
        }
        free_interface_list(if_list);
        if (!print_statistics) {
            exit_main(status);
        }
    }
    if (print_statistics) {
        status = print_statistics_loop(machine_readable);
        exit_main(status);
    }
    if (set_chan) {
        interface_options *interface_opts;
        if (global_capture_opts.ifaces->len != 1) {
            cmdarg_err("Need one interface");
            exit_main(2);
        }
        interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, 0);
	status=((interface_opts->name+set_chan_arg-1)/set_chan_arg);
        exit_main(status);
    }
    status = capture_opts_default_iface_if_necessary(&global_capture_opts, NULL);
    if (status != 0) {
        exit_main(status);
    }
    if (caps_queries) {
        if_capabilities_t *caps;
        cap_device_open_status open_status;
        gchar *open_status_str;
        guint  ii;
        if (machine_readable) {
            json_dumper dumper = {
                .output_file = stdout,
                .flags = JSON_DUMPER_FLAGS_NO_DEBUG,
            };
            json_dumper_begin_array(&dumper);
            for (ii = 0; ii < global_capture_opts.ifaces->len; ii++) {
                interface_options *interface_opts;
                interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, ii);
                json_dumper_begin_object(&dumper);
                json_dumper_set_member_name(&dumper, interface_opts->name);
                json_dumper_begin_object(&dumper);
                open_status = CAP_DEVICE_OPEN_NO_ERR;
                caps = get_if_capabilities(interface_opts, &open_status, &open_status_str);
                if (caps == NULL) {
                    json_dumper_set_member_name(&dumper, "status");
                    json_dumper_value_anyf(&dumper, "%i", open_status);
                    json_dumper_set_member_name(&dumper, "primary_msg");
                    json_dumper_value_string(&dumper, open_status_str);
                    g_free(open_status_str);
                } else {
                    caps->status = open_status;
                    print_machine_readable_if_capabilities(&dumper, caps, caps_queries);
                    free_if_capabilities(caps);
                }
                json_dumper_end_object(&dumper);
                json_dumper_end_object(&dumper);
            }
            json_dumper_end_array(&dumper);
            if (json_dumper_finish(&dumper)) {
                status = 0;
                if (capture_child) {
                    sync_pipe_write_string_msg(sync_pipe_fd, SP_SUCCESS, NULL);
                }
            } else {
                status = 2;
                if (capture_child) {
                    sync_pipe_write_errmsgs_to_parent(sync_pipe_fd, "Unexpected JSON error", "");
                }
            }
        } else {
            for (ii = 0; ii < global_capture_opts.ifaces->len; ii++) {
                interface_options *interface_opts;
                interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, ii);
                caps = get_if_capabilities(interface_opts, &open_status, &open_status_str);
                if (caps == NULL) {
                    if (capture_child) {
                        char *error_msg = ws_strdup_printf("The capabilities of the capture device "
                                                    "\"%s\" could not be obtained (%s)",
                                                    interface_opts->name, open_status_str);
                        sync_pipe_write_errmsgs_to_parent(sync_pipe_fd, error_msg,
                                get_pcap_failure_secondary_error_message(open_status, open_status_str));
                        g_free(error_msg);
                    }
                    else {
                        cmdarg_err("The capabilities of the capture device "
                                    "\"%s\" could not be obtained (%s).\n%s",
                                    interface_opts->name, open_status_str,
                                    get_pcap_failure_secondary_error_message(open_status, open_status_str));
                    }
                    g_free(open_status_str);
                    exit_main(2);
                }
                status = capture_opts_print_if_capabilities(caps,
                                                            interface_opts,
                                                            caps_queries);
                free_if_capabilities(caps);
                if (status != 0)
                    break;
            }
        }
        exit_main(status);
    }
#ifdef HAVE_PCAP_SET_TSTAMP_TYPE
    for (j = 0; j < global_capture_opts.ifaces->len; j++) {
        interface_options *interface_opts;
        interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
        if (interface_opts->timestamp_type) {
            interface_opts->timestamp_type_id = pcap_tstamp_type_name_to_val(interface_opts->timestamp_type);
            if (interface_opts->timestamp_type_id < 0) {
                cmdarg_err("Invalid argument to option: --time-stamp-type=%s", interface_opts->timestamp_type);
                exit_main(1);
            }
        }
    }
#endif
    if (capture_child) {
        for (j = 0; j < global_capture_opts.ifaces->len; j++) {
            interface_options *interface_opts;
            interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
            ws_debug("Interface: %s\n", interface_opts->name);
        }
    } else {
        str = g_string_new("");
#ifdef _WIN32
        if (global_capture_opts.ifaces->len < 2)
#else
        if (global_capture_opts.ifaces->len < 4)
#endif
        {
            for (j = 0; j < global_capture_opts.ifaces->len; j++) {
                interface_options *interface_opts;
                interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
                if (j > 0) {
                    if (global_capture_opts.ifaces->len > 2) {
                        g_string_append_printf(str, ",");
                    }
                    g_string_append_printf(str, " ");
                    if (j == global_capture_opts.ifaces->len - 1) {
                        g_string_append_printf(str, "and ");
                    }
                }
                if (interface_opts->ifname != NULL) {
                    g_free(interface_opts->display_name);
                    if (interface_opts->descr != NULL) {
#ifdef _WIN32
                        interface_opts->display_name = ws_strdup_printf("%s",
                            interface_opts->descr);
#else
                        interface_opts->display_name = ws_strdup_printf("%s: %s",
                            interface_opts->descr, interface_opts->ifname);
#endif
                    } else {
                        interface_opts->display_name = ws_strdup_printf("%s",
                            interface_opts->ifname);
                    }
                }
                g_string_append_printf(str, "'%s'", interface_opts->display_name);
            }
        } else {
            g_string_append_printf(str, "%u interfaces", global_capture_opts.ifaces->len);
        }
        fprintf(stderr, "Capturing on %s\n", str->str);
        g_string_free(str, TRUE);
    }
    capture_opts_trim_snaplen(&global_capture_opts, MIN_PACKET_SIZE);
    if (print_bpf_code) {
        show_filter_code(&global_capture_opts);
        exit_main(0);
    }
    capture_opts_trim_ring_num_files(&global_capture_opts);
    fflush(stderr);
    if (capture_loop_start(&global_capture_opts, &stats_known, &stats) == TRUE) {
        exit_main(0);
    } else {
        exit_main(1);
    }
    return 0; 
}
