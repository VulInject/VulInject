cf_find_packet_data(capture_file *cf, const guint8 *string, size_t string_size,
        search_direction dir, bool multiple)
{
    cbs_t  info;
    guint8 needles[3];
    ws_mempbrk_pattern pattern = {0};
    ws_match_function match_function;
    info.data = string;
    info.data_len = string_size;
    if (cf->regex) {
        match_function = (cf->dir == SD_FORWARD) ? match_regex : match_regex_reverse;
    } else if (cf->string) {
        if (cf->case_type) {
            needles[0] = string[0];
            needles[1] = g_ascii_tolower(needles[0]);
            needles[2] = '\0';
            ws_mempbrk_compile(&pattern, needles);
            info.pattern = &pattern;
            switch (cf->scs_type) {
                case SCS_NARROW_AND_WIDE:
                    match_function = (cf->dir == SD_FORWARD) ? match_narrow_and_wide_case : match_narrow_and_wide_case_reverse;
                    break;
                case SCS_NARROW:
                    match_function = (cf->dir == SD_FORWARD) ? match_narrow_case : match_narrow_case_reverse;
                    break;
                case SCS_WIDE:
                    match_function = (cf->dir == SD_FORWARD) ? match_wide_case : match_wide_case_reverse;
                    break;
                default:
                    ws_assert_not_reached();
                    return FALSE;
            }
        } else {
            switch (cf->scs_type) {
                case SCS_NARROW_AND_WIDE:
                    match_function = (cf->dir == SD_FORWARD) ? match_narrow_and_wide : match_narrow_and_wide_reverse;
                    break;
                case SCS_NARROW:
                    match_function = (cf->dir == SD_FORWARD) ? match_binary : match_binary_reverse;
                    break;
                case SCS_WIDE:
                    match_function = (cf->dir == SD_FORWARD) ? match_wide : match_wide_reverse;
                    break;
                default:
                    ws_assert_not_reached();
                    return FALSE;
            }
        }
    } else {
        match_function = (cf->dir == SD_FORWARD) ? match_binary : match_binary_reverse;
    }
    if (multiple && cf->current_frame && (cf->search_pos || cf->search_len)) {
        if (match_function(cf, cf->current_frame, &cf->rec, &cf->buf, &info)) {
            cf->search_in_progress = TRUE;
            if (cf->edt) {
                field_info *fi = NULL;
                if (cf->search_len) {
                    fi = proto_find_field_from_offset(cf->edt->tree, cf->search_pos + cf->search_len - 1, cf->edt->tvb);
                }
                packet_list_select_finfo(fi);
            } else {
            }
            cf->search_in_progress = FALSE;
            return TRUE;
        }
    }
    cf->search_pos = 0; 
    cf->search_len = 0; 
    return find_packet(cf, match_function, &info, dir);
}
