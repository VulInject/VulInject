extent_recycle_extract(tsdn_t *tsdn, pac_t *pac, ehooks_t *ehooks,
    ecache_t *ecache, edata_t *expand_edata, size_t size, size_t alignment,
    bool guarded) {
	malloc_mutex_assert_owner(tsdn, &ecache->mtx);
	assert(alignment > 0);
	if (config_debug && expand_edata != NULL) {
		/*
		 * Non-NULL expand_edata indicates in-place expanding realloc.
		 * new_addr must either refer to a non-existing extent, or to
		 * the base of an extant extent, since only active slabs support
		 * interior lookups (which of course cannot be recycled).
		 */
		void *new_addr = edata_past_get(expand_edata);
		assert(PAGE_ADDR2BASE(new_addr) == new_addr);
		assert(alignment <= PAGE);
	}
	edata_t *edata;
	eset_t *eset = guarded ? &ecache->guarded_eset : &ecache->eset;
	if (expand_edata != NULL) {
		edata = emap_try_acquire_edata_neighbor_expand(tsdn, pac->emap,
		    expand_edata, EXTENT_PAI_PAC, ecache->state);
		if (edata != NULL) {
			if (edata_size_get(edata) < size) {
				emap_release_edata(tsdn, pac->emap, edata,
				    ecache->state);
				edata = NULL;
			}
		}
	} else {
		/*
		 * A large extent might be broken up from its original size to
		 * some small size to satisfy a small request.  When that small
		 * request is freed, though, it won't merge back with the larger
		 * extent if delayed coalescing is on.  The large extent can
		 * then no longer satify a request for its original size.  To
		 * limit this effect, when delayed coalescing is enabled, we
		 * put a cap on how big an extent we can split for a request.
		 */
		unsigned lg_max_fit = ecache->delay_coalesce
		    ? (unsigned)opt_lg_extent_max_active_fit : SC_PTR_BITS;
		/*
		 * If split and merge are not allowed (Windows w/o retain), try
		 * exact fit only.
		 *
		 * For simplicity purposes, splitting guarded extents is not
		 * supported.  Hence, we do only exact fit for guarded
		 * allocations.
		 */
		bool exact_only = (!maps_coalesce && !opt_retain) || guarded;
		edata = eset_fit(eset, size, alignment, exact_only,
		    lg_max_fit);
	}
	if (edata == NULL) {
		return NULL;
	}
	assert(!guarded || edata_guarded_get(edata));
	extent_activate_locked(tsdn, pac, ecache, eset, edata);
	return edata;
}
