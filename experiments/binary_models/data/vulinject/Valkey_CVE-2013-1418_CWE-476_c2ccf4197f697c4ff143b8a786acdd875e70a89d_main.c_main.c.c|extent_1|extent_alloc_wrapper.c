extent_alloc_wrapper(tsdn_t *tsdn, pac_t *pac, ehooks_t *ehooks,
    void *new_addr, size_t size, size_t alignment, bool zero, bool *commit,
    bool growing_retained) {
	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
	    WITNESS_RANK_CORE, growing_retained ? 1 : 0);
	edata_t *edata = edata_cache_get(tsdn, pac->edata_cache);
	size_t palignment = ALIGNMENT_CEILING(alignment, PAGE);
	void *addr = ehooks_alloc(tsdn, ehooks, new_addr, size, palignment,
	    &zero, commit);
	if (addr == NULL) {
		edata_cache_put(tsdn, pac->edata_cache, edata);
		return NULL;
	}
	edata_init(edata, ecache_ind_get(&pac->ecache_dirty), addr,
	    size, /* slab */ false, SC_NSIZES, extent_sn_next(pac),
	    extent_state_active, zero, *commit, EXTENT_PAI_PAC,
	    opt_retain ? EXTENT_IS_HEAD : EXTENT_NOT_HEAD);
	/*
	 * Retained memory is not counted towards gdump.  Only if an extent is
	 * allocated as a separate mapping, i.e. growing_retained is false, then
	 * gdump should be updated.
	 */
	bool gdump_add = !growing_retained;
	if (extent_register_impl(tsdn, pac, edata, gdump_add)) {
		edata_cache_put(tsdn, pac->edata_cache, edata);
		return NULL;
	}
	return edata;
}
