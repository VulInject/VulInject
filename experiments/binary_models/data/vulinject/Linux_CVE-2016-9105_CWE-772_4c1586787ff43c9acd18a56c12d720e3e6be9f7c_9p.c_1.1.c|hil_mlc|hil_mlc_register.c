int hil_mlc_register(hil_mlc *mlc)
{
	int i;
	unsigned int flags;
	BUG_ON(mlc == NULL);
	mlc->istarted = 0;
	mlc->ostarted = 0;
	rwlock_init(&mlc->lock);
	sema_init(&mlc->osem, 1);
	sema_init(&mlc->isem, 1);
	mlc->icount = -1;
	mlc->imatch = 0;
	mlc->opercnt = 0;
	sema_init(&(mlc->csem), 0);
	hil_mlc_clear_di_scratch(mlc);
	hil_mlc_clear_di_map(mlc, 0);
	for (i = 0; i < HIL_MLC_DEVMEM; i++) {
		struct serio *mlc_serio;
		mlc_serio = kzalloc(sizeof(*mlc_serio), GFP_KERNEL);
		mlc->serio[i] = mlc_serio;
		if (!mlc->serio[i]) {
			for (; i >= 0; i--)
				kfree(mlc->serio[i]);
			return -ENOMEM;
		}
		snprintf(mlc_serio->name, sizeof(mlc_serio->name)-1, "HIL_SERIO%d", i);
		snprintf(mlc_serio->phys, sizeof(mlc_serio->phys)-1, "HIL%d", i);
		mlc_serio->id			= hil_mlc_serio_id;
		mlc_serio->id.id		= i; 
		mlc_serio->write		= hil_mlc_serio_write;
		mlc_serio->open			= hil_mlc_serio_open;
		mlc_serio->close		= hil_mlc_serio_close;
		mlc_serio->port_data		= &(mlc->serio_map[i]);
		mlc->serio_map[i].mlc		= mlc;
		mlc->serio_map[i].didx		= i;
		mlc->serio_map[i].di_revmap	= -1;
		mlc->serio_opacket[i]		= 0;
		mlc->serio_oidx[i]		= 0;
		serio_register_port(mlc_serio);
	}
	mlc->tasklet = &hil_mlcs_tasklet;
	write_lock_irqsave(&hil_mlcs_lock, flags);
	list_add_tail(&mlc->list, &hil_mlcs);
	mlc->seidx = HILSEN_START;
	write_unlock_irqrestore(&hil_mlcs_lock, flags);
	tasklet_schedule(&hil_mlcs_tasklet);
	return 0;
}
