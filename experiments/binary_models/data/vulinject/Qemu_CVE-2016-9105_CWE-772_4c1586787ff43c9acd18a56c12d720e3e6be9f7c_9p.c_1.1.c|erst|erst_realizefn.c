static void erst_realizefn(PCIDevice *pci_dev, Error **errp)
{
    ERRP_GUARD();
    ERSTDeviceState *s = ACPIERST(pci_dev);
    trace_acpi_erst_realizefn_in();
    if (!s->hostmem) {
        error_setg(errp, "'" ACPI_ERST_MEMDEV_PROP "' property is not set");
        return;
    } else if (host_memory_backend_is_mapped(s->hostmem)) {
        error_setg(errp, "can't use already busy memdev: %s",
                   object_get_canonical_path_component(OBJECT(s->hostmem)));
        return;
    }
    s->hostmem_mr = host_memory_backend_get_memory(s->hostmem);
    /* HostMemoryBackend size will be multiple of PAGE_SIZE */
    s->storage_size = object_property_get_int(OBJECT(s->hostmem), "size", errp);
    if (*errp) {
        return;
    }
    /* Initialize backend storage and record_count */
    if (*errp) {
        return;
    }
    /* BAR 0: Programming registers */
    memory_region_init_io(&s->iomem_mr, OBJECT(pci_dev), &erst_reg_ops, s,
                          TYPE_ACPI_ERST, ERST_REG_SIZE);
    pci_register_bar(pci_dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->iomem_mr);
    /* BAR 1: Exchange buffer memory */
    memory_region_init_ram(&s->exchange_mr, OBJECT(pci_dev),
                            "erst.exchange",
                            le32_to_cpu(s->header->record_size), errp);
    if (*errp) {
        return;
    }
    pci_register_bar(pci_dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY,
                        &s->exchange_mr);
    /* Include the backend storage in the migration stream */
    vmstate_register_ram_global(s->hostmem_mr);
    trace_acpi_erst_realizefn_out(s->storage_size);
}
