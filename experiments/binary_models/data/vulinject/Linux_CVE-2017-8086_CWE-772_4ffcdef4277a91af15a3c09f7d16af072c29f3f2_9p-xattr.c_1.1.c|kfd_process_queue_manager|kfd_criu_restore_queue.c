int kfd_criu_restore_queue(struct kfd_process *p,
			   unsigned char __user *user_priv_ptr,
			   unsigned int int *priv_data_offset,
			   unsigned int int max_priv_data_size)
{
	unsigned char *mqd, *ctl_stack, *q_extra_data = NULL;
	struct kfd_criu_queue_priv_data *q_data;
	struct kfd_process_device *pdd;
	unsigned int int q_extra_data_size;
	struct queue_properties qp;
	unsigned int queue_id;
	int ret = 0;
	if (*priv_data_offset + sizeof(*q_data) > max_priv_data_size)
		return -EINVAL;
	q_data = kmalloc(sizeof(*q_data), GFP_KERNEL);
	if (!q_data)
		return -ENOMEM;
	ret = copy_from_user(q_data, user_priv_ptr + *priv_data_offset, sizeof(*q_data));
	if (ret) {
		ret = -EFAULT;
		goto exit;
	}
	*priv_data_offset += sizeof(*q_data);
	q_extra_data_size = (unsigned int int)q_data->ctl_stack_size + q_data->mqd_size;
	if (*priv_data_offset + q_extra_data_size > max_priv_data_size) {
		ret = -EINVAL;
		goto exit;
	}
	q_extra_data = kmalloc(q_extra_data_size, GFP_KERNEL);
	if (!q_extra_data) {
		ret = -ENOMEM;
		goto exit;
	}
	ret = copy_from_user(q_extra_data, user_priv_ptr + *priv_data_offset, q_extra_data_size);
	if (ret) {
		ret = -EFAULT;
		goto exit;
	}
	*priv_data_offset += q_extra_data_size;
	pdd = kfd_process_device_data_by_id(p, q_data->gpu_id);
	if (!pdd) {
		pr_err("Failed to get pdd\n");
		ret = -EINVAL;
		goto exit;
	}
	mqd = q_extra_data;
	ctl_stack = mqd + q_data->mqd_size;
	memset(&qp, 0, sizeof(qp));
	set_queue_properties_from_criu(&qp, q_data);
	print_queue_properties(&qp);
	ret = pqm_create_queue(&p->pqm, pdd->dev, NULL, &qp, &queue_id, NULL, q_data, mqd, ctl_stack,
				NULL);
	if (ret) {
		pr_err("Failed to create new queue err:%d\n", ret);
		goto exit;
	}
	if (q_data->gws)
		ret = pqm_set_gws(&p->pqm, q_data->q_id, pdd->dev->gws);
exit:
	if (ret)
		pr_err("Failed to restore queue (%d)\n", ret);
	else
	kfree(q_data);
	return ret;
}
