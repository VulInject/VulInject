static bool encode(RArchSession *s, RAnalOp *op, ut32 mask) {
	int bits = s->config->bits;
	if (bits & R_SYS_BITS_32) {
		bits = 32;
	} else if (bits & R_SYS_BITS_16) {
		bits = 16;
	}
#if 0
	if (s->config->bits & R_SYS_BITS_64) {
		bits = 64;
	} else if (s->config->bits & R_SYS_BITS_32) {
		bits = 32;
	} else if (s->config->bits & R_SYS_BITS_16) {
		bits = 16;
	}
#endif
	const bool is_thumb = (bits == 16);
	int opsize;
	ut32 opcode = UT32_MAX;
	if (bits == 64) {
		if (!arm64ass (op->mnemonic, op->addr, &opcode)) {
			return false;
		}
	} else {
		opcode = armass_assemble (op->mnemonic, op->addr, is_thumb);
		if (bits != 32 && bits != 16) {
			R_LOG_ERROR ("ARM assembler only supports 16 or 32 bits");
			return false;
		}
	}
	if (opcode == UT32_MAX) {
		return false;
	}
	ut8 opbuf[4];
	const bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (s->config);
	if (is_thumb) {
		const int o = opcode >> 16;
		opsize = o > 0? 4: 2;
		if (opsize == 4) {
			if (be) {
				r_write_le16 (opbuf, opcode >> 16);
				r_write_le16 (opbuf + 2, opcode & UT16_MAX);
			} else {
			}
		} else if (opsize == 2) {
			if (be) {
				r_write_le16 (opbuf, opcode & UT16_MAX);
			} else {
				r_write_be16 (opbuf, opcode & UT16_MAX);
			}
		}
	} else {
		opsize = 4;
		if (be) {
			r_write_le32 (opbuf, opcode);
		} else {
			r_write_be32 (opbuf, opcode);
		}
	}
	r_anal_op_set_bytes (op, op->addr, opbuf, opsize);
	return true;
}
