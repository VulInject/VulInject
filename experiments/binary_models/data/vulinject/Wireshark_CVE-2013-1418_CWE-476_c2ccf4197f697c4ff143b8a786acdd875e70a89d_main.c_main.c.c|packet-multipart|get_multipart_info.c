get_multipart_info(packet_info *pinfo, media_content_info_t *content_info)
{
    char *start_boundary, *start_protocol = NULL;
    multipart_info_t *m_info = NULL;
    const char *type = pinfo->match_string;
    char *parameters;
    gint dummy;
    if (content_info == NULL) {
        return NULL;
    }
    if (content_info->media_str == NULL) {
        return NULL;
    }
    parameters = unfold_and_compact_mime_header(pinfo->pool, content_info->media_str, &dummy);
    start_boundary = ws_find_media_type_parameter(pinfo->pool, parameters, "boundary");
    if (!start_boundary) {
        return NULL;
    }
    if (strncmp(type, "multipart/encrypted", sizeof("multipart/encrypted") - 1) == 0) {
        start_protocol = ws_find_media_type_parameter(pinfo->pool, parameters, "protocol");
        if (!start_protocol) {
            return NULL;
        }
    }
    m_info = wmem_new(pinfo->pool, multipart_info_t);
    m_info->type = type;
    m_info->boundary = start_boundary;
    m_info->boundary_length = (guint)strlen(start_boundary);
    if(start_protocol) {
        m_info->protocol = start_protocol;
        m_info->protocol_length = (guint)strlen(start_protocol);
    } else {
        m_info->protocol = NULL;
        m_info->protocol_length = -1;
    }
    m_info->orig_content_type = NULL;
    m_info->orig_parameters = NULL;
    return m_info;
}
