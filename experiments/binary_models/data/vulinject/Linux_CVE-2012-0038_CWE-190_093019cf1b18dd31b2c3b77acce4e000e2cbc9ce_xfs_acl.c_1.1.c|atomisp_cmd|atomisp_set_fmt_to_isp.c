static int atomisp_set_fmt_to_isp(struct video_device *vdev,
				  struct ia_css_frame_info *output_info,
				  const struct v4l2_pix_format *pix)
{
	struct camera_mipi_info *mipi_info;
	struct atomisp_device *isp = video_get_drvdata(vdev);
	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
	struct atomisp_input_subdev *input = &isp->inputs[asd->input_curr];
	const struct atomisp_format_bridge *format;
	struct v4l2_rect *isp_sink_crop;
	enum ia_css_pipe_id pipe_id;
	int (*configure_output)(struct atomisp_sub_device *asd,
				unsigned int width, unsigned int height,
				unsigned int min_width,
				enum ia_css_frame_format sh_fmt) =
				    configure_output_nop;
	int (*get_frame_info)(struct atomisp_sub_device *asd,
			      struct ia_css_frame_info *finfo) =
				  get_frame_info_nop;
	int (*configure_pp_input)(struct atomisp_sub_device *asd,
				  unsigned int width, unsigned int height) =
				      configure_pp_input_nop;
	const struct atomisp_in_fmt_conv *fc = NULL;
	struct v4l2_mbus_framefmt *ffmt;
	int ret, i;
	isp_sink_crop = atomisp_subdev_get_rect(
			    &asd->subdev, NULL, V4L2_SUBDEV_FORMAT_ACTIVE,
			    ATOMISP_SUBDEV_PAD_SINK, V4L2_SEL_TGT_CROP);
	format = atomisp_get_format_bridge(pix->pixelformat);
	if (!format)
		return -EINVAL;
	mipi_info = atomisp_to_sensor_mipi_info(input->camera);
	if (atomisp_set_sensor_mipi_to_isp(asd, ATOMISP_INPUT_STREAM_GENERAL,
					   mipi_info))
		return -EINVAL;
	if (mipi_info)
		fc = atomisp_find_in_fmt_conv_by_atomisp_in_fmt(mipi_info->input_format);
	if (!fc) {
		ffmt = atomisp_subdev_get_ffmt(&asd->subdev, NULL,
					       V4L2_SUBDEV_FORMAT_ACTIVE,
					       ATOMISP_SUBDEV_PAD_SINK);
		fc = atomisp_find_in_fmt_conv(ffmt->code);
	}
	if (!fc)
		return -EINVAL;
	if (format->sh_fmt == IA_CSS_FRAME_FORMAT_RAW &&
	    raw_output_format_match_input(fc->atomisp_in_fmt, pix->pixelformat))
		return -EINVAL;
	{
	int width, height;
		if (pix->width < 640 || pix->height < 480) {
			width = pix->width;
			height = pix->height;
		} else {
			width = 640;
			height = 480;
		}
		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO ||
		    asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER) {
			atomisp_css_video_configure_viewfinder(asd, width, height, 0,
							       IA_CSS_FRAME_FORMAT_NV12);
		} else if (asd->run_mode->val == ATOMISP_RUN_MODE_STILL_CAPTURE ||
			   asd->vfpp->val == ATOMISP_VFPP_DISABLE_LOWLAT) {
			atomisp_css_capture_configure_viewfinder(asd, width, height, 0,
								 IA_CSS_FRAME_FORMAT_NV12);
		}
	}
	atomisp_css_input_set_mode(asd, IA_CSS_INPUT_MODE_BUFFERED_SENSOR);
	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].pipe_extra_configs[i].disable_vf_pp = asd->vfpp->val != ATOMISP_VFPP_ENABLE;
	if (asd->copy_mode) {
		pipe_id = IA_CSS_PIPE_ID_COPY;
		atomisp_css_capture_enable_online(asd, ATOMISP_INPUT_STREAM_GENERAL, false);
	} else if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER) {
		configure_output = atomisp_css_video_configure_output;
		get_frame_info = atomisp_css_video_get_output_frame_info;
		pipe_id = IA_CSS_PIPE_ID_VIDEO;
	} else if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
		configure_output = atomisp_css_video_configure_output;
		get_frame_info = atomisp_css_video_get_output_frame_info;
		pipe_id = IA_CSS_PIPE_ID_VIDEO;
	} else if (asd->run_mode->val == ATOMISP_RUN_MODE_PREVIEW) {
		configure_output = atomisp_css_preview_configure_output;
		get_frame_info = atomisp_css_preview_get_output_frame_info;
		configure_pp_input = atomisp_css_preview_configure_pp_input;
		pipe_id = IA_CSS_PIPE_ID_PREVIEW;
	} else {
		if (format->sh_fmt == IA_CSS_FRAME_FORMAT_RAW) {
			atomisp_css_capture_set_mode(asd, IA_CSS_CAPTURE_MODE_RAW);
			atomisp_css_enable_dz(asd, false);
		} else {
			atomisp_update_capture_mode(asd);
		}
		atomisp_css_capture_enable_online(asd, ATOMISP_INPUT_STREAM_GENERAL,
						  !asd->params.low_light);
		configure_output = atomisp_css_capture_configure_output;
		get_frame_info = atomisp_css_capture_get_output_frame_info;
		configure_pp_input = atomisp_css_capture_configure_pp_input;
		pipe_id = IA_CSS_PIPE_ID_CAPTURE;
		if (asd->run_mode->val != ATOMISP_RUN_MODE_STILL_CAPTURE) {
			dev_err(isp->dev,
				"Need to set the running mode first\n");
			asd->run_mode->val = ATOMISP_RUN_MODE_STILL_CAPTURE;
		}
	}
	if (asd->copy_mode)
		ret = atomisp_css_copy_configure_output(asd, ATOMISP_INPUT_STREAM_GENERAL,
							pix->width, pix->height,
							format->planar ? pix->bytesperline :
							pix->bytesperline * 8 / format->depth,
							format->sh_fmt);
	else
		ret = configure_output(asd, pix->width, pix->height,
				       format->planar ? pix->bytesperline :
				       pix->bytesperline * 8 / format->depth,
				       format->sh_fmt);
	if (ret) {
		dev_err(isp->dev, "configure_output %ux%u, format %8.8x\n",
			pix->width, pix->height, format->sh_fmt);
		return -EINVAL;
	}
	ret = configure_pp_input(asd, isp_sink_crop->width, isp_sink_crop->height);
	if (ret) {
		dev_err(isp->dev, "configure_pp_input %ux%u\n",
			isp_sink_crop->width,
			isp_sink_crop->height);
		return -EINVAL;
	}
	if (asd->copy_mode)
		ret = atomisp_css_copy_get_output_frame_info(asd,
							     ATOMISP_INPUT_STREAM_GENERAL,
							     output_info);
	else
		ret = get_frame_info(asd, output_info);
	if (ret) {
		dev_err(isp->dev, "__get_frame_info %ux%u (padded to %u) returned %d\n",
			pix->width, pix->height, pix->bytesperline, ret);
		return ret;
	}
	atomisp_update_grid_info(asd, pipe_id);
	return 0;
}
