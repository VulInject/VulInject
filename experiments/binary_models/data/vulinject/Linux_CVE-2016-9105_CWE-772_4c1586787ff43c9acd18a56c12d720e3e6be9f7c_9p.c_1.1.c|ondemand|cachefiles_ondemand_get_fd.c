static int cachefiles_ondemand_get_fd(struct cachefiles_req *req)
{
	struct cachefiles_object *object;
	struct cachefiles_cache *cache;
	struct cachefiles_open *load;
	struct file *file;
	unsigned int object_id;
	int ret, fd;
	object = cachefiles_grab_object(req->object,
			cachefiles_obj_get_ondemand_fd);
	cache = object->volume->cache;
	ret = xa_alloc_cyclic(&cache->ondemand_ids, &object_id, NULL,
			      XA_LIMIT(1, INT_MAX),
			      &cache->ondemand_id_next, GFP_KERNEL);
	if (ret < 0)
		goto err;
	fd = get_unused_fd_flags(O_WRONLY);
	if (fd < 0) {
		ret = fd;
		goto err_free_id;
	}
	file = anon_inode_getfile("[cachefiles]", &cachefiles_ondemand_fd_fops,
				  object, O_WRONLY);
	if (IS_ERR(file)) {
		ret = PTR_ERR(file);
		goto err_put_fd;
	}
	file->f_mode |= FMODE_PWRITE | FMODE_LSEEK;
	load = (void *)req->msg.data;
	load->fd = fd;
	object->ondemand->ondemand_id = object_id;
	cachefiles_get_unbind_pincount(cache);
	trace_cachefiles_ondemand_open(object, &req->msg, load);
	return 0;
err_put_fd:
	put_unused_fd(fd);
err_free_id:
	xa_erase(&cache->ondemand_ids, object_id);
err:
	cachefiles_put_object(object, cachefiles_obj_put_ondemand_fd);
	return ret;
}
