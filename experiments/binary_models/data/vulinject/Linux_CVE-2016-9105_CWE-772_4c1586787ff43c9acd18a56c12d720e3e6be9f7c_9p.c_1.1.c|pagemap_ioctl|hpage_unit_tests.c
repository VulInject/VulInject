int hpage_unit_tests(void)
{
	char *map;
	int ret, ret2;
	size_t num_pages = 10;
	int map_size = hpage_size * num_pages;
	int vec_size = map_size/page_size;
	struct page_region *vec, *vec2;
	vec = malloc(sizeof(struct page_region) * vec_size);
	vec2 = malloc(sizeof(struct page_region) * vec_size);
	if (!vec || !vec2)
		ksft_exit_fail_msg("malloc failed\n");
	map = gethugepage(map_size);
	if (map) {
		wp_addr_range(map, map_size);
		ret = pagemap_ioctl(map, map_size, vec, vec_size,
				    PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC, 0,
				    PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
		if (ret < 0)
			ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
		ksft_test_result(ret == 0, "%s all new huge page must not be written (dirty)\n",
				 __func__);
		ret = pagemap_ioctl(map, map_size, vec, vec_size, 0, 0,
				    PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
		if (ret < 0)
			ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
		ksft_test_result(ret == 0, "%s all the huge page must not be written\n", __func__);
		memset(map, -1, map_size);
		ret = pagemap_ioctl(map, map_size, vec, vec_size,
				    PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
				    0, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
		if (ret < 0)
			ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
		ksft_test_result(ret == 1 && vec[0].start == (uintptr_t)map &&
				 LEN(vec[0]) == vec_size && vec[0].categories == PAGE_IS_WRITTEN,
				 "%s all the huge page must be written and clear\n", __func__);
		wp_free(map, map_size);
		free(map);
		map = gethugepage(map_size);
		wp_init(map, map_size);
		wp_addr_range(map, map_size);
		map[vec_size/2 * page_size]++;
		ret = pagemap_ioctl(map, map_size, vec, vec_size, 0, 0,
				    PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
		if (ret < 0)
			ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
		ksft_test_result(ret == 1 && LEN(vec[0]) > 0,
				 "%s only middle page written\n", __func__);
		wp_free(map, map_size);
		free(map);
	} else {
		ksft_test_result_skip("%s all new huge page must be written\n", __func__);
		ksft_test_result_skip("%s all the huge page must not be written\n", __func__);
		ksft_test_result_skip("%s all the huge page must be written and clear\n", __func__);
		ksft_test_result_skip("%s only middle page written\n", __func__);
	}
	map = gethugepage(map_size);
	if (map) {
		wp_init(map, map_size);
		wp_addr_range(map, map_size);
		memset(map, 0, map_size);
		wp_addr_range(map, map_size/2);
		ret = pagemap_ioctl(map, map_size, vec, vec_size, 0, 0,
				    PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
		if (ret < 0)
			ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
		ksft_test_result(ret == 1 && LEN(vec[0]) == vec_size/2 &&
				 vec[0].start == (uintptr_t)(map + map_size/2),
				 "%s clear first half of huge page\n", __func__);
		wp_free(map, map_size);
		free(map);
	} else {
		ksft_test_result_skip("%s clear first half of huge page\n", __func__);
	}
	map = gethugepage(map_size);
	if (map) {
		wp_init(map, map_size);
		wp_addr_range(map, map_size);
		memset(map, 0, map_size);
		ret = pagemap_ioctl(map, map_size, vec, vec_size,
				    PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
				    vec_size/2, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
		if (ret < 0)
			ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
		ret = pagemap_ioctl(map, map_size, vec, vec_size, 0, 0,
				    PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
		if (ret < 0)
			ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
		ksft_test_result(ret == 1 && LEN(vec[0]) == vec_size/2 &&
				 vec[0].start == (uintptr_t)(map + map_size/2),
				 "%s clear first half of huge page with limited buffer\n",
				 __func__);
		wp_free(map, map_size);
		free(map);
	} else {
		ksft_test_result_skip("%s clear first half of huge page with limited buffer\n",
				      __func__);
	}
	map = gethugepage(map_size);
	if (map) {
		wp_init(map, map_size);
		wp_addr_range(map, map_size);
		memset(map, -1, map_size);
		ret = pagemap_ioctl(map + map_size/2, map_size/2, vec, vec_size,
				    PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC, vec_size/2,
				    PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
		if (ret < 0)
			ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
		ret = pagemap_ioctl(map, map_size, vec, vec_size, 0, 0,
				    PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
		if (ret < 0)
			ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
		ksft_test_result(ret == 1 && LEN(vec[0]) == vec_size/2,
				 "%s clear second half huge page\n", __func__);
		wp_free(map, map_size);
		free(map);
	} else {
		ksft_test_result_skip("%s clear second half huge page\n", __func__);
	}
	map = gethugepage(map_size);
	if (map) {
		wp_init(map, map_size);
		wp_addr_range(map, map_size);
		memset(map, -1, map_size);
		usleep(100);
		ret = pagemap_ioctl(map, map_size, vec, 1,
				    PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
				    hpage_size/(2*page_size), PAGE_IS_WRITTEN, 0, 0,
				    PAGE_IS_WRITTEN);
		if (ret < 0)
			ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
		ksft_test_result(ret == 1 && LEN(vec[0]) == hpage_size/(2*page_size),
				 "%s get half huge page\n", __func__);
		ret2 = pagemap_ioctl(map, map_size, vec, vec_size, 0, 0,
				    PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
		if (ret2 < 0)
			ksft_exit_fail_msg("error %d %d %s\n", ret2, errno, strerror(errno));
		ksft_test_result(ret2 == 1 && LEN(vec[0]) == (map_size - hpage_size/2)/page_size,
				 "%s get half huge page\n", __func__);
		wp_free(map, map_size);
		free(map);
	} else {
		ksft_test_result_skip("%s get half huge page\n", __func__);
		ksft_test_result_skip("%s get half huge page\n", __func__);
	}
	free(vec);
	free(vec2);
	return 0;
}
