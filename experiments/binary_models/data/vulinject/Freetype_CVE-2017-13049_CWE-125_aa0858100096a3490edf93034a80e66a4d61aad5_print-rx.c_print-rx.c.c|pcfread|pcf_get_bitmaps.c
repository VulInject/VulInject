  pcf_get_bitmaps( FT_Stream  stream,
                   PCF_Face   face )
  {
    FT_Error  error;
    FT_ULong  bitmapSizes[GLYPHPADOPTIONS];
    FT_ULong  format, size, pos;
    FT_ULong  nbitmaps, orig_nbitmaps, i, sizebitmaps = 0;
    error = pcf_seek_to_table_type( stream,
                                    face->toc.tables,
                                    face->toc.count,
                                    PCF_BITMAPS,
                                    &format,
                                    &size );
    if ( error )
      return error;
    error = FT_Stream_EnterFrame( stream, 8 );
    if ( error )
      return error;
    format = FT_GET_ULONG_LE();
    if ( PCF_BYTE_ORDER( format ) == MSBFirst )
      orig_nbitmaps = FT_GET_ULONG();
    else
      orig_nbitmaps = FT_GET_ULONG_LE();
    FT_TRACE4(( "pcf_get_bitmaps:\n" ));
    FT_TRACE4(( "  format: 0x%lX\n", format ));
    FT_TRACE4(( "          (%s, %s,\n",
                PCF_BYTE_ORDER( format ) == MSBFirst
                  ? "most significant byte first"
                  : "least significant byte first",
                PCF_BIT_ORDER( format ) == MSBFirst
                  ? "most significant bit first"
                  : "least significant bit first" ));
    FT_TRACE4(( "           padding=%d bit%s, scanning=%d bit%s)\n",
                8 << PCF_GLYPH_PAD_INDEX( format ),
                ( 8 << PCF_GLYPH_PAD_INDEX( format ) ) == 1 ? "" : "s",
                8 << PCF_SCAN_UNIT_INDEX( format ),
                ( 8 << PCF_SCAN_UNIT_INDEX( format ) ) == 1 ? "" : "s" ));
    if ( !PCF_FORMAT_MATCH( format, PCF_DEFAULT_FORMAT ) )
      return FT_THROW( Invalid_File_Format );
    FT_TRACE4(( "  number of bitmaps: %ld\n", orig_nbitmaps ));
    if ( orig_nbitmaps > 65534 )
    {
      FT_TRACE0(( "pcf_get_bitmaps:"
                  " only loading first 65534 bitmaps\n" ));
      nbitmaps = 65534;
    }
    else
      nbitmaps = orig_nbitmaps;
    if ( nbitmaps != face->nmetrics - 1 )
      return FT_THROW( Invalid_File_Format );
    pos = stream->pos + nbitmaps * 4 + 4 * 4;
    FT_TRACE5(( "\n" ));
    for ( i = 1; i <= nbitmaps; i++ )
    {
      FT_ULong  offset;
      if ( PCF_BYTE_ORDER( format ) == MSBFirst )
        (void)FT_READ_ULONG( offset );
      else
        (void)FT_READ_ULONG_LE( offset );
      FT_TRACE5(( "  bitmap %lu: offset %lu (0x%lX)\n",
                  i, offset, offset ));
      if ( offset > size )
      {
        FT_TRACE0(( "pcf_get_bitmaps:"
                    " invalid offset to bitmap data of glyph %lu\n", i ));
        face->metrics[i].bits = pos;
      }
      else
        face->metrics[i].bits = pos + offset;
    }
    if ( error )
      goto Bail;
    for ( i = 0; i < GLYPHPADOPTIONS; i++ )
    {
      if ( PCF_BYTE_ORDER( format ) == MSBFirst )
        (void)FT_READ_ULONG( bitmapSizes[i] );
      else
        (void)FT_READ_ULONG_LE( bitmapSizes[i] );
      if ( error )
        goto Bail;
      sizebitmaps = bitmapSizes[PCF_GLYPH_PAD_INDEX( format )];
      FT_TRACE4(( "  %d-bit padding implies a size of %lu\n",
                  8 << i, bitmapSizes[i] ));
    }
    FT_TRACE4(( "  %lu bitmaps, using %d-bit padding\n",
                nbitmaps,
                8 << PCF_GLYPH_PAD_INDEX( format ) ));
    FT_TRACE4(( "  bitmap size: %lu\n", sizebitmaps ));
    FT_UNUSED( sizebitmaps );       
    face->bitmapsFormat = format;
  Bail:
    return error;
  }
