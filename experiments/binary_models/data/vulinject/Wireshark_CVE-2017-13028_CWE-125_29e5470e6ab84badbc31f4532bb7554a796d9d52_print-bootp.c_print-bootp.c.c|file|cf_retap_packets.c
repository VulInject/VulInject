cf_retap_packets(capture_file *cf)
{
    packet_range_t        range;
    retap_callback_args_t callback_args;
    gboolean              create_proto_tree;
    gboolean              filtering_tap_listeners;
    guint                 tap_flags;
    psp_return_t          ret;
    if (cf == NULL) {
        return CF_READ_ABORTED;
    }
    if (cf->read_lock) {
        ws_warning("Failing due to nested process_specified_records(\"%s\") call!", cf->filename);
        return CF_READ_ERROR;
    }
    cf_callback_invoke(cf_cb_file_retap_started, cf);
    filtering_tap_listeners = have_filtering_tap_listeners();
    if (cf->edt != NULL && cf->edt->tree != NULL) {
        if (filtering_tap_listeners)
    }
    tap_flags = union_of_tap_listener_flags();
    callback_args.cinfo = (tap_listeners_require_columns()) ? &cf->cinfo : NULL;
    create_proto_tree =
        (filtering_tap_listeners || (tap_flags & TL_REQUIRES_PROTO_TREE));
    reset_tap_listeners();
    unsigned int count = cf->count;
    epan_dissect_init(&callback_args.edt, cf->epan, create_proto_tree, FALSE);
    packet_range_init(&range, cf);
    packet_range_process_init(&range);
    if (cf->state == FILE_READ_IN_PROGRESS) {
        if (count) {
            char* range_str = g_strdup_printf("-%u", count);
            packet_range_convert_str(&range, range_str);
            g_free(range_str);
        } else {
            packet_range_convert_str(&range, "0");
        }
        range.process = range_process_user_range;
    }
    ret = process_specified_records(cf, &range, "Recalculating statistics on",
            "all packets", TRUE, retap_packet,
            &callback_args, TRUE);
    packet_range_cleanup(&range);
    epan_dissect_cleanup(&callback_args.edt);
    cf_callback_invoke(cf_cb_file_retap_finished, cf);
    switch (ret) {
        case PSP_FINISHED:
            return CF_READ_OK;
        case PSP_STOPPED:
            return CF_READ_ABORTED;
        case PSP_FAILED:
            return CF_READ_ERROR;
    }
    ws_assert_not_reached();
    return CF_READ_OK;
}
