dissect_thrift_field_header(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int *offset, thrift_option_data_t *thrift_opt, thrift_field_header_t *header, gboolean gen_bool)
{
    DISSECTOR_ASSERT(header != NULL);
    ABORT_SUBDISSECTION_ON_ISSUE(*offset); 
    guint8 dfid_type = tvb_get_guint8(tvb, *offset);
    gint32 delta = TCP_THRIFT_DELTA_NOT_SET;
    gint64 fid = 0;
    memset(header, 0, sizeof(thrift_field_header_t));
    header->type_offset = *offset;
    *offset += TBP_THRIFT_TYPE_LEN;
    if (dfid_type == DE_THRIFT_T_STOP) {
        header->type.binary = (thrift_type_enum_t)dfid_type;
        header->type_pi = proto_tree_add_item(tree, hf_thrift_type, tvb, header->type_offset, TBP_THRIFT_TYPE_LEN, ENC_BIG_ENDIAN);
        return *offset;
    }
    if (thrift_opt->tprotocol & PROTO_THRIFT_COMPACT) {
        header->type.compact = (thrift_compact_type_enum_t)(dfid_type & TCP_THRIFT_NIBBLE_MASK);
        delta = (dfid_type >> TCP_THRIFT_NIBBLE_SHIFT) & TCP_THRIFT_NIBBLE_MASK;
        if (delta == TCP_THRIFT_DELTA_NOT_SET) {
            header->fid_offset = *offset;
            header->fid_length = thrift_get_varint_enc(tvb, pinfo, NULL, *offset, TCP_THRIFT_MAX_I16_LEN, &fid, ENC_VARINT_ZIGZAG);
            switch (header->fid_length) {
            case THRIFT_REQUEST_REASSEMBLY:
                ABORT_ON_INCOMPLETE_PDU(TCP_THRIFT_MAX_I16_LEN);
                return THRIFT_REQUEST_REASSEMBLY; 
            case 0: 
            default:
                header->field_id = fid;
                *offset += header->fid_length;
                break;
            }
        } else {
            header->field_id = thrift_opt->previous_field_id + delta;
            header->fid_offset = header->type_offset;
            header->fid_length = TBP_THRIFT_TYPE_LEN;
        }
    } else {
        ABORT_ON_INCOMPLETE_PDU(TBP_THRIFT_FID_LEN);
        header->type.binary = (thrift_type_enum_t)dfid_type;
        header->field_id = tvb_get_ntohis(tvb, *offset);
        header->fid_offset = *offset;
        header->fid_length = TBP_THRIFT_FID_LEN;
        *offset += TBP_THRIFT_FID_LEN;
    }
    if (tree != NULL) {
        guint nested_count = p_get_proto_depth(pinfo, proto_thrift);
        if (nested_count >= thrift_opt->nested_type_depth) {
            expert_add_info(pinfo, proto_tree_get_parent(tree), &ei_thrift_too_many_subtypes);
            return THRIFT_REQUEST_REASSEMBLY;
        }
        header->fh_tree = proto_tree_add_subtree_format(tree, tvb, header->type_offset, *offset - header->type_offset, ett_thrift_field, NULL,
                "Field Header #%" PRId64, header->field_id);
        if (thrift_opt->tprotocol & PROTO_THRIFT_COMPACT) {
            header->type_pi = proto_tree_add_bits_item(header->fh_tree, hf_thrift_compact_struct_type, tvb, (header->type_offset << OCTETS_TO_BITS_SHIFT) + TCP_THRIFT_NIBBLE_SHIFT, TCP_THRIFT_NIBBLE_SHIFT, ENC_BIG_ENDIAN);
            header->fid_pi = proto_tree_add_bits_item(header->fh_tree, hf_thrift_fid_delta, tvb, header->type_offset << OCTETS_TO_BITS_SHIFT, TCP_THRIFT_NIBBLE_SHIFT, ENC_BIG_ENDIAN);
            if (delta == TCP_THRIFT_DELTA_NOT_SET) {
                proto_item_append_text(header->fid_pi, " (Not Set)");
            }
            if (gen_bool && is_thrift_compact_bool_type(header->type.compact)) {
                proto_item *bool_item = proto_tree_add_boolean(tree, hf_thrift_bool, tvb, header->type_offset, TBP_THRIFT_TYPE_LEN, 2 - header->type.compact);
                proto_item_set_generated(bool_item);
            }
            if (gen_bool && is_thrift_compact_bool_type(header->type.compact)) {
                proto_item *bool_item = proto_tree_add_boolean(tree, hf_thrift_bool, tvb, header->type_offset, TBP_THRIFT_TYPE_LEN, 2 - header->type.compact);
                proto_item_set_generated(bool_item);
            }
        } else {
            header->type_pi = proto_tree_add_item(header->fh_tree, hf_thrift_type, tvb, header->type_offset, TBP_THRIFT_TYPE_LEN, ENC_BIG_ENDIAN);
        }
        if (delta == TCP_THRIFT_DELTA_NOT_SET) {
            if (header->fid_length > 0) {
                header->fid_pi = proto_tree_add_item(header->fh_tree, hf_thrift_fid, tvb, header->fid_offset, header->fid_length, ENC_BIG_ENDIAN);
            } else {
                proto_tree_add_expert(header->fh_tree, pinfo, &ei_thrift_varint_too_large, tvb, header->fid_offset, TCP_THRIFT_MAX_I16_LEN);
                return THRIFT_REQUEST_REASSEMBLY;
            }
        } else {
            if ((gint64)INT16_MIN > header->field_id || header->field_id > (gint64)INT16_MAX) {
                header->fid_pi = proto_tree_add_int64(header->fh_tree, hf_thrift_i64, tvb, header->fid_offset, header->fid_length, header->field_id);
                expert_add_info(pinfo, header->fid_pi, &ei_thrift_varint_too_large);
            } else {
                header->fid_pi = proto_tree_add_int(header->fh_tree, hf_thrift_fid, tvb, header->fid_offset, header->fid_length, (gint16)header->field_id);
            }
            proto_item_set_generated(header->fid_pi);
        }
        if (header->field_id < thrift_opt->previous_field_id || (header->field_id == thrift_opt->previous_field_id && thrift_opt->previous_field_id != 0)) {
            if (thrift_opt->previous_field_id == 0) {
                expert_add_info(pinfo, header->fid_pi, &ei_thrift_negative_field_id);
            } else {
                expert_add_info(pinfo, header->fid_pi, &ei_thrift_unordered_field_id);
            }
        }
    } else {
        if (delta == TCP_THRIFT_DELTA_NOT_SET) {
            if (header->fid_length > 0) {
                header->fid_pi = proto_tree_add_item(header->fh_tree, hf_thrift_fid, tvb, header->fid_offset, header->fid_length, ENC_BIG_ENDIAN);
            } else {
                proto_tree_add_expert(tree, pinfo, &ei_thrift_varint_too_large, tvb, header->fid_offset, TCP_THRIFT_MAX_I16_LEN);
                return THRIFT_REQUEST_REASSEMBLY;
            }
        } else {
            if ((gint64)INT16_MIN > header->field_id || header->field_id > (gint64)INT16_MAX) {
                header->fid_pi = proto_tree_add_int64(header->fh_tree, hf_thrift_i64, tvb, header->fid_offset, header->fid_length, header->field_id);
                expert_add_info(pinfo, header->fid_pi, &ei_thrift_varint_too_large);
            } else {
                header->fid_pi = proto_tree_add_int(header->fh_tree, hf_thrift_fid, tvb, header->fid_offset, header->fid_length, (gint16)header->field_id);
            }
            proto_item_set_generated(header->fid_pi);
        }
    }
    return *offset;
}
