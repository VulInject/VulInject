static int config_output(AVFilterLink *outlink)
{
    AVFilterContext *ctx = outlink->src;
    VPPContext      *vpp = ctx->priv;
    QSVVPPParam     param = { NULL };
    QSVVPPCrop      crop  = { 0 };
    mfxExtBuffer    *ext_buf[ENH_FILTERS_COUNT];
    mfxVersion      mfx_version;
    AVFilterLink    *inlink = ctx->inputs[0];
    enum AVPixelFormat in_format;
    outlink->w          = vpp->out_width;
    outlink->h          = vpp->out_height;
    outlink->frame_rate = vpp->framerate;
    if (vpp->framerate.num == 0 || vpp->framerate.den == 0)
        outlink->time_base = inlink->time_base;
    else
        outlink->time_base = av_inv_q(vpp->framerate);
    param.filter_frame  = NULL;
    param.set_frame_ext_params = vpp_set_frame_ext_params;
    param.num_ext_buf   = 0;
    param.ext_buf       = ext_buf;
    if (get_mfx_version(ctx, &mfx_version) != MFX_ERR_NONE) {
        av_log(ctx, AV_LOG_ERROR, "Failed to query mfx version.\n");
        return AVERROR(EINVAL);
    }
    if (inlink->format == AV_PIX_FMT_QSV) {
         if (!inlink->hw_frames_ctx || !inlink->hw_frames_ctx->data)
             return AVERROR(EINVAL);
         else
             in_format = ((AVHWFramesContext*)inlink->hw_frames_ctx->data)->sw_format;
    } else
        in_format = inlink->format;
    if (vpp->out_format == AV_PIX_FMT_NONE)
        vpp->out_format = in_format;
    param.out_sw_format  = vpp->out_format;
    if (vpp->use_crop) {
        crop.in_idx = 0;
        crop.x = vpp->crop_x;
        crop.y = vpp->crop_y;
        crop.w = vpp->crop_w;
        crop.h = vpp->crop_h;
        param.num_crop = 1;
        param.crop     = &crop;
    }
#define INIT_MFX_EXTBUF(extbuf, id) do { \
        memset(&vpp->extbuf, 0, sizeof(vpp->extbuf)); \
        vpp->extbuf.Header.BufferId = id; \
        vpp->extbuf.Header.BufferSz = sizeof(vpp->extbuf); \
        param.ext_buf[param.num_ext_buf++] = (mfxExtBuffer*)&vpp->extbuf; \
    } while (0)
#define SET_MFX_PARAM_FIELD(extbuf, field, value) do { \
        vpp->extbuf.field = value; \
    } while (0)
    if (vpp->deinterlace) {
        SET_MFX_PARAM_FIELD(deinterlace_conf, Mode, (vpp->deinterlace == 1 ?
                            MFX_DEINTERLACING_BOB : MFX_DEINTERLACING_ADVANCED));
    }
    if (vpp->use_frc) {
        INIT_MFX_EXTBUF(frc_conf, MFX_EXTBUFF_VPP_FRAME_RATE_CONVERSION);
        SET_MFX_PARAM_FIELD(frc_conf, Algorithm, MFX_FRCALGM_DISTRIBUTED_TIMESTAMP);
    }
    if (vpp->denoise) {
        INIT_MFX_EXTBUF(denoise_conf, MFX_EXTBUFF_VPP_DENOISE);
        SET_MFX_PARAM_FIELD(denoise_conf, DenoiseFactor, vpp->denoise);
    }
    if (vpp->detail) {
        INIT_MFX_EXTBUF(detail_conf, MFX_EXTBUFF_VPP_DETAIL);
        SET_MFX_PARAM_FIELD(detail_conf, DetailFactor, vpp->detail);
    }
    if (vpp->procamp) {
        INIT_MFX_EXTBUF(procamp_conf, MFX_EXTBUFF_VPP_PROCAMP);
        SET_MFX_PARAM_FIELD(procamp_conf, Hue, vpp->hue);
        SET_MFX_PARAM_FIELD(procamp_conf, Saturation, vpp->saturation);
        SET_MFX_PARAM_FIELD(procamp_conf, Contrast, vpp->contrast);
        SET_MFX_PARAM_FIELD(procamp_conf, Brightness, vpp->brightness);
    }
    if (vpp->transpose >= 0) {
        if (QSV_RUNTIME_VERSION_ATLEAST(mfx_version, 1, 17)) {
            switch (vpp->transpose) {
            case TRANSPOSE_CCLOCK_FLIP:
                vpp->rotate = MFX_ANGLE_270;
                vpp->hflip  = MFX_MIRRORING_HORIZONTAL;
                break;
            case TRANSPOSE_CLOCK:
                vpp->rotate = MFX_ANGLE_90;
                vpp->hflip  = MFX_MIRRORING_DISABLED;
                break;
            case TRANSPOSE_CCLOCK:
                vpp->rotate = MFX_ANGLE_270;
                vpp->hflip  = MFX_MIRRORING_DISABLED;
                break;
            case TRANSPOSE_CLOCK_FLIP:
                vpp->rotate = MFX_ANGLE_90;
                vpp->hflip  = MFX_MIRRORING_HORIZONTAL;
                break;
            case TRANSPOSE_REVERSAL:
                vpp->rotate = MFX_ANGLE_180;
                vpp->hflip  = MFX_MIRRORING_DISABLED;
                break;
            case TRANSPOSE_HFLIP:
                vpp->rotate = MFX_ANGLE_0;
                vpp->hflip  = MFX_MIRRORING_HORIZONTAL;
                break;
            case TRANSPOSE_VFLIP:
                vpp->rotate = MFX_ANGLE_180;
                vpp->hflip  = MFX_MIRRORING_HORIZONTAL;
                break;
            default:
                av_log(ctx, AV_LOG_ERROR, "Failed to set transpose mode to %d.\n", vpp->transpose);
                return AVERROR(EINVAL);
            }
        } else {
            av_log(ctx, AV_LOG_WARNING, "The QSV VPP transpose option is "
                   "not supported with this MSDK version.\n");
            vpp->transpose = 0;
        }
    }
    if (vpp->rotate) {
        if (QSV_RUNTIME_VERSION_ATLEAST(mfx_version, 1, 17)) {
            INIT_MFX_EXTBUF(rotation_conf, MFX_EXTBUFF_VPP_ROTATION);
            SET_MFX_PARAM_FIELD(rotation_conf, Angle, vpp->rotate);
            if (MFX_ANGLE_90 == vpp->rotate || MFX_ANGLE_270 == vpp->rotate) {
                FFSWAP(int, vpp->out_width, vpp->out_height);
                FFSWAP(int, outlink->w, outlink->h);
                av_log(ctx, AV_LOG_DEBUG, "Swap width and height for clock/cclock rotation.\n");
            }
        } else {
            av_log(ctx, AV_LOG_WARNING, "The QSV VPP rotate option is "
                   "not supported with this MSDK version.\n");
            vpp->rotate = 0;
        }
    }
    if (vpp->hflip) {
        if (QSV_RUNTIME_VERSION_ATLEAST(mfx_version, 1, 19)) {
            INIT_MFX_EXTBUF(mirroring_conf, MFX_EXTBUFF_VPP_MIRRORING);
            SET_MFX_PARAM_FIELD(mirroring_conf, Type, vpp->hflip);
        } else {
            av_log(ctx, AV_LOG_WARNING, "The QSV VPP hflip option is "
                   "not supported with this MSDK version.\n");
            vpp->hflip = 0;
        }
    }
    if (inlink->w != outlink->w || inlink->h != outlink->h || in_format != vpp->out_format) {
        if (QSV_RUNTIME_VERSION_ATLEAST(mfx_version, 1, 19)) {
            int mode = vpp->scale_mode;
#if QSV_ONEVPL
            if (mode > 2)
                mode = MFX_SCALING_MODE_VENDOR + mode - 2;
#endif
            INIT_MFX_EXTBUF(scale_conf, MFX_EXTBUFF_VPP_SCALING);
            SET_MFX_PARAM_FIELD(scale_conf, ScalingMode, mode);
        } else
            av_log(ctx, AV_LOG_WARNING, "The QSV VPP Scale & format conversion "
                   "option is not supported with this MSDK version.\n");
    }
#undef INIT_MFX_EXTBUF
#undef SET_MFX_PARAM_FIELD
    if (vpp->use_frc || vpp->use_crop || vpp->deinterlace || vpp->denoise ||
        vpp->detail || vpp->procamp || vpp->rotate || vpp->hflip ||
        inlink->w != outlink->w || inlink->h != outlink->h || in_format != vpp->out_format ||
        vpp->color_range != AVCOL_RANGE_UNSPECIFIED ||
        vpp->color_primaries != AVCOL_PRI_UNSPECIFIED ||
        vpp->color_transfer != AVCOL_TRC_UNSPECIFIED ||
        vpp->color_matrix != AVCOL_SPC_UNSPECIFIED ||
        vpp->tonemap ||
        !vpp->has_passthrough)
        return ff_qsvvpp_init(ctx, &param);
    else {
        /* No MFX session is created in this case */
        av_log(ctx, AV_LOG_VERBOSE, "qsv vpp pass through mode.\n");
        if (inlink->hw_frames_ctx)
            outlink->hw_frames_ctx = av_buffer_ref(inlink->hw_frames_ctx);
    }
    return 0;
}
