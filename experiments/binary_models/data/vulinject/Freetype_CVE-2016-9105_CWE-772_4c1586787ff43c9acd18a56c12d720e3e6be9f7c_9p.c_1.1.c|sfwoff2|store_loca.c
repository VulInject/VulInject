  store_loca( FT_ULong*  loca_values,
              FT_ULong   loca_values_size,
              FT_UShort  index_format,
              FT_ULong*  checksum,
              FT_Byte**  sfnt_bytes,
              FT_ULong*  sfnt_size,
              FT_ULong*  out_offset,
              FT_Memory  memory )
  {
    FT_Error  error       = FT_Err_Ok;
    FT_Byte*  sfnt        = *sfnt_bytes;
    FT_ULong  dest_offset = *out_offset;
    FT_Byte*  loca_buf = NULL;
    FT_Byte*  dst      = NULL;
    FT_UInt   i = 0;
    FT_ULong  loca_buf_size;
    const FT_ULong  offset_size = index_format ? 4 : 2;
    if ( ( loca_values_size << 2 ) >> 2 != loca_values_size )
      goto Fail;
    loca_buf_size = loca_values_size * offset_size;
    if ( FT_QALLOC( loca_buf, loca_buf_size ) )
      goto Fail;
    dst = loca_buf;
    for ( i = 0; i < loca_values_size; i++ )
    {
      FT_ULong  value = loca_values[i];
      if ( index_format )
      else
        WRITE_USHORT( dst, ( value >> 1 ) );
    }
    *checksum = compute_ULong_sum( loca_buf, loca_buf_size );
    if ( WRITE_SFNT_BUF( loca_buf, loca_buf_size ) )
      goto Fail;
    *sfnt_bytes = sfnt;
    *out_offset = dest_offset;
    FT_FREE( loca_buf );
    return error;
  Fail:
    if ( !error )
      error = FT_THROW( Invalid_Table );
    FT_FREE( loca_buf );
    return error;
  }
