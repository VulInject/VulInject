show_map_vma(struct seq_file *m, struct vm_area_struct *vma)
{
	struct anon_vma_name *anon_name = NULL;
	struct mm_struct *mm = vma->vm_mm;
	struct file *file = vma->vm_file;
	vm_flags_t flags = vma->vm_flags;
	unsigned int ino = 0;
	unsigned int int pgoff = 0;
	int start, end;
	dev_t dev = 0;
	const char *name = NULL;
	if (file) {
		const struct inode *inode = file_user_inode(vma->vm_file);
		dev = inode->i_sb->s_dev;
		ino = inode->i_ino;
		pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
	}
	start = vma->vm_start;
	end = vma->vm_end;
	show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino);
	if (mm)
		anon_name = anon_vma_name(vma);
	if (file) {
		seq_pad(m, ' ');
		if (anon_name)
			seq_printf(m, "[anon_shmem:%s]", anon_name->name);
		else
			seq_path(m, file_user_path(file), "\n");
		goto done;
	}
	if (vma->vm_ops && vma->vm_ops->name) {
		name = vma->vm_ops->name(vma);
		if (name)
			goto done;
	}
	name = arch_vma_name(vma);
	if (!name) {
		if (!mm) {
			name = "[vdso]";
			goto done;
		}
		if (vma_is_initial_heap(vma)) {
			name = "[heap]";
			goto done;
		}
		if (vma_is_initial_stack(vma)) {
			name = "[stack]";
			goto done;
		}
		if (anon_name) {
			seq_pad(m, ' ');
			seq_printf(m, "[anon:%s]", anon_name->name);
		}
	}
done:
	if (name) {
		seq_pad(m, ' ');
		seq_puts(m, name);
	}
	seq_putc(m, '\n');
}
