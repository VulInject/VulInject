static struct htc_packet *htc_wait_for_ctrl_msg(struct htc_target *target)
{
	struct htc_packet *packet = NULL;
	struct htc_frame_look_ahead look_ahead;
	if (ath6kl_hif_poll_mboxmsg_rx(target->dev, &look_ahead.word,
				       HTC_TARGET_RESPONSE_TIMEOUT))
		return NULL;
	ath6kl_dbg(ATH6KL_DBG_HTC,
		   "htc rx wait ctrl look_ahead 0x%X\n", look_ahead.word);
	if (look_ahead.eid != ENDPOINT_0)
		return NULL;
	packet = htc_get_control_buf(target, false);
	if (!packet)
		return NULL;
	packet->info.rx.rx_flags = 0;
	packet->info.rx.exp_hdr = look_ahead.word;
	packet->act_len = le16_to_cpu(look_ahead.payld_len) + HTC_HDR_LENGTH;
	if (packet->act_len > packet->buf_len)
		goto fail_ctrl_rx;
	packet->completion = NULL;
	if (ath6kl_htc_rx_packet(target, packet, packet->act_len))
		goto fail_ctrl_rx;
	trace_ath6kl_htc_rx(packet->status, packet->endpoint,
			    packet->buf, packet->act_len);
	packet->status = ath6kl_htc_rx_process_hdr(target, packet, NULL, NULL);
	if (packet->status) {
		ath6kl_err("htc_wait_for_ctrl_msg, ath6kl_htc_rx_process_hdr failed (status = %d)\n",
			   packet->status);
		goto fail_ctrl_rx;
	}
	return packet;
fail_ctrl_rx:
	if (packet != NULL) {
		htc_rxpkt_reset(packet);
	}
	return NULL;
}
