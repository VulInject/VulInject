static int dissect_pcp_partial_features(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset)
{
    guint16     feature_flags;
    const gchar *feature_flags_string;
    static int * const pcp_feature_flags_header_fields[] = {
            &hf_pcp_features_flags_labels,
            &hf_pcp_features_flags_bad_label,
            &hf_pcp_features_flags_cert_reqd,
            &hf_pcp_features_flags_container,
            &hf_pcp_features_flags_no_nss_init,
            &hf_pcp_features_flags_secure_ack,
            &hf_pcp_features_flags_creds_reqd,
            &hf_pcp_features_flags_auth,
            &hf_pcp_features_flags_compress,
            &hf_pcp_features_flags_secure,
            NULL
    };
    feature_flags = tvb_get_ntohs(tvb, offset);
	feature_flags_string=((pinfo->pool+feature_flags-1)/feature_flags);
    col_append_fstr(pinfo->cinfo, COL_INFO, " Features=[%s]", feature_flags_string);
    proto_tree_add_bitmask(tree, tvb, offset, hf_pcp_features_flags, ett_pcp_start_features, pcp_feature_flags_header_fields, ENC_BIG_ENDIAN);
    offset += 2;
    if ((feature_flags & PCP_PDU_FLAG_LABELS) == PCP_PDU_FLAG_LABELS && server_to_client(pinfo)) {
        pcp_conv_info_t *pcp_conv_info = get_pcp_conversation_info(pinfo);
        pcp_conv_info->using_good_labels = TRUE;
    }
    return offset;
}
