clnp_print(netdissect_options *ndo,
           const unsigned char *pptr, u_int length)
{
	const unsigned char *optr,*source_address,*dest_address;
        u_int li,li_remaining,tlen,nsap_offset,source_address_length,dest_address_length, clnp_pdu_type, clnp_flags;
	const struct clnp_header_t *clnp_header;
	const struct clnp_segment_header_t *clnp_segment_header;
        unsigned char rfd_error,rfd_error_major,rfd_error_minor;
	ndo->ndo_protocol = "clnp";
	clnp_header = (const struct clnp_header_t *) pptr;
        li = GET_U_1(clnp_header->length_indicator);
        li_remaining = li;
        optr = pptr;
        if (!ndo->ndo_eflag)
            nd_print_protocol_caps(ndo);
        if (GET_U_1(clnp_header->version) != CLNP_VERSION) {
            ND_PRINT("version %u packet not supported",
                     GET_U_1(clnp_header->version));
            return (0);
        }
	if (li > length) {
            ND_PRINT(" length indicator(%u) > PDU size (%u)!", li, length);
            return (0);
	}
        if (li < sizeof(struct clnp_header_t)) {
            ND_PRINT(" length indicator %u < min PDU size:", li);
            while (pptr < ndo->ndo_snapend) {
                ND_PRINT("%02X", GET_U_1(pptr));
                pptr++;
            }
            return (0);
        }
        clnp_pdu_type = GET_U_1(clnp_header->type) & CLNP_PDU_TYPE_MASK;
        clnp_flags = GET_U_1(clnp_header->type) & CLNP_FLAG_MASK;
        pptr += sizeof(struct clnp_header_t);
        li_remaining -= sizeof(struct clnp_header_t);
        if (li_remaining < 1) {
            ND_PRINT("li < size of fixed part of CLNP header and addresses");
            return (0);
        }
        dest_address_length = GET_U_1(pptr);
        pptr += 1;
        li_remaining -= 1;
        if (li_remaining < dest_address_length) {
            ND_PRINT("li < size of fixed part of CLNP header and addresses");
            return (0);
        }
        ND_TCHECK_LEN(pptr, dest_address_length);
        dest_address = pptr;
        pptr += dest_address_length;
        li_remaining -= dest_address_length;
        if (li_remaining < 1) {
            ND_PRINT("li < size of fixed part of CLNP header and addresses");
            return (0);
        }
        source_address_length = GET_U_1(pptr);
        pptr += 1;
        li_remaining -= 1;
        if (li_remaining < source_address_length) {
            ND_PRINT("li < size of fixed part of CLNP header and addresses");
            return (0);
        }
        ND_TCHECK_LEN(pptr, source_address_length);
        source_address = pptr;
        pptr += source_address_length;
        li_remaining -= source_address_length;
        if (ndo->ndo_vflag < 1) {
            ND_PRINT("%s%s > %s, %s, length %u",
                   ndo->ndo_eflag ? "" : ", ",
                   GET_ISONSAP_STRING(source_address, source_address_length),
                   GET_ISONSAP_STRING(dest_address, dest_address_length),
                   tok2str(clnp_pdu_values,"unknown (%u)",clnp_pdu_type),
                   length);
            return (1);
        }
        ND_PRINT("%slength %u", ndo->ndo_eflag ? "" : ", ", length);
        ND_PRINT("\n\t%s PDU, hlen: %u, v: %u, lifetime: %u.%us, Segment PDU length: %u, checksum: 0x%04x",
               tok2str(clnp_pdu_values, "unknown (%u)",clnp_pdu_type),
               GET_U_1(clnp_header->length_indicator),
               GET_U_1(clnp_header->version),
               GET_U_1(clnp_header->lifetime)/2,
               (GET_U_1(clnp_header->lifetime)%2)*5,
               GET_BE_U_2(clnp_header->segment_length),
               GET_BE_U_2(clnp_header->cksum));
        osi_print_cksum(ndo, optr, GET_BE_U_2(clnp_header->cksum), 7,
                        GET_U_1(clnp_header->length_indicator));
        ND_PRINT("\n\tFlags [%s]",
               bittok2str(clnp_flag_values, "none", clnp_flags));
        ND_PRINT("\n\tsource address (length %u): %s\n\tdest   address (length %u): %s",
               source_address_length,
               GET_ISONSAP_STRING(source_address, source_address_length),
               dest_address_length,
               GET_ISONSAP_STRING(dest_address, dest_address_length));
        if (clnp_flags & CLNP_SEGMENT_PART) {
                if (li_remaining < sizeof(struct clnp_segment_header_t)) {
                    ND_PRINT("li < size of fixed part of CLNP header, addresses, and segment part");
                    return (0);
                }
		clnp_segment_header = (const struct clnp_segment_header_t *) pptr;
                ND_TCHECK_SIZE(clnp_segment_header);
                ND_PRINT("\n\tData Unit ID: 0x%04x, Segment Offset: %u, Total PDU Length: %u",
                       GET_BE_U_2(clnp_segment_header->data_unit_id),
                       GET_BE_U_2(clnp_segment_header->segment_offset),
                       GET_BE_U_2(clnp_segment_header->total_length));
                pptr+=sizeof(struct clnp_segment_header_t);
                li_remaining-=sizeof(struct clnp_segment_header_t);
        }
        while (li_remaining != 0) {
            u_int op, opli;
            const unsigned char *tptr;
            if (li_remaining < 2) {
                ND_PRINT(", bad opts/li");
                return (0);
            }
            op = GET_U_1(pptr);
            opli = GET_U_1(pptr + 1);
            pptr += 2;
            li_remaining -= 2;
            if (opli > li_remaining) {
                ND_PRINT(", opt (%u) too int", op);
                return (0);
            }
            ND_TCHECK_LEN(pptr, opli);
            li_remaining -= opli;
            tptr = pptr;
            tlen = opli;
            ND_PRINT("\n\t  %s Option #%u, length %u, value: ",
                   tok2str(clnp_option_values,"Unknown",op),
                   op,
                   opli);
            switch (op) {
            case CLNP_OPTION_ROUTE_RECORDING: 
            case CLNP_OPTION_SOURCE_ROUTING:
                    if (tlen < 2) {
                            ND_PRINT(", bad opt len");
                            return (0);
                    }
                    ND_PRINT("%s %s",
                           tok2str(clnp_option_sr_rr_values,"Unknown",GET_U_1(tptr)),
                           tok2str(clnp_option_sr_rr_string_values, "Unknown Option %u", op));
                    nsap_offset=GET_U_1(tptr + 1);
                    if (nsap_offset == 0) {
                            ND_PRINT(" Bad NSAP offset (0)");
                            break;
                    }
                    nsap_offset-=1; 
                    if (nsap_offset > tlen) {
                            ND_PRINT(" Bad NSAP offset (past end of option)");
                            break;
                    }
                    tptr+=nsap_offset;
                    tlen-=nsap_offset;
                    while (tlen != 0) {
                            source_address_length=GET_U_1(tptr);
                            if (tlen < source_address_length+1) {
                                    ND_PRINT("\n\t    NSAP address goes past end of option");
                                    break;
                            }
                            if (source_address_length > 0) {
                                    source_address=(tptr+1);
                                    ND_PRINT("\n\t    NSAP address (length %u): %s",
                                           source_address_length,
                                           GET_ISONSAP_STRING(source_address, source_address_length));
                            }
                            tlen-=source_address_length+1;
                    }
                    break;
            case CLNP_OPTION_PRIORITY:
                    if (tlen < 1) {
                            ND_PRINT(", bad opt len");
                            return (0);
                    }
                    ND_PRINT("0x%1x", GET_U_1(tptr)&0x0f);
                    break;
            case CLNP_OPTION_QOS_MAINTENANCE:
                    if (tlen < 1) {
                            ND_PRINT(", bad opt len");
                            return (0);
                    }
                    ND_PRINT("\n\t    Format Code: %s",
                           tok2str(clnp_option_scope_values, "Reserved", GET_U_1(tptr) & CLNP_OPTION_SCOPE_MASK));
                    if ((GET_U_1(tptr)&CLNP_OPTION_SCOPE_MASK) == CLNP_OPTION_SCOPE_GLOBAL)
                            ND_PRINT("\n\t    QoS Flags [%s]",
                                   bittok2str(clnp_option_qos_global_values,
                                              "none",
                                              GET_U_1(tptr)&CLNP_OPTION_OPTION_QOS_MASK));
                    break;
            case CLNP_OPTION_SECURITY:
                    if (tlen < 2) {
                            ND_PRINT(", bad opt len");
                            return (0);
                    }
                    ND_PRINT("\n\t    Format Code: %s, Security-Level %u",
                           tok2str(clnp_option_scope_values,"Reserved",GET_U_1(tptr)&CLNP_OPTION_SCOPE_MASK),
                           GET_U_1(tptr + 1));
                    break;
            case CLNP_OPTION_DISCARD_REASON:
                if (tlen < 1) {
                        ND_PRINT(", bad opt len");
                        return (0);
                }
                rfd_error = GET_U_1(tptr);
                rfd_error_major = (rfd_error&0xf0) >> 4;
                rfd_error_minor = rfd_error&0x0f;
                ND_PRINT("\n\t    Class: %s Error (0x%01x), %s (0x%01x)",
                       tok2str(clnp_option_rfd_class_values,"Unknown",rfd_error_major),
                       rfd_error_major,
                       tok2str(clnp_option_rfd_error_class[rfd_error_major],"Unknown",rfd_error_minor),
                       rfd_error_minor);
                break;
            case CLNP_OPTION_PADDING:
                    ND_PRINT("padding data");
                break;
            default:
                print_unknown_data(ndo, tptr, "\n\t  ", opli);
                break;
            }
            if (ndo->ndo_vflag > 1)
                print_unknown_data(ndo, pptr, "\n\t  ", opli);
            pptr += opli;
        }
        switch (clnp_pdu_type) {
        case    CLNP_PDU_ER: 
        case	CLNP_PDU_ERP:
            if (GET_U_1(pptr) == NLPID_CLNP) {
                ND_PRINT("\n\t-----original packet-----\n\t");
                clnp_print(ndo, pptr, length - li);
                break;
            }
        ND_FALL_THROUGH;
        case	CLNP_PDU_DT:
        case	CLNP_PDU_MD:
        case	CLNP_PDU_ERQ:
        default:
            if (length > ND_BYTES_BETWEEN(optr, pptr)) {
                ND_PRINT("\n\t  undecoded non-header data, length %u", length-li);
                print_unknown_data(ndo, pptr, "\n\t  ",
                                   length - ND_BYTES_BETWEEN(optr, pptr));
            }
        }
        return (1);
 trunc:
    nd_print_trunc(ndo);
    return (1);
}
