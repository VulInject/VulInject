dissect_reload_framing_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean from_dtls)
{
  proto_item         *ti;
  proto_tree         *reload_framing_tree;
  guint32             relo_token;
  guint32             message_length = 0;
  wmem_tree_key_t     transaction_id_key[4];
  guint32            *key_save, len_save;
  guint32             sequence;
  guint               effective_length;
  guint16             offset;
  conversation_t     *conversation;
  reload_conv_info_t *reload_framing_info = NULL;
  reload_frame_t *    reload_frame;
  guint8              type;
  offset = 0;
  effective_length = tvb_captured_length(tvb);
  if (effective_length < MIN_HDR_LENGTH)
    return 0;
  conversation = find_conversation_pinfo(pinfo, 0);
  if (conversation)
    reload_framing_info = (reload_conv_info_t *)conversation_get_proto_data(conversation, proto_reload_framing);
  type = tvb_get_guint8(tvb, 0);
  switch(type) {
  case DATA:
    if (effective_length < 12)  
      return 0;
    relo_token = tvb_get_ntohl(tvb,1 + 4 + 3);
    if (relo_token != RELOAD_TOKEN) {
      return 0;
    }
    message_length = tvb_get_ntoh24(tvb, 1 + 4);
    if (message_length < MIN_RELOADDATA_HDR_LENGTH) {
      return 0;
    }
    break;
  case ACK:
    if (effective_length < 9 || ! reload_framing_info) {
      return 0;
    }
    break;
  default:
    return 0;
  }
  if (from_dtls && have_tap_listener(exported_pdu_tap)) {
    exp_pdu_data_t *exp_pdu_data = export_pdu_create_common_tags(pinfo, "reload-framing", EXP_PDU_TAG_DISSECTOR_NAME);
    exp_pdu_data->tvb_captured_length = effective_length;
    exp_pdu_data->tvb_reported_length = tvb_reported_length(tvb);
    exp_pdu_data->pdu_tvb = tvb;
    tap_queue_packet(exported_pdu_tap, pinfo, exp_pdu_data);
  }
  col_set_str(pinfo->cinfo, COL_PROTOCOL, "RELOAD Frame");
  col_clear(pinfo->cinfo, COL_INFO);
  sequence = tvb_get_ntohl(tvb, 1);
  transaction_id_key[0].length = 1;
  transaction_id_key[0].key = &sequence; 
  if (type==DATA) {
    transaction_id_key[1].length = 1;
    transaction_id_key[1].key    = &pinfo->srcport;
    transaction_id_key[2].length = (pinfo->src.len) / (guint)sizeof(guint32);
    transaction_id_key[2].key    = (guint32 *)g_malloc(pinfo->src.len);
    memcpy(transaction_id_key[2].key, pinfo->src.data, pinfo->src.len);
  }
  else {
    transaction_id_key[1].length = 1;
    transaction_id_key[1].key    = &pinfo->destport;
    transaction_id_key[2].length = (pinfo->dst.len) / (guint)sizeof(guint32);
    transaction_id_key[2].key    = (guint32 *)g_malloc(pinfo->dst.len);
    memcpy(transaction_id_key[2].key, pinfo->dst.data, pinfo->dst.len);
  }
  transaction_id_key[3].length=0;
  transaction_id_key[3].key=NULL;
  key_save = transaction_id_key[2].key;
  len_save = transaction_id_key[2].length;
  if (!conversation) {
    conversation = conversation_new(pinfo->num, &pinfo->src, &pinfo->dst,
                                    conversation_pt_to_conversation_type(pinfo->ptype), pinfo->srcport, pinfo->destport, 0);
  }
  if (!reload_framing_info) {
    reload_framing_info = wmem_new(wmem_file_scope(), reload_conv_info_t);
    reload_framing_info->transaction_pdus = wmem_tree_new(wmem_file_scope());
    conversation_add_proto_data(conversation, proto_reload_framing, reload_framing_info);
  }
  if (!pinfo->fd->visited) {
    if ((reload_frame = (reload_frame_t *)
           wmem_tree_lookup32_array(reload_framing_info->transaction_pdus, transaction_id_key)) == NULL) {
      transaction_id_key[2].key    = key_save;
      transaction_id_key[2].length = len_save;
      reload_frame = wmem_new(wmem_file_scope(), reload_frame_t);
      reload_frame->data_frame = 0;
      reload_frame->ack_frame  = 0;
      reload_frame->req_time   = pinfo->abs_ts;
      wmem_tree_insert32_array(reload_framing_info->transaction_pdus, transaction_id_key, (void *)reload_frame);
    }
    transaction_id_key[2].key    = key_save;
    transaction_id_key[2].length = len_save;
    if (type == DATA) {
      if (reload_frame->data_frame == 0) {
        reload_frame->data_frame = pinfo->num;
      }
    }
    else {
      if (reload_frame->ack_frame == 0) {
        reload_frame->ack_frame = pinfo->num;
      }
    }
  }
  else {
    reload_frame=(reload_frame_t *)wmem_tree_lookup32_array(reload_framing_info->transaction_pdus, transaction_id_key);
    transaction_id_key[2].key    = key_save;
    transaction_id_key[2].length = len_save;
  }
  g_free(transaction_id_key[2].key);
  if (!reload_frame) {
	reload_frame=((pinfo->pool+reload_frame_t-1)/reload_frame_t);
    reload_frame->data_frame = (type==DATA) ? pinfo->num : 0;
    reload_frame->ack_frame  = (type!=DATA) ? pinfo->num : 0;
    reload_frame->req_time   = pinfo->abs_ts;
  }
  ti = proto_tree_add_item(tree, proto_reload_framing, tvb, 0, -1, ENC_NA);
  reload_framing_tree = proto_item_add_subtree(ti, ett_reload_framing);
  col_add_str(pinfo->cinfo, COL_INFO, val_to_str_const(type, types, "Unknown"));
  proto_item_append_text(ti, ": %s", val_to_str_const(type, types, "Unknown"));
  if (type == DATA) {
    if (reload_frame->data_frame != pinfo->num) {
      proto_item *it;
      it = proto_tree_add_uint(reload_framing_tree, hf_reload_framing_duplicate, tvb, 0, 0, reload_frame->data_frame);
      proto_item_set_generated(it);
    }
    if (reload_frame->ack_frame) {
      proto_item *it;
      it = proto_tree_add_uint(reload_framing_tree, hf_reload_framing_response_in, tvb, 0, 0, reload_frame->ack_frame);
      proto_item_set_generated(it);
    }
  }
  else {
    if (reload_frame->ack_frame != pinfo->num) {
      proto_item *it;
      it = proto_tree_add_uint(reload_framing_tree, hf_reload_framing_duplicate, tvb, 0, 0, reload_frame->ack_frame);
      proto_item_set_generated(it);
    }
    if (reload_frame->data_frame) {
      proto_item *it;
      nstime_t    ns;
      it = proto_tree_add_uint(reload_framing_tree, hf_reload_framing_response_to, tvb, 0, 0, reload_frame->data_frame);
      proto_item_set_generated(it);
      nstime_delta(&ns, &pinfo->abs_ts, &reload_frame->req_time);
      it = proto_tree_add_time(reload_framing_tree, hf_reload_framing_time, tvb, 0, 0, &ns);
      proto_item_set_generated(it);
    }
  }
  proto_tree_add_item(reload_framing_tree, hf_reload_framing_type, tvb, offset , 1, ENC_BIG_ENDIAN);
  offset += 1;
  switch (type) {
  case DATA:
  {
    tvbuff_t   *next_tvb;
    proto_item *ti_message;
    proto_tree *message_tree;
    proto_tree_add_item(reload_framing_tree, hf_reload_framing_sequence, tvb, offset , 4, ENC_BIG_ENDIAN);
    offset += 4;
    ti_message = proto_tree_add_item(reload_framing_tree, hf_reload_framing_message, tvb, offset, 3+message_length, ENC_NA);
    proto_item_append_text(ti_message, " (opaque<%d>)", message_length);
    message_tree =  proto_item_add_subtree(ti_message, ett_reload_framing_message);
    proto_tree_add_item(message_tree, hf_reload_framing_message_length, tvb, offset, 3, ENC_BIG_ENDIAN);
    offset += 3;
    proto_tree_add_item(message_tree, hf_reload_framing_message_data, tvb, offset, message_length, ENC_NA);
    next_tvb = tvb_new_subset_length_caplen(tvb, offset, effective_length - offset, message_length);
    if (reload_handle == NULL) {
      expert_add_info(pinfo, ti, &ei_reload_no_dissector);
      return tvb_captured_length(tvb);
    }
    call_dissector_only(reload_handle, next_tvb, pinfo, tree, NULL);
  }
  break;
  case ACK:
  {
    proto_item *ti_received;
    proto_tree_add_uint(reload_framing_tree, hf_reload_framing_ack_sequence, tvb, offset , 4, sequence);
    offset += 4;
    ti_received = proto_tree_add_item(reload_framing_tree, hf_reload_framing_received, tvb, offset , 4, ENC_BIG_ENDIAN);
    {
      guint32     received;
      int         last_received      = -1;
      unsigned int         indx      = 0;
      proto_tree *received_tree;
      proto_item *ti_parsed_received = NULL;
      received = tvb_get_ntohl(tvb, offset);
      while ((indx<32) && (received<<indx) != 0) {
        if (received &(1U<<(31-indx))) {
          if (indx==0) {
            received_tree = proto_item_add_subtree(ti_received, ett_reload_framing_received);
            ti_parsed_received = proto_tree_add_item(received_tree, hf_reload_framing_parsed_received, tvb, offset, 4, ENC_NA);
            proto_item_append_text(ti_parsed_received, "[%u", (sequence -32+indx));
            last_received = indx;
          }
          else {
            if (received &(1U<<(31-indx+1))) {
              indx++;
              continue;
            }
            else {
              if (last_received<0) {
                received_tree = proto_item_add_subtree(ti_received, ett_reload_framing_received);
                ti_parsed_received = proto_tree_add_item(received_tree, hf_reload_framing_parsed_received, tvb, offset, 4, ENC_NA);
                proto_item_append_text(ti_parsed_received, "[%u",(sequence-32+indx));
              }
              else {
                proto_item_append_text(ti_parsed_received, ",%u",(sequence-32+indx));
              }
              last_received = indx;
            }
          }
        }
        else if (indx>0) {
          if ((indx>1) && (received &(1U<<(31-indx+1))) && (received &(1U<<(31-indx+2)))) {
            if ((indx>2) && (received &(1U<<(31-indx+3)))) {
              proto_item_append_text(ti_parsed_received,"-%u",(sequence-32+indx-1));
            }
            else {
              proto_item_append_text(ti_received, ",%u", (sequence-32+indx-1));
            }
          }
          else {
            indx++;
            continue;
          }
        }
        indx++;
      }
      if (last_received>=0) {
        if ((indx>1) && (received &(1U<<(31-indx+1)))  && (received &(1U<<(31-indx+2)))) {
          if ((indx>2) && (received &(1U<<(31-indx+3)))) {
            proto_item_append_text(ti_parsed_received,"-%u",(sequence-32+indx-1));
          }
          else {
            proto_item_append_text(ti_parsed_received, ",%u", (sequence-32+indx-1));
          }
        }
        proto_item_append_text(ti_parsed_received, "]");
        proto_item_set_generated(ti_parsed_received);
      }
    }
  }
  break;
  default:
    DISSECTOR_ASSERT_NOT_REACHED();
  }
  return tvb_captured_length(tvb);
}
