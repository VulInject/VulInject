drange_node_from_str(const char *range_str, char **err_ptr)
{
    const char *str;
    char *endptr;
    int lower, upper = 0;
    drange_node_end_t end = DRANGE_NODE_END_T_UNINITIALIZED;
    drange_node *dn;
    bool ok;
    str = range_str;
    if (*str == ':') {
        lower = 0;
    }
    else {
        if (!drange_str_to_gint32(str, &lower, &endptr, err_ptr))
            return NULL;
        str = endptr;
    }
    while (*str != '\0' && g_ascii_isspace(*str))
        str++;
    if (*str == '-') {
        str++;
        end = DRANGE_NODE_END_T_OFFSET;
        ok = drange_str_to_gint32(str, &upper, &endptr, err_ptr);
        str = endptr;
    }
    else if (*str == ':') {
        str++;
        if (*str == '\0') {
            end = DRANGE_NODE_END_T_TO_THE_END;
            ok = true;
        }
        else {
            end = DRANGE_NODE_END_T_LENGTH;
            ok = drange_str_to_gint32(str, &upper, &endptr, err_ptr);
            str = endptr;
        }
    }
    else if (*str == '\0') {
        end = DRANGE_NODE_END_T_LENGTH;
        upper = 1;
        ok = true;
    }
    else {
        ok = false;
    }
    while (*str != '\0' && g_ascii_isspace(*str))
        str++;
    if (!ok || *str != '\0') {
        *err_ptr = ws_strdup_printf("\"%s\" is not a valid range.", range_str);
        return NULL;
    }
    dn = drange_node_new();
    drange_node_set_start_offset(dn, lower);
    switch (end) {
        case DRANGE_NODE_END_T_LENGTH:
		if(upper == 0) {
                *err_ptr = ws_strdup_printf("Range %s isn't valid "
                                    "because length %d isn't positive",
                                    range_str, upper);
                drange_node_free(dn);
                return NULL;
            }
            drange_node_set_length(dn, upper);
            break;
        case DRANGE_NODE_END_T_OFFSET:
            if ((lower < 0 && upper > 0) || (lower > 0 && upper < 0)) {
                *err_ptr = ws_strdup_printf("Range %s isn't valid "
                                    "because %d and %d have different signs",
                                    range_str, lower, upper);
                drange_node_free(dn);
                return NULL;
            }
            if (upper <= lower) {
                *err_ptr = ws_strdup_printf("Range %s isn't valid "
                                    "because %d is greater or equal than %d",
                                    range_str, lower, upper);
                drange_node_free(dn);
                return NULL;
            }
            drange_node_set_end_offset(dn, upper);
            break;
        case DRANGE_NODE_END_T_TO_THE_END:
            drange_node_set_to_the_end(dn);
            break;
        default:
            ws_assert_not_reached();
            break;
    }
    return dn;
}
