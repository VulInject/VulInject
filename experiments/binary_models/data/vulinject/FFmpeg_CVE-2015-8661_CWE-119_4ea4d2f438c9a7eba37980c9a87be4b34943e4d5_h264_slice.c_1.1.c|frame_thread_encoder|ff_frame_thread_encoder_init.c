av_cold int ff_frame_thread_encoder_init(AVCodecContext *avctx)
{
    int i=0;
    ThreadContext *c;
    AVCodecContext *thread_avctx = NULL;
    int ret;
    if(   !(avctx->thread_type & FF_THREAD_FRAME)
       || !(avctx->codec->capabilities & AV_CODEC_CAP_FRAME_THREADS))
        return 0;
    if(   !avctx->thread_count
       && avctx->codec_id == AV_CODEC_ID_MJPEG
       && !(avctx->flags & AV_CODEC_FLAG_QSCALE)) {
        av_log(avctx, AV_LOG_DEBUG,
               "Forcing thread count to 1 for MJPEG encoding, use -thread_type slice "
               "or a constant quantizer if you want to use multiple cpu cores\n");
        avctx->thread_count = 1;
    }
    if(   avctx->thread_count > 1
       && avctx->codec_id == AV_CODEC_ID_MJPEG
       && !(avctx->flags & AV_CODEC_FLAG_QSCALE))
        av_log(avctx, AV_LOG_WARNING,
               "MJPEG CBR encoding works badly with frame multi-threading, consider "
               "using -threads 1, -thread_type slice or a constant quantizer.\n");
    if (avctx->codec_id == AV_CODEC_ID_HUFFYUV ||
        avctx->codec_id == AV_CODEC_ID_FFVHUFF) {
        int warn = 0;
        int64_t tmp;
        if (avctx->flags & AV_CODEC_FLAG_PASS1)
            warn = 1;
        else if (av_opt_get_int(avctx->priv_data, "context", 0, &tmp) >= 0 &&
                 tmp > 0) {
            warn = av_opt_get_int(avctx->priv_data, "non_deterministic", 0, &tmp) < 0
                   || !tmp;
        }
        // huffyuv does not support these with multiple frame threads currently
        if (warn) {
            av_log(avctx, AV_LOG_WARNING,
               "Forcing thread count to 1 for huffyuv encoding with first pass or context 1\n");
            avctx->thread_count = 1;
        }
    }
    if(!avctx->thread_count) {
        avctx->thread_count = av_cpu_count();
    }
    if(avctx->thread_count <= 1)
        return 0;
    if(avctx->thread_count > MAX_THREADS)
        return AVERROR(EINVAL);
    av_assert0(!avctx->internal->frame_thread_encoder);
    c = avctx->internal->frame_thread_encoder = av_mallocz(sizeof(ThreadContext));
    if(!c)
        return AVERROR(ENOMEM);
    c->parent_avctx = avctx;
    ret = ff_pthread_init(c, thread_ctx_offsets);
    if (ret < 0)
        goto fail;
    atomic_init(&c->exit, 0);
    c->max_tasks = avctx->thread_count + 2;
    for (unsigned j = 0; j < c->max_tasks; j++) {
        if (!(c->tasks[j].indata  = av_frame_alloc()) ||
            !(c->tasks[j].outdata = av_packet_alloc())) {
            ret = AVERROR(ENOMEM);
            goto fail;
        }
    }
    for(i=0; i<avctx->thread_count ; i++){
        void *tmpv;
        thread_avctx = avcodec_alloc_context3(avctx->codec);
        if (!thread_avctx) {
            ret = AVERROR(ENOMEM);
            goto fail;
        }
        tmpv = thread_avctx->priv_data;
        *thread_avctx = *avctx;
        thread_avctx->priv_data = tmpv;
        thread_avctx->internal = NULL;
        thread_avctx->hw_frames_ctx = NULL;
        ret = av_opt_copy(thread_avctx, avctx);
        if (ret < 0)
            goto fail;
        if (avctx->codec->priv_class) {
            ret = av_opt_copy(thread_avctx->priv_data, avctx->priv_data);
            if (ret < 0)
                goto fail;
        }
        thread_avctx->thread_count = 1;
        thread_avctx->active_thread_type &= ~FF_THREAD_FRAME;
        if ((ret = avcodec_open2(thread_avctx, avctx->codec, NULL)) < 0)
            goto fail;
        av_assert0(!thread_avctx->internal->frame_thread_encoder);
        thread_avctx->internal->frame_thread_encoder = c;
        if ((ret = pthread_create(&c->worker[i], NULL, worker, thread_avctx))) {
            ret = AVERROR(ret);
            goto fail;
        }
    }
    avctx->active_thread_type = FF_THREAD_FRAME;
    return 0;
fail:
    avcodec_close(thread_avctx);
    av_freep(&thread_avctx);
    avctx->thread_count = i;
    av_log(avctx, AV_LOG_ERROR, "ff_frame_thread_encoder_init failed\n");
    ff_frame_thread_encoder_free(avctx);
    return ret;
}
