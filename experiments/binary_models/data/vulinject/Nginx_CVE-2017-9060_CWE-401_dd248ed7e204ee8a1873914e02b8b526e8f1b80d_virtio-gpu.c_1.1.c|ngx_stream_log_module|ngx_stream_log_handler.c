ngx_stream_log_handler(ngx_stream_session_t *s)
{
    u_char                     *line, *p;
    size_t                      len, size;
    ssize_t                     n;
    ngx_str_t                   val;
    ngx_uint_t                  i, l;
    ngx_stream_log_t           *log;
    ngx_stream_log_op_t        *op;
    ngx_stream_log_buf_t       *buffer;
    ngx_stream_log_srv_conf_t  *lscf;
    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   "stream log handler");
    lscf = ngx_stream_get_module_srv_conf(s, ngx_stream_log_module);
    if (lscf->off || lscf->logs == NULL) {
        return NGX_OK;
    }
    log = lscf->logs->elts;
    for (l = 0; l < lscf->logs->nelts; l++) {
        if (log[l].filter) {
            if (ngx_stream_complex_value(s, log[l].filter, &val) != NGX_OK) {
                return NGX_ERROR;
            }
            if (val.len == 0 || (val.len == 1 && val.data[0] == '0')) {
                continue;
            }
        }
        if (ngx_time() == log[l].disk_full_time) {
            continue;
        }
        ngx_stream_script_flush_no_cacheable_variables(s,
                                                       log[l].format->flushes);
        len = 0;
        op = log[l].format->ops->elts;
        for (i = 0; i < log[l].format->ops->nelts; i++) {
            if (op[i].len == 0) {
                len += op[i].getlen(s, op[i].data);
            } else {
                len += op[i].len;
            }
        }
        if (log[l].syslog_peer) {
            len += sizeof("<255>Jan 01 00:00:00 ") - 1
                   + ngx_cycle->hostname.len + 1
                   + log[l].syslog_peer->tag.len + 2;
            goto alloc_line;
        }
        len += NGX_LINEFEED_SIZE;
        buffer = log[l].file ? log[l].file->data : NULL;
        if (buffer) {
            if (len > (size_t) (buffer->last - buffer->pos)) {
                ngx_stream_log_write(s, &log[l], buffer->start,
                                     buffer->pos - buffer->start);
                buffer->pos = buffer->start;
            }
            if (len <= (size_t) (buffer->last - buffer->pos)) {
                p = buffer->pos;
                if (buffer->event && p == buffer->start) {
                    ngx_add_timer(buffer->event, buffer->flush);
                }
                for (i = 0; i < log[l].format->ops->nelts; i++) {
                    p = op[i].run(s, p, &op[i]);
                }
                buffer->pos = p;
                continue;
            }
            if (buffer->event && buffer->event->timer_set) {
                ngx_del_timer(buffer->event);
            }
        }
    alloc_line:
        line = ngx_pnalloc(s->connection->pool, len);
        if (line == NULL) {
            return NGX_ERROR;
        }
        p = line;
        if (log[l].syslog_peer) {
            p = ngx_syslog_add_header(log[l].syslog_peer, line);
        }
        for (i = 0; i < log[l].format->ops->nelts; i++) {
            p = op[i].run(s, p, &op[i]);
        }
        if (log[l].syslog_peer) {
            size = p - line;
            n = ngx_syslog_send(log[l].syslog_peer, line, size);
            if (n < 0) {
                ngx_log_error(NGX_LOG_WARN, s->connection->log, 0,
                              "send() to syslog failed");
            } else if ((size_t) n != size) {
                ngx_log_error(NGX_LOG_WARN, s->connection->log, 0,
                              "send() to syslog has written only %z of %uz",
                              n, size);
            }
            continue;
        }
        ngx_linefeed(p);
        ngx_stream_log_write(s, &log[l], line, p - line);
    }
    return NGX_OK;
}
