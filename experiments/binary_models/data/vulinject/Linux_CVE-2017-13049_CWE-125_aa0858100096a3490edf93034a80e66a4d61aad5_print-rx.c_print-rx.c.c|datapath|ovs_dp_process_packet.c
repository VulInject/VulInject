void ovs_dp_process_packet(struct sk_buff *skb, struct sw_flow_key *key)
{
	const struct vport *p = OVS_CB(skb)->input_vport;
	struct datapath *dp = p->dp;
	struct sw_flow *flow;
	struct sw_flow_actions *sf_acts;
	struct dp_stats_percpu *stats;
	unsigned int int *stats_counter;
	unsigned int n_mask_hit;
	unsigned int n_cache_hit;
	int error;
	stats = this_cpu_ptr(dp->stats_percpu);
	flow = ovs_flow_tbl_lookup_stats(&dp->table, key, skb_get_hash(skb),
					 &n_mask_hit, &n_cache_hit);
	if (unlikely(!flow)) {
		struct dp_upcall_info upcall;
		memset(&upcall, 0, sizeof(upcall));
		upcall.cmd = OVS_PACKET_CMD_MISS;
		if (dp->user_features & OVS_DP_F_DISPATCH_UPCALL_PER_CPU)
			upcall.portid =
			    ovs_dp_get_upcall_portid(dp, smp_processor_id());
		else
			upcall.portid = ovs_vport_find_upcall_portid(p, skb);
		upcall.mru = OVS_CB(skb)->mru;
		error = ovs_dp_upcall(dp, skb, key, &upcall, 0);
		switch (error) {
		case 0:
		case -EAGAIN:
		case -ERESTARTSYS:
		case -EINTR:
			break;
		default:
			kfree_skb(skb);
			break;
		}
		stats_counter = &stats->n_missed;
		goto out;
	}
	ovs_flow_stats_update(flow, key->tp.flags, skb);
	sf_acts = rcu_dereference(flow->sf_acts);
	error = ovs_execute_actions(dp, skb, sf_acts, key);
	if (unlikely(error))
		net_dbg_ratelimited("ovs: action execution error on datapath %s: %d\n",
				    ovs_dp_name(dp), error);
	stats_counter = &stats->n_hit;
out:
	u64_stats_update_begin(&stats->syncp);
	(*stats_counter)++;
	stats->n_mask_hit += n_mask_hit;
	stats->n_cache_hit += n_cache_hit;
	u64_stats_update_end(&stats->syncp);
}
