dissect_dtls_handshake(tvbuff_t *tvb, packet_info *pinfo,
                       proto_tree *tree, guint32 offset,
                       guint32 record_length, gboolean maybe_encrypted,
                       SslSession *session, gint is_from_server,
                       SslDecryptSession* ssl, guint8 content_type)
{
  proto_tree  *ti, *length_item = NULL, *fragment_length_item = NULL;
  proto_tree  *ssl_hand_tree;
  const gchar *msg_type_str;
  guint8       msg_type;
  guint32      length;
  guint16      version;
  guint16      message_seq;
  guint32      fragment_offset;
  guint32      fragment_length;
  gboolean     first_iteration;
  guint32      reassembled_length;
  tvbuff_t     *sub_tvb;
  msg_type_str    = NULL;
  first_iteration = TRUE;
  record_length += offset;
  for (; offset < record_length; offset += fragment_length,
         first_iteration = FALSE) 
    {
      fragment_head *frag_msg = NULL;
      tvbuff_t      *new_tvb  = NULL;
      const gchar   *frag_str = NULL;
      gboolean       fragmented;
      guint32        hs_offset = offset;
      bool           is_hrr = 0;
      ti = proto_tree_add_item(tree, hf_dtls_handshake_protocol, tvb, offset, -1, ENC_NA);
      ssl_hand_tree = proto_item_add_subtree(ti, ett_dtls_handshake);
      msg_type = tvb_get_guint8(tvb, offset);
      fragment_length = tvb_get_ntoh24(tvb, offset + 9);
      if (!maybe_encrypted || offset + fragment_length <= record_length) {
        if (msg_type == SSL_HND_SERVER_HELLO) {
          tls_scan_server_hello(tvb, offset+12, fragment_length, &version, &is_hrr);
        }
        if (is_hrr) {
            msg_type_str = try_val_to_str(SSL_HND_HELLO_RETRY_REQUEST, ssl_31_handshake_type);
        } else {
            msg_type_str = try_val_to_str(msg_type, ssl_31_handshake_type);
        }
      }
      if (!msg_type_str && !first_iteration)
        {
          return;
        }
      if (msg_type_str)
        {
          col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, msg_type_str);
        }
      else
        {
          col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Encrypted Handshake Message");
          return;
        }
      proto_tree_add_uint(ssl_hand_tree, hf_dtls_handshake_type,
                            tvb, offset, 1, msg_type);
      offset++;
      length = tvb_get_ntoh24(tvb, offset);
      length_item = proto_tree_add_uint(ssl_hand_tree, hf_dtls_handshake_length,
                                          tvb, offset, 3, length);
      offset += 3;
      message_seq = tvb_get_ntohs(tvb,offset);
      proto_tree_add_uint(ssl_hand_tree, hf_dtls_handshake_message_seq,
                            tvb, offset, 2, message_seq);
      offset += 2;
      fragment_offset = tvb_get_ntoh24(tvb, offset);
      proto_tree_add_uint(ssl_hand_tree, hf_dtls_handshake_fragment_offset,
                            tvb, offset, 3, fragment_offset);
      offset += 3;
      fragment_length_item = proto_tree_add_uint(ssl_hand_tree,
                                                   hf_dtls_handshake_fragment_length,
                                                   tvb, offset, 3,
                                                   fragment_length);
      offset += 3;
      proto_item_set_len(ti, fragment_length + 12);
      fragmented = FALSE;
      if (fragment_length + fragment_offset > length)
        {
          if (fragment_offset == 0)
            {
              expert_add_info(pinfo, fragment_length_item, &ei_dtls_handshake_fragment_length_too_long);
            }
          else
            {
              fragmented = TRUE;
              expert_add_info(pinfo, fragment_length_item, &ei_dtls_handshake_fragment_past_end_msg);
            }
        }
      else if (fragment_offset > 0 && fragment_length == 0)
        {
          expert_add_info(pinfo, fragment_length_item, &ei_dtls_handshake_fragment_length_zero);
          continue;
        }
      else if (fragment_length < length)
        {
          fragmented = TRUE;
          if (ssl_is_valid_handshake_type(msg_type, TRUE))
            {
              pinfo->fragmented = TRUE;
              tvb_ensure_bytes_exist(tvb, offset, fragment_length);
              frag_msg = fragment_add(&dtls_reassembly_table,
                                      tvb, offset, pinfo, message_seq, NULL,
                                      fragment_offset, fragment_length, TRUE);
              reassembled_length = fragment_get_tot_len(&dtls_reassembly_table,
                                                        pinfo, message_seq, NULL);
              if (reassembled_length == 0)
                {
                  fragment_set_tot_len(&dtls_reassembly_table,
                                       pinfo, message_seq, NULL, length);
                }
              else
                {
                  if (reassembled_length != length)
                    {
                      expert_add_info(pinfo, length_item, &ei_dtls_msg_len_diff_fragment);
                    }
                }
              if (frag_msg && (fragment_length + fragment_offset) == reassembled_length)
                {
                  new_tvb = process_reassembled_data(tvb, offset, pinfo,
                                                     "Reassembled DTLS",
                                                     frag_msg,
                                                     &dtls_frag_items,
                                                     NULL, tree);
                  frag_str = " (Reassembled)";
                }
              else
                {
                  frag_str = " (Fragment)";
                }
              col_append_str(pinfo->cinfo, COL_INFO, frag_str);
            }
        }
      if (tree)
        {
          if (first_iteration)
            {
              proto_item_set_text(tree, "%s Record Layer: %s Protocol: %s%s",
                                  val_to_str_const(session->version, ssl_version_short_names, "DTLS"),
                                  val_to_str_const(content_type, ssl_31_content_type, "unknown"),
                                  msg_type_str, (frag_str!=NULL) ? frag_str : "");
            }
          else
            {
              proto_item_set_text(tree, "%s Record Layer: %s Protocol: %s%s",
                                  val_to_str_const(session->version, ssl_version_short_names, "DTLS"),
                                  val_to_str_const(content_type, ssl_31_content_type, "unknown"),
                                  "Multiple Handshake Messages",
                                  (frag_str!=NULL) ? frag_str : "");
            }
          if (ssl_hand_tree)
            {
              proto_item_set_text(ssl_hand_tree, "Handshake Protocol: %s%s",
                                  msg_type_str, (frag_str!=NULL) ? frag_str : "");
            }
        }
        if (fragmented && !new_tvb)
        {
          continue;
        }
        if (new_tvb)
        {
          sub_tvb = new_tvb;
        }
        else
        {
          sub_tvb = tvb_new_subset_length(tvb, offset, fragment_length);
        }
        if ((msg_type == SSL_HND_CLIENT_HELLO || msg_type == SSL_HND_SERVER_HELLO)) {
            ssl_reset_session(session, ssl, msg_type == SSL_HND_CLIENT_HELLO);
        }
        if (msg_type != SSL_HND_CERT_VERIFY) {
          if (fragment_offset == 0) {
            ssl_calculate_handshake_hash(ssl, tvb, hs_offset, 12 + fragment_length);
          } else {
            ssl_calculate_handshake_hash(ssl, tvb, hs_offset, 6);
            ssl_calculate_handshake_hash(ssl, NULL, 0, 3);
            ssl_calculate_handshake_hash(ssl, tvb, hs_offset + 1, 3);
            ssl_calculate_handshake_hash(ssl, sub_tvb, 0, length);
          }
        }
        switch ((HandshakeType) msg_type) {
          case SSL_HND_HELLO_REQUEST:
            break;
          case SSL_HND_CLIENT_HELLO:
            if (ssl) {
              ssl_set_server(session, &pinfo->dst, pinfo->ptype, pinfo->destport);
            }
            ssl_dissect_hnd_cli_hello(&dissect_dtls_hf, sub_tvb, pinfo,
                                      ssl_hand_tree, 0, length, session, ssl,
                                      &dtls_hfs);
            if (ssl) {
                tls_save_crandom(ssl, tls_get_master_key_map(FALSE));
            }
            break;
          case SSL_HND_SERVER_HELLO:
            tls_scan_server_hello(sub_tvb, 0, fragment_length, &version, &is_hrr);
            ssl_try_set_version(session, ssl, SSL_ID_HANDSHAKE, SSL_HND_SERVER_HELLO, TRUE, version);
            ssl_dissect_hnd_srv_hello(&dissect_dtls_hf, sub_tvb, pinfo, ssl_hand_tree,
                                      0, length, session, ssl, TRUE, is_hrr);
            break;
          case SSL_HND_HELLO_VERIFY_REQUEST:
            if (ssl && ssl->handshake_data.data_len) {
              ssl_debug_printf("%s erasing previous handshake_messages: %d\n", G_STRFUNC, ssl->handshake_data.data_len);
              wmem_free(wmem_file_scope(), ssl->handshake_data.data);
              ssl->handshake_data.data = NULL;
            }
            dissect_dtls_hnd_hello_verify_request(&dissect_dtls_hf, sub_tvb, pinfo,
                                                  ssl_hand_tree, 0, length);
            break;
          case SSL_HND_NEWSESSION_TICKET:
            ssl_dissect_hnd_new_ses_ticket(&dissect_dtls_hf, sub_tvb, pinfo,
                                           ssl_hand_tree, 0, length, session, ssl, TRUE,
                                           tls_get_master_key_map(FALSE)->tickets);
            break;
          case SSL_HND_HELLO_RETRY_REQUEST:
            ssl_dissect_hnd_hello_retry_request(&dissect_dtls_hf, sub_tvb, pinfo, ssl_hand_tree,
                                                0, length, session, ssl, TRUE);
            break;
          case SSL_HND_CERTIFICATE:
            ssl_dissect_hnd_cert(&dissect_dtls_hf, sub_tvb, ssl_hand_tree, 0, length,
                pinfo, session, ssl, is_from_server, TRUE);
            break;
          case SSL_HND_SERVER_KEY_EXCHG:
            ssl_dissect_hnd_srv_keyex(&dissect_dtls_hf, sub_tvb, pinfo, ssl_hand_tree, 0, length, session);
            break;
          case SSL_HND_CERT_REQUEST:
            ssl_dissect_hnd_cert_req(&dissect_dtls_hf, sub_tvb, pinfo, ssl_hand_tree, 0, length, session, TRUE);
            break;
          case SSL_HND_SVR_HELLO_DONE:
            session->is_session_resumed = FALSE;
            break;
          case SSL_HND_CERT_VERIFY:
            ssl_dissect_hnd_cli_cert_verify(&dissect_dtls_hf, sub_tvb, pinfo, ssl_hand_tree, 0, length, session->version);
            break;
          case SSL_HND_CLIENT_KEY_EXCHG:
            ssl_dissect_hnd_cli_keyex(&dissect_dtls_hf, sub_tvb, ssl_hand_tree, 0, length, session);
            if (!ssl)
                break;
            if (!ssl_generate_pre_master_secret(ssl, length, sub_tvb, 0,
                                                dtls_options.psk, pinfo,
#ifdef HAVE_LIBGNUTLS
                                                dtls_key_hash,
#endif
                                                tls_get_master_key_map(TRUE))) {
                ssl_debug_printf("dissect_dtls_handshake can't generate pre master secret\n");
            }
            break;
          case SSL_HND_FINISHED:
            ssl_dissect_hnd_finished(&dissect_dtls_hf, sub_tvb, ssl_hand_tree,
                                     0, length, session, NULL);
            break;
          case SSL_HND_CERT_STATUS:
            tls_dissect_hnd_certificate_status(&dissect_dtls_hf, sub_tvb, pinfo, ssl_hand_tree, 0, length);
            break;
          case SSL_HND_CERT_URL:
          case SSL_HND_SUPPLEMENTAL_DATA:
          case SSL_HND_KEY_UPDATE:
            tls13_dissect_hnd_key_update(&dissect_dtls_hf, sub_tvb, ssl_hand_tree, 0);
            if (ssl && ssl->session.version == DTLSV1DOT3_VERSION) {
              ssl->session.dtls13_current_epoch[is_from_server]++;
            }
            break;
          case SSL_HND_ENCRYPTED_EXTS:
          case SSL_HND_END_OF_EARLY_DATA: 
          case SSL_HND_COMPRESSED_CERTIFICATE:
            break;
          case SSL_HND_ENCRYPTED_EXTENSIONS: 
            ssl_dissect_hnd_encrypted_extensions(&dissect_dtls_hf, sub_tvb, pinfo, ssl_hand_tree, 0, length, session, ssl, 1);
            break;
        }
    }
}
