dissect_ssl3_record(tvbuff_t *tvb, packet_info *pinfo,
                    proto_tree *tree, guint32 offset,
                    SslSession *session, gint is_from_server,
                    gboolean *need_desegmentation,
                    SslDecryptSession *ssl,
                    guint8 curr_layer_num_ssl, struct tlsinfo *tlsinfo)
{
    guint32         record_length;
    guint16         record_version, version;
    guint8          content_type;
    guint8          next_byte;
    proto_tree     *ti;
    proto_tree     *ssl_record_tree;
    proto_item     *length_pi, *ct_pi;
    guint           content_type_offset;
    guint32         available_bytes;
    tvbuff_t       *decrypted;
    SslRecordInfo  *record = NULL;
    ti = NULL;
    ssl_record_tree = NULL;
    available_bytes = tvb_reported_length_remaining(tvb, offset);
    if ((session->version==TLSV1_VERSION ||
         session->version==TLSV1DOT1_VERSION ||
         session->version==TLSV1DOT2_VERSION ||
         session->version==TLCPV1_VERSION ) &&
        (available_bytes >=1 ) && !ssl_is_valid_content_type(tvb_get_guint8(tvb, offset))) {
        proto_tree_add_expert(tree, pinfo, &ei_tls_ignored_unknown_record, tvb, offset, available_bytes);
        col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Ignored Unknown Record");
        return offset + available_bytes;
    }
    if (available_bytes < 5) {
        ssl_proto_tree_add_segment_data(tree, tvb, offset, -1, NULL);
        if (tls_desegment && pinfo->can_desegment) {
            pinfo->desegment_offset = offset;
            pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;
            *need_desegmentation = TRUE;
            return offset;
        } else {
            return offset + available_bytes;
        }
    }
    content_type  = tvb_get_guint8(tvb, offset);
    version       = tvb_get_ntohs(tvb, offset + 1);
    record_version = version;
    record_length = tvb_get_ntohs(tvb, offset + 3);
    if (ssl_is_valid_content_type(content_type)) {
        if (available_bytes < record_length + 5) {
            ssl_proto_tree_add_segment_data(tree, tvb, offset, -1, NULL);
            if (tls_desegment && pinfo->can_desegment) {
                pinfo->desegment_offset = offset;
                pinfo->desegment_len = (record_length + 5) - available_bytes;
                *need_desegmentation = TRUE;
                return offset;
            } else {
                return offset + available_bytes;
            }
        }
    } else {
        col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Continuation Data");
        return offset + 5 + record_length;
    }
    ti = proto_tree_add_item(tree, hf_tls_record, tvb,
                             offset, 5 + record_length, ENC_NA);
    ssl_record_tree = proto_item_add_subtree(ti, ett_tls_record);
    if (session->version == TLSV1DOT3_VERSION && content_type == SSL_ID_APP_DATA) {
        ct_pi = proto_tree_add_item(ssl_record_tree, hf_tls_record_opaque_type,
                            tvb, offset, 1, ENC_BIG_ENDIAN);
    } else {
        ct_pi = proto_tree_add_item(ssl_record_tree, hf_tls_record_content_type,
                            tvb, offset, 1, ENC_BIG_ENDIAN);
    }
    content_type_offset = offset;
    offset++;
    proto_tree_add_item(ssl_record_tree, hf_tls_record_version, tvb,
                        offset, 2, ENC_BIG_ENDIAN);
    offset += 2;
    length_pi = proto_tree_add_uint(ssl_record_tree, hf_tls_record_length, tvb,
                        offset, 2, record_length);
    offset += 2;    
    next_byte = tvb_get_guint8(tvb, offset);
    if (session->version == SSL_VER_UNKNOWN) {
        ssl_try_set_version(session, ssl, content_type, next_byte, FALSE, version);
        col_set_str(pinfo->cinfo, COL_PROTOCOL,
                            val_to_str_const(version, ssl_version_short_names, "SSL"));
    } else {
        version = session->version;
    }
    ssl_debug_printf("dissect_ssl3_record: content_type %d %s\n",content_type, val_to_str_const(content_type, ssl_31_content_type, "unknown"));
    if (ssl && record_length && (session->version != TLSV1DOT3_VERSION || content_type == SSL_ID_APP_DATA)) {
        gboolean    decrypt_ok = FALSE;
        if (session->version == TLSV1DOT3_VERSION && content_type == SSL_ID_APP_DATA &&
            ssl->has_early_data && !ssl_packet_from_server(session, ssl_associations, pinfo)) {
            decrypt_ok = decrypt_tls13_early_data(tvb, pinfo, offset, record_length, ssl, curr_layer_num_ssl);
            if (!decrypt_ok) {
                if (ssl->state & SSL_SERVER_RANDOM) {
                    tls13_change_key(ssl, &ssl_master_key_map, FALSE, TLS_SECRET_HANDSHAKE);
                }
                ssl->has_early_data = FALSE;
            }
        }
        if (!decrypt_ok) {
            decrypt_ssl3_record(tvb, pinfo, offset, ssl,
                content_type, record_version, record_length,
                content_type == SSL_ID_APP_DATA ||
                content_type == SSL_ID_HANDSHAKE, curr_layer_num_ssl);
        }
    }
    decrypted = ssl_get_record_info(tvb, proto_tls, pinfo, tvb_raw_offset(tvb)+offset, curr_layer_num_ssl, &record);
    if (decrypted) {
        add_new_data_source(pinfo, decrypted, "Decrypted TLS");
        if (session->version == TLSV1DOT3_VERSION) {
            content_type = record->type;
            ti = proto_tree_add_uint(ssl_record_tree, hf_tls_record_content_type,
                                     tvb, content_type_offset, 1, record->type);
        }
    }
    ssl_check_record_length(&dissect_ssl3_hf, pinfo, (ContentType)content_type, record_length, length_pi, version, decrypted);
    switch ((ContentType) content_type) {
    case SSL_ID_CHG_CIPHER_SPEC:
        if (version == TLSV1DOT3_VERSION && session->tls13_draft_version > 0 && session->tls13_draft_version < 22) {
            expert_add_info_format(pinfo, ct_pi, &ei_tls_unexpected_message,
                                   "Record type is not allowed in TLS 1.3");
            break;
        }
        col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Change Cipher Spec");
        ssl_dissect_change_cipher_spec(&dissect_ssl3_hf, tvb, pinfo,
                                       ssl_record_tree, offset, session,
                                       is_from_server, ssl);
        if (version == TLSV1DOT3_VERSION) {
            break;
        }
        if (ssl) {
            ssl_load_keyfile(ssl_options.keylog_filename, &ssl_keylog_file,
                             &ssl_master_key_map);
            ssl_finalize_decryption(ssl, &ssl_master_key_map);
            ssl_change_cipher(ssl, ssl_packet_from_server(session, ssl_associations, pinfo));
        }
        if (is_from_server)
          session->is_session_resumed = FALSE;
        break;
    case SSL_ID_ALERT:
        if (decrypted) {
            dissect_ssl3_alert(decrypted, pinfo, ssl_record_tree, 0, 2, session, tlsinfo);
        } else {
            dissect_ssl3_alert(tvb, pinfo, ssl_record_tree, offset, record_length, session, tlsinfo);
        }
        break;
    case SSL_ID_HANDSHAKE:
        if (decrypted) {
            guint record_id = record->id;
            dissect_tls_handshake(decrypted, pinfo, ssl_record_tree, 0,
                                  tvb_reported_length(decrypted), FALSE, record_id, curr_layer_num_ssl, session,
                                  is_from_server, ssl, version);
        } else {
            guint record_id = tvb_raw_offset(tvb) + offset + curr_layer_num_ssl;
            dissect_tls_handshake(tvb, pinfo, ssl_record_tree, offset,
                                  offset + record_length, TRUE, record_id, curr_layer_num_ssl, session,
                                  is_from_server, ssl, version);
        }
        break;
    case SSL_ID_APP_DATA:
    {
        dissector_handle_t app_handle;
        col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Application Data");
        app_handle = session->app_handle;
        if (!app_handle) {
            app_handle = dissector_get_uint_handle(ssl_associations, pinfo->srcport);
            if (!app_handle) app_handle = dissector_get_uint_handle(ssl_associations, pinfo->destport);
        }
        proto_item_set_text(ssl_record_tree,
           "%s Record Layer: %s Protocol: %s",
            val_to_str_const(version, ssl_version_short_names, "SSL"),
            val_to_str_const(content_type, ssl_31_content_type, "unknown"),
            app_handle ? dissector_handle_get_protocol_long_name(app_handle)
            : "Application Data");
        proto_tree_add_item(ssl_record_tree, hf_tls_record_appdata, tvb,
                       offset, record_length, ENC_NA);
        if (app_handle) {
            ti = proto_tree_add_string(ssl_record_tree, hf_tls_record_appdata_proto, tvb, 0, 0, dissector_handle_get_protocol_long_name(app_handle));
            proto_item_set_generated(ti);
        }
        if (decrypted) {
            dissect_ssl_payload(decrypted, pinfo, tree, session, record, app_handle, tlsinfo);
        }
        if (session->app_handle && session->app_handle != app_handle)
            proto_item_set_text(ssl_record_tree,
               "%s Record Layer: %s Protocol: %s",
                val_to_str_const(version, ssl_version_short_names, "SSL"),
                val_to_str_const(content_type, ssl_31_content_type, "unknown"),
                dissector_handle_get_protocol_long_name(session->app_handle));
        break;
    }
    case SSL_ID_HEARTBEAT:
        if (version == TLSV1DOT3_VERSION) {
            expert_add_info_format(pinfo, ct_pi, &ei_tls_unexpected_message,
                                   "Record type is not allowed in TLS 1.3");
            break;
        }
        if (decrypted) {
            dissect_ssl3_heartbeat(decrypted, pinfo, ssl_record_tree, 0, session, tvb_reported_length (decrypted), TRUE);
        } else {
            gboolean plaintext = TRUE;
            if (ssl) {
                if (ssl_packet_from_server(session, ssl_associations, pinfo)) {
                    plaintext = ssl->server == NULL;
                } else {
                    plaintext = ssl->client == NULL;
                }
            }
            dissect_ssl3_heartbeat(tvb, pinfo, ssl_record_tree, offset, session, record_length, plaintext);
        }
        break;
    case SSL_ID_TLS12_CID:
    case SSL_ID_DTLS13_ACK:
        break;
    }
    offset += record_length; 
    return offset;
}
