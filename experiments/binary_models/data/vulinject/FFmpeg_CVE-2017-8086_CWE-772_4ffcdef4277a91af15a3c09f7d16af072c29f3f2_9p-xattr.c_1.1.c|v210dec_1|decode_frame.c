static int decode_frame(AVCodecContext *avctx, AVFrame *pic,
                        int *got_frame, AVPacket *avpkt)
{
    V210DecContext *s = avctx->priv_data;
    ThreadData td;
    int ret, stride, aligned_input;
    const uint8_t *psrc = avpkt->data;
    if (s->custom_stride )
        stride = s->custom_stride > 0 ? s->custom_stride : 0;
    else {
        stride = v210_stride(avctx->width, 48);
        if (avpkt->size < stride * avctx->height) {
            int align;
            for (align = 24; align >= 6; align >>= 1) {
                int small_stride = v210_stride(avctx->width, align);
                if (avpkt->size == small_stride * avctx->height) {
                    stride = small_stride;
                    if (!s->stride_warning_shown)
                        av_log(avctx, AV_LOG_WARNING, "Broken v210 with too small padding (%d byte) detected\n", align * 8 / 3);
                    s->stride_warning_shown = 1;
                    break;
                }
            }
            if (align < 6 && avctx->codec_tag == MKTAG('b', 'x', 'y', '2'))
                stride = 0;
        }
    }
    if (stride == 0 && ((avctx->width & 1) || (int64_t)avctx->width * avctx->height > INT_MAX / 6)) {
        av_log(avctx, AV_LOG_ERROR, "Strideless v210 is not supported for size %dx%d\n", avctx->width, avctx->height);
        return AVERROR_INVALIDDATA;
    }
    if (stride  > 0 && avpkt->size < (int64_t)stride * avctx->height ||
        stride == 0 && avpkt->size < v210_stride(avctx->width * avctx->height, 6)) {
        av_log(avctx, AV_LOG_ERROR, "packet too small\n");
        return AVERROR_INVALIDDATA;
    }
    if (   avctx->codec_tag == MKTAG('C', '2', '1', '0')
        && avpkt->size > 64
        && AV_RN32(psrc) == AV_RN32("INFO")
        && avpkt->size - 64 >= stride * avctx->height)
        psrc += 64;
    aligned_input = !((uintptr_t)psrc & 0x1f) && !(stride & 0x1f);
    if (aligned_input != s->aligned_input) {
        s->aligned_input = aligned_input;
    }
    if ((ret = ff_thread_get_buffer(avctx, pic, 0)) < 0)
        return ret;
    pic->pict_type = AV_PICTURE_TYPE_I;
    pic->flags |= AV_FRAME_FLAG_KEY;
    if (stride) {
        td.stride = stride;
        td.buf = psrc;
        td.frame = pic;
        avctx->execute2(avctx, v210_decode_slice, &td, NULL, s->thread_count);
    } else {
        uint8_t *pointers[4];
        int linesizes[4];
        int ret = av_image_alloc(pointers, linesizes, avctx->width, avctx->height, avctx->pix_fmt, 1);
        if (ret < 0)
            return ret;
        decode_row((const uint32_t *)psrc, (uint16_t *)pointers[0], (uint16_t *)pointers[1], (uint16_t *)pointers[2], avctx->width * avctx->height, s->unpack_frame);
        av_image_copy2(pic->data, pic->linesize, pointers, linesizes,
                       avctx->pix_fmt, avctx->width, avctx->height);
        av_freep(&pointers[0]);
    }
    if (avctx->field_order > AV_FIELD_PROGRESSIVE) {
        /* we have interlaced material flagged in container */
        pic->flags |= AV_FRAME_FLAG_INTERLACED;
        if (avctx->field_order == AV_FIELD_TT || avctx->field_order == AV_FIELD_TB)
            pic->flags |= AV_FRAME_FLAG_TOP_FIELD_FIRST;
    }
    *got_frame      = 1;
    return avpkt->size;
}
