static void net_l2tpv3_send(void *opaque)
{
    NetL2TPV3State *s = opaque;
    int target_count, count;
    struct mmsghdr *msgvec;
    /* go into ring mode only if there is a "pending" tail */
    if (s->queue_depth) {
        /* The ring buffer we use has variable intake
         * count of how much we can read varies - adjust accordingly
         */
        target_count = MAX_L2TPV3_MSGCNT - s->queue_depth;
        /* Ensure we do not overrun the ring when we have
         * a lot of enqueued packets
         */
        if (s->queue_head + target_count > MAX_L2TPV3_MSGCNT) {
            target_count = MAX_L2TPV3_MSGCNT - s->queue_head;
        }
    } else {
        /* we do not have any pending packets - we can use
        * the whole message vector linearly instead of using
        * it as a ring
        */
        s->queue_head = 0;
        s->queue_tail = 0;
        target_count = MAX_L2TPV3_MSGCNT;
    }
    msgvec = s->msgvec + s->queue_head;
    if (target_count > 0) {
        count = RETRY_ON_EINTR(
                recvmmsg(s->fd, msgvec, target_count, MSG_DONTWAIT, NULL)
        );
        if (count < 0) {
            /* Recv error - we still need to flush packets here,
             * (re)set queue head to current position
             */
            count = 0;
        }
        s->queue_head = (s->queue_head + count) % MAX_L2TPV3_MSGCNT;
        s->queue_depth += count;
    }
}
