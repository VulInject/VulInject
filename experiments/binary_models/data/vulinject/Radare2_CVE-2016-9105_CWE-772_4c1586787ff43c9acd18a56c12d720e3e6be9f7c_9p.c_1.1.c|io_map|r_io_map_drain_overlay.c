R_API void r_io_map_drain_overlay(RIOMap *map) {
	r_return_if_fail (map);
	if (!map->overlay || map->overlay->size < 2) {
		return;
	}
	RQueue *q = r_queue_new (map->overlay->size - 1);
	if (!q) {
		return;
	}
	RRBNode *start_n = r_crbtree_first_node (map->overlay);
	RRBNode *cur_n = start_n;
	RRBNode *next_n = r_rbnode_next (cur_n);
	while (next_n) {
		MapOverlayChunk *cur = (MapOverlayChunk *)cur_n->data;
		MapOverlayChunk *next = (MapOverlayChunk *)next_n->data;
		if (r_itv_end (cur->itv) == r_itv_begin (next->itv)) {
			cur_n = next_n;
		} else {
			if (!r_queue_is_empty (q)) {
				MapOverlayChunk *start = (MapOverlayChunk *)start_n->data;
				const ut64 new_size = r_itv_end (cur->itv) - r_itv_begin (start->itv);
				ut8 *buf = realloc (start->buf, new_size * sizeof (ut8));
				if (buf) {
					start->buf = buf;
					memcpy (&buf[r_itv_begin (cur->itv) - r_itv_begin (start->itv)],
						cur->buf, r_itv_size (cur->itv));
					r_crbtree_delete (map->overlay, cur, _overlay_chunk_insert, NULL);
					r_queue_dequeue (q);	
					while (!r_queue_is_empty (q)) {
						cur = (MapOverlayChunk *)r_queue_dequeue (q);
						memcpy (&buf[r_itv_begin (cur->itv) - r_itv_begin (start->itv)],
							cur->buf, r_itv_size (cur->itv));
						r_crbtree_delete (map->overlay, cur, _overlay_chunk_insert, NULL);
					}
					start->itv.size = new_size;
				} else {
					while (!r_queue_is_empty (q)) {
						r_queue_dequeue (q);
					}
				}
				start_n = cur_n = next_n;
			}
		}
		next_n = r_rbnode_next (next_n);
	}
	if (!r_queue_is_empty (q)) {
		MapOverlayChunk *cur = (MapOverlayChunk *)cur_n->data;
		MapOverlayChunk *start = (MapOverlayChunk *)start_n->data;
		const ut64 new_size = r_itv_end (cur->itv) - r_itv_begin (start->itv);
		ut8 *buf = realloc (start->buf, new_size * sizeof (ut8));
		if (buf) {
			start->buf = buf;
			memcpy (&buf[r_itv_begin (cur->itv) - r_itv_begin (start->itv)],
				cur->buf, r_itv_size (cur->itv));
			r_crbtree_delete (map->overlay, cur, _overlay_chunk_insert, NULL);
			r_queue_dequeue (q);	
			while (!r_queue_is_empty (q)) {
				cur = (MapOverlayChunk *)r_queue_dequeue (q);
				memcpy (&buf[r_itv_begin (cur->itv) - r_itv_begin (start->itv)],
					cur->buf, r_itv_size (cur->itv));
				r_crbtree_delete (map->overlay, cur, _overlay_chunk_insert, NULL);
			}
			start->itv.size = new_size;
		} else {
			while (!r_queue_is_empty (q)) {
				r_queue_dequeue (q);
			}
		}
	}
	r_queue_free (q);
}
