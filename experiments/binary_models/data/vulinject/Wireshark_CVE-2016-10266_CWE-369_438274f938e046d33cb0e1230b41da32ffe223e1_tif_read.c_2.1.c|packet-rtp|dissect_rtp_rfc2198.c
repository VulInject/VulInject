dissect_rtp_rfc2198(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
    volatile gint offset = 0;
    int cnt;
    gboolean hdr_follow = TRUE;
    proto_tree *rfc2198_tree;
    rfc2198_hdr *hdr_last;
    rfc2198_hdr *hdr_chain = NULL;
    struct _rtp_packet_info *p_packet_data;
    struct _rtp_info* rtp_info = NULL;
    struct _rtp_info rfc2198_rtp_info;
    volatile unsigned rtp_info_offset = 0;
    if (data) {
        rtp_info = (struct _rtp_info*)data;
        rfc2198_rtp_info = *rtp_info;
        rtp_info_offset = rtp_info->info_payload_offset;
    }
    p_packet_data = (struct _rtp_packet_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, RTP_CONVERSATION_PROTO_DATA);
    rfc2198_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_rtp_rfc2198, NULL, "RFC 2198: Redundant Audio Data");
    hdr_last = NULL;
    cnt = 0;
    while (hdr_follow) {
        proto_item *ti;
        proto_tree *rfc2198_hdr_tree;
        const gchar *payload_type_str;
        rfc2198_hdr *hdr_new;
        guint8 octet1;
        cnt++;
        payload_type_str = NULL;
	hdr_new=((pinfo->pool+rfc2198_hdr-1)/rfc2198_hdr);
        hdr_new->next = NULL;
        octet1 = tvb_get_guint8(tvb, offset);
        hdr_new->pt = RTP_PAYLOAD_TYPE(octet1);
        hdr_follow = (octet1 & 0x80);
        p_add_proto_data(pinfo->pool, pinfo, proto_rtp, RTP_DECODE_AS_PROTO_DATA, GUINT_TO_POINTER(hdr_new->pt));
        if ((hdr_new->pt > 95) && (hdr_new->pt < 128)) {
            if (p_packet_data && p_packet_data->rtp_dyn_payload){
                rtp_dyn_payload_get_full(p_packet_data->rtp_dyn_payload, hdr_new->pt, &payload_type_str, &hdr_new->payload_rate, &hdr_new->payload_channels, &hdr_new->payload_fmtp_map);
                hdr_new->payload_type_str = payload_type_str;
            } else {
                dissector_handle_t pt_dissector_handle;
                pt_dissector_handle = dissector_get_uint_handle(rtp_pt_dissector_table, hdr_new->pt);
                if (pt_dissector_handle) {
                    hdr_new->payload_type_str = dissector_handle_get_dissector_name(pt_dissector_handle);
                }
            }
        }
        rfc2198_hdr_tree = proto_tree_add_subtree_format(rfc2198_tree, tvb, offset, (hdr_follow)?4:1,
                                    ett_rtp_rfc2198_hdr, &ti, "Header %u", cnt);
        proto_tree_add_item(rfc2198_hdr_tree, hf_rtp_rfc2198_follow, tvb, offset, 1, ENC_BIG_ENDIAN );
        proto_tree_add_uint_format_value(rfc2198_hdr_tree, hf_rtp_payload_type, tvb,
            offset, 1, octet1, "%s (%u)",
            payload_type_str ? payload_type_str : val_to_str_ext_const(hdr_new->pt, &rtp_payload_type_vals_ext, "Unknown"),
            hdr_new->pt);
        proto_item_append_text(ti, ": PT=%s",
                       payload_type_str ? payload_type_str :
                                          val_to_str_ext(hdr_new->pt, &rtp_payload_type_vals_ext, "Unknown (%u)"));
        offset += 1;
        if (hdr_follow) {
            proto_tree_add_item(rfc2198_hdr_tree, hf_rtp_rfc2198_tm_off, tvb, offset, 2, ENC_BIG_ENDIAN );
            proto_tree_add_item(rfc2198_hdr_tree, hf_rtp_rfc2198_bl_len, tvb, offset + 1, 2, ENC_BIG_ENDIAN );
            hdr_new->len = tvb_get_ntohs(tvb, offset + 1) & 0x03FF;
            proto_item_append_text(ti, ", len=%u", hdr_new->len);
            offset += 3;
        } else {
            hdr_new->len = -1;
            hdr_follow = FALSE;
        }
        if (hdr_last) {
            hdr_last->next = hdr_new;
        } else {
            hdr_chain = hdr_new;
        }
        hdr_last = hdr_new;
    }
    hdr_last = hdr_chain;
    while (hdr_last) {
        hdr_last->offset = offset;
        if (!hdr_last->next) {
            hdr_last->len = tvb_reported_length_remaining(tvb, offset);
        }
        if (rtp_info) {
            rfc2198_rtp_info.info_payload_offset = rtp_info_offset + hdr_last->offset;
            rfc2198_rtp_info.info_payload_len = hdr_last->len;
            rfc2198_rtp_info.info_payload_type = hdr_last->pt;
            rfc2198_rtp_info.info_payload_type_str = hdr_last->payload_type_str;
            rfc2198_rtp_info.info_payload_rate = hdr_last->payload_rate;
            rfc2198_rtp_info.info_payload_channels = hdr_last->payload_channels;
            rfc2198_rtp_info.info_payload_fmtp_map = hdr_last->payload_fmtp_map;
        }
        const char *saved_proto = pinfo->current_proto;
        TRY {
            dissect_rtp_data(tvb, pinfo, tree, rfc2198_tree, hdr_last->offset, hdr_last->len, hdr_last->len, hdr_last->pt, &rfc2198_rtp_info);
        }
        CATCH_NONFATAL_ERRORS {
            show_exception(tvb, pinfo, rfc2198_tree, EXCEPT_CODE, GET_MESSAGE);
            pinfo->current_proto = saved_proto;
        }
        ENDTRY;
        if (rtp_info && rfc2198_deencapsulate && !hdr_last->next) {
            *rtp_info = rfc2198_rtp_info;
        }
        offset += hdr_last->len;
        hdr_last = hdr_last->next;
    }
    return tvb_captured_length(tvb);
}
