void brcmf_fws_hdrpull(struct brcmf_if *ifp, short siglen, struct sk_buff *skb)
{
	struct brcmf_skb_reorder_data *rd;
	struct brcmf_fws_info *fws = drvr_to_fws(ifp->drvr);
	unsigned char *signal_data;
	short data_len;
	unsigned char type;
	unsigned char len;
	unsigned char *data;
	int status;
	int err;
	brcmf_dbg(HDRS, "enter: ifidx %d, skblen %u, sig %d\n",
		  ifp->ifidx, skb->len, siglen);
	WARN_ON(siglen > skb->len);
	if (siglen > skb->len)
		siglen = skb->len;
	if (!siglen)
		return;
	if ((!fws) || (!fws->fw_signals)) {
		return;
	}
	fws->stats.header_pulls++;
	data_len = siglen;
	signal_data = skb->data;
	status = BRCMF_FWS_RET_OK_NOSCHEDULE;
	while (data_len > 0) {
		type = signal_data[0];
		if (type == BRCMF_FWS_TYPE_FILLER) {
			signal_data += 1;
			data_len -= 1;
			continue;
		}
		len = signal_data[1];
		data = signal_data + 2;
		brcmf_dbg(HDRS, "tlv type=%s (%d), len=%d (%d)\n",
			  brcmf_fws_get_tlv_name(type), type, len,
			  brcmf_fws_get_tlv_len(fws, type));
		if (data_len < len + 2)
			break;
		if (len < brcmf_fws_get_tlv_len(fws, type))
			break;
		err = BRCMF_FWS_RET_OK_NOSCHEDULE;
		switch (type) {
		case BRCMF_FWS_TYPE_HOST_REORDER_RXPKTS:
			rd = (struct brcmf_skb_reorder_data *)skb->cb;
			rd->reorder = data;
			break;
		case BRCMF_FWS_TYPE_MACDESC_ADD:
		case BRCMF_FWS_TYPE_MACDESC_DEL:
			brcmf_fws_macdesc_indicate(fws, type, data);
			break;
		case BRCMF_FWS_TYPE_MAC_OPEN:
		case BRCMF_FWS_TYPE_MAC_CLOSE:
			err = brcmf_fws_macdesc_state_indicate(fws, type, data);
			break;
		case BRCMF_FWS_TYPE_INTERFACE_OPEN:
		case BRCMF_FWS_TYPE_INTERFACE_CLOSE:
			err = brcmf_fws_interface_state_indicate(fws, type,
								 data);
			break;
		case BRCMF_FWS_TYPE_MAC_REQUEST_CREDIT:
		case BRCMF_FWS_TYPE_MAC_REQUEST_PACKET:
			err = brcmf_fws_request_indicate(fws, type, data);
			break;
		case BRCMF_FWS_TYPE_TXSTATUS:
		case BRCMF_FWS_TYPE_COMP_TXSTATUS:
			brcmf_fws_txstatus_indicate(fws, type, data);
			break;
		case BRCMF_FWS_TYPE_FIFO_CREDITBACK:
			err = brcmf_fws_fifocreditback_indicate(fws, data);
			break;
		case BRCMF_FWS_TYPE_RSSI:
			brcmf_fws_rssi_indicate(fws, *data);
			break;
		case BRCMF_FWS_TYPE_TRANS_ID:
			brcmf_fws_dbg_seqnum_check(fws, data);
			break;
		case BRCMF_FWS_TYPE_PKTTAG:
		case BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP:
		default:
			fws->stats.tlv_invalid_type++;
			break;
		}
		if (err == BRCMF_FWS_RET_OK_SCHEDULE)
			status = BRCMF_FWS_RET_OK_SCHEDULE;
		signal_data += len + 2;
		data_len -= len + 2;
	}
	if (data_len != 0)
		fws->stats.tlv_parse_failed++;
	if (status == BRCMF_FWS_RET_OK_SCHEDULE)
		brcmf_fws_schedule_deq(fws);
	skb_pull(skb, siglen);
	if (skb->len == 0)
		fws->stats.header_only_pkt++;
}
