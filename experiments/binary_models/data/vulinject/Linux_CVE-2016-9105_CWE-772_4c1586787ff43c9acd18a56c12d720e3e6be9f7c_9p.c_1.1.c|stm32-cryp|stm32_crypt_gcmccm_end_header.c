static void stm32_crypt_gcmccm_end_header(struct stm32_cryp *cryp)
{
	unsigned int cfg;
	int err;
	if (!cryp->header_in) {
		err = stm32_cryp_wait_busy(cryp);
		if (err) {
			dev_err(cryp->dev, "Timeout (gcm/ccm header)\n");
			stm32_cryp_write(cryp, cryp->caps->imsc, 0);
			return;
		}
		if (stm32_cryp_get_input_text_len(cryp)) {
			cfg = stm32_cryp_read(cryp, cryp->caps->cr);
			cfg &= ~CR_CRYPEN;
			stm32_cryp_write(cryp, cryp->caps->cr, cfg);
			cfg &= ~CR_PH_MASK;
			cfg |= CR_PH_PAYLOAD | CR_CRYPEN;
			stm32_cryp_write(cryp, cryp->caps->cr, cfg);
		} else {
		}
	}
}
