unsigned int rh_alloc_align(rh_info_t * info, int size, int alignment, const char *owner)
{
	struct list_head *l;
	rh_block_t *blk;
	rh_block_t *newblk;
	int start, sp_size;
	if (size <= 0 || (alignment & (alignment - 1)) != 0)
		return (unsigned int) -EINVAL;
	size = (size + (info->alignment - 1)) & ~(info->alignment - 1);
	if (assure_empty(info, 2) < 0)
		return (unsigned int) -ENOMEM;
	blk = NULL;
	list_for_each(l, &info->free_list) {
		blk = list_entry(l, rh_block_t, list);
		if (size <= blk->size) {
			start = (blk->start + alignment - 1) & ~(alignment - 1);
			if (start + size <= blk->start + blk->size)
				break;
		}
		blk = NULL;
	}
	if (blk == NULL)
		return (unsigned int) -ENOMEM;
	if (blk->size == size) {
		list_del(&blk->list);
		newblk = blk;
	} else {
		sp_size = start - blk->start;
		if (sp_size) {
			rh_block_t *spblk;
			spblk = get_slot(info);
			spblk->start = blk->start;
			spblk->size = sp_size;
			list_add(&spblk->list, blk->list.prev);
		}
		newblk = get_slot(info);
		newblk->start = start;
		newblk->size = size;
		blk->start = start + size;
		blk->size -= sp_size + size;
		if (blk->size == 0) {
			list_del(&blk->list);
			release_slot(info, blk);
		}
	}
	newblk->owner = owner;
	attach_taken_block(info, newblk);
	return start;
}
