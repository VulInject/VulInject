rescan_file(capture_file *cf, const char *fname, gboolean is_tempfile)
{
    wtap_rec             rec;
    Buffer               buf;
    int                  err;
    gchar               *err_info;
    gchar               *name_ptr;
    gint64               data_offset;
    progdlg_t           *progbar        = NULL;
    GTimer              *prog_timer = g_timer_new();
    gint64               size;
    float                progbar_val;
    gint64               start_time;
    gchar                status_str[100];
    guint32              framenum;
    frame_data          *fdata;
    wtap_close(cf->provider.wth);
    cf->provider.wth = wtap_open_offline(fname, WTAP_TYPE_AUTO, &err, &err_info, TRUE);
    if (cf->provider.wth == NULL) {
        cfile_open_failure_alert_box(fname, err, err_info);
        return CF_READ_ERROR;
    }
    cf->f_datalen = 0;
    if (cf->filename != NULL) {
        g_free(cf->filename);
    }
    cf->filename = g_strdup(fname);
    cf->is_tempfile = is_tempfile;
    cf->unsaved_changes = FALSE;
    cf->cd_t        = wtap_file_type_subtype(cf->provider.wth);
    if (cf->linktypes != NULL) {
        g_array_free(cf->linktypes, TRUE);
    }
    cf->linktypes = g_array_sized_new(FALSE, FALSE, (guint) sizeof(int), 1);
    cf->snap      = wtap_snapshot_length(cf->provider.wth);
    name_ptr = g_filename_display_basename(cf->filename);
    cf->compression_type = wtap_get_compression_type(cf->provider.wth);
    size = wtap_file_size(cf->provider.wth, NULL);
    g_timer_start(prog_timer);
    cf->stop_flag = FALSE;
    start_time = g_get_monotonic_time();
    framenum = 0;
    wtap_rec_init(&rec);
    ws_buffer_init(&buf, 1514);
    while ((wtap_read(cf->provider.wth, &rec, &buf, &err, &err_info,
                    &data_offset))) {
        framenum++;
        fdata = frame_data_sequence_find(cf->provider.frames, framenum);
        if (G_LIKELY(fdata != NULL)) {
            fdata->file_off = data_offset;
        }
        if (size >= 0) {
            cf->f_datalen = wtap_read_so_far(cf->provider.wth);
            if (progress_is_slow(progbar, prog_timer, size, cf->f_datalen)) {
                progbar_val = calc_progbar_val(cf, size, cf->f_datalen, status_str, sizeof(status_str));
                progbar = delayed_create_progress_dlg(cf->window, NULL, NULL,
                        TRUE, &cf->stop_flag, progbar_val);
            }
            if (progbar && g_timer_elapsed(prog_timer, NULL) > PROGBAR_UPDATE_INTERVAL) {
                progbar_val = calc_progbar_val(cf, size, cf->f_datalen, status_str, sizeof(status_str));
                update_progress_dlg(progbar, progbar_val, status_str);
                compute_elapsed(cf, start_time);
                packets_bar_update();
                g_timer_start(prog_timer);
            }
        }
        if (cf->stop_flag) {
            break;
        }
        if (rec.rec_type == REC_TYPE_PACKET) {
            cf_add_encapsulation_type(cf, rec.rec_header.packet_header.pkt_encap);
        }
        wtap_rec_reset(&rec);
    }
    wtap_rec_cleanup(&rec);
    ws_buffer_free(&buf);
    g_free(name_ptr);
    if (progbar != NULL)
        destroy_progress_dlg(progbar);
    g_timer_destroy(prog_timer);
    cf->state = FILE_READ_DONE;
    wtap_sequential_close(cf->provider.wth);
    compute_elapsed(cf, start_time);
    cf->lnk_t = wtap_file_encap(cf->provider.wth);
    cf_callback_invoke(cf_cb_file_rescan_finished, cf);
    if (cf->stop_flag) {
        return CF_READ_ABORTED;
    }
    if (err != 0) {
        cfile_read_failure_alert_box(NULL, err, err_info);
        return CF_READ_ERROR;
    } else
        return CF_READ_OK;
}
