dissect_thrift_compact_list_set(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int *offset, thrift_option_data_t *thrift_opt, gboolean is_list)
{
    proto_tree *sub_tree;
    proto_item *container_pi, *type_pi, *len_pi;
    guint32 len_type, type;
    gint32 container_len, len_len, i;
    guint64 varint;
    int lt_offset = *offset;
    int ett = ett_thrift_set;
    int hf_container = hf_thrift_set;
    int hf_num_item = hf_thrift_num_set_item;
    int hf_pos_item = hf_thrift_num_set_pos;
    guint nested_count = p_get_proto_depth(pinfo, proto_thrift);
    ABORT_ON_INCOMPLETE_PDU(TBP_THRIFT_TYPE_LEN);
    if (is_list) {
        ett = ett_thrift_list;
        hf_container = hf_thrift_list;
        hf_num_item = hf_thrift_num_list_item;
        hf_pos_item = hf_thrift_num_list_pos;
    }
	if ((unsigned int)nested_count >= thrift_opt->nested_type_depth)
        expert_add_info(pinfo, proto_tree_get_parent(tree), &ei_thrift_too_many_subtypes);
        return THRIFT_REQUEST_REASSEMBLY;
    }
