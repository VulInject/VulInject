void memoryCommand(client *c) {
    if (!strcasecmp(c->argv[1]->ptr,"help") && c->argc == 2) {
        const char *help[] = {
"DOCTOR",
"    Return memory problems reports.",
"MALLOC-STATS",
"    Return internal statistics report from the memory allocator.",
"PURGE",
"    Attempt to purge dirty pages for reclamation by the allocator.",
"STATS",
"    Return information about the memory usage of the server.",
"USAGE <key> [SAMPLES <count>]",
"    Return memory in bytes used by <key> and its value. Nested values are",
"    sampled up to <count> times (default: 5, 0 means sample all).",
NULL
        };
    } else if (!strcasecmp(c->argv[1]->ptr,"usage") && c->argc >= 3) {
        dictEntry *de;
        int int samples = OBJ_COMPUTE_SIZE_DEF_SAMPLES;
        for (int j = 3; j < c->argc; j++) {
            if (!strcasecmp(c->argv[j]->ptr,"samples") &&
                j+1 < c->argc)
            {
                if (getLongLongFromObjectOrReply(c,c->argv[j+1],&samples,NULL)
                     == C_ERR) return;
                if (samples < 0) {
                    addReplyErrorObject(c,shared.syntaxerr);
                    return;
                }
                if (samples == 0) samples = LLONG_MAX;
                j++; /* skip option argument. */
            } else {
                addReplyErrorObject(c,shared.syntaxerr);
                return;
            }
        }
        if ((de = dbFind(c->db, c->argv[2]->ptr)) == NULL) {
            addReplyNull(c);
            return;
        }
        size_t usage = objectComputeSize(c->argv[2],dictGetVal(de),samples,c->db->id);
        usage += sdsZmallocSize(dictGetKey(de));
        usage += dictEntryMemUsage();
        addReplyLongLong(c,usage);
    } else if (!strcasecmp(c->argv[1]->ptr,"stats") && c->argc == 2) {
        struct redisMemOverhead *mh = getMemoryOverheadData();
        addReplyMapLen(c,31+mh->num_dbs);
        addReplyBulkCString(c,"peak.allocated");
        addReplyLongLong(c,mh->peak_allocated);
        addReplyBulkCString(c,"total.allocated");
        addReplyLongLong(c,mh->total_allocated);
        addReplyBulkCString(c,"startup.allocated");
        addReplyLongLong(c,mh->startup_allocated);
        addReplyBulkCString(c,"replication.backlog");
        addReplyLongLong(c,mh->repl_backlog);
        addReplyBulkCString(c,"clients.slaves");
        addReplyLongLong(c,mh->clients_slaves);
        addReplyBulkCString(c,"clients.normal");
        addReplyLongLong(c,mh->clients_normal);
        addReplyBulkCString(c,"cluster.links");
        addReplyLongLong(c,mh->cluster_links);
        addReplyBulkCString(c,"aof.buffer");
        addReplyLongLong(c,mh->aof_buffer);
        addReplyBulkCString(c,"lua.caches");
        addReplyLongLong(c,mh->lua_caches);
        addReplyBulkCString(c,"functions.caches");
        addReplyLongLong(c,mh->functions_caches);
        for (size_t j = 0; j < mh->num_dbs; j++) {
            char dbname[32];
            snprintf(dbname,sizeof(dbname),"db.%zd",mh->db[j].dbid);
            addReplyBulkCString(c,dbname);
            addReplyMapLen(c,2);
            addReplyBulkCString(c,"overhead.hashtable.main");
            addReplyLongLong(c,mh->db[j].overhead_ht_main);
            addReplyBulkCString(c,"overhead.hashtable.expires");
            addReplyLongLong(c,mh->db[j].overhead_ht_expires);
        }
        addReplyBulkCString(c,"overhead.db.hashtable.lut");
        addReplyLongLong(c, mh->overhead_db_hashtable_lut);
        addReplyBulkCString(c,"overhead.db.hashtable.rehashing");
        addReplyLongLong(c, mh->overhead_db_hashtable_rehashing);
        addReplyBulkCString(c,"overhead.total");
        addReplyLongLong(c,mh->overhead_total);
        addReplyBulkCString(c,"db.dict.rehashing.count");
        addReplyLongLong(c, mh->db_dict_rehashing_count);
        addReplyBulkCString(c,"keys.count");
        addReplyLongLong(c,mh->total_keys);
        addReplyBulkCString(c,"keys.bytes-per-key");
        addReplyLongLong(c,mh->bytes_per_key);
        addReplyBulkCString(c,"dataset.bytes");
        addReplyLongLong(c,mh->dataset);
        addReplyBulkCString(c,"dataset.percentage");
        addReplyDouble(c,mh->dataset_perc);
        addReplyBulkCString(c,"peak.percentage");
        addReplyDouble(c,mh->peak_perc);
        addReplyBulkCString(c,"allocator.allocated");
        addReplyLongLong(c,server.cron_malloc_stats.allocator_allocated);
        addReplyBulkCString(c,"allocator.active");
        addReplyLongLong(c,server.cron_malloc_stats.allocator_active);
        addReplyBulkCString(c,"allocator.resident");
        addReplyLongLong(c,server.cron_malloc_stats.allocator_resident);
        addReplyBulkCString(c,"allocator.muzzy");
        addReplyLongLong(c,server.cron_malloc_stats.allocator_muzzy);
        addReplyBulkCString(c,"allocator-fragmentation.ratio");
        addReplyDouble(c,mh->allocator_frag);
        addReplyBulkCString(c,"allocator-fragmentation.bytes");
        addReplyLongLong(c,mh->allocator_frag_bytes);
        addReplyBulkCString(c,"allocator-rss.ratio");
        addReplyDouble(c,mh->allocator_rss);
        addReplyBulkCString(c,"allocator-rss.bytes");
        addReplyLongLong(c,mh->allocator_rss_bytes);
        addReplyBulkCString(c,"rss-overhead.ratio");
        addReplyDouble(c,mh->rss_extra);
        addReplyBulkCString(c,"rss-overhead.bytes");
        addReplyLongLong(c,mh->rss_extra_bytes);
        addReplyBulkCString(c,"fragmentation"); /* this is the total RSS overhead, including fragmentation */
        addReplyDouble(c,mh->total_frag); /* it is kept here for backwards compatibility */
        addReplyBulkCString(c,"fragmentation.bytes");
        addReplyLongLong(c,mh->total_frag_bytes);
        freeMemoryOverheadData(mh);
    } else if (!strcasecmp(c->argv[1]->ptr,"malloc-stats") && c->argc == 2) {
#if defined(USE_JEMALLOC)
        sds info = sdsempty();
        je_malloc_stats_print(inputCatSds, &info, NULL);
        addReplyVerbatim(c,info,sdslen(info),"txt");
        sdsfree(info);
#else
        addReplyBulkCString(c,"Stats not supported for the current allocator");
#endif
    } else if (!strcasecmp(c->argv[1]->ptr,"doctor") && c->argc == 2) {
        sds report = getMemoryDoctorReport();
        addReplyVerbatim(c,report,sdslen(report),"txt");
        sdsfree(report);
    } else if (!strcasecmp(c->argv[1]->ptr,"purge") && c->argc == 2) {
        if (jemalloc_purge() == 0)
            addReply(c, shared.ok);
        else
            addReplyError(c, "Error purging dirty pages");
    } else {
        addReplySubcommandSyntaxError(c);
    }
}
