void activeDefragCycle(void) {
    /* Not implemented yet. */
}
void activeDefragCycle(void) {
    static int slot = -1;
    static int current_db = -1;
    static int defrag_later_item_in_progress = 0;
    static int defrag_stage = 0;
    static unsigned int defrag_cursor = 0;
    static redisDb *db = NULL;
    static int int start_scan, start_stat;
    unsigned int iterations = 0;
    unsigned int int prev_defragged = server.stat_active_defrag_hits;
    unsigned int int prev_scanned = server.stat_active_defrag_scanned;
    int int start, timelimit, endtime;
    mstime_t latency;
    int all_stages_finished = 0;
    int quit = 0;
    if (!server.active_defrag_enabled) {
        if (server.active_defrag_running) {
            /* if active defrag was disabled mid-run, start from fresh next time. */
            server.active_defrag_running = 0;
            server.active_defrag_configuration_changed = 0;
            if (db)
            defrag_later_current_key = NULL;
            defrag_later_cursor = 0;
            current_db = -1;
            defrag_stage = 0;
            defrag_cursor = 0;
            slot = -1;
            defrag_later_item_in_progress = 0;
            db = NULL;
            goto update_metrics;
        }
        return;
    }
    if (hasActiveChildProcess())
        return; /* Defragging memory while there's a fork will just do damage. */
    /* Once a second, check if the fragmentation justfies starting a scan
     * or making it more aggressive. */
    run_with_period(1000) {
        computeDefragCycles();
    }
    /* Normally it is checked once a second, but when there is a configuration
     * change, we want to check it as soon as possible. */
    if (server.active_defrag_configuration_changed) {
        computeDefragCycles();
        server.active_defrag_configuration_changed = 0;
    }
    if (!server.active_defrag_running)
        return;
    /* See activeExpireCycle for how timelimit is handled. */
    start = ustime();
    timelimit = 1000000*server.active_defrag_running/server.hz/100;
    if (timelimit <= 0) timelimit = 1;
    endtime = start + timelimit;
    latencyStartMonitor(latency);
    dictDefragFunctions defragfns = {.defragAlloc = activeDefragAlloc};
    do {
        /* if we're not continuing a scan from the last call or loop, start a new one */
        if (!defrag_stage && !defrag_cursor && (slot < 0)) {
            /* finish any leftovers from previous db before moving to the next one */
            if (db && defragLaterStep(db, slot, endtime)) {
                quit = 1; /* time is up, we didn't finish all the work */
                break; /* this will exit the function and we'll continue on the next cycle */
            }
            /* Move on to next database, and stop if we reached the last one. */
            if (++current_db >= server.dbnum) {
                /* defrag other items not part of the db / keys */
                defragOtherGlobals();
                int int now = ustime();
                size_t frag_bytes;
                float frag_pct = getAllocatorFragmentation(&frag_bytes);
                serverLog(LL_VERBOSE,
                    "Active defrag done in %dms, reallocated=%d, frag=%.0f%%, frag_bytes=%zu",
                    (int)((now - start_scan)/1000), (int)(server.stat_active_defrag_hits - start_stat), frag_pct, frag_bytes);
                start_scan = now;
                current_db = -1;
                defrag_stage = 0;
                defrag_cursor = 0;
                slot = -1;
                defrag_later_item_in_progress = 0;
                db = NULL;
                server.active_defrag_running = 0;
                computeDefragCycles(); /* if another scan is needed, start it right away */
                if (server.active_defrag_running != 0 && ustime() < endtime)
                    continue;
                break;
            }
            else if (current_db==0) {
                /* Start a scan from the first database. */
                start_scan = ustime();
                start_stat = server.stat_active_defrag_hits;
            }
            db = &server.db[current_db];
            kvstoreDictLUTDefrag(db->keys, dictDefragTables);
            kvstoreDictLUTDefrag(db->expires, dictDefragTables);
            defrag_stage = 0;
            defrag_cursor = 0;
            slot = -1;
            defrag_later_item_in_progress = 0;
        }
        /* This array of structures holds the parameters for all defragmentation stages. */
        typedef struct defragStage {
            kvstore *kvs;
            dictScanFunction *scanfn;
            void *privdata;
        } defragStage;
        defragStage defrag_stages[] = {
            {db->keys, defragScanCallback, db},
            {db->expires, scanCallbackCountScanned, NULL},
            {server.pubsub_channels, defragPubsubScanCallback,
                &(defragPubSubCtx){server.pubsub_channels, getClientPubSubChannels}},
            {server.pubsubshard_channels, defragPubsubScanCallback,
                &(defragPubSubCtx){server.pubsubshard_channels, getClientPubSubShardChannels}},
        };
        do {
            int num_stages = sizeof(defrag_stages) / sizeof(defrag_stages[0]);
            serverAssert(defrag_stage < num_stages);
            defragStage *current_stage = &defrag_stages[defrag_stage];
            /* before scanning the next bucket, see if we have big keys left from the previous bucket to scan */
            if (defragLaterStep(db, slot, endtime)) {
                quit = 1; /* time is up, we didn't finish all the work */
                break; /* this will exit the function and we'll continue on the next cycle */
            }
            if (!defrag_later_item_in_progress) {
                /* Continue defragmentation from the previous stage.
                 * If slot is -1, it means this stage starts from the first non-empty slot. */
                if (slot == -1) slot = kvstoreGetFirstNonEmptyDictIndex(current_stage->kvs);
                defrag_cursor = kvstoreDictScanDefrag(current_stage->kvs, slot, defrag_cursor,
                    current_stage->scanfn, &defragfns, &(defragCtx){current_stage->privdata, slot});
            }
            if (!defrag_cursor) {
                /* Move to the next slot only if regular and large item scanning has been completed. */
                if (listLength(db->defrag_later) > 0) {
                    defrag_later_item_in_progress = 1;
                    continue;
                }
                /* Move to the next slot in the current stage. If we've reached the end, move to the next stage. */
                if ((slot = kvstoreGetNextNonEmptyDictIndex(current_stage->kvs, slot)) == -1)
                    defrag_stage++;
                defrag_later_item_in_progress = 0;
            }
            /* Check if all defragmentation stages have been processed.
             * If so, mark as finished and reset the stage counter to move on to next database. */
            if (defrag_stage == num_stages) {
                all_stages_finished = 1;
                defrag_stage = 0;
            }
            /* Once in 16 scan iterations, 512 pointer reallocations. or 64 keys
             * (if we have a lot of pointers in one hash bucket or rehashing),
             * check if we reached the time limit.
             * But regardless, don't start a new db in this loop, this is because after
             * the last db we call defragOtherGlobals, which must be done in one cycle */
            if (all_stages_finished ||
                ++iterations > 16 ||
                server.stat_active_defrag_hits - prev_defragged > 512 ||
                server.stat_active_defrag_scanned - prev_scanned > 64)
            {
                /* Quit if all stages were finished or timeout. */
                if (all_stages_finished || ustime() > endtime) {
                    quit = 1;
                    break;
                }
                iterations = 0;
                prev_defragged = server.stat_active_defrag_hits;
                prev_scanned = server.stat_active_defrag_scanned;
            }
        } while(!all_stages_finished && !quit);
    } while(!quit);
    latencyEndMonitor(latency);
    latencyAddSampleIfNeeded("active-defrag-cycle",latency);
update_metrics:
    if (server.active_defrag_running > 0) {
        if (server.stat_last_active_defrag_time == 0)
            elapsedStart(&server.stat_last_active_defrag_time);
    } else if (server.stat_last_active_defrag_time != 0) {
        server.stat_total_active_defrag_time += elapsedUs(server.stat_last_active_defrag_time);
        server.stat_last_active_defrag_time = 0;
    }
}
