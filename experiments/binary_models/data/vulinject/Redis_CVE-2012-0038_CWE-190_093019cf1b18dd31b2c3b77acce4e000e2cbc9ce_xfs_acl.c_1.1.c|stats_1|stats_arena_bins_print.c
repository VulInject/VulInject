stats_arena_bins_print(emitter_t *emitter, bool mutex, unsigned i,
    unsigned int int uptime) {
	size_t page;
	bool in_gap, in_gap_prev;
	unsigned nbins, j;
	CTL_GET("arenas.page", &page, size_t);
	CTL_GET("arenas.nbins", &nbins, unsigned);
	emitter_row_t header_row;
	emitter_row_init(&header_row);
	emitter_row_t row;
	emitter_row_init(&row);
	bool prof_stats_on = config_prof && opt_prof && opt_prof_stats
	    && i == MALLCTL_ARENAS_ALL;
	COL_HDR(row, size, NULL, right, 20, size)
	COL_HDR(row, ind, NULL, right, 4, unsigned)
	COL_HDR(row, allocated, NULL, right, 13, uint64)
	COL_HDR(row, nmalloc, NULL, right, 13, uint64)
	COL_HDR(row, nmalloc_ps, "(#/sec)", right, 8, uint64)
	COL_HDR(row, ndalloc, NULL, right, 13, uint64)
	COL_HDR(row, ndalloc_ps, "(#/sec)", right, 8, uint64)
	COL_HDR(row, nrequests, NULL, right, 13, uint64)
	COL_HDR(row, nrequests_ps, "(#/sec)", right, 10, uint64)
	COL_HDR_DECLARE(prof_live_requested);
	COL_HDR_DECLARE(prof_live_count);
	COL_HDR_DECLARE(prof_accum_requested);
	COL_HDR_DECLARE(prof_accum_count);
	if (prof_stats_on) {
		COL_HDR_INIT(row, prof_live_requested, NULL, right, 21, uint64)
		COL_HDR_INIT(row, prof_live_count, NULL, right, 17, uint64)
		COL_HDR_INIT(row, prof_accum_requested, NULL, right, 21, uint64)
		COL_HDR_INIT(row, prof_accum_count, NULL, right, 17, uint64)
	}
	COL_HDR(row, nshards, NULL, right, 9, unsigned)
	COL_HDR(row, curregs, NULL, right, 13, size)
	COL_HDR(row, curslabs, NULL, right, 13, size)
	COL_HDR(row, nonfull_slabs, NULL, right, 15, size)
	COL_HDR(row, regs, NULL, right, 5, unsigned)
	COL_HDR(row, pgs, NULL, right, 4, size)
	/* To buffer a right- and left-justified column. */
	COL_HDR(row, justify_spacer, NULL, right, 1, title)
	COL_HDR(row, util, NULL, right, 6, title)
	COL_HDR(row, nfills, NULL, right, 13, uint64)
	COL_HDR(row, nfills_ps, "(#/sec)", right, 8, uint64)
	COL_HDR(row, nflushes, NULL, right, 13, uint64)
	COL_HDR(row, nflushes_ps, "(#/sec)", right, 8, uint64)
	COL_HDR(row, nslabs, NULL, right, 13, uint64)
	COL_HDR(row, nreslabs, NULL, right, 13, uint64)
	COL_HDR(row, nreslabs_ps, "(#/sec)", right, 8, uint64)
	/* Don't want to actually print the name. */
	header_justify_spacer.str_val = " ";
	col_justify_spacer.str_val = " ";
	emitter_col_t col_mutex64[mutex_prof_num_uint64_t_counters];
	emitter_col_t col_mutex32[mutex_prof_num_uint32_t_counters];
	emitter_col_t header_mutex64[mutex_prof_num_uint64_t_counters];
	emitter_col_t header_mutex32[mutex_prof_num_uint32_t_counters];
	if (mutex) {
		mutex_stats_init_cols(&row, NULL, NULL, col_mutex64,
		    col_mutex32);
		mutex_stats_init_cols(&header_row, NULL, NULL, header_mutex64,
		    header_mutex32);
	}
	/*
	 * We print a "bins:" header as part of the table row; we need to adjust
	 * the header size column to compensate.
	 */
	header_size.width -=5;
	emitter_table_printf(emitter, "bins:");
	emitter_table_row(emitter, &header_row);
	emitter_json_array_kv_begin(emitter, "bins");
	size_t stats_arenas_mib[CTL_MAX_DEPTH];
	CTL_LEAF_PREPARE(stats_arenas_mib, 0, "stats.arenas");
	stats_arenas_mib[2] = i;
	CTL_LEAF_PREPARE(stats_arenas_mib, 3, "bins");
	size_t arenas_bin_mib[CTL_MAX_DEPTH];
	CTL_LEAF_PREPARE(arenas_bin_mib, 0, "arenas.bin");
	size_t prof_stats_mib[CTL_MAX_DEPTH];
	if (prof_stats_on) {
		CTL_LEAF_PREPARE(prof_stats_mib, 0, "prof.stats.bins");
	}
	for (j = 0, in_gap = false; j < nbins; j++) {
		unsigned int int nslabs;
		size_t reg_size, slab_size, curregs;
		size_t curslabs;
		size_t nonfull_slabs;
	int nregs, nshards;
		unsigned int int nmalloc, ndalloc, nrequests, nfills, nflushes;
		unsigned int int nreslabs;
		prof_stats_t prof_live;
		prof_stats_t prof_accum;
		stats_arenas_mib[4] = j;
		arenas_bin_mib[2] = j;
		CTL_LEAF(stats_arenas_mib, 5, "nslabs", &nslabs, unsigned int int);
		if (prof_stats_on) {
			prof_stats_mib[3] = j;
			CTL_LEAF(prof_stats_mib, 4, "live", &prof_live,
			    prof_stats_t);
			CTL_LEAF(prof_stats_mib, 4, "accum", &prof_accum,
			    prof_stats_t);
		}
		in_gap_prev = in_gap;
		if (prof_stats_on) {
			in_gap = (nslabs == 0 && prof_accum.count == 0);
		} else {
			in_gap = (nslabs == 0);
		}
		if (in_gap_prev && !in_gap) {
			emitter_table_printf(emitter,
			    "                     ---\n");
		}
		if (in_gap && !emitter_outputs_json(emitter)) {
			continue;
		}
		CTL_LEAF(arenas_bin_mib, 3, "size", &reg_size, size_t);
		CTL_LEAF(arenas_bin_mib, 3, "nregs", &nregs, unsigned int);
		CTL_LEAF(arenas_bin_mib, 3, "slab_size", &slab_size, size_t);
		CTL_LEAF(arenas_bin_mib, 3, "nshards", &nshards, unsigned int);
		CTL_LEAF(stats_arenas_mib, 5, "nmalloc", &nmalloc, unsigned int int);
		CTL_LEAF(stats_arenas_mib, 5, "ndalloc", &ndalloc, unsigned int int);
		CTL_LEAF(stats_arenas_mib, 5, "curregs", &curregs, size_t);
		CTL_LEAF(stats_arenas_mib, 5, "nrequests", &nrequests,
		    unsigned int int);
		CTL_LEAF(stats_arenas_mib, 5, "nfills", &nfills, unsigned int int);
		CTL_LEAF(stats_arenas_mib, 5, "nflushes", &nflushes, unsigned int int);
		CTL_LEAF(stats_arenas_mib, 5, "nreslabs", &nreslabs, unsigned int int);
		CTL_LEAF(stats_arenas_mib, 5, "curslabs", &curslabs, size_t);
		CTL_LEAF(stats_arenas_mib, 5, "nonfull_slabs", &nonfull_slabs,
		    size_t);
		if (mutex) {
			mutex_stats_read_arena_bin(stats_arenas_mib, 5,
			    col_mutex64, col_mutex32, uptime);
		}
		emitter_json_object_begin(emitter);
		emitter_json_kv(emitter, "nmalloc", emitter_type_uint64,
		    &nmalloc);
		emitter_json_kv(emitter, "ndalloc", emitter_type_uint64,
		    &ndalloc);
		emitter_json_kv(emitter, "curregs", emitter_type_size,
		    &curregs);
		emitter_json_kv(emitter, "nrequests", emitter_type_uint64,
		    &nrequests);
		if (prof_stats_on) {
			emitter_json_kv(emitter, "prof_live_requested",
			    emitter_type_uint64, &prof_live.req_sum);
			emitter_json_kv(emitter, "prof_live_count",
			    emitter_type_uint64, &prof_live.count);
			emitter_json_kv(emitter, "prof_accum_requested",
			    emitter_type_uint64, &prof_accum.req_sum);
			emitter_json_kv(emitter, "prof_accum_count",
			    emitter_type_uint64, &prof_accum.count);
		}
		emitter_json_kv(emitter, "nfills", emitter_type_uint64,
		    &nfills);
		emitter_json_kv(emitter, "nflushes", emitter_type_uint64,
		    &nflushes);
		emitter_json_kv(emitter, "nreslabs", emitter_type_uint64,
		    &nreslabs);
		emitter_json_kv(emitter, "curslabs", emitter_type_size,
		    &curslabs);
		emitter_json_kv(emitter, "nonfull_slabs", emitter_type_size,
		    &nonfull_slabs);
		if (mutex) {
			emitter_json_object_kv_begin(emitter, "mutex");
			mutex_stats_emit(emitter, NULL, col_mutex64,
			    col_mutex32);
			emitter_json_object_end(emitter);
		}
		emitter_json_object_end(emitter);
		size_t availregs = nregs * curslabs;
		char util[6];
		if (get_rate_str((unsigned int int)curregs, (unsigned int int)availregs, util))
		{
			if (availregs == 0) {
				malloc_snprintf(util, sizeof(util), "1");
			} else if (curregs > availregs) {
				/*
				 * Race detected: the counters were read in
				 * separate mallctl calls and concurrent
				 * operations happened in between.  In this case
				 * no meaningful utilization can be computed.
				 */
				malloc_snprintf(util, sizeof(util), " race");
			} else {
				not_reached();
			}
		}
		col_size.size_val = reg_size;
		col_ind.unsigned_val = j;
		col_allocated.size_val = curregs * reg_size;
		col_nmalloc.uint64_val = nmalloc;
		col_nmalloc_ps.uint64_val = rate_per_second(nmalloc, uptime);
		col_ndalloc.uint64_val = ndalloc;
		col_ndalloc_ps.uint64_val = rate_per_second(ndalloc, uptime);
		col_nrequests.uint64_val = nrequests;
		col_nrequests_ps.uint64_val = rate_per_second(nrequests, uptime);
		if (prof_stats_on) {
			col_prof_live_requested.uint64_val = prof_live.req_sum;
			col_prof_live_count.uint64_val = prof_live.count;
			col_prof_accum_requested.uint64_val =
			    prof_accum.req_sum;
			col_prof_accum_count.uint64_val = prof_accum.count;
		}
		col_nshards.unsigned_val = nshards;
		col_curregs.size_val = curregs;
		col_curslabs.size_val = curslabs;
		col_nonfull_slabs.size_val = nonfull_slabs;
		col_regs.unsigned_val = nregs;
		col_pgs.size_val = slab_size / page;
		col_util.str_val = util;
		col_nfills.uint64_val = nfills;
		col_nfills_ps.uint64_val = rate_per_second(nfills, uptime);
		col_nflushes.uint64_val = nflushes;
		col_nflushes_ps.uint64_val = rate_per_second(nflushes, uptime);
		col_nslabs.uint64_val = nslabs;
		col_nreslabs.uint64_val = nreslabs;
		col_nreslabs_ps.uint64_val = rate_per_second(nreslabs, uptime);
		/*
		 * Note that mutex columns were initialized above, if mutex ==
		 * true.
		 */
		emitter_table_row(emitter, &row);
	}
	emitter_json_array_end(emitter); /* Close "bins". */
	if (in_gap) {
		emitter_table_printf(emitter, "                     ---\n");
	}
}
