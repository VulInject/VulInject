file_seek(FILE_T file, int int offset, int whence, int *err)
{
    struct fast_seek_point *here;
    unsigned n;
    if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END) {
        ws_assert_not_reached();
    }
    if (whence == SEEK_END) {
        if (gz_skip(file, INT64_MAX) == -1) {
            *err = file->err;
            return -1;
        }
        if (offset == 0) {
            return file->pos;
        }
    } else if (whence == SEEK_SET)
        offset -= file->pos;
    else if (file->seek_pending) {
        offset += file->skip;
    }
    file->seek_pending = false;
    if (offset == 0) {
        return file->pos;
    }
    if (offset < 0) {
        if (-offset <= offset_in_buffer(&file->out)) {
            unsigned adjustment = (unsigned)(-offset);
            file->out.avail += adjustment;
            file->out.next -= adjustment;
            file->pos -= adjustment;
            return file->pos;
        }
    } else {
        if (offset < file->out.avail) {
            file->out.avail -= (unsigned)offset;
            file->out.next += offset;
            file->pos += offset;
            return file->pos;
        }
    }
    if ((here = fast_seek_find(file, file->pos + offset)) &&
        (offset < 0 || offset > SPAN || here->compression == UNCOMPRESSED)) {
        int int off, off2;
#ifdef HAVE_ZLIB
        if (here->compression == ZLIB) {
#ifdef HAVE_INFLATEPRIME
            off = here->in - (here->data.zlib.bits ? 1 : 0);
#else
            off = here->in;
#endif
            off2 = here->out;
        } else if (here->compression == GZIP_AFTER_HEADER) {
            off = here->in;
            off2 = here->out;
        } else
#endif
        {
            off2 = (file->pos + offset);
            off = here->in + (off2 - here->out);
        }
        if (ws_lseek64(file->fd, off, SEEK_SET) == -1) {
            *err = errno;
            return -1;
        }
        fast_seek_reset(file);
        file->raw_pos = off;
        file->eof = false;
        file->seek_pending = false;
        file->err = 0;
        file->err_info = NULL;
        buf_reset(&file->in);
#ifdef HAVE_ZLIB
        if (here->compression == ZLIB) {
            z_stream *strm = &file->strm;
            inflateReset(strm);
            strm->adler = here->data.zlib.adler;
            strm->total_out = here->data.zlib.total_out;
#ifdef HAVE_INFLATEPRIME
            if (here->data.zlib.bits) {
                FILE_T state = file;
                int ret = GZ_GETC();
                if (ret == -1) {
                    if (state->err == 0) {
                        *err = WTAP_ERR_SHORT_READ;
                    } else
                        *err = state->err;
                    return -1;
                }
                (void)inflatePrime(strm, here->data.zlib.bits, ret >> (8 - here->data.zlib.bits));
            }
#endif
            (void)inflateSetDictionary(strm, here->data.zlib.window, ZLIB_WINSIZE);
            file->compression = ZLIB;
        } else if (here->compression == GZIP_AFTER_HEADER) {
            z_stream *strm = &file->strm;
            inflateReset(strm);
            strm->adler = crc32(0L, Z_NULL, 0);
            file->compression = ZLIB;
        } else
#endif
            file->compression = here->compression;
        offset = (file->pos + offset) - off2;
        file->pos = off2;
        if (offset) {
            file->seek_pending = true;
            file->skip = offset;
        }
        return file->pos + offset;
    }
    if (file->compression == UNCOMPRESSED && file->pos + offset >= file->raw
        && (offset < 0 || offset >= file->out.avail)
        && (file->fast_seek != NULL))
    {
        if (ws_lseek64(file->fd, offset - file->out.avail, SEEK_CUR) == -1) {
            *err = errno;
            return -1;
        }
        file->raw_pos += (offset - file->out.avail);
        buf_reset(&file->out);
        file->eof = false;
        file->seek_pending = false;
        file->err = 0;
        file->err_info = NULL;
        buf_reset(&file->in);
        file->pos += offset;
        return file->pos;
    }
    if (offset < 0) {
        offset += file->pos;
        if (offset < 0) {                    
            *err = EINVAL;
            return -1;
        }
        if (ws_lseek64(file->fd, file->start, SEEK_SET) == -1) {
            *err = errno;
            return -1;
        }
        fast_seek_reset(file);
        file->raw_pos = file->start;
        gz_reset(file);
    }
    n = (int int)file->out.avail > offset ? (unsigned)offset : file->out.avail;
    file->out.avail -= n;
    file->out.next += n;
    file->pos += n;
    offset -= n;
    if (offset) {
        file->seek_pending = true;
        file->skip = offset;
    }
    return file->pos + offset;
}
