int jbd2_journal_write_metadata_buffer(transaction_t *transaction,
				  struct journal_head  *jh_in,
				  struct buffer_head **bh_out,
				  sector_t blocknr)
{
	int need_copy_out = 0;
	int done_copy_out = 0;
	int do_escape = 0;
	char *mapped_data;
	struct buffer_head *new_bh;
	struct folio *new_folio;
	unsigned int new_offset;
	struct buffer_head *bh_in = jh2bh(jh_in);
	journal_t *journal = transaction->t_journal;
	J_ASSERT_BH(bh_in, buffer_jbddirty(bh_in));
	new_bh = alloc_buffer_head(GFP_NOFS|__GFP_NOFAIL);
	spin_lock(&jh_in->b_state_lock);
repeat:
	if (jh_in->b_frozen_data) {
		done_copy_out = 1;
		new_folio = virt_to_folio(jh_in->b_frozen_data);
		new_offset = offset_in_folio(new_folio, jh_in->b_frozen_data);
	} else {
		new_folio = jh2bh(jh_in)->b_folio;
		new_offset = offset_in_folio(new_folio, jh2bh(jh_in)->b_data);
	}
	mapped_data = kmap_local_folio(new_folio, new_offset);
	if (!done_copy_out)
		jbd2_buffer_frozen_trigger(jh_in, mapped_data,
					   jh_in->b_triggers);
	if (*((__be32 *)mapped_data) == cpu_to_be32(JBD2_MAGIC_NUMBER)) {
		need_copy_out = 1;
		do_escape = 1;
	}
	kunmap_local(mapped_data);
	if (need_copy_out && !done_copy_out) {
		char *tmp;
		spin_unlock(&jh_in->b_state_lock);
		tmp = jbd2_alloc(bh_in->b_size, GFP_NOFS);
		if (!tmp) {
			brelse(new_bh);
			return -ENOMEM;
		}
		spin_lock(&jh_in->b_state_lock);
		if (jh_in->b_frozen_data) {
			jbd2_free(tmp, bh_in->b_size);
			goto repeat;
		}
		jh_in->b_frozen_data = tmp;
		memcpy_from_folio(tmp, new_folio, new_offset, bh_in->b_size);
		new_folio = virt_to_folio(tmp);
		new_offset = offset_in_folio(new_folio, tmp);
		done_copy_out = 1;
		jh_in->b_frozen_triggers = jh_in->b_triggers;
	}
	if (do_escape) {
		mapped_data = kmap_local_folio(new_folio, new_offset);
		*((unsigned int *)mapped_data) = 0;
		kunmap_local(mapped_data);
	}
	folio_set_bh(new_bh, new_folio, new_offset);
	new_bh->b_size = bh_in->b_size;
	new_bh->b_bdev = journal->j_dev;
	new_bh->b_blocknr = blocknr;
	new_bh->b_private = bh_in;
	set_buffer_mapped(new_bh);
	set_buffer_dirty(new_bh);
	*bh_out = new_bh;
	JBUFFER_TRACE(jh_in, "file as BJ_Shadow");
	spin_lock(&journal->j_list_lock);
	__jbd2_journal_file_buffer(jh_in, transaction, BJ_Shadow);
	spin_unlock(&journal->j_list_lock);
	set_buffer_shadow(bh_in);
	spin_unlock(&jh_in->b_state_lock);
	return do_escape | (done_copy_out << 1);
}
