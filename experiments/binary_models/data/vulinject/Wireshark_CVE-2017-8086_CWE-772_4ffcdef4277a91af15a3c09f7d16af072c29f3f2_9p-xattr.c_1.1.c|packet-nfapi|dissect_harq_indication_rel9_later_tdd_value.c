static void dissect_harq_indication_rel9_later_tdd_value(ptvcursor_t * ptvc, packet_info* pinfo)
{
	proto_item* item;
	guint32 mode, i, count;
	item = ptvcursor_add_ret_uint(ptvc, hf_nfapi_tdd_harq_mode, 1, ENC_BIG_ENDIAN, &mode);
	if (mode > 4)
	{
		expert_add_info_format(pinfo, item, &ei_invalid_range, "Invalid mode value [0..4]");
	}
	item = ptvcursor_add_ret_uint(ptvc, hf_nfapi_number_of_ack_nack, 1, ENC_BIG_ENDIAN, &count);
	if (mode == 0 || mode == 1)
	{
		if (!(count >= 1 && count <= 4))
		{
			expert_add_info_format(pinfo, item, &ei_invalid_range, "Invalid number of ack nack value [1..4]");
		}
	}
	else if (mode == 3)
	{
		if (!(count >= 1 && count <= 8))
		{
			expert_add_info_format(pinfo, item, &ei_invalid_range, "Invalid number of ack nack value [1..8]");
		}
	}
	else if (mode == 4)
	{
		if (!(count >= 1 && count <= 21))
		{
			expert_add_info_format(pinfo, item, &ei_invalid_range, "Invalid number of ack nack value [1..21]");
		}
	}
	ptvcursor_add_text_with_subtree(ptvc, SUBTREE_UNDEFINED_LENGTH, ett_nfapi_harq_ack_nack_data, "ACK/NACK Data");
	for (i = 0; i < count; ++i)
	{
		ptvcursor_add_text_with_subtree(ptvc, SUBTREE_UNDEFINED_LENGTH, ett_nfapi_harq_ack_nack_data, "[%u]", i);
		switch (mode)
		{
			case 0:
			{
				dissect_harq_indication_data_format_1a_1b_bundling_value(ptvc, pinfo);
				break;
			}
			case 1:
			{
				dissect_harq_indication_data_format_1a_1b_multplexing_value(ptvc, pinfo);
				break;
			}
			case 2:
			{
				dissect_harq_indication_data_format_1a_1b_special_bundling_value(ptvc, pinfo);
				break;
			}
			case 3:
			{
				dissect_harq_indication_data_channel_selection_value(ptvc, pinfo);
				break;
			}
			case 4:
			{
				dissect_harq_indication_data_format_3_value(ptvc, pinfo);
				break;
			}
		};
	}
	ptvcursor_pop_subtree(ptvc);
}
