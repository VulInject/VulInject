static int pcan_usb_encode_msg(struct peak_usb_device *dev, struct sk_buff *skb,
			       unsigned char *obuf, size_t *size)
{
	struct net_device *netdev = dev->netdev;
	struct net_device_stats *stats = &netdev->stats;
	struct can_frame *cf = (struct can_frame *)skb->data;
	unsigned int can_id_flags = cf->can_id & CAN_ERR_MASK;
	unsigned char *pc;
	obuf[0] = PCAN_USB_MSG_TX_CAN;
	obuf[1] = 1;	
	pc = obuf + PCAN_USB_MSG_HEADER_LEN;
	*pc = can_get_cc_dlc(cf, dev->can.ctrlmode);
	if (cf->can_id & CAN_RTR_FLAG)
		*pc |= PCAN_USB_STATUSLEN_RTR;
	if (cf->can_id & CAN_EFF_FLAG) {
		*pc |= PCAN_USB_STATUSLEN_EXT_ID;
		pc++;
		can_id_flags <<= 3;
		if (dev->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)
			can_id_flags |= PCAN_USB_TX_SRR;
		if (dev->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
			can_id_flags |= PCAN_USB_TX_AT;
		pc += 4;
	} else {
		pc++;
		can_id_flags <<= 5;
		if (dev->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)
			can_id_flags |= PCAN_USB_TX_SRR;
		if (dev->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
			can_id_flags |= PCAN_USB_TX_AT;
		put_unaligned_le16(can_id_flags, pc);
		pc += 2;
	}
	if (!(cf->can_id & CAN_RTR_FLAG)) {
		memcpy(pc, cf->data, cf->len);
		pc += cf->len;
	}
	if (can_id_flags & PCAN_USB_TX_SRR)
		*pc++ = 0x80;
	obuf[(*size)-1] = (unsigned char)(stats->tx_packets & 0xff);
	return 0;
}
