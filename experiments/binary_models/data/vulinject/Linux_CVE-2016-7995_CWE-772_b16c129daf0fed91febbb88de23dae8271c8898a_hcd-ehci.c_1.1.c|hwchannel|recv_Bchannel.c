recv_Bchannel(struct bchannel *bch, unsigned int id, bool force)
{
	struct mISDNhead *hh;
	if (unlikely(!bch->rx_skb))
		return;
	if (unlikely(!bch->rx_skb->len)) {
		dev_kfree_skb(bch->rx_skb);
		bch->rx_skb = NULL;
	} else {
		if (test_bit(FLG_TRANSPARENT, &bch->Flags) &&
		    (bch->rx_skb->len < bch->minlen) && !force)
				return;
		hh = mISDN_HEAD_P(bch->rx_skb);
		hh->prim = PH_DATA_IND;
		hh->id = id;
		if (bch->rcount >= 64) {
			printk(KERN_WARNING
			       "B%d receive queue overflow - flushing!\n",
			       bch->nr);
		}
		bch->rcount++;
		skb_queue_tail(&bch->rqueue, bch->rx_skb);
		bch->rx_skb = NULL;
		schedule_event(bch, FLG_RECVQUEUE);
	}
}
