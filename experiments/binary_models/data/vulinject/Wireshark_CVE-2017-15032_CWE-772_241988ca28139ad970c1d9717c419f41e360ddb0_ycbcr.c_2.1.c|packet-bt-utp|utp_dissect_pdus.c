utp_dissect_pdus(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
                 gboolean proto_desegment, guint fixed_len,
                 guint (*get_pdu_len)(packet_info *, tvbuff_t *, int, void*),
                 dissector_t dissect_pdu, void* dissector_data)
{
  volatile int offset = 0;
  int offset_before;
  guint captured_length_remaining;
  volatile guint plen;
  guint length;
  tvbuff_t *next_tvb;
  proto_item *item=NULL;
  const char *saved_proto;
  guint8 curr_layer_num;
  wmem_list_frame_t *frame;
  while (tvb_reported_length_remaining(tvb, offset) > 0) {
    captured_length_remaining = tvb_ensure_captured_length_remaining(tvb, offset);
    if (proto_desegment && pinfo->can_desegment) {
      if (captured_length_remaining < fixed_len) {
        pinfo->desegment_offset = offset;
        pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;
        return;
      }
    }
    plen = (*get_pdu_len)(pinfo, tvb, offset, dissector_data);
    if (plen == 0) {
      DISSECTOR_ASSERT(proto_desegment && pinfo->can_desegment);
      pinfo->desegment_offset = offset;
      pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;
      return;
    }
    if (plen < fixed_len) {
      show_reported_bounds_error(tvb, pinfo, tree);
      return;
    }
    if(!pinfo->fd->visited && utp_analyze_seq) {
      guint remaining_bytes;
      remaining_bytes = tvb_reported_length_remaining(tvb, offset);
      if(plen>remaining_bytes) {
        pinfo->want_pdu_tracking=2;
        pinfo->bytes_until_next_pdu=plen-remaining_bytes;
      }
    }
    if (proto_desegment && pinfo->can_desegment) {
      if (captured_length_remaining < plen) {
        pinfo->desegment_offset = offset;
        pinfo->desegment_len = plen - captured_length_remaining;
        return;
      }
    }
    curr_layer_num = pinfo->curr_layer_num-1;
    frame = wmem_list_frame_prev(wmem_list_tail(pinfo->layers));
    while (frame && (proto_bt_utp != (gint) GPOINTER_TO_UINT(wmem_list_frame_data(frame)))) {
      curr_layer_num--;
    }
#if 0
    if (captured_length_remaining >= plen || there are more packets)
    {
#endif
          item=proto_tree_add_uint(((utp_info_t *)p_get_proto_data(pinfo->pool, pinfo, proto_bt_utp, curr_layer_num))->tree,
                                   hf_bt_utp_pdu_size,
                                   tvb, offset, plen, plen);
          proto_item_set_generated(item);
#if 0
    } else {
          item = proto_tree_add_expert_format((proto_tree *)p_get_proto_data(pinfo->pool, pinfo, proto_bt_utp, curr_layer_num),
                                  tvb, offset, -1,
              "PDU Size: %u cut short at %u",plen,captured_length_remaining);
          proto_item_set_generated(item);
    }
#endif
    length = captured_length_remaining;
    if (length > plen) {
      length = plen;
    }
    next_tvb = tvb_new_subset_length_caplen(tvb, offset, length, plen);
    if (!(proto_desegment && pinfo->can_desegment)) {
      tvb_set_fragment(next_tvb);
    }
    saved_proto = pinfo->current_proto;
    TRY {
      (*dissect_pdu)(next_tvb, pinfo, tree, dissector_data);
    }
    CATCH_NONFATAL_ERRORS {
      show_exception(tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);
      pinfo->current_proto = saved_proto;
    }
    ENDTRY;
    offset_before = offset;
    offset += plen;
    if (offset <= offset_before)
        break;
  }
}
