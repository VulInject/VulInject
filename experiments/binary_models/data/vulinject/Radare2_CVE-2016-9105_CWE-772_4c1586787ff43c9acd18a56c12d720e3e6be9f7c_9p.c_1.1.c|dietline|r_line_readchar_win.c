static int r_line_readchar_win(ut8 *s, int slen) {	
	INPUT_RECORD irInBuf = { { 0 } };
	BOOL ret;
	DWORD mode, out;
	char buf[5] = {
		0
	};
	void *bed;
	HANDLE h = GetStdHandle (STD_INPUT_HANDLE);
	DWORD new_mode = I.vtmode == 2? ENABLE_VIRTUAL_TERMINAL_INPUT: 0;
	SetConsoleMode (h, new_mode);
	if (I.zerosep) {
		bed = r_cons_sleep_begin ();
		DWORD rsz = 0;
		BOOL ret = ReadFile (h, s, 1, &rsz, NULL);
		r_cons_sleep_end (bed);
		SetConsoleMode (h, mode);
		if (!ret || rsz != 1) {
			return 0;
		}
		return 1;
	}
do_it_again:
	bed = r_cons_sleep_begin ();
	if (r_cons_singleton ()->term_xterm) {
		ret = ReadFile (h, buf, 1, &out, NULL);
	} else {
		ret = ReadConsoleInput (h, &irInBuf, 1, &out);
	}
	r_cons_sleep_end (bed);
	if (ret < 1) {
		return 0;
	}
	if (irInBuf.EventType == KEY_EVENT) {
		if (irInBuf.Event.KeyEvent.bKeyDown) {
			if (irInBuf.Event.KeyEvent.uChar.UnicodeChar) {
				ut8 chbuf[4] = {
					0
				};
				memcpy (chbuf, &(irInBuf.Event.KeyEvent.uChar), 2);
				char *tmp = r_sys_conv_win_to_utf8_l ((PTCHAR) &chbuf, 1);
				if (tmp) {
					r_str_ncpy (buf, tmp, sizeof (buf));
					free (tmp);
				}
			} else {
				int idx = 0;
				buf[idx++] = 27;
				buf[idx++] = '[';	
				if (irInBuf.Event.KeyEvent.dwControlKeyState & 8) {
					buf[idx++] = '1';	
				}
				switch (irInBuf.Event.KeyEvent.wVirtualKeyCode) {
				case VK_UP: buf[idx++] = 'A'; break;
				case VK_DOWN: buf[idx++] = 'B'; break;
				case VK_RIGHT: buf[idx++] = 'C'; break;
				case VK_LEFT: buf[idx++] = 'D'; break;
				case VK_PRIOR: buf[idx++] = '5'; break;	
				case VK_NEXT: buf[idx++] = '6'; break;	
				case VK_DELETE: buf[idx++] = '3'; break;
				case VK_HOME: buf[idx++] = 'H'; break;	
				case VK_END: buf[idx++] = 'F'; break;	
				default: buf[0] = 0; break;
				}
			}
		}
	}
	if (!buf[0]) {
		goto do_it_again;
	}
	r_str_ncpy ((char *) s, buf, slen);
	SetConsoleMode (h, mode);
	return strlen ((char *) s);
}
