static int vhdx_open(BlockDriverState *bs, QDict *options, int flags,
                     Error **errp)
{
    BDRVVHDXState *s = bs->opaque;
    int ret = 0;
    uint32_t i;
    uint64_t signature;
    Error *local_err = NULL;
    GLOBAL_STATE_CODE();
    ret = bdrv_open_file_child(NULL, options, "file", bs, errp);
    if (ret < 0) {
        return ret;
    }
    GRAPH_RDLOCK_GUARD_MAINLOOP();
    s->bat = NULL;
    s->first_visible_write = true;
    QLIST_INIT(&s->regions);
    /* validate the file signature */
    ret = bdrv_pread(bs->file, 0, sizeof(uint64_t), &signature, 0);
    if (ret < 0) {
        goto fail;
    }
    if (memcmp(&signature, "vhdxfile", 8)) {
        ret = -EINVAL;
        goto fail;
    }
    /* This is used for any header updates, for the file_write_guid.
     * The spec dictates that a new value should be used for the first
     * header update */
    vhdx_guid_generate(&s->session_guid);
    vhdx_parse_header(bs, s, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
        ret = -EINVAL;
        goto fail;
    }
    ret = vhdx_parse_log(bs, s, &s->log_replayed_on_open, errp);
    if (ret < 0) {
        goto fail;
    }
    ret = vhdx_open_region_tables(bs, s);
    if (ret < 0) {
        goto fail;
    }
    ret = vhdx_parse_metadata(bs, s);
    if (ret < 0) {
        goto fail;
    }
    s->block_size = s->params.block_size;
    /* the VHDX spec dictates that virtual_disk_size is always a multiple of
     * logical_sector_size */
    bs->total_sectors = s->virtual_disk_size >> s->logical_sector_size_bits;
    vhdx_calc_bat_entries(s);
    s->bat_offset = s->bat_rt.file_offset;
    if (s->bat_entries > s->bat_rt.length / sizeof(VHDXBatEntry)) {
        /* BAT allocation is not large enough for all entries */
        ret = -EINVAL;
        goto fail;
    }
    /* s->bat is freed in vhdx_close() */
    s->bat = qemu_try_blockalign(bs->file->bs, s->bat_rt.length);
    if (s->bat == NULL) {
        ret = -ENOMEM;
        goto fail;
    }
    ret = bdrv_pread(bs->file, s->bat_offset, s->bat_rt.length, s->bat, 0);
    if (ret < 0) {
        goto fail;
    }
    /* endian convert populated BAT field entries */
    for (i = 0; i < s->bat_entries; i++) {
        s->bat[i] = le64_to_cpu(s->bat[i]);
    }
    if (!(flags & BDRV_O_CHECK)) {
        ret = vhdx_check_bat_entries(bs, NULL);
        if (ret < 0) {
            goto fail;
        }
    }
    /* Disable migration when VHDX images are used */
    error_setg(&s->migration_blocker, "The vhdx format used by node '%s' "
               "does not support live migration",
               bdrv_get_device_or_node_name(bs));
    ret = migrate_add_blocker_normal(&s->migration_blocker, errp);
    if (ret < 0) {
        goto fail;
    }
    /* TODO: differencing files */
    return 0;
fail:
    vhdx_close(bs);
    return ret;
}
