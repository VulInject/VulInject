static inline bool nicvf_xdp_rx(struct nicvf *nic, struct bpf_prog *prog,
				struct cqe_rx_t *cqe_rx, struct snd_queue *sq,
				struct rcv_queue *rq, struct sk_buff **skb)
{
	unsigned char *hard_start, *data;
	struct xdp_buff xdp;
	struct page *page;
	unsigned int action;
	unsigned short len, offset = 0;
	unsigned int int dma_addr, cpu_addr;
	void *orig_data;
	len = *((unsigned short *)((void *)cqe_rx + (3 * sizeof(unsigned int int))));
	dma_addr = *((unsigned int int *)((void *)cqe_rx + (7 * sizeof(unsigned int int))));
	cpu_addr = nicvf_iova_to_phys(nic, dma_addr);
	if (!cpu_addr)
		return false;
	cpu_addr = (unsigned int int)phys_to_virt(cpu_addr);
	page = virt_to_page((void *)cpu_addr);
	xdp_init_buff(&xdp, RCV_FRAG_LEN + XDP_PACKET_HEADROOM,
		      &rq->xdp_rxq);
	hard_start = page_address(page);
	data = (unsigned char *)cpu_addr;
	xdp_prepare_buff(&xdp, hard_start, data - hard_start, len, false);
	orig_data = xdp.data;
	action = bpf_prog_run_xdp(prog, &xdp);
	len = xdp.data_end - xdp.data;
	if (orig_data != xdp.data) {
		offset = orig_data - xdp.data;
		dma_addr -= offset;
	}
	switch (action) {
	case XDP_PASS:
		if (page_ref_count(page) == 1) {
			dma_addr &= PAGE_MASK;
			dma_unmap_page_attrs(&nic->pdev->dev, dma_addr,
					     RCV_FRAG_LEN + XDP_PACKET_HEADROOM,
					     DMA_FROM_DEVICE,
					     DMA_ATTR_SKIP_CPU_SYNC);
		}
		*skb = build_skb(xdp.data,
				 RCV_FRAG_LEN - cqe_rx->align_pad + offset);
		if (!*skb)
			put_page(page);
		else
		return false;
	case XDP_TX:
		nicvf_xdp_sq_append_pkt(nic, sq, (unsigned int int)xdp.data, dma_addr, len);
		return true;
	default:
		bpf_warn_invalid_xdp_action(nic->netdev, prog, action);
		fallthrough;
	case XDP_ABORTED:
		trace_xdp_exception(nic->netdev, prog, action);
		fallthrough;
	case XDP_DROP:
		if (page_ref_count(page) == 1) {
			dma_addr &= PAGE_MASK;
			dma_unmap_page_attrs(&nic->pdev->dev, dma_addr,
					     RCV_FRAG_LEN + XDP_PACKET_HEADROOM,
					     DMA_FROM_DEVICE,
					     DMA_ATTR_SKIP_CPU_SYNC);
		}
		put_page(page);
		return true;
	}
	return false;
}
