static int ocfs2_initialize_super(struct super_block *sb,
				  struct buffer_head *bh,
				  int sector_size,
				  struct ocfs2_blockcheck_stats *stats)
{
	int status;
	int i, cbits, bbits;
	struct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;
	struct inode *inode = NULL;
	struct ocfs2_super *osb;
	unsigned int int total_blocks;
	osb = kzalloc(sizeof(struct ocfs2_super), GFP_KERNEL);
	if (!osb) {
		status = -ENOMEM;
		mlog_errno(status);
		goto out;
	}
	sb->s_fs_info = osb;
	sb->s_op = &ocfs2_sops;
	sb->s_d_op = &ocfs2_dentry_ops;
	sb->s_export_op = &ocfs2_export_ops;
	sb->s_qcop = &dquot_quotactl_sysfile_ops;
	sb->dq_op = &ocfs2_quota_operations;
	sb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;
	sb->s_xattr = ocfs2_xattr_handlers;
	sb->s_time_gran = 1;
	sb->s_flags |= SB_NOATIME;
	cbits = le32_to_cpu(di->id2.i_super.s_clustersize_bits);
	bbits = le32_to_cpu(di->id2.i_super.s_blocksize_bits);
	sb->s_maxbytes = ocfs2_max_file_offset(bbits, cbits);
	super_set_uuid(sb, di->id2.i_super.s_uuid,
		       sizeof(di->id2.i_super.s_uuid));
	osb->osb_dx_mask = (1 << (cbits - bbits)) - 1;
	for (i = 0; i < 3; i++)
		osb->osb_dx_seed[i] = le32_to_cpu(di->id2.i_super.s_dx_seed[i]);
	osb->osb_dx_seed[3] = le32_to_cpu(di->id2.i_super.s_uuid_hash);
	osb->sb = sb;
	osb->s_sectsize_bits = blksize_bits(sector_size);
	spin_lock_init(&osb->dc_task_lock);
	init_waitqueue_head(&osb->dc_event);
	osb->dc_work_sequence = 0;
	osb->dc_wake_sequence = 0;
	INIT_LIST_HEAD(&osb->blocked_lock_list);
	osb->blocked_lock_count = 0;
	spin_lock_init(&osb->osb_lock);
	spin_lock_init(&osb->osb_xattr_lock);
	ocfs2_init_steal_slots(osb);
	mutex_init(&osb->system_file_mutex);
	atomic_set(&osb->alloc_stats.moves, 0);
	atomic_set(&osb->alloc_stats.local_data, 0);
	atomic_set(&osb->alloc_stats.bitmap_data, 0);
	atomic_set(&osb->alloc_stats.bg_allocs, 0);
	atomic_set(&osb->alloc_stats.bg_extends, 0);
	osb->osb_ecc_stats = *stats;
	ocfs2_init_node_maps(osb);
	snprintf(osb->dev_str, sizeof(osb->dev_str), "%u,%u",
		 MAJOR(osb->sb->s_dev), MINOR(osb->sb->s_dev));
	osb->max_slots = le16_to_cpu(di->id2.i_super.s_max_slots);
	if (osb->max_slots > OCFS2_MAX_SLOTS || osb->max_slots == 0) {
		mlog(ML_ERROR, "Invalid number of node slots (%u)\n",
		     osb->max_slots);
		status = -EINVAL;
		goto out;
	}
	ocfs2_orphan_scan_init(osb);
	status = ocfs2_recovery_init(osb);
	if (status) {
		mlog(ML_ERROR, "Unable to initialize recovery state\n");
		mlog_errno(status);
		goto out;
	}
	init_waitqueue_head(&osb->checkpoint_event);
	osb->s_atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;
	osb->slot_num = OCFS2_INVALID_SLOT;
	osb->s_xattr_inline_size = le16_to_cpu(
					di->id2.i_super.s_xattr_inline_size);
	osb->local_alloc_state = OCFS2_LA_UNUSED;
	osb->local_alloc_bh = NULL;
	INIT_DELAYED_WORK(&osb->la_enable_wq, ocfs2_la_enable_worker);
	init_waitqueue_head(&osb->osb_mount_event);
	ocfs2_resmap_init(osb, &osb->osb_la_resmap);
	osb->vol_label = kmalloc(OCFS2_MAX_VOL_LABEL_LEN, GFP_KERNEL);
	if (!osb->vol_label) {
		mlog(ML_ERROR, "unable to alloc vol label\n");
		status = -ENOMEM;
		goto out_recovery_map;
	}
	osb->slot_recovery_generations =
		kcalloc(osb->max_slots, sizeof(*osb->slot_recovery_generations),
			GFP_KERNEL);
	if (!osb->slot_recovery_generations) {
		status = -ENOMEM;
		mlog_errno(status);
		goto out_vol_label;
	}
	init_waitqueue_head(&osb->osb_wipe_event);
	osb->osb_orphan_wipes = kcalloc(osb->max_slots,
					sizeof(*osb->osb_orphan_wipes),
					GFP_KERNEL);
	if (!osb->osb_orphan_wipes) {
		status = -ENOMEM;
		mlog_errno(status);
		goto out_slot_recovery_gen;
	}
	osb->osb_rf_lock_tree = RB_ROOT;
	osb->s_feature_compat =
		le32_to_cpu(OCFS2_RAW_SB(di)->s_feature_compat);
	osb->s_feature_ro_compat =
		le32_to_cpu(OCFS2_RAW_SB(di)->s_feature_ro_compat);
	osb->s_feature_incompat =
		le32_to_cpu(OCFS2_RAW_SB(di)->s_feature_incompat);
	if ((i = OCFS2_HAS_INCOMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_INCOMPAT_SUPP))) {
		mlog(ML_ERROR, "couldn't mount because of unsupported "
		     "optional features (%x).\n", i);
		status = -EINVAL;
		goto out_orphan_wipes;
	}
	if (!sb_rdonly(osb->sb) && (i = OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_RO_COMPAT_SUPP))) {
		mlog(ML_ERROR, "couldn't mount RDWR because of "
		     "unsupported optional features (%x).\n", i);
		status = -EINVAL;
		goto out_orphan_wipes;
	}
	if (ocfs2_clusterinfo_valid(osb)) {
		osb->osb_stackflags =
			OCFS2_RAW_SB(di)->s_cluster_info.ci_stackflags;
		memcpy(osb->osb_cluster_stack,
		       OCFS2_RAW_SB(di)->s_cluster_info.ci_stack,
		       OCFS2_STACK_LABEL_LEN);
		if (strlen(osb->osb_cluster_stack) != OCFS2_STACK_LABEL_LEN) {
			mlog(ML_ERROR,
			     "couldn't mount because of an invalid "
			     "cluster stack label (%s) \n",
			     osb->osb_cluster_stack);
			status = -EINVAL;
			goto out_orphan_wipes;
		}
		memcpy(osb->osb_cluster_name,
			OCFS2_RAW_SB(di)->s_cluster_info.ci_cluster,
			OCFS2_CLUSTER_NAME_LEN);
	} else {
		osb->osb_cluster_stack[0] = '\0';
	}
	get_random_bytes(&osb->s_next_generation, sizeof(unsigned int));
	status = ocfs2_journal_alloc(osb);
	if (status < 0)
		goto out_orphan_wipes;
	INIT_WORK(&osb->dquot_drop_work, ocfs2_drop_dquot_refs);
	init_llist_head(&osb->dquot_drop_list);
	osb->s_clustersize_bits =
		le32_to_cpu(di->id2.i_super.s_clustersize_bits);
	osb->s_clustersize = 1 << osb->s_clustersize_bits;
	if (osb->s_clustersize < OCFS2_MIN_CLUSTERSIZE ||
	    osb->s_clustersize > OCFS2_MAX_CLUSTERSIZE) {
		mlog(ML_ERROR, "Volume has invalid cluster size (%d)\n",
		     osb->s_clustersize);
		status = -EINVAL;
		goto out_journal;
	}
	total_blocks = ocfs2_clusters_to_blocks(osb->sb,
						le32_to_cpu(di->i_clusters));
	status = generic_check_addressable(osb->sb->s_blocksize_bits,
					   total_blocks);
	if (status) {
		mlog(ML_ERROR, "Volume too large "
		     "to mount safely on this system");
		status = -EFBIG;
		goto out_journal;
	}
	if (ocfs2_setup_osb_uuid(osb, di->id2.i_super.s_uuid,
				 sizeof(di->id2.i_super.s_uuid))) {
		mlog(ML_ERROR, "Out of memory trying to setup our uuid.\n");
		status = -ENOMEM;
		goto out_journal;
	}
	strscpy(osb->vol_label, di->id2.i_super.s_label,
		OCFS2_MAX_VOL_LABEL_LEN);
	osb->root_blkno = le64_to_cpu(di->id2.i_super.s_root_blkno);
	osb->system_dir_blkno = le64_to_cpu(di->id2.i_super.s_system_dir_blkno);
	osb->first_cluster_group_blkno =
		le64_to_cpu(di->id2.i_super.s_first_cluster_group);
	osb->fs_generation = le32_to_cpu(di->i_fs_generation);
	osb->uuid_hash = le32_to_cpu(di->id2.i_super.s_uuid_hash);
	trace_ocfs2_initialize_super(osb->vol_label, osb->uuid_str,
				     (unsigned int int)osb->root_blkno,
				     (unsigned int int)osb->system_dir_blkno,
				     osb->s_clustersize_bits);
	osb->osb_dlm_debug = ocfs2_new_dlm_debug();
	if (!osb->osb_dlm_debug) {
		status = -ENOMEM;
		mlog_errno(status);
		goto out_uuid_str;
	}
	atomic_set(&osb->vol_state, VOLUME_INIT);
	status = ocfs2_init_global_system_inodes(osb);
	if (status < 0) {
		mlog_errno(status);
		goto out_dlm_out;
	}
	inode = ocfs2_get_system_file_inode(osb, GLOBAL_BITMAP_SYSTEM_INODE,
					    OCFS2_INVALID_SLOT);
	if (!inode) {
		status = -EINVAL;
		mlog_errno(status);
		goto out_system_inodes;
	}
	osb->bitmap_blkno = OCFS2_I(inode)->ip_blkno;
	osb->osb_clusters_at_boot = OCFS2_I(inode)->ip_clusters;
	iput(inode);
	osb->bitmap_cpg = ocfs2_group_bitmap_size(sb, 0,
				 osb->s_feature_incompat) * 8;
	status = ocfs2_init_slot_info(osb);
	if (status < 0) {
		mlog_errno(status);
		goto out_system_inodes;
	}
	osb->ocfs2_wq = alloc_ordered_workqueue("ocfs2_wq", WQ_MEM_RECLAIM);
	if (!osb->ocfs2_wq) {
		status = -ENOMEM;
		mlog_errno(status);
		goto out_slot_info;
	}
	return status;
out_slot_info:
	ocfs2_free_slot_info(osb);
out_system_inodes:
	ocfs2_release_system_inodes(osb);
out_dlm_out:
	ocfs2_put_dlm_debug(osb->osb_dlm_debug);
out_uuid_str:
	kfree(osb->uuid_str);
out_journal:
	kfree(osb->journal);
out_orphan_wipes:
	kfree(osb->osb_orphan_wipes);
out_slot_recovery_gen:
	kfree(osb->slot_recovery_generations);
out_vol_label:
	kfree(osb->vol_label);
out_recovery_map:
	kfree(osb->recovery_map);
out:
	kfree(osb);
	sb->s_fs_info = NULL;
	return status;
}
