dtp_print(netdissect_options *ndo, const u_char *tptr, u_int length)
{
    ndo->ndo_protocol = "dtp";
    if (length < DTP_HEADER_LEN) {
        ND_PRINT("[zero packet length]");
        goto invalid;
    }
    ND_PRINT("DTPv%u, length %u",
           GET_U_1(tptr),
           length);
    if (ndo->ndo_vflag < 1) {
	return;
    }
    tptr += DTP_HEADER_LEN;
    length -= DTP_HEADER_LEN;
    while (length) {
        unsigned short type, len;
        if (length < 4) {
            ND_PRINT("[%u bytes remaining]", length);
            goto invalid;
        }
	type = GET_BE_U_2(tptr);
        len  = GET_BE_U_2(tptr + 2);
        if (type == 0)
            return;
        ND_PRINT("\n\t%s (0x%04x) TLV, length %u",
               tok2str(dtp_tlv_values, "Unknown", type),
               type, len);
        if (len < 4 || len > length) {
            ND_PRINT("[TLV length %u]", len);
            goto invalid;
        }
        switch (type) {
	case DTP_DOMAIN_TLV:
		ND_PRINT(", ");
		nd_printjnp(ndo, tptr+4, len-4);
		break;
	case DTP_STATUS_TLV:
	case DTP_DTP_TYPE_TLV:
                if (len != 5)
                    goto invalid;
                ND_PRINT(", 0x%x", GET_U_1(tptr + 4));
                break;
	case DTP_NEIGHBOR_TLV:
                if (len != 10)
                    goto invalid;
                ND_PRINT(", %s", GET_MAC48_STRING(tptr+4));
                break;
        default:
            break;
        }
        tptr += len;
        length -= len;
    }
    return;
 invalid:
    nd_print_invalid(ndo);
    ND_TCHECK_LEN(tptr, length);
}
