cap_pipe_open_live(char *pipename,
                   capture_src *pcap_src,
                   void *hdr,
                   char *errmsg, size_t errmsgl,
                   char *secondary_errmsg, size_t secondary_errmsgl)
{
#ifndef _WIN32
    ws_statb64         pipe_stat;
    struct sockaddr_un sa;
#else 
    guintptr extcap_pipe_handle;
#endif
    gboolean extcap_pipe = FALSE;
    ssize_t  b;
    int      fd = -1, sel_ret;
    size_t   bytes_read;
    guint32  magic = 0;
    pcap_src->cap_pipe_fd = -1;
#ifdef _WIN32
    pcap_src->cap_pipe_h = INVALID_HANDLE_VALUE;
#endif
    ws_debug("cap_pipe_open_live: %s", pipename);
    if (strcmp(pipename, "-") == 0) {
#ifndef _WIN32
        fd = 0; 
#else 
        pcap_src->cap_pipe_h = GetStdHandle(STD_INPUT_HANDLE);
#endif  
    } else if (!strncmp(pipename, "TCP@", 4)) {
       if ((fd = cap_open_socket(pipename, pcap_src, errmsg, errmsgl)) < 0) {
          return;
       }
    } else {
#ifndef _WIN32
        if ( g_strrstr(pipename, EXTCAP_PIPE_PREFIX) != NULL )
            extcap_pipe = TRUE;
        if (ws_stat64(pipename, &pipe_stat) < 0) {
            if (errno == ENOENT || errno == ENOTDIR)
                pcap_src->cap_pipe_err = PIPNEXIST;
            else {
                snprintf(errmsg, errmsgl,
                           "The capture session could not be initiated "
                           "due to error getting information on pipe or socket: %s.", g_strerror(errno));
                pcap_src->cap_pipe_err = PIPERR;
            }
            return;
        }
        if (S_ISFIFO(pipe_stat.st_mode)) {
            fd = ws_open(pipename, O_RDONLY | O_NONBLOCK, 0000 );
            if (fd == -1) {
                snprintf(errmsg, errmsgl,
                           "The capture session could not be initiated "
                           "due to error on pipe open: %s.", g_strerror(errno));
                pcap_src->cap_pipe_err = PIPERR;
                return;
            }
        } else if (S_ISSOCK(pipe_stat.st_mode)) {
            fd = socket(AF_UNIX, SOCK_STREAM, 0);
            if (fd == -1) {
                snprintf(errmsg, errmsgl,
                           "The capture session could not be initiated "
                           "due to error on socket create: %s.", g_strerror(errno));
                pcap_src->cap_pipe_err = PIPERR;
                return;
            }
            sa.sun_family = AF_UNIX;
            if (g_strlcpy(sa.sun_path, pipename, sizeof sa.sun_path) > sizeof sa.sun_path) {
                snprintf(errmsg, errmsgl,
                           "The capture session could not be initiated "
                           "due to error on socket connect: Path name too int.");
                pcap_src->cap_pipe_err = PIPERR;
                ws_close(fd);
                return;
            }
            b = connect(fd, (struct sockaddr *)&sa, sizeof sa);
            if (b == -1) {
                snprintf(errmsg, errmsgl,
                           "The capture session could not be initiated "
                           "due to error on socket connect: %s.", g_strerror(errno));
                pcap_src->cap_pipe_err = PIPERR;
                ws_close(fd);
                return;
            }
        } else {
            if (S_ISCHR(pipe_stat.st_mode)) {
                pcap_src->cap_pipe_err = PIPNEXIST;
            } else {
                snprintf(errmsg, errmsgl,
                           "The capture session could not be initiated because\n"
                           "\"%s\" is neither an interface nor a socket nor a pipe.", pipename);
                pcap_src->cap_pipe_err = PIPERR;
            }
            return;
        }
#else 
        if (sscanf(pipename, EXTCAP_PIPE_PREFIX "%" SCNuPTR, &extcap_pipe_handle) == 1)
        {
            extcap_pipe = TRUE;
            pcap_src->cap_pipe_h = (HANDLE)extcap_pipe_handle;
        }
        else
        {
            if (!win32_is_pipe_name(pipename)) {
                snprintf(errmsg, errmsgl,
                    "The capture session could not be initiated because\n"
                    "\"%s\" is neither an interface nor a pipe.", pipename);
                pcap_src->cap_pipe_err = PIPNEXIST;
                return;
            }
            while (1) {
                pcap_src->cap_pipe_h = CreateFile(utf_8to16(pipename), GENERIC_READ, 0, NULL,
                        OPEN_EXISTING, 0, NULL);
                if (pcap_src->cap_pipe_h != INVALID_HANDLE_VALUE)
                    break;
                if (GetLastError() != ERROR_PIPE_BUSY) {
                    snprintf(errmsg, errmsgl,
                        "The capture session on \"%s\" could not be started "
                        "due to error on pipe open: %s.",
                        pipename, win32strerror(GetLastError()));
                    pcap_src->cap_pipe_err = PIPERR;
                    return;
                }
                if (!WaitNamedPipe(utf_8to16(pipename), 30 * 1000)) {
                    snprintf(errmsg, errmsgl,
                        "The capture session on \"%s\" timed out during "
                        "pipe open: %s.",
                        pipename, win32strerror(GetLastError()));
                    pcap_src->cap_pipe_err = PIPERR;
                    return;
                }
            }
        }
#endif 
    }
    pcap_src->from_cap_pipe = TRUE;
    pcap_src->cap_pipe_databuf = (char*)g_malloc(2048);
    pcap_src->cap_pipe_databuf_size = 2048;
#ifdef _WIN32
    if (pcap_src->from_cap_socket)
#endif
    {
        bytes_read = 0;
        while (bytes_read < sizeof magic) {
            sel_ret = cap_pipe_select(fd);
            if (sel_ret < 0) {
                snprintf(errmsg, errmsgl,
                           "Unexpected error from select: %s.",
                           g_strerror(errno));
                goto error;
            } else if (sel_ret > 0) {
                b = cap_pipe_read(fd, ((char *)&magic)+bytes_read,
                                  sizeof magic-bytes_read,
                                  pcap_src->from_cap_socket);
                if (extcap_pipe && b <= 0)
                    goto error;
		if(b == 0) {
                    if (b == 0)
                        snprintf(errmsg, errmsgl,
                                   "End of file on pipe magic during open.");
                    else
                        snprintf(errmsg, errmsgl,
                                   "Error on pipe magic during open: %s.",
                                   g_strerror(errno));
                    goto error;
                }
                bytes_read += b;
            }
        }
    }
#ifdef _WIN32
    else {
        g_thread_new("cap_pipe_open_live", &cap_thread_read, pcap_src);
        pipe_read_sync(pcap_src, &magic, sizeof(magic));
        if (pcap_src->cap_pipe_bytes_read <= 0 && extcap_pipe)
            goto error;
        if (pcap_src->cap_pipe_bytes_read <= 0) {
            if (pcap_src->cap_pipe_bytes_read == 0)
                snprintf(errmsg, errmsgl,
                           "End of file on pipe magic during open.");
            else
                snprintf(errmsg, errmsgl,
                           "Error on pipe magic during open: %s.",
                           g_strerror(errno));
            goto error;
        }
    }
#endif
    switch (magic) {
    case PCAP_MAGIC:
    case PCAP_NSEC_MAGIC:
        pcap_src->cap_pipe_info.pcap.byte_swapped = FALSE;
        pcap_src->cap_pipe_modified = FALSE;
        pcap_src->ts_nsec = magic == PCAP_NSEC_MAGIC;
        break;
    case PCAP_MODIFIED_MAGIC:
        pcap_src->cap_pipe_info.pcap.byte_swapped = FALSE;
        pcap_src->cap_pipe_modified = TRUE;
        break;
    case PCAP_SWAPPED_MAGIC:
    case PCAP_SWAPPED_NSEC_MAGIC:
        pcap_src->cap_pipe_info.pcap.byte_swapped = TRUE;
        pcap_src->cap_pipe_modified = FALSE;
        pcap_src->ts_nsec = magic == PCAP_SWAPPED_NSEC_MAGIC;
        break;
    case PCAP_SWAPPED_MODIFIED_MAGIC:
        pcap_src->cap_pipe_info.pcap.byte_swapped = TRUE;
        pcap_src->cap_pipe_modified = TRUE;
        break;
    case BLOCK_TYPE_SHB:
        pcap_src->from_pcapng = TRUE;
        pcap_src->cap_pipe_dispatch = pcapng_pipe_dispatch;
        pcap_src->cap_pipe_info.pcapng.src_iface_to_global = g_array_new(FALSE, FALSE, sizeof(guint32));
        global_capture_opts.use_pcapng = TRUE;      
        break;
    default:
        snprintf(errmsg, errmsgl,
                   "File type is neither a supported pcap nor pcapng format. (magic = 0x%08x)", magic);
        snprintf(secondary_errmsg, secondary_errmsgl, "%s",
                   not_our_bug);
        goto error;
    }
    if (pcap_src->from_pcapng)
        pcapng_pipe_open_live(fd, pcap_src, errmsg, errmsgl);
    else
        pcap_pipe_open_live(fd, pcap_src, (struct pcap_hdr *) hdr, errmsg, errmsgl,
                            secondary_errmsg, secondary_errmsgl);
    return;
error:
    ws_debug("cap_pipe_open_live: error %s", errmsg);
    pcap_src->cap_pipe_err = PIPERR;
    cap_pipe_close(fd, pcap_src->from_cap_socket);
    pcap_src->cap_pipe_fd = -1;
#ifdef _WIN32
    pcap_src->cap_pipe_h = INVALID_HANDLE_VALUE;
#endif
}
