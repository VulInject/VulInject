static void adm8211_interrupt_rci(struct ieee80211_hw *dev)
{
	struct adm8211_priv *priv = dev->priv;
	unsigned int entry = priv->cur_rx % priv->rx_ring_size;
	unsigned int status;
	unsigned int pktlen;
	struct sk_buff *skb, *newskb;
	unsigned int limit = priv->rx_ring_size;
	unsigned char rssi, rate;
	while (!(priv->rx_ring[entry].status & cpu_to_le32(RDES0_STATUS_OWN))) {
		if (!limit--)
			break;
		status = le32_to_cpu(priv->rx_ring[entry].status);
		rate = (status & RDES0_STATUS_RXDR) >> 12;
		rssi = le32_to_cpu(priv->rx_ring[entry].length) &
			RDES1_STATUS_RSSI;
		pktlen = status & RDES0_STATUS_FL;
		if (pktlen > RX_PKT_SIZE) {
			if (net_ratelimit())
				wiphy_debug(dev->wiphy, "frame too int (%d)\n",
					    pktlen);
			pktlen = RX_PKT_SIZE;
		}
		if (!priv->soft_rx_crc && status & RDES0_STATUS_ES) {
			skb = NULL; 
		} else if (pktlen < RX_COPY_BREAK) {
			skb = dev_alloc_skb(pktlen);
			if (skb) {
				dma_sync_single_for_cpu(&priv->pdev->dev,
							priv->rx_buffers[entry].mapping,
							pktlen,
							DMA_FROM_DEVICE);
				skb_put_data(skb,
					     skb_tail_pointer(priv->rx_buffers[entry].skb),
					     pktlen);
				dma_sync_single_for_device(&priv->pdev->dev,
							   priv->rx_buffers[entry].mapping,
							   RX_PKT_SIZE,
							   DMA_FROM_DEVICE);
			}
		} else {
			newskb = dev_alloc_skb(RX_PKT_SIZE);
			if (newskb) {
				skb = priv->rx_buffers[entry].skb;
				dma_unmap_single(&priv->pdev->dev,
						 priv->rx_buffers[entry].mapping,
						 RX_PKT_SIZE, DMA_FROM_DEVICE);
				priv->rx_buffers[entry].skb = newskb;
				priv->rx_buffers[entry].mapping =
					dma_map_single(&priv->pdev->dev,
						       skb_tail_pointer(newskb),
						       RX_PKT_SIZE,
						       DMA_FROM_DEVICE);
				if (dma_mapping_error(&priv->pdev->dev,
						      priv->rx_buffers[entry].mapping)) {
					priv->rx_buffers[entry].skb = NULL;
					dev_kfree_skb(newskb);
					skb = NULL;
				}
			} else {
				skb = NULL;
			}
			priv->rx_ring[entry].buffer1 =
				cpu_to_le32(priv->rx_buffers[entry].mapping);
		}
		priv->rx_ring[entry].status = cpu_to_le32(RDES0_STATUS_OWN |
							  RDES0_STATUS_SQL);
		priv->rx_ring[entry].length =
			cpu_to_le32(RX_PKT_SIZE |
				    (entry == priv->rx_ring_size - 1 ?
				     RDES1_CONTROL_RER : 0));
		if (skb) {
			struct ieee80211_rx_status rx_status = {0};
			if (priv->pdev->revision < ADM8211_REV_CA)
				rx_status.signal = rssi;
			else
				rx_status.signal = 100 - rssi;
			rx_status.rate_idx = rate;
			rx_status.freq = adm8211_channels[priv->channel - 1].center_freq;
			rx_status.band = NL80211_BAND_2GHZ;
			memcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));
			ieee80211_rx_irqsafe(dev, skb);
		}
		entry = (++priv->cur_rx) % priv->rx_ring_size;
	}
}
