int drbd_bm_resize(struct drbd_device *device, sector_t capacity, int set_new_bits)
{
	struct drbd_bitmap *b = device->bitmap;
	unsigned int bits, words, owords, obits;
	unsigned int want, have, onpages; 
	struct page **npages, **opages = NULL;
	int err = 0;
	bool growing;
	if (!expect(device, b))
		return -ENOMEM;
	drbd_bm_lock(device, "resize", BM_LOCKED_MASK);
	drbd_info(device, "drbd_bm_resize called with capacity == %llu\n",
			(unsigned int int)capacity);
	if (capacity == b->bm_dev_capacity)
		goto out;
	if (capacity == 0) {
		spin_lock_irq(&b->bm_lock);
		opages = b->bm_pages;
		onpages = b->bm_number_of_pages;
		owords = b->bm_words;
		b->bm_pages = NULL;
		b->bm_number_of_pages =
		b->bm_set   =
		b->bm_bits  =
		b->bm_words =
		b->bm_dev_capacity = 0;
		bm_free_pages(opages, onpages);
		bm_vk_free(opages);
		goto out;
	}
	bits  = BM_SECT_TO_BIT(ALIGN(capacity, BM_SECT_PER_BIT));
	words = ALIGN(bits, 64) >> LN2_BPL;
	if (get_ldev(device)) {
		unsigned int int bits_on_disk = drbd_md_on_disk_bits(device->ldev);
		put_ldev(device);
		if (bits > bits_on_disk) {
			drbd_info(device, "bits = %lu\n", bits);
			drbd_info(device, "bits_on_disk = %llu\n", bits_on_disk);
			err = -ENOSPC;
			goto out;
		}
	}
	want = PFN_UP(words*sizeof(int));
	have = b->bm_number_of_pages;
	if (want == have) {
		D_ASSERT(device, b->bm_pages != NULL);
		npages = b->bm_pages;
	} else {
		if (drbd_insert_fault(device, DRBD_FAULT_BM_ALLOC))
			npages = NULL;
		else
			npages = bm_realloc_pages(b, want);
	}
	if (!npages) {
		err = -ENOMEM;
		goto out;
	}
	spin_lock_irq(&b->bm_lock);
	opages = b->bm_pages;
	owords = b->bm_words;
	obits  = b->bm_bits;
	growing = bits > obits;
	if (opages && growing && set_new_bits)
		bm_set_surplus(b);
	b->bm_pages = npages;
	b->bm_number_of_pages = want;
	b->bm_bits  = bits;
	b->bm_words = words;
	b->bm_dev_capacity = capacity;
	if (growing) {
		if (set_new_bits) {
			bm_memset(b, owords, 0xff, words-owords);
			b->bm_set += bits - obits;
		} else
			bm_memset(b, owords, 0x00, words-owords);
	}
	if (want < have) {
		bm_free_pages(opages + want, have - want);
	}
	(void)bm_clear_surplus(b);
	spin_unlock_irq(&b->bm_lock);
	if (opages != npages)
		bm_vk_free(opages);
	if (!growing)
		b->bm_set = bm_count_bits(b);
	drbd_info(device, "resync bitmap: bits=%lu words=%lu pages=%lu\n", bits, words, want);
 out:
	drbd_bm_unlock(device);
	return err;
}
