int devm_cxl_enumerate_ports(struct cxl_memdev *cxlmd)
{
	struct device *dev = &cxlmd->dev;
	struct device *iter;
	int rc;
	if (cxlmd->cxlds->rcd)
		return 0;
	rc = devm_add_action_or_reset(&cxlmd->dev, cxl_detach_ep, cxlmd);
	if (rc)
		return rc;
retry:
	for (iter = dev; iter; iter = grandparent(iter)) {
		struct device *dport_dev = grandparent(iter);
		struct device *uport_dev;
		struct cxl_dport *dport;
		struct cxl_port *port;
		if (!dport_dev || dport_dev == &platform_bus)
			return 0;
		uport_dev = dport_dev->parent;
		if (!uport_dev) {
			dev_warn(dev, "at %s no parent for dport: %s\n",
				 dev_name(iter), dev_name(dport_dev));
			return -ENXIO;
		}
		dev_dbg(dev, "scan: iter: %s dport_dev: %s parent: %s\n",
			dev_name(iter), dev_name(dport_dev),
			dev_name(uport_dev));
		port = find_cxl_port(dport_dev, &dport);
		if (port) {
			dev_dbg(&cxlmd->dev,
				"found already registered port %s:%s\n",
				dev_name(&port->dev),
				dev_name(port->uport_dev));
			rc = cxl_add_ep(dport, &cxlmd->dev);
			if (rc && rc != -EBUSY) {
				return rc;
			}
			if (!dev_is_cxl_root_child(&port->dev)) {
				put_device(&port->dev);
				continue;
			}
			put_device(&port->dev);
			return 0;
		}
		rc = add_port_attach_ep(cxlmd, uport_dev, dport_dev);
		if (rc == -EAGAIN)
			continue;
		if (rc)
			return rc;
		goto retry;
	}
	return 0;
}
