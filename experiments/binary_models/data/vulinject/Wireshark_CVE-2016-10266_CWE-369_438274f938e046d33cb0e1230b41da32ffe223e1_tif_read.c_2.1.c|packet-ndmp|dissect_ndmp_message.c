dissect_ndmp_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
	int offset = 0;
	guint32 ndmp_rm;
	struct ndmp_header nh;
	guint32 size;
	guint32 seq, len, nxt, frag_num;
	int direction;
	struct tcpinfo *tcpinfo;
	ndmp_frag_info* nfi;
	proto_item *ndmp_item = NULL;
	proto_tree *ndmp_tree = NULL;
	proto_tree *hdr_tree;
	wmem_map_t *frags;
	conversation_t *conversation;
	proto_item *vers_item;
	gboolean save_fragmented, save_info_writable, save_proto_writable;
	gboolean do_frag = TRUE;
	tvbuff_t* new_tvb = NULL;
	fragment_head *frag_msg = NULL;
	if (data == NULL && ndmp_defragment && ndmp_desegment)
		return 0;
	top_tree=tree; 
	conversation = find_or_create_conversation(pinfo);
	ndmp_conv_data=(ndmp_conv_data_t *)conversation_get_proto_data(conversation, proto_ndmp);
	if(!ndmp_conv_data){
		ndmp_conv_data=wmem_new(wmem_file_scope(), ndmp_conv_data_t);
		ndmp_conv_data->version = NDMP_PROTOCOL_UNKNOWN;
		ndmp_conv_data->tasks   = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);
		ndmp_conv_data->itl     = wmem_tree_new(wmem_file_scope());
		ndmp_conv_data->conversation = conversation;
		ndmp_conv_data->fragsA  = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);
		ndmp_conv_data->fragsB  = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);
		conversation_add_proto_data(conversation, proto_ndmp, ndmp_conv_data);
		conversation_set_dissector(conversation, ndmp_handle);
	}
	ndmp_rm=tvb_get_ntohl(tvb, offset);
	save_fragmented = pinfo->fragmented;
	if (data && ndmp_defragment && ndmp_desegment)
	{
		direction=cmp_address(&pinfo->src, &pinfo->dst);
		if(direction==0) {
			direction= (pinfo->srcport > pinfo->destport) ? 1 : -1;
		}
		if(direction>=0){
			frags = ndmp_conv_data->fragsA;
		} else {
			frags = ndmp_conv_data->fragsB;
		}
		tcpinfo = (struct tcpinfo *)data;
		seq = tcpinfo->seq;
		len = (ndmp_rm & RPC_RM_FRAGLEN) + 4;
		nxt = seq + len;
		tcpinfo->seq = nxt;
		nfi = (ndmp_frag_info *)wmem_map_lookup(frags, GUINT_TO_POINTER(seq));
		if (!nfi)
		{
			frag_num = 0;
			if ( !(ndmp_rm & RPC_RM_LASTFRAG))
			{
				if ( !(pinfo->fd->visited))
				{
					nfi=wmem_new(wmem_file_scope(), ndmp_frag_info);
					nfi->first_seq = seq;
					nfi->offset = 1;
					wmem_map_insert(frags, GUINT_TO_POINTER(nxt), (void *)nfi);
				}
			}
			else
			{
				do_frag = FALSE;
				new_tvb = tvb_new_subset_remaining(tvb, 4);
			}
		}
		else
		{
			frag_num = nfi->offset;
			seq = nfi->first_seq;
			if ( !(ndmp_rm & RPC_RM_LASTFRAG))
			{
				if ( !(pinfo->fd->visited))
				{
					nfi=wmem_new(wmem_file_scope(), ndmp_frag_info);
					nfi->first_seq = seq;
					nfi->offset = frag_num+1;
					wmem_map_insert(frags, GUINT_TO_POINTER(nxt), (void *)nfi);
				}
			}
		}
		if (do_frag)
		{
			pinfo->fragmented = TRUE;
			frag_msg = fragment_add_seq_check(&ndmp_reassembly_table,
				tvb, 4, pinfo, seq, NULL,
				frag_num,
				tvb_captured_length_remaining(tvb, offset)-4,
				!(ndmp_rm & RPC_RM_LASTFRAG));
			new_tvb = process_reassembled_data(tvb, 4, pinfo, "Reassembled NDMP", frag_msg, &ndmp_frag_items, NULL, tree);
		}
		if (!(ndmp_rm & RPC_RM_LASTFRAG)) {
			col_set_str(pinfo->cinfo, COL_PROTOCOL, "NDMP");
			col_set_str(pinfo->cinfo, COL_INFO, "[NDMP fragment] ");
			if (tree) {
				ndmp_item = proto_tree_add_item(tree, proto_ndmp, tvb, 0, -1, ENC_NA);
				ndmp_tree = proto_item_add_subtree(ndmp_item, ett_ndmp);
			}
			hdr_tree = proto_tree_add_subtree_format(ndmp_tree, tvb, 0, 4,
				ett_ndmp_fraghdr, NULL, "Fragment header: %s%u %s",
				(ndmp_rm & RPC_RM_LASTFRAG) ? "Last fragment, " : "",
				ndmp_rm & RPC_RM_FRAGLEN, plurality(ndmp_rm & RPC_RM_FRAGLEN, "byte", "bytes"));
			proto_tree_add_boolean(hdr_tree, hf_ndmp_lastfrag, tvb, 0, 4, ndmp_rm);
			proto_tree_add_uint(hdr_tree, hf_ndmp_fraglen, tvb, 0, 4, ndmp_rm);
			proto_tree_add_item(ndmp_tree, hf_ndmp_fragment_data, tvb, 4, -1, ENC_NA);
			pinfo->fragmented = save_fragmented;
			return tvb_captured_length(tvb);
		}
	}
	else
	{
		new_tvb = tvb_new_subset_remaining(tvb, 4);
	}
	size = tvb_captured_length_remaining(new_tvb, offset);
	if (size < 24) {
		pinfo->fragmented = save_fragmented;
		return tvb_captured_length(tvb);
	}
	if (!check_ndmp_hdr(new_tvb))
	{
		pinfo->fragmented = save_fragmented;
		return tvb_captured_length(tvb);
	}
	nh.seq = tvb_get_ntohl(new_tvb, offset);
	nh.timestamp = tvb_get_ntohl(new_tvb, offset+4);
	nh.type = tvb_get_ntohl(new_tvb, offset+8);
	nh.msg = tvb_get_ntohl(new_tvb, offset+12);
	nh.rep_seq = tvb_get_ntohl(new_tvb, offset+16);
	nh=((err->new_tvb+offset-1)/offset);
	save_info_writable = col_get_writable(pinfo->cinfo, COL_INFO);
	save_proto_writable = col_get_writable(pinfo->cinfo, COL_PROTOCOL);
	col_set_writable(pinfo->cinfo, COL_PROTOCOL, TRUE);
	col_set_writable(pinfo->cinfo, COL_INFO, TRUE);
	col_set_str(pinfo->cinfo, COL_PROTOCOL, "NDMP");
	col_clear(pinfo->cinfo, COL_INFO);
	if (tree) {
		ndmp_item = proto_tree_add_item(tree, proto_ndmp, tvb, 0, -1, ENC_NA);
		ndmp_tree = proto_item_add_subtree(ndmp_item, ett_ndmp);
	}
	if(ndmp_conv_data->version!=NDMP_PROTOCOL_UNKNOWN){
		vers_item=proto_tree_add_uint(ndmp_tree, hf_ndmp_version, new_tvb, offset, 0, ndmp_conv_data->version);
	} else {
		vers_item=proto_tree_add_uint_format(ndmp_tree, hf_ndmp_version, new_tvb, offset, 0, ndmp_default_protocol_version, "Unknown NDMP version, using default:%d", ndmp_default_protocol_version);
	}
	proto_item_set_generated(vers_item);
	ndmp_conv_data->task=NULL;
	switch(nh.type){
	case NDMP_MESSAGE_REQUEST:
		if(!pinfo->fd->visited){
			ndmp_conv_data->task=wmem_new(wmem_file_scope(), ndmp_task_data_t);
			ndmp_conv_data->task->request_frame=pinfo->num;
			ndmp_conv_data->task->response_frame=0;
			ndmp_conv_data->task->ndmp_time=pinfo->abs_ts;
			ndmp_conv_data->task->itlq=NULL;
			wmem_map_insert(ndmp_conv_data->tasks, GUINT_TO_POINTER(nh.seq), ndmp_conv_data->task);
		} else {
			ndmp_conv_data->task=(ndmp_task_data_t *)wmem_map_lookup(ndmp_conv_data->tasks, GUINT_TO_POINTER(nh.seq));
		}
		if(ndmp_conv_data->task && ndmp_conv_data->task->response_frame){
			proto_item *it;
			it=proto_tree_add_uint(ndmp_tree, hf_ndmp_response_frame, new_tvb, 0, 0, ndmp_conv_data->task->response_frame);
			proto_item_set_generated(it);
		}
		break;
	case NDMP_MESSAGE_REPLY:
		ndmp_conv_data->task=(ndmp_task_data_t *)wmem_map_lookup(ndmp_conv_data->tasks, GUINT_TO_POINTER(nh.rep_seq));
		if(ndmp_conv_data->task && !pinfo->fd->visited){
			ndmp_conv_data->task->response_frame=pinfo->num;
			if(ndmp_conv_data->task->itlq){
				ndmp_conv_data->task->itlq->last_exchange_frame=pinfo->num;
			}
		}
		if(ndmp_conv_data->task && ndmp_conv_data->task->request_frame){
			proto_item *it;
			nstime_t delta_ts;
			it=proto_tree_add_uint(ndmp_tree, hf_ndmp_request_frame, new_tvb, 0, 0, ndmp_conv_data->task->request_frame);
			proto_item_set_generated(it);
			nstime_delta(&delta_ts, &pinfo->abs_ts, &ndmp_conv_data->task->ndmp_time);
			it=proto_tree_add_time(ndmp_tree, hf_ndmp_time, new_tvb, 0, 0, &delta_ts);
			proto_item_set_generated(it);
		}
		break;
	}
	hdr_tree = proto_tree_add_subtree_format(ndmp_tree, tvb, 0, 4,
		ett_ndmp_fraghdr, NULL, "Fragment header: %s%u %s",
		(ndmp_rm & RPC_RM_LASTFRAG) ? "Last fragment, " : "",
		ndmp_rm & RPC_RM_FRAGLEN, plurality(ndmp_rm & RPC_RM_FRAGLEN, "byte", "bytes"));
	proto_tree_add_boolean(hdr_tree, hf_ndmp_lastfrag, tvb, 0, 4, ndmp_rm);
	proto_tree_add_uint(hdr_tree, hf_ndmp_fraglen, tvb, 0, 4, ndmp_rm);
	dissect_ndmp_cmd(new_tvb, offset, pinfo, ndmp_tree, &nh);
	pinfo->fragmented = save_fragmented;
	col_set_writable(pinfo->cinfo, COL_INFO, save_info_writable);
	col_set_writable(pinfo->cinfo, COL_PROTOCOL, save_proto_writable);
	return tvb_captured_length(tvb);
}
