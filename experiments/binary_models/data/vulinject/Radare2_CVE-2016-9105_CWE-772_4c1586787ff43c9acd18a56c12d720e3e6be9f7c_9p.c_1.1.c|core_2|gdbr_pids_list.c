RList* gdbr_pids_list(libgdbr_t *g, int pid) {
	int ret = -1;
	RList *list = NULL;
	int tpid = -1, ttid = -1;
	char *ptr, *ptr2, *exec_file;
	RDebugPid *dpid = NULL;
	RListIter *iter = NULL;
	if (!g) {
		return NULL;
	}
	if (!gdbr_lock_enter (g)) {
		goto end;
	}
	if (!(list = r_list_new ())) {
		ret = -1;
		goto end;
	}
	if (g->stub_features.qXfer_threads_read) {
		if (gdbr_read_processes_xml(g, pid, list) == 0) {
			ret = 0;
			goto end;
		}
	}
	R_LOG_WARN ("Showing possibly incomplete pid list due to xml protocol failure");
	if (!g->stub_features.qXfer_exec_file_read
		    || !(exec_file = gdbr_exec_file_read (g, pid))) {
		exec_file = "";
	}
	if (send_msg (g, "qfThreadInfo") < 0 || read_packet (g, false) < 0 || send_ack (g) < 0
		    || g->data_len == 0 || g->data[0] != 'm') {
		ret = -1;
		goto end;
	}
	while (1) {
		g->data[g->data_len] = '\0';
		ptr = g->data + 1;
		while (ptr) {
			if ((ptr2 = strchr (ptr, ','))) {
				*ptr2 = '\0';
				ptr2++;
			}
			if (read_thread_id (ptr, &tpid, &ttid, g->stub_features.multiprocess) < 0) {
				ptr = ptr2;
				continue;
			}
			r_list_foreach (list, iter, dpid) {
				if (tpid == dpid->pid) {
					continue;
				}
			}
			if (!(dpid = R_NEW0 (RDebugPid)) || !(dpid->path = strdup (exec_file))) {
				ret = -1;
				goto end;
			}
			dpid->pid = tpid;
			if (tpid != g->pid) {
				dpid->ppid = g->pid;
			}
			dpid->uid = dpid->gid = -1;
			dpid->runnable = true;
			dpid->status = R_DBG_PROC_STOP;
			ptr = ptr2;
		}
		if (send_msg (g, "qsThreadInfo") < 0 || read_packet (g, false) < 0
			    || send_ack (g) < 0 || g->data_len == 0
			    || (g->data[0] != 'm' && g->data[0] != 'l')) {
			ret = -1;
			goto end;
		}
		if (g->data[0] == 'l') {
			break;
		}
	}
	ret = 0;
end:
	gdbr_lock_leave (g);
	if (ret != 0) {
		free (dpid);
		if (list) {
			r_list_foreach (list, iter, dpid) {
				free (dpid->path);
				free (dpid);
			}
			r_list_free (list);
		}
		return NULL;
	}
	return list;
}
