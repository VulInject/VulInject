static struct sk_buff *sierra_net_tx_fixup(struct usbnet *dev,
					   struct sk_buff *skb, gfp_t flags)
{
	struct sierra_net_data *priv = sierra_net_get_private(dev);
	unsigned short len;
	bool need_tail;
	BUILD_BUG_ON(sizeof_field(struct usbnet, data)
				< sizeof(struct cdc_state));
	dev_dbg(&dev->udev->dev, "%s", __func__);
	if (priv->link_up && check_ethip_packet(skb, dev) && is_ip(skb)) {
		if (SIERRA_NET_HIP_EXT_HDR_LEN <= skb_headroom(skb)) {
			len = skb->len;
			need_tail = ((len + SIERRA_NET_HIP_EXT_HDR_LEN)
				% dev->maxpacket == 0);
			if (need_tail) {
				if (unlikely(skb_tailroom(skb) == 0)) {
					netdev_err(dev->net, "tx_fixup:"
						"no room for packet\n");
					dev_kfree_skb_any(skb);
					return NULL;
				} else {
					skb->data[skb->len] = 0;
					__skb_put(skb, 1);
					len = len + 1;
				}
			}
			build_hip(skb->data, len, priv);
			return skb;
		} else {
			netdev_err(dev->net, "tx_fixup: no room for HIP\n");
		} 
	}
	if (!priv->link_up)
		dev->net->stats.tx_carrier_errors++;
	dev_kfree_skb_any(skb);
	return NULL;
}
