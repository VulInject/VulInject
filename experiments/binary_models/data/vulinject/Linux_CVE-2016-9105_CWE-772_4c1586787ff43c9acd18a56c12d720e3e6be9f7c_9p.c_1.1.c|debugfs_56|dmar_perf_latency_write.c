static ssize_t dmar_perf_latency_write(struct file *filp,
				       const char __user *ubuf,
				       size_t cnt, loff_t *ppos)
{
	struct dmar_drhd_unit *drhd;
	struct intel_iommu *iommu;
	int counting;
	char buf[64];
	if (cnt > 63)
		cnt = 63;
	if (copy_from_user(&buf, ubuf, cnt))
		return -EFAULT;
	buf[cnt] = 0;
	if (kstrtoint(buf, 0, &counting))
		return -EINVAL;
	switch (counting) {
	case 0:
		rcu_read_lock();
		for_each_active_iommu(iommu, drhd) {
			dmar_latency_disable(iommu, DMAR_LATENCY_INV_DEVTLB);
			dmar_latency_disable(iommu, DMAR_LATENCY_INV_IEC);
		}
		rcu_read_unlock();
		break;
	case 1:
		rcu_read_lock();
		for_each_active_iommu(iommu, drhd)
			dmar_latency_enable(iommu, DMAR_LATENCY_INV_IOTLB);
		rcu_read_unlock();
		break;
	case 2:
		rcu_read_lock();
		for_each_active_iommu(iommu, drhd)
			dmar_latency_enable(iommu, DMAR_LATENCY_INV_DEVTLB);
		rcu_read_unlock();
		break;
	case 3:
		rcu_read_lock();
		for_each_active_iommu(iommu, drhd)
			dmar_latency_enable(iommu, DMAR_LATENCY_INV_IEC);
		rcu_read_unlock();
		break;
	default:
		return -EINVAL;
	}
	*ppos += cnt;
	return cnt;
}
