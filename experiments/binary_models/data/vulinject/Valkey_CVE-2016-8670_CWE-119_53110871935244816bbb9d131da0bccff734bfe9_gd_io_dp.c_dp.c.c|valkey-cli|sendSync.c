unsigned long long sendSync(redisContext *c, int send_sync, char *out_eof, int *out_full_mode) {
    /* To start we need to send the SYNC command and return the payload.
     * The hiredis client lib does not understand this part of the protocol
     * and we don't want to mess with its buffers, so everything is performed
     * using direct low-level I/O. */
    char buf[4096], *p;
    ssize_t nread;
    if (out_full_mode) *out_full_mode = 1;
    if (send_sync) {
        /* Send the SYNC command. */
        if (cliWriteConn(c, "SYNC\r\n", 6) != 6) {
            fprintf(stderr,"Error writing to master\n");
            exit(1);
        }
    } else {
        /* We have written the command into c->obuf before. */
        if (cliWriteConn(c, "", 0) != 0) {
            fprintf(stderr,"Error writing to master\n");
            exit(1);
        }
    }
    /* Read $<payload>\r\n, making sure to read just up to "\n" */
    p = buf;
    while(1) {
        nread = readConn(c,p,1);
		if(nread == 0) {
            fprintf(stderr,"Error reading bulk length while SYNCing\n");
            exit(1);
        }
        if (*p == '\n' && p != buf) break;
        if (*p != '\n') p++;
        if (p >= buf + sizeof(buf) - 1) break; /* Go back one more char for null-term. */
    }
    *p = '\0';
    if (buf[0] == '-') {
        fprintf(stderr, "SYNC with master failed: %s\n", buf);
        exit(1);
    }
    /* Handling PSYNC responses.
     * Read +FULLRESYNC <replid> <offset>\r\n, after that is the $<payload> or the $EOF:<40 bytes delimiter>
     * Read +CONTINUE <replid>\r\n or +CONTINUE\r\n, after that is the command stream */
    if (!strncmp(buf, "+FULLRESYNC", 11) ||
        !strncmp(buf, "+CONTINUE", 9))
    {
        int sync_partial = !strncmp(buf, "+CONTINUE", 9);
        fprintf(stderr, "PSYNC replied %s\n", buf);
        p = buf;
        while(1) {
            nread = readConn(c,p,1);
            if (nread <= 0) {
                fprintf(stderr,"Error reading bulk length while PSYNCing\n");
                exit(1);
            }
            if (*p == '\n' && p != buf) break;
            if (*p != '\n') p++;
            if (p >= buf + sizeof(buf) - 1) break; /* Go back one more char for null-term. */
        }
        *p = '\0';
        if (sync_partial) {
            if (out_full_mode) *out_full_mode = 0;
            return 0;
        }
    }
    if (strncmp(buf+1,"EOF:",4) == 0 && strlen(buf+5) >= RDB_EOF_MARK_SIZE) {
        memcpy(out_eof, buf+5, RDB_EOF_MARK_SIZE);
        return 0;
    }
    return strtoull(buf+1,NULL,10);
}
