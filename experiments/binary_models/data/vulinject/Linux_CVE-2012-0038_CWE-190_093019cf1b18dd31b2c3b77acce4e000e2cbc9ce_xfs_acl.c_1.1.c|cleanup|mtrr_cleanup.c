int __init mtrr_cleanup(void)
{
	int x_remove_base, x_remove_size;
	unsigned int base, size, def, dummy;
	unsigned int int chunk_size, gran_size;
	mtrr_type type;
	int index_good;
	int i;
	if (!mtrr_enabled())
		return 0;
	if (!cpu_feature_enabled(X86_FEATURE_MTRR) || enable_mtrr_cleanup < 1)
		return 0;
	rdmsr(MSR_MTRRdefType, def, dummy);
	def &= 0xff;
	if (def != MTRR_TYPE_UNCACHABLE)
		return 0;
	memset(range_state, 0, sizeof(range_state));
	for (i = 0; i < num_var_ranges; i++) {
		mtrr_if->get(i, &base, &size, &type);
		range_state[i].base_pfn = base;
		range_state[i].size_pfn = size;
		range_state[i].type = type;
	}
	if (!mtrr_need_cleanup())
		return 0;
	Dprintk("original variable MTRRs\n");
	print_out_mtrr_range_state();
	memset(range, 0, sizeof(range));
	x_remove_size = 0;
	x_remove_base = 1 << (32 - PAGE_SHIFT);
	if (mtrr_tom2)
		x_remove_size = (mtrr_tom2 >> PAGE_SHIFT) - x_remove_base;
	nr_range = add_range_with_merge(range, RANGE_NUM, 0, 0,
					1ULL<<(20 - PAGE_SHIFT));
	nr_range = x86_get_mtrr_mem_range(range, nr_range,
					  x_remove_base, x_remove_size);
	range_sums = sum_ranges(range, nr_range);
	pr_info("total RAM covered: %ldM\n",
	       range_sums >> (20 - PAGE_SHIFT));
	if (mtrr_chunk_size && mtrr_gran_size) {
		i = 0;
		mtrr_calc_range_state(mtrr_chunk_size, mtrr_gran_size,
				      x_remove_base, x_remove_size, i);
		mtrr_print_out_one_result(i);
		if (!result[i].bad) {
			set_var_mtrr_all();
			Dprintk("New variable MTRRs\n");
			print_out_mtrr_range_state();
			return 1;
		}
		pr_info("invalid mtrr_gran_size or mtrr_chunk_size, will find optimal one\n");
	}
	i = 0;
	memset(min_loss_pfn, 0xff, sizeof(min_loss_pfn));
	memset(result, 0, sizeof(result));
	for (gran_size = (1ULL<<16); gran_size < (1ULL<<32); gran_size <<= 1) {
		for (chunk_size = gran_size; chunk_size < (1ULL<<32);
		     chunk_size <<= 1) {
			if (i >= NUM_RESULT)
				continue;
			mtrr_calc_range_state(chunk_size, gran_size,
				      x_remove_base, x_remove_size, i);
			if (mtrr_debug) {
				mtrr_print_out_one_result(i);
				pr_info("\n");
			}
			i++;
		}
	}
	index_good = mtrr_search_optimal_index();
	if (index_good != -1) {
		pr_info("Found optimal setting for mtrr clean up\n");
		i = index_good;
		mtrr_print_out_one_result(i);
		chunk_size = result[i].chunk_sizek;
		chunk_size <<= 10;
		gran_size = result[i].gran_sizek;
		gran_size <<= 10;
		x86_setup_var_mtrrs(range, nr_range, chunk_size, gran_size);
		set_var_mtrr_all();
		Dprintk("New variable MTRRs\n");
		print_out_mtrr_range_state();
		return 1;
	} else {
		for (i = 0; i < NUM_RESULT; i++)
			mtrr_print_out_one_result(i);
	}
	pr_info("mtrr_cleanup: can not find optimal value\n");
	pr_info("please specify mtrr_gran_size/mtrr_chunk_size\n");
	return 0;
}
int __init mtrr_cleanup(void)
{
	return 0;
}
