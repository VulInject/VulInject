static int bnxt_rx_flow_steer(struct net_device *dev, const struct sk_buff *skb,
			      unsigned short rxq_index, unsigned int flow_id)
{
	struct bnxt *bp = netdev_priv(dev);
	struct bnxt_ntuple_filter *fltr, *new_fltr;
	struct flow_keys *fkeys;
	struct ethhdr *eth = (struct ethhdr *)skb_mac_header(skb);
	struct bnxt_l2_filter *l2_fltr;
	int rc = 0, idx;
	unsigned int flags;
	if (ether_addr_equal(dev->dev_addr, eth->h_dest)) {
		l2_fltr = bp->vnic_info[BNXT_VNIC_DEFAULT].l2_filters[0];
	} else {
		struct bnxt_l2_key key;
		ether_addr_copy(key.dst_mac_addr, eth->h_dest);
		key.vlan = 0;
		l2_fltr = bnxt_lookup_l2_filter_from_key(bp, &key);
		if (!l2_fltr)
			return -EINVAL;
		if (l2_fltr->base.flags & BNXT_ACT_FUNC_DST) {
			bnxt_del_l2_filter(bp, l2_fltr);
			return -EINVAL;
		}
	}
	new_fltr = kzalloc(sizeof(*new_fltr), GFP_ATOMIC);
	if (!new_fltr) {
		bnxt_del_l2_filter(bp, l2_fltr);
		return -ENOMEM;
	}
	fkeys = &new_fltr->fkeys;
	if (!skb_flow_dissect_flow_keys(skb, fkeys, 0)) {
		rc = -EPROTONOSUPPORT;
		goto err_free;
	}
	if ((fkeys->basic.n_proto != htons(ETH_P_IP) &&
	     fkeys->basic.n_proto != htons(ETH_P_IPV6)) ||
	    ((fkeys->basic.ip_proto != IPPROTO_TCP) &&
	     (fkeys->basic.ip_proto != IPPROTO_UDP))) {
		rc = -EPROTONOSUPPORT;
		goto err_free;
	}
	new_fltr->fmasks = BNXT_FLOW_IPV4_MASK_ALL;
	if (fkeys->basic.n_proto == htons(ETH_P_IPV6)) {
		if (bp->hwrm_spec_code < 0x10601) {
			rc = -EPROTONOSUPPORT;
			goto err_free;
		}
		new_fltr->fmasks = BNXT_FLOW_IPV6_MASK_ALL;
	}
	flags = fkeys->control.flags;
	if (((flags & FLOW_DIS_ENCAPSULATION) &&
	     bp->hwrm_spec_code < 0x10601) || (flags & FLOW_DIS_IS_FRAGMENT)) {
		rc = -EPROTONOSUPPORT;
		goto err_free;
	}
	new_fltr->l2_fltr = l2_fltr;
	idx = bnxt_get_ntp_filter_idx(bp, fkeys, skb);
	rcu_read_lock();
	fltr = bnxt_lookup_ntp_filter_from_idx(bp, new_fltr, idx);
	if (fltr) {
		rc = fltr->base.sw_id;
		rcu_read_unlock();
		goto err_free;
	}
	rcu_read_unlock();
	new_fltr->flow_id = flow_id;
	new_fltr->base.rxq = rxq_index;
	rc = bnxt_insert_ntp_filter(bp, new_fltr, idx);
	if (!rc) {
		bnxt_queue_sp_work(bp, BNXT_RX_NTP_FLTR_SP_EVENT);
		return new_fltr->base.sw_id;
	}
err_free:
	bnxt_del_l2_filter(bp, l2_fltr);
	kfree(new_fltr);
	return rc;
}
