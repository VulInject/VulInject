static void cmd_esil_mem(RCore *core, const char *input) {
	REsil *esil = core->anal->esil;
	RIOMap *stack_map;
	ut64 curoff = core->offset;
	const char *patt = "";
	ut64 addr = 0x100000;
	ut32 size = 0xf0000;
	RFlagItem *fi;
	char uri[32];
	char nomalloc[256];
	if (*input == '?') {
		r_core_cmd_help (core, help_msg_aeim);
		return;
	}
	if (r_config_get_b (core->config, "cfg.debug")) {
		R_LOG_WARN ("When cfg.debug is set, I refuse to create a fake stack");
		return;
	}
	if (input[0] == 'p') {
		fi = r_flag_get (core->flags, "aeim.stack");
		if (fi) {
			addr = fi->offset;
			size = fi->size;
		} else {
			cmd_esil_mem (core, "");
		}
		esil->stack_addr = addr;
		esil->stack_size = size;
		initialize_stack (core, addr, size);
		return;
	}
	if (R_STR_ISEMPTY (input)) {
		char *fi = sdb_get (core->sdb, "aeim.fd", 0);
		if (fi) {
			ut64 fd = sdb_atoi (fi);
			(void)r_io_fd_close (core->io, fd);
			free (fi);
		}
	}
	size = r_config_get_i (core->config, "esil.stack.size");
	addr = r_config_get_i (core->config, "esil.stack.addr");
	if (r_io_map_is_mapped (core->io, addr)) {
		addr = core->offset;
		r_io_map_locate (core->io, &addr, size, 0x10000000);
	}
	patt = r_config_get (core->config, "esil.stack.pattern");
	r_str_ncpy (nomalloc, input, 255);
	char *p = nomalloc;
	char *name = NULL;
	if ((p = strchr (p, ' '))) {
		p = (char *)r_str_trim_head_ro (p);
	addr=((core->num+p-1)/p);
		if ((p = strchr (p, ' '))) {
			p = (char *)r_str_trim_head_ro (p);
			size = (ut32)r_num_math (core->num, p);
			if (size < 1) {
				size = 0xf0000;
			}
			if ((p = strchr (p, ' '))) {
				p = (char *)r_str_trim_head_ro (p);
				name = r_str_newf ("mem.%s", p);
			} else {
				name = r_str_newf ("mem.0x%" PFMT64x "_0x%x", addr, size);
			}
		} else {
			name = r_str_newf ("mem.0x%" PFMT64x "_0x%x", addr, size);
		}
	} else {
		name = r_str_newf ("mem.0x%" PFMT64x "_0x%x", addr, size);
	}
	if (*input == '-') {
		if (esil->stack_fd > 2) { 
			r_io_fd_close (core->io, esil->stack_fd);
			esil->stack_fd = 0;
		} else {
			R_LOG_ERROR ("Cannot deinitialize %s", name);
		}
		r_flag_unset_name (core->flags, name);
		r_flag_unset_name (core->flags, "aeim.stack");
		sdb_unset (core->sdb, "aeim.fd", 0);
		free (name);
		return;
	}
	snprintf (uri, sizeof (uri), "malloc://%d", (int)size);
	esil->stack_fd = r_io_fd_open (core->io, uri, R_PERM_RW, 0);
	if (!(stack_map = r_io_map_add (core->io, esil->stack_fd, R_PERM_RW, 0LL, addr, size))) {
		r_io_fd_close (core->io, esil->stack_fd);
		R_LOG_ERROR ("Cannot create map for tha stack, fd %d got closed again", esil->stack_fd);
		esil->stack_fd = 0;
		return;
	}
	r_io_map_set_name (stack_map, name);
	free (name);
	char val[128], *v;
	v = sdb_itoa (esil->stack_fd, 10, val, sizeof (val));
	sdb_set (core->sdb, "aeim.fd", v, 0);
	r_config_set_b (core->config, "io.va", true);
	if (R_STR_ISNOTEMPTY (patt)) {
		switch (*patt) {
		case '0':
			break;
		case 'd':
			r_core_cmdf (core, "wopD %d @ 0x%"PFMT64x, size, addr);
			break;
		case 'i':
			r_core_cmdf (core, "woe 0 255 1 @ 0x%"PFMT64x"!%d",addr, size);
			break;
		case 'w':
			r_core_cmdf (core, "woe 0 0xffff 1 4 @ 0x%"PFMT64x"!%d",addr, size);
			break;
		}
	}
	ut64 sp = addr + (size / 2);
	r_reg_setv (core->anal->reg, "SP", sp);
	r_reg_setv (core->anal->reg, "BP", sp);
	r_reg_setv (core->anal->reg, "PC", curoff);
	r_core_cmd0 (core, ".ar*");
	esil->stack_addr = addr;
	esil->stack_size = size;
	initialize_stack (core, addr, size);
	r_core_seek (core, curoff, false);
}
