dissect_eap_msauth_tlv(proto_tree *eap_tree, tvbuff_t *tvb, packet_info *pinfo, int offset, gint size)
{
  guint tlv_type, tlv_len;
  proto_tree *tlv_tree, *tree, *ti_len;
  tlv_tree = proto_tree_add_subtree(eap_tree, tvb, offset, size, ett_eap_msauth_tlv,
                                    NULL, "Tag Length Values");
next_tlv:
  tlv_type = tvb_get_guint16(tvb, offset, ENC_BIG_ENDIAN) & MSAUTH_TLV_TYPE;
  tlv_len = tvb_get_guint16(tvb, offset + 2, ENC_BIG_ENDIAN);
  tree = proto_tree_add_subtree_format(tlv_tree, tvb, offset, 4 + tlv_len,
                                       ett_eap_msauth_tlv_tree, NULL, "TLV: t=%s(%d) l=%d",
                                       val_to_str_const(tlv_type, eap_msauth_tlv_type_vals, "Unknown"),
                                       tlv_type, 4 + tlv_len);
  proto_tree_add_item(tree, hf_eap_msauth_tlv_mandatory, tvb, offset, 2, ENC_BIG_ENDIAN);
  proto_tree_add_item(tree, hf_eap_msauth_tlv_reserved, tvb, offset, 2, ENC_BIG_ENDIAN);
  proto_tree_add_item(tree, hf_eap_msauth_tlv_type, tvb, offset, 2, ENC_BIG_ENDIAN);
  offset += 2;
  proto_tree_add_item(tree, hf_eap_msauth_tlv_len, tvb, offset, 2, ENC_BIG_ENDIAN);
  offset += 2;
  switch (tlv_type) {
  case MSAUTH_TLV_TYPE_EXTENSION_RESULT:
    proto_tree_add_item(tree, hf_eap_msauth_tlv_status, tvb, offset, 2, ENC_BIG_ENDIAN);
    offset += 2;
    break;
  case MSAUTH_TLV_TYPE_EXTENSION_CRYPTOBINDING:
    proto_tree_add_item(tree, hf_eap_msauth_tlv_crypto_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_eap_msauth_tlv_crypto_version, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_eap_msauth_tlv_crypto_rcv_version, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_eap_msauth_tlv_crypto_subtype, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_eap_msauth_tlv_crypto_nonce, tvb, offset, 32, ENC_NA);
    offset += 32;
    proto_tree_add_item(tree, hf_eap_msauth_tlv_crypto_cmac, tvb, offset, 20, ENC_NA);
    offset += 20;
    break;
  default:
    ti_len = proto_tree_add_item(tree, hf_eap_msauth_tlv_val, tvb, offset, tlv_len, ENC_NA);
    if (4 + tlv_len > (guint)size - offset) {
      expert_add_info(pinfo, ti_len, &ei_eap_bad_length);
    }
    offset += tlv_len;
  }
  return offset;
}
