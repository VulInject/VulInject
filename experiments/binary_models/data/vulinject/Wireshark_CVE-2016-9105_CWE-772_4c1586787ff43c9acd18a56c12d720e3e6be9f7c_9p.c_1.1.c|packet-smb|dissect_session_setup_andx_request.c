dissect_session_setup_andx_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, proto_tree *smb_tree, smb_info_t *si)
{
	guint8      wc, cmd        = 0xff;
	guint16     bc;
	guint16     andxoffset     = 0;
	int         an_len;
	const char *an;
	int         dn_len;
	const char *dn;
	guint16     pwlen          = 0;
	guint16     sbloblen       = 0, sbloblen_short;
	guint16     apwlen         = 0, upwlen = 0;
	gboolean    unicodeflag;
	static int  ntlmssp_tap_id = 0;
	const ntlmssp_header_t *ntlmssph;
	if (!ntlmssp_tap_id) {
		GString *error_string;
		error_string = register_tap_listener("ntlmssp", NULL, NULL,
		    TL_IS_DISSECTOR_HELPER, NULL, NULL, NULL, NULL);
		if (!error_string) {
			ntlmssp_tap_id = find_tap_id("ntlmssp");
		} else {
		}
	}
	DISSECTOR_ASSERT(si);
	WORD_COUNT;
	cmd = tvb_get_guint8(tvb, offset);
	if (cmd != 0xff) {
		proto_tree_add_uint(tree, hf_smb_andxcmd, tvb, offset, 1, cmd);
	} else {
		proto_tree_add_uint_format_value(tree, hf_smb_andxcmd, tvb, offset, 1, cmd, "No further commands (0xff)");
	}
	offset += 1;
	proto_tree_add_item(tree, hf_smb_reserved, tvb, offset, 1, ENC_NA);
	offset += 1;
	andxoffset = tvb_get_letohs(tvb, offset);
	proto_tree_add_uint(tree, hf_smb_andxoffset, tvb, offset, 2, andxoffset);
	offset += 2;
	proto_tree_add_item(tree, hf_smb_max_buf_size, tvb, offset, 2, ENC_LITTLE_ENDIAN);
	offset += 2;
	proto_tree_add_item(tree, hf_smb_max_mpx_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
	offset += 2;
	proto_tree_add_item(tree, hf_smb_vc_num, tvb, offset, 2, ENC_LITTLE_ENDIAN);
	offset += 2;
	proto_tree_add_item(tree, hf_smb_session_key, tvb, offset, 4, ENC_LITTLE_ENDIAN);
	offset += 4;
	switch (wc) {
	case 10:
		pwlen = tvb_get_letohs(tvb, offset);
		proto_tree_add_uint(tree, hf_smb_password_len,
			tvb, offset, 2, pwlen);
		offset += 2;
		proto_tree_add_item(tree, hf_smb_reserved, tvb, offset, 4, ENC_NA);
		offset += 4;
		break;
	case 12:
		sbloblen = tvb_get_letohs(tvb, offset);
		proto_tree_add_uint(tree, hf_smb_security_blob_len, tvb, offset, 2, sbloblen);
		offset += 2;
		proto_tree_add_item(tree, hf_smb_reserved, tvb, offset, 4, ENC_NA);
		offset += 4;
		dissect_negprot_capabilities(tvb, tree, offset);
		offset += 4;
		break;
	case 13:
		apwlen = tvb_get_letohs(tvb, offset);
		proto_tree_add_uint(tree, hf_smb_ansi_password_len,
			tvb, offset, 2, apwlen);
		offset += 2;
		upwlen = tvb_get_letohs(tvb, offset);
		proto_tree_add_uint(tree, hf_smb_unicode_password_len,
			tvb, offset, 2, upwlen);
		offset += 2;
		proto_tree_add_item(tree, hf_smb_reserved, tvb, offset, 4, ENC_NA);
		offset += 4;
		dissect_negprot_capabilities(tvb, tree, offset);
		offset += 4;
		break;
	}
	BYTE_COUNT;
	if (wc == 12) {
		proto_item *blob_item;
		sbloblen_short = sbloblen;
		if (sbloblen_short > tvb_reported_length_remaining(tvb, offset)) {
			sbloblen_short = tvb_reported_length_remaining(tvb, offset);
		}
		blob_item = proto_tree_add_item(tree, hf_smb_security_blob,
						tvb, offset, sbloblen_short,
						ENC_NA);
		if (sbloblen) {
			tvbuff_t *blob_tvb;
			proto_tree *blob_tree;
			blob_tree = proto_item_add_subtree(blob_item,
							   ett_smb_secblob);
			CHECK_BYTE_COUNT(sbloblen);
			blob_tvb = tvb_new_subset_length_caplen(tvb, offset, sbloblen_short,
						  sbloblen);
			if (si && si->ct && si->ct->raw_ntlmssp &&
			    (tvb_strneql(tvb, offset, "NTLMSSP", 7) == 0)) {
			  call_dissector(ntlmssp_handle, blob_tvb, pinfo,
					 blob_tree);
			}
			else {
			  call_dissector(gssapi_handle, blob_tvb,
					 pinfo, blob_tree);
			}
			if (!pinfo->fd->visited && si->sip) {
				int idx = 0;
				if ((ntlmssph = (const ntlmssp_header_t *)fetch_tapped_data(ntlmssp_tap_id, idx + 1 )) != NULL) {
					if (ntlmssph && (ntlmssph->type == 3)) {
						smb_uid_t *smb_uid;
						smb_uid = wmem_new(wmem_file_scope(), smb_uid_t);
						smb_uid->logged_in  = -1;
						smb_uid->logged_out = -1;
						smb_uid->domain  = wmem_strdup(wmem_file_scope(), ntlmssph->domain_name);
						smb_uid->account = wmem_strdup(wmem_file_scope(), ntlmssph->acct_name);
						si->sip->extra_info = smb_uid;
						si->sip->extra_info_type = SMB_EI_UID;
					}
				}
			}
			COUNT_BYTES(sbloblen);
		}
		unicodeflag = si->unicode;
		if ( tvb_strneql(tvb, offset, "Win", 3) == 0 ) {
			unicodeflag = FALSE;
		}
		an = get_unicode_or_ascii_string(tvb, &offset,
			unicodeflag, &an_len, FALSE, FALSE, &bc);
		if (an == NULL)
			goto endofcommand;
		proto_tree_add_string(tree, hf_smb_os, tvb,
			offset, an_len, an);
		COUNT_BYTES(an_len);
		unicodeflag = si->unicode;
		if ( tvb_strneql(tvb, offset, "Win", 3) == 0 ) {
			unicodeflag = FALSE;
		}
		an = get_unicode_or_ascii_string(tvb, &offset,
			unicodeflag, &an_len, FALSE, FALSE, &bc);
		if (an == NULL)
			goto endofcommand;
		proto_tree_add_string(tree, hf_smb_lanman, tvb,
			offset, an_len, an);
		COUNT_BYTES(an_len);
		dn = get_unicode_or_ascii_string(tvb, &offset,
			si->unicode, &dn_len, FALSE, FALSE, &bc);
		if (dn == NULL)
			goto endofcommand;
		proto_tree_add_string(tree, hf_smb_primary_domain, tvb,
			offset, dn_len, dn);
		COUNT_BYTES(dn_len);
	} else {
		switch (wc) {
		case 10:
			if (pwlen) {
				CHECK_BYTE_COUNT(pwlen);
				proto_tree_add_item(tree, hf_smb_password,
					tvb, offset, pwlen, ENC_NA);
				COUNT_BYTES(pwlen);
			}
			break;
		case 13:
			if (apwlen) {
				CHECK_BYTE_COUNT(apwlen);
				proto_tree_add_item(tree, hf_smb_ansi_password,
					tvb, offset, apwlen, ENC_NA);
				COUNT_BYTES(apwlen);
			}
			if (upwlen) {
				proto_item *item;
				CHECK_BYTE_COUNT(upwlen);
				item = proto_tree_add_item(tree, hf_smb_unicode_password,
					tvb, offset, upwlen, ENC_NA);
				if (upwlen > 24) {
					proto_tree *subtree;
					subtree = proto_item_add_subtree(item, ett_smb_unicode_password);
					dissect_ntlmv2_response(tvb, pinfo, subtree, offset, upwlen);
				}
				COUNT_BYTES(upwlen);
			}
			break;
		}
		an = get_unicode_or_ascii_string(tvb, &offset,
			si->unicode, &an_len, FALSE, FALSE, &bc);
		if (an == NULL)
			goto endofcommand;
		proto_tree_add_string(tree, hf_smb_account, tvb, offset, an_len,
			an);
		COUNT_BYTES(an_len);
		dn = get_unicode_or_ascii_string(tvb, &offset,
			si->unicode, &dn_len, FALSE, FALSE, &bc);
		if (dn == NULL)
			goto endofcommand;
		proto_tree_add_string(tree, hf_smb_primary_domain, tvb,
			offset, dn_len, dn);
		COUNT_BYTES(dn_len);
		col_append_str(pinfo->cinfo, COL_INFO, ", User: ");
		if (!dn[0] && !an[0])
			col_append_str(pinfo->cinfo, COL_INFO, "anonymous");
		else
			col_append_fstr(pinfo->cinfo, COL_INFO,
					"%s\\%s",
					format_text(wmem_packet_scope(), (const guchar*)dn, strlen(dn)),
					format_text(wmem_packet_scope(), (const guchar*)an, strlen(an)));
		an = get_unicode_or_ascii_string(tvb, &offset,
			si->unicode, &an_len, FALSE, FALSE, &bc);
		if (an == NULL)
			goto endofcommand;
		proto_tree_add_string(tree, hf_smb_os, tvb,
			offset, an_len, an);
		COUNT_BYTES(an_len);
		an = get_unicode_or_ascii_string(tvb, &offset,
			si->unicode, &an_len, FALSE, FALSE, &bc);
		if (an == NULL)
			goto endofcommand;
		proto_tree_add_string(tree, hf_smb_lanman, tvb,
			offset, an_len, an);
		COUNT_BYTES(an_len);
	}
	END_OF_SMB
	if (cmd != 0xff) { 	
		if (andxoffset < offset) {
			THROW(ReportedBoundsError);
		}
		dissect_smb_command(tvb, pinfo, andxoffset, smb_tree, cmd, FALSE, si);
	}
	return offset;
}
