generate_key_or_iv(packet_info *pinfo, unsigned int id, tvbuff_t *salt_tvb, unsigned int iter,
		       const char *pw, unsigned int req_keylen, char * keybuf)
{
  int rc;
	int i, j;
  gcry_md_hd_t md;
  gcry_mpi_t num_b1 = NULL;
  size_t pwlen;
  char hash[20], buf_b[64], buf_i[128], *p;
  char *salt_p;
  int salt_size;
  size_t cur_keylen;
  size_t n;
  gcry_error_t	err;
  cur_keylen = 0;
  salt_size = tvb_captured_length(salt_tvb);
  salt_p = (char *)tvb_memdup(pinfo->pool, salt_tvb, 0, salt_size);
  if (pw == NULL)
    pwlen = 0;
  else
    pwlen = strlen(pw);
  if (pwlen > 63 / 2)
    {
      return FALSE;
    }
  p = buf_i;
  for (i = 0; i < 64; i++)
    *p++ = salt_p[i % salt_size];
  if (pw)
    {
      for (i = j = 0; i < 64; i += 2)
	{
	  *p++ = 0;
	  *p++ = pw[j];
	  if (++j > pwlen)	
	    j = 0;
	}
    }
  else
    memset (p, 0, 64);
  for (;;) {
      err = gcry_md_open(&md, GCRY_MD_SHA1, 0);
      if (gcry_err_code(err))
        {
          return FALSE;
        }
      for (i = 0; i < 64; i++)
        {
          unsigned char lid = id & 0xFF;
          gcry_md_write (md, &lid, 1);
	}
      gcry_md_write(md, buf_i, pw ? 128 : 64);
      gcry_md_final (md);
      memcpy (hash, gcry_md_read (md, 0), 20);
      gcry_md_close (md);
      for (i = 1; i < iter; i++)
        gcry_md_hash_buffer (GCRY_MD_SHA1, hash, hash, 20);
      for (i = 0; i < 20 && cur_keylen < req_keylen; i++)
        keybuf[cur_keylen++] = hash[i];
      if (cur_keylen == req_keylen)
      {
        gcry_mpi_release (num_b1);
        return TRUE;		
      }
      for (i = 0; i < 64; i++)
        buf_b[i] = hash[i % 20];
      n = 64;
      rc = gcry_mpi_scan (&num_b1, GCRYMPI_FMT_USG, buf_b, n, &n);
      if (rc != 0)
        {
          return FALSE;
        }
      gcry_mpi_add_ui (num_b1, num_b1, 1);
      for (i = 0; i < 128; i += 64)
        {
          gcry_mpi_t num_ij;
          n = 64;
          rc = gcry_mpi_scan (&num_ij, GCRYMPI_FMT_USG, buf_i + i, n, &n);
          if (rc != 0)
            {
              return FALSE;
            }
          gcry_mpi_add (num_ij, num_ij, num_b1);
          gcry_mpi_clear_highbit (num_ij, 64 * 8);
          n = 64;
          rc = gcry_mpi_print (GCRYMPI_FMT_USG, buf_i + i, n, &n, num_ij);
          if (rc != 0)
            {
              return FALSE;
            }
          gcry_mpi_release (num_ij);
        }
  }
}
