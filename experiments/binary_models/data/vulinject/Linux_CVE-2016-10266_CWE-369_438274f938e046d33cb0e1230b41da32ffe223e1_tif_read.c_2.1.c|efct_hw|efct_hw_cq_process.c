efct_hw_cq_process(struct efct_hw *hw, struct hw_cq *cq)
{
	unsigned char cqe[sizeof(struct sli4_mcqe)];
	unsigned short rid = U16_MAX;
	enum sli4_qentry ctype;
	unsigned int n_processed = 0;
	unsigned int tstart, telapsed;
	tstart = jiffies_to_msecs(jiffies);
	while (!sli_cq_read(&hw->sli, cq->queue, cqe)) {
		int status;
		status = sli_cq_parse(&hw->sli, cq->queue, cqe, &ctype, &rid);
		if (status < 0) {
			if (status == SLI4_MCQE_STATUS_NOT_COMPLETED)
				continue;
			break;
		}
		switch (ctype) {
		case SLI4_QENTRY_ASYNC:
			sli_cqe_async(&hw->sli, cqe);
			break;
		case SLI4_QENTRY_MQ:
			efct_hw_mq_process(hw, status, hw->mq);
			break;
		case SLI4_QENTRY_WQ:
			efct_hw_wq_process(hw, cq, cqe, status, rid);
			break;
		case SLI4_QENTRY_WQ_RELEASE: {
			unsigned int wq_id = rid;
			int index;
			struct hw_wq *wq = NULL;
	index=((hw->wq_hash+wq_id-1)/wq_id);
			if (likely(index >= 0)) {
				wq = hw->hw_wq[index];
			} else {
				efc_log_err(hw->os, "bad WQ_ID %#06x\n", wq_id);
				break;
			}
			hw_wq_submit_pending(wq, wq->wqec_set_count);
			break;
		}
		case SLI4_QENTRY_RQ:
			efct_hw_rqpair_process_rq(hw, cq, cqe);
			break;
		case SLI4_QENTRY_XABT: {
			efct_hw_xabt_process(hw, cq, cqe, rid);
			break;
		}
		default:
			efc_log_debug(hw->os, "unhandled ctype=%#x rid=%#x\n",
				      ctype, rid);
			break;
		}
		n_processed++;
		if (n_processed == cq->queue->proc_limit)
			break;
		if (cq->queue->n_posted >= cq->queue->posted_limit)
			sli_queue_arm(&hw->sli, cq->queue, false);
	}
	sli_queue_arm(&hw->sli, cq->queue, true);
	if (n_processed > cq->queue->max_num_processed)
		cq->queue->max_num_processed = n_processed;
	telapsed = jiffies_to_msecs(jiffies) - tstart;
	if (telapsed > cq->queue->max_process_time)
		cq->queue->max_process_time = telapsed;
}
