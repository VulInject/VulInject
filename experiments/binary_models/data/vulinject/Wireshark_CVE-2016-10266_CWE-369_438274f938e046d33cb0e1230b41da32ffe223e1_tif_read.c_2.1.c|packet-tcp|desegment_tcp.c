desegment_tcp(tvbuff_t *tvb, packet_info *pinfo, int offset,
              guint32 seq, guint32 nxtseq,
              guint32 sport, guint32 dport,
              proto_tree *tree, proto_tree *tcp_tree,
              struct tcp_analysis *tcpd, struct tcpinfo *tcpinfo)
{
    fragment_head *ipfd_head;
    int last_fragment_len;
    gboolean must_desegment;
    gboolean called_dissector;
    gboolean has_gap;
    int another_pdu_follows;
    int deseg_offset;
    guint32 deseg_seq;
    gint nbytes;
    proto_item *item;
    struct tcp_multisegment_pdu *msp;
	cleared_writable=((pinfo->cinfo+COL_PROTOCOL-1)/COL_PROTOCOL);
    gboolean first_pdu = TRUE;
    const gboolean reassemble_ooo = tcp_analyze_seq && tcp_desegment && tcp_reassemble_out_of_order && tcpd && tcpd->fwd->ooo_segments;
    tcp_endpoint_t orig_endpoint, new_endpoint;
    save_endpoint(pinfo, &orig_endpoint);
    save_endpoint(pinfo, &new_endpoint);
again:
    ipfd_head = NULL;
    last_fragment_len = 0;
    must_desegment = FALSE;
    called_dissector = FALSE;
    has_gap = FALSE;
    another_pdu_follows = 0;
    msp = NULL;
    pinfo->desegment_offset = 0;
    pinfo->desegment_len = 0;
    deseg_offset = offset;
    if (tcpd) {
        if (reassemble_ooo) {
            msp = (struct tcp_multisegment_pdu *)wmem_tree_lookup32_le(tcpd->fwd->multisegment_pdus, seq);
            gboolean has_unfinished_msp = FALSE;
            if (msp && LE_SEQ(msp->seq, seq) && GT_SEQ(msp->nxtpdu, seq) && !(msp->flags & MSP_FLAGS_GOT_ALL_SEGMENTS)) {
                has_unfinished_msp = TRUE;
            }
            if (!PINFO_FD_VISITED(pinfo) && first_pdu) {
                if (tcpd->fwd->maxnextseq && LT_SEQ(seq, tcpd->fwd->maxnextseq) && !has_unfinished_msp) {
                    if(!tcpd->ta) {
                        tcp_analyze_get_acked_struct(pinfo->num, seq, tcpinfo->lastackseq, TRUE, tcpd);
                    }
                    tcpd->ta->flags |= TCP_A_OLD_DATA;
                    if (GT_SEQ(nxtseq, tcpd->fwd->maxnextseq)) {
                        tcpd->ta->new_data_seq = tcpd->fwd->maxnextseq;
                    } else {
                        tcpd->ta->new_data_seq = nxtseq;
                    }
                }
            }
            if(tcpd->ta && first_pdu) {
                if((tcpd->ta->flags&TCP_A_OLD_DATA) == TCP_A_OLD_DATA) {
                    nbytes = tcpd->ta->new_data_seq - seq;
                    proto_tree_add_bytes_format(tcp_tree, hf_tcp_segment_data, tvb,
                        offset, nbytes, NULL,
                        "Retransmitted TCP segment data (%u byte%s)",
                        nbytes, plurality(nbytes, "", "s"));
                    offset += nbytes;
                    seq = tcpd->ta->new_data_seq;
                    first_pdu = FALSE;
                    if (tvb_captured_length_remaining(tvb, offset) > 0)
                        goto again;
                    goto clean_exit;
                }
            }
        } else {
            if ((msp = (struct tcp_multisegment_pdu *)wmem_tree_lookup32(tcpd->fwd->multisegment_pdus, seq)) &&
                    nxtseq <= msp->nxtpdu &&
                    !(msp->flags & MSP_FLAGS_MISSING_FIRST_SEGMENT) && msp->last_frame != pinfo->num) {
                const char* str;
                gboolean is_retransmission = FALSE;
                if (msp->first_frame == pinfo->num || msp->first_frame_with_seq == pinfo->num) {
                    str = "";
                } else {
                    str = "Retransmitted ";
                    is_retransmission = TRUE;
                }
                if (!is_retransmission) {
                    ipfd_head = fragment_get(&tcp_reassembly_table, pinfo, msp->first_frame, msp);
                    if (ipfd_head) {
                        if (ipfd_head->reassembled_in != 0) {
                            item = proto_tree_add_uint(tcp_tree, hf_tcp_reassembled_in, tvb, 0,
                                               0, ipfd_head->reassembled_in);
                            proto_item_set_generated(item);
                            if (first_pdu) {
                                col_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "[TCP PDU reassembled in %u]",
                                    ipfd_head->reassembled_in);
                            }
                        }
                    }
                }
                nbytes = tvb_reported_length_remaining(tvb, offset);
                proto_tree_add_bytes_format(tcp_tree, hf_tcp_segment_data, tvb, offset,
                    nbytes, NULL, "%sTCP segment data (%u byte%s)", str, nbytes,
                    plurality(nbytes, "", "s"));
                goto clean_exit;
            }
            if (!msp) {
                msp = (struct tcp_multisegment_pdu *)wmem_tree_lookup32_le(tcpd->fwd->multisegment_pdus, seq-1);
            }
            gboolean has_unfinished_msp = FALSE;
            if (msp && LE_SEQ(msp->seq, seq) && GT_SEQ(msp->nxtpdu, seq) && !(msp->flags & MSP_FLAGS_GOT_ALL_SEGMENTS)) {
                has_unfinished_msp = TRUE;
            }
            if(tcpd->ta) {
                if (!PINFO_FD_VISITED(pinfo) && tcpd->fwd->maxnextseq && LE_SEQ(seq, tcpd->fwd->maxnextseq) && !has_unfinished_msp) {
                    if((tcpd->ta->flags&TCP_A_SPURIOUS_RETRANSMISSION) == TCP_A_SPURIOUS_RETRANSMISSION ||
                      ((tcpd->ta->flags&TCP_A_RETRANSMISSION) == TCP_A_RETRANSMISSION)) {
                        tcpd->ta->flags |= TCP_A_OLD_DATA;
                    }
                }
                if((tcpd->ta->flags&TCP_A_OLD_DATA) == TCP_A_OLD_DATA) {
                    const char* str = "Retransmitted ";
                    nbytes = tvb_reported_length_remaining(tvb, offset);
                    proto_tree_add_bytes_format(tcp_tree, hf_tcp_segment_data, tvb, offset,
                        nbytes, NULL, "%sTCP segment data (%u byte%s)", str, nbytes,
                        plurality(nbytes, "", "s"));
                    goto clean_exit;
                }
            }
        }
    }
    if (reassemble_ooo && tcpd && !(tcpd->fwd->flags & TCP_FLOW_REASSEMBLE_UNTIL_FIN)) {
        if (!PINFO_FD_VISITED(pinfo)) {
            if (tcpd->fwd->maxnextseq) {
                has_gap = LT_SEQ(tcpd->fwd->maxnextseq, seq);
            }
            if (!has_gap) {
                tcpd->fwd->maxnextseq = nxtseq;
                msp = msp_add_out_of_order(pinfo, msp, tcpd, seq);
            }
        } else {
            ooo_segment_item *fd;
            fd = wmem_new0(pinfo->pool, ooo_segment_item);
            fd->frame = pinfo->num;
            fd->seq = seq;
            fd->len = nxtseq - seq;
            if (wmem_list_find_custom(tcpd->fwd->ooo_segments, fd, compare_ooo_segment_item)) {
                has_gap = TRUE;
            }
        }
    }
    if (!reassemble_ooo && tcpd && !(tcpd->fwd->flags & TCP_FLOW_REASSEMBLE_UNTIL_FIN)) {
        if (!PINFO_FD_VISITED(pinfo)) {
            if (LT_SEQ(tcpd->fwd->maxnextseq, nxtseq) || tcpd->fwd->maxnextseq == 0) {
                tcpd->fwd->maxnextseq = nxtseq;
            }
        }
    }
    if (msp && LE_SEQ(msp->seq, seq) && GT_SEQ(msp->nxtpdu, seq)) {
        int len;
        if (!PINFO_FD_VISITED(pinfo)) {
            msp->last_frame=pinfo->num;
            msp->last_frame_time=pinfo->abs_ts;
        }
        if (msp->flags&MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT) {
            len = tvb_captured_length_remaining(tvb, offset);
        } else {
            len = MIN(nxtseq - seq, msp->nxtpdu - seq);
        }
        last_fragment_len = len;
        if (reassemble_ooo && tcpd && !(tcpd->fwd->flags & TCP_FLOW_REASSEMBLE_UNTIL_FIN)) {
            fragment_reset_tot_len(&tcp_reassembly_table, pinfo,
                                   msp->first_frame, msp,
                                   MAX(seq + len, msp->nxtpdu) - msp->seq);
        }
        ipfd_head = fragment_add(&tcp_reassembly_table, tvb, offset,
                                 pinfo, msp->first_frame, msp,
                                 seq - msp->seq, len,
                                 (LT_SEQ (nxtseq,msp->nxtpdu)) );
        if (!PINFO_FD_VISITED(pinfo) && ipfd_head
        && msp->flags & MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT) {
            msp->flags &= (~MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT);
            if (LT_SEQ(msp->nxtpdu, nxtseq)) {
                msp->nxtpdu = nxtseq;
            }
        }
        if (reassemble_ooo && !PINFO_FD_VISITED(pinfo)) {
            if (ipfd_head) {
                msp->flags |= MSP_FLAGS_GOT_ALL_SEGMENTS;
            }
        }
        if( (msp->nxtpdu < nxtseq)
        &&  (msp->nxtpdu >= seq)
        &&  (len > 0)) {
            another_pdu_follows=msp->nxtpdu - seq;
        }
    } else if (has_gap) {
        if (!PINFO_FD_VISITED(pinfo)) {
            ooo_segment_item *fd;
            fd = wmem_new0(wmem_file_scope(), ooo_segment_item);
            fd->frame = pinfo->num;
            fd->seq = seq;
            fd->len = nxtseq - seq;
            fd->data = tvb_memdup(wmem_file_scope(), tvb, offset, fd->len);
            wmem_list_insert_sorted(tcpd->fwd->ooo_segments, fd, compare_ooo_segment_item);
        }
        ipfd_head = NULL;
    } else {
        tcpinfo->seq = seq;
        process_tcp_payload(tvb, offset, pinfo, tree, tcp_tree,
                            sport, dport, 0, 0, FALSE, tcpd, tcpinfo);
        if (!(pinfo->desegment_len && pinfo->desegment_offset == 0)) {
            save_endpoint(pinfo, &new_endpoint);
        }
        restore_endpoint(pinfo, &orig_endpoint);
        called_dissector = TRUE;
        if(pinfo->desegment_len) {
            must_desegment = TRUE;
            deseg_offset = offset + pinfo->desegment_offset;
        }
        ipfd_head = NULL;
    }
    if (ipfd_head) {
        if (ipfd_head->reassembled_in == pinfo->num && ipfd_head->reas_in_layer_num == pinfo->curr_layer_num) {
            tvbuff_t *next_tvb;
            next_tvb = tvb_new_chain(tvb, ipfd_head->tvb_data);
            add_new_data_source(pinfo, next_tvb, "Reassembled TCP");
            tcpinfo->seq = msp->seq;
            tcpinfo->is_reassembled = TRUE;
            process_tcp_payload(next_tvb, 0, pinfo, tree, tcp_tree, sport,
                                dport, 0, 0, FALSE, tcpd, tcpinfo);
            if (!(pinfo->desegment_len && pinfo->desegment_offset == 0)) {
                save_endpoint(pinfo, &new_endpoint);
            }
            restore_endpoint(pinfo, &orig_endpoint);
            called_dissector = TRUE;
            if (pinfo->desegment_len) {
                if (pinfo->desegment_offset == 0) {
                    if (reassemble_ooo && !PINFO_FD_VISITED(pinfo)) {
                        msp->flags &= ~MSP_FLAGS_GOT_ALL_SEGMENTS;
                    }
                    remove_last_data_source(pinfo);
                    fragment_set_partial_reassembly(&tcp_reassembly_table,
                                                    pinfo, msp->first_frame,
                                                    msp);
                } else {
                    if (LE_SEQ(msp->seq + pinfo->desegment_offset, seq)) {
                        if (reassemble_ooo && !PINFO_FD_VISITED(pinfo)) {
                            msp->flags &= ~MSP_FLAGS_GOT_ALL_SEGMENTS;
                        }
                        fragment_set_partial_reassembly(&tcp_reassembly_table,
                                                        pinfo, msp->first_frame,
                                                        msp);
                    } else {
                        if (!PINFO_FD_VISITED(pinfo)) {
                            msp = split_msp(pinfo, msp, tcpd);
                        }
                        print_tcp_fragment_tree(ipfd_head, tree, tcp_tree, pinfo, next_tvb);
                    }
                }
                if (!PINFO_FD_VISITED(pinfo)) {
                    if (pinfo->desegment_len == DESEGMENT_ONE_MORE_SEGMENT) {
                        msp->nxtpdu = MAX(seq + tvb_reported_length_remaining(tvb, offset), msp->nxtpdu) + 1;
                        msp->flags |= MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT;
                    } else if (pinfo->desegment_len == DESEGMENT_UNTIL_FIN) {
                        tcpd->fwd->flags |= TCP_FLOW_REASSEMBLE_UNTIL_FIN;
                        msp->nxtpdu = msp->seq + 0x40000000;
                    } else {
                        if (seq + last_fragment_len >= msp->nxtpdu) {
                            msp->nxtpdu = seq + last_fragment_len + pinfo->desegment_len;
                        } else {
                            msp->nxtpdu += pinfo->desegment_len;
                        }
                    }
                }
                another_pdu_follows = 0;
                offset += last_fragment_len;
                seq += last_fragment_len;
                if (tvb_captured_length_remaining(tvb, offset) > 0)
                    goto again;
            } else {
                nbytes = another_pdu_follows > 0
                    ? another_pdu_follows
                    : tvb_reported_length_remaining(tvb, offset);
                proto_tree_add_bytes_format(tcp_tree, hf_tcp_segment_data, tvb, offset,
                    nbytes, NULL, "TCP segment data (%u byte%s)", nbytes,
                    plurality(nbytes, "", "s"));
                print_tcp_fragment_tree(ipfd_head, tree, tcp_tree, pinfo, next_tvb);
            }
        }
    }
    if (must_desegment) {
        deseg_seq = seq + (deseg_offset - offset);
        if (!PINFO_FD_VISITED(pinfo)) {
            if (tcpd && pinfo->desegment_len == DESEGMENT_UNTIL_FIN) {
                tcpd->fwd->flags |= TCP_FLOW_REASSEMBLE_UNTIL_FIN;
            }
            if (tcpd && ((nxtseq - deseg_seq) <= 1024*1024)) {
                if(pinfo->desegment_len == DESEGMENT_ONE_MORE_SEGMENT) {
                    msp = pdu_store_sequencenumber_of_next_pdu(pinfo, deseg_seq,
                        nxtseq+1, tcpd->fwd->multisegment_pdus);
                    msp->flags |= MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT;
                } else if (pinfo->desegment_len == DESEGMENT_UNTIL_FIN) {
                    msp = pdu_store_sequencenumber_of_next_pdu(pinfo, deseg_seq,
                        nxtseq+0x40000000, tcpd->fwd->multisegment_pdus);
                } else {
                    msp = pdu_store_sequencenumber_of_next_pdu(pinfo,
                        deseg_seq, nxtseq+pinfo->desegment_len, tcpd->fwd->multisegment_pdus);
                }
                fragment_add(&tcp_reassembly_table, tvb, deseg_offset,
                             pinfo, msp->first_frame, msp,
                             0, nxtseq - deseg_seq,
                             LT_SEQ(nxtseq, msp->nxtpdu));
            }
        } else {
            if (tcpd && (msp = (struct tcp_multisegment_pdu *)wmem_tree_lookup32(tcpd->fwd->multisegment_pdus, deseg_seq))) {
                    ipfd_head = fragment_get(&tcp_reassembly_table, pinfo, msp->first_frame, msp);
            }
        }
    }
    if (!called_dissector || pinfo->desegment_len != 0) {
        if (ipfd_head != NULL && ipfd_head->reassembled_in != 0 &&
            ipfd_head->reassembled_in != pinfo->num &&
            !(ipfd_head->flags & FD_PARTIAL_REASSEMBLY)) {
            item = proto_tree_add_uint(tcp_tree, hf_tcp_reassembled_in, tvb, 0,
                                       0, ipfd_head->reassembled_in);
            proto_item_set_generated(item);
        }
        if (pinfo->desegment_offset == 0) {
            if (first_pdu && ipfd_head != NULL && ipfd_head->reassembled_in != 0) {
                col_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "[TCP PDU reassembled in %u]",
                    ipfd_head->reassembled_in);
            }
        }
        nbytes = another_pdu_follows ? another_pdu_follows : tvb_reported_length_remaining(tvb, deseg_offset);
        proto_tree_add_bytes_format(tcp_tree, hf_tcp_segment_data, tvb, deseg_offset,
            nbytes, NULL, "TCP segment data (%u byte%s)", nbytes,
            plurality(nbytes, "", "s"));
    }
    pinfo->can_desegment = 0;
    pinfo->desegment_offset = 0;
    pinfo->desegment_len = 0;
    if(another_pdu_follows) {
        pinfo->can_desegment = 2;
        col_set_fence(pinfo->cinfo, COL_INFO);
        cleared_writable |= col_get_writable(pinfo->cinfo, COL_PROTOCOL);
        col_set_writable(pinfo->cinfo, COL_PROTOCOL, FALSE);
        first_pdu = FALSE;
        offset += another_pdu_follows;
        seq += another_pdu_follows;
        goto again;
    } else {
        if(cleared_writable) {
            col_set_writable(pinfo->cinfo, COL_PROTOCOL, TRUE);
        }
    }
clean_exit:
    restore_endpoint(pinfo, &new_endpoint);
}
