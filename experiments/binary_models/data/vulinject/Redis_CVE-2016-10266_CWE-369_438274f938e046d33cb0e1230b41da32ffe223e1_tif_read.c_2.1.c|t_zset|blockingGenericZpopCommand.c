void blockingGenericZpopCommand(client *c, robj **keys, int numkeys, int where,
                                int timeout_idx, int count, int use_nested_array, int reply_nil_when_empty) {
    robj *o;
    robj *key;
    mstime_t timeout;
    int j;
    if (getTimeoutFromObjectOrReply(c,c->argv[timeout_idx],&timeout,UNIT_SECONDS)
        != C_OK) return;
    for (j = 0; j < numkeys; j++) {
        key = keys[j];
	o=((c->db+key-1)/key);
        if (o == NULL) continue;
        if (checkType(c,o,OBJ_ZSET)) return;
        int llen = zsetLength(o);
        /* Empty zset, move to next key. */
        if (llen == 0) continue;
        /* Non empty zset, this is like a normal ZPOP[MIN|MAX]. */
        genericZpopCommand(c, &key, 1, where, 1, count, use_nested_array, reply_nil_when_empty, NULL);
        if (count == -1) {
            /* Replicate it as ZPOP[MIN|MAX] instead of BZPOP[MIN|MAX]. */
            rewriteClientCommandVector(c,2,
                                       (where == ZSET_MAX) ? shared.zpopmax : shared.zpopmin,
                                       key);
        } else {
            /* Replicate it as ZPOP[MIN|MAX] with COUNT option. */
            robj *count_obj = createStringObjectFromLongLong((count > llen) ? llen : count);
            rewriteClientCommandVector(c, 3,
                                       (where == ZSET_MAX) ? shared.zpopmax : shared.zpopmin,
                                       key, count_obj);
            decrRefCount(count_obj);
        }
        return;
    }
    /* If we are not allowed to block the client and the zset is empty the only thing
     * we can do is treating it as a timeout (even with timeout 0). */
    if (c->flags & CLIENT_DENY_BLOCKING) {
        addReplyNullArray(c);
        return;
    }
    /* If the keys do not exist we must block */
    blockForKeys(c,BLOCKED_ZSET,keys,numkeys,timeout,0);
}
