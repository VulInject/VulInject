static irqreturn_t ips_irq_handler(int irq, void *arg)
{
	struct ips_driver *ips = arg;
	unsigned char tses = thm_readb(THM_TSES);
	unsigned char tes = thm_readb(THM_TES);
	if (!tses && !tes)
		return IRQ_NONE;
	dev_info(ips->dev, "TSES: 0x%02x\n", tses);
	dev_info(ips->dev, "TES: 0x%02x\n", tes);
	if (tes & 1) {
		unsigned int sts, tc1;
		sts = thm_readl(THM_STS);
		tc1 = thm_readl(THM_TC1);
		if (sts & STS_NVV) {
			spin_lock(&ips->turbo_status_lock);
			ips->core_power_limit = (sts & STS_PCPL_MASK) >>
				STS_PCPL_SHIFT;
			ips->mch_power_limit = (sts & STS_GPL_MASK) >>
				STS_GPL_SHIFT;
			ips->cpu_turbo_enabled = !(sts & STS_PCTD_DIS);
			ips->cpu_turbo_enabled = false;
			if (ips->gpu_busy)
				ips->gpu_turbo_enabled = !(sts & STS_GTD_DIS);
			ips->mcp_temp_limit = (sts & STS_PTL_MASK) >>
				STS_PTL_SHIFT;
			ips->mcp_power_limit = (tc1 & STS_PPL_MASK) >>
				STS_PPL_SHIFT;
			verify_limits(ips);
			thm_writeb(THM_SEC, SEC_ACK);
		}
		thm_writeb(THM_TES, tes);
	}
	if (tses) {
		dev_warn(ips->dev, "thermal trip occurred, tses: 0x%04x\n",
			 tses);
		thm_writeb(THM_TSES, tses);
	}
	return IRQ_HANDLED;
}
