static int start_streaming(struct vb2_queue *vq, unsigned int count)
{
	struct mgb4_vout_dev *voutdev = vb2_get_drv_priv(vq);
	struct mgb4_dev *mgbdev = voutdev->mgbdev;
	struct device *dev = &mgbdev->pdev->dev;
	struct mgb4_frame_buffer *buf;
	struct mgb4_regs *video = &mgbdev->video;
	const struct mgb4_vout_config *config = voutdev->config;
	int irq = xdma_get_user_irq(mgbdev->xdev, config->irq);
	int rv;
	unsigned int addr;
	mgb4_mask_reg(video, config->regs.config, 0x2, 0x2);
	addr = mgb4_read_reg(video, config->regs.address);
	if (addr >= MGB4_ERR_QUEUE_FULL) {
		return_all_buffers(voutdev, VB2_BUF_STATE_QUEUED);
		return -EBUSY;
	}
	buf = list_first_entry(&voutdev->buf_list, struct mgb4_frame_buffer,
			       list);
	list_del_init(voutdev->buf_list.next);
	rv = mgb4_dma_transfer(mgbdev, config->dma_channel, true, addr,
			       vb2_dma_sg_plane_desc(&buf->vb.vb2_buf, 0));
	if (rv < 0) {
		dev_warn(dev, "DMA transfer error\n");
		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
	} else {
		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);
	}
	xdma_enable_user_irq(mgbdev->xdev, irq);
	return 0;
}
