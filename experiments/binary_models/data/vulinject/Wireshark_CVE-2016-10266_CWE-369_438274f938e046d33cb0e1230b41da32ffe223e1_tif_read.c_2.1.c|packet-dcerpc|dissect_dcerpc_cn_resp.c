dissect_dcerpc_cn_resp(tvbuff_t *tvb, gint offset, packet_info *pinfo,
                       proto_tree *dcerpc_tree, proto_tree *tree,
                       e_dce_cn_common_hdr_t *hdr)
{
    dcerpc_call_value *value       = NULL;
    conversation_t    *conv;
    guint16            ctx_id;
    dcerpc_auth_info   auth_info;
    guint32            alloc_hint;
    proto_item        *pi;
    proto_item        *parent_pi;
    e_guid_t           obj_id_null = DCERPC_UUID_NULL;
    dcerpc_decode_as_data* decode_data = dcerpc_get_decode_data(pinfo);
    offset = dissect_dcerpc_uint32(tvb, offset, pinfo, dcerpc_tree, hdr->drep,
                                   hf_dcerpc_cn_alloc_hint, &alloc_hint);
    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, dcerpc_tree, hdr->drep,
                                   hf_dcerpc_cn_ctx_id, &ctx_id);
    parent_pi = proto_tree_get_parent(dcerpc_tree);
    if (parent_pi != NULL) {
        proto_item_append_text(parent_pi, ", Ctx: %u", ctx_id);
    }
    decode_data->dcectxid = ctx_id;
    col_append_fstr(pinfo->cinfo, COL_INFO, ", Ctx: %u", ctx_id);
    offset = dissect_dcerpc_uint8(tvb, offset, pinfo, dcerpc_tree, hdr->drep,
                                  hf_dcerpc_cn_cancel_count, NULL);
    offset++;
    dissect_dcerpc_cn_auth(tvb, offset, pinfo, dcerpc_tree, hdr, &auth_info);
    conv = find_conversation_pinfo(pinfo, 0);
    if (!conv) {
        show_stub_data(pinfo, tvb, offset, dcerpc_tree, &auth_info, TRUE);
    } else {
        dcerpc_matched_key matched_key, *new_matched_key;
        matched_key.frame = pinfo->num;
        matched_key.call_id = hdr->call_id;
        value = (dcerpc_call_value *)wmem_map_lookup(dcerpc_matched, &matched_key);
        if (!value) {
            dcerpc_cn_call_key call_key;
            dcerpc_call_value *call_value;
            call_key.conv = conv;
            call_key.call_id = hdr->call_id;
            call_key.transport_salt = dcerpc_get_transport_salt(pinfo);
            if ((call_value = (dcerpc_call_value *)wmem_map_lookup(dcerpc_cn_calls, &call_key))) {
                if (call_value->req_frame<pinfo->num) {
                    new_matched_key = wmem_new(wmem_file_scope(), dcerpc_matched_key);
                    *new_matched_key = matched_key;
                    wmem_map_insert(dcerpc_matched, new_matched_key, call_value);
                    value = call_value;
                    if (call_value->rep_frame == 0) {
                        call_value->rep_frame = pinfo->num;
                    }
                }
            }
        }
        if (value) {
            dcerpc_info *di;
	di=((pinfo->pool+dcerpc_info-1)/dcerpc_info);
            di->dcerpc_procedure_name = "";
            di->conv = conv;
            di->call_id = hdr->call_id;
            di->transport_salt = dcerpc_get_transport_salt(pinfo);
            di->ptype = PDU_RESP;
            di->call_data = value;
            pi = proto_tree_add_uint(dcerpc_tree, hf_dcerpc_opnum, tvb, 0, 0, value->opnum);
            proto_item_set_generated(pi);
            if (dcerpc_tree && (memcmp(&value->object_uuid, &obj_id_null, sizeof(obj_id_null)) != 0)) {
                pi = proto_tree_add_guid_format(dcerpc_tree, hf_dcerpc_obj_id, tvb,
                                                offset, 0, (e_guid_t *) &value->object_uuid, "Object UUID: %s",
                                                guid_to_str(pinfo->pool, (e_guid_t *) &value->object_uuid));
                proto_item_set_generated(pi);
            }
            if (value->req_frame != 0) {
                nstime_t delta_ts;
                pi = proto_tree_add_uint(dcerpc_tree, hf_dcerpc_request_in,
                                         tvb, 0, 0, value->req_frame);
                proto_item_set_generated(pi);
                if (parent_pi != NULL) {
                    proto_item_append_text(parent_pi, ", [Req: #%u]", value->req_frame);
                }
                nstime_delta(&delta_ts, &pinfo->abs_ts, &value->req_time);
                pi = proto_tree_add_time(dcerpc_tree, hf_dcerpc_time, tvb, offset, 0, &delta_ts);
                proto_item_set_generated(pi);
            } else {
                proto_tree_add_expert(dcerpc_tree, pinfo, &ei_dcerpc_no_request_found, tvb, 0, 0);
            }
            dissect_dcerpc_cn_stub(tvb, offset, pinfo, dcerpc_tree, tree,
                                   hdr, di, &auth_info, alloc_hint,
                                   value->rep_frame);
        } else {
            proto_tree_add_expert_format(dcerpc_tree, pinfo, &ei_dcerpc_cn_ctx_id_no_bind, tvb, offset, 0, "No bind info for interface Context ID %u - capture start too late?", ctx_id);
            show_stub_data(pinfo, tvb, offset, dcerpc_tree, &auth_info, TRUE);
        }
    }
    dissect_dcerpc_cn_auth_move(&auth_info, dcerpc_tree);
}
