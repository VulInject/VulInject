qla1280_isr(struct scsi_qla_host *ha, struct list_head *done_q)
{
	struct device_reg __iomem *reg = ha->iobase;
	struct response *pkt;
	struct srb *sp = NULL;
	unsigned short mailbox[MAILBOX_REGISTER_COUNT];
	unsigned short *wptr;
	unsigned int index;
	unsigned short istatus;
	ENTER("qla1280_isr");
	istatus = RD_REG_WORD(&reg->istatus);
	if (!(istatus & (RISC_INT | PCI_INT)))
		return;
	mailbox[5] = RD_REG_WORD(&reg->mailbox5);
	mailbox[0] = RD_REG_WORD_dmasync(&reg->semaphore);
	if (mailbox[0] & BIT_0) {
		wptr = &mailbox[0];
		*wptr++ = RD_REG_WORD(&reg->mailbox0);
		*wptr++ = RD_REG_WORD(&reg->mailbox1);
		*wptr = RD_REG_WORD(&reg->mailbox2);
		if (mailbox[0] != MBA_SCSI_COMPLETION) {
			wptr++;
			*wptr++ = RD_REG_WORD(&reg->mailbox3);
			*wptr++ = RD_REG_WORD(&reg->mailbox4);
			wptr++;
			*wptr++ = RD_REG_WORD(&reg->mailbox6);
			*wptr = RD_REG_WORD(&reg->mailbox7);
		}
		WRT_REG_WORD(&reg->semaphore, 0);
		WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
		dprintk(5, "qla1280_isr: mailbox interrupt mailbox[0] = 0x%x",
			mailbox[0]);
		switch (mailbox[0]) {
		case MBA_SCSI_COMPLETION:	
			dprintk(5, "qla1280_isr: mailbox SCSI response "
				"completion\n");
			if (ha->flags.online) {
				index = mailbox[2] << 16 | mailbox[1];
				if (index < MAX_OUTSTANDING_COMMANDS)
					sp = ha->outstanding_cmds[index];
				else
					sp = NULL;
				if (sp) {
					ha->outstanding_cmds[index] = NULL;
					CMD_RESULT(sp->cmd) = 0;
					CMD_HANDLE(sp->cmd) = COMPLETED_HANDLE;
					list_add_tail(&sp->list, done_q);
				} else {
					printk(KERN_WARNING
					       "qla1280: ISP invalid handle\n");
				}
			}
			break;
		case MBA_BUS_RESET:	
			ha->flags.reset_marker = 1;
			index = mailbox[6] & BIT_0;
			ha->bus_settings[index].reset_marker = 1;
			printk(KERN_DEBUG "qla1280_isr(): index %i "
			       "asynchronous BUS_RESET\n", index);
			break;
		case MBA_SYSTEM_ERR:	
			printk(KERN_WARNING
			       "qla1280: ISP System Error - mbx1=%xh, mbx2="
			       "%xh, mbx3=%xh\n", mailbox[1], mailbox[2],
			       mailbox[3]);
			break;
		case MBA_REQ_TRANSFER_ERR:	
			printk(KERN_WARNING
			       "qla1280: ISP Request Transfer Error\n");
			break;
		case MBA_RSP_TRANSFER_ERR:	
			printk(KERN_WARNING
			       "qla1280: ISP Response Transfer Error\n");
			break;
		case MBA_WAKEUP_THRES:	
			dprintk(2, "qla1280_isr: asynchronous WAKEUP_THRES\n");
			break;
		case MBA_TIMEOUT_RESET:	
			dprintk(2,
				"qla1280_isr: asynchronous TIMEOUT_RESET\n");
			break;
		case MBA_DEVICE_RESET:	
			printk(KERN_INFO "qla1280_isr(): asynchronous "
			       "BUS_DEVICE_RESET\n");
			ha->flags.reset_marker = 1;
			index = mailbox[6] & BIT_0;
			ha->bus_settings[index].reset_marker = 1;
			break;
		case MBA_BUS_MODE_CHANGE:
			dprintk(2,
				"qla1280_isr: asynchronous BUS_MODE_CHANGE\n");
			break;
		default:
			if (mailbox[0] < MBA_ASYNC_EVENT) {
				wptr = &mailbox[0];
				memcpy((unsigned short *) ha->mailbox_out, wptr,
				       MAILBOX_REGISTER_COUNT *
				       sizeof(unsigned short));
				if(ha->mailbox_wait != NULL)
			}
			break;
		}
	} else {
		WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
	}
	if (!(ha->flags.online && !ha->mailbox_wait)) {
		dprintk(2, "qla1280_isr: Response pointer Error\n");
		goto out;
	}
	if (mailbox[5] >= RESPONSE_ENTRY_CNT)
		goto out;
	while (ha->rsp_ring_index != mailbox[5]) {
		pkt = ha->response_ring_ptr;
		dprintk(5, "qla1280_isr: ha->rsp_ring_index = 0x%x, mailbox[5]"
			" = 0x%x\n", ha->rsp_ring_index, mailbox[5]);
		dprintk(5,"qla1280_isr: response packet data\n");
		qla1280_dump_buffer(5, (char *)pkt, RESPONSE_ENTRY_SIZE);
		if (pkt->entry_type == STATUS_TYPE) {
			if ((le16_to_cpu(pkt->scsi_status) & 0xff)
			    || pkt->comp_status || pkt->entry_status) {
				dprintk(2, "qla1280_isr: ha->rsp_ring_index = "
					"0x%x mailbox[5] = 0x%x, comp_status "
					"= 0x%x, scsi_status = 0x%x\n",
					ha->rsp_ring_index, mailbox[5],
					le16_to_cpu(pkt->comp_status),
					le16_to_cpu(pkt->scsi_status));
			}
		} else {
			dprintk(2, "qla1280_isr: ha->rsp_ring_index = "
				"0x%x, mailbox[5] = 0x%x\n",
				ha->rsp_ring_index, mailbox[5]);
			dprintk(2, "qla1280_isr: response packet data\n");
			qla1280_dump_buffer(2, (char *)pkt,
					    RESPONSE_ENTRY_SIZE);
		}
		if (pkt->entry_type == STATUS_TYPE || pkt->entry_status) {
			dprintk(2, "status: Cmd %p, handle %i\n",
				ha->outstanding_cmds[pkt->handle]->cmd,
				pkt->handle);
			if (pkt->entry_type == STATUS_TYPE)
				qla1280_status_entry(ha, pkt, done_q);
			else
				qla1280_error_entry(ha, pkt, done_q);
			ha->rsp_ring_index++;
			if (ha->rsp_ring_index == RESPONSE_ENTRY_CNT) {
				ha->rsp_ring_index = 0;
				ha->response_ring_ptr =	ha->response_ring;
			} else
				ha->response_ring_ptr++;
			WRT_REG_WORD(&reg->mailbox5, ha->rsp_ring_index);
		}
	}
 out:
	LEAVE("qla1280_isr");
}
