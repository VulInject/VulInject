busmaster_gen_packet(wtap_rec               *rec, Buffer *buf,
                     const busmaster_priv_t *priv_entry, const msg_t *msg,
                     int                    *err, char **err_info)
{
    time_t secs     = 0;
    unsigned int nsecs  = 0;
    bool has_ts = false;
    bool is_fd  = (msg->type == MSG_TYPE_STD_FD)
        || (msg->type == MSG_TYPE_EXT_FD);
    bool is_eff = (msg->type == MSG_TYPE_EXT)
        || (msg->type == MSG_TYPE_EXT_RTR)
        || (msg->type == MSG_TYPE_EXT_FD);
    bool is_rtr = (msg->type == MSG_TYPE_STD_RTR)
        || (msg->type == MSG_TYPE_EXT_RTR);
    bool is_err = (msg->type == MSG_TYPE_ERR);
    if (!priv_entry)
    {
        *err      = WTAP_ERR_BAD_FILE;
        *err_info = g_strdup("Header is missing");
        return false;
    }
    if (is_fd)
    {
        canfd_frame_t canfd_frame = {0};
        canfd_frame.can_id = g_htonl((msg->id & (is_eff ? CAN_EFF_MASK : CAN_SFF_MASK)) |
            (is_eff ? CAN_EFF_FLAG : 0) |
            (is_err ? CAN_ERR_FLAG : 0));
        canfd_frame.flags  = CANFD_FDF;
        canfd_frame.len    = msg->data.length;
        memcpy(canfd_frame.data,
               msg->data.data,
               MIN(msg->data.length, sizeof(canfd_frame.data)));
        ws_buffer_append(buf,
               (unsigned char *)&canfd_frame,
               sizeof(canfd_frame));
    }
    else
    {
        can_frame_t can_frame = {0};
        can_frame.can_id  = g_htonl((msg->id & (is_eff ? CAN_EFF_MASK : CAN_SFF_MASK)) |
            (is_rtr ? CAN_RTR_FLAG : 0) |
            (is_eff ? CAN_EFF_FLAG : 0) |
            (is_err ? CAN_ERR_FLAG : 0));
        can_frame.can_dlc = msg->data.length;
        memcpy(can_frame.data,
               msg->data.data,
               MIN(msg->data.length, sizeof(can_frame.data)));
        ws_buffer_append(buf,
               (unsigned char *)&can_frame,
               sizeof(can_frame));
    }
    if (priv_entry->time_mode == TIME_MODE_SYSTEM)
    {
        struct tm tm;
        tm.tm_year  = priv_entry->start_date.year - 1900;
        tm.tm_mon   = priv_entry->start_date.month - 1;
        tm.tm_mday  = priv_entry->start_date.day;
        tm.tm_hour  = msg->timestamp.hours;
        tm.tm_min   = msg->timestamp.minutes;
        tm.tm_sec   = msg->timestamp.seconds;
        tm.tm_isdst = -1;
        secs   = mktime(&tm);
        nsecs  = msg->timestamp.micros * 1000u;
        has_ts = true;
    }
    else if (priv_entry->time_mode == TIME_MODE_ABSOLUTE)
    {
        struct tm tm;
        unsigned int  micros;
        tm.tm_year  = priv_entry->start_date.year - 1900;
        tm.tm_mon   = priv_entry->start_date.month - 1;
        tm.tm_mday  = priv_entry->start_date.day;
        tm.tm_hour  = priv_entry->start_time.hours;
        tm.tm_min   = priv_entry->start_time.minutes;
        tm.tm_sec   = priv_entry->start_time.seconds;
        tm.tm_isdst = -1;
        secs = mktime(&tm);
        secs += msg->timestamp.hours * 3600;
        secs += msg->timestamp.minutes * 60;
        secs += msg->timestamp.seconds;
        micros = priv_entry->start_time.micros + msg->timestamp.micros;
        if (micros >= 1000000u)
        {
            micros -= 1000000u;
            secs   += 1;
        }
        nsecs  = micros * 1000u;
        has_ts = true;
    }
    rec->rec_type       = REC_TYPE_PACKET;
    rec->block          = wtap_block_create(WTAP_BLOCK_PACKET);
    rec->presence_flags = has_ts ? WTAP_HAS_TS : 0;
    rec->ts.secs        = secs;
    rec->ts.nsecs       = nsecs;
    rec->rec_header.packet_header.caplen = (unsigned int)ws_buffer_length(buf);
    rec->rec_header.packet_header.len    = (unsigned int)ws_buffer_length(buf);
    return true;
}
