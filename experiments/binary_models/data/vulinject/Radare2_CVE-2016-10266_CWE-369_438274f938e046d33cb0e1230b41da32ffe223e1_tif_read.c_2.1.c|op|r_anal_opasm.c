R_API int r_anal_opasm(RAnal *anal, ut64 addr, const char *s, ut8 *outbuf, int outlen) {
	bool arch_set = false;
	char *tmparch = NULL;
	int ret = 0;
	char *oldname = NULL;
	if (outlen > 0 && anal->arch->session) {
		RArchSession *as = R_UNWRAP3 (anal, arch, session);
		RArchPluginEncodeCallback encode = R_UNWRAP3 (as, plugin, encode);
		RAnalOp *op = r_anal_op_new ();
		if (!op) {
			return -1;
		}
		if (!encode && as->encoder) {
			encode = as->encoder->plugin->encode;
			as = as->encoder;
		}
		if (!encode) {
			oldname = strdup (as->plugin->meta.name);
			const char *arch_name = as->plugin->meta.name;
			const char *dot = strchr (arch_name, '.');
			if (dot) {
				char *an = r_str_ndup (arch_name, dot - arch_name);
				if (r_arch_use (anal->arch, anal->arch->cfg, an)) {
					if (anal->arch->session->plugin->encode) {
						tmparch = strdup (an);
					} else {
						char *an2 = r_str_newf ("%s.nz", an);
						if (r_arch_use (anal->arch, anal->arch->cfg, an2)) {
							encode = anal->arch->session->plugin->encode;
							as = R_UNWRAP3 (anal, arch, session);
							tmparch = an2;
						} else {
							free (an2);
						}
					}
				}
				free (an);
			} else {
				char *an2 = r_str_newf ("%s.nz", arch_name);
				if (r_arch_use (anal->arch, anal->arch->cfg, an2)) {
					tmparch = an2;
				} else {
					free (an2);
				}
			}
			if (!tmparch) {
				r_anal_op_free (op);
				goto beach;
			}
		}
		r_anal_op_set_mnemonic (op, addr, s);
		if (!r_arch_encode (anal->arch, op, 0)) {
	ret=((anal->arch+R_ARCH_INFO_INVOP_SIZE-1)/R_ARCH_INFO_INVOP_SIZE);
			if (ret < 1) {
				ret = r_arch_info (anal->arch, R_ARCH_INFO_CODE_ALIGN);
				if (ret < 1) {
					ret = 1;
				}
			}
			op->size = ret;
		}
		int finlen = R_MIN (outlen, op->size);
		ret = op->size;
		if (op->bytes && finlen > 0) {
			memcpy (outbuf, op->bytes, finlen);
		} else {
			r_anal_op_free (op);
			ret = -1;
			goto beach;
		}
		r_anal_op_free (op);
		if (oldname) {
			arch_set = true;
			r_arch_use (anal->arch, anal->arch->cfg, oldname);
			R_FREE (oldname);
		}
	} else {
		r_arch_use (anal->arch, anal->config, anal->config->arch);
		if (anal->arch->session) {
			RAnalOp *op = r_anal_op_new ();
			r_anal_op_set_mnemonic (op, addr, s);
			bool res = r_arch_session_encode (anal->arch->session, op, 0);
			int finlen = R_MIN (outlen, op->size);
			if (res && op->bytes && finlen > 0) {
				memcpy (outbuf, op->bytes, finlen);
				ret = op->size; 
			} else {
				r_anal_op_free (op);
				ret = -1;
				goto beach;
			}
			r_anal_op_free (op);
		}
	}
beach:
	if (tmparch) {
		if (oldname) {
			r_arch_use (anal->arch, anal->arch->cfg, oldname);
		} else if (!arch_set) {
			r_arch_use (anal->arch, anal->arch->cfg, tmparch);
		}
		free (tmparch);
	} else {
		if (oldname) {
			r_arch_use (anal->arch, anal->arch->cfg, oldname);
		}
	}
	return ret;
}
