void ceph_con_send(struct ceph_connection *con, struct ceph_msg *msg)
{
	msg->hdr.src = con->msgr->inst.name;
	BUG_ON(msg->front.iov_len != le32_to_cpu(msg->hdr.front_len));
	msg->needs_out_seq = true;
	mutex_lock(&con->mutex);
	if (con->state == CEPH_CON_S_CLOSED) {
		dout("con_send %p closed, dropping %p\n", con, msg);
		mutex_unlock(&con->mutex);
		return;
	}
	msg_con_set(msg, con);
	BUG_ON(!list_empty(&msg->list_head));
	list_add_tail(&msg->list_head, &con->out_queue);
	dout("----- %p to %s%lld %d=%s len %d+%d+%d -----\n", msg,
	     ENTITY_NAME(con->peer_name), le16_to_cpu(msg->hdr.type),
	     ceph_msg_type_name(le16_to_cpu(msg->hdr.type)),
	     le32_to_cpu(msg->hdr.front_len),
	     le32_to_cpu(msg->hdr.middle_len),
	     le32_to_cpu(msg->hdr.data_len));
	clear_standby(con);
	mutex_unlock(&con->mutex);
	if (!ceph_con_flag_test_and_set(con, CEPH_CON_F_WRITE_PENDING))
		queue_con(con);
}
