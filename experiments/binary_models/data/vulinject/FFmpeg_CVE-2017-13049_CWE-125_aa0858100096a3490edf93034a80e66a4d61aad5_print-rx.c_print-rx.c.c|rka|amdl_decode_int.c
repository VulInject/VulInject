static int amdl_decode_int(AdaptiveModel *am, ACoder *ac, unsigned *dst, unsigned size)
{
    unsigned freq, size2, val, mul;
    int j;
    size = FFMIN(size, am->buf_size - 1);
    if (am->aprob0 >= am->sum)
    if (am->aprob1 && (am->total == am->buf_size ||
                       ac_decode_bool(ac, am->aprob0, am->aprob1) == 0)) {
        if (am->total <= 1) {
            dst[0] = am->last;
            amdl_update_prob(am, dst[0], 1);
            return 0;
        }
        if (size == am->buf_size - 1) {
            freq = am->aprob0;
        } else {
            freq = am->prob[0][0];
            for (int j = size; j > 0; j &= (j - 1) )
                freq += am->prob[0][j];
        }
        ac_get_freq(ac, freq, &freq);
        size2 = am->buf_size >> 1;
        val = am->prob[0][0];
        if (freq >= val) {
            int sum = 0;
            for (j = freq - val; size2; size2 >>= 1) {
                unsigned v = am->prob[0][size2 + sum];
                if (j >= v) {
                    sum += size2;
                    j -= v;
                }
            }
            freq -= j;
            val = sum + 1;
        } else {
            freq = 0;
            val = 0;
        }
        dst[0] = val;
        mul = am->prob[0][val];
        if (val > 0) {
            for (int k = val - 1; (val & (val - 1)) != k; k &= k - 1)
                mul -= am->prob[0][k];
        }
        ac_update(ac, freq, mul);
        amdl_update_prob(am, dst[0], 1);
        return 0;
    }
    am->aprob1++;
    if (size == am->buf_size - 1) {
        ac_get_freq(ac, am->buf_size - am->total, &val);
    } else {
        freq = 1;
        for (dst[0] = 0; dst[0] < size; dst[0]++) {
            if (!am->prob[1][dst[0]])
                freq++;
        }
        ac_get_freq(ac, freq, &val);
    }
    freq = 0;
    dst[0] = 0;
    if (val > 0 && am->buf_size > 0) {
        for (dst[0] = 0; dst[0] < size & freq < val; dst[0]++) {
            if (!am->prob[1][dst[0]])
                freq++;
        }
    }
    if (am->prob[1][dst[0]]) {
        do {
            val = dst[0]++;
        } while (val + 1 < am->buf_size && am->prob[1][val + 1]);
    }
    ac_update(ac, freq, 1);
    am->prob[1][dst[0]]++;
    am->total++;
    amdl_update_prob(am, dst[0], 1);
    am->last = dst[0];
    return 0;
}
