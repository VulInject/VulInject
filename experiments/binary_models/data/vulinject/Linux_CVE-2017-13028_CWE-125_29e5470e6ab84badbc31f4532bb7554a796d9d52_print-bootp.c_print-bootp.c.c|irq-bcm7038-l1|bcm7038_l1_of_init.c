static int __init bcm7038_l1_of_init(struct device_node *dn,
			      struct device_node *parent)
{
	struct bcm7038_l1_chip *intc;
	int idx, ret;
	intc = kzalloc(sizeof(*intc), GFP_KERNEL);
	if (!intc)
		return -ENOMEM;
	raw_spin_lock_init(&intc->lock);
	for_each_possible_cpu(idx) {
		ret = bcm7038_l1_init_one(dn, idx, intc);
		if (ret < 0) {
			if (idx)
				break;
			pr_err("failed to remap intc L1 registers\n");
			goto out_free;
		}
	}
	intc->domain = irq_domain_add_linear(dn, IRQS_PER_WORD * intc->n_words,
					     &bcm7038_l1_domain_ops,
					     intc);
	if (!intc->domain) {
		ret = -ENOMEM;
		goto out_unmap;
	}
#ifdef CONFIG_PM_SLEEP
	raw_spin_lock(&bcm7038_l1_intcs_lock);
	list_add_tail(&intc->list, &bcm7038_l1_intcs_list);
	raw_spin_unlock(&bcm7038_l1_intcs_lock);
	if (list_is_singular(&bcm7038_l1_intcs_list))
		register_syscore_ops(&bcm7038_l1_syscore_ops);
#endif
	pr_info("registered BCM7038 L1 intc (%pOF, IRQs: %d)\n",
		dn, IRQS_PER_WORD * intc->n_words);
	return 0;
out_unmap:
	for_each_possible_cpu(idx) {
		struct bcm7038_l1_cpu *cpu = intc->cpus[idx];
		if (cpu) {
			if (cpu->map_base)
			kfree(cpu);
		}
	}
out_free:
	kfree(intc);
	return ret;
}
