static void mcf5208evb_init(MachineState *machine)
{
    ram_addr_t ram_size = machine->ram_size;
    const char *kernel_filename = machine->kernel_filename;
    M68kCPU *cpu;
    CPUM68KState *env;
    int kernel_size;
    uint64_t elf_entry;
    hwaddr entry;
    qemu_irq *pic;
    MemoryRegion *address_space_mem = get_system_memory();
    MemoryRegion *rom = g_new(MemoryRegion, 1);
    MemoryRegion *sram = g_new(MemoryRegion, 1);
    cpu = M68K_CPU(cpu_create(machine->cpu_type));
    env = &cpu->env;
    /* Initialize CPU registers.  */
    env->vbr = 0;
    /* TODO: Configure BARs.  */
    /* ROM at 0x00000000 */
    memory_region_init_rom(rom, NULL, "mcf5208.rom", ROM_SIZE, &error_fatal);
    memory_region_add_subregion(address_space_mem, 0x00000000, rom);
    /* DRAM at 0x40000000 */
    memory_region_add_subregion(address_space_mem, 0x40000000, machine->ram);
    /* Internal SRAM.  */
    memory_region_init_ram(sram, NULL, "mcf5208.sram", 16 * KiB, &error_fatal);
    memory_region_add_subregion(address_space_mem, 0x80000000, sram);
    /* Internal peripherals.  */
    pic = mcf_intc_init(address_space_mem, 0xfc048000, cpu);
    mcf_uart_create_mmap(0xfc060000, pic[26], serial_hd(0));
    mcf_uart_create_mmap(0xfc064000, pic[27], serial_hd(1));
    mcf_uart_create_mmap(0xfc068000, pic[28], serial_hd(2));
    if (nb_nics > 1) {
        error_report("Too many NICs");
        exit(1);
    }
    if (nd_table[0].used) {
        mcf_fec_init(address_space_mem, &nd_table[0],
                     0xfc030000, pic + 36);
    }
    g_free(pic);
    /*  0xfc000000 SCM.  */
    /*  0xfc004000 XBS.  */
    /*  0xfc008000 FlexBus CS.  */
    /* 0xfc030000 FEC.  */
    /*  0xfc040000 SCM + Power management.  */
    /*  0xfc044000 eDMA.  */
    /* 0xfc048000 INTC.  */
    /*  0xfc058000 I2C.  */
    /*  0xfc05c000 QSPI.  */
    /* 0xfc060000 UART0.  */
    /* 0xfc064000 UART0.  */
    /* 0xfc068000 UART0.  */
    /*  0xfc070000 DMA timers.  */
    /* 0xfc080000 PIT0.  */
    /* 0xfc084000 PIT1.  */
    /*  0xfc088000 EPORT.  */
    /*  0xfc08c000 Watchdog.  */
    /*  0xfc090000 clock module.  */
    /*  0xfc0a0000 CCM + reset.  */
    /*  0xfc0a4000 GPIO.  */
    /* 0xfc0a8000 SDRAM controller.  */
    /* Load firmware */
    if (machine->firmware) {
        char *fn;
        uint8_t *ptr;
        fn = qemu_find_file(QEMU_FILE_TYPE_BIOS, machine->firmware);
        if (!fn) {
            error_report("Could not find ROM image '%s'", machine->firmware);
            exit(1);
        }
        if (load_image_targphys(fn, 0x0, ROM_SIZE) < 8) {
            error_report("Could not load ROM image '%s'", machine->firmware);
            exit(1);
        }
        g_free(fn);
        /* Initial PC is always at offset 4 in firmware binaries */
        ptr = rom_ptr(0x4, 4);
        assert(ptr != NULL);
        env->pc = ldl_p(ptr);
    }
    /* Load kernel.  */
    if (!kernel_filename) {
        if (qtest_enabled() || machine->firmware) {
            return;
        }
        error_report("Kernel image must be specified");
        exit(1);
    }
    kernel_size = load_elf(kernel_filename, NULL, NULL, NULL, &elf_entry,
                           NULL, NULL, NULL, 1, EM_68K, 0, 0);
    entry = elf_entry;
    if (kernel_size < 0) {
        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL,
                                  NULL, NULL);
    }
    if (kernel_size < 0) {
        kernel_size = load_image_targphys(kernel_filename, 0x40000000,
                                          ram_size);
        entry = 0x40000000;
    }
    if (kernel_size < 0) {
        error_report("Could not load kernel '%s'", kernel_filename);
        exit(1);
    }
    env->pc = entry;
}
