dissect_ber_sequence(bool implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, const ber_sequence_t *seq, gint hf_id, gint ett_id) {
    gint8       classx;
    bool    pcx, ind   = 0, ind_field, imp_tag = FALSE;
    gint32      tagx;
    int         identifier_offset;
    int         identifier_len;
    guint32     lenx;
    proto_tree *tree       = parent_tree;
    proto_item *item       = NULL;
    proto_item *cause;
    int         end_offset = 0;
    int         hoffset;
    tvbuff_t   *next_tvb;
#ifdef DEBUG_BER
{
const char *name;
header_field_info *hfinfo;
if (hf_id > 0) {
hfinfo = proto_registrar_get_nth(hf_id);
name = hfinfo->name;
} else {
name = "unnamed";
}
if (tvb_reported_length_remaining(tvb, offset) > 3) {
proto_tree_add_debug_text(tree, "SEQUENCE dissect_ber_sequence(%s) entered offset:%d len:%d %02x:%02x:%02x\n", name, offset, tvb_reported_length_remaining(tvb, offset), tvb_get_guint8(tvb, offset), tvb_get_guint8(tvb, offset+1), tvb_get_guint8(tvb, offset+2));
} else {
proto_tree_add_debug_text(tree, "SEQUENCE dissect_ber_sequence(%s) entered\n", name);
}
}
#endif
    hoffset = offset;
    if (!implicit_tag) {
        offset = get_ber_identifier(tvb, offset, NULL, NULL, NULL);
        offset = get_ber_length(tvb, offset, &lenx, NULL);
    } else {
        lenx = tvb_reported_length_remaining(tvb, offset);
        end_offset = offset+lenx;
    }
    if (hf_id > 0) {
        if (parent_tree) {
            item = proto_tree_add_item(parent_tree, hf_id, tvb, hoffset, lenx + offset - hoffset, ENC_BIG_ENDIAN);
            tree = proto_item_add_subtree(item, ett_id);
        }
    }
    offset = hoffset;
    if (!implicit_tag) {
        identifier_offset = offset;
        offset = dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &classx, &pcx, &tagx);
        identifier_len = offset - identifier_offset;
        offset = dissect_ber_length(actx->pinfo, tree, tvb, offset, &lenx, &ind);
        if (ind) {
          end_offset = offset + lenx -2;
        } else {
          end_offset = offset + lenx;
        }
        if ((classx != BER_CLASS_APP) && (classx != BER_CLASS_PRI)) {
            if (!pcx
             || ((classx != BER_CLASS_UNI) || (tagx != BER_UNI_TAG_SEQUENCE))) {
                tvb_ensure_bytes_exist(tvb, hoffset, 2);
                cause = proto_tree_add_expert_format(
                    tree, actx->pinfo, &ei_ber_expected_sequence,
                    tvb, identifier_offset, identifier_len,
                    "BER Error: Sequence expected but class:%s(%d) %s tag:%d was unexpected",
                    val_to_str_const(classx, ber_class_codes, "Unknown"),
                    classx,
                    tfs_get_string(pcx, &tfs_constructed_primitive),
                    tagx);
                if (decode_unexpected) {
                    proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);
                    dissect_unknown_ber(actx->pinfo, tvb, hoffset, unknown_tree);
                }
                return end_offset;
            }
        }
    }
    if(offset == end_offset){
        proto_item_append_text(item, " [0 length]");
    }
    while (offset < end_offset) {
        gint8    ber_class;
        bool pc;
        gint32   tag;
        guint32  len;
        int      eoffset, count;
            if ((tvb_get_guint8(tvb, offset) == 0) && (tvb_get_guint8(tvb, offset+1) == 0)) {
                offset = dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &ber_class, &pc, &tag);
                dissect_ber_length(actx->pinfo, tree, tvb, offset, &len, &ind);
                proto_item_append_text(item, " 0 items");
                return end_offset;
            }
        hoffset = offset;
        offset = get_ber_identifier(tvb, offset, &ber_class, &pc, &tag);
        offset = get_ber_length(tvb, offset, &len, &ind_field);
        eoffset = offset + len;
        if (eoffset <= hoffset)
            THROW(ReportedBoundsError);
ber_sequence_try_again:
        if (!seq->func) {
            offset = dissect_ber_identifier(actx->pinfo, tree, tvb, hoffset, NULL, NULL, NULL);
            offset = dissect_ber_length(actx->pinfo, tree, tvb, offset, &len, NULL);
            cause = proto_tree_add_expert_format(
                tree, actx->pinfo, &ei_ber_unknown_field_sequence,
                tvb, hoffset, ((offset - hoffset) + len),
                "BER Error: This field lies beyond the end of the known sequence definition.");
            if (decode_unexpected) {
                proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);
                dissect_unknown_ber(actx->pinfo, tvb, hoffset, unknown_tree);
            }
            offset = eoffset;
            continue;
        }
        if ( ((seq->ber_class == BER_CLASS_CON) || (seq->ber_class == BER_CLASS_APP) || (seq->ber_class == BER_CLASS_PRI))
          && (!(seq->flags & BER_FLAGS_NOOWNTAG)) ) {
            if ( (seq->ber_class != BER_CLASS_ANY)
             &&  (seq->tag != -1)
             &&  ( (seq->ber_class != ber_class)
                || (seq->tag != tag) ) ) {
                if (seq->flags & BER_FLAGS_OPTIONAL) {
                    seq++;
                    goto ber_sequence_try_again;
                }
                identifier_offset = hoffset;
                offset = dissect_ber_identifier(actx->pinfo, tree, tvb, hoffset, NULL, NULL, NULL);
                identifier_len = offset - identifier_offset;
                dissect_ber_length(actx->pinfo, tree, tvb, offset, NULL, NULL);
                if (seq->ber_class == BER_CLASS_UNI) {
                    cause = proto_tree_add_expert_format(
                        tree, actx->pinfo, &ei_ber_sequence_field_wrong,
                        tvb, identifier_offset, identifier_len,
                        "BER Error: Wrong field in SEQUENCE: expected class:%s(%d) tag:%d (%s) but found class:%s(%d) tag:%d",
                        val_to_str_const(seq->ber_class, ber_class_codes, "Unknown"),
                        seq->ber_class,
                        seq->tag,
                        val_to_str_ext_const(seq->tag, &ber_uni_tag_codes_ext, "Unknown"),
                        val_to_str_const(ber_class, ber_class_codes, "Unknown"),
                        ber_class,
                        tag);
                } else {
                    cause = proto_tree_add_expert_format(
                        tree, actx->pinfo, &ei_ber_sequence_field_wrong,
                        tvb, identifier_offset, identifier_len,
                        "BER Error: Wrong field in SEQUENCE: expected class:%s(%d) tag:%d but found class:%s(%d) tag:%d",
                        val_to_str_const(seq->ber_class, ber_class_codes, "Unknown"),
                        seq->ber_class,
                        seq->tag,
                        val_to_str_const(ber_class, ber_class_codes, "Unknown"),
                        ber_class,
                        tag);
                }
                if (decode_unexpected) {
                    proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);
                    dissect_unknown_ber(actx->pinfo, tvb, hoffset, unknown_tree);
                }
                seq++;
                offset = eoffset;
                continue;
            }
        } else if (!(seq->flags & BER_FLAGS_NOTCHKTAG)) {
            if ( (seq->ber_class != BER_CLASS_ANY)
              && (seq->tag != -1)
              && ( (seq->ber_class != ber_class)
                || (seq->tag != tag) ) ) {
                if (seq->flags & BER_FLAGS_OPTIONAL) {
                    seq++;
                    goto ber_sequence_try_again;
                }
                identifier_offset = hoffset;
                offset = dissect_ber_identifier(actx->pinfo, tree, tvb, hoffset, NULL, NULL, NULL);
                identifier_len = offset - identifier_offset;
                dissect_ber_length(actx->pinfo, tree, tvb, offset, NULL, NULL);
                if ( seq->ber_class == BER_CLASS_UNI) {
                    cause = proto_tree_add_expert_format(
                        tree, actx->pinfo, &ei_ber_sequence_field_wrong,
                        tvb, identifier_offset, identifier_len,
                        "BER Error: Wrong field in SEQUENCE: expected class:%s(%d) tag:%d(%s) but found class:%s(%d) tag:%d",
                        val_to_str_const(seq->ber_class, ber_class_codes, "Unknown"),
                        seq->ber_class,
                        seq->tag,
                        val_to_str_ext_const(seq->tag, &ber_uni_tag_codes_ext, "Unknown"),
                        val_to_str_const(ber_class, ber_class_codes, "Unknown"),
                        ber_class, tag);
                } else {
                    cause = proto_tree_add_expert_format(
                        tree, actx->pinfo, &ei_ber_sequence_field_wrong,
                        tvb, identifier_offset, identifier_len,
                        "BER Error: Wrong field in SEQUENCE: expected class:%s(%d) tag:%d but found class:%s(%d) tag:%d",
                        val_to_str_const(seq->ber_class, ber_class_codes, "Unknown"),
                        seq->ber_class,
                        seq->tag,
                        val_to_str_const(ber_class, ber_class_codes, "Unknown"),
                        ber_class,
                        tag);
                }
                if (decode_unexpected) {
                    proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);
                    dissect_unknown_ber(actx->pinfo, tvb, hoffset, unknown_tree);
                }
                seq++;
                offset = eoffset;
                continue;
            }
        }
        if (!(seq->flags & BER_FLAGS_NOOWNTAG) ) {
            if (ind_field && (len == 2)) {
                next_tvb = ber_tvb_new_subset_length(tvb, offset, len);
                hoffset = eoffset;
            } else {
                hoffset = dissect_ber_identifier(actx->pinfo, tree, tvb, hoffset, NULL, NULL, NULL);
                hoffset = dissect_ber_length(actx->pinfo, tree, tvb, hoffset, NULL, NULL);
                next_tvb = ber_tvb_new_subset_length(tvb, hoffset, eoffset - hoffset - (2 * ind_field));
            }
        } else {
            next_tvb = ber_tvb_new_subset_length(tvb, hoffset, eoffset - hoffset);
        }
#if 0
        if ((eoffset-hoffset) > length_remaining) {
            next_tvb = tvb_new_subset_remaining(tvb, hoffset);
        } else {
        }
#endif
#ifdef DEBUG_BER
{
const char *name;
header_field_info *hfinfo;
if (hf_id > 0) {
hfinfo = proto_registrar_get_nth(hf_id);
name = hfinfo->name;
} else {
name = "unnamed";
}
if (tvb_reported_length_remaining(next_tvb, 0) > 3) {
proto_tree_add_debug_text(tree, "SEQUENCE dissect_ber_sequence(%s) calling subdissector offset:%d len:%d %02x:%02x:%02x\n", name, offset, tvb_reported_length_remaining(next_tvb, 0), tvb_get_guint8(next_tvb, 0), tvb_get_guint8(next_tvb, 1), tvb_get_guint8(next_tvb, 2));
} else {
proto_tree_add_debug_text(tree, "SEQUENCE dissect_ber_sequence(%s) calling subdissector\n", name);
}
}
#endif
        imp_tag = FALSE;
        if (seq->flags & BER_FLAGS_IMPLTAG) {
            imp_tag = TRUE;
        }
        count = seq->func(imp_tag, next_tvb, 0, actx, tree, *seq->p_id);
#ifdef DEBUG_BER
{
const char *name;
header_field_info *hfinfo;
if (hf_id > 0) {
hfinfo = proto_registrar_get_nth(hf_id);
name = hfinfo->name;
} else {
name = "unnamed";
}
proto_tree_add_debug_text(tree, "SEQUENCE dissect_ber_sequence(%s) subdissector ate %d bytes\n", name, count);
}
#endif
        if ((len != 0) && (count == 0) && (seq->flags & BER_FLAGS_OPTIONAL)) {
            seq++;
            goto ber_sequence_try_again;
        }
        offset = eoffset;
        if (!(seq->flags & BER_FLAGS_NOOWNTAG) ) {
            if ((ind_field == 1) && (len > 2))
            {
                if (show_internal_ber_fields) {
                    proto_tree_add_item(tree, hf_ber_seq_field_eoc, tvb, offset-2, 2, ENC_NA);
                }
            }
        }
        seq++;
    }
    if (offset != end_offset) {
        tvb_ensure_bytes_exist(tvb, offset-2, 2);
        proto_tree_add_expert_format(
            tree, actx->pinfo, &ei_ber_error_length, tvb, offset-2, 2,
            "BER Error: SEQUENCE is %d too many bytes int",
            offset - end_offset);
    }
    if (ind) {
        end_offset += 2;
        if (show_internal_ber_fields) {
            proto_tree_add_item(tree, hf_ber_seq_eoc, tvb, end_offset-2, 2, ENC_NA);
        }
    }
    return end_offset;
}
