static void handle_reply(struct ceph_mds_session *session, struct ceph_msg *msg)
{
	struct ceph_mds_client *mdsc = session->s_mdsc;
	struct ceph_client *cl = mdsc->fsc->client;
	struct ceph_mds_request *req;
	struct ceph_mds_reply_head *head = msg->front.iov_base;
	struct ceph_mds_reply_info_parsed *rinfo;  
	struct ceph_snap_realm *realm;
	unsigned int int tid;
	int err, result;
	int mds = session->s_mds;
	bool close_sessions = false;
	if (msg->front.iov_len < sizeof(*head)) {
		pr_err_client(cl, "got corrupt (short) reply\n");
		return;
	}
	tid = le64_to_cpu(msg->hdr.tid);
	mutex_lock(&mdsc->mutex);
	req = lookup_get_request(mdsc, tid);
	if (!req) {
		doutc(cl, "on unknown tid %llu\n", tid);
		mutex_unlock(&mdsc->mutex);
		return;
	}
	doutc(cl, "handle_reply %p\n", req);
	if (req->r_session != session) {
		pr_err_client(cl, "got %llu on session mds%d not mds%d\n",
			      tid, session->s_mds,
			      req->r_session ? req->r_session->s_mds : -1);
		mutex_unlock(&mdsc->mutex);
		goto out;
	}
	if ((test_bit(CEPH_MDS_R_GOT_UNSAFE, &req->r_req_flags) && !head->safe) ||
	    (test_bit(CEPH_MDS_R_GOT_SAFE, &req->r_req_flags) && head->safe)) {
		pr_warn_client(cl, "got a dup %s reply on %llu from mds%d\n",
			       head->safe ? "safe" : "unsafe", tid, mds);
		mutex_unlock(&mdsc->mutex);
		goto out;
	}
	if (test_bit(CEPH_MDS_R_GOT_SAFE, &req->r_req_flags)) {
		pr_warn_client(cl, "got unsafe after safe on %llu from mds%d\n",
			       tid, mds);
		mutex_unlock(&mdsc->mutex);
		goto out;
	}
	result = le32_to_cpu(head->result);
	if (head->safe) {
		set_bit(CEPH_MDS_R_GOT_SAFE, &req->r_req_flags);
		__unregister_request(mdsc, req);
		if (mdsc->stopping && !__get_oldest_req(mdsc))
			complete_all(&mdsc->safe_umount_waiters);
		if (test_bit(CEPH_MDS_R_GOT_UNSAFE, &req->r_req_flags)) {
			doutc(cl, "got safe reply %llu, mds%d\n", tid, mds);
			mutex_unlock(&mdsc->mutex);
			goto out;
		}
	} else {
		set_bit(CEPH_MDS_R_GOT_UNSAFE, &req->r_req_flags);
		list_add_tail(&req->r_unsafe_item, &req->r_session->s_unsafe);
	}
	doutc(cl, "tid %lld result %d\n", tid, result);
	if (test_bit(CEPHFS_FEATURE_REPLY_ENCODING, &session->s_features))
		err = parse_reply_info(session, msg, req, (unsigned int int)-1);
	else
		err = parse_reply_info(session, msg, req,
				       session->s_con.peer_features);
	mutex_unlock(&mdsc->mutex);
	rinfo = &req->r_reply_info;
	if ((err >= 0) && rinfo->head->is_target) {
		struct inode *in = xchg(&req->r_new_inode, NULL);
		struct ceph_vino tvino = {
			.ino  = le64_to_cpu(rinfo->targeti.in->ino),
			.snap = le64_to_cpu(rinfo->targeti.in->snapid)
		};
		if (req->r_op == CEPH_MDS_OP_CREATE &&
		    !req->r_reply_info.has_create_ino) {
			WARN_ON_ONCE(req->r_deleg_ino);
			iput(in);
			in = NULL;
		}
		in = ceph_get_inode(mdsc->fsc->sb, tvino, in);
		if (IS_ERR(in)) {
			err = PTR_ERR(in);
			mutex_lock(&session->s_mutex);
			goto out_err;
		}
		req->r_target_inode = in;
	}
	mutex_lock(&session->s_mutex);
	if (err < 0) {
		pr_err_client(cl, "got corrupt reply mds%d(tid:%lld)\n",
			      mds, tid);
		ceph_msg_dump(msg);
		goto out_err;
	}
	realm = NULL;
	if (rinfo->snapblob_len) {
		down_write(&mdsc->snap_rwsem);
		err = ceph_update_snap_trace(mdsc, rinfo->snapblob,
				rinfo->snapblob + rinfo->snapblob_len,
				le32_to_cpu(head->op) == CEPH_MDS_OP_RMSNAP,
				&realm);
		if (err) {
			up_write(&mdsc->snap_rwsem);
			close_sessions = true;
			if (err == -EIO)
				ceph_msg_dump(msg);
			goto out_err;
		}
		downgrade_write(&mdsc->snap_rwsem);
	} else {
		down_read(&mdsc->snap_rwsem);
	}
	mutex_lock(&req->r_fill_mutex);
	current->journal_info = req;
	err = ceph_fill_trace(mdsc->fsc->sb, req);
	if (err == 0) {
		if (result == 0 && (req->r_op == CEPH_MDS_OP_READDIR ||
				    req->r_op == CEPH_MDS_OP_LSSNAP))
			err = ceph_readdir_prepopulate(req, req->r_session);
	}
	current->journal_info = NULL;
	mutex_unlock(&req->r_fill_mutex);
	up_read(&mdsc->snap_rwsem);
	if (realm)
		ceph_put_snap_realm(mdsc, realm);
	if (err == 0) {
		if (req->r_target_inode &&
		    test_bit(CEPH_MDS_R_GOT_UNSAFE, &req->r_req_flags)) {
			struct ceph_inode_info *ci =
				ceph_inode(req->r_target_inode);
			spin_lock(&ci->i_unsafe_lock);
			list_add_tail(&req->r_unsafe_target_item,
				      &ci->i_unsafe_iops);
			spin_unlock(&ci->i_unsafe_lock);
		}
		ceph_unreserve_caps(mdsc, &req->r_caps_reservation);
	}
out_err:
	mutex_lock(&mdsc->mutex);
	if (!test_bit(CEPH_MDS_R_ABORTED, &req->r_req_flags)) {
		if (err) {
			req->r_err = err;
		} else {
			req->r_reply =  ceph_msg_get(msg);
			set_bit(CEPH_MDS_R_GOT_RESULT, &req->r_req_flags);
		}
	} else {
		doutc(cl, "reply arrived after request %lld was aborted\n", tid);
	}
	mutex_unlock(&mdsc->mutex);
	mutex_unlock(&session->s_mutex);
	complete_request(mdsc, req);
	ceph_update_metadata_metrics(&mdsc->metric, req->r_start_latency,
				     req->r_end_latency, err);
out:
	ceph_mdsc_put_request(req);
	if (close_sessions)
		ceph_mdsc_close_sessions(mdsc);
	return;
}
