dissect_thrift_varint(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int *offset, thrift_option_data_t *thrift_opt, int max_length, int hf_id, dissector_t raw_dissector)
{
    gint64 varint;
    proto_item *pi;
    int length = thrift_get_varint_enc(tvb, pinfo, tree, *offset, max_length, &varint, ENC_VARINT_ZIGZAG);
    switch (length) {
    case THRIFT_REQUEST_REASSEMBLY:
        return THRIFT_REQUEST_REASSEMBLY; 
    case 0:
        return THRIFT_REQUEST_REASSEMBLY;
    default:
        switch (max_length) {
        case TCP_THRIFT_MAX_I16_LEN:
            if ((gint64)INT16_MIN > varint || varint > (gint64)INT16_MAX) {
                pi = proto_tree_add_int64(tree, hf_thrift_i64, tvb, *offset, length, varint);
                expert_add_info(pinfo, pi, &ei_thrift_varint_too_large);
            } else {
                if (raw_dissector != NULL) {
                    guint8 *data = wmem_alloc(wmem_packet_scope(), TBP_THRIFT_I16_LEN);
                    data[0] = (varint >> 8) & 0xFF;
                    data[1] =  varint       & 0xFF;
                    tvbuff_t* sub_tvb = tvb_new_child_real_data(tvb, data, TBP_THRIFT_I16_LEN, TBP_THRIFT_I16_LEN);
                    thrift_opt->use_std_dissector = FALSE;
                    raw_dissector(sub_tvb, pinfo, tree, thrift_opt);
                }
                if (thrift_opt->use_std_dissector) {
                    proto_tree_add_int(tree, hf_id, tvb, *offset, length, (gint16)varint);
                }
            }
            break;
        case TCP_THRIFT_MAX_I32_LEN:
            if ((gint64)INT32_MIN > varint || varint > (gint64)INT32_MAX) {
                pi = proto_tree_add_int64(tree, hf_thrift_i64, tvb, *offset, length, varint);
                expert_add_info(pinfo, pi, &ei_thrift_varint_too_large);
            } else {
                if (raw_dissector != NULL) {
                    guint8 *data = wmem_alloc(wmem_packet_scope(), TBP_THRIFT_I32_LEN);
                    data[0] = (varint >> 24) & 0xFF;
                    data[1] = (varint >> 16) & 0xFF;
                    data[2] = (varint >>  8) & 0xFF;
                    data[3] =  varint        & 0xFF;
                    tvbuff_t* sub_tvb = tvb_new_child_real_data(tvb, data, TBP_THRIFT_I32_LEN, TBP_THRIFT_I32_LEN);
                    thrift_opt->use_std_dissector = FALSE;
                    raw_dissector(sub_tvb, pinfo, tree, thrift_opt);
                }
                if (thrift_opt->use_std_dissector) {
                    proto_tree_add_int(tree, hf_id, tvb, *offset, length, (gint32)varint);
                }
            }
            break;
        case TCP_THRIFT_MAX_I64_LEN:
        default:
            if (raw_dissector != NULL) {
                guint8 *data = wmem_alloc(wmem_packet_scope(), TBP_THRIFT_I64_LEN);
                data[0] = (varint >> 56) & 0xFF;
                data[1] = (varint >> 48) & 0xFF;
                data[2] = (varint >> 40) & 0xFF;
                data[3] = (varint >> 32) & 0xFF;
                data[4] = (varint >> 24) & 0xFF;
                data[5] = (varint >> 16) & 0xFF;
                data[6] = (varint >>  8) & 0xFF;
                data[7] =  varint        & 0xFF;
                tvbuff_t* sub_tvb = tvb_new_child_real_data(tvb, data, TBP_THRIFT_I64_LEN, TBP_THRIFT_I64_LEN);
                thrift_opt->use_std_dissector = FALSE;
                raw_dissector(sub_tvb, pinfo, tree, thrift_opt);
            }
            if (thrift_opt->use_std_dissector) {
                proto_tree_add_int64(tree, hf_id, tvb, *offset, length, varint);
            }
            break;
        }
        *offset += length;
        break;
    }
    return *offset;
}
