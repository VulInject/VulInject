nfsd4_encode_read(struct nfsd4_compoundres *resp, __be32 nfserr,
		  union nfsd4_op_u *u)
{
	struct nfsd4_compoundargs *argp = resp->rqstp->rq_argp;
	struct nfsd4_read *read = &u->read;
	struct xdr_stream *xdr = resp->xdr;
	int starting_len = xdr->buf->len;
	bool splice_ok = argp->splice_ok;
	unsigned int maxcount;
	struct file *file;
	__be32 *p;
	if (nfserr)
		return nfserr;
	file = read->rd_nf->nf_file;
	p = xdr_reserve_space(xdr, 8); 
	if (!p) {
		WARN_ON_ONCE(splice_ok);
		return nfserr_resource;
	}
	if (resp->xdr->buf->page_len && splice_ok) {
		WARN_ON_ONCE(1);
		return nfserr_serverfault;
	}
	xdr_commit_encode(xdr);
	maxcount = min_t(unsigned int, read->rd_length,
			 (xdr->buf->buflen - xdr->buf->len));
	if (file->f_op->splice_read && splice_ok)
		nfserr = nfsd4_encode_splice_read(resp, read, file, maxcount);
	else
		nfserr = nfsd4_encode_readv(resp, read, file, maxcount);
	if (nfserr) {
		return nfserr;
	}
	p = xdr_encode_bool(p, read->rd_eof);
	*p = cpu_to_be32(read->rd_length);
	return nfs_ok;
}
