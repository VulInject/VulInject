bool dml32_CalculatePrefetchSchedule(
		struct vba_vars_st *v,
		unsigned int k,
		double HostVMInefficiencyFactor,
		DmlPipe *myPipe,
		unsigned int DSCDelay,
		unsigned int DPP_RECOUT_WIDTH,
		unsigned int VStartup,
		unsigned int MaxVStartup,
		double UrgentLatency,
		double UrgentExtraLatency,
		double TCalc,
		unsigned int PDEAndMetaPTEBytesFrame,
		unsigned int MetaRowByte,
		unsigned int PixelPTEBytesPerRow,
		double PrefetchSourceLinesY,
		unsigned int SwathWidthY,
		unsigned int VInitPreFillY,
		unsigned int MaxNumSwathY,
		double PrefetchSourceLinesC,
		unsigned int SwathWidthC,
		unsigned int VInitPreFillC,
		unsigned int MaxNumSwathC,
		unsigned int swath_width_luma_ub,
		unsigned int swath_width_chroma_ub,
		unsigned int SwathHeightY,
		unsigned int SwathHeightC,
		double TWait,
		double TPreReq,
		bool ExtendPrefetchIfPossible,
		double   *DSTXAfterScaler,
		double   *DSTYAfterScaler,
		double *DestinationLinesForPrefetch,
		double *PrefetchBandwidth,
		double *DestinationLinesToRequestVMInVBlank,
		double *DestinationLinesToRequestRowInVBlank,
		double *VRatioPrefetchY,
		double *VRatioPrefetchC,
		double *RequiredPrefetchPixDataBWLuma,
		double *RequiredPrefetchPixDataBWChroma,
		bool   *NotEnoughTimeForDynamicMetadata,
		double *Tno_bw,
		double *prefetch_vmrow_bw,
		double *Tdmdl_vm,
		double *Tdmdl,
		double *TSetup,
		unsigned int   *VUpdateOffsetPix,
		double   *VUpdateWidthPix,
		double   *VReadyOffsetPix)
{
	double DPPCLKDelaySubtotalPlusCNVCFormater = v->DPPCLKDelaySubtotal + v->DPPCLKDelayCNVCFormater;
	bool MyError = false;
	int DPPCycles, DISPCLKCycles;
	double DSTTotalPixelsAfterScaler;
	double LineTime;
	double dst_y_prefetch_equ;
	double prefetch_bw_oto;
	double Tvm_oto;
	double Tr0_oto;
	double Tvm_oto_lines;
	double Tr0_oto_lines;
	double dst_y_prefetch_oto;
	double TimeForFetchingMetaPTE = 0;
	double TimeForFetchingRowInVBlank = 0;
	double LinesToRequestPrefetchPixelData = 0;
	double LinesForPrefetchBandwidth = 0;
	unsigned int HostVMDynamicLevelsTrips;
	double  trip_to_mem;
	double  Tvm_trips;
	double  Tr0_trips;
	double  Tvm_trips_rounded;
	double  Tr0_trips_rounded;
	double  Lsw_oto;
	double  Tpre_rounded;
	double  prefetch_bw_equ;
	double  Tvm_equ;
	double  Tr0_equ;
	double  Tdmbf;
	double  Tdmec;
	double  Tdmsks;
	double  prefetch_sw_bytes;
	double  bytes_pp;
	double  dep_bytes;
	unsigned int max_vratio_pre = v->MaxVRatioPre;
	double  min_Lsw;
	double  Tsw_est1 = 0;
	double  Tsw_est3 = 0;
	if (v->GPUVMEnable == true && v->HostVMEnable == true)
		HostVMDynamicLevelsTrips = v->HostVMMaxNonCachedPageTableLevels;
	else
		HostVMDynamicLevelsTrips = 0;
#ifdef __DML_VBA_DEBUG__
	dml_print("DML::%s: v->GPUVMEnable = %d\n", __func__, v->GPUVMEnable);
	dml_print("DML::%s: v->GPUVMMaxPageTableLevels = %d\n", __func__, v->GPUVMMaxPageTableLevels);
	dml_print("DML::%s: DCCEnable = %d\n", __func__, myPipe->DCCEnable);
	dml_print("DML::%s: v->HostVMEnable=%d HostVMInefficiencyFactor=%f\n",
			__func__, v->HostVMEnable, HostVMInefficiencyFactor);
#endif
	dml32_CalculateVUpdateAndDynamicMetadataParameters(
			v->MaxInterDCNTileRepeaters,
			myPipe->Dppclk,
			myPipe->Dispclk,
			myPipe->DCFClkDeepSleep,
			myPipe->PixelClock,
			myPipe->HTotal,
			myPipe->VBlank,
			v->DynamicMetadataTransmittedBytes[k],
			v->DynamicMetadataLinesBeforeActiveRequired[k],
			myPipe->InterlaceEnable,
			myPipe->ProgressiveToInterlaceUnitInOPP,
			TSetup,
			&Tdmbf,
			&Tdmec,
			&Tdmsks,
			VUpdateOffsetPix,
			VUpdateWidthPix,
			VReadyOffsetPix);
	LineTime = myPipe->HTotal / myPipe->PixelClock;
	trip_to_mem = UrgentLatency;
	Tvm_trips = UrgentExtraLatency + trip_to_mem * (v->GPUVMMaxPageTableLevels * (HostVMDynamicLevelsTrips + 1) - 1);
	if (v->DynamicMetadataVMEnabled == true)
		*Tdmdl = TWait + Tvm_trips + trip_to_mem;
	else
		*Tdmdl = TWait + UrgentExtraLatency;
#ifdef __DML_VBA_ALLOW_DELTA__
	if (v->DynamicMetadataEnable[k] == false)
		*Tdmdl = 0.0;
#endif
	if (v->DynamicMetadataEnable[k] == true) {
		if (VStartup * LineTime < *TSetup + *Tdmdl + Tdmbf + Tdmec + Tdmsks) {
			*NotEnoughTimeForDynamicMetadata = true;
#ifdef __DML_VBA_DEBUG__
			dml_print("DML::%s: Not Enough Time for Dynamic Meta!\n", __func__);
			dml_print("DML::%s: Tdmbf: %fus - time for dmd transfer from dchub to dio output buffer\n",
					__func__, Tdmbf);
			dml_print("DML::%s: Tdmec: %fus - time dio takes to transfer dmd\n", __func__, Tdmec);
			dml_print("DML::%s: Tdmsks: %fus - time before active dmd must complete transmission at dio\n",
					__func__, Tdmsks);
			dml_print("DML::%s: Tdmdl: %fus - time for fabric to become ready and fetch dmd\n",
					__func__, *Tdmdl);
#endif
		} else {
			*NotEnoughTimeForDynamicMetadata = false;
		}
	} else {
		*NotEnoughTimeForDynamicMetadata = false;
	}
	*Tdmdl_vm =  (v->DynamicMetadataEnable[k] == true && v->DynamicMetadataVMEnabled == true &&
			v->GPUVMEnable == true ? TWait + Tvm_trips : 0);
	if (myPipe->ScalerEnabled)
		DPPCycles = DPPCLKDelaySubtotalPlusCNVCFormater + v->DPPCLKDelaySCL;
	else
		DPPCycles = DPPCLKDelaySubtotalPlusCNVCFormater + v->DPPCLKDelaySCLLBOnly;
	DPPCycles = DPPCycles + myPipe->NumberOfCursors * v->DPPCLKDelayCNVCCursor;
	DISPCLKCycles = v->DISPCLKDelaySubtotal;
	if (myPipe->Dppclk == 0.0 || myPipe->Dispclk == 0.0)
		return true;
	*DSTXAfterScaler = DPPCycles * myPipe->PixelClock / myPipe->Dppclk + DISPCLKCycles *
			myPipe->PixelClock / myPipe->Dispclk + DSCDelay;
	*DSTXAfterScaler = *DSTXAfterScaler + (myPipe->ODMMode != dm_odm_combine_mode_disabled ? 18 : 0)
			+ (myPipe->DPPPerSurface - 1) * DPP_RECOUT_WIDTH
			+ ((myPipe->ODMMode == dm_odm_split_mode_1to2 || myPipe->ODMMode == dm_odm_mode_mso_1to2) ?
					myPipe->HActive / 2 : 0)
			+ ((myPipe->ODMMode == dm_odm_mode_mso_1to4) ? myPipe->HActive * 3 / 4 : 0);
#ifdef __DML_VBA_DEBUG__
	dml_print("DML::%s: DPPCycles: %d\n", __func__, DPPCycles);
	dml_print("DML::%s: PixelClock: %f\n", __func__, myPipe->PixelClock);
	dml_print("DML::%s: Dppclk: %f\n", __func__, myPipe->Dppclk);
	dml_print("DML::%s: DISPCLKCycles: %d\n", __func__, DISPCLKCycles);
	dml_print("DML::%s: DISPCLK: %f\n", __func__,  myPipe->Dispclk);
	dml_print("DML::%s: DSCDelay: %d\n", __func__,  DSCDelay);
	dml_print("DML::%s: ODMMode: %d\n", __func__,  myPipe->ODMMode);
	dml_print("DML::%s: DPP_RECOUT_WIDTH: %d\n", __func__, DPP_RECOUT_WIDTH);
	dml_print("DML::%s: DSTXAfterScaler: %d\n", __func__,  *DSTXAfterScaler);
#endif
	if (v->OutputFormat[k] == dm_420 || (myPipe->InterlaceEnable && myPipe->ProgressiveToInterlaceUnitInOPP))
		*DSTYAfterScaler = 1;
	else
		*DSTYAfterScaler = 0;
	DSTTotalPixelsAfterScaler = *DSTYAfterScaler * myPipe->HTotal + *DSTXAfterScaler;
	*DSTYAfterScaler = dml_floor(DSTTotalPixelsAfterScaler / myPipe->HTotal, 1);
	*DSTXAfterScaler = DSTTotalPixelsAfterScaler - ((double) (*DSTYAfterScaler * myPipe->HTotal));
#ifdef __DML_VBA_DEBUG__
	dml_print("DML::%s: DSTXAfterScaler: %d (final)\n", __func__,  *DSTXAfterScaler);
	dml_print("DML::%s: DSTYAfterScaler: %d (final)\n", __func__, *DSTYAfterScaler);
#endif
	MyError = false;
	Tr0_trips = trip_to_mem * (HostVMDynamicLevelsTrips + 1);
	if (v->GPUVMEnable == true) {
		Tvm_trips_rounded = dml_ceil(4.0 * Tvm_trips / LineTime, 1.0) / 4.0 * LineTime;
		Tr0_trips_rounded = dml_ceil(4.0 * Tr0_trips / LineTime, 1.0) / 4.0 * LineTime;
		if (v->GPUVMMaxPageTableLevels >= 3) {
			*Tno_bw = UrgentExtraLatency + trip_to_mem *
					(double) ((v->GPUVMMaxPageTableLevels - 2) * (HostVMDynamicLevelsTrips + 1) - 1);
		} else if (v->GPUVMMaxPageTableLevels == 1 && myPipe->DCCEnable != true) {
			Tr0_trips_rounded = dml_ceil(4.0 * UrgentExtraLatency / LineTime, 1.0) /
					4.0 * LineTime; 
			*Tno_bw = UrgentExtraLatency;
		} else {
			*Tno_bw = 0;
		}
	} else if (myPipe->DCCEnable == true) {
		Tvm_trips_rounded = LineTime / 4.0;
		Tr0_trips_rounded = dml_ceil(4.0 * Tr0_trips / LineTime, 1.0) / 4.0 * LineTime;
		*Tno_bw = 0;
	} else {
		Tvm_trips_rounded = LineTime / 4.0;
		Tr0_trips_rounded = LineTime / 2.0;
		*Tno_bw = 0;
	}
	Tvm_trips_rounded = dml_max(Tvm_trips_rounded, LineTime / 4.0);
	Tr0_trips_rounded = dml_max(Tr0_trips_rounded, LineTime / 4.0);
	if (myPipe->SourcePixelFormat == dm_420_8 || myPipe->SourcePixelFormat == dm_420_10
			|| myPipe->SourcePixelFormat == dm_420_12) {
		bytes_pp = myPipe->BytePerPixelY + myPipe->BytePerPixelC / 4;
	} else {
		bytes_pp = myPipe->BytePerPixelY + myPipe->BytePerPixelC;
	}
	prefetch_sw_bytes = PrefetchSourceLinesY * swath_width_luma_ub * myPipe->BytePerPixelY
			+ PrefetchSourceLinesC * swath_width_chroma_ub * myPipe->BytePerPixelC;
	prefetch_bw_oto = dml_max(bytes_pp * myPipe->PixelClock / myPipe->DPPPerSurface,
			prefetch_sw_bytes / (dml_max(PrefetchSourceLinesY, PrefetchSourceLinesC) * LineTime));
	min_Lsw = dml_max(PrefetchSourceLinesY, PrefetchSourceLinesC) / max_vratio_pre;
	min_Lsw = dml_max(min_Lsw, 1.0);
	Lsw_oto = dml_ceil(4.0 * dml_max(prefetch_sw_bytes / prefetch_bw_oto / LineTime, min_Lsw), 1.0) / 4.0;
	if (v->GPUVMEnable == true) {
		Tvm_oto = dml_max3(
				Tvm_trips,
				*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / prefetch_bw_oto,
				LineTime / 4.0);
	} else
		Tvm_oto = LineTime / 4.0;
	if ((v->GPUVMEnable == true || myPipe->DCCEnable == true)) {
		Tr0_oto = dml_max4(
				Tr0_trips,
				(MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / prefetch_bw_oto,
				(LineTime - Tvm_oto)/2.0,
				LineTime / 4.0);
#ifdef __DML_VBA_DEBUG__
		dml_print("DML::%s: Tr0_oto max0 = %f\n", __func__,
				(MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / prefetch_bw_oto);
		dml_print("DML::%s: Tr0_oto max1 = %f\n", __func__, Tr0_trips);
		dml_print("DML::%s: Tr0_oto max2 = %f\n", __func__, LineTime - Tvm_oto);
		dml_print("DML::%s: Tr0_oto max3 = %f\n", __func__, LineTime / 4);
#endif
	} else
		Tr0_oto = (LineTime - Tvm_oto) / 2.0;
	Tvm_oto_lines = dml_ceil(4.0 * Tvm_oto / LineTime, 1) / 4.0;
	Tr0_oto_lines = dml_ceil(4.0 * Tr0_oto / LineTime, 1) / 4.0;
	dst_y_prefetch_oto = Tvm_oto_lines + 2 * Tr0_oto_lines + Lsw_oto;
	dst_y_prefetch_equ = VStartup - (*TSetup + dml_max(TWait + TCalc, *Tdmdl)) / LineTime -
			(*DSTYAfterScaler + (double) *DSTXAfterScaler / (double) myPipe->HTotal);
	dst_y_prefetch_equ = dml_min(dst_y_prefetch_equ, __DML_VBA_MAX_DST_Y_PRE__);
#ifdef __DML_VBA_DEBUG__
	dml_print("DML::%s: HTotal = %d\n", __func__, myPipe->HTotal);
	dml_print("DML::%s: min_Lsw = %f\n", __func__, min_Lsw);
	dml_print("DML::%s: *Tno_bw = %f\n", __func__, *Tno_bw);
	dml_print("DML::%s: UrgentExtraLatency = %f\n", __func__, UrgentExtraLatency);
	dml_print("DML::%s: trip_to_mem = %f\n", __func__, trip_to_mem);
	dml_print("DML::%s: BytePerPixelY = %d\n", __func__, myPipe->BytePerPixelY);
	dml_print("DML::%s: PrefetchSourceLinesY = %f\n", __func__, PrefetchSourceLinesY);
	dml_print("DML::%s: swath_width_luma_ub = %d\n", __func__, swath_width_luma_ub);
	dml_print("DML::%s: BytePerPixelC = %d\n", __func__, myPipe->BytePerPixelC);
	dml_print("DML::%s: PrefetchSourceLinesC = %f\n", __func__, PrefetchSourceLinesC);
	dml_print("DML::%s: swath_width_chroma_ub = %d\n", __func__, swath_width_chroma_ub);
	dml_print("DML::%s: prefetch_sw_bytes = %f\n", __func__, prefetch_sw_bytes);
	dml_print("DML::%s: bytes_pp = %f\n", __func__, bytes_pp);
	dml_print("DML::%s: PDEAndMetaPTEBytesFrame = %d\n", __func__, PDEAndMetaPTEBytesFrame);
	dml_print("DML::%s: MetaRowByte = %d\n", __func__, MetaRowByte);
	dml_print("DML::%s: PixelPTEBytesPerRow = %d\n", __func__, PixelPTEBytesPerRow);
	dml_print("DML::%s: HostVMInefficiencyFactor = %f\n", __func__, HostVMInefficiencyFactor);
	dml_print("DML::%s: Tvm_trips = %f\n", __func__, Tvm_trips);
	dml_print("DML::%s: Tr0_trips = %f\n", __func__, Tr0_trips);
	dml_print("DML::%s: prefetch_bw_oto = %f\n", __func__, prefetch_bw_oto);
	dml_print("DML::%s: Tr0_oto = %f\n", __func__, Tr0_oto);
	dml_print("DML::%s: Tvm_oto = %f\n", __func__, Tvm_oto);
	dml_print("DML::%s: Tvm_oto_lines = %f\n", __func__, Tvm_oto_lines);
	dml_print("DML::%s: Tr0_oto_lines = %f\n", __func__, Tr0_oto_lines);
	dml_print("DML::%s: Lsw_oto = %f\n", __func__, Lsw_oto);
	dml_print("DML::%s: dst_y_prefetch_oto = %f\n", __func__, dst_y_prefetch_oto);
	dml_print("DML::%s: dst_y_prefetch_equ = %f\n", __func__, dst_y_prefetch_equ);
#endif
	dst_y_prefetch_equ = dml_floor(4.0 * (dst_y_prefetch_equ + 0.125), 1) / 4.0;
	Tpre_rounded = dst_y_prefetch_equ * LineTime;
#ifdef __DML_VBA_DEBUG__
	dml_print("DML::%s: dst_y_prefetch_equ: %f (after round)\n", __func__, dst_y_prefetch_equ);
	dml_print("DML::%s: LineTime: %f\n", __func__, LineTime);
	dml_print("DML::%s: VStartup: %d\n", __func__, VStartup);
	dml_print("DML::%s: Tvstartup: %fus - time between vstartup and first pixel of active\n",
			__func__, VStartup * LineTime);
	dml_print("DML::%s: TSetup: %fus - time from vstartup to vready\n", __func__, *TSetup);
	dml_print("DML::%s: TCalc: %fus - time for calculations in dchub starting at vready\n", __func__, TCalc);
	dml_print("DML::%s: Tdmbf: %fus - time for dmd transfer from dchub to dio output buffer\n", __func__, Tdmbf);
	dml_print("DML::%s: Tdmec: %fus - time dio takes to transfer dmd\n", __func__, Tdmec);
	dml_print("DML::%s: Tdmdl_vm: %fus - time for vm stages of dmd\n", __func__, *Tdmdl_vm);
	dml_print("DML::%s: Tdmdl: %fus - time for fabric to become ready and fetch dmd\n", __func__, *Tdmdl);
	dml_print("DML::%s: DSTYAfterScaler: %d lines - number of lines of pipeline and buffer delay after scaler\n",
			__func__, *DSTYAfterScaler);
#endif
	dep_bytes = dml_max(PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor,
			MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor);
	if (prefetch_sw_bytes < dep_bytes)
		prefetch_sw_bytes = 2 * dep_bytes;
	*PrefetchBandwidth = 0;
	*DestinationLinesToRequestVMInVBlank = 0;
	*DestinationLinesToRequestRowInVBlank = 0;
	*VRatioPrefetchY = 0;
	*VRatioPrefetchC = 0;
	*RequiredPrefetchPixDataBWLuma = 0;
	if (dst_y_prefetch_equ > 1 &&
			(Tpre_rounded >= TPreReq || dst_y_prefetch_equ == __DML_VBA_MAX_DST_Y_PRE__)) {
		double PrefetchBandwidth1;
		double PrefetchBandwidth2;
		double PrefetchBandwidth3;
		double PrefetchBandwidth4;
		if (Tpre_rounded - *Tno_bw > 0) {
			PrefetchBandwidth1 = (PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor + 2 * MetaRowByte
					+ 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor
					+ prefetch_sw_bytes) / (Tpre_rounded - *Tno_bw);
			Tsw_est1 = prefetch_sw_bytes / PrefetchBandwidth1;
		} else
			PrefetchBandwidth1 = 0;
		if (VStartup == MaxVStartup && (Tsw_est1 / LineTime < min_Lsw)
				&& Tpre_rounded - min_Lsw * LineTime - 0.75 * LineTime - *Tno_bw > 0) {
			PrefetchBandwidth1 = (PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor + 2 * MetaRowByte
					+ 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor)
					/ (Tpre_rounded - min_Lsw * LineTime - 0.75 * LineTime - *Tno_bw);
		}
		if (Tpre_rounded - *Tno_bw - 2 * Tr0_trips_rounded > 0)
			PrefetchBandwidth2 = (PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor + prefetch_sw_bytes) /
			(Tpre_rounded - *Tno_bw - 2 * Tr0_trips_rounded);
		else
			PrefetchBandwidth2 = 0;
		if (Tpre_rounded - Tvm_trips_rounded > 0) {
			PrefetchBandwidth3 = (2 * MetaRowByte + 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor
					+ prefetch_sw_bytes) / (Tpre_rounded - Tvm_trips_rounded);
			Tsw_est3 = prefetch_sw_bytes / PrefetchBandwidth3;
		} else
			PrefetchBandwidth3 = 0;
		if (VStartup == MaxVStartup &&
				(Tsw_est3 / LineTime < min_Lsw) && Tpre_rounded - min_Lsw * LineTime - 0.75 *
				LineTime - Tvm_trips_rounded > 0) {
			PrefetchBandwidth3 = (2 * MetaRowByte + 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor)
					/ (Tpre_rounded - min_Lsw * LineTime - 0.75 * LineTime - Tvm_trips_rounded);
		}
		if (Tpre_rounded - Tvm_trips_rounded - 2 * Tr0_trips_rounded > 0) {
			PrefetchBandwidth4 = prefetch_sw_bytes /
					(Tpre_rounded - Tvm_trips_rounded - 2 * Tr0_trips_rounded);
		} else {
			PrefetchBandwidth4 = 0;
		}
#ifdef __DML_VBA_DEBUG__
		dml_print("DML::%s: Tpre_rounded: %f\n", __func__, Tpre_rounded);
		dml_print("DML::%s: Tno_bw: %f\n", __func__, *Tno_bw);
		dml_print("DML::%s: Tvm_trips_rounded: %f\n", __func__, Tvm_trips_rounded);
		dml_print("DML::%s: Tsw_est1: %f\n", __func__, Tsw_est1);
		dml_print("DML::%s: Tsw_est3: %f\n", __func__, Tsw_est3);
		dml_print("DML::%s: PrefetchBandwidth1: %f\n", __func__, PrefetchBandwidth1);
		dml_print("DML::%s: PrefetchBandwidth2: %f\n", __func__, PrefetchBandwidth2);
		dml_print("DML::%s: PrefetchBandwidth3: %f\n", __func__, PrefetchBandwidth3);
		dml_print("DML::%s: PrefetchBandwidth4: %f\n", __func__, PrefetchBandwidth4);
#endif
		{
			bool Case1OK;
			bool Case2OK;
			bool Case3OK;
			if (PrefetchBandwidth1 > 0) {
				if (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth1
						>= Tvm_trips_rounded
						&& (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor)
								/ PrefetchBandwidth1 >= Tr0_trips_rounded) {
					Case1OK = true;
				} else {
					Case1OK = false;
				}
			} else {
				Case1OK = false;
			}
			if (PrefetchBandwidth2 > 0) {
				if (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth2
						>= Tvm_trips_rounded
						&& (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor)
						/ PrefetchBandwidth2 < Tr0_trips_rounded) {
					Case2OK = true;
				} else {
					Case2OK = false;
				}
			} else {
				Case2OK = false;
			}
			if (PrefetchBandwidth3 > 0) {
				if (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth3 <
						Tvm_trips_rounded && (MetaRowByte + PixelPTEBytesPerRow *
								HostVMInefficiencyFactor) / PrefetchBandwidth3 >=
								Tr0_trips_rounded) {
					Case3OK = true;
				} else {
					Case3OK = false;
				}
			} else {
				Case3OK = false;
			}
			if (Case1OK)
				prefetch_bw_equ = PrefetchBandwidth1;
			else if (Case2OK)
				prefetch_bw_equ = PrefetchBandwidth2;
			else if (Case3OK)
				prefetch_bw_equ = PrefetchBandwidth3;
			else
				prefetch_bw_equ = PrefetchBandwidth4;
#ifdef __DML_VBA_DEBUG__
			dml_print("DML::%s: Case1OK: %d\n", __func__, Case1OK);
			dml_print("DML::%s: Case2OK: %d\n", __func__, Case2OK);
			dml_print("DML::%s: Case3OK: %d\n", __func__, Case3OK);
			dml_print("DML::%s: prefetch_bw_equ: %f\n", __func__, prefetch_bw_equ);
#endif
			if (prefetch_bw_equ > 0) {
				if (v->GPUVMEnable == true) {
					Tvm_equ = dml_max3(*Tno_bw + PDEAndMetaPTEBytesFrame *
							HostVMInefficiencyFactor / prefetch_bw_equ,
							Tvm_trips, LineTime / 4);
				} else {
					Tvm_equ = LineTime / 4;
				}
				if ((v->GPUVMEnable == true || myPipe->DCCEnable == true)) {
					Tr0_equ = dml_max4((MetaRowByte + PixelPTEBytesPerRow *
							HostVMInefficiencyFactor) / prefetch_bw_equ, Tr0_trips,
							(LineTime - Tvm_equ) / 2, LineTime / 4);
				} else {
					Tr0_equ = (LineTime - Tvm_equ) / 2;
				}
			} else {
				Tvm_equ = 0;
				Tr0_equ = 0;
#ifdef __DML_VBA_DEBUG__
				dml_print("DML: prefetch_bw_equ equals 0! %s:%d\n", __FILE__, __LINE__);
#endif
			}
		}
		if (dst_y_prefetch_oto < dst_y_prefetch_equ) {
			if (dst_y_prefetch_oto * LineTime < TPreReq) {
				*DestinationLinesForPrefetch = dst_y_prefetch_equ;
			} else {
				*DestinationLinesForPrefetch = dst_y_prefetch_oto;
			}
			TimeForFetchingMetaPTE = Tvm_oto;
			TimeForFetchingRowInVBlank = Tr0_oto;
			*PrefetchBandwidth = prefetch_bw_oto;
			LinesForPrefetchBandwidth = dst_y_prefetch_oto;
		} else {
			if (ExtendPrefetchIfPossible && TPreReq == 0 && VStartup < MaxVStartup) {
				MyError = true;
			} else {
				*DestinationLinesForPrefetch = dst_y_prefetch_equ;
				TimeForFetchingMetaPTE = Tvm_equ;
				TimeForFetchingRowInVBlank = Tr0_equ;
				*PrefetchBandwidth = prefetch_bw_equ;
				LinesForPrefetchBandwidth = dst_y_prefetch_equ;
			}
		}
		*DestinationLinesToRequestVMInVBlank = dml_ceil(4.0 * TimeForFetchingMetaPTE / LineTime, 1.0) / 4.0;
		*DestinationLinesToRequestRowInVBlank =
				dml_ceil(4.0 * TimeForFetchingRowInVBlank / LineTime, 1.0) / 4.0;
		LinesToRequestPrefetchPixelData = LinesForPrefetchBandwidth -
				*DestinationLinesToRequestVMInVBlank - 2 * *DestinationLinesToRequestRowInVBlank;
#ifdef __DML_VBA_DEBUG__
		dml_print("DML::%s: DestinationLinesForPrefetch = %f\n", __func__, *DestinationLinesForPrefetch);
		dml_print("DML::%s: DestinationLinesToRequestVMInVBlank = %f\n",
				__func__, *DestinationLinesToRequestVMInVBlank);
		dml_print("DML::%s: TimeForFetchingRowInVBlank = %f\n", __func__, TimeForFetchingRowInVBlank);
		dml_print("DML::%s: LineTime = %f\n", __func__, LineTime);
		dml_print("DML::%s: DestinationLinesToRequestRowInVBlank = %f\n",
				__func__, *DestinationLinesToRequestRowInVBlank);
		dml_print("DML::%s: PrefetchSourceLinesY = %f\n", __func__, PrefetchSourceLinesY);
		dml_print("DML::%s: LinesToRequestPrefetchPixelData = %f\n", __func__, LinesToRequestPrefetchPixelData);
#endif
		if (LinesToRequestPrefetchPixelData >= 1 && prefetch_bw_equ > 0) {
			*VRatioPrefetchY = (double) PrefetchSourceLinesY / LinesToRequestPrefetchPixelData;
			*VRatioPrefetchY = dml_max(*VRatioPrefetchY, 1.0);
#ifdef __DML_VBA_DEBUG__
			dml_print("DML::%s: VRatioPrefetchY = %f\n", __func__, *VRatioPrefetchY);
			dml_print("DML::%s: SwathHeightY = %d\n", __func__, SwathHeightY);
			dml_print("DML::%s: VInitPreFillY = %d\n", __func__, VInitPreFillY);
#endif
			if ((SwathHeightY > 4) && (VInitPreFillY > 3)) {
				if (LinesToRequestPrefetchPixelData > (VInitPreFillY - 3.0) / 2.0) {
					*VRatioPrefetchY =
							dml_max((double) PrefetchSourceLinesY /
									LinesToRequestPrefetchPixelData,
									(double) MaxNumSwathY * SwathHeightY /
									(LinesToRequestPrefetchPixelData -
									(VInitPreFillY - 3.0) / 2.0));
					*VRatioPrefetchY = dml_max(*VRatioPrefetchY, 1.0);
				} else {
					MyError = true;
					*VRatioPrefetchY = 0;
				}
#ifdef __DML_VBA_DEBUG__
				dml_print("DML::%s: VRatioPrefetchY = %f\n", __func__, *VRatioPrefetchY);
				dml_print("DML::%s: PrefetchSourceLinesY = %f\n", __func__, PrefetchSourceLinesY);
				dml_print("DML::%s: MaxNumSwathY = %d\n", __func__, MaxNumSwathY);
#endif
			}
			*VRatioPrefetchC = (double) PrefetchSourceLinesC / LinesToRequestPrefetchPixelData;
			*VRatioPrefetchC = dml_max(*VRatioPrefetchC, 1.0);
#ifdef __DML_VBA_DEBUG__
			dml_print("DML::%s: VRatioPrefetchC = %f\n", __func__, *VRatioPrefetchC);
			dml_print("DML::%s: SwathHeightC = %d\n", __func__, SwathHeightC);
			dml_print("DML::%s: VInitPreFillC = %d\n", __func__, VInitPreFillC);
#endif
			if ((SwathHeightC > 4)) {
				if (LinesToRequestPrefetchPixelData > (VInitPreFillC - 3.0) / 2.0) {
					*VRatioPrefetchC =
						dml_max(*VRatioPrefetchC,
							(double) MaxNumSwathC * SwathHeightC /
							(LinesToRequestPrefetchPixelData -
							(VInitPreFillC - 3.0) / 2.0));
					*VRatioPrefetchC = dml_max(*VRatioPrefetchC, 1.0);
				} else {
					MyError = true;
					*VRatioPrefetchC = 0;
				}
#ifdef __DML_VBA_DEBUG__
				dml_print("DML::%s: VRatioPrefetchC = %f\n", __func__, *VRatioPrefetchC);
				dml_print("DML::%s: PrefetchSourceLinesC = %f\n", __func__, PrefetchSourceLinesC);
				dml_print("DML::%s: MaxNumSwathC = %d\n", __func__, MaxNumSwathC);
#endif
			}
			*RequiredPrefetchPixDataBWLuma = (double) PrefetchSourceLinesY
					/ LinesToRequestPrefetchPixelData * myPipe->BytePerPixelY * swath_width_luma_ub
					/ LineTime;
#ifdef __DML_VBA_DEBUG__
			dml_print("DML::%s: BytePerPixelY = %d\n", __func__, myPipe->BytePerPixelY);
			dml_print("DML::%s: swath_width_luma_ub = %d\n", __func__, swath_width_luma_ub);
			dml_print("DML::%s: LineTime = %f\n", __func__, LineTime);
			dml_print("DML::%s: RequiredPrefetchPixDataBWLuma = %f\n",
					__func__, *RequiredPrefetchPixDataBWLuma);
#endif
			*RequiredPrefetchPixDataBWChroma = (double) PrefetchSourceLinesC /
					LinesToRequestPrefetchPixelData
					* myPipe->BytePerPixelC
					* swath_width_chroma_ub / LineTime;
		} else {
			MyError = true;
#ifdef __DML_VBA_DEBUG__
			dml_print("DML:%s: MyErr set. LinesToRequestPrefetchPixelData: %f, should be > 0\n",
					__func__, LinesToRequestPrefetchPixelData);
#endif
			*VRatioPrefetchY = 0;
			*VRatioPrefetchC = 0;
			*RequiredPrefetchPixDataBWLuma = 0;
			*RequiredPrefetchPixDataBWChroma = 0;
		}
#ifdef __DML_VBA_DEBUG__
		dml_print("DML: Tpre: %fus - sum of time to request meta pte, 2 x data pte + meta data, swaths\n",
			(double)LinesToRequestPrefetchPixelData * LineTime +
			2.0*TimeForFetchingRowInVBlank + TimeForFetchingMetaPTE);
		dml_print("DML:  Tvm: %fus - time to fetch page tables for meta surface\n", TimeForFetchingMetaPTE);
		dml_print("DML: To: %fus - time for propagation from scaler to optc\n",
			(*DSTYAfterScaler + ((double) (*DSTXAfterScaler) / (double) myPipe->HTotal)) * LineTime);
		dml_print("DML: Tvstartup - TSetup - Tcalc - Twait - Tpre - To > 0\n");
		dml_print("DML: Tslack(pre): %fus - time left over in schedule\n", VStartup * LineTime -
			TimeForFetchingMetaPTE - 2*TimeForFetchingRowInVBlank - (*DSTYAfterScaler +
			((double) (*DSTXAfterScaler) / (double) myPipe->HTotal)) * LineTime - TWait - TCalc - *TSetup);
		dml_print("DML: row_bytes = dpte_row_bytes (per_pipe) = PixelPTEBytesPerRow = : %d\n",
				PixelPTEBytesPerRow);
#endif
	} else {
		MyError = true;
#ifdef __DML_VBA_DEBUG__
		dml_print("DML::%s: MyErr set, dst_y_prefetch_equ = %f (should be > 1)\n",
				__func__, dst_y_prefetch_equ);
#endif
	}
	{
		double prefetch_vm_bw;
		double prefetch_row_bw;
		if (PDEAndMetaPTEBytesFrame == 0) {
			prefetch_vm_bw = 0;
		} else if (*DestinationLinesToRequestVMInVBlank > 0) {
#ifdef __DML_VBA_DEBUG__
			dml_print("DML::%s: PDEAndMetaPTEBytesFrame = %d\n", __func__, PDEAndMetaPTEBytesFrame);
			dml_print("DML::%s: HostVMInefficiencyFactor = %f\n", __func__, HostVMInefficiencyFactor);
			dml_print("DML::%s: DestinationLinesToRequestVMInVBlank = %f\n",
					__func__, *DestinationLinesToRequestVMInVBlank);
			dml_print("DML::%s: LineTime = %f\n", __func__, LineTime);
#endif
			prefetch_vm_bw = PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor /
					(*DestinationLinesToRequestVMInVBlank * LineTime);
#ifdef __DML_VBA_DEBUG__
			dml_print("DML::%s: prefetch_vm_bw = %f\n", __func__, prefetch_vm_bw);
#endif
		} else {
			prefetch_vm_bw = 0;
			MyError = true;
#ifdef __DML_VBA_DEBUG__
			dml_print("DML::%s: MyErr set. DestinationLinesToRequestVMInVBlank=%f (should be > 0)\n",
					__func__, *DestinationLinesToRequestVMInVBlank);
#endif
		}
		if (MetaRowByte + PixelPTEBytesPerRow == 0) {
			prefetch_row_bw = 0;
		} else if (*DestinationLinesToRequestRowInVBlank > 0) {
			prefetch_row_bw = (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) /
					(*DestinationLinesToRequestRowInVBlank * LineTime);
#ifdef __DML_VBA_DEBUG__
			dml_print("DML::%s: MetaRowByte = %d\n", __func__, MetaRowByte);
			dml_print("DML::%s: PixelPTEBytesPerRow = %d\n", __func__, PixelPTEBytesPerRow);
			dml_print("DML::%s: DestinationLinesToRequestRowInVBlank = %f\n",
					__func__, *DestinationLinesToRequestRowInVBlank);
			dml_print("DML::%s: prefetch_row_bw = %f\n", __func__, prefetch_row_bw);
#endif
		} else {
			prefetch_row_bw = 0;
			MyError = true;
#ifdef __DML_VBA_DEBUG__
			dml_print("DML::%s: MyErr set. DestinationLinesToRequestRowInVBlank=%f (should be > 0)\n",
					__func__, *DestinationLinesToRequestRowInVBlank);
#endif
		}
		*prefetch_vmrow_bw = dml_max(prefetch_vm_bw, prefetch_row_bw);
	}
	if (MyError) {
		*PrefetchBandwidth = 0;
		TimeForFetchingMetaPTE = 0;
		TimeForFetchingRowInVBlank = 0;
		*DestinationLinesToRequestVMInVBlank = 0;
		*DestinationLinesToRequestRowInVBlank = 0;
		*DestinationLinesForPrefetch = 0;
		LinesToRequestPrefetchPixelData = 0;
		*VRatioPrefetchY = 0;
		*VRatioPrefetchC = 0;
		*RequiredPrefetchPixDataBWLuma = 0;
		*RequiredPrefetchPixDataBWChroma = 0;
	}
	return MyError;
} 
