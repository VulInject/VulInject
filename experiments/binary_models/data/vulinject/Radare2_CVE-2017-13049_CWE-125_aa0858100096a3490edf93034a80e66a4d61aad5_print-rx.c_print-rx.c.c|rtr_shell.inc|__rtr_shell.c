static void __rtr_shell(RCore *core, int nth) {
	char *proto = "http";
	char *host = "";
	char *port= "";
	char *file= "";
	char prompt[64], prompt2[64], *str, *ptr;
	int len;
	const char* res;
	RSocket *s = NULL;
	if (!r_config_get_b (core->config, "scr.interactive")) {
		eprintf ("Set scr.interfactive to use the remote r2 shell.\n");
		return;
	}
	TextLog T = { host, port, file };
	snprintf (prompt, sizeof (prompt), "[%s://%s:%s/%s]> ",
			proto, host, port, file);
	snprintf (prompt2, sizeof (prompt2), "[%s:%s]$ ", host, port);
	for (;;) {
		res = r_line_readline ();
		if (!res || !*res) {
			break;
		}
		if (*res == 'q') {
			break;
		}
		if (!strcmp (res, "!sh")) {
			for (;;) {
				r_line_set_prompt (prompt2);
				res = r_line_readline ();
				if (!res || !*res || !strcmp (res, "exit")) {
					break;
				}
				ptr = r_str_uri_encode (res);
				char *uri = r_str_newf ("http://%s:%s/%s!%s", host, port, file, res);
				str = r_socket_http_get (uri, NULL, &len);
				if (str) {
					str[len] = 0;
					res = strstr (str, "\n\n");
					if (res) {
						res = strstr (res + 1, "\n\n");
					}
					res = res? res + 2: str;
					const char *tail = (res[strlen (res) - 1] == '\n')? "": "\n";
					printf ("%s%s", res, tail);
					r_line_hist_add (str);
					free (str);
				}
				free (ptr);
				free (uri);
			}
		} else if (res[0] == 'v' || res[0] == 'V') {
			if (res[1] == ' ') {
				rtr_visual (core, T, res + 1);
			} else {
				rtr_visual (core, T, NULL);
			}
		} else if (!strcmp (res, "TT")) {
			rtr_textlog_chat (core, T);
		} else {
			char *cmdline = r_str_newf ("%d %s", nth, res);
			r_core_rtr_cmd (core, cmdline);
			r_cons_flush ();
			r_line_hist_add (res);
		}
	}
	r_socket_free (s);
}
