hisds hi_sdsMakeRoomFor(hisds s, size_t addlen) {
    void *sh, *newsh;
    size_t avail = hi_sdsavail(s);
    size_t len, newlen, reqlen;
    char type, oldtype = s[-1] & HI_SDS_TYPE_MASK;
    int hdrlen;
    /* Return ASAP if there is enough space left. */
    if (avail >= addlen) return s;
    len = hi_sdslen(s);
    sh = (char*)s-hi_sdsHdrSize(oldtype);
    reqlen = newlen = (len+addlen);
    if (newlen <= len) return NULL; /* Catch size_t overflow */
    if (newlen < HI_SDS_MAX_PREALLOC)
        newlen *= 2;
    else
        newlen += HI_SDS_MAX_PREALLOC;
    type = hi_sdsReqType(newlen);
    /* Don't use type 5: the user is appending to the string and type 5 is
     * not able to remember empty space, so hi_sdsMakeRoomFor() must be called
     * at every appending operation. */
    if (type == HI_SDS_TYPE_5) type = HI_SDS_TYPE_8;
    hdrlen = hi_sdsHdrSize(type);
    if (hdrlen+newlen+1 <= reqlen) return NULL; /* Catch size_t overflow */
    if (oldtype==type) {
        newsh = hi_s_realloc(sh, hdrlen+newlen+1);
        if (newsh == NULL) return NULL;
        s = (char*)newsh+hdrlen;
    } else {
        /* Since the header size changes, need to move the string forward,
         * and can't use realloc */
        newsh = hi_s_malloc(hdrlen+newlen+1);
        if (newsh == NULL) return NULL;
        memcpy((char*)newsh+hdrlen, s, len+1);
        hi_s_free(sh);
        s = (char*)newsh+hdrlen;
        s[-1] = type;
    }
    hi_sdssetalloc(s, newlen);
    return s;
}
