static void rzg2l_pinctrl_pm_setup_regs(struct rzg2l_pinctrl *pctrl, bool suspend)
{
	unsigned int nports = pctrl->data->n_port_pins / RZG2L_PINS_PER_PORT;
	struct rzg2l_pinctrl_reg_cache *cache = pctrl->cache;
	for (unsigned int port = 0; port < nports; port++) {
	int has_iolh, has_ien;
		unsigned int off, caps;
		unsigned char pincnt;
		unsigned int int cfg;
		cfg = pctrl->data->port_pin_configs[port];
		off = RZG2L_PIN_CFG_TO_PORT_OFFSET(cfg);
		pincnt = hweight8(FIELD_GET(PIN_CFG_PIN_MAP_MASK, cfg));
		caps = FIELD_GET(PIN_CFG_MASK, cfg);
		has_iolh = !!(caps & (PIN_CFG_IOLH_A | PIN_CFG_IOLH_B | PIN_CFG_IOLH_C));
		has_ien = !!(caps & PIN_CFG_IEN);
		if (suspend)
			RZG2L_PCTRL_REG_ACCESS32(suspend, pctrl->base + PFC(off), cache->pfc[port]);
		RZG2L_PCTRL_REG_ACCESS8(suspend, pctrl->base + PMC(off), cache->pmc[port]);
		if (has_iolh) {
			RZG2L_PCTRL_REG_ACCESS32(suspend, pctrl->base + IOLH(off),
						 cache->iolh[0][port]);
			if (pincnt >= 4) {
				RZG2L_PCTRL_REG_ACCESS32(suspend, pctrl->base + IOLH(off) + 4,
							 cache->iolh[1][port]);
			}
		}
		RZG2L_PCTRL_REG_ACCESS16(suspend, pctrl->base + PM(off), cache->pm[port]);
		RZG2L_PCTRL_REG_ACCESS8(suspend, pctrl->base + P(off), cache->p[port]);
		if (has_ien) {
			RZG2L_PCTRL_REG_ACCESS32(suspend, pctrl->base + IEN(off),
						 cache->ien[0][port]);
			if (pincnt >= 4) {
				RZG2L_PCTRL_REG_ACCESS32(suspend, pctrl->base + IEN(off) + 4,
							 cache->ien[1][port]);
			}
		}
	}
}
