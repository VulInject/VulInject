dissect_etv_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int proto,
	int hf_filter_info, int hf_reserved,
	expert_field* ei_section_syntax_indicator, expert_field* ei_reserved,
	expert_field* ei_section_length, expert_field* ei_filter_info)
{
	tvbuff_t   *sub_tvb;
	guint       offset = 0;
	proto_item *ti;
	proto_item *pi;
	proto_tree *etv_tree;
	proto_item *items[PACKET_MPEG_SECT_PI__SIZE];
	bool        ssi;
	guint       reserved;
	guint8      reserved2;
	guint16     filter_info;
	guint       sect_len;
	ti = proto_tree_add_item(tree, proto, tvb, offset, -1, ENC_NA);
	etv_tree = proto_item_add_subtree(ti, ett_etv);
	offset += packet_mpeg_sect_header_extra(tvb, offset, etv_tree, &sect_len,
						&reserved, &ssi, items);
	if (FALSE != ssi) {
		proto_item *msg_error;
		msg_error = items[PACKET_MPEG_SECT_PI__SSI];
		expert_add_info(pinfo, msg_error, ei_section_syntax_indicator);
	}
	if (4 != reserved) {
		proto_item *msg_error;
		msg_error = items[PACKET_MPEG_SECT_PI__RESERVED];
		proto_item_set_generated(msg_error);
		expert_add_info(pinfo, msg_error, ei_reserved);
	}
	col_append_fstr(pinfo->cinfo, COL_INFO, ", Length: %u", sect_len);
	proto_item_append_text(ti, " Length=%u", sect_len);
	if (1021 < sect_len) {
		proto_item *msg_error;
		msg_error = items[PACKET_MPEG_SECT_PI__LENGTH];
		proto_item_set_generated(msg_error);
		expert_add_info(pinfo, msg_error, ei_section_length);
	}
	filter_info = tvb_get_ntohs(tvb, offset);
	col_append_fstr(pinfo->cinfo, COL_INFO, ", Filter: 0x%x", filter_info);
	proto_item_append_text(ti, " Filter=0x%x", filter_info);
	pi = proto_tree_add_item(etv_tree, hf_filter_info, tvb, offset, 2, ENC_BIG_ENDIAN);
	if ((proto_etv_dii == proto) && (0xFBFB != filter_info)) {
		expert_add_info_format(pinfo, pi, ei_filter_info,
					"Invalid filter_info value (must be 0xFBFB)");
	} else if ((proto_etv_ddb == proto) &&
			((filter_info < 1) || (0xfbef < filter_info)))
	{
		expert_add_info_format(pinfo, pi, ei_filter_info,
					"Invalid filter_info value (must be [0x0001-0xFBEF] inclusive)");
	}
	offset += 2;
	reserved2 = tvb_get_guint8(tvb, offset);
	pi = proto_tree_add_item(etv_tree, hf_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);
	if (0 != reserved2) {
		expert_add_info_format(pinfo, pi, ei_reserved,
					"Invalid reserved2 bits (should all be 0)");
	}
	offset += 1;
	sub_tvb = tvb_new_subset_length(tvb, offset, sect_len-7);
	call_dissector(dsmcc_handle, sub_tvb, pinfo, tree);
	sect_len += 3 - 4; 
	packet_mpeg_sect_crc(tvb, pinfo, etv_tree, 0, sect_len);
}
