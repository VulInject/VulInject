  cf2_getGlyphOutline( CF2_Font           font,
                       CF2_Buffer         charstring,
                       const CF2_Matrix*  transform,
                       CF2_F16Dot16*      glyphWidth )
  {
    FT_Error  lastError = FT_Err_Ok;
    FT_Vector  translation;
#if 0
    FT_Vector  advancePoint;
#endif
    CF2_Fixed  advWidth = 0;
    FT_Bool    needWinding;
    translation.x = transform->tx;
    translation.y = transform->ty;
    cf2_font_setup( font, transform );
    if ( font->error )
      goto exit;                      
    font->reverseWinding = FALSE;
    needWinding = font->darkened;
    while ( 1 )
    {
      cf2_interpT2CharString( font,
                              charstring,
                              (CF2_OutlineCallbacks)&font->outline,
                              &translation,
                              FALSE,
                              0,
                              0,
                              &advWidth );
      if ( font->error )
        goto exit;
      if ( !needWinding )
        break;
      if ( font->outline.root.windingMomentum >= 0 ) 
        break;
      font->reverseWinding = TRUE;
      needWinding = FALSE;    
    }
    cf2_outline_close( &font->outline );
  exit:
    *glyphWidth = advWidth;
    cf2_setError( &font->error, lastError );
    return font->error;
  }
