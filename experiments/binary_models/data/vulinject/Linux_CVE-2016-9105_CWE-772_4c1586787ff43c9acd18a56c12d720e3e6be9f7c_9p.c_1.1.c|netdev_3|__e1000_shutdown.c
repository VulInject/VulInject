static int __e1000_shutdown(struct pci_dev *pdev, bool runtime)
{
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	unsigned int ctrl, ctrl_ext, rctl, status, wufc;
	int retval = 0;
	unsigned short smb_ctrl;
	if (runtime)
		wufc = E1000_WUFC_LNKC;
	else if (device_may_wakeup(&pdev->dev))
		wufc = adapter->wol;
	else
		wufc = 0;
	status = er32(STATUS);
	if (status & E1000_STATUS_LU)
		wufc &= ~E1000_WUFC_LNKC;
	if (wufc) {
		e1000_setup_rctl(adapter);
		e1000e_set_rx_mode(netdev);
		if (wufc & E1000_WUFC_MC) {
			rctl = er32(RCTL);
			rctl |= E1000_RCTL_MPE;
		}
		ctrl = er32(CTRL);
		ctrl |= E1000_CTRL_ADVD3WUC;
		if (!(adapter->flags2 & FLAG2_HAS_PHY_WAKEUP))
			ctrl |= E1000_CTRL_EN_PHY_PWR_MGMT;
		ew32(CTRL, ctrl);
		if (adapter->hw.phy.media_type == e1000_media_type_fiber ||
		    adapter->hw.phy.media_type ==
		    e1000_media_type_internal_serdes) {
			ctrl_ext = er32(CTRL_EXT);
			ctrl_ext |= E1000_CTRL_EXT_SDP3_DATA;
			ew32(CTRL_EXT, ctrl_ext);
		}
		if (!runtime)
			e1000e_power_up_phy(adapter);
		if (adapter->flags & FLAG_IS_ICH)
			e1000_suspend_workarounds_ich8lan(&adapter->hw);
		if (adapter->flags2 & FLAG2_HAS_PHY_WAKEUP) {
			retval = e1000_init_phy_wakeup(adapter, wufc);
			if (retval)
				return retval;
		} else {
			ew32(WUFC, wufc);
			ew32(WUC, E1000_WUC_PME_EN);
		}
	} else {
		ew32(WUC, 0);
		ew32(WUFC, 0);
		e1000_power_down_phy(adapter);
	}
	if (adapter->hw.phy.type == e1000_phy_igp_3) {
		e1000e_igp3_phy_powerdown_workaround_ich8lan(&adapter->hw);
	} else if (hw->mac.type >= e1000_pch_lpt) {
		if (wufc && !(wufc & (E1000_WUFC_EX | E1000_WUFC_MC | E1000_WUFC_BC))) {
			retval = e1000_enable_ulp_lpt_lp(hw, !runtime);
			if (retval)
				return retval;
		}
		e1000e_disable_phy_retry(hw);
		e1e_rphy(hw, CV_SMB_CTRL, &smb_ctrl);
		smb_ctrl |= CV_SMB_CTRL_FORCE_SMBUS;
		e1e_wphy(hw, CV_SMB_CTRL, smb_ctrl);
		e1000e_enable_phy_retry(hw);
		ctrl_ext = er32(CTRL_EXT);
		ctrl_ext |= E1000_CTRL_EXT_FORCE_SMBUS;
		ew32(CTRL_EXT, ctrl_ext);
	}
	if ((hw->phy.type >= e1000_phy_i217) &&
	    adapter->eee_advert && hw->dev_spec.ich8lan.eee_lp_ability) {
		unsigned short lpi_ctrl = 0;
		retval = hw->phy.ops.acquire(hw);
		if (!retval) {
			retval = e1e_rphy_locked(hw, I82579_LPI_CTRL,
						 &lpi_ctrl);
			if (!retval) {
				if (adapter->eee_advert &
				    hw->dev_spec.ich8lan.eee_lp_ability &
				    I82579_EEE_100_SUPPORTED)
					lpi_ctrl |= I82579_LPI_CTRL_100_ENABLE;
				if (adapter->eee_advert &
				    hw->dev_spec.ich8lan.eee_lp_ability &
				    I82579_EEE_1000_SUPPORTED)
					lpi_ctrl |= I82579_LPI_CTRL_1000_ENABLE;
				retval = e1e_wphy_locked(hw, I82579_LPI_CTRL,
							 lpi_ctrl);
			}
		}
		hw->phy.ops.release(hw);
	}
	e1000e_release_hw_control(adapter);
	pci_clear_master(pdev);
	if (adapter->flags & FLAG_IS_QUAD_PORT) {
		struct pci_dev *us_dev = pdev->bus->self;
		unsigned short devctl;
		if (!us_dev)
			return 0;
		pcie_capability_read_word(us_dev, PCI_EXP_DEVCTL, &devctl);
		pcie_capability_write_word(us_dev, PCI_EXP_DEVCTL,
					   (devctl & ~PCI_EXP_DEVCTL_CERE));
		pci_save_state(pdev);
		pci_prepare_to_sleep(pdev);
		pcie_capability_write_word(us_dev, PCI_EXP_DEVCTL, devctl);
	}
	return 0;
}
