seafile_encrypt (char **data_out,
                 int *out_len,
                 const char *data_in,
                 const int in_len,
                 SeafileCrypt *crypt)
{
    char *buf = NULL, *enc_buf = NULL;
    int buf_size, remain;
    guint8 padding;
    gnutls_cipher_hd_t handle;
    gnutls_datum_t key, iv;
    int rc, ret = 0;
    buf_size = BLK_SIZE * ((in_len / BLK_SIZE) + 1);
    remain = buf_size - in_len;
    buf = g_new (char, buf_size);
    memcpy (buf, data_in, in_len);
    padding = (guint8)remain;
    memset (buf + in_len, padding, remain);
    key.data = crypt->key;
    key.size = sizeof(crypt->key);
    iv.data = crypt->iv;
    iv.size = sizeof(crypt->iv);
    rc = gnutls_cipher_init (&handle, GNUTLS_CIPHER_AES_256_CBC, &key, &iv);
    if (rc < 0) {
        seaf_warning ("Failed to init cipher: %s\n", gnutls_strerror(rc));
        ret = -1;
        goto out;
    }
    enc_buf = g_new (char, buf_size);
    rc = gnutls_cipher_encrypt2 (handle, buf, buf_size, enc_buf, buf_size);
    if (rc < 0) {
        seaf_warning ("Failed to encrypt: %s\n", gnutls_strerror(rc));
        ret = -1;
        goto out;
    }
    gnutls_cipher_deinit (handle);
out:
    g_free (buf);
    if (ret < 0) {
        g_free (enc_buf);
        *data_out = NULL;
        *out_len = -1;
    } else {
        *data_out = enc_buf;
        *out_len = buf_size;
    }
    return ret;
}
seafile_encrypt (char **data_out,
                 int *out_len,
                 const char *data_in,
                 const int in_len,
                 SeafileCrypt *crypt)
{
    *data_out = NULL;
    *out_len = -1;
    if ( data_in == NULL || in_len <= 0 || crypt == NULL) {
        seaf_warning ("Invalid params.\n");
        return -1;
    }
    EVP_CIPHER_CTX *ctx;
    int ret;
    int blks;
    ctx = EVP_CIPHER_CTX_new ();
    if (crypt->version == 1)
        ret = EVP_EncryptInit_ex (ctx,
                                  EVP_aes_128_cbc(), 
                                  NULL, 
                                  crypt->key,  
                                  crypt->iv);  
    else if (crypt->version == 3)
        ret = EVP_EncryptInit_ex (ctx,
                                  EVP_aes_128_ecb(), 
                                  NULL, 
                                  crypt->key,  
                                  crypt->iv);  
    else
        ret = EVP_EncryptInit_ex (ctx,
                                  EVP_aes_256_cbc(), 
                                  NULL, 
                                  crypt->key,  
                                  crypt->iv);  
    if (ret == ENC_FAILURE) {
        EVP_CIPHER_CTX_free (ctx);
        return -1;
    }
    blks = (in_len / BLK_SIZE) + 1;
    *data_out = (char *)g_malloc (blks * BLK_SIZE);
    if (*data_out == NULL) {
        seaf_warning ("failed to allocate the output buffer.\n");
        goto enc_error;
    }                
    int update_len, final_len;
    ret = EVP_EncryptUpdate (ctx,
                             (unsigned char*)*data_out,
                             &update_len,
                             (unsigned char*)data_in,
                             in_len);
    if (ret == ENC_FAILURE)
        goto enc_error;
    ret = EVP_EncryptFinal_ex (ctx,
                               (unsigned char*)*data_out + update_len,
                               &final_len);
    *out_len = update_len + final_len;
    if (ret == ENC_FAILURE || *out_len != (blks * BLK_SIZE))
        goto enc_error;
    EVP_CIPHER_CTX_free (ctx);
    return 0;
enc_error:
    EVP_CIPHER_CTX_free (ctx);
    *out_len = -1;
    if (*data_out != NULL)
        g_free (*data_out);
    *data_out = NULL;
    return -1;
}
