int zlib_deflate(
	z_streamp strm,
	int flush
)
{
    int old_flush; 
    deflate_state *s;
    if (strm == NULL || strm->state == NULL ||
	flush > Z_FINISH || flush < 0) {
        return Z_STREAM_ERROR;
    }
    s = (deflate_state *) strm->state;
    if ((strm->next_in == NULL && strm->avail_in != 0) ||
	(s->status == FINISH_STATE && flush != Z_FINISH)) {
        return Z_STREAM_ERROR;
    }
    if (strm->avail_out == 0) return Z_BUF_ERROR;
    s->strm = strm; 
    old_flush = s->last_flush;
    s->last_flush = flush;
    if (s->status == INIT_STATE) {
        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
        uInt level_flags = (s->level-1) >> 1;
        if (level_flags > 3) level_flags = 3;
        header |= (level_flags << 6);
	if (s->strstart != 0) header |= PRESET_DICT;
        header += 31 - (header % 31);
        s->status = BUSY_STATE;
	if (s->strstart != 0) {
	    putShortMSB(s, (uInt)(strm->adler >> 16));
	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
	}
	strm->adler = 1L;
    }
    if (s->pending != 0) {
        flush_pending(strm);
        if (strm->avail_out == 0) {
	    s->last_flush = -1;
	    return Z_OK;
	}
    } else if (strm->avail_in == 0 && flush <= old_flush &&
	       flush != Z_FINISH) {
        return Z_BUF_ERROR;
    }
    if (s->status == FINISH_STATE && strm->avail_in != 0) {
        return Z_BUF_ERROR;
    }
    if (strm->avail_in != 0 || s->lookahead != 0 ||
        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
        block_state bstate;
	bstate = DEFLATE_HOOK(strm, flush, &bstate) ? bstate :
		 (*(configuration_table[s->level].func))(s, flush);
        if (bstate == finish_started || bstate == finish_done) {
            s->status = FINISH_STATE;
        }
        if (bstate == need_more || bstate == finish_started) {
	    if (strm->avail_out == 0) {
	        s->last_flush = -1; 
	    }
	    return Z_OK;
	}
        if (bstate == block_done) {
            if (flush == Z_PARTIAL_FLUSH) {
                zlib_tr_align(s);
	    } else if (flush == Z_PACKET_FLUSH) {
		zlib_tr_stored_type_only(s);
            } else { 
                zlib_tr_stored_block(s, (char*)0, 0L, 0);
                if (flush == Z_FULL_FLUSH) {
                    CLEAR_HASH(s);             
                }
            }
            flush_pending(strm);
	    if (strm->avail_out == 0) {
	      s->last_flush = -1; 
	      return Z_OK;
	    }
        }
    }
    Assert(strm->avail_out > 0, "bug2");
    if (flush != Z_FINISH) return Z_OK;
    if (!s->noheader) {
	putShortMSB(s, (uInt)(strm->adler >> 16));
	putShortMSB(s, (uInt)(strm->adler & 0xffff));
    }
    flush_pending(strm);
    if (!s->noheader) {
	s->noheader = -1; 
    }
    if (s->pending == 0) {
	Assert(s->bi_valid == 0, "bi_buf not flushed");
	return Z_STREAM_END;
    }
    return Z_OK;
}
