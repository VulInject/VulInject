R_API char *r_io_stream_system(RIOStream *s, const char *cmd) {
	if (!s || R_STR_ISEMPTY (cmd)) {
		return NULL;
	}
	RStrBuf *sb = r_strbuf_new ("");
	RIOStreamItem *si;
	RListIter *iter;
	int i, count = 0;
	ut64 addr = 0;
	switch (*cmd) {
	case '*':
		r_list_foreach (s->log, iter, si) {
			if (s->mode == R_PERM_R && si->host) {
				continue;
			}
			if (s->mode == R_PERM_W && !si->host) {
				continue;
			}
			r_strbuf_append (sb, "wx+");
			for (i = 0; i < si->size; i++) {
				r_strbuf_appendf (sb, "%02x", si->data[i]);
			}
			r_strbuf_append (sb, "\n");
			count++;
		}
		break;
	case 'f':
		r_list_foreach (s->log, iter, si) {
			if (s->mode == R_PERM_R && si->host) {
				continue;
			}
			if (s->mode == R_PERM_W && !si->host) {
				continue;
			}
			r_strbuf_appendf (sb, "f msg.%d.%s %"PFMT64d" %d\n",
				count, si->host? "w": "r", addr, si->size);
			count++;
			addr += si->size;
		}
		break;
	case 'p':
		if (cmd[1] == 'x') {
			r_list_foreach (s->log, iter, si) {
				r_strbuf_appendf (sb, "%s (%.2d)", si->host? "H>": "D<", si->size);
				for (i = 0; i < si->size; i++) {
					r_strbuf_appendf (sb, " %02x", si->data[i]);
				}
				r_strbuf_append (sb, "\n");
			}
		} else {
			r_strbuf_append (sb, o);
			free (o);
		}
		break;
	case 'r':
		if (cmd[1] == 'w') {
			s->mode = R_PERM_RW;
		} else {
			s->mode = R_PERM_R;
		}
		update_buffer (s);
		break;
	case 'w':
		s->mode = R_PERM_W;
		update_buffer (s);
		break;
	default:
	case '?':
		r_strbuf_append (sb, "Usage: :[cmd ..]\n");
		r_strbuf_append (sb, ":f         # print flags for current mode\n");
		r_strbuf_append (sb, ":*         # show write commands to fill the buffer\n");
		r_strbuf_append (sb, ":r         # only show the read ops\n");
		r_strbuf_append (sb, ":w         # only show the write ops\n");
		r_strbuf_append (sb, ":rw        # show read and write ops\n");
		r_strbuf_append (sb, ":p         # print two column ascii art of the communication\n");
		r_strbuf_append (sb, ":px        # print (H)ost/(D)est communication in hex per line\n");
		break;
	}
	return r_strbuf_drain (sb);
}
