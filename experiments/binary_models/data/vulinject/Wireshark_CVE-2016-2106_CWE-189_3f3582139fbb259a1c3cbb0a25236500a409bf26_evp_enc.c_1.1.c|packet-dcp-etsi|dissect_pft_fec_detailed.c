dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
  guint32 findex _U_,
  guint32 fcount,
  guint16 seq,
  gint offset,
  guint16 plen,
  gboolean fec _U_,
  guint16 rsk,
  guint16 rsz,
  fragment_head *fdx
)
{
  guint32 decoded_size;
  guint32 c_max;
  guint32 rx_min;
  tvbuff_t *new_tvb=NULL;
  if (fcount > MAX_FRAGMENTS) {
    proto_tree_add_expert_format(tree, pinfo, &ei_edcp_reassembly, tvb , 0, -1, "[Reassembly of %d fragments not attempted]", fcount);
    return NULL;
  }
  decoded_size = fcount*plen;
  c_max = fcount*plen/(rsk+PFT_RS_P);  
  rx_min = fcount - (c_max*PFT_RS_P/plen);
  if (fdx)
    new_tvb = process_reassembled_data (tvb, offset, pinfo,
                                        "Reassembled DCP (ETSI)",
                                        fdx, &dcp_frag_items,
                                        NULL, tree);
  else {
    guint fragments=0;
    guint32 *got;
    fragment_item *fd;
    fragment_head *fd_head;
    proto_tree_add_expert_format(tree, pinfo, &ei_edcp_reassembly_info, tvb, 0, -1, "want %d, got %d need %d",
                           fcount, fragments, rx_min);
    got = (guint32 *)wmem_alloc(pinfo->pool, fcount*sizeof(guint32));
    fd_head = fragment_get(&dcp_reassembly_table, pinfo, seq, NULL);
    if (fd_head) {
      for (fd = fd_head->next; fd != NULL && fragments < fcount; fd = fd->next) {
        if(fd->tvb_data) {
          got[fragments++] = fd->offset; 
        }
      }
    }
    if(fragments>=rx_min) { 
      guint i,current_findex;
      fragment_head *frag=NULL;
      guint8 *dummy_data = (guint8*) wmem_alloc0 (pinfo->pool, plen);
      tvbuff_t *dummytvb = tvb_new_real_data(dummy_data, plen, plen);
      proto_tree_add_expert_format(tree, pinfo, &ei_edcp_reassembly_info, tvb, 0, -1, "want %d, got %d need %d",
                               fcount, fragments, rx_min);
      current_findex = 0;
      for(i=0; i<fragments; i++) {
        guint next_fragment_we_have = got[i];
        if (next_fragment_we_have > MAX_FRAGMENTS) {
          proto_tree_add_expert_format(tree, pinfo, &ei_edcp_reassembly, tvb , 0, -1, "[Reassembly of %d fragments not attempted]", next_fragment_we_have);
          return NULL;
        }
        if (current_findex + MAX_FRAG_GAP < next_fragment_we_have) {
          proto_tree_add_expert_format(tree, pinfo, &ei_edcp_reassembly, tvb, 0, -1,
              "[Missing %d consecutive packets. Don't attempt reassembly]",
              next_fragment_we_have-current_findex);
          return NULL;
        }
        for(; current_findex<next_fragment_we_have; current_findex++) {
          frag = fragment_add_seq_check (&dcp_reassembly_table,
                                         dummytvb, 0, pinfo, seq, NULL,
                                         current_findex, plen, (current_findex+1!=fcount));
        }
        current_findex++; 
      }
      tvb_free(dummytvb);
      if(frag)
        new_tvb = process_reassembled_data (tvb, offset, pinfo,
                                            "Reassembled DCP (ETSI)",
                                            frag, &dcp_frag_items,
                                            NULL, tree);
    }
  }
  if(new_tvb && tvb_captured_length(new_tvb) > 0) {
    gboolean decoded;
    tvbuff_t *dtvb = NULL;
    const guint8 *input = tvb_get_ptr(new_tvb, 0, -1);
    guint32 reassembled_size = tvb_captured_length(new_tvb);
    guint8 *deinterleaved = (guint8*) wmem_alloc(pinfo->pool, reassembled_size);
    guint8 *output = (guint8*) wmem_alloc(pinfo->pool, decoded_size);
    rs_deinterleave(input, deinterleaved, plen, fcount);
    dtvb = tvb_new_child_real_data(tvb, deinterleaved, reassembled_size, reassembled_size);
    add_new_data_source(pinfo, dtvb, "Deinterleaved");
    decoded = rs_correct_data(deinterleaved, output, c_max, rsk, rsz);
    proto_tree_add_boolean (tree, hf_edcp_rs_ok, tvb, offset, 2, decoded);
    new_tvb = tvb_new_child_real_data(dtvb, output, decoded_size, decoded_size);
    add_new_data_source(pinfo, new_tvb, "RS Error Corrected Data");
  }
  return new_tvb;
}
