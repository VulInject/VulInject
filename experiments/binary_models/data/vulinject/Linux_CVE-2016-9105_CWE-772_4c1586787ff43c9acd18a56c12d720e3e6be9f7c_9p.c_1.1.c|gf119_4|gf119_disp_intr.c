gf119_disp_intr(struct nvkm_disp *disp)
{
	struct nvkm_subdev *subdev = &disp->engine.subdev;
	struct nvkm_device *device = subdev->device;
	struct nvkm_head *head;
	unsigned int intr = nvkm_rd32(device, 0x610088);
	if (intr & 0x00000001) {
		unsigned int stat = nvkm_rd32(device, 0x61008c);
		while (stat) {
			int chid = __ffs(stat); stat &= ~(1 << chid);
			nvkm_wr32(device, 0x61008c, 1 << chid);
		}
		intr &= ~0x00000001;
	}
	if (intr & 0x00000002) {
		unsigned int stat = nvkm_rd32(device, 0x61009c);
		int chid = ffs(stat) - 1;
		if (chid >= 0)
			disp->func->intr_error(disp, chid);
		intr &= ~0x00000002;
	}
	if (intr & 0x00100000) {
		unsigned int stat = nvkm_rd32(device, 0x6100ac);
		if (stat & 0x00000007) {
			disp->super.pending = (stat & 0x00000007);
			queue_work(disp->super.wq, &disp->super.work);
			nvkm_wr32(device, 0x6100ac, disp->super.pending);
			stat &= ~0x00000007;
		}
		if (stat) {
			nvkm_warn(subdev, "intr24 %08x\n", stat);
			nvkm_wr32(device, 0x6100ac, stat);
		}
		intr &= ~0x00100000;
	}
	list_for_each_entry(head, &disp->heads, head) {
		const unsigned int hoff = head->id * 0x800;
		unsigned int mask = 0x01000000 << head->id;
		if (mask & intr) {
			unsigned int stat = nvkm_rd32(device, 0x6100bc + hoff);
			if (stat & 0x00000001)
				nvkm_disp_vblank(disp, head->id);
			nvkm_mask(device, 0x6100bc + hoff, 0, 0);
			nvkm_rd32(device, 0x6100c0 + hoff);
		}
	}
}
