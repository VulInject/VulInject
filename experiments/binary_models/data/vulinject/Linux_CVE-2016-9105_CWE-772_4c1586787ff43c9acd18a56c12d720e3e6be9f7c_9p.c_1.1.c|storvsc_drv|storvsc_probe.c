static int storvsc_probe(struct hv_device *device,
			const struct hv_vmbus_device_id *dev_id)
{
	int ret;
	int num_cpus = num_online_cpus();
	int num_present_cpus = num_present_cpus();
	struct Scsi_Host *host;
	struct hv_host_device *host_dev;
	bool dev_is_ide = ((dev_id->driver_data == IDE_GUID) ? true : false);
	bool is_fc = ((dev_id->driver_data == SFC_GUID) ? true : false);
	int target = 0;
	struct storvsc_device *stor_device;
	int max_sub_channels = 0;
	unsigned int max_xfer_bytes;
	if (!dev_is_ide)
		max_sub_channels =
			(num_cpus - 1) / storvsc_vcpus_per_sub_channel;
	scsi_driver.can_queue = max_outstanding_req_per_channel *
				(max_sub_channels + 1) *
				(100 - ring_avail_percent_lowater) / 100;
	host = scsi_host_alloc(&scsi_driver,
			       sizeof(struct hv_host_device));
	if (!host)
		return -ENOMEM;
	host_dev = shost_priv(host);
	memset(host_dev, 0, sizeof(struct hv_host_device));
	host_dev->port = host->host_no;
	host_dev->dev = device;
	host_dev->host = host;
	stor_device = kzalloc(sizeof(struct storvsc_device), GFP_KERNEL);
	if (!stor_device) {
		ret = -ENOMEM;
		goto err_out0;
	}
	stor_device->destroy = false;
	init_waitqueue_head(&stor_device->waiting_to_drain);
	stor_device->device = device;
	stor_device->host = host;
	hv_set_drvdata(device, stor_device);
	dma_set_min_align_mask(&device->device, HV_HYP_PAGE_SIZE - 1);
	stor_device->port_number = host->host_no;
	ret = storvsc_connect_to_vsp(device, aligned_ringbuffer_size, is_fc);
	if (ret)
		goto err_out1;
	host_dev->path = stor_device->path_id;
	host_dev->target = stor_device->target_id;
	switch (dev_id->driver_data) {
	case SFC_GUID:
		host->max_lun = STORVSC_FC_MAX_LUNS_PER_TARGET;
		host->max_id = STORVSC_FC_MAX_TARGETS;
		host->max_channel = STORVSC_FC_MAX_CHANNELS - 1;
#if IS_ENABLED(CONFIG_SCSI_FC_ATTRS)
		host->transportt = fc_transport_template;
#endif
		break;
	case SCSI_GUID:
		host->max_lun = STORVSC_MAX_LUNS_PER_TARGET;
		host->max_id = STORVSC_MAX_TARGETS;
		host->max_channel = STORVSC_MAX_CHANNELS - 1;
		break;
	default:
		host->max_lun = STORVSC_IDE_MAX_LUNS_PER_TARGET;
		host->max_id = STORVSC_IDE_MAX_TARGETS;
		host->max_channel = STORVSC_IDE_MAX_CHANNELS - 1;
		break;
	}
	host->max_cmd_len = STORVSC_MAX_CMD_LEN;
	max_xfer_bytes = round_down(stor_device->max_transfer_bytes, HV_HYP_PAGE_SIZE);
	if (is_fc)
		max_xfer_bytes = min(max_xfer_bytes, STORVSC_FC_MAX_XFER_SIZE);
	host->max_sectors = max_xfer_bytes >> 9;
	host->sg_tablesize = (max_xfer_bytes >> HV_HYP_PAGE_SHIFT) + 1;
	if (!dev_is_ide) {
		if (storvsc_max_hw_queues > num_present_cpus) {
			storvsc_max_hw_queues = 0;
			storvsc_log(device, STORVSC_LOGGING_WARN,
				"Resetting invalid storvsc_max_hw_queues value to default.\n");
		}
		if (storvsc_max_hw_queues)
			host->nr_hw_queues = storvsc_max_hw_queues;
		else
			host->nr_hw_queues = num_present_cpus;
	}
	host_dev->handle_error_wq =
			alloc_ordered_workqueue("storvsc_error_wq_%d",
						0,
						host->host_no);
	if (!host_dev->handle_error_wq) {
		ret = -ENOMEM;
		goto err_out2;
	}
	INIT_WORK(&host_dev->host_scan_work, storvsc_host_scan);
	ret = scsi_add_host(host, &device->device);
	if (ret != 0)
		goto err_out3;
	if (!dev_is_ide) {
		scsi_scan_host(host);
	} else {
		target = (device->dev_instance.b[5] << 8 |
			 device->dev_instance.b[4]);
		ret = scsi_add_device(host, 0, target, 0);
		if (ret)
			goto err_out4;
	}
#if IS_ENABLED(CONFIG_SCSI_FC_ATTRS)
	if (host->transportt == fc_transport_template) {
		struct fc_rport_identifiers ids = {
			.roles = FC_PORT_ROLE_FCP_DUMMY_INITIATOR,
		};
		fc_host_node_name(host) = stor_device->node_name;
		fc_host_port_name(host) = stor_device->port_name;
		stor_device->rport = fc_remote_port_add(host, 0, &ids);
		if (!stor_device->rport) {
			ret = -ENOMEM;
			goto err_out4;
		}
	}
#endif
	return 0;
err_out4:
	scsi_remove_host(host);
err_out3:
	destroy_workqueue(host_dev->handle_error_wq);
err_out2:
	storvsc_dev_remove(device);
	goto err_out0;
err_out1:
	kfree(stor_device->stor_chns);
	kfree(stor_device);
err_out0:
	scsi_host_put(host);
	return ret;
}
