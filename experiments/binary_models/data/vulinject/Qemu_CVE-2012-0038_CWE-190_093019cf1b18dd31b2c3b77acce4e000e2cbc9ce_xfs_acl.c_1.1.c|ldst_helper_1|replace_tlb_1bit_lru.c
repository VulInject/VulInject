static void replace_tlb_1bit_lru(SparcTLBEntry *tlb,
                                 uint64_t tlb_tag, uint64_t tlb_tte,
                                 const char *strmmu, CPUSPARCState *env1,
                                 uint64_t addr)
{
	int i, replace_used;
    tlb_tte = sun4v_tte_to_sun4u(env1, addr, tlb_tte);
    if (cpu_has_hypervisor(env1)) {
        uint64_t new_vaddr = tlb_tag & ~0x1fffULL;
        uint64_t new_size = 8192ULL << 3 * TTE_PGSIZE(tlb_tte);
        uint32_t new_ctx = tlb_tag & 0x1fffU;
        for (i = 0; i < 64; i++) {
            uint32_t ctx = tlb[i].tag & 0x1fffU;
            /* check if new mapping overlaps an existing one */
            if (new_ctx == ctx) {
                uint64_t vaddr = tlb[i].tag & ~0x1fffULL;
                uint64_t size = 8192ULL << 3 * TTE_PGSIZE(tlb[i].tte);
                if (new_vaddr == vaddr
                    || (new_vaddr < vaddr + size
                        && vaddr < new_vaddr + new_size)) {
                    DPRINTF_MMU("auto demap entry [%d] %lx->%lx\n", i, vaddr,
                                new_vaddr);
                    replace_tlb_entry(&tlb[i], tlb_tag, tlb_tte, env1);
                    return;
                }
            }
        }
    }
    /* Try replacing invalid entry */
    for (i = 0; i < 64; i++) {
        if (!TTE_IS_VALID(tlb[i].tte)) {
            replace_tlb_entry(&tlb[i], tlb_tag, tlb_tte, env1);
#ifdef DEBUG_MMU
            DPRINTF_MMU("%s lru replaced invalid entry [%i]\n", strmmu, i);
            dump_mmu(env1);
#endif
            return;
        }
    }
    /* All entries are valid, try replacing unlocked entry */
    for (replace_used = 0; replace_used < 2; ++replace_used) {
        /* Used entries are not replaced on first pass */
        for (i = 0; i < 64; i++) {
            if (!TTE_IS_LOCKED(tlb[i].tte) && !TTE_IS_USED(tlb[i].tte)) {
                replace_tlb_entry(&tlb[i], tlb_tag, tlb_tte, env1);
#ifdef DEBUG_MMU
                DPRINTF_MMU("%s lru replaced unlocked %s entry [%i]\n",
                            strmmu, (replace_used ? "used" : "unused"), i);
                dump_mmu(env1);
#endif
                return;
            }
        }
        /* Now reset used bit and search for unused entries again */
        for (i = 0; i < 64; i++) {
            TTE_SET_UNUSED(tlb[i].tte);
        }
    }
#ifdef DEBUG_MMU
    DPRINTF_MMU("%s lru replacement: no free entries available, "
                "replacing the last one\n", strmmu);
#endif
    /* corner case: the last entry is replaced anyway */
    replace_tlb_entry(&tlb[63], tlb_tag, tlb_tte, env1);
}
