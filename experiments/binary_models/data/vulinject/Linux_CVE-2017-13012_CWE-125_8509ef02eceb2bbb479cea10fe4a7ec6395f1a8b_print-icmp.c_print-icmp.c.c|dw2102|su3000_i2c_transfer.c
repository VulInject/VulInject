static int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],
			       int num)
{
	struct dvb_usb_device *d = i2c_get_adapdata(adap);
	struct dw2102_state *state;
	int j;
	if (!d)
		return -ENODEV;
	state = d->priv;
	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
		return -EAGAIN;
	if (mutex_lock_interruptible(&d->data_mutex) < 0) {
		return -EAGAIN;
	}
	j = 0;
	while (j < num) {
		switch (msg[j].addr) {
		case SU3000_STREAM_CTRL:
			state->data[0] = msg[j].buf[0] + 0x36;
			state->data[1] = 3;
			state->data[2] = 0;
			if (dvb_usb_generic_rw(d, state->data, 3,
					       state->data, 0, 0) < 0)
				err("i2c transfer failed.");
			break;
		case DW2102_RC_QUERY:
			state->data[0] = 0x10;
			if (dvb_usb_generic_rw(d, state->data, 1,
					       state->data, 2, 0) < 0)
				err("i2c transfer failed.");
			msg[j].buf[1] = state->data[0];
			msg[j].buf[0] = state->data[1];
			break;
		default:
			if ((j + 1 < num) && (msg[j + 1].flags & I2C_M_RD) &&
			    (msg[j].addr == msg[j + 1].addr)) {
				if (4 + msg[j].len > sizeof(state->data)) {
					warn("i2c combined wr/rd: write len=%d is too big!\n",
					     msg[j].len);
					num = -EOPNOTSUPP;
					break;
				}
				if (1 + msg[j + 1].len > sizeof(state->data)) {
					warn("i2c combined wr/rd: read len=%d is too big!\n",
					    msg[j + 1].len);
					num = -EOPNOTSUPP;
					break;
				}
				state->data[0] = 0x09;
				state->data[1] = msg[j].len;
				state->data[2] = msg[j + 1].len;
				state->data[3] = msg[j].addr;
				memcpy(&state->data[4], msg[j].buf, msg[j].len);
				if (dvb_usb_generic_rw(d, state->data, msg[j].len + 4,
					state->data, msg[j + 1].len + 1, 0) < 0)
					err("i2c transfer failed.");
				memcpy(msg[j + 1].buf, &state->data[1], msg[j + 1].len);
				j++;
				break;
			}
			if (msg[j].flags & I2C_M_RD) {
				if (4 + msg[j].len > sizeof(state->data)) {
					warn("i2c rd: len=%d is too big!\n", msg[j].len);
					num = -EOPNOTSUPP;
					break;
				}
				state->data[0] = 0x09;
				state->data[1] = 0;
				state->data[2] = msg[j].len;
				state->data[3] = msg[j].addr;
				memcpy(&state->data[4], msg[j].buf, msg[j].len);
				if (dvb_usb_generic_rw(d, state->data, 4,
						       state->data, msg[j].len + 1, 0) < 0)
					err("i2c transfer failed.");
				memcpy(msg[j].buf, &state->data[1], msg[j].len);
				break;
			}
			if (3 + msg[j].len > sizeof(state->data)) {
				warn("i2c wr: len=%d is too big!\n", msg[j].len);
				num = -EOPNOTSUPP;
				break;
			}
			state->data[0] = 0x08;
			state->data[1] = msg[j].addr;
			state->data[2] = msg[j].len;
			memcpy(&state->data[3], msg[j].buf, msg[j].len);
			if (dvb_usb_generic_rw(d, state->data, msg[j].len + 3,
					       state->data, 1, 0) < 0)
				err("i2c transfer failed.");
		} 
		j++;
	} 
	mutex_unlock(&d->data_mutex);
	mutex_unlock(&d->i2c_mutex);
	return num;
}
