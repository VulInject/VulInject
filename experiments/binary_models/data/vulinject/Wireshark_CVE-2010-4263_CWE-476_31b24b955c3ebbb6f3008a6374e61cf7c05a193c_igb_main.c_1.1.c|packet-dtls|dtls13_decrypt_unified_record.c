static gboolean dtls13_decrypt_unified_record(tvbuff_t *tvb, packet_info *pinfo, guint32 hdr_off, unsigned int hdr_size,
                                              unsigned char hdr_flags, gboolean is_from_server,
                                              SslDecryptSession *ssl, guint32 dtls_record_length, guint8 curr_layer_num_ssl,
                                              unsigned short seq_suffix)
{
  unsigned char mask[DTLS13_RECORD_NUMBER_MASK_SZ];
  unsigned int int epoch, curr_max_epoch;
  unsigned int int sequence_number;
  unsigned int cid_length;
  unsigned char seq_length;
  SslDecoder *dec;
  epoch = (hdr_flags & DTLS13_HDR_EPOCH_BIT_MASK);
  seq_length = (hdr_flags & DTLS13_L_BIT_MASK) ? 2 : 1;
  if (dtls_record_length < 16) {
      ssl_debug_printf("dtls13: record too short\n");
      return FALSE;
  }
  curr_max_epoch = ssl->session.dtls13_current_epoch[is_from_server];
  if ((curr_max_epoch & 0x3) != epoch) {
    if (curr_max_epoch < 4) {
      if (epoch > curr_max_epoch) {
        ssl->session.dtls13_current_epoch[is_from_server] = epoch;
      }
    } else {
      epoch = (curr_max_epoch & ~(0x3)) | epoch;
      if (epoch > curr_max_epoch)
        epoch -= 4;
    }
  } else {
    epoch = curr_max_epoch;
  }
  if (epoch == 0) {
      ssl_debug_printf("dtls13: unified header with epoch 0 (plaintext)\n");
      return FALSE;
  }
  if (dtls13_load_keys_from_epoch(ssl, is_from_server, epoch) < 0) {
      ssl_debug_printf("dtls13: can't load keys\n");
      return FALSE;
  }
  dec = NULL;
	if (is_from_server)
    dec = ssl->server;
  } else if (ssl->client) {
