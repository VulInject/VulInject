static int bond_slave_netdev_event(unsigned int event,
				   struct net_device *slave_dev)
{
	struct slave *slave = bond_slave_get_rtnl(slave_dev), *primary;
	struct bonding *bond;
	struct net_device *bond_dev;
	if (!slave) {
		netdev_dbg(slave_dev, "%s called on NULL slave\n", __func__);
		return NOTIFY_DONE;
	}
	bond_dev = slave->bond->dev;
	bond = slave->bond;
	primary = rtnl_dereference(bond->primary_slave);
	slave_dbg(bond_dev, slave_dev, "%s called\n", __func__);
	switch (event) {
	case NETDEV_UNREGISTER:
		if (bond_dev->type != ARPHRD_ETHER)
			bond_release_and_destroy(bond_dev, slave_dev);
		else
			__bond_release_one(bond_dev, slave_dev, false, true);
		break;
	case NETDEV_UP:
	case NETDEV_CHANGE:
		if (bond_update_speed_duplex(slave) &&
		    BOND_MODE(bond) == BOND_MODE_8023AD) {
			if (slave->last_link_up)
				slave->link = BOND_LINK_FAIL;
			else
				slave->link = BOND_LINK_DOWN;
		}
		if (BOND_MODE(bond) == BOND_MODE_8023AD)
			bond_3ad_adapter_speed_duplex_changed(slave);
		fallthrough;
	case NETDEV_DOWN:
		if (bond_mode_can_use_xmit_hash(bond))
			bond_update_slave_arr(bond, NULL);
		break;
	case NETDEV_CHANGEMTU:
		break;
	case NETDEV_CHANGENAME:
		if (!bond_uses_primary(bond) ||
		    !bond->params.primary[0])
			break;
		if (slave == primary) {
		} else if (!strcmp(slave_dev->name, bond->params.primary)) {
			rcu_assign_pointer(bond->primary_slave, slave);
		} else { 
			break;
		}
		netdev_info(bond->dev, "Primary slave changed to %s, reselecting active slave\n",
			    primary ? slave_dev->name : "none");
		block_netpoll_tx();
		bond_select_active_slave(bond);
		unblock_netpoll_tx();
		break;
	case NETDEV_FEAT_CHANGE:
		if (!bond->notifier_ctx) {
			bond->notifier_ctx = true;
			bond_compute_features(bond);
			bond->notifier_ctx = false;
		}
		break;
	case NETDEV_RESEND_IGMP:
		call_netdevice_notifiers(event, slave->bond->dev);
		break;
	case NETDEV_XDP_FEAT_CHANGE:
		bond_xdp_set_features(bond_dev);
		break;
	default:
		break;
	}
	return NOTIFY_DONE;
}
