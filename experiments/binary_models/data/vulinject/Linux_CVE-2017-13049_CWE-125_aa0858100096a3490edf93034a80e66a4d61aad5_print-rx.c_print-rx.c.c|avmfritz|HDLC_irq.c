HDLC_irq(struct bchannel *bch, unsigned int stat)
{
	struct fritzcard *fc = bch->hw;
	int		len, fs;
	unsigned int		rmlMask;
	struct hdlc_hw	*hdlc;
	hdlc = &fc->hdlc[(bch->nr - 1) & 1];
	pr_debug("%s: ch%d stat %#x\n", fc->name, bch->nr, stat);
	if (fc->type == AVM_FRITZ_PCIV2) {
		rmlMask = HDLC_STAT_RML_MASK_V2;
		fs = HDLC_FIFO_SIZE_V2;
	} else {
		rmlMask = HDLC_STAT_RML_MASK_V1;
		fs = HDLC_FIFO_SIZE_V1;
	}
	if (stat & HDLC_INT_RPR) {
		if (stat & HDLC_STAT_RDO) {
			pr_warn("%s: ch%d stat %x RDO\n",
				fc->name, bch->nr, stat);
			hdlc->ctrl.sr.xml = 0;
			hdlc->ctrl.sr.cmd |= HDLC_CMD_RRS;
			write_ctrl(bch, 1);
			hdlc->ctrl.sr.cmd &= ~HDLC_CMD_RRS;
			write_ctrl(bch, 1);
			if (bch->rx_skb)
				skb_trim(bch->rx_skb, 0);
		} else {
			len = (stat & rmlMask) >> 8;
			if (!len)
				len = fs;
			hdlc_empty_fifo(bch, len);
			if (!bch->rx_skb)
				goto handle_tx;
			if (test_bit(FLG_TRANSPARENT, &bch->Flags)) {
				recv_Bchannel(bch, 0, false);
			} else if (stat & HDLC_STAT_RME) {
				if ((stat & HDLC_STAT_CRCVFRRAB) ==
				    HDLC_STAT_CRCVFR) {
					recv_Bchannel(bch, 0, false);
				} else {
					pr_warn("%s: got invalid frame\n",
						fc->name);
					skb_trim(bch->rx_skb, 0);
				}
			}
		}
	}
handle_tx:
	if (stat & HDLC_INT_XDU) {
		pr_warn("%s: ch%d stat %x XDU %s\n", fc->name, bch->nr,
			stat, bch->tx_skb ? "tx_skb" : "no tx_skb");
		if (bch->tx_skb && bch->tx_skb->len) {
			if (!test_bit(FLG_TRANSPARENT, &bch->Flags))
				bch->tx_idx = 0;
		} else if (test_bit(FLG_FILLEMPTY, &bch->Flags)) {
			test_and_set_bit(FLG_TX_EMPTY, &bch->Flags);
		}
		hdlc->ctrl.sr.xml = 0;
		hdlc->ctrl.sr.cmd |= HDLC_CMD_XRS;
		write_ctrl(bch, 1);
		hdlc->ctrl.sr.cmd &= ~HDLC_CMD_XRS;
		return;
	} else if (stat & HDLC_INT_XPR)
		HDLC_irq_xpr(bch);
}
