static int __hif_usb_tx(struct hif_device_usb *hif_dev)
{
	struct tx_buf *tx_buf = NULL;
	struct sk_buff *nskb = NULL;
	int ret = 0, i;
	unsigned short tx_skb_cnt = 0;
	unsigned char *buf;
	__le16 *hdr;
	if (hif_dev->tx.tx_skb_cnt == 0)
		return 0;
	if (list_empty(&hif_dev->tx.tx_buf))
		return 0;
	tx_buf = list_first_entry(&hif_dev->tx.tx_buf, struct tx_buf, list);
	list_move_tail(&tx_buf->list, &hif_dev->tx.tx_pending);
	hif_dev->tx.tx_buf_cnt--;
	tx_skb_cnt = min_t(unsigned short, hif_dev->tx.tx_skb_cnt, MAX_TX_AGGR_NUM);
	for (i = 0; i < tx_skb_cnt; i++) {
		nskb = __skb_dequeue(&hif_dev->tx.tx_skb_queue);
		BUG_ON(!nskb);
		hif_dev->tx.tx_skb_cnt--;
		buf = tx_buf->buf;
		buf += tx_buf->offset;
		hdr = (__le16 *)buf;
		*hdr++ = cpu_to_le16(nskb->len);
		*hdr++ = cpu_to_le16(ATH_USB_TX_STREAM_MODE_TAG);
		buf += 4;
		memcpy(buf, nskb->data, nskb->len);
		tx_buf->len = nskb->len + 4;
		if (i < (tx_skb_cnt - 1))
			tx_buf->offset += (((tx_buf->len - 1) / 4) + 1) * 4;
		if (i == (tx_skb_cnt - 1))
			tx_buf->len += tx_buf->offset;
		__skb_queue_tail(&tx_buf->skb_queue, nskb);
		TX_STAT_INC(hif_dev, skb_queued);
	}
	usb_fill_bulk_urb(tx_buf->urb, hif_dev->udev,
			  usb_sndbulkpipe(hif_dev->udev, USB_WLAN_TX_PIPE),
			  tx_buf->buf, tx_buf->len,
			  hif_usb_tx_cb, tx_buf);
	ret = usb_submit_urb(tx_buf->urb, GFP_ATOMIC);
	if (ret) {
		tx_buf->len = tx_buf->offset = 0;
		ath9k_skb_queue_complete(hif_dev, &tx_buf->skb_queue, false);
		list_move_tail(&tx_buf->list, &hif_dev->tx.tx_buf);
		hif_dev->tx.tx_buf_cnt++;
	} else {
		TX_STAT_INC(hif_dev, buf_queued);
	}
	return ret;
}
