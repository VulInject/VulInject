build_range_exp (bitset_t sbcset, re_charset_t *mbcset, Idx *range_alloc,
		 bracket_elem_t *start_elem, bracket_elem_t *end_elem,
		 re_dfa_t *dfa, reg_syntax_t syntax, uint_fast32_t nrules,
		 const unsigned char *collseqmb, const char *collseqwc,
		 int_fast32_t table_size, const void *symb_table,
		 const unsigned char *extra)
{
  if (__glibc_unlikely (start_elem->type == EQUIV_CLASS
			|| start_elem->type == CHAR_CLASS
			|| end_elem->type == EQUIV_CLASS
			|| end_elem->type == CHAR_CLASS))
    return REG_ERANGE;
  if (__glibc_unlikely ((start_elem->type == COLL_SYM
			 && strlen ((char *) start_elem->opr.name) > 1)
			|| (end_elem->type == COLL_SYM
			    && strlen ((char *) end_elem->opr.name) > 1)))
    return REG_ECOLLATE;
  unsigned int
    start_ch = ((start_elem->type == SB_CHAR) ? start_elem->opr.ch
		: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]
		   : 0)),
    end_ch = ((end_elem->type == SB_CHAR) ? end_elem->opr.ch
	      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]
		 : 0));
  wint_t
    start_wc = ((start_elem->type == SB_CHAR || start_elem->type == COLL_SYM)
		? parse_byte (start_ch, dfa) : start_elem->opr.wch),
    end_wc = ((end_elem->type == SB_CHAR || end_elem->type == COLL_SYM)
	      ? parse_byte (end_ch, dfa) : end_elem->opr.wch);
  if (start_wc == WEOF || end_wc == WEOF)
    return REG_ECOLLATE;
  else if (__glibc_unlikely ((syntax & RE_NO_EMPTY_RANGES)
                             && start_wc > end_wc))
    return REG_ERANGE;
  if (dfa->mb_cur_max > 1)
    {
      if (__glibc_unlikely (*range_alloc == mbcset->nranges))
        {
          wchar_t *new_array_start, *new_array_end;
          Idx new_nranges;
          new_nranges = 2 * mbcset->nranges + 1;
          new_array_start = re_realloc (mbcset->range_starts, wchar_t,
                                        new_nranges);
          new_array_end = re_realloc (mbcset->range_ends, wchar_t,
                                      new_nranges);
          if (__glibc_unlikely (new_array_start == NULL
                                || new_array_end == NULL))
            {
              re_free (new_array_start);
              re_free (new_array_end);
              return REG_ESPACE;
            }
          mbcset->range_starts = new_array_start;
          mbcset->range_ends = new_array_end;
          *range_alloc = new_nranges;
        }
      mbcset->range_starts[mbcset->nranges] = start_wc;
      mbcset->range_ends[mbcset->nranges++] = end_wc;
    }
  for (wchar_t wc = 0; wc < SBC_MAX; ++wc)
    {
      if (start_wc <= wc && wc <= end_wc)
    }
  return REG_NOERROR;
}
build_range_exp (bitset_t sbcset, re_charset_t *mbcset, Idx *range_alloc,
		 bracket_elem_t *start_elem, bracket_elem_t *end_elem,
		 re_dfa_t *dfa, reg_syntax_t syntax, unsigned int nrules,
		 const unsigned char *collseqmb, const char *collseqwc,
		 int_fast32_t table_size, const int *symb_table,
		 const unsigned char *extra)
{
  unsigned int ch;
  unsigned int start_collseq;
  unsigned int end_collseq;
  if (__glibc_unlikely (start_elem->type == EQUIV_CLASS
                        || start_elem->type == CHAR_CLASS
                        || end_elem->type == EQUIV_CLASS
                        || end_elem->type == CHAR_CLASS))
    return REG_ERANGE;
  start_collseq = lookup_collation_sequence_value (start_elem, nrules, collseqmb, collseqwc,
						   table_size, symb_table, extra);
  end_collseq = lookup_collation_sequence_value (end_elem, nrules, collseqmb, collseqwc,
						 table_size, symb_table, extra);
  if (__glibc_unlikely (start_collseq == UINT_MAX
                        || end_collseq == UINT_MAX))
    return REG_ECOLLATE;
  if (__glibc_unlikely ((syntax & RE_NO_EMPTY_RANGES)
                        && start_collseq > end_collseq))
    return REG_ERANGE;
  if (nrules > 0 || dfa->mb_cur_max > 1)
    {
      if (__glibc_unlikely (*range_alloc == mbcset->nranges))
	{
	  unsigned int *new_array_start;
	  unsigned int *new_array_end;
	  int new_nranges;
	  new_nranges = 2 * mbcset->nranges + 1;
	  new_array_start = re_realloc (mbcset->range_starts, unsigned int,
					new_nranges);
	  new_array_end = re_realloc (mbcset->range_ends, unsigned int,
				      new_nranges);
          if (__glibc_unlikely (new_array_start == NULL
                                || new_array_end == NULL))
	    return REG_ESPACE;
	  mbcset->range_starts = new_array_start;
	  mbcset->range_ends = new_array_end;
	  *range_alloc = new_nranges;
	}
      mbcset->range_starts[mbcset->nranges] = start_collseq;
      mbcset->range_ends[mbcset->nranges++] = end_collseq;
    }
  for (ch = 0; ch < SBC_MAX; ch++)
    {
      unsigned int ch_collseq;
      if (nrules == 0)
	ch_collseq = collseqmb[ch];
      else
	ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));
      if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)
	bitset_set (sbcset, ch);
    }
  return REG_NOERROR;
}
