static int stex_abort(struct scsi_cmnd *cmd)
{
	struct Scsi_Host *host = cmd->device->host;
	struct st_hba *hba = (struct st_hba *)host->hostdata;
	unsigned short tag = scsi_cmd_to_rq(cmd)->tag;
	void __iomem *base;
	unsigned int data;
	int result = SUCCESS;
	unsigned int flags;
	scmd_printk(KERN_INFO, cmd, "aborting command\n");
	base = hba->mmio_base;
	spin_lock_irqsave(host->host_lock, flags);
	if (tag < host->can_queue &&
		hba->ccb[tag].req && hba->ccb[tag].cmd == cmd)
		hba->wait_ccb = &hba->ccb[tag];
	else
		goto out;
	if (hba->cardtype == st_yel) {
		data = readl(base + YI2H_INT);
		if (data == 0 || data == 0xffffffff)
			goto fail_out;
		writel(data, base + YI2H_INT_C);
		stex_ss_mu_intr(hba);
	} else if (hba->cardtype == st_P3) {
		data = readl(base + PSCRATCH4);
		if (data == 0xffffffff)
			goto fail_out;
		if (data != 0) {
			writel(data, base + PSCRATCH1);
			writel((1 << 22), base + YH2I_INT);
		}
		stex_ss_mu_intr(hba);
	} else {
		data = readl(base + ODBL);
		if (data == 0 || data == 0xffffffff)
			goto fail_out;
		writel(data, base + ODBL);
		stex_mu_intr(hba, data);
	}
	if (hba->wait_ccb == NULL) {
		printk(KERN_WARNING DRV_NAME
			"(%s): lost interrupt\n", pci_name(hba->pdev));
		goto out;
	}
fail_out:
	scsi_dma_unmap(cmd);
	hba->wait_ccb->req = NULL; 
	hba->wait_ccb = NULL;
	result = FAILED;
out:
	spin_unlock_irqrestore(host->host_lock, flags);
	return result;
}
