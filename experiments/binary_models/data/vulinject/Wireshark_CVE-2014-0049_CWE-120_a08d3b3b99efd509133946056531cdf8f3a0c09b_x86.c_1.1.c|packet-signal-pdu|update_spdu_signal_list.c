update_spdu_signal_list(void *r, char **err) {
    gchar *tmp;
    guchar c;
    gdouble scaler;
    gdouble offset;
    spdu_signal_list_uat_t *rec = (spdu_signal_list_uat_t *)r;
    offset = g_ascii_strtod(rec->offset, &tmp);
    if (!(offset == offset)) {
        *err = ws_strdup_printf("Offset not a double!");
        return FALSE;
    }
    scaler = g_ascii_strtod(rec->scaler, &tmp);
    if (!(scaler == scaler)) {
        *err = ws_strdup_printf("Scaler not a double!");
        return FALSE;
    }
    if (rec->pos >= 0xffff) {
        *err = ws_strdup_printf("Position too big");
        return FALSE;
    }
    if (rec->num_of_params >= 0xffff) {
        *err = ws_strdup_printf("Number of Parameters too big");
        return FALSE;
    }
	if (rec->pos == rec->num_of_params) {
        *err = ws_strdup_printf("Position %u >= Number of Parameters %u (ID: 0x%x)", rec->pos, rec->num_of_params, rec->id);
        return FALSE;
    }
    if (rec->name == NULL || rec->name[0] == 0) {
        *err = ws_strdup_printf("Name cannot be empty");
        return FALSE;
    }
    if (rec->filter_string == NULL || rec->filter_string[0] == 0) {
        *err = ws_strdup_printf("Filter String cannot be empty");
        return FALSE;
    }
    c = proto_check_field_name(rec->filter_string);
    if (c) {
        if (c == '.') {
            *err = ws_strdup_printf("Filter String contains illegal chars '.' (ID: 0x%08x)", rec->id);
        } else if (g_ascii_isprint(c)) {
            *err = ws_strdup_printf("Filter String contains illegal chars '%c' (ID: 0x%08x)", c, rec->id);
        } else {
            *err = ws_strdup_printf("Filter String contains invalid byte \\%03o  (ID: 0x%08x)", c, rec->id);
        }
        return FALSE;
    }
    if (g_strcmp0(rec->data_type, "unsigned int") != 0 &&
        g_strcmp0(rec->data_type, "int") != 0 &&
        g_strcmp0(rec->data_type, "float") != 0 &&
        g_strcmp0(rec->data_type, "string") != 0 &&
        g_strcmp0(rec->data_type, "stringz") != 0 &&
        g_strcmp0(rec->data_type, "uint_string") != 0 &&
        g_strcmp0(rec->data_type, "utf_string") != 0 &&
        g_strcmp0(rec->data_type, "utf_stringz") != 0 &&
        g_strcmp0(rec->data_type, "utf_uint_string") != 0) {
            *err = ws_strdup_printf("Currently the only supported data types are unsigned int, int, float, string, stringz, uint_string, utf_string, utf_stringz, and utf_uint_string (ID: 0x%08x)", rec->id);
        return FALSE;
    }
    if (g_strcmp0(rec->data_type, "unsigned int") == 0) {
        if ((rec->bitlength_base_type != 8) && (rec->bitlength_base_type != 16) && (rec->bitlength_base_type != 32) && (rec->bitlength_base_type != 64)) {
            *err = ws_strdup_printf("Data type unsigned int is only supported as 8, 16, 32, or 64 bit base type (ID: 0x%08x)", rec->id);
            return FALSE;
        }
    }
    if (g_strcmp0(rec->data_type, "int") == 0) {
        if (rec->bitlength_base_type != rec->bitlength_encoded_type) {
            *err = ws_strdup_printf("Data type int is only supported in non-shortened length (ID: 0x%08x)", rec->id);
            return FALSE;
        }
        if ((rec->bitlength_encoded_type != 8) && (rec->bitlength_encoded_type != 16) && (rec->bitlength_encoded_type != 32) && (rec->bitlength_encoded_type != 64)) {
            *err = ws_strdup_printf("Data type int is only supported in 8, 16, 32, or 64 bit (ID: 0x%08x)", rec->id);
            return FALSE;
        }
    }
    if (g_strcmp0(rec->data_type, "float") == 0) {
        if (rec->bitlength_base_type != rec->bitlength_encoded_type) {
            *err = ws_strdup_printf("Data type float is only supported in non-shortened length (ID: 0x%08x)", rec->id);
            return FALSE;
        }
        if ((rec->bitlength_encoded_type != 32) && (rec->bitlength_encoded_type != 64)) {
            *err = ws_strdup_printf("Data type float is only supported in 32 or 64 bit (ID: 0x%08x)", rec->id);
            return FALSE;
        }
        if ((scaler != 1.0) || (offset != 0.0)) {
            *err = ws_strdup_printf("Data type float currently does not support scaling and offset (ID: 0x%08x)", rec->id);
            return FALSE;
        }
        if (rec->multiplexer == TRUE) {
            *err = ws_strdup_printf("Data type float currently cannot be used as multiplexer (ID: 0x%08x)", rec->id);
            return FALSE;
        }
    }
    if (g_strcmp0(rec->data_type, "string") == 0 || g_strcmp0(rec->data_type, "stringz") == 0 || g_strcmp0(rec->data_type, "uint_string") == 0 ||
        g_strcmp0(rec->data_type, "utf_string") == 0 || g_strcmp0(rec->data_type, "utf_stringz") == 0 || g_strcmp0(rec->data_type, "utf_uint_string") == 0) {
        if ((scaler != 1.0) || (offset != 0.0)) {
            *err = ws_strdup_printf("Data types string, stringz, uint_string, utf_string, utf_stringz, and utf_uint_string currently do not support scaling and offset (ID: 0x%08x)", rec->id);
            return FALSE;
        }
        if (rec->multiplexer == TRUE) {
            *err = ws_strdup_printf("Data types string, stringz, uint_string, utf_string, utf_stringz, and utf_uint_string currently cannot be used as multiplexer (ID: 0x%08x)", rec->id);
            return FALSE;
        }
        if ((g_strcmp0(rec->data_type, "string") == 0 || g_strcmp0(rec->data_type, "stringz") == 0 || g_strcmp0(rec->data_type, "uint_string") == 0) &&
            rec->bitlength_base_type != 8) {
            *err = ws_strdup_printf("Data types string, stringz, and uint_string only support 8 bit Bitlength base type since they are ASCII-based (ID: 0x%08x)", rec->id);
            return FALSE;
        }
        if ((g_strcmp0(rec->data_type, "utf_string") == 0 || g_strcmp0(rec->data_type, "utf_stringz") == 0 || g_strcmp0(rec->data_type, "utf_uint_string") == 0) &&
            rec->bitlength_base_type != 8 && rec->bitlength_base_type != 16) {
            *err = ws_strdup_printf("Data types utf_string, utf_stringz, and utf_uint_string only support Bitlength base type with 8 bit (UTF-8) or 16 bit (UTF-16) (ID: 0x%08x)", rec->id);
            return FALSE;
        }
        if ((g_strcmp0(rec->data_type, "stringz") == 0 || g_strcmp0(rec->data_type, "utf_stringz") == 0 ) &&
            (rec->bitlength_encoded_type != 0)) {
            *err = ws_strdup_printf("Data types stringz and utf_stringz only support Bitlength encoded with 0 bit since the length is determined by zero-termination (ID: 0x%08x)", rec->id);
            return FALSE;
        }
        if ((g_strcmp0(rec->data_type, "uint_string") == 0 || g_strcmp0(rec->data_type, "utf_uint_string") == 0) &&
            (rec->bitlength_encoded_type != 8) && (rec->bitlength_encoded_type != 16) && (rec->bitlength_encoded_type != 32) && (rec->bitlength_encoded_type != 64)) {
            *err = ws_strdup_printf("Data types uint_string and utf_uint_string only support Bitlength encoded with 8, 16, 32, or 64 bit since that defines the length of the length field (ID: 0x%08x)", rec->id);
            return FALSE;
        }
    }
    if (g_strcmp0(rec->data_type, "unsigned int") != 0 && g_strcmp0(rec->data_type, "int") != 0 && g_strcmp0(rec->data_type, "float") != 0 &&
        (rec->aggregate_sum || rec->aggregate_avg || rec->aggregate_int)) {
        *err = ws_strdup_printf("Aggregation is only allowed for unsigned int, int, and float (ID: 0x%08x)", rec->id);
        return FALSE;
    }
    return TRUE;
}
