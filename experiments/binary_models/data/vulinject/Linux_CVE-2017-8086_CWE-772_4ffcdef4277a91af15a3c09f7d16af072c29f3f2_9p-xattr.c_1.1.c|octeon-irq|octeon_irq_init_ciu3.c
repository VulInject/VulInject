static int __init octeon_irq_init_ciu3(struct device_node *ciu_node,
				       struct device_node *parent)
{
	int i, ret;
	int node;
	struct irq_domain *domain;
	struct octeon_ciu3_info *ciu3_info;
	struct resource res;
	unsigned int int base_addr;
	union cvmx_ciu3_const consts;
	node = 0; 
	ciu3_info = kzalloc_node(sizeof(*ciu3_info), GFP_KERNEL, node);
	if (!ciu3_info)
		return -ENOMEM;
	ret = of_address_to_resource(ciu_node, 0, &res);
	if (WARN_ON(ret))
		return ret;
	ciu3_info->ciu3_addr = base_addr = (unsigned int int)phys_to_virt(res.start);
	ciu3_info->node = node;
	consts.unsigned int int = cvmx_read_csr(base_addr + CIU3_CONST);
	octeon_irq_setup_secondary = octeon_irq_setup_secondary_ciu3;
	octeon_irq_ip2 = octeon_irq_ciu3_ip2;
	octeon_irq_ip3 = octeon_irq_ciu3_mbox;
	octeon_irq_ip4 = octeon_irq_ip4_mask;
	if (node == cvmx_get_node_num()) {
		octeon_irq_init_core();
		i = irq_alloc_descs_from(OCTEON_IRQ_MBOX0, 8, node);
		WARN_ON(i < 0);
		for (i = 0; i < 8; i++)
			irq_set_chip_and_handler(i + OCTEON_IRQ_MBOX0,
						 &octeon_irq_chip_ciu3_mbox, handle_percpu_irq);
	}
	domain = irq_domain_add_tree(ciu_node, &octeon_dflt_domain_ciu3_ops,
				     ciu3_info);
	for (i = 0; i < MAX_CIU3_DOMAINS; i++)
		ciu3_info->domain[i] = domain;
	octeon_ciu3_info_per_node[node] = ciu3_info;
	if (node == cvmx_get_node_num()) {
		if (node == 0)
			irq_set_default_host(domain);
		octeon_irq_use_ip4 = false;
		set_c0_status(STATUSF_IP2 | STATUSF_IP3);
		clear_c0_status(STATUSF_IP4);
	}
	return 0;
}
