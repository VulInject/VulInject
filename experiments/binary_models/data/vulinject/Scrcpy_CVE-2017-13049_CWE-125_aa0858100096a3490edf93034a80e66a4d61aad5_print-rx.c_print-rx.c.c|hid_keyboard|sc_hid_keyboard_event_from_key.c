sc_hid_keyboard_event_from_key(struct sc_hid_keyboard *hid,
                               struct sc_hid_event *hid_event,
                               const struct sc_key_event *event) {
    enum sc_scancode scancode = event->scancode;
    assert(scancode >= 0);
    // SDL also generates events when only modifiers are pressed, we cannot
    // ignore them totally, for example press 'a' first then press 'Control',
    // if we ignore 'Control' event, only 'a' is sent.
    if (scancode >= SC_HID_KEYBOARD_KEYS && !scancode_is_modifier(scancode)) {
        // Scancode to ignore
        return false;
    }
    uint16_t mods = sc_hid_mod_from_sdl_keymod(event->mods_state);
    if (scancode < SC_HID_KEYBOARD_KEYS) {
        // Pressed is true and released is false
        hid->keys[scancode] = (event->action == SC_ACTION_DOWN);
        LOGV("keys[%02x] = %s", scancode,
             hid->keys[scancode] ? "true" : "false");
    }
    hid_event->data[SC_HID_KEYBOARD_INDEX_MODS] = mods;
    uint8_t *keys_data = &hid_event->data[SC_HID_KEYBOARD_INDEX_KEYS];
    // Re-calculate pressed keys every time
    int keys_pressed_count = 0;
    for (int i = 0; i < SC_HID_KEYBOARD_KEYS; ++i) {
        if (hid->keys[i]) {
            // USB HID protocol says that if keys exceeds report count, a
            // phantom state should be reported
            if (keys_pressed_count >= SC_HID_KEYBOARD_MAX_KEYS) {
                // Phantom state:
                //  - Modifiers
                //  - Reserved
                //  - ErrorRollOver * HID_MAX_KEYS
                memset(keys_data, SC_HID_ERROR_ROLL_OVER,
                       SC_HID_KEYBOARD_MAX_KEYS);
                goto end;
            }
            keys_data[keys_pressed_count] = i;
            ++keys_pressed_count;
        }
    }
end:
    LOGV("hid keyboard: key %-4s scancode=%02x (%u) mod=%02x",
         event->action == SC_ACTION_DOWN ? "down" : "up", event->scancode,
         event->scancode, mods);
    return true;
}
