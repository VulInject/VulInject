dissect_beep_tree(tvbuff_t *tvb, int offset, packet_info *pinfo,
                  proto_tree *tree, struct beep_request_val *request_val,
                  struct beep_proto_data *beep_frame_data)
{
  proto_tree     *ti = NULL, *hdr = NULL;
  int            st_offset, msgno, ansno, seqno, size, channel, ackno, window, cc,
                 more;
  const char * cmd_temp = NULL;
  int is_ANS = 0;
  st_offset = offset;
  if (tvb_strneql(tvb, offset, "MSG ", 4) == 0)
    cmd_temp = "Command: MSG";
  if (tvb_strneql(tvb, offset, "RPY ", 4) == 0)
    cmd_temp = "Command: RPY";
  if (tvb_strneql(tvb, offset, "ERR ", 4) == 0)
    cmd_temp = "Command: ERR";
  if (tvb_strneql(tvb, offset, "NUL ", 4) == 0)
    cmd_temp = "Command: NUL";
  if (tvb_strneql(tvb, offset, "ANS ", 4) == 0) {
    cmd_temp = "Command: ANS";
    is_ANS = 1;
  }
  if (cmd_temp != NULL) {
    if (tree) {
      hdr = proto_tree_add_subtree(tree, tvb, offset, header_len(tvb, offset) + 2,
            ett_header, NULL, "Header");
      ti = proto_tree_add_item(hdr, hf_beep_cmd, tvb, offset, 3, ENC_NA|ENC_ASCII);
      proto_item_set_len(ti, 4);
      proto_tree_add_boolean(hdr, hf_beep_req, tvb, offset, 3, TRUE);
    }
    offset += 4;
    offset += dissect_beep_int(tvb, pinfo, offset, hdr, hf_beep_channel, &channel, req_chan_hfa);
    offset += 1; 
    offset += dissect_beep_int(tvb, pinfo, offset, hdr, hf_beep_msgno, &msgno, req_msgno_hfa);
    offset += 1; 
    if ((more = dissect_beep_more(tvb, pinfo, offset, hdr)) >= 0) {
      set_mime_hdr_flags(more, request_val, beep_frame_data, pinfo);
    }
    else {  
      if (tree && (tvb_reported_length_remaining(tvb, offset) > 0)) {
        proto_tree_add_item(tree, hf_beep_payload_undissected, tvb, offset,
                            tvb_reported_length_remaining(tvb, offset), ENC_NA|ENC_ASCII);
      }
      return -1;
    }
    offset += 2; 
    offset += dissect_beep_int(tvb, pinfo, offset, hdr, hf_beep_seqno, &seqno, req_seqno_hfa);
    offset += 1; 
    offset += dissect_beep_int(tvb, pinfo, offset, hdr, hf_beep_size, &size, req_size_hfa);
    if (request_val)   
      request_val -> size = size;  
    else if (beep_frame_data) {
      beep_frame_data->pl_size = size;
      if (beep_frame_data->pl_size < 0) beep_frame_data->pl_size = 0; 
    }
    if (is_ANS) { 
        offset += 1; 
        offset += dissect_beep_int(tvb, pinfo, offset, hdr, hf_beep_ansno, &ansno, req_ansno_hfa);
    }
    if ((cc = check_term(tvb, pinfo, offset, hdr)) <= 0) {
      if (tree && (tvb_reported_length_remaining(tvb, offset) > 0)) {
        proto_tree_add_item(tree, hf_beep_payload_undissected, tvb, offset,
                            tvb_reported_length_remaining(tvb, offset), ENC_NA|ENC_ASCII);
      }
      return -1;
    }
    offset += cc;
    if (beep_frame_data && beep_frame_data->mime_hdr)
      offset += dissect_beep_mime_header(tvb, pinfo, offset, beep_frame_data, hdr);
    if (tvb_reported_length_remaining(tvb, offset) > 0) { 
      int pl_size = MIN(size, tvb_reported_length_remaining(tvb, offset));
      if (tree) {
        proto_tree_add_item(tree, hf_beep_payload, tvb, offset, pl_size, ENC_NA|ENC_ASCII);
      }
      offset += pl_size;
      if (request_val) {
        request_val->size -= pl_size;
        if (request_val->size < 0) request_val->size = 0;
      }
      else if (beep_frame_data) {
        beep_frame_data->pl_size -= pl_size;
        if (beep_frame_data->pl_size < 0) beep_frame_data->pl_size = 0;
      }
    }
    if (tvb_reported_length_remaining(tvb, offset) > 0) {
      offset += dissect_beep_tree(tvb, offset, pinfo, tree, request_val, beep_frame_data);
      decrement_dissection_depth(pinfo);
    }
  } else if (tvb_strneql(tvb, offset, "SEQ ", 4) == 0) {
    if (tree) {
      ti = proto_tree_add_item(hdr, hf_beep_cmd, tvb, offset, 3, ENC_NA|ENC_ASCII);
      proto_item_set_len(ti, 4);
    }
    offset += 3;
    offset += 1;
    offset += dissect_beep_int(tvb, pinfo, offset, tree, hf_beep_channel, &channel, seq_chan_hfa);
    offset += 1;
    offset += dissect_beep_int(tvb, pinfo, offset, tree, hf_beep_ackno, &ackno, seq_ackno_hfa);
    offset += 1;
    offset += dissect_beep_int(tvb, pinfo, offset, tree, hf_beep_window, &window, seq_window_hfa);
    if ((cc = check_term(tvb, pinfo, offset, tree)) <= 0) {
      if (tree && (tvb_reported_length_remaining(tvb, offset) > 0)) {
        proto_tree_add_item(tree, hf_beep_payload_undissected, tvb, offset,
                            tvb_reported_length_remaining(tvb, offset), ENC_NA|ENC_ASCII);
      }
      return -1;
    }
    offset += cc;
  } else if (tvb_strneql(tvb, offset, "END", 3) == 0) {
    proto_tree *tr = NULL;
    if (tree) {
      tr = proto_tree_add_subtree(tree, tvb, offset, MIN(5, MAX(0, tvb_reported_length_remaining(tvb, offset))),
                                    ett_trailer, NULL, "Trailer");
      proto_tree_add_item(hdr, hf_beep_cmd, tvb, offset, 3, ENC_NA|ENC_ASCII);
    }
    offset += 3;
    if ((cc = check_term(tvb, pinfo, offset, tr)) <= 0) {
      if (tree && (tvb_reported_length_remaining(tvb, offset) > 0)) {
        proto_tree_add_item(tree, hf_beep_payload_undissected, tvb, offset,
                            tvb_reported_length_remaining(tvb, offset), ENC_NA|ENC_ASCII);
      }
      return -1;
    }
    offset += cc;
  }
  if (tvb_reported_length_remaining(tvb, offset) > 0) { 
    int pl_size = 0;
    if (request_val) {
      pl_size = MIN(request_val->size, tvb_reported_length_remaining(tvb, offset));
      if (pl_size == 0) { 
        pl_size = tvb_reported_length_remaining(tvb, offset); 
      }
    } else if (beep_frame_data) {
      pl_size = MIN(beep_frame_data->pl_size, tvb_reported_length_remaining(tvb, offset));
    } else { 
      pl_size = tvb_reported_length_remaining(tvb, offset);
    }
    if (pl_size == 0 && offset == st_offset)
      pl_size = tvb_reported_length_remaining(tvb, offset);
    if (pl_size > 0) {
      if (tree) {
        proto_tree_add_item(tree, hf_beep_payload, tvb, offset, pl_size, ENC_NA|ENC_ASCII);
      }
      offset += pl_size;            
      if (request_val){
        request_val->size -= pl_size; 
        if (request_val->size < 0) request_val->size = 0;
      }
      else if (beep_frame_data) {
        beep_frame_data->pl_size -= pl_size;
        if (beep_frame_data->pl_size < 0) beep_frame_data->pl_size = 0;
      }
    }
    if (tvb_reported_length_remaining(tvb, offset) > 0) {
      offset += dissect_beep_tree(tvb, offset, pinfo, tree, request_val, beep_frame_data);
    }
  }
  return offset - st_offset;
}
