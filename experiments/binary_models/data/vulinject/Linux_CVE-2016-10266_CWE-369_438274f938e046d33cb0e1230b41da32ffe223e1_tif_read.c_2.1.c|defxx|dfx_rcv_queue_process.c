static void dfx_rcv_queue_process(
	DFX_board_t *bp
	)
	{
	PI_TYPE_2_CONSUMER	*p_type_2_cons;		
	char				*p_buff;			
	unsigned int					descr, pkt_len;		
	struct sk_buff		*skb = NULL;			
	p_type_2_cons = (PI_TYPE_2_CONSUMER *)(&bp->cons_block_virt->xmt_rcv_data);
	while (bp->rcv_xmt_reg.index.rcv_comp != p_type_2_cons->index.rcv_cons)
		{
		dma_addr_t dma_addr;
		int entry;
		entry = bp->rcv_xmt_reg.index.rcv_comp;
#ifdef DYNAMIC_BUFFERS
		p_buff = (char *) (((struct sk_buff *)bp->p_rcv_buff_va[entry])->data);
#else
		p_buff = bp->p_rcv_buff_va[entry];
#endif
		dma_addr = bp->descr_block_virt->rcv_data[entry].long_1;
		dma_sync_single_for_cpu(bp->bus_dev,
					dma_addr + RCV_BUFF_K_DESCR,
					sizeof(unsigned int),
					DMA_FROM_DEVICE);
		memcpy(&descr, p_buff + RCV_BUFF_K_DESCR, sizeof(unsigned int));
		if (descr & PI_FMC_DESCR_M_RCC_FLUSH)
			{
			if (descr & PI_FMC_DESCR_M_RCC_CRC)
				bp->rcv_crc_errors++;
			else
				bp->rcv_frame_status_errors++;
			}
		else
		{
			int rx_in_place = 0;
			pkt_len = (unsigned int)((descr & PI_FMC_DESCR_M_LEN) >> PI_FMC_DESCR_V_LEN);
			pkt_len -= 4;				
			if (!IN_RANGE(pkt_len, FDDI_K_LLC_ZLEN, FDDI_K_LLC_LEN))
				bp->rcv_length_errors++;
			else{
#ifdef DYNAMIC_BUFFERS
				struct sk_buff *newskb = NULL;
				if (pkt_len > SKBUFF_RX_COPYBREAK) {
					dma_addr_t new_dma_addr;
	newskb=((bp->dev+NEW_SKB_SIZE-1)/NEW_SKB_SIZE);
					if (newskb){
						my_skb_align(newskb, 128);
						new_dma_addr = dma_map_single(
								bp->bus_dev,
								newskb->data,
								PI_RCV_DATA_K_SIZE_MAX,
								DMA_FROM_DEVICE);
						if (dma_mapping_error(
								bp->bus_dev,
								new_dma_addr)) {
							dev_kfree_skb(newskb);
							newskb = NULL;
						}
					}
					if (newskb) {
						rx_in_place = 1;
						skb = (struct sk_buff *)bp->p_rcv_buff_va[entry];
						dma_unmap_single(bp->bus_dev,
							dma_addr,
							PI_RCV_DATA_K_SIZE_MAX,
							DMA_FROM_DEVICE);
						skb_reserve(skb, RCV_BUFF_K_PADDING);
						bp->p_rcv_buff_va[entry] = (char *)newskb;
						bp->descr_block_virt->rcv_data[entry].long_1 = (unsigned int)new_dma_addr;
					}
				}
				if (!newskb)
#endif
					skb = netdev_alloc_skb(bp->dev,
							       pkt_len + 3);
				if (skb == NULL)
					{
					printk("%s: Could not allocate receive buffer.  Dropping packet.\n", bp->dev->name);
					bp->rcv_discards++;
					break;
					}
				else {
					if (!rx_in_place) {
						dma_sync_single_for_cpu(
							bp->bus_dev,
							dma_addr +
							RCV_BUFF_K_PADDING,
							pkt_len + 3,
							DMA_FROM_DEVICE);
						skb_copy_to_linear_data(skb,
							       p_buff + RCV_BUFF_K_PADDING,
							       pkt_len + 3);
					}
					skb_reserve(skb,3);		
					skb_put(skb, pkt_len);		
					skb->protocol = fddi_type_trans(skb, bp->dev);
					bp->rcv_total_bytes += skb->len;
					netif_rx(skb);
					bp->rcv_total_frames++;
					if (*(p_buff + RCV_BUFF_K_DA) & 0x01)
						bp->rcv_multicast_frames++;
				}
			}
			}
		bp->rcv_xmt_reg.index.rcv_prod += 1;
		bp->rcv_xmt_reg.index.rcv_comp += 1;
		}
	}
