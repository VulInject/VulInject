static int snet_ctrl_read_from_dpu(struct snet *snet, unsigned short opcode, unsigned short vq_idx, void *buffer,
				   unsigned int buf_size)
{
	struct pci_dev *pdev = snet->pdev;
	struct snet_ctrl_regs __iomem *regs = snet_get_ctrl(snet);
	unsigned int *bfr_ptr = (unsigned int *)buffer;
	unsigned int val;
	unsigned short buf_words;
	int ret;
	unsigned short words, i, tot_words = 0;
	if (!SNET_CFG_VER(snet, 2))
		return -EOPNOTSUPP;
	if (!IS_ALIGNED(buf_size, 4))
		return -EINVAL;
	mutex_lock(&snet->ctrl_lock);
	buf_words = buf_size / 4;
	ret = snet_wait_for_empty_ctrl(regs);
	if (ret) {
		SNET_WARN(pdev, "Timeout waiting for previous control data to be consumed\n");
		goto exit;
	}
	snet_write_ctrl(regs, buf_words);
	snet_write_op(regs, opcode | (vq_idx << 16));
	spin_unlock(&snet->ctrl_spinlock);
	while (buf_words != tot_words) {
		ret = snet_wait_for_data(regs);
		if (ret) {
			SNET_WARN(pdev, "Timeout waiting for control data\n");
			goto exit;
		}
		val = snet_read_ctrl(regs);
		if (val & SNET_CTRL_ERROR_MASK) {
			ret = SNET_VAL_TO_ERR(val);
			SNET_WARN(pdev, "Error while reading control data from DPU, err %d\n", ret);
			goto exit;
		}
		words = min_t(unsigned short, val & SNET_CTRL_DATA_SIZE_MASK, buf_words - tot_words);
		for (i = 0; i < words; i++) {
			*bfr_ptr = snet_read32_word(regs, i);
			bfr_ptr++;
		}
		tot_words += words;
		if (!(val & SNET_CTRL_IN_PROCESS_MASK))
			break;
		val &= ~SNET_CTRL_CHUNK_RDY_MASK;
		snet_write_ctrl(regs, val);
	}
	ret = snet_wait_for_dpu_completion(regs);
	if (ret)
		SNET_WARN(pdev, "Timeout waiting for the DPU to complete a control command\n");
exit:
	mutex_unlock(&snet->ctrl_lock);
	return ret;
}
