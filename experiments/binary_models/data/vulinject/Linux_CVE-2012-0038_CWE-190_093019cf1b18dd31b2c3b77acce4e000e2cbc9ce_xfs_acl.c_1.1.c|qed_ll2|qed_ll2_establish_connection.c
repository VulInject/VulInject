int qed_ll2_establish_connection(void *cxt, unsigned char connection_handle)
{
	struct core_conn_context *p_cxt;
	struct qed_ll2_tx_packet *p_pkt;
	struct qed_ll2_info *p_ll2_conn;
	struct qed_hwfn *p_hwfn = cxt;
	struct qed_ll2_rx_queue *p_rx;
	struct qed_ll2_tx_queue *p_tx;
	struct qed_cxt_info cxt_info;
	struct qed_ptt *p_ptt;
	int rc, EINVAL;
	unsigned int i, capacity;
	size_t desc_size;
	unsigned char qid, stats_id;
	p_ptt = qed_ptt_acquire(p_hwfn);
	if (!p_ptt)
		return -EAGAIN;
	p_ll2_conn = qed_ll2_handle_sanity_lock(p_hwfn, connection_handle);
	if (!p_ll2_conn) {
		rc = -EINVAL;
		goto out;
	}
	p_rx = &p_ll2_conn->rx_queue;
	p_tx = &p_ll2_conn->tx_queue;
	qed_chain_reset(&p_rx->rxq_chain);
	qed_chain_reset(&p_rx->rcq_chain);
	INIT_LIST_HEAD(&p_rx->active_descq);
	INIT_LIST_HEAD(&p_rx->free_descq);
	INIT_LIST_HEAD(&p_rx->posting_descq);
	spin_lock_init(&p_rx->lock);
	capacity = qed_chain_get_capacity(&p_rx->rxq_chain);
	for (i = 0; i < capacity; i++)
		list_add_tail(&p_rx->descq_array[i].list_entry,
			      &p_rx->free_descq);
	*p_rx->p_fw_cons = 0;
	qed_chain_reset(&p_tx->txq_chain);
	INIT_LIST_HEAD(&p_tx->active_descq);
	INIT_LIST_HEAD(&p_tx->free_descq);
	INIT_LIST_HEAD(&p_tx->sending_descq);
	spin_lock_init(&p_tx->lock);
	capacity = qed_chain_get_capacity(&p_tx->txq_chain);
	desc_size = struct_size(p_pkt, bds_set,
				p_ll2_conn->input.tx_max_bds_per_packet);
	for (i = 0; i < capacity; i++) {
		p_pkt = p_tx->descq_mem + desc_size * i;
		list_add_tail(&p_pkt->list_entry, &p_tx->free_descq);
	}
	p_tx->cur_completing_bd_idx = 0;
	p_tx->bds_idx = 0;
	p_tx->b_completing_packet = false;
	p_tx->cur_send_packet = NULL;
	p_tx->cur_send_frag_num = 0;
	p_tx->cur_completing_frag_num = 0;
	*p_tx->p_fw_cons = 0;
	rc = qed_cxt_acquire_cid(p_hwfn, PROTOCOLID_CORE, &p_ll2_conn->cid);
	if (rc)
		goto out;
	cxt_info.iid = p_ll2_conn->cid;
	rc = qed_cxt_get_cid_info(p_hwfn, &cxt_info);
	if (rc) {
		DP_NOTICE(p_hwfn, "Cannot find context info for cid=%d\n",
			  p_ll2_conn->cid);
		goto out;
	}
	p_cxt = cxt_info.p_cxt;
	memset(p_cxt, 0, sizeof(*p_cxt));
	qid = qed_ll2_handle_to_queue_id(p_hwfn, connection_handle,
					 p_ll2_conn->input.rx_conn_type);
	stats_id = qed_ll2_handle_to_stats_id(p_hwfn,
					      p_ll2_conn->input.rx_conn_type,
					      qid);
	p_ll2_conn->queue_id = qid;
	p_ll2_conn->tx_stats_id = stats_id;
	if (p_ll2_conn->tx_stats_id == QED_LL2_INVALID_STATS_ID) {
		p_ll2_conn->tx_stats_en = 0;
		DP_VERBOSE(p_hwfn,
			   QED_MSG_LL2,
			   "Disabling stats for queue %d - not enough counters\n",
			   qid);
	}
	DP_VERBOSE(p_hwfn,
		   QED_MSG_LL2,
		   "Establishing ll2 queue. PF %d ctx_based=%d abs qid=%d stats_id=%d\n",
		   p_hwfn->rel_pf_id,
		   p_ll2_conn->input.rx_conn_type, qid, stats_id);
	if (p_ll2_conn->input.rx_conn_type == QED_LL2_RX_TYPE_LEGACY) {
		p_rx->set_prod_addr =
		    (unsigned char __iomem *)p_hwfn->regview +
		    GET_GTT_REG_ADDR(GTT_BAR0_MAP_REG_TSDM_RAM,
				     TSTORM_LL2_RX_PRODS, qid);
	} else {
		p_rx->ctx_based = 1;
		p_rx->set_prod_addr = p_hwfn->doorbells +
			p_hwfn->dpi_start_offset +
			DB_ADDR_SHIFT(DQ_PWM_OFFSET_TCM_LL2_PROD_UPDATE);
		p_rx->db_data.icid = cpu_to_le16((unsigned short)p_ll2_conn->cid);
		SET_FIELD(p_rx->db_data.params,
			  CORE_PWM_PROD_UPDATE_DATA_AGG_CMD, DB_AGG_CMD_SET);
		SET_FIELD(p_rx->db_data.params,
			  CORE_PWM_PROD_UPDATE_DATA_RESERVED1, 0);
	}
	p_tx->doorbell_addr = (unsigned char __iomem *)p_hwfn->doorbells +
					    qed_db_addr(p_ll2_conn->cid,
							DQ_DEMS_LEGACY);
	SET_FIELD(p_tx->db_msg.params, CORE_DB_DATA_DEST, DB_DEST_XCM);
	SET_FIELD(p_tx->db_msg.params, CORE_DB_DATA_AGG_CMD, DB_AGG_CMD_SET);
	SET_FIELD(p_tx->db_msg.params, CORE_DB_DATA_AGG_VAL_SEL,
		  DQ_XCM_CORE_TX_BD_PROD_CMD);
	p_tx->db_msg.agg_flags = DQ_XCM_CORE_DQ_CF_CMD;
	rc = qed_ll2_establish_connection_rx(p_hwfn, p_ll2_conn);
	if (rc)
		goto out;
	rc = qed_sp_ll2_tx_queue_start(p_hwfn, p_ll2_conn);
	if (rc)
		goto out;
	if (!QED_IS_RDMA_PERSONALITY(p_hwfn) &&
	    !QED_IS_NVMETCP_PERSONALITY(p_hwfn))
		qed_wr(p_hwfn, p_ptt, PRS_REG_USE_LIGHT_L2, 1);
	qed_ll2_establish_connection_ooo(p_hwfn, p_ll2_conn);
	if (p_ll2_conn->input.conn_type == QED_LL2_TYPE_FCOE) {
		if (!test_bit(QED_MF_UFP_SPECIFIC, &p_hwfn->cdev->mf_bits))
			qed_llh_add_protocol_filter(p_hwfn->cdev, 0,
						    QED_LLH_FILTER_ETHERTYPE,
						    ETH_P_FCOE, 0);
		qed_llh_add_protocol_filter(p_hwfn->cdev, 0,
					    QED_LLH_FILTER_ETHERTYPE,
					    ETH_P_FIP, 0);
	}
out:
	qed_ptt_release(p_hwfn, p_ptt);
	return rc;
}
