allocate_mipi_frames(struct ia_css_pipe *pipe,
		     struct ia_css_stream_info *info)
{
	int err = -EINVAL;
	unsigned int port;
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
			    "allocate_mipi_frames(%p) enter:\n", pipe);
	if (IS_ISP2401 && pipe->stream->config.online) {
		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
				    "allocate_mipi_frames(%p) exit: no buffers needed for 2401 pipe mode.\n",
				    pipe);
		return 0;
	}
	if (pipe->stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
				    "allocate_mipi_frames(%p) exit: no buffers needed for pipe mode.\n",
				    pipe);
		return 0; 
	}
	port = (unsigned int)pipe->stream->config.source.port.port;
	if (port >= N_CSI_PORTS) {
		IA_CSS_ERROR("allocate_mipi_frames(%p) exit: port is not correct (port=%d).",
			     pipe, port);
		return -EINVAL;
	}
	if (IS_ISP2401)
		err = calculate_mipi_buff_size(&pipe->stream->config,
					       &my_css.mipi_frame_size[port]);
	if (ref_count_mipi_allocation[port] != 0) {
		if (IS_ISP2401)
			ref_count_mipi_allocation[port]++;
		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
				    "allocate_mipi_frames(%p) leave: nothing to do, already allocated for this port (port=%d).\n",
				    pipe, port);
		return 0;
	}
	ref_count_mipi_allocation[port]++;
	my_css.num_mipi_frames[port] = NUM_MIPI_FRAMES_PER_STREAM;
	int i, j;
		for (i = 0; i < my_css.num_mipi_frames[port]; i++) {
			if (my_css.mipi_frames[port][i]) {
				ia_css_frame_free(my_css.mipi_frames[port][i]);
				my_css.mipi_frames[port][i] = NULL;
			}
			if (i < my_css.num_mipi_frames[port]) {
				err = ia_css_frame_allocate_with_buffer_size(
					  &my_css.mipi_frames[port][i],
					  my_css.mipi_frame_size[port] * HIVE_ISP_DDR_WORD_BYTES);
				if (err) {
					for (j = 0; j < i; j++) {
						if (my_css.mipi_frames[port][j]) {
							ia_css_frame_free(my_css.mipi_frames[port][j]);
							my_css.mipi_frames[port][j] = NULL;
						}
					}
					IA_CSS_ERROR("allocate_mipi_frames(%p, %d) exit: allocation failed.",
						     pipe, port);
					return err;
				}
			}
			if (info->metadata_info.size > 0) {
				if (my_css.mipi_metadata[port][i]) {
					ia_css_metadata_free(my_css.mipi_metadata[port][i]);
					my_css.mipi_metadata[port][i] = NULL;
				}
				if (i < my_css.num_mipi_frames[port]) {
					my_css.mipi_metadata[port][i] = ia_css_metadata_allocate(&info->metadata_info);
					if (!my_css.mipi_metadata[port][i]) {
						ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
								    "allocate_mipi_metadata(%p, %d) failed.\n",
								    pipe, port);
						return err;
					}
				}
			}
		}
	}
