static void portio_list_add_1(PortioList *piolist,
                              const MemoryRegionPortio *pio_init,
                              unsigned count, unsigned start,
                              unsigned off_low, unsigned off_high)
{
    MemoryRegionPortioList *mrpio;
    Object *owner;
    char *name;
    unsigned i;
    /* Copy the sub-list and null-terminate it.  */
    mrpio = MEMORY_REGION_PORTIO_LIST(
                object_new(TYPE_MEMORY_REGION_PORTIO_LIST));
    mrpio->portio_opaque = piolist->opaque;
    mrpio->ports = g_malloc0(sizeof(MemoryRegionPortio) * (count + 1));
    memcpy(mrpio->ports, pio_init, sizeof(MemoryRegionPortio) * count);
    memset(mrpio->ports + count, 0, sizeof(MemoryRegionPortio));
    /* Adjust the offsets to all be zero-based for the region.  */
    for (i = 0; i < count; ++i) {
        mrpio->ports[i].offset -= off_low;
        mrpio->ports[i].base = start + off_low;
    }
    /*
     * The MemoryRegion owner is the MemoryRegionPortioList since that manages
     * the lifecycle via the refcount
     */
    memory_region_init_io(&mrpio->mr, OBJECT(mrpio), &portio_ops, mrpio,
                          piolist->name, off_high - off_low);
    /* Reparent the MemoryRegion to the piolist owner */
    object_unparent(OBJECT(&mrpio->mr));
    if (!piolist->owner) {
        owner = container_get(qdev_get_machine(), "/unattached");
    } else {
        owner = piolist->owner;
    }
    name = g_strdup_printf("%s[*]", piolist->name);
    object_property_add_child(owner, name, OBJECT(&mrpio->mr));
    g_free(name);
    if (piolist->flush_coalesced_mmio) {
        memory_region_set_flush_coalesced(&mrpio->mr);
    }
    memory_region_add_subregion(piolist->address_space,
                                start + off_low, &mrpio->mr);
    piolist->regions[piolist->nr] = &mrpio->mr;
    ++piolist->nr;
}
