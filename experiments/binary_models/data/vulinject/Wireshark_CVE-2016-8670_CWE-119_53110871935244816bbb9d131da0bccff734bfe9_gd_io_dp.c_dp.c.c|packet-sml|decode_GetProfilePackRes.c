static gboolean decode_GetProfilePackRes(tvbuff_t *tvb, packet_info *pinfo, proto_tree *messagebodytree_list, guint *offset){
	proto_item *SML_time = NULL;
	proto_item *treepath = NULL;
	proto_item *periodList = NULL;
	proto_item *period_List_Entry = NULL;
	proto_item *headerList = NULL;
	proto_item *header_List_Entry = NULL;
	proto_item *profileSignature = NULL;
	proto_item *valuelist = NULL;
	proto_item *value_List_Entry = NULL;
	proto_tree *SML_time_tree = NULL;
	proto_tree *treepath_list = NULL;
	proto_tree *periodList_list = NULL;
	proto_tree *period_List_Entry_list = NULL;
	proto_tree *headerList_subtree = NULL;
	proto_tree *header_List_Entry_list = NULL;
	proto_tree *profileSignature_tree = NULL;
	proto_tree *valuelist_list = NULL;
	proto_tree *value_List_Entry_list = NULL;
	guint i = 0;
	guint d = 0;
	guint repeat = 0;
	guint repeat2= 0;
	guint data = 0;
	guint length = 0;
	field_serverId(tvb, messagebodytree_list, offset, &data, &length);
	get_length(tvb, offset, &data, &length);
	SML_time_tree = proto_tree_add_subtree_format(messagebodytree_list, tvb, *offset, -1, ett_sml_time, &SML_time,
				"actTime List with %d %s", length+data, plurality(length+data, "element", "elements"));
	*offset+=1;
	sml_time_type(tvb, pinfo, SML_time_tree, offset);
	proto_item_set_end(SML_time,tvb,*offset);
	field_regPeriod(tvb, messagebodytree_list, offset, &data, &length);
	get_length(tvb, offset, &data, &length);
	repeat = (data+length);
	treepath_list = proto_tree_add_subtree_format(messagebodytree_list, tvb, *offset, -1, ett_sml_treepath, &treepath,
					"parameterTreePath with %d %s", length+data, plurality(length+data, "element", "elements"));
	if ((tvb_get_guint8(tvb,*offset) & 0xF0) != LONG_LIST && (tvb_get_guint8(tvb,*offset) & 0xF0) != SHORT_LIST){
		expert_add_info_format(pinfo, treepath, &ei_sml_invalid_count, "invalid count of elements in Treepath");
		return TRUE;
	}
		if(repeat == 0) {
		expert_add_info_format(pinfo, treepath, &ei_sml_invalid_count, "invalid loop count");
		return TRUE;
	}
	*offset+=length;
	for (i=0; i< repeat; i++) {
		field_parameterTreePath(tvb, treepath_list, offset, &data, &length);
	}
	proto_item_set_end(treepath, tvb, *offset);
	get_length(tvb, offset, &data, &length);
	repeat = (data+length);
	headerList_subtree = proto_tree_add_subtree_format(messagebodytree_list, tvb, *offset, -1, ett_sml_headerList, &headerList,
							"header_List with %d %s", length+data, plurality(length+data, "element", "elements"));
	if ((tvb_get_guint8(tvb,*offset) & 0xF0) != LONG_LIST && (tvb_get_guint8(tvb,*offset) & 0xF0) != SHORT_LIST){
		expert_add_info_format(pinfo, headerList, &ei_sml_invalid_count, "invalid count of elements in headerlist");
		return TRUE;
	}
	else if (repeat <= 0){
		expert_add_info_format(pinfo, headerList, &ei_sml_invalid_count, "invalid loop count");
		return TRUE;
	}
	*offset+=length;
	for (i=0; i< repeat; i++) {
		get_length(tvb, offset, &data, &length);
		header_List_Entry_list = proto_tree_add_subtree_format(headerList_subtree, tvb, *offset, -1, ett_sml_header_List_Entry, &header_List_Entry,
								"header_List_Entry with %d %s", length+data, plurality(length+data, "element", "elements"));
		*offset+=1;
		field_objName(tvb, header_List_Entry_list, offset, &data, &length);
		field_unit(tvb, header_List_Entry_list, offset, &data, &length);
		field_scaler(tvb, header_List_Entry_list, offset, &data, &length);
		proto_item_set_end(header_List_Entry, tvb, *offset);
	}
	proto_item_set_end(headerList, tvb, *offset);
	get_length(tvb, offset, &data, &length);
	repeat = (data+length);
	periodList_list = proto_tree_add_subtree_format(messagebodytree_list, tvb, *offset, -1, ett_sml_periodList, &periodList,
				"period_List with %d %s", length+data, plurality(length+data, "element", "elements"));
	if ((tvb_get_guint8(tvb,*offset) & 0xF0) != LONG_LIST && (tvb_get_guint8(tvb,*offset) & 0xF0) != SHORT_LIST){
		expert_add_info_format(pinfo, periodList, &ei_sml_invalid_count, "invalid count of elements in periodList");
		return TRUE;
	}
	else if (repeat <= 0){
		expert_add_info_format(pinfo, periodList, &ei_sml_invalid_count, "invalid loop count");
		return TRUE;
	}
	*offset+=length;
	for (i=0; i< repeat; i++) {
		get_length(tvb, offset, &data, &length);
		period_List_Entry_list = proto_tree_add_subtree_format(periodList_list, tvb, *offset, -1, ett_sml_period_List_Entry, &period_List_Entry,
						"period_List_Entry with %d %s", length+data, plurality(length+data, "element", "elements"));
		*offset+=1;
		get_length(tvb, offset, &data, &length);
		SML_time_tree = proto_tree_add_subtree(period_List_Entry, tvb, *offset, -1, ett_sml_time, &SML_time, "valTime");
		*offset+=1;
		sml_time_type(tvb, pinfo, SML_time_tree, offset);
		proto_item_set_end(SML_time,tvb, *offset);
		field_status(tvb, period_List_Entry_list, offset, &data, &length);
		get_length(tvb, offset, &data, &length);
		repeat2 = data + length;
		valuelist_list = proto_tree_add_subtree_format(period_List_Entry_list, tvb, *offset, -1, ett_sml_valuelist, &valuelist,
							       "period_List with %d %s", length+data, plurality(length+data, "element", "elements"));
		if ((tvb_get_guint8(tvb,*offset) & 0xF0) != LONG_LIST && (tvb_get_guint8(tvb,*offset) & 0xF0) != SHORT_LIST){
			expert_add_info_format(pinfo, valuelist, &ei_sml_invalid_count, "invalid count of elements in valueList");
			return TRUE;
		}
		else if (repeat2 <= 0){
			expert_add_info_format(pinfo, valuelist, &ei_sml_invalid_count, "invalid loop count");
			return TRUE;
		}
		*offset+=length;
		for (d=0; d< repeat2; d++) {
			get_length(tvb, offset, &data, &length);
			value_List_Entry_list = proto_tree_add_subtree_format(valuelist_list, tvb, *offset, -1, ett_sml_value_List_Entry, NULL,
									"value_List_Entry with %d %s", length+data, plurality(length+data, "element", "elements"));
			*offset+=1;
			sml_value(tvb, pinfo, value_List_Entry_list, offset, &data, &length);
			field_valueSignature(tvb, value_List_Entry_list, offset, &data, &length);
			proto_item_set_end(value_List_Entry, tvb, *offset);
		}
		proto_item_set_end(valuelist, tvb, *offset);
		field_periodSignature(tvb, period_List_Entry_list, offset, &data, &length);
		proto_item_set_end(period_List_Entry, tvb, *offset);
	}
	proto_item_set_end(periodList,tvb, *offset);
	field_rawdata(tvb, messagebodytree_list, offset, &data, &length);
	get_length(tvb, offset, &data, &length);
	profileSignature = proto_tree_add_bytes_format (messagebodytree_list, hf_sml_profileSignature, tvb, *offset, length+data, NULL, "profileSignature %s", (data == 0)? ": NOT SET" : "");
	if (data > 0){
		profileSignature_tree = proto_item_add_subtree (profileSignature, ett_sml_profileSignature);
		proto_tree_add_uint (profileSignature_tree, hf_sml_length, tvb, *offset, length, data);
		*offset+=length;
		proto_tree_add_item (profileSignature_tree, hf_sml_profileSignature, tvb, *offset, data, ENC_NA);
		*offset+=data;
	}
	else
		*offset+=1;
	return FALSE;
}
