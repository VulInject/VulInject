dissect_uavcan(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
    proto_item *ti, *toggle, *transfer_crc;
    proto_tree *uavcan_tree, *can_id_tree, *can_data_tree, *dsdl_tree;
    gint offset = 0;
    struct can_info can_info;
    guint16 *src_addr, *dest_addr;
    guint8 tail_byte;
    fragment_info_t *fragment_info = NULL;
    guint reported_length;
    guint32 lookup_id = 0;
    reported_length = tvb_reported_length(tvb);
    DISSECTOR_ASSERT(data);
    can_info = *((struct can_info *) data);
    tail_byte = tvb_get_guint8(tvb, reported_length - 1);
    if ((can_info.id & CAN_ERR_FLAG) ||
        !(can_info.id & CAN_EFF_FLAG)) {
        return 0;
    }
    if ((tail_byte & (START_OF_TRANSFER | TOGGLE)) ==
        (START_OF_TRANSFER)) {
        return 0;
    }
    if ((tail_byte & (START_OF_TRANSFER | END_OF_TRANSFER)) !=
        (START_OF_TRANSFER | END_OF_TRANSFER)) { 
        if (UAVCAN_IS_MESSAGE(can_info.id)) { 
            lookup_id  = 0; 
            lookup_id |= UAVCAN_SUBJECT_ID(can_info.id) << 1;
            lookup_id |= UAVCAN_SOURCE_ID(can_info.id)  << 11;
            lookup_id |= (tail_byte & TRANSFER_ID)      << 18;
        } else { 
            lookup_id = 1; 
            lookup_id |= ((can_info.id & 0x01000000) >> 24) << 1;
            lookup_id |= UAVCAN_SERVICE_ID(can_info.id)     << 2;
            lookup_id |= UAVCAN_DESTINATION_ID(can_info.id) << 11;
            lookup_id |= UAVCAN_SOURCE_ID(can_info.id)      << 18;
            lookup_id |= (tail_byte & TRANSFER_ID)          << 25;
        }
        fragment_info = (fragment_info_t *) wmem_tree_lookup32(fragment_info_table, lookup_id);
        if (!(tail_byte & START_OF_TRANSFER) && fragment_info == NULL) {
            return 0;
        }
    }
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "UAVCAN/CAN");
    col_clear(pinfo->cinfo, COL_INFO);
    ti = proto_tree_add_item(tree, proto_uavcan, tvb, offset, reported_length, ENC_NA);
    uavcan_tree = proto_item_add_subtree(ti, ett_uavcan);
    can_id_tree = proto_tree_add_subtree_format(uavcan_tree, tvb, 0, 0,
                                                ett_uavcan_can, &ti, "CAN ID field: 0x%08x",
                                                can_info.id);
    proto_item_set_generated(ti);
    ti = proto_tree_add_uint(can_id_tree, hf_uavcan_can_id, tvb, 0, 0, can_info.id);
    proto_item_set_generated(ti);
    if (UAVCAN_IS_MESSAGE(can_info.id)) {
        ti = proto_tree_add_uint(can_id_tree, hf_uavcan_priority, tvb, 0, 0, can_info.id);
        proto_item_set_generated(ti);
        ti = proto_tree_add_uint(can_id_tree, hf_uavcan_serv_not_msg, tvb, 0, 0, can_info.id);
        proto_item_set_generated(ti);
        ti = proto_tree_add_uint(can_id_tree, hf_uavcan_anonymous, tvb, 0, 0, can_info.id);
        proto_item_set_generated(ti);
        ti = proto_tree_add_uint(can_id_tree, hf_uavcan_subject_id, tvb, 0, 0, can_info.id);
        proto_item_set_generated(ti);
        ti = proto_tree_add_uint(can_id_tree, hf_uavcan_src_addr, tvb, 0, 0, can_info.id);
        proto_item_set_generated(ti);
	src_addr=((pinfo->pool+guint16-1)/guint16);
        *src_addr = (guint16) UAVCAN_SOURCE_ID(can_info.id);
        if (UAVCAN_IS_ANONYMOUS(can_info.id)) {
            *src_addr |= ANONYMOUS_FLAG;
        }
        set_address(&pinfo->src, uavcan_address_type, 2, (const void *) src_addr);
        dest_addr = wmem_new(pinfo->pool, guint16);
        *dest_addr = BROADCAST_FLAG;
        set_address(&pinfo->dst, uavcan_address_type, 2, (const void *) dest_addr);
        col_add_fstr(pinfo->cinfo, COL_INFO, "Message: %d (%s)", UAVCAN_SUBJECT_ID(can_info.id),
                     rval_to_str_const(UAVCAN_SUBJECT_ID(can_info.id), uavcan_subject_id_vals, "Reserved"));
    } else { 
        ti = proto_tree_add_uint(can_id_tree, hf_uavcan_priority, tvb, 0, 0, can_info.id);
        proto_item_set_generated(ti);
        ti = proto_tree_add_uint(can_id_tree, hf_uavcan_serv_not_msg, tvb, 0, 0, can_info.id);
        proto_item_set_generated(ti);
        ti = proto_tree_add_uint(can_id_tree, hf_uavcan_req_not_rsp, tvb, 0, 0, can_info.id);
        proto_item_set_generated(ti);
        ti = proto_tree_add_uint(can_id_tree, hf_uavcan_service_id, tvb, 0, 0, can_info.id);
        proto_item_set_generated(ti);
        ti = proto_tree_add_uint(can_id_tree, hf_uavcan_dst_addr, tvb, 0, 0, can_info.id);
        proto_item_set_generated(ti);
        ti = proto_tree_add_uint(can_id_tree, hf_uavcan_src_addr, tvb, 0, 0, can_info.id);
        proto_item_set_generated(ti);
        src_addr = wmem_new(pinfo->pool, guint16);
        *src_addr = (guint16) UAVCAN_SOURCE_ID(can_info.id);
        set_address(&pinfo->src, uavcan_address_type, 2, (const void *) src_addr);
        dest_addr = wmem_new(pinfo->pool, guint16);
        *dest_addr = (guint16) UAVCAN_DESTINATION_ID(can_info.id);
        set_address(&pinfo->dst, uavcan_address_type, 2, (const void *) dest_addr);
        if (UAVCAN_IS_RESPONSE(can_info.id)) {
            col_add_fstr(pinfo->cinfo, COL_INFO, "Service response: %d (%s)", UAVCAN_SERVICE_ID(can_info.id),
                         rval_to_str_const(UAVCAN_SERVICE_ID(can_info.id), uavcan_service_id_vals, "Reserved"));
        } else {
            col_add_fstr(pinfo->cinfo, COL_INFO, "Service request: %d (%s)", UAVCAN_SERVICE_ID(can_info.id),
                         rval_to_str_const(UAVCAN_SERVICE_ID(can_info.id), uavcan_service_id_vals, "Reserved"));
        }
    }
    can_data_tree = proto_tree_add_subtree(uavcan_tree, tvb, 0, -1, ett_uavcan_message, NULL, "CAN data field");
    proto_tree_add_item(can_data_tree, hf_uavcan_start_of_transfer, tvb,
                        reported_length - 1, 1, ENC_NA);
    proto_tree_add_item(can_data_tree, hf_uavcan_end_of_transfer, tvb,
                        reported_length - 1, 1, ENC_NA);
    toggle = proto_tree_add_item(can_data_tree, hf_uavcan_toggle, tvb,
                                 reported_length - 1, 1, ENC_NA);
    proto_tree_add_item(can_data_tree, hf_uavcan_transfer_id, tvb,
                        reported_length - 1, 1, ENC_NA);
    proto_tree_add_item(can_data_tree, hf_uavcan_data, tvb, 0, reported_length - 1,
                        ENC_NA);
    if ((tail_byte & (START_OF_TRANSFER | END_OF_TRANSFER)) ==
        (START_OF_TRANSFER | END_OF_TRANSFER)) { 
        dsdl_tree = proto_tree_add_subtree(uavcan_tree, tvb, 0, tvb_reported_length(
                                               tvb) - 1, ett_uavcan_message, NULL, "");
        tvb_set_reported_length(tvb, reported_length - 1); 
        if (UAVCAN_IS_MESSAGE(can_info.id)) {
            guint32 id;
            id = UAVCAN_SUBJECT_ID(can_info.id);
            proto_item_append_text(dsdl_tree, "Message");
            call_dissector_with_data(dsdl_message_handle, tvb, pinfo, dsdl_tree,
                                     GUINT_TO_POINTER((guint) id));
        } else if (UAVCAN_IS_SERVICE(can_info.id)) {
            guint32 id;
            id = UAVCAN_SERVICE_ID(can_info.id);
            if (UAVCAN_IS_REQUEST(can_info.id)) {
                proto_item_append_text(dsdl_tree, "Service request");
                call_dissector_with_data(dsdl_request_handle, tvb, pinfo, dsdl_tree, GUINT_TO_POINTER(
                                             (guint) id));
            } else {
                proto_item_append_text(dsdl_tree, "Service response");
                call_dissector_with_data(dsdl_response_handle, tvb, pinfo, dsdl_tree, GUINT_TO_POINTER(
                                             (guint) id));
            }
        }
    }
    if ((tail_byte & (START_OF_TRANSFER | END_OF_TRANSFER)) !=
        (START_OF_TRANSFER | END_OF_TRANSFER)) { 
        struct uavcan_proto_data *uavcan_frame_data;
        if (!PINFO_FD_VISITED(pinfo)) { 
            if (fragment_info == NULL) { 
                fragment_info = (fragment_info_t *) wmem_new(wmem_file_scope(), fragment_info_t);
                fragment_info->fragment_id = 0;
                fragment_info->toggle = tail_byte & TOGGLE;
                wmem_tree_insert32(fragment_info_table, lookup_id, fragment_info);
            }
            uavcan_frame_data =
                wmem_new0(wmem_file_scope(), struct uavcan_proto_data);
            p_add_proto_data(wmem_file_scope(), pinfo, proto_uavcan, 0, uavcan_frame_data);
            if ((tail_byte & START_OF_TRANSFER) != 0) { 
                uavcan_frame_data->toggle_error = 0;
                fragment_info->fragment_id = 0;
                fragment_info->seq_id = uavcan_seq_id;
                uavcan_seq_id += 1;
            } else { 
                fragment_info->fragment_id += 1;
                uavcan_frame_data->toggle_error =
                    ((tail_byte & TOGGLE) == fragment_info->toggle) ? TRUE : FALSE;
            }
            uavcan_frame_data->seq_id = fragment_info->seq_id;
            fragment_info->toggle = tail_byte & TOGGLE;
            pinfo->fragmented = TRUE;
            fragment_add_seq_check(&uavcan_reassembly_table,
                                   tvb, offset, pinfo, fragment_info->seq_id, NULL, 
                                   fragment_info->fragment_id, 
                                   tvb_captured_length_remaining(tvb, offset) - 1, 
                                   ((tail_byte & END_OF_TRANSFER) == 0) ? TRUE : FALSE); 
        } else { 
            fragment_head *reassembled = NULL;
            tvbuff_t *reassembled_tvb;
            proto_tree *multi_tree;
            uavcan_frame_data = (struct uavcan_proto_data *) p_get_proto_data(
                wmem_file_scope(), pinfo, proto_uavcan, 0);
            reassembled = fragment_get_reassembled_id(&uavcan_reassembly_table, pinfo,
                                                      uavcan_frame_data->seq_id);
            if (reassembled) {
                if (uavcan_frame_data->toggle_error == 1) {
                    expert_add_info_format(pinfo, toggle, &ei_uavcan_toggle_bit_error,
                                           "Expected Toggle %u got %u.",
                                           !((tail_byte & TOGGLE) != 0),
                                           ((tail_byte & TOGGLE) != 0));
                }
                col_append_str(pinfo->cinfo, COL_INFO,
                               " (Multi-frame)");
                reassembled_tvb = tvb_new_chain(tvb, reassembled->tvb_data); 
                multi_tree = proto_tree_add_subtree(uavcan_tree, reassembled_tvb, 0,
                                                    -1, ett_uavcan_message, NULL,
                                                    "Multi-frame");
                process_reassembled_data(tvb, offset, pinfo,
                                         "Reassembled Message", reassembled, &uavcan_frag_items,
                                         NULL, multi_tree);
                if ((tail_byte & END_OF_TRANSFER) != 0) {
                    transfer_crc = proto_tree_add_item(multi_tree, hf_uavcan_packet_crc,
                                                       reassembled_tvb,
                                                       tvb_reported_length(reassembled_tvb) - 2,
                                                       2, ENC_BIG_ENDIAN);
                    guint16 packet_crc = tvb_get_guint16(reassembled_tvb,
                                                         tvb_reported_length(reassembled_tvb) - 2,
                                                         ENC_BIG_ENDIAN);
                    guint16 calc_crc = crc16_x25_ccitt_tvb(reassembled_tvb,
                                                   tvb_reported_length(reassembled_tvb) - 2);
                    if (packet_crc != calc_crc) {
                        expert_add_info_format(pinfo, transfer_crc, &ei_uavcan_transfer_crc_error,
                                               "Expected CRC16 %X got %X.",
                                               calc_crc, packet_crc);
                    }
                    tvb_set_reported_length(reassembled_tvb, tvb_reported_length(reassembled_tvb) - 2); 
                    dsdl_tree = proto_tree_add_subtree(uavcan_tree, reassembled_tvb, 0,
                                                       -1, ett_uavcan_message, NULL, "");
                    if (UAVCAN_IS_MESSAGE(can_info.id)) {
                        guint32 id = UAVCAN_SUBJECT_ID(can_info.id);
                        proto_item_append_text(dsdl_tree, "Message");
                        call_dissector_with_data(dsdl_message_handle, reassembled_tvb, pinfo,
                                                 dsdl_tree,
                                                 GUINT_TO_POINTER((guint) id));
                    } else if (UAVCAN_IS_SERVICE(can_info.id)) {
                        guint32 id = UAVCAN_SERVICE_ID(can_info.id);
                        if (UAVCAN_IS_REQUEST(can_info.id)) {
                            proto_item_append_text(dsdl_tree, "Service request");
                            call_dissector_with_data(dsdl_request_handle, reassembled_tvb, pinfo,
                                                     dsdl_tree, GUINT_TO_POINTER((guint) id));
                        } else {
                            proto_item_append_text(dsdl_tree, "Service response");
                            call_dissector_with_data(dsdl_response_handle, reassembled_tvb, pinfo,
                                                     dsdl_tree, GUINT_TO_POINTER((guint) id));
                        }
                    }
                }
            }
        }
    }
    return tvb_captured_length(tvb);
}
