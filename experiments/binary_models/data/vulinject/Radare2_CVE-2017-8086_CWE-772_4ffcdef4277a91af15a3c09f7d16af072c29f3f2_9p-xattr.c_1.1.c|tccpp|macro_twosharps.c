static inline int *macro_twosharps(TCCState *s1, const int *macro_str) {
	const int *ptr;
	int t;
	TokenString macro_str1;
	CString cstr;
	int n, start_of_nosubsts;
	for (ptr = macro_str;;) {
		CValue cval;
		TOK_GET (&t, &ptr, &cval);
		if (t == TOK_TWOSHARPS) {
			break;
		}
		if (t == 0) {
			return NULL;
		}
	}
	start_of_nosubsts = -1;
	tok_str_new (&macro_str1);
	for (ptr = macro_str;;) {
		TOK_GET (&s1->tok, &ptr, &s1->tokc);
		if (s1->tok == 0) {
			break;
		}
		if (s1->tok == TOK_TWOSHARPS) {
			continue;
		}
		if (s1->tok == TOK_NOSUBST && start_of_nosubsts < 0) {
			start_of_nosubsts = macro_str1.len;
		}
		while (*ptr == TOK_TWOSHARPS) {
			if (start_of_nosubsts >= 0) {
				macro_str1.len = start_of_nosubsts;
			}
			ptr++;
			t = *ptr;
			while (t == TOK_NOSUBST) {
				ptr++;
				t = *ptr;
			}
			if (t && t != TOK_TWOSHARPS) {
				CValue cval;
				TOK_GET (&t, &ptr, &cval);
				cstr_new (&cstr);
				cstr_cat (&cstr, get_tok_str (s1, s1->tok, &s1->tokc));
				n = cstr.size;
				cstr_cat (&cstr, get_tok_str (s1, t, &cval));
				cstr_ccat (&cstr, '\0');
				tcc_open_bf (s1, ":paste:", cstr.size);
				memcpy (s1->file->buffer, cstr.data, cstr.size);
				while (tcc_nerr (s1) == 0) {
					if (0 == *s1->file->buf_ptr) {
						break;
					}
					tok_str_add2 (&macro_str1, s1->tok, &s1->tokc);
					tcc_warning (s1, "pasting \"%.*s\" and \"%s\" does not give a valid preprocessing token",
						n, (char *) cstr.data, (char *) cstr.data + n);
				}
				tcc_close (s1);
				cstr_free (&cstr);
			}
		}
		if (s1->tok != TOK_NOSUBST) {
			start_of_nosubsts = -1;
		}
		tok_str_add2 (&macro_str1, s1->tok, &s1->tokc);
	}
	tok_str_add (s1, &macro_str1, 0);
	return macro_str1.str;
}
