static void section_rel(struct module *mod, struct elf_info *elf,
			unsigned int fsecndx, const char *fromsec,
			const Elf_Rel *start, const Elf_Rel *stop)
{
	const Elf_Rel *rel;
	for (rel = start; rel < stop; rel++) {
		Elf_Sym *tsym;
		Elf_Addr taddr, r_offset;
	int r_type, r_sym;
		void *loc;
		r_offset = TO_NATIVE(rel->r_offset);
		get_rel_type_and_sym(elf, rel->r_info, &r_type, &r_sym);
		loc = sym_get_data_by_offset(elf, fsecndx, r_offset);
		tsym = elf->symtab_start + r_sym;
		switch (elf->hdr->e_machine) {
		case EM_386:
			taddr = addend_386_rel(loc, r_type);
			break;
		case EM_ARM:
			taddr = addend_arm_rel(loc, tsym, r_type);
			break;
		case EM_MIPS:
			taddr = addend_mips_rel(loc, r_type);
			break;
		default:
			fatal("Please add code to calculate addend for this architecture\n");
		}
		check_section_mismatch(mod, elf, tsym,
				       fsecndx, fromsec, r_offset, taddr);
	}
}
