dissect_gryphon_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean is_msgresp_add)
{
    proto_tree      *gryphon_tree;
    proto_item      *ti, *type_item;
    proto_tree      *header_tree, *body_tree;
    int             msgend, msglen, msgpad;
    int             offset = 0;
    guint32         src, dest, i, frmtyp, flags;
    if (!is_msgresp_add) {
        col_set_str(pinfo->cinfo, COL_PROTOCOL, "Gryphon");
        col_clear(pinfo->cinfo, COL_INFO);
        ti = proto_tree_add_item(tree, proto_gryphon, tvb, 0, -1, ENC_NA);
        gryphon_tree = proto_item_add_subtree(ti, ett_gryphon);
    }
    else {
        gryphon_tree = tree;
    }
    header_tree = proto_tree_add_subtree(gryphon_tree, tvb, offset, MSG_HDR_SZ, ett_gryphon_header, NULL, "Header");
    proto_tree_add_item_ret_uint(header_tree, hf_gryphon_src, tvb, offset, 1, ENC_BIG_ENDIAN, &src);
    if (is_special_client(src)) {
        proto_tree_add_item(header_tree, hf_gryphon_srcchanclient, tvb, offset + 1, 1, ENC_BIG_ENDIAN);
    }
    else {
        proto_tree_add_item(header_tree, hf_gryphon_srcchan, tvb, offset + 1, 1, ENC_BIG_ENDIAN);
    }
    proto_tree_add_item_ret_uint(header_tree, hf_gryphon_dest, tvb, offset + 2, 1, ENC_BIG_ENDIAN, &dest);
    if (is_special_client(dest)) {
        proto_tree_add_item(header_tree, hf_gryphon_destchanclient, tvb, offset + 3, 1, ENC_BIG_ENDIAN);
    }
    else {
        proto_tree_add_item(header_tree, hf_gryphon_destchan, tvb, offset + 3, 1, ENC_BIG_ENDIAN);
    }
    proto_tree_add_item_ret_uint(header_tree, hf_gryphon_data_length, tvb, offset + 4, 2, ENC_BIG_ENDIAN, &msglen);
    flags = tvb_get_guint8(tvb, offset + 6);
    frmtyp = flags & ~RESPONSE_FLAGS;
    type_item = proto_tree_add_uint(header_tree, hf_gryphon_type, tvb, offset + 6, 1, frmtyp);
    if (!is_msgresp_add)
        col_set_str(pinfo->cinfo, COL_INFO, val_to_str_const(frmtyp, frame_type, "- Invalid -"));
    if (is_msgresp_add) {
        static int * const wait_flags[] = {
            &hf_gryphon_wait_resp,
            &hf_gryphon_wait_prev_resp,
            NULL
        };
        proto_tree_add_bitmask(header_tree, tvb, offset + 6, hf_gryphon_wait_flags, ett_gryphon_flags, wait_flags, ENC_NA);
    }
    proto_tree_add_item(header_tree, hf_gryphon_reserved, tvb, offset + 7, 1, ENC_NA);
    offset += MSG_HDR_SZ;
    msgpad = 3 - (msglen + 3) % 4;
    msgend = offset + msglen + msgpad;
    body_tree = proto_tree_add_subtree(gryphon_tree, tvb, offset, msglen, ett_gryphon_body, NULL, "Body");
    switch (frmtyp) {
    case GY_FT_CMD:
        offset = decode_command(tvb, pinfo, msglen, offset, dest, body_tree);
        break;
    case GY_FT_RESP:
        offset = decode_response(tvb, pinfo, offset, src, body_tree);
        break;
    case GY_FT_DATA:
        offset = decode_data(tvb, offset, body_tree);
        break;
    case GY_FT_EVENT:
        offset = decode_event(tvb, offset, body_tree);
        break;
    case GY_FT_MISC:
        offset = decode_misc(tvb, offset, pinfo, body_tree);
        break;
    case GY_FT_TEXT:
        offset = decode_text(tvb, offset, msglen, body_tree);
        break;
    case GY_FT_SIG:
        break;
    default:
        expert_add_info(pinfo, type_item, &ei_gryphon_type);
        proto_tree_add_item(body_tree, hf_gryphon_data, tvb, offset, msglen, ENC_NA);
        break;
    }
    decrement_dissection_depth(pinfo);
    if (offset < msgend) {
        i = msgend - offset;
        proto_tree_add_item(gryphon_tree, hf_gryphon_padding, tvb, offset, i, ENC_NA);
        offset += i;
    }
    return offset;
}
