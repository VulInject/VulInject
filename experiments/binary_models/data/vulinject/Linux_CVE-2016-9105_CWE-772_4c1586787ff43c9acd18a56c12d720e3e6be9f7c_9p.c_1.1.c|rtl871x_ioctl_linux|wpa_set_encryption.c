static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,
			      unsigned int param_len)
{
	int ret = 0;
	unsigned int wep_key_idx, wep_key_len = 0;
	struct NDIS_802_11_WEP	 *pwep = NULL;
	struct _adapter *padapter = netdev_priv(dev);
	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
	struct security_priv *psecuritypriv = &padapter->securitypriv;
	param->u.crypt.err = 0;
	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
	if (param_len != (unsigned int)((unsigned char *) param->u.crypt.key - (unsigned char *)param) +
			 param->u.crypt.key_len)
		return -EINVAL;
	if (!is_broadcast_ether_addr(param->sta_addr))
		return -EINVAL;
	if (param->u.crypt.idx >= WEP_KEYS) {
		param->u.crypt.idx = 0;
	}
	if (strcmp(param->u.crypt.alg, "WEP") == 0) {
		netdev_info(dev, "r8712u: %s: crypt.alg = WEP\n", __func__);
		padapter->securitypriv.ndisencryptstatus =
			     Ndis802_11Encryption1Enabled;
		padapter->securitypriv.PrivacyAlgrthm = _WEP40_;
		padapter->securitypriv.XGrpPrivacy = _WEP40_;
		wep_key_idx = param->u.crypt.idx;
		wep_key_len = param->u.crypt.key_len;
		if (wep_key_idx >= WEP_KEYS)
			wep_key_idx = 0;
		if (wep_key_len <= 0)
			return -EINVAL;
		wep_key_len = wep_key_len <= 5 ? 5 : 13;
		pwep = kzalloc(sizeof(*pwep), GFP_ATOMIC);
		if (!pwep)
			return -ENOMEM;
		pwep->KeyLength = wep_key_len;
		pwep->Length = wep_key_len +
			offsetof(struct NDIS_802_11_WEP, KeyMaterial);
		if (wep_key_len == 13) {
			padapter->securitypriv.PrivacyAlgrthm = _WEP104_;
			padapter->securitypriv.XGrpPrivacy = _WEP104_;
		}
		pwep->KeyIndex = wep_key_idx;
		pwep->KeyIndex |= 0x80000000;
		memcpy(pwep->KeyMaterial, param->u.crypt.key, pwep->KeyLength);
		if (param->u.crypt.set_tx) {
			if (r8712_set_802_11_add_wep(padapter, pwep))
				ret = -EOPNOTSUPP;
		} else {
			if (wep_key_idx >= WEP_KEYS) {
				ret = -EOPNOTSUPP;
				goto exit;
			}
			memcpy(&psecuritypriv->DefKey[wep_key_idx].skey[0],
			       pwep->KeyMaterial,
			       pwep->KeyLength);
			psecuritypriv->DefKeylen[wep_key_idx] =
				pwep->KeyLength;
			r8712_set_key(padapter, psecuritypriv, wep_key_idx);
		}
		goto exit;
	}
	if (padapter->securitypriv.AuthAlgrthm == 2) { 
		struct sta_info *psta, *pbcmc_sta;
		struct sta_priv *pstapriv = &padapter->stapriv;
		struct security_priv *spriv = &padapter->securitypriv;
		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE |
		    WIFI_MP_STATE)) { 
			psta = r8712_get_stainfo(pstapriv,
						 get_bssid(pmlmepriv));
			if (psta) {
				psta->ieee8021x_blocked = false;
				if (spriv->ndisencryptstatus ==
				    Ndis802_11Encryption2Enabled ||
				    spriv->ndisencryptstatus ==
				    Ndis802_11Encryption3Enabled)
					psta->XPrivacy = spriv->PrivacyAlgrthm;
				if (param->u.crypt.set_tx == 1)
					handle_pairwise_key(psta, param,
							    padapter);
				else 
			}
			pbcmc_sta = r8712_get_bcmc_stainfo(padapter);
			if (pbcmc_sta) {
				pbcmc_sta->ieee8021x_blocked = false;
				if (spriv->ndisencryptstatus ==
				    Ndis802_11Encryption2Enabled ||
				    spriv->ndisencryptstatus ==
				    Ndis802_11Encryption3Enabled)
					pbcmc_sta->XPrivacy =
						spriv->PrivacyAlgrthm;
			}
		}
	}
exit:
	kfree(pwep);
	return ret;
}
