*sdw_intel_probe_controller(struct sdw_intel_res *res)
{
	struct sdw_intel_link_res *link;
	struct sdw_intel_link_dev *ldev;
	struct sdw_intel_ctx *ctx;
	struct acpi_device *adev;
	struct sdw_slave *slave;
	struct list_head *node;
	struct sdw_bus *bus;
	unsigned int link_mask;
	int num_slaves = 0;
	int count;
	adev = acpi_fetch_acpi_dev(res->handle);
	if (!adev)
		return NULL;
	if (!res->count)
		return NULL;
	count = res->count;
	dev_dbg(&adev->dev, "Creating %d SDW Link devices\n", count);
	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
	if (!ctx)
		return NULL;
	ctx->count = count;
	ctx->ldev = kcalloc(ctx->count, sizeof(*ctx->ldev), GFP_KERNEL);
	if (!ctx->ldev) {
		kfree(ctx);
		return NULL;
	}
	ctx->mmio_base = res->mmio_base;
	ctx->shim_base = res->shim_base;
	ctx->alh_base = res->alh_base;
	ctx->link_mask = res->link_mask;
	ctx->handle = res->handle;
	mutex_init(&ctx->shim_lock);
	link_mask = ctx->link_mask;
	INIT_LIST_HEAD(&ctx->link_list);
	for (i = 0; i < count; i++) {
		if (!(link_mask & BIT(i)))
			continue;
		ldev = intel_link_dev_register(res,
					       ctx,
					       acpi_fwnode_handle(adev),
					       "link",
					       i);
		if (IS_ERR(ldev))
			goto err;
		link = &ldev->link_res;
		link->cdns = auxiliary_get_drvdata(&ldev->auxdev);
		if (!link->cdns) {
			dev_err(&adev->dev, "failed to get link->cdns\n");
			i++;
			goto err;
		}
		list_add_tail(&link->list, &ctx->link_list);
		bus = &link->cdns->bus;
		list_for_each(node, &bus->slaves)
			num_slaves++;
	}
	ctx->ids = kcalloc(num_slaves, sizeof(*ctx->ids), GFP_KERNEL);
	if (!ctx->ids)
		goto err;
	ctx->num_slaves = num_slaves;
	i = 0;
	list_for_each_entry(link, &ctx->link_list, list) {
		bus = &link->cdns->bus;
		list_for_each_entry(slave, &bus->slaves, node) {
			ctx->ids[i].id = slave->id;
			ctx->ids[i].link_id = bus->link_id;
			i++;
		}
	}
	return ctx;
err:
	while (i--) {
		if (!(link_mask & BIT(i)))
			continue;
		ldev = ctx->ldev[i];
		intel_link_dev_unregister(ldev);
	}
	kfree(ctx->ldev);
	kfree(ctx);
	return NULL;
}
