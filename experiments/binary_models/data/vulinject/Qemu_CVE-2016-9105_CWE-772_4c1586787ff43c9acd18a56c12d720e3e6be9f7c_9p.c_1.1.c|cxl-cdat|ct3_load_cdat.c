static void ct3_load_cdat(CDATObject *cdat, Error **errp)
{
    g_autofree CDATEntry *cdat_st = NULL;
    g_autofree char *buf = NULL;
    uint8_t sum = 0;
    int num_ent;
    int i = 0, ent = 1;
    gsize file_size = 0;
    CDATSubHeader *hdr;
    GError *error = NULL;
    /* Read CDAT file and create its cache */
    if (!g_file_get_contents(cdat->filename, (gchar **)&buf,
                             &file_size, &error)) {
        error_setg(errp, "CDAT: File read failed: %s", error->message);
        g_error_free(error);
        return;
    }
    if (file_size < sizeof(CDATTableHeader)) {
        error_setg(errp, "CDAT: File too short");
        return;
    }
    i = sizeof(CDATTableHeader);
    num_ent = 1;
    while (i < file_size) {
        hdr = (CDATSubHeader *)(buf + i);
        if (i + sizeof(CDATSubHeader) > file_size) {
            error_setg(errp, "CDAT: Truncated table");
            return;
        }
        i += hdr->length;
        if (i > file_size) {
            error_setg(errp, "CDAT: Truncated table");
            return;
        }
        num_ent++;
    }
    if (i != file_size) {
        error_setg(errp, "CDAT: File length mismatch");
        return;
    }
    cdat_st = g_new0(CDATEntry, num_ent);
    /* Set CDAT header, Entry = 0 */
    cdat_st[0].base = buf;
    cdat_st[0].length = sizeof(CDATTableHeader);
    i = 0;
    while (i < cdat_st[0].length) {
        sum += buf[i++];
    }
    /* Read CDAT structures */
    while (i < file_size) {
        hdr = (CDATSubHeader *)(buf + i);
        cdat_st[ent].base = hdr;
        cdat_st[ent].length = hdr->length;
        while (buf + i < (char *)cdat_st[ent].base + cdat_st[ent].length) {
            assert(i < file_size);
            sum += buf[i++];
        }
        ent++;
    }
    if (sum != 0) {
        warn_report("CDAT: Found checksum mismatch in %s", cdat->filename);
    }
    cdat->entry_len = num_ent;
    cdat->entry = g_steal_pointer(&cdat_st);
    cdat->buf = g_steal_pointer(&buf);
}
