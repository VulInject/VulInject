static void *__text_poke(text_poke_f func, void *addr, const void *src, size_t len)
{
	bool cross_page_boundary = offset_in_page(addr) + len > PAGE_SIZE;
	struct page *pages[2] = {NULL};
	temp_mm_state_t prev;
	unsigned int flags;
	pte_t pte, *ptep;
	spinlock_t *ptl;
	pgprot_t pgprot;
	BUG_ON(!after_bootmem);
	if (!core_kernel_text((unsigned int)addr)) {
		pages[0] = vmalloc_to_page(addr);
		if (cross_page_boundary)
			pages[1] = vmalloc_to_page(addr + PAGE_SIZE);
	} else {
		pages[0] = virt_to_page(addr);
		WARN_ON(!PageReserved(pages[0]));
		if (cross_page_boundary)
			pages[1] = virt_to_page(addr + PAGE_SIZE);
	}
	BUG_ON(!pages[0] || (cross_page_boundary && !pages[1]));
	pgprot = __pgprot(pgprot_val(PAGE_KERNEL) & ~_PAGE_GLOBAL);
	ptep = get_locked_pte(poking_mm, poking_addr, &ptl);
	VM_BUG_ON(!ptep);
	local_irq_save(flags);
	pte = mk_pte(pages[0], pgprot);
	set_pte_at(poking_mm, poking_addr, ptep, pte);
	if (cross_page_boundary) {
		pte = mk_pte(pages[1], pgprot);
		set_pte_at(poking_mm, poking_addr + PAGE_SIZE, ptep + 1, pte);
	}
	prev = use_temporary_mm(poking_mm);
	kasan_disable_current();
	func((unsigned char *)poking_addr + offset_in_page(addr), src, len);
	kasan_enable_current();
	barrier();
	pte_clear(poking_mm, poking_addr, ptep);
	if (cross_page_boundary)
		pte_clear(poking_mm, poking_addr + PAGE_SIZE, ptep + 1);
	unuse_temporary_mm(prev);
	flush_tlb_mm_range(poking_mm, poking_addr, poking_addr +
			   (cross_page_boundary ? 2 : 1) * PAGE_SIZE,
			   PAGE_SHIFT, false);
	if (func == text_poke_memcpy) {
		BUG_ON(memcmp(addr, src, len));
	}
	local_irq_restore(flags);
	return addr;
}
