hol_entry_help (struct hol_entry *entry, const struct argp_state *state,
                argp_fmtstream_t stream, struct hol_help_state *hhstate)
{
  unsigned num;
  const struct argp_option *real = entry->opt, *opt;
  char *so = entry->short_options;
  int have_long_opt = 0;        
  int old_lm = __argp_fmtstream_set_lmargin (stream, 0);
  int old_wm = __argp_fmtstream_wmargin (stream);
  struct pentry_state pest = { entry, stream, hhstate, 1, state };
  if (! odoc (real))
    for (opt = real, num = entry->num; num > 0; opt++, num--)
      if (opt->name && ovisible (opt))
        {
          have_long_opt = 1;
          break;
        }
  __argp_fmtstream_set_wmargin (stream, uparams.short_opt_col); 
  for (opt = real, num = entry->num; num > 0; opt++, num--)
    if (oshort (opt) && opt->key == *so)
      {
        if (ovisible (opt))
          {
            comma (uparams.short_opt_col, &pest);
            __argp_fmtstream_putc (stream, '-');
            __argp_fmtstream_putc (stream, *so);
            if (!have_long_opt || uparams.dup_args)
              arg (real, " %s", "[%s]",
                   state == NULL ? NULL : state->root_argp->argp_domain,
                   stream);
            else if (real->arg)
              hhstate->suppressed_dup_arg = 1;
          }
        so++;
      }
  if (odoc (real))
    {
      __argp_fmtstream_set_wmargin (stream, uparams.doc_opt_col);
      for (opt = real, num = entry->num; num > 0; opt++, num--)
        if (opt->name && ovisible (opt))
          {
            comma (uparams.doc_opt_col, &pest);
            __argp_fmtstream_puts (stream,
                                   dgettext (state == NULL ? NULL
                                             : state->root_argp->argp_domain,
                                             opt->name));
          }
    }
  else
    {
      __argp_fmtstream_set_wmargin (stream, uparams.long_opt_col);
      for (opt = real, num = entry->num; num > 0; opt++, num--)
        if (opt->name && ovisible (opt))
          {
            comma (uparams.long_opt_col, &pest);
            __argp_fmtstream_printf (stream, "--%s", opt->name);
            arg (real, "=%s", "[=%s]",
                 state == NULL ? NULL : state->root_argp->argp_domain, stream);
          }
    }
  __argp_fmtstream_set_lmargin (stream, 0);
  if (pest.first)
    {
      if (!oshort (real) && !real->name)
        print_header (real->doc, entry->argp, &pest);
      else
        goto cleanup;           
    }
  else
    {
      const char *tstr = real->doc ? dgettext (state == NULL ? NULL
                                               : state->root_argp->argp_domain,
                                               real->doc) : NULL;
      const char *fstr = filter_doc (tstr, real->key, entry->argp, state);
      if (fstr && *fstr)
        {
          unsigned int col = __argp_fmtstream_point (stream);
          __argp_fmtstream_set_lmargin (stream, uparams.opt_doc_col);
          __argp_fmtstream_set_wmargin (stream, uparams.opt_doc_col);
          if (col > (unsigned int) (uparams.opt_doc_col + 3))
            __argp_fmtstream_putc (stream, '\n');
          else if (col >= (unsigned int) uparams.opt_doc_col)
            __argp_fmtstream_puts (stream, "   ");
          else
            indent_to (stream, uparams.opt_doc_col);
        }
      if (fstr && fstr != tstr)
        free ((char *) fstr);
      __argp_fmtstream_set_lmargin (stream, 0);
      __argp_fmtstream_putc (stream, '\n');
    }
  hhstate->prev_entry = entry;
cleanup:
  __argp_fmtstream_set_lmargin (stream, old_lm);
  __argp_fmtstream_set_wmargin (stream, old_wm);
}
