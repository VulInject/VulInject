static void read_apic(AVFormatContext *s, AVIOContext *pb, int taglen,
                      const char *tag, ExtraMetaList *extra_meta, int isv34)
{
    int enc, pic_type;
    char mimetype[64] = {0};
    const CodecMime *mime     = ff_id3v2_mime_tags;
    enum AVCodecID id         = AV_CODEC_ID_NONE;
    ID3v2ExtraMetaAPIC *apic  = NULL;
    ID3v2ExtraMeta *new_extra = NULL;
    int64_t end               = avio_tell(pb) + taglen;
    if (taglen <= 4 || (!isv34 && taglen <= 6))
        goto fail;
    new_extra = av_mallocz(sizeof(*new_extra));
    if (!new_extra)
        goto fail;
    apic = &new_extra->data.apic;
    enc = avio_r8(pb);
    taglen--;
    /* mimetype */
    if (isv34) {
        int ret = avio_get_str(pb, taglen, mimetype, sizeof(mimetype));
        if (ret < 0 || ret >= taglen)
            goto fail;
        taglen -= ret;
    } else {
        if (avio_read(pb, mimetype, 3) < 0)
            goto fail;
        mimetype[3] = 0;
        taglen    -= 3;
    }
    while (mime->id != AV_CODEC_ID_NONE) {
        if (!av_strncasecmp(mime->str, mimetype, sizeof(mimetype))) {
            id = mime->id;
            break;
        }
        mime++;
    }
    if (id == AV_CODEC_ID_NONE) {
        av_log(s, AV_LOG_WARNING,
               "Unknown attached picture mimetype: %s, skipping.\n", mimetype);
        goto fail;
    }
    apic->id = id;
    /* picture type */
    pic_type = avio_r8(pb);
    taglen--;
    if (pic_type < 0 || pic_type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types)) {
        av_log(s, AV_LOG_WARNING, "Unknown attached picture type %d.\n",
               pic_type);
        pic_type = 0;
    }
    apic->type = ff_id3v2_picture_types[pic_type];
    /* description and picture data */
    if (decode_str(s, pb, enc, &apic->description, &taglen) < 0) {
        av_log(s, AV_LOG_ERROR,
               "Error decoding attached picture description.\n");
        goto fail;
    }
    apic->buf = av_buffer_alloc(taglen + AV_INPUT_BUFFER_PADDING_SIZE);
    if (!apic->buf || !taglen || avio_read(pb, apic->buf->data, taglen) != taglen)
        goto fail;
    memset(apic->buf->data + taglen, 0, AV_INPUT_BUFFER_PADDING_SIZE);
    new_extra->tag  = "APIC";
    // The description must be unique, and some ID3v2 tag writers add spaces
    // to write several APIC entries with the same description.
    list_append(new_extra, extra_meta);
    return;
fail:
    if (apic)
        free_apic(apic);
    av_freep(&new_extra);
    avio_seek(pb, end, SEEK_SET);
}
