bool test_r_anal_block_query(void) {
	RAnal *anal = r_anal_new ();
#define N 200
#define MAXSIZE 0x300
#define SPACE 0x10000
#define SAMPLES 300
	RAnalBlock *blocks[N];
	size_t i;
	for (i = 0; i < N; i++) {
		blocks[i] = r_anal_create_block (anal, rand () % SPACE, rand () % MAXSIZE); 
		assert_invariants (anal);
	}
	for (i = 0; i < N; i++) {
		if (!blocks[i]) {
			continue;
		}
		mu_assert_ptreq (r_anal_get_block_at (anal, blocks[i]->addr), blocks[i], "r_anal_get_block_at");
	}
	for (i = 0; i < SAMPLES; i++) {
		ut64 addr = rand () % SPACE;
		size_t j;
		RAnalBlock *block = NULL;
		for (j = 0; j < N; j++) {
			if (!blocks[j]) {
				continue;
			}
			if (blocks[j]->addr == addr) {
				block = blocks[j];
				break;
			}
		}
		mu_assert_ptreq (r_anal_get_block_at (anal, addr), block, "r_anal_get_block_at");
	}
	for (i = 0; i < SAMPLES; i++) {
		ut64 addr = rand () % SPACE;
		RList *in = r_anal_get_blocks_in (anal, addr);
		RAnalBlock *block;
		RListIter *it;
		r_list_foreach (in, it, block) {
			mu_assert_eq (block->ref, 2, "block refd in returned list");
		}
		size_t linear_found = 0;
		size_t j;
		for (j = 0; j < N; j++) {
			if (!blocks[j]) {
				continue;
			}
			if (r_anal_block_contains (blocks[j], addr)) {
				linear_found++;
				mu_assert ("intersect linear found in list", r_list_contains (in, blocks[j]));
			}
		}
		mu_assert_eq ((size_t)r_list_length (in), linear_found, "r_anal_get_blocks_in count");
		r_list_free (in);
	}
	for (i = 0; i < SAMPLES; i++) {
		ut64 addr = rand () % SPACE;
		ut64 size = rand() % MAXSIZE;
		RList *in = r_anal_get_blocks_intersect (anal, addr, size);
		RAnalBlock *block;
		RListIter *it;
		r_list_foreach (in, it, block) {
			mu_assert_eq (block->ref, 2, "block refd in returned list");
		}
		size_t linear_found = 0;
		size_t j;
		for (j = 0; j < N; j++) {
			RAnalBlock *block = blocks[j];
			if (!block || addr + size <= block->addr || addr >= block->addr + block->size) {
				continue;
			}
			linear_found++;
			mu_assert ("in linear found in list", r_list_contains (in, blocks[j]));
		}
		mu_assert_eq ((size_t)r_list_length (in), linear_found, "r_anal_get_blocks_intersect count");
		r_list_free (in);
	}
	for (i = 0; i < N; i++) {
		r_anal_block_unref (blocks[i]);
	}
	assert_leaks (anal);
	r_anal_free (anal);
	mu_end;
}
