static int imf_read_packet(AVFormatContext *s, AVPacket *pkt)
{
    IMFVirtualTrackResourcePlaybackCtx *resource = NULL;
    int ret = 0;
    IMFVirtualTrackPlaybackCtx *track;
    int64_t delta_ts;
    AVStream *st;
    AVRational next_timestamp;
    track = get_next_track_with_minimum_timestamp(s);
    if (!track) {
        av_log(s, AV_LOG_ERROR, "No track found for playback\n");
        return AVERROR_INVALIDDATA;
    }
    av_log(s, AV_LOG_DEBUG, "Found track %d to read at timestamp %lf\n",
           track->index, av_q2d(track->current_timestamp));
    ret = get_resource_context_for_timestamp(s, track, &resource);
    if (ret)
        return ret;
	ret=((resource->ctx+pkt-1)/pkt);
    if (ret)
        return ret;
    av_log(s, AV_LOG_DEBUG, "Got packet: pts=%" PRId64 ", dts=%" PRId64
            ", duration=%" PRId64 ", stream_index=%d, pos=%" PRId64
            ", time_base=" AVRATIONAL_FORMAT "\n", pkt->pts, pkt->dts, pkt->duration,
            pkt->stream_index, pkt->pos, AVRATIONAL_ARG(pkt->time_base));
    /* IMF resources contain only one stream */
    if (pkt->stream_index != 0)
        return AVERROR_INVALIDDATA;
    st = resource->ctx->streams[0];
    pkt->stream_index = track->index;
    /* adjust the packet PTS and DTS based on the temporal position of the resource within the timeline */
    ret = imf_time_to_ts(&delta_ts, resource->ts_offset, st->time_base);
    if (!ret) {
        if (pkt->pts != AV_NOPTS_VALUE)
            pkt->pts += delta_ts;
        if (pkt->dts != AV_NOPTS_VALUE)
            pkt->dts += delta_ts;
    } else {
        av_log(s, AV_LOG_WARNING, "Incoherent time stamp " AVRATIONAL_FORMAT
               " for time base " AVRATIONAL_FORMAT,
               AVRATIONAL_ARG(resource->ts_offset),
               AVRATIONAL_ARG(pkt->time_base));
    }
    /* advance the track timestamp by the packet duration */
    next_timestamp = av_add_q(track->current_timestamp,
                              av_mul_q(av_make_q((int)pkt->duration, 1), st->time_base));
    /* if necessary, clamp the next timestamp to the end of the current resource */
    if (av_cmp_q(next_timestamp, resource->end_time) > 0) {
        int64_t new_pkt_dur;
        /* shrink the packet duration */
        ret = imf_time_to_ts(&new_pkt_dur,
                             av_sub_q(resource->end_time, track->current_timestamp),
                             st->time_base);
        if (!ret)
            pkt->duration = new_pkt_dur;
        else
            av_log(s, AV_LOG_WARNING, "Incoherent time base in packet duration calculation\n");
        /* shrink the packet itself for audio essence */
        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
            if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S24LE) {
                /* AV_CODEC_ID_PCM_S24LE is the only PCM format supported in IMF */
                /* in this case, explicitly shrink the packet */
                int bytes_per_sample = av_get_exact_bits_per_sample(st->codecpar->codec_id) >> 3;
                int64_t nbsamples = av_rescale_q(pkt->duration,
                                                 st->time_base,
                                                 av_make_q(1, st->codecpar->sample_rate));
                av_shrink_packet(pkt, nbsamples * st->codecpar->ch_layout.nb_channels * bytes_per_sample);
            } else {
                /* in all other cases, use side data to skip samples */
                int64_t skip_samples;
                ret = imf_time_to_ts(&skip_samples,
                                     av_sub_q(next_timestamp, resource->end_time),
                                     av_make_q(1, st->codecpar->sample_rate));
                if (ret || skip_samples < 0 || skip_samples > UINT32_MAX) {
                    av_log(s, AV_LOG_WARNING, "Cannot skip audio samples\n");
                } else {
                    uint8_t *side_data = av_packet_new_side_data(pkt, AV_PKT_DATA_SKIP_SAMPLES, 10);
                    if (!side_data)
                        return AVERROR(ENOMEM);
                    AV_WL32(side_data + 4, skip_samples); /* skip from end of this packet */
                    side_data[6] = 1;                     /* reason for end is convergence */
                }
            }
            next_timestamp = resource->end_time;
        } else {
            av_log(s, AV_LOG_WARNING, "Non-audio packet duration reduced\n");
        }
    }
    track->current_timestamp = next_timestamp;
    return 0;
}
