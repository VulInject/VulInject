qla2x00_setup_chip(scsi_qla_host_t *vha)
{
	int rval;
	unsigned int srisc_address = 0;
	struct qla_hw_data *ha = vha->hw;
	struct device_reg_2xxx __iomem *reg = &ha->iobase->isp;
	unsigned int flags;
	int done_once = 0;
	if (IS_P3P_TYPE(ha)) {
		rval = ha->isp_ops->load_risc(vha, &srisc_address);
		if (rval == QLA_SUCCESS) {
			qla2x00_stop_firmware(vha);
			goto enable_82xx_npiv;
		} else
			goto failed;
	}
	if (!IS_FWI2_CAPABLE(ha) && !IS_QLA2100(ha) && !IS_QLA2200(ha)) {
		spin_lock_irqsave(&ha->hardware_lock, flags);
		wrt_reg_word(&reg->hccr, (HCCR_ENABLE_PARITY + 0x0));
		spin_unlock_irqrestore(&ha->hardware_lock, flags);
	}
	qla81xx_mpi_sync(vha);
execute_fw_with_lr:
	rval = ha->isp_ops->load_risc(vha, &srisc_address);
	if (rval == QLA_SUCCESS) {
		ql_dbg(ql_dbg_init, vha, 0x00c9,
		    "Verifying Checksum of loaded RISC code.\n");
		rval = qla2x00_verify_checksum(vha, srisc_address);
		if (rval == QLA_SUCCESS) {
			ql_dbg(ql_dbg_init, vha, 0x00ca,
			    "Starting firmware.\n");
			if (ql2xexlogins)
				ha->flags.exlogins_enabled = 1;
			if (qla_is_exch_offld_enabled(vha))
				ha->flags.exchoffld_enabled = 1;
			rval = qla2x00_execute_fw(vha, srisc_address);
			if (rval == QLA_SUCCESS) {
				if (!done_once++ && qla24xx_detect_sfp(vha)) {
					ql_dbg(ql_dbg_init, vha, 0x00ca,
					    "Re-starting firmware -- BPM.\n");
					ha->isp_ops->reset_chip(vha);
					ha->isp_ops->chip_diag(vha);
					goto execute_fw_with_lr;
				}
				if (IS_ZIO_THRESHOLD_CAPABLE(ha))
					qla27xx_set_zio_threshold(vha,
					    ha->last_zio_threshold);
				rval = qla2x00_set_exlogins_buffer(vha);
				if (rval != QLA_SUCCESS)
					goto failed;
				rval = qla2x00_set_exchoffld_buffer(vha);
				if (rval != QLA_SUCCESS)
					goto failed;
enable_82xx_npiv:
				if (IS_P3P_TYPE(ha))
					qla82xx_check_md_needed(vha);
				else
					rval = qla2x00_get_fw_version(vha);
				if (rval != QLA_SUCCESS)
					goto failed;
				ha->flags.npiv_supported = 0;
				if (IS_QLA2XXX_MIDTYPE(ha) &&
					 (ha->fw_attributes & BIT_2)) {
					ha->flags.npiv_supported = 1;
					if ((!ha->max_npiv_vports) ||
					    ((ha->max_npiv_vports + 1) %
					    MIN_MULTI_ID_FABRIC))
						ha->max_npiv_vports =
						    MIN_MULTI_ID_FABRIC - 1;
				}
				qla2x00_get_resource_cnts(vha);
				qla_init_iocb_limit(vha);
				rval = qla2x00_alloc_outstanding_cmds(ha,
				    vha->req);
				if (rval != QLA_SUCCESS)
					goto failed;
				if (ql2xallocfwdump && !(IS_P3P_TYPE(ha)))
					qla2x00_alloc_fw_dump(vha);
				qla_enable_fce_trace(vha);
				qla_enable_eft_trace(vha);
			} else {
				goto failed;
			}
		} else {
			ql_log(ql_log_fatal, vha, 0x00cd,
			    "ISP Firmware failed checksum.\n");
			goto failed;
		}
		if (ql2xrdpenable || ha->flags.scm_supported_f ||
		    ha->flags.edif_enabled)
			qla25xx_set_els_cmds_supported(vha);
	} else
		goto failed;
	if (!IS_FWI2_CAPABLE(ha) && !IS_QLA2100(ha) && !IS_QLA2200(ha)) {
		spin_lock_irqsave(&ha->hardware_lock, flags);
		if (IS_QLA2300(ha))
			wrt_reg_word(&reg->hccr, HCCR_ENABLE_PARITY + 0x1);
		else
			wrt_reg_word(&reg->hccr, HCCR_ENABLE_PARITY + 0x7);
		rd_reg_word(&reg->hccr);
		spin_unlock_irqrestore(&ha->hardware_lock, flags);
	}
	if (IS_QLA27XX(ha) || IS_QLA28XX(ha))
		ha->flags.fac_supported = 1;
	else if (rval == QLA_SUCCESS && IS_FAC_REQUIRED(ha)) {
		unsigned int size;
		rval = qla81xx_fac_get_sector_size(vha, &size);
		if (rval == QLA_SUCCESS) {
			ha->flags.fac_supported = 1;
			ha->fdt_block_size = size << 2;
		} else {
			ql_log(ql_log_warn, vha, 0x00ce,
			    "Unsupported FAC firmware (%d.%02d.%02d).\n",
			    ha->fw_major_version, ha->fw_minor_version,
			    ha->fw_subminor_version);
			if (IS_QLA83XX(ha)) {
				ha->flags.fac_supported = 0;
				rval = QLA_SUCCESS;
			}
		}
	}
failed:
	if (rval) {
		ql_log(ql_log_fatal, vha, 0x00cf,
		    "Setup chip ****FAILED****.\n");
	}
	return (rval);
}
