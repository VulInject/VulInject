static int igen6_mem_slice_setup(unsigned int int mchbar)
{
	struct igen6_imc *imc = &igen6_pvt->imc[0];
	unsigned int int base = mchbar + res_cfg->cmf_base;
	unsigned int offset = res_cfg->ms_hash_offset;
	unsigned int size = res_cfg->cmf_size;
	unsigned int int ms_s_size, ms_hash;
	void __iomem *cmf;
	int ms_l_map;
	edac_dbg(2, "\n");
	if (imc[0].size < imc[1].size) {
		ms_s_size = imc[0].size;
		ms_l_map  = 1;
	} else {
		ms_s_size = imc[1].size;
		ms_l_map  = 0;
	}
	igen6_pvt->ms_s_size = ms_s_size;
	igen6_pvt->ms_l_map  = ms_l_map;
	edac_dbg(0, "ms_s_size: %llu MiB, ms_l_map %d\n",
		 ms_s_size >> 20, ms_l_map);
	if (!size)
		return 0;
	cmf = ioremap(base, size);
	if (!cmf) {
		igen6_printk(KERN_ERR, "Failed to ioremap cmf 0x%llx\n", base);
		return -ENODEV;
	}
	ms_hash = readq(cmf + offset);
	igen6_pvt->ms_hash = ms_hash;
	iounmap(cmf);
	return 0;
}
