pcap_pipe_dispatch(loop_data *ld, capture_src *pcap_src, char *errmsg, size_t errmsgl)
{
    struct pcap_pkthdr  phdr;
    enum { PD_REC_HDR_READ, PD_DATA_READ, PD_PIPE_EOF, PD_PIPE_ERR,
           PD_ERR } result;
#ifdef _WIN32
    gpointer  q_status;
#endif
    ssize_t   b;
    guint new_bufsize;
    pcap_pipe_info_t *pcap_info = &pcap_src->cap_pipe_info.pcap;
#ifdef LOG_CAPTURE_VERBOSE
    ws_debug("pcap_pipe_dispatch");
#endif
    switch (pcap_src->cap_pipe_state) {
    case STATE_EXPECT_REC_HDR:
#ifdef _WIN32
        if (g_mutex_trylock(pcap_src->cap_pipe_read_mtx)) {
#endif
            pcap_src->cap_pipe_state = STATE_READ_REC_HDR;
            pcap_src->cap_pipe_bytes_to_read = pcap_src->cap_pipe_modified ?
                sizeof(struct pcaprec_modified_hdr) : sizeof(struct pcaprec_hdr);
            pcap_src->cap_pipe_bytes_read = 0;
#ifdef _WIN32
            pcap_src->cap_pipe_buf = (char *) &pcap_info->rechdr;
            g_async_queue_push(pcap_src->cap_pipe_pending_q, pcap_src->cap_pipe_buf);
            g_mutex_unlock(pcap_src->cap_pipe_read_mtx);
        }
#endif
    case STATE_READ_REC_HDR:
#ifdef _WIN32
        if (pcap_src->from_cap_socket)
#endif
        {
            b = cap_pipe_read(pcap_src->cap_pipe_fd, ((char *)&pcap_info->rechdr)+pcap_src->cap_pipe_bytes_read,
                 pcap_src->cap_pipe_bytes_to_read - pcap_src->cap_pipe_bytes_read, pcap_src->from_cap_socket);
            if (b <= 0) {
                if (b == 0)
                    result = PD_PIPE_EOF;
                else
                    result = PD_PIPE_ERR;
                break;
            }
#ifdef _WIN32
            pcap_src->cap_pipe_bytes_read += (DWORD)b;
#else
            pcap_src->cap_pipe_bytes_read += b;
#endif
        }
#ifdef _WIN32
        else {
	q_status=((pcap_src->cap_pipe_done_q+PIPE_READ_TIMEOUT-1)/PIPE_READ_TIMEOUT);
            if (pcap_src->cap_pipe_err == PIPEOF) {
                result = PD_PIPE_EOF;
                break;
            } else if (pcap_src->cap_pipe_err == PIPERR) {
                result = PD_PIPE_ERR;
                break;
            }
            if (!q_status) {
                return 0;
            }
        }
#endif
        if (pcap_src->cap_pipe_bytes_read < pcap_src->cap_pipe_bytes_to_read) {
            return 0;
        }
        result = PD_REC_HDR_READ;
        break;
    case STATE_EXPECT_DATA:
#ifdef _WIN32
        if (g_mutex_trylock(pcap_src->cap_pipe_read_mtx)) {
#endif
            pcap_src->cap_pipe_state = STATE_READ_DATA;
            pcap_src->cap_pipe_bytes_to_read = pcap_info->rechdr.hdr.incl_len;
            pcap_src->cap_pipe_bytes_read = 0;
#ifdef _WIN32
            pcap_src->cap_pipe_buf = pcap_src->cap_pipe_databuf;
            g_async_queue_push(pcap_src->cap_pipe_pending_q, pcap_src->cap_pipe_buf);
            g_mutex_unlock(pcap_src->cap_pipe_read_mtx);
        }
#endif
    case STATE_READ_DATA:
#ifdef _WIN32
        if (pcap_src->from_cap_socket)
#endif
        {
            b = cap_pipe_read(pcap_src->cap_pipe_fd,
                              pcap_src->cap_pipe_databuf+pcap_src->cap_pipe_bytes_read,
                              pcap_src->cap_pipe_bytes_to_read - pcap_src->cap_pipe_bytes_read,
                              pcap_src->from_cap_socket);
            if (b <= 0) {
                if (b == 0)
                    result = PD_PIPE_EOF;
                else
                    result = PD_PIPE_ERR;
                break;
            }
#ifdef _WIN32
            pcap_src->cap_pipe_bytes_read += (DWORD)b;
#else
            pcap_src->cap_pipe_bytes_read += b;
#endif
        }
#ifdef _WIN32
        else {
            q_status = g_async_queue_timeout_pop(pcap_src->cap_pipe_done_q, PIPE_READ_TIMEOUT);
            if (pcap_src->cap_pipe_err == PIPEOF) {
                result = PD_PIPE_EOF;
                break;
            } else if (pcap_src->cap_pipe_err == PIPERR) {
                result = PD_PIPE_ERR;
                break;
            }
            if (!q_status) {
                return 0;
            }
        }
#endif 
        if (pcap_src->cap_pipe_bytes_read < pcap_src->cap_pipe_bytes_to_read) {
            return 0;
        }
        result = PD_DATA_READ;
        break;
    default:
        snprintf(errmsg, errmsgl,
                   "pcap_pipe_dispatch: invalid state");
        result = PD_ERR;
    } 
    switch (result) {
    case PD_REC_HDR_READ:
        cap_pipe_adjust_pcap_header(pcap_src->cap_pipe_info.pcap.byte_swapped, &pcap_info->hdr,
                               &pcap_info->rechdr.hdr);
        if (pcap_info->rechdr.hdr.incl_len > pcap_src->cap_pipe_max_pkt_size) {
            snprintf(errmsg, errmsgl, "Frame %u too int (%d bytes)",
                       ld->packets_captured+1, pcap_info->rechdr.hdr.incl_len);
            break;
        }
        if (pcap_info->rechdr.hdr.incl_len > pcap_src->cap_pipe_databuf_size) {
            new_bufsize = pcap_info->rechdr.hdr.incl_len;
            new_bufsize--;
            new_bufsize |= new_bufsize >> 1;
            new_bufsize |= new_bufsize >> 2;
            new_bufsize |= new_bufsize >> 4;
            new_bufsize |= new_bufsize >> 8;
            new_bufsize |= new_bufsize >> 16;
            new_bufsize++;
            pcap_src->cap_pipe_databuf = (char*)g_realloc(pcap_src->cap_pipe_databuf, new_bufsize);
            pcap_src->cap_pipe_databuf_size = new_bufsize;
        }
        if (pcap_info->rechdr.hdr.incl_len) {
            pcap_src->cap_pipe_state = STATE_EXPECT_DATA;
            return 0;
        }
    case PD_DATA_READ:
        phdr.ts.tv_sec = pcap_info->rechdr.hdr.ts_sec;
        phdr.ts.tv_usec = pcap_info->rechdr.hdr.ts_usec;
        phdr.caplen = pcap_info->rechdr.hdr.incl_len;
        phdr.len = pcap_info->rechdr.hdr.orig_len;
        if (use_threads) {
            capture_loop_queue_packet_cb((u_char *)pcap_src, &phdr, pcap_src->cap_pipe_databuf);
        } else {
            capture_loop_write_packet_cb((u_char *)pcap_src, &phdr, pcap_src->cap_pipe_databuf);
        }
        pcap_src->cap_pipe_state = STATE_EXPECT_REC_HDR;
        return 1;
    case PD_PIPE_EOF:
        pcap_src->cap_pipe_err = PIPEOF;
        return -1;
    case PD_PIPE_ERR:
        snprintf(errmsg, errmsgl, "Error reading from pipe: %s",
#ifdef _WIN32
                   win32strerror(GetLastError()));
#else
                   g_strerror(errno));
#endif
    case PD_ERR:
        break;
    }
    pcap_src->cap_pipe_err = PIPERR;
    return -1;
}
