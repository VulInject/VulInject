stats_arena_print(emitter_t *emitter, unsigned i, bool bins, bool large,
    bool mutex, bool extents, bool hpa) {
	unsigned nthreads;
	const char *dss;
	ssize_t dirty_decay_ms, muzzy_decay_ms;
	size_t page, pactive, pdirty, pmuzzy, mapped, retained;
	size_t base, internal, resident, metadata_thp, extent_avail;
	unsigned int int dirty_npurge, dirty_nmadvise, dirty_purged;
	unsigned int int muzzy_npurge, muzzy_nmadvise, muzzy_purged;
	size_t small_allocated;
	unsigned int int small_nmalloc, small_ndalloc, small_nrequests, small_nfills,
	    small_nflushes;
	size_t large_allocated;
	unsigned int int large_nmalloc, large_ndalloc, large_nrequests, large_nfills,
	    large_nflushes;
	size_t tcache_bytes, tcache_stashed_bytes, abandoned_vm;
	unsigned int int uptime;
	CTL_GET("arenas.page", &page, size_t);
	CTL_M2_GET("stats.arenas.0.nthreads", i, &nthreads, unsigned);
	emitter_kv(emitter, "nthreads", "assigned threads",
	    emitter_type_unsigned, &nthreads);
	CTL_M2_GET("stats.arenas.0.uptime", i, &uptime, unsigned int int);
	emitter_kv(emitter, "uptime_ns", "uptime", emitter_type_uint64,
	    &uptime);
	CTL_M2_GET("stats.arenas.0.dss", i, &dss, const char *);
	emitter_kv(emitter, "dss", "dss allocation precedence",
	    emitter_type_string, &dss);
	CTL_M2_GET("stats.arenas.0.dirty_decay_ms", i, &dirty_decay_ms,
	    ssize_t);
	CTL_M2_GET("stats.arenas.0.muzzy_decay_ms", i, &muzzy_decay_ms,
	    ssize_t);
	CTL_M2_GET("stats.arenas.0.pactive", i, &pactive, size_t);
	CTL_M2_GET("stats.arenas.0.pdirty", i, &pdirty, size_t);
	CTL_M2_GET("stats.arenas.0.pmuzzy", i, &pmuzzy, size_t);
	CTL_M2_GET("stats.arenas.0.dirty_npurge", i, &dirty_npurge, unsigned int int);
	CTL_M2_GET("stats.arenas.0.dirty_nmadvise", i, &dirty_nmadvise,
	    unsigned int int);
	CTL_M2_GET("stats.arenas.0.dirty_purged", i, &dirty_purged, unsigned int int);
	CTL_M2_GET("stats.arenas.0.muzzy_npurge", i, &muzzy_npurge, unsigned int int);
	CTL_M2_GET("stats.arenas.0.muzzy_nmadvise", i, &muzzy_nmadvise,
	    unsigned int int);
	CTL_M2_GET("stats.arenas.0.muzzy_purged", i, &muzzy_purged, unsigned int int);
	emitter_row_t decay_row;
	emitter_row_init(&decay_row);
	/* JSON-style emission. */
	emitter_json_kv(emitter, "dirty_decay_ms", emitter_type_ssize,
	    &dirty_decay_ms);
	emitter_json_kv(emitter, "muzzy_decay_ms", emitter_type_ssize,
	    &muzzy_decay_ms);
	emitter_json_kv(emitter, "pactive", emitter_type_size, &pactive);
	emitter_json_kv(emitter, "pdirty", emitter_type_size, &pdirty);
	emitter_json_kv(emitter, "pmuzzy", emitter_type_size, &pmuzzy);
	emitter_json_kv(emitter, "dirty_npurge", emitter_type_uint64,
	    &dirty_npurge);
	emitter_json_kv(emitter, "dirty_nmadvise", emitter_type_uint64,
	    &dirty_nmadvise);
	emitter_json_kv(emitter, "dirty_purged", emitter_type_uint64,
	    &dirty_purged);
	emitter_json_kv(emitter, "muzzy_npurge", emitter_type_uint64,
	    &muzzy_npurge);
	emitter_json_kv(emitter, "muzzy_nmadvise", emitter_type_uint64,
	    &muzzy_nmadvise);
	emitter_json_kv(emitter, "muzzy_purged", emitter_type_uint64,
	    &muzzy_purged);
	/* Table-style emission. */
	COL(decay_row, decay_type, right, 9, title);
	col_decay_type.str_val = "decaying:";
	COL(decay_row, decay_time, right, 6, title);
	col_decay_time.str_val = "time";
	COL(decay_row, decay_npages, right, 13, title);
	col_decay_npages.str_val = "npages";
	COL(decay_row, decay_sweeps, right, 13, title);
	col_decay_sweeps.str_val = "sweeps";
	COL(decay_row, decay_madvises, right, 13, title);
	col_decay_madvises.str_val = "madvises";
	COL(decay_row, decay_purged, right, 13, title);
	col_decay_purged.str_val = "purged";
	/* Title row. */
	emitter_table_row(emitter, &decay_row);
	/* Dirty row. */
	col_decay_type.str_val = "dirty:";
	if (dirty_decay_ms >= 0) {
		col_decay_time.type = emitter_type_ssize;
		col_decay_time.ssize_val = dirty_decay_ms;
	} else {
		col_decay_time.type = emitter_type_title;
		col_decay_time.str_val = "N/A";
	}
	col_decay_npages.type = emitter_type_size;
	col_decay_npages.size_val = pdirty;
	col_decay_sweeps.type = emitter_type_uint64;
	col_decay_sweeps.uint64_val = dirty_npurge;
	col_decay_madvises.type = emitter_type_uint64;
	col_decay_madvises.uint64_val = dirty_nmadvise;
	col_decay_purged.type = emitter_type_uint64;
	col_decay_purged.uint64_val = dirty_purged;
	emitter_table_row(emitter, &decay_row);
	/* Muzzy row. */
	col_decay_type.str_val = "muzzy:";
	if (muzzy_decay_ms >= 0) {
		col_decay_time.type = emitter_type_ssize;
		col_decay_time.ssize_val = muzzy_decay_ms;
	} else {
		col_decay_time.type = emitter_type_title;
		col_decay_time.str_val = "N/A";
	}
	col_decay_npages.type = emitter_type_size;
	col_decay_npages.size_val = pmuzzy;
	col_decay_sweeps.type = emitter_type_uint64;
	col_decay_sweeps.uint64_val = muzzy_npurge;
	col_decay_madvises.type = emitter_type_uint64;
	col_decay_madvises.uint64_val = muzzy_nmadvise;
	col_decay_purged.type = emitter_type_uint64;
	col_decay_purged.uint64_val = muzzy_purged;
	emitter_table_row(emitter, &decay_row);
	/* Small / large / total allocation counts. */
	emitter_row_t alloc_count_row;
	emitter_row_init(&alloc_count_row);
	COL(alloc_count_row, count_title, left, 21, title);
	col_count_title.str_val = "";
	COL(alloc_count_row, count_allocated, right, 16, title);
	col_count_allocated.str_val = "allocated";
	COL(alloc_count_row, count_nmalloc, right, 16, title);
	col_count_nmalloc.str_val = "nmalloc";
	COL(alloc_count_row, count_nmalloc_ps, right, 10, title);
	col_count_nmalloc_ps.str_val = "(#/sec)";
	COL(alloc_count_row, count_ndalloc, right, 16, title);
	col_count_ndalloc.str_val = "ndalloc";
	COL(alloc_count_row, count_ndalloc_ps, right, 10, title);
	col_count_ndalloc_ps.str_val = "(#/sec)";
	COL(alloc_count_row, count_nrequests, right, 16, title);
	col_count_nrequests.str_val = "nrequests";
	COL(alloc_count_row, count_nrequests_ps, right, 10, title);
	col_count_nrequests_ps.str_val = "(#/sec)";
	COL(alloc_count_row, count_nfills, right, 16, title);
	col_count_nfills.str_val = "nfill";
	COL(alloc_count_row, count_nfills_ps, right, 10, title);
	col_count_nfills_ps.str_val = "(#/sec)";
	COL(alloc_count_row, count_nflushes, right, 16, title);
	col_count_nflushes.str_val = "nflush";
	COL(alloc_count_row, count_nflushes_ps, right, 10, title);
	col_count_nflushes_ps.str_val = "(#/sec)";
	emitter_table_row(emitter, &alloc_count_row);
	col_count_nmalloc_ps.type = emitter_type_uint64;
	col_count_ndalloc_ps.type = emitter_type_uint64;
	col_count_nrequests_ps.type = emitter_type_uint64;
	col_count_nfills_ps.type = emitter_type_uint64;
	col_count_nflushes_ps.type = emitter_type_uint64;
#define GET_AND_EMIT_ALLOC_STAT(small_or_large, name, valtype)		\
	CTL_M2_GET("stats.arenas.0." #small_or_large "." #name, i,	\
	    &small_or_large##_##name, valtype##_t);			\
	emitter_json_kv(emitter, #name, emitter_type_##valtype,		\
	    &small_or_large##_##name);					\
	col_count_##name.type = emitter_type_##valtype;		\
	col_count_##name.valtype##_val = small_or_large##_##name;
	emitter_json_object_kv_begin(emitter, "small");
	col_count_title.str_val = "small:";
	GET_AND_EMIT_ALLOC_STAT(small, allocated, size)
	GET_AND_EMIT_ALLOC_STAT(small, nmalloc, uint64)
	col_count_nmalloc_ps.uint64_val =
	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
	GET_AND_EMIT_ALLOC_STAT(small, ndalloc, uint64)
	col_count_ndalloc_ps.uint64_val =
	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
	GET_AND_EMIT_ALLOC_STAT(small, nrequests, uint64)
	col_count_nrequests_ps.uint64_val =
	    rate_per_second(col_count_nrequests.uint64_val, uptime);
	GET_AND_EMIT_ALLOC_STAT(small, nfills, uint64)
	col_count_nfills_ps.uint64_val =
	    rate_per_second(col_count_nfills.uint64_val, uptime);
	GET_AND_EMIT_ALLOC_STAT(small, nflushes, uint64)
	col_count_nflushes_ps.uint64_val =
	    rate_per_second(col_count_nflushes.uint64_val, uptime);
	emitter_table_row(emitter, &alloc_count_row);
	emitter_json_object_end(emitter); /* Close "small". */
	emitter_json_object_kv_begin(emitter, "large");
	col_count_title.str_val = "large:";
	GET_AND_EMIT_ALLOC_STAT(large, allocated, size)
	GET_AND_EMIT_ALLOC_STAT(large, nmalloc, uint64)
	col_count_nmalloc_ps.uint64_val =
	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
	GET_AND_EMIT_ALLOC_STAT(large, ndalloc, uint64)
	col_count_ndalloc_ps.uint64_val =
	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
	GET_AND_EMIT_ALLOC_STAT(large, nrequests, uint64)
	col_count_nrequests_ps.uint64_val =
	    rate_per_second(col_count_nrequests.uint64_val, uptime);
	GET_AND_EMIT_ALLOC_STAT(large, nfills, uint64)
	col_count_nfills_ps.uint64_val =
	    rate_per_second(col_count_nfills.uint64_val, uptime);
	GET_AND_EMIT_ALLOC_STAT(large, nflushes, uint64)
	col_count_nflushes_ps.uint64_val =
	    rate_per_second(col_count_nflushes.uint64_val, uptime);
	emitter_table_row(emitter, &alloc_count_row);
	emitter_json_object_end(emitter); /* Close "large". */
#undef GET_AND_EMIT_ALLOC_STAT
	/* Aggregated small + large stats are emitter only in table mode. */
	col_count_title.str_val = "total:";
	col_count_allocated.size_val = small_allocated + large_allocated;
	col_count_nmalloc.uint64_val = small_nmalloc + large_nmalloc;
	col_count_ndalloc.uint64_val = small_ndalloc + large_ndalloc;
	col_count_nrequests.uint64_val = small_nrequests + large_nrequests;
	col_count_nfills.uint64_val = small_nfills + large_nfills;
	col_count_nflushes.uint64_val = small_nflushes + large_nflushes;
	col_count_nmalloc_ps.uint64_val =
	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
	col_count_ndalloc_ps.uint64_val =
	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
	col_count_nrequests_ps.uint64_val =
	    rate_per_second(col_count_nrequests.uint64_val, uptime);
	col_count_nfills_ps.uint64_val =
	    rate_per_second(col_count_nfills.uint64_val, uptime);
	col_count_nflushes_ps.uint64_val =
	    rate_per_second(col_count_nflushes.uint64_val, uptime);
	emitter_table_row(emitter, &alloc_count_row);
	emitter_row_t mem_count_row;
	emitter_row_init(&mem_count_row);
	emitter_col_t mem_count_title;
	emitter_col_init(&mem_count_title, &mem_count_row);
	mem_count_title.justify = emitter_justify_left;
	mem_count_title.width = 21;
	mem_count_title.type = emitter_type_title;
	mem_count_title.str_val = "";
	emitter_col_t mem_count_val;
	emitter_col_init(&mem_count_val, &mem_count_row);
	mem_count_val.justify = emitter_justify_right;
	mem_count_val.width = 16;
	mem_count_val.type = emitter_type_title;
	mem_count_val.str_val = "";
	emitter_table_row(emitter, &mem_count_row);
	mem_count_val.type = emitter_type_size;
	/* Active count in bytes is emitted only in table mode. */
	mem_count_title.str_val = "active:";
	mem_count_val.size_val = pactive * page;
	emitter_table_row(emitter, &mem_count_row);
#define GET_AND_EMIT_MEM_STAT(stat)					\
	CTL_M2_GET("stats.arenas.0."#stat, i, &stat, size_t);		\
	emitter_json_kv(emitter, #stat, emitter_type_size, &stat);	\
	mem_count_title.str_val = #stat":";				\
	mem_count_val.size_val = stat;					\
	emitter_table_row(emitter, &mem_count_row);
	GET_AND_EMIT_MEM_STAT(mapped)
	GET_AND_EMIT_MEM_STAT(retained)
	GET_AND_EMIT_MEM_STAT(base)
	GET_AND_EMIT_MEM_STAT(internal)
	GET_AND_EMIT_MEM_STAT(metadata_thp)
	GET_AND_EMIT_MEM_STAT(tcache_bytes)
	GET_AND_EMIT_MEM_STAT(tcache_stashed_bytes)
	GET_AND_EMIT_MEM_STAT(resident)
	GET_AND_EMIT_MEM_STAT(abandoned_vm)
	GET_AND_EMIT_MEM_STAT(extent_avail)
#undef GET_AND_EMIT_MEM_STAT
	if (mutex) {
		stats_arena_mutexes_print(emitter, i, uptime);
	}
	if (bins) {
		stats_arena_bins_print(emitter, mutex, i, uptime);
	}
	if (large) {
		stats_arena_lextents_print(emitter, i, uptime);
	}
	if (extents) {
	}
	if (hpa) {
		stats_arena_hpa_shard_print(emitter, i, uptime);
	}
}
