wtap_open_return_val observer_open(wtap *wth, int *err, char **err_info)
{
    unsigned offset;
    capture_file_header file_header;
    unsigned header_offset;
    unsigned i;
    tlv_header tlvh;
    unsigned seek_increment;
    packet_entry_header packet_header;
    observer_dump_private_state * private_state = NULL;
    const char *err_str;
    offset = 0;
    if (!wtap_read_bytes(wth->fh, &file_header, sizeof file_header,
                         err, err_info)) {
        if (*err != WTAP_ERR_SHORT_READ)
            return WTAP_OPEN_ERROR;
        return WTAP_OPEN_NOT_MINE;
    }
    offset += (unsigned)sizeof file_header;
    if (memcmp(file_header.observer_version, observer_magic, true_magic_length)!=0) {
        return WTAP_OPEN_NOT_MINE;
    }
    header_offset = file_header.offset_to_first_packet + ((unsigned)(file_header.offset_to_first_packet_high_byte)<<16);
    if (offset > header_offset) {
        *err = WTAP_ERR_BAD_FILE;
        *err_info = ws_strdup_printf("Observer: The first packet begins in the middle of the file header");
        return WTAP_OPEN_ERROR;
    }
    private_state = g_new(observer_dump_private_state, 1);
    private_state->time_format = TIME_INFO_LOCAL;
    wth->priv = (void *) private_state;
    for (i = 0; i < file_header.number_of_information_elements; i++) {
        unsigned tlv_data_length;
        if (offset + (unsigned)sizeof tlvh > header_offset) {
            *err = WTAP_ERR_BAD_FILE;
            *err_info = ws_strdup_printf("Observer: TLVs run into the first packet data");
            return WTAP_OPEN_ERROR;
        }
        if (!wtap_read_bytes(wth->fh, &tlvh, sizeof tlvh, err, err_info))
            return WTAP_OPEN_ERROR;
        offset += (unsigned)sizeof tlvh;
        TLV_HEADER_FROM_LE_IN_PLACE(tlvh);
        if (tlvh.length < sizeof tlvh) {
            *err = WTAP_ERR_BAD_FILE;
            *err_info = ws_strdup_printf("Observer: bad record (TLV length %u < %zu)",
                tlvh.length, sizeof tlvh);
            return WTAP_OPEN_ERROR;
        }
        tlv_data_length = tlvh.length - (unsigned)sizeof tlvh;
        if (offset + tlv_data_length > header_offset) {
            *err = WTAP_ERR_BAD_FILE;
            *err_info = ws_strdup_printf("Observer: TLVs run into the first packet data");
            return WTAP_OPEN_ERROR;
        }
        switch (tlvh.type) {
        case INFORMATION_TYPE_TIME_INFO:
            if (tlv_data_length != sizeof private_state->time_format) {
                *err = WTAP_ERR_BAD_FILE;
                *err_info = ws_strdup_printf("Observer: bad record (time information TLV length %u != %zu)",
                    tlvh.length,
                    sizeof tlvh + sizeof private_state->time_format);
                return WTAP_OPEN_ERROR;
            }
            if (!wtap_read_bytes(wth->fh, &private_state->time_format,
                                 sizeof private_state->time_format,
                                 err, err_info))
                return WTAP_OPEN_ERROR;
            private_state->time_format = GUINT32_FROM_LE(private_state->time_format);
            offset += (unsigned)sizeof private_state->time_format;
            break;
        default:
            if (tlv_data_length != 0) {
                if (!wtap_read_bytes(wth->fh, NULL, tlv_data_length, err, err_info))
                    return WTAP_OPEN_ERROR;
            }
            offset += tlv_data_length;
        }
    }
    seek_increment = header_offset - offset;
    if (seek_increment != 0) {
        if (!wtap_read_bytes(wth->fh, NULL, seek_increment, err, err_info))
            return WTAP_OPEN_ERROR;
    }
    if (!wtap_read_bytes_or_eof(wth->fh, &packet_header, sizeof packet_header,
                                err, err_info)) {
        if (*err == 0) {
            *err = WTAP_ERR_BAD_FILE;
            *err_info = ws_strdup_printf("Observer: No records in the file, so we can't determine the link-layer type");
        }
        return WTAP_OPEN_ERROR;
    }
    PACKET_ENTRY_HEADER_FROM_LE_IN_PLACE(packet_header);
    if (packet_header.packet_magic != observer_packet_magic) {
        *err = WTAP_ERR_UNSUPPORTED;
        *err_info = ws_strdup_printf("Observer: unsupported packet version %ul", packet_header.packet_magic);
        return WTAP_OPEN_ERROR;
    }
    if (observer_to_wtap_encap(packet_header.network_type) == WTAP_ENCAP_UNKNOWN) {
        *err = WTAP_ERR_UNSUPPORTED;
        *err_info = ws_strdup_printf("Observer: network type %u unknown or unsupported", packet_header.network_type);
        return WTAP_OPEN_ERROR;
    }
    wth->file_encap = observer_to_wtap_encap(packet_header.network_type);
    private_state->packet_count = 0;
    private_state->network_type = wtap_to_observer_encap(wth->file_encap);
    wth->subtype_read = observer_read;
    wth->subtype_seek_read = observer_seek_read;
    wth->subtype_close = NULL;
    wth->subtype_sequential_close = NULL;
    wth->snapshot_length = 0;    
    wth->file_tsprec = WTAP_TSPREC_NSEC;
    wth->file_type_subtype = observer_file_type_subtype;
    if (file_seek(wth->fh, header_offset, SEEK_SET, err) == -1)
        return WTAP_OPEN_ERROR;
    err_str = init_gmt_to_localtime_offset();
    if (err_str != NULL) {
        *err = WTAP_ERR_INTERNAL;
        *err_info = ws_strdup_printf("observer: %s", err_str);
        return WTAP_OPEN_ERROR;
    }
    wtap_add_generated_idb(wth);
    return WTAP_OPEN_MINE;
}
