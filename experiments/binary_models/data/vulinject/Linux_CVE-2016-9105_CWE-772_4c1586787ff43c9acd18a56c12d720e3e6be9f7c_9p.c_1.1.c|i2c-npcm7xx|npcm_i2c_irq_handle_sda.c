static void npcm_i2c_irq_handle_sda(struct npcm_i2c *bus, unsigned char i2cst)
{
	unsigned char fif_cts;
	if (!npcm_i2c_is_master(bus))
		return;
	if (bus->state == I2C_IDLE) {
		bus->stop_ind = I2C_WAKE_UP_IND;
		if (npcm_i2c_is_quick(bus) || bus->read_block_use)
			npcm_i2c_stall_after_start(bus, true);
		else
			npcm_i2c_stall_after_start(bus, false);
		if (bus->wr_size == 0 && bus->rd_size == 1)
			npcm_i2c_stall_after_start(bus, true);
		fif_cts = ioread8(bus->reg + NPCM_I2CFIF_CTS);
		fif_cts = fif_cts & ~NPCM_I2CFIF_CTS_SLVRSTR;
		fif_cts = fif_cts | NPCM_I2CFIF_CTS_CLR_FIFO;
		iowrite8(fif_cts, bus->reg + NPCM_I2CFIF_CTS);
		fif_cts = fif_cts | NPCM_I2CFIF_CTS_RXF_TXE;
		iowrite8(fif_cts, bus->reg + NPCM_I2CFIF_CTS);
		if (bus->wr_size)
			npcm_i2c_set_fifo(bus, -1, bus->wr_size);
		else
			npcm_i2c_set_fifo(bus, bus->rd_size, -1);
		bus->state = I2C_OPER_STARTED;
		if (npcm_i2c_is_quick(bus) || bus->wr_size)
			npcm_i2c_wr_byte(bus, bus->dest_addr);
		else
			npcm_i2c_wr_byte(bus, bus->dest_addr | BIT(0));
	} else {
		if (NPCM_I2CST_XMIT & i2cst) {
			bus->operation = I2C_WRITE_OPER;
			npcm_i2c_irq_master_handler_write(bus);
		} else {
			bus->operation = I2C_READ_OPER;
			npcm_i2c_irq_master_handler_read(bus);
		}
	}
}
