mf_release(memfile_T *mfp, int page_count)
{
    bhdr_T	*hp;
    int		need_release;
    buf_T	*buf;
    if (mf_dont_release)
	return NULL;
    need_release = ((mfp->mf_used_count >= mfp->mf_used_count_max)
				  || (total_mem_used >> 10) >= (long_u)p_mmt);
    if (mfp->mf_fd < 0 && need_release && p_uc)
    {
	FOR_ALL_BUFFERS(buf)
	    if (buf->b_ml.ml_mfp == mfp)
		break;
	if (buf != NULL && buf->b_may_swap)
	    ml_open_file(buf);
    }
    if (mfp->mf_fd < 0 || !need_release)
	return NULL;
    for (hp = mfp->mf_used_last; hp != NULL; hp = hp->bh_prev)
	if (!(hp->bh_flags & BH_LOCKED))
	    break;
    if (hp == NULL)	
	return NULL;
    if ((hp->bh_flags & BH_DIRTY) && mf_write(mfp, hp) == FAIL)
	return NULL;
    mf_rem_hash(mfp, hp);
    if (hp->bh_page_count != page_count)
    {
	VIM_CLEAR(hp->bh_data);
	if (page_count > 0)
	    hp->bh_data = alloc((size_t)mfp->mf_page_size * page_count);
	if (hp->bh_data == NULL)
	{
	    vim_free(hp);
	    return NULL;
	}
	hp->bh_page_count = page_count;
    }
    return hp;
}
