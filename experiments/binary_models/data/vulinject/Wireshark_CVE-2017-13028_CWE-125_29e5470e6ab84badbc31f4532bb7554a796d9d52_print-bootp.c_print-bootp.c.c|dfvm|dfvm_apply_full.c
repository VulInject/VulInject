dfvm_apply_full(dfilter_t *df, proto_tree *tree, GPtrArray **fvals)
{
	int		id, length;
	bool	accum = true;
	dfvm_insn_t	*insn;
	dfvm_value_t	*arg1;
	dfvm_value_t	*arg2;
	dfvm_value_t	*arg3 = NULL;
	ws_assert(tree);
	length = df->insns->len;
	for (id = 0; id < length; id++) {
	  AGAIN:
		insn = g_ptr_array_index(df->insns, id);
		arg1 = insn->arg1;
		arg2 = insn->arg2;
		arg3 = insn->arg3;
		switch (insn->op) {
			case DFVM_CHECK_EXISTS:
				accum = check_exists(tree, arg1, NULL);
				break;
			case DFVM_CHECK_EXISTS_R:
				accum = check_exists(tree, arg1, arg2);
				break;
			case DFVM_READ_TREE:
				accum = read_tree(df, tree, arg1, arg2, NULL);
				break;
			case DFVM_READ_TREE_R:
				accum = read_tree(df, tree, arg1, arg2, arg3);
				break;
			case DFVM_READ_REFERENCE:
				accum = read_reference(df, arg1, arg2, NULL);
				break;
			case DFVM_READ_REFERENCE_R:
				accum = read_reference(df, arg1, arg2, arg3);
				break;
			case DFVM_PUT_FVALUE:
				put_fvalue(df, arg1, arg2);
				break;
			case DFVM_CALL_FUNCTION:
				accum = call_function(df, arg1, arg2, arg3);
				break;
			case DFVM_STACK_PUSH:
				stack_push(df, arg1);
				break;
			case DFVM_STACK_POP:
				stack_pop(df, arg1);
				break;
			case DFVM_SLICE:
				mk_slice(df, arg1, arg2, arg3);
				break;
			case DFVM_LENGTH:
				mk_length(df, arg1, arg2);
				break;
			case DFVM_VALUE_STRING:
				accum = mk_value_string(df, arg1, arg2, arg3);
				break;
			case DFVM_ALL_EQ:
				accum = all_test(df, fvalue_eq, arg1, arg2);
				break;
			case DFVM_ANY_EQ:
				accum = any_test(df, fvalue_eq, arg1, arg2);
				break;
			case DFVM_ALL_NE:
				accum = all_test(df, fvalue_ne, arg1, arg2);
				break;
			case DFVM_ANY_NE:
				accum = any_test(df, fvalue_ne, arg1, arg2);
				break;
			case DFVM_ALL_GT:
				accum = all_test(df, fvalue_gt, arg1, arg2);
				break;
			case DFVM_ANY_GT:
				accum = any_test(df, fvalue_gt, arg1, arg2);
				break;
			case DFVM_ALL_GE:
				accum = all_test(df, fvalue_ge, arg1, arg2);
				break;
			case DFVM_ANY_GE:
				accum = any_test(df, fvalue_ge, arg1, arg2);
				break;
			case DFVM_ALL_LT:
				accum = all_test(df, fvalue_lt, arg1, arg2);
				break;
			case DFVM_ANY_LT:
				accum = any_test(df, fvalue_lt, arg1, arg2);
				break;
			case DFVM_ALL_LE:
				accum = all_test(df, fvalue_le, arg1, arg2);
				break;
			case DFVM_ANY_LE:
				accum = any_test(df, fvalue_le, arg1, arg2);
				break;
			case DFVM_BITWISE_AND:
				mk_binary(df, fvalue_bitwise_and, arg1, arg2, arg3);
				break;
			case DFVM_ADD:
				mk_binary(df, fvalue_add, arg1, arg2, arg3);
				break;
			case DFVM_SUBTRACT:
				mk_binary(df, fvalue_subtract, arg1, arg2, arg3);
				break;
			case DFVM_MULTIPLY:
				mk_binary(df, fvalue_multiply, arg1, arg2, arg3);
				break;
			case DFVM_DIVIDE:
				mk_binary(df, fvalue_divide, arg1, arg2, arg3);
				break;
			case DFVM_MODULO:
				mk_binary(df, fvalue_modulo, arg1, arg2, arg3);
				break;
			case DFVM_NOT_ALL_ZERO:
				accum = !all_test_unary(df, fvalue_is_zero, arg1);
				break;
			case DFVM_ALL_CONTAINS:
				accum = all_test(df, fvalue_contains, arg1, arg2);
				break;
			case DFVM_ANY_CONTAINS:
				accum = any_test(df, fvalue_contains, arg1, arg2);
				break;
			case DFVM_ALL_MATCHES:
				accum = all_matches(df, arg1, arg2);
				break;
			case DFVM_ANY_MATCHES:
				accum = any_matches(df, arg1, arg2);
				break;
			case DFVM_SET_ADD:
				set_push(df, arg1, NULL);
				break;
			case DFVM_SET_ADD_RANGE:
				set_push(df, arg1, arg2);
				break;
			case DFVM_SET_ALL_IN:
				accum = all_in(df, arg1);
				break;
			case DFVM_SET_ANY_IN:
				accum = any_in(df, arg1);
				break;
			case DFVM_SET_ALL_NOT_IN:
				accum = !all_in(df, arg1);
				break;
			case DFVM_SET_ANY_NOT_IN:
				accum = !any_in(df, arg1);
				break;
			case DFVM_SET_CLEAR:
				set_clear(df);
				break;
			case DFVM_UNARY_MINUS:
				mk_minus(df, arg1, arg2);
				break;
			case DFVM_NOT:
				accum = !accum;
				break;
			case DFVM_RETURN:
				if (fvals && arg1) {
					*fvals = df_cell_ref(&df->registers[arg1->value.numeric]);
					if (*fvals == NULL) {
						*fvals = g_ptr_array_new();
					}
				}
				free_register_overhead(df);
				return accum;
			case DFVM_NO_OP:
				break;
			case DFVM_IF_TRUE_GOTO:
				if (accum) {
					id = arg1->value.numeric;
					goto AGAIN;
				}
				break;
			case DFVM_IF_FALSE_GOTO:
				if (!accum) {
					id = arg1->value.numeric;
					goto AGAIN;
				}
				break;
			case DFVM_NULL:
		}
	}
	ws_assert_not_reached();
}
