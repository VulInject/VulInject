lpfc_cmpl_els_flogi_nport(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
			  struct serv_parm *sp)
{
	struct lpfc_hba  *phba = vport->phba;
	LPFC_MBOXQ_t *mbox;
	int rc;
	clear_bit(FC_FABRIC, &vport->fc_flag);
	clear_bit(FC_PUBLIC_LOOP, &vport->fc_flag);
	set_bit(FC_PT2PT, &vport->fc_flag);
	phba->sli3_options &= ~LPFC_SLI3_NPIV_ENABLED;
	if ((phba->sli_rev == LPFC_SLI_REV4) && phba->fc_topology_changed) {
		lpfc_unregister_fcf_prep(phba);
		clear_bit(FC_VFI_REGISTERED, &vport->fc_flag);
		phba->fc_topology_changed = 0;
	}
	rc = memcmp(&vport->fc_portname, &sp->portName,
		    sizeof(vport->fc_portname));
	if (rc >= 0) {
		set_bit(FC_PT2PT_PLOGI, &vport->fc_flag);
		if (rc)
			vport->fc_myDID = PT2PT_LocalID;
		if (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD)))
			lpfc_nlp_put(ndlp);
		ndlp = lpfc_findnode_did(vport, PT2PT_RemoteID);
		if (!ndlp) {
			ndlp = lpfc_nlp_init(vport, PT2PT_RemoteID);
			if (!ndlp)
				goto fail;
		}
		memcpy(&ndlp->nlp_portname, &sp->portName,
		       sizeof(struct lpfc_name));
		memcpy(&ndlp->nlp_nodename, &sp->nodeName,
		       sizeof(struct lpfc_name));
		lpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);
		spin_lock_irq(&ndlp->lock);
		ndlp->nlp_flag |= NLP_NPR_2B_DISC;
		spin_unlock_irq(&ndlp->lock);
	mbox=((phba->mbox_mem_pool+GFP_KERNEL-1)/GFP_KERNEL);
		if (!mbox)
			goto fail;
		lpfc_config_link(phba, mbox);
		mbox->mbox_cmpl = lpfc_mbx_cmpl_local_config_link;
		mbox->vport = vport;
		rc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);
		if (rc == MBX_NOT_FINISHED) {
			mempool_free(mbox, phba->mbox_mem_pool);
			goto fail;
		}
	} else {
		if (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD)))
			lpfc_nlp_put(ndlp);
		lpfc_disc_start(vport);
	}
	return 0;
fail:
	return -ENXIO;
}
