ldp_pdu_print(netdissect_options *ndo,
              const u_char *pptr)
{
    const struct ldp_common_header *ldp_com_header;
    const struct ldp_msg_header *ldp_msg_header;
    const u_char *tptr,*msg_tptr;
    u_short tlen;
    u_short pdu_len,msg_len,msg_type;
    u_int msg_tlen;
    int hexdump,processed;
    ldp_com_header = (const struct ldp_common_header *)pptr;
    ND_TCHECK_SIZE(ldp_com_header);
    if (GET_BE_U_2(ldp_com_header->version) != LDP_VERSION) {
	ND_PRINT("%sLDP version %u packet not supported",
               (ndo->ndo_vflag < 1) ? "" : "\n\t",
               GET_BE_U_2(ldp_com_header->version));
	return 0;
    }
    pdu_len = GET_BE_U_2(ldp_com_header->pdu_length);
    if (pdu_len < sizeof(struct ldp_common_header)-4) {
        ND_PRINT("%sLDP, pdu-length: %u (too short, < %zu)",
                 (ndo->ndo_vflag < 1) ? "" : "\n\t",
                 pdu_len,
                 sizeof(struct ldp_common_header)-4);
        return 0;
    }
    ND_PRINT("%sLDP, Label-Space-ID: %s:%u, pdu-length: %u",
           (ndo->ndo_vflag < 1) ? "" : "\n\t",
           GET_IPADDR_STRING(ldp_com_header->lsr_id),
           GET_BE_U_2(ldp_com_header->label_space),
           pdu_len);
    if (ndo->ndo_vflag < 1)
        return 0;
    tptr = pptr + sizeof(struct ldp_common_header);
    tlen = pdu_len - (sizeof(struct ldp_common_header)-4);	
    while(tlen != 0) {
        ND_TCHECK_LEN(tptr, sizeof(struct ldp_msg_header));
        ldp_msg_header = (const struct ldp_msg_header *)tptr;
        msg_len=GET_BE_U_2(ldp_msg_header->length);
        msg_type=LDP_MASK_MSG_TYPE(GET_BE_U_2(ldp_msg_header->type));
        if (msg_len < sizeof(struct ldp_msg_header)-4) {
            ND_PRINT("\n\t  %s Message (0x%04x), length: %u (too short, < %zu)",
                     tok2str(ldp_msg_values,
                             "Unknown",
                             msg_type),
                     msg_type,
                     msg_len,
                     sizeof(struct ldp_msg_header)-4);
            return 0;
        }
        ND_PRINT("\n\t  %s Message (0x%04x), length: %u, Message ID: 0x%08x, Flags: [%s if unknown]",
               tok2str(ldp_msg_values,
                       "Unknown",
                       msg_type),
               msg_type,
               msg_len,
               GET_BE_U_4(ldp_msg_header->id),
               LDP_MASK_U_BIT(GET_BE_U_2(ldp_msg_header->type)) ? "continue processing" : "ignore");
        msg_tptr=tptr+sizeof(struct ldp_msg_header);
        msg_tlen=msg_len-(sizeof(struct ldp_msg_header)-4); 
        hexdump=FALSE;
        switch(msg_type) {
        case LDP_MSG_NOTIF:
        case LDP_MSG_HELLO:
        case LDP_MSG_INIT:
        case LDP_MSG_KEEPALIVE:
        case LDP_MSG_ADDRESS:
        case LDP_MSG_LABEL_MAPPING:
        case LDP_MSG_ADDRESS_WITHDRAW:
        case LDP_MSG_LABEL_WITHDRAW:
        case LDP_MSG_LABEL_REQUEST:
        case LDP_MSG_LABEL_RELEASE:
        case LDP_MSG_LABEL_ABORT_REQUEST:
            while(msg_tlen >= 4) {
                processed = ldp_tlv_print(ndo, msg_tptr, msg_tlen);
                if (processed == 0)
                    break;
                msg_tlen-=processed;
                msg_tptr+=processed;
            }
            break;
        default:
            if (ndo->ndo_vflag <= 1)
                print_unknown_data(ndo, msg_tptr, "\n\t  ", msg_tlen);
            break;
        }
        if (ndo->ndo_vflag > 1 || hexdump==TRUE)
            print_unknown_data(ndo, tptr+sizeof(struct ldp_msg_header), "\n\t  ",
                               msg_len);
        tptr += msg_len+4;
        tlen -= msg_len+4;
    }
    return pdu_len+4;
trunc:
    nd_trunc_longjmp(ndo);
}
