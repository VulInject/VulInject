kg_compose_deleg_cred(OM_uint32 *minor_status,
                      krb5_gss_cred_id_t impersonator_cred,
                      krb5_creds *subject_creds,
                      OM_uint32 time_req,
                      krb5_gss_cred_id_t *output_cred,
                      OM_uint32 *time_rec,
                      krb5_context context)
{
    OM_uint32 major_status;
    krb5_error_code code;
    krb5_gss_cred_id_t cred = NULL;
    *output_cred = NULL;
    if (!kg_is_initiator_cred(impersonator_cred) ||
        impersonator_cred->name == NULL ||
        impersonator_cred->impersonator != NULL) {
        code = G_BAD_USAGE;
        goto cleanup;
    }
    assert(impersonator_cred->name->princ != NULL);
    assert(subject_creds != NULL);
    assert(subject_creds->client != NULL);
    cred = xmalloc(sizeof(*cred));
    if (cred == NULL) {
        code = ENOMEM;
        goto cleanup;
    }
    memset(cred, 0, sizeof(*cred));
    code = k5_mutex_init(&cred->lock);
    if (code != 0)
        goto cleanup;
    cred->usage = GSS_C_INITIATE;
    cred->expire = subject_creds->times.endtime;
    code = kg_init_name(context, subject_creds->client, NULL, NULL, NULL, 0,
                        &cred->name);
    if (code != 0)
        goto cleanup;
    code = krb5_cc_new_unique(context, "MEMORY", NULL, &cred->ccache);
    if (code != 0)
        goto cleanup;
    cred->destroy_ccache = 1;
    code = krb5_cc_initialize(context, cred->ccache, subject_creds->client);
    if (code != 0)
        goto cleanup;
    code = make_proxy_cred(context, cred, impersonator_cred);
    if (code != 0)
        goto cleanup;
    code = krb5_cc_store_cred(context, cred->ccache, subject_creds);
    if (code != 0)
        goto cleanup;
    if (time_rec != NULL) {
        krb5_timestamp now;
        code = krb5_timeofday(context, &now);
        if (code != 0)
            goto cleanup;
        *time_rec = ts_interval(now, cred->expire);
    }
    major_status = GSS_S_COMPLETE;
    *minor_status = 0;
    *output_cred = cred;
cleanup:
    if (code != 0) {
        *minor_status = code;
        major_status = GSS_S_FAILURE;
    }
    if (GSS_ERROR(major_status) && cred != NULL) {
        k5_mutex_destroy(&cred->lock);
        krb5_cc_destroy(context, cred->ccache);
        kg_release_name(context, &cred->name);
        xfree(cred);
    }
    return major_status;
}
