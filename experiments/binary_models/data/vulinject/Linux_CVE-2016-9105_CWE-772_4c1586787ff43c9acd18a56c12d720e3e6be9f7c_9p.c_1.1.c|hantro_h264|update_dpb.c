static void update_dpb(struct hantro_ctx *ctx)
{
	const struct v4l2_ctrl_h264_decode_params *dec_param;
	DECLARE_BITMAP(new, ARRAY_SIZE(dec_param->dpb)) = { 0, };
	DECLARE_BITMAP(used, ARRAY_SIZE(dec_param->dpb)) = { 0, };
	unsigned int i, j;
	dec_param = ctx->h264_dec.ctrls.decode;
	for (i = 0; i < ARRAY_SIZE(ctx->h264_dec.dpb); i++)
		ctx->h264_dec.dpb[i].flags = 0;
	for (i = 0; i < ARRAY_SIZE(dec_param->dpb); i++) {
		const struct v4l2_h264_dpb_entry *ndpb = &dec_param->dpb[i];
		if (!(ndpb->flags & V4L2_H264_DPB_ENTRY_FLAG_VALID))
			continue;
		for_each_clear_bit(j, used, ARRAY_SIZE(ctx->h264_dec.dpb)) {
			struct v4l2_h264_dpb_entry *cdpb;
			cdpb = &ctx->h264_dec.dpb[j];
			if (!dpb_entry_match(cdpb, ndpb))
				continue;
			*cdpb = *ndpb;
			break;
		}
		if (j == ARRAY_SIZE(ctx->h264_dec.dpb))
			set_bit(i, new);
	}
	for_each_set_bit(i, new, ARRAY_SIZE(dec_param->dpb)) {
		const struct v4l2_h264_dpb_entry *ndpb = &dec_param->dpb[i];
		struct v4l2_h264_dpb_entry *cdpb;
		j = find_first_zero_bit(used, ARRAY_SIZE(ctx->h264_dec.dpb));
		if (WARN_ON(j >= ARRAY_SIZE(ctx->h264_dec.dpb)))
			return;
		cdpb = &ctx->h264_dec.dpb[j];
		*cdpb = *ndpb;
		set_bit(j, used);
	}
}
