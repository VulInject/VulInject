dissect_rohc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data )
{
    proto_item         *ti, *item, *conf_item;
    proto_tree         *rohc_tree, *sub_tree = NULL, *conf_tree;
    int                 offset               = 0, length;
    guint8              oct, code, size, val_len = 0;
    gint16              feedback_data_len, cid = 0;
    gboolean            is_add_cid           = FALSE;
    rohc_info          *p_rohc_info          = NULL;
    rohc_info           g_rohc_info;
    tvbuff_t           *next_tvb=NULL, *payload_tvb;
    rohc_cid_context_t *rohc_cid_context     = NULL;
    if (data == NULL) {
        g_rohc_info.rohc_compression     = FALSE;
        g_rohc_info.rohc_ip_version      = g_version;
        g_rohc_info.cid_inclusion_info   = FALSE;
        g_rohc_info.large_cid_present    = FALSE;
        g_rohc_info.mode                 = RELIABLE_BIDIRECTIONAL;
        g_rohc_info.rnd                  = FALSE;
        g_rohc_info.udp_checksum_present = FALSE;
        g_rohc_info.profile              = g_profile;
        g_rohc_info.last_created_item    = NULL;
        p_rohc_info = &g_rohc_info;
    } else {
        p_rohc_info = (rohc_info *)data;
        memset(&g_rohc_info, 0, sizeof(rohc_info));
    }
    length = tvb_reported_length(tvb);
    if (pinfo->src.type == AT_ETHER) {
        col_set_str(pinfo->cinfo, COL_INFO, "ROHC");
        col_clear(pinfo->cinfo, COL_INFO);
    } else {
        col_append_str(pinfo->cinfo, COL_PROTOCOL, "|ROHC");
        col_append_str(pinfo->cinfo, COL_INFO, " ");
    }
    ti = proto_tree_add_item(tree, proto_rohc, tvb, 0, -1, ENC_NA);
    rohc_tree = proto_item_add_subtree(ti, ett_rohc);
    conf_tree = proto_tree_add_subtree_format(rohc_tree, tvb, offset, 0, ett_rohc_conf, &item,
                                              "Global Configuration: (%s)",
                                              p_rohc_info->large_cid_present ? "Large CID" : "Small CID");
    proto_item_set_generated(item);
    rohc_cid_context = (rohc_cid_context_t*)p_get_proto_data(wmem_file_scope(), pinfo, proto_rohc, 0 );
    if (rohc_cid_context) {
        if (rohc_cid_context->ir_frame_number>0) {
            conf_item = proto_tree_add_item(conf_tree, hf_rohc_configured_by_ir_packet, tvb, offset, 0, ENC_NA);
            proto_item_set_generated(conf_item);
            conf_item = proto_tree_add_uint(conf_tree, hf_rohc_ir_pkt_frame, tvb, 0, 0, rohc_cid_context->ir_frame_number);
            proto_item_set_generated(conf_item);
            if (rohc_cid_context->prev_ir_frame_number>0) {
                conf_item = proto_tree_add_uint(conf_tree, hf_rohc_ir_previous_frame, tvb, 0, 0, rohc_cid_context->prev_ir_frame_number);
                proto_item_set_generated(conf_item);
            }
            conf_item = proto_tree_add_uint(conf_tree, hf_rohc_ir_profile, tvb, offset, 0, rohc_cid_context->profile);
            proto_item_set_generated(conf_item);
            col_append_fstr(pinfo->cinfo, COL_INFO, "%s: ", val_to_str_const(rohc_cid_context->profile, rohc_profile_vals, "Unknown"));
            conf_item = proto_tree_add_uint(conf_tree, hf_rohc_ir_ip_version, tvb, offset, 0, rohc_cid_context->rohc_ip_version);
            proto_item_set_generated(conf_item);
            if (rohc_cid_context->mode == 0) {
                conf_item = proto_tree_add_uint_format_value(conf_tree, hf_rohc_ir_mode, tvb, offset, 0, 0, "not known");
                proto_item_set_generated(conf_item);
            } else {
                conf_item = proto_tree_add_uint(conf_tree, hf_rohc_ir_mode, tvb, offset, 0, rohc_cid_context->mode);
                proto_item_set_generated(conf_item);
            }
        } else {
            conf_item = proto_tree_add_item(conf_tree, hf_rohc_no_configuration_info, tvb, offset, 0, ENC_NA);
            proto_item_set_generated(conf_item);
        }
    }
start_over:
    cid = 0;
    oct = tvb_get_guint8(tvb,offset);
    if (oct== 0xe0) {
        while (oct == 0xe0) {
            offset++;
            oct = tvb_get_guint8(tvb,offset);
        }
        proto_tree_add_item(rohc_tree, hf_rohc_padding, tvb, 0, offset, ENC_NA);
    }
    if ((oct&0xf0) == 0xe0) {
        is_add_cid = TRUE;
        cid = oct & 0x0f;
        proto_tree_add_item(rohc_tree, hf_rohc_add_cid, tvb, offset, 1, ENC_BIG_ENDIAN);
        proto_tree_add_uint(rohc_tree, hf_rohc_small_cid, tvb, offset, 1, cid);
        offset++;
        oct = tvb_get_guint8(tvb,offset);
    }
    if ((oct&0xf8) == 0xf0) {
        int feedback_start = offset;
        if (is_add_cid) {
            p_rohc_info->last_created_item = proto_tree_add_item(rohc_tree, hf_rohc_feedback, tvb, offset, 1, ENC_BIG_ENDIAN);
            col_append_str(pinfo->cinfo, COL_INFO, "Error packet");
            proto_tree_add_item(rohc_tree, hf_rohc_error_packet, tvb, offset, -1, ENC_NA);
            return tvb_captured_length(tvb);
        } else {
            col_append_str(pinfo->cinfo, COL_INFO, "Feedback ");
            p_rohc_info->last_created_item = proto_tree_add_item(rohc_tree, hf_rohc_feedback, tvb, offset, 1, ENC_BIG_ENDIAN);
	sub_tree=((p_rohc_info->last_created_item+ett_rohc_fb-1)/ett_rohc_fb);
            proto_tree_add_item(sub_tree, hf_rohc_code, tvb, offset, 1, ENC_BIG_ENDIAN);
            code = oct&0x7;
            offset++;
            if (code==0) {
                size = tvb_get_guint8(tvb,offset);
                proto_tree_add_item(sub_tree, hf_rohc_size, tvb, offset, 1, ENC_BIG_ENDIAN);
                offset++;
            } else {
                size = code;
            }
            feedback_data_len = size;
            if (!p_rohc_info->large_cid_present) {
                oct = tvb_get_guint8(tvb,offset);
                if ((oct&0xf0) == 0xe0) {
                    cid = oct & 0x0f;
                    proto_tree_add_item(sub_tree, hf_rohc_add_cid, tvb, offset, 1, ENC_BIG_ENDIAN);
                    proto_tree_add_uint(sub_tree, hf_rohc_small_cid, tvb, offset, 1, cid);
                    offset++;
                    feedback_data_len--;
                } else {
                    item = proto_tree_add_uint(sub_tree, hf_rohc_small_cid, tvb, 0, 0, cid);
                    proto_item_set_generated(item);
                }
            } else {
                get_self_describing_var_len_val(tvb, sub_tree, offset, hf_rohc_large_cid, &val_len);
                feedback_data_len = feedback_data_len - val_len;
                offset += val_len;
            }
            dissect_rohc_feedback_data(tvb, sub_tree, pinfo, offset, feedback_data_len, p_rohc_info, cid, p_rohc_info != &g_rohc_info);
            offset += size;
            if (offset<length) {
                goto start_over;
            }
            proto_item_set_len(p_rohc_info->last_created_item, offset-feedback_start);
            return tvb_captured_length(tvb);
        }
    }
    if ((oct&0xfe) == 0xfe) {
        col_append_str(pinfo->cinfo, COL_INFO, "Segment");
        if (!p_rohc_info->large_cid_present && !is_add_cid) {
            item = proto_tree_add_uint(rohc_tree, hf_rohc_small_cid, tvb, 0, 0, cid);
            proto_item_set_generated(item);
        }
        proto_tree_add_expert(rohc_tree, pinfo, &ei_rohc_desegmentation_not_implemented, tvb, offset, -1);
        return tvb_captured_length(tvb);
    }
    if ((oct&0xfe) == 0xfc) {
        col_append_str(pinfo->cinfo, COL_INFO, "IR");
        offset = dissect_rohc_ir_packet(tvb, rohc_tree, pinfo, offset, cid, is_add_cid, p_rohc_info);
        if (offset == -1) {
            return tvb_captured_length(tvb);
        }
        payload_tvb = tvb_new_subset_remaining(tvb, offset);
        call_data_dissector(payload_tvb, pinfo, rohc_tree);
        return tvb_captured_length(tvb);
    }
    if ((oct&0xff) == 0xf8) {
        col_append_str(pinfo->cinfo, COL_INFO, "IR-DYN packet");
        offset = dissect_rohc_ir_dyn_packet(tvb, rohc_tree, pinfo, offset, cid, is_add_cid, p_rohc_info);
        if (offset == -1) {
            return tvb_captured_length(tvb);
        }
        payload_tvb = tvb_new_subset_remaining(tvb, offset);
        call_data_dissector(payload_tvb, pinfo, rohc_tree);
        return tvb_captured_length(tvb);
    }
    if (!PINFO_FD_VISITED(pinfo)) {
        gint key = cid;
        rohc_cid_context = (rohc_cid_context_t*)g_hash_table_lookup(rohc_cid_hash, GUINT_TO_POINTER(key));
        if (!rohc_cid_context) {
            rohc_cid_context = wmem_new(wmem_file_scope(), rohc_cid_context_t);
            rohc_cid_context->rnd = p_rohc_info->rnd;
            rohc_cid_context->udp_checksum_present = p_rohc_info->udp_checksum_present;
            rohc_cid_context->profile = p_rohc_info->profile;
            rohc_cid_context->mode = p_rohc_info->mode;
            rohc_cid_context->rohc_ip_version = p_rohc_info->rohc_ip_version;
            rohc_cid_context->large_cid_present = p_rohc_info->large_cid_present;
            rohc_cid_context->prev_ir_frame_number = -1;
            rohc_cid_context->ir_frame_number = -1;
        }
        p_add_proto_data(wmem_file_scope(), pinfo, proto_rohc, 0, rohc_cid_context);
    } else {
        rohc_cid_context = (rohc_cid_context_t*)p_get_proto_data(wmem_file_scope(), pinfo, proto_rohc, 0);
    }
    DISSECTOR_ASSERT(rohc_cid_context);
    if (rohc_cid_context->profile==ROHC_PROFILE_UNCOMPRESSED) {
        if (rohc_cid_context->large_cid_present) {
            get_self_describing_var_len_val(tvb, rohc_tree, offset+1, hf_rohc_large_cid, &val_len);
            gint len = tvb_captured_length_remaining(tvb, offset);
            if (len >= val_len) {
                len -= val_len;
                guint8 *payload_data = (guint8 *)wmem_alloc(pinfo->pool, len);
                tvb_memcpy(tvb, payload_data, offset, 1);
                tvb_memcpy(tvb, &payload_data[1], offset+1+val_len, len-1);
                next_tvb = tvb_new_child_real_data(tvb, payload_data, len, len);
                add_new_data_source(pinfo, next_tvb, "Payload");
            }
        }
        else {
            next_tvb = tvb_new_subset_remaining(tvb, offset);
        }
        if ((oct&0xf0)==0x40) {
            call_dissector(ip_handle, next_tvb, pinfo, tree);
        }
        else if ((oct&0xf0)==0x60) {
            call_dissector(ipv6_handle, next_tvb, pinfo, tree);
        }
        else {
            call_data_dissector(next_tvb, pinfo, tree);
        }
        col_prepend_fstr(pinfo->cinfo, COL_PROTOCOL, "ROHC/");
        return tvb_captured_length(tvb);
    }
    else if (((oct&0x80)==0x00) &&
             ((rohc_cid_context->profile==ROHC_PROFILE_RTP) || (rohc_cid_context->profile==ROHC_PROFILE_UDP))) {
        offset = dissect_rohc_pkt_type_0(tvb, pinfo, rohc_tree, offset, oct, rohc_cid_context);
    } else if ((oct&0xc0)==0x80) {
        if (rohc_cid_context->mode == RELIABLE_BIDIRECTIONAL) {
            offset = dissect_rohc_pkt_type_1_r_mode(tvb, pinfo, rohc_tree, offset, rohc_cid_context);
        }
        else {
            offset = dissect_rohc_pkt_type_1_u_o_mode(tvb, pinfo, rohc_tree, offset, rohc_cid_context);
        }
    } else if ((oct&0xe0)==0xc0) {
        offset = dissect_rohc_pkt_type_2(tvb, pinfo, rohc_tree, offset, rohc_cid_context);
    }
    if (rohc_cid_context->rnd) {
        proto_tree_add_item(rohc_tree, hf_rohc_ip_id, tvb, offset, 2, ENC_BIG_ENDIAN);
        offset += 2;
    }
    if (rohc_cid_context->udp_checksum_present) {
        proto_tree_add_checksum(rohc_tree, tvb, offset, hf_rohc_udp_checksum, -1, NULL, pinfo, 0, ENC_BIG_ENDIAN, PROTO_CHECKSUM_NO_FLAGS);
        offset += 2;
    }
    payload_tvb = tvb_new_subset_remaining(tvb, offset);
    call_data_dissector(payload_tvb, pinfo, tree);
    return tvb_captured_length(tvb);
}
