process_specified_records(capture_file *cf, packet_range_t *range,
        const char *string1, const char *string2, gboolean terminate_is_stop,
        bool (*callback)(capture_file *, frame_data *,
            wtap_rec *, Buffer *, void *),
        void *callback_args,
        gboolean show_progress_bar)
{
    guint32          framenum;
    frame_data      *fdata;
    wtap_rec         rec;
    Buffer           buf;
    psp_return_t     ret     = PSP_FINISHED;
    progdlg_t       *progbar = NULL;
    GTimer          *prog_timer = g_timer_new();
    int              progbar_count;
    float            progbar_val;
    gchar            progbar_status_str[100];
    range_process_e  process_this;
    wtap_rec_init(&rec);
    ws_buffer_init(&buf, 1514);
    g_timer_start(prog_timer);
    progbar_count = 0;
    progbar_val = 0.0f;
    if (cf->read_lock) {
        ws_warning("Failing due to nested process_specified_records(\"%s\") call!", cf->filename);
        return PSP_FAILED;
    }
    cf->read_lock = TRUE;
    cf->stop_flag = FALSE;
    if (range != NULL)
        packet_range_process_init(range);
    for (framenum = 1; framenum <= cf->count; framenum++) {
        fdata = frame_data_sequence_find(cf->provider.frames, framenum);
        if (show_progress_bar && progbar == NULL)
            progbar = delayed_create_progress_dlg(cf->window, string1, string2,
                    terminate_is_stop,
                    &cf->stop_flag,
                    progbar_val);
        if (progbar && g_timer_elapsed(prog_timer, NULL) > PROGBAR_UPDATE_INTERVAL) {
            ws_assert(cf->count > 0);
            progbar_val = (gfloat) progbar_count / cf->count;
            snprintf(progbar_status_str, sizeof(progbar_status_str),
                    "%4u of %u packets", progbar_count, cf->count);
            update_progress_dlg(progbar, progbar_val, progbar_status_str);
            g_timer_start(prog_timer);
        }
        if (cf->stop_flag) {
            ret = PSP_STOPPED;
            break;
        }
        progbar_count++;
        if (range != NULL) {
            process_this = packet_range_process_packet(range, fdata);
            if (process_this == range_process_next) {
                continue;
            } else if (process_this == range_processing_finished) {
                break;
            }
        }
        if (!cf_read_record(cf, fdata, &rec, &buf)) {
            ret = PSP_FAILED;
            break;
        }
        if (!callback(cf, fdata, &rec, &buf, callback_args)) {
            ret = PSP_FAILED;
            break;
        }
        wtap_rec_reset(&rec);
    }
    if (progbar != NULL)
        destroy_progress_dlg(progbar);
    g_timer_destroy(prog_timer);
    cf->read_lock = FALSE;
    wtap_rec_cleanup(&rec);
    ws_buffer_free(&buf);
    return ret;
}
