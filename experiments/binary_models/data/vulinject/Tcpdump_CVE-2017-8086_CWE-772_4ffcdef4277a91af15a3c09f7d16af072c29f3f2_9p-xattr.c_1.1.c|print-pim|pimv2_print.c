pimv2_print(netdissect_options *ndo,
            const u_char *bp, u_int len, const u_char *bp2)
{
	const struct pim *pim = (const struct pim *)bp;
	int advance;
	int subtype;
	enum checksum_status cksum_status;
	u_int pim_typever;
	u_int pimv2_addr_len;
	ndo->ndo_protocol = "pimv2";
	if (len < 2) {
		nd_print_invalid(ndo);
		return;
	}
	pim_typever = GET_U_1(pim->pim_typever);
	pimv2_addr_len = GET_U_1(pim->pim_rsv) & 0x0f;
	if (pimv2_addr_len != 0)
		ND_PRINT(", RFC2117-encoding");
	if (len < 4) {
		ND_PRINT("[length %u < 4]", len);
		nd_print_invalid(ndo);
		return;
	}
	ND_PRINT(", cksum 0x%04x ", GET_BE_U_2(pim->pim_cksum));
	if (GET_BE_U_2(pim->pim_cksum) == 0) {
		ND_PRINT("(unverified)");
	} else {
		if (PIM_TYPE(pim_typever) == PIMV2_TYPE_REGISTER) {
			cksum_status = pimv2_check_checksum(ndo, bp, bp2, 8);
			if (cksum_status == INCORRECT) {
				cksum_status = pimv2_check_checksum(ndo, bp, bp2, len);
			}
		} else {
			cksum_status = pimv2_check_checksum(ndo, bp, bp2, len);
		}
		switch (cksum_status) {
		case CORRECT:
			ND_PRINT("(correct)");
			break;
		case INCORRECT:
			ND_PRINT("(incorrect)");
			break;
		case UNVERIFIED:
			ND_PRINT("(unverified)");
			break;
		}
	}
	bp += 4;
	len -= 4;
	switch (PIM_TYPE(pim_typever)) {
	case PIMV2_TYPE_HELLO:
	    {
		unsigned short otype, olen;
		while (len != 0) {
			if (len < 4)
				goto trunc;
			otype = GET_BE_U_2(bp);
			olen = GET_BE_U_2(bp + 2);
			ND_PRINT("\n\t  %s Option (%u), length %u, Value: ",
			          tok2str(pimv2_hello_option_values, "Unknown", otype),
			          otype,
			          olen);
			bp += 4;
			len -= 4;
			if (len < olen)
				goto trunc;
			ND_TCHECK_LEN(bp, olen);
			switch (otype) {
			case PIMV2_HELLO_OPTION_HOLDTIME:
				if (olen != 2) {
					ND_PRINT("[option length %u != 2]", olen);
					nd_print_invalid(ndo);
					return;
				} else {
					unsigned_relts_print(ndo,
							     GET_BE_U_2(bp));
				}
				break;
			case PIMV2_HELLO_OPTION_LANPRUNEDELAY:
				if (olen != 4) {
					ND_PRINT("[option length %u != 4]", olen);
					nd_print_invalid(ndo);
					return;
				} else {
					char t_bit;
					unsigned short lan_delay, override_interval;
					lan_delay = GET_BE_U_2(bp);
					override_interval = GET_BE_U_2(bp + 2);
					t_bit = (lan_delay & 0x8000)? 1 : 0;
					lan_delay &= ~0x8000;
					ND_PRINT("\n\t    T-bit=%u, LAN delay %ums, Override interval %ums",
					t_bit, lan_delay, override_interval);
				}
				break;
			case PIMV2_HELLO_OPTION_DR_PRIORITY_OLD:
			case PIMV2_HELLO_OPTION_DR_PRIORITY:
				switch (olen) {
				case 0:
					ND_PRINT("Bi-Directional Capability (Old)");
					break;
				case 4:
					ND_PRINT("%u", GET_BE_U_4(bp));
					break;
				default:
					ND_PRINT("[option length %u != 4]", olen);
					nd_print_invalid(ndo);
					return;
				}
				break;
			case PIMV2_HELLO_OPTION_GENID:
				if (olen != 4) {
					ND_PRINT("[option length %u != 4]", olen);
					nd_print_invalid(ndo);
					return;
				} else {
					ND_PRINT("0x%08x", GET_BE_U_4(bp));
				}
				break;
			case PIMV2_HELLO_OPTION_REFRESH_CAP:
				if (olen != 4) {
					ND_PRINT("[option length %u != 4]", olen);
					nd_print_invalid(ndo);
					return;
				} else {
					ND_PRINT("v%u", GET_U_1(bp));
					if (GET_U_1(bp + 1) != 0) {
						ND_PRINT(", interval ");
						unsigned_relts_print(ndo,
								     GET_U_1(bp + 1));
					}
					if (GET_BE_U_2(bp + 2) != 0) {
						ND_PRINT(" ?0x%04x?",
							 GET_BE_U_2(bp + 2));
					}
				}
				break;
			case  PIMV2_HELLO_OPTION_BIDIR_CAP:
				break;
			case PIMV2_HELLO_OPTION_ADDRESS_LIST_OLD:
			case PIMV2_HELLO_OPTION_ADDRESS_LIST:
				if (ndo->ndo_vflag > 1) {
					const u_char *ptr = bp;
					u_int plen = len;
					while (ptr < (bp+olen)) {
						ND_PRINT("\n\t    ");
						advance = pimv2_addr_print(ndo, ptr, plen, pimv2_unicast, pimv2_addr_len, 0);
						if (advance < 0)
							goto trunc;
						ptr += advance;
						plen -= advance;
					}
				}
				break;
			default:
				if (ndo->ndo_vflag <= 1)
					print_unknown_data(ndo, bp, "\n\t    ", olen);
				break;
			}
			if (ndo->ndo_vflag> 1)
				print_unknown_data(ndo, bp, "\n\t    ", olen);
			bp += olen;
			len -= olen;
		}
		break;
	    }
	case PIMV2_TYPE_REGISTER:
	{
		const struct ip *ip;
		if (len < 4)
			goto trunc;
		ND_TCHECK_LEN(bp, PIMV2_REGISTER_FLAG_LEN);
		ND_PRINT(", Flags [ %s ]\n\t",
		          tok2str(pimv2_register_flag_values,
		          "none",
		          GET_BE_U_4(bp)));
		bp += 4; len -= 4;
		if (len == 0)
			goto trunc;
		ip = (const struct ip *)bp;
		switch (IP_V(ip)) {
                case 0: 
			ND_PRINT("IP-Null-header %s > %s",
			          GET_IPADDR_STRING(ip->ip_src),
			          GET_IPADDR_STRING(ip->ip_dst));
			break;
		case 4:	
			ip_print(ndo, bp, len);
			break;
		case 6:	
			ip6_print(ndo, bp, len);
			break;
		default:
			ND_PRINT("IP ver %u", IP_V(ip));
			break;
		}
		break;
	}
	case PIMV2_TYPE_REGISTER_STOP:
		ND_PRINT(" group=");
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_group, pimv2_addr_len, 0)) < 0)
			goto trunc;
		bp += advance; len -= advance;
		ND_PRINT(" source=");
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
			goto trunc;
		bp += advance; len -= advance;
		break;
	case PIMV2_TYPE_JOIN_PRUNE:
	case PIMV2_TYPE_GRAFT:
	case PIMV2_TYPE_GRAFT_ACK:
	    {
		unsigned char ngroup;
		unsigned short holdtime;
		unsigned short njoin;
		unsigned short nprune;
		u_int i, j;
		if (PIM_TYPE(pim_typever) != 7) {	
			ND_PRINT(", upstream-neighbor: ");
			if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
				goto trunc;
			bp += advance; len -= advance;
		}
		if (len < 4)
			goto trunc;
		ND_TCHECK_4(bp);
		ngroup = GET_U_1(bp + 1);
		holdtime = GET_BE_U_2(bp + 2);
		ND_PRINT("\n\t  %u group(s)", ngroup);
		if (PIM_TYPE(pim_typever) != 7) {	
			ND_PRINT(", holdtime: ");
			if (holdtime == 0xffff)
				ND_PRINT("infinite");
			else
				unsigned_relts_print(ndo, holdtime);
		}
		bp += 4; len -= 4;
		for (i = 0; i < ngroup; i++) {
			ND_PRINT("\n\t    group #%u: ", i+1);
			if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_group, pimv2_addr_len, 0)) < 0)
				goto trunc;
			bp += advance; len -= advance;
			if (len < 4)
				goto trunc;
			ND_TCHECK_4(bp);
			njoin = GET_BE_U_2(bp);
			nprune = GET_BE_U_2(bp + 2);
			ND_PRINT(", joined sources: %u, pruned sources: %u", njoin, nprune);
			bp += 4; len -= 4;
			for (j = 0; j < njoin; j++) {
				ND_PRINT("\n\t      joined source #%u: ", j+1);
				if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_source, pimv2_addr_len, 0)) < 0)
					goto trunc;
				bp += advance; len -= advance;
			}
			for (j = 0; j < nprune; j++) {
				ND_PRINT("\n\t      pruned source #%u: ", j+1);
				if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_source, pimv2_addr_len, 0)) < 0)
					goto trunc;
				bp += advance; len -= advance;
			}
		}
		break;
	    }
	case PIMV2_TYPE_BOOTSTRAP:
	{
		u_int i, j, frpcnt;
		if (len < 2)
			goto trunc;
		ND_PRINT(" tag=%x", GET_BE_U_2(bp));
		bp += 2;
		len -= 2;
		if (len < 1)
			goto trunc;
		ND_PRINT(" hashmlen=%u", GET_U_1(bp));
		if (len < 2)
			goto trunc;
		ND_TCHECK_1(bp + 2);
		ND_PRINT(" BSRprio=%u", GET_U_1(bp + 1));
		bp += 2;
		len -= 2;
		ND_PRINT(" BSR=");
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
			goto trunc;
		bp += advance;
		len -= advance;
		for (i = 0; len > 0; i++) {
			ND_PRINT(" (group%u: ", i);
			if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_group, pimv2_addr_len, 0)) < 0)
				goto trunc;
			bp += advance;
			len -= advance;
			if (len < 1)
				goto trunc;
			ND_PRINT(" RPcnt=%u", GET_U_1(bp));
			if (len < 2)
				goto trunc;
			frpcnt = GET_U_1(bp + 1);
			ND_PRINT(" FRPcnt=%u", frpcnt);
			if (len < 4)
				goto trunc;
			bp += 4;
			len -= 4;
			for (j = 0; j < frpcnt && len > 0; j++) {
				ND_PRINT(" RP%u=", j);
				if ((advance = pimv2_addr_print(ndo, bp, len,
								pimv2_unicast,
								pimv2_addr_len,
								0)) < 0)
					goto trunc;
				bp += advance;
				len -= advance;
				if (len < 2)
					goto trunc;
				ND_PRINT(",holdtime=");
				unsigned_relts_print(ndo,
						     GET_BE_U_2(bp));
				if (len < 3)
					goto trunc;
				ND_PRINT(",prio=%u", GET_U_1(bp + 2));
				if (len < 4)
					goto trunc;
				bp += 4;
				len -= 4;
			}
			ND_PRINT(")");
		}
		break;
	}
	case PIMV2_TYPE_ASSERT:
		ND_PRINT(" group=");
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_group, pimv2_addr_len, 0)) < 0)
			goto trunc;
		bp += advance; len -= advance;
		ND_PRINT(" src=");
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
			goto trunc;
		bp += advance; len -= advance;
		if (len < 8)
			goto trunc;
		ND_TCHECK_8(bp);
		if (GET_U_1(bp) & 0x80)
			ND_PRINT(" RPT");
		ND_PRINT(" pref=%u", GET_BE_U_4(bp) & 0x7fffffff);
		ND_PRINT(" metric=%u", GET_BE_U_4(bp + 4));
		break;
	case PIMV2_TYPE_CANDIDATE_RP:
	{
		u_int i, pfxcnt;
		if (len < 1)
			goto trunc;
		ND_PRINT(" prefix-cnt=%u", GET_U_1(bp));
		pfxcnt = GET_U_1(bp);
		if (len < 2)
			goto trunc;
		ND_PRINT(" prio=%u", GET_U_1(bp + 1));
		if (len < 4)
			goto trunc;
		ND_PRINT(" holdtime=");
		unsigned_relts_print(ndo, GET_BE_U_2(bp + 2));
		bp += 4;
		len -= 4;
		ND_PRINT(" RP=");
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
			goto trunc;
		bp += advance;
		len -= advance;
		for (i = 0; i < pfxcnt && len > 0; i++) {
			ND_PRINT(" Group%u=", i);
			if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_group, pimv2_addr_len, 0)) < 0)
				goto trunc;
			bp += advance;
			len -= advance;
		}
		break;
	}
	case PIMV2_TYPE_PRUNE_REFRESH:
		ND_PRINT(" src=");
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
			goto trunc;
		bp += advance;
		len -= advance;
		ND_PRINT(" grp=");
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_group, pimv2_addr_len, 0)) < 0)
			goto trunc;
		bp += advance;
		len -= advance;
		ND_PRINT(" forwarder=");
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
			goto trunc;
		bp += advance;
		len -= advance;
		if (len < 2)
			goto trunc;
		ND_PRINT(" TUNR ");
		unsigned_relts_print(ndo, GET_BE_U_2(bp));
		break;
	case PIMV2_TYPE_DF_ELECTION:
		subtype = PIM_SUBTYPE(GET_U_1(pim->pim_rsv));
		ND_PRINT("\n\t  %s,", tok2str( pimv2_df_election_flag_values,
			 "Unknown", subtype) );
		ND_PRINT(" rpa=");
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0) {
			goto trunc;
		}
		bp += advance;
		len -= advance;
		ND_PRINT(" sender pref=%u", GET_BE_U_4(bp) );
		ND_PRINT(" sender metric=%u", GET_BE_U_4(bp + 4));
		bp += 8;
		len -= 8;
		switch (subtype) {
		case PIMV2_DF_ELECTION_BACKOFF:
		case PIMV2_DF_ELECTION_PASS:
			ND_PRINT("\n\t  %s addr=", PIMV2_DF_ELECTION_PASS_BACKOFF_STR(subtype));
			if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0) {
				goto trunc;
			}
			bp += advance;
			len -= advance;
			ND_PRINT(" %s pref=%u", PIMV2_DF_ELECTION_PASS_BACKOFF_STR(subtype), GET_BE_U_4(bp) );
			ND_PRINT(" %s metric=%u", PIMV2_DF_ELECTION_PASS_BACKOFF_STR(subtype), GET_BE_U_4(bp + 4));
			bp += 8;
			len -= 8;
			if (subtype == PIMV2_DF_ELECTION_BACKOFF) {
				ND_PRINT(" interval %dms", GET_BE_U_2(bp));
			}
			break;
		default:
			break;
		}
		break;
	 default:
		ND_PRINT(" [type %u]", PIM_TYPE(pim_typever));
		break;
	}
	return;
trunc:
	nd_print_trunc(ndo);
}
