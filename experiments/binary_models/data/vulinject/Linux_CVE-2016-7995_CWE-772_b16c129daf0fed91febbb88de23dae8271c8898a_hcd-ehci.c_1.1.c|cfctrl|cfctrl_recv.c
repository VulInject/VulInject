static int cfctrl_recv(struct cflayer *layer, struct cfpkt *pkt)
{
	unsigned char cmdrsp;
	unsigned char cmd;
	int ret = -1;
	unsigned char len;
	unsigned char param[255];
	unsigned char linkid = 0;
	struct cfctrl *cfctrl = container_obj(layer);
	struct cfctrl_request_info rsp, *req;
	cmdrsp = cfpkt_extr_head_u8(pkt);
	cmd = cmdrsp & CFCTRL_CMD_MASK;
	if (cmd != CFCTRL_CMD_LINK_ERR
	    && CFCTRL_RSP_BIT != (CFCTRL_RSP_BIT & cmdrsp)
		&& CFCTRL_ERR_BIT != (CFCTRL_ERR_BIT & cmdrsp)) {
		if (handle_loop(cfctrl, cmd, pkt) != 0)
			cmdrsp |= CFCTRL_ERR_BIT;
	}
	switch (cmd) {
	case CFCTRL_CMD_LINK_SETUP:
		{
			enum cfctrl_srv serv;
			enum cfctrl_srv servtype;
			unsigned char endpoint;
			unsigned char physlinkid;
			unsigned char prio;
			unsigned char tmp;
			unsigned char *cp;
			int i;
			struct cfctrl_link_param linkparam;
			memset(&linkparam, 0, sizeof(linkparam));
			tmp = cfpkt_extr_head_u8(pkt);
			serv = tmp & CFCTRL_SRV_MASK;
			linkparam.linktype = serv;
			servtype = tmp >> 4;
			linkparam.chtype = servtype;
			tmp = cfpkt_extr_head_u8(pkt);
			physlinkid = tmp & 0x07;
			prio = tmp >> 3;
			linkparam.priority = prio;
			linkparam.phyid = physlinkid;
			endpoint = cfpkt_extr_head_u8(pkt);
			linkparam.endpoint = endpoint & 0x03;
			switch (serv) {
			case CFCTRL_SRV_VEI:
			case CFCTRL_SRV_DBG:
				if (CFCTRL_ERR_BIT & cmdrsp)
					break;
				linkid = cfpkt_extr_head_u8(pkt);
				break;
			case CFCTRL_SRV_VIDEO:
				tmp = cfpkt_extr_head_u8(pkt);
				linkparam.u.video.connid = tmp;
				if (CFCTRL_ERR_BIT & cmdrsp)
					break;
				linkid = cfpkt_extr_head_u8(pkt);
				break;
			case CFCTRL_SRV_DATAGRAM:
				linkparam.u.datagram.connid =
				    cfpkt_extr_head_u32(pkt);
				if (CFCTRL_ERR_BIT & cmdrsp)
					break;
				linkid = cfpkt_extr_head_u8(pkt);
				break;
			case CFCTRL_SRV_RFM:
				linkparam.u.rfm.connid =
				    cfpkt_extr_head_u32(pkt);
				cp = (unsigned char *) linkparam.u.rfm.volume;
				for (tmp = cfpkt_extr_head_u8(pkt);
				     cfpkt_more(pkt) && tmp != '\0';
				     tmp = cfpkt_extr_head_u8(pkt))
					*cp++ = tmp;
				*cp = '\0';
				if (CFCTRL_ERR_BIT & cmdrsp)
					break;
				linkid = cfpkt_extr_head_u8(pkt);
				break;
			case CFCTRL_SRV_UTIL:
				linkparam.u.utility.fifosize_kb =
				    cfpkt_extr_head_u16(pkt);
				linkparam.u.utility.fifosize_bufs =
				    cfpkt_extr_head_u16(pkt);
				cp = (unsigned char *) linkparam.u.utility.name;
				caif_assert(sizeof(linkparam.u.utility.name)
					     >= UTILITY_NAME_LENGTH);
				for (i = 0;
				     i < UTILITY_NAME_LENGTH
				     && cfpkt_more(pkt); i++) {
					tmp = cfpkt_extr_head_u8(pkt);
					*cp++ = tmp;
				}
				len = cfpkt_extr_head_u8(pkt);
				linkparam.u.utility.paramlen = len;
				cp = linkparam.u.utility.params;
				while (cfpkt_more(pkt) && len--) {
					tmp = cfpkt_extr_head_u8(pkt);
					*cp++ = tmp;
				}
				if (CFCTRL_ERR_BIT & cmdrsp)
					break;
				linkid = cfpkt_extr_head_u8(pkt);
				len = cfpkt_extr_head_u8(pkt);
				cfpkt_extr_head(pkt, &param, len);
				break;
			default:
				pr_warn("Request setup, invalid type (%d)\n",
					serv);
				goto error;
			}
			rsp.cmd = cmd;
			rsp.param = linkparam;
			req = cfctrl_remove_req(cfctrl, &rsp);
			if (CFCTRL_ERR_BIT == (CFCTRL_ERR_BIT & cmdrsp) ||
				cfpkt_erroneous(pkt)) {
				pr_err("Invalid O/E bit or parse error "
						"on CAIF control channel\n");
				cfctrl->res.reject_rsp(cfctrl->serv.layer.up,
						       0,
						       req ? req->client_layer
						       : NULL);
			} else {
				cfctrl->res.linksetup_rsp(cfctrl->serv.
							  layer.up, linkid,
							  serv, physlinkid,
							  req ? req->
							  client_layer : NULL);
			}
			kfree(req);
			spin_unlock_bh(&cfctrl->info_list_lock);
		}
		break;
	case CFCTRL_CMD_LINK_DESTROY:
		linkid = cfpkt_extr_head_u8(pkt);
		cfctrl->res.linkdestroy_rsp(cfctrl->serv.layer.up, linkid);
		break;
	case CFCTRL_CMD_LINK_ERR:
		pr_err("Frame Error Indication received\n");
		cfctrl->res.linkerror_ind();
		break;
	case CFCTRL_CMD_ENUM:
		cfctrl->res.enum_rsp();
		break;
	case CFCTRL_CMD_SLEEP:
		cfctrl->res.sleep_rsp();
		break;
	case CFCTRL_CMD_WAKE:
		cfctrl->res.wake_rsp();
		break;
	case CFCTRL_CMD_LINK_RECONF:
		cfctrl->res.restart_rsp();
		break;
	case CFCTRL_CMD_RADIO_SET:
		cfctrl->res.radioset_rsp();
		break;
	default:
		pr_err("Unrecognized Control Frame\n");
		goto error;
	}
	ret = 0;
error:
	cfpkt_destroy(pkt);
	return ret;
}
