sctp_print(netdissect_options *ndo,
	   const u_char *bp,        
	   const u_char *bp2,       
	   u_int sctpPacketLength)  
{
  u_int sctpPacketLengthRemaining;
  const struct sctpHeader *sctpPktHdr;
  const struct ip *ip;
  const struct ip6_hdr *ip6;
  unsigned char chunkID;
  u_short sourcePort, destPort;
  u_int chunkCount;
  const struct sctpChunkDesc *chunkDescPtr;
  const char *sep;
  int isforces = 0;
  ndo->ndo_protocol = "sctp";
  ND_ICHECKMSG_ZU("length", sctpPacketLength, <, sizeof(struct sctpHeader));
  sctpPktHdr = (const struct sctpHeader*) bp;
  ND_TCHECK_SIZE(sctpPktHdr);
  sctpPacketLengthRemaining = sctpPacketLength;
  sourcePort = GET_BE_U_2(sctpPktHdr->source);
  destPort = GET_BE_U_2(sctpPktHdr->destination);
  ip = (const struct ip *)bp2;
  if (IP_V(ip) == 6)
    ip6 = (const struct ip6_hdr *)bp2;
  else
    ip6 = NULL;
  if (ip6) {
    ND_PRINT("%s.%u > %s.%u: sctp",
      GET_IP6ADDR_STRING(ip6->ip6_src),
      sourcePort,
      GET_IP6ADDR_STRING(ip6->ip6_dst),
      destPort);
  } else {
    ND_PRINT("%s.%u > %s.%u: sctp",
      GET_IPADDR_STRING(ip->ip_src),
      sourcePort,
      GET_IPADDR_STRING(ip->ip_dst),
      destPort);
  }
  if (isForCES_port(sourcePort)) {
	 ND_PRINT("[%s]", tok2str(ForCES_channels, NULL, sourcePort));
	 isforces = 1;
  }
  if (isForCES_port(destPort)) {
	 ND_PRINT("[%s]", tok2str(ForCES_channels, NULL, destPort));
	 isforces = 1;
  }
  bp += sizeof(struct sctpHeader);
  sctpPacketLengthRemaining -= sizeof(struct sctpHeader);
  if (ndo->ndo_vflag >= 2)
    sep = "\n\t";
  else
    sep = " (";
  for (chunkCount = 0, chunkDescPtr = (const struct sctpChunkDesc *)bp;
      sctpPacketLengthRemaining != 0;
      chunkCount++)
    {
      unsigned short chunkLength, chunkLengthRemaining;
      unsigned short align;
      chunkDescPtr = (const struct sctpChunkDesc *)bp;
      if (sctpPacketLengthRemaining < sizeof(*chunkDescPtr)) {
	ND_PRINT("%s%u) [chunk descriptor cut off at end of packet]", sep, chunkCount+1);
	break;
      }
      ND_TCHECK_SIZE(chunkDescPtr);
      chunkLength = GET_BE_U_2(chunkDescPtr->chunkLength);
      if (chunkLength < sizeof(*chunkDescPtr)) {
	ND_PRINT("%s%u) [Bad chunk length %u, < size of chunk descriptor]", sep, chunkCount+1, chunkLength);
	break;
      }
      chunkLengthRemaining = chunkLength;
      align = chunkLength % 4;
      if (align != 0)
	align = 4 - align;
      if (sctpPacketLengthRemaining < align) {
	ND_PRINT("%s%u) [Bad chunk length %u, > remaining data in packet]", sep, chunkCount+1, chunkLength);
	break;
      }
      bp += sizeof(*chunkDescPtr);
      sctpPacketLengthRemaining -= sizeof(*chunkDescPtr);
      chunkLengthRemaining -= sizeof(*chunkDescPtr);
      ND_PRINT("%s%u) ", sep, chunkCount+1);
      chunkID = GET_U_1(chunkDescPtr->chunkID);
      ND_PRINT("[%s] ", tok2str(sctp_chunkid_str, "Unknown chunk type: 0x%x",
	       chunkID));
      switch (chunkID) {
	case SCTP_DATA :
	  {
	    const struct sctpDataPart *dataHdrPtr;
	    unsigned char chunkFlg;
	    unsigned int ppid;
	    unsigned short payload_size;
	    chunkFlg = GET_U_1(chunkDescPtr->chunkFlg);
	    if ((chunkFlg & SCTP_DATA_UNORDERED) == SCTP_DATA_UNORDERED)
	      ND_PRINT("(U)");
	    if ((chunkFlg & SCTP_DATA_FIRST_FRAG) == SCTP_DATA_FIRST_FRAG)
	      ND_PRINT("(B)");
	    if ((chunkFlg & SCTP_DATA_LAST_FRAG) == SCTP_DATA_LAST_FRAG)
	      ND_PRINT("(E)");
	    if( ((chunkFlg & SCTP_DATA_UNORDERED) == SCTP_DATA_UNORDERED) ||
		((chunkFlg & SCTP_DATA_FIRST_FRAG) == SCTP_DATA_FIRST_FRAG) ||
		((chunkFlg & SCTP_DATA_LAST_FRAG) == SCTP_DATA_LAST_FRAG) )
	      ND_PRINT(" ");
	    ND_ICHECKMSG_ZU("chunk length", chunkLengthRemaining, <,
			    sizeof(*dataHdrPtr));
	    dataHdrPtr=(const struct sctpDataPart*)bp;
	    ppid = GET_BE_U_4(dataHdrPtr->payloadtype);
	    ND_PRINT("[TSN: %u] ", GET_BE_U_4(dataHdrPtr->TSN));
	    ND_PRINT("[SID: %u] ", GET_BE_U_2(dataHdrPtr->streamId));
	    ND_PRINT("[SSEQ %u] ", GET_BE_U_2(dataHdrPtr->sequence));
	    ND_PRINT("[PPID %s] ",
		    tok2str(PayloadProto_idents, "0x%x", ppid));
	    if (!isforces) {
		isforces = (ppid == SCTP_PPID_FORCES_HP) ||
		    (ppid == SCTP_PPID_FORCES_MP) ||
		    (ppid == SCTP_PPID_FORCES_LP);
	    }
	    bp += sizeof(*dataHdrPtr);
	    sctpPacketLengthRemaining -= sizeof(*dataHdrPtr);
	    chunkLengthRemaining -= sizeof(*dataHdrPtr);
	    ND_ICHECKMSG_U("chunk length", chunkLengthRemaining, ==, 0);
	    payload_size = chunkLengthRemaining;
	    if (isforces) {
		forces_print(ndo, bp, payload_size);
		ndo->ndo_protocol = "sctp";
	    } else if (ndo->ndo_vflag >= 2) {	
		switch (ppid) {
		case SCTP_PPID_M3UA :
			m3ua_print(ndo, bp, payload_size);
			ndo->ndo_protocol = "sctp";
			break;
		default:
			ND_PRINT("[Payload");
			if (!ndo->ndo_suppress_default_print) {
				ND_PRINT(":");
				ND_DEFAULTPRINT(bp, payload_size);
			}
			ND_PRINT("]");
			break;
		}
	    }
	    bp += payload_size;
	    sctpPacketLengthRemaining -= payload_size;
	    chunkLengthRemaining -= payload_size;
	    break;
	  }
	case SCTP_INITIATION :
	  {
	    const struct sctpInitiation *init;
	    ND_ICHECKMSG_ZU("chunk length", chunkLengthRemaining, <,
			    sizeof(*init));
	    init=(const struct sctpInitiation*)bp;
	    ND_PRINT("[init tag: %u] ", GET_BE_U_4(init->initTag));
	    ND_PRINT("[rwnd: %u] ", GET_BE_U_4(init->rcvWindowCredit));
	    ND_PRINT("[OS: %u] ", GET_BE_U_2(init->NumPreopenStreams));
	    ND_PRINT("[MIS: %u] ", GET_BE_U_2(init->MaxInboundStreams));
	    ND_PRINT("[init TSN: %u] ", GET_BE_U_4(init->initialTSN));
	    bp += sizeof(*init);
	    sctpPacketLengthRemaining -= sizeof(*init);
	    chunkLengthRemaining -= sizeof(*init);
#if 0 
	    if( chunkLengthRemaining != 0 )
	      ND_PRINT(" @@@@@ UNFINISHED @@@@@@%s\n",
		     "Optional params present, but not printed.");
#endif
	    bp += chunkLengthRemaining;
	    sctpPacketLengthRemaining -= chunkLengthRemaining;
	    chunkLengthRemaining = 0;
	    break;
	  }
	case SCTP_INITIATION_ACK :
	  {
	    const struct sctpInitiation *init;
	    ND_ICHECKMSG_ZU("chunk length", chunkLengthRemaining, <,
			    sizeof(*init));
	    init=(const struct sctpInitiation*)bp;
	    ND_PRINT("[init tag: %u] ", GET_BE_U_4(init->initTag));
	    ND_PRINT("[rwnd: %u] ", GET_BE_U_4(init->rcvWindowCredit));
	    ND_PRINT("[OS: %u] ", GET_BE_U_2(init->NumPreopenStreams));
	    ND_PRINT("[MIS: %u] ", GET_BE_U_2(init->MaxInboundStreams));
	    ND_PRINT("[init TSN: %u] ", GET_BE_U_4(init->initialTSN));
	    bp += sizeof(*init);
	    sctpPacketLengthRemaining -= sizeof(*init);
	    chunkLengthRemaining -= sizeof(*init);
#if 0 
	    if( chunkLengthRemaining != 0 )
	      ND_PRINT(" @@@@@ UNFINISHED @@@@@@%s\n",
		     "Optional params present, but not printed.");
#endif
	    bp += chunkLengthRemaining;
	    sctpPacketLengthRemaining -= chunkLengthRemaining;
	    chunkLengthRemaining = 0;
	    break;
	  }
	case SCTP_SELECTIVE_ACK:
	  {
	    const struct sctpSelectiveAck *sack;
	    const struct sctpSelectiveFrag *frag;
	    u_int fragNo, tsnNo;
	    const u_char *dupTSN;
	    ND_ICHECKMSG_ZU("chunk length", chunkLengthRemaining, <,
			    sizeof(*sack));
	    sack=(const struct sctpSelectiveAck*)bp;
	    ND_PRINT("[cum ack %u] ", GET_BE_U_4(sack->highestConseqTSN));
	    ND_PRINT("[a_rwnd %u] ", GET_BE_U_4(sack->updatedRwnd));
	    ND_PRINT("[#gap acks %u] ", GET_BE_U_2(sack->numberOfdesc));
	    ND_PRINT("[#dup tsns %u] ", GET_BE_U_2(sack->numDupTsns));
	    bp += sizeof(*sack);
	    sctpPacketLengthRemaining -= sizeof(*sack);
	    chunkLengthRemaining -= sizeof(*sack);
	    for (fragNo=0;
		 chunkLengthRemaining != 0 && fragNo < GET_BE_U_2(sack->numberOfdesc);
		 bp += sizeof(*frag), sctpPacketLengthRemaining -= sizeof(*frag), chunkLengthRemaining -= sizeof(*frag), fragNo++) {
	      ND_ICHECKMSG_ZU("chunk length", chunkLengthRemaining, <,
			    sizeof(*frag));
	      frag = (const struct sctpSelectiveFrag *)bp;
	      ND_PRINT("\n\t\t[gap ack block #%u: start = %u, end = %u] ",
		     fragNo+1,
		     GET_BE_U_4(sack->highestConseqTSN) + GET_BE_U_2(frag->fragmentStart),
		     GET_BE_U_4(sack->highestConseqTSN) + GET_BE_U_2(frag->fragmentEnd));
	    }
	    for (tsnNo=0;
		 chunkLengthRemaining != 0 && tsnNo<GET_BE_U_2(sack->numDupTsns);
		 bp += 4, sctpPacketLengthRemaining -= 4, chunkLengthRemaining -= 4, tsnNo++) {
	      ND_ICHECKMSG_U("chunk length", chunkLengthRemaining, <, 4);
	      dupTSN = (const u_char *)bp;
	      ND_PRINT("\n\t\t[dup TSN #%u: %u] ", tsnNo+1,
		       GET_BE_U_4(dupTSN));
	    }
	    break;
	  }
	default :
	  {
	    bp += chunkLengthRemaining;
	    sctpPacketLengthRemaining -= chunkLengthRemaining;
	    chunkLengthRemaining = 0;
	    break;
	  }
	}
      bp += chunkLengthRemaining;
      sctpPacketLengthRemaining -= chunkLengthRemaining;
      if (ndo->ndo_vflag < 2)
	sep = ", (";
      if (align != 0) {
	ND_TCHECK_LEN(bp, align);
	bp += align;
	sctpPacketLengthRemaining -= align;
      }
    }
    return;
invalid:
    nd_print_invalid(ndo);
}
