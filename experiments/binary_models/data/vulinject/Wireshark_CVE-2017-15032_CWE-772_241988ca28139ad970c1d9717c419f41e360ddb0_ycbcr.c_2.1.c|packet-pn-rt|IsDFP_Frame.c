IsDFP_Frame(tvbuff_t *tvb, packet_info *pinfo, guint16 u16FrameID)
{
    guint16       u16SFCRC16;
    guint8        u8SFPosition;
    guint8        u8SFDataLength   = 255;
    int           offset           = 0;
    guint32       u32SubStart;
    guint16       crc;
    gint          tvb_len          = 0;
    unsigned char virtualFramebuffer[16];
    if (!pinfo->src.data || !pinfo->dst.data ||
            pinfo->dst.type != AT_ETHER || pinfo->src.type != AT_ETHER) {
        return FALSE;
    }
    memcpy(&virtualFramebuffer[0], pinfo->dst.data, 6);
    memcpy(&virtualFramebuffer[6], pinfo->src.data, 6);
    virtualFramebuffer[12] = 0x88;
    virtualFramebuffer[13] = 0x92;
    virtualFramebuffer[15] = (unsigned char) (u16FrameID &0xff);
    virtualFramebuffer[14] = (unsigned char) (u16FrameID>>8);
    crc = crc16_plain_init();
    crc = crc16_plain_update(crc, &virtualFramebuffer[0], 16);
    u16SFCRC16 = tvb_get_letohs(tvb, offset);
    if (u16SFCRC16 != 0) 
    {
        if (u16SFCRC16 != crc)
        {
            return FALSE;
        }
    }
    offset += 2;    
    tvb_len = tvb_captured_length(tvb);
    if (offset + 4 > tvb_len)
        return FALSE;
    if (tvb_get_letohs(tvb, offset) == 0)
        return FALSE;   
    while (1) {
        u32SubStart = offset;
        u8SFPosition = tvb_get_guint8(tvb, offset);
        offset += 1;
        u8SFDataLength = tvb_get_guint8(tvb, offset);
        offset += 1;
        if (u8SFDataLength == 0) {
            break;
        }
        offset += 2;
        offset += u8SFDataLength;
       if (offset > tvb_len)
           return FALSE;
        u16SFCRC16 = tvb_get_letohs(tvb, offset);
        if (u16SFCRC16 != 0) {
            if (u8SFPosition & 0x80) {
                crc = crc16_plain_tvb_offset_seed(tvb, u32SubStart, offset-u32SubStart, 0);
                if (crc != u16SFCRC16) {
                    return FALSE;
                } else {
                }
            } else {
            }
        }
        offset += 2;
    }
    return TRUE;
}
