static int trace_headers(AVBSFContext *bsf, AVPacket *pkt)
{
    TraceHeadersContext *ctx = bsf->priv_data;
    CodedBitstreamFragment *frag = &ctx->fragment;
    char tmp[256] = { 0 };
    int err;
    err = ff_bsf_get_packet_ref(bsf, pkt);
    if (err < 0)
        return err;
    if (pkt->flags & AV_PKT_FLAG_KEY)
        av_strlcat(tmp, ", key frame", sizeof(tmp));
    if (pkt->flags & AV_PKT_FLAG_CORRUPT)
        av_strlcat(tmp, ", corrupt", sizeof(tmp));
    if (pkt->pts != AV_NOPTS_VALUE)
        av_strlcatf(tmp, sizeof(tmp), ", pts %"PRId64, pkt->pts);
    else
        av_strlcat(tmp, ", no pts", sizeof(tmp));
    if (pkt->dts != AV_NOPTS_VALUE)
        av_strlcatf(tmp, sizeof(tmp), ", dts %"PRId64, pkt->dts);
    else
        av_strlcat(tmp, ", no dts", sizeof(tmp));
    if (pkt->duration > 0)
        av_strlcatf(tmp, sizeof(tmp), ", duration %"PRId64, pkt->duration);
    av_log(bsf, AV_LOG_INFO, "Packet: %d bytes%s.\n", pkt->size, tmp);
    if (av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, NULL)) {
        av_log(bsf, AV_LOG_INFO, "Side data:\n");
        err = ff_cbs_read_packet_side_data(ctx->cbc, frag, pkt);
        if (err < 0) {
            av_packet_unref(pkt);
            return err;
        }
        av_log(bsf, AV_LOG_INFO, "Payload:\n");
    }
    err = ff_cbs_read_packet(ctx->cbc, frag, pkt);
    ff_cbs_fragment_reset(frag);
    if (err < 0)
        av_packet_unref(pkt);
    return err;
}
