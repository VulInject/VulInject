static int npcm_i2c_init_module(struct npcm_i2c *bus, enum i2c_mode mode,
				unsigned int bus_freq_hz)
{
	unsigned char val;
	int ret;
	if ((bus->state != I2C_DISABLE && bus->state != I2C_IDLE) ||
	    bus_freq_hz < I2C_FREQ_MIN_HZ || bus_freq_hz > I2C_FREQ_MAX_HZ)
		return -EINVAL;
	npcm_i2c_int_enable(bus, false);
	npcm_i2c_disable(bus);
	if (FIELD_GET(I2C_VER_FIFO_EN, ioread8(bus->reg + I2C_VER))) {
		bus->fifo_use = true;
		val = ioread8(bus->reg + NPCM_I2CFIF_CTL);
		val |= NPCM_I2CFIF_CTL_FIFO_EN;
		iowrite8(val, bus->reg + NPCM_I2CFIF_CTL);
		npcm_i2c_select_bank(bus, I2C_BANK_1);
	} else {
		bus->fifo_use = false;
	}
	ret = npcm_i2c_init_clk(bus, bus_freq_hz);
	if (ret) {
		dev_err(bus->dev, "npcm_i2c_init_clk failed\n");
		return ret;
	}
	npcm_i2c_enable(bus);
	bus->state = I2C_IDLE;
	val = ioread8(bus->reg + NPCM_I2CCTL1);
	val = (val | NPCM_I2CCTL1_NMINTE) & ~NPCM_I2CCTL1_RWS;
	iowrite8(val, bus->reg + NPCM_I2CCTL1);
	npcm_i2c_reset(bus);
	if ((npcm_i2c_get_SDA(&bus->adap) == 0) || (npcm_i2c_get_SCL(&bus->adap) == 0)) {
		dev_err(bus->dev, "I2C%d init fail: lines are low\n", bus->num);
		dev_err(bus->dev, "SDA=%d SCL=%d\n", npcm_i2c_get_SDA(&bus->adap),
			npcm_i2c_get_SCL(&bus->adap));
		return -ENXIO;
	}
	npcm_i2c_int_enable(bus, true);
	return 0;
}
