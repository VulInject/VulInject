insert_chunk(active_file   *file, export_object_entry_t *entry, const smb_eo_t *eo_info)
{
	gint       nfreechunks      = g_slist_length(file->free_chunk_list);
	gint       i;
	free_chunk *current_free_chunk;
	free_chunk *new_free_chunk;
	guint64     chunk_offset     = eo_info->smb_file_offset;
	guint64     chunk_length     = eo_info->payload_len;
	guint64     chunk_end_offset = chunk_offset + chunk_length-1;
	guint64     calculated_size  = chunk_offset + chunk_length;
	gpointer    dest_memory_addr;
	if ((file->data_gathered == 0) && (nfreechunks == 0)) {
		new_free_chunk = g_new(free_chunk, 1);
		new_free_chunk->start_offset = 0;
		new_free_chunk->end_offset = MAX(file->file_length, chunk_end_offset+1) - 1;
		file->free_chunk_list = NULL;
		nfreechunks += 1;
	} else {
		if (chunk_end_offset > file->file_length-1) {
			new_free_chunk = g_new(free_chunk, 1);
			new_free_chunk->start_offset = file->file_length;
			new_free_chunk->end_offset = chunk_end_offset;
			file->free_chunk_list = g_slist_append(file->free_chunk_list, new_free_chunk);
			nfreechunks += 1;
		}
	}
	file->file_length = MAX(file->file_length, chunk_end_offset+1);
	for (i=0; i<nfreechunks; i++) {
		current_free_chunk = (free_chunk *)g_slist_nth_data(file->free_chunk_list, i);
		if (chunk_end_offset<current_free_chunk->start_offset) {
			continue;
		}
		if (chunk_offset<=current_free_chunk->start_offset && chunk_end_offset>=current_free_chunk->start_offset && chunk_end_offset<current_free_chunk->end_offset) {
			file->data_gathered += chunk_end_offset-current_free_chunk->start_offset+1;
			current_free_chunk->start_offset=chunk_end_offset+1;
			continue;
		}
		if (chunk_offset<=current_free_chunk->start_offset && chunk_end_offset>=current_free_chunk->end_offset) {
			file->data_gathered += current_free_chunk->end_offset-current_free_chunk->start_offset+1;
			file->free_chunk_list = g_slist_remove(file->free_chunk_list, current_free_chunk);
			g_free(current_free_chunk);
			nfreechunks -= 1;
			if (nfreechunks == 0) { 
				g_slist_free(file->free_chunk_list);
				file->free_chunk_list = NULL;
				break;
			}
			i--;
			continue;
		}
		if (chunk_offset>current_free_chunk->start_offset && chunk_end_offset<current_free_chunk->end_offset) {
			new_free_chunk = g_new(free_chunk, 1);
			new_free_chunk->start_offset = chunk_end_offset + 1;
			new_free_chunk->end_offset = current_free_chunk->end_offset;
			current_free_chunk->end_offset = chunk_offset-1;
			file->free_chunk_list = g_slist_insert(file->free_chunk_list, new_free_chunk, i + 1);
			file->data_gathered += chunk_length;
			continue;
		}
		if (chunk_offset>current_free_chunk->start_offset && chunk_offset<=current_free_chunk->end_offset && chunk_end_offset>=current_free_chunk->end_offset) {
			file->data_gathered += current_free_chunk->end_offset-chunk_offset+1;
			current_free_chunk->end_offset = chunk_offset-1;
			continue;
		}
		if (chunk_offset>current_free_chunk->end_offset) {
			continue;
		}
	}
	if (!entry->payload_data) {
		if (calculated_size > G_MAXUINT32) {
			entry->payload_data = NULL;
		} else {
			entry->payload_data = (guint8 *)g_try_malloc((gsize)calculated_size);
			entry->payload_len  = (size_t)calculated_size;
		}
		if (!entry->payload_data) {
			file->is_out_of_memory = TRUE;
		}
	} else {
		if (calculated_size > (guint64) entry->payload_len &&
			!file->is_out_of_memory) {
			if (calculated_size > G_MAXUINT32) {
				dest_memory_addr = NULL;
			} else {
				dest_memory_addr = g_try_realloc(
					entry->payload_data,
					(gsize)calculated_size);
			}
			if (!dest_memory_addr) {
				file->is_out_of_memory = TRUE;
				g_free(entry->payload_data);
				entry->payload_data = NULL;
				entry->payload_len = 0;
			} else {
				entry->payload_data = (guint8 *)dest_memory_addr;
				entry->payload_len = (size_t)calculated_size;
			}
		}
	}
	if (!file->is_out_of_memory) {
		dest_memory_addr = entry->payload_data + chunk_offset;
		memmove(dest_memory_addr, eo_info->payload_data, eo_info->payload_len);
	}
}
