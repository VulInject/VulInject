static void jpeg_put_comments(AVCodecContext *avctx, PutBitContext *p,
                              const AVFrame *frame)
{
    const AVFrameSideData *sd = NULL;
    int size;
    uint8_t *ptr;
    if (avctx->sample_aspect_ratio.num > 0 && avctx->sample_aspect_ratio.den > 0) {
        AVRational sar = avctx->sample_aspect_ratio;
        if (sar.num > 65535 || sar.den > 65535) {
            if (!av_reduce(&sar.num, &sar.den, avctx->sample_aspect_ratio.num, avctx->sample_aspect_ratio.den, 65535))
                av_log(avctx, AV_LOG_WARNING,
                    "Cannot store exact aspect ratio %d:%d\n",
                    avctx->sample_aspect_ratio.num,
                    avctx->sample_aspect_ratio.den);
        }
        /* JFIF header */
        put_marker(p, APP0);
        put_bits(p, 16, 16);
        ff_put_string(p, "JFIF", 1); /* this puts the trailing zero-byte too */
        /* The most significant byte is used for major revisions, the least
         * significant byte for minor revisions. Version 1.02 is the current
         * released revision. */
        put_bits(p, 16, 0x0102);
        put_bits(p,  8, 0);              /* units type: 0 - aspect ratio */
        put_bits(p, 16, sar.num);
        put_bits(p, 16, sar.den);
        put_bits(p, 8, 0); /* thumbnail width */
        put_bits(p, 8, 0); /* thumbnail height */
    }
    /* ICC profile */
    sd = av_frame_get_side_data(frame, AV_FRAME_DATA_ICC_PROFILE);
    if (sd && sd->size) {
        const int nb_chunks = (sd->size + ICC_CHUNK_SIZE - 1) / ICC_CHUNK_SIZE;
        const uint8_t *data = sd->data;
        size_t remaining = sd->size;
        /* must already be checked by the packat allocation code */
        av_assert0(remaining <= ICC_MAX_CHUNKS * ICC_CHUNK_SIZE);
        for (int i = 0; i < nb_chunks; i++) {
            size = FFMIN(remaining, ICC_CHUNK_SIZE);
            av_assert1(size > 0);
            ptr = put_bits_ptr(p);
            ptr[0] = 0xff; /* chunk marker, not part of ICC_HDR_SIZE */
            ptr[1] = APP2;
            AV_WB16(ptr+2, size + ICC_HDR_SIZE);
            AV_WL32(ptr+4,  MKTAG('I','C','C','_'));
            AV_WL32(ptr+8,  MKTAG('P','R','O','F'));
            AV_WL32(ptr+12, MKTAG('I','L','E','\0'));
            ptr[16] = i+1;
            ptr[17] = nb_chunks;
            memcpy(&ptr[18], data, size);
            skip_put_bytes(p, size + ICC_HDR_SIZE + 2);
            remaining -= size;
            data += size;
        }
        av_assert1(!remaining);
    }
    /* comment */
    if (!(avctx->flags & AV_CODEC_FLAG_BITEXACT)) {
        put_marker(p, COM);
        flush_put_bits(p);
        ptr = put_bits_ptr(p);
        put_bits(p, 16, 0); /* patched later */
        ff_put_string(p, LIBAVCODEC_IDENT, 1);
        size = strlen(LIBAVCODEC_IDENT)+3;
        AV_WB16(ptr, size);
    }
    if (((avctx->pix_fmt == AV_PIX_FMT_YUV420P ||
          avctx->pix_fmt == AV_PIX_FMT_YUV422P ||
          avctx->pix_fmt == AV_PIX_FMT_YUV444P) && avctx->color_range != AVCOL_RANGE_JPEG)
        || avctx->color_range == AVCOL_RANGE_MPEG) {
        put_marker(p, COM);
        flush_put_bits(p);
        ptr = put_bits_ptr(p);
        put_bits(p, 16, 0); /* patched later */
        ff_put_string(p, "CS=ITU601", 1);
        size = strlen("CS=ITU601")+3;
        AV_WB16(ptr, size);
    }
}
