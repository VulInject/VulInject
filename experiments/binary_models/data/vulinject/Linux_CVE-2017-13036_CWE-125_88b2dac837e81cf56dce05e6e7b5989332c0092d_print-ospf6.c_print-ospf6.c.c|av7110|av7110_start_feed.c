static int av7110_start_feed(struct dvb_demux_feed *feed)
{
	struct dvb_demux *demux = feed->demux;
	struct av7110 *av7110 = demux->priv;
	int ret = 0;
	dprintk(4, "%p\n", av7110);
	if (!demux->dmx.frontend)
		return -EINVAL;
	if (!av7110->full_ts && feed->pid > 0x1fff)
		return -EINVAL;
	if (feed->type == DMX_TYPE_TS) {
		if ((feed->ts_type & TS_DECODER) &&
		    (feed->pes_type <= DMX_PES_PCR)) {
			switch (demux->dmx.frontend->source) {
			case DMX_MEMORY_FE:
				if (feed->ts_type & TS_DECODER)
				       if (feed->pes_type < 2 &&
					   !(demux->pids[0] & 0x8000) &&
					   !(demux->pids[1] & 0x8000)) {
					       dvb_ringbuffer_flush_spinlock_wakeup(&av7110->aout);
					       ret = av7110_av_start_play(av7110,RP_AV);
					       if (!ret)
						       demux->playing = 1;
					}
				break;
			default:
				ret = dvb_feed_start_pid(feed);
				break;
			}
		} else if ((feed->ts_type & TS_PACKET) &&
			   (demux->dmx.frontend->source != DMX_MEMORY_FE)) {
			ret = StartHWFilter(feed->filter);
		}
	}
	if (av7110->full_ts) {
		budget_start_feed(feed);
		return ret;
	}
	if (feed->type == DMX_TYPE_SEC) {
		int i;
		for (i = 0; i < demux->filternum; i++) {
			if (demux->filter[i].state != DMX_STATE_READY)
				continue;
			if (demux->filter[i].type != DMX_TYPE_SEC)
				continue;
			if (demux->filter[i].filter.parent != &feed->feed.sec)
				continue;
			demux->filter[i].state = DMX_STATE_GO;
			if (demux->dmx.frontend->source != DMX_MEMORY_FE) {
				ret = StartHWFilter(&demux->filter[i]);
				if (ret)
					break;
			}
		}
	}
	return ret;
}
