int sanity_tests_sd(void)
{
	int mem_size, vec_size, ret, ret2, ret3, i, num_pages = 1000, total_pages = 0;
	int total_writes, total_reads, reads, count;
	struct page_region *vec, *vec2;
	char *mem, *m[2];
	int walk_end;
	vec_size = num_pages/2;
	mem_size = num_pages * page_size;
	vec = malloc(sizeof(struct page_region) * vec_size);
	if (!vec)
		ksft_exit_fail_msg("error nomem\n");
	vec2 = malloc(sizeof(struct page_region) * vec_size);
	if (!vec2)
		ksft_exit_fail_msg("error nomem\n");
	mem = mmap(NULL, mem_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
	if (mem == MAP_FAILED)
		ksft_exit_fail_msg("error nomem\n");
	wp_addr_range(mem, mem_size);
	ksft_test_result(pagemap_ioctl(mem, 0, vec, vec_size, 0,
				       0, PAGEMAP_BITS_ALL, 0, 0, PAGEMAP_BITS_ALL) == 0,
			 "%s Zero range size is valid\n", __func__);
	ksft_test_result(pagemap_ioctl(mem, mem_size, NULL, vec_size, 0,
				       0, PAGEMAP_BITS_ALL, 0, 0, PAGEMAP_BITS_ALL) < 0,
			 "%s output buffer must be specified with size\n", __func__);
	ksft_test_result(pagemap_ioctl(mem, mem_size, vec, 0, 0,
				       0, PAGEMAP_BITS_ALL, 0, 0, PAGEMAP_BITS_ALL) == 0,
			 "%s output buffer can be 0\n", __func__);
	ksft_test_result(pagemap_ioctl(mem, mem_size, 0, 0, 0,
				       0, PAGEMAP_BITS_ALL, 0, 0, PAGEMAP_BITS_ALL) == 0,
			 "%s output buffer can be 0\n", __func__);
	ksft_test_result(pagemap_ioctl(mem, mem_size, vec, vec_size, -1,
				       0, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN) < 0,
			 "%s wrong flag specified\n", __func__);
	ksft_test_result(pagemap_ioctl(mem, mem_size, vec, vec_size,
				       PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC | 0xFF,
				       0, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN) < 0,
			 "%s flag has extra bits specified\n", __func__);
	ksft_test_result(pagemap_ioctl(mem, mem_size, vec, vec_size, 0,
				       0, 0, 0, 0, PAGE_IS_WRITTEN) >= 0,
			 "%s no selection mask is specified\n", __func__);
	ksft_test_result(pagemap_ioctl(mem, mem_size, vec, vec_size, 0,
				       0, PAGE_IS_WRITTEN, PAGE_IS_WRITTEN, 0, 0) == 0,
			 "%s no return mask is specified\n", __func__);
	ksft_test_result(pagemap_ioctl(mem, mem_size, vec, vec_size, 0,
				       0, PAGE_IS_WRITTEN, 0, 0, 0x1000) < 0,
			 "%s wrong return mask specified\n", __func__);
	ksft_test_result(pagemap_ioctl(mem, mem_size, vec, vec_size,
				       PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
				       0, 0xFFF, PAGE_IS_WRITTEN, 0, PAGE_IS_WRITTEN) < 0,
			 "%s mixture of correct and wrong flag\n", __func__);
	ksft_test_result(pagemap_ioctl(mem, mem_size, vec, vec_size,
				       PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
				       0, 0, 0, PAGEMAP_BITS_ALL, PAGE_IS_WRITTEN) >= 0,
			 "%s PAGEMAP_BITS_ALL can be specified with PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC\n",
			 __func__);
	ret = pagemap_ioctl(mem, mem_size, vec, vec_size,
			    PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC, 0,
			    PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
	ksft_test_result(ret >= 0, "%s Clear area with larger vec size\n", __func__);
	for (i = 0; i < mem_size; i += 2 * page_size)
		mem[i]++;
	ret = pagemap_ioctl(mem, mem_size, vec, vec_size, 0, 0, PAGE_IS_WRITTEN, 0,
			    0, PAGE_IS_WRITTEN);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == mem_size/(page_size * 2),
			 "%s Repeated pattern of written and non-written pages\n", __func__);
	ret = pagemap_ioctl(mem, mem_size, vec, vec_size,
			    PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
			    num_pages/2 - 2, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ret2 = pagemap_ioctl(mem, mem_size, vec, 2, 0, 0, PAGE_IS_WRITTEN, 0, 0,
			     PAGE_IS_WRITTEN);
	if (ret2 < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret2, errno, strerror(errno));
	ret3 = pagemap_ioctl(mem, mem_size, vec, vec_size,
			     PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
			     0, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
	if (ret3 < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret3, errno, strerror(errno));
	ksft_test_result((ret + ret3) == num_pages/2 && ret2 == 2,
			 "%s Repeated pattern of written and non-written pages in parts %d %d %d\n",
			 __func__, ret, ret3, ret2);
	for (i = 0; i < mem_size; i += 2 * page_size)
		mem[i]++;
	mem[(mem_size/page_size - 1) * page_size]++;
	ret = pagemap_ioctl(mem, mem_size, vec, vec_size,
			    PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
			    num_pages/2, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ret2 = pagemap_ioctl(mem, mem_size, vec, vec_size,
			     PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
			     0, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
	if (ret2 < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret2, errno, strerror(errno));
	ksft_test_result(ret == num_pages/2 && ret2 == 1,
			 "%s Repeated pattern of written and non-written pages max_pages\n",
			 __func__);
	vec_size = mem_size/page_size;
	memset(mem, -1, mem_size);
	ret = pagemap_ioctl(mem + page_size, 2 * page_size, vec, 1,
			    PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
			    2, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ret2 = pagemap_ioctl(mem, mem_size, vec2, vec_size, 0, 0,
			      PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
	if (ret2 < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret2, errno, strerror(errno));
	ksft_test_result(ret == 1 && LEN(vec[0]) == 2 &&
			 vec[0].start == (uintptr_t)(mem + page_size) &&
			 ret2 == 2 && LEN(vec2[0]) == 1 && vec2[0].start == (uintptr_t)mem &&
			 LEN(vec2[1]) == vec_size - 3 &&
			 vec2[1].start == (uintptr_t)(mem + 3 * page_size),
			 "%s only get 2 written pages and clear them as well\n", __func__);
	wp_free(mem, mem_size);
	munmap(mem, mem_size);
	m[0] = mmap(NULL, mem_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
	if (m[0] == MAP_FAILED)
		ksft_exit_fail_msg("error nomem\n");
	m[1] = mmap(NULL, mem_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
	if (m[1] == MAP_FAILED)
		ksft_exit_fail_msg("error nomem\n");
	wp_init(m[0], mem_size);
	wp_init(m[1], mem_size);
	wp_addr_range(m[0], mem_size);
	wp_addr_range(m[1], mem_size);
	memset(m[0], 'a', mem_size);
	memset(m[1], 'b', mem_size);
	wp_addr_range(m[0], mem_size);
	ret = pagemap_ioctl(m[1], mem_size, vec, 1, 0, 0, PAGE_IS_WRITTEN, 0, 0,
			    PAGE_IS_WRITTEN);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == 1 && LEN(vec[0]) == mem_size/page_size,
			 "%s Two regions\n", __func__);
	wp_free(m[0], mem_size);
	wp_free(m[1], mem_size);
	munmap(m[0], mem_size);
	munmap(m[1], mem_size);
	free(vec);
	free(vec2);
	mem_size = 1050 * page_size;
	vec_size = mem_size/(page_size*2);
	vec = malloc(sizeof(struct page_region) * vec_size);
	if (!vec)
		ksft_exit_fail_msg("error nomem\n");
	mem = mmap(NULL, mem_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
	if (mem == MAP_FAILED)
		ksft_exit_fail_msg("error nomem\n");
	wp_init(mem, mem_size);
	wp_addr_range(mem, mem_size);
	ret = pagemap_ioctl(mem, mem_size, vec, vec_size,
			    PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC, 0,
			    PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	for (i = 0; i < mem_size/page_size; i += 2)
		mem[i * page_size]++;
	ret = pagemap_ioctl(mem, mem_size, vec, vec_size,
			    PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
			    mem_size/(page_size*5), PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	total_pages += ret;
	ret = pagemap_ioctl(mem, mem_size, vec, vec_size,
			    PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
			    mem_size/(page_size*5), PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	total_pages += ret;
	ret = pagemap_ioctl(mem, mem_size, vec, vec_size,
			    PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
			    mem_size/(page_size*5), PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	total_pages += ret;
	ksft_test_result(total_pages == mem_size/(page_size*2), "%s Smaller max_pages\n", __func__);
	free(vec);
	wp_free(mem, mem_size);
	munmap(mem, mem_size);
	total_pages = 0;
	mem_size = 10000 * page_size;
	vec_size = 50;
	vec = malloc(sizeof(struct page_region) * vec_size);
	if (!vec)
		ksft_exit_fail_msg("error nomem\n");
	mem = mmap(NULL, mem_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
	if (mem == MAP_FAILED)
		ksft_exit_fail_msg("error nomem\n");
	wp_init(mem, mem_size);
	wp_addr_range(mem, mem_size);
	for (count = 0; count < TEST_ITERATIONS; count++) {
		total_writes = total_reads = 0;
		walk_end = (int)mem;
		for (i = 0; i < mem_size; i += page_size) {
			if (rand() % 2) {
				mem[i]++;
				total_writes++;
			}
		}
		while (total_reads < total_writes) {
			ret = pagemap_ioc((void *)walk_end, mem_size-(walk_end - (int)mem), vec,
					  vec_size, PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
					  0, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
			if (ret < 0)
				ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
			if (ret > vec_size)
				break;
			reads = get_reads(vec, ret);
			total_reads += reads;
		}
		if (total_reads != total_writes)
			break;
	}
	ksft_test_result(count == TEST_ITERATIONS, "Smaller vec\n");
	free(vec);
	wp_free(mem, mem_size);
	munmap(mem, mem_size);
	vec_size = 1000;
	mem_size = vec_size * page_size;
	vec = malloc(sizeof(struct page_region) * vec_size);
	if (!vec)
		ksft_exit_fail_msg("error nomem\n");
	mem = mmap(NULL, mem_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
	if (mem == MAP_FAILED)
		ksft_exit_fail_msg("error nomem\n");
	wp_init(mem, mem_size);
	wp_addr_range(mem, mem_size);
	memset(mem, 0, mem_size);
	ret = pagemap_ioc(mem, 0, vec, vec_size, 0,
			  0, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == 0 && walk_end == (int)mem,
			 "Walk_end: Same start and end address\n");
	ret = pagemap_ioc(mem, 0, vec, vec_size, PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
			  0, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == 0 && walk_end == (int)mem,
			 "Walk_end: Same start and end with WP\n");
	ret = pagemap_ioc(mem, 0, vec, 0, PM_SCAN_WP_MATCHING | PM_SCAN_CHECK_WPASYNC,
			  0, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == 0 && walk_end == (int)mem,
			 "Walk_end: Same start and end with 0 output buffer\n");
	ret = pagemap_ioc(mem, mem_size, vec, vec_size, 0,
			  0, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == 1 && walk_end == (int)(mem + mem_size),
			 "Walk_end: Big vec\n");
	ret = pagemap_ioc(mem, mem_size, vec, 1, 0,
			  0, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == 1 && walk_end == (int)(mem + mem_size),
			 "Walk_end: vec of minimum length\n");
	ret = pagemap_ioc(mem, mem_size, vec, 1, 0,
			  vec_size, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == 1 && walk_end == (int)(mem + mem_size),
			 "Walk_end: Max pages specified\n");
	ret = pagemap_ioc(mem, mem_size, vec, vec_size, 0,
			  vec_size/2, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == 1 && walk_end == (int)(mem + mem_size/2),
			 "Walk_end: Half max pages\n");
	ret = pagemap_ioc(mem, mem_size, vec, vec_size, 0,
			  1, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == 1 && walk_end == (int)(mem + page_size),
			 "Walk_end: 1 max page\n");
	ret = pagemap_ioc(mem, mem_size, vec, vec_size, 0,
			  -1, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == 1 && walk_end == (int)(mem + mem_size),
			 "Walk_end: max pages\n");
	wp_addr_range(mem, mem_size);
	for (i = 0; i < mem_size; i += 2 * page_size)
		mem[i]++;
	ret = pagemap_ioc(mem, mem_size, vec, vec_size, 0,
			  0, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == vec_size/2 && walk_end == (int)(mem + mem_size),
			 "Walk_end sparse: Big vec\n");
	ret = pagemap_ioc(mem, mem_size, vec, 1, 0,
			  0, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == 1 && walk_end == (int)(mem + page_size * 2),
			 "Walk_end sparse: vec of minimum length\n");
	ret = pagemap_ioc(mem, mem_size, vec, 1, 0,
			  vec_size, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == 1 && walk_end == (int)(mem + page_size * 2),
			 "Walk_end sparse: Max pages specified\n");
	ret = pagemap_ioc(mem, mem_size, vec, vec_size/2, 0,
			  vec_size, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == vec_size/2 && walk_end == (int)(mem + mem_size),
			 "Walk_end sparse: Max pages specified\n");
	ret = pagemap_ioc(mem, mem_size, vec, vec_size, 0,
			  vec_size, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == vec_size/2 && walk_end == (int)(mem + mem_size),
			 "Walk_end sparse: Max pages specified\n");
	ret = pagemap_ioc(mem, mem_size, vec, vec_size, 0,
			  vec_size/2, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == vec_size/2 && walk_end == (int)(mem + mem_size),
			 "Walk_endsparse : Half max pages\n");
	ret = pagemap_ioc(mem, mem_size, vec, vec_size, 0,
			  1, PAGE_IS_WRITTEN, 0, 0, PAGE_IS_WRITTEN, &walk_end);
	if (ret < 0)
		ksft_exit_fail_msg("error %d %d %s\n", ret, errno, strerror(errno));
	ksft_test_result(ret == 1 && walk_end == (int)(mem + page_size * 2),
			 "Walk_end: 1 max page\n");
	free(vec);
	wp_free(mem, mem_size);
	munmap(mem, mem_size);
	return 0;
}
