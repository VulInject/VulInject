fore200e_rx_irq(struct fore200e* fore200e)
{
    struct host_rxq*        rxq = &fore200e->host_rxq;
    struct host_rxq_entry*  entry;
    struct atm_vcc*         vcc;
    struct fore200e_vc_map* vc_map;
    for (;;) {
	entry = &rxq->host_entry[ rxq->head ];
	if ((*entry->status & STATUS_COMPLETE) == 0)
	    break;
	vc_map = FORE200E_VC_MAP(fore200e, entry->rpd->atm_header.vpi, entry->rpd->atm_header.vci);
	if ((vc_map->vcc == NULL) ||
	    (test_bit(ATM_VF_READY, &vc_map->vcc->flags) == 0)) {
	    DPRINTK(1, "no ready VC found for PDU received on %d.%d.%d\n",
		    fore200e->atm_dev->number,
		    entry->rpd->atm_header.vpi, entry->rpd->atm_header.vci);
	}
	else {
	    vcc = vc_map->vcc;
	    if ((*entry->status & STATUS_ERROR) == 0) {
		fore200e_push_rpd(fore200e, vcc, entry->rpd);
	    }
	    else {
		DPRINTK(2, "damaged PDU on %d.%d.%d\n",
			fore200e->atm_dev->number,
			entry->rpd->atm_header.vpi, entry->rpd->atm_header.vci);
		atomic_inc(&vcc->stats->rx_err);
	    }
	}
	FORE200E_NEXT_ENTRY(rxq->head, QUEUE_SIZE_RX);
	fore200e_collect_rpd(fore200e, entry->rpd);
	fore200e->bus->write(entry->rpd_dma, &entry->cp_entry->rpd_haddr);
	*entry->status = STATUS_FREE;
	fore200e_supply(fore200e);
    }
}
