wtap_open_offline(const char *filename, unsigned int type, int *err, char **err_info,
		  bool do_random)
{
	int	fd;
	ws_statb64 statb;
	bool ispipe = false;
	wtap	*wth;
	unsigned int	i;
	bool use_stdin = false;
	char *extension;
	wtap_block_t shb;
	*err = 0;
	*err_info = NULL;
	if (strcmp(filename, "-") == 0)
		use_stdin = true;
	if (use_stdin) {
		if (ws_fstat64(0, &statb) < 0) {
			*err = errno;
			return NULL;
		}
	} else {
		if (ws_stat64(filename, &statb) < 0) {
			*err = errno;
			return NULL;
		}
	}
	if (S_ISFIFO(statb.st_mode)) {
		if (do_random) {
			*err = WTAP_ERR_RANDOM_OPEN_PIPE;
			return NULL;
		}
		ispipe = true;
	} else if (S_ISDIR(statb.st_mode)) {
		*err = EISDIR;
		return NULL;
	} else if (! S_ISREG(statb.st_mode)) {
		*err = WTAP_ERR_NOT_REGULAR_FILE;
		return NULL;
	}
	if (use_stdin && do_random) {
		*err = WTAP_ERR_RANDOM_OPEN_STDIN;
		return NULL;
	}
	errno = ENOMEM;
	wth = g_new0(wtap, 1);
	errno = WTAP_ERR_CANT_OPEN;
	if (use_stdin) {
		fd = ws_dup(0);
		if (fd < 0) {
			*err = errno;
			return NULL;
		}
#ifdef _WIN32
		if (_setmode(fd, O_BINARY) == -1) {
			*err = errno;
			g_free(wth);
			return NULL;
		}
#endif
		if (!(wth->fh = file_fdopen(fd))) {
			*err = errno;
			ws_close(fd);
			g_free(wth);
			return NULL;
		}
	} else {
		if (!(wth->fh = file_open(filename))) {
			*err = errno;
			g_free(wth);
			return NULL;
		}
	}
	if (do_random) {
		if (!(wth->random_fh = file_open(filename))) {
			*err = errno;
			file_close(wth->fh);
			g_free(wth);
			return NULL;
		}
	} else
		wth->random_fh = NULL;
	wth->ispipe = ispipe;
	wth->file_encap = WTAP_ENCAP_UNKNOWN;
	wth->subtype_sequential_close = NULL;
	wth->subtype_close = NULL;
	wth->file_tsprec = WTAP_TSPREC_USEC;
	wth->pathname = g_strdup(filename);
	wth->priv = NULL;
	wth->wslua_data = NULL;
	wth->shb_hdrs = g_array_new(false, false, sizeof(wtap_block_t));
	shb = wtap_block_create(WTAP_BLOCK_SECTION);
	if (shb)
		g_array_append_val(wth->shb_hdrs, shb);
	wth->interface_data = g_array_new(false, false, sizeof(wtap_block_t));
	wth->next_interface_data = 0;
	wth->shb_iface_to_global = g_array_new(false, false, sizeof(unsigned));
	g_array_append_val(wth->shb_iface_to_global, wth->interface_data->len);
	if (wth->random_fh) {
		wth->fast_seek = g_ptr_array_new();
		file_set_random_access(wth->fh, false, wth->fast_seek);
		file_set_random_access(wth->random_fh, true, wth->fast_seek);
	}
	if (type != WTAP_TYPE_AUTO && type <= open_info_arr->len) {
		int result;
		if (file_seek(wth->fh, 0, SEEK_SET, err) == -1) {
			wtap_close(wth);
			return NULL;
		}
		wth->wslua_data = open_routines[type - 1].wslua_data;
		result = (*open_routines[type - 1].open_routine)(wth, err, err_info);
		switch (result) {
			case WTAP_OPEN_ERROR:
				wtap_close(wth);
				return NULL;
			case WTAP_OPEN_NOT_MINE:
				goto fail;
			case WTAP_OPEN_MINE:
				goto success;
		}
	}
	for (i = 0; i < heuristic_open_routine_idx; i++) {
		if (file_seek(wth->fh, 0, SEEK_SET, err) == -1) {
			wtap_close(wth);
			return NULL;
		}
		wth->wslua_data = open_routines[i].wslua_data;
		switch ((*open_routines[i].open_routine)(wth, err, err_info)) {
		case WTAP_OPEN_ERROR:
			wtap_close(wth);
			return NULL;
		case WTAP_OPEN_NOT_MINE:
			break;
		case WTAP_OPEN_MINE:
			goto success;
		}
	}
	extension = get_file_extension(filename);
	if (extension != NULL) {
		for (i = heuristic_open_routine_idx; i < open_info_arr->len; i++) {
			if (heuristic_uses_extension(i, extension)) {
				if (file_seek(wth->fh, 0, SEEK_SET, err) == -1) {
					g_free(extension);
					wtap_close(wth);
					return NULL;
				}
				wth->wslua_data = open_routines[i].wslua_data;
				switch ((*open_routines[i].open_routine)(wth,
				    err, err_info)) {
				case WTAP_OPEN_ERROR:
					g_free(extension);
					wtap_close(wth);
					return NULL;
				case WTAP_OPEN_NOT_MINE:
					break;
				case WTAP_OPEN_MINE:
					g_free(extension);
					goto success;
				}
			}
		}
		for (i = heuristic_open_routine_idx; i < open_info_arr->len; i++) {
			if (open_routines[i].extensions == NULL) {
				if (file_seek(wth->fh, 0, SEEK_SET, err) == -1) {
					g_free(extension);
					wtap_close(wth);
					return NULL;
				}
				wth->wslua_data = open_routines[i].wslua_data;
				switch ((*open_routines[i].open_routine)(wth,
				    err, err_info)) {
				case WTAP_OPEN_ERROR:
					g_free(extension);
					wtap_close(wth);
					return NULL;
				case WTAP_OPEN_NOT_MINE:
					break;
				case WTAP_OPEN_MINE:
					g_free(extension);
					goto success;
				}
			}
		}
		for (i = heuristic_open_routine_idx; i < open_info_arr->len; i++) {
			if (open_routines[i].extensions != NULL &&
			    !heuristic_uses_extension(i, extension)) {
				if (file_seek(wth->fh, 0, SEEK_SET, err) == -1) {
					g_free(extension);
					wtap_close(wth);
					return NULL;
				}
				wth->wslua_data = open_routines[i].wslua_data;
				switch ((*open_routines[i].open_routine)(wth,
				    err, err_info)) {
				case WTAP_OPEN_ERROR:
					g_free(extension);
					wtap_close(wth);
					return NULL;
				case WTAP_OPEN_NOT_MINE:
					break;
				case WTAP_OPEN_MINE:
					g_free(extension);
					goto success;
				}
			}
		}
		g_free(extension);
	} else {
		for (i = heuristic_open_routine_idx; i < open_info_arr->len; i++) {
			if (file_seek(wth->fh, 0, SEEK_SET, err) == -1) {
				wtap_close(wth);
				return NULL;
			}
			wth->wslua_data = open_routines[i].wslua_data;
			switch ((*open_routines[i].open_routine)(wth, err, err_info)) {
			case WTAP_OPEN_ERROR:
				wtap_close(wth);
				return NULL;
			case WTAP_OPEN_NOT_MINE:
				break;
			case WTAP_OPEN_MINE:
				goto success;
			}
		}
	}
fail:
	wtap_close(wth);
	*err = WTAP_ERR_FILE_UNKNOWN_FORMAT;
	return NULL;
success:
	return wth;
}
