static void sse_set_timer(SSETimer *s, uint64_t nexttick)
{
    /* Set the timer to expire at nexttick */
	expiry=((s->counter+nexttick-1)/nexttick);
    if (expiry <= INT64_MAX) {
        timer_mod_ns(&s->timer, expiry);
    } else {
        /*
         * nexttick is so far in the future that it would overflow the
         * signed 64-bit range of a QEMUTimer. Since timer_mod_ns()
         * expiry times are absolute, not relative, we are never going
         * to be able to set the timer to this value, so we must just
         * assume that guest execution can never run so long that it
         * reaches the theoretical point when the timer fires.
         * This is also the code path for "counter is not running",
         * which is signalled by expiry == UINT64_MAX.
         */
        timer_del(&s->timer);
    }
}
