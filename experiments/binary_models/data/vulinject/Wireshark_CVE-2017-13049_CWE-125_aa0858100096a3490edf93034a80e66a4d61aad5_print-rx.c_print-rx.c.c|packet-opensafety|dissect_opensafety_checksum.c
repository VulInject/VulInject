dissect_opensafety_checksum(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *opensafety_tree,
                            opensafety_packet_info *packet )
{
    guint16     frame1_crc, frame2_crc;
    guint16     calc1_crc, calc2_crc;
    guint       dataLength, frame2Length;
    guint8     *bytesf2, *bytesf1, ctr = 0, crcType = OPENSAFETY_CHECKSUM_CRC8;
    proto_item *item;
    proto_tree *checksum_tree;
    gint        start;
    gint        length;
    gboolean    isSlim = FALSE;
    gboolean    isSNMT = FALSE;
    gboolean    isSPDO = FALSE;
    GByteArray *scmUDID = NULL;
    dataLength = OSS_FRAME_LENGTH_T(message_tvb, packet->frame.subframe1);
    start = OSS_FRAME_POS_DATA + dataLength + packet->frame.subframe1;
    if (OSS_FRAME_LENGTH_T(message_tvb, packet->frame.subframe1) > OSS_PAYLOAD_MAXSIZE_FOR_CRC8)
        frame1_crc = tvb_get_letohs(message_tvb, start);
    else
        frame1_crc = tvb_get_guint8(message_tvb, start);
    if ( packet->msg_type == OPENSAFETY_SLIM_SSDO_MESSAGE_TYPE )
        isSlim = TRUE;
    if ( packet->msg_type == OPENSAFETY_SNMT_MESSAGE_TYPE )
        isSNMT = TRUE;
    if ( packet->msg_type == OPENSAFETY_SPDO_MESSAGE_TYPE )
        isSPDO = TRUE;
    frame2Length = (isSlim ? 0 : dataLength) + 5;
    length = (dataLength > OSS_PAYLOAD_MAXSIZE_FOR_CRC8 ? OPENSAFETY_CHECKSUM_CRC16 : OPENSAFETY_CHECKSUM_CRC8);
    item = proto_tree_add_uint_format(opensafety_tree, hf_oss_crc, message_tvb, start, length, frame1_crc,
                                      "CRC for subframe #1: 0x%04X", frame1_crc);
    checksum_tree = proto_item_add_subtree(item, ett_opensafety_checksum);
    bytesf1 = (guint8*)tvb_memdup(pinfo->pool, message_tvb, packet->frame.subframe1, dataLength + 4);
    crcType = packet->crc.type;
    calc1_crc = packet->crc.frame1;
    if ( ! isSlim && crcType == OPENSAFETY_CHECKSUM_CRC16SLIM )
        expert_add_info(pinfo, item, &ei_crc_slimssdo_instead_of_spdo );
    item = proto_tree_add_boolean(checksum_tree, hf_oss_crc_valid, message_tvb,
            packet->frame.subframe1, dataLength + 4, (frame1_crc == calc1_crc));
    if ( crcType == OPENSAFETY_CHECKSUM_INVALID || frame1_crc != calc1_crc )
        expert_add_info(pinfo, item, &ei_crc_frame_1_invalid );
    proto_tree_add_uint(checksum_tree, hf_oss_crc_type, message_tvb, start, length, crcType );
    start = packet->frame.subframe2 + (isSlim ? 5 : dataLength + OSS_FRAME_POS_DATA + 1 );
    if (OSS_FRAME_LENGTH_T(message_tvb, packet->frame.subframe1) > OSS_PAYLOAD_MAXSIZE_FOR_CRC8)
        frame2_crc = tvb_get_letohs(message_tvb, start);
    else
        frame2_crc = tvb_get_guint8(message_tvb, start);
    calc2_crc = 0xFFFF;
    if ( isSPDO && packet->payload.spdo->flags.enabled40bit == TRUE )
        packet->scm_udid_valid = FALSE;
    if ( isSNMT || packet->scm_udid_valid )
    {
        bytesf2 = (guint8*)tvb_memdup(pinfo->pool, message_tvb, packet->frame.subframe2, frame2Length + length);
        if ( isSlim == TRUE )
            dataLength = 0;
        scmUDID = g_byte_array_new();
        packet->crc.valid2 = FALSE;
        if ( isSNMT || ( hex_str_to_bytes((local_scm_udid != NULL ? local_scm_udid : global_scm_udid), scmUDID, TRUE) && scmUDID->len == 6 ) )
        {
            if ( !isSNMT )
            {
                for ( ctr = 0; ctr < 6; ctr++ )
                    bytesf2[ctr] = bytesf2[ctr] ^ (guint8)(scmUDID->data[ctr]);
                if ( isSPDO )
                {
                    if ( packet->msg_id == OPENSAFETY_MSG_SPDO_DATA_ONLY )
                    {
                        if ( packet->payload.spdo->flags.enabled40bit == TRUE )
                        {
                            bytesf2[0] = bytesf2[0] ^ (bytesf2[0] ^ OPENSAFETY_DEFAULT_DOMAIN ^ bytesf1[0]);
                            bytesf2[1] = bytesf2[1] ^ (bytesf2[1] ^ bytesf1[1]);
                            bytesf2[3] = 0;
                        }
                    }
                }
                if ( isSlim || packet->frame.length == 11 )
                    frame2_crc ^= ((guint8)scmUDID->data[5]);
                if ( dataLength == 0 )
                {
                    if ( isSlim && length == 2 )
                        frame2_crc = ( bytesf2[6] << 8 ) + bytesf2[5];
                }
            }
            item = proto_tree_add_uint_format(opensafety_tree, hf_oss_crc, message_tvb, start, length, frame2_crc,
                    "CRC for subframe #2: 0x%04X", frame2_crc);
            checksum_tree = proto_item_add_subtree(item, ett_opensafety_checksum);
            if ( OSS_FRAME_LENGTH_T(message_tvb, packet->frame.subframe1) > OSS_PAYLOAD_MAXSIZE_FOR_CRC8 )
            {
                calc2_crc = crc16_0x755B(bytesf2, frame2Length, 0);
                if ( frame2_crc != calc2_crc )
                    calc2_crc = crc16_0x5935(bytesf2, frame2Length, 0);
            }
            else
                calc2_crc = crc8_0x2F(bytesf2, frame2Length, 0);
            item = proto_tree_add_boolean(checksum_tree, hf_oss_crc2_valid, message_tvb,
                    packet->frame.subframe2, frame2Length, (frame2_crc == calc2_crc));
            proto_item_set_generated(item);
            if ( frame2_crc != calc2_crc )
            {
                item = proto_tree_add_uint_format(checksum_tree, hf_oss_crc, message_tvb,
                        packet->frame.subframe2, frame2Length, calc2_crc, "Calculated CRC: 0x%04X", calc2_crc);
                proto_item_set_generated(item);
                expert_add_info(pinfo, item, &ei_crc_frame_2_invalid );
            }
            else
            {
                if ( global_opensafety_debug_verbose && ( isSlim || ( !isSNMT && packet->frame.length == 11 ) ) )
                    expert_add_info(pinfo, item, &ei_crc_frame_2_scm_udid_encoded );
                packet->crc.valid2 = TRUE;
            }
        }
        else
            expert_add_info(pinfo, item, &ei_crc_frame_2_unknown_scm_udid );
        g_byte_array_free(scmUDID, TRUE);
    }
    return (gboolean) (frame1_crc == calc1_crc) &&
            ( ( isSNMT || packet->scm_udid_valid ) == TRUE ? (frame2_crc == calc2_crc) : TRUE);
}
