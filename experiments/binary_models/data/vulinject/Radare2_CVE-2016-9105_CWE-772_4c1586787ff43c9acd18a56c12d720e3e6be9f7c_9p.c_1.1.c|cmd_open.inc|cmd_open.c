static int cmd_open(void *data, const char *input) {
	RCore *core = (RCore*)data;
	int perms = R_PERM_R;
	ut64 baddr = r_config_get_i (core->config, "bin.baddr");
	ut64 addr = 0LL;
	int argc, fd = -1;
	RIODesc *file;
	RIODesc *desc;
	const char *ptr = NULL;
	char **argv = NULL;
	switch (*input) {
	case 'a': 
		switch (input[1]) {
		case '*': 
			{
				RListIter *iter;
				RBinFile *bf = NULL;
				r_list_foreach (core->bin->binfiles, iter, bf) {
					if (bf && bf->bo && bf->bo->info) {
						r_cons_printf ("oa %s %d %s\n", bf->bo->info->arch, bf->bo->info->bits, bf->file);
					}
				}
				return 1;
			}
			break;
		case '?': 
			r_core_cmd_help_match (core, help_msg_o, "oa");
			return 1;
		case ' ': { 
			int i;
			char *ptr = strdup (input+2);
			const char *arch = NULL;
			ut16 bits = 0;
			const char *filename = NULL;
			i = r_str_word_set0 (ptr);
			if (i < 2) {
				R_LOG_ERROR ("Missing argument");
				free (ptr);
				return 0;
			}
			if (i == 3) {
				filename = r_str_word_get0 (ptr, 2);
			}
			bits = r_num_math (core->num, r_str_word_get0 (ptr, 1));
			arch = r_str_word_get0 (ptr, 0);
			r_core_bin_set_arch_bits (core, filename, arch, bits);
			RBinFile *file = NULL;
			if (filename) {
				file = r_bin_file_find_by_name (core->bin, filename);
				if (!file) {
					R_LOG_ERROR ("Cannot find file %s", filename);
				}
			} else if (r_list_length (core->bin->binfiles) == 1) {
				file = (RBinFile *)r_list_first (core->bin->binfiles);
			} else {
				R_LOG_INFO ("More than one file is opened, you must specify the filename");
			}
			if (!file) {
				free (ptr);
				return 0;
			}
			if (file->bo && file->bo->info) {
				free (file->bo->info->arch);
				file->bo->info->arch = strdup (arch);
				file->bo->info->bits = bits;
			}
			free (ptr);
			return 1;
			}
			break;
		default:
			r_core_cmd_help_match (core, help_msg_o, "oa");
			return 0;
		}
		break;
	case 'n': 
		if (input[1] == '?') {
			r_core_cmd_help (core, help_msg_on);
			return 0;
		}
		if (input[1] == 'n') { 
			cmd_onn (core, input);
			return 0;
		}
		if (input[1] == '*') { 
			R_LOG_TODO ("on* is not yet implemented");
			return 0;
		}
		if (input[1] == '+') { 
			perms |= R_PERM_W;
			if (input[2] != ' ') {
				r_core_cmd_help_match (core, help_msg_on, "on+");
				return 0;
			}
			ptr = r_str_trim_head_ro (input + 3);
		} else if (input[1] == ' ') {
			ptr = input + 2;
		} else {
			r_core_cmd_help (core, help_msg_on);
			return 0;
		}
		argv = r_str_argv (ptr, &argc);
		if (!argc) {
			r_core_cmd_help (core, help_msg_on);
			r_str_argv_free (argv);
			return 0;
		}
		ptr = argv[0];
		if (argc == 2) {
			if (r_num_is_valid_input (core->num, argv[1])) {
				addr = r_num_math (core->num, argv[1]);
			} else {
				perms = r_str_rwx (argv[1]);
				if (perms < 0) {
					R_LOG_WARN ("Invalid permissions string");
					perms = 0;
				}
			}
		}
		if (argc == 3) {
			addr = r_num_math (core->num, argv[1]);
			perms = r_str_rwx (argv[2]);
			if (perms < 0) {
				R_LOG_WARN ("Invalid permissions string");
				perms = 0;
			}
		}
		if (!strcmp (ptr, "-")) {
			ptr = "malloc://512";
		}
		if ((desc = r_io_open_at (core->io, ptr, perms, 0644, addr))) {
			fd = desc->fd;
		}
		if (fd == -1) {
			R_LOG_ERROR ("Cannot open file '%s'", ptr);
		}
		r_str_argv_free (argv);
		r_core_return_value (core, fd);
		r_core_block_read (core);
		return 0;
	case 'e': 
		if (input[1] == ' ') {
			const char *arg = r_str_trim_head_ro (input + 1);
			free (r_core_editor (core, arg, NULL));
		} else {
			r_core_cmd_help_contains (core, help_msg_o, "oe");
		}
		return 0;
	case 'f': 
		if (input[1]) {
			ptr = r_str_trim_head_ro (input + 2);
			argv = r_str_argv (ptr, &argc);
			if (argc == 0 || input[1] == '?') {
				r_core_cmd_help_match (core, help_msg_o, "of");
				r_str_argv_free (argv);
				return 0;
			}
			if (argc == 2) {
				perms = r_str_rwx (argv[1]);
				if (perms < 0) {
					R_LOG_WARN ("Invalid permissions string");
					perms = 0;
				}
			}
			fd = r_io_fd_open (core->io, argv[0], perms, 0);
			r_core_return_value (core, fd);
			r_str_argv_free (argv);
		} else {
			r_core_cmd_help_match (core, help_msg_o, "of");
		}
		return 0;
	case 't': 
		r_core_cmdf (core, "touch%s", input + 1);
		return 0;
	case 'p': 
		if (input[1]) {
			switch (input[1]) {
			case 'e': 
				{
					const char *sp = strchr (input, ' ');
					if (sp) {
#if R2__WINDOWS__
						r_sys_cmdf ("start %s", sp + 1);
#else
						if (r_file_exists ("/usr/bin/xdg-open")) {
							r_sys_cmdf ("xdg-open %s", sp + 1);
						} else if (r_file_exists ("/usr/local/bin/xdg-open")) {
							r_sys_cmdf ("xdg-open %s", sp + 1);
						} else if (r_file_exists ("/usr/bin/open")) {
							r_sys_cmdf ("open %s", sp + 1);
						} else {
							eprintf ("Unknown open tool. Cannot find xdg-open\n");
						}
#endif
					} else {
						r_core_cmd_help_match (core, help_msg_o, "open");
					}
				}
				break;
			case 'r': 
			case 'n': 
			case 'p': 
				if (!cmd_op (core, input[1], -1)) {
					R_LOG_ERROR ("Cannot find file");
				}
				break;
			case ' ': {
				int fd = r_num_math (core->num, input + 1);
				if (fd >= 0 || input[1] == '0') {
					cmd_op (core, 0, fd);
				} else {
					R_LOG_ERROR ("Invalid fd number");
				}
				}
				break;
			default:
				r_core_cmd_help (core, help_msg_op);
				break;
			}
		} else {
			if (core->io && core->io->desc) {
				r_cons_printf ("%d\n", core->io->desc->fd);
			}
		}
		return 0;
		break;
	case 'r': 
		ptr = input + 1;
		argv = r_str_argv (ptr, &argc);
		if (argc > 1) {
			const int fd = (int)r_num_math (core->num, argv[0]);
			const ut64 size = r_num_math (core->num, argv[1]);
			r_io_fd_resize (core->io, fd, size);
		}
		r_str_argv_free (argv);
		return 0;
		break;
	case '+': 
		if (input[1] == '?' || (input[1] && input[2] == '?')) {
			r_core_cmd_help_contains (core, help_msg_o, "o+");
			return 0;
		}
		perms |= R_PERM_W;
		if (input[1] == '+') { 
			perms |= R_PERM_CREAT;
			input++;
		}
	case ' ': 
		ptr = input + 1;
		argv = r_str_argv (ptr, &argc);
		if (argc == 0) {
			if (perms & R_PERM_W) {
				r_core_cmd_help_contains (core, help_msg_o, "o+");
			} else {
				r_core_cmd_help_match (core, help_msg_o, "o");
			}
			r_str_argv_free (argv);
			return 0;
		}
		if (argv) {
			if (r_str_startswith (argv[0], "base64:")) {
				char *decoded = (char *)sdb_decode (argv[0] + 7, NULL);
				if (decoded) {
					free (argv[0]);
					argv[0] = decoded;
				}
			} else {
				r_str_path_unescape (argv[0]);
			}
			if (argc == 2) {
				if (r_num_is_valid_input (core->num, argv[1])) {
					addr = r_num_math (core->num, argv[1]);
				} else {
					perms = r_str_rwx (argv[1]);
					if (perms < 0) {
						R_LOG_WARN ("Invalid permissions string");
						perms = 0;
					}
				}
			} else if (argc == 3) {
				addr = r_num_math (core->num, argv[1]);
				perms = r_str_rwx (argv[2]);
				if (perms < 0) {
					R_LOG_WARN ("Invalid permissions string");
					perms = 0;
				}
			}
		}
		{
			const char *argv0 = argv ? argv[0] : ptr;
			if ((file = r_core_file_open (core, argv0, perms, addr))) {
				fd = file->fd;
				r_core_return_value (core, fd);
				if (addr == 0) { 
					addr = UT64_MAX;
				}
				r_core_bin_load (core, argv0, addr);
				if (*input == '+') { 
					RIODesc *desc = r_io_desc_get (core->io, fd);
					if (desc && (desc->perm & R_PERM_W)) {
						RListIter *iter;
						RList *maplist = r_io_map_get_by_fd (core->io, desc->fd);
						if (!maplist) {
							break;
						}
						RIOMap *map;
						r_list_foreach (maplist, iter, map) {
							map->perm |= R_PERM_WX;
						}
						r_list_free (maplist);
					} else {
						R_LOG_ERROR ("%s is not writable", argv0);
					}
				}
			} else {
				if (perms & R_PERM_W) {
				}
				R_LOG_ERROR ("cannot open file %s", argv0);
			}
		}
		r_core_block_read (core);
		r_str_argv_free (argv);
		return 0;
	}
	switch (*input) {
	case '=': 
		if (input[1]) { 
			int n = (int)r_num_math (core->num, input + 1);
			if (n > 0) {
				RIODesc *desc = r_io_desc_get (core->io, n);
				if (desc) {
					core->io->desc = desc;
				}
			}
		} else { 
			fdsz = 0;
			r_id_storage_foreach (core->io->files, init_desc_list_visual_cb, core->print);
			r_id_storage_foreach (core->io->files, desc_list_visual_cb, core->print);
		}
		break;
	case 'q': 
		if (input[1] == 'q') { 
			if (core->io->desc) {
				int fd = core->io->desc->fd;
				r_cons_printf ("%d\n", fd);
			}
		} else if (input[1] == '.') { 
			r_id_storage_foreach (core->io->files, desc_list_quiet2_cb, core->print);
		} else {
			r_id_storage_foreach (core->io->files, desc_list_quiet_cb, core->print);
		}
		break;
	case '\0': 
		r_id_storage_foreach (core->io->files, desc_list_cb, core->print);
		break;
	case '*': 
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_o, "o*");
		} else if (input[1] == '*') {
			r_id_storage_foreach (core->io->files, desc_list_cmds_cb2, core);
		} else {
			r_id_storage_foreach (core->io->files, desc_list_cmds_cb, core);
		}
		break;
	case 'j': 
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_o, "oj");
			break;
		}
		PJ *pj = pj_new ();
		pj_a (pj);
		r_id_storage_foreach (core->io->files, desc_list_json_cb, pj);
		pj_end (pj);
		core->print->cb_printf ("%s\n", pj_string (pj));
		pj_free (pj);
		break;
	case 'L': 
		if (r_sandbox_enable (0)) {
			R_LOG_ERROR ("This command is disabled in sandbox mode");
			return 0;
		}
		if (input[1] == ' ') {
			if (r_lib_open (core->lib, input + 2) == -1) {
				R_LOG_ERROR ("Oops. Cannot open library");
			}
		} else {
			if ('j' == input[1]) {
				r_io_plugin_list_json (core->io);
			} else {
				r_io_plugin_list (core->io);
			}
		}
		break;
	case 'u': { 
		core->switch_file_view = 0;
		int num = atoi (input + 2);
		r_io_use_fd (core->io, num);
		RBinFile *bf = r_bin_file_find_by_fd (core->bin, num);
		if (bf) {
			r_core_bin_raise (core, bf->id);
			r_core_block_read (core);
		}
		break;
	}
	case 'b': 
		cmd_open_bin (core, input);
		break;
	case '-': 
		switch (input[1]) {
		case '!': 
			if (input[2] == '?') {
				r_core_cmd_help_match (core, help_msg_o_dash, "o-!");
			} else {
				r_core_file_close_all_but (core);
			}
			break;
		case '$': 
			if (input[2] == '?') {
				r_core_cmd_help_match (core, help_msg_o_dash, "o-$");
			} else {
				R_LOG_TODO ("o-$: close last fd is not implemented");
			}
			break;
		case '.': 
			if (input[2] == '?') {
				r_core_cmd_help_match (core, help_msg_o_dash, "o-*");
			} else {
				RBinFile *bf = r_bin_cur (core->bin);
				if (bf && bf->fd >= 0) {
					core->bin->cur = NULL;
					int fd = bf->fd;
					if (!r_io_fd_close (core->io, fd)) {
						R_LOG_ERROR ("Unable to find file descriptor %d", fd);
					}
				}
			}
			break;
		case '*': 
			if (input[2] == '?') {
				r_core_cmd_help_match (core, help_msg_o_dash, "o-*");
			} else {
				r_io_close_all (core->io);
				r_bin_file_delete_all (core->bin);
			}
			break;
		case '-': 
			if (input[2] == '?') {
				r_core_cmd_help_match (core, help_msg_o_dash, "o--");
			} else {
				r_io_close_all (core->io);
				r_bin_file_delete_all (core->bin);
				r_core_cmd0 (core, "o-*;om-*");
				r_anal_purge (core->anal);
				r_flag_unset_all (core->flags);
			}
			break;
		case '\0':
		case '?':
			r_core_cmd_help (core, help_msg_o_dash);
			break;
		default: {
			int fd = (int)r_num_math (core->num, input + 1);
			if (!r_io_fd_close (core->io, fd)) {
				R_LOG_ERROR ("Unable to find file descriptor %d", fd);
			}
			}
			break;
		}
		break;
	case '.': 
		if (input[1] == 'q') { 
			RIOMap *map = r_io_map_get_at (core->io, core->offset);
			if (map) {
				r_cons_printf ("%d\n", map->fd);
			}
		} else {
			RIOMap *map = r_io_map_get_at (core->io, core->offset);
			if (map) {
				RIODesc *desc = r_io_desc_get (core->io, map->fd);
				if (desc) {
					r_cons_printf ("%s\n", desc->uri);
				}
			}
		}
		break;
	case ':': 
		{
			int len = r_num_math (core->num, input + 1);
			if (len < 1) {
				len = core->blocksize;
			}
			char *uri = r_str_newf ("malloc://%d", len);
			ut8 *data = calloc (len, 1);
			r_io_read_at (core->io, core->offset, data, len);
			if ((file = r_core_file_open (core, uri, R_PERM_RWX, 0))) {
				fd = file->fd;
				r_core_return_value (core, fd);
				r_core_bin_load (core, uri, 0);
				RIODesc *desc = r_io_desc_get (core->io, fd);
				if (desc) {
					r_io_desc_write_at (desc, 0, data, len);
				}
			} else {
				R_LOG_ERROR ("Cannot %s", uri);
			}
			free (uri);
			free (data);
		}
		break;
	case 'm': 
		cmd_open_map (core, input);
		break;
	case 'o': 
		switch (input[1]) {
		case 'm': 
			r_core_file_reopen_in_malloc (core);
			break;
		case 'd': 
			switch (input[2]) {
			case 'r': 
				r_core_cmdf (core, "dor %s", input + 3);
				r_core_file_reopen_debug (core, "");
				break;
			case 'f': 
				argv = r_str_argv (input + 3, &argc);
				if (argc < 1 || argc > 2) {
					r_core_cmd_help_match (core, help_msg_ood, "oodf");
					r_str_argv_free (argv);
					return 0;
				}
				if (argc == 2 && r_num_is_valid_input (core->num, argv[1])) {
					addr = r_num_math (core->num, argv[1]);
				}
				r_core_file_reopen_remote_debug (core, argv[0], addr);
				r_str_argv_free (argv);
				break;
			case '\0': 
			case ' ': 
				r_core_file_reopen_debug (core, r_str_trim_head_ro (input + 2));
				break;
			case '?': 
			default:
				r_core_cmd_help (core, help_msg_ood);
				break;
			}
			break;
		case 'c': 
			if (input[2] == '?') {
				r_core_cmd_help_match (core, help_msg_oo, "ooc");
			} else {
				r_core_cmd0 (core, "oc `o.`");
			}
			break;
		case 'b': 
			if (input[2] == '?') {
				r_core_cmd_help_match (core, help_msg_oo, "oob");
			} else {
				r_core_file_reopen (core, input + 2, 0, 2);
			}
			break;
		case 'n': 
			switch (input[2]) {
			case 0: 
				r_core_file_reopen (core, NULL, 0, 0);
				break;
			case '+': 
				r_core_file_reopen (core, NULL, R_PERM_RW, 0);
				break;
			case 'n': 
				if (input[3] == '?' || !core->io->desc) {
					r_core_cmd_help_contains (core, help_msg_oo, "oonn");
					break;
				}
				RIODesc *desc = r_io_desc_get (core->io, core->io->desc->fd);
				if (desc) {
					perms = core->io->desc->perm;
					if (input[3] == '+') {
						perms |= R_PERM_RW;
					}
					char *fname = strdup (desc->name);
					if (fname) {
						r_core_bin_load_structs (core, fname);
						r_core_file_reopen (core, fname, perms, 0);
						free (fname);
					}
					break;
				}
				break;
			case '?':
			default:
				r_core_cmd_help_contains (core, help_msg_oo, "oon");
				break;
			}
			break;
		case '+': 
			if (input[2] == '?') {
				r_core_cmd_help_match (core, help_msg_oo, "oo+");
			} else if (core && core->io && core->io->desc) {
				int fd;
				int perms = R_PERM_RW;
				if ((ptr = strrchr (input, ' ')) && ptr[1]) {
					fd = (int)r_num_math (core->num, ptr + 1);
				} else {
					fd = core->io->desc->fd;
					perms |= core->io->desc->perm;
				}
				if (r_io_reopen (core->io, fd, perms, 644)) {
					RListIter *iter;
					RList *maplist = r_io_map_get_by_fd (core->io, fd);
					if (!maplist) {
						break;
					}
					RIOMap *map;
					r_list_foreach (maplist, iter, map) {
						map->perm |= R_PERM_WX;
					}
					r_list_free (maplist);
				}
			}
			break;
		case '\0': 
			if (core && core->io && core->io->desc) {
				int fd;
				if ((ptr = strrchr (input, ' ')) && ptr[1]) {
					fd = (int)r_num_math (core->num, ptr + 1);
				} else {
					fd = core->io->desc->fd;
				}
				if (r_config_get_b (core->config, "cfg.debug")) {
					RBinFile *bf = r_bin_cur (core->bin);
					if (bf && r_file_exists (bf->file)) {
						char *file = r_str_path_escape (bf->file);
						ut64 orig_baddr = core->bin->cur->bo->baddr_shift;
						RList *orig_sections = __save_old_sections (core);
						r_core_cmd0 (core, "ob-*");
						r_io_close_all (core->io);
						r_config_set_b (core->config, "cfg.debug", false);
						r_core_cmdf (core, "o %s", file);
						r_core_block_read (core);
						__rebase_everything (core, orig_sections, orig_baddr);
						r_list_free (orig_sections);
						free (file);
					} else {
						R_LOG_WARN ("Nothing to do");
					}
				} else {
					if (!r_io_reopen (core->io, fd, R_PERM_RX, 755)) {
						R_LOG_ERROR ("Cannot reopen");
					}
				}
			}
			break;
		case '?': 
		default:
			 r_core_cmd_help (core, help_msg_oo);
			 break;
		}
		break;
	case 'c': 
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_o, "oc");
		} else if (input[1] && input[2]) {
			if (r_sandbox_enable (0)) {
				R_LOG_ERROR ("This command is disabled in sandbox mode");
				return 0;
			}
			if (core->tasks.current_task != core->tasks.main_task) {
				R_LOG_ERROR ("This command can only be executed on the main task!");
				return 0;
			}
			r_core_task_sync_end (&core->tasks);
			r_core_fini (core);
			r_core_init (core);
			r_core_task_sync_begin (&core->tasks);
			if (r_core_file_open (core, input + 2, R_PERM_RX, 0)) {
				(void)r_core_bin_load (core, NULL, baddr);
			} else {
				R_LOG_ERROR ("Cannot open file");
			}
		} else {
			R_LOG_ERROR ("Missing argument");
		}
		break;
	case 'x': 
		if (input[1] && input[1] != '?') {
			int fd, fdx;
			fd = fdx = -1;
			char *ptr, *inp = strdup (input);
			if ((ptr = strrchr (inp, ' '))) {
				fdx = (int)r_num_math (core->num, ptr + 1);
				*ptr = '\0';
				if ((ptr = strchr (inp, ' '))) {
					fd = r_num_math (core->num, ptr + 1);
				}
			}
			if ((fdx == -1) || (fd == -1) || (fdx == fd)) {
				free (inp);
				break;
			}
			r_io_desc_exchange (core->io, fd, fdx);
			free (inp);
			r_core_block_read (core);
		} else {
			r_core_cmd_help_match (core, help_msg_o, "oxr");
		}
		break;
	case '?': 
	default:
		r_core_cmd_help (core, help_msg_o);
		break;
	}
	return 0;
}
