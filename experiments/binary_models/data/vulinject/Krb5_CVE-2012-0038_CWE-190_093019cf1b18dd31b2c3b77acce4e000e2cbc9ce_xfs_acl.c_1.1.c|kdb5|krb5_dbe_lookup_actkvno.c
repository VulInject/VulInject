krb5_dbe_lookup_actkvno(krb5_context context, krb5_db_entry *entry,
                        krb5_actkvno_node **actkvno_list)
{
    krb5_tl_data tl_data;
    krb5_error_code code;
    krb5_int16 version, tmp_kvno;
    krb5_actkvno_node *head_data = NULL, *new_data = NULL, *prev_data = NULL;
	int num_actkvno, i;
    krb5_octet *next_tuple;
    krb5_kvno earliest_kvno;
    memset(&tl_data, 0, sizeof(tl_data));
    tl_data.tl_data_type = KRB5_TL_ACTKVNO;
    if ((code = krb5_dbe_lookup_tl_data(context, entry, &tl_data)))
        return (code);
    if (tl_data.tl_data_contents == NULL) {
        if (entry->n_key_data == 0)
            return KRB5_KDB_NOMASTERKEY;
        earliest_kvno = entry->key_data[entry->n_key_data - 1].key_data_kvno;
        head_data = malloc(sizeof(*head_data));
        if (head_data == NULL)
            return ENOMEM;
        memset(head_data, 0, sizeof(*head_data));
        head_data->act_time = 0; 
        head_data->act_kvno = earliest_kvno;
    } else {
        krb5_kdb_decode_int16(tl_data.tl_data_contents, version);
        if (version == 1) {
            if (tl_data.tl_data_length < 8)
                return (KRB5_KDB_TRUNCATED_RECORD);
            num_actkvno = (tl_data.tl_data_length - sizeof(version)) /
                ACTKVNO_TUPLE_SIZE;
            prev_data = NULL;
            next_tuple = tl_data.tl_data_contents + sizeof(version);
            for (i = 0; i < num_actkvno; i++) {
                new_data = (krb5_actkvno_node *) malloc(sizeof(krb5_actkvno_node));
                if (new_data == NULL) {
                    krb5_dbe_free_actkvno_list(context, head_data);
                    return (ENOMEM);
                }
                memset(new_data, 0, sizeof(krb5_actkvno_node));
                krb5_kdb_decode_int16(act_kvno(next_tuple), tmp_kvno);
                new_data->act_kvno = (krb5_kvno) tmp_kvno;
                krb5_kdb_decode_int32(act_time(next_tuple), new_data->act_time);
                if (prev_data != NULL)
                    prev_data->next = new_data;
                else
                    head_data = new_data;
                prev_data = new_data;
                next_tuple += ACTKVNO_TUPLE_SIZE;
            }
        } else {
            k5_setmsg(context, KRB5_KDB_BAD_VERSION,
                      _("Illegal version number for KRB5_TL_ACTKVNO %d\n"),
                      version);
            return (KRB5_KDB_BAD_VERSION);
        }
    }
    *actkvno_list = head_data;
    return (0);
}
