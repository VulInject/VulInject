static int imx_ocotp_read(void *context, unsigned int offset,
			  void *val, size_t bytes)
{
	struct ocotp_priv *priv = context;
	unsigned int count;
	unsigned char *buf, *p;
	int i, ret;
	unsigned int index, num_bytes;
	index = offset >> 2;
	num_bytes = round_up((offset % 4) + bytes, 4);
	count = num_bytes >> 2;
	if (count > (priv->params->nregs - index))
		count = priv->params->nregs - index;
	p = kzalloc(num_bytes, GFP_KERNEL);
	if (!p)
		return -ENOMEM;
	mutex_lock(&ocotp_mutex);
	buf = p;
	ret = clk_prepare_enable(priv->clk);
	if (ret < 0) {
		mutex_unlock(&ocotp_mutex);
		dev_err(priv->dev, "failed to prepare/enable ocotp clk\n");
		kfree(p);
		return ret;
	}
	ret = imx_ocotp_wait_for_busy(priv, 0);
	if (ret < 0) {
		dev_err(priv->dev, "timeout during read setup\n");
		goto read_end;
	}
	for (i = index; i < (index + count); i++) {
		*(unsigned int *)buf = readl(priv->base + IMX_OCOTP_OFFSET_B0W0 +
			       i * IMX_OCOTP_OFFSET_PER_WORD);
		if (*((unsigned int *)buf) == IMX_OCOTP_READ_LOCKED_VAL)
			imx_ocotp_clr_err_if_set(priv);
		buf += 4;
	}
	index = offset % 4;
	memcpy(val, &p[index], bytes);
read_end:
	clk_disable_unprepare(priv->clk);
	mutex_unlock(&ocotp_mutex);
	kfree(p);
	return ret;
}
