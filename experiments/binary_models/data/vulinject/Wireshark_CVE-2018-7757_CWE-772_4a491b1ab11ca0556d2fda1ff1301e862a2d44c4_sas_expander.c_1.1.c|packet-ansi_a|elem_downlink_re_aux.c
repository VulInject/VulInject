elem_downlink_re_aux(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 offset, guint len, proto_item *parent_item_p)
{
    guint8      disc;
    guint16     consumed;
    guint8      num_cells;
    guint8      curr_cell;
    guint32     curr_offset;
    proto_item  *item;
    proto_tree  *subtree;
    curr_offset = offset;
    proto_tree_add_item(tree, hf_ansi_a_downlink_re_num_cells, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
    num_cells = tvb_get_guint8(tvb, curr_offset);
    curr_offset += 1;
    proto_tree_add_item(tree, hf_ansi_a_cell_id_disc, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
    disc = tvb_get_guint8(tvb, curr_offset);
    curr_offset += 1;
    NO_MORE_DATA_CHECK(len);
    curr_cell = 0;
    do
    {
        SHORT_DATA_CHECK(len - (curr_offset - offset), (guint32) 3 + ANSI_A_CELL_ID_LEN(disc));
        subtree =
            proto_tree_add_subtree_format(tree, tvb, curr_offset, -1,
                ett_cell_list, &item, "Cell [%u]", curr_cell + 1);
        consumed =
            elem_cell_id_aux(tvb, pinfo, subtree, curr_offset, len - (curr_offset - offset), disc, item);
        proto_item_set_len(item, consumed);
        curr_offset += consumed;
        proto_tree_add_item(tree, hf_ansi_a_reserved_bits_8_c0, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
        proto_tree_add_item(tree, hf_ansi_a_downlink_re_sig_str_raw, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
        curr_offset += 1;
        proto_tree_add_item(tree, hf_ansi_a_downlink_re_cdma_towd, tvb, curr_offset, 2, ENC_BIG_ENDIAN);
        curr_offset += 2;
        curr_cell++;
    }
    while (curr_cell < num_cells);
    proto_item_append_text(parent_item_p, " - %u cell%s", num_cells, plurality(num_cells, "", "s"));
    return curr_offset - offset;
}
