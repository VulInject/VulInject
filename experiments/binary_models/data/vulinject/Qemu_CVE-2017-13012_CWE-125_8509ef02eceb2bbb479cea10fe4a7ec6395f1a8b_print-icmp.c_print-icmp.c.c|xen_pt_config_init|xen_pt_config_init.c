void xen_pt_config_init(XenPCIPassthroughState *s, Error **errp)
{
    ERRP_GUARD();
    int i, rc;
    for (i = 0; xen_pt_emu_reg_grps[i].grp_size != 0; i++) {
        uint32_t reg_grp_offset = 0;
        XenPTRegGroup *reg_grp_entry = NULL;
        if (xen_pt_emu_reg_grps[i].grp_id != 0xFF
            && xen_pt_emu_reg_grps[i].grp_id != XEN_PCI_INTEL_OPREGION) {
            if (xen_pt_hide_dev_cap(&s->real_device,
                                    xen_pt_emu_reg_grps[i].grp_id)) {
                continue;
            }
            reg_grp_offset = find_cap_offset(s, xen_pt_emu_reg_grps[i].grp_id);
            if (!reg_grp_offset) {
                continue;
            }
        }
        if (xen_pt_emu_reg_grps[i].grp_id == XEN_PCI_INTEL_OPREGION) {
            if (!is_igd_vga_passthrough(&s->real_device) ||
                s->real_device.vendor_id != PCI_VENDOR_ID_INTEL) {
                continue;
            }
            /*
             * By default we will trap up to 0x40 in the cfg space.
             * If an intel device is pass through we need to trap 0xfc,
             * therefore the size should be 0xff.
             */
            reg_grp_offset = XEN_PCI_INTEL_OPREGION;
        }
        reg_grp_entry = g_new0(XenPTRegGroup, 1);
        QLIST_INIT(&reg_grp_entry->reg_tbl_list);
        QLIST_INSERT_HEAD(&s->reg_grps, reg_grp_entry, entries);
        reg_grp_entry->base_offset = reg_grp_offset;
        reg_grp_entry->reg_grp = xen_pt_emu_reg_grps + i;
        if (xen_pt_emu_reg_grps[i].size_init) {
            /* get register group size */
            rc = xen_pt_emu_reg_grps[i].size_init(s, reg_grp_entry->reg_grp,
                                                  reg_grp_offset,
                                                  &reg_grp_entry->size);
            if (rc < 0) {
                error_setg(errp, "Failed to initialize %d/%zu, type = 0x%x,"
                           " rc: %d", i, ARRAY_SIZE(xen_pt_emu_reg_grps),
                           xen_pt_emu_reg_grps[i].grp_type, rc);
                xen_pt_config_delete(s);
                return;
            }
        }
        if (xen_pt_emu_reg_grps[i].grp_type == XEN_PT_GRP_TYPE_EMU) {
            if (xen_pt_emu_reg_grps[i].emu_regs) {
                int j = 0;
                XenPTRegInfo *regs = xen_pt_emu_reg_grps[i].emu_regs;
                /* initialize capability register */
                for (j = 0; regs->size != 0; j++, regs++) {
                    xen_pt_config_reg_init(s, reg_grp_entry, regs, errp);
                    if (*errp) {
                        error_append_hint(errp, "Failed to init register %d"
                                          " offsets 0x%x in grp_type = 0x%x (%d/%zu)",
                                          j,
                                          regs->offset,
                                          xen_pt_emu_reg_grps[i].grp_type,
                                          i, ARRAY_SIZE(xen_pt_emu_reg_grps));
                        xen_pt_config_delete(s);
                        return;
                    }
                }
            }
        }
    }
}
