dissect_epl_payload(proto_tree *epl_tree, tvbuff_t *tvb, packet_info *pinfo, gint offset, gint len, const struct epl_datatype *type, guint8 msgType)
{
	gint rem_len = 0, payload_len = 0;
	tvbuff_t *payload_tvb = NULL;
	heur_dtbl_entry_t *hdtbl_entry = NULL;
	proto_item *item = NULL;
	if (len <= 0)
		return offset;
	rem_len = tvb_captured_length_remaining(tvb, offset);
	payload_tvb = tvb_new_subset_length(tvb, offset, MIN(len, rem_len));
	payload_len = tvb_captured_length_remaining(payload_tvb, 0);
	if ( payload_len < len )
	{
		item = proto_tree_add_uint(epl_tree, hf_epl_payload_real, tvb, offset, payload_len, payload_len);
		expert_add_info(pinfo, item, &ei_real_length_differs );
	}
	if (msgType != EPL_PREQ && msgType != EPL_PRES)
	{
		if ( dissector_try_heuristic(heur_epl_data_subdissector_list, payload_tvb, pinfo, epl_tree, &hdtbl_entry, &msgType))
			return offset + payload_len;
	}
	if (type && (!type->len || type->len == payload_len))
	{
		if (*type->hf != hf_epl_od_uint)
		{
			proto_tree_add_item(epl_tree, *type->hf, tvb, offset, type->len, type->encoding);
		}
		else
		{
			guint64 val;
			item = proto_tree_add_item_ret_uint64(epl_tree, *type->hf,
						tvb, offset, type->len, type->encoding, &val);
			proto_item_append_text(item, " (0x%.*" PRIx64 ")", 2*type->len, val);
		}
	}
	else
	{
		if (payload_len < (int)sizeof (guint64) && interpret_untyped_as_le)
		{
			guint64 val;
			item = proto_tree_add_item_ret_uint64(epl_tree, hf_epl_od_uint,
						payload_tvb, 0, payload_len, ENC_LITTLE_ENDIAN, &val);
			proto_item_append_text(item, " (0x%.*" PRIx64 ")", 2*payload_len, val);
		}
		else
		{
			call_data_dissector(payload_tvb, pinfo, epl_tree);
		}
	}
	return offset + payload_len;
}
