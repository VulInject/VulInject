static av_cold int flac_encode_init(AVCodecContext *avctx)
{
    int freq = avctx->sample_rate;
    int channels = avctx->ch_layout.nb_channels;
    FlacEncodeContext *s = avctx->priv_data;
    int i, level, ret;
    uint8_t *streaminfo;
    s->avctx = avctx;
    switch (avctx->sample_fmt) {
    case AV_SAMPLE_FMT_S16:
        avctx->bits_per_raw_sample = 16;
        s->bps_code                = 4;
        break;
    case AV_SAMPLE_FMT_S32:
        if (avctx->bits_per_raw_sample <= 24) {
            if (avctx->bits_per_raw_sample < 24)
                av_log(avctx, AV_LOG_WARNING, "encoding as 24 bits-per-sample\n");
            avctx->bits_per_raw_sample = 24;
            s->bps_code                = 6;
        } else if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {
            av_log(avctx, AV_LOG_WARNING,
                   "encoding as 24 bits-per-sample, more is considered "
                   "experimental. Add -strict experimental if you want "
                   "to encode more than 24 bits-per-sample\n");
            avctx->bits_per_raw_sample = 24;
            s->bps_code                = 6;
        } else {
            avctx->bits_per_raw_sample = 32;
            s->bps_code = 7;
        }
        break;
    }
    if (channels < 1 || channels > FLAC_MAX_CHANNELS) {
        av_log(avctx, AV_LOG_ERROR, "%d channels not supported (max %d)\n",
               channels, FLAC_MAX_CHANNELS);
        return AVERROR(EINVAL);
    }
    s->channels = channels;
    /* find samplerate in table */
    if (freq < 1)
        return AVERROR(EINVAL);
    for (i = 1; i < 12; i++) {
        if (freq == ff_flac_sample_rate_table[i]) {
            s->samplerate = ff_flac_sample_rate_table[i];
            s->sr_code[0] = i;
            s->sr_code[1] = 0;
            break;
        }
    }
    /* if not in table, samplerate is non-standard */
    if (i == 12) {
        if (freq % 1000 == 0 && freq < 255000) {
            s->sr_code[0] = 12;
            s->sr_code[1] = freq / 1000;
        } else if (freq % 10 == 0 && freq < 655350) {
            s->sr_code[0] = 14;
            s->sr_code[1] = freq / 10;
        } else if (freq < 65535) {
            s->sr_code[0] = 13;
            s->sr_code[1] = freq;
        } else if (freq < 1048576) {
            s->sr_code[0] = 0;
            s->sr_code[1] = 0;
        } else {
            av_log(avctx, AV_LOG_ERROR, "%d Hz not supported\n", freq);
            return AVERROR(EINVAL);
        }
        s->samplerate = freq;
    }
    /* set compression option defaults based on avctx->compression_level */
    if (avctx->compression_level < 0)
        s->options.compression_level = 5;
    else
        s->options.compression_level = avctx->compression_level;
    level = s->options.compression_level;
    if (level > 12) {
        av_log(avctx, AV_LOG_ERROR, "invalid compression level: %d\n",
               s->options.compression_level);
        return AVERROR(EINVAL);
    }
    s->options.block_time_ms = ((int[]){ 27, 27, 27,105,105,105,105,105,105,105,105,105,105})[level];
    if (s->options.lpc_type == FF_LPC_TYPE_DEFAULT)
        s->options.lpc_type  = ((int[]){ FF_LPC_TYPE_FIXED,    FF_LPC_TYPE_FIXED,    FF_LPC_TYPE_FIXED,
                                         FF_LPC_TYPE_LEVINSON, FF_LPC_TYPE_LEVINSON, FF_LPC_TYPE_LEVINSON,
                                         FF_LPC_TYPE_LEVINSON, FF_LPC_TYPE_LEVINSON, FF_LPC_TYPE_LEVINSON,
                                         FF_LPC_TYPE_LEVINSON, FF_LPC_TYPE_LEVINSON, FF_LPC_TYPE_LEVINSON,
                                         FF_LPC_TYPE_LEVINSON})[level];
    if (s->options.min_prediction_order < 0)
        s->options.min_prediction_order = ((int[]){  2,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1})[level];
    if (s->options.max_prediction_order < 0)
        s->options.max_prediction_order = ((int[]){  3,  4,  4,  6,  8,  8,  8,  8, 12, 12, 12, 32, 32})[level];
    if (s->options.prediction_order_method < 0)
        s->options.prediction_order_method = ((int[]){ ORDER_METHOD_EST,    ORDER_METHOD_EST,    ORDER_METHOD_EST,
                                                       ORDER_METHOD_EST,    ORDER_METHOD_EST,    ORDER_METHOD_EST,
                                                       ORDER_METHOD_4LEVEL, ORDER_METHOD_LOG,    ORDER_METHOD_4LEVEL,
                                                       ORDER_METHOD_LOG,    ORDER_METHOD_SEARCH, ORDER_METHOD_LOG,
                                                       ORDER_METHOD_SEARCH})[level];
    if (s->options.min_partition_order > s->options.max_partition_order) {
        av_log(avctx, AV_LOG_ERROR, "invalid partition orders: min=%d max=%d\n",
               s->options.min_partition_order, s->options.max_partition_order);
        return AVERROR(EINVAL);
    }
    if (s->options.min_partition_order < 0)
        s->options.min_partition_order = ((int[]){  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0})[level];
    if (s->options.max_partition_order < 0)
        s->options.max_partition_order = ((int[]){  2,  2,  3,  3,  3,  8,  8,  8,  8,  8,  8,  8,  8})[level];
    if (s->options.lpc_type == FF_LPC_TYPE_NONE) {
        s->options.min_prediction_order = 0;
        s->options.max_prediction_order = 0;
    } else if (s->options.lpc_type == FF_LPC_TYPE_FIXED) {
        if (s->options.min_prediction_order > MAX_FIXED_ORDER) {
            av_log(avctx, AV_LOG_WARNING,
                   "invalid min prediction order %d, clamped to %d\n",
                   s->options.min_prediction_order, MAX_FIXED_ORDER);
            s->options.min_prediction_order = MAX_FIXED_ORDER;
        }
        if (s->options.max_prediction_order > MAX_FIXED_ORDER) {
            av_log(avctx, AV_LOG_WARNING,
                   "invalid max prediction order %d, clamped to %d\n",
                   s->options.max_prediction_order, MAX_FIXED_ORDER);
            s->options.max_prediction_order = MAX_FIXED_ORDER;
        }
    }
    if (s->options.max_prediction_order < s->options.min_prediction_order) {
        av_log(avctx, AV_LOG_ERROR, "invalid prediction orders: min=%d max=%d\n",
               s->options.min_prediction_order, s->options.max_prediction_order);
        return AVERROR(EINVAL);
    }
    if (avctx->frame_size > 0) {
        if (avctx->frame_size < FLAC_MIN_BLOCKSIZE ||
                avctx->frame_size > FLAC_MAX_BLOCKSIZE) {
            av_log(avctx, AV_LOG_ERROR, "invalid block size: %d\n",
                   avctx->frame_size);
            return AVERROR(EINVAL);
        }
    } else {
        s->avctx->frame_size = select_blocksize(s->samplerate, s->options.block_time_ms);
    }
    s->max_blocksize = s->avctx->frame_size;
    /* set maximum encoded frame size in verbatim mode */
    s->max_framesize = flac_get_max_frame_size(s->avctx->frame_size,
                                               s->channels,
                                               s->avctx->bits_per_raw_sample);
    /* initialize MD5 context */
    s->md5ctx = av_md5_alloc();
    if (!s->md5ctx)
        return AVERROR(ENOMEM);
    av_md5_init(s->md5ctx);
    streaminfo = av_malloc(FLAC_STREAMINFO_SIZE);
    if (!streaminfo)
        return AVERROR(ENOMEM);
    write_streaminfo(s, streaminfo);
    avctx->extradata = streaminfo;
    avctx->extradata_size = FLAC_STREAMINFO_SIZE;
    s->frame_count   = 0;
    s->min_framesize = s->max_framesize;
    if ((channels == 3 &&
         av_channel_layout_compare(&avctx->ch_layout, &(AVChannelLayout)AV_CHANNEL_LAYOUT_SURROUND)) ||
        (channels == 4 &&
         av_channel_layout_compare(&avctx->ch_layout, &(AVChannelLayout)AV_CHANNEL_LAYOUT_2_2) &&
         av_channel_layout_compare(&avctx->ch_layout, &(AVChannelLayout)AV_CHANNEL_LAYOUT_QUAD)) ||
        (channels == 5 &&
         av_channel_layout_compare(&avctx->ch_layout, &(AVChannelLayout)AV_CHANNEL_LAYOUT_5POINT0) &&
         av_channel_layout_compare(&avctx->ch_layout, &(AVChannelLayout)AV_CHANNEL_LAYOUT_5POINT0_BACK)) ||
        (channels == 6 &&
         av_channel_layout_compare(&avctx->ch_layout, &(AVChannelLayout)AV_CHANNEL_LAYOUT_5POINT1) &&
         av_channel_layout_compare(&avctx->ch_layout, &(AVChannelLayout)AV_CHANNEL_LAYOUT_5POINT1_BACK))) {
        if (avctx->ch_layout.order != AV_CHANNEL_ORDER_UNSPEC) {
            av_log(avctx, AV_LOG_ERROR, "Channel layout not supported by Flac, "
                                             "output stream will have incorrect "
                                             "channel layout.\n");
        } else {
            av_log(avctx, AV_LOG_WARNING, "No channel layout specified. The encoder "
                                               "will use Flac channel layout for "
                                               "%d channels.\n", channels);
        }
    }
    ret = ff_lpc_init(&s->lpc_ctx, avctx->frame_size,
                      s->options.max_prediction_order, FF_LPC_TYPE_LEVINSON);
    ff_flacencdsp_init(&s->flac_dsp);
    dprint_compression_options(s);
    return ret;
}
