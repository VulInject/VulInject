static int cfi_intelext_partition_fixup(struct mtd_info *mtd,
					struct cfi_private **pcfi)
{
	struct map_info *map = mtd->priv;
	struct cfi_private *cfi = *pcfi;
	struct cfi_pri_intelext *extp = cfi->cmdset_priv;
	if (extp && extp->MajorVersion == '1' && extp->MinorVersion >= '3'
	    && extp->FeatureSupport & (1 << 9)) {
		int offs = 0;
		struct cfi_private *newcfi;
		struct flchip *chip;
		struct flchip_shared *shared;
		int numregions, numparts, partshift, numvirtchips, i, j;
		if (extp->NumProtectionFields)
			offs = (extp->NumProtectionFields - 1) *
			       sizeof(struct cfi_intelext_otpinfo);
		offs += extp->extra[offs+1]+2;
		numregions = extp->extra[offs];
		offs += 1;
		if (extp->MinorVersion >= '4')
			offs += 2;
		numparts = 0;
		for (i = 0; i < numregions; i++) {
			struct cfi_intelext_regioninfo *rinfo;
			rinfo = (struct cfi_intelext_regioninfo *)&extp->extra[offs];
			numparts += rinfo->NumIdentPartitions;
			offs += sizeof(*rinfo)
				+ (rinfo->NumBlockTypes - 1) *
				  sizeof(struct cfi_intelext_blockinfo);
		}
		if (!numparts)
			numparts = 1;
		if (extp->MinorVersion >= '4') {
			struct cfi_intelext_programming_regioninfo *prinfo;
			prinfo = (struct cfi_intelext_programming_regioninfo *)&extp->extra[offs];
			mtd->writesize = cfi->interleave << prinfo->ProgRegShift;
			mtd->flags &= ~MTD_BIT_WRITEABLE;
			printk(KERN_DEBUG "%s: program region size/ctrl_valid/ctrl_inval = %d/%d/%d\n",
			       map->name, mtd->writesize,
			       cfi->interleave * prinfo->ControlValid,
			       cfi->interleave * prinfo->ControlInvalid);
		}
		partshift = cfi->chipshift - __ffs(numparts);
		if ((1 << partshift) < mtd->erasesize) {
			printk( KERN_ERR
				"%s: bad number of hw partitions (%d)\n",
				__func__, numparts);
			return -EINVAL;
		}
		numvirtchips = cfi->numchips * numparts;
		newcfi = kmalloc(struct_size(newcfi, chips, numvirtchips),
				 GFP_KERNEL);
		if (!newcfi)
			return -ENOMEM;
		shared = kmalloc_array(cfi->numchips,
				       sizeof(struct flchip_shared),
				       GFP_KERNEL);
		if (!shared) {
			kfree(newcfi);
			return -ENOMEM;
		}
		memcpy(newcfi, cfi, sizeof(struct cfi_private));
		newcfi->numchips = numvirtchips;
		newcfi->chipshift = partshift;
		chip = &newcfi->chips[0];
		for (i = 0; i < cfi->numchips; i++) {
			shared[i].writing = shared[i].erasing = NULL;
			mutex_init(&shared[i].lock);
			for (j = 0; j < numparts; j++) {
				*chip = cfi->chips[i];
				chip->start += j << partshift;
				chip->priv = &shared[i];
				mutex_init(&chip->mutex);
				chip++;
			}
		}
		printk(KERN_DEBUG "%s: %d set(s) of %d interleaved chips "
				  "--> %d partitions of %d KiB\n",
				  map->name, cfi->numchips, cfi->interleave,
				  newcfi->numchips, 1<<(newcfi->chipshift-10));
		map->fldrv_priv = newcfi;
		*pcfi = newcfi;
		kfree(cfi);
	}
	return 0;
}
