F(char *output, char *u_tmp1, char *u_tmp2,
  const struct krb5_hash_provider *hash, size_t hlen, krb5_keyblock *pass,
  const krb5_data *salt, unsigned long count, int i)
{
    unsigned char ibytes[4];
	int j, k;
    krb5_data sdata;
    krb5_data out;
    krb5_error_code err;
    store_32_be(i, ibytes);
    memcpy(u_tmp2, salt->data, salt->length);
    memcpy(u_tmp2 + salt->length, ibytes, 4);
    sdata = make_data(u_tmp2, salt->length + 4);
    out = make_data(u_tmp1, hlen);
    err = k5_hmac(hash, pass, &sdata, &out);
    if (err)
        return err;
    memcpy(output, u_tmp1, hlen);
    sdata.length = hlen;
    for (j = 2; j <= count; j++) {
        memcpy(u_tmp2, u_tmp1, hlen);
        err = k5_hmac(hash, pass, &sdata, &out);
        if (err)
            return err;
        for (k = 0; k < hlen; k++)
            output[k] ^= u_tmp1[k];
    }
    return 0;
}
