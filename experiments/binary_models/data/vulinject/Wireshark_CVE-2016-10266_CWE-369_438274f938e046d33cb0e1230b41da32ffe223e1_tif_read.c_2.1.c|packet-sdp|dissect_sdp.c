dissect_sdp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
    proto_tree *sdp_tree;
    proto_item *ti, *sub_ti;
    gint        offset = 0, next_offset, n;
    int         linelen;
    gboolean    in_media_description;
    guchar      type, delim;
    int         datalen, tokenoffset, hf = -1;
    char       *string;
    sdp_data_t  sdp_data;
    transport_info_t  local_transport_info;
    transport_info_t* transport_info = NULL;
    media_description_t *media_desc = NULL;
    session_info_t session_info;
    sdp_packet_info  *sdp_pi;
    sdp_setup_info_t *setup_info = NULL;
    if (data) {
        media_content_info_t *content_info = (media_content_info_t *)data;
        if (content_info->type == MEDIA_CONTAINER_SIP_DATA) {
            setup_info = (sdp_setup_info_t *)content_info->data;
        }
    }
    DPRINT2(("----------------------- dissect_sdp ------------------------"));
	sdp_pi=((pinfo->pool+sdp_packet_info-1)/sdp_packet_info);
    sdp_pi->summary_str[0] = '\0';
    memset(&sdp_data, 0, sizeof(sdp_data));
    transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_reqs, pinfo->num );
    if (transport_info == NULL) {
      transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_rsps, pinfo->num );
    }
    if (transport_info == NULL) {
      transport_info = &local_transport_info;
    }
#ifdef DEBUG_CONVERSATION
    else {
        DPRINT(("found previous transport_info:"));
        sdp_dump_transport_info(pinfo, transport_info);
    }
#endif
    memset(&local_transport_info, 0, sizeof(local_transport_info));
    local_transport_info.media_descriptions = wmem_array_new(pinfo->pool, sizeof(media_description_t));
    for (n = 0; n < SDP_NO_OF_PT; n++) {
        local_transport_info.encoding_name[n] = wmem_strdup(pinfo->pool, UNKNOWN_ENCODING);
    }
    col_append_str(pinfo->cinfo, COL_PROTOCOL, "/SDP");
    ti = proto_tree_add_item(tree, proto_sdp, tvb, offset, -1, ENC_NA);
    sdp_tree = proto_item_add_subtree(ti, ett_sdp);
    in_media_description = FALSE;
    memset(&session_info, 0, sizeof(session_info_t));
    session_info.rtp_dyn_payload = rtp_dyn_payload_new();
    while (tvb_offset_exists(tvb, offset)) {
        linelen = tvb_find_line_end_unquoted(tvb, offset, -1, &next_offset);
        if (linelen < 2)
            break;
        type  = tvb_get_guint8(tvb, offset);
        delim = tvb_get_guint8(tvb, offset + 1);
        if (delim != '=') {
            proto_item *ti2 = proto_tree_add_item(sdp_tree, hf_invalid, tvb, offset, linelen, ENC_UTF_8);
            expert_add_info(pinfo, ti2, &ei_sdp_invalid_line_equal);
            offset = next_offset;
            continue;
        }
        switch (type) {
            case 'v':
                hf = hf_protocol_version;
                break;
            case 'o':
                hf = hf_owner;
                break;
            case 's':
                hf = hf_session_name;
                break;
            case 'i':
                if (in_media_description) {
                  hf = hf_media_title;
                } else {
                  hf = hf_session_info;
                }
                break;
            case 'u':
                hf = hf_uri;
                break;
            case 'e':
                hf = hf_email;
                break;
            case 'p':
                hf = hf_phone;
                break;
            case 'c':
                hf = hf_connection_info;
                break;
            case 'b':
                hf = hf_bandwidth;
                break;
            case 't':
                hf = hf_time;
                break;
            case 'r':
                hf = hf_repeat_time;
                break;
            case 'm':
                hf = hf_media;
                media_desc = sdp_new_media_description(local_transport_info.media_descriptions, &session_info);
                in_media_description = TRUE;
                break;
            case 'k':
                hf = hf_encryption_key;
                break;
            case 'a':
                if (in_media_description) {
                    hf = hf_media_attribute;
                } else {
                    hf = hf_session_attribute;
                }
                break;
            case 'z':
                hf = hf_timezone;
                break;
            default:
                hf = hf_unknown;
                break;
        }
        tokenoffset = 2;
        if (hf == hf_unknown)
            tokenoffset = 0;
        string = (char*)tvb_get_string_enc(pinfo->pool, tvb, offset + tokenoffset,
                                                 linelen - tokenoffset, ENC_ASCII);
        sub_ti = proto_tree_add_string(sdp_tree, hf, tvb, offset, linelen,
                                       string);
        call_sdp_subdissector(tvb_new_subset_length(tvb, offset + tokenoffset,
                                             linelen - tokenoffset),
                              pinfo,
                              hf, sub_ti, linelen-tokenoffset,
                              &local_transport_info,
                              in_media_description ? NULL : &session_info,
                              in_media_description ? media_desc : NULL,
                              &sdp_data);
        offset = next_offset;
    }
    if (NULL != sdp_data.ed137_fid) {
      col_append_fstr(pinfo->cinfo, COL_INFO, "%s ", sdp_data.ed137_fid);
      (void) g_strlcat(sdp_pi->summary_str, sdp_data.ed137_fid, 50);
    }
    if (NULL != sdp_data.ed137_txrxmode) {
      col_append_fstr(pinfo->cinfo, COL_INFO, "%s ", sdp_data.ed137_txrxmode);
      if (strlen(sdp_pi->summary_str))
          (void) g_strlcat(sdp_pi->summary_str, " ", 50);
      (void) g_strlcat(sdp_pi->summary_str, sdp_data.ed137_txrxmode, 50);
    }
    if (NULL != sdp_data.ed137_type) {
      col_append_fstr(pinfo->cinfo, COL_INFO, "%s ", sdp_data.ed137_type);
      if (strlen(sdp_pi->summary_str))
          (void) g_strlcat(sdp_pi->summary_str, " ", 50);
      (void) g_strlcat(sdp_pi->summary_str, sdp_data.ed137_type, 50);
    }
    rtp_dyn_payload_free(session_info.rtp_dyn_payload);
    session_info.rtp_dyn_payload = NULL;
    if (transport_info == &local_transport_info) {
        DPRINT(("no previous transport_info saved, calling complete_descriptions()"));
        DINDENT();
        complete_descriptions(transport_info, 0);
        DENDENT();
#ifdef DEBUG_CONVERSATION
        sdp_dump_transport_info(pinfo, transport_info);
#endif
    }
#ifdef DEBUG_CONVERSATION
    else {
        DPRINT(("not overwriting previous transport_info, local_transport_info contents:"));
        sdp_dump_transport_info(pinfo, &local_transport_info);
    }
#endif
    if ((!pinfo->fd->visited) && (transport_info == &local_transport_info)) {
        apply_sdp_transport(pinfo, transport_info, 0, setup_info);
        p_add_proto_data(wmem_file_scope(), pinfo, proto_sdp, 0, transport_info->sdp_setup_info_list);
    }
    for (guint i = 0; i < wmem_array_get_count(local_transport_info.media_descriptions); i++)
    {
        media_desc = (media_description_t *)wmem_array_index(local_transport_info.media_descriptions, i);
        if (media_desc->media_port != 0) {
            for (int j = 0; j < media_desc->media.pt_count; j++)
            {
                DPRINT(("in for-loop for voip call analysis setting for media #%d, pt=%d",
                        j, media_desc->media. pt[j]));
                if ((media_desc->media.pt[j] >= 96) && (media_desc->media.pt[j] <= 127)) {
                    const gchar *payload_type_str = rtp_dyn_payload_get_name(
                        media_desc->media.rtp_dyn_payload,
                        media_desc->media.pt[j]);
                    if (payload_type_str) {
                        if (strlen(sdp_pi->summary_str))
                            (void) g_strlcat(sdp_pi->summary_str, " ", 50);
                        (void) g_strlcat(sdp_pi->summary_str, payload_type_str, 50);
                    } else {
                        char num_pt[10];
                        snprintf(num_pt, 10, "%u", media_desc->media.pt[j]);
                        if (strlen(sdp_pi->summary_str))
                            (void) g_strlcat(sdp_pi->summary_str, " ", 50);
                        (void) g_strlcat(sdp_pi->summary_str, num_pt, 50);
                      }
                } else {
                    if (strlen(sdp_pi->summary_str))
                        (void) g_strlcat(sdp_pi->summary_str, " ", 50);
                    (void) g_strlcat(sdp_pi->summary_str,
                              val_to_str_ext(media_desc->media.pt[j], &rtp_payload_type_short_vals_ext, "%u"),
                              50);
                }
            }
        }
        if ((media_desc->media_port != 0) && media_desc->proto == SDP_PROTO_T38) {
            if (strlen(sdp_pi->summary_str))
                (void) g_strlcat(sdp_pi->summary_str, " ", 50);
            (void) g_strlcat(sdp_pi->summary_str, "t38", 50);
        }
    }
    if (transport_info == &local_transport_info) {
        clean_unused_media_descriptions(transport_info->media_descriptions);
    }
    datalen = tvb_captured_length_remaining(tvb, offset);
    if (datalen > 0) {
        proto_tree_add_item(sdp_tree, hf_sdp_data, tvb, offset, datalen, ENC_NA);
    }
    wmem_array_t *setup_info_list = transport_info->sdp_setup_info_list;
    if (!setup_info_list) {
        setup_info_list = (wmem_array_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_sdp, 0);
    }
    if (setup_info_list) {
        guint i;
        sdp_setup_info_t *stored_setup_info;
        proto_item *item;
        for (i = 0; i < wmem_array_get_count(setup_info_list); i++) {
            stored_setup_info = (sdp_setup_info_t *)wmem_array_index(setup_info_list, i);
            if (stored_setup_info->hf_id) {
                if (stored_setup_info->hf_type == SDP_TRACE_ID_HF_TYPE_STR) {
                    item = proto_tree_add_string(sdp_tree, stored_setup_info->hf_id, tvb, 0, 0, stored_setup_info->trace_id.str);
                    proto_item_set_generated(item);
                    if (stored_setup_info->add_hidden == TRUE) {
                        proto_item_set_hidden(item);
                    }
                } else if (stored_setup_info->hf_type == SDP_TRACE_ID_HF_TYPE_GUINT32) {
                    item = proto_tree_add_uint(sdp_tree, stored_setup_info->hf_id, tvb, 0, 0, stored_setup_info->trace_id.num);
                    proto_item_set_generated(item);
                    if (stored_setup_info->add_hidden == TRUE) {
                        proto_item_set_hidden(item);
                    }
                }
            }
        }
    }
    tap_queue_packet(sdp_tap, pinfo, sdp_pi);
    return tvb_captured_length(tvb);
}
