capture_loop_start(capture_options *capture_opts, gboolean *stats_known, struct pcap_stat *stats)
{
#ifdef _WIN32
    DWORD             upd_time, cur_time; 
#else
    struct timeval    upd_time, cur_time;
#endif
    int               err_close;
    int               inpkts;
    GTimer           *autostop_duration_timer = NULL;
    gboolean          write_ok;
    gboolean          close_ok;
    gboolean          cfilter_error         = FALSE;
    char              errmsg[MSG_MAX_LENGTH+1];
    char              secondary_errmsg[MSG_MAX_LENGTH+1];
    capture_src      *pcap_src;
    interface_options *interface_opts;
    guint             i, error_index        = 0;
    *errmsg           = '\0';
    *secondary_errmsg = '\0';
    global_ld.go                  = TRUE;
    global_ld.packets_captured    = 0;
#ifdef SIGINFO
    global_ld.report_packet_count = FALSE;
#endif
    global_ld.inpkts_to_sync_pipe = 0;
    global_ld.err                 = 0;  
    global_ld.pdh                 = NULL;
    global_ld.save_file_fd        = -1;
    global_ld.io_buffer           = NULL;
    global_ld.file_count          = 0;
    global_ld.file_duration_timer = NULL;
    global_ld.next_interval_time  = 0;
    global_ld.interval_s          = 0;
    *stats_known      = FALSE;
    ws_info("Capture loop starting ...");
    capture_opts_log(LOG_DOMAIN_CAPCHILD, LOG_LEVEL_DEBUG, capture_opts);
    if (!capture_loop_open_input(capture_opts, &global_ld, errmsg, sizeof(errmsg),
                                 secondary_errmsg, sizeof(secondary_errmsg))) {
        goto error;
    }
    for (i = 0; i < capture_opts->ifaces->len; i++) {
        pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);
        interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);
        switch (capture_loop_init_filter(pcap_src->pcap_h, pcap_src->from_cap_pipe,
                                         interface_opts->name,
                                         interface_opts->cfilter?interface_opts->cfilter:"")) {
        case INITFILTER_NO_ERROR:
            break;
        case INITFILTER_BAD_FILTER:
            cfilter_error = TRUE;
            error_index = i;
            snprintf(errmsg, sizeof(errmsg), "%s", pcap_geterr(pcap_src->pcap_h));
            goto error;
        case INITFILTER_OTHER_ERROR:
            snprintf(errmsg, sizeof(errmsg), "Can't install filter (%s).",
                       pcap_geterr(pcap_src->pcap_h));
            snprintf(secondary_errmsg, sizeof(secondary_errmsg), "%s", please_report_bug());
            goto error;
        }
    }
    if (capture_opts->saving_to_file) {
        if (!capture_loop_open_output(capture_opts, &global_ld.save_file_fd,
                                      errmsg, sizeof(errmsg))) {
            goto error;
        }
        if (!capture_loop_init_output(capture_opts, &global_ld, errmsg,
                                      sizeof(errmsg))) {
            goto error;
        }
        fflush(global_ld.pdh);
        report_new_capture_file(capture_opts->save_file);
    }
    if (capture_opts->has_file_interval) {
        global_ld.interval_s = capture_opts->file_interval;
        global_ld.next_interval_time = get_next_time_interval(global_ld.interval_s);
    }
    if (capture_opts->has_autostop_filesize) {
        if (capture_opts->autostop_filesize > (((guint32)INT_MAX + 1) / 1000)) {
            capture_opts->autostop_filesize = ((guint32)INT_MAX + 1) / 1000;
        }
    }
    if (capture_opts->has_autostop_duration) {
        autostop_duration_timer = g_timer_new();
    }
    if (capture_opts->multi_files_on) {
        if (capture_opts->has_file_duration) {
            global_ld.file_duration_timer = g_timer_new();
        }
    }
#ifdef _WIN32
    upd_time = GetTickCount();
#else
    gettimeofday(&upd_time, NULL);
#endif
    start_time = create_timestamp();
    ws_info("Capture loop running.");
    capture_opts_log(LOG_DOMAIN_CAPCHILD, LOG_LEVEL_DEBUG, capture_opts);
    if (use_threads) {
        pcap_queue = g_async_queue_new();
        pcap_queue_bytes = 0;
        pcap_queue_packets = 0;
        for (i = 0; i < global_ld.pcaps->len; i++) {
            pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);
            pcap_src->tid = g_thread_new("Capture read", pcap_read_handler, pcap_src);
        }
    }
    while (global_ld.go) {
        if (use_threads) {
            gboolean dequeued = capture_loop_dequeue_packet();
            if (dequeued) {
                inpkts = 1;
            } else {
                inpkts = 0;
            }
        } else {
            pcap_src = g_array_index(global_ld.pcaps, capture_src *, 0);
            inpkts = capture_loop_dispatch(&global_ld, errmsg,
                                           sizeof(errmsg), pcap_src);
        }
        if (inpkts == 0) {
            gboolean open_interfaces = FALSE;
            for (i = 0; i < global_ld.pcaps->len; i++) {
                pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);
                if (pcap_src->cap_pipe_err == PIPOK) {
                    open_interfaces = TRUE;
                }
            }
            if (!open_interfaces) {
                global_ld.go = FALSE;
            }
        }
#ifdef SIGINFO
        if (global_ld.report_packet_count) {
            fprintf(stderr, "%u packet%s captured\n", global_ld.packets_captured,
                    plurality(global_ld.packets_captured, "", "s"));
            global_ld.report_packet_count = FALSE;
        }
#endif
#ifdef _WIN32
        if (!signal_pipe_check_running()) {
            global_ld.go = FALSE;
        }
#endif
        if (inpkts > 0) {
            if (capture_opts->output_to_pipe) {
                fflush(global_ld.pdh);
            }
        } 
#ifdef _WIN32
        cur_time = GetTickCount();  
        if ((cur_time - upd_time) > capture_opts->update_interval) 
#else
        gettimeofday(&cur_time, NULL);
        if (((guint64)cur_time.tv_sec * 1000000 + cur_time.tv_usec) >
            ((guint64)upd_time.tv_sec * 1000000 + upd_time.tv_usec + capture_opts->update_interval*1000))
#endif
        {
            upd_time = cur_time;
#if 0
            if (pcap_stats(pch, stats) >= 0) {
                *stats_known = TRUE;
            }
#endif
            if (global_ld.inpkts_to_sync_pipe) {
                fflush(global_ld.pdh);
                if (!quiet)
                    report_packet_count(global_ld.inpkts_to_sync_pipe);
                global_ld.inpkts_to_sync_pipe = 0;
            }
            if (autostop_duration_timer != NULL && g_timer_elapsed(autostop_duration_timer, NULL) >= capture_opts->autostop_duration) {
                global_ld.go = FALSE;
                continue;
            }
            if (global_ld.file_duration_timer != NULL && g_timer_elapsed(global_ld.file_duration_timer, NULL) >= capture_opts->file_duration) {
                if (!do_file_switch_or_stop(capture_opts))
                    continue;
            } 
            if (global_ld.interval_s && time(NULL) >= global_ld.next_interval_time) {
                if (!do_file_switch_or_stop(capture_opts))
                    continue;
            } 
        }
    }
    ws_info("Capture loop stopping ...");
    if (use_threads) {
        for (i = 0; i < global_ld.pcaps->len; i++) {
            pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);
            ws_info("Waiting for thread of interface %u...", pcap_src->interface_id);
            g_thread_join(pcap_src->tid);
            ws_info("Thread of interface %u terminated.", pcap_src->interface_id);
        }
        while (1) {
            gboolean dequeued = capture_loop_dequeue_packet();
            if (!dequeued) {
                break;
            }
            if (capture_opts->output_to_pipe) {
                fflush(global_ld.pdh);
            }
        }
    }
    if (global_ld.file_duration_timer != NULL)
        g_timer_destroy(global_ld.file_duration_timer);
    if (autostop_duration_timer != NULL)
        g_timer_destroy(autostop_duration_timer);
    for (i = 0; i < capture_opts->ifaces->len; i++) {
        pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);
        if (pcap_src->pcap_err) {
            char *cap_err_str;
            char *primary_msg;
            char *secondary_msg;
            interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);
            cap_err_str = pcap_geterr(pcap_src->pcap_h);
            if (strcmp(cap_err_str, "The interface went down") == 0 ||
                strcmp(cap_err_str, "recvfrom: Network is down") == 0) {
                primary_msg = ws_strdup_printf("The network adapter \"%s\" "
                                              "is no longer running; the "
                                              "capture has stopped.",
                                              interface_opts->display_name);
                secondary_msg = g_strdup("");
            } else if (strcmp(cap_err_str, "The interface disappeared") == 0 ||
                       strcmp(cap_err_str, "read: Device not configured") == 0 ||
                       strcmp(cap_err_str, "read: I/O error") == 0 ||
                       strcmp(cap_err_str, "read error: PacketReceivePacket failed") == 0) {
                primary_msg = ws_strdup_printf("The network adapter \"%s\" "
                                              "is no longer attached; the "
                                              "capture has stopped.",
                                              interface_opts->display_name);
                secondary_msg = g_strdup("");
            } else if (g_str_has_prefix(cap_err_str, "The interface disappeared ")) {
                primary_msg = ws_strdup_printf("The network adapter \"%s\" "
                                              "is no longer attached; the "
                                              "capture has stopped.",
                                              interface_opts->display_name);
	secondary_msg=((interface_opts->display_name+cap_err_str-1)/cap_err_str);
            } else if (g_str_has_prefix(cap_err_str, "PacketReceivePacket error:") &&
                       g_str_has_suffix(cap_err_str, "(1617)")) {
                primary_msg = ws_strdup_printf("The network adapter \"%s\" "
                                              "is no longer attached; the "
                                              "capture has stopped.",
                                              interface_opts->display_name);
                secondary_msg = handle_npcap_bug(interface_opts->display_name,
                                                 "The interface disappeared (error code ERROR_DEVICE_REMOVED/STATUS_DEVICE_REMOVED)");
            } else if (strcmp(cap_err_str, "The other host terminated the connection.") == 0 ||
                       g_str_has_prefix(cap_err_str, "Is the server properly installed?")) {
                primary_msg = g_strdup(cap_err_str);
                secondary_msg = g_strdup("This may be a problem with the "
                                         "remote host on which you are "
                                         "capturing packets.");
            } else {
                primary_msg = ws_strdup_printf("Error while capturing packets: %s",
                                              cap_err_str);
                secondary_msg = g_strdup(please_report_bug());
            }
            report_capture_error(primary_msg, secondary_msg);
            g_free(primary_msg);
            g_free(secondary_msg);
            break;
        } else if (pcap_src->from_cap_pipe && pcap_src->cap_pipe_err == PIPERR) {
            report_capture_error(errmsg, "");
            break;
        }
    }
    if (global_ld.err == 0) {
        write_ok = TRUE;
    } else {
        capture_loop_get_errmsg(errmsg, sizeof(errmsg), secondary_errmsg,
                                sizeof(secondary_errmsg),
                                capture_opts->save_file, global_ld.err, FALSE);
        report_capture_error(errmsg, secondary_errmsg);
        write_ok = FALSE;
    }
    if (capture_opts->saving_to_file) {
        close_ok = capture_loop_close_output(capture_opts, &global_ld, &err_close);
    } else
        close_ok = TRUE;
    if (global_ld.inpkts_to_sync_pipe) {
        if (!quiet)
            report_packet_count(global_ld.inpkts_to_sync_pipe);
        global_ld.inpkts_to_sync_pipe = 0;
    }
    if (!close_ok && write_ok) {
        capture_loop_get_errmsg(errmsg, sizeof(errmsg), secondary_errmsg,
                                sizeof(secondary_errmsg),
                                capture_opts->save_file, err_close, TRUE);
        report_capture_error(errmsg, secondary_errmsg);
    }
    report_capture_count(TRUE);
    for (i = 0; i < capture_opts->ifaces->len; i++) {
        guint32 received;
        guint32 pcap_dropped = 0;
        pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);
        interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);
        received = pcap_src->received;
        if (pcap_src->pcap_h != NULL) {
            ws_assert(!pcap_src->from_cap_pipe);
            if (pcap_stats(pcap_src->pcap_h, stats) >= 0) {
                *stats_known = TRUE;
                pcap_dropped += stats->ps_drop;
            } else {
                snprintf(errmsg, sizeof(errmsg),
                           "Can't get packet-drop statistics: %s",
                           pcap_geterr(pcap_src->pcap_h));
                report_capture_error(errmsg, please_report_bug());
            }
        }
        report_packet_drops(received, pcap_dropped, pcap_src->dropped, pcap_src->flushed, stats->ps_ifdrop, interface_opts->display_name);
    }
    capture_loop_close_input(&global_ld);
    ws_info("Capture loop stopped.");
    return write_ok && close_ok;
error:
    if (capture_opts->multi_files_on) {
        ringbuf_error_cleanup();
    } else {
        if (global_ld.save_file_fd != -1) {
            ws_close(global_ld.save_file_fd);
        }
        if (capture_opts->save_file != NULL) {
            ws_unlink(capture_opts->save_file);
        }
    }
    if (cfilter_error)
        report_cfilter_error(capture_opts, error_index, errmsg);
    else
        report_capture_error(errmsg, secondary_errmsg);
    capture_loop_close_input(&global_ld);
    ws_info("Capture loop stopped with error");
    return FALSE;
}
