static void fcp_response(struct fw_card *card, struct fw_request *request,
			 int tcode, int destination, int source,
			 int generation, unsigned int int offset,
			 void *data, size_t length, void *callback_data)
{
	struct fcp_transaction *t;
	unsigned int flags;
	if (length < 1 || (*(const unsigned char *)data & 0xf0) != CTS_AVC)
		return;
	spin_lock_irqsave(&transactions_lock, flags);
	list_for_each_entry(t, &transactions, list) {
		struct fw_device *device = fw_parent_device(t->unit);
		if (device->card != card ||
		    device->generation != generation)
			continue;
		smp_rmb(); 
		if (device->node_id != source)
			continue;
		if (t->state == STATE_PENDING &&
		    is_matching_response(t, data, length)) {
			if (t->deferrable && *(const unsigned char *)data == 0x0f) {
				t->state = STATE_DEFERRED;
			} else {
				t->state = STATE_COMPLETE;
				t->response_size = min_t(unsigned int, length,
							 t->response_size);
				memcpy(t->response_buffer, data,
				       t->response_size);
			}
		}
	}
	spin_unlock_irqrestore(&transactions_lock, flags);
}
