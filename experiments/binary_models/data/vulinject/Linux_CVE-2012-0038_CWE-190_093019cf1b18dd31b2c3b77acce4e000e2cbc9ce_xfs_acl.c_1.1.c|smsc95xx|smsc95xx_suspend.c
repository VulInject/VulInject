static int smsc95xx_suspend(struct usb_interface *intf, pm_message_t message)
{
	struct usbnet *dev = usb_get_intfdata(intf);
	struct smsc95xx_priv *pdata = dev->driver_priv;
	int val, link_up;
	int ret;
	pdata->pm_task = current;
	ret = usbnet_suspend(intf, message);
	if (ret < 0) {
		netdev_warn(dev->net, "usbnet_suspend error\n");
		pdata->pm_task = NULL;
		return ret;
	}
	if (pdata->suspend_flags) {
		netdev_warn(dev->net, "error during last resume\n");
		pdata->suspend_flags = 0;
	}
	link_up = smsc95xx_link_ok(dev);
	if (message.event == PM_EVENT_AUTO_SUSPEND &&
	    (pdata->features & FEATURE_REMOTE_WAKEUP)) {
		ret = smsc95xx_autosuspend(dev, link_up);
		goto done;
	}
	if (!(pdata->wolopts & SUPPORTED_WAKE) ||
		!(link_up || (pdata->wolopts & WAKE_PHY))) {
		netdev_info(dev->net, "entering SUSPEND2 mode\n");
		ret = smsc95xx_read_reg(dev, WUCSR, &val);
		if (ret < 0)
			goto done;
		val &= ~(WUCSR_MPEN_ | WUCSR_WAKE_EN_);
		ret = smsc95xx_write_reg(dev, WUCSR, val);
		if (ret < 0)
			goto done;
		ret = smsc95xx_read_reg(dev, PM_CTRL, &val);
		if (ret < 0)
			goto done;
		val &= ~(PM_CTL_ED_EN_ | PM_CTL_WOL_EN_);
		ret = smsc95xx_write_reg(dev, PM_CTRL, val);
		if (ret < 0)
			goto done;
		ret = smsc95xx_enter_suspend2(dev);
		goto done;
	}
	if (pdata->wolopts & WAKE_PHY) {
		if (!link_up) {
			netdev_info(dev->net, "entering SUSPEND1 mode\n");
			ret = smsc95xx_enter_suspend1(dev);
			goto done;
		}
	}
	if (pdata->wolopts & (WAKE_BCAST | WAKE_MCAST | WAKE_ARP | WAKE_UCAST)) {
		unsigned int *filter_mask = kcalloc(32, sizeof(unsigned int), GFP_KERNEL);
		unsigned int command[2];
		unsigned int offset[2];
		unsigned int crc[4];
		int wuff_filter_count =
			(pdata->features & FEATURE_8_WAKEUP_FILTERS) ?
			LAN9500A_WUFF_NUM : LAN9500_WUFF_NUM;
		int i, filter = 0;
		if (!filter_mask) {
			netdev_warn(dev->net, "Unable to allocate filter_mask\n");
			ret = -ENOMEM;
			goto done;
		}
		memset(command, 0, sizeof(command));
		memset(offset, 0, sizeof(offset));
		memset(crc, 0, sizeof(crc));
		if (pdata->wolopts & WAKE_BCAST) {
			const unsigned char bcast[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
			netdev_info(dev->net, "enabling broadcast detection\n");
			filter_mask[filter * 4] = 0x003F;
			filter_mask[filter * 4 + 1] = 0x00;
			filter_mask[filter * 4 + 2] = 0x00;
			filter_mask[filter * 4 + 3] = 0x00;
			command[filter/4] |= 0x05UL << ((filter % 4) * 8);
			offset[filter/4] |= 0x00 << ((filter % 4) * 8);
			crc[filter/2] |= smsc_crc(bcast, 6, filter);
			filter++;
		}
		if (pdata->wolopts & WAKE_MCAST) {
			const unsigned char mcast[] = {0x01, 0x00, 0x5E};
			netdev_info(dev->net, "enabling multicast detection\n");
			filter_mask[filter * 4] = 0x0007;
			filter_mask[filter * 4 + 1] = 0x00;
			filter_mask[filter * 4 + 2] = 0x00;
			filter_mask[filter * 4 + 3] = 0x00;
			command[filter/4] |= 0x09UL << ((filter % 4) * 8);
			offset[filter/4] |= 0x00  << ((filter % 4) * 8);
			crc[filter/2] |= smsc_crc(mcast, 3, filter);
			filter++;
		}
		if (pdata->wolopts & WAKE_ARP) {
			const unsigned char arp[] = {0x08, 0x06};
			netdev_info(dev->net, "enabling ARP detection\n");
			filter_mask[filter * 4] = 0x0003;
			filter_mask[filter * 4 + 1] = 0x00;
			filter_mask[filter * 4 + 2] = 0x00;
			filter_mask[filter * 4 + 3] = 0x00;
			command[filter/4] |= 0x05UL << ((filter % 4) * 8);
			offset[filter/4] |= 0x0C << ((filter % 4) * 8);
			crc[filter/2] |= smsc_crc(arp, 2, filter);
			filter++;
		}
		if (pdata->wolopts & WAKE_UCAST) {
			netdev_info(dev->net, "enabling unicast detection\n");
			filter_mask[filter * 4] = 0x003F;
			filter_mask[filter * 4 + 1] = 0x00;
			filter_mask[filter * 4 + 2] = 0x00;
			filter_mask[filter * 4 + 3] = 0x00;
			command[filter/4] |= 0x01UL << ((filter % 4) * 8);
			offset[filter/4] |= 0x00 << ((filter % 4) * 8);
			crc[filter/2] |= smsc_crc(dev->net->dev_addr, ETH_ALEN, filter);
			filter++;
		}
		for (i = 0; i < (wuff_filter_count * 4); i++) {
			ret = smsc95xx_write_reg(dev, WUFF, filter_mask[i]);
			if (ret < 0) {
				kfree(filter_mask);
				goto done;
			}
		}
		kfree(filter_mask);
		for (i = 0; i < (wuff_filter_count / 4); i++) {
			ret = smsc95xx_write_reg(dev, WUFF, command[i]);
			if (ret < 0)
				goto done;
		}
		for (i = 0; i < (wuff_filter_count / 4); i++) {
			ret = smsc95xx_write_reg(dev, WUFF, offset[i]);
			if (ret < 0)
				goto done;
		}
		for (i = 0; i < (wuff_filter_count / 2); i++) {
			ret = smsc95xx_write_reg(dev, WUFF, crc[i]);
			if (ret < 0)
				goto done;
		}
		ret = smsc95xx_read_reg(dev, WUCSR, &val);
		if (ret < 0)
			goto done;
		val |= WUCSR_WUFR_;
		ret = smsc95xx_write_reg(dev, WUCSR, val);
		if (ret < 0)
			goto done;
	}
	if (pdata->wolopts & WAKE_MAGIC) {
		ret = smsc95xx_read_reg(dev, WUCSR, &val);
		if (ret < 0)
			goto done;
		val |= WUCSR_MPR_;
		ret = smsc95xx_write_reg(dev, WUCSR, val);
		if (ret < 0)
			goto done;
	}
	ret = smsc95xx_read_reg(dev, WUCSR, &val);
	if (ret < 0)
		goto done;
	if (pdata->wolopts & (WAKE_BCAST | WAKE_MCAST | WAKE_ARP | WAKE_UCAST)) {
		netdev_info(dev->net, "enabling pattern match wakeup\n");
		val |= WUCSR_WAKE_EN_;
	} else {
		netdev_info(dev->net, "disabling pattern match wakeup\n");
		val &= ~WUCSR_WAKE_EN_;
	}
	if (pdata->wolopts & WAKE_MAGIC) {
		netdev_info(dev->net, "enabling magic packet wakeup\n");
		val |= WUCSR_MPEN_;
	} else {
		netdev_info(dev->net, "disabling magic packet wakeup\n");
		val &= ~WUCSR_MPEN_;
	}
	ret = smsc95xx_write_reg(dev, WUCSR, val);
	if (ret < 0)
		goto done;
	ret = smsc95xx_read_reg(dev, PM_CTRL, &val);
	if (ret < 0)
		goto done;
	val |= PM_CTL_WOL_EN_;
	if (pdata->wolopts & WAKE_PHY)
		val |= PM_CTL_ED_EN_;
	ret = smsc95xx_write_reg(dev, PM_CTRL, val);
	if (ret < 0)
		goto done;
	smsc95xx_start_rx_path(dev);
	netdev_info(dev->net, "entering SUSPEND0 mode\n");
	ret = smsc95xx_enter_suspend0(dev);
done:
	if (ret && PMSG_IS_AUTO(message))
		usbnet_resume(intf);
	pdata->pm_task = NULL;
	return ret;
}
