cfm_print(netdissect_options *ndo,
          const u_char *pptr, u_int length)
{
    const struct cfm_common_header_t *cfm_common_header;
    unsigned char mdlevel_version, opcode, flags, first_tlv_offset;
    const struct cfm_tlv_header_t *cfm_tlv_header;
    const unsigned char *tptr, *tlv_ptr;
    const unsigned char *namesp;
    u_int names_data_remaining;
    unsigned char md_nameformat, md_namelength;
    const unsigned char *md_name;
    unsigned char ma_nameformat, ma_namelength;
    const unsigned char *ma_name;
    u_int hexdump, tlen, cfm_tlv_len, cfm_tlv_type, ccm_interval;
    union {
        const struct cfm_ccm_t *cfm_ccm;
        const struct cfm_lbm_t *cfm_lbm;
        const struct cfm_ltm_t *cfm_ltm;
        const struct cfm_ltr_t *cfm_ltr;
    } msg_ptr;
    ndo->ndo_protocol = "cfm";
    tptr=pptr;
    cfm_common_header = (const struct cfm_common_header_t *)pptr;
    if (length < sizeof(*cfm_common_header))
        goto tooshort;
    ND_TCHECK_SIZE(cfm_common_header);
    mdlevel_version = GET_U_1(cfm_common_header->mdlevel_version);
    if (CFM_EXTRACT_VERSION(mdlevel_version) != CFM_VERSION) {
	ND_PRINT("CFMv%u not supported, length %u",
               CFM_EXTRACT_VERSION(mdlevel_version), length);
	return;
    }
    opcode = GET_U_1(cfm_common_header->opcode);
    ND_PRINT("CFMv%u %s, MD Level %u, length %u",
           CFM_EXTRACT_VERSION(mdlevel_version),
           tok2str(cfm_opcode_values, "unknown (%u)", opcode),
           CFM_EXTRACT_MD_LEVEL(mdlevel_version),
           length);
    if (ndo->ndo_vflag < 1) {
        return;
    }
    flags = GET_U_1(cfm_common_header->flags);
    first_tlv_offset = GET_U_1(cfm_common_header->first_tlv_offset);
    ND_PRINT("\n\tFirst TLV offset %u", first_tlv_offset);
    tptr += sizeof(struct cfm_common_header_t);
    tlen = length - sizeof(struct cfm_common_header_t);
    if (first_tlv_offset > tlen) {
        ND_PRINT(" (too large, must be <= %u)", tlen);
        return;
    }
    switch (opcode) {
    case CFM_OPCODE_CCM:
        msg_ptr.cfm_ccm = (const struct cfm_ccm_t *)tptr;
        if (first_tlv_offset < sizeof(*msg_ptr.cfm_ccm)) {
            ND_PRINT(" (too small 1, must be >= %zu)",
                     sizeof(*msg_ptr.cfm_ccm));
            return;
        }
        if (tlen < sizeof(*msg_ptr.cfm_ccm))
            goto tooshort;
        ND_TCHECK_SIZE(msg_ptr.cfm_ccm);
        ccm_interval = CFM_EXTRACT_CCM_INTERVAL(flags);
        ND_PRINT(", Flags [CCM Interval %u%s]",
               ccm_interval,
               flags & CFM_CCM_RDI_FLAG ?
               ", RDI" : "");
        if (ccm_interval) {
            ND_PRINT("\n\t  CCM Interval %.3fs"
                   ", min CCM Lifetime %.3fs, max CCM Lifetime %.3fs",
                   ccm_interval_base[ccm_interval],
                   ccm_interval_base[ccm_interval] * CCM_INTERVAL_MIN_MULTIPLIER,
                   ccm_interval_base[ccm_interval] * CCM_INTERVAL_MAX_MULTIPLIER);
        }
        ND_PRINT("\n\t  Sequence Number 0x%08x, MA-End-Point-ID 0x%04x",
               GET_BE_U_4(msg_ptr.cfm_ccm->sequence),
               GET_BE_U_2(msg_ptr.cfm_ccm->ma_epi));
        namesp = msg_ptr.cfm_ccm->names;
        names_data_remaining = sizeof(msg_ptr.cfm_ccm->names);
        md_nameformat = GET_U_1(namesp);
        namesp++;
        names_data_remaining--;  
        if (md_nameformat != CFM_CCM_MD_FORMAT_NONE) {
            md_namelength = GET_U_1(namesp);
            namesp++;
            names_data_remaining--; 
            ND_PRINT("\n\t  MD Name Format %s (%u), MD Name length %u",
                   tok2str(cfm_md_nameformat_values, "Unknown",
                           md_nameformat),
                   md_nameformat,
                   md_namelength);
            if (md_namelength > names_data_remaining - 3) {
                ND_PRINT(" (too large, must be <= %u)", names_data_remaining - 2);
                return;
            }
            md_name = namesp;
            ND_PRINT("\n\t  MD Name: ");
            switch (md_nameformat) {
            case CFM_CCM_MD_FORMAT_DNS:
            case CFM_CCM_MD_FORMAT_CHAR:
                nd_printjnp(ndo, md_name, md_namelength);
                break;
            case CFM_CCM_MD_FORMAT_MAC:
                if (md_namelength == MAC48_LEN) {
                    ND_PRINT("\n\t  MAC %s", GET_MAC48_STRING(md_name));
                } else {
                    ND_PRINT("\n\t  MAC (length invalid)");
                }
                break;
            case CFM_CCM_MA_FORMAT_8021:
            default:
                print_unknown_data(ndo, md_name, "\n\t    ",
                                   md_namelength);
            }
            namesp += md_namelength;
            names_data_remaining -= md_namelength;
        } else {
            ND_PRINT("\n\t  MD Name Format %s (%u)",
                   tok2str(cfm_md_nameformat_values, "Unknown",
                           md_nameformat),
                   md_nameformat);
        }
        ma_nameformat = GET_U_1(namesp);
        namesp++;
        names_data_remaining--; 
        ma_namelength = GET_U_1(namesp);
        namesp++;
        names_data_remaining--; 
        ND_PRINT("\n\t  MA Name-Format %s (%u), MA name length %u",
               tok2str(cfm_ma_nameformat_values, "Unknown",
                       ma_nameformat),
               ma_nameformat,
               ma_namelength);
        if (ma_namelength > names_data_remaining) {
            ND_PRINT(" (too large, must be <= %u)", names_data_remaining);
            return;
        }
        ma_name = namesp;
        ND_PRINT("\n\t  MA Name: ");
        switch (ma_nameformat) {
        case CFM_CCM_MA_FORMAT_CHAR:
            nd_printjnp(ndo, ma_name, ma_namelength);
            break;
        case CFM_CCM_MA_FORMAT_8021:
        case CFM_CCM_MA_FORMAT_VID:
        case CFM_CCM_MA_FORMAT_INT:
        case CFM_CCM_MA_FORMAT_VPN:
        default:
            print_unknown_data(ndo, ma_name, "\n\t    ", ma_namelength);
        }
        break;
    case CFM_OPCODE_LTM:
        msg_ptr.cfm_ltm = (const struct cfm_ltm_t *)tptr;
        if (first_tlv_offset < sizeof(*msg_ptr.cfm_ltm)) {
            ND_PRINT(" (too small 4, must be >= %zu)",
                     sizeof(*msg_ptr.cfm_ltm));
            return;
        }
        if (tlen < sizeof(*msg_ptr.cfm_ltm))
            goto tooshort;
        ND_TCHECK_SIZE(msg_ptr.cfm_ltm);
        ND_PRINT(", Flags [%s]",
               bittok2str(cfm_ltm_flag_values, "none", flags));
        ND_PRINT("\n\t  Transaction-ID 0x%08x, ttl %u",
               GET_BE_U_4(msg_ptr.cfm_ltm->transaction_id),
               GET_U_1(msg_ptr.cfm_ltm->ttl));
        ND_PRINT("\n\t  Original-MAC %s, Target-MAC %s",
               GET_MAC48_STRING(msg_ptr.cfm_ltm->original_mac),
               GET_MAC48_STRING(msg_ptr.cfm_ltm->target_mac));
        break;
    case CFM_OPCODE_LTR:
        msg_ptr.cfm_ltr = (const struct cfm_ltr_t *)tptr;
        if (first_tlv_offset < sizeof(*msg_ptr.cfm_ltr)) {
            ND_PRINT(" (too small 5, must be >= %zu)",
                     sizeof(*msg_ptr.cfm_ltr));
            return;
        }
        if (tlen < sizeof(*msg_ptr.cfm_ltr))
            goto tooshort;
        ND_TCHECK_SIZE(msg_ptr.cfm_ltr);
        ND_PRINT(", Flags [%s]",
               bittok2str(cfm_ltr_flag_values, "none", flags));
        ND_PRINT("\n\t  Transaction-ID 0x%08x, ttl %u",
               GET_BE_U_4(msg_ptr.cfm_ltr->transaction_id),
               GET_U_1(msg_ptr.cfm_ltr->ttl));
        ND_PRINT("\n\t  Replay-Action %s (%u)",
               tok2str(cfm_ltr_replay_action_values,
                       "Unknown",
                       GET_U_1(msg_ptr.cfm_ltr->replay_action)),
               GET_U_1(msg_ptr.cfm_ltr->replay_action));
        break;
    case CFM_OPCODE_LBR:
    case CFM_OPCODE_LBM:
    default:
        print_unknown_data(ndo, tptr, "\n\t  ",
                           tlen -  first_tlv_offset);
        break;
    }
    tptr += first_tlv_offset;
    tlen -= first_tlv_offset;
    while (tlen != 0) {
        cfm_tlv_header = (const struct cfm_tlv_header_t *)tptr;
        cfm_tlv_type = GET_U_1(cfm_tlv_header->type);
        ND_PRINT("\n\t%s TLV (0x%02x)",
               tok2str(cfm_tlv_values, "Unknown", cfm_tlv_type),
               cfm_tlv_type);
        if (cfm_tlv_type == CFM_TLV_END) {
            return;
        }
        if (tlen < sizeof(struct cfm_tlv_header_t))
            goto tooshort;
        ND_TCHECK_LEN(tptr, sizeof(struct cfm_tlv_header_t));
        cfm_tlv_len=GET_BE_U_2(cfm_tlv_header->length);
        ND_PRINT(", length %u", cfm_tlv_len);
        tptr += sizeof(struct cfm_tlv_header_t);
        tlen -= sizeof(struct cfm_tlv_header_t);
        tlv_ptr = tptr;
        if (tlen < cfm_tlv_len)
            goto tooshort;
        hexdump = FALSE;
        switch(cfm_tlv_type) {
        case CFM_TLV_PORT_STATUS:
            if (cfm_tlv_len < 1) {
                ND_PRINT(" (too short, must be >= 1)");
                return;
            }
            ND_PRINT(", Status: %s (%u)",
                   tok2str(cfm_tlv_port_status_values, "Unknown", GET_U_1(tptr)),
                   GET_U_1(tptr));
            break;
        case CFM_TLV_INTERFACE_STATUS:
            if (cfm_tlv_len < 1) {
                ND_PRINT(" (too short, must be >= 1)");
                return;
            }
            ND_PRINT(", Status: %s (%u)",
                   tok2str(cfm_tlv_interface_status_values, "Unknown", GET_U_1(tptr)),
                   GET_U_1(tptr));
            break;
        case CFM_TLV_PRIVATE:
            if (cfm_tlv_len < 4) {
                ND_PRINT(" (too short, must be >= 4)");
                return;
            }
            ND_PRINT(", Vendor: %s (%u), Sub-Type %u",
                   tok2str(oui_values,"Unknown", GET_BE_U_3(tptr)),
                   GET_BE_U_3(tptr),
                   GET_U_1(tptr + 3));
            hexdump = TRUE;
            break;
        case CFM_TLV_SENDER_ID:
        {
            u_int chassis_id_type, chassis_id_length;
            u_int mgmt_addr_length;
            if (cfm_tlv_len < 1) {
                ND_PRINT(" (too short, must be >= 1)");
                goto next_tlv;
            }
            chassis_id_length = GET_U_1(tptr);
            tptr++;
            tlen--;
            cfm_tlv_len--;
            if (chassis_id_length) {
                if (cfm_tlv_len < 1) {
                    ND_PRINT("\n\t  (TLV too short)");
                    goto next_tlv;
                }
                chassis_id_type = GET_U_1(tptr);
                cfm_tlv_len--;
                ND_PRINT("\n\t  Chassis-ID Type %s (%u), Chassis-ID length %u",
                       tok2str(cfm_tlv_senderid_chassisid_values,
                               "Unknown",
                               chassis_id_type),
                       chassis_id_type,
                       chassis_id_length);
                if (cfm_tlv_len < chassis_id_length) {
                    ND_PRINT("\n\t  (TLV too short)");
                    goto next_tlv;
                }
                switch (chassis_id_type) {
                case CFM_CHASSIS_ID_MAC_ADDRESS:
                    if (chassis_id_length != MAC48_LEN) {
                        ND_PRINT(" (invalid MAC address length)");
                        hexdump = TRUE;
                        break;
                    }
                    ND_PRINT("\n\t  MAC %s", GET_MAC48_STRING(tptr + 1));
                    break;
                case CFM_CHASSIS_ID_NETWORK_ADDRESS:
                    hexdump |= cfm_network_addr_print(ndo, tptr + 1, chassis_id_length);
                    break;
                case CFM_CHASSIS_ID_INTERFACE_NAME: 
                case CFM_CHASSIS_ID_INTERFACE_ALIAS:
                case CFM_CHASSIS_ID_LOCAL:
                case CFM_CHASSIS_ID_CHASSIS_COMPONENT:
                case CFM_CHASSIS_ID_PORT_COMPONENT:
                    nd_printjnp(ndo, tptr + 1, chassis_id_length);
                    break;
                default:
                    hexdump = TRUE;
                    break;
                }
                cfm_tlv_len -= chassis_id_length;
                tptr += 1 + chassis_id_length;
                tlen -= 1 + chassis_id_length;
            }
            if (cfm_tlv_len == 0) {
                break;
            }
            mgmt_addr_length = GET_U_1(tptr);
            tptr++;
            tlen--;
            cfm_tlv_len--;
            ND_PRINT("\n\t  Management Address Domain Length %u", mgmt_addr_length);
            if (mgmt_addr_length) {
                if (cfm_tlv_len < mgmt_addr_length) {
                    ND_PRINT("\n\t  (TLV too short)");
                    goto next_tlv;
                }
                cfm_tlv_len -= mgmt_addr_length;
                hex_print(ndo, "\n\t  Management Address Domain: ", tptr, mgmt_addr_length);
                tptr += mgmt_addr_length;
                tlen -= mgmt_addr_length;
                if (cfm_tlv_len < 1) {
                    ND_PRINT(" (Management Address Length is missing)");
                    hexdump = TRUE;
                    break;
                }
                mgmt_addr_length = GET_U_1(tptr);
                tptr++;
                tlen--;
                cfm_tlv_len--;
                ND_PRINT("\n\t  Management Address Length %u", mgmt_addr_length);
                if (mgmt_addr_length) {
                    if (cfm_tlv_len < mgmt_addr_length) {
                        ND_PRINT("\n\t  (TLV too short)");
                        return;
                    }
                    cfm_tlv_len -= mgmt_addr_length;
                    hex_print(ndo, "\n\t  Management Address: ", tptr, mgmt_addr_length);
                    tptr += mgmt_addr_length;
                    tlen -= mgmt_addr_length;
                }
            }
            break;
        }
        case CFM_TLV_DATA:
        case CFM_TLV_REPLY_INGRESS:
        case CFM_TLV_REPLY_EGRESS:
        default:
            hexdump = TRUE;
            break;
        }
        if (hexdump || ndo->ndo_vflag > 1)
            print_unknown_data(ndo, tlv_ptr, "\n\t  ", cfm_tlv_len);
next_tlv:
        tptr+=cfm_tlv_len;
        tlen-=cfm_tlv_len;
    }
    return;
tooshort:
    ND_PRINT("\n\t\t packet is too short");
    return;
trunc:
    nd_print_trunc(ndo);
}
