dissect_socks(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data) {
    int                 offset     = 0;
    proto_tree         *socks_tree = NULL;
    proto_item         *ti;
    socks_hash_entry_t *hash_info;
    conversation_t     *conversation;
    sock_state_t*       state_info;
    guint8              version;
    struct tcpinfo     *tcpinfo    = (struct tcpinfo*)data;
    state_info = (sock_state_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_socks, 0);
    if (state_info == NULL) {
        state_info = wmem_new(wmem_file_scope(), sock_state_t);
        state_info->in_socks_dissector_flag = 0;
        state_info->client = clientNoInit;
        state_info->server = serverNoInit;
        p_add_proto_data(wmem_file_scope(), pinfo, proto_socks, 0, state_info);
    }
    if (state_info->in_socks_dissector_flag)
        return 0;
    conversation = find_conversation_pinfo(pinfo, 0);
    if (conversation == NULL) {
        version = tvb_get_guint8(tvb, offset);
        if ((version != 4) && (version != 5))
            return 0;
        conversation = conversation_new(pinfo->num, &pinfo->src, &pinfo->dst,
                                        conversation_pt_to_conversation_type(pinfo->ptype), pinfo->srcport, pinfo->destport, 0);
    }
    hash_info = (socks_hash_entry_t *)conversation_get_proto_data(conversation,proto_socks);
    if (hash_info == NULL){
        hash_info = wmem_new0(wmem_file_scope(), socks_hash_entry_t);
        hash_info->start_done_frame = G_MAXINT;
        hash_info->clientState = clientStart;
        hash_info->serverState = serverStart;
        hash_info->server_port = pinfo->destport;
        hash_info->port = 0;
        hash_info->version = tvb_get_guint8(tvb, offset); 
        conversation_add_proto_data(conversation, proto_socks, hash_info);
        if (conversation_get_dissector(conversation, pinfo->num) != NULL) {
            conversation_set_dissector(conversation, socks_handle);
        }
    }
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "Socks");
    if (( hash_info->version == 4) || ( hash_info->version == 5)){
        col_add_fstr(pinfo->cinfo, COL_INFO, "Version: %d",
            hash_info->version);
    }
    else            
        col_set_str(pinfo->cinfo, COL_INFO, "Unknown");
    if ( hash_info->command == PING_COMMAND)
        col_append_str(pinfo->cinfo, COL_INFO, ", Ping Req");
    if ( hash_info->command == TRACERT_COMMAND)
        col_append_str(pinfo->cinfo, COL_INFO, ", Traceroute Req");
    if ((!pinfo->fd->visited) &&
        (!((hash_info->clientState == clientDone) &&
           (hash_info->serverState == serverDone)))) {
        if (hash_info->server_port == pinfo->destport) {
            if ((hash_info->clientState != clientError) &&
                (hash_info->clientState != clientDone))
            {
                if ( hash_info->version == 4) {
                    state_machine_v4( hash_info, tvb, offset, pinfo);
                } else if ( hash_info->version == 5) {
                    client_state_machine_v5( hash_info, tvb, offset, pinfo, TRUE);
                }
            }
        } else {
            if ((hash_info->serverState != serverError) &&
                (hash_info->serverState != serverDone)) {
                if ( hash_info->version == 4) {
                    state_machine_v4( hash_info, tvb, offset, pinfo);
                } else if ( hash_info->version == 5) {
                    server_state_machine_v5( hash_info, tvb, offset, pinfo, TRUE);
                }
            }
        }
        if ((hash_info->clientState == clientDone) &&
            (hash_info->serverState == serverDone)) {   
            hash_info->start_done_frame = pinfo->num;
        }
    }
    if (tree) {
        ti = proto_tree_add_item( tree, proto_socks, tvb, offset, -1, ENC_NA );
        socks_tree = proto_item_add_subtree(ti, ett_socks);
        if ( pinfo->num > hash_info->start_done_frame){
            ti = proto_tree_add_uint( socks_tree, hf_socks_ver, tvb, offset, 0, hash_info->version);
            ti = proto_tree_add_uint( socks_tree, hf_socks_cmd, tvb, offset, 0, hash_info->command);
            proto_item_set_generated(ti);
            if (hash_info->dst_addr.type == AT_IPv4) {
                ti = proto_tree_add_ipv4( socks_tree, hf_socks_ip_dst, tvb,
                    offset, 0, *((const guint32*)hash_info->dst_addr.data));
                proto_item_set_generated(ti);
            } else if (hash_info->dst_addr.type == AT_IPv6) {
                ti = proto_tree_add_ipv6( socks_tree, hf_socks_ip6_dst, tvb,
                    offset, 0, (const ws_in6_addr *)hash_info->dst_addr.data);
                proto_item_set_generated(ti);
            }
            if (( hash_info->command != PING_COMMAND) &&
                ( hash_info->command != TRACERT_COMMAND)){
                ti = proto_tree_add_uint( socks_tree, hf_socks_dstport, tvb, offset, 0, hash_info->port);
                proto_item_set_generated(ti);
            }
        } else {
            if (hash_info->server_port == pinfo->destport) {
                if ( hash_info->version == 4) {
                    display_socks_v4(tvb, offset, pinfo, socks_tree, hash_info, state_info);
                } else if ( hash_info->version == 5) {
                    client_display_socks_v5(tvb, offset, pinfo, socks_tree, hash_info, state_info);
                }
            } else {
                if ( hash_info->version == 4) {
                    display_socks_v4(tvb, offset, pinfo, socks_tree, hash_info, state_info);
                } else if ( hash_info->version == 5) {
                    server_display_socks_v5(tvb, offset, pinfo, socks_tree, hash_info, state_info);
                }
            }
        }
    }
    if ( pinfo->num > hash_info->start_done_frame){
        call_next_dissector(tvb, offset, pinfo, tree, socks_tree,
            hash_info, state_info, tcpinfo);
    }
    return tvb_reported_length(tvb);
}
