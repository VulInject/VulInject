static char *bf_ftoa_internal(size_t *plen, const bf_t *a2, int radix,
                              limb_t prec, bf_flags_t flags, BOOL is_dec)
{
    bf_context_t *ctx = a2->ctx;
    DynBuf s_s, *s = &s_s;
    int radix_bits;
    dbuf_init2(s, ctx, bf_dbuf_realloc);
    if (a2->expn == BF_EXP_NAN) {
        dbuf_putstr(s, "NaN");
    } else {
        if (a2->sign)
            dbuf_putc(s, '-');
        if (a2->expn == BF_EXP_INF) {
            if (flags & BF_FTOA_JS_QUIRKS)
                dbuf_putstr(s, "Infinity");
            else
                dbuf_putstr(s, "Inf");
        } else {
            int fmt, ret;
            slimb_t n_digits, n, i, n_max, n1;
            bf_t a1_s, *a1 = &a1_s;
            if ((radix & (radix - 1)) != 0)
                radix_bits = 0;
            else
                radix_bits = ceil_log2(radix);
            fmt = flags & BF_FTOA_FORMAT_MASK;
            if (fmt == BF_FTOA_FORMAT_FRAC) {
                if (is_dec || radix_bits != 0) {
                    if (bf_set(a1, a2))
                        goto fail1;
#ifdef USE_BF_DEC
                    if (is_dec) {
                        if (bfdec_round((bfdec_t *)a1, prec, (flags & BF_RND_MASK) | BF_FLAG_RADPNT_PREC) & BF_ST_MEM_ERROR)
                            goto fail1;
                        n = a1->expn;
                    } else
#endif
                    {
                        if (bf_round(a1, prec * radix_bits, (flags & BF_RND_MASK) | BF_FLAG_RADPNT_PREC) & BF_ST_MEM_ERROR)
                            goto fail1;
                        n = ceil_div(a1->expn, radix_bits);
                    }
                    if (flags & BF_FTOA_ADD_PREFIX) {
                        if (radix == 16)
                            dbuf_putstr(s, "0x");
                        else if (radix == 8)
                            dbuf_putstr(s, "0o");
                        else if (radix == 2)
                            dbuf_putstr(s, "0b");
                    }
                    if (a1->expn == BF_EXP_ZERO) {
                        dbuf_putstr(s, "0");
                        if (prec > 0) {
                            dbuf_putstr(s, ".");
                            for(i = 0; i < prec; i++) {
                                dbuf_putc(s, '0');
                            }
                        }
                    } else {
                        n_digits = prec + n;
                        if (n <= 0) {
                            dbuf_putstr(s, "0.");
                            for(i = 0; i < -n; i++) {
                                dbuf_putc(s, '0');
                            }
                            if (n_digits > 0) {
                                output_digits(s, a1, radix, n_digits, n_digits, is_dec);
                            }
                        } else {
                            output_digits(s, a1, radix, n_digits, n, is_dec);
                        }
                    }
                } else {
                    size_t pos, start;
                    bf_t a_s, *a = &a_s;
                    a->tab = a2->tab;
                    a->len = a2->len;
                    a->expn = a2->expn;
                    a->sign = 0;
                    n = 1 + bf_mul_log2_radix(bf_max(a->expn, 0), radix, TRUE, TRUE);
                    n_digits = n + prec;
                    n1 = n;
                    if (bf_convert_to_radix(a1, &n1, a, radix, n_digits,
                                            flags & BF_RND_MASK, TRUE))
                        goto fail1;
                    start = s->size;
                    output_digits(s, a1, radix, n_digits, n, is_dec);
                    pos = start;
                    while ((pos + 1) < s->size && s->buf[pos] == '0' &&
                           s->buf[pos + 1] != '.')
                        pos++;
                    if (pos > start) {
                        memmove(s->buf + start, s->buf + pos, s->size - pos);
                        s->size -= (pos - start);
                    }
                }
            } else {
#ifdef USE_BF_DEC
                if (is_dec) {
                    if (bf_set(a1, a2))
                        goto fail1;
                    if (fmt == BF_FTOA_FORMAT_FIXED) {
                        n_digits = prec;
                        n_max = n_digits;
                        if (bfdec_round((bfdec_t *)a1, prec, (flags & BF_RND_MASK)) & BF_ST_MEM_ERROR)
                            goto fail1;
                    } else {
                        prec = n_digits = a1->len * LIMB_DIGITS;
                        while (n_digits > 1 &&
                               get_digit(a1->tab, a1->len, prec - n_digits) == 0) {
                            n_digits--;
                        }
                        n_max = n_digits + 4;
                    }
                    n = a1->expn;
                } else
#endif
                if (radix_bits != 0) {
                    if (bf_set(a1, a2))
                        goto fail1;
                    if (fmt == BF_FTOA_FORMAT_FIXED) {
                        slimb_t prec_bits;
                        n_digits = prec;
                        n_max = n_digits;
                        prec_bits = prec * radix_bits -
                            smod(-a1->expn, radix_bits);
                        if (bf_round(a1, prec_bits,
                                     (flags & BF_RND_MASK)) & BF_ST_MEM_ERROR)
                            goto fail1;
                    } else {
                        limb_t digit_mask;
                        slimb_t pos;
                        pos = a1->len * LIMB_BITS +
                            smod(-a1->expn, radix_bits);
                        n_digits = ceil_div(pos, radix_bits);
                        digit_mask = ((limb_t)1 << radix_bits) - 1;
                        while (n_digits > 1 &&
                               (get_bits(a1->tab, a1->len, pos - n_digits * radix_bits) & digit_mask) == 0) {
                            n_digits--;
                        }
                        n_max = n_digits + 4;
                    }
                    n = ceil_div(a1->expn, radix_bits);
                } else {
                    bf_t a_s, *a = &a_s;
                    a->tab = a2->tab;
                    a->len = a2->len;
                    a->expn = a2->expn;
                    a->sign = 0;
                    if (fmt == BF_FTOA_FORMAT_FIXED) {
                        n_digits = prec;
                        n_max = n_digits;
                    } else {
                        slimb_t n_digits_max, n_digits_min;
                        assert(prec != BF_PREC_INF);
                        n_digits = 1 + bf_mul_log2_radix(prec, radix, TRUE, TRUE);
                        n_max = n_digits + 4;
                        if (fmt == BF_FTOA_FORMAT_FREE_MIN) {
                            bf_t b_s, *b = &b_s;
                            n_digits_max = n_digits;
                            n_digits_min = 1;
                            bf_init(ctx, b);
                            while (n_digits_min < n_digits_max) {
                                n_digits = (n_digits_min + n_digits_max) / 2;
                                if (bf_convert_to_radix(a1, &n, a, radix, n_digits,
                                                        flags & BF_RND_MASK, FALSE)) {
                                    bf_delete(b);
                                    goto fail1;
                                }
                                ret = bf_mul_pow_radix(b, a1, radix, n - n_digits,
                                                       prec,
                                                       (flags & ~BF_RND_MASK) |
                                                       BF_RNDN);
                                if (ret & BF_ST_MEM_ERROR) {
                                    bf_delete(b);
                                    goto fail1;
                                }
                                if (bf_cmpu(b, a) == 0) {
                                    n_digits_max = n_digits;
                                } else {
                                    n_digits_min = n_digits + 1;
                                }
                            }
                            bf_delete(b);
                            n_digits = n_digits_max;
                        }
                    }
                    if (bf_convert_to_radix(a1, &n, a, radix, n_digits,
                                            flags & BF_RND_MASK, FALSE)) {
                    fail1:
                        bf_delete(a1);
                        goto fail;
                    }
                }
                if (a1->expn == BF_EXP_ZERO &&
                    fmt != BF_FTOA_FORMAT_FIXED &&
                    !(flags & BF_FTOA_FORCE_EXP)) {
                    dbuf_putstr(s, "0");
                } else {
                    if (flags & BF_FTOA_ADD_PREFIX) {
                        if (radix == 16)
                            dbuf_putstr(s, "0x");
                        else if (radix == 8)
                            dbuf_putstr(s, "0o");
                        else if (radix == 2)
                            dbuf_putstr(s, "0b");
                    }
                    if (a1->expn == BF_EXP_ZERO)
                        n = 1;
                    if ((flags & BF_FTOA_FORCE_EXP) ||
                        n <= -6 || n > n_max) {
                        const char *fmt;
                        output_digits(s, a1, radix, n_digits, 1, is_dec);
                        if (radix_bits != 0 && radix <= 16) {
                            if (flags & BF_FTOA_JS_QUIRKS)
                                fmt = "p%+" PRId_LIMB;
                            else
                                fmt = "p%" PRId_LIMB;
                            dbuf_printf(s, fmt, (n - 1) * radix_bits);
                        } else {
                            if (flags & BF_FTOA_JS_QUIRKS)
                                fmt = "%c%+" PRId_LIMB;
                            else
                                fmt = "%c%" PRId_LIMB;
                            dbuf_printf(s, fmt,
                                        radix <= 10 ? 'e' : '@', n - 1);
                        }
                    } else if (n <= 0) {
                        dbuf_putstr(s, "0.");
                        for(i = 0; i < -n; i++) {
                            dbuf_putc(s, '0');
                        }
                        output_digits(s, a1, radix, n_digits, n_digits, is_dec);
                    } else {
                        if (n_digits <= n) {
                            output_digits(s, a1, radix, n_digits, n_digits, is_dec);
                            for(i = 0; i < (n - n_digits); i++)
                                dbuf_putc(s, '0');
                        } else {
                            output_digits(s, a1, radix, n_digits, n, is_dec);
                        }
                    }
                }
            }
            bf_delete(a1);
        }
    }
    dbuf_putc(s, '\0');
    if (dbuf_error(s))
        goto fail;
    if (plen)
        *plen = s->size - 1;
    return (char *)s->buf;
 fail:
    bf_free(ctx, s->buf);
    if (plen)
        *plen = 0;
    return NULL;
}
