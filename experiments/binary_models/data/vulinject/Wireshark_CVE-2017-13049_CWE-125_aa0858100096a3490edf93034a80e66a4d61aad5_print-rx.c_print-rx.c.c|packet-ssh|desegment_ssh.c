desegment_ssh(tvbuff_t *tvb, packet_info *pinfo, unsigned int seq,
        unsigned int nxtseq, proto_tree *tree, ssh_channel_info_t *channel)
{
    fragment_head *ipfd_head;
    gboolean       must_desegment;
    gboolean       called_dissector;
    int            another_pdu_follows;
    gboolean       another_segment_in_frame = FALSE;
    int            deseg_offset, offset = 0;
    guint32        deseg_seq;
    gint           nbytes;
    proto_item    *item;
    struct tcp_multisegment_pdu *msp;
    gboolean       first_pdu = TRUE;
again:
    ipfd_head = NULL;
    must_desegment = FALSE;
    called_dissector = FALSE;
    another_pdu_follows = 0;
    msp = NULL;
    pinfo->desegment_offset = 0;
    pinfo->desegment_len = 0;
    deseg_offset = offset;
    if ((msp = (struct tcp_multisegment_pdu *)wmem_tree_lookup32(channel->multisegment_pdus, seq))) {
        const char *prefix;
        gboolean is_retransmission = FALSE;
        if (msp->first_frame == pinfo->num) {
            prefix = "";
            if (msp->last_frame == pinfo->num) {
                col_clear(pinfo->cinfo, COL_INFO);
            } else {
                if (first_pdu) {
                    col_append_sep_str(pinfo->cinfo, COL_INFO, " ", "[SSH segment of a reassembled PDU]");
                }
            }
        } else {
            prefix = "Retransmitted ";
            is_retransmission = TRUE;
        }
        if (!is_retransmission) {
            ipfd_head = fragment_get(&ssh_reassembly_table, pinfo, msp->first_frame, msp);
            if (ipfd_head != NULL && ipfd_head->reassembled_in !=0 &&
                ipfd_head->reassembled_in != pinfo->num) {
                item=proto_tree_add_uint(tree, *ssh_segment_items.hf_reassembled_in,
                                         tvb, 0, 0, ipfd_head->reassembled_in);
            }
        }
        nbytes = tvb_reported_length_remaining(tvb, offset);
        ssh_proto_tree_add_segment_data(tree, tvb, offset, nbytes, prefix);
        return;
    }
    msp = (struct tcp_multisegment_pdu *)wmem_tree_lookup32_le(channel->multisegment_pdus, seq-1);
    if (msp && msp->seq <= seq && msp->nxtpdu > seq) {
        int len;
        if (!PINFO_FD_VISITED(pinfo)) {
            msp->last_frame = pinfo->num;
            msp->last_frame_time = pinfo->abs_ts;
        }
        if (msp->flags & MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT) {
            len = MAX(0, tvb_reported_length_remaining(tvb, offset));
        } else {
            len = MIN(nxtseq, msp->nxtpdu) - seq;
        }
        ipfd_head = fragment_add(&ssh_reassembly_table, tvb, offset,
                                 pinfo, ssh_msp_fragment_id(msp), msp,
                                 seq - msp->seq,
                                 len, (LT_SEQ (nxtseq,msp->nxtpdu)));
        if (!PINFO_FD_VISITED(pinfo)
        && msp->flags & MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT) {
            msp->flags &= (~MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT);
            msp->nxtpdu = nxtseq;
        }
        if ( (msp->nxtpdu < nxtseq)
        &&  (msp->nxtpdu >= seq)
        &&  (len > 0)) {
            another_pdu_follows = msp->nxtpdu - seq;
        }
    } else {
        ssh_process_payload(tvb, offset, pinfo, tree, channel);
        called_dissector = TRUE;
        if (pinfo->desegment_len) {
            if (!PINFO_FD_VISITED(pinfo))
                must_desegment = TRUE;
            deseg_offset = offset + pinfo->desegment_offset;
        }
        ipfd_head = NULL;
    }
    if (ipfd_head && ipfd_head->reassembled_in == pinfo->num) {
        if (nxtseq < msp->nxtpdu) {
            another_pdu_follows = 0;
            col_clear(pinfo->cinfo, COL_INFO);
            another_segment_in_frame = TRUE;
        } else {
            tvbuff_t *next_tvb;
            int old_len;
            col_clear(pinfo->cinfo, COL_INFO);
            next_tvb = tvb_new_chain(tvb, ipfd_head->tvb_data);
            add_new_data_source(pinfo, next_tvb, "Reassembled SSH");
            ssh_process_payload(next_tvb, 0, pinfo, tree, channel);
            called_dissector = TRUE;
            old_len = (int)(tvb_reported_length(next_tvb) - tvb_reported_length_remaining(tvb, offset));
            if (pinfo->desegment_len && pinfo->desegment_offset <= old_len) {
                fragment_set_partial_reassembly(&ssh_reassembly_table,
                                                pinfo, ssh_msp_fragment_id(msp), msp);
                if (pinfo->desegment_len == DESEGMENT_ONE_MORE_SEGMENT) {
                    msp->nxtpdu = seq + tvb_reported_length_remaining(tvb, offset) + 1;
                    msp->flags |= MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT;
                } else if (pinfo->desegment_len == DESEGMENT_UNTIL_FIN) {
                    channel->flags |= TCP_FLOW_REASSEMBLE_UNTIL_FIN;
                    msp->nxtpdu = nxtseq + 0x40000000;
                } else {
                    msp->nxtpdu = seq + tvb_reported_length_remaining(tvb, offset) + pinfo->desegment_len;
                }
                another_pdu_follows = 0;
            } else {
                nbytes = another_pdu_follows > 0
                    ? another_pdu_follows
                    : tvb_reported_length_remaining(tvb, offset);
                ssh_proto_tree_add_segment_data(tree, tvb, offset, nbytes, NULL);
                print_ssh_fragment_tree(ipfd_head, proto_tree_get_root(tree), tree, pinfo, next_tvb);
                if (pinfo->desegment_len) {
                    if (!PINFO_FD_VISITED(pinfo))
                        must_desegment = TRUE;
                    deseg_offset = ipfd_head->datalen - pinfo->desegment_offset;
                    deseg_offset = tvb_reported_length(tvb) - deseg_offset;
                }
            }
        }
    }
    if (must_desegment) {
        if (pinfo->desegment_len == DESEGMENT_UNTIL_FIN) {
            channel->flags |= TCP_FLOW_REASSEMBLE_UNTIL_FIN;
        }
        deseg_seq = seq + (deseg_offset - offset);
        if (((nxtseq - deseg_seq) <= 1024*1024)
            &&  (!PINFO_FD_VISITED(pinfo))) {
            if (pinfo->desegment_len == DESEGMENT_ONE_MORE_SEGMENT) {
                msp = pdu_store_sequencenumber_of_next_pdu(pinfo,
                    deseg_seq, nxtseq+1, channel->multisegment_pdus);
                msp->flags |= MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT;
            } else if (pinfo->desegment_len == DESEGMENT_UNTIL_FIN) {
                msp = pdu_store_sequencenumber_of_next_pdu(pinfo,
                    deseg_seq, nxtseq+0x40000000, channel->multisegment_pdus);
            } else {
                msp = pdu_store_sequencenumber_of_next_pdu(pinfo,
                    deseg_seq, nxtseq+pinfo->desegment_len, channel->multisegment_pdus);
            }
            fragment_add(&ssh_reassembly_table, tvb, deseg_offset,
                         pinfo, ssh_msp_fragment_id(msp), msp,
                         0, nxtseq - deseg_seq,
                         LT_SEQ(nxtseq, msp->nxtpdu));
        }
    }
    if (!called_dissector || pinfo->desegment_len != 0) {
        if (ipfd_head != NULL && ipfd_head->reassembled_in != 0 &&
            ipfd_head->reassembled_in != pinfo->num &&
            !(ipfd_head->flags & FD_PARTIAL_REASSEMBLY)) {
            item=proto_tree_add_uint(tree, *ssh_segment_items.hf_reassembled_in,
                                     tvb, 0, 0, ipfd_head->reassembled_in);
            proto_item_set_generated(item);
        }
        if (!another_segment_in_frame && pinfo->desegment_offset == 0) {
            if (first_pdu) {
                col_append_sep_str(pinfo->cinfo, COL_INFO, " ", "[SSH segment of a reassembled PDU]");
            }
        }
        nbytes = tvb_reported_length_remaining(tvb, deseg_offset);
        ssh_proto_tree_add_segment_data(tree, tvb, deseg_offset, nbytes, NULL);
    }
    pinfo->can_desegment = 0;
    pinfo->desegment_offset = 0;
    pinfo->desegment_len = 0;
    if (another_pdu_follows) {
        pinfo->can_desegment=2;
        col_set_fence(pinfo->cinfo, COL_INFO);
        col_set_writable(pinfo->cinfo, COL_PROTOCOL, FALSE);
        first_pdu = FALSE;
        offset += another_pdu_follows;
        seq += another_pdu_follows;
        goto again;
    }
}
