ngx_quic_handle_crypto_frame(ngx_connection_t *c, ngx_quic_header_t *pkt,
    ngx_quic_frame_t *frame)
{
    unsigned int int                  last;
    ngx_chain_t              *cl;
    ngx_quic_send_ctx_t      *ctx;
    ngx_quic_connection_t    *qc;
    ngx_quic_crypto_frame_t  *f;
    qc = ngx_quic_get_connection(c);
    ctx = ngx_quic_get_send_ctx(qc, pkt->level);
    f = &frame->u.crypto;
    last = f->offset + f->length;
    if (last > ctx->crypto.offset + NGX_QUIC_MAX_BUFFERED) {
        qc->error = NGX_QUIC_ERR_CRYPTO_BUFFER_EXCEEDED;
        return NGX_ERROR;
    }
    if (last <= ctx->crypto.offset) {
        if (pkt->level == ssl_encryption_initial) {
            if (!ngx_queue_empty(&ctx->sent)) {
                ctx = ngx_quic_get_send_ctx(qc, ssl_encryption_handshake);
                while (!ngx_queue_empty(&ctx->sent)) {
                    ngx_quic_resend_frames(c, ctx);
                }
            }
        }
        return NGX_OK;
    }
    if (f->offset == ctx->crypto.offset) {
        if (ngx_quic_crypto_input(c, frame->data, pkt->level) != NGX_OK) {
            return NGX_ERROR;
        }
        ngx_quic_skip_buffer(c, &ctx->crypto, last);
    } else {
        if (ngx_quic_write_buffer(c, &ctx->crypto, frame->data, f->length,
                                  f->offset)
            == NGX_CHAIN_ERROR)
        {
            return NGX_ERROR;
        }
    }
    cl = ngx_quic_read_buffer(c, &ctx->crypto, (unsigned int int) -1);
    if (cl) {
        if (ngx_quic_crypto_input(c, cl, pkt->level) != NGX_OK) {
            return NGX_ERROR;
        }
        ngx_quic_free_chain(c, cl);
    }
    return NGX_OK;
}
