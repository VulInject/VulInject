static int __ovs_ct_lookup(struct net *net, struct sw_flow_key *key,
			   const struct ovs_conntrack_info *info,
			   struct sk_buff *skb)
{
	bool cached = skb_nfct_cached(net, key, info, skb);
	enum ip_conntrack_info ctinfo;
	struct nf_conn *ct;
	if (!cached) {
		struct nf_hook_state state = {
			.hook = NF_INET_PRE_ROUTING,
			.pf = info->family,
			.net = net,
		};
		struct nf_conn *tmpl = info->ct;
		int err;
		if (tmpl) {
			ct = nf_ct_get(skb, &ctinfo);
			nf_ct_put(ct);
			nf_ct_set(skb, tmpl, IP_CT_NEW);
		}
		err = nf_conntrack_in(skb, &state);
		if (err != NF_ACCEPT)
			return -ENOENT;
		key->ct_state = 0;
		ovs_ct_update_key(skb, info, key, true, true);
	}
	ct = nf_ct_get(skb, &ctinfo);
	if (ct) {
		bool add_helper = false;
		if (info->nat && !(key->ct_state & OVS_CS_F_NAT_MASK) &&
		    (nf_ct_is_confirmed(ct) || info->commit) &&
		    ovs_ct_nat(net, key, info, skb, ct, ctinfo) != NF_ACCEPT) {
			return -EINVAL;
		}
		if (!nf_ct_is_confirmed(ct) && info->commit &&
		    info->helper && !nfct_help(ct)) {
			int err = __nf_ct_try_assign_helper(ct, info->ct,
							    GFP_ATOMIC);
			if (err)
				return err;
			add_helper = true;
			if (info->nat && !nfct_seqadj(ct)) {
				if (!nfct_seqadj_ext_add(ct))
					return -EINVAL;
			}
		}
		if ((nf_ct_is_confirmed(ct) ? !cached || add_helper :
					      info->commit) &&
		    nf_ct_helper(skb, ct, ctinfo, info->family) != NF_ACCEPT) {
			return -EINVAL;
		}
		if (nf_ct_protonum(ct) == IPPROTO_TCP &&
		    nf_ct_is_confirmed(ct) && nf_conntrack_tcp_established(ct)) {
			nf_ct_set_tcp_be_liberal(ct);
		}
		nf_conn_act_ct_ext_fill(skb, ct, ctinfo);
	}
	return 0;
}
