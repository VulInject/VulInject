static inline void next_nomacro1(TCCState *s1) {
	int t, c, is_long;
	TokenSym *ts;
	unsigned char *p1;
	unsigned int h;
	unsigned char *p = s1->file->buf_ptr;
redo_no_start:
	c = *p;
	switch (c) {
	case ' ':
	case '\t':
		s1->tok = c;
		p++;
		goto keep_tok_flags;
	case '\f':
	case '\v':
	case '\r':
		p++;
		goto redo_no_start;
	case '\\':
		if (p >= s1->file->buf_end) {
			s1->file->buf_ptr = p;
			p = s1->file->buf_ptr;
			if (p >= s1->file->buf_end) {
				goto parse_eof;
			} else {
				goto redo_no_start;
			}
		} else {
			s1->file->buf_ptr = p;
			s1->ch = *p;
			handle_stray (s1);
			p = s1->file->buf_ptr;
			goto redo_no_start;
		}
parse_eof:
		{
			if ((s1->parse_flags & PARSE_FLAG_LINEFEED)
			    && !(s1->tok_flags & TOK_FLAG_EOF)) {
				s1->tok_flags |= TOK_FLAG_EOF;
				s1->tok = TOK_LINEFEED;
				goto keep_tok_flags;
			} else if (!(s1->parse_flags & PARSE_FLAG_PREPROCESS)) {
				s1->tok = TOK_EOF;
			} else if (s1->ifdef_stack_ptr != s1->file->ifdef_stack_ptr) {
				tcc_error (s1, "missing #endif");
			} else if (s1->include_stack_ptr == s1->include_stack) {
				s1->tok = TOK_EOF;
			} else {
				s1->tok_flags &= ~TOK_FLAG_EOF;
				if (s1->tok_flags & TOK_FLAG_ENDIF) {
#ifdef INC_DEBUG
					printf ("#endif %s\n", get_tok_str (s1, s1->file->ifndef_macro_saved, NULL));
#endif
					add_cached_include (s1, s1->file->filename, s1->file->ifndef_macro_saved);
					s1->tok_flags &= ~TOK_FLAG_ENDIF;
				}
				tcc_close (s1);
				s1->include_stack_ptr--;
				p = s1->file->buf_ptr;
				goto redo_no_start;
			}
		}
		break;
	case '\n':
		s1->file->line_num++;
		s1->tok_flags |= TOK_FLAG_BOL;
		p++;
maybe_newline:
		if (0 == (s1->parse_flags & PARSE_FLAG_LINEFEED)) {
			goto redo_no_start;
		}
		s1->tok = TOK_LINEFEED;
		goto keep_tok_flags;
	case '#':
		PEEKC (s1, c, p);
		if ((s1->tok_flags & TOK_FLAG_BOL) &&
		    (s1->parse_flags & PARSE_FLAG_PREPROCESS)) {
			s1->file->buf_ptr = p;
			preprocess (s1, s1->tok_flags & TOK_FLAG_BOF);
			p = s1->file->buf_ptr;
			goto maybe_newline;
		} else {
			if (c == '#') {
				p++;
				s1->tok = TOK_TWOSHARPS;
			} else {
				if (s1->parse_flags & PARSE_FLAG_ASM_COMMENTS) {
					p = parse_line_comment (s1, p - 1);
					goto redo_no_start;
				}
				s1->tok = '#';
			}
		}
		break;
	case 'a': case 'b': case 'c': case 'd':
	case 'e': case 'f': case 'g': case 'h':
	case 'i': case 'j': case 'k': case 'l':
	case 'm': case 'n': case 'o': case 'p':
	case 'q': case 'r': case 's': case 't':
	case 'u': case 'v': case 'w': case 'x':
	case 'y': case 'z':
	case 'A': case 'B': case 'C': case 'D':
	case 'E': case 'F': case 'G': case 'H':
	case 'I': case 'J': case 'K':
	case 'M': case 'N': case 'O': case 'P':
	case 'Q': case 'R': case 'S': case 'T':
	case 'U': case 'V': case 'W': case 'X':
	case 'Y': case 'Z':
	case '_': case '.':
parse_ident_fast:
		p1 = p;
		h = TOK_HASH_INIT;
		h = TOK_HASH_FUNC (h, c);
		p++;
		for (;;) {
			c = *p;
			if (!s1->isidnum_table[*p - CH_EOF]) {
				break;
			}
			if (isdot (c)) {
				PEEKC (s1, c, p);
				if (isnum (c)) {
					cstr_reset (&s1->tokcstr);
					cstr_ccat (&s1->tokcstr, '.');
					goto parse_num;
				} else if (isdot (c)) {
					goto parse_dots;
				}
			}
			h = TOK_HASH_FUNC (h, *p);
			p++;
		}
		if (c != '\\') {
			TokenSym **pts;
			int len;
			len = p - p1;
			h &= (TOK_HASH_SIZE - 1);
			pts = &s1->hash_ident[h];
			for (;;) {
				ts = *pts;
				if (!ts) {
					break;
				}
				if (ts->len == len && !memcmp (ts->str, p1, len)) {
					goto token_found;
				}
				pts = &(ts->hash_next);
			}
			ts = tok_alloc_new (s1, pts, (const char *) p1, len);
token_found:
			;
		} else {
			cstr_reset (&s1->tokcstr);
			while (p1 < p) {
				cstr_ccat (&s1->tokcstr, *p1);
				p1++;
			}
			p--;
			PEEKC (s1, c, p);
parse_ident_slow:
			while (s1->isidnum_table[((c > 255)? 255: c) - CH_EOF]) {
				cstr_ccat (&s1->tokcstr, c);
				PEEKC (s1, c, p);
			}
			ts = tok_alloc (s1, s1->tokcstr.data, s1->tokcstr.size);
		}
		s1->tok = ts->tok;
		break;
	case 'L':
		t = p[1];
		if (t != '\\' && t != '\'' && t != '\"') {
			goto parse_ident_fast;
		} else {
			PEEKC (s1, c, p);
			if (c == '\'' || c == '\"') {
				is_long = 1;
				goto str_const;
			} else {
				cstr_reset (&s1->tokcstr);
				cstr_ccat (&s1->tokcstr, 'L');
				goto parse_ident_slow;
			}
		}
		break;
	case '0': case '1': case '2': case '3':
	case '4': case '5': case '6': case '7':
	case '8': case '9':
		cstr_reset (&s1->tokcstr);
parse_num:
		for (;;) {
			t = c;
			cstr_ccat (&s1->tokcstr, c);
			PEEKC (s1, c, p);
			if (!(isnum (c) || isid (c) || isdot (c) ||
			      ((c == '+' || c == '-') &&
			       (t == 'e' || t == 'E' || t == 'p' || t == 'P')))) {
				break;
			}
		}
		cstr_ccat (&s1->tokcstr, '\0');
		s1->tokc.cstr = &s1->tokcstr;
		s1->tok = TOK_PPNUM;
		break;
parse_dots:
		if (!isdot (c)) {
			expect (s1, "'.'");
			return;
		}
		PEEKC (s1, c, p);
		s1->tok = TOK_DOTS;
		break;
	case '\'':
	case '\"':
		is_long = 0;
str_const:
		{
			CString str;
			int sep;
			sep = c;
			cstr_new (&str);
			p = parse_pp_string (s1, p, sep, &str);
			if (!p) {
				return;
			}
			cstr_ccat (&str, '\0');
			cstr_reset (&s1->tokcstr);
			parse_escape_string (s1, &s1->tokcstr, (const ut8 *)str.data, is_long);
			cstr_free (&str);
			if (sep == '\'') {
				int char_size;
				if (!is_long) {
					char_size = 1;
				} else {
					char_size = sizeof (nwchar_t);
				}
				if (s1->tokcstr.size <= char_size) {
					tcc_error (s1, "empty character constant");
				}
				if (s1->tokcstr.size > 2 * char_size) {
					tcc_warning (s1, "multi-character character constant");
				}
				if (!is_long) {
					s1->tokc.i = *(char *) s1->tokcstr.data;
					s1->tok = TOK_CCHAR;
				} else {
					s1->tokc.i = *(nwchar_t *) s1->tokcstr.data;
					s1->tok = TOK_LCHAR;
				}
			} else {
				s1->tokc.cstr = &s1->tokcstr;
				if (!is_long) {
					s1->tok = TOK_STR;
				} else {
					s1->tok = TOK_LSTR;
				}
			}
		}
		break;
	case '<':
		PEEKC (s1, c, p);
		if (c == '=') {
			p++;
			s1->tok = TOK_LE;
		} else if (c == '<') {
			PEEKC (s1, c, p);
			if (c == '=') {
				p++;
				s1->tok = TOK_A_SHL;
			} else {
				s1->tok = TOK_SHL;
			}
		} else {
			s1->tok = TOK_LT;
		}
		break;
	case '>':
		PEEKC (s1, c, p);
		if (c == '=') {
			p++;
			s1->tok = TOK_GE;
		} else if (c == '>') {
			PEEKC (s1, c, p);
			if (c == '=') {
				p++;
				s1->tok = TOK_A_SAR;
			} else {
				s1->tok = TOK_SAR;
			}
		} else {
			s1->tok = TOK_GT;
		}
		break;
	case '&':
		PEEKC (s1, c, p);
		if (c == '&') {
			p++;
			s1->tok = TOK_LAND;
		} else if (c == '=') {
			p++;
			s1->tok = TOK_A_AND;
		} else {
			s1->tok = '&';
		}
		break;
	case '|':
		PEEKC (s1, c, p);
		if (c == '|') {
			p++;
			s1->tok = TOK_LOR;
		} else if (c == '=') {
			p++;
			s1->tok = TOK_A_OR;
		} else {
			s1->tok = '|';
		}
		break;
	case '+':
		PEEKC (s1, c, p);
		if (c == '+') {
			p++;
			s1->tok = TOK_INC;
		} else if (c == '=') {
			p++;
			s1->tok = TOK_A_ADD;
		} else {
			s1->tok = '+';
		}
		break;
	case '-':
		PEEKC (s1, c, p);
		if (c == '-') {
			p++;
			s1->tok = TOK_DEC;
		} else if (c == '=') {
			p++;
			s1->tok = TOK_A_SUB;
		} else if (c == '>') {
			p++;
			s1->tok = TOK_ARROW;
		} else {
			s1->tok = '-';
		}
		break;
		PARSE2 ('!', '!', '=', TOK_NE)
		PARSE2 ('=', '=', '=', TOK_EQ)
		PARSE2 ('*', '*', '=', TOK_A_MUL)
		PARSE2 ('%', '%', '=', TOK_A_MOD)
		PARSE2 ('^', '^', '=', TOK_A_XOR)
	case '/':
		PEEKC (s1, c, p);
		if (c == '*') {
			p = parse_comment (s1, p);
			s1->tok = ' ';
			goto keep_tok_flags;
		} else if (c == '/') {
			p = parse_line_comment (s1, p);
			s1->tok = ' ';
			goto keep_tok_flags;
		} else if (c == '=') {
			p++;
			s1->tok = TOK_A_DIV;
		} else {
			s1->tok = '/';
		}
		break;
	case '(':
	case ')':
	case '[':
	case ']':
	case '{':
	case '}':
	case ',':
	case ';':
	case ':':
	case '?':
	case '~':
	case '$':	
	case '@':	
		s1->tok = c;
		p++;
		break;
	default:
		tcc_error (s1, "unrecognized character \\x%02x", c);
		break;
	}
	s1->tok_flags = 0;
keep_tok_flags:
	s1->file->buf_ptr = p;
#if defined(PARSE_DEBUG)
	printf ("token = %s\n", get_tok_str (s1, s1->tok, &s1->tokc));
#endif
}
