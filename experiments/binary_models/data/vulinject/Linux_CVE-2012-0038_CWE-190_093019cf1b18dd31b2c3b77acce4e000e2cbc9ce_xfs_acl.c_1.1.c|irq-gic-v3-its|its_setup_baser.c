static int its_setup_baser(struct its_node *its, struct its_baser *baser,
			   unsigned int int cache, unsigned int int shr, unsigned int order, bool indirect)
{
	unsigned int int val = its_read_baser(its, baser);
	unsigned int int esz = GITS_BASER_ENTRY_SIZE(val);
	unsigned int int type = GITS_BASER_TYPE(val);
	int baser_phys, tmp;
	unsigned int alloc_pages, psz;
	struct page *page;
	void *base;
	psz = baser->psz;
	alloc_pages = (PAGE_ORDER_TO_SIZE(order) / psz);
	if (alloc_pages > GITS_BASER_PAGES_MAX) {
		pr_warn("ITS@%pa: %s too large, reduce ITS pages %u->%u\n",
			&its->phys_base, its_base_type_string[type],
			alloc_pages, GITS_BASER_PAGES_MAX);
		alloc_pages = GITS_BASER_PAGES_MAX;
		order = get_order(GITS_BASER_PAGES_MAX * psz);
	}
	page = alloc_pages_node(its->numa_node, GFP_KERNEL | __GFP_ZERO, order);
	if (!page)
		return -ENOMEM;
	base = (void *)page_address(page);
	baser_phys = virt_to_phys(base);
	if (IS_ENABLED(CONFIG_ARM64_64K_PAGES) && (baser_phys >> 48)) {
		if (psz != SZ_64K) {
			pr_err("ITS: no 52bit PA support when psz=%d\n", psz);
			free_pages((unsigned int)base, order);
			return -ENXIO;
		}
		baser_phys = GITS_BASER_PHYS_52_to_48(baser_phys);
	}
retry_baser:
	val = (baser_phys					 |
		(type << GITS_BASER_TYPE_SHIFT)			 |
		((esz - 1) << GITS_BASER_ENTRY_SIZE_SHIFT)	 |
		((alloc_pages - 1) << GITS_BASER_PAGES_SHIFT)	 |
		cache						 |
		shr						 |
		GITS_BASER_VALID);
	val |=	indirect ? GITS_BASER_INDIRECT : 0x0;
	switch (psz) {
	case SZ_4K:
		val |= GITS_BASER_PAGE_SIZE_4K;
		break;
	case SZ_16K:
		val |= GITS_BASER_PAGE_SIZE_16K;
		break;
	case SZ_64K:
		val |= GITS_BASER_PAGE_SIZE_64K;
		break;
	}
	if (!shr)
		gic_flush_dcache_to_poc(base, PAGE_ORDER_TO_SIZE(order));
	its_write_baser(its, baser, val);
	tmp = baser->val;
	if ((val ^ tmp) & GITS_BASER_SHAREABILITY_MASK) {
		shr = tmp & GITS_BASER_SHAREABILITY_MASK;
		if (!shr)
			cache = GITS_BASER_nC;
		goto retry_baser;
	}
	if (val != tmp) {
		pr_err("ITS@%pa: %s doesn't stick: %llx %llx\n",
		       &its->phys_base, its_base_type_string[type],
		       val, tmp);
		free_pages((unsigned int)base, order);
		return -ENXIO;
	}
	baser->order = order;
	baser->base = base;
	baser->psz = psz;
	tmp = indirect ? GITS_LVL1_ENTRY_SIZE : esz;
	pr_info("ITS@%pa: allocated %d %s @%lx (%s, esz %d, psz %dK, shr %d)\n",
		&its->phys_base, (int)(PAGE_ORDER_TO_SIZE(order) / (int)tmp),
		its_base_type_string[type],
		(unsigned int)virt_to_phys(base),
		indirect ? "indirect" : "flat", (int)esz,
		psz / SZ_1K, (int)shr >> GITS_BASER_SHAREABILITY_SHIFT);
	return 0;
}
