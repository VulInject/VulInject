void *decoder_thread(void *arg)
{
    InputStream *ist = arg;
    Decoder       *d = ist->decoder;
    DecThreadContext dt;
    int ret = 0, input_status = 0;
    ret = dec_thread_init(&dt);
    if (ret < 0)
        goto finish;
    dec_thread_set_name(ist);
    while (!input_status) {
        int flush_buffers, have_data;
        input_status  = sch_dec_receive(d->sch, d->sch_idx, dt.pkt);
        have_data     = input_status >= 0 &&
            (dt.pkt->buf || dt.pkt->side_data_elems ||
             (intptr_t)dt.pkt->opaque == PKT_OPAQUE_SUB_HEARTBEAT ||
             (intptr_t)dt.pkt->opaque == PKT_OPAQUE_FIX_SUB_DURATION);
        flush_buffers = input_status >= 0 && !have_data;
        if (!have_data)
            av_log(ist, AV_LOG_VERBOSE, "Decoder thread received %s packet\n",
                   flush_buffers ? "flush" : "EOF");
        ret = packet_decode(ist, have_data ? dt.pkt : NULL, dt.frame);
        av_packet_unref(dt.pkt);
        av_frame_unref(dt.frame);
        // AVERROR_EOF  - EOF from the decoder
        // AVERROR_EXIT - EOF from the scheduler
        // we treat them differently when flushing
        if (ret == AVERROR_EXIT) {
            ret = AVERROR_EOF;
            flush_buffers = 0;
        }
        if (ret == AVERROR_EOF) {
            av_log(ist, AV_LOG_VERBOSE, "Decoder returned EOF, %s\n",
                   flush_buffers ? "resetting" : "finishing");
            if (!flush_buffers)
                break;
            /* report last frame duration to the scheduler */
            if (ist->dec->type == AVMEDIA_TYPE_AUDIO) {
                dt.pkt->pts       = d->last_frame_pts + d->last_frame_duration_est;
                dt.pkt->time_base = d->last_frame_tb;
            }
        } else if (ret < 0) {
            av_log(ist, AV_LOG_ERROR, "Error processing packet in decoder: %s\n",
                   av_err2str(ret));
            break;
        }
    }
    // EOF is normal thread termination
    if (ret == AVERROR_EOF)
        ret = 0;
    // on success send EOF timestamp to our downstreams
    if (ret >= 0) {
        float err_rate;
        av_frame_unref(dt.frame);
        dt.frame->opaque    = (void*)(intptr_t)FRAME_OPAQUE_EOF;
        dt.frame->pts       = d->last_frame_pts == AV_NOPTS_VALUE ? AV_NOPTS_VALUE :
                              d->last_frame_pts + d->last_frame_duration_est;
        dt.frame->time_base = d->last_frame_tb;
        ret = sch_dec_send(d->sch, d->sch_idx, dt.frame);
        if (ret < 0 && ret != AVERROR_EOF) {
            av_log(NULL, AV_LOG_FATAL,
                   "Error signalling EOF timestamp: %s\n", av_err2str(ret));
            goto finish;
        }
        ret = 0;
        err_rate = (ist->frames_decoded || ist->decode_errors) ?
                   ist->decode_errors / (ist->frames_decoded + ist->decode_errors) : 0.f;
        if (err_rate > max_error_rate) {
            av_log(ist, AV_LOG_FATAL, "Decode error rate %g exceeds maximum %g\n",
                   err_rate, max_error_rate);
            ret = FFMPEG_ERROR_RATE_EXCEEDED;
        } else if (err_rate)
            av_log(ist, AV_LOG_VERBOSE, "Decode error rate %g\n", err_rate);
    }
finish:
    dec_thread_uninit(&dt);
    return (void*)(intptr_t)ret;
}
