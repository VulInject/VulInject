static int bnxt_rx_pkt(struct bnxt *bp, struct bnxt_cp_ring_info *cpr,
		       unsigned int *raw_cons, unsigned char *event)
{
	struct bnxt_napi *bnapi = cpr->bnapi;
	struct bnxt_rx_ring_info *rxr = bnapi->rx_ring;
	struct net_device *dev = bp->dev;
	struct rx_cmp *rxcmp;
	struct rx_cmp_ext *rxcmp1;
	unsigned int tmp_raw_cons = *raw_cons;
	unsigned short cons, prod, cp_cons = RING_CMP(tmp_raw_cons);
	struct bnxt_sw_rx_bd *rx_buf;
	unsigned int len;
	unsigned char *data_ptr, agg_bufs, cmp_type;
	bool xdp_active = false;
	dma_addr_t dma_addr;
	struct sk_buff *skb;
	struct xdp_buff xdp;
	unsigned int flags, misc;
	unsigned int cmpl_ts;
	void *data;
	int rc = 0;
	rxcmp = (struct rx_cmp *)
			&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];
	cmp_type = RX_CMP_TYPE(rxcmp);
	if (cmp_type == CMP_TYPE_RX_TPA_AGG_CMP) {
		bnxt_tpa_agg(bp, rxr, (struct rx_agg_cmp *)rxcmp);
		goto next_rx_no_prod_no_len;
	}
	tmp_raw_cons = NEXT_RAW_CMP(tmp_raw_cons);
	cp_cons = RING_CMP(tmp_raw_cons);
	rxcmp1 = (struct rx_cmp_ext *)
			&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];
	if (!RX_CMP_VALID(rxcmp1, tmp_raw_cons))
		return -EBUSY;
	dma_rmb();
	prod = rxr->rx_prod;
	if (cmp_type == CMP_TYPE_RX_L2_TPA_START_CMP ||
	    cmp_type == CMP_TYPE_RX_L2_TPA_START_V3_CMP) {
		bnxt_tpa_start(bp, rxr, cmp_type,
			       (struct rx_tpa_start_cmp *)rxcmp,
			       (struct rx_tpa_start_cmp_ext *)rxcmp1);
		*event |= BNXT_RX_EVENT;
		goto next_rx_no_prod_no_len;
	} else if (cmp_type == CMP_TYPE_RX_L2_TPA_END_CMP) {
		skb = bnxt_tpa_end(bp, cpr, &tmp_raw_cons,
				   (struct rx_tpa_end_cmp *)rxcmp,
				   (struct rx_tpa_end_cmp_ext *)rxcmp1, event);
		if (IS_ERR(skb))
			return -EBUSY;
		rc = -ENOMEM;
		if (likely(skb)) {
			bnxt_deliver_skb(bp, bnapi, skb);
			rc = 1;
		}
		*event |= BNXT_RX_EVENT;
		goto next_rx_no_prod_no_len;
	}
	cons = rxcmp->rx_cmp_opaque;
	if (unlikely(cons != rxr->rx_next_cons)) {
		int rc1 = bnxt_discard_rx(bp, cpr, &tmp_raw_cons, rxcmp);
		if (rxr->rx_next_cons != 0xffff)
			netdev_warn(bp->dev, "RX cons %x != expected cons %x\n",
				    cons, rxr->rx_next_cons);
		if (rc1)
			return rc1;
		goto next_rx_no_prod_no_len;
	}
	rx_buf = &rxr->rx_buf_ring[cons];
	data = rx_buf->data;
	data_ptr = rx_buf->data_ptr;
	prefetch(data_ptr);
	misc = le32_to_cpu(rxcmp->rx_cmp_misc_v1);
	agg_bufs = (misc & RX_CMP_AGG_BUFS) >> RX_CMP_AGG_BUFS_SHIFT;
	if (agg_bufs) {
		if (!bnxt_agg_bufs_valid(bp, cpr, agg_bufs, &tmp_raw_cons))
			return -EBUSY;
		cp_cons = NEXT_CMP(cp_cons);
		*event |= BNXT_AGG_EVENT;
	}
	*event |= BNXT_RX_EVENT;
	rx_buf->data = NULL;
	if (rxcmp1->rx_cmp_cfa_code_errors_v2 & RX_CMP_L2_ERRORS) {
		unsigned int rx_err = le32_to_cpu(rxcmp1->rx_cmp_cfa_code_errors_v2);
		bnxt_reuse_rx_data(rxr, cons, data);
		if (agg_bufs)
			bnxt_reuse_rx_agg_bufs(cpr, cp_cons, 0, agg_bufs,
					       false);
		rc = -EIO;
		if (rx_err & RX_CMPL_ERRORS_BUFFER_ERROR_MASK) {
			bnapi->cp_ring.sw_stats->rx.rx_buf_errors++;
			if (!(bp->flags & BNXT_FLAG_CHIP_P5_PLUS) &&
			    !(bp->fw_cap & BNXT_FW_CAP_RING_MONITOR)) {
				netdev_warn_once(bp->dev, "RX buffer error %x\n",
						 rx_err);
				bnxt_sched_reset_rxr(bp, rxr);
			}
		}
		goto next_rx_no_len;
	}
	flags = le32_to_cpu(rxcmp->rx_cmp_len_flags_type);
	len = flags >> RX_CMP_LEN_SHIFT;
	dma_addr = rx_buf->mapping;
	if (bnxt_xdp_attached(bp, rxr)) {
		bnxt_xdp_buff_init(bp, rxr, cons, data_ptr, len, &xdp);
		if (agg_bufs) {
			unsigned int frag_len = bnxt_rx_agg_pages_xdp(bp, cpr, &xdp,
							     cp_cons, agg_bufs,
							     false);
			if (!frag_len)
				goto oom_next_rx;
		}
		xdp_active = true;
	}
	if (xdp_active) {
		if (bnxt_rx_xdp(bp, rxr, cons, &xdp, data, &data_ptr, &len, event)) {
			rc = 1;
			goto next_rx;
		}
	}
	if (len <= bp->rx_copy_thresh) {
		if (!xdp_active)
			skb = bnxt_copy_skb(bnapi, data_ptr, len, dma_addr);
		else
			skb = bnxt_copy_xdp(bnapi, &xdp, len, dma_addr);
		bnxt_reuse_rx_data(rxr, cons, data);
		if (!skb) {
			if (agg_bufs) {
				if (!xdp_active)
					bnxt_reuse_rx_agg_bufs(cpr, cp_cons, 0,
							       agg_bufs, false);
				else
					bnxt_xdp_buff_frags_free(rxr, &xdp);
			}
			goto oom_next_rx;
		}
	} else {
		unsigned int payload;
		if (rx_buf->data_ptr == data_ptr)
			payload = misc & RX_CMP_PAYLOAD_OFFSET;
		else
			payload = 0;
		skb = bp->rx_skb_func(bp, rxr, cons, data, data_ptr, dma_addr,
				      payload | len);
		if (!skb)
			goto oom_next_rx;
	}
	if (agg_bufs) {
		if (!xdp_active) {
			skb = bnxt_rx_agg_pages_skb(bp, cpr, skb, cp_cons, agg_bufs, false);
			if (!skb)
				goto oom_next_rx;
		} else {
			skb = bnxt_xdp_build_skb(bp, skb, agg_bufs, rxr->page_pool, &xdp, rxcmp1);
			if (!skb) {
				bnxt_xdp_buff_frags_free(rxr, &xdp);
				goto oom_next_rx;
			}
		}
	}
	if (RX_CMP_HASH_VALID(rxcmp)) {
		enum pkt_hash_types type;
		if (cmp_type == CMP_TYPE_RX_L2_V3_CMP) {
			type = bnxt_rss_ext_op(bp, rxcmp);
		} else {
			unsigned int hash_type = RX_CMP_HASH_TYPE(rxcmp);
			if (hash_type != 1 && hash_type != 3)
				type = PKT_HASH_TYPE_L3;
			else
				type = PKT_HASH_TYPE_L4;
		}
		skb_set_hash(skb, le32_to_cpu(rxcmp->rx_cmp_rss_hash), type);
	}
	if (cmp_type == CMP_TYPE_RX_L2_CMP)
		dev = bnxt_get_pkt_dev(bp, RX_CMP_CFA_CODE(rxcmp1));
	skb->protocol = eth_type_trans(skb, dev);
	if (skb->dev->features & BNXT_HW_FEATURE_VLAN_ALL_RX) {
		skb = bnxt_rx_vlan(skb, cmp_type, rxcmp, rxcmp1);
		if (!skb)
			goto next_rx;
	}
	skb_checksum_none_assert(skb);
	if (RX_CMP_L4_CS_OK(rxcmp1)) {
		if (dev->features & NETIF_F_RXCSUM) {
			skb->ip_summed = CHECKSUM_UNNECESSARY;
			skb->csum_level = RX_CMP_ENCAP(rxcmp1);
		}
	} else {
		if (rxcmp1->rx_cmp_cfa_code_errors_v2 & RX_CMP_L4_CS_ERR_BITS) {
			if (dev->features & NETIF_F_RXCSUM)
				bnapi->cp_ring.sw_stats->rx.rx_l4_csum_errors++;
		}
	}
	if (bnxt_rx_ts_valid(bp, flags, rxcmp1, &cmpl_ts)) {
		if (bp->flags & BNXT_FLAG_CHIP_P5_PLUS) {
			unsigned int int ns, ts;
			if (!bnxt_get_rx_ts_p5(bp, &ts, cmpl_ts)) {
				struct bnxt_ptp_cfg *ptp = bp->ptp_cfg;
				spin_lock_bh(&ptp->ptp_lock);
				ns = timecounter_cyc2time(&ptp->tc, ts);
				spin_unlock_bh(&ptp->ptp_lock);
				memset(skb_hwtstamps(skb), 0,
				       sizeof(*skb_hwtstamps(skb)));
				skb_hwtstamps(skb)->hwtstamp = ns_to_ktime(ns);
			}
		}
	}
	bnxt_deliver_skb(bp, bnapi, skb);
	rc = 1;
next_rx:
	cpr->rx_packets += 1;
	cpr->rx_bytes += len;
next_rx_no_len:
	rxr->rx_prod = NEXT_RX(prod);
	rxr->rx_next_cons = RING_RX(bp, NEXT_RX(cons));
next_rx_no_prod_no_len:
	*raw_cons = tmp_raw_cons;
	return rc;
oom_next_rx:
	cpr->sw_stats->rx.rx_oom_discards += 1;
	rc = -ENOMEM;
	goto next_rx;
}
