wg_process_response(tvbuff_t *tvb, wg_handshake_state_t *hs)
{
    DISSECTOR_ASSERT(hs->initiator_skey);
    DISSECTOR_ASSERT(hs->responder_ekey);
    DISSECTOR_ASSERT(hs->responder_skey);
    if (hs->initiator_recv_cipher || hs->responder_recv_cipher) {
        ws_warning("FIXME multiple responses linked to a single session");
        return;
    }
    DISSECTOR_ASSERT(!hs->initiator_recv_cipher);
    DISSECTOR_ASSERT(!hs->responder_recv_cipher);
    const gboolean has_Epriv_i = has_private_key(&hs->initiator_ekey->priv_key);
    const gboolean has_Spriv_i = has_private_key(&hs->initiator_skey->priv_key);
    const gboolean has_Epriv_r = has_private_key(&hs->responder_ekey->priv_key);
    if (!(has_Epriv_i && has_Spriv_i) && !has_Epriv_r) {
        return;
    }
    const wg_qqword *ephemeral = (const wg_qqword *)tvb_get_ptr(tvb, 12, WG_KEY_LEN);
    const guint8 *encrypted_empty = (const guint8 *)tvb_get_ptr(tvb, 44, AUTH_TAG_LENGTH);
    wg_qqword ctk[3], h;
    wg_qqword *c = &ctk[0], *t = &ctk[1], *k = &ctk[2];
    h = hs->handshake_hash;
    *c = hs->chaining_key;
    wg_kdf(c, ephemeral->data, WG_KEY_LEN, 1, c);
    wg_mix_hash(&h, ephemeral, WG_KEY_LEN);
    wg_qqword dh1;
    if (has_Epriv_i && has_Spriv_i) {
        dh_x25519(&dh1, &hs->initiator_ekey->priv_key, ephemeral);
    } else {
        dh_x25519(&dh1, &hs->responder_ekey->priv_key, &hs->initiator_ekey->pub_key);
    }
    wg_kdf(c, dh1.data, sizeof(dh1), 1, c);
    wg_qqword dh2;
    if (has_Epriv_i && has_Spriv_i) {
        dh_x25519(&dh2, &hs->initiator_skey->priv_key, ephemeral);
    } else {
        dh_x25519(&dh2, &hs->responder_ekey->priv_key, &hs->initiator_skey->pub_key);
    }
    wg_kdf(c, dh2.data, sizeof(dh2), 1, c);
    wg_qqword h_before_psk = h, c_before_psk = *c, psk;
    wg_psk_iter_context psk_iter = { WG_PSK_ITER_STATE_ENTER, NULL };
    while (wg_psk_iter_next(&psk_iter, hs, &psk)) {
        wg_kdf(c, psk.data, WG_KEY_LEN, 3, ctk);
        wg_mix_hash(&h, t, sizeof(wg_qqword));
        if (!aead_decrypt(k, 0, encrypted_empty, AUTH_TAG_LENGTH, h.data, sizeof(wg_qqword), NULL, 0)) {
            h = h_before_psk;
            *c = c_before_psk;
            continue;
        }
        hs->empty_ok = TRUE;
        break;
    }
    if (!hs->empty_ok) {
        return;
    }
    wg_mix_hash(&h, encrypted_empty, AUTH_TAG_LENGTH);
    wg_qqword transport_keys[2];
    wg_kdf(c, NULL, 0, 2, transport_keys);
    hs->initiator_recv_cipher = wg_create_cipher(&transport_keys[1]);
    hs->responder_recv_cipher = wg_create_cipher(&transport_keys[0]);
}
