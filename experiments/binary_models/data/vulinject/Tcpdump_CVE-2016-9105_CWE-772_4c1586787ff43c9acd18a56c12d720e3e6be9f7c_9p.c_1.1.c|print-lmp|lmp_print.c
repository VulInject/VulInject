lmp_print(netdissect_options *ndo,
          const u_char *pptr, u_int length)
{
    const struct lmp_common_header *lmp_com_header;
    const u_char *tptr,*obj_tptr;
    u_int version_res, tlen, lmp_obj_len, lmp_obj_ctype, obj_tlen;
    int hexdump;
    u_int offset;
    u_int link_type;
    ndo->ndo_protocol = "lmp";
    tptr=pptr;
    lmp_com_header = (const struct lmp_common_header *)pptr;
    ND_TCHECK_SIZE(lmp_com_header);
    version_res = GET_BE_U_2(lmp_com_header->version_res);
    if (LMP_EXTRACT_VERSION(version_res) != LMP_VERSION) {
	ND_PRINT("LMP version %u packet not supported",
               LMP_EXTRACT_VERSION(version_res));
	return;
    }
    if (ndo->ndo_vflag < 1) {
        ND_PRINT("LMPv%u %s Message, length: %u",
               LMP_EXTRACT_VERSION(version_res),
               tok2str(lmp_msg_type_values, "unknown (%u)",GET_U_1(lmp_com_header->msg_type)),
               length);
        return;
    }
    tlen=GET_BE_U_2(lmp_com_header->length);
    ND_PRINT("\n\tLMPv%u, msg-type: %s, Flags: [%s], length: %u",
           LMP_EXTRACT_VERSION(version_res),
           tok2str(lmp_msg_type_values, "unknown, type: %u",GET_U_1(lmp_com_header->msg_type)),
           bittok2str(lmp_header_flag_values,"none",GET_U_1(lmp_com_header->flags)),
           tlen);
    if (tlen < sizeof(struct lmp_common_header)) {
        ND_PRINT(" (too short)");
        return;
    }
    if (tlen > length) {
        ND_PRINT(" (too int)");
        tlen = length;
    }
    tptr+=sizeof(struct lmp_common_header);
    tlen-=sizeof(struct lmp_common_header);
    while(tlen != 0) {
        const struct lmp_object_header *lmp_obj_header =
            (const struct lmp_object_header *)tptr;
        lmp_obj_len=GET_BE_U_2(lmp_obj_header->length);
        lmp_obj_ctype=GET_U_1(lmp_obj_header->ctype)&0x7f;
        ND_PRINT("\n\t  %s Object (%u), Class-Type: %s (%u) Flags: [%snegotiable], length: %u",
               tok2str(lmp_obj_values,
                       "Unknown",
                       GET_U_1(lmp_obj_header->class_num)),
               GET_U_1(lmp_obj_header->class_num),
               tok2str(lmp_ctype_values,
                       "Unknown",
                       (GET_U_1(lmp_obj_header->class_num)<<8)+lmp_obj_ctype),
               lmp_obj_ctype,
               GET_U_1(lmp_obj_header->ctype)&0x80 ? "" : "non-",
               lmp_obj_len);
        if (lmp_obj_len < 4) {
            ND_PRINT(" (too short)");
            return;
        }
        if ((lmp_obj_len % 4) != 0) {
            ND_PRINT(" (not a multiple of 4)");
            return;
        }
        obj_tptr=tptr+sizeof(struct lmp_object_header);
        obj_tlen=lmp_obj_len-sizeof(struct lmp_object_header);
        hexdump=FALSE;
        switch(GET_U_1(lmp_obj_header->class_num)) {
        case LMP_OBJ_CC_ID:
            switch(lmp_obj_ctype) {
            case LMP_CTYPE_LOC:
            case LMP_CTYPE_RMT:
                if (obj_tlen != 4) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
                ND_PRINT("\n\t    Control Channel ID: %u (0x%08x)",
                       GET_BE_U_4(obj_tptr),
                       GET_BE_U_4(obj_tptr));
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case LMP_OBJ_LINK_ID:
        case LMP_OBJ_INTERFACE_ID:
            switch(lmp_obj_ctype) {
            case LMP_CTYPE_IPV4_LOC:
            case LMP_CTYPE_IPV4_RMT:
                if (obj_tlen != 4) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
                ND_PRINT("\n\t    IPv4 Link ID: %s (0x%08x)",
                       GET_IPADDR_STRING(obj_tptr),
                       GET_BE_U_4(obj_tptr));
                break;
            case LMP_CTYPE_IPV6_LOC:
            case LMP_CTYPE_IPV6_RMT:
                if (obj_tlen != 16) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
                ND_PRINT("\n\t    IPv6 Link ID: %s (0x%08x)",
                       GET_IP6ADDR_STRING(obj_tptr),
                       GET_BE_U_4(obj_tptr));
                break;
            case LMP_CTYPE_UNMD_LOC:
            case LMP_CTYPE_UNMD_RMT:
                if (obj_tlen != 4) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
                ND_PRINT("\n\t    Link ID: %u (0x%08x)",
                       GET_BE_U_4(obj_tptr),
                       GET_BE_U_4(obj_tptr));
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case LMP_OBJ_MESSAGE_ID:
            switch(lmp_obj_ctype) {
            case LMP_CTYPE_1:
                if (obj_tlen != 4) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
                ND_PRINT("\n\t    Message ID: %u (0x%08x)",
                       GET_BE_U_4(obj_tptr),
                       GET_BE_U_4(obj_tptr));
                break;
            case LMP_CTYPE_2:
                if (obj_tlen != 4) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
                ND_PRINT("\n\t    Message ID Ack: %u (0x%08x)",
                       GET_BE_U_4(obj_tptr),
                       GET_BE_U_4(obj_tptr));
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case LMP_OBJ_NODE_ID:
            switch(lmp_obj_ctype) {
            case LMP_CTYPE_LOC:
            case LMP_CTYPE_RMT:
                if (obj_tlen != 4) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
                ND_PRINT("\n\t    Node ID: %s (0x%08x)",
                       GET_IPADDR_STRING(obj_tptr),
                       GET_BE_U_4(obj_tptr));
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case LMP_OBJ_CONFIG:
            switch(lmp_obj_ctype) {
            case LMP_CTYPE_HELLO_CONFIG:
                if (obj_tlen != 4) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
                ND_PRINT("\n\t    Hello Interval: %u\n\t    Hello Dead Interval: %u",
                       GET_BE_U_2(obj_tptr),
                       GET_BE_U_2(obj_tptr + 2));
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case LMP_OBJ_HELLO:
            switch(lmp_obj_ctype) {
	    case LMP_CTYPE_HELLO:
                if (obj_tlen != 8) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
                ND_PRINT("\n\t    Tx Seq: %u, Rx Seq: %u",
                       GET_BE_U_4(obj_tptr),
                       GET_BE_U_4(obj_tptr + 4));
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case LMP_OBJ_TE_LINK:
	    switch(lmp_obj_ctype) {
	    case LMP_CTYPE_IPV4:
                if (obj_tlen != 12) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
		ND_PRINT("\n\t    Flags: [%s]",
		    bittok2str(lmp_obj_te_link_flag_values,
			"none",
			GET_U_1(obj_tptr)));
		ND_PRINT("\n\t    Local Link-ID: %s (0x%08x)"
		       "\n\t    Remote Link-ID: %s (0x%08x)",
                       GET_IPADDR_STRING(obj_tptr+4),
                       GET_BE_U_4(obj_tptr + 4),
                       GET_IPADDR_STRING(obj_tptr+8),
                       GET_BE_U_4(obj_tptr + 8));
		break;
	    case LMP_CTYPE_IPV6:
                if (obj_tlen != 36) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
		ND_PRINT("\n\t    Flags: [%s]",
		    bittok2str(lmp_obj_te_link_flag_values,
			"none",
			GET_U_1(obj_tptr)));
		ND_PRINT("\n\t    Local Link-ID: %s (0x%08x)"
		       "\n\t    Remote Link-ID: %s (0x%08x)",
                       GET_IP6ADDR_STRING(obj_tptr+4),
                       GET_BE_U_4(obj_tptr + 4),
                       GET_IP6ADDR_STRING(obj_tptr+20),
                       GET_BE_U_4(obj_tptr + 20));
                break;
	    case LMP_CTYPE_UNMD:
                if (obj_tlen != 12) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
		ND_PRINT("\n\t    Flags: [%s]",
		    bittok2str(lmp_obj_te_link_flag_values,
			"none",
			GET_U_1(obj_tptr)));
		ND_PRINT("\n\t    Local Link-ID: %u (0x%08x)"
		       "\n\t    Remote Link-ID: %u (0x%08x)",
                       GET_BE_U_4(obj_tptr + 4),
                       GET_BE_U_4(obj_tptr + 4),
                       GET_BE_U_4(obj_tptr + 8),
                       GET_BE_U_4(obj_tptr + 8));
		break;
            default:
                hexdump=TRUE;
            }
            break;
        case LMP_OBJ_DATA_LINK:
	    switch(lmp_obj_ctype) {
	    case LMP_CTYPE_IPV4:
                if (obj_tlen < 12) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
	        ND_PRINT("\n\t    Flags: [%s]",
		    bittok2str(lmp_obj_data_link_flag_values,
			"none",
			GET_U_1(obj_tptr)));
                ND_PRINT("\n\t    Local Interface ID: %s (0x%08x)"
                       "\n\t    Remote Interface ID: %s (0x%08x)",
                       GET_IPADDR_STRING(obj_tptr+4),
                       GET_BE_U_4(obj_tptr + 4),
                       GET_IPADDR_STRING(obj_tptr+8),
                       GET_BE_U_4(obj_tptr + 8));
		if (lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 12, 12))
		    hexdump=TRUE;
		break;
	    case LMP_CTYPE_IPV6:
                if (obj_tlen < 36) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
	        ND_PRINT("\n\t    Flags: [%s]",
		    bittok2str(lmp_obj_data_link_flag_values,
			"none",
			GET_U_1(obj_tptr)));
                ND_PRINT("\n\t    Local Interface ID: %s (0x%08x)"
                       "\n\t    Remote Interface ID: %s (0x%08x)",
                       GET_IP6ADDR_STRING(obj_tptr+4),
                       GET_BE_U_4(obj_tptr + 4),
                       GET_IP6ADDR_STRING(obj_tptr+20),
                       GET_BE_U_4(obj_tptr + 20));
		if (lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 36, 36))
		    hexdump=TRUE;
		break;
	    case LMP_CTYPE_UNMD:
                if (obj_tlen < 12) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
	        ND_PRINT("\n\t    Flags: [%s]",
		    bittok2str(lmp_obj_data_link_flag_values,
			"none",
			GET_U_1(obj_tptr)));
                ND_PRINT("\n\t    Local Interface ID: %u (0x%08x)"
                       "\n\t    Remote Interface ID: %u (0x%08x)",
                       GET_BE_U_4(obj_tptr + 4),
                       GET_BE_U_4(obj_tptr + 4),
                       GET_BE_U_4(obj_tptr + 8),
                       GET_BE_U_4(obj_tptr + 8));
		if (lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 12, 12))
		    hexdump=TRUE;
		break;
            default:
                hexdump=TRUE;
            }
            break;
        case LMP_OBJ_VERIFY_BEGIN:
	    switch(lmp_obj_ctype) {
            case LMP_CTYPE_1:
                if (obj_tlen != 20) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
		ND_PRINT("\n\t    Flags: %s",
		bittok2str(lmp_obj_begin_verify_flag_values,
			"none",
			GET_BE_U_2(obj_tptr)));
		ND_PRINT("\n\t    Verify Interval: %u",
			GET_BE_U_2(obj_tptr + 2));
		ND_PRINT("\n\t    Data links: %u",
			GET_BE_U_4(obj_tptr + 4));
                ND_PRINT("\n\t    Encoding type: %s",
			tok2str(gmpls_encoding_values, "Unknown", GET_U_1((obj_tptr + 8))));
                ND_PRINT("\n\t    Verify Transport Mechanism: %u (0x%x)%s",
			GET_BE_U_2(obj_tptr + 10),
			GET_BE_U_2(obj_tptr + 10),
			GET_BE_U_2(obj_tptr + 10)&8000 ? " (Payload test messages capable)" : "");
		ND_PRINT("\n\t    Transmission Rate: %.3f Mbps",
			GET_BE_F_4(obj_tptr + 12)*8/1000000);
		ND_PRINT("\n\t    Wavelength: %u",
			GET_BE_U_4(obj_tptr + 16));
		break;
            default:
                hexdump=TRUE;
            }
            break;
        case LMP_OBJ_VERIFY_BEGIN_ACK:
	    switch(lmp_obj_ctype) {
            case LMP_CTYPE_1:
                if (obj_tlen != 4) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
                ND_PRINT("\n\t    Verify Dead Interval: %u"
                       "\n\t    Verify Transport Response: %u",
                       GET_BE_U_2(obj_tptr),
                       GET_BE_U_2(obj_tptr + 2));
                break;
            default:
                hexdump=TRUE;
            }
            break;
	case LMP_OBJ_VERIFY_ID:
	    switch(lmp_obj_ctype) {
            case LMP_CTYPE_1:
                if (obj_tlen != 4) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
                ND_PRINT("\n\t    Verify ID: %u",
                       GET_BE_U_4(obj_tptr));
                break;
            default:
                hexdump=TRUE;
            }
            break;
	case LMP_OBJ_CHANNEL_STATUS:
            switch(lmp_obj_ctype) {
	    case LMP_CTYPE_IPV4:
		offset = 0;
		while (offset+8 <= obj_tlen) {
			ND_PRINT("\n\t    Interface ID: %s (0x%08x)",
			GET_IPADDR_STRING(obj_tptr+offset),
			GET_BE_U_4(obj_tptr + offset));
			ND_PRINT("\n\t\t    Active: %s (%u)",
				(GET_BE_U_4(obj_tptr + offset + 4)>>31) ?
				"Allocated" : "Non-allocated",
				(GET_BE_U_4(obj_tptr + offset + 4)>>31));
			ND_PRINT("\n\t\t    Direction: %s (%u)",
				(GET_BE_U_4(obj_tptr + offset + 4)>>30)&0x1 ?
				"Transmit" : "Receive",
				(GET_BE_U_4(obj_tptr + offset + 4)>>30)&0x1);
			ND_PRINT("\n\t\t    Channel Status: %s (%u)",
					tok2str(lmp_obj_channel_status_values,
					"Unknown",
					GET_BE_U_4(obj_tptr + offset + 4)&0x3FFFFFF),
					GET_BE_U_4(obj_tptr + offset + 4)&0x3FFFFFF);
			offset+=8;
		}
                break;
	    case LMP_CTYPE_IPV6:
		offset = 0;
		while (offset+20 <= obj_tlen) {
			ND_PRINT("\n\t    Interface ID: %s (0x%08x)",
			GET_IP6ADDR_STRING(obj_tptr+offset),
			GET_BE_U_4(obj_tptr + offset));
			ND_PRINT("\n\t\t    Active: %s (%u)",
				(GET_BE_U_4(obj_tptr + offset + 16)>>31) ?
				"Allocated" : "Non-allocated",
				(GET_BE_U_4(obj_tptr + offset + 16)>>31));
			ND_PRINT("\n\t\t    Direction: %s (%u)",
				(GET_BE_U_4(obj_tptr + offset + 16)>>30)&0x1 ?
				"Transmit" : "Receive",
				(GET_BE_U_4(obj_tptr + offset + 16)>>30)&0x1);
			ND_PRINT("\n\t\t    Channel Status: %s (%u)",
					tok2str(lmp_obj_channel_status_values,
					"Unknown",
					GET_BE_U_4(obj_tptr + offset + 16)&0x3FFFFFF),
					GET_BE_U_4(obj_tptr + offset + 16)&0x3FFFFFF);
			offset+=20;
		}
                break;
	    case LMP_CTYPE_UNMD:
		offset = 0;
		while (offset+8 <= obj_tlen) {
			ND_PRINT("\n\t    Interface ID: %u (0x%08x)",
			GET_BE_U_4(obj_tptr + offset),
			GET_BE_U_4(obj_tptr + offset));
			ND_PRINT("\n\t\t    Active: %s (%u)",
				(GET_BE_U_4(obj_tptr + offset + 4)>>31) ?
				"Allocated" : "Non-allocated",
				(GET_BE_U_4(obj_tptr + offset + 4)>>31));
			ND_PRINT("\n\t\t    Direction: %s (%u)",
				(GET_BE_U_4(obj_tptr + offset + 4)>>30)&0x1 ?
				"Transmit" : "Receive",
				(GET_BE_U_4(obj_tptr + offset + 4)>>30)&0x1);
			ND_PRINT("\n\t\t    Channel Status: %s (%u)",
					tok2str(lmp_obj_channel_status_values,
					"Unknown",
					GET_BE_U_4(obj_tptr + offset + 4)&0x3FFFFFF),
					GET_BE_U_4(obj_tptr + offset + 4)&0x3FFFFFF);
			offset+=8;
		}
                break;
            default:
                hexdump=TRUE;
            }
            break;
	case LMP_OBJ_CHANNEL_STATUS_REQ:
            switch(lmp_obj_ctype) {
	    case LMP_CTYPE_IPV4:
		offset = 0;
		while (offset+4 <= obj_tlen) {
			ND_PRINT("\n\t    Interface ID: %s (0x%08x)",
			GET_IPADDR_STRING(obj_tptr+offset),
			GET_BE_U_4(obj_tptr + offset));
			offset+=4;
		}
                break;
	    case LMP_CTYPE_IPV6:
		offset = 0;
		while (offset+16 <= obj_tlen) {
			ND_PRINT("\n\t    Interface ID: %s (0x%08x)",
			GET_IP6ADDR_STRING(obj_tptr+offset),
			GET_BE_U_4(obj_tptr + offset));
			offset+=16;
		}
                break;
	    case LMP_CTYPE_UNMD:
		offset = 0;
		while (offset+4 <= obj_tlen) {
			ND_PRINT("\n\t    Interface ID: %u (0x%08x)",
			GET_BE_U_4(obj_tptr + offset),
			GET_BE_U_4(obj_tptr + offset));
			offset+=4;
		}
                break;
	    default:
                hexdump=TRUE;
            }
            break;
        case LMP_OBJ_ERROR_CODE:
	    switch(lmp_obj_ctype) {
            case LMP_CTYPE_BEGIN_VERIFY_ERROR:
                if (obj_tlen != 4) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
		ND_PRINT("\n\t    Error Code: %s",
		bittok2str(lmp_obj_begin_verify_error_values,
			"none",
			GET_BE_U_4(obj_tptr)));
                break;
            case LMP_CTYPE_LINK_SUMMARY_ERROR:
                if (obj_tlen != 4) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
		ND_PRINT("\n\t    Error Code: %s",
		bittok2str(lmp_obj_link_summary_error_values,
			"none",
			GET_BE_U_4(obj_tptr)));
                break;
            default:
                hexdump=TRUE;
            }
            break;
	case LMP_OBJ_SERVICE_CONFIG:
	    switch (lmp_obj_ctype) {
	    case LMP_CTYPE_SERVICE_CONFIG_SP:
                if (obj_tlen != 4) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
		ND_PRINT("\n\t Flags: %s",
		       bittok2str(lmp_obj_service_config_sp_flag_values,
				  "none",
				  GET_U_1(obj_tptr)));
		ND_PRINT("\n\t  UNI Version: %u",
		       GET_U_1(obj_tptr + 1));
		break;
            case LMP_CTYPE_SERVICE_CONFIG_CPSA:
                if (obj_tlen != 16) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
		link_type = GET_U_1(obj_tptr);
		ND_PRINT("\n\t Link Type: %s (%u)",
		       tok2str(lmp_sd_service_config_cpsa_link_type_values,
			       "Unknown", link_type),
		       link_type);
		switch (link_type) {
		case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH:
		    ND_PRINT("\n\t Signal Type: %s (%u)",
			   tok2str(lmp_sd_service_config_cpsa_signal_type_sdh_values,
				   "Unknown",
				   GET_U_1(obj_tptr + 1)),
			   GET_U_1(obj_tptr + 1));
		    break;
		case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET:
		    ND_PRINT("\n\t Signal Type: %s (%u)",
			   tok2str(lmp_sd_service_config_cpsa_signal_type_sonet_values,
				   "Unknown",
				   GET_U_1(obj_tptr + 1)),
			   GET_U_1(obj_tptr + 1));
		    break;
		}
		ND_PRINT("\n\t Transparency: %s",
		       bittok2str(lmp_obj_service_config_cpsa_tp_flag_values,
				  "none",
				  GET_U_1(obj_tptr + 2)));
		ND_PRINT("\n\t Contiguous Concatenation Types: %s",
		       bittok2str(lmp_obj_service_config_cpsa_cct_flag_values,
				  "none",
				  GET_U_1(obj_tptr + 3)));
		ND_PRINT("\n\t Minimum NCC: %u",
		       GET_BE_U_2(obj_tptr + 4));
		ND_PRINT("\n\t Maximum NCC: %u",
		       GET_BE_U_2(obj_tptr + 6));
		ND_PRINT("\n\t Minimum NVC:%u",
		       GET_BE_U_2(obj_tptr + 8));
		ND_PRINT("\n\t Maximum NVC:%u",
		       GET_BE_U_2(obj_tptr + 10));
		ND_PRINT("\n\t    Local Interface ID: %s (0x%08x)",
		       GET_IPADDR_STRING(obj_tptr+12),
		       GET_BE_U_4(obj_tptr + 12));
		break;
	    case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM:
                if (obj_tlen != 8) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
		ND_PRINT("\n\t Transparency Flags: %s",
		       bittok2str(
			   lmp_obj_service_config_nsa_transparency_flag_values,
			   "none",
			   GET_BE_U_4(obj_tptr)));
		ND_PRINT("\n\t TCM Monitoring Flags: %s",
		       bittok2str(
			   lmp_obj_service_config_nsa_tcm_flag_values,
			   "none",
			   GET_U_1(obj_tptr + 7)));
		break;
	    case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY:
                if (obj_tlen != 4) {
                    ND_PRINT(" (not correct for object)");
                    break;
                }
		ND_PRINT("\n\t Diversity: Flags: %s",
		       bittok2str(
			   lmp_obj_service_config_nsa_network_diversity_flag_values,
			   "none",
			   GET_U_1(obj_tptr + 3)));
		break;
	    default:
		hexdump = TRUE;
	    }
	break;
        default:
            if (ndo->ndo_vflag <= 1)
                print_unknown_data(ndo,obj_tptr,"\n\t    ",obj_tlen);
            break;
        }
        if (ndo->ndo_vflag > 1 || hexdump==TRUE)
            print_unknown_data(ndo,tptr+sizeof(struct lmp_object_header),"\n\t    ",
                               lmp_obj_len-sizeof(struct lmp_object_header));
        if (tlen < lmp_obj_len) {
            ND_PRINT(" [remaining objects length %u < %u]", tlen, lmp_obj_len);
            nd_print_invalid(ndo);
            break;
        }
        tptr+=lmp_obj_len;
        tlen-=lmp_obj_len;
    }
}
