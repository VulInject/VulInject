dissect_bthci_vendor_intel(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
    proto_item        *main_item;
    proto_tree        *main_tree;
    proto_item        *opcode_item;
    proto_tree        *opcode_tree;
    proto_item        *sub_item;
    bluetooth_data_t  *bluetooth_data;
    gint               offset = 0;
    gint               offset_parameters;
    guint16            opcode;
    guint16            ocf;
    const gchar       *description;
    guint8             length;
    guint8             event_code;
    guint8             status;
    guint8             type;
    guint32            interface_id;
    guint32            adapter_id;
    bluetooth_data = (bluetooth_data_t *) data;
    if (bluetooth_data) {
        interface_id  = bluetooth_data->interface_id;
        adapter_id    = bluetooth_data->adapter_id;
    } else {
        interface_id  = HCI_INTERFACE_DEFAULT;
        adapter_id    = HCI_ADAPTER_DEFAULT;
    }
    main_item = proto_tree_add_item(tree, proto_bthci_vendor_intel, tvb, 0, tvb_captured_length(tvb), ENC_NA);
    main_tree = proto_item_add_subtree(main_item, ett_intel);
    switch (pinfo->p2p_dir) {
    case P2P_DIR_SENT:
        col_set_str(pinfo->cinfo, COL_PROTOCOL, "HCI_CMD_INTEL");
        col_add_fstr(pinfo->cinfo, COL_INFO, "Sent Intel ");
        opcode_item = proto_tree_add_item(main_tree, hf_intel_opcode, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        opcode_tree = proto_item_add_subtree(opcode_item, ett_intel_opcode);
        opcode = tvb_get_letohs(tvb, offset);
        proto_tree_add_item(opcode_tree, hf_intel_opcode_ogf, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(opcode_tree, hf_intel_opcode_ocf, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        ocf = opcode & 0x03ff;
        offset+=2;
        description = val_to_str_const(ocf, intel_opcode_ocf_vals, "unknown");
        if (g_strcmp0(description, "unknown") != 0)
            col_append_str(pinfo->cinfo, COL_INFO, description);
        else
            col_append_fstr(pinfo->cinfo, COL_INFO, "Unknown Command 0x%04X (opcode 0x%04X)", ocf, opcode);
        if (have_tap_listener(bluetooth_hci_summary_tap)) {
            bluetooth_hci_summary_tap_t  *tap_hci_summary;
	tap_hci_summary=((pinfo->pool+bluetooth_hci_summary_tap_t-1)/bluetooth_hci_summary_tap_t);
            tap_hci_summary->interface_id  = interface_id;
            tap_hci_summary->adapter_id    = adapter_id;
            tap_hci_summary->type = BLUETOOTH_HCI_SUMMARY_VENDOR_OPCODE;
            tap_hci_summary->ogf = opcode >> 10;
            tap_hci_summary->ocf = ocf;
            if (try_val_to_str(ocf, intel_opcode_ocf_vals))
                tap_hci_summary->name = description;
            else
                tap_hci_summary->name = NULL;
            tap_queue_packet(bluetooth_hci_summary_tap, pinfo, tap_hci_summary);
        }
        proto_tree_add_item(main_tree, hf_intel_parameter_length, tvb, offset, 1, ENC_NA);
        length = tvb_get_guint8(tvb, offset);
        offset += 1;
        offset_parameters = offset;
        switch(ocf) {
        case 0x0001: 
            proto_tree_add_item(main_tree, hf_intel_reset_reset_type, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_reset_patch_enable, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_reset_ddc_reload, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_reset_ddc_reload, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_reset_boot_option, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_reset_boot_address, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;
            break;
        case 0x0002: 
        case 0x0006: 
        case 0x0007: 
        case 0x0008: 
        case 0x000E: 
        case 0x000F: 
        case 0x0010: 
        case 0x0012: 
        case 0x0022: 
        case 0x0024: 
        case 0x0032: 
        case 0x0034: 
        case 0x0038: 
        case 0x0039: 
        case 0x0050: 
        case 0x0053: 
        case 0x0089: 
        case 0x008A: 
        case 0x008C: 
        case 0x008D: 
            break;
        case 0x0005: 
        case 0x000D: 
        case 0x0030: 
        case 0x003F: 
            break;
        case 0x0009: 
            proto_tree_add_item(main_tree, hf_intel_secure_send_type, tvb, offset, 1, ENC_NA);
            offset += 1;
            if (length - 1 > 0) {
                sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, length, ENC_NA);
                expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
                offset += length - 1;
            }
            break;
        case 0x0011: 
            proto_tree_add_item(main_tree, hf_intel_manufacturer_mode, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_manufacturer_reset, tvb, offset, 1, ENC_NA);
            offset += 1;
            break;
        case 0x002F: 
            offset = dissect_bd_addr(hf_intel_bd_addr, pinfo, main_tree, tvb, offset, FALSE, interface_id, adapter_id, NULL);
            sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, 6, ENC_NA);
            expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
            offset += 6;
            sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, 8, ENC_NA);
            expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
            offset += 8;
            sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, 1, ENC_NA);
            expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
            offset += 1;
            if (length - 6 - 8 - 1 > 0) {
                sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, length - 6 - 8 - 1, ENC_NA);
                expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
                offset += length - 6 - 8 - 1;
            }
            break;
        case 0x0031: 
            offset = dissect_bd_addr(hf_intel_bd_addr, pinfo, main_tree, tvb, offset, FALSE, interface_id, adapter_id, NULL);
            break;
        case 0x0043: 
            proto_tree_add_item(main_tree, hf_intel_transmit_traces, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_transmit_arq, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_receive_traces, tvb, offset, 1, ENC_NA);
            offset += 1;
            break;
        case 0x004D: 
            proto_tree_add_item(main_tree, hf_intel_stimulated_exception_type, tvb, offset, 1, ENC_NA);
            offset += 1;
            break;
        case 0x0052: 
            proto_tree_add_bitmask(main_tree, tvb, offset, hf_intel_set_event_mask, ett_intel_set_event_mask, hfx_intel_set_event_mask, ENC_LITTLE_ENDIAN);
            offset += 8;
            break;
        case 0x008B: 
            while (length > 0) {
                guint8  ddc_config_length;
                proto_tree_add_item(main_tree, hf_intel_ddc_config_length, tvb, offset, 1, ENC_NA);
                ddc_config_length = tvb_get_guint8(tvb, offset);
                offset += 1;
                proto_tree_add_item(main_tree, hf_intel_identifier, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                offset += 2;
                proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, ddc_config_length, ENC_NA);
                offset += ddc_config_length;
                length -= 1 + 3 + ddc_config_length;
            }
            break;
        case 0x008E: 
            proto_tree_add_item(main_tree, hf_intel_mem_address, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;
            proto_tree_add_item(main_tree, hf_intel_mem_mode, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_mem_length, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, tvb_get_guint8(tvb, offset - 1), ENC_NA);
            offset += tvb_get_guint8(tvb, offset - 1);
            break;
        default:
            if (length > 0) {
                sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, length, ENC_NA);
                expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
                offset += length;
            }
        }
        if (offset - offset_parameters < length) {
            sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, length - (offset - offset_parameters), ENC_NA);
            expert_add_info(pinfo, sub_item, &ei_intel_unexpected_parameter);
            offset += length - (offset - offset_parameters);
        }
        break;
    case P2P_DIR_RECV:
        col_set_str(pinfo->cinfo, COL_PROTOCOL, "HCI_EVT_INTEL");
        col_add_fstr(pinfo->cinfo, COL_INFO, "Rcvd Intel ");
        event_code = tvb_get_guint8(tvb, offset);
        if (try_val_to_str(event_code, intel_event_code_vals))
            description = val_to_str(event_code, intel_event_code_vals, "Unknown 0x%08x");
        else
            description = val_to_str_ext(event_code, &bthci_evt_evt_code_vals_ext, "Unknown 0x%08x");
        col_append_str(pinfo->cinfo, COL_INFO, description);
        proto_tree_add_item(main_tree, hf_intel_event_code, tvb, offset, 1, ENC_NA);
        offset += 1;
        if (have_tap_listener(bluetooth_hci_summary_tap)) {
            bluetooth_hci_summary_tap_t  *tap_hci_summary;
            tap_hci_summary = wmem_new(pinfo->pool, bluetooth_hci_summary_tap_t);
            tap_hci_summary->interface_id  = interface_id;
            tap_hci_summary->adapter_id    = adapter_id;
            tap_hci_summary->type = BLUETOOTH_HCI_SUMMARY_VENDOR_EVENT;
            tap_hci_summary->event = event_code;
            if (try_val_to_str_ext(event_code, &bthci_evt_evt_code_vals_ext))
                tap_hci_summary->name = description;
            else
                tap_hci_summary->name = NULL;
            tap_queue_packet(bluetooth_hci_summary_tap, pinfo, tap_hci_summary);
        }
        proto_tree_add_item(main_tree, hf_intel_parameter_length, tvb, offset, 1, ENC_NA);
        length = tvb_get_guint8(tvb, offset);
        offset += 1;
        offset_parameters = offset;
        switch (event_code) {
        case 0x0e: 
            proto_tree_add_item(main_tree, hf_intel_number_of_allowed_command_packets, tvb, offset, 1, ENC_NA);
            offset += 1;
            opcode_item = proto_tree_add_item(main_tree, hf_intel_opcode, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            opcode_tree = proto_item_add_subtree(opcode_item, ett_intel_opcode);
            opcode = tvb_get_letohs(tvb, offset);
            proto_tree_add_item(opcode_tree, hf_intel_opcode_ogf, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            proto_tree_add_item(opcode_tree, hf_intel_opcode_ocf, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            ocf = opcode & 0x03ff;
            offset += 2;
            description = val_to_str_const(ocf, intel_opcode_ocf_vals, "unknown");
            if (g_strcmp0(description, "unknown") != 0)
                col_append_fstr(pinfo->cinfo, COL_INFO, " (%s)", description);
            else
                col_append_fstr(pinfo->cinfo, COL_INFO, " (Unknown Command 0x%04X [opcode 0x%04X])", ocf, opcode);
            if (have_tap_listener(bluetooth_hci_summary_tap)) {
                bluetooth_hci_summary_tap_t  *tap_hci_summary;
                tap_hci_summary = wmem_new(pinfo->pool, bluetooth_hci_summary_tap_t);
                tap_hci_summary->interface_id  = interface_id;
                tap_hci_summary->adapter_id    = adapter_id;
                tap_hci_summary->type = BLUETOOTH_HCI_SUMMARY_VENDOR_EVENT_OPCODE;
                tap_hci_summary->ogf = opcode >> 10;
                tap_hci_summary->ocf = ocf;
                if (try_val_to_str(ocf, intel_opcode_ocf_vals))
                    tap_hci_summary->name = description;
                else
                    tap_hci_summary->name = NULL;
                tap_queue_packet(bluetooth_hci_summary_tap, pinfo, tap_hci_summary);
            }
            proto_tree_add_item(main_tree, hf_intel_status, tvb, offset, 1, ENC_NA);
            status = tvb_get_guint8(tvb, offset);
            offset += 1;
            switch (ocf) {
            case 0x0001: 
            case 0x0009: 
            case 0x0011: 
            case 0x0031: 
            case 0x003F: 
            case 0x004D: 
            case 0x0052: 
            case 0x008E: 
                break;
            case 0x0002: 
            case 0x0006: 
            case 0x0007: 
            case 0x0008: 
            case 0x000D: 
            case 0x000E: 
            case 0x000F: 
            case 0x0010: 
            case 0x0012: 
            case 0x0022: 
            case 0x0024: 
            case 0x002F: 
            case 0x0032: 
            case 0x0034: 
            case 0x0038: 
            case 0x0039: 
            case 0x0043: 
            case 0x0050: 
            case 0x0053: 
            case 0x0089: 
            case 0x008A: 
            case 0x008C: 
            case 0x008D: 
                if (length > 0) {
                    sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, length, ENC_NA);
                    if (status == STATUS_SUCCESS)
                        expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
                    else
                        expert_add_info(pinfo, sub_item, &ei_intel_unexpected_parameter);
                    offset += length;
                }
                break;
            case 0x0005: 
                proto_tree_add_item(main_tree, hf_intel_hardware_platform, tvb, offset, length, ENC_NA);
                offset += 1;
                proto_tree_add_item(main_tree, hf_intel_hardware_variant, tvb, offset, length, ENC_NA);
                offset += 1;
                proto_tree_add_item(main_tree, hf_intel_hardware_revision, tvb, offset, length, ENC_NA);
                offset += 1;
                proto_tree_add_item(main_tree, hf_intel_firmware_variant, tvb, offset, length, ENC_NA);
                offset += 1;
                proto_tree_add_item(main_tree, hf_intel_firmware_revision, tvb, offset, length, ENC_NA);
                offset += 1;
                proto_tree_add_item(main_tree, hf_intel_firmware_build_version_nn, tvb, offset, length, ENC_NA);
                offset += 1;
                proto_tree_add_item(main_tree, hf_intel_firmware_build_version_cw, tvb, offset, length, ENC_NA);
                offset += 1;
                proto_tree_add_item(main_tree, hf_intel_firmware_build_version_yy, tvb, offset, length, ENC_NA);
                offset += 1;
                proto_tree_add_item(main_tree, hf_intel_firmware_patch, tvb, offset, length, ENC_NA);
                offset += 1;
                break;
            case 0x0030: 
                offset = dissect_bd_addr(hf_intel_bd_addr, pinfo, main_tree, tvb, offset, FALSE, interface_id, adapter_id, NULL);
                break;
            case 0x008B: 
                proto_tree_add_item(main_tree, hf_intel_identifier, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                offset += 2;
                break;
            default:
                if (length > 0) {
                    sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, length, ENC_NA);
                    if (status == STATUS_SUCCESS)
                        expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
                    else
                        expert_add_info(pinfo, sub_item, &ei_intel_unexpected_parameter);
                    offset += length;
                }
                break;
            }
            break;
        case 0x01: 
        case 0x08: 
            proto_tree_add_item(main_tree, hf_intel_line, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset += 2;
            proto_tree_add_item(main_tree, hf_intel_module, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_reason, tvb, offset, 1, ENC_NA);
            offset += 1;
            break;
        case 0x02: 
            proto_tree_add_item(main_tree, hf_intel_zero, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_number_of_packets, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_source, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_reset_type, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_reset_reason, tvb, offset, 1, ENC_NA);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_ddc_status, tvb, offset, 1, ENC_NA);
            offset += 1;
            break;
        case 0x05: 
            proto_tree_add_item(main_tree, hf_intel_bd_data_status, tvb, offset, 1, ENC_NA);
            offset += 1;
            break;
        case 0x06: 
            proto_tree_add_item(main_tree, hf_intel_secure_send_commands_result, tvb, offset, 1, ENC_NA);
            offset += 1;
            opcode_item = proto_tree_add_item(main_tree, hf_intel_opcode, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            opcode_tree = proto_item_add_subtree(opcode_item, ett_intel_opcode);
            proto_tree_add_item(opcode_tree, hf_intel_opcode_ogf, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            proto_tree_add_item(opcode_tree, hf_intel_opcode_ocf, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset += 2;
            proto_tree_add_item(main_tree, hf_intel_status, tvb, offset, 1, ENC_NA);
            offset += 1;
            break;
        case 0x0F: 
            proto_tree_add_item(main_tree, hf_intel_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset += 2;
            sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, 8, ENC_NA);
            expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
            offset += 8;
            proto_tree_add_item(main_tree, hf_intel_access_address, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;
            sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, length - 2 - 8 - 4, ENC_NA);
            expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
            offset += length - 2 - 8 - 4;
            break;
        case 0x11: 
            proto_tree_add_bitmask(main_tree, tvb, offset, hf_intel_scan_status, ett_intel_scan_status, hfx_intel_scan_status, ENC_NA);
            offset += 1;
            break;
        case 0x16: 
            proto_tree_add_item(main_tree, hf_intel_status, tvb, offset, 1, ENC_NA);
            offset += 1;
            break;
        case 0x17: 
            proto_tree_add_item(main_tree, hf_intel_link_pdu_trace_type, tvb, offset, 1, ENC_NA);
            type = tvb_get_guint8(tvb, offset);
            offset += 1;
            proto_tree_add_item(main_tree, hf_intel_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset += 2;
            switch (type) {
            case 0x00: 
                sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, 1, ENC_NA);
                expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
                offset += 1;
                call_dissector(btlmp_handle, tvb_new_subset_length(tvb, offset, length - 3 - 4), pinfo, tree);
                offset += length - 3 - 4;
                proto_tree_add_item(main_tree, hf_intel_link_clock, tvb, offset, 4, ENC_LITTLE_ENDIAN);
                offset += 4;
                break;
            case 0x01: 
                sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, 1, ENC_NA);
                expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
                offset += 1;
                call_dissector(btlmp_handle, tvb_new_subset_length(tvb, offset, length - 3 - 5), pinfo, tree);
                offset += length - 3 - 5;
                proto_tree_add_item(main_tree, hf_intel_link_clock, tvb, offset, 4, ENC_LITTLE_ENDIAN);
                offset += 4;
                proto_tree_add_item(main_tree, hf_intel_link_id, tvb, offset, 1, ENC_NA);
                offset += 1;
                break;
            case 0x02: 
                proto_tree_add_item(main_tree, hf_intel_link_clock, tvb, offset, 4, ENC_LITTLE_ENDIAN);
                offset += 4;
                proto_tree_add_item(main_tree, hf_intel_link_id, tvb, offset, 1, ENC_NA);
                offset += 1;
                break;
            case 0x03: 
            case 0x04: 
                proto_tree_add_item(main_tree, hf_intel_link_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                offset += 2;
                proto_tree_add_item(main_tree, hf_intel_link_id, tvb, offset, 1, ENC_NA);
                offset += 1;
                sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, 2, ENC_NA);
                expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
                offset += 2;
                call_dissector(btle_handle, tvb_new_subset_length(tvb, offset, length - 3 - 2 - 1 - 2), pinfo, tree);
                offset += length - 3 - 2 - 1 - 2;
                break;
            case 0x05: 
                proto_tree_add_item(main_tree, hf_intel_link_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                offset += 2;
                proto_tree_add_item(main_tree, hf_intel_link_id, tvb, offset, 1, ENC_NA);
                offset += 1;
                break;
            };
            break;
        case 0x19: 
            proto_tree_add_item(main_tree, hf_intel_status, tvb, offset, 1, ENC_NA);
            offset += 1;
            break;
        case 0x25: 
            offset = dissect_bd_addr(hf_intel_bd_addr, pinfo, main_tree, tvb, offset, FALSE, interface_id, adapter_id, NULL);
            proto_tree_add_item(main_tree, hf_intel_reason, tvb, offset, 1, ENC_NA);
            offset += 1;
            break;
        case 0x26: 
            proto_tree_add_item(main_tree, hf_intel_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset += 2;
            proto_tree_add_item(main_tree, hf_intel_packet_table, tvb, offset, 1, ENC_NA);
            offset += 1;
            break;
        case 0x29: 
            proto_tree_add_item(main_tree, hf_intel_exception_type, tvb, offset, 1, ENC_NA);
            offset += 1;
            sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, length - 1, ENC_NA);
            expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
            offset += length - 1;
            break;
        case 0x2C: 
        case 0x2E: 
            sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, length, ENC_NA);
            expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
            offset += length;
            break;
        default:
            if (length > 0) {
                sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, length, ENC_NA);
                expert_add_info(pinfo, sub_item, &ei_intel_undecoded);
                offset += length;
            }
        }
        if (offset - offset_parameters < length) {
            sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, length - (offset - offset_parameters), ENC_NA);
            expert_add_info(pinfo, sub_item, &ei_intel_unexpected_parameter);
            offset += length - (offset - offset_parameters);
        }
        break;
    case P2P_DIR_UNKNOWN:
    default:
        col_set_str(pinfo->cinfo, COL_PROTOCOL, "HCI_INTEL");
        col_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection Intel ");
        if (tvb_captured_length_remaining(tvb, offset) > 0) {
            proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, tvb_captured_length_remaining(tvb, offset), ENC_NA);
            offset += tvb_captured_length_remaining(tvb, offset);
        }
        break;
    }
    if (tvb_captured_length_remaining(tvb, offset) > 0) {
        sub_item = proto_tree_add_item(main_tree, hf_intel_data, tvb, offset, tvb_captured_length_remaining(tvb, offset), ENC_NA);
        expert_add_info(pinfo, sub_item, &ei_intel_unexpected_data);
        offset += tvb_captured_length_remaining(tvb, offset);
    }
    return offset;
}
