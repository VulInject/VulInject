be_chan_type(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, gchar *add_string, int string_len)
{
    guint8       oct;
    guint8       sdi;
    guint8       num_chan;
    guint32      curr_offset = offset;
    const gchar *str;
    oct = tvb_get_guint8(tvb, curr_offset);
    sdi = oct & 0x0f;
    proto_tree_add_bits_item(tree, hf_gsm_a_bssmap_spare_bits, tvb, curr_offset<<3, 4, ENC_BIG_ENDIAN);
    proto_tree_add_item(tree, hf_gsm_a_bssmap_speech_data_ind, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
    if (add_string)
        snprintf(add_string, string_len, " - (%s)", val_to_str_const(tvb_get_guint8(tvb, curr_offset) & 0x0f,
                gsm_a_bssap_speech_data_ind_vals,
                "Unknown"));
    curr_offset++;
    oct = tvb_get_guint8(tvb, curr_offset);
    if ((sdi == 0x01)||(sdi == 0x04))
    {
        proto_tree_add_item(tree, hf_gsm_a_bssmap_channel_rate_and_type, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
        curr_offset++;
        NO_MORE_DATA_CHECK(len);
        do
        {
            proto_tree_add_item(tree, hf_gsm_a_bssmap_chan_type_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
            proto_tree_add_item(tree, hf_gsm_a_bssmap_perm_speech_v_ind, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
            curr_offset++;
        }
        while ((len - (curr_offset - offset)) > 0);
    }
    else if (sdi == 0x02)
    {
        num_chan = 0;
        if ((oct >= 0x20) && (oct <= 0x27))
        {
            num_chan = (oct - 0x20) + 1;
        }
        else if ((oct >= 0x30) && (oct <= 0x37))
        {
            num_chan = (oct - 0x30) + 1;
        }
        if (num_chan > 0)
        {
            proto_tree_add_uint_format_value(tree, hf_gsm_a_bssmap_data_channel_rate_and_type,
                tvb, curr_offset, 1, oct, "Max channels %u, %s",
                num_chan, rval_to_str_const(oct, gsm_a_bssap_channel_rate_and_type_rvals, "Reserved"));
        }
        else
        {
            proto_tree_add_item(tree, hf_gsm_a_bssmap_data_channel_rate_and_type,
                tvb, curr_offset, 1, ENC_NA);
        }
        curr_offset++;
        NO_MORE_DATA_CHECK(len);
        oct = tvb_get_guint8(tvb, curr_offset);
        proto_tree_add_item(tree, hf_gsm_a_bssmap_chan_type_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
        proto_tree_add_item(tree, hf_gsm_a_bssmap_transparent_service, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
        if (num_chan == 0)
        {
            if (oct & 0x40)
            {
                switch (oct & 0x3f)
                {
                case 0x00: str = "12 kbit/s if the channel is a full rate TCH, or 6 kbit/s if the channel is a half rate TCH"; break;
                case 0x18: str = "14.5 kbit/s"; break;
                case 0x10: str = "12 kbits/s"; break;
                case 0x11: str = "6 kbits/s"; break;
                case 0x31: str = "29 kbit/s"; break;
                case 0x34: str = "43,5 kbit/s"; break;
                default:
                    str = "Reserved";
                    break;
                }
            }
            else
            {
                switch (oct & 0x3f)
                {
                case 0x18: str = "14.4 kbit/s"; break;
                case 0x10: str = "9.6kbit/s"; break;
                case 0x11: str = "4.8kbit/s"; break;
                case 0x12: str = "2.4kbit/s"; break;
                case 0x13: str = "1.2Kbit/s"; break;
                case 0x14: str = "600 bit/s"; break;
                case 0x15: str = "1200/75 bit/s (1200 network-to-MS / 75 MS-to-network)"; break;
                case 0x39: str = "28,8 kbit/s"; break;
                case 0x3a: str = "32,0 kbit/s"; break;
                default:
                    str = "Reserved";
                    break;
                }
            }
        }
        else
        {
            if (oct & 0x40)
            {
                switch (oct & 0x3f)
                {
                case 0x16: str = "58 kbit/s (4x14.5 kbit/s)"; break;
                case 0x14: str = "48.0 / 43.5 kbit/s (4x12 kbit/s or 3x14.5 kbit/s)"; break;
                case 0x13: str = "36.0 / 29.0 kbit/s (3x12 kbit/s or 2x14.5 kbit/s)"; break;
                case 0x12: str = "24.0 / 24.0 (4x6 kbit/s or 2x12 kbit/s)"; break;
                case 0x11: str = "18.0 / 14.5 kbit/s (3x6 kbit/s or 1x14.5 kbit/s)"; break;
                case 0x10: str = "12.0 / 12.0 kbit/s (2x6 kbit/s or 1x12 kbit/s)"; break;
                default:
                    str = "Reserved";
                    break;
                }
            }
            else
            {
                switch (oct & 0x3f)
                {
                case 0x1f: str = "64 kbit/s, bit transparent"; break;
                case 0x1e: str = "56 kbit/s, bit transparent"; break;
                case 0x1d: str = "56 kbit/s"; break;
                case 0x1c: str = "48 kbit/s"; break;
                case 0x1b: str = "38.4 kbit/s"; break;
                case 0x1a: str = "28.8 kbit/s"; break;
                case 0x19: str = "19.2 kbit/s"; break;
                case 0x18: str = "14.4 kbit/s"; break;
                case 0x10: str = "9.6 kbit/s"; break;
                default:
                    str = "Reserved";
                    break;
                }
            }
        }
        proto_tree_add_uint_format_value(tree, hf_gsm_a_bssmap_rate,
            tvb, curr_offset, 1, oct & 0x3f, "%s", str);
        curr_offset++;
        NO_MORE_DATA_CHECK(len);
        proto_tree_add_item(tree, hf_gsm_a_bssmap_chan_type_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
        proto_tree_add_bits_item(tree, hf_gsm_a_bssmap_spare_bits, tvb, (curr_offset<<3)+1, 3, ENC_BIG_ENDIAN);
        if (num_chan == 0)
        {
            proto_tree_add_item(tree, hf_gsm_a_bssmap_tch_14_5kb, tvb, curr_offset, 1, ENC_NA);
            proto_tree_add_bits_item(tree, hf_gsm_a_bssmap_spare_bits, tvb, (curr_offset<<3)+6, 1, ENC_BIG_ENDIAN);
            proto_tree_add_item(tree, hf_gsm_a_bssmap_tch_12kb, tvb, curr_offset, 1, ENC_NA);
            proto_tree_add_item(tree, hf_gsm_a_bssmap_tch_6kb, tvb, curr_offset, 1, ENC_NA);
        }
        else
        {
            proto_tree_add_item(tree, hf_gsm_a_bssmap_tch_14_5_14_4kb, tvb, curr_offset, 1, ENC_NA);
            proto_tree_add_bits_item(tree, hf_gsm_a_bssmap_spare_bits, tvb, (curr_offset<<3)+6, 1, ENC_BIG_ENDIAN);
            proto_tree_add_item(tree, hf_gsm_a_bssmap_tch_12_9kb, tvb, curr_offset, 1, ENC_NA);
            proto_tree_add_item(tree, hf_gsm_a_bssmap_tch_6_4_8kb, tvb, curr_offset, 1, ENC_NA);
        }
        curr_offset++;
    }
    else if (sdi == 0x03)
    {
        proto_tree_add_item(tree, hf_gsm_a_bssmap_data_channel_rate_and_type,
            tvb, curr_offset, 1, ENC_NA);
        curr_offset++;
        NO_MORE_DATA_CHECK(len);
        proto_tree_add_item(tree, hf_gsm_a_bssmap_spare, tvb, curr_offset, len - (curr_offset - offset), ENC_NA);
        curr_offset += len - (curr_offset - offset);
    }
    else
    {
        proto_tree_add_item(tree, hf_gsm_a_bssmap_unknown_format, tvb, curr_offset, len - (curr_offset - offset), ENC_NA);
        curr_offset += len - (curr_offset - offset);
    }
    EXTRANEOUS_DATA_CHECK(len, curr_offset - offset, pinfo, &ei_gsm_a_bssmap_extraneous_data);
    return curr_offset-offset;
}
