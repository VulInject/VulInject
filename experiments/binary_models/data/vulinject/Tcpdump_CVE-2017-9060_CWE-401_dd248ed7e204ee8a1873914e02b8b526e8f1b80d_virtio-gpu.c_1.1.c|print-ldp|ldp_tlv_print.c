ldp_tlv_print(netdissect_options *ndo,
              const u_char *tptr,
              u_int msg_tlen)
{
    struct ldp_tlv_header {
        nd_uint16_t type;
        nd_uint16_t length;
    };
    const struct ldp_tlv_header *ldp_tlv_header;
    u_short tlv_type,tlv_len,tlv_tlen,af,ft_flags;
    u_char fec_type, transport_pref;
    u_int ui,vc_info_len, vc_info_tlv_type, vc_info_tlv_len,idx;
    char buf[100];
    int i;
    ldp_tlv_header = (const struct ldp_tlv_header *)tptr;
    tlv_len=GET_BE_U_2(ldp_tlv_header->length);
    if (tlv_len + 4U > msg_tlen) {
        ND_PRINT("\n\t\t TLV contents go past end of message");
        return 0;
    }
    tlv_tlen=tlv_len;
    tlv_type=LDP_MASK_TLV_TYPE(GET_BE_U_2(ldp_tlv_header->type));
    ND_PRINT("\n\t    %s TLV (0x%04x), length: %u, Flags: [%s and %s forward if unknown]",
           tok2str(ldp_tlv_values,
                   "Unknown",
                   tlv_type),
           tlv_type,
           tlv_len,
           LDP_MASK_U_BIT(GET_BE_U_2(ldp_tlv_header->type)) ? "continue processing" : "ignore",
           LDP_MASK_F_BIT(GET_BE_U_2(ldp_tlv_header->type)) ? "do" : "don't");
    tptr+=sizeof(struct ldp_tlv_header);
    switch(tlv_type) {
    case LDP_TLV_COMMON_HELLO:
        ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 4);
        ND_PRINT("\n\t      Hold Time: %us, Flags: [%s Hello%s]",
               GET_BE_U_2(tptr),
               (GET_BE_U_2(tptr + 2)&0x8000) ? "Targeted" : "Link",
               (GET_BE_U_2(tptr + 2)&0x4000) ? ", Request for targeted Hellos" : "");
        break;
    case LDP_TLV_IPV4_TRANSPORT_ADDR:
        ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 4);
        ND_PRINT("\n\t      IPv4 Transport Address: %s", GET_IPADDR_STRING(tptr));
        break;
    case LDP_TLV_IPV6_TRANSPORT_ADDR:
        ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 16);
        ND_PRINT("\n\t      IPv6 Transport Address: %s", GET_IP6ADDR_STRING(tptr));
        break;
    case LDP_TLV_CONFIG_SEQ_NUMBER:
        ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 4);
        ND_PRINT("\n\t      Sequence Number: %u", GET_BE_U_4(tptr));
        break;
    case LDP_TLV_ADDRESS_LIST:
        ND_ICHECKMSG_U("tlv length", tlv_tlen, <,
                       LDP_TLV_ADDRESS_LIST_AFNUM_LEN);
	af = GET_BE_U_2(tptr);
	tptr+=LDP_TLV_ADDRESS_LIST_AFNUM_LEN;
        tlv_tlen -= LDP_TLV_ADDRESS_LIST_AFNUM_LEN;
	ND_PRINT("\n\t      Address Family: %s, addresses",
               tok2str(af_values, "Unknown (%u)", af));
        switch (af) {
        case AFNUM_IP:
	    while(tlv_tlen >= sizeof(nd_ipv4)) {
		ND_PRINT(" %s", GET_IPADDR_STRING(tptr));
		tlv_tlen-=sizeof(nd_ipv4);
		tptr+=sizeof(nd_ipv4);
	    }
            break;
        case AFNUM_IP6:
	    while(tlv_tlen >= sizeof(nd_ipv6)) {
		ND_PRINT(" %s", GET_IP6ADDR_STRING(tptr));
		tlv_tlen-=sizeof(nd_ipv6);
		tptr+=sizeof(nd_ipv6);
	    }
            break;
        default:
            break;
        }
	break;
    case LDP_TLV_HOP_COUNT:
	ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 1);
	ND_PRINT("\n\t      Hop Count: %u", GET_U_1(tptr));
	break;
    case LDP_TLV_PATH_VECTOR:
	ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 4);
	ND_PRINT("\n\t      Path Vector: %s", GET_IPADDR_STRING(tptr));
	tptr += 4;
	tlv_tlen -= 4;
	while (tlv_tlen >= 4) {
	    ND_PRINT(", %s", GET_IPADDR_STRING(tptr));
	    tptr += 4;
	    tlv_tlen -= 4;
	}
	break;
    case LDP_TLV_COMMON_SESSION:
	ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 14);
	ND_PRINT("\n\t      Version: %u, Keepalive: %us, Flags: [Downstream %s, Loop Detection %s]",
	       GET_BE_U_2(tptr), GET_BE_U_2(tptr + 2),
	       (GET_BE_U_2(tptr + 4)&0x8000) ? "On Demand" : "Unsolicited",
	       (GET_BE_U_2(tptr + 4)&0x4000) ? "Enabled" : "Disabled"
	       );
	ND_PRINT("\n\t      Path Vector Limit %u, Max-PDU length: %u, Receiver Label-Space-ID %s:%u",
	       GET_U_1(tptr+5),
	       GET_BE_U_2(tptr+6),
	       GET_IPADDR_STRING(tptr+8),
	       GET_BE_U_2(tptr+12)
	       );
	break;
    case LDP_TLV_FEC:
        ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 1);
        fec_type = GET_U_1(tptr);
	ND_PRINT("\n\t      %s FEC (0x%02x)",
	       tok2str(ldp_fec_values, "Unknown", fec_type),
	       fec_type);
	tptr+=1;
	tlv_tlen-=1;
	switch(fec_type) {
	case LDP_FEC_WILDCARD:
	    break;
	case LDP_FEC_PREFIX:
	    ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 2);
	    af = GET_BE_U_2(tptr);
	    tptr+=2;
	    tlv_tlen-=2;
	    if (af == AFNUM_IP) {
		i=decode_prefix4(ndo, tptr, tlv_tlen, buf, sizeof(buf));
		if (i == -2)
		    goto trunc;
		if (i == -3)
		    ND_PRINT(": IPv4 prefix (goes past end of TLV)");
		else if (i == -1)
		    ND_PRINT(": IPv4 prefix (invalid length)");
		else
		    ND_PRINT(": IPv4 prefix %s", buf);
	    } else if (af == AFNUM_IP6) {
		i=decode_prefix6(ndo, tptr, tlv_tlen, buf, sizeof(buf));
		if (i == -2)
		    goto trunc;
		if (i == -3)
		    ND_PRINT(": IPv4 prefix (goes past end of TLV)");
		else if (i == -1)
		    ND_PRINT(": IPv6 prefix (invalid length)");
		else
		    ND_PRINT(": IPv6 prefix %s", buf);
	    } else
		ND_PRINT(": Address family %u prefix", af);
	    break;
	case LDP_FEC_HOSTADDRESS:
	    break;
	case LDP_FEC_MARTINI_VC:
            ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 7);
            vc_info_len = GET_U_1(tptr + 2);
            if (vc_info_len == 0) {
                ND_PRINT(": %s, %scontrol word, group-ID %u, VC-info-length: %u",
                       tok2str(mpls_pw_types_values, "Unknown", GET_BE_U_2(tptr)&0x7fff),
                       GET_BE_U_2(tptr)&0x8000 ? "" : "no ",
                       GET_BE_U_4(tptr + 3),
                       vc_info_len);
                break;
            }
            ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 11);
	    ND_PRINT(": %s, %scontrol word, group-ID %u, VC-ID %u, VC-info-length: %u",
		   tok2str(mpls_pw_types_values, "Unknown", GET_BE_U_2(tptr)&0x7fff),
		   GET_BE_U_2(tptr)&0x8000 ? "" : "no ",
		   GET_BE_U_4(tptr + 3),
		   GET_BE_U_4(tptr + 7),
		   vc_info_len);
            if (vc_info_len < 4) {
                ND_PRINT(" (invalid, < 4");
                return(tlv_len+4); 
	    }
            vc_info_len -= 4; 
            tptr+=11;
            tlv_tlen-=11;
            ND_ICHECKMSG_U("tlv length", tlv_tlen, <, vc_info_len);
            while (vc_info_len > 2) {
                vc_info_tlv_type = GET_U_1(tptr);
                vc_info_tlv_len = GET_U_1(tptr + 1);
                if (vc_info_tlv_len < 2)
                    break;
                if (vc_info_len < vc_info_tlv_len)
                    break;
                ND_PRINT("\n\t\tInterface Parameter: %s (0x%02x), len %u",
                       tok2str(ldp_fec_martini_ifparm_values,"Unknown",vc_info_tlv_type),
                       vc_info_tlv_type,
                       vc_info_tlv_len);
                switch(vc_info_tlv_type) {
                case LDP_FEC_MARTINI_IFPARM_MTU:
                    ND_PRINT(": %u", GET_BE_U_2(tptr + 2));
                    break;
                case LDP_FEC_MARTINI_IFPARM_DESC:
                    ND_PRINT(": ");
                    for (idx = 2; idx < vc_info_tlv_len; idx++)
                        fn_print_char(ndo, GET_U_1(tptr + idx));
                    break;
                case LDP_FEC_MARTINI_IFPARM_VCCV:
                    ND_PRINT("\n\t\t  Control Channels (0x%02x) = [%s]",
                           GET_U_1((tptr + 2)),
                           bittok2str(ldp_fec_martini_ifparm_vccv_cc_values, "none", GET_U_1((tptr + 2))));
                    ND_PRINT("\n\t\t  CV Types (0x%02x) = [%s]",
                           GET_U_1((tptr + 3)),
                           bittok2str(ldp_fec_martini_ifparm_vccv_cv_values, "none", GET_U_1((tptr + 3))));
                    break;
                default:
                    print_unknown_data(ndo, tptr+2, "\n\t\t  ", vc_info_tlv_len-2);
                    break;
                }
                vc_info_len -= vc_info_tlv_len;
                tptr += vc_info_tlv_len;
            }
	    break;
	}
	break;
    case LDP_TLV_GENERIC_LABEL:
	ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 4);
	ND_PRINT("\n\t      Label: %u", GET_BE_U_4(tptr) & 0xfffff);
	break;
    case LDP_TLV_STATUS:
	ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 10);
	ui = GET_BE_U_4(tptr);
	tptr+=4;
	ND_PRINT("\n\t      Status Code: %s, Flags: [%s and %s forward]",
		 tok2str(ldp_status_code_values, "Unknown", ui&0x3fffffff),
		 ui&0x80000000 ? "Fatal error" : "Advisory Notification",
		 ui&0x40000000 ? "do" : "don't");
	ui = GET_BE_U_4(tptr);
	tptr+=4;
	if (ui)
	    ND_PRINT(", causing Message ID: 0x%08x", ui);
	ui = GET_BE_U_2(tptr);
	if (ui)
	    ND_PRINT(", Message Type: %s", tok2str(ldp_msg_values, "Unknown", ui));
	break;
    case LDP_TLV_FT_SESSION:
	ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 12);
	ft_flags = GET_BE_U_2(tptr);
	ND_PRINT("\n\t      Flags: [%sReconnect, %sSave State, %sAll-Label Protection, %s Checkpoint, %sRe-Learn State]",
	       ft_flags&0x8000 ? "" : "No ",
	       ft_flags&0x8 ? "" : "Don't ",
	       ft_flags&0x4 ? "" : "No ",
	       ft_flags&0x2 ? "Sequence Numbered Label" : "All Labels",
	       ft_flags&0x1 ? "" : "Don't ");
	tptr+=4;
	ui = GET_BE_U_4(tptr);
	if (ui)
	    ND_PRINT(", Reconnect Timeout: %ums", ui);
	tptr+=4;
	ui = GET_BE_U_4(tptr);
	if (ui)
	    ND_PRINT(", Recovery Time: %ums", ui);
	break;
    case LDP_TLV_TYPED_WC_FEC_CAP:
	ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 1);
	ND_PRINT("\n\t      %s", GET_U_1(tptr)&0x80 ? "Support" : "No Support");
	break;
    case LDP_TLV_MTU:
	ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 2);
	ND_PRINT("\n\t      MTU: %u", GET_BE_U_2(tptr));
	break;
    case LDP_TLV_DUAL_STACK_CAP:
	ND_ICHECKMSG_U("tlv length", tlv_tlen, <, 4);
	transport_pref = GET_U_1(tptr);
	ND_PRINT("\n\t      Transport Connection Preference: %s",
		 tok2str(ldp_dual_stack_transport_pref_values,
			 "Unknown",
			 transport_pref));
	break;
    case LDP_TLV_ATM_LABEL:
    case LDP_TLV_FR_LABEL:
    case LDP_TLV_EXTD_STATUS:
    case LDP_TLV_RETURNED_PDU:
    case LDP_TLV_RETURNED_MSG:
    case LDP_TLV_ATM_SESSION_PARM:
    case LDP_TLV_FR_SESSION_PARM:
    case LDP_TLV_LABEL_REQUEST_MSG_ID:
    default:
        if (ndo->ndo_vflag <= 1)
            print_unknown_data(ndo, tptr, "\n\t      ", tlv_tlen);
        break;
    }
    return(tlv_len+4); 
trunc:
    nd_trunc_longjmp(ndo);
invalid:
    nd_print_invalid(ndo);
    return(tlv_len+4); 
}
