static void dissect_rlc_lte_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean is_udp_framing)
{
    proto_tree             *rlc_lte_tree;
    proto_tree             *context_tree;
    proto_item             *top_ti;
    proto_item             *context_ti;
    proto_item             *ti;
    proto_item             *mode_ti;
    gint                   offset = 0;
    struct rlc_lte_info    *p_rlc_lte_info;
    rlc_3gpp_tap_info *tap_info = wmem_new0(pinfo->pool, rlc_3gpp_tap_info);
    tap_info->rat = RLC_RAT_LTE;
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "RLC-LTE");
    top_ti = proto_tree_add_item(tree, proto_rlc_lte, tvb, offset, -1, ENC_NA);
    rlc_lte_tree = proto_item_add_subtree(top_ti, ett_rlc_lte);
    p_rlc_lte_info = (rlc_lte_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rlc_lte, 0);
    if (p_rlc_lte_info == NULL) {
        proto_tree_add_expert(rlc_lte_tree, pinfo, &ei_rlc_lte_no_per_frame_info, tvb, offset, -1);
        return;
    }
    if (is_udp_framing) {
        col_clear(pinfo->cinfo, COL_INFO);
    }
    context_ti = proto_tree_add_string_format(rlc_lte_tree, hf_rlc_lte_context,
                                              tvb, offset, 0, "", "Context");
    context_tree = proto_item_add_subtree(context_ti, ett_rlc_lte_context);
    ti = proto_tree_add_uint(context_tree, hf_rlc_lte_context_direction,
                             tvb, 0, 0, p_rlc_lte_info->direction);
    proto_item_set_generated(ti);
    mode_ti = proto_tree_add_uint(context_tree, hf_rlc_lte_context_mode,
                                  tvb, 0, 0, p_rlc_lte_info->rlcMode);
    proto_item_set_generated(mode_ti);
    if (p_rlc_lte_info->ueid != 0) {
        ti = proto_tree_add_uint(context_tree, hf_rlc_lte_context_ueid,
                                 tvb, 0, 0, p_rlc_lte_info->ueid);
        proto_item_set_generated(ti);
    }
    if ((p_rlc_lte_info->priority >= 1) && (p_rlc_lte_info->priority <=16)) {
        ti = proto_tree_add_uint(context_tree, hf_rlc_lte_context_priority,
                                 tvb, 0, 0, p_rlc_lte_info->priority);
        proto_item_set_generated(ti);
    }
    ti = proto_tree_add_uint(context_tree, hf_rlc_lte_context_channel_type,
                             tvb, 0, 0, p_rlc_lte_info->channelType);
    proto_item_set_generated(ti);
    if ((p_rlc_lte_info->channelType == CHANNEL_TYPE_SRB) ||
        (p_rlc_lte_info->channelType == CHANNEL_TYPE_DRB) ||
        (p_rlc_lte_info->channelType == CHANNEL_TYPE_MTCH)) {
        ti = proto_tree_add_uint(context_tree, hf_rlc_lte_context_channel_id,
                                 tvb, 0, 0, p_rlc_lte_info->channelId);
        proto_item_set_generated(ti);
    }
    ti = proto_tree_add_uint(context_tree, hf_rlc_lte_context_pdu_length,
                             tvb, 0, 0, p_rlc_lte_info->pduLength);
    proto_item_set_generated(ti);
    if (p_rlc_lte_info->rlcMode == RLC_UM_MODE) {
        ti = proto_tree_add_uint(context_tree, hf_rlc_lte_context_um_sn_length,
                                 tvb, 0, 0, p_rlc_lte_info->sequenceNumberLength);
        proto_item_set_generated(ti);
    }
    if (p_rlc_lte_info->rlcMode == RLC_AM_MODE) {
        if (!p_rlc_lte_info->sequenceNumberLength) {
            p_rlc_lte_info->sequenceNumberLength = 10;
        }
        ti = proto_tree_add_uint(context_tree, hf_rlc_lte_context_am_sn_length,
                                 tvb, 0, 0, p_rlc_lte_info->sequenceNumberLength);
        proto_item_set_generated(ti);
    }
    if (p_rlc_lte_info->ueid != 0) {
        proto_item_append_text(top_ti, "   UEId=%u", p_rlc_lte_info->ueid);
        col_append_fstr(pinfo->cinfo, COL_INFO, "UEId=%-4u ", p_rlc_lte_info->ueid);
    }
    write_pdu_label_and_info(top_ti, NULL, pinfo,
                             " [%s] [%s] ",
                             (p_rlc_lte_info->direction == 0) ? "UL" : "DL",
                             val_to_str_const(p_rlc_lte_info->rlcMode, rlc_mode_short_vals, "Unknown"));
    if (p_rlc_lte_info->channelId == 0) {
        write_pdu_label_and_info(top_ti, NULL, pinfo, "%s   ",
                                 val_to_str_const(p_rlc_lte_info->channelType, rlc_channel_type_vals, "Unknown"));
    }
    else {
        write_pdu_label_and_info(top_ti, NULL, pinfo, "%s:%-2u",
                                 val_to_str_const(p_rlc_lte_info->channelType, rlc_channel_type_vals, "Unknown"),
                                 p_rlc_lte_info->channelId);
    }
    tap_info->rlcMode = p_rlc_lte_info->rlcMode;
    tap_info->direction = p_rlc_lte_info->direction;
    tap_info->priority = p_rlc_lte_info->priority;
    tap_info->ueid = p_rlc_lte_info->ueid;
    tap_info->channelType = p_rlc_lte_info->channelType;
    tap_info->channelId = p_rlc_lte_info->channelId;
    tap_info->pduLength = p_rlc_lte_info->pduLength;
    tap_info->sequenceNumberLength = p_rlc_lte_info->sequenceNumberLength;
    tap_info->loggedInMACFrame = (p_get_proto_data(wmem_file_scope(), pinfo, proto_mac_lte, 0) != NULL);
    tap_info->rlc_time = pinfo->abs_ts;
    s_number_of_extensions = 0;
    switch (p_rlc_lte_info->rlcMode) {
        case RLC_TM_MODE:
            dissect_rlc_lte_tm(tvb, pinfo, rlc_lte_tree, offset, p_rlc_lte_info, top_ti);
            break;
        case RLC_UM_MODE:
            dissect_rlc_lte_um(tvb, pinfo, rlc_lte_tree, offset, p_rlc_lte_info, top_ti,
                               tap_info);
            break;
        case RLC_AM_MODE:
            dissect_rlc_lte_am(tvb, pinfo, rlc_lte_tree, offset, p_rlc_lte_info, top_ti,
                               tap_info);
            break;
        case RLC_PREDEF:
            proto_tree_add_item(rlc_lte_tree, hf_rlc_lte_predefined_pdu, tvb, offset, -1, ENC_NA);
            write_pdu_label_and_info(top_ti, NULL, pinfo, "   [%u-bytes]",
                                     tvb_reported_length_remaining(tvb, offset));
            break;
        default:
            expert_add_info_format(pinfo, mode_ti, &ei_rlc_lte_context_mode,
                                   "Unrecognised RLC Mode set (%u)", p_rlc_lte_info->rlcMode);
            break;
    }
    tap_queue_packet(rlc_lte_tap, pinfo, tap_info);
}
