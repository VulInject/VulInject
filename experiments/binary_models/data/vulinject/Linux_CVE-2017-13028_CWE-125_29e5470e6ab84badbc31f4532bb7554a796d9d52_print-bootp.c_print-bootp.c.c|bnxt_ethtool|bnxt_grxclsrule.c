static int bnxt_grxclsrule(struct bnxt *bp, struct ethtool_rxnfc *cmd)
{
	struct ethtool_rx_flow_spec *fs =
		(struct ethtool_rx_flow_spec *)&cmd->fs;
	struct bnxt_filter_base *fltr_base;
	struct bnxt_ntuple_filter *fltr;
	struct bnxt_flow_masks *fmasks;
	struct flow_keys *fkeys;
	int rc = -EINVAL;
	if (fs->location >= bp->max_fltr)
		return rc;
	rcu_read_lock();
	fltr_base = bnxt_get_one_fltr_rcu(bp, bp->l2_fltr_hash_tbl,
					  BNXT_L2_FLTR_HASH_SIZE,
					  fs->location);
	if (fltr_base) {
		struct ethhdr *h_ether = &fs->h_u.ether_spec;
		struct ethhdr *m_ether = &fs->m_u.ether_spec;
		struct bnxt_l2_filter *l2_fltr;
		struct bnxt_l2_key *l2_key;
		l2_fltr = container_of(fltr_base, struct bnxt_l2_filter, base);
		l2_key = &l2_fltr->l2_key;
		fs->flow_type = ETHER_FLOW;
		ether_addr_copy(h_ether->h_dest, l2_key->dst_mac_addr);
		if (l2_key->vlan) {
			struct ethtool_flow_ext *m_ext = &fs->m_ext;
			struct ethtool_flow_ext *h_ext = &fs->h_ext;
			fs->flow_type |= FLOW_EXT;
			m_ext->vlan_tci = htons(0xfff);
			h_ext->vlan_tci = htons(l2_key->vlan);
		}
		if (fltr_base->flags & BNXT_ACT_RING_DST)
			fs->ring_cookie = fltr_base->rxq;
		if (fltr_base->flags & BNXT_ACT_FUNC_DST)
			fs->ring_cookie = (unsigned int int)(fltr_base->vf_idx + 1) <<
					  ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF;
		rcu_read_unlock();
		return 0;
	}
	fltr_base = bnxt_get_one_fltr_rcu(bp, bp->ntp_fltr_hash_tbl,
					  BNXT_NTP_FLTR_HASH_SIZE,
					  fs->location);
	if (!fltr_base) {
		rcu_read_unlock();
		return rc;
	}
	fltr = container_of(fltr_base, struct bnxt_ntuple_filter, base);
	fkeys = &fltr->fkeys;
	fmasks = &fltr->fmasks;
	if (fkeys->basic.n_proto == htons(ETH_P_IP)) {
		if (fkeys->basic.ip_proto == IPPROTO_ICMP ||
		    fkeys->basic.ip_proto == IPPROTO_RAW) {
			fs->flow_type = IP_USER_FLOW;
			fs->h_u.usr_ip4_spec.ip_ver = ETH_RX_NFC_IP4;
			if (fkeys->basic.ip_proto == IPPROTO_ICMP)
				fs->h_u.usr_ip4_spec.proto = IPPROTO_ICMP;
			else
				fs->h_u.usr_ip4_spec.proto = IPPROTO_RAW;
			fs->m_u.usr_ip4_spec.proto = BNXT_IP_PROTO_FULL_MASK;
		} else if (fkeys->basic.ip_proto == IPPROTO_TCP) {
			fs->flow_type = TCP_V4_FLOW;
		} else if (fkeys->basic.ip_proto == IPPROTO_UDP) {
			fs->flow_type = UDP_V4_FLOW;
		} else {
			goto fltr_err;
		}
		fs->h_u.tcp_ip4_spec.ip4src = fkeys->addrs.v4addrs.src;
		fs->m_u.tcp_ip4_spec.ip4src = fmasks->addrs.v4addrs.src;
		fs->h_u.tcp_ip4_spec.ip4dst = fkeys->addrs.v4addrs.dst;
		fs->m_u.tcp_ip4_spec.ip4dst = fmasks->addrs.v4addrs.dst;
		if (fs->flow_type == TCP_V4_FLOW ||
		    fs->flow_type == UDP_V4_FLOW) {
			fs->h_u.tcp_ip4_spec.psrc = fkeys->ports.src;
			fs->m_u.tcp_ip4_spec.psrc = fmasks->ports.src;
			fs->h_u.tcp_ip4_spec.pdst = fkeys->ports.dst;
			fs->m_u.tcp_ip4_spec.pdst = fmasks->ports.dst;
		}
	} else {
		if (fkeys->basic.ip_proto == IPPROTO_ICMPV6 ||
		    fkeys->basic.ip_proto == IPPROTO_RAW) {
			fs->flow_type = IPV6_USER_FLOW;
			if (fkeys->basic.ip_proto == IPPROTO_ICMPV6)
				fs->h_u.usr_ip6_spec.l4_proto = IPPROTO_ICMPV6;
			else
				fs->h_u.usr_ip6_spec.l4_proto = IPPROTO_RAW;
			fs->m_u.usr_ip6_spec.l4_proto = BNXT_IP_PROTO_FULL_MASK;
		} else if (fkeys->basic.ip_proto == IPPROTO_TCP) {
			fs->flow_type = TCP_V6_FLOW;
		} else if (fkeys->basic.ip_proto == IPPROTO_UDP) {
			fs->flow_type = UDP_V6_FLOW;
		} else {
			goto fltr_err;
		}
		*(struct in6_addr *)&fs->h_u.tcp_ip6_spec.ip6src[0] =
			fkeys->addrs.v6addrs.src;
		*(struct in6_addr *)&fs->m_u.tcp_ip6_spec.ip6src[0] =
			fmasks->addrs.v6addrs.src;
		*(struct in6_addr *)&fs->h_u.tcp_ip6_spec.ip6dst[0] =
			fkeys->addrs.v6addrs.dst;
		*(struct in6_addr *)&fs->m_u.tcp_ip6_spec.ip6dst[0] =
			fmasks->addrs.v6addrs.dst;
		if (fs->flow_type == TCP_V6_FLOW ||
		    fs->flow_type == UDP_V6_FLOW) {
			fs->h_u.tcp_ip6_spec.psrc = fkeys->ports.src;
			fs->m_u.tcp_ip6_spec.psrc = fmasks->ports.src;
			fs->h_u.tcp_ip6_spec.pdst = fkeys->ports.dst;
			fs->m_u.tcp_ip6_spec.pdst = fmasks->ports.dst;
		}
	}
	if (fltr->base.flags & BNXT_ACT_DROP)
		fs->ring_cookie = RX_CLS_FLOW_DISC;
	else
		fs->ring_cookie = fltr->base.rxq;
	rc = 0;
fltr_err:
	rcu_read_unlock();
	return rc;
}
