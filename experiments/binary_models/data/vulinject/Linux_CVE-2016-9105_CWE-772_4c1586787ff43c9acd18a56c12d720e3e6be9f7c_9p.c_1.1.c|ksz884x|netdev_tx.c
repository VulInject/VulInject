static netdev_tx_t netdev_tx(struct sk_buff *skb, struct net_device *dev)
{
	struct dev_priv *priv = netdev_priv(dev);
	struct dev_info *hw_priv = priv->adapter;
	struct ksz_hw *hw = &hw_priv->hw;
	int left;
	int num = 1;
	int rc = 0;
	if (hw->features & SMALL_PACKET_TX_BUG) {
		struct sk_buff *org_skb = skb;
		if (skb->len <= 48) {
			if (skb_end_pointer(skb) - skb->data >= 50) {
				memset(&skb->data[skb->len], 0, 50 - skb->len);
				skb->len = 50;
			} else {
				skb = netdev_alloc_skb(dev, 50);
				if (!skb)
					return NETDEV_TX_BUSY;
				memcpy(skb->data, org_skb->data, org_skb->len);
				memset(&skb->data[org_skb->len], 0,
					50 - org_skb->len);
				skb->len = 50;
			}
		}
	}
	spin_lock_irq(&hw_priv->hwlock);
	num = skb_shinfo(skb)->nr_frags + 1;
	left = hw_alloc_pkt(hw, skb->len, num);
	if (left) {
		if (left < num ||
		    (CHECKSUM_PARTIAL == skb->ip_summed &&
		     skb->protocol == htons(ETH_P_IPV6))) {
			struct sk_buff *org_skb = skb;
			skb = netdev_alloc_skb(dev, org_skb->len);
			if (!skb) {
				rc = NETDEV_TX_BUSY;
				goto unlock;
			}
			skb_copy_and_csum_dev(org_skb, skb->data);
			org_skb->ip_summed = CHECKSUM_NONE;
			skb->len = org_skb->len;
			copy_old_skb(org_skb, skb);
		}
		send_packet(skb, dev);
		if (left <= num)
			netif_stop_queue(dev);
	} else {
		netif_stop_queue(dev);
		rc = NETDEV_TX_BUSY;
	}
unlock:
	spin_unlock_irq(&hw_priv->hwlock);
	return rc;
}
