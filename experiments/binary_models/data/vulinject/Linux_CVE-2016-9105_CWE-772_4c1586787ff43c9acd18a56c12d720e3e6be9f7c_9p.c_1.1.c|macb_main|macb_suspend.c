static int __maybe_unused macb_suspend(struct device *dev)
{
	struct net_device *netdev = dev_get_drvdata(dev);
	struct macb *bp = netdev_priv(netdev);
	struct macb_queue *queue;
	unsigned int flags;
	unsigned int q;
	int err;
	if (!device_may_wakeup(&bp->dev->dev))
		phy_exit(bp->sgmii_phy);
	if (!netif_running(netdev))
		return 0;
	if (bp->wol & MACB_WOL_ENABLED) {
		spin_lock_irqsave(&bp->lock, flags);
		macb_writel(bp, TSR, -1);
		macb_writel(bp, RSR, -1);
		for (q = 0, queue = bp->queues; q < bp->num_queues;
		     ++q, ++queue) {
			queue_writel(queue, IDR, -1);
			if (bp->caps & MACB_CAPS_ISR_CLEAR_ON_WRITE)
				queue_writel(queue, ISR, -1);
		}
		devm_free_irq(dev, bp->queues[0].irq, bp->queues);
		if (macb_is_gem(bp)) {
			err = devm_request_irq(dev, bp->queues[0].irq, gem_wol_interrupt,
					       IRQF_SHARED, netdev->name, bp->queues);
			if (err) {
				dev_err(dev,
					"Unable to request IRQ %d (error %d)\n",
					bp->queues[0].irq, err);
				spin_unlock_irqrestore(&bp->lock, flags);
				return err;
			}
			queue_writel(bp->queues, IER, GEM_BIT(WOL));
			gem_writel(bp, WOL, MACB_BIT(MAG));
		} else {
			err = devm_request_irq(dev, bp->queues[0].irq, macb_wol_interrupt,
					       IRQF_SHARED, netdev->name, bp->queues);
			if (err) {
				dev_err(dev,
					"Unable to request IRQ %d (error %d)\n",
					bp->queues[0].irq, err);
				spin_unlock_irqrestore(&bp->lock, flags);
				return err;
			}
			queue_writel(bp->queues, IER, MACB_BIT(WOL));
			macb_writel(bp, WOL, MACB_BIT(MAG));
		}
		spin_unlock_irqrestore(&bp->lock, flags);
		enable_irq_wake(bp->queues[0].irq);
	}
	netif_device_detach(netdev);
	for (q = 0, queue = bp->queues; q < bp->num_queues;
	     ++q, ++queue) {
		napi_disable(&queue->napi_rx);
		napi_disable(&queue->napi_tx);
	}
	if (!(bp->wol & MACB_WOL_ENABLED)) {
		rtnl_lock();
		phylink_stop(bp->phylink);
		rtnl_unlock();
		spin_lock_irqsave(&bp->lock, flags);
		macb_reset_hw(bp);
		spin_unlock_irqrestore(&bp->lock, flags);
	}
	if (!(bp->caps & MACB_CAPS_USRIO_DISABLED))
		bp->pm_data.usrio = macb_or_gem_readl(bp, USRIO);
	if (netdev->hw_features & NETIF_F_NTUPLE)
		bp->pm_data.scrt2 = gem_readl_n(bp, ETHT, SCRT2_ETHT);
	if (bp->ptp_info)
		bp->ptp_info->ptp_remove(netdev);
	if (!device_may_wakeup(dev))
		pm_runtime_force_suspend(dev);
	return 0;
}
