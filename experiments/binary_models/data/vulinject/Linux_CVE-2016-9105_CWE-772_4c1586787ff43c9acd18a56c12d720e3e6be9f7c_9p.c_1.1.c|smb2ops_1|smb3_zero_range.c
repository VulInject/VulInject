static int smb3_zero_range(struct file *file, struct cifs_tcon *tcon,
			    loff_t offset, loff_t len, bool keep_size)
{
	struct cifs_ses *ses = tcon->ses;
	struct inode *inode = file_inode(file);
	struct cifsInodeInfo *cifsi = CIFS_I(inode);
	struct cifsFileInfo *cfile = file->private_data;
	unsigned int int new_size;
	int rc;
	unsigned int xid;
	xid = get_xid();
	trace_smb3_zero_enter(xid, cfile->fid.persistent_fid, tcon->tid,
			      ses->Suid, offset, len);
	inode_lock(inode);
	filemap_invalidate_lock(inode->i_mapping);
	truncate_pagecache_range(inode, offset, offset + len - 1);
	rc = -EOPNOTSUPP;
	if (keep_size == false && !CIFS_CACHE_READ(cifsi))
		goto zero_range_exit;
	rc = smb3_zero_data(file, tcon, offset, len, xid);
	if (rc < 0)
		goto zero_range_exit;
	new_size = offset + len;
	if (keep_size == false && (unsigned int int)i_size_read(inode) < new_size) {
		rc = SMB2_set_eof(xid, tcon, cfile->fid.persistent_fid,
				  cfile->fid.volatile_fid, cfile->pid, new_size);
		if (rc >= 0) {
			netfs_resize_file(&cifsi->netfs, new_size, true);
			if (offset < cifsi->netfs.zero_point)
				cifsi->netfs.zero_point = offset;
			fscache_resize_cookie(cifs_inode_cookie(inode), new_size);
		}
	}
 zero_range_exit:
	filemap_invalidate_unlock(inode->i_mapping);
	inode_unlock(inode);
	free_xid(xid);
	if (rc)
		trace_smb3_zero_err(xid, cfile->fid.persistent_fid, tcon->tid,
			      ses->Suid, offset, len, rc);
	else
		trace_smb3_zero_done(xid, cfile->fid.persistent_fid, tcon->tid,
			      ses->Suid, offset, len);
	return rc;
}
