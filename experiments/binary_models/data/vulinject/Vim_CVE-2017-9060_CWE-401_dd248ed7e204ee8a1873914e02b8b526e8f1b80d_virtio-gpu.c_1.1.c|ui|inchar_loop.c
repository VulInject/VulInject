inchar_loop(
    char_u	*buf,
    int		maxlen,
    int	wtime,	    
    int		tb_change_cnt,
    int		(*wait_func)(int wtime, int *interrupted, int ignore_input),
    int		(*resize_func)(int check_only))
{
    int		len;
    int		interrupted = FALSE;
    int		did_call_wait_func = FALSE;
    int		did_start_blocking = FALSE;
    int	wait_time;
    int	elapsed_time = 0;
#ifdef ELAPSED_FUNC
    elapsed_T	start_tv;
#endif
    for (;;)
    {
	if (resize_func != NULL)
	    resize_func(FALSE);
#ifdef MESSAGE_QUEUE
	if (wtime != 0)
	{
	    parse_queued_messages();
	    if (typebuf_changed(tb_change_cnt))
		return 0;
	}
#endif
	if (wtime < 0 && did_start_blocking)
	    wait_time = -1;
	else
	{
	    if (wtime >= 0)
		wait_time = wtime;
	    else
		wait_time = p_ut;
#ifdef ELAPSED_FUNC
	    elapsed_time = ELAPSED_FUNC(start_tv);
#endif
	    wait_time -= elapsed_time;
	    if (wait_time <= 0 && did_call_wait_func)
	    {
		if (wtime >= 0)
		    return 0;
		did_start_blocking = TRUE;
		if (trigger_cursorhold() && maxlen >= 3
					    && !typebuf_changed(tb_change_cnt))
		{
		    if (buf == NULL)
		    {
			char_u	ibuf[3];
			ibuf[0] = CSI;
			ibuf[1] = KS_EXTRA;
			ibuf[2] = (int)KE_CURSORHOLD;
			add_to_input_buf(ibuf, 3);
		    }
		    else
		    {
			buf[0] = K_SPECIAL;
			buf[1] = KS_EXTRA;
			buf[2] = (int)KE_CURSORHOLD;
		    }
		    return 3;
		}
		before_blocking();
		continue;
	    }
	}
#ifdef FEAT_JOB_CHANNEL
	if (wait_time < 0 || wait_time > 100L)
	{
	    if (has_pending_job())
		wait_time = 100L;
	    if (channel_any_readahead())
		wait_time = 10L;
	}
#endif
#ifdef FEAT_BEVAL_GUI
	if (p_beval && wait_time > 100L)
	    wait_time = 100L;
#endif
	did_call_wait_func = TRUE;
	if (wait_func(wait_time, &interrupted, FALSE))
	{
	    if (typebuf_changed(tb_change_cnt))
		return 0;
	    if (buf == NULL)
		return input_available();
	    len = read_from_input_buf(buf, (int)maxlen);
	    if (len > 0)
		return len;
	    continue;
	}
#ifndef ELAPSED_FUNC
	elapsed_time += wait_time;
#endif
	if ((resize_func != NULL && resize_func(TRUE))
#if defined(FEAT_CLIENTSERVER) && defined(UNIX)
		|| server_waiting()
#endif
#ifdef MESSAGE_QUEUE
		|| interrupted
#endif
		|| wait_time > 0
		|| (wtime < 0 && !did_start_blocking))
	    continue;
	break;
    }
    return 0;
}
