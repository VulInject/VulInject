static int stm32_adc_probe_identification(struct platform_device *pdev,
					  struct stm32_adc_priv *priv)
{
	struct device_node *np = pdev->dev.of_node;
	struct device_node *child;
	const char *compat;
	int ret, count;
	unsigned int id, val;
	if (!priv->cfg->ipid)
		return 0;
	id = FIELD_GET(STM32MP1_IPIDR_MASK,
		       readl_relaxed(priv->common.base + STM32MP1_ADC_IPDR));
	if (id != priv->cfg->ipid) {
		dev_err(&pdev->dev, "Unexpected IP version: 0x%x", id);
		return -EINVAL;
	}
	for_each_child_of_node(np, child) {
		ret = of_property_read_string(child, "compatible", &compat);
		if (ret)
			continue;
		if (strstr(compat, "st,stm32") && strstr(compat, "adc"))
			count++;
	}
	val = readl_relaxed(priv->common.base + STM32MP1_ADC_HWCFGR0);
	priv->nb_adc_max = FIELD_GET(STM32MP1_ADCNUM_MASK, val);
	if (count > priv->nb_adc_max) {
		dev_err(&pdev->dev, "Unexpected child number: %d", count);
		return -EINVAL;
	}
	val = readl_relaxed(priv->common.base + STM32MP1_ADC_VERR);
	dev_dbg(&pdev->dev, "ADC version: %lu.%lu\n",
		FIELD_GET(STM32MP1_MAJREV_MASK, val),
		FIELD_GET(STM32MP1_MINREV_MASK, val));
	return 0;
}
