bcm_li_print(netdissect_options *ndo,
             const u_char *bp, u_int length)
{
	u_int shim, direction, pkt_type, pkt_subtype, li_id;
	ndo->ndo_protocol = "bcm_li";
	if (length < BCM_LI_SHIM_LEN) {
	    ND_PRINT(" (length %u < %u)", length, BCM_LI_SHIM_LEN);
	    goto invalid;
	}
	shim = GET_BE_U_4(bp);
	direction = (shim >> 29) & 0x7;
	pkt_type = (shim >> 25) & 0xf;
	pkt_subtype = (shim >> 22) & 0x7;
	li_id = shim & 0x3fffff;
	length -= BCM_LI_SHIM_LEN;
	bp += BCM_LI_SHIM_LEN;
	ND_PRINT("%sBCM-LI-SHIM: direction %s, pkt-type %s, pkt-subtype %s, li-id %u%s",
		 ndo->ndo_vflag ? "\n    " : "",
		 tok2str(bcm_li_direction_values, "unknown", direction),
		 tok2str(bcm_li_pkt_type_values, "unknown", pkt_type),
		 tok2str(bcm_li_pkt_subtype_values, "unknown", pkt_subtype),
		 li_id,
		 ndo->ndo_vflag ? "\n    ": "");
	if (!ndo->ndo_vflag) {
	    return;
	}
	switch (pkt_type) {
	case BCM_LI_PKT_TYPE_ETHERNET:
	    ether_print(ndo, bp, length, ND_BYTES_AVAILABLE_AFTER(bp), NULL, NULL);
	    break;
	case BCM_LI_PKT_TYPE_IPV4:
	    ip_print(ndo, bp, length);
	    break;
	case BCM_LI_PKT_TYPE_IPV6:
	    ip6_print(ndo, bp, length);
	    break;
	case BCM_LI_PKT_TYPE_UNDECIDED:
	    if ((GET_U_1(bp) >> 4) == 4) {
		ip_print(ndo, bp, length);
	    } else if ((GET_U_1(bp) >> 4) == 6) {
		ip6_print(ndo, bp, length);
	    } else {
		ND_PRINT("unknown payload");
	    }
	    break;
	default:
	    goto invalid;
	}
	return;
invalid:
	nd_print_invalid(ndo);
}
