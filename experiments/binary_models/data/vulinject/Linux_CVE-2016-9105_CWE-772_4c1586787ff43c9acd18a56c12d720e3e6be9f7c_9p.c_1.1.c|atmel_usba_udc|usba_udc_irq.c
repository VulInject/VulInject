static irqreturn_t usba_udc_irq(int irq, void *devid)
{
	struct usba_udc *udc = devid;
	unsigned int status, int_enb;
	unsigned int dma_status;
	unsigned int ep_status;
	spin_lock(&udc->lock);
	int_enb = usba_int_enb_get(udc);
	status = usba_readl(udc, INT_STA) & (int_enb | USBA_HIGH_SPEED);
	DBG(DBG_INT, "irq, status=%#08x\n", status);
	if (status & USBA_DET_SUSPEND) {
		usba_writel(udc, INT_CLR, USBA_DET_SUSPEND|USBA_WAKE_UP);
		usba_int_enb_clear(udc, USBA_DET_SUSPEND);
		udc->suspended = true;
		toggle_bias(udc, 0);
		udc->bias_pulse_needed = true;
		stop_clock(udc);
		DBG(DBG_BUS, "Suspend detected\n");
		if (udc->gadget.speed != USB_SPEED_UNKNOWN
				&& udc->driver && udc->driver->suspend) {
			spin_unlock(&udc->lock);
			udc->driver->suspend(&udc->gadget);
			spin_lock(&udc->lock);
		}
	}
	if (status & USBA_WAKE_UP) {
		start_clock(udc);
		toggle_bias(udc, 1);
		usba_writel(udc, INT_CLR, USBA_WAKE_UP);
		DBG(DBG_BUS, "Wake Up CPU detected\n");
	}
	if (status & USBA_END_OF_RESUME) {
		udc->suspended = false;
		usba_writel(udc, INT_CLR, USBA_END_OF_RESUME);
		usba_int_enb_clear(udc, USBA_WAKE_UP);
		usba_int_enb_set(udc, USBA_DET_SUSPEND);
		generate_bias_pulse(udc);
		DBG(DBG_BUS, "Resume detected\n");
		if (udc->gadget.speed != USB_SPEED_UNKNOWN
				&& udc->driver && udc->driver->resume) {
			spin_unlock(&udc->lock);
			udc->driver->resume(&udc->gadget);
			spin_lock(&udc->lock);
		}
	}
	dma_status = USBA_BFEXT(DMA_INT, status);
	if (dma_status) {
		int i;
		usba_int_enb_set(udc, USBA_DET_SUSPEND);
		for (i = 1; i <= USBA_NR_DMAS; i++)
			if (dma_status & (1 << i))
				usba_dma_irq(udc, &udc->usba_ep[i]);
	}
	ep_status = USBA_BFEXT(EPT_INT, status);
	if (ep_status) {
		int i;
		usba_int_enb_set(udc, USBA_DET_SUSPEND);
		for (i = 0; i < udc->num_ep; i++)
			if (ep_status & (1 << i)) {
				if (ep_is_control(&udc->usba_ep[i]))
					usba_control_irq(udc, &udc->usba_ep[i]);
				else
					usba_ep_irq(udc, &udc->usba_ep[i]);
			}
	}
	if (status & USBA_END_OF_RESET) {
		struct usba_ep *ep0, *ep;
		int i;
		usba_writel(udc, INT_CLR,
			USBA_END_OF_RESET|USBA_END_OF_RESUME
			|USBA_DET_SUSPEND|USBA_WAKE_UP);
		generate_bias_pulse(udc);
		reset_all_endpoints(udc);
		if (udc->gadget.speed != USB_SPEED_UNKNOWN && udc->driver) {
			udc->gadget.speed = USB_SPEED_UNKNOWN;
			spin_unlock(&udc->lock);
			usb_gadget_udc_reset(&udc->gadget, udc->driver);
			spin_lock(&udc->lock);
		}
		if (status & USBA_HIGH_SPEED)
			udc->gadget.speed = USB_SPEED_HIGH;
		else
			udc->gadget.speed = USB_SPEED_FULL;
		DBG(DBG_BUS, "%s bus reset detected\n",
		    usb_speed_string(udc->gadget.speed));
		ep0 = &udc->usba_ep[0];
		ep0->ep.desc = &usba_ep0_desc;
		ep0->state = WAIT_FOR_SETUP;
		usba_ep_writel(ep0, CFG,
				(USBA_BF(EPT_SIZE, EP0_EPT_SIZE)
				| USBA_BF(EPT_TYPE, USBA_EPT_TYPE_CONTROL)
				| USBA_BF(BK_NUMBER, USBA_BK_NUMBER_ONE)));
		usba_ep_writel(ep0, CTL_ENB,
				USBA_EPT_ENABLE | USBA_RX_SETUP);
		udc->suspended = false;
		usba_int_enb_clear(udc, USBA_WAKE_UP);
		usba_int_enb_set(udc, USBA_BF(EPT_INT, 1) |
				      USBA_DET_SUSPEND | USBA_END_OF_RESUME);
		if (!(usba_ep_readl(ep0, CFG) & USBA_EPT_MAPPED))
			dev_err(&udc->pdev->dev,
				"ODD: EP0 configuration is invalid!\n");
		for (i = 1; i < udc->num_ep; i++) {
			ep = &udc->usba_ep[i];
			if (ep->ep.claimed) {
				usba_ep_writel(ep, CFG, ep->ept_cfg);
				if (!(usba_ep_readl(ep, CFG) & USBA_EPT_MAPPED))
					dev_err(&udc->pdev->dev,
						"ODD: EP%d configuration is invalid!\n", i);
			}
		}
	}
	spin_unlock(&udc->lock);
	return IRQ_HANDLED;
}
