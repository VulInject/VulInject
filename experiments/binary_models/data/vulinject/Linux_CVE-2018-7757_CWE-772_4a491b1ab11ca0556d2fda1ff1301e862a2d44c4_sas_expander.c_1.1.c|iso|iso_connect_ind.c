int iso_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags)
{
	struct hci_ev_le_pa_sync_established *ev1;
	struct hci_evt_le_big_info_adv_report *ev2;
	struct hci_ev_le_per_adv_report *ev3;
	struct sock *sk;
	bt_dev_dbg(hdev, "bdaddr %pMR", bdaddr);
	ev1 = hci_recv_event_data(hdev, HCI_EV_LE_PA_SYNC_ESTABLISHED);
	if (ev1) {
		sk = iso_get_sock(&hdev->bdaddr, bdaddr, BT_LISTEN,
				  iso_match_sid, ev1);
		if (sk && !ev1->status)
			iso_pi(sk)->sync_handle = le16_to_cpu(ev1->handle);
		goto done;
	}
	ev2 = hci_recv_event_data(hdev, HCI_EVT_LE_BIG_INFO_ADV_REPORT);
	if (ev2) {
		sk = iso_get_sock(&hdev->bdaddr, bdaddr, BT_CONNECTED,
				  iso_match_sync_handle, ev2);
		if (sk) {
			sk = NULL;
			goto done;
		}
		sk = iso_get_sock(&hdev->bdaddr, bdaddr, BT_CONNECT2,
				  iso_match_sync_handle, ev2);
		if (!sk)
			sk = iso_get_sock(&hdev->bdaddr, bdaddr,
					  BT_LISTEN,
					  iso_match_sync_handle,
					  ev2);
		if (sk) {
			int err;
			iso_pi(sk)->qos.bcast.encryption = ev2->encryption;
			if (ev2->num_bis < iso_pi(sk)->bc_num_bis)
				iso_pi(sk)->bc_num_bis = ev2->num_bis;
			if (!test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags) &&
			    !test_and_set_bit(BT_SK_BIG_SYNC, &iso_pi(sk)->flags)) {
				err = hci_le_big_create_sync(hdev, NULL,
							     &iso_pi(sk)->qos,
							     iso_pi(sk)->sync_handle,
							     iso_pi(sk)->bc_num_bis,
							     iso_pi(sk)->bc_bis);
				if (err) {
					bt_dev_err(hdev, "hci_le_big_create_sync: %d",
						   err);
					sock_put(sk);
					sk = NULL;
				}
			}
		}
		goto done;
	}
	ev3 = hci_recv_event_data(hdev, HCI_EV_LE_PER_ADV_REPORT);
	if (ev3) {
		size_t base_len = 0;
		unsigned char *base;
		struct hci_conn *hcon;
		sk = iso_get_sock(&hdev->bdaddr, bdaddr, BT_LISTEN,
				  iso_match_sync_handle_pa_report, ev3);
		if (!sk)
			goto done;
		hcon = iso_pi(sk)->conn->hcon;
		if (!hcon)
			goto done;
		if (ev3->data_status == LE_PA_DATA_TRUNCATED) {
			memset(hcon->le_per_adv_data, 0,
			       HCI_MAX_PER_AD_TOT_LEN);
			hcon->le_per_adv_data_len = 0;
			hcon->le_per_adv_data_offset = 0;
			goto done;
		}
		if (hcon->le_per_adv_data_offset + ev3->length >
		    HCI_MAX_PER_AD_TOT_LEN)
			goto done;
		memcpy(hcon->le_per_adv_data + hcon->le_per_adv_data_offset,
		       ev3->data, ev3->length);
		hcon->le_per_adv_data_offset += ev3->length;
		if (ev3->data_status == LE_PA_DATA_COMPLETE) {
			hcon->le_per_adv_data_len =
				hcon->le_per_adv_data_offset;
			hcon->le_per_adv_data_offset = 0;
			base = eir_get_service_data(hcon->le_per_adv_data,
						    hcon->le_per_adv_data_len,
						    EIR_BAA_SERVICE_UUID,
						    &base_len);
			if (!base || base_len > BASE_MAX_LENGTH)
				goto done;
			memcpy(iso_pi(sk)->base, base, base_len);
			iso_pi(sk)->base_len = base_len;
		} else {
			hcon->le_per_adv_data_len = 0;
		}
	} else {
		sk = iso_get_sock(&hdev->bdaddr, BDADDR_ANY,
				  BT_LISTEN, NULL, NULL);
	}
done:
	if (!sk)
		return 0;
	if (test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))
		*flags |= HCI_PROTO_DEFER;
	sock_put(sk);
	return HCI_LM_ACCEPT;
}
