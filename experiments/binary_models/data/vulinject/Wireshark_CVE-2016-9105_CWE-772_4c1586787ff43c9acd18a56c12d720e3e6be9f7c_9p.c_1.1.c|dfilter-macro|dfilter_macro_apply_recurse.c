static char* dfilter_macro_apply_recurse(const char* text, unsigned depth, df_error_t** error) {
	enum { OUTSIDE, STARTING, NAME, NAME_PARENS, ARGS } state = OUTSIDE;
	GString* out;
	GString* name = NULL;
	GString* arg = NULL;
	GPtrArray* args = NULL;
	char c;
	char open_c = 0; 
	const char* r = text;
	bool changed = false;
	char* resolved;
	if ( depth > 31) {
		if (error != NULL)
			*error = df_error_new_msg("too much nesting in macros");
		return NULL;
	}
#define FGS(n) if (n) g_string_free(n,true); n = NULL
#define FREE_ALL() \
	do { \
		FGS(name); \
		FGS(arg); \
		if (args) { \
			while(args->len) { void* p = g_ptr_array_remove_index_fast(args,0); g_free(p); } \
			g_ptr_array_free(args,true); \
			args = NULL; \
		} \
		open_c = 0; \
	} while(0)
#define MACRO_NAME_CHAR(c) (g_ascii_isalnum(c) || (c) == '_')
	if (error != NULL)
		*error = NULL;
	out = g_string_sized_new(64);
	while(1) {
		c = *r++;
		switch(state) {
			case OUTSIDE:
			{
				switch(c) {
					case '\0':
						goto finish;
					case '$':
						state = STARTING;
						break;
					default:
						break;
				}
				break;
			}
			case STARTING:
			{
				switch (c) {
					case '{':
						if (start_is_field_reference(r)) {
							g_string_append(out,"${");
							state = OUTSIDE;
							break;
						}
						args = g_ptr_array_new();
						arg = g_string_sized_new(32);
						name = g_string_sized_new(32);
						state = NAME;
						open_c = c;
						break;
					case '\0':
						g_string_append_c(out,'$');
						goto finish;
					default:
						if (MACRO_NAME_CHAR(c)) {
							args = g_ptr_array_new();
							arg = g_string_sized_new(32);
							name = g_string_sized_new(32);
							g_string_append_c(name,c);
							state = NAME_PARENS;
						}
						else {
							g_string_append_c(out,'$');
							g_string_append_c(out,c);
							state = OUTSIDE;
						}
						break;
				}
				break;
			}
			case NAME:
			{
				if (MACRO_NAME_CHAR(c)) {
					g_string_append_c(name,c);
				} else if ( c == ':' || c == ';' ) {
					state = ARGS;
				} else if ( c == '}') {
					g_ptr_array_add(args,NULL);
					resolved = dfilter_macro_resolve(name->str, (char**)args->pdata, error);
					if (resolved == NULL)
						goto on_error;
					changed = true;
					g_string_append(out,resolved);
					wmem_free(NULL, resolved);
					FREE_ALL();
					state = OUTSIDE;
				} else if ( c == '\0') {
					if (error != NULL)
						*error = df_error_new_msg("end of filter in the middle of a macro expression");
					goto on_error;
				} else {
					if (error != NULL)
						*error = df_error_new_msg("invalid character in macro name");
					goto on_error;
				}
				break;
			}
			case NAME_PARENS:
			{
				if (MACRO_NAME_CHAR(c)) {
					g_string_append_c(name,c);
				} else if ( c == '(' || c == '{') {
					state = ARGS;
					open_c = c;
				} else {
					g_string_append_c(out,'$');
					g_string_append(out,name->str);
					g_string_append_c(out,c);
					FREE_ALL();
					if (c == '\0')
						goto finish;
					state = OUTSIDE;
				}
				break;
			}
			case ARGS:
			{
				switch(c) {
					case '\0':
						if (error != NULL)
							*error = df_error_new_msg("end of filter in the middle of a macro expression");
						goto on_error;
					case ';':
					case ',':
						if (arg->len == 0) {
							if (error != NULL)
								*error = df_error_new_msg("null argument in macro expression");
							goto on_error;
						}
						g_ptr_array_add(args,g_string_free(arg,false));
						arg = g_string_sized_new(32);
						break;
					case '\\':
						c = *r++;
						if (c) {
							g_string_append_c(arg,c);
							break;
						} else {
							if (error != NULL)
								*error = df_error_new_msg("end of filter in the middle of a macro expression");
							goto on_error;
						}
					case '}':
					case ')':
						if (c != close_char(open_c)) {
							g_string_append_c(arg,c);
							break;
						}
						if (arg->len == 0) {
							if (args->len != 0) {
								if (error != NULL)
									*error = df_error_new_msg("null argument in macro expression");
								goto on_error;
							}
						} else {
							g_ptr_array_add(args,g_string_free(arg,false));
							g_ptr_array_add(args,NULL);
							arg = NULL;
						}
						resolved = dfilter_macro_resolve(name->str, (char**)args->pdata, error);
						if (resolved == NULL)
							goto on_error;
						changed = true;
						g_string_append(out,resolved);
						wmem_free(NULL, resolved);
						FREE_ALL();
						state = OUTSIDE;
						break;
					default:
						g_string_append_c(arg,c);
						break;
				}
				break;
			}
		}
	}
finish:
	{
		FREE_ALL();
		if (changed) {
			resolved = dfilter_macro_apply_recurse(out->str, depth + 1, error);
			g_string_free(out,true);
			return resolved;
		} else {
			char* out_str = wmem_strdup(NULL, out->str);
			g_string_free(out,true);
			return out_str;
		}
	}
on_error:
	{
		FREE_ALL();
		if (error != NULL) {
			if (*error == NULL)
				*error = df_error_new_msg("unknown error in macro expression");
		}
		g_string_free(out,true);
		return NULL;
	}
}
