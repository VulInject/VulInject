static int config_input(AVFilterLink *inlink)
{
    AVFilterContext *ctx = inlink->dst;
    BilateralContext *s = ctx->priv;
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
    s->depth = desc->comp[0].depth;
    s->planewidth[1] = s->planewidth[2] = AV_CEIL_RSHIFT(inlink->w, desc->log2_chroma_w);
    s->planewidth[0] = s->planewidth[3] = inlink->w;
    s->planeheight[1] = s->planeheight[2] = AV_CEIL_RSHIFT(inlink->h, desc->log2_chroma_h);
    s->planeheight[0] = s->planeheight[3] = inlink->h;
    s->nb_planes = av_pix_fmt_count_planes(inlink->format);
    s->nb_threads = ff_filter_get_nb_threads(ctx);
    for (int p = 0; p < s->nb_planes; p++) {
        const int w = s->planewidth[p];
        const int h = s->planeheight[p];
        s->img_out_f[p] = av_calloc(w * h, sizeof(float));
        s->img_temp[p] = av_calloc(w * h, sizeof(float));
        s->map_factor_a[p] = av_calloc(w * h, sizeof(float));
        s->map_factor_b[p] = av_calloc(w * h, sizeof(float));
        s->slice_factor_a[p] = av_calloc(w, sizeof(float));
        s->slice_factor_b[p] = av_calloc(w, sizeof(float));
        s->line_factor_a[p] = av_calloc(w, sizeof(float));
        s->line_factor_b[p] = av_calloc(w, sizeof(float));
        if (!s->img_out_f[p] ||
            !s->img_temp[p] ||
            !s->map_factor_a[p] ||
            !s->map_factor_b[p] ||
            !s->slice_factor_a[p] ||
            !s->slice_factor_a[p] ||
            !s->line_factor_a[p] ||
            !s->line_factor_a[p])
            return AVERROR(ENOMEM);
    }
    return 0;
}
