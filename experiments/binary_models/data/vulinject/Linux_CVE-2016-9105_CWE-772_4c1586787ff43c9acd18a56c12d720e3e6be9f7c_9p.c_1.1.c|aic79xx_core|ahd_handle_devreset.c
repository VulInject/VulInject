ahd_handle_devreset(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
		    unsigned int lun, cam_status status, char *message,
		    int verbose_level)
{
#ifdef AHD_TARGET_MODE
	struct ahd_tmode_tstate* tstate;
#endif
	int found;
	found = ahd_abort_scbs(ahd, devinfo->target, devinfo->channel,
			       lun, SCB_LIST_NULL, devinfo->role,
			       status);
#ifdef AHD_TARGET_MODE
	tstate = ahd->enabled_targets[devinfo->our_scsiid];
	if (tstate != NULL) {
		unsigned int cur_lun;
		unsigned int max_lun;
		if (lun != CAM_LUN_WILDCARD) {
			cur_lun = 0;
			max_lun = AHD_NUM_LUNS - 1;
		} else {
			cur_lun = lun;
			max_lun = lun;
		}
		for (;cur_lun <= max_lun; cur_lun++) {
			struct ahd_tmode_lstate* lstate;
			lstate = tstate->enabled_luns[cur_lun];
			if (lstate == NULL)
				continue;
			ahd_queue_lstate_event(ahd, lstate, devinfo->our_scsiid,
					       TARGET_RESET, 0);
		}
	}
#endif
	ahd_set_width(ahd, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
		      AHD_TRANS_CUR, TRUE);
	ahd_set_syncrate(ahd, devinfo, 0, 0,
			 0, AHD_TRANS_CUR,
			 TRUE);
	if (status != CAM_SEL_TIMEOUT)
		ahd_send_async(ahd, devinfo->channel, devinfo->target,
			       CAM_LUN_WILDCARD, AC_SENT_BDR);
	if (message != NULL && bootverbose)
		printk("%s: %s on %c:%d. %d SCBs aborted\n", ahd_name(ahd),
		       message, devinfo->channel, devinfo->target, found);
}
