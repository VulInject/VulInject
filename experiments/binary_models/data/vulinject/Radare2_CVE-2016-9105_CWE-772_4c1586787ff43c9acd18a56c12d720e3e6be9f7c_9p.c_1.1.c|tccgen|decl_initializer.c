static void decl_initializer(TCCState *s1, CType *type, unsigned int c, int first, int size_only) {
	int int index;
	int n, no_oblock, nb, parlevel, parlevel1;
	size_t array_length, size1, i;
	int align1, expr_type;
	Sym *s, *f;
	CType *t1;
	if (type->t & VT_ARRAY) {
		s = type->ref;
		n = s->c;
		array_length = 0;
		t1 = pointed_type (type);
		size1 = type_size (s1, t1, &align1);
		no_oblock = 1;
		if ((first && s1->tok != TOK_LSTR && s1->tok != TOK_STR) ||
		    s1->tok == '{') {
			if (s1->tok != '{') {
				TCC_ERR ("character array initializer must be a literal,"
					" optionally enclosed in braces");
			}
			skip (s1, '{');
			no_oblock = 0;
		}
		if ((s1->tok == TOK_LSTR && (t1->t & VT_BTYPE) == VT_INT32) || (s1->tok == TOK_STR && (t1->t & VT_BTYPE) == VT_INT8)) {
			while (tcc_nerr (s1) == 0 && (s1->tok == TOK_STR || s1->tok == TOK_LSTR)) {
				CString *cstr = s1->tokc.cstr;
				int cstr_len;
				if (s1->tok == TOK_STR) {
					cstr_len = cstr->size;
				} else {
					cstr_len = cstr->size / sizeof (nwchar_t);
				}
				cstr_len--;
				nb = cstr_len;
				if (n >= 0 && nb > (n - array_length)) {
					nb = n - array_length;
				}
				if (!size_only) {
					if (cstr_len > nb) {
						tcc_warning (s1, "initializer-string for array is too int");
					}
					for (i = 0; i < nb; i++) {
						int ch = (s1->tok == TOK_STR)
							? ((unsigned char *) cstr->data)[i]
							: ((nwchar_t *) cstr->data)[i];
						init_putv (s1, t1, c + (array_length + i) * size1,
							ch, EXPR_VAL);
					}
				}
				array_length += nb;
				next (s1);
			}
			if (n < 0 || array_length < n) {
				if (!size_only) {
					init_putv (s1, t1, c + (array_length * size1), 0, EXPR_VAL);
				}
				array_length++;
			}
		} else {
			index = 0;
			while (s1->tok != '}') {
				decl_designator (s1, type, c, &index, NULL, size_only);
				if (n >= 0 && index >= n) {
					TCC_ERR ("index too large");
				}
				if (!size_only && array_length < index) {
					init_putz (s1, t1, c + array_length * size1,
						(index - array_length) * size1);
				}
				index++;
				if (index > array_length) {
					array_length = index;
				}
				if (index >= n && no_oblock) {
					break;
				}
				if (s1->tok == '}') {
					break;
				}
				skip (s1, ',');
			}
		}
		if (!no_oblock) {
			skip (s1, '}');
		}
		if (!size_only && n >= 0 && array_length < n) {
			init_putz (s1, t1, c + array_length * size1,
				(n - array_length) * size1);
		}
		if (n < 0) {
			s->c = array_length;
		}
	} else if (is_structured (type) && (!first || s1->tok == '{')) {
		int par_count;
		par_count = 0;
		if (s1->tok == '(') {
			AttributeDef ad1;
			next (s1);
			while (s1->tok == '(') {
				par_count++;
				next (s1);
			}
			if (!parse_btype (s1, &type1, &ad1)) {
				expect (s1, "cast");
			}
			type_decl (s1, &type1, &ad1, &n, TYPE_ABSTRACT);
#if 0
			if (!is_assignable_types (type, &type1)) {
				tcc_error (s1, "invalid type for cast");
			}
#endif
			skip (s1, ')');
		}
		no_oblock = 1;
		if (first || s1->tok == '{') {
			skip (s1, '{');
			no_oblock = 0;
		}
		s = type->ref;
		f = s->next;
		if (!f) {
			TCC_ERR ("missing next entry");
		}
		array_length = 0;
		index = 0;
		n = s->c;
		while (s1->tok != '}') {
			decl_designator (s1, type, c, NULL, &f, size_only);
			index = f->c;
			if (!size_only && array_length < index) {
				init_putz (s1, type, c + array_length,
					index - array_length);
			}
			index = index + type_size (s1, &f->type, &align1);
			if (index > array_length) {
				array_length = index;
			}
			while (f->next) {
				if (f->next->c != f->c) {
					break;
				}
				if ((f->type.t & VT_BITFIELD) && (f->next->type.t & VT_BITFIELD)) {
					int bit_pos_1 = (f->type.t >> VT_STRUCT_SHIFT) & 0x3f;
					int bit_pos_2 = (f->next->type.t >> VT_STRUCT_SHIFT) & 0x3f;
					if (bit_pos_1 != bit_pos_2) {
						break;
					}
				}
				f = f->next;
			}
			f = f->next;
			if (no_oblock && f == NULL) {
				break;
			}
			if (s1->tok == '}') {
				break;
			}
			skip (s1, ',');
		}
		if (!size_only && array_length < n) {
			init_putz (s1, type, c + array_length,
				n - array_length);
		}
		if (!no_oblock) {
			skip (s1, '}');
		}
		while (par_count) {
			skip (s1, ')');
			par_count--;
		}
	} else if (s1->tok == '{') {
		next (s1);
		decl_initializer (s1, type, c, first, size_only);
		skip (s1, '}');
	} else if (size_only) {
		parlevel = parlevel1 = 0;
		while ((parlevel > 0 || parlevel1 > 0 ||
			(s1->tok != '}' && s1->tok != ',')) && s1->tok != -1) {
			if (s1->tok == '(') {
				parlevel++;
			} else if (s1->tok == ')') {
				parlevel--;
			} else if (s1->tok == '{') {
				parlevel1++;
			} else if (s1->tok == '}') {
				parlevel1--;
			}
			next (s1);
		}
	} else {
		expr_type = EXPR_CONST;
		init_putv (s1, type, c, 0, expr_type);
	}
}
