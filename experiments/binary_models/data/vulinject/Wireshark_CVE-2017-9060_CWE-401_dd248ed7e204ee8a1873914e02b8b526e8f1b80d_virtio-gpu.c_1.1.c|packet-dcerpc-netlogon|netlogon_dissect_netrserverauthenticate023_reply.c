netlogon_dissect_netrserverauthenticate023_reply(tvbuff_t *tvb, int offset,
                                                 packet_info *pinfo,
                                                 proto_tree *tree,
                                                 dcerpc_info *di,
                                                 guint8 *drep,
                                                 int version)
{
    guint32 flags = 0;
    netlogon_auth_vars *vars;
    netlogon_auth_key key;
    guint64 server_cred;
    offset = dissect_dcerpc_8bytes(tvb, offset, pinfo, tree, drep,
                                   hf_server_credential, &server_cred);
    if (version >= 2) {
        flags = tvb_get_letohl (tvb, offset);
        netlogon_dissect_neg_options(tvb,tree,flags,offset);
        offset +=4;
    }
    ALIGN_TO_4_BYTES;
    if (version >= 3) {
        offset = dissect_dcerpc_uint32(tvb, offset, pinfo, tree, drep,
                                       hf_server_rid, NULL);
    }
    offset = dissect_ntstatus(tvb, offset, pinfo, tree, di, drep,
                              hf_netlogon_rc, NULL);
    generate_hash_key(pinfo, 1 , &key);
    vars = (netlogon_auth_vars *)wmem_map_lookup(netlogon_auths, &key);
    if(vars != NULL) {
        debugprintf("Found some vars (ie. server/client challenges), let's see if I can get a session key\n");
        while(vars != NULL && vars->next_start != -1 && vars->next_start < (int) pinfo->num ) {
            debugprintf("looping auth reply...\n");
            vars = vars->next;
        }
        if(vars == NULL ) {
            debugprintf("Something strange happened while searching for authenticate_reply\n");
        }
        else {
            md4_pass *pass_list=NULL;
            const md4_pass *used_md4 = NULL;
            const char *used_method = NULL;
            guint32 list_size = 0;
            unsigned int i = 0;
            md4_pass password;
            guint8 session_key[16];
            int found = 0;
            vars->flags = flags;
            vars->can_decrypt = FALSE;
            list_size = get_md4pass_list(pinfo->pool, &pass_list);
            debugprintf("Found %d passwords \n",list_size);
            if( flags & NETLOGON_FLAG_AES )
            {
                guint8 salt_buf[16] = { 0 };
                guint8 sha256[HASH_SHA2_256_LENGTH];
                guint64 calculated_cred;
                memcpy(&salt_buf[0], (guint8*)&vars->client_challenge, 8);
                memcpy(&salt_buf[8], (guint8*)&vars->server_challenge, 8);
                used_method = "AES";
                printnbyte((guint8*)&vars->client_challenge,8,"Client challenge:","\n");
                printnbyte((guint8*)&vars->server_challenge,8,"Server challenge:","\n");
                printnbyte((guint8*)&server_cred,8,"Server creds:","\n");
                for(i=0;i<list_size;i++)
                {
                    used_md4 = &pass_list[i];
                    password = pass_list[i];
                    printnbyte((guint8*)&password, 16,"NTHASH:","\n");
                    if (!ws_hmac_buffer(GCRY_MD_SHA256, sha256, salt_buf, sizeof(salt_buf), (guint8*) &password, 16)) {
                        gcry_error_t err;
                        gcry_cipher_hd_t cipher_hd = NULL;
                        guint8 iv[16] = { 0 };
                        memcpy(session_key, sha256, 16);
                        printnbyte((guint8*)session_key, 16,"Session Key","\n");
                        err = gcry_cipher_open(&cipher_hd, GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_CFB8, 0);
                        if (err != 0) {
                            ws_warning("GCRY: cipher open %s/%s\n", gcry_strsource(err), gcry_strerror(err));
                            break;
                        }
                        err = gcry_cipher_setiv(cipher_hd, iv, sizeof(iv));
                        if (err != 0) {
                            ws_warning("GCRY: setiv %s/%s\n", gcry_strsource(err), gcry_strerror(err));
                            break;
                        }
                        err = gcry_cipher_setkey(cipher_hd, session_key, 16);
                        if (err != 0) {
                            ws_warning("GCRY: setkey %s/%s\n", gcry_strsource(err), gcry_strerror(err));
                            gcry_cipher_close(cipher_hd);
                            break;
                        }
                        calculated_cred = 0x1234567812345678;
                        err = gcry_cipher_encrypt(cipher_hd,
                                                  (guint8 *)&calculated_cred, 8,
                                                  (const guint8 *)&vars->server_challenge, 8);
                        if (err != 0) {
                            ws_warning("GCRY: encrypt %s/%s\n", gcry_strsource(err), gcry_strerror(err));
                            gcry_cipher_close(cipher_hd);
                            break;
                        }
                        gcry_cipher_close(cipher_hd);
                        printnbyte((guint8*)&calculated_cred,8,"Calculated creds:","\n");
                        if(calculated_cred==server_cred) {
                            found = 1;
                            break;
                        }
                    }
                }
            } else if ( flags & NETLOGON_FLAG_STRONGKEY ) {
                guint8 zeros[4] = { 0 };
                guint8 md5[HASH_MD5_LENGTH];
                gcry_md_hd_t md5_handle;
                guint8 buf[8] = { 0 };
                guint64 calculated_cred;
                used_method = "MD5";
                if (!gcry_md_open(&md5_handle, GCRY_MD_MD5, 0)) {
                    gcry_md_write(md5_handle, zeros, 4);
                    gcry_md_write(md5_handle, (guint8*)&vars->client_challenge, 8);
                    gcry_md_write(md5_handle, (guint8*)&vars->server_challenge, 8);
                    memcpy(md5, gcry_md_read(md5_handle, 0), 16);
                    gcry_md_close(md5_handle);
                }
                printnbyte(md5,8,"MD5:","\n");
                printnbyte((guint8*)&vars->client_challenge,8,"Client challenge:","\n");
                printnbyte((guint8*)&vars->server_challenge,8,"Server challenge:","\n");
                printnbyte((guint8*)&server_cred,8,"Server creds:","\n");
                for(i=0;i<list_size;i++)
                {
                    used_md4 = &pass_list[i];
                    password = pass_list[i];
                    if (!ws_hmac_buffer(GCRY_MD_MD5, session_key, md5, HASH_MD5_LENGTH, (guint8*) &password, 16)) {
                        crypt_des_ecb(buf,(unsigned char*)&vars->server_challenge,session_key);
                        crypt_des_ecb((unsigned char*)&calculated_cred,buf,session_key+7);
                        printnbyte((guint8*)&calculated_cred,8,"Calculated creds:","\n");
                        if(calculated_cred==server_cred) {
                            found = 1;
                            break;
                        }
                    }
                }
            }
            else
            {
                debugprintf("Else case not implemented\n");
                memset(session_key,0,16);
            }
            if(found) {
                vars->nthash = *used_md4;
                vars->auth_fd_num = pinfo->num;
                memcpy(&vars->session_key,session_key,16);
                debugprintf("Found the good session key !\n");
                expert_add_info_format(pinfo, proto_tree_get_parent(tree),
                         &ei_netlogon_auth_nthash,
                         "%s authenticated using %s (%02x%02x%02x%02x...)",
                         used_method, used_md4->key_origin,
                         used_md4->md4[0] & 0xFF, used_md4->md4[1] & 0xFF,
                         used_md4->md4[2] & 0xFF, used_md4->md4[3] & 0xFF);
                expert_add_info_format(pinfo, proto_tree_get_parent(tree),
                         &ei_netlogon_session_key,
                         "session key ("
                         "%02x%02x%02x%02x"
                         "%02x%02x%02x%02x"
                         "%02x%02x%02x%02x"
                         "%02x%02x%02x%02x"
                         ")",
                         session_key[0] & 0xFF,  session_key[1] & 0xFF,
                         session_key[2] & 0xFF,  session_key[3] & 0xFF,
                         session_key[4] & 0xFF,  session_key[5] & 0xFF,
                         session_key[6] & 0xFF,  session_key[7] & 0xFF,
                         session_key[8] & 0xFF,  session_key[9] & 0xFF,
                         session_key[10] & 0xFF, session_key[11] & 0xFF,
                         session_key[12] & 0xFF, session_key[13] & 0xFF,
                         session_key[14] & 0xFF, session_key[15] & 0xFF);
            }
            else {
                debugprintf("Session key not found !\n");
                memset(&vars->session_key,0,16);
            }
        }
    }
    return offset;
}
