esis_print(netdissect_options *ndo,
           const unsigned char *pptr, u_int length)
{
	const unsigned char *optr;
	u_int li, version, esis_pdu_type, source_address_length, source_address_number;
	const struct esis_header_t *esis_header;
	ndo->ndo_protocol = "esis";
	if (!ndo->ndo_eflag)
		ND_PRINT("ES-IS");
	if (length <= 2) {
		ND_PRINT(ndo->ndo_qflag ? "bad pkt!" : "no header at all!");
		return;
	}
	esis_header = (const struct esis_header_t *) pptr;
        li = GET_U_1(esis_header->length_indicator);
        optr = pptr;
        if (GET_U_1(esis_header->nlpid) != NLPID_ESIS) {
            ND_PRINT(" nlpid 0x%02x packet not supported",
		     GET_U_1(esis_header->nlpid));
            return;
        }
        version = GET_U_1(esis_header->version);
        if (version != ESIS_VERSION) {
            ND_PRINT(" version %u packet not supported", version);
            return;
        }
	if (li > length) {
            ND_PRINT(" length indicator(%u) > PDU size (%u)!", li, length);
            return;
	}
	if (li < sizeof(struct esis_header_t) + 2) {
            ND_PRINT(" length indicator %u < min PDU size:", li);
            while (pptr < ndo->ndo_snapend) {
                ND_PRINT("%02X", GET_U_1(pptr));
                pptr++;
            }
            return;
	}
        esis_pdu_type = GET_U_1(esis_header->type) & ESIS_PDU_TYPE_MASK;
        if (ndo->ndo_vflag < 1) {
            ND_PRINT("%s%s, length %u",
                   ndo->ndo_eflag ? "" : ", ",
                   tok2str(esis_pdu_values,"unknown type (%u)",esis_pdu_type),
                   length);
            return;
        } else
            ND_PRINT("%slength %u\n\t%s (%u)",
                   ndo->ndo_eflag ? "" : ", ",
                   length,
                   tok2str(esis_pdu_values,"unknown type: %u", esis_pdu_type),
                   esis_pdu_type);
        ND_PRINT(", v: %u%s", version, version == ESIS_VERSION ? "" : "unsupported" );
        ND_PRINT(", checksum: 0x%04x", GET_BE_U_2(esis_header->cksum));
        osi_print_cksum(ndo, pptr, GET_BE_U_2(esis_header->cksum), 7,
                        li);
        ND_PRINT(", holding time: %us, length indicator: %u",
                  GET_BE_U_2(esis_header->holdtime), li);
        if (ndo->ndo_vflag > 1)
            print_unknown_data(ndo, optr, "\n\t", sizeof(struct esis_header_t));
	pptr += sizeof(struct esis_header_t);
	li -= sizeof(struct esis_header_t);
	switch (esis_pdu_type) {
	case ESIS_PDU_REDIRECT: {
		const unsigned char *dst, *snpa, *neta;
		u_int dstl, snpal, netal;
		ND_TCHECK_1(pptr);
		if (li < 1) {
			ND_PRINT(", bad redirect/li");
			return;
		}
		dstl = GET_U_1(pptr);
		pptr++;
		li--;
		ND_TCHECK_LEN(pptr, dstl);
		if (li < dstl) {
			ND_PRINT(", bad redirect/li");
			return;
		}
		dst = pptr;
		pptr += dstl;
                li -= dstl;
		ND_PRINT("\n\t  %s", GET_ISONSAP_STRING(dst, dstl));
		ND_TCHECK_1(pptr);
		if (li < 1) {
			ND_PRINT(", bad redirect/li");
			return;
		}
		snpal = GET_U_1(pptr);
		pptr++;
		li--;
		ND_TCHECK_LEN(pptr, snpal);
		if (li < snpal) {
			ND_PRINT(", bad redirect/li");
			return;
		}
		snpa = pptr;
		pptr += snpal;
                li -= snpal;
		ND_TCHECK_1(pptr);
		if (li < 1) {
			ND_PRINT(", bad redirect/li");
			return;
		}
		netal = GET_U_1(pptr);
		pptr++;
		ND_TCHECK_LEN(pptr, netal);
		if (li < netal) {
			ND_PRINT(", bad redirect/li");
			return;
		}
		neta = pptr;
		pptr += netal;
                li -= netal;
		if (snpal == MAC48_LEN)
			ND_PRINT("\n\t  SNPA (length: %u): %s",
			       snpal,
			       GET_MAC48_STRING(snpa));
		else
			ND_PRINT("\n\t  SNPA (length: %u): %s",
			       snpal,
			       GET_LINKADDR_STRING(snpa, LINKADDR_OTHER, snpal));
		if (netal != 0)
			ND_PRINT("\n\t  NET (length: %u) %s",
			       netal,
			       GET_ISONSAP_STRING(neta, netal));
		break;
	}
	case ESIS_PDU_ESH:
            ND_TCHECK_1(pptr);
            if (li < 1) {
                ND_PRINT(", bad esh/li");
                return;
            }
            source_address_number = GET_U_1(pptr);
            pptr++;
            li--;
            ND_PRINT("\n\t  Number of Source Addresses: %u", source_address_number);
            while (source_address_number != 0) {
                ND_TCHECK_1(pptr);
		if (li < 1) {
                    ND_PRINT(", bad esh/li");
		    return;
		}
                source_address_length = GET_U_1(pptr);
                pptr++;
		li--;
                ND_TCHECK_LEN(pptr, source_address_length);
		if (li < source_address_length) {
                    ND_PRINT(", bad esh/li");
		    return;
		}
                ND_PRINT("\n\t  NET (length: %u): %s",
                       source_address_length,
                       GET_ISONSAP_STRING(pptr, source_address_length));
                pptr += source_address_length;
                li -= source_address_length;
                source_address_number--;
            }
            break;
	case ESIS_PDU_ISH: {
            ND_TCHECK_1(pptr);
            if (li < 1) {
                ND_PRINT(", bad ish/li");
                return;
            }
            source_address_length = GET_U_1(pptr);
            pptr++;
            li--;
            ND_TCHECK_LEN(pptr, source_address_length);
            if (li < source_address_length) {
                ND_PRINT(", bad ish/li");
                return;
            }
            ND_PRINT("\n\t  NET (length: %u): %s", source_address_length, GET_ISONSAP_STRING(pptr, source_address_length));
            pptr += source_address_length;
            li -= source_address_length;
            break;
	}
	default:
		if (ndo->ndo_vflag <= 1) {
			if (ND_TTEST_LEN(pptr, 1))
				print_unknown_data(ndo, pptr, "\n\t  ", ND_BYTES_AVAILABLE_AFTER(pptr));
		}
		return;
	}
        while (li != 0) {
            u_int op, opli;
            const unsigned char *tptr;
            if (li < 2) {
                ND_PRINT(", bad opts/li");
                return;
            }
            op = GET_U_1(pptr);
            opli = GET_U_1(pptr + 1);
            pptr += 2;
            li -= 2;
            if (opli > li) {
                ND_PRINT(", opt (%u) too int", op);
                return;
            }
            li -= opli;
            tptr = pptr;
            ND_PRINT("\n\t  %s Option #%u, length %u, value: ",
                   tok2str(esis_option_values,"Unknown",op),
                   op,
                   opli);
            switch (op) {
            case ESIS_OPTION_ES_CONF_TIME:
                if (opli == 2) {
                    ND_TCHECK_2(pptr);
                    ND_PRINT("%us", GET_BE_U_2(tptr));
                } else
                    ND_PRINT("(bad length)");
                break;
            case ESIS_OPTION_PROTOCOLS:
                while (opli != 0) {
                    ND_PRINT("%s (0x%02x)",
                           tok2str(nlpid_values,
                                   "unknown",
                                   GET_U_1(tptr)),
                           GET_U_1(tptr));
                    if (opli>1) 
                        ND_PRINT(", ");
                    tptr++;
                    opli--;
                }
                break;
            case ESIS_OPTION_QOS_MAINTENANCE:
            case ESIS_OPTION_SECURITY:
            case ESIS_OPTION_PRIORITY:
            case ESIS_OPTION_ADDRESS_MASK:
            case ESIS_OPTION_SNPA_MASK:
            default:
                print_unknown_data(ndo, tptr, "\n\t  ", opli);
                break;
            }
            if (ndo->ndo_vflag > 1)
                print_unknown_data(ndo, pptr, "\n\t  ", opli);
            pptr += opli;
        }
        return;
trunc:
	nd_print_trunc(ndo);
}
