static void ath9k_hif_usb_rx_stream(struct hif_device_usb *hif_dev,
				    struct sk_buff *skb)
{
	struct sk_buff *nskb, *skb_pool[MAX_PKT_NUM_IN_TRANSFER];
	int index = 0, i, len = skb->len;
	int rx_remain_len, rx_pkt_len;
	unsigned short pool_index = 0;
	unsigned char *ptr;
	spin_lock(&hif_dev->rx_lock);
	rx_remain_len = hif_dev->rx_remain_len;
	rx_pkt_len = hif_dev->rx_transfer_len;
	if (rx_remain_len != 0) {
		struct sk_buff *remain_skb = hif_dev->remain_skb;
		if (remain_skb) {
			ptr = (unsigned char *) remain_skb->data;
			index = rx_remain_len;
			rx_remain_len -= hif_dev->rx_pad_len;
			ptr += rx_pkt_len;
			memcpy(ptr, skb->data, rx_remain_len);
			rx_pkt_len += rx_remain_len;
			skb_pool[pool_index++] = remain_skb;
			hif_dev->remain_skb = NULL;
			hif_dev->rx_remain_len = 0;
		} else {
			index = rx_remain_len;
		}
	}
	spin_unlock(&hif_dev->rx_lock);
	while (index < len) {
		unsigned short pkt_len;
		unsigned short pkt_tag;
		unsigned short pad_len;
		int chk_idx;
		ptr = (unsigned char *) skb->data;
		pkt_len = get_unaligned_le16(ptr + index);
		pkt_tag = get_unaligned_le16(ptr + index + 2);
		if (pkt_tag != ATH_USB_RX_STREAM_MODE_TAG) {
			RX_STAT_INC(hif_dev, skb_dropped);
			goto invalid_pkt;
		}
		if (pkt_len > 2 * MAX_RX_BUF_SIZE) {
			dev_err(&hif_dev->udev->dev,
				"ath9k_htc: invalid pkt_len (%x)\n", pkt_len);
			RX_STAT_INC(hif_dev, skb_dropped);
			goto invalid_pkt;
		}
		pad_len = 4 - (pkt_len & 0x3);
		if (pad_len == 4)
			pad_len = 0;
		chk_idx = index;
		index = index + 4 + pkt_len + pad_len;
		if (index > MAX_RX_BUF_SIZE) {
			spin_lock(&hif_dev->rx_lock);
			nskb = __dev_alloc_skb(pkt_len + 32, GFP_ATOMIC);
			if (!nskb) {
				dev_err(&hif_dev->udev->dev,
					"ath9k_htc: RX memory allocation error\n");
				spin_unlock(&hif_dev->rx_lock);
				goto err;
			}
			hif_dev->rx_remain_len = index - MAX_RX_BUF_SIZE;
			hif_dev->rx_transfer_len =
				MAX_RX_BUF_SIZE - chk_idx - 4;
			hif_dev->rx_pad_len = pad_len;
			skb_reserve(nskb, 32);
			RX_STAT_INC(hif_dev, skb_allocated);
			memcpy(nskb->data, &(skb->data[chk_idx+4]),
			       hif_dev->rx_transfer_len);
			hif_dev->remain_skb = nskb;
			spin_unlock(&hif_dev->rx_lock);
		} else {
			if (pool_index == MAX_PKT_NUM_IN_TRANSFER) {
				dev_err(&hif_dev->udev->dev,
					"ath9k_htc: over RX MAX_PKT_NUM\n");
				goto err;
			}
			nskb = __dev_alloc_skb(pkt_len + 32, GFP_ATOMIC);
			if (!nskb) {
				dev_err(&hif_dev->udev->dev,
					"ath9k_htc: RX memory allocation error\n");
				goto err;
			}
			skb_reserve(nskb, 32);
			RX_STAT_INC(hif_dev, skb_allocated);
			memcpy(nskb->data, &(skb->data[chk_idx+4]), pkt_len);
			skb_put(nskb, pkt_len);
			skb_pool[pool_index++] = nskb;
		}
	}
err:
	for (i = 0; i < pool_index; i++) {
		RX_STAT_ADD(hif_dev, skb_completed_bytes, skb_pool[i]->len);
		ath9k_htc_rx_msg(hif_dev->htc_handle, skb_pool[i],
				 skb_pool[i]->len, USB_WLAN_RX_PIPE);
		RX_STAT_INC(hif_dev, skb_completed);
	}
	return;
invalid_pkt:
	for (i = 0; i < pool_index; i++) {
		dev_kfree_skb_any(skb_pool[i]);
		RX_STAT_INC(hif_dev, skb_dropped);
	}
	return;
}
