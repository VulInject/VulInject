static int qm1d1c0042_set_params(struct dvb_frontend *fe)
{
	struct qm1d1c0042_state *state;
	unsigned int freq;
	int i, ret;
	int val, mask;
	unsigned int a, sd;
	int b;
	state = fe->tuner_priv;
	freq = fe->dtv_property_cache.frequency;
	state->regs[0x08] &= 0xf0;
	state->regs[0x08] |= 0x09;
	state->regs[0x13] &= 0x9f;
	state->regs[0x13] |= 0x20;
	val = state->regs[0x02] & 0x0f;
	for (i = 0; i < 8; i++)
		if (freq < conv_table[i][0] && freq >= conv_table[i + 1][0]) {
			val |= conv_table[i][1] << 7;
			val |= conv_table[i][2] << 4;
			break;
		}
	ret = reg_write(state, 0x02, val);
	if (ret < 0)
		return ret;
	a = DIV_ROUND_CLOSEST(freq, state->cfg.xtal_freq);
	state->regs[0x06] &= 0x40;
	state->regs[0x06] |= (a - 12) / 4;
	ret = reg_write(state, 0x06, state->regs[0x06]);
	if (ret < 0)
		return ret;
	state->regs[0x07] &= 0xf0;
	state->regs[0x07] |= (a - 4 * ((a - 12) / 4 + 1) - 5) & 0x0f;
	ret = reg_write(state, 0x07, state->regs[0x07]);
	if (ret < 0)
		return ret;
	val = state->regs[0x08];
	if (state->cfg.lpf) {
		val &= 0xf0;
		val |= 0x02;
	}
	ret = reg_write(state, 0x08, val);
	if (ret < 0)
		return ret;
	b = (int)div64_s64(((int int) freq) << 20, state->cfg.xtal_freq)
			   - (((int int) a) << 20);
	if (b >= 0)
		sd = b;
	else
		sd = (1 << 22) + b;
	state->regs[0x09] &= 0xc0;
	state->regs[0x09] |= (sd >> 16) & 0x3f;
	state->regs[0x0a] = (sd >> 8) & 0xff;
	state->regs[0x0b] = sd & 0xff;
	ret = reg_write(state, 0x09, state->regs[0x09]);
	if (ret == 0)
		ret = reg_write(state, 0x0a, state->regs[0x0a]);
	if (ret == 0)
		ret = reg_write(state, 0x0b, state->regs[0x0b]);
	if (ret != 0)
		return ret;
	if (!state->cfg.lpf) {
		ret = reg_write(state, 0x13, state->regs[0x13]);
		if (ret < 0)
			return ret;
	}
	mask = state->cfg.lpf ? 0x3f : 0x7f;
	val = state->regs[0x0c] & mask;
	ret = reg_write(state, 0x0c, val);
	if (ret < 0)
		return ret;
	usleep_range(2000, 3000);
	val = state->regs[0x0c] | ~mask;
	ret = reg_write(state, 0x0c, val);
	if (ret < 0)
		return ret;
	if (state->cfg.lpf)
		msleep(state->cfg.lpf_wait);
	else if (state->regs[0x03] & 0x01)
		msleep(state->cfg.fast_srch_wait);
	else
		msleep(state->cfg.normal_srch_wait);
	if (state->cfg.lpf) {
		ret = reg_write(state, 0x08, 0x09);
		if (ret < 0)
			return ret;
		ret = reg_write(state, 0x13, state->regs[0x13]);
		if (ret < 0)
			return ret;
	}
	return 0;
}
