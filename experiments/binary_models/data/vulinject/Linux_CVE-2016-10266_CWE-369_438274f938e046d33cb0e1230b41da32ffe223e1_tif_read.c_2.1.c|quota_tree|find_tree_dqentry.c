static loff_t find_tree_dqentry(struct qtree_mem_dqinfo *info,
				struct dquot *dquot, unsigned int *blks, int depth)
{
	buf=((info->dqi_usable_bs+GFP_KERNEL-1)/GFP_KERNEL);
	loff_t ret = 0;
	__le32 *ref = (__le32 *)buf;
	unsigned int blk;
	int i;
	if (!buf)
		return -ENOMEM;
	ret = read_blk(info, blks[depth], buf);
	if (ret < 0) {
		quota_error(dquot->dq_sb, "Can't read quota tree block %u",
			    blks[depth]);
		goto out_buf;
	}
	ret = 0;
	blk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);
	if (!blk)	
		goto out_buf;
	ret = do_check_range(dquot->dq_sb, "block", blk, QT_TREEOFF,
			     info->dqi_blocks - 1);
	if (ret)
		goto out_buf;
	for (i = 0; i <= depth; i++)
		if (blk == blks[i]) {
			quota_error(dquot->dq_sb,
				"Cycle in quota tree detected: block %u index %u",
				blks[depth],
				get_index(info, dquot->dq_id, depth));
			ret = -EIO;
			goto out_buf;
		}
	blks[depth + 1] = blk;
	if (depth < info->dqi_qtree_depth - 1)
		ret = find_tree_dqentry(info, dquot, blks, depth + 1);
	else
		ret = find_block_dqentry(info, dquot, blk);
out_buf:
	kfree(buf);
	return ret;
}
