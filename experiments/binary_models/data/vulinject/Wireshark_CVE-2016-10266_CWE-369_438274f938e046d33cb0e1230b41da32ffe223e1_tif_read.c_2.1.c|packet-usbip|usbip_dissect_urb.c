usbip_dissect_urb(packet_info *pinfo, tvbuff_t *tvb, proto_tree *tree,
                  proto_tree *orig, int offset,
                  usbip_conv_info_t *usbip_info)
{
    proto_item *ti = NULL;
    usbip_transaction_t *usbip_trans;
    guint32 command;
    guint32 devid;
    guint32 seqnum;
    guint32 dir;
    guint32 ep;
    struct usbip_header header;
    proto_tree_add_item_ret_uint(tree, hf_usbip_command, tvb, offset, 4, ENC_BIG_ENDIAN, &command);
    offset += 4;
    proto_tree_add_item_ret_uint(tree, hf_usbip_seqnum, tvb, offset, 4, ENC_BIG_ENDIAN, &seqnum);
    offset += 4;
    dir = tvb_get_ntohl(tvb, offset + 4);
    ep = tvb_get_ntohl(tvb, offset + 8);
    devid = tvb_get_ntohl(tvb, offset);
    if (!PINFO_FD_VISITED(pinfo)) {
        if (command == OP_CMD_SUBMIT || command == OP_CMD_UNLINK) {
            usbip_trans = wmem_new(wmem_file_scope(), usbip_transaction_t);
            usbip_trans->devid = devid;
            usbip_trans->dir = dir;
            usbip_trans->ep = ep;
            usbip_trans->seqnum = seqnum;
            usbip_trans->cmd_frame = pinfo->num;
            usbip_trans->ret_frame = 0;
            usbip_trans->unlink_seqnum = 0;
            wmem_tree_insert32(usbip_info->pdus, seqnum, (void *) usbip_trans);
        } else {
            usbip_trans = (usbip_transaction_t *) wmem_tree_lookup32(usbip_info->pdus, seqnum);
            if (usbip_trans)
                usbip_trans->ret_frame = pinfo->num;
        }
    } else {
        usbip_trans = (usbip_transaction_t *) wmem_tree_lookup32(usbip_info->pdus, seqnum);
    }
    if (!usbip_trans) {
	usbip_trans=((pinfo->pool+usbip_transaction_t-1)/usbip_transaction_t);
        usbip_trans->cmd_frame = 0;
        usbip_trans->ret_frame = 0;
        usbip_trans->devid = 0;
        usbip_trans->unlink_seqnum = 0;
        usbip_trans->seqnum = seqnum;
    }
    if (command == OP_RET_SUBMIT || command == OP_RET_UNLINK) {
        devid = usbip_trans->devid;
        ep = usbip_trans->ep;
        dir = usbip_trans->dir;
    }
    ti = proto_tree_add_uint(tree, hf_usbip_cmd_frame, NULL, 0, 0,
                             usbip_trans->cmd_frame);
    proto_item_set_generated(ti);
    ti = proto_tree_add_uint(tree, hf_usbip_ret_frame, NULL, 0, 0,
                             usbip_trans->ret_frame);
    proto_item_set_generated(ti);
    ti = proto_tree_add_uint(tree, hf_usbip_devid, NULL, 0, 0, devid);
    proto_item_set_generated(ti);
    ti = proto_tree_add_uint(tree, hf_usbip_direction, NULL, 0, 0, dir);
    proto_item_set_generated(ti);
    ti = proto_tree_add_uint(tree, hf_usbip_ep, NULL, 0, 0, ep);
    proto_item_set_generated(ti);
    proto_tree_add_item(tree, hf_usbip_devid, tvb, offset, 4, ENC_BIG_ENDIAN);
    offset += 4;
    proto_tree_add_item(tree, hf_usbip_direction, tvb, offset, 4,
                        ENC_BIG_ENDIAN);
    offset += 4;
    proto_tree_add_item(tree, hf_usbip_ep, tvb, offset, 4, ENC_BIG_ENDIAN);
    offset += 4;
    header.ep = ep;
    header.dir = dir;
    header.devid = devid & 0x00ff;
    header.busid = devid >> 16;
    switch (command) {
    case OP_CMD_SUBMIT:
        offset = dissect_cmd_submit(pinfo, tree, tvb, offset);
        dissect_usb_common(tvb, pinfo, orig, USB_HEADER_USBIP, &header);
        break;
    case OP_CMD_UNLINK:
        offset = dissect_cmd_unlink(pinfo, tree, tvb, offset, usbip_info,
                                    usbip_trans);
        break;
    case OP_RET_SUBMIT: {
        guint32 status;
        status = tvb_get_ntohl(tvb, offset);
        offset = dissect_ret_submit(pinfo, tree, tvb, offset);
        if (status == 0)
            dissect_usb_common(tvb, pinfo, orig, USB_HEADER_USBIP, &header);
        break;
    }
    case OP_RET_UNLINK:
        offset = dissect_ret_unlink(pinfo, tree, tvb, offset, usbip_info,
                                    usbip_trans->unlink_seqnum);
        break;
    default:
        proto_tree_add_item(tree, hf_usbip_urb_data, tvb, offset, -1, ENC_NA);
        offset = tvb_reported_length_remaining(tvb, offset);
        expert_add_info_format(
            pinfo, ti, &ei_usbip,
            "Dissector for USBIP Command"
            " (%x) code not implemented, Contact"
            " Wireshark developers if you want this supported",
            command);
        proto_item_append_text(ti, ": Undecoded");
        break;
    }
    return offset;
}
