static int cmd_wo(void *data, const char *input) {
	RCore *core = (RCore *)data;
	ut8 *buf;
	int len;
	int value;
	switch (input[0]) {
	case 'e': 
		if (input[1]!=' ') {
			r_core_cmd_help_match (core, help_msg_wo, "woe");
			return -1;
		}
	case 'a': 
	case 's': 
	case 'A': 
	case 'x': 
	case 'r': 
	case 'l': 
	case 'm': 
	case 'i': 
	case 'd': 
	case 'o': 
	case 'w': 
	case '2': 
	case '4': 
	case '8': 
		if (input[1] == '?') {  
			r_core_cmd_help_match_spec (core, help_msg_wo, "wo", input[0]);
		} else if (input[1]) {  
			r_core_write_op (core, r_str_trim_head_ro (input + 1), input[0]);
		} else {  
			r_core_write_op (core, NULL, input[0]);
		}
		break;
	case 'R':
		r_core_cmd_call (core, "wr $b");
		break;
	case 'n':
		r_core_write_op (core, "ff", 'x');
		r_core_block_read (core);
		break;
	case 'E': 
	case 'D': 
		{
			int direction = (input[0] == 'E') ? R_CRYPTO_DIR_ENCRYPT : R_CRYPTO_DIR_DECRYPT;
			const char *algo = NULL;
			const char *key = NULL;
			const char *iv = NULL;
			char *space, *args = strdup (r_str_trim_head_ro (input+1));
			space = strchr (args, ' ');
			if (space) {
				*space++ = 0;
				key = space;
				space = strchr (key, ' ');
				if (space) {
					*space++ = 0;
					iv = space;
				}
			}
			algo = args;
			if (R_STR_ISNOTEMPTY (algo) && key) {
				encrypt_or_decrypt_block (core, algo, key, direction, iv);
			} else {
				r_crypto_list (core->crypto, r_cons_printf, 0);
				r_core_cmd_help_match_spec (core, help_msg_wo, "wo", input[0]);
			}
			free (args);
		}
		break;
	case 'p': 
		switch (input[1]) {
		case 'D': 
			{
				char *sp = strchr (input, ' ');
				len = sp? r_num_math (core->num, sp + 1): core->blocksize;
			}
			if (len > 0) {
				buf = (ut8*)r_debruijn_pattern (len, 0, NULL); 
				if (buf) {
					const ut8 *ptr = buf;
					ut64 addr = core->offset;
					if (input[2] == '*') {
						int i;
						r_cons_printf ("wx ");
						for (i = 0; i < len; i++) {
							r_cons_printf ("%02x", buf[i]);
						}
						r_cons_newline ();
					} else {
						if (!r_core_write_at (core, addr, ptr, len)) {
							cmd_write_fail (core);
						}
					}
					free (buf);
				} else {
					R_LOG_ERROR ("Couldn't generate pattern of length %d", len);
				}
			}
			break;
		case 'O': 
			if (strlen (input) > 3 && strncmp (input + 3, "0x", 2)) {
				R_LOG_ERROR ("Need hex value with `0x' prefix e.g. 0x41414142");
			} else if (input[2] == ' ') {
				value = r_num_get (core->num, input + 3);
				int offset = r_debruijn_offset (value, r_config_get_i (core->config, "cfg.bigendian"));
				r_core_return_value (core, offset);
				r_cons_printf ("%"PFMT64d"\n", core->num->value);
			}
			break;
		case '\0':
		case '?':
		default:
			r_core_cmd_help (core, help_msg_wop);
			break;
		}
		break;
	case '\0':
	case '?':
	default:
		r_core_cmd_help (core, help_msg_wo);
		break;
	}
	return 0;
}
