int fnic_fc_trace_set_data(unsigned int host_no, unsigned char frame_type,
				char *frame, unsigned int fc_trc_frame_len)
{
	unsigned int flags;
	struct fc_trace_hdr *fc_buf;
	unsigned int eth_fcoe_hdr_len;
	spin_lock_irqsave(&fnic_fc_trace_lock, flags);
	if (fnic_fc_trace_cleared == 1) {
		fc_trace_entries.rd_idx = fc_trace_entries.wr_idx = 0;
		pr_info("fnic: Resetting the read idx\n");
		memset((void *)fnic_fc_ctlr_trace_buf_p, 0,
				fnic_fc_trace_max_pages * PAGE_SIZE);
		fnic_fc_trace_cleared = 0;
	}
	fc_buf = (struct fc_trace_hdr *)
		fc_trace_entries.page_offset[fc_trace_entries.wr_idx];
	fc_trace_entries.wr_idx++;
	if (fc_trace_entries.wr_idx >= fc_trace_max_entries)
		fc_trace_entries.wr_idx = 0;
	if (fc_trace_entries.wr_idx == fc_trace_entries.rd_idx) {
		fc_trace_entries.rd_idx++;
		if (fc_trace_entries.rd_idx >= fc_trace_max_entries)
			fc_trace_entries.rd_idx = 0;
	}
	ktime_get_real_ts64(&fc_buf->time_stamp);
	fc_buf->host_no = host_no;
	fc_buf->frame_type = frame_type;
	fc_trace = (char *)FC_TRACE_ADDRESS(fc_buf);
	if (frame_type == FNIC_FC_RECV) {
		eth_fcoe_hdr_len = sizeof(struct ethhdr) +
					sizeof(struct fcoe_hdr);
		memset((char *)fc_trace, 0xff, eth_fcoe_hdr_len);
		memcpy((char *)(fc_trace + eth_fcoe_hdr_len), (void *)frame,
		min_t(unsigned char, fc_trc_frame_len,
			(unsigned char)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE
						- eth_fcoe_hdr_len)));
	} else {
		memcpy((char *)fc_trace, (void *)frame,
		min_t(unsigned char, fc_trc_frame_len,
			(unsigned char)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE)));
	}
	fc_buf->frame_len = fc_trc_frame_len;
	spin_unlock_irqrestore(&fnic_fc_trace_lock, flags);
	return 0;
}
