dissect_esmc_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *treex)
{
    gint     offset    = 0;
    gboolean event_flag;
    gint     ssm       = 0;
    gint     essm      = 0;
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "ESMC");
    proto_item_append_text(treex, ": ESMC");
    {
        proto_tree *tree_a;
        tree_a = proto_item_add_subtree(treex, ett_esmc);
        { 
            proto_item *item_b;
            item_b = proto_tree_add_item(tree_a, hf_esmc_version, tvb, offset, 1, ENC_BIG_ENDIAN);
            if ((tvb_get_guint8(tvb, offset) >> 4) != ESMC_VERSION_1)
            {
                expert_add_info_format(pinfo, item_b, &ei_esmc_version_compliance, "Version must be 0x%.1x claim compliance with Version 1 of this protocol", ESMC_VERSION_1);
            }
        }
        { 
            event_flag = ((tvb_get_guint8(tvb, offset) & 0x08) != 0);
            proto_tree_add_item(tree_a, hf_esmc_event_flag, tvb, offset, 1, ENC_BIG_ENDIAN);
        }
        { 
            proto_item *item_b;
            guint8 reserved;
            reserved = tvb_get_guint8(tvb, offset) & 0x07;
            item_b = proto_tree_add_uint_format_value(tree_a, hf_esmc_reserved_bits, tvb, offset, 1, reserved, "0x%.2x", reserved);
            if (reserved != 0x0)
            {
                expert_add_info_format(pinfo, item_b, &ei_esmc_reserved_not_zero, "Reserved bits must be set to all zero on transmitter");
            }
            offset += 1;
        }
        { 
            proto_item *item_b;
            guint32 reserved;
            reserved = tvb_get_ntoh24(tvb, offset);
            item_b = proto_tree_add_uint_format_value(tree_a, hf_esmc_reserved_octets, tvb, offset, 3, reserved, "0x%.6x", reserved);
            if (reserved != 0x0)
            {
                expert_add_info_format(pinfo, item_b, &ei_esmc_reserved_not_zero, "Reserved octets must be set to all zero on transmitter");
            }
            offset += 3;
        }
        proto_item_append_text(treex, ", Event:%s", event_flag ?
                               "Time-critical" : "Information");
        col_add_fstr(pinfo->cinfo, COL_INFO, "Event:%s", event_flag ?
                     "Time-critical" : "Information");
        {
            proto_item *item_b;
            guint8 type;
            item_b = proto_tree_add_item(tree_a, hf_esmc_tlv, tvb, offset, ESMC_QL_TLV_LENGTH, ENC_NA);
            {
                proto_tree *tree_b;
                tree_b = proto_item_add_subtree(item_b, ett_esmc);
                {
                    proto_item *item_c;
                    guint16 length;
                    guint8 unused;
                    type = tvb_get_guint8(tvb, offset);
                    item_c = proto_tree_add_item(tree_b, hf_esmc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);
                    if (type != ESMC_QL_TLV_TYPE)
                    {
                        expert_add_info_format(pinfo, item_c, &ei_esmc_tlv_type_ql_type_not_first, "TLV Type must be == 0x%.2x (QL) because QL TLV must be first in the ESMC PDU", ESMC_QL_TLV_TYPE);
                        expert_add_info(pinfo, item_c, &ei_esmc_tlv_type_decoded_as_ql_type);
                    }
                    proto_item_append_text(item_b, ", %s", val_to_str_const(type, esmc_tlv_type_vals, "Unknown"));
                    offset += 1;
                    length = tvb_get_ntohs(tvb, offset);
                    item_c = proto_tree_add_item(tree_b, hf_esmc_tlv_length, tvb, offset, 2, ENC_BIG_ENDIAN);
                    if (length != ESMC_QL_TLV_LENGTH)
                    {
                        expert_add_info_format(pinfo, item_c, &ei_esmc_tlv_length_bad, "QL TLV Length must be == 0x%.4x", ESMC_QL_TLV_LENGTH);
                        expert_add_info_format(pinfo, item_c, &ei_esmc_tlv_type_decoded_as_ql_type, "Let's decode this TLV as if Length has valid value");
                    }
                    offset += 2;
                    ssm = tvb_get_guint8(tvb, offset);
                    unused = ssm & 0xf0;
                    ssm &= 0x0f;
                    item_c = proto_tree_add_item(tree_b, hf_esmc_tlv_ql_unused, tvb, offset, 1, ENC_BIG_ENDIAN);
                    if (unused != 0x00)
                    {
                        expert_add_info(pinfo, item_c, &ei_esmc_tlv_ql_unused_not_zero);
                    }
                    proto_tree_add_item(tree_b, hf_esmc_tlv_ql_ssm, tvb, offset, 1, ENC_BIG_ENDIAN);
                    offset += 1;
                }
            }
        }
        if (tvb_captured_length_remaining(tvb, offset) >= ESMC_EXTENDED_QL_TLV_LENGTH)
        {
            guint8 type;
            type = tvb_get_guint8(tvb, offset);
            if (type == ESMC_EXTENDED_QL_TLV_TYPE)
            {
                proto_item *item_b;
                item_b = proto_tree_add_item(tree_a, hf_esmc_tlv, tvb, offset, ESMC_EXTENDED_QL_TLV_LENGTH, ENC_NA);
                {
                    proto_tree *tree_b;
                    tree_b = proto_item_add_subtree(item_b, ett_esmc);
                    {
                        proto_item *item_c;
                        guint16 length;
                        guint64 reserved;
                        item_c = proto_tree_add_item(tree_b, hf_esmc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);
                        if (type != ESMC_EXTENDED_QL_TLV_TYPE)
                        {
                            expert_add_info_format(pinfo, item_c, &ei_esmc_tlv_type_not_ext_ql, "TLV Type must be == 0x%.2x (Extended QL)", ESMC_EXTENDED_QL_TLV_TYPE);
                            expert_add_info(pinfo, item_c, &ei_esmc_tlv_type_decoded_as_ext_ql);
                        }
                        proto_item_append_text(item_b, ", %s", val_to_str_const(type, esmc_tlv_type_vals, "Unknown"));
                        offset += 1;
                        length = tvb_get_ntohs(tvb, offset);
                        item_c = proto_tree_add_item(tree_b, hf_esmc_tlv_length, tvb, offset, 2, ENC_BIG_ENDIAN);
                        if (length != ESMC_EXTENDED_QL_TLV_LENGTH)
                        {
                            expert_add_info_format(pinfo, item_c, &ei_esmc_tlv_length_bad, "Extended QL TLV Length must be == 0x%.4x", ESMC_EXTENDED_QL_TLV_LENGTH);
                            expert_add_info_format(pinfo, item_c, &ei_esmc_tlv_type_decoded_as_ext_ql, "Let's decode this TLV as if Length has valid value");
                        }
                        offset += 2;
                        essm = tvb_get_guint8(tvb, offset);
                        proto_tree_add_item(tree_b, hf_esmc_tlv_ext_ql_essm, tvb, offset, 1, ENC_BIG_ENDIAN);
                        offset += 1;
                        proto_tree_add_item(tree_b, hf_esmc_tlv_ext_ql_clockid, tvb, offset, 8, ENC_BIG_ENDIAN);
                        offset += 8;
                        reserved = tvb_get_guint8(tvb, offset) & 0xfc;
                        item_c = proto_tree_add_item(tree_b, hf_esmc_tlv_ext_ql_flag_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);
                        if (reserved != 0x0)
                        {
                            expert_add_info(pinfo, item_c, &ei_esmc_reserved_not_zero);
                        }
                        proto_tree_add_item(tree_b, hf_esmc_tlv_ext_ql_flag_chain, tvb, offset, 1, ENC_BIG_ENDIAN);
                        proto_tree_add_item(tree_b, hf_esmc_tlv_ext_ql_flag_mixed, tvb, offset, 1, ENC_BIG_ENDIAN);
                        offset += 1;
                        proto_tree_add_item(tree_b, hf_esmc_tlv_ext_ql_eeec, tvb, offset, 1, ENC_BIG_ENDIAN);
                        offset += 1;
                        proto_tree_add_item(tree_b, hf_esmc_tlv_ext_ql_eec, tvb, offset, 1, ENC_BIG_ENDIAN);
                        offset += 1;
                        reserved = tvb_get_guint40(tvb, offset, ENC_BIG_ENDIAN);
                        item_c = proto_tree_add_item(tree_b, hf_esmc_tlv_ext_ql_reserved, tvb, offset, 5, ENC_BIG_ENDIAN);
                        if (reserved != 0x0)
                        {
                            expert_add_info(pinfo, item_c, &ei_esmc_reserved_not_zero);
                        }
                        offset += 5;
                    }
                }
            }
        }
    }
    {
        const value_string *ql_vals;
        const value_string *ql_vals_short;
        const gchar *ql_str;
        proto_item *item_b;
        ql_vals = esmc_quality_level_vals[pref_option_network];
        ql_vals_short = esmc_quality_level_vals_short[pref_option_network];
        ql_str = try_val_to_str((essm<<8) | ssm, ql_vals);
        item_b = proto_tree_add_uint_format_value(treex, hf_esmc_quality_level, tvb, 6, offset-6,
            (essm<<8) | ssm, "%s", (NULL != ql_str) ? ql_str : "Unknown Quality Level");
        if (NULL == ql_str)
        {
            expert_add_info(pinfo, item_b, &ei_esmc_quality_level_invalid);
        }
        col_append_fstr(pinfo->cinfo, COL_INFO, ", %s",
            val_to_str_const((essm<<8) | ssm, ql_vals_short, "Unknown Quality Level"));
    }
    { 
        gint padding_size;
        padding_size = tvb_captured_length_remaining(tvb, offset);
        if (0 != padding_size)
        {
            proto_tree* tree_a;
            tree_a = proto_item_add_subtree(treex, ett_esmc);
            {
                proto_item* item_b;
                tvbuff_t* tvb_next;
                tvb_next = tvb_new_subset_remaining(tvb, offset);
                item_b = proto_tree_add_item(tree_a, hf_esmc_padding, tvb_next, 0, -1, ENC_NA);
                proto_item_append_text(item_b, ", %d %s%s", padding_size,
                    "octet", plurality(padding_size,"","s"));
                {
                    proto_tree* tree_b;
                    tree_b = proto_item_add_subtree(item_b, ett_esmc);
                    call_data_dissector(tvb_next, pinfo, tree_b);
                }
            }
        }
    }
}
