dissect_CBA_Connection_Data(tvbuff_t *tvb,
    packet_info *pinfo, proto_tree *tree, cba_ldev_t *cons_ldev, cba_frame_t *frame)
{
    guint8      u8Version;
    guint8      u8Flags;
    guint16     u16CountFix;
    guint16     u16Count;
    guint32     u32ItemIdx;
    guint32     u32HoleIdx;
    proto_item *conn_data_item = NULL;
    proto_tree *conn_data_tree = NULL;
    guint16     u16Len;
    guint32     u32ID;
    guint8      u8QC;
    guint16     u16DataLen;
    guint16     u16HdrLen;
    int         offset         = 0;
    int         offset_hole;
    gboolean    qc_reported    = FALSE;
    int         qc_good        = 0;
    int         qc_uncertain   = 0;
    int         qc_bad         = 0;
    GList      *conns;
    int         item_offset;
    cba_connection_t *conn;
    if (tree) {
        conn_data_item = proto_tree_add_item(tree, hf_cba_acco_cb_conn_data, tvb, offset, 0, ENC_NA);
        conn_data_tree = proto_item_add_subtree(conn_data_item, ett_ICBAAccoCallback_Buffer);
    }
    u8Version = tvb_get_guint8 (tvb, offset);
    if (conn_data_tree) {
        proto_tree_add_item(conn_data_tree, hf_cba_acco_cb_version, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    }
    offset += 1;
    u8Flags = tvb_get_guint8 (tvb, offset);
    if (conn_data_tree) {
        proto_tree_add_item(conn_data_tree, hf_cba_acco_cb_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    }
    offset += 1;
    u16Count = tvb_get_letohs (tvb, offset);
    if (conn_data_tree) {
        proto_tree_add_item(conn_data_tree, hf_cba_acco_cb_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    }
    offset += 2;
    u16CountFix = u16Count;
    if (frame) {
        cba_frame_info(tvb, pinfo, conn_data_tree, frame);
    } else {
        if (cons_ldev && cons_ldev->name) {
            proto_item *item;
            item = proto_tree_add_string(conn_data_tree, hf_cba_acco_conn_consumer, tvb, offset, 0, cons_ldev->name);
        }
    }
#if 0
    col_append_fstr(pinfo->cinfo, COL_INFO, " Cnt=%u", u16Count);
#endif
    if ((u8Version != CBA_MRSH_VERSION_DCOM) &&
        (u8Version != CBA_MRSH_VERSION_SRT_WITH_CONSID) &&
        (u8Version != CBA_MRSH_VERSION_SRT_WITHOUT_CONSID))
    {
        return offset;
    }
    if (u8Flags != 0) {
        return offset;
    }
    u32ItemIdx = 1;
    u32HoleIdx = 1;
    while (u16Count--) {
        proto_item *sub_item;
        proto_tree *sub_tree;
        proto_item *item;
        u16Len = tvb_get_letohs (tvb, offset);
        if (u16Len == 0 &&
            (u8Version == CBA_MRSH_VERSION_SRT_WITH_CONSID ||
            u8Version == CBA_MRSH_VERSION_SRT_WITHOUT_CONSID))
        {
            u32HoleIdx++;
            offset_hole = offset;
            while (u16Len == 0) {
                offset++;
                u16Len = tvb_get_letohs(tvb, offset);
                if (u16Len > 0x300) {
                    u16Len = 0;
                }
            }
            proto_tree_add_none_format(conn_data_tree, hf_cba_acco_cb_item_hole, tvb,
                offset_hole, offset - offset_hole,
                "Hole(--): -------------, offset=%2u, length=%2u",
                offset_hole, offset - offset_hole);
        }
        sub_item = proto_tree_add_item(conn_data_tree, hf_cba_acco_cb_item, tvb, offset, 0, ENC_NA);
        sub_tree = proto_item_add_subtree(sub_item, ett_ICBAAccoCallback_Item);
        item_offset = offset;
        if (sub_tree) {
            proto_tree_add_item(sub_tree, hf_cba_acco_cb_item_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        }
        offset    += 2;
        u16HdrLen  = 2;
        if (u8Version == CBA_MRSH_VERSION_DCOM ||
            u8Version == CBA_MRSH_VERSION_SRT_WITH_CONSID)
        {
            u32ID = tvb_get_letohl (tvb, offset);
            if (sub_tree) {
                proto_tree_add_item(sub_tree, hf_cba_acco_conn_cons_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            }
            offset    += 4;
            u16HdrLen += 4;
        } else {
            u32ID = 0;
        }
        u8QC = tvb_get_guint8 (tvb, offset);
        item = NULL;
        if (sub_tree) {
            item = proto_tree_add_item(sub_tree, hf_cba_acco_qc, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        }
        offset    += 1;
        u16HdrLen += 1;
        if ( u8QC != 0x80 && 
            u8QC != 0x1C && 
            qc_reported == 0) {
            expert_add_info_format(pinfo, item, &ei_cba_acco_qc, "%s QC: %s",
                u8Version == CBA_MRSH_VERSION_DCOM ? "DCOM" : "SRT",
                val_to_str(u8QC, cba_acco_qc_vals, "Unknown (0x%02x)"));
            qc_reported = 0;
        }
        switch(u8QC >> 6) {
        case(00):
            qc_bad++;
            break;
        case(01):
            qc_uncertain++;
            break;
        default:
            qc_good++;
        }
        u16DataLen = u16Len - u16HdrLen;
        if (u8Version == CBA_MRSH_VERSION_DCOM ||
            u8Version == CBA_MRSH_VERSION_SRT_WITH_CONSID)
        {
            proto_item_append_text(sub_item,
                "[%2u]: ConsID=0x%08x, offset=%2u, length=%2u (user-length=%2u), QC=%s (0x%02x)",
                u32ItemIdx, u32ID, offset - u16HdrLen, u16Len, u16DataLen,
                val_to_str(u8QC, cba_acco_qc_vals, "Unknown (0x%02x)"), u8QC );
        } else {
            proto_item_append_text(sub_item,
                "[%2u]: ConsID=-, offset=%2u, length=%2u (user-length=%2u), QC=%s (0x%02x)",
                u32ItemIdx, offset - u16HdrLen, u16Len, u16DataLen,
                val_to_str(u8QC, cba_acco_qc_vals, "Unknown (0x%02x)"), u8QC );
        }
        proto_item_set_len(sub_item, u16Len);
        proto_tree_add_item(sub_tree, hf_cba_acco_cb_item_data, tvb, offset, u16DataLen, ENC_NA);
        offset += u16DataLen;
        if (frame != NULL ) {
            cba_frame_incoming_data(tvb, pinfo, sub_tree, frame);
            for(conns = frame->conns; conns != NULL; conns = g_list_next(conns)) {
                conn = (cba_connection_t *)conns->data;
                if (conn->frame_offset == item_offset) {
                    cba_connection_info(tvb, pinfo, sub_tree, conn);
                    break;
                }
            }
        } else {
            if (cons_ldev != NULL) {
                for(conns = cons_ldev->consconns; conns != NULL; conns = g_list_next(conns)) {
                    conn = (cba_connection_t *)conns->data;
                    if (conn->consid == u32ID) {
                        cba_connection_info(tvb, pinfo, sub_tree, conn);
                        cba_connection_incoming_data(tvb, pinfo, sub_tree, conn);
                        break;
                    }
                }
            }
        }
        u32ItemIdx++;
    }
    if (u8Version == 1) {
        proto_item_append_text(conn_data_item,
            ": Version=0x%x (DCOM), Flags=0x%x, Count=%u",
            u8Version, u8Flags, u16CountFix);
    } else {
        proto_item_append_text(conn_data_item,
            ": Version=0x%x (SRT), Flags=0x%x, Count=%u, Items=%u, Holes=%u",
            u8Version, u8Flags, u16CountFix, u32ItemIdx-1, u32HoleIdx-1);
    }
    proto_item_set_len(conn_data_item, offset);
    col_append_fstr(pinfo->cinfo, COL_INFO, ", QC (G:%u,U:%u,B:%u)",
        qc_good, qc_uncertain, qc_bad);
    return offset;
}
