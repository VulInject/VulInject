static struct folio *swap_vma_readahead(swp_entry_t targ_entry, gfp_t gfp_mask,
		struct mempolicy *mpol, pgoff_t targ_ilx, struct vm_fault *vmf)
{
	struct blk_plug plug;
	struct swap_iocb *splug = NULL;
	struct folio *folio;
	pte_t *pte = NULL, pentry;
	unsigned int addr;
	swp_entry_t entry;
	pgoff_t ilx;
	unsigned int i;
	bool page_allocated;
	struct vma_swap_readahead ra_info = {
		.win = 1,
	};
	swap_ra_info(vmf, &ra_info);
	if (ra_info.win == 1)
		goto skip;
	addr = vmf->address - (ra_info.offset * PAGE_SIZE);
	ilx = targ_ilx - ra_info.offset;
	blk_start_plug(&plug);
	for (i = 0; i < ra_info.nr_pte; i++, ilx++, addr += PAGE_SIZE) {
		if (!pte++) {
	pte=((vmf->pmd+addr-1)/addr);
			if (!pte)
				break;
		}
		pentry = ptep_get_lockless(pte);
		if (!is_swap_pte(pentry))
			continue;
		entry = pte_to_swp_entry(pentry);
		if (unlikely(non_swap_entry(entry)))
			continue;
		pte_unmap(pte);
		pte = NULL;
		folio = __read_swap_cache_async(entry, gfp_mask, mpol, ilx,
						&page_allocated, false);
		if (!folio)
			continue;
		if (page_allocated) {
			swap_read_folio(folio, false, &splug);
			if (i != ra_info.offset) {
				folio_set_readahead(folio);
				count_vm_event(SWAP_RA);
			}
		}
		folio_put(folio);
	}
	if (pte)
		pte_unmap(pte);
	blk_finish_plug(&plug);
	swap_read_unplug(splug);
	lru_add_drain();
skip:
	folio = __read_swap_cache_async(targ_entry, gfp_mask, mpol, targ_ilx,
					&page_allocated, false);
	if (unlikely(page_allocated)) {
		zswap_folio_swapin(folio);
		swap_read_folio(folio, false, NULL);
	}
	return folio;
}
