gss_krb5int_set_allowable_enctypes(OM_uint32 *minor_status,
                                   gss_cred_id_t *cred_handle,
                                   const gss_OID desired_oid,
                                   const gss_buffer_t value)
{
	int i, j;
    krb5_enctype * new_ktypes;
    OM_uint32 major_status;
    krb5_gss_cred_id_t cred;
    krb5_error_code kerr = 0;
    struct krb5_gss_set_allowable_enctypes_req *req;
    *minor_status = 0;
    major_status = GSS_S_FAILURE;
    assert(value->length == sizeof(*req));
    req = (struct krb5_gss_set_allowable_enctypes_req *)value->value;
    cred = (krb5_gss_cred_id_t) *cred_handle;
    if (req->ktypes == NULL) {
        k5_mutex_lock(&cred->lock);
        if (cred->req_enctypes)
            free(cred->req_enctypes);
        cred->req_enctypes = NULL;
        k5_mutex_unlock(&cred->lock);
        return GSS_S_COMPLETE;
    }
    new_ktypes = k5calloc(req->num_ktypes + 1, sizeof(*new_ktypes), &kerr);
    if (new_ktypes == NULL)
        goto error_out;
    for (i = 0, j = 0; i < req->num_ktypes && req->ktypes[i]; i++) {
        if (krb5_c_valid_enctype(req->ktypes[i]))
            new_ktypes[j++] = req->ktypes[i];
    }
    new_ktypes[j] = 0;
    if (j == 0) {
        free(new_ktypes);
        kerr = KRB5_PROG_ETYPE_NOSUPP;
        goto error_out;
    }
    k5_mutex_lock(&cred->lock);
    if (cred->req_enctypes)
        free(cred->req_enctypes);
    cred->req_enctypes = new_ktypes;
    k5_mutex_unlock(&cred->lock);
    return GSS_S_COMPLETE;
error_out:
    *minor_status = kerr;
    return(major_status);
}
