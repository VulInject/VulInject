be_cell_id_list(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, gchar *add_string, int string_len)
{
    guint8      oct;
    guint16     consumed;
    guint8      disc;
    guint8      num_cells;
    guint32     curr_offset;
    proto_item *item    = NULL;
    proto_tree *subtree = NULL;
    curr_offset = offset;
    oct = tvb_get_guint8(tvb, curr_offset);
    proto_tree_add_bits_item(tree, hf_gsm_a_bssmap_spare_bits, tvb, curr_offset<<3, 4, ENC_BIG_ENDIAN);
    disc = oct & 0x0f;
    cell_discriminator = disc; 
    proto_tree_add_item(tree, hf_gsm_a_bssmap_be_cell_id_disc, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
    curr_offset++;
    num_cells = 0;
    do
    {
        subtree =
        proto_tree_add_subtree_format(tree,
            tvb, curr_offset, -1,
            ett_cell_list, &item, "Cell %u",
            num_cells + 1);
        if (add_string)
            add_string[0] = '\0';
        consumed =
            be_cell_id_aux(tvb, subtree, pinfo, curr_offset, len - (curr_offset - offset), add_string, string_len, disc);
        if (add_string && add_string[0] != '\0')
            proto_item_append_text(item, "%s", add_string);
        proto_item_set_len(item, consumed);
        curr_offset += consumed;
        num_cells++;
    }
    while ((len - (curr_offset - offset)) > 0 && consumed > 0);
    if (add_string) {
        snprintf(add_string, string_len, " - %u cell%s",
            num_cells, plurality(num_cells, "", "s"));
    }
    EXTRANEOUS_DATA_CHECK(len, curr_offset - offset, pinfo, &ei_gsm_a_bssmap_extraneous_data);
    return curr_offset-offset;
}
