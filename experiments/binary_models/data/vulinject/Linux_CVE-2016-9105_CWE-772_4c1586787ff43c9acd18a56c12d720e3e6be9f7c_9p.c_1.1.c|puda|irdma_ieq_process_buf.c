static int irdma_ieq_process_buf(struct irdma_puda_rsrc *ieq,
				 struct irdma_pfpdu *pfpdu,
				 struct irdma_puda_buf *buf)
{
	unsigned short fpdu_len = 0;
	unsigned short datalen = buf->datalen;
	unsigned char *datap = buf->data;
	unsigned char *crcptr;
	unsigned short ioffset = 0;
	unsigned int mpacrc;
	unsigned int seqnum = buf->seqnum;
	unsigned short len = 0;
	unsigned short full = 0;
	bool partial = false;
	struct irdma_puda_buf *txbuf;
	struct list_head *rxlist = &pfpdu->rxlist;
	int ret = 0;
	ioffset = (unsigned short)(buf->data - (unsigned char *)buf->mem.va);
	while (datalen) {
		fpdu_len = irdma_ieq_get_fpdu_len(pfpdu, datap, buf->seqnum);
		if (!fpdu_len) {
			ibdev_dbg(to_ibdev(ieq->dev),
				  "IEQ: error bad fpdu len\n");
			list_add(&buf->list, rxlist);
			return -EINVAL;
		}
		if (datalen < fpdu_len) {
			partial = true;
			break;
		}
		crcptr = datap + fpdu_len - 4;
		mpacrc = *(unsigned int *)crcptr;
		if (ieq->check_crc)
			ret = irdma_ieq_check_mpacrc(ieq->hash_desc, datap,
						     fpdu_len - 4, mpacrc);
		if (ret) {
			list_add(&buf->list, rxlist);
			ibdev_dbg(to_ibdev(ieq->dev),
				  "ERR: IRDMA_ERR_MPA_CRC\n");
			return -EINVAL;
		}
		full++;
		pfpdu->fpdu_processed++;
		ieq->fpdu_processed++;
		datap += fpdu_len;
		len += fpdu_len;
		datalen -= fpdu_len;
	}
	if (full) {
		txbuf = irdma_puda_get_bufpool(ieq);
		if (!txbuf) {
			pfpdu->no_tx_bufs++;
			list_add(&buf->list, rxlist);
			return -ENOBUFS;
		}
		if (ieq->dev->hw_attrs.uk_attrs.hw_rev >= IRDMA_GEN_2) {
			irdma_ieq_copy_to_txbuf(buf, txbuf, ioffset,
						txbuf->hdrlen, len);
			txbuf->totallen = txbuf->hdrlen + len;
			txbuf->ah_id = pfpdu->ah->ah_info.ah_idx;
		} else {
			irdma_ieq_copy_to_txbuf(buf, txbuf, ioffset,
						buf->hdrlen, len);
			txbuf->totallen = buf->hdrlen + len;
		}
		irdma_ieq_update_tcpip_info(txbuf, len, buf->seqnum);
		print_hex_dump_debug("IEQ: IEQ TX BUFFER", DUMP_PREFIX_OFFSET,
				     16, 8, txbuf->mem.va, txbuf->totallen,
				     false);
		txbuf->do_lpb = true;
		irdma_puda_send_buf(ieq, txbuf);
		if (!datalen) {
			pfpdu->rcv_nxt = buf->seqnum + len;
			irdma_puda_ret_bufpool(ieq, buf);
			return 0;
		}
		buf->data = datap;
		buf->seqnum = seqnum + len;
		buf->datalen = datalen;
		pfpdu->rcv_nxt = buf->seqnum;
	}
	if (partial)
		return irdma_ieq_handle_partial(ieq, pfpdu, buf, fpdu_len);
	return 0;
}
