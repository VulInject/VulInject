print_packet(capture_file *cf, frame_data *fdata, wtap_rec *rec, Buffer *buf,
        void *argsp)
{
    print_callback_args_t *args = (print_callback_args_t *)argsp;
    int             i;
    char           *cp;
    int             line_len;
    int             column_len;
    int             cp_off;
    char            bookmark_name[9+10+1];  
    char            bookmark_title[6+10+1]; 
    col_item_t*     col_item;
    const gchar*    col_text;
    if (args->print_args->print_summary) {
        col_custom_prime_edt(&args->edt, &cf->cinfo);
        epan_dissect_run(&args->edt, cf->cd_t, rec,
                frame_tvbuff_new_buffer(&cf->provider, fdata, buf),
                fdata, &cf->cinfo);
        epan_dissect_fill_in_columns(&args->edt, FALSE, TRUE);
    } else
        epan_dissect_run(&args->edt, cf->cd_t, rec,
                frame_tvbuff_new_buffer(&cf->provider, fdata, buf),
                fdata, NULL);
    if (args->print_formfeed) {
        if (!new_page(args->print_args->stream))
            goto fail;
        if (args->print_args->print_col_headings)
            args->print_header_line = TRUE;
    } else {
        if (args->print_separator) {
            if (!print_line(args->print_args->stream, 0, ""))
                goto fail;
        }
    }
    snprintf(bookmark_name, sizeof bookmark_name, "__frame%u__", fdata->num);
    if (args->print_args->print_summary) {
        if (!args->print_args->print_col_headings)
            args->print_header_line = FALSE;
        if (args->print_header_line) {
            if (!print_line(args->print_args->stream, 0, args->header_line_buf))
                goto fail;
            args->print_header_line = FALSE;  
        }
        cp = &args->line_buf[0];
        line_len = 0;
        for (i = 0; i < args->num_visible_cols; i++) {
            col_item = &cf->cinfo.columns[args->visible_cols[i]];
            col_text = get_column_text(&cf->cinfo, args->visible_cols[i]);
            column_len = (int) strlen(col_text);
            if (args->col_widths[i] > column_len)
                column_len = args->col_widths[i];
            line_len += column_len + 1;   
            if (line_len > args->line_buf_len) {
                cp_off = (int) (cp - args->line_buf);
                args->line_buf_len = 2 * line_len;
                args->line_buf = (char *)g_realloc(args->line_buf, args->line_buf_len + 1);
                cp = args->line_buf + cp_off;
            }
            if (col_item->col_fmt == COL_NUMBER)
                snprintf(cp, column_len+1, "%*s", args->col_widths[i], col_text);
            else
                snprintf(cp, column_len+1, "%-*s", args->col_widths[i], col_text);
            cp += column_len;
            if (i != args->num_visible_cols - 1)
                *cp++ = ' ';
        }
        *cp = '\0';
        if (!print_bookmark(args->print_args->stream, bookmark_name,
                    args->line_buf))
            goto fail;
        if (!print_line(args->print_args->stream, 0, args->line_buf))
            goto fail;
    } else {
        snprintf(bookmark_title, sizeof bookmark_title, "Frame %u", fdata->num);
        if (!print_bookmark(args->print_args->stream, bookmark_name,
                    bookmark_title))
            goto fail;
    } 
    if (args->print_args->print_dissections != print_dissections_none) {
        if (args->print_args->print_summary) {
            if (!print_line(args->print_args->stream, 0, ""))
                goto fail;
        }
        if (!proto_tree_print(args->print_args->print_dissections,
                    args->print_args->print_hex, &args->edt, NULL,
                    args->print_args->stream))
            goto fail;
        args->print_separator = TRUE;
        if (args->print_args->print_col_headings)
            args->print_header_line = TRUE;
    }
    if (args->print_args->print_hex) {
        if (args->print_args->print_summary || (args->print_args->print_dissections != print_dissections_none)) {
            if (!print_line(args->print_args->stream, 0, ""))
                goto fail;
        }
        if (!print_hex_data(args->print_args->stream, &args->edt, args->print_args->hexdump_options))
            goto fail;
        args->print_separator = TRUE;
        if (args->print_args->print_col_headings)
            args->print_header_line = TRUE;
    } 
    if (args->print_args->print_formfeed) {
        args->print_formfeed = TRUE;
    }
    return true;
fail:
    epan_dissect_reset(&args->edt);
    return false;
}
