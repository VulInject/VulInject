static int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr, size_t len)
{
	struct onenand_chip *this = mtd->priv;
	int value, block, page;
	switch (cmd) {
	case ONENAND_CMD_UNLOCK:
	case ONENAND_CMD_LOCK:
	case ONENAND_CMD_LOCK_TIGHT:
	case ONENAND_CMD_UNLOCK_ALL:
		block = -1;
		page = -1;
		break;
	case FLEXONENAND_CMD_PI_ACCESS:
		block = addr * this->density_mask;
		page = -1;
		break;
	case ONENAND_CMD_ERASE:
	case ONENAND_CMD_MULTIBLOCK_ERASE:
	case ONENAND_CMD_ERASE_VERIFY:
	case ONENAND_CMD_BUFFERRAM:
	case ONENAND_CMD_OTP_ACCESS:
		page = -1;
		break;
	case FLEXONENAND_CMD_READ_PI:
		cmd = ONENAND_CMD_READ;
		block = addr * this->density_mask;
		page = 0;
		break;
	default:
		block = onenand_block(this, addr);
		if (FLEXONENAND(this))
			page = (int) (addr - onenand_addr(this, block))>>\
				this->page_shift;
		else
			page = (int) (addr >> this->page_shift);
		if (ONENAND_IS_2PLANE(this)) {
			block &= ~1;
			if (addr & this->writesize)
				block++;
			page >>= 1;
		}
		page &= this->page_mask;
		break;
	}
	if (cmd == ONENAND_CMD_BUFFERRAM) {
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
		if (ONENAND_IS_2PLANE(this) || ONENAND_IS_4KB_PAGE(this))
			ONENAND_SET_BUFFERRAM0(this);
		else
			ONENAND_SET_NEXT_BUFFERRAM(this);
		return 0;
	}
	if (block != -1) {
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
	}
	if (page != -1) {
		int sectors = 0, count = 0;
		int dataram;
		switch (cmd) {
		case FLEXONENAND_CMD_RECOVER_LSB:
		case ONENAND_CMD_READ:
		case ONENAND_CMD_READOOB:
			if (ONENAND_IS_4KB_PAGE(this))
				dataram = ONENAND_SET_BUFFERRAM0(this);
			else
				dataram = ONENAND_SET_NEXT_BUFFERRAM(this);
			break;
		default:
			if (ONENAND_IS_2PLANE(this) && cmd == ONENAND_CMD_PROG)
				cmd = ONENAND_CMD_2X_PROG;
			dataram = ONENAND_CURRENT_BUFFERRAM(this);
			break;
		}
		value = onenand_page_address(page, sectors);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS8);
		value = onenand_buffer_address(dataram, sectors, count);
		this->write_word(value, this->base + ONENAND_REG_START_BUFFER);
	}
	this->write_word(ONENAND_INT_CLEAR, this->base + ONENAND_REG_INTERRUPT);
	this->write_word(cmd, this->base + ONENAND_REG_COMMAND);
	return 0;
}
