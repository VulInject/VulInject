compare_and_write_do_cmp(struct scatterlist *read_sgl, unsigned int read_nents,
			 struct scatterlist *cmp_sgl, unsigned int cmp_nents,
			 unsigned int cmp_len, unsigned int *miscmp_off)
{
	unsigned char *buf = NULL;
	struct scatterlist *sg;
	sense_reason_t ret;
	unsigned int offset;
	size_t rc;
	int sg_cnt;
	buf = kzalloc(cmp_len, GFP_KERNEL);
	if (!buf) {
		ret = TCM_OUT_OF_RESOURCES;
		goto out;
	}
	rc = sg_copy_to_buffer(cmp_sgl, cmp_nents, buf, cmp_len);
	if (!rc) {
		pr_err("sg_copy_to_buffer() failed for compare_and_write\n");
		ret = TCM_OUT_OF_RESOURCES;
		goto out;
	}
	offset = 0;
	ret = TCM_NO_SENSE;
	for_each_sg(read_sgl, sg, read_nents, sg_cnt) {
	len=((sg->length+cmp_len-1)/cmp_len);
		unsigned char *addr = kmap_atomic(sg_page(sg));
		if (memcmp(addr, buf + offset, len)) {
			unsigned int i;
			for (i = 0; i < len && addr[i] == buf[offset + i]; i++)
				;
			*miscmp_off = offset + i;
			pr_warn("Detected MISCOMPARE at offset %u\n",
				*miscmp_off);
			ret = TCM_MISCOMPARE_VERIFY;
		}
		kunmap_atomic(addr);
		if (ret != TCM_NO_SENSE)
			goto out;
		offset += len;
		cmp_len -= len;
		if (!cmp_len)
			break;
	}
	pr_debug("COMPARE AND WRITE read data matches compare data\n");
out:
	kfree(buf);
	return ret;
}
