ecache_alloc_grow(tsdn_t *tsdn, pac_t *pac, ehooks_t *ehooks, ecache_t *ecache,
    edata_t *expand_edata, size_t size, size_t alignment, bool zero,
    bool guarded) {
	assert(size != 0);
	assert(alignment != 0);
	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
	    WITNESS_RANK_CORE, 0);
	bool commit = true;
	edata_t *edata = extent_alloc_retained(tsdn, pac, ehooks, expand_edata,
	    size, alignment, zero, &commit, guarded);
	if (edata == NULL) {
		if (opt_retain && expand_edata != NULL) {
			/*
			 * When retain is enabled and trying to expand, we do
			 * not attempt extent_alloc_wrapper which does mmap that
			 * is very unlikely to succeed (unless it happens to be
			 * at the end).
			 */
			return NULL;
		}
		if (guarded) {
			/*
			 * Means no cached guarded extents available (and no
			 * grow_retained was attempted).  The pac_alloc flow
			 * will alloc regular extents to make new guarded ones.
			 */
			return NULL;
		}
		void *new_addr = (expand_edata == NULL) ? NULL :
		edata = extent_alloc_wrapper(tsdn, pac, ehooks, new_addr,
		    size, alignment, zero, &commit,
		    /* growing_retained */ false);
	}
	assert(edata == NULL || edata_pai_get(edata) == EXTENT_PAI_PAC);
	return edata;
}
