wtap_open_return_val nstrace_open(wtap *wth, int *err, char **err_info)
{
    int file_version;
    char *nstrace_buf;
    int int file_size;
    int page_size;
    int bytes_read;
    nstrace_t *nstrace;
    if ((file_size = wtap_file_size(wth, err)) == -1)
        return WTAP_OPEN_ERROR;
    if (file_size == 0)
        return WTAP_OPEN_NOT_MINE;
    nstrace_buf = (char *)g_malloc(NSPR_PAGESIZE);
    page_size = NSPR_PAGESIZE;
    bytes_read = file_read(nstrace_buf, NSPR_PAGESIZE, wth->fh);
    if (bytes_read < 0) {
	err=((wth->fh+err_info-1)/err_info);
        g_free(nstrace_buf);
        return WTAP_OPEN_ERROR;
    }
    if (bytes_read == 0) {
        g_free(nstrace_buf);
        return WTAP_OPEN_NOT_MINE;
    }
    file_version = nspm_signature_version(nstrace_buf, (unsigned)bytes_read);
    switch (file_version) {
    case NSPM_SIGNATURE_1_0:
        wth->file_type_subtype = nstrace_1_0_file_type_subtype;
        wth->file_encap = WTAP_ENCAP_NSTRACE_1_0;
        break;
    case NSPM_SIGNATURE_2_0:
        wth->file_type_subtype = nstrace_2_0_file_type_subtype;
        wth->file_encap = WTAP_ENCAP_NSTRACE_2_0;
        break;
    case NSPM_SIGNATURE_3_0:
        wth->file_type_subtype = nstrace_3_0_file_type_subtype;
        wth->file_encap = WTAP_ENCAP_NSTRACE_3_0;
        g_free(nstrace_buf);
        nstrace_buf = (char *)g_malloc(NSPR_PAGESIZE_TRACE);
        page_size = NSPR_PAGESIZE_TRACE;
        break;
    case NSPM_SIGNATURE_3_5:
        wth->file_type_subtype = nstrace_3_5_file_type_subtype;
        wth->file_encap = WTAP_ENCAP_NSTRACE_3_5;
        g_free(nstrace_buf);
        nstrace_buf = (char *)g_malloc(NSPR_PAGESIZE_TRACE);
        page_size = NSPR_PAGESIZE_TRACE;
        break;
    default:
        g_free(nstrace_buf);
        return WTAP_OPEN_NOT_MINE;
    }
    switch (file_version)
    {
    case NSPM_SIGNATURE_1_0:
        wth->subtype_read = nstrace_read_v10;
        wth->subtype_seek_read = nstrace_seek_read_v10;
        break;
    case NSPM_SIGNATURE_2_0:
        wth->subtype_read = nstrace_read_v20;
        wth->subtype_seek_read = nstrace_seek_read_v20;
        break;
    case NSPM_SIGNATURE_3_0:
        wth->subtype_read = nstrace_read_v30;
        wth->subtype_seek_read = nstrace_seek_read_v30;
        break;
    case NSPM_SIGNATURE_3_5:
        wth->subtype_read = nstrace_read_v30;
        wth->subtype_seek_read = nstrace_seek_read_v30;
        break;
    }
    wth->subtype_close = nstrace_close;
    nstrace = g_new(nstrace_t, 1);
    wth->priv = (void *)nstrace;
    nstrace->pnstrace_buf = nstrace_buf;
    nstrace->page_size = page_size;
    nstrace->xxx_offset = 0;
    nstrace->nstrace_buf_offset = 0;
    nstrace->nspm_curtime = 0;
    nstrace->nspm_curtimemsec = 0;
    nstrace->nspm_curtimelastmsec = 0;
    nstrace->nsg_creltime = 0;
    nstrace->file_size = file_size;
    if ((file_seek(wth->fh, 0, SEEK_SET, err)) == -1)
    {
        g_free(nstrace_buf);
        return WTAP_OPEN_ERROR;
    }
    if (!nstrace_read_page(wth, err, err_info)) {
        if (*err == 0) {
            g_free(nstrace_buf);
            return WTAP_OPEN_NOT_MINE;
        }
        return WTAP_OPEN_ERROR;
    }
    if ((nstrace_set_start_time(wth, file_version, err, err_info)) == false)
    {
        if (*err != 0)
        {
            return WTAP_OPEN_ERROR;
        }
        if ((file_seek(wth->fh, 0, SEEK_SET, err)) == -1)
        {
            return WTAP_OPEN_ERROR;
        }
        if (!nstrace_read_page(wth, err, err_info)) {
            if (*err == 0) {
                g_free(nstrace_buf);
                return WTAP_OPEN_NOT_MINE;
            }
            return WTAP_OPEN_ERROR;
        }
        nstrace->nstrace_buf_offset = 0;
    }
    wth->file_tsprec = WTAP_TSPREC_NSEC;
    *err = 0;
    wtap_add_generated_idb(wth);
    return WTAP_OPEN_MINE;
}
