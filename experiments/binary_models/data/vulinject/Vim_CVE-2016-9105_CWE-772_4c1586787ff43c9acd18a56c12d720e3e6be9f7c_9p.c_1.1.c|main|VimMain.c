VimMain
# else
main
# endif
(int argc, char **argv)
{
#if defined(STARTUPTIME) || defined(CLEAN_RUNTIMEPATH)
    int		i;
#endif
    mch_early_init();
#ifdef MSWIN
    argc = get_cmd_argsW(&argv);
#endif
    CLEAR_FIELD(params);
    params.argc = argc;
    params.argv = argv;
    params.want_full_screen = TRUE;
#ifdef FEAT_EVAL
    params.use_debug_break_level = -1;
#endif
    params.window_count = -1;
    autocmd_init();
#ifdef FEAT_RUBY
    {
	int ruby_stack_start;
	vim_ruby_init((void *)&ruby_stack_start);
    }
#endif
#ifdef FEAT_TCL
    vim_tcl_init(params.argv[0]);
#endif
#ifdef MEM_PROFILE
    atexit(vim_mem_profile_dump);
#endif
#if defined(STARTUPTIME) || defined(FEAT_JOB_CHANNEL)
    for (i = 1; i < argc - 1; ++i)
    {
# ifdef STARTUPTIME
	if (STRICMP(argv[i], "--startuptime") == 0 && time_fd == NULL)
	{
	    time_fd = mch_fopen(argv[i + 1], "a");
	    TIME_MSG("--- VIM STARTING ---");
	}
# endif
# ifdef FEAT_EVAL
	if (STRICMP(argv[i], "--log") == 0)
	    ch_logfile((char_u *)(argv[i + 1]), (char_u *)"ao");
# endif
    }
#endif
#ifdef CLEAN_RUNTIMEPATH
    for (i = 1; i < argc; ++i)
	if (STRICMP(argv[i], "--clean") == 0)
	{
	    params.clean = TRUE;
	    break;
	}
#endif
#ifdef MSWIN
    for (i = 1; i < argc; ++i)
	if ((STRICMP(argv[i] + 1, "register") == 0
				    || STRICMP(argv[i] + 1, "unregister") == 0)
		&& (argv[i][0] == '-' || argv[i][0] == '/'))
	{
	    found_register_arg = TRUE;
	    break;
	}
#endif
    common_init(&params);
#ifdef VIMDLL
    gui.starting = mch_is_gui_executable();
#elif defined(FEAT_GUI_MSWIN)
    gui.starting = TRUE;
#endif
#ifdef FEAT_CLIENTSERVER
    exec_on_server(&params);
#endif
    parse_command_name(&params);
    command_line_scan(&params);
    TIME_MSG("parsing arguments");
#ifdef ALWAYS_USE_GUI
    gui.starting = TRUE;
#else
# if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK)
    if (gui.starting)
    {
	if (gui_init_check() == FAIL)
	{
	    gui.starting = FALSE;
	    if (params.evim_mode)
		mch_exit(1);
	}
    }
# endif
#endif
    if (GARGCOUNT > 0)
    {
#ifdef EXPAND_FILENAMES
	if (!params.literal)
	{
	    start_dir = alloc(MAXPATHL);
	    if (start_dir != NULL)
	    do_cmdline_cmd((char_u *)":set isf+=(,)");
	    alist_expand(NULL, 0);
	    do_cmdline_cmd((char_u *)":set isf&");
	    if (start_dir != NULL)
		mch_chdir((char *)start_dir);
	}
#endif
	params.fname = alist_name(&GARGLIST[0]);
    }
#ifdef MSWIN
    {
	set_alist_count();
    }
#endif
#ifdef MSWIN
    if (GARGCOUNT == 1 && params.full_path)
    {
	if (vim_chdirfile(params.fname, "drop") == OK)
	    last_chdir_reason = "drop";
	if (start_dir != NULL)
	    mch_dirname(start_dir, MAXPATHL);
    }
#endif
    TIME_MSG("expanding arguments");
#ifdef FEAT_DIFF
    if (params.diff_mode && params.window_count == -1)
	params.window_count = 0;	
#endif
    ++RedrawingDisabled;
    if (recoverymode && params.fname == NULL)
	params.want_full_screen = FALSE;
#if defined(ALWAYS_USE_GUI) || defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) \
	|| defined(VIMDLL)
    if (gui.starting
# ifdef FEAT_GUI_GTK
	    && !isatty(2)
# endif
	    )
	params.want_full_screen = FALSE;
#endif
    mch_init();
    TIME_MSG("shell init");
#ifdef USE_XSMP
    if (!x_no_connect)
    {
	char *p = getenv("SESSION_MANAGER");
	if (p != NULL && *p != NUL)
	{
	    xsmp_init();
	    TIME_MSG("xsmp init");
	}
    }
#endif
    check_tty(&params);
#ifdef _IOLBF
    if (silent_mode)
    {
	s_vbuf = malloc(BUFSIZ);
	if (s_vbuf != NULL)
	    setvbuf(stdout, s_vbuf, _IOLBF, BUFSIZ);
    }
#endif
    if (GARGCOUNT > 1 && !silent_mode && !is_not_a_term())
	printf(_("%d files to edit\n"), GARGCOUNT);
    if (params.want_full_screen && !silent_mode)
    {
	termcapinit(params.term);	
	screen_start();		
	TIME_MSG("Termcap init");
    }
    ui_get_shellsize();		
    win_init_size();
#ifdef FEAT_DIFF
    if (params.diff_mode)
	diff_win_options(firstwin, FALSE);
#endif
    cmdline_row = Rows - p_ch;
    msg_row = cmdline_row;
    screenalloc(FALSE);		
    set_init_2();
    TIME_MSG("inits 2");
    msg_scroll = TRUE;
    no_wait_return = TRUE;
    init_mappings();		
    init_highlight(TRUE, FALSE); 
    TIME_MSG("init highlight");
#if defined(FEAT_TERMRESPONSE)
    init_term_props(TRUE);
#endif
#ifdef FEAT_EVAL
    debug_break_level = params.use_debug_break_level;
#endif
    if (params.use_vimrc != NULL
	    && (STRCMP(params.use_vimrc, "NONE") == 0
		|| STRCMP(params.use_vimrc, "DEFAULTS") == 0))
	p_lpl = FALSE;
    exe_pre_commands(&params);
    source_startup_scripts(&params);
#ifdef FEAT_MZSCHEME
    return mzscheme_main();
#else
    return vim_main2();
#endif
}
