radius_print(netdissect_options *ndo,
             const u_char *dat, const u_int length)
{
   const struct radius_hdr *rad;
   u_int len, auth_idx;
   ndo->ndo_protocol = "radius";
   nd_print_protocol_caps(ndo);
   ND_ICHECK_U(length, <, MIN_RADIUS_LEN);
   rad = (const struct radius_hdr *)dat;
   len = GET_BE_U_2(rad->len);
   ND_ICHECKMSG_U("length", len, <, MIN_RADIUS_LEN);
   ND_ICHECKMSG_U("length", len, >, 4096);
   ND_ICHECKMSG_U("length", len, >, length);
   if (ndo->ndo_vflag < 1) {
       ND_PRINT(", %s (%u), id: 0x%02x, length: %u",
              tok2str(radius_command_values,"Unknown Command",GET_U_1(rad->code)),
              GET_U_1(rad->code),
              GET_U_1(rad->id),
              len);
       return;
   } else {
       ND_PRINT(", length: %u\n\t%s (%u), id: 0x%02x, Authenticator: ",
              len,
              tok2str(radius_command_values,"Unknown Command",GET_U_1(rad->code)),
              GET_U_1(rad->code),
              GET_U_1(rad->id));
       for(auth_idx=0; auth_idx < 16; auth_idx++)
            ND_PRINT("%02x", GET_U_1((rad->auth + auth_idx)));
   }
   if (len > MIN_RADIUS_LEN)
      radius_attrs_print(ndo, dat + MIN_RADIUS_LEN, len - MIN_RADIUS_LEN);
   return;
invalid:
   nd_print_invalid(ndo);
}
