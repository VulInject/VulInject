static void fs_readdir(void *obj, void *data, QGuestAllocator *t_alloc)
{
    QVirtio9P *v9p = obj;
    char *wnames[] = { g_strdup(QTEST_V9FS_SYNTH_READDIR_DIR) };
    uint16_t nqid;
    v9fs_qid qid;
    uint32_t count, nentries;
    struct V9fsDirent *entries = NULL;
    tattach({ .client = v9p });
    twalk({
        .client = v9p, .fid = 0, .newfid = 1,
        .nwname = 1, .wnames = wnames, .rwalk.nwqid = &nqid
    });
    g_assert_cmpint(nqid, ==, 1);
    tlopen({
        .client = v9p, .fid = 1, .flags = O_DIRECTORY, .rlopen.qid = &qid
    });
    /*
     * submit count = msize - 11, because 11 is the header size of Rreaddir
     */
    treaddir({
        .client = v9p, .fid = 1, .offset = 0, .count = P9_MAX_SIZE - 11,
        .rreaddir = {
            .count = &count, .nentries = &nentries, .entries = &entries
        }
    });
    /*
     * Assuming msize (P9_MAX_SIZE) is large enough so we can retrieve all
     * dir entries with only one readdir request.
     */
    g_assert_cmpint(
        nentries, ==,
        QTEST_V9FS_SYNTH_READDIR_NFILES + 2 /* "." and ".." */
    );
    /*
     * Check all file names exist in returned entries, ignore their order
     * though.
     */
    g_assert_cmpint(fs_dirents_contain_name(entries, "."), ==, true);
    g_assert_cmpint(fs_dirents_contain_name(entries, ".."), ==, true);
    for (int i = 0; i < QTEST_V9FS_SYNTH_READDIR_NFILES; ++i) {
        g_autofree char *name =
            g_strdup_printf(QTEST_V9FS_SYNTH_READDIR_FILE, i);
        g_assert_cmpint(fs_dirents_contain_name(entries, name), ==, true);
    }
    v9fs_free_dirents(entries);
    g_free(wnames[0]);
}
