ecache_evict(tsdn_t *tsdn, pac_t *pac, ehooks_t *ehooks,
    ecache_t *ecache, size_t npages_min) {
	malloc_mutex_lock(tsdn, &ecache->mtx);
	/*
	 * Get the LRU coalesced extent, if any.  If coalescing was delayed,
	 * the loop will iterate until the LRU extent is fully coalesced.
	 */
	edata_t *edata;
	while (true) {
		/* Get the LRU extent, if any. */
		eset_t *eset = &ecache->eset;
		edata = edata_list_inactive_first(&eset->lru);
		if (edata == NULL) {
			/*
			 * Next check if there are guarded extents.  They are
			 * more expensive to purge (since they are not
			 * mergeable), thus in favor of caching them longer.
			 */
			eset = &ecache->guarded_eset;
			edata = edata_list_inactive_first(&eset->lru);
			if (edata == NULL) {
				goto label_return;
			}
		}
		/* Check the eviction limit. */
		size_t extents_npages = ecache_npages_get(ecache);
		if (extents_npages <= npages_min) {
			edata = NULL;
			goto label_return;
		}
		if (!ecache->delay_coalesce || edata_guarded_get(edata)) {
			break;
		}
		/* Try to coalesce. */
		if (extent_try_delayed_coalesce(tsdn, pac, ehooks, ecache,
		    edata)) {
			break;
		}
		/*
		 * The LRU extent was just coalesced and the result placed in
		 * the LRU at its neighbor's position.  Start over.
		 */
	}
	/*
	 * Either mark the extent active or deregister it to protect against
	 * concurrent operations.
	 */
	switch (ecache->state) {
	case extent_state_active:
		not_reached();
	case extent_state_dirty:
	case extent_state_muzzy:
		emap_update_edata_state(tsdn, pac->emap, edata,
		    extent_state_active);
		break;
	case extent_state_retained:
		extent_deregister(tsdn, pac, edata);
		break;
	default:
		not_reached();
	}
label_return:
	malloc_mutex_unlock(tsdn, &ecache->mtx);
	return edata;
}
