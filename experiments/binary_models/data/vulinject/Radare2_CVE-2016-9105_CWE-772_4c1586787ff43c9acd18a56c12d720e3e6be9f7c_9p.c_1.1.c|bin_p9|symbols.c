static RList *symbols(RBinFile *bf) {
	RList *ret = NULL;
	RVector *history = NULL; 
	HtUP *histories = NULL; 
	RPVector *names = NULL; 
	const RBinPlan9Obj *o = (RBinPlan9Obj *)bf->bo->bin_obj;
	ut64 i;
	Sym sym = {0};
	if (!(ret = r_list_newf (free))) {
		goto error;
	}
	if (!(histories = ht_up_new0 ())) {
		goto error;
	}
	if (!(names = r_pvector_new (NULL))) {
		goto error;
	}
	const ut64 syms = o->header_size + o->header.text + o->header.data;
	if (!bf->sdb_addrinfo && o->header.syms && o->header.pcsz) {
		bf->sdb_addrinfo = sdb_new0 ();
	}
	ut64 offset = 0;
	while (offset < o->header.syms) {
		const st64 size = sym_read (bf, &sym, offset);
		if (size == -1) {
			goto error;
		}
		offset += size;
		if (sym.type == 'f') {
			if (sym.value * 4 > r_buf_size (bf->buf)) {
				R_LOG_ERROR ("Prevented huge memory allocation");
				break;
			}
			if (r_pvector_length (names) < sym.value) {
				if (!r_pvector_reserve (names, sym.value)) {
					goto error;
				}
				names->v.len = sym.value;
			}
			r_pvector_set (names, sym.value - 1, sym.name);
			continue;
		}
		if (sym.type == 'z') {
			RStrBuf *sb = r_strbuf_new (NULL);
			ut64 fin = (o->header.syms > offset)? o->header.syms - offset: 0;
			for (i = 0; i < fin; i += sizeof (ut16)) {
				ut16 index = r_buf_read_be16_at (bf->buf, syms + offset + i);
				if (index == UT16_MAX) {
					r_strbuf_free (sb);
					goto error;
				}
				if (index == 0) {
					offset += i + sizeof (ut16);
					break;
				}
				const char *name = r_pvector_at (names, index - 1);
				r_strbuf_appendf (sb, "%s", name);
				if (i != 0) {
					r_strbuf_append (sb, "/");
				}
			}
			char *name = r_strbuf_drain (sb);
			size_t name_size = strlen (name);
			if (name_size) {
				name[name_size - 1] = '\0';
			}
			if (sym.value == 1 && history) {
				history = NULL;
			}
			if (!history) {
				history = r_vector_new (sizeof (Sym), sym_fini, NULL);
			}
			Sym history_sym = {sym.value, 'z', name};
			r_vector_push (history, &history_sym);
			continue;
		}
		switch (sym.type) {
		case 'T':
		case 't':
		case 'L':
		case 'l':
		case 'D':
		case 'd':
		case 'B':
		case 'b':
			break;
		case 'Z':
		default:
			sym_fini (&sym, NULL);
			continue;
		}
		RBinSymbol *bin_sym = R_NEW0 (RBinSymbol);
		if (!bin_sym) {
			goto error;
		}
		bin_sym->name = r_bin_name_new (sym.name);
		bin_sym->paddr = sym.value - baddr (bf);
		if (o->is_kernel) {
			bin_sym->paddr += o->header_size;
		}
		bin_sym->vaddr = sym.value;
		bin_sym->size = 0;
		bin_sym->ordinal = 0;
		if (history) {
			ht_up_insert (histories, bin_sym->vaddr, history);
		}
	}
	history = NULL;
	const ut64 pcs = syms + o->header.syms + o->header.spsz;
	ut64 line = 0;
	ut64 pc = baddr (bf) + (o->is_kernel? 0: o->header_size) - o->pcq;
	offset = 0;
	while (offset < o->header.pcsz) {
		RVector *h = ht_up_find (histories, pc + o->pcq, NULL);
		if (h) {
			history = h;
		}
		ut64 prev = line;
		const ut8 b = r_buf_read8_at (bf->buf, pcs + offset);
		if (b == UT8_MAX) {
			goto error;
		}
		offset += sizeof (ut8);
		if (b == 0) {
			ut32 d = r_buf_read_be32_at (bf->buf, pcs + offset);
			if (d == UT32_MAX) {
				goto error;
			}
			line += (st32)d;
			offset += sizeof (ut32);
		} else if (b < 65) {
			line += b;
		} else if (b < 129) {
			line -= b - 64;
		} else {
			pc += o->pcq * (b - 129);
		}
		pc += o->pcq;
		if (prev != line && r_vector_length (history) > 1) {
			apply_history (bf, pc, line, r_vector_at (history, 0), NULL);
		}
	}
	ht_up_free (histories);
	r_pvector_free (names);
	return ret;
error:
	sym_fini (&sym, NULL);
	r_list_free (ret);
	r_pvector_free (names);
	ht_up_free (histories);
	return NULL;
}
