int amdgpu_ras_save_bad_pages(struct amdgpu_device *adev,
		unsigned int *new_cnt)
{
	struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
	struct ras_err_handler_data *data;
	struct amdgpu_ras_eeprom_control *control;
	int save_count;
	if (!con || !con->eh_data) {
		if (new_cnt)
			*new_cnt = 0;
		return 0;
	}
	control = &con->eeprom_control;
	data = con->eh_data;
	save_count = data->count - control->ras_num_recs;
	mutex_unlock(&con->recovery_lock);
	if (new_cnt)
		*new_cnt = save_count / adev->umc.retire_unit;
	if (save_count > 0) {
		if (amdgpu_ras_eeprom_append(control,
					     &data->bps[control->ras_num_recs],
					     save_count)) {
			dev_err(adev->dev, "Failed to save EEPROM table data!");
			return -EIO;
		}
		dev_info(adev->dev, "Saved %d pages to EEPROM table.\n", save_count);
	}
	return 0;
}
