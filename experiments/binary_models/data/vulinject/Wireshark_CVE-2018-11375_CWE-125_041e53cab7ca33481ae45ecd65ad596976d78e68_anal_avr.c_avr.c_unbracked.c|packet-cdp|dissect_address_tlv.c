dissect_address_tlv(tvbuff_t *tvb, packet_info* pinfo, int offset, int length, proto_tree *tree)
{
    proto_item *ti;
    proto_tree *address_tree;
    guint8      protocol_type;
    guint8      protocol_length;
    int         nlpid = 0;
    guint16     address_length;
    guint16     etypeid = 0;
    int         hf_addr = -1;
    if (length < 1)
        return -1;
    address_tree = proto_tree_add_subtree(tree, tvb, offset, length, ett_cdp_address, &ti, "Truncated address");
    protocol_type = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(address_tree, hf_cdp_protocol_type, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    length -= 1;
    if (length < 1)
        return -1;
    protocol_length = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(address_tree, hf_cdp_protocol_length, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    length -= 1;
    if (length < protocol_length) {
        if (length != 0) {
            ti = proto_tree_add_item(address_tree, hf_cdp_protocol, tvb, offset, length, ENC_NA);
            proto_item_append_text(ti, " (truncated)");
        }
        return -1;
    }
    if ((protocol_type == PROTO_TYPE_NLPID) && (protocol_length == 1)) {
        nlpid = tvb_get_guint8(tvb, offset);
        proto_tree_add_bytes_format_value(address_tree, hf_cdp_protocol, tvb, offset, protocol_length, NULL, "%s",
                            val_to_str(nlpid, nlpid_vals, "Unknown (0x%02x)"));
    } else if ((protocol_type == PROTO_TYPE_IEEE_802_2) && (protocol_length == 8) && (tvb_get_ntoh48(tvb, offset) == 0xAAAA03000000)) {
        etypeid = tvb_get_ntohs(tvb, offset + 6);
        proto_tree_add_bytes_format_value(address_tree, hf_cdp_protocol, tvb, offset, protocol_length, NULL, "%s",
                            val_to_str(etypeid, etype_vals, "Unknown (0x%04x)"));
    } else {
        nlpid = -1;
        proto_tree_add_item(address_tree, hf_cdp_protocol, tvb, offset, protocol_length, ENC_NA);
    }
    offset += protocol_length;
    length -= protocol_length;
    address_length = tvb_get_ntohs(tvb, offset);
    proto_tree_add_item(address_tree, hf_cdp_address_length, tvb, offset, 2, ENC_BIG_ENDIAN);
    offset += 2;
    length -= 2;
    if (length < address_length) {
        if (length != 0) {
            ti = proto_tree_add_item(address_tree, hf_cdp_address, tvb, offset, length, ENC_NA);
            proto_item_append_text(ti, " (truncated)");
        }
        return -1;
    }
    if ((protocol_type == PROTO_TYPE_NLPID) && (protocol_length == 1)) {
        switch (nlpid) {
        case NLPID_IP:
            if (address_length == 4) {
                proto_item_set_text(ti, "IP address: %s", tvb_ip_to_str(pinfo->pool, tvb, offset));
                hf_addr = hf_cdp_nrgyz_ip_address;
                proto_tree_add_item(address_tree, hf_cdp_nrgyz_ip_address, tvb, offset, address_length, ENC_BIG_ENDIAN);
            }
            break;
        }
    }
    if ((protocol_type == PROTO_TYPE_IEEE_802_2) && (protocol_length == 8) && (etypeid > 0)) {
        switch (etypeid) {
        case ETHERTYPE_IPv6:
            if (address_length == 16) {
                proto_item_set_text(ti, "IPv6 address: %s", tvb_ip6_to_str(pinfo->pool, tvb, offset));
                hf_addr = hf_cdp_nrgyz_ip6_address;
                proto_tree_add_item(address_tree, hf_cdp_nrgyz_ip6_address, tvb, offset, address_length, ENC_NA);
            }
            break;
        }
    }
    if (hf_addr == -1)
    {
        proto_tree_add_item(address_tree, hf_cdp_address, tvb, offset, address_length, ENC_NA);
        if(address_length)
        {
            proto_item_set_text(ti, "Address: %s", tvb_bytes_to_str(pinfo->pool, tvb, offset, address_length));
        }
    }
    return 2 + protocol_length + 2 + address_length;
}
