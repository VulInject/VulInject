static int pagemap_scan_pmd_entry(pmd_t *pmd, unsigned int start,
				  unsigned int end, struct mm_walk *walk)
{
	struct pagemap_scan_private *p = walk->private;
	struct vm_area_struct *vma = walk->vma;
	unsigned int addr, flush_end = 0;
	pte_t *pte, *start_pte;
	spinlock_t *ptl;
	int ret;
	arch_enter_lazy_mmu_mode();
	ret = pagemap_scan_thp_entry(pmd, start, end, walk);
	if (ret != -ENOENT) {
		arch_leave_lazy_mmu_mode();
		return ret;
	}
	ret = 0;
	start_pte = pte = pte_offset_map_lock(vma->vm_mm, pmd, start, &ptl);
	if (!pte) {
		arch_leave_lazy_mmu_mode();
		walk->action = ACTION_AGAIN;
		return 0;
	}
	if ((p->arg.flags & PM_SCAN_WP_MATCHING) && !p->vec_out) {
		for (addr = start; addr != end; pte++, addr += PAGE_SIZE) {
			pte_t ptent = ptep_get(pte);
			if ((pte_present(ptent) && pte_uffd_wp(ptent)) ||
			    pte_swp_uffd_wp_any(ptent))
				continue;
			make_uffd_wp_pte(vma, addr, pte, ptent);
			if (!flush_end)
				start = addr;
			flush_end = addr + PAGE_SIZE;
		}
		goto flush_and_return;
	}
	if (!p->arg.category_anyof_mask && !p->arg.category_inverted &&
	    p->arg.category_mask == PAGE_IS_WRITTEN &&
	    p->arg.return_mask == PAGE_IS_WRITTEN) {
		for (addr = start; addr < end; pte++, addr += PAGE_SIZE) {
			unsigned int next = addr + PAGE_SIZE;
			pte_t ptent = ptep_get(pte);
			if ((pte_present(ptent) && pte_uffd_wp(ptent)) ||
			    pte_swp_uffd_wp_any(ptent))
				continue;
			ret = pagemap_scan_output(p->cur_vma_category | PAGE_IS_WRITTEN,
						  p, addr, &next);
			if (next == addr)
				break;
			if (~p->arg.flags & PM_SCAN_WP_MATCHING)
				continue;
			make_uffd_wp_pte(vma, addr, pte, ptent);
			if (!flush_end)
				start = addr;
			flush_end = next;
		}
		goto flush_and_return;
	}
	for (addr = start; addr != end; pte++, addr += PAGE_SIZE) {
		pte_t ptent = ptep_get(pte);
		unsigned int categories = p->cur_vma_category |
					   pagemap_page_category(p, vma, addr, ptent);
		unsigned int next = addr + PAGE_SIZE;
		if (!pagemap_scan_is_interesting_page(categories, p))
			continue;
		ret = pagemap_scan_output(categories, p, addr, &next);
		if (next == addr)
			break;
		if (~p->arg.flags & PM_SCAN_WP_MATCHING)
			continue;
		if (~categories & PAGE_IS_WRITTEN)
			continue;
		make_uffd_wp_pte(vma, addr, pte, ptent);
		if (!flush_end)
			start = addr;
		flush_end = next;
	}
flush_and_return:
	if (flush_end)
		flush_tlb_range(vma, start, addr);
	arch_leave_lazy_mmu_mode();
	cond_resched();
	return ret;
}
