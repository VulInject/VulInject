static int cmd_write(void *data, const char *input) {
	RCore *core = (RCore *)data;
	if (!input) {
		return 0;
	}
	switch (*input) {
	case '0': 
		cmd_w0 (data, input + 1);
		break;
	case '1': 
	case '2': 
	case '4': 
	case '8': 
		w_incdec_handler (data, input + 1, *input - '0');
		break;
	case '6': 
		cmd_w6 (core, input + 1);
		break;
	case 'a': 
		cmd_wa (core, input + 1);
		break;
	case 'b': 
		cmd_wb (core, input + 1);
		break;
	case 'X': 
		cmd_wX (core, input + 1);
		break;
	case 'B': 
		cmd_wB (data, input + 1);
		break;
	case 'c': 
		cmd_wc (core, input + 1);
		break;
	case 'h': 
		if (!strcmp (input, "hoami")) {
			char *ui = r_sys_whoami ();
			r_cons_printf ("%s\n", ui);
			free (ui);
		} else {
			cmd_wh (core, input + 1);
		}
		break;
	case 'e': 
		cmd_we (core, input + 1);
		break;
	case 'p': 
		cmd_wp (core, input + 1);
		break;
	case 'u': 
		cmd_wu (core, input + 1);
		break;
	case 'r': 
		cmd_wr (core, input + 1);
		break;
#if 0
	case 'A': 
		cmd_wA (core, input + 1);
		break;
#endif
	case ' ': 
	case '+': 
	{
		size_t len = core->blocksize;
		const char *curcs = r_config_get (core->config, "cfg.charset");
		char *str = strdup (input);
#if !SHELLFILTER
		r_str_trim_args (str);
#endif
		r_str_trim_tail (str);
		ut64 addr = core->offset;
		if (R_STR_ISEMPTY (curcs)) {
			r_core_return_value (core, 0);
			cmd_w (core, str + 1);
			addr += core->num->value;
		} else {
			if (len > 0) {
				size_t in_len = strlen (str + 1);
				int max = core->print->charset->encode_maxkeylen;
				int out_len = in_len * max;
				int new_len = 0;
				ut8 *out = malloc (in_len * max); 
				if (out) {
					*out = 0;
					new_len = r_charset_decode_str (core->print->charset, out, out_len, (const ut8*) str + 1, in_len);
					cmd_w (core, (const char *)out);
					free (out);
				}
				addr += new_len;
			}
		}
		free (str);
		if (*input == '+') {
			r_core_seek (core, addr, true);
		}
		break;
	}
	case 'g': 
		cmd_wget (core, input + 1);
		break;
	case 'z': 
		cmd_wz (core, input + 1);
		break;
	case 't': 
		break;
	case 'f': 
		cmd_wf (core, input + 1);
		break;
	case 'w': 
		cmd_ww (core, input + 1);
		break;
	case 'x': 
		cmd_wx (core, input + 1);
		break;
	case 'm': 
		cmd_wm (core, input + 1);
		break;
	case 'v': 
		cmd_write_value (core, input + 1);
		break;
	case 'o': 
		cmd_wo (core, input + 1);
		break;
	case 'd': 
		cmd_wd (core, input + 1);
		break;
	case 's': 
		cmd_ws (core, input + 1);
		break;
	default:
	case '?': 
		r_core_cmd_help (core, help_msg_w);
		break;
	}
	r_core_block_read (core);
	return 0;
}
