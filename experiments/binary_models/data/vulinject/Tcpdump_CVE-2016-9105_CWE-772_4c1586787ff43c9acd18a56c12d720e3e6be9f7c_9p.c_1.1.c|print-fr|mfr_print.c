mfr_print(netdissect_options *ndo,
          const u_char *p, u_int length)
{
    u_int tlen,idx,hdr_len = 0;
    unsigned short sequence_num;
    unsigned char ie_type,ie_len;
    const unsigned char *tptr;
    ndo->ndo_protocol = "mfr";
    if (length < 4) {	
        ND_PRINT("[length %u < 4]", length);
        nd_print_invalid(ndo);
        return length;
    }
    ND_TCHECK_4(p);
    if ((GET_U_1(p) & MFR_BEC_MASK) == MFR_CTRL_FRAME && GET_U_1(p + 1) == 0) {
        ND_PRINT("FRF.16 Control, Flags [%s], %s, length %u",
               bittok2str(frf_flag_values,"none",(GET_U_1(p) & MFR_BEC_MASK)),
               tok2str(mfr_ctrl_msg_values,"Unknown Message (0x%02x)",GET_U_1(p + 2)),
               length);
        tptr = p + 3;
        tlen = length -3;
        hdr_len = 3;
        if (!ndo->ndo_vflag)
            return hdr_len;
        while (tlen>sizeof(struct ie_tlv_header_t)) {
            ND_TCHECK_LEN(tptr, sizeof(struct ie_tlv_header_t));
            ie_type=GET_U_1(tptr);
            ie_len=GET_U_1(tptr + 1);
            ND_PRINT("\n\tIE %s (%u), length %u: ",
                   tok2str(mfr_ctrl_ie_values,"Unknown",ie_type),
                   ie_type,
                   ie_len);
            if (ie_type == 0 || ie_len <= sizeof(struct ie_tlv_header_t))
                return hdr_len;
            tptr+=sizeof(struct ie_tlv_header_t);
            ie_len-=sizeof(struct ie_tlv_header_t);
            tlen-=sizeof(struct ie_tlv_header_t);
            switch (ie_type) {
            case MFR_CTRL_IE_MAGIC_NUM:
                if (ie_len != 4) {
                    ND_PRINT("[IE data length %d != 4]", ie_len);
                    nd_print_invalid(ndo);
                    break;
                }
                ND_PRINT("0x%08x", GET_BE_U_4(tptr));
                break;
            case MFR_CTRL_IE_BUNDLE_ID: 
            case MFR_CTRL_IE_LINK_ID:
                for (idx = 0; idx < ie_len && idx < MFR_ID_STRING_MAXLEN; idx++) {
                    if (GET_U_1(tptr + idx) != 0) 
                        fn_print_char(ndo, GET_U_1(tptr + idx));
                    else
                        break;
                }
                break;
            case MFR_CTRL_IE_TIMESTAMP:
                if (ie_len > 14) {
                    ND_PRINT("[Timestamp IE length %d > 14]", ie_len);
                    nd_print_invalid(ndo);
                    break;
                }
                ND_FALL_THROUGH;
            case MFR_CTRL_IE_VENDOR_EXT:
            case MFR_CTRL_IE_CAUSE:
            default:
                if (ndo->ndo_vflag <= 1)
                    print_unknown_data(ndo, tptr, "\n\t  ", ie_len);
                break;
            }
            if (ndo->ndo_vflag > 1 )
                print_unknown_data(ndo, tptr, "\n\t  ", ie_len);
            tlen-=ie_len;
            tptr+=ie_len;
        }
        return hdr_len;
    }
    sequence_num = (GET_U_1(p)&0x1e)<<7 | GET_U_1(p + 1);
    if ((GET_U_1(p) & MFR_BEC_MASK) == MFR_FRAG_FRAME ||
        (GET_U_1(p) & MFR_BEC_MASK) == MFR_B_BIT) {
        ND_PRINT("FRF.16 Frag, seq %u, Flags [%s], ",
               sequence_num,
               bittok2str(frf_flag_values,"none",(GET_U_1(p) & MFR_BEC_MASK)));
        hdr_len = 2;
        fr_print(ndo, p+hdr_len,length-hdr_len);
        return hdr_len;
    }
    ND_PRINT("FRF.16 Frag, seq %u, Flags [%s]",
           sequence_num,
           bittok2str(frf_flag_values,"none",(GET_U_1(p) & MFR_BEC_MASK)));
    print_unknown_data(ndo, p, "\n\t", length);
    return hdr_len;
trunc:
    nd_print_trunc(ndo);
    return length;
}
