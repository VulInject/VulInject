static void dissect_tftp_message(tftp_conv_info_t *tftp_info,
                                 tvbuff_t *tvb, packet_info *pinfo,
                                 proto_tree *tree)
{
  proto_tree *tftp_tree;
  proto_item *root_ti;
  proto_item *ti;
  proto_item *blocknum_item;
  gint        offset    = 0;
  guint16     opcode;
  const char  *filename = NULL;
  guint16     bytes;
  guint32     blocknum;
  guint       i1;
  guint16     error;
  gboolean    likely_tsize_probe;
  gboolean    is_last_package;
  gboolean    is_fragmented;
  tvbuff_t    *next_tvb;
  fragment_head *tftpfd_head = NULL;
  heur_dtbl_entry_t *hdtbl_entry;
  struct tftpinfo tftpinfo;
  guint32     payload_data_offset;
  col_set_str(pinfo->cinfo, COL_PROTOCOL, "TFTP");
  root_ti = proto_tree_add_item(tree, proto_tftp, tvb, offset, -1, ENC_NA);
  tftp_tree = proto_item_add_subtree(root_ti, ett_tftp);
  opcode = tvb_get_ntohs(tvb, offset);
  proto_tree_add_uint(tftp_tree, hf_tftp_opcode, tvb, offset, 2, opcode);
  col_add_str(pinfo->cinfo, COL_INFO,
              val_to_str(opcode, tftp_opcode_vals, "Unknown (0x%04x)"));
  offset += 2;
  if (tftp_info->request_frame != 0 && opcode != TFTP_RRQ && opcode != TFTP_WRQ) {
    if (tftp_info->source_file) {
      filename = tftp_info->source_file;
    } else if (tftp_info->destination_file) {
      filename = tftp_info->destination_file;
    }
    ti = proto_tree_add_string(tftp_tree, hf_tftp_destination_file, tvb, 0, 0, filename);
    proto_item_set_generated(ti);
    ti = proto_tree_add_uint_format(tftp_tree, hf_tftp_request_frame,
                                    tvb, 0, 0, tftp_info->request_frame,
                                    "%s in frame %u",
                                    tftp_info->source_file ? "Read Request" : "Write Request",
                                    tftp_info->request_frame);
    proto_item_set_generated(ti);
  }
  switch (opcode) {
  case TFTP_RRQ:
    i1 = tvb_strsize(tvb, offset);
    proto_tree_add_item_ret_string(tftp_tree, hf_tftp_source_file,
                        tvb, offset, i1, ENC_ASCII|ENC_NA, wmem_file_scope(), &tftp_info->source_file);
    tftp_info->destination_file = NULL;
    tftp_info->request_frame = pinfo->num;
    col_append_fstr(pinfo->cinfo, COL_INFO, ", File: %s",
                    tvb_format_stringzpad(pinfo->pool, tvb, offset, i1));
    offset += i1;
    i1 = tvb_strsize(tvb, offset);
    proto_tree_add_item(tftp_tree, hf_tftp_transfer_type,
                        tvb, offset, i1, ENC_ASCII);
    col_append_fstr(pinfo->cinfo, COL_INFO, ", Transfer type: %s",
                    tvb_format_stringzpad(pinfo->pool, tvb, offset, i1));
    offset += i1;
    tftp_dissect_options(tvb, pinfo,  offset, tftp_tree,
                         opcode, tftp_info);
    break;
  case TFTP_WRQ:
    i1 = tvb_strsize(tvb, offset);
    proto_tree_add_item_ret_string(tftp_tree, hf_tftp_destination_file,
                        tvb, offset, i1, ENC_ASCII|ENC_NA, wmem_file_scope(), &tftp_info->destination_file);
    tftp_info->source_file = NULL; 
    tftp_info->request_frame = pinfo->num;
    col_append_fstr(pinfo->cinfo, COL_INFO, ", File: %s",
                    tvb_format_stringzpad(pinfo->pool, tvb, offset, i1));
    offset += i1;
    i1 = tvb_strsize(tvb, offset);
    proto_tree_add_item(tftp_tree, hf_tftp_transfer_type,
                        tvb, offset, i1, ENC_ASCII);
    col_append_fstr(pinfo->cinfo, COL_INFO, ", Transfer type: %s",
                    tvb_format_stringzpad(pinfo->pool, tvb, offset, i1));
    offset += i1;
    tftp_dissect_options(tvb, pinfo, offset, tftp_tree,
                         opcode,  tftp_info);
    break;
  case TFTP_INFO:
    tftp_dissect_options(tvb, pinfo, offset, tftp_tree,
                         opcode,  tftp_info);
    break;
  case TFTP_DATA:
    proto_item_set_len(root_ti, 4);
    blocknum_item = proto_tree_add_item_ret_uint(tftp_tree, hf_tftp_blocknum, tvb, offset, 2,
                                                 ENC_BIG_ENDIAN, &blocknum);
    offset += 2;
    if (!PINFO_FD_VISITED(pinfo)) {
      blocknum = determine_full_blocknum(blocknum, tftp_info);
      p_add_proto_data(wmem_file_scope(), pinfo, proto_tftp, FULL_BLOCKNUM_KEY,
                       GUINT_TO_POINTER(blocknum));
    } else {
      blocknum = GPOINTER_TO_UINT(p_get_proto_data(wmem_file_scope(), pinfo,
                                                   proto_tftp, FULL_BLOCKNUM_KEY));
    }
    ti = proto_tree_add_uint(tftp_tree, hf_tftp_full_blocknum, tvb, 0, 0,
                             blocknum);
    proto_item_set_generated(ti);
    bytes = tvb_reported_length_remaining(tvb, offset);
    is_last_package = (bytes < tftp_info->blocksize);
    if (!PINFO_FD_VISITED(pinfo)) {
      tftp_info->last_package_available |= is_last_package;
      if (blocknum > tftp_info->next_block_num) {
        tftp_info->next_block_num = blocknum + 1;
        tftp_info->blocks_missing = TRUE;
      }
      else if (blocknum == tftp_info->next_block_num) {
        tftp_info->next_block_num++;
        tftp_info->file_length += bytes;
      }
    }
    col_append_fstr(pinfo->cinfo, COL_INFO, ", Block: %u%s",
                    blocknum,
                    is_last_package ?" (last)":"" );
    is_fragmented = !(is_last_package && blocknum == 1);
    if (is_fragmented) {
      if (tftp_defragment && (pinfo->num <= tftp_info->last_reassembly_package)) {
        tftpfd_head = fragment_add_seq_check(&tftp_reassembly_table, tvb, offset, pinfo,
                                             tftp_info->reassembly_id, 
                                             NULL,                     
                                             blocknum - 1,
                                             bytes, !is_last_package);
        next_tvb = process_reassembled_data(tvb, offset, pinfo,
                                            "Reassembled TFTP", tftpfd_head,
                                            &tftp_frag_items, NULL, tftp_tree);
      } else {
        next_tvb = NULL;
      }
    } else {
      next_tvb = tvb_new_subset_remaining(tvb, offset);
    }
    if (next_tvb == NULL) {
      call_data_dissector(tvb_new_subset_remaining(tvb, offset), pinfo, tree);
    } else {
      tftp_info->last_reassembly_package = pinfo->num;
      if (tvb_reported_length(next_tvb) > 0) {
        tftpinfo.filename = filename;
        if (!dissector_try_heuristic(heur_subdissector_list, next_tvb, pinfo,
                                     tree, &hdtbl_entry, &tftpinfo)) {
          call_data_dissector(next_tvb, pinfo, tree);
        } else {
          tftp_info->is_simple_file = FALSE;
        }
      }
    }
    if (blocknum == 0xFFFF && bytes == tftp_info->blocksize) {
       expert_add_info(pinfo, blocknum_item, &ei_tftp_blocknum_will_wrap);
    }
    if (have_tap_listener(tftp_eo_tap) &&
        tftp_info->is_simple_file            
        && filename != NULL                  
        && !tftp_info->blocks_missing        
        && (tftp_info->last_package_available || !PINFO_FD_VISITED(pinfo))
    ) {
      if (PINFO_FD_VISITED(pinfo)) {
        if (blocknum == 1 && !tftp_info->payload_data) {
          tftp_info->payload_data = (guint8 *)g_try_malloc((gsize)tftp_info->file_length);
        }
      } else {
        tftp_info->payload_data = (guint8 *)wmem_realloc(wmem_file_scope(), tftp_info->payload_data, (gsize)tftp_info->file_length);
      }
      if (tftp_info->payload_data == NULL ||
          (blocknum != tftp_info->next_tap_block_num)) {
        break;
      }
      payload_data_offset =
          (tftp_info->next_tap_block_num - 1) * tftp_info->blocksize;
      tvb_memcpy(tvb, tftp_info->payload_data + payload_data_offset, offset,
                 bytes);
      tftp_info->next_tap_block_num++;
      if (is_last_package) {
        tftp_eo_t        *eo_info;
	eo_info=((pinfo->pool+tftp_eo_t-1)/tftp_eo_t);
        eo_info->filename = g_strdup(filename);
        eo_info->payload_len = tftp_info->file_length;
        eo_info->payload_data = tftp_info->payload_data;
        tap_queue_packet(tftp_eo_tap, pinfo, eo_info);
        tftp_info->next_tap_block_num = 1;
        tftp_info->payload_data = NULL;
      }
    }
    break;
  case TFTP_ACK:
    proto_tree_add_item_ret_uint(tftp_tree, hf_tftp_blocknum, tvb, offset, 2,
                                 ENC_BIG_ENDIAN, &blocknum);
    if (!PINFO_FD_VISITED(pinfo)) {
      blocknum = determine_full_blocknum(blocknum, tftp_info);
      p_add_proto_data(wmem_file_scope(), pinfo, proto_tftp, FULL_BLOCKNUM_KEY,
                       GUINT_TO_POINTER(blocknum));
    } else {
      blocknum = GPOINTER_TO_UINT(p_get_proto_data(wmem_file_scope(), pinfo,
                                                   proto_tftp, FULL_BLOCKNUM_KEY));
    }
    ti = proto_tree_add_uint(tftp_tree, hf_tftp_full_blocknum, tvb, 0, 0,
                             blocknum);
    proto_item_set_generated(ti);
    col_append_fstr(pinfo->cinfo, COL_INFO, ", Block: %u",
                    blocknum);
    offset += 2;
    if (tftp_info->dynamic_windowing_active && tvb_bytes_exist(tvb, offset, 1)) {
      gboolean windowsize_changed;
      guint8 windowsize = tvb_get_guint8(tvb, offset);
      ti = proto_tree_add_uint(tftp_tree, hf_tftp_nextwindowsize, tvb,
                               offset, 1, windowsize);
      if (!PINFO_FD_VISITED(pinfo)) {
        windowsize_changed = windowsize != tftp_info->windowsize &&
                             !tftp_info->last_package_available;
        if (windowsize_changed) {
          p_add_proto_data(wmem_file_scope(), pinfo, proto_tftp,
                           WINDOWSIZE_CHANGE_KEY, GUINT_TO_POINTER(1));
          tftp_info->windowsize = windowsize;
        }
      } else {
        windowsize_changed = p_get_proto_data(wmem_file_scope(), pinfo, proto_tftp, WINDOWSIZE_CHANGE_KEY) != NULL;
      }
      if (windowsize_changed) {
        expert_add_info(pinfo, ti, &ei_tftp_windowsize_change);
      }
    }
    break;
  case TFTP_ERROR:
    error = tvb_get_ntohs(tvb, offset);
    proto_tree_add_uint(tftp_tree, hf_tftp_error_code, tvb, offset, 2,
                        error);
    col_append_fstr(pinfo->cinfo, COL_INFO, ", Code: %s",
                    val_to_str(error, tftp_error_code_vals, "Unknown (%u)"));
    offset += 2;
    i1 = tvb_strsize(tvb, offset);
    proto_tree_add_item(tftp_tree, hf_tftp_error_string, tvb, offset,
                        i1, ENC_ASCII);
    col_append_fstr(pinfo->cinfo, COL_INFO, ", Message: %s",
                    tvb_format_stringzpad(pinfo->pool, tvb, offset, i1));
    if (!PINFO_FD_VISITED(pinfo)) {
      likely_tsize_probe = error_is_likely_tsize_probe(error, tftp_info);
      if (likely_tsize_probe) {
        p_add_proto_data(wmem_file_scope(), pinfo, proto_tftp, LIKELY_TSIZE_PROBE_KEY, GUINT_TO_POINTER(1));
      }
    } else {
      likely_tsize_probe = GPOINTER_TO_UINT(p_get_proto_data(wmem_file_scope(), pinfo, proto_tftp,
                                                             LIKELY_TSIZE_PROBE_KEY)) != 0;
    }
    expert_add_info(pinfo, tftp_tree, likely_tsize_probe ? &ei_tftp_likely_tsize_probe : &ei_tftp_error);
    break;
  case TFTP_OACK:
    tftp_dissect_options(tvb, pinfo, offset, tftp_tree,
                         opcode, tftp_info);
    break;
  default:
    proto_tree_add_item(tftp_tree, hf_tftp_data, tvb, offset, -1, ENC_NA);
    break;
  }
  tftp_info->prev_opcode = opcode;
}
