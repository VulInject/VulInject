static int vaapi_encode_h264_init_sequence_params(AVCodecContext *avctx)
{
    VAAPIEncodeContext                *ctx = avctx->priv_data;
    VAAPIEncodeH264Context           *priv = avctx->priv_data;
    H264RawSPS                        *sps = &priv->raw_sps;
    H264RawPPS                        *pps = &priv->raw_pps;
    VAEncSequenceParameterBufferH264 *vseq = ctx->codec_sequence_params;
    VAEncPictureParameterBufferH264  *vpic = ctx->codec_picture_params;
    const AVPixFmtDescriptor *desc;
    int bit_depth;
    memset(sps, 0, sizeof(*sps));
    memset(pps, 0, sizeof(*pps));
    desc = av_pix_fmt_desc_get(priv->common.input_frames->sw_format);
    if (desc->nb_components == 1 || desc->log2_chroma_w != 1 || desc->log2_chroma_h != 1) {
        av_log(avctx, AV_LOG_ERROR, "Chroma format of input pixel format "
                "%s is not supported.\n", desc->name);
        return AVERROR(EINVAL);
    }
    bit_depth = desc->comp[0].depth;
    sps->nal_unit_header.nal_ref_idc   = 3;
    sps->nal_unit_header.nal_unit_type = H264_NAL_SPS;
    sps->profile_idc = avctx->profile & 0xff;
    if (avctx->profile == AV_PROFILE_H264_CONSTRAINED_BASELINE ||
        avctx->profile == AV_PROFILE_H264_MAIN)
        sps->constraint_set1_flag = 1;
    if (avctx->profile == AV_PROFILE_H264_HIGH || avctx->profile == AV_PROFILE_H264_HIGH_10)
        sps->constraint_set3_flag = ctx->gop_size == 1;
    if (avctx->profile == AV_PROFILE_H264_MAIN ||
        avctx->profile == AV_PROFILE_H264_HIGH || avctx->profile == AV_PROFILE_H264_HIGH_10) {
        sps->constraint_set4_flag = 1;
        sps->constraint_set5_flag = ctx->b_per_p == 0;
    }
    if (ctx->gop_size == 1)
        priv->dpb_frames = 0;
    else
        priv->dpb_frames = 1 + ctx->max_b_depth;
    if (avctx->level != AV_LEVEL_UNKNOWN) {
        sps->level_idc = avctx->level;
    } else {
        const H264LevelDescriptor *level;
        int framerate;
        if (avctx->framerate.num > 0 && avctx->framerate.den > 0)
            framerate = avctx->framerate.num / avctx->framerate.den;
        else
            framerate = 0;
        level = ff_h264_guess_level(sps->profile_idc,
                                    avctx->bit_rate,
                                    framerate,
                                    priv->mb_width  * 16,
                                    priv->mb_height * 16,
                                    priv->dpb_frames);
        if (level) {
            av_log(avctx, AV_LOG_VERBOSE, "Using level %s.\n", level->name);
            if (level->constraint_set3_flag)
                sps->constraint_set3_flag = 1;
            sps->level_idc = level->level_idc;
        } else {
            av_log(avctx, AV_LOG_WARNING, "Stream will not conform "
                   "to any level: using level 6.2.\n");
            sps->level_idc = 62;
        }
    }
    sps->seq_parameter_set_id = 0;
    sps->chroma_format_idc    = 1;
    sps->bit_depth_luma_minus8 = bit_depth - 8;
    sps->bit_depth_chroma_minus8 = bit_depth - 8;
    sps->log2_max_frame_num_minus4 = 4;
    sps->pic_order_cnt_type        = ctx->max_b_depth ? 0 : 2;
    if (sps->pic_order_cnt_type == 0) {
        sps->log2_max_pic_order_cnt_lsb_minus4 = 4;
    }
    sps->max_num_ref_frames = priv->dpb_frames;
    sps->pic_width_in_mbs_minus1        = priv->mb_width  - 1;
    sps->pic_height_in_map_units_minus1 = priv->mb_height - 1;
    sps->frame_mbs_only_flag = 1;
    sps->direct_8x8_inference_flag = 1;
    if (avctx->width  != 16 * priv->mb_width ||
        avctx->height != 16 * priv->mb_height) {
        sps->frame_cropping_flag = 1;
        sps->frame_crop_left_offset   = 0;
        sps->frame_crop_right_offset  =
            (16 * priv->mb_width - avctx->width) / 2;
        sps->frame_crop_top_offset    = 0;
        sps->frame_crop_bottom_offset =
            (16 * priv->mb_height - avctx->height) / 2;
    } else {
        sps->frame_cropping_flag = 0;
    }
    sps->vui_parameters_present_flag = 1;
    if (avctx->sample_aspect_ratio.num != 0 &&
        avctx->sample_aspect_ratio.den != 0) {
        int num, den, i;
        av_reduce(&num, &den, avctx->sample_aspect_ratio.num,
                  avctx->sample_aspect_ratio.den, 65535);
        for (i = 0; i < FF_ARRAY_ELEMS(ff_h2645_pixel_aspect); i++) {
            if (num == ff_h2645_pixel_aspect[i].num &&
                den == ff_h2645_pixel_aspect[i].den) {
                sps->vui.aspect_ratio_idc = i;
                break;
            }
        }
        if (i >= FF_ARRAY_ELEMS(ff_h2645_pixel_aspect)) {
            sps->vui.aspect_ratio_idc = 255;
            sps->vui.sar_width  = num;
            sps->vui.sar_height = den;
        }
        sps->vui.aspect_ratio_info_present_flag = 1;
    }
    // Unspecified video format, from table E-2.
    sps->vui.video_format             = 5;
    sps->vui.video_full_range_flag    =
        avctx->color_range == AVCOL_RANGE_JPEG;
    sps->vui.colour_primaries         = avctx->color_primaries;
    sps->vui.transfer_characteristics = avctx->color_trc;
    sps->vui.matrix_coefficients      = avctx->colorspace;
    if (avctx->color_primaries != AVCOL_PRI_UNSPECIFIED ||
        avctx->color_trc       != AVCOL_TRC_UNSPECIFIED ||
        avctx->colorspace      != AVCOL_SPC_UNSPECIFIED)
        sps->vui.colour_description_present_flag = 1;
    if (avctx->color_range     != AVCOL_RANGE_UNSPECIFIED ||
        sps->vui.colour_description_present_flag)
        sps->vui.video_signal_type_present_flag = 1;
    if (avctx->chroma_sample_location != AVCHROMA_LOC_UNSPECIFIED) {
        sps->vui.chroma_loc_info_present_flag = 1;
        sps->vui.chroma_sample_loc_type_top_field    =
        sps->vui.chroma_sample_loc_type_bottom_field =
            avctx->chroma_sample_location - 1;
    }
    sps->vui.timing_info_present_flag = 1;
    if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {
        sps->vui.num_units_in_tick = avctx->framerate.den;
        sps->vui.time_scale        = 2 * avctx->framerate.num;
        sps->vui.fixed_frame_rate_flag = 1;
    } else {
        sps->vui.num_units_in_tick = avctx->time_base.num;
        sps->vui.time_scale        = 2 * avctx->time_base.den;
        sps->vui.fixed_frame_rate_flag = 0;
    }
    if (priv->sei & SEI_TIMING) {
        H264RawHRD *hrd = &sps->vui.nal_hrd_parameters;
        H264RawSEIBufferingPeriod *bp = &priv->sei_buffering_period;
        sps->vui.nal_hrd_parameters_present_flag = 1;
        hrd->cpb_cnt_minus1 = 0;
        // Try to scale these to a sensible range so that the
        // golomb encode of the value is not overlong.
        hrd->bit_rate_scale =
            av_clip_uintp2(av_log2(ctx->va_bit_rate) - 15 - 6, 4);
        hrd->bit_rate_value_minus1[0] =
            (ctx->va_bit_rate >> hrd->bit_rate_scale + 6) - 1;
        hrd->cpb_size_scale =
            av_clip_uintp2(av_log2(ctx->hrd_params.buffer_size) - 15 - 4, 4);
        hrd->cpb_size_value_minus1[0] =
            (ctx->hrd_params.buffer_size >> hrd->cpb_size_scale + 4) - 1;
        // CBR mode as defined for the HRD cannot be achieved without filler
        // data, so this flag cannot be set even with VAAPI CBR modes.
        hrd->cbr_flag[0] = 0;
        hrd->initial_cpb_removal_delay_length_minus1 = 23;
        hrd->cpb_removal_delay_length_minus1         = 23;
        hrd->dpb_output_delay_length_minus1          = 7;
        hrd->time_offset_length                      = 0;
        bp->seq_parameter_set_id = sps->seq_parameter_set_id;
        // This calculation can easily overflow 32 bits.
        bp->nal.initial_cpb_removal_delay[0] = 90000 *
            (uint64_t)ctx->hrd_params.initial_buffer_fullness /
            ctx->hrd_params.buffer_size;
        bp->nal.initial_cpb_removal_delay_offset[0] = 0;
    } else {
        sps->vui.nal_hrd_parameters_present_flag = 0;
        sps->vui.low_delay_hrd_flag = 1 - sps->vui.fixed_frame_rate_flag;
    }
    sps->vui.bitstream_restriction_flag    = 1;
    sps->vui.motion_vectors_over_pic_boundaries_flag = 1;
    sps->vui.log2_max_mv_length_horizontal = 15;
    sps->vui.log2_max_mv_length_vertical   = 15;
    sps->vui.max_num_reorder_frames        = ctx->max_b_depth;
    sps->vui.max_dec_frame_buffering       = ctx->max_b_depth + 1;
    pps->nal_unit_header.nal_ref_idc = 3;
    pps->nal_unit_header.nal_unit_type = H264_NAL_PPS;
    pps->pic_parameter_set_id = 0;
    pps->seq_parameter_set_id = 0;
    pps->entropy_coding_mode_flag =
        !(sps->profile_idc == AV_PROFILE_H264_BASELINE ||
          sps->profile_idc == AV_PROFILE_H264_EXTENDED ||
          sps->profile_idc == AV_PROFILE_H264_CAVLC_444);
    if (!priv->coder && pps->entropy_coding_mode_flag)
        pps->entropy_coding_mode_flag = 0;
    pps->num_ref_idx_l0_default_active_minus1 = 0;
    pps->num_ref_idx_l1_default_active_minus1 = 0;
    pps->pic_init_qp_minus26 = priv->fixed_qp_idr - 26;
    if (sps->profile_idc == AV_PROFILE_H264_BASELINE ||
        sps->profile_idc == AV_PROFILE_H264_EXTENDED ||
        sps->profile_idc == AV_PROFILE_H264_MAIN) {
        pps->more_rbsp_data = 0;
    } else {
        pps->more_rbsp_data = 1;
        pps->transform_8x8_mode_flag = 1;
    }
    *vseq = (VAEncSequenceParameterBufferH264) {
        .seq_parameter_set_id = sps->seq_parameter_set_id,
        .level_idc        = sps->level_idc,
        .intra_period     = ctx->gop_size,
        .intra_idr_period = ctx->gop_size,
        .ip_period        = ctx->b_per_p + 1,
        .bits_per_second       = ctx->va_bit_rate,
        .max_num_ref_frames    = sps->max_num_ref_frames,
        .picture_width_in_mbs  = sps->pic_width_in_mbs_minus1 + 1,
        .picture_height_in_mbs = sps->pic_height_in_map_units_minus1 + 1,
        .seq_fields.bits = {
            .chroma_format_idc                 = sps->chroma_format_idc,
            .frame_mbs_only_flag               = sps->frame_mbs_only_flag,
            .mb_adaptive_frame_field_flag      = sps->mb_adaptive_frame_field_flag,
            .seq_scaling_matrix_present_flag   = sps->seq_scaling_matrix_present_flag,
            .direct_8x8_inference_flag         = sps->direct_8x8_inference_flag,
            .log2_max_frame_num_minus4         = sps->log2_max_frame_num_minus4,
            .pic_order_cnt_type                = sps->pic_order_cnt_type,
            .log2_max_pic_order_cnt_lsb_minus4 = sps->log2_max_pic_order_cnt_lsb_minus4,
            .delta_pic_order_always_zero_flag  = sps->delta_pic_order_always_zero_flag,
        },
        .bit_depth_luma_minus8   = sps->bit_depth_luma_minus8,
        .bit_depth_chroma_minus8 = sps->bit_depth_chroma_minus8,
        .frame_cropping_flag      = sps->frame_cropping_flag,
        .frame_crop_left_offset   = sps->frame_crop_left_offset,
        .frame_crop_right_offset  = sps->frame_crop_right_offset,
        .frame_crop_top_offset    = sps->frame_crop_top_offset,
        .frame_crop_bottom_offset = sps->frame_crop_bottom_offset,
        .vui_parameters_present_flag = sps->vui_parameters_present_flag,
        .vui_fields.bits = {
            .aspect_ratio_info_present_flag = sps->vui.aspect_ratio_info_present_flag,
            .timing_info_present_flag       = sps->vui.timing_info_present_flag,
            .bitstream_restriction_flag     = sps->vui.bitstream_restriction_flag,
            .log2_max_mv_length_horizontal  = sps->vui.log2_max_mv_length_horizontal,
            .log2_max_mv_length_vertical    = sps->vui.log2_max_mv_length_vertical,
        },
        .aspect_ratio_idc  = sps->vui.aspect_ratio_idc,
        .sar_width         = sps->vui.sar_width,
        .sar_height        = sps->vui.sar_height,
        .num_units_in_tick = sps->vui.num_units_in_tick,
        .time_scale        = sps->vui.time_scale,
    };
    *vpic = (VAEncPictureParameterBufferH264) {
        .CurrPic = {
            .picture_id = VA_INVALID_ID,
            .flags      = VA_PICTURE_H264_INVALID,
        },
        .coded_buf = VA_INVALID_ID,
        .pic_parameter_set_id = pps->pic_parameter_set_id,
        .seq_parameter_set_id = pps->seq_parameter_set_id,
        .pic_init_qp                  = pps->pic_init_qp_minus26 + 26,
        .num_ref_idx_l0_active_minus1 = pps->num_ref_idx_l0_default_active_minus1,
        .num_ref_idx_l1_active_minus1 = pps->num_ref_idx_l1_default_active_minus1,
        .chroma_qp_index_offset        = pps->chroma_qp_index_offset,
        .second_chroma_qp_index_offset = pps->second_chroma_qp_index_offset,
        .pic_fields.bits = {
            .entropy_coding_mode_flag        = pps->entropy_coding_mode_flag,
            .weighted_pred_flag              = pps->weighted_pred_flag,
            .weighted_bipred_idc             = pps->weighted_bipred_idc,
            .constrained_intra_pred_flag     = pps->constrained_intra_pred_flag,
            .transform_8x8_mode_flag         = pps->transform_8x8_mode_flag,
            .deblocking_filter_control_present_flag =
                pps->deblocking_filter_control_present_flag,
            .redundant_pic_cnt_present_flag  = pps->redundant_pic_cnt_present_flag,
            .pic_order_present_flag          =
                pps->bottom_field_pic_order_in_frame_present_flag,
            .pic_scaling_matrix_present_flag = pps->pic_scaling_matrix_present_flag,
        },
    };
    return 0;
}
