bool decode_as_command_option(const char *cl_param)
{
    char                         *table_name;
    unsigned int                      selector = 0, selector2 = 0;
    char                         *decoded_param;
    char                         *remaining_param;
    char                         *selector_str = NULL;
    char                         *dissector_str;
    dissector_handle_t            dissector_matching;
    dissector_table_t             table_matching;
    ftenum_t                      dissector_table_selector_type;
    struct protocol_name_search   user_protocol_name;
    unsigned int int                      i;
    char                          op = '\0';
    decoded_param = g_strdup(cl_param);
    ws_assert(decoded_param);
    table_name = decoded_param; 
    remaining_param = strchr(table_name, '=');
    if (remaining_param == NULL) {
        remaining_param = strchr(table_name, ',');
        if (remaining_param == NULL) {
            cmdarg_err("Parameter \"%s\" doesn't follow the template \"%s\"", cl_param, DECODE_AS_ARG_TEMPLATE);
        } else {
            *remaining_param = '\0'; 
        }
    }
    else {
        *remaining_param = '\0'; 
    }
    while (table_name[0] == ' ')
        table_name++;
    while (table_name[strlen(table_name) - 1] == ' ')
        table_name[strlen(table_name) - 1] = '\0'; 
    table_matching = NULL;
    if (!(*(table_name))) { 
        cmdarg_err("No layer type specified"); 
    }
    else {
        table_matching = find_dissector_table(table_name);
        if (!table_matching) {
            cmdarg_err("Unknown layer type -- %s", table_name); 
        }
    }
    if (!table_matching) {
        cmdarg_err("Valid layer types are:");
        fprint_all_layer_types(stderr);
    }
    if (remaining_param == NULL || !table_matching) {
        g_free(decoded_param);
        return false;
    }
    dissector_table_selector_type = get_dissector_table_selector_type(table_name);
    if (dissector_table_selector_type != FT_NONE) {
        if (*(remaining_param + 1) != '=') { 
                cmdarg_err("WARNING: -d requires \"==\" instead of \"=\". Option will be treated as \"%s==%s\"", table_name, remaining_param + 1);
        }
        else {
            remaining_param++; 
            *remaining_param = '\0'; 
        }
        remaining_param++; 
        selector_str = remaining_param; 
        remaining_param = strchr(selector_str, ',');
        if (remaining_param == NULL) {
            cmdarg_err("Parameter \"%s\" doesn't follow the template \"%s\"", cl_param, DECODE_AS_ARG_TEMPLATE);
        }
        else {
            *remaining_param = '\0'; 
        }
    }
    switch (dissector_table_selector_type) {
    case FT_UINT8:
    case FT_UINT16:
    case FT_UINT24:
    case FT_UINT32:
    {
        char *str = selector_str;
        char *end;
        unsigned int int val;
        while (g_ascii_isspace(*str)) {
            str++;
        }
        val = g_ascii_strtoull(str, &end, 0);
        if (str == end || val > UINT32_MAX) {
            cmdarg_err("Invalid selector number \"%s\"", selector_str);
            g_free(decoded_param);
            return false;
        }
        selector = (unsigned int) val;
        if (*end == '\0') {
            op = '\0';
            selector2 = 0;
        } else if (*end == ':' || *end == '-') {
            op = *end;
            str = end + 1;
            val = g_ascii_strtoull(str, &end, 0);
            if (str == end || val > UINT32_MAX || *end != '\0') {
                cmdarg_err("Invalid selector numeric range \"%s\"", selector_str);
                g_free(decoded_param);
                return false;
            }
            selector2 = (unsigned int) val;
            if (op == ':') {
                if ((selector2 == 0) || ((unsigned int int)selector + selector2 - 1) > UINT32_MAX) {
                    cmdarg_err("Invalid selector numeric range \"%s\"", selector_str);
                    g_free(decoded_param);
                    return false;
                }
            }
            else if (selector2 < selector) {
                cmdarg_err("Invalid selector numeric range \"%s\"", selector_str);
                g_free(decoded_param);
                return false;
            }
        } else {
            cmdarg_err("Invalid selector number \"%s\"", selector_str);
            g_free(decoded_param);
            return false;
        }
        break;
    }
    case FT_STRING:
    case FT_STRINGZ:
    case FT_UINT_STRING:
    case FT_STRINGZPAD:
    case FT_STRINGZTRUNC:
        break;
    case FT_NONE:
        break;
    default:
        ws_assert_not_reached();
    }
    if (remaining_param == NULL) {
        cmdarg_err("Valid protocols for layer type \"%s\" are:", table_name);
        fprint_all_protocols_for_layer_types(stderr, table_name);
        g_free(decoded_param);
        return false;
    }
    remaining_param++; 
    dissector_str = remaining_param; 
    while (dissector_str[0] == ' ')
        dissector_str++;
    while (dissector_str[strlen(dissector_str) - 1] == ' ')
        dissector_str[strlen(dissector_str) - 1] = '\0'; 
    dissector_matching = NULL;
    if (!(*dissector_str)) { 
        cmdarg_err("No protocol name specified"); 
    }
    else {
        header_field_info *hfi = proto_registrar_get_byalias(dissector_str);
        user_protocol_name.nb_match = 0;
        if (hfi) {
            user_protocol_name.searched_name = hfi->abbrev;
        } else {
            user_protocol_name.searched_name = dissector_str;
        }
        user_protocol_name.matched_handle = NULL;
        dissector_table_foreach_handle(table_name, find_protocol_name_func, &user_protocol_name); 
        if (user_protocol_name.nb_match != 0) {
            dissector_matching = user_protocol_name.matched_handle;
            if (user_protocol_name.nb_match > 1) {
                cmdarg_err("WARNING: Protocol \"%s\" matched %u dissectors, first one will be used", dissector_str, user_protocol_name.nb_match);
            }
        }
        else {
            if (proto_get_id_by_filter_name(dissector_str) == -1) {
                cmdarg_err("Unknown protocol -- \"%s\"", dissector_str);
            }
            else {
                cmdarg_err("Protocol \"%s\" isn't valid for layer type \"%s\"",
                    dissector_str, table_name);
            }
        }
    }
    if (!dissector_matching) {
        cmdarg_err("Valid protocols for layer type \"%s\" are:", table_name);
        fprint_all_protocols_for_layer_types(stderr, table_name);
        g_free(decoded_param);
        return false;
    }
    switch (dissector_table_selector_type) {
    case FT_UINT8:
    case FT_UINT16:
    case FT_UINT24:
    case FT_UINT32:
        if (op == '\0') {
            dissector_change_uint(table_name, selector, dissector_matching);
        }
        else if (op == ':') {
            for (i = selector; i < (unsigned int int)selector + selector2; i++) {
                dissector_change_uint(table_name, (unsigned int)i, dissector_matching);
            }
        }
        else { 
            for (i = selector; i <= selector2; i++) {
                dissector_change_uint(table_name, (unsigned int)i, dissector_matching);
            }
        }
        break;
    case FT_STRING:
    case FT_STRINGZ:
    case FT_UINT_STRING:
    case FT_STRINGZPAD:
    case FT_STRINGZTRUNC:
        dissector_change_string(table_name, selector_str, dissector_matching);
        break;
    case FT_NONE:
        dissector_change_payload(table_name, dissector_matching);
        break;
    default:
        ws_assert_not_reached();
    }
    g_free(decoded_param); 
    return true;
}
