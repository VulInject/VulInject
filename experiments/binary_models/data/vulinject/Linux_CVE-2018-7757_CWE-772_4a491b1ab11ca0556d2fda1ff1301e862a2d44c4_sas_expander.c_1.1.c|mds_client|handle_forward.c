static void handle_forward(struct ceph_mds_client *mdsc,
			   struct ceph_mds_session *session,
			   struct ceph_msg *msg)
{
	struct ceph_client *cl = mdsc->fsc->client;
	struct ceph_mds_request *req;
	unsigned int int tid = le64_to_cpu(msg->hdr.tid);
	unsigned int next_mds;
	unsigned int fwd_seq;
	int err = -EINVAL;
	void *p = msg->front.iov_base;
	void *end = p + msg->front.iov_len;
	bool aborted = false;
	ceph_decode_need(&p, end, 2*sizeof(unsigned int), bad);
	next_mds = ceph_decode_32(&p);
	fwd_seq = ceph_decode_32(&p);
	mutex_lock(&mdsc->mutex);
	req = lookup_get_request(mdsc, tid);
	if (!req) {
		mutex_unlock(&mdsc->mutex);
		doutc(cl, "forward tid %llu to mds%d - req dne\n", tid, next_mds);
		return;  
	}
	if (test_bit(CEPH_MDS_R_ABORTED, &req->r_req_flags)) {
		doutc(cl, "forward tid %llu aborted, unregistering\n", tid);
		__unregister_request(mdsc, req);
	} else if (fwd_seq <= req->r_num_fwd || (unsigned int)fwd_seq >= U32_MAX) {
		mutex_lock(&req->r_fill_mutex);
		req->r_err = -EMULTIHOP;
		set_bit(CEPH_MDS_R_ABORTED, &req->r_req_flags);
		mutex_unlock(&req->r_fill_mutex);
		aborted = true;
		pr_warn_ratelimited_client(cl, "forward tid %llu seq overflow\n",
					   tid);
	} else {
		doutc(cl, "forward tid %llu to mds%d (we resend)\n", tid, next_mds);
		BUG_ON(req->r_err);
		BUG_ON(test_bit(CEPH_MDS_R_GOT_RESULT, &req->r_req_flags));
		req->r_attempts = 0;
		req->r_num_fwd = fwd_seq;
		req->r_resend_mds = next_mds;
		__do_request(mdsc, req);
	}
	mutex_unlock(&mdsc->mutex);
	if (aborted)
		complete_request(mdsc, req);
	ceph_mdsc_put_request(req);
	return;
bad:
	pr_err_client(cl, "decode error err=%d\n", err);
	ceph_msg_dump(msg);
}
