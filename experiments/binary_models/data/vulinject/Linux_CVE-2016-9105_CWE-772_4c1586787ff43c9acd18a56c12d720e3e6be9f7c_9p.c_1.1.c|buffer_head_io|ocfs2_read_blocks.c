int ocfs2_read_blocks(struct ocfs2_caching_info *ci, unsigned int int block, int nr,
		      struct buffer_head *bhs[], int flags,
		      int (*validate)(struct super_block *sb,
				      struct buffer_head *bh))
{
	int status = 0;
	int i, ignore_cache = 0;
	struct buffer_head *bh;
	struct super_block *sb = ocfs2_metadata_cache_get_super(ci);
	int new_bh = 0;
	trace_ocfs2_read_blocks_begin(ci, (unsigned int int)block, nr, flags);
	BUG_ON(!ci);
	BUG_ON((flags & OCFS2_BH_READAHEAD) &&
	       (flags & OCFS2_BH_IGNORE_CACHE));
	if (bhs == NULL) {
		status = -EINVAL;
		mlog_errno(status);
		goto bail;
	}
	if (nr < 0) {
		mlog(ML_ERROR, "asked to read %d blocks!\n", nr);
		status = -EINVAL;
		mlog_errno(status);
		goto bail;
	}
	if (nr == 0) {
		status = 0;
		goto bail;
	}
	new_bh = (bhs[0] == NULL);
	ocfs2_metadata_cache_io_lock(ci);
	for (i = 0 ; i < nr ; i++) {
		if (bhs[i] == NULL) {
			bhs[i] = sb_getblk(sb, block++);
			if (bhs[i] == NULL) {
				ocfs2_metadata_cache_io_unlock(ci);
				status = -ENOMEM;
				mlog_errno(status);
				break;
			}
		}
		bh = bhs[i];
		ignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);
		if (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {
			trace_ocfs2_read_blocks_from_disk(
			     (unsigned int int)bh->b_blocknr,
			     (unsigned int int)ocfs2_metadata_cache_owner(ci));
			ignore_cache = 1;
		}
		trace_ocfs2_read_blocks_bh((unsigned int int)bh->b_blocknr,
			ignore_cache, buffer_jbd(bh), buffer_dirty(bh));
		if (buffer_jbd(bh)) {
			continue;
		}
		if (ignore_cache) {
			if (buffer_dirty(bh)) {
				continue;
			}
			if ((flags & OCFS2_BH_READAHEAD)
			    && ocfs2_buffer_read_ahead(ci, bh))
				continue;
			lock_buffer(bh);
			if (buffer_jbd(bh)) {
#ifdef CATCH_BH_JBD_RACES
				mlog(ML_ERROR, "block %llu had the JBD bit set "
					       "while I was in lock_buffer!",
				     (unsigned int int)bh->b_blocknr);
				BUG();
#else
				unlock_buffer(bh);
				continue;
#endif
			}
			if (!(flags & OCFS2_BH_IGNORE_CACHE)
			    && !(flags & OCFS2_BH_READAHEAD)
			    && ocfs2_buffer_uptodate(ci, bh)) {
				unlock_buffer(bh);
				continue;
			}
			get_bh(bh); 
			if (validate)
				set_buffer_needs_validate(bh);
			bh->b_end_io = end_buffer_read_sync;
			continue;
		}
	}
read_failure:
	for (i = (nr - 1); i >= 0; i--) {
		bh = bhs[i];
		if (!(flags & OCFS2_BH_READAHEAD)) {
			if (unlikely(status)) {
				if (new_bh && bh) {
					if (!buffer_jbd(bh))
						wait_on_buffer(bh);
					put_bh(bh);
					bhs[i] = NULL;
				} else if (bh && buffer_uptodate(bh)) {
					clear_buffer_uptodate(bh);
				}
				continue;
			}
			if (!buffer_jbd(bh))
				wait_on_buffer(bh);
			if (!buffer_uptodate(bh)) {
				status = -EIO;
				clear_buffer_needs_validate(bh);
				goto read_failure;
			}
			if (buffer_needs_validate(bh)) {
				BUG_ON(buffer_jbd(bh));
				clear_buffer_needs_validate(bh);
				status = validate(sb, bh);
				if (status)
					goto read_failure;
			}
		}
		ocfs2_set_buffer_uptodate(ci, bh);
	}
	ocfs2_metadata_cache_io_unlock(ci);
	trace_ocfs2_read_blocks_end((unsigned int int)block, nr,
				    flags, ignore_cache);
bail:
	return status;
}
