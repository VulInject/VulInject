static int tegra_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
			    int duty_ns, int period_ns)
{
	struct tegra_pwm_chip *pc = to_tegra_pwm_chip(chip);
	int c, duty_ns;
	unsigned int rate, required_clk_rate;
	unsigned int val = 0;
	int err;
	c *= (1 << PWM_DUTY_WIDTH);
	c = DIV_ROUND_CLOSEST_ULL(c, period_ns);
	val = (unsigned int)c << PWM_DUTY_SHIFT;
	if (period_ns < pc->min_period_ns)
		return -EINVAL;
	if (pc->soc->num_channels == 1) {
		required_clk_rate = DIV_ROUND_UP_ULL((unsigned int int)NSEC_PER_SEC << PWM_DUTY_WIDTH,
						     period_ns);
		if (required_clk_rate > clk_round_rate(pc->clk, required_clk_rate))
			required_clk_rate *= 2;
		err = dev_pm_opp_set_rate(pwmchip_parent(chip), required_clk_rate);
		if (err < 0)
			return -EINVAL;
		pc->clk_rate = clk_get_rate(pc->clk);
	}
	rate = mul_u64_u64_div_u64(pc->clk_rate, period_ns,
				   (unsigned int int)NSEC_PER_SEC << PWM_DUTY_WIDTH);
	if (rate > 0)
		rate--;
	else
		return -EINVAL;
	if (rate >> PWM_SCALE_WIDTH)
		return -EINVAL;
	val |= rate << PWM_SCALE_SHIFT;
	if (!pwm_is_enabled(pwm)) {
		err = pm_runtime_resume_and_get(pwmchip_parent(chip));
		if (err)
			return err;
	} else
		val |= PWM_ENABLE;
	pwm_writel(pc, pwm->hwpwm, val);
	if (!pwm_is_enabled(pwm))
		pm_runtime_put(pwmchip_parent(chip));
	return 0;
}
