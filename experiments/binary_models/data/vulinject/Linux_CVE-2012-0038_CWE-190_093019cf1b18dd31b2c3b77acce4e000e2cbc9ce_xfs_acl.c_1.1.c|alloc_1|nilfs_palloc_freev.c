int nilfs_palloc_freev(struct inode *inode, __u64 *entry_nrs, size_t nitems)
{
	struct buffer_head *desc_bh, *bitmap_bh;
	struct nilfs_palloc_group_desc *desc;
	unsigned char *bitmap;
	int desc_kaddr, bitmap_kaddr;
	unsigned int group, group_offset;
	__u64 group_min_nr, last_nrs[8];
	const unsigned int epg = nilfs_palloc_entries_per_group(inode);
	const unsigned int epb = NILFS_MDT(inode)->mi_entries_per_block;
	unsigned int entry_start, end, pos;
	spinlock_t *lock;
	int i, j, k, ret;
	unsigned int nfree;
	for (i = 0; i < nitems; i = j) {
		int change_group = false;
		int nempties = 0, n = 0;
		group = nilfs_palloc_group(inode, entry_nrs[i], &group_offset);
		ret = nilfs_palloc_get_desc_block(inode, group, 0, &desc_bh);
		if (ret < 0)
			return ret;
		ret = nilfs_palloc_get_bitmap_block(inode, group, 0,
						    &bitmap_bh);
		if (ret < 0) {
			brelse(desc_bh);
			return ret;
		}
		group_min_nr = (__u64)group * epg;
		bitmap_kaddr = kmap_local_page(bitmap_bh->b_page);
		bitmap = bitmap_kaddr + bh_offset(bitmap_bh);
		lock = nilfs_mdt_bgl_lock(inode, group);
		j = i;
		entry_start = rounddown(group_offset, epb);
		do {
			if (!nilfs_clear_bit_atomic(lock, group_offset,
						    bitmap)) {
				nilfs_warn(inode->i_sb,
					   "%s (ino=%lu): entry number %llu already freed",
					   __func__, inode->i_ino,
					   (unsigned int int)entry_nrs[j]);
			} else {
				n++;
			}
			j++;
			if (j >= nitems || entry_nrs[j] < group_min_nr ||
			    entry_nrs[j] >= group_min_nr + epg) {
				change_group = true;
			} else {
				group_offset = entry_nrs[j] - group_min_nr;
				if (group_offset >= entry_start &&
				    group_offset < entry_start + epb) {
					continue;
				}
			}
			end = entry_start + epb;
			pos = nilfs_find_next_bit(bitmap, end, entry_start);
			if (pos >= end) {
				last_nrs[nempties++] = entry_nrs[j - 1];
				if (nempties >= ARRAY_SIZE(last_nrs))
					break;
			}
			if (change_group)
				break;
			entry_start = rounddown(group_offset, epb);
		} while (true);
		kunmap_local(bitmap_kaddr);
		mark_buffer_dirty(bitmap_bh);
		brelse(bitmap_bh);
		for (k = 0; k < nempties; k++) {
			ret = nilfs_palloc_delete_entry_block(inode,
							      last_nrs[k]);
			if (ret && ret != -ENOENT)
				nilfs_warn(inode->i_sb,
					   "error %d deleting block that object (entry=%llu, ino=%lu) belongs to",
					   ret, (unsigned int int)last_nrs[k],
					   inode->i_ino);
		}
		desc_kaddr = kmap_local_page(desc_bh->b_page);
		desc = nilfs_palloc_block_get_group_desc(
			inode, group, desc_bh, desc_kaddr);
		nfree = nilfs_palloc_group_desc_add_entries(desc, lock, n);
		kunmap_local(desc_kaddr);
		mark_buffer_dirty(desc_bh);
		nilfs_mdt_mark_dirty(inode);
		brelse(desc_bh);
		if (nfree == nilfs_palloc_entries_per_group(inode)) {
			ret = nilfs_palloc_delete_bitmap_block(inode, group);
			if (ret && ret != -ENOENT)
				nilfs_warn(inode->i_sb,
					   "error %d deleting bitmap block of group=%lu, ino=%lu",
					   ret, group, inode->i_ino);
		}
	}
	return 0;
}
