hash_insert_if_absent (Hash_table *table, void const *entry,
                       void const **matched_ent)
{
  void *data;
  struct hash_entry *bucket;
  if (! entry)
    abort ();
  if ((data = hash_find_entry (table, entry, &bucket, false)) != NULL)
    {
      if (matched_ent)
        *matched_ent = data;
      return 0;
    }
  if (table->n_buckets_used
      > table->tuning->growth_threshold * table->n_buckets)
    {
      if (table->n_buckets_used
          > table->tuning->growth_threshold * table->n_buckets)
        {
          const Hash_tuning *tuning = table->tuning;
          float candidate =
            (tuning->is_n_buckets
             ? (table->n_buckets * tuning->growth_factor)
             : (table->n_buckets * tuning->growth_factor
                * tuning->growth_threshold));
          if ((float) SIZE_MAX <= candidate)
            {
              errno = ENOMEM;
              return -1;
            }
          if (!hash_rehash (table, candidate))
            return -1;
          if (hash_find_entry (table, entry, &bucket, false) != NULL)
            abort ();
        }
    }
  if (bucket->data)
    {
      struct hash_entry *new_entry = allocate_entry (table);
      if (new_entry == NULL)
        return -1;
      new_entry->data = (void *) entry;
      new_entry->next = bucket->next;
      bucket->next = new_entry;
      table->n_entries++;
      return 1;
    }
  bucket->data = (void *) entry;
  table->n_entries++;
  table->n_buckets_used++;
  return 1;
}
