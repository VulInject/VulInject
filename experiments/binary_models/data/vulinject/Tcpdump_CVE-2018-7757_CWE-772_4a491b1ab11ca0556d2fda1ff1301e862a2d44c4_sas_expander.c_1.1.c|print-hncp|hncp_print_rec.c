hncp_print_rec(netdissect_options *ndo,
               const u_char *cp, u_int length, int indent)
{
    const int in_line = is_in_line(ndo, indent);
    int first_one = 1;
    u_int i, t;
    unsigned int last_type_mask = 0xffffffffU;
    int last_type_count = -1;
    const unsigned char *tlv, *value;
    unsigned short type, bodylen;
    unsigned int type_mask;
    i = 0;
    while (i < length) {
        tlv = cp + i;
        if (!in_line) {
            ND_PRINT("\n");
            for (t = indent; t > 0; t--)
                ND_PRINT("\t");
        }
        if (i + 4 > length)
            goto invalid;
        type = GET_BE_U_2(tlv);
        bodylen = GET_BE_U_2(tlv + 2);
        value = tlv + 4;
        ND_TCHECK_LEN(value, bodylen);
        if (i + bodylen + 4 > length)
            goto invalid;
        type_mask =
            (type == 0)                   ? RANGE_DNCP_RESERVED:
            (44 <= type && type <= 511)   ? RANGE_HNCP_UNASSIGNED:
            (768 <= type && type <= 1023) ? RANGE_DNCP_PRIVATE_USE:
                                            RANGE_DNCP_FUTURE_USE;
        if (type == 6 || type == 7)
            type_mask = RANGE_DNCP_FUTURE_USE;
        {
            t = 0;
            while (1) {
                u_int key = type_values[t++].v;
                if (key > 0xffff)
                    break;
                if (key == type) {
                    type_mask = type;
                    break;
                }
            }
        }
        if (in_line) {
            if (last_type_mask == type_mask) {
                last_type_count++;
            } else {
                print_type_in_line(ndo, last_type_mask, last_type_count, indent, &first_one);
                last_type_mask = type_mask;
                last_type_count = 1;
            }
            goto skip_multiline;
        }
        ND_PRINT("%s", tok2str(type_values, "Easter Egg (42)", type_mask) );
        if (type_mask > 0xffff)
            ND_PRINT(": type=%u", type );
        ND_PRINT(" (%u)", bodylen + 4 );
        switch (type_mask) {
        case DNCP_REQUEST_NETWORK_STATE: {
            if (bodylen != 0)
                nd_print_invalid(ndo);
        }
            break;
        case DNCP_REQUEST_NODE_STATE: {
            const char *node_identifier;
            if (bodylen != 4) {
                nd_print_invalid(ndo);
                break;
            }
            node_identifier = format_nid(ndo, value);
            ND_PRINT(" NID: %s", node_identifier);
        }
            break;
        case DNCP_NODE_ENDPOINT: {
            const char *node_identifier;
            unsigned int endpoint_identifier;
            if (bodylen != 8) {
                nd_print_invalid(ndo);
                break;
            }
            node_identifier = format_nid(ndo, value);
            endpoint_identifier = GET_BE_U_4(value + 4);
            ND_PRINT(" NID: %s EPID: %08x",
                node_identifier,
                endpoint_identifier
            );
        }
            break;
        case DNCP_NETWORK_STATE: {
            unsigned int int hash;
            if (bodylen != 8) {
                nd_print_invalid(ndo);
                break;
            }
            hash = GET_BE_U_8(value);
            ND_PRINT(" hash: %016" PRIx64, hash);
        }
            break;
        case DNCP_NODE_STATE: {
            const char *node_identifier, *interval;
            unsigned int sequence_number;
            unsigned int int hash;
            if (bodylen < 20) {
                nd_print_invalid(ndo);
                break;
            }
            node_identifier = format_nid(ndo, value);
            sequence_number = GET_BE_U_4(value + 4);
            interval = format_interval(GET_BE_U_4(value + 8));
            hash = GET_BE_U_8(value + 12);
            ND_PRINT(" NID: %s seqno: %u %s hash: %016" PRIx64,
                node_identifier,
                sequence_number,
                interval,
                hash
            );
            hncp_print_rec(ndo, value+20, bodylen-20, indent+1);
        }
            break;
        case DNCP_PEER: {
            const char *peer_node_identifier;
            unsigned int peer_endpoint_identifier, endpoint_identifier;
            if (bodylen != 12) {
                nd_print_invalid(ndo);
                break;
            }
            peer_node_identifier = format_nid(ndo, value);
            peer_endpoint_identifier = GET_BE_U_4(value + 4);
            endpoint_identifier = GET_BE_U_4(value + 8);
            ND_PRINT(" Peer-NID: %s Peer-EPID: %08x Local-EPID: %08x",
                peer_node_identifier,
                peer_endpoint_identifier,
                endpoint_identifier
            );
        }
            break;
        case DNCP_KEEP_ALIVE_INTERVAL: {
            unsigned int endpoint_identifier;
            const char *interval;
            if (bodylen < 8) {
                nd_print_invalid(ndo);
                break;
            }
            endpoint_identifier = GET_BE_U_4(value);
            interval = format_interval(GET_BE_U_4(value + 4));
            ND_PRINT(" EPID: %08x Interval: %s",
                endpoint_identifier,
                interval
            );
        }
            break;
        case DNCP_TRUST_VERDICT: {
            if (bodylen <= 36) {
                nd_print_invalid(ndo);
                break;
            }
            ND_PRINT(" Verdict: %u Fingerprint: %s Common Name: ",
                GET_U_1(value),
                format_256(ndo, value + 4));
            nd_printjnp(ndo, value + 36, bodylen - 36);
        }
            break;
        case HNCP_HNCP_VERSION: {
            unsigned short capabilities;
            unsigned char M, P, H, L;
            if (bodylen < 5) {
                nd_print_invalid(ndo);
                break;
            }
            capabilities = GET_BE_U_2(value + 2);
            M = (unsigned char)((capabilities >> 12) & 0xf);
            P = (unsigned char)((capabilities >> 8) & 0xf);
            H = (unsigned char)((capabilities >> 4) & 0xf);
            L = (unsigned char)(capabilities & 0xf);
            ND_PRINT(" M: %u P: %u H: %u L: %u User-agent: ",
                M, P, H, L
            );
            nd_printjnp(ndo, value + 4, bodylen - 4);
        }
            break;
        case HNCP_EXTERNAL_CONNECTION: {
            hncp_print_rec(ndo, value, bodylen, indent+1);
        }
            break;
        case HNCP_DELEGATED_PREFIX: {
            int l;
            if (bodylen < 9 || bodylen < 9 + (GET_U_1(value + 8) + 7) / 8) {
                nd_print_invalid(ndo);
                break;
            }
            ND_PRINT(" VLSO: %s PLSO: %s Prefix: ",
                format_interval(GET_BE_U_4(value)),
                format_interval(GET_BE_U_4(value + 4))
            );
            l = print_prefix(ndo, value + 8, bodylen - 8);
            if (l == -1) {
                ND_PRINT("(length is invalid)");
                break;
            }
            if (l < 0) {
                nd_print_invalid(ndo);
                break;
            }
            l += 8 + (-l & 3);
            if (bodylen >= l)
                hncp_print_rec(ndo, value + l, bodylen - l, indent+1);
        }
            break;
        case HNCP_PREFIX_POLICY: {
            unsigned char policy;
            int l;
            if (bodylen < 1) {
                nd_print_invalid(ndo);
                break;
            }
            policy = GET_U_1(value);
            ND_PRINT(" type: ");
            if (policy == 0) {
                if (bodylen != 1) {
                    nd_print_invalid(ndo);
                    break;
                }
                ND_PRINT("Internet connectivity");
            } else if (policy >= 1 && policy <= 128) {
                ND_PRINT("Dest-Prefix: ");
                l = print_prefix(ndo, value, bodylen);
                if (l == -1) {
                    ND_PRINT("(length is invalid)");
                    break;
                }
                if (l < 0) {
                    nd_print_invalid(ndo);
                    break;
                }
            } else if (policy == 129) {
                ND_PRINT("DNS domain: ");
                print_dns_label(ndo, value+1, bodylen-1, 1);
            } else if (policy == 130) {
                ND_PRINT("Opaque UTF-8: ");
                nd_printjnp(ndo, value + 1, bodylen - 1);
            } else if (policy == 131) {
                if (bodylen != 1) {
                    nd_print_invalid(ndo);
                    break;
                }
                ND_PRINT("Restrictive assignment");
            } else if (policy >= 132) {
                ND_PRINT("Unknown (%u)", policy); 
            }
        }
            break;
        case HNCP_DHCPV4_DATA: {
            if (bodylen == 0) {
                nd_print_invalid(ndo);
                break;
            }
            if (dhcpv4_print(ndo, value, bodylen, indent+1) != 0)
                goto invalid;
        }
            break;
        case HNCP_DHCPV6_DATA: {
            if (bodylen == 0) {
                nd_print_invalid(ndo);
                break;
            }
            if (dhcpv6_print(ndo, value, bodylen, indent+1) != 0) {
                nd_print_invalid(ndo);
                break;
            }
        }
            break;
        case HNCP_ASSIGNED_PREFIX: {
            unsigned char prty;
            int l;
            if (bodylen < 6 || bodylen < 6 + (GET_U_1(value + 5) + 7) / 8) {
                nd_print_invalid(ndo);
                break;
            }
            prty = GET_U_1(value + 4) & 0xf;
            ND_PRINT(" EPID: %08x Prty: %u",
                GET_BE_U_4(value),
                prty
            );
            ND_PRINT(" Prefix: ");
            if ((l = print_prefix(ndo, value + 5, bodylen - 5)) < 0) {
                nd_print_invalid(ndo);
                break;
            }
            l += 5;
            l += -l & 3;
            if (bodylen >= l)
                hncp_print_rec(ndo, value + l, bodylen - l, indent+1);
        }
            break;
        case HNCP_NODE_ADDRESS: {
            unsigned int endpoint_identifier;
            const char *ip_address;
            if (bodylen < 20) {
                nd_print_invalid(ndo);
                break;
            }
            endpoint_identifier = GET_BE_U_4(value);
            ip_address = format_ip6addr(ndo, value + 4);
            ND_PRINT(" EPID: %08x IP Address: %s",
                endpoint_identifier,
                ip_address
            );
            hncp_print_rec(ndo, value + 20, bodylen - 20, indent+1);
        }
            break;
        case HNCP_DNS_DELEGATED_ZONE: {
            const char *ip_address;
            int len;
            if (bodylen < 17) {
                nd_print_invalid(ndo);
                break;
            }
            ip_address = format_ip6addr(ndo, value);
            ND_PRINT(" IP-Address: %s %c%c%c ",
                ip_address,
                (GET_U_1(value + 16) & 4) ? 'l' : '-',
                (GET_U_1(value + 16) & 2) ? 'b' : '-',
                (GET_U_1(value + 16) & 1) ? 's' : '-'
            );
            len = print_dns_label(ndo, value+17, bodylen-17, 1);
            if (len < 0) {
                nd_print_invalid(ndo);
                break;
            }
            len += 17;
            len += -len & 3;
            if (bodylen >= len)
                hncp_print_rec(ndo, value+len, bodylen-len, indent+1);
        }
            break;
        case HNCP_DOMAIN_NAME: {
            if (bodylen == 0) {
                nd_print_invalid(ndo);
                break;
            }
            ND_PRINT(" Domain: ");
            print_dns_label(ndo, value, bodylen, 1);
        }
            break;
        case HNCP_NODE_NAME: {
            u_int l;
            if (bodylen < 17) {
                nd_print_invalid(ndo);
                break;
            }
            l = GET_U_1(value + 16);
            if (bodylen < 17 + l) {
                nd_print_invalid(ndo);
                break;
            }
            ND_PRINT(" IP-Address: %s Name: ",
                format_ip6addr(ndo, value)
            );
            if (l < 64) {
                ND_PRINT("\"");
                nd_printjnp(ndo, value + 17, l);
                ND_PRINT("\"");
            } else {
                nd_print_invalid(ndo);
            }
            l += 17;
            l = roundup2(l, 4);
            if (bodylen >= l)
                hncp_print_rec(ndo, value + l, bodylen - l, indent+1);
        }
            break;
        case HNCP_MANAGED_PSK: {
            if (bodylen < 32) {
                nd_print_invalid(ndo);
                break;
            }
            ND_PRINT(" PSK: %s", format_256(ndo, value));
            hncp_print_rec(ndo, value + 32, bodylen - 32, indent+1);
        }
            break;
        case RANGE_DNCP_RESERVED:
        case RANGE_HNCP_UNASSIGNED:
        case RANGE_DNCP_PRIVATE_USE:
        case RANGE_DNCP_FUTURE_USE:
            break;
        }
    skip_multiline:
        i += 4 + roundup2(bodylen, 4);
    }
    print_type_in_line(ndo, last_type_mask, last_type_count, indent, &first_one);
    return;
 trunc:
    nd_print_trunc(ndo);
    return;
 invalid:
    nd_print_invalid(ndo);
}
