static void coroutine_fn v9fs_walk(void *opaque)
{
    int name_idx, nwalked;
    g_autofree V9fsQID *qids = NULL;
    int i, err = 0, any_err = 0;
    V9fsPath dpath, path;
    P9ARRAY_REF(V9fsPath) pathes = NULL;
    uint16_t nwnames;
    struct stat stbuf, fidst;
    g_autofree struct stat *stbufs = NULL;
    size_t offset = 7;
    int32_t fid, newfid;
    P9ARRAY_REF(V9fsString) wnames = NULL;
    V9fsFidState *fidp;
    V9fsFidState *newfidp = NULL;
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    V9fsQID qid;
    err = pdu_unmarshal(pdu, offset, "ddw", &fid, &newfid, &nwnames);
    if (err < 0) {
        pdu_complete(pdu, err);
        return;
    }
    offset += err;
    trace_v9fs_walk(pdu->tag, pdu->id, fid, newfid, nwnames);
    if (nwnames > P9_MAXWELEM) {
        err = -EINVAL;
        goto out_nofid;
    }
    if (nwnames) {
        P9ARRAY_NEW(V9fsString, wnames, nwnames);
        qids   = g_new0(V9fsQID, nwnames);
        stbufs = g_new0(struct stat, nwnames);
        P9ARRAY_NEW(V9fsPath, pathes, nwnames);
        for (i = 0; i < nwnames; i++) {
            err = pdu_unmarshal(pdu, offset, "s", &wnames[i]);
            if (err < 0) {
                goto out_nofid;
            }
            if (name_is_illegal(wnames[i].data)) {
                err = -ENOENT;
                goto out_nofid;
            }
            offset += err;
        }
    }
    fidp = get_fid(pdu, fid);
    if (fidp == NULL) {
        err = -ENOENT;
        goto out_nofid;
    }
    v9fs_path_init(&dpath);
    v9fs_path_init(&path);
    /*
     * Both dpath and path initially point to fidp.
     * Needed to handle request with nwnames == 0
     */
    v9fs_path_copy(&dpath, &fidp->path);
    v9fs_path_copy(&path, &fidp->path);
    /*
     * To keep latency (i.e. overall execution time for processing this
     * Twalk client request) as small as possible, run all the required fs
     * driver code altogether inside the following block.
     */
    v9fs_co_run_in_worker({
        nwalked = 0;
        if (v9fs_request_cancelled(pdu)) {
            any_err |= err = -EINTR;
            break;
        }
        err = s->ops->lstat(&s->ctx, &dpath, &fidst);
        if (err < 0) {
            any_err |= err = -errno;
            break;
        }
        stbuf = fidst;
        for (; nwalked < nwnames; nwalked++) {
            if (v9fs_request_cancelled(pdu)) {
                any_err |= err = -EINTR;
                break;
            }
            if (!same_stat_id(&pdu->s->root_st, &stbuf) ||
                strcmp("..", wnames[nwalked].data))
            {
                err = s->ops->name_to_path(&s->ctx, &dpath,
                                           wnames[nwalked].data,
                                           &pathes[nwalked]);
                if (err < 0) {
                    any_err |= err = -errno;
                    break;
                }
                if (v9fs_request_cancelled(pdu)) {
                    any_err |= err = -EINTR;
                    break;
                }
                err = s->ops->lstat(&s->ctx, &pathes[nwalked], &stbuf);
                if (err < 0) {
                    any_err |= err = -errno;
                    break;
                }
                stbufs[nwalked] = stbuf;
                v9fs_path_copy(&dpath, &pathes[nwalked]);
            }
        }
    });
    /*
     * Handle all the rest of this Twalk request on main thread ...
     *
     * NOTE: -EINTR is an exception where we deviate from the protocol spec
     * and simply send a (R)Lerror response instead of bothering to assemble
     * a (deducted) Rwalk response; because -EINTR is always the result of a
     * Tflush request, so client would no longer wait for a response in this
     * case anyway.
     */
    if ((err < 0 && !nwalked) || err == -EINTR) {
        goto out;
    }
    any_err |= err = stat_to_qid(pdu, &fidst, &qid);
    if (err < 0 && !nwalked) {
        goto out;
    }
    stbuf = fidst;
    /* reset dpath and path */
    v9fs_path_copy(&dpath, &fidp->path);
    v9fs_path_copy(&path, &fidp->path);
    for (name_idx = 0; name_idx < nwalked; name_idx++) {
        if (!same_stat_id(&pdu->s->root_st, &stbuf) ||
            strcmp("..", wnames[name_idx].data))
        {
            stbuf = stbufs[name_idx];
            any_err |= err = stat_to_qid(pdu, &stbuf, &qid);
            if (err < 0) {
                break;
            }
            v9fs_path_copy(&path, &pathes[name_idx]);
            v9fs_path_copy(&dpath, &path);
        }
        memcpy(&qids[name_idx], &qid, sizeof(qid));
    }
    if (any_err < 0) {
        if (!name_idx) {
            /* don't send any QIDs, send Rlerror instead */
            goto out;
        } else {
            /* send QIDs (not Rlerror), but fid MUST remain unaffected */
            goto send_qids;
        }
    }
    if (fid == newfid) {
        if (fidp->fid_type != P9_FID_NONE) {
            err = -EINVAL;
            goto out;
        }
        v9fs_path_copy(&fidp->path, &path);
        v9fs_path_unlock(s);
    } else {
        newfidp = alloc_fid(s, newfid);
        if (newfidp == NULL) {
            err = -EINVAL;
            goto out;
        }
        newfidp->uid = fidp->uid;
        v9fs_path_copy(&newfidp->path, &path);
    }
send_qids:
    err = v9fs_walk_marshal(pdu, name_idx, qids);
    trace_v9fs_walk_return(pdu->tag, pdu->id, name_idx, qids);
out:
    put_fid(pdu, fidp);
    if (newfidp) {
        put_fid(pdu, newfidp);
    }
    v9fs_path_free(&dpath);
    v9fs_path_free(&path);
out_nofid:
    pdu_complete(pdu, err);
}
