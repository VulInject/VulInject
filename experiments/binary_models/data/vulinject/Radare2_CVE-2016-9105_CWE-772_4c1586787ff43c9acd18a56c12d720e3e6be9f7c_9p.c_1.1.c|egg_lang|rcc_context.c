static void rcc_context(REgg *egg, int delta) {
	REggEmit *emit = egg->remit;
	char str[64];
	if (CTX > 31 || CTX < 0) {
		return;
	}
	if (delta > 0) {
		egg->lang.nestedi[CTX]++;
		R_FREE (egg->lang.nested_callname[CTX]);
		if (egg->lang.callname) {
			egg->lang.nested_callname[CTX] = strdup (egg->lang.callname);
		}
	}
	if (egg->lang.callname && CTX > 0) {	
	}
	CTX += delta;
	egg->lang.lastctxdelta = delta;
	if (CTX == 0 && delta < 0) {
		if (egg->lang.mode != LANG_MODE_NAKED) {
			emit->frame_end (egg, egg->lang.stackframe + egg->lang.stackfixed, egg->lang.nbrackets);
		}
		if (egg->lang.mode == LANG_MODE_NORMAL) {	
			egg->lang.stackframe = 0;
		}
		egg->lang.mode = LANG_MODE_NORMAL;
	} else {
		const char *elm = r_str_trim_head_ro (egg->lang.elem);
#if 0
		if (delta < 0 && context > 0) {
			eprintf ("close bracket foo!!!\n");
			shownested ();
			cn = strdup (egg->lang.nested[context - 1]);
			eprintf ("STATEMENT cn=(%s) idx=%d (%s)\n", cn, context - 1, egg->lang.nested[context - 1]);
			eprintf ("CNTXXXPUSH (%s)\n", egg->lang.ctxpush[context - 1]);
#if 0
			if (!strcmp (cn, "while")) {
				emit->while_end (egg, get_frame_label (context - 1));
				return;
			}
#endif
		}
#endif
		if (egg->lang.callname) {
			char *b, *g, *e, *n;
			emit->comment (egg, "cond frame %s (%s)", egg->lang.callname, elm);
			if (egg->lang.conditionstr) {
				b = strchr (egg->lang.conditionstr, '<');	
				g = strchr (egg->lang.conditionstr, '>');	
				e = strchr (egg->lang.conditionstr, '=');	
				n = strchr (egg->lang.conditionstr, '!');	
			} else {
				b = g = e = n = NULL;
			}
			if (!strcmp (egg->lang.callname, "while")) {
				char lab[128];
				snprintf (lab, sizeof (lab), "__begin_%d_%d_%d", egg->lang.nfunctions,
					CTX - 1, egg->lang.nestedi[CTX - 1] - 1);
				emit->get_while_end (egg, str, egg->lang.ctxpush[CTX - 1], lab);	
				if (delta > 0) {
				}
				rcc_set_callname (egg, "if");
			}
			if (!strcmp (egg->lang.callname, "if")) {
				snprintf (str, sizeof (str), "__end_%d_%d_%d", egg->lang.nfunctions, CTX - 1, egg->lang.nestedi[CTX - 1] - 1);
				emit->branch (egg, b, g, e, n, egg->lang.varsize, str);
				if (CTX > 0) {
				}
				rcc_reset_callname (egg);
				R_FREE (egg->lang.conditionstr);
			}	
		}	
	}
}
