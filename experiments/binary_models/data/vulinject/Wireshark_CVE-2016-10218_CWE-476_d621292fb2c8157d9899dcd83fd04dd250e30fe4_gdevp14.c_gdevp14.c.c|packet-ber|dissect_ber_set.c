dissect_ber_set(bool implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, const ber_sequence_t *set, gint hf_id, gint ett_id) {
    gint8       classx;
    bool    pcx, ind = 0, ind_field, imp_tag;
    gint32      tagx;
    int         identifier_offset;
    int         identifier_len;
    guint32     lenx;
    int         len_offset;
    int         len_len;
    proto_tree *tree     = parent_tree;
    proto_item *item     = NULL;
    proto_item *cause;
    int         end_offset, s_offset;
    int         hoffset;
    tvbuff_t   *next_tvb;
    guint32     mandatory_fields = 0;
    guint8      set_idx;
    bool    first_pass;
    const ber_sequence_t *cset = NULL;
#define MAX_SET_ELEMENTS 32
    s_offset = offset;
#ifdef DEBUG_BER
    {
const char *name;
header_field_info *hfinfo;
if (hf_id > 0) {
hfinfo = proto_registrar_get_nth(hf_id);
name = hfinfo->name;
} else {
name = "unnamed";
}
if (tvb_reported_length_remaining(tvb, offset) > 3) {
proto_tree_add_debug_text(tree, "SET dissect_ber_set(%s) entered offset:%d len:%d %02x:%02x:%02x\n", name, offset, tvb_reported_length_remaining(tvb, offset), tvb_get_guint8(tvb, offset), tvb_get_guint8(tvb, offset+1), tvb_get_guint8(tvb, offset+2));
} else {
proto_tree_add_debug_text(tree, "SET dissect_ber_set(%s) entered\n", name);
}
}
#endif
    if (!implicit_tag) {
        hoffset = offset;
        identifier_offset = offset;
        offset = dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &classx, &pcx, &tagx);
        identifier_len = offset - identifier_offset;
        offset = dissect_ber_length(actx->pinfo, tree, tvb, offset, &lenx, &ind);
        if (ind) {
          end_offset = offset + lenx -2;
        } else {
          end_offset = offset + lenx;
        }
        if ((classx != BER_CLASS_APP) && (classx != BER_CLASS_PRI)) {
            if (!pcx
             || ((classx != BER_CLASS_UNI) || (tagx != BER_UNI_TAG_SET))) {
                tvb_ensure_bytes_exist(tvb, hoffset, 2);
                cause = proto_tree_add_expert_format(
                    tree, actx->pinfo, &ei_ber_expected_set,
                    tvb, identifier_offset, identifier_len,
                    "BER Error: SET expected but class:%s(%d) %s tag:%d was found",
                    val_to_str_const(classx, ber_class_codes, "Unknown"),
                    classx,
                    tfs_get_string(pcx, &tfs_constructed_primitive),
                    tagx);
                if (decode_unexpected) {
                    proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);
                    dissect_unknown_ber(actx->pinfo, tvb, hoffset, unknown_tree);
                }
                return end_offset;
            }
        }
    } else {
        lenx = tvb_reported_length_remaining(tvb, offset);
        end_offset = offset+lenx;
        identifier_offset = 0;
        identifier_len = 0;
    }
    if (hf_id > 0) {
        if (parent_tree) {
            item = proto_tree_add_item(parent_tree, hf_id, tvb, offset, lenx, ENC_BIG_ENDIAN);
            tree = proto_item_add_subtree(item, ett_id);
        }
    }
    for (set_idx = 0; (set_idx < MAX_SET_ELEMENTS) && (cset = &set[set_idx])->func; set_idx++) {
        if (!(cset->flags & BER_FLAGS_OPTIONAL))
            mandatory_fields |= 1 << set_idx;
    }
    while (offset < end_offset) {
        gint8    ber_class;
        bool pc;
        gint32   tag;
        guint32  len;
        int      eoffset, count;
            if ((tvb_get_guint8(tvb, offset) == 0) && (tvb_get_guint8(tvb, offset+1) == 0)) {
                if (show_internal_ber_fields) {
                    proto_tree_add_item(tree, hf_ber_seq_eoc, tvb, s_offset, offset+2, ENC_NA);
                }
                return end_offset;
            }
        hoffset = offset;
        identifier_offset = offset;
        offset  = get_ber_identifier(tvb, offset, &ber_class, &pc, &tag);
        identifier_len = offset - identifier_offset;
        len_offset = offset;
        offset  = get_ber_length(tvb, offset, &len, &ind_field);
        len_len = offset - len_offset;
        eoffset = offset + len;
        if (len > (guint32)(end_offset - offset) || len > (guint32) tvb_reported_length_remaining(tvb, offset)) {
            ber_add_large_length_error(actx->pinfo, tree, tvb, offset, len, tvb, len_offset, len_len);
            return end_offset;
        }
        for (first_pass = TRUE, cset = set, set_idx = 0; cset->func || first_pass; cset++, set_idx++) {
            if (!cset->func) {
                first_pass = FALSE;
                cset = set; 
                set_idx = 0;
                if (!cset->func) {
                    break;
                }
            }
            if ((first_pass && ((cset->ber_class == ber_class) && (cset->tag == tag))) ||
                (!first_pass && ((cset->ber_class == BER_CLASS_ANY) && (cset->tag == -1))) ) 
            {
                if (!(cset->flags & BER_FLAGS_NOOWNTAG) ) {
                    hoffset = dissect_ber_identifier(actx->pinfo, tree, tvb, hoffset, NULL, NULL, NULL);
                    hoffset = dissect_ber_length(actx->pinfo, tree, tvb, hoffset, NULL, NULL);
                    next_tvb = ber_tvb_new_subset_length(tvb, hoffset, eoffset - hoffset - (2 * ind_field));
                } else {
                    next_tvb = ber_tvb_new_subset_length(tvb, hoffset, eoffset - hoffset);
                }
#if 0
                if    ((eoffset-hoffset)>length_remaining) {
                    next_tvb = tvb_new_subset_remaining(tvb, hoffset);
                } else {
                }
#endif
#ifdef DEBUG_BER
{
const char *name;
header_field_info *hfinfo;
if (hf_id > 0) {
hfinfo = proto_registrar_get_nth(hf_id);
name = hfinfo->name;
} else {
name = "unnamed";
}
if (tvb_reported_length_remaining(next_tvb, 0) > 3) {
proto_tree_add_debug_text(tree, "SET dissect_ber_set(%s) calling subdissector offset:%d len:%d %02x:%02x:%02x\n", name, offset, tvb_reported_length_remaining(next_tvb, 0), tvb_get_guint8(next_tvb, 0), tvb_get_guint8(next_tvb, 1), tvb_get_guint8(next_tvb, 2));
} else {
proto_tree_add_debug_text(tree, "SET dissect_ber_set(%s) calling subdissector\n", name);
}
}
#endif
                imp_tag = FALSE;
                if ((cset->flags & BER_FLAGS_IMPLTAG))
                    imp_tag = TRUE;
                count = cset->func(imp_tag, next_tvb, 0, actx, tree, *cset->p_id);
                if (count || (first_pass && ((len == 0) || ((ind_field == 1) && (len == 2))))) {
                    if (set_idx < MAX_SET_ELEMENTS)
                        mandatory_fields &= ~(1 << set_idx);
                    offset = eoffset;
                    if (!(cset->flags & BER_FLAGS_NOOWNTAG) ) {
                        if (ind_field == 1) {
                            if (show_internal_ber_fields) {
                                proto_tree_add_item(tree, hf_ber_set_field_eoc, tvb, offset, count, ENC_NA);
                            }
                        }
                    }
                    break;
                }
            }
        }
        if (!cset->func) {
            cause = proto_tree_add_expert_format(
                tree, actx->pinfo, &ei_ber_unknown_field_set,
                tvb, identifier_offset, identifier_len,
                "BER Error: Unknown field in SET class:%s(%d) tag:%d",
                val_to_str_const(ber_class, ber_class_codes, "Unknown"),
                ber_class,
                tag);
            if (decode_unexpected) {
                proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);
                dissect_unknown_ber(actx->pinfo, tvb, hoffset, unknown_tree);
            }
            offset = eoffset;
        }
    }
    if (mandatory_fields) {
        for (set_idx = 0; (set_idx < MAX_SET_ELEMENTS) && (cset = &set[set_idx])->func; set_idx++) {
            if (mandatory_fields & (1U << set_idx)) {
                proto_tree_add_expert_format(
                    tree, actx->pinfo, &ei_ber_missing_field_set,
                    tvb, identifier_offset, identifier_len,
                    "BER Error: Missing field in SET class:%s(%d) tag:%d expected",
                    val_to_str_const(cset->ber_class, ber_class_codes, "Unknown"),
                    cset->ber_class,
                    cset->tag);
            }
        }
    }
    if (offset != end_offset) {
        tvb_ensure_bytes_exist(tvb, offset-2, 2);
        proto_tree_add_expert_format(
            tree, actx->pinfo, &ei_ber_error_length, tvb, offset-2, 2,
            "BER Error: SET is %d too many bytes int",
            offset - end_offset);
    }
    if (ind) {
        end_offset += 2;
        if (show_internal_ber_fields) {
            proto_tree_add_item(tree, hf_ber_set_eoc, tvb, end_offset-2, 2, ENC_NA);
        }
    }
    return end_offset;
}
