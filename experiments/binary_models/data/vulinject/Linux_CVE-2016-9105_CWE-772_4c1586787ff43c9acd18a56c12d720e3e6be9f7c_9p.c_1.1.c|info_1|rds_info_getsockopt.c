int rds_info_getsockopt(struct socket *sock, int optname, char __user *optval,
			int __user *optlen)
{
	struct rds_info_iterator iter;
	struct rds_info_lengths lens;
	unsigned int nr_pages = 0;
	unsigned int start;
	rds_info_func func;
	struct page **pages = NULL;
	int ret;
	int len;
	int total;
	if (get_user(len, optlen)) {
		ret = -EFAULT;
		goto out;
	}
	start = (unsigned int)optval;
	if (len < 0 || len > INT_MAX - PAGE_SIZE + 1 || start + len < start) {
		ret = -EINVAL;
		goto out;
	}
	if (len == 0)
		goto call_func;
	nr_pages = (PAGE_ALIGN(start + len) - (start & PAGE_MASK))
			>> PAGE_SHIFT;
	pages = kmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);
	if (!pages) {
		ret = -ENOMEM;
		goto out;
	}
	ret = pin_user_pages_fast(start, nr_pages, FOLL_WRITE, pages);
	if (ret != nr_pages) {
		if (ret > 0)
			nr_pages = ret;
		else
			nr_pages = 0;
		ret = -EAGAIN; 
		goto out;
	}
	rdsdebug("len %d nr_pages %lu\n", len, nr_pages);
call_func:
	func = rds_info_funcs[optname - RDS_INFO_FIRST];
	if (!func) {
		ret = -ENOPROTOOPT;
		goto out;
	}
	iter.pages = pages;
	iter.addr = NULL;
	iter.offset = start & (PAGE_SIZE - 1);
	func(sock, len, &iter, &lens);
	BUG_ON(lens.each == 0);
	total = lens.nr * lens.each;
	rds_info_iter_unmap(&iter);
	if (total > len) {
		len = total;
		ret = -ENOSPC;
	} else {
		len = total;
		ret = lens.each;
	}
	if (put_user(len, optlen))
		ret = -EFAULT;
out:
	if (pages)
	kfree(pages);
	return ret;
}
