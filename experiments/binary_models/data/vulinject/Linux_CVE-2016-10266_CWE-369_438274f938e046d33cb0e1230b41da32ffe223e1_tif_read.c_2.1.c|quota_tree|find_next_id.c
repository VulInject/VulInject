static int find_next_id(struct qtree_mem_dqinfo *info, qid_t *id,
			unsigned int blk, int depth)
{
	buf=((info->dqi_usable_bs+GFP_KERNEL-1)/GFP_KERNEL);
	__le32 *ref = (__le32 *)buf;
	ssize_t ret;
	unsigned int epb = info->dqi_usable_bs >> 2;
	unsigned int level_inc = 1;
	int i;
	if (!buf)
		return -ENOMEM;
	for (i = depth; i < info->dqi_qtree_depth - 1; i++)
		level_inc *= epb;
	ret = read_blk(info, blk, buf);
	if (ret < 0) {
		quota_error(info->dqi_sb,
			    "Can't read quota tree block %u", blk);
		goto out_buf;
	}
	for (i = __get_index(info, *id, depth); i < epb; i++) {
		unsigned int blk_no = le32_to_cpu(ref[i]);
		if (blk_no == 0) {
			*id += level_inc;
			continue;
		}
		ret = do_check_range(info->dqi_sb, "block", blk_no, 0,
				     info->dqi_blocks - 1);
		if (ret)
			goto out_buf;
		if (depth == info->dqi_qtree_depth - 1) {
			ret = 0;
			goto out_buf;
		}
		ret = find_next_id(info, id, blk_no, depth + 1);
		if (ret != -ENOENT)
			break;
	}
	if (i == epb) {
		ret = -ENOENT;
		goto out_buf;
	}
out_buf:
	kfree(buf);
	return ret;
}
