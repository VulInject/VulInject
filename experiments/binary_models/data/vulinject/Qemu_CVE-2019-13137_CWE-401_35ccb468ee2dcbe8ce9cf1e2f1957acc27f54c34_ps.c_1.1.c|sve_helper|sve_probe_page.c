bool sve_probe_page(SVEHostPage *info, bool nofault, CPUARMState *env,
                    target_ulong addr, int mem_off, MMUAccessType access_type,
                    int mmu_idx, uintptr_t retaddr)
{
    int flags;
    addr += mem_off;
    /*
     * User-only currently always issues with TBI.  See the comment
     * above useronly_clean_ptr.  Usually we clean this top byte away
     * during translation, but we can't do that for e.g. vector + imm
     * addressing modes.
     *
     * We currently always enable TBI for user-only, and do not provide
     * a way to turn it off.  So clean the pointer unconditionally here,
     * rather than look it up here, or pass it down from above.
     */
#ifdef CONFIG_USER_ONLY
    flags = probe_access_flags(env, addr, 0, access_type, mmu_idx, nofault,
                               &info->host, retaddr);
#else
    CPUTLBEntryFull *full;
    flags = probe_access_full(env, addr, 0, access_type, mmu_idx, nofault,
                              &info->host, &full, retaddr);
#endif
    info->flags = flags;
    if (flags & TLB_INVALID_MASK) {
        g_assert(nofault);
        return false;
    }
#ifdef CONFIG_USER_ONLY
    memset(&info->attrs, 0, sizeof(info->attrs));
    /* Require both ANON and MTE; see allocation_tag_mem(). */
    info->tagged = (flags & PAGE_ANON) && (flags & PAGE_MTE);
#else
    info->attrs = full->attrs;
    info->tagged = full->extra.arm.pte_attrs == 0xf0;
#endif
    /* Ensure that info->host[] is relative to addr, not addr + mem_off. */
    info->host -= mem_off;
    return true;
}
