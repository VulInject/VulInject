dissect_finger(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
    void *data)
{
    proto_item           *ti, *expert_ti;
    proto_tree           *finger_tree;
    conversation_t       *conversation;
    finger_transaction_t *finger_trans;
    gboolean              is_query;
    guint                 len;
    struct tcpinfo       *tcpinfo = (struct tcpinfo*)data;
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "FINGER");
    if (pinfo->destport == FINGER_PORT) {
        is_query = TRUE;
        col_set_str(pinfo->cinfo, COL_INFO, "Query");
    } else {
        is_query = FALSE;
        col_set_str(pinfo->cinfo, COL_INFO, "Response");
    }
    conversation = find_or_create_conversation(pinfo);
    finger_trans = (finger_transaction_t *)conversation_get_proto_data(conversation, proto_finger);
    if (finger_trans == NULL) {
        finger_trans = wmem_new0(wmem_file_scope(), finger_transaction_t);
        conversation_add_proto_data(conversation, proto_finger, finger_trans);
    }
    len = tvb_reported_length(tvb);
    if (!PINFO_FD_VISITED(pinfo)) {
        if (pinfo->can_desegment) {
            if (is_query) {
                if ((len < 2) || (tvb_memeql(tvb, len - 2, (const guint8*)"\r\n", 2))) {
                    pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;
                    pinfo->desegment_offset = 0;
                    return -1;
                } else {
                    finger_trans->req_frame = pinfo->num;
                    finger_trans->req_time = pinfo->abs_ts;
                }
            } else if (!(tcpinfo && (IS_TH_FIN(tcpinfo->flags) || tcpinfo->is_reassembled))) {
                pinfo->desegment_len = DESEGMENT_UNTIL_FIN;
                pinfo->desegment_offset = 0;
                return -1;
            }
        }
    } else if (is_query && (finger_trans->req_frame == 0)) {
        finger_trans->req_frame = pinfo->num;
        finger_trans->req_time = pinfo->abs_ts;
    }
    if (!is_query && (finger_trans->rep_frame == 0)) {
        finger_trans->rep_frame = pinfo->num;
    }
    ti = proto_tree_add_protocol_format(tree, proto_finger, tvb, 0, -1,
        "FINGER: %s", is_query ? "Query" : "Response");
    finger_tree = proto_item_add_subtree(ti, ett_finger);
    if (is_query) {
        expert_ti = proto_tree_add_item(finger_tree, hf_finger_query, tvb, 0, -1, ENC_ASCII);
        if ((len < 2) || (tvb_memeql(tvb, len - 2, (const guint8*)"\r\n", 2))) {
            expert_add_info(pinfo, expert_ti, &ei_finger_nocrlf);
        }
	if (tree)
            ti = proto_tree_add_uint(finger_tree, hf_finger_response_in,
                tvb, 0, 0, finger_trans->rep_frame);
            proto_item_set_generated(ti);
        }
    } else if (tree && finger_trans->rep_frame) {
