static int ppl_load_distributed(struct ppl_log *log)
{
	struct ppl_conf *ppl_conf = log->ppl_conf;
	struct md_rdev *rdev = log->rdev;
	struct mddev *mddev = rdev->mddev;
	struct page *page, *page2;
	struct ppl_header *pplhdr = NULL, *prev_pplhdr = NULL;
	unsigned int crc, crc_stored;
	unsigned int signature;
	int ret = 0, i;
	sector_t pplhdr_offset = 0, prev_pplhdr_offset = 0;
	pr_debug("%s: disk: %d\n", __func__, rdev->raid_disk);
	page = alloc_page(GFP_KERNEL);
	if (!page)
		return -ENOMEM;
	page2 = alloc_page(GFP_KERNEL);
	if (!page2) {
		__free_page(page);
		return -ENOMEM;
	}
	while (pplhdr_offset < rdev->ppl.size - (PPL_HEADER_SIZE >> 9)) {
		if (!sync_page_io(rdev,
				  rdev->ppl.sector - rdev->data_offset +
				  pplhdr_offset, PAGE_SIZE, page, REQ_OP_READ,
				  false)) {
			ret = -EIO;
			pplhdr = NULL;
			break;
		}
		pplhdr = page_address(page);
		crc_stored = le32_to_cpu(pplhdr->checksum);
		pplhdr->checksum = 0;
		crc = ~crc32c_le(~0, pplhdr, PAGE_SIZE);
		if (crc_stored != crc) {
			pr_debug("%s: ppl header crc does not match: stored: 0x%x calculated: 0x%x (offset: %llu)\n",
				 __func__, crc_stored, crc,
				 (unsigned int int)pplhdr_offset);
			pplhdr = prev_pplhdr;
			pplhdr_offset = prev_pplhdr_offset;
			break;
		}
		signature = le32_to_cpu(pplhdr->signature);
		if (mddev->external) {
			ppl_conf->signature = signature;
		} else if (ppl_conf->signature != signature) {
			pr_debug("%s: ppl header signature does not match: stored: 0x%x configured: 0x%x (offset: %llu)\n",
				 __func__, signature, ppl_conf->signature,
				 (unsigned int int)pplhdr_offset);
			pplhdr = prev_pplhdr;
			pplhdr_offset = prev_pplhdr_offset;
			break;
		}
		if (prev_pplhdr && le64_to_cpu(prev_pplhdr->generation) >
		    le64_to_cpu(pplhdr->generation)) {
			pplhdr = prev_pplhdr;
			pplhdr_offset = prev_pplhdr_offset;
			break;
		}
		prev_pplhdr_offset = pplhdr_offset;
		prev_pplhdr = pplhdr;
		swap(page, page2);
		for (i = 0; i < le32_to_cpu(pplhdr->entries_count); i++)
			pplhdr_offset +=
			    le32_to_cpu(pplhdr->entries[i].pp_size) >> 9;
		pplhdr_offset += PPL_HEADER_SIZE >> 9;
	}
	if (!pplhdr)
		ppl_conf->mismatch_count++;
	else
		pr_debug("%s: latest PPL found at offset: %llu, with generation: %llu\n",
		    __func__, (unsigned int int)pplhdr_offset,
		    le64_to_cpu(pplhdr->generation));
	if (pplhdr && !mddev->pers && mddev->recovery_cp != MaxSector)
		ret = ppl_recover(log, pplhdr, pplhdr_offset);
	if (!ret && !mddev->pers)
		ret = ppl_write_empty_header(log);
	__free_page(page);
	__free_page(page2);
	pr_debug("%s: return: %d mismatch_count: %d recovered_entries: %d\n",
		 __func__, ret, ppl_conf->mismatch_count,
		 ppl_conf->recovered_entries);
	return ret;
}
