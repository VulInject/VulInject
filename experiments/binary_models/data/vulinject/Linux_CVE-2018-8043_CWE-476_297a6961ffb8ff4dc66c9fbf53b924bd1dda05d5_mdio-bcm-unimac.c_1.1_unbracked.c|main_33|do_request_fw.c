static int do_request_fw(struct b43legacy_wldev *dev,
			 const char *name,
			 const struct firmware **fw, bool async)
{
	char path[sizeof(modparam_fwpostfix) + 32];
	struct b43legacy_fw_header *hdr;
	unsigned int size;
	snprintf(path, ARRAY_SIZE(path),
		 "b43legacy%s/%s.fw",
		 modparam_fwpostfix, name);
	b43legacyinfo(dev->wl, "Loading firmware %s\n", path);
	if (async) {
		init_completion(&dev->fw_load_complete);
		err = request_firmware_nowait(THIS_MODULE, 1, path,
					      dev->dev->dev, GFP_KERNEL,
					      dev, b43legacy_fw_cb);
		if (err) {
			b43legacyerr(dev->wl, "Unable to load firmware\n");
			return err;
		}
		wait_for_completion(&dev->fw_load_complete);
		if (!dev->fwp)
			err = -EINVAL;
		*fw = dev->fwp;
	} else {
		err = request_firmware(fw, path, dev->dev->dev);
	}
	if (err) {
		b43legacyerr(dev->wl, "Firmware file \"%s\" not found "
		       "or load failed.\n", path);
		return err;
	}
	if ((*fw)->size < sizeof(struct b43legacy_fw_header))
		goto err_format;
	hdr = (struct b43legacy_fw_header *)((*fw)->data);
	switch (hdr->type) {
	case B43legacy_FW_TYPE_UCODE:
	case B43legacy_FW_TYPE_PCM:
		size = be32_to_cpu(hdr->size);
		if (size != (*fw)->size - sizeof(struct b43legacy_fw_header))
			goto err_format;
		fallthrough;
	case B43legacy_FW_TYPE_IV:
		if (hdr->ver != 1)
			goto err_format;
		break;
	default:
		goto err_format;
	}
	return err;
err_format:
	b43legacyerr(dev->wl, "Firmware file \"%s\" format error.\n", path);
	return -EPROTO;
}
