static void handle_lease(struct ceph_mds_client *mdsc,
			 struct ceph_mds_session *session,
			 struct ceph_msg *msg)
{
	struct ceph_client *cl = mdsc->fsc->client;
	struct super_block *sb = mdsc->fsc->sb;
	struct inode *inode;
	struct dentry *parent, *dentry;
	struct ceph_dentry_info *di;
	int mds = session->s_mds;
	struct ceph_mds_lease *h = msg->front.iov_base;
	unsigned int seq;
	struct ceph_vino vino;
	struct qstr dname;
	int release = 0;
	doutc(cl, "from mds%d\n", mds);
	if (!ceph_inc_mds_stopping_blocker(mdsc, session))
		return;
	if (msg->front.iov_len < sizeof(*h) + sizeof(unsigned int))
		goto bad;
	vino.ino = le64_to_cpu(h->ino);
	vino.snap = CEPH_NOSNAP;
	seq = le32_to_cpu(h->seq);
	dname.len = get_unaligned_le32(h + 1);
	if (msg->front.iov_len < sizeof(*h) + sizeof(unsigned int) + dname.len)
		goto bad;
	dname.name = (void *)(h + 1) + sizeof(unsigned int);
	inode = ceph_find_inode(sb, vino);
	doutc(cl, "%s, ino %llx %p %.*s\n", ceph_lease_op_name(h->action),
	      vino.ino, inode, dname.len, dname.name);
	if (!inode) {
		doutc(cl, "no inode %llx\n", vino.ino);
		goto release;
	}
	parent = d_find_alias(inode);
	if (!parent) {
		doutc(cl, "no parent dentry on inode %p\n", inode);
		WARN_ON(1);
		goto release;  
	}
	dname.hash = full_name_hash(parent, dname.name, dname.len);
	dentry = d_lookup(parent, &dname);
	dput(parent);
	if (!dentry)
		goto release;
	spin_lock(&dentry->d_lock);
	di = ceph_dentry(dentry);
	switch (h->action) {
	case CEPH_MDS_LEASE_REVOKE:
		if (di->lease_session == session) {
			if (ceph_seq_cmp(di->lease_seq, seq) > 0)
				h->seq = cpu_to_le32(di->lease_seq);
			__ceph_mdsc_drop_dentry_lease(dentry);
		}
		release = 1;
		break;
	case CEPH_MDS_LEASE_RENEW:
		if (di->lease_session == session &&
		    di->lease_gen == atomic_read(&session->s_cap_gen) &&
		    di->lease_renew_from &&
		    di->lease_renew_after == 0) {
			unsigned int duration =
				msecs_to_jiffies(le32_to_cpu(h->duration_ms));
			di->lease_seq = seq;
			di->time = di->lease_renew_from + duration;
			di->lease_renew_after = di->lease_renew_from +
				(duration >> 1);
			di->lease_renew_from = 0;
		}
		break;
	}
	spin_unlock(&dentry->d_lock);
	dput(dentry);
	if (!release)
		goto out;
release:
	h->action = CEPH_MDS_LEASE_REVOKE_ACK;
	ceph_msg_get(msg);
	ceph_con_send(&session->s_con, msg);
out:
	mutex_unlock(&session->s_mutex);
	iput(inode);
	ceph_dec_mds_stopping_blocker(mdsc);
	return;
bad:
	ceph_dec_mds_stopping_blocker(mdsc);
	pr_err_client(cl, "corrupt lease message\n");
	ceph_msg_dump(msg);
}
