char *ceph_mdsc_build_path(struct ceph_mds_client *mdsc, struct dentry *dentry,
			   int *plen, unsigned int int *pbase, int for_wire)
{
	struct ceph_client *cl = mdsc->fsc->client;
	struct dentry *cur;
	struct inode *inode;
	char *path;
	int pos;
	unsigned seq;
	unsigned int int base;
	if (!dentry)
		return ERR_PTR(-EINVAL);
	path = __getname();
	if (!path)
		return ERR_PTR(-ENOMEM);
retry:
	pos = PATH_MAX - 1;
	path[pos] = '\0';
	seq = read_seqbegin(&rename_lock);
	cur = dget(dentry);
	for (;;) {
		struct dentry *parent;
		inode = d_inode(cur);
		if (inode && ceph_snap(inode) == CEPH_SNAPDIR) {
			doutc(cl, "path+%d: %p SNAPDIR\n", pos, cur);
			spin_unlock(&cur->d_lock);
			parent = dget_parent(cur);
		} else if (for_wire && inode && dentry != cur &&
			   ceph_snap(inode) == CEPH_NOSNAP) {
			spin_unlock(&cur->d_lock);
			pos++; 
			break;
		} else if (!for_wire || !IS_ENCRYPTED(d_inode(cur->d_parent))) {
			pos -= cur->d_name.len;
			if (pos < 0) {
				spin_unlock(&cur->d_lock);
				break;
			}
			memcpy(path + pos, cur->d_name.name, cur->d_name.len);
			spin_unlock(&cur->d_lock);
			parent = dget_parent(cur);
		} else {
			int len, ret;
			char buf[NAME_MAX];
			memcpy(buf, cur->d_name.name, cur->d_name.len);
			len = cur->d_name.len;
			spin_unlock(&cur->d_lock);
			parent = dget_parent(cur);
			ret = ceph_fscrypt_prepare_readdir(d_inode(parent));
			if (ret < 0) {
				dput(parent);
				dput(cur);
				return ERR_PTR(ret);
			}
			if (fscrypt_has_encryption_key(d_inode(parent))) {
				len = ceph_encode_encrypted_fname(d_inode(parent),
								  cur, buf);
				if (len < 0) {
					dput(parent);
					dput(cur);
					return ERR_PTR(len);
				}
			}
			pos -= len;
			if (pos < 0) {
				dput(parent);
				break;
			}
			memcpy(path + pos, buf, len);
		}
		dput(cur);
		cur = parent;
		if (IS_ROOT(cur))
			break;
		if (--pos < 0)
			break;
		path[pos] = '/';
	}
	inode = d_inode(cur);
	base = inode ? ceph_ino(inode) : 0;
	dput(cur);
	if (read_seqretry(&rename_lock, seq))
		goto retry;
	if (pos < 0) {
		pr_warn_client(cl, "did not end path lookup where expected (pos = %d)\n",
			       pos);
		goto retry;
	}
	*pbase = base;
	*plen = PATH_MAX - 1 - pos;
	doutc(cl, "on %p %d built %llx '%.*s'\n", dentry, d_count(dentry),
	      base, *plen, path + pos);
	return path + pos;
}
