static int parse_line_ios(unsigned char* packet, unsigned* offset, char* line, int status, time_t *pkt_time, unsigned int *pkt_usec)
{
	char** parts;
	char** part;
	unsigned int value;
	size_t size;
	if (strlen(line) <= 1) {
		if (status == CISCODUMP_PARSER_IN_PACKET)
			return CISCODUMP_PARSER_END_PACKET;
		else
			return status;
	}
	parts = g_regex_split_simple(
		"^(\\d{2}:\\d{2}:\\d{2}).(\\d+) (\\w+) (\\w+ \\d+ \\d+) :",
		line, G_REGEX_CASELESS, 0);
	if (parts && *(parts+1)) {
		char* cp;
		struct tm tm;
		char* d1 = g_strdup_printf("%s %s %s", *(parts+1), *(parts+3), *(parts+4));
		char* d2 = g_strdup_printf("%s %s", *(parts+1), *(parts+4));
		memset(&tm, 0x0, sizeof(struct tm));
		cp = ws_strptime_p(d1, "%H:%M:%S %Z %b %d %Y", &tm);
		if (!cp || (*cp != '\0')) {
			cp = ws_strptime_p(d2, "%H:%M:%S %b %d %Y", &tm);
			if (!cp || (*cp != '\0')) {
				time_t t;
				struct tm *tm2;
				t = time(0);
				tm2 = localtime(&t);
				memcpy(&tm, tm2, sizeof(struct tm));
			}
		}
		ws_strtou32(*(parts+2), NULL, pkt_usec);
		*pkt_usec *= 1000;
		*pkt_time = mktime(&tm);
		g_strfreev(parts);
		return CISCODUMP_PARSER_IN_HEADER;
	}
	g_strfreev(parts);
	parts = g_regex_split_simple(
		"^[\\dA-F]{8,8}:\\s+([\\dA-F]{2,8})\\s+([\\dA-F]{2,8}){0,1}\\s+([\\dA-F]{2,8}){0,1}\\s+([\\dA-F]{2,8}){0,1}.*",
		line, G_REGEX_CASELESS, 0);
	part = parts;
	if (*part && *(part+1)) {
		part++;
		while(*part) {
			if (strlen(*part) > 1) {
				ws_hexstrtou32(*part, NULL, &value);
				size = strlen(*part) / 2;
				memcpy(packet + *offset, &value, size);
				*offset += (unsigned int)size;
			}
			part++;
		}
	}
	g_strfreev(parts);
	return CISCODUMP_PARSER_IN_PACKET;
}
