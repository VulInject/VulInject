static RList *r_core_asm_back_disassemble(RCore *core, ut64 addr, int len, ut64 max_hit_count, ut8 disassmble_each_addr, ut32 extra_padding) {
	RList *hits;
	ut8 *buf = NULL;
	ut8 max_invalid_b4_exit = 4,
		last_num_invalid = 0;
	int current_instr_len = 0;
	ut64 current_instr_addr = addr,
		current_buf_pos = 0,
		next_buf_pos = len;
	RCoreAsmHit dummy_value;
	ut32 hit_count = 0;
	if (disassmble_each_addr) {
		return r_core_asm_back_disassemble_all(core, addr, len, max_hit_count, extra_padding+1);
	}
	hits = r_core_asm_hit_list_new ();
	buf = malloc (len + extra_padding);
	if (!hits || !buf) {
		if (hits) {
			free (hits);
		}
		free (buf);
		return NULL;
	}
	if (!r_io_read_at (core->io, (addr + extra_padding) - len, buf, len + extra_padding)) {
		r_list_purge (hits);
		free (hits);
		free (buf);
		return NULL;
	}
	memset (&dummy_value, 0, sizeof (RCoreAsmHit));
	current_buf_pos = len - extra_padding - 1;
	next_buf_pos = len + extra_padding - 1;
	current_instr_addr = addr - 1;
	do {
		RAnalOp op;
		if (r_cons_is_breaked ()) {
			break;
		}
		r_asm_set_pc (core->rasm, current_instr_addr);
		current_instr_len = next_buf_pos - current_buf_pos;
		current_instr_len = r_asm_disassemble (core->rasm, &op, buf+current_buf_pos, current_instr_len);
		IFDBG {
			ut32 byte_cnt =  current_instr_len ? current_instr_len : 1;
			eprintf("current_instr_addr: 0x%"PFMT64x", current_buf_pos: 0x%"PFMT64x", current_instr_len: %d \n", current_instr_addr, current_buf_pos, current_instr_len);
			ut8 *hex_str = (ut8*)r_hex_bin2strdup(buf+current_buf_pos, byte_cnt);
			eprintf ("==== current_instr_bytes: %s ",hex_str);
			if (current_instr_len > 0) {
				eprintf ("op.buf_asm: %s\n", op.mnemonic);
			} else {
				eprintf ("op.buf_asm: <invalid>\n");
			}
			free (hex_str);
		}
		if (current_instr_len == 0 || strstr (op.mnemonic, "invalid")) {
			if (current_instr_len == 0) {
				current_instr_len = 1;
			}
			add_hit_to_sorted_hits(hits, current_instr_addr, current_instr_len,  false);
			hit_count ++;
			last_num_invalid ++;
		} else if (current_buf_pos + current_instr_len == next_buf_pos) {
			ut32 purge_results = 0;
			ut8 is_valid = true;
			IFDBG eprintf(" handling underlap case: current_instr_addr: 0x%"PFMT64x".\n", current_instr_addr);
			purge_results =  prune_hits_in_addr_range(hits, current_instr_addr, current_instr_len,  true);
			if (purge_results) {
				handle_forward_disassemble(core, hits, buf, len, current_buf_pos+current_instr_len, current_instr_addr+current_instr_len, addr);
				hit_count = r_list_length(hits);
			}
			add_hit_to_sorted_hits(hits, current_instr_addr, current_instr_len, is_valid);
			hit_count ++;
			next_buf_pos = current_buf_pos;
			last_num_invalid = 0;
		} else if (current_buf_pos + current_instr_len < next_buf_pos) {
			ut32 purge_results = 0;
			ut8 is_valid = true;
			purge_results =  prune_hits_in_addr_range(hits, current_instr_addr, current_instr_len,  true);
			add_hit_to_sorted_hits(hits, current_instr_addr, current_instr_len, is_valid);
			if (hit_count < purge_results) {
				hit_count = 0; 
			} else {
				hit_count -= purge_results;
			}
			next_buf_pos = current_buf_pos;
			handle_forward_disassemble(core, hits, buf, len - extra_padding, current_buf_pos+current_instr_len, current_instr_addr+current_instr_len, addr);
			hit_count = r_list_length(hits);
			last_num_invalid = 0;
		} else if (current_buf_pos + current_instr_len > next_buf_pos) {
			next_buf_pos = current_buf_pos;
			hit_count = r_list_length (hits);
			last_num_invalid = 0;
		}
		IFDBG eprintf(" current_instr_addr: 0x%"PFMT64x" current_instr_len: %d next_instr_addr: 0x%04"PFMT64x"\n",
			current_instr_addr, current_instr_len, next_buf_pos);
		IFDBG eprintf(" hit count: %d \n", hit_count );
		current_instr_addr -= 1;
		current_buf_pos -= 1;
		r_asm_op_fini (&op);
		if (hit_count >= max_hit_count &&
			(last_num_invalid >= max_invalid_b4_exit || last_num_invalid == 0)) {
			break;
		}
	} while (((int) current_buf_pos >= 0) && (int)(len - current_buf_pos) >= 0);
	r_asm_set_pc (core->rasm, addr);
	free (buf);
	return hits;
}
