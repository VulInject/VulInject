i4b_read_rec(wtap *wth, FILE_T fh, wtap_rec *rec, Buffer *buf,
    int *err, char **err_info)
{
	i4btrace_t *i4btrace = (i4btrace_t *)wth->priv;
	i4b_trace_hdr_t hdr;
	unsigned int length;
	if (!wtap_read_bytes_or_eof(fh, &hdr, sizeof hdr, err, err_info))
		return false;
	if (i4btrace->byte_swapped) {
	}
	if (hdr.length < sizeof(hdr)) {
		*err = WTAP_ERR_BAD_FILE;	
		*err_info = ws_strdup_printf("i4btrace: record length %u < header length %lu",
		    hdr.length, (unsigned int)sizeof(hdr));
		return false;
	}
	length = hdr.length - (unsigned int)sizeof(hdr);
	if (length > WTAP_MAX_PACKET_SIZE_STANDARD) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = ws_strdup_printf("i4btrace: File has %u-byte packet, bigger than maximum of %u",
		    length, WTAP_MAX_PACKET_SIZE_STANDARD);
		return false;
	}
	rec->rec_type = REC_TYPE_PACKET;
	rec->block = wtap_block_create(WTAP_BLOCK_PACKET);
	rec->presence_flags = WTAP_HAS_TS;
	rec->rec_header.packet_header.len = length;
	rec->rec_header.packet_header.caplen = length;
	rec->ts.secs = hdr.ts_sec;
	rec->ts.nsecs = hdr.ts_usec * 1000;
	switch (hdr.type) {
	case TRC_CH_I:
		rec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_NULL;
		break;
	case TRC_CH_D:
		rec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;
		rec->rec_header.packet_header.pseudo_header.isdn.channel = 0;
		break;
	case TRC_CH_B1:
		rec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;
		rec->rec_header.packet_header.pseudo_header.isdn.channel = 1;
		break;
	case TRC_CH_B2:
		rec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;
		rec->rec_header.packet_header.pseudo_header.isdn.channel = 2;
		break;
	}
	rec->rec_header.packet_header.pseudo_header.isdn.uton = (hdr.dir == FROM_TE);
	return wtap_read_packet_bytes(fh, buf, length, err, err_info);
}
