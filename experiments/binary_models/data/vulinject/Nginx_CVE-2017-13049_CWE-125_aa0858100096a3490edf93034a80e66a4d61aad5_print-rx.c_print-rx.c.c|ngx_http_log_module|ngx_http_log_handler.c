ngx_http_log_handler(ngx_http_request_t *r)
{
    u_char                   *line, *p;
    size_t                    len, size;
    ssize_t                   n;
    ngx_str_t                 val;
    ngx_uint_t                i, l;
    ngx_http_log_t           *log;
    ngx_http_log_op_t        *op;
    ngx_http_log_buf_t       *buffer;
    ngx_http_log_loc_conf_t  *lcf;
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   "http log handler");
    lcf = ngx_http_get_module_loc_conf(r, ngx_http_log_module);
    if (lcf->off) {
        return NGX_OK;
    }
    log = lcf->logs->elts;
    for (l = 0; l < lcf->logs->nelts; l++) {
        if (log[l].filter) {
            if (ngx_http_complex_value(r, log[l].filter, &val) != NGX_OK) {
                return NGX_ERROR;
            }
            if (val.len == 0 || (val.len == 1 && val.data[0] == '0')) {
                continue;
            }
        }
        if (ngx_time() == log[l].disk_full_time) {
            continue;
        }
        ngx_http_script_flush_no_cacheable_variables(r, log[l].format->flushes);
        len = 0;
        op = log[l].format->ops->elts;
        for (i = 0; i < log[l].format->ops->nelts; i++) {
            if (op[i].len == 0) {
                len += op[i].getlen(r, op[i].data);
            } else {
                len += op[i].len;
            }
        }
        if (log[l].syslog_peer) {
            len += sizeof("<255>Jan 01 00:00:00 ") - 1
                   + ngx_cycle->hostname.len + 1
                   + log[l].syslog_peer->tag.len + 2;
            goto alloc_line;
        }
        len += NGX_LINEFEED_SIZE;
        buffer = log[l].file ? log[l].file->data : NULL;
        if (buffer) {
            if (len > (size_t) (buffer->last - buffer->pos)) {
                ngx_http_log_write(r, &log[l], buffer->start,
                                   buffer->pos - buffer->start);
                buffer->pos = buffer->start;
            }
            if (len <= (size_t) (buffer->last - buffer->pos)) {
                p = buffer->pos;
                if (buffer->event && p == buffer->start) {
                    ngx_add_timer(buffer->event, buffer->flush);
                }
                for (i = 0; i < log[l].format->ops->nelts; i++) {
                    p = op[i].run(r, p, &op[i]);
                }
                buffer->pos = p;
                continue;
            }
            if (buffer->event && buffer->event->timer_set) {
                ngx_del_timer(buffer->event);
            }
        }
    alloc_line:
        line = ngx_pnalloc(r->pool, len);
        if (line == NULL) {
            return NGX_ERROR;
        }
        p = line;
        if (log[l].syslog_peer) {
            p = ngx_syslog_add_header(log[l].syslog_peer, line);
        }
        for (i = 0; i < log[l].format->ops->nelts; i++) {
            p = op[i].run(r, p, &op[i]);
        }
        if (log[l].syslog_peer) {
            size = p - line;
            n = ngx_syslog_send(log[l].syslog_peer, line, size);
            if (n < 0) {
                ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,
                              "send() to syslog failed");
            } else if ((size_t) n != size) {
                ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,
                              "send() to syslog has written only %z of %uz",
                              n, size);
            }
            continue;
        }
        ngx_linefeed(p);
        ngx_http_log_write(r, &log[l], line, p - line);
    }
    return NGX_OK;
}
