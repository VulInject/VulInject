static void resize_buffer(VTermScreen *screen, int bufidx, int new_rows, int new_cols, int active, VTermStateFields *statefields)
{
  int old_rows = screen->rows;
  int old_cols = screen->cols;
  ScreenCell *old_buffer = screen->buffers[bufidx];
  VTermLineInfo *old_lineinfo = statefields->lineinfos[bufidx];
  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);
  VTermLineInfo *new_lineinfo = vterm_allocator_malloc(screen->vt, sizeof(new_lineinfo[0]) * new_rows);
  int old_row = old_rows - 1;
  int new_row = new_rows - 1;
  VTermPos old_cursor = statefields->pos;
  VTermPos new_cursor = { -1, -1 };
#ifdef DEBUG_REFLOW
  fprintf(stderr, "Resizing from %dx%d to %dx%d; cursor was at (%d,%d)\n",
      old_cols, old_rows, new_cols, new_rows, old_cursor.col, old_cursor.row);
#endif
  int final_blank_row = new_rows;
  while(old_row >= 0) {
    int old_row_end = old_row;
    while(REFLOW && old_lineinfo && old_row >= 0 && old_lineinfo[old_row].continuation)
      old_row--;
    int old_row_start = old_row;
    int width = 0;
    for(int row = old_row_start; row <= old_row_end; row++) {
      if(REFLOW && row < (old_rows - 1) && old_lineinfo[row + 1].continuation)
        width += old_cols;
      else
        width += line_popcount(old_buffer, row, old_rows, old_cols);
    }
    if(final_blank_row == (new_row + 1) && width == 0)
      final_blank_row = new_row;
    int new_height = REFLOW
      ? width ? (width + new_cols - 1) / new_cols : 1
      : 1;
    int new_row_end = new_row;
    int new_row_start = new_row - new_height + 1;
    old_row = old_row_start;
    int old_col = 0;
    int spare_rows = new_rows - final_blank_row;
    if(new_row_start < 0 && 
        spare_rows >= 0 && 
        (!active || new_cursor.row == -1 || (new_cursor.row - new_row_start) < new_rows))
    {
      int downwards = -new_row_start;
      if(downwards > spare_rows)
        downwards = spare_rows;
      int rowcount = new_rows - downwards;
#ifdef DEBUG_REFLOW
      fprintf(stderr, "  scroll %d rows +%d downwards\n", rowcount, downwards);
#endif
      memmove(&new_buffer[downwards * new_cols], &new_buffer[0],   rowcount * new_cols * sizeof(ScreenCell));
      memmove(&new_lineinfo[downwards],          &new_lineinfo[0], rowcount            * sizeof(new_lineinfo[0]));
      new_row += downwards;
      new_row_start += downwards;
      new_row_end += downwards;
      if(new_cursor.row >= 0)
        new_cursor.row += downwards;
      final_blank_row += downwards;
    }
#ifdef DEBUG_REFLOW
    fprintf(stderr, "  rows [%d..%d] <- [%d..%d] width=%d\n",
        new_row_start, new_row_end, old_row_start, old_row_end, width);
#endif
    if(new_row_start < 0) {
      if(old_row_start <= old_cursor.row && old_cursor.row < old_row_end) {
        new_cursor.row = 0;
        new_cursor.col = old_cursor.col;
        if(new_cursor.col >= new_cols)
          new_cursor.col = new_cols-1;
      }
      break;
    }
    for(new_row = new_row_start, old_row = old_row_start; new_row <= new_row_end; new_row++) {
      int count = width >= new_cols ? new_cols : width;
      width -= count;
      int new_col = 0;
      while(count) {
        new_buffer[new_row * new_cols + new_col] = old_buffer[old_row * old_cols + old_col];
        if(old_cursor.row == old_row && old_cursor.col == old_col)
          new_cursor.row = new_row, new_cursor.col = new_col;
        old_col++;
        if(old_col == old_cols) {
          old_row++;
          if(!REFLOW) {
            new_col++;
            break;
          }
          old_col = 0;
        }
        new_col++;
        count--;
      }
      if(old_cursor.row == old_row && old_cursor.col >= old_col) {
        new_cursor.row = new_row, new_cursor.col = (old_cursor.col - old_col + new_col);
        if(new_cursor.col >= new_cols)
          new_cursor.col = new_cols-1;
      }
      while(new_col < new_cols) {
        clearcell(screen, &new_buffer[new_row * new_cols + new_col]);
        new_col++;
      }
      new_lineinfo[new_row].continuation = (new_row > new_row_start);
    }
    old_row = old_row_start - 1;
    new_row = new_row_start - 1;
  }
  if(old_cursor.row <= old_row) {
    new_cursor.row = 0, new_cursor.col = old_cursor.col;
    if(new_cursor.col >= new_cols)
      new_cursor.col = new_cols-1;
  }
  if(active && (new_cursor.row == -1 || new_cursor.col == -1)) {
    if (new_cursor.row < 0)
      new_cursor.row = 0;
    if (new_cursor.col < 0)
      new_cursor.col = 0;
  }
  if(old_row >= 0 && bufidx == BUFIDX_PRIMARY) {
    if(screen->callbacks && screen->callbacks->sb_pushline)
      for(int row = 0; row <= old_row; row++)
    if(active)
      statefields->pos.row -= (old_row + 1);
  }
  if(new_row >= 0 && bufidx == BUFIDX_PRIMARY &&
      screen->callbacks && screen->callbacks->sb_popline) {
    while(new_row >= 0) {
      VTermPos pos;
      if(!(screen->callbacks->sb_popline(old_cols, screen->sb_buffer, screen->cbdata)))
        break;
      pos.row = new_row;
      for(pos.col = 0; pos.col < old_cols && pos.col < new_cols; pos.col += screen->sb_buffer[pos.col].width) {
        VTermScreenCell *src = &screen->sb_buffer[pos.col];
        ScreenCell *dst = &new_buffer[pos.row * new_cols + pos.col];
        for(int i = 0; i < VTERM_MAX_CHARS_PER_CELL; i++) {
          dst->chars[i] = src->chars[i];
          if(!src->chars[i])
            break;
        }
        dst->pen.bold      = src->attrs.bold;
        dst->pen.underline = src->attrs.underline;
        dst->pen.italic    = src->attrs.italic;
        dst->pen.blink     = src->attrs.blink;
        dst->pen.reverse   = src->attrs.reverse ^ screen->global_reverse;
        dst->pen.conceal   = src->attrs.conceal;
        dst->pen.strike    = src->attrs.strike;
        dst->pen.font      = src->attrs.font;
        dst->pen.small     = src->attrs.small;
        dst->pen.baseline  = src->attrs.baseline;
        dst->pen.fg = src->fg;
        dst->pen.bg = src->bg;
        if(src->width == 2 && pos.col < (new_cols-1))
          (dst + 1)->chars[0] = (unsigned int) -1;
      }
      for( ; pos.col < new_cols; pos.col++)
        clearcell(screen, &new_buffer[pos.row * new_cols + pos.col]);
      new_row--;
      if(active)
        statefields->pos.row++;
    }
  }
  if(new_row >= 0) {
    int moverows = new_rows - new_row - 1;
    memmove(&new_buffer[0], &new_buffer[(new_row + 1) * new_cols], moverows * new_cols * sizeof(ScreenCell));
    memmove(&new_lineinfo[0], &new_lineinfo[new_row + 1], moverows * sizeof(new_lineinfo[0]));
    new_cursor.row -= (new_row + 1);
    for(new_row = moverows; new_row < new_rows; new_row++) {
      for(int col = 0; col < new_cols; col++)
        clearcell(screen, &new_buffer[new_row * new_cols + col]);
      new_lineinfo[new_row] = (VTermLineInfo){ 0 };
    }
  }
  vterm_allocator_free(screen->vt, old_buffer);
  screen->buffers[bufidx] = new_buffer;
  vterm_allocator_free(screen->vt, old_lineinfo);
  statefields->lineinfos[bufidx] = new_lineinfo;
  if(active)
    statefields->pos = new_cursor;
  return;
}
