static int flush_packet(AVFormatContext *format_context, AVPacket *packet)
{
    APNGMuxContext *apng = format_context->priv_data;
    AVIOContext *io_context = format_context->pb;
    AVStream *codec_stream = format_context->streams[0];
    uint8_t *side_data = NULL;
    size_t side_data_size;
    side_data = av_packet_get_side_data(apng->prev_packet, AV_PKT_DATA_NEW_EXTRADATA, &side_data_size);
    if (side_data_size) {
        av_freep(&apng->extra_data);
        apng->extra_data = av_mallocz(side_data_size + AV_INPUT_BUFFER_PADDING_SIZE);
        if (!apng->extra_data)
            return AVERROR(ENOMEM);
        apng->extra_data_size = side_data_size;
        memcpy(apng->extra_data, side_data, apng->extra_data_size);
    }
    if (apng->frame_number == 0 && !packet) {
        const uint8_t *existing_acTL_chunk;
        const uint8_t *existing_fcTL_chunk;
        av_log(format_context, AV_LOG_INFO, "Only a single frame so saving as a normal PNG.\n");
        // Write normal PNG headers without acTL chunk
        existing_acTL_chunk = apng_find_chunk(MKBETAG('a', 'c', 'T', 'L'), apng->extra_data, apng->extra_data_size);
        if (existing_acTL_chunk) {
            const uint8_t *chunk_after_acTL = existing_acTL_chunk + AV_RB32(existing_acTL_chunk) + 12;
            avio_write(io_context, apng->extra_data, existing_acTL_chunk - apng->extra_data);
            avio_write(io_context, chunk_after_acTL, apng->extra_data + apng->extra_data_size - chunk_after_acTL);
        } else {
            avio_write(io_context, apng->extra_data, apng->extra_data_size);
        }
        // Write frame data without fcTL chunk
        existing_fcTL_chunk = apng_find_chunk(MKBETAG('f', 'c', 'T', 'L'), apng->prev_packet->data, apng->prev_packet->size);
        if (existing_fcTL_chunk) {
            const uint8_t *chunk_after_fcTL = existing_fcTL_chunk + AV_RB32(existing_fcTL_chunk) + 12;
            avio_write(io_context, apng->prev_packet->data, existing_fcTL_chunk - apng->prev_packet->data);
            avio_write(io_context, chunk_after_fcTL, apng->prev_packet->data + apng->prev_packet->size - chunk_after_fcTL);
        } else {
            avio_write(io_context, apng->prev_packet->data, apng->prev_packet->size);
        }
    } else {
        const uint8_t *data, *data_end;
        const uint8_t *existing_fcTL_chunk;
        if (apng->frame_number == 0) {
            const uint8_t *existing_acTL_chunk;
            // Write normal PNG headers
            avio_write(io_context, apng->extra_data, apng->extra_data_size);
            existing_acTL_chunk = apng_find_chunk(MKBETAG('a', 'c', 'T', 'L'), apng->extra_data, apng->extra_data_size);
            if (!existing_acTL_chunk) {
                uint8_t buf[8];
                // Write animation control header
                apng->acTL_offset = avio_tell(io_context);
                AV_WB32(buf, UINT_MAX); // number of frames (filled in later)
                AV_WB32(buf + 4, apng->plays);
                apng_write_chunk(io_context, MKBETAG('a', 'c', 'T', 'L'), buf, 8);
            }
        }
        data     = apng->prev_packet->data;
        data_end = data + apng->prev_packet->size;
        existing_fcTL_chunk = apng_find_chunk(MKBETAG('f', 'c', 'T', 'L'), apng->prev_packet->data, apng->prev_packet->size);
        if (existing_fcTL_chunk) {
            AVRational delay;
            if (AV_RB32(existing_fcTL_chunk) != APNG_FCTL_CHUNK_SIZE)
                return AVERROR_INVALIDDATA;
            existing_fcTL_chunk += 8;
            delay.num = AV_RB16(existing_fcTL_chunk + 20);
            delay.den = AV_RB16(existing_fcTL_chunk + 22);
            if (delay.num == 0 && delay.den == 0) {
                uint8_t new_fcTL_chunk[APNG_FCTL_CHUNK_SIZE];
                if (packet) {
                    int64_t delay_num_raw = (packet->dts - apng->prev_packet->dts) * codec_stream->time_base.num;
                    int64_t delay_den_raw = codec_stream->time_base.den;
                    if (!av_reduce(&delay.num, &delay.den, delay_num_raw, delay_den_raw, UINT16_MAX) &&
                        !apng->framerate_warned) {
                        av_log(format_context, AV_LOG_WARNING,
                               "Frame rate is too high or specified too precisely. Unable to copy losslessly.\n");
                        apng->framerate_warned = 1;
                    }
                } else if (apng->last_delay.num > 0) {
                    delay = apng->last_delay;
                } else {
                    delay = apng->prev_delay;
                }
                avio_write(io_context, data, (existing_fcTL_chunk - 8) - data);
                data = existing_fcTL_chunk + APNG_FCTL_CHUNK_SIZE + 4 /* CRC-32 */;
                // Update frame control header with new delay
                memcpy(new_fcTL_chunk, existing_fcTL_chunk, sizeof(new_fcTL_chunk));
                AV_WB16(new_fcTL_chunk + 20, delay.num);
                AV_WB16(new_fcTL_chunk + 22, delay.den);
                apng_write_chunk(io_context, MKBETAG('f', 'c', 'T', 'L'),
                                 new_fcTL_chunk, sizeof(new_fcTL_chunk));
            }
            apng->prev_delay = delay;
        }
        // Write frame data
        avio_write(io_context, data, data_end - data);
    }
    ++apng->frame_number;
    av_packet_unref(apng->prev_packet);
    if (packet)
        av_packet_ref(apng->prev_packet, packet);
    return 0;
}
