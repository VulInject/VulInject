glwthread_timedrecmutex_lock (glwthread_timedrecmutex_t *mutex)
{
  if (!mutex->guard.done)
    {
      if (InterlockedIncrement (&mutex->guard.started) == 0)
        {
          if (err != 0)
            {
              InterlockedDecrement (&mutex->guard.started);
              return err;
            }
        }
      else
        {
          InterlockedDecrement (&mutex->guard.started);
          while (!mutex->guard.done)
            Sleep (0);
        }
    }
  {
    DWORD self = GetCurrentThreadId ();
    if (mutex->owner != self)
      {
        EnterCriticalSection (&mutex->lock);
        mutex->owner = self;
      }
    if (++(mutex->depth) == 0) 
      {
        mutex->depth--;
        return EAGAIN;
      }
  }
  return 0;
}
