cf_save_records(capture_file *cf, const char *fname, guint save_format,
        wtap_compression_type compression_type,
        gboolean discard_comments, gboolean dont_reopen)
{
    gchar           *err_info;
    gchar           *fname_new = NULL;
    wtap_dumper     *pdh;
    frame_data      *fdata;
    addrinfo_lists_t *addr_lists;
    guint            framenum;
    int              err;
#ifdef _WIN32
    gchar           *display_basename;
#endif
    enum {
        SAVE_WITH_MOVE,
        SAVE_WITH_COPY,
        SAVE_WITH_WTAP
    }                    how_to_save;
    save_callback_args_t callback_args;
    callback_args.export = FALSE;
    bool needs_reload = false;
    if (cf->read_lock) {
        ws_warning("cf_save_records(\"%s\") while the file is being read, potential crash ahead", fname);
    }
    cf_callback_invoke(cf_cb_file_save_started, (gpointer)fname);
    addr_lists = get_addrinfo_list();
    if (save_format == cf->cd_t && compression_type == cf->compression_type
            && !discard_comments && !cf->unsaved_changes
            && (wtap_addrinfo_list_empty(addr_lists) || wtap_file_type_subtype_supports_block(save_format, WTAP_BLOCK_NAME_RESOLUTION) == BLOCK_NOT_SUPPORTED)) {
        if (cf->is_tempfile) {
#ifndef _WIN32
            if (ws_rename(cf->filename, fname) == 0) {
                how_to_save = SAVE_WITH_MOVE;
            } else {
                if (errno == EXDEV) {
                    how_to_save = SAVE_WITH_COPY;
                } else {
                    cf_rename_failure_alert_box(fname, errno);
                    goto fail;
                }
            }
#else
            how_to_save = SAVE_WITH_COPY;
#endif
        } else {
            how_to_save = SAVE_WITH_COPY;
        }
        if (how_to_save == SAVE_WITH_COPY) {
            if (file_exists(fname)) {
                fname_new = ws_strdup_printf("%s~", fname);
                if (!copy_file_binary_mode(cf->filename, fname_new))
                    goto fail;
            } else {
                if (!copy_file_binary_mode(cf->filename, fname))
                    goto fail;
            }
        }
    } else {
        wtap_dump_params params;
        int encap;
        how_to_save = SAVE_WITH_WTAP;
        wtap_dump_params_init(&params, cf->provider.wth);
        encap = wtap_dump_required_file_encap_type(cf->linktypes);
        params.encap = encap;
        params.snaplen = cf->snap;
        if (file_exists(fname)) {
            fname_new = ws_strdup_printf("%s~", fname);
            pdh = wtap_dump_open(fname_new, save_format, compression_type, &params,
                    &err, &err_info);
        } else {
            pdh = wtap_dump_open(fname, save_format, compression_type, &params,
                    &err, &err_info);
        }
        g_free(params.idb_inf);
        params.idb_inf = NULL;
        if (pdh == NULL) {
            cfile_dump_open_failure_alert_box(fname, err, err_info, save_format);
            goto fail;
        }
        wtap_dump_set_addrinfo_list(pdh, addr_lists);
        callback_args.pdh = pdh;
        callback_args.fname = fname;
        callback_args.file_type = save_format;
        switch (process_specified_records(cf, NULL, "Saving", "packets",
                    TRUE, save_record, &callback_args, TRUE)) {
            case PSP_FINISHED:
                break;
            case PSP_STOPPED:
                wtap_dump_close(pdh, NULL, &err, &err_info);
                if (fname_new != NULL)
                cf_callback_invoke(cf_cb_file_save_stopped, NULL);
                wtap_dump_params_cleanup(&params);
                return CF_WRITE_ABORTED;
            case PSP_FAILED:
                if (fname_new != NULL)
                    ws_unlink(fname_new);
                wtap_dump_close(pdh, NULL, &err, &err_info);
                wtap_dump_params_cleanup(&params);
                goto fail;
        }
        if (!wtap_dump_close(pdh, &needs_reload, &err, &err_info)) {
            cfile_close_failure_alert_box(fname, err, err_info);
            wtap_dump_params_cleanup(&params);
            goto fail;
        }
        wtap_dump_params_cleanup(&params);
    }
    if (fname_new != NULL) {
#ifdef _WIN32
        wtap_fdclose(cf->provider.wth);
#endif
        if (ws_rename(fname_new, fname) == -1) {
            cf_rename_failure_alert_box(fname, errno);
#ifdef _WIN32
            if (!wtap_fdreopen(cf->provider.wth, cf->filename, &err)) {
                display_basename = g_filename_display_basename(cf->filename);
                simple_error_message_box(
                        file_open_error_message(err, FALSE), display_basename);
                g_free(display_basename);
            }
#endif
            goto fail;
        }
        g_free(fname_new);
    }
    if (cf->is_tempfile && how_to_save != SAVE_WITH_MOVE) {
        ws_unlink(cf->filename);
    }
    cf_callback_invoke(cf_cb_file_save_finished, NULL);
    cf->unsaved_changes = FALSE;
    if (!dont_reopen) {
        switch (how_to_save) {
            case SAVE_WITH_MOVE:
                g_free(cf->filename);
                cf->filename = g_strdup(fname);
                cf->is_tempfile = FALSE;
                cf_callback_invoke(cf_cb_file_fast_save_finished, cf);
                break;
            case SAVE_WITH_COPY:
                wtap_fdclose(cf->provider.wth);
                if (!wtap_fdreopen(cf->provider.wth, fname, &err)) {
                    cfile_open_failure_alert_box(fname, err, err_info);
                    cf_close(cf);
                } else {
                    g_free(cf->filename);
                    cf->filename = g_strdup(fname);
                    cf->is_tempfile = FALSE;
                }
                cf_callback_invoke(cf_cb_file_fast_save_finished, cf);
                break;
            case SAVE_WITH_WTAP:
                cf->open_type = WTAP_TYPE_AUTO;
                if(needs_reload) {
                    if (cf_open(cf, fname, WTAP_TYPE_AUTO, FALSE, &err) == CF_OK) {
                        if (cf_read(cf, TRUE) != CF_READ_OK) {
                            cf_close(cf);
                        }
                    }
                }
                else {
                    if (rescan_file(cf, fname, FALSE) != CF_READ_OK) {
                        cf_close(cf);
                    }
                }
                break;
        }
        if (discard_comments) {
            wtap_write_shb_comment(cf->provider.wth, NULL);
            for (framenum = 1; framenum <= cf->count; framenum++) {
                fdata = frame_data_sequence_find(cf->provider.frames, framenum);
                fdata->has_modified_block = FALSE;
            }
            if (cf->provider.frames_modified_blocks) {
                g_tree_destroy(cf->provider.frames_modified_blocks);
                cf->provider.frames_modified_blocks = NULL;
            }
            cf->packet_comment_count = 0;
        }
    }
    return CF_WRITE_OK;
fail:
    if (fname_new != NULL) {
        ws_unlink(fname_new);
        g_free(fname_new);
    }
    cf_callback_invoke(cf_cb_file_save_failed, NULL);
    return CF_WRITE_ERROR;
}
