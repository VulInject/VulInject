static void __init srmmu_nocache_init(void)
{
	void *srmmu_nocache_bitmap;
	unsigned int bitmap_bits;
	pgd_t *pgd;
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *pte;
	unsigned int paddr, vaddr;
	unsigned int pteval;
	bitmap_bits = srmmu_nocache_size >> SRMMU_NOCACHE_BITMAP_SHIFT;
					    SRMMU_NOCACHE_ALIGN_MAX);
	if (!srmmu_nocache_pool)
		panic("%s: Failed to allocate %lu bytes align=0x%x\n",
		      __func__, srmmu_nocache_size, SRMMU_NOCACHE_ALIGN_MAX);
	memset(srmmu_nocache_pool, 0, srmmu_nocache_size);
	srmmu_nocache_bitmap =
		memblock_alloc(BITS_TO_LONGS(bitmap_bits) * sizeof(int),
			       SMP_CACHE_BYTES);
	if (!srmmu_nocache_bitmap)
		panic("%s: Failed to allocate %zu bytes\n", __func__,
		      BITS_TO_LONGS(bitmap_bits) * sizeof(int));
	bit_map_init(&srmmu_nocache_map, srmmu_nocache_bitmap, bitmap_bits);
	srmmu_swapper_pg_dir = __srmmu_get_nocache(SRMMU_PGD_TABLE_SIZE, SRMMU_PGD_TABLE_SIZE);
	memset(__nocache_fix(srmmu_swapper_pg_dir), 0, SRMMU_PGD_TABLE_SIZE);
	init_mm.pgd = srmmu_swapper_pg_dir;
	srmmu_early_allocate_ptable_skeleton(SRMMU_NOCACHE_VADDR, srmmu_nocache_end);
	paddr = __pa((unsigned int)srmmu_nocache_pool);
	vaddr = SRMMU_NOCACHE_VADDR;
	while (vaddr < srmmu_nocache_end) {
		pgd = pgd_offset_k(vaddr);
		p4d = p4d_offset(pgd, vaddr);
		pud = pud_offset(p4d, vaddr);
		pmd = pmd_offset(__nocache_fix(pud), vaddr);
		pte = pte_offset_kernel(__nocache_fix(pmd), vaddr);
		pteval = ((paddr >> 4) | SRMMU_ET_PTE | SRMMU_PRIV);
		if (srmmu_cache_pagetables)
			pteval |= SRMMU_CACHE;
		set_pte(__nocache_fix(pte), __pte(pteval));
		vaddr += PAGE_SIZE;
		paddr += PAGE_SIZE;
	}
	flush_cache_all();
	flush_tlb_all();
}
