static int convert_do_copy(ImgConvertState *s)
{
    int ret, i, n;
    int64_t sector_num = 0;
    /* Check whether we have zero initialisation or can get it efficiently */
    if (!s->has_zero_init && s->target_is_new && s->min_sparse &&
        !s->target_has_backing) {
        bdrv_graph_rdlock_main_loop();
        s->has_zero_init = bdrv_has_zero_init(blk_bs(s->target));
        bdrv_graph_rdunlock_main_loop();
    }
    /* Allocate buffer for copied data. For compressed images, only one cluster
     * can be copied at a time. */
    if (s->compressed) {
        if (s->cluster_sectors <= 0 || s->cluster_sectors > s->buf_sectors) {
            error_report("invalid cluster size");
            return -EINVAL;
        }
        s->buf_sectors = s->cluster_sectors;
    }
    while (sector_num < s->total_sectors) {
        bdrv_graph_rdlock_main_loop();
        n = convert_iteration_sectors(s, sector_num);
        bdrv_graph_rdunlock_main_loop();
        if (n < 0) {
            return n;
        }
        if (s->status == BLK_DATA || (!s->min_sparse && s->status == BLK_ZERO))
        {
            s->allocated_sectors += n;
        }
        sector_num += n;
    }
    /* Do the copy */
    s->sector_next_status = 0;
    s->ret = -EINPROGRESS;
    for (i = 0; i < s->num_coroutines; i++) {
        s->co[i] = qemu_coroutine_create(convert_co_do_copy, s);
        s->wait_sector_num[i] = -1;
        qemu_coroutine_enter(s->co[i]);
    }
    while (s->running_coroutines) {
        main_loop_wait(false);
    }
    if (s->compressed && !s->ret) {
        /* signal EOF to align */
        ret = blk_pwrite_compressed(s->target, 0, 0, NULL);
        if (ret < 0) {
            return ret;
        }
    }
    return s->ret;
}
