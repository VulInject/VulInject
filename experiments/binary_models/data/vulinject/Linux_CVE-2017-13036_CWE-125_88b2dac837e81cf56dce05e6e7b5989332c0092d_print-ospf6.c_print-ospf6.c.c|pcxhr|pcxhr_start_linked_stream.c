static void pcxhr_start_linked_stream(struct pcxhr_mgr *mgr)
{
	int i, j, err;
	struct pcxhr_pipe *pipe;
	struct snd_pcxhr *chip;
	int capture_mask = 0;
	int playback_mask = 0;
#ifdef CONFIG_SND_DEBUG_VERBOSE
	ktime_t start_time, stop_time, diff_time;
	start_time = ktime_get();
	for (i = 0; i < mgr->num_cards; i++) {
		chip = mgr->chip[i];
		for (j = 0; j < chip->nb_streams_capt; j++) {
			if (pcxhr_stream_scheduled_get_pipe(&chip->capture_stream[j], &pipe))
				capture_mask |= (1 << pipe->first_audio);
		}
		for (j = 0; j < chip->nb_streams_play; j++) {
			if (pcxhr_stream_scheduled_get_pipe(&chip->playback_stream[j], &pipe)) {
				playback_mask |= (1 << pipe->first_audio);
				break;	
			}
		}
	}
	if (capture_mask == 0 && playback_mask == 0) {
		mutex_unlock(&mgr->setup_mutex);
		dev_err(&mgr->pci->dev, "%s : no pipes\n", __func__);
		return;
	}
	dev_dbg(&mgr->pci->dev, "%s : playback_mask=%x capture_mask=%x\n",
		    __func__, playback_mask, capture_mask);
	err = pcxhr_set_pipe_state(mgr,  playback_mask, capture_mask, 0);
	if (err) {
		mutex_unlock(&mgr->setup_mutex);
		dev_err(&mgr->pci->dev, "%s : "
			   "error stop pipes (P%x C%x)\n",
			   __func__, playback_mask, capture_mask);
		return;
	}
	for (i = 0; i < mgr->num_cards; i++) {
		struct pcxhr_stream *stream;
		chip = mgr->chip[i];
		for (j = 0; j < chip->nb_streams_capt; j++) {
			stream = &chip->capture_stream[j];
			if (pcxhr_stream_scheduled_get_pipe(stream, &pipe)) {
				err = pcxhr_set_format(stream);
				err = pcxhr_update_r_buffer(stream);
			}
		}
		for (j = 0; j < chip->nb_streams_play; j++) {
			stream = &chip->playback_stream[j];
			if (pcxhr_stream_scheduled_get_pipe(stream, &pipe)) {
				err = pcxhr_set_format(stream);
				err = pcxhr_update_r_buffer(stream);
			}
		}
	}
	for (i = 0; i < mgr->num_cards; i++) {
		struct pcxhr_stream *stream;
		chip = mgr->chip[i];
		for (j = 0; j < chip->nb_streams_capt; j++) {
			stream = &chip->capture_stream[j];
			if (pcxhr_stream_scheduled_get_pipe(stream, &pipe))
				err = pcxhr_set_stream_state(chip, stream);
		}
		for (j = 0; j < chip->nb_streams_play; j++) {
			stream = &chip->playback_stream[j];
			if (pcxhr_stream_scheduled_get_pipe(stream, &pipe))
				err = pcxhr_set_stream_state(chip, stream);
		}
	}
	err = pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 1);
	if (err) {
		mutex_unlock(&mgr->setup_mutex);
		dev_err(&mgr->pci->dev, "%s : "
			   "error start pipes (P%x C%x)\n",
			   __func__, playback_mask, capture_mask);
		return;
	}
	mutex_lock(&mgr->lock);
	for ( i =0; i < mgr->num_cards; i++) {
		struct pcxhr_stream *stream;
		chip = mgr->chip[i];
		for(j = 0; j < chip->nb_streams_capt; j++) {
			stream = &chip->capture_stream[j];
			if(stream->status == PCXHR_STREAM_STATUS_STARTED)
				stream->status = PCXHR_STREAM_STATUS_RUNNING;
		}
		for (j = 0; j < chip->nb_streams_play; j++) {
			stream = &chip->playback_stream[j];
			if (stream->status == PCXHR_STREAM_STATUS_STARTED) {
				stream->timer_period_frag += mgr->granularity;
				stream->status = PCXHR_STREAM_STATUS_RUNNING;
			}
		}
	}
	mutex_unlock(&mgr->lock);
	mutex_unlock(&mgr->setup_mutex);
#ifdef CONFIG_SND_DEBUG_VERBOSE
	stop_time = ktime_get();
	diff_time = ktime_sub(stop_time, start_time);
	dev_dbg(&mgr->pci->dev, "***TRIGGER START*** TIME = %ld (err = %x)\n",
		    (int)(ktime_to_ns(diff_time)), err);
#endif
}
