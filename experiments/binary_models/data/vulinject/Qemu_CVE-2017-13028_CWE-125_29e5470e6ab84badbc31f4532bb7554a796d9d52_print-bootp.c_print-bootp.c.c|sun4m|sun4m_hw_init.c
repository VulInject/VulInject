static void sun4m_hw_init(MachineState *machine)
{
    const struct sun4m_hwdef *hwdef = SUN4M_MACHINE_GET_CLASS(machine)->hwdef;
    DeviceState *slavio_intctl;
    unsigned int i;
    Nvram *nvram;
    qemu_irq *cpu_irqs[MAX_CPUS], slavio_irq[32], slavio_cpu_irq[MAX_CPUS];
    qemu_irq fdc_tc;
    unsigned long kernel_size;
    uint32_t initrd_size;
    DriveInfo *fd[MAX_FD];
    FWCfgState *fw_cfg;
    DeviceState *dev, *ms_kb_orgate, *serial_orgate;
    SysBusDevice *s;
    unsigned int smp_cpus = machine->smp.cpus;
    unsigned int max_cpus = machine->smp.max_cpus;
    HostMemoryBackend *ram_memdev = machine->memdev;
    NICInfo *nd = &nd_table[0];
    if (machine->ram_size > hwdef->max_mem) {
        error_report("Too much memory for this machine: %" PRId64 ","
                     " maximum %" PRId64,
                     machine->ram_size / MiB, hwdef->max_mem / MiB);
        exit(1);
    }
    /* init CPUs */
    for(i = 0; i < smp_cpus; i++) {
        cpu_devinit(machine->cpu_type, i, hwdef->slavio_base, &cpu_irqs[i]);
    }
    for (i = smp_cpus; i < MAX_CPUS; i++)
        cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);
    /* Create and map RAM frontend */
    dev = qdev_new("memory");
    object_property_set_link(OBJECT(dev), "memdev", OBJECT(ram_memdev), &error_fatal);
    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0);
    /* models without ECC don't trap when missing ram is accessed */
    if (!hwdef->ecc_base) {
        empty_slot_init("ecc", machine->ram_size,
                        hwdef->max_mem - machine->ram_size);
    }
    prom_init(hwdef->slavio_base, machine->firmware);
    slavio_intctl = slavio_intctl_init(hwdef->intctl_base,
                                       hwdef->intctl_base + 0x10000ULL,
                                       cpu_irqs);
    for (i = 0; i < 32; i++) {
        slavio_irq[i] = qdev_get_gpio_in(slavio_intctl, i);
    }
    for (i = 0; i < MAX_CPUS; i++) {
        slavio_cpu_irq[i] = qdev_get_gpio_in(slavio_intctl, 32 + i);
    }
    if (hwdef->idreg_base) {
    }
    if (hwdef->afx_base) {
        afx_init(hwdef->afx_base);
    }
    iommu_init(hwdef->iommu_base, hwdef->iommu_version, slavio_irq[30]);
    if (hwdef->iommu_pad_base) {
        /* On the real hardware (SS-5, LX) the MMU is not padded, but aliased.
           Software shouldn't use aliased addresses, neither should it crash
           when does. Using empty_slot instead of aliasing can help with
           debugging such accesses */
        empty_slot_init("iommu.alias",
                        hwdef->iommu_pad_base, hwdef->iommu_pad_len);
    }
    qemu_check_nic_model(nd, TYPE_LANCE);
    sparc32_dma_init(hwdef->dma_base,
                     hwdef->esp_base, slavio_irq[18],
                     hwdef->le_base, slavio_irq[16], nd);
    if (graphic_depth != 8 && graphic_depth != 24) {
        error_report("Unsupported depth: %d", graphic_depth);
        exit (1);
    }
    if (vga_interface_type != VGA_NONE) {
        if (vga_interface_type == VGA_CG3) {
            if (graphic_depth != 8) {
                error_report("Unsupported depth: %d", graphic_depth);
                exit(1);
            }
            if (!(graphic_width == 1024 && graphic_height == 768) &&
                !(graphic_width == 1152 && graphic_height == 900)) {
                error_report("Unsupported resolution: %d x %d", graphic_width,
                             graphic_height);
                exit(1);
            }
            /* sbus irq 5 */
            cg3_init(hwdef->tcx_base, slavio_irq[11], 0x00100000,
                     graphic_width, graphic_height, graphic_depth);
            vga_interface_created = true;
        } else {
            /* If no display specified, default to TCX */
            if (graphic_depth != 8 && graphic_depth != 24) {
                error_report("Unsupported depth: %d", graphic_depth);
                exit(1);
            }
            if (!(graphic_width == 1024 && graphic_height == 768)) {
                error_report("Unsupported resolution: %d x %d",
                             graphic_width, graphic_height);
                exit(1);
            }
            tcx_init(hwdef->tcx_base, slavio_irq[11], 0x00100000,
                     graphic_width, graphic_height, graphic_depth);
            vga_interface_created = true;
        }
    }
    for (i = 0; i < MAX_VSIMMS; i++) {
        /* vsimm registers probed by OBP */
        if (hwdef->vsimm[i].reg_base) {
            char *name = g_strdup_printf("vsimm[%d]", i);
            empty_slot_init(name, hwdef->vsimm[i].reg_base, 0x2000);
            g_free(name);
        }
    }
    if (hwdef->sx_base) {
        create_unimplemented_device("sun-sx", hwdef->sx_base, 0x2000);
    }
    dev = qdev_new("sysbus-m48t08");
    qdev_prop_set_int32(dev, "base-year", 1968);
    s = SYS_BUS_DEVICE(dev);
    sysbus_realize_and_unref(s, &error_fatal);
    sysbus_connect_irq(s, 0, slavio_irq[0]);
    sysbus_mmio_map(s, 0, hwdef->nvram_base);
    nvram = NVRAM(dev);
    slavio_timer_init_all(hwdef->counter_base, slavio_irq[19], slavio_cpu_irq, smp_cpus);
    /* Slavio TTYA (base+4, Linux ttyS0) is the first QEMU serial device
       Slavio TTYB (base+0, Linux ttyS1) is the second QEMU serial device */
    dev = qdev_new(TYPE_ESCC);
    qdev_prop_set_uint32(dev, "disabled", !machine->enable_graphics);
    qdev_prop_set_uint32(dev, "frequency", ESCC_CLOCK);
    qdev_prop_set_uint32(dev, "it_shift", 1);
    qdev_prop_set_chr(dev, "chrB", NULL);
    qdev_prop_set_chr(dev, "chrA", NULL);
    qdev_prop_set_uint32(dev, "chnBtype", escc_mouse);
    qdev_prop_set_uint32(dev, "chnAtype", escc_kbd);
    s = SYS_BUS_DEVICE(dev);
    sysbus_realize_and_unref(s, &error_fatal);
    sysbus_mmio_map(s, 0, hwdef->ms_kb_base);
    /* Logically OR both its IRQs together */
    ms_kb_orgate = DEVICE(object_new(TYPE_OR_IRQ));
    object_property_set_int(OBJECT(ms_kb_orgate), "num-lines", 2, &error_fatal);
    qdev_realize_and_unref(ms_kb_orgate, NULL, &error_fatal);
    sysbus_connect_irq(s, 0, qdev_get_gpio_in(ms_kb_orgate, 0));
    sysbus_connect_irq(s, 1, qdev_get_gpio_in(ms_kb_orgate, 1));
    qdev_connect_gpio_out(ms_kb_orgate, 0, slavio_irq[14]);
    dev = qdev_new(TYPE_ESCC);
    qdev_prop_set_uint32(dev, "disabled", 0);
    qdev_prop_set_uint32(dev, "frequency", ESCC_CLOCK);
    qdev_prop_set_uint32(dev, "it_shift", 1);
    qdev_prop_set_chr(dev, "chrB", serial_hd(1));
    qdev_prop_set_chr(dev, "chrA", serial_hd(0));
    qdev_prop_set_uint32(dev, "chnBtype", escc_serial);
    qdev_prop_set_uint32(dev, "chnAtype", escc_serial);
    s = SYS_BUS_DEVICE(dev);
    sysbus_realize_and_unref(s, &error_fatal);
    sysbus_mmio_map(s, 0, hwdef->serial_base);
    /* Logically OR both its IRQs together */
    serial_orgate = DEVICE(object_new(TYPE_OR_IRQ));
    object_property_set_int(OBJECT(serial_orgate), "num-lines", 2,
                            &error_fatal);
    qdev_realize_and_unref(serial_orgate, NULL, &error_fatal);
    sysbus_connect_irq(s, 0, qdev_get_gpio_in(serial_orgate, 0));
    sysbus_connect_irq(s, 1, qdev_get_gpio_in(serial_orgate, 1));
    qdev_connect_gpio_out(serial_orgate, 0, slavio_irq[15]);
    if (hwdef->apc_base) {
        apc_init(hwdef->apc_base, qemu_allocate_irq(cpu_halt_signal, NULL, 0));
    }
    if (hwdef->fd_base) {
        /* there is zero or one floppy drive */
        memset(fd, 0, sizeof(fd));
        fd[0] = drive_get(IF_FLOPPY, 0, 0);
        sun4m_fdctrl_init(slavio_irq[22], hwdef->fd_base, fd,
                          &fdc_tc);
    } else {
        fdc_tc = qemu_allocate_irq(dummy_fdc_tc, NULL, 0);
    }
    slavio_misc_init(hwdef->slavio_base, hwdef->aux1_base, hwdef->aux2_base,
                     slavio_irq[30], fdc_tc);
    if (hwdef->cs_base) {
        sysbus_create_simple("sun-CS4231", hwdef->cs_base,
                             slavio_irq[5]);
    }
    if (hwdef->dbri_base) {
        /* ISDN chip with attached CS4215 audio codec */
        /* prom space */
        create_unimplemented_device("sun-DBRI.prom",
                                    hwdef->dbri_base + 0x1000, 0x30);
        /* reg space */
        create_unimplemented_device("sun-DBRI",
                                    hwdef->dbri_base + 0x10000, 0x100);
    }
    if (hwdef->bpp_base) {
        /* parallel port */
        create_unimplemented_device("sun-bpp", hwdef->bpp_base, 0x20);
    }
    initrd_size = 0;
    kernel_size = sun4m_load_kernel(machine->kernel_filename,
                                    machine->initrd_filename,
                                    machine->ram_size, &initrd_size);
    nvram_init(nvram, (uint8_t *)&nd->macaddr, machine->kernel_cmdline,
               machine->boot_config.order, machine->ram_size, kernel_size,
               graphic_width, graphic_height, graphic_depth,
               hwdef->nvram_machine_id, "Sun4m");
    if (hwdef->ecc_base)
        ecc_init(hwdef->ecc_base, slavio_irq[28],
                 hwdef->ecc_version);
    dev = qdev_new(TYPE_FW_CFG_MEM);
    fw_cfg = FW_CFG(dev);
    qdev_prop_set_uint32(dev, "data_width", 1);
    qdev_prop_set_bit(dev, "dma_enabled", false);
    object_property_add_child(OBJECT(qdev_get_machine()), TYPE_FW_CFG,
                              OBJECT(fw_cfg));
    s = SYS_BUS_DEVICE(dev);
    sysbus_realize_and_unref(s, &error_fatal);
    sysbus_mmio_map(s, 0, CFG_ADDR);
    sysbus_mmio_map(s, 1, CFG_ADDR + 2);
    fw_cfg_add_i16(fw_cfg, FW_CFG_NB_CPUS, (uint16_t)smp_cpus);
    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)max_cpus);
    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)machine->ram_size);
    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);
    fw_cfg_add_i16(fw_cfg, FW_CFG_SUN4M_DEPTH, graphic_depth);
    fw_cfg_add_i16(fw_cfg, FW_CFG_SUN4M_WIDTH, graphic_width);
    fw_cfg_add_i16(fw_cfg, FW_CFG_SUN4M_HEIGHT, graphic_height);
    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);
    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);
    if (machine->kernel_cmdline) {
        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);
        pstrcpy_targphys("cmdline", CMDLINE_ADDR, TARGET_PAGE_SIZE,
                         machine->kernel_cmdline);
        fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, machine->kernel_cmdline);
        fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE,
                       strlen(machine->kernel_cmdline) + 1);
    } else {
        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);
        fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE, 0);
    }
    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);
    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);
    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, machine->boot_config.order[0]);
    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);
}
