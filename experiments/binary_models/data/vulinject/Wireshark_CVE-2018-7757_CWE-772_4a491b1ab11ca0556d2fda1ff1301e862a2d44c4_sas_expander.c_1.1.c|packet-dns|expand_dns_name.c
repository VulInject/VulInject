expand_dns_name(tvbuff_t *tvb, int offset, int max_len, int dns_data_offset,
    const gchar **name, gint* name_len)
{
  int     start_offset    = offset;
  gchar  *np;
  int     len             = -1;
  int     pointers_count  = 0;
  int     component_len;
  int     indir_offset;
  int     maxname;
  const int min_len = 1;        
  maxname = MAX_DNAME_LEN;
  np=(gchar *)wmem_alloc(wmem_packet_scope(), maxname);
  *name=np;
  (*name_len) = 0;
  for (;;) {
    if (max_len && offset - start_offset > max_len - 1) {
      break;
    }
    component_len = tvb_get_guint8(tvb, offset);
    offset++;
    if (component_len == 0) {
      break;
    }
    switch (component_len & 0xc0) {
      case 0x00:
        if (np != *name) {
          if (maxname > 0) {
            *np++ = '.';
            (*name_len)++;
            maxname--;
          }
        }
        else {
          maxname--;
        }
        while (component_len > 0) {
          if (max_len && offset - start_offset > max_len - 1) {
          }
          if (maxname > 0) {
            *np++ = tvb_get_guint8(tvb, offset);
            (*name_len)++;
            maxname--;
          }
          component_len--;
          offset++;
        }
        break;
      case 0x40:
        switch (component_len & 0x3f) {
          case 0x01:
          {
            int bit_count;
            int label_len;
            int print_len;
            bit_count = tvb_get_guint8(tvb, offset);
            offset++;
            label_len = (bit_count - 1) / 8 + 1;
            if (maxname > 0) {
              print_len = snprintf(np, maxname, "\\[x");
              if (print_len <= maxname) {
                np      += print_len;
                maxname -= print_len;
              } else {
                maxname = 0;
              }
            }
            while (label_len--) {
              if (maxname > 0) {
                print_len = snprintf(np, maxname, "%02x",
                                       tvb_get_guint8(tvb, offset));
                if (print_len <= maxname) {
                  np      += print_len;
                  maxname -= print_len;
                } else {
                  maxname = 0;
                }
              }
              offset++;
            }
            if (maxname > 0) {
              print_len = snprintf(np, maxname, "/%d]", bit_count);
              if (print_len <= maxname) {
                np      += print_len;
                maxname -= print_len;
              } else {
                maxname = 0;
              }
            }
          }
          break;
          default:
            *name="<Unknown extended label>";
            *name_len = (guint)strlen(*name);
            len = offset - start_offset;
            if (len < min_len) {
              THROW(ReportedBoundsError);
            }
            return len;
        }
        break;
      case 0x80:
        THROW(ReportedBoundsError);
        break;
      case 0xc0:
        indir_offset = dns_data_offset +
          (((component_len & ~0xc0) << 8) | tvb_get_guint8(tvb, offset));
        offset++;
        pointers_count++;
        if (len < 0) {
          len = offset - start_offset;
        }
        if (indir_offset == offset + 2 || pointers_count > MAX_DNAME_LEN) {
          *name="<Name contains a pointer that loops>";
          *name_len = (guint)strlen(*name);
          if (len < min_len) {
            THROW(ReportedBoundsError);
          }
          return len;
        }
        offset = indir_offset;
        break;   
    }
  }
  if (maxname > 0) {
    *np = '\0';
  }
  else {
    *name="<Name too int>";
    *name_len = (guint)strlen(*name);
  }
  if (len < 0) {
    len = offset - start_offset;
  }
  return len;
}
