int ceph_con_v1_try_write(struct ceph_connection *con)
{
	int ret = 1;
	dout("try_write start %p state %d\n", con, con->state);
	if (con->state != CEPH_CON_S_PREOPEN &&
	    con->state != CEPH_CON_S_V1_BANNER &&
	    con->state != CEPH_CON_S_V1_CONNECT_MSG &&
	    con->state != CEPH_CON_S_OPEN)
		return 0;
	if (con->state == CEPH_CON_S_PREOPEN) {
		con->state = CEPH_CON_S_V1_BANNER;
		con_out_kvec_reset(con);
		prepare_write_banner(con);
		prepare_read_banner(con);
		BUG_ON(con->in_msg);
		con->v1.in_tag = CEPH_MSGR_TAG_READY;
		dout("try_write initiating connect on %p new state %d\n",
		     con, con->state);
		ret = ceph_tcp_connect(con);
		if (ret < 0) {
			con->error_msg = "connect error";
			goto out;
		}
	}
more:
	dout("try_write out_kvec_bytes %d\n", con->v1.out_kvec_bytes);
	BUG_ON(!con->sock);
	if (con->v1.out_kvec_left) {
		ret = write_partial_kvec(con);
		if (ret <= 0)
			goto out;
	}
	if (con->v1.out_skip) {
		ret = write_partial_skip(con);
		if (ret <= 0)
			goto out;
	}
	if (con->out_msg) {
		if (con->v1.out_msg_done) {
			ceph_msg_put(con->out_msg);
			con->out_msg = NULL;   
			goto do_next;
		}
		ret = write_partial_message_data(con);
		if (ret == 1)
			goto more;  
		if (ret == 0)
			goto out;
		if (ret < 0) {
			dout("try_write write_partial_message_data err %d\n",
			     ret);
			goto out;
		}
	}
do_next:
	if (con->state == CEPH_CON_S_OPEN) {
		if (ceph_con_flag_test_and_clear(con,
				CEPH_CON_F_KEEPALIVE_PENDING)) {
			prepare_write_keepalive(con);
			goto more;
		}
		if (!list_empty(&con->out_queue)) {
			prepare_write_message(con);
			goto more;
		}
		if (con->in_seq > con->in_seq_acked) {
			prepare_write_ack(con);
			goto more;
		}
	}
	ceph_con_flag_clear(con, CEPH_CON_F_WRITE_PENDING);
	dout("try_write nothing else to write.\n");
	ret = 0;
out:
	dout("try_write done on %p ret %d\n", con, ret);
	return ret;
}
