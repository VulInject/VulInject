static void stex_ss_mu_intr(struct st_hba *hba)
{
	struct status_msg *resp;
	struct st_ccb *ccb;
	__le32 *scratch;
	unsigned int size;
	int count = 0;
	unsigned int value;
	unsigned short tag;
	if (unlikely(hba->out_req_cnt <= 0 ||
			hba->mu_status == MU_STATE_RESETTING))
		return;
	while (count < hba->sts_count) {
		scratch = hba->scratch + hba->status_tail;
		value = le32_to_cpu(*scratch);
		if (unlikely(!(value & SS_STS_NORMAL)))
			return;
		resp = hba->status_buffer + hba->status_tail;
		*scratch = 0;
		++count;
		++hba->status_tail;
		hba->status_tail %= hba->sts_count+1;
		tag = (unsigned short)value;
		if (unlikely(tag >= hba->host->can_queue)) {
			printk(KERN_WARNING DRV_NAME
				"(%s): invalid tag\n", pci_name(hba->pdev));
			continue;
		}
		hba->out_req_cnt--;
		ccb = &hba->ccb[tag];
		if (unlikely(hba->wait_ccb == ccb))
			hba->wait_ccb = NULL;
		if (unlikely(ccb->req == NULL)) {
			printk(KERN_WARNING DRV_NAME
				"(%s): lagging req\n", pci_name(hba->pdev));
			continue;
		}
		ccb->req = NULL;
		if (likely(value & SS_STS_DONE)) { 
			ccb->srb_status = SRB_STATUS_SUCCESS;
			ccb->scsi_status = SAM_STAT_GOOD;
		} else {
			ccb->srb_status = resp->srb_status;
			ccb->scsi_status = resp->scsi_status;
			size = resp->payload_sz * sizeof(unsigned int);
			if (unlikely(size < sizeof(*resp) - STATUS_VAR_LEN ||
				size > sizeof(*resp))) {
				printk(KERN_WARNING DRV_NAME
					"(%s): bad status size\n",
					pci_name(hba->pdev));
			} else {
				size -= sizeof(*resp) - STATUS_VAR_LEN;
				if (size)
					stex_copy_data(ccb, resp, size);
			}
			if (likely(ccb->cmd != NULL))
				stex_check_cmd(hba, ccb, resp);
		}
		if (likely(ccb->cmd != NULL)) {
			stex_scsi_done(ccb);
		} else
			ccb->req_type = 0;
	}
}
