ngx_quic_open_sockets(ngx_connection_t *c, ngx_quic_connection_t *qc,
    ngx_quic_header_t *pkt)
{
    ngx_quic_socket_t     *qsock, *tmp;
    ngx_quic_client_id_t  *cid;
    ngx_queue_init(&qc->free_sockets);
    ngx_queue_init(&qc->paths);
    ngx_queue_init(&qc->free_paths);
    ngx_queue_init(&qc->client_ids);
    ngx_queue_init(&qc->free_client_ids);
    qc->tp.original_dcid.len = pkt->odcid.len;
    qc->tp.original_dcid.data = ngx_pstrdup(c->pool, &pkt->odcid);
    if (qc->tp.original_dcid.data == NULL) {
        return NGX_ERROR;
    }
    qsock = ngx_quic_create_socket(c, qc);
    if (qsock == NULL) {
        return NGX_ERROR;
    }
    if (ngx_quic_listen(c, qc, qsock) != NGX_OK) {
        return NGX_ERROR;
    }
    qsock->used = 1;
    qc->tp.initial_scid.len = qsock->sid.len;
    qc->tp.initial_scid.data = ngx_pnalloc(c->pool, qsock->sid.len);
    if (qc->tp.initial_scid.data == NULL) {
        goto failed;
    }
    ngx_memcpy(qc->tp.initial_scid.data, qsock->sid.id, qsock->sid.len);
    c->udp = &qsock->udp;
    cid = ngx_quic_create_client_id(c, &pkt->scid, 0, NULL);
    if (cid == NULL) {
        goto failed;
    }
    qc->path = ngx_quic_new_path(c, c->sockaddr, c->socklen, cid);
    if (qc->path == NULL) {
        goto failed;
    }
    qc->path->tag = NGX_QUIC_PATH_ACTIVE;
    if (pkt->validated) {
        qc->path->validated = 1;
    }
    ngx_quic_path_dbg(c, "set active", qc->path);
    tmp = ngx_pcalloc(c->pool, sizeof(ngx_quic_socket_t));
    if (tmp == NULL) {
        goto failed;
    }
    tmp->sid.seqnum = NGX_QUIC_UNSET_PN; 
    ngx_memcpy(tmp->sid.id, pkt->dcid.data, pkt->dcid.len);
    tmp->sid.len = pkt->dcid.len;
    if (ngx_quic_listen(c, qc, tmp) != NGX_OK) {
        goto failed;
    }
    return NGX_OK;
failed:
    ngx_rbtree_delete(&c->listening->rbtree, &qsock->udp.node);
    c->udp = NULL;
    return NGX_ERROR;
}
