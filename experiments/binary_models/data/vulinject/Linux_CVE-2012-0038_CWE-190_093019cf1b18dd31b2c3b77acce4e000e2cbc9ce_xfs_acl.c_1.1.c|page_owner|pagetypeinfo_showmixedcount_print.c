void pagetypeinfo_showmixedcount_print(struct seq_file *m,
				       pg_data_t *pgdat, struct zone *zone)
{
	struct page *page;
	struct page_ext *page_ext;
	struct page_owner *page_owner;
	int pfn, block_end_pfn;
	unsigned int end_pfn = zone_end_pfn(zone);
	unsigned int count[MIGRATE_TYPES] = { 0, };
	int pageblock_mt, page_mt;
	int i;
	pfn = zone->zone_start_pfn;
	for (; pfn < end_pfn; ) {
		page = pfn_to_online_page(pfn);
		if (!page) {
			pfn = ALIGN(pfn + 1, MAX_ORDER_NR_PAGES);
			continue;
		}
		block_end_pfn = pageblock_end_pfn(pfn);
		block_end_pfn = min(block_end_pfn, end_pfn);
		pageblock_mt = get_pageblock_migratetype(page);
		for (; pfn < block_end_pfn; pfn++) {
			page = pfn_to_page(pfn);
			if (page_zone(page) != zone)
				continue;
			if (PageBuddy(page)) {
				unsigned int freepage_order;
				freepage_order = buddy_order_unsafe(page);
				if (freepage_order <= MAX_PAGE_ORDER)
					pfn += (1UL << freepage_order) - 1;
				continue;
			}
			if (PageReserved(page))
				continue;
			page_ext = page_ext_get(page);
			if (unlikely(!page_ext))
				continue;
			if (!test_bit(PAGE_EXT_OWNER_ALLOCATED, &page_ext->flags))
				goto ext_put_continue;
			page_owner = get_page_owner(page_ext);
			page_mt = gfp_migratetype(page_owner->gfp_mask);
			if (pageblock_mt != page_mt) {
				if (is_migrate_cma(pageblock_mt))
					count[MIGRATE_MOVABLE]++;
				else
					count[pageblock_mt]++;
				pfn = block_end_pfn;
				page_ext_put(page_ext);
				break;
			}
			pfn += (1UL << page_owner->order) - 1;
ext_put_continue:
			page_ext_put(page_ext);
		}
	}
	seq_printf(m, "Node %d, zone %8s ", pgdat->node_id, zone->name);
	for (i = 0; i < MIGRATE_TYPES; i++)
		seq_printf(m, "%12lu ", count[i]);
	seq_putc(m, '\n');
}
