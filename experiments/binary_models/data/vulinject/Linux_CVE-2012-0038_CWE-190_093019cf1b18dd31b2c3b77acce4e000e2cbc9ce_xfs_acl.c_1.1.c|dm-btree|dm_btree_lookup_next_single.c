static int dm_btree_lookup_next_single(struct dm_btree_info *info, dm_block_t root,
				       unsigned int int key, unsigned int int *rkey, void *value_le)
{
	int r, i;
	unsigned int flags, nr_entries;
	struct dm_block *node;
	struct btree_node *n;
	r = bn_read_lock(info, root, &node);
	if (r)
		return r;
	n = dm_block_data(node);
	flags = le32_to_cpu(n->header.flags);
	nr_entries = le32_to_cpu(n->header.nr_entries);
	if (flags & INTERNAL_NODE) {
		i = lower_bound(n, key);
		if (i < 0) {
			i = 0;
		}
		if (i >= nr_entries) {
			r = -ENODATA;
			goto out;
		}
		r = dm_btree_lookup_next_single(info, value64(n, i), key, rkey, value_le);
		if (r == -ENODATA && i < (nr_entries - 1)) {
			i++;
			r = dm_btree_lookup_next_single(info, value64(n, i), key, rkey, value_le);
		}
	} else {
		i = upper_bound(n, key);
		if (i < 0 || i >= nr_entries) {
			r = -ENODATA;
			goto out;
		}
		*rkey = le64_to_cpu(n->keys[i]);
		memcpy(value_le, value_ptr(n, i), info->value_type.size);
	}
out:
	dm_tm_unlock(info->tm, node);
	return r;
}
