void process_receive(struct s_smc *smc)
{
	int i ;
	int n ;
	int frag_count ;		
	int used_frags ;		
	struct s_smt_rx_queue *queue ;	
	struct s_smt_fp_rxd volatile *r ;	
	struct s_smt_fp_rxd volatile *rxd ;	
	u_long rbctrl ;			
	u_long rfsw ;			
	u_short rx_used ;
	u_char far *virt ;
	char far *data ;
	SMbuf *mb ;
	u_char fc ;			
	int len ;			
	smc->os.hwm.detec_count = 0 ;
	queue = smc->hw.fp.rx[QUEUE_R1] ;
	NDD_TRACE("RHxB",0,0,0) ;
	for ( ; ; ) {
		r = queue->rx_curr_get ;
		rx_used = queue->rx_used ;
		frag_count = 0 ;
#ifdef	USE_BREAK_ISR
		if (smc->os.hwm.leave_isr) {
			goto rx_end ;
		}
#endif
#ifdef	NDIS_OS2
		if (offDepth) {
			smc->os.hwm.rx_break = 1 ;
			goto rx_end ;
		}
		smc->os.hwm.rx_break = 0 ;
#endif
#ifdef	ODI2
		if (smc->os.hwm.rx_break) {
			goto rx_end ;
		}
#endif
		n = 0 ;
		do {
			DB_RX(5, "Check RxD %p for OWN and EOF", r);
			rbctrl = le32_to_cpu(CR_READ(r->rxd_rbctrl));
			if (rbctrl & BMU_OWN) {
				NDD_TRACE("RHxE",r,rfsw,rbctrl) ;
				DB_RX(4, "End of RxDs");
				goto rx_end ;
			}
			if (!rx_used) {
				SK_BREAK() ;
				SMT_PANIC(smc,HWM_E0009,HWM_E0009_MSG) ;
				smc->hw.hw_state = STOPPED ;
				mac_drv_clear_rx_queue(smc) ;
				smc->hw.hw_state = STARTED ;
				mac_drv_fill_rxd(smc) ;
				smc->os.hwm.detec_count = 0 ;
				goto rx_end ;
			}
			rfsw = le32_to_cpu(r->rxd_rfsw) ;
			if ((rbctrl & BMU_STF) != ((rbctrl & BMU_ST_BUF) <<5)) {
				SK_BREAK() ;
				rfsw = 0 ;
				if (frag_count) {
					break ;
				}
			}
			n += rbctrl & 0xffff ;
			r = r->rxd_next ;
			frag_count++ ;
			rx_used-- ;
		} while (!(rbctrl & BMU_EOF)) ;
		used_frags = frag_count ;
		DB_RX(5, "EOF set in RxD, used_frags = %d", used_frags);
		DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
		while (rx_used && !(r->rxd_rbctrl & cpu_to_le32(BMU_ST_BUF))) {
			DB_RX(5, "Check STF bit in %p", r);
			r = r->rxd_next ;
			DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
			frag_count++ ;
			rx_used-- ;
		}
		DB_RX(5, "STF bit found");
		rxd = queue->rx_curr_get ;
		queue->rx_curr_get = r ;
		queue->rx_free += frag_count ;
		queue->rx_used = rx_used ;
		rxd->rxd_rbctrl &= cpu_to_le32(~BMU_STF) ;
		for (r=rxd, i=frag_count ; i ; r=r->rxd_next, i--){
			DB_RX(5, "dma_complete for RxD %p", r);
			dma_complete(smc,(union s_fp_descr volatile *)r,DMA_WR);
		}
		smc->hw.fp.err_stats.err_valid++ ;
		smc->mib.m[MAC0].fddiMACCopied_Ct++ ;
		len = (rfsw & RD_LENGTH) - 4 ;
		DB_RX(4, "frame length = %d", len);
		if (rfsw & (RX_MSRABT|RX_FS_E|RX_FS_CRC|RX_FS_IMPL)){
			if (rfsw & RD_S_MSRABT) {
				DB_RX(2, "Frame aborted by the FORMAC");
				smc->hw.fp.err_stats.err_abort++ ;
			}
			if (rfsw & RD_S_SEAC2) {
				DB_RX(2, "E-Indicator set");
				smc->hw.fp.err_stats.err_e_indicator++ ;
			}
			if (rfsw & RD_S_SFRMERR) {
				DB_RX(2, "CRC error");
				smc->hw.fp.err_stats.err_crc++ ;
			}
			if (rfsw & RX_FS_IMPL) {
				DB_RX(2, "Implementer frame");
				smc->hw.fp.err_stats.err_imp_frame++ ;
			}
			goto abort_frame ;
		}
		if (len > FDDI_RAW_MTU-4) {
			DB_RX(2, "Frame too int error");
			smc->hw.fp.err_stats.err_too_long++ ;
			goto abort_frame ;
		}
		if (len <= 4) {
			DB_RX(2, "Frame length = 0");
			goto abort_frame ;
		}
		if (len != (n-4)) {
			DB_RX(4, "BMU: rx len differs: [%d:%d]", len, n);
			smc->os.hwm.rx_len_error++ ;
			goto abort_frame ;
		}
		virt = (u_char far *) rxd->rxd_virt ;
		DB_RX(2, "FC = %x", *virt);
		if (virt[12] == MA[5] &&
		    virt[11] == MA[4] &&
		    virt[10] == MA[3] &&
		    virt[9] == MA[2] &&
		    virt[8] == MA[1] &&
		    (virt[7] & ~GROUP_ADDR_BIT) == MA[0]) {
			goto abort_frame ;
		}
		if (rfsw & RX_FS_LLC) {
			if (!smc->os.hwm.pass_llc_promisc) {
				if(!(virt[1] & GROUP_ADDR_BIT)) {
					if (virt[6] != MA[5] ||
					    virt[5] != MA[4] ||
					    virt[4] != MA[3] ||
					    virt[3] != MA[2] ||
					    virt[2] != MA[1] ||
					    virt[1] != MA[0]) {
						DB_RX(2, "DA != MA and not multi- or broadcast");
						goto abort_frame ;
					}
				}
			}
			DB_RX(4, "LLC - receive");
			mac_drv_rx_complete(smc,rxd,frag_count,len) ;
		}
		else {
			if (!(mb = smt_get_mbuf(smc))) {
				smc->hw.fp.err_stats.err_no_buf++ ;
				DB_RX(4, "No SMbuf; receive terminated");
				goto abort_frame ;
			}
			data = smtod(mb,char *) - 1 ;
#ifdef USE_OS_CPY
			hwm_cpy_rxd2mb(rxd,data,len) ;
#else
			for (r=rxd, i=used_frags ; i ; r=r->rxd_next, i--){
				n = le32_to_cpu(r->rxd_rbctrl) & RD_LENGTH ;
				DB_RX(6, "cp SMT frame to mb: len = %d", n);
				memcpy(data,r->rxd_virt,n) ;
				data += n ;
			}
			data = smtod(mb,char *) - 1 ;
#endif
			fc = *(char *)mb->sm_data = *data ;
			mb->sm_len = len - 1 ;		
			data++ ;
			switch(fc) {
			case FC_SMT_INFO :
				smc->hw.fp.err_stats.err_smt_frame++ ;
				DB_RX(5, "SMT frame received");
				if (smc->os.hwm.pass_SMT) {
					DB_RX(5, "pass SMT frame");
					mac_drv_rx_complete(smc, rxd,
						frag_count,len) ;
				}
				else {
					DB_RX(5, "requeue RxD");
					mac_drv_requeue_rxd(smc,rxd,frag_count);
				}
				smt_received_pack(smc,mb,(int)(rfsw>>25)) ;
				break ;
			case FC_SMT_NSA :
				smc->hw.fp.err_stats.err_smt_frame++ ;
				DB_RX(5, "SMT frame received");
				if (smc->os.hwm.pass_NSA ||
					(smc->os.hwm.pass_SMT &&
					!(rfsw & A_INDIC))) {
					DB_RX(5, "pass SMT frame");
					mac_drv_rx_complete(smc, rxd,
						frag_count,len) ;
				}
				else {
					DB_RX(5, "requeue RxD");
					mac_drv_requeue_rxd(smc,rxd,frag_count);
				}
				smt_received_pack(smc,mb,(int)(rfsw>>25)) ;
				break ;
			case FC_BEACON :
				if (smc->os.hwm.pass_DB) {
					DB_RX(5, "pass DB frame");
					mac_drv_rx_complete(smc, rxd,
						frag_count,len) ;
				}
				else {
					DB_RX(5, "requeue RxD");
					mac_drv_requeue_rxd(smc,rxd,frag_count);
				}
				smt_free_mbuf(smc,mb) ;
				break ;
			default :
				DB_RX(2, "unknown FC error");
				smt_free_mbuf(smc,mb) ;
				DB_RX(5, "requeue RxD");
				mac_drv_requeue_rxd(smc,rxd,frag_count) ;
				if ((fc & 0xf0) == FC_MAC)
					smc->hw.fp.err_stats.err_mac_frame++ ;
				else
					smc->hw.fp.err_stats.err_imp_frame++ ;
				break ;
			}
		}
		DB_RX(3, "next RxD is %p", queue->rx_curr_get);
		NDD_TRACE("RHx1",queue->rx_curr_get,0,0) ;
		continue ;
abort_frame:
		DB_RX(5, "requeue RxD");
		mac_drv_requeue_rxd(smc,rxd,frag_count) ;
		DB_RX(3, "next RxD is %p", queue->rx_curr_get);
		NDD_TRACE("RHx2",queue->rx_curr_get,0,0) ;
	}
rx_end:
#ifdef	ALL_RX_COMPLETE
	mac_drv_all_receives_complete(smc) ;
#endif
	return ;	
}
