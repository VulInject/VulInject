static int cfi_amdstd_write_words(struct mtd_info *mtd, loff_t to, size_t len,
				  size_t *retlen, const u_char *buf)
{
	struct map_info *map = mtd->priv;
	struct cfi_private *cfi = map->fldrv_priv;
	int ret;
	int chipnum;
	unsigned int ofs, chipstart;
	DECLARE_WAITQUEUE(wait, current);
	chipnum = to >> cfi->chipshift;
	ofs = to  - (chipnum << cfi->chipshift);
	chipstart = cfi->chips[chipnum].start;
	if (ofs & (map_bankwidth(map)-1)) {
		unsigned int bus_ofs = ofs & ~(map_bankwidth(map)-1);
		int i = ofs - bus_ofs;
		int n = 0;
		map_word tmp_buf;
 retry:
		mutex_lock(&cfi->chips[chipnum].mutex);
		if (cfi->chips[chipnum].state != FL_READY) {
			add_wait_queue(&cfi->chips[chipnum].wq, &wait);
			mutex_unlock(&cfi->chips[chipnum].mutex);
			schedule();
			remove_wait_queue(&cfi->chips[chipnum].wq, &wait);
			goto retry;
		}
		tmp_buf = map_read(map, bus_ofs+chipstart);
		mutex_unlock(&cfi->chips[chipnum].mutex);
		n = min_t(int, len, map_bankwidth(map)-i);
		tmp_buf = map_word_load_partial(map, tmp_buf, buf, i, n);
		ret = do_write_oneword(map, &cfi->chips[chipnum],
				       bus_ofs, tmp_buf, FL_WRITING);
		if (ret)
			return ret;
		ofs += n;
		buf += n;
		(*retlen) += n;
		len -= n;
		if (ofs >> cfi->chipshift) {
			chipnum ++;
			ofs = 0;
			if (chipnum == cfi->numchips)
				return 0;
		}
	}
	while(len >= map_bankwidth(map)) {
		map_word datum;
		datum = map_word_load(map, buf);
		ret = do_write_oneword(map, &cfi->chips[chipnum],
				       ofs, datum, FL_WRITING);
		if (ret)
			return ret;
		ofs += map_bankwidth(map);
		buf += map_bankwidth(map);
		(*retlen) += map_bankwidth(map);
		len -= map_bankwidth(map);
		if (ofs >> cfi->chipshift) {
			chipnum ++;
			ofs = 0;
			if (chipnum == cfi->numchips)
				return 0;
			chipstart = cfi->chips[chipnum].start;
		}
	}
	if (len & (map_bankwidth(map)-1)) {
		map_word tmp_buf;
 retry1:
		mutex_lock(&cfi->chips[chipnum].mutex);
		if (cfi->chips[chipnum].state != FL_READY) {
			set_current_state(TASK_UNINTERRUPTIBLE);
			add_wait_queue(&cfi->chips[chipnum].wq, &wait);
			mutex_unlock(&cfi->chips[chipnum].mutex);
			schedule();
			remove_wait_queue(&cfi->chips[chipnum].wq, &wait);
			goto retry1;
		}
		tmp_buf = map_read(map, ofs + chipstart);
		mutex_unlock(&cfi->chips[chipnum].mutex);
		tmp_buf = map_word_load_partial(map, tmp_buf, buf, 0, len);
		ret = do_write_oneword(map, &cfi->chips[chipnum],
				       ofs, tmp_buf, FL_WRITING);
		if (ret)
			return ret;
		(*retlen) += len;
	}
	return 0;
}
