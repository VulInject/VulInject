dissect_thrift_binary_linear(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int *offset, thrift_option_data_t *thrift_opt, thrift_type_enum_t expected)
{
    proto_tree *sub_tree;
    proto_item *container_pi, *len_pi, *vtype_pi;
    proto_item *ktype_pi = NULL; 
    gint32 ktype, vtype;
    gint32 container_len, i;
    int ett = -1;
    int hf_container = -1;
    int hf_num_item = -1;
    int hf_vtype = hf_thrift_type;
    int min_len = TBP_THRIFT_LINEAR_LEN;
    guint nested_count = p_get_proto_depth(pinfo, proto_thrift);
    switch (expected) {
        case DE_THRIFT_T_SET:
            ett = ett_thrift_set;
            hf_container = hf_thrift_set;
            hf_num_item = hf_thrift_num_set_item;
            break;
        case DE_THRIFT_T_LIST:
            ett = ett_thrift_list;
            hf_container = hf_thrift_list;
            hf_num_item = hf_thrift_num_list_item;
            break;
        case DE_THRIFT_T_MAP:
            ett = ett_thrift_map;
            hf_container = hf_thrift_map;
            hf_num_item = hf_thrift_num_map_item;
            hf_vtype = hf_thrift_value_type; 
            min_len += TBP_THRIFT_TYPE_LEN; 
            break;
        default:
            REPORT_DISSECTOR_BUG("dissect_thrift_binary_linear called with something else than a container type.");
            break;
    }
    ABORT_ON_INCOMPLETE_PDU(min_len);
	if ((unsigned int)nested_count >= thrift_opt->nested_type_depth)
        expert_add_info(pinfo, proto_tree_get_parent(tree), &ei_thrift_too_many_subtypes);
        return THRIFT_REQUEST_REASSEMBLY;
    }
