static void dissect_rlc_lte_am_status_pdu(tvbuff_t *tvb,
                                          packet_info *pinfo,
                                          proto_tree *tree,
                                          proto_item *status_ti,
                                          int offset,
                                          proto_item *top_ti,
                                          rlc_lte_info *p_rlc_lte_info,
                                          rlc_3gpp_tap_info *tap_info)
{
    guint32    cpt;
    guint8     sn_size, so_size;
    guint32    sn_limit;
    guint64    ack_sn, nack_sn;
    guint16    nack_count = 0, so_end_of_pdu;
    guint64    e1 = 0, e2 = 0;
    guint64    so_start, so_end;
    int        bit_offset = offset * 8;
    proto_item *ti;
    ti = proto_tree_add_item_ret_uint(tree, hf_rlc_lte_am_cpt, tvb, offset, 1, ENC_BIG_ENDIAN, &cpt);
    if (cpt != 0) {
        expert_add_info_format(pinfo, ti, &ei_rlc_lte_am_cpt,
                               "RLC Control frame type %u not handled", cpt);
        return;
    }
    if (p_rlc_lte_info->sequenceNumberLength == AM_SN_LENGTH_16_BITS) {
        sn_size = 16;
        sn_limit = 65536;
        so_size = 16;
        so_end_of_pdu = 0xffff;
    } else {
        sn_size = 10;
        sn_limit = 1024;
        so_size = 15;
        so_end_of_pdu = 0x7fff;
    }
    bit_offset += 4;
    proto_tree_add_bits_ret_val(tree, hf_rlc_lte_am_ack_sn, tvb,
                                bit_offset, sn_size, &ack_sn, ENC_BIG_ENDIAN);
    bit_offset += sn_size;
    write_pdu_label_and_info(top_ti, status_ti, pinfo, "  ACK_SN=%-4u", (guint16)ack_sn);
    tap_info->ACKNo = (guint16)ack_sn;
    proto_tree_add_bits_ret_val(tree, hf_rlc_lte_am_e1, tvb,
                                bit_offset, 1, &e1, ENC_BIG_ENDIAN);
    bit_offset++;
    do {
        if (e1) {
            proto_item *nack_ti;
            nack_ti = proto_tree_add_bits_ret_val(tree, hf_rlc_lte_am_nack_sn, tvb,
                                                  bit_offset, sn_size, &nack_sn, ENC_BIG_ENDIAN);
            bit_offset += sn_size;
            write_pdu_label_and_info(top_ti, NULL, pinfo, "  NACK_SN=%-4u", (guint16)nack_sn);
            if (nack_sn == ack_sn) {
                expert_add_info_format(pinfo, nack_ti, &ei_rlc_lte_am_nack_sn_ack_same,
                                       "Status PDU shouldn't ACK and NACK the same sequence number (%" PRIu64 ")",
                                       ack_sn);
            }
            if ((sn_limit + ack_sn - nack_sn) % sn_limit > (sn_limit>>1)) {
                expert_add_info(pinfo, nack_ti, &ei_rlc_lte_am_nack_sn_ahead_ack);
            }
            if (nack_count < MAX_NACKs) {
                tap_info->NACKs[nack_count++] = (guint16)nack_sn;
            }
            else {
                nack_count++;
            }
            proto_tree_add_bits_ret_val(tree, hf_rlc_lte_am_e1, tvb,
                                        bit_offset, 1, &e1, ENC_BIG_ENDIAN);
            bit_offset++;
            proto_tree_add_bits_ret_val(tree, hf_rlc_lte_am_e2, tvb,
                                        bit_offset, 1, &e2, ENC_BIG_ENDIAN);
            if (e2) {
                expert_add_info_format(pinfo, nack_ti, &ei_rlc_lte_am_nack_sn_partial,
                                       "Status PDU reports NACK (partial) on %s for UE %u",
                                       val_to_str_const(p_rlc_lte_info->direction, direction_vals, "Unknown"),
                                       p_rlc_lte_info->ueid);
            }
            else {
                expert_add_info_format(pinfo, nack_ti, &ei_rlc_lte_am_nack_sn,
                                       "Status PDU reports NACK on %s for UE %u",
                                       val_to_str_const(p_rlc_lte_info->direction, direction_vals, "Unknown"),
                                       p_rlc_lte_info->ueid);
            }
            bit_offset++;
        }
        if (e2) {
            proto_tree_add_bits_ret_val(tree, hf_rlc_lte_am_so_start, tvb,
                                        bit_offset, so_size, &so_start, ENC_BIG_ENDIAN);
            bit_offset += so_size;
            proto_tree_add_bits_ret_val(tree, hf_rlc_lte_am_so_end, tvb,
                                        bit_offset, so_size, &so_end, ENC_BIG_ENDIAN);
            bit_offset += so_size;
            if ((guint16)so_end == so_end_of_pdu) {
                write_pdu_label_and_info(top_ti, NULL, pinfo,
                                         " (SOstart=%u SOend=<END-OF_PDU>)",
                                         (guint16)so_start);
            }
            else {
                write_pdu_label_and_info(top_ti, NULL, pinfo,
                                         " (SOstart=%u SOend=%u)",
                                         (guint16)so_start, (guint16)so_end);
            }
            e2 = 0;
        }
    } while (e1);
    if (nack_count > 0) {
        proto_item *count_ti = proto_tree_add_uint(tree, hf_rlc_lte_am_nacks, tvb, 0, 1, nack_count);
        proto_item_set_generated(count_ti);
        proto_item_append_text(status_ti, "  (%u NACKs)", nack_count);
        tap_info->noOfNACKs = nack_count;
    }
    offset = (bit_offset+7) / 8;
    if (tvb_reported_length_remaining(tvb, offset) > 0) {
        expert_add_info_format(pinfo, status_ti, &ei_rlc_lte_bytes_after_status_pdu_complete,
                               "%cL %u bytes remaining after Status PDU complete",
                               (p_rlc_lte_info->direction == DIRECTION_UPLINK) ? 'U' : 'D',
                               tvb_reported_length_remaining(tvb, offset));
    }
    if (((global_rlc_lte_am_sequence_analysis == SEQUENCE_ANALYSIS_MAC_ONLY) &&
         (p_get_proto_data(wmem_file_scope(), pinfo, proto_mac_lte, 0) != NULL)) ||
        ((global_rlc_lte_am_sequence_analysis == SEQUENCE_ANALYSIS_RLC_ONLY) &&
         (p_get_proto_data(wmem_file_scope(), pinfo, proto_mac_lte, 0) == NULL))) {
        if (!is_mac_lte_frame_retx(pinfo, p_rlc_lte_info->direction)) {
            checkChannelRepeatedNACKInfo(pinfo, p_rlc_lte_info, tap_info, tree, tvb);
            checkChannelACKWindow((guint16)ack_sn, pinfo, p_rlc_lte_info, tap_info, tree, tvb);
        }
     }
}
