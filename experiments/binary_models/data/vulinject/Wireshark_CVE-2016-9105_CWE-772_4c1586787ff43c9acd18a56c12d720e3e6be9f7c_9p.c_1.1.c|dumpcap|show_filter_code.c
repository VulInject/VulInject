show_filter_code(capture_options *capture_opts)
{
    interface_options *interface_opts;
    pcap_t *pcap_h;
    cap_device_open_status open_status;
    gchar open_status_str[PCAP_ERRBUF_SIZE];
    char errmsg[MSG_MAX_LENGTH+1];
    char secondary_errmsg[MSG_MAX_LENGTH+1];
    struct bpf_program fcode;
    struct bpf_insn *insn;
    u_int i;
    guint j;
    for (j = 0; j < capture_opts->ifaces->len; j++) {
        interface_opts = &g_array_index(capture_opts->ifaces, interface_options, j);
        pcap_h = open_capture_device(capture_opts, interface_opts,
            CAP_READ_TIMEOUT, &open_status, &open_status_str);
        if (pcap_h == NULL) {
            get_capture_device_open_failure_messages(open_status, open_status_str,
                                                     interface_opts->name,
                                                     errmsg, sizeof errmsg,
                                                     secondary_errmsg,
                                                     sizeof secondary_errmsg);
            return FALSE;
        }
        if (!set_pcap_datalink(pcap_h, interface_opts->linktype, interface_opts->name,
                               errmsg, sizeof errmsg,
                               secondary_errmsg, sizeof secondary_errmsg)) {
            pcap_close(pcap_h);
            report_capture_error(errmsg, secondary_errmsg);
            return FALSE;
        }
        if (!compile_capture_filter(interface_opts->name, pcap_h, &fcode,
                                    interface_opts->cfilter)) {
            snprintf(errmsg, sizeof(errmsg), "%s", pcap_geterr(pcap_h));
            pcap_close(pcap_h);
            report_cfilter_error(capture_opts, j, errmsg);
            return FALSE;
        }
        pcap_close(pcap_h);
        insn = fcode.bf_insns;
        for (i = 0; i < fcode.bf_len; insn++, i++)
            printf("%s\n", bpf_image(insn, i));
    }
#ifndef HAVE_LIBCAP
    relinquish_special_privs_perm();
#else
    relinquish_all_capabilities();
#endif
    if (capture_child) {
        sync_pipe_write_string_msg(sync_pipe_fd, SP_SUCCESS, NULL);
    }
    return TRUE;
}
