irqreturn_t atmel_isc_interrupt(int irq, void *dev_id)
{
	struct isc_device *isc = (struct isc_device *)dev_id;
	struct regmap *regmap = isc->regmap;
	unsigned int isc_intsr, isc_intmask, pending;
	irqreturn_t ret = IRQ_NONE;
	regmap_read(regmap, ISC_INTSR, &isc_intsr);
	regmap_read(regmap, ISC_INTMASK, &isc_intmask);
	pending = isc_intsr & isc_intmask;
	if (likely(pending & ISC_INT_DDONE)) {
		if (isc->cur_frm) {
			struct vb2_v4l2_buffer *vbuf = &isc->cur_frm->vb;
			struct vb2_buffer *vb = &vbuf->vb2_buf;
			vb->timestamp = ktime_get_ns();
			vbuf->sequence = isc->sequence++;
			vb2_buffer_done(vb, VB2_BUF_STATE_DONE);
			isc->cur_frm = NULL;
		}
		if (!list_empty(&isc->dma_queue) && !isc->stop) {
			isc->cur_frm = list_first_entry(&isc->dma_queue,
						     struct isc_buffer, list);
			list_del(&isc->cur_frm->list);
			isc_start_dma(isc);
		}
		if (isc->stop)
			complete(&isc->comp);
		ret = IRQ_HANDLED;
		spin_unlock(&isc->dma_queue_lock);
	}
	if (pending & ISC_INT_HISDONE) {
		schedule_work(&isc->awb_work);
		ret = IRQ_HANDLED;
	}
	return ret;
}
