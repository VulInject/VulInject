  t42_parse_encoding( FT_Face  face,
                      void*    loader_ )
  {
    T42_Face    t42face = (T42_Face)face;
    T42_Loader  loader  = (T42_Loader)loader_;
    T42_Parser  parser  = &loader->parser;
    FT_Byte*    cur;
    FT_Byte*    limit   = parser->root.limit;
    PSAux_Service  psaux  = (PSAux_Service)t42face->psaux;
    cur = parser->root.cursor;
    if ( cur >= limit )
    {
      FT_ERROR(( "t42_parse_encoding: out of bounds\n" ));
      parser->root.error = FT_THROW( Invalid_File_Format );
      return;
    }
    if ( ft_isdigit( *cur ) || *cur == '[' )
    {
      T1_Encoding  encode          = &t42face->type1.encoding;
      FT_Int       count, n;
      PS_Table     char_table      = &loader->encoding_table;
      FT_Memory    memory          = parser->root.memory;
      FT_Error     error;
      FT_Bool      only_immediates = 0;
      if ( *cur == '[' )
      {
        count           = 256;
        only_immediates = 1;
        parser->root.cursor++;
      }
      else
        count = (FT_Int)T1_ToInt( parser );
      if ( count > 256 )
      {
        FT_ERROR(( "t42_parse_encoding: invalid encoding array size\n" ));
        parser->root.error = FT_THROW( Invalid_File_Format );
        return;
      }
      T1_Skip_Spaces( parser );
      if ( parser->root.cursor >= limit )
        return;
      if ( encode->char_index )
      {
        FT_FREE( encode->char_index );
        FT_FREE( encode->char_name );
        T1_Release_Table( char_table );
      }
      loader->num_chars = encode->num_chars = count;
      if ( FT_QNEW_ARRAY( encode->char_index, count )    ||
           FT_QNEW_ARRAY( encode->char_name,  count )    ||
           FT_SET_ERROR( psaux->ps_table_funcs->init(
                           char_table, count, memory ) ) )
      {
        parser->root.error = error;
        return;
      }
      for ( n = 0; n < count; n++ )
        (void)T1_Add_Table( char_table, n, ".notdef", 8 );
      n = 0;
      T1_Skip_Spaces( parser );
      while ( parser->root.cursor < limit )
      {
        cur = parser->root.cursor;
        if ( *cur == 'd' && cur + 3 < limit )
        {
          if ( cur[1] == 'e'          &&
               cur[2] == 'f'          &&
               t42_is_space( cur[3] ) )
          {
            FT_TRACE6(( "encoding end\n" ));
            cur += 3;
            break;
          }
        }
        if ( *cur == ']' )
        {
          FT_TRACE6(( "encoding end\n" ));
          cur++;
          break;
        }
        if ( ft_isdigit( *cur ) || only_immediates )
        {
          FT_Int  charcode;
          if ( only_immediates )
            charcode = n;
          else
          {
            charcode = (FT_Int)T1_ToInt( parser );
            T1_Skip_Spaces( parser );
            if ( cur == parser->root.cursor )
            {
              parser->root.error = FT_THROW( Unknown_File_Format );
              return;
            }
          }
          cur = parser->root.cursor;
          if ( cur + 2 < limit && *cur == '/' && n < count )
          {
            FT_UInt  len;
            cur++;
            parser->root.cursor = cur;
            T1_Skip_PS_Token( parser );
            if ( parser->root.cursor >= limit )
              return;
            if ( parser->root.error )
              return;
            len = (FT_UInt)( parser->root.cursor - cur );
            parser->root.error = T1_Add_Table( char_table, charcode,
                                               cur, len + 1 );
            if ( parser->root.error )
              return;
            char_table->elements[charcode][len] = '\0';
            n++;
          }
          else if ( only_immediates )
          {
            parser->root.error = FT_THROW( Unknown_File_Format );
            return;
          }
        }
        else
        {
          T1_Skip_PS_Token( parser );
          if ( parser->root.error )
            return;
        }
        T1_Skip_Spaces( parser );
      }
      t42face->type1.encoding_type = T1_ENCODING_TYPE_ARRAY;
      parser->root.cursor          = cur;
    }
    else
    {
      if ( cur + 17 < limit                                            &&
           ft_strncmp( (const char*)cur, "StandardEncoding", 16 ) == 0 )
        t42face->type1.encoding_type = T1_ENCODING_TYPE_STANDARD;
      else if ( cur + 15 < limit                                          &&
                ft_strncmp( (const char*)cur, "ExpertEncoding", 14 ) == 0 )
        t42face->type1.encoding_type = T1_ENCODING_TYPE_EXPERT;
      else if ( cur + 18 < limit                                             &&
                ft_strncmp( (const char*)cur, "ISOLatin1Encoding", 17 ) == 0 )
        t42face->type1.encoding_type = T1_ENCODING_TYPE_ISOLATIN1;
      else
        parser->root.error = FT_ERR( Ignore );
    }
  }
