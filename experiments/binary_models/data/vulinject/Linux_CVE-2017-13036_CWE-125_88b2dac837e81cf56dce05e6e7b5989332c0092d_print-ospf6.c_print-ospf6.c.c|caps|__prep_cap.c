static void __prep_cap(struct cap_msg_args *arg, struct ceph_cap *cap,
		       int op, int flags, int used, int want, int retain,
		       int flushing, unsigned int int flush_tid, unsigned int int oldest_flush_tid)
{
	struct ceph_inode_info *ci = cap->ci;
	struct inode *inode = &ci->netfs.inode;
	struct ceph_client *cl = ceph_inode_to_client(inode);
	int held, revoking;
	held = cap->issued | cap->implemented;
	revoking = cap->implemented & ~cap->issued;
	retain &= ~revoking;
	doutc(cl, "%p %llx.%llx cap %p session %p %s -> %s (revoking %s)\n",
	      inode, ceph_vinop(inode), cap, cap->session,
	      ceph_cap_string(held), ceph_cap_string(held & retain),
	      ceph_cap_string(revoking));
	BUG_ON((retain & CEPH_CAP_PIN) == 0);
	ci->i_ceph_flags &= ~CEPH_I_FLUSH;
	cap->issued &= retain;  
	arg->wake = cap->implemented & ~cap->issued;
	cap->implemented &= cap->issued | used;
	cap->mds_wanted = want;
	arg->session = cap->session;
	arg->ino = ceph_vino(inode).ino;
	arg->cid = cap->cap_id;
	arg->follows = flushing ? ci->i_head_snapc->seq : 0;
	arg->flush_tid = flush_tid;
	arg->oldest_flush_tid = oldest_flush_tid;
	arg->size = i_size_read(inode);
	ci->i_reported_size = arg->size;
	arg->max_size = ci->i_wanted_max_size;
	if (cap == ci->i_auth_cap) {
		if (want & CEPH_CAP_ANY_FILE_WR)
			ci->i_requested_max_size = arg->max_size;
		else
			ci->i_requested_max_size = 0;
	}
	if (flushing & CEPH_CAP_XATTR_EXCL) {
		arg->old_xattr_buf = __ceph_build_xattrs_blob(ci);
		arg->xattr_version = ci->i_xattrs.version;
		arg->xattr_buf = ceph_buffer_get(ci->i_xattrs.blob);
	} else {
		arg->xattr_buf = NULL;
		arg->old_xattr_buf = NULL;
	}
	arg->mtime = inode_get_mtime(inode);
	arg->atime = inode_get_atime(inode);
	arg->ctime = inode_get_ctime(inode);
	arg->btime = ci->i_btime;
	arg->change_attr = inode_peek_iversion_raw(inode);
	arg->op = op;
	arg->caps = cap->implemented;
	arg->wanted = want;
	arg->dirty = flushing;
	arg->seq = cap->seq;
	arg->issue_seq = cap->issue_seq;
	arg->mseq = cap->mseq;
	arg->time_warp_seq = ci->i_time_warp_seq;
	arg->uid = inode->i_uid;
	arg->gid = inode->i_gid;
	arg->mode = inode->i_mode;
	arg->inline_data = ci->i_inline_version != CEPH_INLINE_NONE;
	if (!(flags & CEPH_CLIENT_CAPS_PENDING_CAPSNAP) &&
	    !list_empty(&ci->i_cap_snaps)) {
		struct ceph_cap_snap *capsnap;
		list_for_each_entry_reverse(capsnap, &ci->i_cap_snaps, ci_item) {
			if (capsnap->cap_flush.tid)
				break;
			if (capsnap->need_flush) {
				flags |= CEPH_CLIENT_CAPS_PENDING_CAPSNAP;
				break;
			}
		}
	}
	arg->flags = flags;
	arg->encrypted = IS_ENCRYPTED(inode);
#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
	if (ci->fscrypt_auth_len &&
	    WARN_ON_ONCE(ci->fscrypt_auth_len > sizeof(struct ceph_fscrypt_auth))) {
		arg->fscrypt_auth_len = 0;
	} else {
		arg->fscrypt_auth_len = ci->fscrypt_auth_len;
		memcpy(arg->fscrypt_auth, ci->fscrypt_auth,
		       min_t(size_t, ci->fscrypt_auth_len,
			     sizeof(arg->fscrypt_auth)));
	}
#endif 
}
