nouveau_dma_wait(struct nouveau_channel *chan, int slots, int size)
{
	unsigned int int prev_get = 0;
	int cnt = 0, get;
	if (chan->dma.ib_max)
		return nv50_dma_wait(chan, slots, size);
	while (chan->dma.free < size) {
		get = READ_GET(chan, &prev_get, &cnt);
		if (unlikely(get == -EBUSY))
			return -EBUSY;
		if (unlikely(get == -EINVAL) || get < NOUVEAU_DMA_SKIPS)
			continue;
		if (get <= chan->dma.cur) {
			chan->dma.free = chan->dma.max - chan->dma.cur;
			if (chan->dma.free >= size)
				break;
			OUT_RING(chan, chan->push.addr | 0x20000000);
			do {
				get = READ_GET(chan, &prev_get, &cnt);
				if (unlikely(get == -EBUSY))
					return -EBUSY;
				if (unlikely(get == -EINVAL))
					continue;
			} while (get <= NOUVEAU_DMA_SKIPS);
			chan->dma.cur  =
			chan->dma.put  = NOUVEAU_DMA_SKIPS;
		}
		chan->dma.free = get - chan->dma.cur - 1;
	}
	return 0;
}
