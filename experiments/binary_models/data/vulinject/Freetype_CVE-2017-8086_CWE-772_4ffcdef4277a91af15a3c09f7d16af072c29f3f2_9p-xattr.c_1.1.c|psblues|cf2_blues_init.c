  cf2_blues_init( CF2_Blues  blues,
                  CF2_Font   font )
  {
    PS_Decoder*  decoder = font->decoder;
    CF2_Fixed  zoneHeight;
    CF2_Fixed  maxZoneHeight = 0;
    CF2_Fixed  csUnitsPerPixel;
    size_t  numBlueValues;
    size_t  numOtherBlues;
    size_t  numFamilyBlues;
    size_t  numFamilyOtherBlues;
    FT_Fixed*  blueValues;
    FT_Fixed*  otherBlues;
    FT_Fixed*  familyBlues;
    FT_Fixed*  familyOtherBlues;
    size_t     i;
    CF2_Fixed  emBoxBottom, emBoxTop;
#if 0
    CF2_Int  unitsPerEm = font->unitsPerEm;
    if ( unitsPerEm == 0 )
      unitsPerEm = 1000;
#endif
    blues->scale = font->innerTransform.d;
    cf2_getBlueMetrics( decoder,
                        &blues->blueScale,
                        &blues->blueShift,
                        &blues->blueFuzz );
    cf2_getBlueValues( decoder, &numBlueValues, &blueValues );
    cf2_getOtherBlues( decoder, &numOtherBlues, &otherBlues );
    cf2_getFamilyBlues( decoder, &numFamilyBlues, &familyBlues );
    cf2_getFamilyOtherBlues( decoder, &numFamilyOtherBlues, &familyOtherBlues );
#if 0
    FCM_getHorizontalLineMetrics( &e,
                                  font->font,
                                  &ascender,
                                  &descender,
                                  &linegap );
    if ( ascender - descender == unitsPerEm )
    {
      emBoxBottom = cf2_intToFixed( descender );
      emBoxTop    = cf2_intToFixed( ascender );
    }
    else
#endif
    {
      emBoxBottom = CF2_ICF_Bottom;
      emBoxTop    = CF2_ICF_Top;
    }
    if ( cf2_getLanguageGroup( decoder ) == 1     &&
         ( numBlueValues == 0                   ||
           ( numBlueValues == 4               &&
             blueValues[0] < emBoxBottom      &&
             blueValues[1] < emBoxBottom      &&
             blueValues[2] > emBoxTop         &&
             blueValues[3] > emBoxTop         ) ) )
    {
      blues->emBoxBottomEdge.csCoord = emBoxBottom - CF2_FIXED_EPSILON;
      blues->emBoxBottomEdge.dsCoord = cf2_fixedRound(
                                         FT_MulFix(
                                           blues->emBoxBottomEdge.csCoord,
                                           blues->scale ) ) -
                                       CF2_MIN_COUNTER;
      blues->emBoxBottomEdge.scale   = blues->scale;
      blues->emBoxBottomEdge.flags   = CF2_GhostBottom |
                                       CF2_Locked |
                                       CF2_Synthetic;
      blues->emBoxTopEdge.csCoord = emBoxTop + CF2_FIXED_EPSILON +
                                    2 * font->darkenY;
      blues->emBoxTopEdge.dsCoord = cf2_fixedRound(
                                      FT_MulFix(
                                        blues->emBoxTopEdge.csCoord,
                                        blues->scale ) ) +
                                    CF2_MIN_COUNTER;
      blues->emBoxTopEdge.scale   = blues->scale;
      blues->emBoxTopEdge.flags   = CF2_GhostTop |
                                    CF2_Locked |
                                    CF2_Synthetic;
      blues->doEmBoxHints = TRUE;    
      return;
    }
    for ( i = 0; i < numBlueValues; i += 2 )
    {
      blues->zone[blues->count].csBottomEdge = blueValues[i];
      blues->zone[blues->count].csTopEdge    = blueValues[i + 1];
      zoneHeight = SUB_INT32( blues->zone[blues->count].csTopEdge,
                              blues->zone[blues->count].csBottomEdge );
      if ( zoneHeight < 0 )
      {
        FT_TRACE4(( "cf2_blues_init: ignoring negative zone height\n" ));
        continue;   
      }
      if ( zoneHeight > maxZoneHeight )
      {
        maxZoneHeight = zoneHeight;
      }
      if ( i != 0 )
      {
        blues->zone[blues->count].csTopEdge    += 2 * font->darkenY;
        blues->zone[blues->count].csBottomEdge += 2 * font->darkenY;
      }
      if ( i == 0 )
      {
        blues->zone[blues->count].bottomZone =
          TRUE;
        blues->zone[blues->count].csFlatEdge =
          blues->zone[blues->count].csTopEdge;
      }
      else
      {
        blues->zone[blues->count].bottomZone =
          FALSE;
        blues->zone[blues->count].csFlatEdge =
          blues->zone[blues->count].csBottomEdge;
      }
      blues->count += 1;
    }
    for ( i = 0; i < numOtherBlues; i += 2 )
    {
      blues->zone[blues->count].csBottomEdge = otherBlues[i];
      blues->zone[blues->count].csTopEdge    = otherBlues[i + 1];
      zoneHeight = SUB_INT32( blues->zone[blues->count].csTopEdge,
                              blues->zone[blues->count].csBottomEdge );
      if ( zoneHeight < 0 )
      {
        FT_TRACE4(( "cf2_blues_init: ignoring negative zone height\n" ));
        continue;   
      }
      if ( zoneHeight > maxZoneHeight )
      {
        maxZoneHeight = zoneHeight;
      }
      blues->zone[blues->count].bottomZone =
        TRUE;
      blues->zone[blues->count].csFlatEdge =
        blues->zone[blues->count].csTopEdge;
      blues->count += 1;
    }
    csUnitsPerPixel = FT_DivFix( cf2_intToFixed( 1 ), blues->scale );
    for ( i = 0; i < blues->count; i++ )
    {
      size_t     j;
      CF2_Fixed  minDiff;
      CF2_Fixed  flatFamilyEdge, diff;
      CF2_Fixed  flatEdge = blues->zone[i].csFlatEdge;
      if ( blues->zone[i].bottomZone )
      {
        minDiff = CF2_FIXED_MAX;
        for ( j = 0; j < numFamilyOtherBlues; j += 2 )
        {
          flatFamilyEdge = familyOtherBlues[j + 1];
          diff = cf2_fixedAbs( SUB_INT32( flatEdge, flatFamilyEdge ) );
          if ( diff < minDiff && diff < csUnitsPerPixel )
          {
            blues->zone[i].csFlatEdge = flatFamilyEdge;
            minDiff                   = diff;
            if ( diff == 0 )
              break;
          }
        }
        if ( numFamilyBlues >= 2 )
        {
          flatFamilyEdge = familyBlues[1];
          diff = cf2_fixedAbs( SUB_INT32( flatEdge, flatFamilyEdge ) );
          if ( diff < minDiff && diff < csUnitsPerPixel )
            blues->zone[i].csFlatEdge = flatFamilyEdge;
        }
      }
      else
      {
        minDiff = CF2_FIXED_MAX;
        for ( j = 2; j < numFamilyBlues; j += 2 )
        {
          flatFamilyEdge = familyBlues[j];
          flatFamilyEdge += 2 * font->darkenY;      
          diff = cf2_fixedAbs( SUB_INT32( flatEdge, flatFamilyEdge ) );
          if ( diff < minDiff && diff < csUnitsPerPixel )
          {
            blues->zone[i].csFlatEdge = flatFamilyEdge;
            minDiff                   = diff;
            if ( diff == 0 )
              break;
          }
        }
      }
    }
    if ( maxZoneHeight > 0 )
    {
      if ( blues->blueScale > FT_DivFix( cf2_intToFixed( 1 ),
                                         maxZoneHeight ) )
      {
        blues->blueScale = FT_DivFix( cf2_intToFixed( 1 ),
                                      maxZoneHeight );
      }
#if 0
      if ( blueScale < .4 / maxZoneHeight )
      {
        tetraphilia_assert( 0 );
        blueScale = .4 / maxZoneHeight;
      }
#endif
    }
    if ( blues->scale < blues->blueScale )
    {
      blues->suppressOvershoot = TRUE;
      blues->boost = cf2_doubleToFixed( .6 ) -
                       FT_MulDiv( cf2_doubleToFixed ( .6 ),
                                  blues->scale,
                                  blues->blueScale );
      if ( blues->boost > 0x7FFF )
      {
        blues->boost = 0x7FFF;
      }
    }
    if ( font->stemDarkened )
      blues->boost = 0;
    for ( i = 0; i < blues->count; i++ )
    {
      if ( blues->zone[i].bottomZone )
        blues->zone[i].dsFlatEdge = cf2_fixedRound(
                                      FT_MulFix(
                                        blues->zone[i].csFlatEdge,
                                        blues->scale ) -
                                      blues->boost );
      else
        blues->zone[i].dsFlatEdge = cf2_fixedRound(
                                      FT_MulFix(
                                        blues->zone[i].csFlatEdge,
                                        blues->scale ) +
                                      blues->boost );
    }
  }
