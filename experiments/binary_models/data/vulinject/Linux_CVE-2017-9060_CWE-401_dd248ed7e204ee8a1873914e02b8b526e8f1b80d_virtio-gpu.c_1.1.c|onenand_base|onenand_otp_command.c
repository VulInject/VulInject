static int onenand_otp_command(struct mtd_info *mtd, int cmd, loff_t addr,
				size_t len)
{
	struct onenand_chip *this = mtd->priv;
	int value, block, page;
	switch (cmd) {
	case ONENAND_CMD_OTP_ACCESS:
		block = (int) (addr >> this->erase_shift);
		page = -1;
		break;
	default:
		block = (int) (addr >> this->erase_shift);
		page = (int) (addr >> this->page_shift);
		if (ONENAND_IS_2PLANE(this)) {
			block &= ~1;
			if (addr & this->writesize)
				block++;
			page >>= 1;
		}
		page &= this->page_mask;
		break;
	}
	if (block != -1) {
		value = onenand_block_address(this, block);
		this->write_word(value, this->base +
				ONENAND_REG_START_ADDRESS1);
	}
	if (page != -1) {
		int sectors = 4, count = 4;
		int dataram;
		switch (cmd) {
		default:
			if (ONENAND_IS_2PLANE(this) && cmd == ONENAND_CMD_PROG)
				cmd = ONENAND_CMD_2X_PROG;
			break;
		}
		value = onenand_page_address(page, sectors);
		this->write_word(value, this->base +
				ONENAND_REG_START_ADDRESS8);
		value = onenand_buffer_address(dataram, sectors, count);
		this->write_word(value, this->base + ONENAND_REG_START_BUFFER);
	}
	this->write_word(ONENAND_INT_CLEAR, this->base + ONENAND_REG_INTERRUPT);
	this->write_word(cmd, this->base + ONENAND_REG_COMMAND);
	return 0;
}
