static bool analyzeFunction(RCore *core, ut64 addr) {
	r_strf_buffer (64);
	Sdb *db = sdb_new0 ();
	RFlagItem *fi;
	RListIter *iter;
	ut64 loc_addr = 0;
	char *command = NULL;
	char *function_label;
	bool vars = r_config_get_b (core->config, "anal.vars");
	if (!db) {
		R_LOG_ERROR ("Cannot create db");
		return false;
	}
	RList *delayed_commands = r_list_newf (free);
	if (!delayed_commands) {
		sdb_free (db);
		return false;
	}
	ut64 a = analyzeStackBased (core, db, addr, delayed_commands);
	if (addr == UT64_MAX) {
		R_LOG_ERROR ("Initial analysis failed");
		return false;
	}
	if (a != UT64_MAX) {
		addr = a;
	}
	sdb_num_set (db, "addr", addr, 0);
	sdb_num_set (db, "size", getFunctionSize (db), 0);
	fi = r_flag_get_at (core->flags, addr, false);
	if (fi && fi->name && strncmp (fi->name, "sect", 4)) {
		function_label = strdup (fi->name);
	} else {
		function_label = r_str_newf ("fcn.%08"PFMT64x, addr);
	}
	loc_addr = sdb_num_get (db, "addr", NULL);
	RAnalFunction *fcn_at_addr = r_anal_get_function_at (core->anal, loc_addr);
	if (fcn_at_addr) {
		return false;
	}
	r_core_cmdf (core, "af+ 0x%08"PFMT64x" %s", loc_addr, function_label);
	{
		char *c, *bbs = sdb_get (db, "bbs", NULL);
		sdb_aforeach (c, bbs) {
			ut64 addr = sdb_atoi (c);
			ut64 addr_end = sdb_num_get (db, Fbb (addr), NULL);
			ut64 jump = sdb_array_get_num (db, FbbTo (addr), 0, NULL);
			ut64 fail = sdb_array_get_num (db, FbbTo (addr), 1, NULL);
			r_core_cmdf (core, "afb+ 0x%"PFMT64x" 0x%"PFMT64x" %d 0x%"PFMT64x" 0x%"PFMT64x,
			  	loc_addr, addr, (int)(addr_end - addr), jump, fail);
			sdb_aforeach_next (c);
		}
		if (vars) {
			RAnalFunction *fcn = r_anal_get_function_at (core->anal, addr);
			if (fcn && !r_list_empty (fcn->bbs)) {
				r_core_cmdf (core, "afva @ 0x%"PFMT64x, addr);
			}
		}
		free (bbs);
		free (function_label);
	}
	r_list_foreach (delayed_commands, iter, command) {
		if (command) {
			command = NULL;
		}
	}
	r_list_free (delayed_commands);
	sdb_free (db);
	return true;
}
