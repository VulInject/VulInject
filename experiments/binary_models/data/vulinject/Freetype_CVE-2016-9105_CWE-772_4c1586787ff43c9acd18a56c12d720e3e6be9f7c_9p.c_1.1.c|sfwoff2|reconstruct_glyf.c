  reconstruct_glyf( FT_Stream    stream,
                    FT_ULong*    glyf_checksum,
                    FT_ULong*    loca_checksum,
                    FT_Byte**    sfnt_bytes,
                    FT_ULong*    sfnt_size,
                    FT_ULong*    out_offset,
                    WOFF2_Info   info,
                    FT_Memory    memory )
  {
    FT_Error  error = FT_Err_Ok;
    FT_Byte*  sfnt  = *sfnt_bytes;
    const FT_ULong  pos = FT_STREAM_POS();
    FT_UInt  num_substreams = 7;
    FT_UShort  option_flags;
    FT_UShort  num_glyphs;
    FT_UShort  index_format;
    FT_ULong   expected_loca_length;
    FT_UInt    offset;
    FT_UInt    i;
    FT_ULong   points_size;
    FT_ULong   glyph_buf_size;
    FT_ULong   bbox_bitmap_offset;
    FT_ULong   bbox_bitmap_length;
    FT_ULong   overlap_bitmap_offset = 0;
    FT_ULong   overlap_bitmap_length = 0;
    const FT_ULong  glyf_start  = *out_offset;
    FT_ULong        dest_offset = *out_offset;
    WOFF2_Substream  substreams = NULL;
    FT_ULong*    loca_values  = NULL;
    FT_UShort*   n_points_arr = NULL;
    FT_Byte*     glyph_buf    = NULL;
    WOFF2_Point  points       = NULL;
    if ( FT_QNEW_ARRAY( substreams, num_substreams ) )
      goto Fail;
    if ( FT_STREAM_SKIP( 2 ) )
      goto Fail;
    if ( FT_READ_USHORT( option_flags ) )
      goto Fail;
    if ( FT_READ_USHORT( num_glyphs ) )
      goto Fail;
    if ( FT_READ_USHORT( index_format ) )
      goto Fail;
    FT_TRACE4(( "option_flags = %u; num_glyphs = %u; index_format = %u\n",
                option_flags, num_glyphs, index_format ));
    info->num_glyphs = num_glyphs;
    expected_loca_length = ( index_format ? 4 : 2 ) *
                             ( (FT_ULong)num_glyphs + 1 );
    if ( info->loca_table->dst_length != expected_loca_length )
      goto Fail;
    offset = 2 + 2 + 2 + 2 + ( num_substreams * 4 );
    if ( offset > info->glyf_table->TransformLength )
      goto Fail;
    for ( i = 0; i < num_substreams; ++i )
    {
      FT_ULong  substream_size;
      if ( FT_READ_ULONG( substream_size ) )
        goto Fail;
      if ( substream_size > info->glyf_table->TransformLength - offset )
        goto Fail;
      substreams[i].start  = pos + offset;
      substreams[i].offset = pos + offset;
      substreams[i].size   = substream_size;
      FT_TRACE5(( "  Substream %d: offset = %lu; size = %lu;\n",
                  i, substreams[i].offset, substreams[i].size ));
      offset += substream_size;
    }
    if ( option_flags & HAVE_OVERLAP_SIMPLE_BITMAP )
    {
      overlap_bitmap_length = ( num_glyphs + 7U ) >> 3;
      if ( overlap_bitmap_length > info->glyf_table->TransformLength - offset )
        goto Fail;
      overlap_bitmap_offset = pos + offset;
      FT_TRACE5(( "  Overlap bitmap: offset = %lu; size = %lu;\n",
                  overlap_bitmap_offset, overlap_bitmap_length ));
      offset += overlap_bitmap_length;
    }
    if ( FT_QNEW_ARRAY( loca_values, num_glyphs + 1 ) )
      goto Fail;
    points_size        = 0;
    bbox_bitmap_offset = substreams[BBOX_STREAM].offset;
    bbox_bitmap_length              = ( ( num_glyphs + 31U ) >> 5 ) << 2;
    substreams[BBOX_STREAM].offset += bbox_bitmap_length;
    glyph_buf_size = WOFF2_DEFAULT_GLYPH_BUF;
    if ( FT_QALLOC( glyph_buf, glyph_buf_size ) )
      goto Fail;
    if ( FT_QNEW_ARRAY( info->x_mins, num_glyphs ) )
      goto Fail;
    for ( i = 0; i < num_glyphs; ++i )
    {
      FT_ULong   glyph_size = 0;
      FT_UShort  n_contours = 0;
      FT_Bool    have_bbox  = FALSE;
      FT_Byte    bbox_bitmap;
      FT_ULong   bbox_offset;
      FT_UShort  x_min      = 0;
      bbox_offset = bbox_bitmap_offset + ( i >> 3 );
      if ( FT_STREAM_SEEK( bbox_offset ) ||
           FT_READ_BYTE( bbox_bitmap )   )
        goto Fail;
      if ( bbox_bitmap & ( 0x80 >> ( i & 7 ) ) )
        have_bbox = TRUE;
      if ( FT_STREAM_SEEK( substreams[N_CONTOUR_STREAM].offset ) ||
           FT_READ_USHORT( n_contours )                          )
        goto Fail;
      substreams[N_CONTOUR_STREAM].offset += 2;
      if ( n_contours == 0xffff )
      {
        FT_Bool    have_instructions = FALSE;
        FT_UShort  instruction_size  = 0;
        FT_ULong   composite_size    = 0;
        FT_ULong   size_needed;
        FT_Byte*   pointer           = NULL;
        if ( !have_bbox )
          goto Fail;
        if ( compositeGlyph_size( stream,
                                  substreams[COMPOSITE_STREAM].offset,
                                  &composite_size,
                                  &have_instructions) )
          goto Fail;
        if ( have_instructions )
        {
          if ( FT_STREAM_SEEK( substreams[GLYPH_STREAM].offset ) ||
               READ_255USHORT( instruction_size )                )
            goto Fail;
          substreams[GLYPH_STREAM].offset = FT_STREAM_POS();
        }
        size_needed = 12 + composite_size + instruction_size;
        if ( glyph_buf_size < size_needed )
        {
          if ( FT_QREALLOC( glyph_buf, glyph_buf_size, size_needed ) )
            goto Fail;
          glyph_buf_size = size_needed;
        }
        pointer = glyph_buf + glyph_size;
        glyph_size += 2;
        if ( FT_STREAM_SEEK( substreams[BBOX_STREAM].offset ) ||
             FT_READ_USHORT( x_min )                          )
          goto Fail;
        if ( FT_STREAM_SEEK( substreams[BBOX_STREAM].offset ) ||
             FT_STREAM_READ( glyph_buf + glyph_size, 8 )      )
          goto Fail;
        substreams[BBOX_STREAM].offset += 8;
        glyph_size                     += 8;
        if ( FT_STREAM_SEEK( substreams[COMPOSITE_STREAM].offset )    ||
             FT_STREAM_READ( glyph_buf + glyph_size, composite_size ) )
          goto Fail;
        substreams[COMPOSITE_STREAM].offset += composite_size;
        glyph_size                          += composite_size;
        if ( have_instructions )
        {
          pointer = glyph_buf + glyph_size;
          WRITE_USHORT( pointer, instruction_size );
          glyph_size += 2;
          if ( FT_STREAM_SEEK( substreams[INSTRUCTION_STREAM].offset )    ||
               FT_STREAM_READ( glyph_buf + glyph_size, instruction_size ) )
            goto Fail;
          substreams[INSTRUCTION_STREAM].offset += instruction_size;
          glyph_size                            += instruction_size;
        }
      }
      else if ( n_contours > 0 )
      {
        FT_ULong   total_n_points = 0;
        FT_UShort  n_points_contour;
        FT_UInt    j;
        FT_ULong   flag_size;
        FT_ULong   triplet_size;
        FT_ULong   triplet_bytes_used;
        FT_Bool    have_overlap  = FALSE;
        FT_Byte    overlap_bitmap;
        FT_ULong   overlap_offset;
        FT_Byte*   flags_buf     = NULL;
        FT_Byte*   triplet_buf   = NULL;
        FT_UShort  instruction_size;
        FT_ULong   size_needed;
        FT_Int     end_point;
        FT_UInt    contour_ix;
        FT_Byte*   pointer = NULL;
        if ( overlap_bitmap_offset )
        {
          overlap_offset = overlap_bitmap_offset + ( i >> 3 );
          if ( FT_STREAM_SEEK( overlap_offset ) ||
               FT_READ_BYTE( overlap_bitmap )   )
            goto Fail;
          if ( overlap_bitmap & ( 0x80 >> ( i & 7 ) ) )
            have_overlap = TRUE;
        }
        if ( FT_QNEW_ARRAY( n_points_arr, n_contours ) )
          goto Fail;
        if ( FT_STREAM_SEEK( substreams[N_POINTS_STREAM].offset ) )
          goto Fail;
        for ( j = 0; j < n_contours; ++j )
        {
          if ( READ_255USHORT( n_points_contour ) )
            goto Fail;
          n_points_arr[j] = n_points_contour;
          if ( total_n_points + n_points_contour < total_n_points )
            goto Fail;
          total_n_points += n_points_contour;
        }
        substreams[N_POINTS_STREAM].offset = FT_STREAM_POS();
        flag_size = total_n_points;
        if ( flag_size > substreams[FLAG_STREAM].size )
          goto Fail;
        flags_buf   = stream->base + substreams[FLAG_STREAM].offset;
        triplet_buf = stream->base + substreams[GLYPH_STREAM].offset;
        if ( substreams[GLYPH_STREAM].size <
               ( substreams[GLYPH_STREAM].offset -
                 substreams[GLYPH_STREAM].start ) )
          goto Fail;
        triplet_size       = substreams[GLYPH_STREAM].size -
                               ( substreams[GLYPH_STREAM].offset -
                                 substreams[GLYPH_STREAM].start );
        triplet_bytes_used = 0;
        points_size = total_n_points;
        if ( FT_QNEW_ARRAY( points, points_size ) )
          goto Fail;
        if ( triplet_decode( flags_buf,
                             triplet_buf,
                             triplet_size,
                             total_n_points,
                             points,
                             &triplet_bytes_used ) )
          goto Fail;
        substreams[FLAG_STREAM].offset  += flag_size;
        substreams[GLYPH_STREAM].offset += triplet_bytes_used;
        if ( FT_STREAM_SEEK( substreams[GLYPH_STREAM].offset ) ||
             READ_255USHORT( instruction_size )                )
          goto Fail;
        substreams[GLYPH_STREAM].offset = FT_STREAM_POS();
        if ( total_n_points >= ( 1 << 27 ) )
          goto Fail;
        size_needed = 12 +
                      ( 2 * n_contours ) +
                      ( 5 * total_n_points ) +
                      instruction_size;
        if ( glyph_buf_size < size_needed )
        {
          if ( FT_QREALLOC( glyph_buf, glyph_buf_size, size_needed ) )
            goto Fail;
          glyph_buf_size = size_needed;
        }
        pointer = glyph_buf + glyph_size;
        WRITE_USHORT( pointer, n_contours );
        glyph_size += 2;
        if ( have_bbox )
        {
          if ( FT_STREAM_SEEK( substreams[BBOX_STREAM].offset ) ||
               FT_READ_USHORT( x_min )                          )
            goto Fail;
          if ( FT_STREAM_SEEK( substreams[BBOX_STREAM].offset ) ||
               FT_STREAM_READ( glyph_buf + glyph_size, 8 )      )
            goto Fail;
          substreams[BBOX_STREAM].offset += 8;
        }
        else
          compute_bbox( total_n_points, points, glyph_buf, &x_min );
        glyph_size = CONTOUR_OFFSET_END_POINT;
        pointer   = glyph_buf + glyph_size;
        end_point = -1;
        for ( contour_ix = 0; contour_ix < n_contours; ++contour_ix )
        {
          end_point += n_points_arr[contour_ix];
          if ( end_point >= 65536 )
            goto Fail;
          WRITE_SHORT( pointer, end_point );
          glyph_size += 2;
        }
        WRITE_USHORT( pointer, instruction_size );
        glyph_size += 2;
        if ( FT_STREAM_SEEK( substreams[INSTRUCTION_STREAM].offset )    ||
             FT_STREAM_READ( glyph_buf + glyph_size, instruction_size ) )
          goto Fail;
        substreams[INSTRUCTION_STREAM].offset += instruction_size;
        glyph_size                            += instruction_size;
        if ( store_points( total_n_points,
                           points,
                           n_contours,
                           instruction_size,
                           have_overlap,
                           glyph_buf,
                           glyph_buf_size,
                           &glyph_size ) )
          goto Fail;
        FT_FREE( points );
        FT_FREE( n_points_arr );
      }
      else
      {
        if ( have_bbox )
        {
          FT_ERROR(( "Empty glyph has a bbox.\n" ));
          goto Fail;
        }
      }
      loca_values[i] = dest_offset - glyf_start;
      if ( WRITE_SFNT_BUF( glyph_buf, glyph_size ) )
        goto Fail;
      if ( pad4( &sfnt, sfnt_size, &dest_offset, memory ) )
        goto Fail;
      *glyf_checksum += compute_ULong_sum( glyph_buf, glyph_size );
      info->x_mins[i] = (FT_Short)x_min;
    }
    info->glyf_table->dst_length = dest_offset - info->glyf_table->dst_offset;
    info->loca_table->dst_offset = dest_offset;
    loca_values[num_glyphs] = info->glyf_table->dst_length;
    if ( store_loca( loca_values,
                     num_glyphs + 1,
                     index_format,
                     loca_checksum,
                     &sfnt,
                     sfnt_size,
                     &dest_offset,
                     memory ) )
      goto Fail;
    info->loca_table->dst_length = dest_offset - info->loca_table->dst_offset;
    FT_TRACE4(( "  loca table info:\n" ));
    FT_TRACE4(( "    dst_offset = %lu\n", info->loca_table->dst_offset ));
    FT_TRACE4(( "    dst_length = %lu\n", info->loca_table->dst_length ));
    FT_TRACE4(( "    checksum = %09lx\n", *loca_checksum ));
    *sfnt_bytes = sfnt;
    *out_offset = dest_offset;
    FT_FREE( substreams );
    FT_FREE( loca_values );
    FT_FREE( n_points_arr );
    FT_FREE( glyph_buf );
    FT_FREE( points );
    return error;
  Fail:
    if ( !error )
      error = FT_THROW( Invalid_Table );
    *sfnt_bytes = sfnt;
    FT_FREE( substreams );
    FT_FREE( loca_values );
    FT_FREE( n_points_arr );
    FT_FREE( glyph_buf );
    FT_FREE( points );
    return error;
  }
