static int rxq_refill(struct rx_queue *rxq, int budget)
{
	struct mv643xx_eth_private *mp = rxq_to_mp(rxq);
	int refilled;
	refilled = 0;
	while (refilled < budget && rxq->rx_desc_count < rxq->rx_ring_size) {
		struct sk_buff *skb;
		int rx;
		struct rx_desc *rx_desc;
		int size;
		skb = netdev_alloc_skb(mp->dev, mp->skb_size);
		if (skb == NULL) {
			mp->oom = 1;
			goto oom;
		}
		if (SKB_DMA_REALIGN)
		refilled++;
		rxq->rx_desc_count++;
		rx = rxq->rx_used_desc++;
		if (rxq->rx_used_desc == rxq->rx_ring_size)
			rxq->rx_used_desc = 0;
		rx_desc = rxq->rx_desc_area + rx;
		size = skb_end_pointer(skb) - skb->data;
		rx_desc->buf_ptr = dma_map_single(mp->dev->dev.parent,
						  skb->data, size,
						  DMA_FROM_DEVICE);
		rx_desc->buf_size = size;
		rxq->rx_skb[rx] = skb;
		wmb();
		rx_desc->cmd_sts = BUFFER_OWNED_BY_DMA | RX_ENABLE_INTERRUPT;
		wmb();
		skb_reserve(skb, 2);
	}
	if (refilled < budget)
		mp->work_rx_refill &= ~(1 << rxq->index);
oom:
	return refilled;
}
