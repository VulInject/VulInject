dissect_thrift_compact_struct(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int *offset, thrift_option_data_t *thrift_opt)
{
    proto_tree *sub_tree;
    proto_item *pi;
    guint nested_count = p_get_proto_depth(pinfo, proto_thrift);
    ABORT_ON_INCOMPLETE_PDU(TCP_THRIFT_STRUCT_LEN);
	if ((unsigned int)nested_count >= thrift_opt->nested_type_depth)
        expert_add_info(pinfo, proto_tree_get_parent(tree), &ei_thrift_too_many_subtypes);
        return THRIFT_REQUEST_REASSEMBLY;
    }
