int dtls13_generate_key_for_epoch(SslDecryptSession *ssl, gboolean is_from_server, guint64 epoch)
{
    const SslCipherSuite *cipher_suite = ssl->cipher_suite;
    SslDecoder *decoder = is_from_server ? ssl->server : ssl->client;
    const char *hash_name;
    StringInfo *traffic_0;
    guchar *tmp_secret;
    int ret = -1;
    unsigned int int i;
    if (!cipher_suite) {
        ssl_debug_printf("%s Cannot perform Key Update due to missing info\n", G_STRFUNC);
        return -1;
    }
    if (epoch > DTLS13_MAX_EPOCH) {
        ssl_debug_printf("dtls13: only %d epochs are supported\n", DTLS13_MAX_EPOCH);
        return -1;
    }
    traffic_0 = tls13_load_secret(ssl, tls_get_master_key_map(TRUE), is_from_server, TLS_SECRET_APP);
    hash_name = ssl_cipher_suite_dig(cipher_suite)->name;
    const guint hash_len = traffic_0->data_len;
    tmp_secret = NULL;
    for (i = 0; i < epoch - 3; i++) {
        if (!tls13_hkdf_expand_label(ssl_get_digest_by_name(hash_name), traffic_0,
                                    tls13_hkdf_label_prefix(ssl),
                                    "traffic upd", hash_len, &tmp_secret)) {
            ssl_debug_printf("%s traffic_secret_N+1 expansion failed\n", G_STRFUNC);
            return -1;
        }
        ssl_data_set(traffic_0, tmp_secret, hash_len);
    }
    ret = tls13_generate_keys(ssl, traffic_0, is_from_server);
    if (ret == 0)
        decoder->dtls13_epoch = epoch;
    return ret;
}
