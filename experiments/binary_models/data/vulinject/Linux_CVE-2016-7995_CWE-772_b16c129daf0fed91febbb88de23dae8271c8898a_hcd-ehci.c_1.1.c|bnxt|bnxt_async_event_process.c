static int bnxt_async_event_process(struct bnxt *bp,
				    struct hwrm_async_event_cmpl *cmpl)
{
	unsigned short event_id = le16_to_cpu(cmpl->event_id);
	unsigned int data1 = le32_to_cpu(cmpl->event_data1);
	unsigned int data2 = le32_to_cpu(cmpl->event_data2);
	netdev_dbg(bp->dev, "hwrm event 0x%x {0x%x, 0x%x}\n",
		   event_id, data1, data2);
	switch (event_id) {
	case ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CFG_CHANGE: {
		struct bnxt_link_info *link_info = &bp->link_info;
		if (BNXT_VF(bp))
			goto async_event_process_exit;
		if (!(link_info->autoneg & BNXT_AUTONEG_SPEED) &&
		    (data1 & 0x20000)) {
			unsigned short fw_speed = bnxt_get_force_speed(link_info);
			unsigned int speed = bnxt_fw_to_ethtool_speed(fw_speed);
			if (speed != SPEED_UNKNOWN)
				netdev_warn(bp->dev, "Link speed %d no longer supported\n",
					    speed);
		}
		set_bit(BNXT_LINK_SPEED_CHNG_SP_EVENT, &bp->sp_event);
	}
		fallthrough;
	case ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CHANGE:
	case ASYNC_EVENT_CMPL_EVENT_ID_PORT_PHY_CFG_CHANGE:
		set_bit(BNXT_LINK_CFG_CHANGE_SP_EVENT, &bp->sp_event);
		fallthrough;
	case ASYNC_EVENT_CMPL_EVENT_ID_LINK_STATUS_CHANGE:
		set_bit(BNXT_LINK_CHNG_SP_EVENT, &bp->sp_event);
		break;
	case ASYNC_EVENT_CMPL_EVENT_ID_PF_DRVR_UNLOAD:
		set_bit(BNXT_HWRM_PF_UNLOAD_SP_EVENT, &bp->sp_event);
		break;
	case ASYNC_EVENT_CMPL_EVENT_ID_PORT_CONN_NOT_ALLOWED: {
		unsigned short port_id = BNXT_GET_EVENT_PORT(data1);
		if (BNXT_VF(bp))
			break;
		if (bp->pf.port_id != port_id)
			break;
		set_bit(BNXT_HWRM_PORT_MODULE_SP_EVENT, &bp->sp_event);
		break;
	}
	case ASYNC_EVENT_CMPL_EVENT_ID_VF_CFG_CHANGE:
		if (BNXT_PF(bp))
			goto async_event_process_exit;
		set_bit(BNXT_RESET_TASK_SILENT_SP_EVENT, &bp->sp_event);
		break;
	case ASYNC_EVENT_CMPL_EVENT_ID_RESET_NOTIFY: {
		char *type_str = "Solicited";
		if (!bp->fw_health)
			goto async_event_process_exit;
		bp->fw_reset_timestamp = jiffies;
		bp->fw_reset_min_dsecs = cmpl->timestamp_lo;
		if (!bp->fw_reset_min_dsecs)
			bp->fw_reset_min_dsecs = BNXT_DFLT_FW_RST_MIN_DSECS;
		bp->fw_reset_max_dsecs = le16_to_cpu(cmpl->timestamp_hi);
		if (!bp->fw_reset_max_dsecs)
			bp->fw_reset_max_dsecs = BNXT_DFLT_FW_RST_MAX_DSECS;
		if (EVENT_DATA1_RESET_NOTIFY_FW_ACTIVATION(data1)) {
			set_bit(BNXT_STATE_FW_ACTIVATE_RESET, &bp->state);
		} else if (EVENT_DATA1_RESET_NOTIFY_FATAL(data1)) {
			type_str = "Fatal";
			bp->fw_health->fatalities++;
			set_bit(BNXT_STATE_FW_FATAL_COND, &bp->state);
		} else if (data2 && BNXT_FW_STATUS_HEALTHY !=
			   EVENT_DATA2_RESET_NOTIFY_FW_STATUS_CODE(data2)) {
			type_str = "Non-fatal";
			bp->fw_health->survivals++;
			set_bit(BNXT_STATE_FW_NON_FATAL_COND, &bp->state);
		}
		netif_warn(bp, hw, bp->dev,
			   "%s firmware reset event, data1: 0x%x, data2: 0x%x, min wait %u ms, max wait %u ms\n",
			   type_str, data1, data2,
			   bp->fw_reset_min_dsecs * 100,
			   bp->fw_reset_max_dsecs * 100);
		set_bit(BNXT_FW_RESET_NOTIFY_SP_EVENT, &bp->sp_event);
		break;
	}
	case ASYNC_EVENT_CMPL_EVENT_ID_ERROR_RECOVERY: {
		struct bnxt_fw_health *fw_health = bp->fw_health;
		char *status_desc = "healthy";
		unsigned int status;
		if (!fw_health)
			goto async_event_process_exit;
		if (!EVENT_DATA1_RECOVERY_ENABLED(data1)) {
			fw_health->enabled = false;
			netif_info(bp, drv, bp->dev, "Driver recovery watchdog is disabled\n");
			break;
		}
		fw_health->primary = EVENT_DATA1_RECOVERY_MASTER_FUNC(data1);
		fw_health->tmr_multiplier =
			DIV_ROUND_UP(fw_health->polling_dsecs * HZ,
				     bp->current_interval * 10);
		fw_health->tmr_counter = fw_health->tmr_multiplier;
		if (!fw_health->enabled)
			fw_health->last_fw_heartbeat =
				bnxt_fw_health_readl(bp, BNXT_FW_HEARTBEAT_REG);
		fw_health->last_fw_reset_cnt =
			bnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);
		status = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);
		if (status != BNXT_FW_STATUS_HEALTHY)
			status_desc = "unhealthy";
		netif_info(bp, drv, bp->dev,
			   "Driver recovery watchdog, role: %s, firmware status: 0x%x (%s), resets: %u\n",
			   fw_health->primary ? "primary" : "backup", status,
			   status_desc, fw_health->last_fw_reset_cnt);
		if (!fw_health->enabled) {
			smp_wmb();
			fw_health->enabled = true;
		}
		goto async_event_process_exit;
	}
	case ASYNC_EVENT_CMPL_EVENT_ID_DEBUG_NOTIFICATION:
		netif_notice(bp, hw, bp->dev,
			     "Received firmware debug notification, data1: 0x%x, data2: 0x%x\n",
			     data1, data2);
		goto async_event_process_exit;
	case ASYNC_EVENT_CMPL_EVENT_ID_RING_MONITOR_MSG: {
		struct bnxt_rx_ring_info *rxr;
		unsigned short grp_idx;
		if (bp->flags & BNXT_FLAG_CHIP_P5_PLUS)
			goto async_event_process_exit;
		netdev_warn(bp->dev, "Ring monitor event, ring type %lu id 0x%x\n",
			    BNXT_EVENT_RING_TYPE(data2), data1);
		if (!BNXT_EVENT_RING_TYPE_RX(data2))
			goto async_event_process_exit;
		grp_idx = bnxt_agg_ring_id_to_grp_idx(bp, data1);
		if (grp_idx == INVALID_HW_RING_ID) {
			netdev_warn(bp->dev, "Unknown RX agg ring id 0x%x\n",
				    data1);
			goto async_event_process_exit;
		}
		rxr = bp->bnapi[grp_idx]->rx_ring;
		bnxt_sched_reset_rxr(bp, rxr);
		goto async_event_process_exit;
	}
	case ASYNC_EVENT_CMPL_EVENT_ID_ECHO_REQUEST: {
		struct bnxt_fw_health *fw_health = bp->fw_health;
		netif_notice(bp, hw, bp->dev,
			     "Received firmware echo request, data1: 0x%x, data2: 0x%x\n",
			     data1, data2);
		if (fw_health) {
			fw_health->echo_req_data1 = data1;
			fw_health->echo_req_data2 = data2;
			set_bit(BNXT_FW_ECHO_REQUEST_SP_EVENT, &bp->sp_event);
			break;
		}
		goto async_event_process_exit;
	}
	case ASYNC_EVENT_CMPL_EVENT_ID_PPS_TIMESTAMP: {
		bnxt_ptp_pps_event(bp, data1, data2);
		goto async_event_process_exit;
	}
	case ASYNC_EVENT_CMPL_EVENT_ID_ERROR_REPORT: {
		if (bnxt_event_error_report(bp, data1, data2))
			break;
		goto async_event_process_exit;
	}
	case ASYNC_EVENT_CMPL_EVENT_ID_PHC_UPDATE: {
		switch (BNXT_EVENT_PHC_EVENT_TYPE(data1)) {
		case ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_PHC_RTC_UPDATE:
			if (BNXT_PTP_USE_RTC(bp)) {
				struct bnxt_ptp_cfg *ptp = bp->ptp_cfg;
				unsigned int int ns;
				if (!ptp)
					goto async_event_process_exit;
				bnxt_ptp_update_current_time(bp);
				ns = (((unsigned int int)BNXT_EVENT_PHC_RTC_UPDATE(data1) <<
				       BNXT_PHC_BITS) | ptp->current_time);
				bnxt_ptp_rtc_timecounter_init(ptp, ns);
				spin_unlock_bh(&ptp->ptp_lock);
			}
			break;
		}
		goto async_event_process_exit;
	}
	case ASYNC_EVENT_CMPL_EVENT_ID_DEFERRED_RESPONSE: {
		unsigned short seq_id = le32_to_cpu(cmpl->event_data2) & 0xffff;
		hwrm_update_token(bp, seq_id, BNXT_HWRM_DEFERRED);
		goto async_event_process_exit;
	}
	default:
		goto async_event_process_exit;
	}
	__bnxt_queue_sp_work(bp);
async_event_process_exit:
	return 0;
}
