main(int argc, char *argv[])
{
    char         *configuration_init_error;
    static const struct report_message_routines editcap_report_routines = {
        failure_message,
        failure_message,
        open_failure_message,
        read_failure_message,
        write_failure_message,
        cfile_open_failure_message,
        cfile_dump_open_failure_message,
        cfile_read_failure_message,
        cfile_write_failure_message,
        cfile_close_failure_message
    };
    wtap         *wth = NULL;
    int           i, j, read_err, write_err;
    gchar        *read_err_info, *write_err_info;
    int           opt;
#define LONGOPT_NO_VLAN              LONGOPT_BASE_APPLICATION+1
#define LONGOPT_SKIP_RADIOTAP_HEADER LONGOPT_BASE_APPLICATION+2
#define LONGOPT_SEED                 LONGOPT_BASE_APPLICATION+3
#define LONGOPT_INJECT_SECRETS       LONGOPT_BASE_APPLICATION+4
#define LONGOPT_DISCARD_ALL_SECRETS  LONGOPT_BASE_APPLICATION+5
#define LONGOPT_CAPTURE_COMMENT      LONGOPT_BASE_APPLICATION+6
#define LONGOPT_DISCARD_CAPTURE_COMMENT LONGOPT_BASE_APPLICATION+7
#define LONGOPT_SET_UNUSED           LONGOPT_BASE_APPLICATION+8
#define LONGOPT_DISCARD_PACKET_COMMENTS LONGOPT_BASE_APPLICATION+9
    static const struct ws_option long_options[] = {
        {"novlan", ws_no_argument, NULL, LONGOPT_NO_VLAN},
        {"skip-radiotap-header", ws_no_argument, NULL, LONGOPT_SKIP_RADIOTAP_HEADER},
        {"seed", ws_required_argument, NULL, LONGOPT_SEED},
        {"inject-secrets", ws_required_argument, NULL, LONGOPT_INJECT_SECRETS},
        {"discard-all-secrets", ws_no_argument, NULL, LONGOPT_DISCARD_ALL_SECRETS},
        {"help", ws_no_argument, NULL, 'h'},
        {"version", ws_no_argument, NULL, 'v'},
        {"capture-comment", ws_required_argument, NULL, LONGOPT_CAPTURE_COMMENT},
        {"discard-capture-comment", ws_no_argument, NULL, LONGOPT_DISCARD_CAPTURE_COMMENT},
        {"set-unused", ws_no_argument, NULL, LONGOPT_SET_UNUSED},
        {"discard-packet-comments", ws_no_argument, NULL, LONGOPT_DISCARD_PACKET_COMMENTS},
        {0, 0, 0, 0 }
    };
    char         *p;
    guint32       snaplen            = 0; 
    chop_t        chop               = {0, 0, 0, 0, 0, 0}; 
    gboolean      adjlen             = FALSE;
    wtap_dumper  *pdh                = NULL;
    GArray       *idbs_seen          = NULL;
    unsigned int  count              = 1;
    unsigned int  duplicate_count    = 0;
    gint64        data_offset;
    int           err_type;
    guint8       *buf;
    guint32       read_count         = 0;
    guint32       split_packet_count = 0;
    int           written_count      = 0;
    char         *filename           = NULL;
    gboolean      ts_okay;
    nstime_t      secs_per_block     = NSTIME_INIT_UNSET;
    int           block_cnt          = 0;
    nstime_t      block_next         = NSTIME_INIT_UNSET;
    gchar        *fprefix            = NULL;
    gchar        *fsuffix            = NULL;
    guint32       change_offset      = 0;
    guint         max_packet_number  = 0;
    GArray       *dsb_types          = NULL;
    GPtrArray    *dsb_filenames      = NULL;
    wtap_rec                     read_rec;
    Buffer                       read_buf;
    const wtap_rec              *rec;
    wtap_rec                     temp_rec;
    wtap_dump_params             params = WTAP_DUMP_PARAMS_INIT;
    char                        *shb_user_appl;
    gboolean                     do_mutation;
    guint32                      caplen;
    int                          ret = EXIT_SUCCESS;
    gboolean                     valid_seed = FALSE;
    unsigned int                 seed = 0;
    memset(&read_rec, 0, sizeof *rec);
    ws_log_init("editcap", vcmdarg_err);
    ws_log_parse_args(&argc, argv, vcmdarg_err, WS_EXIT_INVALID_OPTION);
    ws_noisy("Finished log init and parsing command line log arguments");
#ifdef _WIN32
    create_app_running_mutex();
#endif 
    ws_init_version_info("Editcap", NULL, NULL);
    init_process_policies();
    configuration_init_error = configuration_init(argv[0], NULL);
    if (configuration_init_error != NULL) {
        fprintf(stderr,
                "editcap: Can't get pathname of directory containing the editcap program: %s.\n",
                configuration_init_error);
        g_free(configuration_init_error);
    }
    init_report_message("editcap", &editcap_report_routines);
    wtap_init(TRUE);
    while ((opt = ws_getopt_long(argc, argv, ":a:A:B:c:C:dD:E:F:hi:I:Lo:rs:S:t:T:vVw:", long_options, NULL)) != -1) {
        switch (opt) {
        case LONGOPT_NO_VLAN:
        {
            rem_vlan = TRUE;
            break;
        }
        case LONGOPT_SKIP_RADIOTAP_HEADER:
        {
            skip_radiotap = TRUE;
            break;
        }
        case LONGOPT_SEED:
        {
            if (sscanf(ws_optarg, "%u", &seed) != 1) {
                fprintf(stderr, "editcap: \"%s\" isn't a valid seed\n\n",
                        ws_optarg);
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            valid_seed = TRUE;
            break;
        }
        case LONGOPT_INJECT_SECRETS:
        {
            guint32 secrets_type_id = 0;
            const char *secrets_filename = NULL;
            if (strcmp("help", ws_optarg) == 0) {
                list_secrets_types(stdout);
                goto clean_exit;
            }
            gchar **splitted = g_strsplit(ws_optarg, ",", 2);
            if (splitted[0] && splitted[0][0] != '\0') {
                secrets_type_id = lookup_secrets_type(splitted[0]);
                if (secrets_type_id == 0) {
                    fprintf(stderr, "editcap: \"%s\" isn't a valid secrets type\n", splitted[0]);
                    g_strfreev(splitted);
                    ret = WS_EXIT_INVALID_OPTION;
                    goto clean_exit;
                }
                secrets_filename = splitted[1];
            } else {
                fprintf(stderr, "editcap: no secrets type was specified for --inject-secrets\n");
                g_strfreev(splitted);
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            if (!dsb_filenames) {
                dsb_types = g_array_new(FALSE, FALSE, sizeof(guint32));
                dsb_filenames = g_ptr_array_new_with_free_func(g_free);
            }
            g_array_append_val(dsb_types, secrets_type_id);
            g_ptr_array_add(dsb_filenames, g_strdup(secrets_filename));
            g_strfreev(splitted);
            break;
        }
        case LONGOPT_DISCARD_ALL_SECRETS:
        {
            discard_all_secrets = TRUE;
            break;
        }
        case LONGOPT_CAPTURE_COMMENT:
        {
            if (strlen(ws_optarg) > 65535) {
                cmdarg_err("Capture comment %u is too large to save in a capture file.",
                           capture_comments->len + 1);
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            if (!capture_comments) {
                capture_comments = g_ptr_array_new_with_free_func(g_free);
            }
            g_ptr_array_add(capture_comments, g_strdup(ws_optarg));
            break;
        }
        case LONGOPT_DISCARD_CAPTURE_COMMENT:
        {
            discard_cap_comments = TRUE;
            break;
        }
        case LONGOPT_SET_UNUSED:
        {
            set_unused = TRUE;
            break;
        }
        case LONGOPT_DISCARD_PACKET_COMMENTS:
        {
            discard_pkt_comments = TRUE;
            break;
        }
        case 'a':
        {
            guint frame_number;
            gint string_start_index = 0;
            if ((sscanf(ws_optarg, "%u:%n", &frame_number, &string_start_index) < 1) || (string_start_index == 0)) {
                fprintf(stderr, "editcap: \"%s\" isn't a valid <frame>:<comment>\n\n",
                        ws_optarg);
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            if (strlen(ws_optarg+string_start_index) > 65535) {
                cmdarg_err("A comment for frame %u is too large to save in a capture file.",
                           frame_number);
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            if (!frames_user_comments) {
                frames_user_comments = g_tree_new_full(framenum_compare, NULL, NULL, g_free);
            }
            g_tree_replace(frames_user_comments, GUINT_TO_POINTER(frame_number), g_strdup(ws_optarg+string_start_index));
            break;
        }
        case 'A':
        case 'B':
        {
            nstime_t in_time;
            check_startstop = TRUE;
            if ((NULL != iso8601_to_nstime(&in_time, ws_optarg, ISO8601_DATETIME)) || (NULL != unix_epoch_to_nstime(&in_time, ws_optarg))) {
                if (opt == 'A') {
                    nstime_copy(&starttime, &in_time);
                    have_starttime = TRUE;
                } else {
                    nstime_copy(&stoptime, &in_time);
                    have_stoptime = TRUE;
                }
                break;
            }
            else {
                fprintf(stderr, "editcap: \"%s\" isn't a valid date and time\n\n",
                        ws_optarg);
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
        }
        case 'c':
            split_packet_count = get_nonzero_guint32(ws_optarg, "packet count");
            break;
        case 'C':
        {
            int choplen = 0, chopoff = 0;
            switch (sscanf(ws_optarg, "%d:%d", &chopoff, &choplen)) {
            case 1: 
                choplen = chopoff;
                chopoff = 0;
                break;
            case 2: 
                break;
            default:
                fprintf(stderr, "editcap: \"%s\" isn't a valid chop length or offset:length\n",
                        ws_optarg);
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
                break;
            }
            if (choplen > 0) {
                chop.len_begin += choplen;
                if (chopoff > 0)
                    chop.off_begin_pos += chopoff;
                else
                    chop.off_begin_neg += chopoff;
            } else if (choplen < 0) {
                chop.len_end += choplen;
                if (chopoff > 0)
                    chop.off_end_pos += chopoff;
                else
                    chop.off_end_neg += chopoff;
            }
            break;
        }
        case 'd':
            dup_detect = TRUE;
            dup_detect_by_time = FALSE;
            dup_window = DEFAULT_DUP_DEPTH;
            break;
        case 'D':
            dup_detect = TRUE;
            dup_detect_by_time = FALSE;
            dup_window = get_guint32(ws_optarg, "duplicate window");
            if (dup_window > MAX_DUP_DEPTH) {
                fprintf(stderr, "editcap: \"%d\" duplicate window value must be between 0 and %d inclusive.\n",
                        dup_window, MAX_DUP_DEPTH);
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            break;
        case 'E':
            err_prob = g_ascii_strtod(ws_optarg, &p);
            if (p == ws_optarg || err_prob < 0.0 || err_prob > 1.0) {
                fprintf(stderr, "editcap: probability \"%s\" must be between 0.0 and 1.0\n",
                        ws_optarg);
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            break;
        case 'F':
            out_file_type_subtype = wtap_name_to_file_type_subtype(ws_optarg);
            if (out_file_type_subtype < 0) {
                fprintf(stderr, "editcap: \"%s\" isn't a valid capture file type\n\n",
                        ws_optarg);
                list_capture_types(stderr);
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            break;
        case 'h':
            show_help_header("Edit and/or translate the format of capture files.");
            print_usage(stdout);
            goto clean_exit;
            break;
        case 'i': 
        {
            double spb = get_positive_double(ws_optarg, "time interval");
            if (spb == 0.0) {
              cmdarg_err("The specified interval is zero");
              ret = WS_EXIT_INVALID_OPTION;
              goto clean_exit;
            }
            double spb_int, spb_frac;
            spb_frac = modf(spb, &spb_int);
            secs_per_block.secs = (time_t) spb_int;
            secs_per_block.nsecs = (int) (NANOSECS_PER_SEC * spb_frac);
        }
            break;
        case 'I': 
            ignored_bytes = get_guint32(ws_optarg, "number of bytes to ignore");
            break;
        case 'L':
            adjlen = TRUE;
            break;
        case 'o':
            change_offset = get_guint32(ws_optarg, "change offset");
            break;
        case 'r':
            if (keep_em) {
                cmdarg_err("-r was specified twice");
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            keep_em = TRUE;
            break;
        case 's':
            snaplen = get_nonzero_guint32(ws_optarg, "snapshot length");
            break;
        case 'S':
            if (!set_strict_time_adj(ws_optarg)) {
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            do_strict_time_adjustment = TRUE;
            break;
        case 't':
            if (!set_time_adjustment(ws_optarg)) {
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            break;
        case 'T':
            out_frame_type = wtap_name_to_encap(ws_optarg);
            if (out_frame_type < 0) {
                fprintf(stderr, "editcap: \"%s\" isn't a valid encapsulation type\n\n",
                        ws_optarg);
                list_encap_types(stderr);
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            break;
        case 'V':
            if (verbose) {
                cmdarg_err("-V was specified twice");
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            verbose = TRUE;
            break;
        case 'v':
            show_version();
            goto clean_exit;
            break;
        case 'w':
            dup_detect = FALSE;
            dup_detect_by_time = TRUE;
            dup_window = MAX_DUP_DEPTH;
            if (!set_rel_time(ws_optarg)) {
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            break;
        case '?':              
        case ':':              
            switch(ws_optopt) {
            case'F':
                list_capture_types(stdout);
                break;
            case'T':
                list_encap_types(stdout);
                break;
            default:
                if (opt == '?') {
                    fprintf(stderr, "editcap: invalid option -- '%c'\n", ws_optopt);
                } else {
                    fprintf(stderr, "editcap: option requires an argument -- '%c'\n", ws_optopt);
                }
                print_usage(stderr);
                ret = WS_EXIT_INVALID_OPTION;
                break;
            }
            goto clean_exit;
            break;
        }
    } 
#ifdef DEBUG
    fprintf(stderr, "Optind = %i, argc = %i\n", ws_optind, argc);
#endif
    if ((argc - ws_optind) < 2) {
        print_usage(stderr);
        ret = WS_EXIT_INVALID_OPTION;
        goto clean_exit;
    }
    if (out_file_type_subtype == WTAP_FILE_TYPE_SUBTYPE_UNKNOWN) {
      out_file_type_subtype = wtap_pcapng_file_type_subtype();
    }
    if (err_prob >= 0.0) {
        if (!valid_seed) {
            seed = (unsigned int) (time(NULL) + ws_getpid());
        }
        if (verbose) {
            fprintf(stderr, "Using seed %u\n", seed);
        }
        srand(seed);
    }
    if (have_starttime && have_stoptime &&
        nstime_cmp(&starttime, &stoptime) > 0) {
        fprintf(stderr, "editcap: start time is after the stop time\n");
        ret = WS_EXIT_INVALID_OPTION;
        goto clean_exit;
    }
    if (split_packet_count != 0 && !nstime_is_unset(&secs_per_block)) {
        fprintf(stderr, "editcap: can't split on both packet count and time interval\n");
        fprintf(stderr, "editcap: at the same time\n");
        ret = WS_EXIT_INVALID_OPTION;
        goto clean_exit;
    }
    wth = wtap_open_offline(argv[ws_optind], WTAP_TYPE_AUTO, &read_err, &read_err_info, FALSE);
    if (!wth) {
        cfile_open_failure_message(argv[ws_optind], read_err, read_err_info);
        ret = WS_EXIT_INVALID_FILE;
        goto clean_exit;
    }
    if (verbose) {
        fprintf(stderr, "File %s is a %s capture file.\n", argv[ws_optind],
                wtap_file_type_subtype_description(wtap_file_type_subtype(wth)));
    }
    if (skip_radiotap) {
        if (ignored_bytes != 0) {
            fprintf(stderr, "editcap: can't skip radiotap headers and %d byte(s)\n", ignored_bytes);
            fprintf(stderr, "editcap: at the start of packet at the same time\n");
            ret = WS_EXIT_INVALID_OPTION;
            goto clean_exit;
        }
        if (wtap_file_encap(wth) != WTAP_ENCAP_IEEE_802_11_RADIOTAP) {
            fprintf(stderr, "editcap: can't skip radiotap header because input file has non-radiotap packets\n");
            if (wtap_file_encap(wth) == WTAP_ENCAP_PER_PACKET) {
                fprintf(stderr, "editcap: expected '%s', not all packets are necessarily that type\n",
                        wtap_encap_description(WTAP_ENCAP_IEEE_802_11_RADIOTAP));
            } else {
                fprintf(stderr, "editcap: expected '%s', packets are '%s'\n",
                        wtap_encap_description(WTAP_ENCAP_IEEE_802_11_RADIOTAP),
                        wtap_encap_description(wtap_file_encap(wth)));
            }
            ret = WS_EXIT_INVALID_OPTION;
            goto clean_exit;
        }
    }
    wtap_dump_params_init_no_idbs(&params, wth);
    if (discard_all_secrets) {
        wtap_dump_params_discard_decryption_secrets(&params);
    }
    if (discard_cap_comments) {
        for (guint b = 0; b < params.shb_hdrs->len; b++) {
            wtap_block_t shb = g_array_index(params.shb_hdrs, wtap_block_t, b);
            while (WTAP_OPTTYPE_SUCCESS == wtap_block_remove_nth_option_instance(shb, OPT_COMMENT, 0)) {
                continue;
            }
        }
    }
    if (capture_comments != NULL) {
        for (guint b = 0; b < params.shb_hdrs->len; b++) {
            wtap_block_t shb = g_array_index(params.shb_hdrs, wtap_block_t, b);
            for (guint c = 0; c < capture_comments->len; c++) {
                char *comment = (char *)g_ptr_array_index(capture_comments, c);
                wtap_block_add_string_option(shb, OPT_COMMENT, comment, strlen(comment));
            }
        }
    }
    if (dsb_filenames) {
        for (guint k = 0; k < dsb_filenames->len; k++) {
            guint32 secrets_type_id = g_array_index(dsb_types, guint32, k);
            const char *secrets_filename = (const char *)g_ptr_array_index(dsb_filenames, k);
            char *data;
            gsize data_len;
            wtap_block_t block;
            wtapng_dsb_mandatory_t *dsb;
            GError *err = NULL;
            if (!g_file_get_contents(secrets_filename, &data, &data_len, &err)) {
                fprintf(stderr, "editcap: \"%s\" could not be read: %s\n", secrets_filename, err->message);
                g_clear_error(&err);
                ret = WS_EXIT_INVALID_OPTION;
                goto clean_exit;
            }
            if (data_len == 0) {
                fprintf(stderr, "editcap: \"%s\" is an empty file, ignoring\n", secrets_filename);
                g_free(data);
                continue;
            }
            if (data_len >= G_MAXINT) {
                fprintf(stderr, "editcap: \"%s\" is too large, ignoring\n", secrets_filename);
                g_free(data);
                continue;
            }
            validate_secrets_file(secrets_filename, secrets_type_id, data);
            block = wtap_block_create(WTAP_BLOCK_DECRYPTION_SECRETS);
            dsb = (wtapng_dsb_mandatory_t *)wtap_block_get_mandatory_data(block);
            dsb->secrets_type = secrets_type_id;
            dsb->secrets_len = (guint)data_len;
            dsb->secrets_data = data;
            if (params.dsbs_initial == NULL) {
                params.dsbs_initial = g_array_new(FALSE, FALSE, sizeof(wtap_block_t));
            }
            g_array_append_val(params.dsbs_initial, block);
        }
    }
    if (out_frame_type != -2)
        params.encap = out_frame_type;
    if (snaplen != 0 && snaplen < wtap_snapshot_length(wth))
        params.snaplen = snaplen;
    for (i = ws_optind + 2; i < argc; i++)
        if (add_selection(argv[i], &max_packet_number) == FALSE)
            break;
    if (keep_em && max_selected == 0) {
        fprintf(stderr, "editcap: must specify packets to keep when using -r\n");
        ret = WS_EXIT_INVALID_OPTION;
        goto clean_exit;
    }
    if (!keep_em)
        max_packet_number = G_MAXUINT;
    if (dup_detect || dup_detect_by_time) {
        for (i = 0; i < dup_window; i++) {
            memset(&fd_hash[i].digest, 0, 16);
            fd_hash[i].len = 0;
            nstime_set_unset(&fd_hash[i].frame_time);
        }
    }
    idbs_seen = g_array_new(FALSE, FALSE, sizeof(wtap_block_t));
    wtap_rec_init(&read_rec);
    ws_buffer_init(&read_buf, 1514);
    while (wtap_read(wth, &read_rec, &read_buf, &read_err, &read_err_info, &data_offset)) {
        if (max_packet_number <= read_count)
            break;
        read_count++;
        rec = &read_rec;
        if (read_count == 1) {
            if (split_packet_count != 0 || !nstime_is_unset(&secs_per_block)) {
                if (!fileset_extract_prefix_suffix(argv[ws_optind+1], &fprefix, &fsuffix)) {
                    ret = CANT_EXTRACT_PREFIX;
                    goto clean_exit;
                }
                filename = fileset_get_filename_by_pattern(block_cnt++, rec, fprefix, fsuffix);
            } else {
                filename = g_strdup(argv[ws_optind+1]);
            }
            ws_assert(filename);
            if (wtap_block_get_string_option_value(g_array_index(params.shb_hdrs, wtap_block_t, 0), OPT_SHB_USERAPPL, &shb_user_appl) != WTAP_OPTTYPE_SUCCESS) {
                wtap_block_add_string_option_format(g_array_index(params.shb_hdrs, wtap_block_t, 0), OPT_SHB_USERAPPL, "%s", get_appname_and_version());
            }
            pdh = editcap_dump_open(filename, &params, idbs_seen, &write_err,
                                    &write_err_info);
            if (pdh == NULL) {
                cfile_dump_open_failure_message(filename,
                                                write_err, write_err_info,
                                                out_file_type_subtype);
                ret = WS_EXIT_INVALID_FILE;
                goto clean_exit;
            }
        } 
        if (!process_new_idbs(wth, pdh, idbs_seen, &write_err, &write_err_info)) {
            cfile_write_failure_message(argv[ws_optind], filename,
                                        write_err, write_err_info,
                                        read_count,
                                        out_file_type_subtype);
            ret = DUMP_ERROR;
            wtap_dump_close(pdh, NULL, &write_err, &write_err_info);
            goto clean_exit;
        }
        buf = ws_buffer_start_ptr(&read_buf);
        if (rec->presence_flags & WTAP_HAS_TS) {
            if (!nstime_is_unset(&secs_per_block)) {
                if (nstime_is_unset(&block_next)) {
                    block_next = rec->ts;
                    nstime_add(&block_next, &secs_per_block);
                }
                while (nstime_cmp(&rec->ts, &block_next) > 0) { 
                    wtap_block_array_ref(params.dsbs_initial);
                    if (!wtap_dump_close(pdh, NULL, &write_err, &write_err_info)) {
                        cfile_close_failure_message(filename, write_err,
                                                    write_err_info);
                        ret = WRITE_ERROR;
                        goto clean_exit;
                    }
                    g_free(filename);
                    temp_rec = *rec;
                    temp_rec.ts = block_next;
                    filename = fileset_get_filename_by_pattern(block_cnt++, &temp_rec, fprefix, fsuffix);
                    ws_assert(filename);
                    nstime_add(&block_next, &secs_per_block); 
                    if (verbose)
                        fprintf(stderr, "Continuing writing in file %s\n", filename);
                    pdh = editcap_dump_open(filename, &params, idbs_seen,
                                            &write_err, &write_err_info);
                    if (pdh == NULL) {
                        cfile_dump_open_failure_message(filename,
                                                        write_err,
                                                        write_err_info,
                                                        out_file_type_subtype);
                        ret = WS_EXIT_INVALID_FILE;
                        goto clean_exit;
                    }
                }
            }
        }  
        if (split_packet_count != 0) {
            if (written_count > 0 && (written_count % split_packet_count) == 0) {
                wtap_block_array_ref(params.dsbs_initial);
                if (!wtap_dump_close(pdh, NULL, &write_err, &write_err_info)) {
                    cfile_close_failure_message(filename, write_err,
                                                write_err_info);
                    ret = WRITE_ERROR;
                    goto clean_exit;
                }
                g_free(filename);
                filename = fileset_get_filename_by_pattern(block_cnt++, rec, fprefix, fsuffix);
                ws_assert(filename);
                if (verbose)
                    fprintf(stderr, "Continuing writing in file %s\n", filename);
                pdh = editcap_dump_open(filename, &params, idbs_seen,
                                        &write_err, &write_err_info);
                if (pdh == NULL) {
                    cfile_dump_open_failure_message(filename,
                                                    write_err, write_err_info,
                                                    out_file_type_subtype);
                    ret = WS_EXIT_INVALID_FILE;
                    goto clean_exit;
                }
            }
        } 
        if (check_startstop) {
            ts_okay = FALSE;
            if (rec->presence_flags & WTAP_HAS_TS) {
                if (have_starttime && have_stoptime) {
                    ts_okay = nstime_cmp(&rec->ts, &starttime) >= 0 &&
                              nstime_cmp(&rec->ts, &stoptime) < 0;
                } else if (have_starttime) {
                    ts_okay = nstime_cmp(&rec->ts, &starttime) >= 0;
                } else if (have_stoptime) {
                    ts_okay = nstime_cmp(&rec->ts, &stoptime) < 0;
                }
            }
        } else {
            ts_okay = TRUE;
        }
        if (ts_okay && ((!selected(count) && !keep_em)
                        || (selected(count) && keep_em))) {
            if (verbose && !dup_detect && !dup_detect_by_time)
                fprintf(stderr, "Packet: %u\n", count);
            rec = &read_rec;
            if (rec->presence_flags & WTAP_HAS_TS) {
                if (do_strict_time_adjustment) {
                    if (previous_time.secs || previous_time.nsecs) {
                        if (!strict_time_adj.is_negative) {
                            nstime_t current;
                            nstime_t delta;
                            current = rec->ts;
                            nstime_delta(&delta, &current, &previous_time);
                            if (delta.secs < 0 || delta.nsecs < 0) {
                                temp_rec = *rec;
                                temp_rec.ts.secs = previous_time.secs + strict_time_adj.tv.secs;
                                temp_rec.ts.nsecs = previous_time.nsecs;
                                if (temp_rec.ts.nsecs + strict_time_adj.tv.nsecs >= ONE_BILLION) {
                                    temp_rec.ts.secs++;
                                    temp_rec.ts.nsecs += strict_time_adj.tv.nsecs - ONE_BILLION;
                                } else {
                                    temp_rec.ts.nsecs += strict_time_adj.tv.nsecs;
                                }
                                rec = &temp_rec;
                            }
                        } else {
                            temp_rec = *rec;
                            temp_rec.ts.secs = previous_time.secs + strict_time_adj.tv.secs;
                            temp_rec.ts.nsecs = previous_time.nsecs;
                            if (temp_rec.ts.nsecs + strict_time_adj.tv.nsecs >= ONE_BILLION) {
                                temp_rec.ts.secs++;
                                temp_rec.ts.nsecs += strict_time_adj.tv.nsecs - ONE_BILLION;
                            } else {
                                temp_rec.ts.nsecs += strict_time_adj.tv.nsecs;
                            }
                            rec = &temp_rec;
                        }
                    }
                    previous_time = rec->ts;
                }
                if (time_adj.tv.secs != 0) {
                    temp_rec = *rec;
                    if (time_adj.is_negative)
                        temp_rec.ts.secs -= time_adj.tv.secs;
                    else
                        temp_rec.ts.secs += time_adj.tv.secs;
                    rec = &temp_rec;
                }
                if (time_adj.tv.nsecs != 0) {
                    temp_rec = *rec;
                    if (time_adj.is_negative) { 
                        if (temp_rec.ts.nsecs < time_adj.tv.nsecs) { 
                            temp_rec.ts.secs--;
                            temp_rec.ts.nsecs += ONE_BILLION;
                        }
                        temp_rec.ts.nsecs -= time_adj.tv.nsecs;
                    } else {                  
                        if (temp_rec.ts.nsecs + time_adj.tv.nsecs >= ONE_BILLION) {
                            temp_rec.ts.secs++;
                            temp_rec.ts.nsecs += time_adj.tv.nsecs - ONE_BILLION;
                        } else {
                            temp_rec.ts.nsecs += time_adj.tv.nsecs;
                        }
                    }
                    rec = &temp_rec;
                }
            } 
            if (rec->rec_type == REC_TYPE_PACKET) {
                if (snaplen != 0) {
                    if (rec->rec_header.packet_header.caplen > snaplen) {
                        temp_rec = *rec;
                        temp_rec.rec_header.packet_header.caplen = snaplen;
                        rec = &temp_rec;
                    }
                    if (adjlen && rec->rec_header.packet_header.len > snaplen) {
                        temp_rec = *rec;
                        temp_rec.rec_header.packet_header.len = snaplen;
                        rec = &temp_rec;
                    }
                }
                if (out_frame_type != -2) {
                    temp_rec = *rec;
                    temp_rec.rec_header.packet_header.pkt_encap = out_frame_type;
                    rec = &temp_rec;
                }
                temp_rec = *rec;
                handle_chopping(chop, &temp_rec.rec_header.packet_header,
                                &rec->rec_header.packet_header, &buf,
                                adjlen);
                rec = &temp_rec;
                if (set_unused) {
                    set_unused_info(&rec->rec_header.packet_header, buf);
                }
                if (rem_vlan) {
                    temp_rec = *rec;
                    remove_vlan_info(&rec->rec_header.packet_header, buf,
                                     &temp_rec.rec_header.packet_header.caplen);
                    rec = &temp_rec;
                }
                if (dup_detect) {
                    if (is_duplicate(buf, rec->rec_header.packet_header.caplen)) {
                        if (verbose) {
                            fprintf(stderr, "Skipped: %u, Len: %u, MD5 Hash: ",
                                    count,
                                    rec->rec_header.packet_header.caplen);
                            for (i = 0; i < 16; i++)
                                fprintf(stderr, "%02x",
                                        (unsigned char)fd_hash[cur_dup_entry].digest[i]);
                            fprintf(stderr, "\n");
                        }
                        duplicate_count++;
                        count++;
                        continue;
                    } else {
                        if (verbose) {
                            fprintf(stderr, "Packet: %u, Len: %u, MD5 Hash: ",
                                    count,
                                    rec->rec_header.packet_header.caplen);
                            for (i = 0; i < 16; i++)
                                fprintf(stderr, "%02x",
                                        (unsigned char)fd_hash[cur_dup_entry].digest[i]);
                            fprintf(stderr, "\n");
                        }
                    }
                } 
                if (rec->presence_flags & WTAP_HAS_TS) {
                    if (dup_detect_by_time) {
                        nstime_t current;
                        current.secs  = rec->ts.secs;
                        current.nsecs = rec->ts.nsecs;
                        if (is_duplicate_rel_time(buf,
                                                  rec->rec_header.packet_header.caplen,
                                                  &current)) {
                            if (verbose) {
                                fprintf(stderr, "Skipped: %u, Len: %u, MD5 Hash: ",
                                        count,
                                        rec->rec_header.packet_header.caplen);
                                for (i = 0; i < 16; i++)
                                    fprintf(stderr, "%02x",
                                            (unsigned char)fd_hash[cur_dup_entry].digest[i]);
                                fprintf(stderr, "\n");
                            }
                            duplicate_count++;
                            count++;
                            continue;
                        } else {
                            if (verbose) {
                                fprintf(stderr, "Packet: %u, Len: %u, MD5 Hash: ",
                                        count,
                                        rec->rec_header.packet_header.caplen);
                                for (i = 0; i < 16; i++)
                                    fprintf(stderr, "%02x",
                                            (unsigned char)fd_hash[cur_dup_entry].digest[i]);
                                fprintf(stderr, "\n");
                            }
                        }
                    }
                } 
            }
            do_mutation = FALSE;
            caplen = 0;
            if (err_prob > 0.0) {
                switch (rec->rec_type) {
                case REC_TYPE_PACKET:
                    caplen = rec->rec_header.packet_header.caplen;
                    do_mutation = TRUE;
                    break;
                case REC_TYPE_FT_SPECIFIC_EVENT:
                case REC_TYPE_FT_SPECIFIC_REPORT:
                    caplen = rec->rec_header.ft_specific_header.record_len;
                    do_mutation = TRUE;
                    break;
                case REC_TYPE_SYSCALL:
                    caplen = rec->rec_header.syscall_header.event_filelen;
                    do_mutation = TRUE;
                    break;
                case REC_TYPE_SYSTEMD_JOURNAL_EXPORT:
                    caplen = rec->rec_header.systemd_journal_export_header.record_len;
                    do_mutation = TRUE;
                    break;
                }
                if (change_offset > caplen) {
                    fprintf(stderr, "change offset %u is longer than caplen %u in packet %u\n",
                        change_offset, caplen, count);
                    do_mutation = FALSE;
                }
            }
            if (do_mutation) {
                int real_data_start = 0;
                switch (rec->rec_type) {
                case REC_TYPE_PACKET:
                    if (rec->rec_header.packet_header.pkt_encap == WTAP_ENCAP_CATAPULT_DCT2000)
                        real_data_start = find_dct2000_real_data(buf);
                    break;
                }
                real_data_start += change_offset;
                for (i = real_data_start; i < (int) caplen; i++) {
                    if (rand() <= err_prob * RAND_MAX) {
                        err_type = rand() / (RAND_MAX / ERR_WT_TOTAL + 1);
                        if (err_type < ERR_WT_BIT) {
                            buf[i] ^= 1 << (rand() / (RAND_MAX / 8 + 1));
                            err_type = ERR_WT_TOTAL;
                        } else {
                            err_type -= ERR_WT_BYTE;
                        }
                        if (err_type < ERR_WT_BYTE) {
                            buf[i] = rand() / (RAND_MAX / 255 + 1);
                            err_type = ERR_WT_TOTAL;
                        } else {
                            err_type -= ERR_WT_BYTE;
                        }
                        if (err_type < ERR_WT_ALNUM) {
                            buf[i] = ALNUM_CHARS[rand() / (RAND_MAX / ALNUM_LEN + 1)];
                            err_type = ERR_WT_TOTAL;
                        } else {
                            err_type -= ERR_WT_ALNUM;
                        }
                        if (err_type < ERR_WT_FMT) {
                            if ((unsigned int)i < caplen - 2)
                                (void) g_strlcpy((char*) &buf[i], "%s", 2);
                            err_type = ERR_WT_TOTAL;
                        } else {
                            err_type -= ERR_WT_FMT;
                        }
                        if (err_type < ERR_WT_AA) {
                            for (j = i; j < (int) caplen; j++)
                                buf[j] = 0xAA;
                            i = caplen;
                        }
                    }
                }
            } 
            if (discard_pkt_comments) {
                temp_rec = *rec;
                while (WTAP_OPTTYPE_SUCCESS == wtap_block_remove_nth_option_instance(rec->block, OPT_COMMENT, 0)) {
                    temp_rec.block_was_modified = TRUE;
                    continue;
                }
                rec = &temp_rec;
            }
            if (frames_user_comments) {
                const char *comment =
                    (const char*)g_tree_lookup(frames_user_comments, GUINT_TO_POINTER(read_count));
                if (comment != NULL) {
                    temp_rec = *rec;
                    while (WTAP_OPTTYPE_SUCCESS == wtap_block_remove_nth_option_instance(rec->block, OPT_COMMENT, 0)) {
                        temp_rec.block_was_modified = TRUE;
                        continue;
                    }
                    wtap_block_add_string_option(rec->block, OPT_COMMENT, (char *)comment, strlen((char *)comment));
                    temp_rec.block_was_modified = TRUE;
                    rec = &temp_rec;
                } else {
                    temp_rec = *rec;
                    temp_rec.block_was_modified = FALSE;
                    rec = &temp_rec;
                }
            }
            if (discard_all_secrets) {
                wtap_dump_discard_decryption_secrets(pdh);
            }
            if (!wtap_dump(pdh, rec, buf, &write_err, &write_err_info)) {
                cfile_write_failure_message(argv[ws_optind], filename,
                                            write_err, write_err_info,
                                            read_count,
                                            out_file_type_subtype);
                ret = DUMP_ERROR;
                wtap_dump_close(pdh, NULL, &write_err, &write_err_info);
                goto clean_exit;
            }
            written_count++;
        }
        count++;
        wtap_rec_reset(&read_rec);
    }
    wtap_rec_cleanup(&read_rec);
    ws_buffer_free(&read_buf);
    g_free(fprefix);
    g_free(fsuffix);
    if (verbose)
        fprintf(stderr, "Total selected: %d\n", written_count);
    if (read_err != 0) {
        cfile_read_failure_message(argv[ws_optind], read_err, read_err_info);
    }
    if (!pdh) {
        g_free (filename);
        filename = g_strdup(argv[ws_optind+1]);
        pdh = editcap_dump_open(filename, &params, idbs_seen, &write_err,
                                &write_err_info);
        if (pdh == NULL) {
            cfile_dump_open_failure_message(filename,
                                            write_err, write_err_info,
                                            out_file_type_subtype);
            ret = WS_EXIT_INVALID_FILE;
            goto clean_exit;
        }
    }
    if (!process_new_idbs(wth, pdh, idbs_seen, &write_err, &write_err_info)) {
        cfile_write_failure_message(argv[ws_optind], filename,
                                    write_err, write_err_info,
                                    read_count,
                                    out_file_type_subtype);
        ret = DUMP_ERROR;
        wtap_dump_close(pdh, NULL, &write_err, &write_err_info);
        goto clean_exit;
    }
    if (!wtap_dump_close(pdh, NULL, &write_err, &write_err_info)) {
        cfile_close_failure_message(filename, write_err, write_err_info);
        ret = WRITE_ERROR;
        goto clean_exit;
    }
    if (dup_detect) {
        fprintf(stderr, "%u packet%s seen, %u packet%s skipped with duplicate window of %i packets.\n",
                count - 1, plurality(count - 1, "", "s"), duplicate_count,
                plurality(duplicate_count, "", "s"), dup_window);
    } else if (dup_detect_by_time) {
        fprintf(stderr, "%u packet%s seen, %u packet%s skipped with duplicate time window equal to or less than %ld.%09ld seconds.\n",
                count - 1, plurality(count - 1, "", "s"), duplicate_count,
                plurality(duplicate_count, "", "s"),
                (int)relative_time_window.secs,
                (int int)relative_time_window.nsecs);
    }
clean_exit:
    if (filename) {
        g_free(filename);
    }
    if (frames_user_comments) {
        g_tree_destroy(frames_user_comments);
    }
    if (dsb_filenames) {
        g_array_free(dsb_types, TRUE);
        g_ptr_array_free(dsb_filenames, TRUE);
    }
    if (idbs_seen != NULL) {
        for (guint b = 0; b < idbs_seen->len; b++) {
            wtap_block_t if_data = g_array_index(idbs_seen, wtap_block_t, b);
            wtap_block_unref(if_data);
        }
        g_array_free(idbs_seen, TRUE);
    }
    g_free(params.idb_inf);
    wtap_dump_params_cleanup(&params);
    if (wth != NULL)
        wtap_close(wth);
    wtap_rec_reset(&read_rec);
    wtap_cleanup();
    free_progdirs();
    if (capture_comments != NULL) {
        g_ptr_array_free(capture_comments, TRUE);
        capture_comments = NULL;
    }
    return ret;
}
