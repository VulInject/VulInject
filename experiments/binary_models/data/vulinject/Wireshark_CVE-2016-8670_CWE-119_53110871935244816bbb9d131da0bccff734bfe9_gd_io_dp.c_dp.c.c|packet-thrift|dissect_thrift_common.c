dissect_thrift_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, thrift_option_data_t *thrift_opt)
{
    proto_tree *thrift_tree, *sub_tree;
    proto_item *thrift_pi, *data_pi;
    proto_item *mtype_pi = NULL;
    proto_item *fid_pi = NULL;
    int start_offset = offset;
    int header_offset = 0, data_offset = 0;
    gint32 seqid_len = TCP_THRIFT_MAX_I32_LEN;
    gint32 str_len_len = TCP_THRIFT_MAX_I32_LEN;
    guint8 mtype;
    guint16 version;
    gint32 str_len, seq_id;
    gint64 varint;
    guint8 *method_str;
    int remaining;
    tvbuff_t *msg_tvb;
    int len, tframe_length = 0;
    gboolean is_framed, is_compact, request_reasm;
    DISSECTOR_ASSERT(thrift_opt);
    DISSECTOR_ASSERT(thrift_opt->canary == THRIFT_OPTION_DATA_CANARY);
    is_framed = (thrift_opt->tprotocol & PROTO_THRIFT_FRAMED) != 0;
    is_compact = (thrift_opt->tprotocol & PROTO_THRIFT_COMPACT) != 0;
    thrift_pi = proto_tree_add_item(tree, proto_thrift, tvb, offset, -1, ENC_NA);
    thrift_tree = proto_item_add_subtree(thrift_pi, ett_thrift);
    data_pi = thrift_pi; 
    if (is_framed) {
        tframe_length = tvb_get_ntohil(tvb, offset);
		if(tframe_length == 0) {
            thrift_tree = proto_item_add_subtree(thrift_pi, ett_thrift_error);
            data_pi = proto_tree_add_item(thrift_tree, hf_thrift_frame_length, tvb, offset, TBP_THRIFT_LENGTH_LEN, ENC_BIG_ENDIAN);
            expert_add_info(pinfo, data_pi, &ei_thrift_negative_length);
            return 0;
        }
        proto_item_set_len(thrift_pi, TBP_THRIFT_LENGTH_LEN + tframe_length);
        offset += TBP_THRIFT_LENGTH_LEN;
    }
    header_offset = offset;
    remaining = tvb_reported_length_remaining(tvb, offset);
    DISSECTOR_ASSERT(remaining >= tframe_length);
    if (is_compact) {
        if (remaining < TCP_THRIFT_MIN_MESSAGE_LEN) {
            goto add_expert_and_reassemble;
        }
        version = tvb_get_ntohs(tvb, offset) & THRIFT_COMPACT_VERSION_VALUE_MASK;
        mtype = (tvb_get_ntohs(tvb, offset) & THRIFT_COMPACT_MESSAGE_MASK) >> THRIFT_COMPACT_MESSAGE_SHIFT;
        offset += TCP_THRIFT_VERSION_LEN;
        seqid_len = thrift_get_varint_enc(tvb, pinfo, tree, offset, TCP_THRIFT_MAX_I32_LEN, &varint, ENC_VARINT_ZIGZAG);
        if (seqid_len <= 0) {
            return seqid_len;
        }
        offset += seqid_len;
        if (varint > (gint64)INT32_MAX || varint < (gint64)INT32_MIN) {
            expert_add_info(pinfo, thrift_pi, &ei_thrift_varint_too_large);
        }
        seq_id = (gint32)varint;
        str_len_len = thrift_get_varint_enc(tvb, pinfo, tree, offset, TCP_THRIFT_MAX_I32_LEN, &varint, ENC_VARINT_PROTOBUF);
        if (str_len_len <= 0) {
            return str_len_len;
        }
        if (varint > (gint64)INT32_MAX) {
            expert_add_info(pinfo, thrift_pi, &ei_thrift_varint_too_large);
            return 0;
        }
        str_len = (gint32)varint;
        if (str_len < 0) {
            expert_add_info(pinfo, thrift_pi, &ei_thrift_negative_length);
            return 0;
        }
        offset += str_len_len;
        if (tvb_reported_length_remaining(tvb, offset) < str_len) {
            goto add_expert_and_reassemble;
        }
        method_str = tvb_get_string_enc(pinfo->pool, tvb, offset, str_len, ENC_UTF_8);
        offset += str_len;
    } else if (thrift_opt->tprotocol & PROTO_THRIFT_STRICT) {
        if (remaining < TBP_THRIFT_STRICT_MIN_MESSAGE_LEN) {
            goto add_expert_and_reassemble;
        }
        version = tvb_get_ntohs(tvb, offset) & THRIFT_BINARY_VERSION_VALUE_MASK;
        mtype = tvb_get_guint8(tvb, offset + TBP_THRIFT_MTYPE_OFFSET) & THRIFT_BINARY_MESSAGE_MASK;
        str_len = tvb_get_ntohil(tvb, offset + TBP_THRIFT_VERSION_LEN);
        if (str_len < 0) {
            expert_add_info(pinfo, thrift_pi, &ei_thrift_negative_length);
            return 0;
        }
        if (remaining < TBP_THRIFT_STRICT_MIN_MESSAGE_LEN + str_len) {
            goto add_expert_and_reassemble;
        }
        offset += TBP_THRIFT_VERSION_LEN + TBP_THRIFT_LENGTH_LEN;
        method_str = tvb_get_string_enc(pinfo->pool, tvb, offset, str_len, ENC_UTF_8);
        offset += str_len;
        seq_id = tvb_get_ntohil(tvb, offset);
        offset += TBP_THRIFT_SEQ_ID_LEN;
    } else {
        if (remaining < TBP_THRIFT_MIN_MESSAGE_LEN) {
            goto add_expert_and_reassemble;
        }
        version = 0;
        str_len = tvb_get_ntohil(tvb, offset);
        if (str_len < 0) {
            expert_add_info(pinfo, thrift_pi, &ei_thrift_negative_length);
            return 0;
        }
        if (remaining < TBP_THRIFT_MIN_MESSAGE_LEN + str_len) {
            goto add_expert_and_reassemble;
        }
        offset += TBP_THRIFT_LENGTH_LEN;
        method_str = tvb_get_string_enc(pinfo->pool, tvb, offset, str_len, ENC_UTF_8);
        offset += str_len;
        mtype = tvb_get_guint8(tvb, offset + TBP_THRIFT_LENGTH_LEN + str_len) & THRIFT_BINARY_MESSAGE_MASK;
        offset += TBP_THRIFT_TYPE_LEN;
        seq_id = tvb_get_ntohil(tvb, offset);
        offset += TBP_THRIFT_SEQ_ID_LEN;
    }
    data_offset = offset;
    thrift_opt->reassembly_tree = thrift_tree;
    thrift_opt->reassembly_offset = start_offset;
    thrift_opt->reassembly_length = -1;
    thrift_opt->mtype = (thrift_method_type_enum_t)mtype;
    col_append_sep_fstr(pinfo->cinfo, COL_INFO, ", ", "%s %s", val_to_str(mtype, thrift_mtype_vals, "%d"), method_str);
    if (thrift_tree) {
        offset = start_offset; 
        if (is_framed) {
            proto_tree_add_item(thrift_tree, hf_thrift_frame_length, tvb, offset, TBP_THRIFT_LENGTH_LEN, ENC_BIG_ENDIAN);
            offset += TBP_THRIFT_LENGTH_LEN;
        }
        sub_tree = proto_tree_add_subtree_format(thrift_tree, tvb, header_offset, data_offset - header_offset, ett_thrift_header, &data_pi,
                "%s [version: %d, seqid: %d, method: %s]",
                val_to_str(mtype, thrift_mtype_vals, "%d"),
                version, seq_id, method_str);
        if (is_compact) {
            proto_tree_add_item(sub_tree, hf_thrift_protocol_id, tvb, offset, TBP_THRIFT_TYPE_LEN, ENC_BIG_ENDIAN);
            proto_tree_add_bits_item(sub_tree, hf_thrift_version, tvb, (offset << OCTETS_TO_BITS_SHIFT) + 11, 5, ENC_BIG_ENDIAN);
            mtype_pi = proto_tree_add_bits_item(sub_tree, hf_thrift_mtype, tvb, (offset << OCTETS_TO_BITS_SHIFT) + 8, 3, ENC_BIG_ENDIAN);
            offset += TCP_THRIFT_VERSION_LEN;
            proto_tree_add_int(sub_tree, hf_thrift_seq_id, tvb, offset, seqid_len, seq_id);
            offset += seqid_len;
            proto_tree_add_int(sub_tree, hf_thrift_str_len, tvb, offset, str_len_len, str_len);
            offset += str_len_len;
            proto_tree_add_item(sub_tree, hf_thrift_method, tvb, offset, str_len, ENC_UTF_8);
            offset = offset + str_len;
        } else if (thrift_opt->tprotocol & PROTO_THRIFT_STRICT) {
            proto_tree_add_item(sub_tree, hf_thrift_protocol_id, tvb, offset, TBP_THRIFT_TYPE_LEN, ENC_BIG_ENDIAN);
            proto_tree_add_bits_item(sub_tree, hf_thrift_version, tvb, (offset << OCTETS_TO_BITS_SHIFT) + 11, 5, ENC_BIG_ENDIAN);
            offset += TBP_THRIFT_MTYPE_OFFSET;
            mtype_pi = proto_tree_add_bits_item(sub_tree, hf_thrift_mtype, tvb, (offset << OCTETS_TO_BITS_SHIFT) + 5, 3, ENC_BIG_ENDIAN);
            offset += TBP_THRIFT_MTYPE_LEN;
            proto_tree_add_item(sub_tree, hf_thrift_str_len, tvb, offset, TBP_THRIFT_LENGTH_LEN, ENC_BIG_ENDIAN);
            offset += TBP_THRIFT_LENGTH_LEN;
            proto_tree_add_item(sub_tree, hf_thrift_method, tvb, offset, str_len, ENC_UTF_8);
            offset = offset + str_len;
            proto_tree_add_item(sub_tree, hf_thrift_seq_id, tvb, offset, TBP_THRIFT_SEQ_ID_LEN, ENC_BIG_ENDIAN);
            offset += TBP_THRIFT_SEQ_ID_LEN;
        } else {
            proto_tree_add_item(sub_tree, hf_thrift_str_len, tvb, offset, TBP_THRIFT_LENGTH_LEN, ENC_BIG_ENDIAN);
            offset += TBP_THRIFT_LENGTH_LEN;
            proto_tree_add_item(sub_tree, hf_thrift_method, tvb, offset, str_len, ENC_UTF_8);
            offset = offset + str_len;
            mtype_pi = proto_tree_add_bits_item(sub_tree, hf_thrift_mtype, tvb, (offset << OCTETS_TO_BITS_SHIFT) + 5, 3, ENC_BIG_ENDIAN);
            offset += TBP_THRIFT_MTYPE_LEN;
            proto_tree_add_item(sub_tree, hf_thrift_seq_id, tvb, offset, TBP_THRIFT_SEQ_ID_LEN, ENC_BIG_ENDIAN);
            offset += TBP_THRIFT_SEQ_ID_LEN;
        }
        DISSECTOR_ASSERT(offset == data_offset);
    }
    if (tvb_reported_length_remaining(tvb, data_offset) < TBP_THRIFT_TYPE_LEN) {
        goto add_expert_and_reassemble;
    }
    thrift_opt->previous_field_id = 0;
    msg_tvb = tvb_new_subset_remaining(tvb, data_offset);
    if (thrift_opt->mtype == ME_THRIFT_T_REPLY) {
        thrift_field_header_t header = {
            .field_id = 0, 
        };
        int result = data_offset;
        result = dissect_thrift_field_header(tvb, pinfo, NULL, &result, thrift_opt, &header, FALSE);
        switch (result) {
        case THRIFT_REQUEST_REASSEMBLY:
            goto add_expert_and_reassemble;
        case THRIFT_SUBDISSECTOR_ERROR:
            return 0;
        default:
            break;
        }
        thrift_opt->reply_field_id = header.field_id;
        fid_pi = header.fid_pi;
    }
    if (thrift_opt->mtype != ME_THRIFT_T_EXCEPTION) {
        if (pinfo->can_desegment > 0) pinfo->can_desegment++;
        len = dissector_try_string(thrift_method_name_dissector_table, method_str, msg_tvb, pinfo, tree, thrift_opt);
        if (pinfo->can_desegment > 0) pinfo->can_desegment--;
    } else {
        expert_add_info(pinfo, mtype_pi, &ei_thrift_protocol_exception);
        len = dissect_thrift_t_struct(msg_tvb, pinfo, thrift_tree, 0, thrift_opt, FALSE, 0, hf_thrift_exception, ett_thrift_exception, thrift_exception);
    }
    if (len > 0) {
        if (!is_framed) {
            proto_item_set_end(thrift_pi, msg_tvb, len);
        }
        return data_offset + len;
    } else if (len == THRIFT_REQUEST_REASSEMBLY) {
        goto reassemble_pdu;
    } else if (len <= THRIFT_SUBDISSECTOR_ERROR) {
        if (!try_generic_if_sub_dissector_fails) {
            return 0;
        }
    } 
    sub_tree = proto_tree_add_subtree(thrift_tree, tvb, data_offset, -1, ett_thrift_params, &data_pi, "Data");
    thrift_opt->reassembly_length = TBP_THRIFT_TYPE_LEN;
    if (thrift_opt->reply_field_id != 0) {
        expert_add_info(pinfo, fid_pi, &ei_thrift_application_exception);
        proto_item_set_text(data_pi, "Exception: %" PRId64, thrift_opt->reply_field_id);
    }
    if (is_compact) {
        request_reasm = dissect_thrift_compact_fields(tvb, pinfo, sub_tree, &offset, thrift_opt) == THRIFT_REQUEST_REASSEMBLY;
    } else { 
        request_reasm = dissect_thrift_binary_fields(tvb, pinfo, sub_tree, &offset, thrift_opt) == THRIFT_REQUEST_REASSEMBLY;
    }
    if (request_reasm) {
        if (offset > 0) {
            return tvb_reported_length(tvb);
        } 
        goto reassemble_pdu;
    } else {
        proto_item_set_end(data_pi, tvb, offset);
    }
    if (!is_framed) {
        proto_item_set_end(thrift_pi, tvb, offset);
    }
    proto_item_set_end(data_pi, tvb, offset);
    return offset;
add_expert_and_reassemble: 
    expert_add_info(pinfo, data_pi, &ei_thrift_not_enough_data);
reassemble_pdu: 
    pinfo->desegment_offset = start_offset;
    pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;
    return THRIFT_REQUEST_REASSEMBLY;
}
