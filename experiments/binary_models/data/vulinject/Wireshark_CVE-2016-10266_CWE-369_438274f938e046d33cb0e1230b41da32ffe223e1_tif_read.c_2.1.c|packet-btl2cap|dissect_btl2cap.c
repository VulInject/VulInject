dissect_btl2cap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
    gint              offset       = 0;
    proto_item       *ti;
    proto_tree       *btl2cap_tree;
    proto_item       *length_item;
    guint16           length;
    guint16           cid;
    guint16           psm;
    guint16           control;
    tvbuff_t         *next_tvb     = NULL;
    psm_data_t       *psm_data;
    bthci_acl_data_t *acl_data;
    btl2cap_data_t   *l2cap_data;
    gboolean          dir_in_col = TRUE;
    acl_data = (bthci_acl_data_t *) data;
    if ((acl_data) && (acl_data->is_btle)) {
        dir_in_col = FALSE;
    }
    ti = proto_tree_add_item(tree, proto_btl2cap, tvb, offset, -1, ENC_NA);
    btl2cap_tree = proto_item_add_subtree(ti, ett_btl2cap);
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "L2CAP");
    if (dir_in_col) {
        switch (pinfo->p2p_dir) {
        case P2P_DIR_SENT:
            col_set_str(pinfo->cinfo, COL_INFO, "Sent ");
            break;
        case P2P_DIR_RECV:
            col_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");
            break;
        default:
            col_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");
            break;
        }
    } else {
        col_clear(pinfo->cinfo, COL_INFO);
    }
    length  = tvb_get_letohs(tvb, offset);
    length_item = proto_tree_add_item(btl2cap_tree, hf_btl2cap_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    if (tvb_captured_length_remaining(tvb, offset) < length) {
        expert_add_info(pinfo, length_item, &ei_btl2cap_length_bad);
        length = tvb_captured_length_remaining(tvb, offset) - 4;
    }
    offset += 2;
    cid = tvb_get_letohs(tvb, offset);
    proto_tree_add_item(btl2cap_tree, hf_btl2cap_cid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    if (p_get_proto_data(pinfo->pool, pinfo, proto_btl2cap, PROTO_DATA_BTL2CAP_CID ) == NULL) {
        guint16 *value_data;
        value_data = wmem_new(wmem_file_scope(), guint16);
        *value_data = cid;
        p_add_proto_data(pinfo->pool, pinfo, proto_btl2cap, PROTO_DATA_BTL2CAP_CID, value_data);
    }
    offset += 2;
	l2cap_data=((pinfo->pool+btl2cap_data_t-1)/btl2cap_data_t);
    if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID)
        l2cap_data->interface_id = pinfo->rec->rec_header.packet_header.interface_id;
    else
        l2cap_data->interface_id = HCI_INTERFACE_DEFAULT;
    if (acl_data) {
        l2cap_data->adapter_id                  = acl_data->adapter_id;
        l2cap_data->adapter_disconnect_in_frame = acl_data->adapter_disconnect_in_frame;
        l2cap_data->chandle                     = acl_data->chandle;
        l2cap_data->hci_disconnect_in_frame     = acl_data->disconnect_in_frame;
        l2cap_data->remote_bd_addr_oui          = acl_data->remote_bd_addr_oui;
        l2cap_data->remote_bd_addr_id           = acl_data->remote_bd_addr_id;
    } else {
        l2cap_data->adapter_id                  = HCI_ADAPTER_DEFAULT;
        l2cap_data->adapter_disconnect_in_frame = &bluetooth_max_disconnect_in_frame;
        l2cap_data->chandle                     = 0;
        l2cap_data->hci_disconnect_in_frame     = &bluetooth_max_disconnect_in_frame;
        l2cap_data->remote_bd_addr_oui          = 0;
        l2cap_data->remote_bd_addr_id           = 0;
    }
    l2cap_data->disconnect_in_frame         = &bluetooth_max_disconnect_in_frame;
    l2cap_data->cid              = cid;
    l2cap_data->local_cid        = BTL2CAP_UNKNOWN_CID;
    l2cap_data->remote_cid       = BTL2CAP_UNKNOWN_CID;
    l2cap_data->is_local_psm     = FALSE;
    l2cap_data->psm              = 0;
    if (cid == BTL2CAP_FIXED_CID_SIGNAL || cid == BTL2CAP_FIXED_CID_LE_SIGNAL) {
        while (offset < length + 4) {
            proto_item  *ti_command;
            proto_tree  *btl2cap_cmd_tree;
            guint8       cmd_code;
            guint8       cmd_ident;
            guint16      cmd_length;
            const gchar *cmd_str;
            ti_command = proto_tree_add_none_format(btl2cap_tree,
                    hf_btl2cap_command, tvb,
                    offset, length,
                    "Command: ");
            btl2cap_cmd_tree = proto_item_add_subtree(ti_command, ett_btl2cap_cmd);
            cmd_code = tvb_get_guint8(tvb, offset);
            proto_tree_add_item(btl2cap_cmd_tree, hf_btl2cap_cmd_code,   tvb, offset, 1, ENC_LITTLE_ENDIAN);
            offset += 1;
            cmd_ident = tvb_get_guint8(tvb, offset);
            proto_tree_add_item(btl2cap_cmd_tree, hf_btl2cap_cmd_ident,  tvb, offset, 1, ENC_LITTLE_ENDIAN);
            offset += 1;
            cmd_length = tvb_get_letohs(tvb, offset);
            proto_tree_add_item(btl2cap_cmd_tree, hf_btl2cap_cmd_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            proto_item_set_len(ti_command, cmd_length + 4);
            offset += 2;
            cmd_str = val_to_str_const(cmd_code, command_code_vals, "Unknown command");
            proto_item_append_text(ti_command, "%s", cmd_str);
            col_append_str(pinfo->cinfo, COL_INFO, cmd_str);
            switch (cmd_code) {
            case 0x01: 
                offset  = dissect_comrej(tvb, offset, pinfo, btl2cap_cmd_tree);
                break;
            case 0x02: 
                offset  = dissect_connrequest(tvb, offset, pinfo, btl2cap_tree, btl2cap_cmd_tree, FALSE, acl_data, l2cap_data);
                break;
            case 0x03: 
                offset  = dissect_connresponse(tvb, offset, pinfo, btl2cap_cmd_tree, acl_data);
                break;
            case 0x04: 
                offset  = dissect_configrequest(tvb, offset, pinfo, btl2cap_cmd_tree, cmd_length, acl_data);
                break;
            case 0x05: 
                offset  = dissect_configresponse(tvb, offset, pinfo, btl2cap_cmd_tree, cmd_length, acl_data);
                break;
            case 0x06: 
                offset  = dissect_disconnrequestresponse(tvb, offset, pinfo, btl2cap_tree, btl2cap_cmd_tree, acl_data, l2cap_data, TRUE);
                break;
            case 0x07: 
                offset  = dissect_disconnrequestresponse(tvb, offset, pinfo, btl2cap_tree, btl2cap_cmd_tree, acl_data, l2cap_data, FALSE);
                break;
            case 0x08: 
                proto_tree_add_item(btl2cap_cmd_tree, hf_btl2cap_data, tvb, offset, -1, ENC_NA);
                offset = tvb_reported_length(tvb);
                break;
            case 0x09: 
                proto_tree_add_item(btl2cap_cmd_tree, hf_btl2cap_data, tvb, offset, -1, ENC_NA);
                offset = tvb_reported_length(tvb);
                break;
            case 0x0a: 
                offset  = dissect_inforequest(tvb, offset, pinfo, btl2cap_cmd_tree);
                break;
            case 0x0b: 
                offset  = dissect_inforesponse(tvb, offset, pinfo, btl2cap_cmd_tree);
                break;
            case 0x0c: 
                offset  = dissect_connrequest(tvb, offset, pinfo, btl2cap_tree, btl2cap_cmd_tree, TRUE, acl_data, l2cap_data);
                break;
            case 0x0d: 
                offset  = dissect_chanresponse(tvb, offset, pinfo, btl2cap_cmd_tree, acl_data);
                break;
            case 0x0e: 
                offset  = dissect_movechanrequest(tvb, offset, pinfo, btl2cap_cmd_tree);
                break;
            case 0x0f: 
                offset  = dissect_movechanresponse(tvb, offset, pinfo, btl2cap_cmd_tree);
                break;
            case 0x10: 
                offset  = dissect_movechanconfirmation(tvb, offset, pinfo, btl2cap_cmd_tree);
                break;
            case 0x11: 
                offset  = dissect_movechanconfirmationresponse(tvb, offset, pinfo, btl2cap_cmd_tree);
                break;
            case 0x12: 
                offset  = dissect_connparamrequest(tvb, offset, pinfo, btl2cap_cmd_tree);
                break;
            case 0x13: 
                offset  = dissect_connparamresponse(tvb, offset, pinfo, btl2cap_cmd_tree);
                break;
            case 0x14: 
                offset = dissect_le_credit_based_connrequest(tvb, offset, pinfo, btl2cap_tree, btl2cap_cmd_tree, cid, cmd_ident, acl_data, l2cap_data);
                col_append_fstr(pinfo->cinfo, COL_INFO, " (CID: %04x, Initial Credits: %u)",
                                tvb_get_letohs(tvb, offset - 8), tvb_get_letohs(tvb, offset - 2));
                break;
            case 0x15: 
                offset = dissect_le_credit_based_connresponse(tvb, offset, pinfo, btl2cap_cmd_tree, cid, cmd_ident, acl_data);
                col_append_fstr(pinfo->cinfo, COL_INFO, " (CID: %04x, Initial Credits: %u)",
                                tvb_get_letohs(tvb, offset - 10), tvb_get_letohs(tvb, offset - 4));
                break;
            case 0x16: 
                proto_tree_add_item(btl2cap_cmd_tree, hf_btl2cap_cid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                offset += 2;
                proto_tree_add_item(btl2cap_cmd_tree, hf_btl2cap_credits, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                offset += 2;
                col_append_fstr(pinfo->cinfo, COL_INFO, " (CID: %04x, Credits: %u)",
                                tvb_get_letohs(tvb, offset - 4), tvb_get_letohs(tvb, offset - 2));
                break;
            case 0x17: 
                offset = dissect_l2cap_credit_based_connrequest(tvb, offset, pinfo, btl2cap_tree, btl2cap_cmd_tree, cid, cmd_ident, cmd_length, acl_data, l2cap_data);
                break;
            case 0x18: 
                offset = dissect_l2cap_credit_based_connresponse(tvb, offset, pinfo, btl2cap_cmd_tree, cid, cmd_ident, cmd_length, acl_data);
                break;
            default:
                proto_tree_add_expert(btl2cap_cmd_tree, pinfo, &ei_btl2cap_unknown_command_code, tvb, offset, -1);
                offset += tvb_reported_length_remaining(tvb, offset);
                break;
            }
        }
    }
    else if (cid == BTL2CAP_FIXED_CID_CONNLESS) { 
        col_append_str(pinfo->cinfo, COL_INFO, "Connectionless reception channel");
        psm = tvb_get_letohs(tvb, offset);
        if (pinfo->p2p_dir == P2P_DIR_RECV) {
            l2cap_data->local_cid = cid;
            l2cap_data->remote_cid = BTL2CAP_UNKNOWN_CID;
        } else {
            l2cap_data->local_cid = BTL2CAP_UNKNOWN_CID;
            l2cap_data->remote_cid = cid;
        }
        l2cap_data->psm = psm;
        l2cap_data->disconnect_in_frame = &bluetooth_max_disconnect_in_frame;
        if (p_get_proto_data(pinfo->pool, pinfo, proto_btl2cap, PROTO_DATA_BTL2CAP_PSM ) == NULL) {
            guint16 *value_data;
            value_data = wmem_new(wmem_file_scope(), guint16);
            *value_data = psm;
            p_add_proto_data(pinfo->pool, pinfo, proto_btl2cap, PROTO_DATA_BTL2CAP_PSM, value_data);
        }
        proto_tree_add_item(btl2cap_tree, hf_btl2cap_psm, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
        next_tvb = tvb_new_subset_length_caplen(tvb, offset, tvb_captured_length_remaining(tvb, offset), length);
        if (!dissector_try_uint_new(l2cap_psm_dissector_table, (guint32) psm, next_tvb, pinfo, tree, TRUE, l2cap_data)) {
            guint16  bt_uuid;
            bluetooth_uuid_t  uuid;
            bt_uuid = get_service_uuid(pinfo, l2cap_data, psm, (pinfo->p2p_dir == P2P_DIR_RECV) ? TRUE : FALSE );
            uuid.size = 2;
            uuid.bt_uuid = bt_uuid;
            uuid.data[0] = bt_uuid >> 8;
            uuid.data[1] = bt_uuid & 0xFF;
            if (bt_uuid && p_get_proto_data(pinfo->pool, pinfo, proto_bluetooth, PROTO_DATA_BLUETOOTH_SERVICE_UUID ) == NULL) {
                gchar* value_data;
                value_data = wmem_strdup(wmem_file_scope(), print_numeric_bluetooth_uuid(pinfo->pool, &uuid));
                p_add_proto_data(pinfo->pool, pinfo, proto_bluetooth, PROTO_DATA_BLUETOOTH_SERVICE_UUID, value_data);
            }
            if (!dissector_try_string(bluetooth_uuid_table, print_numeric_bluetooth_uuid(pinfo->pool, &uuid), next_tvb, pinfo, tree, l2cap_data)) {
                proto_tree_add_item(btl2cap_tree, hf_btl2cap_payload, tvb, offset, length, ENC_NA);
            }
            offset = tvb_captured_length(tvb);
        }
    }
    else if (cid <= BTL2CAP_FIXED_CID_LAST) {
        if (cid == BTL2CAP_FIXED_CID_AMP_MAN) {
            control = tvb_get_letohs(tvb, offset);
            if (control & 0x1) {
                offset = dissect_s_frame(tvb, pinfo, tree, btl2cap_tree, 0 , length, offset, NULL );
            } else {
                proto_item* ti_control;
                proto_tree* ti_control_subtree;
                ti_control = proto_tree_add_none_format(btl2cap_tree, hf_btl2cap_control, tvb,
                    offset, 2, "Control: %s reqseq:%d r:%d txseq:%d",
                    val_to_str_const((control & 0xC000) >> 14, control_sar_vals, "unknown"),
                    (control & 0x3F00) >> 8,
                    (control & 0x0080) >> 7,
                    (control & 0x007E) >> 1);
                ti_control_subtree = proto_item_add_subtree(ti_control, ett_btl2cap_control);
                proto_tree_add_item(ti_control_subtree, hf_btl2cap_control_sar, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                proto_tree_add_item(ti_control_subtree, hf_btl2cap_control_reqseq, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                proto_tree_add_item(ti_control_subtree, hf_btl2cap_control_retransmissiondisable, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                proto_tree_add_item(ti_control_subtree, hf_btl2cap_control_txseq, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                proto_tree_add_item(ti_control_subtree, hf_btl2cap_control_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                offset += 2;
                proto_tree_add_item(btl2cap_tree, hf_btl2cap_fcs, tvb, tvb_reported_length(tvb) - 2, 2, ENC_LITTLE_ENDIAN);
                next_tvb = tvb_new_subset_length_caplen(tvb, offset, tvb_captured_length_remaining(tvb, offset)-2, length);
            }
        }
        else {
            next_tvb = tvb_new_subset_length_caplen(tvb, offset, tvb_captured_length_remaining(tvb, offset), length);
        }
        if (next_tvb && !dissector_try_uint_new(l2cap_cid_dissector_table, (guint32) cid,
                    next_tvb, pinfo, tree, TRUE, l2cap_data)) {
            proto_tree_add_item(btl2cap_tree, hf_btl2cap_payload, tvb, offset, length, ENC_NA);
        }
        offset = tvb_captured_length(tvb);
    }
    else  { 
        wmem_tree_key_t    key[6];
        guint32            k_interface_id;
        guint32            k_adapter_id;
        guint32            k_chandle;
        guint32            k_cid;
        guint32            k_frame_number;
        guint32            interface_id;
        guint32            adapter_id;
        guint32            chandle;
        guint32            key_cid;
        if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID)
            interface_id = pinfo->rec->rec_header.packet_header.interface_id;
        else
            interface_id = HCI_INTERFACE_DEFAULT;
        adapter_id   = (acl_data) ? acl_data->adapter_id : HCI_ADAPTER_DEFAULT;
        chandle      = (acl_data) ? acl_data->chandle : 0;
        key_cid      = cid | ((pinfo->p2p_dir == P2P_DIR_RECV) ? 0x00000000 : 0x80000000);
        k_interface_id = interface_id;
        k_adapter_id   = adapter_id;
        k_chandle      = chandle;
        k_cid          = key_cid;
        k_frame_number = pinfo->num;
        key[0].length = 1;
        key[0].key    = &k_interface_id;
        key[1].length = 1;
        key[1].key    = &k_adapter_id;
        key[2].length = 1;
        key[2].key    = &k_chandle;
        key[3].length = 1;
        key[3].key    = &k_cid;
        key[4].length = 1;
        key[4].key    = &k_frame_number;
        key[5].length = 0;
        key[5].key    = NULL;
        psm_data = (psm_data_t *)wmem_tree_lookup32_array_le(cid_to_psm_table, key);
        if (psm_data &&
            psm_data->interface_id == interface_id &&
            psm_data->adapter_id == adapter_id &&
            psm_data->chandle == chandle &&
            (psm_data->local_cid == key_cid ||
             psm_data->remote_cid == key_cid) &&
            psm_data->disconnect_in_frame > pinfo->num)
        {
            config_data_t  *config_data;
            proto_item     *sub_item;
            guint32         bt_uuid;
            psm = psm_data->psm;
            l2cap_data->local_cid = psm_data->local_cid;
            l2cap_data->remote_cid = psm_data->remote_cid;
            l2cap_data->psm = psm;
            l2cap_data->is_local_psm = psm_data->local_service;
            l2cap_data->disconnect_in_frame = &psm_data->disconnect_in_frame;
            if (pinfo->p2p_dir == P2P_DIR_RECV)
                config_data = &(psm_data->in);
            else
                config_data = &(psm_data->out);
            if (psm_data->connect_in_frame > 0 && psm_data->connect_in_frame < G_MAXUINT32) {
                sub_item = proto_tree_add_uint(btl2cap_tree, hf_btl2cap_connect_in_frame, tvb, 0, 0, psm_data->connect_in_frame);
                proto_item_set_generated(sub_item);
            }
            if (psm_data->disconnect_in_frame > 0 && psm_data->disconnect_in_frame < G_MAXUINT32) {
                sub_item = proto_tree_add_uint(btl2cap_tree, hf_btl2cap_disconnect_in_frame, tvb, 0, 0, psm_data->disconnect_in_frame);
                proto_item_set_generated(sub_item);
            }
            bt_uuid = get_service_uuid(pinfo, l2cap_data, psm_data->psm, psm_data->local_service);
            if (bt_uuid) {
                sub_item = proto_tree_add_uint(btl2cap_tree, hf_btl2cap_service, tvb, 0, 0, bt_uuid);
                proto_item_set_generated(sub_item);
            }
            if (config_data->mode == L2CAP_BASIC_MODE) {
                offset = dissect_b_frame(tvb, pinfo, tree, btl2cap_tree, cid, psm, psm_data->local_service, length, offset, l2cap_data);
            } else if (config_data->mode == L2CAP_LE_CREDIT_BASED_FLOW_CONTROL_MODE) {
                gboolean is_retransmit = FALSE;
                if (acl_data) {
                    is_retransmit = acl_data->is_btle_retransmit;
                }
                offset = dissect_le_frame(tvb, pinfo, tree, btl2cap_tree, cid, psm, psm_data->local_service, length, offset, config_data, l2cap_data, is_retransmit);
            } else {
                control = tvb_get_letohs(tvb, offset);
                if (control & 0x1) {
                    offset = dissect_s_frame(tvb, pinfo, tree, btl2cap_tree, psm, length, offset, config_data);
                } else {
                    offset = dissect_i_frame(tvb, pinfo, tree, btl2cap_tree, psm_data, length, offset, config_data, l2cap_data);
                }
            }
        } else {
            psm = 0;
            offset = dissect_b_frame(tvb, pinfo, tree, btl2cap_tree, cid, psm, FALSE, length, offset, l2cap_data);
        }
    }
    return offset;
}
