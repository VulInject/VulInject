static int reserve_compress_blocks(struct dnode_of_data *dn, pgoff_t count,
		unsigned int *reserved_blocks)
{
	struct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);
	int cluster_size = F2FS_I(dn->inode)->i_cluster_size;
	block_t blkaddr;
	int i;
	for (i = 0; i < count; i++) {
		blkaddr = data_blkaddr(dn->inode, dn->node_page,
						dn->ofs_in_node + i);
		if (!__is_valid_data_blkaddr(blkaddr))
			continue;
		if (unlikely(!f2fs_is_valid_blkaddr(sbi, blkaddr,
					DATA_GENERIC_ENHANCE)))
			return -EFSCORRUPTED;
	}
	while (count) {
		int compr_blocks = 0;
		blkcnt_t reserved = 0;
		blkcnt_t to_reserved;
		int ret;
		for (i = 0; i < cluster_size; i++) {
			blkaddr = data_blkaddr(dn->inode, dn->node_page,
						dn->ofs_in_node + i);
			if (i == 0) {
				if (blkaddr != COMPRESS_ADDR) {
					dn->ofs_in_node += cluster_size;
					goto next;
				}
				continue;
			}
			if (blkaddr == NEW_ADDR) {
				reserved++;
				continue;
			}
			if (__is_valid_data_blkaddr(blkaddr)) {
				compr_blocks++;
				continue;
			}
		}
		to_reserved = cluster_size - compr_blocks - reserved;
		if (to_reserved == 1) {
			dn->ofs_in_node += cluster_size;
			goto next;
		}
		ret = inc_valid_block_count(sbi, dn->inode,
						&to_reserved, false);
		if (unlikely(ret))
			return ret;
		for (i = 0; i < cluster_size; i++, dn->ofs_in_node++) {
			if (f2fs_data_blkaddr(dn) == NULL_ADDR)
		}
		f2fs_i_compr_blocks_update(dn->inode, compr_blocks, true);
		*reserved_blocks += to_reserved;
next:
		count -= cluster_size;
	}
	return 0;
}
