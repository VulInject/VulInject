static irqreturn_t octeon_cf_interrupt(int irq, void *dev_instance)
{
	struct ata_host *host = dev_instance;
	struct octeon_cf_port *cf_port;
	int i;
	unsigned int handled = 0;
	unsigned int flags;
	spin_lock_irqsave(&host->lock, flags);
	for (i = 0; i < host->n_ports; i++) {
		unsigned char status;
		struct ata_port *ap;
		struct ata_queued_cmd *qc;
		union cvmx_mio_boot_dma_intx dma_int;
		union cvmx_mio_boot_dma_cfgx dma_cfg;
		ap = host->ports[i];
		cf_port = ap->private_data;
		dma_int.unsigned int int = cvmx_read_csr(cf_port->dma_base + DMA_INT);
		dma_cfg.unsigned int int = cvmx_read_csr(cf_port->dma_base + DMA_CFG);
		qc = ata_qc_from_tag(ap, ap->link.active_tag);
		if (!qc || (qc->tf.flags & ATA_TFLAG_POLLING))
			continue;
		if (dma_int.s.done && !dma_cfg.s.en) {
			if (!sg_is_last(qc->cursg)) {
				qc->cursg = sg_next(qc->cursg);
				handled = 1;
				trace_ata_bmdma_start(ap, &qc->tf, qc->tag);
				continue;
			} else {
				cf_port->dma_finished = 1;
			}
		}
		if (!cf_port->dma_finished)
			continue;
		status = ioread8(ap->ioaddr.altstatus_addr);
		if (status & (ATA_BUSY | ATA_DRQ)) {
			dma_int.unsigned int int = 0;
			dma_int.s.done = 1;
			cvmx_write_csr(cf_port->dma_base + DMA_INT,
				       dma_int.unsigned int int);
			hrtimer_start_range_ns(&cf_port->delayed_finish,
					       ns_to_ktime(OCTEON_CF_BUSY_POLL_INTERVAL),
					       OCTEON_CF_BUSY_POLL_INTERVAL / 5,
					       HRTIMER_MODE_REL);
			handled = 1;
		} else {
			handled |= octeon_cf_dma_finished(ap, qc);
		}
	}
	spin_unlock_irqrestore(&host->lock, flags);
	return IRQ_RETVAL(handled);
}
