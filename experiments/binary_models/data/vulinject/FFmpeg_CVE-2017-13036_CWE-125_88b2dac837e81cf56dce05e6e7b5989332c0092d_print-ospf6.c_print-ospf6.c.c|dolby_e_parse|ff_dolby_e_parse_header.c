int ff_dolby_e_parse_header(DBEContext *s, const uint8_t *buf, int buf_size)
{
    DolbyEHeaderInfo *const header = &s->metadata;
    int hdr, ret, key, mtd_size;
    if (buf_size < 3)
        return AVERROR_INVALIDDATA;
    hdr = AV_RB24(buf);
    if ((hdr & 0xfffffe) == 0x7888e) {
        s->word_bits = 24;
    } else if ((hdr & 0xffffe0) == 0x788e0) {
        s->word_bits = 20;
    } else if ((hdr & 0xfffe00) == 0x78e00) {
        s->word_bits = 16;
    } else {
        if (s->avctx)
            av_log(s->avctx, AV_LOG_ERROR, "Invalid frame header\n");
        return AVERROR_INVALIDDATA;
    }
    s->word_bytes  = s->word_bits + 7 >> 3;
    s->input       = buf + s->word_bytes;
    s->input_size  = buf_size / s->word_bytes - 1;
    s->key_present = hdr >> 24 - s->word_bits & 1;
    if ((key = parse_key(s)) < 0)
        return key;
    if ((ret = ff_dolby_e_convert_input(s, 1, key)) < 0)
        return ret;
    skip_bits(&s->gb, 4);
    mtd_size = get_bits(&s->gb, 10);
    if (!mtd_size) {
        if (s->avctx)
            av_log(s->avctx, AV_LOG_ERROR, "Invalid metadata size\n");
        return AVERROR_INVALIDDATA;
    }
    if ((ret = ff_dolby_e_convert_input(s, mtd_size, key)) < 0)
        return ret;
    skip_bits(&s->gb, 14);
    header->prog_conf = get_bits(&s->gb, 6);
    if (header->prog_conf > MAX_PROG_CONF) {
        if (s->avctx)
            av_log(s->avctx, AV_LOG_ERROR, "Invalid program configuration\n");
        return AVERROR_INVALIDDATA;
    }
    header->nb_channels = nb_channels_tab[header->prog_conf];
    header->nb_programs = nb_programs_tab[header->prog_conf];
    header->fr_code      = get_bits(&s->gb, 4);
    header->fr_code_orig = get_bits(&s->gb, 4);
    if (!(header->sample_rate = sample_rate_tab[header->fr_code]) ||
        !sample_rate_tab[header->fr_code_orig]) {
        if (s->avctx)
            av_log(s->avctx, AV_LOG_ERROR, "Invalid frame rate code\n");
        return AVERROR_INVALIDDATA;
    }
    skip_bits_long(&s->gb, 88);
    for (int i = 0; i < header->nb_channels; i++)
        header->ch_size[i] = get_bits(&s->gb, 10);
    header->mtd_ext_size = get_bits(&s->gb, 8);
    header->meter_size   = get_bits(&s->gb, 8);
    skip_bits_long(&s->gb, 10 * header->nb_programs);
    for (int i = 0; i < header->nb_channels; i++) {
        header->rev_id[i]     = get_bits(&s->gb,  4);
        header->begin_gain[i] = get_bits(&s->gb, 10);
        header->end_gain[i]   = get_bits(&s->gb, 10);
    }
    if (get_bits_left(&s->gb) < 0) {
        if (s->avctx)
            av_log(s->avctx, AV_LOG_ERROR, "Read past end of metadata\n");
        return AVERROR_INVALIDDATA;
    }
    return skip_input(s, mtd_size + 1);
}
