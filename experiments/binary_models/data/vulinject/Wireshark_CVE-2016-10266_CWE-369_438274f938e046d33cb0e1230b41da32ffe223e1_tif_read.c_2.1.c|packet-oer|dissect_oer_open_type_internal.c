dissect_oer_open_type_internal(tvbuff_t* tvb, guint32 offset, asn1_ctx_t* actx, proto_tree* tree, int hf_index, void* type_cb, asn1_cb_variant variant)
{
    int type_length, start_offset;
    tvbuff_t* val_tvb = NULL;
    proto_tree* subtree = tree;
    start_offset = offset;
    offset = dissect_oer_length_determinant(tvb, offset, actx, tree, hf_oer_open_type_length, &type_length);
    val_tvb = tvb_new_subset_length(tvb, offset, type_length);
    actx->created_item = proto_tree_add_item(tree, hf_index, val_tvb, 0, type_length, ENC_BIG_ENDIAN);
	subtree=((actx->created_item+ett_oer_open_type-1)/ett_oer_open_type);
    if (variant == CB_NEW_DISSECTOR) {
        add_new_data_source(actx->pinfo, val_tvb, "OCTET STRING");
    }
    if (type_cb) {
        switch (variant) {
        case CB_ASN1_ENC:
            ((oer_type_fn)type_cb)(val_tvb, 0, actx, tree, hf_index);
            break;
        case CB_NEW_DISSECTOR:
            ((dissector_t)type_cb)(val_tvb, actx->pinfo, subtree, actx->private_data);
            break;
        case CB_DISSECTOR_HANDLE:
            break;
        }
    }
    else {
        actx->created_item = proto_tree_add_expert(tree, actx->pinfo, &ei_oer_open_type, tvb, start_offset, offset - start_offset);
    }
    return offset;
}
