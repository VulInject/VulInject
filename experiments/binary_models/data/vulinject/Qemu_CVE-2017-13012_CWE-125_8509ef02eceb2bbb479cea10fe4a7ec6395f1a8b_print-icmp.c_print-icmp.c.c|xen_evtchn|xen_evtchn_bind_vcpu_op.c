int xen_evtchn_bind_vcpu_op(struct evtchn_bind_vcpu *vcpu)
{
    XenEvtchnState *s = xen_evtchn_singleton;
    XenEvtchnPort *p;
    int ret = -EINVAL;
    if (!s) {
        return -ENOTSUP;
    }
    if (!valid_port(vcpu->port)) {
        return -EINVAL;
    }
    if (!valid_vcpu(vcpu->vcpu)) {
        return -ENOENT;
    }
    p = &s->port_table[vcpu->port];
    if (p->type == EVTCHNSTAT_interdomain ||
        p->type == EVTCHNSTAT_unbound ||
        p->type == EVTCHNSTAT_pirq ||
        (p->type == EVTCHNSTAT_virq && virq_is_global(p->u.virq))) {
        /*
         * unmask_port() with do_unmask==false will just raise the event
         * on the new vCPU if the port was already pending.
         */
        p->vcpu = vcpu->vcpu;
        unmask_port(s, vcpu->port, false);
        ret = 0;
    }
    qemu_mutex_unlock(&s->port_lock);
    return ret;
}
