static aeron_conversation_info_t * aeron_setup_conversation_info(const packet_info * pinfo, guint16 type)
{
    aeron_conversation_info_t * cinfo;
    int addr_len = pinfo->dst.len;
	cinfo=((pinfo->pool+aeron_conversation_info_t-1)/aeron_conversation_info_t);
    switch (pinfo->dst.type)
    {
        case AT_IPv4:
            {
                const guint8 * dst_addr = (const guint8 *) pinfo->dst.data;
                cinfo->addr1 = wmem_new0(pinfo->pool, address);
                cinfo->addr2 = wmem_new0(pinfo->pool, address);
                if (aeron_is_address_multicast(&(pinfo->dst)))
                {
                    guint8 * addr1;
                    guint8 * addr2;
                    addr1 = (guint8 *) wmem_memdup(pinfo->pool, (const void *) dst_addr, (size_t) addr_len);
                    addr2 = (guint8 *) wmem_memdup(pinfo->pool, (const void *) dst_addr, (size_t) addr_len);
                    if ((dst_addr[addr_len - 1] & 0x1) != 0)
                    {
                        addr1[addr_len - 1]++;
                    }
                    else
                    {
                        addr2[addr_len - 1]--;
                    }
                    set_address(cinfo->addr1, AT_IPv4, addr_len, (void *) addr1);
                    set_address(cinfo->addr2, AT_IPv4, addr_len, (void *) addr2);
                    cinfo->port1 = pinfo->destport;
                    cinfo->port2 = cinfo->port1;
                }
                else
                {
                    switch (type)
                    {
                        case HDR_TYPE_PAD:
                        case HDR_TYPE_DATA:
                        case HDR_TYPE_SETUP:
                        case HDR_TYPE_RTT:
                            copy_address_wmem(pinfo->pool, cinfo->addr1, &(pinfo->src));
                            cinfo->port1 = pinfo->srcport;
                            copy_address_wmem(pinfo->pool, cinfo->addr2, &(pinfo->dst));
                            cinfo->port2 = pinfo->destport;
                            break;
                        case HDR_TYPE_NAK:
                        case HDR_TYPE_SM:
                            copy_address_wmem(pinfo->pool, cinfo->addr1, &(pinfo->dst));
                            cinfo->port1 = pinfo->destport;
                            copy_address_wmem(pinfo->pool, cinfo->addr2, &(pinfo->src));
                            cinfo->port2 = pinfo->srcport;
                            break;
                        default:
                            break;
                    }
                }
            }
            break;
        case AT_IPv6:
            {
                const guint8 * dst_addr = (const guint8 *) pinfo->dst.data;
                cinfo->addr1 = wmem_new0(pinfo->pool, address);
                cinfo->addr2 = wmem_new0(pinfo->pool, address);
                if (aeron_is_address_multicast(&(pinfo->dst)))
                {
                    guint8 * addr1;
                    guint8 * addr2;
                    addr1 = (guint8 *) wmem_memdup(pinfo->pool, (const void *) dst_addr, (size_t) addr_len);
                    addr2 = (guint8 *) wmem_memdup(pinfo->pool, (const void *) dst_addr, (size_t) addr_len);
                    if ((dst_addr[addr_len - 1] & 0x1) != 0)
                    {
                        addr1[addr_len - 1]++;
                    }
                    else
                    {
                        addr2[addr_len - 1]--;
                    }
                    set_address(cinfo->addr1, AT_IPv6, addr_len, (void *) addr1);
                    set_address(cinfo->addr2, AT_IPv6, addr_len, (void *) addr2);
                    cinfo->port1 = pinfo->destport;
                    cinfo->port2 = cinfo->port1;
                }
                else
                {
                    switch (type)
                    {
                        case HDR_TYPE_PAD:
                        case HDR_TYPE_DATA:
                        case HDR_TYPE_SETUP:
                        case HDR_TYPE_RTT:
                            copy_address_wmem(pinfo->pool, cinfo->addr1, &(pinfo->src));
                            cinfo->port1 = pinfo->srcport;
                            copy_address_wmem(pinfo->pool, cinfo->addr2, &(pinfo->dst));
                            cinfo->port2 = pinfo->destport;
                            break;
                        case HDR_TYPE_NAK:
                        case HDR_TYPE_SM:
                            copy_address_wmem(pinfo->pool, cinfo->addr1, &(pinfo->dst));
                            cinfo->port1 = pinfo->destport;
                            copy_address_wmem(pinfo->pool, cinfo->addr2, &(pinfo->src));
                            cinfo->port2 = pinfo->srcport;
                            break;
                        default:
                            break;
                    }
                }
            }
            break;
        default:
            return (NULL);
    }
    return (cinfo);
}
