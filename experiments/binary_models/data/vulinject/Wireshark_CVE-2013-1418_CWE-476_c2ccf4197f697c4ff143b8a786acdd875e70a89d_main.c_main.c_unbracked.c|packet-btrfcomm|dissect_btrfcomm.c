dissect_btrfcomm(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
    proto_item          *ti;
    proto_tree          *rfcomm_tree;
    gint                 offset     = 0;
    gint                 fcs_offset;
    guint8               dlci, cr_flag, ea_flag;
    guint8               frame_type, pf_flag;
    guint16              frame_len;
    btl2cap_data_t      *l2cap_data;
    service_info_t      *service_info = NULL;
    l2cap_data = (btl2cap_data_t *) data;
    ti = proto_tree_add_item(tree, proto_btrfcomm, tvb, offset, tvb_captured_length(tvb), ENC_NA);
    rfcomm_tree = proto_item_add_subtree(ti, ett_btrfcomm);
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "RFCOMM");
    switch (pinfo->p2p_dir) {
        case P2P_DIR_SENT:
            col_set_str(pinfo->cinfo, COL_INFO, "Sent ");
            break;
        case P2P_DIR_RECV:
            col_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");
            break;
        default:
            col_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");
            break;
    }
    offset = dissect_btrfcomm_address(tvb, pinfo, offset, rfcomm_tree, &ea_flag, &cr_flag, &dlci);
    offset = dissect_btrfcomm_control(tvb, offset, rfcomm_tree, &pf_flag, &frame_type);
    offset = dissect_btrfcomm_payload_length(tvb, offset, rfcomm_tree, &frame_len);
    if (dlci && (frame_len || (frame_type == FRAME_TYPE_UIH) || (frame_type == FRAME_TYPE_SABM))) {
        wmem_tree_key_t       key[10];
        guint32               k_interface_id;
        guint32               k_adapter_id;
        guint32               k_psm;
        guint32               k_direction;
        guint32               k_bd_addr_oui;
        guint32               k_bd_addr_id;
        guint32               k_service_type;
        guint32               k_frame_number;
        guint32               k_chandle;
        guint32               k_channel;
        guint32               k_dlci;
        service_direction_t  *service_direction;
        wmem_tree_t          *subtree;
        k_interface_id    = l2cap_data->interface_id;
        k_adapter_id      = l2cap_data->adapter_id;
        k_chandle         = l2cap_data->chandle;
        k_psm             = l2cap_data->psm;
        k_channel         = dlci >> 1;
        k_frame_number    = pinfo->num;
        k_dlci            = dlci;
        key[0].length = 1;
        key[0].key = &k_interface_id;
        key[1].length = 1;
        key[1].key = &k_adapter_id;
        key[2].length = 1;
        key[2].key = &k_chandle;
        key[3].length = 1;
        key[3].key = &k_psm;
        key[4].length = 1;
        key[4].key = &k_dlci;
        if (!pinfo->fd->visited && frame_type == FRAME_TYPE_SABM) {
            key[5].length = 0;
            key[5].key = NULL;
            subtree = (wmem_tree_t *) wmem_tree_lookup32_array(service_directions, key);
            service_direction = (subtree) ? (service_direction_t *) wmem_tree_lookup32_le(subtree, k_frame_number) : NULL;
            if (service_direction && service_direction->end_in == bluetooth_max_disconnect_in_frame) {
                service_direction->end_in = k_frame_number;
            }
            key[5].length = 1;
            key[5].key = &k_frame_number;
            key[6].length = 0;
            key[6].key = NULL;
            service_direction = wmem_new(wmem_file_scope(), service_direction_t);
            service_direction->direction = (pinfo->p2p_dir == P2P_DIR_RECV) ? P2P_DIR_SENT : P2P_DIR_RECV;
            service_direction->end_in = bluetooth_max_disconnect_in_frame;
            wmem_tree_insert32_array(service_directions, key, service_direction);
        }
        key[4].key = &k_channel;
        key[5].length = 0;
        key[5].key = NULL;
        subtree = (wmem_tree_t *) wmem_tree_lookup32_array(service_directions, key);
        service_direction = (subtree) ? (service_direction_t *) wmem_tree_lookup32_le(subtree, k_frame_number) : NULL;
        if (service_direction && service_direction->end_in > k_frame_number) {
            k_direction = service_direction->direction;
        } else {
            if (dlci & 0x01)
                k_direction = (l2cap_data->is_local_psm) ? P2P_DIR_RECV : P2P_DIR_SENT;
            else
                k_direction = (l2cap_data->is_local_psm) ? P2P_DIR_SENT : P2P_DIR_RECV;
        }
        k_psm = SDP_PSM_DEFAULT;
        if (k_direction == P2P_DIR_RECV) {
            k_bd_addr_oui     = l2cap_data->remote_bd_addr_oui;
            k_bd_addr_id      = l2cap_data->remote_bd_addr_id;
        } else {
            k_bd_addr_oui     = 0;
            k_bd_addr_id      = 0;
        }
        k_service_type    = BTSDP_RFCOMM_PROTOCOL_UUID;
        key[2].length = 1;
        key[2].key = &k_psm;
        key[3].length = 1;
        key[3].key = &k_direction;
        key[4].length = 1;
        key[4].key = &k_bd_addr_oui;
        key[5].length = 1;
        key[5].key = &k_bd_addr_id;
        key[6].length = 1;
        key[6].key = &k_service_type;
        key[7].length = 1;
        key[7].key = &k_channel;
        key[8].length = 1;
        key[8].key = &k_frame_number;
        key[9].length = 0;
        key[9].key = NULL;
        service_info = btsdp_get_service_info(key);
        if (service_info && service_info->interface_id == l2cap_data->interface_id &&
                service_info->adapter_id == l2cap_data->adapter_id &&
                service_info->sdp_psm == SDP_PSM_DEFAULT &&
                ((service_info->direction == P2P_DIR_RECV &&
                service_info->bd_addr_oui == l2cap_data->remote_bd_addr_oui &&
                service_info->bd_addr_id == l2cap_data->remote_bd_addr_id) ||
                (service_info->direction != P2P_DIR_RECV &&
                service_info->bd_addr_oui == 0 &&
                service_info->bd_addr_id == 0)) &&
                service_info->type == BTSDP_RFCOMM_PROTOCOL_UUID &&
                service_info->channel == (dlci >> 1)) {
        } else {
            service_info = wmem_new0(pinfo->pool, service_info_t);
        }
    }
    col_append_fstr(pinfo->cinfo, COL_INFO, "%s Channel=%u ",
                    val_to_str_const(frame_type, vs_frame_type_short, "Unknown"), dlci >> 1);
    if (dlci && (frame_type == FRAME_TYPE_SABM) && service_info) {
        if (service_info->uuid.size==16)
            col_append_fstr(pinfo->cinfo, COL_INFO, "(UUID128: %s) ", print_bluetooth_uuid(pinfo->pool, &service_info->uuid));
        else
            col_append_fstr(pinfo->cinfo, COL_INFO, "(%s) ",
                    val_to_str_ext_const(service_info->uuid.bt_uuid, &bluetooth_uuid_vals_ext, "Unknown"));
    }
    if ((frame_type == FRAME_TYPE_UIH) && dlci && pf_flag) {
        col_append_str(pinfo->cinfo, COL_INFO, "UID ");
        proto_tree_add_item(rfcomm_tree, hf_fc_credits, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset += 1;
    }
    fcs_offset = offset + frame_len;
    if (!dlci && frame_len) {
        proto_item *mcc_ti;
        proto_tree *ctrl_tree;
        proto_tree *dlci_tree;
        proto_item *dlci_item;
        guint32     mcc_type, length;
        guint8      mcc_cr_flag, mcc_ea_flag;
        guint8      mcc_channel;
        guint8      mcc_dlci;
        int         start_offset = offset;
        mcc_ti = proto_tree_add_item(rfcomm_tree, hf_mcc, tvb, offset, 1, ENC_NA);
        ctrl_tree = proto_item_add_subtree(mcc_ti, ett_btrfcomm_ctrl);
        offset = dissect_btrfcomm_MccType(tvb, offset, ctrl_tree, &mcc_cr_flag, &mcc_ea_flag, &mcc_type);
        offset = get_le_multi_byte_value(tvb, offset, ctrl_tree, &length, hf_mcc_len);
        if (length > (guint32) tvb_reported_length_remaining(tvb, offset)) {
            expert_add_info_format(pinfo, ctrl_tree, &ei_btrfcomm_mcc_length_bad, "Huge MCC length: %u", length);
            return offset;
        }
        switch(mcc_type) {
        case 0x20: 
            dissect_ctrl_pn(ctrl_tree, tvb, offset, &mcc_channel);
            break;
        case 0x24: 
            mcc_dlci = tvb_get_guint8(tvb, offset) >> 2;
            mcc_channel = mcc_dlci >> 1;
            dlci_item = proto_tree_add_item(ctrl_tree, hf_mcc_dlci, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            proto_item_append_text(dlci_item, " (Direction: %d, Channel: %u)", mcc_dlci & 0x01, mcc_channel);
            dlci_tree = proto_item_add_subtree(dlci_item, ett_mcc_dlci);
            proto_tree_add_item(dlci_tree, hf_mcc_channel, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            proto_tree_add_item(dlci_tree, hf_mcc_direction, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            proto_tree_add_item(ctrl_tree, hf_mcc_const_1, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            proto_tree_add_item(ctrl_tree, hf_mcc_ea, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            break;
        case 0x38: 
            dissect_ctrl_msc(ctrl_tree, tvb, offset, length, &mcc_channel);
            break;
        default:
            mcc_channel = -1;
        }
        if (mcc_channel > 0) {
            col_append_fstr(pinfo->cinfo, COL_INFO, "-> %d ", mcc_channel);
        }
        col_append_str(pinfo->cinfo, COL_INFO, "MPX_CTRL ");
        if(mcc_type){
            col_append_fstr(pinfo->cinfo, COL_INFO, "%s ", val_to_str_const(mcc_type, vs_ctl, "Unknown"));
        }
        offset += length;
        proto_item_set_len(mcc_ti, offset - start_offset);
    }
    if (dlci && frame_len) {
        dissector_handle_t  decode_by_dissector;
        tvbuff_t           *next_tvb;
        btrfcomm_data_t    *rfcomm_data;
        next_tvb = tvb_new_subset_length(tvb, offset, frame_len);
        rfcomm_data = (btrfcomm_data_t *) wmem_new(pinfo->pool, btrfcomm_data_t);
        rfcomm_data->interface_id       = l2cap_data->interface_id;
        rfcomm_data->adapter_id         = l2cap_data->adapter_id;
        rfcomm_data->chandle            = l2cap_data->chandle;
        rfcomm_data->cid                = l2cap_data->cid;
        rfcomm_data->is_local_psm       = l2cap_data->is_local_psm;
        rfcomm_data->dlci               = dlci;
        rfcomm_data->remote_bd_addr_oui = l2cap_data->remote_bd_addr_oui;
        rfcomm_data->remote_bd_addr_id  = l2cap_data->remote_bd_addr_id;
        if (service_info && service_info->uuid.size != 0 &&
                p_get_proto_data(pinfo->pool, pinfo, proto_bluetooth, PROTO_DATA_BLUETOOTH_SERVICE_UUID) == NULL) {
            guint8 *value_data;
            value_data = wmem_strdup(wmem_file_scope(), print_numeric_bluetooth_uuid(pinfo->pool, &service_info->uuid));
            p_add_proto_data(pinfo->pool, pinfo, proto_bluetooth, PROTO_DATA_BLUETOOTH_SERVICE_UUID, value_data);
        }
        if (!dissector_try_uint_new(rfcomm_dlci_dissector_table, (guint32) dlci,
                next_tvb, pinfo, tree, TRUE, rfcomm_data)) {
            if (service_info && (service_info->uuid.size == 0 ||
                !dissector_try_string(bluetooth_uuid_table, print_numeric_bluetooth_uuid(pinfo->pool, &service_info->uuid),
                    next_tvb, pinfo, tree, rfcomm_data))) {
                decode_by_dissector = find_proto_by_channel(dlci >> 1);
                if (rfcomm_channels_enabled && decode_by_dissector) {
                    call_dissector_with_data(decode_by_dissector, next_tvb, pinfo, tree, rfcomm_data);
                } else {
                    call_data_dissector(next_tvb, pinfo, tree);
                }
            }
        }
    }
    proto_tree_add_item(rfcomm_tree, hf_fcs, tvb, fcs_offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    return offset;
}
