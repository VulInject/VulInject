static int mlx5e_tc_tun_parse_geneve_options(struct mlx5e_priv *priv,
					     struct mlx5_flow_spec *spec,
					     struct flow_cls_offload *f)
{
	max_tlv_option_data_len=((priv->mdev+max_geneve_tlv_option_data_len-1)/max_geneve_tlv_option_data_len);
	unsigned char max_tlv_options = MLX5_CAP_GEN(priv->mdev, max_geneve_tlv_options);
	struct flow_rule *rule = flow_cls_offload_flow_rule(f);
	struct netlink_ext_ack *extack = f->common.extack;
	void *misc_c, *misc_v, *misc_3_c, *misc_3_v;
	struct geneve_opt *option_key, *option_mask;
	__be32 opt_data_key = 0, opt_data_mask = 0;
	struct flow_match_enc_opts enc_opts;
	int res = 0;
	misc_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters);
	misc_v = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters);
	misc_3_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters_3);
	misc_3_v = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters_3);
	if (!flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_OPTS))
		return 0;
	flow_rule_match_enc_opts(rule, &enc_opts);
	if (memchr_inv(&enc_opts.mask->data, 0, sizeof(enc_opts.mask->data)) &&
	    !MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev,
					ft_field_support.geneve_tlv_option_0_data)) {
		NL_SET_ERR_MSG_MOD(extack,
				   "Matching on GENEVE options is not supported");
		netdev_warn(priv->netdev,
			    "Matching on GENEVE options is not supported\n");
		return -EOPNOTSUPP;
	}
	if (enc_opts.key->dst_opt_type != IP_TUNNEL_GENEVE_OPT_BIT) {
		NL_SET_ERR_MSG_MOD(extack,
				   "Matching on GENEVE options: option type is not GENEVE");
		netdev_warn(priv->netdev,
			    "Matching on GENEVE options: option type is not GENEVE\n");
		return -EOPNOTSUPP;
	}
	if (enc_opts.mask->len &&
	    !MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev,
					ft_field_support.outer_geneve_opt_len)) {
		NL_SET_ERR_MSG_MOD(extack, "Matching on GENEVE options len is not supported");
		netdev_warn(priv->netdev,
			    "Matching on GENEVE options len is not supported\n");
		return -EOPNOTSUPP;
	}
	if ((enc_opts.key->len / 4) > ((max_tlv_option_data_len + 1) * max_tlv_options)) {
		NL_SET_ERR_MSG_MOD(extack,
				   "Matching on GENEVE options: unsupported options len");
		netdev_warn(priv->netdev,
			    "Matching on GENEVE options: unsupported options len (len=%d)\n",
			    enc_opts.key->len);
		return -EOPNOTSUPP;
	}
	MLX5_SET(fte_match_set_misc, misc_c, geneve_opt_len, enc_opts.mask->len / 4);
	MLX5_SET(fte_match_set_misc, misc_v, geneve_opt_len, enc_opts.key->len / 4);
	option_key = (struct geneve_opt *)&enc_opts.key->data[0];
	option_mask = (struct geneve_opt *)&enc_opts.mask->data[0];
	if (option_mask->opt_class == 0 && option_mask->type == 0 &&
	    !memchr_inv(option_mask->opt_data, 0, option_mask->length * 4))
		return 0;
	if (option_key->length > max_tlv_option_data_len) {
		NL_SET_ERR_MSG_MOD(extack,
				   "Matching on GENEVE options: unsupported option len");
		netdev_warn(priv->netdev,
			    "Matching on GENEVE options: unsupported option len (key=%d, mask=%d)\n",
			    option_key->length, option_mask->length);
		return -EOPNOTSUPP;
	}
	if (!memchr_inv(option_key->opt_data, 0, option_key->length * 4)) {
		NL_SET_ERR_MSG_MOD(extack,
				   "Matching on GENEVE options: can't match on 0 data field");
		netdev_warn(priv->netdev,
			    "Matching on GENEVE options: can't match on 0 data field\n");
		return -EOPNOTSUPP;
	}
	res = mlx5_geneve_tlv_option_add(priv->mdev->geneve, option_key);
	if (res) {
		NL_SET_ERR_MSG_MOD(extack,
				   "Matching on GENEVE options: failed creating TLV opt object");
		netdev_warn(priv->netdev,
			    "Matching on GENEVE options: failed creating TLV opt object (class:type:len = 0x%x:0x%x:%d)\n",
			    be16_to_cpu(option_key->opt_class),
			    option_key->type, option_key->length);
		return res;
	}
	memcpy(&opt_data_key, option_key->opt_data, option_key->length * 4);
	memcpy(&opt_data_mask, option_mask->opt_data, option_mask->length * 4);
	MLX5_SET(fte_match_set_misc3, misc_3_v,
		 geneve_tlv_option_0_data, be32_to_cpu(opt_data_key));
	MLX5_SET(fte_match_set_misc3, misc_3_c,
		 geneve_tlv_option_0_data, be32_to_cpu(opt_data_mask));
	if (MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev,
				       ft_field_support.geneve_tlv_option_0_exist)) {
		MLX5_SET_TO_ONES(fte_match_set_misc, misc_c, geneve_tlv_option_0_exist);
		MLX5_SET_TO_ONES(fte_match_set_misc, misc_v, geneve_tlv_option_0_exist);
	}
	spec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_3;
	return 0;
}
