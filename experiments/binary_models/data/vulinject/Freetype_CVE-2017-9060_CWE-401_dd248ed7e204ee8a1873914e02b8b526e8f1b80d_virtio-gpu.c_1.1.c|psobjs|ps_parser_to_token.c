  ps_parser_to_token( PS_Parser  parser,
                      T1_Token   token )
  {
    FT_Byte*  cur;
    FT_Byte*  limit;
    FT_Int    embed;
    token->type  = T1_TOKEN_TYPE_NONE;
    token->start = NULL;
    token->limit = NULL;
    cur   = parser->cursor;
    limit = parser->limit;
    if ( cur >= limit )
      return;
    switch ( *cur )
    {
    case '(':
      token->type  = T1_TOKEN_TYPE_STRING;
      token->start = cur;
      if ( skip_literal_string( &cur, limit ) == FT_Err_Ok )
        token->limit = cur;
      break;
    case '{':
      token->type  = T1_TOKEN_TYPE_ARRAY;
      token->start = cur;
      if ( skip_procedure( &cur, limit ) == FT_Err_Ok )
        token->limit = cur;
      break;
    case '[':
      token->type  = T1_TOKEN_TYPE_ARRAY;
      embed        = 1;
      token->start = cur++;
      parser->cursor = cur;
      ps_parser_skip_spaces( parser );
      cur = parser->cursor;
      while ( cur < limit && !parser->error )
      {
        if ( *cur == '[' )
          embed++;
        else if ( *cur == ']' )
        {
          embed--;
          if ( embed <= 0 )
          {
            token->limit = ++cur;
            break;
          }
        }
        parser->cursor = cur;
        ps_parser_skip_PS_token( parser );
        ps_parser_skip_spaces  ( parser );
        cur = parser->cursor;
      }
      break;
    default:
      token->start = cur;
      token->type  = ( *cur == '/' ) ? T1_TOKEN_TYPE_KEY : T1_TOKEN_TYPE_ANY;
      ps_parser_skip_PS_token( parser );
      cur = parser->cursor;
      if ( !parser->error )
        token->limit = cur;
    }
    if ( !token->limit )
    {
      token->start = NULL;
      token->type  = T1_TOKEN_TYPE_NONE;
    }
    parser->cursor = cur;
  }
