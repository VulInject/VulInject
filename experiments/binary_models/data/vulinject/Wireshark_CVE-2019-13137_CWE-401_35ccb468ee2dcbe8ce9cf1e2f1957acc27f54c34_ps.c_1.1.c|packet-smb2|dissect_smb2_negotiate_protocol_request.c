dissect_smb2_negotiate_protocol_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, smb2_info_t *si)
{
	guint16 dc;
	guint16 i;
	proto_item *nco_item, *ncc_item;
	gboolean supports_smb_3_10 = FALSE;
	guint32 nco;
	guint32 ncc;
	proto_item *hash_item = NULL;
	smb2_saved_info_t *ssi = si->saved;
	if (!pinfo->fd->visited && ssi) {
		ssi->preauth_hash_req = (guint8*)wmem_alloc0(wmem_file_scope(), SMB2_PREAUTH_HASH_SIZE);
		memset(si->conv->preauth_hash_ses, 0, SMB2_PREAUTH_HASH_SIZE);
		memset(si->conv->preauth_hash_con, 0, SMB2_PREAUTH_HASH_SIZE);
		si->conv->preauth_hash_current = si->conv->preauth_hash_con;
		update_preauth_hash(si->conv->preauth_hash_current, pinfo, tvb);
		memcpy(ssi->preauth_hash_req, si->conv->preauth_hash_current, SMB2_PREAUTH_HASH_SIZE);
	}
	if (ssi && ssi->preauth_hash_req) {
		hash_item = proto_tree_add_bytes_with_length(tree,
							     hf_smb2_preauth_hash, tvb,
							     0, tvb_captured_length(tvb),
							     ssi->preauth_hash_req, SMB2_PREAUTH_HASH_SIZE);
		proto_item_set_generated(hash_item);
	}
	offset = dissect_smb2_buffercode(tree, tvb, offset, NULL);
	dc = tvb_get_letohs(tvb, offset);
	proto_tree_add_item(tree, hf_smb2_dialect_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
	offset += 2;
	offset = dissect_smb2_secmode(tree, tvb, offset);
	offset++;
	proto_tree_add_item(tree, hf_smb2_reserved, tvb, offset, 2, ENC_NA);
	offset += 2;
	offset = dissect_smb2_capabilities(tree, tvb, offset);
	proto_tree_add_item(tree, hf_smb2_client_guid, tvb, offset, 16, ENC_LITTLE_ENDIAN);
	offset += 16;
	nco_item = proto_tree_add_item_ret_uint(tree, hf_smb2_negotiate_context_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN, &nco);
	offset += 4;
	ncc_item = proto_tree_add_item_ret_uint(tree, hf_smb2_negotiate_context_count, tvb, offset, 2, ENC_LITTLE_ENDIAN, &ncc);
	offset += 2;
	proto_tree_add_item(tree, hf_smb2_reserved, tvb, offset, 2, ENC_NA);
	offset += 2;
	for (i = 0 ; i < dc; i++) {
		guint16 d = tvb_get_letohs(tvb, offset);
		proto_tree_add_item(tree, hf_smb2_dialect, tvb, offset, 2, ENC_LITTLE_ENDIAN);
		offset += 2;
		if (d >= SMB2_DIALECT_310) {
			supports_smb_3_10 = TRUE;
		}
	}
	if (!supports_smb_3_10) {
		if (ncc != 0) {
			expert_add_info(pinfo, ncc_item, &ei_smb2_bad_negprot_negotiate_context_count);
			ncc = 0;
		}
		if (nco != 0) {
			expert_add_info(pinfo, nco_item, &ei_smb2_bad_negprot_negotiate_context_offset);
			nco = 0;
		}
	}
	if (nco != 0) {
		guint32 tmp = 0x40 + 36 + dc * 2;
		if (nco >= tmp) {
			offset += nco - tmp;
		} else {
			ncc = 0;
		}
	}
	for (i = 0; i < ncc; i++) {
		offset = dissect_smb2_negotiate_context(tvb, pinfo, tree, offset, si);
	}
	return offset;
}
