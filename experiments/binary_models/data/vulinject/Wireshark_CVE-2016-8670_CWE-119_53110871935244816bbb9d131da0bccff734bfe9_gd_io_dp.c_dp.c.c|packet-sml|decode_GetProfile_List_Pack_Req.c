static gboolean decode_GetProfile_List_Pack_Req (tvbuff_t *tvb, packet_info *pinfo, proto_tree *messagebodytree_list, guint *offset){
	proto_item *withRawdata = NULL;
	proto_item *SML_time = NULL;
	proto_item *treepath = NULL;
	proto_item *object_list = NULL;
	proto_item *dasDetails = NULL;
	proto_tree *withRawdata_tree = NULL;
	proto_tree *SML_time_tree = NULL;
	proto_tree *treepath_list = NULL;
	proto_tree *object_list_list = NULL;
	proto_tree *dasDetails_list = NULL;
	guint i = 0;
	guint repeat = 0;
	guint check = 0;
	guint data = 0;
	guint length = 0;
	field_serverId(tvb,messagebodytree_list, offset, &data, &length);
	field_username(tvb,messagebodytree_list, offset, &data, &length);
	field_password(tvb,messagebodytree_list, offset, &data, &length);
	get_length(tvb, offset, &data, &length);
	withRawdata = proto_tree_add_uint_format (messagebodytree_list, hf_sml_withRawdata, tvb, *offset, data+length, data+length, "withRawdata %s", (data == 0)? ": NOT SET" : "");
	if (data > 0) {
		withRawdata_tree = proto_item_add_subtree (withRawdata, ett_sml_withRawdata);
		proto_tree_add_item (withRawdata_tree, hf_sml_datatype, tvb, *offset, 1, ENC_BIG_ENDIAN);
		*offset+=1;
		proto_tree_add_item (withRawdata_tree, hf_sml_withRawdata, tvb, *offset, 1, ENC_BIG_ENDIAN);
		*offset+=1;
	}
	else
		*offset+=1;
	get_length(tvb, offset, &data, &length);
	SML_time_tree = proto_tree_add_subtree(messagebodytree_list, tvb, *offset, -1, ett_sml_time, &SML_time, "beginTime");
	if (data == 0){
		proto_item_append_text(SML_time, ": NOT SET");
		proto_item_set_len(SML_time, length + data);
		*offset+=1;
	}
	else {
		*offset+=1;
		sml_time_type(tvb, pinfo, SML_time_tree, offset);
		proto_item_set_end(SML_time,tvb,*offset);
	}
	get_length(tvb, offset, &data, &length);
	SML_time_tree = proto_tree_add_subtree(messagebodytree_list, tvb, *offset, -1, ett_sml_time, &SML_time, "endTime");
	if (data == 0){
		proto_item_append_text(SML_time, ": NOT SET");
		proto_item_set_len(SML_time, length + data);
		*offset+=1;
	}
	else {
		*offset+=1;
		sml_time_type(tvb, pinfo, SML_time_tree, offset);
		proto_item_set_end(SML_time,tvb,*offset);
	}
	get_length(tvb, offset, &data, &length);
	repeat = (data+length);
	treepath_list = proto_tree_add_subtree_format(messagebodytree_list, tvb, *offset, -1, ett_sml_treepath, &treepath,
					"parameterTreePath with %d %s", length+data, plurality(length+data, "element", "elements"));
	if ((tvb_get_guint8(tvb,*offset) & 0xF0) != LONG_LIST && (tvb_get_guint8(tvb,*offset) & 0xF0) != SHORT_LIST){
		expert_add_info_format(pinfo, treepath, &ei_sml_invalid_count, "invalid count of elements in Treepath");
		return TRUE;
	}
		if(repeat == 0) {
		expert_add_info_format(pinfo, treepath, &ei_sml_invalid_count, "invalid loop count");
		return TRUE;
	}
	*offset+=length;
	for (i=0; i< repeat; i++) {
		field_parameterTreePath(tvb, treepath_list, offset, &data, &length);
	}
	proto_item_set_end(treepath, tvb, *offset);
	object_list_list = proto_tree_add_subtree(messagebodytree_list, tvb, *offset, -1, ett_sml_object_list, &object_list, "object_List");
	if (tvb_get_guint8(tvb,*offset) == OPTIONAL){
		proto_item_append_text(object_list, ": NOT SET");
		proto_item_set_len(object_list, 1);
		*offset+=1;
	}
	else{
		get_length(tvb, offset, &data, &length);
		repeat = (data+length);
		proto_item_append_text(object_list, " with %d %s", length+data, plurality(length+data, "element", "elements"));
		if ((tvb_get_guint8(tvb,*offset) & 0xF0) != LONG_LIST && (tvb_get_guint8(tvb,*offset) & 0xF0) != SHORT_LIST){
			expert_add_info_format(pinfo, object_list, &ei_sml_invalid_count, "invalid count of elements in object_List");
			return TRUE;
		}
		else if (repeat <= 0){
			expert_add_info_format(pinfo, treepath, &ei_sml_invalid_count, "invalid loop count");
			return TRUE;
		}
		*offset+=length;
		for (i=0; i< repeat; i++) {
			field_ObjReqEntry(tvb, object_list_list, offset, &data, &length);
		}
		proto_item_set_end(object_list, tvb, *offset);
	}
	check = tvb_get_guint8(tvb,*offset);
	dasDetails_list = proto_tree_add_subtree(messagebodytree_list, tvb, *offset, -1, ett_sml_dasDetails, &dasDetails, "dasDetails");
	if (check == OPTIONAL){
		proto_item_append_text(dasDetails, ": NOT SET");
		proto_item_set_len(dasDetails, 1);
		*offset+=1;
	}
	else if ((check & 0xF0) == LONG_LIST || (check & 0xF0) == SHORT_LIST){
		get_length(tvb, offset, &data, &length);
		proto_item_append_text(dasDetails, " with %d %s", length+data, plurality(length+data, "element", "elements"));
		*offset+=length;
		child_tree(tvb, pinfo, dasDetails_list, offset, &data, &length);
		proto_item_set_end(dasDetails, tvb, *offset);
	}
	else {
		expert_add_info_format(pinfo, dasDetails, &ei_sml_invalid_count, "invalid count of elements in dasDetails");
		return TRUE;
	}
	return FALSE;
}
