sync_pipe_input_cb(GIOChannel *pipe_io, capture_session *cap_session)
{
    int  ret;
    char buffer[SP_MAX_MSG_LEN+1] = {0};
    ssize_t nread;
    char indicator;
    int exec_errno = 0;
    int  primary_len;
    char *primary_msg;
    int  secondary_len;
    char *secondary_msg;
    char *wait_msg, *combined_msg;
    unsigned int npackets = 0;
    nread = pipe_read_block(pipe_io, &indicator, SP_MAX_MSG_LEN, buffer,
                            &primary_msg);
		if(nread == 0) {
        ret = sync_pipe_wait_for_child(cap_session->fork_child, &wait_msg);
        if(nread == 0) {
            if (ret == -1)
                primary_msg = wait_msg;
        } else {
            if (ret == -1) {
                combined_msg = ws_strdup_printf("%s\n\n%s", primary_msg, wait_msg);
                g_free(primary_msg);
                g_free(wait_msg);
                primary_msg = combined_msg;
            }
        }
        cap_session->fork_child = WS_INVALID_PID;
        cap_session->fork_child_status = ret;
#ifdef _WIN32
        ws_close(cap_session->signal_pipe_write_fd);
#endif
        cap_session->capture_opts->closed_msg = primary_msg;
        if (extcap_session_stop(cap_session)) {
            capture_process_finished(cap_session);
        } else {
            extcap_request_stop(cap_session);
        }
        return false;
    }
    switch(indicator) {
    case SP_FILE:
        if(!cap_session->new_file(cap_session, buffer)) {
            ws_debug("file failed, closing capture");
            sync_pipe_stop(cap_session);
            cap_session->closed(cap_session, NULL);
            return false;
        }
        break;
    case SP_PACKET_COUNT:
        if (!ws_strtou32(buffer, NULL, &npackets)) {
            ws_warning("Invalid packets number: %s", buffer);
        }
        ws_debug("new packets %u", npackets);
        cap_session->count += npackets;
        cap_session->new_packets(cap_session, npackets);
        break;
    case SP_EXEC_FAILED:
        if (!ws_strtoi32(buffer, NULL, &exec_errno)) {
            ws_warning("Invalid errno: %s", buffer);
        }
        primary_msg = ws_strdup_printf("Couldn't run dumpcap in child process: %s",
                                       g_strerror(exec_errno));
        cap_session->error(cap_session, primary_msg, NULL);
        break;
    case SP_ERROR_MSG:
        pipe_convert_header((unsigned char*)buffer, 4, &indicator, &primary_len);
        primary_msg = buffer+4;
        pipe_convert_header((unsigned char*)primary_msg + primary_len, 4, &indicator, &secondary_len);
        secondary_msg = primary_msg + primary_len + 4;
        cap_session->error(cap_session, primary_msg, secondary_msg);
        break;
    case SP_LOG_MSG:
        sync_pipe_handle_log_msg(buffer);
        break;
    case SP_BAD_FILTER: {
        const char *message=NULL;
        unsigned int indx = 0;
        const char* end;
        if (ws_strtou32(buffer, &end, &indx) && end[0] == ':') {
            message = end + 1;
        }
        cap_session->cfilter_error(cap_session, indx, message);
        break;
        }
    case SP_DROPS: {
        const char *name = NULL;
        const char* end;
        unsigned int num = 0;
        if (ws_strtou32(buffer, &end, &num) && end[0] == ':') {
            name = end + 1;
        }
        cap_session->drops(cap_session, num, name);
        break;
        }
    default:
        if (g_ascii_isprint(indicator))
            ws_warning("Unknown indicator '%c'", indicator);
        else
            ws_warning("Unknown indicator '\\x%02x", indicator);
        break;
    }
    return true;
}
