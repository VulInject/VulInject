get_if_capabilities(interface_options *interface_opts,
    cap_device_open_status *status, char **status_str)
{
#if defined(HAVE_PCAP_OPEN) && defined(HAVE_PCAP_REMOTE)
    if_capabilities_t *caps;
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t *pch;
    int deflt;
    data_link_info_t *data_link_info;
    if (strncmp (interface_opts->name, "rpcap://", 8) == 0) {
        struct pcap_rmtauth auth;
        auth.type = interface_opts->auth_type == CAPTURE_AUTH_PWD ?
            RPCAP_RMTAUTH_PWD : RPCAP_RMTAUTH_NULL;
        auth.username = interface_opts->auth_username;
        auth.password = interface_opts->auth_password;
        errbuf[0] = '\0';
        pch = pcap_open(interface_opts->name, MIN_PACKET_SIZE, 0, 0, &auth,
            errbuf);
	if (pch == NULL) {
		*status = CAP_DEVICE_OPEN_ERROR_GENERIC;
		if (strcmp(errbuf, "not supported") == 0) {
			g_strlcpy(errbuf, "Remote capture not supported",
			    PCAP_ERRBUF_SIZE);
		}
		*status_str = g_strdup(errbuf[0] == '\0' ? "Unknown error (pcap bug; actual error cause not reported)" : errbuf);
		return NULL;
	}
        caps = (if_capabilities_t *)g_malloc0(sizeof *caps);
        caps->can_set_rfmon = false;
        caps->data_link_types = NULL;
        deflt = get_pcap_datalink(pch, interface_opts->name);
        data_link_info = create_data_link_info(deflt);
	caps->timestamp_types = get_pcap_timestamp_types(pch, NULL);
        pcap_close(pch);
        *status = CAP_DEVICE_OPEN_NO_ERR;
        *status_str = NULL;
        return caps;
    }
#endif 
    return get_if_capabilities_local(interface_opts, status, status_str);
}
