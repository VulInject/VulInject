dissect_fcswils(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
    proto_item          *ti            = NULL;
    guint8               opcode;
    guint8               failed_opcode = 0;
    int                  offset        = 0;
    conversation_t      *conversation;
    fcswils_conv_data_t *cdata;
    fcswils_conv_key_t   ckey, *req_key;
    proto_tree          *swils_tree    = NULL;
    guint8               isreq         = FC_SWILS_REQ;
    tvbuff_t            *next_tvb;
    fc_hdr *fchdr;
    fchdr = (fc_hdr *)data;
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "SW_ILS");
    opcode = tvb_get_guint8(tvb, 0);
    ti = proto_tree_add_protocol_format(tree, proto_fcswils, tvb, 0, -1, "SW_ILS");
    swils_tree = proto_item_add_subtree(ti, ett_fcswils);
    if ((opcode != FC_SWILS_SWACC) && (opcode != FC_SWILS_SWRJT)) {
        conversation = find_conversation(pinfo->num, &pinfo->src, &pinfo->dst,
                                         conversation_pt_to_conversation_type(pinfo->ptype), fchdr->oxid,
                                         fchdr->rxid, NO_PORT_B);
        if (!conversation) {
            conversation = conversation_new(pinfo->num, &pinfo->src, &pinfo->dst,
                                            conversation_pt_to_conversation_type(pinfo->ptype), fchdr->oxid,
                                            fchdr->rxid, NO_PORT2);
        }
        ckey.conv_idx = conversation->conv_index;
        cdata = (fcswils_conv_data_t *)wmem_map_lookup(fcswils_req_hash,
                                                           &ckey);
        if (cdata) {
            cdata->opcode = opcode;
        }
        else {
            req_key = wmem_new(wmem_file_scope(), fcswils_conv_key_t);
            req_key->conv_idx = conversation->conv_index;
            cdata = wmem_new(wmem_file_scope(), fcswils_conv_data_t);
            cdata->opcode = opcode;
            wmem_map_insert(fcswils_req_hash, req_key, cdata);
        }
    }
    else {
        conversation = find_conversation(pinfo->num, &pinfo->src, &pinfo->dst,
                                         conversation_pt_to_conversation_type(pinfo->ptype), fchdr->oxid,
                                         fchdr->rxid, NO_PORT_B);
        isreq = FC_SWILS_RPLY;
        if (!conversation) {
            if (tree && (opcode == FC_SWILS_SWACC)) {
                proto_tree_add_expert_format(swils_tree, pinfo, &ei_swils_no_exchange, tvb, 0, -1, "No record of Exchg. Unable to decode SW_ACC");
                return 0;
            }
        }
        else {
            ckey.conv_idx = conversation->conv_index;
            cdata = (fcswils_conv_data_t *)wmem_map_lookup(fcswils_req_hash, &ckey);
            if (cdata != NULL) {
                if (opcode == FC_SWILS_SWACC)
                    opcode = cdata->opcode;
                else
                    failed_opcode = cdata->opcode;
            }
            if (tree) {
                if ((cdata == NULL) && (opcode != FC_SWILS_SWRJT)) {
                    proto_tree_add_expert_format(swils_tree, pinfo, &ei_swils_no_exchange, tvb, 0, -1, "No record of SW_ILS Req. Unable to decode SW_ACC");
                    return 0;
                }
            }
        }
    }
    if (isreq == FC_SWILS_REQ) {
        col_add_str(pinfo->cinfo, COL_INFO,
                    val_to_str(opcode, fc_swils_opcode_key_val, "0x%x"));
    }
    else if (opcode == FC_SWILS_SWRJT) {
        col_add_fstr(pinfo->cinfo, COL_INFO, "SW_RJT (%s)",
                        val_to_str(failed_opcode, fc_swils_opcode_key_val, "0x%x"));
    }
    else {
        col_add_fstr(pinfo->cinfo, COL_INFO, "SW_ACC (%s)",
                        val_to_str(opcode, fc_swils_opcode_key_val, "0x%x"));
    }
    proto_tree_add_item(swils_tree, hf_swils_opcode, tvb, offset, 1, ENC_BIG_ENDIAN);
    if ((opcode < FC_SWILS_MAXCODE) && fcswils_func_table[opcode].func) {
        fcswils_func_table[opcode].func(tvb, pinfo, swils_tree, isreq);
    } else if (opcode == FC_SWILS_AUTH_ILS) {
        if (isreq && fcsp_handle)
            call_dissector(fcsp_handle, tvb, pinfo, swils_tree);
    } else {
        next_tvb = tvb_new_subset_remaining(tvb, offset+4);
        call_data_dissector(next_tvb, pinfo, tree);
    }
    return tvb_captured_length(tvb);
}
