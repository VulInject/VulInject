static void lec_vcc_close(struct lec_priv *priv, struct atm_vcc *vcc)
{
	unsigned int flags;
	struct hlist_node *next;
	struct lec_arp_table *entry;
	int i;
	pr_debug("LEC_ARP: lec_vcc_close vpi:%d vci:%d\n", vcc->vpi, vcc->vci);
	dump_arp_table(priv);
	spin_lock_irqsave(&priv->lec_arp_lock, flags);
	for (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {
		hlist_for_each_entry_safe(entry, next,
					  &priv->lec_arp_tables[i], next) {
			if (vcc == entry->vcc) {
				lec_arp_put(entry);
				if (priv->mcast_vcc == vcc)
					priv->mcast_vcc = NULL;
			}
		}
	}
	hlist_for_each_entry_safe(entry, next,
				  &priv->lec_arp_empty_ones, next) {
		if (entry->vcc == vcc) {
			lec_arp_clear_vccs(entry);
			del_timer(&entry->timer);
			hlist_del(&entry->next);
			lec_arp_put(entry);
		}
	}
	hlist_for_each_entry_safe(entry, next,
				  &priv->lec_no_forward, next) {
		if (entry->recv_vcc == vcc) {
			lec_arp_clear_vccs(entry);
			del_timer(&entry->timer);
			hlist_del(&entry->next);
			lec_arp_put(entry);
		}
	}
	hlist_for_each_entry_safe(entry, next, &priv->mcast_fwds, next) {
		if (entry->recv_vcc == vcc) {
			lec_arp_clear_vccs(entry);
			hlist_del(&entry->next);
			lec_arp_put(entry);
		}
	}
	spin_unlock_irqrestore(&priv->lec_arp_lock, flags);
	dump_arp_table(priv);
}
