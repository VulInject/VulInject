dissect_epsem(tvbuff_t *tvb, int offset, guint32 len, packet_info *pinfo, proto_tree *tree)
{
  proto_tree *cmd_tree = NULL;
  proto_tree *ct = NULL;
  proto_tree *crypto_tree = NULL;
  proto_tree *yt = NULL;
  proto_item *item = NULL;
  guint8 flags;
  int local_offset;
  gint len2;
  int cmd_err;
  bool ind;
  guchar *buffer;
  tvbuff_t *epsem_buffer = NULL;
  gboolean crypto_good = FALSE;
  gboolean crypto_bad = FALSE;
  gboolean hasmac = FALSE;
  gboolean encrypted = FALSE;
  if ((tvb == NULL) && (len == 0)) {
    expert_add_info(pinfo, tree, &ei_c1222_epsem_missing);
    return offset;
  }
  flags = tvb_get_guint8(tvb, offset);
  proto_tree_add_bitmask(tree, tvb, offset, hf_c1222_epsem_flags, ett_c1222_flags, c1222_flags, ENC_BIG_ENDIAN);
  offset++;
  switch ((flags & C1222_EPSEM_FLAG_SECURITY_MODE) >> 2) {
    case EAX_MODE_CIPHERTEXT_AUTH:
      hasmac = TRUE;
      len2 = tvb_reported_length_remaining(tvb, offset);
      if (len2 <= 0)
        return offset;
      encrypted = TRUE;
      if (c1222_decrypt) {
        buffer = (guchar *)tvb_memdup(pinfo->pool, tvb, offset, len2);
        if (!decrypt_packet(buffer, len2, TRUE)) {
          crypto_bad = TRUE;
        } else {
          epsem_buffer = tvb_new_real_data(buffer, len2, len2);
          tvb_set_child_real_data_tvbuff(tvb, epsem_buffer);
          add_new_data_source(pinfo, epsem_buffer, "Decrypted EPSEM Data");
          crypto_good = TRUE;
          encrypted = FALSE;
        }
      }
      break;
    case EAX_MODE_CLEARTEXT_AUTH:
      hasmac = TRUE;
      len2 = tvb_reported_length_remaining(tvb, offset);
      if (len2 <= 0)
        return offset;
      epsem_buffer = tvb_new_subset_remaining(tvb, offset);
      buffer = (guchar *)tvb_memdup(pinfo->pool, tvb, offset, len2);
      if (c1222_decrypt) {
        if (!decrypt_packet(buffer, len2, FALSE)) {
          crypto_bad = TRUE;
          expert_add_info(pinfo, tree, &ei_c1222_epsem_failed_authentication);
        } else {
          crypto_good = TRUE;
        }
      }
      break;
    default:
      epsem_buffer = tvb_new_subset_remaining(tvb, offset);
  }
  if (encrypted) {
    proto_tree_add_item(tree, hf_c1222_epsem_total, tvb, offset, -1, ENC_NA);
    expert_add_info(pinfo, tree, &ei_c1222_epsem_not_decrypted);
    local_offset = offset+len2-4;
    epsem_buffer = tvb;
  } else {  
    local_offset = 0;
    if (flags & C1222_EPSEM_FLAG_ED_CLASS_INCLUDED) {
      if (tvb_offset_exists(epsem_buffer, local_offset+4-1)) {
        proto_tree_add_item(tree, hf_c1222_epsem_ed_class, epsem_buffer, local_offset, 4, ENC_NA);
        local_offset += 4;
      } else {
        expert_add_info(pinfo, tree, &ei_c1222_ed_class_missing);
      }
    }
    while (tvb_offset_exists(epsem_buffer, local_offset+(hasmac?5:1))) {
      if (ber_len_ok(epsem_buffer, local_offset)) {
        local_offset = dissect_ber_length(pinfo, tree, epsem_buffer, local_offset, (guint32 *)&len2, &ind);
      } else {
        expert_add_info(pinfo, tree, &ei_c1222_epsem_ber_length_error);
        return offset+len;
      }
      if (tvb_offset_exists(epsem_buffer, local_offset+len2-1)) {
        cmd_err = tvb_get_guint8(epsem_buffer, local_offset);
        ct = proto_tree_add_item(tree, hf_c1222_epsem_total, epsem_buffer, local_offset, len2, ENC_NA);
        cmd_tree = proto_item_add_subtree(ct, ett_c1222_cmd);
        parse_c1222_detailed(epsem_buffer, pinfo, cmd_tree, cmd_err, (guint32 *)&len2, &local_offset);
        local_offset += len2;
      } else {
        expert_add_info(pinfo, tree, &ei_c1222_epsem_field_length_error);
        return offset+len;
      }
    }
  }
  if (hasmac) {
    if (tvb_offset_exists(epsem_buffer, local_offset+4-1)) {
      yt = proto_tree_add_item(tree, hf_c1222_epsem_mac, epsem_buffer, local_offset, 4, ENC_NA);
      crypto_tree = proto_item_add_subtree(yt, ett_c1222_crypto);
      item = proto_tree_add_boolean(crypto_tree, hf_c1222_epsem_crypto_good, tvb, local_offset, 4, crypto_good);
      item = proto_tree_add_boolean(crypto_tree, hf_c1222_epsem_crypto_bad, tvb, local_offset, 4, crypto_bad);
      proto_item_set_generated(item);
    } else {
      expert_add_info(pinfo, tree, &ei_c1222_mac_missing);
      return offset+len;
    }
  }
  return offset;
}
