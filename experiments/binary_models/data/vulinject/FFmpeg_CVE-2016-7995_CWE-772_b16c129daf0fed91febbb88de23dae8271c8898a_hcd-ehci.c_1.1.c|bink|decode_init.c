static av_cold int decode_init(AVCodecContext *avctx)
{
    static AVOnce init_static_once = AV_ONCE_INIT;
    BinkContext * const c = avctx->priv_data;
    HpelDSPContext hdsp;
    int ret;
    int flags;
    c->version = avctx->codec_tag >> 24;
    if (avctx->extradata_size < 4) {
        av_log(avctx, AV_LOG_ERROR, "Extradata missing or too short\n");
        return AVERROR_INVALIDDATA;
    }
    flags = AV_RL32(avctx->extradata);
    c->has_alpha = flags & BINK_FLAG_ALPHA;
    c->swap_planes = c->version >= 'h';
    c->avctx = avctx;
    if ((ret = av_image_check_size(avctx->width, avctx->height, 0, avctx)) < 0)
        return ret;
    c->last = av_frame_alloc();
    if (!c->last)
        return AVERROR(ENOMEM);
    avctx->pix_fmt = c->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;
    avctx->color_range = c->version == 'k' ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG;
    ff_hpeldsp_init(&hdsp, avctx->flags);
    c->put_pixels_tab = hdsp.put_pixels_tab[1][0];
    ff_binkdsp_init(&c->binkdsp);
    if ((ret = init_bundles(c)) < 0)
        return ret;
    if (c->version == 'b') {
        static AVOnce binkb_init_once = AV_ONCE_INIT;
        ff_thread_once(&binkb_init_once, binkb_calc_quant);
    }
    ff_thread_once(&init_static_once, bink_init_vlcs);
    return 0;
}
