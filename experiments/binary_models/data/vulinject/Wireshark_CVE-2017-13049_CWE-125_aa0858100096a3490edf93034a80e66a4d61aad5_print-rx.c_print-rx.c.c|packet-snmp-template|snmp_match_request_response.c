snmp_match_request_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint requestId, guint procedure_id, snmp_conv_info_t *snmp_info)
{
	snmp_request_response_t *srrp=NULL;
	DISSECTOR_ASSERT_HINT(snmp_info, "No SNMP info from ASN1 context");
	srrp=(snmp_request_response_t *)snmp_get_request_response_pointer(snmp_info->request_response, requestId);
	if (!PINFO_FD_VISITED(pinfo)) {
		switch(procedure_id)
		{
			case SNMP_REQ_GET:
			case SNMP_REQ_GETNEXT:
			case SNMP_REQ_SET:
			case SNMP_REQ_GETBULK:
			case SNMP_REQ_INFORM:
				srrp->request_frame_id=pinfo->fd->num;
				srrp->response_frame_id=0;
				srrp->request_time=pinfo->abs_ts;
				srrp->request_procedure_id=procedure_id;
				break;
			case SNMP_RES_GET:
				srrp->response_frame_id=pinfo->fd->num;
				break;
			default:
				return NULL;
		}
	}
	if (srrp->request_frame_id!=0 && srrp->response_frame_id!=0)
	{
		proto_item *it;
		if (srrp->response_frame_id == pinfo->fd->num)
		{
			nstime_t ns;
			it=proto_tree_add_uint(tree, hf_snmp_response_to, tvb, 0, 0, srrp->request_frame_id);
			nstime_delta(&ns, &pinfo->abs_ts, &srrp->request_time);
			it=proto_tree_add_time(tree, hf_snmp_time, tvb, 0, 0, &ns);
			proto_item_set_generated(it);
			return srrp;
		} else {
			it=proto_tree_add_uint(tree, hf_snmp_response_in, tvb, 0, 0, srrp->response_frame_id);
			proto_item_set_generated(it);
		}
	}
	return NULL;
}
