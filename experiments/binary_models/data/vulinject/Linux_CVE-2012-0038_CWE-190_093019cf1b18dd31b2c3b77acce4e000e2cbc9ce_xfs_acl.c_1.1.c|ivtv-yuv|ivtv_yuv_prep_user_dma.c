static int ivtv_yuv_prep_user_dma(struct ivtv *itv, struct ivtv_user_dma *dma,
				  struct ivtv_dma_frame *args)
{
	struct ivtv_dma_page_info y_dma;
	struct ivtv_dma_page_info uv_dma;
	struct yuv_playback_info *yi = &itv->yuv_info;
	unsigned char frame = yi->draw_frame;
	struct yuv_frame_info *f = &yi->new_frame_info[frame];
	int y_pages, uv_pages;
	unsigned int y_buffer_offset, uv_buffer_offset;
	int y_decode_height, uv_decode_height, y_size;
	y_buffer_offset = IVTV_DECODER_OFFSET + yuv_offset[frame];
	uv_buffer_offset = y_buffer_offset + IVTV_YUV_BUFFER_UV_OFFSET;
	y_decode_height = uv_decode_height = f->src_h + f->src_y;
	if (f->offset_y)
		y_buffer_offset += 720 * 16;
	if (y_decode_height & 15)
		y_decode_height = (y_decode_height + 16) & ~15;
	if (uv_decode_height & 31)
		uv_decode_height = (uv_decode_height + 32) & ~31;
	y_size = 720 * y_decode_height;
	if (dma->SG_length || dma->page_count) {
		IVTV_DEBUG_WARN
		    ("prep_user_dma: SG_length %d page_count %d still full?\n",
		     dma->SG_length, dma->page_count);
		return -EBUSY;
	}
	ivtv_udma_get_page_info (&y_dma, (unsigned int)args->y_source, 720 * y_decode_height);
	ivtv_udma_get_page_info (&uv_dma, (unsigned int)args->uv_source, 360 * uv_decode_height);
	y_pages = pin_user_pages_unlocked(y_dma.uaddr,
			y_dma.page_count, &dma->map[0], 0);
	uv_pages = 0; 
	if (y_pages == y_dma.page_count) {
		uv_pages = pin_user_pages_unlocked(uv_dma.uaddr,
				uv_dma.page_count, &dma->map[y_pages], 0);
	}
	if (y_pages != y_dma.page_count || uv_pages != uv_dma.page_count) {
		int rc = -EFAULT;
		if (y_pages == y_dma.page_count) {
			IVTV_DEBUG_WARN
				("failed to map uv user pages, returned %d expecting %d\n",
				 uv_pages, uv_dma.page_count);
			if (uv_pages >= 0) {
				unpin_user_pages(&dma->map[y_pages], uv_pages);
				rc = -EFAULT;
			} else {
				rc = uv_pages;
			}
		} else {
			IVTV_DEBUG_WARN
				("failed to map y user pages, returned %d expecting %d\n",
				 y_pages, y_dma.page_count);
		}
		if (y_pages >= 0) {
			unpin_user_pages(dma->map, y_pages);
		} else {
			rc = y_pages;
		}
		return rc;
	}
	dma->page_count = y_pages + uv_pages;
	if (ivtv_udma_fill_sg_list (dma, &uv_dma, ivtv_udma_fill_sg_list (dma, &y_dma, 0)) < 0) {
		IVTV_DEBUG_WARN("could not allocate bounce buffers for highmem userspace buffers\n");
		unpin_user_pages(dma->map, dma->page_count);
		dma->page_count = 0;
		return -ENOMEM;
	}
	dma->SG_length = dma_map_sg(&itv->pdev->dev, dma->SGlist,
				    dma->page_count, DMA_TO_DEVICE);
	ivtv_udma_fill_sg_array(dma, y_buffer_offset, uv_buffer_offset, y_size);
	if (f->offset_y && yi->blanking_dmaptr) {
		dma->SGarray[dma->SG_length].size = cpu_to_le32(720*16);
		dma->SGarray[dma->SG_length].src = cpu_to_le32(yi->blanking_dmaptr);
		dma->SGarray[dma->SG_length].dst = cpu_to_le32(IVTV_DECODER_OFFSET + yuv_offset[frame]);
		dma->SG_length++;
	}
	dma->SGarray[dma->SG_length - 1].size |= cpu_to_le32(0x80000000);
	ivtv_udma_sync_for_device(itv);
	return 0;
}
