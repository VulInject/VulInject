ssize_t ctucan_receive(CanBusClientState *client, const qemu_can_frame *frames,
                        size_t frames_cnt)
{
    CtuCanCoreState *s = container_of(client, CtuCanCoreState, bus_client);
    static uint8_t rcv[CTUCAN_MSG_MAX_LEN];
    int i;
    int ret = -1;
    const qemu_can_frame *frame = frames;
    union ctu_can_fd_int_stat int_stat;
    int_stat.u32 = 0;
    if (frames_cnt <= 0) {
        return 0;
    }
    ret = ctucan_frame2buff(frame, rcv);
    if (s->rx_cnt + ret > CTUCAN_RCV_BUF_LEN) { /* Data overrun. */
        s->status.s.dor = 1;
        int_stat.s.doi = 1;
        s->int_stat.u32 |= int_stat.u32 & ~s->int_mask.u32;
        DPRINTF("Receive FIFO overrun\n");
        return ret;
    }
    s->status.s.idle = 0;
    s->status.s.rxs = 1;
    int_stat.s.rxi = 1;
    if (((s->rx_cnt + 3) & ~3) == CTUCAN_RCV_BUF_LEN) {
        int_stat.s.rxfi = 1;
    }
    s->int_stat.u32 |= int_stat.u32 & ~s->int_mask.u32;
    s->rx_fr_ctr.s.rx_fr_ctr_val++;
    s->rx_status_rx_settings.s.rxfrc++;
    for (i = 0; i < ret; i++) {
        s->rx_buff[(s->rx_tail_pos + s->rx_cnt) % CTUCAN_RCV_BUF_LEN] = rcv[i];
        s->rx_cnt++;
    }
    s->status.s.rxne = 1;
    ctucan_update_irq(s);
    return 1;
}
