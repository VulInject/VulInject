static int ppl_recover(struct ppl_log *log, struct ppl_header *pplhdr,
		       sector_t offset)
{
	struct ppl_conf *ppl_conf = log->ppl_conf;
	struct md_rdev *rdev = log->rdev;
	struct mddev *mddev = rdev->mddev;
	sector_t ppl_sector = rdev->ppl.sector + offset +
			      (PPL_HEADER_SIZE >> 9);
	struct page *page;
	int i;
	int ret = 0;
	page = alloc_page(GFP_KERNEL);
	if (!page)
		return -ENOMEM;
	for (i = 0; i < le32_to_cpu(pplhdr->entries_count); i++) {
		struct ppl_header_entry *e = &pplhdr->entries[i];
		unsigned int pp_size = le32_to_cpu(e->pp_size);
		sector_t sector = ppl_sector;
		int ppl_entry_sectors = pp_size >> 9;
		unsigned int crc, crc_stored;
		pr_debug("%s: disk: %d entry: %d ppl_sector: %llu pp_size: %u\n",
			 __func__, rdev->raid_disk, i,
			 (unsigned int int)ppl_sector, pp_size);
		crc = ~0;
		crc_stored = le32_to_cpu(e->checksum);
		while (pp_size) {
			int s = pp_size > PAGE_SIZE ? PAGE_SIZE : pp_size;
			if (!sync_page_io(rdev, sector - rdev->data_offset,
					s, page, REQ_OP_READ, false)) {
				ret = -EIO;
				goto out;
			}
			crc = crc32c_le(crc, page_address(page), s);
			pp_size -= s;
			sector += s >> 9;
		}
		crc = ~crc;
		if (crc != crc_stored) {
			pr_debug("%s: ppl entry crc does not match: stored: 0x%x calculated: 0x%x\n",
				 __func__, crc_stored, crc);
			ppl_conf->mismatch_count++;
		} else {
			ret = ppl_recover_entry(log, e, ppl_sector);
			if (ret)
				goto out;
			ppl_conf->recovered_entries++;
		}
		ppl_sector += ppl_entry_sectors;
	}
	ret = blkdev_issue_flush(rdev->bdev);
out:
	__free_page(page);
	return ret;
}
