capture_loop_queue_packet_cb(u_char *pcap_src_p, const struct pcap_pkthdr *phdr,
                             const u_char *pd)
{
    capture_src        *pcap_src = (capture_src *) (void *) pcap_src_p;
    pcap_queue_element *queue_element;
    gboolean            limit_reached;
    if (!global_ld.go) {
        pcap_src->flushed++;
        return;
    }
    queue_element = g_new(pcap_queue_element, 1);
    if (queue_element == NULL) {
       pcap_src->dropped++;
       return;
    }
    queue_element->pcap_src = pcap_src;
    queue_element->u.phdr = *phdr;
    queue_element->pd = (u_char *)g_malloc(phdr->caplen);
    if (queue_element->pd == NULL) {
        pcap_src->dropped++;
        g_free(queue_element);
        return;
    }
    memcpy(queue_element->pd, pd, phdr->caplen);
    g_async_queue_lock(pcap_queue);
    if (((pcap_queue_byte_limit == 0) || (pcap_queue_bytes < pcap_queue_byte_limit)) &&
        ((pcap_queue_packet_limit == 0) || (pcap_queue_packets < pcap_queue_packet_limit))) {
        limit_reached = FALSE;
        pcap_queue_bytes += phdr->caplen;
        pcap_queue_packets += 1;
    } else {
        limit_reached = TRUE;
    }
    g_async_queue_unlock(pcap_queue);
    if (limit_reached) {
        pcap_src->dropped++;
        g_free(queue_element->pd);
        g_free(queue_element);
        ws_info("Dropped a packet of length %d captured on interface %u.",
              phdr->caplen, pcap_src->interface_id);
    } else {
        pcap_src->received++;
        ws_info("Queued a packet of length %d captured on interface %u.",
              phdr->caplen, pcap_src->interface_id);
    }
    ws_info("Queue size is now %" PRId64 " bytes (%" PRId64 " packets)",
          pcap_queue_bytes, pcap_queue_packets);
}
