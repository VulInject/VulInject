static void omap2_gpio_module_write(void *opaque, hwaddr addr,
                uint32_t value)
{
    struct omap2_gpio_s *s = opaque;
    uint32_t diff;
    int ln;
    switch (addr) {
    case 0x00:	/* GPIO_REVISION */
    case 0x14:	/* GPIO_SYSSTATUS */
    case 0x38:	/* GPIO_DATAIN */
        break;
    case 0x10:	/* GPIO_SYSCONFIG */
        if (((value >> 3) & 3) == 3) {
            qemu_log_mask(LOG_GUEST_ERROR,
                          "%s: Illegal IDLEMODE value: 3\n", __func__);
        }
        if (value & 2)
            omap2_gpio_module_reset(s);
        s->config[0] = value & 0x1d;
        break;
    case 0x18:	/* GPIO_IRQSTATUS1 */
        if (s->ints[0] & value) {
            s->ints[0] &= ~value;
            omap2_gpio_module_level_update(s, 0);
        }
        break;
    case 0x1c:	/* GPIO_IRQENABLE1 */
        s->mask[0] = value;
        omap2_gpio_module_int_update(s, 0);
        break;
    case 0x20:	/* GPIO_WAKEUPENABLE */
        s->wumask = value;
        break;
    case 0x28:	/* GPIO_IRQSTATUS2 */
        if (s->ints[1] & value) {
            s->ints[1] &= ~value;
            omap2_gpio_module_level_update(s, 1);
        }
        break;
    case 0x2c:	/* GPIO_IRQENABLE2 */
        s->mask[1] = value;
        omap2_gpio_module_int_update(s, 1);
        break;
    case 0x30:	/* GPIO_CTRL */
        s->config[1] = value & 7;
        break;
    case 0x34:	/* GPIO_OE */
        diff = s->outputs & (s->dir ^ value);
        s->dir = value;
        value = s->outputs & ~s->dir;
        while ((ln = ctz32(diff)) != 32) {
            diff &= ~(1 << ln);
            qemu_set_irq(s->handler[ln], (value >> ln) & 1);
        }
        omap2_gpio_module_level_update(s, 0);
        omap2_gpio_module_level_update(s, 1);
        break;
    case 0x3c:	/* GPIO_DATAOUT */
        omap2_gpio_module_out_update(s, s->outputs ^ value);
        break;
    case 0x40:	/* GPIO_LEVELDETECT0 */
        s->level[0] = value;
        omap2_gpio_module_level_update(s, 0);
        omap2_gpio_module_level_update(s, 1);
        break;
    case 0x44:	/* GPIO_LEVELDETECT1 */
        s->level[1] = value;
        omap2_gpio_module_level_update(s, 0);
        omap2_gpio_module_level_update(s, 1);
        break;
    case 0x48:	/* GPIO_RISINGDETECT */
        s->edge[0] = value;
        break;
    case 0x4c:	/* GPIO_FALLINGDETECT */
        s->edge[1] = value;
        break;
    case 0x50:	/* GPIO_DEBOUNCENABLE */
        s->debounce = value;
        break;
    case 0x54:	/* GPIO_DEBOUNCINGTIME */
        s->delay = value;
        break;
    case 0x60:	/* GPIO_CLEARIRQENABLE1 */
        s->mask[0] &= ~value;
        omap2_gpio_module_int_update(s, 0);
        break;
    case 0x64:	/* GPIO_SETIRQENABLE1 */
        s->mask[0] |= value;
        omap2_gpio_module_int_update(s, 0);
        break;
    case 0x70:	/* GPIO_CLEARIRQENABLE2 */
        s->mask[1] &= ~value;
        omap2_gpio_module_int_update(s, 1);
        break;
    case 0x74:	/* GPIO_SETIREQNEABLE2 */
        s->mask[1] |= value;
        omap2_gpio_module_int_update(s, 1);
        break;
    case 0x80:	/* GPIO_CLEARWKUENA */
        s->wumask &= ~value;
        break;
    case 0x84:	/* GPIO_SETWKUENA */
        s->wumask |= value;
        break;
    case 0x90:	/* GPIO_CLEARDATAOUT */
        omap2_gpio_module_out_update(s, s->outputs & value);
        break;
    case 0x94:	/* GPIO_SETDATAOUT */
        omap2_gpio_module_out_update(s, ~s->outputs & value);
        break;
    default:
        OMAP_BAD_REG(addr);
        return;
    }
}
