ospf_te_lsa_print(netdissect_options *ndo,
                  const u_char *tptr, u_int ls_length)
{
    u_int tlv_type, tlv_length;
    while (ls_length != 0) {
        if (ls_length < 4) {
            ND_PRINT("\n\t    Remaining LS length %u < 4", ls_length);
            return -1;
        }
        tlv_type = GET_BE_U_2(tptr);
        tlv_length = GET_BE_U_2(tptr + 2);
        tptr+=4;
        ls_length-=4;
        ND_PRINT("\n\t    %s TLV (%u), length: %u",
               tok2str(lsa_opaque_te_tlv_values,"unknown",tlv_type),
               tlv_type,
               tlv_length);
        if (tlv_length > ls_length) {
            ND_PRINT("\n\t    Bogus length %u > %u", tlv_length,
                   ls_length);
            goto invalid;
        }
        if (tlv_type == 0 || tlv_length ==0) {
	    nd_print_invalid(ndo);
            goto invalid;
        }
        switch(tlv_type) {
        case LS_OPAQUE_TE_TLV_LINK:
            if (ospf_te_tlv_link_print(ndo, tptr, tlv_length) == -1)
                return -1;
            break;
        case LS_OPAQUE_TE_TLV_ROUTER:
            if (tlv_length < 4) {
                ND_PRINT("\n\t    TLV length %u < 4", tlv_length);
                goto invalid;
            }
            ND_PRINT(", %s", GET_IPADDR_STRING(tptr));
            break;
        default:
            if (ndo->ndo_vflag <= 1) {
                if (!print_unknown_data(ndo, tptr, "\n\t      ", tlv_length))
                    goto invalid;
            }
            break;
        }
        if (tlv_length%4 != 0) {
            tlv_length+=4-(tlv_length%4);
            if (tlv_length > ls_length) {
                ND_PRINT("\n\t    Bogus padded length %u > %u", tlv_length,
                       ls_length);
                goto invalid;
            }
        }
        ls_length-=tlv_length;
        tptr+=tlv_length;
    }
    return 0;
trunc:
    nd_print_trunc(ndo);
    return -1;
invalid:
    nd_print_invalid(ndo);
    return -1;
}
