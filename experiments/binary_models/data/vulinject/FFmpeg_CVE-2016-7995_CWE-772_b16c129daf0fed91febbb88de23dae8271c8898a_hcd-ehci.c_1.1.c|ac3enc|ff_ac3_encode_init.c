av_cold int ff_ac3_encode_init(AVCodecContext *avctx)
{
    static AVOnce init_static_once = AV_ONCE_INIT;
    AC3EncodeContext *s = avctx->priv_data;
    int ret, frame_size_58;
    s->avctx = avctx;
    s->eac3 = avctx->codec_id == AV_CODEC_ID_EAC3;
    ret = validate_options(s);
    if (ret)
        return ret;
    avctx->frame_size = AC3_BLOCK_SIZE * s->num_blocks;
    avctx->initial_padding = AC3_BLOCK_SIZE;
    s->bitstream_mode = avctx->audio_service_type;
    if (s->bitstream_mode == AV_AUDIO_SERVICE_TYPE_KARAOKE)
        s->bitstream_mode = 0x7;
    s->bits_written    = 0;
    s->samples_written = 0;
    /* calculate crc_inv for both possible frame sizes */
    frame_size_58 = (( s->frame_size    >> 2) + ( s->frame_size    >> 4)) << 1;
    s->crc_inv[0] = pow_poly((CRC16_POLY >> 1), (8 * frame_size_58) - 16, CRC16_POLY);
    if (s->bit_alloc.sr_code == 1) {
        frame_size_58 = (((s->frame_size+2) >> 2) + ((s->frame_size+2) >> 4)) << 1;
        s->crc_inv[1] = pow_poly((CRC16_POLY >> 1), (8 * frame_size_58) - 16, CRC16_POLY);
    }
    if (CONFIG_EAC3_ENCODER && s->eac3) {
        static AVOnce init_static_once_eac3 = AV_ONCE_INIT;
        ff_thread_once(&init_static_once_eac3, ff_eac3_exponent_init);
        s->output_frame_header = ff_eac3_output_frame_header;
    } else
        s->output_frame_header = ac3_output_frame_header;
    set_bandwidth(s);
    bit_alloc_init(s);
    ret = s->mdct_init(s);
    if (ret)
        return ret;
    ret = allocate_buffers(s);
    if (ret)
        return ret;
    ff_me_cmp_init(&s->mecc, avctx);
    ff_ac3dsp_init(&s->ac3dsp);
    dprint_options(s);
    ff_thread_once(&init_static_once, exponent_init);
    return 0;
}
