  af_cjk_hints_compute_edges( AF_GlyphHints  hints,
                              AF_Dimension   dim )
  {
    AF_AxisHints  axis   = &hints->axis[dim];
    FT_Error      error  = FT_Err_Ok;
    FT_Memory     memory = hints->memory;
    AF_CJKAxis    laxis  = &((AF_CJKMetrics)hints->metrics)->axis[dim];
    AF_Segment    segments      = axis->segments;
    AF_Segment    segment_limit = FT_OFFSET( segments, axis->num_segments );
    AF_Segment    seg;
    FT_Fixed      scale;
    FT_Pos        edge_distance_threshold;
    axis->num_edges = 0;
    scale = ( dim == AF_DIMENSION_HORZ ) ? hints->x_scale
                                         : hints->y_scale;
    edge_distance_threshold = FT_MulFix( laxis->edge_distance_threshold,
                                         scale );
    if ( edge_distance_threshold > 64 / 4 )
      edge_distance_threshold = FT_DivFix( 64 / 4, scale );
    else
      edge_distance_threshold = laxis->edge_distance_threshold;
    for ( seg = segments; seg < segment_limit; seg++ )
    {
      AF_Edge  found = NULL;
      FT_Pos   best  = 0xFFFFU;
      FT_UInt  ee;
      for ( ee = 0; ee < axis->num_edges; ee++ )
      {
        AF_Edge  edge = axis->edges + ee;
        FT_Pos   dist;
        if ( edge->dir != seg->dir )
          continue;
        dist = seg->pos - edge->fpos;
        if ( dist < 0 )
          dist = -dist;
        if ( dist < edge_distance_threshold && dist < best )
        {
          AF_Segment  link = seg->link;
          if ( link )
          {
            AF_Segment  seg1  = edge->first;
            FT_Pos      dist2 = 0;
            do
            {
              AF_Segment  link1 = seg1->link;
              if ( link1 )
              {
                dist2 = AF_SEGMENT_DIST( link, link1 );
                if ( dist2 >= edge_distance_threshold )
                  break;
              }
            } while ( ( seg1 = seg1->edge_next ) != edge->first );
            if ( dist2 >= edge_distance_threshold )
              continue;
          }
          best  = dist;
          found = edge;
        }
      }
      if ( !found )
      {
        AF_Edge  edge;
        error = af_axis_hints_new_edge( axis, seg->pos,
                                        (AF_Direction)seg->dir, 0,
                                        memory, &edge );
        if ( error )
          goto Exit;
        edge->first    = seg;
        edge->last     = seg;
        edge->dir      = seg->dir;
        edge->fpos     = seg->pos;
        edge->opos     = FT_MulFix( seg->pos, scale );
        edge->pos      = edge->opos;
        seg->edge_next = seg;
      }
      else
      {
        seg->edge_next         = found->first;
        found->last->edge_next = seg;
        found->last            = seg;
      }
    }
    {
      AF_Edge  edges      = axis->edges;
      AF_Edge  edge_limit = FT_OFFSET( edges, axis->num_edges );
      AF_Edge  edge;
      for ( edge = edges; edge < edge_limit; edge++ )
      {
        seg = edge->first;
        if ( seg )
          do
          {
            seg->edge = edge;
            seg       = seg->edge_next;
          } while ( seg != edge->first );
      }
      for ( edge = edges; edge < edge_limit; edge++ )
      {
        FT_Int  is_round    = 0;  
        FT_Int  is_straight = 0;  
        seg = edge->first;
        if ( !seg )
          goto Skip_Loop;
        do
        {
          FT_Bool  is_serif;
          if ( seg->flags & AF_EDGE_ROUND )
            is_round++;
          else
            is_straight++;
          is_serif = FT_BOOL( seg->serif && seg->serif->edge != edge );
          if ( seg->link || is_serif )
          {
            AF_Edge     edge2;
            AF_Segment  seg2;
            edge2 = edge->link;
            seg2  = seg->link;
            if ( is_serif )
            {
              seg2  = seg->serif;
              edge2 = edge->serif;
            }
            if ( edge2 )
            {
              FT_Pos  edge_delta;
              FT_Pos  seg_delta;
              edge_delta = edge->fpos - edge2->fpos;
              if ( edge_delta < 0 )
                edge_delta = -edge_delta;
              seg_delta = AF_SEGMENT_DIST( seg, seg2 );
              if ( seg_delta < edge_delta )
                edge2 = seg2->edge;
            }
            else
              edge2 = seg2->edge;
            if ( is_serif )
            {
              edge->serif   = edge2;
              edge2->flags |= AF_EDGE_SERIF;
            }
            else
              edge->link = edge2;
          }
          seg = seg->edge_next;
        } while ( seg != edge->first );
      Skip_Loop:
        edge->flags = AF_EDGE_NORMAL;
        if ( is_round > 0 && is_round >= is_straight )
          edge->flags |= AF_EDGE_ROUND;
        if ( edge->serif && edge->link )
          edge->serif = NULL;
      }
    }
  Exit:
    return error;
  }
