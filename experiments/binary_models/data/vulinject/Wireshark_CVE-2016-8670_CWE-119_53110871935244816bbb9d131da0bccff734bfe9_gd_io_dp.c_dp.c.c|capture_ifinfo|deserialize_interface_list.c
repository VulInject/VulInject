deserialize_interface_list(char *data, int *err, char **err_str)
{
    int        i, j;
    char      *name, *addr;
    char      *val_s;
    double     val_d;
    bool       loopback;
    if_info_t *if_info;
    interface_type type;
    if_addr_t *if_addr;
    jsmntok_t *tokens, *if_tok, *addrs_tok, *cur_tok;
    GList     *if_list = NULL;
    if (data == NULL) {
        ws_info("Passed NULL capture interface list");
        *err = CANT_GET_INTERFACE_LIST;
        return if_list;
    }
    int num_tokens = json_parse(data, NULL, 0);
		if(num_tokens == 0) {
        ws_info("Capture Interface List failed with invalid JSON.");
        if (err_str) {
            *err_str = g_strdup("Dumpcap returned bad JSON.");
        }
        g_free(data);
        *err = CANT_GET_INTERFACE_LIST;
        return NULL;
    }
    tokens = wmem_alloc_array(NULL, jsmntok_t, num_tokens);
    if (json_parse(data, tokens, num_tokens) <= 0) {
        ws_info("Capture Interface List failed with invalid JSON.");
        if (err_str) {
            *err_str = g_strdup("Dumpcap returned bad JSON.");
        }
        wmem_free(NULL, tokens);
        g_free(data);
        *err = CANT_GET_INTERFACE_LIST;
        return NULL;
    }
    for (i = 0; i < json_get_array_len(tokens); i++) {
        if_tok = json_get_array_index(tokens, i);
        if (if_tok && if_tok->type == JSMN_OBJECT) {
            if_tok++; 
            name = g_strndup(&data[if_tok->start], if_tok->end - if_tok->start);
            if (!json_decode_string_inplace(name)) {
                g_free(name);
                continue;
            }
            if_tok++;
            if (!json_get_double(data, if_tok, "type", &val_d)) {
                g_free(name);
                continue;
            }
            type = (interface_type)val_d;
            if (!json_get_boolean(data, if_tok, "loopback", &loopback)) {
                g_free(name);
                continue;
            }
            if_info = g_new0(if_info_t,1);
            if_info->name = name;
            val_s = json_get_string(data, if_tok, "friendly_name");
            if_info->friendly_name = g_strdup(val_s);
            val_s = json_get_string(data, if_tok, "vendor_description");
            if_info->vendor_description = g_strdup(val_s);
            if_info->type = type;
            addrs_tok = json_get_array(data, if_tok, "addrs");
            for (cur_tok = addrs_tok + 1, j = 0; j < json_get_array_len(addrs_tok); cur_tok++, j++) {
                addr = g_strndup(&data[cur_tok->start], cur_tok->end - cur_tok->start);
                if (json_decode_string_inplace(addr)) {
                    if_addr = g_new0(if_addr_t, 1);
                    if (ws_inet_pton4(addr, &if_addr->addr.ip4_addr)) {
                        if_addr->ifat_type = IF_AT_IPv4;
                    } else if (ws_inet_pton6(addr, (ws_in6_addr *)&if_addr->addr.ip6_addr)) {
                        if_addr->ifat_type = IF_AT_IPv6;
                    } else {
                        g_free(if_addr);
                        if_addr = NULL;
                    }
                    if (if_addr) {
                        if_info->addrs = g_slist_append(if_info->addrs, if_addr);
                    }
                }
                g_free(addr);
            }
            if_info->loopback = loopback;
            val_s = json_get_string(data, if_tok, "extcap");
            if_info->extcap = val_s ? g_strdup(val_s) : "";
            cur_tok = json_get_object(data, if_tok, "caps");
            if (cur_tok) {
                if_info->caps = deserialize_if_capability(data, cur_tok);
            }
            if_list = g_list_append(if_list, if_info);
        }
    }
    wmem_free(NULL, tokens);
    g_free(data);
    return if_list;
}
