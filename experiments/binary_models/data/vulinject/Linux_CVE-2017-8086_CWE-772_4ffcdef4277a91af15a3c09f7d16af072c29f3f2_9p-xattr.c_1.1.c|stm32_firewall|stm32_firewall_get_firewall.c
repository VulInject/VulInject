int stm32_firewall_get_firewall(struct device_node *np, struct stm32_firewall *firewall,
				unsigned int nb_firewall)
{
	struct stm32_firewall_controller *ctrl;
	struct of_phandle_iterator it;
	unsigned int i, j = 0;
	int err;
	if (!firewall || !nb_firewall)
		return -EINVAL;
	of_for_each_phandle(&it, err, np, "access-controllers", "#access-controller-cells", 0) {
		struct of_phandle_args provider_args;
		struct device_node *provider = it.node;
		const char *fw_entry;
		bool match = false;
		if (err) {
			pr_err("Unable to get access-controllers property for node %s\n, err: %d",
			       np->full_name, err);
			return err;
		}
		if (j >= nb_firewall) {
			pr_err("Too many firewall controllers");
			of_node_put(provider);
			return -EINVAL;
		}
		provider_args.args_count = of_phandle_iterator_args(&it, provider_args.args,
								    STM32_FIREWALL_MAX_ARGS);
		mutex_lock(&firewall_controller_list_lock);
		list_for_each_entry(ctrl, &firewall_controller_list, entry) {
			if (ctrl->dev->of_node->phandle == it.phandle) {
				match = true;
				firewall[j].firewall_ctrl = ctrl;
				break;
			}
		}
		mutex_unlock(&firewall_controller_list_lock);
		if (!match) {
			firewall[j].firewall_ctrl = NULL;
			pr_err("No firewall controller registered for %s\n", np->full_name);
			of_node_put(provider);
			return -ENODEV;
		}
		err = of_property_read_string_index(np, "access-controller-names", j, &fw_entry);
		if (err == 0)
			firewall[j].entry = fw_entry;
		if (provider_args.args_count < 0 ||
		    provider_args.args_count > STM32_FIREWALL_MAX_ARGS) {
			of_node_put(provider);
			return -EINVAL;
		} else if (provider_args.args_count == 0) {
			firewall[j].extra_args_size = 0;
			firewall[j].firewall_id = U32_MAX;
			j++;
			continue;
		}
		firewall[j].firewall_id = provider_args.args[0];
		for (i = 0; i < provider_args.args_count - 1; i++)
			firewall[j].extra_args[i] = provider_args.args[i + 1];
		firewall[j].extra_args_size = provider_args.args_count - 1;
		j++;
	}
	return 0;
}
