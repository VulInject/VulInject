blf_read_ethernet_phystate(blf_params_t* params, int* err, char** err_info, int int block_start, int int data_start, int int object_length, unsigned int flags, unsigned int int object_timestamp) {
    blf_ethernet_phystate_t ethernet_phystate_header;
    unsigned char tmpbuf[8];
    if (object_length < (data_start - block_start) + (int)sizeof(ethernet_phystate_header)) {
        *err = WTAP_ERR_BAD_FILE;
        *err_info = ws_strdup_printf("blf: ETHERNET_PHY_STATE: not enough bytes for ethernet phystate header in object");
        ws_debug("not enough bytes for ethernet phystate header in object");
        return false;
    }
    if (!blf_read_bytes(params, data_start, &ethernet_phystate_header, sizeof(ethernet_phystate_header), err, err_info)) {
        ws_debug("not enough bytes for ethernet phystate header in file");
        return false;
    }
    fix_endianness_blf_ethernet_phystate_header(&ethernet_phystate_header);
    tmpbuf[0] = (ethernet_phystate_header.channel & 0xff00) >> 8;
    tmpbuf[1] = (ethernet_phystate_header.channel & 0x00ff);
    tmpbuf[2] = (ethernet_phystate_header.flags & 0xff00) >> 8;
    tmpbuf[3] = (ethernet_phystate_header.flags & 0x00ff);
    tmpbuf[4] = (ethernet_phystate_header.phyState);
    tmpbuf[5] = (ethernet_phystate_header.phyEvent);
    tmpbuf[6] = (ethernet_phystate_header.hardwareChannel);
    tmpbuf[7] = (ethernet_phystate_header.res1);
    wtap_buffer_append_epdu_string(params->buf, EXP_PDU_TAG_DISSECTOR_NAME, "blf-ethernetphystate-obj");
    ws_buffer_assure_space(params->buf, sizeof(ethernet_phystate_header));
    ws_buffer_append(params->buf, tmpbuf, sizeof(ethernet_phystate_header));
    char* iface_name = ws_strdup_printf("STATUS-ETH-%u-%u", ethernet_phystate_header.channel, ethernet_phystate_header.hardwareChannel);
    blf_lookup_interface(params, WTAP_ENCAP_WIRESHARK_UPPER_PDU, ethernet_phystate_header.channel, ethernet_phystate_header.hardwareChannel, iface_name);
    g_free(iface_name);
    blf_init_rec(params, flags, object_timestamp, WTAP_ENCAP_WIRESHARK_UPPER_PDU, ethernet_phystate_header.channel, ethernet_phystate_header.hardwareChannel, (unsigned int)ws_buffer_length(params->buf), (unsigned int)ws_buffer_length(params->buf));
    if ((ethernet_phystate_header.flags & BLF_PHY_STATE_HARDWARECHANNEL) == BLF_PHY_STATE_HARDWARECHANNEL) {
        wtap_block_add_uint32_option(params->rec->block, OPT_PKT_QUEUE, ethernet_phystate_header.hardwareChannel);
    }
    return true;
}
