static int nvdec_retrieve_data(void *logctx, AVFrame *frame)
{
    FrameDecodeData  *fdd = (FrameDecodeData*)frame->private_ref->data;
    NVDECFrame        *cf = (NVDECFrame*)fdd->hwaccel_priv;
    NVDECDecoder *decoder = cf->decoder;
    AVHWFramesContext *hwctx = (AVHWFramesContext *)frame->hw_frames_ctx->data;
    CUVIDPROCPARAMS vpp = { 0 };
    NVDECFrame *unmap_data = NULL;
    CUcontext dummy;
    CUdeviceptr devptr;
	int pitch, i;
    unsigned int offset = 0;
    int shift_h = 0, shift_v = 0;
    int ret = 0;
    vpp.progressive_frame = 1;
    vpp.output_stream = decoder->stream;
    ret = CHECK_CU(decoder->cudl->cuCtxPushCurrent(decoder->cuda_ctx));
    if (ret < 0)
        return ret;
    ret = CHECK_CU(decoder->cvdl->cuvidMapVideoFrame(decoder->decoder,
                                                     cf->idx, &devptr,
                                                     &pitch, &vpp));
    if (ret < 0)
        goto finish;
    unmap_data = av_mallocz(sizeof(*unmap_data));
    if (!unmap_data) {
        ret = AVERROR(ENOMEM);
        goto copy_fail;
    }
    frame->buf[1] = av_buffer_create((uint8_t *)unmap_data, sizeof(*unmap_data),
                                     nvdec_unmap_mapped_frame, (void*)devptr,
                                     AV_BUFFER_FLAG_READONLY);
    if (!frame->buf[1]) {
        ret = AVERROR(ENOMEM);
        goto copy_fail;
    }
    ret = av_buffer_replace(&frame->hw_frames_ctx, decoder->real_hw_frames_ref);
    if (ret < 0)
        goto copy_fail;
    unmap_data->idx = cf->idx;
    unmap_data->idx_ref = ff_refstruct_ref(cf->idx_ref);
    unmap_data->decoder = ff_refstruct_ref(cf->decoder);
    av_pix_fmt_get_chroma_sub_sample(hwctx->sw_format, &shift_h, &shift_v);
    for (i = 0; frame->linesize[i]; i++) {
        frame->data[i] = (uint8_t*)(devptr + offset);
        frame->linesize[i] = pitch;
        offset += pitch * (frame->height >> (i ? shift_v : 0));
    }
    goto finish;
copy_fail:
    if (!frame->buf[1]) {
        CHECK_CU(decoder->cvdl->cuvidUnmapVideoFrame(decoder->decoder, devptr));
        av_freep(&unmap_data);
    } else {
        av_buffer_unref(&frame->buf[1]);
    }
finish:
    CHECK_CU(decoder->cudl->cuCtxPopCurrent(&dummy));
    if (ret < 0 || decoder->unsafe_output)
        return ret;
    return av_frame_make_writable(frame);
}
