static int amd8111e_probe_one(struct pci_dev *pdev,
				  const struct pci_device_id *ent)
{
	int err, i;
	unsigned int reg_addr, reg_len;
	struct amd8111e_priv *lp;
	struct net_device *dev;
	unsigned char addr[ETH_ALEN];
	err = pci_enable_device(pdev);
	if (err) {
		dev_err(&pdev->dev, "Cannot enable new PCI device\n");
		return err;
	}
	if (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {
		dev_err(&pdev->dev, "Cannot find PCI base address\n");
		err = -ENODEV;
		goto err_disable_pdev;
	}
	err = pci_request_regions(pdev, MODULE_NAME);
	if (err) {
		dev_err(&pdev->dev, "Cannot obtain PCI resources\n");
		goto err_disable_pdev;
	}
	pci_set_master(pdev);
	if (!pdev->pm_cap) {
		dev_err(&pdev->dev, "No Power Management capability\n");
		err = -ENODEV;
		goto err_free_reg;
	}
	if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32)) < 0) {
		dev_err(&pdev->dev, "DMA not supported\n");
		err = -ENODEV;
		goto err_free_reg;
	}
	reg_addr = pci_resource_start(pdev, 0);
	reg_len = pci_resource_len(pdev, 0);
	dev = alloc_etherdev(sizeof(struct amd8111e_priv));
	if (!dev) {
		err = -ENOMEM;
		goto err_free_reg;
	}
	SET_NETDEV_DEV(dev, &pdev->dev);
#if AMD8111E_VLAN_TAG_USED
	dev->features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX;
#endif
	lp = netdev_priv(dev);
	lp->pci_dev = pdev;
	lp->amd8111e_net_dev = dev;
	spin_lock_init(&lp->lock);
	lp->mmio = devm_ioremap(&pdev->dev, reg_addr, reg_len);
	if (!lp->mmio) {
		dev_err(&pdev->dev, "Cannot map device registers\n");
		err = -ENOMEM;
		goto err_free_dev;
	}
	for (i = 0; i < ETH_ALEN; i++)
		addr[i] = readb(lp->mmio + PADR + i);
	eth_hw_addr_set(dev, addr);
	lp->ext_phy_option = speed_duplex[card_idx];
	if (coalesce[card_idx])
		lp->options |= OPTION_INTR_COAL_ENABLE;
	if (dynamic_ipg[card_idx++])
		lp->options |= OPTION_DYN_IPG_ENABLE;
	dev->netdev_ops = &amd8111e_netdev_ops;
	dev->ethtool_ops = &ops;
	dev->irq = pdev->irq;
	dev->watchdog_timeo = AMD8111E_TX_TIMEOUT;
	dev->min_mtu = AMD8111E_MIN_MTU;
	dev->max_mtu = AMD8111E_MAX_MTU;
	netif_napi_add_weight(dev, &lp->napi, amd8111e_rx_poll, 32);
	amd8111e_probe_ext_phy(dev);
	lp->mii_if.dev = dev;
	lp->mii_if.mdio_read = amd8111e_mdio_read;
	lp->mii_if.mdio_write = amd8111e_mdio_write;
	lp->mii_if.phy_id = lp->ext_phy_addr;
	amd8111e_set_rx_buff_len(dev);
	err = register_netdev(dev);
	if (err) {
		dev_err(&pdev->dev, "Cannot register net device\n");
		goto err_free_dev;
	}
	pci_set_drvdata(pdev, dev);
	if (lp->options & OPTION_DYN_IPG_ENABLE) {
		timer_setup(&lp->ipg_data.ipg_timer, amd8111e_config_ipg, 0);
		lp->ipg_data.ipg_timer.expires = jiffies +
						 IPG_CONVERGE_JIFFIES;
		lp->ipg_data.ipg = DEFAULT_IPG;
		lp->ipg_data.ipg_state = CSTATE;
	}
	chip_version = (readl(lp->mmio + CHIPID) & 0xf0000000) >> 28;
	dev_info(&pdev->dev, "[ Rev %x ] PCI 10/100BaseT Ethernet %pM\n",
		 chip_version, dev->dev_addr);
	if (lp->ext_phy_id)
		dev_info(&pdev->dev, "Found MII PHY ID 0x%08x at address 0x%02x\n",
			 lp->ext_phy_id, lp->ext_phy_addr);
	else
		dev_info(&pdev->dev, "Couldn't detect MII PHY, assuming address 0x01\n");
	return 0;
err_free_dev:
	free_netdev(dev);
err_free_reg:
	pci_release_regions(pdev);
err_disable_pdev:
	pci_disable_device(pdev);
	return err;
}
