static int npcm_i2c_recovery_tgclk(struct i2c_adapter *_adap)
{
	unsigned char               val;
	unsigned char               fif_cts;
	bool             done = false;
	int              status = -ENOTRECOVERABLE;
	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
	int              iter = 27;
	if ((npcm_i2c_get_SDA(_adap) == 1) && (npcm_i2c_get_SCL(_adap) == 1)) {
		dev_dbg(bus->dev, "bus%d-0x%x recovery skipped, bus not stuck",
			bus->num, bus->dest_addr);
		return 0;
	}
	npcm_i2c_int_enable(bus, false);
	npcm_i2c_disable(bus);
	npcm_i2c_enable(bus);
	iowrite8(NPCM_I2CCST_BB, bus->reg + NPCM_I2CCST);
	npcm_i2c_clear_tx_fifo(bus);
	npcm_i2c_clear_rx_fifo(bus);
	iowrite8(0, bus->reg + NPCM_I2CRXF_CTL);
	iowrite8(0, bus->reg + NPCM_I2CTXF_CTL);
	npcm_i2c_stall_after_start(bus, false);
	npcm_i2c_select_bank(bus, I2C_BANK_1);
	fif_cts = ioread8(bus->reg + NPCM_I2CFIF_CTS);
	fif_cts &= ~NPCM_I2CFIF_CTS_SLVRSTR;
	fif_cts |= NPCM_I2CFIF_CTS_CLR_FIFO;
	iowrite8(fif_cts, bus->reg + NPCM_I2CFIF_CTS);
	npcm_i2c_set_fifo(bus, -1, 0);
	do {
		iowrite8(NPCM_I2CCST_TGSCL, bus->reg + NPCM_I2CCST);
		usleep_range(20, 30);
		if (npcm_i2c_get_SDA(_adap)) {
			done = true;
			status = 0;
		}
	} while (!done && iter--);
	if (npcm_i2c_get_SDA(_adap)) {
		npcm_i2c_wr_byte(bus, bus->dest_addr);
		npcm_i2c_master_start(bus);
		status = readx_poll_timeout(npcm_i2c_get_SCL, _adap, val, !val,
					    20, 200);
		if (npcm_i2c_is_master(bus) > 0) {
			usleep_range(20, 30);
			npcm_i2c_master_stop(bus);
			usleep_range(200, 500);
		}
	}
	npcm_i2c_reset(bus);
	npcm_i2c_int_enable(bus, true);
	if ((npcm_i2c_get_SDA(_adap) == 1) && (npcm_i2c_get_SCL(_adap) == 1))
		status = 0;
	else
		status = -ENOTRECOVERABLE;
	if (status) {
		if (bus->rec_fail_cnt < ULLONG_MAX)
			bus->rec_fail_cnt++;
	} else {
		if (bus->rec_succ_cnt < ULLONG_MAX)
			bus->rec_succ_cnt++;
	}
	return status;
}
