emap_try_acquire_edata_neighbor_impl(tsdn_t *tsdn, emap_t *emap, edata_t *edata,
    extent_pai_t pai, extent_state_t expected_state, bool forward,
    bool expanding) {
	witness_assert_positive_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
	    WITNESS_RANK_CORE);
	assert(!edata_guarded_get(edata));
	assert(!expanding || forward);
	assert(!edata_state_in_transition(expected_state));
	assert(expected_state == extent_state_dirty ||
	       expected_state == extent_state_muzzy ||
	       expected_state == extent_state_retained);
	void *neighbor_addr = forward ? edata_past_get(edata) :
	    edata_before_get(edata);
	/*
	 * This is subtle; the rtree code asserts that its input pointer is
	 * non-NULL, and this is a useful thing to check.  But it's possible
	 * that edata corresponds to an address of (void *)PAGE (in practice,
	 * this has only been observed on FreeBSD when address-space
	 * randomization is on, but it could in principle happen anywhere).  In
	 * this case, edata_before_get(edata) is NULL, triggering the assert.
	 */
	if (neighbor_addr == NULL) {
		return NULL;
	}
	EMAP_DECLARE_RTREE_CTX;
	rtree_leaf_elm_t *elm = rtree_leaf_elm_lookup(tsdn, &emap->rtree,
	    rtree_ctx, (uintptr_t)neighbor_addr, /* dependent*/ false,
	    /* init_missing */ false);
	if (elm == NULL) {
		return NULL;
	}
	rtree_contents_t neighbor_contents = rtree_leaf_elm_read(tsdn,
	    &emap->rtree, elm, /* dependent */ true);
	if (!extent_can_acquire_neighbor(edata, neighbor_contents, pai,
	    expected_state, forward, expanding)) {
		return NULL;
	}
	/* From this point, the neighbor edata can be safely acquired. */
	edata_t *neighbor = neighbor_contents.edata;
	assert(edata_state_get(neighbor) == expected_state);
	emap_update_edata_state(tsdn, emap, neighbor, extent_state_merging);
	if (expanding) {
	} else {
		extent_assert_can_coalesce(edata, neighbor);
	}
	return neighbor;
}
