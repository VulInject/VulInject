geneve_print(netdissect_options *ndo, const u_char *bp, u_int len)
{
    unsigned char ver_opt;
    u_int version;
    unsigned char flags;
    unsigned short prot;
    unsigned int vni;
    unsigned char reserved;
    u_int opts_len;
    ndo->ndo_protocol = "geneve";
    ND_PRINT("Geneve");
    ND_ICHECK_U(len, <, 8);
    ver_opt = GET_U_1(bp);
    bp += 1;
    len -= 1;
    version = ver_opt >> VER_SHIFT;
    if (version != 0) {
        ND_PRINT(" ERROR: unknown-version %u", version);
        goto invalid;
    }
    flags = GET_U_1(bp);
    bp += 1;
    len -= 1;
    prot = GET_BE_U_2(bp);
    bp += 2;
    len -= 2;
    vni = GET_BE_U_3(bp);
    bp += 3;
    len -= 3;
    reserved = GET_U_1(bp);
    bp += 1;
    len -= 1;
    ND_PRINT(", Flags [%s]",
              bittok2str_nosep(geneve_flag_values, "none", flags));
    ND_PRINT(", vni 0x%x", vni);
    if (reserved)
        ND_PRINT(", rsvd 0x%x", reserved);
    if (ndo->ndo_eflag)
        ND_PRINT(", proto %s (0x%04x)",
                  tok2str(ethertype_values, "unknown", prot), prot);
    opts_len = (ver_opt & HDR_OPTS_LEN_MASK) * 4;
    if (len < opts_len) {
        ND_PRINT(" (opts_len %u > %u", opts_len, len);
        goto invalid;
    }
    if (opts_len > 0) {
        ND_PRINT(", options [");
        if (ndo->ndo_vflag) {
            if (! geneve_opts_print(ndo, bp, opts_len))
                goto invalid;
        } else {
            ND_PRINT("%u bytes", opts_len);
        }
        ND_PRINT("]");
    }
    bp += opts_len;
    len -= opts_len;
    if (ndo->ndo_vflag < 1)
        ND_PRINT(": ");
    else
        ND_PRINT("\n\t");
    if (ethertype_print(ndo, prot, bp, len, ND_BYTES_AVAILABLE_AFTER(bp), NULL, NULL) == 0) {
        if (prot == ETHERTYPE_TEB)
            ether_print(ndo, bp, len, ND_BYTES_AVAILABLE_AFTER(bp), NULL, NULL);
        else {
            ND_PRINT("geneve-proto-0x%x", prot);
            ND_TCHECK_LEN(bp, len);
        }
    }
    return;
invalid:
    nd_print_invalid(ndo);
}
