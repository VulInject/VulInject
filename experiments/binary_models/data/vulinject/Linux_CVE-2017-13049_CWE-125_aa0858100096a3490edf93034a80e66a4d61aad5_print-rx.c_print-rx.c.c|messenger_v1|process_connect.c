static int process_connect(struct ceph_connection *con)
{
	unsigned int int sup_feat = from_msgr(con->msgr)->supported_features;
	unsigned int int req_feat = from_msgr(con->msgr)->required_features;
	unsigned int int server_feat = le64_to_cpu(con->v1.in_reply.features);
	int ret;
	dout("process_connect on %p tag %d\n", con, con->v1.in_tag);
	if (con->v1.auth) {
		int len = le32_to_cpu(con->v1.in_reply.authorizer_len);
		if (con->v1.in_reply.tag ==
				CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER) {
			ret = con->ops->add_authorizer_challenge(
				con, con->v1.auth->authorizer_reply_buf, len);
			if (ret < 0)
				return ret;
			__prepare_write_connect(con);
			prepare_read_connect(con);
			return 0;
		}
		if (len) {
			ret = con->ops->verify_authorizer_reply(con);
			if (ret < 0) {
				con->error_msg = "bad authorize reply";
				return ret;
			}
		}
	}
	switch (con->v1.in_reply.tag) {
	case CEPH_MSGR_TAG_FEATURES:
		pr_err("%s%lld %s feature set mismatch,"
		       " my %llx < server's %llx, missing %llx\n",
		       ENTITY_NAME(con->peer_name),
		       ceph_pr_addr(&con->peer_addr),
		       sup_feat, server_feat, server_feat & ~sup_feat);
		con->error_msg = "missing required protocol features";
		return -1;
	case CEPH_MSGR_TAG_BADPROTOVER:
		pr_err("%s%lld %s protocol version mismatch,"
		       " my %d != server's %d\n",
		       ENTITY_NAME(con->peer_name),
		       ceph_pr_addr(&con->peer_addr),
		       le32_to_cpu(con->v1.out_connect.protocol_version),
		       le32_to_cpu(con->v1.in_reply.protocol_version));
		con->error_msg = "protocol version mismatch";
		return -1;
	case CEPH_MSGR_TAG_BADAUTHORIZER:
		con->v1.auth_retry++;
		dout("process_connect %p got BADAUTHORIZER attempt %d\n", con,
		     con->v1.auth_retry);
		if (con->v1.auth_retry == 2) {
			con->error_msg = "connect authorization failure";
			return -1;
		}
		con_out_kvec_reset(con);
		ret = prepare_write_connect(con);
		if (ret < 0)
			return ret;
		prepare_read_connect(con);
		break;
	case CEPH_MSGR_TAG_RESETSESSION:
		dout("process_connect got RESET peer seq %u\n",
		     le32_to_cpu(con->v1.in_reply.connect_seq));
		pr_info("%s%lld %s session reset\n",
			ENTITY_NAME(con->peer_name),
			ceph_pr_addr(&con->peer_addr));
		ceph_con_reset_session(con);
		con_out_kvec_reset(con);
		ret = prepare_write_connect(con);
		if (ret < 0)
			return ret;
		prepare_read_connect(con);
		mutex_unlock(&con->mutex);
		if (con->ops->peer_reset)
			con->ops->peer_reset(con);
		mutex_lock(&con->mutex);
		if (con->state != CEPH_CON_S_V1_CONNECT_MSG)
			return -EAGAIN;
		break;
	case CEPH_MSGR_TAG_RETRY_SESSION:
		dout("process_connect got RETRY_SESSION my seq %u, peer %u\n",
		     le32_to_cpu(con->v1.out_connect.connect_seq),
		     le32_to_cpu(con->v1.in_reply.connect_seq));
		con->v1.connect_seq = le32_to_cpu(con->v1.in_reply.connect_seq);
		con_out_kvec_reset(con);
		ret = prepare_write_connect(con);
		if (ret < 0)
			return ret;
		prepare_read_connect(con);
		break;
	case CEPH_MSGR_TAG_RETRY_GLOBAL:
		dout("process_connect got RETRY_GLOBAL my %u peer_gseq %u\n",
		     con->v1.peer_global_seq,
		     le32_to_cpu(con->v1.in_reply.global_seq));
		ceph_get_global_seq(con->msgr,
				    le32_to_cpu(con->v1.in_reply.global_seq));
		con_out_kvec_reset(con);
		ret = prepare_write_connect(con);
		if (ret < 0)
			return ret;
		prepare_read_connect(con);
		break;
	case CEPH_MSGR_TAG_SEQ:
	case CEPH_MSGR_TAG_READY:
		if (req_feat & ~server_feat) {
			pr_err("%s%lld %s protocol feature mismatch,"
			       " my required %llx > server's %llx, need %llx\n",
			       ENTITY_NAME(con->peer_name),
			       ceph_pr_addr(&con->peer_addr),
			       req_feat, server_feat, req_feat & ~server_feat);
			con->error_msg = "missing required protocol features";
			return -1;
		}
		WARN_ON(con->state != CEPH_CON_S_V1_CONNECT_MSG);
		con->state = CEPH_CON_S_OPEN;
		con->v1.auth_retry = 0;    
		con->v1.peer_global_seq =
			le32_to_cpu(con->v1.in_reply.global_seq);
		con->v1.connect_seq++;
		con->peer_features = server_feat;
		dout("process_connect got READY gseq %d cseq %d (%d)\n",
		     con->v1.peer_global_seq,
		     le32_to_cpu(con->v1.in_reply.connect_seq),
		     con->v1.connect_seq);
		WARN_ON(con->v1.connect_seq !=
			le32_to_cpu(con->v1.in_reply.connect_seq));
		if (con->v1.in_reply.flags & CEPH_MSG_CONNECT_LOSSY)
			ceph_con_flag_set(con, CEPH_CON_F_LOSSYTX);
		con->delay = 0;      
		if (con->v1.in_reply.tag == CEPH_MSGR_TAG_SEQ) {
			prepare_write_seq(con);
			prepare_read_seq(con);
		} else {
			prepare_read_tag(con);
		}
		break;
	case CEPH_MSGR_TAG_WAIT:
		con->error_msg = "protocol error, got WAIT as client";
		return -1;
	default:
		con->error_msg = "protocol error, garbage tag during connect";
		return -1;
	}
	return 0;
}
