static int encode_packet(Jpeg2000EncoderContext *s, Jpeg2000ResLevel *rlevel, int layno,
                         int precno, uint8_t *expn, int numgbits, int packetno,
                         int nlayers)
{
    int bandno, empty = 1;
    int i;
    // init bitstream
    *s->buf = 0;
    s->bit_index = 0;
    if (s->sop) {
        bytestream_put_be16(&s->buf, JPEG2000_SOP);
        bytestream_put_be16(&s->buf, 4);
        bytestream_put_be16(&s->buf, packetno);
    }
    // header
    if (!layno) {
        for (bandno = 0; bandno < rlevel->nbands; bandno++) {
            Jpeg2000Band *band = rlevel->band + bandno;
            if (band->coord[0][0] < band->coord[0][1]
            &&  band->coord[1][0] < band->coord[1][1]) {
                Jpeg2000Prec *prec = band->prec + precno;
                int nb_cblks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;
                int pos;
                ff_tag_tree_zero(prec->zerobits, prec->nb_codeblocks_width, prec->nb_codeblocks_height, 99);
                ff_tag_tree_zero(prec->cblkincl, prec->nb_codeblocks_width, prec->nb_codeblocks_height, 99);
                for (pos = 0; pos < nb_cblks; pos++) {
                    Jpeg2000Cblk *cblk = &prec->cblk[pos];
                    prec->zerobits[pos].val = expn[bandno] + numgbits - 1 - cblk->nonzerobits;
                    cblk->incl = 0;
                    cblk->lblock = 3;
                    tag_tree_update(prec->zerobits + pos);
                    for (i = 0; i < nlayers; i++) {
                        if (cblk->layers[i].npasses > 0) {
                            prec->cblkincl[pos].val = i;
                            break;
                        }
                    }
                    if (i == nlayers)
                        prec->cblkincl[pos].val = i;
                    tag_tree_update(prec->cblkincl + pos);
                }
            }
        }
    }
    // is the packet empty?
    for (bandno = 0; bandno < rlevel->nbands; bandno++){
        Jpeg2000Band *band = rlevel->band + bandno;
        if (band->coord[0][0] < band->coord[0][1]
        &&  band->coord[1][0] < band->coord[1][1]) {
            Jpeg2000Prec *prec = band->prec + precno;
            int nb_cblks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;
            int pos;
            for (pos = 0; pos < nb_cblks; pos++) {
                Jpeg2000Cblk *cblk = &prec->cblk[pos];
                if (cblk->layers[layno].npasses) {
                    empty = 0;
                    break;
                }
            }
            if (!empty)
                break;
        }
    }
    put_bits(s, !empty, 1);
    if (empty){
        if (s->eph)
            bytestream_put_be16(&s->buf, JPEG2000_EPH);
        return 0;
    }
    for (bandno = 0; bandno < rlevel->nbands; bandno++) {
        Jpeg2000Band *band = rlevel->band + bandno;
        Jpeg2000Prec *prec = band->prec + precno;
        int yi, xi, pos;
        int cblknw = prec->nb_codeblocks_width;
        if (band->coord[0][0] == band->coord[0][1]
        ||  band->coord[1][0] == band->coord[1][1])
            continue;
        for (pos=0, yi = 0; yi < prec->nb_codeblocks_height; yi++) {
            for (xi = 0; xi < cblknw; xi++, pos++){
                int llen = 0, length;
                Jpeg2000Cblk *cblk = prec->cblk + yi * cblknw + xi;
                if (s->buf_end - s->buf < 20) // approximately
                    return -1;
                // inclusion information
                if (!cblk->incl)
                    tag_tree_code(s, prec->cblkincl + pos, layno + 1);
                else {
                    put_bits(s, cblk->layers[layno].npasses > 0, 1);
                }
                if (!cblk->layers[layno].npasses)
                    continue;
                // zerobits information
                if (!cblk->incl) {
                    tag_tree_code(s, prec->zerobits + pos, 100);
                    cblk->incl = 1;
                }
                // number of passes
                putnumpasses(s, cblk->layers[layno].npasses);
                length = cblk->layers[layno].data_len;
                if (layno == nlayers - 1 && cblk->layers[layno].cum_passes){
                    length += cblk->passes[cblk->layers[layno].cum_passes-1].flushed_len;
                }
                if (cblk->lblock + av_log2(cblk->layers[layno].npasses) < av_log2(length) + 1) {
                    llen = av_log2(length) + 1 - cblk->lblock - av_log2(cblk->layers[layno].npasses);
                }
                // length of code block
                cblk->lblock += llen;
                put_bits(s, 1, llen);
                put_bits(s, 0, 1);
                put_num(s, length, cblk->lblock + av_log2(cblk->layers[layno].npasses));
            }
        }
    }
    j2k_flush(s);
    if (s->eph) {
        bytestream_put_be16(&s->buf, JPEG2000_EPH);
    }
    for (bandno = 0; bandno < rlevel->nbands; bandno++) {
        Jpeg2000Band *band = rlevel->band + bandno;
        Jpeg2000Prec *prec = band->prec + precno;
        int yi, cblknw = prec->nb_codeblocks_width;
        for (yi =0; yi < prec->nb_codeblocks_height; yi++) {
            int xi;
            for (xi = 0; xi < cblknw; xi++){
                Jpeg2000Cblk *cblk = prec->cblk + yi * cblknw + xi;
                if (cblk->layers[layno].npasses) {
                    if (s->buf_end - s->buf < cblk->layers[layno].data_len + 2)
                        return -1;
                    bytestream_put_buffer(&s->buf, cblk->layers[layno].data_start + 1, cblk->layers[layno].data_len);
                    if (layno == nlayers - 1 && cblk->layers[layno].cum_passes) {
                        bytestream_put_buffer(&s->buf, cblk->passes[cblk->layers[layno].cum_passes-1].flushed,
                                                       cblk->passes[cblk->layers[layno].cum_passes-1].flushed_len);
                    }
                }
            }
        }
    }
    return 0;
}
