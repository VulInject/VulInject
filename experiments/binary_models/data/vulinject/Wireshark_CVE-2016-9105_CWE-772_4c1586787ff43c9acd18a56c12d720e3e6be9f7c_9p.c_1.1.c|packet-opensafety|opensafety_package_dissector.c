opensafety_package_dissector(const gchar *protocolName, const gchar *sub_diss_handle,
                             gboolean b_frame2First, gboolean do_byte_swap, guint8 force_nr_in_package,
                             tvbuff_t *given_tvb, packet_info *pinfo, proto_tree *tree, guint8 transporttype )
{
    tvbuff_t           *next_tvb = NULL, *gap_tvb = NULL, *message_tvb = NULL;
    guint               length, len, frameOffset, frameLength, nodeAddress, gapStart;
    guint8             *swbytes;
    gboolean            handled, dissectorCalled, call_sub_dissector, markAsMalformed;
    guint8              type, found, i, tempByte, previous_msg_id;
    guint16             frameStart1, frameStart2, byte_offset;
    gint                reported_len;
    dissector_handle_t  protocol_dissector = NULL;
    proto_item         *opensafety_item;
    proto_tree         *opensafety_tree;
    opensafety_packet_info *packet = NULL;
    handled            = FALSE;
    dissectorCalled    = FALSE;
    call_sub_dissector = FALSE;
    markAsMalformed    = FALSE;
    previous_msg_id    = 0;
    length = tvb_reported_length(given_tvb);
    if ( length < OSS_MINIMUM_LENGTH )
        return FALSE;
    if ( strlen( sub_diss_handle ) > 0 )
    {
        call_sub_dissector = TRUE;
        protocol_dissector = find_dissector ( sub_diss_handle );
        if ( protocol_dissector == NULL )
            protocol_dissector = data_dissector;
    }
    reported_len = tvb_reported_length_remaining(given_tvb, 0);
    if ( do_byte_swap == TRUE && global_mbtcp_big_endian == TRUE )
    {
        if ( ! tvb_bytes_exist ( given_tvb, 0, length ) )
            return FALSE;
        swbytes = (guint8 *) tvb_memdup( pinfo->pool, given_tvb, 0, length);
        len = (length / 2);
        for ( i = 0; i < len; i++ )
        {
            tempByte = swbytes [ 2 * i ]; swbytes [ 2 * i ] = swbytes [ 2 * i + 1 ]; swbytes [ 2 * i + 1 ] = tempByte;
        }
        message_tvb = tvb_new_real_data(swbytes, length, reported_len);
    } else {
        message_tvb = given_tvb;
    }
    frameOffset = 0;
    frameLength = 0;
    found = 0;
    gapStart = 0;
    while ( frameOffset < length )
    {
        next_tvb = NULL;
        if ( tvb_captured_length_remaining(message_tvb, frameOffset ) < ( OSS_MINIMUM_LENGTH - 1 ) )
            break;
        packet = wmem_new0(pinfo->pool, opensafety_packet_info);
        if ( findSafetyFrame(pinfo, message_tvb, frameOffset, b_frame2First, &frameOffset, &frameLength, packet) )
        {
            if ( packet->msg_id == 0 || ( frameOffset + frameLength ) > (guint)reported_len )
                break;
            found++;
            byte_offset = ( b_frame2First ? 0 : frameOffset );
            if ( b_frame2First )
            {
                frameStart1 = findFrame1Position (pinfo, message_tvb, byte_offset, frameLength, FALSE );
                frameStart2 = 0;
            }
            else
            {
                frameStart1 = 0;
                frameStart2 = ((OSS_FRAME_LENGTH_T(message_tvb, byte_offset + frameStart1) - 1) +
                        (OSS_FRAME_LENGTH_T(message_tvb, byte_offset + frameStart1) > OSS_PAYLOAD_MAXSIZE_FOR_CRC8 ? OSS_SLIM_FRAME2_WITH_CRC16 : OSS_SLIM_FRAME2_WITH_CRC8));
            }
            if (frameStart1 == frameStart2)
            {
                found--;
                frameOffset += frameLength;
                continue;
            }
            packet->msg_id = OSS_FRAME_ID_T(message_tvb, byte_offset + frameStart1);
            if ( ( packet->msg_id & OPENSAFETY_SLIM_SSDO_MESSAGE_TYPE ) == OPENSAFETY_SLIM_SSDO_MESSAGE_TYPE )
                type = OPENSAFETY_SLIM_SSDO_MESSAGE_TYPE;
            else if ( ( packet->msg_id & OPENSAFETY_SSDO_MESSAGE_TYPE ) == OPENSAFETY_SSDO_MESSAGE_TYPE )
                type = OPENSAFETY_SSDO_MESSAGE_TYPE;
            else if ( ( packet->msg_id & OPENSAFETY_SPDO_MESSAGE_TYPE ) == OPENSAFETY_SPDO_MESSAGE_TYPE )
                type = OPENSAFETY_SPDO_MESSAGE_TYPE;
            else if ( ( packet->msg_id & OPENSAFETY_SNMT_MESSAGE_TYPE ) == OPENSAFETY_SNMT_MESSAGE_TYPE )
                type = OPENSAFETY_SNMT_MESSAGE_TYPE;
            else
            {
                if ( b_frame2First )
                {
                    frameStart1 = findFrame1Position(pinfo, message_tvb, ( b_frame2First ? 0 : frameOffset ), frameLength, TRUE );
                    frameStart2 = 0;
                    packet->msg_id = OSS_FRAME_ID_T(message_tvb, byte_offset + frameStart1);
                    if ( ( packet->msg_id & OPENSAFETY_SLIM_SSDO_MESSAGE_TYPE ) == OPENSAFETY_SLIM_SSDO_MESSAGE_TYPE )
                        type = OPENSAFETY_SLIM_SSDO_MESSAGE_TYPE;
                    else if ( ( packet->msg_id & OPENSAFETY_SSDO_MESSAGE_TYPE ) == OPENSAFETY_SSDO_MESSAGE_TYPE )
                        type = OPENSAFETY_SSDO_MESSAGE_TYPE;
                    else if ( ( packet->msg_id & OPENSAFETY_SPDO_MESSAGE_TYPE ) == OPENSAFETY_SPDO_MESSAGE_TYPE )
                        type = OPENSAFETY_SPDO_MESSAGE_TYPE;
                    else if ( ( packet->msg_id & OPENSAFETY_SNMT_MESSAGE_TYPE ) == OPENSAFETY_SNMT_MESSAGE_TYPE )
                        type = OPENSAFETY_SNMT_MESSAGE_TYPE;
                    else {
                        frameOffset += 2;
                        found--;
                        continue;
                    }
                } else {
                    frameOffset += 2;
                    found--;
                    continue;
                }
            }
            if ( global_classify_transport && transporttype != OPENSAFETY_ANY_TRANSPORT )
            {
                if ( ( transporttype == OPENSAFETY_ACYCLIC_DATA && type == OPENSAFETY_SPDO_MESSAGE_TYPE ) ||
                        ( transporttype == OPENSAFETY_CYCLIC_DATA && type != OPENSAFETY_SPDO_MESSAGE_TYPE ) )
                {
                    frameOffset += 2;
                    found--;
                    continue;
                }
            }
            if ( type != OPENSAFETY_SPDO_MESSAGE_TYPE )
            {
                gint idx = -1;
                try_val_to_str_idx(OSS_FRAME_ID_T(message_tvb, byte_offset + frameStart1), opensafety_message_type_values, &idx );
                if ( idx < 0 )
                {
                    frameOffset += 2;
                    found--;
                    continue;
                }
                else if ( type == OPENSAFETY_SNMT_MESSAGE_TYPE &&
                        (OSS_FRAME_ID_T(message_tvb, byte_offset + frameStart1) != OSS_FRAME_ID_T(message_tvb, byte_offset + frameStart2)) )
                {
                    frameOffset += 2;
                    found--;
                    continue;
                }
            }
            if ( ( (gint)frameLength - (gint)( frameStart2 > frameStart1 ? frameStart2 : frameLength - frameStart1 ) ) < 0 )
                return FALSE;
            if ( type == OPENSAFETY_SPDO_MESSAGE_TYPE )
            {
                nodeAddress = OSS_FRAME_ADDR_T(message_tvb, byte_offset + frameStart1);
                if ( nodeAddress == 0 || nodeAddress > 1024 ) {
                    markAsMalformed = TRUE;
                }
                if ( OSS_FRAME_ID_T(message_tvb, byte_offset + frameStart1) == OPENSAFETY_MSG_SPDO_RESERVED )
                {
                    frameOffset += 2;
                    found--;
                    continue;
                }
            }
            gint addr = OSS_FRAME_ADDR_T(message_tvb, byte_offset + frameStart1);
            if ( global_filter_list && wmem_list_count ( global_filter_list ) > 0 )
            {
                gboolean found_in_list = wmem_list_find(global_filter_list, GINT_TO_POINTER( addr )) ? TRUE : FALSE;
                if ( ( ! global_show_only_node_in_filter && found_in_list ) ||
                        ( global_show_only_node_in_filter && ! found_in_list ) )
                {
                    opensafety_item = proto_tree_add_item(tree, proto_opensafety, message_tvb, frameOffset, frameLength, ENC_NA);
                    proto_item_append_text(opensafety_item, ", Filtered Node: 0x%03X (%d)", addr, addr);
                    frameOffset += 2;
                    found--;
                    continue;
                }
            }
            if ( global_display_intergap_data == TRUE && gapStart != frameOffset )
            {
                gap_tvb = tvb_new_subset_length_caplen(message_tvb, gapStart, (frameOffset - gapStart), reported_len);
                call_dissector(data_dissector, gap_tvb, pinfo, tree);
            }
            gapStart = frameOffset + frameLength;
            next_tvb = tvb_new_subset_length_caplen ( message_tvb, frameOffset, frameLength, reported_len );
            add_new_data_source(pinfo, next_tvb, "openSAFETY Frame");
            if ( force_nr_in_package > 0 )
            {
                found = force_nr_in_package + 1;
                dissectorCalled = TRUE;
                col_set_str(pinfo->cinfo, COL_PROTOCOL, protocolName);
            }
            if ( ! dissectorCalled )
            {
                if ( call_sub_dissector )
                    call_dissector(protocol_dissector, message_tvb, pinfo, tree);
                dissectorCalled = TRUE;
                col_set_str(pinfo->cinfo, COL_PROTOCOL, protocolName);
                col_clear(pinfo->cinfo, COL_INFO);
            }
            if ( tree )
            {
                opensafety_item = proto_tree_add_item(tree, proto_opensafety, message_tvb, frameOffset, frameLength, ENC_NA);
                opensafety_tree = proto_item_add_subtree(opensafety_item, ett_opensafety);
            } else {
                opensafety_item = NULL;
                opensafety_tree = NULL;
            }
            packet->msg_type = type;
            packet->frame.frame_tvb = next_tvb;
            packet->frame.byte_offset = frameOffset + tvb_raw_offset(message_tvb);
            packet->frame.subframe1 = frameStart1;
            packet->frame.subframe2 = frameStart2;
            packet->frame.length = frameLength;
            packet->frame.malformed = FALSE;
            if ( packet->msg_type == OPENSAFETY_SPDO_MESSAGE_TYPE )
                packet->msg_id = packet->msg_id & 0xF8;
            if ( dissect_opensafety_message(packet, next_tvb, pinfo, opensafety_item, opensafety_tree, found, previous_msg_id) != TRUE )
                markAsMalformed = TRUE;
            previous_msg_id = packet->msg_id;
            if ( markAsMalformed )
            {
                packet->frame.malformed = TRUE;
                if ( OSS_FRAME_ADDR_T(message_tvb, byte_offset + frameStart1) > 1024 )
                    expert_add_info(pinfo, opensafety_item, &ei_message_spdo_address_invalid );
            }
            tap_queue_packet(opensafety_tap, pinfo, packet);
            handled = TRUE;
        }
        else
            break;
        frameOffset += frameLength;
        if ( tvb_captured_length_remaining(message_tvb, frameOffset) > 0 )
            frameOffset += 1;
    }
    if ( handled == TRUE )
    {
        if ( frameOffset < length && global_display_intergap_data == TRUE && gapStart != frameOffset )
        {
            gap_tvb = tvb_new_subset_length_caplen(message_tvb, gapStart, (length - gapStart), reported_len);
            call_dissector(data_dissector, gap_tvb, pinfo, tree);
        }
    }
    return ( handled ? TRUE : FALSE );
}
