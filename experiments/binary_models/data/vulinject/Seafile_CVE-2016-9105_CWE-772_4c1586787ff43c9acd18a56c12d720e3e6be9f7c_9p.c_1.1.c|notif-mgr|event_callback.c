event_callback (struct lws *wsi, enum lws_callback_reasons reason,
                void *user, void *in, size_t len)
{
    NotifServer *server = (NotifServer *)user;
    Message *msg = NULL;
    int m;
    int ret = 0;
    if (!server) {
        return ret;
    }
    seaf_debug ("Notification event: %d\n", reason);
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        server->status = STATUS_ERROR;
        seaf_debug ("websocket connection error: %s\n",
            in ? (char *)in : "(null)");
        ret = -1;
        break;
    case LWS_CALLBACK_CLIENT_RECEIVE:
        break;
    case LWS_CALLBACK_CLIENT_WRITEABLE:
        msg = g_async_queue_try_pop (server->messages);
        if (!msg) {
            break;
        }
        m = lws_write(wsi, ((unsigned char *)msg->payload) + LWS_PRE,
                  msg->len, msg->type);
        if (m < (int)msg->len) {
            notif_message_free (msg);
            seaf_warning ("Failed to write message to websocket\n");
            server->status = STATUS_ERROR;
            return -1;
        }
        notif_message_free (msg);
        break;
    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        seaf_sync_manager_check_locks_and_folder_perms (seaf->sync_mgr, server->server_url);
        server->status = STATUS_CONNECTED;
        seaf_debug ("Successfully connected to the server: %s\n", server->server_url);
        break;
    case LWS_CALLBACK_CLIENT_CLOSED:
        ret = -1;
        server->status = STATUS_ERROR;
        break;
    case LWS_CALLBACK_EVENT_WAIT_CANCELLED:
        ret = -1;
        server->status = STATUS_CANCELLED;
        break;
    default:
        break;
    }
    return ret;
}
