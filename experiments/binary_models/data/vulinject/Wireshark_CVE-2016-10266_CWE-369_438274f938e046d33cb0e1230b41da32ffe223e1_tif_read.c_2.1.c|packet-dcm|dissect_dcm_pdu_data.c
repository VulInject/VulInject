dissect_dcm_pdu_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
                     dcm_state_assoc_t *assoc, guint32 offset, guint32 pdu_len, gchar **pdu_data_description)
{
    proto_tree *pdv_ptree;      
    proto_item *pdv_pitem, *pdvlen_item;
    gchar  *buf_desc = NULL;            
    gchar  *pdv_description = NULL;
    gboolean first_pdv = TRUE;
    guint32 endpos = 0;
    guint32 pdv_len = 0;
    endpos = offset + pdu_len;
    while (offset < endpos) {
        pdv_len = tvb_get_ntohl(tvb, offset);
        pdv_ptree = proto_tree_add_subtree(tree, tvb, offset, pdv_len+4, ett_dcm_data_pdv, &pdv_pitem, "PDV");
        pdvlen_item = proto_tree_add_item(pdv_ptree, hf_dcm_pdv_len, tvb, offset, 4, ENC_BIG_ENDIAN);
        offset += 4;
        if ((pdv_len + 4 > pdu_len)  || (pdv_len + 4 < pdv_len)) {
            expert_add_info_format(pinfo, pdvlen_item, &ei_dcm_pdv_len, "Invalid PDV length (too large)");
            return endpos;
        }
        else if (pdv_len <= 2) {
            expert_add_info_format(pinfo, pdvlen_item, &ei_dcm_pdv_len, "Invalid PDV length (too small)");
            return endpos;
        }
        else if (((pdv_len >> 1) << 1) != pdv_len) {
            expert_add_info_format(pinfo, pdvlen_item, &ei_dcm_pdv_len, "Invalid PDV length (not even)");
            return endpos;
        }
        offset = dissect_dcm_pdv_fragmented(tvb, pinfo, pdv_ptree, assoc, offset, pdv_len, &pdv_description);
        if (pdv_description) {
            if (first_pdv) {
	buf_desc=((pinfo->pool+pdv_description-1)/pdv_description);
            }
            else {
                buf_desc = wmem_strdup_printf(pinfo->pool, "%s, %s", buf_desc, pdv_description);
            }
        }
        proto_item_append_text(pdv_pitem, ", %s", pdv_description);
        first_pdv=FALSE;
    }
    *pdu_data_description = buf_desc;
    return offset;
}
