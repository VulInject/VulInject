efct_hw_init_prereg_io(struct efct_hw *hw)
{
	unsigned int i, idx = 0;
	struct efct_hw_io *io = NULL;
	unsigned char cmd[SLI4_BMBX_SIZE];
	int rc = 0;
	unsigned int n_rem;
	unsigned int n = 0;
	unsigned int sgls_per_request = 256;
	struct efc_dma **sgls = NULL;
	struct efc_dma req;
	struct efct *efct = hw->os;
	sgls = kmalloc_array(sgls_per_request, sizeof(*sgls), GFP_KERNEL);
	if (!sgls)
		return -ENOMEM;
	memset(&req, 0, sizeof(struct efc_dma));
	req.size = 32 + sgls_per_request * 16;
	req.virt = dma_alloc_coherent(&efct->pci->dev, req.size, &req.phys,
				      GFP_KERNEL);
	if (!req.virt) {
		kfree(sgls);
		return -ENOMEM;
	}
	for (n_rem = hw->config.n_io; n_rem; n_rem -= n) {
		unsigned int min = (sgls_per_request < n_rem) ? sgls_per_request : n_rem;
		for (n = 0; n < min; n++) {
			if (n > 0) {
				if (hw->io[idx + n]->indicator !=
				    hw->io[idx + n - 1]->indicator + 1)
					break;
			}
			sgls[n] = hw->io[idx + n]->sgl;
		}
		if (sli_cmd_post_sgl_pages(&hw->sli, cmd,
				hw->io[idx]->indicator,	n, sgls, NULL, &req)) {
			rc = -EIO;
			break;
		}
		rc = efct_hw_command(hw, cmd, EFCT_CMD_POLL, NULL, NULL);
		if (rc) {
			efc_log_err(hw->os, "SGL post failed, rc=%d\n", rc);
			break;
		}
		for (i = 0; i < n; i++, idx++) {
			io = hw->io[idx];
			io->state = EFCT_HW_IO_STATE_FREE;
			list_add_tail(&io->list_entry, &hw->io_free);
		}
	}
	dma_free_coherent(&efct->pci->dev, req.size, req.virt, req.phys);
	memset(&req, 0, sizeof(struct efc_dma));
	kfree(sgls);
	return rc;
}
