int psb_intel_opregion_setup(struct drm_device *dev)
{
	struct drm_psb_private *dev_priv = to_drm_psb_private(dev);
	struct pci_dev *pdev = to_pci_dev(dev->dev);
	struct psb_intel_opregion *opregion = &dev_priv->opregion;
	int opregion_phy, mboxes;
	void __iomem *base;
	int err = 0;
	pci_read_config_dword(pdev, PCI_ASLS, &opregion_phy);
	if (opregion_phy == 0) {
		DRM_DEBUG_DRIVER("ACPI Opregion not supported\n");
		return -ENOTSUPP;
	}
	INIT_WORK(&opregion->asle_work, psb_intel_opregion_asle_work);
	DRM_DEBUG("OpRegion detected at 0x%8x\n", opregion_phy);
	base = acpi_os_ioremap(opregion_phy, 8*1024);
	if (!base)
		return -ENOMEM;
	if (memcmp(base, OPREGION_SIGNATURE, 16)) {
		DRM_DEBUG_DRIVER("opregion signature mismatch\n");
		err = -EINVAL;
		goto err_out;
	}
	opregion->header = base;
	opregion->vbt = base + OPREGION_VBT_OFFSET;
	opregion->lid_state = base + ACPI_CLID;
	mboxes = opregion->header->mboxes;
	if (mboxes & MBOX_ACPI) {
		DRM_DEBUG_DRIVER("Public ACPI methods supported\n");
		opregion->acpi = base + OPREGION_ACPI_OFFSET;
	}
	if (mboxes & MBOX_ASLE) {
		DRM_DEBUG_DRIVER("ASLE supported\n");
		opregion->asle = base + OPREGION_ASLE_OFFSET;
	}
	return 0;
err_out:
	iounmap(base);
	return err;
}
