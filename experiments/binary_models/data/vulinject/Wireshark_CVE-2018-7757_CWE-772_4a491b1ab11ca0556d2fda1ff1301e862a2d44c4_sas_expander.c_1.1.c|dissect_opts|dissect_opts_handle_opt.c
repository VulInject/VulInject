dissect_opts_handle_opt(int opt, char *optarg_str_p)
{
    char badopt;
    char *dotp;
    ts_precision tsp;
    switch(opt) {
    case 'd':        
        if (!decode_as_command_option(optarg_str_p))
             return false;
        break;
    case 'K':        
#if defined(HAVE_HEIMDAL_KERBEROS) || defined(HAVE_MIT_KERBEROS)
#else
        cmdarg_err("-K specified, but Kerberos keytab file support isn't present");
        return false;
#endif
        break;
    case 'n':        
        disable_name_resolution();
        break;
    case 'N':        
        badopt = string_to_name_resolve(optarg_str_p, &gbl_resolv_flags);
        if (badopt != '\0') {
            cmdarg_err("-N specifies unknown resolving option '%c'; valid options are:",
                       badopt);
            cmdarg_err_cont("\t'd' to enable address resolution from captured DNS packets\n"
                            "\t'g' to enable address geolocation information from MaxMind databases\n"
                            "\t'm' to enable MAC address resolution\n"
                            "\t'n' to enable network address resolution\n"
                            "\t'N' to enable using external resolvers (e.g., DNS)\n"
                            "\t    for network address resolution\n"
                            "\t't' to enable transport-layer port number resolution\n"
                            "\t'v' to enable VLAN IDs to names resolution");
            return false;
        }
        break;
    case 't':        
        tsp = TS_PREC_NOT_SET;
        dotp = strchr(optarg_str_p, '.');
        if (dotp != NULL) {
            if (strcmp(dotp + 1, "") == 0) {
                tsp = TS_PREC_AUTO;
            } else {
                unsigned int val;
                if (!ws_strtou32(dotp + 1, NULL, &val) || val > WS_TSPREC_MAX) {
                    cmdarg_err("Invalid .N time stamp precision \"%s\"; N must be a value between 0 and %u or absent",
                               dotp + 1, WS_TSPREC_MAX);
                    return false;
                }
                tsp = val;
            }
            *dotp = '\0';
        }
        if (strcmp(optarg_str_p, "r") == 0)
            global_dissect_options.time_format = TS_RELATIVE;
        else if (strcmp(optarg_str_p, "a") == 0)
            global_dissect_options.time_format = TS_ABSOLUTE;
        else if (strcmp(optarg_str_p, "ad") == 0)
            global_dissect_options.time_format = TS_ABSOLUTE_WITH_YMD;
        else if (strcmp(optarg_str_p, "adoy") == 0)
            global_dissect_options.time_format = TS_ABSOLUTE_WITH_YDOY;
        else if (strcmp(optarg_str_p, "d") == 0)
            global_dissect_options.time_format = TS_DELTA;
        else if (strcmp(optarg_str_p, "dd") == 0)
            global_dissect_options.time_format = TS_DELTA_DIS;
        else if (strcmp(optarg_str_p, "e") == 0)
            global_dissect_options.time_format = TS_EPOCH;
        else if (strcmp(optarg_str_p, "u") == 0)
            global_dissect_options.time_format = TS_UTC;
        else if (strcmp(optarg_str_p, "ud") == 0)
            global_dissect_options.time_format = TS_UTC_WITH_YMD;
        else if (strcmp(optarg_str_p, "udoy") == 0)
            global_dissect_options.time_format = TS_UTC_WITH_YDOY;
        else if (optarg_str_p != dotp) {
            cmdarg_err("Invalid time stamp type \"%s\"; it must be one of:", optarg_str_p);
            cmdarg_err_cont("\t\"a\"    for absolute\n"
                            "\t\"ad\"   for absolute with YYYY-MM-DD date\n"
                            "\t\"adoy\" for absolute with YYYY/DOY date\n"
                            "\t\"d\"    for delta\n"
                            "\t\"dd\"   for delta displayed\n"
                            "\t\"e\"    for epoch\n"
                            "\t\"r\"    for relative\n"
                            "\t\"u\"    for absolute UTC\n"
                            "\t\"ud\"   for absolute UTC with YYYY-MM-DD date\n"
                            "\t\"udoy\" for absolute UTC with YYYY/DOY date");
            if (dotp)
                *dotp = '.';
            return false;
        }
        if (dotp) {
            *dotp = '.';
            global_dissect_options.time_precision = tsp;
        }
        break;
    case 'u':        
        if (strcmp(optarg_str_p, "s") == 0)
            timestamp_set_seconds_type(TS_SECONDS_DEFAULT);
        else if (strcmp(optarg_str_p, "hms") == 0)
            timestamp_set_seconds_type(TS_SECONDS_HOUR_MIN_SEC);
        else {
            cmdarg_err("Invalid seconds type \"%s\"; it must be one of:", optarg_str_p);
            cmdarg_err_cont("\t\"s\"   for seconds\n"
                            "\t\"hms\" for hours, minutes and seconds");
            return false;
        }
        break;
    case LONGOPT_DISABLE_PROTOCOL: 
        global_dissect_options.disable_protocol_slist = g_slist_append(global_dissect_options.disable_protocol_slist, optarg_str_p);
        break;
    case LONGOPT_ENABLE_HEURISTIC: 
        global_dissect_options.enable_heur_slist = g_slist_append(global_dissect_options.enable_heur_slist, optarg_str_p);
        break;
    case LONGOPT_DISABLE_HEURISTIC: 
        global_dissect_options.disable_heur_slist = g_slist_append(global_dissect_options.disable_heur_slist, optarg_str_p);
        break;
    case LONGOPT_ENABLE_PROTOCOL: 
        global_dissect_options.enable_protocol_slist = g_slist_append(global_dissect_options.enable_protocol_slist, optarg_str_p);
        break;
    case LONGOPT_ONLY_PROTOCOLS: 
        proto_disable_all();
        for (char *ps = strtok (optarg_str_p, ","); ps; ps = strtok(NULL, ",")){
          global_dissect_options.enable_protocol_slist = g_slist_append(global_dissect_options.enable_protocol_slist, ps);
        }
        break;
    case LONGOPT_DISABLE_ALL_PROTOCOLS: 
        proto_disable_all();
        break;
    default:
        ws_assert_not_reached();
    }
    return true;
}
