static int corkscrew_open(struct net_device *dev)
{
	int ioaddr = dev->base_addr;
	struct corkscrew_private *vp = netdev_priv(dev);
	bool armtimer = false;
	__u32 config;
	int i;
	EL3WINDOW(3);
	if (vp->full_duplex)
		outb(0x20, ioaddr + Wn3_MAC_Ctrl);	
	config = inl(ioaddr + Wn3_Config);
	if (vp->media_override != 7) {
		if (corkscrew_debug > 1)
			pr_info("%s: Media override to transceiver %d (%s).\n",
				dev->name, vp->media_override,
				media_tbl[vp->media_override].name);
		dev->if_port = vp->media_override;
	} else if (vp->autoselect) {
		dev->if_port = 4;
		while (!(vp->available_media & media_tbl[dev->if_port].mask))
			dev->if_port = media_tbl[dev->if_port].next;
		if (corkscrew_debug > 1)
			pr_debug("%s: Initial media type %s.\n",
			       dev->name, media_tbl[dev->if_port].name);
		armtimer = true;
	} else
		dev->if_port = vp->default_media;
	config = (config & ~Xcvr) | (dev->if_port << Xcvr_shift);
	outl(config, ioaddr + Wn3_Config);
	if (corkscrew_debug > 1) {
		pr_debug("%s: corkscrew_open() InternalConfig %8.8x.\n",
		       dev->name, config);
	}
	outw(TxReset, ioaddr + EL3_CMD);
	for (i = 20; i >= 0; i--)
		if (!(inw(ioaddr + EL3_STATUS) & CmdInProgress))
			break;
	outw(RxReset, ioaddr + EL3_CMD);
	for (i = 20; i >= 0; i--)
		if (!(inw(ioaddr + EL3_STATUS) & CmdInProgress))
			break;
	outw(SetStatusEnb | 0x00, ioaddr + EL3_CMD);
	if (vp->capabilities == 0x11c7) {
		if (dev->irq == 0 ||
		    dev->dma == 0 ||
		    request_irq(dev->irq, corkscrew_interrupt, 0,
				vp->product_name, dev))
			return -EAGAIN;
		set_dma_mode(dev->dma, DMA_MODE_CASCADE);
	} else if (request_irq(dev->irq, corkscrew_interrupt, IRQF_SHARED,
			       vp->product_name, dev)) {
		return -EAGAIN;
	}
	if (armtimer)
		mod_timer(&vp->timer, jiffies + media_tbl[dev->if_port].wait);
	if (corkscrew_debug > 1) {
		EL3WINDOW(4);
		pr_debug("%s: corkscrew_open() irq %d media status %4.4x.\n",
		       dev->name, dev->irq, inw(ioaddr + Wn4_Media));
	}
	EL3WINDOW(2);
	for (i = 0; i < 6; i++)
		outb(dev->dev_addr[i], ioaddr + i);
	for (; i < 12; i += 2)
		outw(0, ioaddr + i);
	if (dev->if_port == 3)
		outw(StartCoax, ioaddr + EL3_CMD);
	EL3WINDOW(4);
	outw((inw(ioaddr + Wn4_Media) & ~(Media_10TP | Media_SQE)) |
	     media_tbl[dev->if_port].media_bits, ioaddr + Wn4_Media);
	outw(StatsDisable, ioaddr + EL3_CMD);
	EL3WINDOW(6);
	for (i = 0; i < 10; i++)
		inb(ioaddr + i);
	inw(ioaddr + 10);
	inw(ioaddr + 12);
	EL3WINDOW(4);
	inb(ioaddr + 12);
	outw(0x0040, ioaddr + Wn4_NetDiag);
	EL3WINDOW(7);
	if (vp->full_bus_master_rx) {	
		vp->cur_rx = vp->dirty_rx = 0;
		if (corkscrew_debug > 2)
			pr_debug("%s:  Filling in the Rx ring.\n", dev->name);
		for (i = 0; i < RX_RING_SIZE; i++) {
			struct sk_buff *skb;
			if (i < (RX_RING_SIZE - 1))
				vp->rx_ring[i].next =
				    isa_virt_to_bus(&vp->rx_ring[i + 1]);
			else
				vp->rx_ring[i].next = 0;
			vp->rx_ring[i].status = 0;	
			vp->rx_ring[i].length = PKT_BUF_SZ | 0x80000000;
			skb = netdev_alloc_skb(dev, PKT_BUF_SZ);
			vp->rx_skbuff[i] = skb;
			if (skb == NULL)
				break;	
			skb_reserve(skb, 2);	
			vp->rx_ring[i].addr = isa_virt_to_bus(skb->data);
		}
		if (i != 0)
			vp->rx_ring[i - 1].next =
				isa_virt_to_bus(&vp->rx_ring[0]);	
		outl(isa_virt_to_bus(&vp->rx_ring[0]), ioaddr + UpListPtr);
	}
	if (vp->full_bus_master_tx) {	
		vp->cur_tx = vp->dirty_tx = 0;
		outb(PKT_BUF_SZ >> 8, ioaddr + TxFreeThreshold);	
		for (i = 0; i < TX_RING_SIZE; i++)
			vp->tx_skbuff[i] = NULL;
		outl(0, ioaddr + DownListPtr);
	}
	set_rx_mode(dev);
	outw(StatsEnable, ioaddr + EL3_CMD);	
	netif_start_queue(dev);
	outw(RxEnable, ioaddr + EL3_CMD);	
	outw(TxEnable, ioaddr + EL3_CMD);	
	outw(SetStatusEnb | AdapterFailure | IntReq | StatsFull |
	     (vp->full_bus_master_tx ? DownComplete : TxAvailable) |
	     (vp->full_bus_master_rx ? UpComplete : RxComplete) |
	     (vp->bus_master ? DMADone : 0), ioaddr + EL3_CMD);
	outw(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,
	     ioaddr + EL3_CMD);
	outw(SetIntrEnb | IntLatch | TxAvailable | RxComplete | StatsFull
	     | (vp->bus_master ? DMADone : 0) | UpComplete | DownComplete,
	     ioaddr + EL3_CMD);
	return 0;
}
