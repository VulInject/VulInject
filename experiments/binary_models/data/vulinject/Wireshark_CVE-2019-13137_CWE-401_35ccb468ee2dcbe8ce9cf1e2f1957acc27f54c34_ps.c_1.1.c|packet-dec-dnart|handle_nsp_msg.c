handle_nsp_msg(
    tvbuff_t *tvb,
    packet_info *pinfo,
    proto_tree *tree,
    guint offset,
    guint8 nsp_msg_type)
{
    guint      my_offset = offset;
    gint       data_length;
    guint16    ack_num, ack_dat, ack_oth, seg_num;
    guint8     ls_flags, fc_val, services;
    proto_item  *ti;
    proto_tree *flow_control_tree;
    switch (nsp_msg_type) {
        case DATA_SEGMENT_MSG:     
        case BOM_MSG:              
        case EOM_MSG:              
        case BOM_EOM_MSG:          
            ack_num = tvb_get_letohs(tvb, my_offset);
            if (ack_num & 0x8000) {
                proto_tree_add_none_format(tree, hf_dec_rt_acknum,
                    tvb, my_offset, 2,
                    "Last data segment %s acknowledged: %d",
                    (ack_num & 0x1000) ? "negatively" : "positively",
                    ack_num & 0xfff);
                my_offset += 2;
                ack_oth = tvb_get_letohs(tvb, my_offset);
                if (ack_oth & 0x8000) {
                    proto_tree_add_none_format(tree, hf_dec_rt_acknum,
                        tvb, my_offset, 2,
                        "Cross sub-channel %s of other data msg %d",
                        ((ack_oth & 0x3000) == 0x2000) ? "ACK" : "NAK",
                        ack_oth & 0xfff);
                    my_offset += 2;
                }
            }
            seg_num = tvb_get_letohs(tvb, my_offset);
            if (nsp_msg_type == BOM_MSG) {
                dec_dna_total_bytes_this_segment = 0;
                col_append_fstr(pinfo->cinfo, COL_INFO,
                    "msg nr. %d: start of segment",
                    seg_num & 0xfff);
            } else if (nsp_msg_type == DATA_SEGMENT_MSG) {
                col_append_fstr(pinfo->cinfo, COL_INFO,
                    "msg nr. %d: continuation segment ",
                    seg_num & 0xfff);
            } else if (nsp_msg_type == EOM_MSG) {
                col_append_fstr(pinfo->cinfo, COL_INFO,
                    "msg nr. %d: end of segment",
                    seg_num & 0xfff);
            } else if (nsp_msg_type == BOM_EOM_MSG) {
                dec_dna_total_bytes_this_segment = 0;
                col_append_fstr(pinfo->cinfo, COL_INFO,
                    "msg nr. %d single segment",
                    seg_num & 0xfff);
            }
            proto_tree_add_item(tree, hf_dec_rt_segnum,
                tvb, my_offset, 2, ENC_LITTLE_ENDIAN);
            proto_tree_add_item(tree, hf_dec_rt_delay,
                tvb, my_offset, 2, ENC_LITTLE_ENDIAN);
            my_offset += 2;
            data_length =
                tvb_reported_length_remaining(tvb, my_offset);
            dec_dna_previous_total = dec_dna_total_bytes_this_segment;
            dec_dna_total_bytes_this_segment += data_length;
            col_append_fstr(pinfo->cinfo, COL_INFO,
                ", bytes this segment: %d, total so far:%d",
                data_length, dec_dna_total_bytes_this_segment);
            break;
        case INTERRUPT_MSG:        
            col_set_str(pinfo->cinfo, COL_INFO, "NSP interrupt message");
            ack_num = tvb_get_letohs(tvb, my_offset);
            if (ack_num & 0x8000) {
                proto_tree_add_none_format(tree, hf_dec_rt_acknum,
                    tvb, my_offset, 2,
                    "Last interrupt/link service msg %s acknowledged: %d",
                    (ack_num & 0x1000) ? "negatively" : "positively",
                    ack_num & 0xfff);
                my_offset += 2;
            } else {
                proto_tree_add_item(tree, hf_dec_rt_segnum,
                    tvb, my_offset, 2, ENC_LITTLE_ENDIAN);
                proto_tree_add_item(tree, hf_dec_rt_delay,
                    tvb, my_offset, 2, ENC_LITTLE_ENDIAN);
                my_offset += 2;
                break;
            }
            ack_dat = tvb_get_letohs(tvb, my_offset);
            if (ack_dat & 0x8000) {
                proto_tree_add_none_format(tree, hf_dec_rt_acknum,
                    tvb, my_offset, 2,
                    "Cross sub-channel %s of data segment msg: %d",
                    ((ack_dat & 0x3000) == 0x2000) ? "ACK" : "NAK",
                   ack_dat & 0xfff);
                my_offset += 2;
            }
            proto_tree_add_item(tree, hf_dec_rt_segnum,
                tvb, my_offset, 2, ENC_LITTLE_ENDIAN);
            proto_tree_add_item(tree, hf_dec_rt_delay,
                tvb, my_offset, 2, ENC_LITTLE_ENDIAN);
            my_offset += 2;
            break;
        case LINK_SERVICE_MSG:     
            col_set_str(pinfo->cinfo, COL_INFO, "NSP link control message");
            ack_num = tvb_get_letohs(tvb, my_offset);
            if (ack_num & 0x8000) {
                proto_tree_add_none_format(tree, hf_dec_rt_acknum,
                    tvb, my_offset, 2,
                    "Last interrupt/link service msg %s acknowledged: %d",
                    (ack_num & 0x1000) ? "negatively" : "positively",
                    ack_num & 0xfff);
                my_offset += 2;
            } else {
                proto_tree_add_item(tree, hf_dec_rt_segnum,
                    tvb, my_offset, 2, ENC_LITTLE_ENDIAN);
                proto_tree_add_item(tree, hf_dec_rt_delay,
                    tvb, my_offset, 2, ENC_LITTLE_ENDIAN);
                my_offset += 2;
                break;
            }
            ack_dat = tvb_get_letohs(tvb, my_offset);
            if (ack_dat & 0x8000) {
                proto_tree_add_none_format(tree, hf_dec_rt_acknum,
                    tvb, my_offset, 2,
                    "Cross sub-channel %s of data segment msg: %d",
                    ((ack_dat & 0x3000) == 0x2000) ? "ACK" : "NAK",
                   ack_dat & 0xfff);
                my_offset += 2;
            }
            proto_tree_add_item(tree, hf_dec_rt_segnum,
                tvb, my_offset, 2, ENC_LITTLE_ENDIAN);
            proto_tree_add_item(tree, hf_dec_rt_delay,
                tvb, my_offset, 2, ENC_LITTLE_ENDIAN);
            my_offset += 2;
            ls_flags = tvb_get_guint8(tvb, my_offset);
            switch(ls_flags) {
                case 0: 
                    col_append_str(pinfo->cinfo, COL_INFO,
                       "(no change)");
                break;
                case 1: 
                    col_append_str(pinfo->cinfo, COL_INFO,
                       "(stop)");
                break;
                case 2: 
                    col_append_str(pinfo->cinfo, COL_INFO,
                       "(go)");
                break;
                default:
                break;
            }
            fc_val = tvb_get_guint8(tvb, my_offset + 1);
            ti = proto_tree_add_uint(tree, hf_dec_flow_control, tvb,
                         my_offset, 1, ls_flags);
            flow_control_tree =
                proto_item_add_subtree(ti, ett_dec_flow_control);
            proto_tree_add_none_format(flow_control_tree, hf_dec_rt_fc_val,
                tvb, my_offset, 2,
                "Request for additional %d %s msgs",
                fc_val, ((ls_flags & 0x04) ? "interrupt" : "data"));
            my_offset += 2;
            break;
        case DATA_ACK_MSG:         
            ack_num = tvb_get_letohs(tvb, my_offset);
            proto_tree_add_none_format(tree, hf_dec_rt_acknum,
                tvb, my_offset, 2,
                "Last data segment %s acknowledged: %d",
                (ack_num & 0x1000) ? "negatively" : "positively",
                ack_num & 0xfff);
            my_offset += 2;
            col_append_fstr(pinfo->cinfo, COL_INFO,
                "NSP data %s message(%d)",
                    (ack_num & 0x1000) ? "NAK" : "ACK",
                    ack_num & 0xfff);
            if (tvb_reported_length_remaining(tvb, my_offset) > 0) {
                ack_oth = tvb_get_letohs(tvb, my_offset);
                if (ack_oth & 0x8000) {
                    proto_tree_add_none_format(tree, hf_dec_rt_acknum,
                        tvb, my_offset, 2,
                        "Cross sub-channel %s of other data msg %d",
                        ((ack_oth & 0x3000) == 0x2000) ? "ACK" : "NAK",
                        ack_oth & 0xfff);
                    my_offset += 2;
                }
            }
            break;
        case OTHER_DATA_ACK_MSG:   
            col_set_str(pinfo->cinfo, COL_INFO, "NSP other data ACK message");
            ack_num = tvb_get_letohs(tvb, my_offset);
            proto_tree_add_none_format(tree, hf_dec_rt_acknum,
                tvb, my_offset, 2,
                "Last interrupt/link service msg %s acknowledged: %d",
                (ack_num & 0x1000) ? "negatively" : "positively",
                ack_num & 0xfff);
            my_offset += 2;
            if (tvb_reported_length_remaining(tvb, my_offset) > 0) {
                ack_dat = tvb_get_letohs(tvb, my_offset);
                if (ack_dat & 0x8000) {
                    proto_tree_add_none_format(tree, hf_dec_rt_acknum,
                        tvb, my_offset, 2,
                        "Cross sub-channel %s of data msg %d",
                        ((ack_dat & 0x3000) == 0x2000) ? "ACK" : "NAK",
                        ack_dat & 0xfff);
                    my_offset += 2;
                }
            }
            break;
        case CONN_CONFIRM_MSG:     
        case CONN_INITIATE_MSG:    
            col_set_str(pinfo->cinfo, COL_INFO, "NSP connect confirm/initiate message");
            services = tvb_get_guint8(tvb, my_offset);
            proto_tree_add_uint(tree, hf_dec_rt_services, tvb,
                         my_offset, 1, services);
            my_offset++;
            proto_tree_add_item(tree, hf_dec_rt_info, tvb, my_offset, 1, ENC_LITTLE_ENDIAN);
            my_offset++;
            proto_tree_add_item(tree, hf_dec_rt_seg_size, tvb, my_offset, 2, ENC_LITTLE_ENDIAN);
            my_offset += 2;
            my_offset = handle_connect_contents(tvb, tree, my_offset);
            break;
        case DISCONN_INITIATE_MSG: 
        case DISCONN_CONFIRM_MSG:  
            col_set_str(pinfo->cinfo, COL_INFO, "NSP disconnect initiate/confirm message");
            proto_tree_add_item(tree, hf_dec_disc_reason, tvb, my_offset, 2, ENC_LITTLE_ENDIAN);
            my_offset += 2;
            if (nsp_msg_type == DISCONN_INITIATE_MSG) {
            }
            break;
        default:
            break;
    }
    return (my_offset);
}
