bgp_print(netdissect_options *ndo,
          const u_char *dat, u_int length _U_)
{
    const u_char *p;
    const u_char *ep = ndo->ndo_snapend;
    const u_char *start;
    const u_char marker[] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    };
    const struct bgp *bgp_header;
    unsigned short hlen;
    ndo->ndo_protocol = "bgp";
    ND_PRINT(": BGP");
    if (ndo->ndo_vflag < 1) 
        return;
    p = dat;
    start = p;
    while (p < ep) {
        if (!ND_TTEST_1(p))
            break;
        if (GET_U_1(p) != 0xff) {
            p++;
            continue;
        }
        if (!ND_TTEST_LEN(p, sizeof(marker)))
            break;
        if (memcmp(p, marker, sizeof(marker)) != 0) {
            p++;
            continue;
        }
        bgp_header = (const struct bgp *)p;
        if (start != p)
            nd_print_trunc(ndo);
        hlen = GET_BE_U_2(bgp_header->bgp_len);
        if (hlen < BGP_SIZE) {
            ND_PRINT("\nmessage length %u < %u", hlen, BGP_SIZE);
            nd_print_invalid(ndo);
            break;
        }
        if (ND_TTEST_LEN(p, hlen)) {
            if (!bgp_pdu_print(ndo, p, hlen))
                return;
            p += hlen;
            start = p;
        } else {
            ND_PRINT("\n[|BGP %s]",
                      tok2str(bgp_msg_values,
                              "Unknown Message Type",
                              GET_U_1(bgp_header->bgp_type)));
            break;
        }
    }
    return;
trunc:
    nd_print_trunc(ndo);
}
