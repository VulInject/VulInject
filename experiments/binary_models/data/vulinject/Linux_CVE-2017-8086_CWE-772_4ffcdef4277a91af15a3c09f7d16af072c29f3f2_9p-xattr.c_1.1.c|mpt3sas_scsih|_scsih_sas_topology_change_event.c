_scsih_sas_topology_change_event(struct MPT3SAS_ADAPTER *ioc,
	struct fw_event_work *fw_event)
{
	int i;
	unsigned short parent_handle, handle;
	unsigned short reason_code;
	unsigned char phy_number, max_phys;
	struct _sas_node *sas_expander;
	unsigned int int sas_address;
	unsigned int flags;
	unsigned char link_rate, prev_link_rate;
	struct hba_port *port;
	Mpi2EventDataSasTopologyChangeList_t *event_data =
		(Mpi2EventDataSasTopologyChangeList_t *)
		fw_event->event_data;
	if (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)
		_scsih_sas_topology_change_event_debug(ioc, event_data);
	if (ioc->shost_recovery || ioc->remove_host || ioc->pci_error_recovery)
		return 0;
	if (!ioc->sas_hba.num_phys)
	else
		_scsih_sas_host_refresh(ioc);
	if (fw_event->ignore) {
		dewtprintk(ioc, ioc_info(ioc, "ignoring expander event\n"));
		return 0;
	}
	parent_handle = le16_to_cpu(event_data->ExpanderDevHandle);
	port = mpt3sas_get_port_by_id(ioc, event_data->PhysicalPort, 0);
	if (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_ADDED)
		if (_scsih_expander_add(ioc, parent_handle) != 0)
			return 0;
	spin_lock_irqsave(&ioc->sas_node_lock, flags);
	sas_expander = mpt3sas_scsih_expander_find_by_handle(ioc,
	    parent_handle);
	if (sas_expander) {
		sas_address = sas_expander->sas_address;
		max_phys = sas_expander->num_phys;
		port = sas_expander->port;
	} else if (parent_handle < ioc->sas_hba.num_phys) {
		sas_address = ioc->sas_hba.sas_address;
		max_phys = ioc->sas_hba.num_phys;
	} else {
		spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
		return 0;
	}
	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
	for (i = 0; i < event_data->NumEntries; i++) {
		if (fw_event->ignore) {
			dewtprintk(ioc,
				   ioc_info(ioc, "ignoring expander event\n"));
			return 0;
		}
		if (ioc->remove_host || ioc->pci_error_recovery)
			return 0;
		phy_number = event_data->StartPhyNum + i;
		if (phy_number >= max_phys)
			continue;
		reason_code = event_data->PHY[i].PhyStatus &
		    MPI2_EVENT_SAS_TOPO_RC_MASK;
		if ((event_data->PHY[i].PhyStatus &
		    MPI2_EVENT_SAS_TOPO_PHYSTATUS_VACANT) && (reason_code !=
		    MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING))
				continue;
		handle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);
		if (!handle)
			continue;
		link_rate = event_data->PHY[i].LinkRate >> 4;
		prev_link_rate = event_data->PHY[i].LinkRate & 0xF;
		switch (reason_code) {
		case MPI2_EVENT_SAS_TOPO_RC_PHY_CHANGED:
			if (ioc->shost_recovery)
				break;
			if (link_rate == prev_link_rate)
				break;
			mpt3sas_transport_update_links(ioc, sas_address,
			    handle, phy_number, link_rate, port);
			if (link_rate < MPI2_SAS_NEG_LINK_RATE_1_5)
				break;
			_scsih_check_device(ioc, sas_address, handle,
			    phy_number, link_rate);
			if (!test_bit(handle, ioc->pend_os_device_add))
				break;
			fallthrough;
		case MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED:
			if (ioc->shost_recovery)
				break;
			mpt3sas_transport_update_links(ioc, sas_address,
			    handle, phy_number, link_rate, port);
			_scsih_add_device(ioc, handle, phy_number, 0);
			break;
		case MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING:
			_scsih_device_remove_by_handle(ioc, handle);
			break;
		}
	}
	if (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING &&
	    sas_expander)
		mpt3sas_expander_remove(ioc, sas_address, port);
	return 0;
}
