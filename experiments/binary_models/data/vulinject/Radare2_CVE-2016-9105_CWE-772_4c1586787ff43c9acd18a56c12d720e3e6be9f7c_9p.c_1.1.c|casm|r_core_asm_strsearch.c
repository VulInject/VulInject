R_API RList *r_core_asm_strsearch(RCore *core, const char *input, ut64 from, ut64 to, int maxhits, int regexp, int everyByte, int mode) {
	RCoreAsmHit *hit;
	RList *hits;
	ut64 at, toff = core->offset;
	ut8 *buf;
	int align = core->search->align;
	RRegex* rx = NULL;
	char *tok, *tokens[1024], *code = NULL, *ptr;
	char *save_ptr = NULL;
	int idx, tidx = 0, len = 0;
	int tokcount, matchcount, count = 0;
	int matches = 0;
	const int addrbytes = core->io->addrbytes;
	 ut64 first_match_addr = 0;
	if (!input || !*input) {
		return NULL;
	}
	char *inp = r_str_trim_dup (input + 1);
	char *inp_arg = strchr (inp, ' ');
	if (inp_arg) {
		*inp_arg++ = 0;
	}
	ut64 usrimm = r_num_math (core->num, inp);
	ut64 usrimm2 = inp_arg? r_num_math (core->num, inp_arg): usrimm;
	if (usrimm > usrimm2) {
		R_LOG_ERROR ("/ci : Invalid range");
		return NULL;
	}
	if (core->blocksize < 8) {
		R_LOG_ERROR ("block size too small");
		return NULL;
	}
	if (!(buf = (ut8 *)calloc (core->blocksize, 1))) {
		return NULL;
	}
	if (!(ptr = strdup (input))) {
		free (buf);
		return NULL;
	}
	if (!(hits = r_core_asm_hit_list_new ())) {
		free (buf);
		free (ptr);
		return NULL;
	}
	tokens[0] = NULL;
	for (tokcount = 0; tokcount < R_ARRAY_SIZE (tokens) - 1; tokcount++) {
		tok = r_str_tok_r (tokcount? NULL: ptr, ";", &save_ptr);
		if (!tok) {
			break;
		}
		r_str_trim (tok);
		tokens[tokcount] = tok;
	}
	tokens[tokcount] = NULL;
	r_cons_break_push (NULL, NULL);
	char *opst = NULL;
	for (at = from; at < to; at += core->blocksize) {
		if (r_cons_is_breaked ()) {
			break;
		}
		if (!r_io_is_valid_offset (core->io, at, 0)) {
			break;
		}
		(void)r_io_read_at (core->io, at, buf, core->blocksize);
		idx = 0, matchcount = 0;
		while (addrbytes * (idx + 1) <= core->blocksize) {
			ut64 addr = at + idx;
			if (addr >= to) {
				break;
			}
			r_asm_set_pc (core->rasm, addr);
			if (mode == 'i') {
				RAnalOp analop = {0};
				ut64 len = R_MIN (15, core->blocksize - idx);
				if (r_anal_op (core->anal, &analop, addr, buf + idx, len, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_DISASM) < 1) {
					idx ++; 
					continue;
				}
				ut64 val = analop.val; 
				bool match = (val != UT64_MAX && val >= usrimm && val <= usrimm2);
				if (!match) {
					ut64 val = analop.disp;
					match = (val != UT64_MAX && val >= usrimm && val <= usrimm2);
				}
				if (!match) {
					ut64 val = analop.ptr;
					match = (val != UT64_MAX && val >= usrimm && val <= usrimm2);
				}
				if (match) {
					RAnalOp op;
					if (!(hit = r_core_asm_hit_new ())) {
						r_list_purge (hits);
						R_FREE (hits);
						goto beach;
					}
					hit->addr = addr;
					hit->len = analop.size;  
					if (hit->len == -1) {
						r_core_asm_hit_free (hit);
						goto beach;
					}
					r_asm_disassemble (core->rasm, &op, buf + addrbytes * idx,
					      core->blocksize - addrbytes * idx);
					hit->code = strdup (op.mnemonic);
					r_asm_op_fini (&op);
					idx = (matchcount)? tidx + 1: idx + 1;
					matchcount = 0;
					continue;
				}
				r_anal_op_fini (&analop);
				idx ++; 
				continue;
			} else if (mode == 'e') {
				RAnalOp analop = {0};
				if (r_anal_op (core->anal, &analop, addr, buf + idx, 15, R_ARCH_OP_MASK_ESIL) < 1) {
					idx ++; 
					continue;
				}
				opst = strdup (r_strbuf_get (&analop.esil));
				r_anal_op_fini (&analop);
			} else {
				RAnalOp op;
				if (!(len = r_asm_disassemble (
					      core->rasm, &op,
					      buf + addrbytes * idx,
					      core->blocksize - addrbytes * idx))) {
					idx = (matchcount)? tidx + 1: idx + 1;
					matchcount = 0;
					r_asm_op_fini (&op);
					continue;
				}
				if (op.mnemonic) {
					opst = strdup (op.mnemonic);
				} else {
					R_LOG_DEBUG ("Cannot disassemble at 0x%08"PFMT64x, addr);
				}
				r_asm_op_fini (&op);
			}
			if (opst) {
				matches = strcmp (opst, "invalid") && strcmp (opst, "unaligned");
			}
			if (matches && tokens[matchcount]) {
				if (mode == 'a') { 
					matches = !r_str_ncasecmp (opst, tokens[matchcount], strlen (tokens[matchcount]));
				} else if (!regexp) {
					matches = !!strstr (opst, tokens[matchcount]);
				} else {
					rx = r_regex_new (tokens[matchcount], "es");
					matches = r_regex_exec (rx, opst, 0, 0, 0) == 0;
					r_regex_free (rx);
				}
			}
			if (align && align > 1) {
				if (addr % align) {
					matches = false;
				}
			}
			if (matches) {
				code = r_str_appendf (code, "%s; ", opst);
				if (matchcount == 0) {
					first_match_addr = addr;
				}
				if (matchcount == tokcount - 1) {
					if (tokcount == 1) {
						tidx = idx;
					}
					if (!(hit = r_core_asm_hit_new ())) {
						r_list_purge (hits);
						R_FREE (hits);
						goto beach;
					}
					hit->addr = first_match_addr;
					hit->len = idx + len - tidx;
					if (hit->len == -1) {
						r_core_asm_hit_free (hit);
						goto beach;
					}
					code[strlen (code) - 2] = 0;
					hit->code = strdup (code);
					r_list_append (hits, hit);
					R_FREE (code);
					matchcount = 0;
					idx = tidx + 1;
					if (maxhits) {
						count++;
						if (count >= maxhits) {
							goto beach;
						}
					}
				} else if (!matchcount) {
					tidx = idx;
					matchcount++;
					idx += len;
				} else {
					matchcount++;
					idx += len;
				}
			} else {
				if (everyByte) {
					idx = matchcount? tidx + 1: idx + 1;
				} else {
					idx += R_MAX (1, len);
				}
				R_FREE (code);
				matchcount = 0;
			}
			R_FREE (opst);
		}
	}
beach:
	r_asm_set_pc (core->rasm, toff);
	free (buf);
	free (ptr);
	free (code);
	free (inp);
	R_FREE (opst);
	r_cons_break_pop ();
	return hits;
}
