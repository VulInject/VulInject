isis_print(netdissect_options *ndo,
           const unsigned char *p, u_int length)
{
    const struct isis_common_header *isis_header;
    const struct isis_iih_lan_header *header_iih_lan;
    const struct isis_iih_ptp_header *header_iih_ptp;
    const struct isis_lsp_header *header_lsp;
    const struct isis_csnp_header *header_csnp;
    const struct isis_psnp_header *header_psnp;
    const struct isis_tlv_lsp *tlv_lsp;
    const struct isis_tlv_ptp_adj *tlv_ptp_adj;
    const struct isis_tlv_is_reach *tlv_is_reach;
    const struct isis_tlv_es_reach *tlv_es_reach;
    unsigned char version, pdu_version, fixed_len;
    unsigned char pdu_type, pdu_max_area, max_area, pdu_id_length, id_length, tlv_type, tlv_len, tlen, alen, prefix_len;
    u_int ext_is_len, ext_ip_len;
    unsigned char mt_len;
    unsigned char isis_subtlv_idrp;
    const unsigned char *optr, *pptr, *tptr;
    u_int packet_len;
    u_short pdu_len, key_id;
    u_int i,vendor_id, num_vals;
    unsigned char auth_type;
    unsigned char num_system_ids;
    int sigcheck;
    ndo->ndo_protocol = "isis";
    packet_len=length;
    optr = p; 
    isis_header = (const struct isis_common_header *)p;
    ND_TCHECK_SIZE(isis_header);
    if (length < ISIS_COMMON_HEADER_SIZE)
        goto trunc;
    pptr = p+(ISIS_COMMON_HEADER_SIZE);
    header_iih_lan = (const struct isis_iih_lan_header *)pptr;
    header_iih_ptp = (const struct isis_iih_ptp_header *)pptr;
    header_lsp = (const struct isis_lsp_header *)pptr;
    header_csnp = (const struct isis_csnp_header *)pptr;
    header_psnp = (const struct isis_psnp_header *)pptr;
    if (!ndo->ndo_eflag)
        ND_PRINT("IS-IS");
    version = GET_U_1(isis_header->version);
    if (version != ISIS_VERSION) {
	ND_PRINT("version %u packet not supported", version);
	return (0);
    }
    pdu_id_length = GET_U_1(isis_header->id_length);
    if ((pdu_id_length != SYSTEM_ID_LEN) && (pdu_id_length != 0)) {
	ND_PRINT("system ID length of %u is not supported",
	       pdu_id_length);
	return (0);
    }
    pdu_version = GET_U_1(isis_header->pdu_version);
    if (pdu_version != ISIS_VERSION) {
	ND_PRINT("version %u packet not supported", pdu_version);
	return (0);
    }
    fixed_len = GET_U_1(isis_header->fixed_len);
    if (length < fixed_len) {
	ND_PRINT("fixed header length %u > packet length %u", fixed_len, length);
	return (0);
    }
    if (fixed_len < ISIS_COMMON_HEADER_SIZE) {
	ND_PRINT("fixed header length %u < minimum header size %u", fixed_len, (u_int)ISIS_COMMON_HEADER_SIZE);
	return (0);
    }
    pdu_max_area = GET_U_1(isis_header->max_area);
    switch(pdu_max_area) {
    case 0:
	max_area = 3;	 
	break;
    case 255:
	ND_PRINT("bad packet -- 255 areas");
	return (0);
    default:
        max_area = pdu_max_area;
	break;
    }
    switch(pdu_id_length) {
    case 0:
        id_length = 6;	 
	break;
    case 1:              
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
        id_length = pdu_id_length;
        break;
    case 255:
        id_length = 0;   
	break;
    default:
        id_length = pdu_id_length;
        break;
    }
    if (id_length != 6 ) {
	ND_PRINT("bad packet -- illegal sys-ID length (%u)", id_length);
	return (0);
    }
    pdu_type = GET_U_1(isis_header->pdu_type);
    if (ndo->ndo_vflag == 0) {
        ND_PRINT("%s%s",
               ndo->ndo_eflag ? "" : ", ",
               tok2str(isis_pdu_values, "unknown PDU-Type %u", pdu_type));
    } else {
        ND_PRINT("%slength %u", ndo->ndo_eflag ? "" : ", ", length);
        ND_PRINT("\n\t%s, hlen: %u, v: %u, pdu-v: %u, sys-id-len: %u (%u), max-area: %u (%u)",
               tok2str(isis_pdu_values,
                       "unknown, type %u",
                       pdu_type),
               fixed_len,
               version,
               pdu_version,
               id_length,
               pdu_id_length,
               max_area,
               pdu_max_area);
        if (ndo->ndo_vflag > 1) {
            if (!print_unknown_data(ndo, optr, "\n\t", 8)) 
                return (0);                         
        }
    }
    switch (pdu_type) {
    case ISIS_PDU_L1_LAN_IIH:
    case ISIS_PDU_L2_LAN_IIH:
        if (fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)) {
            ND_PRINT(", bogus fixed header length %u should be %zu",
                     fixed_len, ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);
            return (0);
        }
        ND_TCHECK_SIZE(header_iih_lan);
        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)
            goto trunc;
        if (ndo->ndo_vflag == 0) {
            ND_PRINT(", src-id %s",
                      isis_print_id(ndo, header_iih_lan->source_id, SYSTEM_ID_LEN));
            ND_PRINT(", lan-id %s, prio %u",
                      isis_print_id(ndo, header_iih_lan->lan_id,NODE_ID_LEN),
                      GET_U_1(header_iih_lan->priority));
            ND_PRINT(", length %u", length);
            return (1);
        }
        pdu_len=GET_BE_U_2(header_iih_lan->pdu_len);
        if (packet_len>pdu_len) {
           packet_len=pdu_len; 
           length=pdu_len;
        }
        ND_PRINT("\n\t  source-id: %s,  holding time: %us, Flags: [%s]",
                  isis_print_id(ndo, header_iih_lan->source_id,SYSTEM_ID_LEN),
                  GET_BE_U_2(header_iih_lan->holding_time),
                  tok2str(isis_iih_circuit_type_values,
                          "unknown circuit type 0x%02x",
                          GET_U_1(header_iih_lan->circuit_type)));
        ND_PRINT("\n\t  lan-id:    %s, Priority: %u, PDU length: %u",
                  isis_print_id(ndo, header_iih_lan->lan_id, NODE_ID_LEN),
                  GET_U_1(header_iih_lan->priority) & ISIS_LAN_PRIORITY_MASK,
                  pdu_len);
        if (ndo->ndo_vflag > 1) {
            if (!print_unknown_data(ndo, pptr, "\n\t  ", ISIS_IIH_LAN_HEADER_SIZE))
                return (0);
        }
        INVALID_OR_DECREMENT(packet_len,ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);
        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);
        break;
    case ISIS_PDU_PTP_IIH:
        if (fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)) {
            ND_PRINT(", bogus fixed header length %u should be %zu",
                      fixed_len, ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE);
            return (0);
        }
        ND_TCHECK_SIZE(header_iih_ptp);
        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)
            goto trunc;
        if (ndo->ndo_vflag == 0) {
            ND_PRINT(", src-id %s", isis_print_id(ndo, header_iih_ptp->source_id, SYSTEM_ID_LEN));
            ND_PRINT(", length %u", length);
            return (1);
        }
        pdu_len=GET_BE_U_2(header_iih_ptp->pdu_len);
        if (packet_len>pdu_len) {
            packet_len=pdu_len; 
            length=pdu_len;
        }
        ND_PRINT("\n\t  source-id: %s, holding time: %us, Flags: [%s]",
                  isis_print_id(ndo, header_iih_ptp->source_id,SYSTEM_ID_LEN),
                  GET_BE_U_2(header_iih_ptp->holding_time),
                  tok2str(isis_iih_circuit_type_values,
                          "unknown circuit type 0x%02x",
                          GET_U_1(header_iih_ptp->circuit_type)));
        ND_PRINT("\n\t  circuit-id: 0x%02x, PDU length: %u",
                  GET_U_1(header_iih_ptp->circuit_id),
                  pdu_len);
        if (ndo->ndo_vflag > 1) {
            if (!print_unknown_data(ndo, pptr, "\n\t  ", ISIS_IIH_PTP_HEADER_SIZE))
                return (0);
        }
        INVALID_OR_DECREMENT(packet_len,ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE);
        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE);
        break;
    case ISIS_PDU_L1_LSP:
    case ISIS_PDU_L2_LSP:
        if (fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE)) {
            ND_PRINT(", bogus fixed header length %u should be %zu",
                   fixed_len, ISIS_LSP_HEADER_SIZE);
            return (0);
        }
        ND_TCHECK_SIZE(header_lsp);
        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE)
            goto trunc;
        if (ndo->ndo_vflag == 0) {
            ND_PRINT(", lsp-id %s, seq 0x%08x, lifetime %5us",
                      isis_print_id(ndo, header_lsp->lsp_id, LSP_ID_LEN),
                      GET_BE_U_4(header_lsp->sequence_number),
                      GET_BE_U_2(header_lsp->remaining_lifetime));
            ND_PRINT(", length %u", length);
            return (1);
        }
        pdu_len=GET_BE_U_2(header_lsp->pdu_len);
        if (packet_len>pdu_len) {
            packet_len=pdu_len; 
            length=pdu_len;
        }
        ND_PRINT("\n\t  lsp-id: %s, seq: 0x%08x, lifetime: %5us\n\t  chksum: 0x%04x",
               isis_print_id(ndo, header_lsp->lsp_id, LSP_ID_LEN),
               GET_BE_U_4(header_lsp->sequence_number),
               GET_BE_U_2(header_lsp->remaining_lifetime),
               GET_BE_U_2(header_lsp->checksum));
        osi_print_cksum(ndo, (const unsigned char *)header_lsp->lsp_id,
                        GET_BE_U_2(header_lsp->checksum),
                        12, length-12);
        ND_PRINT(", PDU length: %u, Flags: [ %s",
               pdu_len,
               ISIS_MASK_LSP_OL_BIT(header_lsp->typeblock) ? "Overload bit set, " : "");
        if (ISIS_MASK_LSP_ATT_BITS(header_lsp->typeblock)) {
            ND_PRINT("%s", ISIS_MASK_LSP_ATT_DEFAULT_BIT(header_lsp->typeblock) ? "default " : "");
            ND_PRINT("%s", ISIS_MASK_LSP_ATT_DELAY_BIT(header_lsp->typeblock) ? "delay " : "");
            ND_PRINT("%s", ISIS_MASK_LSP_ATT_EXPENSE_BIT(header_lsp->typeblock) ? "expense " : "");
            ND_PRINT("%s", ISIS_MASK_LSP_ATT_ERROR_BIT(header_lsp->typeblock) ? "error " : "");
            ND_PRINT("ATT bit set, ");
        }
        ND_PRINT("%s", ISIS_MASK_LSP_PARTITION_BIT(header_lsp->typeblock) ? "P bit set, " : "");
        ND_PRINT("%s ]", tok2str(isis_lsp_istype_values, "Unknown(0x%x)",
                  ISIS_MASK_LSP_ISTYPE_BITS(header_lsp->typeblock)));
        if (ndo->ndo_vflag > 1) {
            if (!print_unknown_data(ndo, pptr, "\n\t  ", ISIS_LSP_HEADER_SIZE))
                return (0);
        }
        INVALID_OR_DECREMENT(packet_len,ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE);
        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE);
        break;
    case ISIS_PDU_L1_CSNP:
    case ISIS_PDU_L2_CSNP:
        if (fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)) {
            ND_PRINT(", bogus fixed header length %u should be %zu",
                      fixed_len, ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE);
            return (0);
        }
        ND_TCHECK_SIZE(header_csnp);
        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)
            goto trunc;
        if (ndo->ndo_vflag == 0) {
            ND_PRINT(", src-id %s", isis_print_id(ndo, header_csnp->source_id, NODE_ID_LEN));
            ND_PRINT(", length %u", length);
            return (1);
        }
        pdu_len=GET_BE_U_2(header_csnp->pdu_len);
        if (packet_len>pdu_len) {
            packet_len=pdu_len; 
            length=pdu_len;
        }
        ND_PRINT("\n\t  source-id:    %s, PDU length: %u",
               isis_print_id(ndo, header_csnp->source_id, NODE_ID_LEN),
               pdu_len);
        ND_PRINT("\n\t  start lsp-id: %s",
               isis_print_id(ndo, header_csnp->start_lsp_id, LSP_ID_LEN));
        ND_PRINT("\n\t  end lsp-id:   %s",
               isis_print_id(ndo, header_csnp->end_lsp_id, LSP_ID_LEN));
        if (ndo->ndo_vflag > 1) {
            if (!print_unknown_data(ndo, pptr, "\n\t  ", ISIS_CSNP_HEADER_SIZE))
                return (0);
        }
        INVALID_OR_DECREMENT(packet_len,ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE);
        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE);
        break;
    case ISIS_PDU_L1_PSNP:
    case ISIS_PDU_L2_PSNP:
        if (fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)) {
            ND_PRINT("- bogus fixed header length %u should be %zu",
                   fixed_len, ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);
            return (0);
        }
        ND_TCHECK_SIZE(header_psnp);
        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)
            goto trunc;
        if (ndo->ndo_vflag == 0) {
            ND_PRINT(", src-id %s", isis_print_id(ndo, header_psnp->source_id, NODE_ID_LEN));
            ND_PRINT(", length %u", length);
            return (1);
        }
        pdu_len=GET_BE_U_2(header_psnp->pdu_len);
        if (packet_len>pdu_len) {
            packet_len=pdu_len; 
            length=pdu_len;
        }
        ND_PRINT("\n\t  source-id:    %s, PDU length: %u",
               isis_print_id(ndo, header_psnp->source_id, NODE_ID_LEN),
               pdu_len);
        if (ndo->ndo_vflag > 1) {
            if (!print_unknown_data(ndo, pptr, "\n\t  ", ISIS_PSNP_HEADER_SIZE))
                return (0);
        }
        INVALID_OR_DECREMENT(packet_len,ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);
        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);
        break;
    default:
        if (ndo->ndo_vflag == 0) {
            ND_PRINT(", length %u", length);
            return (1);
        }
	(void)print_unknown_data(ndo, pptr, "\n\t  ", length);
	return (0);
    }
    while (packet_len != 0) {
	ND_TCHECK_2(pptr);
	if (packet_len < 2)
	    goto trunc;
	tlv_type = GET_U_1(pptr);
	tlv_len = GET_U_1(pptr + 1);
	pptr += 2;
	packet_len -= 2;
        tlen = tlv_len; 
        tptr = pptr;
	ND_PRINT("\n\t    %s TLV #%u, length: %u",
               tok2str(isis_tlv_values,
                       "unknown",
                       tlv_type),
               tlv_type,
               tlv_len);
	if (packet_len < tlv_len)
	    goto trunc;
	switch (tlv_type) {
	case ISIS_TLV_AREA_ADDR:
	    while (tlen != 0) {
		alen = GET_U_1(tptr);
		tptr++;
		tlen--;
		if (tlen < alen)
		    goto tlv_trunc;
		ND_PRINT("\n\t      Area address (length: %u): %s",
                       alen,
                       GET_ISONSAP_STRING(tptr, alen));
		tptr += alen;
		tlen -= alen;
	    }
	    break;
	case ISIS_TLV_ISNEIGH:
	    while (tlen != 0) {
		if (tlen < MAC48_LEN)
		    goto tlv_trunc;
                ND_PRINT("\n\t      SNPA: %s", isis_print_id(ndo, tptr, MAC48_LEN));
                tlen -= MAC48_LEN;
                tptr += MAC48_LEN;
	    }
	    break;
        case ISIS_TLV_INSTANCE_ID:
            if (tlen < 4)
                goto tlv_trunc;
            num_vals = (tlen-2)/2;
            ND_PRINT("\n\t      Instance ID: %u, ITIDs(%u)%s ",
                     GET_BE_U_2(tptr), num_vals,
                     num_vals ? ":" : "");
            tptr += 2;
            tlen -= 2;
            for (i=0; i < num_vals; i++) {
                ND_PRINT("%u", GET_BE_U_2(tptr));
                if (i < (num_vals - 1)) {
                   ND_PRINT(", ");
                }
                tptr += 2;
                tlen -= 2;
            }
            break;
	case ISIS_TLV_PADDING:
	    break;
        case ISIS_TLV_MT_IS_REACH:
            mt_len = isis_print_mtid(ndo, tptr, "\n\t      ", tlen);
            if (mt_len == 0) 
                goto trunc;
            tptr+=mt_len;
            tlen-=mt_len;
            while (tlen != 0) {
                ext_is_len = isis_print_ext_is_reach(ndo, tptr, "\n\t      ", tlv_type, tlen);
                if (ext_is_len == 0) 
                    goto trunc;
                if (tlen < ext_is_len) {
                    ND_PRINT(" [remaining tlv length %u < %u]", tlen, ext_is_len);
                    nd_print_invalid(ndo);
                    break;
                }
                tlen-=(unsigned char)ext_is_len;
                tptr+=(unsigned char)ext_is_len;
            }
            break;
        case ISIS_TLV_IS_ALIAS_ID:
	    while (tlen != 0) {
	        ext_is_len = isis_print_ext_is_reach(ndo, tptr, "\n\t      ", tlv_type, tlen);
		if (ext_is_len == 0) 
	            goto trunc;
                if (tlen < ext_is_len) {
                    ND_PRINT(" [remaining tlv length %u < %u]", tlen, ext_is_len);
                    nd_print_invalid(ndo);
                    break;
                }
		tlen-=(unsigned char)ext_is_len;
		tptr+=(unsigned char)ext_is_len;
	    }
	    break;
        case ISIS_TLV_EXT_IS_REACH:
            while (tlen != 0) {
                ext_is_len = isis_print_ext_is_reach(ndo, tptr, "\n\t      ", tlv_type, tlen);
                if (ext_is_len == 0) 
                    goto trunc;
                if (tlen < ext_is_len) {
                    ND_PRINT(" [remaining tlv length %u < %u]", tlen, ext_is_len);
                    nd_print_invalid(ndo);
                    break;
                }
                tlen-=(unsigned char)ext_is_len;
                tptr+=(unsigned char)ext_is_len;
            }
            break;
        case ISIS_TLV_IS_REACH:
            if (tlen < 1)
                goto tlv_trunc;
            ND_PRINT("\n\t      %s",
                   tok2str(isis_is_reach_virtual_values,
                           "bogus virtual flag 0x%02x",
                           GET_U_1(tptr)));
	    tptr++;
	    tlen--;
	    tlv_is_reach = (const struct isis_tlv_is_reach *)tptr;
            while (tlen != 0) {
                if (tlen < sizeof(struct isis_tlv_is_reach))
                    goto tlv_trunc;
		ND_TCHECK_SIZE(tlv_is_reach);
		ND_PRINT("\n\t      IS Neighbor: %s",
		       isis_print_id(ndo, tlv_is_reach->neighbor_nodeid, NODE_ID_LEN));
		isis_print_metric_block(ndo, &tlv_is_reach->isis_metric_block);
		tlen -= sizeof(struct isis_tlv_is_reach);
		tlv_is_reach++;
	    }
            break;
        case ISIS_TLV_ESNEIGH:
	    tlv_es_reach = (const struct isis_tlv_es_reach *)tptr;
            while (tlen != 0) {
                if (tlen < sizeof(struct isis_tlv_es_reach))
                    goto tlv_trunc;
		ND_TCHECK_SIZE(tlv_es_reach);
		ND_PRINT("\n\t      ES Neighbor: %s",
                       isis_print_id(ndo, tlv_es_reach->neighbor_sysid, SYSTEM_ID_LEN));
		isis_print_metric_block(ndo, &tlv_es_reach->isis_metric_block);
		tlen -= sizeof(struct isis_tlv_es_reach);
		tlv_es_reach++;
	    }
            break;
	case ISIS_TLV_INT_IP_REACH:
	case ISIS_TLV_EXT_IP_REACH:
		if (!isis_print_tlv_ip_reach(ndo, pptr, "\n\t      ", tlv_len))
			return (1);
		break;
	case ISIS_TLV_EXTD_IP_REACH:
	    while (tlen != 0) {
                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, "\n\t      ", AFNUM_IP);
                if (ext_ip_len == 0) 
                    goto trunc;
                if (tlen < ext_ip_len) {
                    ND_PRINT(" [remaining tlv length %u < %u]", tlen, ext_ip_len);
                    nd_print_invalid(ndo);
                    break;
                }
                tlen-=(unsigned char)ext_ip_len;
                tptr+=(unsigned char)ext_ip_len;
            }
            break;
        case ISIS_TLV_MT_IP_REACH:
            mt_len = isis_print_mtid(ndo, tptr, "\n\t      ", tlen);
            if (mt_len == 0) { 
                goto trunc;
            }
            tptr+=mt_len;
            tlen-=mt_len;
            while (tlen != 0) {
                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, "\n\t      ", AFNUM_IP);
                if (ext_ip_len == 0) 
                    goto trunc;
                if (tlen < ext_ip_len) {
                    ND_PRINT(" [remaining tlv length %u < %u]", tlen, ext_ip_len);
                    nd_print_invalid(ndo);
                    break;
                }
                tlen-=(unsigned char)ext_ip_len;
                tptr+=(unsigned char)ext_ip_len;
            }
            break;
	case ISIS_TLV_IP6_REACH:
            while (tlen != 0) {
                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, "\n\t      ", AFNUM_IP6);
                if (ext_ip_len == 0) 
                    goto trunc;
                if (tlen < ext_ip_len) {
                    ND_PRINT(" [remaining tlv length %u < %u]", tlen, ext_ip_len);
                    nd_print_invalid(ndo);
                    break;
                }
                tlen-=(unsigned char)ext_ip_len;
                tptr+=(unsigned char)ext_ip_len;
            }
            break;
	case ISIS_TLV_MT_IP6_REACH:
            mt_len = isis_print_mtid(ndo, tptr, "\n\t      ", tlen);
            if (mt_len == 0) { 
                goto trunc;
            }
            tptr+=mt_len;
            tlen-=mt_len;
            while (tlen != 0) {
                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, "\n\t      ", AFNUM_IP6);
                if (ext_ip_len == 0) 
                    goto trunc;
                if (tlen < ext_ip_len) {
                    ND_PRINT(" [remaining tlv length %u < %u]", tlen, ext_ip_len);
                    nd_print_invalid(ndo);
                    break;
                }
                tlen-=(unsigned char)ext_ip_len;
                tptr+=(unsigned char)ext_ip_len;
            }
            break;
	case ISIS_TLV_IP6ADDR:
	    while (tlen != 0) {
                if (tlen < sizeof(nd_ipv6))
                    goto tlv_trunc;
                ND_PRINT("\n\t      IPv6 interface address: %s",
		       GET_IP6ADDR_STRING(tptr));
		tptr += sizeof(nd_ipv6);
		tlen -= sizeof(nd_ipv6);
	    }
	    break;
	case ISIS_TLV_AUTH:
	    if (tlen < 1)
	        goto tlv_trunc;
	    auth_type = GET_U_1(tptr);
	    tptr++;
	    tlen--;
            ND_PRINT("\n\t      %s: ",
                   tok2str(isis_subtlv_auth_values,
                           "unknown Authentication type 0x%02x",
                           auth_type));
	    switch (auth_type) {
	    case ISIS_SUBTLV_AUTH_SIMPLE:
		nd_printjnp(ndo, tptr, tlen);
		break;
	    case ISIS_SUBTLV_AUTH_MD5:
		for(i=0;i<tlen;i++) {
		    ND_PRINT("%02x", GET_U_1(tptr + i));
		}
		if (tlen != ISIS_SUBTLV_AUTH_MD5_LEN)
                    ND_PRINT(", (invalid subTLV) ");
                sigcheck = signature_verify(ndo, optr, length, tptr,
                                            isis_clear_checksum_lifetime,
                                            header_lsp);
                ND_PRINT(" (%s)", tok2str(signature_check_values, "Unknown", sigcheck));
		break;
            case ISIS_SUBTLV_AUTH_GENERIC:
                if (tlen < 2)
                    goto tlv_trunc;
                key_id = GET_BE_U_2(tptr);
                ND_PRINT("%u, password: ", key_id);
                tptr += 2;
                tlen -= 2;
                for(i=0;i<tlen;i++) {
                    ND_PRINT("%02x", GET_U_1(tptr + i));
                }
                break;
	    case ISIS_SUBTLV_AUTH_PRIVATE:
	    default:
		if (!print_unknown_data(ndo, tptr, "\n\t\t  ", tlen))
		    return(0);
		break;
	    }
	    break;
	case ISIS_TLV_PTP_ADJ:
	    tlv_ptp_adj = (const struct isis_tlv_ptp_adj *)tptr;
	    if(tlen>=1) {
		ND_PRINT("\n\t      Adjacency State: %s (%u)",
		       tok2str(isis_ptp_adjacency_values, "unknown", GET_U_1(tptr)),
		       GET_U_1(tptr));
		tlen--;
	    }
	    if(tlen>sizeof(tlv_ptp_adj->extd_local_circuit_id)) {
		ND_PRINT("\n\t      Extended Local circuit-ID: 0x%08x",
		       GET_BE_U_4(tlv_ptp_adj->extd_local_circuit_id));
		tlen-=sizeof(tlv_ptp_adj->extd_local_circuit_id);
	    }
	    if(tlen>=SYSTEM_ID_LEN) {
		ND_TCHECK_LEN(tlv_ptp_adj->neighbor_sysid, SYSTEM_ID_LEN);
		ND_PRINT("\n\t      Neighbor System-ID: %s",
		       isis_print_id(ndo, tlv_ptp_adj->neighbor_sysid, SYSTEM_ID_LEN));
		tlen-=SYSTEM_ID_LEN;
	    }
	    if(tlen>=sizeof(tlv_ptp_adj->neighbor_extd_local_circuit_id)) {
		ND_PRINT("\n\t      Neighbor Extended Local circuit-ID: 0x%08x",
		       GET_BE_U_4(tlv_ptp_adj->neighbor_extd_local_circuit_id));
	    }
	    break;
	case ISIS_TLV_PROTOCOLS:
	    ND_PRINT("\n\t      NLPID(s): ");
	    while (tlen != 0) {
		ND_PRINT("%s (0x%02x)",
                       tok2str(nlpid_values,
                               "unknown",
                               GET_U_1(tptr)),
                       GET_U_1(tptr));
		if (tlen>1) 
		    ND_PRINT(", ");
                tptr++;
                tlen--;
	    }
	    break;
        case ISIS_TLV_MT_PORT_CAP:
        {
            if (tlen < 2)
                goto tlv_trunc;
            ND_PRINT("\n\t       RES: %u, MTID(s): %u",
                    (GET_BE_U_2(tptr) >> 12),
                    (GET_BE_U_2(tptr) & 0x0fff));
            tptr += 2;
            tlen -= 2;
            if (tlen)
                isis_print_mt_port_cap_subtlv(ndo, tptr, tlen);
            break;
        }
        case ISIS_TLV_MT_CAPABILITY:
            if (tlen < 2)
                goto tlv_trunc;
            ND_PRINT("\n\t      O: %u, RES: %u, MTID(s): %u",
                      (GET_BE_U_2(tptr) >> 15) & 0x01,
                      (GET_BE_U_2(tptr) >> 12) & 0x07,
                      GET_BE_U_2(tptr) & 0x0fff);
            tptr += 2;
            tlen -= 2;
            if (tlen)
                isis_print_mt_capability_subtlv(ndo, tptr, tlen);
            break;
	case ISIS_TLV_TE_ROUTER_ID:
	    if (tlen < sizeof(nd_ipv4))
	        goto tlv_trunc;
	    ND_PRINT("\n\t      Traffic Engineering Router ID: %s", GET_IPADDR_STRING(pptr));
	    break;
	case ISIS_TLV_IPADDR:
	    while (tlen != 0) {
                if (tlen < sizeof(nd_ipv4))
                    goto tlv_trunc;
		ND_PRINT("\n\t      IPv4 interface address: %s", GET_IPADDR_STRING(tptr));
		tptr += sizeof(nd_ipv4);
		tlen -= sizeof(nd_ipv4);
	    }
	    break;
	case ISIS_TLV_HOSTNAME:
	    ND_PRINT("\n\t      Hostname: ");
	    nd_printjnp(ndo, tptr, tlen);
	    break;
	case ISIS_TLV_SHARED_RISK_GROUP:
	    if (tlen < NODE_ID_LEN)
	        break;
	    ND_TCHECK_LEN(tptr, NODE_ID_LEN);
	    ND_PRINT("\n\t      IS Neighbor: %s", isis_print_id(ndo, tptr, NODE_ID_LEN));
	    tptr+=NODE_ID_LEN;
	    tlen-=NODE_ID_LEN;
	    if (tlen < 1)
	        break;
	    ND_PRINT(", Flags: [%s]",
                     ISIS_MASK_TLV_SHARED_RISK_GROUP(GET_U_1(tptr)) ? "numbered" : "unnumbered");
	    tptr++;
	    tlen--;
	    if (tlen < sizeof(nd_ipv4))
	        break;
	    ND_PRINT("\n\t      IPv4 interface address: %s", GET_IPADDR_STRING(tptr));
	    tptr+=sizeof(nd_ipv4);
	    tlen-=sizeof(nd_ipv4);
	    if (tlen < sizeof(nd_ipv4))
	        break;
	    ND_PRINT("\n\t      IPv4 neighbor address: %s", GET_IPADDR_STRING(tptr));
	    tptr+=sizeof(nd_ipv4);
	    tlen-=sizeof(nd_ipv4);
	    while (tlen != 0) {
		if (tlen < 4)
		    goto tlv_trunc;
                ND_PRINT("\n\t      Link-ID: 0x%08x", GET_BE_U_4(tptr));
                tptr+=4;
                tlen-=4;
	    }
	    break;
	case ISIS_TLV_LSP:
	    tlv_lsp = (const struct isis_tlv_lsp *)tptr;
	    while (tlen != 0) {
		if (tlen < sizeof(struct isis_tlv_lsp))
		    goto tlv_trunc;
		ND_TCHECK_1(tlv_lsp->lsp_id + LSP_ID_LEN - 1);
		ND_PRINT("\n\t      lsp-id: %s",
                       isis_print_id(ndo, tlv_lsp->lsp_id, LSP_ID_LEN));
		ND_PRINT(", seq: 0x%08x",
                         GET_BE_U_4(tlv_lsp->sequence_number));
		ND_PRINT(", lifetime: %5ds",
                         GET_BE_U_2(tlv_lsp->remaining_lifetime));
		ND_PRINT(", chksum: 0x%04x", GET_BE_U_2(tlv_lsp->checksum));
		tlen-=sizeof(struct isis_tlv_lsp);
		tlv_lsp++;
	    }
	    break;
	case ISIS_TLV_CHECKSUM:
	    if (tlen < ISIS_TLV_CHECKSUM_MINLEN)
	        break;
	    ND_TCHECK_LEN(tptr, ISIS_TLV_CHECKSUM_MINLEN);
	    ND_PRINT("\n\t      checksum: 0x%04x ", GET_BE_U_2(tptr));
            osi_print_cksum(ndo, optr, GET_BE_U_2(tptr), (int)(tptr-optr),
                            length);
	    break;
	case ISIS_TLV_POI:
	    if (tlen < 1)
	        goto tlv_trunc;
	    num_system_ids = GET_U_1(tptr);
	    tptr++;
	    tlen--;
	    if (num_system_ids == 0) {
		ND_PRINT(" No system IDs supplied");
	    } else {
		if (tlen < SYSTEM_ID_LEN)
		    goto tlv_trunc;
		ND_TCHECK_LEN(tptr, SYSTEM_ID_LEN);
		ND_PRINT("\n\t      Purge Originator System-ID: %s",
		       isis_print_id(ndo, tptr, SYSTEM_ID_LEN));
		tptr += SYSTEM_ID_LEN;
		tlen -= SYSTEM_ID_LEN;
		if (num_system_ids > 1) {
		    if (tlen < SYSTEM_ID_LEN)
			goto tlv_trunc;
		    ND_TCHECK_LEN(tptr, SYSTEM_ID_LEN);
		    ND_TCHECK_LEN(tptr, 2 * SYSTEM_ID_LEN + 1);
		    ND_PRINT("\n\t      Received from System-ID: %s",
			   isis_print_id(ndo, tptr, SYSTEM_ID_LEN));
		}
	    }
	    break;
	case ISIS_TLV_MT_SUPPORTED:
	    while (tlen != 0) {
		if (tlen!=1) {
                    mt_len = isis_print_mtid(ndo, tptr, "\n\t      ", tlen);
                    if (mt_len == 0) 
                        goto trunc;
                    tptr+=mt_len;
                    tlen-=mt_len;
		} else {
		    ND_PRINT("\n\t      invalid MT-ID");
		    break;
		}
	    }
	    break;
	case ISIS_TLV_RESTART_SIGNALING:
            if (tlen < ISIS_TLV_RESTART_SIGNALING_FLAGLEN)
                break;
            ND_TCHECK_LEN(tptr, ISIS_TLV_RESTART_SIGNALING_FLAGLEN);
            ND_PRINT("\n\t      Flags [%s]",
                   bittok2str(isis_restart_flag_values, "none", GET_U_1(tptr)));
            tptr+=ISIS_TLV_RESTART_SIGNALING_FLAGLEN;
            tlen-=ISIS_TLV_RESTART_SIGNALING_FLAGLEN;
            if (tlen == 0)
                break;
            if (tlen < ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN)
                break;
            ND_TCHECK_LEN(tptr, ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN);
            ND_PRINT(", Remaining holding time %us", GET_BE_U_2(tptr));
            tptr+=ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN;
            tlen-=ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN;
            if (tlen == SYSTEM_ID_LEN) {
                    ND_TCHECK_LEN(tptr, SYSTEM_ID_LEN);
                    ND_PRINT(", for %s", isis_print_id(ndo, tptr,SYSTEM_ID_LEN));
            }
	    break;
        case ISIS_TLV_IDRP_INFO:
	    if (tlen < 1)
	        break;
            isis_subtlv_idrp = GET_U_1(tptr);
            ND_PRINT("\n\t      Inter-Domain Information Type: %s",
                   tok2str(isis_subtlv_idrp_values,
                           "Unknown (0x%02x)",
                           isis_subtlv_idrp));
            tptr++;
            tlen--;
            switch (isis_subtlv_idrp) {
            case ISIS_SUBTLV_IDRP_ASN:
                if (tlen < 2)
                    goto tlv_trunc;
                ND_PRINT("AS Number: %u", GET_BE_U_2(tptr));
                break;
            case ISIS_SUBTLV_IDRP_LOCAL:
            case ISIS_SUBTLV_IDRP_RES:
            default:
                if (!print_unknown_data(ndo, tptr, "\n\t      ", tlen))
                    return(0);
                break;
            }
            break;
        case ISIS_TLV_LSP_BUFFERSIZE:
	    if (tlen < 2)
	        break;
            ND_PRINT("\n\t      LSP Buffersize: %u", GET_BE_U_2(tptr));
            break;
        case ISIS_TLV_PART_DIS:
            while (tlen != 0) {
                if (tlen < SYSTEM_ID_LEN)
                    goto tlv_trunc;
                ND_TCHECK_LEN(tptr, SYSTEM_ID_LEN);
                ND_PRINT("\n\t      %s", isis_print_id(ndo, tptr, SYSTEM_ID_LEN));
                tptr+=SYSTEM_ID_LEN;
                tlen-=SYSTEM_ID_LEN;
            }
            break;
        case ISIS_TLV_PREFIX_NEIGH:
	    if (tlen < sizeof(struct isis_metric_block))
	        break;
            ND_TCHECK_LEN(tptr, sizeof(struct isis_metric_block));
            ND_PRINT("\n\t      Metric Block");
            isis_print_metric_block(ndo, (const struct isis_metric_block *)tptr);
            tptr+=sizeof(struct isis_metric_block);
            tlen-=sizeof(struct isis_metric_block);
            while (tlen != 0) {
                prefix_len=GET_U_1(tptr); 
                tptr++;
                tlen--;
                if (prefix_len < 2) {
                    ND_PRINT("\n\t\tAddress: prefix length %u < 2", prefix_len);
                    break;
                }
                if (tlen < prefix_len/2)
                    break;
                ND_PRINT("\n\t\tAddress: %s/%u",
                       GET_ISONSAP_STRING(tptr, prefix_len / 2), prefix_len * 4);
                tptr+=prefix_len/2;
                tlen-=prefix_len/2;
            }
            break;
        case ISIS_TLV_IIH_SEQNR:
	    if (tlen < 4)
	        break;
            ND_PRINT("\n\t      Sequence number: %u", GET_BE_U_4(tptr));
            break;
        case ISIS_TLV_ROUTER_CAPABILITY:
            if (tlen < 5) {
                ND_PRINT(" [object length %u < 5]", tlen);
                nd_print_invalid(ndo);
                break;
            }
            ND_PRINT("\n\t      Router-ID %s", GET_IPADDR_STRING(tptr));
            ND_PRINT(", Flags [%s]",
		     bittok2str(isis_tlv_router_capability_flags, "none", GET_U_1(tptr+4)));
	    if (tlen > 5) {
		isis_print_router_cap_subtlv(ndo, tptr+5, tlen-5);
	    }
            break;
        case ISIS_TLV_VENDOR_PRIVATE:
	    if (tlen < 3)
	        break;
            vendor_id = GET_BE_U_3(tptr);
            ND_PRINT("\n\t      Vendor: %s (%u)",
                   tok2str(oui_values, "Unknown", vendor_id),
                   vendor_id);
            tptr+=3;
            tlen-=3;
            if (tlen != 0) 
                if (!print_unknown_data(ndo, tptr, "\n\t\t", tlen))
                    return(0);
            break;
        case ISIS_TLV_DECNET_PHASE4:
        case ISIS_TLV_LUCENT_PRIVATE:
        case ISIS_TLV_IPAUTH:
        case ISIS_TLV_NORTEL_PRIVATE1:
        case ISIS_TLV_NORTEL_PRIVATE2:
	default:
		if (ndo->ndo_vflag <= 1) {
			if (!print_unknown_data(ndo, pptr, "\n\t\t", tlv_len))
				return(0);
		}
		break;
	}
tlv_trunc:
	if (ndo->ndo_vflag> 1) {
		if (!print_unknown_data(ndo, pptr, "\n\t      ", tlv_len))
			return(0);
	}
	pptr += tlv_len;
	packet_len -= tlv_len;
    }
    if (packet_len != 0) {
	ND_PRINT("\n\t      %u straggler bytes", packet_len);
    }
    return (1);
trunc:
    nd_print_trunc(ndo);
    return (1);
}
