void VM_Yield(ValkeyModuleCtx *ctx, int flags, const char *busy_reply) {
    static int yield_nesting = 0;
    /* Avoid nested calls to VM_Yield */
    if (yield_nesting)
        return;
    yield_nesting++;
    long long now = getMonotonicUs();
	if ((unsigned int)now >= ctx->next_yield_time)
        /* In loading mode, there's no need to handle busy_module_yield_reply,
         * and busy_module_yield_flags, since the server is anyway rejecting all
         * commands with -LOADING. */
        if (server.loading) {
            /* Let the server process events */
            processEventsWhileBlocked();
        } else {
            const char *prev_busy_module_yield_reply = server.busy_module_yield_reply;
            server.busy_module_yield_reply = busy_reply;
            /* start the blocking operation if not already started. */
            if (!server.busy_module_yield_flags) {
                server.busy_module_yield_flags = BUSY_MODULE_YIELD_EVENTS;
                blockingOperationStarts();
                if (server.current_client)
                    protectClient(server.current_client);
            }
            if (flags & VALKEYMODULE_YIELD_FLAG_CLIENTS)
                server.busy_module_yield_flags |= BUSY_MODULE_YIELD_CLIENTS;
            /* Let the server process events */
            if (!pthread_equal(server.main_thread_id, pthread_self())) {
                /* If we are not in the main thread, we defer event loop processing to the main thread
                 * after the main thread enters acquiring GIL state in order to protect the event
                 * loop (ae.c) and avoid potential race conditions. */
                int acquiring;
                atomicGet(server.module_gil_acquring, acquiring);
                if (!acquiring) {
                    /* If the main thread has not yet entered the acquiring GIL state,
                     * we attempt to wake it up and exit without waiting for it to
                     * acquire the GIL. This avoids blocking the caller, allowing them to
                     * continue with unfinished tasks before the next yield.
                     * We assume the caller keeps the GIL locked. */
                    if (write(server.module_pipe[1],"A",1) != 1) {
                        /* Ignore the error, this is best-effort. */
                    }
                } else {
                    /* Release the GIL, yielding CPU to give the main thread an opportunity to start
                     * event processing, and then acquire the GIL again until the main thread releases it. */
                    moduleReleaseGIL();
                    sched_yield();
                    moduleAcquireGIL();
                }
            } else {
                /* If we are in the main thread, we can safely process events. */
                processEventsWhileBlocked();
            }
            server.busy_module_yield_reply = prev_busy_module_yield_reply;
            /* Possibly restore the previous flags in case of two nested contexts
             * that use this API with different flags, but keep the first bit
             * (PROCESS_EVENTS) set, so we know to call blockingOperationEnds on time. */
            server.busy_module_yield_flags &= ~BUSY_MODULE_YIELD_CLIENTS;
        }
        /* decide when the next event should fire. */
        ctx->next_yield_time = now + 1000000 / server.hz;
    }
