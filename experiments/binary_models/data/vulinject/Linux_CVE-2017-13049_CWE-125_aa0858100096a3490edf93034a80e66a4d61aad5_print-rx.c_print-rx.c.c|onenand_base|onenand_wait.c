static int onenand_wait(struct mtd_info *mtd, int state)
{
	struct onenand_chip * this = mtd->priv;
	unsigned int timeout;
	unsigned int flags = ONENAND_INT_MASTER;
	unsigned int interrupt = 0;
	unsigned int ctrl;
	timeout = jiffies + msecs_to_jiffies(20);
	while (time_before(jiffies, timeout)) {
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
		if (interrupt & flags)
			break;
		if (state != FL_READING && state != FL_PREPARING_ERASE)
			cond_resched();
	}
	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
	if (interrupt & ONENAND_INT_READ) {
		if (ecc) {
			if (ecc & ONENAND_ECC_2BIT_ALL) {
				printk(KERN_ERR "%s: ECC error = 0x%04x\n",
					__func__, ecc);
				mtd->ecc_stats.failed++;
				return -EBADMSG;
			} else if (ecc & ONENAND_ECC_1BIT_ALL) {
				printk(KERN_DEBUG "%s: correctable ECC error = 0x%04x\n",
					__func__, ecc);
				mtd->ecc_stats.corrected++;
			}
		}
	} else if (state == FL_READING) {
		printk(KERN_ERR "%s: read timeout! ctrl=0x%04x intr=0x%04x\n",
			__func__, ctrl, interrupt);
		return -EIO;
	}
	if (state == FL_PREPARING_ERASE && !(interrupt & ONENAND_INT_ERASE)) {
		printk(KERN_ERR "%s: mb erase timeout! ctrl=0x%04x intr=0x%04x\n",
		       __func__, ctrl, interrupt);
		return -EIO;
	}
	if (!(interrupt & ONENAND_INT_MASTER)) {
		printk(KERN_ERR "%s: timeout! ctrl=0x%04x intr=0x%04x\n",
		       __func__, ctrl, interrupt);
		return -EIO;
	}
	if (ctrl & ONENAND_CTRL_ERROR) {
		printk(KERN_ERR "%s: controller error = 0x%04x\n",
			__func__, ctrl);
		if (ctrl & ONENAND_CTRL_LOCK)
			printk(KERN_ERR "%s: it's locked error.\n", __func__);
		return -EIO;
	}
	return 0;
}
