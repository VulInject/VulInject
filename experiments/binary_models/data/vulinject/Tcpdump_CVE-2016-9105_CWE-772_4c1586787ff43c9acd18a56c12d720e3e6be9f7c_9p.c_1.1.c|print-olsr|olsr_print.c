olsr_print(netdissect_options *ndo,
           const u_char *pptr, u_int length, int is_ipv6)
{
    union {
        const struct olsr_common *common;
        const struct olsr_msg4 *msg4;
        const struct olsr_msg6 *msg6;
        const struct olsr_hello *hello;
        const struct olsr_hello_link *hello_link;
        const struct olsr_tc *tc;
        const struct olsr_hna4 *hna;
    } ptr;
    u_int msg_type, msg_len, msg_tlen, hello_len;
    unsigned short name_entry_type, name_entry_len;
    u_int name_entry_padding;
    unsigned char link_type, neighbor_type;
    const u_char *tptr, *msg_data;
    ndo->ndo_protocol = "olsr";
    tptr = pptr;
    nd_print_protocol_caps(ndo);
    ND_PRINT("v%u", (is_ipv6) ? 6 : 4);
    ND_ICHECKMSG_ZU("packet length", length, <, sizeof(struct olsr_common));
    ptr.common = (const struct olsr_common *)tptr;
    length = ND_MIN(length, GET_BE_U_2(ptr.common->packet_len));
    ND_PRINT(", seq 0x%04x, length %u",
            GET_BE_U_2(ptr.common->packet_seq),
            length);
    tptr += sizeof(struct olsr_common);
    if (ndo->ndo_vflag < 1) {
        return;
    }
    while (tptr < (pptr+length)) {
        union
        {
            const struct olsr_msg4 *v4;
            const struct olsr_msg6 *v6;
        } msgptr;
        int msg_len_valid = 0;
        if (is_ipv6) {
            ND_TCHECK_LEN(tptr, sizeof(struct olsr_msg6));
            msgptr.v6 = (const struct olsr_msg6 *) tptr;
            msg_type = GET_U_1(msgptr.v6->msg_type);
            msg_len = GET_BE_U_2(msgptr.v6->msg_len);
            if ((msg_len >= sizeof (struct olsr_msg6))
                    && (msg_len <= length))
                msg_len_valid = 1;
            if (msg_type == 0 || msg_len == 0) {
                return;
            }
            ND_PRINT("\n\t%s Message (%#04x), originator %s, ttl %u, hop %u"
                    "\n\t  vtime %.3fs, msg-seq 0x%04x, length %u%s",
                    tok2str(olsr_msg_values, "Unknown", msg_type),
                    msg_type, GET_IP6ADDR_STRING(msgptr.v6->originator),
                    GET_U_1(msgptr.v6->ttl),
                    GET_U_1(msgptr.v6->hopcount),
                    ME_TO_DOUBLE(GET_U_1(msgptr.v6->vtime)),
                    GET_BE_U_2(msgptr.v6->msg_seq),
                    msg_len, (msg_len_valid == 0) ? " (invalid)" : "");
            if (!msg_len_valid) {
                return;
            }
            msg_tlen = msg_len - sizeof(struct olsr_msg6);
            msg_data = tptr + sizeof(struct olsr_msg6);
        } else {	
            ND_TCHECK_LEN(tptr, sizeof(struct olsr_msg4));
            msgptr.v4 = (const struct olsr_msg4 *) tptr;
            msg_type = GET_U_1(msgptr.v4->msg_type);
            msg_len = GET_BE_U_2(msgptr.v4->msg_len);
            if ((msg_len >= sizeof (struct olsr_msg4))
                    && (msg_len <= length))
                msg_len_valid = 1;
            if (msg_type == 0 || msg_len == 0) {
                return;
            }
            ND_PRINT("\n\t%s Message (%#04x), originator %s, ttl %u, hop %u"
                    "\n\t  vtime %.3fs, msg-seq 0x%04x, length %u%s",
                    tok2str(olsr_msg_values, "Unknown", msg_type),
                    msg_type, GET_IPADDR_STRING(msgptr.v4->originator),
                    GET_U_1(msgptr.v4->ttl),
                    GET_U_1(msgptr.v4->hopcount),
                    ME_TO_DOUBLE(GET_U_1(msgptr.v4->vtime)),
                    GET_BE_U_2(msgptr.v4->msg_seq),
                    msg_len, (msg_len_valid == 0) ? " (invalid)" : "");
            if (!msg_len_valid) {
                return;
            }
            msg_tlen = msg_len - sizeof(struct olsr_msg4);
            msg_data = tptr + sizeof(struct olsr_msg4);
        }
        switch (msg_type) {
        case OLSR_HELLO_MSG:
        case OLSR_HELLO_LQ_MSG:
            ND_ICHECKMSG_ZU("message length", msg_tlen, <,
                            sizeof(struct olsr_hello));
            ptr.hello = (const struct olsr_hello *)msg_data;
            ND_PRINT("\n\t  hello-time %.3fs, MPR willingness %u",
                   ME_TO_DOUBLE(GET_U_1(ptr.hello->htime)),
                   GET_U_1(ptr.hello->will));
            msg_data += sizeof(struct olsr_hello);
            msg_tlen -= sizeof(struct olsr_hello);
            while (msg_tlen >= sizeof(struct olsr_hello_link)) {
                int hello_len_valid = 0;
                ND_TCHECK_LEN(msg_data, sizeof(struct olsr_hello_link));
                ptr.hello_link = (const struct olsr_hello_link *)msg_data;
                hello_len = GET_BE_U_2(ptr.hello_link->len);
                link_type = OLSR_EXTRACT_LINK_TYPE(GET_U_1(ptr.hello_link->link_code));
                neighbor_type = OLSR_EXTRACT_NEIGHBOR_TYPE(GET_U_1(ptr.hello_link->link_code));
                if ((hello_len <= msg_tlen)
                        && (hello_len >= sizeof(struct olsr_hello_link)))
                    hello_len_valid = 1;
                ND_PRINT("\n\t    link-type %s, neighbor-type %s, len %u%s",
                       tok2str(olsr_link_type_values, "Unknown", link_type),
                       tok2str(olsr_neighbor_type_values, "Unknown", neighbor_type),
                       hello_len,
                       (hello_len_valid == 0) ? " (invalid)" : "");
                if (hello_len_valid == 0)
                    break;
                msg_data += sizeof(struct olsr_hello_link);
                msg_tlen -= sizeof(struct olsr_hello_link);
                hello_len -= sizeof(struct olsr_hello_link);
                if (msg_type == OLSR_HELLO_MSG) {
                    olsr_print_neighbor(ndo, msg_data, hello_len);
                } else {
                    if (is_ipv6) {
                        olsr_print_lq_neighbor6(ndo, msg_data, hello_len);
                    } else {
                        olsr_print_lq_neighbor4(ndo, msg_data, hello_len);
                    }
                }
                msg_data += hello_len;
                msg_tlen -= hello_len;
            }
            break;
        case OLSR_TC_MSG:
        case OLSR_TC_LQ_MSG:
            ND_ICHECKMSG_ZU("message length", msg_tlen, <,
                            sizeof(struct olsr_tc));
            ND_TCHECK_LEN(msg_data, sizeof(struct olsr_tc));
            ptr.tc = (const struct olsr_tc *)msg_data;
            ND_PRINT("\n\t    advertised neighbor seq 0x%04x",
                   GET_BE_U_2(ptr.tc->ans_seq));
            msg_data += sizeof(struct olsr_tc);
            msg_tlen -= sizeof(struct olsr_tc);
            if (msg_type == OLSR_TC_MSG) {
                olsr_print_neighbor(ndo, msg_data, msg_tlen);
            } else {
                if (is_ipv6) {
                    olsr_print_lq_neighbor6(ndo, msg_data, msg_tlen);
                } else {
                    olsr_print_lq_neighbor4(ndo, msg_data, msg_tlen);
                }
            }
            break;
        case OLSR_MID_MSG:
        {
            u_int addr_size = (u_int)sizeof(nd_ipv4);
            if (is_ipv6)
                addr_size = (u_int)sizeof(nd_ipv6);
            while (msg_tlen >= addr_size) {
                ND_TCHECK_LEN(msg_data, addr_size);
                ND_PRINT("\n\t  interface address %s",
                        is_ipv6 ? GET_IP6ADDR_STRING(msg_data) :
                        GET_IPADDR_STRING(msg_data));
                msg_data += addr_size;
                msg_tlen -= addr_size;
            }
            break;
        }
        case OLSR_HNA_MSG:
            if (is_ipv6) {
                int i = 0;
                ND_PRINT("\n\t  Advertised networks (total %u)",
                        (unsigned int) (msg_tlen / sizeof(struct olsr_hna6)));
                while (msg_tlen >= sizeof(struct olsr_hna6)) {
                    const struct olsr_hna6 *hna6;
                    ND_TCHECK_LEN(msg_data, sizeof(struct olsr_hna6));
                    hna6 = (const struct olsr_hna6 *)msg_data;
                    ND_PRINT("\n\t    #%i: %s/%u",
                            i, GET_IP6ADDR_STRING(hna6->network),
                            mask62plen (hna6->mask));
                    msg_data += sizeof(struct olsr_hna6);
                    msg_tlen -= sizeof(struct olsr_hna6);
                }
            } else {
                int col = 0;
                ND_PRINT("\n\t  Advertised networks (total %u)",
                        (unsigned int) (msg_tlen / sizeof(struct olsr_hna4)));
                while (msg_tlen >= sizeof(struct olsr_hna4)) {
                    ND_TCHECK_LEN(msg_data, sizeof(struct olsr_hna4));
                    ptr.hna = (const struct olsr_hna4 *)msg_data;
                    if (!ptr.hna->network[0] && !ptr.hna->network[1] &&
                        !ptr.hna->network[2] && !ptr.hna->network[3] &&
                        !ptr.hna->mask[GW_HNA_PAD] &&
                        ptr.hna->mask[GW_HNA_FLAGS]) {
                            ND_PRINT("%sSmart-Gateway:%s%s%s%s%s %u/%u",
                                col == 0 ? "\n\t    " : ", ", 
                                (ptr.hna->mask[GW_HNA_FLAGS] &
                                 GW_HNA_FLAG_LINKSPEED) ? " LINKSPEED" : "",
                                (ptr.hna->mask[GW_HNA_FLAGS] &
                                 GW_HNA_FLAG_IPV4) ? " IPV4" : "",
                                (ptr.hna->mask[GW_HNA_FLAGS] &
                                 GW_HNA_FLAG_IPV4_NAT) ? " IPV4-NAT" : "",
                                (ptr.hna->mask[GW_HNA_FLAGS] &
                                 GW_HNA_FLAG_IPV6) ? " IPV6" : "",
                                (ptr.hna->mask[GW_HNA_FLAGS] &
                                 GW_HNA_FLAG_IPV6PREFIX) ? " IPv6-PREFIX" : "",
                                (ptr.hna->mask[GW_HNA_FLAGS] &
                                 GW_HNA_FLAG_LINKSPEED) ?
                                 deserialize_gw_speed(ptr.hna->mask[GW_HNA_UPLINK]) : 0,
                                (ptr.hna->mask[GW_HNA_FLAGS] &
                                 GW_HNA_FLAG_LINKSPEED) ?
                                 deserialize_gw_speed(ptr.hna->mask[GW_HNA_DOWNLINK]) : 0
                                );
                    } else {
                        ND_PRINT("%s%s/%u",
                                col == 0 ? "\n\t    " : ", ",
                                GET_IPADDR_STRING(ptr.hna->network),
                                mask2plen(GET_BE_U_4(ptr.hna->mask)));
                    }
                    msg_data += sizeof(struct olsr_hna4);
                    msg_tlen -= sizeof(struct olsr_hna4);
                    col = (col + 1) % 4;
                }
            }
            break;
        case OLSR_NAMESERVICE_MSG:
        {
            u_int name_entries;
            u_int addr_size;
            int name_entries_valid;
            u_int i;
            ND_ICHECKMSG_U("message length", msg_tlen, <, 4);
            name_entries = GET_BE_U_2(msg_data + 2);
            addr_size = 4;
            if (is_ipv6)
                addr_size = 16;
            name_entries_valid = 0;
            if ((name_entries > 0)
                    && ((name_entries * (4 + addr_size)) <= msg_tlen))
                name_entries_valid = 1;
            ND_PRINT("\n\t  Version %u, Entries %u%s",
                   GET_BE_U_2(msg_data),
                   name_entries, (name_entries_valid == 0) ? " (invalid)" : "");
            if (name_entries_valid == 0)
                break;
            msg_data += 4;
            msg_tlen -= 4;
            for (i = 0; i < name_entries; i++) {
                int name_entry_len_valid = 0;
                if (msg_tlen < 4)
                    break;
                name_entry_type = GET_BE_U_2(msg_data);
                name_entry_len = GET_BE_U_2(msg_data + 2);
                msg_data += 4;
                msg_tlen -= 4;
                if ((name_entry_len > 0) && ((addr_size + name_entry_len) <= msg_tlen))
                    name_entry_len_valid = 1;
                ND_PRINT("\n\t    #%u: type %#06x, length %u%s",
                        (unsigned int) i, name_entry_type,
                        name_entry_len, (name_entry_len_valid == 0) ? " (invalid)" : "");
                if (name_entry_len_valid == 0)
                    break;
                name_entry_padding = 0;
                if (name_entry_len%4 != 0)
                    name_entry_padding = 4-(name_entry_len%4);
                ND_ICHECKMSG_U("name entry length", msg_tlen, <,
                               addr_size + name_entry_len + name_entry_padding);
                ND_TCHECK_LEN(msg_data,
                              addr_size + name_entry_len + name_entry_padding);
                if (is_ipv6)
                    ND_PRINT(", address %s, name \"",
                            GET_IP6ADDR_STRING(msg_data));
                else
                    ND_PRINT(", address %s, name \"",
                            GET_IPADDR_STRING(msg_data));
                nd_printjn(ndo, msg_data + addr_size, name_entry_len);
                ND_PRINT("\"");
                msg_data += addr_size + name_entry_len + name_entry_padding;
                msg_tlen -= addr_size + name_entry_len + name_entry_padding;
            } 
            break;
        } 
        case OLSR_POWERINFO_MSG:
        default:
            print_unknown_data(ndo, msg_data, "\n\t    ", msg_tlen);
            break;
        } 
        tptr += msg_len;
    } 
    return;
invalid:
    nd_print_invalid(ndo);
}
