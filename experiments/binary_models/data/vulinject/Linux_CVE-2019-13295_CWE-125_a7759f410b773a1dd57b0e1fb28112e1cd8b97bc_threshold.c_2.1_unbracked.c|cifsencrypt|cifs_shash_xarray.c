static ssize_t cifs_shash_xarray(const struct iov_iter *iter, ssize_t maxsize,
				 struct shash_desc *shash)
{
	struct folio *folios[16], *folio;
	unsigned int nr, i, j, npages;
	loff_t start = iter->xarray_start + iter->iov_offset;
	pgoff_t last, index = start / PAGE_SIZE;
	ssize_t ret = 0;
	size_t len, offset, foffset;
	last = (start + maxsize - 1) / PAGE_SIZE;
	do {
		nr = xa_extract(iter->xarray, (void **)folios, index, last,
				ARRAY_SIZE(folios), XA_PRESENT);
		if (nr == 0)
			return -EIO;
		for (i = 0; i < nr; i++) {
			folio = folios[i];
			npages = folio_nr_pages(folio);
			foffset = start - folio_pos(folio);
			offset = foffset % PAGE_SIZE;
			for (j = foffset / PAGE_SIZE; j < npages; j++) {
				len = min_t(size_t, maxsize, PAGE_SIZE - offset);
				p = kmap_local_page(folio_page(folio, j));
				ret = crypto_shash_update(shash, p, len);
				kunmap_local(p);
				if (ret < 0)
					return ret;
				maxsize -= len;
				if (maxsize <= 0)
					return 0;
				start += len;
				offset = 0;
				index++;
			}
		}
	} while (nr == ARRAY_SIZE(folios));
	return 0;
}
