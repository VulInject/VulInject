d_print_comp_inner (struct d_print_info *dpi, int options,
		    struct demangle_component *dc)
{
  struct demangle_component *mod_inner = NULL;
  struct d_print_template *saved_templates;
  int need_template_restore = 0;
  if (dc == NULL)
    {
      return;
    }
  if (d_print_saw_error (dpi))
    return;
  switch (dc->type)
    {
    case DEMANGLE_COMPONENT_NAME:
      if ((options & DMGL_JAVA) == 0)
	d_append_buffer (dpi, dc->u.s_name.s, dc->u.s_name.len);
      else
	d_print_java_identifier (dpi, dc->u.s_name.s, dc->u.s_name.len);
      return;
    case DEMANGLE_COMPONENT_TAGGED_NAME:
      d_print_comp (dpi, options, d_left (dc));
      d_append_string (dpi, "[abi:");
      d_print_comp (dpi, options, d_right (dc));
      d_append_char (dpi, ']');
      return;
    case DEMANGLE_COMPONENT_QUAL_NAME:
    case DEMANGLE_COMPONENT_LOCAL_NAME:
      d_print_comp (dpi, options, d_left (dc));
      if ((options & DMGL_JAVA) == 0)
	d_append_string (dpi, "::");
      else
	d_append_char (dpi, '.');
      {
	struct demangle_component *local_name = d_right (dc);
	if (local_name->type == DEMANGLE_COMPONENT_DEFAULT_ARG)
	  {
	    d_append_string (dpi, "{default arg#");
	    d_append_num (dpi, local_name->u.s_unary_num.num + 1);
	    d_append_string (dpi, "}::");
	    local_name = local_name->u.s_unary_num.sub;
	  }
	d_print_comp (dpi, options, local_name);
      }
      return;
    case DEMANGLE_COMPONENT_TYPED_NAME:
      {
	struct d_print_mod *hold_modifiers;
	struct demangle_component *typed_name;
	struct d_print_mod adpm[4];
	unsigned int i;
	struct d_print_template dpt;
	hold_modifiers = dpi->modifiers;
	dpi->modifiers = 0;
	i = 0;
	typed_name = d_left (dc);
	while (typed_name)
	  {
	    if (i >= sizeof adpm / sizeof adpm[0])
	      {
		d_print_error (dpi);
		return;
	      }
	    adpm[i].next = dpi->modifiers;
	    dpi->modifiers = &adpm[i];
	    adpm[i].mod = typed_name;
	    adpm[i].printed = 0;
	    adpm[i].templates = dpi->templates;
	    i++;
	    if (!is_fnqual_component_type (typed_name->type))
	      break;
	    typed_name = d_left (typed_name);
	  }
	if (typed_name == NULL)
	  {
	    d_print_error (dpi);
	    return;
	  }
	if (typed_name->type == DEMANGLE_COMPONENT_LOCAL_NAME)
	  {
	    typed_name = d_right (typed_name);
	    if (typed_name->type == DEMANGLE_COMPONENT_DEFAULT_ARG)
	      typed_name = typed_name->u.s_unary_num.sub;
	    while (typed_name != NULL
		   && is_fnqual_component_type (typed_name->type))
	      {
		if (i >= sizeof adpm / sizeof adpm[0])
		  {
		    d_print_error (dpi);
		    return;
		  }
		adpm[i] = adpm[i - 1];
		adpm[i].next = &adpm[i - 1];
		dpi->modifiers = &adpm[i];
		adpm[i - 1].mod = typed_name;
		adpm[i - 1].printed = 0;
		adpm[i - 1].templates = dpi->templates;
		i++;
		typed_name = d_left (typed_name);
	      }
	    if (typed_name == NULL)
	      {
		d_print_error (dpi);
		return;
	      }
	  }
	if (typed_name->type == DEMANGLE_COMPONENT_TEMPLATE)
	  {
	    dpt.next = dpi->templates;
	    dpi->templates = &dpt;
	    dpt.template_decl = typed_name;
	  }
	d_print_comp (dpi, options, d_right (dc));
	if (typed_name->type == DEMANGLE_COMPONENT_TEMPLATE)
	  dpi->templates = dpt.next;
	while (i > 0)
	  {
	    --i;
	    if (! adpm[i].printed)
	      {
		d_append_char (dpi, ' ');
		d_print_mod (dpi, options, adpm[i].mod);
	      }
	  }
	dpi->modifiers = hold_modifiers;
	return;
      }
    case DEMANGLE_COMPONENT_TEMPLATE:
      {
	struct d_print_mod *hold_dpm;
	struct demangle_component *dcl;
	const struct demangle_component *hold_current;
	hold_current = dpi->current_template;
	dpi->current_template = dc;
	hold_dpm = dpi->modifiers;
	dpi->modifiers = NULL;
        dcl = d_left (dc);
        if ((options & DMGL_JAVA) != 0
            && dcl->type == DEMANGLE_COMPONENT_NAME
            && dcl->u.s_name.len == 6
            && strncmp (dcl->u.s_name.s, "JArray", 6) == 0)
          {
            d_print_comp (dpi, options, d_right (dc));
            d_append_string (dpi, "[]");
          }
        else
          {
	    d_print_comp (dpi, options, dcl);
	    if (d_last_char (dpi) == '<')
	      d_append_char (dpi, ' ');
	    d_append_char (dpi, '<');
	    d_print_comp (dpi, options, d_right (dc));
	    if (d_last_char (dpi) == '>')
	      d_append_char (dpi, ' ');
	    d_append_char (dpi, '>');
          }
	dpi->modifiers = hold_dpm;
	dpi->current_template = hold_current;
	return;
      }
    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
      if (dpi->is_lambda_arg)
	{
	  d_append_buffer (dpi, "auto:", 5);
	  d_append_num (dpi, dc->u.s_number.number + 1);
	}
      else
	{
	  struct d_print_template *hold_dpt;
	  struct demangle_component *a = d_lookup_template_argument (dpi, dc);
	  if (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)
	    a = d_index_template_argument (a, dpi->pack_index);
	  if (a == NULL)
	    {
	      d_print_error (dpi);
	      return;
	    }
	  hold_dpt = dpi->templates;
	  dpi->templates = hold_dpt->next;
	  d_print_comp (dpi, options, a);
	  dpi->templates = hold_dpt;
	}
      return;
    case DEMANGLE_COMPONENT_TPARM_OBJ:
      d_append_string (dpi, "template parameter object for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_CTOR:
      d_print_comp (dpi, options, dc->u.s_ctor.name);
      return;
    case DEMANGLE_COMPONENT_DTOR:
      d_append_char (dpi, '~');
      d_print_comp (dpi, options, dc->u.s_dtor.name);
      return;
    case DEMANGLE_COMPONENT_VTABLE:
      d_append_string (dpi, "vtable for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_VTT:
      d_append_string (dpi, "VTT for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:
      d_append_string (dpi, "construction vtable for ");
      d_print_comp (dpi, options, d_left (dc));
      d_append_string (dpi, "-in-");
      d_print_comp (dpi, options, d_right (dc));
      return;
    case DEMANGLE_COMPONENT_TYPEINFO:
      d_append_string (dpi, "typeinfo for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_TYPEINFO_NAME:
      d_append_string (dpi, "typeinfo name for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_TYPEINFO_FN:
      d_append_string (dpi, "typeinfo fn for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_THUNK:
      d_append_string (dpi, "non-virtual thunk to ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:
      d_append_string (dpi, "virtual thunk to ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_COVARIANT_THUNK:
      d_append_string (dpi, "covariant return thunk to ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_JAVA_CLASS:
      d_append_string (dpi, "java Class for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_GUARD:
      d_append_string (dpi, "guard variable for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_TLS_INIT:
      d_append_string (dpi, "TLS init function for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_TLS_WRAPPER:
      d_append_string (dpi, "TLS wrapper function for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_REFTEMP:
      d_append_string (dpi, "reference temporary #");
      d_print_comp (dpi, options, d_right (dc));
      d_append_string (dpi, " for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:
      d_append_string (dpi, "hidden alias for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:
      d_append_string (dpi, "transaction clone for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:
      d_append_string (dpi, "non-transaction clone for ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_SUB_STD:
      d_append_buffer (dpi, dc->u.s_string.string, dc->u.s_string.len);
      return;
    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_CONST:
      {
	struct d_print_mod *pdpm;
	for (pdpm = dpi->modifiers; pdpm; pdpm = pdpm->next)
	  {
	    if (! pdpm->printed)
	      {
		if (pdpm->mod->type != DEMANGLE_COMPONENT_RESTRICT
		    && pdpm->mod->type != DEMANGLE_COMPONENT_VOLATILE
		    && pdpm->mod->type != DEMANGLE_COMPONENT_CONST)
		  break;
		if (pdpm->mod->type == dc->type)
		  {
		    d_print_comp (dpi, options, d_left (dc));
		    return;
		  }
	      }
	  }
      }
      goto modifier;
    case DEMANGLE_COMPONENT_REFERENCE:
    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:
      {
	struct demangle_component *sub = d_left (dc);
	if (!dpi->is_lambda_arg
	    && sub->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM)
	  {
	    struct d_saved_scope *scope = d_get_saved_scope (dpi, sub);
	    struct demangle_component *a;
	    if (scope == NULL)
	      {
		d_save_scope (dpi, sub);
		if (d_print_saw_error (dpi))
		  return;
	      }
	    else
	      {
		const struct d_component_stack *dcse;
		int found_self_or_parent = 0;
		for (dcse = dpi->component_stack; dcse;
		     dcse = dcse->parent)
		  {
		    if (dcse->dc == sub
			|| (dcse->dc == dc
			    && dcse != dpi->component_stack))
		      {
			found_self_or_parent = 1;
			break;
		      }
		  }
		if (!found_self_or_parent)
		  {
		    saved_templates = dpi->templates;
		    dpi->templates = scope->templates;
		    need_template_restore = 1;
		  }
	      }
	    a = d_lookup_template_argument (dpi, sub);
	    if (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)
	      a = d_index_template_argument (a, dpi->pack_index);
	    if (a == NULL)
	      {
		if (need_template_restore)
		  dpi->templates = saved_templates;
		d_print_error (dpi);
		return;
	      }
	    sub = a;
	  }
	if (sub->type == DEMANGLE_COMPONENT_REFERENCE
	    || sub->type == dc->type)
	  dc = sub;
	else if (sub->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE)
	  mod_inner = d_left (sub);
      }
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
    case DEMANGLE_COMPONENT_POINTER:
    case DEMANGLE_COMPONENT_COMPLEX:
    case DEMANGLE_COMPONENT_IMAGINARY:
    FNQUAL_COMPONENT_CASE:
    modifier:
      {
	struct d_print_mod dpm;
	dpm.next = dpi->modifiers;
	dpi->modifiers = &dpm;
	dpm.mod = dc;
	dpm.printed = 0;
	dpm.templates = dpi->templates;
	if (!mod_inner)
	  mod_inner = d_left (dc);
	d_print_comp (dpi, options, mod_inner);
	if (! dpm.printed)
	  d_print_mod (dpi, options, dc);
	dpi->modifiers = dpm.next;
	if (need_template_restore)
	  dpi->templates = saved_templates;
	return;
      }
    case DEMANGLE_COMPONENT_BUILTIN_TYPE:
      if ((options & DMGL_JAVA) == 0)
	d_append_buffer (dpi, dc->u.s_builtin.type->name,
			 dc->u.s_builtin.type->len);
      else
	d_append_buffer (dpi, dc->u.s_builtin.type->java_name,
			 dc->u.s_builtin.type->java_len);
      return;
    case DEMANGLE_COMPONENT_VENDOR_TYPE:
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
      {
	if ((options & DMGL_RET_POSTFIX) != 0)
	  d_print_function_type (dpi,
				 options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),
				 dc, dpi->modifiers);
	if (d_left (dc) && (options & DMGL_RET_POSTFIX) != 0)
	  d_print_comp (dpi, options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),
			d_left (dc));
	else if (d_left (dc) && (options & DMGL_RET_DROP) == 0)
	  {
	    struct d_print_mod dpm;
	    dpm.next = dpi->modifiers;
	    dpi->modifiers = &dpm;
	    dpm.mod = dc;
	    dpm.printed = 0;
	    dpm.templates = dpi->templates;
	    d_print_comp (dpi, options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),
			  d_left (dc));
	    dpi->modifiers = dpm.next;
	    if (dpm.printed)
	      return;
	    if ((options & DMGL_RET_POSTFIX) == 0)
	      d_append_char (dpi, ' ');
	  }
	if ((options & DMGL_RET_POSTFIX) == 0)
	  d_print_function_type (dpi,
				 options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),
				 dc, dpi->modifiers);
	return;
      }
    case DEMANGLE_COMPONENT_ARRAY_TYPE:
      {
	struct d_print_mod *hold_modifiers;
	struct d_print_mod adpm[4];
	unsigned int i;
	struct d_print_mod *pdpm;
	hold_modifiers = dpi->modifiers;
	adpm[0].next = hold_modifiers;
	dpi->modifiers = &adpm[0];
	adpm[0].mod = dc;
	adpm[0].printed = 0;
	adpm[0].templates = dpi->templates;
	i = 1;
	pdpm = hold_modifiers;
	while (pdpm
	       && (pdpm->mod->type == DEMANGLE_COMPONENT_RESTRICT
		   || pdpm->mod->type == DEMANGLE_COMPONENT_VOLATILE
		   || pdpm->mod->type == DEMANGLE_COMPONENT_CONST))
	  {
	    if (! pdpm->printed)
	      {
		if (i >= sizeof adpm / sizeof adpm[0])
		  {
		    d_print_error (dpi);
		    return;
		  }
		adpm[i] = *pdpm;
		adpm[i].next = dpi->modifiers;
		dpi->modifiers = &adpm[i];
		pdpm->printed = 1;
		i++;
	      }
	    pdpm = pdpm->next;
	  }
	d_print_comp (dpi, options, d_right (dc));
	dpi->modifiers = hold_modifiers;
	if (adpm[0].printed)
	  return;
	while (i > 1)
	  {
	    --i;
	    d_print_mod (dpi, options, adpm[i].mod);
	  }
	d_print_array_type (dpi, options, dc, dpi->modifiers);
	return;
      }
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
    case DEMANGLE_COMPONENT_VECTOR_TYPE:
      {
	struct d_print_mod dpm;
	dpm.next = dpi->modifiers;
	dpi->modifiers = &dpm;
	dpm.mod = dc;
	dpm.printed = 0;
	dpm.templates = dpi->templates;
	d_print_comp (dpi, options, d_right (dc));
	if (! dpm.printed)
	  d_print_mod (dpi, options, dc);
	dpi->modifiers = dpm.next;
	return;
      }
    case DEMANGLE_COMPONENT_FIXED_TYPE:
      if (dc->u.s_fixed.sat)
	d_append_string (dpi, "_Sat ");
      if (dc->u.s_fixed.length->u.s_builtin.type
	  != &cplus_demangle_builtin_types['i'-'a'])
	{
	  d_print_comp (dpi, options, dc->u.s_fixed.length);
	  d_append_char (dpi, ' ');
	}
      if (dc->u.s_fixed.accum)
	d_append_string (dpi, "_Accum");
      else
	d_append_string (dpi, "_Fract");
      return;
    case DEMANGLE_COMPONENT_ARGLIST:
    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
      if (d_left (dc))
	d_print_comp (dpi, options, d_left (dc));
      if (d_right (dc))
	{
	  size_t len;
	  unsigned int int flush_count;
	  if (dpi->len >= sizeof (dpi->buf) - 2)
	    d_print_flush (dpi);
	  d_append_string (dpi, ", ");
	  len = dpi->len;
	  flush_count = dpi->flush_count;
	  d_print_comp (dpi, options, d_right (dc));
	  if (dpi->flush_count == flush_count && dpi->len == len)
	    dpi->len -= 2;
	}
      return;
    case DEMANGLE_COMPONENT_INITIALIZER_LIST:
      {
	struct demangle_component *type = d_left (dc);
	struct demangle_component *list = d_right (dc);
	if (type)
	  d_print_comp (dpi, options, type);
	d_append_char (dpi, '{');
	d_print_comp (dpi, options, list);
	d_append_char (dpi, '}');
      }
      return;
    case DEMANGLE_COMPONENT_OPERATOR:
      {
	const struct demangle_operator_info *op = dc->u.s_operator.op;
	int len = op->len;
	d_append_string (dpi, "operator");
	if (IS_LOWER (op->name[0]))
	  d_append_char (dpi, ' ');
	if (op->name[len-1] == ' ')
	  --len;
	d_append_buffer (dpi, op->name, len);
	return;
      }
    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
      d_append_string (dpi, "operator ");
      d_print_comp (dpi, options, dc->u.s_extended_operator.name);
      return;
    case DEMANGLE_COMPONENT_CONVERSION:
      d_append_string (dpi, "operator ");
      d_print_conversion (dpi, options, dc);
      return;
    case DEMANGLE_COMPONENT_NULLARY:
      d_print_expr_op (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_UNARY:
      {
	struct demangle_component *op = d_left (dc);
	struct demangle_component *operand = d_right (dc);
	const char *code = NULL;
	if (op->type == DEMANGLE_COMPONENT_OPERATOR)
	  {
	    code = op->u.s_operator.op->code;
	    if (!strcmp (code, "ad"))
	      {
		if (operand->type == DEMANGLE_COMPONENT_TYPED_NAME
		    && d_left (operand)->type == DEMANGLE_COMPONENT_QUAL_NAME
		    && d_right (operand)->type == DEMANGLE_COMPONENT_FUNCTION_TYPE)
		  operand = d_left (operand);
	      }
	    if (operand->type == DEMANGLE_COMPONENT_BINARY_ARGS)
	      {
		operand = d_left (operand);
		d_print_subexpr (dpi, options, operand);
		d_print_expr_op (dpi, options, op);
		return;
	      }
	  }
	if (code && !strcmp (code, "sZ"))
	  {
	    struct demangle_component *a = d_find_pack (dpi, operand);
	    int len = d_pack_length (a);
	    d_append_num (dpi, len);
	    return;
	  }
	else if (code && !strcmp (code, "sP"))
	  {
	    int len = d_args_length (dpi, operand);
	    d_append_num (dpi, len);
	    return;
	  }
	if (op->type != DEMANGLE_COMPONENT_CAST)
	  d_print_expr_op (dpi, options, op);
	else
	  {
	    d_append_char (dpi, '(');
	    d_print_cast (dpi, options, op);
	    d_append_char (dpi, ')');
	  }
	if (code && !strcmp (code, "gs"))
	  d_print_comp (dpi, options, operand);
	else if (code && !strcmp (code, "st"))
	  {
	    d_append_char (dpi, '(');
	    d_print_comp (dpi, options, operand);
	    d_append_char (dpi, ')');
	  }
	else
	  d_print_subexpr (dpi, options, operand);
      }
      return;
    case DEMANGLE_COMPONENT_BINARY:
      if (d_right (dc)->type != DEMANGLE_COMPONENT_BINARY_ARGS)
	{
	  d_print_error (dpi);
	  return;
	}
      if (op_is_new_cast (d_left (dc)))
	{
	  d_print_expr_op (dpi, options, d_left (dc));
	  d_append_char (dpi, '<');
	  d_print_comp (dpi, options, d_left (d_right (dc)));
	  d_append_string (dpi, ">(");
	  d_print_comp (dpi, options, d_right (d_right (dc)));
	  d_append_char (dpi, ')');
	  return;
	}
      if (d_maybe_print_fold_expression (dpi, options, dc))
	return;
      if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR
	  && d_left (dc)->u.s_operator.op->len == 1
	  && d_left (dc)->u.s_operator.op->name[0] == '>')
	d_append_char (dpi, '(');
      if (strcmp (d_left (dc)->u.s_operator.op->code, "cl") == 0
          && d_left (d_right (dc))->type == DEMANGLE_COMPONENT_TYPED_NAME)
	{
	  const struct demangle_component *func = d_left (d_right (dc));
	  if (d_right (func)->type != DEMANGLE_COMPONENT_FUNCTION_TYPE)
	    d_print_error (dpi);
	  d_print_subexpr (dpi, options, d_left (func));
	}
      else
	d_print_subexpr (dpi, options, d_left (d_right (dc)));
      if (strcmp (d_left (dc)->u.s_operator.op->code, "ix") == 0)
	{
	  d_append_char (dpi, '[');
	  d_print_comp (dpi, options, d_right (d_right (dc)));
	  d_append_char (dpi, ']');
	}
      else
	{
	  if (strcmp (d_left (dc)->u.s_operator.op->code, "cl") != 0)
	    d_print_expr_op (dpi, options, d_left (dc));
	  d_print_subexpr (dpi, options, d_right (d_right (dc)));
	}
      if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR
	  && d_left (dc)->u.s_operator.op->len == 1
	  && d_left (dc)->u.s_operator.op->name[0] == '>')
	d_append_char (dpi, ')');
      return;
    case DEMANGLE_COMPONENT_BINARY_ARGS:
      d_print_error (dpi);
      return;
    case DEMANGLE_COMPONENT_TRINARY:
      if (d_right (dc)->type != DEMANGLE_COMPONENT_TRINARY_ARG1
	  || d_right (d_right (dc))->type != DEMANGLE_COMPONENT_TRINARY_ARG2)
	{
	  d_print_error (dpi);
	  return;
	}
      if (d_maybe_print_fold_expression (dpi, options, dc))
	return;
      {
	struct demangle_component *op = d_left (dc);
	struct demangle_component *first = d_left (d_right (dc));
	struct demangle_component *second = d_left (d_right (d_right (dc)));
	struct demangle_component *third = d_right (d_right (d_right (dc)));
	if (!strcmp (op->u.s_operator.op->code, "qu"))
	  {
	    d_print_subexpr (dpi, options, first);
	    d_print_expr_op (dpi, options, op);
	    d_print_subexpr (dpi, options, second);
	    d_append_string (dpi, " : ");
	    d_print_subexpr (dpi, options, third);
	  }
	else
	  {
	    d_append_string (dpi, "new ");
	    if (d_left (first))
	      {
		d_print_subexpr (dpi, options, first);
		d_append_char (dpi, ' ');
	      }
	    d_print_comp (dpi, options, second);
	    if (third)
	      d_print_subexpr (dpi, options, third);
	  }
      }
      return;
    case DEMANGLE_COMPONENT_TRINARY_ARG1:
    case DEMANGLE_COMPONENT_TRINARY_ARG2:
      d_print_error (dpi);
      return;
    case DEMANGLE_COMPONENT_LITERAL:
    case DEMANGLE_COMPONENT_LITERAL_NEG:
      {
	enum d_builtin_type_print tp;
	tp = D_PRINT_DEFAULT;
	if (d_left (dc)->type == DEMANGLE_COMPONENT_BUILTIN_TYPE)
	  {
	    tp = d_left (dc)->u.s_builtin.type->print;
	    switch (tp)
	      {
	      case D_PRINT_INT:
	      case D_PRINT_UNSIGNED:
	      case D_PRINT_LONG:
	      case D_PRINT_UNSIGNED_LONG:
	      case D_PRINT_LONG_LONG:
	      case D_PRINT_UNSIGNED_LONG_LONG:
		if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME)
		  {
		    if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
		      d_append_char (dpi, '-');
		    d_print_comp (dpi, options, d_right (dc));
		    switch (tp)
		      {
		      default:
			break;
		      case D_PRINT_UNSIGNED:
			d_append_char (dpi, 'u');
			break;
		      case D_PRINT_LONG:
			d_append_char (dpi, 'l');
			break;
		      case D_PRINT_UNSIGNED_LONG:
			d_append_string (dpi, "ul");
			break;
		      case D_PRINT_LONG_LONG:
			d_append_string (dpi, "ll");
			break;
		      case D_PRINT_UNSIGNED_LONG_LONG:
			d_append_string (dpi, "ull");
			break;
		      }
		    return;
		  }
		break;
	      case D_PRINT_BOOL:
		if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME
		    && d_right (dc)->u.s_name.len == 1
		    && dc->type == DEMANGLE_COMPONENT_LITERAL)
		  {
		    switch (d_right (dc)->u.s_name.s[0])
		      {
		      case '0':
			d_append_string (dpi, "false");
			return;
		      case '1':
			d_append_string (dpi, "true");
			return;
		      default:
			break;
		      }
		  }
		break;
	      default:
		break;
	      }
	  }
	d_append_char (dpi, '(');
	d_print_comp (dpi, options, d_left (dc));
	d_append_char (dpi, ')');
	if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
	  d_append_char (dpi, '-');
	if (tp == D_PRINT_FLOAT)
	  d_append_char (dpi, '[');
	d_print_comp (dpi, options, d_right (dc));
	if (tp == D_PRINT_FLOAT)
	  d_append_char (dpi, ']');
      }
      return;
    case DEMANGLE_COMPONENT_NUMBER:
      d_append_num (dpi, dc->u.s_number.number);
      return;
    case DEMANGLE_COMPONENT_JAVA_RESOURCE:
      d_append_string (dpi, "java resource ");
      d_print_comp (dpi, options, d_left (dc));
      return;
    case DEMANGLE_COMPONENT_COMPOUND_NAME:
      d_print_comp (dpi, options, d_left (dc));
      d_print_comp (dpi, options, d_right (dc));
      return;
    case DEMANGLE_COMPONENT_CHARACTER:
      d_append_char (dpi, dc->u.s_character.character);
      return;
    case DEMANGLE_COMPONENT_DECLTYPE:
      d_append_string (dpi, "decltype (");
      d_print_comp (dpi, options, d_left (dc));
      d_append_char (dpi, ')');
      return;
    case DEMANGLE_COMPONENT_PACK_EXPANSION:
      {
	int len;
	int i;
	struct demangle_component *a = d_find_pack (dpi, d_left (dc));
	if (a == NULL)
	  {
	    d_print_subexpr (dpi, options, d_left (dc));
	    d_append_string (dpi, "...");
	    return;
	  }
	len = d_pack_length (a);
	dc = d_left (dc);
	for (i = 0; i < len; i++)
	  {
	    dpi->pack_index = i;
	    d_print_comp (dpi, options, dc);
	    if (i < len-1)
	      d_append_string (dpi, ", ");
	  }
      }
      return;
    case DEMANGLE_COMPONENT_FUNCTION_PARAM:
      {
	int num = dc->u.s_number.number;
	if (num == 0)
	  d_append_string (dpi, "this");
	else
	  {
	    d_append_string (dpi, "{parm#");
	    d_append_num (dpi, num);
	    d_append_char (dpi, '}');
	  }
      }
      return;
    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:
      d_append_string (dpi, "global constructors keyed to ");
      d_print_comp (dpi, options, dc->u.s_binary.left);
      return;
    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:
      d_append_string (dpi, "global destructors keyed to ");
      d_print_comp (dpi, options, dc->u.s_binary.left);
      return;
    case DEMANGLE_COMPONENT_LAMBDA:
      d_append_string (dpi, "{lambda(");
      dpi->is_lambda_arg++;
      d_print_comp (dpi, options, dc->u.s_unary_num.sub);
      dpi->is_lambda_arg--;
      d_append_string (dpi, ")#");
      d_append_num (dpi, dc->u.s_unary_num.num + 1);
      d_append_char (dpi, '}');
      return;
    case DEMANGLE_COMPONENT_UNNAMED_TYPE:
      d_append_string (dpi, "{unnamed type#");
      d_append_num (dpi, dc->u.s_number.number + 1);
      d_append_char (dpi, '}');
      return;
    case DEMANGLE_COMPONENT_CLONE:
      d_print_comp (dpi, options, d_left (dc));
      d_append_string (dpi, " [clone ");
      d_print_comp (dpi, options, d_right (dc));
      d_append_char (dpi, ']');
      return;
    default:
      d_print_error (dpi);
      return;
    }
}
