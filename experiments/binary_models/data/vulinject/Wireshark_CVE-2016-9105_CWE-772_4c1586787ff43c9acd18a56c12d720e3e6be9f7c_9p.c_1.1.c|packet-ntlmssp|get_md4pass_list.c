get_md4pass_list(wmem_allocator_t *pool, md4_pass** p_pass_list)
{
#if defined(HAVE_HEIMDAL_KERBEROS) || defined(HAVE_MIT_KERBEROS)
  guint32        nb_pass = 0;
  enc_key_t     *ek;
  const char*    password = ntlmssp_option_nt_password;
  unsigned char  nt_hash[NTLMSSP_KEY_LEN];
  char           password_unicode[256];
  md4_pass*      pass_list;
  int            i;
  *p_pass_list = NULL;
  read_keytab_file_from_preferences();
  for (ek=enc_key_list; ek; ek=ek->next) {
    if (NTLMSSP_EK_IS_NT4HASH(ek)) {
      nb_pass++;
    }
  }
  memset(password_unicode, 0, sizeof(password_unicode));
  memset(nt_hash, 0, NTLMSSP_KEY_LEN);
  if (strlen(password) < 129) {
    int password_len;
    nb_pass++;
    password_len = (int)strlen(password);
    gcry_md_hash_buffer(GCRY_MD_MD4, nt_hash, password_unicode, password_len*2);
  }
  if (nb_pass == 0) {
    return 0;
  }
  i = 0;
  *p_pass_list = (md4_pass *)wmem_alloc0(pool, nb_pass*sizeof(md4_pass));
  pass_list = *p_pass_list;
  if (memcmp(nt_hash, gbl_zeros, NTLMSSP_KEY_LEN) != 0) {
    memcpy(pass_list[i].md4, nt_hash, NTLMSSP_KEY_LEN);
    snprintf(pass_list[i].key_origin, NTLMSSP_MAX_ORIG_LEN,
               "<Global NT Password>");
    i = 1;
  }
  for (ek=enc_key_list; ek; ek=ek->next) {
    if (NTLMSSP_EK_IS_NT4HASH(ek)) {
      memcpy(pass_list[i].md4, ek->keyvalue, NTLMSSP_KEY_LEN);
      memcpy(pass_list[i].key_origin, ek->key_origin,
             MIN(sizeof(pass_list[i].key_origin),sizeof(ek->key_origin)));
      i++;
    }
  }
  return nb_pass;
#else 
  (void) pool;
  *p_pass_list = NULL;
  return 0;
#endif 
}
