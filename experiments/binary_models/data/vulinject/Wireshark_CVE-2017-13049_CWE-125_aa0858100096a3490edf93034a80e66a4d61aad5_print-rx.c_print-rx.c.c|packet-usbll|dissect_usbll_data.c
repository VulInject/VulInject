dissect_usbll_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset,
                   guint8 pid, usbll_data_t *data, gint *payload_size)
{
    guint16                computed_crc, actual_crc;
    gint                   data_offset = offset;
    gint                   data_size = tvb_reported_length_remaining(tvb, offset) - 2;
    proto_item            *data_item = NULL;
    usbll_transfer_info_t *transfer = NULL;
    data_item = proto_tree_add_item(tree, hf_usbll_data, tvb, offset, data_size, ENC_NA);
    offset += data_size;
    actual_crc = tvb_get_letohs(tvb, offset);
    computed_crc = crc16_usb_tvb_offset(tvb, 1, offset - 1);
    proto_tree_add_checksum(tree, tvb, offset,
                            hf_usbll_data_crc, hf_usbll_data_crc_status, &ei_wrong_crc16, pinfo,
                            computed_crc, ENC_LITTLE_ENDIAN, PROTO_CHECKSUM_VERIFY);
    offset += 2;
    if (!PINFO_FD_VISITED(pinfo))
    {
        usbll_state_t             prev_state;
        prev_state = data->prev ? data->prev->transaction_state : STATE_IDLE;
        data->transaction_state = usbll_next_state(prev_state, pid);
        if (data->transaction_state != STATE_INVALID)
        {
            DISSECTOR_ASSERT(data->prev != NULL);
            DISSECTOR_ASSERT(data->prev->transaction != NULL);
            data->transaction = data->prev->transaction;
        }
    }
    if (actual_crc != computed_crc)
    {
        return offset;
    }
    if (usbll_is_setup_data(data->transaction_state))
    {
        if (data_size != 8)
        {
            expert_add_info(pinfo, data_item, &ei_invalid_setup_data);
        }
        else if (!PINFO_FD_VISITED(pinfo))
        {
            usbll_endpoint_info_t *ep_out, *ep_in;
            ep_out = usbll_get_endpoint_info(pinfo, data->transaction->address, data->transaction->endpoint, TRUE);
            ep_in = usbll_get_endpoint_info(pinfo, data->transaction->address, data->transaction->endpoint, FALSE);
            if ((ep_out->type == USBLL_EP_CONTROL) && (ep_in->type == USBLL_EP_CONTROL))
            {
                guint8 setup[8];
                gboolean data_stage_from_host;
                guint16  requested_length;
                tvb_memcpy(tvb, setup, data_offset, 8);
                data_stage_from_host = (setup[0] & 0x80) ? FALSE : TRUE;
                requested_length = setup[6] | (setup[7] << 8);
                usbll_reset_endpoint_info(ep_out, USBLL_EP_CONTROL, ep_out->max_packet_size);
                usbll_reset_endpoint_info(ep_in, USBLL_EP_CONTROL, ep_in->max_packet_size);
                transfer = wmem_new0(wmem_file_scope(), usbll_transfer_info_t);
                transfer->first_packet = pinfo->num;
                transfer->offset = 0;
                transfer->type = USBLL_EP_CONTROL;
                transfer->from_host = TRUE; 
                if (requested_length > 0)
                {
                    if (data_stage_from_host)
                    {
                        transfer->more_frags = TRUE;
                        ep_out->active_transfer_key = pinfo->num;
                        ep_out->requested_transfer_length = 8 + requested_length;
                        ep_out->transfer_offset = 8;
                        ep_out->last_data_pid = pid;
                        ep_out->last_data_acked = FALSE;
                        ep_out->last_data_len = 0;
                    }
                    else
                    {
                        transfer->more_frags = FALSE;
                        ep_in->requested_transfer_length = requested_length;
                        ep_in->last_data_pid = pid;
                        ep_in->last_data_acked = FALSE;
                        ep_in->last_data_len = 0;
                    }
                }
                if (is_get_device_descriptor(setup))
                {
                    ep_in->data = USBLL_TRANSFER_GET_DEVICE_DESCRIPTOR;
                }
                else if (is_set_address(setup))
                {
                    int addr = setup[2];
                    if (addr > 0)
                    {
                    }
                }
                wmem_map_insert(transfer_info, GUINT_TO_POINTER(pinfo->num), transfer);
            }
        }
    }
    else if ((!PINFO_FD_VISITED(pinfo)) && (data->transaction_state != STATE_INVALID))
    {
        usbll_endpoint_info_t *ep_info;
        gboolean               from_host;
        from_host = usbll_is_data_from_host(data->transaction_state);
        ep_info = usbll_get_endpoint_info(pinfo, data->transaction->address, data->transaction->endpoint, from_host);
        if (ep_info->type == USBLL_EP_CONTROL)
        {
            if (ep_info->requested_transfer_length > 0)
            {
                if (pid == ep_info->last_data_pid)
                {
                    if (ep_info->last_data_len == 0)
                    {
                        data->transaction_state = STATE_INVALID;
                    }
                    else
                    {
                        transfer = wmem_new0(wmem_file_scope(), usbll_transfer_info_t);
                        transfer->first_packet = ep_info->active_transfer_key;
                        transfer->offset = ep_info->transfer_offset - ep_info->last_data_len;
                        transfer->type = USBLL_EP_CONTROL;
                        transfer->from_host = from_host;
                        transfer->more_frags = !packet_ends_transfer(ep_info, transfer->offset, data_size);
                        wmem_map_insert(transfer_info, GUINT_TO_POINTER(pinfo->num), transfer);
                    }
                }
                else if ((pid == USB_PID_DATA_DATA0) || (pid == USB_PID_DATA_DATA1))
                {
                    if (ep_info->active_transfer_key == 0)
                    {
                        DISSECTOR_ASSERT(!from_host);
                        DISSECTOR_ASSERT(ep_info->transfer_offset == 0);
                        DISSECTOR_ASSERT(ep_info->last_data_len == 0);
                        ep_info->active_transfer_key = pinfo->num;
                        if ((ep_info->data == USBLL_TRANSFER_GET_DEVICE_DESCRIPTOR) && (data_size >= 8))
                        {
                            usbll_endpoint_info_t *ep_out;
                            usb_speed_t            speed;
                            guint16                max_packet_size;
                            ep_out = usbll_get_endpoint_info(pinfo, data->transaction->address, data->transaction->endpoint, TRUE);
                            max_packet_size = tvb_get_guint8(tvb, data_offset + 7);
                            speed = usbll_get_data_transaction_speed(data);
                            max_packet_size = sanitize_usb_max_packet_size(ENDPOINT_TYPE_CONTROL, speed, max_packet_size);
                            ep_info->max_packet_size = ep_out->max_packet_size = max_packet_size;
                        }
                    }
                    transfer = wmem_new0(wmem_file_scope(), usbll_transfer_info_t);
                    transfer->first_packet = ep_info->active_transfer_key;
                    transfer->offset = ep_info->transfer_offset;
                    transfer->type = USBLL_EP_CONTROL;
                    transfer->from_host = from_host;
                    transfer->more_frags = !packet_ends_transfer(ep_info, transfer->offset, data_size);
                    wmem_map_insert(transfer_info, GUINT_TO_POINTER(pinfo->num), transfer);
                    ep_info->last_data_pid = pid;
                    ep_info->last_data_acked = usbll_is_split_data_from_device(data->transaction_state);
                    ep_info->transfer_offset += data_size;
                    ep_info->last_data_len = data_size;
                }
                else
                {
                    data->transaction_state = STATE_INVALID;
                }
            }
            else
            {
            }
        }
        else if ((ep_info->type == USBLL_EP_BULK) || (ep_info->type == USBLL_EP_INTERRUPT))
        {
            if (pid == ep_info->last_data_pid)
            {
                DISSECTOR_ASSERT(ep_info->active_transfer_key != 0);
                transfer = wmem_new0(wmem_file_scope(), usbll_transfer_info_t);
                transfer->first_packet = ep_info->active_transfer_key;
                transfer->offset = ep_info->transfer_offset - ep_info->last_data_len;
                transfer->type = ep_info->type;
                transfer->from_host = from_host;
                transfer->more_frags = !packet_ends_transfer(ep_info, transfer->offset, data_size);
                wmem_map_insert(transfer_info, GUINT_TO_POINTER(pinfo->num), transfer);
            }
            else if ((ep_info->active_transfer_key == 0) ||
                     packet_ends_transfer(ep_info, ep_info->transfer_offset, ep_info->last_data_len))
            {
                 transfer = wmem_new0(wmem_file_scope(), usbll_transfer_info_t);
                 transfer->first_packet = pinfo->num;
                 transfer->offset = 0;
                 transfer->type = ep_info->type;
                 transfer->from_host = from_host;
                 transfer->more_frags = !packet_ends_transfer(ep_info, transfer->offset, data_size);
                 wmem_map_insert(transfer_info, GUINT_TO_POINTER(pinfo->num), transfer);
                 ep_info->last_data_pid = pid;
                 ep_info->last_data_acked = usbll_is_split_data_from_device(data->transaction_state);
                 ep_info->active_transfer_key = pinfo->num;
                 ep_info->transfer_offset = data_size;
                 ep_info->last_data_len = data_size;
            }
            else
            {
                transfer = wmem_new0(wmem_file_scope(), usbll_transfer_info_t);
                transfer->first_packet = ep_info->active_transfer_key;
                transfer->offset = ep_info->transfer_offset;
                transfer->type = ep_info->type;
                transfer->from_host = from_host;
                transfer->more_frags = !packet_ends_transfer(ep_info, transfer->offset, data_size);
                wmem_map_insert(transfer_info, GUINT_TO_POINTER(pinfo->num), transfer);
                ep_info->last_data_pid = pid;
                ep_info->last_data_acked = usbll_is_split_data_from_device(data->transaction_state);
                ep_info->transfer_offset += data_size;
                ep_info->last_data_len = data_size;
            }
        }
        else if (ep_info->type == USBLL_EP_ISOCHRONOUS)
        {
            transfer = wmem_new0(wmem_file_scope(), usbll_transfer_info_t);
            transfer->first_packet = pinfo->num;
            transfer->offset = 0;
            transfer->type = ep_info->type;
            transfer->from_host = from_host;
            transfer->more_frags = FALSE;
            wmem_map_insert(transfer_info, GUINT_TO_POINTER(pinfo->num), transfer);
        }
    }
    *payload_size = data_size;
    return offset;
}
