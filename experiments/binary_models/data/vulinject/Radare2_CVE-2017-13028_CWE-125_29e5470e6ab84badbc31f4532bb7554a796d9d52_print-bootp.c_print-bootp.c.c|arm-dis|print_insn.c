print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)
{
  unsigned char b[4];
  int		given;
  int           status;
  int           is_thumb = FALSE;
  int           is_data = FALSE;
  int           little_code;
  unsigned int	size = 4;
  void	 	(*printer) (bfd_vma, struct disassemble_info *, int);
  bfd_boolean   found = FALSE;
  struct arm_private_data *private_data;
  if (info->disassembler_options)
    {
      info->disassembler_options = NULL;
    }
  if (info->private_data == NULL)
    {
      static struct arm_private_data private;
      if ((info->flags & USER_SPECIFIED_MACHINE_TYPE) == 0) {
	      info->mach = bfd_mach_arm_unknown;
      }
      select_arm_features (info->mach, & private.features);
      private.has_mapping_symbols = -1;
      private.last_mapping_sym = -1;
      private.last_mapping_addr = 0;
      info->private_data = & private;
    }
  private_data = info->private_data;
  little_code = ((info->endian_code == BFD_ENDIAN_LITTLE) || little);
  if (info->symtab_size != 0
      && bfd_asymbol_flavour (*info->symtab) == bfd_target_elf_flavour)
    {
      bfd_vma addr;
      int n, start;
      int last_sym = -1;
      enum map_type type = MAP_ARM;
      if (pc == 0) {
	      start = 0;
      } else {
	      start = info->symtab_pos + 1;
	      if (start < private_data->last_mapping_sym) {
		      start = private_data->last_mapping_sym;
	      }
	}
      found = FALSE;
      if (private_data->has_mapping_symbols != 0)
	{
	  for (n = start; n < info->symtab_size; n++)
	    {
	      addr = bfd_asymbol_value (info->symtab[n]);
	      if (addr > pc) {
		      break;
	      }
	      if (get_map_sym_type (info, n, &type))
		{
		  last_sym = n;
		  found = TRUE;
		}
	    }
	  if (!found)
	    {
	      for (n = start - 1; n >= 0; n--)
		{
		  if (get_map_sym_type (info, n, &type))
		    {
		      last_sym = n;
		      found = TRUE;
		      break;
		    }
		}
	    }
	    if (found) {
		    private_data->has_mapping_symbols = 1;
	    }
	    if (!found && private_data->has_mapping_symbols == -1) {
		    for (n = 0; n < info->symtab_size; n++) {
			    if (is_mapping_symbol (info, n, &type)) {
				    private_data->has_mapping_symbols = 1;
				    break;
			    }
		    }
		    if (private_data->has_mapping_symbols == -1) {
			    private_data->has_mapping_symbols = 0;
		    }
	    }
	  if (!found && private_data->has_mapping_symbols == 1)
	    {
	      type = MAP_DATA;
	      found = TRUE;
	    }
	}
      if (!found)
	{
	  for (n = start; n < info->symtab_size; n++)
	    {
	      addr = bfd_asymbol_value (info->symtab[n]);
	      if (addr > pc) {
		      break;
	      }
	      if (get_sym_code_type (info, n, &type))
		{
		  last_sym = n;
		  found = TRUE;
		}
	    }
	  if (!found)
	    {
	      for (n = start - 1; n >= 0; n--)
		{
		  if (get_sym_code_type (info, n, &type))
		    {
		      last_sym = n;
		      found = TRUE;
		      break;
		    }
		}
	    }
	}
      private_data->last_mapping_sym = last_sym;
      private_data->last_type = type;
      is_thumb = (private_data->last_type == MAP_THUMB);
      is_data = (private_data->last_type == MAP_DATA);
      if (is_data)
	{
	  size = 4 - (pc & 3);
	  for (n = last_sym + 1; n < info->symtab_size; n++)
	    {
	      addr = bfd_asymbol_value (info->symtab[n]);
	      if (addr > pc
		  && (info->section == NULL
		      || info->section == info->symtab[n]->section))
		{
		      if (addr - pc < size) {
			      size = addr - pc;
		      }
		      break;
		}
	    }
	    if (size == 3) {
		    size = (pc & 1) ? 1 : 2;
	    }
	}
    }
    if (force_thumb) {
	    is_thumb = TRUE;
    }
    if (is_data) {
	    info->display_endian = little ? BFD_ENDIAN_LITTLE : BFD_ENDIAN_BIG;
    } else {
	    info->display_endian = little_code ? BFD_ENDIAN_LITTLE : BFD_ENDIAN_BIG;
    }
    info->bytes_per_line = 4;
    if (is_data && ((info->flags & DISASSEMBLE_DATA) == 0)) {
	    int i;
	    info->bytes_per_chunk = size;
	    printer = print_insn_data;
	    status = info->read_memory_func (pc, (bfd_byte *)b, size, info);
	    given = 0;
	    if (little) {
		    for (i = size - 1; i >= 0; i--) {
			    given = b[i] | (given << 8);
		    }
	    } else {
		    for (i = 0; i < (int)size; i++) {
			    given = b[i] | (given << 8);
		    }
	    }
    }
  else if (!is_thumb)
    {
      printer = print_insn_arm;
      info->bytes_per_chunk = 4;
      size = 4;
      status = info->read_memory_func (pc, (bfd_byte *) b, 4, info);
#define N(x) (((unsigned int int )(b[x])) & 0xff)
      if (little_code) {
	      given = N(0) | N(1) <<8 | N(2) << 16 | N(3) << 24;
      } else {
	      given = N(3) | N(2) <<8 | N(1) << 16 | N(0) << 24;
      }
    }
  else
    {
      printer = print_insn_thumb16;
      info->bytes_per_chunk = 2;
      size = 2;
      status = info->read_memory_func (pc, (bfd_byte *) b, 2, info);
      if (little_code) {
	      given = (b[0]) | (b[1] << 8);
      } else {
	      given = (b[1]) | (b[0] << 8);
      }
      if (!status)
	{
	  if ((given & 0xF800) == 0xF800
	      || (given & 0xF800) == 0xF000
	      || (given & 0xF800) == 0xE800)
	    {
	      status = info->read_memory_func (pc + 2, (bfd_byte *) b, 2, info);
	      if (little_code) {
		      given = (b[0]) | (b[1] << 8) | (given << 16);
	      } else {
		      given = (b[1]) | (b[0] << 8) | (given << 16);
	      }
	      printer = print_insn_thumb32;
	      size = 4;
	    }
	}
	if (ifthen_address != pc) {
		find_ifthen_state (pc, info, little_code);
	}
	if (ifthen_state) {
		if ((ifthen_state & 0xf) == 0x8) {
			ifthen_next_state = 0;
		} else {
			ifthen_next_state = (ifthen_state & 0xe0) | ((ifthen_state & 0xf) << 1);
		}
	}
    }
  if (status)
    {
      info->memory_error_func (status, pc, info);
      return -1;
    }
    if (info->flags & INSN_HAS_RELOC) {
	    pc = 0;
    }
    printer (pc, info, given);
    if (is_thumb) {
	    ifthen_state = ifthen_next_state;
	    ifthen_address += size;
    }
  return size;
}
