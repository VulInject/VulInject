void ceph_handle_caps(struct ceph_mds_session *session,
		      struct ceph_msg *msg)
{
	struct ceph_mds_client *mdsc = session->s_mdsc;
	struct ceph_client *cl = mdsc->fsc->client;
	struct inode *inode;
	struct ceph_inode_info *ci;
	struct ceph_cap *cap;
	struct ceph_mds_caps *h;
	struct ceph_mds_cap_peer *peer = NULL;
	struct ceph_snap_realm *realm = NULL;
	int op;
	int msg_version = le16_to_cpu(msg->hdr.version);
	unsigned int seq, mseq;
	struct ceph_vino vino;
	void *snaptrace;
	size_t snaptrace_len;
	void *p, *end;
	struct cap_extra_info extra_info = {};
	bool queue_trunc;
	bool close_sessions = false;
	bool do_cap_release = false;
	doutc(cl, "from mds%d\n", session->s_mds);
	if (!ceph_inc_mds_stopping_blocker(mdsc, session))
		return;
	end = msg->front.iov_base + msg->front.iov_len;
	if (msg->front.iov_len < sizeof(*h))
		goto bad;
	h = msg->front.iov_base;
	op = le32_to_cpu(h->op);
	vino.ino = le64_to_cpu(h->ino);
	vino.snap = CEPH_NOSNAP;
	seq = le32_to_cpu(h->seq);
	mseq = le32_to_cpu(h->migrate_seq);
	snaptrace = h + 1;
	snaptrace_len = le32_to_cpu(h->snap_trace_len);
	p = snaptrace + snaptrace_len;
	if (msg_version >= 2) {
		unsigned int flock_len;
		ceph_decode_32_safe(&p, end, flock_len, bad);
		if (p + flock_len > end)
			goto bad;
		p += flock_len;
	}
	if (msg_version >= 3) {
		if (op == CEPH_CAP_OP_IMPORT) {
			if (p + sizeof(*peer) > end)
				goto bad;
			peer = p;
			p += sizeof(*peer);
		} else if (op == CEPH_CAP_OP_EXPORT) {
			peer = (void *)&h->size;
		}
	}
	if (msg_version >= 4) {
		ceph_decode_64_safe(&p, end, extra_info.inline_version, bad);
		ceph_decode_32_safe(&p, end, extra_info.inline_len, bad);
		if (p + extra_info.inline_len > end)
			goto bad;
		extra_info.inline_data = p;
		p += extra_info.inline_len;
	}
	if (msg_version >= 5) {
		struct ceph_osd_client	*osdc = &mdsc->fsc->client->osdc;
		unsigned int			epoch_barrier;
		ceph_decode_32_safe(&p, end, epoch_barrier, bad);
		ceph_osdc_update_epoch_barrier(osdc, epoch_barrier);
	}
	if (msg_version >= 8) {
		unsigned int pool_ns_len;
		ceph_decode_skip_64(&p, end, bad);	
		ceph_decode_skip_32(&p, end, bad);	
		ceph_decode_skip_32(&p, end, bad);	
		ceph_decode_32_safe(&p, end, pool_ns_len, bad);
		if (pool_ns_len > 0) {
			ceph_decode_need(&p, end, pool_ns_len, bad);
			extra_info.pool_ns =
				ceph_find_or_create_string(p, pool_ns_len);
			p += pool_ns_len;
		}
	}
	if (msg_version >= 9) {
		struct ceph_timespec *btime;
		if (p + sizeof(*btime) > end)
			goto bad;
		btime = p;
		ceph_decode_timespec64(&extra_info.btime, btime);
		p += sizeof(*btime);
		ceph_decode_64_safe(&p, end, extra_info.change_attr, bad);
	}
	if (msg_version >= 11) {
		ceph_decode_skip_32(&p, end, bad); 
		extra_info.dirstat_valid = true;
		ceph_decode_64_safe(&p, end, extra_info.nfiles, bad);
		ceph_decode_64_safe(&p, end, extra_info.nsubdirs, bad);
	}
	if (msg_version >= 12) {
		if (parse_fscrypt_fields(&p, end, &extra_info))
			goto bad;
	}
	inode = ceph_find_inode(mdsc->fsc->sb, vino);
	doutc(cl, " op %s ino %llx.%llx inode %p\n", ceph_cap_op_name(op),
	      vino.ino, vino.snap, inode);
	doutc(cl, " mds%d seq %lld cap seq %u\n", session->s_mds,
	      session->s_seq, (unsigned)seq);
	if (!inode) {
		doutc(cl, " i don't have ino %llx\n", vino.ino);
		switch (op) {
		case CEPH_CAP_OP_IMPORT:
		case CEPH_CAP_OP_REVOKE:
		case CEPH_CAP_OP_GRANT:
			do_cap_release = true;
			break;
		default:
			break;
		}
		goto flush_cap_releases;
	}
	ci = ceph_inode(inode);
	switch (op) {
	case CEPH_CAP_OP_FLUSHSNAP_ACK:
		handle_cap_flushsnap_ack(inode, le64_to_cpu(msg->hdr.tid),
					 h, session);
		goto done;
	case CEPH_CAP_OP_EXPORT:
		handle_cap_export(inode, h, peer, session);
		goto done_unlocked;
	case CEPH_CAP_OP_IMPORT:
		realm = NULL;
		if (snaptrace_len) {
			down_write(&mdsc->snap_rwsem);
			if (ceph_update_snap_trace(mdsc, snaptrace,
						   snaptrace + snaptrace_len,
						   false, &realm)) {
				up_write(&mdsc->snap_rwsem);
				close_sessions = true;
				goto done;
			}
			downgrade_write(&mdsc->snap_rwsem);
		} else {
			down_read(&mdsc->snap_rwsem);
		}
		spin_lock(&ci->i_ceph_lock);
		handle_cap_import(mdsc, inode, h, peer, session,
				  &cap, &extra_info.issued);
		handle_cap_grant(inode, session, cap,
				 h, msg->middle, &extra_info);
		if (realm)
			ceph_put_snap_realm(mdsc, realm);
		goto done_unlocked;
	}
	spin_lock(&ci->i_ceph_lock);
	cap = __get_cap_for_mds(ceph_inode(inode), session->s_mds);
	if (!cap) {
		doutc(cl, " no cap on %p ino %llx.%llx from mds%d\n",
		      inode, ceph_ino(inode), ceph_snap(inode),
		      session->s_mds);
		spin_unlock(&ci->i_ceph_lock);
		switch (op) {
		case CEPH_CAP_OP_REVOKE:
		case CEPH_CAP_OP_GRANT:
			do_cap_release = true;
			break;
		default:
			break;
		}
		goto flush_cap_releases;
	}
	switch (op) {
	case CEPH_CAP_OP_REVOKE:
	case CEPH_CAP_OP_GRANT:
		__ceph_caps_issued(ci, &extra_info.issued);
		extra_info.issued |= __ceph_caps_dirty(ci);
		handle_cap_grant(inode, session, cap,
				 h, msg->middle, &extra_info);
		goto done_unlocked;
	case CEPH_CAP_OP_FLUSH_ACK:
		handle_cap_flush_ack(inode, le64_to_cpu(msg->hdr.tid),
				     h, session, cap);
		break;
	case CEPH_CAP_OP_TRUNC:
		queue_trunc = handle_cap_trunc(inode, h, session,
						&extra_info);
		spin_unlock(&ci->i_ceph_lock);
		if (queue_trunc)
			ceph_queue_vmtruncate(inode);
		break;
	default:
		spin_unlock(&ci->i_ceph_lock);
		pr_err_client(cl, "unknown cap op %d %s\n", op,
			      ceph_cap_op_name(op));
	}
done:
	mutex_unlock(&session->s_mutex);
done_unlocked:
	iput(inode);
out:
	ceph_dec_mds_stopping_blocker(mdsc);
	ceph_put_string(extra_info.pool_ns);
	if (close_sessions)
		ceph_mdsc_close_sessions(mdsc);
	kfree(extra_info.fscrypt_auth);
	return;
flush_cap_releases:
	if (do_cap_release) {
		cap = ceph_get_cap(mdsc, NULL);
		cap->cap_ino = vino.ino;
		cap->queue_release = 1;
		cap->cap_id = le64_to_cpu(h->cap_id);
		cap->mseq = mseq;
		cap->seq = seq;
		cap->issue_seq = seq;
		spin_lock(&session->s_cap_lock);
		__ceph_queue_cap_release(session, cap);
		spin_unlock(&session->s_cap_lock);
	}
	ceph_flush_cap_releases(mdsc, session);
	goto done;
bad:
	pr_err_client(cl, "corrupt message\n");
	ceph_msg_dump(msg);
	goto out;
}
