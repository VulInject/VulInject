struct posix_acl *nfs3_get_acl(struct inode *inode, int type, bool rcu)
{
	struct nfs_server *server = NFS_SERVER(inode);
	struct page *pages[NFSACL_MAXPAGES] = { };
	struct nfs3_getaclargs args = {
		.fh = NFS_FH(inode),
		.pages = pages,
	};
	struct nfs3_getaclres res = {
		NULL,
	};
	struct rpc_message msg = {
		.rpc_argp	= &args,
		.rpc_resp	= &res,
	};
	int status, count;
	if (rcu)
		return ERR_PTR(-ECHILD);
	if (!nfs_server_capable(inode, NFS_CAP_ACLS))
		return ERR_PTR(-EOPNOTSUPP);
	status = nfs_revalidate_inode(inode, NFS_INO_INVALID_CHANGE);
	if (status < 0)
		return ERR_PTR(status);
	if (type == ACL_TYPE_ACCESS)
		args.mask |= NFS_ACLCNT|NFS_ACL;
	if (S_ISDIR(inode->i_mode))
		args.mask |= NFS_DFACLCNT|NFS_DFACL;
	if (args.mask == 0)
		return NULL;
	dprintk("NFS call getacl\n");
	msg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_GETACL];
	res.fattr = nfs_alloc_fattr();
	if (res.fattr == NULL)
		return ERR_PTR(-ENOMEM);
	if (args.mask & NFS_ACL)
	if (args.mask & NFS_DFACL)
		nfs3_prepare_get_acl(&inode->i_default_acl);
	status = rpc_call_sync(server->client_acl, &msg, 0);
	dprintk("NFS reply getacl: %d\n", status);
	for (count = 0; count < NFSACL_MAXPAGES && args.pages[count]; count++)
		__free_page(args.pages[count]);
	switch (status) {
		case 0:
			status = nfs_refresh_inode(inode, res.fattr);
			break;
		case -EPFNOSUPPORT:
		case -EPROTONOSUPPORT:
			dprintk("NFS_V3_ACL extension not supported; disabling\n");
			server->caps &= ~NFS_CAP_ACLS;
			fallthrough;
		case -ENOTSUPP:
			status = -EOPNOTSUPP;
			goto getout;
		default:
			goto getout;
	}
	if ((args.mask & res.mask) != args.mask) {
		status = -EIO;
		goto getout;
	}
	if (res.acl_access != NULL) {
		if ((posix_acl_equiv_mode(res.acl_access, NULL) == 0) ||
		    res.acl_access->a_count == 0) {
			posix_acl_release(res.acl_access);
			res.acl_access = NULL;
		}
	}
	if (res.mask & NFS_ACL)
		nfs3_complete_get_acl(&inode->i_acl, res.acl_access);
	else
		forget_cached_acl(inode, ACL_TYPE_ACCESS);
	if (res.mask & NFS_DFACL)
		nfs3_complete_get_acl(&inode->i_default_acl, res.acl_default);
	else
		forget_cached_acl(inode, ACL_TYPE_DEFAULT);
	nfs_free_fattr(res.fattr);
	if (type == ACL_TYPE_ACCESS) {
		posix_acl_release(res.acl_default);
		return res.acl_access;
	} else {
		posix_acl_release(res.acl_access);
		return res.acl_default;
	}
getout:
	nfs3_abort_get_acl(&inode->i_acl);
	nfs3_abort_get_acl(&inode->i_default_acl);
	posix_acl_release(res.acl_access);
	posix_acl_release(res.acl_default);
	nfs_free_fattr(res.fattr);
	return ERR_PTR(status);
}
