static int alloc_exact_nid_numa_reserved_full_merge_generic_check(void)
{
	int nid_req = 6;
	int nid_next = nid_req + 1;
	struct memblock_region *new_rgn = &memblock.reserved.regions[0];
	struct memblock_region *req_node = &memblock.memory.regions[nid_req];
	struct memblock_region *next_node = &memblock.memory.regions[nid_next];
	void *allocated_ptr = NULL;
	struct region r1, r2;
	phys_addr_t size = req_node->size;
	phys_addr_t total_size;
	phys_addr_t max_addr;
	phys_addr_t min_addr;
	PREFIX_PUSH();
	r1.base = next_node->base;
	r1.size = SZ_128;
	r2.size = SZ_128;
	r2.base = r1.base - (size + r2.size);
	total_size = r1.size + r2.size + size;
	min_addr = r2.base + r2.size;
	max_addr = r1.base;
	memblock_reserve(r1.base, r1.size);
	memblock_reserve(r2.base, r2.size);
	allocated_ptr = memblock_alloc_exact_nid_raw(size, SMP_CACHE_BYTES,
						     min_addr, max_addr,
						     nid_req);
	ASSERT_NE(allocated_ptr, NULL);
	ASSERT_MEM_NE(allocated_ptr, 0, size);
	ASSERT_EQ(new_rgn->size, total_size);
	ASSERT_EQ(new_rgn->base, r2.base);
	ASSERT_LE(new_rgn->base, req_node->base);
	ASSERT_LE(region_end(req_node), region_end(new_rgn));
	ASSERT_EQ(memblock.reserved.cnt, 1);
	ASSERT_EQ(memblock.reserved.total_size, total_size);
	test_pass_pop();
	return 0;
}
