static int matroska_parse_block(MatroskaDemuxContext *matroska, AVBufferRef *buf, uint8_t *data,
                                int size, int64_t pos, uint64_t cluster_time,
                                uint64_t block_duration, int is_keyframe,
                                MatroskaBlockMore *blockmore, int nb_blockmore,
                                int64_t cluster_pos, int64_t discard_padding)
{
    uint64_t timecode = AV_NOPTS_VALUE;
    MatroskaTrack *track;
    FFIOContext pb;
    int res = 0;
    AVStream *st;
    int16_t block_time;
    uint32_t lace_size[256];
    int n, flags, laces = 0;
    uint64_t num;
    int trust_default_duration;
    ffio_init_read_context(&pb, data, size);
    if ((n = ebml_read_num(matroska, &pb.pub, 8, &num, 1)) < 0)
        return n;
    data += n;
    size -= n;
    track = matroska_find_track_by_num(matroska, num);
    if (!track || size < 3)
        return AVERROR_INVALIDDATA;
    if (!(st = track->stream)) {
        av_log(matroska->ctx, AV_LOG_VERBOSE,
               "No stream associated to TrackNumber %"PRIu64". "
               "Ignoring Block with this TrackNumber.\n", num);
        return 0;
    }
    if (st->discard >= AVDISCARD_ALL)
        return res;
    if (block_duration > INT64_MAX)
        block_duration = INT64_MAX;
    block_time = sign_extend(AV_RB16(data), 16);
    data      += 2;
    flags      = *data++;
    size      -= 3;
    if (is_keyframe == -1)
        is_keyframe = flags & 0x80 ? AV_PKT_FLAG_KEY : 0;
    if (cluster_time != (uint64_t) -1 &&
        (block_time >= 0 || cluster_time >= -block_time)) {
        uint64_t timecode_cluster_in_track_tb = (double) cluster_time / track->time_scale;
        timecode = timecode_cluster_in_track_tb + block_time - track->codec_delay_in_track_tb;
        if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE &&
            timecode < track->end_timecode)
            is_keyframe = 0;  /* overlapping subtitles are not key frame */
        if (is_keyframe) {
            ff_reduce_index(matroska->ctx, st->index);
            av_add_index_entry(st, cluster_pos, timecode, 0, 0,
                               AVINDEX_KEYFRAME);
        }
    }
    if (matroska->skip_to_keyframe &&
        track->type != MATROSKA_TRACK_TYPE_SUBTITLE) {
        // Compare signed timecodes. Timecode may be negative due to codec delay
        // offset. We don't support timestamps greater than int64_t anyway - see
        // AVPacket's pts.
        if ((int64_t)timecode < (int64_t)matroska->skip_to_timecode)
            return res;
        if (is_keyframe)
            matroska->skip_to_keyframe = 0;
        else if (!ffstream(st)->skip_to_keyframe) {
            av_log(matroska->ctx, AV_LOG_ERROR, "File is broken, keyframes not correctly marked!\n");
            matroska->skip_to_keyframe = 0;
        }
    }
    res = matroska_parse_laces(matroska, &data, size, (flags & 0x06) >> 1,
                               &pb.pub, lace_size, &laces);
    if (res < 0) {
        av_log(matroska->ctx, AV_LOG_ERROR, "Error parsing frame sizes.\n");
        return res;
    }
    trust_default_duration = track->default_duration != 0;
    if (track->audio.samplerate == 8000 && trust_default_duration) {
        // If this is needed for more codecs, then add them here
        if (st->codecpar->codec_id == AV_CODEC_ID_AC3) {
            if (track->audio.samplerate != st->codecpar->sample_rate || !st->codecpar->frame_size)
                trust_default_duration = 0;
        }
    }
    if (!block_duration && trust_default_duration)
        block_duration = track->default_duration * laces / matroska->time_scale;
    if (cluster_time != (uint64_t)-1 && (block_time >= 0 || cluster_time >= -block_time))
        track->end_timecode =
            FFMAX(track->end_timecode, timecode + block_duration);
    for (n = 0; n < laces; n++) {
        int64_t lace_duration = block_duration*(n+1) / laces - block_duration*n / laces;
        uint8_t *out_data = data;
        int      out_size = lace_size[n];
        if (track->needs_decoding) {
            res = matroska_decode_buffer(&out_data, &out_size, track);
            if (res < 0)
                return res;
            /* Given that we are here means that out_data is no longer
             * owned by buf, so set it to NULL. This depends upon
             * zero-length header removal compression being ignored. */
            av_assert1(out_data != data);
            buf = NULL;
        }
        if (track->audio.buf) {
            res = matroska_parse_rm_audio(matroska, track, st,
                                          out_data, out_size,
                                          timecode, pos);
            if (!buf)
                av_free(out_data);
            if (res)
                return res;
        } else if (st->codecpar->codec_id == AV_CODEC_ID_WEBVTT) {
            res = matroska_parse_webvtt(matroska, track, st,
                                        out_data, out_size,
                                        timecode, lace_duration,
                                        pos);
            if (!buf)
                av_free(out_data);
            if (res)
                return res;
        } else {
            res = matroska_parse_frame(matroska, track, st, buf, out_data,
                                       out_size, timecode, lace_duration,
                                       pos, !n ? is_keyframe : 0,
                                       blockmore, nb_blockmore,
                                       discard_padding);
            if (res)
                return res;
        }
        if (timecode != AV_NOPTS_VALUE)
            timecode = lace_duration ? timecode + lace_duration : AV_NOPTS_VALUE;
        data += lace_size[n];
    }
    return 0;
}
