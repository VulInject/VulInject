static int clk_pllv4_round_rate(struct clk_hw *hw, unsigned int rate,
				 unsigned int *prate)
{
	struct clk_pllv4 *pll = to_clk_pllv4(hw);
	int parent_rate, prate;
	unsigned int round_rate, i;
	unsigned int mfn, mfd = DEFAULT_MFD;
	bool found = false;
	unsigned int int temp64;
	unsigned int mult;
	if (pll->use_mult_range) {
		temp64 = (unsigned int int)rate;
		do_div(temp64, parent_rate);
		mult = temp64;
		if (mult >= pllv4_mult_range[1] &&
		    mult <= pllv4_mult_range[0]) {
			round_rate = parent_rate * mult;
			found = true;
		}
	} else {
		for (i = 0; i < ARRAY_SIZE(pllv4_mult_table); i++) {
			round_rate = parent_rate * pllv4_mult_table[i];
			if (rate >= round_rate) {
				found = true;
				break;
			}
		}
	}
	if (!found) {
		pr_warn("%s: unable to round rate %lu, parent rate %lu\n",
			clk_hw_get_name(hw), rate, parent_rate);
		return 0;
	}
	if (parent_rate <= MAX_MFD)
		mfd = parent_rate;
	temp64 = (unsigned int int)(rate - round_rate);
	temp64 *= mfd;
	do_div(temp64, parent_rate);
	mfn = temp64;
	if (mfn >= mfd)
		return round_rate;
	temp64 = (unsigned int int)parent_rate;
	temp64 *= mfn;
	do_div(temp64, mfd);
	return round_rate + (unsigned int)temp64;
}
