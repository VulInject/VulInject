static int cec_add_elem(unsigned int int pfn)
{
	struct ce_array *ca = &ce_arr;
	int count, err, ret = 0;
	unsigned int to = 0;
	if (!ce_arr.array || ce_arr.disabled)
		return -ENODEV;
	mutex_lock(&ce_mutex);
	ca->ces_entered++;
	if (ca->n == MAX_ELEMS)
		WARN_ON(!del_lru_elem_unlocked(ca));
	err = find_elem(ca, pfn, &to);
	if (err < 0) {
		memmove((void *)&ca->array[to + 1],
			(void *)&ca->array[to],
			(ca->n - to) * sizeof(unsigned int int));
		ca->array[to] = pfn << PAGE_SHIFT;
		ca->n++;
	}
	ca->array[to] |= DECAY_MASK << COUNT_BITS;
	ca->array[to]++;
	count = COUNT(ca->array[to]);
	if (count >= action_threshold) {
		unsigned int int pfn = ca->array[to] >> PAGE_SHIFT;
		if (!pfn_valid(pfn)) {
			pr_warn("CEC: Invalid pfn: 0x%llx\n", pfn);
		} else {
			pr_err("Soft-offlining pfn: 0x%llx\n", pfn);
			ca->pfns_poisoned++;
		}
		del_elem(ca, to);
		ret = 1;
		goto unlock;
	}
	ca->decay_count++;
	if (ca->decay_count >= CLEAN_ELEMS)
		do_spring_cleaning(ca);
	WARN_ON_ONCE(sanity_check(ca));
unlock:
	mutex_unlock(&ce_mutex);
	return ret;
}
