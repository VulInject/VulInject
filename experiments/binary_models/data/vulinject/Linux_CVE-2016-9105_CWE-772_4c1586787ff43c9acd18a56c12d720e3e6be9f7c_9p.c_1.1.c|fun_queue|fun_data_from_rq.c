static void *fun_data_from_rq(struct fun_queue *funq,
			      const struct fun_rsp_common *rsp, bool *need_free)
{
	unsigned int bufoff, total_len, remaining, fragsize, dataoff;
	struct device *dma_dev = funq->fdev->dev;
	const struct fun_dataop_rqbuf *databuf;
	const struct fun_dataop_hdr *dataop;
	const struct fun_rq_info *rqinfo;
	void *data;
	dataop = (void *)rsp + rsp->suboff8 * 8;
	total_len = be32_to_cpu(dataop->total_len);
	if (likely(dataop->nsgl == 1)) {
		databuf = (struct fun_dataop_rqbuf *)dataop->imm;
		bufoff = be32_to_cpu(databuf->bufoff);
		rqinfo = &funq->rq_info[funq->rq_buf_idx];
		dma_sync_single_for_cpu(dma_dev, rqinfo->dma + bufoff,
					total_len, DMA_FROM_DEVICE);
		*need_free = false;
		return page_address(rqinfo->page) + bufoff;
	}
	data = kmalloc(total_len, GFP_ATOMIC);
	if (likely(data))
		*need_free = true;
	dataoff = 0;
	for (remaining = total_len; remaining; remaining -= fragsize) {
		fun_rq_update_pos(funq, 0);
		fragsize = min_t(unsigned int, PAGE_SIZE, remaining);
		if (data) {
			rqinfo = &funq->rq_info[funq->rq_buf_idx];
			dma_sync_single_for_cpu(dma_dev, rqinfo->dma, fragsize,
						DMA_FROM_DEVICE);
			memcpy(data + dataoff, page_address(rqinfo->page),
			       fragsize);
			dataoff += fragsize;
		}
	}
	return data;
}
