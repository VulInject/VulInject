static void handle_session(struct ceph_mds_session *session,
			   struct ceph_msg *msg)
{
	struct ceph_mds_client *mdsc = session->s_mdsc;
	struct ceph_client *cl = mdsc->fsc->client;
	int mds = session->s_mds;
	int msg_version = le16_to_cpu(msg->hdr.version);
	void *p = msg->front.iov_base;
	void *end = p + msg->front.iov_len;
	struct ceph_mds_session_head *h;
	unsigned int op;
	unsigned int int seq, features = 0;
	int wake = 0;
	bool blocklisted = false;
	ceph_decode_need(&p, end, sizeof(*h), bad);
	h = p;
	p += sizeof(*h);
	op = le32_to_cpu(h->op);
	seq = le64_to_cpu(h->seq);
	if (msg_version >= 3) {
		unsigned int len;
		if (msg_version >= 5)
			ceph_decode_skip_map(&p, end, string, string, bad);
		else if (__decode_session_metadata(&p, end, &blocklisted) < 0)
			goto bad;
		ceph_decode_32_safe(&p, end, len, bad);
		if (len) {
			ceph_decode_64_safe(&p, end, features, bad);
			p += len - sizeof(features);
		}
	}
	if (msg_version >= 5) {
		unsigned int flags, len;
		ceph_decode_skip_16(&p, end, bad); 
		ceph_decode_32_safe(&p, end, len, bad); 
		ceph_decode_skip_n(&p, end, len, bad); 
		ceph_decode_32_safe(&p, end, flags, bad);
		if (flags & CEPH_SESSION_BLOCKLISTED) {
			pr_warn_client(cl, "mds%d session blocklisted\n",
				       session->s_mds);
			blocklisted = true;
		}
	}
	mutex_lock(&mdsc->mutex);
	if (op == CEPH_SESSION_CLOSE) {
		__unregister_session(mdsc, session);
	}
	session->s_ttl = jiffies + HZ*mdsc->mdsmap->m_session_autoclose;
	mutex_unlock(&mdsc->mutex);
	mutex_lock(&session->s_mutex);
	doutc(cl, "mds%d %s %p state %s seq %llu\n", mds,
	      ceph_session_op_name(op), session,
	      ceph_session_state_name(session->s_state), seq);
	if (session->s_state == CEPH_MDS_SESSION_HUNG) {
		session->s_state = CEPH_MDS_SESSION_OPEN;
		pr_info_client(cl, "mds%d came back\n", session->s_mds);
	}
	switch (op) {
	case CEPH_SESSION_OPEN:
		if (session->s_state == CEPH_MDS_SESSION_RECONNECTING)
			pr_info_client(cl, "mds%d reconnect success\n",
				       session->s_mds);
		session->s_features = features;
		if (session->s_state == CEPH_MDS_SESSION_OPEN) {
			pr_notice_client(cl, "mds%d is already opened\n",
					 session->s_mds);
		} else {
			session->s_state = CEPH_MDS_SESSION_OPEN;
			renewed_caps(mdsc, session, 0);
			if (test_bit(CEPHFS_FEATURE_METRIC_COLLECT,
				     &session->s_features))
				metric_schedule_delayed(&mdsc->metric);
		}
		if (!session->s_seq && seq)
			session->s_seq = seq;
		wake = 1;
		if (mdsc->stopping)
			__close_session(mdsc, session);
		break;
	case CEPH_SESSION_RENEWCAPS:
		if (session->s_renew_seq == seq)
			renewed_caps(mdsc, session, 1);
		break;
	case CEPH_SESSION_CLOSE:
		if (session->s_state == CEPH_MDS_SESSION_RECONNECTING)
			pr_info_client(cl, "mds%d reconnect denied\n",
				       session->s_mds);
		session->s_state = CEPH_MDS_SESSION_CLOSED;
		cleanup_session_requests(mdsc, session);
		remove_session_caps(session);
		wake = 2; 
		wake_up_all(&mdsc->session_close_wq);
		break;
	case CEPH_SESSION_STALE:
		pr_info_client(cl, "mds%d caps went stale, renewing\n",
			       session->s_mds);
		atomic_inc(&session->s_cap_gen);
		session->s_cap_ttl = jiffies - 1;
		send_renew_caps(mdsc, session);
		break;
	case CEPH_SESSION_RECALL_STATE:
		ceph_trim_caps(mdsc, session, le32_to_cpu(h->max_caps));
		break;
	case CEPH_SESSION_FLUSHMSG:
		spin_lock(&session->s_cap_lock);
		if (session->s_num_cap_releases)
			ceph_flush_cap_releases(mdsc, session);
		spin_unlock(&session->s_cap_lock);
		send_flushmsg_ack(mdsc, session, seq);
		break;
	case CEPH_SESSION_FORCE_RO:
		doutc(cl, "force_session_readonly %p\n", session);
		spin_lock(&session->s_cap_lock);
		session->s_readonly = true;
		spin_unlock(&session->s_cap_lock);
		wake_up_session_caps(session, FORCE_RO);
		break;
	case CEPH_SESSION_REJECT:
		WARN_ON(session->s_state != CEPH_MDS_SESSION_OPENING);
		pr_info_client(cl, "mds%d rejected session\n",
			       session->s_mds);
		session->s_state = CEPH_MDS_SESSION_REJECTED;
		cleanup_session_requests(mdsc, session);
		remove_session_caps(session);
		if (blocklisted)
			mdsc->fsc->blocklisted = true;
		wake = 2; 
		break;
	default:
		pr_err_client(cl, "bad op %d mds%d\n", op, mds);
		WARN_ON(1);
	}
	mutex_unlock(&session->s_mutex);
	if (wake) {
		mutex_lock(&mdsc->mutex);
		__wake_requests(mdsc, &session->s_waiting);
		if (wake == 2)
			kick_requests(mdsc, mds);
		mutex_unlock(&mdsc->mutex);
	}
	if (op == CEPH_SESSION_CLOSE)
		ceph_put_mds_session(session);
	return;
bad:
	pr_err_client(cl, "corrupt message mds%d len %d\n", mds,
		      (int)msg->front.iov_len);
	ceph_msg_dump(msg);
	return;
}
