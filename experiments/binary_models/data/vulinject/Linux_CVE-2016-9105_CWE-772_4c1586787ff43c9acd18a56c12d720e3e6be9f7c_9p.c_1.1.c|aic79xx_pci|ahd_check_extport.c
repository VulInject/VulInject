ahd_check_extport(struct ahd_softc *ahd)
{
	struct	vpd_config vpd;
	struct	seeprom_config *sc;
	unsigned int	adapter_control;
	int	have_seeprom;
	int	error;
	sc = ahd->seep_config;
	have_seeprom = ahd_acquire_seeprom(ahd);
	if (have_seeprom) {
		unsigned int start_addr;
		if (bootverbose) 
			printk("%s: Reading VPD from SEEPROM...",
			       ahd_name(ahd));
		start_addr = ((2 * sizeof(*sc))
			    + (sizeof(vpd) * (ahd->channel - 'A'))) / 2;
		error = ahd_read_seeprom(ahd, (unsigned short *)&vpd,
					 start_addr, sizeof(vpd)/2,
					 TRUE);
		if (error == 0)
			error = ahd_parse_vpddata(ahd, &vpd);
		if (bootverbose) 
			printk("%s: VPD parsing %s\n",
			       ahd_name(ahd),
			       error == 0 ? "successful" : "failed");
		if (bootverbose) 
			printk("%s: Reading SEEPROM...", ahd_name(ahd));
		start_addr = (sizeof(*sc) / 2) * (ahd->channel - 'A');
		error = ahd_read_seeprom(ahd, (unsigned short *)sc,
					 start_addr, sizeof(*sc)/2,
					 FALSE);
		if (error != 0) {
			printk("Unable to read SEEPROM\n");
			have_seeprom = 0;
		} else {
			have_seeprom = ahd_verify_cksum(sc);
			if (bootverbose) {
				if (have_seeprom == 0)
					printk ("checksum error\n");
				else
					printk ("done.\n");
			}
		}
		ahd_release_seeprom(ahd);
	}
	if (!have_seeprom) {
		unsigned int	  nvram_scb;
		ahd_set_scbptr(ahd, 0xFF);
		nvram_scb = ahd_inb_scbram(ahd, SCB_BASE + NVRAM_SCB_OFFSET);
		if (nvram_scb != 0xFF
		 && ((ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'
		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'D'
		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'
		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'T')
		  || (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'B'
		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'I'
		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'O'
		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'S')
		  || (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'
		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'S'
		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'
		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'I'))) {
			unsigned short *sc_data;
			int	  i;
			sc_data = (unsigned short *)sc;
			for (i = 0; i < 64; i += 2)
				*sc_data++ = ahd_inw_scbram(ahd, SCB_BASE+i);
			have_seeprom = ahd_verify_cksum(sc);
			if (have_seeprom)
				ahd->flags |= AHD_SCB_CONFIG_USED;
		}
	}
#ifdef AHD_DEBUG
	if (have_seeprom != 0
	 && (ahd_debug & AHD_DUMP_SEEPROM) != 0) {
		unsigned short *sc_data;
		int	  i;
		printk("%s: Seeprom Contents:", ahd_name(ahd));
		sc_data = (unsigned short *)sc;
		for (i = 0; i < (sizeof(*sc)); i += 2)
			printk("\n\t0x%.4x", sc_data[i]);
		printk("\n");
	}
#endif
	if (!have_seeprom) {
		if (bootverbose)
			printk("%s: No SEEPROM available.\n", ahd_name(ahd));
		ahd->flags |= AHD_USEDEFAULTS;
		error = ahd_default_config(ahd);
		adapter_control = CFAUTOTERM|CFSEAUTOTERM;
		kfree(ahd->seep_config);
		ahd->seep_config = NULL;
	} else {
		error = ahd_parse_cfgdata(ahd, sc);
		adapter_control = sc->adapter_control;
	}
	if (error != 0)
		return (error);
	ahd_configure_termination(ahd, adapter_control);
	return (0);
}
