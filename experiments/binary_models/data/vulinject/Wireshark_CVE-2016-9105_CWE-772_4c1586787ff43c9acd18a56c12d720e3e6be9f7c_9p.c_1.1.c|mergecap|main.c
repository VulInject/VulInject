main(int argc, char *argv[])
{
    char               *configuration_init_error;
    static const struct report_message_routines mergecap_report_routines = {
        failure_message,
        failure_message,
        open_failure_message,
        read_failure_message,
        write_failure_message,
        cfile_open_failure_message,
        cfile_dump_open_failure_message,
        cfile_read_failure_message,
        cfile_write_failure_message,
        cfile_close_failure_message
    };
    int                 opt;
    static const struct ws_option long_options[] = {
        {"help", ws_no_argument, NULL, 'h'},
        {"version", ws_no_argument, NULL, 'v'},
        {0, 0, 0, 0 }
    };
    gboolean            do_append          = FALSE;
    gboolean            verbose            = FALSE;
    int                 in_file_count      = 0;
    guint32             snaplen            = 0;
    int                 file_type          = WTAP_FILE_TYPE_SUBTYPE_UNKNOWN;
    int                 err                = 0;
    gchar              *err_info           = NULL;
    int                 err_fileno;
    guint32             err_framenum;
    char               *out_filename       = NULL;
    merge_result        status             = MERGE_OK;
    idb_merge_mode      mode               = IDB_MERGE_MODE_MAX;
    merge_progress_callback_t cb;
    ws_log_init("mergecap", vcmdarg_err);
    ws_log_parse_args(&argc, argv, vcmdarg_err, 1);
    ws_noisy("Finished log init and parsing command line log arguments");
#ifdef _WIN32
    create_app_running_mutex();
#endif 
    ws_init_version_info("Mergecap", NULL, NULL);
    init_process_policies();
    configuration_init_error = configuration_init(argv[0], NULL);
    if (configuration_init_error != NULL) {
        fprintf(stderr,
                "mergecap: Can't get pathname of directory containing the mergecap program: %s.\n",
                configuration_init_error);
        g_free(configuration_init_error);
    }
    init_report_message("mergecap", &mergecap_report_routines);
    wtap_init(TRUE);
    while ((opt = ws_getopt_long(argc, argv, "aF:hI:s:vVw:", long_options, NULL)) != -1) {
        switch (opt) {
            case 'a':
                do_append = !do_append;
                break;
            case 'F':
                file_type = wtap_name_to_file_type_subtype(ws_optarg);
                if (file_type < 0) {
                    fprintf(stderr, "mergecap: \"%s\" isn't a valid capture file type\n",
                            ws_optarg);
                    list_capture_types();
                    status = MERGE_ERR_INVALID_OPTION;
                    goto clean_exit;
                }
                break;
            case 'h':
                show_help_header("Merge two or more capture files into one.");
                print_usage(stdout);
                goto clean_exit;
                break;
            case 'I':
                mode = merge_string_to_idb_merge_mode(ws_optarg);
                if (mode == IDB_MERGE_MODE_MAX) {
                    fprintf(stderr, "mergecap: \"%s\" isn't a valid IDB merge mode\n",
                            ws_optarg);
                    list_idb_merge_modes();
                    status = MERGE_ERR_INVALID_OPTION;
                    goto clean_exit;
                }
                break;
            case 's':
                snaplen = get_nonzero_guint32(ws_optarg, "snapshot length");
                break;
            case 'V':
                verbose = TRUE;
                break;
            case 'v':
                show_version();
                goto clean_exit;
                break;
            case 'w':
                out_filename = ws_optarg;
                break;
            case '?':              
                switch(ws_optopt) {
                    case'F':
                        list_capture_types();
                        break;
                    case'I':
                        list_idb_merge_modes();
                        break;
                    default:
                        print_usage(stderr);
                }
                status = MERGE_ERR_INVALID_OPTION;
                goto clean_exit;
                break;
        }
    }
    if (file_type == WTAP_FILE_TYPE_SUBTYPE_UNKNOWN)
        file_type = wtap_pcapng_file_type_subtype();
    cb.callback_func = merge_callback;
    cb.data = NULL;
    in_file_count = argc - ws_optind;
    if (!out_filename) {
        fprintf(stderr, "mergecap: an output filename must be set with -w\n");
        fprintf(stderr, "          run with -h for help\n");
        status = MERGE_ERR_INVALID_OPTION;
        goto clean_exit;
    }
    if (in_file_count < 1) {
        fprintf(stderr, "mergecap: No input files were specified\n");
        return 1;
    }
    if (mode != IDB_MERGE_MODE_MAX &&
            wtap_file_type_subtype_supports_block(file_type, WTAP_BLOCK_IF_ID_AND_INFO) == BLOCK_NOT_SUPPORTED) {
        fprintf(stderr, "The IDB merge mode can only be used with an output format that identifies interfaces\n");
        status = MERGE_ERR_INVALID_OPTION;
        goto clean_exit;
    }
    if (mode == IDB_MERGE_MODE_MAX) {
        mode = IDB_MERGE_MODE_ALL_SAME;
    }
    if (strcmp(out_filename, "-") == 0) {
        status = merge_files_to_stdout(file_type,
                (const char *const *) &argv[ws_optind],
                in_file_count, do_append, mode, snaplen,
                get_appname_and_version(),
                verbose ? &cb : NULL,
                &err, &err_info, &err_fileno, &err_framenum);
    } else {
        status = merge_files(out_filename, file_type,
                (const char *const *) &argv[ws_optind], in_file_count,
                do_append, mode, snaplen, get_appname_and_version(),
                verbose ? &cb : NULL,
                &err, &err_info, &err_fileno, &err_framenum);
    }
    switch (status) {
        case MERGE_OK:
            break;
        case MERGE_USER_ABORTED:
            ws_assert_not_reached();
            break;
        case MERGE_ERR_CANT_OPEN_INFILE:
            cfile_open_failure_message(argv[ws_optind + err_fileno], err, err_info);
            break;
        case MERGE_ERR_CANT_OPEN_OUTFILE:
            cfile_dump_open_failure_message(out_filename, err, err_info, file_type);
            break;
        case MERGE_ERR_CANT_READ_INFILE:
            cfile_read_failure_message(argv[ws_optind + err_fileno], err, err_info);
            break;
        case MERGE_ERR_BAD_PHDR_INTERFACE_ID:
            cmdarg_err("Record %u of \"%s\" has an interface ID that does not match any IDB in its file.",
                    err_framenum, argv[ws_optind + err_fileno]);
            break;
        case MERGE_ERR_CANT_WRITE_OUTFILE:
            cfile_write_failure_message(argv[ws_optind + err_fileno], out_filename,
                    err, err_info, err_framenum, file_type);
            break;
        case MERGE_ERR_CANT_CLOSE_OUTFILE:
            cfile_close_failure_message(out_filename, err, err_info);
            break;
        case MERGE_ERR_INVALID_OPTION:
            if (err_info) {
                cmdarg_err("%s", err_info);
            }
            else {
                cmdarg_err("Unspecified error with merge option");
            }
            break;
        default:
            cmdarg_err("Unknown merge_files error %d", status);
            break;
    }
clean_exit:
    wtap_cleanup();
    free_progdirs();
    return (status == MERGE_OK) ? 0 : 2;
}
