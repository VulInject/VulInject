blf_read_apptextmessage(blf_params_t *params, int *err, char **err_info, int int block_start, int int data_start, int int object_length, unsigned int flags, unsigned int int object_timestamp, size_t metadata_cont) {
    blf_apptext_t            apptextheader;
    if (object_length < (data_start - block_start) + (int)sizeof(apptextheader)) {
        *err = WTAP_ERR_BAD_FILE;
        *err_info = ws_strdup_printf("blf: APP_TEXT: not enough bytes for apptext header in object");
        ws_debug("not enough bytes for apptext header in object");
        return BLF_APPTEXT_FAILED;
    }
    if (!blf_read_bytes(params, data_start, &apptextheader, sizeof(apptextheader), err, err_info)) {
        ws_debug("not enough bytes for apptext header in file");
        return BLF_APPTEXT_FAILED;
    }
    fix_endianness_blf_apptext_header(&apptextheader);
    if (metadata_cont && apptextheader.source != BLF_APPTEXT_METADATA) {
        metadata_cont = 0;
    }
    char* text = g_try_malloc((size_t)apptextheader.textLength + 1);
    if (!blf_read_bytes(params, data_start + sizeof(apptextheader), text, apptextheader.textLength, err, err_info)) {
        ws_debug("not enough bytes for apptext text in file");
        return BLF_APPTEXT_FAILED;
    }
    text[apptextheader.textLength] = '\0'; 
    switch (apptextheader.source) {
    case BLF_APPTEXT_CHANNEL:
    {
        char** tokens = g_strsplit_set(text, ";", -1);
        if (tokens == NULL || tokens[0] == NULL || tokens[1] == NULL) {
            if (tokens != NULL) {
                g_strfreev(tokens);
            }
            g_free(text);
            return BLF_APPTEXT_CHANNEL;
        }
        unsigned short channel = (apptextheader.reservedAppText1 >> 8) & 0xff;
        int pkt_encap;
        switch ((apptextheader.reservedAppText1 >> 16) & 0xff) {
        case BLF_BUSTYPE_CAN:
            pkt_encap = WTAP_ENCAP_SOCKETCAN;
            break;
        case BLF_BUSTYPE_FLEXRAY:
            pkt_encap = WTAP_ENCAP_FLEXRAY;
            break;
        case BLF_BUSTYPE_LIN:
            pkt_encap = WTAP_ENCAP_LIN;
            break;
        case BLF_BUSTYPE_ETHERNET:
            pkt_encap = WTAP_ENCAP_ETHERNET;
            break;
        case BLF_BUSTYPE_WLAN:
            pkt_encap = WTAP_ENCAP_IEEE_802_11;
            break;
        default:
            pkt_encap = 0xffffffff;
        }
        blf_prepare_interface_name(params, pkt_encap, channel, UINT16_MAX, tokens[1], false);
        g_strfreev(tokens);
        g_free(text);
        return BLF_APPTEXT_CHANNEL;
        break;
    }
    case BLF_APPTEXT_METADATA:
        if (metadata_cont) {
            params->buf->first_free = metadata_cont;
        }
        else {
            wtap_buffer_append_epdu_string(params->buf, EXP_PDU_TAG_DISSECTOR_NAME, "data-text-lines");
            wtap_buffer_append_epdu_string(params->buf, EXP_PDU_TAG_COL_PROT_TEXT, "BLF App text");
            wtap_buffer_append_epdu_string(params->buf, EXP_PDU_TAG_COL_INFO_TEXT, "Metadata");
            wtap_buffer_append_epdu_end(params->buf);
        }
        ws_buffer_assure_space(params->buf, apptextheader.textLength);
        ws_buffer_append(params->buf, text, apptextheader.textLength);
        g_free(text);
        if ((apptextheader.reservedAppText1 & 0x00ffffff) > apptextheader.textLength) {
            return BLF_APPTEXT_CONT;
        }
        if (((apptextheader.reservedAppText1 >> 24) & 0xff) == BLF_APPTEXT_XML_CHANNELS) {
            blf_set_xml_channels(params, params->buf->data, ws_buffer_length(params->buf));
        }
        blf_init_rec(params, flags, object_timestamp, WTAP_ENCAP_WIRESHARK_UPPER_PDU, 0, UINT16_MAX, (unsigned int)ws_buffer_length(params->buf), (unsigned int)ws_buffer_length(params->buf));
        return BLF_APPTEXT_METADATA;
        break;
    case BLF_APPTEXT_COMMENT:
    case BLF_APPTEXT_ATTACHMENT:
    case BLF_APPTEXT_TRACELINE:
    {
        wtap_buffer_append_epdu_string(params->buf, EXP_PDU_TAG_DISSECTOR_NAME, "data-text-lines");
        wtap_buffer_append_epdu_string(params->buf, EXP_PDU_TAG_COL_PROT_TEXT, "BLF App text");
        char* info_line = NULL;
        switch (apptextheader.source) {
        case BLF_APPTEXT_COMMENT:
            info_line = ws_strdup_printf("Comment: %s", text);
            break;
        case BLF_APPTEXT_ATTACHMENT:
            info_line = ws_strdup_printf("Attachment: %s", text);
            break;
        case BLF_APPTEXT_TRACELINE:
            info_line = ws_strdup_printf("Trace line%s: %s", (apptextheader.reservedAppText1 & 0x00000010) ? "" : " (hidden)", text);
            break;
        default:
            break;
        }
        wtap_buffer_append_epdu_string(params->buf, EXP_PDU_TAG_COL_INFO_TEXT, info_line);
        wtap_buffer_append_epdu_end(params->buf);
        size_t text_length = strlen(text);  
        ws_buffer_assure_space(params->buf, text_length); 
        ws_buffer_append(params->buf, text, text_length);
        blf_init_rec(params, flags, object_timestamp, WTAP_ENCAP_WIRESHARK_UPPER_PDU, 0, UINT16_MAX, (unsigned int)ws_buffer_length(params->buf), (unsigned int)ws_buffer_length(params->buf));
        g_free(text);
        if (info_line) {
            g_free(info_line);
        }
        return apptextheader.source;
        break;
    }
    default:
        g_free(text);
        return BLF_APPTEXT_CHANNEL; ;
        break;
    }
    return BLF_APPTEXT_CHANNEL; 
}
