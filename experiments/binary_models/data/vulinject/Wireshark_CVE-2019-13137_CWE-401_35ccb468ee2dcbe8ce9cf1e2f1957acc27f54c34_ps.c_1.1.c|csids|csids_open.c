wtap_open_return_val csids_open(wtap *wth, int *err, char **err_info)
{
  int tmp,iplen;
  bool byteswap = false;
  struct csids_header hdr;
  csids_t *csids;
  if( !wtap_read_bytes( wth->fh, &hdr, sizeof( struct csids_header), err, err_info ) ) {
    if( *err != WTAP_ERR_SHORT_READ ) {
      return WTAP_OPEN_ERROR;
    }
    return WTAP_OPEN_NOT_MINE;
  }
  if( hdr.zeropad != 0 || hdr.caplen == 0 ) {
    return WTAP_OPEN_NOT_MINE;
  }
  hdr.seconds = pntoh32( &hdr.seconds );
  hdr.caplen = pntoh16( &hdr.caplen );
  if( !wtap_read_bytes( wth->fh, &tmp, 2, err, err_info ) ) {
    if( *err != WTAP_ERR_SHORT_READ ) {
      return WTAP_OPEN_ERROR;
    }
    return WTAP_OPEN_NOT_MINE;
  }
  if( !wtap_read_bytes(wth->fh, &iplen, 2, err, err_info ) ) {
    if( *err != WTAP_ERR_SHORT_READ ) {
      return WTAP_OPEN_ERROR;
    }
    return WTAP_OPEN_NOT_MINE;
  }
  iplen = pntoh16(&iplen);
  if ( iplen == 0 )
    return WTAP_OPEN_NOT_MINE;
  if( iplen > hdr.caplen ) {
    if( iplen <= hdr.caplen ) {
      byteswap = true;
    } else {
      return WTAP_OPEN_NOT_MINE;
    }
  } else {
    byteswap = false;
  }
  if (file_seek(wth->fh, 0, SEEK_SET, err) == -1)
    return WTAP_OPEN_ERROR;
  csids = g_new(csids_t, 1);
  wth->priv = (void *)csids;
  csids->byteswapped = byteswap;
  wth->file_encap = WTAP_ENCAP_RAW_IP;
  wth->file_type_subtype = csids_file_type_subtype;
  wth->snapshot_length = 0; 
  wth->subtype_read = csids_read;
  wth->subtype_seek_read = csids_seek_read;
  wth->file_tsprec = WTAP_TSPREC_SEC;
  wtap_add_generated_idb(wth);
  return WTAP_OPEN_MINE;
}
