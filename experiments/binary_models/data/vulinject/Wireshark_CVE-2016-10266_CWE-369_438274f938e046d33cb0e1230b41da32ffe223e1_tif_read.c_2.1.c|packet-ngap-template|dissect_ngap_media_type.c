dissect_ngap_media_type(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
  int ret;
  char *json_data;
  const char *n2_info_class;
  jsmntok_t *tokens, *cur_tok;
  dissector_handle_t subdissector = NULL;
  tvbuff_t* json_tvb = (tvbuff_t*)p_get_proto_data(pinfo->pool, pinfo, proto_json, 0);
  media_content_info_t *content_info = (media_content_info_t *)data;
  if (!json_tvb || !content_info || !content_info->content_id)
    return 0;
  json_data = tvb_get_string_enc(pinfo->pool, json_tvb, 0, tvb_reported_length(json_tvb), ENC_UTF_8|ENC_NA);
  ret = json_parse(json_data, NULL, 0);
  if (ret <= 0)
    return 0;
  tokens = wmem_alloc_array(pinfo->pool, jsmntok_t, ret);
  if (json_parse(json_data, tokens, ret) <= 0)
    return 0;
  cur_tok = json_get_object(json_data, tokens, "n2InfoContainer");
  if (!cur_tok) {
      cur_tok = json_get_object(json_data, tokens, "n2Information");
  }
  if (cur_tok) {
    n2_info_class = json_get_string(json_data, cur_tok, "n2InformationClass");
    if (n2_info_class) {
      if (!strcmp(n2_info_class, "SM")) {
        cur_tok = json_get_object(json_data, cur_tok, "smInfo");
        if (cur_tok && find_n2_info_content(json_data, cur_tok, "n2InfoContent",
                                            content_info->content_id, &subdissector))
          goto found;
      }
      if (!strcmp(n2_info_class, "RAN")) {
        cur_tok = json_get_object(json_data, cur_tok, "ranInfo");
        if (cur_tok && find_n2_info_content(json_data, cur_tok, "n2InfoContent",
                                            content_info->content_id, &subdissector))
          goto found;
      }
      if (!strcmp(n2_info_class, "NRPPa")) {
        cur_tok = json_get_object(json_data, cur_tok, "nrppaInfo");
        if (cur_tok && find_n2_info_content(json_data, cur_tok, "nrppaPdu",
                                            content_info->content_id, &subdissector))
          goto found;
      }
      if (!strcmp(n2_info_class, "PWS") ||
          !strcmp(n2_info_class, "PWS-BCAL") ||
          !strcmp(n2_info_class, "PWS-RF")) {
        cur_tok = json_get_object(json_data, cur_tok, "pwsInfo");
        if (cur_tok && find_n2_info_content(json_data, cur_tok, "pwsContainer",
                                            content_info->content_id, &subdissector))
          goto found;
      }
    }
  }
  cur_tok = json_get_object(json_data, tokens, "n2SmInfo");
  if (cur_tok) {
    const char *content_id_str = json_get_string(json_data, cur_tok, "contentId");
    if (content_id_str && !strcmp(content_id_str, content_info->content_id)) {
      const char *str = json_get_string(json_data, tokens, "n2SmInfoType");
      if (str)
        subdissector = dissector_get_string_handle(ngap_n2_ie_type_dissector_table, str);
      else
        subdissector = NULL;
      goto found;
    }
  }
  if (find_n2_info_content(json_data, tokens, "n2MbsSmInfo",
                           content_info->content_id, &subdissector))
    goto found;
  cur_tok = json_get_array(json_data, tokens, "pduSessionList");
  if (cur_tok) {
    int i, count;
    count = json_get_array_len(cur_tok);
    for (i = 0; i < count; i++) {
      jsmntok_t *array_tok = json_get_array_index(cur_tok, i);
      if (find_n2_info_content(json_data, array_tok, "n2InfoContent",
                               content_info->content_id, &subdissector))
        goto found;
    }
  }
  if (find_n2_info_content(json_data, tokens, "sourceToTargetData",
                           content_info->content_id, &subdissector))
    goto found;
  if (find_n2_info_content(json_data, tokens, "targetToSourceData",
                           content_info->content_id, &subdissector))
    goto found;
  if (find_n2_info_content(json_data, tokens, "targetToSourceFailureData",
                           content_info->content_id, &subdissector))
    goto found;
  if (find_n2_info_content(json_data, tokens, "ueRadioCapability",
                           content_info->content_id, &subdissector))
    goto found;
found:
  if (subdissector) {
    proto_item *ngap_item;
    proto_tree *ngap_tree;
    gboolean save_writable;
    col_append_sep_str(pinfo->cinfo, COL_PROTOCOL, "/", "NGAP");
    if (subdissector != ngap_handle) {
        ngap_item = proto_tree_add_item(tree, proto_ngap, tvb, 0, -1, ENC_NA);
        ngap_tree = proto_item_add_subtree(ngap_item, ett_ngap);
    } else {
        ngap_tree = tree;
    }
	save_writable=((pinfo->cinfo+COL_PROTOCOL-1)/COL_PROTOCOL);
    col_set_writable(pinfo->cinfo, COL_PROTOCOL, FALSE);
    call_dissector_with_data(subdissector, tvb, pinfo, ngap_tree, NULL);
    col_set_writable(pinfo->cinfo, COL_PROTOCOL, save_writable);
    return tvb_captured_length(tvb);
  } else {
    return 0;
  }
}
