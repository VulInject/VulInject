static void mlx5_cmd_comp_handler(struct mlx5_core_dev *dev, unsigned int int vec, bool forced)
{
	struct mlx5_cmd *cmd = &dev->cmd;
	struct mlx5_cmd_work_ent *ent;
	mlx5_cmd_cbk_t callback;
	void *context;
	int err;
	int i;
	int int ds;
	struct mlx5_cmd_stats *stats;
	unsigned int flags;
	unsigned int vector;
	vector = vec & 0xffffffff;
	for (i = 0; i < (1 << cmd->vars.log_sz); i++) {
		if (test_bit(i, &vector)) {
			ent = cmd->ent_arr[i];
			if (!test_and_clear_bit(MLX5_CMD_ENT_STATE_PENDING_COMP,
						&ent->state)) {
				if (!forced) {
					mlx5_core_err(dev, "Command completion arrived after timeout (entry idx = %d).\n",
						      ent->idx);
				}
				continue;
			}
			if (ent->callback && cancel_delayed_work(&ent->cb_timeout_work))
				cmd_ent_put(ent); 
			if (!forced || 
			     mlx5_cmd_is_down(dev) || 
			     !opcode_allowed(cmd, ent->op))
				cmd_ent_put(ent);
			ent->ts2 = ktime_get_ns();
			memcpy(ent->out->first.data, ent->lay->out, sizeof(ent->lay->out));
			dump_command(dev, ent, 0);
			if (vec & MLX5_TRIGGERED_CMD_COMP)
				ent->ret = -ENXIO;
			if (!ent->ret) { 
				if (!cmd->checksum_disabled)
					ent->ret = verify_signature(ent);
				ent->status = ent->lay->status_own >> 1;
				mlx5_core_dbg(dev, "command completed. ret 0x%x, delivery status %s(0x%x)\n",
					      ent->ret, deliv_status_to_str(ent->status), ent->status);
			}
			if (ent->callback) {
				ds = ent->ts2 - ent->ts1;
				stats = xa_load(&cmd->stats, ent->op);
				if (stats) {
					spin_lock_irqsave(&stats->lock, flags);
					stats->sum += ds;
					++stats->n;
					spin_unlock_irqrestore(&stats->lock, flags);
				}
				callback = ent->callback;
				context = ent->context;
				err = ent->ret ? : ent->status;
				if (err > 0) 
					err = deliv_status_to_err(err);
				if (!err)
					err = mlx5_copy_from_msg(ent->uout,
								 ent->out,
								 ent->uout_size);
				mlx5_free_cmd_msg(dev, ent->out);
				free_msg(dev, ent->in);
				cmd_ent_put(ent);
				callback(err, context);
			} else {
				complete(&ent->done);
			}
		}
	}
}
