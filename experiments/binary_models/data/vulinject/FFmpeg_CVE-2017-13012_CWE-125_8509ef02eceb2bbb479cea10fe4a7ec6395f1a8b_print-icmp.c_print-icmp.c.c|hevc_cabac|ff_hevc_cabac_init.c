int ff_hevc_cabac_init(HEVCLocalContext *lc, int ctb_addr_ts)
{
    const HEVCContext *const s = lc->parent;
    if (ctb_addr_ts == s->ps.pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs]) {
        int ret = cabac_init_decoder(lc);
        if (ret < 0)
            return ret;
        if (s->sh.dependent_slice_segment_flag == 0 ||
            (s->ps.pps->tiles_enabled_flag &&
             s->ps.pps->tile_id[ctb_addr_ts] != s->ps.pps->tile_id[ctb_addr_ts - 1]))
            cabac_init_state(lc, s);
        if (!s->sh.first_slice_in_pic_flag &&
            s->ps.pps->entropy_coding_sync_enabled_flag) {
            if (ctb_addr_ts % s->ps.sps->ctb_width == 0) {
                if (s->ps.sps->ctb_width == 1)
                    cabac_init_state(lc, s);
                else if (s->sh.dependent_slice_segment_flag == 1)
                    load_states(lc, s);
            }
        }
    } else {
        if (s->ps.pps->tiles_enabled_flag &&
            s->ps.pps->tile_id[ctb_addr_ts] != s->ps.pps->tile_id[ctb_addr_ts - 1]) {
            int ret;
            if (s->threads_number == 1)
                ret = cabac_reinit(lc);
            else {
                ret = cabac_init_decoder(lc);
            }
            if (ret < 0)
                return ret;
            cabac_init_state(lc, s);
        }
        if (s->ps.pps->entropy_coding_sync_enabled_flag) {
            if (ctb_addr_ts % s->ps.sps->ctb_width == 0) {
                int ret;
                if (s->threads_number == 1)
                    ret = cabac_reinit(lc);
                else {
                    ret = cabac_init_decoder(lc);
                }
                if (ret < 0)
                    return ret;
                if (s->ps.sps->ctb_width == 1)
                    cabac_init_state(lc, s);
                else
                    load_states(lc, s);
            }
        }
    }
    return 0;
}
