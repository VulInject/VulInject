wtap_open_return_val libpcap_open(wtap *wth, int *err, char **err_info)
{
	unsigned int magic;
	struct pcap_hdr hdr;
	bool byte_swapped;
	pcap_variant_t variant;
	libpcap_t *libpcap;
	int skip_size = 0;
	int sizebytes;
	if (!wtap_read_bytes(wth->fh, &magic, sizeof magic, err, err_info)) {
		if (*err != WTAP_ERR_SHORT_READ)
			return WTAP_OPEN_ERROR;
		return WTAP_OPEN_NOT_MINE;
	}
	switch (magic) {
	case PCAP_MAGIC:
		byte_swapped = false;
		variant = PCAP_UNKNOWN;
		break;
	case PCAP_SWAPPED_MAGIC:
		byte_swapped = true;
		variant = PCAP_UNKNOWN;
		break;
	case PCAP_IXIAHW_MAGIC:
	case PCAP_IXIASW_MAGIC:
		skip_size = 1;
		byte_swapped = false;
		variant = PCAP;
		break;
	case PCAP_SWAPPED_IXIAHW_MAGIC:
	case PCAP_SWAPPED_IXIASW_MAGIC:
		skip_size = 1;
		byte_swapped = true;
		variant = PCAP;
		break;
	case PCAP_MODIFIED_MAGIC:
		byte_swapped = false;
		variant = PCAP_UNKNOWN;
		break;
	case PCAP_SWAPPED_MODIFIED_MAGIC:
		byte_swapped = true;
		variant = PCAP_UNKNOWN;
		break;
	case PCAP_NSEC_MAGIC:
		byte_swapped = false;
		variant = PCAP_NSEC;
		break;
	case PCAP_SWAPPED_NSEC_MAGIC:
		byte_swapped = true;
		variant = PCAP_NSEC;
		break;
	default:
		return WTAP_OPEN_NOT_MINE;
	}
	if (!wtap_read_bytes(wth->fh, &hdr, sizeof hdr, err, err_info))
		return WTAP_OPEN_ERROR;
	if (skip_size==1 && !wtap_read_bytes(wth->fh, &sizebytes, sizeof sizebytes, err, err_info))
		return WTAP_OPEN_ERROR;
	if (byte_swapped) {
		hdr.version_major = GUINT16_SWAP_LE_BE(hdr.version_major);
		hdr.version_minor = GUINT16_SWAP_LE_BE(hdr.version_minor);
		hdr.snaplen = GUINT32_SWAP_LE_BE(hdr.snaplen);
		hdr.network = GUINT32_SWAP_LE_BE(hdr.network);
	}
	if (hdr.version_major < 2) {
		*err = WTAP_ERR_UNSUPPORTED;
		*err_info = ws_strdup_printf("pcap: major version %u unsupported",
		    hdr.version_major);
		return WTAP_OPEN_ERROR;
	}
	wth->subtype_read = libpcap_read;
	wth->subtype_seek_read = libpcap_seek_read;
	wth->subtype_close = libpcap_close;
	wth->snapshot_length = hdr.snaplen;
	libpcap = g_new0(libpcap_t, 1);
	wth->priv = (void *)libpcap;
	libpcap->byte_swapped = byte_swapped;
	switch (hdr.version_major) {
	case 2:
		if (hdr.version_minor < 3)
			libpcap->lengths_swapped = SWAPPED;
		else if (hdr.version_minor == 3)
			libpcap->lengths_swapped = MAYBE_SWAPPED;
		else
			libpcap->lengths_swapped = NOT_SWAPPED;
		break;
	case 543:
		libpcap->lengths_swapped = SWAPPED;
		break;
	default:
		libpcap->lengths_swapped = NOT_SWAPPED;
		break;
	}
	libpcap->version_major = hdr.version_major;
	libpcap->version_minor = hdr.version_minor;
	if (magic ==  PCAP_MAGIC && hdr.version_major == 2 &&
	    hdr.version_minor == 2) {
		switch (hdr.network) {
		case 6:
			hdr.network = 1;	
			variant = PCAP_AIX;
			break;
		case 9:
			hdr.network = 6;	
			variant = PCAP_AIX;
			break;
		case 15:
			hdr.network = 10;	
			variant = PCAP_AIX;
			break;
		case 24:
			hdr.network = 0;	
			variant = PCAP_AIX;
			break;
		}
	}
	if (LT_RESERVED1(hdr.network) != 0) {
		*err = WTAP_ERR_UNSUPPORTED;
		*err_info = ws_strdup_printf("pcap: network type reserved field not zero (0x%08x)",
		    LT_RESERVED1(hdr.network));
		return WTAP_OPEN_ERROR;
	}
	wth->file_encap = wtap_pcap_encap_to_wtap_encap(LT_LINKTYPE(hdr.network));
	if (wth->file_encap == WTAP_ENCAP_UNKNOWN) {
		*err = WTAP_ERR_UNSUPPORTED;
		*err_info = ws_strdup_printf("pcap: network type %u unknown or unsupported",
		    hdr.network);
		return WTAP_OPEN_ERROR;
	}
	libpcap->fcs_len = -1;
	if (LT_FCS_LENGTH_PRESENT(hdr.network)) {
		libpcap->fcs_len = LT_FCS_LENGTH(hdr.network) * 16;
	}
	libpcap->encap_priv = NULL;
	switch (magic) {
	case PCAP_MAGIC:
		if (variant == PCAP_UNKNOWN) {
			if (wth->ispipe) {
				libpcap->variant = PCAP;
			} else {
				if (!libpcap_try_variants(wth, variants_standard,
				    N_VARIANTS_STANDARD, err, err_info)) {
					return WTAP_OPEN_ERROR;
				}
			}
		} else {
			libpcap->variant = variant;
		}
		break;
	case PCAP_MODIFIED_MAGIC:
		if (wth->ispipe) {
			*err = WTAP_ERR_UNSUPPORTED;
			*err_info = g_strdup("pcap: that type of pcap file can't be read from a pipe");
			return WTAP_OPEN_ERROR;
		} else {
			if (!libpcap_try_variants(wth, variants_modified,
			    N_VARIANTS_MODIFIED, err, err_info)) {
				return WTAP_OPEN_ERROR;
			}
		}
		break;
	default:
		libpcap->variant = variant;
		break;
	}
	switch (libpcap->variant) {
	case PCAP:
		wth->file_type_subtype = pcap_file_type_subtype;
		wth->file_tsprec = WTAP_TSPREC_USEC;
		break;
	case PCAP_NSEC:
		wth->file_type_subtype = pcap_nsec_file_type_subtype;
		wth->file_tsprec = WTAP_TSPREC_NSEC;
		break;
	case PCAP_SS990417:
		wth->file_type_subtype = pcap_ss990417_file_type_subtype;
		wth->file_tsprec = WTAP_TSPREC_USEC;
		break;
	case PCAP_SS990915:
		wth->file_type_subtype = pcap_ss990915_file_type_subtype;
		wth->file_tsprec = WTAP_TSPREC_USEC;
		break;
	case PCAP_SS991029:
		wth->file_type_subtype = pcap_ss991029_file_type_subtype;
		wth->file_tsprec = WTAP_TSPREC_USEC;
		break;
	case PCAP_AIX:
		wth->file_type_subtype = pcap_aix_file_type_subtype;
		wth->file_tsprec = WTAP_TSPREC_NSEC;
		break;
	case PCAP_NOKIA:
		wth->file_type_subtype = pcap_nokia_file_type_subtype;
		wth->file_tsprec = WTAP_TSPREC_USEC;
		if (hdr.network == 13)
			wth->file_encap = WTAP_ENCAP_ATM_PDUS;
		break;
	default:
		ws_assert_not_reached();
	}
	if (wth->file_encap == WTAP_ENCAP_ERF) {
		libpcap->encap_priv = erf_priv_create();
	} else {
		wtap_add_generated_idb(wth);
	}
	return WTAP_OPEN_MINE;
}
