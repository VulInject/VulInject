int lct_ext_decode(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, guint offset, guint offset_max, lct_data_exchange_t *data_exchange,
                   int hfext, int ettext)
{
    guint8      het;
    guint       i, count = 0;
    guint       length,
                tmp_offset   = offset,
                start_offset = offset;
    proto_item *ti;
    proto_tree *hec_tree, *ext_tree;
    double      cc_loss;
    while (tmp_offset < offset_max)
    {
        het = tvb_get_guint8(tvb, tmp_offset);
        if (het <= 127)
        {
            length = tvb_get_guint8(tvb, tmp_offset+1)*4;
        }
        else
        {
            length = 4;
        }
        if (length == 0)
            break;
        tmp_offset += length;
        count++;
    }
    ti = proto_tree_add_uint(tree, hfext, tvb, offset, tmp_offset - offset, count);
    hec_tree = proto_item_add_subtree(ti, ettext);
    for (i = 0; i < count; i++)
    {
        het = tvb_get_guint8(tvb, offset);
        if (het <= 127)
        {
            length = tvb_get_guint8(tvb, offset+1)*4;
        }
        else
        {
            length = 4;
        }
        ti = proto_tree_add_item(hec_tree, hf_hec_type, tvb, offset, 1, ENC_BIG_ENDIAN);
        ext_tree = proto_item_add_subtree(ti, ett_ext_ext);
        proto_item_set_len(ti, length);
        if (het <= 127)
        {
            proto_tree_add_item(ext_tree, hf_hec_len, tvb, offset+1, 1, ENC_BIG_ENDIAN);
        }
        switch (het)
        {
            case 0: 
            case 1: 
            default:
                proto_tree_add_item(ext_tree, hf_hec_data, tvb, offset+2, length-2, ENC_NA);
                break;
            case 3: 
                proto_tree_add_item(ext_tree, hf_cc_sequence, tvb, offset+2, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(ext_tree, hf_cc_flags, tvb, offset+4, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(ext_tree, hf_cc_rtt, tvb, offset+5, 1, ENC_BIG_ENDIAN);
                cc_loss = tvb_get_ntohs(tvb, offset+6)/65535.0;
                proto_tree_add_double(ext_tree, hf_cc_loss, tvb, offset+6, 2, cc_loss);
                proto_tree_add_item(ext_tree, hf_cc_rate, tvb, offset+8, 2, ENC_BIG_ENDIAN);
                break;
            case 64: 
                fec_decode_ext_fti(tvb, pinfo, ext_tree, offset,
                                   (data_exchange == NULL) ? 0 :
                                   data_exchange->is_sp ? 0 :data_exchange->codepoint);
                break;
            case 67: 
                proto_tree_add_item(ext_tree, hf_ext_tol_48_transfer_len, tvb, offset+1, 6, ENC_BIG_ENDIAN);
                break;
            case 128: 
                proto_tree_add_double(ext_tree, hf_send_rate, tvb, offset+2, 2,
                                      rmt_decode_send_rate(tvb_get_ntohs(tvb, offset+2)));
                break;
            case 192: 
                if ((data_exchange != NULL) && (data_exchange->ext_192 == LCT_PREFS_EXT_192_FLUTE))
                {
                    proto_tree_add_item(ext_tree, hf_flute_version, tvb, offset, 4, ENC_BIG_ENDIAN);
                    proto_tree_add_item(ext_tree, hf_fdt_instance_id, tvb, offset, 4, ENC_BIG_ENDIAN);
                    data_exchange->is_flute = TRUE;
                }
                break;
            case 193: 
                if ((data_exchange != NULL) && (data_exchange->ext_193 == LCT_PREFS_EXT_193_FLUTE))
                {
                    proto_tree_add_item(ext_tree, hf_cenc, tvb, offset+3, 1, ENC_BIG_ENDIAN);
                }
                break;
            case 194: 
                proto_tree_add_item(ext_tree, hf_ext_tol_24_transfer_len, tvb, offset+1, 3, ENC_BIG_ENDIAN);
                break;
        }
        offset += length;
    }
    return offset-start_offset;
}
