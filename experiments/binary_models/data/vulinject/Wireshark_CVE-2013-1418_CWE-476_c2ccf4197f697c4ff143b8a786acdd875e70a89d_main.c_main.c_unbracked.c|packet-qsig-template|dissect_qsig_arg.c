dissect_qsig_arg(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data) {
  int offset = 0;
  rose_ctx_t *rctx;
  gint32 opcode = 0, service, oid_num;
  const qsig_op_t *op_ptr = NULL;
  const gchar *p, *oid;
  proto_item *ti, *ti_tmp;
  proto_tree *qsig_tree;
  rctx = get_rose_ctx(data);
  DISSECTOR_ASSERT(rctx);
  if (rctx->d.pdu != 1)  
    return offset;
  if (rctx->d.code == 0) {  
    opcode = rctx->d.code_local;
    op_ptr = get_op(opcode);
  } else if (rctx->d.code == 1) {  
    oid = g_strrstr(rctx->d.code_global, ".");
    if (oid != NULL) {
     if (ws_strtou32(oid+1, NULL, &oid_num))
        op_ptr = get_op(oid_num);
    }
    if (op_ptr)
        opcode = op_ptr->opcode;
  } else {
    return offset;
  }
  if (!op_ptr)
    return offset;
  service = get_service(opcode);
  ti = proto_tree_add_item(tree, proto_qsig, tvb, offset, tvb_captured_length(tvb), ENC_NA);
  qsig_tree = proto_item_add_subtree(ti, ett_qsig);
  proto_tree_add_uint(qsig_tree, hf_qsig_operation, tvb, 0, 0, opcode);
  p = try_val_to_str(opcode, VALS(qsig_str_operation));
  if (p) {
    proto_item_append_text(ti, ": %s", p);
    proto_item_append_text(rctx->d.code_item, " - %s", p);
    if (rctx->apdu_depth >= 0)
      proto_item_append_text(proto_item_get_parent_nth(proto_tree_get_parent(tree), rctx->apdu_depth), " %s", p);
  }
  ti_tmp = proto_tree_add_uint(qsig_tree, hf_qsig_service, tvb, 0, 0, service);
  p = try_val_to_str(service, VALS(qsig_str_service_name));
  if (p) proto_item_append_text(ti_tmp, " - %s", p);
  if (op_ptr->arg_pdu)
    offset = op_ptr->arg_pdu(tvb, pinfo, qsig_tree, NULL);
  else
    if (tvb_reported_length_remaining(tvb, offset) > 0) {
      proto_tree_add_expert(tree, pinfo, &ei_qsig_unsupported_error_type, tvb, offset, -1);
      offset += tvb_captured_length_remaining(tvb, offset);
    }
  return offset;
}
