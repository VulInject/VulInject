tcp_print(netdissect_options *ndo,
          const u_char *bp, u_int length,
          const u_char *bp2, int fragmented)
{
        const struct tcphdr *tp;
        const struct ip *ip;
        unsigned short flags;
        u_int hlen;
        char ch;
        unsigned short sport, dport, win, urp;
        unsigned int seq, ack, thseq, thack;
        u_int utoval;
        unsigned short magic;
        int rev;
        const struct ip6_hdr *ip6;
        u_int header_len;	
        ndo->ndo_protocol = "tcp";
        tp = (const struct tcphdr *)bp;
        ip = (const struct ip *)bp2;
        if (IP_V(ip) == 6)
                ip6 = (const struct ip6_hdr *)bp2;
        else
                ip6 = NULL;
        ch = '\0';
        if (!ND_TTEST_2(tp->th_dport)) {
                if (ip6) {
                        ND_PRINT("%s > %s:",
                                 GET_IP6ADDR_STRING(ip6->ip6_src),
                                 GET_IP6ADDR_STRING(ip6->ip6_dst));
                } else {
                        ND_PRINT("%s > %s:",
                                 GET_IPADDR_STRING(ip->ip_src),
                                 GET_IPADDR_STRING(ip->ip_dst));
                }
                nd_trunc_longjmp(ndo);
        }
        sport = GET_BE_U_2(tp->th_sport);
        dport = GET_BE_U_2(tp->th_dport);
        if (ip6) {
                if (GET_U_1(ip6->ip6_nxt) == IPPROTO_TCP) {
                        ND_PRINT("%s.%s > %s.%s: ",
                                 GET_IP6ADDR_STRING(ip6->ip6_src),
                                 tcpport_string(ndo, sport),
                                 GET_IP6ADDR_STRING(ip6->ip6_dst),
                                 tcpport_string(ndo, dport));
                } else {
                        ND_PRINT("%s > %s: ",
                                 tcpport_string(ndo, sport), tcpport_string(ndo, dport));
                }
        } else {
                if (GET_U_1(ip->ip_p) == IPPROTO_TCP) {
                        ND_PRINT("%s.%s > %s.%s: ",
                                 GET_IPADDR_STRING(ip->ip_src),
                                 tcpport_string(ndo, sport),
                                 GET_IPADDR_STRING(ip->ip_dst),
                                 tcpport_string(ndo, dport));
                } else {
                        ND_PRINT("%s > %s: ",
                                 tcpport_string(ndo, sport), tcpport_string(ndo, dport));
                }
        }
        hlen = TH_OFF(tp) * 4;
        if (hlen < sizeof(*tp)) {
                ND_PRINT(" tcp %u [bad hdr length %u - too short, < %zu]",
                         length - hlen, hlen, sizeof(*tp));
                goto invalid;
        }
        seq = GET_BE_U_4(tp->th_seq);
        ack = GET_BE_U_4(tp->th_ack);
        win = GET_BE_U_2(tp->th_win);
        urp = GET_BE_U_2(tp->th_urp);
        if (ndo->ndo_qflag) {
                ND_PRINT("tcp %u", length - hlen);
                if (hlen > length) {
                        ND_PRINT(" [bad hdr length %u - too int, > %u]",
                                 hlen, length);
                        goto invalid;
                }
                return;
        }
        flags = tcp_get_flags(tp);
        ND_PRINT("Flags [%s]", bittok2str_nosep(tcp_flag_values, "none", flags));
        if (!ndo->ndo_Sflag && (flags & TH_ACK)) {
                rev = 0;
                if (ip6) {
                        struct tcp_seq_hash6 *th;
                        struct tcp_seq_hash6 *tcp_seq_hash;
                        const void *src, *dst;
                        struct tha6 tha;
                        tcp_seq_hash = tcp_seq_hash6;
                        src = (const void *)ip6->ip6_src;
                        dst = (const void *)ip6->ip6_dst;
                        if (sport > dport)
                                rev = 1;
                        else if (sport == dport) {
                                if (UNALIGNED_MEMCMP(src, dst, sizeof(ip6->ip6_dst)) > 0)
                                        rev = 1;
                        }
                        if (rev) {
                                UNALIGNED_MEMCPY(&tha.src, dst, sizeof(ip6->ip6_dst));
                                UNALIGNED_MEMCPY(&tha.dst, src, sizeof(ip6->ip6_src));
                                tha.port = ((u_int)dport) << 16 | sport;
                        } else {
                                UNALIGNED_MEMCPY(&tha.dst, dst, sizeof(ip6->ip6_dst));
                                UNALIGNED_MEMCPY(&tha.src, src, sizeof(ip6->ip6_src));
                                tha.port = ((u_int)sport) << 16 | dport;
                        }
                        for (th = &tcp_seq_hash[tha.port % TSEQ_HASHSIZE];
                             th->nxt; th = th->nxt)
                                if (memcmp((char *)&tha, (char *)&th->addr,
                                           sizeof(th->addr)) == 0)
                                        break;
                        if (!th->nxt || (flags & TH_SYN)) {
                                if (th->nxt == NULL) {
                                        th->nxt = (struct tcp_seq_hash6 *)
                                                calloc(1, sizeof(*th));
                                        if (th->nxt == NULL)
                                                (*ndo->ndo_error)(ndo,
                                                        S_ERR_ND_MEM_ALLOC,
                                                        "%s: calloc", __func__);
                                }
                                th->addr = tha;
                                if (rev)
                                        th->ack = seq, th->seq = ack - 1;
                                else
                                        th->seq = seq, th->ack = ack - 1;
                        } else {
                                if (rev)
                                        seq -= th->ack, ack -= th->seq;
                                else
                                        seq -= th->seq, ack -= th->ack;
                        }
                        thseq = th->seq;
                        thack = th->ack;
                } else {
                        struct tcp_seq_hash *th;
                        struct tcp_seq_hash *tcp_seq_hash;
                        struct tha tha;
                        tcp_seq_hash = tcp_seq_hash4;
                        if (sport > dport)
                                rev = 1;
                        else if (sport == dport) {
                                if (UNALIGNED_MEMCMP(ip->ip_src, ip->ip_dst, sizeof(ip->ip_dst)) > 0)
                                        rev = 1;
                        }
                        if (rev) {
                                UNALIGNED_MEMCPY(&tha.src, ip->ip_dst,
                                                 sizeof(ip->ip_dst));
                                UNALIGNED_MEMCPY(&tha.dst, ip->ip_src,
                                                 sizeof(ip->ip_src));
                                tha.port = ((u_int)dport) << 16 | sport;
                        } else {
                                UNALIGNED_MEMCPY(&tha.dst, ip->ip_dst,
                                                 sizeof(ip->ip_dst));
                                UNALIGNED_MEMCPY(&tha.src, ip->ip_src,
                                                 sizeof(ip->ip_src));
                                tha.port = ((u_int)sport) << 16 | dport;
                        }
                        for (th = &tcp_seq_hash[tha.port % TSEQ_HASHSIZE];
                             th->nxt; th = th->nxt)
                                if (memcmp((char *)&tha, (char *)&th->addr,
                                           sizeof(th->addr)) == 0)
                                        break;
                        if (!th->nxt || (flags & TH_SYN)) {
                                if (th->nxt == NULL) {
                                        th->nxt = (struct tcp_seq_hash *)
                                                calloc(1, sizeof(*th));
                                        if (th->nxt == NULL)
                                                (*ndo->ndo_error)(ndo,
                                                        S_ERR_ND_MEM_ALLOC,
                                                        "%s: calloc", __func__);
                                }
                                th->addr = tha;
                                if (rev)
                                        th->ack = seq, th->seq = ack - 1;
                                else
                                        th->seq = seq, th->ack = ack - 1;
                        } else {
                                if (rev)
                                        seq -= th->ack, ack -= th->seq;
                                else
                                        seq -= th->seq, ack -= th->ack;
                        }
                        thseq = th->seq;
                        thack = th->ack;
                }
        } else {
                thseq = thack = rev = 0;
        }
        if (hlen > length) {
                ND_PRINT(" [bad hdr length %u - too int, > %u]",
                         hlen, length);
                goto invalid;
        }
        if (ndo->ndo_vflag && !ndo->ndo_Kflag && !fragmented) {
                unsigned short sum, tcp_sum;
                if (IP_V(ip) == 4) {
                        if (ND_TTEST_LEN(tp->th_sport, length)) {
                                sum = tcp_cksum(ndo, ip, tp, length);
                                tcp_sum = GET_BE_U_2(tp->th_sum);
                                ND_PRINT(", cksum 0x%04x", tcp_sum);
                                if (sum != 0)
                                        ND_PRINT(" (incorrect -> 0x%04x)",
                                            in_cksum_shouldbe(tcp_sum, sum));
                                else
                                        ND_PRINT(" (correct)");
                        }
                } else if (IP_V(ip) == 6) {
                        if (ND_TTEST_LEN(tp->th_sport, length)) {
                                sum = tcp6_cksum(ndo, ip6, tp, length);
                                tcp_sum = GET_BE_U_2(tp->th_sum);
                                ND_PRINT(", cksum 0x%04x", tcp_sum);
                                if (sum != 0)
                                        ND_PRINT(" (incorrect -> 0x%04x)",
                                            in_cksum_shouldbe(tcp_sum, sum));
                                else
                                        ND_PRINT(" (correct)");
                        }
                }
        }
        length -= hlen;
        if (ndo->ndo_vflag > 1 || length > 0 || flags & (TH_SYN | TH_FIN | TH_RST)) {
                ND_PRINT(", seq %u", seq);
                if (length > 0) {
                        ND_PRINT(":%u", seq + length);
                }
        }
        if (flags & TH_ACK) {
                ND_PRINT(", ack %u", ack);
        }
        ND_PRINT(", win %u", win);
        if (flags & TH_URG)
                ND_PRINT(", urg %u", urp);
        if (hlen > sizeof(*tp)) {
                const u_char *cp;
                u_int i, opt, datalen;
                u_int len;
                hlen -= sizeof(*tp);
                cp = (const u_char *)tp + sizeof(*tp);
                ND_PRINT(", options [");
                while (hlen != 0) {
                        if (ch != '\0')
                                ND_PRINT("%c", ch);
                        opt = GET_U_1(cp);
                        cp++;
                        if (ZEROLENOPT(opt))
                                len = 1;
                        else {
                                len = GET_U_1(cp);
                                cp++;	
                                if (len < 2 || len > hlen)
                                        goto bad;
                                --hlen;		
                        }
                        --hlen;			
                        datalen = 0;
#define LENCHECK(l) { if ((l) > hlen) goto bad; }
                        ND_PRINT("%s", tok2str(tcp_option_values, "unknown-%u", opt));
                        switch (opt) {
                        case TCPOPT_MAXSEG:
                                datalen = 2;
                                LENCHECK(datalen);
                                ND_PRINT(" %u", GET_BE_U_2(cp));
                                break;
                        case TCPOPT_WSCALE:
                                datalen = 1;
                                LENCHECK(datalen);
                                ND_PRINT(" %u", GET_U_1(cp));
                                break;
                        case TCPOPT_SACK:
                                datalen = len - 2;
                                if (datalen % 8 != 0) {
                                        ND_PRINT(" invalid sack");
                                } else {
                                        unsigned int s, e;
                                        ND_PRINT(" %u ", datalen / 8);
                                        for (i = 0; i < datalen; i += 8) {
                                                LENCHECK(i + 4);
                                                s = GET_BE_U_4(cp + i);
                                                LENCHECK(i + 8);
                                                e = GET_BE_U_4(cp + i + 4);
                                                if (rev) {
                                                        s -= thseq;
                                                        e -= thseq;
                                                } else {
                                                        s -= thack;
                                                        e -= thack;
                                                }
                                                ND_PRINT("{%u:%u}", s, e);
                                        }
                                }
                                break;
                        case TCPOPT_CC:
                        case TCPOPT_CCNEW:
                        case TCPOPT_CCECHO:
                        case TCPOPT_ECHO:
                        case TCPOPT_ECHOREPLY:
                                datalen = 4;
                                LENCHECK(datalen);
                                ND_PRINT(" %u", GET_BE_U_4(cp));
                                break;
                        case TCPOPT_TIMESTAMP:
                                datalen = 8;
                                LENCHECK(datalen);
                                ND_PRINT(" val %u ecr %u",
                                             GET_BE_U_4(cp),
                                             GET_BE_U_4(cp + 4));
                                break;
                        case TCPOPT_SIGNATURE:
                                datalen = TCP_SIGLEN;
                                LENCHECK(datalen);
                                ND_PRINT(" ");
#ifdef HAVE_LIBCRYPTO
                                switch (tcp_verify_signature(ndo, ip, tp,
                                                             bp + TH_OFF(tp) * 4, length, cp)) {
                                case SIGNATURE_VALID:
                                        ND_PRINT("valid");
                                        break;
                                case SIGNATURE_INVALID:
                                        nd_print_invalid(ndo);
                                        break;
                                case CANT_CHECK_SIGNATURE:
                                        ND_PRINT("can't check - ");
                                        for (i = 0; i < TCP_SIGLEN; ++i)
                                                ND_PRINT("%02x",
                                                         GET_U_1(cp + i));
                                        break;
                                }
#else
                                for (i = 0; i < TCP_SIGLEN; ++i)
                                        ND_PRINT("%02x", GET_U_1(cp + i));
#endif
                                break;
                        case TCPOPT_SCPS:
                                datalen = 2;
                                LENCHECK(datalen);
                                ND_PRINT(" cap %02x id %u", GET_U_1(cp),
                                         GET_U_1(cp + 1));
                                break;
                        case TCPOPT_TCPAO:
                                datalen = len - 2;
                                if (datalen < 2) {
                                        nd_print_invalid(ndo);
                                } else {
                                        LENCHECK(1);
                                        ND_PRINT(" keyid %u", GET_U_1(cp));
                                        LENCHECK(2);
                                        ND_PRINT(" rnextkeyid %u",
                                                 GET_U_1(cp + 1));
                                        if (datalen > 2) {
                                                ND_PRINT(" mac 0x");
                                                for (i = 2; i < datalen; i++) {
                                                        LENCHECK(i + 1);
                                                        ND_PRINT("%02x",
                                                                 GET_U_1(cp + i));
                                                }
                                        }
                                }
                                break;
                        case TCPOPT_EOL:
                        case TCPOPT_NOP:
                        case TCPOPT_SACKOK:
                                break;
                        case TCPOPT_UTO:
                                datalen = 2;
                                LENCHECK(datalen);
                                utoval = GET_BE_U_2(cp);
                                ND_PRINT(" 0x%x", utoval);
                                if (utoval & 0x0001)
                                        utoval = (utoval >> 1) * 60;
                                else
                                        utoval >>= 1;
                                ND_PRINT(" %u", utoval);
                                break;
                        case TCPOPT_MPTCP:
                            {
                                const u_char *snapend_save;
                                int ret;
                                datalen = len - 2;
                                LENCHECK(datalen);
                                ND_TCHECK_LEN(cp, datalen);
                                snapend_save = ndo->ndo_snapend;
                                ndo->ndo_snapend = ND_MIN(cp - 2 + len,
                                                          ndo->ndo_snapend);
                                ret = mptcp_print(ndo, cp - 2, len, flags);
                                ndo->ndo_snapend = snapend_save;
                                if (!ret)
                                        goto bad;
                                break;
                            }
                        case TCPOPT_FASTOPEN:
                                datalen = len - 2;
                                LENCHECK(datalen);
                                ND_TCHECK_LEN(cp, datalen);
                                ND_PRINT(" ");
                                print_tcp_fastopen_option(ndo, cp, datalen);
                                break;
                        case TCPOPT_EXPERIMENT2:
                                datalen = len - 2;
                                LENCHECK(datalen);
                                ND_TCHECK_LEN(cp, datalen);
                                if (datalen < 2)
                                        goto bad;
                                magic = GET_BE_U_2(cp);
                                ND_PRINT("-");
                                switch(magic) {
                                case 0xf989: 
                                        ND_PRINT("tfo");
                                        print_tcp_fastopen_option(ndo, cp + 2, datalen - 2);
                                        break;
                                default:
                                        ND_PRINT("%04x", magic);
                                        break;
                                }
                                break;
                        default:
                                datalen = len - 2;
                                if (datalen)
                                        ND_PRINT(" 0x");
                                for (i = 0; i < datalen; ++i) {
                                        LENCHECK(i + 1);
                                        ND_PRINT("%02x", GET_U_1(cp + i));
                                }
                                break;
                        }
                        cp += datalen;
                        hlen -= datalen;
                        ++datalen;		
                        if (!ZEROLENOPT(opt))
                                ++datalen;	
                        if (datalen != len)
                                ND_PRINT("[len %u]", len);
                        ch = ',';
                        if (opt == TCPOPT_EOL)
                                break;
                }
                ND_PRINT("]");
        }
        ND_PRINT(", length %u", length);
        if (length == 0)
                return;
        header_len = TH_OFF(tp) * 4;
        if (!ND_TTEST_LEN(bp, header_len)) {
                ND_PRINT(" [remaining caplen(%u) < header length(%u)]",
                         ND_BYTES_AVAILABLE_AFTER(bp), header_len);
                nd_trunc_longjmp(ndo);
        }
        bp += header_len;
        if ((flags & TH_RST) && ndo->ndo_vflag) {
                print_tcp_rst_data(ndo, bp, length);
                return;
        }
        if (ndo->ndo_packettype) {
                switch (ndo->ndo_packettype) {
                case PT_ZMTP1:
                        zmtp1_print(ndo, bp, length);
                        break;
                case PT_RESP:
                        resp_print(ndo, bp, length);
                        break;
                case PT_DOMAIN:
                        domain_print(ndo, bp, length, TRUE, FALSE);
                        break;
                }
                return;
        }
        if (IS_SRC_OR_DST_PORT(FTP_PORT)) {
                ND_PRINT(": ");
                ftp_print(ndo, bp, length);
        } else if (IS_SRC_OR_DST_PORT(SSH_PORT)) {
                ssh_print(ndo, bp, length);
        } else if (IS_SRC_OR_DST_PORT(TELNET_PORT)) {
                telnet_print(ndo, bp, length);
        } else if (IS_SRC_OR_DST_PORT(SMTP_PORT)) {
                ND_PRINT(": ");
                smtp_print(ndo, bp, length);
        } else if (IS_SRC_OR_DST_PORT(WHOIS_PORT)) {
                ND_PRINT(": ");
                whois_print(ndo, bp, length);
        } else if (IS_SRC_OR_DST_PORT(NAMESERVER_PORT)) {
                domain_print(ndo, bp, length, TRUE, FALSE);
        } else if (IS_SRC_OR_DST_PORT(HTTP_PORT)) {
                ND_PRINT(": ");
                http_print(ndo, bp, length);
#ifdef ENABLE_SMB
        } else if (IS_SRC_OR_DST_PORT(NETBIOS_SSN_PORT)) {
                nbt_tcp_print(ndo, bp, length);
#endif
        } else if (IS_SRC_OR_DST_PORT(BGP_PORT)) {
                bgp_print(ndo, bp, length);
        } else if (IS_SRC_OR_DST_PORT(RPKI_RTR_PORT)) {
                rpki_rtr_print(ndo, bp, length);
#ifdef ENABLE_SMB
        } else if (IS_SRC_OR_DST_PORT(SMB_PORT)) {
                smb_tcp_print(ndo, bp, length);
#endif
        } else if (IS_SRC_OR_DST_PORT(RTSP_PORT)) {
                ND_PRINT(": ");
                rtsp_print(ndo, bp, length);
        } else if (IS_SRC_OR_DST_PORT(MSDP_PORT)) {
                msdp_print(ndo, bp, length);
        } else if (IS_SRC_OR_DST_PORT(LDP_PORT)) {
                ldp_print(ndo, bp, length);
        } else if (IS_SRC_OR_DST_PORT(PPTP_PORT))
                pptp_print(ndo, bp);
        else if (IS_SRC_OR_DST_PORT(REDIS_PORT))
                resp_print(ndo, bp, length);
        else if (IS_SRC_OR_DST_PORT(BEEP_PORT))
                beep_print(ndo, bp, length);
        else if (IS_SRC_OR_DST_PORT(OPENFLOW_PORT_OLD) || IS_SRC_OR_DST_PORT(OPENFLOW_PORT_IANA)) {
                openflow_print(ndo, bp, length);
        } else if (IS_SRC_OR_DST_PORT(HTTP_PORT_ALT)) {
                ND_PRINT(": ");
                http_print(ndo, bp, length);
        } else if (IS_SRC_OR_DST_PORT(RTSP_PORT_ALT)) {
                ND_PRINT(": ");
                rtsp_print(ndo, bp, length);
        } else if ((IS_SRC_OR_DST_PORT(NFS_PORT)) &&
                 length >= 4) {
                unsigned int fraglen;
                const struct sunrpc_msg *rp;
                enum sunrpc_msg_type direction;
                fraglen = GET_BE_U_4(bp) & 0x7FFFFFFF;
                if (fraglen > (length) - 4)
                        fraglen = (length) - 4;
                rp = (const struct sunrpc_msg *)(bp + 4);
                if (ND_TTEST_4(rp->rm_direction)) {
                        direction = (enum sunrpc_msg_type) GET_BE_U_4(rp->rm_direction);
                        if (dport == NFS_PORT && direction == SUNRPC_CALL) {
                                ND_PRINT(": NFS request xid %u ",
                                         GET_BE_U_4(rp->rm_xid));
                                nfsreq_noaddr_print(ndo, (const u_char *)rp, fraglen, (const u_char *)ip);
                                return;
                        }
                        if (sport == NFS_PORT && direction == SUNRPC_REPLY) {
                                ND_PRINT(": NFS reply xid %u ",
                                         GET_BE_U_4(rp->rm_xid));
                                nfsreply_noaddr_print(ndo, (const u_char *)rp, fraglen, (const u_char *)ip);
                                return;
                        }
                }
        }
        return;
bad:
        ND_PRINT("[bad opt]");
        if (ch != '\0')
                ND_PRINT("]");
        return;
invalid:
        nd_print_invalid(ndo);
}
