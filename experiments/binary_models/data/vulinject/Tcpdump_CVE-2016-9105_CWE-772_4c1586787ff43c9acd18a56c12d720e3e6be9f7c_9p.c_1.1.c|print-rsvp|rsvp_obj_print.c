rsvp_obj_print(netdissect_options *ndo,
               const u_char *pptr, u_int plen, const u_char *tptr,
               const char *indent, u_int tlen,
               const struct rsvp_common_header *rsvp_com_header)
{
    const struct rsvp_object_header *rsvp_obj_header;
    const u_char *obj_tptr;
    union {
        const struct rsvp_obj_integrity_t *rsvp_obj_integrity;
        const struct rsvp_obj_frr_t *rsvp_obj_frr;
    } obj_ptr;
    u_short rsvp_obj_len,rsvp_obj_ctype,rsvp_obj_class_num;
    u_int obj_tlen,intserv_serv_tlen;
    int hexdump;
    u_int processed,padbytes,error_code,error_value,i,sigcheck;
    u_int namelen;
    u_int action, subchannel;
    while(tlen>=sizeof(struct rsvp_object_header)) {
        rsvp_obj_header = (const struct rsvp_object_header *)tptr;
        rsvp_obj_len=GET_BE_U_2(rsvp_obj_header->length);
        rsvp_obj_ctype=GET_U_1(rsvp_obj_header->ctype);
        if(rsvp_obj_len % 4) {
            ND_PRINT("%sERROR: object header size %u not a multiple of 4", indent, rsvp_obj_len);
            return -1;
        }
        if(rsvp_obj_len < sizeof(struct rsvp_object_header)) {
            ND_PRINT("%sERROR: object header too short %u < %zu", indent, rsvp_obj_len,
                   sizeof(struct rsvp_object_header));
            return -1;
        }
        rsvp_obj_class_num = GET_U_1(rsvp_obj_header->class_num);
        ND_PRINT("%s%s Object (%u) Flags: [%s",
               indent,
               tok2str(rsvp_obj_values,
                       "Unknown",
                       rsvp_obj_class_num),
               rsvp_obj_class_num,
               (rsvp_obj_class_num & 0x80) ?
                   ((rsvp_obj_class_num & 0x40) ? "ignore and forward" :
                                         "ignore silently") :
                   "reject");
        ND_PRINT(" if unknown], Class-Type: %s (%u), length: %u",
               tok2str(rsvp_ctype_values,
                       "Unknown",
                       (rsvp_obj_class_num<<8)+rsvp_obj_ctype),
               rsvp_obj_ctype,
               rsvp_obj_len);
        if(tlen < rsvp_obj_len) {
            ND_PRINT("%sERROR: object goes past end of objects TLV", indent);
            return -1;
        }
        obj_tptr=tptr+sizeof(struct rsvp_object_header);
        obj_tlen=rsvp_obj_len-sizeof(struct rsvp_object_header);
        hexdump=FALSE;
        switch(rsvp_obj_class_num) {
        case RSVP_OBJ_SESSION:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_IPV4:
                if (obj_tlen < 8)
                    goto obj_tooshort;
                ND_PRINT("%s  IPv4 DestAddress: %s, Protocol ID: 0x%02x",
                       indent,
                       GET_IPADDR_STRING(obj_tptr),
                       GET_U_1(obj_tptr + sizeof(nd_ipv4)));
                ND_PRINT("%s  Flags: [0x%02x], DestPort %u",
                       indent,
                       GET_U_1((obj_tptr + 5)),
                       GET_BE_U_2(obj_tptr + 6));
                obj_tlen-=8;
                obj_tptr+=8;
                break;
            case RSVP_CTYPE_IPV6:
                if (obj_tlen < 20)
                    goto obj_tooshort;
                ND_PRINT("%s  IPv6 DestAddress: %s, Protocol ID: 0x%02x",
                       indent,
                       GET_IP6ADDR_STRING(obj_tptr),
                       GET_U_1(obj_tptr + sizeof(nd_ipv6)));
                ND_PRINT("%s  Flags: [0x%02x], DestPort %u",
                       indent,
                       GET_U_1((obj_tptr + sizeof(nd_ipv6) + 1)),
                       GET_BE_U_2(obj_tptr + sizeof(nd_ipv6) + 2));
                obj_tlen-=20;
                obj_tptr+=20;
                break;
            case RSVP_CTYPE_TUNNEL_IPV6:
                if (obj_tlen < 36)
                    goto obj_tooshort;
                ND_PRINT("%s  IPv6 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s",
                       indent,
                       GET_IP6ADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 18),
                       GET_IP6ADDR_STRING(obj_tptr + 20));
                obj_tlen-=36;
                obj_tptr+=36;
                break;
            case RSVP_CTYPE_14: 
                if (obj_tlen < 26)
                    goto obj_tooshort;
                ND_PRINT("%s  IPv6 P2MP LSP ID: 0x%08x, Tunnel ID: 0x%04x, Extended Tunnel ID: %s",
                       indent,
                       GET_BE_U_4(obj_tptr),
                       GET_BE_U_2(obj_tptr + 6),
                       GET_IP6ADDR_STRING(obj_tptr + 8));
                obj_tlen-=26;
                obj_tptr+=26;
                break;
            case RSVP_CTYPE_13: 
                if (obj_tlen < 12)
                    goto obj_tooshort;
                ND_PRINT("%s  IPv4 P2MP LSP ID: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s",
                       indent,
                       GET_IPADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 6),
                       GET_IPADDR_STRING(obj_tptr + 8));
                obj_tlen-=12;
                obj_tptr+=12;
                break;
            case RSVP_CTYPE_TUNNEL_IPV4:
            case RSVP_CTYPE_UNI_IPV4:
                if (obj_tlen < 12)
                    goto obj_tooshort;
                ND_PRINT("%s  IPv4 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s",
                       indent,
                       GET_IPADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 6),
                       GET_IPADDR_STRING(obj_tptr + 8));
                obj_tlen-=12;
                obj_tptr+=12;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_CONFIRM:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_IPV4:
                if (obj_tlen < sizeof(nd_ipv4))
                    goto obj_tooshort;
                ND_PRINT("%s  IPv4 Receiver Address: %s",
                       indent,
                       GET_IPADDR_STRING(obj_tptr));
                obj_tlen-=sizeof(nd_ipv4);
                obj_tptr+=sizeof(nd_ipv4);
                break;
            case RSVP_CTYPE_IPV6:
                if (obj_tlen < sizeof(nd_ipv6))
                    goto obj_tooshort;
                ND_PRINT("%s  IPv6 Receiver Address: %s",
                       indent,
                       GET_IP6ADDR_STRING(obj_tptr));
                obj_tlen-=sizeof(nd_ipv6);
                obj_tptr+=sizeof(nd_ipv6);
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_NOTIFY_REQ:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_IPV4:
                if (obj_tlen < sizeof(nd_ipv4))
                    goto obj_tooshort;
                ND_PRINT("%s  IPv4 Notify Node Address: %s",
                       indent,
                       GET_IPADDR_STRING(obj_tptr));
                obj_tlen-=sizeof(nd_ipv4);
                obj_tptr+=sizeof(nd_ipv4);
                break;
            case RSVP_CTYPE_IPV6:
                if (obj_tlen < sizeof(nd_ipv6))
                    goto obj_tooshort;
                ND_PRINT("%s  IPv6 Notify Node Address: %s",
                       indent,
                       GET_IP6ADDR_STRING(obj_tptr));
                obj_tlen-=sizeof(nd_ipv6);
                obj_tptr+=sizeof(nd_ipv6);
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_SUGGESTED_LABEL: 
        case RSVP_OBJ_UPSTREAM_LABEL:  
        case RSVP_OBJ_RECOVERY_LABEL:  
        case RSVP_OBJ_LABEL:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1:
                while(obj_tlen >= 4 ) {
                    ND_PRINT("%s  Label: %u", indent, GET_BE_U_4(obj_tptr));
                    obj_tlen-=4;
                    obj_tptr+=4;
                }
                break;
            case RSVP_CTYPE_2:
                if (obj_tlen < 4)
                    goto obj_tooshort;
                ND_PRINT("%s  Generalized Label: %u",
                       indent,
                       GET_BE_U_4(obj_tptr));
                obj_tlen-=4;
                obj_tptr+=4;
                break;
            case RSVP_CTYPE_3:
                if (obj_tlen < 12)
                    goto obj_tooshort;
                ND_PRINT("%s  Waveband ID: %u%s  Start Label: %u, Stop Label: %u",
                       indent,
                       GET_BE_U_4(obj_tptr),
                       indent,
                       GET_BE_U_4(obj_tptr + 4),
                       GET_BE_U_4(obj_tptr + 8));
                obj_tlen-=12;
                obj_tptr+=12;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_STYLE:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1:
                if (obj_tlen < 4)
                    goto obj_tooshort;
                ND_PRINT("%s  Reservation Style: %s, Flags: [0x%02x]",
                       indent,
                       tok2str(rsvp_resstyle_values,
                               "Unknown",
                               GET_BE_U_3(obj_tptr + 1)),
                       GET_U_1(obj_tptr));
                obj_tlen-=4;
                obj_tptr+=4;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_SENDER_TEMPLATE:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_IPV4:
                if (obj_tlen < 8)
                    goto obj_tooshort;
                ND_PRINT("%s  Source Address: %s, Source Port: %u",
                       indent,
                       GET_IPADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 6));
                obj_tlen-=8;
                obj_tptr+=8;
                break;
            case RSVP_CTYPE_IPV6:
                if (obj_tlen < 20)
                    goto obj_tooshort;
                ND_PRINT("%s  Source Address: %s, Source Port: %u",
                       indent,
                       GET_IP6ADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 18));
                obj_tlen-=20;
                obj_tptr+=20;
                break;
            case RSVP_CTYPE_13: 
                if (obj_tlen < 40)
                    goto obj_tooshort;
                ND_PRINT("%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x"
                       "%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x",
                       indent,
                       GET_IP6ADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 18),
                       indent,
                       GET_IP6ADDR_STRING(obj_tptr+20),
                       GET_BE_U_2(obj_tptr + 38));
                obj_tlen-=40;
                obj_tptr+=40;
                break;
            case RSVP_CTYPE_TUNNEL_IPV4:
                if (obj_tlen < 8)
                    goto obj_tooshort;
                ND_PRINT("%s  IPv4 Tunnel Sender Address: %s, LSP-ID: 0x%04x",
                       indent,
                       GET_IPADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 6));
                obj_tlen-=8;
                obj_tptr+=8;
                break;
            case RSVP_CTYPE_12: 
                if (obj_tlen < 16)
                    goto obj_tooshort;
                ND_PRINT("%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x"
                       "%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x",
                       indent,
                       GET_IPADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 6),
                       indent,
                       GET_IPADDR_STRING(obj_tptr+8),
                       GET_BE_U_2(obj_tptr + 12));
                obj_tlen-=16;
                obj_tptr+=16;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_LABEL_REQ:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1:
                while(obj_tlen >= 4 ) {
                    ND_PRINT("%s  L3 Protocol ID: %s",
                           indent,
                           tok2str(ethertype_values,
                                   "Unknown Protocol (0x%04x)",
                                   GET_BE_U_2(obj_tptr + 2)));
                    obj_tlen-=4;
                    obj_tptr+=4;
                }
                break;
            case RSVP_CTYPE_2:
                if (obj_tlen < 12)
                    goto obj_tooshort;
                ND_PRINT("%s  L3 Protocol ID: %s",
                       indent,
                       tok2str(ethertype_values,
                               "Unknown Protocol (0x%04x)",
                               GET_BE_U_2(obj_tptr + 2)));
                ND_PRINT(",%s merge capability",
                         ((GET_U_1(obj_tptr + 4)) & 0x80) ? "no" : "" );
                ND_PRINT("%s  Minimum VPI/VCI: %u/%u",
                       indent,
                       (GET_BE_U_2(obj_tptr + 4))&0xfff,
                       (GET_BE_U_2(obj_tptr + 6)) & 0xfff);
                ND_PRINT("%s  Maximum VPI/VCI: %u/%u",
                       indent,
                       (GET_BE_U_2(obj_tptr + 8))&0xfff,
                       (GET_BE_U_2(obj_tptr + 10)) & 0xfff);
                obj_tlen-=12;
                obj_tptr+=12;
                break;
            case RSVP_CTYPE_3:
                if (obj_tlen < 12)
                    goto obj_tooshort;
                ND_PRINT("%s  L3 Protocol ID: %s",
                       indent,
                       tok2str(ethertype_values,
                               "Unknown Protocol (0x%04x)",
                               GET_BE_U_2(obj_tptr + 2)));
                ND_PRINT("%s  Minimum/Maximum DLCI: %u/%u, %s%s bit DLCI",
                       indent,
                       (GET_BE_U_4(obj_tptr + 4))&0x7fffff,
                       (GET_BE_U_4(obj_tptr + 8))&0x7fffff,
                       (((GET_BE_U_2(obj_tptr + 4)>>7)&3) == 0 ) ? "10" : "",
                       (((GET_BE_U_2(obj_tptr + 4) >> 7) & 3) == 2 ) ? "23" : "");
                obj_tlen-=12;
                obj_tptr+=12;
                break;
            case RSVP_CTYPE_4:
                if (obj_tlen < 4)
                    goto obj_tooshort;
                ND_PRINT("%s  LSP Encoding Type: %s (%u)",
                       indent,
                       tok2str(gmpls_encoding_values,
                               "Unknown",
                               GET_U_1(obj_tptr)),
                       GET_U_1(obj_tptr));
                ND_PRINT("%s  Switching Type: %s (%u), Payload ID: %s (0x%04x)",
                       indent,
                       tok2str(gmpls_switch_cap_values,
                               "Unknown",
                               GET_U_1((obj_tptr + 1))),
                       GET_U_1(obj_tptr + 1),
                       tok2str(gmpls_payload_values,
                               "Unknown",
                               GET_BE_U_2(obj_tptr + 2)),
                       GET_BE_U_2(obj_tptr + 2));
                obj_tlen-=4;
                obj_tptr+=4;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_RRO:
        case RSVP_OBJ_ERO:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_IPV4:
                while(obj_tlen >= 4 ) {
		    u_char length;
		    ND_TCHECK_4(obj_tptr);
		    length = GET_U_1(obj_tptr + 1);
                    ND_PRINT("%s  Subobject Type: %s, length %u",
                           indent,
                           tok2str(rsvp_obj_xro_values,
                                   "Unknown %u",
                                   RSVP_OBJ_XRO_MASK_SUBOBJ(GET_U_1(obj_tptr))),
                           length);
                    if (obj_tlen < length) {
                        ND_PRINT("%s  ERROR: ERO subobject length > object length", indent);
                        break;
                    }
                    if (length == 0) { 
                        ND_PRINT("%s  ERROR: zero length ERO subtype", indent);
                        break;
                    }
                    switch(RSVP_OBJ_XRO_MASK_SUBOBJ(GET_U_1(obj_tptr))) {
		    u_char prefix_length;
                    case RSVP_OBJ_XRO_IPV4:
			if (length != 8) {
				ND_PRINT(" ERROR: length != 8");
				goto invalid;
			}
			ND_TCHECK_8(obj_tptr);
			prefix_length = GET_U_1(obj_tptr + 6);
			if (prefix_length != 32) {
				ND_PRINT(" ERROR: Prefix length %u != 32",
					  prefix_length);
				goto invalid;
			}
                        ND_PRINT(", %s, %s/%u, Flags: [%s]",
                               RSVP_OBJ_XRO_MASK_LOOSE(GET_U_1(obj_tptr)) ? "Loose" : "Strict",
                               GET_IPADDR_STRING(obj_tptr+2),
                               GET_U_1((obj_tptr + 6)),
                               bittok2str(rsvp_obj_rro_flag_values,
                                   "none",
                                   GET_U_1((obj_tptr + 7)))); 
                    break;
                    case RSVP_OBJ_XRO_LABEL:
			if (length != 8) {
				ND_PRINT(" ERROR: length != 8");
				goto invalid;
			}
                        ND_PRINT(", Flags: [%s] (%#x), Class-Type: %s (%u), %u",
                               bittok2str(rsvp_obj_rro_label_flag_values,
                                   "none",
                                   GET_U_1((obj_tptr + 2))),
                               GET_U_1(obj_tptr + 2),
                               tok2str(rsvp_ctype_values,
                                       "Unknown",
                                       GET_U_1((obj_tptr + 3)) + (256 * RSVP_OBJ_RRO)),
                               GET_U_1((obj_tptr + 3)),
                               GET_BE_U_4(obj_tptr + 4));
                    }
                    obj_tlen-=length;
                    obj_tptr+=length;
                }
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_HELLO:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1:
            case RSVP_CTYPE_2:
                if (obj_tlen < 8)
                    goto obj_tooshort;
                ND_PRINT("%s  Source Instance: 0x%08x, Destination Instance: 0x%08x",
                       indent,
                       GET_BE_U_4(obj_tptr),
                       GET_BE_U_4(obj_tptr + 4));
                obj_tlen-=8;
                obj_tptr+=8;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_RESTART_CAPABILITY:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1:
                if (obj_tlen < 8)
                    goto obj_tooshort;
                ND_PRINT("%s  Restart  Time: %ums, Recovery Time: %ums",
                       indent,
                       GET_BE_U_4(obj_tptr),
                       GET_BE_U_4(obj_tptr + 4));
                obj_tlen-=8;
                obj_tptr+=8;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_CAPABILITY:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1:
                if (obj_tlen < 4)
                    goto obj_tooshort;
                unsigned int unused_and_flags = GET_BE_U_4(obj_tptr);
                if (unused_and_flags & ~RSVP_OBJ_CAPABILITY_FLAGS_MASK)
                    ND_PRINT("%s  [reserved=0x%08x must be zero]", indent,
                        unused_and_flags & ~RSVP_OBJ_CAPABILITY_FLAGS_MASK);
                ND_PRINT("%s  Flags: [%s]",
                       indent,
                       bittok2str(rsvp_obj_capability_flag_values,
                                  "none",
                                  (unused_and_flags & RSVP_OBJ_CAPABILITY_FLAGS_MASK)));
                obj_tlen-=4;
                obj_tptr+=4;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_SESSION_ATTRIBUTE:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_TUNNEL_IPV4:
                if (obj_tlen < 4)
                    goto obj_tooshort;
                namelen = GET_U_1(obj_tptr + 3);
                if (obj_tlen < 4+namelen)
                    goto obj_tooshort;
                ND_PRINT("%s  Session Name: ", indent);
                for (i = 0; i < namelen; i++)
                    fn_print_char(ndo, GET_U_1(obj_tptr + 4 + i));
                ND_PRINT("%s  Setup Priority: %u, Holding Priority: %u, Flags: [%s] (%#x)",
                       indent,
                       GET_U_1(obj_tptr),
                       GET_U_1(obj_tptr + 1),
                       bittok2str(rsvp_session_attribute_flag_values,
                                  "none",
                                  GET_U_1((obj_tptr + 2))),
                       GET_U_1(obj_tptr + 2));
                obj_tlen-=4+namelen;
                obj_tptr+=4+namelen;
                break;
            default:
                hexdump=TRUE;
            }
            break;
	case RSVP_OBJ_GENERALIZED_UNI:
            switch(rsvp_obj_ctype) {
		u_int subobj_type,af,subobj_len,total_subobj_len;
            case RSVP_CTYPE_1:
                if (obj_tlen < 4)
                    goto obj_tooshort;
		total_subobj_len = obj_tlen;
                while(total_subobj_len != 0) {
                    ND_ICHECK_U(total_subobj_len, <, 4);
                    subobj_len  = GET_BE_U_2(obj_tptr);
                    subobj_type = (GET_BE_U_2(obj_tptr + 2))>>8;
                    af = (GET_BE_U_2(obj_tptr + 2))&0x00FF;
                    ND_PRINT("%s  Subobject Type: %s (%u), AF: %s (%u), length: %u",
                           indent,
                           tok2str(rsvp_obj_generalized_uni_values, "Unknown", subobj_type),
                           subobj_type,
                           tok2str(af_values, "Unknown", af), af,
                           subobj_len);
                    if(subobj_len < 4 || subobj_len > total_subobj_len ||
                       obj_tlen < subobj_len)
                        goto invalid;
                    switch(subobj_type) {
                    case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:
                    case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:
                        switch(af) {
                        case AFNUM_IP:
                            if (subobj_len < 8)
                                goto subobj_tooshort;
                            ND_PRINT("%s    UNI IPv4 TNA address: %s",
                                   indent, GET_IPADDR_STRING(obj_tptr + 4));
                            break;
                        case AFNUM_IP6:
                            if (subobj_len < 20)
                                goto subobj_tooshort;
                            ND_PRINT("%s    UNI IPv6 TNA address: %s",
                                   indent, GET_IP6ADDR_STRING(obj_tptr + 4));
                            break;
                        case AFNUM_NSAP:
                            if (subobj_len) {
                                hexdump=TRUE;
                            }
                            break;
                        }
                        break;
                    case RSVP_GEN_UNI_SUBOBJ_DIVERSITY:
                        if (subobj_len > 4) {
                            hexdump=TRUE;
                        }
                        break;
                    case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL:
                        if (subobj_len < 16) {
                            goto subobj_tooshort;
                        }
                        ND_PRINT("%s    U-bit: %x, Label type: %u, Logical port id: %u, Label: %u",
                               indent,
                               ((GET_BE_U_4(obj_tptr + 4))>>31),
                               ((GET_BE_U_4(obj_tptr + 4))&0xFF),
                               GET_BE_U_4(obj_tptr + 8),
                               GET_BE_U_4(obj_tptr + 12));
                        break;
                    case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL:
                        if (subobj_len < 8) {
                            goto subobj_tooshort;
                        }
                        ND_PRINT("%s    Service level: %u",
                               indent, (GET_BE_U_4(obj_tptr + 4)) >> 24);
                        break;
                    default:
                        hexdump=TRUE;
                        break;
                    }
                    total_subobj_len-=subobj_len;
                    obj_tptr+=subobj_len;
                    obj_tlen+=subobj_len;
		}
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_RSVP_HOP:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_3: 
            case RSVP_CTYPE_IPV4:
                if (obj_tlen < 8)
                    goto obj_tooshort;
                ND_PRINT("%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x",
                       indent,
                       GET_IPADDR_STRING(obj_tptr),
                       GET_BE_U_4(obj_tptr + 4));
                obj_tlen-=8;
                obj_tptr+=8;
                if (obj_tlen)
                    hexdump=TRUE; 
                break;
            case RSVP_CTYPE_4: 
            case RSVP_CTYPE_IPV6:
                if (obj_tlen < 20)
                    goto obj_tooshort;
                ND_PRINT("%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x",
                       indent,
                       GET_IP6ADDR_STRING(obj_tptr),
                       GET_BE_U_4(obj_tptr + 16));
                obj_tlen-=20;
                obj_tptr+=20;
                hexdump=TRUE; 
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_TIME_VALUES:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1:
                if (obj_tlen < 4)
                    goto obj_tooshort;
                ND_PRINT("%s  Refresh Period: %ums",
                       indent,
                       GET_BE_U_4(obj_tptr));
                obj_tlen-=4;
                obj_tptr+=4;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_SENDER_TSPEC:
        case RSVP_OBJ_ADSPEC:
        case RSVP_OBJ_FLOWSPEC:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_2:
                if (obj_tlen < 4)
                    goto obj_tooshort;
                ND_PRINT("%s  Msg-Version: %u, length: %u",
                       indent,
                       (GET_U_1(obj_tptr) & 0xf0) >> 4,
                       GET_BE_U_2(obj_tptr + 2) << 2);
                obj_tptr+=4; 
                obj_tlen-=4;
                while (obj_tlen >= 4) {
                    intserv_serv_tlen=GET_BE_U_2(obj_tptr + 2)<<2;
                    ND_PRINT("%s  Service Type: %s (%u), break bit %sset, Service length: %u",
                           indent,
                           tok2str(rsvp_intserv_service_type_values,"unknown",GET_U_1((obj_tptr))),
                           GET_U_1(obj_tptr),
                           (GET_U_1(obj_tptr + 1)&0x80) ? "" : "not ",
                           intserv_serv_tlen);
                    obj_tptr+=4; 
                    obj_tlen-=4;
                    while (intserv_serv_tlen>=4) {
                        processed = rsvp_intserv_print(ndo, obj_tptr, obj_tlen);
                        if (processed == 0)
                            break;
                        obj_tlen-=processed;
                        intserv_serv_tlen-=processed;
                        obj_tptr+=processed;
                    }
                }
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_FILTERSPEC:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_IPV4:
                if (obj_tlen < 8)
                    goto obj_tooshort;
                ND_PRINT("%s  Source Address: %s, Source Port: %u",
                       indent,
                       GET_IPADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 6));
                obj_tlen-=8;
                obj_tptr+=8;
                break;
            case RSVP_CTYPE_IPV6:
                if (obj_tlen < 20)
                    goto obj_tooshort;
                ND_PRINT("%s  Source Address: %s, Source Port: %u",
                       indent,
                       GET_IP6ADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 18));
                obj_tlen-=20;
                obj_tptr+=20;
                break;
            case RSVP_CTYPE_3:
                if (obj_tlen < 20)
                    goto obj_tooshort;
                ND_PRINT("%s  Source Address: %s, Flow Label: %u",
                       indent,
                       GET_IP6ADDR_STRING(obj_tptr),
                       GET_BE_U_3(obj_tptr + 17));
                obj_tlen-=20;
                obj_tptr+=20;
                break;
            case RSVP_CTYPE_TUNNEL_IPV6:
                if (obj_tlen < 20)
                    goto obj_tooshort;
                ND_PRINT("%s  Source Address: %s, LSP-ID: 0x%04x",
                       indent,
                       GET_IPADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 18));
                obj_tlen-=20;
                obj_tptr+=20;
                break;
            case RSVP_CTYPE_13: 
                if (obj_tlen < 40)
                    goto obj_tooshort;
                ND_PRINT("%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x"
                       "%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x",
                       indent,
                       GET_IP6ADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 18),
                       indent,
                       GET_IP6ADDR_STRING(obj_tptr+20),
                       GET_BE_U_2(obj_tptr + 38));
                obj_tlen-=40;
                obj_tptr+=40;
                break;
            case RSVP_CTYPE_TUNNEL_IPV4:
                if (obj_tlen < 8)
                    goto obj_tooshort;
                ND_PRINT("%s  Source Address: %s, LSP-ID: 0x%04x",
                       indent,
                       GET_IPADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 6));
                obj_tlen-=8;
                obj_tptr+=8;
                break;
            case RSVP_CTYPE_12: 
                if (obj_tlen < 16)
                    goto obj_tooshort;
                ND_PRINT("%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x"
                       "%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x",
                       indent,
                       GET_IPADDR_STRING(obj_tptr),
                       GET_BE_U_2(obj_tptr + 6),
                       indent,
                       GET_IPADDR_STRING(obj_tptr+8),
                       GET_BE_U_2(obj_tptr + 12));
                obj_tlen-=16;
                obj_tptr+=16;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_FASTREROUTE:
            obj_ptr.rsvp_obj_frr = (const struct rsvp_obj_frr_t *)obj_tptr;
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1: 
                if (obj_tlen < sizeof(struct rsvp_obj_frr_t))
                    goto obj_tooshort;
                ND_PRINT("%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps",
                       indent,
                       GET_U_1(obj_ptr.rsvp_obj_frr->setup_prio),
                       GET_U_1(obj_ptr.rsvp_obj_frr->hold_prio),
                       GET_U_1(obj_ptr.rsvp_obj_frr->hop_limit),
                       GET_BE_F_4(obj_ptr.rsvp_obj_frr->bandwidth) * 8 / 1000000);
                ND_PRINT("%s  Include-any: 0x%08x, Exclude-any: 0x%08x, Include-all: 0x%08x",
                       indent,
                       GET_BE_U_4(obj_ptr.rsvp_obj_frr->include_any),
                       GET_BE_U_4(obj_ptr.rsvp_obj_frr->exclude_any),
                       GET_BE_U_4(obj_ptr.rsvp_obj_frr->include_all));
                obj_tlen-=sizeof(struct rsvp_obj_frr_t);
                obj_tptr+=sizeof(struct rsvp_obj_frr_t);
                break;
            case RSVP_CTYPE_TUNNEL_IPV4: 
                if (obj_tlen < 16)
                    goto obj_tooshort;
                ND_PRINT("%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps",
                       indent,
                       GET_U_1(obj_ptr.rsvp_obj_frr->setup_prio),
                       GET_U_1(obj_ptr.rsvp_obj_frr->hold_prio),
                       GET_U_1(obj_ptr.rsvp_obj_frr->hop_limit),
                       GET_BE_F_4(obj_ptr.rsvp_obj_frr->bandwidth) * 8 / 1000000);
                ND_PRINT("%s  Include Colors: 0x%08x, Exclude Colors: 0x%08x",
                       indent,
                       GET_BE_U_4(obj_ptr.rsvp_obj_frr->include_any),
                       GET_BE_U_4(obj_ptr.rsvp_obj_frr->exclude_any));
                obj_tlen-=16;
                obj_tptr+=16;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_DETOUR:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_TUNNEL_IPV4:
                while(obj_tlen >= 8) {
                    ND_PRINT("%s  PLR-ID: %s, Avoid-Node-ID: %s",
                           indent,
                           GET_IPADDR_STRING(obj_tptr),
                           GET_IPADDR_STRING(obj_tptr + 4));
                    obj_tlen-=8;
                    obj_tptr+=8;
                }
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_CLASSTYPE:
        case RSVP_OBJ_CLASSTYPE_OLD: 
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1:
                if (obj_tlen < 4)
                    goto obj_tooshort;
                ND_PRINT("%s  CT: %u",
                       indent,
                       GET_BE_U_4(obj_tptr) & 0x7);
                obj_tlen-=4;
                obj_tptr+=4;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_ERROR_SPEC:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_3: 
            case RSVP_CTYPE_IPV4:
                if (obj_tlen < 8)
                    goto obj_tooshort;
                error_code=GET_U_1(obj_tptr + 5);
                error_value=GET_BE_U_2(obj_tptr + 6);
                ND_PRINT("%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)",
                       indent,
                       GET_IPADDR_STRING(obj_tptr),
                       GET_U_1(obj_tptr + 4),
                       indent,
                       tok2str(rsvp_obj_error_code_values,"unknown",error_code),
                       error_code);
                switch (error_code) {
                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:
                    ND_PRINT(", Error Value: %s (%u)",
                           tok2str(rsvp_obj_error_code_routing_values,"unknown",error_value),
                           error_value);
                    break;
                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE: 
                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD:
                    ND_PRINT(", Error Value: %s (%u)",
                           tok2str(rsvp_obj_error_code_diffserv_te_values,"unknown",error_value),
                           error_value);
                    break;
                default:
                    ND_PRINT(", Unknown Error Value (%u)", error_value);
                    break;
                }
                obj_tlen-=8;
                obj_tptr+=8;
                break;
            case RSVP_CTYPE_4: 
            case RSVP_CTYPE_IPV6:
                if (obj_tlen < 20)
                    goto obj_tooshort;
                error_code=GET_U_1(obj_tptr + 17);
                error_value=GET_BE_U_2(obj_tptr + 18);
                ND_PRINT("%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)",
                       indent,
                       GET_IP6ADDR_STRING(obj_tptr),
                       GET_U_1(obj_tptr + 16),
                       indent,
                       tok2str(rsvp_obj_error_code_values,"unknown",error_code),
                       error_code);
                switch (error_code) {
                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:
                    ND_PRINT(", Error Value: %s (%u)",
                           tok2str(rsvp_obj_error_code_routing_values,"unknown",error_value),
			   error_value);
                    break;
                default:
                    break;
                }
                obj_tlen-=20;
                obj_tptr+=20;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_PROPERTIES:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1:
                if (obj_tlen < 4)
                    goto obj_tooshort;
                padbytes = GET_BE_U_2(obj_tptr + 2);
                ND_PRINT("%s  TLV count: %u, padding bytes: %u",
                       indent,
                       GET_BE_U_2(obj_tptr),
                       padbytes);
                obj_tlen-=4;
                obj_tptr+=4;
                while(obj_tlen >= 2 + padbytes) {
                    ND_PRINT("%s    %s TLV (0x%02x), length: %u", 
                           indent,
                           tok2str(rsvp_obj_prop_tlv_values,"unknown",GET_U_1(obj_tptr)),
                           GET_U_1(obj_tptr),
                           GET_U_1(obj_tptr + 1));
                    if (obj_tlen < GET_U_1(obj_tptr + 1))
                        goto obj_tooshort;
                    if (GET_U_1(obj_tptr + 1) < 2) {
                        ND_PRINT("%sERROR: property TLV is too short", indent);
                        return -1;
                    }
                    print_unknown_data(ndo, obj_tptr + 2, "\n\t\t",
                                       GET_U_1(obj_tptr + 1) - 2);
                    obj_tlen-=GET_U_1(obj_tptr + 1);
                    obj_tptr+=GET_U_1(obj_tptr + 1);
                }
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_MESSAGE_ID:     
        case RSVP_OBJ_MESSAGE_ID_ACK: 
        case RSVP_OBJ_MESSAGE_ID_LIST:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1:
            case RSVP_CTYPE_2:
                if (obj_tlen < 4)
                    goto obj_tooshort;
                ND_PRINT("%s  Flags [0x%02x], epoch: %u",
                       indent,
                       GET_U_1(obj_tptr),
                       GET_BE_U_3(obj_tptr + 1));
                obj_tlen-=4;
                obj_tptr+=4;
                while(obj_tlen >= 4) {
                    ND_PRINT("%s    Message-ID 0x%08x (%u)",
                           indent,
                           GET_BE_U_4(obj_tptr),
                           GET_BE_U_4(obj_tptr));
                    obj_tlen-=4;
                    obj_tptr+=4;
                }
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_INTEGRITY:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1:
                if (obj_tlen < sizeof(struct rsvp_obj_integrity_t))
                    goto obj_tooshort;
                obj_ptr.rsvp_obj_integrity = (const struct rsvp_obj_integrity_t *)obj_tptr;
                ND_PRINT("%s  Key-ID 0x%04x%08x, Sequence 0x%08x%08x, Flags [%s]",
                       indent,
                       GET_BE_U_2(obj_ptr.rsvp_obj_integrity->key_id),
                       GET_BE_U_4(obj_ptr.rsvp_obj_integrity->key_id + 2),
                       GET_BE_U_4(obj_ptr.rsvp_obj_integrity->sequence),
                       GET_BE_U_4(obj_ptr.rsvp_obj_integrity->sequence + 4),
                       bittok2str(rsvp_obj_integrity_flag_values,
                                  "none",
                                  GET_U_1(obj_ptr.rsvp_obj_integrity->flags)));
                ND_PRINT("%s  MD5-sum 0x%08x%08x%08x%08x ",
                       indent,
                       GET_BE_U_4(obj_ptr.rsvp_obj_integrity->digest),
                       GET_BE_U_4(obj_ptr.rsvp_obj_integrity->digest + 4),
                       GET_BE_U_4(obj_ptr.rsvp_obj_integrity->digest + 8),
                       GET_BE_U_4(obj_ptr.rsvp_obj_integrity->digest + 12));
                sigcheck = signature_verify(ndo, pptr, plen,
                                            obj_ptr.rsvp_obj_integrity->digest,
                                            rsvp_clear_checksum,
                                            rsvp_com_header);
                ND_PRINT(" (%s)", tok2str(signature_check_values, "Unknown", sigcheck));
                obj_tlen+=sizeof(struct rsvp_obj_integrity_t);
                obj_tptr+=sizeof(struct rsvp_obj_integrity_t);
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_ADMIN_STATUS:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1:
                if (obj_tlen < 4)
                    goto obj_tooshort;
                ND_PRINT("%s  Flags [%s]", indent,
                       bittok2str(rsvp_obj_admin_status_flag_values, "none",
                                  GET_BE_U_4(obj_tptr)));
                obj_tlen-=4;
                obj_tptr+=4;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_LABEL_SET:
            switch(rsvp_obj_ctype) {
            case RSVP_CTYPE_1:
                if (obj_tlen < 4)
                    goto obj_tooshort;
                action = (GET_BE_U_2(obj_tptr)>>8);
                ND_PRINT("%s  Action: %s (%u), Label type: %u", indent,
                       tok2str(rsvp_obj_label_set_action_values, "Unknown", action),
                       action, (GET_BE_U_4(obj_tptr) & 0x7F));
                switch (action) {
                case LABEL_SET_INCLUSIVE_RANGE:
                case LABEL_SET_EXCLUSIVE_RANGE: 
		    if (obj_tlen < 12)
			goto obj_tooshort;
		    ND_PRINT("%s  Start range: %u, End range: %u", indent,
                           GET_BE_U_4(obj_tptr + 4),
                           GET_BE_U_4(obj_tptr + 8));
		    obj_tlen-=12;
		    obj_tptr+=12;
                    break;
                default:
                    obj_tlen-=4;
                    obj_tptr+=4;
                    subchannel = 1;
                    while(obj_tlen >= 4 ) {
                        ND_PRINT("%s  Subchannel #%u: %u", indent, subchannel,
                               GET_BE_U_4(obj_tptr));
                        obj_tptr+=4;
                        obj_tlen-=4;
                        subchannel++;
                    }
                    break;
                }
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_S2L:
            switch (rsvp_obj_ctype) {
            case RSVP_CTYPE_IPV4:
                if (obj_tlen < 4)
                    goto obj_tooshort;
                ND_PRINT("%s  Sub-LSP destination address: %s",
                       indent, GET_IPADDR_STRING(obj_tptr));
                obj_tlen-=4;
                obj_tptr+=4;
                break;
            case RSVP_CTYPE_IPV6:
                if (obj_tlen < 16)
                    goto obj_tooshort;
                ND_PRINT("%s  Sub-LSP destination address: %s",
                       indent, GET_IP6ADDR_STRING(obj_tptr));
                obj_tlen-=16;
                obj_tptr+=16;
                break;
            default:
                hexdump=TRUE;
            }
            break;
        case RSVP_OBJ_SCOPE:
        case RSVP_OBJ_POLICY_DATA:
        case RSVP_OBJ_ACCEPT_LABEL_SET:
        case RSVP_OBJ_PROTECTION:
        default:
            if (ndo->ndo_vflag <= 1)
                print_unknown_data(ndo, obj_tptr, "\n\t    ", obj_tlen); 
            break;
        }
        if (ndo->ndo_vflag > 1 || hexdump == TRUE)
            print_unknown_data(ndo, tptr + sizeof(struct rsvp_object_header), "\n\t    ", 
                               rsvp_obj_len - sizeof(struct rsvp_object_header));
        tptr+=rsvp_obj_len;
        tlen-=rsvp_obj_len;
    }
    return 0;
subobj_tooshort:
    ND_PRINT("%sERROR: sub-object is too short", indent);
    return -1;
obj_tooshort:
    ND_PRINT("%sERROR: object is too short", indent);
    return -1;
invalid:
    nd_print_invalid(ndo);
    return -1;
}
