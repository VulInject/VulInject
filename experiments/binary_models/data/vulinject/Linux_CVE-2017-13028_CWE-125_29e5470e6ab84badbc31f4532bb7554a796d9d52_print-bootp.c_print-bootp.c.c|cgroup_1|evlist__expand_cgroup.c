int evlist__expand_cgroup(struct evlist *evlist, const char *str,
			  struct rblist *metric_events, bool open_cgroup)
{
	struct evlist *orig_list, *tmp_list;
	struct evsel *pos, *evsel, *leader;
	struct rblist orig_metric_events;
	struct cgroup *cgrp = NULL;
	struct cgroup_name *cn;
	int ret = -1;
	int prefix_len;
	if (evlist->core.nr_entries == 0) {
		fprintf(stderr, "must define events before cgroups\n");
		return -EINVAL;
	}
	orig_list = evlist__new();
	tmp_list = evlist__new();
	if (orig_list == NULL || tmp_list == NULL) {
		fprintf(stderr, "memory allocation failed\n");
		return -ENOMEM;
	}
	evlist__splice_list_tail(orig_list, &evlist->core.entries);
	evlist->core.nr_entries = 0;
	if (metric_events) {
		orig_metric_events = *metric_events;
		rblist__init(metric_events);
	} else {
		rblist__init(&orig_metric_events);
	}
	if (has_pattern_string(str))
		prefix_len = match_cgroups(str);
	else
		prefix_len = list_cgroups(str);
	if (prefix_len < 0)
		goto out_err;
	list_for_each_entry(cn, &cgroup_list, list) {
		char *name;
		if (!cn->used)
			continue;
		name = cn->name + prefix_len;
		if (name[0] == '/' && name[1])
			name++;
		cgrp = cgroup__new(name, open_cgroup);
		if (cgrp == NULL)
			continue;
		leader = NULL;
		evlist__for_each_entry(orig_list, pos) {
			evsel = evsel__clone(pos);
			if (evsel == NULL)
				goto out_err;
			evsel->cgrp = cgroup__get(cgrp);
			if (evsel__is_group_leader(pos))
				leader = evsel;
			evsel__set_leader(evsel, leader);
			evlist__add(tmp_list, evsel);
		}
		cgroup__put(cgrp);
		nr_cgroups++;
		if (metric_events) {
			if (metricgroup__copy_metric_events(tmp_list, cgrp,
							    metric_events,
							    &orig_metric_events) < 0)
				goto out_err;
		}
		evlist__splice_list_tail(evlist, &tmp_list->core.entries);
		tmp_list->core.nr_entries = 0;
	}
	if (list_empty(&evlist->core.entries)) {
		fprintf(stderr, "no cgroup matched: %s\n", str);
		goto out_err;
	}
	ret = 0;
	cgrp_event_expanded = true;
out_err:
	evlist__delete(orig_list);
	evlist__delete(tmp_list);
	rblist__exit(&orig_metric_events);
	release_cgroup_list();
	return ret;
}
