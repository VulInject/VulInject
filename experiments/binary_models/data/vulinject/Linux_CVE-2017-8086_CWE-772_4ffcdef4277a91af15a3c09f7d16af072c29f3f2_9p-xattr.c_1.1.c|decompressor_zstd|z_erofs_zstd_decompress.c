int z_erofs_zstd_decompress(struct z_erofs_decompress_req *rq,
			    struct page **pgpl)
{
	const unsigned int nrpages_out =
		PAGE_ALIGN(rq->pageofs_out + rq->outputsize) >> PAGE_SHIFT;
	const unsigned int nrpages_in =
		PAGE_ALIGN(rq->inputsize) >> PAGE_SHIFT;
	zstd_dstream *stream;
	struct super_block *sb = rq->sb;
	unsigned int insz, outsz, pofs;
	struct z_erofs_zstd *strm;
	zstd_in_buffer in_buf = { NULL, 0, 0 };
	zstd_out_buffer out_buf = { NULL, 0, 0 };
	unsigned char *kin, *kout = NULL;
	bool bounced = false;
	int no = -1, ni = 0, j = 0, zerr, err;
	kin = kmap_local_page(*rq->in);
	err = z_erofs_fixup_insize(rq, kin + rq->pageofs_in,
			min_t(unsigned int, rq->inputsize,
			      sb->s_blocksize - rq->pageofs_in));
	if (err) {
		return err;
	}
	strm = z_erofs_isolate_strms(false);
	insz = rq->inputsize;
	outsz = rq->outputsize;
	stream = zstd_init_dstream(z_erofs_zstd_max_dictsize, strm->wksp, strm->wkspsz);
	if (!stream) {
		err = -EIO;
		goto failed_zinit;
	}
	pofs = rq->pageofs_out;
	in_buf.size = min_t(unsigned int, insz, PAGE_SIZE - rq->pageofs_in);
	insz -= in_buf.size;
	in_buf.src = kin + rq->pageofs_in;
	do {
		if (out_buf.size == out_buf.pos) {
			if (++no >= nrpages_out || !outsz) {
				erofs_err(sb, "insufficient space for decompressed data");
				err = -EFSCORRUPTED;
				break;
			}
			if (kout)
				kunmap_local(kout);
			out_buf.size = min_t(unsigned int, outsz, PAGE_SIZE - pofs);
			outsz -= out_buf.size;
			if (!rq->out[no]) {
				rq->out[no] = erofs_allocpage(pgpl, rq->gfp);
				if (!rq->out[no]) {
					kout = NULL;
					err = -ENOMEM;
					break;
				}
				set_page_private(rq->out[no],
						 Z_EROFS_SHORTLIVED_PAGE);
			}
			kout = kmap_local_page(rq->out[no]);
			out_buf.dst = kout + pofs;
			out_buf.pos = 0;
			pofs = 0;
		}
		if (in_buf.size == in_buf.pos && insz) {
			if (++ni >= nrpages_in) {
				erofs_err(sb, "invalid compressed data");
				err = -EFSCORRUPTED;
				break;
			}
			if (kout) 
				kunmap_local(kout);
			kunmap_local(kin);
			in_buf.size = min_t(unsigned int, insz, PAGE_SIZE);
			insz -= in_buf.size;
			kin = kmap_local_page(rq->in[ni]);
			in_buf.src = kin;
			in_buf.pos = 0;
			bounced = false;
			if (kout) {
				j = (unsigned char *)out_buf.dst - kout;
				kout = kmap_local_page(rq->out[no]);
				out_buf.dst = kout + j;
			}
		}
		if (!bounced && rq->out[no] == rq->in[ni]) {
			memcpy(strm->bounce, in_buf.src, in_buf.size);
			in_buf.src = strm->bounce;
			bounced = true;
		}
		for (j = ni + 1; j < nrpages_in; ++j) {
			struct page *tmppage;
			if (rq->out[no] != rq->in[j])
				continue;
			tmppage = erofs_allocpage(pgpl, rq->gfp);
			if (!tmppage) {
				err = -ENOMEM;
				goto failed;
			}
			set_page_private(tmppage, Z_EROFS_SHORTLIVED_PAGE);
			copy_highpage(tmppage, rq->in[j]);
			rq->in[j] = tmppage;
		}
		zerr = zstd_decompress_stream(stream, &out_buf, &in_buf);
		if (zstd_is_error(zerr) || (!zerr && outsz)) {
			erofs_err(sb, "failed to decompress in[%u] out[%u]: %s",
				  rq->inputsize, rq->outputsize,
				  zerr ? zstd_get_error_name(zerr) : "unexpected end of stream");
			err = -EFSCORRUPTED;
			break;
		}
	} while (outsz || out_buf.pos < out_buf.size);
failed:
	if (kout)
		kunmap_local(kout);
failed_zinit:
	kunmap_local(kin);
	spin_lock(&z_erofs_zstd_lock);
	strm->next = z_erofs_zstd_head;
	z_erofs_zstd_head = strm;
	spin_unlock(&z_erofs_zstd_lock);
	wake_up(&z_erofs_zstd_wq);
	return err;
}
