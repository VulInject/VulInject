fnmatch (const char *pattern, const char *string, int flags)
{
  if (__glibc_unlikely (MB_CUR_MAX != 1))
    {
      mbstate_t ps;
      size_t n;
      const char *p;
      WCHAR_T *wpattern_malloc = NULL;
      WCHAR_T *wpattern;
      WCHAR_T *wstring_malloc = NULL;
      WCHAR_T *wstring;
      size_t alloca_used = 0;
      memset (&ps, '\0', sizeof (ps));
      p = pattern;
      n = strnlen (pattern, 1024);
      if (__glibc_likely (n < 1024))
        {
          wpattern = (WCHAR_T *) alloca_account ((n + 1) * sizeof (WCHAR_T),
                                                 alloca_used);
          n = MBSRTOWCS (wpattern, &p, n + 1, &ps);
          if (__glibc_unlikely (n == (size_t) -1))
            return -1;
          if (p)
            {
              memset (&ps, '\0', sizeof (ps));
              goto prepare_wpattern;
            }
        }
      else
        {
        prepare_wpattern:
          n = MBSRTOWCS (NULL, &pattern, 0, &ps);
          if (__glibc_unlikely (n == (size_t) -1))
            return -1;
          if (__glibc_unlikely (n >= (size_t) -1 / sizeof (WCHAR_T)))
            {
              return -2;
            }
          wpattern_malloc = wpattern
            = (WCHAR_T *) malloc ((n + 1) * sizeof (WCHAR_T));
          assert (mbsinit (&ps));
          if (wpattern == NULL)
            return -2;
          (void) MBSRTOWCS (wpattern, &pattern, n + 1, &ps);
        }
      assert (mbsinit (&ps));
      n = strnlen (string, 1024);
      p = string;
      if (__glibc_likely (n < 1024))
        {
          wstring = (WCHAR_T *) alloca_account ((n + 1) * sizeof (WCHAR_T),
                                                alloca_used);
          n = MBSRTOWCS (wstring, &p, n + 1, &ps);
          if (__glibc_unlikely (n == (size_t) -1))
            {
            free_return:
              free (wpattern_malloc);
              return -1;
            }
          if (p)
            {
              memset (&ps, '\0', sizeof (ps));
              goto prepare_wstring;
            }
        }
      else
        {
        prepare_wstring:
          n = MBSRTOWCS (NULL, &string, 0, &ps);
          if (__glibc_unlikely (n == (size_t) -1))
            goto free_return;
          if (__glibc_unlikely (n >= (size_t) -1 / sizeof (WCHAR_T)))
            {
              free (wpattern_malloc);
              __set_errno (ENOMEM);
              return -2;
            }
          wstring_malloc = wstring
            = (WCHAR_T *) malloc ((n + 1) * sizeof (WCHAR_T));
          if (wstring == NULL)
            {
              free (wpattern_malloc);
              return -2;
            }
          assert (mbsinit (&ps));
          (void) MBSRTOWCS (wstring, &string, n + 1, &ps);
        }
      int res = internal_fnwmatch (wpattern, wstring, wstring + n,
                                   flags & FNM_PERIOD, flags, NULL,
                                   alloca_used);
      free (wstring_malloc);
      free (wpattern_malloc);
      return res;
    }
  return internal_fnmatch (pattern, string, string + strlen (string),
                           flags & FNM_PERIOD, flags, NULL, 0);
}
