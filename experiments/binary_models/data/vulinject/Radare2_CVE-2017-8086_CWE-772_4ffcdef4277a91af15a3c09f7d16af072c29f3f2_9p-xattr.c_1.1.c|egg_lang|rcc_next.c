static void rcc_next(REgg *egg) {
	const char *ocn;
	REggEmit *e = egg->remit;
	char *str = NULL, *p, *ptr, buf[64];
	int i;
	if (egg->lang.setenviron) {
		egg->lang.elem[egg->lang.elem_n - 1] = 0;
		r_sys_setenv (egg->lang.setenviron, egg->lang.elem);
		R_FREE (egg->lang.setenviron);
		return;
	}
	if (egg->lang.includefile) {
		char *p, *q, *path;
		egg->lang.elem[egg->lang.elem_n - 1] = 0;
		path = find_include (egg->lang.includedir, egg->lang.includefile);
		if (!path) {
			R_LOG_ERROR ("Cannot find include file '%s'", egg->lang.elem);
			return;
		}
		R_FREE (egg->lang.includefile);
		R_FREE (egg->lang.includedir);
		p = q = r_file_slurp (path, NULL);
		if (p) {
			int oline = ++(egg->lang.line);
			egg->lang.elem[0] = 0;	
			egg->lang.elem_n = 0;
			egg->lang.line = 0;
			for (; *p; p++) {
				r_egg_lang_parsechar (egg, *p);
			}
			free (q);
			egg->lang.line = oline;
		} else {
			R_LOG_ERROR ("Cannot find '%s'", path);
		}
		free (path);
		return;
	}
	egg->lang.docall = 1;
	if (egg->lang.callname) {
		if (!strcmp (egg->lang.callname, "goto")) {
			if (egg->lang.nargs != 1) {
				R_LOG_ERROR ("Invalid number of arguments for goto()");
				return;
			}
			e->jmp (egg, egg->lang.ctxpush[CTX], 0);
			rcc_reset_callname (egg);
			return;
		}
		if (!strcmp (egg->lang.callname, "break")) {
			e->trap (egg);
			rcc_reset_callname (egg);
			return;
		}
		ptr = strchr (egg->lang.callname, '=');
		if (ptr) {
			*ptr = '\0';
		}
		ocn = r_str_trim_head_ro (egg->lang.callname);
		if (!ocn) {
			return;
		}
		str = r_egg_mkvar (egg, buf, ocn, 0);
		if (!str) {
			R_LOG_ERROR ("Cannot mkvar");
			return;
		}
		if (*ocn == '.') {
			e->call (egg, str, 1);
		}
		if (!strcmp (str, "while")) {
			char var[128];
			if (egg->lang.lastctxdelta >= 0) {
				R_LOG_ERROR ("Unsupported while syntax");
				return;
			}
			snprintf (var, sizeof (var), "__begin_%d_%d_%d\n", egg->lang.nfunctions, CTX, egg->lang.nestedi[CTX - 1]);
			e->while_end (egg, var);
#if 0
			eprintf ("------------------------------------------ lastctx: %d\n", egg->lang.lastctxdelta);
			rcc_printf ("  pop %%eax\n");
			rcc_printf ("  cmp $0, %%eax\n");	
			if (egg->lang.lastctxdelta < 0) {
				rcc_printf ("  jnz %s\n", get_frame_label (1));
			} else {
				rcc_printf ("  jnz %s\n", get_frame_label (0));
			}
#endif
			egg->lang.nargs = 0;
		} else {
			for (i = 0; i < egg->lang.nsyscalls; i++) {
				if (!strcmp (str, egg->lang.syscalls[i].name)) {
					p = egg->lang.syscallbody;
					e->comment (egg, "set syscall args");
					e->syscall_args (egg, egg->lang.nargs);
					egg->lang.docall = 0;
					e->comment (egg, "syscall");
					r_egg_lang_parsechar (egg, '\n');	
					if (p) {
						for (; *p; p++) {
							r_egg_lang_parsechar (egg, *p);
						}
					} else {
						char *q, *s = e->syscall (egg, egg->lang.nargs);
						if (s) {
							for (q = s; *q; q++) {
								r_egg_lang_parsechar (egg, *q);
							}
							free (s);
						} else {
							R_LOG_ERROR ("Cannot get @syscall payload");
						}
					}
					egg->lang.docall = 0;
					break;
				}
			}
			if (egg->lang.docall) {
				for (i = 0; i < egg->lang.ninlines; i++) {
					if (!strcmp (str, egg->lang.inlines[i].name)) {
						p = egg->lang.inlines[i].body;
						egg->lang.docall = 0;
						e->comment (egg, "inline");
						r_egg_lang_parsechar (egg, '\n');	
						for (; *p; p++) {
							r_egg_lang_parsechar (egg, *p);
						}
						egg->lang.docall = 0;
						break;
					}
				}
			}
			if (egg->lang.docall) {
				e->comment (egg, "call in egg->lang.mode %d", egg->lang.mode);
				e->call (egg, str, 0);
			}
		}
		if (egg->lang.nargs > 0) {
			e->restore_stack (egg, egg->lang.nargs * e->size);
		}
		if (egg->lang.dstvar) {
			*buf = 0;
			free (str);
			str = r_egg_mkvar (egg, buf, egg->lang.dstvar, 0);
			if (*buf == 0) {
				R_LOG_ERROR ("Cannot resolve variable '%s'", egg->lang.dstvar);
			} else {
				e->get_result (egg, buf);
			}
			R_FREE (egg->lang.dstvar);
		}
		rcc_reset_callname (egg);
	} else {
		int vs = 'l';
		char type, *eq, *ptr = egg->lang.elem, *tmp;
		egg->lang.elem[egg->lang.elem_n] = '\0';
		ptr = (char *) r_str_trim_head_ro (ptr);
		if (*ptr) {
			eq = strchr (ptr, '=');
			if (eq) {
				vs = egg->lang.varsize;
				*buf = *eq = '\x00';
				e->mathop (egg, '=', vs, '$', "0", e->regs (egg, 1));
				egg->lang.mathline = r_str_trim_dup (eq + 1);
				tmp = egg->lang.mathline;
				rcc_mathop (egg, &tmp, 2);
				R_FREE (egg->lang.mathline);
				tmp = NULL;
				char *p = r_egg_mkvar (egg, buf, ptr, 0);
				if (is_var (p)) {
					char *q = r_egg_mkvar (egg, buf, p, 0);
					if (q) {
						free (p);
						p = q;
					}
					if (egg->lang.varxs == '*' || egg->lang.varxs == '&') {
						R_LOG_ERROR ("not support for *ptr in egg->lang.dstvar");
					}
					type = ' ';
				} else {
					type = '$';
				}
				e->mathop (egg, '=', vs, type, e->regs (egg, 1), p);
				free (p);
#if 0
				char str2[64], *p, ch = *(eq-1);
				*eq = '\0';
				eq = (char*) skipspaces (eq+1);
				p = r_egg_mkvar (egg, str2, ptr, 0);
				vs = egg->lang.varsize;
				if (is_var (eq)) {
					eq = r_egg_mkvar (egg, buf, eq, 0);
					if (egg->lang.varxs == '*') {
						e->load (egg, eq, egg->lang.varsize);
					} else if (egg->lang.varxs == '&') {
						e->load_ptr (egg, eq);
					}
					R_FREE (eq);
					type = ' ';
				} else {
					type = '$';
				}
				vs = 'l'; 
				eprintf("Getting into e->mathop with ch: %c\n", ch);
				eprintf("Getting into e->mathop with vs: %c\n", vs);
				eprintf("Getting into e->mathop with type: %c\n", type);
				eprintf("Getting into e->mathop with eq: %s\n", eq);
				eprintf("Getting into e->mathop with p: %s\n", p);
				e->mathop (egg, ch, vs, type, eq, p);
				free (p);
#endif
			} else {
				if (!strcmp (ptr, "break")) {	
					e->trap (egg);
					rcc_reset_callname (egg);
				} else {
					e->mathop (egg, '=', vs, '$', ptr, NULL);
				}
			}
		}
	}
	free (str);
}
