static bool mac8390_rsrc_init(struct net_device *dev,
			      struct nubus_rsrc *fres,
			      enum mac8390_type cardtype)
{
	struct nubus_board *board = fres->board;
	struct nubus_dir dir;
	struct nubus_dirent ent;
	int offset;
	volatile unsigned short *i;
	unsigned char addr[ETH_ALEN];
	dev->irq = SLOT2IRQ(board->slot);
	dev->base_addr = board->slot_addr | ((board->slot & 0xf) << 20);
	if (nubus_get_func_dir(fres, &dir) == -1) {
		dev_err(&board->dev,
			"Unable to get Nubus functional directory\n");
		return false;
	}
	if (nubus_find_rsrc(&dir, NUBUS_RESID_MAC_ADDRESS, &ent) == -1) {
		dev_info(&board->dev, "MAC address resource not found\n");
		return false;
	}
	eth_hw_addr_set(dev, addr);
	if (useresources[cardtype] == 1) {
		nubus_rewinddir(&dir);
		if (nubus_find_rsrc(&dir, NUBUS_RESID_MINOR_BASEOS,
				    &ent) == -1) {
			dev_err(&board->dev,
				"Memory offset resource not found\n");
			return false;
		}
		nubus_get_rsrc_mem(&offset, &ent, 4);
		dev->mem_start = dev->base_addr + offset;
		dev->base_addr = dev->mem_start + 0x10000;
		nubus_rewinddir(&dir);
		if (nubus_find_rsrc(&dir, NUBUS_RESID_MINOR_LENGTH,
				    &ent) == -1) {
			dev_info(&board->dev,
				 "Memory length resource not found, probing\n");
			offset = mac8390_memsize(dev->mem_start);
		} else {
			nubus_get_rsrc_mem(&offset, &ent, 4);
		}
		dev->mem_end = dev->mem_start + offset;
	} else {
		switch (cardtype) {
		case MAC8390_KINETICS:
		case MAC8390_DAYNA: 
			dev->base_addr = (int)(board->slot_addr +
					       DAYNA_8390_BASE);
			dev->mem_start = (int)(board->slot_addr +
					       DAYNA_8390_MEM);
			dev->mem_end = dev->mem_start +
				       mac8390_memsize(dev->mem_start);
			break;
		case MAC8390_INTERLAN:
			dev->base_addr = (int)(board->slot_addr +
					       INTERLAN_8390_BASE);
			dev->mem_start = (int)(board->slot_addr +
					       INTERLAN_8390_MEM);
			dev->mem_end = dev->mem_start +
				       mac8390_memsize(dev->mem_start);
			break;
		case MAC8390_CABLETRON:
			dev->base_addr = (int)(board->slot_addr +
					       CABLETRON_8390_BASE);
			dev->mem_start = (int)(board->slot_addr +
					       CABLETRON_8390_MEM);
			i = (void *)dev->base_addr;
			*i = 0x21;
			dev->mem_end = dev->mem_start +
				       mac8390_memsize(dev->mem_start);
			break;
		default:
			dev_err(&board->dev,
				"No known base address for card type\n");
			return false;
		}
	}
	return true;
}
