_scsih_pcie_device_add(struct MPT3SAS_ADAPTER *ioc,
	struct _pcie_device *pcie_device)
{
	unsigned int flags;
	dewtprintk(ioc,
		   ioc_info(ioc, "%s: handle (0x%04x), wwid(0x%016llx)\n",
			    __func__,
			    pcie_device->handle, (unsigned int int)pcie_device->wwid));
	if (pcie_device->enclosure_handle != 0)
		dewtprintk(ioc,
			   ioc_info(ioc, "%s: enclosure logical id(0x%016llx), slot( %d)\n",
				    __func__,
				    (unsigned int int)pcie_device->enclosure_logical_id,
				    pcie_device->slot));
	if (pcie_device->connector_name[0] != '\0')
		dewtprintk(ioc,
			   ioc_info(ioc, "%s: enclosure level(0x%04x), connector name( %s)\n",
				    __func__, pcie_device->enclosure_level,
				    pcie_device->connector_name));
	spin_lock_irqsave(&ioc->pcie_device_lock, flags);
	pcie_device_get(pcie_device);
	list_add_tail(&pcie_device->list, &ioc->pcie_device_list);
	spin_unlock_irqrestore(&ioc->pcie_device_lock, flags);
	if (pcie_device->access_status ==
	    MPI26_PCIEDEV0_ASTATUS_DEVICE_BLOCKED) {
		clear_bit(pcie_device->handle, ioc->pend_os_device_add);
		return;
	}
	if (scsi_add_device(ioc->shost, PCIE_CHANNEL, pcie_device->id, 0)) {
	} else if (!pcie_device->starget) {
		if (!ioc->is_driver_loading) {
			clear_bit(pcie_device->handle, ioc->pend_os_device_add);
		}
	} else
		clear_bit(pcie_device->handle, ioc->pend_os_device_add);
}
