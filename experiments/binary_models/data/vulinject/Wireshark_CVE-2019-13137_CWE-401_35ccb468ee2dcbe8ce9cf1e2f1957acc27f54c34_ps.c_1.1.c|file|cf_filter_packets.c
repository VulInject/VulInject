cf_filter_packets(capture_file *cf, gchar *dftext, gboolean force)
{
    const char *filter_new = dftext ? dftext : "";
    const char *filter_old = cf->dfilter ? cf->dfilter : "";
    dfilter_t  *dfcode;
    df_error_t *df_err;
    if (!force && strcmp(filter_new, filter_old) == 0) {
        return CF_OK;
    }
    dfcode=NULL;
    if (dftext == NULL) {
    } else {
        if (!dfilter_compile(dftext, &dfcode, &df_err)) {
            simple_message_box(ESD_TYPE_ERROR, NULL,
                    "See the help for a description of the display filter syntax.",
                    "\"%s\" isn't a valid display filter: %s",
                    dftext, df_err->msg);
            df_error_free(&df_err);
            g_free(dftext);
            return CF_ERROR;
        }
        if (dfcode == NULL) {
            g_free(dftext);
            dftext = NULL;
        }
    }
    g_free(cf->dfilter);
    cf->dfilter = dftext;
    dfilter_free(cf->dfcode);
    cf->dfcode = dfcode;
    if (cf->redissection_queued == RESCAN_NONE) {
        if (cf->read_lock) {
            cf->redissection_queued = RESCAN_SCAN;
        } else if (cf->state != FILE_CLOSED) {
            if (dftext == NULL) {
                rescan_packets(cf, "Resetting", "filter", FALSE);
            } else {
                rescan_packets(cf, "Filtering", dftext, FALSE);
            }
        }
    }
    return CF_OK;
}
