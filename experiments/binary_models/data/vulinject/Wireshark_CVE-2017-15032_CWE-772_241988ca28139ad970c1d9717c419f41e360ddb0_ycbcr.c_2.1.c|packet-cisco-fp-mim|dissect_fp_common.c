dissect_fp_common ( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int header_size)
{
  proto_item   *ti;
  proto_tree   *fp_tree;
  proto_tree   *fp_addr_tree;
  tvbuff_t     *next_tvb;
  int           offset   = 0;
  int           next_tvb_len = 0;
  int           fcs_offset = 0;
  guint64       hmac_src;
  guint64       hmac_dst;
  guint16       sswid    = 0;
  guint16       ssswid   = 0;
  guint16       slid     = 0;
  guint16       dswid    = 0;
  guint16       dsswid   = 0;
  guint16       dlid     = 0;
  guint16       etype    = 0;
  const guint8 *dst_addr = NULL;
  gboolean      dest_as_mac  = FALSE;
  col_set_str( pinfo->cinfo, COL_PROTOCOL, FP_PROTO_COL_NAME );
  col_set_str( pinfo->cinfo, COL_INFO, FP_PROTO_COL_INFO );
  hmac_dst = tvb_get_ntoh48 (tvb, 0);
  hmac_src = tvb_get_ntoh48 (tvb, 6);
  if (hmac_dst & MAC_MC_BC) {
    dest_as_mac = TRUE;
  }
  if (!dest_as_mac) {
    fp_get_hmac_addr (hmac_dst, &dswid, &dsswid, &dlid);
  } else {
    dst_addr = ((const guint8 *) &hmac_dst) + 2;
  }
  fp_get_hmac_addr (hmac_src, &sswid, &ssswid, &slid);
  if (tree && PTREE_DATA(tree)->visible) {
    if (dest_as_mac) {
      address      ether_addr;
      set_address(&ether_addr, AT_ETHER, 6, dst_addr);
      ti = proto_tree_add_protocol_format(tree, proto_fp, tvb, 0, header_size,
                                          "Cisco FabricPath, Src: %03x.%02x.%04x, Dst: %s",
                                          sswid, ssswid, slid,
                                          address_with_resolution_to_str(pinfo->pool, &ether_addr));
    } else {
      ti = proto_tree_add_protocol_format(tree, proto_fp, tvb, 0, header_size,
                                          "Cisco FabricPath, Src: %03x.%02x.%04x, Dst: %03x.%02x.%04x",
                                          sswid, ssswid, slid,
                                          dswid, dsswid, dlid);
    }
  } else {
    ti = proto_tree_add_item( tree, proto_fp, tvb, 0, header_size, ENC_NA );
  }
  fp_tree = proto_item_add_subtree( ti, ett_mim );
  if (dest_as_mac) {
    proto_tree_add_ether( fp_tree,  hf_d_hmac_mc, tvb, offset, 6, dst_addr);
  } else {
    ti = proto_tree_add_none_format (fp_tree, hf_d_hmac, tvb, offset, 6, "Destination: %03x.%02x.%04x", dswid, dsswid, dlid);
    fp_addr_tree = proto_item_add_subtree (ti, ett_hmac);
    fp_add_hmac (tvb, fp_addr_tree, offset);
  }
  offset += FP_HMAC_LEN;
  ti = proto_tree_add_none_format (fp_tree, hf_s_hmac, tvb, offset, 6,
                                   "Source: %03x.%02x.%04x", sswid, ssswid, slid);
  fp_addr_tree = proto_item_add_subtree (ti, ett_hmac);
  fp_add_hmac (tvb, fp_addr_tree, offset);
  offset += FP_HMAC_LEN;
  etype = tvb_get_ntohs(tvb, offset);
  switch (etype) {
  case ETHERTYPE_DCE:
      proto_tree_add_item(fp_tree, hf_fp_etype, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      break;
  case ETHERTYPE_IEEE_802_1AD:
  case ETHERTYPE_VLAN:
      proto_tree_add_item(fp_tree, hf_fp_1ad_etype, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      proto_tree_add_item(fp_tree, hf_fp_1ad_priority, tvb, offset, 2, ENC_NA);
      proto_tree_add_item(fp_tree, hf_fp_1ad_cfi, tvb, offset, 2, ENC_NA);
      proto_tree_add_item(fp_tree, hf_fp_1ad_svid, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      proto_tree_add_item(fp_tree, hf_fp_etype, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
      break;
  default:
      DISSECTOR_ASSERT(0);
  }
  proto_tree_add_item (fp_tree, hf_ftag, tvb, offset, FP_FTAG_LEN, ENC_BIG_ENDIAN);
  proto_tree_add_item (fp_tree, hf_ttl, tvb, offset, FP_FTAG_LEN, ENC_BIG_ENDIAN);
  fcs_offset = tvb_reported_length(tvb) - 4;
  if ( tvb_bytes_exist(tvb, fcs_offset, 4 ) ) {
    if ( fp_check_fcs ) {
      guint32 fcs = crc32_802_tvb(tvb, fcs_offset);
      proto_tree_add_checksum(fp_tree, tvb, fcs_offset, hf_fp_fcs, hf_fp_fcs_status, &ei_fp_fcs_bad, pinfo, fcs, ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY);
    } else {
      proto_tree_add_checksum(fp_tree, tvb, fcs_offset, hf_fp_fcs, hf_fp_fcs_status, &ei_fp_fcs_bad, pinfo, 0, ENC_BIG_ENDIAN, PROTO_CHECKSUM_NO_FLAGS);
    }
    proto_tree_set_appendix(fp_tree, tvb, fcs_offset, 4);
  }
  next_tvb_len = tvb_reported_length_remaining( tvb, header_size ) - 4;
  next_tvb = tvb_new_subset_length( tvb, header_size, next_tvb_len );
  call_dissector( eth_withoutfcs_dissector, next_tvb, pinfo, tree );
  return tvb_captured_length( tvb );
}
