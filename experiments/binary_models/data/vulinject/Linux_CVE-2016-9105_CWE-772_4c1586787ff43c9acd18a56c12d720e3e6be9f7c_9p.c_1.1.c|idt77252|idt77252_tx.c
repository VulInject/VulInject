idt77252_tx(struct idt77252_dev *card)
{
	struct tsq_entry *tsqe;
	unsigned int vpi, vci;
	struct vc_map *vc;
	unsigned int conn, stat;
	if (card->tsq.next == card->tsq.last)
		tsqe = card->tsq.base;
	else
		tsqe = card->tsq.next + 1;
	TXPRINTK("idt77252_tx: tsq  %p: base %p, next %p, last %p\n", tsqe,
		 card->tsq.base, card->tsq.next, card->tsq.last);
	TXPRINTK("idt77252_tx: tsqb %08x, tsqt %08x, tsqh %08x, \n",
		 readl(SAR_REG_TSQB),
		 readl(SAR_REG_TSQT),
		 readl(SAR_REG_TSQH));
	stat = le32_to_cpu(tsqe->word_2);
	if (stat & SAR_TSQE_INVALID)
		return;
	do {
		TXPRINTK("tsqe: 0x%p [0x%08x 0x%08x]\n", tsqe,
			 le32_to_cpu(tsqe->word_1),
			 le32_to_cpu(tsqe->word_2));
		switch (stat & SAR_TSQE_TYPE) {
		case SAR_TSQE_TYPE_TIMER:
			TXPRINTK("%s: Timer RollOver detected.\n", card->name);
			break;
		case SAR_TSQE_TYPE_IDLE:
			conn = le32_to_cpu(tsqe->word_1);
			if (SAR_TSQE_TAG(stat) == 0x10) {
#ifdef	NOTDEF
				printk("%s: Connection %d halted.\n",
				       card->name,
				       le32_to_cpu(tsqe->word_1) & 0x1fff);
#endif
				break;
			}
			vc = card->vcs[conn & 0x1fff];
			if (!vc) {
				printk("%s: could not find VC from conn %d\n",
				       card->name, conn & 0x1fff);
				break;
			}
			printk("%s: Connection %d IDLE.\n",
			       card->name, vc->index);
			set_bit(VCF_IDLE, &vc->flags);
			break;
		case SAR_TSQE_TYPE_TSR:
			conn = le32_to_cpu(tsqe->word_1);
			vc = card->vcs[conn & 0x1fff];
			if (!vc) {
				printk("%s: no VC at index %d\n",
				       card->name,
				       le32_to_cpu(tsqe->word_1) & 0x1fff);
				break;
			}
			break;
		case SAR_TSQE_TYPE_TBD_COMP:
			conn = le32_to_cpu(tsqe->word_1);
			vpi = (conn >> SAR_TBD_VPI_SHIFT) & 0x00ff;
			vci = (conn >> SAR_TBD_VCI_SHIFT) & 0xffff;
			if (vpi >= (1 << card->vpibits) ||
			    vci >= (1 << card->vcibits)) {
				printk("%s: TBD complete: "
				       "out of range VPI.VCI %u.%u\n",
				       card->name, vpi, vci);
				break;
			}
			vc = card->vcs[VPCI2VC(card, vpi, vci)];
			if (!vc) {
				printk("%s: TBD complete: "
				       "no VC at VPI.VCI %u.%u\n",
				       card->name, vpi, vci);
				break;
			}
			drain_scq(card, vc);
			break;
		}
		tsqe->word_2 = cpu_to_le32(SAR_TSQE_INVALID);
		card->tsq.next = tsqe;
		if (card->tsq.next == card->tsq.last)
			tsqe = card->tsq.base;
		else
			tsqe = card->tsq.next + 1;
		TXPRINTK("tsqe: %p: base %p, next %p, last %p\n", tsqe,
			 card->tsq.base, card->tsq.next, card->tsq.last);
		stat = le32_to_cpu(tsqe->word_2);
	} while (!(stat & SAR_TSQE_INVALID));
	writel((unsigned int)card->tsq.next - (unsigned int)card->tsq.base,
	       SAR_REG_TSQH);
	XPRINTK("idt77252_tx-after writel%d: TSQ head = 0x%x, tail = 0x%x, next = 0x%p.\n",
		card->index, readl(SAR_REG_TSQH),
		readl(SAR_REG_TSQT), card->tsq.next);
}
