int bench_sched_messaging(int argc, const char **argv)
{
	unsigned int i;
	struct timeval start, stop, diff;
	unsigned int num_fds = 20;
	int readyfds[2], wakefds[2];
	char dummy;
	struct sender_context *pos, *n;
	argc = parse_options(argc, argv, options,
			     bench_sched_message_usage, 0);
	worker_tab = malloc(num_fds * 2 * num_groups * sizeof(union messaging_worker));
	if (!worker_tab)
	fdpair(readyfds);
	fdpair(wakefds);
	if (!thread_mode) {
		signal(SIGINT, sig_handler);
		signal(SIGTERM, sig_handler);
	}
	for (i = 0; i < num_groups; i++)
		total_children += group(worker_tab + total_children, num_fds,
					readyfds[1], wakefds[0]);
	for (i = 0; i < total_children; i++)
		if (read(readyfds[0], &dummy, 1) != 1)
			err(EXIT_FAILURE, "Reading for readyfds");
	gettimeofday(&start, NULL);
	if (write(wakefds[1], &dummy, 1) != 1)
		err(EXIT_FAILURE, "Writing to start them");
	for (i = 0; i < total_children; i++)
		reap_worker(worker_tab + i);
	gettimeofday(&stop, NULL);
	timersub(&stop, &start, &diff);
	switch (bench_format) {
	case BENCH_FORMAT_DEFAULT:
		printf("# %d sender and receiver %s per group\n",
		       num_fds, thread_mode ? "threads" : "processes");
		printf("# %d groups == %d %s run\n\n",
		       num_groups, num_groups * 2 * num_fds,
		       thread_mode ? "threads" : "processes");
		printf(" %14s: %lu.%03lu [sec]\n", "Total time",
		       (unsigned int) diff.tv_sec,
		       (unsigned int) (diff.tv_usec / USEC_PER_MSEC));
		break;
	case BENCH_FORMAT_SIMPLE:
		printf("%lu.%03lu\n", (unsigned int) diff.tv_sec,
		       (unsigned int) (diff.tv_usec / USEC_PER_MSEC));
		break;
	default:
		fprintf(stderr, "Unknown format:%d\n", bench_format);
		exit(1);
		break;
	}
	free(worker_tab);
	list_for_each_entry_safe(pos, n, &sender_contexts, list) {
		list_del_init(&pos->list);
		free(pos);
	}
	list_for_each_entry_safe(pos, n, &receiver_contexts, list) {
		list_del_init(&pos->list);
		free(pos);
	}
	return 0;
}
