static int decrypt_opcua(
        unsigned int channel_id, unsigned int token_id,
        const guint8 *cipher, guint cipher_len,
        guint8 *plaintext, guint plaintext_len,
        guint8 *padding_len, guint8 *sig_len, bool from_server)
{
    struct ua_keyset *keyset;
    unsigned int int id;
	int keylen, ivlen;
    unsigned char *keydata, *ivdata;
    int cipher_mode;
    gcry_error_t res;
    int ret = 0;
    id = ua_keyset_id(channel_id, token_id);
    keyset = ua_keysets_lookup(id);
    if (keyset == NULL) {
        debugprintf("no keyset found for channel_id=%u and token_id=%u\n", channel_id, token_id);
        return -1;
    }
    debugprintf("found keyset for channel_id=%u and token_id=%u\n", channel_id, token_id);
    if (from_server) {
        ivlen = sizeof(keyset->server_iv);
        ivdata = keyset->server_iv;
        keylen = keyset->server_key_len;
        keydata = keyset->server_key;
        *sig_len = keyset->server_sig_len;
    } else {
        ivlen = sizeof(keyset->client_iv);
        ivdata = keyset->client_iv;
        keylen = keyset->client_key_len;
        keydata = keyset->client_key;
        *sig_len = keyset->client_sig_len;
    }
    switch (keylen) {
    case 16:
        debugprintf("using AES-128-CBC\n");
        cipher_mode = GCRY_CIPHER_AES128;
        break;
    case 32:
        debugprintf("using AES-256-CBC\n");
        cipher_mode = GCRY_CIPHER_AES256;
        break;
    default:
        debugprintf("invalid AES key length: %u bytes\n", keylen);
        return -1;
    }
    debugprintf("cipher_len=%u\n", cipher_len);
    if (cipher_len % 16 != 0) {
        debugprintf("warning: cipher_len not a multiple of 16.\n");
    }
    gcry_cipher_hd_t handle;
    gcry_cipher_open(&handle, cipher_mode, GCRY_CIPHER_MODE_CBC, GCRY_CIPHER_CBC_CTS);
    gcry_cipher_setkey(handle, keydata, keylen);
    gcry_cipher_setiv(handle, ivdata, ivlen);
    res = gcry_cipher_decrypt(handle, plaintext, plaintext_len, cipher, cipher_len);
    if (res == 0) {
        debugprintf("decryption succeeded.\n");
    } else {
        debugprintf("decryption failed.\n");
        ret = -1;
    }
    gcry_cipher_close(handle);
    if (ret != 0) {
        return ret;
    }
    ret = verify_padding(&plaintext[plaintext_len - *sig_len - 1]);
    if (ret < 0) {
        debugprintf("padding is invalid.\n");
    }
    *padding_len = plaintext[plaintext_len - *sig_len - 1];
    debugprintf("sig_len=%u\n", *sig_len);
    debugprintf("pad_len=%u\n", *padding_len);
    return 0;
}
