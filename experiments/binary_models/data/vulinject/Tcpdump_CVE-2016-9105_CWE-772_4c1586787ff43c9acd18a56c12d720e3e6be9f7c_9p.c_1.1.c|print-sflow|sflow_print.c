sflow_print(netdissect_options *ndo,
            const u_char *pptr, u_int len)
{
    const struct sflow_datagram_t *sflow_datagram;
    const struct sflow_v6_datagram_t *sflow_v6_datagram;
    const struct sflow_sample_header *sflow_sample;
    const u_char *tptr;
    u_int tlen;
    unsigned int sflow_sample_type, sflow_sample_len;
    unsigned int nsamples;
    unsigned int ip_version;
    ndo->ndo_protocol = "sflow";
    tptr = pptr;
    tlen = len;
    sflow_datagram = (const struct sflow_datagram_t *)pptr;
    sflow_v6_datagram = (const struct sflow_v6_datagram_t *)pptr;
    ip_version = GET_BE_U_4(sflow_datagram->ip_version);
    if ((len < sizeof(struct sflow_datagram_t) && (ip_version == 1)) ||
        (len < sizeof(struct sflow_v6_datagram_t) && (ip_version == 2))) {
        ND_PRINT("sFlowv%u", GET_BE_U_4(sflow_datagram->version));
        ND_PRINT(" [length %u < %zu]", len, sizeof(struct sflow_datagram_t));
        nd_print_invalid(ndo);
        return;
    }
    ND_TCHECK_SIZE(sflow_datagram);
    if (GET_BE_U_4(sflow_datagram->version) != 5) {
        ND_PRINT("sFlow version %u packet not supported",
               GET_BE_U_4(sflow_datagram->version));
        return;
    }
    if (ndo->ndo_vflag < 1) {
        ND_PRINT("sFlowv%u, %s agent %s, agent-id %u, length %u",
               GET_BE_U_4(sflow_datagram->version),
               ip_version == 1 ? "IPv4" : "IPv6",
               ip_version == 1 ? GET_IPADDR_STRING(sflow_datagram->agent) :
                                 GET_IP6ADDR_STRING( sflow_v6_datagram->agent),
               ip_version == 1 ? GET_BE_U_4(sflow_datagram->agent_id) :
                                 GET_BE_U_4(sflow_v6_datagram->agent_id),
               len);
        return;
    }
    if (ip_version == 1) {
        nsamples = GET_BE_U_4(sflow_datagram->samples);
        ND_PRINT("sFlowv%u, %s agent %s, agent-id %u, seqnum %u, uptime %u, samples %u, length %u",
               GET_BE_U_4(sflow_datagram->version),
               "IPv4",
               GET_IPADDR_STRING(sflow_datagram->agent),
               GET_BE_U_4(sflow_datagram->agent_id),
               GET_BE_U_4(sflow_datagram->seqnum),
               GET_BE_U_4(sflow_datagram->uptime),
               nsamples,
               len);
        ND_ICHECK_ZU(tlen, <, sizeof(struct sflow_datagram_t));
        tptr += sizeof(struct sflow_datagram_t);
        tlen -= sizeof(struct sflow_datagram_t);
    } else {
        nsamples = GET_BE_U_4(sflow_v6_datagram->samples);
        ND_PRINT("sFlowv%u, %s agent %s, agent-id %u, seqnum %u, uptime %u, samples %u, length %u",
               GET_BE_U_4(sflow_v6_datagram->version),
               "IPv6",
               GET_IP6ADDR_STRING(sflow_v6_datagram->agent),
               GET_BE_U_4(sflow_v6_datagram->agent_id),
               GET_BE_U_4(sflow_v6_datagram->seqnum),
               GET_BE_U_4(sflow_v6_datagram->uptime),
               nsamples,
               len);
        ND_ICHECK_ZU(tlen, <, sizeof(struct sflow_v6_datagram_t));
        tptr += sizeof(struct sflow_v6_datagram_t);
        tlen -= sizeof(struct sflow_v6_datagram_t);
    }
    while (nsamples != 0 && tlen != 0) {
        sflow_sample = (const struct sflow_sample_header *)tptr;
        sflow_sample_type = (GET_BE_U_4(sflow_sample->format)&0x0FFF);
        sflow_sample_len = GET_BE_U_4(sflow_sample->len);
	if (tlen < sizeof(struct sflow_sample_header))
	    goto invalid;
        tptr += sizeof(struct sflow_sample_header);
        tlen -= sizeof(struct sflow_sample_header);
        ND_PRINT("\n\t%s (%u), length %u,",
               tok2str(sflow_format_values, "Unknown", sflow_sample_type),
               sflow_sample_type,
               sflow_sample_len);
        if (sflow_sample_type == 0 || sflow_sample_len == 0) {
            return;
        }
	if (tlen < sflow_sample_len)
	    goto invalid;
	switch(sflow_sample_type) {
        case SFLOW_FLOW_SAMPLE:
	    if (sflow_print_flow_sample(ndo, tptr, tlen))
		goto invalid;
            break;
        case SFLOW_COUNTER_SAMPLE:
	    if (sflow_print_counter_sample(ndo, tptr,tlen))
		goto invalid;
            break;
        case SFLOW_EXPANDED_FLOW_SAMPLE:
	    if (sflow_print_expanded_flow_sample(ndo, tptr, tlen))
		goto invalid;
	    break;
        case SFLOW_EXPANDED_COUNTER_SAMPLE:
	    if (sflow_print_expanded_counter_sample(ndo, tptr,tlen))
		goto invalid;
	    break;
        default:
            if (ndo->ndo_vflag <= 1)
                print_unknown_data(ndo, tptr, "\n\t    ", sflow_sample_len);
            break;
        }
        tptr += sflow_sample_len;
        tlen -= sflow_sample_len;
        nsamples--;
    }
    return;
invalid:
    nd_print_invalid(ndo);
    ND_TCHECK_LEN(tptr, tlen);
}
