static void offb_init_fb(struct platform_device *parent, const char *name,
			 int width, int height, int depth,
			 int pitch, unsigned int address,
			 int foreign_endian, struct device_node *dp)
{
	unsigned int res_size = pitch * height;
	unsigned int res_start = address;
	struct fb_fix_screeninfo *fix;
	struct fb_var_screeninfo *var;
	struct fb_info *info;
	struct offb_par *par;
	if (!request_mem_region(res_start, res_size, "offb"))
		return;
	printk(KERN_INFO
	       "Using unsupported %dx%d %s at %lx, depth=%d, pitch=%d\n",
	       width, height, name, address, depth, pitch);
	if (depth != 8 && depth != 15 && depth != 16 && depth != 32) {
		printk(KERN_ERR "%pOF: can't use depth = %d\n", dp, depth);
		release_mem_region(res_start, res_size);
		return;
	}
	info = framebuffer_alloc(sizeof(*par), &parent->dev);
	if (!info) {
		release_mem_region(res_start, res_size);
		return;
	}
	platform_set_drvdata(parent, info);
	par = info->par;
	fix = &info->fix;
	var = &info->var;
	if (name)
		snprintf(fix->id, sizeof(fix->id), "OFfb %s", name);
	else
		snprintf(fix->id, sizeof(fix->id), "OFfb %pOFn", dp);
	var->xres = var->xres_virtual = width;
	var->yres = var->yres_virtual = height;
	fix->line_length = pitch;
	fix->smem_start = address;
	fix->smem_len = pitch * height;
	fix->type = FB_TYPE_PACKED_PIXELS;
	fix->type_aux = 0;
	par->cmap_type = cmap_unknown;
	if (depth == 8)
		offb_init_palette_hacks(info, dp, address);
	else
		fix->visual = FB_VISUAL_TRUECOLOR;
	var->xoffset = var->yoffset = 0;
	switch (depth) {
	case 8:
		var->bits_per_pixel = 8;
		var->red.offset = 0;
		var->red.length = 8;
		var->green.offset = 0;
		var->green.length = 8;
		var->blue.offset = 0;
		var->blue.length = 8;
		var->transp.offset = 0;
		var->transp.length = 0;
		break;
	case 15:		
		var->bits_per_pixel = 16;
		var->red.offset = 10;
		var->red.length = 5;
		var->green.offset = 5;
		var->green.length = 5;
		var->blue.offset = 0;
		var->blue.length = 5;
		var->transp.offset = 0;
		var->transp.length = 0;
		break;
	case 16:		
		var->bits_per_pixel = 16;
		var->red.offset = 11;
		var->red.length = 5;
		var->green.offset = 5;
		var->green.length = 6;
		var->blue.offset = 0;
		var->blue.length = 5;
		var->transp.offset = 0;
		var->transp.length = 0;
		break;
	case 32:		
		var->bits_per_pixel = 32;
		var->red.offset = 16;
		var->red.length = 8;
		var->green.offset = 8;
		var->green.length = 8;
		var->blue.offset = 0;
		var->blue.length = 8;
		var->transp.offset = 24;
		var->transp.length = 8;
		break;
	}
	var->red.msb_right = var->green.msb_right = var->blue.msb_right =
	    var->transp.msb_right = 0;
	var->grayscale = 0;
	var->nonstd = 0;
	var->activate = 0;
	var->height = var->width = -1;
	var->pixclock = 10000;
	var->left_margin = var->right_margin = 16;
	var->upper_margin = var->lower_margin = 16;
	var->hsync_len = var->vsync_len = 8;
	var->sync = 0;
	var->vmode = FB_VMODE_NONINTERLACED;
	par->base = address;
	par->size = fix->smem_len;
	info->fbops = &offb_ops;
	info->screen_base = ioremap(address, fix->smem_len);
	info->pseudo_palette = par->pseudo_palette;
	info->flags = foreign_endian;
	fb_alloc_cmap(&info->cmap, 256, 0);
	if (devm_aperture_acquire_for_platform_device(parent, par->base, par->size) < 0)
		goto out_err;
	if (register_framebuffer(info) < 0)
		goto out_err;
	fb_info(info, "Open Firmware frame buffer device on %pOF\n", dp);
	return;
out_err:
	iounmap(info->screen_base);
	iounmap(par->cmap_adr);
	par->cmap_adr = NULL;
	framebuffer_release(info);
	release_mem_region(res_start, res_size);
}
