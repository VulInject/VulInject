start_watch_dir_change(SeafWTMonitorPriv *priv, HANDLE dir_handle)
{
    if (!dir_handle)
        return FALSE;
    BOOL first_alloc = FALSE;
    DirWatchAux *aux = g_hash_table_lookup (priv->buf_hash, dir_handle);
    if (!aux) {
        first_alloc = TRUE;
        aux = g_new0(DirWatchAux, 1);
    }
    BOOL ret;
    DWORD code;
    RepoWatchInfo *info;
retry:
    ret = ReadDirectoryChangesW
        (dir_handle,            
         aux->buf,              
         DIR_WATCH_BUFSIZE,     
         TRUE,                  
         DIR_WATCH_MASK,        
         NULL,                  
         &aux->ol,              
         NULL);                 
    if (!ret) {
        code = GetLastError();
        seaf_warning("Failed to ReadDirectoryChangesW, "
                     "error code %lu", code);
        if (first_alloc)
            g_free(aux);
        else if (code == ERROR_NOTIFY_ENUM_DIR) {
            info = g_hash_table_lookup (priv->info_hash, dir_handle);
            add_event_to_queue (info->status, WT_EVENT_OVERFLOW, NULL, NULL);
            goto retry;
        }
    } else {
        if (first_alloc)
            g_hash_table_insert (priv->buf_hash,
                                 (gpointer)dir_handle, (gpointer)aux);
    }
    return ret;
}
