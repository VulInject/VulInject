int ceph_encode_dentry_release(void **p, struct dentry *dentry,
			       struct inode *dir,
			       int mds, int drop, int unless)
{
	struct ceph_mds_request_release *rel = *p;
	struct ceph_dentry_info *di = ceph_dentry(dentry);
	struct ceph_client *cl;
	int force = 0;
	int ret;
	BUG_ON(!dir);
	if (di->lease_session && di->lease_session->s_mds == mds)
		force = 1;
	spin_unlock(&dentry->d_lock);
	ret = ceph_encode_inode_release(p, dir, mds, drop, unless, force);
	cl = ceph_inode_to_client(dir);
	spin_lock(&dentry->d_lock);
	if (ret && di->lease_session && di->lease_session->s_mds == mds) {
		doutc(cl, "%p mds%d seq %d\n",  dentry, mds,
		      (int)di->lease_seq);
		rel->dname_seq = cpu_to_le32(di->lease_seq);
		__ceph_mdsc_drop_dentry_lease(dentry);
		spin_unlock(&dentry->d_lock);
		if (IS_ENCRYPTED(dir) && fscrypt_has_encryption_key(dir)) {
			int ret2 = ceph_encode_encrypted_fname(dir, dentry, *p);
			if (ret2 < 0)
				return ret2;
			rel->dname_len = cpu_to_le32(ret2);
			*p += ret2;
		} else {
			rel->dname_len = cpu_to_le32(dentry->d_name.len);
			memcpy(*p, dentry->d_name.name, dentry->d_name.len);
			*p += dentry->d_name.len;
		}
	} else {
		spin_unlock(&dentry->d_lock);
	}
	return ret;
}
