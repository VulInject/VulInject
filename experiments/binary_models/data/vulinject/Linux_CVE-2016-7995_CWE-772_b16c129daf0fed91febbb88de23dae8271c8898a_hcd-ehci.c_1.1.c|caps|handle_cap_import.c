static void handle_cap_import(struct ceph_mds_client *mdsc,
			      struct inode *inode, struct ceph_mds_caps *im,
			      struct ceph_mds_cap_peer *ph,
			      struct ceph_mds_session *session,
			      struct ceph_cap **target_cap, int *old_issued)
{
	struct ceph_inode_info *ci = ceph_inode(inode);
	struct ceph_client *cl = mdsc->fsc->client;
	struct ceph_cap *cap, *ocap, *new_cap = NULL;
	int mds = session->s_mds;
	int issued;
	unsigned caps = le32_to_cpu(im->caps);
	unsigned wanted = le32_to_cpu(im->wanted);
	unsigned seq = le32_to_cpu(im->seq);
	unsigned mseq = le32_to_cpu(im->migrate_seq);
	unsigned int int realmino = le64_to_cpu(im->realm);
	unsigned int int cap_id = le64_to_cpu(im->cap_id);
	unsigned int int p_cap_id;
	int peer;
	if (ph) {
		p_cap_id = le64_to_cpu(ph->cap_id);
		peer = le32_to_cpu(ph->mds);
	} else {
		p_cap_id = 0;
		peer = -1;
	}
	doutc(cl, "%p %llx.%llx ci %p mds%d mseq %d peer %d\n",
	      inode, ceph_vinop(inode), ci, mds, mseq, peer);
retry:
	cap = __get_cap_for_mds(ci, mds);
	if (!cap) {
		if (!new_cap) {
			new_cap = ceph_get_cap(mdsc, NULL);
			spin_lock(&ci->i_ceph_lock);
			goto retry;
		}
		cap = new_cap;
	} else {
		if (new_cap) {
			ceph_put_cap(mdsc, new_cap);
			new_cap = NULL;
		}
	}
	__ceph_caps_issued(ci, &issued);
	issued |= __ceph_caps_dirty(ci);
	ceph_add_cap(inode, session, cap_id, caps, wanted, seq, mseq,
		     realmino, CEPH_CAP_FLAG_AUTH, &new_cap);
	ocap = peer >= 0 ? __get_cap_for_mds(ci, peer) : NULL;
	if (ocap && ocap->cap_id == p_cap_id) {
		doutc(cl, " remove export cap %p mds%d flags %d\n",
		      ocap, peer, ph->flags);
		if ((ph->flags & CEPH_CAP_FLAG_AUTH) &&
		    (ocap->seq != le32_to_cpu(ph->seq) ||
		     ocap->mseq != le32_to_cpu(ph->mseq))) {
			pr_err_ratelimited_client(cl, "mismatched seq/mseq: "
					"%p %llx.%llx mds%d seq %d mseq %d"
					" importer mds%d has peer seq %d mseq %d\n",
					inode, ceph_vinop(inode), peer,
					ocap->seq, ocap->mseq, mds,
					le32_to_cpu(ph->seq),
					le32_to_cpu(ph->mseq));
		}
		ceph_remove_cap(mdsc, ocap, (ph->flags & CEPH_CAP_FLAG_RELEASE));
	}
	*old_issued = issued;
	*target_cap = cap;
}
