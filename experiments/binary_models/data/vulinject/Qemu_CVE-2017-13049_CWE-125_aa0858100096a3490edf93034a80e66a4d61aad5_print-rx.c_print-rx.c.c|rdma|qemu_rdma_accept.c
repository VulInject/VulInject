static int qemu_rdma_accept(RDMAContext *rdma)
{
    Error *err = NULL;
    RDMACapabilities cap;
    struct rdma_conn_param conn_param = {
                                            .responder_resources = 2,
                                            .private_data = &cap,
                                            .private_data_len = sizeof(cap),
                                         };
    RDMAContext *rdma_return_path = NULL;
    g_autoptr(InetSocketAddress) isock = g_new0(InetSocketAddress, 1);
    struct rdma_cm_event *cm_event;
    struct ibv_context *verbs;
    int ret;
    ret = rdma_get_cm_event(rdma->channel, &cm_event);
    if (ret < 0) {
        goto err_rdma_dest_wait;
    }
    if (cm_event->event != RDMA_CM_EVENT_CONNECT_REQUEST) {
        goto err_rdma_dest_wait;
    }
    isock->host = rdma->host;
    isock->port = g_strdup_printf("%d", rdma->port);
    /*
     * initialize the RDMAContext for return path for postcopy after first
     * connection request reached.
     */
    if ((migrate_postcopy() || migrate_return_path())
        && !rdma->is_return_path) {
        rdma_return_path = qemu_rdma_data_init(isock, NULL);
        if (rdma_return_path == NULL) {
            rdma_ack_cm_event(cm_event);
            goto err_rdma_dest_wait;
        }
        qemu_rdma_return_path_dest_init(rdma_return_path, rdma);
    }
    memcpy(&cap, cm_event->param.conn.private_data, sizeof(cap));
    network_to_caps(&cap);
    if (cap.version < 1 || cap.version > RDMA_CONTROL_VERSION_CURRENT) {
        error_report("Unknown source RDMA version: %d, bailing...",
                     cap.version);
        rdma_ack_cm_event(cm_event);
        goto err_rdma_dest_wait;
    }
    /*
     * Respond with only the capabilities this version of QEMU knows about.
     */
    cap.flags &= known_capabilities;
    /*
     * Enable the ones that we do know about.
     * Add other checks here as new ones are introduced.
     */
    if (cap.flags & RDMA_CAPABILITY_PIN_ALL) {
        rdma->pin_all = true;
    }
    rdma->cm_id = cm_event->id;
    verbs = cm_event->id->verbs;
    rdma_ack_cm_event(cm_event);
    trace_qemu_rdma_accept_pin_state(rdma->pin_all);
    caps_to_network(&cap);
    trace_qemu_rdma_accept_pin_verbsc(verbs);
    if (!rdma->verbs) {
        rdma->verbs = verbs;
    } else if (rdma->verbs != verbs) {
        error_report("ibv context not matching %p, %p!", rdma->verbs,
                     verbs);
        goto err_rdma_dest_wait;
    }
    qemu_rdma_dump_id("dest_init", verbs);
    ret = qemu_rdma_alloc_pd_cq(rdma, &err);
    if (ret < 0) {
        error_report_err(err);
        goto err_rdma_dest_wait;
    }
    ret = qemu_rdma_alloc_qp(rdma);
    if (ret < 0) {
        error_report("rdma migration: error allocating qp!");
        goto err_rdma_dest_wait;
    }
    qemu_rdma_init_ram_blocks(rdma);
    for (int i = 0; i < RDMA_WRID_MAX; i++) {
        ret = qemu_rdma_reg_control(rdma, i);
        if (ret < 0) {
            error_report("rdma: error registering %d control", i);
            goto err_rdma_dest_wait;
        }
    }
    /* Accept the second connection request for return path */
    if ((migrate_postcopy() || migrate_return_path())
        && !rdma->is_return_path) {
        qemu_set_fd_handler(rdma->channel->fd, rdma_accept_incoming_migration,
                            NULL,
                            (void *)(intptr_t)rdma->return_path);
    } else {
        qemu_set_fd_handler(rdma->channel->fd, rdma_cm_poll_handler,
                            NULL, rdma);
    }
    ret = rdma_accept(rdma->cm_id, &conn_param);
    if (ret < 0) {
        error_report("rdma_accept failed");
        goto err_rdma_dest_wait;
    }
    ret = rdma_get_cm_event(rdma->channel, &cm_event);
    if (ret < 0) {
        error_report("rdma_accept get_cm_event failed");
        goto err_rdma_dest_wait;
    }
    if (cm_event->event != RDMA_CM_EVENT_ESTABLISHED) {
        error_report("rdma_accept not event established");
        rdma_ack_cm_event(cm_event);
        goto err_rdma_dest_wait;
    }
    rdma_ack_cm_event(cm_event);
    rdma->connected = true;
    ret = qemu_rdma_post_recv_control(rdma, RDMA_WRID_READY, &err);
    if (ret < 0) {
        error_report_err(err);
        goto err_rdma_dest_wait;
    }
    qemu_rdma_dump_gid("dest_connect", rdma->cm_id);
    return 0;
err_rdma_dest_wait:
    rdma->errored = true;
    qemu_rdma_cleanup(rdma);
    g_free(rdma_return_path);
    return -1;
}
