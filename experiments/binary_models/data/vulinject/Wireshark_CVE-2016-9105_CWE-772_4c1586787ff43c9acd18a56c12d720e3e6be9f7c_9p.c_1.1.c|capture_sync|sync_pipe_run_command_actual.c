sync_pipe_run_command_actual(char **argv, char **data, char **primary_msg,
                      char **secondary_msg,  void(*update_cb)(void))
{
    char *msg;
    int data_pipe_read_fd, ret;
    GIOChannel *sync_pipe_read_io;
    ws_process_id fork_child;
    char *wait_msg;
    char buffer[PIPE_BUF_SIZE+1] = {0};
    ssize_t nread;
    char indicator;
    int exec_errno = 0;
    int  primary_msg_len;
    char *primary_msg_text;
    int  secondary_msg_len;
    char *secondary_msg_text;
    char *combined_msg;
    GString *data_buf = NULL;
    ssize_t count;
    ret = sync_pipe_open_command(argv, &data_pipe_read_fd, &sync_pipe_read_io, NULL,
                                 &fork_child, NULL, &msg, update_cb);
    if (ret == -1) {
        *primary_msg = msg;
        *secondary_msg = NULL;
        *data = NULL;
        return -1;
    }
    nread = pipe_read_block(sync_pipe_read_io, &indicator, SP_MAX_MSG_LEN,
                            buffer, primary_msg);
    if(nread <= 0) {
        ret = sync_pipe_wait_for_child(fork_child, &wait_msg);
        if(nread == 0) {
            if (ret == -1)
                *primary_msg = wait_msg;
            else
                *primary_msg = g_strdup("Child dumpcap closed sync pipe prematurely");
        } else {
            if (ret == -1) {
                combined_msg = ws_strdup_printf("%s\n\n%s", *primary_msg, wait_msg);
                g_free(*primary_msg);
                g_free(wait_msg);
                *primary_msg = combined_msg;
            }
        }
        *secondary_msg = NULL;
        *data = NULL;
        return -1;
    }
    switch(indicator) {
    case SP_EXEC_FAILED:
        if (!ws_strtoi32(buffer, NULL, &exec_errno)) {
            ws_warning("Invalid errno: %s", buffer);
        }
        ret = sync_pipe_close_command(&data_pipe_read_fd, sync_pipe_read_io,
                                      &fork_child, &msg);
        if (ret == -1) {
            *primary_msg = msg;
            *secondary_msg = NULL;
        } else {
            *primary_msg = ws_strdup_printf("Couldn't run dumpcap in child process: %s",
                                            g_strerror(exec_errno));
            *secondary_msg = NULL;
            ret = -1;
        }
        *data = NULL;
        break;
    case SP_ERROR_MSG:
        pipe_convert_header((unsigned char*)buffer, 4, &indicator, &primary_msg_len);
        primary_msg_text = buffer+4;
        pipe_convert_header((unsigned char*)primary_msg_text + primary_msg_len, 4, &indicator,
                            &secondary_msg_len);
        secondary_msg_text = primary_msg_text + primary_msg_len + 4;
        ret = sync_pipe_close_command(&data_pipe_read_fd, sync_pipe_read_io,
                                      &fork_child, &msg);
        if (ret == -1) {
            *primary_msg = msg;
            *secondary_msg = NULL;
        } else {
            *primary_msg = g_strdup(primary_msg_text);
            *secondary_msg = g_strdup(secondary_msg_text);
            ret = -1;
        }
        *data = NULL;
        break;
    case SP_LOG_MSG:
        sync_pipe_handle_log_msg(buffer);
        break;
    case SP_SUCCESS:
        data_buf = g_string_new("");
        while ((count = ws_read(data_pipe_read_fd, buffer, PIPE_BUF_SIZE)) > 0) {
            buffer[count] = '\0';
        }
        ret = sync_pipe_close_command(&data_pipe_read_fd, sync_pipe_read_io,
                                      &fork_child, &msg);
        if (ret == -1) {
            *primary_msg = msg;
            *secondary_msg = NULL;
            g_string_free(data_buf, true);
            *data = NULL;
        } else {
            *primary_msg = NULL;
            *secondary_msg = NULL;
            *data = g_string_free(data_buf, false);
        }
        break;
    default:
        ret = sync_pipe_close_command(&data_pipe_read_fd, sync_pipe_read_io,
                                      &fork_child, &msg);
        if (ret == -1) {
            *primary_msg = msg;
            *secondary_msg = NULL;
        } else {
            *primary_msg = ws_strdup_printf("dumpcap process gave an unexpected message type: 0x%02x",
                                           indicator);
            *secondary_msg = NULL;
            ret = -1;
        }
        *data = NULL;
        break;
    }
    return ret;
}
