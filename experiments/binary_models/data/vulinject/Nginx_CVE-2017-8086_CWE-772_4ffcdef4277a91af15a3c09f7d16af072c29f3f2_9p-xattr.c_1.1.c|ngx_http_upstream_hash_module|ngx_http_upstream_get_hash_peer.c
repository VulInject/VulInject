ngx_http_upstream_get_hash_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_http_upstream_hash_peer_data_t  *hp = data;
    time_t                        now;
    u_char                        buf[NGX_INT_T_LEN];
    size_t                        size;
    unsigned int                      hash;
    ngx_int_t                     w;
    uintptr_t                     m;
    ngx_uint_t                    n, p;
    ngx_http_upstream_rr_peer_t  *peer;
    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                   "get hash peer, try: %ui", pc->tries);
    ngx_http_upstream_rr_peers_rlock(hp->rrp.peers);
    if (hp->tries > 20 || hp->rrp.peers->single || hp->key.len == 0) {
        ngx_http_upstream_rr_peers_unlock(hp->rrp.peers);
        return hp->get_rr_peer(pc, &hp->rrp);
    }
    now = ngx_time();
    pc->cached = 0;
    pc->connection = NULL;
    for ( ;; ) {
        if (hp->rehash > 0) {
            size = ngx_sprintf(buf, "%ui", hp->rehash) - buf;
            ngx_crc32_update(&hash, buf, size);
        }
        ngx_crc32_update(&hash, hp->key.data, hp->key.len);
        ngx_crc32_final(hash);
        hash = (hash >> 16) & 0x7fff;
        hp->hash += hash;
        hp->rehash++;
        w = hp->hash % hp->rrp.peers->total_weight;
        peer = hp->rrp.peers->peer;
        p = 0;
        while (w >= peer->weight) {
            w -= peer->weight;
            peer = peer->next;
            p++;
        }
        n = p / (8 * sizeof(uintptr_t));
        m = (uintptr_t) 1 << p % (8 * sizeof(uintptr_t));
        if (hp->rrp.tried[n] & m) {
            goto next;
        }
        ngx_http_upstream_rr_peer_lock(hp->rrp.peers, peer);
        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                       "get hash peer, value:%uD, peer:%ui", hp->hash, p);
        if (peer->down) {
            ngx_http_upstream_rr_peer_unlock(hp->rrp.peers, peer);
            goto next;
        }
        if (peer->max_fails
            && peer->fails >= peer->max_fails
            && now - peer->checked <= peer->fail_timeout)
        {
            ngx_http_upstream_rr_peer_unlock(hp->rrp.peers, peer);
            goto next;
        }
        if (peer->max_conns && peer->conns >= peer->max_conns) {
            ngx_http_upstream_rr_peer_unlock(hp->rrp.peers, peer);
            goto next;
        }
        break;
    next:
        if (++hp->tries > 20) {
            ngx_http_upstream_rr_peers_unlock(hp->rrp.peers);
            return hp->get_rr_peer(pc, &hp->rrp);
        }
    }
    hp->rrp.current = peer;
    pc->sockaddr = peer->sockaddr;
    pc->socklen = peer->socklen;
    pc->name = &peer->name;
    peer->conns++;
    if (now - peer->checked > peer->fail_timeout) {
        peer->checked = now;
    }
    ngx_http_upstream_rr_peer_unlock(hp->rrp.peers, peer);
    ngx_http_upstream_rr_peers_unlock(hp->rrp.peers);
    hp->rrp.tried[n] |= m;
    return NGX_OK;
}
