static int try_get_cap_refs(struct inode *inode, int need, int want,
			    loff_t endoff, int flags, int *got)
{
	struct ceph_inode_info *ci = ceph_inode(inode);
	struct ceph_mds_client *mdsc = ceph_inode_to_fs_client(inode)->mdsc;
	struct ceph_client *cl = ceph_inode_to_client(inode);
	int ret = 0;
	int have, implemented;
	bool snap_rwsem_locked = false;
	doutc(cl, "%p %llx.%llx need %s want %s\n", inode,
	      ceph_vinop(inode), ceph_cap_string(need),
	      ceph_cap_string(want));
again:
	if ((flags & CHECK_FILELOCK) &&
	    (ci->i_ceph_flags & CEPH_I_ERROR_FILELOCK)) {
		doutc(cl, "%p %llx.%llx error filelock\n", inode,
		      ceph_vinop(inode));
		ret = -EIO;
		goto out_unlock;
	}
	while (ci->i_truncate_pending) {
		spin_unlock(&ci->i_ceph_lock);
		if (snap_rwsem_locked) {
			up_read(&mdsc->snap_rwsem);
			snap_rwsem_locked = false;
		}
		__ceph_do_pending_vmtruncate(inode);
		spin_lock(&ci->i_ceph_lock);
	}
	have = __ceph_caps_issued(ci, &implemented);
	if (have & need & CEPH_CAP_FILE_WR) {
		if (endoff >= 0 && endoff > (loff_t)ci->i_max_size) {
			doutc(cl, "%p %llx.%llx endoff %llu > maxsize %llu\n",
			      inode, ceph_vinop(inode), endoff, ci->i_max_size);
			if (endoff > ci->i_requested_max_size)
				ret = ci->i_auth_cap ? -EFBIG : -EUCLEAN;
			goto out_unlock;
		}
		if (__ceph_have_pending_cap_snap(ci)) {
			doutc(cl, "%p %llx.%llx cap_snap_pending\n", inode,
			      ceph_vinop(inode));
			goto out_unlock;
		}
	}
	if ((have & need) == need) {
		int not = want & ~(have & need);
		int revoking = implemented & ~have;
		int exclude = revoking & not;
		doutc(cl, "%p %llx.%llx have %s but not %s (revoking %s)\n",
		      inode, ceph_vinop(inode), ceph_cap_string(have),
		      ceph_cap_string(not), ceph_cap_string(revoking));
		if (!exclude || !(exclude & CEPH_CAP_FILE_BUFFER)) {
			if (!snap_rwsem_locked &&
			    !ci->i_head_snapc &&
			    (need & CEPH_CAP_FILE_WR)) {
				if (!down_read_trylock(&mdsc->snap_rwsem)) {
					if (flags & NON_BLOCKING) {
						ret = -EAGAIN;
						goto out_unlock;
					}
					spin_unlock(&ci->i_ceph_lock);
					down_read(&mdsc->snap_rwsem);
					snap_rwsem_locked = true;
					goto again;
				}
				snap_rwsem_locked = true;
			}
			if ((have & want) == want)
				*got = need | (want & ~exclude);
			else
				*got = need;
			ceph_take_cap_refs(ci, *got, true);
			ret = 1;
		}
	} else {
		int session_readonly = false;
		int mds_wanted;
		if (ci->i_auth_cap &&
		    (need & (CEPH_CAP_FILE_WR | CEPH_CAP_FILE_EXCL))) {
			struct ceph_mds_session *s = ci->i_auth_cap->session;
			spin_lock(&s->s_cap_lock);
			session_readonly = s->s_readonly;
			spin_unlock(&s->s_cap_lock);
		}
		if (session_readonly) {
			doutc(cl, "%p %llx.%llx need %s but mds%d readonly\n",
			      inode, ceph_vinop(inode), ceph_cap_string(need),
			      ci->i_auth_cap->mds);
			ret = -EROFS;
			goto out_unlock;
		}
		if (ceph_inode_is_shutdown(inode)) {
			doutc(cl, "%p %llx.%llx inode is shutdown\n",
			      inode, ceph_vinop(inode));
			ret = -ESTALE;
			goto out_unlock;
		}
		mds_wanted = __ceph_caps_mds_wanted(ci, false);
		if (need & ~mds_wanted) {
			doutc(cl, "%p %llx.%llx need %s > mds_wanted %s\n",
			      inode, ceph_vinop(inode), ceph_cap_string(need),
			      ceph_cap_string(mds_wanted));
			ret = -EUCLEAN;
			goto out_unlock;
		}
		doutc(cl, "%p %llx.%llx have %s need %s\n", inode,
		      ceph_vinop(inode), ceph_cap_string(have),
		      ceph_cap_string(need));
	}
out_unlock:
	__ceph_touch_fmode(ci, mdsc, flags);
	spin_unlock(&ci->i_ceph_lock);
	if (snap_rwsem_locked)
		up_read(&mdsc->snap_rwsem);
	if (!ret)
		ceph_update_cap_mis(&mdsc->metric);
	else if (ret == 1)
		ceph_update_cap_hit(&mdsc->metric);
	doutc(cl, "%p %llx.%llx ret %d got %s\n", inode,
	      ceph_vinop(inode), ret, ceph_cap_string(*got));
	return ret;
}
