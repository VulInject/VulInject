static void process_tx_bd(eTSEC         *etsec,
                          eTSEC_rxtx_bd *bd)
{
    uint8_t *tmp_buff = NULL;
    hwaddr tbdbth     = (hwaddr)(etsec->regs[TBDBPH].value & 0xF) << 32;
    if (bd->length == 0) {
        /* ERROR */
        return;
    }
    if (etsec->tx_buffer_len == 0) {
        /* It's the first BD */
        etsec->first_bd = *bd;
    }
    /* TODO: if TxBD[TOE/UN] skip the Tx Frame Control Block*/
    /* Load this Data Buffer */
    etsec->tx_buffer = g_realloc(etsec->tx_buffer,
                                    etsec->tx_buffer_len + bd->length);
    tmp_buff = etsec->tx_buffer + etsec->tx_buffer_len;
    cpu_physical_memory_read(bd->bufptr + tbdbth, tmp_buff, bd->length);
    /* Update buffer length */
    etsec->tx_buffer_len += bd->length;
    if (etsec->tx_buffer_len != 0 && (bd->flags & BD_LAST)) {
        if (etsec->regs[MACCFG1].value & MACCFG1_TX_EN) {
            /* MAC Transmit enabled */
            /* Process offload Tx FCB */
            if (etsec->first_bd.flags & BD_TX_TOEUN) {
            }
            if (etsec->first_bd.flags & BD_TX_PADCRC
                || etsec->regs[MACCFG2].value & MACCFG2_PADCRC) {
                /* Padding and CRC (Padding implies CRC) */
                tx_padding_and_crc(etsec, 60);
            } else if (etsec->first_bd.flags & BD_TX_TC
                       || etsec->regs[MACCFG2].value & MACCFG2_CRC_EN) {
                /* Only CRC */
                /* Never add CRC in QEMU */
            }
#if defined(HEX_DUMP)
            qemu_log("eTSEC Send packet size:%d\n", etsec->tx_buffer_len);
            qemu_hexdump(stderr, "", etsec->tx_buffer, etsec->tx_buffer_len);
#endif  /* ETSEC_RING_DEBUG */
            if (etsec->first_bd.flags & BD_TX_TOEUN) {
                qemu_send_packet(qemu_get_queue(etsec->nic),
                        etsec->tx_buffer + 8,
                        etsec->tx_buffer_len - 8);
            } else {
                qemu_send_packet(qemu_get_queue(etsec->nic),
                        etsec->tx_buffer,
                        etsec->tx_buffer_len);
            }
        }
        etsec->tx_buffer_len = 0;
        if (bd->flags & BD_INTERRUPT) {
            ievent_set(etsec, IEVENT_TXF);
        }
    } else {
        if (bd->flags & BD_INTERRUPT) {
            ievent_set(etsec, IEVENT_TXB);
        }
    }
    /* Update DB flags */
    /* Clear Ready */
    bd->flags &= ~BD_TX_READY;
    /* Clear Defer */
    bd->flags &= ~BD_TX_PREDEF;
    /* Clear Late Collision */
    bd->flags &= ~BD_TX_HFELC;
    /* Clear Retransmission Limit */
    bd->flags &= ~BD_TX_CFRL;
    /* Clear Retry Count */
    bd->flags &= ~(BD_TX_RC_MASK << BD_TX_RC_OFFSET);
    /* Clear Underrun */
    bd->flags &= ~BD_TX_TOEUN;
    /* Clear Truncation */
    bd->flags &= ~BD_TX_TR;
}
