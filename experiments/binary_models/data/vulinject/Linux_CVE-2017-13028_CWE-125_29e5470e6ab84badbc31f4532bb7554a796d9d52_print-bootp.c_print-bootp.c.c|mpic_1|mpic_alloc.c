struct mpic * __init mpic_alloc(struct device_node *node,
				phys_addr_t phys_addr,
				unsigned int flags,
				unsigned int isu_size,
				unsigned int irq_count,
				const char *name)
{
	int i, psize, intvec_top;
	struct mpic *mpic;
	unsigned int greg_feature;
	const char *vers;
	const unsigned int *psrc;
	unsigned int last_irq;
	unsigned int fsl_version = 0;
	static const struct of_device_id __initconst mpic_device_id[] = {
		{ .type	      = "open-pic", },
		{ .compatible = "open-pic", },
		{},
	};
	if (node) {
		node = of_node_get(node);
	} else {
		node = of_find_matching_node(NULL, mpic_device_id);
		if (!node)
			return NULL;
	}
	if (!phys_addr) {
		if (of_property_read_bool(node, "dcr-reg")) {
			flags |= MPIC_USES_DCR;
		} else {
			struct resource r;
			if (of_address_to_resource(node, 0, &r))
				goto err_of_node_put;
			phys_addr = r.start;
		}
	}
	if (of_property_read_bool(node, "big-endian"))
		flags |= MPIC_BIG_ENDIAN;
	if (of_property_read_bool(node, "pic-no-reset"))
		flags |= MPIC_NO_RESET;
	if (of_property_read_bool(node, "single-cpu-affinity"))
		flags |= MPIC_SINGLE_DEST_CPU;
	if (of_device_is_compatible(node, "fsl,mpic")) {
		flags |= MPIC_FSL | MPIC_LARGE_VECTORS;
		mpic_irq_chip.flags |= IRQCHIP_SKIP_SET_WAKE;
		mpic_tm_chip.flags |= IRQCHIP_SKIP_SET_WAKE;
	}
	mpic = kzalloc(sizeof(struct mpic), GFP_KERNEL);
	if (mpic == NULL)
		goto err_of_node_put;
	mpic->name = name;
	mpic->node = node;
	mpic->paddr = phys_addr;
	mpic->flags = flags;
	mpic->hc_irq = mpic_irq_chip;
	mpic->hc_irq.name = name;
	if (!(mpic->flags & MPIC_SECONDARY))
		mpic->hc_irq.irq_set_affinity = mpic_set_affinity;
#ifdef CONFIG_MPIC_U3_HT_IRQS
	mpic->hc_ht_irq = mpic_irq_ht_chip;
	mpic->hc_ht_irq.name = name;
	if (!(mpic->flags & MPIC_SECONDARY))
		mpic->hc_ht_irq.irq_set_affinity = mpic_set_affinity;
#endif 
#ifdef CONFIG_SMP
	mpic->hc_ipi = mpic_ipi_chip;
	mpic->hc_ipi.name = name;
#endif 
	mpic->hc_tm = mpic_tm_chip;
	mpic->hc_tm.name = name;
	mpic->num_sources = 0; 
	if (mpic->flags & MPIC_LARGE_VECTORS)
		intvec_top = 2047;
	else
		intvec_top = 255;
	mpic->timer_vecs[0] = intvec_top - 12;
	mpic->timer_vecs[1] = intvec_top - 11;
	mpic->timer_vecs[2] = intvec_top - 10;
	mpic->timer_vecs[3] = intvec_top - 9;
	mpic->timer_vecs[4] = intvec_top - 8;
	mpic->timer_vecs[5] = intvec_top - 7;
	mpic->timer_vecs[6] = intvec_top - 6;
	mpic->timer_vecs[7] = intvec_top - 5;
	mpic->ipi_vecs[0]   = intvec_top - 4;
	mpic->ipi_vecs[1]   = intvec_top - 3;
	mpic->ipi_vecs[2]   = intvec_top - 2;
	mpic->ipi_vecs[3]   = intvec_top - 1;
	mpic->spurious_vec  = intvec_top;
	psrc = of_get_property(mpic->node, "protected-sources", &psize);
	if (psrc) {
		mpic->protected = bitmap_zalloc(intvec_top + 1, GFP_KERNEL);
		BUG_ON(mpic->protected == NULL);
		for (i = 0; i < psize/sizeof(unsigned int); i++) {
			if (psrc[i] > intvec_top)
				continue;
			__set_bit(psrc[i], mpic->protected);
		}
	}
#ifdef CONFIG_MPIC_WEIRD
	mpic->hw_set = mpic_infos[MPIC_GET_REGSET(mpic->flags)];
#endif
	if (mpic->flags & MPIC_BIG_ENDIAN)
		mpic->reg_type = mpic_access_mmio_be;
	else
		mpic->reg_type = mpic_access_mmio_le;
#ifdef CONFIG_PPC_DCR
	if (mpic->flags & MPIC_USES_DCR)
		mpic->reg_type = mpic_access_dcr;
#else
	BUG_ON(mpic->flags & MPIC_USES_DCR);
#endif
	mpic_map(mpic, mpic->paddr, &mpic->gregs, MPIC_INFO(GREG_BASE), 0x1000);
	mpic_map(mpic, mpic->paddr, &mpic->tmregs, MPIC_INFO(TIMER_BASE), 0x1000);
	if (mpic->flags & MPIC_FSL) {
		int ret;
		mpic_map(mpic, mpic->paddr, &mpic->thiscpuregs,
			 MPIC_CPU_THISBASE, 0x1000);
		fsl_version = fsl_mpic_get_version(mpic);
		if (fsl_version >= 0x401) {
			ret = mpic_setup_error_int(mpic, intvec_top - 13);
			if (ret)
				return NULL;
		}
	}
	if (fsl_version < 0x400 && (flags & MPIC_ENABLE_COREINT))
		ppc_md.get_irq = mpic_get_irq;
	if (!(mpic->flags & MPIC_NO_RESET)) {
		printk(KERN_DEBUG "mpic: Resetting\n");
		mpic_write(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0),
			   mpic_read(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0))
			   | MPIC_GREG_GCONF_RESET);
		while( mpic_read(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0))
		       & MPIC_GREG_GCONF_RESET)
			mb();
	}
	if (mpic->flags & MPIC_ENABLE_COREINT)
		mpic_write(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0),
			   mpic_read(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0))
			   | MPIC_GREG_GCONF_COREINT);
	if (mpic->flags & MPIC_ENABLE_MCK)
		mpic_write(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0),
			   mpic_read(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0))
			   | MPIC_GREG_GCONF_MCK);
	BUG_ON(num_possible_cpus() > MPIC_MAX_CPUS);
	for_each_possible_cpu(i) {
		unsigned int cpu = get_hard_smp_processor_id(i);
		mpic_map(mpic, mpic->paddr, &mpic->cpuregs[cpu],
			 MPIC_INFO(CPU_BASE) + cpu * MPIC_INFO(CPU_STRIDE),
			 0x1000);
	}
	greg_feature = mpic_read(mpic->gregs, MPIC_INFO(GREG_FEATURE_0));
	last_irq = (greg_feature & MPIC_GREG_FEATURE_LAST_SRC_MASK)
				>> MPIC_GREG_FEATURE_LAST_SRC_SHIFT;
	if (isu_size)
		last_irq = isu_size  * MPIC_MAX_ISU - 1;
	of_property_read_u32(mpic->node, "last-interrupt-source", &last_irq);
	if (irq_count)
		last_irq = irq_count - 1;
	if (!isu_size) {
		isu_size = last_irq + 1;
		mpic->num_sources = isu_size;
		mpic_map(mpic, mpic->paddr, &mpic->isus[0],
				MPIC_INFO(IRQ_BASE),
				MPIC_INFO(IRQ_STRIDE) * isu_size);
	}
	mpic->isu_size = isu_size;
	mpic->isu_shift = 1 + __ilog2(mpic->isu_size - 1);
	mpic->isu_mask = (1 << mpic->isu_shift) - 1;
	mpic->irqhost = irq_domain_add_linear(mpic->node,
				       intvec_top,
				       &mpic_host_ops, mpic);
	if (mpic->irqhost == NULL)
		return NULL;
	switch (greg_feature & MPIC_GREG_FEATURE_VERSION_MASK) {
	case 1:
		vers = "1.0";
		break;
	case 2:
		vers = "1.2";
		break;
	case 3:
		vers = "1.3";
		break;
	default:
		vers = "<unknown>";
		break;
	}
	printk(KERN_INFO "mpic: Setting up MPIC \"%s\" version %s at %llx,"
	       " max %d CPUs\n",
	       name, vers, (unsigned int int)mpic->paddr, num_possible_cpus());
	printk(KERN_INFO "mpic: ISU size: %d, shift: %d, mask: %x\n",
	       mpic->isu_size, mpic->isu_shift, mpic->isu_mask);
	mpic->next = mpics;
	mpics = mpic;
	if (!(mpic->flags & MPIC_SECONDARY)) {
		mpic_primary = mpic;
	}
	return mpic;
err_of_node_put:
	of_node_put(node);
	return NULL;
}
