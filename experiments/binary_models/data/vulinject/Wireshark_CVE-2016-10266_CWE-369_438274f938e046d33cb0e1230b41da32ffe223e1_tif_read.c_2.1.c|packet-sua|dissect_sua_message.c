dissect_sua_message(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *sua_tree, proto_tree *tree)
{
  tvbuff_t *common_header_tvb;
  tvbuff_t *parameters_tvb;
  tvbuff_t *data_tvb = NULL;
  heur_dtbl_entry_t *hdtbl_entry;
#if 0
  proto_tree *assoc_tree;
#endif
  guint8 source_ssn = INVALID_SSN;
  guint8 dest_ssn = INVALID_SSN;
  proto_item *assoc_item;
  struct _sccp_msg_info_t* sccp_info = NULL;
  message_class = 0;
  message_type = 0;
  drn = 0;
  srn = 0;
  assoc = NULL;
  no_sua_assoc.calling_dpc = 0;
  no_sua_assoc.called_dpc = 0;
  no_sua_assoc.calling_ssn = INVALID_SSN;
  no_sua_assoc.called_ssn = INVALID_SSN;
  no_sua_assoc.has_bw_key = FALSE;
  no_sua_assoc.has_fw_key = FALSE;
	sua_opc=((pinfo->pool+mtp3_addr_pc_t-1)/mtp3_addr_pc_t);
  sua_dpc = wmem_new0(pinfo->pool, mtp3_addr_pc_t);
  sua_source_gt = NULL;
  sua_destination_gt = NULL;
  common_header_tvb = tvb_new_subset_length(message_tvb, COMMON_HEADER_OFFSET, COMMON_HEADER_LENGTH);
  dissect_common_header(common_header_tvb, pinfo, sua_tree);
  parameters_tvb = tvb_new_subset_remaining(message_tvb, COMMON_HEADER_LENGTH);
  dissect_parameters(parameters_tvb, pinfo, sua_tree, &data_tvb, &source_ssn, &dest_ssn);
  if (message_class == MESSAGE_CLASS_CO_MESSAGE) {
      sccp_assoc_info_t* sccp_assoc;
      sccp_decode_context_t sccp_decode;
      switch (message_type) {
              case MESSAGE_TYPE_CORE:
                      assoc = sua_assoc(pinfo,&(pinfo->src),&(pinfo->dst), srn , drn);
                      if(assoc) {
                              assoc->calling_routing_ind = sua_ri;
                              assoc->calling_ssn = source_ssn;
                              assoc->called_ssn = dest_ssn;
                      }
                      break;
              case MESSAGE_TYPE_COAK:
                      assoc = sua_assoc(pinfo,&(pinfo->src),&(pinfo->dst), srn , drn);
                      if(assoc) {
                              assoc->called_routing_ind = sua_ri;
                              if( (assoc->called_ssn != INVALID_SSN)&& (dest_ssn != INVALID_SSN)) {
                                      assoc->called_ssn = dest_ssn;
                              }
                      }
                      break;
              default :
                      assoc = sua_assoc(pinfo,&(pinfo->src),&(pinfo->dst), srn , drn);
      }
      switch (message_type) {
              case MESSAGE_TYPE_CORE:
              case MESSAGE_TYPE_COAK:
                       break;
              default:
                      if((assoc && assoc->called_ssn != INVALID_SSN)&& (dest_ssn != INVALID_SSN)) {
                              dest_ssn = assoc->called_ssn;
                      }
                      if((assoc && assoc->calling_ssn != INVALID_SSN)&& (source_ssn != INVALID_SSN)) {
                              source_ssn = assoc->calling_ssn;
                      }
      }
      if (assoc && assoc->assoc_id !=0) {
          assoc_item = proto_tree_add_uint(tree, hf_sua_assoc_id, message_tvb, 0, 0, assoc->assoc_id);
          proto_item_set_generated(assoc_item);
#if 0
          assoc_tree = proto_item_add_subtree(assoc_item, ett_sua_assoc);
          proto_tree_add_debug_text(assoc_tree, message_tvb, 0, 0, "routing_ind %u", assoc->calling_routing_ind);
          proto_tree_add_debug_text(assoc_tree, message_tvb, 0, 0, "routing_ind %u", assoc->called_routing_ind);
          proto_tree_add_debug_text(assoc_tree, message_tvb, 0, 0, "calling_ssn %u", assoc->calling_ssn);
          proto_tree_add_debug_text(assoc_tree, message_tvb, 0, 0, "called_ssn %u", assoc->called_ssn);
#endif 
      }
      sccp_decode.message_type = message_type;
      sccp_decode.dlr = drn;
      sccp_decode.slr = srn;
      sccp_decode.assoc = NULL;
      sccp_decode.sccp_msg = NULL; 
      sccp_assoc = get_sccp_assoc(pinfo, tvb_offset_from_real_beginning(message_tvb), &sccp_decode);
      if (sccp_assoc && sccp_assoc->curr_msg) {
              sccp_info = sccp_assoc->curr_msg;
              tap_queue_packet(sua_tap,pinfo,sccp_assoc->curr_msg);
      }
  }
  if (set_addresses) {
    if (sua_opc->type)
      set_address(&pinfo->src, ss7pc_address_type, sizeof(mtp3_addr_pc_t), (guint8 *) sua_opc);
    if (sua_dpc->type)
      set_address(&pinfo->dst, ss7pc_address_type, sizeof(mtp3_addr_pc_t), (guint8 *) sua_dpc);
    if (sua_source_gt)
      set_address(&pinfo->src, AT_STRINGZ, 1+(int)strlen(sua_source_gt), wmem_strdup(pinfo->pool, sua_source_gt));
    if (sua_destination_gt)
      set_address(&pinfo->dst, AT_STRINGZ, 1+(int)strlen(sua_destination_gt), wmem_strdup(pinfo->pool, sua_destination_gt));
  }
  if(data_tvb)
  {
    if ((dest_ssn == INVALID_SSN ||
       !dissector_try_uint_new(sccp_ssn_dissector_table, dest_ssn, data_tvb, pinfo, tree, TRUE, sccp_info))
       && (source_ssn == INVALID_SSN ||
       !dissector_try_uint_new(sccp_ssn_dissector_table, source_ssn, data_tvb, pinfo, tree, TRUE, sccp_info)))
    {
      if (dissector_try_heuristic(heur_subdissector_list, data_tvb, pinfo, tree, &hdtbl_entry, sccp_info)) {
        return;
      }
      call_data_dissector(data_tvb, pinfo, tree);
    }
  }
}
