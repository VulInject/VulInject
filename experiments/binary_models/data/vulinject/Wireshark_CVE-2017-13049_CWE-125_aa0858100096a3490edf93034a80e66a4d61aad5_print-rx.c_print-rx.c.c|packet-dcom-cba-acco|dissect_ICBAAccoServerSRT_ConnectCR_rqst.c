dissect_ICBAAccoServerSRT_ConnectCR_rqst(tvbuff_t *tvb, int offset,
    packet_info *pinfo, proto_tree *tree, dcerpc_info *di, guint8 *drep)
{
    gchar   szCons[1000]            = { 0 };
    guint32           u32MaxConsLen = sizeof(szCons);
    guint16           u16QoSType;
    guint16           u16QoSValue;
    guint8            u8ConsMac[6];
    guint16           u16CRID       = 0;
    guint16           u16CRLength   = 0;
    guint32           u32Flags;
    guint32           u32Count;
    guint32           u32ArraySize;
    guint32           u32Idx;
    proto_item       *item;
    proto_tree       *flags_tree;
    guint32           u32SubStart;
    dcom_interface_t *cons_interf;
    cba_ldev_t       *prov_ldev;
    cba_ldev_t       *cons_ldev;
    cba_frame_t      *frame;
    server_frame_call_t *call;
    offset = dissect_dcom_this(tvb, offset, pinfo, tree, di, drep);
    prov_ldev = cba_ldev_find(pinfo, &pinfo->net_dst, &di->call_data->object_uuid);
    item = proto_tree_add_boolean (tree, hf_cba_acco_srt_call, tvb, offset, 0, TRUE);
    p_add_proto_data(pinfo->pool, pinfo, proto_ICBAAccoMgt, 0, GUINT_TO_POINTER(4));
    offset = dissect_dcom_LPWSTR(tvb, offset, pinfo, tree, di, drep,
                       hf_cba_acco_conn_consumer, szCons, u32MaxConsLen);
    cons_ldev = cba_acco_add(pinfo, szCons);
    offset = dissect_dcom_WORD(tvb, offset, pinfo, tree, di, drep,
                        hf_cba_acco_conn_qos_type, &u16QoSType);
    offset = dissect_dcom_WORD(tvb, offset, pinfo, tree, di, drep,
                        hf_cba_acco_conn_qos_value, &u16QoSValue);
    offset = dissect_dcom_PMInterfacePointer(tvb, offset, pinfo, tree, di, drep, 0, &cons_interf);
    if (cons_interf == NULL) {
        expert_add_info_format(pinfo, NULL, &ei_cba_acco_conn_consumer,
            "ServerSRT_ConnectCR: consumer interface invalid");
    }
    if (cons_interf != NULL && cons_ldev != NULL) {
        cba_ldev_link_acco(pinfo, cons_ldev, cons_interf);
    }
    tvb_memcpy(tvb, u8ConsMac, offset, 6);
    proto_tree_add_ether(tree, hf_cba_acco_serversrt_cons_mac, tvb,
        offset, 6, u8ConsMac);
    offset += 6;
    offset = dissect_dcom_DWORD(tvb, offset, pinfo, NULL , di, drep,
                        0 , &u32Flags);
    offset -= 4;
    item = proto_tree_add_uint_format_value(tree, hf_cba_acco_serversrt_cr_flags,
        tvb, offset, 4, u32Flags,
        "0x%02x (%s, %s)", u32Flags,
        (u32Flags & 0x2) ? "Reconfigure" : "not Reconfigure",
        (u32Flags & 0x1) ? "Timestamped" : "not Timestamped");
    flags_tree = proto_item_add_subtree(item, ett_cba_acco_serversrt_cr_flags);
    proto_tree_add_boolean(flags_tree, hf_cba_acco_serversrt_cr_flags_reconfigure, tvb, offset, 4, u32Flags);
    proto_tree_add_boolean(flags_tree, hf_cba_acco_serversrt_cr_flags_timestamped, tvb, offset, 4, u32Flags);
    offset += 4;
    offset = dissect_dcom_DWORD(tvb, offset, pinfo, tree, di, drep,
                        hf_cba_acco_count, &u32Count);
    offset = dissect_dcom_dcerpc_array_size(tvb, offset, pinfo, tree, di, drep,
                        &u32ArraySize);
    if (prov_ldev != NULL && cons_ldev != NULL && u32ArraySize < 100) {
        call = (server_frame_call_t *)wmem_alloc(wmem_file_scope(), sizeof(server_frame_call_t) + u32ArraySize * sizeof(cba_frame_t *));
        call->frame_count = 0;
        call->frames = (cba_frame_t **) (call+1);
        di->call_data->private_data = call;
    } else {
        call = NULL;
    }
    u32Idx = 1;
    while (u32ArraySize--) {
        proto_item *sub_item;
        proto_tree *sub_tree;
        sub_item = proto_tree_add_item(tree, hf_cba_connectincr, tvb, offset, 0, ENC_NA);
        sub_tree = proto_item_add_subtree(sub_item, ett_cba_connectincr);
        u32SubStart = offset;
        offset = dissect_dcom_WORD(tvb, offset, pinfo, sub_tree, di, drep,
                            hf_cba_acco_serversrt_cr_id, &u16CRID);
        offset = dissect_dcom_WORD(tvb, offset, pinfo, sub_tree, di, drep,
                            hf_cba_acco_serversrt_cr_length, &u16CRLength);
        if (prov_ldev != NULL && cons_ldev != NULL) {
            frame = cba_frame_connect(pinfo, cons_ldev, prov_ldev, u16QoSType, u16QoSValue, u8ConsMac, u16CRID, u16CRLength);
            cba_frame_info(tvb, pinfo, sub_tree, frame);
        } else {
            frame = NULL;
        }
        if (call != NULL) {
            call->frame_count++;
            call->frames[u32Idx-1] = frame;
        }
        proto_item_append_text(sub_item, "[%u]: CRID=0x%x, CRLength=%u",
            u32Idx, u16CRID, u16CRLength);
        proto_item_set_len(sub_item, offset - u32SubStart);
        u32Idx++;
    }
    col_append_fstr(pinfo->cinfo, COL_INFO, ": %sConsCRID=0x%x Len=%u QoS=%u",
           (u32Flags & 0x2) ? "Reco " : "", u16CRID, u16CRLength, u16QoSValue);
    return offset;
}
