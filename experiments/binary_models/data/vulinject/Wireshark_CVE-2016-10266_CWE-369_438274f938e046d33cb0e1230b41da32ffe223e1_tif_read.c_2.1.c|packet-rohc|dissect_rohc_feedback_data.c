dissect_rohc_feedback_data(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, int offset, gint16 feedback_data_len,
                           rohc_info *p_rohc_info, guint16 cid, gboolean cid_context)
{
    proto_item         *ti;
    proto_tree         *rohc_feedback_tree;
    guint8              opt, opt_len, oct;
    rohc_cid_context_t *rohc_cid_context = NULL;
    gint                key = cid;
    guint32             sn;
    if (!PINFO_FD_VISITED(pinfo)) {
        rohc_cid_context = (rohc_cid_context_t*)g_hash_table_lookup(rohc_cid_hash, GUINT_TO_POINTER(key));
        if (rohc_cid_context) {
            p_add_proto_data(wmem_file_scope(), pinfo, proto_rohc, 0, rohc_cid_context);
        }
    } else{
        rohc_cid_context = (rohc_cid_context_t*)p_get_proto_data(wmem_file_scope(), pinfo, proto_rohc, 0);
    }
    if (!rohc_cid_context) {
        if (cid_context) {
	rohc_cid_context=((pinfo->pool+rohc_cid_context_t-1)/rohc_cid_context_t);
            rohc_cid_context->rnd = p_rohc_info->rnd;
            rohc_cid_context->udp_checksum_present = p_rohc_info->udp_checksum_present;
            rohc_cid_context->profile = p_rohc_info->profile;
            rohc_cid_context->mode = p_rohc_info->mode;
            rohc_cid_context->rohc_ip_version = p_rohc_info->rohc_ip_version;
            rohc_cid_context->large_cid_present = p_rohc_info->large_cid_present;
            rohc_cid_context->prev_ir_frame_number = -1;
            rohc_cid_context->ir_frame_number = -1;
        } else {
            proto_item_append_text(p_rohc_info->last_created_item, " (type %d)", (feedback_data_len==1) ? 1 : 2);
            proto_tree_add_expert_format(tree, pinfo, &ei_rohc_profile_not_supported, tvb, offset, feedback_data_len, "profile-specific information [Profile not known]");
            return;
        }
    }
    if (feedback_data_len==1) {
        proto_item_append_text(p_rohc_info->last_created_item, " (type 1)");
        oct = tvb_get_guint8(tvb, offset);
        switch (rohc_cid_context->profile) {
            case ROHC_PROFILE_UNCOMPRESSED: 
                ti = proto_tree_add_item(tree, hf_rohc_profile_spec_octet, tvb, offset, 1, ENC_BIG_ENDIAN);
                if (oct) {
                    expert_add_info_format(pinfo, ti, &ei_rohc_profile_spec_octet, "Invalid profile-specific octet value (0x%02X)", oct);
                }
                break;
            case ROHC_PROFILE_RTP: 
            case ROHC_PROFILE_UDP: 
                proto_tree_add_item(tree, hf_rohc_fb1_sn, tvb, offset, 1, ENC_BIG_ENDIAN);
                col_append_fstr(pinfo->cinfo, COL_INFO, " (sn=%u)", oct);
                break;
            default:
                proto_tree_add_expert(tree, pinfo, &ei_rohc_profile_specific, tvb, offset, feedback_data_len);
                break;
        }
        return;
    }
    proto_item_append_text(p_rohc_info->last_created_item, " (type 2)");
    switch (rohc_cid_context->profile) {
        case ROHC_PROFILE_UNCOMPRESSED: 
            expert_add_info(pinfo, p_rohc_info->last_created_item, &ei_rohc_feedback_type_2_is_not_applicable_for_uncompressed_profile);
            break;
        case ROHC_PROFILE_RTP: 
        case ROHC_PROFILE_UDP: 
            rohc_feedback_tree = proto_tree_add_subtree_format(tree, tvb, offset, feedback_data_len, ett_rohc_feedback, NULL,
                                     "%s profile-specific information",
                                     (rohc_cid_context->profile == ROHC_PROFILE_RTP) ? "RTP" : "UDP");
            proto_tree_add_item(rohc_feedback_tree, hf_rohc_acktype, tvb, offset, 1, ENC_BIG_ENDIAN);
            rohc_cid_context->mode = (enum rohc_mode)((tvb_get_guint8(tvb,offset) & 0x30)>>4);
            proto_tree_add_item(rohc_feedback_tree, hf_rohc_mode, tvb, offset, 1, ENC_BIG_ENDIAN);
            sn = tvb_get_ntohs(tvb, offset) & 0x0fff;
            proto_tree_add_item(rohc_feedback_tree, hf_rohc_sn, tvb, offset, 2, ENC_BIG_ENDIAN);
            offset+=2;
            feedback_data_len-=2;
            while (feedback_data_len>0) {
                opt = opt_len = tvb_get_guint8(tvb,offset);
                opt = opt >> 4;
                opt_len = opt_len &0x0f;
                ti = proto_tree_add_item(rohc_feedback_tree, hf_rohc_opt_type, tvb, offset, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(rohc_feedback_tree, hf_rohc_opt_len, tvb, offset, 1, ENC_BIG_ENDIAN);
                offset++;
                feedback_data_len--;
                switch (opt) {
                    case 1:
                        proto_tree_add_item(rohc_feedback_tree, hf_rohc_crc, tvb, offset, 1, ENC_BIG_ENDIAN);
                        oct = tvb_get_guint8(tvb, offset);
                        col_append_fstr(pinfo->cinfo, COL_INFO, "CRC=%u ", oct);
                        break;
                    case 2:
                        col_append_str(pinfo->cinfo, COL_INFO, "Reject ");
                        break;
                    case 3:
                        col_append_str(pinfo->cinfo, COL_INFO, "SN-Not-Valid ");
                        break;
                    case 4:
                        proto_tree_add_item(rohc_feedback_tree, hf_rohc_opt_sn, tvb, offset, 1, ENC_BIG_ENDIAN);
                        sn = (sn << 8) | tvb_get_guint8(tvb, offset);
                        ti = proto_tree_add_uint(rohc_feedback_tree, hf_rohc_ext_sn, tvb, 0, 0, sn);
                        proto_item_set_generated(ti);
                        break;
                    case 5:
                        if (rohc_cid_context->profile == ROHC_PROFILE_RTP) {
                            proto_tree_add_item(rohc_feedback_tree, hf_rohc_opt_clock, tvb, offset, 1, ENC_BIG_ENDIAN);
                            oct = tvb_get_guint8(tvb, offset);
                            col_append_fstr(pinfo->cinfo, COL_INFO, "Clock=%u ", oct);
                        } else {
                            expert_add_info(pinfo, ti, &ei_rohc_rohc_opt_clock);
                        }
                        break;
                    case 6:
                        if (rohc_cid_context->profile == ROHC_PROFILE_RTP) {
                            proto_tree_add_item(rohc_feedback_tree, hf_rohc_opt_jitter, tvb, offset, 1, ENC_BIG_ENDIAN);
                            oct = tvb_get_guint8(tvb, offset);
                            col_append_fstr(pinfo->cinfo, COL_INFO, "Jitter=%u ", oct);
                        } else {
                            expert_add_info(pinfo, ti, &ei_rohc_opt_jitter);
                        }
                        break;
                    case 7:
                        proto_tree_add_item(rohc_feedback_tree, hf_rohc_opt_loss, tvb, offset, 1, ENC_BIG_ENDIAN);
                        oct = tvb_get_guint8(tvb, offset);
                        col_append_fstr(pinfo->cinfo, COL_INFO, "Loss=%u ", oct);
                        break;
                    default:
                        proto_tree_add_item(rohc_feedback_tree, hf_rohc_unknown_option_data, tvb, offset, opt_len, ENC_NA);
                        break;
                }
                feedback_data_len = feedback_data_len - opt_len;
                offset = offset + opt_len;
            }
            col_append_fstr(pinfo->cinfo, COL_INFO, " (sn=%u)", sn);
            break;
        default:
            rohc_feedback_tree = proto_tree_add_subtree(tree, tvb, offset, feedback_data_len,
                        ett_rohc_feedback, NULL, "profile-specific information[Not dissected yet]");
            proto_tree_add_item(rohc_feedback_tree, hf_rohc_acktype, tvb, offset, 1, ENC_BIG_ENDIAN);
            break;
    }
}
