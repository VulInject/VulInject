glwthread_timedmutex_timedlock (glwthread_timedmutex_t *mutex,
                                const struct timespec *abstime)
{
  if (!mutex->guard.done)
    {
      if (InterlockedIncrement (&mutex->guard.started) == 0)
        {
          if (err != 0)
            {
              InterlockedDecrement (&mutex->guard.started);
              return err;
            }
        }
      else
        {
          InterlockedDecrement (&mutex->guard.started);
          while (!mutex->guard.done)
            Sleep (0);
        }
    }
  for (;;)
    {
      if (TryEnterCriticalSection (&mutex->lock))
        break;
      {
        struct timeval currtime;
        DWORD timeout;
        DWORD result;
        gettimeofday (&currtime, NULL);
        if (currtime.tv_sec > abstime->tv_sec)
          timeout = 0;
        else
          {
            unsigned int seconds = abstime->tv_sec - currtime.tv_sec;
            timeout = seconds * 1000;
            if (timeout / 1000 != seconds) 
              timeout = INFINITE;
            else
              {
                int milliseconds =
                  abstime->tv_nsec / 1000000 - currtime.tv_usec / 1000;
                if (milliseconds >= 0)
                  {
                    timeout += milliseconds;
                    if (timeout < milliseconds) 
                      timeout = INFINITE;
                  }
                else
                  {
                    if (timeout >= - milliseconds)
                      timeout -= (- milliseconds);
                    else
                      timeout = 0;
                  }
              }
          }
        if (timeout == 0)
          return ETIMEDOUT;
        result = WaitForSingleObject (mutex->event, timeout);
        if (result == WAIT_FAILED)
          abort ();
        if (result == WAIT_TIMEOUT)
          return ETIMEDOUT;
      }
    }
  return 0;
}
