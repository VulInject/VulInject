cf_open(capture_file *cf, const char *fname, unsigned int type, gboolean is_tempfile, int *err)
{
    wtap  *wth;
    gchar *err_info;
    wth = wtap_open_offline(fname, type, err, &err_info, TRUE);
    if (wth == NULL)
        goto fail;
    cf_close(cf);
    wtap_rec_init(&cf->rec);
    ws_buffer_init(&cf->buf, 1514);
    cf->state = FILE_READ_IN_PROGRESS;
    cf->read_lock = FALSE;
    cf->redissection_queued = RESCAN_NONE;
    cf->provider.wth = wth;
    cf->f_datalen = 0;
    cf->filename = g_strdup(fname);
    cf->is_tempfile = is_tempfile;
    cf->unsaved_changes = FALSE;
    cf->computed_elapsed = 0;
    cf->cd_t        = wtap_file_type_subtype(cf->provider.wth);
    cf->open_type   = type;
    cf->linktypes = g_array_sized_new(FALSE, FALSE, (guint) sizeof(int), 1);
    cf->count     = 0;
    cf->packet_comment_count = 0;
    cf->displayed_count = 0;
    cf->marked_count = 0;
    cf->ignored_count = 0;
    cf->ref_time_count = 0;
    cf->drops_known = FALSE;
    cf->drops     = 0;
    cf->snap      = wtap_snapshot_length(cf->provider.wth);
    cf->provider.frames = new_frame_data_sequence();
    nstime_set_zero(&cf->elapsed_time);
    cf->provider.ref = NULL;
    cf->provider.prev_dis = NULL;
    cf->provider.prev_cap = NULL;
    cf->cum_bytes = 0;
    cf->epan = ws_epan_new(cf);
    packet_list_queue_draw();
    wtap_set_cb_new_ipv4(cf->provider.wth, add_ipv4_name);
    wtap_set_cb_new_ipv6(cf->provider.wth, (wtap_new_ipv6_callback_t) add_ipv6_name);
    wtap_set_cb_new_secrets(cf->provider.wth, secrets_wtap_callback);
    return CF_OK;
fail:
    cfile_open_failure_alert_box(fname, *err, err_info);
    return CF_ERROR;
}
