print_insn_arm (bfd_vma pc, struct disassemble_info *info, int given)
{
  const struct opcode32 *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;
  struct arm_private_data *private_data = info->private_data;
  if (print_insn_coprocessor (pc, info, given, FALSE)) {
	  return;
  }
  if (print_insn_neon (info, given, FALSE)) {
	  return;
  }
  for (insn = arm_opcodes; insn->assembler; insn++)
    {
	  if ((given & insn->mask) != insn->value) {
		  continue;
	  }
	  if (!ARM_CPU_HAS_FEATURE (insn->arch, private_data->features)) {
		  continue;
	  }
	  if ((given & 0xF0000000) != 0xF0000000 || (insn->mask & 0xF0000000) == 0xF0000000 || (insn->mask == 0 && insn->value == 0)) {
		  unsigned int u_reg = 16;
		  unsigned int U_reg = 16;
		  bfd_boolean is_unpredictable = FALSE;
		  int value_in_comment = 0;
		  const char *c;
		  for (c = insn->assembler; *c; c++) {
			  if (*c == '%') {
				  bfd_boolean allow_unpredictable = FALSE;
				  switch (*++c) {
				  case '%':
					  func (stream, "%%");
					  break;
				  case 'a':
					  value_in_comment = print_arm_address (pc, info, given);
					  break;
				  case 'P':
					  value_in_comment = print_arm_address (pc, info, given | (1 << P_BIT));
					  break;
				  case 'S':
					  allow_unpredictable = TRUE;
				  case 's':
					  if ((given & 0x004f0000) == 0x004f0000) {
						  bfd_vma offset = ((given & 0xf00) >> 4) | (given & 0xf);
						  if (PRE_BIT_SET) {
							  if (offset || NEGATIVE_BIT_SET) {
								  func (stream, "[pc, %s%d] ; ",
									  NEGATIVE_BIT_SET ? "-" : "", (int)offset);
							  } else {
								  func (stream, "[pc] ; ");
							  }
							  if (NEGATIVE_BIT_SET) {
								  offset = -offset;
							  }
							  info->print_address_func (offset + pc + 8, info);
						  } else {
							  func (stream, "[pc], %s%d",
								  NEGATIVE_BIT_SET ? "-" : "", (int)offset);
							  if (!allow_unpredictable) {
								  is_unpredictable = TRUE;
							  }
						  }
					  } else {
						  int offset = ((given & 0xf00) >> 4) | (given & 0xf);
						  func (stream, "[%s",
							  arm_regnames[(given >> 16) & 0xf]);
						  if (PRE_BIT_SET) {
							  if (IMMEDIATE_BIT_SET) {
								  if (WRITEBACK_BIT_SET || NEGATIVE_BIT_SET || offset) {
									  func (stream, ", %s%d",
										  NEGATIVE_BIT_SET ? "-" : "", offset);
								  }
								  if (NEGATIVE_BIT_SET) {
									  offset = -offset;
								  }
								  value_in_comment = offset;
							  } else {
								  func (stream, ", %s%s",
									  NEGATIVE_BIT_SET ? "-" : "",
									  arm_regnames[given & 0xf]);
								  if (!allow_unpredictable && WRITEBACK_BIT_SET && ((given & 0xf) == ((given >> 12) & 0xf))) {
									  is_unpredictable = TRUE;
								  }
							  }
							  func (stream, "]%s",
								  WRITEBACK_BIT_SET ? "!" : "");
						  } else {
							  if (IMMEDIATE_BIT_SET) {
								  func (stream, "], %s%d",
									  NEGATIVE_BIT_SET ? "-" : "", offset);
								  if (NEGATIVE_BIT_SET) {
									  offset = -offset;
								  }
								  value_in_comment = offset;
							  } else {
								  func (stream, "], %s%s",
									  NEGATIVE_BIT_SET ? "-" : "",
									  arm_regnames[given & 0xf]);
								  if (!allow_unpredictable && (given & 0xf) == ((given >> 12) & 0xf)) {
									  is_unpredictable = TRUE;
								  }
							  }
							  if (!allow_unpredictable) {
								  if (WRITEBACK_BIT_SET
									  || (!IMMEDIATE_BIT_SET && ((given & 0xf) == 0xf))) {
									  is_unpredictable = TRUE;
								  }
							  }
						  }
					  }
					  break;
				  case 'b': {
					  bfd_vma disp = (((given & 0xffffff) ^ 0x800000) - 0x800000);
					  info->print_address_func (disp * 4 + pc + 8, info);
				  } break;
				  case 'c':
					  if (((given >> 28) & 0xf) != 0xe) {
						  func (stream, "%s",
							  arm_conditional[(given >> 28) & 0xf]);
					  }
					  break;
				  case 'm': {
					  int started = 0;
					  int reg;
					  func (stream, "{");
					  for (reg = 0; reg < 16; reg++) {
						  if ((given & (1 << reg)) != 0) {
							  if (started) {
								  func (stream, ", ");
							  }
							  started = 1;
							  func (stream, "%s", arm_regnames[reg]);
						  }
					  }
					  func (stream, "}");
					  if (!started) {
						  is_unpredictable = TRUE;
					  }
				  } break;
				  case 'q':
					  arm_decode_shift (given, func, stream, FALSE);
					  break;
				  case 'o':
					  if ((given & 0x02000000) != 0) {
						  unsigned int rotate = (given & 0xf00) >> 7;
						  unsigned int immed = (given & 0xff);
	int a, i;
						  a = (((immed << (32 - rotate)) | (immed >> rotate)) & 0xffffffff);
						  for (i = 0; i < 32; i += 2) {
							  if ((a << i | a >> (32 - i)) <= 0xff) {
								  break;
							  }
						  }
						  if (i != rotate) {
							  func (stream, "%d, %d", immed, rotate);
						  } else {
							  func (stream, "%d", a);
						  }
						  value_in_comment = a;
					  } else {
						  arm_decode_shift (given, func, stream, TRUE);
					  }
					  break;
				  case 'p':
					  if ((given & 0x0000f000) == 0x0000f000) {
						  arm_feature_set arm_ext_v6 =
							  ARM_FEATURE_CORE_LOW (ARM_EXT_V6);
						  if (!ARM_CPU_HAS_FEATURE (private_data->features,
							      arm_ext_v6)) {
							  func (stream, "p");
						  } else {
							  is_unpredictable = TRUE;
						  }
					  }
					  break;
				  case 't':
					  if ((given & 0x01200000) == 0x00200000) {
						  func (stream, "t");
					  }
					  break;
				  case 'A': {
					  int offset = given & 0xff;
					  value_in_comment = offset * 4;
					  if (NEGATIVE_BIT_SET) {
						  value_in_comment = -value_in_comment;
					  }
					  func (stream, "[%s", arm_regnames[(given >> 16) & 0xf]);
					  if (PRE_BIT_SET) {
						  if (offset) {
							  func (stream, ", %d]%s",
								  (int)value_in_comment,
								  WRITEBACK_BIT_SET ? "!" : "");
						  } else {
							  func (stream, "]");
						  }
					  } else {
						  func (stream, "]");
						  if (WRITEBACK_BIT_SET) {
							  if (offset) {
								  func (stream, ", %d", (int)value_in_comment);
							  }
						  } else {
							  func (stream, ", {%d}", (int)offset);
							  value_in_comment = offset;
						  }
					  }
				  } break;
				  case 'B':
					  {
						  bfd_vma address;
						  bfd_vma offset = 0;
						  if (!NEGATIVE_BIT_SET) {
							  offset = (-1) ^ 0x00ffffff;
						  }
						  offset += given & 0x00ffffff;
						  offset <<= 2;
						  address = offset + pc + 8;
						  if (given & 0x01000000) {
							  address += 2;
						  }
						  info->print_address_func (address, info);
					  }
					  break;
				  case 'C':
					  if ((given & 0x02000200) == 0x200) {
						  const char *name;
						  unsigned sysm = (given & 0x004f0000) >> 16;
						  sysm |= (given & 0x300) >> 4;
						  name = banked_regname (sysm);
						  if (name) {
							  func (stream, "%s", name);
						  } else {
							  func (stream, "(UNDEF: %lu)", (unsigned int)sysm);
						  }
					  } else {
						  func (stream, "%cPSR_",
							  (given & 0x00400000) ? 'S' : 'C');
						  if (given & 0x80000) {
							  func (stream, "f");
						  }
						  if (given & 0x40000) {
							  func (stream, "s");
						  }
						  if (given & 0x20000) {
							  func (stream, "x");
						  }
						  if (given & 0x10000) {
							  func (stream, "c");
						  }
					  }
					  break;
				  case 'U':
					  if ((given & 0xf0) == 0x60) {
						  switch (given & 0xf) {
						  case 0xf: func (stream, "sy"); break;
						  default:
							  func (stream, "%d", (int)given & 0xf);
							  break;
						  }
					  } else {
						  const char *opt = data_barrier_option (given & 0xf);
						  if (opt) {
							  func (stream, "%s", opt);
						  } else {
							  func (stream, "%d", (int)given & 0xf);
						  }
					  }
					  break;
				  case '0':
				  case '1':
				  case '2':
				  case '3':
				  case '4':
				  case '5':
				  case '6':
				  case '7':
				  case '8':
				  case '9': {
					  int width;
					  unsigned int value;
					  c = arm_decode_bitfield (c, given, &value, &width);
					  switch (*c) {
					  case 'R':
						  if (value == 15) {
							  is_unpredictable = TRUE;
						  }
					  case 'r':
					  case 'T':
						  if (*c == 'T') {
							  ++value;
						  }
						  if (c[1] == 'u') {
							  ++c;
							  if (u_reg == value) {
								  is_unpredictable = TRUE;
							  }
							  u_reg = value;
						  }
						  if (c[1] == 'U') {
							  ++c;
							  if (U_reg == value) {
								  is_unpredictable = TRUE;
							  }
							  U_reg = value;
						  }
						  func (stream, "%s", value < 16? arm_regnames[value]: "?");
						  break;
					  case 'd':
						  func (stream, "%ld", value);
						  value_in_comment = value;
						  break;
					  case 'b':
						  func (stream, "%ld", value * 8);
						  value_in_comment = value * 8;
						  break;
					  case 'W':
						  func (stream, "%ld", value + 1);
						  value_in_comment = value + 1;
						  break;
					  case 'x':
						  func (stream, "0x%08lx", value);
						  if ((given & 0x0fffffff) == 0x0FF00000) {
							  func (stream, " ; IMB");
						  } else if ((given & 0x0fffffff) == 0x0FF00001) {
							  func (stream, " ; IMBRange");
						  }
						  break;
					  case 'X':
						  func (stream, "%01lx", value & 0xf);
						  value_in_comment = value;
						  break;
					  case '`':
						  c++;
						  if (value == 0) {
							  func (stream, "%c", *c);
						  }
						  break;
					  case '\'':
						  c++;
						  if (value == ((1ul << width) - 1)) {
							  func (stream, "%c", *c);
						  }
						  break;
					  case '?':
						  func (stream, "%c", c[(1 << width) - (int)value]);
						  c += 1 << width;
						  break;
					  default:
						  return;
					  }
					  break;
				  case 'e': {
					  int imm;
					  imm = (given & 0xf) | ((given & 0xfff00) >> 4);
					  func (stream, "%d", imm);
					  value_in_comment = imm;
				  } break;
				  case 'E':
					  {
						  int msb = (given & 0x001f0000) >> 16;
						  int lsb = (given & 0x00000f80) >> 7;
						  int w = msb - lsb + 1;
						  if (w > 0) {
							  func (stream, "%lu, %lu", lsb, w);
						  } else {
							  func (stream, "(invalid: %lu:%lu)", lsb, msb);
						  }
					  }
					  break;
				  case 'R':
					  {
						  const char *name;
						  unsigned sysm = (given & 0x004f0000) >> 16;
						  sysm |= (given & 0x300) >> 4;
						  name = banked_regname (sysm);
						  if (name) {
							  func (stream, "%s", name);
						  } else {
							  func (stream, "(UNDEF: %lu)", (unsigned int)sysm);
						  }
					  }
					  break;
				  case 'V':
					  {
						  int hi = (given & 0x000f0000) >> 4;
						  int lo = (given & 0x00000fff);
						  int imm16 = hi | lo;
						  func (stream, "%lu", imm16);
						  value_in_comment = imm16;
					  }
					  break;
				  }
				  }
			  } else {
				  func (stream, "%c", *c);
			  }
		  }
#if 0
	  if (value_in_comment > 32 || value_in_comment < -16)
	    func (stream, " ; 0x%lx", (value_in_comment & 0xffffffffUL));
#endif
		  if (is_unpredictable) {
			  func (stream, UNPREDICTABLE_INSTRUCTION);
		  }
		  return;
	}
    }
}
