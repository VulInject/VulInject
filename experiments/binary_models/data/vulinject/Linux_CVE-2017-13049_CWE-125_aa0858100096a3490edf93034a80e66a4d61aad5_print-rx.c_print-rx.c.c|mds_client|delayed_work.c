static void delayed_work(struct work_struct *work)
{
	struct ceph_mds_client *mdsc =
		container_of(work, struct ceph_mds_client, delayed_work.work);
	unsigned int delay;
	int renew_interval;
	int renew_caps;
	int i;
	doutc(mdsc->fsc->client, "mdsc delayed_work\n");
	if (mdsc->stopping >= CEPH_MDSC_STOPPING_FLUSHED)
		return;
	mutex_lock(&mdsc->mutex);
	renew_interval = mdsc->mdsmap->m_session_timeout >> 2;
	renew_caps = time_after_eq(jiffies, HZ*renew_interval +
				   mdsc->last_renew_caps);
	if (renew_caps)
		mdsc->last_renew_caps = jiffies;
	for (i = 0; i < mdsc->max_sessions; i++) {
		struct ceph_mds_session *s = __ceph_lookup_mds_session(mdsc, i);
		if (!s)
			continue;
		if (!check_session_state(s)) {
			continue;
		}
		mutex_unlock(&mdsc->mutex);
		mutex_lock(&s->s_mutex);
		if (renew_caps)
			send_renew_caps(mdsc, s);
		else
			ceph_con_keepalive(&s->s_con);
		if (s->s_state == CEPH_MDS_SESSION_OPEN ||
		    s->s_state == CEPH_MDS_SESSION_HUNG)
			ceph_send_cap_releases(mdsc, s);
		mutex_unlock(&s->s_mutex);
		ceph_put_mds_session(s);
		mutex_lock(&mdsc->mutex);
	}
	mutex_unlock(&mdsc->mutex);
	delay = ceph_check_delayed_caps(mdsc);
	ceph_queue_cap_reclaim_work(mdsc);
	ceph_trim_snapid_map(mdsc);
	maybe_recover_session(mdsc);
	schedule_delayed(mdsc, delay);
}
