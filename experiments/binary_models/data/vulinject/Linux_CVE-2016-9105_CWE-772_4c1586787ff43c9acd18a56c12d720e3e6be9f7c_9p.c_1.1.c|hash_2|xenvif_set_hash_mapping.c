unsigned int xenvif_set_hash_mapping(struct xenvif *vif, unsigned int gref, unsigned int len,
			    unsigned int off)
{
	unsigned int *mapping = vif->hash.mapping[!vif->hash.mapping_sel];
	unsigned int nr = 1;
	struct gnttab_copy copy_op[2] = {{
		.source.u.ref = gref,
		.source.domid = vif->domid,
		.dest.domid = DOMID_SELF,
		.len = len * sizeof(*mapping),
		.flags = GNTCOPY_source_gref
	}};
	if ((off + len < off) || (off + len > vif->hash.size) ||
	    len > XEN_PAGE_SIZE / sizeof(*mapping))
		return XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER;
	copy_op[0].dest.u.gmfn = virt_to_gfn(mapping + off);
	copy_op[0].dest.offset = xen_offset_in_page(mapping + off);
	if (copy_op[0].dest.offset + copy_op[0].len > XEN_PAGE_SIZE) {
		copy_op[1] = copy_op[0];
		copy_op[1].source.offset = XEN_PAGE_SIZE - copy_op[0].dest.offset;
		copy_op[1].dest.u.gmfn = virt_to_gfn(mapping + off + len);
		copy_op[1].dest.offset = 0;
		copy_op[1].len = copy_op[0].len - copy_op[1].source.offset;
		copy_op[0].len = copy_op[1].source.offset;
		nr = 2;
	}
	memcpy(mapping, vif->hash.mapping[vif->hash.mapping_sel],
	       vif->hash.size * sizeof(*mapping));
	if (copy_op[0].len != 0) {
		if (copy_op[0].status != GNTST_okay ||
		    copy_op[nr - 1].status != GNTST_okay)
			return XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER;
	}
	while (len-- != 0)
		if (mapping[off++] >= vif->num_queues)
			return XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER;
	vif->hash.mapping_sel = !vif->hash.mapping_sel;
	return XEN_NETIF_CTRL_STATUS_SUCCESS;
}
