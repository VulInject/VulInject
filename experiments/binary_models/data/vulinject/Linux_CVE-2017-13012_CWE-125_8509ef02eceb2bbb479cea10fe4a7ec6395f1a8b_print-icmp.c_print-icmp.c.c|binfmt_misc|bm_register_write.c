static ssize_t bm_register_write(struct file *file, const char __user *buffer,
			       size_t count, loff_t *ppos)
{
	Node *e;
	struct inode *inode;
	struct super_block *sb = file_inode(file)->i_sb;
	struct dentry *root = sb->s_root, *dentry;
	struct binfmt_misc *misc;
	int err = 0;
	struct file *f = NULL;
	e = create_entry(buffer, count);
	if (IS_ERR(e))
		return PTR_ERR(e);
	if (e->flags & MISC_FMT_OPEN_FILE) {
		const struct cred *old_cred;
		old_cred = override_creds(file->f_cred);
		f = open_exec(e->interpreter);
		revert_creds(old_cred);
		if (IS_ERR(f)) {
			pr_notice("register: failed to install interpreter file %s\n",
				 e->interpreter);
			kfree(e);
			return PTR_ERR(f);
		}
		e->interp_file = f;
	}
	inode_lock(d_inode(root));
	dentry = lookup_one_len(e->name, root, strlen(e->name));
	err = PTR_ERR(dentry);
	if (IS_ERR(dentry))
		goto out;
	err = -EEXIST;
	if (d_really_is_positive(dentry))
		goto out2;
	inode = bm_get_inode(sb, S_IFREG | 0644);
	err = -ENOMEM;
	if (!inode)
		goto out2;
	refcount_set(&e->users, 1);
	e->dentry = dget(dentry);
	inode->i_private = e;
	inode->i_fop = &bm_entry_operations;
	d_instantiate(dentry, inode);
	write_lock(&misc->entries_lock);
	list_add(&e->list, &misc->entries);
	write_unlock(&misc->entries_lock);
	err = 0;
out2:
	dput(dentry);
out:
	inode_unlock(d_inode(root));
	if (err) {
		if (f)
			filp_close(f, NULL);
		kfree(e);
		return err;
	}
	return count;
}
