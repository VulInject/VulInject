ospf6_decode_v3(netdissect_options *ndo,
                const struct ospf6hdr *op,
                const u_char *dataend)
{
	const rtrid_t *ap;
	const struct lsr6 *lsrp;
	const struct lsa6_hdr *lshp;
	const struct lsa6 *lsap;
	unsigned int i;
	switch (GET_U_1(op->ospf6_type)) {
	case OSPF_TYPE_HELLO: {
		const struct hello6 *hellop = (const struct hello6 *)((const unsigned char *)op + OSPF6HDR_LEN);
		ND_PRINT("\n\tOptions [%s]",
		          bittok2str(ospf6_option_values, "none",
		          GET_BE_U_4(hellop->hello_options)));
		ND_PRINT("\n\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u",
		          GET_BE_U_2(hellop->hello_helloint),
		          GET_BE_U_2(hellop->hello_deadint),
		          GET_IPADDR_STRING(hellop->hello_ifid),
		          GET_U_1(hellop->hello_priority));
		if (GET_BE_U_4(hellop->hello_dr) != 0)
			ND_PRINT("\n\t  Designated Router %s",
			    GET_IPADDR_STRING(hellop->hello_dr));
		if (GET_BE_U_4(hellop->hello_bdr) != 0)
			ND_PRINT(", Backup Designated Router %s",
			    GET_IPADDR_STRING(hellop->hello_bdr));
		if (ndo->ndo_vflag > 1) {
			ND_PRINT("\n\t  Neighbor List:");
			ap = hellop->hello_neighbor;
			while ((const u_char *)ap < dataend) {
				ND_PRINT("\n\t    %s", GET_IPADDR_STRING(ap));
				++ap;
			}
		}
		break;	
	}
	case OSPF_TYPE_DD: {
		const struct dd6 *ddp = (const struct dd6 *)((const unsigned char *)op + OSPF6HDR_LEN);
		ND_PRINT("\n\tOptions [%s]",
		          bittok2str(ospf6_option_values, "none",
		          GET_BE_U_4(ddp->db_options)));
		ND_PRINT(", DD Flags [%s]",
		          bittok2str(ospf6_dd_flag_values,"none",GET_U_1(ddp->db_flags)));
		ND_PRINT(", MTU %u, DD-Sequence 0x%08x",
                       GET_BE_U_2(ddp->db_mtu),
                       GET_BE_U_4(ddp->db_seq));
		if (ndo->ndo_vflag > 1) {
			lshp = ddp->db_lshdr;
			while ((const u_char *)lshp < dataend) {
				if (ospf6_print_lshdr(ndo, lshp++, dataend))
					goto trunc;
			}
		}
		break;
	}
	case OSPF_TYPE_LS_REQ:
		if (ndo->ndo_vflag > 1) {
			lsrp = (const struct lsr6 *)((const unsigned char *)op + OSPF6HDR_LEN);
			while ((const u_char *)lsrp < dataend) {
				ND_PRINT("\n\t  Advertising Router %s",
				          GET_IPADDR_STRING(lsrp->ls_router));
				ospf6_print_ls_type(ndo,
                                                    GET_BE_U_2(lsrp->ls_type),
                                                    &lsrp->ls_stateid);
				++lsrp;
			}
		}
		break;
	case OSPF_TYPE_LS_UPDATE:
		if (ndo->ndo_vflag > 1) {
			const struct lsu6 *lsup = (const struct lsu6 *)((const unsigned char *)op + OSPF6HDR_LEN);
			i = GET_BE_U_4(lsup->lsu_count);
			lsap = lsup->lsu_lsa;
			while ((const u_char *)lsap < dataend && i--) {
				if (ospf6_print_lsa(ndo, lsap, dataend))
					goto trunc;
				lsap = (const struct lsa6 *)((const u_char *)lsap +
				    GET_BE_U_2(lsap->ls_hdr.ls_length));
			}
		}
		break;
	case OSPF_TYPE_LS_ACK:
		if (ndo->ndo_vflag > 1) {
			lshp = (const struct lsa6_hdr *)((const unsigned char *)op + OSPF6HDR_LEN);
			while ((const u_char *)lshp < dataend) {
				if (ospf6_print_lshdr(ndo, lshp++, dataend))
					goto trunc;
			}
		}
		break;
	default:
		break;
	}
	return (0);
trunc:
	return (1);
}
