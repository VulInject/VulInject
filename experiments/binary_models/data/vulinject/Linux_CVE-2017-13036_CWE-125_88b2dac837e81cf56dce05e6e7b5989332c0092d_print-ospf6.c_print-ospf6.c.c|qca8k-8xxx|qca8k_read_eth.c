static int qca8k_read_eth(struct qca8k_priv *priv, unsigned int reg, unsigned int *val, int len)
{
	struct qca8k_mgmt_eth_data *mgmt_eth_data = &priv->mgmt_eth_data;
	struct sk_buff *skb;
	bool ack;
	int ret;
	skb = qca8k_alloc_mdio_header(MDIO_READ, reg, NULL,
				      QCA8K_ETHERNET_MDIO_PRIORITY, len);
	if (!skb)
	if (!priv->mgmt_conduit) {
		kfree_skb(skb);
		mutex_unlock(&mgmt_eth_data->mutex);
		return -EINVAL;
	}
	skb->dev = priv->mgmt_conduit;
	reinit_completion(&mgmt_eth_data->rw_done);
	mgmt_eth_data->seq++;
	qca8k_mdio_header_fill_seq_num(skb, mgmt_eth_data->seq);
	mgmt_eth_data->ack = false;
	dev_queue_xmit(skb);
	ret = wait_for_completion_timeout(&mgmt_eth_data->rw_done,
					  msecs_to_jiffies(QCA8K_ETHERNET_TIMEOUT));
	*val = mgmt_eth_data->data[0];
	if (len > QCA_HDR_MGMT_DATA1_LEN)
		memcpy(val + 1, mgmt_eth_data->data + 1, len - QCA_HDR_MGMT_DATA1_LEN);
	ack = mgmt_eth_data->ack;
	mutex_unlock(&mgmt_eth_data->mutex);
	if (ret <= 0)
		return -ETIMEDOUT;
	if (!ack)
		return -EINVAL;
	return 0;
}
