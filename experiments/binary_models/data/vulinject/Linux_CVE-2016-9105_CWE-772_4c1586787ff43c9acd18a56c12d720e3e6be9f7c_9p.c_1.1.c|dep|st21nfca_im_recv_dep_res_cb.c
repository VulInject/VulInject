static void st21nfca_im_recv_dep_res_cb(void *context, struct sk_buff *skb,
					int err)
{
	struct st21nfca_hci_info *info = context;
	struct st21nfca_dep_req_res *dep_res;
	int size;
	if (err != 0)
		return;
	if (!skb)
		return;
	switch (info->async_cb_type) {
	case ST21NFCA_CB_TYPE_READER_F:
		dep_res = (struct st21nfca_dep_req_res *)skb->data;
		size = 3;
		if (skb->len < size)
			goto exit;
		if (ST21NFCA_NFC_DEP_DID_BIT_SET(dep_res->pfb))
			size++;
		if (ST21NFCA_NFC_DEP_NAD_BIT_SET(dep_res->pfb))
			size++;
		if (skb->len < size)
			goto exit;
		skb_trim(skb, skb->len - 1);
		switch (ST21NFCA_NFC_DEP_PFB_TYPE(dep_res->pfb)) {
		case ST21NFCA_NFC_DEP_PFB_ACK_NACK_PDU:
			pr_err("Received a ACK/NACK PDU\n");
			fallthrough;
		case ST21NFCA_NFC_DEP_PFB_I_PDU:
			info->dep_info.curr_nfc_dep_pni =
			    ST21NFCA_NFC_DEP_PFB_PNI(dep_res->pfb + 1);
			size++;
			nfc_tm_data_received(info->hdev->ndev, skb);
			break;
		case ST21NFCA_NFC_DEP_PFB_SUPERVISOR_PDU:
			pr_err("Received a SUPERVISOR PDU\n");
			skb_pull(skb, size);
			*(unsigned char *)skb_push(skb, 1) = ST21NFCA_NFCIP1_DEP_REQ;
			*(unsigned char *)skb_push(skb, 1) = ST21NFCA_NFCIP1_REQ;
			*(unsigned char *)skb_push(skb, 1) = skb->len;
			*(unsigned char *)skb_push(skb, 1) = info->dep_info.to | 0x10;
			st21nfca_im_send_pdu(info, skb);
			break;
		}
		return;
	default:
		break;
	}
exit:
	kfree_skb(skb);
}
