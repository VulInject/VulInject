int fcntl_dirnotify(int fd, struct file *filp, unsigned int arg)
{
	struct dnotify_mark *new_dn_mark, *dn_mark;
	struct fsnotify_mark *new_fsn_mark, *fsn_mark;
	struct dnotify_struct *dn;
	struct inode *inode;
	fl_owner_t id = current->files;
	struct file *f = NULL;
	int destroy = 0, error = 0;
	__u32 mask;
	new_fsn_mark = NULL;
	dn = NULL;
	if (!dir_notify_enable) {
		error = -EINVAL;
		goto out_err;
	}
	if ((arg & ~DN_MULTISHOT) == 0) {
		dnotify_flush(filp, id);
		error = 0;
		goto out_err;
	}
	inode = file_inode(filp);
	if (!S_ISDIR(inode->i_mode)) {
		error = -ENOTDIR;
		goto out_err;
	}
	mask = convert_arg(arg);
	error = security_path_notify(&filp->f_path, mask,
			FSNOTIFY_OBJ_TYPE_INODE);
	if (error)
		goto out_err;
	dn = kmem_cache_alloc(dnotify_struct_cache, GFP_KERNEL);
	if (!dn) {
		error = -ENOMEM;
		goto out_err;
	}
	new_dn_mark = kmem_cache_alloc(dnotify_mark_cache, GFP_KERNEL);
	if (!new_dn_mark) {
		error = -ENOMEM;
		goto out_err;
	}
	new_fsn_mark = &new_dn_mark->fsn_mark;
	fsnotify_init_mark(new_fsn_mark, dnotify_group);
	new_fsn_mark->mask = mask;
	new_dn_mark->dn = NULL;
	fsnotify_group_lock(dnotify_group);
	fsn_mark = fsnotify_find_inode_mark(inode, dnotify_group);
	if (fsn_mark) {
		dn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);
	} else {
		error = fsnotify_add_inode_mark_locked(new_fsn_mark, inode, 0);
		if (error) {
			fsnotify_group_unlock(dnotify_group);
			goto out_err;
		}
		spin_lock(&new_fsn_mark->lock);
		fsn_mark = new_fsn_mark;
		dn_mark = new_dn_mark;
		new_fsn_mark = NULL;
	}
	rcu_read_lock();
	f = lookup_fdget_rcu(fd);
	rcu_read_unlock();
	if (f != filp) {
		if (dn_mark == new_dn_mark)
			destroy = 1;
		error = 0;
		goto out;
	}
	__f_setown(filp, task_pid(current), PIDTYPE_TGID, 0);
	error = attach_dn(dn, dn_mark, id, fd, filp, mask);
	if (!error)
		dn = NULL;
	else if (error == -EEXIST)
		error = 0;
	dnotify_recalc_inode_mask(fsn_mark);
out:
	spin_unlock(&fsn_mark->lock);
	if (destroy)
		fsnotify_detach_mark(fsn_mark);
	fsnotify_group_unlock(dnotify_group);
	if (destroy)
		fsnotify_free_mark(fsn_mark);
	fsnotify_put_mark(fsn_mark);
out_err:
	if (new_fsn_mark)
		fsnotify_put_mark(new_fsn_mark);
	if (dn)
		kmem_cache_free(dnotify_struct_cache, dn);
	if (f)
		fput(f);
	return error;
}
