fore200e_push_rpd(struct fore200e* fore200e, struct atm_vcc* vcc, struct rpd* rpd)
{
    struct sk_buff*      skb;
    struct buffer*       buffer;
    struct fore200e_vcc* fore200e_vcc;
    int                  i, pdu_len = 0;
#ifdef FORE200E_52BYTE_AAL0_SDU
    unsigned int                  cell_header = 0;
#endif
    fore200e_vcc = FORE200E_VCC(vcc);
    ASSERT(fore200e_vcc);
#ifdef FORE200E_52BYTE_AAL0_SDU
    if ((vcc->qos.aal == ATM_AAL0) && (vcc->qos.rxtp.max_sdu == ATM_AAL0_SDU)) {
	cell_header = (rpd->atm_header.gfc << ATM_HDR_GFC_SHIFT) |
	              (rpd->atm_header.vpi << ATM_HDR_VPI_SHIFT) |
                      (rpd->atm_header.vci << ATM_HDR_VCI_SHIFT) |
                      (rpd->atm_header.plt << ATM_HDR_PTI_SHIFT) | 
                       rpd->atm_header.clp;
	pdu_len = 4;
    }
#endif
    for (i = 0; i < rpd->nseg; i++)
	pdu_len += rpd->rsd[ i ].length;
    skb = alloc_skb(pdu_len, GFP_ATOMIC);
    if (skb == NULL) {
	DPRINTK(2, "unable to alloc new skb, rx PDU length = %d\n", pdu_len);
	atomic_inc(&vcc->stats->rx_drop);
	return -ENOMEM;
    } 
    __net_timestamp(skb);
#ifdef FORE200E_52BYTE_AAL0_SDU
    if (cell_header) {
	*((unsigned int*)skb_put(skb, 4)) = cell_header;
    }
#endif
    for (i = 0; i < rpd->nseg; i++) {
	buffer = FORE200E_HDL2BUF(rpd->rsd[ i ].handle);
	dma_sync_single_for_cpu(fore200e->dev, buffer->data.dma_addr,
				rpd->rsd[i].length, DMA_FROM_DEVICE);
	skb_put_data(skb, buffer->data.align_addr, rpd->rsd[i].length);
	dma_sync_single_for_device(fore200e->dev, buffer->data.dma_addr,
				   rpd->rsd[i].length, DMA_FROM_DEVICE);
    }
    DPRINTK(3, "rx skb: len = %d, truesize = %d\n", skb->len, skb->truesize);
    if (pdu_len < fore200e_vcc->rx_min_pdu)
	fore200e_vcc->rx_min_pdu = pdu_len;
    if (pdu_len > fore200e_vcc->rx_max_pdu)
	fore200e_vcc->rx_max_pdu = pdu_len;
    fore200e_vcc->rx_pdu++;
    if (atm_charge(vcc, skb->truesize) == 0) {
	DPRINTK(2, "receive buffers saturated for %d.%d.%d - PDU dropped\n",
		vcc->itf, vcc->vpi, vcc->vci);
	dev_kfree_skb_any(skb);
	atomic_inc(&vcc->stats->rx_drop);
	return -ENOMEM;
    }
    vcc->push(vcc, skb);
    atomic_inc(&vcc->stats->rx);
    return 0;
}
