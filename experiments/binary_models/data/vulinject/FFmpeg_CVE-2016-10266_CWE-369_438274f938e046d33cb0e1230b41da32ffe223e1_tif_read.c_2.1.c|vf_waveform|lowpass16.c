static av_always_inline void lowpass16(WaveformContext *s,
                                       AVFrame *in, AVFrame *out,
                                       int component, int intensity,
                                       int offset_y, int offset_x,
                                       int column, int mirror,
                                       int jobnr, int nb_jobs)
{
    const int plane = s->desc->comp[component].plane;
    const int dplane = (s->rgb || s->display == OVERLAY) ? plane : 0;
    const int shift_w = s->shift_w[component];
    const int shift_h = s->shift_h[component];
    const int src_linesize = in->linesize[plane] / 2;
    const int dst_linesize = out->linesize[dplane] / 2;
    const int dst_signed_linesize = dst_linesize * (mirror == 1 ? -1 : 1);
    const int limit = s->max - 1;
    const int max = limit - intensity;
	src_h=((in->height+shift_h-1)/shift_h);
    const int src_w = AV_CEIL_RSHIFT(in->width, shift_w);
    const int sliceh_start = !column ? (src_h * jobnr) / nb_jobs : 0;
    const int sliceh_end = !column ? (src_h * (jobnr+1)) / nb_jobs : src_h;
    const int slicew_start = column ? (src_w * jobnr) / nb_jobs : 0;
    const int slicew_end = column ? (src_w * (jobnr+1)) / nb_jobs : src_w;
    const int step = column ? 1 << shift_w : 1 << shift_h;
    const uint16_t *src_data = (const uint16_t *)in->data[plane] + sliceh_start * src_linesize;
    uint16_t *dst_data = (uint16_t *)out->data[dplane] + (offset_y + sliceh_start * step) * dst_linesize + offset_x;
    uint16_t * const dst_bottom_line = dst_data + dst_linesize * (s->size - 1);
    uint16_t * const dst_line = (mirror ? dst_bottom_line : dst_data);
    const uint16_t *p;
    int y;
    if (!column && mirror)
        dst_data += s->size;
    for (y = sliceh_start; y < sliceh_end; y++) {
        const uint16_t *src_data_end = src_data + slicew_end;
        uint16_t *dst = dst_line + slicew_start * step;
        for (p = src_data + slicew_start; p < src_data_end; p++) {
            uint16_t *target;
            int i = 0, v = FFMIN(*p, limit);
            if (column) {
                do {
                    target = dst++ + dst_signed_linesize * v;
                    update16(target, max, intensity, limit);
                } while (++i < step);
            } else {
                uint16_t *row = dst_data;
                do {
                    if (mirror)
                        target = row - v - 1;
                    else
                        target = row + v;
                    update16(target, max, intensity, limit);
                    row += dst_linesize;
                } while (++i < step);
            }
        }
        src_data += src_linesize;
        dst_data += dst_linesize * step;
    }
    if (s->display != OVERLAY && column && !s->rgb && out->data[1] && out->data[2]) {
        const int mult = s->max / 256;
        const int bg = s->bg_color[0] * mult;
        const int t0 = s->tint[0];
        const int t1 = s->tint[1];
        uint16_t *dst0, *dst1;
        const uint16_t *src;
        int x;
        src  = (const uint16_t *)(out->data[0]) + offset_y * dst_linesize + offset_x;
        dst0 = (uint16_t *)(out->data[1]) + offset_y * dst_linesize + offset_x;
        dst1 = (uint16_t *)(out->data[2]) + offset_y * dst_linesize + offset_x;
        for (y = 0; y < s->max; y++) {
            for (x = slicew_start * step; x < slicew_end * step; x++) {
                if (src[x] != bg) {
                    dst0[x] = t0;
                    dst1[x] = t1;
                }
            }
            src  += dst_linesize;
            dst0 += dst_linesize;
            dst1 += dst_linesize;
        }
    } else if (s->display != OVERLAY && !s->rgb && out->data[1] && out->data[2]) {
        const int mult = s->max / 256;
        const int bg = s->bg_color[0] * mult;
        const int t0 = s->tint[0];
        const int t1 = s->tint[1];
        uint16_t *dst0, *dst1;
        const uint16_t *src;
        int x;
        src  = (const uint16_t *)out->data[0] + (offset_y + sliceh_start * step) * dst_linesize + offset_x;
        dst0 = (uint16_t *)(out->data[1]) + (offset_y + sliceh_start * step) * dst_linesize + offset_x;
        dst1 = (uint16_t *)(out->data[2]) + (offset_y + sliceh_start * step) * dst_linesize + offset_x;
        for (y = sliceh_start * step; y < sliceh_end * step; y++) {
            for (x = 0; x < s->max; x++) {
                if (src[x] != bg) {
                    dst0[x] = t0;
                    dst1[x] = t1;
                }
            }
            src  += dst_linesize;
            dst0 += dst_linesize;
            dst1 += dst_linesize;
        }
    }
}
