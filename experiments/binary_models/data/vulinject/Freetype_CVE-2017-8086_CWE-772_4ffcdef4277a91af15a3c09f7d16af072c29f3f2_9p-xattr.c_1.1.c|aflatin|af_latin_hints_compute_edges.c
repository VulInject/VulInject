  af_latin_hints_compute_edges( AF_GlyphHints  hints,
                                AF_Dimension   dim )
  {
    AF_AxisHints  axis   = &hints->axis[dim];
    FT_Error      error  = FT_Err_Ok;
    FT_Memory     memory = hints->memory;
    AF_LatinAxis  laxis  = &((AF_LatinMetrics)hints->metrics)->axis[dim];
    AF_StyleClass   style_class  = hints->metrics->style_class;
    AF_ScriptClass  script_class = af_script_classes[style_class->script];
    FT_Bool  top_to_bottom_hinting = 0;
    AF_Segment    segments      = axis->segments;
    AF_Segment    segment_limit = FT_OFFSET( segments, axis->num_segments );
    AF_Segment    seg;
#if 0
    AF_Direction  up_dir;
#endif
    FT_Fixed      scale;
    FT_Pos        edge_distance_threshold;
    FT_Pos        segment_length_threshold;
    FT_Pos        segment_width_threshold;
    axis->num_edges = 0;
    scale = ( dim == AF_DIMENSION_HORZ ) ? hints->x_scale
                                         : hints->y_scale;
#if 0
    up_dir = ( dim == AF_DIMENSION_HORZ ) ? AF_DIR_UP
                                          : AF_DIR_RIGHT;
#endif
    if ( dim == AF_DIMENSION_VERT )
      top_to_bottom_hinting = script_class->top_to_bottom_hinting;
    if ( dim == AF_DIMENSION_HORZ )
      segment_length_threshold = FT_DivFix( 64, hints->y_scale );
    else
      segment_length_threshold = 0;
    segment_width_threshold = FT_DivFix( 32, scale );
    edge_distance_threshold = FT_MulFix( laxis->edge_distance_threshold,
                                         scale );
    if ( edge_distance_threshold > 64 / 4 )
      edge_distance_threshold = 64 / 4;
    edge_distance_threshold = FT_DivFix( edge_distance_threshold,
                                         scale );
    for ( seg = segments; seg < segment_limit; seg++ )
    {
      AF_Edge  found = NULL;
      FT_UInt  ee;
      if ( seg->height < segment_length_threshold ||
           seg->delta > segment_width_threshold   ||
           seg->dir == AF_DIR_NONE                )
        continue;
      if ( seg->serif                                     &&
           2 * seg->height < 3 * segment_length_threshold )
        continue;
      for ( ee = 0; ee < axis->num_edges; ee++ )
      {
        AF_Edge  edge = axis->edges + ee;
        FT_Pos   dist;
        dist = seg->pos - edge->fpos;
        if ( dist < 0 )
          dist = -dist;
        if ( dist < edge_distance_threshold && edge->dir == seg->dir )
        {
          found = edge;
          break;
        }
      }
      if ( !found )
      {
        AF_Edge  edge;
        error = af_axis_hints_new_edge( axis, seg->pos,
                                        (AF_Direction)seg->dir,
                                        top_to_bottom_hinting,
                                        memory, &edge );
        if ( error )
          goto Exit;
        edge->first    = seg;
        edge->last     = seg;
        edge->dir      = seg->dir;
        edge->fpos     = seg->pos;
        edge->opos     = FT_MulFix( seg->pos, scale );
        edge->pos      = edge->opos;
        seg->edge_next = seg;
      }
      else
      {
        seg->edge_next         = found->first;
        found->last->edge_next = seg;
        found->last            = seg;
      }
    }
    for ( seg = segments; seg < segment_limit; seg++ )
    {
      AF_Edge  found = NULL;
      FT_UInt  ee;
      if ( seg->dir != AF_DIR_NONE )
        continue;
      for ( ee = 0; ee < axis->num_edges; ee++ )
      {
        AF_Edge  edge = axis->edges + ee;
        FT_Pos   dist;
        dist = seg->pos - edge->fpos;
        if ( dist < 0 )
          dist = -dist;
        if ( dist < edge_distance_threshold )
        {
          found = edge;
          break;
        }
      }
      if ( found )
      {
        seg->edge_next         = found->first;
        found->last->edge_next = seg;
        found->last            = seg;
      }
    }
    {
      AF_Edge  edges      = axis->edges;
      AF_Edge  edge_limit = FT_OFFSET( edges, axis->num_edges );
      AF_Edge  edge;
      for ( edge = edges; edge < edge_limit; edge++ )
      {
        seg = edge->first;
        if ( seg )
          do
          {
            seg->edge = edge;
            seg       = seg->edge_next;
          } while ( seg != edge->first );
      }
      for ( edge = edges; edge < edge_limit; edge++ )
      {
        FT_Int  is_round    = 0;  
        FT_Int  is_straight = 0;  
#if 0
        FT_Pos  ups         = 0;  
        FT_Pos  downs       = 0;  
#endif
        seg = edge->first;
        do
        {
          FT_Bool  is_serif;
          if ( seg->flags & AF_EDGE_ROUND )
            is_round++;
          else
            is_straight++;
#if 0
          if ( seg->dir == up_dir )
            ups   += seg->max_coord - seg->min_coord;
          else
            downs += seg->max_coord - seg->min_coord;
#endif
          is_serif = FT_BOOL( seg->serif               &&
                              seg->serif->edge         &&
                              seg->serif->edge != edge );
          if ( ( seg->link && seg->link->edge ) || is_serif )
          {
            AF_Edge     edge2;
            AF_Segment  seg2;
            edge2 = edge->link;
            seg2  = seg->link;
            if ( is_serif )
            {
              seg2  = seg->serif;
              edge2 = edge->serif;
            }
            if ( edge2 )
            {
              FT_Pos  edge_delta;
              FT_Pos  seg_delta;
              edge_delta = edge->fpos - edge2->fpos;
              if ( edge_delta < 0 )
                edge_delta = -edge_delta;
              seg_delta = seg->pos - seg2->pos;
              if ( seg_delta < 0 )
                seg_delta = -seg_delta;
              if ( seg_delta < edge_delta )
                edge2 = seg2->edge;
            }
            else
              edge2 = seg2->edge;
            if ( is_serif )
            {
              edge->serif   = edge2;
              edge2->flags |= AF_EDGE_SERIF;
            }
            else
              edge->link  = edge2;
          }
          seg = seg->edge_next;
        } while ( seg != edge->first );
        edge->flags = AF_EDGE_NORMAL;
        if ( is_round > 0 && is_round >= is_straight )
          edge->flags |= AF_EDGE_ROUND;
#if 0
        edge->dir = AF_DIR_NONE;
        if ( ups > downs )
          edge->dir = (FT_Char)up_dir;
        else if ( ups < downs )
          edge->dir = (FT_Char)-up_dir;
        else if ( ups == downs )
          edge->dir = 0;  
#endif
        if ( edge->serif && edge->link )
          edge->serif = NULL;
      }
    }
  Exit:
    return error;
  }
