static int handle_input(AVFilterContext *ctx, LibplaceboInput *input)
{
    int ret, status;
    LibplaceboContext *s = ctx->priv;
    AVFilterLink *outlink = ctx->outputs[0];
    AVFrame *in;
    int64_t pts;
    while ((ret = ff_inlink_consume_frame(input->link, &in)) > 0) {
        in->opaque = s;
        pl_queue_push(input->queue, &(struct pl_source_frame) {
            .pts         = in->pts * av_q2d(input->link->time_base),
            .duration    = in->duration * av_q2d(input->link->time_base),
            .first_field = pl_field_from_avframe(in),
            .frame_data  = in,
            .map         = map_frame,
            .unmap       = unmap_frame,
            .discard     = discard_frame,
        });
        if (!s->fps.num) {
            /* Internally queue an output frame for the same PTS */
            pts = av_rescale_q(in->pts, input->link->time_base, outlink->time_base);
            av_fifo_write(input->out_pts, &pts, 1);
        }
    }
    if (ret < 0)
        return ret;
    if (!input->status && ff_inlink_acknowledge_status(input->link, &status, &pts)) {
        pts = av_rescale_q_rnd(pts, input->link->time_base, outlink->time_base,
                               AV_ROUND_UP);
        input->status = status;
        input->status_pts = pts;
        if (!s->status || pts >= s->status_pts) {
            /* Also propagate to output unless overwritten by later status change */
            s->status = status;
            s->status_pts = pts;
        }
    }
    return 0;
}
