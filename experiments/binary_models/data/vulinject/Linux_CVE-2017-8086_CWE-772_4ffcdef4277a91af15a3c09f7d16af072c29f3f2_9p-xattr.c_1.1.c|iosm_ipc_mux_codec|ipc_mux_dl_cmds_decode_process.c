static int ipc_mux_dl_cmds_decode_process(struct iosm_mux *ipc_mux,
					  union mux_cmd_param *param,
					  __le32 command_type, unsigned char if_id,
					  __le16 cmd_len, int size)
{
	struct mux_session *session;
	struct hrtimer *adb_timer;
	dev_dbg(ipc_mux->dev, "if_id[%d]: dlcmds decode process %d",
		if_id, le32_to_cpu(command_type));
	switch (le32_to_cpu(command_type)) {
	case MUX_LITE_CMD_FLOW_CTL:
	case IOSM_AGGR_MUX_CMD_FLOW_CTL_DISABLE:
		if (if_id >= IPC_MEM_MUX_IP_SESSION_ENTRIES) {
			dev_err(ipc_mux->dev, "if_id [%d] not valid",
				if_id);
			return -EINVAL; 
		}
		session = &ipc_mux->session[if_id];
		adb_timer = &ipc_mux->imem->adb_timer;
		if (param->flow_ctl.mask == cpu_to_le32(0xFFFFFFFF)) {
			if (cmd_len == cpu_to_le16(size))
				session->flow_ctl_mask =
					le32_to_cpu(param->flow_ctl.mask);
			else
				session->flow_ctl_mask = ~0;
			session->net_tx_stop = true;
			if (ipc_mux->protocol == MUX_AGGREGATION) {
				ipc_imem_hrtimer_stop(adb_timer);
			}
			session->flow_ctl_en_cnt++;
		} else if (param->flow_ctl.mask == 0) {
			dev_dbg(ipc_mux->dev, "if_id[%u] flow_ctl mask 0x%08X",
				if_id, le32_to_cpu(param->flow_ctl.mask));
			if (cmd_len == cpu_to_le16(size))
				session->flow_ctl_mask =
					le32_to_cpu(param->flow_ctl.mask);
			else
				session->flow_ctl_mask = 0;
			session->flow_ctl_dis_cnt++;
		} else {
			break;
		}
		ipc_mux->acc_adb_size = 0;
		ipc_mux->acc_payload_size = 0;
		dev_dbg(ipc_mux->dev, "if_id[%u] FLOW CTRL 0x%08X", if_id,
			le32_to_cpu(param->flow_ctl.mask));
		break;
	case MUX_LITE_CMD_LINK_STATUS_REPORT:
		break;
	default:
		return -EINVAL;
	}
	return 0;
}
