create_ntlmssp_v1_key(const guint8 *serverchallenge, const guint8 *clientchallenge,
                      guint8 *sessionkey, const  guint8 *encryptedsessionkey, int flags,
                      const guint8 *ref_nt_challenge_response, const guint8 *ref_lm_challenge_response,
                      ntlmssp_header_t *ntlmssph,
                      packet_info *pinfo, proto_tree *ntlmssp_tree)
{
  const char       *password = ntlmssp_option_nt_password;
  unsigned char     lm_password_upper[NTLMSSP_KEY_LEN];
  unsigned char     lm_hash[NTLMSSP_KEY_LEN];
  unsigned char     nt_hash[NTLMSSP_KEY_LEN];
  unsigned char     challenges_hash_first8[8];
  unsigned char     challenges[NTLMSSP_KEY_LEN];
  guint8            md4[NTLMSSP_KEY_LEN];
  guint8            nb_pass   = 0;
  guint8            sessionbasekey[NTLMSSP_KEY_LEN];
  guint8            keyexchangekey[NTLMSSP_KEY_LEN];
  guint8            lm_challenge_response[24];
  guint8            nt_challenge_response[24];
  gcry_cipher_hd_t  rc4_handle;
  gcry_md_hd_t      md5_handle;
  char              password_unicode[256];
  size_t            password_len;
  unsigned int      i;
  gboolean          found     = FALSE;
  md4_pass         *pass_list = NULL;
  const md4_pass   *used_md4  = NULL;
  static const bool NoLMResponseNTLMv1 = TRUE;
  static const unsigned char lmhash_key[] =
    {0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25}; 
  memset(sessionkey, 0, NTLMSSP_KEY_LEN);
  password_len = strlen(password);
  gcry_md_hash_buffer(GCRY_MD_MD4, nt_hash, password_unicode, password_len*2);
  if ((flags & NTLMSSP_NEGOTIATE_LM_KEY && !(flags & NoLMResponseNTLMv1)) || !(flags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY)  || !(flags & NTLMSSP_NEGOTIATE_NTLM)) {
    if (password_len > NTLMSSP_KEY_LEN)
      password_len = NTLMSSP_KEY_LEN;
    memset(lm_password_upper, 0, sizeof(lm_password_upper));
    for (i = 0; i < password_len; i++) {
      lm_password_upper[i] = g_ascii_toupper(password[i]);
    }
    crypt_des_ecb(lm_hash, lmhash_key, lm_password_upper);
    crypt_des_ecb(lm_hash+8, lmhash_key, lm_password_upper+7);
    ntlmssp_generate_challenge_response(lm_challenge_response,
                                        lm_hash, serverchallenge);
    memcpy(sessionbasekey, lm_hash, NTLMSSP_KEY_LEN);
  }
  else {
    memset(lm_challenge_response, 0, 24);
    if (flags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY) {
      nb_pass = get_md4pass_list(pinfo->pool, &pass_list);
      i = 0;
      while (i < nb_pass) {
        used_md4 = &pass_list[i];
        memcpy(nt_hash, pass_list[i].md4, NTLMSSP_KEY_LEN);
        i++;
        if(clientchallenge){
          memcpy(lm_challenge_response, clientchallenge, 8);
        }
        if (gcry_md_open(&md5_handle, GCRY_MD_MD5, 0)) {
                break;
        }
        gcry_md_write(md5_handle, serverchallenge, 8);
        gcry_md_write(md5_handle, clientchallenge, 8);
        memcpy(challenges_hash_first8, gcry_md_read(md5_handle, 0), 8);
        gcry_md_close(md5_handle);
        crypt_des_ecb_long(nt_challenge_response, nt_hash, challenges_hash_first8);
        if (ref_nt_challenge_response && !memcmp(ref_nt_challenge_response, nt_challenge_response, 24)) {
          found = TRUE;
          break;
        }
      }
    }
    else {
      crypt_des_ecb_long(nt_challenge_response, nt_hash, serverchallenge);
      if (NoLMResponseNTLMv1) {
        memcpy(lm_challenge_response, nt_challenge_response, 24);
      }
      else {
        crypt_des_ecb_long(lm_challenge_response, lm_hash, serverchallenge);
      }
      if (ref_nt_challenge_response &&
          !memcmp(ref_nt_challenge_response, nt_challenge_response, 24) &&
          ref_lm_challenge_response &&
          !memcmp(ref_lm_challenge_response, lm_challenge_response, 24))
      {
          found = TRUE;
      }
    }
    gcry_md_hash_buffer(GCRY_MD_MD4, md4, nt_hash, NTLMSSP_KEY_LEN);
    if (flags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY) {
      memcpy(challenges, serverchallenge, 8);
      if(clientchallenge){
        memcpy(challenges+8, clientchallenge, 8);
      }
      if (ws_hmac_buffer(GCRY_MD_MD5, sessionbasekey, challenges, NTLMSSP_KEY_LEN, md4, NTLMSSP_KEY_LEN)) {
        return;
      }
    }
    else {
     memcpy(sessionbasekey, md4, NTLMSSP_KEY_LEN);
    }
  }
  if (!found) {
    return;
  }
  get_keyexchange_key(keyexchangekey, sessionbasekey, lm_challenge_response, flags);
  if (flags & NTLMSSP_NEGOTIATE_KEY_EXCH)
  {
    if(encryptedsessionkey){
      memcpy(sessionkey, encryptedsessionkey, NTLMSSP_KEY_LEN);
    }
    if (!gcry_cipher_open(&rc4_handle, GCRY_CIPHER_ARCFOUR, GCRY_CIPHER_MODE_STREAM, 0)) {
      if (!gcry_cipher_setkey(rc4_handle, keyexchangekey, NTLMSSP_KEY_LEN)) {
        gcry_cipher_decrypt(rc4_handle, sessionkey, NTLMSSP_KEY_LEN, NULL, 0);
      }
      gcry_cipher_close(rc4_handle);
    }
  }
  else
  {
    memcpy(sessionkey, keyexchangekey, NTLMSSP_KEY_LEN);
  }
  memcpy(ntlmssph->session_key, sessionkey, NTLMSSP_KEY_LEN);
  if (used_md4 == NULL) {
    return;
  }
  expert_add_info_format(pinfo, proto_tree_get_parent(ntlmssp_tree),
                         &ei_ntlmssp_auth_nthash,
                         "NTLMv1 authenticated using %s (%02x%02x%02x%02x...)",
                         used_md4->key_origin,
                         used_md4->md4[0] & 0xFF, used_md4->md4[1] & 0xFF,
                         used_md4->md4[2] & 0xFF, used_md4->md4[3] & 0xFF);
  expert_add_info_format(pinfo, proto_tree_get_parent(ntlmssp_tree),
                         &ei_ntlmssp_sessionbasekey,
                         "NTLMv1 BaseSessionKey ("
                         "%02x%02x%02x%02x"
                         "%02x%02x%02x%02x"
                         "%02x%02x%02x%02x"
                         "%02x%02x%02x%02x"
                         ")",
                         sessionbasekey[0] & 0xFF,  sessionbasekey[1] & 0xFF,
                         sessionbasekey[2] & 0xFF,  sessionbasekey[3] & 0xFF,
                         sessionbasekey[4] & 0xFF,  sessionbasekey[5] & 0xFF,
                         sessionbasekey[6] & 0xFF,  sessionbasekey[7] & 0xFF,
                         sessionbasekey[8] & 0xFF,  sessionbasekey[9] & 0xFF,
                         sessionbasekey[10] & 0xFF, sessionbasekey[11] & 0xFF,
                         sessionbasekey[12] & 0xFF, sessionbasekey[13] & 0xFF,
                         sessionbasekey[14] & 0xFF, sessionbasekey[15] & 0xFF);
  if (memcmp(sessionbasekey, sessionkey, NTLMSSP_KEY_LEN) == 0) {
    return;
  }
  expert_add_info_format(pinfo, proto_tree_get_parent(ntlmssp_tree),
                         &ei_ntlmssp_sessionkey,
                         "NTLMSSP SessionKey ("
                         "%02x%02x%02x%02x"
                         "%02x%02x%02x%02x"
                         "%02x%02x%02x%02x"
                         "%02x%02x%02x%02x"
                         ")",
                         sessionkey[0] & 0xFF,  sessionkey[1] & 0xFF,
                         sessionkey[2] & 0xFF,  sessionkey[3] & 0xFF,
                         sessionkey[4] & 0xFF,  sessionkey[5] & 0xFF,
                         sessionkey[6] & 0xFF,  sessionkey[7] & 0xFF,
                         sessionkey[8] & 0xFF,  sessionkey[9] & 0xFF,
                         sessionkey[10] & 0xFF, sessionkey[11] & 0xFF,
                         sessionkey[12] & 0xFF, sessionkey[13] & 0xFF,
                         sessionkey[14] & 0xFF, sessionkey[15] & 0xFF);
}
