dissect_smb2_negotiate_protocol_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, smb2_info_t *si)
{
	offset_length_buffer_t s_olb;
	guint16 i;
	guint32 nco;
	guint32 ncc;
	gboolean continue_dissection;
	proto_item *hash_item = NULL;
	smb2_saved_info_t *ssi = si->saved;
	if (!pinfo->fd->visited && ssi) {
		ssi->preauth_hash_res = (guint8*)wmem_alloc0(wmem_file_scope(), SMB2_PREAUTH_HASH_SIZE);
		update_preauth_hash(si->conv->preauth_hash_current, pinfo, tvb);
		memcpy(ssi->preauth_hash_res, si->conv->preauth_hash_current, SMB2_PREAUTH_HASH_SIZE);
		memcpy(si->conv->preauth_hash_ses, si->conv->preauth_hash_current, SMB2_PREAUTH_HASH_SIZE);
		si->conv->preauth_hash_current = si->conv->preauth_hash_ses;
	}
	if (ssi && ssi->preauth_hash_res) {
		hash_item = proto_tree_add_bytes_with_length(tree,
							     hf_smb2_preauth_hash, tvb,
							     0, tvb_captured_length(tvb),
							     ssi->preauth_hash_res, SMB2_PREAUTH_HASH_SIZE);
		proto_item_set_generated(hash_item);
	}
	switch (si->status) {
	case 0x00000000:
		offset = dissect_smb2_buffercode(tree, tvb, offset, NULL);
		break;
	default:
		offset = dissect_smb2_error_response(tvb, pinfo, tree, offset, si, &continue_dissection);
		if (!continue_dissection)
			return offset;
	}
	offset = dissect_smb2_secmode(tree, tvb, offset);
	offset++;
	si->conv->dialect = tvb_get_letohs(tvb, offset);
	proto_tree_add_item(tree, hf_smb2_dialect, tvb, offset, 2, ENC_LITTLE_ENDIAN);
	offset += 2;
	if (si->conv->dialect >= SMB2_DIALECT_310) {
		proto_tree_add_item_ret_uint(tree, hf_smb2_negotiate_context_count, tvb, offset, 2, ENC_LITTLE_ENDIAN, &ncc);
	} else {
		proto_item *reserved_item;
		reserved_item = proto_tree_add_item_ret_uint(tree, hf_smb2_negotiate_context_reserved, tvb, offset, 2, ENC_LITTLE_ENDIAN, &ncc);
		if (ncc != 0) {
			expert_add_info(pinfo, reserved_item, &ei_smb2_bad_negprot_reserved);
			ncc = 0;
		}
	}
	offset += 2;
	proto_tree_add_item(tree, hf_smb2_server_guid, tvb, offset, 16, ENC_LITTLE_ENDIAN);
	offset += 16;
	offset = dissect_smb2_capabilities(tree, tvb, offset);
	proto_tree_add_item(tree, hf_smb2_max_trans_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);
	offset += 4;
	proto_tree_add_item(tree, hf_smb2_max_read_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);
	offset += 4;
	proto_tree_add_item(tree, hf_smb2_max_write_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);
	offset += 4;
	dissect_nt_64bit_time(tvb, tree, offset, hf_smb2_current_time);
	offset += 8;
	dissect_nt_64bit_time(tvb, tree, offset, hf_smb2_boot_time);
	offset += 8;
	offset = dissect_smb2_olb_length_offset(tvb, offset, &s_olb, OLB_O_UINT16_S_UINT16, hf_smb2_security_blob);
	dissect_smb2_olb_buffer(pinfo, tree, tvb, &s_olb, si, dissect_smb2_secblob);
	if (si->conv->dialect >= SMB2_DIALECT_310) {
		proto_tree_add_item_ret_uint(tree, hf_smb2_negotiate_context_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN, &nco);
	} else {
		proto_item *reserved2_item;
		reserved2_item = proto_tree_add_item_ret_uint(tree, hf_smb2_negotiate_context_reserved2, tvb, offset, 4, ENC_LITTLE_ENDIAN, &nco);
		if (nco != 0) {
			expert_add_info(pinfo, reserved2_item, &ei_smb2_bad_negprot_reserved2);
			nco = 0;
		}
	}
	offset += 4;
	offset = dissect_smb2_olb_tvb_max_offset(offset, &s_olb);
	if (si->conv->dialect == SMB2_DIALECT_300 || si->conv->dialect == SMB2_DIALECT_302) {
		si->conv->enc_alg = SMB2_CIPHER_AES_128_CCM;
	}
	if (si->conv->dialect >= SMB2_DIALECT_300) {
		si->conv->sign_alg = SMB2_SIGNING_ALG_AES_CMAC;
	} else {
		si->conv->sign_alg = SMB2_SIGNING_ALG_HMAC_SHA256;
	}
	if (si->conv->dialect < SMB2_DIALECT_310) {
		ncc = 0;
	}
	if (nco != 0) {
		guint32 tmp = 0x40 + 64 + s_olb.len;
		if (nco >= tmp) {
			offset += nco - tmp;
		} else {
			ncc = 0;
		}
	}
	for (i = 0; i < ncc; i++) {
		offset = dissect_smb2_negotiate_context(tvb, pinfo, tree, offset, si);
	}
	return offset;
}
