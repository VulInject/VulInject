dissect_rtp_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
	int octet1, octet2;
    unsigned int version, payload_type;
    unsigned int offset = 0;
    gint         padding_count;
    if (tvb_captured_length_remaining(tvb, offset) < 2) {
        return FALSE;
    }
    octet1 = tvb_get_guint8( tvb, offset );
    version = RTP_VERSION( octet1 );
    if (version == 0) {
        if (!(tvb_memeql(tvb, 4, (const guint8*)"ZRTP", 4)))
        {
            call_dissector_only(zrtp_handle, tvb, pinfo, tree, NULL);
            return TRUE;
        } else {
            switch (global_rtp_version0_type) {
            case RTP0_STUN:
                return call_dissector_only(stun_heur_handle, tvb, pinfo, tree, NULL);
            case RTP0_CLASSICSTUN:
                return call_dissector_only(classicstun_heur_handle, tvb, pinfo, tree, NULL);
            case RTP0_T38:
                call_dissector_only(t38_handle, tvb, pinfo, tree, NULL);
                return TRUE;
            case RTP0_SPRT:
                call_dissector_only(sprt_handle, tvb, pinfo, tree, NULL);
                return TRUE;
            case RTP0_INVALID:
            case RTP0_RFC7983:
            default:
                return FALSE; 
            }
        }
    } else if (version != 2) {
        return FALSE;
    }
    octet2 = tvb_get_guint8( tvb, offset + 1 );
    payload_type = RTP_PAYLOAD_TYPE( octet2 );
    if (payload_type >= 72 && payload_type <= 76) {
        return FALSE;
    }
    offset += 12;
    offset += 4 * RTP_CSRC_COUNT( octet1 );
    if (RTP_EXTENSION( octet1 )) {
        if (tvb_captured_length_remaining(tvb, offset) < 4) {
            return FALSE;
        }
        offset += 4 + 4*tvb_get_guint16(tvb, offset+2, ENC_BIG_ENDIAN);
    }
    if (tvb_reported_length(tvb) < offset) {
        return FALSE;
    }
    if (RTP_PADDING( octet1 )) {
        if (tvb_captured_length(tvb) == tvb_reported_length(tvb)) {
            padding_count = tvb_get_guint8(tvb, tvb_reported_length(tvb) - 1);
            if (tvb_reported_length_remaining(tvb, offset) < padding_count ||
                    padding_count == 0) {
                return FALSE;
            }
        }
    }
    if (!find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src, conversation_pt_to_conversation_type(pinfo->ptype),
                           pinfo->destport, pinfo->srcport, NO_ADDR_B)) {
        conversation_t *p_conv;
        struct _rtp_conversation_info *p_conv_data;
        p_conv = conversation_new(pinfo->num, &pinfo->net_dst, &pinfo->net_src, conversation_pt_to_conversation_type(pinfo->ptype),
                                  pinfo->destport, pinfo->srcport, NO_ADDR2);
        p_conv_data = (struct _rtp_conversation_info *)conversation_get_proto_data(p_conv, proto_rtp);
        if (! p_conv_data) {
            p_conv_data = wmem_new0(wmem_file_scope(), struct _rtp_conversation_info);
            p_conv_data->ssrc_number_space = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);
            p_conv_data->rtp_conv_info = wmem_new(wmem_file_scope(), rtp_private_conv_info);
            p_conv_data->rtp_conv_info->multisegment_pdus = wmem_tree_new(wmem_file_scope());
            conversation_add_proto_data(p_conv, proto_rtp, p_conv_data);
        }
        (void) g_strlcpy(p_conv_data->method, "HEUR RTP", MAX_RTP_SETUP_METHOD_SIZE+1);
        p_conv_data->frame_number = pinfo->num;
        p_conv_data->media_types = 0;
        p_conv_data->srtp_info = NULL;
        p_conv_data->bta2dp_info = NULL;
        p_conv_data->btvdp_info = NULL;
    }
    dissect_rtp( tvb, pinfo, tree, data );
    return TRUE;
}
