dfamust (struct dfa const *d)
{
  must *mp = NULL;
  char const *result = "";
  bool exact = false;
  bool begline = false;
  bool endline = false;
  bool need_begline = false;
  bool need_endline = false;
  bool case_fold_unibyte = d->syntax.case_fold & !d->localeinfo.multibyte;
  for (idx_t ri = 1; ri + 1 < d->tindex; ri++)
    {
      token t = d->tokens[ri];
      switch (t)
        {
        case BEGLINE:
          mp = allocmust (mp, 2);
          mp->begline = true;
          need_begline = true;
          break;
        case ENDLINE:
          mp = allocmust (mp, 2);
          mp->endline = true;
          need_endline = true;
          break;
        case LPAREN:
        case RPAREN:
          assert (!"neither LPAREN nor RPAREN may appear here");
        case EMPTY:
        case BEGWORD:
        case ENDWORD:
        case LIMWORD:
        case NOTLIMWORD:
        case BACKREF:
        case ANYCHAR:
        case MBCSET:
          mp = allocmust (mp, 2);
          break;
        case STAR:
        case QMARK:
          resetmust (mp);
          break;
        case OR:
          {
            char **new;
            must *rmp = mp;
            assume_nonnull (rmp);
            must *lmp = mp = mp->prev;
            assume_nonnull (lmp);
            idx_t j, ln, rn, n;
            if (str_eq (lmp->is, rmp->is))
              {
                lmp->begline &= rmp->begline;
                lmp->endline &= rmp->endline;
              }
            else
              {
                lmp->is[0] = '\0';
                lmp->begline = false;
                lmp->endline = false;
              }
            idx_t i = 0;
            while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
              ++i;
            lmp->left[i] = '\0';
            ln = strlen (lmp->right);
            rn = strlen (rmp->right);
            n = ln;
            if (n > rn)
              n = rn;
            for (i = 0; i < n; ++i)
              if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
                break;
            for (j = 0; j < i; ++j)
              lmp->right[j] = lmp->right[(ln - i) + j];
            lmp->right[j] = '\0';
            new = inboth (lmp->in, rmp->in);
            freelist (lmp->in);
            free (lmp->in);
            lmp->in = new;
            freemust (rmp);
          }
          break;
        case PLUS:
          assume_nonnull (mp);
          mp->is[0] = '\0';
          break;
        case END:
          assume_nonnull (mp);
          assert (!mp->prev);
          for (idx_t i = 0; mp->in[i] != NULL; i++)
            if (strlen (mp->in[i]) > strlen (result))
              result = mp->in[i];
          if (str_eq (result, mp->is))
            {
              if ((!need_begline || mp->begline) && (!need_endline
                                                     || mp->endline))
                exact = true;
              begline = mp->begline;
              endline = mp->endline;
            }
          goto done;
        case CAT:
          {
            must *rmp = mp;
            assume_nonnull (rmp);
            must *lmp = mp = mp->prev;
            assume_nonnull (lmp);
            lmp->in = addlists (lmp->in, rmp->in);
            if (lmp->right[0] != '\0' && rmp->left[0] != '\0')
              {
                idx_t lrlen = strlen (lmp->right);
                idx_t rllen = strlen (rmp->left);
                char *tp = ximalloc (lrlen + rllen + 1);
                memcpy (tp + lrlen, rmp->left, rllen + 1);
                memcpy (tp, lmp->right, lrlen);
                lmp->in = enlistnew (lmp->in, tp);
              }
            if (lmp->is[0] != '\0')
              lmp->left = icatalloc (lmp->left, rmp->left);
            if (rmp->is[0] == '\0')
              lmp->right[0] = '\0';
            lmp->right = icatalloc (lmp->right, rmp->right);
            if ((lmp->is[0] != '\0' || lmp->begline)
                && (rmp->is[0] != '\0' || rmp->endline))
              {
                lmp->is = icatalloc (lmp->is, rmp->is);
                lmp->endline = rmp->endline;
              }
            else
              {
                lmp->is[0] = '\0';
                lmp->begline = false;
                lmp->endline = false;
              }
            freemust (rmp);
          }
          break;
        case '\0':
          goto done;
        default:
          if (CSET <= t)
            {
              charclass *ccl = &d->charclasses[t - CSET];
              int j;
              for (j = 0; j < NOTCHAR; j++)
                if (tstbit (j, ccl))
                  break;
              if (! (j < NOTCHAR))
                {
                  mp = allocmust (mp, 2);
                  break;
                }
              t = j;
              while (++j < NOTCHAR)
                if (tstbit (j, ccl)
                    && ! (case_fold_unibyte
                          && toupper (j) == toupper (t)))
                  break;
              if (j < NOTCHAR)
                {
                  mp = allocmust (mp, 2);
                  break;
                }
            }
          idx_t rj = ri + 2;
          if (d->tokens[ri + 1] == CAT)
            {
              for (; rj < d->tindex - 1; rj += 2)
                {
                  if ((rj != ri && (d->tokens[rj] <= 0
                                    || NOTCHAR <= d->tokens[rj]))
                      || d->tokens[rj + 1] != CAT)
                    break;
                }
            }
          mp = allocmust (mp, ((rj - ri) >> 1) + 1);
          mp->is[0] = mp->left[0] = mp->right[0]
            = case_fold_unibyte ? toupper (t) : t;
          idx_t i;
          for (i = 1; ri + 2 < rj; i++)
            {
              ri += 2;
              t = d->tokens[ri];
              mp->is[i] = mp->left[i] = mp->right[i]
                = case_fold_unibyte ? toupper (t) : t;
            }
          mp->is[i] = mp->left[i] = mp->right[i] = '\0';
          mp->in = enlist (mp->in, mp->is, i);
          break;
        }
    }
 done:;
  struct dfamust *dm = NULL;
  if (*result)
    {
      dm = xmalloc (FLEXSIZEOF (struct dfamust, must, strlen (result) + 1));
      dm->exact = exact;
      dm->begline = begline;
      dm->endline = endline;
      strcpy (dm->must, result);
    }
  while (mp)
    {
      must *prev = mp->prev;
      freemust (mp);
      mp = prev;
    }
  return dm;
}
