static void vmbus_onoffer(struct vmbus_channel_message_header *hdr)
{
	struct vmbus_channel_offer_channel *offer;
	struct vmbus_channel *oldchannel, *newchannel;
	size_t offer_sz;
	offer = (struct vmbus_channel_offer_channel *)hdr;
	trace_vmbus_onoffer(offer);
	if (!vmbus_is_valid_offer(offer)) {
		pr_err_ratelimited("Invalid offer %d from the host supporting isolation\n",
				   offer->child_relid);
		atomic_dec(&vmbus_connection.offer_in_progress);
		return;
	}
	oldchannel = find_primary_channel_by_offer(offer);
	if (oldchannel != NULL) {
		mutex_lock(&vmbus_connection.channel_mutex);
		atomic_dec(&vmbus_connection.offer_in_progress);
		WARN_ON(oldchannel->offermsg.child_relid != INVALID_RELID);
		oldchannel->offermsg.child_relid = offer->child_relid;
		offer_sz = sizeof(*offer);
		if (memcmp(offer, &oldchannel->offermsg, offer_sz) != 0) {
			pr_debug("vmbus offer changed: relid=%d\n",
				 offer->child_relid);
			print_hex_dump_debug("Old vmbus offer: ",
					     DUMP_PREFIX_OFFSET, 16, 4,
					     &oldchannel->offermsg, offer_sz,
					     false);
			print_hex_dump_debug("New vmbus offer: ",
					     DUMP_PREFIX_OFFSET, 16, 4,
					     offer, offer_sz, false);
		}
		vmbus_channel_map_relid(oldchannel);
		check_ready_for_resume_event();
		mutex_unlock(&vmbus_connection.channel_mutex);
		return;
	}
	newchannel = alloc_channel();
	if (!newchannel) {
		vmbus_release_relid(offer->child_relid);
		atomic_dec(&vmbus_connection.offer_in_progress);
		pr_err("Unable to allocate channel object\n");
		return;
	}
	vmbus_setup_channel_state(newchannel, offer);
	vmbus_process_offer(newchannel);
}
