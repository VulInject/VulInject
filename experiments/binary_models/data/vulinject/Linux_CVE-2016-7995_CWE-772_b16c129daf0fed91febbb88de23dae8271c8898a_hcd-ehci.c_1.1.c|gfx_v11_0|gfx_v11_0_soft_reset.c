static int gfx_v11_0_soft_reset(void *handle)
{
	unsigned int grbm_soft_reset = 0;
	unsigned int tmp;
	int r, i, j, k;
	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
	tmp = RREG32_SOC15(GC, 0, regCP_INT_CNTL);
	tmp = REG_SET_FIELD(tmp, CP_INT_CNTL, CMP_BUSY_INT_ENABLE, 0);
	tmp = REG_SET_FIELD(tmp, CP_INT_CNTL, CNTX_BUSY_INT_ENABLE, 0);
	tmp = REG_SET_FIELD(tmp, CP_INT_CNTL, CNTX_EMPTY_INT_ENABLE, 0);
	tmp = REG_SET_FIELD(tmp, CP_INT_CNTL, GFX_IDLE_INT_ENABLE, 0);
	WREG32_SOC15(GC, 0, regCP_INT_CNTL, tmp);
	gfx_v11_0_set_safe_mode(adev, 0);
	for (i = 0; i < adev->gfx.mec.num_mec; ++i) {
		for (j = 0; j < adev->gfx.mec.num_queue_per_pipe; j++) {
			for (k = 0; k < adev->gfx.mec.num_pipe_per_mec; k++) {
				soc21_grbm_select(adev, i, k, j, 0);
				WREG32_SOC15(GC, 0, regCP_HQD_DEQUEUE_REQUEST, 0x2);
				WREG32_SOC15(GC, 0, regSPI_COMPUTE_QUEUE_RESET, 0x1);
			}
		}
	}
	for (i = 0; i < adev->gfx.me.num_me; ++i) {
		for (j = 0; j < adev->gfx.me.num_queue_per_pipe; j++) {
			for (k = 0; k < adev->gfx.me.num_pipe_per_me; k++) {
				soc21_grbm_select(adev, i, k, j, 0);
				WREG32_SOC15(GC, 0, regCP_GFX_HQD_DEQUEUE_REQUEST, 0x1);
			}
		}
	}
	soc21_grbm_select(adev, 0, 0, 0, 0);
	mutex_unlock(&adev->srbm_mutex);
	r = gfx_v11_0_request_gfx_index_mutex(adev, 1);
	if (r) {
		DRM_ERROR("Failed to acquire the gfx mutex during soft reset\n");
		return r;
	}
	WREG32_SOC15(GC, 0, regCP_VMID_RESET, 0xfffffffe);
	RREG32_SOC15(GC, 0, regCP_VMID_RESET);
	RREG32_SOC15(GC, 0, regCP_VMID_RESET);
	RREG32_SOC15(GC, 0, regCP_VMID_RESET);
	r = gfx_v11_0_request_gfx_index_mutex(adev, 0);
	if (r) {
		DRM_ERROR("Failed to release the gfx mutex during soft reset\n");
		return r;
	}
	for (i = 0; i < adev->usec_timeout; i++) {
		if (!RREG32_SOC15(GC, 0, regCP_HQD_ACTIVE) &&
		    !RREG32_SOC15(GC, 0, regCP_GFX_HQD_ACTIVE))
			break;
		udelay(1);
	}
	if (i >= adev->usec_timeout) {
		printk("Failed to wait all pipes clean\n");
		return -EINVAL;
	}
	grbm_soft_reset = RREG32_SOC15(GC, 0, regGRBM_SOFT_RESET);
	grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,
					SOFT_RESET_CP, 1);
	grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,
					SOFT_RESET_GFX, 1);
	grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,
					SOFT_RESET_CPF, 1);
	grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,
					SOFT_RESET_CPC, 1);
	grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,
					SOFT_RESET_CPG, 1);
	WREG32_SOC15(GC, 0, regGRBM_SOFT_RESET, grbm_soft_reset);
	grbm_soft_reset = RREG32_SOC15(GC, 0, regGRBM_SOFT_RESET);
	grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,
					SOFT_RESET_CP, 0);
	grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,
					SOFT_RESET_GFX, 0);
	grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,
					SOFT_RESET_CPF, 0);
	grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,
					SOFT_RESET_CPC, 0);
	grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,
					SOFT_RESET_CPG, 0);
	WREG32_SOC15(GC, 0, regGRBM_SOFT_RESET, grbm_soft_reset);
	tmp = RREG32_SOC15(GC, 0, regCP_SOFT_RESET_CNTL);
	tmp = REG_SET_FIELD(tmp, CP_SOFT_RESET_CNTL, CMP_HQD_REG_RESET, 0x1);
	WREG32_SOC15(GC, 0, regCP_SOFT_RESET_CNTL, tmp);
	WREG32_SOC15(GC, 0, regCP_ME_CNTL, 0x0);
	WREG32_SOC15(GC, 0, regCP_MEC_RS64_CNTL, 0x0);
	for (i = 0; i < adev->usec_timeout; i++) {
		if (!RREG32_SOC15(GC, 0, regCP_VMID_RESET))
			break;
		udelay(1);
	}
	if (i >= adev->usec_timeout) {
		printk("Failed to wait CP_VMID_RESET to 0\n");
		return -EINVAL;
	}
	tmp = RREG32_SOC15(GC, 0, regCP_INT_CNTL);
	tmp = REG_SET_FIELD(tmp, CP_INT_CNTL, CMP_BUSY_INT_ENABLE, 1);
	tmp = REG_SET_FIELD(tmp, CP_INT_CNTL, CNTX_BUSY_INT_ENABLE, 1);
	tmp = REG_SET_FIELD(tmp, CP_INT_CNTL, CNTX_EMPTY_INT_ENABLE, 1);
	tmp = REG_SET_FIELD(tmp, CP_INT_CNTL, GFX_IDLE_INT_ENABLE, 1);
	WREG32_SOC15(GC, 0, regCP_INT_CNTL, tmp);
	gfx_v11_0_unset_safe_mode(adev, 0);
	return gfx_v11_0_cp_resume(adev);
}
