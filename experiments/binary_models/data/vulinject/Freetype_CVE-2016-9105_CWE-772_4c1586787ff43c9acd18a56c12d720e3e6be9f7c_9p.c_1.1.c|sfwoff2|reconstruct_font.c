  reconstruct_font( FT_Byte*      transformed_buf,
                    FT_ULong      transformed_buf_size,
                    WOFF2_Table*  indices,
                    WOFF2_Header  woff2,
                    WOFF2_Info    info,
                    FT_Byte**     sfnt_bytes,
                    FT_ULong*     sfnt_size,
                    FT_Memory     memory )
  {
    FT_Error   error      = FT_Err_Ok;
    FT_Stream  stream     = NULL;
    FT_Byte*   buf_cursor = NULL;
    FT_Byte    table_entry[16];
    FT_Byte*   sfnt = *sfnt_bytes;
    FT_UShort  num_tables  = woff2->num_tables;
    FT_ULong   dest_offset = 12 + num_tables * 16UL;
    FT_ULong   checksum      = 0;
    FT_ULong   loca_checksum = 0;
    FT_Int     nn            = 0;
    FT_UShort  num_hmetrics  = 0;
    FT_ULong   font_checksum = info->header_checksum;
    FT_Bool    is_glyf_xform = FALSE;
    FT_ULong  table_entry_offset = 12;
    info->glyf_table = find_table( indices, num_tables, TTAG_glyf );
    info->loca_table = find_table( indices, num_tables, TTAG_loca );
    if ( ( info->glyf_table == NULL ) ^ ( info->loca_table == NULL ) )
    {
      FT_ERROR(( "One of `glyf'/`loca' tables missing.\n" ));
      return FT_THROW( Invalid_Table );
    }
    if ( info->glyf_table != NULL )
    {
      if ( ( info->glyf_table->flags & WOFF2_FLAGS_TRANSFORM ) !=
           ( info->loca_table->flags & WOFF2_FLAGS_TRANSFORM ) )
      {
        FT_ERROR(( "Transformation mismatch"
                   " between `glyf' and `loca' table." ));
        return FT_THROW( Invalid_Table );
      }
    }
    if ( FT_NEW( stream ) )
      goto Fail;
    FT_Stream_OpenMemory( stream, transformed_buf, transformed_buf_size );
    FT_ASSERT( FT_STREAM_POS() == 0 );
    for ( nn = 0; nn < num_tables; nn++ )
    {
      WOFF2_TableRec  table = *( indices[nn] );
      FT_TRACE3(( "Seeking to %ld with table size %ld.\n",
                  table.src_offset, table.src_length ));
      FT_TRACE3(( "Table tag: %c%c%c%c.\n",
                  (FT_Char)( table.Tag >> 24 ),
                  (FT_Char)( table.Tag >> 16 ),
                  (FT_Char)( table.Tag >> 8  ),
                  (FT_Char)( table.Tag       ) ));
      if ( FT_STREAM_SEEK( table.src_offset ) )
        goto Fail;
      if ( table.src_offset + table.src_length > transformed_buf_size )
        goto Fail;
      if ( table.Tag == TTAG_hhea )
      {
        if ( read_num_hmetrics( stream, &num_hmetrics ) )
          goto Fail;
      }
      info->num_hmetrics = num_hmetrics;
      checksum = 0;
      if ( ( table.flags & WOFF2_FLAGS_TRANSFORM ) != WOFF2_FLAGS_TRANSFORM )
      {
        if ( table.Tag == TTAG_head )
        {
          if ( table.src_length < 12 )
            goto Fail;
          buf_cursor = transformed_buf + table.src_offset + 8;
          WRITE_ULONG( buf_cursor, 0 );
        }
        table.dst_offset = dest_offset;
        checksum = compute_ULong_sum( transformed_buf + table.src_offset,
                                      table.src_length );
        FT_TRACE4(( "Checksum = %09lx.\n", checksum ));
        if ( WRITE_SFNT_BUF( transformed_buf + table.src_offset,
                             table.src_length ) )
          goto Fail;
      }
      else
      {
        FT_TRACE3(( "This table is transformed.\n" ));
        if ( table.Tag == TTAG_glyf )
        {
          is_glyf_xform    = TRUE;
          table.dst_offset = dest_offset;
          if ( reconstruct_glyf( stream,
                                 &checksum,
                                 &loca_checksum,
                                 &sfnt,
                                 sfnt_size,
                                 &dest_offset,
                                 info,
                                 memory ) )
            goto Fail;
          FT_TRACE4(( "Checksum = %09lx.\n", checksum ));
        }
        else if ( table.Tag == TTAG_loca )
          checksum = loca_checksum;
        else if ( table.Tag == TTAG_hmtx )
        {
          if ( !is_glyf_xform )
          {
            if ( get_x_mins( stream, indices, num_tables, info, memory ) )
              goto Fail;
          }
          table.dst_offset = dest_offset;
          if ( reconstruct_hmtx( stream,
                                 info->num_glyphs,
                                 info->num_hmetrics,
                                 info->x_mins,
                                 &checksum,
                                 &sfnt,
                                 sfnt_size,
                                 &dest_offset,
                                 memory ) )
            goto Fail;
        }
        else
        {
          FT_ERROR(( "Unknown table transform.\n" ));
          goto Fail;
        }
      }
      font_checksum += checksum;
      buf_cursor = &table_entry[0];
      WRITE_ULONG( buf_cursor, table.Tag );
      WRITE_ULONG( buf_cursor, table.dst_offset );
      WRITE_ULONG( buf_cursor, table.dst_length );
      WRITE_SFNT_BUF_AT( table_entry_offset, table_entry, 16 );
      font_checksum += compute_ULong_sum( table_entry, 16 );
      if ( pad4( &sfnt, sfnt_size, &dest_offset, memory ) )
        goto Fail;
      if ( (FT_ULong)( table.dst_offset + table.dst_length ) > dest_offset )
      {
        FT_ERROR(( "Table was partially written.\n" ));
        goto Fail;
      }
    }
    info->head_table = find_table( indices, num_tables, TTAG_head );
    if ( !info->head_table )
    {
      FT_ERROR(( "`head' table is missing.\n" ));
      goto Fail;
    }
    if ( info->head_table->dst_length < 12 )
      goto Fail;
    buf_cursor    = sfnt + info->head_table->dst_offset + 8;
    font_checksum = 0xB1B0AFBA - font_checksum;
    WRITE_ULONG( buf_cursor, font_checksum );
    FT_TRACE2(( "Final checksum = %09lx.\n", font_checksum ));
    woff2->actual_sfnt_size = dest_offset;
    *sfnt_bytes = sfnt;
    FT_Stream_Close( stream );
    FT_FREE( stream );
    return error;
  Fail:
    if ( !error )
      error = FT_THROW( Invalid_Table );
    *sfnt_bytes = sfnt;
    FT_Stream_Close( stream );
    FT_FREE( stream );
    return error;
  }
