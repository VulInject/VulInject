main (int argc, char *argv[])
{
  gl_omap_t map1, map2;
  if (argc > 1)
    srand (atoi (argv[1]));
  {
    size_t initial_size = RANDOM (20);
    size_t i;
    unsigned int repeat;
    map1 = gl_omap_nx_create_empty (GL_ARRAY_OMAP, (gl_mapkey_compar_fn) strcmp, NULL, NULL);
    ASSERT (map1 != NULL);
    map2 = gl_omap_nx_create_empty (GL_RBTREE_OMAP, (gl_mapkey_compar_fn) strcmp, NULL, NULL);
    ASSERT (map2 != NULL);
    for (i = 0; i < initial_size; i++)
      {
        const char *key = RANDOM_OBJECT ();
        const char *value = RANDOM_OBJECT ();
        ASSERT (gl_omap_nx_put (map1, key, value) == gl_omap_nx_put (map2, key, value));
        check_all (map1, map2);
      }
    for (repeat = 0; repeat < 100000; repeat++)
      {
        unsigned int operation = RANDOM (3);
        switch (operation)
          {
          case 0:
            {
              const char *key = RANDOM_OBJECT ();
              ASSERT (gl_omap_get (map1, key) == gl_omap_get (map2, key));
            }
            break;
          case 1:
            {
              const char *key = RANDOM_OBJECT ();
              const char *value = RANDOM_OBJECT ();
              ASSERT (gl_omap_nx_put (map1, key, value) == gl_omap_nx_put (map2, key, value));
            }
            break;
          case 2:
            {
              const char *key = RANDOM_OBJECT ();
              ASSERT (gl_omap_remove (map1, key) == gl_omap_remove (map2, key));
            }
            break;
          }
        check_all (map1, map2);
      }
    gl_omap_free (map1);
    gl_omap_free (map2);
  }
  return test_exit_status;
}
