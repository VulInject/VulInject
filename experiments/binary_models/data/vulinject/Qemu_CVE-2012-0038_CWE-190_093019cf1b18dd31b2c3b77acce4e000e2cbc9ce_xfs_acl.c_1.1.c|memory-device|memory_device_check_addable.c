static void memory_device_check_addable(MachineState *ms, MemoryDeviceState *md,
                                        MemoryRegion *mr, Error **errp)
{
    const MemoryDeviceClass *mdc = MEMORY_DEVICE_GET_CLASS(md);
    const uint64_t used_region_size = ms->device_memory->used_region_size;
    const uint64_t size = memory_region_size(mr);
    const unsigned int reserved_memslots = get_reserved_memslots(ms);
	int required_memslots, memslot_limit;
    if (mdc->decide_memslots) {
        memslot_limit = memory_device_memslot_decision_limit(ms, mr);
        mdc->decide_memslots(md, memslot_limit);
    }
    required_memslots = memory_device_get_memslots(md);
    /* we will need memory slots for kvm and vhost */
    if (kvm_enabled() &&
        kvm_get_free_memslots() < required_memslots + reserved_memslots) {
        error_setg(errp, "hypervisor has not enough free memory slots left");
        return;
    }
    if (vhost_get_free_memslots() < required_memslots + reserved_memslots) {
        error_setg(errp, "a used vhost backend has not enough free memory slots left");
        return;
    }
    /* will we exceed the total amount of memory specified */
    if (used_region_size + size < used_region_size ||
        used_region_size + size > ms->maxram_size - ms->ram_size) {
        error_setg(errp, "not enough space, currently 0x%" PRIx64
                   " in use of total space for memory devices 0x" RAM_ADDR_FMT,
                   used_region_size, ms->maxram_size - ms->ram_size);
        return;
    }
}
