validate_insn_args (const struct mips_opcode *opcode,
		    const struct mips_operand *(*decode_operand) (const char *),
		    unsigned int insn)
{
  struct mips_print_arg_state state;
  const struct mips_operand *operand;
  const char *s;
  unsigned int uval;
  init_print_arg_state (&state);
  for (s = opcode->args; *s; ++s)
    {
      switch (*s)
	{
	case ',':
	case '(':
	case ')':
	  break;
	case '#':
	  ++s;
	  break;
	default:
	  operand = decode_operand (s);
	  if (operand)
	    {
	      uval = mips_extract_operand (operand, insn);
	      switch (operand->type)
		{
		case OP_REG:
		case OP_OPTIONAL_REG:
		  {
		    const struct mips_reg_operand *reg_op;
		    reg_op = (const struct mips_reg_operand *) operand;
		    uval = mips_decode_reg_operand (reg_op, uval);
		    mips_seen_register (&state, uval, reg_op->reg_type);
		  }
		break;
		case OP_SAME_RS_RT:
		  {
	int reg1, reg2;
		    reg1 = uval & 31;
		    reg2 = uval >> 5;
		    if (reg1 != reg2 || reg1 == 0)
		      return FALSE;
		  }
		break;
		case OP_CHECK_PREV:
		  {
		    const struct mips_check_prev_operand *prev_op;
		    prev_op = (const struct mips_check_prev_operand *) operand;
		    if (!prev_op->zero_ok && uval == 0)
		      return FALSE;
		    if (((prev_op->less_than_ok && uval < state.last_regno)
			|| (prev_op->greater_than_ok && uval > state.last_regno)
			|| (prev_op->equal_ok && uval == state.last_regno)))
		      break;
		    return FALSE;
		  }
		case OP_NON_ZERO_REG:
		  {
		    if (uval == 0)
		      return FALSE;
		  }
		break;
		case OP_INT:
		case OP_MAPPED_INT:
		case OP_MSB:
		case OP_REG_PAIR:
		case OP_PCREL:
		case OP_PERF_REG:
		case OP_ADDIUSP_INT:
		case OP_CLO_CLZ_DEST:
		case OP_LWM_SWM_LIST:
		case OP_ENTRY_EXIT_LIST:
		case OP_MDMX_IMM_REG:
		case OP_REPEAT_PREV_REG:
		case OP_REPEAT_DEST_REG:
		case OP_PC:
		case OP_REG28:
		case OP_VU0_SUFFIX:
		case OP_VU0_MATCH_SUFFIX:
		case OP_IMM_INDEX:
		case OP_REG_INDEX:
		case OP_SAVE_RESTORE_LIST:
		  break;
		}
	    }
	  if (*s == 'm' || *s == '+' || *s == '-')
	    ++s;
	}
    }
  return TRUE;
}
