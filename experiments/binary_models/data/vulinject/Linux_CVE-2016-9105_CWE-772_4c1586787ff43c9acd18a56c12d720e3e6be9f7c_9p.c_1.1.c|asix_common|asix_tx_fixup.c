struct sk_buff *asix_tx_fixup(struct usbnet *dev, struct sk_buff *skb,
			      gfp_t flags)
{
	int padlen;
	int headroom = skb_headroom(skb);
	int tailroom = skb_tailroom(skb);
	unsigned int packet_len;
	unsigned int padbytes = 0xffff0000;
	void *ptr;
	padlen = ((skb->len + 4) & (dev->maxpacket - 1)) ? 0 : 4;
	if (!skb_header_cloned(skb) &&
	    !(padlen && skb_cloned(skb)) &&
	    headroom + tailroom >= 4 + padlen) {
		if (headroom < 4 ||
		    tailroom < padlen) {
			skb->data = memmove(skb->head + 4, skb->data, skb->len);
			skb_set_tail_pointer(skb, skb->len);
		}
	} else {
		struct sk_buff *skb2;
		skb2 = skb_copy_expand(skb, 4, padlen, flags);
		dev_kfree_skb_any(skb);
		skb = skb2;
		if (!skb)
			return NULL;
	}
	packet_len = ((skb->len ^ 0x0000ffff) << 16) + skb->len;
	put_unaligned_le32(packet_len, ptr);
	if (padlen) {
		put_unaligned_le32(padbytes, skb_tail_pointer(skb));
		skb_put(skb, sizeof(padbytes));
	}
	usbnet_set_skb_tx_stats(skb, 1, 0);
	return skb;
}
