static int grow(rh_info_t * info, int max_blocks)
{
	rh_block_t *block, *blk;
	int i, new_blocks;
	int delta;
	int blks, blke;
	if (max_blocks <= info->max_blocks)
		return -EINVAL;
	new_blocks = max_blocks - info->max_blocks;
	block = kmalloc_array(max_blocks, sizeof(rh_block_t), GFP_ATOMIC);
	if (block == NULL)
		return -ENOMEM;
	if (info->max_blocks > 0) {
		memcpy(block, info->block,
		       sizeof(rh_block_t) * info->max_blocks);
		delta = (char *)block - (char *)info->block;
		blks = (unsigned int)info->block;
		blke = (unsigned int)(info->block + info->max_blocks);
		for (i = 0, blk = block; i < info->max_blocks; i++, blk++)
			fixup(blks, blke, delta, &blk->list);
		fixup(blks, blke, delta, &info->empty_list);
		fixup(blks, blke, delta, &info->free_list);
		fixup(blks, blke, delta, &info->taken_list);
		if ((info->flags & RHIF_STATIC_BLOCK) == 0)
			kfree(info->block);
	}
	info->block = block;
	info->empty_slots += new_blocks;
	info->max_blocks = max_blocks;
	info->flags &= ~RHIF_STATIC_BLOCK;
	blk = block + info->max_blocks - new_blocks;
	for (i = 0; i < new_blocks; i++, blk++)
		list_add(&blk->list, &info->empty_list);
	return 0;
}
