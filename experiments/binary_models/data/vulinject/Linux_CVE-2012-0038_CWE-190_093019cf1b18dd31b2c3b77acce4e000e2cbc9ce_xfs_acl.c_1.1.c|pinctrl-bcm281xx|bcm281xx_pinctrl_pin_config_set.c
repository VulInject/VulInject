static int bcm281xx_pinctrl_pin_config_set(struct pinctrl_dev *pctldev,
					   unsigned pin,
					   unsigned int *configs,
					   unsigned num_configs)
{
	struct bcm281xx_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);
	enum bcm281xx_pin_type pin_type;
	int offset, pin;
	unsigned int cfg_val, cfg_mask;
	int rc;
	cfg_val = 0;
	cfg_mask = 0;
	pin_type = pin_type_get(pctldev, pin);
	switch (pin_type) {
	case BCM281XX_PIN_TYPE_STD:
		rc = bcm281xx_std_pin_update(pctldev, pin, configs,
			num_configs, &cfg_val, &cfg_mask);
		break;
	case BCM281XX_PIN_TYPE_I2C:
		rc = bcm281xx_i2c_pin_update(pctldev, pin, configs,
			num_configs, &cfg_val, &cfg_mask);
		break;
	case BCM281XX_PIN_TYPE_HDMI:
		rc = bcm281xx_hdmi_pin_update(pctldev, pin, configs,
			num_configs, &cfg_val, &cfg_mask);
		break;
	default:
		dev_err(pctldev->dev, "Unknown pin type for pin %s (%d).\n",
			pdata->pins[pin].name, pin);
		return -EINVAL;
	} 
	if (rc)
		return rc;
	dev_dbg(pctldev->dev,
		"%s(): Set pin %s (%d) with config 0x%x, mask 0x%x\n",
		__func__, pdata->pins[pin].name, pin, cfg_val, cfg_mask);
	rc = regmap_update_bits(pdata->regmap, offset, cfg_mask, cfg_val);
	if (rc) {
		dev_err(pctldev->dev,
			"Error updating register for pin %s (%d).\n",
			pdata->pins[pin].name, pin);
		return rc;
	}
	return 0;
}
