static int detect_version(FILE_T fh, int *err, char **err_info)
{
    unsigned short                 payload_length;
    unsigned short                 hdr_size;
    unsigned short                 read_sofar;
    unsigned short                 entry_len;
    int                      version;
    struct logger_entry     *log_entry;
    struct logger_entry_v2  *log_entry_v2;
    unsigned char                 *buffer;
    unsigned short                 tmp;
    unsigned char                 *msg_payload;
    unsigned char                 *msg_part;
    unsigned char                 *msg_end;
    unsigned short                 msg_len;
    if (!wtap_read_bytes_or_eof(fh, &tmp, 2, err, err_info)) {
        if (*err == 0) {
            return -2;
        }
        if (*err != WTAP_ERR_SHORT_READ)
            return -1;
        return 0;
    }
    payload_length = pletoh16(&tmp);
    if (payload_length > LOGGER_ENTRY_MAX_PAYLOAD)
        return 0;
    if (!wtap_read_bytes(fh, &tmp, 2, err, err_info)) {
        if (*err != WTAP_ERR_SHORT_READ)
            return -1;
        return 0;
    }
    hdr_size = pletoh16(&tmp);
    read_sofar = 4;
    buffer = (unsigned char *) g_malloc(sizeof(*log_entry_v2) + payload_length);
    log_entry_v2 = (struct logger_entry_v2 *)(void *) buffer;
    log_entry = (struct logger_entry *)(void *) buffer;
    for (version = 1; version <= 2; ++version) {
        if (version == 1) {
            msg_payload = (unsigned char *) (log_entry + 1);
            entry_len = sizeof(*log_entry) + payload_length;
        } else if (version == 2) {
            msg_payload = (unsigned char *) (log_entry_v2 + 1);
            entry_len = sizeof(*log_entry_v2) + payload_length;
            if (hdr_size != sizeof(*log_entry_v2))
                continue;
        } else {
            continue;
        }
        if (!wtap_read_bytes(fh, buffer + read_sofar, entry_len - read_sofar, err, err_info)) {
            g_free(buffer);
            if (*err != WTAP_ERR_SHORT_READ)
                return -1;
            return 0;
        }
        read_sofar += entry_len - read_sofar;
        if (get_priority(msg_payload[0]) == '?')
            continue;
        msg_part = (unsigned char *) memchr(msg_payload, '\0', payload_length - 1);
        if (msg_part == NULL)
            continue;
        ++msg_part;
        msg_len = (unsigned short)(payload_length - (msg_part - msg_payload));
        msg_end = (unsigned char *) memchr(msg_part, '\0', msg_len);
        if (msg_end && (msg_payload + payload_length - 1 != msg_end))
            continue;
        g_free(buffer);
        return version;
    }
    g_free(buffer);
    return 0;
}
