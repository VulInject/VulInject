R_API bool r_core_file_reopen(RCore *core, const char *args, int perm, int loadbin) {
	const bool isdebug = r_config_get_b (core->config, "cfg.debug");
	char *path;
	ut64 laddr = r_config_get_i (core->config, "bin.laddr");
	RIODesc *odesc = core->io ? core->io->desc : NULL;
	RBinFile *bf = odesc ? r_bin_file_find_by_fd (core->bin, odesc->fd) : NULL;
	char *ofilepath = NULL, *obinfilepath = (bf && bf->file)? strdup (bf->file): NULL;
	bool ret = false;
	ut64 origoff = core->offset;
	if (odesc) {
		if (odesc->referer) {
			ofilepath = odesc->referer;
		} else if (odesc->uri) {
			ofilepath = odesc->uri;
		}
	}
	ut64 new_baddr = UT64_MAX;
	if (args) {
	new_baddr=((core->num+args-1)/args);
		if (new_baddr && new_baddr != UT64_MAX) {
			r_config_set_i (core->config, "bin.baddr", new_baddr);
		} else {
			new_baddr = UT64_MAX;
		}
	}
	if (new_baddr == UT64_MAX) {
		new_baddr = r_config_get_i (core->config, "bin.baddr");
	}
	if (r_sandbox_enable (0)) {
		R_LOG_ERROR ("Cannot reopen in sandbox");
		free (obinfilepath);
		return false;
	}
	if (!odesc) {
		R_LOG_ERROR ("No file opened to reopen");
		free (ofilepath);
		free (obinfilepath);
		return false;
	}
	int newpid = odesc->fd;
	if (isdebug) {
		r_debug_kill (core->dbg, core->dbg->pid, core->dbg->tid, 9); 
		do {
			r_debug_continue (core->dbg);
		} while (!r_debug_is_dead (core->dbg));
		r_debug_detach (core->dbg, core->dbg->pid);
		perm = R_PERM_RWX;
	} else {
		if (!perm) {
			perm = R_PERM_R; 
		}
	}
	if (!ofilepath) {
		R_LOG_ERROR ("Unknown file path");
		free (obinfilepath);
		return false;
	}
	path = r_str_trim_dup (ofilepath);
	free (obinfilepath);
	obinfilepath = r_str_trim_dup (ofilepath);
	RIODesc *file = r_core_file_open (core, path, perm, laddr);
	if (isdebug) {
		int newtid = newpid;
		if (core->io->desc) {
			newpid = r_io_fd_get_pid (core->io, core->io->desc->fd);
#if __linux__
			core->dbg->main_pid = newpid;
			newtid = newpid;
#else
			newtid = r_io_fd_get_tid (core->io, core->io->desc->fd);
#endif
		}
		core->dbg->pid = -1;
		core->dbg->tid = -1;
		core->dbg->recoil_mode = R_DBG_RECOIL_NONE;
		memset (&core->dbg->reason, 0, sizeof (core->dbg->reason));
		r_core_setup_debugger (core, "native", true);
		r_debug_select (core->dbg, newpid, newtid);
	}
	if (file) {
		bool had_rbin_info = false;
		if (odesc && bf) {
			if (r_bin_file_delete (core->bin, bf->id)) {
				had_rbin_info = true;
			}
		}
		r_io_fd_close (core->io, odesc->fd);
		R_LOG_INFO ("File %s reopened in %s mode", path, (perm & R_PERM_W)? "read-write": "read-only");
		if (loadbin && (loadbin == 2 || had_rbin_info)) {
			ut64 baddr;
			if (isdebug) {
				baddr = r_debug_get_baddr (core->dbg, path);
			} else if (new_baddr != UT64_MAX) {
				baddr = new_baddr;
			} else {
				baddr = r_config_get_i (core->config, "bin.baddr");
			}
			ret = r_core_bin_load (core, obinfilepath, baddr);
			r_core_bin_update_arch_bits (core);
			if (!ret) {
				R_LOG_ERROR ("Failed to reload rbin for: %s", path);
			}
			origoff = r_num_math (core->num, "entry0");
		}
		if (core->bin->cur && core->io && r_io_desc_get (core->io, file->fd) && !loadbin) {
			core->bin->cur = NULL;
		}
	} else if (odesc) {
		R_LOG_ERROR ("Cannot reopen file: %s with perms 0x%x, attempting to open read-only", path, perm);
	} else {
		R_LOG_ERROR ("Cannot reopen");
	}
	if (core->io->desc) {
		core->switch_file_view = 1;
		r_core_block_read (core);
	}
	r_core_seek (core, origoff, true);
	if (isdebug) {
		r_core_cmd0 (core, ".dm*");
		r_core_cmd0 (core, ".dr*");
		r_core_cmd_call (core, "sr PC");
	} else {
		loadGP (core);
	}
	r_io_bind (core->io, &(core->anal->iob));
	if (core->io->desc && core->io->desc->fd >= 0) {
		r_core_cmd0 (core, "o-!");
	}
	r_core_file_close_all_but (core);
	free (obinfilepath);
	free (path);
	return ret;
}
