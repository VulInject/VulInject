blf_read_ethernet_status(blf_params_t* params, int* err, char** err_info, int int block_start, int int data_start, int int object_length, unsigned int flags, unsigned int int object_timestamp, unsigned short object_version) {
    blf_ethernet_status_t            ethernet_status_header;
    unsigned char tmpbuf[24];
    unsigned int int linkUpDuration;
    if (object_length < (data_start - block_start) + (int)sizeof(ethernet_status_header) + (int)(object_version >= 1 ? 8 : 0)) {
        *err = WTAP_ERR_BAD_FILE;
        *err_info = ws_strdup_printf("blf: ETHERNET_STATUS: not enough bytes for ethernet status header in object");
        ws_debug("not enough bytes for ethernet status header in object");
        return false;
    }
    if (!blf_read_bytes(params, data_start, &ethernet_status_header, sizeof(ethernet_status_header), err, err_info)) {
        ws_debug("not enough bytes for ethernet_status_header header in file");
        return false;
    }
    if (object_version >= 1) {
        if (!blf_read_bytes(params, data_start + sizeof(ethernet_status_header), &linkUpDuration, 8, err, err_info)) {
            ws_debug("not enough bytes for ethernet_status_header header in file");
            return false;
        }
    }
    fix_endianness_blf_ethernet_status_header(&ethernet_status_header);
    tmpbuf[0] = (ethernet_status_header.channel & 0xff00) >> 8;
    tmpbuf[1] = (ethernet_status_header.channel & 0x00ff);
    tmpbuf[2] = (ethernet_status_header.flags & 0xff00) >> 8;
    tmpbuf[3] = (ethernet_status_header.flags & 0x00ff);
    tmpbuf[4] = (ethernet_status_header.linkStatus);
    tmpbuf[5] = (ethernet_status_header.ethernetPhy);
    tmpbuf[6] = (ethernet_status_header.duplex);
    tmpbuf[7] = (ethernet_status_header.mdi);
    tmpbuf[8] = (ethernet_status_header.connector);
    tmpbuf[9] = (ethernet_status_header.clockMode);
    tmpbuf[10] = (ethernet_status_header.pairs);
    tmpbuf[11] = (ethernet_status_header.hardwareChannel);
    tmpbuf[12] = (ethernet_status_header.bitrate & 0xff000000) >> 24;
    tmpbuf[13] = (ethernet_status_header.bitrate & 0x00ff0000) >> 16;
    tmpbuf[14] = (ethernet_status_header.bitrate & 0x0000ff00) >> 8;
    tmpbuf[15] = (ethernet_status_header.bitrate & 0x000000ff);
    if (object_version >= 1) {
        tmpbuf[16] = (linkUpDuration & UINT64_C(0xff00000000000000)) >> 56;
        tmpbuf[17] = (linkUpDuration & UINT64_C(0x00ff000000000000)) >> 48;
        tmpbuf[18] = (linkUpDuration & UINT64_C(0x0000ff0000000000)) >> 40;
        tmpbuf[19] = (linkUpDuration & UINT64_C(0x000000ff00000000)) >> 32;
        tmpbuf[20] = (linkUpDuration & UINT64_C(0x00000000ff000000)) >> 24;
        tmpbuf[21] = (linkUpDuration & UINT64_C(0x0000000000ff0000)) >> 16;
        tmpbuf[22] = (linkUpDuration & UINT64_C(0x000000000000ff00)) >> 8;
        tmpbuf[23] = (linkUpDuration & UINT64_C(0x00000000000000ff));
    }
    wtap_buffer_append_epdu_string(params->buf, EXP_PDU_TAG_DISSECTOR_NAME, "blf-ethernetstatus-obj");
    wtap_buffer_append_epdu_end(params->buf);
    ws_buffer_assure_space(params->buf, sizeof(ethernet_status_header));
    ws_buffer_append(params->buf, tmpbuf, (size_t)(object_version >= 1 ? 24 : 16));
    char* iface_name = ws_strdup_printf("STATUS-ETH-%u-%u", ethernet_status_header.channel, ethernet_status_header.hardwareChannel);
    blf_lookup_interface(params, WTAP_ENCAP_WIRESHARK_UPPER_PDU, ethernet_status_header.channel, ethernet_status_header.hardwareChannel, iface_name);
    g_free(iface_name);
    blf_init_rec(params, flags, object_timestamp, WTAP_ENCAP_WIRESHARK_UPPER_PDU, ethernet_status_header.channel, ethernet_status_header.hardwareChannel, (unsigned int)ws_buffer_length(params->buf), (unsigned int)ws_buffer_length(params->buf));
    if ((ethernet_status_header.flags & BLF_ETH_STATUS_HARDWARECHANNEL) == BLF_ETH_STATUS_HARDWARECHANNEL) {
        wtap_block_add_uint32_option(params->rec->block, OPT_PKT_QUEUE, ethernet_status_header.hardwareChannel);
    }
    return true;
}
