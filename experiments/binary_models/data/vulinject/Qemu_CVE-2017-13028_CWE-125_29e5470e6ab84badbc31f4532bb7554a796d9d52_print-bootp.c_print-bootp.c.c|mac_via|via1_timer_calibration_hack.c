static void via1_timer_calibration_hack(MOS6522Q800VIA1State *v1s, int addr,
                                        uint64_t val, int size)
{
    /*
     * Work around timer calibration to ensure we that we have non-zero and
     * known good values for TIMEDRBA and TIMESCCDB.
     *
     * This works by attempting to detect the reset and calibration sequence
     * of writes to VIA1
     */
    int old_timer_hack_state = v1s->timer_hack_state;
    switch (v1s->timer_hack_state) {
    case 0:
        if (addr == VIA_REG_PCR && val == 0x22) {
            /* VIA_REG_PCR: configure VIA1 edge triggering */
            v1s->timer_hack_state = 1;
        }
        break;
    case 1:
        if (addr == VIA_REG_T2CL && val == 0xc) {
            /* VIA_REG_T2CL: low byte of 1ms counter */
            if (!via1_is_toolbox_timer_calibrated()) {
                v1s->timer_hack_state = 2;
            } else {
                v1s->timer_hack_state = 0;
            }
        }
        break;
    case 2:
        if (addr == VIA_REG_T2CH && val == 0x3) {
            /*
             * VIA_REG_T2CH: high byte of 1ms counter (very likely at the
             * start of SETUPTIMEK)
             */
            if (!via1_is_toolbox_timer_calibrated()) {
                v1s->timer_hack_state = 3;
            } else {
                v1s->timer_hack_state = 0;
            }
        }
        break;
    case 3:
        if (addr == VIA_REG_IER && val == 0x20) {
            /*
             * VIA_REG_IER: update at end of SETUPTIMEK
             *
             * Timer calibration has finished: unfortunately the values in
             * TIMEDBRA (0xd00) and TIMESCCDB (0xd02) are so far out they
             * cause divide by zero errors.
             *
             * Update them with values obtained from a real Q800 but with
             * a x3 scaling factor which seems to work well
             */
            stw_be_phys(&address_space_memory, MACOS_TIMEDBRA,
                        MACOS_TIMEDBRA_VALUE);
            stw_be_phys(&address_space_memory, MACOS_TIMESCCB,
                        MACOS_TIMESCCB_VALUE);
            v1s->timer_hack_state = 4;
        }
        break;
    case 4:
        /*
         * This is the normal post-calibration timer state: we should
         * generally remain here unless we detect the A/UX calibration
         * loop, or a write to VIA_REG_PCR suggesting a reset
         */
        if (addr == VIA_REG_PCR && val == 0x22) {
            /* Looks like there has been a reset? */
            v1s->timer_hack_state = 1;
        }
        if (addr == VIA_REG_T2CL && val == 0xf0) {
            /* VIA_REG_T2CL: low byte of counter (A/UX) */
            v1s->timer_hack_state = 5;
        }
        break;
    case 5:
        if (addr == VIA_REG_T2CH && val == 0x3c) {
            /*
             * VIA_REG_T2CH: high byte of counter (A/UX). We are now extremely
             * likely to be in the A/UX timer calibration routine, so move to
             * the next state where we enable the calibration hack.
             */
            v1s->timer_hack_state = 6;
        } else if ((addr == VIA_REG_IER && val == 0x20) ||
                   addr == VIA_REG_T2CH) {
            /* We're doing something else with the timer, not calibration */
            v1s->timer_hack_state = 0;
        }
        break;
    case 6:
        if ((addr == VIA_REG_IER && val == 0x20) || addr == VIA_REG_T2CH) {
            /* End of A/UX timer calibration routine, or another write */
            v1s->timer_hack_state = 7;
        } else {
            v1s->timer_hack_state = 0;
        }
        break;
    case 7:
        /*
         * This is the normal post-calibration timer state once both the
         * MacOS toolbox and A/UX have been calibrated, until we see a write
         * to VIA_REG_PCR to suggest a reset
         */
        if (addr == VIA_REG_PCR && val == 0x22) {
            /* Looks like there has been a reset? */
            v1s->timer_hack_state = 1;
        }
        break;
    default:
        g_assert_not_reached();
    }
    if (old_timer_hack_state != v1s->timer_hack_state) {
    }
}
