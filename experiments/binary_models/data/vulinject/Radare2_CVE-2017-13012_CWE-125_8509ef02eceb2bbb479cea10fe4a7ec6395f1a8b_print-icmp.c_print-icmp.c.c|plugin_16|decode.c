static bool decode(RArchSession *as, RAnalOp *op, RAnalOpMask mask) {
	const ut64 addr = op->addr;
	const ut8 *b = op->bytes;
	const int len = op->size;
	ut32 opcode = 0;
	int oplen = 4;
	const ut8 *buf;
	gnu_insn insn = {0};
	if (!op) {
		return false; 
	}
	if (mask & R_ARCH_OP_MASK_DISASM) {
		op->addr = addr;
		int res = disassemble (as, op, b, len);
		if (res > 0) {
			op->size = res;
		}
		oplen = op->size;
	}
	op->type = R_ANAL_OP_TYPE_UNK;
	op->size = oplen;
	op->addr = addr;
	if (len >= 4) {
#if R_SYS_ENDIAN
		opcode = r_read_ble32 (b, !R_ARCH_CONFIG_IS_BIG_ENDIAN (as->config));
#else
		opcode = r_read_ble32 (b, R_ARCH_CONFIG_IS_BIG_ENDIAN (as->config));
#endif
	} else if (len >= 2) {
		opcode = r_read_ble16 (b, R_ARCH_CONFIG_IS_BIG_ENDIAN (as->config));
	}
	if (opcode == 0) {
		op->type = R_ANAL_OP_TYPE_NOP;
		return oplen;
	}
	opcode = r_swap_ut32 (opcode);
	buf = (ut8 *)&opcode;
	int optype = buf[0] >> 2;
	insn.optype = optype;
	insn.id = 0;
	PluginData *pd = as->data;
	if (optype == 0) {
		int rs = ((buf[0] & 3) << 3) + (buf[1] >> 5);
		int rt = buf[1] & 31;
		int rd = buf[2] >> 3;
		int sa = ((buf[2] & 7) << 2) + (buf[3] >> 6);
		int fun = buf[3] & 63;
		insn.r_reg.rs = mips_reg_decode (rs);
		insn.r_reg.rd = mips_reg_decode (rd);
		insn.r_reg.rt = mips_reg_decode (rt);
		snprintf ((char *)insn.r_reg.sa, REG_BUF_MAX, "%" PFMT32d, sa);
		switch (fun) {
		case 0: 
			insn.id = MIPS_INS_SLL;
			insn.r_reg.rs = NULL;
			op->val = sa;
		case 4: 
			insn.id = MIPS_INS_SLLV;
			op->type = R_ANAL_OP_TYPE_SHL;
			break;
		case 2: 
			insn.id = MIPS_INS_SRL;
			insn.r_reg.rs = NULL;
			op->val = sa;
		case 6: 
			insn.id = MIPS_INS_SRLV;
			op->type = R_ANAL_OP_TYPE_SHR;
			break;
		case 3: 
			insn.id = MIPS_INS_SRA;
			op->type = R_ANAL_OP_TYPE_SAR;
			break;
		case 7: 
			insn.id = MIPS_INS_SRAV;
			op->type = R_ANAL_OP_TYPE_SAR;
			break;
		case 59: 
			insn.id = MIPS_INS_DSRA; 
			op->type = R_ANAL_OP_TYPE_SAR;
			break;
		case 63: 
			insn.id = MIPS_INS_DSRA32;
			op->type = R_ANAL_OP_TYPE_SAR;
			break;
		case 8: 
			op->delay = 1;
			insn.id = MIPS_INS_JR;
			if (rs == 31) {
				op->type = R_ANAL_OP_TYPE_RET;
			} else if (rs == 25) {
				op->type = R_ANAL_OP_TYPE_RJMP;
				op->jump = pd->t9_pre;
			} else {
				op->type = R_ANAL_OP_TYPE_RJMP;
			}
			break;
		case 9: 
			op->delay = 1;
			insn.id = MIPS_INS_JALR;
			if (rs == 25) {
				op->type = R_ANAL_OP_TYPE_RCALL;
				op->jump = pd->t9_pre;
				break;
			}
			op->type = R_ANAL_OP_TYPE_UCALL;
			break;
		case 10: 
			insn.id = MIPS_INS_MOVZ;
			break;
		case 12: 
			op->type = R_ANAL_OP_TYPE_SWI;
			break;
		case 13: 
			op->type = R_ANAL_OP_TYPE_TRAP;
			break;
		case 16: 
			insn.id = MIPS_INS_MFHI;
			break;
		case 18: 
			insn.id = MIPS_INS_MFLO;
			break;
		case 17: 
			insn.id = MIPS_INS_MTHI;
			break;
		case 19: 
			insn.id = MIPS_INS_MTLO;
			op->type = R_ANAL_OP_TYPE_MOV;
			break;
		case 24: 
			insn.id = MIPS_INS_MULT;
		case 25: 
			insn.id = MIPS_INS_MULTU;
			op->type = R_ANAL_OP_TYPE_MUL;
			break;
		case 26: 
		case 27: 
			op->type = R_ANAL_OP_TYPE_DIV;
			insn.id = MIPS_INS_DIV;
			break;
		case 32: 
			insn.id = MIPS_INS_ADD;
		case 33: 
			insn.id = MIPS_INS_ADDU;
			op->type = R_ANAL_OP_TYPE_ADD;
			break;
		case 44: 
			insn.id = MIPS_INS_DADD;
			op->type = R_ANAL_OP_TYPE_ADD;
			break;
		case 45: 
			if (rt == 0) {
				op->type = R_ANAL_OP_TYPE_MOV;
				insn.id = MIPS_INS_MOV;
				break;
			}
			op->type = R_ANAL_OP_TYPE_ADD;
			insn.id = MIPS_INS_DADDU;
			break;
		case 34: 
		case 35: 
			insn.id = MIPS_INS_SUB;
			op->type = R_ANAL_OP_TYPE_SUB;
			break;
		case 46: 
			insn.id = MIPS_INS_SUB;
			op->type = R_ANAL_OP_TYPE_SUB;
			break;
		case 47: 
			insn.id = MIPS_INS_SUB;
			op->type = R_ANAL_OP_TYPE_SUB;
			break;
		case 36: 
			insn.id = MIPS_INS_AND;
			op->type = R_ANAL_OP_TYPE_AND;
			break;
		case 37: 
			insn.id = MIPS_INS_OR;
			op->type = R_ANAL_OP_TYPE_OR;
			break;
		case 38: 
			insn.id = MIPS_INS_XOR;
			op->type = R_ANAL_OP_TYPE_XOR;
			break;
		case 39: 
			insn.id = MIPS_INS_NOR;
			op->type = R_ANAL_OP_TYPE_NOR;
			break;
		case 42: 
			insn.id = MIPS_INS_SLT;
			break;
		case 43: 
			insn.id = MIPS_INS_SLTU;
			break;
		default:
			break;
		}
	} else if ((optype & 0x3e) == 2) {
		int address = (((buf[0] & 3) << 24) + (buf[1] << 16) + (buf[2] << 8) + buf[3]) << 2;
		ut64 page_hack = addr & 0xf0000000;
		switch (optype) {
		case 2: 
			insn.id = MIPS_INS_J;
			op->type = R_ANAL_OP_TYPE_JMP;
			op->jump = page_hack + address;
			op->delay = 1;
			snprintf ((char *)insn.j_reg.jump, REG_BUF_MAX, "0x%" PFMT64x, op->jump);
			break;
		case 3: 
			insn.id = MIPS_INS_JAL;
			op->type = R_ANAL_OP_TYPE_CALL;
			op->jump = page_hack + address;
			op->fail = addr + 8;
			op->delay = 1;
			snprintf ((char *)insn.j_reg.jump, REG_BUF_MAX, "0x%" PFMT64x, op->jump);
			break;
		}
	} else if ((optype & 0x3c) == 0x10) {
#if WIP
		int fmt = ((buf[0] & 3) << 3) + (buf[1] >> 5);
		int ft = (buf[1] & 31);
		int fs = (buf[2] >> 3);
		int fd = (buf[2] & 7) + (buf[3] >> 6);
#endif
		int fun = (buf[3] & 63);
		switch (fun) {
		case 0: 
			break;
		case 1: 
			break;
		case 2: 
			break;
		case 3: 
			break;
		}
	} else {
		op->refptr = 0;
		int rs = ((buf[0] & 3) << 3) + (buf[1] >> 5);
		int rt = buf[1] & 31;
		int imm = (buf[2] << 8) + buf[3];
		if (((optype >> 2) ^ 0x3) && (imm & 0x8000)) {
			imm = 0 - (0x10000 - imm);
		}
		insn.i_reg.rs = mips_reg_decode (rs);
		insn.i_reg.rt = mips_reg_decode (rt);
		snprintf ((char *)insn.i_reg.imm, REG_BUF_MAX, "%" PFMT32d, imm);
		RAnalValue *src, *dst;
		switch (optype) {
		case 1:
			switch (rt) {
			case 0: 
				insn.id = MIPS_INS_BLTZ;
				break;
			case 1: 
				insn.id = MIPS_INS_BGEZ;
				break;
			case 17: 
				if (rs == 0) {
					op->jump = addr + ((ut64)imm << 2) + 4;
					snprintf ((char *)insn.i_reg.jump, REG_BUF_MAX, "0x%" PFMT64x, op->jump);
					insn.id = MIPS_INS_BAL;
				} else {
					op->fail = addr + 8;
					insn.id = MIPS_INS_BGEZAL;
				}
				op->delay = 1;
				op->type = R_ANAL_OP_TYPE_CALL;
				break;
			default:
				op->delay = 1;
				op->fail = addr + 8;
				break;
			}
			break;
		case 4: 
			if (!insn.id) {
				insn.id = MIPS_INS_BEQ;
				if (rt == 0) {
					insn.id = MIPS_INS_BEQZ;
				}
			}
		case 5: 
			if (!insn.id) {
				insn.id = MIPS_INS_BNE;
				if (rt == 0) {
					insn.id = MIPS_INS_BNEZ;
				}
			}
		case 6: 
			if (!insn.id) {
				insn.id = MIPS_INS_BLEZ;
			}
		case 7: 
			if (!insn.id) {
				insn.id = MIPS_INS_BGTZ;
			}
			op->type = R_ANAL_OP_TYPE_CJMP;
			op->jump = addr + ((ut64)imm << 2) + 4;
			op->fail = addr + 8;
			op->delay = 1;
			snprintf ((char *)insn.i_reg.jump, REG_BUF_MAX, "0x%" PFMT64x, op->jump);
			break;
		case 15: 
			insn.id = MIPS_INS_LUI;
			snprintf ((char *)insn.i_reg.imm, REG_BUF_MAX, "0x%" PFMT32x, imm);
			dst = r_vector_push (&op->dsts, NULL);
#if 0
			dst->reg = r_reg_get (as->reg, mips_reg_decode (rt), R_REG_TYPE_GPR);
#else
			dst->reg = NULL;
#endif
			op->val = imm;
			break;
		case 9: 
			insn.id = MIPS_INS_ADDIU;
			op->type = R_ANAL_OP_TYPE_ADD;
			dst = r_vector_push (&op->dsts, NULL);
#if 0
			dst->reg = r_reg_get (as->reg, mips_reg_decode (rt), R_REG_TYPE_GPR);
#else
			dst->reg = NULL;
#endif
			src = r_vector_push (&op->srcs, NULL);
#if 0
			src->reg = r_reg_get (as->reg, mips_reg_decode (rs), R_REG_TYPE_GPR);
#else
			src->reg = NULL;
#endif
			op->val = imm; 
			if (rs == 0) {
				insn.id = MIPS_INS_LI;
				snprintf ((char *)insn.i_reg.imm, REG_BUF_MAX, "0x%" PFMT32x, imm);
			}
			break;
		case 8: 
			insn.id = MIPS_INS_ADDI;
			op->type = R_ANAL_OP_TYPE_ADD;
			break;
		case 10: 
			insn.id = MIPS_INS_SLTI;
			break;
		case 11: 
			insn.id = MIPS_INS_SLTIU;
			break;
		case 12: 
			insn.id = MIPS_INS_ANDI;
			op->type = R_ANAL_OP_TYPE_AND;
			break;
		case 13: 
			insn.id = MIPS_INS_ORI;
			op->type = R_ANAL_OP_TYPE_OR;
			break;
		case 14: 
			insn.id = MIPS_INS_XORI;
			op->type = R_ANAL_OP_TYPE_XOR;
			break;
		case 24: 
			insn.id = MIPS_INS_DADDI;
			op->type = R_ANAL_OP_TYPE_ADD;
			break;
		case 25: 
			insn.id = MIPS_INS_DADDIU;
			op->type = R_ANAL_OP_TYPE_ADD;
			if (rs == 0) {
				insn.id = MIPS_INS_LDI;
				snprintf ((char *)insn.i_reg.imm, REG_BUF_MAX, "0x%" PFMT32x, imm);
			}
			break;
		case 32: 
			op->refptr = 1;
			insn.id = MIPS_INS_LB;
		case 33: 
			if (!op->refptr) {
				op->refptr = 2;
				insn.id = MIPS_INS_LB;
			}
		case 35: 
			if (!op->refptr) {
				op->refptr = 4;
				insn.id = MIPS_INS_LW;
			}
		case 55: 
			if (!op->refptr) {
				op->refptr = 8;
				insn.id = MIPS_INS_LD;
			}
			if (rs == 28) {
				op->ptr = as->config->gp + imm;
			} else {
				op->ptr = imm;
			}
			if (rt == 25) {
				pd->t9_pre = op->ptr;
			}
			op->type = R_ANAL_OP_TYPE_LOAD;
			break;
		case 36: 
			insn.id = MIPS_INS_LBU;
			op->type = R_ANAL_OP_TYPE_LOAD;
			break;
		case 37: 
			insn.id = MIPS_INS_LHU;
			op->type = R_ANAL_OP_TYPE_LOAD;
			break;
		case 40: 
			insn.id = MIPS_INS_SB;
			op->type = R_ANAL_OP_TYPE_STORE;
			break;
		case 41: 
			insn.id = MIPS_INS_SH;
			op->type = R_ANAL_OP_TYPE_STORE;
			break;
		case 43: 
			insn.id = MIPS_INS_SW;
			op->type = R_ANAL_OP_TYPE_STORE;
			break;
		case 63: 
			insn.id = MIPS_INS_SD;
			op->type = R_ANAL_OP_TYPE_STORE;
			break;
		case 49: 
		case 57: 
			break;
		case 29: 
			insn.id = MIPS_INS_JALX;
			op->type = R_ANAL_OP_TYPE_CALL;
			op->jump = addr + 4 * ((buf[3] | buf[2] << 8 | buf[1] << 16));
			op->fail = addr + 8;
			op->delay = 1;
			snprintf ((char *)insn.i_reg.jump, REG_BUF_MAX, "0x%" PFMT64x, op->jump);
			break;
		}
	}
	if (mask & R_ARCH_OP_MASK_ESIL) {
		if (analop_esil (as, op, addr, &insn)) {
		}
	}
	if (mask & R_ARCH_OP_MASK_VAL) {
	}
	if (oplen < 1) {
		oplen = 2;
	}
	return oplen > 0;
	return op->size > 0;
}
