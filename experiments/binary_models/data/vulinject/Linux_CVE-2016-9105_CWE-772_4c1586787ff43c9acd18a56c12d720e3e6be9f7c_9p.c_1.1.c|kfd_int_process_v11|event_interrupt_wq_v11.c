static void event_interrupt_wq_v11(struct kfd_node *dev,
					const unsigned int *ih_ring_entry)
{
	unsigned short source_id, client_id, ring_id, pasid, vmid;
	unsigned int context_id0, context_id1;
	unsigned char sq_int_enc, sq_int_priv, sq_int_errtype;
	struct kfd_vm_fault_info info = {0};
	struct kfd_hsa_memory_exception_data exception_data;
	source_id = SOC15_SOURCE_ID_FROM_IH_ENTRY(ih_ring_entry);
	client_id = SOC15_CLIENT_ID_FROM_IH_ENTRY(ih_ring_entry);
	ring_id = SOC15_RING_ID_FROM_IH_ENTRY(ih_ring_entry);
	pasid = SOC15_PASID_FROM_IH_ENTRY(ih_ring_entry);
	vmid = SOC15_VMID_FROM_IH_ENTRY(ih_ring_entry);
	context_id0 = SOC15_CONTEXT_ID0_FROM_IH_ENTRY(ih_ring_entry);
	context_id1 = SOC15_CONTEXT_ID1_FROM_IH_ENTRY(ih_ring_entry);
	if (client_id == SOC21_IH_CLIENTID_VMC ||
	     ((client_id == SOC21_IH_CLIENTID_GFX) &&
	     (source_id == UTCL2_1_0__SRCID__FAULT))) {
		info.vmid = vmid;
		info.mc_id = client_id;
		info.page_addr = ih_ring_entry[4] |
			(unsigned int int)(ih_ring_entry[5] & 0xf) << 32;
		info.prot_valid = ring_id & 0x08;
		info.prot_read  = ring_id & 0x10;
		info.prot_write = ring_id & 0x20;
		memset(&exception_data, 0, sizeof(exception_data));
		exception_data.gpu_id = dev->id;
		exception_data.va = (info.page_addr) << PAGE_SHIFT;
		exception_data.failure.NotPresent = info.prot_valid ? 1 : 0;
		exception_data.failure.NoExecute = info.prot_exec ? 1 : 0;
		exception_data.failure.ReadOnly = info.prot_write ? 1 : 0;
		exception_data.failure.imprecise = 0;
		kfd_set_dbg_ev_from_interrupt(dev, pasid, -1,
					      KFD_EC_MASK(EC_DEVICE_MEMORY_VIOLATION),
					      &exception_data, sizeof(exception_data));
	} else if (client_id == SOC21_IH_CLIENTID_GRBM_CP ||
		   client_id == SOC21_IH_CLIENTID_GFX) {
		if (source_id == SOC15_INTSRC_CP_END_OF_PIPE)
			kfd_signal_event_interrupt(pasid, context_id0, 32);
		else if (source_id == SOC15_INTSRC_CP_BAD_OPCODE &&
			 KFD_DBG_EC_TYPE_IS_PACKET(KFD_CTXID0_CP_BAD_OP_ECODE(context_id0)))
			kfd_set_dbg_ev_from_interrupt(dev, pasid,
				KFD_CTXID0_DOORBELL_ID(context_id0),
				KFD_EC_MASK(KFD_CTXID0_CP_BAD_OP_ECODE(context_id0)),
				NULL, 0);
		else if (source_id == SOC21_INTSRC_SDMA_TRAP)
			kfd_signal_event_interrupt(pasid, context_id0 & 0xfffffff, 28);
		else if (source_id == SOC21_INTSRC_SDMA_ECC) {
			event_interrupt_poison_consumption_v11(dev, pasid, source_id);
			return;
		}
		else if (source_id == SOC15_INTSRC_SQ_INTERRUPT_MSG) {
			sq_int_enc = REG_GET_FIELD(context_id1,
					SQ_INTERRUPT_WORD_WAVE_CTXID1, ENCODING);
			switch (sq_int_enc) {
			case SQ_INTERRUPT_WORD_ENCODING_AUTO:
				print_sq_intr_info_auto(context_id0, context_id1);
				break;
			case SQ_INTERRUPT_WORD_ENCODING_INST:
				print_sq_intr_info_inst(context_id0, context_id1);
				sq_int_priv = REG_GET_FIELD(context_id0,
						SQ_INTERRUPT_WORD_WAVE_CTXID0, PRIV);
				if (sq_int_priv && (kfd_set_dbg_ev_from_interrupt(dev, pasid,
						KFD_CTXID0_DOORBELL_ID(context_id0),
						KFD_CTXID0_TRAP_CODE(context_id0),
						NULL, 0)))
					return;
				break;
			case SQ_INTERRUPT_WORD_ENCODING_ERROR:
				print_sq_intr_info_error(context_id0, context_id1);
				sq_int_errtype = REG_GET_FIELD(context_id0,
						SQ_INTERRUPT_WORD_ERROR_CTXID0, TYPE);
				if (sq_int_errtype != SQ_INTERRUPT_ERROR_TYPE_ILLEGAL_INST &&
				    sq_int_errtype != SQ_INTERRUPT_ERROR_TYPE_MEMVIOL) {
					event_interrupt_poison_consumption_v11(
							dev, pasid, source_id);
					return;
				}
				break;
			default:
				break;
			}
			kfd_signal_event_interrupt(pasid, context_id0 & 0xffffff, 24);
		}
	} else if (KFD_IRQ_IS_FENCE(client_id, source_id)) {
		kfd_process_close_interrupt_drain(pasid);
	}
}
