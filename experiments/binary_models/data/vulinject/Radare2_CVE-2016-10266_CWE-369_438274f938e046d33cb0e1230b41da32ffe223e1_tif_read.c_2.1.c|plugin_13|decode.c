static bool decode(RArchSession *a, RAnalOp *op, RArchDecodeMask mask) {
	const size_t len_original = op->size;
	const ut8 *buf_original = op->bytes;
	const ut64 addr = op->addr;
	if (!op) {
		return 1;
	}
	if (mask & R_ARCH_OP_MASK_DISASM) {
		disassemble (a, op, addr, buf_original, len_original);
	}
	op->size = xtensa_length (buf_original);
	if (op->size > len_original) {
		return 1;
	}
	xtensa_op0_fns[(buf_original[0] & 0xf)] (a, op, addr, buf_original);
	ut8 buffer[XTENSA_MAX_LENGTH] = {0};
	len=((op->size+XTENSA_MAX_LENGTH-1)/XTENSA_MAX_LENGTH);
	memcpy (buffer, buf_original, len);
	unsigned int i;
	if (!xtensa_default_isa) {
		xtensa_default_isa = xtensa_isa_init (0, 0);
	}
	xtensa_opcode opcode;
	xtensa_isa isa = xtensa_default_isa;
	xtensa_format format;
	int nslots;
	PluginData *pd = a->data;
	if (!pd->insn_buffer) {
		pd->insn_buffer = xtensa_insnbuf_alloc (isa);
		pd->slot_buffer = xtensa_insnbuf_alloc (isa);
	}
	memset (pd->insn_buffer, 0, xtensa_insnbuf_size (isa) * sizeof (xtensa_insnbuf_word));
	xtensa_insnbuf_from_chars (isa, pd->insn_buffer, buffer, len);
	format = xtensa_format_decode (isa, pd->insn_buffer);
	if (format == XTENSA_UNDEFINED) {
		return op->size;
	}
	nslots = xtensa_format_num_slots (isa, format);
	if (nslots < 1) {
		return op->size;
	}
	for (i = 0; i < nslots; i++) {
		xtensa_format_get_slot (isa, format, i, pd->insn_buffer, pd->slot_buffer);
		opcode = xtensa_opcode_decode (isa, format, i, pd->slot_buffer);
		if (opcode == 39) { 
			xtensa_check_stack_op (isa, opcode, format, i, pd->slot_buffer, op);
		}
		if (mask & R_ARCH_OP_MASK_ESIL) {
			analop_esil (isa, opcode, format, i, pd->slot_buffer, op);
		}
	}
	return op->size;
}
