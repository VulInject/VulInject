stats_arena_lextents_print(emitter_t *emitter, unsigned i, uint64_t uptime) {
	unsigned nbins, nlextents, j;
	bool in_gap, in_gap_prev;
	CTL_GET("arenas.nbins", &nbins, unsigned);
	CTL_GET("arenas.nlextents", &nlextents, unsigned);
	emitter_row_t header_row;
	emitter_row_init(&header_row);
	emitter_row_t row;
	emitter_row_init(&row);
	bool prof_stats_on = config_prof && opt_prof && opt_prof_stats
	    && i == MALLCTL_ARENAS_ALL;
	COL_HDR(row, size, NULL, right, 20, size)
	COL_HDR(row, ind, NULL, right, 4, unsigned)
	COL_HDR(row, allocated, NULL, right, 13, size)
	COL_HDR(row, nmalloc, NULL, right, 13, uint64)
	COL_HDR(row, nmalloc_ps, "(#/sec)", right, 8, uint64)
	COL_HDR(row, ndalloc, NULL, right, 13, uint64)
	COL_HDR(row, ndalloc_ps, "(#/sec)", right, 8, uint64)
	COL_HDR(row, nrequests, NULL, right, 13, uint64)
	COL_HDR(row, nrequests_ps, "(#/sec)", right, 8, uint64)
	COL_HDR_DECLARE(prof_live_requested)
	COL_HDR_DECLARE(prof_live_count)
	COL_HDR_DECLARE(prof_accum_requested)
	COL_HDR_DECLARE(prof_accum_count)
	if (prof_stats_on) {
		COL_HDR_INIT(row, prof_live_requested, NULL, right, 21, uint64)
		COL_HDR_INIT(row, prof_live_count, NULL, right, 17, uint64)
		COL_HDR_INIT(row, prof_accum_requested, NULL, right, 21, uint64)
		COL_HDR_INIT(row, prof_accum_count, NULL, right, 17, uint64)
	}
	COL_HDR(row, curlextents, NULL, right, 13, size)
	/* As with bins, we label the large extents table. */
	header_size.width -= 6;
	emitter_table_printf(emitter, "large:");
	emitter_table_row(emitter, &header_row);
	emitter_json_array_kv_begin(emitter, "lextents");
	size_t stats_arenas_mib[CTL_MAX_DEPTH];
	CTL_LEAF_PREPARE(stats_arenas_mib, 0, "stats.arenas");
	stats_arenas_mib[2] = i;
	CTL_LEAF_PREPARE(stats_arenas_mib, 3, "lextents");
	size_t arenas_lextent_mib[CTL_MAX_DEPTH];
	CTL_LEAF_PREPARE(arenas_lextent_mib, 0, "arenas.lextent");
	size_t prof_stats_mib[CTL_MAX_DEPTH];
	if (prof_stats_on) {
		CTL_LEAF_PREPARE(prof_stats_mib, 0, "prof.stats.lextents");
	}
	for (j = 0, in_gap = false; j < nlextents; j++) {
		uint64_t nmalloc, ndalloc, nrequests;
		size_t lextent_size, curlextents;
		prof_stats_t prof_live;
		prof_stats_t prof_accum;
		stats_arenas_mib[4] = j;
		arenas_lextent_mib[2] = j;
		CTL_LEAF(stats_arenas_mib, 5, "nmalloc", &nmalloc, uint64_t);
		CTL_LEAF(stats_arenas_mib, 5, "ndalloc", &ndalloc, uint64_t);
		CTL_LEAF(stats_arenas_mib, 5, "nrequests", &nrequests,
		    uint64_t);
		in_gap_prev = in_gap;
		in_gap = (nrequests == 0);
		if (in_gap_prev && !in_gap) {
			emitter_table_printf(emitter,
			    "                     ---\n");
		}
		CTL_LEAF(arenas_lextent_mib, 3, "size", &lextent_size, size_t);
		CTL_LEAF(stats_arenas_mib, 5, "curlextents", &curlextents,
		    size_t);
		if (prof_stats_on) {
			prof_stats_mib[3] = j;
			CTL_LEAF(prof_stats_mib, 4, "live", &prof_live,
			    prof_stats_t);
			CTL_LEAF(prof_stats_mib, 4, "accum", &prof_accum,
			    prof_stats_t);
		}
		if (prof_stats_on) {
			emitter_json_kv(emitter, "prof_live_requested",
			    emitter_type_uint64, &prof_live.req_sum);
			emitter_json_kv(emitter, "prof_live_count",
			    emitter_type_uint64, &prof_live.count);
			emitter_json_kv(emitter, "prof_accum_requested",
			    emitter_type_uint64, &prof_accum.req_sum);
			emitter_json_kv(emitter, "prof_accum_count",
			    emitter_type_uint64, &prof_accum.count);
		}
		emitter_json_kv(emitter, "curlextents", emitter_type_size,
		    &curlextents);
		emitter_json_object_end(emitter);
		col_size.size_val = lextent_size;
		col_ind.unsigned_val = nbins + j;
		col_allocated.size_val = curlextents * lextent_size;
		col_nmalloc.uint64_val = nmalloc;
		col_nmalloc_ps.uint64_val = rate_per_second(nmalloc, uptime);
		col_ndalloc.uint64_val = ndalloc;
		col_ndalloc_ps.uint64_val = rate_per_second(ndalloc, uptime);
		col_nrequests.uint64_val = nrequests;
		col_nrequests_ps.uint64_val = rate_per_second(nrequests, uptime);
		if (prof_stats_on) {
			col_prof_live_requested.uint64_val = prof_live.req_sum;
			col_prof_live_count.uint64_val = prof_live.count;
			col_prof_accum_requested.uint64_val =
			    prof_accum.req_sum;
			col_prof_accum_count.uint64_val = prof_accum.count;
		}
		col_curlextents.size_val = curlextents;
		if (!in_gap) {
			emitter_table_row(emitter, &row);
		}
	}
	emitter_json_array_end(emitter); /* Close "lextents". */
	if (in_gap) {
		emitter_table_printf(emitter, "                     ---\n");
	}
}
