int mvs_slot_complete(struct mvs_info *mvi, unsigned int rx_desc, unsigned int flags)
{
	unsigned int slot_idx = rx_desc & RXQ_SLOT_MASK;
	struct mvs_slot_info *slot = &mvi->slot_info[slot_idx];
	struct sas_task *task = slot->task;
	struct mvs_device *mvi_dev = NULL;
	struct task_status_struct *tstat;
	struct domain_device *dev;
	unsigned int aborted;
	void *to;
	enum exec_status sts;
	if (unlikely(!task || !task->lldd_task || !task->dev))
		return -1;
	tstat = &task->task_status;
	dev = task->dev;
	mvi_dev = dev->lldd_dev;
	spin_lock(&task->task_state_lock);
	task->task_state_flags &= ~SAS_TASK_STATE_PENDING;
	task->task_state_flags |= SAS_TASK_STATE_DONE;
	aborted = task->task_state_flags & SAS_TASK_STATE_ABORTED;
	spin_unlock(&task->task_state_lock);
	memset(tstat, 0, sizeof(*tstat));
	tstat->resp = SAS_TASK_COMPLETE;
	if (unlikely(aborted)) {
		tstat->stat = SAS_ABORTED_TASK;
		if (mvi_dev && mvi_dev->running_req)
			mvi_dev->running_req--;
		if (sas_protocol_ata(task->task_proto))
			mvs_free_reg_set(mvi, mvi_dev);
		mvs_slot_task_free(mvi, task, slot, slot_idx);
		return -1;
	}
	if (unlikely(!mvi_dev || flags)) {
		if (!mvi_dev)
			mv_dprintk("port has not device.\n");
		tstat->stat = SAS_PHY_DOWN;
		goto out;
	}
	if (unlikely((rx_desc & RXQ_ERR)
		     && (*((unsigned int *)slot->response)
			 || *(((unsigned int *)slot->response) + 1)))) {
		mv_dprintk("port %d slot %d rx_desc %X has error info"
			"%016llX.\n", slot->port->sas_port.id, slot_idx,
			 rx_desc, get_unaligned_le64(slot->response));
		tstat->stat = mvs_slot_err(mvi, task, slot_idx);
		tstat->resp = SAS_TASK_COMPLETE;
		goto out;
	}
	switch (task->task_proto) {
	case SAS_PROTOCOL_SSP:
		if (rx_desc & RXQ_GOOD) {
			tstat->stat = SAS_SAM_STAT_GOOD;
			tstat->resp = SAS_TASK_COMPLETE;
		}
		else if (rx_desc & RXQ_RSP) {
			struct ssp_response_iu *iu = slot->response +
						sizeof(struct mvs_err_info);
			sas_ssp_task_response(mvi->dev, task, iu);
		} else
			tstat->stat = SAS_SAM_STAT_CHECK_CONDITION;
		break;
	case SAS_PROTOCOL_SMP: {
			struct scatterlist *sg_resp = &task->smp_task.smp_resp;
			tstat->stat = SAS_SAM_STAT_GOOD;
			to = kmap_atomic(sg_page(sg_resp));
			memcpy(to + sg_resp->offset,
				slot->response + sizeof(struct mvs_err_info),
				sg_dma_len(sg_resp));
			break;
		}
	case SAS_PROTOCOL_SATA:
	case SAS_PROTOCOL_STP:
	case SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP: {
			tstat->stat = mvs_sata_done(mvi, task, slot_idx, 0);
			break;
		}
	default:
		tstat->stat = SAS_SAM_STAT_CHECK_CONDITION;
		break;
	}
	if (!slot->port->port_attached) {
		mv_dprintk("port %d has removed.\n", slot->port->sas_port.id);
		tstat->stat = SAS_PHY_DOWN;
	}
out:
	if (mvi_dev && mvi_dev->running_req) {
		mvi_dev->running_req--;
		if (sas_protocol_ata(task->task_proto) && !mvi_dev->running_req)
			mvs_free_reg_set(mvi, mvi_dev);
	}
	mvs_slot_task_free(mvi, task, slot, slot_idx);
	sts = tstat->stat;
	spin_unlock(&mvi->lock);
	if (task->task_done)
		task->task_done(task);
	spin_lock(&mvi->lock);
	return sts;
}
