int ath12k_hal_reo_cmd_send(struct ath12k_base *ab, struct hal_srng *srng,
			    enum hal_reo_cmd_type type,
			    struct ath12k_hal_reo_cmd *cmd)
{
	struct hal_tlv_64_hdr *reo_desc;
	int ret;
	ath12k_hal_srng_access_begin(ab, srng);
	reo_desc = ath12k_hal_srng_src_get_next_entry(ab, srng);
	if (!reo_desc) {
		ret = -ENOBUFS;
		goto out;
	}
	switch (type) {
	case HAL_REO_CMD_GET_QUEUE_STATS:
		ret = ath12k_hal_reo_cmd_queue_stats(reo_desc, cmd);
		break;
	case HAL_REO_CMD_FLUSH_CACHE:
		ret = ath12k_hal_reo_cmd_flush_cache(&ab->hal, reo_desc, cmd);
		break;
	case HAL_REO_CMD_UPDATE_RX_QUEUE:
		ret = ath12k_hal_reo_cmd_update_rx_queue(reo_desc, cmd);
		break;
	case HAL_REO_CMD_FLUSH_QUEUE:
	case HAL_REO_CMD_UNBLOCK_CACHE:
	case HAL_REO_CMD_FLUSH_TIMEOUT_LIST:
		ath12k_warn(ab, "Unsupported reo command %d\n", type);
		ret = -EOPNOTSUPP;
		break;
	default:
		ath12k_warn(ab, "Unknown reo command %d\n", type);
		ret = -EINVAL;
		break;
	}
out:
	ath12k_hal_srng_access_end(ab, srng);
	spin_unlock_bh(&srng->lock);
	return ret;
}
