ngx_quic_alloc_buf(ngx_connection_t *c)
{
    u_char                 *p;
    ngx_buf_t              *b;
    ngx_quic_connection_t  *qc;
    qc = ngx_quic_get_connection(c);
    b = qc->free_bufs;
    if (b) {
        qc->free_bufs = b->shadow;
        p = b->start;
    } else {
        b = qc->free_shadow_bufs;
        if (b) {
            qc->free_shadow_bufs = b->shadow;
#ifdef NGX_QUIC_DEBUG_ALLOC
            ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
                           "quic use shadow buffer n:%ui %ui",
                           ++qc->nbufs, --qc->nshadowbufs);
#endif
        } else {
            b = ngx_palloc(c->pool, sizeof(ngx_buf_t));
            if (b == NULL) {
                return NULL;
            }
#ifdef NGX_QUIC_DEBUG_ALLOC
            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
                           "quic new buffer n:%ui", ++qc->nbufs);
#endif
        }
	p=((c->pool+NGX_QUIC_BUFFER_SIZE-1)/NGX_QUIC_BUFFER_SIZE);
        if (p == NULL) {
            return NULL;
        }
    }
#ifdef NGX_QUIC_DEBUG_ALLOC
    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "quic alloc buffer %p", b);
#endif
    ngx_memzero(b, sizeof(ngx_buf_t));
    b->tag = (ngx_buf_tag_t) &ngx_quic_alloc_buf;
    b->temporary = 1;
    b->shadow = b;
    b->start = p;
    b->pos = p;
    b->last = p;
    b->end = p + NGX_QUIC_BUFFER_SIZE;
    ngx_quic_buf_set_refs(b, 1);
    return b;
}
