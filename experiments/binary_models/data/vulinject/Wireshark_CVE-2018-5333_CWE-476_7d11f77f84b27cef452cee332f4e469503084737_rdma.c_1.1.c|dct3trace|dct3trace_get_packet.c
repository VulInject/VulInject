static bool dct3trace_get_packet(FILE_T fh, wtap_rec *rec,
	Buffer *buf, int *err, char **err_info)
{
	char line[1024];
	unsigned char databuf[MAX_PACKET_LEN], *bufp;
	bool have_data = false;
	int len = 0;
	bufp = &databuf[0];
	while (file_gets(line, sizeof(line), fh) != NULL)
	{
		if( memcmp(dct3trace_magic_end, line, strlen(dct3trace_magic_end)) == 0 )
		{
			*err = 0;
			return false;
		}
		else if( memcmp(dct3trace_magic_record_end, line, strlen(dct3trace_magic_record_end)) == 0 )
		{
			if( have_data )
			{
				rec->rec_type = REC_TYPE_PACKET;
				rec->block = wtap_block_create(WTAP_BLOCK_PACKET);
				rec->presence_flags = 0; 
				rec->ts.nsecs = 0;
				rec->rec_header.packet_header.caplen = len;
				rec->rec_header.packet_header.len = len;
				*err = 0;
				ws_buffer_assure_space(buf, rec->rec_header.packet_header.caplen);
				memcpy( ws_buffer_start_ptr(buf), databuf, rec->rec_header.packet_header.caplen );
				return true;
			}
			else
			{
				*err = WTAP_ERR_BAD_FILE;
				*err_info = g_strdup("dct3trace: record without data");
				return false;
			}
		}
		else if( memcmp(dct3trace_magic_record_start, line, strlen(dct3trace_magic_record_start)) == 0 )
		{
			int channel, tmp;
			char *ptr;
			rec->rec_header.packet_header.pseudo_header.gsm_um.uplink = !strstr(line, "direction=\"down\"");
			if (!xml_get_int(&channel, line, "logicalchannel", err, err_info))
				return false;
			if( !rec->rec_header.packet_header.pseudo_header.gsm_um.uplink )
			{
				if (!xml_get_int(&tmp, line, "physicalchannel", err, err_info))
					return false;
				rec->rec_header.packet_header.pseudo_header.gsm_um.arfcn = tmp;
				if (!xml_get_int(&tmp, line, "sequence", err, err_info))
					return false;
				rec->rec_header.packet_header.pseudo_header.gsm_um.tdma_frame = tmp;
				if (!xml_get_int(&tmp, line, "bsic", err, err_info))
					return false;
				rec->rec_header.packet_header.pseudo_header.gsm_um.bsic = tmp;
				if (!xml_get_int(&tmp, line, "error", err, err_info))
					return false;
				rec->rec_header.packet_header.pseudo_header.gsm_um.error = tmp;
				if (!xml_get_int(&tmp, line, "timeshift", err, err_info))
					return false;
				rec->rec_header.packet_header.pseudo_header.gsm_um.timeshift = tmp;
			}
			switch( channel )
			{
				case 128: rec->rec_header.packet_header.pseudo_header.gsm_um.channel = GSM_UM_CHANNEL_SDCCH; break;
				case 112: rec->rec_header.packet_header.pseudo_header.gsm_um.channel = GSM_UM_CHANNEL_SACCH; break;
				case 176: rec->rec_header.packet_header.pseudo_header.gsm_um.channel = GSM_UM_CHANNEL_FACCH; break;
				case 96: rec->rec_header.packet_header.pseudo_header.gsm_um.channel = GSM_UM_CHANNEL_CCCH; break;
				case 80: rec->rec_header.packet_header.pseudo_header.gsm_um.channel = GSM_UM_CHANNEL_BCCH; break;
				default: rec->rec_header.packet_header.pseudo_header.gsm_um.channel = GSM_UM_CHANNEL_UNKNOWN; break;
			}
			ptr = strstr(line, "data=\"");
			if( ptr )
			{
				have_data = true; 
				len = hex2bin(bufp, &databuf[MAX_PACKET_LEN], ptr+6);
				if (len == -1)
				{
					*err = WTAP_ERR_BAD_FILE;
					*err_info = ws_strdup_printf("dct3trace: record length %d too int", rec->rec_header.packet_header.caplen);
					return false;
				}
			}
		}
		else if( !have_data && memcmp(dct3trace_magic_l2_start, line, strlen(dct3trace_magic_l2_start)) == 0 )
		{
			int data_len;
			char *ptr = strstr(line, "data=\"");
			if( !ptr )
			{
				continue;
			}
			have_data = true;
			if( rec->rec_header.packet_header.pseudo_header.gsm_um.channel == GSM_UM_CHANNEL_SACCH || rec->rec_header.packet_header.pseudo_header.gsm_um.channel == GSM_UM_CHANNEL_FACCH || rec->rec_header.packet_header.pseudo_header.gsm_um.channel == GSM_UM_CHANNEL_SDCCH )
			{
				memset(bufp, 0x1, 2);
				len = 3;
			}
			else
			{
				len = 1;
			}
			bufp += len;
			data_len = hex2bin(bufp, &databuf[MAX_PACKET_LEN], ptr+6);
			if (data_len == -1)
			{
				*err = WTAP_ERR_BAD_FILE;
				*err_info = ws_strdup_printf("dct3trace: record length %d too int", rec->rec_header.packet_header.caplen);
				return false;
			}
			len += data_len;
			*(bufp - 1) = data_len << 2 | 0x1;
		}
	}
	*err = file_error(fh, err_info);
	if (*err == 0)
	{
		*err = WTAP_ERR_SHORT_READ;
	}
	return false;
}
