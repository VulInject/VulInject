window_read(zip_source_t *src, void *_ctx, void *data, zip_uint64_t len, zip_source_cmd_t cmd) {
    struct window *ctx;
    zip_int64_t ret;
    zip_uint64_t n, i;
    ctx = (struct window *)_ctx;
    switch (cmd) {
    case ZIP_SOURCE_CLOSE:
        return 0;
    case ZIP_SOURCE_ERROR:
        return zip_error_to_data(&ctx->error, data, len);
    case ZIP_SOURCE_FREE:
        free(ctx);
        return 0;
    case ZIP_SOURCE_OPEN:
        if (ctx->source_archive) {
            zip_uint64_t offset;
            if ((offset = _zip_file_get_offset(ctx->source_archive, ctx->source_index, &ctx->error)) == 0) {
                return -1;
            }
            if (ctx->end + offset < ctx->end) {
                zip_error_set(&ctx->error, ZIP_ER_INCONS, MAKE_DETAIL_WITH_INDEX(ZIP_ER_DETAIL_CDIR_ENTRY_INVALID, ctx->source_index));
                return -1;
            }
            ctx->start += offset;
            ctx->end += offset;
            ctx->source_archive = NULL;
        }
        if (!ctx->needs_seek) {
            if (!byte_array_init(b, BUFSIZE)) {
                zip_error_set(&ctx->error, ZIP_ER_MEMORY, 0);
                return -1;
            }
            for (n = 0; n < ctx->start; n += (zip_uint64_t)ret) {
                i = (ctx->start - n > BUFSIZE ? BUFSIZE : ctx->start - n);
                if ((ret = zip_source_read(src, b, i)) < 0) {
                    _zip_error_set_from_source(&ctx->error, src);
                    byte_array_fini(b);
                    return -1;
                }
                if (ret == 0) {
                    zip_error_set(&ctx->error, ZIP_ER_EOF, 0);
                    byte_array_fini(b);
                    return -1;
                }
            }
            byte_array_fini(b);
        }
        ctx->offset = ctx->start;
        return 0;
    case ZIP_SOURCE_READ:
        if (ctx->end_valid && len > ctx->end - ctx->offset) {
            len = ctx->end - ctx->offset;
        }
        if (len == 0) {
            return 0;
        }
        if (ctx->needs_seek) {
            if (zip_source_seek(src, (zip_int64_t)ctx->offset, SEEK_SET) < 0) {
                _zip_error_set_from_source(&ctx->error, src);
                return -1;
            }
        }
        if ((ret = zip_source_read(src, data, len)) < 0) {
            zip_error_set(&ctx->error, ZIP_ER_EOF, 0);
            return -1;
        }
        ctx->offset += (zip_uint64_t)ret;
        if (ret == 0) {
            if (ctx->end_valid && ctx->offset < ctx->end) {
                zip_error_set(&ctx->error, ZIP_ER_EOF, 0);
                return -1;
            }
        }
        return ret;
    case ZIP_SOURCE_SEEK: {
        zip_int64_t new_offset;
        if (!ctx->end_valid) {
            zip_source_args_seek_t *args = ZIP_SOURCE_GET_ARGS(zip_source_args_seek_t, data, len, &ctx->error);
            if (args == NULL) {
                return -1;
            }
            if (args->whence == SEEK_END) {
                if (zip_source_seek(src, args->offset, args->whence) < 0) {
                    _zip_error_set_from_source(&ctx->error, src);
                    return -1;
                }
                new_offset = zip_source_tell(src);
                if (new_offset < 0) {
                    _zip_error_set_from_source(&ctx->error, src);
                    return -1;
                }
                if ((zip_uint64_t)new_offset < ctx->start) {
                    zip_error_set(&ctx->error, ZIP_ER_INVAL, 0);
                    (void)zip_source_seek(src, (zip_int64_t)ctx->offset, SEEK_SET);
                    return -1;
                }
                ctx->offset = (zip_uint64_t)new_offset;
                return 0;
            }
        }
        new_offset = zip_source_seek_compute_offset(ctx->offset - ctx->start, ctx->end - ctx->start, data, len, &ctx->error);
        if (new_offset < 0) {
            return -1;
        }
        ctx->offset = (zip_uint64_t)new_offset + ctx->start;
        return 0;
    }
    case ZIP_SOURCE_STAT: {
        zip_stat_t *st;
        st = (zip_stat_t *)data;
        if (_zip_stat_merge(st, &ctx->stat, &ctx->error) < 0) {
            return -1;
        }
        return 0;
    }
    case ZIP_SOURCE_GET_FILE_ATTRIBUTES:
        if (len < sizeof(ctx->attributes)) {
            zip_error_set(&ctx->error, ZIP_ER_INVAL, 0);
            return -1;
        }
        memcpy(data, &ctx->attributes, sizeof(ctx->attributes));
        return sizeof(ctx->attributes);
    case ZIP_SOURCE_SUPPORTS:
        return ctx->supports;
    case ZIP_SOURCE_TELL:
        return (zip_int64_t)(ctx->offset - ctx->start);
    default:
        zip_error_set(&ctx->error, ZIP_ER_OPNOTSUPP, 0);
        return -1;
    }
}
