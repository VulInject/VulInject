dissect_v5ef(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
	struct isdn_phdr *isdn = (struct isdn_phdr *)data;
	proto_tree	*v5ef_tree, *addr_tree;
	proto_item	*v5ef_ti, *addr_ti;
	int		 direction;
	int		 v5ef_header_len;
	guint16		 addr, eah, eal, efaddr;
	tvbuff_t	*next_tvb;
	const char	*srcname = "src";
	const char	*dstname = "dst";
	col_set_str(pinfo->cinfo, COL_PROTOCOL, "V5-EF");
	col_clear(pinfo->cinfo, COL_INFO);
	addr		= tvb_get_ntohs(tvb, 0);
	eah		= (addr & V5EF_EAH) >> V5EF_EAH_SHIFT;
	eal		= (addr & V5EF_EAL) >> V5EF_EAL_SHIFT;
	efaddr		= (eah << 7) + eal;
	v5ef_header_len = 2;	
	direction = isdn->uton;
	if (direction==0) {
	        srcname = "LE";
	        dstname = "AN";
	 } else if (direction > 0) {
	        srcname = "AN";
	        dstname = "LE";
	}
	col_set_str(pinfo->cinfo, COL_RES_DL_SRC, srcname);
	col_set_str(pinfo->cinfo, COL_RES_DL_DST, dstname);
	if (tree) {
		proto_item *direction_ti;
		v5ef_ti = proto_tree_add_item(tree, proto_v5ef, tvb, 0, -1,
		    ENC_NA);
		v5ef_tree = proto_item_add_subtree(v5ef_ti, ett_v5ef);
		if (direction != P2P_DIR_UNKNOWN) {
			direction_ti = proto_tree_add_uint(v5ef_tree, hf_v5ef_direction,
			                                   tvb, 0, 0, direction);
		}
		addr_ti = proto_tree_add_uint(v5ef_tree, hf_v5ef_address, tvb,
		    0, 2, addr);
		addr_tree = proto_item_add_subtree(addr_ti, ett_v5ef_address);
		proto_tree_add_uint(addr_tree, hf_v5ef_eah,  tvb, 0, 1, addr);
		proto_tree_add_uint(addr_tree, hf_v5ef_ea1, tvb, 0, 1, addr);
		proto_tree_add_uint(addr_tree, hf_v5ef_eal, tvb, 1, 1, addr);
		proto_tree_add_uint(addr_tree, hf_v5ef_ea2, tvb, 1, 1, addr);
	}
	else {
		v5ef_ti	  = NULL;
		v5ef_tree = NULL;
	}
	if (tree)
		proto_item_set_len(v5ef_ti, v5ef_header_len);
	next_tvb = tvb_new_subset_remaining(tvb, v5ef_header_len);
	if (efaddr>8175)
		call_dissector(v5dl_handle,next_tvb, pinfo, tree);
	else
		call_dissector_with_data(lapd_phdr_handle, next_tvb, pinfo, tree, isdn);
	return tvb_captured_length(tvb);
}
