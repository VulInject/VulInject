static int __ebs_rw_bvec(struct ebs_c *ec, enum req_op op, struct bio_vec *bv,
			 struct bvec_iter *iter)
{
	int r = 0;
	unsigned char *ba, *pa;
	unsigned int cur_len;
	unsigned int bv_len = bv->bv_len;
	unsigned int buf_off = to_bytes(__block_mod(iter->bi_sector, ec->u_bs));
	sector_t block = __sector_to_block(ec, iter->bi_sector);
	struct dm_buffer *b;
	if (unlikely(!bv->bv_page || !bv_len))
		return -EIO;
	pa = bvec_virt(bv);
	while (bv_len) {
		cur_len = min(dm_bufio_get_block_size(ec->bufio) - buf_off, bv_len);
		if (op == REQ_OP_READ || buf_off || bv_len < dm_bufio_get_block_size(ec->bufio))
			ba = dm_bufio_read(ec->bufio, block, &b);
		else
			ba = dm_bufio_new(ec->bufio, block, &b);
		if (IS_ERR(ba)) {
			r = PTR_ERR(ba);
		} else {
			ba += buf_off;
			if (op == REQ_OP_READ) {
				memcpy(pa, ba, cur_len);
			} else {
				flush_dcache_page(bv->bv_page);
				memcpy(ba, pa, cur_len);
				dm_bufio_mark_partial_buffer_dirty(b, buf_off, buf_off + cur_len);
			}
			dm_bufio_release(b);
		}
		pa += cur_len;
		bv_len -= cur_len;
		buf_off = 0;
		block++;
	}
	return r;
}
