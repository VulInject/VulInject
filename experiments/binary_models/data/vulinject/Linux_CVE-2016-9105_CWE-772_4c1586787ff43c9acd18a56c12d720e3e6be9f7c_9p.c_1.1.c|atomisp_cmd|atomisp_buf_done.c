void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
		      enum ia_css_buffer_type buf_type,
		      enum ia_css_pipe_id css_pipe_id,
		      bool q_buffers, enum atomisp_input_stream_id stream_id)
{
	struct atomisp_video_pipe *pipe = NULL;
	struct atomisp_css_buffer buffer;
	bool requeue = false;
	unsigned int irqflags;
	struct ia_css_frame *frame = NULL;
	struct atomisp_s3a_buf *s3a_buf = NULL, *_s3a_buf_tmp, *s3a_iter;
	struct atomisp_dis_buf *dis_buf = NULL, *_dis_buf_tmp, *dis_iter;
	struct atomisp_metadata_buf *md_buf = NULL, *_md_buf_tmp, *md_iter;
	enum atomisp_metadata_type md_type;
	struct atomisp_device *isp = asd->isp;
	int i, err;
	lockdep_assert_held(&isp->mutex);
	if (
	    buf_type != IA_CSS_BUFFER_TYPE_METADATA &&
	    buf_type != IA_CSS_BUFFER_TYPE_3A_STATISTICS &&
	    buf_type != IA_CSS_BUFFER_TYPE_DIS_STATISTICS &&
	    buf_type != IA_CSS_BUFFER_TYPE_OUTPUT_FRAME &&
	    buf_type != IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME &&
	    buf_type != IA_CSS_BUFFER_TYPE_RAW_OUTPUT_FRAME &&
	    buf_type != IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME &&
	    buf_type != IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME) {
		dev_err(isp->dev, "%s, unsupported buffer type: %d\n",
			__func__, buf_type);
		return;
	}
	memset(&buffer, 0, sizeof(struct atomisp_css_buffer));
	buffer.css_buffer.type = buf_type;
	err = atomisp_css_dequeue_buffer(asd, stream_id, css_pipe_id,
					 buf_type, &buffer);
	if (err) {
		dev_err(isp->dev,
			"atomisp_css_dequeue_buffer failed: 0x%x\n", err);
		return;
	}
	switch (buf_type) {
	case IA_CSS_BUFFER_TYPE_3A_STATISTICS:
		list_for_each_entry_safe(s3a_iter, _s3a_buf_tmp,
					 &asd->s3a_stats_in_css, list) {
			if (s3a_iter->s3a_data ==
			    buffer.css_buffer.data.stats_3a) {
				list_del_init(&s3a_iter->list);
				list_add_tail(&s3a_iter->list,
					      &asd->s3a_stats_ready);
				s3a_buf = s3a_iter;
				break;
			}
		}
		asd->s3a_bufs_in_css[css_pipe_id]--;
		atomisp_3a_stats_ready_event(asd, buffer.css_buffer.exp_id);
		if (s3a_buf)
			dev_dbg(isp->dev, "%s: s3a stat with exp_id %d is ready\n",
				__func__, s3a_buf->s3a_data->exp_id);
		else
			dev_dbg(isp->dev, "%s: s3a stat is ready with no exp_id found\n",
				__func__);
		break;
	case IA_CSS_BUFFER_TYPE_METADATA:
		if (error)
			break;
		md_type = ATOMISP_MAIN_METADATA;
		list_for_each_entry_safe(md_iter, _md_buf_tmp,
					 &asd->metadata_in_css[md_type], list) {
			if (md_iter->metadata ==
			    buffer.css_buffer.data.metadata) {
				list_del_init(&md_iter->list);
				list_add_tail(&md_iter->list,
					      &asd->metadata_ready[md_type]);
				md_buf = md_iter;
				break;
			}
		}
		asd->metadata_bufs_in_css[stream_id][css_pipe_id]--;
		if (md_buf)
			dev_dbg(isp->dev, "%s: metadata with exp_id %d is ready\n",
				__func__, md_buf->metadata->exp_id);
		else
			dev_dbg(isp->dev, "%s: metadata is ready with no exp_id found\n",
				__func__);
		break;
	case IA_CSS_BUFFER_TYPE_DIS_STATISTICS:
		list_for_each_entry_safe(dis_iter, _dis_buf_tmp,
					 &asd->dis_stats_in_css, list) {
			if (dis_iter->dis_data ==
			    buffer.css_buffer.data.stats_dvs) {
				spin_lock_irqsave(&asd->dis_stats_lock,
						  irqflags);
				list_del_init(&dis_iter->list);
				list_add(&dis_iter->list, &asd->dis_stats);
				asd->params.dis_proj_data_valid = true;
				spin_unlock_irqrestore(&asd->dis_stats_lock,
						       irqflags);
				dis_buf = dis_iter;
				break;
			}
		}
		asd->dis_bufs_in_css--;
		if (dis_buf)
			dev_dbg(isp->dev, "%s: dis stat with exp_id %d is ready\n",
				__func__, dis_buf->dis_data->exp_id);
		else
			dev_dbg(isp->dev, "%s: dis stat is ready with no exp_id found\n",
				__func__);
		break;
	case IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:
	case IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME:
		frame = buffer.css_buffer.data.frame;
		if (!frame) {
			WARN_ON(1);
			break;
		}
		if (!frame->valid)
			error = true;
		pipe = vb_to_pipe(&frame->vb.vb2_buf);
		dev_dbg(isp->dev, "%s: vf frame with exp_id %d is ready\n",
			__func__, frame->exp_id);
		pipe->frame_config_id[frame->vb.vb2_buf.index] = frame->isp_config_id;
		break;
	case IA_CSS_BUFFER_TYPE_OUTPUT_FRAME:
	case IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME:
		frame = buffer.css_buffer.data.frame;
		if (!frame) {
			WARN_ON(1);
			break;
		}
		if (!frame->valid)
			error = true;
		pipe = vb_to_pipe(&frame->vb.vb2_buf);
		dev_dbg(isp->dev, "%s: main frame with exp_id %d is ready\n",
			__func__, frame->exp_id);
		i = frame->vb.vb2_buf.index;
		if (pipe->frame_params[i]) {
			if (asd->params.dvs_6axis == pipe->frame_params[i]->params.dvs_6axis)
				asd->params.dvs_6axis = NULL;
			atomisp_free_css_parameters(&pipe->frame_params[i]->params);
			kvfree(pipe->frame_params[i]);
			pipe->frame_params[i] = NULL;
		}
		pipe->frame_config_id[i] = frame->isp_config_id;
		if (asd->params.css_update_params_needed) {
			atomisp_apply_css_parameters(asd,
						     &asd->params.css_param);
			if (asd->params.css_param.update_flag.dz_config)
				asd->params.config.dz_config = &asd->params.css_param.dz_config;
			if (asd->params.dvs_6axis)
				atomisp_css_set_dvs_6axis(asd,
							  asd->params.dvs_6axis);
			else
				asd->params.css_update_params_needed = false;
			atomisp_css_update_isp_params(asd);
		}
		break;
	default:
		break;
	}
	if (frame) {
		spin_lock_irqsave(&pipe->irq_lock, irqflags);
		atomisp_buffer_done(frame, error ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);
		spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
	}
	if (requeue) {
		err = atomisp_css_queue_buffer(asd,
					       stream_id, css_pipe_id,
					       buf_type, &buffer);
		if (err)
			dev_err(isp->dev, "%s, q to css fails: %d\n",
				__func__, err);
		return;
	}
	if (!error && q_buffers)
		atomisp_qbuffers_to_css(asd);
}
