iptrace_read_rec_1_0(wtap *wth, FILE_T fh, wtap_rec *rec, Buffer *buf,
    int *err, char **err_info)
{
	iptrace_t		*iptrace = (iptrace_t *)wth->priv;
	unsigned char			header[IPTRACE_1_0_PHDR_SIZE];
	unsigned int		record_length;
	unsigned char			pkt_info[IPTRACE_1_0_PINFO_SIZE];
	if_info			info;
	unsigned int		packet_size;
	void			*result;
	if (!wtap_read_bytes_or_eof(fh, header, IPTRACE_1_0_PHDR_SIZE, err,
	    err_info)) {
		return false;
	}
	record_length = pntoh32(&header[IPTRACE_1_0_REC_LENGTH_OFFSET]);
	if (record_length < IPTRACE_1_0_PINFO_SIZE) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = ws_strdup_printf("iptrace: file has a %u-byte record, too small to have even a packet information header",
		    record_length);
		return false;
	}
	if (!wtap_read_bytes(fh, pkt_info, IPTRACE_1_0_PINFO_SIZE, err,
	    err_info)) {
		return false;
	}
	info.if_type = pkt_info[IPTRACE_1_0_IF_TYPE_OFFSET];
	rec->rec_header.packet_header.pkt_encap = wtap_encap_ift(info.if_type);
	if (rec->rec_header.packet_header.pkt_encap == WTAP_ENCAP_UNKNOWN) {
		*err = WTAP_ERR_UNSUPPORTED;
		*err_info = ws_strdup_printf("iptrace: interface type IFT=0x%02x unknown or unsupported",
		    info.if_type);
		return false;
	}
	packet_size = record_length - IPTRACE_1_0_PINFO_SIZE;
	if (rec->rec_header.packet_header.pkt_encap == WTAP_ENCAP_FDDI_BITSWAPPED) {
		if (packet_size < 3) {
			*err = WTAP_ERR_BAD_FILE;
			*err_info = ws_strdup_printf("iptrace: file has a %u-byte record, too small to have even a packet meta-data header",
			    record_length);
			return false;
		}
		packet_size -= 3;
		if (!wtap_read_bytes(fh, NULL, 3, err, err_info))
			return false;
	}
	if (packet_size > WTAP_MAX_PACKET_SIZE_STANDARD) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = ws_strdup_printf("iptrace: File has %u-byte packet, bigger than maximum of %u",
		    packet_size, WTAP_MAX_PACKET_SIZE_STANDARD);
		return false;
	}
	rec->rec_type = REC_TYPE_PACKET;
	rec->block = wtap_block_create(WTAP_BLOCK_PACKET);
	rec->presence_flags = WTAP_HAS_TS | WTAP_HAS_INTERFACE_ID;
	rec->rec_header.packet_header.len = packet_size;
	rec->rec_header.packet_header.caplen = packet_size;
	rec->ts.secs = pntoh32(&header[IPTRACE_1_0_TV_SEC_OFFSET]);
	rec->ts.nsecs = 0;
	wtap_block_add_uint32_option(rec->block, OPT_PKT_FLAGS,
	    pkt_info[IPTRACE_1_0_TX_FLAGS_OFFSET] ?
	      (PACK_FLAGS_DIRECTION_OUTBOUND << PACK_FLAGS_DIRECTION_SHIFT) :
	      (PACK_FLAGS_DIRECTION_INBOUND << PACK_FLAGS_DIRECTION_SHIFT));
	fill_in_pseudo_header(rec->rec_header.packet_header.pkt_encap,
	    &rec->rec_header.packet_header.pseudo_header,
	    (const char *)&pkt_info[IPTRACE_1_0_PKT_TEXT_OFFSET]);
	if (!iptrace_read_rec_data(fh, buf, rec, err, err_info))
		return false;
	memcpy(info.prefix, &pkt_info[IPTRACE_1_0_PREFIX_OFFSET],
	    sizeof info.prefix);
	info.prefix[PREFIX_SIZE] = '\0';
	info.unit = pkt_info[IPTRACE_1_0_UNIT_OFFSET];
	if (!g_hash_table_lookup_extended(iptrace->interface_ids,
	    (gconstpointer)&info, NULL, &result)) {
		wtap_block_t int_data;
		wtapng_if_descr_mandatory_t *int_data_mand;
		add_new_if_info(iptrace, &info, &result);
		int_data = wtap_block_create(WTAP_BLOCK_IF_ID_AND_INFO);
		int_data_mand = (wtapng_if_descr_mandatory_t *)wtap_block_get_mandatory_data(int_data);
		int_data_mand->wtap_encap = rec->rec_header.packet_header.pkt_encap;
		int_data_mand->tsprecision = WTAP_TSPREC_SEC;
		int_data_mand->time_units_per_second = 1; 
		int_data_mand->snap_len = WTAP_MAX_PACKET_SIZE_STANDARD;	
		wtap_block_add_uint8_option(int_data, OPT_IDB_TSRESOL, 0); 
		int_data_mand->num_stat_entries = 0;
		int_data_mand->interface_statistics = NULL;
		wtap_block_set_string_option_value_format(int_data,
		    OPT_IDB_NAME, "%s%u", info.prefix, info.unit);
	}
	rec->rec_header.packet_header.interface_id = GPOINTER_TO_UINT(result);
	return true;
}
