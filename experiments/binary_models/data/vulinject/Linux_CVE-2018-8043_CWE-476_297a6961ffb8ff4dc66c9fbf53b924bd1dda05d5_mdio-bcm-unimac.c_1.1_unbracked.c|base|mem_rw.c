static ssize_t mem_rw(struct file *file, char __user *buf,
			size_t count, loff_t *ppos, int write)
{
	struct mm_struct *mm = file->private_data;
	unsigned int addr = *ppos;
	ssize_t copied;
	char *page;
	page = (char *)__get_free_page(GFP_KERNEL);
	if (!page)
		return -ENOMEM;
	copied = 0;
	if (!mmget_not_zero(mm))
		goto free;
	flags = FOLL_FORCE | (write ? FOLL_WRITE : 0);
	while (count > 0) {
		size_t this_len = min_t(size_t, count, PAGE_SIZE);
		if (write && copy_from_user(page, buf, this_len)) {
			copied = -EFAULT;
			break;
		}
		this_len = access_remote_vm(mm, addr, page, this_len, flags);
		if (!this_len) {
			if (!copied)
				copied = -EIO;
			break;
		}
		if (!write && copy_to_user(buf, page, this_len)) {
			copied = -EFAULT;
			break;
		}
		buf += this_len;
		addr += this_len;
		copied += this_len;
		count -= this_len;
	}
	*ppos = addr;
	mmput(mm);
free:
	free_page((unsigned int) page);
	return copied;
}
