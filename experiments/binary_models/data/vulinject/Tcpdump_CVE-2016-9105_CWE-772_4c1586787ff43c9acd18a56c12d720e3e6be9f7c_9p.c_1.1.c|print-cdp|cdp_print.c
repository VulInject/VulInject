cdp_print(netdissect_options *ndo,
          const u_char *tptr, u_int length)
{
	u_int orig_length = length;
	unsigned short checksum;
	ndo->ndo_protocol = "cdp";
	if (length < CDP_HEADER_LEN) {
		ND_PRINT(" (packet length %u < %u)", length, CDP_HEADER_LEN);
		goto invalid;
	}
	ND_PRINT("CDPv%u, ttl: %us",
	         GET_U_1(tptr + CDP_HEADER_VERSION_OFFSET),
	         GET_U_1(tptr + CDP_HEADER_TTL_OFFSET));
	checksum = GET_BE_U_2(tptr + CDP_HEADER_CHECKSUM_OFFSET);
	if (ndo->ndo_vflag)
		ND_PRINT(", checksum: 0x%04x (unverified), length %u",
		         checksum, orig_length);
	tptr += CDP_HEADER_LEN;
	length -= CDP_HEADER_LEN;
	while (length) {
		u_int type, len;
		const struct cdp_tlvinfo *info;
		const char *name;
		int print_if_not_verbose;
		int covered = 0;
		if (length < CDP_TLV_HEADER_LEN) {
			ND_PRINT(" (remaining packet length %u < %u)",
			         length, CDP_TLV_HEADER_LEN);
			goto invalid;
		}
		type = GET_BE_U_2(tptr + CDP_TLV_TYPE_OFFSET);
		len  = GET_BE_U_2(tptr + CDP_TLV_LEN_OFFSET); 
		info = type < T_MAX ? &cdptlvs[type] : NULL;
		name = (info && info->name) ? info->name : "unknown field type";
		print_if_not_verbose =
		    (info ? (info->when_to_print == VERBOSE_OR_NOT_VERBOSE) : 0);
		if (len < CDP_TLV_HEADER_LEN) {
			if (ndo->ndo_vflag)
				ND_PRINT("\n\t%s (0x%04x), TLV length: %u byte%s (too short)",
				         name, type, len, PLURAL_SUFFIX(len));
			else
				ND_PRINT(", %s TLV length %u too short",
				         name, len);
			goto invalid;
		}
		if (len > length) {
			ND_PRINT(" (TLV length %u > %u)", len, length);
			goto invalid;
		}
		tptr += CDP_TLV_HEADER_LEN;
		length -= CDP_TLV_HEADER_LEN;
		len -= CDP_TLV_HEADER_LEN;
		if (ndo->ndo_vflag) {
			ND_PRINT("\n\t%s (0x%04x), value length: %u byte%s: ",
			         name, type, len, PLURAL_SUFFIX(len));
		} else {
			if (print_if_not_verbose)
				ND_PRINT(", %s ", name);
		}
		if (info) {
			if ((info->min_len > 0 && len < (unsigned)info->min_len) ||
			    (info->max_len > 0 && len > (unsigned)info->max_len))
				ND_PRINT(" (malformed TLV)");
			else if (ndo->ndo_vflag || print_if_not_verbose) {
				if (info->printer)
					info->printer(ndo, tptr, len);
				else
				covered = 1;
			}
		}
		if (ndo->ndo_vflag && !covered) {
			ND_TCHECK_LEN(tptr, len);
			print_unknown_data(ndo, tptr, "\n\t  ", len);
		}
		tptr += len;
		length -= len;
	}
	if (ndo->ndo_vflag < 1)
		ND_PRINT(", length %u", orig_length);
	return;
invalid:
	nd_print_invalid(ndo);
	ND_TCHECK_LEN(tptr, length);
}
