static int init_pdb7_root_stream(RPdb *pdb, int *root_page_list, int pages_amount,
				 EStream indx, int root_size, int page_size) {
	R_PDB_STREAM *pdb_stream = 0;
	int tmp_data_max_size = 0;
	char *tmp_data = NULL, *data_end;
	int stream_size = 0;
	int num_streams = 0;
	int *sizes = NULL;
	int num_pages = 0;
	int data_size = 0;
	int i = 0;
	int pos = 0;
	R_PDB7_ROOT_STREAM *root_stream7;
	pdb->root_stream = R_NEW0 (R_PDB7_ROOT_STREAM);
	init_r_pdb_stream (&pdb->root_stream->pdb_stream, pdb->buf, root_page_list, pages_amount,
		indx, root_size, page_size);
	root_stream7 = pdb->root_stream;
	pdb_stream = &(root_stream7->pdb_stream);
	stream_file_get_size (&pdb_stream->stream_file, &data_size);
	if (data_size > UT16_MAX || data_size < 1) {
		return 0;
	}
	char *data = (char *) calloc (1, R_MAX (data_size, 8));
	if (!data) {
		return 0;
	}
	stream_file_get_data (&pdb_stream->stream_file, data);
	num_streams = *(int *) data;
	tmp_data = data;
	tmp_data += 4;
	root_stream7->num_streams = num_streams;
	tmp_data_max_size = (data_size - (num_streams * 4) - 4);
	data_end = data + tmp_data_max_size;
	if (tmp_data_max_size > data_size) {
		R_FREE (data);
		R_LOG_ERROR ("Invalid max tmp data size");
		return 0;
	}
	if (num_streams < 0 || tmp_data_max_size <= 0) {
		R_FREE (data);
		R_LOG_ERROR ("Too many streams: current PDB file is incorrect");
		return 0;
	}
	sizes = (int *) calloc (num_streams, 4);
	if (!sizes) {
		R_FREE (data);
		R_LOG_ERROR ("Size too big: current PDB file is incorrect");
		return 0;
	}
	for (i = 0; i < num_streams && (tmp_data + 4 < data_end); i++) {
		stream_size = *(int *) (tmp_data);
		tmp_data += 4;
		if (stream_size == UT32_MAX) {
			stream_size = 0;
		}
		memcpy (sizes + i, &stream_size, 4);
	}
	tmp_data = ((char *) data + num_streams * 4 + 4);
	root_stream7->streams_list = r_list_new ();
	RList *pList = root_stream7->streams_list;
	SPage *page = 0;
	for (i = 0; i < num_streams; i++) {
		num_pages = count_pages (sizes[i], page_size);
		if ((pos + num_pages) > tmp_data_max_size) {
			R_LOG_WARN ("looks like there is no correct values of stream size in PDB file");
			R_FREE (data);
			R_FREE (sizes);
			return 0;
		}
		if (SZT_MUL_OVFCHK (num_pages, 4)) {
			R_LOG_WARN ("num_pages overflow");
			R_FREE (data);
			R_FREE (sizes);
			return 0;
		}
		ut32 size = num_pages * 4;
		if (size > UT16_MAX) {
			R_LOG_WARN ("too many pages");
			R_FREE (data);
			R_FREE (sizes);
			return 0;
		}
		ut8 *tmp = (ut8 *) calloc (num_pages, 4);
		page = R_NEW0 (SPage);
		if (num_pages != 0) {
			if ((pos + size) > tmp_data_max_size) {
				R_LOG_ERROR ("Data overrun by num_pages");
				R_FREE (data);
				R_FREE (sizes);
				R_FREE (tmp);
				R_FREE (page);
				return 0;
			}
			memcpy (tmp, tmp_data + pos, num_pages * 4);
			pos += size;
			page->stream_size = sizes[i];
			if (sizes[i] == 0) {
			}
			page->stream_pages = tmp;
			page->num_pages = num_pages;
		} else {
			page->stream_size = 0;
			page->stream_pages = 0;
			page->num_pages = 0;
			free (tmp);
		}
	}
	free (sizes);
	free (data);
	return 1;
}
