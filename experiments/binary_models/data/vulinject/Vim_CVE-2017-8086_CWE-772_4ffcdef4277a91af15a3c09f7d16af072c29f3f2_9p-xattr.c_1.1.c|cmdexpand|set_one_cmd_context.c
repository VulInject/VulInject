set_one_cmd_context(
    expand_T	*xp,
    char_u	*buff)	    
{
    char_u		*p;
    char_u		*cmd, *arg;
    int			len = 0;
    exarg_T		ea;
    int			compl = EXPAND_NOTHING;
    int			forceit = FALSE;
    int			usefilter = FALSE;  
    xp->xp_pattern = buff;
    xp->xp_line = buff;
    xp->xp_context = EXPAND_COMMANDS;	
    ea.argt = 0;
    for (cmd = buff; vim_strchr((char_u *)" \t:|", *cmd) != NULL; cmd++)
	;
    xp->xp_pattern = cmd;
    if (*cmd == NUL)
	return NULL;
    if (*cmd == '"')	    
    {
	xp->xp_context = EXPAND_NOTHING;
	return NULL;
    }
    cmd = skip_range(cmd, TRUE, &xp->xp_context);
    xp->xp_pattern = cmd;
    if (*cmd == NUL)
	return NULL;
    if (*cmd == '"')
    {
	xp->xp_context = EXPAND_NOTHING;
	return NULL;
    }
    if (*cmd == '|' || *cmd == '\n')
	return cmd + 1;			
    p = set_cmd_index(cmd, &ea, xp, &compl);
    if (p == NULL)
	return NULL;
    xp->xp_context = EXPAND_NOTHING; 
    if (*p == '!')		    
    {
	forceit = TRUE;
	++p;
    }
    if (!IS_USER_CMDIDX(ea.cmdidx))
	ea.argt = excmd_get_argt(ea.cmdidx);
    arg = skipwhite(p);
    if ((ea.argt & EX_ARGOPT) || ea.cmdidx == CMD_terminal)
    {
	while (*arg != NUL && STRNCMP(arg, "++", 2) == 0)
	{
	    p = arg + 2;
	    while (*p && !vim_isspace(*p))
		MB_PTR_ADV(p);
	    if (*p == NUL)
	    {
		if (ea.argt & EX_ARGOPT)
		    return set_context_in_argopt(xp, arg + 2);
#ifdef FEAT_TERMINAL
		if (ea.cmdidx == CMD_terminal)
		    return set_context_in_terminalopt(xp, arg + 2);
#endif
	    }
	    arg = skipwhite(p);
	}
    }
    if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update)
    {
	if (*arg == '>')			
	{
	    if (*++arg == '>')
		++arg;
	    arg = skipwhite(arg);
	}
	else if (*arg == '!' && ea.cmdidx == CMD_write)	
	{
	    ++arg;
	    usefilter = TRUE;
	}
    }
    if (ea.cmdidx == CMD_read)
    {
	usefilter = forceit;			
	if (*arg == '!')			
	{
	    ++arg;
	    usefilter = TRUE;
	}
    }
    if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift)
    {
	while (*arg == *cmd)	    
	    ++arg;
	arg = skipwhite(arg);
    }
    if ((ea.argt & EX_CMDARG) && !usefilter && *arg == '+')
    {
	p = arg + 1;
	arg = skip_cmd_arg(arg, FALSE);
	if (*arg == NUL)
	    return p;
	arg = skipwhite(arg);
    }
    if ((ea.argt & EX_TRLBAR) && !usefilter)
    {
	p = arg;
	if (ea.cmdidx == CMD_redir && p[0] == '@' && p[1] == '"')
	    p += 2;
	while (*p)
	{
	    if (*p == Ctrl_V)
	    {
		if (p[1] != NUL)
		    ++p;
	    }
	    else if ( (*p == '"' && !(ea.argt & EX_NOTRLCOM))
		    || *p == '|' || *p == '\n')
	    {
		if (*(p - 1) != '\\')
		{
		    if (*p == '|' || *p == '\n')
			return p + 1;
		    return NULL;    
		}
	    }
	    MB_PTR_ADV(p);
	}
    }
    if (!(ea.argt & EX_EXTRA) && *arg != NUL
				  && vim_strchr((char_u *)"|\"", *arg) == NULL)
	return NULL;
    p = buff;
    xp->xp_pattern = p;
    len = (int)STRLEN(buff);
    while (*p && p < buff + len)
    {
	if (*p == ' ' || *p == TAB)
	{
	    xp->xp_pattern = ++p;
	}
	else
	{
	    if (*p == '\\' && *(p + 1) != NUL)
		++p; 
	    MB_PTR_ADV(p);
	}
    }
    if (ea.argt & EX_XFILE)
	set_context_for_wildcard_arg(&ea, arg, usefilter, xp, &compl);
    return set_context_by_cmdname(cmd, ea.cmdidx, xp, arg, ea.argt, compl,
								forceit);
}
