static int onenand_otp_write_oob_nolock(struct mtd_info *mtd, loff_t to,
				    struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int column, ret = 0, oobsize;
	int written = 0;
	u_char *oobbuf;
	size_t len = ops->ooblen;
	const u_char *buf = ops->oobbuf;
	int block, value, status;
	to += ops->ooboffs;
	ops->oobretlen = 0;
	oobsize = mtd->oobsize;
	column = to & (mtd->oobsize - 1);
	oobbuf = this->oob_buf;
	while (written < len) {
		int thislen = min_t(int, oobsize, len - written);
		cond_resched();
		block = (int) (to >> this->erase_shift);
		this->write_word(value, this->base +
				ONENAND_REG_START_ADDRESS1);
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base +
				ONENAND_REG_START_ADDRESS2);
		ONENAND_SET_NEXT_BUFFERRAM(this);
		this->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);
		this->wait(mtd, FL_OTPING);
		memcpy(oobbuf + column, buf, thislen);
		this->write_bufferram(mtd, ONENAND_SPARERAM,
					oobbuf, 0, mtd->oobsize);
		onenand_otp_command(mtd, ONENAND_CMD_PROGOOB, to, mtd->oobsize);
		onenand_update_bufferram(mtd, to, 0);
		if (ONENAND_IS_2PLANE(this)) {
			ONENAND_SET_BUFFERRAM1(this);
			onenand_update_bufferram(mtd, to + this->writesize, 0);
		}
		ret = this->wait(mtd, FL_WRITING);
		if (ret) {
			printk(KERN_ERR "%s: write failed %d\n", __func__, ret);
			break;
		}
		this->command(mtd, ONENAND_CMD_RESET, 0, 0);
		this->wait(mtd, FL_RESETTING);
		status = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
		status &= 0x60;
		if (status == 0x60) {
			printk(KERN_DEBUG "\nBLOCK\tSTATUS\n");
			printk(KERN_DEBUG "1st Block\tLOCKED\n");
			printk(KERN_DEBUG "OTP Block\tLOCKED\n");
		} else if (status == 0x20) {
			printk(KERN_DEBUG "\nBLOCK\tSTATUS\n");
			printk(KERN_DEBUG "1st Block\tLOCKED\n");
			printk(KERN_DEBUG "OTP Block\tUN-LOCKED\n");
		} else if (status == 0x40) {
			printk(KERN_DEBUG "\nBLOCK\tSTATUS\n");
			printk(KERN_DEBUG "1st Block\tUN-LOCKED\n");
			printk(KERN_DEBUG "OTP Block\tLOCKED\n");
		} else {
			printk(KERN_DEBUG "Reboot to check\n");
		}
		written += thislen;
		if (written == len)
			break;
		to += mtd->writesize;
		buf += thislen;
		column = 0;
	}
	ops->oobretlen = written;
	return ret;
}
