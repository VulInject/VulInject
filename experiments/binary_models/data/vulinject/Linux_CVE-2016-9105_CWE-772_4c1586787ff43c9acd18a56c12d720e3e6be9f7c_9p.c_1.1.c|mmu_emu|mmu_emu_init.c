void __init mmu_emu_init(unsigned int bootmem_end)
{
	unsigned int seg, num;
	int i,j;
	memset(rom_pages, 0, sizeof(rom_pages));
	memset(pmeg_vaddr, 0, sizeof(pmeg_vaddr));
	memset(pmeg_alloc, 0, sizeof(pmeg_alloc));
	memset(pmeg_ctx, 0, sizeof(pmeg_ctx));
	bootmem_end = (bootmem_end + (2 * SUN3_PMEG_SIZE)) & ~SUN3_PMEG_MASK;
	for (i=0; i < __pa(bootmem_end) / SUN3_PMEG_SIZE ; ++i)
		pmeg_alloc[i] = 2;
	for(num = 0xf0; num <= 0xff; num++)
		pmeg_alloc[num] = 2;
	for(seg = bootmem_end; seg < 0x0f800000; seg += SUN3_PMEG_SIZE) {
		i = sun3_get_segmap(seg);
		if(!pmeg_alloc[i]) {
#ifdef DEBUG_MMU_EMU
			pr_info("freed:");
			print_pte_vaddr (seg);
#endif
		}
	}
	j = 0;
	for (num=0, seg=0x0F800000; seg<0x10000000; seg+=16*PAGE_SIZE) {
		if (sun3_get_segmap (seg) != SUN3_INVALID_PMEG) {
#ifdef DEBUG_PROM_MAPS
			for(i = 0; i < 16; i++) {
				pr_info("mapped:");
				print_pte_vaddr (seg + (i*PAGE_SIZE));
				break;
			}
#endif
			if (!m68k_vmalloc_end)
				m68k_vmalloc_end = seg;
			pmeg_alloc[sun3_get_segmap(seg)] = 2;
		}
	}
	dvma_init();
	for(seg = 0; seg < PAGE_OFFSET; seg += SUN3_PMEG_SIZE)
		sun3_put_segmap(seg, SUN3_INVALID_PMEG);
	set_fc(3);
	for(seg = 0; seg < 0x10000000; seg += SUN3_PMEG_SIZE) {
		i = sun3_get_segmap(seg);
		for(j = 1; j < CONTEXTS_NUM; j++)
			(*(romvec->pv_setctxt))(j, (void *)seg, i);
	}
	set_fc(USER_DATA);
}
