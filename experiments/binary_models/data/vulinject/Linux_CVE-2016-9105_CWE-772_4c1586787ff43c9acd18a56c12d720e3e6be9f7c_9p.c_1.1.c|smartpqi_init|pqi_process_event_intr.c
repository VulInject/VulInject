static int pqi_process_event_intr(struct pqi_ctrl_info *ctrl_info)
{
	int num_events;
	pqi_index_t oq_pi;
	pqi_index_t oq_ci;
	struct pqi_event_queue *event_queue;
	struct pqi_event_response *response;
	struct pqi_event *event;
	int event_index;
	event_queue = &ctrl_info->event_queue;
	num_events = 0;
	oq_ci = event_queue->oq_ci_copy;
	while (1) {
		oq_pi = readl(event_queue->oq_pi);
		if (oq_pi >= PQI_NUM_EVENT_QUEUE_ELEMENTS) {
			dev_err(&ctrl_info->pci_dev->dev,
				"event interrupt: producer index (%u) out of range (0-%u): consumer index: %u\n",
				oq_pi, PQI_NUM_EVENT_QUEUE_ELEMENTS - 1, oq_ci);
			return -1;
		}
		if (oq_pi == oq_ci)
			break;
		num_events++;
		response = event_queue->oq_element_array + (oq_ci * PQI_EVENT_OQ_ELEMENT_LENGTH);
		event_index = pqi_event_type_to_event_index(response->event_type);
		if (event_index >= 0 && response->request_acknowledge) {
			event = &ctrl_info->events[event_index];
			event->pending = true;
			event->event_type = response->event_type;
			event->event_id = get_unaligned_le16(&response->event_id);
			event->additional_event_id =
				get_unaligned_le32(&response->additional_event_id);
			if (event->event_type == PQI_EVENT_TYPE_OFA)
				pqi_ofa_capture_event_payload(ctrl_info, event, response);
		}
		oq_ci = (oq_ci + 1) % PQI_NUM_EVENT_QUEUE_ELEMENTS;
	}
	if (num_events) {
		event_queue->oq_ci_copy = oq_ci;
		writel(oq_ci, event_queue->oq_ci);
		schedule_work(&ctrl_info->event_work);
	}
	return num_events;
}
