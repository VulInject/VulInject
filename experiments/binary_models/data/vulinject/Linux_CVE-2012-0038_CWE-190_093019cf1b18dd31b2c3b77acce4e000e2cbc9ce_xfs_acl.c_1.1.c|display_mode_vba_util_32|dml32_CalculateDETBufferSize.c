void dml32_CalculateDETBufferSize(
		unsigned int DETSizeOverride[],
		enum dm_use_mall_for_pstate_change_mode UseMALLForPStateChange[],
		bool ForceSingleDPP,
		unsigned int NumberOfActiveSurfaces,
		bool UnboundedRequestEnabled,
		unsigned int nomDETInKByte,
		unsigned int MaxTotalDETInKByte,
		unsigned int ConfigReturnBufferSizeInKByte,
		unsigned int MinCompressedBufferSizeInKByte,
		unsigned int CompressedBufferSegmentSizeInkByteFinal,
		enum source_format_class SourcePixelFormat[],
		double ReadBandwidthLuma[],
		double ReadBandwidthChroma[],
		unsigned int RoundedUpMaxSwathSizeBytesY[],
		unsigned int RoundedUpMaxSwathSizeBytesC[],
		unsigned int DPPPerSurface[],
		unsigned int DETBufferSizeInKByte[],
		unsigned int *CompressedBufferSizeInkByte)
{
	unsigned int DETBufferSizePoolInKByte;
	unsigned int NextDETBufferPieceInKByte;
	bool DETPieceAssignedToThisSurfaceAlready[DC__NUM_DPP__MAX];
	bool NextPotentialSurfaceToAssignDETPieceFound;
	unsigned int NextSurfaceToAssignDETPiece;
	double TotalBandwidth;
	double BandwidthOfSurfacesNotAssignedDETPiece;
	unsigned int max_minDET;
	unsigned int minDET;
	unsigned int minDET_pipe;
	int j, k;
#ifdef __DML_VBA_DEBUG__
	dml_print("DML::%s: ForceSingleDPP = %d\n", __func__, ForceSingleDPP);
	dml_print("DML::%s: nomDETInKByte = %d\n", __func__, nomDETInKByte);
	dml_print("DML::%s: NumberOfActiveSurfaces = %d\n", __func__, NumberOfActiveSurfaces);
	dml_print("DML::%s: UnboundedRequestEnabled = %d\n", __func__, UnboundedRequestEnabled);
	dml_print("DML::%s: MaxTotalDETInKByte = %d\n", __func__, MaxTotalDETInKByte);
	dml_print("DML::%s: ConfigReturnBufferSizeInKByte = %d\n", __func__, ConfigReturnBufferSizeInKByte);
	dml_print("DML::%s: MinCompressedBufferSizeInKByte = %d\n", __func__, MinCompressedBufferSizeInKByte);
	dml_print("DML::%s: CompressedBufferSegmentSizeInkByteFinal = %d\n", __func__,
			CompressedBufferSegmentSizeInkByteFinal);
#endif
	if (UnboundedRequestEnabled) {
		if (DETSizeOverride[0] > 0) {
			DETBufferSizeInKByte[0] = DETSizeOverride[0];
		} else {
			DETBufferSizeInKByte[0] = dml_max(nomDETInKByte, dml_ceil(2.0 *
					((double) RoundedUpMaxSwathSizeBytesY[0] +
							(double) RoundedUpMaxSwathSizeBytesC[0]) / 1024.0, 64.0));
		}
		*CompressedBufferSizeInkByte = ConfigReturnBufferSizeInKByte - DETBufferSizeInKByte[0];
	} else {
		DETBufferSizePoolInKByte = MaxTotalDETInKByte;
		for (k = 0; k < NumberOfActiveSurfaces; ++k) {
			DETBufferSizeInKByte[k] = nomDETInKByte;
			if (SourcePixelFormat[k] == dm_420_8 || SourcePixelFormat[k] == dm_420_10 ||
					SourcePixelFormat[k] == dm_420_12) {
				max_minDET = nomDETInKByte - 64;
			} else {
				max_minDET = nomDETInKByte;
			}
			minDET = 128;
			minDET_pipe = 0;
			while (minDET <= max_minDET && minDET_pipe == 0) {
				if (2.0 * ((double) RoundedUpMaxSwathSizeBytesY[k] +
						(double) RoundedUpMaxSwathSizeBytesC[k]) / 1024.0 <= minDET)
					minDET_pipe = minDET;
				minDET = minDET + 64;
			}
#ifdef __DML_VBA_DEBUG__
			dml_print("DML::%s: k=%0d minDET        = %d\n", __func__, k, minDET);
			dml_print("DML::%s: k=%0d max_minDET    = %d\n", __func__, k, max_minDET);
			dml_print("DML::%s: k=%0d minDET_pipe   = %d\n", __func__, k, minDET_pipe);
			dml_print("DML::%s: k=%0d RoundedUpMaxSwathSizeBytesY = %d\n", __func__, k,
					RoundedUpMaxSwathSizeBytesY[k]);
			dml_print("DML::%s: k=%0d RoundedUpMaxSwathSizeBytesC = %d\n", __func__, k,
					RoundedUpMaxSwathSizeBytesC[k]);
#endif
			if (minDET_pipe == 0) {
				minDET_pipe = dml_max(128, dml_ceil(((double)RoundedUpMaxSwathSizeBytesY[k] +
						(double)RoundedUpMaxSwathSizeBytesC[k]) / 1024.0, 64));
#ifdef __DML_VBA_DEBUG__
				dml_print("DML::%s: k=%0d minDET_pipe = %d (assume each plane take half DET)\n",
						__func__, k, minDET_pipe);
#endif
			}
			if (UseMALLForPStateChange[k] == dm_use_mall_pstate_change_phantom_pipe) {
				DETBufferSizeInKByte[k] = 0;
			} else if (DETSizeOverride[k] > 0) {
				DETBufferSizeInKByte[k] = DETSizeOverride[k];
				DETBufferSizePoolInKByte = DETBufferSizePoolInKByte -
						(ForceSingleDPP ? 1 : DPPPerSurface[k]) * DETSizeOverride[k];
			} else if ((ForceSingleDPP ? 1 : DPPPerSurface[k]) * minDET_pipe <= DETBufferSizePoolInKByte) {
				DETBufferSizeInKByte[k] = minDET_pipe;
				DETBufferSizePoolInKByte = DETBufferSizePoolInKByte -
						(ForceSingleDPP ? 1 : DPPPerSurface[k]) * minDET_pipe;
			}
#ifdef __DML_VBA_DEBUG__
			dml_print("DML::%s: k=%d DPPPerSurface = %d\n", __func__, k, DPPPerSurface[k]);
			dml_print("DML::%s: k=%d DETSizeOverride = %d\n", __func__, k, DETSizeOverride[k]);
			dml_print("DML::%s: k=%d DETBufferSizeInKByte = %d\n", __func__, k, DETBufferSizeInKByte[k]);
			dml_print("DML::%s: DETBufferSizePoolInKByte = %d\n", __func__, DETBufferSizePoolInKByte);
#endif
		}
		TotalBandwidth = 0;
		for (k = 0; k < NumberOfActiveSurfaces; ++k) {
			if (UseMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe)
				TotalBandwidth = TotalBandwidth + ReadBandwidthLuma[k] + ReadBandwidthChroma[k];
		}
#ifdef __DML_VBA_DEBUG__
		dml_print("DML::%s: --- Before bandwidth adjustment ---\n", __func__);
		for (unsigned int k = 0; k < NumberOfActiveSurfaces; ++k)
			dml_print("DML::%s: k=%d DETBufferSizeInKByte   = %d\n", __func__, k, DETBufferSizeInKByte[k]);
		dml_print("DML::%s: --- DET allocation with bandwidth ---\n", __func__);
		dml_print("DML::%s: TotalBandwidth = %f\n", __func__, TotalBandwidth);
#endif
		BandwidthOfSurfacesNotAssignedDETPiece = TotalBandwidth;
		for (k = 0; k < NumberOfActiveSurfaces; ++k) {
			if (UseMALLForPStateChange[k] == dm_use_mall_pstate_change_phantom_pipe) {
				DETPieceAssignedToThisSurfaceAlready[k] = true;
			} else if (DETSizeOverride[k] > 0 || (((double) (ForceSingleDPP ? 1 : DPPPerSurface[k]) *
					(double) DETBufferSizeInKByte[k] / (double) MaxTotalDETInKByte) >=
					((ReadBandwidthLuma[k] + ReadBandwidthChroma[k]) / TotalBandwidth))) {
				DETPieceAssignedToThisSurfaceAlready[k] = true;
				BandwidthOfSurfacesNotAssignedDETPiece = BandwidthOfSurfacesNotAssignedDETPiece -
						ReadBandwidthLuma[k] - ReadBandwidthChroma[k];
			} else {
				DETPieceAssignedToThisSurfaceAlready[k] = false;
			}
#ifdef __DML_VBA_DEBUG__
			dml_print("DML::%s: k=%d DETPieceAssignedToThisSurfaceAlready = %d\n", __func__, k,
					DETPieceAssignedToThisSurfaceAlready[k]);
			dml_print("DML::%s: k=%d BandwidthOfSurfacesNotAssignedDETPiece = %f\n", __func__, k,
					BandwidthOfSurfacesNotAssignedDETPiece);
#endif
		}
		for (j = 0; j < NumberOfActiveSurfaces; ++j) {
			NextPotentialSurfaceToAssignDETPieceFound = false;
			NextSurfaceToAssignDETPiece = 0;
			for (k = 0; k < NumberOfActiveSurfaces; ++k) {
#ifdef __DML_VBA_DEBUG__
				dml_print("DML::%s: j=%d k=%d, ReadBandwidthLuma[k] = %f\n", __func__, j, k,
						ReadBandwidthLuma[k]);
				dml_print("DML::%s: j=%d k=%d, ReadBandwidthChroma[k] = %f\n", __func__, j, k,
						ReadBandwidthChroma[k]);
				dml_print("DML::%s: j=%d k=%d, ReadBandwidthLuma[Next] = %f\n", __func__, j, k,
						ReadBandwidthLuma[NextSurfaceToAssignDETPiece]);
				dml_print("DML::%s: j=%d k=%d, ReadBandwidthChroma[Next] = %f\n", __func__, j, k,
						ReadBandwidthChroma[NextSurfaceToAssignDETPiece]);
				dml_print("DML::%s: j=%d k=%d, NextSurfaceToAssignDETPiece = %d\n", __func__, j, k,
						NextSurfaceToAssignDETPiece);
#endif
				if (!DETPieceAssignedToThisSurfaceAlready[k] &&
						(!NextPotentialSurfaceToAssignDETPieceFound ||
						ReadBandwidthLuma[k] + ReadBandwidthChroma[k] <
						ReadBandwidthLuma[NextSurfaceToAssignDETPiece] +
						ReadBandwidthChroma[NextSurfaceToAssignDETPiece])) {
					NextSurfaceToAssignDETPiece = k;
					NextPotentialSurfaceToAssignDETPieceFound = true;
				}
#ifdef __DML_VBA_DEBUG__
				dml_print("DML::%s: j=%d k=%d, DETPieceAssignedToThisSurfaceAlready = %d\n",
						__func__, j, k, DETPieceAssignedToThisSurfaceAlready[k]);
				dml_print("DML::%s: j=%d k=%d, NextPotentialSurfaceToAssignDETPieceFound = %d\n",
						__func__, j, k, NextPotentialSurfaceToAssignDETPieceFound);
#endif
			}
			if (NextPotentialSurfaceToAssignDETPieceFound) {
				NextDETBufferPieceInKByte = dml_min(
					dml_round((double) DETBufferSizePoolInKByte *
						(ReadBandwidthLuma[NextSurfaceToAssignDETPiece] +
						ReadBandwidthChroma[NextSurfaceToAssignDETPiece]) /
						BandwidthOfSurfacesNotAssignedDETPiece /
						((ForceSingleDPP ? 1 :
								DPPPerSurface[NextSurfaceToAssignDETPiece]) * 64.0)) *
						(ForceSingleDPP ? 1 :
								DPPPerSurface[NextSurfaceToAssignDETPiece]) * 64.0,
						dml_floor((double) DETBufferSizePoolInKByte,
						(ForceSingleDPP ? 1 :
								DPPPerSurface[NextSurfaceToAssignDETPiece]) * 64.0));
				if (NextDETBufferPieceInKByte > nomDETInKByte * (ForceSingleDPP ? 1 : DPPPerSurface[k])) {
					if (DETBufferSizeInKByte[NextSurfaceToAssignDETPiece] <
							nomDETInKByte * (ForceSingleDPP ? 1 : DPPPerSurface[k])) {
						NextDETBufferPieceInKByte = nomDETInKByte * (ForceSingleDPP ? 1 : DPPPerSurface[k]) -
								DETBufferSizeInKByte[NextSurfaceToAssignDETPiece];
					} else {
						NextDETBufferPieceInKByte = 0;
					}
				}
#ifdef __DML_VBA_DEBUG__
				dml_print("DML::%s: j=%0d, DETBufferSizePoolInKByte = %d\n", __func__, j,
					DETBufferSizePoolInKByte);
				dml_print("DML::%s: j=%0d, NextSurfaceToAssignDETPiece = %d\n", __func__, j,
					NextSurfaceToAssignDETPiece);
				dml_print("DML::%s: j=%0d, ReadBandwidthLuma[%0d] = %f\n", __func__, j,
					NextSurfaceToAssignDETPiece, ReadBandwidthLuma[NextSurfaceToAssignDETPiece]);
				dml_print("DML::%s: j=%0d, ReadBandwidthChroma[%0d] = %f\n", __func__, j,
					NextSurfaceToAssignDETPiece, ReadBandwidthChroma[NextSurfaceToAssignDETPiece]);
				dml_print("DML::%s: j=%0d, BandwidthOfSurfacesNotAssignedDETPiece = %f\n",
					__func__, j, BandwidthOfSurfacesNotAssignedDETPiece);
				dml_print("DML::%s: j=%0d, NextDETBufferPieceInKByte = %d\n", __func__, j,
					NextDETBufferPieceInKByte);
				dml_print("DML::%s: j=%0d, DETBufferSizeInKByte[%0d] increases from %0d ",
					__func__, j, NextSurfaceToAssignDETPiece,
					DETBufferSizeInKByte[NextSurfaceToAssignDETPiece]);
#endif
				DETBufferSizeInKByte[NextSurfaceToAssignDETPiece] =
						DETBufferSizeInKByte[NextSurfaceToAssignDETPiece]
						+ NextDETBufferPieceInKByte
						/ (ForceSingleDPP ? 1 : DPPPerSurface[NextSurfaceToAssignDETPiece]);
#ifdef __DML_VBA_DEBUG__
				dml_print("to %0d\n", DETBufferSizeInKByte[NextSurfaceToAssignDETPiece]);
#endif
				DETBufferSizePoolInKByte = DETBufferSizePoolInKByte - NextDETBufferPieceInKByte;
				DETPieceAssignedToThisSurfaceAlready[NextSurfaceToAssignDETPiece] = true;
				BandwidthOfSurfacesNotAssignedDETPiece = BandwidthOfSurfacesNotAssignedDETPiece -
						(ReadBandwidthLuma[NextSurfaceToAssignDETPiece] +
								ReadBandwidthChroma[NextSurfaceToAssignDETPiece]);
			}
		}
		*CompressedBufferSizeInkByte = MinCompressedBufferSizeInKByte;
	}
	*CompressedBufferSizeInkByte = *CompressedBufferSizeInkByte * CompressedBufferSegmentSizeInkByteFinal / 64;
#ifdef __DML_VBA_DEBUG__
	dml_print("DML::%s: --- After bandwidth adjustment ---\n", __func__);
	dml_print("DML::%s: CompressedBufferSizeInkByte = %d\n", __func__, *CompressedBufferSizeInkByte);
	for (unsigned int k = 0; k < NumberOfActiveSurfaces; ++k) {
		dml_print("DML::%s: k=%d DETBufferSizeInKByte = %d (TotalReadBandWidth=%f)\n",
				__func__, k, DETBufferSizeInKByte[k], ReadBandwidthLuma[k] + ReadBandwidthChroma[k]);
	}
#endif
} 
