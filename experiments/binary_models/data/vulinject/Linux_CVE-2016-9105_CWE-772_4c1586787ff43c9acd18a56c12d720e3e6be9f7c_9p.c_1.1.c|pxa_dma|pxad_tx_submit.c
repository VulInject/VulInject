static dma_cookie_t pxad_tx_submit(struct dma_async_tx_descriptor *tx)
{
	struct virt_dma_chan *vc = to_virt_chan(tx->chan);
	struct pxad_chan *chan = to_pxad_chan(&vc->chan);
	struct virt_dma_desc *vd_chained = NULL,
		*vd = container_of(tx, struct virt_dma_desc, tx);
	dma_cookie_t cookie;
	unsigned int flags;
	set_updater_desc(to_pxad_sw_desc(vd), tx->flags);
	spin_lock_irqsave(&vc->lock, flags);
	cookie = dma_cookie_assign(tx);
	if (list_empty(&vc->desc_submitted) && pxad_try_hotchain(vc, vd)) {
		list_move_tail(&vd->node, &vc->desc_issued);
		dev_dbg(&chan->vc.chan.dev->device,
			"%s(): txd %p[%x]: submitted (hot linked)\n",
			__func__, vd, cookie);
		goto out;
	}
	if (!list_empty(&vc->desc_submitted)) {
		vd_chained = list_entry(vc->desc_submitted.prev,
					struct virt_dma_desc, node);
		if (chan->misaligned || !to_pxad_sw_desc(vd)->misaligned)
		else
			vd_chained = NULL;
	}
	dev_dbg(&chan->vc.chan.dev->device,
		"%s(): txd %p[%x]: submitted (%s linked)\n",
		__func__, vd, cookie, vd_chained ? "cold" : "not");
	list_move_tail(&vd->node, &vc->desc_submitted);
	chan->misaligned |= to_pxad_sw_desc(vd)->misaligned;
out:
	spin_unlock_irqrestore(&vc->lock, flags);
	return cookie;
}
