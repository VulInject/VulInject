static int alloc_nid_top_down_numa_part_reserved_fallback_check(void)
{
	int nid_req = 4;
	int nid_exp = NUMA_NODES - 1;
	struct memblock_region *new_rgn = &memblock.reserved.regions[1];
	struct memblock_region *req_node = &memblock.memory.regions[nid_req];
	struct memblock_region *exp_node = &memblock.memory.regions[nid_exp];
	void *allocated_ptr = NULL;
	struct region r1;
	phys_addr_t size;
	phys_addr_t min_addr;
	phys_addr_t max_addr;
	PREFIX_PUSH();
	ASSERT_LE(SZ_4, req_node->size);
	size = req_node->size / SZ_2;
	r1.base = req_node->base + (size / SZ_2);
	r1.size = size;
	min_addr = memblock_start_of_DRAM();
	max_addr = memblock_end_of_DRAM();
	memblock_reserve(r1.base, r1.size);
	allocated_ptr = run_memblock_alloc_nid(size, SMP_CACHE_BYTES,
					       min_addr, max_addr, nid_req);
	ASSERT_NE(allocated_ptr, NULL);
	assert_mem_content(allocated_ptr, size, alloc_nid_test_flags);
	ASSERT_EQ(new_rgn->size, size);
	ASSERT_EQ(new_rgn->base, region_end(exp_node) - size);
	ASSERT_LE(exp_node->base, new_rgn->base);
	ASSERT_EQ(memblock.reserved.cnt, 2);
	ASSERT_EQ(memblock.reserved.total_size, size + r1.size);
	test_pass_pop();
	return 0;
}
