sync_interface_stats_open(int *data_read_fd, ws_process_id *fork_child, char **data, char **msg, void (*update_cb)(void))
{
    int argc;
    char **argv;
    int ret;
    GIOChannel *message_read_io;
    char *wait_msg;
    char buffer[PIPE_BUF_SIZE+1] = {0};
    ssize_t nread;
    char indicator;
    int exec_errno = 0;
    int  primary_msg_len;
    char *primary_msg_text;
    int  secondary_msg_len;
    char *combined_msg;
    ws_debug("sync_interface_stats_open");
    argv = init_pipe_args(&argc);
    if (!argv) {
        *msg = g_strdup("We don't know where to find dumpcap.");
        return -1;
    }
    argv = sync_pipe_add_arg(argv, &argc, "-S");
    if (data) {
        argv = sync_pipe_add_arg(argv, &argc, "-D");
        argv = sync_pipe_add_arg(argv, &argc, "-L");
    }
#ifndef DEBUG_CHILD
#ifdef _WIN32
    argv = sync_pipe_add_arg(argv, &argc, "--signal-pipe");
    ret = create_dummy_signal_pipe(msg);
    if (ret == -1) {
        return -1;
    }
    argv = sync_pipe_add_arg(argv, &argc, dummy_control_id);
#endif
#endif
    ret = sync_pipe_open_command(argv, data_read_fd, &message_read_io, NULL,
                                 fork_child, NULL, msg, update_cb);
    if (ret == -1) {
        return -1;
    }
    do {
        nread = pipe_read_block(message_read_io, &indicator, SP_MAX_MSG_LEN,
                                buffer, msg);
		if(nread == 0) {
            ret = sync_pipe_wait_for_child(*fork_child, &wait_msg);
            g_io_channel_unref(message_read_io);
            ws_close(*data_read_fd);
            if(nread == 0) {
                if (ret == -1)
                    *msg = wait_msg;
                else
                    *msg = g_strdup("Child dumpcap closed sync pipe prematurely");
            } else {
                if (ret == -1) {
                    combined_msg = ws_strdup_printf("%s\n\n%s", *msg, wait_msg);
                    g_free(*msg);
                    g_free(wait_msg);
                    *msg = combined_msg;
                }
            }
            return -1;
        }
        switch(indicator) {
        case SP_EXEC_FAILED:
            if (!ws_strtoi32(buffer, NULL, &exec_errno)) {
                ws_warning("Invalid errno: %s", buffer);
            }
            *msg = ws_strdup_printf("Couldn't run dumpcap in child process: %s",
                                    g_strerror(exec_errno));
            char *close_msg = NULL;
            sync_pipe_close_command(data_read_fd, message_read_io,
                                    fork_child, &close_msg);
            g_free(close_msg);
            ret = -1;
            break;
        case SP_ERROR_MSG:
            pipe_convert_header((unsigned char*)buffer, 4, &indicator, &primary_msg_len);
            primary_msg_text = buffer+4;
            pipe_convert_header((unsigned char*)primary_msg_text + primary_msg_len, 4, &indicator,
                                &secondary_msg_len);
            ret = sync_pipe_close_command(data_read_fd, message_read_io,
                                          fork_child, msg);
            if (ret == -1) {
            } else if (ret == WS_EXIT_NO_INTERFACES) {
                *msg = g_strdup(primary_msg_text);
            } else {
                *msg = g_strdup(primary_msg_text);
                ret = -1;
            }
            return ret;
        case SP_LOG_MSG:
            sync_pipe_handle_log_msg(buffer);
            break;
        case SP_IFACE_LIST:
            *data = g_strdup(buffer);
            break;
        case SP_SUCCESS:
            g_io_channel_unref(message_read_io);
            break;
        default:
            ret = sync_pipe_close_command(data_read_fd, message_read_io,
                                          fork_child, msg);
            if (ret == -1) {
            } else {
                *msg = ws_strdup_printf("dumpcap process gave an unexpected message type: 0x%02x",
                                       indicator);
                ret = -1;
            }
            break;
        }
    } while (indicator != SP_SUCCESS && ret != -1);
    return ret;
}
