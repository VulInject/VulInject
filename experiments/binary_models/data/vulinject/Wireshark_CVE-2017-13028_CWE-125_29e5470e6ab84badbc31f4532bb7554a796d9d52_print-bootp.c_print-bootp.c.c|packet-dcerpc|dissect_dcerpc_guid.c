dissect_dcerpc_guid(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
    dcerpc_dissector_data_t* dissector_data = (dcerpc_dissector_data_t*)data;
    const gchar          *name     = NULL;
    dcerpc_sub_dissector *proc;
    int (*volatile sub_dissect)(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, dcerpc_info *di, guint8 *drep) = NULL;
    proto_item           *pi, *sub_item;
    proto_tree           *sub_tree;
    volatile guint        length;
    guint                 reported_length;
    volatile gint         offset   = 0;
    tvbuff_t *volatile    stub_tvb;
    tvbuff_t *volatile    payload_tvb = NULL;
    volatile guint        auth_pad_len;
    volatile int          auth_pad_offset;
    const char *volatile  saved_proto;
    for (proc = dissector_data->sub_proto->procs; proc->name; proc++) {
        if (proc->num == dissector_data->info->call_data->opnum) {
            name = proc->name;
            break;
        }
    }
    col_set_str(pinfo->cinfo, COL_PROTOCOL, dissector_data->sub_proto->name);
    if (!name)
        col_add_fstr(pinfo->cinfo, COL_INFO, "Unknown operation %u %s",
                     dissector_data->info->call_data->opnum,
                     (dissector_data->info->ptype == PDU_REQ) ? "request" : "response");
    else
        col_add_fstr(pinfo->cinfo, COL_INFO, "%s %s",
                     name, (dissector_data->info->ptype == PDU_REQ) ? "request" : "response");
    sub_dissect = (dissector_data->info->ptype == PDU_REQ) ?
        proc->dissect_rqst : proc->dissect_resp;
    sub_item = proto_tree_add_item(tree, dissector_data->sub_proto->proto_id,
                                       tvb,
                                       0, -1, ENC_NA);
    sub_tree = proto_item_add_subtree(sub_item, dissector_data->sub_proto->ett);
    if (!name)
        proto_item_append_text(sub_item, ", unknown operation %u",
                                dissector_data->info->call_data->opnum);
    else
        proto_item_append_text(sub_item, ", %s", name);
    if (tree) {
        if (dissector_data->sub_proto->opnum_hf != -1)
            proto_tree_add_uint_format(sub_tree, dissector_data->sub_proto->opnum_hf,
                                       tvb, 0, 0, dissector_data->info->call_data->opnum,
                                       "Operation: %s (%u)",
                                       name ? name : "Unknown operation",
                                       dissector_data->info->call_data->opnum);
        else
            proto_tree_add_uint_format_value(sub_tree, hf_dcerpc_op, tvb,
                                       0, 0, dissector_data->info->call_data->opnum,
                                       "%s (%u)",
                                       name ? name : "Unknown operation",
                                       dissector_data->info->call_data->opnum);
        if ((dissector_data->info->ptype == PDU_REQ) && (dissector_data->info->call_data->rep_frame != 0)) {
            pi = proto_tree_add_uint(sub_tree, hf_dcerpc_response_in,
                                     tvb, 0, 0, dissector_data->info->call_data->rep_frame);
            proto_item_set_generated(pi);
        }
        if ((dissector_data->info->ptype == PDU_RESP) && (dissector_data->info->call_data->req_frame != 0)) {
            pi = proto_tree_add_uint(sub_tree, hf_dcerpc_request_in,
                                     tvb, 0, 0, dissector_data->info->call_data->req_frame);
            proto_item_set_generated(pi);
        }
    } 
    if (!dissector_data->decrypted || (sub_dissect == NULL))
    {
        show_stub_data(pinfo, tvb, 0, sub_tree, dissector_data->auth_info, !dissector_data->decrypted);
        return tvb_captured_length(tvb);
    }
    saved_proto          = pinfo->current_proto;
    pinfo->current_proto = dissector_data->sub_proto->name;
    length = tvb_captured_length(tvb);
    reported_length = tvb_reported_length(tvb);
    if ((dissector_data->auth_info != NULL) && (dissector_data->auth_info->auth_pad_len != 0)) {
        if (reported_length >= dissector_data->auth_info->auth_pad_len) {
            reported_length -= dissector_data->auth_info->auth_pad_len;
            if (length > reported_length)
                length = reported_length;
            stub_tvb = tvb_new_subset_length_caplen(tvb, 0, length, reported_length);
            auth_pad_len = dissector_data->auth_info->auth_pad_len;
            auth_pad_offset = reported_length;
        } else {
            stub_tvb = NULL;
            auth_pad_len = reported_length;
            auth_pad_offset = 0;
            length = 0;
        }
    } else {
        stub_tvb = tvb;
        auth_pad_len = 0;
        auth_pad_offset = 0;
    }
    if (sub_item) {
        proto_item_set_len(sub_item, length);
    }
    if (stub_tvb != NULL) {
        TRY {
            proto_tree *stub_tree = NULL;
            int remaining;
            int trailer_start_offset = -1;
            int trailer_end_offset = -1;
            stub_tree = proto_tree_add_subtree_format(dissector_data->dcerpc_tree,
                                stub_tvb, 0, length,
                                ett_dcerpc_complete_stub_data, NULL,
                                "Complete stub data (%d byte%s)", length,
                                plurality(length, "", "s"));
            trailer_end_offset = dissect_verification_trailer(pinfo,
                                                    stub_tvb, 0,
                                                    stub_tree,
                                                    &trailer_start_offset);
            if (trailer_end_offset != -1) {
                remaining = tvb_captured_length_remaining(stub_tvb,
                                                    trailer_start_offset);
                length -= remaining;
                if (sub_item) {
                        proto_item_set_len(sub_item, length);
                }
            } else {
                proto_item *payload_item;
                payload_item = proto_tree_add_item(stub_tree,
                                    hf_dcerpc_payload_stub_data,
                                    stub_tvb, 0, length, ENC_NA);
                proto_item_append_text(payload_item, " (%d byte%s)",
                                        length, plurality(length, "", "s"));
            }
            payload_tvb = tvb_new_subset_length_caplen(stub_tvb, 0, length, length);
            offset = sub_dissect(payload_tvb, 0, pinfo, sub_tree,
                            dissector_data->info, dissector_data->drep);
            remaining = tvb_reported_length_remaining(stub_tvb, offset);
            if (trailer_end_offset != -1) {
                if (offset > trailer_start_offset) {
                    remaining = offset - trailer_start_offset;
                    proto_tree_add_item(sub_tree, hf_dcerpc_stub_data_with_sec_vt,
                                        stub_tvb, trailer_start_offset, remaining, ENC_NA);
                    col_append_fstr(pinfo->cinfo, COL_INFO,
                                        "[Payload with Verification Trailer (%d byte%s)]",
                                    remaining,
                                    plurality(remaining, "", "s"));
                    remaining = 0;
                } else {
                    remaining = trailer_start_offset - offset;
                }
            }
            if (remaining > 0) {
                proto_tree_add_expert(sub_tree, pinfo, &ei_dcerpc_long_frame, stub_tvb, offset, remaining);
                col_append_fstr(pinfo->cinfo, COL_INFO,
                                    "[Long frame (%d byte%s)]",
                                    remaining,
                                    plurality(remaining, "", "s"));
            }
        } CATCH_NONFATAL_ERRORS {
            show_exception(stub_tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);
        } ENDTRY;
    }
    if (auth_pad_len != 0) {
        proto_tree_add_item(sub_tree, hf_dcerpc_auth_padding, tvb, auth_pad_offset, auth_pad_len, ENC_NA);
    }
    pinfo->current_proto = saved_proto;
    return tvb_captured_length(tvb);
}
