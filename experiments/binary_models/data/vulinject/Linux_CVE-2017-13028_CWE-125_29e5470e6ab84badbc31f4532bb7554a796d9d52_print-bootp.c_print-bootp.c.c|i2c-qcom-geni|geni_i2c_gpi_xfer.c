static int geni_i2c_gpi_xfer(struct geni_i2c_dev *gi2c, struct i2c_msg msgs[], int num)
{
	struct dma_slave_config config = {};
	struct gpi_i2c_config peripheral = {};
	int i, ret = 0;
	unsigned int time_left;
	dma_addr_t tx_addr, rx_addr;
	void *tx_buf = NULL, *rx_buf = NULL;
	const struct geni_i2c_clk_fld *itr = gi2c->clk_fld;
	config.peripheral_config = &peripheral;
	config.peripheral_size = sizeof(peripheral);
	peripheral.pack_enable = I2C_PACK_TX | I2C_PACK_RX;
	peripheral.cycle_count = itr->t_cycle_cnt;
	peripheral.high_count = itr->t_high_cnt;
	peripheral.low_count = itr->t_low_cnt;
	peripheral.clk_div = itr->clk_div;
	peripheral.set_config = 1;
	peripheral.multi_msg = false;
	for (i = 0; i < num; i++) {
		gi2c->cur = &msgs[i];
		gi2c->err = 0;
		dev_dbg(gi2c->se.dev, "msg[%d].len:%d\n", i, gi2c->cur->len);
		peripheral.stretch = 0;
		if (i < num - 1)
			peripheral.stretch = 1;
		peripheral.addr = msgs[i].addr;
		ret =  geni_i2c_gpi(gi2c, &msgs[i], &config,
				    &tx_addr, &tx_buf, I2C_WRITE, gi2c->tx_c);
		if (ret)
			goto err;
		if (msgs[i].flags & I2C_M_RD) {
			ret =  geni_i2c_gpi(gi2c, &msgs[i], &config,
					    &rx_addr, &rx_buf, I2C_READ, gi2c->rx_c);
			if (ret)
				goto err;
		}
		dma_async_issue_pending(gi2c->tx_c);
		time_left = wait_for_completion_timeout(&gi2c->done, XFER_TIMEOUT);
		if (!time_left)
			gi2c->err = -ETIMEDOUT;
		if (gi2c->err) {
			ret = gi2c->err;
			goto err;
		}
		geni_i2c_gpi_unmap(gi2c, &msgs[i], tx_buf, tx_addr, rx_buf, rx_addr);
	}
	return num;
err:
	dev_err(gi2c->se.dev, "GPI transfer failed: %d\n", ret);
	dmaengine_terminate_sync(gi2c->rx_c);
	dmaengine_terminate_sync(gi2c->tx_c);
	geni_i2c_gpi_unmap(gi2c, &msgs[i], tx_buf, tx_addr, rx_buf, rx_addr);
	return ret;
}
