static int mpc_parse_run(mpc_input_t *i, mpc_parser_t *p, mpc_result_t *r, mpc_err_t **e, int depth) {
  int j = 0, k = 0;
  mpc_result_t results_stk[MPC_PARSE_STACK_MIN];
  mpc_result_t *results;
  int results_slots = MPC_PARSE_STACK_MIN;
  if (depth == MPC_MAX_RECURSION_DEPTH)
  {
    MPC_FAILURE(mpc_err_fail(i, "Maximum recursion depth exceeded!"));
  }
  switch (p->type) {
    case MPC_TYPE_ANY:     MPC_PRIMITIVE(mpc_input_any(i, (char**)&r->output));
    case MPC_TYPE_SINGLE:  MPC_PRIMITIVE(mpc_input_char(i, p->data.single.x, (char**)&r->output));
    case MPC_TYPE_RANGE:   MPC_PRIMITIVE(mpc_input_range(i, p->data.range.x, p->data.range.y, (char**)&r->output));
    case MPC_TYPE_ONEOF:   MPC_PRIMITIVE(mpc_input_oneof(i, p->data.string.x, (char**)&r->output));
    case MPC_TYPE_NONEOF:  MPC_PRIMITIVE(mpc_input_noneof(i, p->data.string.x, (char**)&r->output));
    case MPC_TYPE_SATISFY: MPC_PRIMITIVE(mpc_input_satisfy(i, p->data.satisfy.f, (char**)&r->output));
    case MPC_TYPE_STRING:  MPC_PRIMITIVE(mpc_input_string(i, p->data.string.x, (char**)&r->output));
    case MPC_TYPE_ANCHOR:  MPC_PRIMITIVE(mpc_input_anchor(i, p->data.anchor.f, (char**)&r->output));
    case MPC_TYPE_SOI:     MPC_PRIMITIVE(mpc_input_soi(i, (char**)&r->output));
    case MPC_TYPE_EOI:     MPC_PRIMITIVE(mpc_input_eoi(i, (char**)&r->output));
    case MPC_TYPE_UNDEFINED: MPC_FAILURE(mpc_err_fail(i, "Parser Undefined!"));
    case MPC_TYPE_PASS:      MPC_SUCCESS(NULL);
    case MPC_TYPE_FAIL:      MPC_FAILURE(mpc_err_fail(i, p->data.fail.m));
    case MPC_TYPE_LIFT:      MPC_SUCCESS(p->data.lift.lf());
    case MPC_TYPE_LIFT_VAL:  MPC_SUCCESS(p->data.lift.x);
    case MPC_TYPE_STATE:     MPC_SUCCESS(mpc_input_state_copy(i));
    case MPC_TYPE_APPLY:
      if (mpc_parse_run(i, p->data.apply.x, r, e, depth+1)) {
        MPC_SUCCESS(mpc_parse_apply(i, p->data.apply.f, r->output));
      } else {
      }
    case MPC_TYPE_APPLY_TO:
      if (mpc_parse_run(i, p->data.apply_to.x, r, e, depth+1)) {
        MPC_SUCCESS(mpc_parse_apply_to(i, p->data.apply_to.f, r->output, p->data.apply_to.d));
      } else {
        MPC_FAILURE(r->error);
      }
    case MPC_TYPE_CHECK:
      if (mpc_parse_run(i, p->data.check.x, r, e, depth+1)) {
        if (p->data.check.f(&r->output)) {
          MPC_SUCCESS(r->output);
        } else {
          mpc_parse_dtor(i, p->data.check.dx, r->output);
          MPC_FAILURE(mpc_err_fail(i, p->data.check.e));
        }
      } else {
        MPC_FAILURE(r->error);
      }
    case MPC_TYPE_CHECK_WITH:
      if (mpc_parse_run(i, p->data.check_with.x, r, e, depth+1)) {
        if (p->data.check_with.f(&r->output, p->data.check_with.d)) {
          MPC_SUCCESS(r->output);
        } else {
          mpc_parse_dtor(i, p->data.check.dx, r->output);
          MPC_FAILURE(mpc_err_fail(i, p->data.check_with.e));
        }
      } else {
        MPC_FAILURE(r->error);
      }
    case MPC_TYPE_EXPECT:
      mpc_input_suppress_enable(i);
      if (mpc_parse_run(i, p->data.expect.x, r, e, depth+1)) {
        mpc_input_suppress_disable(i);
        MPC_SUCCESS(r->output);
      } else {
        mpc_input_suppress_disable(i);
        MPC_FAILURE(mpc_err_new(i, p->data.expect.m));
      }
    case MPC_TYPE_PREDICT:
      mpc_input_backtrack_disable(i);
      if (mpc_parse_run(i, p->data.predict.x, r, e, depth+1)) {
        mpc_input_backtrack_enable(i);
        MPC_SUCCESS(r->output);
      } else {
        mpc_input_backtrack_enable(i);
        MPC_FAILURE(r->error);
      }
    case MPC_TYPE_NOT:
      mpc_input_mark(i);
      mpc_input_suppress_enable(i);
      if (mpc_parse_run(i, p->data.not.x, r, e, depth+1)) {
        mpc_input_rewind(i);
        mpc_input_suppress_disable(i);
        mpc_parse_dtor(i, p->data.not.dx, r->output);
        MPC_FAILURE(mpc_err_new(i, "opposite"));
      } else {
        mpc_input_unmark(i);
        mpc_input_suppress_disable(i);
        MPC_SUCCESS(p->data.not.lf());
      }
    case MPC_TYPE_MAYBE:
      if (mpc_parse_run(i, p->data.not.x, r, e, depth+1)) {
        MPC_SUCCESS(r->output);
      } else {
        *e = mpc_err_merge(i, *e, r->error);
        MPC_SUCCESS(p->data.not.lf());
      }
    case MPC_TYPE_MANY:
      results = results_stk;
      while (mpc_parse_run(i, p->data.repeat.x, &results[j], e, depth+1)) {
        j++;
        if (j == MPC_PARSE_STACK_MIN) {
          results_slots = j + j / 2;
          results = mpc_malloc(i, sizeof(mpc_result_t) * results_slots);
          memcpy(results, results_stk, sizeof(mpc_result_t) * MPC_PARSE_STACK_MIN);
        } else if (j >= results_slots) {
          results_slots = j + j / 2;
          results = mpc_realloc(i, results, sizeof(mpc_result_t) * results_slots);
        }
      }
      *e = mpc_err_merge(i, *e, results[j].error);
      MPC_SUCCESS(
        mpc_parse_fold(i, p->data.repeat.f, j, (mpc_val_t**)results);
        if (j >= MPC_PARSE_STACK_MIN) { mpc_free(i, results); });
    case MPC_TYPE_MANY1:
      results = results_stk;
      while (mpc_parse_run(i, p->data.repeat.x, &results[j], e, depth+1)) {
        j++;
        if (j == MPC_PARSE_STACK_MIN) {
          results_slots = j + j / 2;
          results = mpc_malloc(i, sizeof(mpc_result_t) * results_slots);
          memcpy(results, results_stk, sizeof(mpc_result_t) * MPC_PARSE_STACK_MIN);
        } else if (j >= results_slots) {
          results_slots = j + j / 2;
          results = mpc_realloc(i, results, sizeof(mpc_result_t) * results_slots);
        }
      }
      if (j == 0) {
        MPC_FAILURE(
          mpc_err_many1(i, results[j].error);
          if (j >= MPC_PARSE_STACK_MIN) { mpc_free(i, results); });
      } else {
        *e = mpc_err_merge(i, *e, results[j].error);
        MPC_SUCCESS(
          mpc_parse_fold(i, p->data.repeat.f, j, (mpc_val_t**)results);
          if (j >= MPC_PARSE_STACK_MIN) { mpc_free(i, results); });
      }
    case MPC_TYPE_COUNT:
      results = p->data.repeat.n > MPC_PARSE_STACK_MIN
        ? mpc_malloc(i, sizeof(mpc_result_t) * p->data.repeat.n)
        : results_stk;
      while (mpc_parse_run(i, p->data.repeat.x, &results[j], e, depth+1)) {
        j++;
        if (j == p->data.repeat.n) { break; }
      }
      if (j == p->data.repeat.n) {
        MPC_SUCCESS(
          mpc_parse_fold(i, p->data.repeat.f, j, (mpc_val_t**)results);
          if (p->data.repeat.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); });
      } else {
        for (k = 0; k < j; k++) {
          mpc_parse_dtor(i, p->data.repeat.dx, results[k].output);
        }
        MPC_FAILURE(
          mpc_err_count(i, results[j].error, p->data.repeat.n);
          if (p->data.repeat.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); });
      }
    case MPC_TYPE_OR:
      if (p->data.or.n == 0) { MPC_SUCCESS(NULL); }
      results = p->data.or.n > MPC_PARSE_STACK_MIN
        ? mpc_malloc(i, sizeof(mpc_result_t) * p->data.or.n)
        : results_stk;
      for (j = 0; j < p->data.or.n; j++) {
        if (mpc_parse_run(i, p->data.or.xs[j], &results[j], e, depth+1)) {
          MPC_SUCCESS(results[j].output;
            if (p->data.or.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); });
        } else {
          *e = mpc_err_merge(i, *e, results[j].error);
        }
      }
      MPC_FAILURE(NULL;
        if (p->data.or.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); });
    case MPC_TYPE_AND:
      if (p->data.and.n == 0) { MPC_SUCCESS(NULL); }
      results = p->data.or.n > MPC_PARSE_STACK_MIN
        ? mpc_malloc(i, sizeof(mpc_result_t) * p->data.or.n)
        : results_stk;
      mpc_input_mark(i);
      for (j = 0; j < p->data.and.n; j++) {
        if (!mpc_parse_run(i, p->data.and.xs[j], &results[j], e, depth+1)) {
          mpc_input_rewind(i);
          for (k = 0; k < j; k++) {
            mpc_parse_dtor(i, p->data.and.dxs[k], results[k].output);
          }
          MPC_FAILURE(results[j].error;
            if (p->data.or.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); });
        }
      }
      mpc_input_unmark(i);
      MPC_SUCCESS(
        mpc_parse_fold(i, p->data.and.f, j, (mpc_val_t**)results);
        if (p->data.or.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); });
    default:
      MPC_FAILURE(mpc_err_fail(i, "Unknown Parser Type Id!"));
  }
  return 0;
}
