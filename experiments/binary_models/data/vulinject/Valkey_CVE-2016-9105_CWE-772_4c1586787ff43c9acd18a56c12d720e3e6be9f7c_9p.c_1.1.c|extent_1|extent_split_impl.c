extent_split_impl(tsdn_t *tsdn, pac_t *pac, ehooks_t *ehooks,
    edata_t *edata, size_t size_a, size_t size_b, bool holding_core_locks) {
	assert(edata_size_get(edata) == size_a + size_b);
	/* Only the shrink path may split w/o holding core locks. */
	if (holding_core_locks) {
		witness_assert_positive_depth_to_rank(
		    tsdn_witness_tsdp_get(tsdn), WITNESS_RANK_CORE);
	} else {
		witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
		    WITNESS_RANK_CORE, 0);
	}
	if (ehooks_split_will_fail(ehooks)) {
		return NULL;
	}
	edata_t *trail = edata_cache_get(tsdn, pac->edata_cache);
	if (trail == NULL) {
		goto label_error_a;
	}
	edata_init(trail, edata_arena_ind_get(edata),
	    (void *)((uintptr_t)edata_base_get(edata) + size_a), size_b,
	    /* slab */ false, SC_NSIZES, edata_sn_get(edata),
	    edata_state_get(edata), edata_zeroed_get(edata),
	    edata_committed_get(edata), EXTENT_PAI_PAC, EXTENT_NOT_HEAD);
	emap_prepare_t prepare;
	bool err = emap_split_prepare(tsdn, pac->emap, &prepare, edata,
	    size_a, trail, size_b);
	if (err) {
		goto label_error_b;
	}
	/*
	 * No need to acquire trail or edata, because: 1) trail was new (just
	 * allocated); and 2) edata is either an active allocation (the shrink
	 * path), or in an acquired state (extracted from the ecache on the
	 * extent_recycle_split path).
	 */
	assert(emap_edata_is_acquired(tsdn, pac->emap, edata));
	assert(emap_edata_is_acquired(tsdn, pac->emap, trail));
	err = ehooks_split(tsdn, ehooks, edata_base_get(edata), size_a + size_b,
	    size_a, size_b, edata_committed_get(edata));
	if (err) {
		goto label_error_b;
	}
	emap_split_commit(tsdn, pac->emap, &prepare, edata, size_a, trail,
	    size_b);
	return trail;
label_error_b:
	edata_cache_put(tsdn, pac->edata_cache, trail);
label_error_a:
	return NULL;
}
