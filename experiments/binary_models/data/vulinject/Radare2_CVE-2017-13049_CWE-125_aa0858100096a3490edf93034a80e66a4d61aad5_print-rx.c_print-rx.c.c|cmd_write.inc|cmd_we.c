static int cmd_we(void *data, const char *input) {
	RCore *core = (RCore *)data;
	ut64 addr = 0, len = 0, b_size = 0;
	st64 dist = 0;
	ut8* bytes = NULL;
	int cmd_suc = false;
	char *input_shadow = NULL, *p = NULL;
	char *save_ptr = NULL;
	switch (input[0]) {
	case 'n': 
		if (input[1] == ' ') {
			len = *input ? r_num_math (core->num, input + 2) : 0;
			if (len > 0) {
				const ut64 cur_off = core->offset;
				cmd_suc = r_core_extend_at (core, core->offset, len);
				if (cmd_suc) {
					core->offset = cur_off;
				} else {
					R_LOG_ERROR ("r_io_extend failed");
					cmd_suc = true;
				}
			}
		} else {
			r_core_cmd_help_match (core, help_msg_we, "wen");
			cmd_suc = true;
		}
		break;
	case 'N': 
		if (input[1] == ' ') {
			input = r_str_trim_head_ro (input + 2);
			addr = r_num_math (core->num, input);
			while (*input && *input != ' ') {
				input++;
			}
			if (*input) {
				input++;
			}
			len = *input ? r_num_math (core->num, input) : 0;
			if (len > 0) {
				ut64 cur_off = core->offset;
				cmd_suc = r_core_extend_at (core, addr, len);
				if (cmd_suc) {
					r_core_seek (core, cur_off, true);
					core->offset = addr;
					r_core_block_read (core);
				} else {
					R_LOG_ERROR ("r_io_extend failed");
				}
			}
			cmd_suc = true;
		}
		break;
	case 'x': 
		if (input[1] == ' ') {
			input += 1;
			len = *input ? strlen (input) : 0;
			bytes = len > 1? malloc (len+1) : NULL;
			len = bytes ? r_hex_str2bin (input, bytes) : 0;
			if (len > 0) {
				ut64 cur_off = core->offset;
				cmd_suc = r_core_extend_at (core, cur_off, len);
				if (cmd_suc) {
					if (!r_core_write_at (core, cur_off, bytes, len)) {
						cmd_write_fail (core);
					}
				}
				core->offset = cur_off;
				r_core_block_read (core);
			}
			free (bytes);
		}
		break;
	case 's': 
		input += 2;
		while (*input && *input == ' ') {
			input++;
		}
		len = strlen (input);
		if (len > 0) {
			input_shadow = strdup (input);
			p = r_str_tok_r (input_shadow, " ", &save_ptr);
			addr = p && *p ? r_num_math (core->num, p) : 0;
			p = r_str_tok_r (NULL, " ", &save_ptr);
			dist = p && *p ? r_num_math (core->num, p) : 0;
			p = r_str_tok_r (NULL, " ", &save_ptr);
			b_size = p && *p ? r_num_math (core->num, p) : 0;
			if (dist != 0) {
				r_core_shift_block (core, addr, b_size, dist);
				r_core_seek (core, addr, true);
				cmd_suc = true;
			}
		}
		free (input_shadow);
		break;
	case 'X': 
		if (input[1] == ' ') {
			input = r_str_trim_head_ro (input + 2);
			addr = r_num_math (core->num, input);
			while (*input && *input != ' ') {
				input++;
			}
			if (*input) {
				input++;
			}
			len = *input ? strlen (input) : 0;
			bytes = (len > 1)? malloc (len + 1) : NULL;
			len = bytes ? r_hex_str2bin (input, bytes) : 0;
			if (len > 0) {
				cmd_suc = r_core_extend_at (core, addr, len);
				if (cmd_suc) {
					if (!r_core_write_at (core, addr, bytes, len)) {
						cmd_write_fail (core);
					}
				} else {
					R_LOG_ERROR ("r_io_extend failed");
				}
				core->offset = addr;
				r_core_block_read (core);
			}
			free (bytes);
		}
		break;
	case '?': 
	default:
		cmd_suc = false;
		break;
	}
	if (cmd_suc == false) {
		r_core_cmd_help (core, help_msg_we);
	}
	return 0;
}
