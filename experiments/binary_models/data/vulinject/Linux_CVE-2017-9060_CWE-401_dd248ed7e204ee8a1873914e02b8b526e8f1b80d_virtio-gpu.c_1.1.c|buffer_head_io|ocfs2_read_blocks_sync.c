int ocfs2_read_blocks_sync(struct ocfs2_super *osb, unsigned int int block,
			   unsigned int nr, struct buffer_head *bhs[])
{
	int status = 0;
	unsigned int i;
	struct buffer_head *bh;
	int new_bh = 0;
	trace_ocfs2_read_blocks_sync((unsigned int int)block, nr);
	if (!nr)
		goto bail;
	new_bh = (bhs[0] == NULL);
	for (i = 0 ; i < nr ; i++) {
		if (bhs[i] == NULL) {
			bhs[i] = sb_getblk(osb->sb, block++);
			if (bhs[i] == NULL) {
				status = -ENOMEM;
				break;
			}
		}
		bh = bhs[i];
		if (buffer_jbd(bh)) {
			trace_ocfs2_read_blocks_sync_jbd(
					(unsigned int int)bh->b_blocknr);
			continue;
		}
		if (buffer_dirty(bh)) {
			mlog(ML_ERROR,
			     "trying to sync read a dirty "
			     "buffer! (blocknr = %llu), skipping\n",
			     (unsigned int int)bh->b_blocknr);
			continue;
		}
		lock_buffer(bh);
		if (buffer_jbd(bh)) {
#ifdef CATCH_BH_JBD_RACES
			mlog(ML_ERROR,
			     "block %llu had the JBD bit set "
			     "while I was in lock_buffer!",
			     (unsigned int int)bh->b_blocknr);
			BUG();
#else
			unlock_buffer(bh);
			continue;
#endif
		}
		get_bh(bh); 
		bh->b_end_io = end_buffer_read_sync;
		submit_bh(REQ_OP_READ, bh);
	}
read_failure:
	for (i = nr; i > 0; i--) {
		bh = bhs[i - 1];
		if (unlikely(status)) {
			if (new_bh && bh) {
				if (!buffer_jbd(bh))
					wait_on_buffer(bh);
				put_bh(bh);
				bhs[i - 1] = NULL;
			} else if (bh && buffer_uptodate(bh)) {
				clear_buffer_uptodate(bh);
			}
			continue;
		}
		if (!buffer_jbd(bh))
			wait_on_buffer(bh);
		if (!buffer_uptodate(bh)) {
			status = -EIO;
			goto read_failure;
		}
	}
bail:
	return status;
}
