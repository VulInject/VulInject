static int concat_parse_script(AVFormatContext *avf)
{
    ConcatContext *cat = avf->priv_data;
    unsigned nb_files_alloc = 0;
    AVBPrint bp;
    uint8_t *cursor, *keyword;
    ConcatFile *file = NULL;
    AVStream *stream = NULL;
    AVChapter *chapter = NULL;
    unsigned line = 0, arg;
    const ParseSyntax *dir;
    char *arg_kw[MAX_ARGS];
    char *arg_str[MAX_ARGS] = { 0 };
    int64_t arg_int[MAX_ARGS];
    int ret;
    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_UNLIMITED);
    while ((ret = ff_read_line_to_bprint_overwrite(avf->pb, &bp)) >= 0) {
        line++;
        cursor = bp.str;
        keyword = get_keyword(&cursor);
        if (!*keyword || *keyword == '#')
            continue;
        for (dir = syntax; dir < syntax + FF_ARRAY_ELEMS(syntax); dir++)
            if (!strcmp(dir->keyword, keyword))
                break;
        if (dir >= syntax + FF_ARRAY_ELEMS(syntax)) {
            av_log(avf, AV_LOG_ERROR, "Line %d: unknown keyword '%s'\n",
                   line, keyword);
            FAIL(AVERROR_INVALIDDATA);
        }
        /* Flags check */
        if ((dir->flags & NEEDS_UNSAFE) && cat->safe) {
            av_log(avf, AV_LOG_ERROR, "Line %d: %s not allowed if safe\n", line, keyword);
            FAIL(AVERROR_INVALIDDATA);
        }
        if ((dir->flags & NEEDS_FILE) && !cat->nb_files) {
            av_log(avf, AV_LOG_ERROR, "Line %d: %s without file\n", line, keyword);
            FAIL(AVERROR_INVALIDDATA);
        }
        if ((dir->flags & NEEDS_STREAM) && !avf->nb_streams) {
            av_log(avf, AV_LOG_ERROR, "Line %d: %s without stream\n", line, keyword);
            FAIL(AVERROR_INVALIDDATA);
        }
        /* Arguments parsing */
        for (arg = 0; arg < FF_ARRAY_ELEMS(dir->args) && dir->args[arg]; arg++) {
            switch (dir->args[arg]) {
            case 'd': /* duration */
                arg_kw[arg] = get_keyword(&cursor);
                ret = av_parse_time(&arg_int[arg], arg_kw[arg], 1);
                if (ret < 0) {
                    av_log(avf, AV_LOG_ERROR, "Line %d: invalid duration '%s'\n",
                           line, arg_kw[arg]);
                    goto fail;
                }
                break;
            case 'i': /* integer */
                arg_int[arg] = strtol(get_keyword(&cursor), NULL, 0);
                break;
            case 'k': /* keyword */
                arg_kw[arg] = get_keyword(&cursor);
                break;
            case 's': /* string */
                av_assert0(!arg_str[arg]);
                arg_str[arg] = av_get_token((const char **)&cursor, SPACE_CHARS);
                if (!arg_str[arg])
                    FAIL(AVERROR(ENOMEM));
                if (!*arg_str[arg]) {
                    av_log(avf, AV_LOG_ERROR, "Line %d: string required\n", line);
                    FAIL(AVERROR_INVALIDDATA);
                }
                break;
            default:
                FAIL(AVERROR_BUG);
            }
        }
        /* Directive action */
        switch ((ParseDirective)(dir - syntax)) {
        case DIR_FFCONCAT:
            if (strcmp(arg_kw[0], "version") || strcmp(arg_kw[1], "1.0")) {
                av_log(avf, AV_LOG_ERROR, "Line %d: invalid version\n", line);
                FAIL(AVERROR_INVALIDDATA);
            }
            break;
        case DIR_FILE:
            ret = add_file(avf, arg_str[0], &file, &nb_files_alloc);
            arg_str[0] = NULL;
            if (ret < 0)
                goto fail;
            break;
        case DIR_DURATION:
            file->user_duration = arg_int[0];
            break;
        case DIR_INPOINT:
            file->inpoint = arg_int[0];
            break;
        case DIR_OUTPOINT:
            file->outpoint = arg_int[0];
            break;
        case DIR_FPMETA:
            ret = av_dict_set(&file->metadata, arg_kw[0], arg_str[1], AV_DICT_DONT_STRDUP_VAL);
            arg_str[1] = NULL;
            if (ret < 0)
                FAIL(ret);
            break;
        case DIR_FPMETAS:
            if ((ret = av_dict_parse_string(&file->metadata, arg_str[0], "=", "", 0)) < 0) {
                av_log(avf, AV_LOG_ERROR, "Line %d: failed to parse metadata string\n", line);
                FAIL(AVERROR_INVALIDDATA);
            }
            av_log(avf, AV_LOG_WARNING,
                   "'file_packet_metadata key=value:key=value' is deprecated, "
                   "use multiple 'file_packet_meta key value' instead\n");
            av_freep(&arg_str[0]);
            break;
        case DIR_OPTION:
            ret = av_dict_set(&file->options, arg_kw[0], arg_str[1], AV_DICT_DONT_STRDUP_VAL);
            arg_str[1] = NULL;
            if (ret < 0)
                FAIL(ret);
            break;
        case DIR_STREAM:
            stream = avformat_new_stream(avf, NULL);
            if (!stream)
                FAIL(AVERROR(ENOMEM));
            break;
        case DIR_EXSID:
            stream->id = arg_int[0];
            break;
        case DIR_STMETA:
            ret = av_dict_set(&stream->metadata, arg_kw[0], arg_str[1], AV_DICT_DONT_STRDUP_VAL);
            arg_str[1] = NULL;
            if (ret < 0)
                FAIL(ret);
            break;
        case DIR_STCODEC: {
            const AVCodecDescriptor *codec = avcodec_descriptor_get_by_name(arg_kw[0]);
            if (!codec) {
                av_log(avf, AV_LOG_ERROR, "Line %d: codec '%s' not found\n", line, arg_kw[0]);
                FAIL(AVERROR_DECODER_NOT_FOUND);
            }
            stream->codecpar->codec_type = codec->type;
            stream->codecpar->codec_id = codec->id;
            break;
        }
        case DIR_STEDATA: {
            int size = ff_hex_to_data(NULL, arg_kw[0]);
	ret=((stream->codecpar+size-1)/size);
            if (ret < 0)
                FAIL(ret);
            ff_hex_to_data(stream->codecpar->extradata, arg_kw[0]);
            break;
        }
        case DIR_CHAPTER:
            chapter = avpriv_new_chapter(avf, arg_int[0], AV_TIME_BASE_Q,
                                         arg_int[1], arg_int[2], NULL);
            if (!chapter)
                FAIL(ENOMEM);
            break;
        default:
            FAIL(AVERROR_BUG);
        }
    }
fail:
    for (arg = 0; arg < MAX_ARGS; arg++)
        av_freep(&arg_str[arg]);
    av_bprint_finalize(&bp, NULL);
    return ret == AVERROR_EOF ? 0 : ret;
}
