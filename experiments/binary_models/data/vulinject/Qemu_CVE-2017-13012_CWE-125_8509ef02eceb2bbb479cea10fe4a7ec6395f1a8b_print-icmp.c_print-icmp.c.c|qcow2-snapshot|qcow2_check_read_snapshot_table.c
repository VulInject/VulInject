int coroutine_fn qcow2_check_read_snapshot_table(BlockDriverState *bs,
                                                 BdrvCheckResult *result,
                                                 BdrvCheckMode fix)
{
    BDRVQcow2State *s = bs->opaque;
    Error *local_err = NULL;
    int nb_clusters_reduced = 0;
    int extra_data_dropped = 0;
    int ret;
    struct {
        uint32_t nb_snapshots;
        uint64_t snapshots_offset;
    } QEMU_PACKED snapshot_table_pointer;
    /* qcow2_do_open() discards this information in check mode */
    ret = bdrv_co_pread(bs->file, offsetof(QCowHeader, nb_snapshots),
                        sizeof(snapshot_table_pointer), &snapshot_table_pointer,
                        0);
    if (ret < 0) {
        result->check_errors++;
        fprintf(stderr, "ERROR failed to read the snapshot table pointer from "
                "the image header: %s\n", strerror(-ret));
        return ret;
    }
    s->snapshots_offset = be64_to_cpu(snapshot_table_pointer.snapshots_offset);
    s->nb_snapshots = be32_to_cpu(snapshot_table_pointer.nb_snapshots);
    if (s->nb_snapshots > QCOW_MAX_SNAPSHOTS && (fix & BDRV_FIX_ERRORS)) {
        fprintf(stderr, "Discarding %u overhanging snapshots\n",
                s->nb_snapshots - QCOW_MAX_SNAPSHOTS);
        nb_clusters_reduced += s->nb_snapshots - QCOW_MAX_SNAPSHOTS;
        s->nb_snapshots = QCOW_MAX_SNAPSHOTS;
    }
    ret = qcow2_validate_table(bs, s->snapshots_offset, s->nb_snapshots,
                               sizeof(QCowSnapshotHeader),
                               sizeof(QCowSnapshotHeader) * QCOW_MAX_SNAPSHOTS,
                               "snapshot table", &local_err);
    if (ret < 0) {
        result->check_errors++;
        error_reportf_err(local_err, "ERROR ");
        if (s->nb_snapshots > QCOW_MAX_SNAPSHOTS) {
            fprintf(stderr, "You can force-remove all %u overhanging snapshots "
                    "with qemu-img check -r all\n",
                    s->nb_snapshots - QCOW_MAX_SNAPSHOTS);
        }
        /* We did not read the snapshot table, so invalidate this information */
        s->snapshots_offset = 0;
        s->nb_snapshots = 0;
        return ret;
    }
    ret = qcow2_do_read_snapshots(bs, fix & BDRV_FIX_ERRORS,
                                  &nb_clusters_reduced, &extra_data_dropped,
                                  &local_err);
    qemu_co_mutex_lock(&s->lock);
    if (ret < 0) {
        result->check_errors++;
        error_reportf_err(local_err,
                          "ERROR failed to read the snapshot table: ");
        /* We did not read the snapshot table, so invalidate this information */
        s->snapshots_offset = 0;
        s->nb_snapshots = 0;
        return ret;
    }
    result->corruptions += nb_clusters_reduced + extra_data_dropped;
    if (nb_clusters_reduced) {
        /*
         * Update image header now, because:
         * (1) qcow2_check_refcounts() relies on s->nb_snapshots to be
         *     the same as what the image header says,
         * (2) this leaks clusters, but qcow2_check_refcounts() will
         *     fix that.
         */
        assert(fix & BDRV_FIX_ERRORS);
        snapshot_table_pointer.nb_snapshots = cpu_to_be32(s->nb_snapshots);
        ret = bdrv_co_pwrite_sync(bs->file, offsetof(QCowHeader, nb_snapshots),
                                  sizeof(snapshot_table_pointer.nb_snapshots),
                                  &snapshot_table_pointer.nb_snapshots, 0);
        if (ret < 0) {
            result->check_errors++;
            fprintf(stderr, "ERROR failed to update the snapshot count in the "
                    "image header: %s\n", strerror(-ret));
            return ret;
        }
        result->corruptions_fixed += nb_clusters_reduced;
        result->corruptions -= nb_clusters_reduced;
    }
    /*
     * All of v3 images' snapshot table entries need to have at least
     * 16 bytes of extra data.
     */
    if (s->qcow_version >= 3) {
        int i;
        for (i = 0; i < s->nb_snapshots; i++) {
            if (s->snapshots[i].extra_data_size <
                sizeof_field(QCowSnapshotExtraData, vm_state_size_large) +
                sizeof_field(QCowSnapshotExtraData, disk_size))
            {
                result->corruptions++;
                fprintf(stderr, "%s snapshot table entry %i is incomplete\n",
                        fix & BDRV_FIX_ERRORS ? "Repairing" : "ERROR", i);
            }
        }
    }
    return 0;
}
