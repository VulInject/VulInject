static bool logcat_read_packet(struct logcat_phdr *logcat, FILE_T fh,
    wtap_rec *rec, Buffer *buf, int *err, char **err_info)
{
    int                  packet_size;
    unsigned short             payload_length;
    unsigned             tmp[2];
    unsigned char             *pd;
    struct logger_entry *log_entry;
    if (!wtap_read_bytes_or_eof(fh, &tmp, 2, err, err_info)) {
        return false;
    }
    payload_length = pletoh16(tmp);
    if (logcat->version == 1) {
        packet_size = (int)sizeof(struct logger_entry) + payload_length;
    } else if (logcat->version == 2) {
        packet_size = (int)sizeof(struct logger_entry_v2) + payload_length;
    } else {
        return false;
    }
    pd = ws_buffer_start_ptr(buf);
    log_entry = (struct logger_entry *)(void *) pd;
    memcpy(pd, tmp, 2);
    if (!wtap_read_bytes(fh, pd + 2, packet_size - 2, err, err_info)) {
        return false;
    }
    rec->rec_type = REC_TYPE_PACKET;
    rec->block = wtap_block_create(WTAP_BLOCK_PACKET);
    rec->presence_flags = WTAP_HAS_TS;
    rec->ts.secs = (time_t) GINT32_FROM_LE(log_entry->sec);
    rec->ts.nsecs = GINT32_FROM_LE(log_entry->nsec);
    rec->rec_header.packet_header.caplen = packet_size;
    rec->rec_header.packet_header.len = packet_size;
    rec->rec_header.packet_header.pseudo_header.logcat.version = logcat->version;
    return true;
}
