  parse_subrs( FT_Face  face,     
               void*    loader_ )
  {
    T1_Face    t1face = (T1_Face)face;
    T1_Loader  loader = (T1_Loader)loader_;
    T1_Parser  parser = &loader->parser;
    PS_Table   table  = &loader->subrs;
    FT_Memory  memory = parser->root.memory;
    FT_Error   error;
    FT_Int     num_subrs;
    FT_UInt    count;
    PSAux_Service  psaux = (PSAux_Service)t1face->psaux;
    if ( parser->root.cursor < parser->root.limit &&
         *parser->root.cursor == '['              )
    {
      T1_Skip_PS_Token( parser );
      T1_Skip_Spaces  ( parser );
      if ( parser->root.cursor >= parser->root.limit ||
           *parser->root.cursor != ']'               )
        parser->root.error = FT_THROW( Invalid_File_Format );
      return;
    }
    num_subrs = (FT_Int)T1_ToInt( parser );
    if ( num_subrs < 0 )
    {
      parser->root.error = FT_THROW( Invalid_File_Format );
      return;
    }
    if ( parser->root.limit >= parser->root.cursor                     &&
         num_subrs > ( parser->root.limit - parser->root.cursor ) >> 3 )
    {
      FT_TRACE0(( "parse_subrs: adjusting number of subroutines"
                  " (from %d to %zu)\n",
                  num_subrs,
                  ( parser->root.limit - parser->root.cursor ) >> 3 ));
      num_subrs = ( parser->root.limit - parser->root.cursor ) >> 3;
      if ( !loader->subrs_hash )
      {
        if ( FT_QNEW( loader->subrs_hash ) )
          goto Fail;
        error = ft_hash_num_init( loader->subrs_hash, memory );
        if ( error )
          goto Fail;
      }
    }
    T1_Skip_PS_Token( parser );         
    if ( parser->root.error )
      return;
    T1_Skip_Spaces( parser );
    if ( !loader->num_subrs )
    {
      error = psaux->ps_table_funcs->init( table, num_subrs, memory );
      if ( error )
        goto Fail;
    }
    for ( count = 0; ; count++ )
    {
      FT_Long   idx;
      FT_ULong  size;
      FT_Byte*  base;
      if ( parser->root.cursor + 4 >= parser->root.limit          ||
          ft_strncmp( (char*)parser->root.cursor, "dup", 3 ) != 0 )
        break;
      T1_Skip_PS_Token( parser );       
      idx = T1_ToInt( parser );
      if ( !read_binary_data( parser, &size, &base, IS_INCREMENTAL ) )
        return;
      T1_Skip_PS_Token( parser );   
      if ( parser->root.error )
        return;
      T1_Skip_Spaces  ( parser );
      if ( parser->root.cursor + 4 < parser->root.limit            &&
           ft_strncmp( (char*)parser->root.cursor, "put", 3 ) == 0 )
      {
        T1_Skip_PS_Token( parser ); 
        T1_Skip_Spaces  ( parser );
      }
      if ( loader->subrs_hash )
      {
        ft_hash_num_insert( idx, count, loader->subrs_hash, memory );
        idx = count;
      }
      if ( loader->num_subrs )
        continue;
      if ( t1face->type1.private_dict.lenIV >= 0 )
      {
        FT_Byte*  temp = NULL;
        if ( size < (FT_ULong)t1face->type1.private_dict.lenIV )
        {
          error = FT_THROW( Invalid_File_Format );
          goto Fail;
        }
        if ( FT_DUP( temp, base, size ) )
          goto Fail;
        psaux->t1_decrypt( temp, size, 4330 );
        size -= (FT_ULong)t1face->type1.private_dict.lenIV;
        error = T1_Add_Table( table,
                              (FT_Int)idx,
                              temp + t1face->type1.private_dict.lenIV,
                              size );
        FT_FREE( temp );
      }
      else
        error = T1_Add_Table( table, (FT_Int)idx, base, size );
      if ( error )
        goto Fail;
    }
    if ( !loader->num_subrs )
      loader->num_subrs = num_subrs;
#ifdef FT_DEBUG_LEVEL_TRACE
      FT_TRACE4(( " <" ));
      FT_TRACE4(( "%d elements", num_subrs ));
      FT_TRACE4(( ">\n" ));
#endif
    return;
  Fail:
    parser->root.error = error;
  }
