static bool decode(RArchSession *as, RAnalOp *op, RAnalOpMask mask) {
	const ut64 addr = op->addr;
	const ut8 *b = op->bytes;
	const int len = op->size;
	struct loongarch_ASE *ase = NULL;
	const struct loongarch_anal_opcode *it;
	ut32 opcode; 
	ut32 insn_id = 0;
	if (!op || (len < INSNLEN)) {
		return false;
	}
	op->type = R_ANAL_OP_TYPE_UNK;
	op->size = INSNLEN;
	op->addr = addr;
	opcode = r_read_le32 (b);
	PluginData *pd = as->data;
	for (ase = pd->la_ases; ase->opcode; ase++) {
		if (!ase->opc_htab_inited) {
			for (it=ase->opcode; it->match; it++) {
				if (!ase->la_opcode_ht[LA_INSN_HASH(it->match)]) {
					ase->la_opcode_ht[LA_INSN_HASH(it->match)] = it;
				}
			}
			int i;
			for (i = 0; i < HT_NUM; i++) {
				if (!ase->la_opcode_ht[i]) {
					ase->la_opcode_ht[i]=it;
				}
			}
			ase->opc_htab_inited = 1;
		}
		it = ase->la_opcode_ht[LA_INSN_HASH(opcode)];
		for (; it->match; it++) {
			if ((opcode & it->mask) == it->match) {
				insn_id = it->index;
				op->type = it->r_type;
			}
		}
	}
	op->id = insn_id;
	switch (insn_id) {
	case LA_INS_BEQ:
	case LA_INS_BNE:
	case LA_INS_BLT:
	case LA_INS_BGE:
	case LA_INS_BLTU:
	case LA_INS_BGEU:
		op->jump = addr + I16s2_SX(opcode);
		op->fail = addr + INSNLEN;
		break;
	case LA_INS_BEQZ:
	case LA_INS_BNEZ:
		op->jump = addr + I21s2_SX(opcode);
		op->fail = addr + INSNLEN;
		break;
	case LA_INS_B:
		op->jump = addr + I26s2_SX(opcode);
		break;
	case LA_INS_BL:
		op->jump = addr + I26s2_SX(opcode);
		op->fail = addr + INSNLEN;
		break;
	case LA_INS_JIRL:
		break;
	case LA_INS_LD_B:
		break;
	case LA_INS_PCADDU12I:
		break;
	default:
		break;
	}
	if (mask & R_ARCH_OP_MASK_ESIL) {
		if (analop_esil (as, op, opcode)) {
		}
	}
	if (mask & R_ARCH_OP_MASK_VAL) {
	}
	if (mask & R_ARCH_OP_MASK_DISASM) {
		PluginData *pd = as->data;
		struct disassemble_info disasm_obj;
		int n = 0;
		RStrBuf *insn_strbuf = r_strbuf_new ("");
		pd->insn_offset = addr;
		memcpy (pd->insn_bytes, b, INSNLEN);
		disasm_obj.private_data = pd;
		disasm_obj.fprintf_func = &insn_fprintf_func;
		disasm_obj.memory_error_func = &insn_memory_error_func;
		disasm_obj.read_memory_func = &insn_read_func;
		disasm_obj.stream = insn_strbuf;
		n = print_insn_loongarch (addr, &disasm_obj);
		if (n < 0) {
			op->mnemonic = strdup ("invalid");
		} else {
			op->mnemonic = strdup (insn_strbuf->buf);
		}
		r_strbuf_free (insn_strbuf);
	}
	return true;
}
