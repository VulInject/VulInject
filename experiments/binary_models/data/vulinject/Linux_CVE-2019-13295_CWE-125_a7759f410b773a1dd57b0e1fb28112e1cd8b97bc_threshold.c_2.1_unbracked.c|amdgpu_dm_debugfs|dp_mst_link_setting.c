static ssize_t dp_mst_link_setting(struct file *f, const char __user *buf,
				 size_t size, loff_t *pos)
{
	struct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;
	struct dc_link *link = aconnector->dc_link;
	struct amdgpu_device *adev = drm_to_adev(aconnector->base.dev);
	struct dc *dc = (struct dc *)link->dc;
	struct dc_link_settings prefer_link_settings;
	char *wr_buf = NULL;
	const unsigned int wr_buf_size = 40;
	int max_param_num = 2;
	unsigned char param_nums = 0;
	int param[2];
	bool valid_input = true;
	if (!dp_mst_is_end_device(aconnector))
		return -EINVAL;
	wr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);
	if (!wr_buf)
		return -ENOSPC;
	if (parse_write_buffer_into_params(wr_buf, wr_buf_size,
					   (int *)param, buf,
					   max_param_num,
					   &param_nums)) {
		kfree(wr_buf);
		return -EINVAL;
	}
	if (param_nums <= 0) {
		kfree(wr_buf);
		DRM_DEBUG_DRIVER("user data not be read\n");
		return -EINVAL;
	}
	switch (param[0]) {
	case LANE_COUNT_ONE:
	case LANE_COUNT_TWO:
	case LANE_COUNT_FOUR:
		break;
	default:
		valid_input = false;
		break;
	}
	switch (param[1]) {
	case LINK_RATE_LOW:
	case LINK_RATE_HIGH:
	case LINK_RATE_RBR2:
	case LINK_RATE_HIGH2:
	case LINK_RATE_HIGH3:
	case LINK_RATE_UHBR10:
	case LINK_RATE_UHBR13_5:
	case LINK_RATE_UHBR20:
		break;
	default:
		valid_input = false;
		break;
	}
	if (!valid_input) {
		kfree(wr_buf);
		DRM_DEBUG_DRIVER("Invalid Input value No HW will be programmed\n");
		mutex_lock(&adev->dm.dc_lock);
		dc_link_set_preferred_training_settings(dc, NULL, NULL, link, false);
		mutex_unlock(&adev->dm.dc_lock);
		return -EINVAL;
	}
	prefer_link_settings.link_spread = link->cur_link_settings.link_spread;
	prefer_link_settings.use_link_rate_set = false;
	prefer_link_settings.lane_count = param[0];
	prefer_link_settings.link_rate = param[1];
	mutex_lock(&adev->dm.dc_lock);
	dc_link_set_preferred_training_settings(dc, &prefer_link_settings, NULL, link, true);
	mutex_unlock(&adev->dm.dc_lock);
	mutex_lock(&aconnector->base.dev->mode_config.mutex);
	aconnector->base.force = DRM_FORCE_OFF;
	mutex_unlock(&aconnector->base.dev->mode_config.mutex);
	drm_kms_helper_hotplug_event(aconnector->base.dev);
	msleep(100);
	mutex_lock(&aconnector->base.dev->mode_config.mutex);
	aconnector->base.force = DRM_FORCE_UNSPECIFIED;
	mutex_unlock(&aconnector->base.dev->mode_config.mutex);
	drm_kms_helper_hotplug_event(aconnector->base.dev);
	kfree(wr_buf);
	return size;
}
