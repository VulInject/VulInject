R_API void r_print_hexdump(RPrint *p, ut64 addr, const ut8 *buf, int len, int base, int step, size_t zoomsz) {
	r_return_if_fail (buf && len > 0);
	PrintfCallback printfmt = (PrintfCallback)printf;
	bool c = p? (p->flags & R_PRINT_FLAGS_COLOR): false;
	const char *color_title = c? (Pal (p, offset): Color_MAGENTA): "";
	int inc = p? p->cols : 16;
	size_t i, j, k;
	int sparse_char = 0;
	int stride = 0;
	int col = 0; 
	int use_sparse = 0;
	bool use_header = true;
	bool use_hdroff = true;
	bool use_offset = true;
	bool compact = false;
	bool use_segoff = false;
	bool pairs = false; 
	const char *bytefmt = "%02x";
	const char *pre = "";
	int last_sparse = 0;
	bool use_hexa = true;
	bool use_align = false;
	bool use_unalloc = false;
	const char *a, *b;
	int K = 0;
	bool hex_style = false;
	if (step < len) {
		len = len - (len % step);
	}
	if (p) {
		pairs = p->pairs;
		use_sparse = p->flags & R_PRINT_FLAGS_SPARSE;
		use_header = p->flags & R_PRINT_FLAGS_HEADER;
		use_hdroff = p->flags & R_PRINT_FLAGS_HDROFF;
		use_segoff = p->flags & R_PRINT_FLAGS_SEGOFF;
		use_align = p->flags & R_PRINT_FLAGS_ALIGN;
		use_offset = p->flags & R_PRINT_FLAGS_OFFSET;
		hex_style = p->flags & R_PRINT_FLAGS_STYLE;
		use_hexa = !(p->flags & R_PRINT_FLAGS_NONHEX);
		use_unalloc = p->flags & R_PRINT_FLAGS_UNALLOC;
		compact = p->flags & R_PRINT_FLAGS_COMPACT;
		inc = p->cols; 
		col = p->col;
		printfmt = (PrintfCallback) p->cb_printf;
		stride = p->stride;
	}
	if (!use_hexa) {
		inc *= 4;
	}
	if (step < 1) {
		step = 1;
	}
	if (inc < 1) {
		inc = 1;
	}
	if (zoomsz < 1) {
		zoomsz = 1;
	}
	switch (base) {
	case -10:
	case -11:
		bytefmt = "0x%08x ";
		pre = " ";
		if (inc < 4) {
			inc = 4;
		}
		break;
	case -1:
	case -2:
		bytefmt = "0x%08x ";
		pre = "  ";
		if (inc < 4) {
			inc = 4;
		}
		break;
	case 8:
		bytefmt = "%03o";
		pre = " ";
		break;
	case 10:
		bytefmt = "%3d";
		pre = " ";
		break;
	case 11:
		bytefmt = "%3u";
		pre = " ";
		break;
	case 16:
		if (inc < 2) {
			inc = 2;
			use_header = false;
		}
		break;
	case 32:
		bytefmt = "0x%08x ";
		pre = " ";
		if (inc < 4) {
			inc = 4;
		}
		break;
	case 64:
		bytefmt = "0x%016x ";
		pre = " ";
		if (inc < 8) {
			inc = 8;
		}
		break;
	}
	const char *space = hex_style? ".": " ";
	if (step == 1 && base < 0) {
		use_header = false;
	}
	if (use_header) {
		if (c) {
			printfmt ("%s", color_title);
		}
		if (base < 32) {
			int i, delta = 0;
			char soff[32];
			if (use_offset) {
				if (hex_style) {
					print ("..offset..");
				} else {
					print ("- offset -");
					if (p && p->wide_offsets) {
						print ("       ");
					}
				}
			} else {
				delta--;
			}
			if (use_segoff) {
				int seggrn = (p && p->config)? p->config->seggrn: 4;
				ut32 s, a;
				a = addr & 0xffff;
				s = ((addr - a) >> seggrn) & 0xffff;
				snprintf (soff, sizeof (soff), "%04x:%04x ", s, a);
				delta += strlen (soff) - 10;
			} else {
				snprintf (soff, sizeof (soff), "0x%08" PFMT64x, addr);
				delta += strlen (soff) - 9;
			}
			if (compact) {
				delta--;
			}
			for (i = 0; i < delta; i++) {
				print (space);
			}
			print ((col == 1)? "|": space);
			if (use_hdroff)  {
				k = addr & 0xf;
				K = (addr >> 4) & 0xf;
			} else {
				k = 0; 
			}
			if (use_hexa) {
				for (i = 0; i < inc; i++) {
					print (pre);
					if (base < 0) {
						if (i & 1) {
							print (space);
						}
					}
					if (use_hdroff) {
						if ((((i + k) >> 4) + K) % 16) {
							printfmt ("%c%c",
								hex[(((i+k) >> 4) + K) % 16],
								hex[(i + k) % 16]);
						} else {
							printfmt (" %c", hex[(i + k) % 16]);
						}
					} else {
						printfmt (" %c", hex[(i + k) % 16]);
					}
					if (i & 1 || !pairs) {
						if (!compact) {
							print (col != 1? space: ((i + 1) < inc)? space: "|");
						}
					}
				}
			}
			if (compact) {
				print (col > 0? "|": space);
			} else {
				print (col == 2? "|": space);
			}
			if (!p || !(p->flags & R_PRINT_FLAGS_NONASCII)) {
				for (i = 0; i < inc; i++) {
					printfmt ("%c", hex[(i + k) % 16]);
				}
			}
			if (col == 2) {
				printfmt ("|");
			}
			if (p && p->use_comments && !compact) {
				if (col != 2) {
					print (" ");
				}
				if (!hex_style) {
					print (" comment");
				}
			}
			print ("\n");
		}
		if (c) {
			print (Color_RESET);
		}
	}
	if (p) {
	}
	int rowbytes;
	int rows = 0;
	int bytes = 0;
	bool printValue = true;
	bool oPrintValue = true;
	bool isPxr = (p && p->flags & R_PRINT_FLAGS_REFS);
	bool be = p? (p->config? R_ARCH_CONFIG_IS_BIG_ENDIAN (p->config): R_SYS_ENDIAN): R_SYS_ENDIAN;
	for (i = j = 0; i < len; i += (stride? stride: inc)) {
		if (p && p->cons && p->cons->context && p->cons->context->breaked) {
			break;
		}
		rowbytes = inc;
		if (use_align) {
			int sz = (p && p->offsize)? p->offsize (p->user, addr + j): -1;
			if (sz > 0) { 
				rowbytes = sz;
			}
		}
		if (use_sparse) {
			if (checkSparse (buf + i, inc, sparse_char)) {
				if (i + inc >= len || checkSparse (buf + i + inc, inc, sparse_char)) {
					if (i + inc + inc >= len ||
					checkSparse (buf + i + inc + inc, inc, sparse_char)) {
						sparse_char = buf[j];
						last_sparse++;
						if (last_sparse == 2) {
							print (" ...\n");
							continue;
						}
						if (last_sparse > 2) {
							continue;
						}
					}
				}
			} else {
				last_sparse = 0;
			}
		}
		ut64 at = addr + (j * zoomsz);
		if (use_offset && (!isPxr || inc < 4)) {
			r_print_section (p, at);
			r_print_addr (p, at);
		}
		int row_have_cursor = -1;
		ut64 row_have_addr = UT64_MAX;
		if (use_hexa) {
			if (!compact && !isPxr) {
				print ((col == 1)? "|": " ");
			}
			for (j = i; j < i + inc; j++) {
				if (j != i && use_align && rowbytes == inc) {
					int sz = (p && p->offsize)? p->offsize (p->user, addr + j): -1;
					if (sz >= 0) {
						rowbytes = bytes;
					}
				}
				if (row_have_cursor == -1) {
					if (p && r_print_cursor_pointer (p, j, 1)) {
						row_have_cursor = j - i;
						row_have_addr = addr + j;
					}
				}
				if (!compact && ((j >= len) || bytes >= rowbytes)) {
					if (col == 1) {
						if (j + 1 >= inc + i) {
							print (j % 2? "  |": "| ");
						} else {
							print (j % 2? "   ": "  ");
						}
					} else {
						if (base == 32) {
							print ((j % 4)? "   ": "  ");
						} else if (base == 10) {
							print (j % 2? "     ": "  ");
						} else {
							print (j % 2? "   ": "  ");
						}
					}
					continue;
				}
				const char *hl = (hex_style && p && p->offname (p->user, addr + j))? Color_INVERT: NULL;
				if (hl) {
					print (hl);
				}
				if (p && (base == 32 || base == 64)) {
					int left = len - i;
					ut64 n = 0;
					size_t sz_n = (base == 64)
						? sizeof (ut64) : (step == 2)
						? sizeof (ut16) : sizeof (ut32);
					sz_n = R_MIN (left, sz_n);
					if (j + sz_n > len) {
						j += sz_n;
						continue;
					}
#if R_SYS_ENDIAN
					if (base == 32) {
						ut32 n32 = 0;
						r_mem_swaporcopy ((ut8 *)&n32, buf + j, 4, be);
						switch (sz_n) {
						case 1:
							n = n32 & 0xff;
							break;
						case 2:
							n = n32 & 0xffff;
							break;
						case 4:
							n = n32;
							break;
						}
					} else {
						ut64 n64 = 0;
						r_mem_swaporcopy ((ut8 *) &n64, buf + j, 8, be);
						switch (sz_n) {
						case 1:
							n = n64 & 0xff;
							break;
						case 2:
							n = n64 & 0xffff;
							break;
						case 4:
							n = n64 & 0xffffffff;
							break;
						default:
							n = n64;
							break;
						}
					}
#else
					r_mem_swaporcopy ((ut8 *) &n, buf + j, sz_n, be);
#endif
					r_print_cursor (p, j, sz_n, 1);
					if (p && p->colorfor) {
						if (!p->iob.addr_is_mapped (p->iob.io, addr + j)) {
							a = p->cons->context->pal.ai_unmap;
						} else {
							a = p->colorfor (p->user, addr, n, true);
						}
						if (a && *a) {
							b = Color_RESET;
						} else {
							a = b = "";
						}
					} else {
						a = b = "";
					}
					printValue = true;
					bool hasNull = false;
					if (isPxr) {
						if (n == 0) {
							if (oPrintValue) {
								hasNull = true;
							}
							printValue = false;
						}
					}
					if (printValue) {
						if (use_offset && !hasNull && isPxr) {
							r_print_section (p, at);
							r_print_addr (p, addr + j * zoomsz);
						}
						if (base == 64) {
							printfmt ("%s0x%016" PFMT64x "%s  ", a, (ut64) n, b);
						} else if (step == 2) {
							printfmt ("%s0x%04x%s ", a, (ut16) n, b);
						} else {
							printfmt ("%s0x%08x%s ", a, (ut32) n, b);
						}
					} else {
						if (hasNull) {
							const char *n = p? p->offname (p->user, addr + j): NULL;
							r_print_section (p, at);
							r_print_addr (p, addr + j * zoomsz);
							printfmt ("..[ null bytes ]..   00000000 %s\n", r_str_get (n));
						}
					}
					r_print_cursor (p, j, sz_n, 0);
					oPrintValue = printValue;
					j += step - 1;
				} else if (base == -8) {
					int int w = r_read_ble64 (buf + j, be);
					r_print_cursor (p, j, 8, 1);
					printfmt ("%23" PFMT64d " ", (st64)w);
					r_print_cursor (p, j, 8, 0);
					j += 7;
				} else if (base == -9) {
					st64 w = r_read_ble64 (buf + j, be);
					r_print_cursor (p, j, 8, 1);
					printfmt ("%23" PFMT64u " ", (st64)w);
					r_print_cursor (p, j, 8, 0);
					j += 7;
				} else if (base == -2) { 
					ut8 w = buf[j];
					r_print_cursor (p, j, 1, 1);
					printfmt ("%4u ", w);
					r_print_cursor (p, j, 1, 0);
				} else if (base == -1) { 
					st8 w = r_read_ble8 (buf + j);
					r_print_cursor (p, j, 1, 1);
					printfmt ("%4d ", w);
					r_print_cursor (p, j, 1, 0);
				} else if (base == -10) {
					if (j + 1 < len) {
						st16 w = r_read_ble16 (buf + j, be);
						r_print_cursor (p, j, 2, 1);
						printfmt ("%7d ", w);
						r_print_cursor (p, j, 2, 0);
					}
					j += 1;
				} else if (base == -11) { 
					if (j + 1 < len) {
						ut16 w = r_read_ble16 (buf + j, be);
						r_print_cursor (p, j, 2, 1);
						printfmt ("%7u ", (w & 0xFFFF));
						r_print_cursor (p, j, 2, 0);
					}
					j += 1;
				} else if (base == 10) { 
					if (j + 3 < len) {
						int w = r_read_ble32 (buf + j, be);
						r_print_cursor (p, j, 4, 1);
						printfmt ("%13d ", w);
						r_print_cursor (p, j, 4, 0);
					}
					j += 3;
				} else if (base == 11) { 
					if (j + 3 < len) {
						int w = r_read_ble32 (buf + j, be);
						r_print_cursor (p, j, 4, 1);
						printfmt ("%13u ", w);
						r_print_cursor (p, j, 4, 0);
					}
					j += 3;
				} else {
					if (j >= len) {
						break;
					}
					if (p && use_unalloc && !p->iob.is_valid_offset (p->iob.io, addr + j, false)) {
						char ch = p->io_unalloc_ch;
						char dbl_ch_str[] = { ch, ch, 0 };
						p->cb_printf ("%s", dbl_ch_str);
					} else {
						r_print_byte (p, addr + j, bytefmt, j, buf[j]);
					}
					bool mustspace = false;
					if (pairs && !compact && (inc & 1)) {
						mustspace = (rows % 2) ? !(j&1) : (j&1);
					} else if (bytes % 2 || !pairs) {
						if (col == 1) {
							if (j + 1 < inc + i) {
								mustspace = !compact;
							} else {
								print ("|");
							}
						} else {
							mustspace = !compact;
						}
					}
					if (mustspace) {
						print (" ");
					}
				}
				if (hl) {
					print (Color_RESET);
				}
				bytes++;
			}
		}
		if (printValue) {
			if (compact) {
				if (col == 0) {
					print (" ");
				} else if (col == 1) {
				} else {
					print ((col == 2)? "|": "");
				}
			} else {
				print ((col == 2)? "|": " ");
			}
			if (!pairs) {
				if (i + inc > len) {
					const int done = ((i + inc) - len) / 2;
					for (j = 0; j < done; j++) {
						print (" ");
					}
				}
			}
			if (!p || !(p->flags & R_PRINT_FLAGS_NONASCII)) {
				bytes = 0;
				size_t end = i + inc;
				for (j = i; j < end; j++) {
					if (j != i && use_align && bytes >= rowbytes) {
						int sz = (p && p->offsize)? p->offsize (p->user, addr + j): -1;
						if (sz >= 0) {
							print (" ");
							break;
						}
					}
					if (j >= len || (use_align && bytes >= rowbytes)) {
						break;
					}
					ut8 ch = (use_unalloc && p && !p->iob.is_valid_offset (p->iob.io, addr + j, false))
						? ' ' : buf[j];
					if (p && p->charset && p->charset->loaded) {
						ut8 input[2] = {ch, 0};
						ut8 output[32];
						size_t len = r_charset_encode_str (p->charset, output, sizeof (output), input, 1);
						ch = (len > 0)? *output: '?';
					}
					r_print_byte (p, addr + j, "%c", j, ch);
					bytes++;
				}
			}
			if (col == 2) {
				print ("|");
			}
			bool eol = false;
			if (!eol && p && p->flags & R_PRINT_FLAGS_REFS) {
				ut64 off = UT64_MAX;
				if (inc == 8) {
					if (i + sizeof (ut64) - 1 < len) {
						off = r_read_le64 (buf + i);
					}
				} else if (inc == 4) {
					if (i + sizeof (ut32) - 1 < len) {
						off = r_read_le32 (buf + i);
					}
				} else if (inc == 2 && base == 16) {
					if (i + sizeof (ut16) - 1 < len) {
						off = r_read_le16 (buf + i);
						if (off == 0) {
							off = UT64_MAX;
						}
					}
				}
				if (p->hasrefs && off != UT64_MAX) {
					char *rstr = p->hasrefs (p->user, addr + i, false);
					if (R_STR_ISNOTEMPTY (rstr)) {
						printfmt (" @ %s", rstr);
					}
					free (rstr);
					rstr = p->hasrefs (p->user, off, true);
					if (R_STR_ISNOTEMPTY (rstr)) {
						printfmt (" %s", rstr);
					}
					free (rstr);
				}
			}
			bool first = true;
			if (eol) {
			} else if (p && p->use_comments) {
				if (!pairs) {
					for (; j < i + inc; j++) {
						print (" ");
					}
				}
				for (j = i; j < i + inc; j++) {
					if (use_align && (j-i) >= rowbytes) {
						break;
					}
					if (p && p->offname) {
						a = p->offname (p->user, addr + j);
						if (p->colorfor && R_STR_ISNOTEMPTY (a)) {
							const char *color = p->colorfor (p->user, addr + j, addr + j, true);
							printfmt ("%s  ; %s%s", r_str_get (color), a,
									color ? Color_RESET : "");
						}
					}
					char *comment = p->get_comments (p->user, addr + j);
					if (comment) {
						if (p && p->colorfor) {
							a = p->colorfor (p->user, addr + j, addr + j, true);
							if (R_STR_ISEMPTY (a)) {
								a = "";
							}
						} else {
							a = "";
						}
						if (strchr (comment, '\n')) {
							char *s = strdup (comment);
							char *q = s;
							while (true) {
								char *nl = strchr (q, '\n');
								if (nl) {
									*nl = 0;
								}
								if (first) {
									printfmt ("%s 2; %s", a, q);
									first = false;
								} else {
									const char *a = r_str_pad (' ', 8 + (p->cols * 4));
									printfmt ("%s; %s", a, q);
								}
								if (!nl) {
									break;
								}
								q = nl + 1;
							}
							free (s);
						} else {
							printfmt ("%s ; %s", a, comment);
						}
						free (comment);
					}
				}
			}
			if (use_align && rowbytes < inc && bytes >= rowbytes) {
				i -= (inc - bytes);
			}
			print ("\n");
		}
		rows++;
		bytes = 0;
		if (p && R_STR_ISNOTEMPTY (p->cfmt)) {
			if (row_have_cursor != -1) {
				int i = 0;
				print (" _________");
				if (!compact) {
					print ("_");
				}
				for (i = 0; i < row_have_cursor; i++) {
					if (!pairs || (!compact && i % 2)) {
						print ("___");
					} else {
						print ("__");
					}
				}
				print ("__|\n");
				printfmt ("| cmd.hexcursor = %s\n", p->cfmt);
				p->coreb.cmdf (p->coreb.core,
						"%s @ 0x%08"PFMT64x, p->cfmt, row_have_addr);
			}
		}
	}
}
