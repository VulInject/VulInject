parse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,
	      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)
{
  bin_tree_t *tree = NULL, *old_tree = NULL;
  Idx i, start, end, start_idx = re_string_cur_idx (regexp);
  re_token_t start_token = *token;
  if (token->type == OP_OPEN_DUP_NUM)
    {
      end = 0;
      start = fetch_number (regexp, token, syntax);
      if (start == -1)
	{
	  if (token->type == CHARACTER && token->opr.c == ',')
	    start = 0; 
	  else
	    {
	      *err = REG_BADBR; 
	      return NULL;
	    }
	}
      if (__glibc_likely (start != -2))
	{
	  end = ((token->type == OP_CLOSE_DUP_NUM) ? start
		 : ((token->type == CHARACTER && token->opr.c == ',')
		    ? fetch_number (regexp, token, syntax) : -2));
	}
      if (__glibc_unlikely (start == -2 || end == -2))
	{
	  if (__glibc_unlikely (!(syntax & RE_INVALID_INTERVAL_ORD)))
	    {
	      if (token->type == END_OF_RE)
		*err = REG_EBRACE;
	      else
		*err = REG_BADBR;
	      return NULL;
	    }
	  *token = start_token;
	  token->type = CHARACTER;
	  return elem;
	}
      if (__glibc_unlikely ((end != -1 && start > end)
			    || token->type != OP_CLOSE_DUP_NUM))
	{
	  *err = REG_BADBR;
	  return NULL;
	}
      if (__glibc_unlikely (RE_DUP_MAX < (end == -1 ? start : end)))
	{
	  *err = REG_ESIZE;
	  return NULL;
	}
    }
  else
    {
      start = (token->type == OP_DUP_PLUS) ? 1 : 0;
      end = (token->type == OP_DUP_QUESTION) ? 1 : -1;
    }
  fetch_token (token, regexp, syntax);
  if (__glibc_unlikely (elem == NULL))
    return NULL;
  if (__glibc_unlikely (start == 0 && end == 0))
    {
      postorder (elem, free_tree, NULL);
      return NULL;
    }
  if (__glibc_unlikely (start > 0))
    {
      tree = elem;
      for (i = 2; i <= start; ++i)
	{
	  elem = duplicate_tree (elem, dfa);
	  tree = create_tree (dfa, tree, elem, CONCAT);
	  if (__glibc_unlikely (elem == NULL || tree == NULL))
	    goto parse_dup_op_espace;
	}
      if (start == end)
	return tree;
      elem = duplicate_tree (elem, dfa);
      if (__glibc_unlikely (elem == NULL))
        goto parse_dup_op_espace;
      old_tree = tree;
    }
  else
    old_tree = NULL;
  if (elem->token.type == SUBEXP)
    {
      uintptr_t subidx = elem->token.opr.idx;
      postorder (elem, mark_opt_subexp, (void *) subidx);
    }
  tree = create_tree (dfa, elem, NULL,
		      (end == -1 ? OP_DUP_ASTERISK : OP_ALT));
  if (__glibc_unlikely (tree == NULL))
    goto parse_dup_op_espace;
  if (TYPE_SIGNED (Idx) || end != -1)
    for (i = start + 2; i <= end; ++i)
      {
	elem = duplicate_tree (elem, dfa);
	tree = create_tree (dfa, tree, elem, CONCAT);
	if (__glibc_unlikely (elem == NULL || tree == NULL))
	  goto parse_dup_op_espace;
	tree = create_tree (dfa, tree, NULL, OP_ALT);
	if (__glibc_unlikely (tree == NULL))
	  goto parse_dup_op_espace;
      }
  if (old_tree)
    tree = create_tree (dfa, old_tree, tree, CONCAT);
  return tree;
 parse_dup_op_espace:
  *err = REG_ESPACE;
  return NULL;
}
