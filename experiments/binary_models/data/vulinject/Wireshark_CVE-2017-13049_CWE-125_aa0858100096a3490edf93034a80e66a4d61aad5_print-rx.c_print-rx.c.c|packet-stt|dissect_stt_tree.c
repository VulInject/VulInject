dissect_stt_tree(tvbuff_t *tvb, packet_info *pinfo, proto_tree *stt_tree,
                 proto_item *stt_item)
{
    proto_tree *vlan_tree;
    proto_item *ver_item, *l4_offset_item, *vlan_item, *mss_item;
    guint8 flags;
    guint32 version, l4_offset, mss, attributes;
    guint64 context_id;
    int offset = STT_TCP_HDR_LEN;
    ver_item = proto_tree_add_item_ret_uint(stt_tree, hf_stt_version, tvb,
                                            offset, 1, ENC_BIG_ENDIAN, &version);
    if (version != 0) {
        expert_add_info_format(pinfo, ver_item, &ei_stt_ver_unknown,
                               "Unknown version %u", version);
        col_add_fstr(pinfo->cinfo, COL_INFO, "Unknown STT version %u", version);
    }
    offset++;
    flags = tvb_get_guint8(tvb, offset);
    offset = dissect_stt_flags(stt_tree, tvb, offset);
    l4_offset_item = proto_tree_add_item_ret_uint(stt_tree, hf_stt_l4_offset,
                                                  tvb, offset, 1,
                                                  ENC_BIG_ENDIAN, &l4_offset);
    if ( !(flags & FLAG_OFFLOAD_MASK) && (l4_offset != 0) ) {
        expert_add_info_format(pinfo, l4_offset_item, &ei_stt_l4_offset, "Incorrect offset, should be equal to zero");
    }
    if ( (flags & FLAG_OFFLOAD_MASK) && (l4_offset == 0) ) {
        expert_add_info_format(pinfo, l4_offset_item, &ei_stt_l4_offset, "Incorrect offset, should be greater than zero");
    }
    offset ++;
    proto_tree_add_item(stt_tree, hf_stt_reserved_8, tvb, offset, 1,
                        ENC_BIG_ENDIAN);
    offset ++;
    mss_item = proto_tree_add_item_ret_uint(stt_tree, hf_stt_mss, tvb,
                                            offset, 2, ENC_BIG_ENDIAN, &mss);
    if ( !(flags & FLAG_OFFLOAD_MASK) && (mss != 0) ) {
        expert_add_info_format(pinfo, mss_item, &ei_stt_mss, "Incorrect max segment size, should be equal to zero");
    }
    offset += 2;
    vlan_item = proto_tree_add_item_ret_uint(stt_tree, hf_stt_vlan, tvb, offset,
                                             2, ENC_BIG_ENDIAN, &attributes);
    vlan_tree = proto_item_add_subtree(vlan_item, ett_stt_vlan);
    proto_item_set_text(vlan_item, "VLAN Priority %u, ID %u",
                        (attributes >> 13), (attributes & STT_VLANID_MASK));
    proto_tree_add_item(vlan_tree, hf_stt_pcp, tvb, offset, 2, ENC_BIG_ENDIAN);
    proto_tree_add_item(vlan_tree, hf_stt_v, tvb, offset, 2, ENC_BIG_ENDIAN);
    proto_tree_add_item(vlan_tree, hf_stt_vlan_id, tvb, offset, 2, ENC_BIG_ENDIAN);
    if (attributes & STT_V_MASK) {
        proto_item_append_text(stt_item, ", Priority: %u, VLAN ID: %u",
                               attributes >> 13,
                               attributes & STT_VLANID_MASK);
    }
    if (attributes == 0) {
    }
    offset += 2;
    context_id = tvb_get_ntoh64(tvb, offset);
    proto_tree_add_item(stt_tree, hf_stt_context_id, tvb, offset, 8, ENC_BIG_ENDIAN);
    proto_item_append_text(stt_item, ", Context ID: 0x%" PRIx64,
                           context_id);
    offset += 8;
    proto_tree_add_item(stt_tree, hf_stt_padding, tvb, offset,
                        2, ENC_BIG_ENDIAN);
}
