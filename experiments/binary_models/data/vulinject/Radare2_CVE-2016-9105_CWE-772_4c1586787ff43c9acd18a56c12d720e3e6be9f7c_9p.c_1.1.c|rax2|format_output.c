static bool format_output(RNum *num, char mode, const char *s, RaxMode m, RaxActions flags) {
	const char *errstr = NULL;
	ut64 n = r_num_calc (num, s, &errstr);
	if (errstr) {
		R_LOG_ERROR (errstr);
		return false;
	}
	char strbits[65];
	if (!flags.forcebase) {
		m.omode = mode;
	}
	if (flags.swapendian) {
		ut64 n2 = n;
		r_mem_swapendian ((ut8 *) &n, (ut8 *) &n2, 8);
		if (!(int) n) {
			n >>= 32;
		}
	}
	switch (m.omode) {
	case 'I':
		printf ("%" PFMT64d "\n", n);
		break;
	case '0':
		printf ("0x%" PFMT64x "\n", n);
		break;
	case 'F': {
		int n2 = (int) n;
		float *f = (float *) &n2;
		printf ("%ff\n", *f);
		}
		break;
	case 'V':
		break;
	case 'f':
		printf ("%.01lf\n", num->fvalue);
		break;
	case 'l':
		{
			R_STATIC_ASSERT (sizeof (float) == 4);
			float f = (float) num->fvalue;
			ut32 *p = (ut32 *) &f;
			printf ("Fx%08x\n", *p);
		}
		break;
	case 'O': printf ("0%" PFMT64o "\n", n); break;
	case 'B':
		if (n) {
			printf ("%sb\n", strbits);
		} else {
			printf ("0b\n");
		}
		break;
	case 'T':
		if (n) {
			r_num_to_ternary (strbits, n);
			printf ("%st\n", strbits);
		} else {
			printf ("0t\n");
		}
		break;
	default:
		R_LOG_ERROR ("Unknown output mode %d", m.omode);
		return false;
	}
	return true;
}
