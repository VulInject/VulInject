static irqreturn_t mmci_pio_irq(int irq, void *dev_id)
{
	struct mmci_host *host = dev_id;
	struct sg_mapping_iter *sg_miter = &host->sg_miter;
	struct variant_data *variant = host->variant;
	void __iomem *base = host->base;
	unsigned int status;
	status = readl(base + MMCISTATUS);
	dev_dbg(mmc_dev(host->mmc), "irq1 (pio) %08x\n", status);
	do {
	int remain, len;
		char *buffer;
		if (!(status & (MCI_TXFIFOHALFEMPTY|MCI_RXDATAAVLBL)))
			break;
		if (!sg_miter_next(sg_miter))
			break;
		buffer = sg_miter->addr;
		remain = sg_miter->length;
		len = 0;
		if (status & MCI_RXACTIVE)
			len = mmci_pio_read(host, buffer, remain);
		if (status & MCI_TXACTIVE)
			len = mmci_pio_write(host, buffer, remain, status);
		sg_miter->consumed = len;
		host->size -= len;
		remain -= len;
		if (remain)
			break;
		status = readl(base + MMCISTATUS);
	} while (1);
	sg_miter_stop(sg_miter);
	if (status & MCI_RXACTIVE && host->size < variant->fifohalfsize)
		mmci_set_mask1(host, MCI_RXDATAAVLBLMASK);
	if (host->size == 0) {
		mmci_set_mask1(host, 0);
		writel(readl(base + MMCIMASK0) | MCI_DATAENDMASK, base + MMCIMASK0);
	}
	return IRQ_HANDLED;
}
