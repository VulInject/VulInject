print_stats(const gchar *filename, capture_info *cf_info)
{
    const gchar           *file_type_string, *file_encap_string;
    gchar                 *size_string;
    pkt_cmt               *p, *prev;
    if (machine_readable) {
        file_type_string = wtap_file_type_subtype_name(cf_info->file_type);
        file_encap_string = wtap_encap_name(cf_info->file_encap);
    }
    else {
        file_type_string = wtap_file_type_subtype_description(cf_info->file_type);
        file_encap_string = wtap_encap_description(cf_info->file_encap);
    }
    if (filename)           printf     ("File name:           %s\n", filename);
    if (cap_file_type) {
        const char *compression_type_description;
        compression_type_description = wtap_compression_type_description(cf_info->compression_type);
        if (compression_type_description == NULL)
            printf     ("File type:           %s\n",
                    file_type_string);
        else
            printf     ("File type:           %s (%s)\n",
                    file_type_string, compression_type_description);
    }
    if (cap_file_encap) {
        printf      ("File encapsulation:  %s\n", file_encap_string);
        if (cf_info->file_encap == WTAP_ENCAP_PER_PACKET) {
            int i;
            printf    ("Encapsulation in use by packets (# of pkts):\n");
            for (i=0; i<WTAP_NUM_ENCAP_TYPES; i++) {
                if (cf_info->encap_counts[i] > 0)
                    printf("                     %s (%d)\n",
                            wtap_encap_description(i), cf_info->encap_counts[i]);
            }
        }
    }
    if (cap_file_more_info) {
        printf      ("File timestamp precision:  %s (%d)\n",
                wtap_tsprec_string(cf_info->file_tsprec), cf_info->file_tsprec);
    }
    if (cap_snaplen && cf_info->snap_set)
        printf     ("Packet size limit:   file hdr: %u bytes\n", cf_info->snaplen);
    else if (cap_snaplen && !cf_info->snap_set)
        printf     ("Packet size limit:   file hdr: (not set)\n");
    if (cf_info->snaplen_max_inferred > 0) {
        if (cf_info->snaplen_min_inferred == cf_info->snaplen_max_inferred)
            printf     ("Packet size limit:   inferred: %u bytes\n", cf_info->snaplen_min_inferred);
        else
            printf     ("Packet size limit:   inferred: %u bytes - %u bytes (range)\n",
                    cf_info->snaplen_min_inferred, cf_info->snaplen_max_inferred);
    }
    if (cap_packet_count) {
        printf     ("Number of packets:   ");
        if (machine_readable) {
            printf ("%u\n", cf_info->packet_count);
        } else {
            size_string = format_size(cf_info->packet_count, FORMAT_SIZE_UNIT_NONE, 0);
            printf ("%s\n", size_string);
            g_free(size_string);
        }
    }
    if (cap_file_size) {
        printf     ("File size:           ");
        if (machine_readable) {
            printf     ("%" PRId64 " bytes\n", cf_info->filesize);
        } else {
            size_string = format_size(cf_info->filesize, FORMAT_SIZE_UNIT_BYTES, 0);
            printf ("%s\n", size_string);
            g_free(size_string);
        }
    }
    if (cap_data_size) {
        printf     ("Data size:           ");
        if (machine_readable) {
            printf     ("%" PRIu64 " bytes\n", cf_info->packet_bytes);
        } else {
            size_string = format_size(cf_info->packet_bytes, FORMAT_SIZE_UNIT_BYTES, 0);
            printf ("%s\n", size_string);
            g_free(size_string);
        }
    }
    if (cf_info->times_known) {
        if (cap_duration) 
            printf("Capture duration:    %s\n", relative_time_string(&cf_info->duration, cf_info->duration_tsprec, cf_info, TRUE));
        if (cap_start_time)
            printf("First packet time:   %s\n", absolute_time_string(&cf_info->start_time, cf_info->start_time_tsprec, cf_info));
        if (cap_end_time)
            printf("Last packet time:    %s\n", absolute_time_string(&cf_info->stop_time, cf_info->stop_time_tsprec, cf_info));
        if (cap_data_rate_byte) {
            printf("Data byte rate:      ");
            if (machine_readable) {
                print_value("", 2, " bytes/sec",   cf_info->data_rate);
            } else {
                size_string = format_size((int int)cf_info->data_rate, FORMAT_SIZE_UNIT_BYTES_S, 0);
                printf ("%s\n", size_string);
                g_free(size_string);
            }
        }
        if (cap_data_rate_bit) {
            printf("Data bit rate:       ");
            if (machine_readable) {
                print_value("", 2, " bits/sec",    cf_info->data_rate*8);
            } else {
                size_string = format_size((int int)(cf_info->data_rate*8), FORMAT_SIZE_UNIT_BITS_S, 0);
                printf ("%s\n", size_string);
                g_free(size_string);
            }
        }
    }
    if (cap_packet_size)    printf("Average packet size: %.2f bytes\n",        cf_info->packet_size);
    if (cf_info->times_known) {
        if (cap_packet_rate) {
            printf("Average packet rate: ");
            if (machine_readable) {
                print_value("", 2, " packets/sec", cf_info->packet_rate);
            } else {
                size_string = format_size((int int)cf_info->packet_rate, FORMAT_SIZE_UNIT_PACKETS_S, 0);
                printf ("%s\n", size_string);
                g_free(size_string);
            }
        }
    }
    if (cap_file_hashes) {
        printf     ("SHA256:              %s\n", file_sha256);
        printf     ("SHA1:                %s\n", file_sha1);
    }
    if (cap_order)          printf     ("Strict time order:   %s\n", order_string(cf_info->order));
    gboolean has_multiple_sections = (wtap_file_get_num_shbs(cf_info->wth) > 1);
    for (guint section_number = 0;
            section_number < wtap_file_get_num_shbs(cf_info->wth);
            section_number++) {
        wtap_block_t shb;
        if (has_multiple_sections)
            printf("Section %u:\n\n", section_number);
	shb=((cf_info->wth+section_number-1)/section_number);
        if (shb != NULL) {
            if (cap_file_more_info) {
                char *str;
                if (wtap_block_get_string_option_value(shb, OPT_SHB_HARDWARE, &str) == WTAP_OPTTYPE_SUCCESS)
                    show_option_string("Capture hardware:    ", str);
                if (wtap_block_get_string_option_value(shb, OPT_SHB_OS, &str) == WTAP_OPTTYPE_SUCCESS)
                    show_option_string("Capture oper-sys:    ", str);
                if (wtap_block_get_string_option_value(shb, OPT_SHB_USERAPPL, &str) == WTAP_OPTTYPE_SUCCESS)
                    show_option_string("Capture application: ", str);
            }
            if (cap_comment) {
                unsigned int i;
                char *str;
                for (i = 0; wtap_block_get_nth_string_option_value(shb, OPT_COMMENT, i, &str) == WTAP_OPTTYPE_SUCCESS; i++) {
                    show_option_string("Capture comment:     ", str);
                }
            }
            if (pkt_comments && cf_info->pkt_cmts != NULL) {
              for (p = cf_info->pkt_cmts; p != NULL; prev = p, p = p->next, g_free(prev)) {
                if (machine_readable){
                  printf("Packet %d Comment:    %s\n", p->recno, g_strescape(p->cmt, NULL));
                } else {
                  printf("Packet %d Comment:    %s\n", p->recno, p->cmt);
                }
                g_free(p->cmt);
              }
            }
            if (cap_file_idb && cf_info->num_interfaces != 0) {
                guint i;
                ws_assert(cf_info->num_interfaces == cf_info->idb_info_strings->len);
                printf     ("Number of interfaces in file: %u\n", cf_info->num_interfaces);
                for (i = 0; i < cf_info->idb_info_strings->len; i++) {
                    gchar *s = g_array_index(cf_info->idb_info_strings, gchar*, i);
                    guint32 packet_count = 0;
                    if (i < cf_info->interface_packet_counts->len)
                        packet_count = g_array_index(cf_info->interface_packet_counts, guint32, i);
                    printf   ("Interface #%u info:\n", i);
                    printf   ("%s", s);
                    printf   ("                     Number of packets = %u\n", packet_count);
                }
            }
        }
        if (cap_file_nrb) {
            if (num_ipv4_addresses != 0)
                printf   ("Number of resolved IPv4 addresses in file: %u\n", num_ipv4_addresses);
            if (num_ipv6_addresses != 0)
                printf   ("Number of resolved IPv6 addresses in file: %u\n", num_ipv6_addresses);
        }
        if (cap_file_dsb) {
            if (num_decryption_secrets != 0)
                printf   ("Number of decryption secrets in file: %u\n", num_decryption_secrets);
        }
    }
}
