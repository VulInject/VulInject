pkware_decrypt(zip_source_t *src, void *ud, void *data, zip_uint64_t len, zip_source_cmd_t cmd) {
    struct trad_pkware *ctx;
    zip_int64_t n;
    ctx = (struct trad_pkware *)ud;
    switch (cmd) {
    case ZIP_SOURCE_OPEN:
        _zip_pkware_decrypt(&ctx->keys, NULL, (const zip_uint8_t *)ctx->password, strlen(ctx->password));
        if (decrypt_header(src, ctx) < 0) {
            return -1;
        }
        return 0;
    case ZIP_SOURCE_READ:
        if ((n = zip_source_read(src, data, len)) < 0) {
            _zip_error_set_from_source(&ctx->error, src);
            return -1;
        }
        _zip_pkware_decrypt(&ctx->keys, (zip_uint8_t *)data, (zip_uint8_t *)data, (zip_uint64_t)n);
        return n;
    case ZIP_SOURCE_CLOSE:
        return 0;
    case ZIP_SOURCE_STAT: {
        zip_stat_t *st;
        st = (zip_stat_t *)data;
        st->encryption_method = ZIP_EM_NONE;
        st->valid |= ZIP_STAT_ENCRYPTION_METHOD;
        if (st->valid & ZIP_STAT_COMP_SIZE) {
            st->comp_size -= ZIP_CRYPTO_PKWARE_HEADERLEN;
        }
        return 0;
    }
    case ZIP_SOURCE_SUPPORTS:
        return zip_source_make_command_bitmap(ZIP_SOURCE_OPEN, ZIP_SOURCE_READ, ZIP_SOURCE_CLOSE, ZIP_SOURCE_STAT, ZIP_SOURCE_ERROR, ZIP_SOURCE_FREE, -1);
    case ZIP_SOURCE_ERROR:
        return zip_error_to_data(&ctx->error, data, len);
    case ZIP_SOURCE_FREE:
        trad_pkware_free(ctx);
        return 0;
    default:
        zip_error_set(&ctx->error, ZIP_ER_INVAL, 0);
        return -1;
    }
}
