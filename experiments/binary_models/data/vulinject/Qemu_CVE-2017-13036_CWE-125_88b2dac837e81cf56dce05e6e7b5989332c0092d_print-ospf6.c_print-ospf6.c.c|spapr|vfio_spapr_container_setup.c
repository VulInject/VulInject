static int vfio_spapr_container_setup(VFIOContainerBase *bcontainer,
                                      Error **errp)
{
    VFIOContainer *container = container_of(bcontainer, VFIOContainer,
                                            bcontainer);
    VFIOSpaprContainer *scontainer = container_of(container, VFIOSpaprContainer,
                                                  container);
    struct vfio_iommu_spapr_tce_info info;
    bool v2 = container->iommu_type == VFIO_SPAPR_TCE_v2_IOMMU;
    int ret, fd = container->fd;
    if (!v2) {
        ret = ioctl(fd, VFIO_IOMMU_ENABLE);
        if (ret) {
            error_setg_errno(errp, errno, "failed to enable container");
            return -errno;
        }
    } else {
        scontainer->prereg_listener = vfio_prereg_listener;
        memory_listener_register(&scontainer->prereg_listener,
                                 &address_space_memory);
        if (bcontainer->error) {
            ret = -1;
            error_propagate_prepend(errp, bcontainer->error,
                    "RAM memory listener initialization failed: ");
            goto listener_unregister_exit;
        }
    }
    info.argsz = sizeof(info);
    ret = ioctl(fd, VFIO_IOMMU_SPAPR_TCE_GET_INFO, &info);
    if (ret) {
        error_setg_errno(errp, errno,
                         "VFIO_IOMMU_SPAPR_TCE_GET_INFO failed");
        ret = -errno;
        goto listener_unregister_exit;
    }
    if (v2) {
        bcontainer->pgsizes = info.ddw.pgsizes;
        /*
         * There is a default window in just created container.
         * To make region_add/del simpler, we better remove this
         * window now and let those iommu_listener callbacks
         * create/remove them when needed.
         */
        ret = vfio_spapr_remove_window(container, info.dma32_window_start);
        if (ret) {
            error_setg_errno(errp, -ret,
                             "failed to remove existing window");
            goto listener_unregister_exit;
        }
    } else {
        /* The default table uses 4K pages */
        bcontainer->pgsizes = 0x1000;
        vfio_host_win_add(scontainer, info.dma32_window_start,
                          info.dma32_window_start +
                          info.dma32_window_size - 1,
                          0x1000);
    }
    return 0;
listener_unregister_exit:
    if (v2) {
        memory_listener_unregister(&scontainer->prereg_listener);
    }
    return ret;
}
