efi_earlycon_write(struct console *con, const char *str, unsigned int num)
{
	struct screen_info *si;
	unsigned int cur_efi_x = efi_x;
	unsigned int len;
	const char *s;
	void *dst;
	si = &screen_info;
	len = si->lfb_linelength;
	while (num) {
		unsigned int linemax = (si->lfb_width - efi_x) / font->width;
		unsigned int h, count;
		count = strnchrnul(str, num, '\n') - str;
		if (count > linemax)
			count = linemax;
		for (h = 0; h < font->height; h++) {
			unsigned int n, x;
			dst = efi_earlycon_map((efi_y + h) * len, len);
			if (!dst)
				return;
			s = str;
			n = count;
			x = efi_x;
			while (n-- > 0) {
				efi_earlycon_write_char(dst + x*4, *s, h);
				x += font->width;
				s++;
			}
		}
		num -= count;
		efi_x += count * font->width;
		str += count;
		if (num > 0 && *s == '\n') {
			cur_efi_x = efi_x;
			efi_x = 0;
			efi_y += font->height;
			str++;
			num--;
		}
		if (efi_x + font->width > si->lfb_width) {
			cur_efi_x = efi_x;
			efi_x = 0;
			efi_y += font->height;
		}
		if (efi_y + font->height > si->lfb_height) {
			unsigned int i;
			efi_x_array[cur_line_y] = cur_efi_x;
			cur_line_y = (cur_line_y + 1) % max_line_y;
			efi_y -= font->height;
			efi_earlycon_scroll_up();
			for (i = 0; i < font->height; i++)
				efi_earlycon_clear_scanline(efi_y + i);
		}
	}
}
