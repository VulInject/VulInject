int ceph_iterate_session_caps(struct ceph_mds_session *session,
			      int (*cb)(struct inode *, int mds, void *),
			      void *arg)
{
	struct ceph_client *cl = session->s_mdsc->fsc->client;
	struct list_head *p;
	struct ceph_cap *cap;
	struct inode *inode, *last_inode = NULL;
	struct ceph_cap *old_cap = NULL;
	int ret;
	doutc(cl, "%p mds%d\n", session, session->s_mds);
	p = session->s_caps.next;
	while (p != &session->s_caps) {
		int mds;
		cap = list_entry(p, struct ceph_cap, session_caps);
		inode = igrab(&cap->ci->netfs.inode);
		if (!inode) {
			p = p->next;
			continue;
		}
		session->s_cap_iterator = cap;
		mds = cap->mds;
		spin_unlock(&session->s_cap_lock);
		if (last_inode) {
			iput(last_inode);
			last_inode = NULL;
		}
		if (old_cap) {
			ceph_put_cap(session->s_mdsc, old_cap);
			old_cap = NULL;
		}
		ret = cb(inode, mds, arg);
		last_inode = inode;
		spin_lock(&session->s_cap_lock);
		p = p->next;
		if (!cap->ci) {
			doutc(cl, "finishing cap %p removal\n", cap);
			BUG_ON(cap->session != session);
			cap->session = NULL;
			list_del_init(&cap->session_caps);
			session->s_nr_caps--;
			atomic64_dec(&session->s_mdsc->metric.total_caps);
			if (cap->queue_release)
				__ceph_queue_cap_release(session, cap);
			else
				old_cap = cap;  
		}
		if (ret < 0)
			goto out;
	}
	ret = 0;
out:
	session->s_cap_iterator = NULL;
	spin_unlock(&session->s_cap_lock);
	iput(last_inode);
	if (old_cap)
		ceph_put_cap(session->s_mdsc, old_cap);
	return ret;
}
