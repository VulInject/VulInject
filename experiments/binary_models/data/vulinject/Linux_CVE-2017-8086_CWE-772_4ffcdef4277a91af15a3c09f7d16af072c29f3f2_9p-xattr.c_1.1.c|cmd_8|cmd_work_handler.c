static void cmd_work_handler(struct work_struct *work)
{
	struct mlx5_cmd_work_ent *ent = container_of(work, struct mlx5_cmd_work_ent, work);
	struct mlx5_cmd *cmd = ent->cmd;
	bool poll_cmd = ent->polling;
	struct mlx5_cmd_layout *lay;
	struct mlx5_core_dev *dev;
	unsigned int timeout;
	unsigned int flags;
	int alloc_ret;
	int cmd_mode;
	complete(&ent->handling);
	dev = container_of(cmd, struct mlx5_core_dev, cmd);
	timeout = msecs_to_jiffies(mlx5_tout_ms(dev, CMD));
	if (!ent->page_queue) {
		if (down_timeout(&cmd->vars.sem, timeout)) {
			mlx5_core_warn(dev, "%s(0x%x) timed out while waiting for a slot.\n",
				       mlx5_command_str(ent->op), ent->op);
			if (ent->callback) {
				ent->callback(-EBUSY, ent->context);
				mlx5_free_cmd_msg(dev, ent->out);
				free_msg(dev, ent->in);
			} else {
				ent->ret = -EBUSY;
				complete(&ent->done);
			}
			complete(&ent->slotted);
			return;
		}
		alloc_ret = cmd_alloc_index(cmd, ent);
		if (alloc_ret < 0) {
			mlx5_core_err_rl(dev, "failed to allocate command entry\n");
			if (ent->callback) {
				ent->callback(-EAGAIN, ent->context);
				mlx5_free_cmd_msg(dev, ent->out);
				free_msg(dev, ent->in);
				cmd_ent_put(ent);
			} else {
				ent->ret = -EAGAIN;
				complete(&ent->done);
			}
			up(&cmd->vars.sem);
			return;
		}
	} else {
		down(&cmd->vars.pages_sem);
		ent->idx = cmd->vars.max_reg_cmds;
		spin_lock_irqsave(&cmd->alloc_lock, flags);
		clear_bit(ent->idx, &cmd->vars.bitmask);
		cmd->ent_arr[ent->idx] = ent;
		spin_unlock_irqrestore(&cmd->alloc_lock, flags);
	}
	complete(&ent->slotted);
	lay = get_inst(cmd, ent->idx);
	ent->lay = lay;
	memset(lay, 0, sizeof(*lay));
	memcpy(lay->in, ent->in->first.data, sizeof(lay->in));
	if (ent->in->next)
		lay->in_ptr = cpu_to_be64(ent->in->next->dma);
	lay->inlen = cpu_to_be32(ent->in->len);
	if (ent->out->next)
		lay->out_ptr = cpu_to_be64(ent->out->next->dma);
	lay->outlen = cpu_to_be32(ent->out->len);
	lay->type = MLX5_PCI_CMD_XPORT;
	lay->token = ent->token;
	lay->status_own = CMD_OWNER_HW;
	set_signature(ent, !cmd->checksum_disabled);
	dump_command(dev, ent, 1);
	ent->ts1 = ktime_get_ns();
	cmd_mode = cmd->mode;
	if (ent->callback && schedule_delayed_work(&ent->cb_timeout_work, timeout))
		cmd_ent_get(ent);
	set_bit(MLX5_CMD_ENT_STATE_PENDING_COMP, &ent->state);
	cmd_ent_get(ent); 
	if (mlx5_cmd_is_down(dev) || !opcode_allowed(&dev->cmd, ent->op)) {
		ent->ret = -ENXIO;
		mlx5_cmd_comp_handler(dev, 1ULL << ent->idx, true);
		return;
	}
	mlx5_core_dbg(dev, "writing 0x%x to command doorbell\n", 1 << ent->idx);
	wmb();
	iowrite32be(1 << ent->idx, &dev->iseg->cmd_dbell);
	if (cmd_mode == CMD_MODE_POLLING || poll_cmd) {
		poll_timeout(ent);
		rmb();
		mlx5_cmd_comp_handler(dev, 1ULL << ent->idx, (ent->ret == -ETIMEDOUT));
	}
}
