static void pflash_write(PFlashCFI01 *pfl, hwaddr offset,
                         uint32_t value, int width, int be)
{
    uint8_t *p;
    uint8_t cmd;
    cmd = value;
    trace_pflash_io_write(pfl->name, offset, width, value, pfl->wcycle);
    if (!pfl->wcycle) {
        /* Set the device in I/O access mode */
        memory_region_rom_device_set_romd(&pfl->mem, false);
    }
    switch (pfl->wcycle) {
    case 0:
        /* read mode */
        switch (cmd) {
        case 0x00: /* This model reset value for READ_ARRAY (not CFI) */
            goto mode_read_array;
        case 0x10: /* Single Byte Program */
        case 0x40: /* Single Byte Program */
            trace_pflash_write(pfl->name, "single byte program (0)");
            break;
        case 0x20: /* Block erase */
            p = pfl->storage;
            offset &= ~(pfl->sector_len - 1);
            trace_pflash_write_block_erase(pfl->name, offset, pfl->sector_len);
            if (!pfl->ro) {
                memset(p + offset, 0xff, pfl->sector_len);
                pflash_update(pfl, offset, pfl->sector_len);
            } else {
                pfl->status |= 0x20; /* Block erase error */
            }
            pfl->status |= 0x80; /* Ready! */
            break;
        case 0x50: /* Clear status bits */
            trace_pflash_write(pfl->name, "clear status bits");
            pfl->status = 0x0;
            goto mode_read_array;
        case 0x60: /* Block (un)lock */
            trace_pflash_write(pfl->name, "block unlock");
            break;
        case 0x70: /* Status Register */
            trace_pflash_write(pfl->name, "read status register");
            pfl->cmd = cmd;
            return;
        case 0x90: /* Read Device ID */
            trace_pflash_write(pfl->name, "read device information");
            pfl->cmd = cmd;
            return;
        case 0x98: /* CFI query */
            trace_pflash_write(pfl->name, "CFI query");
            break;
        case 0xe8: /* Write to buffer */
            trace_pflash_write(pfl->name, "write to buffer");
            /* FIXME should save @offset, @width for case 1+ */
            qemu_log_mask(LOG_UNIMP,
                          "%s: Write to buffer emulation is flawed\n",
                          __func__);
            pfl->status |= 0x80; /* Ready! */
            break;
        case 0xf0: /* Probe for AMD flash */
            trace_pflash_write(pfl->name, "probe for AMD flash");
            goto mode_read_array;
        case 0xff: /* Read Array */
            trace_pflash_write(pfl->name, "read array mode");
            goto mode_read_array;
        default:
            goto error_flash;
        }
        pfl->wcycle++;
        pfl->cmd = cmd;
        break;
    case 1:
        switch (pfl->cmd) {
        case 0x10: /* Single Byte Program */
        case 0x40: /* Single Byte Program */
            trace_pflash_write(pfl->name, "single byte program (1)");
            if (!pfl->ro) {
                pflash_data_write(pfl, offset, value, width, be);
                pflash_update(pfl, offset, width);
            } else {
                pfl->status |= 0x10; /* Programming error */
            }
            pfl->status |= 0x80; /* Ready! */
            pfl->wcycle = 0;
        break;
        case 0x20: /* Block erase */
        case 0x28:
            if (cmd == 0xd0) { /* confirm */
                pfl->wcycle = 0;
                pfl->status |= 0x80;
            } else if (cmd == 0xff) { /* Read Array */
                goto mode_read_array;
            } else
                goto error_flash;
            break;
        case 0xe8:
            /*
             * Mask writeblock size based on device width, or bank width if
             * device width not specified.
             */
            /* FIXME check @offset, @width */
            if (pfl->device_width) {
                value = extract32(value, 0, pfl->device_width * 8);
            } else {
                value = extract32(value, 0, pfl->bank_width * 8);
            }
            pfl->counter = value;
            pfl->wcycle++;
            pflash_blk_write_start(pfl, offset);
            break;
        case 0x60:
            if (cmd == 0xd0) {
                pfl->wcycle = 0;
                pfl->status |= 0x80;
            } else if (cmd == 0x01) {
                pfl->wcycle = 0;
                pfl->status |= 0x80;
            } else if (cmd == 0xff) { /* Read Array */
                goto mode_read_array;
            } else {
                trace_pflash_write(pfl->name, "unknown (un)locking command");
                goto mode_read_array;
            }
            break;
        case 0x98:
            if (cmd == 0xff) { /* Read Array */
                goto mode_read_array;
            } else {
                trace_pflash_write(pfl->name, "leaving query mode");
            }
            break;
        default:
            goto error_flash;
        }
        break;
    case 2:
        switch (pfl->cmd) {
        case 0xe8: /* Block write */
            /* FIXME check @offset, @width */
            if (!pfl->ro && (pfl->blk_offset != -1)) {
                pflash_data_write(pfl, offset, value, width, be);
            } else {
                pfl->status |= 0x10; /* Programming error */
            }
            pfl->status |= 0x80;
            if (!pfl->counter) {
                trace_pflash_write(pfl->name, "block write finished");
                pfl->wcycle++;
            }
            pfl->counter--;
            break;
        default:
            goto error_flash;
        }
        break;
    case 3: /* Confirm mode */
        switch (pfl->cmd) {
        case 0xe8: /* Block write */
            if ((cmd == 0xd0) && !(pfl->status & 0x10)) {
                pfl->wcycle = 0;
                pfl->status |= 0x80;
            } else {
                pflash_blk_write_abort(pfl);
                goto mode_read_array;
            }
            break;
        default:
            pflash_blk_write_abort(pfl);
            goto error_flash;
        }
        break;
    default:
        /* Should never happen */
        trace_pflash_write(pfl->name, "invalid write state");
        goto mode_read_array;
    }
    return;
 error_flash:
    qemu_log_mask(LOG_UNIMP, "%s: Unimplemented flash cmd sequence "
                  "(offset " HWADDR_FMT_plx ", wcycle 0x%x cmd 0x%x value 0x%x)"
                  "\n", __func__, offset, pfl->wcycle, pfl->cmd, value);
 mode_read_array:
    trace_pflash_mode_read_array(pfl->name);
    memory_region_rom_device_set_romd(&pfl->mem, true);
    pfl->wcycle = 0;
    pfl->cmd = 0x00; /* This model reset value for READ_ARRAY (not CFI) */
}
