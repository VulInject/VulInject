static int qcom_parse_instructions(struct nand_chip *chip,
				    const struct nand_subop *subop,
				    struct qcom_op *q_op)
{
	const struct nand_op_instr *instr = NULL;
	unsigned int op_id;
	int i, ret;
	for (op_id = 0; op_id < subop->ninstrs; op_id++) {
	int offset, naddrs;
		const unsigned char *addrs;
		instr = &subop->instrs[op_id];
		switch (instr->type) {
		case NAND_OP_CMD_INSTR:
			ret = qcom_op_cmd_mapping(chip, instr->ctx.cmd.opcode, q_op);
			if (ret < 0)
				return ret;
			q_op->cmd_reg = ret;
			q_op->rdy_delay_ns = instr->delay_ns;
			break;
		case NAND_OP_ADDR_INSTR:
			offset = nand_subop_get_addr_start_off(subop, op_id);
			naddrs = nand_subop_get_num_addr_cyc(subop, op_id);
			addrs = &instr->ctx.addr.addrs[offset];
			for (i = 0; i < min_t(unsigned int, 4, naddrs); i++)
				q_op->addr1_reg |= addrs[i] << (i * 8);
			if (naddrs > 4)
				q_op->addr2_reg |= addrs[4];
			q_op->rdy_delay_ns = instr->delay_ns;
			break;
		case NAND_OP_DATA_IN_INSTR:
			q_op->data_instr = instr;
			q_op->data_instr_idx = op_id;
			q_op->rdy_delay_ns = instr->delay_ns;
			fallthrough;
		case NAND_OP_DATA_OUT_INSTR:
			q_op->rdy_delay_ns = instr->delay_ns;
			break;
		case NAND_OP_WAITRDY_INSTR:
			q_op->rdy_timeout_ms = instr->ctx.waitrdy.timeout_ms;
			q_op->rdy_delay_ns = instr->delay_ns;
			break;
		}
	}
	return 0;
}
