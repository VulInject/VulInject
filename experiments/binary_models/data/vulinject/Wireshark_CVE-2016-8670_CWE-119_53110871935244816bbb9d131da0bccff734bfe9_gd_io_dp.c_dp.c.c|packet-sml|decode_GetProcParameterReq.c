static gboolean decode_GetProcParameterReq(tvbuff_t *tvb, packet_info *pinfo, proto_tree *messagebodytree_list, guint *offset){
	proto_item *treepath = NULL;
	proto_item *attribute = NULL;
	proto_tree *treepath_list = NULL;
	proto_tree *attribute_tree = NULL;
	guint i = 0;
	guint repeat = 0;
	guint data = 0;
	guint length = 0;
	field_serverId(tvb, messagebodytree_list, offset, &data, &length);
	field_username(tvb, messagebodytree_list, offset, &data, &length);
	field_password(tvb, messagebodytree_list, offset, &data, &length);
	get_length(tvb, offset, &data, &length);
	repeat = data+length;
	treepath_list = proto_tree_add_subtree_format(messagebodytree_list, tvb, *offset, -1, ett_sml_treepath, &treepath,
					"ParameterTreePath with %d %s", length+data, plurality(length+data, "element", "elements"));
	if ((tvb_get_guint8(tvb,*offset) & 0xF0) != LONG_LIST && (tvb_get_guint8(tvb,*offset) & 0xF0) != SHORT_LIST){
		expert_add_info_format(pinfo, treepath, &ei_sml_invalid_count, "invalid count of elements in ParameterTreePath");
		return TRUE;
	}
		if(repeat == 0) {
		expert_add_info_format(pinfo, treepath, &ei_sml_invalid_count, "invalid loop count");
		return TRUE;
	}
	*offset+=length;
	for (i=0; i< repeat; i++) {
		field_parameterTreePath(tvb, treepath_list, offset, &data, &length);
	}
	proto_item_set_end(treepath, tvb, *offset);
	get_length(tvb, offset, &data, &length);
	attribute = proto_tree_add_bytes_format (messagebodytree_list,hf_sml_attribute, tvb, *offset, length+data, NULL, "attribute %s", (data == 0)? ": NOT SET" : "");
	if (data > 0) {
		attribute_tree = proto_item_add_subtree (attribute, ett_sml_attribute);
		proto_tree_add_uint (attribute_tree, hf_sml_length, tvb, *offset, length, data);
		*offset+=length;
		proto_tree_add_item (attribute_tree, hf_sml_attribute, tvb, *offset, data, ENC_NA);
		*offset+=data;
	}
	else
		*offset+=1;
	return FALSE;
}
