static void qemu_file_monitor_watch(void *arg)
{
    QFileMonitor *mon = arg;
    char buf[4096]
        __attribute__ ((aligned(__alignof__(struct inotify_event))));
    int used = 0;
    int len;
    if (mon->fd == -1) {
        qemu_mutex_unlock(&mon->lock);
        return;
    }
    len = read(mon->fd, buf, sizeof(buf));
    if (len < 0) {
        if (errno != EAGAIN) {
            error_report("Failure monitoring inotify FD '%s',"
                         "disabling events", strerror(errno));
            goto cleanup;
        }
        /* no more events right now */
        goto cleanup;
    }
    /* Loop over all events in the buffer */
    while (used < len) {
        const char *name;
        QFileMonitorDir *dir;
        uint32_t iev;
        int qev;
        gsize i;
        struct inotify_event *ev = (struct inotify_event *)(buf + used);
        /*
         * We trust the kernel to provide valid buffer with complete event
         * records.
         */
        assert(len - used >= sizeof(struct inotify_event));
        assert(len - used - sizeof(struct inotify_event) >= ev->len);
        name = ev->len ? ev->name : "";
        dir = g_hash_table_lookup(mon->idmap, GINT_TO_POINTER(ev->wd));
        iev = ev->mask &
            (IN_CREATE | IN_MODIFY | IN_DELETE | IN_IGNORED |
             IN_MOVED_TO | IN_MOVED_FROM | IN_ATTRIB);
        used += sizeof(struct inotify_event) + ev->len;
        if (!dir) {
            continue;
        }
        /*
         * During a rename operation, the old name gets
         * IN_MOVED_FROM and the new name gets IN_MOVED_TO.
         * To simplify life for callers, we turn these into
         * DELETED and CREATED events
         */
        switch (iev) {
        case IN_CREATE:
        case IN_MOVED_TO:
            qev = QFILE_MONITOR_EVENT_CREATED;
            break;
        case IN_MODIFY:
            qev = QFILE_MONITOR_EVENT_MODIFIED;
            break;
        case IN_DELETE:
        case IN_MOVED_FROM:
            qev = QFILE_MONITOR_EVENT_DELETED;
            break;
        case IN_ATTRIB:
            qev = QFILE_MONITOR_EVENT_ATTRIBUTES;
            break;
        case IN_IGNORED:
            qev = QFILE_MONITOR_EVENT_IGNORED;
            break;
        default:
            g_assert_not_reached();
        }
        trace_qemu_file_monitor_event(mon, dir->path, name, ev->mask,
                                      dir->inotify_id);
        for (i = 0; i < dir->watches->len; i++) {
            QFileMonitorWatch *watch = &g_array_index(dir->watches,
                                                      QFileMonitorWatch,
                                                      i);
            if (watch->filename == NULL ||
                (name && g_str_equal(watch->filename, name))) {
                trace_qemu_file_monitor_dispatch(mon, dir->path, name,
                                                 qev, watch->cb,
                                                 watch->opaque, watch->id);
                watch->cb(watch->id, qev, name, watch->opaque);
            }
        }
    }
 cleanup:
    qemu_mutex_unlock(&mon->lock);
}
