R_API ut8 *r_hash_do_hmac_sha256(RHash *ctx, const ut8 *input, int len, const ut8 *key, int klen) {
	if (len < 0 || klen < 0) {
		return NULL;
	}
	size_t i;
	ut8 bskey[R_SHA256_BLOCK_LENGTH]; 
	ut8 kpad[R_SHA256_BLOCK_LENGTH]; 
	memset (bskey, 0, R_SHA256_BLOCK_LENGTH);
	if (klen > R_SHA256_BLOCK_LENGTH) {
		r_sha256_update (&ctx->sha256, key, klen);
		r_sha256_final (ctx->digest, &ctx->sha256);
		memcpy (bskey, ctx->digest, R_HASH_SIZE_SHA256);
	} else {
		memcpy (bskey, key, klen);
	}
	memset (kpad, 0, R_SHA256_BLOCK_LENGTH);
	memcpy (kpad, bskey, R_SHA256_BLOCK_LENGTH);
	for (i = 0; i < R_SHA256_BLOCK_LENGTH; i++) {
		kpad[i] ^= 0x36;
	}
	r_sha256_init (&ctx->sha256);
	r_sha256_update (&ctx->sha256, kpad, R_SHA256_BLOCK_LENGTH);
	r_sha256_update (&ctx->sha256, input, len);
	r_sha256_final (ctx->digest, &ctx->sha256);
	memset (kpad, 0, R_SHA256_BLOCK_LENGTH);
	memcpy (kpad, bskey, R_SHA256_BLOCK_LENGTH);
	for (i = 0; i < R_SHA256_BLOCK_LENGTH; i++) {
		kpad[i] ^= 0x5c;
	}
	r_sha256_init (&ctx->sha256);
	r_sha256_update (&ctx->sha256, kpad, R_SHA256_BLOCK_LENGTH);
	r_sha256_update (&ctx->sha256, ctx->digest, R_HASH_SIZE_SHA256);
	r_sha256_final (ctx->digest, &ctx->sha256);
	return ctx->digest;
}
