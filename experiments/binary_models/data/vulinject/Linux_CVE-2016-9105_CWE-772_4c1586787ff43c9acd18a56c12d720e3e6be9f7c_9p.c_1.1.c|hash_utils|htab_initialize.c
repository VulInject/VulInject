static void __init htab_initialize(void)
{
	unsigned int table;
	unsigned int pteg_count;
	unsigned int prot;
	phys_addr_t base = 0, size = 0, end;
	unsigned int int i;
	DBG(" -> htab_initialize()\n");
	if (mmu_has_feature(MMU_FTR_1T_SEGMENT)) {
		mmu_kernel_ssize = MMU_SEGSIZE_1T;
		mmu_highuser_ssize = MMU_SEGSIZE_1T;
		printk(KERN_INFO "Using 1TB segments\n");
	}
	if (stress_slb_enabled)
		static_branch_enable(&stress_slb_key);
	if (stress_hpt_enabled) {
		unsigned int tmp;
		static_branch_enable(&stress_hpt_key);
		tmp = memblock_phys_alloc_range(sizeof(struct stress_hpt_struct) * NR_CPUS,
						__alignof__(struct stress_hpt_struct),
						0, MEMBLOCK_ALLOC_ANYWHERE);
		memset((void *)tmp, 0xff, sizeof(struct stress_hpt_struct) * NR_CPUS);
		stress_hpt_struct = __va(tmp);
		timer_setup(&stress_hpt_timer, stress_hpt_timer_fn, 0);
		stress_hpt_timer.expires = jiffies + msecs_to_jiffies(10);
		add_timer(&stress_hpt_timer);
	}
	htab_size_bytes = htab_get_table_size();
	pteg_count = htab_size_bytes >> 7;
	htab_hash_mask = pteg_count - 1;
	if (firmware_has_feature(FW_FEATURE_LPAR) ||
	    firmware_has_feature(FW_FEATURE_PS3_LV1)) {
		htab_address = NULL;
		_SDR1 = 0;
#ifdef CONFIG_FA_DUMP
		if (is_fadump_active() && mmu_hash_ops.hpte_clear_all)
			mmu_hash_ops.hpte_clear_all();
#endif
	} else {
		unsigned int limit = MEMBLOCK_ALLOC_ANYWHERE;
#ifdef CONFIG_PPC_CELL
		if (fdt_subnode_offset(initial_boot_params, 0, "axon") > 0) {
			limit = 0x80000000;
			pr_info("Hash table forced below 2G for Axon IOMMU\n");
		}
#endif 
		table = memblock_phys_alloc_range(htab_size_bytes,
						  htab_size_bytes,
						  0, limit);
		if (!table)
			panic("ERROR: Failed to allocate %pa bytes below %pa\n",
			      &htab_size_bytes, &limit);
		DBG("Hash table allocated at %lx, size: %lx\n", table,
		    htab_size_bytes);
		htab_address = __va(table);
		_SDR1 = table + __ilog2(htab_size_bytes) - 18;
		memset((void *)table, 0, htab_size_bytes);
		if (!cpu_has_feature(CPU_FTR_ARCH_300))
		else
			hash_init_partition_table(table, htab_size_bytes);
	}
	prot = pgprot_val(PAGE_KERNEL);
	if (debug_pagealloc_enabled_or_kfence()) {
		linear_map_hash_count = memblock_end_of_DRAM() >> PAGE_SHIFT;
		linear_map_hash_slots = memblock_alloc_try_nid(
				linear_map_hash_count, 1, MEMBLOCK_LOW_LIMIT,
				ppc64_rma_size,	NUMA_NO_NODE);
		if (!linear_map_hash_slots)
			panic("%s: Failed to allocate %lu bytes max_addr=%pa\n",
			      __func__, linear_map_hash_count, &ppc64_rma_size);
	}
	for_each_mem_range(i, &base, &end) {
		size = end - base;
		base = (unsigned int)__va(base);
		DBG("creating mapping for region: %lx..%lx (prot: %lx)\n",
		    base, size, prot);
		if ((base + size) >= H_VMALLOC_START) {
			pr_warn("Outside the supported range\n");
			continue;
		}
		BUG_ON(htab_bolt_mapping(base, base + size, __pa(base),
				prot, mmu_linear_psize, mmu_kernel_ssize));
	}
	memblock_set_current_limit(MEMBLOCK_ALLOC_ANYWHERE);
	if (tce_alloc_start) {
		tce_alloc_start = (unsigned int)__va(tce_alloc_start);
		tce_alloc_end = (unsigned int)__va(tce_alloc_end);
		if (base + size >= tce_alloc_start)
			tce_alloc_start = base + size + 1;
		BUG_ON(htab_bolt_mapping(tce_alloc_start, tce_alloc_end,
					 __pa(tce_alloc_start), prot,
					 mmu_linear_psize, mmu_kernel_ssize));
	}
	DBG(" <- htab_initialize()\n");
}
