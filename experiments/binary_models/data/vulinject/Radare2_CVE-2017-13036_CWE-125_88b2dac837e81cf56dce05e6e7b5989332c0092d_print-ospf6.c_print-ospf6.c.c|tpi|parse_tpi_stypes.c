static int parse_tpi_stypes(R_STREAM_FILE *stream, SType *type) {
	unsigned char *leaf_data;
	unsigned int read_bytes = 0;
	stream_file_read(stream, 2, (char *)&type->length);
	if (type->length < 1) {
		return 0;
	}
	leaf_data = (unsigned char *) malloc(type->length);
	if (!leaf_data) {
		return 0;
	}
	stream_file_read (stream, type->length, (char *)leaf_data);
	type->type_data.leaf_type = *(unsigned short *)leaf_data;
	read_bytes += 2;
	switch (type->type_data.leaf_type) {
	case eLF_FIELDLIST:
		PARSE_LF(SLF_FIELDLIST, lf_fieldlist);
		break;
	case eLF_ENUM:
		PARSE_LF(SLF_ENUM, lf_enum);
		break;
	case eLF_CLASS:
		PARSE_LF(SLF_CLASS, lf_class);
		break;
	case eLF_STRUCTURE:
		PARSE_LF(SLF_STRUCTURE, lf_structure);
		break;
	case eLF_POINTER:
	{
		SLF_POINTER *lf = (SLF_POINTER *) malloc(sizeof (SLF_POINTER)); \
		if (!lf) { \
			free (leaf_data); \
			return 0; \
		} \
		parse_lf_pointer(lf, leaf_data + 2, &read_bytes, type->length); \
		type->type_data.type_info = (void *) lf; \
	}
		break;
	case eLF_ARRAY:
		PARSE_LF(SLF_ARRAY, lf_array);
		break;
	case eLF_MODIFIER:
		PARSE_LF(SLF_MODIFIER, lf_modifier);
		break;
	case eLF_ARGLIST:
		PARSE_LF(SLF_ARGLIST, lf_arglist);
		break;
	case eLF_MFUNCTION:
		PARSE_LF(SLF_MFUNCTION, lf_mfunction);
		break;
	case eLF_METHODLIST:
		break;
	case eLF_PROCEDURE:
		PARSE_LF(SLF_PROCEDURE, lf_procedure);
		break;
	case eLF_UNION:
		PARSE_LF(SLF_UNION, lf_union);
		break;
	case eLF_BITFIELD:
		PARSE_LF(SLF_BITFIELD, lf_bitfield);
		break;
	case eLF_VTSHAPE:
		PARSE_LF(SLF_VTSHAPE, lf_vtshape);
		break;
	default:
		eprintf ("parse_tpi_streams(): unsupported leaf type: 0x%"PFMT32x"\n", type->type_data.leaf_type);
		read_bytes = 0;
		break;
	}
	free (leaf_data);
	return read_bytes;
}
