dissect_dtls_appdata(tvbuff_t *tvb, packet_info *pinfo, guint32 offset,
                     guint32 record_length, SslSession *session,
                     proto_tree *dtls_record_tree, gboolean is_from_server,
                     tvbuff_t *decrypted, SslRecordInfo *record)
{
  heur_dtbl_entry_t *hdtbl_entry;
  proto_item *ti;
  col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Application Data");
  if (!session->app_handle) {
    dissector_handle_t handle;
    handle = dissector_get_uint_handle(dtls_associations, pinfo->srcport);
    handle = handle ? handle : dissector_get_uint_handle(dtls_associations, pinfo->destport);
    if (handle) session->app_handle = handle;
  }
  proto_item_set_text(dtls_record_tree,
                      "%s Record Layer: %s Protocol: %s",
                      val_to_str_const(session->version, ssl_version_short_names, "DTLS"),
                      val_to_str_const(SSL_ID_APP_DATA, ssl_31_content_type, "unknown"),
                      session->app_handle
                      ? dissector_handle_get_protocol_long_name(session->app_handle)
                      : "Application Data");
  proto_tree_add_item(dtls_record_tree, hf_dtls_record_appdata, tvb,
                      offset, record_length, ENC_NA);
  if (session->app_handle) {
    ti = proto_tree_add_string(dtls_record_tree, hf_dtls_record_appdata_proto, tvb, 0, 0, dissector_handle_get_protocol_long_name(session->app_handle));
  }
  if (decrypted) {
    gboolean  dissected;
    guint16   saved_match_port;
    ssl_debug_printf("%s decrypted len %d\n", G_STRFUNC, record->data_len);
    saved_match_port = pinfo->match_uint;
    if (is_from_server) {
      pinfo->match_uint = pinfo->srcport;
    } else {
      pinfo->match_uint = pinfo->destport;
    }
    if (session->app_handle) {
      ssl_debug_printf("%s: found handle %p (%s)\n", G_STRFUNC,
                       (void *)session->app_handle,
                       dissector_handle_get_dissector_name(session->app_handle));
      ssl_print_data("decrypted app data", record->plain_data, record->data_len);
      if (have_tap_listener(exported_pdu_tap)) {
        export_pdu_packet(decrypted, pinfo, EXP_PDU_TAG_DISSECTOR_NAME,
                          dissector_handle_get_dissector_name(session->app_handle));
      }
      dissected = call_dissector_only(session->app_handle, decrypted, pinfo, top_tree, NULL);
    }
    else {
      dissected = dissector_try_heuristic(heur_subdissector_list, decrypted, pinfo, top_tree, &hdtbl_entry, NULL);
      if (dissected && have_tap_listener(exported_pdu_tap)) {
        export_pdu_packet(decrypted, pinfo, EXP_PDU_TAG_HEUR_DISSECTOR_NAME, hdtbl_entry->short_name);
      }
    }
    pinfo->match_uint = saved_match_port;
    if (!dissected)
      call_data_dissector(decrypted, pinfo, top_tree);
    }
}
