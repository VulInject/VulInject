print_insn_args (const char *d,
		 register unsigned long int l,
		 bfd_vma pc,
		 struct disassemble_info *info,
		 const struct mips_opcode *opp)
{
  int op, delta;
  unsigned int lsb, msb, msbd;
  lsb = 0;
  for (; *d != '\0'; d++)
    {
      switch (*d)
	{
	case ',':
	case '(':
	case ')':
	case '[':
	case ']':
	  (*info->fprintf_func) (info->stream, "%c", *d);
	  break;
	case '+':
	  /* Extension character; switch for second char.  */
	  d++;
	  switch (*d)
	    {
	    case '\0':
	      /* xgettext:c-format */
	      (*info->fprintf_func) (info->stream,
				     "# internal error, incomplete extension sequence (+)");
	      return;
	    case 'A':
	      lsb = (l >> OP_SH_SHAMT) & OP_MASK_SHAMT;
	      (*info->fprintf_func) (info->stream, "0x%x", lsb);
	      break;
	    case 'B':
	      msb = (l >> OP_SH_INSMSB) & OP_MASK_INSMSB;
	      (*info->fprintf_func) (info->stream, "0x%x", msb - lsb + 1);
	      break;
	    case '1':
	      (*info->fprintf_func) (info->stream, "0x%lx",
				     (l >> OP_SH_UDI1) & OP_MASK_UDI1);
	      break;
	    case '2':
	      (*info->fprintf_func) (info->stream, "0x%lx",
				     (l >> OP_SH_UDI2) & OP_MASK_UDI2);
	      break;
	    case '3':
	      (*info->fprintf_func) (info->stream, "0x%lx",
				     (l >> OP_SH_UDI3) & OP_MASK_UDI3);
	      break;
	    case '4':
	      (*info->fprintf_func) (info->stream, "0x%lx",
				     (l >> OP_SH_UDI4) & OP_MASK_UDI4);
	      break;
        case '5': /* 5-bit signed immediate in bit 16 */
            delta = ((l >> OP_SH_RT) & OP_MASK_RT);
            if (delta & 0x10) { /* test sign bit */
                delta |= ~OP_MASK_RT;
            }
            (*info->fprintf_func) (info->stream, "%d", delta);
            break;
        case '6':
            (*info->fprintf_func) (info->stream, "0x%lx",
                    (l >> OP_SH_2BIT) & OP_MASK_2BIT);
            break;
        case '7':
            (*info->fprintf_func) (info->stream, "0x%lx",
                    (l >> OP_SH_3BIT) & OP_MASK_3BIT);
            break;
        case '8':
            (*info->fprintf_func) (info->stream, "0x%lx",
                    (l >> OP_SH_4BIT) & OP_MASK_4BIT);
            break;
        case '9':
            (*info->fprintf_func) (info->stream, "0x%lx",
                    (l >> OP_SH_5BIT) & OP_MASK_5BIT);
            break;
        case ':':
            (*info->fprintf_func) (info->stream, "0x%lx",
                    (l >> OP_SH_1BIT) & OP_MASK_1BIT);
            break;
        case '!': /* 10-bit pc-relative target in bit 11 */
            delta = ((l >> OP_SH_10BIT) & OP_MASK_10BIT);
            if (delta & 0x200) { /* test sign bit */
                delta |= ~OP_MASK_10BIT;
            }
            info->target = (delta << 2) + pc + INSNLEN;
            (*info->print_address_func) (info->target, info);
            break;
        case '~':
            (*info->fprintf_func) (info->stream, "0");
            break;
        case '@':
            (*info->fprintf_func) (info->stream, "0x%lx",
                    ((l >> OP_SH_1_TO_4) & OP_MASK_1_TO_4)+1);
            break;
        case '^': /* 10-bit signed immediate << 0 in bit 16 */
            delta = ((l >> OP_SH_IMM10) & OP_MASK_IMM10);
            if (delta & 0x200) { /* test sign bit */
                delta |= ~OP_MASK_IMM10;
            }
            (*info->fprintf_func) (info->stream, "%d", delta);
            break;
        case '#': /* 10-bit signed immediate << 1 in bit 16 */
            delta = ((l >> OP_SH_IMM10) & OP_MASK_IMM10);
            if (delta & 0x200) { /* test sign bit */
                delta |= ~OP_MASK_IMM10;
            }
            (*info->fprintf_func) (info->stream, "%d", delta << 1);
            break;
        case '$': /* 10-bit signed immediate << 2 in bit 16 */
            delta = ((l >> OP_SH_IMM10) & OP_MASK_IMM10);
            if (delta & 0x200) { /* test sign bit */
                delta |= ~OP_MASK_IMM10;
            }
            (*info->fprintf_func) (info->stream, "%d", delta << 2);
            break;
        case '%': /* 10-bit signed immediate << 3 in bit 16 */
            delta = ((l >> OP_SH_IMM10) & OP_MASK_IMM10);
            if (delta & 0x200) { /* test sign bit */
                delta |= ~OP_MASK_IMM10;
            }
            (*info->fprintf_func) (info->stream, "%d", delta << 3);
            break;
	    case 'C':
	    case 'H':
	      msbd = (l >> OP_SH_EXTMSBD) & OP_MASK_EXTMSBD;
	      (*info->fprintf_func) (info->stream, "0x%x", msbd + 1);
	      break;
	    case 'D':
	      {
		const struct mips_cp0sel_name *n;
	int cp0reg, sel;
		cp0reg = (l >> OP_SH_RD) & OP_MASK_RD;
		sel = (l >> OP_SH_SEL) & OP_MASK_SEL;
		/* CP0 register including 'sel' code for mtcN (et al.), to be
		   printed textually if known.  If not known, print both
		   CP0 register name and sel numerically since CP0 register
		   with sel 0 may have a name unrelated to register being
		   printed.  */
		n = lookup_mips_cp0sel_name(mips_cp0sel_names,
					    mips_cp0sel_names_len, cp0reg, sel);
		if (n != NULL)
		  (*info->fprintf_func) (info->stream, "%s", n->name);
		else
		  (*info->fprintf_func) (info->stream, "$%d,%d", cp0reg, sel);
		break;
	      }
	    case 'E':
	      lsb = ((l >> OP_SH_SHAMT) & OP_MASK_SHAMT) + 32;
	      (*info->fprintf_func) (info->stream, "0x%x", lsb);
	      break;
	    case 'F':
	      msb = ((l >> OP_SH_INSMSB) & OP_MASK_INSMSB) + 32;
	      (*info->fprintf_func) (info->stream, "0x%x", msb - lsb + 1);
	      break;
	    case 'G':
	      msbd = ((l >> OP_SH_EXTMSBD) & OP_MASK_EXTMSBD) + 32;
	      (*info->fprintf_func) (info->stream, "0x%x", msbd + 1);
	      break;
            case 'o':
                switch (*(d+1)) {
                case '1':
                    d++;
                    delta = l & ((1 << 18) - 1);
                    if (delta & 0x20000) {
                        delta |= ~0x1ffff;
                    }
                    break;
                case '2':
                    d++;
                    delta = l & ((1 << 19) - 1);
                    if (delta & 0x40000) {
                        delta |= ~0x3ffff;
                    }
                    break;
                default:
                    delta = (l >> OP_SH_DELTA_R6) & OP_MASK_DELTA_R6;
                    if (delta & 0x8000) {
                        delta |= ~0xffff;
                    }
                }
                (*info->fprintf_func) (info->stream, "%d", delta);
                break;
            case 'p':
                /* Sign extend the displacement with 26 bits.  */
                delta = (l >> OP_SH_DELTA) & OP_MASK_TARGET;
                if (delta & 0x2000000) {
                    delta |= ~0x3FFFFFF;
                }
                info->target = (delta << 2) + pc + INSNLEN;
                (*info->print_address_func) (info->target, info);
                break;
            case 'q':
                /* Sign extend the displacement with 21 bits.  */
                delta = sextract32(l, OP_SH_DELTA, 21);
                info->target = (delta << 2) + pc + INSNLEN;
                (*info->print_address_func) (info->target, info);
                break;
	    case 't': /* Coprocessor 0 reg name */
	      (*info->fprintf_func) (info->stream, "%s",
				     mips_cp0_names[(l >> OP_SH_RT) &
						     OP_MASK_RT]);
	      break;
	    case 'T': /* Coprocessor 0 reg name */
	      {
		const struct mips_cp0sel_name *n;
		unsigned int cp0reg, sel;
		cp0reg = (l >> OP_SH_RT) & OP_MASK_RT;
		sel = (l >> OP_SH_SEL) & OP_MASK_SEL;
		/* CP0 register including 'sel' code for mftc0, to be
		   printed textually if known.  If not known, print both
		   CP0 register name and sel numerically since CP0 register
		   with sel 0 may have a name unrelated to register being
		   printed.  */
		n = lookup_mips_cp0sel_name(mips_cp0sel_names,
					    mips_cp0sel_names_len, cp0reg, sel);
		if (n != NULL)
		  (*info->fprintf_func) (info->stream, "%s", n->name);
		else
		  (*info->fprintf_func) (info->stream, "$%d,%d", cp0reg, sel);
		break;
	      }
        case 'd':
            (*info->fprintf_func) (info->stream, "%s",
                    mips_wr_names[(l >> OP_SH_FD) & OP_MASK_FD]);
            break;
        case 'e':
            (*info->fprintf_func) (info->stream, "%s",
                    mips_wr_names[(l >> OP_SH_FS) & OP_MASK_FS]);
            break;
        case 'f':
            (*info->fprintf_func) (info->stream, "%s",
                    mips_wr_names[(l >> OP_SH_FT) & OP_MASK_FT]);
            break;
        case 'g':
            (*info->fprintf_func) (info->stream, "%s",
                    mips_msa_control_names_mips3264r2[(l >> OP_SH_MSACR11)
                                                      & OP_MASK_MSACR11]);
            break;
        case 'h':
            (*info->fprintf_func) (info->stream, "%s",
                    mips_msa_control_names_mips3264r2[(l >> OP_SH_MSACR6)
                                                      & OP_MASK_MSACR6]);
            break;
        case 'i':
            (*info->fprintf_func) (info->stream, "%s",
                    mips_gpr_names[(l >> OP_SH_GPR) & OP_MASK_GPR]);
            break;
	    default:
	      /* xgettext:c-format */
	      (*info->fprintf_func) (info->stream,
				     "# internal error, undefined extension sequence (+%c)",
				     *d);
	      return;
	    }
	  break;
	case '2':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_BP) & OP_MASK_BP);
	  break;
	case '3':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_SA3) & OP_MASK_SA3);
	  break;
	case '4':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_SA4) & OP_MASK_SA4);
	  break;
	case '5':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_IMM8) & OP_MASK_IMM8);
	  break;
	case '6':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_RS) & OP_MASK_RS);
	  break;
	case '7':
	  (*info->fprintf_func) (info->stream, "$ac%ld",
				 (l >> OP_SH_DSPACC) & OP_MASK_DSPACC);
	  break;
	case '8':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_WRDSP) & OP_MASK_WRDSP);
	  break;
	case '9':
	  (*info->fprintf_func) (info->stream, "$ac%ld",
				 (l >> OP_SH_DSPACC_S) & OP_MASK_DSPACC_S);
	  break;
	case '0': /* dsp 6-bit signed immediate in bit 20 */
	  delta = ((l >> OP_SH_DSPSFT) & OP_MASK_DSPSFT);
	  if (delta & 0x20) /* test sign bit */
	    delta |= ~OP_MASK_DSPSFT;
	  (*info->fprintf_func) (info->stream, "%d", delta);
	  break;
	case ':': /* dsp 7-bit signed immediate in bit 19 */
	  delta = ((l >> OP_SH_DSPSFT_7) & OP_MASK_DSPSFT_7);
	  if (delta & 0x40) /* test sign bit */
	    delta |= ~OP_MASK_DSPSFT_7;
	  (*info->fprintf_func) (info->stream, "%d", delta);
	  break;
	case '\'':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_RDDSP) & OP_MASK_RDDSP);
	  break;
	case '@': /* dsp 10-bit signed immediate in bit 16 */
	  delta = ((l >> OP_SH_IMM10) & OP_MASK_IMM10);
	  if (delta & 0x200) /* test sign bit */
	    delta |= ~OP_MASK_IMM10;
	  (*info->fprintf_func) (info->stream, "%d", delta);
	  break;
	case '!':
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_MT_U) & OP_MASK_MT_U);
	  break;
	case '$':
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_MT_H) & OP_MASK_MT_H);
	  break;
	case '*':
	  (*info->fprintf_func) (info->stream, "$ac%ld",
				 (l >> OP_SH_MTACC_T) & OP_MASK_MTACC_T);
	  break;
	case '&':
	  (*info->fprintf_func) (info->stream, "$ac%ld",
				 (l >> OP_SH_MTACC_D) & OP_MASK_MTACC_D);
	  break;
	case 'g':
	  /* Coprocessor register for CTTC1, MTTC2, MTHC2, CTTC2.  */
	  (*info->fprintf_func) (info->stream, "$%ld",
				 (l >> OP_SH_RD) & OP_MASK_RD);
	  break;
	case 's':
	case 'b':
	case 'r':
	case 'v':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_gpr_names[(l >> OP_SH_RS) & OP_MASK_RS]);
	  break;
	case 't':
	case 'w':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
	  break;
	case 'i':
	case 'u':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_IMMEDIATE) & OP_MASK_IMMEDIATE);
	  break;
	case 'j': /* Same as i, but sign-extended.  */
	case 'o':
            delta = (l >> OP_SH_DELTA) & OP_MASK_DELTA;
	  if (delta & 0x8000)
	    delta |= ~0xffff;
	  (*info->fprintf_func) (info->stream, "%d",
				 delta);
	  break;
	case 'h':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (unsigned int) ((l >> OP_SH_PREFX)
						 & OP_MASK_PREFX));
	  break;
	case 'k':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (unsigned int) ((l >> OP_SH_CACHE)
						 & OP_MASK_CACHE));
	  break;
	case 'a':
	  info->target = (((pc + 4) & ~(bfd_vma) 0x0fffffff)
			  | (((l >> OP_SH_TARGET) & OP_MASK_TARGET) << 2));
	  /* For gdb disassembler, force odd address on jalx.  */
	  if (info->flavour == bfd_target_unknown_flavour
	      && strcmp (opp->name, "jalx") == 0)
	    info->target |= 1;
	  (*info->print_address_func) (info->target, info);
	  break;
	case 'p':
	  /* Sign extend the displacement.  */
	  delta = (l >> OP_SH_DELTA) & OP_MASK_DELTA;
	  if (delta & 0x8000)
	    delta |= ~0xffff;
	  info->target = (delta << 2) + pc + INSNLEN;
	  (*info->print_address_func) (info->target, info);
	  break;
	case 'd':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_gpr_names[(l >> OP_SH_RD) & OP_MASK_RD]);
	  break;
	case 'U':
	  {
	    /* First check for both rd and rt being equal.  */
	    unsigned int reg = (l >> OP_SH_RD) & OP_MASK_RD;
	    if (reg == ((l >> OP_SH_RT) & OP_MASK_RT))
	      (*info->fprintf_func) (info->stream, "%s",
				     mips_gpr_names[reg]);
	    else
	      {
		/* If one is zero use the other.  */
		if (reg == 0)
		  (*info->fprintf_func) (info->stream, "%s",
					 mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
		else if (((l >> OP_SH_RT) & OP_MASK_RT) == 0)
		  (*info->fprintf_func) (info->stream, "%s",
					 mips_gpr_names[reg]);
		else /* Bogus, result depends on processor.  */
		  (*info->fprintf_func) (info->stream, "%s or %s",
					 mips_gpr_names[reg],
					 mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
	      }
	  }
	  break;
	case 'z':
	  (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[0]);
	  break;
	case '<':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_SHAMT) & OP_MASK_SHAMT);
	  break;
	case 'c':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_CODE) & OP_MASK_CODE);
	  break;
	case 'q':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_CODE2) & OP_MASK_CODE2);
	  break;
	case 'C':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_COPZ) & OP_MASK_COPZ);
	  break;
	case 'B':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_CODE20) & OP_MASK_CODE20);
	  break;
	case 'J':
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_CODE19) & OP_MASK_CODE19);
	  break;
	case 'S':
	case 'V':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FS) & OP_MASK_FS]);
	  break;
	case 'T':
	case 'W':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FT) & OP_MASK_FT]);
	  break;
	case 'D':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FD) & OP_MASK_FD]);
	  break;
	case 'R':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FR) & OP_MASK_FR]);
	  break;
	case 'E':
	  /* Coprocessor register for lwcN instructions, et al.
	     Note that there is no load/store cp0 instructions, and
	     that FPU (cp1) instructions disassemble this field using
	     'T' format.  Therefore, until we gain understanding of
	     cp2 register names, we can simply print the register
	     numbers.  */
	  (*info->fprintf_func) (info->stream, "$%ld",
				 (l >> OP_SH_RT) & OP_MASK_RT);
	  break;
	case 'G':
	  /* Coprocessor register for mtcN instructions, et al.  Note
	     that FPU (cp1) instructions disassemble this field using
	     'S' format.  Therefore, we only need to worry about cp0,
	     cp2, and cp3.  */
	  op = (l >> OP_SH_OP) & OP_MASK_OP;
	  if (op == OP_OP_COP0)
	    (*info->fprintf_func) (info->stream, "%s",
				   mips_cp0_names[(l >> OP_SH_RD) & OP_MASK_RD]);
	  else
	    (*info->fprintf_func) (info->stream, "$%ld",
				   (l >> OP_SH_RD) & OP_MASK_RD);
	  break;
	case 'K':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_hwr_names[(l >> OP_SH_RD) & OP_MASK_RD]);
	  break;
	case 'N':
	  (*info->fprintf_func) (info->stream,
				 ((opp->pinfo & (FP_D | FP_S)) != 0
				  ? "$fcc%ld" : "$cc%ld"),
				 (l >> OP_SH_BCC) & OP_MASK_BCC);
	  break;
	case 'M':
	  (*info->fprintf_func) (info->stream, "$fcc%ld",
				 (l >> OP_SH_CCC) & OP_MASK_CCC);
	  break;
	case 'P':
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_PERFREG) & OP_MASK_PERFREG);
	  break;
	case 'e':
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_VECBYTE) & OP_MASK_VECBYTE);
	  break;
	case '%':
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_VECALIGN) & OP_MASK_VECALIGN);
	  break;
	case 'H':
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_SEL) & OP_MASK_SEL);
	  break;
	case 'O':
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_ALN) & OP_MASK_ALN);
	  break;
	case 'Q':
	  {
	    unsigned int vsel = (l >> OP_SH_VSEL) & OP_MASK_VSEL;
	    if ((vsel & 0x10) == 0)
	      {
		int fmt;
		vsel &= 0x0f;
		for (fmt = 0; fmt < 3; fmt++, vsel >>= 1)
		  if ((vsel & 1) == 0)
		    break;
		(*info->fprintf_func) (info->stream, "$v%ld[%d]",
				       (l >> OP_SH_FT) & OP_MASK_FT,
				       vsel >> 1);
	      }
	    else if ((vsel & 0x08) == 0)
	      {
		(*info->fprintf_func) (info->stream, "$v%ld",
				       (l >> OP_SH_FT) & OP_MASK_FT);
	      }
	    else
	      {
		(*info->fprintf_func) (info->stream, "0x%lx",
				       (l >> OP_SH_FT) & OP_MASK_FT);
	      }
	  }
	  break;
	case 'X':
	  (*info->fprintf_func) (info->stream, "$v%ld",
				 (l >> OP_SH_FD) & OP_MASK_FD);
	  break;
	case 'Y':
	  (*info->fprintf_func) (info->stream, "$v%ld",
				 (l >> OP_SH_FS) & OP_MASK_FS);
	  break;
	case 'Z':
	  (*info->fprintf_func) (info->stream, "$v%ld",
				 (l >> OP_SH_FT) & OP_MASK_FT);
	  break;
	default:
	  /* xgettext:c-format */
	  (*info->fprintf_func) (info->stream,
				 "# internal error, undefined modifier(%c)",
				 *d);
	  return;
	}
    }
}
