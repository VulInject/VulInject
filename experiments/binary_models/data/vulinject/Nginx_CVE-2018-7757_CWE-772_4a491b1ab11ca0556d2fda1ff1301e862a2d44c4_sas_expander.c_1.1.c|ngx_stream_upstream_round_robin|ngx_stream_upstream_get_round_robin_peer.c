ngx_stream_upstream_get_round_robin_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_stream_upstream_rr_peer_data_t *rrp = data;
    ngx_int_t                        rc;
    ngx_uint_t                       i, n;
    ngx_stream_upstream_rr_peer_t   *peer;
    ngx_stream_upstream_rr_peers_t  *peers;
    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, pc->log, 0,
                   "get rr peer, try: %ui", pc->tries);
    pc->connection = NULL;
    peers = rrp->peers;
    if (peers->single) {
        peer = peers->peer;
        if (peer->down) {
            goto failed;
        }
        if (peer->max_conns && peer->conns >= peer->max_conns) {
            goto failed;
        }
        rrp->current = peer;
    } else {
        peer = ngx_stream_upstream_get_peer(rrp);
        if (peer == NULL) {
            goto failed;
        }
        ngx_log_debug2(NGX_LOG_DEBUG_STREAM, pc->log, 0,
                       "get rr peer, current: %p %i",
                       peer, peer->current_weight);
    }
    pc->sockaddr = peer->sockaddr;
    pc->socklen = peer->socklen;
    pc->name = &peer->name;
    peer->conns++;
    ngx_stream_upstream_rr_peers_unlock(peers);
    return NGX_OK;
failed:
    if (peers->next) {
        ngx_log_debug0(NGX_LOG_DEBUG_STREAM, pc->log, 0, "backup servers");
        rrp->peers = peers->next;
        n = (rrp->peers->number + (8 * sizeof(uintptr_t) - 1))
                / (8 * sizeof(uintptr_t));
        for (i = 0; i < n; i++) {
            rrp->tried[i] = 0;
        }
        ngx_stream_upstream_rr_peers_unlock(peers);
        rc = ngx_stream_upstream_get_round_robin_peer(pc, rrp);
        if (rc != NGX_BUSY) {
            return rc;
        }
        ngx_stream_upstream_rr_peers_wlock(peers);
    }
    ngx_stream_upstream_rr_peers_unlock(peers);
    pc->name = peers->name;
    return NGX_BUSY;
}
