nvkm_chan_new_(const struct nvkm_chan_func *func, struct nvkm_runl *runl, int runq,
	       struct nvkm_cgrp *cgrp, const char *name, bool priv, unsigned int devm, struct nvkm_vmm *vmm,
	       struct nvkm_dmaobj *dmaobj, unsigned int int offset, unsigned int int length,
	       struct nvkm_memory *userd, unsigned int int ouserd, struct nvkm_chan **pchan)
{
	struct nvkm_fifo *fifo = runl->fifo;
	struct nvkm_device *device = fifo->engine.subdev.device;
	struct nvkm_chan *chan;
	int ret;
	if ((runq && runq >= runl->func->runqs) ||
	    (!func->inst->vmm != !vmm) ||
	    ((func->userd->bar < 0) == !userd) ||
	    (!func->ramfc->ctxdma != !dmaobj) ||
	    ((func->ramfc->devm < devm) && devm != BIT(0)) ||
	    (!func->ramfc->priv && priv)) {
		RUNL_DEBUG(runl, "args runq:%d:%d vmm:%d:%p userd:%d:%p "
				 "push:%d:%p devm:%08x:%08x priv:%d:%d",
			   runl->func->runqs, runq, func->inst->vmm, vmm,
			   func->userd->bar < 0, userd, func->ramfc->ctxdma, dmaobj,
			   func->ramfc->devm, devm, func->ramfc->priv, priv);
		return -EINVAL;
	}
	if (!(chan = *pchan = kzalloc(sizeof(*chan), GFP_KERNEL)))
		return -ENOMEM;
	chan->func = func;
	strscpy(chan->name, name, sizeof(chan->name));
	chan->runq = runq;
	chan->id = -1;
	atomic_set(&chan->blocked, 1);
	atomic_set(&chan->errored, 0);
	INIT_LIST_HEAD(&chan->cctxs);
	INIT_LIST_HEAD(&chan->head);
	if (!cgrp) {
		ret = nvkm_cgrp_new(runl, chan->name, vmm, fifo->func->cgrp.force, &chan->cgrp);
		if (ret) {
			RUNL_DEBUG(runl, "cgrp %d", ret);
			return ret;
		}
		cgrp = chan->cgrp;
	} else {
		if (cgrp->runl != runl || cgrp->vmm != vmm) {
			RUNL_DEBUG(runl, "cgrp %d %d", cgrp->runl != runl, cgrp->vmm != vmm);
			return -EINVAL;
		}
		chan->cgrp = nvkm_cgrp_ref(cgrp);
	}
	ret = nvkm_gpuobj_new(device, func->inst->size, 0x1000, func->inst->zero, NULL,
			      &chan->inst);
	if (ret) {
		RUNL_DEBUG(runl, "inst %d", ret);
		return ret;
	}
	if (func->inst->vmm) {
		if (WARN_ON(vmm->mmu != device->mmu))
			return -EINVAL;
		ret = nvkm_vmm_join(vmm, chan->inst->memory);
		if (ret) {
			RUNL_DEBUG(runl, "vmm %d", ret);
			return ret;
		}
		chan->vmm = nvkm_vmm_ref(vmm);
	}
	if (func->ramfc->ctxdma) {
		ret = nvkm_object_bind(&dmaobj->object, chan->inst, -16, &chan->push);
		if (ret) {
			RUNL_DEBUG(runl, "bind %d", ret);
			return ret;
		}
	}
	if (!chan->func->id_get) {
		chan->id = nvkm_chid_get(runl->chid, chan);
		if (chan->id >= 0) {
			if (func->userd->bar < 0) {
				if (ouserd + chan->func->userd->size >=
					nvkm_memory_size(userd)) {
					RUNL_DEBUG(runl, "ouserd %llx", ouserd);
					return -EINVAL;
				}
				ret = nvkm_memory_kmap(userd, &chan->userd.mem);
				if (ret) {
					RUNL_DEBUG(runl, "userd %d", ret);
					return ret;
				}
				chan->userd.base = ouserd;
			} else {
				chan->userd.mem = nvkm_memory_ref(fifo->userd.mem);
				chan->userd.base = chan->id * chan->func->userd->size;
			}
		}
	} else {
		chan->id = chan->func->id_get(chan, userd, ouserd);
	}
	if (chan->id < 0) {
		RUNL_ERROR(runl, "!chids");
		return -ENOSPC;
	}
	if (cgrp->id < 0)
		cgrp->id = chan->id;
	if (chan->func->userd->clear)
		chan->func->userd->clear(chan);
	ret = chan->func->ramfc->write(chan, offset, length, devm, priv);
	if (ret) {
		RUNL_DEBUG(runl, "ramfc %d", ret);
		return ret;
	}
	return 0;
}
