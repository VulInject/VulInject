static int setup_frame(AVCodecContext *ctx, const AVFrame *frame,
                       x264_picture_t **ppic)
{
    X264Context *x4 = ctx->priv_data;
    X264Opaque  *opaque = &x4->reordered_opaque[x4->next_reordered_opaque];
    x264_picture_t *pic = &x4->pic;
    x264_sei_t     *sei = &pic->extra_sei;
    unsigned int sei_data_size = 0;
    int64_t wallclock = 0;
    int bit_depth, ret;
    AVFrameSideData *sd;
    AVFrameSideData *mbinfo_sd;
    *ppic = NULL;
    if (!frame)
        return 0;
    pic->img.i_csp   = x4->params.i_csp;
#if X264_BUILD >= 153
    bit_depth = x4->params.i_bitdepth;
#else
    bit_depth = x264_bit_depth;
#endif
    if (bit_depth > 8)
        pic->img.i_csp |= X264_CSP_HIGH_DEPTH;
    pic->img.i_plane = av_pix_fmt_count_planes(ctx->pix_fmt);
    for (int i = 0; i < pic->img.i_plane; i++) {
        pic->img.plane[i]    = frame->data[i];
        pic->img.i_stride[i] = frame->linesize[i];
    }
    pic->i_pts  = frame->pts;
    opaque_uninit(opaque);
    if (ctx->flags & AV_CODEC_FLAG_COPY_OPAQUE) {
        opaque->frame_opaque = frame->opaque;
        ret = av_buffer_replace(&opaque->frame_opaque_ref, frame->opaque_ref);
        if (ret < 0)
            goto fail;
    }
#if FF_API_REORDERED_OPAQUE
FF_DISABLE_DEPRECATION_WARNINGS
    opaque->reordered_opaque = frame->reordered_opaque;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    opaque->duration         = frame->duration;
    opaque->wallclock = wallclock;
    if (ctx->export_side_data & AV_CODEC_EXPORT_DATA_PRFT)
        opaque->wallclock = av_gettime();
    pic->opaque = opaque;
    x4->next_reordered_opaque++;
    x4->next_reordered_opaque %= x4->nb_reordered_opaque;
    switch (frame->pict_type) {
    case AV_PICTURE_TYPE_I:
        pic->i_type = x4->forced_idr > 0 ? X264_TYPE_IDR : X264_TYPE_KEYFRAME;
        break;
    case AV_PICTURE_TYPE_P:
        pic->i_type = X264_TYPE_P;
        break;
    case AV_PICTURE_TYPE_B:
        pic->i_type = X264_TYPE_B;
        break;
    default:
        pic->i_type = X264_TYPE_AUTO;
        break;
    }
    reconfig_encoder(ctx, frame);
    if (x4->a53_cc) {
        void *sei_data;
        size_t sei_size;
        ret = ff_alloc_a53_sei(frame, 0, &sei_data, &sei_size);
        if (ret < 0)
            goto fail;
        if (sei_data) {
            sei->payloads = av_mallocz(sizeof(sei->payloads[0]));
            if (!sei->payloads) {
                av_free(sei_data);
                ret = AVERROR(ENOMEM);
                goto fail;
            }
            sei->sei_free = av_free;
            sei->payloads[0].payload_size = sei_size;
            sei->payloads[0].payload      = sei_data;
            sei->payloads[0].payload_type = SEI_TYPE_USER_DATA_REGISTERED_ITU_T_T35;
            sei->num_payloads = 1;
        }
    }
    sd = av_frame_get_side_data(frame, AV_FRAME_DATA_REGIONS_OF_INTEREST);
    if (sd) {
        ret = setup_roi(ctx, pic, bit_depth, frame, sd->data, sd->size);
        if (ret < 0)
            goto fail;
    }
    mbinfo_sd = av_frame_get_side_data(frame, AV_FRAME_DATA_VIDEO_HINT);
    if (mbinfo_sd) {
        int ret = setup_mb_info(ctx, pic, frame, (const AVVideoHint *)mbinfo_sd->data);
        if (ret < 0) {
            /* No need to fail here, this is not fatal. We just proceed with no
             * mb_info and log a message */
            av_log(ctx, AV_LOG_WARNING, "setup_mb_info failed with error: %s\n", av_err2str(ret));
        }
    }
    if (x4->udu_sei) {
        for (int j = 0; j < frame->nb_side_data; j++) {
            AVFrameSideData *side_data = frame->side_data[j];
            void *tmp;
            x264_sei_payload_t *sei_payload;
            if (side_data->type != AV_FRAME_DATA_SEI_UNREGISTERED)
                continue;
            tmp = av_fast_realloc(sei->payloads, &sei_data_size, (sei->num_payloads + 1) * sizeof(*sei_payload));
            if (!tmp) {
                ret = AVERROR(ENOMEM);
                goto fail;
            }
            sei->payloads = tmp;
            sei->sei_free = av_free;
            sei_payload = &sei->payloads[sei->num_payloads];
            sei_payload->payload = av_memdup(side_data->data, side_data->size);
            if (!sei_payload->payload) {
                ret = AVERROR(ENOMEM);
                goto fail;
            }
            sei_payload->payload_size = side_data->size;
            sei_payload->payload_type = SEI_TYPE_USER_DATA_UNREGISTERED;
            sei->num_payloads++;
        }
    }
    *ppic = pic;
    return 0;
fail:
    free_picture(pic);
    *ppic = NULL;
    return ret;
}
