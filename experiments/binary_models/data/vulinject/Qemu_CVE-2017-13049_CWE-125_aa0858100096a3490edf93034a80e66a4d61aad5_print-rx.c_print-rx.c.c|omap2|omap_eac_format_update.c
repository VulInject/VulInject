static void omap_eac_format_update(struct omap_eac_s *s)
{
    struct audsettings fmt;
    /* The hardware buffers at most one sample */
    if (s->codec.rxlen)
        s->codec.rxlen = 1;
    if (s->codec.in_voice) {
        AUD_set_active_in(s->codec.in_voice, 0);
        AUD_close_in(&s->codec.card, s->codec.in_voice);
        s->codec.in_voice = NULL;
    }
    if (s->codec.out_voice) {
        AUD_set_active_out(s->codec.out_voice, 0);
        AUD_close_out(&s->codec.card, s->codec.out_voice);
        s->codec.out_voice = NULL;
        s->codec.txavail = 0;
    }
    /* Discard what couldn't be written */
    s->codec.txlen = 0;
    omap_eac_enable_update(s);
    if (!s->codec.enable)
        return;
    omap_eac_rate_update(s);
    fmt.endianness = ((s->codec.config[0] >> 8) & 1);		/* LI_BI */
    fmt.nchannels = ((s->codec.config[0] >> 10) & 1) ? 2 : 1;	/* MN_ST */
    fmt.freq = s->codec.rate;
    /* TODO: signedness possibly depends on the CODEC hardware - or
     * does I2S specify it?  */
    /* All register writes are 16 bits so we store 16-bit samples
     * in the buffers regardless of AGCFR[B8_16] value.  */
    fmt.fmt = AUDIO_FORMAT_U16;
    s->codec.in_voice = AUD_open_in(&s->codec.card, s->codec.in_voice,
                    "eac.codec.in", s, omap_eac_in_cb, &fmt);
    s->codec.out_voice = AUD_open_out(&s->codec.card, s->codec.out_voice,
                    "eac.codec.out", s, omap_eac_out_cb, &fmt);
    omap_eac_volume_update(s);
    AUD_set_active_in(s->codec.in_voice, 1);
    AUD_set_active_out(s->codec.out_voice, 1);
}
