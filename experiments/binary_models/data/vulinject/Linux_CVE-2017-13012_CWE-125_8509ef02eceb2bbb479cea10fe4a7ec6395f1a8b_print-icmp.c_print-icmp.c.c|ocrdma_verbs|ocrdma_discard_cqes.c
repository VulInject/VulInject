static void ocrdma_discard_cqes(struct ocrdma_qp *qp, struct ocrdma_cq *cq)
{
	unsigned int cq_flags;
	unsigned int flags;
	unsigned int cur_getp, stop_getp;
	struct ocrdma_cqe *cqe;
	unsigned int qpn = 0, wqe_idx = 0;
	spin_lock_irqsave(&cq->cq_lock, cq_flags);
	cur_getp = cq->getp;
	stop_getp = cur_getp;
	do {
		if (is_hw_sq_empty(qp) && (!qp->srq && is_hw_rq_empty(qp)))
			break;
		cqe = cq->va + cur_getp;
		qpn = cqe->cmn.qpn & OCRDMA_CQE_QPN_MASK;
		if (qpn == 0 || qpn != qp->id)
			goto skip_cqe;
		if (is_cqe_for_sq(cqe)) {
		} else {
			if (qp->srq) {
				wqe_idx = (le32_to_cpu(cqe->rq.buftag_qpn) >>
					OCRDMA_CQE_BUFTAG_SHIFT) &
					qp->srq->rq.max_wqe_idx;
				BUG_ON(wqe_idx < 1);
				spin_lock_irqsave(&qp->srq->q_lock, flags);
				ocrdma_hwq_inc_tail(&qp->srq->rq);
				ocrdma_srq_toggle_bit(qp->srq, wqe_idx - 1);
				spin_unlock_irqrestore(&qp->srq->q_lock, flags);
			} else {
				ocrdma_hwq_inc_tail(&qp->rq);
			}
		}
		cqe->cmn.qpn = 0;
skip_cqe:
		cur_getp = (cur_getp + 1) % cq->max_hw_cqe;
	} while (cur_getp != stop_getp);
	spin_unlock_irqrestore(&cq->cq_lock, cq_flags);
}
