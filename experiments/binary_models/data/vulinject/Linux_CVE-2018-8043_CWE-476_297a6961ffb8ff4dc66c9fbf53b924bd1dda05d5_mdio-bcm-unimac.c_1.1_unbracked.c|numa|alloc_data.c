static unsigned char *alloc_data(ssize_t bytes0, int map_flags,
		      int init_zero, int init_cpu0, int thp, int init_random)
{
	cpu_set_t *orig_mask = NULL;
	ssize_t bytes;
	unsigned char *buf;
	if (init_cpu0) {
		int node = numa_node_of_cpu(0);
		orig_mask = bind_to_node(node);
		bind_to_memnode(node);
	}
	bytes = bytes0 + HPSIZE;
	buf = (void *)mmap(0, bytes, PROT_READ|PROT_WRITE, MAP_ANON|map_flags, -1, 0);
	BUG_ON(buf == (void *)-1);
	if (map_flags == MAP_PRIVATE) {
		if (thp > 0) {
			ret = madvise(buf, bytes, MADV_HUGEPAGE);
			if (ret && !g->print_once) {
				g->print_once = 1;
				printf("WARNING: Could not enable THP - do: 'echo madvise > /sys/kernel/mm/transparent_hugepage/enabled'\n");
			}
		}
		if (thp < 0) {
			ret = madvise(buf, bytes, MADV_NOHUGEPAGE);
			if (ret && !g->print_once) {
				g->print_once = 1;
				printf("WARNING: Could not disable THP: run a CONFIG_TRANSPARENT_HUGEPAGE kernel?\n");
			}
		}
	}
	if (init_zero) {
		bzero(buf, bytes);
	} else {
		if (init_random) {
			unsigned int int *wbuf = (void *)buf;
			int off = rand();
			int i;
			for (i = 0; i < bytes/8; i++)
				wbuf[i] = i + off;
		}
	}
	buf = (void *)(((unsigned int)buf + HPSIZE-1) & ~(HPSIZE-1));
	if (init_cpu0) {
		bind_to_cpumask(orig_mask);
		CPU_FREE(orig_mask);
		mempol_restore();
	}
	return buf;
}
