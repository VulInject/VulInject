static int gfx_v11_0_get_cu_info(struct amdgpu_device *adev,
				 struct amdgpu_cu_info *cu_info)
{
	int i, j, k, counter, active_cu_number = 0;
	unsigned int mask, bitmap;
	unsigned disable_masks[8 * 2];
	if (!adev || !cu_info)
		return -EINVAL;
	amdgpu_gfx_parse_disable_cu(disable_masks, 8, 2);
	for (i = 0; i < adev->gfx.config.max_shader_engines; i++) {
		for (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {
			bitmap = i * adev->gfx.config.max_sh_per_se + j;
			if (!((gfx_v11_0_get_sa_active_bitmap(adev) >> bitmap) & 1))
				continue;
			mask = 1;
			counter = 0;
			gfx_v11_0_select_se_sh(adev, i, j, 0xffffffff, 0);
			if (i < 8 && j < 2)
				gfx_v11_0_set_user_wgp_inactive_bitmap_per_sh(
					adev, disable_masks[i * 2 + j]);
			bitmap = gfx_v11_0_get_cu_active_bitmap_per_sh(adev);
			cu_info->bitmap[0][i % 4][j + (i / 4) * 2] = bitmap;
			for (k = 0; k < adev->gfx.config.max_cu_per_sh; k++) {
				if (bitmap & mask)
					counter++;
				mask <<= 1;
			}
			active_cu_number += counter;
		}
	}
	gfx_v11_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);
	mutex_unlock(&adev->grbm_idx_mutex);
	cu_info->number = active_cu_number;
	cu_info->simd_per_cu = NUM_SIMD_PER_CU;
	return 0;
}
