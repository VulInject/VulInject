static int __net_init ip_vs_control_net_init_sysctl(struct netns_ipvs *ipvs) { return 0; }
static int __net_init ip_vs_control_net_init_sysctl(struct netns_ipvs *ipvs)
{
	struct net *net = ipvs->net;
	struct ctl_table *tbl;
	int idx, ret;
	size_t ctl_table_size = ARRAY_SIZE(vs_vars);
	bool unpriv = net->user_ns != &init_user_ns;
	spin_lock_init(&ipvs->dropentry_lock);
	spin_lock_init(&ipvs->droppacket_lock);
	spin_lock_init(&ipvs->securetcp_lock);
	INIT_DELAYED_WORK(&ipvs->defense_work, defense_work_handler);
	INIT_DELAYED_WORK(&ipvs->expire_nodest_conn_work,
			  expire_nodest_conn_handler);
	ipvs->est_stopped = 0;
	if (!net_eq(net, &init_net)) {
		tbl = kmemdup(vs_vars, sizeof(vs_vars), GFP_KERNEL);
		if (tbl == NULL)
			return -ENOMEM;
	} else
		tbl = vs_vars;
	for (idx = 0; idx < ARRAY_SIZE(vs_vars); idx++) {
		if (tbl[idx].proc_handler == proc_do_defense_mode)
			tbl[idx].extra2 = ipvs;
	}
	idx = 0;
	ipvs->sysctl_amemthresh = 1024;
	tbl[idx++].data = &ipvs->sysctl_amemthresh;
	ipvs->sysctl_am_droprate = 10;
	tbl[idx++].data = &ipvs->sysctl_am_droprate;
	tbl[idx++].data = &ipvs->sysctl_drop_entry;
	tbl[idx++].data = &ipvs->sysctl_drop_packet;
#ifdef CONFIG_IP_VS_NFCT
	tbl[idx++].data = &ipvs->sysctl_conntrack;
#endif
	tbl[idx++].data = &ipvs->sysctl_secure_tcp;
	ipvs->sysctl_snat_reroute = 1;
	tbl[idx++].data = &ipvs->sysctl_snat_reroute;
	ipvs->sysctl_sync_ver = 1;
	tbl[idx++].data = &ipvs->sysctl_sync_ver;
	ipvs->sysctl_sync_ports = 1;
	tbl[idx++].data = &ipvs->sysctl_sync_ports;
	tbl[idx++].data = &ipvs->sysctl_sync_persist_mode;
	ipvs->sysctl_sync_qlen_max = nr_free_buffer_pages() / 32;
	if (unpriv)
		tbl[idx].mode = 0444;
	tbl[idx++].data = &ipvs->sysctl_sync_qlen_max;
	ipvs->sysctl_sync_sock_size = 0;
	if (unpriv)
		tbl[idx].mode = 0444;
	tbl[idx++].data = &ipvs->sysctl_sync_sock_size;
	tbl[idx++].data = &ipvs->sysctl_cache_bypass;
	tbl[idx++].data = &ipvs->sysctl_expire_nodest_conn;
	tbl[idx++].data = &ipvs->sysctl_sloppy_tcp;
	tbl[idx++].data = &ipvs->sysctl_sloppy_sctp;
	tbl[idx++].data = &ipvs->sysctl_expire_quiescent_template;
	ipvs->sysctl_sync_threshold[0] = DEFAULT_SYNC_THRESHOLD;
	ipvs->sysctl_sync_threshold[1] = DEFAULT_SYNC_PERIOD;
	tbl[idx].data = &ipvs->sysctl_sync_threshold;
	tbl[idx].extra2 = ipvs;
	tbl[idx++].maxlen = sizeof(ipvs->sysctl_sync_threshold);
	ipvs->sysctl_sync_refresh_period = DEFAULT_SYNC_REFRESH_PERIOD;
	tbl[idx++].data = &ipvs->sysctl_sync_refresh_period;
	ipvs->sysctl_sync_retries = clamp_t(int, DEFAULT_SYNC_RETRIES, 0, 3);
	tbl[idx++].data = &ipvs->sysctl_sync_retries;
	tbl[idx++].data = &ipvs->sysctl_nat_icmp_send;
	ipvs->sysctl_pmtu_disc = 1;
	tbl[idx++].data = &ipvs->sysctl_pmtu_disc;
	tbl[idx++].data = &ipvs->sysctl_backup_only;
	ipvs->sysctl_conn_reuse_mode = 1;
	tbl[idx++].data = &ipvs->sysctl_conn_reuse_mode;
	tbl[idx++].data = &ipvs->sysctl_schedule_icmp;
	tbl[idx++].data = &ipvs->sysctl_ignore_tunneled;
	ipvs->sysctl_run_estimation = 1;
	if (unpriv)
		tbl[idx].mode = 0444;
	tbl[idx].extra2 = ipvs;
	tbl[idx++].data = &ipvs->sysctl_run_estimation;
	ipvs->est_cpulist_valid = 0;
	if (unpriv)
		tbl[idx].mode = 0444;
	tbl[idx].extra2 = ipvs;
	tbl[idx++].data = &ipvs->sysctl_est_cpulist;
	ipvs->sysctl_est_nice = IPVS_EST_NICE;
	if (unpriv)
		tbl[idx].mode = 0444;
	tbl[idx].extra2 = ipvs;
	tbl[idx++].data = &ipvs->sysctl_est_nice;
#ifdef CONFIG_IP_VS_DEBUG
	if (!net_eq(net, &init_net))
		tbl[idx++].mode = 0444;
#endif
	ret = -ENOMEM;
	ipvs->sysctl_hdr = register_net_sysctl_sz(net, "net/ipv4/vs", tbl,
						  ctl_table_size);
	if (!ipvs->sysctl_hdr)
		goto err;
	ipvs->sysctl_tbl = tbl;
	ret = ip_vs_start_estimator(ipvs, &ipvs->tot_stats->s);
	if (ret < 0)
		goto err;
	queue_delayed_work(system_long_wq, &ipvs->defense_work,
			   DEFENSE_TIMER_PERIOD);
	return 0;
err:
	unregister_net_sysctl_table(ipvs->sysctl_hdr);
	if (!net_eq(net, &init_net))
		kfree(tbl);
	return ret;
}
