static int capture_android_tcpdump(char *interface, char *fifo,
        char *capture_filter, const char *adb_server_ip,
        unsigned short *adb_server_tcp_port) {
    static const char                       *const adb_shell_tcpdump_format = "exec:tcpdump -U -n -s 0 -u -i %s -w - %s 2>/dev/null";
    static const char                       *const regex_interface = INTERFACE_ANDROID_TCPDUMP "-(?<iface>.*?)-(?<serial>.*)";
    struct extcap_dumper                     extcap_dumper;
    static char                              data[PACKET_LENGTH];
    ssize_t                                  length;
    ssize_t                                  used_buffer_length =  0;
    ssize_t                                  frame_length=0;
    socket_handle_t                          sock;
    int                                     result;
    char                                    *iface = NULL;
    char                                    *serial_number = NULL;
    bool                                     nanosecond_timestamps;
    bool                                     swap_byte_order;
    pcap_hdr_t                              *global_header;
    pcaprec_hdr_t                            p_header;
    GRegex                                  *regex = NULL;
    GError                                  *err = NULL;
    GMatchInfo                              *match = NULL;
    char                                    *tcpdump_cmd = NULL;
    char                                    *quoted_filter = NULL;
    regex = g_regex_new(regex_interface, G_REGEX_RAW, (GRegexMatchFlags)0, &err);
    if (!regex) {
        ws_warning("Failed to compile regex for tcpdump interface");
        return EXIT_CODE_GENERIC;
    }
    g_regex_match(regex, interface, (GRegexMatchFlags)0, &match);
    if (!g_match_info_matches(match)) {
        ws_warning("Failed to determine iface name and serial number");
        g_regex_unref(regex);
        return EXIT_CODE_GENERIC;
    }
    iface = g_match_info_fetch_named(match, "iface");
    serial_number = g_match_info_fetch_named(match, "serial");
    g_match_info_free(match);
    g_regex_unref(regex);
    sock = adb_connect_transport(adb_server_ip, adb_server_tcp_port, serial_number);
    g_free(serial_number);
    if (sock == INVALID_SOCKET) {
        g_free(iface);
        return EXIT_CODE_INVALID_SOCKET_11;
    }
    quoted_filter = g_shell_quote(capture_filter ? capture_filter : "");
    tcpdump_cmd = ws_strdup_printf(adb_shell_tcpdump_format, iface, quoted_filter);
    g_free(iface);
    g_free(quoted_filter);
    result = adb_send(sock, tcpdump_cmd);
    g_free(tcpdump_cmd);
    if (result) {
        ws_warning("Error while setting adb transport");
        closesocket(sock);
        return EXIT_CODE_GENERIC;
    }
    while (used_buffer_length < PCAP_GLOBAL_HEADER_LENGTH) {
        errno = 0;
        length = recv(sock, data + used_buffer_length, (int)(PCAP_GLOBAL_HEADER_LENGTH - used_buffer_length), 0);
        if (errno == EAGAIN
#if EWOULDBLOCK != EAGAIN
            || errno == EWOULDBLOCK
#endif
            ) {
            continue;
        }
        else if (errno != 0) {
            ws_warning("ERROR capture: %s", strerror(errno));
            closesocket(sock);
            return EXIT_CODE_GENERIC;
        }
        if (length <= 0) {
            ws_warning("Broken socket connection.");
            closesocket(sock);
            return EXIT_CODE_GENERIC;
        }
        used_buffer_length += length;
    }
    global_header = (pcap_hdr_t*) data;
    switch (global_header->magic_number) {
    case 0xa1b2c3d4:
        swap_byte_order = false;
        nanosecond_timestamps = false;
        break;
    case 0xd4c3b2a1:
        swap_byte_order = true;
        nanosecond_timestamps = false;
        break;
    case 0xa1b23c4d:
        swap_byte_order = false;
        nanosecond_timestamps = true;
        break;
    case 0x4d3cb2a1:
        swap_byte_order = true;
        nanosecond_timestamps = true;
        break;
    default:
        ws_warning("Received incorrect magic");
        closesocket(sock);
        return EXIT_CODE_GENERIC;
    }
    int encap = (int)(swap_byte_order ? GUINT32_SWAP_LE_BE(global_header->network) : global_header->network);
#ifndef ANDROIDDUMP_USE_LIBPCAP
#endif
    extcap_dumper = extcap_dumper_open(fifo, encap);
    used_buffer_length = 0;
    while (endless_loop) {
        ssize_t offset = 0;
        errno = 0;
        length = recv(sock, data + used_buffer_length, (int)(PACKET_LENGTH - used_buffer_length), 0);
        if (errno == EAGAIN
#if EWOULDBLOCK != EAGAIN
            || errno == EWOULDBLOCK
#endif
            ) {
            continue;
        }
        else if (errno != 0) {
            ws_warning("ERROR capture: %s", strerror(errno));
            closesocket(sock);
            return EXIT_CODE_GENERIC;
        }
        if (length <= 0) {
            ws_warning("Broken socket connection.");
            closesocket(sock);
            return EXIT_CODE_GENERIC;
        }
        used_buffer_length += length;
        while ((used_buffer_length - offset) > PCAP_RECORD_HEADER_LENGTH) {
            p_header = *((pcaprec_hdr_t*) (data + offset));
            if (swap_byte_order) {
                p_header.ts_sec   = GUINT32_SWAP_LE_BE(p_header.ts_sec);
                p_header.ts_usec  = GUINT32_SWAP_LE_BE(p_header.ts_usec);
                p_header.incl_len = GUINT32_SWAP_LE_BE(p_header.incl_len);
                p_header.orig_len = GUINT32_SWAP_LE_BE(p_header.orig_len);
            }
            if (!nanosecond_timestamps) {
                p_header.ts_usec = p_header.ts_usec * 1000;
            }
            frame_length = p_header.incl_len + PCAP_RECORD_HEADER_LENGTH;
            if ((used_buffer_length - offset) < frame_length) {
                break; 
            }
            if (p_header.incl_len > 0) {
                endless_loop = extcap_dumper_dump(extcap_dumper, fifo, data + offset + PCAP_RECORD_HEADER_LENGTH,
                    p_header.incl_len, p_header.orig_len, p_header.ts_sec, p_header.ts_usec);
            }
            offset += frame_length;
        }
        if (offset < used_buffer_length) {
            memmove(data, data + offset, used_buffer_length - offset);
        }
        used_buffer_length -= offset;
    }
    closesocket(sock);
    return EXIT_CODE_SUCCESS;
}
