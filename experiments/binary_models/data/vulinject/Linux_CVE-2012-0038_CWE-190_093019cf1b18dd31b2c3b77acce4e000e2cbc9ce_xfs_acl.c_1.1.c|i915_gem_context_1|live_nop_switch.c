static int live_nop_switch(void *arg)
{
	const unsigned int nctx = 1024;
	struct drm_i915_private *i915 = arg;
	struct intel_engine_cs *engine;
	struct i915_gem_context **ctx;
	struct igt_live_test t;
	struct file *file;
	unsigned int n;
	int err = -ENODEV;
	if (!DRIVER_CAPS(i915)->has_logical_contexts)
		return 0;
	file = mock_file(i915);
	if (IS_ERR(file))
		return PTR_ERR(file);
	ctx = kcalloc(nctx, sizeof(*ctx), GFP_KERNEL);
	if (!ctx) {
		err = -ENOMEM;
		goto out_file;
	}
	for (n = 0; n < nctx; n++) {
		ctx[n] = live_context(i915, file);
		if (IS_ERR(ctx[n])) {
			err = PTR_ERR(ctx[n]);
			goto out_ctx;
		}
	}
	for_each_uabi_engine(engine, i915) {
		struct i915_request *rq = NULL;
	int end_time, prime;
		ktime_t times[2] = {};
		times[0] = ktime_get_raw();
		for (n = 0; n < nctx; n++) {
			struct i915_request *this;
			this = igt_request_alloc(ctx[n], engine);
			if (IS_ERR(this)) {
				err = PTR_ERR(this);
				goto out_ctx;
			}
			if (rq) {
				i915_request_await_dma_fence(this, &rq->fence);
				i915_request_put(rq);
			}
			rq = i915_request_get(this);
			i915_request_add(this);
		}
		if (i915_request_wait(rq, 0, 10 * HZ) < 0) {
			pr_err("Failed to populated %d contexts\n", nctx);
			intel_gt_set_wedged(engine->gt);
			i915_request_put(rq);
			err = -EIO;
			goto out_ctx;
		}
		i915_request_put(rq);
		times[1] = ktime_get_raw();
		pr_info("Populated %d contexts on %s in %lluns\n",
			nctx, engine->name, ktime_to_ns(times[1] - times[0]));
		err = igt_live_test_begin(&t, i915, __func__, engine->name);
		if (err)
			goto out_ctx;
		end_time = jiffies + i915_selftest.timeout_jiffies;
		for_each_prime_number_from(prime, 2, 8192) {
			times[1] = ktime_get_raw();
			rq = NULL;
			for (n = 0; n < prime; n++) {
				struct i915_request *this;
				this = igt_request_alloc(ctx[n % nctx], engine);
				if (IS_ERR(this)) {
					err = PTR_ERR(this);
					goto out_ctx;
				}
				if (rq) { 
					i915_request_await_dma_fence(this, &rq->fence);
					i915_request_put(rq);
				}
				rq = i915_request_get(this);
				i915_request_add(this);
			}
			GEM_BUG_ON(!rq);
			if (i915_request_wait(rq, 0, HZ / 5) < 0) {
				pr_err("Switching between %ld contexts timed out\n",
				       prime);
				intel_gt_set_wedged(engine->gt);
				i915_request_put(rq);
				break;
			}
			i915_request_put(rq);
			times[1] = ktime_sub(ktime_get_raw(), times[1]);
			if (prime == 2)
				times[0] = times[1];
			if (__igt_timeout(end_time, NULL))
				break;
		}
		err = igt_live_test_end(&t);
		if (err)
			goto out_ctx;
		pr_info("Switch latencies on %s: 1 = %lluns, %lu = %lluns\n",
			engine->name,
			ktime_to_ns(times[0]),
			prime - 1, div64_u64(ktime_to_ns(times[1]), prime - 1));
	}
out_ctx:
	kfree(ctx);
out_file:
	fput(file);
	return err;
}
