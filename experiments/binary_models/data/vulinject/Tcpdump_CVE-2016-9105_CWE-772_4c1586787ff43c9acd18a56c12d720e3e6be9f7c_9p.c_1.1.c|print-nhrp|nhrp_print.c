nhrp_print(netdissect_options *ndo, const u_char *bp, u_int length)
{
	const struct nhrp_fixed_header	*fixed_hdr;
	unsigned short			afn;
	unsigned short			pro_type;
	unsigned short			pktsz;
	unsigned short			extoff;
	unsigned char				op_version;
	unsigned char				op_type;
	unsigned char				shtl, sstl;
	const struct nhrp_mand_header	*mand_hdr;
	unsigned short			mand_part_len;
	unsigned char				spl, dpl;
	ndo->ndo_protocol = "nhrp";
	nd_print_protocol_caps(ndo);
	ND_PRINT(": ");
	fixed_hdr = (const struct nhrp_fixed_header *)bp;
	ND_ICHECK_ZU(length, <, sizeof(*fixed_hdr));
	op_version = GET_U_1(fixed_hdr->op_version);
	if (op_version != NHRP_VER_RFC2332) {
		ND_PRINT("unknown-version-%02x", op_version);
		return;
	}
	afn = GET_BE_U_2(fixed_hdr->afn);
	pro_type = GET_BE_U_2(fixed_hdr->pro_type);
	pktsz = GET_BE_U_2(fixed_hdr->pktsz);
	ND_ICHECKMSG_ZU("pktsz", pktsz, <, sizeof(*fixed_hdr));
	extoff = GET_BE_U_2(fixed_hdr->extoff);
	op_type = GET_U_1(fixed_hdr->op_type);
	ND_PRINT("%s", tok2str(pkt_types, "unknown-op-type-%04x", op_type));
	if (extoff == 0) {
		mand_part_len = pktsz - sizeof(*fixed_hdr);
	} else {
		ND_ICHECKMSG_U("extoff", extoff, >, pktsz);
		ND_ICHECKMSG_ZU("extoff", extoff, <, sizeof(*fixed_hdr));
		mand_part_len = extoff - sizeof(*fixed_hdr);
	}
	length -= sizeof(*fixed_hdr);
	if (mand_part_len > length)
		mand_part_len = (unsigned short)length;
	ND_TCHECK_LEN(bp, sizeof(*fixed_hdr));
	bp += sizeof(*fixed_hdr);
	length -= sizeof(*fixed_hdr);
	ND_ICHECK_ZU(mand_part_len, <, sizeof(*mand_hdr));
	ND_TCHECK_LEN(bp, sizeof(*mand_hdr));
	mand_hdr = (const struct nhrp_mand_header *)bp;
	switch (op_type) {
	case NHRP_PKT_RESOLUTION_REQUEST:
	case NHRP_PKT_RESOLUTION_REPLY:
	case NHRP_PKT_REGISTRATION_REQUEST:
	case NHRP_PKT_REGISTRATION_REPLY:
	case NHRP_PKT_PURGE_REQUEST:
	case NHRP_PKT_PURGE_REPLY:
		ND_PRINT(", id %u", GET_BE_U_4(mand_hdr->u.id));
		break;
	case NHRP_PKT_ERROR_INDICATION:
		ND_PRINT(", error <%s>", tok2str(err_code_types, "unknown-err-code-%u", GET_BE_U_2(mand_hdr->u.err.code)));
		break;
	case NHRP_PKT_TRAFFIC_INDICATION:
		ND_PRINT(", code <%s>", tok2str(traffic_code_types, "unknown-traffic-code-%u", GET_BE_U_2(mand_hdr->u.tind.traffic_code)));
		break;
	}
	shtl = GET_U_1(fixed_hdr->shtl);
	sstl = GET_U_1(fixed_hdr->sstl);
	if (ndo->ndo_vflag) {
		ND_PRINT(", hopcnt %u", GET_U_1(fixed_hdr->hopcnt));
		if (shtl & 0x80)
			ND_PRINT(" (shtl bit 7 set)");
		if (shtl & 0x40)
			ND_PRINT(" (nbma E.154)");
	}
	spl = GET_U_1(mand_hdr->spl);
	dpl = GET_U_1(mand_hdr->dpl);
	bp += sizeof(*mand_hdr);	
	mand_part_len -= sizeof(*mand_hdr);
	if (shtl != 0) {
		ND_ICHECK_U(mand_part_len, <, shtl);
		switch (afn) {
		case AFNUM_IP:
			ND_PRINT(", src nbma %s", NHRP_IPv4_ADDR_STRING(bp, shtl));
			break;
		case AFNUM_IP6:
			ND_PRINT(", src nbma %s", NHRP_IPv6_ADDR_STRING(bp, shtl));
			break;
		case AFNUM_802:
			ND_PRINT(", src nbma %s", NHRP_MAC_ADDR_STRING(bp, shtl));
			break;
		default:
			ND_PRINT(", unknown-nbma-addr-family-%04x (%s)",
			         afn, GET_LINKADDR_STRING(bp, LINKADDR_OTHER, shtl));
			break;
		}
		bp += shtl;
		mand_part_len -= shtl;
	}
	if (sstl != 0) {
		ND_TCHECK_LEN(bp, sstl);
		bp += sstl;
		mand_part_len -= sstl;
	}
	ND_PRINT(", ");
	if (spl != 0) {
		ND_ICHECK_U(mand_part_len, <, spl);
		switch (pro_type) {
		case ETHERTYPE_IP:
			ND_PRINT("%s ", NHRP_IPv4_ADDR_STRING(bp, spl));
			break;
		case ETHERTYPE_IPV6:
			ND_PRINT("%s ", NHRP_IPv6_ADDR_STRING(bp, spl));
			break;
		default:
			ND_PRINT("proto type %04x ", pro_type);
			ND_PRINT("%s ", GET_LINKADDR_STRING(bp, LINKADDR_OTHER, spl));
			break;
		}
		bp += spl;
		mand_part_len -= spl;
	}
	ND_PRINT("->");
	if (dpl != 0) {
		ND_ICHECK_U(mand_part_len, <, dpl);
		switch (pro_type) {
		case ETHERTYPE_IP:
			ND_PRINT(" %s", NHRP_IPv4_ADDR_STRING(bp, dpl));
			break;
		case ETHERTYPE_IPV6:
			ND_PRINT(" %s", NHRP_IPv6_ADDR_STRING(bp, dpl));
			break;
		default:
			ND_PRINT(" %s", GET_LINKADDR_STRING(bp, LINKADDR_OTHER, dpl));
			break;
		}
		bp += dpl;
		mand_part_len -= dpl;
	}
	switch (op_type) {
	case NHRP_PKT_RESOLUTION_REQUEST:
	case NHRP_PKT_RESOLUTION_REPLY:
	case NHRP_PKT_REGISTRATION_REQUEST:
	case NHRP_PKT_REGISTRATION_REPLY:
	case NHRP_PKT_PURGE_REQUEST:
	case NHRP_PKT_PURGE_REPLY:
		while (mand_part_len != 0) {
			u_int cie_len;
			cie_len = nhrp_print_cie(ndo, bp, mand_part_len,
			    afn, pro_type);
			bp += cie_len;
			mand_part_len -= (unsigned short)cie_len;
		}
		break;
	case NHRP_PKT_ERROR_INDICATION:
		break;
	default:
		break;
	}
	return;
invalid:
	nd_print_invalid(ndo);
}
