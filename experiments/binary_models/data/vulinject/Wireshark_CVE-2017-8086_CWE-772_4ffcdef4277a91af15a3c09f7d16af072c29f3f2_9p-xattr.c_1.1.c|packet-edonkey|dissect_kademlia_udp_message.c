static int dissect_kademlia_udp_message(guint8 msg_type,
                                         tvbuff_t *tvb, packet_info *pinfo,
                                         int offset, int length, proto_tree *tree)
{
    int msg_end, bytes_remaining;
    proto_item *hidden_item;
    bytes_remaining = tvb_reported_length_remaining(tvb, offset);
    if ((length < 0) || (length > bytes_remaining)) length = bytes_remaining;
    if (length <= 0) return offset;
    hidden_item = proto_tree_add_item(tree, hf_kademlia, tvb, offset, 1, ENC_BIG_ENDIAN);
    msg_end = offset + length;
    switch (msg_type) {
        case KADEMLIA_BOOTSTRAP_REQ:
        case KADEMLIA_HELLO_REQ:
        case KADEMLIA_HELLO_RES:
            offset = dissect_kademlia_peer(tvb, pinfo, offset, tree);
            break;
        case KADEMLIA2_BOOTSTRAP_REQ:
            offset = dissect_kademlia2_prolog( tvb, pinfo, offset, tree );
            break;
        case KADEMLIA2_HELLO_REQ:
        case KADEMLIA2_HELLO_RES:
            offset = dissect_kademlia2_prolog( tvb, pinfo, offset, tree );
            offset = dissect_kademlia_taglist( tvb, pinfo, offset, tree );
            break;
        case KADEMLIA_BOOTSTRAP_RES:  
            offset = dissect_kademlia_peer_list_2byte( tvb, pinfo, offset, tree );
            break;
        case KADEMLIA2_BOOTSTRAP_RES:
            offset = dissect_kademlia2_prolog( tvb, pinfo, offset, tree );
            offset = dissect_kademlia2_peer_list_2byte( tvb, pinfo, offset, tree );
            break;
        case KADEMLIA2_SEARCH_SOURCE_REQ:
            {
                offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_target_id);
                proto_tree_add_item(tree, hf_edonkey_kademlia_start_position, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                offset +=2;
                proto_tree_add_item(tree, hf_edonkey_kademlia_filesize, tvb, offset, 8, ENC_LITTLE_ENDIAN);
                offset +=8;
            }
            break;
        case KADEMLIA_SEARCH_NOTES_REQ: 
            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_hash);
            break;
        case KADEMLIA2_SEARCH_KEY_REQ:
            {
              offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_target_id);
              proto_tree_add_item(tree, hf_edonkey_kademlia_start_position, tvb, offset, 2, ENC_LITTLE_ENDIAN);
              offset += 2;
            }
            break;
        case KADEMLIA2_SEARCH_NOTES_REQ:
        case KADEMLIA_PUBLISH_RES:
            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_target_id);
            if (offset<msg_end) {
                offset = dissect_kademlia_uload( tvb, pinfo, offset, tree );
            }
            break;
        case KADEMLIA2_PUBLISH_RES:
            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_target_id);
            offset = dissect_kademlia_uload( tvb, pinfo, offset, tree );
            break;
        case KADEMLIA_REQ: 
        case KADEMLIA2_REQ:
            {
                int type;
                guint8 target_id[16];
                guint8 recipients_id[16];
                proto_item *ti;
                int i, j, k, l;
                char binarray[129];
                type = tvb_get_guint8(tvb, offset);
                ti = proto_tree_add_uint_format_value(tree, hf_kademlia_request_type, tvb, offset, 1, type, "0x%02x", type );
                proto_item_append_text(ti, "%s", val_to_str_const(type, kademlia_parameter, " Unknown"));
                offset +=1;
                for (i=0; i<4; i++) {
                  for (j=3; j>=0; j--) {
                    l = (j+4*i);
                    target_id[l] = tvb_get_guint8(tvb, offset + abs(8*i-(l-3)));
                  }
                }
                offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_target_id);
                for (i=0; i<4; i++) {
                  for (j=3; j>=0; j--) {
                    l = (j+4*i);
                    recipients_id[l] = tvb_get_guint8(tvb, offset + abs(8*i-(l-3)));
                  }
                }
                offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_recipients_id);
                for (i=0; i<16; i++) {
                  k = 128;
                  l = target_id[i]^recipients_id[i];
                  for(j=8*i; j<8*i+8; j++) {
                    if (l >= k) {
                      binarray[j] = '1';
                      l = l-k;
                    }
                    else
                      binarray[j] = '0';
                    k = k/2;
                  }
                }
                binarray[128] = '\0';
                proto_tree_add_string(tree, hf_kademlia_distance, tvb, offset, 0, binarray);
            }
            break;
        case KADEMLIA_RES:     
            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_target_id);
            offset = dissect_kademlia_peer_list_1byte( tvb, pinfo, offset, tree );
            break;
        case KADEMLIA2_RES:
            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_target_id);
            offset = dissect_kademlia2_peer_list_1byte( tvb, pinfo, offset, tree );
            break;
        case KADEMLIA_FIREWALLED_RES: 
            offset = dissect_kademlia_ip_address( tvb, pinfo, offset, tree );
            break;
        case KADEMLIA_FIREWALLED_REQ: 
            offset = dissect_kademlia_tcp_port( tvb, pinfo, offset, tree );
            break;
        case KADEMLIA_CALLBACK_REQ:
        case KADEMLIA_FINDBUDDY_REQ:
        case KADEMLIA_FINDBUDDY_RES:
            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_hash);
            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_hash);
            offset = dissect_kademlia_tcp_port( tvb, pinfo, offset, tree );
            break;
        case KADEMLIA2_PUBLISH_SOURCE_REQ:
            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_file_id);
            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_peer_id);
            offset = dissect_kademlia_taglist( tvb, pinfo, offset, tree );
            break;
        case KADEMLIA_SEARCH_REQ:
            {
                int restrictive;
                offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_target_id);
                restrictive = tvb_get_guint8(tvb, offset);
                proto_tree_add_item(tree, hf_edonkey_kademlia_restrictive, tvb, offset, 1, ENC_NA);
                offset +=1;
                if ( offset < msg_end && restrictive )
                    offset = dissect_kademlia_search_expression_tree( tvb, pinfo, offset, tree );
            }
            break;
        case KADEMLIA_SEARCH_RES:
            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_target_id);
            offset = dissect_edonkey_list(tvb, pinfo, offset, tree, 2, "Result", dissect_kademlia_search_result );
            break;
        case KADEMLIA2_SEARCH_RES:
            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_sender_id);
            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_target_id);
            offset = dissect_edonkey_list(tvb, pinfo, offset, tree, 2, "Result", dissect_kademlia_search_result );
            break;
        case KADEMLIA2_PUBLISH_KEY_REQ:
            {
                offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_keyword_hash);
                offset = dissect_edonkey_list(tvb, pinfo, offset, tree, 2, "StuffToPublish", dissect_kademlia_publish_req_entry_file );
                break;
            }
        case KADEMLIA_PUBLISH_REQ: 
            {
                guint8 tagname_value=0, taglist_size, type;
                int i=1, j=34;
                taglist_size = tvb_get_guint8(tvb, offset + j);
                j++;
                while(i <= taglist_size) {
                  type = tvb_get_guint8(tvb, offset + j);
                  j +=3;
                  tagname_value = tvb_get_guint8(tvb, offset + j);
                  if (tagname_value == 0xff)
                    i = taglist_size;
                  j++;
                  switch(type) {
                    case KADEMLIA_TAGTYPE_HASH:
                        j += 16;
                        break;
                    case KADEMLIA_TAGTYPE_STRING:
                    {
                        guint16 string_length = tvb_get_letohs(tvb, offset+j);
                        j += 2 + string_length;
                        break;
                    }
                    case KADEMLIA_TAGTYPE_UINT8:
                        j += 1;
                        break;
                    case KADEMLIA_TAGTYPE_UINT16:
                        j += 2;
                        break;
                    case KADEMLIA_TAGTYPE_UINT32:
                    case KADEMLIA_TAGTYPE_FLOAT32:
                        j += 4;
                        break;
                    case KADEMLIA_TAGTYPE_UINT64:
                        j += 8;
                        break;
                    case KADEMLIA_TAGTYPE_BSOB:
                    {
                      guint16 bsob_length = tvb_get_guint8(tvb, offset);
                      j += 1 + bsob_length;
                      break;
                    }
                  }
                  i++;
                }
                switch (tagname_value) {
                    case KADEMLIA_TAG_SOURCETYPE:
                        {
                            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_file_id);
                            offset = dissect_edonkey_list(tvb, pinfo, offset, tree, 2, "StuffToPublish", dissect_kademlia_publish_req_entry_peer);
                        }
                        break;
                    default:
                        {
                            offset = dissect_kademlia_hash(tvb, pinfo, offset, tree, &hf_kademlia_keyword_hash);
                            offset = dissect_edonkey_list(tvb, pinfo, offset, tree, 2, "StuffToPublish", dissect_kademlia_publish_req_entry_file);
                        }
                }
            }
    }
    return offset;
}
