static av_cold int decode_init(AVCodecContext *avctx)
{
    EXRContext *s = avctx->priv_data;
    uint32_t i;
    union av_intfloat32 t;
    float one_gamma = 1.0f / s->gamma;
    av_csp_trc_function trc_func = NULL;
    s->avctx              = avctx;
    ff_exrdsp_init(&s->dsp);
#if HAVE_BIGENDIAN
    ff_bswapdsp_init(&s->bbdsp);
#endif
    trc_func = av_csp_trc_func_from_id(s->apply_trc_type);
    if (trc_func) {
        for (i = 0; i < 65536; ++i) {
            t.i = half2float(i, &s->h2f_tables);
            t.f = trc_func(t.f);
            s->gamma_table[i] = t;
        }
    } else {
        if (one_gamma > 0.9999f && one_gamma < 1.0001f) {
            for (i = 0; i < 65536; ++i) {
                s->gamma_table[i].i = half2float(i, &s->h2f_tables);
            }
        } else {
            for (i = 0; i < 65536; ++i) {
                t.i = half2float(i, &s->h2f_tables);
                /* If negative value we reuse half value */
                if (t.f <= 0.0f) {
                    s->gamma_table[i] = t;
                } else {
                    t.f = powf(t.f, one_gamma);
                    s->gamma_table[i] = t;
                }
            }
        }
    }
    // allocate thread data, used for non EXR_RAW compression types
    s->thread_data = av_calloc(avctx->thread_count, sizeof(*s->thread_data));
    if (!s->thread_data)
        return AVERROR(ENOMEM);
    return 0;
}
