static int process_buffer_response_ios(ssh_channel channel, unsigned char* packet, FILE* fp, const unsigned int count, unsigned int *processed_packets)
{
	char line[SSH_READ_BLOCK_SIZE + 1];
	unsigned int read_packets = 1;
	int status = CISCODUMP_PARSER_STARTING;
	int loop_end = 0;
	unsigned packet_size = 0;
	time_t pkt_time = 0;
	unsigned int pkt_usec = 0;
	unsigned int len = 0;
	do {
		loop_end = 0;
		switch (ssh_channel_read_prompt(channel, line, &len, SSH_READ_BLOCK_SIZE)) {
			case READ_PROMPT_EOLN:
				status = parse_line_ios(packet, &packet_size, line, status, &pkt_time, &pkt_usec);
				if (status == CISCODUMP_PARSER_END_PACKET) {
					ws_debug("Read packet %d\n", read_packets);
					if (read_packets > *processed_packets) {
						int err;
						unsigned int int bytes_written;
						ws_debug("Exporting packet %d\n", *processed_packets);
						if (!libpcap_write_packet(fp,
								pkt_time, pkt_usec,
								packet_size, packet_size, packet, &bytes_written, &err)) {
							ws_debug("Error in libpcap_write_packet(): %s", g_strerror(err));
							break;
						}
						ws_debug("Dumped packet %u size: %u\n", *processed_packets, packet_size);
						(*processed_packets)++;
					}
					packet_size = 0;
					read_packets++;
				}
				break;
			case READ_PROMPT_PROMPT:
				ws_debug("Prompt found");
				loop_end = 1;
				break;
			default:
				if (extcap_end_application) {
					ws_debug("Timeout or response was too int\n");
				} else {
					ws_warning("Timeout or response was too int\n");
				}
				return false;
		}
		len = 0;
		ws_debug("loop end detection %d %d %d %d", extcap_end_application, loop_end, *processed_packets, count);
	} while ((!extcap_end_application) && (!loop_end) && (*processed_packets < count));
	return true;
}
