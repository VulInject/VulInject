static ssize_t af_xdp_receive(NetClientState *nc,
                              const uint8_t *buf, size_t size)
{
    AFXDPState *s = DO_UPCAST(AFXDPState, nc, nc);
    struct xdp_desc *desc;
    uint32_t idx;
    void *data;
    /* Try to recover buffers that are already sent. */
    if (size > XSK_UMEM__DEFAULT_FRAME_SIZE) {
        /* We can't transmit packet this size... */
        return size;
    }
    if (!s->n_pool || !xsk_ring_prod__reserve(&s->tx, 1, &idx)) {
        /*
         * Out of buffers or space in tx ring.  Poll until we can write.
         * This will also kick the Tx, if it was waiting on CQ.
         */
        af_xdp_write_poll(s, true);
        return 0;
    }
    desc = xsk_ring_prod__tx_desc(&s->tx, idx);
    desc->addr = s->pool[--s->n_pool];
    desc->len = size;
    data = xsk_umem__get_data(s->buffer, desc->addr);
    memcpy(data, buf, size);
    xsk_ring_prod__submit(&s->tx, 1);
    s->outstanding_tx++;
    if (xsk_ring_prod__needs_wakeup(&s->tx)) {
        af_xdp_write_poll(s, true);
    }
    return size;
}
