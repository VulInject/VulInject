static gboolean decode_GetProfileListRes(tvbuff_t *tvb, packet_info *pinfo, proto_tree *messagebodytree_list, guint *offset){
	proto_item *SML_time = NULL;
	proto_item *treepath = NULL;
	proto_item *periodList = NULL;
	proto_item *periodList_Entry = NULL;
	proto_tree *SML_time_tree = NULL;
	proto_tree *treepath_list = NULL;
	proto_tree *periodList_list = NULL;
	proto_tree *periodList_Entry_list = NULL;
	guint i = 0;
	guint repeat = 0;
	guint data = 0;
	guint length = 0;
	field_serverId(tvb, messagebodytree_list, offset, &data, &length);
	get_length(tvb, offset, &data, &length);
	SML_time_tree = proto_tree_add_subtree(messagebodytree_list, tvb, *offset, -1, ett_sml_time, &SML_time, "actTime");
	*offset+=1;
	sml_time_type(tvb, pinfo, SML_time_tree, offset);
	proto_item_set_end(SML_time,tvb, *offset);
	field_regPeriod(tvb, messagebodytree_list, offset, &data, &length);
	get_length(tvb, offset, &data, &length);
	repeat = (data+length);
	treepath_list = proto_tree_add_subtree_format(messagebodytree_list, tvb, *offset, -1, ett_sml_treepath, &treepath,
				"parameterTreePath with %d %s", length+data, plurality(length+data, "element", "elements"));
	if ((tvb_get_guint8(tvb,*offset) & 0xF0) != LONG_LIST && (tvb_get_guint8(tvb,*offset) & 0xF0) != SHORT_LIST){
		expert_add_info_format(pinfo, treepath, &ei_sml_invalid_count, "invalid count of elements in parameterTreePath");
		return TRUE;
	}
		if(repeat == 0) {
		expert_add_info_format(pinfo, treepath, &ei_sml_invalid_count, "invalid loop count");
		return TRUE;
	}
	*offset+=length;
	for (i=0; i< repeat; i++) {
		field_parameterTreePath(tvb, treepath_list, offset, &data, &length);
	}
	proto_item_set_end(treepath, tvb,*offset);
	get_length(tvb, offset, &data, &length);
	SML_time_tree = proto_tree_add_subtree(messagebodytree_list, tvb, *offset, -1, ett_sml_time, &SML_time, "valTime");
	if (data == 0){
		proto_item_append_text(SML_time, ": NOT SET");
		proto_item_set_len(SML_time, length + data);
		*offset+=1;
	}
	else {
		*offset+=1;
		sml_time_type(tvb, pinfo, SML_time_tree, offset);
		proto_item_set_end(SML_time,tvb,*offset);
	}
	field_status(tvb, messagebodytree_list, offset, &data, &length);
	get_length(tvb, offset, &data, &length);
	repeat = (data+length);
	periodList_list = proto_tree_add_subtree_format(messagebodytree_list, tvb, *offset, -1, ett_sml_periodList, &periodList,
					"period-List with %d %s", length+data, plurality(length+data, "element", "elements"));
	if ((tvb_get_guint8(tvb,*offset) & 0xF0) != LONG_LIST && (tvb_get_guint8(tvb,*offset) & 0xF0) != SHORT_LIST){
		expert_add_info_format(pinfo, periodList, &ei_sml_invalid_count, "invalid count of elements in periodList");
		return TRUE;
	}
	else if (repeat <= 0){
		expert_add_info_format(pinfo, periodList, &ei_sml_invalid_count, "invalid loop count");
		return TRUE;
	}
	*offset+=length;
	for (i=0; i< repeat; i++) {
		get_length(tvb, offset, &data, &length);
		periodList_Entry_list = proto_tree_add_subtree(periodList_list, tvb, *offset, -1, ett_sml_period_List_Entry, &periodList_Entry, "PeriodEntry");
		*offset+=1;
		field_objName(tvb, periodList_Entry_list, offset, &data, &length);
		field_unit(tvb, periodList_Entry_list, offset, &data, &length);
		field_scaler(tvb, periodList_Entry_list, offset, &data, &length);
		sml_value(tvb, pinfo, periodList_Entry_list, offset, &data, &length);
		field_valueSignature(tvb, periodList_Entry_list, offset, &data, &length);
		proto_item_set_end(periodList_Entry, tvb, *offset);
	}
	proto_item_set_end(periodList, tvb, *offset);
	field_rawdata(tvb, messagebodytree_list, offset, &data, &length);
	field_periodSignature(tvb, messagebodytree_list, offset, &data, &length);
	return FALSE;
}
