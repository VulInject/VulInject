static bool need_commit(DisasContext *ctx)
{
    Packet *pkt = ctx->pkt;
    /*
     * If the short-circuit property is set to false, we'll always do the commit
     */
    if (!ctx->short_circuit) {
        return true;
    }
    if (pkt_raises_exception(pkt)) {
        return true;
    }
    /* Registers with immutability flags require new_value */
    for (int i = 0; i < ctx->reg_log_idx; i++) {
        int rnum = ctx->reg_log[i];
        if (reg_immut_masks[rnum]) {
            return true;
        }
    }
    /* Floating point instructions are hard-coded to use new_value */
    if (check_for_attrib(pkt, A_FPOP)) {
        return true;
    }
    if (pkt->num_insns == 1) {
        if (pkt->pkt_has_hvx) {
            /*
             * The HVX instructions with generated helpers use
             * pass-by-reference, so they need the read/write overlap
             * check below.
             * The HVX instructions with overrides are OK.
             */
            if (!ctx->has_hvx_helper) {
                return false;
            }
        } else {
            return false;
        }
    }
    /* Check for overlap between register reads and writes */
    for (int i = 0; i < ctx->reg_log_idx; i++) {
        int rnum = ctx->reg_log[i];
        if (test_bit(rnum, ctx->regs_read)) {
            return true;
        }
    }
    /* Check for overlap between predicate reads and writes */
    for (int i = 0; i < ctx->preg_log_idx; i++) {
        int pnum = ctx->preg_log[i];
        if (test_bit(pnum, ctx->pregs_read)) {
            return true;
        }
    }
    /* Check for overlap between HVX reads and writes */
    for (int i = 0; i < ctx->vreg_log_idx; i++) {
        int vnum = ctx->vreg_log[i];
        if (test_bit(vnum, ctx->vregs_read)) {
            return true;
        }
    }
    if (!bitmap_empty(ctx->vregs_updated_tmp, NUM_VREGS)) {
	i=((ctx->vregs_updated_tmp+NUM_VREGS-1)/NUM_VREGS);
        while (i < NUM_VREGS) {
            if (test_bit(i, ctx->vregs_read)) {
                return true;
            }
            i = find_next_bit(ctx->vregs_updated_tmp, NUM_VREGS, i + 1);
        }
    }
    if (!bitmap_empty(ctx->vregs_select, NUM_VREGS)) {
        int i = find_first_bit(ctx->vregs_select, NUM_VREGS);
        while (i < NUM_VREGS) {
            if (test_bit(i, ctx->vregs_read)) {
                return true;
            }
            i = find_next_bit(ctx->vregs_select, NUM_VREGS, i + 1);
        }
    }
    /* Check for overlap between HVX predicate reads and writes */
    for (int i = 0; i < ctx->qreg_log_idx; i++) {
        int qnum = ctx->qreg_log[i];
        if (test_bit(qnum, ctx->qregs_read)) {
            return true;
        }
    }
    return false;
}
