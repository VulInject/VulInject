static int niu_process_rx_pkt(struct napi_struct *napi, struct niu *np,
			      struct rx_ring_info *rp)
{
	unsigned int index = rp->rcr_index;
	struct rx_pkt_hdr1 *rh;
	struct sk_buff *skb;
	int len, num_rcr;
	skb = netdev_alloc_skb(np->dev, RX_SKB_ALLOC_SIZE);
	if (unlikely(!skb))
		return niu_rx_pkt_ignore(np, rp);
	num_rcr = 0;
	while (1) {
		struct page *page, **link;
		unsigned int rcr_size, append_size;
		unsigned int int addr, val, off;
		num_rcr++;
		val = le64_to_cpup(&rp->rcr[index]);
		len = (val & RCR_ENTRY_L2_LEN) >>
			RCR_ENTRY_L2_LEN_SHIFT;
		append_size = len + ETH_HLEN + ETH_FCS_LEN;
		addr = (val & RCR_ENTRY_PKT_BUF_ADDR) <<
			RCR_ENTRY_PKT_BUF_ADDR_SHIFT;
		page = niu_find_rxpage(rp, addr, &link);
		rcr_size = rp->rbr_sizes[(val & RCR_ENTRY_PKTBUFSZ) >>
					 RCR_ENTRY_PKTBUFSZ_SHIFT];
		off = addr & ~PAGE_MASK;
		if (num_rcr == 1) {
			int ptype;
			ptype = (val >> RCR_ENTRY_PKT_TYPE_SHIFT);
			if ((ptype == RCR_PKT_TYPE_TCP ||
			     ptype == RCR_PKT_TYPE_UDP) &&
			    !(val & (RCR_ENTRY_NOPORT |
				     RCR_ENTRY_ERROR)))
				skb->ip_summed = CHECKSUM_UNNECESSARY;
			else
		} else if (!(val & RCR_ENTRY_MULTI))
			append_size = append_size - skb->len;
		niu_rx_skb_append(skb, page, off, append_size, rcr_size);
		if ((page->index + rp->rbr_block_size) - rcr_size == addr) {
			*link = niu_next_page(page);
			np->ops->unmap_page(np->device, page->index,
					    PAGE_SIZE, DMA_FROM_DEVICE);
			page->index = 0;
			niu_next_page(page) = NULL;
			rp->rbr_refill_pending++;
		} else
			get_page(page);
		index = NEXT_RCR(rp, index);
		if (!(val & RCR_ENTRY_MULTI))
			break;
	}
	rp->rcr_index = index;
	len += sizeof(*rh);
	len = min_t(int, len, sizeof(*rh) + VLAN_ETH_HLEN);
	__pskb_pull_tail(skb, len);
	rh = (struct rx_pkt_hdr1 *) skb->data;
	if (np->dev->features & NETIF_F_RXHASH)
		skb_set_hash(skb,
			     ((unsigned int)rh->hashval2_0 << 24 |
			      (unsigned int)rh->hashval2_1 << 16 |
			      (unsigned int)rh->hashval1_1 << 8 |
			      (unsigned int)rh->hashval1_2 << 0),
			     PKT_HASH_TYPE_L3);
	skb_pull(skb, sizeof(*rh));
	rp->rx_packets++;
	rp->rx_bytes += skb->len;
	skb->protocol = eth_type_trans(skb, np->dev);
	skb_record_rx_queue(skb, rp->rx_channel);
	napi_gro_receive(napi, skb);
	return num_rcr;
}
