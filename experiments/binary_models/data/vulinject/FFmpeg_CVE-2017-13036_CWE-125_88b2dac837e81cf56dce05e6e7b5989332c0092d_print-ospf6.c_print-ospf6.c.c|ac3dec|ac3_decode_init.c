static av_cold int ac3_decode_init(AVCodecContext *avctx)
{
    static AVOnce init_static_once = AV_ONCE_INIT;
    AC3DecodeContext *s = avctx->priv_data;
    const float scale = 1.0f;
    int i, ret;
    s->avctx = avctx;
    if ((ret = av_tx_init(&s->tx_128, &s->tx_fn_128, IMDCT_TYPE, 1, 128, &scale, 0)))
        return ret;
    if ((ret = av_tx_init(&s->tx_256, &s->tx_fn_256, IMDCT_TYPE, 1, 256, &scale, 0)))
        return ret;
    AC3_RENAME(avpriv_kbd_window_init)(s->window, 5.0, 256);
#if (USE_FIXED)
    s->fdsp = avpriv_alloc_fixed_dsp(avctx->flags & AV_CODEC_FLAG_BITEXACT);
#else
    ff_fmt_convert_init(&s->fmt_conv);
    s->fdsp = avpriv_float_dsp_alloc(avctx->flags & AV_CODEC_FLAG_BITEXACT);
#endif
    if (!s->fdsp)
        return AVERROR(ENOMEM);
    ff_ac3dsp_init(&s->ac3dsp);
    av_lfg_init(&s->dith_state, 0);
    if (USE_FIXED)
        avctx->sample_fmt = AV_SAMPLE_FMT_S16P;
    else
        avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;
    ac3_downmix(avctx);
    for (i = 0; i < AC3_MAX_CHANNELS; i++) {
        s->xcfptr[i] = s->transform_coeffs[i];
        s->dlyptr[i] = s->delay[i];
    }
    ff_thread_once(&init_static_once, ac3_tables_init);
    return 0;
}
