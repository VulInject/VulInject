R_API RList *r_io_sundo_list(RIO *io, int mode) {
	int idx, undos, redos, i, j, start, end;
	RList* list = NULL;
	if (mode == '!') {
		mode = 0;
	}
	if (!io->undo.s_enable) {
		return NULL;
	}
	undos = io->undo.undos;
	redos = io->undo.redos;
	idx = io->undo.idx;
	start = (idx - undos + R_IO_UNDOS) % R_IO_UNDOS;
	end = (idx + redos) % R_IO_UNDOS;
	j = 0;
	switch (mode) {
	case 'j':
		io->cb_printf ("[");
		break;
	case 0:
		break;
	}
	for (i = start;; i = (i + 1) % R_IO_UNDOS) {
		int idx = (j < undos)? undos - j - 1: j - undos - 1;
		RIOUndos *undo = &io->undo.seek[i];
		ut64 addr = undo->off;
		bool notLast = (j + 1 < undos);
		switch (mode) {
		case '=':
			if (j < undos) {
				io->cb_printf ("0x%"PFMT64x"%s", addr, notLast? " > ": "");
			}
			break;
		case 'r':
			{
				char *cmt = io->coreb.cmdstrf (io->coreb.core, "fd 0x%08"PFMT64x, addr);
				r_str_trim (cmt);
				if (j < undos) {
					io->cb_printf ("0x%08"PFMT64x" ; %ds- # %s\n", addr, idx + 1, cmt);
				} else if (j == undos && j != 0 && redos != 0) {
					io->cb_printf ("0x%08"PFMT64x" ; # CUR %s\n", addr, cmt);
				} else if (j != undos) {
					io->cb_printf ("0x%08"PFMT64x" ; %ds+ # %s\n", addr, idx + 1, cmt);
				} else if (addr != 0) {
					io->cb_printf ("0x%08"PFMT64x" ; # CUR %s\n", addr, cmt);
				}
				free (cmt);
			}
			break;
		case '*':
			if (j < undos) {
				io->cb_printf ("f undo_%d @ 0x%"PFMT64x"\n", idx, addr);
			} else if (j == undos && j != 0 && redos != 0) {
				io->cb_printf ("# Current undo/redo position.\n");
			} else if (j != undos) {
				io->cb_printf ("f redo_%d @ 0x%"PFMT64x"\n", idx, addr);
			}
			break;
		case 0:
			if (list) {
				RIOUndos *u = R_NEW0 (RIOUndos);
				if (u) {
					if (!(j == undos && redos == 0)) {
						memcpy (u, undo, sizeof (RIOUndos));
					} else {
						u->off = io->off;
					}
					r_list_append (list, u);
				}
			}
			break;
		}
		j++;
		if (i == end) {
			break;
		}
	}
	switch (mode) {
	case '=':
		io->cb_printf ("\n");
		break;
	}
	return list;
}
