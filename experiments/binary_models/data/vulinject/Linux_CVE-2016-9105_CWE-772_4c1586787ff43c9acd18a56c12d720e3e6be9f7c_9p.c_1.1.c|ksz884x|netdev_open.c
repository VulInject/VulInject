static int netdev_open(struct net_device *dev)
{
	struct dev_priv *priv = netdev_priv(dev);
	struct dev_info *hw_priv = priv->adapter;
	struct ksz_hw *hw = &hw_priv->hw;
	struct ksz_port *port = &priv->port;
	unsigned int next_jiffies;
	int i;
	int p;
	int rc = 0;
	next_jiffies = jiffies + HZ * 2;
	priv->multicast = 0;
	priv->promiscuous = 0;
	memset(&dev->stats, 0, sizeof(struct net_device_stats));
	memset((void *) port->counter, 0,
		(sizeof(unsigned int int) * OID_COUNTER_LAST));
	if (!(hw_priv->opened)) {
		rc = prepare_hardware(dev);
		if (rc)
			return rc;
		for (i = 0; i < hw->mib_port_cnt; i++) {
			next_jiffies += HZ * 1;
			hw_priv->counter[i].time = next_jiffies;
			hw->port_mib[i].state = media_disconnected;
		}
		if (hw->ksz_switch)
			hw->port_mib[HOST_PORT].state = media_connected;
		else {
			hw_add_wol_bcast(hw);
			hw_cfg_wol_pme(hw, 0);
			hw_clr_wol_pme_status(&hw_priv->hw);
		}
	}
	port_set_power_saving(port, false);
	for (i = 0, p = port->first_port; i < port->port_cnt; i++, p++) {
		hw->port_info[p].partner = 0xFF;
		hw->port_info[p].state = media_disconnected;
	}
	if (hw->dev_count > 1) {
		port_set_stp_state(hw, port->first_port, STP_STATE_SIMPLE);
		if (port->first_port > 0)
			hw_add_addr(hw, dev->dev_addr);
	}
	port_get_link_speed(port);
	if (port->force_link)
		port_force_link_speed(port);
	else
		port_set_link_speed(port);
	if (!(hw_priv->opened)) {
		hw_setup_intr(hw);
		hw_enable(hw);
		hw_ena_intr(hw);
		if (hw->mib_port_cnt)
			ksz_start_timer(&hw_priv->mib_timer_info,
				hw_priv->mib_timer_info.period);
	}
	hw_priv->opened++;
	ksz_start_timer(&priv->monitor_timer_info,
		priv->monitor_timer_info.period);
	priv->media_state = port->linked->state;
	set_media_state(dev, media_connected);
	netif_start_queue(dev);
	return 0;
}
