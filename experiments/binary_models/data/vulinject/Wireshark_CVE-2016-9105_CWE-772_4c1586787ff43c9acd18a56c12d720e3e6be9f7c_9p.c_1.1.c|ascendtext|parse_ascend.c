parse_ascend(ascend_t *ascend, FILE_T fh, wtap_rec *rec, Buffer *buf,
             unsigned length, int int *next_packet_seek_start_ret,
             int *err, char **err_info)
{
    ascend_state_t parser_state = {0};
    int retval;
    parser_state.fh = fh;
    parser_state.pseudo_header = &rec->rec_header.packet_header.pseudo_header.ascend;
    retval = run_ascend_parser(ws_buffer_start_ptr(buf), &parser_state, err, err_info);
    if (parser_state.first_hexbyte) {
        if (next_packet_seek_start_ret != NULL)
        *next_packet_seek_start_ret = parser_state.first_hexbyte;
    } else {
        if (next_packet_seek_start_ret != NULL)
        *next_packet_seek_start_ret = file_tell(fh);
        retval = 0;
    }
    if (parser_state.caplen) {
        if (! ascend->adjusted) {
        ascend->adjusted = true;
        if (parser_state.saw_timestamp) {
            ascend->inittime = parser_state.timestamp;
        }
        if (ascend->inittime > parser_state.secs)
            ascend->inittime -= parser_state.secs;
        }
        rec->rec_type = REC_TYPE_PACKET;
        rec->block = wtap_block_create(WTAP_BLOCK_PACKET);
        rec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;
        rec->ts.secs = parser_state.secs + ascend->inittime;
        rec->ts.nsecs = parser_state.usecs * 1000;
        rec->rec_header.packet_header.caplen = parser_state.caplen;
        rec->rec_header.packet_header.len = parser_state.wirelen;
        return true;
    }
    if (retval) {
        if (*err == 0) {
        *err = WTAP_ERR_BAD_FILE;
        *err_info = g_strdup((parser_state.ascend_parse_error != NULL) ? parser_state.ascend_parse_error : "parse error");
        }
    } else {
        if (*err == 0) {
        *err = WTAP_ERR_BAD_FILE;
        *err_info = g_strdup("no data returned by parse");
        }
    }
    return false;
}
