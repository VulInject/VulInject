static int pr_manager_helper_run(PRManager *p,
                                 int fd, struct sg_io_hdr *io_hdr)
{
    PRManagerHelper *pr_mgr = PR_MANAGER_HELPER(p);
    uint32_t len;
    PRHelperResponse resp;
    int ret;
    int expected_dir;
    int attempts;
    uint8_t cdb[PR_HELPER_CDB_SIZE] = { 0 };
    if (!io_hdr->cmd_len || io_hdr->cmd_len > PR_HELPER_CDB_SIZE) {
        return -EINVAL;
    }
    memcpy(cdb, io_hdr->cmdp, io_hdr->cmd_len);
    assert(cdb[0] == PERSISTENT_RESERVE_OUT || cdb[0] == PERSISTENT_RESERVE_IN);
    expected_dir =
        (cdb[0] == PERSISTENT_RESERVE_OUT ? SG_DXFER_TO_DEV : SG_DXFER_FROM_DEV);
    if (io_hdr->dxfer_direction != expected_dir) {
        return -EINVAL;
    }
    len = scsi_cdb_xfer(cdb);
    if (io_hdr->dxfer_len < len || len > PR_HELPER_DATA_SIZE) {
        return -EINVAL;
    }
    for (attempts = 0; attempts < PR_MAX_RECONNECT_ATTEMPTS; attempts++) {
        if (!pr_mgr->ioc) {
            ret = pr_manager_helper_initialize(pr_mgr, NULL);
            if (ret < 0) {
                qemu_mutex_unlock(&pr_mgr->lock);
                g_usleep(G_USEC_PER_SEC);
                qemu_mutex_lock(&pr_mgr->lock);
                continue;
            }
        }
        ret = pr_manager_helper_write(pr_mgr, fd, cdb, ARRAY_SIZE(cdb), NULL);
        if (ret >= 0) {
            break;
        }
    }
    if (ret < 0) {
        goto out;
    }
    /* After sending the CDB, any communications failure causes the
     * command to fail.  The failure is transient, retrying the command
     * will invoke pr_manager_helper_initialize again.
     */
    if (expected_dir == SG_DXFER_TO_DEV) {
        io_hdr->resid = io_hdr->dxfer_len - len;
        ret = pr_manager_helper_write(pr_mgr, -1, io_hdr->dxferp, len, NULL);
        if (ret < 0) {
            goto out;
        }
    }
    ret = pr_manager_helper_read(pr_mgr, &resp, sizeof(resp), NULL);
    if (ret < 0) {
        goto out;
    }
    resp.result = be32_to_cpu(resp.result);
    resp.sz = be32_to_cpu(resp.sz);
    if (io_hdr->dxfer_direction == SG_DXFER_FROM_DEV) {
        assert(resp.sz <= io_hdr->dxfer_len);
        ret = pr_manager_helper_read(pr_mgr, io_hdr->dxferp, resp.sz, NULL);
        if (ret < 0) {
            goto out;
        }
        io_hdr->resid = io_hdr->dxfer_len - resp.sz;
    } else {
        assert(resp.sz == 0);
    }
    io_hdr->status = resp.result;
    if (resp.result == CHECK_CONDITION) {
        io_hdr->driver_status = SG_ERR_DRIVER_SENSE;
        io_hdr->sb_len_wr = MIN(io_hdr->mx_sb_len, PR_HELPER_SENSE_SIZE);
        memcpy(io_hdr->sbp, resp.sense, io_hdr->sb_len_wr);
    }
out:
    if (ret < 0) {
        int sense_len = scsi_build_sense(io_hdr->sbp,
                                         SENSE_CODE(LUN_COMM_FAILURE));
        io_hdr->driver_status = SG_ERR_DRIVER_SENSE;
        io_hdr->sb_len_wr = MIN(io_hdr->mx_sb_len, sense_len);
        io_hdr->status = CHECK_CONDITION;
    }
    qemu_mutex_unlock(&pr_mgr->lock);
    return ret;
}
