static int vp4_unpack_dct_coeffs(Vp3DecodeContext *s, GetBitContext *gb)
{
    const VLCElem *const *coeff_vlc = s->coeff_vlc->vlc_tabs;
    int dc_y_table;
    int dc_c_table;
    int ac_y_table;
    int ac_c_table;
    const VLCElem *tables[2][64];
    int eob_tracker[64];
    VP4Predictor dc_pred[6][6];
    int last_dc[NB_VP4_DC_TYPES];
    if (get_bits_left(gb) < 16)
        return AVERROR_INVALIDDATA;
    /* fetch the DC table indexes */
    dc_y_table = get_bits(gb, 4);
    dc_c_table = get_bits(gb, 4);
    ac_y_table = get_bits(gb, 4);
    ac_c_table = get_bits(gb, 4);
    /* build tables of DC/AC VLC tables */
    /* DC table group */
    tables[0][0] = coeff_vlc[dc_y_table];
    tables[1][0] = coeff_vlc[dc_c_table];
    for (int i = 1; i <= 5; i++) {
        /* AC VLC table group 1 */
        tables[0][i] = coeff_vlc[ac_y_table + 16];
        tables[1][i] = coeff_vlc[ac_c_table + 16];
    }
    for (int i = 6; i <= 14; i++) {
        /* AC VLC table group 2 */
        tables[0][i] = coeff_vlc[ac_y_table + 32];
        tables[1][i] = coeff_vlc[ac_c_table + 32];
    }
    for (int i = 15; i <= 27; i++) {
        /* AC VLC table group 3 */
        tables[0][i] = coeff_vlc[ac_y_table + 48];
        tables[1][i] = coeff_vlc[ac_c_table + 48];
    }
    for (int i = 28; i <= 63; i++) {
        /* AC VLC table group 4 */
        tables[0][i] = coeff_vlc[ac_y_table + 64];
        tables[1][i] = coeff_vlc[ac_c_table + 64];
    }
    memset(last_dc, 0, sizeof(last_dc));
    for (int plane = 0; plane < ((s->avctx->flags & AV_CODEC_FLAG_GRAY) ? 1 : 3); plane++) {
        memset(eob_tracker, 0, sizeof(eob_tracker));
        /* initialise dc prediction */
        for (int i = 0; i < s->fragment_width[!!plane]; i++)
            vp4_dc_predictor_reset(&s->dc_pred_row[i]);
        for (int j = 0; j < 6; j++)
            for (int i = 0; i < 6; i++)
                vp4_dc_predictor_reset(&dc_pred[j][i]);
        for (int sb_y = 0; sb_y * 4 < s->fragment_height[!!plane]; sb_y++) {
            for (int sb_x = 0; sb_x *4 < s->fragment_width[!!plane]; sb_x++) {
                vp4_dc_pred_before(s, dc_pred, sb_x);
                for (int j = 0; j < 16; j++) {
                        int hx = hilbert_offset[j][0];
                        int hy = hilbert_offset[j][1];
                        int x  = 4 * sb_x + hx;
                        int y  = 4 * sb_y + hy;
                        VP4Predictor *this_dc_pred = &dc_pred[hy + 1][hx + 1];
                        int fragment, dc_block_type;
                        if (x >= s->fragment_width[!!plane] || y >= s->fragment_height[!!plane])
                            continue;
                        fragment = s->fragment_start[plane] + y * s->fragment_width[!!plane] + x;
                        if (s->all_fragments[fragment].coding_method == MODE_COPY)
                            continue;
                        if (vp4_unpack_vlcs(s, gb, tables[!!plane], plane, eob_tracker, fragment) < 0)
                            return -1;
                        dc_block_type = vp4_pred_block_type_map[s->all_fragments[fragment].coding_method];
                        s->all_fragments[fragment].dc +=
                            vp4_dc_pred(s, this_dc_pred, last_dc, dc_block_type, plane);
                        this_dc_pred->type = dc_block_type,
                        this_dc_pred->dc   = last_dc[dc_block_type] = s->all_fragments[fragment].dc;
                }
                vp4_dc_pred_after(s, dc_pred, sb_x);
            }
        }
    }
    vp4_set_tokens_base(s);
    return 0;
}
