dissect_nt_create_andx_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, proto_tree *smb_tree, smb_info_t *si)
{
	guint8          wc, cmd    = 0xff;
	guint16         andxoffset = 0;
	guint16         bc;
	guint16         fid        = 0;
	guint16         ftype;
	guint8          isdir;
	smb_fid_info_t *fid_info   = NULL;
	WORD_COUNT;
	cmd = tvb_get_guint8(tvb, offset);
	if (cmd != 0xff) {
		proto_tree_add_uint(tree, hf_smb_andxcmd, tvb, offset, 1, cmd);
	} else {
		proto_tree_add_uint_format_value(tree, hf_smb_andxcmd, tvb, offset, 1, cmd, "No further commands (0xff)");
	}
	offset += 1;
	proto_tree_add_item(tree, hf_smb_reserved, tvb, offset, 1, ENC_NA);
	offset += 1;
	andxoffset = tvb_get_letohs(tvb, offset);
	proto_tree_add_uint(tree, hf_smb_andxoffset, tvb, offset, 2, andxoffset);
	offset += 2;
	proto_tree_add_item(tree, hf_smb_oplock_level, tvb, offset, 1, ENC_LITTLE_ENDIAN);
	offset += 1;
	fid = tvb_get_letohs(tvb, offset);
	fid_info = dissect_smb_fid(tvb, pinfo, tree, offset, 2, fid, TRUE, FALSE, FALSE, si);
	offset += 2;
	proto_tree_add_item(tree, hf_smb_create_action, tvb, offset, 4, ENC_LITTLE_ENDIAN);
	offset += 4;
	offset = dissect_nt_64bit_time(tvb, tree, offset, hf_smb_create_time);
	offset = dissect_nt_64bit_time(tvb, tree, offset, hf_smb_access_time);
	offset = dissect_nt_64bit_time(tvb, tree, offset,
		hf_smb_last_write_time);
	offset = dissect_nt_64bit_time(tvb, tree, offset, hf_smb_change_time);
	offset = dissect_file_ext_attr(tvb, tree, offset);
	proto_tree_add_item(tree, hf_smb_alloc_size64, tvb, offset, 8, ENC_LITTLE_ENDIAN);
	offset += 8;
	if (fid_info) {
		fid_info->end_of_file = tvb_get_letoh64(tvb, offset);
	}
	proto_tree_add_item(tree, hf_smb_end_of_file, tvb, offset, 8, ENC_LITTLE_ENDIAN);
	offset += 8;
	ftype = tvb_get_letohs(tvb, offset);
	proto_tree_add_item(tree, hf_smb_file_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);
	offset += 2;
	offset = dissect_ipc_state(tvb, tree, offset, FALSE);
	isdir = tvb_get_guint8(tvb, offset);
	proto_tree_add_item(tree, hf_smb_is_directory, tvb, offset, 1, ENC_LITTLE_ENDIAN);
	offset += 1;
	if (wc >= 42) {
		proto_tree *tr = NULL;
		proto_tree_add_item(tree, hf_smb_volume_guid,
				    tvb, offset, 16, ENC_NA);
		offset += 16;
		proto_tree_add_item(tree, hf_smb_file_id_64bit,
				    tvb, offset, 8, ENC_LITTLE_ENDIAN);
		offset += 8;
		tr = proto_tree_add_subtree(tree, tvb, offset, 4,
					  ett_smb_nt_access_mask, NULL, "Maximal Access Rights");
		offset = dissect_smb_access_mask(tvb, tr, offset);
		tr = proto_tree_add_subtree(tree, tvb, offset, 4,
					   ett_smb_nt_access_mask, NULL, "Guest Maximal Access Rights");
		offset = dissect_smb_access_mask(tvb, tr, offset);
	}
	if (ftype == 0) {
		if (isdir == 0) {
			if (fid_info) {
				fid_info->type = SMB_FID_TYPE_FILE;
			}
		} else {
			if (fid_info) {
				fid_info->type = SMB_FID_TYPE_DIR;
			}
		}
	}
	if (ftype == 2) {
		if (fid_info) {
			fid_info->type = SMB_FID_TYPE_PIPE;
		}
	}
	BYTE_COUNT;
	END_OF_SMB
	if (cmd != 0xff) { 	
		if (andxoffset < offset)
		dissect_smb_command(tvb, pinfo, andxoffset, smb_tree, cmd, FALSE, si);
	}
	if (si->nt_status) {
		dissect_smb_fid(tvb, pinfo, tree, 0, 0, fid, TRUE, TRUE, TRUE, si);
	}
	return offset;
}
