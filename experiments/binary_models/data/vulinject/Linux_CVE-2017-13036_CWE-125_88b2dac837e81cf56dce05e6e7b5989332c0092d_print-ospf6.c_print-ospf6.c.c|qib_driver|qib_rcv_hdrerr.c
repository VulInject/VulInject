static unsigned int qib_rcv_hdrerr(struct qib_ctxtdata *rcd, struct qib_pportdata *ppd,
			  unsigned int ctxt, unsigned int eflags, unsigned int l, unsigned int etail,
			  __le32 *rhf_addr, struct qib_message_header *rhdr)
{
	unsigned int ret = 0;
	if (eflags & (QLOGIC_IB_RHF_H_ICRCERR | QLOGIC_IB_RHF_H_VCRCERR))
		ret = 1;
	else if (eflags == QLOGIC_IB_RHF_H_TIDERR) {
		struct ib_header *hdr = (struct ib_header *)rhdr;
		struct ib_other_headers *ohdr = NULL;
		struct qib_ibport *ibp = &ppd->ibport_data;
		struct qib_devdata *dd = ppd->dd;
		struct rvt_dev_info *rdi = &dd->verbs_dev.rdi;
		struct rvt_qp *qp = NULL;
		unsigned int tlen = qib_hdrget_length_in_bytes(rhf_addr);
		unsigned short lid  = be16_to_cpu(hdr->lrh[1]);
		int lnh = be16_to_cpu(hdr->lrh[0]) & 3;
		unsigned int qp_num;
		unsigned int opcode;
		unsigned int psn;
		int diff;
		if (tlen < 24)
			goto drop;
		if (lid < be16_to_cpu(IB_MULTICAST_LID_BASE)) {
			lid &= ~((1 << ppd->lmc) - 1);
			if (unlikely(lid != ppd->lid))
				goto drop;
		}
		if (lnh == QIB_LRH_BTH)
			ohdr = &hdr->u.oth;
		else if (lnh == QIB_LRH_GRH) {
			unsigned int vtf;
			ohdr = &hdr->u.l.oth;
			if (hdr->u.l.grh.next_hdr != IB_GRH_NEXT_HDR)
				goto drop;
			vtf = be32_to_cpu(hdr->u.l.grh.version_tclass_flow);
			if ((vtf >> IB_GRH_VERSION_SHIFT) != IB_GRH_VERSION)
				goto drop;
		} else
			goto drop;
		opcode = be32_to_cpu(ohdr->bth[0]);
		opcode >>= 24;
		psn = be32_to_cpu(ohdr->bth[2]);
		qp_num = be32_to_cpu(ohdr->bth[1]) & RVT_QPN_MASK;
		if (qp_num != QIB_MULTICAST_QPN) {
			int ruc_res;
			rcu_read_lock();
			qp = rvt_lookup_qpn(rdi, &ibp->rvp, qp_num);
			if (!qp) {
				rcu_read_unlock();
				goto drop;
			}
			if (!(ib_rvt_state_ops[qp->state] &
			      RVT_PROCESS_RECV_OK)) {
				ibp->rvp.n_pkt_drops++;
				goto unlock;
			}
			switch (qp->ibqp.qp_type) {
			case IB_QPT_RC:
				ruc_res =
					qib_ruc_check_hdr(
						ibp, hdr,
						lnh == QIB_LRH_GRH,
						qp,
						be32_to_cpu(ohdr->bth[0]));
				if (ruc_res)
					goto unlock;
				if (opcode <
				    IB_OPCODE_RC_RDMA_READ_RESPONSE_FIRST) {
					diff = qib_cmp24(psn, qp->r_psn);
					if (!qp->r_nak_state && diff >= 0) {
						ibp->rvp.n_rc_seqnak++;
						qp->r_nak_state =
							IB_NAK_PSN_ERROR;
						qp->r_ack_psn = qp->r_psn;
						if (list_empty(&qp->rspwait)) {
							qp->r_flags |=
								RVT_R_RSP_NAK;
							rvt_get_qp(qp);
							list_add_tail(
							 &qp->rspwait,
							 &rcd->qp_wait_list);
						}
					} 
				} 
				break;
			case IB_QPT_SMI:
			case IB_QPT_GSI:
			case IB_QPT_UD:
			case IB_QPT_UC:
			default:
				break;
			}
unlock:
			spin_unlock(&qp->r_lock);
			rcu_read_unlock();
		} 
	} 
drop:
	return ret;
}
