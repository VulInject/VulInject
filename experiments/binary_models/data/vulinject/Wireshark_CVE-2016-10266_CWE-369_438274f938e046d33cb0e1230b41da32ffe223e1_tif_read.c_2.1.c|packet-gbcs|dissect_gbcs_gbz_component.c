static void dissect_gbcs_gbz_component(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint *offset, guint component_index)
{
    proto_item *ti;
    proto_tree *component_tree;
    guint32 component_len;
    guint32 cluster;
    gboolean fromdatetime_present;
    gboolean encryption_present;
    guint32 extended_header_control;
    if (component_index > GBCS_GBZ_MAX_COMPONENTS - 1) {
        component_index = GBCS_GBZ_MAX_COMPONENTS - 1;
    }
    component_tree = proto_tree_add_subtree(tree, tvb, *offset, 1, ett_gbcs_gbz_components[component_index], &ti, "Use Case Component");
    proto_tree_add_item_ret_uint(component_tree, hf_gbcs_gbz_extended_header_control, tvb, *offset, 1, ENC_NA, &extended_header_control);
    fromdatetime_present = extended_header_control & GBCS_GBZ_EXTENDED_HEADER_CONTROL_FROM_DATE_TIME_PRESENT;
    encryption_present = extended_header_control & GBCS_GBZ_EXTENDED_HEADER_CONTROL_ENCRYPTED_COMPONENT;
    *offset += 1;
    proto_tree_add_item_ret_uint(component_tree, hf_gbcs_gbz_extended_header_cluster, tvb, *offset, 2, ENC_BIG_ENDIAN, &cluster);
    *offset += 2;
    proto_tree_add_item_ret_uint(component_tree, hf_gbcs_gbz_extended_header_length, tvb, *offset, 2, ENC_BIG_ENDIAN, &component_len);
    *offset += 2;
    if ((gint)component_len > tvb_reported_length_remaining(tvb, *offset)) {
        expert_add_info(pinfo, tree, &ei_gbcs_gbz_invalid_length);
    }
    if (fromdatetime_present) {
        proto_tree_add_item(component_tree, hf_gbcs_gbz_from_date_time, tvb, *offset, 4, ENC_TIME_ZBEE_ZCL|ENC_BIG_ENDIAN);
        *offset += 4;
        component_len -= 4;
    }
    if (encryption_present) {
        proto_tree_add_item(component_tree, hf_gbcs_gbz_additional_header_control, tvb, *offset, 1, ENC_NA);
        *offset += 1;
        component_len -= 1;
        proto_tree_add_item(component_tree, hf_gbcs_gbz_additional_frame_counter, tvb, *offset, 1, ENC_NA);
        *offset += 1;
        component_len -= 1;
    }
    proto_tree_add_item(component_tree, hf_gbcs_gbz_frame_control, tvb, *offset, 1, ENC_NA);
    *offset += 1;
    component_len -= 1;
    proto_tree_add_item(component_tree, hf_gbcs_gbz_transaction, tvb, *offset, 1, ENC_NA);
    *offset += 1;
    component_len -= 1;
    proto_tree_add_item(component_tree, hf_gbcs_gbz_command_id, tvb, *offset, 1, ENC_NA);
    *offset += 1;
    component_len -= 1;
    if (encryption_present) {
        proto_tree_add_item(component_tree, hf_gbcs_gbz_length_of_ciphered_information, tvb, *offset, 2, ENC_BIG_ENDIAN);
        *offset += 2;
        component_len -= 2;
        proto_tree_add_item(component_tree, hf_gbcs_gbz_security_control, tvb, *offset, 1, ENC_NA);
        *offset += 1;
        component_len -= 1;
        proto_tree_add_item(component_tree, hf_gbcs_gbz_invocation_counter, tvb, *offset, 4, ENC_BIG_ENDIAN);
        *offset += 4;
        component_len -= 4;
        if (component_len < GBCS_GBZ_MAC_LENGTH) {
            expert_add_info(pinfo, tree, &ei_gbcs_gbz_invalid_length);
        }
        proto_tree_add_item(component_tree, hf_gbcs_gbz_encrypted_payload, tvb, *offset, component_len - GBCS_GBZ_MAC_LENGTH, ENC_NA);
        *offset += component_len - GBCS_GBZ_MAC_LENGTH;
        proto_tree_add_item(component_tree, hf_gbcs_gbz_mac, tvb, *offset, GBCS_GBZ_MAC_LENGTH, ENC_NA);
        *offset += GBCS_GBZ_MAC_LENGTH;
    }
    else if (zcl_handle) {
        zbee_nwk_packet nwk;
        tvbuff_t *payload_tvb;
        const gchar *text;
        wmem_strbuf_t *strbuf;
	text=((pinfo->cinfo+COL_INFO-1)/COL_INFO);
        if (text) {
            strbuf = wmem_strbuf_new(pinfo->pool, text);
        }
        nwk.cluster_id = cluster;
        payload_tvb = tvb_new_subset_length(tvb, *offset - 3, component_len + 3);
        call_dissector_with_data(zcl_handle, payload_tvb, pinfo, component_tree, &nwk);
        if (text) {
            col_add_str(pinfo->cinfo, COL_INFO, wmem_strbuf_get_str(strbuf));
        }
        *offset += component_len;
    }
    proto_item_set_end(ti, tvb, *offset);
}
