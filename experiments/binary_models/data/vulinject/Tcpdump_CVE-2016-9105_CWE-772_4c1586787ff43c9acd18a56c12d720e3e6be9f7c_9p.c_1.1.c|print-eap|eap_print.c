eap_print(netdissect_options *ndo,
          const u_char *cp,
          const u_int length)
{
    u_int type, subtype, len;
    u_int count;
    const char *sep;
    ndo->ndo_protocol = "eap";
    type = GET_U_1(cp);
    len = GET_BE_U_2(cp + 2);
    ND_ICHECK_U(len, <, 4);
    if (len != length) {
        ND_PRINT("EAP fragment?");
        return;
    }
    ND_PRINT("%s (%u), id %u, len %u",
            tok2str(eap_code_values, "unknown", type),
            type,
            GET_U_1((cp + 1)),
            len);
    if (type == EAP_REQUEST || type == EAP_RESPONSE) {
        ND_ICHECK_U(len, <, 5);
        subtype = GET_U_1(cp + 4);
        ND_PRINT("\n\t\t Type %s (%u)",
                tok2str(eap_type_values, "unknown", subtype),
                subtype);
        switch (subtype) {
            case EAP_TYPE_IDENTITY:
                if (len > 5) {
                    ND_PRINT(", Identity: ");
                    nd_printjnp(ndo, cp + 5, len - 5);
                }
                break;
            case EAP_TYPE_NOTIFICATION:
                ND_ICHECK_U(len, <, 6);
                ND_PRINT(", Notification: ");
                nd_printjnp(ndo, cp + 5, len - 5);
                break;
            case EAP_TYPE_NAK:
                ND_ICHECK_U(len, <, 6);
                sep = "";
                for (count = 5; count < len; count++) {
                    ND_PRINT("%s %s (%u)", sep,
                           tok2str(eap_type_values, "unknown", GET_U_1((cp + count))),
                           GET_U_1(cp + count));
                    sep = ",";
                }
                break;
            case EAP_TYPE_TTLS:
            case EAP_TYPE_TLS:
                ND_ICHECK_U(len, <, 6);
                if (subtype == EAP_TYPE_TTLS)
                    ND_PRINT(" TTLSv%u",
                           EAP_TTLS_VERSION(GET_U_1((cp + 5))));
                ND_PRINT(" flags [%s] 0x%02x",
                       bittok2str(eap_tls_flags_values, "none", GET_U_1((cp + 5))),
                       GET_U_1(cp + 5));
                if (EAP_TLS_EXTRACT_BIT_L(GET_U_1(cp + 5))) {
                    ND_ICHECK_U(len, <, 10);
                    ND_PRINT(", len %u", GET_BE_U_4(cp + 6));
                }
                break;
            case EAP_TYPE_FAST:
                ND_ICHECK_U(len, <, 6);
                ND_PRINT(" FASTv%u",
                       EAP_TTLS_VERSION(GET_U_1((cp + 5))));
                ND_PRINT(" flags [%s] 0x%02x",
                       bittok2str(eap_tls_flags_values, "none", GET_U_1((cp + 5))),
                       GET_U_1(cp + 5));
                if (EAP_TLS_EXTRACT_BIT_L(GET_U_1(cp + 5))) {
                    ND_ICHECK_U(len, <, 10);
                    ND_PRINT(", len %u", GET_BE_U_4(cp + 6));
                }
                break;
            case EAP_TYPE_AKA:
            case EAP_TYPE_SIM:
                ND_ICHECK_U(len, <, 6);
                ND_PRINT(" subtype [%s] 0x%02x",
                       tok2str(eap_aka_subtype_values, "unknown", GET_U_1((cp + 5))),
                       GET_U_1(cp + 5));
                break;
            case EAP_TYPE_MD5_CHALLENGE:
            case EAP_TYPE_OTP:
            case EAP_TYPE_GTC:
            case EAP_TYPE_EXPANDED_TYPES:
            case EAP_TYPE_EXPERIMENTAL:
            default:
                break;
        }
    }
    return;
invalid:
    nd_print_invalid(ndo);
}
