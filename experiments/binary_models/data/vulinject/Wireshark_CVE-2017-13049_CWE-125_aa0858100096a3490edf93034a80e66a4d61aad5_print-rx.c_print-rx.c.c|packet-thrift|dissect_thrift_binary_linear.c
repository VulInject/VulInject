dissect_thrift_binary_linear(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int *offset, thrift_option_data_t *thrift_opt, thrift_type_enum_t expected)
{
    proto_tree *sub_tree;
    proto_item *container_pi, *len_pi, *vtype_pi;
    proto_item *ktype_pi = NULL; 
    gint32 ktype, vtype;
    gint32 container_len, i;
    int ett = -1;
    int hf_container = -1;
    int hf_num_item = -1;
    int hf_vtype = hf_thrift_type;
    int min_len = TBP_THRIFT_LINEAR_LEN;
    guint nested_count = p_get_proto_depth(pinfo, proto_thrift);
    switch (expected) {
        case DE_THRIFT_T_SET:
            ett = ett_thrift_set;
            hf_container = hf_thrift_set;
            hf_num_item = hf_thrift_num_set_item;
            break;
        case DE_THRIFT_T_LIST:
            ett = ett_thrift_list;
            hf_container = hf_thrift_list;
            hf_num_item = hf_thrift_num_list_item;
            break;
        case DE_THRIFT_T_MAP:
            ett = ett_thrift_map;
            hf_container = hf_thrift_map;
            hf_num_item = hf_thrift_num_map_item;
            hf_vtype = hf_thrift_value_type; 
            min_len += TBP_THRIFT_TYPE_LEN; 
            break;
        default:
            REPORT_DISSECTOR_BUG("dissect_thrift_binary_linear called with something else than a container type.");
            break;
    }
    if (nested_count >= thrift_opt->nested_type_depth) {
        expert_add_info(pinfo, proto_tree_get_parent(tree), &ei_thrift_too_many_subtypes);
        return THRIFT_REQUEST_REASSEMBLY;
    }
    p_set_proto_depth(pinfo, proto_thrift, nested_count + 1);
    container_pi = proto_tree_add_item(tree, hf_container, tvb, *offset, -1, ENC_NA);
    sub_tree = proto_item_add_subtree(container_pi, ett);
    if (expected == DE_THRIFT_T_MAP) {
        ktype_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_key_type, tvb, *offset, TBP_THRIFT_TYPE_LEN, ENC_BIG_ENDIAN, &ktype);
        *offset += TBP_THRIFT_TYPE_LEN;
    }
    vtype_pi = proto_tree_add_item_ret_uint(sub_tree, hf_vtype, tvb, *offset, TBP_THRIFT_TYPE_LEN, ENC_BIG_ENDIAN, &vtype);
    *offset += TBP_THRIFT_TYPE_LEN;
    len_pi = proto_tree_add_item_ret_int(sub_tree, hf_num_item, tvb, *offset, TBP_THRIFT_LENGTH_LEN, ENC_BIG_ENDIAN, &container_len);
    *offset += TBP_THRIFT_LENGTH_LEN;
    if (container_len < 0) {
        expert_add_info(pinfo, len_pi, &ei_thrift_negative_length);
        return THRIFT_REQUEST_REASSEMBLY;
    }
    for (i = 0; i < container_len; ++i) {
        if (expected == DE_THRIFT_T_MAP) {
            if (dissect_thrift_binary_type(tvb, pinfo, sub_tree, offset, thrift_opt, NULL, ktype, ktype_pi) == THRIFT_REQUEST_REASSEMBLY)
                return THRIFT_REQUEST_REASSEMBLY;
        }
        if (dissect_thrift_binary_type(tvb, pinfo, sub_tree, offset, thrift_opt, NULL, vtype, vtype_pi) == THRIFT_REQUEST_REASSEMBLY)
            return THRIFT_REQUEST_REASSEMBLY;
    }
    proto_item_set_end(container_pi, tvb, *offset);
    p_set_proto_depth(pinfo, proto_thrift, nested_count);
    return *offset;
}
