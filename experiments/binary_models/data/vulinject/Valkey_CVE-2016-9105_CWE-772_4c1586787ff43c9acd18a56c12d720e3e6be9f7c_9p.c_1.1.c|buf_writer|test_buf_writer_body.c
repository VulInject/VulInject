test_buf_writer_body(tsdn_t *tsdn, buf_writer_t *buf_writer) {
	char s[UNIT_MAX + 1];
	size_t n_unit, remain, i;
	ssize_t unit;
	assert(buf_writer->buf != NULL);
	memset(s, 'a', UNIT_MAX);
	arg = 4; /* Starting value of random argument. */
	arg_store = arg;
	for (unit = UNIT_MAX; unit >= 0; --unit) {
		/* unit keeps decreasing, so strlen(s) is always unit. */
		s[unit] = '\0';
		for (n_unit = 1; n_unit <= 3; ++n_unit) {
			test_write_len = 0;
			remain = 0;
			for (i = 1; i <= n_unit; ++i) {
				arg = prng_lg_range_u64(&arg, 64);
				remain += unit;
				if (remain > buf_writer->buf_size) {
					/* Flushes should have happened. */
					assert_u64_eq(arg_store, arg, "Call "
					    "back argument didn't get through");
					remain %= buf_writer->buf_size;
					if (remain == 0) {
						/* Last flush should be lazy. */
						remain += buf_writer->buf_size;
					}
				}
				assert_zu_eq(test_write_len + remain, i * unit,
				    "Incorrect length after writing %zu strings"
				    " of length %zu", i, unit);
			}
			buf_writer_flush(buf_writer);
			expect_zu_eq(test_write_len, n_unit * unit,
			    "Incorrect length after flushing at the end of"
			    " writing %zu strings of length %zu", n_unit, unit);
		}
	}
	buf_writer_terminate(tsdn, buf_writer);
}
