static int __choose_mds(struct ceph_mds_client *mdsc,
			struct ceph_mds_request *req,
			bool *random)
{
	struct inode *inode;
	struct ceph_inode_info *ci;
	struct ceph_cap *cap;
	int mode = req->r_direct_mode;
	int mds = -1;
	unsigned int hash = req->r_direct_hash;
	bool is_hash = test_bit(CEPH_MDS_R_DIRECT_IS_HASH, &req->r_req_flags);
	struct ceph_client *cl = mdsc->fsc->client;
	if (random)
		*random = false;
	if (req->r_resend_mds >= 0 &&
	    (__have_session(mdsc, req->r_resend_mds) ||
	     ceph_mdsmap_get_state(mdsc->mdsmap, req->r_resend_mds) > 0)) {
		doutc(cl, "using resend_mds mds%d\n", req->r_resend_mds);
		return req->r_resend_mds;
	}
	if (mode == USE_RANDOM_MDS)
		goto random;
	inode = NULL;
	if (req->r_inode) {
		if (ceph_snap(req->r_inode) != CEPH_SNAPDIR) {
			inode = req->r_inode;
			ihold(inode);
		} else {
			rcu_read_lock();
			inode = get_nonsnap_parent(req->r_dentry);
			rcu_read_unlock();
			doutc(cl, "using snapdir's parent %p %llx.%llx\n",
			      inode, ceph_vinop(inode));
		}
	} else if (req->r_dentry) {
		struct dentry *parent;
		struct inode *dir;
		rcu_read_lock();
		parent = READ_ONCE(req->r_dentry->d_parent);
		dir = req->r_parent ? : d_inode_rcu(parent);
		if (!dir || dir->i_sb != mdsc->fsc->sb) {
			inode = d_inode(req->r_dentry);
			if (inode)
				ihold(inode);
		} else if (ceph_snap(dir) != CEPH_NOSNAP) {
			inode = get_nonsnap_parent(parent);
			doutc(cl, "using nonsnap parent %p %llx.%llx\n",
			      inode, ceph_vinop(inode));
		} else {
			inode = d_inode(req->r_dentry);
			if (!inode || mode == USE_AUTH_MDS) {
				inode = igrab(dir);
				hash = ceph_dentry_hash(dir, req->r_dentry);
				is_hash = true;
			} else {
				ihold(inode);
			}
		}
		rcu_read_unlock();
	}
	if (!inode)
		goto random;
	doutc(cl, "%p %llx.%llx is_hash=%d (0x%x) mode %d\n", inode,
	      ceph_vinop(inode), (int)is_hash, hash, mode);
	ci = ceph_inode(inode);
	if (is_hash && S_ISDIR(inode->i_mode)) {
		struct ceph_inode_frag frag;
		int found;
		ceph_choose_frag(ci, hash, &frag, &found);
		if (found) {
			if (mode == USE_ANY_MDS && frag.ndist > 0) {
				unsigned char r;
				get_random_bytes(&r, 1);
				r %= frag.ndist;
				mds = frag.dist[r];
				doutc(cl, "%p %llx.%llx frag %u mds%d (%d/%d)\n",
				      inode, ceph_vinop(inode), frag.frag,
				      mds, (int)r, frag.ndist);
				if (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=
				    CEPH_MDS_STATE_ACTIVE &&
				    !ceph_mdsmap_is_laggy(mdsc->mdsmap, mds))
					goto out;
			}
			if (frag.mds >= 0) {
				mds = frag.mds;
				doutc(cl, "%p %llx.%llx frag %u mds%d (auth)\n",
				      inode, ceph_vinop(inode), frag.frag, mds);
				if (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=
				    CEPH_MDS_STATE_ACTIVE) {
					if (!ceph_mdsmap_is_laggy(mdsc->mdsmap,
								  mds))
						goto out;
				}
			}
			mode = USE_AUTH_MDS;
		}
	}
	cap = NULL;
	if (mode == USE_AUTH_MDS)
		cap = ci->i_auth_cap;
	if (!cap && !RB_EMPTY_ROOT(&ci->i_caps))
		cap = rb_entry(rb_first(&ci->i_caps), struct ceph_cap, ci_node);
	if (!cap) {
		spin_unlock(&ci->i_ceph_lock);
		iput(inode);
		goto random;
	}
	mds = cap->session->s_mds;
	doutc(cl, "%p %llx.%llx mds%d (%scap %p)\n", inode,
	      ceph_vinop(inode), mds,
	      cap == ci->i_auth_cap ? "auth " : "", cap);
	spin_unlock(&ci->i_ceph_lock);
out:
	iput(inode);
	return mds;
random:
	if (random)
		*random = true;
	mds = ceph_mdsmap_get_random_mds(mdsc->mdsmap);
	doutc(cl, "chose random mds%d\n", mds);
	return mds;
}
