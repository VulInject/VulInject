mlx5e_ktls_tx_handle_ooo(struct mlx5e_ktls_offload_context_tx *priv_tx,
			 struct mlx5e_txqsq *sq,
			 int datalen,
			 unsigned int seq)
{
	enum mlx5e_ktls_sync_retval ret;
	struct tx_sync_info info = {};
	int i;
	ret = tx_sync_info_get(priv_tx, seq, datalen, &info);
	if (unlikely(ret != MLX5E_KTLS_SYNC_DONE))
		return ret;
	tx_post_resync_params(sq, priv_tx, info.rcd_sn);
	for (i = 0; i < info.nr_frags; i++) {
		unsigned int orig_fsz, frag_offset = 0, n = 0;
		skb_frag_t *f = &info.frags[i];
		orig_fsz = skb_frag_size(f);
		do {
			unsigned int fsz;
			n++;
			fsz = min_t(unsigned int, sq->hw_mtu, orig_fsz - frag_offset);
			if (tx_post_resync_dump(sq, f, priv_tx->tisn)) {
				page_ref_add(skb_frag_page(f), n - 1);
				goto err_out;
			}
			skb_frag_off_add(f, fsz);
			frag_offset += fsz;
		} while (frag_offset < orig_fsz);
		page_ref_add(skb_frag_page(f), n - 1);
	}
	return MLX5E_KTLS_SYNC_DONE;
err_out:
	for (; i < info.nr_frags; i++)
		put_page(skb_frag_page(&info.frags[i]));
	return MLX5E_KTLS_SYNC_FAIL;
}
