RedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {
    client *c = NULL;
    robj **argv = NULL;
    int argc = 0, flags = 0;
    va_list ap;
    RedisModuleCallReply *reply = NULL;
    int replicate = 0; /* Replicate this command? */
    int error_as_call_replies = 0; /* return errors as RedisModuleCallReply object */
    unsigned int int cmd_flags;
    /* Handle arguments. */
    va_start(ap, fmt);
    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
    replicate = flags & REDISMODULE_ARGV_REPLICATE;
    error_as_call_replies = flags & REDISMODULE_ARGV_CALL_REPLIES_AS_ERRORS;
    va_end(ap);
    c = moduleAllocTempClient();
    if (!(flags & REDISMODULE_ARGV_ALLOW_BLOCK)) {
        /* We do not want to allow block, the module do not expect it */
        c->flags |= CLIENT_DENY_BLOCKING;
    }
    c->db = ctx->client->db;
    c->argv = argv;
    /* We have to assign argv_len, which is equal to argc in that case (RM_Call)
     * because we may be calling a command that uses rewriteClientCommandArgument */
    c->argc = c->argv_len = argc;
    c->resp = 2;
    if (flags & REDISMODULE_ARGV_RESP_3) {
        c->resp = 3;
    } else if (flags & REDISMODULE_ARGV_RESP_AUTO) {
        /* Auto mode means to take the same protocol as the ctx client. */
        c->resp = ctx->client->resp;
    }
    if (ctx->module) ctx->module->in_call++;
    user *user = NULL;
    if (flags & REDISMODULE_ARGV_RUN_AS_USER) {
        user = ctx->user ? ctx->user->user : ctx->client->user;
        if (!user) {
            errno = ENOTSUP;
            if (error_as_call_replies) {
                sds msg = sdsnew("cannot run as user, no user directly attached to context or context's client");
                reply = callReplyCreateError(msg, ctx);
            }
            goto cleanup;
        }
        c->user = user;
    }
    /* We handle the above format error only when the client is setup so that
     * we can free it normally. */
    if (argv == NULL) {
        /* We do not return a call reply here this is an error that should only
         * be catch by the module indicating wrong fmt was given, the module should
         * handle this error and decide how to continue. It is not an error that
         * should be propagated to the user. */
        errno = EBADF;
        goto cleanup;
    }
    /* Call command filters */
    moduleCallCommandFilters(c);
    /* Lookup command now, after filters had a chance to make modifications
     * if necessary.
     */
    c->cmd = c->lastcmd = c->realcmd = lookupCommand(c->argv,c->argc);
    sds err;
    if (!commandCheckExistence(c, error_as_call_replies? &err : NULL)) {
        errno = ENOENT;
        if (error_as_call_replies)
            reply = callReplyCreateError(err, ctx);
        goto cleanup;
    }
    if (!commandCheckArity(c, error_as_call_replies? &err : NULL)) {
        errno = EINVAL;
        if (error_as_call_replies)
            reply = callReplyCreateError(err, ctx);
        goto cleanup;
    }
    cmd_flags = getCommandFlags(c);
    if (flags & REDISMODULE_ARGV_SCRIPT_MODE) {
        /* Basically on script mode we want to only allow commands that can
         * be executed on scripts (CMD_NOSCRIPT is not set on the command flags) */
        if (cmd_flags & CMD_NOSCRIPT) {
            errno = ESPIPE;
            if (error_as_call_replies) {
                sds msg = sdscatfmt(sdsempty(), "command '%S' is not allowed on script mode", c->cmd->fullname);
                reply = callReplyCreateError(msg, ctx);
            }
            goto cleanup;
        }
    }
    if (flags & REDISMODULE_ARGV_RESPECT_DENY_OOM && server.maxmemory) {
        if (cmd_flags & CMD_DENYOOM) {
            int oom_state;
            if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) {
                /* On background thread we can not count on server.pre_command_oom_state.
                 * Because it is only set on the main thread, in such case we will check
                 * the actual memory usage. */
                oom_state = (getMaxmemoryState(NULL,NULL,NULL,NULL) == C_ERR);
            } else {
                oom_state = server.pre_command_oom_state;
            }
            if (oom_state) {
                errno = ENOSPC;
                if (error_as_call_replies) {
                    sds msg = sdsdup(shared.oomerr->ptr);
                    reply = callReplyCreateError(msg, ctx);
                }
                goto cleanup;
            }
        }
    } else {
        /* if we aren't OOM checking in RM_Call, we want further executions from this client to also not fail on OOM */
        c->flags |= CLIENT_ALLOW_OOM;
    }
    if (flags & REDISMODULE_ARGV_NO_WRITES) {
        if (cmd_flags & CMD_WRITE) {
            errno = ENOSPC;
            if (error_as_call_replies) {
                sds msg = sdscatfmt(sdsempty(), "Write command '%S' was "
                                                "called while write is not allowed.", c->cmd->fullname);
                reply = callReplyCreateError(msg, ctx);
            }
            goto cleanup;
        }
    }
    /* Script mode tests */
    if (flags & REDISMODULE_ARGV_SCRIPT_MODE) {
        if (cmd_flags & CMD_WRITE) {
            /* on script mode, if a command is a write command,
             * We will not run it if we encounter disk error
             * or we do not have enough replicas */
            if (!checkGoodReplicasStatus()) {
                errno = ESPIPE;
                if (error_as_call_replies) {
                    sds msg = sdsdup(shared.noreplicaserr->ptr);
                    reply = callReplyCreateError(msg, ctx);
                }
                goto cleanup;
            }
            int deny_write_type = writeCommandsDeniedByDiskError();
            int obey_client = (server.current_client && mustObeyClient(server.current_client));
            if (deny_write_type != DISK_ERROR_TYPE_NONE && !obey_client) {
                errno = ESPIPE;
                if (error_as_call_replies) {
                    sds msg = writeCommandsGetDiskErrorMessage(deny_write_type);
                    reply = callReplyCreateError(msg, ctx);
                }
                goto cleanup;
            }
            if (server.masterhost && server.repl_slave_ro && !obey_client) {
                errno = ESPIPE;
                if (error_as_call_replies) {
                    sds msg = sdsdup(shared.roslaveerr->ptr);
                    reply = callReplyCreateError(msg, ctx);
                }
                goto cleanup;
            }
        }
        if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&
            server.repl_serve_stale_data == 0 && !(cmd_flags & CMD_STALE)) {
            errno = ESPIPE;
            if (error_as_call_replies) {
                sds msg = sdsdup(shared.masterdownerr->ptr);
                reply = callReplyCreateError(msg, ctx);
            }
            goto cleanup;
        }
    }
    /* Check if the user can run this command according to the current
     * ACLs.
     *
     * If RM_SetContextUser has set a user, that user is used, otherwise
     * use the attached client's user. If there is no attached client user and no manually
     * set user, an error will be returned */
    if (flags & REDISMODULE_ARGV_RUN_AS_USER) {
        int acl_errpos;
        int acl_retval;
        acl_retval = ACLCheckAllUserCommandPerm(user,c->cmd,c->argv,c->argc,&acl_errpos);
        if (acl_retval != ACL_OK) {
            sds object = (acl_retval == ACL_DENIED_CMD) ? sdsdup(c->cmd->fullname) : sdsdup(c->argv[acl_errpos]->ptr);
            addACLLogEntry(ctx->client, acl_retval, ACL_LOG_CTX_MODULE, -1, c->user->name, object);
            if (error_as_call_replies) {
                /* verbosity should be same as processCommand() in server.c */
                sds acl_msg = getAclErrorMessage(acl_retval, c->user, c->cmd, c->argv[acl_errpos]->ptr, 0);
                sds msg = sdscatfmt(sdsempty(), "-NOPERM %S\r\n", acl_msg);
                sdsfree(acl_msg);
                reply = callReplyCreateError(msg, ctx);
            }
            errno = EACCES;
            goto cleanup;
        }
    }
    /* If this is a Redis Cluster node, we need to make sure the module is not
     * trying to access non-local keys, with the exception of commands
     * received from our master. */
    if (server.cluster_enabled && !mustObeyClient(ctx->client)) {
        int error_code;
        /* Duplicate relevant flags in the module client. */
        c->flags &= ~(CLIENT_READONLY|CLIENT_ASKING);
        c->flags |= ctx->client->flags & (CLIENT_READONLY|CLIENT_ASKING);
        if (getNodeByQuery(c,c->cmd,c->argv,c->argc,NULL,&error_code) !=
                           getMyClusterNode())
        {
            sds msg = NULL;
            if (error_code == CLUSTER_REDIR_DOWN_RO_STATE) {
                if (error_as_call_replies) {
                    msg = sdscatfmt(sdsempty(), "Can not execute a write command '%S' while the cluster is down and readonly", c->cmd->fullname);
                }
                errno = EROFS;
            } else if (error_code == CLUSTER_REDIR_DOWN_STATE) {
                if (error_as_call_replies) {
                    msg = sdscatfmt(sdsempty(), "Can not execute a command '%S' while the cluster is down", c->cmd->fullname);
                }
                errno = ENETDOWN;
            } else {
                if (error_as_call_replies) {
                    msg = sdsnew("Attempted to access a non local key in a cluster node");
                }
                errno = EPERM;
            }
            if (msg) {
                reply = callReplyCreateError(msg, ctx);
            }
            goto cleanup;
        }
    }
    if (flags & REDISMODULE_ARGV_DRY_RUN) {
        goto cleanup;
    }
    /* We need to use a global replication_allowed flag in order to prevent
     * replication of nested RM_Calls. Example:
     * 1. module1.foo does RM_Call of module2.bar without replication (i.e. no '!')
     * 2. module2.bar internally calls RM_Call of INCR with '!'
     * 3. at the end of module1.foo we call RM_ReplicateVerbatim
     * We want the replica/AOF to see only module1.foo and not the INCR from module2.bar */
    int prev_replication_allowed = server.replication_allowed;
    server.replication_allowed = replicate && server.replication_allowed;
    /* Run the command */
    int call_flags = CMD_CALL_FROM_MODULE;
    if (replicate) {
        if (!(flags & REDISMODULE_ARGV_NO_AOF))
            call_flags |= CMD_CALL_PROPAGATE_AOF;
        if (!(flags & REDISMODULE_ARGV_NO_REPLICAS))
            call_flags |= CMD_CALL_PROPAGATE_REPL;
    }
    call(c,call_flags);
    server.replication_allowed = prev_replication_allowed;
    if (c->flags & CLIENT_BLOCKED) {
        serverAssert(flags & REDISMODULE_ARGV_ALLOW_BLOCK);
        RedisModuleAsyncRMCallPromise *promise = zmalloc(sizeof(RedisModuleAsyncRMCallPromise));
        *promise = (RedisModuleAsyncRMCallPromise) {
                /* We start with ref_count value of 2 because this object is held
                 * by the promise CallReply and the fake client that was used to execute the command. */
                .ref_count = 2,
                .module = ctx->module,
                .on_unblocked = NULL,
                .private_data = NULL,
                .c = c,
                .ctx = (ctx->flags & REDISMODULE_CTX_AUTO_MEMORY) ? ctx : NULL,
        };
        reply = callReplyCreatePromise(promise);
        c->bstate.async_rm_call_handle = promise;
        if (!(call_flags & CMD_CALL_PROPAGATE_AOF)) {
            /* No need for AOF propagation, set the relevant flags of the client */
            c->flags |= CLIENT_MODULE_PREVENT_AOF_PROP;
        }
        if (!(call_flags & CMD_CALL_PROPAGATE_REPL)) {
            /* No need for replication propagation, set the relevant flags of the client */
            c->flags |= CLIENT_MODULE_PREVENT_REPL_PROP;
        }
        c = NULL; /* Make sure not to free the client */
    } else {
        reply = moduleParseReply(c, (ctx->flags & REDISMODULE_CTX_AUTO_MEMORY) ? ctx : NULL);
    }
cleanup:
    if (reply) autoMemoryAdd(ctx,REDISMODULE_AM_REPLY,reply);
    if (ctx->module) ctx->module->in_call--;
    if (c) moduleReleaseTempClient(c);
    return reply;
}
