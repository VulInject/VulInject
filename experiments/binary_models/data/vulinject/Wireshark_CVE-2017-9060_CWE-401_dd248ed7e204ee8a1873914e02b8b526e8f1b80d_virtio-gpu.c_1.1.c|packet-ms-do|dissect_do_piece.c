dissect_do_piece(tvbuff_t* tvb, _U_ packet_info* pinfo, proto_tree* message_tree, unsigned int message_size, unsigned char message_id, guint* offset_ptr)
{
    proto_item* pi = NULL;
    unsigned int piece_index = 0;
    unsigned int piece_start_offset = 0;
    unsigned int piece_size = 0;
    piece_size = message_size - 9;
    if (message_size <= 9)
    {
        proto_tree_add_expert_format(message_tree, pinfo, &ei_do_invalid_message_length, tvb, *offset_ptr, message_size - 1,
            "Invalid message size: message size %u must be larger than 9", message_size);
        *offset_ptr += message_size - 1;
        return FALSE;
    }
    proto_tree_add_item_ret_uint(message_tree, hf_do_piece_index, tvb, *offset_ptr, 4, ENC_BIG_ENDIAN, &piece_index);
    *offset_ptr += 4;
    proto_tree_add_item_ret_uint(message_tree, hf_do_piece_start_offset, tvb, *offset_ptr, 4, ENC_BIG_ENDIAN, &piece_start_offset);
    *offset_ptr += 4;
    proto_tree_add_item(message_tree, hf_do_piece_buffer, tvb, *offset_ptr, message_size - 9, ENC_NA);
    *offset_ptr += message_size - 9;
    pi = proto_tree_add_uint(message_tree, hf_do_piece_response_size, NULL, 0, 0, piece_size);
    col_append_sep_fstr(pinfo->cinfo, COL_INFO, NULL, "%s (piece %u; offset 0x%x; size 0x%x)",
        do_message_id_to_str(message_id), piece_index, piece_start_offset, piece_size);
    return TRUE;
}
