process_rtp_payload(tvbuff_t *newtvb, packet_info *pinfo, proto_tree *tree,
            proto_tree *rtp_tree, unsigned int payload_type,
            struct _rtp_info *rtp_info)
{
    struct _rtp_packet_info *p_packet_data;
    int payload_len;
    struct srtp_info *srtp_info;
    int offset = 0;
    proto_item *rtp_data;
    payload_len = tvb_captured_length_remaining(newtvb, offset);
    p_packet_data = (struct _rtp_packet_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, RTP_CONVERSATION_PROTO_DATA);
    if (p_packet_data && p_packet_data->srtp_info) {
        srtp_info = p_packet_data->srtp_info;
        payload_len -= srtp_info->mki_len + srtp_info->auth_tag_len;
#if 0
#error Currently the srtp_info structure contains no cipher data, see packet-sdp.c adding dummy_srtp_info structure
        if (p_conv_data->srtp_info->encryption_algorithm == SRTP_ENC_ALG_NULL) {
            if (rtp_tree)
                proto_tree_add_item(rtp_tree, hf_srtp_null_encrypted_payload, newtvb, offset, payload_len, ENC_NA);
        }
        else
#endif
        {
            if (rtp_tree)
                proto_tree_add_item(rtp_tree, hf_srtp_encrypted_payload, newtvb, offset, payload_len, ENC_NA);
        }
        offset += payload_len;
        if (srtp_info->mki_len) {
            proto_tree_add_item(rtp_tree, hf_srtp_mki, newtvb, offset, srtp_info->mki_len, ENC_NA);
            offset += srtp_info->mki_len;
        }
        if (srtp_info->auth_tag_len) {
            proto_tree_add_item(rtp_tree, hf_srtp_auth_tag, newtvb, offset, srtp_info->auth_tag_len, ENC_NA);
        }
        return;
    } if (p_packet_data && p_packet_data->bta2dp_info) {
        tvbuff_t  *nexttvb;
        gint       suboffset = 0;
        if (p_packet_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {
            nexttvb = tvb_new_subset_length(newtvb, 0, 1);
             call_dissector(bta2dp_content_protection_header_scms_t, nexttvb, pinfo, tree);
            suboffset = 1;
        }
        nexttvb = tvb_new_subset_remaining(newtvb, suboffset);
        if (p_packet_data->bta2dp_info->codec_dissector)
            call_dissector_with_data(p_packet_data->bta2dp_info->codec_dissector, nexttvb, pinfo, tree, p_packet_data->bta2dp_info);
        else
            call_data_dissector(nexttvb, pinfo, tree);
        return;
    } if (p_packet_data && p_packet_data->btvdp_info) {
        tvbuff_t  *nexttvb;
        gint       suboffset = 0;
        if (p_packet_data->btvdp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {
            nexttvb = tvb_new_subset_length(newtvb, 0, 1);
            call_dissector(btvdp_content_protection_header_scms_t, nexttvb, pinfo, tree);
            suboffset = 1;
        }
        nexttvb = tvb_new_subset_remaining(newtvb, suboffset);
        if (p_packet_data->btvdp_info->codec_dissector)
            call_dissector_with_data(p_packet_data->btvdp_info->codec_dissector, nexttvb, pinfo, tree, p_packet_data->btvdp_info);
        else
            call_data_dissector(nexttvb, pinfo, tree);
        return;
    }
    rtp_data = proto_tree_add_item(rtp_tree, hf_rtp_data, newtvb, 0, -1, ENC_NA);
    if (p_packet_data && payload_type >= PT_UNDF_96 && payload_type <= PT_UNDF_127) {
        if (p_packet_data->rtp_dyn_payload) {
            const gchar *payload_type_str = rtp_dyn_payload_get_name(p_packet_data->rtp_dyn_payload, payload_type);
            if (payload_type_str) {
                int len;
                len = dissector_try_string(rtp_dyn_pt_dissector_table,
                    payload_type_str, newtvb, pinfo, tree, rtp_info);
                if (len > 0)
                return;
            }
        }
    }
    if (dissector_try_uint_new(rtp_pt_dissector_table, payload_type, newtvb, pinfo, tree, TRUE, rtp_info))
        proto_item_set_hidden(rtp_data);
}
