void *bg_call_worker(void *arg) {
    bg_call_data *bg = arg;
    RedisModuleBlockedClient *bc = bg->bc;
    // Get module context
    RedisModuleCtx *ctx = RedisModule_GetThreadSafeContext(bg->bc);
    // Acquire GIL
    if (g_slow_bg_operation) {
        g_is_in_slow_bg_operation = 1;
        while (g_slow_bg_operation) {
            RedisModule_Yield(ctx, REDISMODULE_YIELD_FLAG_CLIENTS, "Slow module operation");
            usleep(1000);
        }
        g_is_in_slow_bg_operation = 0;
    }
    // Call the command
    const char *module_cmd = RedisModule_StringPtrLen(bg->argv[0], NULL);
    int cmd_pos = 1;
    RedisModuleString *format_redis_str = RedisModule_CreateString(NULL, "v", 1);
    if (!strcasecmp(module_cmd, "do_bg_rm_call_format")) {
        cmd_pos = 2;
        size_t format_len;
        const char *format = RedisModule_StringPtrLen(bg->argv[1], &format_len);
        RedisModule_StringAppendBuffer(NULL, format_redis_str, format, format_len);
        RedisModule_StringAppendBuffer(NULL, format_redis_str, "E", 1);
    }
    const char *format = RedisModule_StringPtrLen(format_redis_str, NULL);
    const char *cmd = RedisModule_StringPtrLen(bg->argv[cmd_pos], NULL);
    RedisModuleCallReply *rep = RedisModule_Call(ctx, cmd, format, bg->argv + cmd_pos + 1, bg->argc - cmd_pos - 1);
    RedisModule_FreeString(NULL, format_redis_str);
    /* Free the arguments within GIL to prevent simultaneous freeing in main thread. */
    for (int i=0; i<bg->argc; i++)
        RedisModule_FreeString(ctx, bg->argv[i]);
    RedisModule_Free(bg->argv);
    RedisModule_Free(bg);
    // Release GIL
    RedisModule_ThreadSafeContextUnlock(ctx);
    // Reply to client
    if (!rep) {
        RedisModule_ReplyWithError(ctx, "NULL reply returned");
    } else {
        RedisModule_ReplyWithCallReply(ctx, rep);
        RedisModule_FreeCallReply(rep);
    }
    // Unblock client
    RedisModule_UnblockClient(bc, NULL);
    // Free the module context
    RedisModule_FreeThreadSafeContext(ctx);
    return NULL;
}
