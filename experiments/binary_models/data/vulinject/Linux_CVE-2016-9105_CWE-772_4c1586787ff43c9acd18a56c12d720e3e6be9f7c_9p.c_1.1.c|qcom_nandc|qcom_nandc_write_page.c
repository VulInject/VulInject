static int qcom_nandc_write_page(struct nand_chip *chip, const unsigned char *buf,
				 int oob_required, int page)
{
	struct qcom_nand_host *host = to_qcom_nand_host(chip);
	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
	struct nand_ecc_ctrl *ecc = &chip->ecc;
	unsigned char *data_buf, *oob_buf;
	int i, ret;
	if (host->nr_boot_partitions)
	nand_prog_page_begin_op(chip, page, 0, NULL, 0);
	set_address(host, 0, page);
	nandc->buf_count = 0;
	nandc->buf_start = 0;
	clear_read_regs(nandc);
	clear_bam_transaction(nandc);
	data_buf = (unsigned char *)buf;
	oob_buf = chip->oob_poi;
	host->use_ecc = true;
	update_rw_regs(host, ecc->steps, false, 0);
	config_nand_page_write(chip);
	for (i = 0; i < ecc->steps; i++) {
		int data_size, oob_size;
		if (qcom_nandc_is_last_cw(ecc, i) && !host->codeword_fixup) {
			data_size = ecc->size - ((ecc->steps - 1) << 2);
			oob_size = (ecc->steps << 2) + host->ecc_bytes_hw +
				   host->spare_bytes;
		} else {
			data_size = host->cw_data;
			oob_size = ecc->bytes;
		}
		write_data_dma(nandc, FLASH_BUF_ACC, data_buf, data_size,
			       i == (ecc->steps - 1) ? NAND_BAM_NO_EOT : 0);
		if (qcom_nandc_is_last_cw(ecc, i)) {
			oob_buf += host->bbm_size;
			write_data_dma(nandc, FLASH_BUF_ACC + data_size,
				       oob_buf, oob_size, 0);
		}
		config_nand_cw_write(chip);
		data_buf += data_size;
		oob_buf += oob_size;
	}
	ret = submit_descs(nandc);
	if (ret) {
		dev_err(nandc->dev, "failure to write page\n");
		return ret;
	}
	return nand_prog_page_end_op(chip);
}
