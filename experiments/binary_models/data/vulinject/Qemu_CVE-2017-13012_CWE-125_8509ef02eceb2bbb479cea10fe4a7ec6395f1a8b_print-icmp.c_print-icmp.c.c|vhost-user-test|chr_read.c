static void chr_read(void *opaque, const uint8_t *buf, int size)
{
    g_autoptr(GError) err = NULL;
    TestServer *s = opaque;
    CharBackend *chr = &s->chr;
    VhostUserMsg msg;
    uint8_t *p = (uint8_t *) &msg;
    int fd = -1;
    if (s->test_fail) {
        qemu_chr_fe_disconnect(chr);
        /* now switch to non-failure */
        s->test_fail = false;
    }
    if (size != VHOST_USER_HDR_SIZE) {
        qos_printf("%s: Wrong message size received %d\n", __func__, size);
        return;
    }
    memcpy(p, buf, VHOST_USER_HDR_SIZE);
    if (msg.size) {
        p += VHOST_USER_HDR_SIZE;
        size = qemu_chr_fe_read_all(chr, p, msg.size);
        if (size != msg.size) {
            qos_printf("%s: Wrong message size received %d != %d\n",
                       __func__, size, msg.size);
            goto out;
        }
    }
    switch (msg.request) {
    case VHOST_USER_GET_FEATURES:
        /* Mandatory for tests to define get_features */
        g_assert(s->vu_ops->get_features);
        /* send back features to qemu */
        msg.flags |= VHOST_USER_REPLY_MASK;
        msg.size = sizeof(m.payload.u64);
        if (s->test_flags >= TEST_FLAGS_BAD) {
            msg.payload.u64 = 0;
            s->test_flags = TEST_FLAGS_END;
        } else {
            msg.payload.u64 = s->vu_ops->get_features(s);
        }
        qemu_chr_fe_write_all(chr, (uint8_t *) &msg,
                              VHOST_USER_HDR_SIZE + msg.size);
        break;
    case VHOST_USER_SET_FEATURES:
        if (s->vu_ops->set_features) {
            s->vu_ops->set_features(s, chr, &msg);
        }
        break;
    case VHOST_USER_SET_OWNER:
        /*
         * We don't need to do anything here, the remote is just
         * letting us know it is in charge. Just log it.
         */
        qos_printf("set_owner: start of session\n");
        break;
    case VHOST_USER_GET_PROTOCOL_FEATURES:
        if (s->vu_ops->get_protocol_features) {
            s->vu_ops->get_protocol_features(s, chr, &msg);
        }
        break;
    case VHOST_USER_GET_CONFIG:
        /*
         * Treat GET_CONFIG as a NOP and just reply and let the guest
         * consider we have updated its memory. Tests currently don't
         * require working configs.
         */
        msg.flags |= VHOST_USER_REPLY_MASK;
        p = (uint8_t *) &msg;
        qemu_chr_fe_write_all(chr, p, VHOST_USER_HDR_SIZE + msg.size);
        break;
    case VHOST_USER_SET_PROTOCOL_FEATURES:
        /*
         * We did set VHOST_USER_F_PROTOCOL_FEATURES so its valid for
         * the remote end to send this. There is no handshake reply so
         * just log the details for debugging.
         */
        qos_printf("set_protocol_features: 0x%"PRIx64 "\n", msg.payload.u64);
        break;
        /*
         * A real vhost-user backend would actually set the size and
         * address of the vrings but we can simply report them.
         */
    case VHOST_USER_SET_VRING_NUM:
        qos_printf("set_vring_num: %d/%d\n",
                   msg.payload.state.index, msg.payload.state.num);
        break;
    case VHOST_USER_SET_VRING_ADDR:
        qos_printf("set_vring_addr: 0x%"PRIx64"/0x%"PRIx64"/0x%"PRIx64"\n",
                   msg.payload.addr.avail_user_addr,
                   msg.payload.addr.desc_user_addr,
                   msg.payload.addr.used_user_addr);
        break;
    case VHOST_USER_GET_VRING_BASE:
        /* send back vring base to qemu */
        msg.flags |= VHOST_USER_REPLY_MASK;
        msg.size = sizeof(m.payload.state);
        msg.payload.state.num = 0;
        p = (uint8_t *) &msg;
        qemu_chr_fe_write_all(chr, p, VHOST_USER_HDR_SIZE + msg.size);
        assert(msg.payload.state.index < s->queues * 2);
        s->rings &= ~(0x1ULL << msg.payload.state.index);
        g_cond_broadcast(&s->data_cond);
        break;
    case VHOST_USER_SET_MEM_TABLE:
        /* received the mem table */
        memcpy(&s->memory, &msg.payload.memory, sizeof(msg.payload.memory));
        s->fds_num = qemu_chr_fe_get_msgfds(chr, s->fds,
                                            G_N_ELEMENTS(s->fds));
        /* signal the test that it can continue */
        g_cond_broadcast(&s->data_cond);
        break;
    case VHOST_USER_SET_VRING_KICK:
    case VHOST_USER_SET_VRING_CALL:
        /* consume the fd */
        qemu_chr_fe_get_msgfds(chr, &fd, 1);
        /*
         * This is a non-blocking eventfd.
         * The receive function forces it to be blocking,
         * so revert it back to non-blocking.
         */
        g_unix_set_fd_nonblocking(fd, true, &err);
        g_assert_no_error(err);
        break;
    case VHOST_USER_SET_LOG_BASE:
        if (s->log_fd != -1) {
            close(s->log_fd);
            s->log_fd = -1;
        }
        qemu_chr_fe_get_msgfds(chr, &s->log_fd, 1);
        msg.flags |= VHOST_USER_REPLY_MASK;
        msg.size = 0;
        p = (uint8_t *) &msg;
        qemu_chr_fe_write_all(chr, p, VHOST_USER_HDR_SIZE);
        g_cond_broadcast(&s->data_cond);
        break;
    case VHOST_USER_SET_VRING_BASE:
        assert(msg.payload.state.index < s->queues * 2);
        s->rings |= 0x1ULL << msg.payload.state.index;
        g_cond_broadcast(&s->data_cond);
        break;
    case VHOST_USER_GET_QUEUE_NUM:
        msg.flags |= VHOST_USER_REPLY_MASK;
        msg.size = sizeof(m.payload.u64);
        msg.payload.u64 = s->queues;
        p = (uint8_t *) &msg;
        qemu_chr_fe_write_all(chr, p, VHOST_USER_HDR_SIZE + msg.size);
        break;
    case VHOST_USER_SET_VRING_ENABLE:
        /*
         * Another case we ignore as we don't need to respond. With a
         * fully functioning vhost-user we would enable/disable the
         * vring monitoring.
         */
        qos_printf("set_vring(%d)=%s\n", msg.payload.state.index,
                   msg.payload.state.num ? "enabled" : "disabled");
        break;
    default:
        qos_printf("vhost-user: un-handled message: %d\n", msg.request);
        break;
    }
out:
    g_mutex_unlock(&s->data_mutex);
}
