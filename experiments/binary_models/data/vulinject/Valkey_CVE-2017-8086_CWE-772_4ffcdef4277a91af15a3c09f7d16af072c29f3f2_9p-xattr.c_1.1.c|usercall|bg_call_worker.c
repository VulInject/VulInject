void *bg_call_worker(void *arg) {
    bg_call_data *bg = arg;
    RedisModuleBlockedClient *bc = bg->bc;
    // Get module context
    RedisModuleCtx *ctx = RedisModule_GetThreadSafeContext(bg->bc);
    // Acquire GIL
    RedisModule_SetContextUser(ctx, user);
    // Call the command
    size_t format_len;
    RedisModuleString *format_redis_str = RedisModule_CreateString(NULL, "v", 1);
    const char *format = RedisModule_StringPtrLen(bg->argv[1], &format_len);
    RedisModule_StringAppendBuffer(NULL, format_redis_str, format, format_len);
    RedisModule_StringAppendBuffer(NULL, format_redis_str, "E", 1);
    format = RedisModule_StringPtrLen(format_redis_str, NULL);
    const char *cmd = RedisModule_StringPtrLen(bg->argv[2], NULL);
    RedisModuleCallReply *rep = RedisModule_Call(ctx, cmd, format, bg->argv + 3, bg->argc - 3);
    RedisModule_FreeString(NULL, format_redis_str);
    /* Free the arguments within GIL to prevent simultaneous freeing in main thread. */
    for (int i=0; i<bg->argc; i++)
        RedisModule_FreeString(ctx, bg->argv[i]);
    RedisModule_Free(bg->argv);
    RedisModule_Free(bg);
    // Release GIL
    RedisModule_ThreadSafeContextUnlock(ctx);
    // Reply to client
    if (!rep) {
        RedisModule_ReplyWithError(ctx, "NULL reply returned");
    } else {
        RedisModule_ReplyWithCallReply(ctx, rep);
        RedisModule_FreeCallReply(rep);
    }
    // Unblock client
    RedisModule_UnblockClient(bc, NULL);
    // Free the module context
    RedisModule_FreeThreadSafeContext(ctx);
    return NULL;
}
