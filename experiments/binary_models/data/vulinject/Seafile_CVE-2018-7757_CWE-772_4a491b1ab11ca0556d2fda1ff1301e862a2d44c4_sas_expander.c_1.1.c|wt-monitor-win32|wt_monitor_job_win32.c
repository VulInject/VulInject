wt_monitor_job_win32 (void *vmonitor)
{
    SeafWTMonitor *monitor = vmonitor;
    SeafWTMonitorPriv *priv = monitor->priv;
    RepoWatchInfo *info;
    DWORD bytesRead = 0;
    ULONG_PTR key = 0;
    OVERLAPPED *ol = NULL;
    if (!add_all_to_iocp(monitor)) {
        seaf_warning("Failed to add all to iocp\n");
        return NULL;
    }
    while (1) {
        BOOL ret = GetQueuedCompletionStatus
            (priv->iocp_handle,           
             &bytesRead,                  
             &key,                        
             &ol,                         
             INFINITE);                   
        static int retry;
        if (!ret) {
            seaf_warning ("GetQueuedCompletionStatus failed, "
                          "error code %lu", GetLastError());
            if (retry++ < 3)
                continue;
            else
                break;
        } else {
            retry = 0;
        }
        if (key == (ULONG_PTR)monitor->cmd_pipe[0]) {     
            priv->cmd_bytes_read += (int)bytesRead;
            if (priv->cmd_bytes_read != sizeof(WatchCommand)) {
                start_watch_cmd_pipe (monitor, ol);
                continue;
            } else
                priv->cmd_bytes_read = 0;
            seaf_debug ("recevied a pipe cmd, type %d for repo %s\n",
                        priv->cmd.type, priv->cmd.repo_id);
            handle_watch_command (monitor, &priv->cmd);
            reset_overlapped(ol);
            start_watch_cmd_pipe (monitor, ol);
        } else {
            HANDLE hTriggered = (HANDLE)key;
            info = (RepoWatchInfo *)g_hash_table_lookup
                (priv->info_hash, (gconstpointer)hTriggered); 
            if (info) {
                DirWatchAux *aux = g_hash_table_lookup (priv->buf_hash,
                                                        (gconstpointer)hTriggered);
                process_events (info->status->repo_id, info, aux->buf, bytesRead);
                reset_overlapped(ol);
                if (!start_watch_dir_change(priv, hTriggered)) {
                    seaf_warning ("start_watch_dir_change failed"
                                  "for repo %s, error code %lu\n",
                                  info->status->repo_id, GetLastError());
                }
            } else {
                g_hash_table_remove (priv->buf_hash, (gconstpointer)hTriggered);
            }
        }
    }
    return NULL;
}
