ngx_quic_detect_lost(ngx_connection_t *c, ngx_quic_ack_stat_t *st)
{
    ngx_uint_t              i, nlost;
    ngx_msec_t              now, wait, thr, oldest, newest;
    ngx_queue_t            *q;
    ngx_quic_frame_t       *start;
    ngx_quic_send_ctx_t    *ctx;
    ngx_quic_connection_t  *qc;
    qc = ngx_quic_get_connection(c);
    now = ngx_current_msec;
    thr = ngx_quic_lost_threshold(qc);
    oldest = NGX_TIMER_INFINITE;
    newest = NGX_TIMER_INFINITE;
    nlost = 0;
    for (i = 0; i < NGX_QUIC_SEND_CTX_LAST; i++) {
        ctx = &qc->send_ctx[i];
        if (ctx->largest_ack == NGX_QUIC_UNSET_PN) {
            continue;
        }
        while (!ngx_queue_empty(&ctx->sent)) {
            q = ngx_queue_head(&ctx->sent);
            start = ngx_queue_data(q, ngx_quic_frame_t, queue);
            if (start->pnum > ctx->largest_ack) {
                break;
            }
            wait = start->send_time + thr - now;
            ngx_log_debug4(NGX_LOG_DEBUG_EVENT, c->log, 0,
                           "quic detect_lost pnum:%uL thr:%M wait:%i level:%d",
                           start->pnum, thr, (ngx_int_t) wait, start->level);
            if ((ngx_msec_int_t) wait > 0
                && ctx->largest_ack - start->pnum < NGX_QUIC_PKT_THR)
            {
                break;
            }
            if (start->send_time > qc->first_rtt) {
                if (oldest == NGX_TIMER_INFINITE || start->send_time < oldest) {
                    oldest = start->send_time;
                }
                if (newest == NGX_TIMER_INFINITE || start->send_time > newest) {
                    newest = start->send_time;
                }
                nlost++;
            }
        }
    }
    if (st && nlost >= 2 && (st->newest < oldest || st->oldest > newest)) {
        if (newest - oldest > ngx_quic_pcg_duration(c)) {
            ngx_quic_persistent_congestion(c);
        }
    }
    ngx_quic_set_lost_timer(c);
    return NGX_OK;
}
