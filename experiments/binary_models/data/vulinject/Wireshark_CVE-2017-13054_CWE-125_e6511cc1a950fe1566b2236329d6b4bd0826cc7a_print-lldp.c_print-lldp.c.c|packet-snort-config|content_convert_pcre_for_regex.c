gboolean content_convert_pcre_for_regex(content_t *content)
{
    guint pcre_length, i, end_delimiter_offset = 0;
    if (content->translated_str) {
        return TRUE;
    }
    pcre_length = (guint)strlen(content->str);
    if (pcre_length >= 512) {
        return FALSE;
    }
    if (content->str[0] != '/') {
        return FALSE;
    }
    for (i=pcre_length-1; i > 2; i--) {
        if (content->str[i] == '/') {
            end_delimiter_offset = i;
            break;
        }
        else {
            switch (content->str[i]) {
                case 'i':
                    content->pcre_case_insensitive = TRUE;
                    break;
                case 's':
                    content->pcre_dot_includes_newline = TRUE;
                    break;
                case 'B':
                    content->pcre_raw = TRUE;
                    break;
                case 'm':
                    content->pcre_multiline = TRUE;
                    break;
                default:
                    snort_debug_printf("Unhandled pcre modifier '%c'\n", content->str[i]);
                    break;
            }
        }
    }
    if (end_delimiter_offset == 0) {
        return FALSE;
    }
    content->translated_str = (guchar*)g_malloc(end_delimiter_offset);
    memcpy(content->translated_str, content->str+1, end_delimiter_offset - 1);
    content->translated_str[end_delimiter_offset-1] = '\0';
    content->translated = TRUE;
    content->translated_length = end_delimiter_offset - 1;
    return TRUE;
}
