read_heur_dissector_list_file(const char *ff_path, FILE *ff, GList **flp)
{
  heur_protocol_def *heur;
  int         c;
  char       *heuristic_name;
  int         heuristic_name_len;
  int         name_index;
  gboolean    parse_enabled;
  gboolean    enabled;
  int         line = 1;
  heuristic_name_len = INIT_BUF_SIZE;
  heuristic_name = (char *)g_malloc(heuristic_name_len + 1);
  for (line = 1; ; line++) {
    while ((c = ws_getc_unlocked(ff)) != EOF && g_ascii_isspace(c)) {
      if (c == '\n') {
        continue;
      }
    }
    if (c == EOF) {
      if (ferror(ff))
        goto error;     
      else
        break;  
    }
    name_index = 0;
    enabled = FALSE;
    parse_enabled = FALSE;
    for (;;) {
      c = ws_getc_unlocked(ff);
      if (c == EOF)
        break;  
      if (g_ascii_isspace(c))
        break;  
      if (c == ',') {
        parse_enabled = TRUE;
        continue;
      }
      if (c == '#')
        break;  
      if (parse_enabled) {
          enabled = ((c == '1') ? TRUE : FALSE);
          break;
      }
      if (name_index >= heuristic_name_len) {
        heuristic_name_len *= 2;
        heuristic_name = (char *)g_realloc(heuristic_name, heuristic_name_len + 1);
      }
      heuristic_name[name_index] = c;
      name_index++;
    }
    if (g_ascii_isspace(c) && c != '\n') {
      while ((c = ws_getc_unlocked(ff)) != EOF && c != '\n' && g_ascii_isspace(c))
        ;
      if (c != EOF && c != '\n' && c != '#') {
        ws_warning("'%s' line %d has extra stuff after the protocol name.",
                  ff_path, line);
      }
    }
    if (c != EOF && c != '\n') {
      while ((c = ws_getc_unlocked(ff)) != EOF && c != '\n')
        ;
    }
    if (c == EOF) {
      if (ferror(ff))
        goto error;     
      else {
        ws_warning("'%s' line %d doesn't have a newline.", ff_path,
                  line);
      }
      break;    
    }
    if (name_index >= heuristic_name_len) {
      heuristic_name_len *= 2;
      heuristic_name = (char *)g_realloc(heuristic_name, heuristic_name_len + 1);
    }
    heuristic_name[name_index] = '\0';
    heur         = g_new(heur_protocol_def, 1);
    heur->name   = g_strdup(heuristic_name);
    heur->enabled = enabled;
    *flp = g_list_append(*flp, heur);
  }
  g_free(heuristic_name);
  return 0;
error:
  g_free(heuristic_name);
  return errno;
}
