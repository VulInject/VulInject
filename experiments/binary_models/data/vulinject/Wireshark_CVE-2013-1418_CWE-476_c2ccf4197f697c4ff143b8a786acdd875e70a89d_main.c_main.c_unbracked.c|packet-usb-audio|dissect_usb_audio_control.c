dissect_usb_audio_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data)
{
    usb_conv_info_t *usb_conv_info;
    gint             offset, length;
    usb_conv_info = (usb_conv_info_t *)data;
    if ((usb_conv_info->usb_trans_info == NULL) ||
        (USB_TYPE(usb_conv_info->usb_trans_info->setup.requesttype) != RQT_SETUP_TYPE_CLASS) ||
        !(USB_RECIPIENT(usb_conv_info->usb_trans_info->setup.requesttype) == RQT_SETUP_RECIPIENT_INTERFACE ||
          USB_RECIPIENT(usb_conv_info->usb_trans_info->setup.requesttype) == RQT_SETUP_RECIPIENT_ENDPOINT)) {
        return 0;
    }
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "USBAUDIO");
    col_set_str(pinfo->cinfo, COL_INFO, usb_conv_info->usb_trans_info->setup.requesttype & USB_DIR_IN ? "GET" : "SET");
    length = tvb_reported_length(tvb);
    offset = 0;
    if ((usb_conv_info->interfaceClass == IF_CLASS_AUDIO) &&
        (usb_conv_info->interfaceSubclass == AUDIO_IF_SUBCLASS_AUDIOCONTROL)) {
        switch (usb_conv_info->interfaceProtocol) {
            case AUDIO_PROTOCOL_V1:
                offset += dissect_v1_control(tvb, offset, pinfo, parent_tree, usb_conv_info);
                break;
            case AUDIO_PROTOCOL_V2:
                offset += dissect_v2_control(tvb, offset, pinfo, parent_tree, usb_conv_info);
                break;
            default:
                break;
        }
    }
    if (!usb_conv_info->is_request &&
        (((usb_conv_info->usb_trans_info->setup.requesttype & USB_DIR_IN) == USB_DIR_OUT) ||
          (usb_conv_info->usb_trans_info->setup.wLength == 0))) {
        col_append_str(pinfo->cinfo, COL_INFO, " status");
    } else {
        col_append_str(pinfo->cinfo, COL_INFO, usb_conv_info->is_request ? " request" : " response");
    }
    if (offset < length) {
        proto_tree_add_expert(parent_tree, pinfo, &ei_usb_audio_undecoded, tvb, offset, length - offset);
    }
    return length;
}
