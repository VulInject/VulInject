uint32_t HELPER(bitrev)(uint32_t x)
{
    x = ((x >> 1) & 0x55555555u) | ((x << 1) & 0xaaaaaaaau);
    x = ((x >> 2) & 0x33333333u) | ((x << 2) & 0xccccccccu);
    x = ((x >> 4) & 0x0f0f0f0fu) | ((x << 4) & 0xf0f0f0f0u);
    return bswap32(x);
}
uint32_t HELPER(ff1)(uint32_t x)
{
    int n;
    for (n = 32; x; n--)
        x >>= 1;
    return n;
}
uint32_t HELPER(get_ccr)(CPUM68KState *env)
{
    return cpu_m68k_get_ccr(env);
}
uint32_t HELPER(get_mac_extf)(CPUM68KState *env, uint32_t acc)
{
    uint32_t val;
    val = env->macc[acc] & 0x00ff;
    val |= (env->macc[acc] >> 32) & 0xff00;
    val |= (env->macc[acc + 1] << 16) & 0x00ff0000;
    val |= (env->macc[acc + 1] >> 16) & 0xff000000;
    return val;
}
uint32_t HELPER(get_mac_exti)(CPUM68KState *env, uint32_t acc)
{
    uint32_t val;
    val = (env->macc[acc] >> 32) & 0xffff;
    val |= (env->macc[acc + 1] >> 16) & 0xffff0000;
    return val;
}
uint32_t HELPER(get_macf)(CPUM68KState *env, uint64_t val)
{
    int rem;
    uint32_t result;
    if (env->macsr & MACSR_SU) {
        /* 16-bit rounding.  */
        rem = val & 0xffffff;
        val = (val >> 24) & 0xffffu;
        if (rem > 0x800000)
            val++;
        else if (rem == 0x800000)
            val += (val & 1);
    } else if (env->macsr & MACSR_RT) {
        /* 32-bit rounding.  */
        rem = val & 0xff;
        val >>= 8;
        if (rem > 0x80)
            val++;
        else if (rem == 0x80)
            val += (val & 1);
    } else {
        /* No rounding.  */
        val >>= 8;
    }
    if (env->macsr & MACSR_OMC) {
        /* Saturate.  */
        if (env->macsr & MACSR_SU) {
            if (val != (uint16_t) val) {
                result = ((val >> 63) ^ 0x7fff) & 0xffff;
            } else {
                result = val & 0xffff;
            }
        } else {
            if (val != (uint32_t)val) {
                result = ((uint32_t)(val >> 63) & 0x7fffffff);
            } else {
                result = (uint32_t)val;
            }
        }
    } else {
        /* No saturation.  */
        if (env->macsr & MACSR_SU) {
            result = val & 0xffff;
        } else {
            result = (uint32_t)val;
        }
    }
    return result;
}
uint32_t HELPER(get_macs)(uint64_t val)
{
    if (val == (int32_t)val) {
        return (int32_t)val;
    } else {
        return (val >> 61) ^ ~SIGNBIT;
    }
}
uint32_t HELPER(get_macu)(uint64_t val)
{
    if ((val >> 32) == 0) {
        return (uint32_t)val;
    } else {
        return 0xffffffffu;
    }
}
uint32_t HELPER(m68k_movec_from)(CPUM68KState *env, uint32_t reg)
{
    switch (reg) {
    /* MC680[12346]0 */
    case M68K_CR_SFC:
        return env->sfc;
    /* MC680[12346]0 */
    case M68K_CR_DFC:
        return env->dfc;
    /* MC680[12346]0 */
    case M68K_CR_VBR:
        return env->vbr;
    /* MC680[2346]0 */
    case M68K_CR_CACR:
        if (m68k_feature(env, M68K_FEATURE_M68020)
         || m68k_feature(env, M68K_FEATURE_M68030)
         || m68k_feature(env, M68K_FEATURE_M68040)
         || m68k_feature(env, M68K_FEATURE_M68060)) {
            return env->cacr;
        }
        break;
    /* MC680[46]0 */
    case M68K_CR_TC:
        if (m68k_feature(env, M68K_FEATURE_M68040)
         || m68k_feature(env, M68K_FEATURE_M68060)) {
            return env->mmu.tcr;
        }
        break;
    /* MC68040 */
    case M68K_CR_MMUSR:
        if (m68k_feature(env, M68K_FEATURE_M68040)) {
            return env->mmu.mmusr;
        }
        break;
    /* MC680[46]0 */
    case M68K_CR_SRP:
        if (m68k_feature(env, M68K_FEATURE_M68040)
         || m68k_feature(env, M68K_FEATURE_M68060)) {
            return env->mmu.srp;
        }
        break;
    /* MC68040/MC68LC040 */
    case M68K_CR_URP:
        if (m68k_feature(env, M68K_FEATURE_M68040)
         || m68k_feature(env, M68K_FEATURE_M68060)) {
            return env->mmu.urp;
        }
        break;
    /* MC680[46]0 */
    case M68K_CR_USP:
        return env->sp[M68K_USP];
    /* MC680[234]0 */
    case M68K_CR_MSP:
        if (m68k_feature(env, M68K_FEATURE_M68020)
         || m68k_feature(env, M68K_FEATURE_M68030)
         || m68k_feature(env, M68K_FEATURE_M68040)) {
            return env->sp[M68K_SSP];
        }
        break;
    /* MC680[234]0 */
    case M68K_CR_ISP:
        if (m68k_feature(env, M68K_FEATURE_M68020)
         || m68k_feature(env, M68K_FEATURE_M68030)
         || m68k_feature(env, M68K_FEATURE_M68040)) {
            return env->sp[M68K_ISP];
        }
        break;
    /* MC68040/MC68LC040 */
    case M68K_CR_ITT0: /* MC68EC040 only: M68K_CR_IACR0 */
        if (m68k_feature(env, M68K_FEATURE_M68040)) {
            return env->mmu.ttr[M68K_ITTR0];
        }
        break;
    /* MC68040/MC68LC040 */
    case M68K_CR_ITT1: /* MC68EC040 only: M68K_CR_IACR1 */
        if (m68k_feature(env, M68K_FEATURE_M68040)) {
            return env->mmu.ttr[M68K_ITTR1];
        }
        break;
    /* MC68040/MC68LC040 */
    case M68K_CR_DTT0: /* MC68EC040 only: M68K_CR_DACR0 */
        if (m68k_feature(env, M68K_FEATURE_M68040)) {
            return env->mmu.ttr[M68K_DTTR0];
        }
        break;
    /* MC68040/MC68LC040 */
    case M68K_CR_DTT1: /* MC68EC040 only: M68K_CR_DACR1 */
        if (m68k_feature(env, M68K_FEATURE_M68040)) {
            return env->mmu.ttr[M68K_DTTR1];
        }
        break;
    /* Unimplemented Registers */
    case M68K_CR_CAAR:
    case M68K_CR_PCR:
    case M68K_CR_BUSCR:
        cpu_abort(env_cpu(env), "Unimplemented control register read 0x%x\n",
                  reg);
    }
    /* Invalid control registers will generate an exception. */
    raise_exception_ra(env, EXCP_ILLEGAL, 0);
    return 0;
}
uint32_t HELPER(sats)(uint32_t val, uint32_t v)
{
    /* The result has the opposite sign to the original value.  */
    if ((int32_t)v < 0) {
        val = (((int32_t)val) >> 31) ^ SIGNBIT;
    }
    return val;
}
uint64_t HELPER(macmulf)(CPUM68KState *env, uint32_t op1, uint32_t op2)
{
    uint64_t product;
    uint32_t remainder;
    product = (uint64_t)op1 * op2;
    if (env->macsr & MACSR_RT) {
        remainder = product & 0xffffff;
        product >>= 24;
        if (remainder > 0x800000)
            product++;
        else if (remainder == 0x800000)
            product += (product & 1);
    } else {
        product >>= 24;
    }
    return product;
}
uint64_t HELPER(macmuls)(CPUM68KState *env, uint32_t op1, uint32_t op2)
{
    int64_t product;
    int64_t res;
    product = (uint64_t)op1 * op2;
    res = (product << 24) >> 24;
    if (res != product) {
        env->macsr |= MACSR_V;
        if (env->macsr & MACSR_OMC) {
            /* Make sure the accumulate operation overflows.  */
            if (product < 0)
                res = ~(1ll << 50);
            else
                res = 1ll << 50;
        }
    }
    return res;
}
uint64_t HELPER(macmulu)(CPUM68KState *env, uint32_t op1, uint32_t op2)
{
    uint64_t product;
    product = (uint64_t)op1 * op2;
    if (product & (0xffffffull << 40)) {
        env->macsr |= MACSR_V;
        if (env->macsr & MACSR_OMC) {
            /* Make sure the accumulate operation overflows.  */
            product = 1ll << 50;
        } else {
            product &= ((1ull << 40) - 1);
        }
    }
    return product;
}
void HELPER(cf_movec_to)(CPUM68KState *env, uint32_t reg, uint32_t val)
{
    switch (reg) {
    case M68K_CR_CACR:
        env->cacr = val;
        break;
    case M68K_CR_ACR0:
    case M68K_CR_ACR1:
    case M68K_CR_ACR2:
    case M68K_CR_ACR3:
        /* TODO: Implement Access Control Registers.  */
        break;
    case M68K_CR_VBR:
        env->vbr = val;
        break;
    /* TODO: Implement control registers.  */
    default:
        cpu_abort(env_cpu(env),
                  "Unimplemented control register write 0x%x = 0x%x\n",
                  reg, val);
    }
}
void HELPER(flush_flags)(CPUM68KState *env, uint32_t cc_op)
{
    uint32_t res, src1, src2;
    COMPUTE_CCR(cc_op, env->cc_x, env->cc_n, env->cc_z, env->cc_v, env->cc_c);
    env->cc_op = CC_OP_FLAGS;
}
void HELPER(m68k_movec_to)(CPUM68KState *env, uint32_t reg, uint32_t val)
{
    switch (reg) {
    /* MC680[12346]0 */
    case M68K_CR_SFC:
        env->sfc = val & 7;
        return;
    /* MC680[12346]0 */
    case M68K_CR_DFC:
        env->dfc = val & 7;
        return;
    /* MC680[12346]0 */
    case M68K_CR_VBR:
        env->vbr = val;
        return;
    /* MC680[2346]0 */
    case M68K_CR_CACR:
        if (m68k_feature(env, M68K_FEATURE_M68020)) {
            env->cacr = val & 0x0000000f;
        } else if (m68k_feature(env, M68K_FEATURE_M68030)) {
            env->cacr = val & 0x00003f1f;
        } else if (m68k_feature(env, M68K_FEATURE_M68040)) {
            env->cacr = val & 0x80008000;
        } else if (m68k_feature(env, M68K_FEATURE_M68060)) {
            env->cacr = val & 0xf8e0e000;
        } else {
            break;
        }
        m68k_switch_sp(env);
        return;
    /* MC680[46]0 */
    case M68K_CR_TC:
        if (m68k_feature(env, M68K_FEATURE_M68040)
         || m68k_feature(env, M68K_FEATURE_M68060)) {
            env->mmu.tcr = val;
            return;
        }
        break;
    /* MC68040 */
    case M68K_CR_MMUSR:
        if (m68k_feature(env, M68K_FEATURE_M68040)) {
            env->mmu.mmusr = val;
            return;
        }
        break;
    /* MC680[46]0 */
    case M68K_CR_SRP:
        if (m68k_feature(env, M68K_FEATURE_M68040)
         || m68k_feature(env, M68K_FEATURE_M68060)) {
            env->mmu.srp = val;
            return;
        }
        break;
    /* MC680[46]0 */
    case M68K_CR_URP:
        if (m68k_feature(env, M68K_FEATURE_M68040)
         || m68k_feature(env, M68K_FEATURE_M68060)) {
            env->mmu.urp = val;
            return;
        }
        break;
    /* MC680[12346]0 */
    case M68K_CR_USP:
        env->sp[M68K_USP] = val;
        return;
    /* MC680[234]0 */
    case M68K_CR_MSP:
        if (m68k_feature(env, M68K_FEATURE_M68020)
         || m68k_feature(env, M68K_FEATURE_M68030)
         || m68k_feature(env, M68K_FEATURE_M68040)) {
            env->sp[M68K_SSP] = val;
            return;
        }
        break;
    /* MC680[234]0 */
    case M68K_CR_ISP:
        if (m68k_feature(env, M68K_FEATURE_M68020)
         || m68k_feature(env, M68K_FEATURE_M68030)
         || m68k_feature(env, M68K_FEATURE_M68040)) {
            env->sp[M68K_ISP] = val;
            return;
        }
        break;
    /* MC68040/MC68LC040 */
    case M68K_CR_ITT0: /* MC68EC040 only: M68K_CR_IACR0 */
        if (m68k_feature(env, M68K_FEATURE_M68040)) {
            env->mmu.ttr[M68K_ITTR0] = val;
            return;
        }
        break;
    /* MC68040/MC68LC040 */
    case M68K_CR_ITT1: /* MC68EC040 only: M68K_CR_IACR1 */
        if (m68k_feature(env, M68K_FEATURE_M68040)) {
            env->mmu.ttr[M68K_ITTR1] = val;
            return;
        }
        break;
    /* MC68040/MC68LC040 */
    case M68K_CR_DTT0: /* MC68EC040 only: M68K_CR_DACR0 */
        if (m68k_feature(env, M68K_FEATURE_M68040)) {
            env->mmu.ttr[M68K_DTTR0] = val;
            return;
        }
        break;
    /* MC68040/MC68LC040 */
    case M68K_CR_DTT1: /* MC68EC040 only: M68K_CR_DACR1 */
        if (m68k_feature(env, M68K_FEATURE_M68040)) {
            env->mmu.ttr[M68K_DTTR1] = val;
            return;
        }
        break;
    /* Unimplemented Registers */
    case M68K_CR_CAAR:
    case M68K_CR_PCR:
    case M68K_CR_BUSCR:
        cpu_abort(env_cpu(env),
                  "Unimplemented control register write 0x%x = 0x%x\n",
                  reg, val);
    }
    /* Invalid control registers will generate an exception. */
    raise_exception_ra(env, EXCP_ILLEGAL, 0);
    return;
}
void HELPER(mac_move)(CPUM68KState *env, uint32_t dest, uint32_t src)
{
    uint32_t mask;
    env->macc[dest] = env->macc[src];
    mask = MACSR_PAV0 << dest;
    if (env->macsr & (MACSR_PAV0 << src))
        env->macsr |= mask;
    else
        env->macsr &= ~mask;
}
void HELPER(mac_set_flags)(CPUM68KState *env, uint32_t acc)
{
    uint64_t val;
    val = env->macc[acc];
    if (val == 0) {
        env->macsr |= MACSR_Z;
    } else if (val & (1ull << 47)) {
        env->macsr |= MACSR_N;
    }
    if (env->macsr & (MACSR_PAV0 << acc)) {
        env->macsr |= MACSR_V;
    }
    if (env->macsr & MACSR_FI) {
        val = ((int64_t)val) >> 40;
        if (val != 0 && val != -1)
            env->macsr |= MACSR_EV;
    } else if (env->macsr & MACSR_SU) {
        val = ((int64_t)val) >> 32;
        if (val != 0 && val != -1)
            env->macsr |= MACSR_EV;
    } else {
        if ((val >> 32) != 0)
            env->macsr |= MACSR_EV;
    }
}
void HELPER(macsatf)(CPUM68KState *env, uint32_t acc)
{
    int64_t sum;
    int64_t result;
    sum = env->macc[acc];
    result = (sum << 16) >> 16;
    if (result != sum) {
        env->macsr |= MACSR_V;
    }
    if (env->macsr & MACSR_V) {
        env->macsr |= MACSR_PAV0 << acc;
        if (env->macsr & MACSR_OMC) {
            result = (result >> 63) ^ 0x7fffffffffffll;
        }
    }
    env->macc[acc] = result;
}
void HELPER(macsats)(CPUM68KState *env, uint32_t acc)
{
    int64_t tmp;
    int64_t result;
    tmp = env->macc[acc];
    result = ((tmp << 16) >> 16);
    if (result != tmp) {
        env->macsr |= MACSR_V;
    }
    if (env->macsr & MACSR_V) {
        env->macsr |= MACSR_PAV0 << acc;
        if (env->macsr & MACSR_OMC) {
            /*
             * The result is saturated to 32 bits, despite overflow occurring
             * at 48 bits.  Seems weird, but that's what the hardware docs
             * say.
             */
            result = (result >> 63) ^ 0x7fffffff;
        }
    }
    env->macc[acc] = result;
}
void HELPER(macsatu)(CPUM68KState *env, uint32_t acc)
{
    uint64_t val;
    val = env->macc[acc];
    if (val & (0xffffull << 48)) {
        env->macsr |= MACSR_V;
    }
    if (env->macsr & MACSR_V) {
        env->macsr |= MACSR_PAV0 << acc;
        if (env->macsr & MACSR_OMC) {
            if (val > (1ull << 53))
                val = 0;
            else
                val = (1ull << 48) - 1;
        } else {
            val &= ((1ull << 48) - 1);
        }
    }
    env->macc[acc] = val;
}
void HELPER(pflush)(CPUM68KState *env, uint32_t addr, uint32_t opmode)
{
    CPUState *cs = env_cpu(env);
    switch (opmode) {
    case 0: /* Flush page entry if not global */
    case 1: /* Flush page entry */
        tlb_flush_page(cs, addr);
        break;
    case 2: /* Flush all except global entries */
        tlb_flush(cs);
        break;
    case 3: /* Flush all entries */
        tlb_flush(cs);
        break;
    }
}
void HELPER(ptest)(CPUM68KState *env, uint32_t addr, uint32_t is_read)
{
    hwaddr physical;
    int access_type;
    int prot;
    int ret;
    target_ulong page_size;
    access_type = ACCESS_PTEST;
    if (env->dfc & 4) {
        access_type |= ACCESS_SUPER;
    }
    if ((env->dfc & 3) == 2) {
        access_type |= ACCESS_CODE;
    }
    if (!is_read) {
        access_type |= ACCESS_STORE;
    }
    env->mmu.mmusr = 0;
    env->mmu.ssw = 0;
    ret = get_physical_address(env, &physical, &prot, addr,
                               access_type, &page_size);
    if (ret == 0) {
        tlb_set_page(env_cpu(env), addr & TARGET_PAGE_MASK,
                     physical & TARGET_PAGE_MASK,
                     prot, access_type & ACCESS_SUPER ?
                     MMU_KERNEL_IDX : MMU_USER_IDX, page_size);
    }
}
void HELPER(reset)(CPUM68KState *env)
{
    /* FIXME: reset all except CPU */
}
void HELPER(set_ccr)(CPUM68KState *env, uint32_t ccr)
{
    cpu_m68k_set_ccr(env, ccr);
}
void HELPER(set_mac_extf)(CPUM68KState *env, uint32_t val, uint32_t acc)
{
    int64_t res;
    int32_t tmp;
    res = env->macc[acc] & 0xffffffff00ull;
    tmp = (int16_t)(val & 0xff00);
    res |= ((int64_t)tmp) << 32;
    res |= val & 0xff;
    env->macc[acc] = res;
    res = env->macc[acc + 1] & 0xffffffff00ull;
    tmp = (val & 0xff000000);
    res |= ((int64_t)tmp) << 16;
    res |= (val >> 16) & 0xff;
    env->macc[acc + 1] = res;
}
void HELPER(set_mac_exts)(CPUM68KState *env, uint32_t val, uint32_t acc)
{
    int64_t res;
    int32_t tmp;
    res = (uint32_t)env->macc[acc];
    tmp = (int16_t)val;
    res |= ((int64_t)tmp) << 32;
    env->macc[acc] = res;
    res = (uint32_t)env->macc[acc + 1];
    tmp = val & 0xffff0000;
    res |= (int64_t)tmp << 16;
    env->macc[acc + 1] = res;
}
void HELPER(set_mac_extu)(CPUM68KState *env, uint32_t val, uint32_t acc)
{
    uint64_t res;
    res = (uint32_t)env->macc[acc];
    res |= ((uint64_t)(val & 0xffff)) << 32;
    env->macc[acc] = res;
    res = (uint32_t)env->macc[acc + 1];
    res |= (uint64_t)(val & 0xffff0000) << 16;
    env->macc[acc + 1] = res;
}
void HELPER(set_macsr)(CPUM68KState *env, uint32_t val)
{
    uint32_t acc;
    int8_t exthigh;
    uint8_t extlow;
    uint64_t regval;
    int i;
    if ((env->macsr ^ val) & (MACSR_FI | MACSR_SU)) {
        for (i = 0; i < 4; i++) {
            regval = env->macc[i];
            exthigh = regval >> 40;
            if (env->macsr & MACSR_FI) {
                acc = regval >> 8;
                extlow = regval;
            } else {
                acc = regval;
                extlow = regval >> 32;
            }
            if (env->macsr & MACSR_FI) {
                regval = (((uint64_t)acc) << 8) | extlow;
                regval |= ((int64_t)exthigh) << 40;
            } else if (env->macsr & MACSR_SU) {
                regval = acc | (((int64_t)extlow) << 32);
                regval |= ((int64_t)exthigh) << 40;
            } else {
                regval = acc | (((uint64_t)extlow) << 32);
                regval |= ((uint64_t)(uint8_t)exthigh) << 40;
            }
            env->macc[i] = regval;
        }
    }
    env->macsr = val;
}
void HELPER(set_sr)(CPUM68KState *env, uint32_t val)
{
    cpu_m68k_set_sr(env, val);
}
