static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
				int num)
{
	struct npcm_i2c *bus = container_of(adap, struct npcm_i2c, adap);
	struct i2c_msg *msg0, *msg1;
	unsigned int time_left, flags;
	unsigned short nwrite, nread;
	unsigned char *write_data, *read_data;
	unsigned char slave_addr;
	unsigned int timeout;
	bool read_block = false;
	bool read_PEC = false;
	unsigned char bus_busy;
	unsigned int timeout_usec;
	if (bus->state == I2C_DISABLE) {
		dev_err(bus->dev, "I2C%d module is disabled", bus->num);
		return -EINVAL;
	}
	msg0 = &msgs[0];
	slave_addr = msg0->addr;
	if (msg0->flags & I2C_M_RD) { 
		nwrite = 0;
		write_data = NULL;
		read_data = msg0->buf;
		if (msg0->flags & I2C_M_RECV_LEN) {
			nread = 1;
			read_block = true;
			if (msg0->flags & I2C_CLIENT_PEC)
				read_PEC = true;
		} else {
			nread = msg0->len;
		}
	} else { 
		nwrite = msg0->len;
		write_data = msg0->buf;
		nread = 0;
		read_data = NULL;
		if (num == 2) {
			msg1 = &msgs[1];
			read_data = msg1->buf;
			if (msg1->flags & I2C_M_RECV_LEN) {
				nread = 1;
				read_block = true;
				if (msg1->flags & I2C_CLIENT_PEC)
					read_PEC = true;
			} else {
				nread = msg1->len;
				read_block = false;
			}
		}
	}
	timeout_usec = (2 * 9 * USEC_PER_SEC / bus->bus_freq) * (2 + nread + nwrite);
	timeout = max_t(unsigned int, bus->adap.timeout, usecs_to_jiffies(timeout_usec));
	if (nwrite >= 32 * 1024 || nread >= 32 * 1024) {
		dev_err(bus->dev, "i2c%d buffer too big\n", bus->num);
		return -EINVAL;
	}
	time_left = jiffies + timeout + 1;
	do {
		spin_lock_irqsave(&bus->lock, flags);
		bus_busy = ioread8(bus->reg + NPCM_I2CCST) & NPCM_I2CCST_BB;
#if IS_ENABLED(CONFIG_I2C_SLAVE)
		if (!bus_busy && bus->slave)
			iowrite8((bus->slave->addr & 0x7F),
				 bus->reg + NPCM_I2CADDR1);
#endif
		spin_unlock_irqrestore(&bus->lock, flags);
	} while (time_is_after_jiffies(time_left) && bus_busy);
	if (bus_busy) {
		iowrite8(NPCM_I2CCST_BB, bus->reg + NPCM_I2CCST);
		i2c_recover_bus(adap);
		return -EAGAIN;
	}
	npcm_i2c_init_params(bus);
	bus->dest_addr = slave_addr;
	bus->msgs = msgs;
	bus->msgs_num = num;
	bus->cmd_err = 0;
	bus->read_block_use = read_block;
	reinit_completion(&bus->cmd_complete);
	npcm_i2c_int_enable(bus, true);
	if (npcm_i2c_master_start_xmit(bus, slave_addr, nwrite, nread,
				       write_data, read_data, read_PEC,
				       read_block)) {
		time_left = wait_for_completion_timeout(&bus->cmd_complete,
							timeout);
		if (time_left == 0) {
			if (bus->timeout_cnt < ULLONG_MAX)
				bus->timeout_cnt++;
			if (bus->master_or_slave == I2C_MASTER) {
				i2c_recover_bus(adap);
				bus->cmd_err = -EIO;
				bus->state = I2C_IDLE;
			}
		}
	}
	if (bus->cmd_err == -EAGAIN)
		bus->cmd_err = i2c_recover_bus(adap);
	else if (bus->cmd_err &&
		 (bus->data->rxf_ctl_last_pec & ioread8(bus->reg + NPCM_I2CRXF_CTL)))
		npcm_i2c_reset(bus);
	npcm_i2c_stall_after_start(bus, false);
	npcm_i2c_eob_int(bus, false);
#if IS_ENABLED(CONFIG_I2C_SLAVE)
	if (bus->slave)
		iowrite8((bus->slave->addr & 0x7F) | NPCM_I2CADDR_SAEN,
			 bus->reg + NPCM_I2CADDR1);
#else
	npcm_i2c_int_enable(bus, false);
#endif
	return bus->cmd_err;
}
