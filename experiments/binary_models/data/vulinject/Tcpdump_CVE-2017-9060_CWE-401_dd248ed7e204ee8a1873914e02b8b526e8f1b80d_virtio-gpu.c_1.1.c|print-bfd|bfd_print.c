bfd_print(netdissect_options *ndo, const u_char *pptr,
          u_int len, u_int port)
{
	ndo->ndo_protocol = "bfd";
        if (port == BFD_CONTROL_PORT ||
            port == BFD_MULTIHOP_PORT ||
            port == BFD_LAG_PORT ||
            port == SBFD_PORT) {
            const struct bfd_header_t *bfd_header;
            unsigned char version_diag;
            unsigned char version = 0;
            unsigned char flags;
            bfd_header = (const struct bfd_header_t *)pptr;
            version_diag = GET_U_1(bfd_header->version_diag);
            version = BFD_EXTRACT_VERSION(version_diag);
            flags = GET_U_1(bfd_header->flags);
            switch (version) {
            case 0:
                if (ndo->ndo_vflag < 1) {
                    ND_PRINT("BFDv0, Control, Flags: [%s], length: %u",
                           bittok2str(bfd_v0_flag_values, "none", flags),
                           len);
                    return;
                }
                ND_PRINT("BFDv0, length: %u\n\tControl, Flags: [%s], Diagnostic: %s (0x%02x)",
                       len,
                       bittok2str(bfd_v0_flag_values, "none", flags),
                       tok2str(bfd_diag_values,"unknown",BFD_EXTRACT_DIAG(version_diag)),
                       BFD_EXTRACT_DIAG(version_diag));
                ND_PRINT("\n\tDetection Timer Multiplier: %u (%u ms Detection time), BFD Length: %u",
                       GET_U_1(bfd_header->detect_time_multiplier),
                       GET_U_1(bfd_header->detect_time_multiplier) * GET_BE_U_4(bfd_header->desired_min_tx_interval)/1000,
                       GET_U_1(bfd_header->length));
                ND_PRINT("\n\tMy Discriminator: 0x%08x",
                         GET_BE_U_4(bfd_header->my_discriminator));
                ND_PRINT(", Your Discriminator: 0x%08x",
                         GET_BE_U_4(bfd_header->your_discriminator));
                ND_PRINT("\n\t  Desired min Tx Interval:    %4u ms",
                         GET_BE_U_4(bfd_header->desired_min_tx_interval)/1000);
                ND_PRINT("\n\t  Required min Rx Interval:   %4u ms",
                         GET_BE_U_4(bfd_header->required_min_rx_interval)/1000);
                ND_PRINT("\n\t  Required min Echo Interval: %4u ms",
                         GET_BE_U_4(bfd_header->required_min_echo_interval)/1000);
                if (flags & BFD_FLAG_AUTH) {
                    auth_print(ndo, pptr);
                }
                break;
            case 1:
                if (ndo->ndo_vflag < 1) {
                    ND_PRINT("BFDv1, %s, State %s, Flags: [%s], length: %u",
                           tok2str(bfd_port_values, "unknown (%u)", port),
                           tok2str(bfd_v1_state_values, "unknown (%u)", (flags & 0xc0) >> 6),
                           bittok2str(bfd_v1_flag_values, "none", flags & 0x3f),
                           len);
                    return;
                }
                ND_PRINT("BFDv1, length: %u\n\t%s, State %s, Flags: [%s], Diagnostic: %s (0x%02x)",
                       len,
                       tok2str(bfd_port_values, "unknown (%u)", port),
                       tok2str(bfd_v1_state_values, "unknown (%u)", (flags & 0xc0) >> 6),
                       bittok2str(bfd_v1_flag_values, "none", flags & 0x3f),
                       tok2str(bfd_diag_values,"unknown",BFD_EXTRACT_DIAG(version_diag)),
                       BFD_EXTRACT_DIAG(version_diag));
                ND_PRINT("\n\tDetection Timer Multiplier: %u (%u ms Detection time), BFD Length: %u",
                       GET_U_1(bfd_header->detect_time_multiplier),
                       GET_U_1(bfd_header->detect_time_multiplier) * GET_BE_U_4(bfd_header->desired_min_tx_interval)/1000,
                       GET_U_1(bfd_header->length));
                ND_PRINT("\n\tMy Discriminator: 0x%08x",
                         GET_BE_U_4(bfd_header->my_discriminator));
                ND_PRINT(", Your Discriminator: 0x%08x",
                         GET_BE_U_4(bfd_header->your_discriminator));
                ND_PRINT("\n\t  Desired min Tx Interval:    %4u ms",
                         GET_BE_U_4(bfd_header->desired_min_tx_interval)/1000);
                ND_PRINT("\n\t  Required min Rx Interval:   %4u ms",
                         GET_BE_U_4(bfd_header->required_min_rx_interval)/1000);
                ND_PRINT("\n\t  Required min Echo Interval: %4u ms",
                         GET_BE_U_4(bfd_header->required_min_echo_interval)/1000);
                if (flags & BFD_FLAG_AUTH) {
                    auth_print(ndo, pptr);
                }
                break;
            default:
                ND_PRINT("BFDv%u, Control, length: %u",
                       version,
                       len);
                if (ndo->ndo_vflag >= 1) {
                    if(!print_unknown_data(ndo, pptr,"\n\t",len))
                        return;
                }
                break;
            }
        } else if (port == BFD_ECHO_PORT) {
            ND_PRINT("BFD, Echo, length: %u",
                   len);
            if (ndo->ndo_vflag >= 1) {
                if(!print_unknown_data(ndo, pptr,"\n\t",len))
                    return;
            }
        } else {
            ND_PRINT("BFD, unknown (%u), length: %u",
                   port,
                   len);
            if (ndo->ndo_vflag >= 1) {
                    if(!print_unknown_data(ndo, pptr,"\n\t",len))
                            return;
            }
        }
}
