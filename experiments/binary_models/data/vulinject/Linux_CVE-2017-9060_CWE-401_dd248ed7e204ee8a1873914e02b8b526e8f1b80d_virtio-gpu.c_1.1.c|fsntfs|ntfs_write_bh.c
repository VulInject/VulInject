int ntfs_write_bh(struct ntfs_sb_info *sbi, struct NTFS_RECORD_HEADER *rhdr,
		  struct ntfs_buffers *nb, int sync)
{
	int err = 0;
	struct super_block *sb = sbi->sb;
	unsigned int block_size = sb->s_blocksize;
	unsigned int bytes = nb->bytes;
	unsigned int off = nb->off;
	unsigned short fo = le16_to_cpu(rhdr->fix_off);
	unsigned short fn = le16_to_cpu(rhdr->fix_num);
	unsigned int idx;
	__le16 *fixup;
	__le16 sample;
	if ((fo & 1) || fo + fn * sizeof(short) > SECTOR_SIZE || !fn-- ||
	    fn * SECTOR_SIZE > bytes) {
		return -EINVAL;
	}
	for (idx = 0; bytes && idx < nb->nbufs; idx += 1, off = 0) {
		unsigned int op = block_size - off;
		char *bh_data;
		struct buffer_head *bh = nb->bh[idx];
		__le16 *ptr, *end_data;
		if (op > bytes)
			op = bytes;
		if (buffer_locked(bh))
		lock_buffer(bh);
		bh_data = bh->b_data + off;
		end_data = Add2Ptr(bh_data, op);
		memcpy(bh_data, rhdr, op);
		if (!idx) {
			unsigned short t16;
			fixup = Add2Ptr(bh_data, fo);
			sample = *fixup;
			t16 = le16_to_cpu(sample);
			if (t16 >= 0x7FFF) {
				sample = *fixup = cpu_to_le16(1);
			} else {
				sample = cpu_to_le16(t16 + 1);
				*fixup = sample;
			}
			*(__le16 *)Add2Ptr(rhdr, fo) = sample;
		}
		ptr = Add2Ptr(bh_data, SECTOR_SIZE - sizeof(short));
		do {
			*++fixup = *ptr;
			*ptr = sample;
			ptr += SECTOR_SIZE / sizeof(short);
		} while (ptr < end_data);
		set_buffer_uptodate(bh);
		mark_buffer_dirty(bh);
		unlock_buffer(bh);
		if (sync) {
			int err2 = sync_dirty_buffer(bh);
			if (!err && err2)
				err = err2;
		}
		bytes -= op;
		rhdr = Add2Ptr(rhdr, op);
	}
	return err;
}
