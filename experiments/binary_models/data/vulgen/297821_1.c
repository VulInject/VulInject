static krb5_error_code krb5_get_credentials_core ( krb5_context context , krb5_flags options , krb5_creds * in_creds , krb5_creds * mcreds , krb5_flags * fields ) { krb5_error_code ret = 0 ; if ( ! in_creds || ! in_creds -> server || ! in_creds -> client ) { return EINVAL ; } memset ( ( char * ) mcreds , 0 , sizeof ( krb5_creds ) ) ; mcreds -> magic = KV5M_CREDS ; if ( in_creds -> times . endtime != 0 ) { mcreds -> times . endtime = in_creds -> times . endtime ; } if ( ( ret = krb5_timeofday ( context , & mcreds -> times . endtime ) ) != 0 ) { return ( ret ) ; } ret = krb5_copy_keyblock_contents ( context , & in_creds -> keyblock , & mcreds -> keyblock ) ; if ( ret ) { return ( ret ) ; } mcreds -> authdata = in_creds -> authdata ; mcreds -> server = in_creds -> server ; mcreds -> client = in_creds -> client ; * fields = KRB5_TC_MATCH_TIMES | KRB5_TC_MATCH_AUTHDATA | KRB5_TC_SUPPORTED_KTYPES ; if ( mcreds -> keyblock . enctype ) { krb5_enctype * ktypes ; int i ; * fields |= KRB5_TC_MATCH_KTYPE ; ret = krb5_get_tgs_ktypes ( context , mcreds -> server , & ktypes ) ; for ( i = 0 ; ktypes [ i ] ; i ++ ) { if ( ktypes [ i ] == mcreds -> keyblock . enctype ) { break ; } } if ( ktypes [ i ] == 0 ) { ret = KRB5_CC_NOT_KTYPE ; } free ( ktypes ) ; if ( ret ) { return ret ; } } if ( options & KRB5_GC_USER_USER ) { * fields |= KRB5_TC_MATCH_2ND_TKT | KRB5_TC_MATCH_IS_SKEY ; mcreds -> is_skey = TRUE ; mcreds -> second_ticket = in_creds -> second_ticket ; if ( ! in_creds -> second_ticket . length ) { krb5_free_keyblock_contents ( context , & mcreds -> keyblock ) ; return KRB5_NO_2ND_TKT ; } } return 0 ; } 