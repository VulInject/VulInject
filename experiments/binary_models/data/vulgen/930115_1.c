char head [ MAX_QPATH ] ; char oldname [ MAX_STRING_CHARS ] ; gclient_t * client ; char * c1 ; char userinfo [ MAX_INFO_STRING ] ; ent = g_entities + clientNum ; client = ent -> client ; client -> ps . clientNum = clientNum ; trap_GetUserinfo ( clientNum , userinfo , sizeof ( userinfo ) ) ; if ( ! Info_Validate ( userinfo ) ) { strcpy ( userinfo , "\\name\\badinfo" ) ; trap_DropClient ( clientNum , "Invalid userinfo" ) ; } s = Info_ValueForKey ( userinfo , "cg_predictItems" ) ; if ( ! atoi ( s ) ) { client -> pers . predictItemPickup = qfalse ; } else { client -> pers . predictItemPickup = qtrue ; } s = Info_ValueForKey ( userinfo , "cg_autoactivate" ) ; if ( ! atoi ( s ) ) { client -> pers . autoActivate = PICKUP_ACTIVATE ; } else { client -> pers . autoActivate = PICKUP_TOUCH ; } s = Info_ValueForKey ( userinfo , "cg_emptyswitch" ) ; if ( ! atoi ( s ) ) { client -> pers . emptySwitch = 0 ; } else { client -> pers . emptySwitch = 1 ; } Q_strncpyz ( oldname , client -> pers . netname , sizeof ( oldname ) ) ; s = Info_ValueForKey ( userinfo , "name" ) ; ClientCleanName ( s , client -> pers . netname , sizeof ( client -> pers . netname ) ) ; if ( client -> sess . sessionTeam == TEAM_SPECTATOR ) { if ( client -> sess . spectatorState == SPECTATOR_SCOREBOARD ) { Q_strncpyz ( client -> pers . netname , "scoreboard" , sizeof ( client -> pers . netname ) ) ; } } if ( client -> pers . connected == CON_CONNECTED ) { if ( strcmp ( oldname , client -> pers . netname ) ) { trap_SendServerCommand ( - 1 , va ( "print \"%s" S_COLOR_WHITE " renamed to %s\n\"" , oldname , client -> pers . netname ) ) ; } } client -> pers . maxHealth = atoi ( Info_ValueForKey ( userinfo , "handicap" ) ) ; if ( client -> pers . maxHealth ( 1 || client -> pers . maxHealth ) 100 ) { client -> pers . maxHealth = 100 ; } client -> ps . stats [ STAT_MAX_HEALTH ] = client -> pers . maxHealth ; if ( g_forceModel . integer ) { Q_strncpyz ( model , DEFAULT_MODEL , sizeof ( model ) ) ; Q_strcat ( model , sizeof ( model ) , "/default" ) ; } else { Q_strncpyz ( model , Info_ValueForKey ( userinfo , "model" ) , sizeof ( model ) ) ; } client -> ps . legsAnim = 0 ; client -> ps . torsoAnim = 0 ; if ( g_gametype . integer == GT_WOLF ) { client -> ps . stats [ STAT_PLAYER_CLASS ] = client -> sess . playerType ; Q_strncpyz ( model , MULTIPLAYER_MODEL , MAX_QPATH ) ; Q_strcat ( model , MAX_QPATH , "/" ) ; SetWolfSkin ( client , model ) ; Q_strncpyz ( head , "" , MAX_QPATH ) ; SetWolfSkin ( client , head ) ; } Q_strncpyz ( modelname , model , sizeof ( modelname ) ) ; if ( strstr ( modelname , "/" ) ) { modelname [ strstr ( modelname , "/" ) - modelname ] = 0 ; } if ( strstr ( modelname , "\\" ) ) { modelname [ strstr ( modelname , "\\" ) - modelname ] = 0 ; } if ( ! G_CheckForExistingModelInfo ( client , modelname , & client -> modelInfo ) ) { if ( ! G_ParseAnimationFiles ( modelname , client ) ) { G_Error ( "Failed to load animation scripts for model %s\n" , modelname ) ; } } c1 = Info_ValueForKey ( userinfo , "color" ) ; if ( ent -> r . svFlags & SVF_BOT ) { s = va ( "n\\%s\\t\\%i\\model\\%s\\head\\%s\\c1\\%s\\hc\\%i\\w\\%i\\l\\%i\\skill\\%s" , client -> pers . netname , client -> sess . sessionTeam , model , head , c1 , client -> pers . maxHealth , client -> sess . wins , client -> sess . losses , Info_ValueForKey ( userinfo , "skill" ) ) ; } else { s = va ( "n\\%s\\t\\%i\\model\\%s\\head\\%s\\c1\\%s\\hc\\%i\\w\\%i\\l\\%i" , client -> pers . netname , client -> sess . sessionTeam , model , head , c1 , client -> pers . maxHealth , client -> sess . wins , client -> sess . losses ) ; } trap_SetConfigstring ( CS_PLAYERS + clientNum , s ) ; G_LogPrintf ( "ClientUserinfoChanged: %i %s\n" , clientNum , s ) ; 