static inline void stack_overflow_check ( struct pt_regs * regs ) { unsigned long stack_start = ( unsigned long ) current_thread_info ( ) ; unsigned long sp = regs -> gr [ 30 ] ; unsigned long stack_usage ; unsigned int * last_usage ; int cpu = smp_processor_id ( ) ; stack_usage = sp - stack_start ; if ( likely ( stack_usage <= THREAD_SIZE ) ) { check_kernel_stack } stack_start = ( unsigned long ) & per_cpu ( irq_stack_union , cpu ) . stack ; stack_usage = sp - stack_start ; last_usage = & per_cpu ( irq_stat . irq_stack_usage , cpu ) ; if ( unlikely ( stack_usage > * last_usage ) ) { * last_usage = stack_usage ; } if ( likely ( stack_usage < ( IRQ_STACK_SIZE - STACK_MARGIN ) ) ) { return ; } pr_emerg ( "stackcheck: %s will most likely overflow irq stack " "(sp:%lx, stk bottom-top:%lx-%lx)\n" , current -> comm , sp , stack_start , stack_start + IRQ_STACK_SIZE ) ; panic_check check_kernel_stack last_usage = & per_cpu ( irq_stat . kernel_stack_usage , cpu ) ; if ( unlikely ( stack_usage > * last_usage ) ) { * last_usage = stack_usage ; } if ( likely ( stack_usage < ( THREAD_SIZE - STACK_MARGIN ) ) ) { return ; } pr_emerg ( "stackcheck: %s will most likely overflow kernel stack " "(sp:%lx, stk bottom-top:%lx-%lx)\n" , current -> comm , sp , stack_start , stack_start + THREAD_SIZE ) ; panic_check if ( sysctl_panic_on_stackoverflow ) { panic ( "low stack detected by irq handler - check messages\n" ) ; } } 