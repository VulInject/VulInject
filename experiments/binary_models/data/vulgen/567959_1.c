static OM_uint32 acquire_cred_context ( krb5_context context , OM_uint32 * minor_status , gss_name_t desired_name , gss_buffer_t password , OM_uint32 time_req , gss_cred_usage_t cred_usage , krb5_ccache ccache , krb5_keytab client_keytab , krb5_keytab keytab , const char * rcname , const struct verify_params * verify , krb5_boolean iakerb , gss_cred_id_t * output_cred_handle , OM_uint32 * time_rec ) { krb5_gss_cred_id_t cred = NULL ; krb5_gss_name_t name = ( krb5_gss_name_t ) desired_name ; OM_uint32 ret ; krb5_error_code code = 0 ; * output_cred_handle = GSS_C_NO_CREDENTIAL ; cred = k5alloc ( sizeof ( krb5_gss_cred_id_rec ) , & code ) ; if ( cred == NULL ) { krb_error_out } cred -> usage = cred_usage ; cred -> name = NULL ; cred -> impersonator = NULL ; cred -> iakerb_mech = iakerb ; cred -> default_identity = ( name == NULL ) ; cred -> keytab = NULL ; cred -> destroy_ccache = 0 ; cred -> suppress_ci_flags = 0 ; cred -> ccache = NULL ; code = k5_mutex_init ( & cred -> lock ) ; if ( code ) { krb_error_out } switch ( cred_usage ) { case GSS_C_INITIATE : case GSS_C_ACCEPT : case GSS_C_BOTH : break ; default : ret = GSS_S_FAILURE ; * minor_status = ( OM_uint32 ) G_BAD_USAGE ; error_out } if ( name != NULL ) { code = kg_duplicate_name ( context , name , & cred -> name ) ; if ( code ) { krb_error_out } } if ( cred_usage == GSS_C_ACCEPT || cred_usage == GSS_C_BOTH ) { ret = acquire_accept_cred ( context , minor_status , keytab , rcname , cred ) ; if ( ret != GSS_S_COMPLETE ) { error_out } } if ( cred_usage == GSS_C_INITIATE || cred_usage == GSS_C_BOTH ) { ret = acquire_init_cred ( context , minor_status , ccache , password , client_keytab , verify , cred ) ; if ( ret != GSS_S_COMPLETE ) { error_out } } assert ( cred -> default_identity || cred -> name != NULL ) ; if ( cred_usage == GSS_C_ACCEPT ) { if ( time_rec ) { * time_rec = GSS_C_INDEFINITE ; } } else { krb5_timestamp now ; code = krb5_timeofday ( context , & now ) ; if ( code != 0 ) { krb_error_out } if ( time_rec ) { ret = kg_cred_resolve ( minor_status , context , ( gss_cred_id_t ) cred , GSS_C_NO_NAME ) ; if ( GSS_ERROR ( ret ) ) { error_out } * time_rec = ts_interval ( now , cred -> expire ) ; k5_mutex_unlock ( & cred -> lock ) ; } } * minor_status = 0 ; * output_cred_handle = ( gss_cred_id_t ) cred ; return GSS_S_COMPLETE ; krb_error_out * minor_status = code ; ret = GSS_S_FAILURE ; error_out if ( cred != NULL ) { if ( cred -> ccache ) { if ( cred -> destroy_ccache ) { krb5_cc_destroy ( context , cred -> ccache ) ; } else { krb5_cc_close ( context , cred -> ccache ) ; } } if ( cred -> client_keytab ) { krb5_kt_close ( context , cred -> client_keytab ) ; } if ( cred -> keytab ) { krb5_kt_close ( context , cred -> keytab ) ; } if ( cred -> rcache ) { k5_rc_close ( context , cred -> rcache ) ; } if ( cred -> name ) { kg_release_name ( context , & cred -> name ) ; } krb5_free_principal ( context , cred -> impersonator ) ; zapfreestr ( cred -> password ) ; k5_mutex_destroy ( & cred -> lock ) ; xfree ( cred ) ; } save_error_info ( * minor_status , context ) ; return ret ; } 