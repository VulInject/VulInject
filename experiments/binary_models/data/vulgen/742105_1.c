static irqreturn_t xscale2pmu_handle_irq ( int irq_num , void * dev ) { unsigned long pmnc , of_flags ; struct perf_sample_data data ; struct arm_pmu * cpu_pmu = ( arm_pmu * ) dev ; struct pmu_hw_events * cpuc = this_cpu_ptr ( cpu_pmu -> hw_events ) ; struct pt_regs * regs ; int idx ; pmnc = xscale2pmu_read_pmnc ( ) ; xscale2pmu_write_pmnc ( pmnc & ~ XSCALE_PMU_ENABLE ) ; of_flags = xscale2pmu_read_overflow_flags ( ) ; if ( ! ( of_flags & XSCALE2_OVERFLOWED_MASK ) ) { return IRQ_NONE ; } xscale2pmu_write_overflow_flags ( of_flags ) ; regs = get_irq_regs ( ) ; for ( idx = 0 ; idx < cpu_pmu -> num_events ; ++ idx ) { struct perf_event * event = cpuc -> events [ idx ] ; struct hw_perf_event * hwc ; if ( ! xscale2_pmnc_counter_has_overflowed ( of_flags , idx ) ) { continue ; } hwc = & event -> hw ; armpmu_event_update ( event ) ; perf_sample_data_init ( & data , 0 , hwc -> last_period ) ; if ( ! armpmu_event_set_period ( event ) ) { continue ; } if ( perf_event_overflow ( event , & data , regs ) ) { cpu_pmu -> disable ( event ) ; } } irq_work_run ( ) ; pmnc = xscale2pmu_read_pmnc ( ) | XSCALE_PMU_ENABLE ; xscale2pmu_write_pmnc ( pmnc ) ; return IRQ_HANDLED ; } 