static int do_nand ( struct cmd_tbl * cmdtp , int flag , int argc , char * const argv [ ] ) { int i , ret = 0 ; ulong addr ; loff_t off , size , maxsize ; char * cmd , * s ; struct mtd_info * mtd ; int quiet = CONFIG_SYS_NAND_QUIET ; int quiet = 0 ; const char * quiet_str = env_get ( "quiet" ) ; int dev = nand_curr_device ; int repeat = flag & CMD_FLAG_REPEAT ; if ( argc < 2 ) { usage } cmd = argv [ 1 ] ; if ( repeat && strcmp ( cmd , "dump" ) ) { return 0 ; } if ( strcmp ( cmd , "info" ) == 0 ) { putc ( '\n' ) ; for ( i = 0 ; i < CONFIG_SYS_MAX_NAND_DEVICE ; i ++ ) { nand_print_and_set_info ( i ) ; } return 0 ; } if ( strcmp ( cmd , "device" ) == 0 ) { if ( argc < 3 ) { putc ( '\n' ) ; if ( dev < 0 || dev >= CONFIG_SYS_MAX_NAND_DEVICE ) { puts ( "no devices available\n" ) ; } else { nand_print_and_set_info ( dev ) ; } return 0 ; } dev = ( int ) dectoul ( argv [ 2 ] , NULL ) ; set_dev ( dev ) ; return 0 ; } if ( strcmp ( cmd , "env.oob" ) == 0 ) { return do_nand_env_oob ( cmdtp , argc - 1 , argv + 1 ) ; } mtd = get_nand_dev_by_index ( dev ) ; if ( ! mtd ) { puts ( "\nno devices available\n" ) ; return 1 ; } if ( strcmp ( cmd , "bad" ) == 0 ) { printf ( "\nDevice %d bad blocks:\n" , dev ) ; for ( off = 0 ; off < mtd -> size ; off += mtd -> erasesize ) { if ( nand_block_isbad ( mtd , off ) ) { printf ( "  %08llx\n" , ( unsigned long long ) off ) ; } } return 0 ; } if ( strncmp ( cmd , "erase" , 5 ) == 0 || strncmp ( cmd , "scrub" , 5 ) == 0 ) { nand_erase_options_t opts ; int clean = argc > 2 && ! strcmp ( "clean" , argv [ 2 ] ) ; int scrub_yes = argc > 2 && ! strcmp ( "-y" , argv [ 2 ] ) ; int o = ( clean || scrub_yes ) ?3 : 2 ; int scrub = ! strncmp ( cmd , "scrub" , 5 ) ; int spread = 0 ; int args = 2 ; const char * scrub_warn = "Warning: " "scrub option will erase all factory set bad blocks!\n" "         " "There is no reliable way to recover them.\n" "         " "Use this command only for testing purposes if you\n" "         " "are sure of what you are doing!\n" "\nReally scrub this NAND flash?<y/N>\n" ; if ( cmd [ 5 ] != 0 ) { if ( ! strcmp ( & cmd [ 5 ] , ".spread" ) ) { spread = 1 ; } if ( ! strcmp ( & cmd [ 5 ] , ".part" ) ) { args = 1 ; } if ( ! strcmp ( & cmd [ 5 ] , ".chip" ) ) { args = 0 ; } else { usage } } if ( argc != o + args ) { usage } printf ( "\nNAND %s: " , cmd ) ; if ( mtd_arg_off_size ( argc - o , argv + o , & dev , & off , & size , & maxsize , MTD_DEV_TYPE_NAND , mtd -> size ) != 0 ) { return 1 ; } if ( set_dev ( dev ) ) { return 1 ; } mtd = get_nand_dev_by_index ( dev ) ; memset ( & opts , 0 , sizeof ( opts ) ) ; opts . offset = off ; opts . length = size ; opts . jffs2 = clean ; opts . quiet = quiet ; opts . spread = spread ; if ( scrub ) { if ( scrub_yes ) { opts . scrub = 1 ; } else { puts ( scrub_warn ) ; if ( confirm_yesno ( ) ) { opts . scrub = 1 ; } else { puts ( "scrub aborted\n" ) ; return 1 ; } } } ret = nand_erase_opts ( mtd , & opts ) ; printf ( "%s\n" , ret ?"ERROR" : "OK" ) ; return ret == 0 ?0 : 1 ; } if ( strncmp ( cmd , "dump" , 4 ) == 0 ) { if ( argc < 3 ) { usage } off = ( int ) hextoul ( argv [ 2 ] , NULL ) ; ret = nand_dump ( mtd , off , ! strcmp ( & cmd [ 4 ] , ".oob" ) , repeat ) ; return ret == 0 ?1 : 0 ; } if ( strncmp ( cmd , "read" , 4 ) == 0 || strncmp ( cmd , "write" , 5 ) == 0 ) { size_t rwsize ; ulong pagecount = 1 ; int read ; int raw = 0 ; int no_verify = 0 ; if ( argc < 4 ) { usage } addr = ( ulong ) hextoul ( argv [ 2 ] , NULL ) ; read = strncmp ( cmd , "read" , 4 ) == 0 ; printf ( "\nNAND %s: " , read ?"read" : "write" ) ; s = strchr ( cmd , '.' ) ; if ( s && ! strncmp ( s , ".raw" , 4 ) ) { raw = 1 ; if ( ! strcmp ( s , ".raw.noverify" ) ) { no_verify = 1 ; } if ( mtd_arg_off ( argv [ 3 ] , & dev , & off , & size , & maxsize , MTD_DEV_TYPE_NAND , mtd -> size ) ) { return 1 ; } if ( set_dev ( dev ) ) { return 1 ; } mtd = get_nand_dev_by_index ( dev ) ; if ( argc > 4 && ! str2long ( argv [ 4 ] , & pagecount ) ) { printf ( "'%s' is not a number\n" , argv [ 4 ] ) ; return 1 ; } if ( pagecount * mtd -> writesize > size ) { puts ( "Size exceeds partition or device limit\n" ) ; return - 1 ; } rwsize = pagecount * ( mtd -> writesize + mtd -> oobsize ) ; } else { if ( mtd_arg_off_size ( argc - 3 , argv + 3 , & dev , & off , & size , & maxsize , MTD_DEV_TYPE_NAND , mtd -> size ) != 0 ) { return 1 ; } if ( set_dev ( dev ) ) { return 1 ; } if ( argc < 5 ) { adjust_size_for_badblocks ( & size , off , dev ) ; } rwsize = size ; } mtd = get_nand_dev_by_index ( dev ) ; if ( ! s || ! strcmp ( s , ".jffs2" ) || ! strcmp ( s , ".e" ) || ! strcmp ( s , ".i" ) ) { if ( read ) { ret = nand_read_skip_bad ( mtd , off , & rwsize , NULL , maxsize , ( u_char * ) addr ) ; } else { ret = nand_write_skip_bad ( mtd , off , & rwsize , NULL , maxsize , ( u_char * ) addr , WITH_WR_VERIFY ) ; } } if ( ! strcmp ( s , ".trimffs" ) ) { if ( read ) { printf ( "Unknown nand command suffix '%s'\n" , s ) ; return 1 ; } ret = nand_write_skip_bad ( mtd , off , & rwsize , NULL , maxsize , ( u_char * ) addr , WITH_DROP_FFS | WITH_WR_VERIFY ) ; } if ( ! strcmp ( s , ".oob" ) ) { mtd_oob_ops_t ops = { . oobbuf = ( u8 * ) addr . ooblen = rwsize . mode = MTD_OPS_RAW } ; if ( read ) { ret = mtd_read_oob ( mtd , off , & ops ) ; } else { ret = mtd_write_oob ( mtd , off , & ops ) ; } } if ( raw ) { ret = raw_access ( mtd , addr , off , pagecount , read , no_verify ) ; } else { printf ( "Unknown nand command suffix '%s'.\n" , s ) ; return 1 ; } printf ( " %zu bytes %s: %s\n" , rwsize , read ?"read" : "written" , ret ?"ERROR" : "OK" ) ; return ret == 0 ?0 : 1 ; } if ( strcmp ( cmd , "torture" ) == 0 ) { loff_t endoff ; unsigned int failed = 0 , passed = 0 ; if ( argc < 3 ) { usage } if ( ! str2off ( argv [ 2 ] , & off ) ) { puts ( "Offset is not a valid number\n" ) ; return 1 ; } size = mtd -> erasesize ; if ( argc > 3 ) { if ( ! str2off ( argv [ 3 ] , & size ) ) { puts ( "Size is not a valid number\n" ) ; return 1 ; } } endoff = off + size ; if ( endoff > mtd -> size ) { puts ( "Arguments beyond end of NAND\n" ) ; return 1 ; } off = round_down ( off , mtd -> erasesize ) ; endoff = round_up ( endoff , mtd -> erasesize ) ; size = endoff - off ; printf ( "\nNAND torture: device %d offset 0x%llx size 0x%llx (block size 0x%x)\n" , dev , off , size , mtd -> erasesize ) ; while ( off < endoff ) { ret = nand_torture ( mtd , off ) ; if ( ret ) { failed ++ ; printf ( "  block at 0x%llx failed\n" , off ) ; } else { passed ++ ; } off += mtd -> erasesize ; } printf ( " Passed: %u, failed: %u\n" , passed , failed ) ; return failed != 0 ; } if ( strcmp ( cmd , "markbad" ) == 0 ) { argc -= 2 ; argv += 2 ; if ( argc <= 0 ) { usage } while ( argc > 0 ) { addr = hextoul ( * argv , NULL ) ; if ( mtd_block_markbad ( mtd , addr ) ) { printf ( "block 0x%08lx NOT marked " "as bad! ERROR %d\n" , addr , ret ) ; ret = 1 ; } else { printf ( "block 0x%08lx successfully " "marked as bad\n" , addr ) ; } -- argc ; ++ argv ; } return ret ; } if ( strcmp ( cmd , "biterr" ) == 0 ) { int bit ; if ( argc != 4 ) { usage } off = ( int ) simple_strtoul ( argv [ 2 ] , NULL , 16 ) ; bit = ( int ) simple_strtoul ( argv [ 3 ] , NULL , 10 ) ; ret = nand_biterror ( mtd , off , bit ) ; return ret ; } if ( strcmp ( cmd , "lock" ) == 0 ) { int tight = 0 ; int status = 0 ; if ( argc == 3 ) { if ( ! strcmp ( "tight" , argv [ 2 ] ) ) { tight = 1 ; } if ( ! strcmp ( "status" , argv [ 2 ] ) ) { status = 1 ; } } if ( status ) { do_nand_status ( mtd ) ; } else { if ( ! nand_lock ( mtd , tight ) ) { puts ( "NAND flash successfully locked\n" ) ; } else { puts ( "Error locking NAND flash\n" ) ; return 1 ; } } return 0 ; } if ( strncmp ( cmd , "unlock" , 5 ) == 0 ) { int allexcept = 0 ; s = strchr ( cmd , '.' ) ; if ( s && ! strcmp ( s , ".allexcept" ) ) { allexcept = 1 ; } if ( mtd_arg_off_size ( argc - 2 , argv + 2 , & dev , & off , & size , & maxsize , MTD_DEV_TYPE_NAND , mtd -> size ) < 0 ) { return 1 ; } if ( set_dev ( dev ) ) { return 1 ; } mtd = get_nand_dev_by_index ( dev ) ; if ( ! nand_unlock ( mtd , off , size , allexcept ) ) { puts ( "NAND flash successfully unlocked\n" ) ; } else { puts ( "Error unlocking NAND flash, " "write and erase will probably fail\n" ) ; return 1 ; } return 0 ; } usage return CMD_RET_USAGE ; } 