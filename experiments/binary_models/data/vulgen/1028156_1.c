static noinline int ntfs_get_block_vbo ( struct inode * inode , u64 vbo , struct buffer_head * bh , int create , enum get_block_ctx ctx ) { struct super_block * sb = inode -> i_sb ; struct ntfs_sb_info * sbi = sb -> s_fs_info ; struct ntfs_inode * ni = ntfs_i ( inode ) ; struct page * page = bh -> b_page ; u8 cluster_bits = sbi -> cluster_bits ; u32 block_size = sb -> s_blocksize ; u64 bytes , lbo , valid ; u32 off ; int err ; CLST vcn , lcn , len ; bool new ; clear_buffer_new ( bh ) ; clear_buffer_uptodate ( bh ) ; if ( is_resident ( ni ) ) { ni_lock ( ni ) ; err = attr_data_read_resident ( ni , page ) ; ni_unlock ( ni ) ; if ( ! err ) { set_buffer_uptodate ( bh ) ; } bh -> b_size = block_size ; return err ; } vcn = vbo >> cluster_bits ; off = vbo & sbi -> cluster_mask ; new = false ; err = attr_data_get_block ( ni , vcn , 1 , & lcn , & len , create ?& new : NULL , create && sbi -> cluster_size > PAGE_SIZE ) ; if ( err ) { out } bytes = ( ( u64 ) len << cluster_bits ) - off ; if ( lcn == SPARSE_LCN ) { if ( ! create ) { if ( bh -> b_size > bytes ) { bh -> b_size = bytes ; } return 0 ; } WARN_ON ( 1 ) ; } if ( new ) { set_buffer_new ( bh ) ; } lbo = ( ( u64 ) lcn << cluster_bits ) + off ; set_buffer_mapped ( bh ) ; bh -> b_bdev = sb -> s_bdev ; bh -> b_blocknr = lbo >> sb -> s_blocksize_bits ; valid = ni -> i_valid ; if ( ctx == GET_BLOCK_DIRECT_IO_W ) { if ( vbo >= valid ) { set_buffer_new ( bh ) ; } } if ( create ) { if ( bytes > bh -> b_size ) { bytes = bh -> b_size ; } if ( vbo >= valid ) { set_buffer_new ( bh ) ; } if ( vbo + bytes > valid ) { ni -> i_valid = vbo + bytes ; mark_inode_dirty ( inode ) ; } } if ( vbo >= valid ) { clear_buffer_mapped ( bh ) ; } if ( vbo + bytes <= valid ) { } if ( vbo + block_size <= valid ) { bytes = block_size ; } else { bytes = block_size ; if ( page ) { u32 voff = valid - vbo ; bh -> b_size = block_size ; off = vbo & ( PAGE_SIZE - 1 ) ; set_bh_page ( bh , page , off ) ; err = bh_read ( bh , 0 ) ; if ( err < 0 ) { out } zero_user_segment ( page , off + voff , off + block_size ) ; } } if ( bh -> b_size > bytes ) { bh -> b_size = bytes ; } if ( ctx == GET_BLOCK_DIRECT_IO_W || ctx == GET_BLOCK_DIRECT_IO_R ) { ( sizeof ( size_t ) < sizeof ( loff_t ) ) if ( bytes > 0x40000000u ) { bh -> b_size = 0x40000000u ; } } return 0 ; out return err ; } 