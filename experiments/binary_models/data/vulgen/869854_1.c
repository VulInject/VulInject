static void writezone ( const char * const name , const char * const string , char version , int defaulttype ) { FILE * fp ; ptrdiff_t i , j ; int pass ; static const struct tzhead tzh0 ; static struct tzhead tzh ; bool dir_checked = false ; zic_t one = 1 ; zic_t y2038_boundary = one << 31 ; ptrdiff_t nats = timecnt + WORK_AROUND_QTBUG_53071 ; zic_t * ats = emalloc ( MAXALIGN ( size_product ( nats , sizeof ats + 1 ) ) ) ; void * typesptr = ats + nats ; unsigned char * types = typesptr ; struct timerange rangeall , range32 , range64 ; if ( timecnt > 1 ) { qsort ( attypes , timecnt , sizeof attypes , atcomp ) ; } { ptrdiff_t fromi , toi ; toi = 0 ; fromi = 0 ; for ( ; fromi < timecnt ; ++ fromi ) { if ( toi != 0 && ( ( attypes [ fromi ] . at + utoffs [ attypes [ toi - 1 ] . type ] ) <= ( attypes [ toi - 1 ] . at + utoffs [ toi == 1 ?0 : attypes [ toi - 2 ] . type ] ) ) ) { attypes [ toi - 1 ] . type = attypes [ fromi ] . type ; continue ; } if ( toi == 0 || attypes [ fromi ] . dontmerge || ( utoffs [ attypes [ toi - 1 ] . type ] != utoffs [ attypes [ fromi ] . type ] ) || ( isdsts [ attypes [ toi - 1 ] . type ] != isdsts [ attypes [ fromi ] . type ] ) || ( desigidx [ attypes [ toi - 1 ] . type ] != desigidx [ attypes [ fromi ] . type ] ) ) { attypes [ toi ++ ] = attypes [ fromi ] ; } } timecnt = toi ; } if ( noise && timecnt > 1200 ) { if ( timecnt > TZ_MAX_TIMES ) { warning ( _ ( "reference clients mishandle" " more than %d transition times" ) , TZ_MAX_TIMES ) ; } else { warning ( _ ( "pre-2014 clients may mishandle" " more than 1200 transition times" ) ) ; } } for ( i = 0 ; i < timecnt ; ++ i ) { ats [ i ] = attypes [ i ] . at ; types [ i ] = attypes [ i ] . type ; } for ( i = 0 ; i < timecnt ; ++ i ) { j = leapcnt ; while ( -- j >= 0 ) { if ( ats [ i ] > trans [ j ] - corr [ j ] ) { ats [ i ] = tadd ( ats [ i ] , corr [ j ] ) ; break ; } } } if ( WORK_AROUND_QTBUG_53071 && timecnt != 0 && want_bloat ( ) && ats [ timecnt - 1 ] < y2038_boundary - 1 && strchr ( string , '<' ) ) { ats [ timecnt ] = y2038_boundary - 1 ; types [ timecnt ] = types [ timecnt - 1 ] ; timecnt ++ ; } rangeall . defaulttype = defaulttype ; rangeall . base = rangeall . leapbase = 0 ; rangeall . count = timecnt ; rangeall . leapcount = leapcnt ; range64 = limitrange ( rangeall , lo_time , hi_time , ats , types ) ; range32 = limitrange ( range64 , PG_INT32_MIN , PG_INT32_MAX , ats , types ) ; if ( remove ( name ) == 0 ) { dir_checked = true ; } if ( errno != ENOENT ) { const char * e = strerror ( errno ) ; fprintf ( stderr , _ ( "%s: Cannot remove %s/%s: %s\n" ) , progname , directory , name , e ) ; exit ( EXIT_FAILURE ) ; } fp = fopen ( name , "wb" ) ; if ( ! fp ) { int fopen_errno = errno ; if ( fopen_errno == ENOENT && ! dir_checked ) { mkdirs ( name , true ) ; fp = fopen ( name , "wb" ) ; fopen_errno = errno ; } if ( ! fp ) { fprintf ( stderr , _ ( "%s: Cannot create %s/%s: %s\n" ) , progname , directory , name , strerror ( fopen_errno ) ) ; exit ( EXIT_FAILURE ) ; } } for ( pass = 1 ; pass <= 2 ; ++ pass ) { ptrdiff_t thistimei , thistimecnt , thistimelim ; int thisleapi , thisleapcnt , thisleaplim ; int currenttype , thisdefaulttype ; bool locut , hicut ; zic_t lo ; int old0 ; char omittype [ TZ_MAX_TYPES ] ; int typemap [ TZ_MAX_TYPES ] ; int thistypecnt , stdcnt , utcnt ; char thischars [ TZ_MAX_CHARS ] ; int thischarcnt ; bool toomanytimes ; int indmap [ TZ_MAX_CHARS ] ; if ( pass == 1 ) { thisdefaulttype = ( lo_time <= PG_INT32_MIN ?range64 . defaulttype : range32 . defaulttype ) ; thistimei = range32 . base ; thistimecnt = range32 . count ; toomanytimes = thistimecnt >> 31 >> 1 != 0 ; thisleapi = range32 . leapbase ; thisleapcnt = range32 . leapcount ; locut = PG_INT32_MIN < lo_time ; hicut = hi_time < PG_INT32_MAX ; } else { thisdefaulttype = range64 . defaulttype ; thistimei = range64 . base ; thistimecnt = range64 . count ; toomanytimes = thistimecnt >> 31 >> 31 >> 2 != 0 ; thisleapi = range64 . leapbase ; thisleapcnt = range64 . leapcount ; locut = min_time < lo_time ; hicut = hi_time < max_time ; } if ( toomanytimes ) { error ( _ ( "too many transition times" ) ) ; } if ( 0 < thistimei && ats [ thistimei ] != lo_time ) { thistimei -- ; thistimecnt ++ ; locut = false ; } thistimelim = thistimei + thistimecnt ; thisleaplim = thisleapi + thisleapcnt ; if ( thistimecnt != 0 ) { if ( ats [ thistimei ] == lo_time ) { locut = false ; } if ( hi_time < ZIC_MAX && ats [ thistimelim - 1 ] == hi_time + 1 ) { hicut = false ; } } memset ( omittype , true , typecnt ) ; omittype [ thisdefaulttype ] = false ; for ( i = thistimei ; i < thistimelim ; i ++ ) { omittype [ types [ i ] ] = false ; } old0 = strlen ( omittype ) ; if ( want_bloat ( ) ) { int mrudst , mrustd , hidst , histd , type ; hidst = histd = mrudst = mrustd = - 1 ; for ( i = thistimei ; i < thistimelim ; ++ i ) { if ( isdsts [ types [ i ] ] ) { mrudst = types [ i ] ; } else { mrustd = types [ i ] ; } } for ( i = old0 ; i < typecnt ; i ++ ) { int h = ( i == old0 ?thisdefaulttype : i == thisdefaulttype ?old0 : i ) ; if ( ! omittype [ h ] ) { if ( isdsts [ h ] ) { hidst = i ; } else { histd = i ; } } } if ( hidst >= 0 && mrudst >= 0 && hidst != mrudst && utoffs [ hidst ] != utoffs [ mrudst ] ) { isdsts [ mrudst ] = - 1 ; type = addtype ( utoffs [ mrudst ] , & chars [ desigidx [ mrudst ] ] , true , ttisstds [ mrudst ] , ttisuts [ mrudst ] ) ; isdsts [ mrudst ] = 1 ; omittype [ type ] = false ; } if ( histd >= 0 && mrustd >= 0 && histd != mrustd && utoffs [ histd ] != utoffs [ mrustd ] ) { isdsts [ mrustd ] = - 1 ; type = addtype ( utoffs [ mrustd ] , & chars [ desigidx [ mrustd ] ] , false , ttisstds [ mrustd ] , ttisuts [ mrustd ] ) ; isdsts [ mrustd ] = 0 ; omittype [ type ] = false ; } } thistypecnt = 0 ; for ( i = old0 ; i < typecnt ; i ++ ) { if ( ! omittype [ i ] ) { typemap [ i == old0 ?thisdefaulttype : i == thisdefaulttype ?old0 : i ] = thistypecnt ++ ; } } for ( i = 0 ; i < sizeof indmap / sizeof indmap [ 0 ] ; ++ i ) { indmap [ i ] = - 1 ; } thischarcnt = stdcnt = utcnt = 0 ; for ( i = old0 ; i < typecnt ; i ++ ) { char * thisabbr ; if ( omittype [ i ] ) { continue ; } if ( ttisstds [ i ] ) { stdcnt = thistypecnt ; } if ( ttisuts [ i ] ) { utcnt = thistypecnt ; } if ( indmap [ desigidx [ i ] ] >= 0 ) { continue ; } thisabbr = & chars [ desigidx [ i ] ] ; for ( j = 0 ; j < thischarcnt ; ++ j ) { if ( strcmp ( & thischars [ j ] , thisabbr ) == 0 ) { break ; } } if ( j == thischarcnt ) { strcpy ( & thischars [ thischarcnt ] , thisabbr ) ; thischarcnt += strlen ( thisabbr ) + 1 ; } indmap [ desigidx [ i ] ] = j ; } if ( pass == 1 && ! want_bloat ( ) ) { utcnt = stdcnt = thisleapcnt = 0 ; thistimecnt = - ( locut + hicut ) ; thistypecnt = thischarcnt = 1 ; thistimelim = thistimei ; } tzh = tzh0 ; memcpy ( tzh . tzh_magic , TZ_MAGIC , sizeof tzh . tzh_magic ) ; tzh . tzh_version [ 0 ] = version ; convert ( utcnt , tzh . tzh_ttisutcnt ) ; convert ( stdcnt , tzh . tzh_ttisstdcnt ) ; convert ( thisleapcnt , tzh . tzh_leapcnt ) ; convert ( locut + thistimecnt + hicut , tzh . tzh_timecnt ) ; convert ( thistypecnt , tzh . tzh_typecnt ) ; convert ( thischarcnt , tzh . tzh_charcnt ) ; DO ( tzh_magic ) ; DO ( tzh_version ) ; DO ( tzh_reserved ) ; DO ( tzh_ttisutcnt ) ; DO ( tzh_ttisstdcnt ) ; DO ( tzh_leapcnt ) ; DO ( tzh_timecnt ) ; DO ( tzh_typecnt ) ; DO ( tzh_charcnt ) ; if ( pass == 1 && ! want_bloat ( ) ) { puttzcode ( 0 , fp ) ; putc ( 0 , fp ) ; putc ( 0 , fp ) ; putc ( 0 , fp ) ; continue ; } if ( print_abbrevs && pass == 2 ) { for ( i = thistimei ; i < thistimelim ; ++ i ) { if ( i == thistimelim - 1 || ats [ i + 1 ] > print_cutoff ) { unsigned char tm = types [ i ] ; char * thisabbrev = & thischars [ indmap [ desigidx [ tm ] ] ] ; fprintf ( stdout , "%s\t" INT64_FORMAT "%s\n" , thisabbrev , utoffs [ tm ] , isdsts [ tm ] ?"\tD" : "" ) ; } } if ( thistimei >= thistimelim ) { unsigned char tm = defaulttype ; char * thisabbrev = & thischars [ indmap [ desigidx [ tm ] ] ] ; fprintf ( stdout , "%s\t" INT64_FORMAT "%s\n" , thisabbrev , utoffs [ tm ] , isdsts [ tm ] ?"\tD" : "" ) ; } } lo = pass == 1 && lo_time < PG_INT32_MIN ?PG_INT32_MIN : lo_time ; if ( locut ) { puttzcodepass ( lo , fp , pass ) ; } for ( i = thistimei ; i < thistimelim ; ++ i ) { zic_t at = ats [ i ] < lo ?lo : ats [ i ] ; puttzcodepass ( at , fp , pass ) ; } if ( hicut ) { puttzcodepass ( hi_time + 1 , fp , pass ) ; } currenttype = 0 ; if ( locut ) { putc ( currenttype , fp ) ; } for ( i = thistimei ; i < thistimelim ; ++ i ) { currenttype = typemap [ types [ i ] ] ; putc ( currenttype , fp ) ; } if ( hicut ) { putc ( currenttype , fp ) ; } for ( i = old0 ; i < typecnt ; i ++ ) { int h = ( i == old0 ?thisdefaulttype : i == thisdefaulttype ?old0 : i ) ; if ( ! omittype [ h ] ) { puttzcode ( utoffs [ h ] , fp ) ; putc ( isdsts [ h ] , fp ) ; putc ( indmap [ desigidx [ h ] ] , fp ) ; } } if ( thischarcnt != 0 ) { fwrite ( thischars , sizeof thischars [ 0 ] , thischarcnt , fp ) ; } for ( i = thisleapi ; i < thisleaplim ; ++ i ) { zic_t todo ; if ( roll [ i ] ) { if ( timecnt == 0 || trans [ i ] < ats [ 0 ] ) { j = 0 ; while ( isdsts [ j ] ) { if ( ++ j >= typecnt ) { j = 0 ; break ; } } } else { j = 1 ; while ( j < timecnt && trans [ i ] >= ats [ j ] ) { ++ j ; } j = types [ j - 1 ] ; } todo = tadd ( trans [ i ] , - utoffs [ j ] ) ; } else { todo = trans [ i ] ; } puttzcodepass ( todo , fp , pass ) ; puttzcode ( corr [ i ] , fp ) ; } if ( stdcnt != 0 ) { for ( i = old0 ; i < typecnt ; i ++ ) { if ( ! omittype [ i ] ) { putc ( ttisstds [ i ] , fp ) ; } } } } fprintf ( fp , "\n%s\n" , string ) ; close_file ( fp , directory , name ) ; free ( ats ) ; } 