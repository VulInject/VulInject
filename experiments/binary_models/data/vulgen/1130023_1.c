void ipu_image_convert_abort ( struct ipu_image_convert_ctx * ctx ) { struct ipu_image_convert_chan * chan = ctx -> chan ; struct ipu_image_convert_priv * priv = chan -> priv ; struct ipu_image_convert_run * run , * active_run , * tmp ; unsigned long flags ; int run_count , ret ; bool need_abort ; reinit_completion ( & ctx -> aborted ) ; spin_lock_irqsave ( & chan -> irqlock , flags ) ; list_for_each_entry_safe ( , , , ) { if ( run -> ctx != ctx ) { continue ; } run -> status = - EIO ; list_move_tail ( & run -> list , & chan -> done_q ) ; } run_count = get_run_count ( ctx , & chan -> done_q ) ; active_run = ( chan -> current_run && chan -> current_run -> ctx == ctx ) ?chan -> current_run : NULL ; need_abort = ( run_count || active_run ) ; ctx -> aborting = need_abort ; spin_unlock_irqrestore ( & chan -> irqlock , flags ) ; if ( ! need_abort ) { dev_dbg ( priv -> ipu -> dev , "%s: task %u: no abort needed for ctx %p\n" , __func__ , chan -> ic_task , ctx ) ; return ; } dev_dbg ( priv -> ipu -> dev , "%s: task %u: wait for completion: %d runs, active run %p\n" , __func__ , chan -> ic_task , run_count , active_run ) ; ret = wait_for_completion_timeout ( & ctx -> aborted , msecs_to_jiffies ( 10000 ) ) ; ctx -> aborting = false ; } 