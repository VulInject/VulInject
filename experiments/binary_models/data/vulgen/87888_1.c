int spreading_decision ( const CELTMode * m , const celt_norm * X , int * average , int last_decision , int * hf_average , int * tapset_decision , int update_hf , int end , int C , int M , const int * spread_weight ) { int i , c , N0 ; int sum = 0 , nbBands = 0 ; const opus_int16 * OPUS_RESTRICT eBands = m -> eBands ; int decision ; int hf_sum = 0 ; celt_assert ( end > 0 ) ; N0 = M * m -> shortMdctSize ; if ( M * ( eBands [ end ] - eBands [ end - 1 ] ) <= 8 ) { return SPREAD_NONE ; } c = 0 ; { for ( i = 0 ; i < end ; i ++ ) { int j , N , tmp = 0 ; int tcount [ 3 ] { 0 0 0 } ; ; const celt_norm * OPUS_RESTRICT x = X + M * eBands [ i ] + c * N0 ; N = M * ( eBands [ i + 1 ] - eBands [ i ] ) ; for ( j = 0 ; j < N ; j ++ ) { opus_val32 x2N ; x2N = MULT16_16 ( MULT16_16_Q15 ( x [ j ] , x [ j ] ) , N ) ; if ( x2N < QCONST16 ( 0.25f , 13 ) ) { tcount [ 0 ] ++ ; } if ( x2N < QCONST16 ( 0.0625f , 13 ) ) { tcount [ 1 ] ++ ; } if ( x2N < QCONST16 ( 0.015625f , 13 ) ) { tcount [ 2 ] ++ ; } } if ( i > m -> nbEBands - 4 ) { hf_sum += celt_udiv ( 32 * ( tcount [ 1 ] + tcount [ 0 ] ) , N ) ; } tmp = ( 2 * tcount [ 2 ] >= N ) + ( 2 * tcount [ 1 ] >= N ) + ( 2 * tcount [ 0 ] >= N ) ; sum += tmp * spread_weight [ i ] ; nbBands += spread_weight [ i ] ; } } ++ c < C ; if ( update_hf ) { if ( hf_sum ) { hf_sum = celt_udiv ( hf_sum , C * ( 4 - m -> nbEBands + end ) ) ; } * hf_average = ( * hf_average + hf_sum ) >> 1 ; hf_sum = * hf_average ; if ( * tapset_decision == 2 ) { hf_sum += 4 ; } if ( * tapset_decision == 0 ) { hf_sum -= 4 ; } if ( hf_sum > 22 ) { * tapset_decision = 2 ; } if ( hf_sum > 18 ) { * tapset_decision = 1 ; } else { * tapset_decision = 0 ; } } celt_assert ( nbBands > 0 ) ; celt_assert ( sum >= 0 ) ; sum = celt_udiv ( ( opus_int32 ) sum << 8 , nbBands ) ; sum = ( sum + * average ) >> 1 ; * average = sum ; sum = ( 3 * sum + ( ( ( 3 - last_decision ) << 7 ) + 64 ) + 2 ) >> 2 ; if ( sum < 80 ) { decision = SPREAD_AGGRESSIVE ; } if ( sum < 256 ) { decision = SPREAD_NORMAL ; } if ( sum < 384 ) { decision = SPREAD_LIGHT ; } else { decision = SPREAD_NONE ; } decision = rand ( ) & 0x3 ; * tapset_decision = rand ( ) % 3 ; return decision ; } 