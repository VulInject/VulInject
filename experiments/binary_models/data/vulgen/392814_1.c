static void ieee80211_deliver_skb ( struct ieee80211_rx_data * rx ) { struct ieee80211_sub_if_data * sdata = rx -> sdata ; struct net_device * dev = sdata -> dev ; struct sk_buff * skb , * xmit_skb ; struct ethhdr * ehdr = ( ethhdr * ) rx -> skb -> data ; struct sta_info * dsta ; skb = rx -> skb ; xmit_skb = NULL ; if ( rx -> sta ) { u64_stats_update_begin ( & rx -> link_sta -> rx_stats . syncp ) ; rx -> link_sta -> rx_stats . msdu [ rx -> seqno_idx ] ++ ; u64_stats_update_end ( & rx -> link_sta -> rx_stats . syncp ) ; } if ( ( sdata -> vif . type == NL80211_IFTYPE_AP || sdata -> vif . type == NL80211_IFTYPE_AP_VLAN ) && ! ( sdata -> flags & IEEE80211_SDATA_DONT_BRIDGE_PACKETS ) && ehdr -> h_proto != rx -> sdata -> control_port_protocol && ( sdata -> vif . type != NL80211_IFTYPE_AP_VLAN || ! sdata -> u . vlan . sta ) ) { if ( is_multicast_ether_addr ( ehdr -> h_dest ) && ieee80211_vif_get_num_mcast_if ( sdata ) != 0 ) { xmit_skb = skb_copy ( skb , GFP_ATOMIC ) ; if ( ! xmit_skb ) { net_info_ratelimited ( "%s: failed to clone multicast frame\n" , dev -> name ) ; } } if ( ! is_multicast_ether_addr ( ehdr -> h_dest ) && ! ether_addr_equal ( ehdr -> h_dest , ehdr -> h_source ) ) { dsta = sta_info_get ( sdata , ehdr -> h_dest ) ; if ( dsta ) { xmit_skb = skb ; skb = NULL ; } } } if ( skb ) { int align ; align = ( unsigned long ) ( skb -> data + sizeof ( ethhdr ) ) & 3 ; if ( align ) { if ( WARN_ON ( skb_headroom ( skb ) < 3 ) ) { dev_kfree_skb ( skb ) ; skb = NULL ; } else { u8 * data = skb -> data ; size_t len = skb_headlen ( skb ) ; skb -> data -= align ; memmove ( skb -> data , data , len ) ; skb_set_tail_pointer ( skb , len ) ; } } } if ( skb ) { skb -> protocol = eth_type_trans ( skb , dev ) ; ieee80211_deliver_skb_to_local_stack ( skb , rx ) ; } if ( xmit_skb ) { xmit_skb -> priority += 256 ; xmit_skb -> protocol = htons ( ETH_P_802_3 ) ; skb_reset_network_header ( xmit_skb ) ; skb_reset_mac_header ( xmit_skb ) ; dev_queue_xmit ( xmit_skb ) ; } } 