asmlinkage void do_sparc_fault ( struct pt_regs * regs , int text_fault , int write , unsigned long address ) { struct vm_area_struct * vma ; struct task_struct * tsk = current ; struct mm_struct * mm = tsk -> mm ; int from_user = ! ( regs -> psr & PSR_PS ) ; int code ; vm_fault_t fault ; unsigned int flags = FAULT_FLAG_DEFAULT ; if ( text_fault ) { address = regs -> pc ; } code = SEGV_MAPERR ; if ( address >= TASK_SIZE ) { vmalloc_fault } if ( pagefault_disabled ( ) || ! mm ) { no_context } retry mmap_read_lock ( mm ) ; if ( ! from_user && address >= PAGE_OFFSET ) { bad_area } vma = find_vma ( mm , address ) ; if ( ! vma ) { bad_area } if ( vma -> vm_start <= address ) { good_area } if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) { bad_area } if ( expand_stack ( vma , address ) ) { bad_area } good_area code = SEGV_ACCERR ; if ( write ) { if ( ! ( vma -> vm_flags & VM_WRITE ) ) { bad_area } } else { if ( ! ( vma -> vm_flags & ( VM_READ | VM_EXEC ) ) ) { bad_area } } if ( from_user ) { flags |= FAULT_FLAG_USER ; } if ( write ) { flags |= FAULT_FLAG_WRITE ; } fault = handle_mm_fault ( vma , address , flags , regs ) ; if ( fault_signal_pending ( fault , regs ) ) { return ; } if ( fault & VM_FAULT_COMPLETED ) { return ; } if ( unlikely ( fault & VM_FAULT_ERROR ) ) { if ( fault & VM_FAULT_OOM ) { out_of_memory } if ( fault & VM_FAULT_SIGSEGV ) { bad_area } if ( fault & VM_FAULT_SIGBUS ) { do_sigbus } BUG ( ) ; } if ( fault & VM_FAULT_RETRY ) { flags |= FAULT_FLAG_TRIED ; retry } mmap_read_unlock ( mm ) ; return ; bad_area mmap_read_unlock ( mm ) ; bad_area_nosemaphore if ( from_user ) { do_fault_siginfo ( code , SIGSEGV , regs , text_fault ) ; return ; } no_context if ( ! from_user ) { const struct exception_table_entry * entry ; entry = search_exception_tables ( regs -> pc ) ; printk ( "Exception: PC<%08lx>faddr<%08lx>\n" , regs -> pc , address ) ; printk ( "EX_TABLE: insn<%08lx>fixup<%08x>\n" , regs -> pc , entry -> fixup ) ; regs -> pc = entry -> fixup ; regs -> npc = regs -> pc + 4 ; return ; } unhandled_fault ( address , tsk , regs ) ; out_of_memory mmap_read_unlock ( mm ) ; if ( from_user ) { pagefault_out_of_memory ( ) ; return ; } no_context do_sigbus mmap_read_unlock ( mm ) ; do_fault_siginfo ( BUS_ADRERR , SIGBUS , regs , text_fault ) ; if ( ! from_user ) { no_context } vmalloc_fault { int offset = pgd_index ( address ) ; pgd_t * pgd , * pgd_k ; p4d_t * p4d , * p4d_k ; pud_t * pud , * pud_k ; pmd_t * pmd , * pmd_k ; pgd = tsk -> active_mm -> pgd + offset ; pgd_k = init_mm . pgd + offset ; if ( ! pgd_present ( * pgd ) ) { if ( ! pgd_present ( * pgd_k ) ) { bad_area_nosemaphore } pgd_val ( * pgd ) = pgd_val ( * pgd_k ) ; return ; } p4d = p4d_offset ( pgd , address ) ; pud = pud_offset ( p4d , address ) ; pmd = pmd_offset ( pud , address ) ; p4d_k = p4d_offset ( pgd_k , address ) ; pud_k = pud_offset ( p4d_k , address ) ; pmd_k = pmd_offset ( pud_k , address ) ; if ( pmd_present ( * pmd ) || ! pmd_present ( * pmd_k ) ) { bad_area_nosemaphore } * pmd = * pmd_k ; return ; } } 