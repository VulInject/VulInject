apr_status_t md_acme_authz_respond ( md_acme_authz_t * authz , md_acme_t * acme , md_store_t * store , apr_array_header_t * challenges , md_pkeys_spec_t * key_specs , apr_array_header_t * acme_tls_1_domains , const char * mdomain , apr_table_t * env , apr_pool_t * p , const char * * psetup_token , md_result_t * result ) { apr_status_t rv ; int i , j ; cha_find_ctx fctx ; const char * challenge_setup ; assert ( acme ) ; assert ( authz ) ; assert ( authz -> resource ) ; fctx . p = p ; fctx . accepted = NULL ; md_result_printf ( result , 0 , "%s: selecting suitable authorization challenge " "type, this domain supports %s" , authz -> domain , apr_array_pstrcat ( p , challenges , ' ' ) ) ; rv = APR_ENOTIMPL ; challenge_setup = NULL ; for ( i = 0 ; i < challenges -> nelts ; ++ i ) { fctx . type = APR_ARRAY_IDX ( challenges , i , const char * ) ; fctx . accepted = NULL ; md_json_itera ( find_type , & fctx , authz -> resource , MD_KEY_CHALLENGES , NULL ) ; md_log_perror ( MD_LOG_MARK , MD_LOG_TRACE1 , 0 , p , "%s: challenge type '%s' for %s: %s" , authz -> domain , fctx . type , mdomain , fctx . accepted ?"maybe acceptable" : "not applicable" ) ; if ( fctx . accepted ) { for ( j = 0 ; j < ( int ) CHA_TYPES_LEN ; ++ j ) { if ( ! apr_strnatcasecmp ( CHA_TYPES [ j ] . name , fctx . accepted -> type ) ) { md_result_activity_printf ( result , "Setting up challenge '%s' for domain %s" , fctx . accepted -> type , authz -> domain ) ; rv = CHA_TYPES [ j ] . setup ( fctx . accepted , authz , acme , store , key_specs , acme_tls_1_domains , mdomain , env , result , p ) ; md_result_printf ( result , rv , "error setting up challenge '%s' for %s, " "for domain %s, looking for other option" , fctx . accepted -> type , authz -> domain , mdomain ) ; md_result_log ( result , MD_LOG_INFO ) ; } } } } out * psetup_token = ( APR_SUCCESS == rv ) ?apr_psprintf ( p , "%s:%s" , challenge_setup , authz -> domain ) : NULL ; if ( ! fctx . accepted || APR_ENOTIMPL == rv ) { rv = APR_EINVAL ; fctx . offered = apr_array_make ( p , 5 , sizeof ( const char * ) ) ; md_json_itera ( collect_offered , & fctx , authz -> resource , MD_KEY_CHALLENGES , NULL ) ; md_result_printf ( result , rv , "None of offered challenge types for domain %s are supported. " "The server offered '%s' and available are: '%s'." , authz -> domain , apr_array_pstrcat ( p , fctx . offered , ' ' ) , apr_array_pstrcat ( p , challenges , ' ' ) ) ; result -> problem = "challenge-mismatch" ; md_result_log ( result , MD_LOG_ERR ) ; } if ( APR_SUCCESS != rv ) { fctx . offered = apr_array_make ( p , 5 , sizeof ( const char * ) ) ; md_json_itera ( collect_offered , & fctx , authz -> resource , MD_KEY_CHALLENGES , NULL ) ; md_result_printf ( result , rv , "None of the offered challenge types %s offered " "for domain %s could be setup successfully. Please check the " "log for errors." , authz -> domain , apr_array_pstrcat ( p , fctx . offered , ' ' ) ) ; result -> problem = "challenge-setup-failure" ; md_result_log ( result , MD_LOG_ERR ) ; } return rv ; } 