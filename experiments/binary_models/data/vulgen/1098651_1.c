static noinline int copy_items ( struct btrfs_trans_handle * trans , struct btrfs_inode * inode , struct btrfs_path * dst_path , struct btrfs_path * src_path , u64 * last_extent , int start_slot , int nr , int inode_only , u64 logged_isize ) { struct btrfs_fs_info * fs_info = btrfs_sb ( inode -> vfs_inode . i_sb ) ; unsigned long src_offset ; unsigned long dst_offset ; struct btrfs_root * log = inode -> root -> log_root ; struct btrfs_file_extent_item * extent ; struct btrfs_inode_item * inode_item ; struct extent_buffer * src = src_path -> nodes [ 0 ] ; struct btrfs_key first_key , last_key , key ; int ret ; struct btrfs_key * ins_keys ; u32 * ins_sizes ; char * ins_data ; int i ; struct list_head ordered_sums ; int skip_csum = inode -> flags & BTRFS_INODE_NODATASUM ; bool has_extents = false ; bool need_find_last_extent = true ; bool done = false ; INIT_LIST_HEAD ( & ordered_sums ) ; ins_data = kmalloc ( nr * sizeof ( btrfs_key ) + nr * sizeof ( u32 ) , GFP_NOFS ) ; first_key . objectid = ( u64 ) - 1 ; ins_sizes = ( u32 * ) ins_data ; ins_keys = ( btrfs_key * ) ( ins_data + nr * sizeof ( u32 ) ) ; for ( i = 0 ; i < nr ; i ++ ) { ins_sizes [ i ] = btrfs_item_size_nr ( src , i + start_slot ) ; btrfs_item_key_to_cpu ( src , ins_keys + i , i + start_slot ) ; } ret = btrfs_insert_empty_items ( trans , log , dst_path , ins_keys , ins_sizes , nr ) ; if ( ret ) { kfree ( ins_data ) ; return ret ; } for ( i = 0 ; i < nr ; i ++ , dst_path -> slots [ 0 ] ++ ) { dst_offset = btrfs_item_ptr_offset ( dst_path -> nodes [ 0 ] , dst_path -> slots [ 0 ] ) ; src_offset = btrfs_item_ptr_offset ( src , start_slot + i ) ; if ( ( i == ( nr - 1 ) ) ) { last_key = ins_keys [ i ] ; } if ( ins_keys [ i ] . type == BTRFS_INODE_ITEM_KEY ) { inode_item = btrfs_item_ptr ( dst_path -> nodes [ 0 ] , dst_path -> slots [ 0 ] , btrfs_inode_item ) ; fill_inode_item ( trans , dst_path -> nodes [ 0 ] , inode_item , & inode -> vfs_inode , inode_only == LOG_INODE_EXISTS , logged_isize ) ; } else { copy_extent_buffer ( dst_path -> nodes [ 0 ] , src , dst_offset , src_offset , ins_sizes [ i ] ) ; } if ( ins_keys [ i ] . type == BTRFS_EXTENT_DATA_KEY ) { has_extents = true ; if ( first_key . objectid == ( u64 ) - 1 ) { first_key = ins_keys [ i ] ; } } else { need_find_last_extent = false ; } if ( ins_keys [ i ] . type == BTRFS_EXTENT_DATA_KEY && ! skip_csum ) { int found_type ; extent = btrfs_item_ptr ( src , start_slot + i , btrfs_file_extent_item ) ; if ( btrfs_file_extent_generation ( src , extent ) < trans -> transid ) { continue ; } found_type = btrfs_file_extent_type ( src , extent ) ; if ( found_type == BTRFS_FILE_EXTENT_REG ) { u64 ds , dl , cs , cl ; ds = btrfs_file_extent_disk_bytenr ( src , extent ) ; if ( ds == 0 ) { continue ; } dl = btrfs_file_extent_disk_num_bytes ( src , extent ) ; cs = btrfs_file_extent_offset ( src , extent ) ; cl = btrfs_file_extent_num_bytes ( src , extent ) ; if ( btrfs_file_extent_compression ( src , extent ) ) { cs = 0 ; cl = dl ; } ret = btrfs_lookup_csums_range ( fs_info -> csum_root , ds + cs , ds + cs + cl - 1 , & ordered_sums , 0 ) ; if ( ret ) { btrfs_release_path ( dst_path ) ; kfree ( ins_data ) ; return ret ; } } } } btrfs_mark_buffer_dirty ( dst_path -> nodes [ 0 ] ) ; btrfs_release_path ( dst_path ) ; kfree ( ins_data ) ; ret = 0 ; while ( ! list_empty ( & ordered_sums ) ) { struct btrfs_ordered_sum * sums = list_entry ( ordered_sums . next , btrfs_ordered_sum , list ) ; if ( ! ret ) { ret = btrfs_csum_file_blocks ( trans , log , sums ) ; } list_del ( & sums -> list ) ; kfree ( sums ) ; } if ( ! has_extents ) { return ret ; } if ( need_find_last_extent && * last_extent == first_key . offset ) { need_find_last_extent = false ; } if ( need_find_last_extent ) { u64 len ; ret = btrfs_prev_leaf ( inode -> root , src_path ) ; if ( ret < 0 ) { return ret ; } if ( ret ) { fill_holes } if ( src_path -> slots [ 0 ] ) { src_path -> slots [ 0 ] -- ; } src = src_path -> nodes [ 0 ] ; btrfs_item_key_to_cpu ( src , & key , src_path -> slots [ 0 ] ) ; if ( key . objectid != btrfs_ino ( inode ) || key . type != BTRFS_EXTENT_DATA_KEY ) { fill_holes } extent = btrfs_item_ptr ( src , src_path -> slots [ 0 ] , btrfs_file_extent_item ) ; if ( btrfs_file_extent_type ( src , extent ) == BTRFS_FILE_EXTENT_INLINE ) { len = btrfs_file_extent_inline_len ( src , src_path -> slots [ 0 ] , extent ) ; * last_extent = ALIGN ( key . offset + len , fs_info -> sectorsize ) ; } else { len = btrfs_file_extent_num_bytes ( src , extent ) ; * last_extent = key . offset + len ; } } fill_holes if ( need_find_last_extent ) { btrfs_release_path ( src_path ) ; ret = btrfs_search_slot ( NULL , inode -> root , & first_key , src_path , 0 , 0 ) ; if ( ret < 0 ) { return ret ; } ASSERT ( ret == 0 ) ; src = src_path -> nodes [ 0 ] ; i = src_path -> slots [ 0 ] ; } else { i = start_slot ; } while ( ! done ) { u64 offset , len ; u64 extent_end ; if ( i >= btrfs_header_nritems ( src_path -> nodes [ 0 ] ) ) { ret = btrfs_next_leaf ( inode -> root , src_path ) ; if ( ret < 0 ) { return ret ; } ASSERT ( ret == 0 ) ; src = src_path -> nodes [ 0 ] ; i = 0 ; } btrfs_item_key_to_cpu ( src , & key , i ) ; if ( ! btrfs_comp_cpu_keys ( & key , & last_key ) ) { done = true ; } if ( key . objectid != btrfs_ino ( inode ) || key . type != BTRFS_EXTENT_DATA_KEY ) { i ++ ; continue ; } extent = btrfs_item_ptr ( src , i , btrfs_file_extent_item ) ; if ( btrfs_file_extent_type ( src , extent ) == BTRFS_FILE_EXTENT_INLINE ) { len = btrfs_file_extent_inline_len ( src , i , extent ) ; extent_end = ALIGN ( key . offset + len , fs_info -> sectorsize ) ; } else { len = btrfs_file_extent_num_bytes ( src , extent ) ; extent_end = key . offset + len ; } i ++ ; if ( * last_extent == key . offset ) { * last_extent = extent_end ; continue ; } offset = * last_extent ; len = key . offset - * last_extent ; ret = btrfs_insert_file_extent ( trans , log , btrfs_ino ( inode ) , offset , 0 , 0 , len , 0 , len , 0 , 0 , 0 ) ; if ( ret ) { break ; } * last_extent = extent_end ; } if ( ! ret && need_find_last_extent ) { ret = 1 ; } return ret ; } 