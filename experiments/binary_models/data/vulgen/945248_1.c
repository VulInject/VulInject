Status_t sa_InformInfo_Subscribe ( Mai_t * maip , STL_INFORM_INFO * iip , uint8_t ibMode ) { int validateLidRange = 1 ; STL_LID lid ; STL_LID topLid ; STL_LID LIDRangeEnd ; STL_LID LIDRangeBegin ; Node_t * nodep ; Port_t * portp ; Port_t * subscriberPortp , subsPort ; uint32_t logseverity ; uint16_t tmp ; Status_t status ; uint64_t guid ; STL_INFORM_INFO_RECORD * iRecordp , syncRecord ; uint64_t gid [ 2 ] ; SubscriberKeyp subsKeyp ; SubscriberKey_t syncKey ; char * nodeName = "Unknown Node" ; uint8_t sync = TRUE ; IB_ENTER ( "sa_InformInfo_Subscribe" , maip , iip , 0 , 0 ) ; iip -> u . Generic . u1 . s . QPNumber = maip -> addrInfo . srcqp ; iip -> Reserved1 = 0 ; iip -> u . Generic . u1 . s . Reserved2 = 0 ; iip -> u . Generic . u2 . s . Reserved3 = 0 ; lid = maip -> addrInfo . slid ; gid [ 0 ] = ntoh64 ( iip -> GID . AsReg64s . H ) ; gid [ 1 ] = ntoh64 ( iip -> GID . AsReg64s . L ) ; ( void ) vs_wrlock ( & old_topology_lock ) ; if ( ( subscriberPortp = sm_find_active_port_lid ( & old_topology , lid ) ) == NULL ) { maip -> base . status = activateInProgress ?MAD_STATUS_BUSY : MAD_STATUS_SA_REQ_INVALID ; if ( activateInProgress ) { logseverity = VS_LOG_VERBOSE ; } else { logseverity = VS_LOG_INFINI_INFO ; } if ( logseverity < VS_LOG_INFINI_INFO || saDebugPerf ) { cs_log ( logseverity , "sa_InformInfo_Subscribe" , "Can not find source lid of 0x%.8X in topology " "in request to subscribe with GID " FMT_GID ", start LID 0x%.8X, end LID 0x%.8X, " "PKey 0x%.4X, isGeneric %d, subscribe %d, type 0x%.4X, trap number 0x%.4X, " "QPN 0x%.8X, response time of 0x%.2X, returning status 0x%.4X" , lid , gid [ 0 ] , gid [ 1 ] , iip -> LIDRangeBegin , iip -> LIDRangeEnd , maip -> addrInfo . pkey , iip -> IsGeneric , iip -> Subscribe , iip -> Type , iip -> u . Generic . TrapNumber , iip -> u . Generic . u1 . s . QPNumber , iip -> u . Generic . u1 . s . RespTimeValue , maip -> base . status ) ; } ( void ) vs_rwunlock ( & old_topology_lock ) ; IB_EXIT ( "sa_InformInfo_Subscribe - Can't find source lid" , VSTATUS_BAD ) ; return ( VSTATUS_BAD ) ; } if ( ( nodep = sm_find_port_node ( & old_topology , subscriberPortp ) ) != NULL ) { nodeName = sm_nodeDescString ( nodep ) ; } memcpy ( & subsPort , subscriberPortp , sizeof ( Port_t ) ) ; if ( memcmp ( & iip -> GID , & nullGid , sizeof ( IB_GID ) ) != 0 ) { guid = ntoh64 ( iip -> GID . AsReg64s . L ) ; if ( guid == 0x0ull ) { ( void ) vs_rwunlock ( & old_topology_lock ) ; IB_EXIT ( "sa_InformInfo_Subscribe - bad Gid/Lid" , VSTATUS_BAD ) ; return ( VSTATUS_BAD ) ; } else { if ( ( portp = sm_find_active_port_guid ( & old_topology , guid ) ) == NULL ) { maip -> base . status = activateInProgress ?MAD_STATUS_BUSY : MAD_STATUS_SA_REQ_INVALID ; IB_LOG_ERROR_FMT ( "sa_InformInfo_Subscribe" , "Can not find port GUID " FMT_U64 " from " "%s, port " FMT_U64 ", lid of 0x%.8X in topology " "in request to subscribe with GID " FMT_GID ", start LID 0x%.8X, " "end LID 0x%.8X, PKey 0x%.4X, isGeneric %d, subscribe %d, type 0x%.4X, " "trap number 0x%.4X, QPN 0x%.8X, response time of 0x%.2X, " "returning status 0x%.4X" , guid , nodeName , subsPort . portData -> guid , lid , gid [ 0 ] , gid [ 1 ] , iip -> LIDRangeBegin , iip -> LIDRangeEnd , maip -> addrInfo . pkey , iip -> IsGeneric , iip -> Subscribe , iip -> Type , iip -> u . Generic . TrapNumber , iip -> u . Generic . u1 . s . QPNumber , iip -> u . Generic . u1 . s . RespTimeValue , maip -> base . status ) ; ( void ) vs_rwunlock ( & old_topology_lock ) ; IB_EXIT ( "sa_InformInfo_Subscribe - bad Gid/Lid" , VSTATUS_BAD ) ; return ( VSTATUS_BAD ) ; } } LIDRangeBegin = portp -> portData -> lid ; LIDRangeEnd = LIDRangeBegin ; } else { if ( iip -> LIDRangeBegin == STL_LID_PERMISSIVE ) { validateLidRange = 0 ; LIDRangeBegin = 1 ; LIDRangeEnd = STL_LID_UNICAST_END ; } if ( iip -> LIDRangeEnd != 0 ) { LIDRangeBegin = iip -> LIDRangeBegin ; LIDRangeEnd = iip -> LIDRangeEnd ; } else { LIDRangeBegin = iip -> LIDRangeBegin ; LIDRangeEnd = iip -> LIDRangeBegin ; } } if ( validateLidRange ) { for_all_ca_nodes ( , ) { for_all_end_ports ( , ) { if ( ! sm_valid_port ( portp ) || portp -> state <= IB_PORT_DOWN ) { continue ; } topLid = portp -> portData -> lid + ( 1 << portp -> portData -> lmc ) - 1 ; if ( ( LIDRangeBegin <= topLid ) && ( portp -> portData -> lid <= LIDRangeEnd ) ) { status = sa_Authenticate_Path ( maip -> addrInfo . slid , portp -> portData -> lid ) ; if ( status != VSTATUS_OK ) { maip -> base . status = MAD_STATUS_SA_REQ_INVALID ; IB_LOG_ERROR_FMT ( "sa_InformInfo_Subscribe" , "Failed to authenticate path from " "%s, port " FMT_U64 ", lid of 0x%.8X in topology " "to subscribe with GID " FMT_GID ", start LID 0x%.8X, " "end LID 0x%.8X, PKey 0x%.4X, isGeneric %d, subscribe %d, type 0x%.4X, " "trap number 0x%.4X, QPN 0x%.8X, response time of 0x%.2X, " "returning status 0x%.4X" , nodeName , subsPort . portData -> guid , lid , gid [ 0 ] , gid [ 1 ] , iip -> LIDRangeBegin , iip -> LIDRangeEnd , maip -> addrInfo . pkey , iip -> IsGeneric , iip -> Subscribe , iip -> Type , iip -> u . Generic . TrapNumber , iip -> u . Generic . u1 . s . QPNumber , iip -> u . Generic . u1 . s . RespTimeValue , maip -> base . status ) ; ( void ) vs_rwunlock ( & old_topology_lock ) ; IB_EXIT ( "sa_InformInfo_Subscribe - Path access" , VSTATUS_BAD ) ; return ( VSTATUS_BAD ) ; } status = sa_Authenticate_Access ( SA_INFORMINFO , ( STL_LID ) 0 , maip -> addrInfo . slid , portp -> portData -> lid ) ; if ( status != VSTATUS_OK ) { maip -> base . status = MAD_STATUS_SA_REQ_INVALID ; IB_LOG_ERROR_FMT ( "sa_InformInfo_Subscribe" , "Failed to authenticate access from " "%s, port " FMT_U64 ", lid of 0x%.8X in topology " "to subscribe with GID " FMT_GID ", start LID 0x%.8X, " "end LID 0x%.8X, PKey 0x%.4X, isGeneric %d, subscribe %d, type 0x%.4X, " "trap number 0x%.4X, QPN 0x%.8X, response time of 0x%.2X, " "returning status 0x%.4X" , nodeName , subsPort . portData -> guid , lid , gid [ 0 ] , gid [ 1 ] , iip -> LIDRangeBegin , iip -> LIDRangeEnd , maip -> addrInfo . pkey , iip -> IsGeneric , iip -> Subscribe , iip -> Type , iip -> u . Generic . TrapNumber , iip -> u . Generic . u1 . s . QPNumber , iip -> u . Generic . u1 . s . RespTimeValue , maip -> base . status ) ; ( void ) vs_rwunlock ( & old_topology_lock ) ; IB_EXIT ( "sa_InformInfo_Subscribe - Auth access" , VSTATUS_BAD ) ; return ( VSTATUS_BAD ) ; } } } } } ( void ) vs_rwunlock ( & old_topology_lock ) ; subsKeyp = ( SubscriberKeyp ) malloc ( sizeof ( SubscriberKey_t ) ) ; if ( subsKeyp == NULL ) { IB_FATAL_ERROR_NODUMP ( "sa_InformInfo_Subscribe: Can't allocate subscriber entry/key" ) ; return VSTATUS_NOMEM ; } memset ( subsKeyp , 0 , sizeof ( SubscriberKey_t ) ) ; subsKeyp -> lid = maip -> addrInfo . slid ; subsKeyp -> trapnum = iip -> u . Generic . TrapNumber ; subsKeyp -> qpn = iip -> u . Generic . u1 . s . QPNumber ; subsKeyp -> producer = iip -> u . Generic . u2 . s . ProducerType ; subsKeyp -> rtv = iip -> u . Generic . u1 . s . RespTimeValue ; subsKeyp -> pkey = maip -> addrInfo . pkey ; subsKeyp -> qkey = maip -> addrInfo . qkey ; subsKeyp -> startLid = LIDRangeBegin ; subsKeyp -> endLid = LIDRangeEnd ; subsKeyp -> ibMode = ibMode ; memcpy ( subsKeyp -> subscriberGid , subsPort . portData -> gid , sizeof ( IB_GID ) ) ; memcpy ( ( void * ) & syncKey , ( void * ) subsKeyp , sizeof ( SubscriberKey_t ) ) ; if ( vs_lock ( & saSubscribers . subsLock ) != VSTATUS_OK ) { free ( subsKeyp ) ; return VSTATUS_BAD ; } if ( NULL == ( iRecordp = ( STL_INFORM_INFO_RECORD * ) cs_hashtable_search ( saSubscribers . subsMap , subsKeyp ) ) ) { iRecordp = ( STL_INFORM_INFO_RECORD * ) malloc ( sizeof ( STL_INFORM_INFO_RECORD ) ) ; if ( iRecordp == NULL ) { free ( subsKeyp ) ; ( void ) vs_unlock ( & saSubscribers . subsLock ) ; IB_FATAL_ERROR_NODUMP ( "sa_InformInfo_Subscribe: Can't allocate informInfoRecord entry" ) ; IB_EXIT ( "sa_InformInfo_Subscribe - memory allocation failure" , VSTATUS_NOMEM ) ; return VSTATUS_NOMEM ; } memset ( iRecordp , 0 , sizeof ( STL_INFORM_INFO_RECORD ) ) ; tmp = saInformCount ++ ; iRecordp -> RID . Enum = tmp ; iRecordp -> InformInfoData = * iip ; iRecordp -> RID . SubscriberLID = subsPort . portData -> lid ; memcpy ( ( void * ) & syncRecord , ( void * ) iRecordp , sizeof ( STL_INFORM_INFO_RECORD ) ) ; if ( ! cs_hashtable_insert ( saSubscribers . subsMap , subsKeyp , iRecordp ) ) { free ( subsKeyp ) ; free ( iRecordp ) ; ( void ) vs_unlock ( & saSubscribers . subsLock ) ; IB_LOG_ERROR_FMT ( "sa_InformInfo_Subscribe" , "Failed to insert subscription from %s, port " FMT_U64 ", lid 0x%.8X in Subscriber hashtable" , nodeName , subsPort . portData -> guid , lid ) ; IB_EXIT ( "sa_InformInfo_Subscribe - hashtable insert failure" , VSTATUS_BAD ) ; return ( VSTATUS_BAD ) ; } if ( saDebugPerf ) { IB_LOG_INFINI_INFO_FMT ( "sa_InformInfo_Subscribe" , "Processed subscription from " "%s, port " FMT_U64 ", lid of 0x%.8X in topology " "to subscribe with GID " FMT_GID ", start LID 0x%.8X, " "end LID 0x%.8X, PKey 0x%.4X, isGeneric %d, subscribe %d, type 0x%.4X, " "trap number 0x%.4X, QPN 0x%.8X, response time of 0x%.2X, Qkey of 0x%.8X, " "Producer 0x%.6X, returning status 0x%.4X" , nodeName , subsPort . portData -> guid , lid , gid [ 0 ] , gid [ 1 ] , iip -> LIDRangeBegin , iip -> LIDRangeEnd , maip -> addrInfo . pkey , iip -> IsGeneric , iip -> Subscribe , iip -> Type , iip -> u . Generic . TrapNumber , iip -> u . Generic . u1 . s . QPNumber , iip -> u . Generic . u1 . s . RespTimeValue , maip -> addrInfo . qkey , iip -> u . Generic . u2 . s . ProducerType , maip -> base . status ) ; } } else { if ( memcmp ( & iRecordp -> InformInfoData , iip , sizeof ( STL_INFORM_INFO ) ) != 0 ) { iRecordp -> InformInfoData = * iip ; memcpy ( ( void * ) & syncRecord , ( void * ) iRecordp , sizeof ( STL_INFORM_INFO_RECORD ) ) ; } else { sync = FALSE ; } free ( subsKeyp ) ; } ( void ) vs_unlock ( & saSubscribers . subsLock ) ; IB_EXIT ( "sa_InformInfo_Subscribe" , VSTATUS_OK ) ; return ( VSTATUS_OK ) ; } 