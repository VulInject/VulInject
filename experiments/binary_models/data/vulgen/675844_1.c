m32r_cgen_cpu_open ( , ) { CGEN_CPU_TABLE * cd = ( CGEN_CPU_TABLE * ) xmalloc ( sizeof ( CGEN_CPU_TABLE ) ) ; static int init_p ; CGEN_BITSET * isas = 0 ; unsigned int machs = 0 ; enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN ; va_list ap ; if ( ! init_p ) { init_tables ( ) ; init_p = 1 ; } memset ( cd , 0 , sizeof ( * cd ) ) ; va_start ( ap , arg_type ) ; while ( arg_type != CGEN_CPU_OPEN_END ) { switch ( arg_type ) { case CGEN_CPU_OPEN_ISAS : isas = va_arg ( ap , CGEN_BITSET * ) ; break ; case CGEN_CPU_OPEN_MACHS : machs = va_arg ( , ) ; break ; case CGEN_CPU_OPEN_BFDMACH : { const char * name = va_arg ( ap , const char * ) ; const CGEN_MACH * mach = lookup_mach_via_bfd_name ( m32r_cgen_mach_table , name ) ; machs |= 1 << mach -> num ; break ; } case CGEN_CPU_OPEN_ENDIAN : endian = va_arg ( ap , cgen_endian ) ; break ; default : fprintf ( stderr , "m32r_cgen_cpu_open: unsupported argument `%d'\n" , arg_type ) ; abort ( ) ; } arg_type = va_arg ( ap , cgen_cpu_open_arg ) ; } va_end ( ap ) ; if ( machs == 0 ) { machs = ( 1 << MAX_MACHS ) - 1 ; } machs |= 1 ; if ( endian == CGEN_ENDIAN_UNKNOWN ) { fprintf ( stderr , "m32r_cgen_cpu_open: no endianness specified\n" ) ; abort ( ) ; } cd -> machs = machs ; cd -> endian = endian ; cd -> insn_endian = endian ; cd -> rebuild_tables = m32r_cgen_rebuild_tables ; m32r_cgen_rebuild_tables ( cd ) ; cd -> signed_overflow_ok_p = 0 ; return ( CGEN_CPU_DESC ) cd ; } 