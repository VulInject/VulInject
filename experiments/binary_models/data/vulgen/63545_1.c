void hibernate_enter_resume_4m_pde ( vaddr_t , paddr_t ) extern caddr_t start , end ; extern int ndumpmem ; extern struct dumpmem dumpmem [ ] ; extern bios_memmap_t * bios_memmap ; extern struct hibernate_state * hibernate_state ; uint32_t pt_entry_t hibio_fn get_hibernate_io_function ( dev_t dev ) { char * blkname = findblkname ( major ( dev ) ) ; if ( strcmp ( blkname , "wd" ) == 0 ) { extern int wd_hibernate_io ( dev_t dev , daddr_t blkno , vaddr_t addr , size_t size , int op , void * page ) ; return wd_hibernate_io ; } if ( strcmp ( blkname , "sd" ) == 0 ) { extern struct cfdriver sd_cd ; extern int ahci_hibernate_io ( dev_t dev , daddr_t blkno , vaddr_t addr , size_t size , int op , void * page ) ; extern int sr_hibernate_io ( dev_t dev , daddr_t blkno , vaddr_t addr , size_t size , int op , void * page ) ; extern int sdmmc_scsi_hibernate_io ( dev_t dev , daddr_t blkno , vaddr_t addr , size_t size , int op , void * page ) ; struct device * dv = disk_lookup ( & sd_cd , DISKUNIT ( dev ) ) ; { const char * driver ; hibio_fn io_func ; } , sd_io_funcs [ ] { { "ahci" ahci_hibernate_io } { "softraid" sr_hibernate_io } { "sdmmc" sdmmc_scsi_hibernate_io } } ; if ( dv && dv -> dv_parent && dv -> dv_parent -> dv_parent ) { const char * driver = dv -> dv_parent -> dv_parent -> dv_cfdata -> cf_driver -> cd_name ; int i ; for ( i = 0 ; i < nitems ( sd_io_funcs ) ; i ++ ) { if ( strcmp ( driver , sd_io_funcs [ i ] . driver ) == 0 ) { return sd_io_funcs [ i ] . io_func ; } } } } return NULL ; } 