static void compute_function_attributes ( ParseState * pstate , bool is_procedure , List * options , List * * as , char * * language , Node * * transform , bool * windowfunc_p , char * volatility_p , bool * strict_p , bool * security_definer , bool * leakproof_p , ArrayType * * proconfig , float4 * procost , float4 * prorows , Oid * prosupport , char * parallel_p ) { ListCell * option ; DefElem * as_item = NULL ; DefElem * language_item = NULL ; DefElem * transform_item = NULL ; DefElem * windowfunc_item = NULL ; DefElem * volatility_item = NULL ; DefElem * strict_item = NULL ; DefElem * security_item = NULL ; DefElem * leakproof_item = NULL ; List * set_items = NIL ; DefElem * cost_item = NULL ; DefElem * rows_item = NULL ; DefElem * support_item = NULL ; DefElem * parallel_item = NULL ; ( option options ; ) { DefElem * defel = ( DefElem * ) lfirst ( option ) ; if ( strcmp ( defel -> defname , "as" ) == 0 ) { if ( as_item ) { errorConflictingDefElem ( defel , pstate ) ; } as_item = defel ; } if ( strcmp ( defel -> defname , "language" ) == 0 ) { if ( language_item ) { errorConflictingDefElem ( defel , pstate ) ; } language_item = defel ; } if ( strcmp ( defel -> defname , "transform" ) == 0 ) { if ( transform_item ) { errorConflictingDefElem ( defel , pstate ) ; } transform_item = defel ; } if ( strcmp ( defel -> defname , "window" ) == 0 ) { if ( windowfunc_item ) { errorConflictingDefElem ( defel , pstate ) ; } windowfunc_item = defel ; } if ( compute_common_attribute ( pstate , is_procedure , defel , & volatility_item , & strict_item , & security_item , & leakproof_item , & set_items , & cost_item , & rows_item , & support_item , & parallel_item ) ) { continue ; } else { elog ( ERROR , "option \"%s\" not recognized" , defel -> defname ) ; } } if ( as_item ) { * as = ( List * ) as_item -> arg ; } if ( language_item ) { * language = strVal ( language_item -> arg ) ; } if ( transform_item ) { * transform = transform_item -> arg ; } if ( windowfunc_item ) { * windowfunc_p = boolVal ( windowfunc_item -> arg ) ; } if ( volatility_item ) { * volatility_p = interpret_func_volatility ( volatility_item ) ; } if ( strict_item ) { * strict_p = boolVal ( strict_item -> arg ) ; } if ( security_item ) { * security_definer = boolVal ( security_item -> arg ) ; } if ( leakproof_item ) { * leakproof_p = boolVal ( leakproof_item -> arg ) ; } if ( set_items ) { * proconfig = update_proconfig_value ( NULL , set_items ) ; } if ( cost_item ) { * procost = defGetNumeric ( cost_item ) ; if ( * procost <= 0 ) { ereport ( ERROR , ( errcode ( ERRCODE_INVALID_PARAMETER_VALUE ) , errmsg ( "COST must be positive" ) ) ) ; } } if ( rows_item ) { * prorows = defGetNumeric ( rows_item ) ; if ( * prorows <= 0 ) { ereport ( ERROR , ( errcode ( ERRCODE_INVALID_PARAMETER_VALUE ) , errmsg ( "ROWS must be positive" ) ) ) ; } } if ( support_item ) { * prosupport = interpret_func_support ( support_item ) ; } if ( parallel_item ) { * parallel_p = interpret_func_parallel ( parallel_item ) ; } } 