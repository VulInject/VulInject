static void test_write_format_iso9660_zisofs_3 ( void ) { unsigned char buff2 [ 1024 ] ; unsigned char nullb [ 2048 ] ; struct archive * a ; struct archive_entry * ae ; unsigned char * buff ; size_t buffsize = 50 * 2048 ; size_t used ; unsigned int i ; int r ; memset ( nullb , 0 , sizeof ( nullb ) ) ; buff = malloc ( buffsize ) ; assert ( buff != NULL ) ; if ( buff == NULL ) { return ; } assert ( ( a = archive_write_new ( ) ) != NULL ) ; assertEqualIntA ( a , 0 , archive_write_set_format_iso9660 ( a ) ) ; assertEqualIntA ( a , 0 , archive_write_add_filter_none ( a ) ) ; r = archive_write_set_option ( a , NULL , "zisofs" , "1" ) ; if ( r == ARCHIVE_FATAL ) { skipping ( "zisofs option not supported on this platform" ) ; assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ; return ; } assertEqualIntA ( a , 0 , archive_write_set_option ( a , NULL , "boot" , "boot.img" ) ) ; assertEqualIntA ( a , 0 , archive_write_set_option ( a , NULL , "pad" , NULL ) ) ; assertEqualIntA ( a , 0 , archive_write_open_memory ( a , buff , buffsize , & used ) ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_set_atime ( ae , 2 , 20 ) ; archive_entry_set_birthtime ( ae , 3 , 30 ) ; archive_entry_set_ctime ( ae , 4 , 40 ) ; archive_entry_set_mtime ( ae , 5 , 50 ) ; archive_entry_copy_pathname ( ae , "boot.img" ) ; archive_entry_set_mode ( ae , S_IFREG | 0755 ) ; archive_entry_set_size ( ae , 10 * 1024 ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assertEqualIntA ( a , 1024 , archive_write_data ( a , nullb , 1024 ) ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_set_atime ( ae , 2 , 20 ) ; archive_entry_set_birthtime ( ae , 3 , 30 ) ; archive_entry_set_ctime ( ae , 4 , 40 ) ; archive_entry_set_mtime ( ae , 5 , 50 ) ; archive_entry_copy_pathname ( ae , "file2" ) ; archive_entry_set_mode ( ae , S_IFREG | 0755 ) ; archive_entry_set_size ( ae , 2048 ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assertEqualIntA ( a , 1024 , archive_write_data ( a , nullb , 1024 ) ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_set_atime ( ae , 2 , 20 ) ; archive_entry_set_birthtime ( ae , 3 , 30 ) ; archive_entry_set_ctime ( ae , 4 , 40 ) ; archive_entry_set_mtime ( ae , 5 , 50 ) ; archive_entry_copy_pathname ( ae , "file3" ) ; archive_entry_set_mode ( ae , S_IFREG | 0755 ) ; archive_entry_set_size ( ae , 2049 ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assertEqualIntA ( a , 1024 , archive_write_data ( a , nullb , 1024 ) ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_close ( a ) ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_free ( a ) ) ; failure ( "The ISO image size should be 81920 bytes." ) ; assertEqualInt ( used , 2048 * 40 ) ; for ( i = 0 ; i < 2048 * 16 ; i ++ ) { failure ( "System Area should be all nulls." ) ; assertEqualInt ( buff [ i ] , 0 ) ; } failure ( "Primary Volume Descriptor should be in 16 Logical Sector." ) ; assertEqualMem ( buff + 2048 * 16 , primary_id , 8 ) ; assertEqualMem ( buff + 2048 * 16 + 0x28 , "CDROM                           " , 32 ) ; assertEqualMem ( buff + 2048 * 16 + 0x50 , volumesize3 , 8 ) ; failure ( "Boot Volume Descriptor should be in 17 Logical Sector." ) ; assertEqualMem ( buff + 2048 * 17 , boot_id , sizeof ( boot_id ) ) ; for ( i = 0x27 ; i <= 0x46 ; i ++ ) { failure ( "Unused area must be all nulls." ) ; assert ( buff [ 2048 * 17 + i ] == 0 ) ; } assert ( buff [ 2048 * 17 + 0x47 ] == 0x20 ) ; assert ( buff [ 2048 * 17 + 0x48 ] == 0x00 ) ; assert ( buff [ 2048 * 17 + 0x49 ] == 0x00 ) ; assert ( buff [ 2048 * 17 + 0x4a ] == 0x00 ) ; for ( i = 0x4a ; i <= 0x7ff ; i ++ ) { failure ( "Unused area must be all nulls." ) ; assert ( buff [ 2048 * 17 + i ] == 0 ) ; } failure ( "Supplementary Volume(Joliet) Descriptor " "should be in 18 Logical Sector." ) ; assertEqualMem ( buff + 2048 * 18 , supplementary_id , 8 ) ; assertEqualMem ( buff + 2048 * 18 + 0x28 , volumeidu16 , 32 ) ; assertEqualMem ( buff + 2048 * 18 + 0x50 , volumesize3 , 8 ) ; failure ( "Date and Time of Primary Volume and " "Date and Time of Supplementary Volume " "must be the same." ) ; assertEqualMem ( buff + 2048 * 16 + 0x32d , buff + 2048 * 18 + 0x32d , 0x44 ) ; failure ( "Volume Descriptor Set Terminator " "should be in 19 Logical Sector." ) ; assertEqualMem ( buff + 2048 * 19 , terminator_id , 8 ) ; for ( i = 8 ; i < 2048 ; i ++ ) { failure ( "Body of Volume Descriptor Set Terminator " "should be all nulls." ) ; assertEqualInt ( buff [ 2048 * 19 + i ] , 0 ) ; } assertEqualMem ( buff + 2048 * 31 , el_torito_signature , 237 ) ; assertEqualMem ( buff + 2048 * 31 + 237 , nullb , 2048 - 237 ) ; assertEqualMem ( buff + 2048 * 32 , boot_catalog , 64 ) ; assertEqualMem ( buff + 2048 * 32 + 64 , nullb , 2048 - 64 ) ; failure ( "boot.img image should not be zisofs'ed." ) ; assertEqualMem ( buff + 2048 * 33 , nullb , 2048 ) ; for ( i = 2048 * 34 ; i < 2048 * 38 ; i += 2048 ) { assertEqualMem ( buff + i , nullb , 2048 ) ; } failure ( "file2 image should not be zisofs'ed." ) ; assertEqualMem ( buff + 2048 * 38 , nullb , 8 ) ; failure ( "file3 image should be zisofs'ed." ) ; assertEqualMem ( buff + 2048 * 39 , zisofs_magic , 8 ) ; assert ( ( a = archive_read_new ( ) ) != NULL ) ; assertEqualIntA ( a , 0 , archive_read_support_format_all ( a ) ) ; assertEqualIntA ( a , 0 , archive_read_support_filter_all ( a ) ) ; assertEqualIntA ( a , 0 , archive_read_open_memory ( a , buff , used ) ) ; assertEqualIntA ( a , 0 , archive_read_next_header ( a , & ae ) ) ; assertEqualInt ( archive_entry_atime ( ae ) , archive_entry_ctime ( ae ) ) ; assertEqualInt ( archive_entry_atime ( ae ) , archive_entry_mtime ( ae ) ) ; assertEqualString ( "." , archive_entry_pathname ( ae ) ) ; assert ( ( S_IFDIR | 0555 ) == archive_entry_mode ( ae ) ) ; assertEqualInt ( 2048 , archive_entry_size ( ae ) ) ; assertEqualIntA ( a , 0 , archive_read_next_header ( a , & ae ) ) ; assertEqualString ( "boot.catalog" , archive_entry_pathname ( ae ) ) ; assert ( ( S_IFREG | 0444 ) == archive_entry_mode ( ae ) ) ; assert ( ( S_IFREG | 0555 ) == archive_entry_mode ( ae ) ) ; assertEqualInt ( 1 , archive_entry_nlink ( ae ) ) ; assertEqualInt ( 2 * 1024 , archive_entry_size ( ae ) ) ; assertEqualIntA ( a , 1024 , archive_read_data ( a , buff2 , 1024 ) ) ; assertEqualMem ( buff2 , boot_catalog , 64 ) ; assertEqualIntA ( a , 0 , archive_read_next_header ( a , & ae ) ) ; assertEqualInt ( 2 , archive_entry_atime ( ae ) ) ; assertEqualInt ( 3 , archive_entry_birthtime ( ae ) ) ; assertEqualInt ( 4 , archive_entry_ctime ( ae ) ) ; assertEqualInt ( 5 , archive_entry_mtime ( ae ) ) ; assertEqualString ( "boot.img" , archive_entry_pathname ( ae ) ) ; assert ( ( S_IFREG | 0555 ) == archive_entry_mode ( ae ) ) ; assertEqualInt ( 1 , archive_entry_nlink ( ae ) ) ; assertEqualInt ( 10 * 1024 , archive_entry_size ( ae ) ) ; assertEqualIntA ( a , 1024 , archive_read_data ( a , buff2 , 1024 ) ) ; assertEqualMem ( buff2 , nullb , 1024 ) ; assertEqualIntA ( a , 0 , archive_read_next_header ( a , & ae ) ) ; assertEqualInt ( 2 , archive_entry_atime ( ae ) ) ; assertEqualInt ( 4 , archive_entry_ctime ( ae ) ) ; assertEqualInt ( 5 , archive_entry_mtime ( ae ) ) ; assertEqualString ( "file2" , archive_entry_pathname ( ae ) ) ; assert ( ( S_IFREG | 0555 ) == archive_entry_mode ( ae ) ) ; assertEqualInt ( 2048 , archive_entry_size ( ae ) ) ; assertEqualIntA ( a , 1024 , archive_read_data ( a , buff2 , 1024 ) ) ; assertEqualMem ( buff2 , nullb , 1024 ) ; assertEqualIntA ( a , 0 , archive_read_next_header ( a , & ae ) ) ; assertEqualInt ( 2 , archive_entry_atime ( ae ) ) ; assertEqualInt ( 4 , archive_entry_ctime ( ae ) ) ; assertEqualInt ( 5 , archive_entry_mtime ( ae ) ) ; assertEqualString ( "file3" , archive_entry_pathname ( ae ) ) ; assert ( ( S_IFREG | 0555 ) == archive_entry_mode ( ae ) ) ; assertEqualInt ( 2049 , archive_entry_size ( ae ) ) ; assertEqualIntA ( a , 1024 , archive_read_data ( a , buff2 , 1024 ) ) ; assertEqualMem ( buff2 , nullb , 1024 ) ; assertEqualIntA ( a , ARCHIVE_EOF , archive_read_next_header ( a , & ae ) ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_read_close ( a ) ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_read_free ( a ) ) ; free ( buff ) ; } 