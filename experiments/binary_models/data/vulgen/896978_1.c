struct nftnl_rule * rule_set_snat ( uint8_t family , uint8_t proto , in_addr_t rhost , unsigned short rport , in_addr_t ehost , unsigned short eport , in_addr_t ihost , unsigned short iport , const char * descr , const char * handle ) { struct nftnl_rule * r = NULL ; uint16_t dport , sport ; UNUSED ( handle ) ; r = nftnl_rule_alloc ( ) ; if ( r == NULL ) { log_error ( "nftnl_rule_alloc() FAILED" ) ; return NULL ; } nftnl_rule_set_u32 ( r , NFTNL_RULE_FAMILY , family ) ; nftnl_rule_set_str ( r , NFTNL_RULE_TABLE , nft_nat_table ) ; nftnl_rule_set_str ( r , NFTNL_RULE_CHAIN , nft_postrouting_chain ) ; expr_add_payload ( r , NFT_PAYLOAD_NETWORK_HEADER , NFT_REG_1 , offsetof ( iphdr , daddr ) , sizeof ( uint32_t ) ) ; expr_add_cmp ( r , NFT_REG_1 , NFT_CMP_EQ , & ihost , sizeof ( uint32_t ) ) ; expr_add_payload ( r , NFT_PAYLOAD_NETWORK_HEADER , NFT_REG_1 , offsetof ( iphdr , saddr ) , sizeof ( in_addr_t ) ) ; expr_add_cmp ( r , NFT_REG_1 , NFT_CMP_EQ , & rhost , sizeof ( in_addr_t ) ) ; expr_add_payload ( r , NFT_PAYLOAD_NETWORK_HEADER , NFT_REG_1 , offsetof ( iphdr , protocol ) , sizeof ( uint8_t ) ) ; expr_add_cmp ( r , NFT_REG_1 , NFT_CMP_EQ , & proto , sizeof ( uint8_t ) ) ; if ( proto == IPPROTO_TCP ) { dport = htons ( iport ) ; expr_add_payload ( r , NFT_PAYLOAD_TRANSPORT_HEADER , NFT_REG_1 , offsetof ( tcphdr , dest ) , sizeof ( uint16_t ) ) ; expr_add_cmp ( r , NFT_REG_1 , NFT_CMP_EQ , & dport , sizeof ( uint16_t ) ) ; sport = htons ( rport ) ; expr_add_payload ( r , NFT_PAYLOAD_TRANSPORT_HEADER , NFT_REG_1 , offsetof ( tcphdr , source ) , sizeof ( uint16_t ) ) ; expr_add_cmp ( r , NFT_REG_1 , NFT_CMP_EQ , & sport , sizeof ( uint16_t ) ) ; } if ( proto == IPPROTO_UDP ) { dport = htons ( iport ) ; expr_add_payload ( r , NFT_PAYLOAD_TRANSPORT_HEADER , NFT_REG_1 , offsetof ( udphdr , dest ) , sizeof ( uint16_t ) ) ; expr_add_cmp ( r , NFT_REG_1 , NFT_CMP_EQ , & dport , sizeof ( uint16_t ) ) ; sport = htons ( rport ) ; expr_add_payload ( r , NFT_PAYLOAD_TRANSPORT_HEADER , NFT_REG_1 , offsetof ( udphdr , source ) , sizeof ( uint16_t ) ) ; expr_add_cmp ( r , NFT_REG_1 , NFT_CMP_EQ , & sport , sizeof ( uint16_t ) ) ; } expr_add_nat ( r , NFT_NAT_SNAT , NFPROTO_IPV4 , ehost , htons ( eport ) , 0 ) ; debug_rule ( r ) ; return r ; } 