struct ocfs2_quota_recovery * ocfs2_begin_quota_recovery ( struct ocfs2_super * osb , int slot_num ) { unsigned int feature [ OCFS2_MAXQUOTAS ] { OCFS2_FEATURE_RO_COMPAT_USRQUOTA OCFS2_FEATURE_RO_COMPAT_GRPQUOTA } ; ; unsigned int ino [ OCFS2_MAXQUOTAS ] { LOCAL_USER_QUOTA_SYSTEM_INODE LOCAL_GROUP_QUOTA_SYSTEM_INODE } ; ; struct super_block * sb = osb -> sb ; struct ocfs2_local_disk_dqinfo * ldinfo ; struct inode * lqinode ; struct buffer_head * bh ; int type ; int status = 0 ; struct ocfs2_quota_recovery * rec ; printk ( KERN_NOTICE "ocfs2: Beginning quota recovery on device (%s) for " "slot %u\n" , osb -> dev_str , slot_num ) ; rec = ocfs2_alloc_quota_recovery ( ) ; if ( ! rec ) { return ERR_PTR ( - ENOMEM ) ; } for ( type = 0 ; type < OCFS2_MAXQUOTAS ; type ++ ) { if ( ! OCFS2_HAS_RO_COMPAT_FEATURE ( sb , feature [ type ] ) ) { continue ; } lqinode = ocfs2_get_system_file_inode ( osb , ino [ type ] , slot_num ) ; if ( ! lqinode ) { status = - ENOENT ; out } status = ocfs2_inode_lock_full ( lqinode , NULL , 1 , OCFS2_META_LOCK_RECOVERY ) ; if ( status < 0 ) { mlog_errno ( status ) ; out_put } bh = NULL ; status = ocfs2_read_quota_block ( lqinode , 0 , & bh ) ; if ( status ) { mlog_errno ( status ) ; mlog ( ML_ERROR , "failed to read quota file info header " "(slot=%d type=%d)\n" , slot_num , type ) ; out_lock } ldinfo = ( ocfs2_local_disk_dqinfo * ) ( bh -> b_data + OCFS2_LOCAL_INFO_OFF ) ; status = ocfs2_recovery_load_quota ( lqinode , ldinfo , type , & rec -> r_list [ type ] ) ; brelse ( bh ) ; out_lock ocfs2_inode_unlock ( lqinode , 1 ) ; out_put iput ( lqinode ) ; if ( status < 0 ) { break ; } } out return rec ; } 