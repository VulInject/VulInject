static struct lowpan_nhdr * dissect_6lowpan_iphc_nhc ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint dgram_size , const guint8 * siid , const guint8 * diid ) { gint length ; proto_item * ti = NULL ; proto_tree * nhc_tree = NULL ; struct lowpan_nhdr * nhdr ; if ( tvb_get_bits8 ( tvb , offset << 3 , LOWPAN_NHC_PATTERN_EXT_IPV6_BITS ) == LOWPAN_NHC_PATTERN_EXT_IPV6 ) { guint8 ext_flags ; tvbuff_t * iphc_tvb ; nhc_tree = proto_tree_add_subtree ( tree , tvb , offset , 2 , ett_6lowpan_nhc_ext , & ti , "IPv6 extension header" ) ; proto_tree_add_bits_item ( nhc_tree , hf_6lowpan_nhc_pattern , tvb , offset << 3 , LOWPAN_NHC_PATTERN_EXT_BITS , ENC_BIG_ENDIAN ) ; ext_flags = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_uint ( nhc_tree , hf_6lowpan_nhc_ext_eid , tvb , offset , 1 , ext_flags & LOWPAN_NHC_EXT_EID ) ; proto_tree_add_boolean ( nhc_tree , hf_6lowpan_nhc_ext_nh , tvb , offset , 1 , ext_flags & LOWPAN_NHC_EXT_NHDR ) ; if ( ext_flags & LOWPAN_NHC_EXT_NHDR ) { } offset += 1 ; iphc_tvb = dissect_6lowpan_iphc ( tvb_new_subset_remaining ( tvb , offset ) , pinfo , tree , dgram_size , siid , diid ) ; nhdr = ( lowpan_nhdr * ) wmem_alloc0 ( pinfo -> pool , sizeof ( lowpan_nhdr ) + tvb_captured_length ( iphc_tvb ) ) ; nhdr -> next = NULL ; nhdr -> proto = IP_PROTO_IPV6 ; nhdr -> length = tvb_captured_length ( iphc_tvb ) ; nhdr -> reported = tvb_reported_length ( iphc_tvb ) ; tvb_memcpy ( iphc_tvb , LOWPAN_NHDR_DATA ( nhdr ) , 0 , nhdr -> length ) ; return nhdr ; } if ( tvb_get_bits8 ( tvb , offset << 3 , LOWPAN_NHC_PATTERN_EXT_BITS ) == LOWPAN_NHC_PATTERN_EXT ) { struct ip6_ext ipv6_ext = { 0 0 } ; guint8 ext_flags ; guint8 ext_hlen ; guint8 ext_len ; guint8 ext_proto ; proto_item * ti_ext_len = NULL ; ext_proto = lowpan_parse_nhc_proto ( tvb , offset ) ; nhc_tree = proto_tree_add_subtree ( tree , tvb , offset , 2 , ett_6lowpan_nhc_ext , NULL , "IPv6 extension header" ) ; proto_tree_add_bits_item ( nhc_tree , hf_6lowpan_nhc_pattern , tvb , offset << 3 , LOWPAN_NHC_PATTERN_EXT_BITS , ENC_BIG_ENDIAN ) ; ext_flags = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_uint ( nhc_tree , hf_6lowpan_nhc_ext_eid , tvb , offset , 1 , ext_flags & LOWPAN_NHC_EXT_EID ) ; proto_tree_add_boolean ( nhc_tree , hf_6lowpan_nhc_ext_nh , tvb , offset , 1 , ext_flags & LOWPAN_NHC_EXT_NHDR ) ; offset += 1 ; if ( ! ( ext_flags & LOWPAN_NHC_EXT_NHDR ) ) { ipv6_ext . ip6e_nxt = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_uint_format_value ( nhc_tree , hf_6lowpan_nhc_ext_next , tvb , offset , 1 , ipv6_ext . ip6e_nxt , "%s (0x%02x)" , ipprotostr ( ipv6_ext . ip6e_nxt ) , ipv6_ext . ip6e_nxt ) ; proto_item_set_end ( ti , tvb , offset + 1 ) ; offset += 1 ; } if ( ext_proto == IP_PROTO_FRAGMENT ) { ext_hlen = 1 ; length = ( guint8 ) sizeof ( ip6_frag ) ; ext_len = length - ext_hlen ; proto_tree_add_item ( nhc_tree , hf_6lowpan_nhc_ext_reserved , tvb , offset , 1 , ENC_NA ) ; } else { ext_hlen = ( guint8 ) sizeof ( ip6_ext ) ; ext_len = tvb_get_guint8 ( tvb , offset ) ; ti_ext_len = proto_tree_add_uint ( nhc_tree , hf_6lowpan_nhc_ext_length , tvb , offset , 1 , ext_len ) ; offset += 1 ; length = ext_hlen + ext_len ; length = ( length + 7 ) & ~ 0x7 ; ipv6_ext . ip6e_len = length >> 3 ; ipv6_ext . ip6e_len -= 1 ; } nhdr = ( lowpan_nhdr * ) wmem_alloc0 ( pinfo -> pool , sizeof ( lowpan_nhdr ) + length ) ; nhdr -> next = NULL ; nhdr -> proto = ext_proto ; nhdr -> length = length ; nhdr -> reported = length ; if ( ext_flags & LOWPAN_NHC_EXT_NHDR ) { ipv6_ext . ip6e_nxt = lowpan_parse_nhc_proto ( tvb , offset + ext_len ) ; } memcpy ( LOWPAN_NHDR_DATA ( nhdr ) , & ipv6_ext , ext_hlen ) ; if ( ! tvb_bytes_exist ( tvb , offset , ext_len ) ) { call_data_dissector ( tvb_new_subset_remaining ( tvb , offset ) , pinfo , nhc_tree ) ; nhdr -> length = tvb_captured_length_remaining ( tvb , offset ) + ext_hlen ; tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr ) + ext_hlen , offset , tvb_captured_length_remaining ( tvb , offset ) ) ; return nhdr ; } if ( ext_proto == IP_PROTO_FRAGMENT ) { call_data_dissector ( tvb_new_subset_length ( tvb , offset + 1 , ext_len - 1 ) , pinfo , nhc_tree ) ; } else { call_data_dissector ( tvb_new_subset_length ( tvb , offset , ext_len ) , pinfo , nhc_tree ) ; } tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr ) + ext_hlen , offset , ext_len ) ; offset += ext_len ; if ( length > ext_hlen + ext_len ) { guint8 padding = length - ( ext_hlen + ext_len ) ; guint8 * pad_ptr = LOWPAN_NHDR_DATA ( nhdr ) + ext_hlen + ext_len ; if ( ext_proto != IP_PROTO_HOPOPTS && ext_proto != IP_PROTO_DSTOPTS ) { expert_add_info ( pinfo , ti_ext_len , & ei_6lowpan_bad_ext_header_length ) ; } if ( padding == 1 ) { pad_ptr [ 0 ] = IP6OPT_PAD1 ; } else { pad_ptr [ 0 ] = IP6OPT_PADN ; pad_ptr [ 1 ] = padding - 2 ; } } if ( ext_flags & LOWPAN_NHC_EXT_NHDR ) { nhdr -> next = dissect_6lowpan_iphc_nhc ( tvb , pinfo , tree , offset , dgram_size - nhdr -> reported , siid , diid ) ; } if ( ipv6_ext . ip6e_nxt != IP_PROTO_NONE ) { length = tvb_captured_length_remaining ( tvb , offset ) ; nhdr -> next = ( lowpan_nhdr * ) wmem_alloc ( pinfo -> pool , sizeof ( lowpan_nhdr ) + length ) ; nhdr -> next -> next = NULL ; nhdr -> next -> proto = ipv6_ext . ip6e_nxt ; nhdr -> next -> length = length ; if ( dgram_size < 0 ) { nhdr -> next -> reported = tvb_reported_length_remaining ( tvb , offset ) ; } else { nhdr -> next -> reported = dgram_size - nhdr -> reported ; } tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr -> next ) , offset , nhdr -> next -> length ) ; } return nhdr ; } if ( tvb_get_bits8 ( tvb , offset << 3 , LOWPAN_NHC_PATTERN_UDP_BITS ) == LOWPAN_NHC_PATTERN_UDP ) { struct udp_hdr udp ; gint src_bitlen ; gint dst_bitlen ; guint8 udp_flags ; guint16 udp_src_port , udp_dst_port ; nhc_tree = proto_tree_add_subtree ( tree , tvb , offset , 1 , ett_6lowpan_nhc_udp , NULL , "UDP header compression" ) ; proto_tree_add_bits_item ( nhc_tree , hf_6lowpan_nhc_pattern , tvb , offset << 3 , LOWPAN_NHC_PATTERN_UDP_BITS , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( nhc_tree , hf_6lowpan_nhc_udp_checksum , tvb , offset , 1 , ENC_NA ) ; proto_tree_add_item ( nhc_tree , hf_6lowpan_nhc_udp_ports , tvb , offset , 1 , ENC_NA ) ; udp_flags = tvb_get_guint8 ( tvb , offset ) ; offset += 1 ; switch ( udp_flags & LOWPAN_NHC_UDP_PORTS ) { case LOWPAN_NHC_UDP_PORT_INLINE : udp_src_port = tvb_get_ntohs ( tvb , offset ) ; udp_dst_port = tvb_get_ntohs ( tvb , offset + 2 ) ; src_bitlen = 16 ; dst_bitlen = 16 ; break ; case LOWPAN_NHC_UDP_PORT_8BIT_DST : udp_src_port = tvb_get_ntohs ( tvb , offset ) ; udp_dst_port = LOWPAN_PORT_8BIT_OFFSET + tvb_get_guint8 ( tvb , offset + 2 ) ; src_bitlen = 16 ; dst_bitlen = 8 ; break ; case LOWPAN_NHC_UDP_PORT_8BIT_SRC : udp_src_port = LOWPAN_PORT_8BIT_OFFSET + tvb_get_guint8 ( tvb , offset ) ; udp_dst_port = tvb_get_ntohs ( tvb , offset + 1 ) ; src_bitlen = 8 ; dst_bitlen = 16 ; break ; case LOWPAN_NHC_UDP_PORT_12BIT : udp_src_port = LOWPAN_PORT_12BIT_OFFSET + ( tvb_get_guint8 ( tvb , offset ) >> 4 ) ; udp_dst_port = LOWPAN_PORT_12BIT_OFFSET + ( tvb_get_guint8 ( tvb , offset ) & 0x0f ) ; src_bitlen = 4 ; dst_bitlen = 4 ; break ; default : DISSECTOR_ASSERT_NOT_REACHED ( ) ; break ; } proto_tree_add_uint ( tree , hf_6lowpan_udp_src , tvb , offset , BITS_TO_BYTE_LEN ( offset << 3 , src_bitlen ) , udp_src_port ) ; proto_tree_add_uint ( tree , hf_6lowpan_udp_dst , tvb , offset + ( src_bitlen >> 3 ) , BITS_TO_BYTE_LEN ( ( offset << 3 ) + src_bitlen , dst_bitlen ) , udp_dst_port ) ; offset += ( ( src_bitlen + dst_bitlen ) >> 3 ) ; udp . src_port = g_htons ( udp_src_port ) ; udp . dst_port = g_htons ( udp_dst_port ) ; if ( ! ( udp_flags & LOWPAN_NHC_UDP_CHECKSUM ) ) { tvb_memcpy ( tvb , & udp . checksum , offset , sizeof ( udp . checksum ) ) ; proto_tree_add_checksum ( tree , tvb , offset , hf_6lowpan_udp_checksum , - 1 , NULL , pinfo , 0 , ENC_BIG_ENDIAN , PROTO_CHECKSUM_NO_FLAGS ) ; offset += 2 ; } else { udp . checksum = 0xffff ; } if ( dgram_size < 0 ) { length = tvb_reported_length_remaining ( tvb , offset ) ; udp . length = g_htons ( length + ( int ) sizeof ( udp_hdr ) ) ; } else { udp . length = g_htons ( dgram_size ) ; } if ( ( udp_flags & LOWPAN_NHC_UDP_CHECKSUM ) && tvb_bytes_exist ( tvb , offset , length ) ) { vec_t cksum_vec [ 3 ] ; { ws_in6_addr src ; ws_in6_addr dst ; guint32 length ; guint8 zero [ 3 ] ; guint8 proto ; } , cksum_phdr memcpy ( & cksum_phdr . src , pinfo -> src . data , sizeof ( ws_in6_addr ) ) ; memcpy ( & cksum_phdr . dst , pinfo -> dst . data , sizeof ( ws_in6_addr ) ) ; cksum_phdr . length = g_htonl ( length + ( int ) sizeof ( udp_hdr ) ) ; memset ( cksum_phdr . zero , 0 , sizeof ( cksum_phdr . zero ) ) ; cksum_phdr . proto = IP_PROTO_UDP ; SET_CKSUM_VEC_PTR ( cksum_vec [ 0 ] , ( const guint8 * ) & cksum_phdr , sizeof ( cksum_phdr ) ) ; SET_CKSUM_VEC_PTR ( cksum_vec [ 1 ] , ( const guint8 * ) & udp , sizeof ( udp_hdr ) ) ; SET_CKSUM_VEC_TVB ( cksum_vec [ 2 ] , tvb , offset , length ) ; udp . checksum = in_cksum ( cksum_vec , 3 ) ; if ( udp . checksum == 0 ) { udp . checksum = 0xffff ; } } length = tvb_captured_length_remaining ( tvb , offset ) ; nhdr = ( lowpan_nhdr * ) wmem_alloc ( pinfo -> pool , sizeof ( lowpan_nhdr ) + sizeof ( udp_hdr ) + length ) ; nhdr -> next = NULL ; nhdr -> proto = IP_PROTO_UDP ; nhdr -> length = length + ( int ) sizeof ( udp_hdr ) ; nhdr -> reported = g_ntohs ( udp . length ) ; memcpy ( LOWPAN_NHDR_DATA ( nhdr ) , & udp , sizeof ( udp_hdr ) ) ; tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr ) + sizeof ( udp_hdr ) , offset , tvb_captured_length_remaining ( tvb , offset ) ) ; return nhdr ; } return NULL ; } 