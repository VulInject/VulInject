PIX * pixRotate ( PIX * pixs , l_float32 angle , l_int32 type , l_int32 incolor , l_int32 width , l_int32 height ) { l_int32 w , h , d ; l_uint32 fillval ; PIX * pix1 , * pix2 , * pix3 , * pixd ; PIXCMAP * cmap ; if ( ! pixs ) { return ( PIX * ) ERROR_PTR ( "pixs not defined" , __func__ , NULL ) ; } if ( type != L_ROTATE_SHEAR && type != L_ROTATE_AREA_MAP && type != L_ROTATE_SAMPLING ) { return ( PIX * ) ERROR_PTR ( "invalid type" , __func__ , NULL ) ; } if ( incolor != L_BRING_IN_WHITE && incolor != L_BRING_IN_BLACK ) { return ( PIX * ) ERROR_PTR ( "invalid incolor" , __func__ , NULL ) ; } if ( L_ABS ( angle ) < MinAngleToRotate ) { return pixClone ( pixs ) ; } if ( pixGetDepth ( pixs ) == 1 ) { if ( L_ABS ( angle ) > Max1BppShearAngle ) { if ( type != L_ROTATE_SAMPLING ) { L_INFO ( "1 bpp, large angle; rotate by sampling\n" , __func__ ) ; } type = L_ROTATE_SAMPLING ; } if ( type != L_ROTATE_SHEAR ) { L_INFO ( "1 bpp; rotate by shear\n" , __func__ ) ; type = L_ROTATE_SHEAR ; } } if ( L_ABS ( angle ) > LimitShearAngle && type == L_ROTATE_SHEAR ) { L_INFO ( "large angle; rotate by sampling\n" , __func__ ) ; type = L_ROTATE_SAMPLING ; } cmap = pixGetColormap ( pixs ) ; if ( cmap && type == L_ROTATE_AREA_MAP ) { pix1 = pixRemoveColormap ( pixs , REMOVE_CMAP_BASED_ON_SRC ) ; } else { pix1 = pixClone ( pixs ) ; } cmap = pixGetColormap ( pix1 ) ; if ( cmap && width == 0 ) { if ( incolor == L_BRING_IN_BLACK ) { pixcmapAddBlackOrWhite ( cmap , 0 , NULL ) ; } else { pixcmapAddBlackOrWhite ( cmap , 1 , NULL ) ; } } pix2 = pixEmbedForRotation ( pix1 , angle , incolor , width , height ) ; d = pixGetDepth ( pix2 ) ; if ( type == L_ROTATE_AREA_MAP && d < 8 ) { pix3 = pixConvertTo8 ( pix2 , FALSE ) ; } else { pix3 = pixClone ( pix2 ) ; } pixGetDimensions ( pix3 , & w , & h , & d ) ; if ( type == L_ROTATE_SHEAR ) { pixd = pixRotateShearCenter ( pix3 , angle , incolor ) ; } if ( type == L_ROTATE_SAMPLING ) { pixd = pixRotateBySampling ( pix3 , w / 2 , h / 2 , angle , incolor ) ; } else { fillval = 0 ; if ( d == 8 ) { pixd = pixRotateAMGray ( pix3 , angle , fillval ) ; } else { pixd = pixRotateAMColor ( pix3 , angle , fillval ) ; } } pixDestroy ( & pix1 ) ; pixDestroy ( & pix2 ) ; pixDestroy ( & pix3 ) ; return pixd ; } 