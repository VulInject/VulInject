void vredraw ( int p ) { int l ; line * tp ; unsigned char temp [ LBSIZE ] ; bool anydl = 0 ; short oldhold = hold ; if ( trace ) { tfixnl ( ) , fprintf ( trace , "vredraw(%d)\n" , p ) , tvliny ( ) ; } if ( holdupd ) { holdupd = 3 ; return ; } if ( state == HARDOPEN || splitw ) { return ; } if ( p < 0 ) { error ( gettext ( "Internal error: vredraw" ) ) ; } CP ( temp , linebuf ) ; l = 0 ; tp = dot - vcline ; if ( vcnt == 0 ) { LINE ( 0 ) = WTOP ; } while ( l < vcnt && LINE ( l ) < p ) { l ++ , tp ++ ; } heldech = 0 ; hold |= HOLDECH ; for ( ; l < vcnt && Peekkey != ATTN ; l ++ ) { if ( l == vcline ) { strcLIN ( temp ) ; } else { getaline ( * tp ) ; } if ( LINE ( l ) != LINE ( l + 1 ) && LINE ( l ) != p ) { if ( anydl == 0 && memory_below && clr_eos ) { hold = oldhold ; vclrech ( 0 ) ; anydl = 1 ; hold |= HOLDECH ; heldech = 0 ; } vdellin ( p , LINE ( l ) - p , l ) ; } LINE ( l ) = p ; if ( FLAGS ( l ) & VDIRT ) { DEPTH ( l ) = vdepth ( ) ; if ( l != vcline && p + DEPTH ( l ) - 1 > WBOT ) { vscrap ( ) ; break ; } FLAGS ( l ) &= ~ VDIRT ; ( void ) vreopen ( p , lineno ( tp ) , l ) ; p = LINE ( l ) + DEPTH ( l ) ; } else { p += DEPTH ( l ) ; } tp ++ ; } if ( state == VISUAL && p <= WBOT ) { int ovcline = vcline ; vcline = l ; for ( ; tp <= dol && Peekkey != ATTN ; tp ++ ) { getaline ( * tp ) ; if ( p + vdepth ( ) - 1 > WBOT ) { break ; } vopen ( tp , p ) ; p += DEPTH ( vcline ) ; vcline ++ ; } vcline = ovcline ; } for ( ; p <= WBOT && Peekkey != ATTN ; p ++ ) { vclrlin ( p , tp ) ; } strcLIN ( temp ) ; hold = oldhold ; if ( heldech ) { vclrech ( 0 ) ; } if ( trace ) { tvliny ( ) ; } } 