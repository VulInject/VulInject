void mpath_cmd ( struct scsi_xfer * xs ) { struct scsi_link * link = xs -> sc_link ; struct mpath_softc * sc = link -> bus -> sb_adapter_softc ; struct mpath_dev * d = sc -> sc_devs [ link -> target ] ; struct mpath_path * p ; struct scsi_xfer * mxs ; if ( d == NULL ) { panic ( "mpath_cmd issued against nonexistent device" ) ; } if ( ISSET ( xs -> flags , SCSI_POLL ) ) { mtx_enter ( & d -> d_mtx ) ; p = mpath_next_path ( d ) ; mtx_leave ( & d -> d_mtx ) ; if ( p == NULL ) { return ; } mxs = scsi_xs_get ( p -> p_link , xs -> flags ) ; if ( mxs == NULL ) { mpath_xs_stuffup ( xs ) ; return ; } memcpy ( & mxs -> cmd , & xs -> cmd , xs -> cmdlen ) ; mxs -> cmdlen = xs -> cmdlen ; mxs -> data = xs -> data ; mxs -> datalen = xs -> datalen ; mxs -> retries = xs -> retries ; mxs -> timeout = xs -> timeout ; mxs -> bp = xs -> bp ; scsi_xs_sync ( mxs ) ; xs -> error = mxs -> error ; xs -> status = mxs -> status ; xs -> resid = mxs -> resid ; memcpy ( & xs -> sense , & mxs -> sense , sizeof ( xs -> sense ) ) ; scsi_xs_put ( mxs ) ; scsi_done ( xs ) ; return ; } mtx_enter ( & d -> d_mtx ) ; SIMPLEQ_INSERT_TAIL ( & d -> d_xfers , xs , xfer_list ) ; p = mpath_next_path ( d ) ; mtx_leave ( & d -> d_mtx ) ; if ( p != NULL ) { scsi_xsh_add ( & p -> p_xsh ) ; } } 