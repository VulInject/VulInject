BranchB { long subexp ; long findsub ; Word_t findbit ; Word_t lowermask ; Word_t jpcount ; Word_t clbelow ; Word_t clabove ; Pjbb = P_JBB ( Pjp -> jp_Addr ) ; findsub = digit / cJU_BITSPERSUBEXPB ; findbit = digit % cJU_BITSPERSUBEXPB ; lowermask = JU_MASKLOWERINC ( JU_BITPOSMASKB ( findbit ) ) ; clbelow = clabove = 0 ; assert ( JU_BITMAPTESTB ( Pjbb , digit ) ) ; assert ( findsub < cJU_NUMSUBEXPB ) ; ( ( ( ( jpcount ) * cJU_WORDSPERJP ) + cJU_WORDSPERCL - 1 ) / cJU_WORDSPERCL ) ; for ( subexp = 0 ; subexp < cJU_NUMSUBEXPB ; ++ subexp ) { jpcount = j__udyCountBitsB ( JU_JBB_BITMAP ( Pjbb , subexp ) ) ; if ( subexp < findsub ) { clbelow += CLPERJPS ( jpcount ) ; } if ( subexp > findsub ) { clabove += CLPERJPS ( jpcount ) ; } else { Word_t clfind ; clfind = CLPERJPS ( j__udyCountBitsB ( JU_JBB_BITMAP ( Pjbb , subexp ) & lowermask ) ) ; assert ( clfind > 0 ) ; clbelow += clfind - 1 ; clabove += CLPERJPS ( jpcount ) - clfind ; } } jpnum = 0 ; if ( clbelow < clabove ) { ++ jbb_upward ; pop1above = pop1 ; for ( subexp = 0 ; subexp <= findsub ; ++ subexp ) { jpcount = j__udyCountBitsB ( ( subexp < findsub ) ?JU_JBB_BITMAP ( Pjbb , subexp ) : JU_JBB_BITMAP ( Pjbb , subexp ) & lowermask ) ; assert ( ( subexp < findsub ) || jpcount ) ; assert ( jpcount || ( BMPJP0 ( subexp ) == ( Pjp_t ) NULL ) ) ; assert ( ( ! jpcount ) || ( BMPJP0 ( subexp ) != ( Pjp_t ) NULL ) ) ; for ( jpnum = 0 ; jpnum < jpcount ; ++ jpnum ) { if ( ( pop1 = j__udyJPPop1 ( BMPJP ( subexp , jpnum ) ) ) == cJU_ALLONES ) { JU_SET_ERRNO_NONNULL ( Pjpm , JU_ERRNO_CORRUPT ) ; return ( C_JERR ) ; } pop1above -= pop1 ; } jpnum = jpcount - 1 ; } } else { long jpcountbf ; ++ jbb_downward ; pop1above = 0 ; jpcountbf = 0 ; for ( subexp = cJU_NUMSUBEXPB - 1 ; subexp >= findsub ; -- subexp ) { jpcount = j__udyCountBitsB ( JU_JBB_BITMAP ( Pjbb , subexp ) ) ; assert ( ( subexp > findsub ) || jpcount ) ; if ( ! jpcount ) { continue ; } if ( subexp == findsub ) { jpcountbf = j__udyCountBitsB ( JU_JBB_BITMAP ( Pjbb , subexp ) & lowermask ) ; } assert ( ( subexp > findsub ) || jpcountbf ) ; assert ( jpcount >= jpcountbf ) ; assert ( BMPJP0 ( subexp ) != ( Pjp_t ) NULL ) ; for ( jpnum = jpcount - 1 ; jpnum >= jpcountbf ; -- jpnum ) { if ( ( pop1 = j__udyJPPop1 ( BMPJP ( subexp , jpnum ) ) ) == cJU_ALLONES ) { JU_SET_ERRNO_NONNULL ( Pjpm , JU_ERRNO_CORRUPT ) ; return ( C_JERR ) ; } pop1above += pop1 ; } } } pop1 = j__udy1LCountSM ( BMPJP ( findsub , jpnum ) , Index , Pjpm ) ; assert ( pop1above + pop1 ) ; return ( pop1above + pop1 ) ; } case cJU_JPBRANCH_U2 : CHECKDCD ( Pjp , 2 ) ; PREPB ( Pjp , 2 , BranchU ) ; case cJU_JPBRANCH_U3 : CHECKDCD ( Pjp , 3 ) ; PREPB ( Pjp , 3 , BranchU ) ; case cJU_JPBRANCH_U4 : CHECKDCD ( Pjp , 4 ) ; PREPB ( Pjp , 4 , BranchU ) ; case cJU_JPBRANCH_U5 : CHECKDCD ( Pjp , 5 ) ; PREPB ( Pjp , 5 , BranchU ) ; case cJU_JPBRANCH_U6 : CHECKDCD ( Pjp , 6 ) ; PREPB ( Pjp , 6 , BranchU ) ; case cJU_JPBRANCH_U7 : CHECKDCD ( Pjp , 7 ) ; PREPB ( Pjp , 7 , BranchU ) ; case cJU_JPBRANCH_U : PREPB_ROOT ( Pjp , BranchU ) ; BranchU Pjbu = P_JBU ( Pjp -> jp_Addr ) ; if ( digit < ( cJU_BRANCHUNUMJPS / 2 ) ) { pop1above = pop1 ; ++ jbu_upward ; for ( jpnum = 0 ; jpnum <= digit ; ++ jpnum ) { if ( ( Pjbu -> jbu_jp [ jpnum ] . jp_Type ) <= cJU_JPNULLMAX ) { continue ; } if ( ( pop1 = j__udyJPPop1 ( Pjbu -> jbu_jp + jpnum ) ) == cJU_ALLONES ) { JU_SET_ERRNO_NONNULL ( Pjpm , JU_ERRNO_CORRUPT ) ; return ( C_JERR ) ; } pop1above -= pop1 ; } } else { assert ( digit < cJU_BRANCHUNUMJPS ) ; ++ jbu_downward ; pop1above = 0 ; for ( jpnum = cJU_BRANCHUNUMJPS - 1 ; jpnum > digit ; -- jpnum ) { if ( ( Pjbu -> jbu_jp [ jpnum ] . jp_Type ) <= cJU_JPNULLMAX ) { continue ; } if ( ( pop1 = j__udyJPPop1 ( Pjbu -> jbu_jp + jpnum ) ) == cJU_ALLONES ) { JU_SET_ERRNO_NONNULL ( Pjpm , JU_ERRNO_CORRUPT ) ; return ( C_JERR ) ; } pop1above += pop1 ; } } if ( ( pop1 = j__udy1LCountSM ( Pjbu -> jbu_jp + digit , Index , Pjpm ) ) == C_JERR ) { return ( C_JERR ) ; } assert ( pop1above + pop1 ) ; return ( pop1above + pop1 ) ; Pjll = P_JLL ( Pjp -> jp_Addr ) ; pop1 = JU_JPLEAF_POP0 ( Pjp ) + 1 ; LEAFABOVE ( , , ) Pjll = ( Pjll_t ) Pjp ; LEAFABOVE ( , , ) LEAFABOVE ( , , ) offset = Func ( Pjll , Pop1 , Index ) ; assert ( offset >= 0 ) ; assert ( offset < ( Pop1 ) ) ; return ( ( Pop1 ) - offset ) assert ( ( JU_JPDCDPOP0 ( Pjp ) ) == JU_TRIMTODCDSIZE ( Index ) ) ; return ( 1 ) ; case cJU_JPLEAF1 : LEAFLABOVE ( j__udySearchLeaf1 ) ; case cJU_JPLEAF2 : LEAFLABOVE ( j__udySearchLeaf2 ) ; case cJU_JPLEAF3 : LEAFLABOVE ( j__udySearchLeaf3 ) ; case cJU_JPLEAF4 : LEAFLABOVE ( j__udySearchLeaf4 ) ; case cJU_JPLEAF5 : LEAFLABOVE ( j__udySearchLeaf5 ) ; case cJU_JPLEAF6 : LEAFLABOVE ( j__udySearchLeaf6 ) ; case cJU_JPLEAF7 : LEAFLABOVE ( j__udySearchLeaf7 ) ; case cJU_JPLEAF_B1 : LEAFB1ABOVE ( j__udyCountLeafB1 ) ; case cJ1_JPFULLPOPU1 : return ( cJU_JPFULLPOPU1_POP0 + 1 - JU_DIGITATSTATE ( Index , 1 ) ) ; case cJU_JPIMMED_1_01 : IMMABOVE_01 ; case cJU_JPIMMED_2_01 : IMMABOVE_01 ; case cJU_JPIMMED_3_01 : IMMABOVE_01 ; case cJU_JPIMMED_4_01 : IMMABOVE_01 ; case cJU_JPIMMED_5_01 : IMMABOVE_01 ; case cJU_JPIMMED_6_01 : IMMABOVE_01 ; case cJU_JPIMMED_7_01 : IMMABOVE_01 ; case cJU_JPIMMED_1_02 : IMMABOVE ( j__udySearchLeaf1 , 2 ) ; case cJU_JPIMMED_1_03 : IMMABOVE ( j__udySearchLeaf1 , 3 ) ; case cJU_JPIMMED_1_04 : IMMABOVE ( j__udySearchLeaf1 , 4 ) ; case cJU_JPIMMED_1_05 : IMMABOVE ( j__udySearchLeaf1 , 5 ) ; case cJU_JPIMMED_1_06 : IMMABOVE ( j__udySearchLeaf1 , 6 ) ; case cJU_JPIMMED_1_07 : IMMABOVE ( j__udySearchLeaf1 , 7 ) ; case cJ1_JPIMMED_1_08 : IMMABOVE ( j__udySearchLeaf1 , 8 ) ; case cJ1_JPIMMED_1_09 : IMMABOVE ( j__udySearchLeaf1 , 9 ) ; case cJ1_JPIMMED_1_10 : IMMABOVE ( j__udySearchLeaf1 , 10 ) ; case cJ1_JPIMMED_1_11 : IMMABOVE ( j__udySearchLeaf1 , 11 ) ; case cJ1_JPIMMED_1_12 : IMMABOVE ( j__udySearchLeaf1 , 12 ) ; case cJ1_JPIMMED_1_13 : IMMABOVE ( j__udySearchLeaf1 , 13 ) ; case cJ1_JPIMMED_1_14 : IMMABOVE ( j__udySearchLeaf1 , 14 ) ; case cJ1_JPIMMED_1_15 : IMMABOVE ( j__udySearchLeaf1 , 15 ) ; case cJU_JPIMMED_2_02 : IMMABOVE ( j__udySearchLeaf2 , 2 ) ; case cJU_JPIMMED_2_03 : IMMABOVE ( j__udySearchLeaf2 , 3 ) ; case cJ1_JPIMMED_2_04 : IMMABOVE ( j__udySearchLeaf2 , 4 ) ; case cJ1_JPIMMED_2_05 : IMMABOVE ( j__udySearchLeaf2 , 5 ) ; case cJ1_JPIMMED_2_06 : IMMABOVE ( j__udySearchLeaf2 , 6 ) ; case cJ1_JPIMMED_2_07 : IMMABOVE ( j__udySearchLeaf2 , 7 ) ; case cJU_JPIMMED_3_02 : IMMABOVE ( j__udySearchLeaf3 , 2 ) ; case cJ1_JPIMMED_3_03 : IMMABOVE ( j__udySearchLeaf3 , 3 ) ; case cJ1_JPIMMED_3_04 : IMMABOVE ( j__udySearchLeaf3 , 4 ) ; case cJ1_JPIMMED_3_05 : IMMABOVE ( j__udySearchLeaf3 , 5 ) ; case cJ1_JPIMMED_4_02 : IMMABOVE ( j__udySearchLeaf4 , 2 ) ; case cJ1_JPIMMED_4_03 : IMMABOVE ( j__udySearchLeaf4 , 3 ) ; case cJ1_JPIMMED_5_02 : IMMABOVE ( j__udySearchLeaf5 , 2 ) ; case cJ1_JPIMMED_5_03 : IMMABOVE ( j__udySearchLeaf5 , 3 ) ; case cJ1_JPIMMED_6_02 : IMMABOVE ( j__udySearchLeaf6 , 2 ) ; case cJ1_JPIMMED_7_02 : IMMABOVE ( j__udySearchLeaf7 , 2 ) ; default : JU_SET_ERRNO_NONNULL ( Pjpm , JU_ERRNO_CORRUPT ) ; return ( C_JERR ) ; 