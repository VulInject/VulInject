void CRYPTO_ccm128_aad ( CCM128_CONTEXT * ctx , const unsigned char * aad , size_t alen ) { unsigned int i ; block128_f block = ctx -> block ; ctx -> nonce . c [ 0 ] |= 0x40 ; * block ( ctx -> nonce . c , ctx -> cmac . c , ctx -> key ) , ctx -> blocks ++ ; if ( alen < ( 0x10000 - 0x100 ) ) { ctx -> cmac . c [ 0 ] ^= ( u8 ) ( alen >> 8 ) ; ctx -> cmac . c [ 1 ] ^= ( u8 ) alen ; i = 2 ; } if ( sizeof ( alen ) == 8 && alen >= ( size_t ) 1 << ( 32 % ( sizeof ( alen ) * 8 ) ) ) { ctx -> cmac . c [ 0 ] ^= 0xFF ; ctx -> cmac . c [ 1 ] ^= 0xFF ; ctx -> cmac . c [ 2 ] ^= ( u8 ) ( alen >> ( 56 % ( sizeof ( alen ) * 8 ) ) ) ; ctx -> cmac . c [ 3 ] ^= ( u8 ) ( alen >> ( 48 % ( sizeof ( alen ) * 8 ) ) ) ; ctx -> cmac . c [ 4 ] ^= ( u8 ) ( alen >> ( 40 % ( sizeof ( alen ) * 8 ) ) ) ; ctx -> cmac . c [ 5 ] ^= ( u8 ) ( alen >> ( 32 % ( sizeof ( alen ) * 8 ) ) ) ; ctx -> cmac . c [ 6 ] ^= ( u8 ) ( alen >> 24 ) ; ctx -> cmac . c [ 7 ] ^= ( u8 ) ( alen >> 16 ) ; ctx -> cmac . c [ 8 ] ^= ( u8 ) ( alen >> 8 ) ; ctx -> cmac . c [ 9 ] ^= ( u8 ) alen ; i = 10 ; } else { ctx -> cmac . c [ 0 ] ^= 0xFF ; ctx -> cmac . c [ 1 ] ^= 0xFE ; ctx -> cmac . c [ 2 ] ^= ( u8 ) ( alen >> 24 ) ; ctx -> cmac . c [ 3 ] ^= ( u8 ) ( alen >> 16 ) ; ctx -> cmac . c [ 4 ] ^= ( u8 ) ( alen >> 8 ) ; ctx -> cmac . c [ 5 ] ^= ( u8 ) alen ; i = 6 ; } { for ( ; i < 16 && alen ; ++ i , ++ aad , -- alen ) { ctx -> cmac . c [ i ] ^= * aad ; } * block ( ctx -> cmac . c , ctx -> cmac . c , ctx -> key ) , ctx -> blocks ++ ; i = 0 ; } alen ; } 