static void chx_txdone ( fsm_instance * fi , int event , void * arg ) { struct channel * ch = arg ; struct net_device * dev = ch -> netdev ; struct ctcm_priv * priv = dev -> ml_priv ; struct sk_buff * skb ; int first = 1 ; int i ; unsigned long duration ; unsigned long done_stamp = jiffies ; CTCM_PR_DEBUG ( "%s(%s): %s\n" , __func__ , ch -> id , dev -> name ) ; duration = done_stamp - ch -> prof . send_stamp ; if ( duration > ch -> prof . tx_time ) { ch -> prof . tx_time = duration ; } if ( ch -> irb -> scsw . cmd . count != 0 ) { CTCM_DBF_TEXT_ ( TRACE , CTC_DBF_DEBUG , "%s(%s): TX not complete, remaining %d bytes" , CTCM_FUNTAIL , dev -> name , ch -> irb -> scsw . cmd . count ) ; } fsm_deltimer ( & ch -> timer ) ; while ( ( skb = skb_dequeue ( & ch -> io_queue ) ) ) { priv -> stats . tx_packets ++ ; priv -> stats . tx_bytes += skb -> len - LL_HEADER_LENGTH ; if ( first ) { priv -> stats . tx_bytes += 2 ; first = 0 ; } atomic_dec ( & skb -> users ) ; dev_kfree_skb_irq ( skb ) ; } spin_lock ( & ch -> collect_lock ) ; clear_normalized_cda ( & ch -> ccw [ 4 ] ) ; if ( ch -> collect_len > 0 ) { int rc ; if ( ctcm_checkalloc_buffer ( ch ) ) { spin_unlock ( & ch -> collect_lock ) ; return ; } ch -> trans_skb -> data = ch -> trans_skb_data ; skb_reset_tail_pointer ( ch -> trans_skb ) ; ch -> trans_skb -> len = 0 ; if ( ch -> prof . maxmulti < ( ch -> collect_len + 2 ) ) { ch -> prof . maxmulti = ch -> collect_len + 2 ; } if ( ch -> prof . maxcqueue < skb_queue_len ( & ch -> collect_queue ) ) { ch -> prof . maxcqueue = skb_queue_len ( & ch -> collect_queue ) ; } * ( ( __u16 * ) skb_put ( ch -> trans_skb , 2 ) ) = ch -> collect_len + 2 ; i = 0 ; while ( ( skb = skb_dequeue ( & ch -> collect_queue ) ) ) { skb_copy_from_linear_data ( skb , skb_put ( ch -> trans_skb , skb -> len ) , skb -> len ) ; priv -> stats . tx_packets ++ ; priv -> stats . tx_bytes += skb -> len - LL_HEADER_LENGTH ; atomic_dec ( & skb -> users ) ; dev_kfree_skb_irq ( skb ) ; i ++ ; } ch -> collect_len = 0 ; spin_unlock ( & ch -> collect_lock ) ; ch -> ccw [ 1 ] . count = ch -> trans_skb -> len ; fsm_addtimer ( & ch -> timer , CTCM_TIME_5_SEC , CTC_EVENT_TIMER , ch ) ; ch -> prof . send_stamp = jiffies ; rc = ccw_device_start ( ch -> cdev , & ch -> ccw [ 0 ] , ( unsigned long ) ch , 0xff , 0 ) ; ch -> prof . doios_multi ++ ; } else { spin_unlock ( & ch -> collect_lock ) ; fsm_newstate ( fi , CTC_STATE_TXIDLE ) ; } ctcm_clear_busy_do ( dev ) ; } 