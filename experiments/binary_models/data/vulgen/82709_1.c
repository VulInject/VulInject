static int deserialize_nvpair ( topo_hdl_t * thp , topo_mod_t * mod , nvlist_t * nvl , xmlNodePtr xn ) { int ret = - 1 ; xmlChar * name = NULL , * type = NULL , * sval = NULL ; uint64_t val ; if ( ( name = xmlGetProp ( xn , ( xmlChar * ) TDG_XML_NAME ) ) == NULL || ( type = xmlGetProp ( xn , ( xmlChar * ) TDG_XML_TYPE ) ) == NULL ) { fail } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_NVLIST ) == 0 ) { nvlist_t * cnvl = NULL ; if ( topo_hdl_nvalloc ( thp , & cnvl , NV_UNIQUE_NAME ) != 0 ) { fail } for ( xmlNodePtr cn = xn -> xmlChildrenNode ; cn != NULL ; cn = cn -> next ) { if ( xmlStrcmp ( cn -> name , ( xmlChar * ) TDG_XML_NVLIST ) != 0 ) { continue ; } for ( xmlNodePtr gcn = cn -> xmlChildrenNode ; gcn != NULL ; gcn = gcn -> next ) { if ( xmlStrcmp ( gcn -> name , ( xmlChar * ) TDG_XML_NVPAIR ) != 0 ) { continue ; } if ( deserialize_nvpair ( thp , mod , cnvl , gcn ) != 0 ) { fail } } if ( nvlist_add_nvlist ( nvl , ( char * ) name , cnvl ) != 0 ) { nvlist_free ( cnvl ) ; fail } nvlist_free ( cnvl ) ; break ; } } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_INT8 ) == 0 ) { if ( xmlattr_to_int ( mod , xn , TDG_XML_VALUE , & val ) != 0 || is_overflow ( thp , val , 8 ) || nvlist_add_int8 ( nvl , ( char * ) name , ( int8_t ) val ) != 0 ) { fail } } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_INT16 ) == 0 ) { if ( xmlattr_to_int ( mod , xn , TDG_XML_VALUE , & val ) != 0 || is_overflow ( thp , val , 16 ) || nvlist_add_int16 ( nvl , ( char * ) name , ( int16_t ) val ) != 0 ) { fail } } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_INT32 ) == 0 ) { if ( xmlattr_to_int ( mod , xn , TDG_XML_VALUE , & val ) != 0 || is_overflow ( thp , val , 32 ) || nvlist_add_int32 ( nvl , ( char * ) name , ( int32_t ) val ) != 0 ) { fail } } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_INT64 ) == 0 ) { if ( xmlattr_to_int ( mod , xn , TDG_XML_VALUE , & val ) != 0 || nvlist_add_int64 ( nvl , ( char * ) name , ( int64_t ) val ) != 0 ) { fail } } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_UINT8 ) == 0 ) { if ( xmlattr_to_int ( mod , xn , TDG_XML_VALUE , & val ) != 0 || is_overflow ( thp , val , 8 ) || nvlist_add_uint8 ( nvl , ( char * ) name , ( uint8_t ) val ) != 0 ) { fail } } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_UINT16 ) == 0 ) { if ( xmlattr_to_int ( mod , xn , TDG_XML_VALUE , & val ) != 0 || is_overflow ( thp , val , 16 ) || nvlist_add_uint16 ( nvl , ( char * ) name , ( uint16_t ) val ) != 0 ) { fail } } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_UINT32 ) == 0 ) { if ( xmlattr_to_int ( mod , xn , TDG_XML_VALUE , & val ) != 0 || is_overflow ( thp , val , 32 ) || nvlist_add_uint32 ( nvl , ( char * ) name , ( uint32_t ) val ) != 0 ) { fail } } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_UINT64 ) == 0 ) { if ( xmlattr_to_int ( mod , xn , TDG_XML_VALUE , & val ) != 0 || nvlist_add_uint64 ( nvl , ( char * ) name , ( uint64_t ) val ) != 0 ) { fail } } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_STRING ) == 0 ) { if ( ( sval = xmlGetProp ( xn , ( xmlChar * ) TDG_XML_VALUE ) ) == NULL || nvlist_add_string ( nvl , ( char * ) name , ( char * ) sval ) != 0 ) { fail } } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_NVLIST_ARR ) == 0 ) { uint64_t nelem = 0 ; nvlist_t * * nvlarr = NULL ; uint_t i = 0 ; xmlNodePtr cn = xn -> xmlChildrenNode ; while ( cn != NULL ) { if ( xmlStrcmp ( cn -> name , ( xmlChar * ) TDG_XML_NVLIST ) == 0 ) { nelem ++ ; } cn = cn -> next ; } if ( ( nvlarr = topo_hdl_zalloc ( thp , ( nelem * sizeof ( nvlist_t * ) ) ) ) == NULL ) { fail } for ( cn = xn -> xmlChildrenNode ; cn != NULL ; cn = cn -> next ) { if ( xmlStrcmp ( cn -> name , ( xmlChar * ) TDG_XML_NVLIST ) != 0 ) { continue ; } if ( topo_hdl_nvalloc ( thp , & nvlarr [ i ] , NV_UNIQUE_NAME ) != 0 ) { free_nvlist_array ( thp , nvlarr , nelem ) ; fail } for ( xmlNodePtr gcn = cn -> xmlChildrenNode ; gcn != NULL ; gcn = gcn -> next ) { if ( xmlStrcmp ( gcn -> name , ( xmlChar * ) TDG_XML_NVPAIR ) != 0 ) { continue ; } if ( deserialize_nvpair ( thp , mod , nvlarr [ i ] , gcn ) != 0 ) { free_nvlist_array ( thp , nvlarr , nelem ) ; fail } } i ++ ; } if ( nvlist_add_nvlist_array ( nvl , ( char * ) name , nvlarr , nelem ) != 0 ) { free_nvlist_array ( thp , nvlarr , nelem ) ; fail } free_nvlist_array ( thp , nvlarr , nelem ) ; } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_UINT32_ARR ) == 0 ) { uint64_t nelem = 0 ; uint32_t * arr = NULL ; uint_t i = 0 ; xmlNodePtr cn = xn -> xmlChildrenNode ; while ( cn != NULL ) { if ( xmlStrcmp ( cn -> name , ( xmlChar * ) TDG_XML_NVPAIR ) == 0 ) { nelem ++ ; } cn = cn -> next ; } if ( ( arr = topo_hdl_zalloc ( thp , ( nelem * sizeof ( uint32_t ) ) ) ) == NULL ) { fail } for ( cn = xn -> xmlChildrenNode ; cn != NULL ; cn = cn -> next ) { if ( xmlStrcmp ( cn -> name , ( xmlChar * ) TDG_XML_NVPAIR ) != 0 ) { continue ; } if ( xmlattr_to_int ( mod , cn , TDG_XML_VALUE , & val ) != 0 ) { topo_hdl_free ( thp , arr , ( nelem * sizeof ( uint32_t ) ) ) ; fail } arr [ i ] = val ; i ++ ; } if ( nvlist_add_uint32_array ( nvl , ( char * ) name , arr , nelem ) != 0 ) { topo_hdl_free ( thp , arr , ( nelem * sizeof ( uint32_t ) ) ) ; fail } topo_hdl_free ( thp , arr , ( nelem * sizeof ( uint32_t ) ) ) ; } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_INT32_ARR ) == 0 ) { uint64_t nelem = 0 ; int32_t * arr = NULL ; uint_t i = 0 ; xmlNodePtr cn = xn -> xmlChildrenNode ; while ( cn != NULL ) { if ( xmlStrcmp ( cn -> name , ( xmlChar * ) TDG_XML_NVPAIR ) == 0 ) { nelem ++ ; } cn = cn -> next ; } if ( ( arr = topo_hdl_zalloc ( thp , ( nelem * sizeof ( int32_t ) ) ) ) == NULL ) { fail } for ( cn = xn -> xmlChildrenNode ; cn != NULL ; cn = cn -> next ) { if ( xmlStrcmp ( cn -> name , ( xmlChar * ) TDG_XML_NVPAIR ) != 0 ) { continue ; } if ( xmlattr_to_int ( mod , cn , TDG_XML_VALUE , & val ) != 0 ) { topo_hdl_free ( thp , arr , ( nelem * sizeof ( int32_t ) ) ) ; fail } arr [ i ] = val ; i ++ ; } if ( nvlist_add_int32_array ( nvl , ( char * ) name , arr , nelem ) != 0 ) { topo_hdl_free ( thp , arr , ( nelem * sizeof ( int32_t ) ) ) ; fail } topo_hdl_free ( thp , arr , ( nelem * sizeof ( int32_t ) ) ) ; } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_UINT64_ARR ) == 0 ) { uint64_t nelem = 0 , * arr = NULL ; uint_t i = 0 ; xmlNodePtr cn = xn -> xmlChildrenNode ; while ( cn != NULL ) { if ( xmlStrcmp ( cn -> name , ( xmlChar * ) TDG_XML_NVPAIR ) == 0 ) { nelem ++ ; } cn = cn -> next ; } if ( ( arr = topo_hdl_zalloc ( thp , ( nelem * sizeof ( uint64_t ) ) ) ) == NULL ) { fail } for ( cn = xn -> xmlChildrenNode ; cn != NULL ; cn = cn -> next ) { if ( xmlStrcmp ( cn -> name , ( xmlChar * ) TDG_XML_NVPAIR ) != 0 ) { continue ; } if ( xmlattr_to_int ( mod , cn , TDG_XML_VALUE , & val ) != 0 ) { topo_hdl_free ( thp , arr , ( nelem * sizeof ( uint64_t ) ) ) ; fail } arr [ i ] = val ; i ++ ; } if ( nvlist_add_uint64_array ( nvl , ( char * ) name , arr , nelem ) != 0 ) { topo_hdl_free ( thp , arr , ( nelem * sizeof ( uint64_t ) ) ) ; fail } topo_hdl_free ( thp , arr , ( nelem * sizeof ( uint64_t ) ) ) ; } if ( xmlStrcmp ( type , ( xmlChar * ) TDG_XML_INT64_ARR ) == 0 ) { uint64_t nelem = 0 ; int64_t * arr = NULL ; uint_t i = 0 ; xmlNodePtr cn = xn -> xmlChildrenNode ; while ( cn != NULL ) { if ( xmlStrcmp ( cn -> name , ( xmlChar * ) TDG_XML_NVPAIR ) == 0 ) { nelem ++ ; } cn = cn -> next ; } if ( ( arr = topo_hdl_zalloc ( thp , ( nelem * sizeof ( int64_t ) ) ) ) == NULL ) { fail } for ( cn = xn -> xmlChildrenNode ; cn != NULL ; cn = cn -> next ) { if ( xmlStrcmp ( cn -> name , ( xmlChar * ) TDG_XML_NVPAIR ) != 0 ) { continue ; } if ( xmlattr_to_int ( mod , cn , TDG_XML_VALUE , & val ) != 0 ) { topo_hdl_free ( thp , arr , ( nelem * sizeof ( int64_t ) ) ) ; fail } arr [ i ] = val ; i ++ ; } if ( nvlist_add_int64_array ( nvl , ( char * ) name , arr , nelem ) != 0 ) { topo_hdl_free ( thp , arr , ( nelem * sizeof ( int64_t ) ) ) ; fail } topo_hdl_free ( thp , arr , ( nelem * sizeof ( int64_t ) ) ) ; } ret = 0 ; fail if ( ret != 0 ) { topo_dprintf ( thp , TOPO_DBG_XML , "%s: error parsing %s " "element: name: %s, type: %s, nvl: %p" , __func__ , xn -> name , ( name != NULL ) ?( char * ) name : "MISSING!" , ( type != NULL ) ?( char * ) type : "MISSING!" , nvl ) ; dump_xml_node ( thp , xn ) ; } if ( name != NULL ) { xmlFree ( name ) ; } if ( type != NULL ) { xmlFree ( type ) ; } if ( sval != NULL ) { xmlFree ( sval ) ; } return ( ret ) ; } 