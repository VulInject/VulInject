static void s626_reset_adc ( struct comedi_device * dev , u8 * ppl ) { struct s626_private * devpriv = dev -> private ; struct comedi_subdevice * s = dev -> read_subdev ; struct comedi_cmd * cmd = & s -> async -> cmd ; u32 * rps ; u32 jmp_adrs ; u16 i ; u16 n ; s626_mc_disable ( dev , S626_MC1_ERPS1 , S626_P_MC1 ) ; rps = ( u32 * ) devpriv -> rps_buf . logical_base ; writel ( ( u32 ) devpriv -> rps_buf . physical_base , dev -> mmio + S626_P_RPSADDR1 ) ; if ( cmd -> scan_begin_src != TRIG_FOLLOW ) { * rps ++ = S626_RPS_PAUSE | S626_RPS_SIGADC ; * rps ++ = S626_RPS_CLRSIGNAL | S626_RPS_SIGADC ; } * rps ++ = S626_RPS_LDREG | ( S626_P_DEBICMD >> 2 ) ; * rps ++ = S626_DEBI_CMD_WRWORD | S626_LP_GSEL ; * rps ++ = S626_RPS_LDREG | ( S626_P_DEBIAD >> 2 ) ; * rps ++ = S626_GSEL_BIPOLAR5V ; * rps ++ = S626_RPS_CLRSIGNAL | S626_RPS_DEBI ; * rps ++ = S626_RPS_UPLOAD | S626_RPS_DEBI ; * rps ++ = S626_RPS_PAUSE | S626_RPS_DEBI ; for ( devpriv -> adc_items = 0 ; devpriv -> adc_items < 16 ; devpriv -> adc_items ++ ) { local_ppl = ( * ppl << 8 ) | ( * ppl & 0x10 ?S626_GSEL_BIPOLAR5V : S626_GSEL_BIPOLAR10V ) ; * rps ++ = S626_RPS_LDREG | ( S626_P_DEBICMD >> 2 ) ; * rps ++ = S626_DEBI_CMD_WRWORD | S626_LP_GSEL ; * rps ++ = S626_RPS_LDREG | ( S626_P_DEBIAD >> 2 ) ; * rps ++ = local_ppl ; * rps ++ = S626_RPS_CLRSIGNAL | S626_RPS_DEBI ; * rps ++ = S626_RPS_UPLOAD | S626_RPS_DEBI ; * rps ++ = S626_RPS_PAUSE | S626_RPS_DEBI ; * rps ++ = S626_RPS_LDREG | ( S626_P_DEBICMD >> 2 ) ; * rps ++ = S626_DEBI_CMD_WRWORD | S626_LP_ISEL ; * rps ++ = S626_RPS_LDREG | ( S626_P_DEBIAD >> 2 ) ; * rps ++ = local_ppl ; * rps ++ = S626_RPS_CLRSIGNAL | S626_RPS_DEBI ; * rps ++ = S626_RPS_UPLOAD | S626_RPS_DEBI ; * rps ++ = S626_RPS_PAUSE | S626_RPS_DEBI ; jmp_adrs = ( u32 ) devpriv -> rps_buf . physical_base + ( u32 ) ( ( unsigned long ) rps - ( unsigned long ) devpriv -> rps_buf . logical_base ) ; for ( i = 0 ; i < ( 10 * S626_RPSCLK_PER_US / 2 ) ; i ++ ) { jmp_adrs += 8 ; * rps ++ = S626_RPS_JUMP ; * rps ++ = jmp_adrs ; } if ( cmd -> convert_src != TRIG_NOW ) { * rps ++ = S626_RPS_PAUSE | S626_RPS_SIGADC ; * rps ++ = S626_RPS_CLRSIGNAL | S626_RPS_SIGADC ; } * rps ++ = S626_RPS_LDREG | ( S626_P_GPIO >> 2 ) ; * rps ++ = S626_GPIO_BASE | S626_GPIO1_LO ; * rps ++ = S626_RPS_NOP ; * rps ++ = S626_RPS_LDREG | ( S626_P_GPIO >> 2 ) ; * rps ++ = S626_GPIO_BASE | S626_GPIO1_HI ; * rps ++ = S626_RPS_PAUSE | S626_RPS_GPIO2 ; * rps ++ = S626_RPS_STREG | ( S626_BUGFIX_STREG ( S626_P_FB_BUFFER1 ) >> 2 ) ; * rps ++ = ( u32 ) devpriv -> ana_buf . physical_base + ( devpriv -> adc_items << 2 ) ; if ( * ppl ++ & S626_EOPL ) { devpriv -> adc_items ++ ; break ; } } for ( n = 0 ; n < ( 2 * S626_RPSCLK_PER_US ) ; n ++ ) { * rps ++ = S626_RPS_NOP ; } * rps ++ = S626_RPS_LDREG | ( S626_P_GPIO >> 2 ) ; * rps ++ = S626_GPIO_BASE | S626_GPIO1_LO ; * rps ++ = S626_RPS_NOP ; * rps ++ = S626_RPS_LDREG | ( S626_P_GPIO >> 2 ) ; * rps ++ = S626_GPIO_BASE | S626_GPIO1_HI ; * rps ++ = S626_RPS_PAUSE | S626_RPS_GPIO2 ; * rps ++ = S626_RPS_STREG | ( S626_BUGFIX_STREG ( S626_P_FB_BUFFER1 ) >> 2 ) ; * rps ++ = ( u32 ) devpriv -> ana_buf . physical_base + ( devpriv -> adc_items << 2 ) ; if ( devpriv -> ai_cmd_running == 1 ) { * rps ++ = S626_RPS_IRQ ; } * rps ++ = S626_RPS_JUMP ; * rps ++ = ( u32 ) devpriv -> rps_buf . physical_base ; } 