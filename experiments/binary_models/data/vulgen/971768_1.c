void dwgpio_attach ( struct device * parent , struct device * self , void * aux ) { struct acpi_attach_args * aaa = aux ; struct dwgpio_softc * sc = ( dwgpio_softc * ) self ; int i ; sc -> sc_acpi = ( acpi_softc * ) parent ; sc -> sc_node = aaa -> aaa_node ; printf ( " %s" , sc -> sc_node -> name ) ; printf ( " addr 0x%llx/0x%llx" , aaa -> aaa_addr [ 0 ] , aaa -> aaa_size [ 0 ] ) ; sc -> sc_memt = aaa -> aaa_bst [ 0 ] ; if ( bus_space_map ( sc -> sc_memt , aaa -> aaa_addr [ 0 ] , aaa -> aaa_size [ 0 ] , 0 , & sc -> sc_memh ) ) { printf ( ": can't map registers\n" ) ; return ; } aml_find_node ( sc -> sc_node , "_HID" , dwgpio_found_hid , sc ) ; if ( sc -> sc_npins == 0 ) { printf ( ": no pins\n" ) ; return ; } if ( sc -> sc_npins >= GPIO_NUM_PINS ) { printf ( ": too many pins\n" ) ; return ; } sc -> sc_pin_ih = mallocarray ( sc -> sc_npins , sizeof ( * sc -> sc_pin_ih ) , M_DEVBUF , M_WAITOK | M_ZERO ) ; printf ( " irq" ) ; sc -> sc_nirq = aaa -> aaa_nirq ; sc -> sc_ih = mallocarray ( sc -> sc_nirq , sizeof ( * sc -> sc_ih ) , M_DEVBUF , M_WAITOK | M_ZERO ) ; for ( i = 0 ; i < sc -> sc_nirq ; i ++ ) { printf ( " %d" , aaa -> aaa_irq [ i ] ) ; sc -> sc_ih [ i ] = acpi_intr_establish ( aaa -> aaa_irq [ i ] , aaa -> aaa_irq_flags [ i ] , IPL_BIO , dwgpio_intr , sc , sc -> sc_dev . dv_xname ) ; } sc -> sc_gpio . cookie = sc ; sc -> sc_gpio . read_pin = dwgpio_read_pin ; sc -> sc_gpio . write_pin = dwgpio_write_pin ; sc -> sc_gpio . intr_establish = dwgpio_intr_establish ; sc -> sc_node -> gpio = & sc -> sc_gpio ; printf ( ", %d pins\n" , sc -> sc_npins ) ; acpi_register_gpio ( sc -> sc_acpi , sc -> sc_node ) ; return ; unmap for ( i = 0 ; i < sc -> sc_nirq ; i ++ ) { if ( sc -> sc_ih [ i ] ) { acpi_intr_disestablish ( sc -> sc_ih [ i ] ) ; } } free ( sc -> sc_ih , M_DEVBUF , sc -> sc_nirq * sizeof ( * sc -> sc_ih ) ) ; free ( sc -> sc_pin_ih , M_DEVBUF , sc -> sc_npins * sizeof ( * sc -> sc_pin_ih ) ) ; bus_space_unmap ( sc -> sc_memt , sc -> sc_memh , aaa -> aaa_size [ 0 ] ) ; } 