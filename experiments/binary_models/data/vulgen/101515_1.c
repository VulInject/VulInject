static int dissect_afs ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) { struct rxinfo * rxinfo = ( rxinfo * ) data ; int reply = 0 ; conversation_t * conversation ; struct afs_request_key request_key , * new_request_key ; struct afs_request_val * request_val = NULL ; proto_tree * afs_tree , * afs_op_tree , * ti ; proto_item * hidden_item ; int port , node , typenode , opcode ; value_string_ext * vals_ext ; int offset = 0 ; nstime_t delta_ts ; guint8 save_fragmented ; int reassembled = 0 ; ptvcursor_t * cursor ; void * dissector ( ptvcursor_t * cursor , struct rxinfo * rxinfo , int opcode ) if ( data == NULL ) { return 0 ; } col_set_str ( pinfo -> cinfo , COL_PROTOCOL , "AFS (RX)" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; reply = ( rxinfo -> flags & RX_CLIENT_INITIATED ) == 0 ; port = ( ( reply == 0 ) ?pinfo -> destport : pinfo -> srcport ) ; conversation = find_or_create_conversation ( pinfo ) ; request_key . conversation = conversation -> conv_index ; request_key . service = rxinfo -> serviceid ; request_key . epoch = rxinfo -> epoch ; request_key . cid = rxinfo -> cid ; request_key . callnumber = rxinfo -> callnumber ; request_val = ( afs_request_val * ) wmem_map_lookup ( afs_request_hash , & request_key ) ; opcode = 0 ; if ( ! pinfo -> fd -> visited ) { if ( ! request_val && ! reply ) { new_request_key = wmem_new ( wmem_file_scope ( ) , afs_request_key ) ; * new_request_key = request_key ; request_val = wmem_new ( wmem_file_scope ( ) , afs_request_val ) ; request_val -> opcode = tvb_get_ntohl ( tvb , offset ) ; request_val -> req_num = pinfo -> num ; request_val -> rep_num = 0 ; request_val -> req_time = pinfo -> abs_ts ; wmem_map_insert ( afs_request_hash , new_request_key , request_val ) ; } if ( request_val && reply ) { request_val -> rep_num = pinfo -> num ; } } if ( request_val ) { opcode = request_val -> opcode ; } node = 0 ; typenode = 0 ; vals_ext = NULL ; dissector = NULL ; switch ( port ) { case AFS_PORT_FS : typenode = hf_afs_fs ; node = hf_afs_fs_opcode ; vals_ext = & fs_req_ext ; dissector = reply ?dissect_fs_reply : dissect_fs_request ; break ; case AFS_PORT_CB : typenode = hf_afs_cb ; node = hf_afs_cb_opcode ; vals_ext = & cb_req_ext ; dissector = reply ?dissect_cb_reply : dissect_cb_request ; break ; case AFS_PORT_PROT : typenode = hf_afs_prot ; node = hf_afs_prot_opcode ; vals_ext = & prot_req_ext ; dissector = reply ?dissect_prot_reply : dissect_prot_request ; break ; case AFS_PORT_VLDB : typenode = hf_afs_vldb ; node = hf_afs_vldb_opcode ; vals_ext = & vldb_req_ext ; dissector = reply ?dissect_vldb_reply : dissect_vldb_request ; break ; case AFS_PORT_KAUTH : typenode = hf_afs_kauth ; node = hf_afs_kauth_opcode ; vals_ext = & kauth_req_ext ; dissector = reply ?dissect_kauth_reply : dissect_kauth_request ; break ; case AFS_PORT_VOL : typenode = hf_afs_vol ; node = hf_afs_vol_opcode ; vals_ext = & vol_req_ext ; dissector = reply ?dissect_vol_reply : dissect_vol_request ; break ; case AFS_PORT_ERROR : typenode = hf_afs_error ; node = hf_afs_error_opcode ; break ; case AFS_PORT_BOS : typenode = hf_afs_bos ; node = hf_afs_bos_opcode ; vals_ext = & bos_req_ext ; dissector = reply ?dissect_bos_reply : dissect_bos_request ; break ; case AFS_PORT_UPDATE : typenode = hf_afs_update ; node = hf_afs_update_opcode ; vals_ext = & update_req_ext ; break ; case AFS_PORT_RMTSYS : typenode = hf_afs_rmtsys ; node = hf_afs_rmtsys_opcode ; vals_ext = & rmtsys_req_ext ; break ; case AFS_PORT_BACKUP : typenode = hf_afs_backup ; node = hf_afs_backup_opcode ; vals_ext = & backup_req_ext ; dissector = reply ?dissect_backup_reply : dissect_backup_request ; break ; default : if ( port >= AFS_PORT_BUTC ) { typenode = hf_afs_butc ; node = hf_afs_butc_opcode ; vals_ext = & butc_req_ext ; dissector = reply ?dissect_butc_reply : dissect_butc_request ; } break ; } if ( ( opcode >= VOTE_LOW && opcode <= VOTE_HIGH ) || ( opcode >= DISK_LOW && opcode <= DISK_HIGH ) ) { typenode = hf_afs_ubik ; node = hf_afs_ubik_opcode ; vals_ext = & ubik_req_ext ; dissector = reply ?dissect_ubik_reply : dissect_ubik_request ; } if ( VALID_OPCODE ( opcode ) ) { if ( vals_ext ) { col_add_fstr ( pinfo -> cinfo , COL_INFO , "%s%s %s: %s (%d)" , typenode == hf_afs_ubik ?"UBIK-" : "" , val_to_str_ext ( port , & port_types_short_ext , "Unknown(%d)" ) , reply ?"Reply" : "Request" , val_to_str_ext ( opcode , vals_ext , "Unknown(%d)" ) , opcode ) ; } else { col_add_fstr ( pinfo -> cinfo , COL_INFO , "%s%s %s: Unknown(%d)" , typenode == hf_afs_ubik ?"UBIK-" : "" , val_to_str_ext ( port , & port_types_short_ext , "Unknown(%d)" ) , reply ?"Reply" : "Request" , opcode ) ; } } else { col_add_fstr ( pinfo -> cinfo , COL_INFO , "Encrypted %s %s" , val_to_str_ext ( port , & port_types_short_ext , "Unknown(%d)" ) , reply ?"Reply" : "Request" ) ; } ti = proto_tree_add_item ( tree , proto_afs , tvb , offset , tvb_reported_length_remaining ( tvb , offset ) , ENC_NA ) ; afs_tree = proto_item_add_subtree ( ti , ett_afs ) ; save_fragmented = pinfo -> fragmented ; if ( ( afs_defragment && ( ! ( rxinfo -> flags & RX_LAST_PACKET ) || rxinfo -> seq > 1 ) ) ) { tvbuff_t * new_tvb = NULL ; fragment_head * frag_msg = NULL ; guint32 afs_seqid = rxinfo -> callnumber ^ rxinfo -> cid ; pinfo -> fragmented = TRUE ; frag_msg = fragment_add_seq_check ( & afs_reassembly_table , tvb , offset , pinfo , afs_seqid , NULL , rxinfo -> seq - 1 , tvb_captured_length_remaining ( tvb , offset ) , ! ( rxinfo -> flags & RX_LAST_PACKET ) ) ; new_tvb = process_reassembled_data ( tvb , offset , pinfo , "Reassembled RX" , frag_msg , & afs_frag_items , NULL , afs_tree ) ; if ( new_tvb ) { tvb = new_tvb ; reassembled = 1 ; col_append_str ( pinfo -> cinfo , COL_INFO , " [AFS reassembled]" ) ; } else { col_set_str ( pinfo -> cinfo , COL_INFO , "[AFS segment of a reassembled PDU]" ) ; return tvb_captured_length ( tvb ) ; } } pinfo -> fragmented = save_fragmented ; if ( tree ) { proto_tree_add_uint_format_value ( afs_tree , hf_afs_service , tvb , 0 , 0 , opcode , "%s%s%s %s" , VALID_OPCODE ( opcode ) ?"" : "Encrypted " , typenode == hf_afs_ubik ?"UBIK - " : "" , val_to_str_ext ( port , & port_types_ext , "Unknown(%d)" ) , reply ?"Reply" : "Request" ) ; if ( request_val && ! reply && request_val -> rep_num ) { proto_tree_add_uint_format ( afs_tree , hf_afs_repframe , tvb , 0 , 0 , request_val -> rep_num , "The reply to this request is in frame %u" , request_val -> rep_num ) ; } if ( request_val && reply && request_val -> rep_num ) { proto_tree_add_uint_format ( afs_tree , hf_afs_reqframe , tvb , 0 , 0 , request_val -> req_num , "This is a reply to a request in frame %u" , request_val -> req_num ) ; nstime_delta ( & delta_ts , & pinfo -> abs_ts , & request_val -> req_time ) ; proto_tree_add_time ( afs_tree , hf_afs_time , tvb , offset , 0 , & delta_ts ) ; } if ( VALID_OPCODE ( opcode ) ) { ti = NULL ; if ( ! reply && node != 0 ) { if ( rxinfo -> seq == 1 || reassembled ) { ti = proto_tree_add_uint ( afs_tree , node , tvb , offset , 4 , opcode ) ; } else { ti = proto_tree_add_uint ( afs_tree , node , tvb , 0 , 0 , opcode ) ; } afs_op_tree = proto_item_add_subtree ( ti , ett_afs_op ) ; } if ( reply && node != 0 ) { ti = proto_tree_add_uint ( afs_tree , node , tvb , 0 , 0 , opcode ) ; afs_op_tree = proto_item_add_subtree ( ti , ett_afs_op ) ; } else { afs_op_tree = proto_tree_add_subtree ( afs_tree , tvb , 0 , 0 , ett_afs_op , & ti , "Operation: Unknown" ) ; } if ( dissector && ( rxinfo -> seq == 1 || reassembled ) ) { cursor = ptvcursor_new ( pinfo -> pool , afs_op_tree , tvb , offset ) ; * dissector ( cursor , rxinfo , opcode ) ; } } } if ( rxinfo -> flags & RX_LAST_PACKET && reply ) { } return tvb_captured_length ( tvb ) ; } 