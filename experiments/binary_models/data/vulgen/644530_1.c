static int method_import_tar_or_raw ( sd_bus_message * msg , void * userdata , sd_bus_error * error ) { _cleanup_ ( ) Transfer * t = NULL ; int fd , force , read_only , r ; const char * local , * object ; Manager * m = ASSERT_PTR ( userdata ) ; TransferType type ; struct stat st ; uint32_t id ; assert ( msg ) ; if ( r < 0 ) { return r ; } if ( r == 0 ) { return 1 ; } r = sd_bus_message_read ( msg , "hsbb" , & fd , & local , & force , & read_only ) ; if ( r < 0 ) { return r ; } if ( fstat ( fd , & st ) < 0 ) { return - errno ; } if ( ! S_ISREG ( st . st_mode ) && ! S_ISFIFO ( st . st_mode ) ) { return - EINVAL ; } if ( ! hostname_is_valid ( local , 0 ) ) { return sd_bus_error_setf ( error , SD_BUS_ERROR_INVALID_ARGS , "Local name %s is invalid" , local ) ; } r = setup_machine_directory ( error , m -> use_btrfs_subvol , m -> use_btrfs_quota ) ; if ( r < 0 ) { return r ; } type = streq_ptr ( sd_bus_message_get_member ( msg ) , "ImportTar" ) ?TRANSFER_IMPORT_TAR : TRANSFER_IMPORT_RAW ; r = transfer_new ( m , & t ) ; if ( r < 0 ) { return r ; } t -> type = type ; t -> force_local = force ; t -> read_only = read_only ; t -> local = strdup ( local ) ; if ( ! t -> local ) { return - ENOMEM ; } t -> stdin_fd = fcntl ( fd , F_DUPFD_CLOEXEC , 3 ) ; if ( t -> stdin_fd < 0 ) { return - errno ; } r = transfer_start ( t ) ; if ( r < 0 ) { return r ; } object = t -> object_path ; id = t -> id ; t = NULL ; return sd_bus_reply_method_return ( msg , "uo" , id , object ) ; } 