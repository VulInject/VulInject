static int cdump_sym ( mrb_state * mrb , mrb_sym sym , const char * var_name , int idx , mrb_value init_syms_code , FILE * fp ) { if ( sym == 0 ) { fputs ( "0," , fp ) ; return MRB_DUMP_OK ; } mrb_int len ; const char * name = mrb_sym_name_len ( mrb , sym , & len ) , * op_name ; if ( sym_name_word_p ( name , len ) ) { fprintf ( fp , "MRB_SYM(%s)" , name ) ; } if ( sym_name_with_equal_p ( name , len ) ) { fprintf ( fp , "MRB_SYM_E(%.*s)" , ( int ) ( len - 1 ) , name ) ; } if ( sym_name_with_question_mark_p ( name , len ) ) { fprintf ( fp , "MRB_SYM_Q(%.*s)" , ( int ) ( len - 1 ) , name ) ; } if ( sym_name_with_bang_p ( name , len ) ) { fprintf ( fp , "MRB_SYM_B(%.*s)" , ( int ) ( len - 1 ) , name ) ; } if ( sym_name_ivar_p ( name , len ) ) { fprintf ( fp , "MRB_IVSYM(%s)" , name + 1 ) ; } if ( sym_name_cvar_p ( name , len ) ) { fprintf ( fp , "MRB_CVSYM(%s)" , name + 2 ) ; } if ( ( op_name = sym_operator_name ( name , len ) ) ) { fprintf ( fp , "MRB_OPSYM(%s)" , op_name ) ; } else { char buf [ 32 ] ; mrb_value name_obj = mrb_str_new ( mrb , name , len ) ; mrb_str_cat_lit ( mrb , init_syms_code , "  " ) ; mrb_str_cat_cstr ( mrb , init_syms_code , var_name ) ; snprintf ( buf , sizeof ( buf ) , "[%d] = " , idx ) ; mrb_str_cat_cstr ( mrb , init_syms_code , buf ) ; mrb_str_cat_lit ( mrb , init_syms_code , "mrb_intern_lit(mrb, " ) ; mrb_str_cat_str ( mrb , init_syms_code , mrb_str_dump ( mrb , name_obj ) ) ; mrb_str_cat_lit ( mrb , init_syms_code , ");\n" ) ; fputs ( "0" , fp ) ; } fputs ( ", " , fp ) ; return MRB_DUMP_OK ; } 