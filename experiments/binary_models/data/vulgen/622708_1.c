int evalExtractShebangFlags ( sds body , uint64_t * out_flags , ssize_t * out_shebang_len , sds * err ) { ssize_t shebang_len = 0 ; uint64_t script_flags = SCRIPT_FLAG_EVAL_COMPAT_MODE ; if ( ! strncmp ( body , "#!" , 2 ) ) { int numparts , j ; char * shebang_end = strchr ( body , '\n' ) ; if ( shebang_end == NULL ) { if ( err ) { * err = sdsnew ( "Invalid script shebang" ) ; } return C_ERR ; } shebang_len = shebang_end - body ; sds shebang = sdsnewlen ( body , shebang_len ) ; sds * parts = sdssplitargs ( shebang , & numparts ) ; if ( ! parts || numparts == 0 ) { if ( err ) { * err = sdsnew ( "Invalid engine in script shebang" ) ; } sdsfreesplitres ( parts , numparts ) ; return C_ERR ; } if ( strcmp ( parts [ 0 ] , "#!lua" ) ) { if ( err ) { * err = sdscatfmt ( sdsempty ( ) , "Unexpected engine in script shebang: %s" , parts [ 0 ] ) ; } sdsfreesplitres ( parts , numparts ) ; return C_ERR ; } script_flags &= ~ SCRIPT_FLAG_EVAL_COMPAT_MODE ; for ( j = 1 ; j < numparts ; j ++ ) { if ( ! strncmp ( parts [ j ] , "flags=" , 6 ) ) { sdsrange ( parts [ j ] , 6 , - 1 ) ; int numflags , jj ; sds * flags = sdssplitlen ( parts [ j ] , sdslen ( parts [ j ] ) , "," , 1 , & numflags ) ; for ( jj = 0 ; jj < numflags ; jj ++ ) { scriptFlag * sf ; for ( sf = scripts_flags_def ; sf -> flag ; sf ++ ) { if ( ! strcmp ( flags [ jj ] , sf -> str ) ) { break ; } } if ( ! sf -> flag ) { if ( err ) { * err = sdscatfmt ( sdsempty ( ) , "Unexpected flag in script shebang: %s" , flags [ jj ] ) ; } sdsfreesplitres ( flags , numflags ) ; sdsfreesplitres ( parts , numparts ) ; return C_ERR ; } script_flags |= sf -> flag ; } sdsfreesplitres ( flags , numflags ) ; } else { if ( err ) { * err = sdscatfmt ( sdsempty ( ) , "Unknown lua shebang option: %s" , parts [ j ] ) ; } sdsfreesplitres ( parts , numparts ) ; return C_ERR ; } } sdsfreesplitres ( parts , numparts ) ; } if ( out_shebang_len ) { * out_shebang_len = shebang_len ; } * out_flags = script_flags ; return C_OK ; } 