int curl_parse_param ( char * val ) { str name = STR_NULL ; str schema = STR_NULL ; str url = STR_NULL ; str username = STR_NULL ; str password = STR_NULL ; str params = STR_NULL ; str failover = STR_NULL ; str client_cert = default_tls_clientcert ; str client_key = default_tls_clientkey ; str ciphersuites = default_cipher_suite_list ; str useragent = default_useragent ; str http_proxy = default_http_proxy ; unsigned int http_proxy_port = default_http_proxy_port ; unsigned int maxdatasize = default_maxdatasize ; unsigned int timeout = default_connection_timeout ; unsigned int http_follow_redirect = default_http_follow_redirect ; unsigned int verify_peer = default_tls_verify_peer ; unsigned int verify_host = default_tls_verify_host ; unsigned int tlsversion = default_tls_version ; unsigned int authmethod = default_authmethod ; unsigned int keep_connections = default_keep_connections ; str in ; char * p ; char * u ; param_t * conparams = NULL ; curl_con_t * cc = NULL ; LM_DBG ( "modparam httpcon: %s\n" , val ) ; LM_DBG ( " *** Default httproxy: %s\n" , http_proxy . s ) ; if ( ! shm_initialized ( ) ) { LM_ERR ( "shared memory was not initialized\n" ) ; return - 1 ; } in . s = val ; in . len = strlen ( in . s ) ; p = in . s ; while ( p < in . s + in . len && ( * p == ' ' || * p == '\t' || * p == '\n' || * p == '\r' ) ) { p ++ ; } if ( p > in . s + in . len || * p == '\0' ) { error } name . s = p ; while ( p < in . s + in . len ) { if ( * p == '=' || * p == ' ' || * p == '\t' || * p == '\n' || * p == '\r' ) { break ; } p ++ ; } if ( p > in . s + in . len || * p == '\0' ) { error } name . len = p - name . s ; if ( * p != '=' ) { while ( p < in . s + in . len && ( * p == ' ' || * p == '\t' || * p == '\n' || * p == '\r' ) ) { p ++ ; } if ( p > in . s + in . len || * p == '\0' || * p != '=' ) { error } } p ++ ; if ( * p != '>' ) { error } p ++ ; while ( p < in . s + in . len && ( * p == ' ' || * p == '\t' || * p == '\n' || * p == '\r' ) ) { p ++ ; } schema . s = p ; while ( p < in . s + in . len ) { if ( * p == ':' ) { break ; } p ++ ; } if ( * p != ':' ) { error } schema . len = p - schema . s ; p ++ ; if ( * p != '/' ) { error } p ++ ; if ( * p != '/' ) { error } p ++ ; url . s = p ; url . len = in . len + ( int ) ( in . s - p ) ; u = p ; while ( p < in . s + in . len ) { if ( * p == '@' ) { break ; } p ++ ; } if ( * p == '@' ) { username . s = u ; while ( u < p ) { if ( * u == ':' ) { break ; } u ++ ; } username . len = u - username . s ; if ( * u == ':' ) { u ++ ; password . s = u ; while ( u < p ) { u ++ ; } password . len = u - password . s ; } p ++ ; url . s = p ; url . len = in . len + ( int ) ( in . s - p ) ; } p = url . s ; while ( p < url . s + url . len ) { if ( * p == ';' ) { url . len = ( int ) ( p - url . s ) ; break ; } p ++ ; } if ( * p == ';' ) { str tok ; param_t * pit = NULL ; p ++ ; params . s = p ; params . len = in . len + ( int ) ( in . s - p ) ; param_hooks_t phooks ; if ( parse_params ( & params , CLASS_ANY , & phooks , & conparams ) < 0 ) { LM_ERR ( "CURL failed parsing httpcon parameters value\n" ) ; error } for ( pit = conparams ; pit ; pit = pit -> next ) { tok = pit -> body ; if ( pit -> name . len == 12 && strncmp ( pit -> name . s , "httpredirect" , 12 ) == 0 ) { if ( str2int ( & tok , & http_follow_redirect ) != 0 ) { LM_WARN ( "curl connection [%.*s]: httpredirect bad value. " "Using default\n" , name . len , name . s ) ; http_follow_redirect = default_http_follow_redirect ; } if ( http_follow_redirect != 0 && http_follow_redirect != 1 ) { LM_WARN ( "curl connection [%.*s]: httpredirect bad value. " "Using default\n" , name . len , name . s ) ; http_follow_redirect = default_http_follow_redirect ; } LM_DBG ( "curl [%.*s] - httpredirect [%d]\n" , pit -> name . len , pit -> name . s , http_follow_redirect ) ; } if ( pit -> name . len == 7 && strncmp ( pit -> name . s , "timeout" , 7 ) == 0 ) { if ( str2int ( & tok , & timeout ) != 0 ) { LM_WARN ( "curl connection [%.*s]: timeout bad value. Using " "default\n" , name . len , name . s ) ; timeout = default_connection_timeout ; } LM_DBG ( "curl [%.*s] - timeout [%d]\n" , pit -> name . len , pit -> name . s , timeout ) ; } if ( pit -> name . len == 9 && strncmp ( pit -> name . s , "useragent" , 9 ) == 0 ) { useragent = tok ; LM_DBG ( "curl [%.*s] - useragent [%.*s]\n" , pit -> name . len , pit -> name . s , useragent . len , useragent . s ) ; } if ( pit -> name . len == 8 && strncmp ( pit -> name . s , "failover" , 8 ) == 0 ) { failover = tok ; LM_DBG ( "curl [%.*s] - failover [%.*s]\n" , pit -> name . len , pit -> name . s , failover . len , failover . s ) ; } if ( pit -> name . len == 11 && strncmp ( pit -> name . s , "maxdatasize" , 11 ) == 0 ) { if ( str2int ( & tok , & maxdatasize ) != 0 ) { LM_WARN ( "curl connection [%.*s]: maxdatasize bad value. " "Using default\n" , name . len , name . s ) ; maxdatasize = default_maxdatasize ; } LM_DBG ( "curl [%.*s] - maxdatasize [%d]\n" , pit -> name . len , pit -> name . s , maxdatasize ) ; } if ( pit -> name . len == 11 && strncmp ( pit -> name . s , "verify_peer" , 11 ) == 0 ) { if ( str2int ( & tok , & verify_peer ) != 0 ) { LM_WARN ( "curl connection [%.*s]: verify_peer bad value. " "Using default\n" , name . len , name . s ) ; verify_peer = default_tls_verify_peer ; } if ( verify_peer != 0 && verify_peer != 1 ) { LM_WARN ( "curl connection [%.*s]: verify_peer bad value. " "Using default\n" , name . len , name . s ) ; verify_peer = default_tls_verify_peer ; } LM_DBG ( "curl [%.*s] - verify_peer [%d]\n" , pit -> name . len , pit -> name . s , verify_peer ) ; } if ( pit -> name . len == 11 && strncmp ( pit -> name . s , "verify_host" , 11 ) == 0 ) { if ( str2int ( & tok , & verify_host ) != 0 ) { LM_WARN ( "curl connection [%.*s]: verify_host bad value. " "Using default\n" , name . len , name . s ) ; verify_host = default_tls_verify_host ; } LM_DBG ( "curl [%.*s] - verify_host [%d]\n" , pit -> name . len , pit -> name . s , verify_host ) ; } if ( pit -> name . len == 10 && strncmp ( pit -> name . s , "tlsversion" , 10 ) == 0 ) { if ( str2int ( & tok , & tlsversion ) != 0 ) { LM_WARN ( "curl connection [%.*s]: tlsversion bad value. " "Using default\n" , name . len , name . s ) ; tlsversion = default_tls_version ; } if ( tlsversion >= CURL_SSLVERSION_LAST ) { LM_WARN ( "curl connection [%.*s]: tlsversion unsupported " "value. Using default\n" , name . len , name . s ) ; tlsversion = default_tls_version ; } LM_DBG ( "curl [%.*s] - tlsversion [%d]\n" , pit -> name . len , pit -> name . s , tlsversion ) ; } if ( pit -> name . len == 11 && strncmp ( pit -> name . s , "client_cert" , 11 ) == 0 ) { client_cert = tok ; LM_DBG ( "curl [%.*s] - client_cert [%.*s]\n" , pit -> name . len , pit -> name . s , client_cert . len , client_cert . s ) ; } if ( pit -> name . len == 10 && strncmp ( pit -> name . s , "client_key" , 10 ) == 0 ) { client_key = tok ; LM_DBG ( "curl [%.*s] - client_key [%.*s]\n" , pit -> name . len , pit -> name . s , client_key . len , client_key . s ) ; } if ( pit -> name . len == 13 && strncmp ( pit -> name . s , "cipher_suites" , 13 ) == 0 ) { ciphersuites = tok ; LM_DBG ( "curl [%.*s] - cipher_suites [%.*s]\n" , pit -> name . len , pit -> name . s , ciphersuites . len , ciphersuites . s ) ; } else { LM_ERR ( "curl Unknown parameter [%.*s] \n" , pit -> name . len , pit -> name . s ) ; } } } if ( conparams != NULL ) { free_params ( conparams ) ; } cc = curl_init_con ( & name ) ; if ( cc == NULL ) { return - 1 ; } cc -> username = username . s ?as_asciiz ( & username ) : NULL ; cc -> password = password . s ?as_asciiz ( & password ) : NULL ; cc -> schema = schema ; cc -> authmethod = authmethod ; cc -> keep_connections = keep_connections ; cc -> failover = failover ; cc -> useragent = as_asciiz ( & useragent ) ; cc -> url = url ; cc -> clientcert = client_cert . s ?as_asciiz ( & client_cert ) : NULL ; cc -> clientkey = client_key . s ?as_asciiz ( & client_key ) : NULL ; cc -> ciphersuites = ciphersuites . s ?as_asciiz ( & ciphersuites ) : NULL ; cc -> tlsversion = tlsversion ; cc -> verify_peer = verify_peer ; cc -> verify_host = verify_host ; cc -> timeout = timeout ; cc -> maxdatasize = maxdatasize ; if ( http_proxy_port > 0 ) { cc -> http_proxy_port = http_proxy_port ; cc -> http_proxy = http_proxy . s ?as_asciiz ( & http_proxy ) : NULL ; LM_DBG ( "*** Setting HTTP proxy for connection to %s \n" , cc -> http_proxy ) ; } cc -> http_follow_redirect = http_follow_redirect ; LM_DBG ( "cname: [%.*s] url: [%.*s]username [%s] password [%s]failover " "[%.*s] timeout [%d]useragent [%s] maxdatasize [%d]" "keep_connections [%d]\n" , cc -> name . len , cc -> name . s , cc -> url . len , cc -> url . s , cc -> username ?cc -> username : "" , cc -> password ?cc -> password : "" , cc -> failover . len , cc -> failover . s , cc -> timeout , cc -> useragent , cc -> maxdatasize , cc -> keep_connections ) ; LM_DBG ( "cname: [%.*s] client_cert [%s]client_key [%s] ciphersuites [%s]" "tlsversion [%d] verify_peer [%d]verify_host [%d] authmethod " "[%d]\n" , cc -> name . len , cc -> name . s , cc -> clientcert , cc -> clientkey , cc -> ciphersuites , cc -> tlsversion , cc -> verify_peer , cc -> verify_host , cc -> authmethod ) ; if ( cc -> http_proxy_port > 0 ) { LM_DBG ( "cname: [%.*s] http_proxy [%s]http_proxy_port [%d]\n" , cc -> name . len , cc -> name . s , cc -> http_proxy , cc -> http_proxy_port ) ; } return 0 ; error LM_ERR ( "invalid curl parameter [%.*s] at [%d]\n" , in . len , in . s , ( int ) ( p - in . s ) ) ; return - 1 ; } 