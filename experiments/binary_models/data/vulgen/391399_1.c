static struct ip6_flowlabel * fl_create ( struct net * net , struct sock * sk , struct in6_flowlabel_req * freq , char __user * optval , int optlen , int * err_p ) { struct ip6_flowlabel * fl = NULL ; int olen ; int addr_type ; int err ; olen = optlen - CMSG_ALIGN ( sizeof ( * freq ) ) ; err = - EINVAL ; if ( olen > 64 * 1024 ) { done } err = - ENOMEM ; fl = kzalloc ( sizeof ( * fl ) , GFP_KERNEL ) ; if ( ! fl ) { done } if ( olen > 0 ) { struct msghdr msg ; struct flowi6 flowi6 ; struct sockcm_cookie sockc_junk ; struct ipcm6_cookie ipc6 ; err = - ENOMEM ; fl -> opt = kmalloc ( sizeof ( * fl -> opt ) + olen , GFP_KERNEL ) ; if ( ! fl -> opt ) { done } fl -> opt -> tot_len = sizeof ( * fl -> opt ) + olen ; err = - EFAULT ; if ( copy_from_user ( fl -> opt + 1 , optval + CMSG_ALIGN ( sizeof ( * freq ) ) , olen ) ) { done } msg . msg_controllen = olen ; msg . msg_control = ( void * ) ( fl -> opt + 1 ) ; memset ( & flowi6 , 0 , sizeof ( flowi6 ) ) ; ipc6 . opt = fl -> opt ; err = ip6_datagram_send_ctl ( net , sk , & msg , & flowi6 , & ipc6 , & sockc_junk ) ; if ( err ) { done } err = - EINVAL ; if ( fl -> opt -> opt_flen ) { done } if ( fl -> opt -> opt_nflen == 0 ) { kfree ( fl -> opt ) ; fl -> opt = NULL ; } } fl -> fl_net = net ; fl -> expires = jiffies ; err = fl6_renew ( fl , freq -> flr_linger , freq -> flr_expires ) ; if ( err ) { done } fl -> share = freq -> flr_share ; addr_type = ipv6_addr_type ( & freq -> flr_dst ) ; if ( ( addr_type & IPV6_ADDR_MAPPED ) || addr_type == IPV6_ADDR_ANY ) { err = - EINVAL ; done } fl -> dst = freq -> flr_dst ; atomic_set ( & fl -> users , 1 ) ; switch ( fl -> share ) { case IPV6_FL_S_EXCL : case IPV6_FL_S_ANY : break ; case IPV6_FL_S_PROCESS : fl -> owner . pid = get_task_pid ( current , PIDTYPE_PID ) ; break ; case IPV6_FL_S_USER : fl -> owner . uid = current_euid ( ) ; break ; default : err = - EINVAL ; done } return fl ; done fl_free ( fl ) ; * err_p = err ; return NULL ; } 