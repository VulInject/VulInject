static ssize_t bm_register_write ( struct file * file , const char __user * buffer , size_t count , loff_t * ppos ) { Node * e ; struct inode * inode ; struct super_block * sb = file_inode ( file ) -> i_sb ; struct dentry * root = sb -> s_root , * dentry ; int err = 0 ; e = create_entry ( buffer , count ) ; if ( IS_ERR ( e ) ) { return PTR_ERR ( e ) ; } inode_lock ( d_inode ( root ) ) ; dentry = lookup_one_len ( e -> name , root , strlen ( e -> name ) ) ; err = PTR_ERR ( dentry ) ; if ( IS_ERR ( dentry ) ) { out } err = - EEXIST ; if ( d_really_is_positive ( dentry ) ) { out2 } inode = bm_get_inode ( sb , S_IFREG | 0644 ) ; err = - ENOMEM ; if ( ! inode ) { out2 } err = simple_pin_fs ( & bm_fs_type , & bm_mnt , & entry_count ) ; if ( err ) { iput ( inode ) ; inode = NULL ; out2 } if ( e -> flags & MISC_FMT_OPEN_FILE ) { struct file * f ; f = open_exec ( e -> interpreter ) ; if ( IS_ERR ( f ) ) { err = PTR_ERR ( f ) ; pr_notice ( "register: failed to install interpreter file %s\n" , e -> interpreter ) ; simple_release_fs ( & bm_mnt , & entry_count ) ; iput ( inode ) ; inode = NULL ; out2 } e -> interp_file = f ; } e -> dentry = dget ( dentry ) ; inode -> i_private = e ; inode -> i_fop = & bm_entry_operations ; d_instantiate ( dentry , inode ) ; write_lock ( & entries_lock ) ; list_add ( & e -> list , & entries ) ; write_unlock ( & entries_lock ) ; err = 0 ; out2 out inode_unlock ( d_inode ( root ) ) ; if ( err ) { kfree ( e ) ; return err ; } return count ; } 