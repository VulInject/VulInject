static int lofi_get_info ( dev_t dev , struct lofi_ioctl * ulip , int which , struct cred * credp , int ioctl_flag ) { struct lofi_ioctl * klip ; struct lofi_state * lsp ; int error ; error = copy_in_lofi_ioctl ( ulip , & klip , ioctl_flag ) ; if ( error != 0 ) { return ( error ) ; } switch ( which ) { case LOFI_GET_FILENAME : if ( klip -> li_id == 0 ) { return ( EINVAL ) ; } mutex_enter ( & lofi_lock ) ; lsp = ddi_get_soft_state ( lofi_statep , klip -> li_id ) ; if ( lsp == NULL || lofi_access ( lsp ) != 0 ) { mutex_exit ( & lofi_lock ) ; free_lofi_ioctl ( klip ) ; return ( ENXIO ) ; } if ( lsp -> ls_stacked_vp == NULL || vnodetopath ( NULL , lsp -> ls_stacked_vp , klip -> li_filename , sizeof ( klip -> li_filename ) , CRED ( ) ) != 0 ) { ( void ) strlcpy ( klip -> li_filename , "?" , sizeof ( klip -> li_filename ) ) ; } klip -> li_readonly = lsp -> ls_readonly ; klip -> li_labeled = lsp -> ls_cmlbhandle != NULL ; ( void ) strlcpy ( klip -> li_algorithm , lsp -> ls_comp_algorithm , sizeof ( klip -> li_algorithm ) ) ; klip -> li_crypto_enabled = lsp -> ls_crypto_enabled ; mutex_exit ( & lofi_lock ) ; lofi_copy_devpath ( klip ) ; error = copy_out_lofi_ioctl ( klip , ulip , ioctl_flag ) ; free_lofi_ioctl ( klip ) ; return ( error ) ; case LOFI_GET_MINOR : mutex_enter ( & lofi_lock ) ; error = file_to_lofi ( klip -> li_filename , klip -> li_readonly , & lsp ) ; if ( error != 0 ) { mutex_exit ( & lofi_lock ) ; free_lofi_ioctl ( klip ) ; return ( error ) ; } klip -> li_id = LOFI_MINOR2ID ( getminor ( lsp -> ls_dev ) ) ; klip -> li_readonly = lsp -> ls_readonly ; klip -> li_labeled = lsp -> ls_cmlbhandle != NULL ; mutex_exit ( & lofi_lock ) ; lofi_copy_devpath ( klip ) ; error = copy_out_lofi_ioctl ( klip , ulip , ioctl_flag ) ; free_lofi_ioctl ( klip ) ; return ( error ) ; case LOFI_CHECK_COMPRESSED : mutex_enter ( & lofi_lock ) ; error = file_to_lofi ( klip -> li_filename , klip -> li_readonly , & lsp ) ; if ( error != 0 ) { mutex_exit ( & lofi_lock ) ; free_lofi_ioctl ( klip ) ; return ( error ) ; } klip -> li_id = LOFI_MINOR2ID ( getminor ( lsp -> ls_dev ) ) ; ( void ) strlcpy ( klip -> li_algorithm , lsp -> ls_comp_algorithm , sizeof ( klip -> li_algorithm ) ) ; mutex_exit ( & lofi_lock ) ; error = copy_out_lofi_ioctl ( klip , ulip , ioctl_flag ) ; free_lofi_ioctl ( klip ) ; return ( error ) ; default : free_lofi_ioctl ( klip ) ; return ( EINVAL ) ; } } 