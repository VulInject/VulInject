static void test_close_all_fds_inner ( void ) { _cleanup_free_ int * fds = NULL , * keep = NULL ; size_t n_fds , n_keep ; int max_fd ; log_info ( "" , __func__ ) ; rlimit_nofile_bump ( - 1 ) ; max_fd = get_max_fd ( ) ; assert_se ( max_fd > 10 ) ; if ( max_fd > 7000 ) { ( void ) setrlimit_closest ( RLIMIT_NOFILE , & ( rlimit ) { 7000 7000 } ) ; max_fd = 7000 ; } n_fds = MIN ( ( ( size_t ) max_fd & ~ 1U ) - 10U , 5000U ) ; assert_se ( ( n_fds & 1U ) == 0U ) ; assert_se ( fds = new ( int , n_fds ) ) ; for ( size_t i = 0 ; i < n_fds ; i += 2 ) { assert_se ( pipe2 ( fds + i , O_CLOEXEC ) >= 0 ) ; } assert_se ( validate_fds ( true , fds , n_fds ) == n_fds ) ; n_keep = ( random_u64 ( ) % ( n_fds / 2 ) ) ; assert_se ( keep = new ( int , n_keep ) ) ; for ( size_t k = 0 ; k < n_keep ; k ++ ) { for ( ; ; ) { size_t p ; p = random_u64 ( ) % n_fds ; if ( fds [ p ] >= 0 ) { keep [ k ] = TAKE_FD ( fds [ p ] ) ; break ; } } } assert_se ( validate_fds ( true , fds , n_fds ) == n_fds - n_keep ) ; assert_se ( validate_fds ( true , keep , n_keep ) == n_keep ) ; log_close ( ) ; log_set_open_when_needed ( true ) ; assert_se ( validate_fds ( false , fds , n_fds ) == n_fds - n_keep ) ; assert_se ( validate_fds ( true , keep , n_keep ) == n_keep ) ; assert_se ( close_all_fds ( NULL , 0 ) >= 0 ) ; assert_se ( validate_fds ( false , fds , n_fds ) == n_fds - n_keep ) ; assert_se ( validate_fds ( false , keep , n_keep ) == n_keep ) ; log_set_open_when_needed ( false ) ; log_open ( ) ; } 