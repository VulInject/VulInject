int c_type ( void ) { struct disk_type * type , * tptr , * oldtype ; u_ioparam_t ioparam ; int i , index , deflt , * defltptr = NULL ; struct disk_type disk_type ; struct disk_type * d = & disk_type ; int first_disk ; int auto_conf_choice ; int other_choice ; struct dk_label label ; struct efi_info efi_info ; uint64_t maxLBA ; char volname [ LEN_DKL_VVOL ] ; int volinit = 0 ; if ( cur_disk == NULL ) { err_print ( "Current Disk is not set.\n" ) ; return ( - 1 ) ; } oldtype = cur_disk -> disk_type ; type = cur_ctype -> ctype_dlist ; fmt_print ( "\n\nAVAILABLE DRIVE TYPES:\n" ) ; first_disk = 0 ; if ( cur_ctype -> ctype_ctype == DKC_SCSI_CCS ) { auto_conf_choice = 0 ; fmt_print ( "        %d. Auto configure\n" , first_disk ++ ) ; } else { auto_conf_choice = - 1 ; } i = first_disk ; for ( tptr = type ; tptr != NULL ; tptr = tptr -> dtype_next ) { if ( cur_dtype == tptr ) { deflt = i ; defltptr = & deflt ; } if ( tptr -> dtype_asciilabel ) { fmt_print ( "        %d. %s\n" , i ++ , tptr -> dtype_asciilabel ) ; } } other_choice = i ; fmt_print ( "        %d. other\n" , i ) ; ioparam . io_bounds . lower = 0 ; ioparam . io_bounds . upper = i ; index = input ( FIO_INT , "Specify disk type (enter its number)" , ':' , & ioparam , defltptr , DATA_INPUT ) ; if ( index == auto_conf_choice ) { float scaled ; diskaddr_t nblks ; int nparts ; ( void ) strcpy ( x86_devname , cur_disk -> disk_name ) ; switch ( cur_disk -> label_type ) { case L_TYPE_SOLARIS : if ( ( tptr = auto_sense ( cur_file , 1 , & label ) ) == NULL ) { err_print ( "Auto configure failed\n" ) ; return ( - 1 ) ; } fmt_print ( "%s: configured with capacity of " , cur_disk -> disk_name ) ; nblks = ( diskaddr_t ) tptr -> dtype_ncyl * tptr -> dtype_nhead * tptr -> dtype_nsect ; scaled = bn2mb ( nblks ) ; if ( scaled > 1024.0 ) { fmt_print ( "%1.2fGB\n" , scaled / 1024.0 ) ; } else { fmt_print ( "%1.2fMB\n" , scaled ) ; } fmt_print ( "<%s cyl %d alt %d hd %d sec %d>\n" , tptr -> dtype_asciilabel , tptr -> dtype_ncyl , tptr -> dtype_acyl , tptr -> dtype_nhead , tptr -> dtype_nsect ) ; break ; case L_TYPE_EFI : if ( ( tptr = auto_efi_sense ( cur_file , & efi_info ) ) == NULL ) { err_print ( "Auto configure failed\n" ) ; return ( - 1 ) ; } fmt_print ( "%s: configured with capacity of " , cur_disk -> disk_name ) ; scaled = bn2mb ( efi_info . capacity ) ; if ( scaled > 1024.0 ) { fmt_print ( "%1.2fGB\n" , scaled / 1024.0 ) ; } else { fmt_print ( "%1.2fMB\n" , scaled ) ; } cur_blksz = efi_info . e_parts -> efi_lbasize ; print_efi_string ( efi_info . vendor , efi_info . product , efi_info . revision , efi_info . capacity ) ; fmt_print ( "\n" ) ; for ( nparts = 0 ; nparts < cur_parts -> etoc -> efi_nparts ; nparts ++ ) { if ( cur_parts -> etoc -> efi_parts [ nparts ] . p_tag == V_RESERVED ) { if ( cur_parts -> etoc -> efi_parts [ nparts ] . p_name ) { ( void ) strcpy ( volname , cur_parts -> etoc -> efi_parts [ nparts ] . p_name ) ; volinit = 1 ; } break ; } } enter_critical ( ) ; if ( delete_disk_type ( cur_disk -> disk_type ) != 0 ) { fmt_print ( "Autoconfiguration failed.\n" ) ; return ( - 1 ) ; } cur_disk -> disk_type = tptr ; cur_disk -> disk_parts = tptr -> dtype_plist ; init_globals ( cur_disk ) ; exit_critical ( ) ; if ( volinit ) { for ( nparts = 0 ; nparts < cur_parts -> etoc -> efi_nparts ; nparts ++ ) { if ( cur_parts -> etoc -> efi_parts [ nparts ] . p_tag == V_RESERVED ) { ( void ) strcpy ( cur_parts -> etoc -> efi_parts [ nparts ] . p_name , volname ) ; ( void ) strlcpy ( cur_disk -> v_volume , volname , LEN_DKL_VVOL ) ; break ; } } } return ( 0 ) ; default : return ( - 1 ) ; } } if ( ( index == other_choice ) && ( cur_label == L_TYPE_SOLARIS ) ) { bzero ( ( char * ) d , sizeof ( disk_type ) ) ; d -> dtype_ncyl = get_ncyl ( ) ; d -> dtype_acyl = get_acyl ( d -> dtype_ncyl ) ; d -> dtype_pcyl = get_pcyl ( d -> dtype_ncyl , d -> dtype_acyl ) ; d -> dtype_nhead = get_nhead ( ) ; d -> dtype_phead = get_phead ( d -> dtype_nhead , & d -> dtype_options ) ; d -> dtype_nsect = get_nsect ( ) ; d -> dtype_psect = get_psect ( & d -> dtype_options ) ; d -> dtype_bpt = get_bpt ( d -> dtype_nsect , & d -> dtype_options ) ; d -> dtype_rpm = get_rpm ( ) ; d -> dtype_fmt_time = get_fmt_time ( & d -> dtype_options ) ; d -> dtype_cyl_skew = get_cyl_skew ( & d -> dtype_options ) ; d -> dtype_trk_skew = get_trk_skew ( & d -> dtype_options ) ; d -> dtype_trks_zone = get_trks_zone ( & d -> dtype_options ) ; d -> dtype_atrks = get_atrks ( & d -> dtype_options ) ; d -> dtype_asect = get_asect ( & d -> dtype_options ) ; d -> dtype_cache = get_cache ( & d -> dtype_options ) ; d -> dtype_threshold = get_threshold ( & d -> dtype_options ) ; d -> dtype_prefetch_min = get_min_prefetch ( & d -> dtype_options ) ; d -> dtype_prefetch_max = get_max_prefetch ( d -> dtype_prefetch_min , & d -> dtype_options ) ; d -> dtype_bps = get_bps ( ) ; d -> dtype_dr_type = 0 ; d -> dtype_asciilabel = get_asciilabel ( ) ; enter_critical ( ) ; tptr = ( disk_type * ) zalloc ( sizeof ( disk_type ) ) ; if ( type == NULL ) { cur_ctype -> ctype_dlist = tptr ; } else { while ( type -> dtype_next != NULL ) { type = type -> dtype_next ; } type -> dtype_next = tptr ; } bcopy ( ( char * ) d , ( char * ) tptr , sizeof ( disk_type ) ) ; tptr -> dtype_next = NULL ; new_partitiontable ( tptr , oldtype ) ; } if ( ( index == other_choice ) && ( cur_label == L_TYPE_EFI ) ) { uint64_t start_lba = cur_parts -> etoc -> efi_first_u_lba ; uint64_t reserved ; reserved = efi_reserved_sectors ( cur_parts -> etoc ) ; maxLBA = get_mlba ( ) ; cur_parts -> etoc -> efi_last_lba = maxLBA ; cur_parts -> etoc -> efi_last_u_lba = maxLBA - start_lba ; for ( i = 0 ; i < cur_parts -> etoc -> efi_nparts ; i ++ ) { cur_parts -> etoc -> efi_parts [ i ] . p_start = 0 ; cur_parts -> etoc -> efi_parts [ i ] . p_size = 0 ; cur_parts -> etoc -> efi_parts [ i ] . p_tag = V_UNASSIGNED ; } cur_parts -> etoc -> efi_parts [ 8 ] . p_start = maxLBA - start_lba - reserved ; cur_parts -> etoc -> efi_parts [ 8 ] . p_size = reserved ; cur_parts -> etoc -> efi_parts [ 8 ] . p_tag = V_RESERVED ; if ( write_label ( ) ) { err_print ( "Write label failed\n" ) ; } else { cur_disk -> disk_flags &= ~ DSK_LABEL_DIRTY ; } return ( 0 ) ; } else { i = first_disk ; tptr = type ; while ( i < index ) { if ( tptr -> dtype_asciilabel ) { i ++ ; } tptr = tptr -> dtype_next ; } if ( ( tptr -> dtype_asciilabel == NULL ) && ( tptr -> dtype_next != NULL ) ) { while ( tptr -> dtype_asciilabel == NULL ) { tptr = tptr -> dtype_next ; } } } if ( ( tptr != oldtype ) && checkmount ( ( diskaddr_t ) - 1 , ( diskaddr_t ) - 1 ) ) { err_print ( "Cannot set disk type while it has mounted " "partitions.\n\n" ) ; return ( - 1 ) ; } if ( ( tptr != oldtype ) && checkswap ( ( diskaddr_t ) - 1 , ( diskaddr_t ) - 1 ) ) { err_print ( "Cannot set disk type while its partition are " "currently being used for swapping.\n" ) ; return ( - 1 ) ; } if ( ( tptr != oldtype ) && checkdevinuse ( cur_disk -> disk_name , ( diskaddr_t ) - 1 , ( diskaddr_t ) - 1 , 0 , 0 ) ) { err_print ( "Cannot set disk type while its " "partitions are currently in use.\n" ) ; return ( - 1 ) ; } enter_critical ( ) ; if ( tptr != oldtype ) { cur_disk -> disk_type = tptr ; cur_disk -> disk_parts = NULL ; cur_disk -> disk_flags &= ~ DSK_LABEL ; } init_globals ( cur_disk ) ; ( void ) get_partition ( ) ; exit_critical ( ) ; if ( cur_disk -> disk_flags & DSK_LABEL_DIRTY ) { if ( check ( "Disk not labeled.  Label it now" ) == 0 ) { if ( write_label ( ) ) { err_print ( "Write label failed\n" ) ; } else { cur_disk -> disk_flags &= ~ DSK_LABEL_DIRTY ; } } } return ( 0 ) ; } 