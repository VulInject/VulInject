void * nodeRead ( const char * token , int tok_len ) { Node * result ; NodeTag type ; if ( token == NULL ) { token = pg_strtok ( & tok_len ) ; } type = nodeTokenType ( token , tok_len ) ; switch ( ( int ) type ) { case LEFT_BRACE : result = parseNodeString ( ) ; token = pg_strtok ( & tok_len ) ; if ( token == NULL || token [ 0 ] != '}' ) { elog ( ERROR , "did not find '}' at end of input node" ) ; } break ; case LEFT_PAREN : { List * l = NIL ; token = pg_strtok ( & tok_len ) ; if ( token == NULL ) { elog ( ERROR , "unterminated List structure" ) ; } if ( tok_len == 1 && token [ 0 ] == 'i' ) { for ( ; ; ) { int val ; char * endptr ; token = pg_strtok ( & tok_len ) ; if ( token == NULL ) { elog ( ERROR , "unterminated List structure" ) ; } if ( token [ 0 ] == ')' ) { break ; } val = ( int ) strtol ( token , & endptr , 10 ) ; if ( endptr != token + tok_len ) { elog ( ERROR , "unrecognized integer: \"%.*s\"" , tok_len , token ) ; } l = lappend_int ( l , val ) ; } result = ( Node * ) l ; } if ( tok_len == 1 && token [ 0 ] == 'o' ) { for ( ; ; ) { Oid val ; char * endptr ; token = pg_strtok ( & tok_len ) ; if ( token == NULL ) { elog ( ERROR , "unterminated List structure" ) ; } if ( token [ 0 ] == ')' ) { break ; } val = ( Oid ) strtoul ( token , & endptr , 10 ) ; if ( endptr != token + tok_len ) { elog ( ERROR , "unrecognized OID: \"%.*s\"" , tok_len , token ) ; } l = lappend_oid ( l , val ) ; } result = ( Node * ) l ; } if ( tok_len == 1 && token [ 0 ] == 'x' ) { for ( ; ; ) { TransactionId val ; char * endptr ; token = pg_strtok ( & tok_len ) ; if ( token == NULL ) { elog ( ERROR , "unterminated List structure" ) ; } if ( token [ 0 ] == ')' ) { break ; } val = ( TransactionId ) strtoul ( token , & endptr , 10 ) ; if ( endptr != token + tok_len ) { elog ( ERROR , "unrecognized Xid: \"%.*s\"" , tok_len , token ) ; } l = lappend_xid ( l , val ) ; } result = ( Node * ) l ; } if ( tok_len == 1 && token [ 0 ] == 'b' ) { Bitmapset * bms = NULL ; for ( ; ; ) { int val ; char * endptr ; token = pg_strtok ( & tok_len ) ; if ( token == NULL ) { elog ( ERROR , "unterminated Bitmapset structure" ) ; } if ( tok_len == 1 && token [ 0 ] == ')' ) { break ; } val = ( int ) strtol ( token , & endptr , 10 ) ; if ( endptr != token + tok_len ) { elog ( ERROR , "unrecognized integer: \"%.*s\"" , tok_len , token ) ; } bms = bms_add_member ( bms , val ) ; } result = ( Node * ) bms ; } else { for ( ; ; ) { if ( token [ 0 ] == ')' ) { break ; } l = lappend ( l , nodeRead ( token , tok_len ) ) ; token = pg_strtok ( & tok_len ) ; if ( token == NULL ) { elog ( ERROR , "unterminated List structure" ) ; } } result = ( Node * ) l ; } break ; } case RIGHT_PAREN : elog ( ERROR , "unexpected right parenthesis" ) ; result = NULL ; break ; case OTHER_TOKEN : if ( tok_len == 0 ) { result = NULL ; } else { elog ( ERROR , "unrecognized token: \"%.*s\"" , tok_len , token ) ; result = NULL ; } break ; case T_Integer : result = ( Node * ) makeInteger ( atoi ( token ) ) ; break ; case T_Float : { char * fval = ( char * ) palloc ( tok_len + 1 ) ; memcpy ( fval , token , tok_len ) ; fval [ tok_len ] = '\0' ; result = ( Node * ) makeFloat ( fval ) ; } break ; case T_Boolean : result = ( Node * ) makeBoolean ( token [ 0 ] == 't' ) ; break ; case T_String : result = ( Node * ) makeString ( debackslash ( token + 1 , tok_len - 2 ) ) ; break ; case T_BitString : { char * val = palloc ( tok_len + 1 ) ; memcpy ( val , token , tok_len ) ; val [ tok_len ] = '\0' ; result = ( Node * ) makeBitString ( val ) ; break ; } default : elog ( ERROR , "unrecognized node type: %d" , ( int ) type ) ; result = NULL ; break ; } return ( void * ) result ; } 