static ssize_t sel_write_load ( struct file * file , const char __user * buf , size_t count , loff_t * ppos ) { ssize_t length ; void * data = NULL ; mutex_lock ( & sel_mutex ) ; length = avc_has_perm ( current_sid ( ) , SECINITSID_SECURITY , SECCLASS_SECURITY , SECURITY__LOAD_POLICY , NULL ) ; length = - EINVAL ; if ( * ppos != 0 ) { out } length = - EFBIG ; if ( count > 64 * 1024 * 1024 ) { out } length = - ENOMEM ; data = vmalloc ( count ) ; if ( ! data ) { out } length = - EFAULT ; if ( copy_from_user ( data , buf , count ) != 0 ) { out } length = security_load_policy ( data , count ) ; if ( length ) { pr_warn_ratelimited ( "SELinux: failed to load policy\n" ) ; out } length = sel_make_bools ( ) ; if ( length ) { pr_err ( "SELinux: failed to load policy booleans\n" ) ; out1 } length = sel_make_classes ( ) ; if ( length ) { pr_err ( "SELinux: failed to load policy classes\n" ) ; out1 } length = sel_make_policycap ( ) ; if ( length ) { pr_err ( "SELinux: failed to load policy capabilities\n" ) ; out1 } length = count ; out1 audit_log ( current -> audit_context , GFP_KERNEL , AUDIT_MAC_POLICY_LOAD , "policy loaded auid=%u ses=%u" , from_kuid ( & init_user_ns , audit_get_loginuid ( current ) ) , audit_get_sessionid ( current ) ) ; out mutex_unlock ( & sel_mutex ) ; vfree ( data ) ; return length ; } 