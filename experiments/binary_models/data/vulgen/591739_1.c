static struct geneve_sock * geneve_socket_create ( struct net * net , __be16 port , bool ipv6 , bool ipv6_rx_csum ) { struct geneve_net * gn = net_generic ( net , geneve_net_id ) ; struct geneve_sock * gs ; struct socket * sock ; struct udp_tunnel_sock_cfg tunnel_cfg ; int h ; gs = kzalloc ( sizeof ( * gs ) , GFP_KERNEL ) ; if ( ! gs ) { return ERR_PTR ( - ENOMEM ) ; } sock = geneve_create_sock ( net , ipv6 , port , ipv6_rx_csum ) ; if ( IS_ERR ( sock ) ) { kfree ( gs ) ; return ERR_CAST ( sock ) ; } gs -> sock = sock ; gs -> refcnt = 1 ; for ( h = 0 ; h < VNI_HASH_SIZE ; ++ h ) { INIT_HLIST_HEAD ( & gs -> vni_list [ h ] ) ; } udp_tunnel_notify_add_rx_port ( gs -> sock , UDP_TUNNEL_TYPE_GENEVE ) ; tunnel_cfg . sk_user_data = gs ; tunnel_cfg . encap_type = 1 ; tunnel_cfg . gro_receive = geneve_gro_receive ; tunnel_cfg . gro_complete = geneve_gro_complete ; tunnel_cfg . encap_rcv = geneve_udp_encap_recv ; tunnel_cfg . encap_err_lookup = geneve_udp_encap_err_lookup ; tunnel_cfg . encap_destroy = NULL ; setup_udp_tunnel_sock ( net , sock , & tunnel_cfg ) ; list_add ( & gs -> list , & gn -> sock_list ) ; return gs ; } 