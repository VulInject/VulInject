_bfd_compute_and_write_armap ( , ) { char * first_name = NULL ; bfd * current ; file_ptr elt_no = 0 ; struct orl * map = NULL ; unsigned int orl_max = 1024 ; unsigned int orl_count = 0 ; int stridx = 0 ; asymbol * * syms = NULL ; long syms_max = 0 ; bfd_boolean ret ; bfd_size_type amt ; if ( elength != 0 ) { elength += sizeof ( ar_hdr ) ; } elength += elength % 2 ; amt = orl_max * sizeof ( orl ) ; map = bfd_malloc ( amt ) ; if ( map == NULL ) { error_return } first_name = bfd_alloc ( arch , 1 ) ; if ( first_name == NULL ) { error_return } while ( arch -> archive_head && strcmp ( arch -> archive_head -> filename , "__.SYMDEF" ) == 0 ) { arch -> archive_head = arch -> archive_head -> next ; } for ( current = arch -> archive_head ; current != NULL ; current = current -> next , elt_no ++ ) { if ( bfd_check_format ( current , bfd_object ) && ( bfd_get_file_flags ( current ) & HAS_SYMS ) != 0 ) { long storage ; long symcount ; long src_count ; storage = bfd_get_symtab_upper_bound ( current ) ; if ( storage < 0 ) { error_return } if ( storage != 0 ) { if ( storage > syms_max ) { if ( syms_max > 0 ) { free ( syms ) ; } syms_max = storage ; syms = bfd_malloc ( syms_max ) ; if ( syms == NULL ) { error_return } } symcount = bfd_canonicalize_symtab ( current , syms ) ; if ( symcount < 0 ) { error_return } for ( src_count = 0 ; src_count < symcount ; src_count ++ ) { flagword flags = ( syms [ src_count ] ) -> flags ; asection * sec = syms [ src_count ] -> section ; if ( ( flags & BSF_GLOBAL || flags & BSF_WEAK || flags & BSF_INDIRECT || bfd_is_com_section ( sec ) ) && ! bfd_is_und_section ( sec ) ) { bfd_size_type namelen ; struct orl * new_map ; if ( orl_count == orl_max ) { orl_max *= 2 ; amt = orl_max * sizeof ( orl ) ; new_map = bfd_realloc ( map , amt ) ; if ( new_map == NULL ) { error_return } map = new_map ; } namelen = strlen ( syms [ src_count ] -> name ) ; amt = sizeof ( char * ) ; map [ orl_count ] . name = bfd_alloc ( arch , amt ) ; if ( map [ orl_count ] . name == NULL ) { error_return } * ( map [ orl_count ] . name ) = bfd_alloc ( arch , namelen + 1 ) ; if ( * ( map [ orl_count ] . name ) == NULL ) { error_return } strcpy ( * ( map [ orl_count ] . name ) , syms [ src_count ] -> name ) ; map [ orl_count ] . u . abfd = current ; map [ orl_count ] . namidx = stridx ; stridx += namelen + 1 ; ++ orl_count ; } } } if ( ! bfd_free_cached_info ( current ) ) { error_return } } } ret = BFD_SEND ( arch , write_armap , ( arch , elength , map , orl_count , stridx ) ) ; if ( syms_max > 0 ) { free ( syms ) ; } if ( map != NULL ) { free ( map ) ; } if ( first_name != NULL ) { bfd_release ( arch , first_name ) ; } return ret ; error_return if ( syms_max > 0 ) { free ( syms ) ; } if ( map != NULL ) { free ( map ) ; } return FALSE ; } 