R_API bool r_debug_reg_sync ( RDebug * dbg , int type , int must_write ) { r_return_val_if_fail ( dbg && dbg -> reg && dbg -> h , false ) ; int i , n , size ; if ( r_debug_is_dead ( dbg ) ) { return false ; } if ( must_write && ! dbg -> h -> reg_write ) { return false ; } if ( ! must_write && ! dbg -> h -> reg_read ) { return false ; } i = ( type == R_REG_TYPE_ALL ) ?R_REG_TYPE_GPR : type ; if ( i >= R_REG_TYPE_GPR && dbg -> reg -> regset [ i ] . regs && ! dbg -> reg -> regset [ i ] . regs -> length ) { for ( n = R_REG_TYPE_GPR ; n < R_REG_TYPE_LAST ; n ++ ) { int mask = dbg -> reg -> regset [ n ] . maskregstype ; int v = ( ( int ) 1 << i ) ; if ( n != i && ( mask & v ) ) { i = n ; break ; } } } { if ( must_write ) { ut8 * buf = r_reg_get_bytes ( dbg -> reg , i , & size ) ; if ( ! buf || ! dbg -> h -> reg_write ( dbg , i , buf , size ) ) { if ( i == R_REG_TYPE_GPR ) { R_LOG_ERROR ( "cannot write registers %d to %d" , i , dbg -> tid ) ; } if ( type != R_REG_TYPE_ALL || i == R_REG_TYPE_GPR ) { free ( buf ) ; return false ; } } free ( buf ) ; } else { int bufsize = dbg -> reg -> size ; if ( bufsize > 0 ) { ut8 * buf = calloc ( 2 , bufsize ) ; if ( ! buf ) { return false ; } size = dbg -> h -> reg_read ( dbg , i , buf , bufsize ) ; if ( dbg -> h -> reg_read ( dbg , i , buf , bufsize ) ) { r_reg_set_bytes ( dbg -> reg , i , buf , bufsize ) ; } free ( buf ) ; } } i ++ ; } ( type == R_REG_TYPE_ALL ) && ( i < R_REG_TYPE_LAST ) ; return true ; } 