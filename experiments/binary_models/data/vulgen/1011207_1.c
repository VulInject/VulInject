static void carl9170_tx_release ( struct kref * ref ) { struct ar9170 * ar ; struct carl9170_tx_info * arinfo ; struct ieee80211_tx_info * txinfo ; struct sk_buff * skb ; arinfo = container_of ( ref , carl9170_tx_info , ref ) ; txinfo = container_of ( ( void * ) arinfo , ieee80211_tx_info , rate_driver_data ) ; skb = container_of ( ( void * ) txinfo , sk_buff , cb ) ; ar = arinfo -> ar ; if ( WARN_ON_ONCE ( ! ar ) ) { return ; } BUILD_BUG_ON ( offsetof ( ieee80211_tx_info , status . ack_signal ) != 20 ) ; memset ( & txinfo -> status . ack_signal , 0 , sizeof ( ieee80211_tx_info ) - offsetof ( ieee80211_tx_info , status . ack_signal ) ) ; if ( atomic_read ( & ar -> tx_total_queued ) ) { ar -> tx_schedule = true ; } if ( txinfo -> flags & IEEE80211_TX_CTL_AMPDU ) { if ( ! atomic_read ( & ar -> tx_ampdu_upload ) ) { ar -> tx_ampdu_schedule = true ; } if ( txinfo -> flags & IEEE80211_TX_STAT_AMPDU ) { struct _carl9170_tx_superframe * super ; super = ( void * ) skb -> data ; txinfo -> status . ampdu_len = super -> s . rix ; txinfo -> status . ampdu_ack_len = super -> s . cnt ; } if ( ( txinfo -> flags & IEEE80211_TX_STAT_ACK ) && ! ( txinfo -> flags & IEEE80211_TX_CTL_REQ_TX_STATUS ) ) { return ; } else { } } skb_pull ( skb , sizeof ( _carl9170_tx_superframe ) ) ; ieee80211_tx_status_irqsafe ( ar -> hw , skb ) ; } 