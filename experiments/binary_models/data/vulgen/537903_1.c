void sepgsql_compute_avd ( const char * scontext , const char * tcontext , uint16 tclass , struct av_decision * avd ) { const char * tclass_name ; security_class_t tclass_ex ; struct av_decision avd_ex ; int i , deny_unknown = security_deny_unknown ( ) ; Assert ( tclass < SEPG_CLASS_MAX ) ; Assert ( tclass == selinux_catalog [ tclass ] . class_code ) ; tclass_name = selinux_catalog [ tclass ] . class_name ; tclass_ex = string_to_security_class ( tclass_name ) ; if ( tclass_ex == 0 ) { avd -> allowed = ( security_deny_unknown ( ) > 0 ?0 : ~ 0 ) ; avd -> auditallow = 0U ; avd -> auditdeny = ~ 0U ; avd -> flags = 0 ; return ; } if ( security_compute_av_flags_raw ( scontext , tcontext , tclass_ex , 0 , & avd_ex ) < 0 ) { ereport ( ERROR , ( errcode ( ERRCODE_INTERNAL_ERROR ) , errmsg ( "SELinux could not compute av_decision: " "scontext=%s tcontext=%s tclass=%s: %m" , scontext , tcontext , tclass_name ) ) ) ; } memset ( avd , 0 , sizeof ( av_decision ) ) ; for ( i = 0 ; selinux_catalog [ tclass ] . av [ i ] . av_name ; i ++ ) { access_vector_t av_code_ex ; const char * av_name = selinux_catalog [ tclass ] . av [ i ] . av_name ; uint32 av_code = selinux_catalog [ tclass ] . av [ i ] . av_code ; av_code_ex = string_to_av_perm ( tclass_ex , av_name ) ; if ( av_code_ex == 0 ) { if ( ! deny_unknown ) { avd -> allowed |= av_code ; } avd -> auditdeny |= av_code ; continue ; } if ( avd_ex . allowed & av_code_ex ) { avd -> allowed |= av_code ; } if ( avd_ex . auditallow & av_code_ex ) { avd -> auditallow |= av_code ; } } } 