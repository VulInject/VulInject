static krb5_error_code krb5_auth_context_internalize ( krb5_context kcontext , krb5_pointer * argp , krb5_octet * * buffer , size_t * lenremain ) { krb5_error_code kret ; krb5_auth_context auth_context ; krb5_int32 ibuf ; krb5_octet * bp ; size_t remain ; krb5_int32 ivlen ; krb5_int32 tag ; bp = * buffer ; remain = * lenremain ; kret = EINVAL ; if ( krb5_ser_unpack_int32 ( & ibuf , & bp , & remain ) ) { ibuf = 0 ; } if ( ibuf == KV5M_AUTH_CONTEXT ) { kret = ENOMEM ; if ( ( remain >= ( 5 * sizeof ( krb5_int32 ) ) ) && ( auth_context = ( krb5_auth_context ) MALLOC ( sizeof ( _krb5_auth_context ) ) ) ) { ( void ) memset ( auth_context , 0 , sizeof ( _krb5_auth_context ) ) ; ( void ) krb5_ser_unpack_int32 ( & ibuf , & bp , & remain ) ; auth_context -> auth_context_flags = ibuf ; ( void ) krb5_ser_unpack_int32 ( & ibuf , & bp , & remain ) ; auth_context -> remote_seq_number = ibuf ; ( void ) krb5_ser_unpack_int32 ( & ibuf , & bp , & remain ) ; auth_context -> local_seq_number = ibuf ; ( void ) krb5_ser_unpack_int32 ( & ibuf , & bp , & remain ) ; auth_context -> req_cksumtype = ( krb5_cksumtype ) ibuf ; ( void ) krb5_ser_unpack_int32 ( & ibuf , & bp , & remain ) ; auth_context -> safe_cksumtype = ( krb5_cksumtype ) ibuf ; ( void ) krb5_ser_unpack_int32 ( & ivlen , & bp , & remain ) ; if ( ivlen ) { if ( ( auth_context -> i_vector = ( krb5_pointer ) MALLOC ( ( size_t ) ivlen ) ) ) { kret = krb5_ser_unpack_bytes ( auth_context -> i_vector , ( size_t ) ivlen , & bp , & remain ) ; } else { kret = ENOMEM ; } } else { kret = 0 ; } tag = 0 ; if ( ! kret ) { kret = krb5_ser_unpack_int32 ( & tag , & bp , & remain ) ; } if ( ! kret && ( tag == TOKEN_RADDR ) ) { if ( ! ( kret = krb5_internalize_opaque ( kcontext , KV5M_ADDRESS , ( krb5_pointer * ) & auth_context -> remote_addr , & bp , & remain ) ) ) { kret = krb5_ser_unpack_int32 ( & tag , & bp , & remain ) ; } } if ( ! kret && ( tag == TOKEN_RPORT ) ) { if ( ! ( kret = krb5_internalize_opaque ( kcontext , KV5M_ADDRESS , ( krb5_pointer * ) & auth_context -> remote_port , & bp , & remain ) ) ) { kret = krb5_ser_unpack_int32 ( & tag , & bp , & remain ) ; } } if ( ! kret && ( tag == TOKEN_LADDR ) ) { if ( ! ( kret = krb5_internalize_opaque ( kcontext , KV5M_ADDRESS , ( krb5_pointer * ) & auth_context -> local_addr , & bp , & remain ) ) ) { kret = krb5_ser_unpack_int32 ( & tag , & bp , & remain ) ; } } if ( ! kret && ( tag == TOKEN_LPORT ) ) { if ( ! ( kret = krb5_internalize_opaque ( kcontext , KV5M_ADDRESS , ( krb5_pointer * ) & auth_context -> local_port , & bp , & remain ) ) ) { kret = krb5_ser_unpack_int32 ( & tag , & bp , & remain ) ; } } if ( ! kret && ( tag == TOKEN_KEYBLOCK ) ) { if ( ! ( kret = krb5_internalize_opaque ( kcontext , KV5M_KEYBLOCK , ( krb5_pointer * ) & auth_context -> keyblock , & bp , & remain ) ) ) { kret = krb5_ser_unpack_int32 ( & tag , & bp , & remain ) ; } } if ( ! kret && ( tag == TOKEN_LSKBLOCK ) ) { if ( ! ( kret = krb5_internalize_opaque ( kcontext , KV5M_KEYBLOCK , ( krb5_pointer * ) & auth_context -> send_subkey , & bp , & remain ) ) ) { kret = krb5_ser_unpack_int32 ( & tag , & bp , & remain ) ; } } if ( ! kret ) { if ( tag == TOKEN_RSKBLOCK ) { kret = krb5_internalize_opaque ( kcontext , KV5M_KEYBLOCK , ( krb5_pointer * ) & auth_context -> recv_subkey , & bp , & remain ) ; } else { bp -= sizeof ( krb5_int32 ) ; remain += sizeof ( krb5_int32 ) ; } } if ( ! kret ) { if ( ( kret = krb5_internalize_opaque ( kcontext , KV5M_AUTHENTICATOR , ( krb5_pointer * ) & auth_context -> authentp , & bp , & remain ) ) ) { } } if ( ! kret ) { kret = krb5_ser_unpack_int32 ( & ibuf , & bp , & remain ) ; if ( ! kret && ( ibuf != KV5M_AUTH_CONTEXT ) ) { kret = EINVAL ; } } if ( ! kret ) { * buffer = bp ; * lenremain = remain ; auth_context -> magic = KV5M_AUTH_CONTEXT ; * argp = ( krb5_pointer ) auth_context ; } else { krb5_auth_con_free ( kcontext , auth_context ) ; } } } return ( kret ) ; } 