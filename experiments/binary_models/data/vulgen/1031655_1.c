static void do_create_aggr ( int argc , char * argv [ ] , const char * use ) { int option ; int key = 0 ; uint32_t policy = AGGR_POLICY_L4 ; aggr_lacp_mode_t lacp_mode = AGGR_LACP_OFF ; aggr_lacp_timer_t lacp_timer = AGGR_LACP_TIMER_SHORT ; dladm_aggr_port_attr_db_t port [ MAXPORT ] ; uint_t n , ndev , nlink ; uint8_t mac_addr [ ETHERADDRL ] ; boolean_t mac_addr_fixed = B_FALSE ; boolean_t P_arg = B_FALSE ; boolean_t l_arg = B_FALSE ; boolean_t u_arg = B_FALSE ; boolean_t T_arg = B_FALSE ; uint32_t flags = DLADM_OPT_ACTIVE | DLADM_OPT_PERSIST ; char * altroot = NULL ; char name [ MAXLINKNAMELEN ] ; char * devs [ MAXPORT ] ; char * links [ MAXPORT ] ; dladm_status_t status ; dladm_status_t pstatus ; char propstr [ DLADM_STRSIZE ] ; dladm_arg_list_t * proplist = NULL ; int i ; datalink_id_t linkid ; ndev = nlink = opterr = 0 ; bzero ( propstr , DLADM_STRSIZE ) ; while ( ( option = getopt_long ( argc , argv , ":d:l:L:P:R:tfu:T:p:" , lopts , NULL ) ) != - 1 ) { switch ( option ) { case 'd' : if ( ndev + nlink >= MAXPORT ) { die ( "too many ports specified" ) ; } devs [ ndev ++ ] = optarg ; break ; case 'P' : if ( P_arg ) { die_optdup ( option ) ; } P_arg = B_TRUE ; if ( ! dladm_aggr_str2policy ( optarg , & policy ) ) { die ( "invalid policy '%s'" , optarg ) ; } break ; case 'u' : if ( u_arg ) { die_optdup ( option ) ; } u_arg = B_TRUE ; if ( ! dladm_aggr_str2macaddr ( optarg , & mac_addr_fixed , mac_addr ) ) { die ( "invalid MAC address '%s'" , optarg ) ; } break ; case 'l' : if ( isdigit ( optarg [ strlen ( optarg ) - 1 ] ) ) { if ( ndev + nlink >= MAXPORT ) { die ( "too many ports specified" ) ; } links [ nlink ++ ] = optarg ; break ; } case 'L' : if ( l_arg ) { die_optdup ( option ) ; } l_arg = B_TRUE ; if ( ! dladm_aggr_str2lacpmode ( optarg , & lacp_mode ) ) { die ( "invalid LACP mode '%s'" , optarg ) ; } break ; case 'T' : if ( T_arg ) { die_optdup ( option ) ; } T_arg = B_TRUE ; if ( ! dladm_aggr_str2lacptimer ( optarg , & lacp_timer ) ) { die ( "invalid LACP timer value '%s'" , optarg ) ; } break ; case 't' : flags &= ~ DLADM_OPT_PERSIST ; break ; case 'f' : flags |= DLADM_OPT_FORCE ; break ; case 'R' : altroot = optarg ; break ; case 'p' : ( void ) strlcat ( propstr , optarg , DLADM_STRSIZE ) ; if ( strlcat ( propstr , "," , DLADM_STRSIZE ) >= DLADM_STRSIZE ) { die ( "property list too long '%s'" , propstr ) ; } break ; default : die_opterr ( optopt , option , use ) ; break ; } } if ( ndev + nlink == 0 ) { usage ( ) ; } if ( optind != ( argc - 1 ) ) { usage ( ) ; } if ( ! str2int ( argv [ optind ] , & key ) ) { if ( strlcpy ( name , argv [ optind ] , MAXLINKNAMELEN ) >= MAXLINKNAMELEN ) { die ( "link name too long '%s'" , argv [ optind ] ) ; } if ( ! dladm_valid_linkname ( name ) ) { die ( "invalid link name '%s'" , argv [ optind ] ) ; } } else { ( void ) snprintf ( name , MAXLINKNAMELEN , "aggr%d" , key ) ; } if ( altroot != NULL ) { altroot_cmd ( altroot , argc , argv ) ; } for ( n = 0 ; n < ndev ; n ++ ) { if ( ( status = dladm_dev2linkid ( handle , devs [ n ] , & port [ n ] . lp_linkid ) ) != DLADM_STATUS_OK ) { die_dlerr ( status , "invalid dev name '%s'" , devs [ n ] ) ; } } for ( n = 0 ; n < nlink ; n ++ ) { if ( ( status = dladm_name2info ( handle , links [ n ] , & port [ ndev + n ] . lp_linkid , NULL , NULL , NULL ) ) != DLADM_STATUS_OK ) { die_dlerr ( status , "invalid link name '%s'" , links [ n ] ) ; } } status = dladm_aggr_create ( handle , name , key , ndev + nlink , port , policy , mac_addr_fixed , ( const uchar_t * ) mac_addr , lacp_mode , lacp_timer , flags ) ; if ( status != DLADM_STATUS_OK ) { done } if ( dladm_parse_link_props ( propstr , & proplist , B_FALSE ) != DLADM_STATUS_OK ) { die ( "invalid aggregation property" ) ; } if ( proplist == NULL ) { return ; } status = dladm_name2info ( handle , name , & linkid , NULL , NULL , NULL ) ; if ( status != DLADM_STATUS_OK ) { done } for ( i = 0 ; i < proplist -> al_count ; i ++ ) { dladm_arg_info_t * aip = & proplist -> al_info [ i ] ; pstatus = dladm_set_linkprop ( handle , linkid , aip -> ai_name , aip -> ai_val , aip -> ai_count , flags ) ; if ( pstatus != DLADM_STATUS_OK ) { die_dlerr ( pstatus , "aggr creation succeeded but " "could not set property '%s'" , aip -> ai_name ) ; } } done dladm_free_props ( proplist ) ; } 