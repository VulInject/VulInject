s_mipsset ( ) { char * name = input_line_pointer , ch ; while ( ! is_end_of_line [ ( unsigned char ) * input_line_pointer ] ) { ++ input_line_pointer ; } ch = * input_line_pointer ; * input_line_pointer = '\0' ; if ( strcmp ( name , "reorder" ) == 0 ) { if ( mips_opts . noreorder && prev_nop_frag != NULL ) { prev_nop_frag -> fr_fix -= ( prev_nop_frag_holds * ( mips_opts . mips16 ?2 : 4 ) ) ; prev_nop_frag = NULL ; } mips_opts . noreorder = 0 ; } if ( strcmp ( name , "noreorder" ) == 0 ) { mips_opts . noreorder = 1 ; mips_any_noreorder = 1 ; } if ( strcmp ( name , "at" ) == 0 ) { mips_opts . noat = 0 ; } if ( strcmp ( name , "noat" ) == 0 ) { mips_opts . noat = 1 ; } if ( strcmp ( name , "macro" ) == 0 ) { mips_opts . warn_about_macros = 0 ; } if ( strcmp ( name , "nomacro" ) == 0 ) { if ( mips_opts . noreorder == 0 ) { as_bad ( _ ( "`noreorder' must be set before `nomacro'" ) ) ; } mips_opts . warn_about_macros = 1 ; } if ( strcmp ( name , "move" ) == 0 || strcmp ( name , "novolatile" ) == 0 ) { mips_opts . nomove = 0 ; } if ( strcmp ( name , "nomove" ) == 0 || strcmp ( name , "volatile" ) == 0 ) { mips_opts . nomove = 1 ; } if ( strcmp ( name , "bopt" ) == 0 ) { mips_opts . nobopt = 0 ; } if ( strcmp ( name , "nobopt" ) == 0 ) { mips_opts . nobopt = 1 ; } if ( strcmp ( name , "mips16" ) == 0 || strcmp ( name , "MIPS-16" ) == 0 ) { mips_opts . mips16 = 1 ; } if ( strcmp ( name , "nomips16" ) == 0 || strcmp ( name , "noMIPS-16" ) == 0 ) { mips_opts . mips16 = 0 ; } if ( strcmp ( name , "mips3d" ) == 0 ) { mips_opts . ase_mips3d = 1 ; } if ( strcmp ( name , "nomips3d" ) == 0 ) { mips_opts . ase_mips3d = 0 ; } if ( strcmp ( name , "mdmx" ) == 0 ) { mips_opts . ase_mdmx = 1 ; } if ( strcmp ( name , "nomdmx" ) == 0 ) { mips_opts . ase_mdmx = 0 ; } if ( strncmp ( name , "mips" , 4 ) == 0 || strncmp ( name , "arch=" , 5 ) == 0 ) { int reset = 0 ; if ( strcmp ( name , "mips0" ) == 0 ) { reset = 1 ; mips_opts . isa = file_mips_isa ; } if ( strcmp ( name , "mips1" ) == 0 ) { mips_opts . isa = ISA_MIPS1 ; } if ( strcmp ( name , "mips2" ) == 0 ) { mips_opts . isa = ISA_MIPS2 ; } if ( strcmp ( name , "mips3" ) == 0 ) { mips_opts . isa = ISA_MIPS3 ; } if ( strcmp ( name , "mips4" ) == 0 ) { mips_opts . isa = ISA_MIPS4 ; } if ( strcmp ( name , "mips5" ) == 0 ) { mips_opts . isa = ISA_MIPS5 ; } if ( strcmp ( name , "mips32" ) == 0 ) { mips_opts . isa = ISA_MIPS32 ; } if ( strcmp ( name , "mips32r2" ) == 0 ) { mips_opts . isa = ISA_MIPS32R2 ; } if ( strcmp ( name , "mips64" ) == 0 ) { mips_opts . isa = ISA_MIPS64 ; } if ( strcmp ( name , "mips64r2" ) == 0 ) { mips_opts . isa = ISA_MIPS64R2 ; } if ( strcmp ( name , "arch=default" ) == 0 ) { reset = 1 ; mips_opts . arch = file_mips_arch ; mips_opts . isa = file_mips_isa ; } if ( strncmp ( name , "arch=" , 5 ) == 0 ) { const struct mips_cpu_info * p ; p = mips_parse_cpu ( "internal use" , name + 5 ) ; if ( ! p ) { as_bad ( _ ( "unknown architecture %s" ) , name + 5 ) ; } else { mips_opts . arch = p -> cpu ; mips_opts . isa = p -> isa ; } } else { as_bad ( _ ( "unknown ISA level %s" ) , name + 4 ) ; } switch ( mips_opts . isa ) { case 0 : break ; case ISA_MIPS1 : case ISA_MIPS2 : case ISA_MIPS32 : case ISA_MIPS32R2 : mips_opts . gp32 = 1 ; mips_opts . fp32 = 1 ; break ; case ISA_MIPS3 : case ISA_MIPS4 : case ISA_MIPS5 : case ISA_MIPS64 : case ISA_MIPS64R2 : mips_opts . gp32 = 0 ; mips_opts . fp32 = 0 ; break ; default : as_bad ( _ ( "unknown ISA level %s" ) , name + 4 ) ; break ; } if ( reset ) { mips_opts . gp32 = file_mips_gp32 ; mips_opts . fp32 = file_mips_fp32 ; } } if ( strcmp ( name , "autoextend" ) == 0 ) { mips_opts . noautoextend = 0 ; } if ( strcmp ( name , "noautoextend" ) == 0 ) { mips_opts . noautoextend = 1 ; } if ( strcmp ( name , "push" ) == 0 ) { struct mips_option_stack * s ; s = ( mips_option_stack * ) xmalloc ( sizeof s ) ; s -> next = mips_opts_stack ; s -> options = mips_opts ; mips_opts_stack = s ; } if ( strcmp ( name , "pop" ) == 0 ) { struct mips_option_stack * s ; s = mips_opts_stack ; if ( s == NULL ) { as_bad ( _ ( ".set pop with no .set push" ) ) ; } else { if ( s -> options . noreorder && ! mips_opts . noreorder ) { mips_emit_delays ( TRUE ) ; } if ( ! s -> options . noreorder && mips_opts . noreorder ) { if ( prev_nop_frag != NULL ) { prev_nop_frag -> fr_fix -= ( prev_nop_frag_holds * ( mips_opts . mips16 ?2 : 4 ) ) ; prev_nop_frag = NULL ; } } mips_opts = s -> options ; mips_opts_stack = s -> next ; free ( s ) ; } } else { as_warn ( _ ( "Tried to set unrecognized symbol: %s\n" ) , name ) ; } * input_line_pointer = ch ; demand_empty_rest_of_line ( ) ; } 