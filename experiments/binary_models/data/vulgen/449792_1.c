void R_RenderSunShadowMaps ( const refdef_t * fd , int level ) { viewParms_t shadowParms ; vec4_t lightDir , lightCol ; vec3_t lightViewAxis [ 3 ] ; vec3_t lightOrigin ; float splitZNear , splitZFar , splitBias ; float viewZNear , viewZFar ; vec3_t lightviewBounds [ 2 ] ; if ( r_forceSun -> integer == 2 ) { int scale = 32768 ; float angle = ( fd -> time % scale ) / ( float ) scale * M_PI ; lightDir [ 0 ] = cos ( angle ) ; lightDir [ 1 ] = sin ( 35.0f * M_PI / 180.0f ) ; lightDir [ 2 ] = sin ( angle ) * cos ( 35.0f * M_PI / 180.0f ) ; lightDir [ 3 ] = 0.0f ; if ( 1 ) { lightCol [ 0 ] = lightCol [ 1 ] = lightCol [ 2 ] = CLAMP ( sin ( angle ) * 2.0f , 0.0f , 1.0f ) * 2.0f ; lightCol [ 3 ] = 1.0f ; } else { lightCol [ 0 ] = lightCol [ 1 ] = lightCol [ 2 ] = CLAMP ( sin ( angle ) * 2.0f * 0.1f , 0.0f , 0.1f ) ; lightCol [ 3 ] = 1.0f ; } VectorCopy4 ( lightDir , tr . refdef . sunDir ) ; VectorCopy4 ( lightCol , tr . refdef . sunCol ) ; VectorScale4 ( lightCol , 0.2f , tr . refdef . sunAmbCol ) ; } else { VectorCopy4 ( tr . refdef . sunDir , lightDir ) ; } viewZNear = r_shadowCascadeZNear -> value ; viewZFar = r_shadowCascadeZFar -> value ; splitBias = r_shadowCascadeZBias -> value ; switch ( level ) { case 0 : default : splitZNear = viewZNear ; splitZFar = CalcSplit ( viewZNear , viewZFar , 1 , 3 ) + splitBias ; break ; case 1 : splitZNear = CalcSplit ( viewZNear , viewZFar , 1 , 3 ) + splitBias ; splitZFar = CalcSplit ( viewZNear , viewZFar , 2 , 3 ) + splitBias ; break ; case 2 : splitZNear = CalcSplit ( viewZNear , viewZFar , 2 , 3 ) + splitBias ; splitZFar = viewZFar ; break ; } if ( level != 3 ) { VectorCopy ( fd -> vieworg , lightOrigin ) ; } else { VectorCopy ( tr . world -> lightGridOrigin , lightOrigin ) ; } VectorScale ( lightDir , - 1.0f , lightViewAxis [ 0 ] ) ; if ( level == 3 || lightViewIndependentOfCameraView ) { VectorSet ( lightViewAxis [ 2 ] , 0 , 0 , 1 ) ; } if ( level == 0 ) { VectorAdd ( fd -> viewaxis [ 0 ] , fd -> viewaxis [ 1 ] , lightViewAxis [ 2 ] ) ; } else { VectorCopy ( fd -> viewaxis [ 2 ] , lightViewAxis [ 2 ] ) ; } if ( fabs ( DotProduct ( lightViewAxis [ 2 ] , lightViewAxis [ 0 ] ) ) > 0.9f ) { if ( level == 3 || lightViewIndependentOfCameraView ) { VectorSet ( lightViewAxis [ 2 ] , 0 , 1 , 0 ) ; } if ( level == 0 ) { VectorAdd ( fd -> viewaxis [ 0 ] , fd -> viewaxis [ 2 ] , lightViewAxis [ 2 ] ) ; } else { VectorCopy ( fd -> viewaxis [ 1 ] , lightViewAxis [ 2 ] ) ; } } CrossProduct ( lightViewAxis [ 2 ] , lightViewAxis [ 0 ] , lightViewAxis [ 1 ] ) ; VectorNormalize ( lightViewAxis [ 1 ] ) ; CrossProduct ( lightViewAxis [ 0 ] , lightViewAxis [ 1 ] , lightViewAxis [ 2 ] ) ; { mat4_t lightViewMatrix ; vec4_t point , base , lightViewPoint ; float lx , ly ; base [ 3 ] = 1 ; point [ 3 ] = 1 ; lightViewPoint [ 3 ] = 1 ; Mat4View ( lightViewAxis , lightOrigin , lightViewMatrix ) ; ClearBounds ( lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; if ( level != 3 ) { lx = splitZNear * tan ( fd -> fov_x * M_PI / 360.0f ) ; ly = splitZNear * tan ( fd -> fov_y * M_PI / 360.0f ) ; VectorMA ( fd -> vieworg , splitZNear , fd -> viewaxis [ 0 ] , base ) ; VectorMA ( base , lx , fd -> viewaxis [ 1 ] , point ) ; VectorMA ( point , ly , fd -> viewaxis [ 2 ] , point ) ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; VectorMA ( base , - lx , fd -> viewaxis [ 1 ] , point ) ; VectorMA ( point , ly , fd -> viewaxis [ 2 ] , point ) ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; VectorMA ( base , lx , fd -> viewaxis [ 1 ] , point ) ; VectorMA ( point , - ly , fd -> viewaxis [ 2 ] , point ) ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; VectorMA ( base , - lx , fd -> viewaxis [ 1 ] , point ) ; VectorMA ( point , - ly , fd -> viewaxis [ 2 ] , point ) ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; lx = splitZFar * tan ( fd -> fov_x * M_PI / 360.0f ) ; ly = splitZFar * tan ( fd -> fov_y * M_PI / 360.0f ) ; VectorMA ( fd -> vieworg , splitZFar , fd -> viewaxis [ 0 ] , base ) ; VectorMA ( base , lx , fd -> viewaxis [ 1 ] , point ) ; VectorMA ( point , ly , fd -> viewaxis [ 2 ] , point ) ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; VectorMA ( base , - lx , fd -> viewaxis [ 1 ] , point ) ; VectorMA ( point , ly , fd -> viewaxis [ 2 ] , point ) ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; VectorMA ( base , lx , fd -> viewaxis [ 1 ] , point ) ; VectorMA ( point , - ly , fd -> viewaxis [ 2 ] , point ) ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; VectorMA ( base , - lx , fd -> viewaxis [ 1 ] , point ) ; VectorMA ( point , - ly , fd -> viewaxis [ 2 ] , point ) ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; } else { vec3_t bounds ; bounds [ 0 ] = tr . world -> lightGridSize [ 0 ] * tr . world -> lightGridBounds [ 0 ] ; bounds [ 1 ] = tr . world -> lightGridSize [ 1 ] * tr . world -> lightGridBounds [ 1 ] ; bounds [ 2 ] = tr . world -> lightGridSize [ 2 ] * tr . world -> lightGridBounds [ 2 ] ; point [ 0 ] = tr . world -> lightGridOrigin [ 0 ] ; point [ 1 ] = tr . world -> lightGridOrigin [ 1 ] ; point [ 2 ] = tr . world -> lightGridOrigin [ 2 ] ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; point [ 0 ] = tr . world -> lightGridOrigin [ 0 ] + bounds [ 0 ] ; point [ 1 ] = tr . world -> lightGridOrigin [ 1 ] ; point [ 2 ] = tr . world -> lightGridOrigin [ 2 ] ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; point [ 0 ] = tr . world -> lightGridOrigin [ 0 ] ; point [ 1 ] = tr . world -> lightGridOrigin [ 1 ] + bounds [ 1 ] ; point [ 2 ] = tr . world -> lightGridOrigin [ 2 ] ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; point [ 0 ] = tr . world -> lightGridOrigin [ 0 ] + bounds [ 0 ] ; point [ 1 ] = tr . world -> lightGridOrigin [ 1 ] + bounds [ 1 ] ; point [ 2 ] = tr . world -> lightGridOrigin [ 2 ] ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; point [ 0 ] = tr . world -> lightGridOrigin [ 0 ] ; point [ 1 ] = tr . world -> lightGridOrigin [ 1 ] ; point [ 2 ] = tr . world -> lightGridOrigin [ 2 ] + bounds [ 2 ] ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; point [ 0 ] = tr . world -> lightGridOrigin [ 0 ] + bounds [ 0 ] ; point [ 1 ] = tr . world -> lightGridOrigin [ 1 ] ; point [ 2 ] = tr . world -> lightGridOrigin [ 2 ] + bounds [ 2 ] ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; point [ 0 ] = tr . world -> lightGridOrigin [ 0 ] ; point [ 1 ] = tr . world -> lightGridOrigin [ 1 ] + bounds [ 1 ] ; point [ 2 ] = tr . world -> lightGridOrigin [ 2 ] + bounds [ 2 ] ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; point [ 0 ] = tr . world -> lightGridOrigin [ 0 ] + bounds [ 0 ] ; point [ 1 ] = tr . world -> lightGridOrigin [ 1 ] + bounds [ 1 ] ; point [ 2 ] = tr . world -> lightGridOrigin [ 2 ] + bounds [ 2 ] ; Mat4Transform ( lightViewMatrix , point , lightViewPoint ) ; AddPointToBounds ( lightViewPoint , lightviewBounds [ 0 ] , lightviewBounds [ 1 ] ) ; } if ( ! glRefConfig . depthClamp ) { lightviewBounds [ 0 ] [ 0 ] = lightviewBounds [ 1 ] [ 0 ] - 8192 ; } if ( lightViewIndependentOfCameraView ) { float cascadeBound , worldUnitsPerTexel , invWorldUnitsPerTexel ; cascadeBound = MAX ( lightviewBounds [ 1 ] [ 0 ] - lightviewBounds [ 0 ] [ 0 ] , lightviewBounds [ 1 ] [ 1 ] - lightviewBounds [ 0 ] [ 1 ] ) ; cascadeBound = MAX ( cascadeBound , lightviewBounds [ 1 ] [ 2 ] - lightviewBounds [ 0 ] [ 2 ] ) ; worldUnitsPerTexel = cascadeBound / tr . sunShadowFbo [ level ] -> width ; invWorldUnitsPerTexel = 1.0f / worldUnitsPerTexel ; VectorScale ( lightviewBounds [ 0 ] , invWorldUnitsPerTexel , lightviewBounds [ 0 ] ) ; lightviewBounds [ 0 ] [ 0 ] = floor ( lightviewBounds [ 0 ] [ 0 ] ) ; lightviewBounds [ 0 ] [ 1 ] = floor ( lightviewBounds [ 0 ] [ 1 ] ) ; lightviewBounds [ 0 ] [ 2 ] = floor ( lightviewBounds [ 0 ] [ 2 ] ) ; VectorScale ( lightviewBounds [ 0 ] , worldUnitsPerTexel , lightviewBounds [ 0 ] ) ; VectorScale ( lightviewBounds [ 1 ] , invWorldUnitsPerTexel , lightviewBounds [ 1 ] ) ; lightviewBounds [ 1 ] [ 0 ] = floor ( lightviewBounds [ 1 ] [ 0 ] ) ; lightviewBounds [ 1 ] [ 1 ] = floor ( lightviewBounds [ 1 ] [ 1 ] ) ; lightviewBounds [ 1 ] [ 2 ] = floor ( lightviewBounds [ 1 ] [ 2 ] ) ; VectorScale ( lightviewBounds [ 1 ] , worldUnitsPerTexel , lightviewBounds [ 1 ] ) ; } } { int firstDrawSurf ; Com_Memset ( & shadowParms , 0 , sizeof ( shadowParms ) ) ; if ( glRefConfig . framebufferObject ) { shadowParms . viewportX = 0 ; shadowParms . viewportY = 0 ; } else { shadowParms . viewportX = tr . refdef . x ; shadowParms . viewportY = glConfig . vidHeight - ( tr . refdef . y + tr . sunShadowFbo [ level ] -> height ) ; } shadowParms . viewportWidth = tr . sunShadowFbo [ level ] -> width ; shadowParms . viewportHeight = tr . sunShadowFbo [ level ] -> height ; shadowParms . isPortal = qfalse ; shadowParms . isMirror = qfalse ; shadowParms . fovX = 90 ; shadowParms . fovY = 90 ; if ( glRefConfig . framebufferObject ) { shadowParms . targetFbo = tr . sunShadowFbo [ level ] ; } shadowParms . flags = VPF_DEPTHSHADOW | VPF_DEPTHCLAMP | VPF_ORTHOGRAPHIC | VPF_NOVIEWMODEL ; shadowParms . zFar = lightviewBounds [ 1 ] [ 0 ] ; VectorCopy ( lightOrigin , shadowParms . or . origin ) ; VectorCopy ( lightViewAxis [ 0 ] , shadowParms . or . axis [ 0 ] ) ; VectorCopy ( lightViewAxis [ 1 ] , shadowParms . or . axis [ 1 ] ) ; VectorCopy ( lightViewAxis [ 2 ] , shadowParms . or . axis [ 2 ] ) ; VectorCopy ( lightOrigin , shadowParms . pvsOrigin ) ; { tr . viewCount ++ ; tr . viewParms = shadowParms ; tr . viewParms . frameSceneNum = tr . frameSceneNum ; tr . viewParms . frameCount = tr . frameCount ; firstDrawSurf = tr . refdef . numDrawSurfs ; tr . viewCount ++ ; R_RotateForViewer ( ) ; R_SetupProjectionOrtho ( & tr . viewParms , lightviewBounds ) ; R_AddWorldSurfaces ( ) ; R_AddPolygonSurfaces ( ) ; R_AddEntitySurfaces ( ) ; R_SortDrawSurfs ( tr . refdef . drawSurfs + firstDrawSurf , tr . refdef . numDrawSurfs - firstDrawSurf ) ; } Mat4Multiply ( tr . viewParms . projectionMatrix , tr . viewParms . world . modelMatrix , tr . refdef . sunShadowMvp [ level ] ) ; } } 