static int netlink_route_info_encode ( struct netlink_route_info * ri , char * in_buf , size_t in_buf_len ) { size_t bytelen ; unsigned int nexthop_num = 0 ; size_t buf_offset ; struct netlink_nh_info * nhi ; enum fpm_nh_encap_type_t encap ; struct rtattr * nest , * inner_nest ; struct rtnexthop * rtnh ; struct vxlan_encap_info_t * vxlan ; struct in6_addr ipv6 ; { struct nlmsghdr n ; struct rtmsg r ; char buf [ 1 ] ; } , * req req = ( void * ) in_buf ; buf_offset = ( ( char * ) req -> buf ) - ( ( char * ) req ) ; if ( in_buf_len < buf_offset ) { assert ( 0 ) ; return 0 ; } bytelen = af_addr_size ( ri -> af ) ; req -> n . nlmsg_len = NLMSG_LENGTH ( sizeof ( rtmsg ) ) ; req -> n . nlmsg_flags = NLM_F_CREATE | NLM_F_REQUEST ; req -> n . nlmsg_pid = ri -> nlmsg_pid ; req -> n . nlmsg_type = ri -> nlmsg_type ; req -> r . rtm_family = ri -> af ; if ( ri -> rtm_table < 256 ) { req -> r . rtm_table = ri -> rtm_table ; } else { req -> r . rtm_table = RT_TABLE_UNSPEC ; nl_attr_put32 ( & req -> n , in_buf_len , RTA_TABLE , ri -> rtm_table ) ; } req -> r . rtm_dst_len = ri -> prefix -> prefixlen ; req -> r . rtm_protocol = ri -> rtm_protocol ; req -> r . rtm_scope = RT_SCOPE_UNIVERSE ; nl_attr_put ( & req -> n , in_buf_len , RTA_DST , & ri -> prefix -> u . prefix , bytelen ) ; req -> r . rtm_type = ri -> rtm_type ; if ( ri -> metric ) { nl_attr_put32 ( & req -> n , in_buf_len , RTA_PRIORITY , * ri -> metric ) ; } if ( ri -> num_nhs == 0 ) { done } if ( ri -> num_nhs == 1 ) { nhi = & ri -> nhs [ 0 ] ; if ( nhi -> gateway ) { if ( nhi -> type == NEXTHOP_TYPE_IPV4_IFINDEX && ri -> af == AF_INET6 ) { ipv4_to_ipv4_mapped_ipv6 ( & ipv6 , nhi -> gateway -> ipv4 ) ; nl_attr_put ( & req -> n , in_buf_len , RTA_GATEWAY , & ipv6 , bytelen ) ; } else { nl_attr_put ( & req -> n , in_buf_len , RTA_GATEWAY , nhi -> gateway , bytelen ) ; } } if ( nhi -> if_index ) { nl_attr_put32 ( & req -> n , in_buf_len , RTA_OIF , nhi -> if_index ) ; } encap = nhi -> encap_info . encap_type ; switch ( encap ) { case FPM_NH_ENCAP_NONE : case FPM_NH_ENCAP_MAX : break ; case FPM_NH_ENCAP_VXLAN : nl_attr_put16 ( & req -> n , in_buf_len , RTA_ENCAP_TYPE , encap ) ; vxlan = & nhi -> encap_info . vxlan_encap ; nest = nl_attr_nest ( & req -> n , in_buf_len , RTA_ENCAP ) ; nl_attr_put32 ( & req -> n , in_buf_len , VXLAN_VNI , vxlan -> vni ) ; nl_attr_nest_end ( & req -> n , nest ) ; break ; } done } nest = nl_attr_nest ( & req -> n , in_buf_len , RTA_MULTIPATH ) ; for ( nexthop_num = 0 ; nexthop_num < ri -> num_nhs ; nexthop_num ++ ) { rtnh = nl_attr_rtnh ( & req -> n , in_buf_len ) ; nhi = & ri -> nhs [ nexthop_num ] ; if ( nhi -> gateway ) { nl_attr_put ( & req -> n , in_buf_len , RTA_GATEWAY , nhi -> gateway , bytelen ) ; } if ( nhi -> if_index ) { rtnh -> rtnh_ifindex = nhi -> if_index ; } rtnh -> rtnh_hops = nhi -> weight ; encap = nhi -> encap_info . encap_type ; switch ( encap ) { case FPM_NH_ENCAP_NONE : case FPM_NH_ENCAP_MAX : break ; case FPM_NH_ENCAP_VXLAN : nl_attr_put16 ( & req -> n , in_buf_len , RTA_ENCAP_TYPE , encap ) ; vxlan = & nhi -> encap_info . vxlan_encap ; inner_nest = nl_attr_nest ( & req -> n , in_buf_len , RTA_ENCAP ) ; nl_attr_put32 ( & req -> n , in_buf_len , VXLAN_VNI , vxlan -> vni ) ; nl_attr_nest_end ( & req -> n , inner_nest ) ; break ; } nl_attr_rtnh_end ( & req -> n , rtnh ) ; } nl_attr_nest_end ( & req -> n , nest ) ; assert ( nest -> rta_len > RTA_LENGTH ( 0 ) ) ; done if ( ri -> pref_src ) { nl_attr_put ( & req -> n , in_buf_len , RTA_PREFSRC , ri -> pref_src , bytelen ) ; } assert ( req -> n . nlmsg_len < in_buf_len ) ; return req -> n . nlmsg_len ; } 