const char * * mdb_path_alloc ( const char * s , size_t * newlen ) { char * format = mdb_alloc ( strlen ( s ) * 2 + 1 , UM_NOSLEEP ) ; const char * * path ; char * p , * q ; struct utsname uts ; size_t len ; int i ; mdb_arg_t arg_i , arg_m , arg_p , arg_r , arg_t , arg_R , arg_V ; mdb_argvec_t argv ; static const char * empty_path [ ] { NULL } ; ; if ( format == NULL ) { nomem } while ( * s == ':' ) { s ++ ; } if ( * s == '\0' ) { * newlen = 0 ; return ( empty_path ) ; } ( void ) strcpy ( format , s ) ; mdb_argvec_create ( & argv ) ; arg_i . a_type = MDB_TYPE_STRING ; if ( mdb . m_target != NULL ) { arg_i . a_un . a_str = mdb_tgt_isa ( mdb . m_target ) ; } else { arg_i . a_un . a_str = mdb_conf_isa ( ) ; } arg_p . a_type = MDB_TYPE_STRING ; if ( mdb . m_target != NULL ) { arg_p . a_un . a_str = mdb_tgt_platform ( mdb . m_target ) ; } else { arg_p . a_un . a_str = mdb_conf_platform ( ) ; } arg_r . a_type = MDB_TYPE_STRING ; arg_r . a_un . a_str = strcmp ( mdb . m_root , "/" ) ?mdb . m_root : "" ; arg_t . a_type = MDB_TYPE_STRING ; arg_t . a_un . a_str = mdb . m_target ?mdb_tgt_name ( mdb . m_target ) : "kvm" ; if ( mdb . m_target == NULL || mdb_tgt_uname ( mdb . m_target , & uts ) < 0 ) { mdb_conf_uname ( & uts ) ; } arg_m . a_type = MDB_TYPE_STRING ; arg_m . a_un . a_str = uts . machine ; arg_R . a_type = MDB_TYPE_STRING ; arg_R . a_un . a_str = uts . release ; arg_V . a_type = MDB_TYPE_STRING ; if ( mdb . m_flags & MDB_FL_LATEST ) { arg_V . a_un . a_str = "latest" ; } else { arg_V . a_un . a_str = uts . version ; } for ( q = format ; ( q = strchr ( q , '%' ) ) != NULL ; q ++ ) { switch ( q [ 1 ] ) { case 'i' : mdb_argvec_append ( & argv , & arg_i ) ; * ++ q = 's' ; break ; case 'm' : mdb_argvec_append ( & argv , & arg_m ) ; * ++ q = 's' ; break ; case 'p' : mdb_argvec_append ( & argv , & arg_p ) ; * ++ q = 's' ; break ; case 'r' : mdb_argvec_append ( & argv , & arg_r ) ; * ++ q = 's' ; break ; case 't' : mdb_argvec_append ( & argv , & arg_t ) ; * ++ q = 's' ; break ; case 'R' : mdb_argvec_append ( & argv , & arg_R ) ; * ++ q = 's' ; break ; case 'V' : mdb_argvec_append ( & argv , & arg_V ) ; * ++ q = 's' ; break ; default : bcopy ( q + 1 , q + 2 , strlen ( q ) ) ; * ++ q = '%' ; } } len = mdb_iob_asnprintf ( NULL , 0 , format , argv . a_data ) ; if ( ( p = mdb_alloc ( len + 1 , UM_NOSLEEP ) ) != NULL ) { ( void ) mdb_iob_asnprintf ( p , len + 1 , format , argv . a_data ) ; } else { nomem } mdb_argvec_zero ( & argv ) ; mdb_argvec_destroy ( & argv ) ; mdb_free ( format , strlen ( s ) * 2 + 1 ) ; format = NULL ; for ( q = p ; * q == ':' ; q ++ ) { continue ; } if ( q != p ) { bcopy ( q , p , strlen ( q ) + 1 ) ; } for ( i = 1 , q = p ; ( q = strchr ( q , ':' ) ) != NULL ; i ++ ) { while ( * q == ':' ) { q ++ ; } } if ( ( path = mdb_alloc ( sizeof ( char * ) * ( i + 1 ) , UM_NOSLEEP ) ) == NULL ) { mdb_free ( p , len + 1 ) ; nomem } for ( i = 0 , q = strtok ( p , ":" ) ; q != NULL ; q = strtok ( NULL , ":" ) ) { path [ i ++ ] = q ; } path [ i ] = NULL ; * newlen = len + 1 ; return ( path ) ; nomem warn ( "failed to allocate memory for path" ) ; * newlen = 0 ; return ( empty_path ) ; } 