static int blowfish_encrypt_update ( crypto_ctx_t * ctx , crypto_data_t * plaintext , crypto_data_t * ciphertext , crypto_req_handle_t req ) { off_t saved_offset ; size_t saved_length , out_len ; int ret = CRYPTO_SUCCESS ; ASSERT ( ctx -> cc_provider_private != NULL ) ; BLOWFISH_ARG_INPLACE ( plaintext , ciphertext ) ; out_len = ( ( blowfish_ctx_t * ) ctx -> cc_provider_private ) -> bc_remainder_len ; out_len += plaintext -> cd_length ; if ( ciphertext -> cd_length < out_len ) { ciphertext -> cd_length = out_len ; return ( CRYPTO_BUFFER_TOO_SMALL ) ; } saved_offset = ciphertext -> cd_offset ; saved_length = ciphertext -> cd_length ; switch ( plaintext -> cd_format ) { case CRYPTO_DATA_RAW : ret = crypto_update_iov ( ctx -> cc_provider_private , plaintext , ciphertext , blowfish_encrypt_contiguous_blocks , blowfish_copy_block64 ) ; break ; case CRYPTO_DATA_UIO : ret = crypto_update_uio ( ctx -> cc_provider_private , plaintext , ciphertext , blowfish_encrypt_contiguous_blocks , blowfish_copy_block64 ) ; break ; case CRYPTO_DATA_MBLK : ret = crypto_update_mp ( ctx -> cc_provider_private , plaintext , ciphertext , blowfish_encrypt_contiguous_blocks , blowfish_copy_block64 ) ; break ; default : ret = CRYPTO_ARGUMENTS_BAD ; } if ( ret == CRYPTO_SUCCESS ) { if ( plaintext != ciphertext ) { ciphertext -> cd_length = ciphertext -> cd_offset - saved_offset ; } } else { ciphertext -> cd_length = saved_length ; } ciphertext -> cd_offset = saved_offset ; return ( ret ) ; } 