int hpet_alloc ( struct hpet_data * hdp ) { u64 cap , mcfg ; struct hpet_dev * devp ; u32 i , ntimer ; struct hpets * hpetp ; struct hpet __iomem * hpet ; static struct hpets * last ; unsigned long period ; unsigned long long temp ; u32 remainder ; if ( hpet_is_known ( hdp ) ) { printk ( KERN_DEBUG "%s: duplicate HPET ignored\n" , __func__ ) ; return 0 ; } hpetp = kzalloc ( struct_size ( hpetp , hp_dev , hdp -> hd_nirqs ) , GFP_KERNEL ) ; if ( ! hpetp ) { return - ENOMEM ; } hpetp -> hp_which = hpet_nhpet ++ ; hpetp -> hp_hpet = hdp -> hd_address ; hpetp -> hp_hpet_phys = hdp -> hd_phys_address ; hpetp -> hp_ntimer = hdp -> hd_nirqs ; for ( i = 0 ; i < hdp -> hd_nirqs ; i ++ ) { hpetp -> hp_dev [ i ] . hd_hdwirq = hdp -> hd_irq [ i ] ; } hpet = hpetp -> hp_hpet ; cap = readq ( & hpet -> hpet_cap ) ; ntimer = ( ( cap & HPET_NUM_TIM_CAP_MASK ) >> HPET_NUM_TIM_CAP_SHIFT ) + 1 ; if ( hpetp -> hp_ntimer != ntimer ) { printk ( KERN_WARNING "hpet: number irqs doesn't agree" " with number of timers\n" ) ; return - ENODEV ; } if ( last ) { last -> hp_next = hpetp ; } else { hpets = hpetp ; } last = hpetp ; period = ( cap & HPET_COUNTER_CLK_PERIOD_MASK ) >> HPET_COUNTER_CLK_PERIOD_SHIFT ; temp = 1000000000000000uLL ; temp += period >> 1 ; do_div ( temp , period ) ; hpetp -> hp_tick_freq = temp ; printk ( KERN_INFO "hpet%d: at MMIO 0x%lx, IRQ%s" , hpetp -> hp_which , hdp -> hd_phys_address , hpetp -> hp_ntimer > 1 ?"s" : "" ) ; for ( i = 0 ; i < hpetp -> hp_ntimer ; i ++ ) { printk ( KERN_CONT "%s %d" , i > 0 ?"," : "" , hdp -> hd_irq [ i ] ) ; } printk ( KERN_CONT "\n" ) ; temp = hpetp -> hp_tick_freq ; remainder = do_div ( temp , 1000000 ) ; printk ( KERN_INFO "hpet%u: %u comparators, %d-bit %u.%06u MHz counter\n" , hpetp -> hp_which , hpetp -> hp_ntimer , cap & HPET_COUNTER_SIZE_MASK ?64 : 32 , ( unsigned ) temp , remainder ) ; mcfg = readq ( & hpet -> hpet_config ) ; if ( ( mcfg & HPET_ENABLE_CNF_MASK ) == 0 ) { write_counter ( 0L , & hpet -> hpet_mc ) ; mcfg |= HPET_ENABLE_CNF_MASK ; writeq ( mcfg , & hpet -> hpet_config ) ; } for ( i = 0 , devp = hpetp -> hp_dev ; i < hpetp -> hp_ntimer ; i ++ , devp ++ ) { struct hpet_timer __iomem * timer ; timer = & hpet -> hpet_timers [ devp - hpetp -> hp_dev ] ; devp -> hd_hpets = hpetp ; devp -> hd_hpet = hpet ; devp -> hd_timer = timer ; if ( hdp -> hd_state & ( 1 << i ) ) { devp -> hd_flags = HPET_OPEN ; continue ; } init_waitqueue_head ( & devp -> hd_waitqueue ) ; } hpetp -> hp_delta = hpet_calibrate ( hpetp ) ; if ( ! hpet_clocksource ) { hpet_mctr = ( void __iomem * ) & hpetp -> hp_hpet -> hpet_mc ; clocksource_hpet . archdata . fsys_mmio = hpet_mctr ; clocksource_register_hz ( & clocksource_hpet , hpetp -> hp_tick_freq ) ; hpetp -> hp_clocksource = & clocksource_hpet ; hpet_clocksource = & clocksource_hpet ; } return 0 ; } 