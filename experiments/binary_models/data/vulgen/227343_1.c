static void btxld ( const char * iname ) { char name [ FILENAME_MAX ] ; struct btx_hdr btx , btxle ; struct hdr ihdr , ohdr ; unsigned int ldr_size , cwr ; int fdi [ 3 ] , fdo , i ; ldr_size = 0 ; for ( i = I_LDR ; i <= I_CLNT ; i ++ ) { fname = i == I_LDR ?lname : i == I_BTX ?bname : iname ; if ( ( fdi [ i ] = open ( fname , O_RDONLY ) ) == - 1 ) { err ( 2 , "%s" , fname ) ; } switch ( i ) { case I_LDR : gethdr ( fdi [ i ] , & ihdr ) ; if ( ihdr . fmt != F_BIN ) { Warn ( fname , "Loader format is %s; processing as %s" , fmtlist [ ihdr . fmt ] , fmtlist [ F_BIN ] ) ; } ldr_size = ihdr . size ; break ; case I_BTX : getbtx ( fdi [ i ] , & btx ) ; break ; case I_CLNT : gethdr ( fdi [ i ] , & ihdr ) ; if ( ihdr . org && ihdr . org != BTX_PGSIZE ) { Warn ( fname , "Client origin is 0x%x; expecting 0 or 0x%x" , ihdr . org , BTX_PGSIZE ) ; } } } ohdr . fmt = format ; ohdr . text = ldr_size ; ohdr . data = btx . btx_textsz + ihdr . size ; ohdr . org = lentry ; ohdr . entry = lentry ; cwr = 0 ; if ( wpage > 0 || ( wpage == - 1 && ! ( ihdr . flags & IMPURE ) ) ) { if ( wpage > 0 ) { cwr = wpage ; } else { cwr = howmany ( ihdr . text , BTX_PGSIZE ) ; if ( cwr > BTX_MAXCWR ) { cwr = BTX_MAXCWR ; } } } if ( ppage > 0 || ( ppage && wpage && ihdr . org >= BTX_PGSIZE ) ) { btx . btx_flags |= BTX_MAPONE ; if ( ! cwr ) { cwr ++ ; } } btx . btx_pgctl -= cwr ; btx . btx_entry = Eflag ?centry : ihdr . entry ; if ( ( size_t ) snprintf ( name , sizeof ( name ) , "%s.tmp" , oname ) >= sizeof ( name ) ) { errx ( 2 , "%s: Filename too long" , oname ) ; } if ( ( fdo = open ( name , O_CREAT | O_TRUNC | O_WRONLY , 0666 ) ) == - 1 ) { err ( 2 , "%s" , name ) ; } if ( ! ( tname = strdup ( name ) ) ) { err ( 2 , NULL ) ; } puthdr ( fdo , & ohdr ) ; for ( i = I_LDR ; i <= I_CLNT ; i ++ ) { fname = i == I_LDR ?lname : i == I_BTX ?bname : iname ; switch ( i ) { case I_LDR : copy ( fdi [ i ] , fdo , ldr_size , 0 ) ; seekx ( fdo , ohdr . size += ohdr . text ) ; break ; case I_BTX : btxle = btx ; btxle . btx_pgctl = htole16 ( btxle . btx_pgctl ) ; btxle . btx_textsz = htole16 ( btxle . btx_textsz ) ; btxle . btx_entry = htole32 ( btxle . btx_entry ) ; writex ( fdo , & btxle , sizeof ( btxle ) ) ; copy ( fdi [ i ] , fdo , btx . btx_textsz - sizeof ( btx ) , sizeof ( btx ) ) ; break ; case I_CLNT : copy ( fdi [ i ] , fdo , ihdr . size , 0 ) ; if ( ftruncate ( fdo , ohdr . size += ohdr . data ) ) { err ( 2 , "%s" , tname ) ; } } if ( close ( fdi [ i ] ) ) { err ( 2 , "%s" , fname ) ; } } if ( close ( fdo ) ) { err ( 2 , "%s" , tname ) ; } if ( verbose ) { printf ( binfo , btx . btx_majver , btx . btx_minver , btx . btx_textsz , BTX_ORIGIN ( btx ) , BTX_ENTRY ( btx ) , BTX_MAPPED ( btx ) * BTX_PGSIZE / 0x100000 , ! ! ( btx . btx_flags & BTX_MAPONE ) , BTX_MAPPED ( btx ) - btx . btx_pgctl - BTX_PGBASE / BTX_PGSIZE - BTX_MAPPED ( btx ) * 4 / BTX_PGSIZE ) ; printf ( cinfo , fmtlist [ ihdr . fmt ] , ihdr . size , ihdr . text , ihdr . data , ihdr . bss , ihdr . entry ) ; printf ( oinfo , fmtlist [ ohdr . fmt ] , ohdr . size , ohdr . text , ohdr . data , ohdr . org , ohdr . entry ) ; } } 