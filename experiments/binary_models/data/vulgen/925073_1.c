write_switch ( , ) { struct decision * p = start ; enum decision_type type = p -> tests -> type ; struct decision * needs_label = NULL ; if ( ! p -> next || p -> tests -> next || p -> next -> tests -> type != type || p -> next -> tests -> next || nodes_identical_1 ( p -> tests , p -> next -> tests ) ) { return p ; } if ( type == DT_code ) { char codemap [ NUM_RTX_CODE ] ; struct decision * ret ; RTX_CODE code ; printf ( "  switch (GET_CODE (x%d))\n    {\n" , depth ) ; code = p -> tests -> u . code ; { if ( p != start && p -> need_label && needs_label == NULL ) { needs_label = p ; } printf ( "    case " ) ; print_code ( code ) ; printf ( ":\n      goto L%d;\n" , p -> success . first -> number ) ; p -> success . first -> need_label = 1 ; codemap [ code ] = 1 ; p = p -> next ; } p && ! p -> tests -> next && p -> tests -> type == DT_code && ! codemap [ code = p -> tests -> u . code ] ; if ( needs_label != NULL ) { ret = needs_label ; } else { ret = p ; } while ( p && p -> tests -> type == DT_pred && p -> tests -> u . pred . data ) { const struct pred_data * data = p -> tests -> u . pred . data ; RTX_CODE c ; for ( c = 0 ; c < NUM_RTX_CODE ; c ++ ) { if ( codemap [ c ] && data -> codes [ c ] ) { pred_done } } for ( c = 0 ; c < NUM_RTX_CODE ; c ++ ) { if ( data -> codes [ c ] ) { fputs ( "    case " , stdout ) ; print_code ( c ) ; fputs ( ":\n" , stdout ) ; codemap [ c ] = 1 ; } } printf ( "      goto L%d;\n" , p -> number ) ; p -> need_label = 1 ; p = p -> next ; } pred_done printf ( "    default:\n" ) ; if ( p != ret ) { if ( p ) { printf ( "      goto L%d;\n" , p -> number ) ; p -> need_label = 1 ; } else { write_afterward ( start , start -> afterward , "      " ) ; } } else { printf ( "     break;\n" ) ; } printf ( "   }\n" ) ; return ret ; } if ( type == DT_mode || type == DT_veclen || type == DT_elt_zero_int || type == DT_elt_one_int || type == DT_elt_zero_wide_safe ) { const char * indent = "" ; if ( type == DT_elt_zero_wide_safe ) { indent = "  " ; printf ( "  if ((int) XWINT (x%d, 0) == XWINT (x%d, 0))\n" , depth , depth ) ; } printf ( "%s  switch (" , indent ) ; switch ( type ) { case DT_mode : printf ( "GET_MODE (x%d)" , depth ) ; break ; case DT_veclen : printf ( "XVECLEN (x%d, 0)" , depth ) ; break ; case DT_elt_zero_int : printf ( "XINT (x%d, 0)" , depth ) ; break ; case DT_elt_one_int : printf ( "XINT (x%d, 1)" , depth ) ; break ; case DT_elt_zero_wide_safe : printf ( "(int) XWINT (x%d, 0)" , depth ) ; break ; default : gcc_unreachable ( ) ; } printf ( ")\n%s    {\n" , indent ) ; { struct decision * q ; for ( q = start ; q != p ; q = q -> next ) { if ( nodes_identical_1 ( p -> tests , q -> tests ) ) { case_done } } if ( p != start && p -> need_label && needs_label == NULL ) { needs_label = p ; } printf ( "%s    case " , indent ) ; switch ( type ) { case DT_mode : printf ( "%smode" , GET_MODE_NAME ( p -> tests -> u . mode ) ) ; break ; case DT_veclen : printf ( "%d" , p -> tests -> u . veclen ) ; break ; case DT_elt_zero_int : case DT_elt_one_int : case DT_elt_zero_wide : case DT_elt_zero_wide_safe : print_host_wide_int ( p -> tests -> u . intval ) ; break ; default : gcc_unreachable ( ) ; } printf ( ":\n%s      goto L%d;\n" , indent , p -> success . first -> number ) ; p -> success . first -> need_label = 1 ; p = p -> next ; } p && p -> tests -> type == type && ! p -> tests -> next ; case_done printf ( "%s    default:\n%s      break;\n%s    }\n" , indent , indent , indent ) ; return needs_label != NULL ?needs_label : p ; } else { return p ; } } 