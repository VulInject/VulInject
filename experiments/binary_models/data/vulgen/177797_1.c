static int _scsih_probe ( struct pci_dev * pdev , const struct pci_device_id * id ) { struct MPT3SAS_ADAPTER * ioc ; struct Scsi_Host * shost = NULL ; int rv ; u16 hba_mpi_version ; hba_mpi_version = _scsih_determine_hba_mpi_version ( pdev ) ; if ( hba_mpi_version == 0 ) { return - ENODEV ; } if ( ( hbas_to_enumerate == 1 ) && ( hba_mpi_version != MPI2_VERSION ) ) { return - ENODEV ; } if ( ( hbas_to_enumerate == 2 ) && ( ! ( hba_mpi_version == MPI25_VERSION || hba_mpi_version == MPI26_VERSION ) ) ) { return - ENODEV ; } switch ( hba_mpi_version ) { case MPI2_VERSION : pci_disable_link_state ( pdev , PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 | PCIE_LINK_STATE_CLKPM ) ; shost = scsi_host_alloc ( & mpt2sas_driver_template , sizeof ( MPT3SAS_ADAPTER ) ) ; if ( ! shost ) { return - ENODEV ; } ioc = shost_priv ( shost ) ; memset ( ioc , 0 , sizeof ( MPT3SAS_ADAPTER ) ) ; ioc -> hba_mpi_version_belonged = hba_mpi_version ; ioc -> id = mpt2_ids ++ ; sprintf ( ioc -> driver_name , "%s" , MPT2SAS_DRIVER_NAME ) ; if ( pdev -> device == MPI2_MFGPAGE_DEVID_SSS6200 ) { ioc -> is_warpdrive = 1 ; ioc -> hide_ir_msg = 1 ; } else { ioc -> mfg_pg10_hide_flag = MFG_PAGE10_EXPOSE_ALL_DISKS ; } break ; case MPI25_VERSION : case MPI26_VERSION : shost = scsi_host_alloc ( & mpt3sas_driver_template , sizeof ( MPT3SAS_ADAPTER ) ) ; if ( ! shost ) { return - ENODEV ; } ioc = shost_priv ( shost ) ; memset ( ioc , 0 , sizeof ( MPT3SAS_ADAPTER ) ) ; ioc -> hba_mpi_version_belonged = hba_mpi_version ; ioc -> id = mpt3_ids ++ ; sprintf ( ioc -> driver_name , "%s" , MPT3SAS_DRIVER_NAME ) ; switch ( pdev -> device ) { case MPI26_MFGPAGE_DEVID_SAS3508 : case MPI26_MFGPAGE_DEVID_SAS3508_1 : case MPI26_MFGPAGE_DEVID_SAS3408 : case MPI26_MFGPAGE_DEVID_SAS3516 : case MPI26_MFGPAGE_DEVID_SAS3516_1 : case MPI26_MFGPAGE_DEVID_SAS3416 : ioc -> is_gen35_ioc = 1 ; break ; default : ioc -> is_gen35_ioc = 0 ; } if ( ( ioc -> hba_mpi_version_belonged == MPI25_VERSION && pdev -> revision >= SAS3_PCI_DEVICE_C0_REVISION ) || ( ioc -> hba_mpi_version_belonged == MPI26_VERSION ) ) { ioc -> combined_reply_queue = 1 ; if ( ioc -> is_gen35_ioc ) { ioc -> combined_reply_index_count = MPT3_SUP_REPLY_POST_HOST_INDEX_REG_COUNT_G35 ; } else { ioc -> combined_reply_index_count = MPT3_SUP_REPLY_POST_HOST_INDEX_REG_COUNT_G3 ; } } break ; default : return - ENODEV ; } INIT_LIST_HEAD ( & ioc -> list ) ; spin_lock ( & gioc_lock ) ; list_add_tail ( & ioc -> list , & mpt3sas_ioc_list ) ; spin_unlock ( & gioc_lock ) ; ioc -> shost = shost ; ioc -> pdev = pdev ; ioc -> scsi_io_cb_idx = scsi_io_cb_idx ; ioc -> tm_cb_idx = tm_cb_idx ; ioc -> ctl_cb_idx = ctl_cb_idx ; ioc -> base_cb_idx = base_cb_idx ; ioc -> port_enable_cb_idx = port_enable_cb_idx ; ioc -> transport_cb_idx = transport_cb_idx ; ioc -> scsih_cb_idx = scsih_cb_idx ; ioc -> config_cb_idx = config_cb_idx ; ioc -> tm_tr_cb_idx = tm_tr_cb_idx ; ioc -> tm_tr_volume_cb_idx = tm_tr_volume_cb_idx ; ioc -> tm_sas_control_cb_idx = tm_sas_control_cb_idx ; ioc -> logging_level = logging_level ; ioc -> schedule_dead_ioc_flush_running_cmds = & _scsih_flush_running_cmds ; mutex_init ( & ioc -> reset_in_progress_mutex ) ; mutex_init ( & ioc -> pci_access_mutex ) ; spin_lock_init ( & ioc -> ioc_reset_in_progress_lock ) ; spin_lock_init ( & ioc -> scsi_lookup_lock ) ; spin_lock_init ( & ioc -> sas_device_lock ) ; spin_lock_init ( & ioc -> sas_node_lock ) ; spin_lock_init ( & ioc -> fw_event_lock ) ; spin_lock_init ( & ioc -> raid_device_lock ) ; spin_lock_init ( & ioc -> diag_trigger_lock ) ; INIT_LIST_HEAD ( & ioc -> sas_device_list ) ; INIT_LIST_HEAD ( & ioc -> sas_device_init_list ) ; INIT_LIST_HEAD ( & ioc -> sas_expander_list ) ; INIT_LIST_HEAD ( & ioc -> fw_event_list ) ; INIT_LIST_HEAD ( & ioc -> raid_device_list ) ; INIT_LIST_HEAD ( & ioc -> sas_hba . sas_port_list ) ; INIT_LIST_HEAD ( & ioc -> delayed_tr_list ) ; INIT_LIST_HEAD ( & ioc -> delayed_sc_list ) ; INIT_LIST_HEAD ( & ioc -> delayed_event_ack_list ) ; INIT_LIST_HEAD ( & ioc -> delayed_tr_volume_list ) ; INIT_LIST_HEAD ( & ioc -> reply_queue_list ) ; sprintf ( ioc -> name , "%s_cm%d" , ioc -> driver_name , ioc -> id ) ; shost -> max_cmd_len = 32 ; shost -> max_lun = max_lun ; shost -> transportt = mpt3sas_transport_template ; shost -> unique_id = ioc -> id ; if ( prot_mask > 0 ) { scsi_host_set_prot ( shost , prot_mask ) ; } else { scsi_host_set_prot ( shost , SHOST_DIF_TYPE1_PROTECTION | SHOST_DIF_TYPE2_PROTECTION | SHOST_DIF_TYPE3_PROTECTION ) ; } scsi_host_set_guard ( shost , SHOST_DIX_GUARD_CRC ) ; snprintf ( ioc -> firmware_event_name , sizeof ( ioc -> firmware_event_name ) , "fw_event_%s%d" , ioc -> driver_name , ioc -> id ) ; ioc -> firmware_event_thread = alloc_ordered_workqueue ( ioc -> firmware_event_name , WQ_MEM_RECLAIM ) ; if ( ! ioc -> firmware_event_thread ) { pr_err ( MPT3SAS_FMT "failure at %s:%d/%s()!\n" , ioc -> name , __FILE__ , __LINE__ , __func__ ) ; rv = - ENODEV ; out_thread_fail } ioc -> is_driver_loading = 1 ; if ( ( mpt3sas_base_attach ( ioc ) ) ) { pr_err ( MPT3SAS_FMT "failure at %s:%d/%s()!\n" , ioc -> name , __FILE__ , __LINE__ , __func__ ) ; rv = - ENODEV ; out_attach_fail } if ( ioc -> is_warpdrive ) { if ( ioc -> mfg_pg10_hide_flag == MFG_PAGE10_EXPOSE_ALL_DISKS ) { ioc -> hide_drives = 0 ; } if ( ioc -> mfg_pg10_hide_flag == MFG_PAGE10_HIDE_ALL_DISKS ) { ioc -> hide_drives = 1 ; } else { if ( mpt3sas_get_num_volumes ( ioc ) ) { ioc -> hide_drives = 1 ; } else { ioc -> hide_drives = 0 ; } } } else { ioc -> hide_drives = 0 ; } rv = scsi_add_host ( shost , & pdev -> dev ) ; if ( rv ) { pr_err ( MPT3SAS_FMT "failure at %s:%d/%s()!\n" , ioc -> name , __FILE__ , __LINE__ , __func__ ) ; out_add_shost_fail } scsi_scan_host ( shost ) ; return 0 ; out_add_shost_fail mpt3sas_base_detach ( ioc ) ; out_attach_fail destroy_workqueue ( ioc -> firmware_event_thread ) ; out_thread_fail spin_lock ( & gioc_lock ) ; list_del ( & ioc -> list ) ; spin_unlock ( & gioc_lock ) ; scsi_host_put ( shost ) ; return rv ; } 