LOCAL tSuccess opt_find_short ( tOptions * pOpts , uint_t optValue , tOptState * pOptState ) { tOptDesc * pRes = pOpts -> pOptDesc ; int ct = pOpts -> optCt ; { if ( optValue != pRes -> optValue ) { continue ; } if ( SKIP_OPT ( pRes ) ) { if ( ( pRes -> fOptState == ( OPTST_OMITTED | OPTST_NO_INIT ) ) && ( pRes -> pz_Name != NULL ) ) { fprintf ( stderr , zDisabledErr , pOpts -> pzProgPath , pRes -> pz_Name ) ; if ( pRes -> pzText != NULL ) { fprintf ( stderr , SET_OFF_FMT , pRes -> pzText ) ; } fputc ( NL , stderr ) ; * pOpts -> pUsageProc ( pOpts , EXIT_FAILURE ) ; _exit ( EXIT_FAILURE ) ; } short_opt_error } pOptState -> pOD = pRes ; pOptState -> optType = TOPT_SHORT ; return SUCCESS ; } pRes ++ , -- ct > 0 ; if ( IS_DEC_DIGIT_CHAR ( optValue ) && ( pOpts -> specOptIdx . number_option != NO_EQUIVALENT ) ) { pOptState -> pOD = pRes = pOpts -> pOptDesc + pOpts -> specOptIdx . number_option ; ( pOpts -> pzCurOpt ) -- ; pOptState -> optType = TOPT_SHORT ; return SUCCESS ; } short_opt_error if ( ( pOpts -> fOptSet & OPTPROC_ERRSTOP ) != 0 ) { fprintf ( stderr , zIllOptChr , pOpts -> pzProgPath , optValue ) ; * pOpts -> pUsageProc ( pOpts , EXIT_FAILURE ) ; _exit ( EXIT_FAILURE ) ; } return FAILURE ; } 