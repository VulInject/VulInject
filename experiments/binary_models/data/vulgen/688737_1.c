load_fallback_face ( , ) { PangoFcFont * fcfont = PANGO_FC_FONT ( ft2font ) ; FcPattern * sans ; FcPattern * matched ; FcResult result ; FT_Error error ; FcChar8 * filename2 = NULL ; gchar * name ; int id ; sans = FcPatternBuild ( NULL , FC_FAMILY , FcTypeString , "sans" , FC_PIXEL_SIZE , FcTypeDouble , ( double ) ft2font -> size / PANGO_SCALE , NULL ) ; _pango_ft2_font_map_default_substitute ( ( PangoFcFontMap * ) fcfont -> fontmap , sans ) ; matched = FcFontMatch ( NULL , sans , & result ) ; if ( FcPatternGetString ( matched , FC_FILE , 0 , & filename2 ) != FcResultMatch ) { bail1 } if ( FcPatternGetInteger ( matched , FC_INDEX , 0 , & id ) != FcResultMatch ) { bail1 } error = FT_New_Face ( _pango_ft2_font_map_get_library ( fcfont -> fontmap ) , ( char * ) filename2 , id , & ft2font -> face ) ; if ( error ) { bail1 name = pango_font_description_to_string ( fcfont -> description ) ; g_error ( "Unable to open font file %s for font %s, exiting\n" , filename2 , name ) ; } else { name = pango_font_description_to_string ( fcfont -> description ) ; g_warning ( "Unable to open font file %s for font %s, falling back to %s\n" , original_file , name , filename2 ) ; } FcPatternDestroy ( sans ) ; FcPatternDestroy ( matched ) ; } 