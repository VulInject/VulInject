void mlx5e_ipsec_offload_handle_rx_skb ( struct net_device * netdev , struct sk_buff * skb , struct mlx5_cqe64 * cqe ) { u32 ipsec_meta_data = be32_to_cpu ( cqe -> ft_metadata ) ; struct mlx5e_priv * priv = netdev_priv ( netdev ) ; struct mlx5e_ipsec * ipsec = priv -> ipsec ; struct mlx5e_ipsec_sa_entry * sa_entry ; struct xfrm_offload * xo ; struct sec_path * sp ; u32 sa_handle ; sa_handle = MLX5_IPSEC_METADATA_HANDLE ( ipsec_meta_data ) ; sp = secpath_set ( skb ) ; if ( unlikely ( ! sp ) ) { atomic64_inc ( & ipsec -> sw_stats . ipsec_rx_drop_sp_alloc ) ; return ; } rcu_read_lock ( ) ; sa_entry = xa_load ( & ipsec -> sadb , sa_handle ) ; if ( unlikely ( ! sa_entry ) ) { rcu_read_unlock ( ) ; atomic64_inc ( & ipsec -> sw_stats . ipsec_rx_drop_sadb_miss ) ; return ; } xfrm_state_hold ( sa_entry -> x ) ; rcu_read_unlock ( ) ; sp -> xvec [ sp -> len ++ ] = sa_entry -> x ; xo = xfrm_offload ( skb ) ; xo -> flags = CRYPTO_DONE ; switch ( MLX5_IPSEC_METADATA_SYNDROM ( ipsec_meta_data ) ) { case MLX5E_IPSEC_OFFLOAD_RX_SYNDROME_DECRYPTED : xo -> status = CRYPTO_SUCCESS ; break ; case MLX5E_IPSEC_OFFLOAD_RX_SYNDROME_AUTH_FAILED : xo -> status = CRYPTO_TUNNEL_ESP_AUTH_FAILED ; break ; case MLX5E_IPSEC_OFFLOAD_RX_SYNDROME_BAD_TRAILER : xo -> status = CRYPTO_INVALID_PACKET_SYNTAX ; break ; default : atomic64_inc ( & ipsec -> sw_stats . ipsec_rx_drop_syndrome ) ; } } 