static const char * atmel_sha_reg_name ( u32 offset , char * tmp , size_t sz , bool wr ) { switch ( offset ) { case SHA_CR : return "CR" ; case SHA_MR : return "MR" ; case SHA_IER : return "IER" ; case SHA_IDR : return "IDR" ; case SHA_IMR : return "IMR" ; case SHA_ISR : return "ISR" ; case SHA_MSR : return "MSR" ; case SHA_BCR : return "BCR" ; case SHA_REG_DIN ( 0 ) : case SHA_REG_DIN ( 1 ) : case SHA_REG_DIN ( 2 ) : case SHA_REG_DIN ( 3 ) : case SHA_REG_DIN ( 4 ) : case SHA_REG_DIN ( 5 ) : case SHA_REG_DIN ( 6 ) : case SHA_REG_DIN ( 7 ) : case SHA_REG_DIN ( 8 ) : case SHA_REG_DIN ( 9 ) : case SHA_REG_DIN ( 10 ) : case SHA_REG_DIN ( 11 ) : case SHA_REG_DIN ( 12 ) : case SHA_REG_DIN ( 13 ) : case SHA_REG_DIN ( 14 ) : case SHA_REG_DIN ( 15 ) : break ; case SHA_REG_DIGEST ( 0 ) : case SHA_REG_DIGEST ( 1 ) : case SHA_REG_DIGEST ( 2 ) : case SHA_REG_DIGEST ( 3 ) : case SHA_REG_DIGEST ( 4 ) : case SHA_REG_DIGEST ( 5 ) : case SHA_REG_DIGEST ( 6 ) : case SHA_REG_DIGEST ( 7 ) : case SHA_REG_DIGEST ( 8 ) : case SHA_REG_DIGEST ( 9 ) : case SHA_REG_DIGEST ( 10 ) : case SHA_REG_DIGEST ( 11 ) : case SHA_REG_DIGEST ( 12 ) : case SHA_REG_DIGEST ( 13 ) : case SHA_REG_DIGEST ( 14 ) : case SHA_REG_DIGEST ( 15 ) : if ( wr ) { snprintf ( tmp , sz , "IDATAR[%u]" , 16u + ( ( offset - SHA_REG_DIGEST ( 0 ) ) >> 2 ) ) ; } else { snprintf ( tmp , sz , "ODATAR[%u]" , ( offset - SHA_REG_DIGEST ( 0 ) ) >> 2 ) ; } break ; case SHA_HW_VERSION : return "HWVER" ; default : snprintf ( tmp , sz , "0x%02x" , offset ) ; break ; } return tmp ; } 