static int loop_add ( int i ) { struct loop_device * lo ; struct gendisk * disk ; int err ; err = - ENOMEM ; lo = kzalloc ( sizeof ( * lo ) , GFP_KERNEL ) ; if ( ! lo ) { out } lo -> worker_tree = RB_ROOT ; INIT_LIST_HEAD ( & lo -> idle_worker_list ) ; timer_setup ( & lo -> timer , loop_free_idle_workers_timer , TIMER_DEFERRABLE ) ; lo -> lo_state = Lo_unbound ; err = mutex_lock_killable ( & loop_ctl_mutex ) ; if ( err ) { out_free_dev } if ( i >= 0 ) { err = idr_alloc ( & loop_index_idr , lo , i , i + 1 , GFP_KERNEL ) ; if ( err == - ENOSPC ) { err = - EEXIST ; } } else { err = idr_alloc ( & loop_index_idr , lo , 0 , 0 , GFP_KERNEL ) ; } mutex_unlock ( & loop_ctl_mutex ) ; i = err ; lo -> tag_set . ops = & loop_mq_ops ; lo -> tag_set . nr_hw_queues = 1 ; lo -> tag_set . queue_depth = hw_queue_depth ; lo -> tag_set . numa_node = NUMA_NO_NODE ; lo -> tag_set . cmd_size = sizeof ( loop_cmd ) ; lo -> tag_set . flags = BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_STACKING | BLK_MQ_F_NO_SCHED_BY_DEFAULT ; lo -> tag_set . driver_data = lo ; err = blk_mq_alloc_tag_set ( & lo -> tag_set ) ; if ( err ) { out_free_idr } disk = lo -> lo_disk = blk_mq_alloc_disk ( & lo -> tag_set , lo ) ; if ( IS_ERR ( disk ) ) { err = PTR_ERR ( disk ) ; out_cleanup_tags } lo -> lo_queue = lo -> lo_disk -> queue ; blk_queue_max_hw_sectors ( lo -> lo_queue , BLK_DEF_MAX_SECTORS ) ; blk_queue_flag_set ( QUEUE_FLAG_NOMERGES , lo -> lo_queue ) ; if ( ! part_shift ) { set_bit ( GD_SUPPRESS_PART_SCAN , & disk -> state ) ; } mutex_init ( & lo -> lo_mutex ) ; lo -> lo_number = i ; spin_lock_init ( & lo -> lo_lock ) ; spin_lock_init ( & lo -> lo_work_lock ) ; INIT_WORK ( & lo -> rootcg_work , loop_rootcg_workfn ) ; INIT_LIST_HEAD ( & lo -> rootcg_cmd_list ) ; disk -> major = LOOP_MAJOR ; disk -> first_minor = i << part_shift ; disk -> minors = 1 << part_shift ; disk -> fops = & lo_fops ; disk -> private_data = lo ; disk -> queue = lo -> lo_queue ; disk -> events = DISK_EVENT_MEDIA_CHANGE ; disk -> event_flags = DISK_EVENT_FLAG_UEVENT ; sprintf ( disk -> disk_name , "loop%d" , i ) ; err = add_disk ( disk ) ; if ( err ) { out_cleanup_disk } mutex_lock ( & loop_ctl_mutex ) ; lo -> idr_visible = true ; mutex_unlock ( & loop_ctl_mutex ) ; return i ; out_cleanup_disk put_disk ( disk ) ; out_cleanup_tags blk_mq_free_tag_set ( & lo -> tag_set ) ; out_free_idr mutex_lock ( & loop_ctl_mutex ) ; idr_remove ( & loop_index_idr , i ) ; mutex_unlock ( & loop_ctl_mutex ) ; out_free_dev kfree ( lo ) ; out return err ; } 