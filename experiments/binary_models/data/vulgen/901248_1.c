s32 rtw_xmitframe_coalesce ( struct adapter * padapter , struct sk_buff * pkt , struct xmit_frame * pxmitframe ) { struct pkt_file pktfile ; s32 frg_inx , frg_len , mpdu_len , llc_sz , mem_sz ; size_t addr ; u8 * pframe , * mem_start ; u8 hw_hdr_offset ; struct sta_info * psta ; struct xmit_priv * pxmitpriv = & padapter -> xmitpriv ; struct pkt_attrib * pattrib = & pxmitframe -> attrib ; u8 * pbuf_start ; s32 bmcst = IS_MCAST ( pattrib -> ra ) ; s32 res = _SUCCESS ; psta = rtw_get_stainfo ( & padapter -> stapriv , pattrib -> ra ) ; if ( psta == NULL ) { return _FAIL ; } if ( pxmitframe -> buf_addr == NULL ) { DBG_88E ( "==>%s buf_addr == NULL\n" , __func__ ) ; return _FAIL ; } pbuf_start = pxmitframe -> buf_addr ; hw_hdr_offset = TXDESC_SIZE + ( pxmitframe -> pkt_offset * PACKET_OFFSET_SZ ) ; mem_start = pbuf_start + hw_hdr_offset ; if ( rtw_make_wlanhdr ( padapter , mem_start , pattrib ) == _FAIL ) { RT_TRACE ( _module_rtl871x_xmit_c_ , _drv_err_ , ( "rtw_xmitframe_coalesce: rtw_make_wlanhdr fail; drop pkt\n" ) ) ; DBG_88E ( "rtw_xmitframe_coalesce: rtw_make_wlanhdr fail; drop pkt\n" ) ; res = _FAIL ; exit } _rtw_open_pktfile ( pkt , & pktfile ) ; _rtw_pktfile_read ( & pktfile , NULL , ETH_HLEN ) ; frg_inx = 0 ; frg_len = pxmitpriv -> frag_len - 4 ; while ( 1 ) { llc_sz = 0 ; mpdu_len = frg_len ; pframe = mem_start ; SetMFrag ( mem_start ) ; pframe += pattrib -> hdrlen ; mpdu_len -= pattrib -> hdrlen ; if ( pattrib -> iv_len ) { switch ( pattrib -> encrypt ) { case _WEP40_ : case _WEP104_ : WEP_IV ( pattrib -> iv , psta -> dot11txpn , pattrib -> key_idx ) ; break ; case _TKIP_ : if ( bmcst ) { TKIP_IV ( pattrib -> iv , psta -> dot11txpn , pattrib -> key_idx ) ; } else { TKIP_IV ( pattrib -> iv , psta -> dot11txpn , 0 ) ; } break ; case _AES_ : if ( bmcst ) { AES_IV ( pattrib -> iv , psta -> dot11txpn , pattrib -> key_idx ) ; } else { AES_IV ( pattrib -> iv , psta -> dot11txpn , 0 ) ; } break ; } memcpy ( pframe , pattrib -> iv , pattrib -> iv_len ) ; RT_TRACE ( _module_rtl871x_xmit_c_ , _drv_notice_ , ( "rtw_xmitframe_coalesce: keyid=%d pattrib->iv[3]=%.2x pframe=%.2x %.2x %.2x %.2x\n" , padapter -> securitypriv . dot11PrivacyKeyIndex , pattrib -> iv [ 3 ] , * pframe , * ( pframe + 1 ) , * ( pframe + 2 ) , * ( pframe + 3 ) ) ) ; pframe += pattrib -> iv_len ; mpdu_len -= pattrib -> iv_len ; } if ( ( pattrib -> icv_len > 0 ) && ( pattrib -> bswenc ) ) { mpdu_len -= pattrib -> icv_len ; } if ( bmcst ) { mem_sz = _rtw_pktfile_read ( & pktfile , pframe , pattrib -> pktlen ) ; } else { mem_sz = _rtw_pktfile_read ( & pktfile , pframe , mpdu_len ) ; } pframe += mem_sz ; if ( ( pattrib -> icv_len > 0 ) && ( pattrib -> bswenc ) ) { memcpy ( pframe , pattrib -> icv , pattrib -> icv_len ) ; pframe += pattrib -> icv_len ; } frg_inx ++ ; if ( bmcst || pktfile . pkt_len == 0 ) { pattrib -> nr_frags = frg_inx ; pattrib -> last_txcmdsz = pattrib -> hdrlen + pattrib -> iv_len + ( ( pattrib -> nr_frags == 1 ) ?llc_sz : 0 ) + ( ( pattrib -> bswenc ) ?pattrib -> icv_len : 0 ) + mem_sz ; ClearMFrag ( mem_start ) ; break ; } else { RT_TRACE ( _module_rtl871x_xmit_c_ , _drv_err_ , ( "%s: There're still something in packet!\n" , __func__ ) ) ; } addr = ( size_t ) ( pframe ) ; mem_start = ( unsigned char * ) round_up ( addr , 4 ) + hw_hdr_offset ; memcpy ( mem_start , pbuf_start + hw_hdr_offset , pattrib -> hdrlen ) ; } rtl88eu_mon_xmit_hook ( padapter -> pmondev , pxmitframe , frg_len ) ; if ( xmitframe_addmic ( padapter , pxmitframe ) == _FAIL ) { RT_TRACE ( _module_rtl871x_xmit_c_ , _drv_err_ , ( "xmitframe_addmic(padapter, pxmitframe) == _FAIL\n" ) ) ; DBG_88E ( "xmitframe_addmic(padapter, pxmitframe) == _FAIL\n" ) ; res = _FAIL ; exit } xmitframe_swencrypt ( padapter , pxmitframe ) ; if ( ! bmcst ) { update_attrib_vcs_info ( padapter , pxmitframe ) ; } else { pattrib -> vcs_mode = NONE_VCS ; } exit return res ; } 