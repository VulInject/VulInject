static l_int32 pixCorrelationBestShift ( PIX * pix1 , PIX * pix2 , NUMA * nasum1 , NUMA * namoment1 , l_int32 area2 , l_int32 ycent2 , l_int32 maxyshift , l_int32 * tab8 , l_int32 * pdelx , l_int32 * pdely , l_float32 * pscore , l_int32 debugflag ) static L_RCH * rchCreate ( l_int32 index , l_float32 score , char * text , l_int32 sample , l_int32 xloc , l_int32 yloc , l_int32 width ) static L_RCHA * rchaCreate ( ) static l_int32 transferRchToRcha ( L_RCH * rch , L_RCHA * rcha ) static PIX * recogPreSplittingFilter ( L_RECOG * recog , PIX * pixs , l_int32 minh , l_float32 minaf , l_int32 debug ) static l_int32 recogSplittingFilter ( L_RECOG * recog , PIX * pixs , l_int32 min , l_float32 minaf , l_int32 * premove , l_int32 debug ) static void l_showIndicatorSplitValues ( NUMA * na1 , NUMA * na2 , NUMA * na3 , NUMA * na4 , NUMA * na5 , NUMA * na6 ) l_ok recogIdentifyMultiple ( L_RECOG * recog , PIX * pixs , l_int32 minh , l_int32 skipsplit , BOXA * * pboxa , PIXA * * ppixa , PIX * * ppixdb , l_int32 debugsplit ) { l_int32 n ; BOXA * boxa ; PIX * pixb ; PIXA * pixa ; if ( ppixa ) { * ppixa = NULL ; } if ( ppixdb ) { * ppixdb = NULL ; } if ( ! recog ) { return ERROR_INT ( "recog not defined" , __func__ , 2 ) ; } if ( ! recog -> train_done ) { return ERROR_INT ( "training not finished" , __func__ , 2 ) ; } if ( ! pixs ) { return ERROR_INT ( "pixs not defined" , __func__ , 2 ) ; } if ( pixGetDepth ( pixs ) > 1 ) { pixb = pixConvertTo1 ( pixs , recog -> threshold ) ; } else { pixb = pixClone ( pixs ) ; } recogSplitIntoCharacters ( recog , pixb , minh , skipsplit , & boxa , & pixa , debugsplit ) ; pixDestroy ( & pixb ) ; if ( ! pixa || ( n = pixaGetCount ( pixa ) ) == 0 ) { pixaDestroy ( & pixa ) ; boxaDestroy ( & boxa ) ; L_WARNING ( "nothing found\n" , __func__ ) ; return 1 ; } recogIdentifyPixa ( recog , pixa , ppixdb ) ; if ( pboxa ) { * pboxa = boxa ; } else { boxaDestroy ( & boxa ) ; } if ( ppixa ) { * ppixa = pixa ; } else { pixaDestroy ( & pixa ) ; } return 0 ; } 