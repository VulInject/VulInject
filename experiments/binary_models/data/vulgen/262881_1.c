demarshal ( , , , , , , , ) { JsonObject * parent_object ; JsonNode * node ; if ( type != FLATPAK_JSON_PROP_TYPE_PARENT ) { parent_object = json_node_get_object ( parent_node ) ; node = json_object_get_member ( parent_object , name ) ; if ( node == NULL && ( flags & FLATPAK_JSON_PROP_FLAGS_MANDATORY ) != 0 ) { g_set_error ( error , G_IO_ERROR , G_IO_ERROR_FAILED , "No value for mandatory property %s" , name ) ; return FALSE ; } } else { node = parent_node ; } switch ( type ) { case FLATPAK_JSON_PROP_TYPE_STRING : if ( ! JSON_NODE_HOLDS_VALUE ( node ) || json_node_get_value_type ( node ) != G_TYPE_STRING ) { g_set_error ( error , G_IO_ERROR , G_IO_ERROR_FAILED , "Expecting string for property %s" , name ) ; return FALSE ; } * ( char * * ) dest = g_strdup ( json_node_get_string ( node ) ) ; break ; case FLATPAK_JSON_PROP_TYPE_INT64 : if ( ! JSON_NODE_HOLDS_VALUE ( node ) || json_node_get_value_type ( node ) != G_TYPE_INT64 ) { g_set_error ( error , G_IO_ERROR , G_IO_ERROR_FAILED , "Expecting int64 for property %s" , name ) ; return FALSE ; } * ( gint64 * ) dest = json_node_get_int ( node ) ; break ; case FLATPAK_JSON_PROP_TYPE_BOOL : if ( ! JSON_NODE_HOLDS_VALUE ( node ) || json_node_get_value_type ( node ) != G_TYPE_BOOLEAN ) { g_set_error ( error , G_IO_ERROR , G_IO_ERROR_FAILED , "Expecting bool for property %s" , name ) ; return FALSE ; } * ( gboolean * ) dest = json_node_get_boolean ( node ) ; break ; case FLATPAK_JSON_PROP_TYPE_STRV : if ( ! JSON_NODE_HOLDS_ARRAY ( node ) ) { g_set_error ( error , G_IO_ERROR , G_IO_ERROR_FAILED , "Expecting array for property %s" , name ) ; return FALSE ; } { JsonArray * array = json_node_get_array ( node ) ; guint i , array_len = json_array_get_length ( array ) ; g_autoptr ( ) str_array = g_ptr_array_sized_new ( array_len + 1 ) ; for ( i = 0 ; i < array_len ; i ++ ) { JsonNode * val = json_array_get_element ( array , i ) ; if ( JSON_NODE_TYPE ( val ) != JSON_NODE_VALUE ) { continue ; } if ( json_node_get_string ( val ) != NULL ) { g_ptr_array_add ( str_array , ( gpointer ) g_strdup ( json_node_get_string ( val ) ) ) ; } } g_ptr_array_add ( str_array , NULL ) ; * ( char * * * ) dest = ( char * * ) g_ptr_array_free ( g_steal_pointer ( & str_array ) , FALSE ) ; } break ; case FLATPAK_JSON_PROP_TYPE_PARENT : case FLATPAK_JSON_PROP_TYPE_STRUCT : if ( ! JSON_NODE_HOLDS_OBJECT ( node ) ) { g_set_error ( error , G_IO_ERROR , G_IO_ERROR_FAILED , "Expecting object for property %s" , name ) ; return FALSE ; } { FlatpakJsonProp * struct_props = type_data ; int i ; if ( ( struct_props -> flags & FLATPAK_JSON_PROP_FLAGS_STRICT ) != 0 ) { JsonObject * object = json_node_get_object ( node ) ; g_autoptr ( ) members = json_object_get_members ( object ) ; GList * l ; for ( l = members ; l != NULL ; l = l -> next ) { const char * member_name = l -> data ; for ( i = 0 ; struct_props [ i ] . name != NULL ; i ++ ) { if ( strcmp ( struct_props [ i ] . name , member_name ) == 0 ) { break ; } } if ( struct_props [ i ] . name == NULL ) { return flatpak_fail ( error , "Unknown property named %s" , member_name ) ; } } } for ( i = 0 ; struct_props [ i ] . name != NULL ; i ++ ) { if ( ! demarshal ( node , struct_props [ i ] . name , G_STRUCT_MEMBER_P ( dest , struct_props [ i ] . offset ) , struct_props [ i ] . type , struct_props [ i ] . type_data , struct_props [ i ] . type_data2 , struct_props [ i ] . flags , error ) ) { return FALSE ; } } } break ; case FLATPAK_JSON_PROP_TYPE_STRUCTV : if ( ! JSON_NODE_HOLDS_ARRAY ( node ) ) { g_set_error ( error , G_IO_ERROR , G_IO_ERROR_FAILED , "Expecting array for property %s" , name ) ; return FALSE ; } { JsonArray * array = json_node_get_array ( node ) ; guint array_len = json_array_get_length ( array ) ; FlatpakJsonProp * struct_props = type_data ; g_autoptr ( ) obj_array = g_ptr_array_sized_new ( array_len + 1 ) ; int i , j ; gboolean res = TRUE ; for ( j = 0 ; res && j < array_len ; j ++ ) { JsonNode * val = json_array_get_element ( array , j ) ; gpointer new_element ; if ( ! JSON_NODE_HOLDS_OBJECT ( val ) ) { g_set_error ( error , G_IO_ERROR , G_IO_ERROR_FAILED , "Expecting object elemen for property %s" , name ) ; res = FALSE ; break ; } new_element = g_malloc0 ( ( gsize ) type_data2 ) ; g_ptr_array_add ( obj_array , new_element ) ; for ( i = 0 ; struct_props [ i ] . name != NULL ; i ++ ) { if ( ! demarshal ( val , struct_props [ i ] . name , G_STRUCT_MEMBER_P ( new_element , struct_props [ i ] . offset ) , struct_props [ i ] . type , struct_props [ i ] . type_data , struct_props [ i ] . type_data2 , struct_props [ i ] . flags , error ) ) { res = FALSE ; break ; } } } g_ptr_array_add ( obj_array , NULL ) ; * ( gpointer * ) dest = ( gpointer * ) g_ptr_array_free ( g_steal_pointer ( & obj_array ) , FALSE ) ; return res ; } break ; case FLATPAK_JSON_PROP_TYPE_STRMAP : if ( ! JSON_NODE_HOLDS_OBJECT ( node ) ) { g_set_error ( error , G_IO_ERROR , G_IO_ERROR_FAILED , "Expecting object for property %s" , name ) ; return FALSE ; } { g_autoptr ( ) h = NULL ; JsonObject * object = json_node_get_object ( node ) ; g_autoptr ( ) members = NULL ; GList * l ; h = g_hash_table_new_full ( g_str_hash , g_str_equal , g_free , g_free ) ; members = json_object_get_members ( object ) ; for ( l = members ; l != NULL ; l = l -> next ) { const char * member_name = l -> data ; JsonNode * val ; const char * val_str ; val = json_object_get_member ( object , member_name ) ; val_str = json_node_get_string ( val ) ; if ( val_str == NULL ) { g_set_error ( error , G_IO_ERROR , G_IO_ERROR_FAILED , "Wrong type for string member %s" , member_name ) ; return FALSE ; } g_hash_table_insert ( h , g_strdup ( member_name ) , g_strdup ( val_str ) ) ; } * ( GHashTable * * ) dest = g_steal_pointer ( & h ) ; } break ; case FLATPAK_JSON_PROP_TYPE_BOOLMAP : if ( ! JSON_NODE_HOLDS_OBJECT ( node ) ) { g_set_error ( error , G_IO_ERROR , G_IO_ERROR_FAILED , "Expecting object for property %s" , name ) ; return FALSE ; } { JsonObject * object = json_node_get_object ( node ) ; g_autoptr ( ) res = g_ptr_array_new_with_free_func ( g_free ) ; g_autoptr ( ) members = NULL ; GList * l ; members = json_object_get_members ( object ) ; for ( l = members ; l != NULL ; l = l -> next ) { const char * member_name = l -> data ; g_ptr_array_add ( res , g_strdup ( member_name ) ) ; } g_ptr_array_add ( res , NULL ) ; * ( char * * * ) dest = ( char * * ) g_ptr_array_free ( g_steal_pointer ( & res ) , FALSE ) ; } break ; default : g_assert_not_reached ( ) ; } return TRUE ; } 