static void consensus_diff_worker_replyfn ( void * work_ ) { tor_assert ( in_main_thread ( ) ) ; tor_assert ( work_ ) ; consensus_diff_worker_job_t * job = work_ ; const char * lv_from_digest = consensus_cache_entry_get_value ( job -> diff_from , LABEL_SHA3_DIGEST_AS_SIGNED ) ; const char * lv_to_digest = consensus_cache_entry_get_value ( job -> diff_to , LABEL_SHA3_DIGEST_UNCOMPRESSED ) ; const char * lv_flavor = consensus_cache_entry_get_value ( job -> diff_to , LABEL_FLAVOR ) ; if ( BUG ( lv_from_digest == NULL ) ) { lv_from_digest = "???" ; } if ( BUG ( lv_to_digest == NULL ) ) { lv_to_digest = "???" ; } uint8_t from_sha3 [ DIGEST256_LEN ] ; uint8_t to_sha3 [ DIGEST256_LEN ] ; int flav = - 1 ; int cache = 1 ; if ( BUG ( cdm_entry_get_sha3_value ( from_sha3 , job -> diff_from , LABEL_SHA3_DIGEST_AS_SIGNED ) < 0 ) ) { cache = 0 ; } if ( BUG ( cdm_entry_get_sha3_value ( to_sha3 , job -> diff_to , LABEL_SHA3_DIGEST_UNCOMPRESSED ) < 0 ) ) { cache = 0 ; } if ( BUG ( lv_flavor == NULL ) ) { cache = 0 ; } if ( ( flav = networkstatus_parse_flavor_name ( lv_flavor ) ) < 0 ) { cache = 0 ; } consensus_cache_entry_handle_t * handles [ ARRAY_LENGTH ( compress_diffs_with ) ] ; char description [ 128 ] ; tor_snprintf ( description , sizeof ( description ) , "consensus diff from %s to %s" , lv_from_digest , lv_to_digest ) ; int status = store_multiple ( handles , n_diff_compression_methods ( ) , compress_diffs_with , job -> out , description ) ; if ( status != CDM_DIFF_PRESENT ) { log_warn ( LD_DIRSERV , "Worker was unable to compute consensus diff " "from %s to %s" , lv_from_digest , lv_to_digest ) ; status = CDM_DIFF_ERROR ; } unsigned u ; for ( u = 0 ; u < ARRAY_LENGTH ( handles ) ; ++ u ) { compress_method_t method = compress_diffs_with [ u ] ; if ( cache ) { consensus_cache_entry_handle_t * h = handles [ u ] ; int this_status = status ; if ( h == NULL ) { this_status = CDM_DIFF_ERROR ; } tor_assert_nonfatal ( h != NULL || this_status == CDM_DIFF_ERROR ) ; cdm_diff_ht_set_status ( flav , from_sha3 , to_sha3 , method , this_status , h ) ; } else { consensus_cache_entry_handle_free ( handles [ u ] ) ; } } consensus_diff_worker_job_free ( job ) ; } 