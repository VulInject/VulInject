int take_charge ( struct interface_info * ifi , int routefd , char * leasespath ) { const struct timespec max_timeout = { 9 0 } ; const struct timespec resend_intvl = { 3 0 } ; const struct timespec leasefile_intvl = { 0 3000000 } ; struct timespec now , resend , stop , timeout ; struct pollfd fds [ 1 ] ; struct rt_msghdr rtm ; int fd , nfds ; clock_gettime ( CLOCK_MONOTONIC , & now ) ; resend = now ; timespecadd ( & now , & max_timeout , & stop ) ; memset ( & rtm , 0 , sizeof ( rtm ) ) ; rtm . rtm_version = RTM_VERSION ; rtm . rtm_type = RTM_PROPOSAL ; rtm . rtm_msglen = sizeof ( rtm ) ; rtm . rtm_tableid = ifi -> rdomain ; rtm . rtm_index = ifi -> index ; rtm . rtm_priority = RTP_PROPOSAL_DHCLIENT ; rtm . rtm_addrs = 0 ; rtm . rtm_flags = RTF_UP | RTF_PROTO3 ; for ( fd = - 1 ; fd == - 1 && quit != TERMINATE ; ) { clock_gettime ( CLOCK_MONOTONIC , & now ) ; if ( timespeccmp ( & now , & stop , >= ) ) { fatalx ( "failed to take charge" ) ; } if ( ( ifi -> flags & IFI_IN_CHARGE ) == 0 ) { if ( timespeccmp ( & now , & resend , >= ) ) { timespecadd ( & resend , & resend_intvl , & resend ) ; rtm . rtm_seq = ifi -> xid = arc4random ( ) ; } timespecsub ( & resend , & now , & timeout ) ; } else { timeout = leasefile_intvl ; } fds [ 0 ] . fd = routefd ; fds [ 0 ] . events = POLLIN ; nfds = ppoll ( fds , 1 , & timeout , NULL ) ; if ( nfds == - 1 ) { if ( errno == EINTR ) { continue ; } fatal ( "ppoll(routefd)" ) ; } if ( ( fds [ 0 ] . revents & ( POLLERR | POLLHUP | POLLNVAL ) ) != 0 ) { fatalx ( "routefd: ERR|HUP|NVAL" ) ; } if ( nfds == 1 && ( fds [ 0 ] . revents & POLLIN ) == POLLIN ) { routefd_handler ( ifi , routefd ) ; } if ( quit != TERMINATE && ( ifi -> flags & IFI_IN_CHARGE ) == IFI_IN_CHARGE ) { fd = open ( leasespath , O_NONBLOCK | O_RDONLY | O_EXLOCK | O_CREAT | O_NOFOLLOW , 0640 ) ; if ( fd == - 1 && errno != EWOULDBLOCK ) { break ; } } } return fd ; } 