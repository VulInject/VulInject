static Tree primary ( void ) { Tree p ; assert ( t != '(' ) ; switch ( t ) { case ICON : case FCON : p -> u . v = tsym -> u . c . v ; break ; case SCON : if ( ischar ( tsym -> type -> type ) ) { tsym -> u . c . v . p = stringn ( tsym -> u . c . v . p , tsym -> type -> size ) ; } else { tsym -> u . c . v . p = memcpy ( allocate ( tsym -> type -> size , PERM ) , tsym -> u . c . v . p , tsym -> type -> size ) ; } tsym = constant ( tsym -> type , tsym -> u . c . v ) ; if ( tsym -> u . c . loc == NULL ) { tsym -> u . c . loc = genident ( STATIC , tsym -> type , GLOBAL ) ; } p = idtree ( tsym -> u . c . loc ) ; break ; case ID : if ( tsym == NULL ) { Symbol p = install ( token , & identifiers , level , FUNC ) ; p -> src = src ; if ( getchr ( ) == '(' ) { Symbol q = lookup ( token , externals ) ; p -> type = func ( inttype , NULL , 1 ) ; p -> sclass = EXTERN ; if ( Aflag >= 1 ) { warning ( "missing prototype\n" ) ; } if ( q && ! eqtype ( q -> type , p -> type , 1 ) ) { warning ( "implicit declaration of `%s' does not match previous declaration at %w\n" , q -> name , & q -> src ) ; } if ( q == NULL ) { q = install ( p -> name , & externals , GLOBAL , PERM ) ; q -> type = p -> type ; q -> sclass = EXTERN ; q -> src = src ; * IR -> defsymbol ( q ) ; } p -> u . alias = q ; } else { error ( "undeclared identifier `%s'\n" , p -> name ) ; p -> sclass = AUTO ; p -> type = inttype ; if ( p -> scope == GLOBAL ) { * IR -> defsymbol ( p ) ; } else { addlocal ( p ) ; } } t = gettok ( ) ; if ( xref ) { use ( p , src ) ; } return idtree ( p ) ; } if ( xref ) { use ( tsym , src ) ; } if ( tsym -> sclass == ENUM ) { p = consttree ( tsym -> u . value , inttype ) ; } else { if ( tsym -> sclass == TYPEDEF ) { error ( "illegal use of type name `%s'\n" , tsym -> name ) ; } p = idtree ( tsym ) ; } break ; case FIRSTARG : if ( level > PARAM && cfunc && cfunc -> u . f . callee [ 0 ] ) { p = idtree ( cfunc -> u . f . callee [ 0 ] ) ; } else { error ( "illegal use of `%k'\n" , FIRSTARG ) ; p = cnsttree ( inttype , 0L ) ; } break ; default : error ( "illegal expression\n" ) ; p = cnsttree ( inttype , 0L ) ; } t = gettok ( ) ; return p ; } 