int be_cmd_get_acpi_wol_cap ( struct be_adapter * adapter ) { struct be_mcc_wrb * wrb ; struct be_cmd_req_acpi_wol_magic_config_v1 * req ; int status = 0 ; struct be_dma_mem cmd ; if ( ! be_cmd_allowed ( adapter , OPCODE_ETH_ACPI_WOL_MAGIC_CONFIG , CMD_SUBSYSTEM_ETH ) ) { return - EPERM ; } if ( be_is_wol_excluded ( adapter ) ) { return status ; } memset ( & cmd , 0 , sizeof ( be_dma_mem ) ) ; cmd . size = sizeof ( be_cmd_resp_acpi_wol_magic_config_v1 ) ; cmd . va = dma_zalloc_coherent ( & adapter -> pdev -> dev , cmd . size , & cmd . dma , GFP_ATOMIC ) ; if ( ! cmd . va ) { dev_err ( & adapter -> pdev -> dev , "Memory allocation failure\n" ) ; status = - ENOMEM ; err } wrb = wrb_from_mbox ( adapter ) ; if ( ! wrb ) { status = - EBUSY ; err } req = cmd . va ; be_wrb_cmd_hdr_prepare ( & req -> hdr , CMD_SUBSYSTEM_ETH , OPCODE_ETH_ACPI_WOL_MAGIC_CONFIG , sizeof ( * req ) , wrb , & cmd ) ; req -> hdr . version = 1 ; req -> query_options = BE_GET_WOL_CAP ; status = be_mbox_notify_wait ( adapter ) ; if ( ! status ) { struct be_cmd_resp_acpi_wol_magic_config_v1 * resp ; resp = ( be_cmd_resp_acpi_wol_magic_config_v1 * ) cmd . va ; adapter -> wol_cap = resp -> wol_settings ; if ( adapter -> wol_cap & BE_WOL_CAP && ! is_zero_ether_addr ( resp -> magic_mac ) ) { adapter -> wol_en = true ; } } err mutex_unlock ( & adapter -> mbox_lock ) ; if ( cmd . va ) { dma_free_coherent ( & adapter -> pdev -> dev , cmd . size , cmd . va , cmd . dma ) ; } return status ; } 