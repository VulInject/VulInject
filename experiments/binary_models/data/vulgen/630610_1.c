int xhci_ctrl_tx ( struct usb_device * udev , unsigned long pipe , struct devrequest * req , int length , void * buffer ) { int ret ; int start_cycle ; int num_trbs ; u32 field ; u32 length_field ; u64 buf_64 = 0 ; struct xhci_generic_trb * start_trb ; struct xhci_ctrl * ctrl = xhci_get_ctrl ( udev ) ; int slot_id = udev -> slot_id ; int ep_index ; u32 trb_fields [ 4 ] ; struct xhci_virt_device * virt_dev = ctrl -> devs [ slot_id ] ; struct xhci_ring * ep_ring ; union xhci_trb * event ; u32 remainder ; debug ( "req=%u (%#x), type=%u (%#x), value=%u (%#x), index=%u\n" , req -> request , req -> request , req -> requesttype , req -> requesttype , le16_to_cpu ( req -> value ) , le16_to_cpu ( req -> value ) , le16_to_cpu ( req -> index ) ) ; ep_index = usb_pipe_ep_index ( pipe ) ; ep_ring = virt_dev -> eps [ ep_index ] . ring ; if ( udev -> speed == USB_SPEED_FULL ) { ret = xhci_check_maxpacket ( udev ) ; if ( ret < 0 ) { return ret ; } } struct xhci_ep_ctx * ep_ctx = NULL ; ep_ctx = xhci_get_ep_ctx ( ctrl , virt_dev -> out_ctx , ep_index ) ; num_trbs = 2 ; if ( length > 0 ) { num_trbs ++ ; } ret = prepare_ring ( ctrl , ep_ring , le32_to_cpu ( ep_ctx -> ep_info ) & EP_STATE_MASK ) ; if ( ret < 0 ) { return ret ; } start_trb = & ep_ring -> enqueue -> generic ; start_cycle = ep_ring -> cycle_state ; debug ( "start_trb %p, start_cycle %d\n" , start_trb , start_cycle ) ; field = 0 ; field |= TRB_IDT | TRB_TYPE ( TRB_SETUP ) ; if ( start_cycle == 0 ) { field |= 0x1 ; } if ( ctrl -> hci_version >= 0x100 || ctrl -> quirks & XHCI_MTK_HOST ) { if ( length > 0 ) { if ( req -> requesttype & USB_DIR_IN ) { field |= TRB_TX_TYPE ( TRB_DATA_IN ) ; } else { field |= TRB_TX_TYPE ( TRB_DATA_OUT ) ; } } } debug ( "req->requesttype = %d, req->request = %d, req->value = %d, req->index = %d, req->length = %d\n" , req -> requesttype , req -> request , le16_to_cpu ( req -> value ) , le16_to_cpu ( req -> index ) , le16_to_cpu ( req -> length ) ) ; trb_fields [ 0 ] = req -> requesttype | req -> request << 8 | le16_to_cpu ( req -> value ) << 16 ; trb_fields [ 1 ] = le16_to_cpu ( req -> index ) | le16_to_cpu ( req -> length ) << 16 ; trb_fields [ 2 ] = ( TRB_LEN ( 8 ) | TRB_INTR_TARGET ( 0 ) ) ; trb_fields [ 3 ] = field ; queue_trb ( ctrl , ep_ring , true , trb_fields ) ; field = 0 ; if ( usb_pipein ( pipe ) ) { field = TRB_ISP | TRB_TYPE ( TRB_DATA ) ; } else { field = TRB_TYPE ( TRB_DATA ) ; } remainder = xhci_td_remainder ( ctrl , 0 , length , length , usb_maxpacket ( udev , pipe ) , true ) ; length_field = TRB_LEN ( length ) | TRB_TD_SIZE ( remainder ) | TRB_INTR_TARGET ( 0 ) ; debug ( "length_field = %d, length = %d," "xhci_td_remainder(length) = %d , TRB_INTR_TARGET(0) = %d\n" , length_field , TRB_LEN ( length ) , TRB_TD_SIZE ( remainder ) , 0 ) ; if ( length > 0 ) { if ( req -> requesttype & USB_DIR_IN ) { field |= TRB_DIR_IN ; } buf_64 = xhci_dma_map ( ctrl , buffer , length ) ; trb_fields [ 0 ] = lower_32_bits ( buf_64 ) ; trb_fields [ 1 ] = upper_32_bits ( buf_64 ) ; trb_fields [ 2 ] = length_field ; trb_fields [ 3 ] = field | ep_ring -> cycle_state ; xhci_flush_cache ( ( uintptr_t ) buffer , length ) ; queue_trb ( ctrl , ep_ring , true , trb_fields ) ; } field = 0 ; if ( length > 0 && req -> requesttype & USB_DIR_IN ) { field = 0 ; } else { field = TRB_DIR_IN ; } trb_fields [ 0 ] = 0 ; trb_fields [ 1 ] = 0 ; trb_fields [ 2 ] = TRB_INTR_TARGET ( 0 ) ; trb_fields [ 3 ] = field | TRB_IOC | TRB_TYPE ( TRB_STATUS ) | ep_ring -> cycle_state ; queue_trb ( ctrl , ep_ring , false , trb_fields ) ; giveback_first_trb ( udev , ep_index , start_cycle , start_trb ) ; event = xhci_wait_for_event ( ctrl , TRB_TRANSFER ) ; if ( ! event ) { abort } field = le32_to_cpu ( event -> trans_event . flags ) ; BUG_ON ( TRB_TO_SLOT_ID ( field ) != slot_id ) ; BUG_ON ( TRB_TO_EP_INDEX ( field ) != ep_index ) ; record_transfer_result ( udev , event , length ) ; xhci_acknowledge_event ( ctrl ) ; if ( udev -> status == USB_ST_STALLED ) { reset_ep ( udev , ep_index ) ; return - EPIPE ; } if ( length > 0 ) { xhci_inval_cache ( ( uintptr_t ) buffer , length ) ; xhci_dma_unmap ( ctrl , buf_64 , length ) ; } if ( GET_COMP_CODE ( le32_to_cpu ( event -> trans_event . transfer_len ) ) == COMP_SHORT_TX ) { event = xhci_wait_for_event ( ctrl , TRB_TRANSFER ) ; if ( ! event ) { abort } BUG_ON ( TRB_TO_SLOT_ID ( field ) != slot_id ) ; BUG_ON ( TRB_TO_EP_INDEX ( field ) != ep_index ) ; xhci_acknowledge_event ( ctrl ) ; } return ( udev -> status != USB_ST_NOT_PROC ) ?0 : - 1 ; abort debug ( "XHCI control transfer timed out, aborting...\n" ) ; abort_td ( udev , ep_index ) ; udev -> status = USB_ST_NAK_REC ; udev -> act_len = 0 ; return - ETIMEDOUT ; } 