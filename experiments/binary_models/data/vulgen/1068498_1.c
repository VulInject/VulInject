static int fxp_handle_opendir ( struct fxp_packet * fxp ) { unsigned char * buf , * ptr ; char * path , * vpath ; uint32_t buflen , bufsz ; int timeout_stalled ; void * dirh ; struct fxp_handle * fxh ; struct fxp_packet * resp ; cmd_rec * cmd , * cmd2 ; struct stat st ; path = sftp_msg_read_string ( fxp -> pool , & fxp -> payload , & fxp -> payload_sz ) ; if ( fxp_session -> client_version >= fxp_utf8_protocol_version ) { path = sftp_utf8_decode_str ( fxp -> pool , path ) ; } pr_scoreboard_entry_update ( session . pid , PR_SCORE_CMD , "%s" , "OPENDIR" , NULL , NULL ) ; pr_scoreboard_entry_update ( session . pid , PR_SCORE_CMD_ARG , "%s" , path , NULL , NULL ) ; pr_proctitle_set ( "%s - %s: OPENDIR %s" , session . user , session . proc_prefix , path ) ; pr_trace_msg ( trace_channel , 7 , "received request: OPENDIR %s" , path ) ; if ( strlen ( path ) == 0 ) { path = sftp_auth_get_default_dir ( ) ; ( void ) pr_log_writefile ( sftp_logfd , MOD_SFTP_VERSION , "empty path given in OPENDIR request, using '%s'" , path ) ; } cmd = fxp_cmd_alloc ( fxp -> pool , "OPENDIR" , path ) ; cmd -> cmd_class = CL_DIRS | CL_SFTP ; buflen = bufsz = FXP_RESPONSE_DATA_DEFAULT_SZ ; buf = ptr = palloc ( fxp -> pool , bufsz ) ; if ( pr_cmd_dispatch_phase ( cmd , PRE_CMD , 0 ) < 0 ) { uint32_t status_code = SSH2_FX_PERMISSION_DENIED ; ( void ) pr_log_writefile ( sftp_logfd , MOD_SFTP_VERSION , "OPENDIR of '%s' blocked by '%s' handler" , path , ( char * ) cmd -> argv [ 0 ] ) ; pr_trace_msg ( trace_channel , 8 , "sending response: STATUS %lu '%s'" , ( unsigned long ) status_code , fxp_strerror ( status_code ) ) ; fxp_status_write ( fxp -> pool , & buf , & buflen , fxp -> request_id , status_code , fxp_strerror ( status_code ) , NULL ) ; fxp_cmd_dispatch_err ( cmd ) ; resp = fxp_packet_create ( fxp -> pool , fxp -> channel_id ) ; resp -> payload = ptr ; resp -> payload_sz = ( bufsz - buflen ) ; return fxp_packet_write ( resp ) ; } path = cmd -> arg ; pr_fs_clear_cache2 ( path ) ; if ( pr_fsio_lstat ( path , & st ) == 0 ) { if ( S_ISLNK ( st . st_mode ) ) { char link_path [ PR_TUNABLE_PATH_MAX ] ; int len ; memset ( link_path , '\0' , sizeof ( link_path ) ) ; len = dir_readlink ( fxp -> pool , path , link_path , sizeof ( link_path ) - 1 , PR_DIR_READLINK_FL_HANDLE_REL_PATH ) ; if ( len > 0 ) { link_path [ len ] = '\0' ; path = pstrdup ( fxp -> pool , link_path ) ; } } } path = dir_best_path ( fxp -> pool , path ) ; if ( path == NULL ) { int xerrno = EACCES ; const char * reason ; uint32_t status_code ; ( void ) pr_log_writefile ( sftp_logfd , MOD_SFTP_VERSION , "OPENDIR request denied: unable to access path '%s'" , cmd -> arg ) ; status_code = fxp_errno2status ( xerrno , & reason ) ; pr_trace_msg ( trace_channel , 8 , "sending response: STATUS %lu '%s' " "('%s' [%d])" , ( unsigned long ) status_code , reason , strerror ( xerrno ) , xerrno ) ; fxp_status_write ( fxp -> pool , & buf , & buflen , fxp -> request_id , status_code , reason , NULL ) ; fxp_cmd_dispatch_err ( cmd ) ; resp = fxp_packet_create ( fxp -> pool , fxp -> channel_id ) ; resp -> payload = ptr ; resp -> payload_sz = ( bufsz - buflen ) ; return fxp_packet_write ( resp ) ; } if ( ! dir_check ( fxp -> pool , cmd , G_DIRS , path , NULL ) ) { uint32_t status_code = SSH2_FX_PERMISSION_DENIED ; ( void ) pr_log_writefile ( sftp_logfd , MOD_SFTP_VERSION , "OPENDIR of '%s' blocked by<Limit>configuration" , path ) ; pr_trace_msg ( trace_channel , 8 , "sending response: STATUS %lu '%s'" , ( unsigned long ) status_code , fxp_strerror ( status_code ) ) ; fxp_status_write ( fxp -> pool , & buf , & buflen , fxp -> request_id , status_code , fxp_strerror ( status_code ) , NULL ) ; fxp_cmd_dispatch_err ( cmd ) ; resp = fxp_packet_create ( fxp -> pool , fxp -> channel_id ) ; resp -> payload = ptr ; resp -> payload_sz = ( bufsz - buflen ) ; return fxp_packet_write ( resp ) ; } cmd2 = fxp_cmd_alloc ( fxp -> pool , C_MLSD , path ) ; cmd2 -> cmd_class = CL_DIRS ; cmd2 -> cmd_id = pr_cmd_get_id ( C_MLSD ) ; if ( pr_cmd_dispatch_phase ( cmd2 , PRE_CMD , 0 ) < 0 ) { int xerrno = errno ; const char * reason ; uint32_t status_code ; ( void ) pr_log_writefile ( sftp_logfd , MOD_SFTP_VERSION , "OPENDIR command for '%s' blocked by '%s' handler" , path , ( char * ) cmd2 -> argv [ 0 ] ) ; if ( xerrno != ENOENT && xerrno != EACCES && xerrno != EPERM && xerrno != EINVAL ) { xerrno = EACCES ; } status_code = fxp_errno2status ( xerrno , & reason ) ; pr_trace_msg ( trace_channel , 8 , "sending response: STATUS %lu '%s' " "('%s' [%d])" , ( unsigned long ) status_code , reason , strerror ( xerrno ) , xerrno ) ; pr_response_add_err ( R_451 , "%s: %s" , cmd2 -> arg , strerror ( xerrno ) ) ; fxp_cmd_dispatch_err ( cmd2 ) ; fxp_status_write ( fxp -> pool , & buf , & buflen , fxp -> request_id , status_code , reason , NULL ) ; fxp_cmd_dispatch_err ( cmd ) ; resp = fxp_packet_create ( fxp -> pool , fxp -> channel_id ) ; resp -> payload = ptr ; resp -> payload_sz = ( bufsz - buflen ) ; return fxp_packet_write ( resp ) ; } path = cmd2 -> arg ; vpath = dir_canonical_vpath ( fxp -> pool , path ) ; if ( vpath == NULL ) { uint32_t status_code ; const char * reason ; int xerrno = errno ; ( void ) pr_log_writefile ( sftp_logfd , MOD_SFTP_VERSION , "error resolving '%s': %s" , path , strerror ( xerrno ) ) ; status_code = fxp_errno2status ( xerrno , & reason ) ; pr_trace_msg ( trace_channel , 8 , "sending response: STATUS %lu '%s' " "('%s' [%d])" , ( unsigned long ) status_code , reason , xerrno != EOF ?strerror ( xerrno ) : "End of file" , xerrno ) ; pr_response_add_err ( R_451 , "%s: %s" , cmd2 -> arg , strerror ( xerrno ) ) ; fxp_cmd_dispatch_err ( cmd2 ) ; fxp_status_write ( fxp -> pool , & buf , & buflen , fxp -> request_id , status_code , reason , NULL ) ; fxp_cmd_dispatch_err ( cmd ) ; resp = fxp_packet_create ( fxp -> pool , fxp -> channel_id ) ; resp -> payload = ptr ; resp -> payload_sz = ( bufsz - buflen ) ; return fxp_packet_write ( resp ) ; } path = vpath ; dirh = pr_fsio_opendir ( path ) ; if ( dirh == NULL ) { uint32_t status_code ; const char * reason ; int xerrno = errno ; ( void ) pr_trace_msg ( "fileperms" , 1 , "OPENDIR, user '%s' (UID %s, " "GID %s): error opening '%s': %s" , session . user , pr_uid2str ( fxp -> pool , session . uid ) , pr_gid2str ( fxp -> pool , session . gid ) , path , strerror ( xerrno ) ) ; ( void ) pr_log_writefile ( sftp_logfd , MOD_SFTP_VERSION , "error opening '%s': %s" , path , strerror ( xerrno ) ) ; status_code = fxp_errno2status ( xerrno , & reason ) ; pr_trace_msg ( trace_channel , 8 , "sending response: STATUS %lu '%s' " "('%s' [%d])" , ( unsigned long ) status_code , reason , xerrno != EOF ?strerror ( xerrno ) : "End of file" , xerrno ) ; pr_response_add_err ( R_451 , "%s: %s" , cmd2 -> arg , strerror ( xerrno ) ) ; fxp_cmd_dispatch_err ( cmd2 ) ; fxp_status_write ( fxp -> pool , & buf , & buflen , fxp -> request_id , status_code , reason , NULL ) ; fxp_cmd_dispatch_err ( cmd ) ; resp = fxp_packet_create ( fxp -> pool , fxp -> channel_id ) ; resp -> payload = ptr ; resp -> payload_sz = ( bufsz - buflen ) ; return fxp_packet_write ( resp ) ; } fxh = fxp_handle_create ( fxp_pool ) ; if ( fxh == NULL ) { uint32_t status_code ; const char * reason ; int xerrno = errno ; ( void ) pr_log_writefile ( sftp_logfd , MOD_SFTP_VERSION , "error creating SFTP handle for '%s': %s" , path , strerror ( xerrno ) ) ; status_code = fxp_errno2status ( xerrno , & reason ) ; pr_trace_msg ( trace_channel , 8 , "sending response: STATUS %lu '%s' " "('%s' [%d])" , ( unsigned long ) status_code , reason , xerrno != EOF ?strerror ( xerrno ) : "End of file" , xerrno ) ; pr_response_add_err ( R_451 , "%s: %s" , cmd2 -> arg , strerror ( xerrno ) ) ; fxp_cmd_dispatch_err ( cmd2 ) ; fxp_status_write ( fxp -> pool , & buf , & buflen , fxp -> request_id , status_code , reason , NULL ) ; fxp_cmd_dispatch_err ( cmd ) ; resp = fxp_packet_create ( fxp -> pool , fxp -> channel_id ) ; resp -> payload = ptr ; resp -> payload_sz = ( bufsz - buflen ) ; return fxp_packet_write ( resp ) ; } fxh -> dirh = dirh ; fxh -> dir = pstrdup ( fxh -> pool , path ) ; if ( fxp_handle_add ( fxp -> channel_id , fxh ) < 0 ) { uint32_t status_code ; const char * reason ; int xerrno = errno ; buf = ptr ; buflen = bufsz ; status_code = fxp_errno2status ( xerrno , & reason ) ; pr_trace_msg ( trace_channel , 8 , "sending response: STATUS %lu '%s' " "('%s' [%d])" , ( unsigned long ) status_code , reason , xerrno != EOF ?strerror ( xerrno ) : "End of file" , xerrno ) ; if ( pr_fsio_closedir ( dirh ) < 0 ) { ( void ) pr_log_writefile ( sftp_logfd , MOD_SFTP_VERSION , "error closing directory '%s': %s" , fxh -> dir , strerror ( xerrno ) ) ; } destroy_pool ( fxh -> pool ) ; pr_response_add_err ( R_451 , "%s: %s" , cmd2 -> arg , strerror ( xerrno ) ) ; fxp_cmd_dispatch_err ( cmd2 ) ; fxp_status_write ( fxp -> pool , & buf , & buflen , fxp -> request_id , status_code , reason , NULL ) ; fxp_cmd_dispatch_err ( cmd ) ; resp = fxp_packet_create ( fxp -> pool , fxp -> channel_id ) ; resp -> payload = ptr ; resp -> payload_sz = ( bufsz - buflen ) ; return fxp_packet_write ( resp ) ; } pr_trace_msg ( trace_channel , 8 , "sending response: HANDLE %s" , fxh -> name ) ; sftp_msg_write_byte ( & buf , & buflen , SFTP_SSH2_FXP_HANDLE ) ; sftp_msg_write_int ( & buf , & buflen , fxp -> request_id ) ; sftp_msg_write_string ( & buf , & buflen , fxh -> name ) ; if ( session . xfer . p == NULL ) { memset ( & session . xfer , 0 , sizeof ( session . xfer ) ) ; session . xfer . p = make_sub_pool ( fxp_pool ) ; pr_pool_tag ( session . xfer . p , "SFTP session transfer pool" ) ; memset ( & session . xfer . start_time , 0 , sizeof ( session . xfer . start_time ) ) ; gettimeofday ( & session . xfer . start_time , NULL ) ; session . xfer . direction = PR_NETIO_IO_WR ; } pr_timer_remove ( PR_TIMER_STALLED , ANY_MODULE ) ; timeout_stalled = pr_data_get_timeout ( PR_DATA_TIMEOUT_STALLED ) ; fxp_cmd_dispatch ( cmd ) ; resp = fxp_packet_create ( fxp -> pool , fxp -> channel_id ) ; resp -> payload = ptr ; resp -> payload_sz = ( bufsz - buflen ) ; return fxp_packet_write ( resp ) ; } 