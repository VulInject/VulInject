static int ext4_mb_init_backend ( struct super_block * sb ) { ext4_group_t ngroups = ext4_get_groups_count ( sb ) ; ext4_group_t i ; struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; int err ; struct ext4_group_desc * desc ; struct kmem_cache * cachep ; err = ext4_mb_alloc_groupinfo ( sb , ngroups ) ; if ( err ) { return err ; } sbi -> s_buddy_cache = new_inode ( sb ) ; if ( sbi -> s_buddy_cache == NULL ) { ext4_msg ( sb , KERN_ERR , "can't get new inode" ) ; err_freesgi } sbi -> s_buddy_cache -> i_ino = EXT4_BAD_INO ; EXT4_I ( sbi -> s_buddy_cache ) -> i_disksize = 0 ; for ( i = 0 ; i < ngroups ; i ++ ) { desc = ext4_get_group_desc ( sb , i , NULL ) ; if ( desc == NULL ) { ext4_msg ( sb , KERN_ERR , "can't read descriptor %u" , i ) ; err_freebuddy } if ( ext4_mb_add_groupinfo ( sb , i , desc ) != 0 ) { err_freebuddy } } return 0 ; err_freebuddy cachep = get_groupinfo_cache ( sb -> s_blocksize_bits ) ; while ( i -- > 0 ) { kfree ( 0 ) ; } i = sbi -> s_group_info_size ; while ( i -- > 0 ) { kfree ( sbi -> s_group_info [ i ] ) ; } iput ( sbi -> s_buddy_cache ) ; err_freesgi kvfree ( sbi -> s_group_info ) ; return - ENOMEM ; } 