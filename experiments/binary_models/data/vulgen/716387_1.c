static void gvt_cache_add ( struct intel_vgpu * vgpu , gfn_t gfn , unsigned long iova ) { gvt_dma * new , * itr ; struct rb_node * * link = & vgpu -> vdev . cache . rb_node , * parent = NULL ; new = kzalloc ( sizeof ( gvt_dma ) , GFP_KERNEL ) ; if ( ! new ) { return ; } new -> gfn = gfn ; new -> iova = iova ; mutex_lock ( & vgpu -> vdev . cache_lock ) ; while ( * link ) { parent = * link ; itr = rb_entry ( parent , gvt_dma , node ) ; if ( gfn == itr -> gfn ) { out } if ( gfn < itr -> gfn ) { link = & parent -> rb_left ; } else { link = & parent -> rb_right ; } } rb_link_node ( & new -> node , parent , link ) ; rb_insert_color ( & new -> node , & vgpu -> vdev . cache ) ; mutex_unlock ( & vgpu -> vdev . cache_lock ) ; return ; out mutex_unlock ( & vgpu -> vdev . cache_lock ) ; } 