static int snd_card_asihpi_playback_open ( struct snd_pcm_substream * substream ) { struct snd_pcm_runtime * runtime = substream -> runtime ; struct snd_card_asihpi_pcm * dpcm ; struct snd_card_asihpi * card = snd_pcm_substream_chip ( substream ) ; struct snd_pcm_hardware snd_card_asihpi_playback ; int err ; dpcm = kzalloc ( sizeof ( * dpcm ) , GFP_KERNEL ) ; err = hpi_outstream_open ( card -> hpi -> adapter -> index , substream -> number , & dpcm -> h_stream ) ; hpi_handle_error ( err ) ; if ( err ) { kfree ( dpcm ) ; } if ( err == HPI_ERROR_OBJ_ALREADY_OPEN ) { return - EBUSY ; } if ( err ) { return - EIO ; } setup_timer ( & dpcm -> timer , snd_card_asihpi_timer_function , ( unsigned long ) dpcm ) ; dpcm -> substream = substream ; runtime -> private_data = dpcm ; runtime -> private_free = snd_card_asihpi_runtime_free ; memset ( & snd_card_asihpi_playback , 0 , sizeof ( snd_card_asihpi_playback ) ) ; if ( ! card -> hpi -> interrupt_mode ) { snd_card_asihpi_playback . buffer_bytes_max = BUFFER_BYTES_MAX ; snd_card_asihpi_playback . period_bytes_min = PERIOD_BYTES_MIN ; snd_card_asihpi_playback . period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN ; snd_card_asihpi_playback . periods_min = PERIODS_MIN ; snd_card_asihpi_playback . periods_max = BUFFER_BYTES_MAX / PERIOD_BYTES_MIN ; } else { size_t pbmin = card -> update_interval_frames * card -> out_max_chans ; snd_card_asihpi_playback . buffer_bytes_max = BUFFER_BYTES_MAX ; snd_card_asihpi_playback . period_bytes_min = pbmin ; snd_card_asihpi_playback . period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN ; snd_card_asihpi_playback . periods_min = PERIODS_MIN ; snd_card_asihpi_playback . periods_max = BUFFER_BYTES_MAX / pbmin ; } snd_card_asihpi_playback . channels_max = card -> out_max_chans ; snd_card_asihpi_playback . channels_min = card -> out_min_chans ; snd_card_asihpi_playback . formats = snd_card_asihpi_playback_formats ( card , dpcm -> h_stream ) ; snd_card_asihpi_pcm_samplerates ( card , & snd_card_asihpi_playback ) ; snd_card_asihpi_playback . info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_DOUBLE | SNDRV_PCM_INFO_BATCH | SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID ; if ( card -> support_grouping ) { snd_card_asihpi_playback . info |= SNDRV_PCM_INFO_SYNC_START ; snd_pcm_set_sync ( substream ) ; } runtime -> hw = snd_card_asihpi_playback ; if ( card -> can_dma ) { err = snd_pcm_hw_constraint_pow2 ( runtime , 0 , SNDRV_PCM_HW_PARAM_BUFFER_BYTES ) ; } if ( err < 0 ) { return err ; } snd_pcm_hw_constraint_step ( runtime , 0 , SNDRV_PCM_HW_PARAM_PERIOD_SIZE , card -> update_interval_frames ) ; snd_pcm_hw_constraint_minmax ( runtime , SNDRV_PCM_HW_PARAM_PERIOD_SIZE , card -> update_interval_frames , UINT_MAX ) ; snd_printdd ( "playback open\n" ) ; return 0 ; } 