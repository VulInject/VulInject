static u32 octeon_droq_fast_process_packets ( struct octeon_device * oct , struct octeon_droq * droq , u32 pkts_to_process ) { struct octeon_droq_info * info ; union octeon_rh * rh ; u32 pkt , total_len = 0 , pkt_count ; pkt_count = pkts_to_process ; for ( pkt = 0 ; pkt < pkt_count ; pkt ++ ) { u32 pkt_len = 0 ; struct sk_buff * nicbuf = NULL ; struct octeon_skb_page_info * pg_info ; void * buf ; info = & droq -> info_list [ droq -> read_idx ] ; if ( ! info -> length ) { dev_err ( & oct -> pci_dev -> dev , "DROQ[%d] idx: %d len:0, pkt_cnt: %d\n" , droq -> q_no , droq -> read_idx , pkt_count ) ; print_hex_dump_bytes ( "" , DUMP_PREFIX_ADDRESS , ( u8 * ) info , OCT_DROQ_INFO_SIZE ) ; break ; } info -> length -= OCT_RH_SIZE ; rh = & info -> rh ; total_len += ( u32 ) info -> length ; if ( opcode_slow_path ( rh ) ) { u32 buf_cnt ; buf_cnt = octeon_droq_dispatch_pkt ( oct , droq , rh , info ) ; droq -> read_idx = incr_index ( droq -> read_idx , buf_cnt , droq -> max_count ) ; droq -> refill_count += buf_cnt ; } else { if ( info -> length <= droq -> buffer_size ) { pkt_len = ( u32 ) info -> length ; nicbuf = droq -> recv_buf_list [ droq -> read_idx ] . buffer ; pg_info = & droq -> recv_buf_list [ droq -> read_idx ] . pg_info ; if ( recv_buffer_recycle ( oct , pg_info ) ) { pg_info -> page = NULL ; } droq -> recv_buf_list [ droq -> read_idx ] . buffer = NULL ; droq -> read_idx = incr_index ( droq -> read_idx , 1 , droq -> max_count ) ; droq -> refill_count ++ ; } else { nicbuf = octeon_fast_packet_alloc ( ( u32 ) info -> length ) ; pkt_len = 0 ; while ( pkt_len < info -> length ) { int cpy_len , idx = droq -> read_idx ; cpy_len = ( ( pkt_len + droq -> buffer_size ) > info -> length ) ?( ( u32 ) info -> length - pkt_len ) : droq -> buffer_size ; if ( nicbuf ) { octeon_fast_packet_next ( droq , nicbuf , cpy_len , idx ) ; buf = droq -> recv_buf_list [ idx ] . buffer ; recv_buffer_fast_free ( buf ) ; droq -> recv_buf_list [ idx ] . buffer = NULL ; } else { droq -> stats . rx_alloc_failure ++ ; } pkt_len += cpy_len ; droq -> read_idx = incr_index ( droq -> read_idx , 1 , droq -> max_count ) ; droq -> refill_count ++ ; } } if ( nicbuf ) { if ( droq -> ops . fptr ) { droq -> ops . fptr ( oct -> octeon_id , nicbuf , pkt_len , rh , & droq -> napi , droq -> ops . farg ) ; } else { recv_buffer_free ( nicbuf ) ; } } } if ( droq -> refill_count >= droq -> refill_threshold ) { int desc_refilled = octeon_droq_refill ( oct , droq ) ; wmb ( ) ; writel ( ( desc_refilled ) , droq -> pkts_credit_reg ) ; mmiowb ( ) ; } } droq -> stats . pkts_received += pkt ; droq -> stats . bytes_received += total_len ; if ( ( droq -> ops . drop_on_max ) && ( pkts_to_process - pkt ) ) { octeon_droq_drop_packets ( oct , droq , ( pkts_to_process - pkt ) ) ; droq -> stats . dropped_toomany += ( pkts_to_process - pkt ) ; return pkts_to_process ; } return pkt ; } 