purge_dead_edges ( ) { edge e ; rtx insn = BB_END ( bb ) , note ; bool purged = false ; bool found ; edge_iterator ei ; if ( NONJUMP_INSN_P ( insn ) && ( note = find_reg_note ( insn , REG_EH_REGION , NULL ) ) ) { rtx eqnote ; } for ( ei = ei_start ( bb -> succs ) ; ( e = ei_safe_edge ( ei ) ) ; ) { if ( e -> flags & EDGE_EH ) { if ( can_throw_internal ( BB_END ( bb ) ) && ( ! ( e -> flags & EDGE_ABNORMAL_CALL ) || CALL_P ( BB_END ( bb ) ) ) ) { ei_next ( & ei ) ; continue ; } } if ( e -> flags & EDGE_ABNORMAL_CALL ) { if ( CALL_P ( BB_END ( bb ) ) && ( ! ( note = find_reg_note ( insn , REG_EH_REGION , NULL ) ) || INTVAL ( XEXP ( note , 0 ) ) >= 0 ) ) { ei_next ( & ei ) ; continue ; } } else { ei_next ( & ei ) ; continue ; } remove_edge ( e ) ; bb -> flags |= BB_DIRTY ; purged = true ; } if ( JUMP_P ( insn ) ) { rtx note ; edge b , f ; edge_iterator ei ; if ( ! any_condjump_p ( insn ) && ! returnjump_p ( insn ) && ! simplejump_p ( insn ) ) { return purged ; } if ( simplejump_p ( insn ) ) { note = find_reg_note ( insn , REG_BR_PROB , NULL ) ; if ( note ) { remove_note ( insn , note ) ; } while ( ( note = find_reg_note ( insn , REG_BR_PRED , NULL ) ) ) { remove_note ( insn , note ) ; } } for ( ei = ei_start ( bb -> succs ) ; ( e = ei_safe_edge ( ei ) ) ; ) { e -> flags &= ~ EDGE_ABNORMAL ; if ( ( e -> flags & EDGE_FALLTHRU ) && any_condjump_p ( insn ) ) { ei_next ( & ei ) ; continue ; } if ( e -> dest != EXIT_BLOCK_PTR && BB_HEAD ( e -> dest ) == JUMP_LABEL ( insn ) ) { ei_next ( & ei ) ; continue ; } if ( e -> dest == EXIT_BLOCK_PTR && returnjump_p ( insn ) ) { ei_next ( & ei ) ; continue ; } if ( ( e -> flags & EDGE_EH ) && can_throw_internal ( insn ) ) { e -> flags |= EDGE_ABNORMAL ; ei_next ( & ei ) ; continue ; } bb -> flags |= BB_DIRTY ; purged = true ; remove_edge ( e ) ; } if ( EDGE_COUNT ( bb -> succs ) == 0 || ! purged ) { return purged ; } if ( dump_file ) { fprintf ( dump_file , "Purged edges from bb %i\n" , bb -> index ) ; } if ( ! optimize ) { return purged ; } if ( single_succ_p ( bb ) ) { single_succ_edge ( bb ) -> probability = REG_BR_PROB_BASE ; single_succ_edge ( bb ) -> count = bb -> count ; } else { note = find_reg_note ( insn , REG_BR_PROB , NULL ) ; if ( ! note ) { return purged ; } b = BRANCH_EDGE ( bb ) ; f = FALLTHRU_EDGE ( bb ) ; b -> probability = INTVAL ( XEXP ( note , 0 ) ) ; f -> probability = REG_BR_PROB_BASE - b -> probability ; b -> count = bb -> count * b -> probability / REG_BR_PROB_BASE ; f -> count = bb -> count * f -> probability / REG_BR_PROB_BASE ; } return purged ; } if ( CALL_P ( insn ) && SIBLING_CALL_P ( insn ) ) { gcc_assert ( single_succ_p ( bb ) ) ; gcc_assert ( single_succ_edge ( bb ) -> flags == ( EDGE_SIBCALL | EDGE_ABNORMAL ) ) ; return 0 ; } found = false ; FOR_EACH_EDGE ( , , ) if ( ! ( e -> flags & ( EDGE_COMPLEX | EDGE_FALLTHRU ) ) ) { found = true ; break ; } if ( ! found ) { return purged ; } for ( ei = ei_start ( bb -> succs ) ; ( e = ei_safe_edge ( ei ) ) ; ) { if ( ! ( e -> flags & ( EDGE_FALLTHRU | EDGE_FAKE ) ) ) { bb -> flags |= BB_DIRTY ; remove_edge ( e ) ; purged = true ; } else { ei_next ( & ei ) ; } } gcc_assert ( single_succ_p ( bb ) ) ; single_succ_edge ( bb ) -> probability = REG_BR_PROB_BASE ; single_succ_edge ( bb ) -> count = bb -> count ; if ( dump_file ) { fprintf ( dump_file , "Purged non-fallthru edges from bb %i\n" , bb -> index ) ; } return purged ; } 