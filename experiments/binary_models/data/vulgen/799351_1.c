static int ibmf_i_init_qp ( ibmf_ci_t * ibmf_cip , ibmf_qp_t * qpp ) { ibt_sqp_type_t qp_type ; ibt_qp_alloc_attr_t qp_attrs ; ibt_qp_hdl_t qp_handle ; ibt_qp_info_t qp_modify_attr ; ibt_status_t ibt_status ; int i , status ; IBMF_TRACE_3 ( IBMF_TNF_DEBUG , DPRINT_L4 , ibmf_i_init_qp_start , IBMF_TNF_TRACE , "" , "ibmf_i_init_qp() enter, cip = %p, " "port = %d, qp = %d\n" , tnf_opaque , ibmf_ci , ibmf_cip , tnf_int , port , qpp -> iq_port_num , tnf_int , num , qpp -> iq_qp_num ) ; _NOTE ( ) ASSERT ( MUTEX_HELD ( & ibmf_cip -> ci_mutex ) ) ; qpp -> iq_flags = IBMF_QP_FLAGS_INITING ; mutex_exit ( & ibmf_cip -> ci_mutex ) ; if ( qpp -> iq_qp_handle ) { ibt_status = ibt_free_qp ( qpp -> iq_qp_handle ) ; if ( ibt_status != IBT_SUCCESS ) { IBMF_TRACE_2 ( IBMF_TNF_NODEBUG , DPRINT_L1 , ibmf_i_init_qp_err , IBMF_TNF_ERROR , "" , "%s, status = %d\n" , tnf_string , msg , "ibt_free_qp returned error" , tnf_uint , ibt_status , ibt_status ) ; } qpp -> iq_qp_handle = NULL ; } ASSERT ( qpp -> iq_qp_num == 0 || qpp -> iq_qp_num == 1 ) ; if ( qpp -> iq_qp_num == 0 ) { qp_type = IBT_SMI_SQP ; } else { qp_type = IBT_GSI_SQP ; } qp_attrs . qp_scq_hdl = ibmf_cip -> ci_cq_handle ; qp_attrs . qp_rcq_hdl = ibmf_cip -> ci_cq_handle ; qp_attrs . qp_pd_hdl = ibmf_cip -> ci_pd ; qp_attrs . qp_sizes . cs_sq_sgl = 1 ; qp_attrs . qp_sizes . cs_rq_sgl = IBMF_MAX_RQ_WR_SGL_ELEMENTS ; qp_attrs . qp_sizes . cs_sq = ibmf_send_wqes_posted_per_qp ; qp_attrs . qp_sizes . cs_rq = ibmf_recv_wqes_posted_per_qp ; qp_attrs . qp_flags = IBT_ALL_SIGNALED ; qp_attrs . qp_alloc_flags = IBT_QP_NO_FLAGS ; ibt_status = ibt_alloc_special_qp ( ibmf_cip -> ci_ci_handle , qpp -> iq_port_num , qp_type , & qp_attrs , NULL , & qp_handle ) ; if ( ibt_status != IBT_SUCCESS ) { mutex_enter ( & ibmf_cip -> ci_mutex ) ; qpp -> iq_flags = IBMF_QP_FLAGS_INVALID ; cv_broadcast ( & ibmf_cip -> ci_qp_cv ) ; IBMF_TRACE_1 ( IBMF_TNF_NODEBUG , DPRINT_L1 , ibmf_i_init_qp_err , IBMF_TNF_ERROR , "" , "ibmf_i_init_qp() error status = %d\n" , tnf_uint , ibt_status , ibt_status ) ; IBMF_TRACE_0 ( IBMF_TNF_DEBUG , DPRINT_L4 , ibmf_i_init_qp_end , IBMF_TNF_TRACE , "" , "ibmf_i_init_qp() exit\n" ) ; return ( IBMF_TRANSPORT_FAILURE ) ; } qpp -> iq_qp_handle = qp_handle ; qp_modify_attr . qp_trans = IBT_UD_SRV ; qp_modify_attr . qp_flags = IBT_CEP_NO_FLAGS ; if ( ibmf_i_get_pkeyix ( ibmf_cip -> ci_ci_handle , IBMF_P_KEY_DEF_LIMITED , qpp -> iq_port_num , & qp_modify_attr . qp_transport . ud . ud_pkey_ix ) != IBMF_SUCCESS ) { ibt_status = ibt_free_qp ( qpp -> iq_qp_handle ) ; if ( ibt_status != IBT_SUCCESS ) { IBMF_TRACE_2 ( IBMF_TNF_NODEBUG , DPRINT_L1 , ibmf_i_init_qp_err , IBMF_TNF_ERROR , "" , "%s, status = %d\n" , tnf_string , msg , "ibt_free_qp returned error" , tnf_uint , ibt_status , ibt_status ) ; } mutex_enter ( & ibmf_cip -> ci_mutex ) ; qpp -> iq_flags = IBMF_QP_FLAGS_INVALID ; cv_broadcast ( & ibmf_cip -> ci_qp_cv ) ; IBMF_TRACE_0 ( IBMF_TNF_NODEBUG , DPRINT_L1 , ibmf_i_init_qp_err , IBMF_TNF_ERROR , "" , "ibmf_init_qp(): failed to get " "pkey index\n" ) ; IBMF_TRACE_0 ( IBMF_TNF_DEBUG , DPRINT_L4 , ibmf_i_init_qp_end , IBMF_TNF_TRACE , "" , "ibmf_i_init_qp() exit\n" ) ; return ( IBMF_FAILURE ) ; } qp_modify_attr . qp_transport . ud . ud_sq_psn = 0 ; qp_modify_attr . qp_transport . ud . ud_port = qpp -> iq_port_num ; qp_modify_attr . qp_transport . ud . ud_qkey = IBMF_MGMT_Q_KEY ; ibt_status = ibt_initialize_qp ( qp_handle , & qp_modify_attr ) ; if ( ibt_status != IBT_SUCCESS ) { ibt_status = ibt_free_qp ( qpp -> iq_qp_handle ) ; if ( ibt_status != IBT_SUCCESS ) { IBMF_TRACE_2 ( IBMF_TNF_NODEBUG , DPRINT_L1 , ibmf_i_init_qp_err , IBMF_TNF_ERROR , "" , "%s, status = %d\n" , tnf_string , msg , "ibt_free_qp returned error" , tnf_uint , ibt_status , ibt_status ) ; } mutex_enter ( & ibmf_cip -> ci_mutex ) ; qpp -> iq_flags = IBMF_QP_FLAGS_INVALID ; cv_broadcast ( & ibmf_cip -> ci_qp_cv ) ; IBMF_TRACE_1 ( IBMF_TNF_NODEBUG , DPRINT_L1 , ibmf_i_init_qp_err , IBMF_TNF_ERROR , "" , "ibmf_init_qp(): error status = %d\n" , tnf_uint , ibt_status , ibt_status ) ; IBMF_TRACE_0 ( IBMF_TNF_DEBUG , DPRINT_L4 , ibmf_i_init_qp_end , IBMF_TNF_TRACE , "" , "ibmf_i_init_qp() exit\n" ) ; return ( IBMF_TRANSPORT_FAILURE ) ; } for ( i = 0 ; i < ibmf_recv_wqes_per_port ; i ++ ) { status = ibmf_i_post_recv_buffer ( ibmf_cip , qpp , B_TRUE , IBMF_QP_HANDLE_DEFAULT ) ; } mutex_enter ( & ibmf_cip -> ci_mutex ) ; qpp -> iq_flags = IBMF_QP_FLAGS_INITED ; cv_broadcast ( & ibmf_cip -> ci_qp_cv ) ; IBMF_TRACE_0 ( IBMF_TNF_DEBUG , DPRINT_L4 , ibmf_i_init_qp_end , IBMF_TNF_TRACE , "" , "ibmf_i_init_qp() exit\n" ) ; return ( IBMF_SUCCESS ) ; } 