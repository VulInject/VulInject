static int bge_add_intrs ( bge_t * bgep , int intr_type ) { dev_info_t * dip = bgep -> devinfo ; int avail , actual , intr_size , count = 0 ; int i , flag , ret ; BGE_DEBUG ( ( "bge_add_intrs($%p, 0x%x)" , ( void * ) bgep , intr_type ) ) ; ret = ddi_intr_get_nintrs ( dip , intr_type , & count ) ; if ( ( ret != DDI_SUCCESS ) || ( count == 0 ) ) { bge_error ( bgep , "ddi_intr_get_nintrs() failure, ret: %d, " "count: %d" , ret , count ) ; return ( DDI_FAILURE ) ; } ret = ddi_intr_get_navail ( dip , intr_type , & avail ) ; if ( ( ret != DDI_SUCCESS ) || ( avail == 0 ) ) { bge_error ( bgep , "ddi_intr_get_navail() failure, " "ret: %d, avail: %d\n" , ret , avail ) ; return ( DDI_FAILURE ) ; } if ( avail < count ) { BGE_DEBUG ( ( "%s: nintrs() returned %d, navail returned %d" , bgep -> ifname , count , avail ) ) ; } if ( intr_type == DDI_INTR_TYPE_MSI ) { count = 1 ; flag = DDI_INTR_ALLOC_STRICT ; } else { flag = DDI_INTR_ALLOC_NORMAL ; } intr_size = count * sizeof ( ddi_intr_handle_t ) ; ret = ddi_intr_alloc ( dip , bgep -> htable , intr_type , 0 , count , & actual , flag ) ; if ( ( ret != DDI_SUCCESS ) || ( actual == 0 ) ) { bge_error ( bgep , "ddi_intr_alloc() failed %d\n" , ret ) ; kmem_free ( bgep -> htable , intr_size ) ; return ( DDI_FAILURE ) ; } if ( actual < count ) { BGE_DEBUG ( ( "%s: Requested: %d, Received: %d" , bgep -> ifname , count , actual ) ) ; } bgep -> intr_cnt = actual ; if ( ( ret = ddi_intr_get_pri ( bgep -> htable [ 0 ] , & bgep -> intr_pri ) ) != DDI_SUCCESS ) { bge_error ( bgep , "ddi_intr_get_pri() failed %d\n" , ret ) ; for ( i = 0 ; i < actual ; i ++ ) { ( void ) ddi_intr_free ( bgep -> htable [ i ] ) ; } kmem_free ( bgep -> htable , intr_size ) ; return ( DDI_FAILURE ) ; } for ( i = 0 ; i < actual ; i ++ ) { if ( ( ret = ddi_intr_add_handler ( bgep -> htable [ i ] , bge_intr , ( caddr_t ) bgep , ( caddr_t ) ( uintptr_t ) i ) ) != DDI_SUCCESS ) { bge_error ( bgep , "ddi_intr_add_handler() " "failed %d\n" , ret ) ; for ( i = 0 ; i < actual ; i ++ ) { ( void ) ddi_intr_free ( bgep -> htable [ i ] ) ; } kmem_free ( bgep -> htable , intr_size ) ; return ( DDI_FAILURE ) ; } } if ( ( ret = ddi_intr_get_cap ( bgep -> htable [ 0 ] , & bgep -> intr_cap ) ) != DDI_SUCCESS ) { bge_error ( bgep , "ddi_intr_get_cap() failed %d\n" , ret ) ; for ( i = 0 ; i < actual ; i ++ ) { ( void ) ddi_intr_remove_handler ( bgep -> htable [ i ] ) ; ( void ) ddi_intr_free ( bgep -> htable [ i ] ) ; } kmem_free ( bgep -> htable , intr_size ) ; return ( DDI_FAILURE ) ; } return ( DDI_SUCCESS ) ; } 