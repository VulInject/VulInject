jerry_snapshot_set_offsets ( , , ) { JERRY_ASSERT ( size > 0 ) ; { ecma_compiled_code_t * bytecode_p = ( ecma_compiled_code_t * ) buffer_p ; if ( CBC_IS_FUNCTION ( bytecode_p -> status_flags ) ) { ecma_value_t * literal_start_p ; uint32_t const_literal_end ; if ( bytecode_p -> status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS ) { literal_start_p = ( ecma_value_t * ) ( ( ( uint8_t * ) buffer_p ) + sizeof ( cbc_uint16_arguments_t ) ) ; cbc_uint16_arguments_t * args_p = ( cbc_uint16_arguments_t * ) buffer_p ; const_literal_end = ( uint32_t ) ( args_p -> const_literal_end - args_p -> register_end ) ; } else { literal_start_p = ( ecma_value_t * ) ( ( ( uint8_t * ) buffer_p ) + sizeof ( cbc_uint8_arguments_t ) ) ; cbc_uint8_arguments_t * args_p = ( cbc_uint8_arguments_t * ) buffer_p ; const_literal_end = ( uint32_t ) ( args_p -> const_literal_end - args_p -> register_end ) ; } for ( uint32_t i = 0 ; i < const_literal_end ; i ++ ) { if ( ecma_is_value_string ( literal_start_p [ i ] ) || ecma_is_value_bigint ( literal_start_p [ i ] ) || ecma_is_value_float_number ( literal_start_p [ i ] ) ) { lit_mem_to_snapshot_id_map_entry_t * current_p = lit_map_p ; while ( current_p -> literal_id != literal_start_p [ i ] ) { current_p ++ ; } literal_start_p [ i ] = current_p -> literal_offset ; } } uint8_t * byte_p = ( uint8_t * ) bytecode_p + ( ( ( size_t ) bytecode_p -> size ) << JMEM_ALIGNMENT_LOG ) ; literal_start_p = ecma_snapshot_resolve_serializable_values ( bytecode_p , byte_p ) ; while ( literal_start_p < ( ecma_value_t * ) byte_p ) { if ( * literal_start_p != ECMA_VALUE_EMPTY ) { JERRY_ASSERT ( ecma_is_value_string ( * literal_start_p ) ) ; lit_mem_to_snapshot_id_map_entry_t * current_p = lit_map_p ; while ( current_p -> literal_id != * literal_start_p ) { current_p ++ ; } * literal_start_p = current_p -> literal_offset ; } literal_start_p ++ ; } bytecode_p -> refs = 1 ; } JERRY_ASSERT ( ( code_size % sizeof ( uint32_t ) ) == 0 ) ; buffer_p += code_size / sizeof ( uint32_t ) ; size -= code_size ; } size > 0 ; } 