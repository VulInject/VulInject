static void ffa_mem_retrieve ( struct thread_smc_args * args , struct sp_session * caller_sp , struct ffa_rxtx * rxtx ) { int ret = FFA_OK ; size_t tx_len = 0 ; struct ffa_mem_transaction * retr_dsc = NULL ; struct ffa_mem_region * mem_region = NULL ; uint64_t va = 0 ; struct sp_mem * smem = NULL ; struct sp_mem_receiver * receiver = NULL ; uint32_t exceptions = 0 ; uint32_t address_offset = 0 ; size_t needed_size = 0 ; if ( ! check_rxtx ( rxtx ) || ! rxtx -> tx_is_mine ) { ret = FFA_DENIED ; err } tx_len = rxtx -> size ; retr_dsc = rxtx -> rx ; smem = sp_mem_get ( retr_dsc -> global_handle ) ; if ( ! smem ) { DMSG ( "Incorrect handle" ) ; ret = FFA_DENIED ; err } receiver = sp_mem_get_receiver ( caller_sp -> endpoint_id , smem ) ; address_offset = READ_ONCE ( retr_dsc -> mem_access_array [ 0 ] . region_offs ) ; if ( ADD_OVERFLOW ( address_offset , sizeof ( ffa_mem_region ) , & needed_size ) || needed_size > tx_len ) { err } if ( check_retrieve_request ( receiver , retr_dsc , smem , tx_len ) != TEE_SUCCESS ) { ret = FFA_INVALID_PARAMETERS ; err } exceptions = cpu_spin_lock_xsave ( & mem_ref_lock ) ; if ( receiver -> ref_count == UINT8_MAX ) { ret = FFA_DENIED ; cpu_spin_unlock_xrestore ( & mem_ref_lock , exceptions ) ; err } receiver -> ref_count ++ ; if ( receiver -> ref_count == 1 ) { TEE_Result ret_map = TEE_SUCCESS ; cpu_spin_unlock_xrestore ( & mem_ref_lock , exceptions ) ; mem_region = ( ffa_mem_region * ) ( ( vaddr_t ) retr_dsc + address_offset ) ; va = READ_ONCE ( mem_region -> address_range_array [ 0 ] . address ) ; ret_map = sp_map_shared ( caller_sp , receiver , smem , & va ) ; if ( ret_map ) { EMSG ( "Could not map memory region: %#" PRIx32 , ret_map ) ; exceptions = cpu_spin_lock_xsave ( & mem_ref_lock ) ; receiver -> ref_count -- ; cpu_spin_unlock_xrestore ( & mem_ref_lock , exceptions ) ; ret = FFA_DENIED ; err } } else { cpu_spin_unlock_xrestore ( & mem_ref_lock , exceptions ) ; } create_retrieve_response ( rxtx -> tx , receiver , smem , caller_sp ) ; args -> a0 = FFA_MEM_RETRIEVE_RESP ; args -> a1 = tx_len ; args -> a2 = tx_len ; rxtx -> tx_is_mine = false ; return ; err ffa_set_error ( args , ret ) ; } 