extern int dlg_h_id_start ; extern int dlg_h_id_step ; struct dlg_table * d_table = 0 ; dlg_ka_t * * dlg_ka_list_head = NULL ; dlg_ka_t * * dlg_ka_list_tail = NULL ; { ( _dlg ) -> ref += ( _cnt ) ; LM_DBG ( "ref dlg %p with %d ->%d\n" , ( _dlg ) , ( _cnt ) , ( _dlg ) -> ref ) ; } 0 ; { if ( ( _dlg ) -> ref <= 0 ) { LM_WARN ( "invalid unref'ing dlg %p with ref %d by %d\n" , ( _dlg ) , ( _dlg ) -> ref , ( _cnt ) ) ; break ; } ( _dlg ) -> ref -= ( _cnt ) ; LM_DBG ( "unref dlg %p with %d ->%d\n" , ( _dlg ) , ( _cnt ) , ( _dlg ) -> ref ) ; if ( ( _dlg ) -> ref < 0 ) { LM_CRIT ( "bogus ref %d with cnt %d for dlg %p [%u:%u] " "with clid '%.*s' and tags '%.*s' '%.*s'\n" , ( _dlg ) -> ref , _cnt , _dlg , ( _dlg ) -> h_entry , ( _dlg ) -> h_id , ( _dlg ) -> callid . len , ( _dlg ) -> callid . s , ( _dlg ) -> tag [ DLG_CALLER_LEG ] . len , ( _dlg ) -> tag [ DLG_CALLER_LEG ] . s , ( _dlg ) -> tag [ DLG_CALLEE_LEG ] . len , ( _dlg ) -> tag [ DLG_CALLEE_LEG ] . s ) ; } if ( ( _dlg ) -> ref <= 0 ) { unlink_unsafe_dlg ( _d_entry , _dlg ) ; LM_DBG ( "ref<=0 for dialog %p\n" , _dlg ) ; destroy_dlg ( _dlg ) ; } } while ( 0 ) { int dlg_ka_add ( dlg_cell_t * dlg ) { dlg_ka_t * dka ; if ( dlg_ka_interval <= 0 ) { return 0 ; } if ( ! ( dlg -> iflags & ( DLG_IFLAG_KA_SRC | DLG_IFLAG_KA_DST ) ) ) { return 0 ; } dka = ( dlg_ka_t * ) shm_malloc ( sizeof ( dlg_ka_t ) ) ; if ( dka == NULL ) { LM_ERR ( "no more shm mem\n" ) ; return - 1 ; } memset ( dka , 0 , sizeof ( dlg_ka_t ) ) ; dka -> katime = get_ticks ( ) + dlg_ka_interval ; dka -> iuid . h_entry = dlg -> h_entry ; dka -> iuid . h_id = dlg -> h_id ; dka -> iflags = dlg -> iflags ; lock_get ( dlg_ka_list_lock ) ; if ( * dlg_ka_list_tail != NULL ) { ( * dlg_ka_list_tail ) -> next = dka ; } if ( * dlg_ka_list_head == NULL ) { * dlg_ka_list_head = dka ; } * dlg_ka_list_tail = dka ; lock_release ( dlg_ka_list_lock ) ; LM_DBG ( "added dlg[%d,%d] to KA list\n" , dlg -> h_entry , dlg -> h_id ) ; return 0 ; } } 