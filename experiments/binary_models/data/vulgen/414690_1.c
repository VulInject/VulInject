void RB_RenderDrawSurfList ( drawSurf_t * drawSurfs , int numDrawSurfs ) { shader_t * shader , * oldShader ; int fogNum , oldFogNum ; int entityNum , oldEntityNum ; int dlighted , oldDlighted ; qboolean depthRange , oldDepthRange , isCrosshair , wasCrosshair ; int i ; drawSurf_t * drawSurf ; int oldSort ; double originalTime ; originalTime = backEnd . refdef . floatTime ; RB_BeginDrawingView ( ) ; oldEntityNum = - 1 ; backEnd . currentEntity = & tr . worldEntity ; oldShader = NULL ; oldFogNum = - 1 ; oldDepthRange = qfalse ; wasCrosshair = qfalse ; oldDlighted = qfalse ; oldSort = - 1 ; depthRange = qfalse ; backEnd . pc . c_surfaces += numDrawSurfs ; for ( i = 0 , drawSurf = drawSurfs ; i < numDrawSurfs ; i ++ , drawSurf ++ ) { if ( drawSurf -> sort == oldSort ) { rb_surfaceTable [ * drawSurf -> surface ] ( drawSurf -> surface ) ; continue ; } oldSort = drawSurf -> sort ; R_DecomposeSort ( drawSurf -> sort , & entityNum , & shader , & fogNum , & dlighted ) ; if ( shader != NULL && ( shader != oldShader || fogNum != oldFogNum || dlighted != oldDlighted || ( entityNum != oldEntityNum && ! shader -> entityMergable ) ) ) { if ( oldShader != NULL ) { RB_EndSurface ( ) ; } RB_BeginSurface ( shader , fogNum ) ; oldShader = shader ; oldFogNum = fogNum ; oldDlighted = dlighted ; } if ( entityNum != oldEntityNum ) { depthRange = isCrosshair = qfalse ; if ( entityNum != REFENTITYNUM_WORLD ) { backEnd . currentEntity = & backEnd . refdef . entities [ entityNum ] ; backEnd . refdef . floatTime = originalTime - ( double ) backEnd . currentEntity -> e . shaderTime ; tess . shaderTime = backEnd . refdef . floatTime - tess . shader -> timeOffset ; R_RotateForEntity ( backEnd . currentEntity , & backEnd . viewParms , & backEnd . or ) ; if ( backEnd . currentEntity -> needDlights ) { R_TransformDlights ( backEnd . refdef . num_dlights , backEnd . refdef . dlights , & backEnd . or ) ; } if ( backEnd . currentEntity -> e . renderfx & RF_DEPTHHACK ) { depthRange = qtrue ; if ( backEnd . currentEntity -> e . renderfx & RF_CROSSHAIR ) { isCrosshair = qtrue ; } } } else { backEnd . currentEntity = & tr . worldEntity ; backEnd . refdef . floatTime = originalTime ; backEnd . or = backEnd . viewParms . world ; tess . shaderTime = backEnd . refdef . floatTime - tess . shader -> timeOffset ; R_TransformDlights ( backEnd . refdef . num_dlights , backEnd . refdef . dlights , & backEnd . or ) ; } qglLoadMatrixf ( backEnd . or . modelMatrix ) ; if ( oldDepthRange != depthRange || wasCrosshair != isCrosshair ) { if ( depthRange ) { if ( backEnd . viewParms . stereoFrame != STEREO_CENTER ) { if ( isCrosshair ) { if ( oldDepthRange ) { qglMatrixMode ( GL_PROJECTION ) ; qglLoadMatrixf ( backEnd . viewParms . projectionMatrix ) ; qglMatrixMode ( GL_MODELVIEW ) ; } } else { viewParms_t temp = backEnd . viewParms ; R_SetupProjection ( & temp , r_znear -> value , qfalse ) ; qglMatrixMode ( GL_PROJECTION ) ; qglLoadMatrixf ( temp . projectionMatrix ) ; qglMatrixMode ( GL_MODELVIEW ) ; } } if ( ! oldDepthRange ) { qglDepthRange ( 0 , 0.3 ) ; } } else { if ( ! wasCrosshair && backEnd . viewParms . stereoFrame != STEREO_CENTER ) { qglMatrixMode ( GL_PROJECTION ) ; qglLoadMatrixf ( backEnd . viewParms . projectionMatrix ) ; qglMatrixMode ( GL_MODELVIEW ) ; } qglDepthRange ( 0 , 1 ) ; } oldDepthRange = depthRange ; wasCrosshair = isCrosshair ; } oldEntityNum = entityNum ; } rb_surfaceTable [ * drawSurf -> surface ] ( drawSurf -> surface ) ; } backEnd . refdef . floatTime = originalTime ; qglLoadMatrixf ( backEnd . viewParms . world . modelMatrix ) ; if ( depthRange ) { qglDepthRange ( 0 , 1 ) ; } if ( r_drawSun -> integer ) { RB_DrawSun ( 0.1 , tr . sunShader ) ; } RB_ShadowFinish ( ) ; RB_RenderFlares ( ) ; } 