static void iwk_recv_mgmt ( struct ieee80211com * ic , mblk_t * mp , struct ieee80211_node * in , int subtype , int rssi , uint32_t rstamp ) { iwk_sc_t * sc = ( iwk_sc_t * ) ic ; struct ieee80211_frame * wh ; uint8_t index1 , index2 ; int err ; sc -> sc_recv_mgmt ( ic , mp , in , subtype , rssi , rstamp ) ; mutex_enter ( & sc -> sc_glock ) ; switch ( subtype ) { case IEEE80211_FC0_SUBTYPE_BEACON : if ( sc -> sc_ibss . ibss_beacon . syncbeacon && in == ic -> ic_bss && ic -> ic_state == IEEE80211_S_RUN ) { if ( ieee80211_beacon_update ( ic , in , & sc -> sc_ibss . ibss_beacon . iwk_boff , sc -> sc_ibss . ibss_beacon . mp , 0 ) ) { bcopy ( sc -> sc_ibss . ibss_beacon . mp -> b_rptr , sc -> sc_ibss . ibss_beacon . beacon_cmd . bcon_frame , MBLKL ( sc -> sc_ibss . ibss_beacon . mp ) ) ; } err = iwk_cmd ( sc , REPLY_TX_BEACON , & sc -> sc_ibss . ibss_beacon . beacon_cmd , sc -> sc_ibss . ibss_beacon . beacon_cmd_len , 1 ) ; if ( err != IWK_SUCCESS ) { cmn_err ( CE_WARN , "iwk_recv_mgmt(): " "failed to TX beacon.\n" ) ; } sc -> sc_ibss . ibss_beacon . syncbeacon = 0 ; } if ( ic -> ic_opmode == IEEE80211_M_IBSS && ic -> ic_state == IEEE80211_S_RUN ) { wh = ( ieee80211_frame * ) mp -> b_rptr ; mutex_enter ( & sc -> sc_ibss . node_tb_lock ) ; for ( index1 = IWK_STA_ID ; index1 < IWK_STATION_COUNT ; index1 ++ ) { if ( sc -> sc_ibss . ibss_node_tb [ index1 ] . used && IEEE80211_ADDR_EQ ( sc -> sc_ibss . ibss_node_tb [ index1 ] . node . bssid , wh -> i_addr2 ) ) { break ; } } if ( index1 >= IWK_BROADCAST_ID ) { err = iwk_clean_add_node_ibss ( ic , wh -> i_addr2 , & index2 ) ; } mutex_exit ( & sc -> sc_ibss . node_tb_lock ) ; } break ; case IEEE80211_FC0_SUBTYPE_PROBE_RESP : break ; } mutex_exit ( & sc -> sc_glock ) ; } 