static int rvu_npa_report_show ( struct devlink_fmsg * fmsg , void * ctx , enum npa_af_rvu_health health_reporter ) { struct rvu_npa_event_ctx * npa_event_context ; unsigned int alloc_dis , free_dis ; u64 intr_val ; int err ; npa_event_context = ctx ; switch ( health_reporter ) { case NPA_AF_RVU_GEN : intr_val = npa_event_context -> npa_af_rvu_gen ; err = rvu_report_pair_start ( fmsg , "NPA_AF_GENERAL" ) ; if ( err ) { return err ; } err = devlink_fmsg_u64_pair_put ( fmsg , "\tNPA General Interrupt Reg " , npa_event_context -> npa_af_rvu_gen ) ; if ( err ) { return err ; } if ( intr_val & BIT_ULL ( 32 ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tUnmap PF Error" ) ; if ( err ) { return err ; } } if ( free_dis & BIT ( NPA_INPQ_NIX0_RX ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tNIX0: free disabled RX" ) ; if ( err ) { return err ; } } if ( free_dis & BIT ( NPA_INPQ_NIX0_TX ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tNIX0:free disabled TX" ) ; if ( err ) { return err ; } } if ( free_dis & BIT ( NPA_INPQ_NIX1_RX ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tNIX1: free disabled RX" ) ; if ( err ) { return err ; } } if ( free_dis & BIT ( NPA_INPQ_NIX1_TX ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tNIX1:free disabled TX" ) ; if ( err ) { return err ; } } if ( free_dis & BIT ( NPA_INPQ_SSO ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tFree Disabled for SSO" ) ; if ( err ) { return err ; } } if ( free_dis & BIT ( NPA_INPQ_TIM ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tFree Disabled for TIM" ) ; if ( err ) { return err ; } } if ( free_dis & BIT ( NPA_INPQ_DPI ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tFree Disabled for DPI" ) ; if ( err ) { return err ; } } if ( free_dis & BIT ( NPA_INPQ_AURA_OP ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tFree Disabled for AURA" ) ; if ( err ) { return err ; } } alloc_dis = FIELD_GET ( GENMASK ( 31 , 16 ) , intr_val ) ; if ( alloc_dis & BIT ( NPA_INPQ_NIX0_RX ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tNIX0: alloc disabled RX" ) ; if ( err ) { return err ; } } if ( alloc_dis & BIT ( NPA_INPQ_NIX0_TX ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tNIX0:alloc disabled TX" ) ; if ( err ) { return err ; } } if ( alloc_dis & BIT ( NPA_INPQ_NIX1_RX ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tNIX1: alloc disabled RX" ) ; if ( err ) { return err ; } } if ( alloc_dis & BIT ( NPA_INPQ_NIX1_TX ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tNIX1:alloc disabled TX" ) ; if ( err ) { return err ; } } if ( alloc_dis & BIT ( NPA_INPQ_SSO ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tAlloc Disabled for SSO" ) ; if ( err ) { return err ; } } if ( alloc_dis & BIT ( NPA_INPQ_TIM ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tAlloc Disabled for TIM" ) ; if ( err ) { return err ; } } if ( alloc_dis & BIT ( NPA_INPQ_DPI ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tAlloc Disabled for DPI" ) ; if ( err ) { return err ; } } if ( alloc_dis & BIT ( NPA_INPQ_AURA_OP ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tAlloc Disabled for AURA" ) ; if ( err ) { return err ; } } err = rvu_report_pair_end ( fmsg ) ; if ( err ) { return err ; } break ; case NPA_AF_RVU_ERR : err = rvu_report_pair_start ( fmsg , "NPA_AF_ERR" ) ; if ( err ) { return err ; } err = devlink_fmsg_u64_pair_put ( fmsg , "\tNPA Error Interrupt Reg " , npa_event_context -> npa_af_rvu_err ) ; if ( err ) { return err ; } if ( npa_event_context -> npa_af_rvu_err & BIT_ULL ( 14 ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tFault on NPA_AQ_INST_S read" ) ; if ( err ) { return err ; } } if ( npa_event_context -> npa_af_rvu_err & BIT_ULL ( 13 ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tFault on NPA_AQ_RES_S write" ) ; if ( err ) { return err ; } } if ( npa_event_context -> npa_af_rvu_err & BIT_ULL ( 12 ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tAQ Doorbell Error" ) ; if ( err ) { return err ; } } err = rvu_report_pair_end ( fmsg ) ; if ( err ) { return err ; } break ; case NPA_AF_RVU_RAS : err = rvu_report_pair_start ( fmsg , "NPA_AF_RVU_RAS" ) ; if ( err ) { return err ; } err = devlink_fmsg_u64_pair_put ( fmsg , "\tNPA RAS Interrupt Reg " , npa_event_context -> npa_af_rvu_ras ) ; if ( err ) { return err ; } if ( npa_event_context -> npa_af_rvu_ras & BIT_ULL ( 34 ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tPoison data on NPA_AQ_INST_S" ) ; if ( err ) { return err ; } } if ( npa_event_context -> npa_af_rvu_ras & BIT_ULL ( 33 ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tPoison data on NPA_AQ_RES_S" ) ; if ( err ) { return err ; } } if ( npa_event_context -> npa_af_rvu_ras & BIT_ULL ( 32 ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tPoison data on HW context" ) ; if ( err ) { return err ; } } err = rvu_report_pair_end ( fmsg ) ; if ( err ) { return err ; } break ; case NPA_AF_RVU_INTR : err = rvu_report_pair_start ( fmsg , "NPA_AF_RVU" ) ; if ( err ) { return err ; } err = devlink_fmsg_u64_pair_put ( fmsg , "\tNPA RVU Interrupt Reg " , npa_event_context -> npa_af_rvu_int ) ; if ( err ) { return err ; } if ( npa_event_context -> npa_af_rvu_int & BIT_ULL ( 0 ) ) { err = devlink_fmsg_string_put ( fmsg , "\n\tUnmap Slot Error" ) ; if ( err ) { return err ; } } return rvu_report_pair_end ( fmsg ) ; default : return - EINVAL ; } return 0 ; } 