int isci_task_abort_task ( struct sas_task * task ) { struct isci_host * ihost = dev_to_ihost ( task -> dev ) ; DECLARE_COMPLETION_ONSTACK ( aborted_io_completion ) ; struct isci_request * old_request = NULL ; struct isci_remote_device * idev = NULL ; struct isci_tmf tmf ; int ret = TMF_RESP_FUNC_FAILED ; unsigned long flags ; int target_done_already = 0 ; spin_lock_irqsave ( & ihost -> scic_lock , flags ) ; spin_lock ( & task -> task_state_lock ) ; old_request = task -> lldd_task ; if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) && ( task -> task_state_flags & SAS_TASK_AT_INITIATOR ) && old_request ) { idev = isci_get_device ( task -> dev -> lldd_dev ) ; target_done_already = test_bit ( IREQ_COMPLETE_IN_TARGET , & old_request -> flags ) ; } spin_unlock ( & task -> task_state_lock ) ; dev_warn ( & ihost -> pdev -> dev , "%s: dev = %p (%s%s), task = %p, old_request == %p\n" , __func__ , idev , ( dev_is_sata ( task -> dev ) ?"STP/SATA" : ( ( dev_is_expander ( task -> dev ) ) ?"SMP" : "SSP" ) ) , ( ( idev ) ?( ( test_bit ( IDEV_GONE , & idev -> flags ) ) ?" IDEV_GONE" : "" ) else "<NULL>" ) , task , old_request ) ; if ( ! idev || ! old_request ) { spin_lock_irqsave ( & task -> task_state_lock , flags ) ; task -> task_state_flags |= SAS_TASK_STATE_DONE ; task -> task_state_flags &= ~ ( SAS_TASK_AT_INITIATOR | SAS_TASK_STATE_PENDING ) ; spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; ret = TMF_RESP_FUNC_COMPLETE ; dev_warn ( & ihost -> pdev -> dev , "%s: abort task not needed for %p\n" , __func__ , task ) ; out } if ( isci_remote_device_suspend_terminate ( ihost , idev , old_request ) != SCI_SUCCESS ) { dev_warn ( & ihost -> pdev -> dev , "%s: isci_remote_device_reset_terminate(dev=%p, " "req=%p, task=%p) failed\n" , __func__ , idev , old_request , task ) ; ret = TMF_RESP_FUNC_FAILED ; out } spin_lock_irqsave ( & ihost -> scic_lock , flags ) ; if ( task -> task_proto == SAS_PROTOCOL_SMP || sas_protocol_ata ( task -> task_proto ) || target_done_already || test_bit ( IDEV_GONE , & idev -> flags ) ) { spin_unlock_irqrestore ( & ihost -> scic_lock , flags ) ; isci_remote_device_resume_from_abort ( ihost , idev ) ; dev_warn ( & ihost -> pdev -> dev , "%s: %s request" " or complete_in_target (%d), " "or IDEV_GONE (%d), thus no TMF\n" , __func__ , ( ( task -> task_proto == SAS_PROTOCOL_SMP ) ?"SMP" : ( sas_protocol_ata ( task -> task_proto ) ?"SATA/STP" : "<other>" ) ) , test_bit ( IREQ_COMPLETE_IN_TARGET , & old_request -> flags ) , test_bit ( IDEV_GONE , & idev -> flags ) ) ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ; task -> task_state_flags &= ~ ( SAS_TASK_AT_INITIATOR | SAS_TASK_STATE_PENDING ) ; task -> task_state_flags |= SAS_TASK_STATE_DONE ; spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; ret = TMF_RESP_FUNC_COMPLETE ; } else { isci_task_build_abort_task_tmf ( & tmf , isci_tmf_ssp_task_abort , old_request ) ; spin_unlock_irqrestore ( & ihost -> scic_lock , flags ) ; ret = isci_task_execute_tmf ( ihost , idev , & tmf , ISCI_ABORT_TASK_TIMEOUT_MS ) ; } out dev_warn ( & ihost -> pdev -> dev , "%s: Done; dev = %p, task = %p , old_request == %p\n" , __func__ , idev , task , old_request ) ; isci_put_device ( idev ) ; return ret ; } 