int get_ok_ack ( TIUSER * tiptr , int type , int fmode ) { int msgsz ; union T_primitives * pptr ; mblk_t * bp ; int error ; error = 0 ; bp = NULL ; if ( ( error = tli_recv ( tiptr , & bp , fmode ) ) != 0 ) { return ( error ) ; } if ( ( msgsz = ( int ) MBLKL ( bp ) ) < sizeof ( int ) ) { return ( EPROTO ) ; } pptr = ( void * ) bp -> b_rptr ; switch ( pptr -> type ) { case T_OK_ACK : if ( msgsz < TOKACKSZ || pptr -> ok_ack . CORRECT_prim != type ) { error = EPROTO ; } break ; case T_ERROR_ACK : if ( msgsz < TERRORACKSZ ) { error = EPROTO ; break ; } if ( pptr -> error_ack . TLI_error == TSYSERR ) { error = pptr -> error_ack . UNIX_error ; } else { error = t_tlitosyserr ( pptr -> error_ack . TLI_error ) ; } break ; default : error = EPROTO ; break ; } freemsg ( bp ) ; return ( error ) ; } 