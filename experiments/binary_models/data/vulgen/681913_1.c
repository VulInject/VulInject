struct ipa_power * ipa_power_init ( struct device * dev , const struct ipa_power_data * data ) { struct ipa_power * power ; struct clk * clk ; size_t size ; int ret ; clk = clk_get ( dev , "core" ) ; if ( IS_ERR ( clk ) ) { dev_err_probe ( dev , PTR_ERR ( clk ) , "error getting core clock\n" ) ; return ERR_CAST ( clk ) ; } ret = clk_set_rate ( clk , data -> core_clock_rate ) ; if ( ret ) { dev_err ( dev , "error %d setting core clock rate to %u\n" , ret , data -> core_clock_rate ) ; err_clk_put } size = struct_size ( power , interconnect , data -> interconnect_count ) ; power = kzalloc ( size , GFP_KERNEL ) ; if ( ! power ) { ret = - ENOMEM ; err_clk_put } power -> dev = dev ; power -> core = clk ; power -> interconnect_count = data -> interconnect_count ; ret = ipa_interconnect_init ( power , data -> interconnect_data ) ; if ( ret ) { err_kfree } ret = ipa_power_retention_init ( power ) ; if ( ret ) { err_interconnect_exit } pm_runtime_set_autosuspend_delay ( dev , IPA_AUTOSUSPEND_DELAY ) ; pm_runtime_use_autosuspend ( dev ) ; pm_runtime_enable ( dev ) ; return power ; err_interconnect_exit ipa_interconnect_exit ( power ) ; err_kfree kfree ( power ) ; err_clk_put clk_put ( clk ) ; return ERR_PTR ( ret ) ; } 