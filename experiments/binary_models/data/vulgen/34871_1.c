static void uvc_fixup_video_ctrl ( struct uvc_streaming * stream , struct uvc_streaming_control * ctrl ) { struct uvc_format * format = NULL ; struct uvc_frame * frame = NULL ; unsigned int i ; for ( i = 0 ; i < stream -> nformats ; ++ i ) { if ( stream -> format [ i ] . index == ctrl -> bFormatIndex ) { format = & stream -> format [ i ] ; break ; } } if ( format == NULL ) { return ; } for ( i = 0 ; i < format -> nframes ; ++ i ) { if ( format -> frame [ i ] . bFrameIndex == ctrl -> bFrameIndex ) { frame = & format -> frame [ i ] ; break ; } } if ( frame == NULL ) { return ; } if ( ! ( format -> flags & UVC_FMT_FLAG_COMPRESSED ) || ( ctrl -> dwMaxVideoFrameSize == 0 && stream -> dev -> uvc_version < 0x0110 ) ) { ctrl -> dwMaxVideoFrameSize = frame -> dwMaxVideoFrameBufferSize ; } if ( ( ctrl -> dwMaxPayloadTransferSize & 0xffff0000 ) == 0xffff0000 ) { ctrl -> dwMaxPayloadTransferSize &= ~ 0xffff0000 ; } if ( ! ( format -> flags & UVC_FMT_FLAG_COMPRESSED ) && stream -> dev -> quirks & UVC_QUIRK_FIX_BANDWIDTH && stream -> intf -> num_altsetting > 1 ) { u32 interval ; u32 bandwidth ; interval = ( ctrl -> dwFrameInterval > 100000 ) ?ctrl -> dwFrameInterval : frame -> dwFrameInterval [ 0 ] ; bandwidth = frame -> wWidth * frame -> wHeight / 8 * format -> bpp ; bandwidth *= 10000000 / interval + 1 ; bandwidth /= 1000 ; if ( stream -> dev -> udev -> speed == USB_SPEED_HIGH ) { bandwidth /= 8 ; } bandwidth += 12 ; ctrl -> dwMaxPayloadTransferSize = bandwidth ; } } 