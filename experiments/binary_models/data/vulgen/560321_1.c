void reg_service ( struct svc_req * rqstp , SVCXPRT * xprt ) { struct pmap reg ; struct pmaplist * pml , * prevpml , * fnd ; struct sockaddr_in * fromsin ; long ans = 0 , port ; void * t ; fromsin = svc_getcaller ( xprt ) ; if ( debugging ) { ( void ) fprintf ( stderr , "server: about to do a switch\n" ) ; } switch ( rqstp -> rq_proc ) { case PMAPPROC_NULL : break ; case PMAPPROC_SET : if ( xprt != ltcpxprt && xprt != ludpxprt ) { syslog ( LOG_WARNING , "non-local set attempt (might be from %s)" , inet_ntoa ( fromsin -> sin_addr ) ) ; svcerr_noproc ( xprt ) ; return ; } if ( ! svc_getargs ( xprt , xdr_pmap , ( caddr_t ) & reg ) ) { svcerr_decode ( xprt ) ; break ; } fnd = find_service ( reg . pm_prog , reg . pm_vers , reg . pm_prot ) ; if ( fnd && fnd -> pml_map . pm_vers == reg . pm_vers ) { if ( fnd -> pml_map . pm_port == reg . pm_port ) { ans = 1 ; } done } if ( debugging ) { printf ( "set: prog %lu vers %lu port %lu\n" , reg . pm_prog , reg . pm_vers , reg . pm_port ) ; } if ( reg . pm_port & ~ 0xffff ) { done } if ( ( reg . pm_port < IPPORT_RESERVED || reg . pm_port == NFS_PORT ) && htons ( fromsin -> sin_port ) >= IPPORT_RESERVED ) { syslog ( LOG_WARNING , "resvport set attempt by non-root" ) ; done } pml = malloc ( sizeof ( pmaplist ) ) ; if ( pml == NULL ) { syslog ( LOG_ERR , "out of memory" ) ; svcerr_systemerr ( xprt ) ; return ; } pml -> pml_map = reg ; pml -> pml_next = 0 ; if ( pmaplist == NULL ) { pmaplist = pml ; } else { for ( fnd = pmaplist ; fnd -> pml_next != 0 ; fnd = fnd -> pml_next ) { } fnd -> pml_next = pml ; } ans = 1 ; done if ( ( ! svc_sendreply ( xprt , xdr_long , ( caddr_t ) & ans ) ) && debugging ) { ( void ) fprintf ( stderr , "svc_sendreply\n" ) ; abort ( ) ; } break ; case PMAPPROC_UNSET : if ( xprt != ltcpxprt && xprt != ludpxprt ) { syslog ( LOG_WARNING , "non-local unset attempt (might be from %s)" , inet_ntoa ( fromsin -> sin_addr ) ) ; svcerr_noproc ( xprt ) ; return ; } if ( ! svc_getargs ( xprt , xdr_pmap , ( caddr_t ) & reg ) ) { svcerr_decode ( xprt ) ; break ; } for ( prevpml = NULL , pml = pmaplist ; pml != NULL ; ) { if ( ( pml -> pml_map . pm_prog != reg . pm_prog ) || ( pml -> pml_map . pm_vers != reg . pm_vers ) ) { prevpml = pml ; pml = pml -> pml_next ; continue ; } if ( ( pml -> pml_map . pm_port < IPPORT_RESERVED || pml -> pml_map . pm_port == NFS_PORT ) && htons ( fromsin -> sin_port ) >= IPPORT_RESERVED ) { syslog ( LOG_WARNING , "resvport unset attempt by non-root" ) ; break ; } ans = 1 ; t = pml ; pml = pml -> pml_next ; if ( prevpml == NULL ) { pmaplist = pml ; } else { prevpml -> pml_next = pml ; } free ( t ) ; } if ( ( ! svc_sendreply ( xprt , xdr_long , ( caddr_t ) & ans ) ) && debugging ) { fprintf ( stderr , "svc_sendreply\n" ) ; abort ( ) ; } break ; case PMAPPROC_GETPORT : if ( ! svc_getargs ( xprt , xdr_pmap , ( caddr_t ) & reg ) ) { svcerr_decode ( xprt ) ; break ; } fnd = find_service ( reg . pm_prog , reg . pm_vers , reg . pm_prot ) ; if ( fnd ) { port = fnd -> pml_map . pm_port ; } else { port = 0 ; } if ( ( ! svc_sendreply ( xprt , xdr_long , ( caddr_t ) & port ) ) && debugging ) { fprintf ( stderr , "svc_sendreply\n" ) ; abort ( ) ; } break ; case PMAPPROC_DUMP : if ( ! svc_getargs ( xprt , xdr_void , NULL ) ) { svcerr_decode ( xprt ) ; break ; } if ( ! svc_sendreply ( xprt , xdr_pmaplist , ( caddr_t ) & pmaplist ) && debugging ) { fprintf ( stderr , "svc_sendreply\n" ) ; abort ( ) ; } break ; case PMAPPROC_CALLIT : callit ( rqstp , xprt ) ; break ; default : svcerr_noproc ( xprt ) ; break ; } } 