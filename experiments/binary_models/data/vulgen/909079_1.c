int befs_btree_read ( struct super_block * sb , const befs_data_stream * ds , loff_t key_no , size_t bufsize , char * keybuf , size_t * keysize , befs_off_t * value ) { struct befs_btree_node * this_node ; befs_btree_super bt_super ; befs_off_t node_off ; int cur_key ; fs64 * valarray ; char * keystart ; u16 keylen ; int res ; uint key_sum = 0 ; befs_debug ( sb , "--->%s" , __func__ ) ; if ( befs_bt_read_super ( sb , ds , & bt_super ) != BEFS_OK ) { befs_error ( sb , "befs_btree_read() failed to read index superblock" ) ; error } this_node = kmalloc ( sizeof ( befs_btree_node ) , GFP_NOFS ) ; if ( this_node == NULL ) { befs_error ( sb , "befs_btree_read() failed to allocate %zu " "bytes of memory" , sizeof ( befs_btree_node ) ) ; error } node_off = bt_super . root_node_ptr ; this_node -> bh = NULL ; res = befs_btree_seekleaf ( sb , ds , & bt_super , this_node , & node_off ) ; if ( res == BEFS_BT_EMPTY ) { brelse ( this_node -> bh ) ; * value = 0 ; * keysize = 0 ; befs_debug ( sb , "<--- %s Tree is EMPTY" , __func__ ) ; return BEFS_BT_EMPTY ; } if ( res == BEFS_ERR ) { error_alloc } while ( key_sum + this_node -> head . all_key_count <= key_no ) { if ( this_node -> head . right == BEFS_BT_INVAL ) { * keysize = 0 ; * value = 0 ; befs_debug ( sb , "<--- %s END of keys at %llu" , __func__ , ( unsigned long long ) key_sum + this_node -> head . all_key_count ) ; brelse ( this_node -> bh ) ; kfree ( this_node ) ; return BEFS_BT_END ; } key_sum += this_node -> head . all_key_count ; node_off = this_node -> head . right ; if ( befs_bt_read_node ( sb , ds , this_node , node_off ) != BEFS_OK ) { befs_error ( sb , "%s failed to read node at %llu" , __func__ , ( unsigned long long ) node_off ) ; error_alloc } } cur_key = key_no - key_sum ; valarray = befs_bt_valarray ( this_node ) ; keystart = befs_bt_get_key ( sb , this_node , cur_key , & keylen ) ; befs_debug ( sb , "Read [%llu,%d]: keysize %d" , ( long long unsigned int ) node_off , ( int ) cur_key , ( int ) keylen ) ; if ( bufsize < keylen + 1 ) { befs_error ( sb , "%s keybuf too small (%zu) " "for key of size %d" , __func__ , bufsize , keylen ) ; brelse ( this_node -> bh ) ; error_alloc } strlcpy ( keybuf , keystart , keylen + 1 ) ; * value = fs64_to_cpu ( sb , valarray [ cur_key ] ) ; * keysize = keylen ; befs_debug ( sb , "Read [%llu,%d]: Key \"%.*s\", Value %llu" , node_off , cur_key , keylen , keybuf , * value ) ; brelse ( this_node -> bh ) ; kfree ( this_node ) ; befs_debug ( sb , "<--- %s" , __func__ ) ; return BEFS_OK ; error_alloc kfree ( this_node ) ; error * keysize = 0 ; * value = 0 ; befs_debug ( sb , "<--- %s ERROR" , __func__ ) ; return BEFS_ERR ; } 