static int xhttp_handler ( sip_msg_t * msg ) { int ret ; char * fake_msg ; int fake_msg_len ; regmatch_t pmatch ; char c ; ret = NONSIP_MSG_DROP ; if ( ! IS_HTTP ( msg ) ) { return NONSIP_MSG_PASS ; } if ( xhttp_url_skip != NULL || xhttp_url_match != NULL ) { c = msg -> first_line . u . request . uri . s [ msg -> first_line . u . request . uri . len ] ; msg -> first_line . u . request . uri . s [ msg -> first_line . u . request . uri . len ] = '\0' ; if ( xhttp_url_skip != NULL && regexec ( & xhttp_url_skip_regexp , msg -> first_line . u . request . uri . s , 1 , & pmatch , 0 ) == 0 ) { LM_DBG ( "URL matched skip re\n" ) ; msg -> first_line . u . request . uri . s [ msg -> first_line . u . request . uri . len ] = c ; return NONSIP_MSG_PASS ; } if ( xhttp_url_match != NULL && regexec ( & xhttp_url_match_regexp , msg -> first_line . u . request . uri . s , 1 , & pmatch , 0 ) != 0 ) { LM_DBG ( "URL not matched\n" ) ; msg -> first_line . u . request . uri . s [ msg -> first_line . u . request . uri . len ] = c ; return NONSIP_MSG_PASS ; } msg -> first_line . u . request . uri . s [ msg -> first_line . u . request . uri . len ] = c ; } if ( msg -> via1 == 0 ) { fake_msg = xhttp_to_sip ( msg , & fake_msg_len ) ; if ( fake_msg == 0 ) { LM_ERR ( "out of memory\n" ) ; ret = NONSIP_MSG_ERROR ; } else { DBG ( "new fake msg created (%d bytes):\n<%.*s>\n" , fake_msg_len , fake_msg_len , fake_msg ) ; if ( xhttp_process_request ( msg , fake_msg , fake_msg_len ) < 0 ) { ret = NONSIP_MSG_ERROR ; } pkg_free ( fake_msg ) ; } return ret ; } else { LM_DBG ( "http msg unchanged (%d bytes):\n<%.*s>\n" , msg -> len , msg -> len , msg -> buf ) ; return ret ; } } 