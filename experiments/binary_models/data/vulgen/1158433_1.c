int prestera_hw_flood_domain_ports_set ( struct prestera_flood_domain * domain ) { struct prestera_flood_domain_port * flood_domain_port ; struct prestera_msg_flood_domain_ports_set_req * req ; struct prestera_msg_flood_domain_port * ports ; struct prestera_switch * sw = domain -> sw ; struct prestera_port * port ; u32 ports_num = 0 ; int buf_size ; void * buff ; u16 lag_id ; int err ; list_for_each_entry ( , , ) ports_num ++ ; if ( ! ports_num ) { return - EINVAL ; } buf_size = sizeof ( * req ) + sizeof ( * ports ) * ports_num ; buff = kmalloc ( buf_size , GFP_KERNEL ) ; if ( ! buff ) { return - ENOMEM ; } req = buff ; ports = buff + sizeof ( * req ) ; req -> flood_domain_idx = __cpu_to_le32 ( domain -> idx ) ; req -> ports_num = __cpu_to_le32 ( ports_num ) ; list_for_each_entry ( , , ) { if ( netif_is_lag_master ( flood_domain_port -> dev ) ) { if ( prestera_lag_id ( sw , flood_domain_port -> dev , & lag_id ) ) { return - EINVAL ; } ports -> port_type = __cpu_to_le16 ( PRESTERA_HW_FLOOD_DOMAIN_PORT_TYPE_LAG ) ; ports -> lag_id = __cpu_to_le16 ( lag_id ) ; } else { port = prestera_port_dev_lower_find ( flood_domain_port -> dev ) ; ports -> port_type = __cpu_to_le16 ( PRESTERA_HW_FDB_ENTRY_TYPE_REG_PORT ) ; ports -> dev_num = __cpu_to_le32 ( port -> dev_id ) ; ports -> port_num = __cpu_to_le32 ( port -> hw_id ) ; } ports -> vid = __cpu_to_le16 ( flood_domain_port -> vid ) ; ports ++ ; } err = prestera_cmd ( sw , PRESTERA_CMD_TYPE_FLOOD_DOMAIN_PORTS_SET , & req -> cmd , buf_size ) ; kfree ( buff ) ; return err ; } 