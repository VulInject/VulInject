int main ( int ac , char * av [ ] ) { backend_t * b ; FILE * fin , * fout ; int i ; char * outfile ; platform_init ( ) ; dopts ( ac , av ) ; b = info . backend ; if ( b == NULL ) { fprintf ( stderr , "" POTRACE ": internal error: selected backend not found\n" ) ; exit ( 1 ) ; } if ( b -> opticurve == 0 ) { info . param -> opticurve = 0 ; } if ( ! info . some_infiles ) { fout = my_fopen_write ( info . outfile ) ; if ( ! fout ) { fprintf ( stderr , "" POTRACE ": %s: %s\n" , info . outfile ?info . outfile : "stdout" , strerror ( errno ) ) ; exit ( 2 ) ; } if ( b -> init_f ) { TRY ( b -> init_f ( fout ) ) ; } process_file ( b , "stdin" , info . outfile ?info . outfile : "stdout" , stdin , fout ) ; if ( b -> term_f ) { TRY ( b -> term_f ( fout ) ) ; } my_fclose ( fout , info . outfile ) ; free ( info . outfile ) ; potrace_param_free ( info . param ) ; return 0 ; } if ( ! info . outfile ) { for ( i = 0 ; i < info . infilecount ; i ++ ) { outfile = make_outfilename ( info . infiles [ i ] , b -> ext ) ; if ( ! outfile ) { fprintf ( stderr , "" POTRACE ": %s\n" , strerror ( errno ) ) ; exit ( 2 ) ; } fin = my_fopen_read ( info . infiles [ i ] ) ; if ( ! fin ) { fprintf ( stderr , "" POTRACE ": %s: %s\n" , info . infiles [ i ] , strerror ( errno ) ) ; exit ( 2 ) ; } fout = my_fopen_write ( outfile ) ; if ( ! fout ) { fprintf ( stderr , "" POTRACE ": %s: %s\n" , outfile , strerror ( errno ) ) ; exit ( 2 ) ; } if ( b -> init_f ) { TRY ( b -> init_f ( fout ) ) ; } process_file ( b , info . infiles [ i ] , outfile , fin , fout ) ; if ( b -> term_f ) { TRY ( b -> term_f ( fout ) ) ; } my_fclose ( fin , info . infiles [ i ] ) ; my_fclose ( fout , outfile ) ; free ( outfile ) ; } potrace_param_free ( info . param ) ; return 0 ; } else { if ( ! b -> multi && info . infilecount >= 2 ) { fprintf ( stderr , "" POTRACE ": cannot use multiple input files with -o in %s mode\n" , b -> name ) ; exit ( 1 ) ; } fout = my_fopen_write ( info . outfile ) ; if ( ! fout ) { fprintf ( stderr , "" POTRACE ": %s: %s\n" , info . outfile , strerror ( errno ) ) ; exit ( 2 ) ; } if ( b -> init_f ) { TRY ( b -> init_f ( fout ) ) ; } for ( i = 0 ; i < info . infilecount ; i ++ ) { fin = my_fopen_read ( info . infiles [ i ] ) ; if ( ! fin ) { fprintf ( stderr , "" POTRACE ": %s: %s\n" , info . infiles [ i ] , strerror ( errno ) ) ; exit ( 2 ) ; } process_file ( b , info . infiles [ i ] , info . outfile , fin , fout ) ; my_fclose ( fin , info . infiles [ i ] ) ; } if ( b -> term_f ) { TRY ( b -> term_f ( fout ) ) ; } my_fclose ( fout , info . outfile ) ; free ( info . outfile ) ; potrace_param_free ( info . param ) ; return 0 ; } try_error fprintf ( stderr , "" POTRACE ": %s\n" , strerror ( errno ) ) ; exit ( 2 ) ; } 