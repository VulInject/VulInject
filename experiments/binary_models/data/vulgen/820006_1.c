static void vcc_act_return_vcl ( struct vcc * tl ) { struct symbol * sym ; struct inifin * p ; char buf [ 1024 ] ; SkipToken ( tl , '(' ) ; ExpectErr ( tl , ID ) ; sym = VCC_SymbolGet ( tl , SYM_MAIN , SYM_VCL , SYMTAB_EXISTING , XREF_NONE ) ; ERRCHK ( tl ) ; AN ( sym ) ; if ( sym -> eval_priv == NULL ) { VSB_cat ( tl -> symtab , ",\n    {\n" ) ; VSB_cat ( tl -> symtab , "\t\"dir\": \"import\",\n" ) ; VSB_cat ( tl -> symtab , "\t\"type\": \"$VCL\",\n" ) ; VSB_printf ( tl -> symtab , "\t\"name\": \"%s\"\n" , sym -> name ) ; VSB_cat ( tl -> symtab , "   }" ) ; sym -> eval_priv = strdup ( buf ) ; AN ( sym -> eval_priv ) ; Fh ( tl , 0 , "static VCL_VCL %s;" , buf ) ; Fh ( tl , 0 , "\t\n" , sym -> name ) ; p = New_IniFin ( tl ) ; AN ( p ) ; VSB_printf ( p -> ini , "\t%s = VPI_vcl_get(ctx, \"%s\");" , buf , sym -> name ) ; VSB_printf ( p -> fin , "\tVPI_vcl_rel(ctx, %s);" , buf ) ; } Fb ( tl , 1 , "VPI_vcl_select(ctx, %s);\t\n" , ( const char * ) sym -> eval_priv , sym -> name ) ; SkipToken ( tl , ')' ) ; } 