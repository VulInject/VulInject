static jobject dtj_new_stack_record ( const caddr_t addr , const dtrace_recdesc_t * rec , dtj_java_consumer_t * jc ) { JNIEnv * jenv = jc -> dtjj_jenv ; dtrace_actkind_t act ; uint64_t * pc ; pid_t pid = - 1 ; int size ; int i ; jbyteArray raw = NULL ; jobject stack = NULL ; for ( i = rec -> dtrd_size - 1 ; ( i >= 0 ) && ! addr [ i ] ; -- i ) { } size = ( i + 1 ) ; raw = ( * jenv ) -> NewByteArray ( jenv , size ) ; ( * jenv ) -> SetByteArrayRegion ( jenv , raw , 0 , size , ( const jbyte * ) addr ) ; if ( ( * jenv ) -> ExceptionCheck ( jenv ) ) { WRAP_EXCEPTION ( jenv ) ; ( * jenv ) -> DeleteLocalRef ( jenv , raw ) ; return ( NULL ) ; } act = rec -> dtrd_action ; switch ( act ) { case DTRACEACT_STACK : stack = ( * jenv ) -> NewObject ( jenv , g_stack_jc , g_stackinit_jm , raw ) ; break ; case DTRACEACT_USTACK : case DTRACEACT_JSTACK : pc = ( uint64_t * ) ( uintptr_t ) addr ; pid = ( pid_t ) * pc ; stack = ( * jenv ) -> NewObject ( jenv , g_ustack_jc , g_ustackinit_jm , pid , raw ) ; break ; default : dtj_throw_illegal_argument ( jenv , "Expected stack action, got %d\n" , act ) ; } ( * jenv ) -> DeleteLocalRef ( jenv , raw ) ; if ( ( * jenv ) -> ExceptionCheck ( jenv ) ) { WRAP_EXCEPTION ( jenv ) ; return ( NULL ) ; } return ( stack ) ; } 