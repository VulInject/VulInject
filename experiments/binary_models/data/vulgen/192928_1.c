static irqreturn_t omap_gpio_irq_handler ( int irq , void * gpiobank ) { void __iomem * isr_reg = NULL ; u32 isr ; unsigned int bit ; struct gpio_bank * bank = gpiobank ; unsigned long wa_lock_flags ; unsigned long lock_flags ; isr_reg = bank -> base + bank -> regs -> irqstatus ; if ( WARN_ON ( ! isr_reg ) ) { exit } pm_runtime_get_sync ( bank -> chip . parent ) ; while ( 1 ) { u32 isr_saved , level_mask = 0 ; u32 enabled ; raw_spin_lock_irqsave ( & bank -> lock , lock_flags ) ; enabled = omap_get_gpio_irqbank_mask ( bank ) ; isr_saved = isr = readl_relaxed ( isr_reg ) & enabled ; if ( bank -> level_mask ) { level_mask = bank -> level_mask & enabled ; } omap_disable_gpio_irqbank ( bank , isr_saved & ~ level_mask ) ; omap_clear_gpio_irqbank ( bank , isr_saved & ~ level_mask ) ; omap_enable_gpio_irqbank ( bank , isr_saved & ~ level_mask ) ; raw_spin_unlock_irqrestore ( & bank -> lock , lock_flags ) ; while ( isr ) { bit = __ffs ( isr ) ; isr &= ~ ( BIT ( bit ) ) ; raw_spin_lock_irqsave ( & bank -> lock , lock_flags ) ; if ( bank -> toggle_mask & ( BIT ( bit ) ) ) { omap_toggle_gpio_edge_triggering ( bank , bit ) ; } raw_spin_unlock_irqrestore ( & bank -> lock , lock_flags ) ; raw_spin_lock_irqsave ( & bank -> wa_lock , wa_lock_flags ) ; generic_handle_irq ( irq_find_mapping ( bank -> chip . irqdomain , bit ) ) ; raw_spin_unlock_irqrestore ( & bank -> wa_lock , wa_lock_flags ) ; } } exit pm_runtime_put ( bank -> chip . parent ) ; return IRQ_HANDLED ; } 