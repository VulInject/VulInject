MagickExport Image * XDisplayImage ( Display * display , XResourceInfo * resource_info , char * * argv , int argc , Image * * image , size_t * state , ExceptionInfo * exception ) { const char * const CommandMenu [ ] { "File" "Edit" "View" "Transform" "Enhance" "Effects" "F/X" "Image Edit" "Miscellany" "Help" ( char * ) NULL } ; , * FileMenu [ ] { "Open..." "Next" "Former" "Select..." "Save..." "Print..." "Delete..." "New..." "Visual Directory..." "Quit" ( char * ) NULL } ; , * EditMenu [ ] { "Undo" "Redo" "Cut" "Copy" "Paste" ( char * ) NULL } ; , * ViewMenu [ ] { "Half Size" "Original Size" "Double Size" "Resize..." "Apply" "Refresh" "Restore" ( char * ) NULL } ; , * TransformMenu [ ] { "Crop" "Chop" "Flop" "Flip" "Rotate Right" "Rotate Left" "Rotate..." "Shear..." "Roll..." "Trim Edges" ( char * ) NULL } ; , * EnhanceMenu [ ] { "Hue..." "Saturation..." "Brightness..." "Gamma..." "Spiff" "Dull" "Contrast Stretch..." "Sigmoidal Contrast..." "Normalize" "Equalize" "Negate" "Grayscale" "Map..." "Quantize..." ( char * ) NULL } ; , * EffectsMenu [ ] { "Despeckle" "Emboss" "Reduce Noise" "Add Noise..." "Sharpen..." "Blur..." "Threshold..." "Edge Detect..." "Spread..." "Shade..." "Raise..." "Segment..." ( char * ) NULL } ; , * FXMenu [ ] { "Solarize..." "Sepia Tone..." "Swirl..." "Implode..." "Vignette..." "Wave..." "Oil Paint..." "Charcoal Draw..." ( char * ) NULL } ; , * ImageEditMenu [ ] { "Annotate..." "Draw..." "Color..." "Matte..." "Composite..." "Add Border..." "Add Frame..." "Comment..." "Launch..." "Region of Interest..." ( char * ) NULL } ; , * MiscellanyMenu [ ] { "Image Info" "Zoom Image" "Show Preview..." "Show Histogram" "Show Matte" "Background..." "Slide Show..." "Preferences..." ( char * ) NULL } ; , * HelpMenu [ ] { "Overview" "Browse Documentation" "About Display" ( char * ) NULL } ; , * ShortCutsMenu [ ] { "Next" "Former" "Open..." "Save..." "Print..." "Undo" "Restore" "Image Info" "Quit" ( char * ) NULL } ; , * VirtualMenu [ ] { "Image Info" "Print" "Next" "Quit" ( char * ) NULL } ; ; const char * const * Menus [ MagickMenus ] { FileMenu EditMenu ViewMenu TransformMenu EnhanceMenu EffectsMenu FXMenu ImageEditMenu MiscellanyMenu HelpMenu } ; ; static CommandType CommandMenus [ ] { NullCommand NullCommand NullCommand NullCommand NullCommand NullCommand NullCommand NullCommand NullCommand NullCommand } ; , FileCommands [ ] { OpenCommand NextCommand FormerCommand SelectCommand SaveCommand PrintCommand DeleteCommand NewCommand VisualDirectoryCommand QuitCommand } ; , EditCommands [ ] { UndoCommand RedoCommand CutCommand CopyCommand PasteCommand } ; , ViewCommands [ ] { HalfSizeCommand OriginalSizeCommand DoubleSizeCommand ResizeCommand ApplyCommand RefreshCommand RestoreCommand } ; , TransformCommands [ ] { CropCommand ChopCommand FlopCommand FlipCommand RotateRightCommand RotateLeftCommand RotateCommand ShearCommand RollCommand TrimCommand } ; , EnhanceCommands [ ] { HueCommand SaturationCommand BrightnessCommand GammaCommand SpiffCommand DullCommand ContrastStretchCommand SigmoidalContrastCommand NormalizeCommand EqualizeCommand NegateCommand GrayscaleCommand MapCommand QuantizeCommand } ; , EffectsCommands [ ] { DespeckleCommand EmbossCommand ReduceNoiseCommand AddNoiseCommand SharpenCommand BlurCommand ThresholdCommand EdgeDetectCommand SpreadCommand ShadeCommand RaiseCommand SegmentCommand } ; , FXCommands [ ] { SolarizeCommand SepiaToneCommand SwirlCommand ImplodeCommand VignetteCommand WaveCommand OilPaintCommand CharcoalDrawCommand } ; , ImageEditCommands [ ] { AnnotateCommand DrawCommand ColorCommand MatteCommand CompositeCommand AddBorderCommand AddFrameCommand CommentCommand LaunchCommand RegionOfInterestCommand } ; , MiscellanyCommands [ ] { InfoCommand ZoomCommand ShowPreviewCommand ShowHistogramCommand ShowMatteCommand BackgroundCommand SlideShowCommand PreferencesCommand } ; , HelpCommands [ ] { HelpCommand BrowseDocumentationCommand VersionCommand } ; , ShortCutsCommands [ ] { NextCommand FormerCommand OpenCommand SaveCommand PrintCommand UndoCommand RestoreCommand InfoCommand QuitCommand } ; , VirtualCommands [ ] { InfoCommand PrintCommand NextCommand QuitCommand } ; ; static CommandType * Commands [ MagickMenus ] { FileCommands EditCommands ViewCommands TransformCommands EnhanceCommands EffectsCommands FXCommands ImageEditCommands MiscellanyCommands HelpCommands } ; ; char command [ MagickPathExtent ] , * directory , geometry [ MagickPathExtent ] , resource_name [ MagickPathExtent ] ; CommandType command_type ; Image * display_image , * nexus ; int entry , id ; KeySym key_symbol ; MagickStatusType context_mask , status ; RectangleInfo geometry_info ; int i ; static char working_directory [ MagickPathExtent ] ; static XPoint vid_info ; static XWindowInfo * magick_windows [ MaxXWindows ] ; static unsigned int number_windows ; struct stat attributes ; time_t timer , timestamp , update_time ; unsigned int height , width ; size_t delay ; WarningHandler warning_handler ; Window root_window ; XClassHint * class_hints ; XEvent event ; XFontStruct * font_info ; XGCValues context_values ; XPixelInfo * icon_pixel , * pixel ; XResourceInfo * icon_resources ; XStandardColormap * icon_map , * map_info ; XVisualInfo * icon_visual , * visual_info ; XWindowChanges window_changes ; XWindows * windows ; XWMHints * manager_hints ; assert ( image != ( Image * * ) NULL ) ; assert ( ( * image ) -> signature == MagickCoreSignature ) ; if ( IsEventLogging ( ) != MagickFalse ) { ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , ( * image ) -> filename ) ; } display_image = ( * image ) ; warning_handler = ( WarningHandler ) NULL ; windows = XSetWindows ( ( XWindows * ) ~ 0 ) ; if ( windows != ( XWindows * ) NULL ) { int status ; if ( * working_directory == '\0' ) { ( void ) CopyMagickString ( working_directory , "." , MagickPathExtent ) ; } status = chdir ( working_directory ) ; if ( status == - 1 ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , FileOpenError , "UnableToOpenFile" , "%s" , working_directory ) ; } warning_handler = resource_info -> display_warnings ?SetErrorHandler ( XWarning ) : SetErrorHandler ( ( ErrorHandler ) NULL ) ; warning_handler = resource_info -> display_warnings ?SetWarningHandler ( XWarning ) : SetWarningHandler ( ( WarningHandler ) NULL ) ; } else { resource_info -> colors = display_image -> colors ; windows = XSetWindows ( XInitializeWindows ( display , resource_info ) ) ; if ( windows == ( XWindows * ) NULL ) { ThrowXWindowFatalException ( XServerFatalError , "UnableToCreateWindow" , ( * image ) -> filename ) ; } number_windows = 0 ; magick_windows [ number_windows ++ ] = ( & windows -> icon ) ; magick_windows [ number_windows ++ ] = ( & windows -> backdrop ) ; magick_windows [ number_windows ++ ] = ( & windows -> image ) ; magick_windows [ number_windows ++ ] = ( & windows -> info ) ; magick_windows [ number_windows ++ ] = ( & windows -> command ) ; magick_windows [ number_windows ++ ] = ( & windows -> widget ) ; magick_windows [ number_windows ++ ] = ( & windows -> popup ) ; magick_windows [ number_windows ++ ] = ( & windows -> magnify ) ; magick_windows [ number_windows ++ ] = ( & windows -> pan ) ; for ( i = 0 ; i < ( int ) number_windows ; i ++ ) { magick_windows [ i ] -> id = ( Window ) NULL ; } vid_info . x = 0 ; vid_info . y = 0 ; } if ( windows -> font_info != ( XFontStruct * ) NULL ) { ( void ) XFreeFont ( display , windows -> font_info ) ; } windows -> font_info = XBestFont ( display , resource_info , MagickFalse ) ; if ( windows -> font_info == ( XFontStruct * ) NULL ) { ThrowXWindowFatalException ( XServerFatalError , "UnableToLoadFont" , resource_info -> font ) ; } map_info = windows -> map_info ; icon_map = windows -> icon_map ; visual_info = windows -> visual_info ; icon_visual = windows -> icon_visual ; pixel = windows -> pixel_info ; icon_pixel = windows -> icon_pixel ; font_info = windows -> font_info ; icon_resources = windows -> icon_resources ; class_hints = windows -> class_hints ; manager_hints = windows -> manager_hints ; root_window = XRootWindow ( display , visual_info -> screen ) ; nexus = NewImageList ( ) ; if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Image: %s[%.20g] %.20gx%.20g " , display_image -> filename , ( double ) display_image -> scene , ( double ) display_image -> columns , ( double ) display_image -> rows ) ; if ( display_image -> colors != 0 ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "%.20gc " , ( double ) display_image -> colors ) ; } ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "%s" , display_image -> magick ) ; } XMakeStandardColormap ( display , visual_info , resource_info , display_image , map_info , pixel , exception ) ; display_image -> taint = MagickFalse ; windows -> context . id = ( Window ) NULL ; XGetWindowInfo ( display , visual_info , map_info , pixel , font_info , resource_info , & windows -> context ) ; ( void ) CloneString ( & class_hints -> res_name , resource_info -> client_name ) ; ( void ) CloneString ( & class_hints -> res_class , resource_info -> client_name ) ; class_hints -> res_class [ 0 ] = ( char ) LocaleToUppercase ( ( int ) class_hints -> res_class [ 0 ] ) ; manager_hints -> flags = InputHint | StateHint ; manager_hints -> input = MagickFalse ; manager_hints -> initial_state = WithdrawnState ; XMakeWindow ( display , root_window , argv , argc , class_hints , manager_hints , & windows -> context ) ; if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Window id: 0x%lx (context)" , windows -> context . id ) ; } context_values . background = pixel -> background_color . pixel ; context_values . font = font_info -> fid ; context_values . foreground = pixel -> foreground_color . pixel ; context_values . graphics_exposures = MagickFalse ; context_mask = ( MagickStatusType ) ( GCBackground | GCFont | GCForeground | GCGraphicsExposures ) ; if ( pixel -> annotate_context != ( GC ) NULL ) { ( void ) XFreeGC ( display , pixel -> annotate_context ) ; } pixel -> annotate_context = XCreateGC ( display , windows -> context . id , context_mask , & context_values ) ; if ( pixel -> annotate_context == ( GC ) NULL ) { ThrowXWindowFatalException ( XServerFatalError , "UnableToCreateGraphicContext" , display_image -> filename ) ; } context_values . background = pixel -> depth_color . pixel ; if ( pixel -> widget_context != ( GC ) NULL ) { ( void ) XFreeGC ( display , pixel -> widget_context ) ; } pixel -> widget_context = XCreateGC ( display , windows -> context . id , context_mask , & context_values ) ; if ( pixel -> widget_context == ( GC ) NULL ) { ThrowXWindowFatalException ( XServerFatalError , "UnableToCreateGraphicContext" , display_image -> filename ) ; } context_values . background = pixel -> foreground_color . pixel ; context_values . foreground = pixel -> background_color . pixel ; context_values . plane_mask = context_values . background ^ context_values . foreground ; if ( pixel -> highlight_context != ( GC ) NULL ) { ( void ) XFreeGC ( display , pixel -> highlight_context ) ; } pixel -> highlight_context = XCreateGC ( display , windows -> context . id , ( size_t ) ( context_mask | GCPlaneMask ) , & context_values ) ; if ( pixel -> highlight_context == ( GC ) NULL ) { ThrowXWindowFatalException ( XServerFatalError , "UnableToCreateGraphicContext" , display_image -> filename ) ; } ( void ) XDestroyWindow ( display , windows -> context . id ) ; XGetWindowInfo ( display , icon_visual , icon_map , icon_pixel , ( XFontStruct * ) NULL , icon_resources , & windows -> icon ) ; windows -> icon . geometry = resource_info -> icon_geometry ; XBestIconSize ( display , & windows -> icon , display_image ) ; windows -> icon . attributes . colormap = XDefaultColormap ( display , icon_visual -> screen ) ; windows -> icon . attributes . event_mask = ExposureMask | StructureNotifyMask ; manager_hints -> flags = InputHint | StateHint ; manager_hints -> input = MagickFalse ; manager_hints -> initial_state = IconicState ; XMakeWindow ( display , root_window , argv , argc , class_hints , manager_hints , & windows -> icon ) ; if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Window id: 0x%lx (icon)" , windows -> icon . id ) ; } if ( icon_pixel -> annotate_context != ( GC ) NULL ) { ( void ) XFreeGC ( display , icon_pixel -> annotate_context ) ; } context_values . background = icon_pixel -> background_color . pixel ; context_values . foreground = icon_pixel -> foreground_color . pixel ; icon_pixel -> annotate_context = XCreateGC ( display , windows -> icon . id , ( size_t ) ( GCBackground | GCForeground ) , & context_values ) ; if ( icon_pixel -> annotate_context == ( GC ) NULL ) { ThrowXWindowFatalException ( XServerFatalError , "UnableToCreateGraphicContext" , display_image -> filename ) ; } windows -> icon . annotate_context = icon_pixel -> annotate_context ; XGetWindowInfo ( display , visual_info , map_info , pixel , font_info , resource_info , & windows -> image ) ; windows -> image . shape = MagickTrue ; if ( resource_info -> use_shared_memory == MagickFalse ) { windows -> image . shared_memory = MagickFalse ; } if ( ( resource_info -> title != ( char * ) NULL ) && ! ( * state & MontageImageState ) ) { char * title ; title = InterpretImageProperties ( resource_info -> image_info , display_image , resource_info -> title , exception ) ; ( void ) CloneString ( & windows -> image . name , title ) ; ( void ) CloneString ( & windows -> image . icon_name , title ) ; title = DestroyString ( title ) ; } else { char filename [ MagickPathExtent ] , window_name [ MagickPathExtent ] ; GetPathComponent ( display_image -> magick_filename , TailPath , filename ) ; if ( display_image -> scene == 0 ) { ( void ) FormatLocaleString ( window_name , MagickPathExtent , "%s: %s" , MagickPackageName , filename ) ; } else { ( void ) FormatLocaleString ( window_name , MagickPathExtent , "%s: %s[scene: %.20g frames: %.20g]" , MagickPackageName , filename , ( double ) display_image -> scene , ( double ) GetImageListLength ( display_image ) ) ; } ( void ) CloneString ( & windows -> image . name , window_name ) ; ( void ) CloneString ( & windows -> image . icon_name , filename ) ; } if ( resource_info -> immutable ) { windows -> image . immutable = MagickTrue ; } windows -> image . use_pixmap = resource_info -> use_pixmap ; windows -> image . geometry = resource_info -> image_geometry ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , "%ux%u+0+0>!" , XDisplayWidth ( display , visual_info -> screen ) , XDisplayHeight ( display , visual_info -> screen ) ) ; geometry_info . width = display_image -> columns ; geometry_info . height = display_image -> rows ; geometry_info . x = 0 ; geometry_info . y = 0 ; ( void ) ParseMetaGeometry ( geometry , & geometry_info . x , & geometry_info . y , & geometry_info . width , & geometry_info . height ) ; windows -> image . width = ( unsigned int ) geometry_info . width ; windows -> image . height = ( unsigned int ) geometry_info . height ; windows -> image . attributes . event_mask = ButtonMotionMask | ButtonPressMask | ButtonReleaseMask | EnterWindowMask | ExposureMask | KeyPressMask | KeyReleaseMask | LeaveWindowMask | OwnerGrabButtonMask | PropertyChangeMask | StructureNotifyMask | SubstructureNotifyMask ; XGetWindowInfo ( display , visual_info , map_info , pixel , font_info , resource_info , & windows -> backdrop ) ; if ( ( resource_info -> backdrop ) || ( windows -> backdrop . id != ( Window ) NULL ) ) { windows -> backdrop . x = 0 ; windows -> backdrop . y = 0 ; ( void ) CloneString ( & windows -> backdrop . name , "Backdrop" ) ; windows -> backdrop . flags = ( size_t ) ( USSize | USPosition ) ; windows -> backdrop . width = ( unsigned int ) XDisplayWidth ( display , visual_info -> screen ) ; windows -> backdrop . height = ( unsigned int ) XDisplayHeight ( display , visual_info -> screen ) ; windows -> backdrop . border_width = 0 ; windows -> backdrop . immutable = MagickTrue ; windows -> backdrop . attributes . do_not_propagate_mask = ButtonPressMask | ButtonReleaseMask ; windows -> backdrop . attributes . event_mask = ButtonPressMask | KeyPressMask | StructureNotifyMask ; manager_hints -> flags = IconWindowHint | InputHint | StateHint ; manager_hints -> icon_window = windows -> icon . id ; manager_hints -> input = MagickTrue ; manager_hints -> initial_state = resource_info -> iconic ?IconicState : NormalState ; XMakeWindow ( display , root_window , argv , argc , class_hints , manager_hints , & windows -> backdrop ) ; if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Window id: 0x%lx (backdrop)" , windows -> backdrop . id ) ; } ( void ) XMapWindow ( display , windows -> backdrop . id ) ; ( void ) XClearWindow ( display , windows -> backdrop . id ) ; if ( windows -> image . id != ( Window ) NULL ) { ( void ) XDestroyWindow ( display , windows -> image . id ) ; windows -> image . id = ( Window ) NULL ; } windows -> image . flags |= USPosition ; windows -> image . x = ( XDisplayWidth ( display , visual_info -> screen ) / 2 ) - ( windows -> image . width / 2 ) ; windows -> image . y = ( XDisplayHeight ( display , visual_info -> screen ) / 2 ) - ( windows -> image . height / 2 ) ; } manager_hints -> flags = IconWindowHint | InputHint | StateHint ; manager_hints -> icon_window = windows -> icon . id ; manager_hints -> input = MagickTrue ; manager_hints -> initial_state = resource_info -> iconic ?IconicState : NormalState ; if ( windows -> group_leader . id != ( Window ) NULL ) { manager_hints -> flags |= WindowGroupHint ; manager_hints -> window_group = windows -> group_leader . id ; ( void ) XSelectInput ( display , windows -> group_leader . id , StructureNotifyMask ) ; if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Window id: 0x%lx (group leader)" , windows -> group_leader . id ) ; } } XMakeWindow ( display , ( Window ) ( resource_info -> backdrop ?windows -> backdrop . id : root_window ) , argv , argc , class_hints , manager_hints , & windows -> image ) ; ( void ) XChangeProperty ( display , windows -> image . id , windows -> im_protocols , XA_STRING , 8 , PropModeReplace , ( unsigned char * ) NULL , 0 ) ; if ( windows -> group_leader . id != ( Window ) NULL ) { ( void ) XSetTransientForHint ( display , windows -> image . id , windows -> group_leader . id ) ; } if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Window id: 0x%lx (image)" , windows -> image . id ) ; } XGetWindowInfo ( display , visual_info , map_info , pixel , font_info , resource_info , & windows -> info ) ; ( void ) CloneString ( & windows -> info . name , "Info" ) ; ( void ) CloneString ( & windows -> info . icon_name , "Info" ) ; windows -> info . border_width = 1 ; windows -> info . x = 2 ; windows -> info . y = 2 ; windows -> info . flags |= PPosition ; windows -> info . attributes . win_gravity = UnmapGravity ; windows -> info . attributes . event_mask = ButtonPressMask | ExposureMask | StructureNotifyMask ; manager_hints -> flags = InputHint | StateHint | WindowGroupHint ; manager_hints -> input = MagickFalse ; manager_hints -> initial_state = NormalState ; manager_hints -> window_group = windows -> image . id ; XMakeWindow ( display , windows -> image . id , argv , argc , class_hints , manager_hints , & windows -> info ) ; windows -> info . highlight_stipple = XCreateBitmapFromData ( display , windows -> info . id , ( char * ) HighlightBitmap , HighlightWidth , HighlightHeight ) ; windows -> info . shadow_stipple = XCreateBitmapFromData ( display , windows -> info . id , ( char * ) ShadowBitmap , ShadowWidth , ShadowHeight ) ; ( void ) XSetTransientForHint ( display , windows -> info . id , windows -> image . id ) ; if ( windows -> image . mapped != MagickFalse ) { ( void ) XWithdrawWindow ( display , windows -> info . id , windows -> info . screen ) ; } if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Window id: 0x%lx (info)" , windows -> info . id ) ; } XGetWindowInfo ( display , visual_info , map_info , pixel , font_info , resource_info , & windows -> command ) ; windows -> command . data = MagickMenus ; ( void ) XCommandWidget ( display , windows , CommandMenu , ( XEvent * ) NULL ) ; ( void ) FormatLocaleString ( resource_name , MagickPathExtent , "%s.command" , resource_info -> client_name ) ; windows -> command . geometry = XGetResourceClass ( resource_info -> resource_database , resource_name , "geometry" , ( char * ) NULL ) ; ( void ) CloneString ( & windows -> command . name , MagickTitle ) ; windows -> command . border_width = 0 ; windows -> command . flags |= PPosition ; windows -> command . attributes . event_mask = ButtonMotionMask | ButtonPressMask | ButtonReleaseMask | EnterWindowMask | ExposureMask | LeaveWindowMask | OwnerGrabButtonMask | StructureNotifyMask ; manager_hints -> flags = InputHint | StateHint | WindowGroupHint ; manager_hints -> input = MagickTrue ; manager_hints -> initial_state = NormalState ; manager_hints -> window_group = windows -> image . id ; XMakeWindow ( display , root_window , argv , argc , class_hints , manager_hints , & windows -> command ) ; windows -> command . highlight_stipple = XCreateBitmapFromData ( display , windows -> command . id , ( char * ) HighlightBitmap , HighlightWidth , HighlightHeight ) ; windows -> command . shadow_stipple = XCreateBitmapFromData ( display , windows -> command . id , ( char * ) ShadowBitmap , ShadowWidth , ShadowHeight ) ; ( void ) XSetTransientForHint ( display , windows -> command . id , windows -> image . id ) ; if ( windows -> command . mapped != MagickFalse ) { ( void ) XMapRaised ( display , windows -> command . id ) ; } if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Window id: 0x%lx (command)" , windows -> command . id ) ; } XGetWindowInfo ( display , visual_info , map_info , pixel , font_info , resource_info , & windows -> widget ) ; ( void ) FormatLocaleString ( resource_name , MagickPathExtent , "%s.widget" , resource_info -> client_name ) ; windows -> widget . geometry = XGetResourceClass ( resource_info -> resource_database , resource_name , "geometry" , ( char * ) NULL ) ; windows -> widget . border_width = 0 ; windows -> widget . flags |= PPosition ; windows -> widget . attributes . event_mask = ButtonMotionMask | ButtonPressMask | ButtonReleaseMask | EnterWindowMask | ExposureMask | KeyPressMask | KeyReleaseMask | LeaveWindowMask | OwnerGrabButtonMask | StructureNotifyMask ; manager_hints -> flags = InputHint | StateHint | WindowGroupHint ; manager_hints -> input = MagickTrue ; manager_hints -> initial_state = NormalState ; manager_hints -> window_group = windows -> image . id ; XMakeWindow ( display , root_window , argv , argc , class_hints , manager_hints , & windows -> widget ) ; windows -> widget . highlight_stipple = XCreateBitmapFromData ( display , windows -> widget . id , ( char * ) HighlightBitmap , HighlightWidth , HighlightHeight ) ; windows -> widget . shadow_stipple = XCreateBitmapFromData ( display , windows -> widget . id , ( char * ) ShadowBitmap , ShadowWidth , ShadowHeight ) ; ( void ) XSetTransientForHint ( display , windows -> widget . id , windows -> image . id ) ; if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Window id: 0x%lx (widget)" , windows -> widget . id ) ; } XGetWindowInfo ( display , visual_info , map_info , pixel , font_info , resource_info , & windows -> popup ) ; windows -> popup . border_width = 0 ; windows -> popup . flags |= PPosition ; windows -> popup . attributes . event_mask = ButtonMotionMask | ButtonPressMask | ButtonReleaseMask | EnterWindowMask | ExposureMask | KeyPressMask | KeyReleaseMask | LeaveWindowMask | StructureNotifyMask ; manager_hints -> flags = InputHint | StateHint | WindowGroupHint ; manager_hints -> input = MagickTrue ; manager_hints -> initial_state = NormalState ; manager_hints -> window_group = windows -> image . id ; XMakeWindow ( display , root_window , argv , argc , class_hints , manager_hints , & windows -> popup ) ; windows -> popup . highlight_stipple = XCreateBitmapFromData ( display , windows -> popup . id , ( char * ) HighlightBitmap , HighlightWidth , HighlightHeight ) ; windows -> popup . shadow_stipple = XCreateBitmapFromData ( display , windows -> popup . id , ( char * ) ShadowBitmap , ShadowWidth , ShadowHeight ) ; ( void ) XSetTransientForHint ( display , windows -> popup . id , windows -> image . id ) ; if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Window id: 0x%lx (pop up)" , windows -> popup . id ) ; } XGetWindowInfo ( display , visual_info , map_info , pixel , font_info , resource_info , & windows -> magnify ) ; if ( resource_info -> use_shared_memory == MagickFalse ) { windows -> magnify . shared_memory = MagickFalse ; } ( void ) FormatLocaleString ( resource_name , MagickPathExtent , "%s.magnify" , resource_info -> client_name ) ; windows -> magnify . geometry = XGetResourceClass ( resource_info -> resource_database , resource_name , "geometry" , ( char * ) NULL ) ; ( void ) FormatLocaleString ( windows -> magnify . name , MagickPathExtent , "Magnify %uX" , resource_info -> magnify ) ; if ( windows -> magnify . cursor != ( Cursor ) NULL ) { ( void ) XFreeCursor ( display , windows -> magnify . cursor ) ; } windows -> magnify . cursor = XMakeCursor ( display , windows -> image . id , map_info -> colormap , resource_info -> background_color , resource_info -> foreground_color ) ; if ( windows -> magnify . cursor == ( Cursor ) NULL ) { ThrowXWindowFatalException ( XServerFatalError , "UnableToCreateCursor" , display_image -> filename ) ; } windows -> magnify . width = MagnifySize ; windows -> magnify . height = MagnifySize ; windows -> magnify . flags |= PPosition ; windows -> magnify . min_width = MagnifySize ; windows -> magnify . min_height = MagnifySize ; windows -> magnify . width_inc = MagnifySize ; windows -> magnify . height_inc = MagnifySize ; windows -> magnify . data = resource_info -> magnify ; windows -> magnify . attributes . cursor = windows -> magnify . cursor ; windows -> magnify . attributes . event_mask = ButtonPressMask | ButtonReleaseMask | ExposureMask | KeyPressMask | KeyReleaseMask | OwnerGrabButtonMask | StructureNotifyMask ; manager_hints -> flags = InputHint | StateHint | WindowGroupHint ; manager_hints -> input = MagickTrue ; manager_hints -> initial_state = NormalState ; manager_hints -> window_group = windows -> image . id ; XMakeWindow ( display , root_window , argv , argc , class_hints , manager_hints , & windows -> magnify ) ; if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Window id: 0x%lx (magnify)" , windows -> magnify . id ) ; } ( void ) XSetTransientForHint ( display , windows -> magnify . id , windows -> image . id ) ; XGetWindowInfo ( display , visual_info , map_info , pixel , font_info , resource_info , & windows -> pan ) ; ( void ) CloneString ( & windows -> pan . name , "Pan Icon" ) ; windows -> pan . width = windows -> icon . width ; windows -> pan . height = windows -> icon . height ; ( void ) FormatLocaleString ( resource_name , MagickPathExtent , "%s.pan" , resource_info -> client_name ) ; windows -> pan . geometry = XGetResourceClass ( resource_info -> resource_database , resource_name , "geometry" , ( char * ) NULL ) ; ( void ) XParseGeometry ( windows -> pan . geometry , & windows -> pan . x , & windows -> pan . y , & windows -> pan . width , & windows -> pan . height ) ; windows -> pan . flags |= PPosition ; windows -> pan . immutable = MagickTrue ; windows -> pan . attributes . event_mask = ButtonMotionMask | ButtonPressMask | ButtonReleaseMask | ExposureMask | KeyPressMask | KeyReleaseMask | StructureNotifyMask ; manager_hints -> flags = InputHint | StateHint | WindowGroupHint ; manager_hints -> input = MagickFalse ; manager_hints -> initial_state = NormalState ; manager_hints -> window_group = windows -> image . id ; XMakeWindow ( display , root_window , argv , argc , class_hints , manager_hints , & windows -> pan ) ; if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Window id: 0x%lx (pan)" , windows -> pan . id ) ; } ( void ) XSetTransientForHint ( display , windows -> pan . id , windows -> image . id ) ; if ( windows -> info . mapped != MagickFalse ) { ( void ) XWithdrawWindow ( display , windows -> info . id , windows -> info . screen ) ; } if ( ( windows -> image . mapped == MagickFalse ) || ( windows -> backdrop . id != ( Window ) NULL ) ) { ( void ) XMapWindow ( display , windows -> image . id ) ; } if ( warning_handler == ( WarningHandler ) NULL ) { warning_handler = resource_info -> display_warnings ?SetErrorHandler ( XWarning ) : SetErrorHandler ( ( ErrorHandler ) NULL ) ; warning_handler = resource_info -> display_warnings ?SetWarningHandler ( XWarning ) : SetWarningHandler ( ( WarningHandler ) NULL ) ; } windows -> image . x = 0 ; windows -> image . y = 0 ; windows -> magnify . shape = MagickFalse ; width = ( unsigned int ) display_image -> columns ; height = ( unsigned int ) display_image -> rows ; if ( ( display_image -> columns != width ) || ( display_image -> rows != height ) ) { ThrowXWindowFatalException ( XServerFatalError , "UnableToCreateXImage" , display_image -> filename ) ; } status = XMakeImage ( display , resource_info , & windows -> image , display_image , width , height , exception ) ; if ( status == MagickFalse ) { ThrowXWindowFatalException ( XServerFatalError , "UnableToCreateXImage" , display_image -> filename ) ; } status = XMakeImage ( display , resource_info , & windows -> magnify , ( Image * ) NULL , windows -> magnify . width , windows -> magnify . height , exception ) ; if ( status == MagickFalse ) { ThrowXWindowFatalException ( XServerFatalError , "UnableToCreateXImage" , display_image -> filename ) ; } if ( windows -> magnify . mapped != MagickFalse ) { ( void ) XMapRaised ( display , windows -> magnify . id ) ; } if ( windows -> pan . mapped != MagickFalse ) { ( void ) XMapRaised ( display , windows -> pan . id ) ; } windows -> image . window_changes . width = ( int ) display_image -> columns ; windows -> image . window_changes . height = ( int ) display_image -> rows ; ( void ) XConfigureImage ( display , resource_info , windows , display_image , exception ) ; ( void ) XWithdrawWindow ( display , windows -> info . id , windows -> info . screen ) ; ( void ) XSync ( display , MagickFalse ) ; delay = display_image -> delay / MagickMax ( display_image -> ticks_per_second , 1L ) ; timer = GetMagickTime ( ) + ( delay == 0 ?1 : delay ) + 1 ; update_time = 0 ; if ( resource_info -> update != MagickFalse ) { MagickBooleanType status ; status = GetPathAttributes ( display_image -> filename , & attributes ) ; if ( status != MagickFalse ) { update_time = attributes . st_mtime ; } } * state &= ( ~ FormerImageState ) ; * state &= ( ~ MontageImageState ) ; * state &= ( ~ NextImageState ) ; { if ( windows -> image . mapped != MagickFalse ) { if ( ( display_image -> delay != 0 ) || ( resource_info -> update != 0 ) ) { if ( timer < GetMagickTime ( ) ) { if ( resource_info -> update == MagickFalse ) { * state |= NextImageState | ExitState ; } else { MagickBooleanType status ; status = GetPathAttributes ( display_image -> filename , & attributes ) ; if ( status != MagickFalse ) { if ( update_time != attributes . st_mtime ) { ( void ) FormatLocaleString ( resource_info -> image_info -> filename , MagickPathExtent , "%s:%s" , display_image -> magick , display_image -> filename ) ; nexus = ReadImage ( resource_info -> image_info , exception ) ; if ( nexus != ( Image * ) NULL ) { * state |= NextImageState | ExitState ; } } } delay = display_image -> delay / MagickMax ( display_image -> ticks_per_second , 1L ) ; timer = GetMagickTime ( ) + ( delay == 0 ?1 : delay ) + 1 ; } } if ( XEventsQueued ( display , QueuedAfterFlush ) == 0 ) { XDelay ( display , SuspendTime << 2 ) ; continue ; } } } timestamp = GetMagickTime ( ) ; ( void ) XNextEvent ( display , & event ) ; if ( ( windows -> image . stasis == MagickFalse ) || ( windows -> magnify . stasis == MagickFalse ) ) { if ( ( GetMagickTime ( ) - timestamp ) > 0 ) { windows -> image . stasis = MagickTrue ; windows -> magnify . stasis = MagickTrue ; } } if ( event . xany . window == windows -> command . id ) { id = XCommandWidget ( display , windows , CommandMenu , & event ) ; if ( id < 0 ) { continue ; } ( void ) CopyMagickString ( command , CommandMenu [ id ] , MagickPathExtent ) ; command_type = CommandMenus [ id ] ; if ( id < MagickMenus ) { entry = XMenuWidget ( display , windows , CommandMenu [ id ] , Menus [ id ] , command ) ; if ( entry < 0 ) { continue ; } ( void ) CopyMagickString ( command , Menus [ id ] [ entry ] , MagickPathExtent ) ; command_type = Commands [ id ] [ entry ] ; } if ( command_type != NullCommand ) { nexus = XMagickCommand ( display , resource_info , windows , command_type , & display_image , exception ) ; } continue ; } switch ( event . type ) { case ButtonPress : { if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Button Press: 0x%lx %u +%d+%d" , event . xbutton . window , event . xbutton . button , event . xbutton . x , event . xbutton . y ) ; } if ( ( event . xbutton . button == Button3 ) && ( event . xbutton . state & Mod1Mask ) ) { event . xbutton . button = Button2 ; event . xbutton . state &= ( ~ Mod1Mask ) ; } if ( event . xbutton . window == windows -> backdrop . id ) { ( void ) XSetInputFocus ( display , event . xbutton . window , RevertToParent , event . xbutton . time ) ; break ; } if ( event . xbutton . window == windows -> image . id ) { switch ( event . xbutton . button ) { case Button1 : { if ( resource_info -> immutable ) { entry = XMenuWidget ( display , windows , "Commands" , VirtualMenu , command ) ; if ( entry >= 0 ) { nexus = XMagickCommand ( display , resource_info , windows , VirtualCommands [ entry ] , & display_image , exception ) ; } break ; } if ( windows -> command . mapped != MagickFalse ) { ( void ) XWithdrawWindow ( display , windows -> command . id , windows -> command . screen ) ; } else { ( void ) XCommandWidget ( display , windows , CommandMenu , ( XEvent * ) NULL ) ; ( void ) XMapRaised ( display , windows -> command . id ) ; } break ; } case Button2 : { ( void ) XMagickCommand ( display , resource_info , windows , ZoomCommand , & display_image , exception ) ; XMagnifyImage ( display , windows , & event , exception ) ; break ; } case Button3 : { if ( resource_info -> immutable ) { entry = XMenuWidget ( display , windows , "Commands" , VirtualMenu , command ) ; if ( entry >= 0 ) { nexus = XMagickCommand ( display , resource_info , windows , VirtualCommands [ entry ] , & display_image , exception ) ; } break ; } if ( display_image -> montage != ( char * ) NULL ) { nexus = XTileImage ( display , resource_info , windows , display_image , & event , exception ) ; if ( nexus != ( Image * ) NULL ) { * state |= MontageImageState | NextImageState | ExitState ; } vid_info . x = ( short int ) windows -> image . x ; vid_info . y = ( short int ) windows -> image . y ; break ; } entry = XMenuWidget ( display , windows , "Short Cuts" , ShortCutsMenu , command ) ; if ( entry >= 0 ) { nexus = XMagickCommand ( display , resource_info , windows , ShortCutsCommands [ entry ] , & display_image , exception ) ; } break ; } case Button4 : { XTranslateImage ( display , windows , * image , XK_Up ) ; break ; } case Button5 : { XTranslateImage ( display , windows , * image , XK_Down ) ; break ; } default : break ; } break ; } if ( event . xbutton . window == windows -> magnify . id ) { const char * const MagnifyMenu [ ] { "2" "4" "5" "6" "7" "8" "9" "3" ( char * ) NULL } ; ; int factor ; static KeySym MagnifyCommands [ ] { XK_2 XK_4 XK_5 XK_6 XK_7 XK_8 XK_9 XK_3 } ; ; factor = XMenuWidget ( display , windows , "Magnify" , MagnifyMenu , command ) ; if ( factor >= 0 ) { XMagnifyWindowCommand ( display , windows , 0 , MagnifyCommands [ factor ] , exception ) ; } break ; } if ( event . xbutton . window == windows -> pan . id ) { switch ( event . xbutton . button ) { case Button4 : { XTranslateImage ( display , windows , * image , XK_Up ) ; break ; } case Button5 : { XTranslateImage ( display , windows , * image , XK_Down ) ; break ; } default : { XPanImage ( display , windows , & event , exception ) ; break ; } } break ; } delay = display_image -> delay / MagickMax ( display_image -> ticks_per_second , 1L ) ; timer = GetMagickTime ( ) + ( delay == 0 ?1 : delay ) + 1 ; break ; } case ButtonRelease : { if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Button Release: 0x%lx %u +%d+%d" , event . xbutton . window , event . xbutton . button , event . xbutton . x , event . xbutton . y ) ; } break ; } case ClientMessage : { if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Client Message: 0x%lx 0x%lx %d 0x%lx" , event . xclient . window , event . xclient . message_type , event . xclient . format , ( unsigned long ) event . xclient . data . l [ 0 ] ) ; } if ( event . xclient . message_type == windows -> im_protocols ) { if ( * event . xclient . data . l == ( long ) windows -> im_update_widget ) { ( void ) CloneString ( & windows -> command . name , MagickTitle ) ; windows -> command . data = MagickMenus ; ( void ) XCommandWidget ( display , windows , CommandMenu , ( XEvent * ) NULL ) ; break ; } if ( * event . xclient . data . l == ( long ) windows -> im_update_colormap ) { for ( i = 0 ; i < ( int ) number_windows ; i ++ ) { if ( magick_windows [ i ] -> id == windows -> icon . id ) { continue ; } context_values . background = pixel -> background_color . pixel ; context_values . foreground = pixel -> foreground_color . pixel ; ( void ) XChangeGC ( display , magick_windows [ i ] -> annotate_context , context_mask , & context_values ) ; ( void ) XChangeGC ( display , magick_windows [ i ] -> widget_context , context_mask , & context_values ) ; context_values . background = pixel -> foreground_color . pixel ; context_values . foreground = pixel -> background_color . pixel ; context_values . plane_mask = context_values . background ^ context_values . foreground ; ( void ) XChangeGC ( display , magick_windows [ i ] -> highlight_context , ( size_t ) ( context_mask | GCPlaneMask ) , & context_values ) ; magick_windows [ i ] -> attributes . background_pixel = pixel -> background_color . pixel ; magick_windows [ i ] -> attributes . border_pixel = pixel -> border_color . pixel ; magick_windows [ i ] -> attributes . colormap = map_info -> colormap ; ( void ) XChangeWindowAttributes ( display , magick_windows [ i ] -> id , ( unsigned long ) magick_windows [ i ] -> mask , & magick_windows [ i ] -> attributes ) ; } if ( windows -> pan . mapped != MagickFalse ) { ( void ) XSetWindowBackgroundPixmap ( display , windows -> pan . id , windows -> pan . pixmap ) ; ( void ) XClearWindow ( display , windows -> pan . id ) ; XDrawPanRectangle ( display , windows ) ; } if ( windows -> backdrop . id != ( Window ) NULL ) { ( void ) XInstallColormap ( display , map_info -> colormap ) ; } break ; } if ( * event . xclient . data . l == ( long ) windows -> im_former_image ) { * state |= FormerImageState | ExitState ; break ; } if ( * event . xclient . data . l == ( long ) windows -> im_next_image ) { * state |= NextImageState | ExitState ; break ; } if ( * event . xclient . data . l == ( long ) windows -> im_retain_colors ) { * state |= RetainColorsState ; break ; } if ( * event . xclient . data . l == ( long ) windows -> im_exit ) { * state |= ExitState ; break ; } break ; } if ( event . xclient . message_type == windows -> dnd_protocols ) { Atom selection , type ; int format , status ; unsigned char * data ; unsigned long after , length ; if ( ( * event . xclient . data . l != 2 ) && ( * event . xclient . data . l != 128 ) ) { break ; } selection = XInternAtom ( display , "DndSelection" , MagickFalse ) ; status = XGetWindowProperty ( display , root_window , selection , 0L , ( long ) MagickPathExtent , MagickFalse , ( Atom ) AnyPropertyType , & type , & format , & length , & after , & data ) ; if ( ( status != Success ) || ( length == 0 ) ) { break ; } if ( * event . xclient . data . l == 2 ) { ( void ) CopyMagickString ( resource_info -> image_info -> filename , ( char * ) data , MagickPathExtent ) ; } else { if ( strncmp ( ( char * ) data , "file:" , 5 ) != 0 ) { ( void ) XFree ( ( void * ) data ) ; break ; } ( void ) CopyMagickString ( resource_info -> image_info -> filename , ( ( char * ) data ) + 5 , MagickPathExtent ) ; } nexus = ReadImage ( resource_info -> image_info , exception ) ; CatchException ( exception ) ; if ( nexus != ( Image * ) NULL ) { * state |= NextImageState | ExitState ; } ( void ) XFree ( ( void * ) data ) ; break ; } if ( event . xclient . message_type != windows -> wm_protocols ) { break ; } if ( * event . xclient . data . l != ( long ) windows -> wm_delete_window ) { break ; } ( void ) XWithdrawWindow ( display , event . xclient . window , visual_info -> screen ) ; if ( event . xclient . window == windows -> image . id ) { * state |= ExitState ; break ; } if ( event . xclient . window == windows -> pan . id ) { windows -> image . window_changes . width = windows -> image . ximage -> width ; windows -> image . window_changes . height = windows -> image . ximage -> height ; ( void ) XConfigureImage ( display , resource_info , windows , display_image , exception ) ; } break ; } case ConfigureNotify : { if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Configure Notify: 0x%lx %dx%d+%d+%d %d" , event . xconfigure . window , event . xconfigure . width , event . xconfigure . height , event . xconfigure . x , event . xconfigure . y , event . xconfigure . send_event ) ; } if ( event . xconfigure . window == windows -> image . id ) { if ( event . xconfigure . send_event != 0 ) { XWindowChanges window_changes ; if ( windows -> command . geometry == ( char * ) NULL ) { if ( windows -> command . mapped == MagickFalse ) { windows -> command . x = event . xconfigure . x - windows -> command . width - 25 ; windows -> command . y = event . xconfigure . y ; XConstrainWindowPosition ( display , & windows -> command ) ; window_changes . x = windows -> command . x ; window_changes . y = windows -> command . y ; ( void ) XReconfigureWMWindow ( display , windows -> command . id , windows -> command . screen , ( unsigned int ) ( CWX | CWY ) , & window_changes ) ; } } if ( windows -> widget . geometry == ( char * ) NULL ) { if ( windows -> widget . mapped == MagickFalse ) { windows -> widget . x = event . xconfigure . x + event . xconfigure . width / 10 ; windows -> widget . y = event . xconfigure . y + event . xconfigure . height / 10 ; XConstrainWindowPosition ( display , & windows -> widget ) ; window_changes . x = windows -> widget . x ; window_changes . y = windows -> widget . y ; ( void ) XReconfigureWMWindow ( display , windows -> widget . id , windows -> widget . screen , ( unsigned int ) ( CWX | CWY ) , & window_changes ) ; } } if ( windows -> magnify . geometry == ( char * ) NULL ) { if ( windows -> magnify . mapped == MagickFalse ) { windows -> magnify . x = event . xconfigure . x + event . xconfigure . width + 25 ; windows -> magnify . y = event . xconfigure . y ; XConstrainWindowPosition ( display , & windows -> magnify ) ; window_changes . x = windows -> magnify . x ; window_changes . y = windows -> magnify . y ; ( void ) XReconfigureWMWindow ( display , windows -> magnify . id , windows -> magnify . screen , ( unsigned int ) ( CWX | CWY ) , & window_changes ) ; } } if ( windows -> pan . geometry == ( char * ) NULL ) { if ( windows -> pan . mapped == MagickFalse ) { windows -> pan . x = event . xconfigure . x + event . xconfigure . width + 25 ; windows -> pan . y = event . xconfigure . y + windows -> magnify . height + 50 ; XConstrainWindowPosition ( display , & windows -> pan ) ; window_changes . x = windows -> pan . x ; window_changes . y = windows -> pan . y ; ( void ) XReconfigureWMWindow ( display , windows -> pan . id , windows -> pan . screen , ( unsigned int ) ( CWX | CWY ) , & window_changes ) ; } } } if ( ( event . xconfigure . width == ( int ) windows -> image . width ) && ( event . xconfigure . height == ( int ) windows -> image . height ) ) { break ; } windows -> image . width = ( unsigned int ) event . xconfigure . width ; windows -> image . height = ( unsigned int ) event . xconfigure . height ; windows -> image . x = 0 ; windows -> image . y = 0 ; if ( display_image -> montage != ( char * ) NULL ) { windows -> image . x = vid_info . x ; windows -> image . y = vid_info . y ; } if ( windows -> image . mapped != MagickFalse && windows -> image . stasis != MagickFalse ) { windows -> image . window_changes . width = event . xconfigure . width ; windows -> image . window_changes . height = event . xconfigure . height ; ( void ) XConfigureImage ( display , resource_info , windows , display_image , exception ) ; } if ( ( event . xconfigure . width < windows -> image . ximage -> width ) || ( event . xconfigure . height < windows -> image . ximage -> height ) ) { ( void ) XMapRaised ( display , windows -> pan . id ) ; XDrawPanRectangle ( display , windows ) ; } if ( windows -> pan . mapped != MagickFalse ) { ( void ) XWithdrawWindow ( display , windows -> pan . id , windows -> pan . screen ) ; } break ; } if ( event . xconfigure . window == windows -> magnify . id ) { unsigned int magnify ; windows -> magnify . width = ( unsigned int ) event . xconfigure . width ; windows -> magnify . height = ( unsigned int ) event . xconfigure . height ; if ( windows -> magnify . mapped == MagickFalse ) { break ; } magnify = 1 ; while ( ( int ) magnify <= event . xconfigure . width ) { magnify <<= 1 ; } while ( ( int ) magnify <= event . xconfigure . height ) { magnify <<= 1 ; } magnify >>= 1 ; if ( ( ( int ) magnify != event . xconfigure . width ) || ( ( int ) magnify != event . xconfigure . height ) ) { window_changes . width = ( int ) magnify ; window_changes . height = ( int ) magnify ; ( void ) XReconfigureWMWindow ( display , windows -> magnify . id , windows -> magnify . screen , ( unsigned int ) ( CWWidth | CWHeight ) , & window_changes ) ; break ; } if ( windows -> magnify . mapped != MagickFalse && windows -> magnify . stasis != MagickFalse ) { status = XMakeImage ( display , resource_info , & windows -> magnify , display_image , windows -> magnify . width , windows -> magnify . height , exception ) ; XMakeMagnifyImage ( display , windows , exception ) ; } break ; } if ( windows -> magnify . mapped != MagickFalse && ( event . xconfigure . window == windows -> pan . id ) ) { if ( event . xconfigure . send_event != 0 ) { windows -> pan . x = event . xconfigure . x ; windows -> pan . y = event . xconfigure . y ; } windows -> pan . width = ( unsigned int ) event . xconfigure . width ; windows -> pan . height = ( unsigned int ) event . xconfigure . height ; break ; } if ( event . xconfigure . window == windows -> icon . id ) { windows -> icon . width = ( unsigned int ) event . xconfigure . width ; windows -> icon . height = ( unsigned int ) event . xconfigure . height ; break ; } break ; } case DestroyNotify : { if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Destroy Notify: 0x%lx" , event . xdestroywindow . window ) ; } if ( event . xdestroywindow . window == windows -> group_leader . id ) { * state |= ExitState ; break ; } break ; } case EnterNotify : { if ( map_info -> colormap != XDefaultColormap ( display , visual_info -> screen ) ) { if ( event . xcrossing . mode != NotifyUngrab ) { XInstallColormap ( display , map_info -> colormap ) ; } } break ; } case Expose : { if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Expose: 0x%lx %dx%d+%d+%d" , event . xexpose . window , event . xexpose . width , event . xexpose . height , event . xexpose . x , event . xexpose . y ) ; } if ( ( event . xexpose . window == windows -> image . id ) && windows -> image . mapped != MagickFalse ) { XRefreshWindow ( display , & windows -> image , & event ) ; delay = display_image -> delay / MagickMax ( display_image -> ticks_per_second , 1L ) ; timer = GetMagickTime ( ) + ( delay == 0 ?1 : delay ) + 1 ; break ; } if ( ( event . xexpose . window == windows -> magnify . id ) && windows -> magnify . mapped != MagickFalse ) { XMakeMagnifyImage ( display , windows , exception ) ; break ; } if ( event . xexpose . window == windows -> pan . id ) { XDrawPanRectangle ( display , windows ) ; break ; } if ( event . xexpose . window == windows -> icon . id ) { XRefreshWindow ( display , & windows -> icon , & event ) ; break ; } break ; } case KeyPress : { int length ; length = XLookupString ( ( XKeyEvent * ) & event . xkey , command , ( int ) sizeof ( command ) , & key_symbol , ( XComposeStatus * ) NULL ) ; * ( command + length ) = '\0' ; if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Key press: %d 0x%lx (%s)" , event . xkey . state , ( unsigned long ) key_symbol , command ) ; } if ( event . xkey . window == windows -> image . id ) { command_type = XImageWindowCommand ( display , resource_info , windows , event . xkey . state , key_symbol , & display_image , exception ) ; if ( command_type != NullCommand ) { nexus = XMagickCommand ( display , resource_info , windows , command_type , & display_image , exception ) ; } } if ( event . xkey . window == windows -> magnify . id ) { XMagnifyWindowCommand ( display , windows , event . xkey . state , key_symbol , exception ) ; } if ( event . xkey . window == windows -> pan . id ) { if ( ( key_symbol == XK_q ) || ( key_symbol == XK_Escape ) ) { ( void ) XWithdrawWindow ( display , windows -> pan . id , windows -> pan . screen ) ; } if ( ( key_symbol == XK_F1 ) || ( key_symbol == XK_Help ) ) { XTextViewHelp ( display , resource_info , windows , MagickFalse , "Help Viewer - Image Pan" , ImagePanHelp ) ; } else { XTranslateImage ( display , windows , * image , key_symbol ) ; } } delay = display_image -> delay / MagickMax ( display_image -> ticks_per_second , 1L ) ; timer = GetMagickTime ( ) + ( delay == 0 ?1 : delay ) + 1 ; break ; } case KeyRelease : { ( void ) XLookupString ( ( XKeyEvent * ) & event . xkey , command , ( int ) sizeof ( command ) , & key_symbol , ( XComposeStatus * ) NULL ) ; if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Key release: 0x%lx (%c)" , ( unsigned long ) key_symbol , * command ) ; } break ; } case LeaveNotify : { if ( map_info -> colormap != XDefaultColormap ( display , visual_info -> screen ) ) { if ( event . xcrossing . mode != NotifyUngrab ) { XUninstallColormap ( display , map_info -> colormap ) ; } } break ; } case MapNotify : { if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Map Notify: 0x%lx" , event . xmap . window ) ; } if ( event . xmap . window == windows -> backdrop . id ) { ( void ) XSetInputFocus ( display , event . xmap . window , RevertToParent , CurrentTime ) ; windows -> backdrop . mapped = MagickTrue ; break ; } if ( event . xmap . window == windows -> image . id ) { if ( windows -> backdrop . id != ( Window ) NULL ) { ( void ) XInstallColormap ( display , map_info -> colormap ) ; } if ( LocaleCompare ( display_image -> magick , "LOGO" ) == 0 ) { if ( LocaleCompare ( display_image -> filename , "LOGO" ) == 0 ) { nexus = XOpenImage ( display , resource_info , windows , MagickFalse ) ; } } if ( ( ( int ) windows -> image . width < windows -> image . ximage -> width ) || ( ( int ) windows -> image . height < windows -> image . ximage -> height ) ) { ( void ) XMapRaised ( display , windows -> pan . id ) ; } windows -> image . mapped = MagickTrue ; break ; } if ( event . xmap . window == windows -> magnify . id ) { XMakeMagnifyImage ( display , windows , exception ) ; windows -> magnify . mapped = MagickTrue ; ( void ) XWithdrawWindow ( display , windows -> info . id , windows -> info . screen ) ; break ; } if ( event . xmap . window == windows -> pan . id ) { XMakePanImage ( display , resource_info , windows , display_image , exception ) ; windows -> pan . mapped = MagickTrue ; break ; } if ( event . xmap . window == windows -> info . id ) { windows -> info . mapped = MagickTrue ; break ; } if ( event . xmap . window == windows -> icon . id ) { MagickBooleanType taint ; taint = display_image -> taint ; XMakeStandardColormap ( display , icon_visual , icon_resources , display_image , icon_map , icon_pixel , exception ) ; ( void ) XMakeImage ( display , icon_resources , & windows -> icon , display_image , windows -> icon . width , windows -> icon . height , exception ) ; display_image -> taint = taint ; ( void ) XSetWindowBackgroundPixmap ( display , windows -> icon . id , windows -> icon . pixmap ) ; ( void ) XClearWindow ( display , windows -> icon . id ) ; ( void ) XWithdrawWindow ( display , windows -> info . id , windows -> info . screen ) ; windows -> icon . mapped = MagickTrue ; break ; } if ( event . xmap . window == windows -> command . id ) { windows -> command . mapped = MagickTrue ; break ; } if ( event . xmap . window == windows -> popup . id ) { windows -> popup . mapped = MagickTrue ; break ; } if ( event . xmap . window == windows -> widget . id ) { windows -> widget . mapped = MagickTrue ; break ; } break ; } case MappingNotify : { ( void ) XRefreshKeyboardMapping ( & event . xmapping ) ; break ; } case NoExpose : break ; case PropertyNotify : { Atom type ; int format , status ; unsigned char * data ; unsigned long after , length ; if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Property Notify: 0x%lx 0x%lx %d" , event . xproperty . window , event . xproperty . atom , event . xproperty . state ) ; } if ( event . xproperty . atom != windows -> im_remote_command ) { break ; } status = XGetWindowProperty ( display , event . xproperty . window , event . xproperty . atom , 0L , ( long ) MagickPathExtent , MagickFalse , ( Atom ) AnyPropertyType , & type , & format , & length , & after , & data ) ; if ( ( status != Success ) || ( length == 0 ) ) { break ; } if ( LocaleCompare ( ( char * ) data , "-quit" ) == 0 ) { XClientMessage ( display , windows -> image . id , windows -> im_protocols , windows -> im_exit , CurrentTime ) ; ( void ) XFree ( ( void * ) data ) ; break ; } ( void ) CopyMagickString ( resource_info -> image_info -> filename , ( char * ) data , MagickPathExtent ) ; ( void ) XFree ( ( void * ) data ) ; nexus = ReadImage ( resource_info -> image_info , exception ) ; CatchException ( exception ) ; if ( nexus != ( Image * ) NULL ) { * state |= NextImageState | ExitState ; } break ; } case ReparentNotify : { if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Reparent Notify: 0x%lx=>0x%lx" , event . xreparent . parent , event . xreparent . window ) ; } break ; } case UnmapNotify : { if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Unmap Notify: 0x%lx" , event . xunmap . window ) ; } if ( event . xunmap . window == windows -> backdrop . id ) { windows -> backdrop . mapped = MagickFalse ; break ; } if ( event . xunmap . window == windows -> image . id ) { windows -> image . mapped = MagickFalse ; break ; } if ( event . xunmap . window == windows -> magnify . id ) { windows -> magnify . mapped = MagickFalse ; break ; } if ( event . xunmap . window == windows -> pan . id ) { windows -> pan . mapped = MagickFalse ; break ; } if ( event . xunmap . window == windows -> info . id ) { windows -> info . mapped = MagickFalse ; break ; } if ( event . xunmap . window == windows -> icon . id ) { if ( map_info -> colormap == icon_map -> colormap ) { XConfigureImageColormap ( display , resource_info , windows , display_image , exception ) ; } ( void ) XFreeStandardColormap ( display , icon_visual , icon_map , icon_pixel ) ; windows -> icon . mapped = MagickFalse ; break ; } if ( event . xunmap . window == windows -> command . id ) { windows -> command . mapped = MagickFalse ; break ; } if ( event . xunmap . window == windows -> popup . id ) { if ( windows -> backdrop . id != ( Window ) NULL ) { ( void ) XSetInputFocus ( display , windows -> image . id , RevertToParent , CurrentTime ) ; } windows -> popup . mapped = MagickFalse ; break ; } if ( event . xunmap . window == windows -> widget . id ) { if ( windows -> backdrop . id != ( Window ) NULL ) { ( void ) XSetInputFocus ( display , windows -> image . id , RevertToParent , CurrentTime ) ; } windows -> widget . mapped = MagickFalse ; break ; } break ; } default : { if ( resource_info -> debug != MagickFalse ) { ( void ) LogMagickEvent ( X11Event , GetMagickModule ( ) , "Event type: %d" , event . type ) ; } break ; } } } ! ( * state & ExitState ) ; if ( ( * state & ExitState ) == 0 ) { ( void ) XMagickCommand ( display , resource_info , windows , FreeBuffersCommand , & display_image , exception ) ; } if ( resource_info -> confirm_edit != MagickFalse ) { if ( ( resource_info -> immutable == MagickFalse ) && display_image -> taint != MagickFalse ) { int status ; status = XConfirmWidget ( display , windows , "Your image changed." , "Do you want to save it" ) ; if ( status == 0 ) { * state &= ( ~ ExitState ) ; } if ( status > 0 ) { ( void ) XMagickCommand ( display , resource_info , windows , SaveCommand , & display_image , exception ) ; } } } if ( ( windows -> visual_info -> klass == GrayScale ) || ( windows -> visual_info -> klass == PseudoColor ) || ( windows -> visual_info -> klass == DirectColor ) ) { if ( windows -> info . mapped != MagickFalse ) { ( void ) XWithdrawWindow ( display , windows -> info . id , windows -> info . screen ) ; } if ( windows -> magnify . mapped != MagickFalse ) { ( void ) XWithdrawWindow ( display , windows -> magnify . id , windows -> magnify . screen ) ; } if ( windows -> command . mapped != MagickFalse ) { ( void ) XWithdrawWindow ( display , windows -> command . id , windows -> command . screen ) ; } } if ( windows -> pan . mapped != MagickFalse ) { ( void ) XWithdrawWindow ( display , windows -> pan . id , windows -> pan . screen ) ; } XSetCursorState ( display , windows , MagickTrue ) ; XCheckRefreshWindows ( display , windows ) ; if ( ( ( * state & FormerImageState ) != 0 ) || ( ( * state & NextImageState ) != 0 ) ) { * state &= ( ~ ExitState ) ; } if ( * state & ExitState ) { ( void ) XFreeStandardColormap ( display , icon_visual , icon_map , icon_pixel ) ; if ( resource_info -> map_type == ( char * ) NULL ) { ( void ) XFreeStandardColormap ( display , visual_info , map_info , pixel ) ; } if ( resource_info -> copy_image != ( Image * ) NULL ) { resource_info -> copy_image = DestroyImage ( resource_info -> copy_image ) ; resource_info -> copy_image = NewImageList ( ) ; } DestroyXResources ( ) ; } ( void ) XSync ( display , MagickFalse ) ; ( void ) SetErrorHandler ( warning_handler ) ; ( void ) SetWarningHandler ( warning_handler ) ; directory = getcwd ( working_directory , MagickPathExtent ) ; ( void ) directory ; { int status ; if ( * resource_info -> home_directory == '\0' ) { ( void ) CopyMagickString ( resource_info -> home_directory , "." , MagickPathExtent ) ; } status = chdir ( resource_info -> home_directory ) ; if ( status == - 1 ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , FileOpenError , "UnableToOpenFile" , "%s" , resource_info -> home_directory ) ; } } * image = display_image ; return ( nexus ) ; } 