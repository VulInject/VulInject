static int iplookup_addnode ( data , ifs ) caddr_t data ; ipf_stack_t * ifs ; { ip_pool_node_t node , * m ; iplookupop_t op ; iphtable_t * iph ; iphtent_t hte ; ip_pool_t * p ; int err ; err = BCOPYIN ( data , & op , sizeof ( op ) ) ; if ( err != 0 ) { return EFAULT ; } op . iplo_name [ sizeof ( op . iplo_name ) - 1 ] = '\0' ; switch ( op . iplo_type ) { case IPLT_POOL : if ( op . iplo_size != sizeof ( node ) ) { return EINVAL ; } err = COPYIN ( op . iplo_struct , & node , sizeof ( node ) ) ; if ( err != 0 ) { return EFAULT ; } p = ip_pool_find ( op . iplo_unit , op . iplo_name , ifs ) ; if ( p == NULL ) { return ESRCH ; } m = ip_pool_findeq ( p , & node . ipn_addr , & node . ipn_mask ) ; if ( m ) { return EEXIST ; } err = ip_pool_insert ( p , & node . ipn_addr , & node . ipn_mask , node . ipn_info , ifs ) ; break ; case IPLT_HASH : if ( op . iplo_size != sizeof ( hte ) ) { return EINVAL ; } err = COPYIN ( op . iplo_struct , & hte , sizeof ( hte ) ) ; if ( err != 0 ) { return EFAULT ; } iph = fr_findhtable ( op . iplo_unit , op . iplo_name , ifs ) ; err = fr_addhtent ( iph , & hte , ifs ) ; break ; default : err = EINVAL ; break ; } return err ; } 