void GH print_malloc_states ( RCore * core , GHT m_arena , MallocState * main_arena ) { MallocState * ta = R_NEW0 ( MallocState ) ; RConsPrintablePalette * pal = & r_cons_singleton ( ) -> context -> pal ; if ( ! ta ) { return ; } PRINT_YA ( "main_arena @ " ) ; PRINTF_BA ( "0x%" PFMT64x "\n" , ( ut64 ) m_arena ) ; if ( main_arena -> GH ( next ) != m_arena ) { ta -> GH ( next ) = main_arena -> GH ( next ) ; while ( GH ( is_arena ) ( core , m_arena , ta -> GH ( next ) ) && ta -> GH ( next ) != m_arena ) { PRINT_YA ( "thread arena @ " ) ; PRINTF_BA ( "0x%" PFMT64x , ( ut64 ) ta -> GH ( next ) ) ; if ( ! GH ( update_main_arena ) ( core , ta -> GH ( next ) , ta ) ) { free ( ta ) ; return ; } if ( ta -> attached_threads ) { PRINT_BA ( "\n" ) ; } else { PRINT_GA ( " free\n" ) ; } } } free ( ta ) ; } 