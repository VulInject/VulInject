static int load_elf_sections ( const struct elfhdr * hdr , struct elf_phdr * phdr , int fd , abi_ulong rbase , abi_ulong * baddrp ) { struct elf_phdr * elf_ppnt ; abi_ulong baddr ; int i ; bool first ; first = true ; for ( i = 0 , elf_ppnt = phdr ; i < hdr -> e_phnum ; i ++ , elf_ppnt ++ ) { int elf_prot = 0 ; abi_ulong error ; if ( elf_ppnt -> p_type != PT_LOAD ) { continue ; } if ( elf_ppnt -> p_flags & PF_R ) { elf_prot |= PROT_READ ; } if ( elf_ppnt -> p_flags & PF_W ) { elf_prot |= PROT_WRITE ; } if ( elf_ppnt -> p_flags & PF_X ) { elf_prot |= PROT_EXEC ; } error = target_mmap ( TARGET_ELF_PAGESTART ( rbase + elf_ppnt -> p_vaddr ) , ( elf_ppnt -> p_filesz + TARGET_ELF_PAGEOFFSET ( elf_ppnt -> p_vaddr ) ) , elf_prot , ( MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE ) , fd , ( elf_ppnt -> p_offset - TARGET_ELF_PAGEOFFSET ( elf_ppnt -> p_vaddr ) ) ) ; if ( error == - 1 ) { perror ( "mmap" ) ; exit ( - 1 ) ; } if ( elf_ppnt -> p_memsz != elf_ppnt -> p_filesz ) { abi_ulong start_bss , end_bss ; start_bss = rbase + elf_ppnt -> p_vaddr + elf_ppnt -> p_filesz ; end_bss = rbase + elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz ; set_brk ( start_bss , end_bss ) ; padzero ( start_bss , end_bss ) ; } if ( first ) { baddr = TARGET_ELF_PAGESTART ( rbase + elf_ppnt -> p_vaddr ) ; first = false ; } } return 0 ; } 