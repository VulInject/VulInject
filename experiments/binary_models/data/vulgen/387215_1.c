int chkquota ( char * fsdev , char * fsfile , char * qffile ) { struct fileusage * fup ; dev_t quotadev ; FILE * qf ; uid_t uid ; struct passwd * pw ; int cg , i ; char * rawdisk ; struct stat64 statb ; struct dqblk dqbuf ; extern char * getfullrawname ( ) ; if ( ( rawdisk = getfullrawname ( fsdev ) ) == NULL ) { fprintf ( stderr , "malloc failed\n" ) ; return ( 1 ) ; } if ( * rawdisk == '\0' ) { fprintf ( stderr , "Could not find character device for %s\n" , fsdev ) ; return ( 1 ) ; } if ( vflag ) { printf ( "*** Checking quotas for %s (%s)\n" , rawdisk , fsfile ) ; } fi = open64 ( rawdisk , 0 ) ; if ( fi < 0 ) { perror ( rawdisk ) ; return ( 1 ) ; } qf = fopen64 ( qffile , "r+" ) ; if ( qf == NULL ) { perror ( qffile ) ; close ( fi ) ; return ( 1 ) ; } if ( fstat64 ( fileno ( qf ) , & statb ) < 0 ) { perror ( qffile ) ; close ( fi ) ; return ( 1 ) ; } quotadev = statb . st_dev ; if ( stat64 ( fsdev , & statb ) < 0 ) { perror ( fsdev ) ; fclose ( qf ) ; close ( fi ) ; return ( 1 ) ; } if ( quotadev != statb . st_rdev ) { fprintf ( stderr , "%s dev (0x%x) mismatch %s dev (0x%x)\n" , qffile , quotadev , fsdev , statb . st_rdev ) ; fclose ( qf ) ; close ( fi ) ; return ( 1 ) ; } bread ( ( diskaddr_t ) SBLOCK , ( char * ) & sblock , SBSIZE ) ; if ( ioctl ( fileno ( qf ) , _FIOFFS , NULL ) == - 1 ) { perror ( qffile ) ; ( void ) fprintf ( stderr , "%s: cannot flush file system.\n" , qffile ) ; ( void ) fclose ( qf ) ; return ( 1 ) ; } if ( ( fflag == 0 ) && pflag && ( FSOKAY == ( sblock . fs_state + sblock . fs_time ) ) && ( sblock . fs_clean == FSLOG ) ) { fclose ( qf ) ; close ( fi ) ; return ( 0 ) ; } ino = 0 ; for ( cg = 0 ; cg < sblock . fs_ncg ; cg ++ ) { dp = NULL ; for ( i = 0 ; i < sblock . fs_ipg ; i ++ ) { acct ( ginode ( ) ) ; } } for ( uid = 0 ; uid <= MAXUID && uid >= 0 ; uid ++ ) { ( void ) fread ( & dqbuf , sizeof ( dqblk ) , 1 , qf ) ; if ( feof ( qf ) ) { break ; } fup = lookup ( uid ) ; if ( fup == 0 ) { fup = & zerofileusage ; } if ( dqbuf . dqb_bhardlimit == 0 && dqbuf . dqb_bsoftlimit == 0 && dqbuf . dqb_fhardlimit == 0 && dqbuf . dqb_fsoftlimit == 0 ) { fup -> fu_curfiles = 0 ; fup -> fu_curblocks = 0 ; } if ( dqbuf . dqb_curfiles == fup -> fu_curfiles && dqbuf . dqb_curblocks == fup -> fu_curblocks ) { fup -> fu_curfiles = 0 ; fup -> fu_curblocks = 0 ; continue ; } if ( fup -> fu_curblocks > UINT_MAX ) { if ( pflag || aflag ) { printf ( "%s: " , rawdisk ) ; } printf ( "512-byte blocks allocated to user " ) ; if ( ( pw = getpwuid ( uid ) ) && pw -> pw_name [ 0 ] ) { printf ( "%-10s " , pw -> pw_name ) ; } else { printf ( "#%-9d " , uid ) ; } printf ( " = %lld\n" , fup -> fu_curblocks ) ; printf ( "This exceeds the maximum number of blocks recordable in a quota record.\n" ) ; printf ( "The value will be set to the maximum, which is %lu.\n" , UINT_MAX ) ; fup -> fu_curblocks = UINT_MAX ; } if ( vflag ) { if ( pflag || aflag ) { printf ( "%s: " , rawdisk ) ; } if ( ( pw = getpwuid ( uid ) ) && pw -> pw_name [ 0 ] ) { printf ( "%-10s fixed:" , pw -> pw_name ) ; } else { printf ( "#%-9d fixed:" , uid ) ; } if ( dqbuf . dqb_curfiles != fup -> fu_curfiles ) { printf ( "  files %lu ->%lu" , dqbuf . dqb_curfiles , fup -> fu_curfiles ) ; } if ( dqbuf . dqb_curblocks != fup -> fu_curblocks ) { printf ( "  blocks %lu ->%llu" , dqbuf . dqb_curblocks , fup -> fu_curblocks ) ; } printf ( "\n" ) ; } dqbuf . dqb_curfiles = fup -> fu_curfiles ; dqbuf . dqb_curblocks = fup -> fu_curblocks ; if ( ( quotactl ( Q_SETQUOTA , fsfile , uid , & dqbuf ) < 0 ) && ( errno == ESRCH ) ) { ( void ) fseeko64 ( qf , ( offset_t ) dqoff ( uid ) , 0 ) ; ( void ) fwrite ( & dqbuf , sizeof ( dqblk ) , 1 , qf ) ; ( void ) fflush ( qf ) ; } fup -> fu_curfiles = 0 ; fup -> fu_curblocks = 0 ; } ( void ) fflush ( qf ) ; ( void ) fsync ( fileno ( qf ) ) ; fclose ( qf ) ; close ( fi ) ; return ( 0 ) ; } 