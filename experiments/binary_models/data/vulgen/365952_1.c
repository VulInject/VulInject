static int enable_slot ( struct hotplug_slot * bss_hotplug_slot ) { struct slot * slot = bss_hotplug_slot -> private ; struct pci_bus * new_bus = NULL ; struct pci_dev * dev ; int num_funcs ; int new_ppb = 0 ; int rc ; char * ssdt = NULL ; void pcibios_fixup_device_resources ( pci_dev * ) ; mutex_lock ( & sn_hotplug_mutex ) ; rc = sn_slot_enable ( bss_hotplug_slot , slot -> device_num , & ssdt ) ; if ( rc ) { mutex_unlock ( & sn_hotplug_mutex ) ; return rc ; } if ( ssdt ) { ssdt = __va ( ssdt ) ; } if ( SN_ACPI_BASE_SUPPORT ( ) && ssdt ) { acpi_status ret ; ret = acpi_load_table ( ( acpi_table_header * ) ssdt ) ; if ( ACPI_FAILURE ( ret ) ) { printk ( KERN_ERR "%s: acpi_load_table failed (0x%x)\n" , __func__ , ret ) ; } } num_funcs = pci_scan_slot ( slot -> pci_bus , PCI_DEVFN ( slot -> device_num + 1 , 0 ) ) ; if ( ! num_funcs ) { dev_dbg ( & slot -> pci_bus -> self -> dev , "no device in slot\n" ) ; mutex_unlock ( & sn_hotplug_mutex ) ; return - ENODEV ; } list_for_each_entry ( , , ) { if ( PCI_SLOT ( dev -> devfn ) != slot -> device_num + 1 ) { continue ; } pcibios_fixup_device_resources ( dev ) ; if ( SN_ACPI_BASE_SUPPORT ( ) ) { sn_acpi_slot_fixup ( dev ) ; } else { sn_io_slot_fixup ( dev ) ; } } if ( SN_ACPI_BASE_SUPPORT ( ) && ssdt ) { unsigned long long adr ; struct acpi_device * pdevice ; acpi_handle phandle ; acpi_handle chandle = NULL ; acpi_handle rethandle ; acpi_status ret ; phandle = acpi_device_handle ( PCI_CONTROLLER ( slot -> pci_bus ) -> companion ) ; if ( acpi_bus_get_device ( phandle , & pdevice ) ) { dev_dbg ( & slot -> pci_bus -> self -> dev , "no parent device, assuming NULL\n" ) ; pdevice = NULL ; } acpi_scan_lock_acquire ( ) ; for ( ; ; ) { rethandle = NULL ; ret = acpi_get_next_object ( ACPI_TYPE_DEVICE , phandle , chandle , & rethandle ) ; if ( ret == AE_NOT_FOUND || rethandle == NULL ) { break ; } chandle = rethandle ; ret = acpi_evaluate_integer ( chandle , METHOD_NAME__ADR , NULL , & adr ) ; if ( ACPI_SUCCESS ( ret ) && ( adr >> 16 ) == ( slot -> device_num + 1 ) ) { ret = acpi_bus_scan ( chandle ) ; if ( ACPI_FAILURE ( ret ) ) { printk ( KERN_ERR "%s: acpi_bus_scan failed (0x%x) for slot %d func %d\n" , __func__ , ret , ( int ) ( adr >> 16 ) , ( int ) ( adr & 0xffff ) ) ; } } } acpi_scan_lock_release ( ) ; } pci_lock_rescan_remove ( ) ; pci_bus_add_devices ( slot -> pci_bus ) ; if ( new_ppb ) { pci_bus_add_devices ( new_bus ) ; } pci_unlock_rescan_remove ( ) ; mutex_unlock ( & sn_hotplug_mutex ) ; if ( rc == 0 ) { dev_dbg ( & slot -> pci_bus -> self -> dev , "insert operation successful\n" ) ; } else { dev_dbg ( & slot -> pci_bus -> self -> dev , "insert operation failed rc = %d\n" , rc ) ; } return rc ; } 