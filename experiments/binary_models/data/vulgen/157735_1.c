static void ace_fsm_dostate ( struct ace_device * ace ) { struct request * req ; u32 status ; u16 val ; int count ; dev_dbg ( ace -> dev , "fsm_state=%i, id_req_count=%i\n" , ace -> fsm_state , ace -> id_req_count ) ; status = ace_in32 ( ace , ACE_STATUS ) ; if ( ( status & ACE_STATUS_CFDETECT ) == 0 ) { ace -> fsm_state = ACE_FSM_STATE_IDLE ; ace -> media_change = 1 ; set_capacity ( ace -> gd , 0 ) ; dev_info ( ace -> dev , "No CF in slot\n" ) ; if ( ace -> req ) { __blk_end_request_all ( ace -> req , - EIO ) ; ace -> req = NULL ; } while ( ( req = blk_fetch_request ( ace -> queue ) ) != NULL ) { __blk_end_request_all ( req , - EIO ) ; } ace -> fsm_state = ACE_FSM_STATE_IDLE ; ace -> id_result = - EIO ; while ( ace -> id_req_count ) { complete ( & ace -> id_completion ) ; ace -> id_req_count -- ; } } switch ( ace -> fsm_state ) { case ACE_FSM_STATE_IDLE : if ( ace -> id_req_count || ace_get_next_request ( ace -> queue ) ) { ace -> fsm_iter_num ++ ; ace -> fsm_state = ACE_FSM_STATE_REQ_LOCK ; mod_timer ( & ace -> stall_timer , jiffies + HZ ) ; if ( ! timer_pending ( & ace -> stall_timer ) ) { add_timer ( & ace -> stall_timer ) ; } break ; } del_timer ( & ace -> stall_timer ) ; break ; case ACE_FSM_STATE_REQ_LOCK : if ( ace_in ( ace , ACE_STATUS ) & ACE_STATUS_MPULOCK ) { ace -> fsm_state = ACE_FSM_STATE_WAIT_CFREADY ; break ; } val = ace_in ( ace , ACE_CTRL ) ; ace_out ( ace , ACE_CTRL , val | ACE_CTRL_LOCKREQ ) ; ace -> fsm_state = ACE_FSM_STATE_WAIT_LOCK ; break ; case ACE_FSM_STATE_WAIT_LOCK : if ( ace_in ( ace , ACE_STATUS ) & ACE_STATUS_MPULOCK ) { ace -> fsm_state = ACE_FSM_STATE_WAIT_CFREADY ; break ; } ace_fsm_yield ( ace ) ; break ; case ACE_FSM_STATE_WAIT_CFREADY : status = ace_in32 ( ace , ACE_STATUS ) ; if ( ! ( status & ACE_STATUS_RDYFORCFCMD ) || ( status & ACE_STATUS_CFBSY ) ) { ace_fsm_yield ( ace ) ; break ; } if ( ace -> id_req_count ) { ace -> fsm_state = ACE_FSM_STATE_IDENTIFY_PREPARE ; } else { ace -> fsm_state = ACE_FSM_STATE_REQ_PREPARE ; } break ; case ACE_FSM_STATE_IDENTIFY_PREPARE : ace -> fsm_task = ACE_TASK_IDENTIFY ; ace -> data_ptr = ace -> cf_id ; ace -> data_count = ACE_BUF_PER_SECTOR ; ace_out ( ace , ACE_SECCNTCMD , ACE_SECCNTCMD_IDENTIFY ) ; val = ace_in ( ace , ACE_CTRL ) ; ace_out ( ace , ACE_CTRL , val | ACE_CTRL_CFGRESET ) ; ace -> fsm_state = ACE_FSM_STATE_IDENTIFY_TRANSFER ; ace_fsm_yieldirq ( ace ) ; break ; case ACE_FSM_STATE_IDENTIFY_TRANSFER : status = ace_in32 ( ace , ACE_STATUS ) ; if ( status & ACE_STATUS_CFBSY ) { dev_dbg ( ace -> dev , "CFBSY set; t=%i iter=%i dc=%i\n" , ace -> fsm_task , ace -> fsm_iter_num , ace -> data_count ) ; ace_fsm_yield ( ace ) ; break ; } if ( ! ( status & ACE_STATUS_DATABUFRDY ) ) { ace_fsm_yield ( ace ) ; break ; } ace -> reg_ops -> datain ( ace ) ; ace -> data_count -- ; if ( ace -> data_count != 0 ) { ace_fsm_yieldirq ( ace ) ; break ; } dev_dbg ( ace -> dev , "identify finished\n" ) ; ace -> fsm_state = ACE_FSM_STATE_IDENTIFY_COMPLETE ; break ; case ACE_FSM_STATE_IDENTIFY_COMPLETE : ace_fix_driveid ( ace -> cf_id ) ; ace_dump_mem ( ace -> cf_id , 512 ) ; if ( ace -> data_result ) { ace -> media_change = 1 ; set_capacity ( ace -> gd , 0 ) ; dev_err ( ace -> dev , "error fetching CF id (%i)\n" , ace -> data_result ) ; } else { ace -> media_change = 0 ; set_capacity ( ace -> gd , ata_id_u32 ( ace -> cf_id , ATA_ID_LBA_CAPACITY ) ) ; dev_info ( ace -> dev , "capacity: %i sectors\n" , ata_id_u32 ( ace -> cf_id , ATA_ID_LBA_CAPACITY ) ) ; } ace -> fsm_state = ACE_FSM_STATE_IDLE ; ace -> id_result = ace -> data_result ; while ( ace -> id_req_count ) { complete ( & ace -> id_completion ) ; ace -> id_req_count -- ; } break ; case ACE_FSM_STATE_REQ_PREPARE : req = ace_get_next_request ( ace -> queue ) ; if ( ! req ) { ace -> fsm_state = ACE_FSM_STATE_IDLE ; break ; } blk_start_request ( req ) ; dev_dbg ( ace -> dev , "request: sec=%llx hcnt=%x, ccnt=%x, dir=%i\n" , ( unsigned long long ) blk_rq_pos ( req ) , blk_rq_sectors ( req ) , blk_rq_cur_sectors ( req ) , rq_data_dir ( req ) ) ; ace -> req = req ; ace -> data_ptr = bio_data ( req -> bio ) ; ace -> data_count = blk_rq_cur_sectors ( req ) * ACE_BUF_PER_SECTOR ; ace_out32 ( ace , ACE_MPULBA , blk_rq_pos ( req ) & 0x0FFFFFFF ) ; count = blk_rq_sectors ( req ) ; if ( rq_data_dir ( req ) ) { dev_dbg ( ace -> dev , "write data\n" ) ; ace -> fsm_task = ACE_TASK_WRITE ; ace_out ( ace , ACE_SECCNTCMD , count | ACE_SECCNTCMD_WRITE_DATA ) ; } else { dev_dbg ( ace -> dev , "read data\n" ) ; ace -> fsm_task = ACE_TASK_READ ; ace_out ( ace , ACE_SECCNTCMD , count | ACE_SECCNTCMD_READ_DATA ) ; } val = ace_in ( ace , ACE_CTRL ) ; ace_out ( ace , ACE_CTRL , val | ACE_CTRL_CFGRESET ) ; ace -> fsm_state = ACE_FSM_STATE_REQ_TRANSFER ; if ( ace -> fsm_task == ACE_TASK_READ ) { ace_fsm_yieldirq ( ace ) ; } break ; case ACE_FSM_STATE_REQ_TRANSFER : status = ace_in32 ( ace , ACE_STATUS ) ; if ( status & ACE_STATUS_CFBSY ) { dev_dbg ( ace -> dev , "CFBSY set; t=%i iter=%i c=%i dc=%i irq=%i\n" , ace -> fsm_task , ace -> fsm_iter_num , blk_rq_cur_sectors ( ace -> req ) * 16 , ace -> data_count , ace -> in_irq ) ; ace_fsm_yield ( ace ) ; break ; } if ( ! ( status & ACE_STATUS_DATABUFRDY ) ) { dev_dbg ( ace -> dev , "DATABUF not set; t=%i iter=%i c=%i dc=%i irq=%i\n" , ace -> fsm_task , ace -> fsm_iter_num , blk_rq_cur_sectors ( ace -> req ) * 16 , ace -> data_count , ace -> in_irq ) ; ace_fsm_yieldirq ( ace ) ; break ; } if ( ace -> fsm_task == ACE_TASK_WRITE ) { ace -> reg_ops -> dataout ( ace ) ; } else { ace -> reg_ops -> datain ( ace ) ; } ace -> data_count -- ; if ( ace -> data_count != 0 ) { ace_fsm_yieldirq ( ace ) ; break ; } if ( __blk_end_request_cur ( ace -> req , 0 ) ) { ace -> data_ptr = bio_data ( ace -> req -> bio ) ; ace -> data_count = blk_rq_cur_sectors ( ace -> req ) * 16 ; ace_fsm_yieldirq ( ace ) ; break ; } ace -> fsm_state = ACE_FSM_STATE_REQ_COMPLETE ; break ; case ACE_FSM_STATE_REQ_COMPLETE : ace -> req = NULL ; ace -> fsm_state = ACE_FSM_STATE_IDLE ; break ; default : ace -> fsm_state = ACE_FSM_STATE_IDLE ; break ; } } 