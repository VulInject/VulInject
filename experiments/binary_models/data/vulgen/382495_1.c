static void dma_block_input ( struct net_device * dev , int count , struct sk_buff * skb , int ring_offset ) { unsigned int nic_base = dev -> base_addr ; int xfer_count = count ; char * buf = skb -> data ; struct ei_device * ei_local = netdev_priv ( dev ) ; if ( ( netif_msg_rx_status ( ei_local ) ) && ( count != 4 ) ) { netdev_dbg ( dev , "[bi=%d]\n" , count + 4 ) ; } if ( ei_status . dmaing ) { netdev_err ( dev , "DMAing conflict in dma_block_input." "[DMAstat:%1x][irqlock:%1x]\n" , ei_status . dmaing , ei_status . irqlock ) ; return ; } ei_status . dmaing |= 0x01 ; outb_p ( E8390_NODMA + E8390_PAGE0 + E8390_START , nic_base + PCNET_CMD ) ; outb_p ( count & 0xff , nic_base + EN0_RCNTLO ) ; outb_p ( count >> 8 , nic_base + EN0_RCNTHI ) ; outb_p ( ring_offset & 0xff , nic_base + EN0_RSARLO ) ; outb_p ( ring_offset >> 8 , nic_base + EN0_RSARHI ) ; outb_p ( E8390_RREAD + E8390_START , nic_base + PCNET_CMD ) ; insw ( nic_base + PCNET_DATAPORT , buf , count >> 1 ) ; if ( netif_msg_rx_status ( ei_local ) ) { int addr , tries = 20 ; { int high = inb_p ( nic_base + EN0_RSARHI ) ; int low = inb_p ( nic_base + EN0_RSARLO ) ; addr = ( high << 8 ) + low ; if ( ( ( ring_offset + xfer_count ) & 0xff ) == ( addr & 0xff ) ) { break ; } } -- tries > 0 ; if ( tries <= 0 ) { netdev_notice ( dev , "RX transfer address mismatch," "%#4.4x (expected) vs. %#4.4x (actual).\n" , ring_offset + xfer_count , addr ) ; } } outb_p ( ENISR_RDC , nic_base + EN0_ISR ) ; ei_status . dmaing &= ~ 0x01 ; } 