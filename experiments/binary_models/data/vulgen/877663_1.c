static int usba_ep_queue ( struct usb_ep * _ep , struct usb_request * _req , gfp_t gfp_flags ) { struct usba_request * req = to_usba_req ( _req ) ; struct usba_ep * ep = to_usba_ep ( _ep ) ; struct usba_udc * udc = ep -> udc ; unsigned long flags ; int ret ; DBG ( DBG_GADGET | DBG_QUEUE | DBG_REQ , "%s: queue req %p, len %u\n" , ep -> ep . name , req , _req -> length ) ; if ( ! udc -> driver || udc -> gadget . speed == USB_SPEED_UNKNOWN || ! ep -> ep . desc ) { return - ESHUTDOWN ; } req -> using_dma = 0 ; req -> last_transaction = 0 ; _req -> status = - EINPROGRESS ; _req -> actual = 0 ; if ( ep -> can_dma ) { return queue_dma ( udc , ep , req , gfp_flags ) ; } ret = - ESHUTDOWN ; spin_lock_irqsave ( & udc -> lock , flags ) ; if ( ep -> ep . desc ) { list_add_tail ( & req -> queue , & ep -> queue ) ; if ( ( ! ep_is_control ( ep ) && ep -> is_in ) || ( ep_is_control ( ep ) && ( ep -> state == DATA_STAGE_IN || ep -> state == STATUS_STAGE_IN ) ) ) { usba_ep_writel ( ep , CTL_ENB , USBA_TX_PK_RDY ) ; } else { usba_ep_writel ( ep , CTL_ENB , USBA_RX_BK_RDY ) ; } ret = 0 ; } spin_unlock_irqrestore ( & udc -> lock , flags ) ; return ret ; } 