int combine_rules ( struct pfctl * pf , struct superblock * block ) { struct pf_opt_rule * p1 , * p2 , * por_next ; int src_eq , dst_eq ; TAILQ_FOREACH ( , , ) { for ( p2 = TAILQ_NEXT ( p1 , por_entry ) ; p2 ; p2 = por_next ) { por_next = TAILQ_NEXT ( p2 , por_entry ) ; src_eq = addrs_equal ( & p1 -> por_rule . src , & p2 -> por_rule . src ) ; dst_eq = addrs_equal ( & p1 -> por_rule . dst , & p2 -> por_rule . dst ) ; if ( src_eq && ! dst_eq && p1 -> por_src_tbl == NULL && p2 -> por_dst_tbl == NULL && p2 -> por_src_tbl == NULL && rules_combineable ( & p1 -> por_rule , & p2 -> por_rule ) && addrs_combineable ( & p1 -> por_rule . dst , & p2 -> por_rule . dst ) ) { DEBUG ( "can combine rules  nr%d = nr%d" , p1 -> por_rule . nr , p2 -> por_rule . nr ) ; if ( p1 -> por_dst_tbl == NULL && add_opt_table ( pf , & p1 -> por_dst_tbl , p1 -> por_rule . af , & p1 -> por_rule . dst , NULL ) ) { return ( 1 ) ; } if ( add_opt_table ( pf , & p1 -> por_dst_tbl , p1 -> por_rule . af , & p2 -> por_rule . dst , NULL ) ) { return ( 1 ) ; } if ( p1 -> por_dst_tbl -> pt_rulecount >= TABLE_THRESHOLD ) { TAILQ_REMOVE ( & block -> sb_rules , p2 , por_entry ) ; } else { p2 -> por_dst_tbl = pf_opt_table_ref ( p1 -> por_dst_tbl ) ; } } if ( ! src_eq && dst_eq && p1 -> por_dst_tbl == NULL && p2 -> por_src_tbl == NULL && p2 -> por_dst_tbl == NULL && rules_combineable ( & p1 -> por_rule , & p2 -> por_rule ) && addrs_combineable ( & p1 -> por_rule . src , & p2 -> por_rule . src ) ) { DEBUG ( "can combine rules  nr%d = nr%d" , p1 -> por_rule . nr , p2 -> por_rule . nr ) ; if ( p1 -> por_src_tbl == NULL && add_opt_table ( pf , & p1 -> por_src_tbl , p1 -> por_rule . af , & p1 -> por_rule . src , NULL ) ) { return ( 1 ) ; } if ( add_opt_table ( pf , & p1 -> por_src_tbl , p1 -> por_rule . af , & p2 -> por_rule . src , NULL ) ) { return ( 1 ) ; } if ( p1 -> por_src_tbl -> pt_rulecount >= TABLE_THRESHOLD ) { TAILQ_REMOVE ( & block -> sb_rules , p2 , por_entry ) ; free ( p2 ) ; } else { p2 -> por_src_tbl = pf_opt_table_ref ( p1 -> por_src_tbl ) ; } } } } for ( p1 = TAILQ_FIRST ( & block -> sb_rules ) ; p1 ; p1 = por_next ) { por_next = TAILQ_NEXT ( p1 , por_entry ) ; assert ( p1 -> por_src_tbl == NULL || p1 -> por_dst_tbl == NULL ) ; if ( p1 -> por_src_tbl && p1 -> por_src_tbl -> pt_rulecount >= TABLE_THRESHOLD ) { if ( p1 -> por_src_tbl -> pt_generated ) { TAILQ_REMOVE ( & block -> sb_rules , p1 , por_entry ) ; free ( p1 ) ; continue ; } p1 -> por_src_tbl -> pt_generated = 1 ; if ( ( pf -> opts & PF_OPT_NOACTION ) == 0 && pf_opt_create_table ( pf , p1 -> por_src_tbl ) ) { return ( 1 ) ; } pf -> tdirty = 1 ; if ( pf -> opts & PF_OPT_VERBOSE ) { print_tabledef ( p1 -> por_src_tbl -> pt_name , PFR_TFLAG_CONST , 1 , & p1 -> por_src_tbl -> pt_nodes ) ; } memset ( & p1 -> por_rule . src . addr , 0 , sizeof ( p1 -> por_rule . src . addr ) ) ; p1 -> por_rule . src . addr . type = PF_ADDR_TABLE ; strlcpy ( p1 -> por_rule . src . addr . v . tblname , p1 -> por_src_tbl -> pt_name , sizeof ( p1 -> por_rule . src . addr . v . tblname ) ) ; pfr_buf_clear ( p1 -> por_src_tbl -> pt_buf ) ; free ( p1 -> por_src_tbl -> pt_buf ) ; p1 -> por_src_tbl -> pt_buf = NULL ; } if ( p1 -> por_dst_tbl && p1 -> por_dst_tbl -> pt_rulecount >= TABLE_THRESHOLD ) { if ( p1 -> por_dst_tbl -> pt_generated ) { TAILQ_REMOVE ( & block -> sb_rules , p1 , por_entry ) ; free ( p1 ) ; continue ; } p1 -> por_dst_tbl -> pt_generated = 1 ; if ( ( pf -> opts & PF_OPT_NOACTION ) == 0 && pf_opt_create_table ( pf , p1 -> por_dst_tbl ) ) { return ( 1 ) ; } pf -> tdirty = 1 ; if ( pf -> opts & PF_OPT_VERBOSE ) { print_tabledef ( p1 -> por_dst_tbl -> pt_name , PFR_TFLAG_CONST , 1 , & p1 -> por_dst_tbl -> pt_nodes ) ; } memset ( & p1 -> por_rule . dst . addr , 0 , sizeof ( p1 -> por_rule . dst . addr ) ) ; p1 -> por_rule . dst . addr . type = PF_ADDR_TABLE ; strlcpy ( p1 -> por_rule . dst . addr . v . tblname , p1 -> por_dst_tbl -> pt_name , sizeof ( p1 -> por_rule . dst . addr . v . tblname ) ) ; pfr_buf_clear ( p1 -> por_dst_tbl -> pt_buf ) ; free ( p1 -> por_dst_tbl -> pt_buf ) ; p1 -> por_dst_tbl -> pt_buf = NULL ; } } return ( 0 ) ; } 