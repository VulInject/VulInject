struct parport * parport_register_port ( unsigned long base , int irq , int dma , struct parport_operations * ops ) { struct list_head * l ; struct parport * tmp ; int num ; int device ; char * name ; int ret ; tmp = kzalloc ( sizeof ( parport ) , GFP_KERNEL ) ; if ( ! tmp ) { return NULL ; } tmp -> base = base ; tmp -> irq = irq ; tmp -> dma = dma ; tmp -> muxport = tmp -> daisy = tmp -> muxsel = - 1 ; tmp -> modes = 0 ; INIT_LIST_HEAD ( & tmp -> list ) ; tmp -> flags = 0 ; tmp -> ops = ops ; tmp -> physport = tmp ; memset ( tmp -> probe_info , 0 , 5 * sizeof ( parport_device_info ) ) ; rwlock_init ( & tmp -> cad_lock ) ; spin_lock_init ( & tmp -> waitlist_lock ) ; spin_lock_init ( & tmp -> pardevice_lock ) ; tmp -> ieee1284 . mode = IEEE1284_MODE_COMPAT ; tmp -> ieee1284 . phase = IEEE1284_PH_FWD_IDLE ; sema_init ( & tmp -> ieee1284 . irq , 0 ) ; tmp -> spintime = parport_default_spintime ; atomic_set ( & tmp -> ref_count , 1 ) ; INIT_LIST_HEAD ( & tmp -> full_list ) ; name = kmalloc ( 15 , GFP_KERNEL ) ; if ( ! name ) { kfree ( tmp ) ; return NULL ; } spin_lock ( & full_list_lock ) ; for ( l = all_ports . next , num = 0 ; l != & all_ports ; l = l -> next , num ++ ) { struct parport * p = list_entry ( l , parport , full_list ) ; if ( p -> number != num ) { break ; } } tmp -> portnum = tmp -> number = num ; list_add_tail ( & tmp -> full_list , l ) ; spin_unlock ( & full_list_lock ) ; sprintf ( name , "parport%d" , tmp -> portnum = tmp -> number ) ; tmp -> name = name ; tmp -> bus_dev . bus = & parport_bus_type ; tmp -> bus_dev . release = free_port ; dev_set_name ( & tmp -> bus_dev , name ) ; tmp -> bus_dev . type = & parport_device_type ; for ( device = 0 ; device < 5 ; device ++ ) { tmp -> probe_info [ device ] . class = PARPORT_CLASS_LEGACY ; } tmp -> waithead = tmp -> waittail = NULL ; ret = device_register ( & tmp -> bus_dev ) ; if ( ret ) { put_device ( & tmp -> bus_dev ) ; return NULL ; } return tmp ; } 