AppendState * ExecInitAppend ( Append * node , EState * estate , int eflags ) { AppendState * appendstate = makeNode ( AppendState ) ; PlanState * * appendplanstates ; Bitmapset * validsubplans ; Bitmapset * asyncplans ; int nplans ; int nasyncplans ; int firstvalid ; int i , j ; Assert ( ! ( eflags & EXEC_FLAG_MARK ) ) ; appendstate -> ps . plan = ( Plan * ) node ; appendstate -> ps . state = estate ; appendstate -> ps . ExecProcNode = ExecAppend ; appendstate -> as_whichplan = INVALID_SUBPLAN_INDEX ; appendstate -> as_syncdone = false ; appendstate -> as_begun = false ; if ( node -> part_prune_index >= 0 ) { PartitionPruneState * prunestate ; prunestate = ExecInitPartitionPruning ( & appendstate -> ps , list_length ( node -> appendplans ) , node -> part_prune_index , node -> apprelids , & validsubplans ) ; appendstate -> as_prune_state = prunestate ; nplans = bms_num_members ( validsubplans ) ; if ( ! prunestate -> do_exec_prune && nplans > 0 ) { appendstate -> as_valid_subplans = bms_add_range ( NULL , 0 , nplans - 1 ) ; } } else { nplans = list_length ( node -> appendplans ) ; Assert ( nplans > 0 ) ; appendstate -> as_valid_subplans = validsubplans = bms_add_range ( NULL , 0 , nplans - 1 ) ; appendstate -> as_prune_state = NULL ; } ExecInitResultTupleSlotTL ( & appendstate -> ps , & TTSOpsVirtual ) ; appendstate -> ps . resultopsset = true ; appendstate -> ps . resultopsfixed = false ; appendplanstates = ( PlanState * * ) palloc ( nplans * sizeof ( PlanState * ) ) ; j = 0 ; asyncplans = NULL ; nasyncplans = 0 ; firstvalid = nplans ; i = - 1 ; while ( ( i = bms_next_member ( validsubplans , i ) ) >= 0 ) { Plan * initNode = ( Plan * ) list_nth ( node -> appendplans , i ) ; if ( initNode -> async_capable && estate -> es_epq_active == NULL ) { asyncplans = bms_add_member ( asyncplans , j ) ; nasyncplans ++ ; } if ( i >= node -> first_partial_plan && j < firstvalid ) { firstvalid = j ; } appendplanstates [ j ++ ] = ExecInitNode ( initNode , estate , eflags ) ; } appendstate -> as_first_partial_plan = firstvalid ; appendstate -> appendplans = appendplanstates ; appendstate -> as_nplans = nplans ; appendstate -> as_asyncplans = asyncplans ; appendstate -> as_nasyncplans = nasyncplans ; appendstate -> as_asyncrequests = NULL ; appendstate -> as_asyncresults = NULL ; appendstate -> as_nasyncresults = 0 ; appendstate -> as_nasyncremain = 0 ; appendstate -> as_needrequest = NULL ; appendstate -> as_eventset = NULL ; appendstate -> as_valid_asyncplans = NULL ; if ( nasyncplans > 0 ) { appendstate -> as_asyncrequests = ( AsyncRequest * * ) palloc0 ( nplans * sizeof ( AsyncRequest * ) ) ; i = - 1 ; while ( ( i = bms_next_member ( asyncplans , i ) ) >= 0 ) { AsyncRequest * areq ; areq = palloc ( sizeof ( AsyncRequest ) ) ; areq -> requestor = ( PlanState * ) appendstate ; areq -> requestee = appendplanstates [ i ] ; areq -> request_index = i ; areq -> callback_pending = false ; areq -> request_complete = false ; areq -> result = NULL ; appendstate -> as_asyncrequests [ i ] = areq ; } appendstate -> as_asyncresults = ( TupleTableSlot * * ) palloc0 ( nasyncplans * sizeof ( TupleTableSlot * ) ) ; } appendstate -> ps . ps_ProjInfo = NULL ; appendstate -> choose_next_subplan = choose_next_subplan_locally ; return appendstate ; } 