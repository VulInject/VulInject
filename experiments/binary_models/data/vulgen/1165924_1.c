pascal_type_print_base ( , , , ) { int i ; int len ; int lastval ; { s_none , s_public , s_private , s_protected } , section_type QUIT ; wrap_here ( "    " ) ; if ( type == NULL ) { fputs_filtered ( "<type unknown>" , stream ) ; return ; } if ( ( TYPE_CODE ( type ) == TYPE_CODE_PTR ) && ( TYPE_CODE ( TYPE_TARGET_TYPE ( type ) ) == TYPE_CODE_VOID ) ) { fputs_filtered ( TYPE_NAME ( type ) ?TYPE_NAME ( type ) : "pointer" , stream ) ; return ; } if ( show <= 0 && TYPE_NAME ( type ) != NULL ) { return ; } CHECK_TYPEDEF ( type ) ; switch ( TYPE_CODE ( type ) ) { case TYPE_CODE_TYPEDEF : case TYPE_CODE_PTR : case TYPE_CODE_MEMBER : case TYPE_CODE_REF : pascal_type_print_base ( TYPE_TARGET_TYPE ( type ) , stream , show , level ) ; break ; case TYPE_CODE_ARRAY : pascal_print_type ( TYPE_TARGET_TYPE ( type ) , NULL , stream , 0 , 0 ) ; break ; case TYPE_CODE_FUNC : case TYPE_CODE_METHOD : break ; case TYPE_CODE_STRUCT : if ( TYPE_TAG_NAME ( type ) != NULL ) { fputs_filtered ( TYPE_TAG_NAME ( type ) , stream ) ; fputs_filtered ( " = " , stream ) ; } if ( HAVE_CPLUS_STRUCT ( type ) ) { fprintf_filtered ( stream , "class " ) ; } else { fprintf_filtered ( stream , "record " ) ; } struct_union case TYPE_CODE_UNION : if ( TYPE_TAG_NAME ( type ) != NULL ) { fputs_filtered ( TYPE_TAG_NAME ( type ) , stream ) ; fputs_filtered ( " = " , stream ) ; } fprintf_filtered ( stream , "case<?>of " ) ; struct_union wrap_here ( "    " ) ; if ( show < 0 ) { if ( TYPE_TAG_NAME ( type ) == NULL ) { fprintf_filtered ( stream , "{...}" ) ; } } if ( show > 0 || TYPE_TAG_NAME ( type ) == NULL ) { pascal_type_print_derivation_info ( stream , type ) ; fprintf_filtered ( stream , "\n" ) ; if ( ( TYPE_NFIELDS ( type ) == 0 ) && ( TYPE_NFN_FIELDS ( type ) == 0 ) ) { if ( TYPE_STUB ( type ) ) { fprintfi_filtered ( level + 4 , stream , "<incomplete type>\n" ) ; } else { fprintfi_filtered ( level + 4 , stream , "<no data fields>\n" ) ; } } section_type = s_none ; len = TYPE_NFIELDS ( type ) ; for ( i = TYPE_N_BASECLASSES ( type ) ; i < len ; i ++ ) { QUIT ; if ( DEPRECATED_STREQN ( TYPE_FIELD_NAME ( type , i ) , "_vptr" , 5 ) && is_cplus_marker ( ( TYPE_FIELD_NAME ( type , i ) ) [ 5 ] ) ) { continue ; } if ( HAVE_CPLUS_STRUCT ( type ) ) { if ( TYPE_FIELD_PROTECTED ( type , i ) ) { if ( section_type != s_protected ) { section_type = s_protected ; fprintfi_filtered ( level + 2 , stream , "protected\n" ) ; } } if ( TYPE_FIELD_PRIVATE ( type , i ) ) { if ( section_type != s_private ) { section_type = s_private ; fprintfi_filtered ( level + 2 , stream , "private\n" ) ; } } else { if ( section_type != s_public ) { section_type = s_public ; fprintfi_filtered ( level + 2 , stream , "public\n" ) ; } } } print_spaces_filtered ( level + 4 , stream ) ; if ( TYPE_FIELD_STATIC ( type , i ) ) { fprintf_filtered ( stream , "static " ) ; } pascal_print_type ( TYPE_FIELD_TYPE ( type , i ) , TYPE_FIELD_NAME ( type , i ) , stream , show - 1 , level + 4 ) ; if ( ! TYPE_FIELD_STATIC ( type , i ) && TYPE_FIELD_PACKED ( type , i ) ) { fprintf_filtered ( stream , " : %d" , TYPE_FIELD_BITSIZE ( type , i ) ) ; } fprintf_filtered ( stream , ";\n" ) ; } len = TYPE_NFN_FIELDS ( type ) ; if ( len && section_type != s_none ) { fprintf_filtered ( stream , "\n" ) ; } for ( i = 0 ; i < len ; i ++ ) { struct fn_field * f = TYPE_FN_FIELDLIST1 ( type , i ) ; int j , len2 = TYPE_FN_FIELDLIST_LENGTH ( type , i ) ; char * method_name = TYPE_FN_FIELDLIST_NAME ( type , i ) ; char * name = type_name_no_tag ( type ) ; for ( j = 0 ; j < len2 ; j ++ ) { char * physname = TYPE_FN_FIELD_PHYSNAME ( f , j ) ; int is_constructor = DEPRECATED_STREQN ( physname , "__ct__" , 6 ) ; int is_destructor = DEPRECATED_STREQN ( physname , "__dt__" , 6 ) ; QUIT ; if ( TYPE_FN_FIELD_PROTECTED ( f , j ) ) { if ( section_type != s_protected ) { section_type = s_protected ; fprintfi_filtered ( level + 2 , stream , "protected\n" ) ; } } if ( TYPE_FN_FIELD_PRIVATE ( f , j ) ) { if ( section_type != s_private ) { section_type = s_private ; fprintfi_filtered ( level + 2 , stream , "private\n" ) ; } } else { if ( section_type != s_public ) { section_type = s_public ; fprintfi_filtered ( level + 2 , stream , "public\n" ) ; } } print_spaces_filtered ( level + 4 , stream ) ; if ( TYPE_FN_FIELD_STATIC_P ( f , j ) ) { fprintf_filtered ( stream , "static " ) ; } if ( TYPE_TARGET_TYPE ( TYPE_FN_FIELD_TYPE ( f , j ) ) == 0 ) { fprintf_filtered ( stream , "<undefined type>%s;\n" , TYPE_FN_FIELD_PHYSNAME ( f , j ) ) ; break ; } if ( is_constructor ) { fprintf_filtered ( stream , "constructor " ) ; } if ( is_destructor ) { fprintf_filtered ( stream , "destructor  " ) ; } if ( TYPE_TARGET_TYPE ( TYPE_FN_FIELD_TYPE ( f , j ) ) != 0 && TYPE_CODE ( TYPE_TARGET_TYPE ( TYPE_FN_FIELD_TYPE ( f , j ) ) ) != TYPE_CODE_VOID ) { fprintf_filtered ( stream , "function  " ) ; } else { fprintf_filtered ( stream , "procedure " ) ; } pascal_type_print_method_args ( physname , method_name , stream ) ; if ( TYPE_TARGET_TYPE ( TYPE_FN_FIELD_TYPE ( f , j ) ) != 0 && TYPE_CODE ( TYPE_TARGET_TYPE ( TYPE_FN_FIELD_TYPE ( f , j ) ) ) != TYPE_CODE_VOID ) { fputs_filtered ( " : " , stream ) ; type_print ( TYPE_TARGET_TYPE ( TYPE_FN_FIELD_TYPE ( f , j ) ) , "" , stream , - 1 ) ; } if ( TYPE_FN_FIELD_VIRTUAL_P ( f , j ) ) { fprintf_filtered ( stream , "; virtual" ) ; } fprintf_filtered ( stream , ";\n" ) ; } } fprintfi_filtered ( level , stream , "end" ) ; } break ; case TYPE_CODE_ENUM : if ( TYPE_TAG_NAME ( type ) != NULL ) { fputs_filtered ( TYPE_TAG_NAME ( type ) , stream ) ; if ( show > 0 ) { fputs_filtered ( " " , stream ) ; } } fprintf_filtered ( stream , " = " ) ; wrap_here ( "    " ) ; if ( show < 0 ) { if ( TYPE_TAG_NAME ( type ) == NULL ) { fprintf_filtered ( stream , "(...)" ) ; } } if ( show > 0 || TYPE_TAG_NAME ( type ) == NULL ) { fprintf_filtered ( stream , "(" ) ; len = TYPE_NFIELDS ( type ) ; lastval = 0 ; for ( i = 0 ; i < len ; i ++ ) { QUIT ; if ( i ) { fprintf_filtered ( stream , ", " ) ; } wrap_here ( "    " ) ; fputs_filtered ( TYPE_FIELD_NAME ( type , i ) , stream ) ; if ( lastval != TYPE_FIELD_BITPOS ( type , i ) ) { fprintf_filtered ( stream , " := %d" , TYPE_FIELD_BITPOS ( type , i ) ) ; lastval = TYPE_FIELD_BITPOS ( type , i ) ; } lastval ++ ; } fprintf_filtered ( stream , ")" ) ; } break ; case TYPE_CODE_VOID : fprintf_filtered ( stream , "void" ) ; break ; case TYPE_CODE_UNDEF : fprintf_filtered ( stream , "record<unknown>" ) ; break ; case TYPE_CODE_ERROR : fprintf_filtered ( stream , "<unknown type>" ) ; break ; case TYPE_CODE_RANGE : { struct type * target = TYPE_TARGET_TYPE ( type ) ; if ( target == NULL ) { target = builtin_type_long ; } print_type_scalar ( target , TYPE_LOW_BOUND ( type ) , stream ) ; fputs_filtered ( ".." , stream ) ; print_type_scalar ( target , TYPE_HIGH_BOUND ( type ) , stream ) ; } break ; case TYPE_CODE_SET : fputs_filtered ( "set of " , stream ) ; pascal_print_type ( TYPE_INDEX_TYPE ( type ) , "" , stream , show - 1 , level ) ; break ; case TYPE_CODE_BITSTRING : fputs_filtered ( "BitString" , stream ) ; break ; case TYPE_CODE_STRING : fputs_filtered ( "String" , stream ) ; break ; default : if ( TYPE_NAME ( type ) != NULL ) { fputs_filtered ( TYPE_NAME ( type ) , stream ) ; } else { fprintf_filtered ( stream , "<invalid unnamed pascal type code %d>" , TYPE_CODE ( type ) ) ; } break ; } } 