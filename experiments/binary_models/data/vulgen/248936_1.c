enum sctp_disposition sctp_sf_do_5_1B_init ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const union sctp_subtype type , void * arg , struct sctp_cmd_seq * commands ) { struct sctp_chunk * chunk = arg , * repl , * err_chunk ; struct sctp_unrecognized_param * unk_param ; struct sctp_association * new_asoc ; struct sctp_packet * packet ; int len ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_init_chunk ) ) ) { return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } if ( ep == sctp_sk ( net -> sctp . ctl_sock ) -> ep ) { SCTP_INC_STATS ( net , SCTP_MIB_OUTOFBLUES ) ; return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; } if ( chunk -> sctp_hdr -> vtag != 0 ) { return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; } if ( sctp_sstate ( ep -> base . sk , CLOSING ) ) { return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; } err_chunk = NULL ; if ( ! sctp_verify_init ( net , ep , asoc , chunk -> chunk_hdr -> type , ( sctp_init_chunk * ) chunk -> chunk_hdr , chunk , & err_chunk ) ) { if ( err_chunk ) { packet = sctp_abort_pkt_new ( net , ep , asoc , arg , ( __u8 * ) ( err_chunk -> chunk_hdr ) + sizeof ( sctp_chunkhdr ) , ntohs ( err_chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr ) ) ; sctp_chunk_free ( err_chunk ) ; if ( packet ) { sctp_add_cmd_sf ( commands , SCTP_CMD_SEND_PKT , SCTP_PACKET ( packet ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_OUTCTRLCHUNKS ) ; return SCTP_DISPOSITION_CONSUME ; } else { return SCTP_DISPOSITION_NOMEM ; } } else { return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; } } chunk -> subh . init_hdr = ( sctp_inithdr * ) chunk -> skb -> data ; chunk -> param_hdr . v = skb_pull ( chunk -> skb , sizeof ( sctp_inithdr ) ) ; new_asoc = sctp_make_temp_asoc ( ep , chunk , GFP_ATOMIC ) ; if ( ! new_asoc ) { nomem } if ( security_sctp_assoc_request ( new_asoc , chunk -> skb ) ) { sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } if ( sctp_assoc_set_bind_addr_from_ep ( new_asoc , sctp_scope ( sctp_source ( chunk ) ) , GFP_ATOMIC ) < 0 ) { nomem_init } if ( ! sctp_process_init ( new_asoc , chunk , sctp_source ( chunk ) , ( sctp_init_chunk * ) chunk -> chunk_hdr , GFP_ATOMIC ) ) { nomem_init } len = 0 ; if ( err_chunk ) { len = ntohs ( err_chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr ) ; } repl = sctp_make_init_ack ( new_asoc , chunk , GFP_ATOMIC , len ) ; if ( ! repl ) { nomem_init } if ( err_chunk ) { unk_param = ( sctp_unrecognized_param * ) ( ( __u8 * ) ( err_chunk -> chunk_hdr ) + sizeof ( sctp_chunkhdr ) ) ; sctp_addto_chunk ( repl , len , unk_param ) ; sctp_chunk_free ( err_chunk ) ; } sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( repl ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ; return SCTP_DISPOSITION_DELETE_TCB ; nomem_init sctp_association_free ( new_asoc ) ; nomem if ( err_chunk ) { sctp_chunk_free ( err_chunk ) ; } return SCTP_DISPOSITION_NOMEM ; } 