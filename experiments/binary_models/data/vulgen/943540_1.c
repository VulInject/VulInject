static struct cachekey_header * cache_insert_ch ( struct cachekey_header * ch , uid_t uid , deskeyarray common , des_block key , keybuf3 * public , keybuf3 * secret ) { struct cachekey_disklist * cd ; struct cachekey_header * newch ; int i , err ; struct skck * skck ; des_block ivec ; struct dhkey * pk ; struct dhkey * sk ; if ( common . deskeyarray_len > sizeof ( skck -> common ) / sizeof ( des_block ) || ( pk = keybuf3_2_dhkey ( public ) ) == 0 || ( sk = keybuf3_2_dhkey ( secret ) ) == 0 ) { return ( 0 ) ; } newch = ch ; if ( ( cd = find_cache_item ( & newch , uid , pk ) ) == 0 ) { free ( pk ) ; free ( sk ) ; return ( newch ) ; } cd -> uid = uid ; memcpy ( & ( cd -> public ) , pk , DHKEYSIZE ( pk ) ) ; skck = MOVE_ADDR ( & ( cd -> public ) , DHKEYSIZE ( pk ) ) ; for ( i = 0 ; i < common . deskeyarray_len ; i ++ ) { skck -> common [ i ] = common . deskeyarray_val [ i ] ; } skck -> verifier = key ; memcpy ( & ( skck -> secret ) , sk , DHKEYSIZE ( sk ) ) ; free ( pk ) ; free ( sk ) ; memcpy ( ivec . c , key . c , sizeof ( key . c ) ) ; err = cbc_crypt ( key . c , ( char * ) skck , SKCK_LEN ( newch -> keylen ) , DES_ENCRYPT | DES_HW , ivec . c ) ; if ( DES_FAILED ( err ) ) { list_insert ( cd , & ( newch -> free ) , 0 , & ( newch -> free_count ) ) ; return ( newch ) ; } list_insert_hash ( cd , & ( newch -> bucket [ hashval ( cd -> uid ) ] ) , 0 , 0 ) ; list_insert ( cd , & ( newch -> inuse ) , & ( newch -> inuse_end ) , & ( newch -> inuse_count ) ) ; ( void ) msync ( ( caddr_t ) newch , newch -> length , MS_SYNC ) ; return ( newch ) ; } 