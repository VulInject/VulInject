static ssize_t chunkqueue_append_cqmem_to_tempfile ( chunkqueue * const restrict dest , chunkqueue * const restrict src , off_t len , log_error_st * const restrict errh ) { unsigned int iovcnt = 0 ; struct iovec iov [ 16 ] ; off_t dlen = 0 ; chunk * c ; for ( c = dest -> first ; c && c -> type == MEM_CHUNK ; c = c -> next ) { const off_t clen = chunk_remaining_length ( c ) ; iov [ iovcnt ] . iov_base = c -> mem -> ptr + c -> offset ; iov [ iovcnt ] . iov_len = ( size_t ) clen ; dlen += clen ; ++ iovcnt ; } if ( __builtin_expect ( ( c != NULL ) , 0 ) && dest -> first -> type == MEM_CHUNK ) { if ( 0 != chunkqueue_to_tempfiles ( dest , errh ) ) { return - 1 ; } dlen = 0 ; iovcnt = 0 ; } if ( __builtin_expect ( ( iovcnt < sizeof ( iov ) / sizeof ( * iov ) ) , 1 ) ) { for ( c = src -> first ; c && c -> type == MEM_CHUNK ; c = c -> next ) { off_t clen = chunk_remaining_length ( c ) ; if ( clen > len ) { clen = len ; } iov [ iovcnt ] . iov_base = c -> mem -> ptr + c -> offset ; iov [ iovcnt ] . iov_len = ( size_t ) clen ; len -= clen ; ++ iovcnt ; if ( 0 == len ) { break ; } if ( __builtin_expect ( ( iovcnt == sizeof ( iov ) / sizeof ( * iov ) ) , 0 ) ) { break ; } } } if ( __builtin_expect ( ( 0 == iovcnt ) , 0 ) ) { return 0 ; } c = chunkqueue_get_append_tempfile ( dest , errh ) ; if ( NULL == c ) { return - 1 ; } if ( c -> file . fd < 0 ) { return - 1 ; } ssize_t wr = pwritev ( c -> file . fd , iov , ( int ) iovcnt , c -> file . length ) ; if ( wr >= 0 ) { c -> file . length += wr ; dest -> bytes_in += wr ; if ( dlen ) { if ( __builtin_expect ( ( wr < dlen ) , 0 ) ) { return chunkqueue_append_cqmem_to_tempfile_partial ( dest , c , wr , errh ) ; } wr -= ( ssize_t ) dlen ; dest -> bytes_in -= dlen ; dest -> bytes_out -= dlen ; chunkqueue_mark_written ( dest , dlen ) ; } } if ( chunkqueue_append_tempfile_err ( dest , errh , c ) ) { wr = 0 ; } return wr ; } 