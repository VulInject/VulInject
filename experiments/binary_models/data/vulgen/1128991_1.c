void smi_debug_elements ( struct ber_element * root ) { static int indent = 0 ; char * value ; int constructed ; ober_calc_len ( root ) ; switch ( root -> be_encoding ) { case BER_TYPE_SEQUENCE : case BER_TYPE_SET : constructed = root -> be_encoding ; break ; default : constructed = 0 ; break ; } fprintf ( stderr , "%*slen %lu " , indent , "" , root -> be_len ) ; switch ( root -> be_class ) { case BER_CLASS_UNIVERSAL : fprintf ( stderr , "class: universal(%u) type: " , root -> be_class ) ; switch ( root -> be_type ) { case BER_TYPE_EOC : fprintf ( stderr , "end-of-content" ) ; break ; case BER_TYPE_INTEGER : fprintf ( stderr , "integer" ) ; break ; case BER_TYPE_BITSTRING : fprintf ( stderr , "bit-string" ) ; break ; case BER_TYPE_OCTETSTRING : fprintf ( stderr , "octet-string" ) ; break ; case BER_TYPE_NULL : fprintf ( stderr , "null" ) ; break ; case BER_TYPE_OBJECT : fprintf ( stderr , "object" ) ; break ; case BER_TYPE_ENUMERATED : fprintf ( stderr , "enumerated" ) ; break ; case BER_TYPE_SEQUENCE : fprintf ( stderr , "sequence" ) ; break ; case BER_TYPE_SET : fprintf ( stderr , "set" ) ; break ; } break ; case BER_CLASS_APPLICATION : fprintf ( stderr , "class: application(%u) type: " , root -> be_class ) ; switch ( root -> be_type ) { case SNMP_T_IPADDR : fprintf ( stderr , "ipaddr" ) ; break ; case SNMP_T_COUNTER32 : fprintf ( stderr , "counter32" ) ; break ; case SNMP_T_GAUGE32 : fprintf ( stderr , "gauge32" ) ; break ; case SNMP_T_TIMETICKS : fprintf ( stderr , "timeticks" ) ; break ; case SNMP_T_OPAQUE : fprintf ( stderr , "opaque" ) ; break ; case SNMP_T_COUNTER64 : fprintf ( stderr , "counter64" ) ; break ; } break ; case BER_CLASS_CONTEXT : fprintf ( stderr , "class: context(%u) type: " , root -> be_class ) ; switch ( root -> be_type ) { case SNMP_C_GETREQ : fprintf ( stderr , "getreq" ) ; break ; case SNMP_C_GETNEXTREQ : fprintf ( stderr , "getnextreq" ) ; break ; case SNMP_C_RESPONSE : fprintf ( stderr , "response" ) ; break ; case SNMP_C_SETREQ : fprintf ( stderr , "setreq" ) ; break ; case SNMP_C_TRAP : fprintf ( stderr , "trap" ) ; break ; case SNMP_C_GETBULKREQ : fprintf ( stderr , "getbulkreq" ) ; break ; case SNMP_C_INFORMREQ : fprintf ( stderr , "informreq" ) ; break ; case SNMP_C_TRAPV2 : fprintf ( stderr , "trapv2" ) ; break ; case SNMP_C_REPORT : fprintf ( stderr , "report" ) ; break ; } break ; case BER_CLASS_PRIVATE : fprintf ( stderr , "class: private(%u) type: " , root -> be_class ) ; break ; default : fprintf ( stderr , "class:<INVALID>(%u) type: " , root -> be_class ) ; break ; } fprintf ( stderr , "(%u) encoding %u " , root -> be_type , root -> be_encoding ) ; if ( ( value = smi_print_element ( root ) ) == NULL ) { invalid } switch ( root -> be_encoding ) { case BER_TYPE_INTEGER : case BER_TYPE_ENUMERATED : fprintf ( stderr , "value %s" , value ) ; break ; case BER_TYPE_BITSTRING : fprintf ( stderr , "hexdump %s" , value ) ; break ; case BER_TYPE_OBJECT : fprintf ( stderr , "oid %s" , value ) ; break ; case BER_TYPE_OCTETSTRING : if ( root -> be_class == BER_CLASS_APPLICATION && root -> be_type == SNMP_T_IPADDR ) { fprintf ( stderr , "addr %s" , value ) ; } else { fprintf ( stderr , "string %s" , value ) ; } break ; case BER_TYPE_NULL : case BER_TYPE_EOC : case BER_TYPE_SEQUENCE : case BER_TYPE_SET : default : fprintf ( stderr , "%s" , value ) ; break ; } invalid if ( value == NULL ) { fprintf ( stderr , "<INVALID>" ) ; } else { free ( value ) ; } fprintf ( stderr , "\n" ) ; if ( constructed ) { root -> be_encoding = constructed ; } if ( root -> be_next ) { smi_debug_elements ( root -> be_next ) ; } } 