static void dce110_reset_hw_ctx_wrap ( struct dc * dc , struct dc_state * context ) { int i ; for ( i = 0 ; i < MAX_PIPES ; i ++ ) { struct pipe_ctx * pipe_ctx_old = & dc -> current_state -> res_ctx . pipe_ctx [ i ] ; struct pipe_ctx * pipe_ctx = & context -> res_ctx . pipe_ctx [ i ] ; if ( ! pipe_ctx_old -> stream || pipe_ctx_old -> top_pipe ) { continue ; } if ( ! pipe_ctx -> stream || pipe_need_reprogram ( pipe_ctx_old , pipe_ctx ) ) { struct clock_source * old_clk = pipe_ctx_old -> clock_source ; if ( ! pipe_ctx -> stream || ! pipe_ctx -> stream -> dpms_off ) { link_set_dpms_off ( pipe_ctx_old ) ; if ( pipe_ctx_old -> stream_res . audio ) { pipe_ctx_old -> stream_res . audio -> funcs -> az_disable ( pipe_ctx_old -> stream_res . audio ) ; } } pipe_ctx_old -> stream_res . tg -> funcs -> set_blank ( pipe_ctx_old -> stream_res . tg , true ) ; if ( ! hwss_wait_for_blank_complete ( pipe_ctx_old -> stream_res . tg ) ) { dm_error ( "DC: failed to blank crtc!\n" ) ; BREAK_TO_DEBUGGER ( ) ; } pipe_ctx_old -> stream_res . tg -> funcs -> disable_crtc ( pipe_ctx_old -> stream_res . tg ) ; pipe_ctx_old -> stream -> link -> phy_state . symclk_ref_cnts . otg = 0 ; pipe_ctx_old -> plane_res . mi -> funcs -> free_mem_input ( pipe_ctx_old -> plane_res . mi , dc -> current_state -> stream_count ) ; if ( old_clk && 0 == resource_get_clock_source_reference ( & context -> res_ctx , dc -> res_pool , old_clk ) ) { old_clk -> funcs -> cs_power_down ( old_clk ) ; } dc -> hwss . disable_plane ( dc , pipe_ctx_old ) ; pipe_ctx_old -> stream = NULL ; } } } 