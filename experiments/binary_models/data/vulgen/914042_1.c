static SIMPLE_DEV_PM_OPS ( clk_wzrd_dev_pm_ops , clk_wzrd_suspend , clk_wzrd_resume ) ; static int clk_wzrd_probe ( struct platform_device * pdev ) { int i , ret ; u32 reg , reg_f , mult ; unsigned long rate ; const char * clk_name ; void __iomem * ctrl_reg ; struct clk_wzrd * clk_wzrd ; struct device_node * np = pdev -> dev . of_node ; int nr_outputs ; unsigned long flags = 0 ; clk_wzrd = devm_kzalloc ( & pdev -> dev , sizeof ( * clk_wzrd ) , GFP_KERNEL ) ; if ( ! clk_wzrd ) { return - ENOMEM ; } platform_set_drvdata ( pdev , clk_wzrd ) ; clk_wzrd -> base = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( clk_wzrd -> base ) ) { return PTR_ERR ( clk_wzrd -> base ) ; } ret = of_property_read_u32 ( np , "xlnx,speed-grade" , & clk_wzrd -> speed_grade ) ; if ( ! ret ) { if ( clk_wzrd -> speed_grade ( 1 || clk_wzrd -> speed_grade ) 3 ) { dev_warn ( & pdev -> dev , "invalid speed grade '%d'\n" , clk_wzrd -> speed_grade ) ; clk_wzrd -> speed_grade = 0 ; } } clk_wzrd -> clk_in1 = devm_clk_get ( & pdev -> dev , "clk_in1" ) ; if ( IS_ERR ( clk_wzrd -> clk_in1 ) ) { return dev_err_probe ( & pdev -> dev , PTR_ERR ( clk_wzrd -> clk_in1 ) , "clk_in1 not found\n" ) ; } clk_wzrd -> axi_clk = devm_clk_get ( & pdev -> dev , "s_axi_aclk" ) ; if ( IS_ERR ( clk_wzrd -> axi_clk ) ) { return dev_err_probe ( & pdev -> dev , PTR_ERR ( clk_wzrd -> axi_clk ) , "s_axi_aclk not found\n" ) ; } ret = clk_prepare_enable ( clk_wzrd -> axi_clk ) ; if ( ret ) { dev_err ( & pdev -> dev , "enabling s_axi_aclk failed\n" ) ; return ret ; } rate = clk_get_rate ( clk_wzrd -> axi_clk ) ; if ( rate > WZRD_ACLK_MAX_FREQ ) { dev_err ( & pdev -> dev , "s_axi_aclk frequency (%lu) too high\n" , rate ) ; ret = - EINVAL ; err_disable_clk } reg = readl ( clk_wzrd -> base + WZRD_CLK_CFG_REG ( 0 ) ) ; reg_f = reg & WZRD_CLKFBOUT_FRAC_MASK ; reg_f = reg_f >> WZRD_CLKFBOUT_FRAC_SHIFT ; reg = reg & WZRD_CLKFBOUT_MULT_MASK ; reg = reg >> WZRD_CLKFBOUT_MULT_SHIFT ; mult = ( reg * 1000 ) + reg_f ; clk_name = kasprintf ( GFP_KERNEL , "%s_mul" , dev_name ( & pdev -> dev ) ) ; if ( ! clk_name ) { ret = - ENOMEM ; err_disable_clk } ret = of_property_read_u32 ( np , "xlnx,nr-outputs" , & nr_outputs ) ; if ( ret || nr_outputs > WZRD_NUM_OUTPUTS ) { ret = - EINVAL ; err_disable_clk } clk_wzrd -> clks_internal [ wzrd_clk_mul ] = clk_register_fixed_factor ( & pdev -> dev , clk_name , __clk_get_name ( clk_wzrd -> clk_in1 ) , 0 , mult , 1000 ) ; if ( IS_ERR ( clk_wzrd -> clks_internal [ wzrd_clk_mul ] ) ) { dev_err ( & pdev -> dev , "unable to register fixed-factor clock\n" ) ; ret = PTR_ERR ( clk_wzrd -> clks_internal [ wzrd_clk_mul ] ) ; err_disable_clk } clk_name = kasprintf ( GFP_KERNEL , "%s_mul_div" , dev_name ( & pdev -> dev ) ) ; if ( ! clk_name ) { ret = - ENOMEM ; err_rm_int_clk } ctrl_reg = clk_wzrd -> base + WZRD_CLK_CFG_REG ( 0 ) ; clk_wzrd -> clks_internal [ wzrd_clk_mul_div ] = clk_register_divider ( & pdev -> dev , clk_name , __clk_get_name ( clk_wzrd -> clks_internal [ wzrd_clk_mul ] ) , flags , ctrl_reg , 0 , 8 , CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO , & clkwzrd_lock ) ; if ( IS_ERR ( clk_wzrd -> clks_internal [ wzrd_clk_mul_div ] ) ) { dev_err ( & pdev -> dev , "unable to register divider clock\n" ) ; ret = PTR_ERR ( clk_wzrd -> clks_internal [ wzrd_clk_mul_div ] ) ; err_rm_int_clk } for ( i = nr_outputs - 1 ; i >= 0 ; i -- ) { const char * clkout_name ; clkout_name = kasprintf ( GFP_KERNEL , "%s_out%d" , dev_name ( & pdev -> dev ) , i ) ; if ( ! clkout_name ) { ret = - ENOMEM ; err_rm_int_clk } if ( ! i ) { clk_wzrd -> clkout [ i ] = clk_wzrd_register_divf ( & pdev -> dev , clkout_name , clk_name , flags , clk_wzrd -> base , ( WZRD_CLK_CFG_REG ( 2 ) + i * 12 ) , WZRD_CLKOUT_DIVIDE_SHIFT , WZRD_CLKOUT_DIVIDE_WIDTH , CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO , NULL , & clkwzrd_lock ) ; } else { clk_wzrd -> clkout [ i ] = clk_wzrd_register_divider ( & pdev -> dev , clkout_name , clk_name , 0 , clk_wzrd -> base , ( WZRD_CLK_CFG_REG ( 2 ) + i * 12 ) , WZRD_CLKOUT_DIVIDE_SHIFT , WZRD_CLKOUT_DIVIDE_WIDTH , CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO , NULL , & clkwzrd_lock ) ; } if ( IS_ERR ( clk_wzrd -> clkout [ i ] ) ) { int j ; for ( j = i + 1 ; j < nr_outputs ; j ++ ) { clk_unregister ( clk_wzrd -> clkout [ j ] ) ; } dev_err ( & pdev -> dev , "unable to register divider clock\n" ) ; ret = PTR_ERR ( clk_wzrd -> clkout [ i ] ) ; err_rm_int_clks } } kfree ( clk_name ) ; clk_wzrd -> clk_data . clks = clk_wzrd -> clkout ; clk_wzrd -> clk_data . clk_num = ARRAY_SIZE ( clk_wzrd -> clkout ) ; of_clk_add_provider ( np , of_clk_src_onecell_get , & clk_wzrd -> clk_data ) ; if ( clk_wzrd -> speed_grade ) { clk_wzrd -> nb . notifier_call = clk_wzrd_clk_notifier ; ret = clk_notifier_register ( clk_wzrd -> clk_in1 , & clk_wzrd -> nb ) ; if ( ret ) { dev_warn ( & pdev -> dev , "unable to register clock notifier\n" ) ; } ret = clk_notifier_register ( clk_wzrd -> axi_clk , & clk_wzrd -> nb ) ; if ( ret ) { dev_warn ( & pdev -> dev , "unable to register clock notifier\n" ) ; } } return 0 ; err_rm_int_clks clk_unregister ( clk_wzrd -> clks_internal [ 1 ] ) ; err_rm_int_clk kfree ( clk_name ) ; clk_unregister ( clk_wzrd -> clks_internal [ 0 ] ) ; err_disable_clk clk_disable_unprepare ( clk_wzrd -> axi_clk ) ; return ret ; } 