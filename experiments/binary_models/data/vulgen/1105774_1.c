static void hidinput_configure_usage ( struct hid_input * hidinput , struct hid_field * field , struct hid_usage * usage ) { struct input_dev * input = hidinput -> input ; struct hid_device * device = input_get_drvdata ( input ) ; int max = 0 , code ; unsigned long * bit = NULL ; field -> hidinput = hidinput ; if ( field -> flags & HID_MAIN_ITEM_CONSTANT ) { ignore } if ( field -> report_count < 1 ) { ignore } if ( field -> report_type == HID_OUTPUT_REPORT && ( usage -> hid & HID_USAGE_PAGE ) != HID_UP_LED ) { ignore } if ( device -> driver -> input_mapping ) { int ret = device -> driver -> input_mapping ( device , hidinput , field , usage , & bit , & max ) ; if ( ret > 0 ) { mapped } if ( ret < 0 ) { ignore } } switch ( usage -> hid & HID_USAGE_PAGE ) { case HID_UP_UNDEFINED : ignore case HID_UP_KEYBOARD : set_bit ( EV_REP , input -> evbit ) ; if ( ( usage -> hid & HID_USAGE ) < 256 ) { if ( ! hid_keyboard [ usage -> hid & HID_USAGE ] ) { ignore } map_key_clear ( hid_keyboard [ usage -> hid & HID_USAGE ] ) ; } else { map_key ( KEY_UNKNOWN ) ; } break ; case HID_UP_BUTTON : code = ( ( usage -> hid - 1 ) & HID_USAGE ) ; switch ( field -> application ) { case HID_GD_MOUSE : case HID_GD_POINTER : code += BTN_MOUSE ; break ; case HID_GD_JOYSTICK : if ( code <= 0xf ) { code += BTN_JOYSTICK ; } else { code += BTN_TRIGGER_HAPPY - 0x10 ; } break ; case HID_GD_GAMEPAD : if ( code <= 0xf ) { code += BTN_GAMEPAD ; } else { code += BTN_TRIGGER_HAPPY - 0x10 ; } break ; default : switch ( field -> physical ) { case HID_GD_MOUSE : case HID_GD_POINTER : code += BTN_MOUSE ; break ; case HID_GD_JOYSTICK : code += BTN_JOYSTICK ; break ; case HID_GD_GAMEPAD : code += BTN_GAMEPAD ; break ; default : code += BTN_MISC ; } } map_key ( code ) ; break ; case HID_UP_SIMULATION : switch ( usage -> hid & 0xffff ) { case 0xba : map_abs ( ABS_RUDDER ) ; break ; case 0xbb : map_abs ( ABS_THROTTLE ) ; break ; case 0xc4 : map_abs ( ABS_GAS ) ; break ; case 0xc5 : map_abs ( ABS_BRAKE ) ; break ; case 0xc8 : map_abs ( ABS_WHEEL ) ; break ; default : ignore } break ; case HID_UP_GENDESK : if ( ( usage -> hid & 0xf0 ) == 0x80 ) { switch ( usage -> hid & 0xf ) { case 0x1 : map_key_clear ( KEY_POWER ) ; break ; case 0x2 : map_key_clear ( KEY_SLEEP ) ; break ; case 0x3 : map_key_clear ( KEY_WAKEUP ) ; break ; case 0x4 : map_key_clear ( KEY_CONTEXT_MENU ) ; break ; case 0x5 : map_key_clear ( KEY_MENU ) ; break ; case 0x6 : map_key_clear ( KEY_PROG1 ) ; break ; case 0x7 : map_key_clear ( KEY_HELP ) ; break ; case 0x8 : map_key_clear ( KEY_EXIT ) ; break ; case 0x9 : map_key_clear ( KEY_SELECT ) ; break ; case 0xa : map_key_clear ( KEY_RIGHT ) ; break ; case 0xb : map_key_clear ( KEY_LEFT ) ; break ; case 0xc : map_key_clear ( KEY_UP ) ; break ; case 0xd : map_key_clear ( KEY_DOWN ) ; break ; case 0xe : map_key_clear ( KEY_POWER2 ) ; break ; case 0xf : map_key_clear ( KEY_RESTART ) ; break ; default : unknown } break ; } if ( field -> application == HID_GD_SYSTEM_CONTROL ) { ignore } if ( ( usage -> hid & 0xf0 ) == 0x90 ) { switch ( usage -> hid ) { case HID_GD_UP : usage -> hat_dir = 1 ; break ; case HID_GD_DOWN : usage -> hat_dir = 5 ; break ; case HID_GD_RIGHT : usage -> hat_dir = 3 ; break ; case HID_GD_LEFT : usage -> hat_dir = 7 ; break ; default : unknown } if ( field -> dpad ) { map_abs ( field -> dpad ) ; ignore } map_abs ( ABS_HAT0X ) ; break ; } switch ( usage -> hid ) { case HID_GD_X : case HID_GD_Y : case HID_GD_Z : case HID_GD_RX : case HID_GD_RY : case HID_GD_RZ : if ( field -> flags & HID_MAIN_ITEM_RELATIVE ) { map_rel ( usage -> hid & 0xf ) ; } else { map_abs_clear ( usage -> hid & 0xf ) ; } break ; case HID_GD_SLIDER : case HID_GD_DIAL : case HID_GD_WHEEL : if ( field -> flags & HID_MAIN_ITEM_RELATIVE ) { map_rel ( usage -> hid & 0xf ) ; } else { map_abs ( usage -> hid & 0xf ) ; } break ; case HID_GD_HATSWITCH : usage -> hat_min = field -> logical_minimum ; usage -> hat_max = field -> logical_maximum ; map_abs ( ABS_HAT0X ) ; break ; case HID_GD_START : map_key_clear ( BTN_START ) ; break ; case HID_GD_SELECT : map_key_clear ( BTN_SELECT ) ; break ; default : unknown } break ; case HID_UP_LED : switch ( usage -> hid & 0xffff ) { case 0x01 : map_led ( LED_NUML ) ; break ; case 0x02 : map_led ( LED_CAPSL ) ; break ; case 0x03 : map_led ( LED_SCROLLL ) ; break ; case 0x04 : map_led ( LED_COMPOSE ) ; break ; case 0x05 : map_led ( LED_KANA ) ; break ; case 0x27 : map_led ( LED_SLEEP ) ; break ; case 0x4c : map_led ( LED_SUSPEND ) ; break ; case 0x09 : map_led ( LED_MUTE ) ; break ; case 0x4b : map_led ( LED_MISC ) ; break ; case 0x19 : map_led ( LED_MAIL ) ; break ; case 0x4d : map_led ( LED_CHARGING ) ; break ; default : ignore } break ; case HID_UP_DIGITIZER : switch ( usage -> hid & 0xff ) { case 0x00 : ignore case 0x30 : if ( ! test_bit ( BTN_TOUCH , input -> keybit ) ) { device -> quirks |= HID_QUIRK_NOTOUCH ; set_bit ( EV_KEY , input -> evbit ) ; set_bit ( BTN_TOUCH , input -> keybit ) ; } map_abs_clear ( ABS_PRESSURE ) ; break ; case 0x32 : switch ( field -> physical & 0xff ) { case 0x21 : map_key ( BTN_TOOL_MOUSE ) ; break ; case 0x22 : map_key ( BTN_TOOL_FINGER ) ; break ; default : map_key ( BTN_TOOL_PEN ) ; break ; } break ; case 0x3c : map_key_clear ( BTN_TOOL_RUBBER ) ; break ; case 0x3d : map_abs_clear ( ABS_TILT_X ) ; break ; case 0x3e : map_abs_clear ( ABS_TILT_Y ) ; break ; case 0x33 : case 0x42 : case 0x43 : device -> quirks &= ~ HID_QUIRK_NOTOUCH ; map_key_clear ( BTN_TOUCH ) ; break ; case 0x44 : map_key_clear ( BTN_STYLUS ) ; break ; case 0x46 : case 0x5a : map_key_clear ( BTN_STYLUS2 ) ; break ; case 0x5b : usage -> type = EV_MSC ; usage -> code = MSC_SERIAL ; bit = input -> mscbit ; max = MSC_MAX ; break ; default : unknown } break ; case HID_UP_TELEPHONY : switch ( usage -> hid & HID_USAGE ) { case 0x2f : map_key_clear ( KEY_MICMUTE ) ; break ; case 0xb0 : map_key_clear ( KEY_NUMERIC_0 ) ; break ; case 0xb1 : map_key_clear ( KEY_NUMERIC_1 ) ; break ; case 0xb2 : map_key_clear ( KEY_NUMERIC_2 ) ; break ; case 0xb3 : map_key_clear ( KEY_NUMERIC_3 ) ; break ; case 0xb4 : map_key_clear ( KEY_NUMERIC_4 ) ; break ; case 0xb5 : map_key_clear ( KEY_NUMERIC_5 ) ; break ; case 0xb6 : map_key_clear ( KEY_NUMERIC_6 ) ; break ; case 0xb7 : map_key_clear ( KEY_NUMERIC_7 ) ; break ; case 0xb8 : map_key_clear ( KEY_NUMERIC_8 ) ; break ; case 0xb9 : map_key_clear ( KEY_NUMERIC_9 ) ; break ; case 0xba : map_key_clear ( KEY_NUMERIC_STAR ) ; break ; case 0xbb : map_key_clear ( KEY_NUMERIC_POUND ) ; break ; case 0xbc : map_key_clear ( KEY_NUMERIC_A ) ; break ; case 0xbd : map_key_clear ( KEY_NUMERIC_B ) ; break ; case 0xbe : map_key_clear ( KEY_NUMERIC_C ) ; break ; case 0xbf : map_key_clear ( KEY_NUMERIC_D ) ; break ; default : ignore } break ; case HID_UP_CONSUMER : switch ( usage -> hid & HID_USAGE ) { case 0x000 : ignore case 0x030 : map_key_clear ( KEY_POWER ) ; break ; case 0x031 : map_key_clear ( KEY_RESTART ) ; break ; case 0x032 : map_key_clear ( KEY_SLEEP ) ; break ; case 0x034 : map_key_clear ( KEY_SLEEP ) ; break ; case 0x035 : map_key_clear ( KEY_KBDILLUMTOGGLE ) ; break ; case 0x036 : map_key_clear ( BTN_MISC ) ; break ; case 0x040 : map_key_clear ( KEY_MENU ) ; break ; case 0x041 : map_key_clear ( KEY_SELECT ) ; break ; case 0x042 : map_key_clear ( KEY_UP ) ; break ; case 0x043 : map_key_clear ( KEY_DOWN ) ; break ; case 0x044 : map_key_clear ( KEY_LEFT ) ; break ; case 0x045 : map_key_clear ( KEY_RIGHT ) ; break ; case 0x046 : map_key_clear ( KEY_ESC ) ; break ; case 0x047 : map_key_clear ( KEY_KPPLUS ) ; break ; case 0x048 : map_key_clear ( KEY_KPMINUS ) ; break ; case 0x060 : map_key_clear ( KEY_INFO ) ; break ; case 0x061 : map_key_clear ( KEY_SUBTITLE ) ; break ; case 0x063 : map_key_clear ( KEY_VCR ) ; break ; case 0x065 : map_key_clear ( KEY_CAMERA ) ; break ; case 0x069 : map_key_clear ( KEY_RED ) ; break ; case 0x06a : map_key_clear ( KEY_GREEN ) ; break ; case 0x06b : map_key_clear ( KEY_BLUE ) ; break ; case 0x06c : map_key_clear ( KEY_YELLOW ) ; break ; case 0x06d : map_key_clear ( KEY_ZOOM ) ; break ; case 0x06f : map_key_clear ( KEY_BRIGHTNESSUP ) ; break ; case 0x070 : map_key_clear ( KEY_BRIGHTNESSDOWN ) ; break ; case 0x072 : map_key_clear ( KEY_BRIGHTNESS_TOGGLE ) ; break ; case 0x073 : map_key_clear ( KEY_BRIGHTNESS_MIN ) ; break ; case 0x074 : map_key_clear ( KEY_BRIGHTNESS_MAX ) ; break ; case 0x075 : map_key_clear ( KEY_BRIGHTNESS_AUTO ) ; break ; case 0x082 : map_key_clear ( KEY_VIDEO_NEXT ) ; break ; case 0x083 : map_key_clear ( KEY_LAST ) ; break ; case 0x084 : map_key_clear ( KEY_ENTER ) ; break ; case 0x088 : map_key_clear ( KEY_PC ) ; break ; case 0x089 : map_key_clear ( KEY_TV ) ; break ; case 0x08a : map_key_clear ( KEY_WWW ) ; break ; case 0x08b : map_key_clear ( KEY_DVD ) ; break ; case 0x08c : map_key_clear ( KEY_PHONE ) ; break ; case 0x08d : map_key_clear ( KEY_PROGRAM ) ; break ; case 0x08e : map_key_clear ( KEY_VIDEOPHONE ) ; break ; case 0x08f : map_key_clear ( KEY_GAMES ) ; break ; case 0x090 : map_key_clear ( KEY_MEMO ) ; break ; case 0x091 : map_key_clear ( KEY_CD ) ; break ; case 0x092 : map_key_clear ( KEY_VCR ) ; break ; case 0x093 : map_key_clear ( KEY_TUNER ) ; break ; case 0x094 : map_key_clear ( KEY_EXIT ) ; break ; case 0x095 : map_key_clear ( KEY_HELP ) ; break ; case 0x096 : map_key_clear ( KEY_TAPE ) ; break ; case 0x097 : map_key_clear ( KEY_TV2 ) ; break ; case 0x098 : map_key_clear ( KEY_SAT ) ; break ; case 0x09a : map_key_clear ( KEY_PVR ) ; break ; case 0x09c : map_key_clear ( KEY_CHANNELUP ) ; break ; case 0x09d : map_key_clear ( KEY_CHANNELDOWN ) ; break ; case 0x0a0 : map_key_clear ( KEY_VCR2 ) ; break ; case 0x0b0 : map_key_clear ( KEY_PLAY ) ; break ; case 0x0b1 : map_key_clear ( KEY_PAUSE ) ; break ; case 0x0b2 : map_key_clear ( KEY_RECORD ) ; break ; case 0x0b3 : map_key_clear ( KEY_FASTFORWARD ) ; break ; case 0x0b4 : map_key_clear ( KEY_REWIND ) ; break ; case 0x0b5 : map_key_clear ( KEY_NEXTSONG ) ; break ; case 0x0b6 : map_key_clear ( KEY_PREVIOUSSONG ) ; break ; case 0x0b7 : map_key_clear ( KEY_STOPCD ) ; break ; case 0x0b8 : map_key_clear ( KEY_EJECTCD ) ; break ; case 0x0bc : map_key_clear ( KEY_MEDIA_REPEAT ) ; break ; case 0x0b9 : map_key_clear ( KEY_SHUFFLE ) ; break ; case 0x0bf : map_key_clear ( KEY_SLOW ) ; break ; case 0x0cd : map_key_clear ( KEY_PLAYPAUSE ) ; break ; case 0x0cf : map_key_clear ( KEY_VOICECOMMAND ) ; break ; case 0x0e0 : map_abs_clear ( ABS_VOLUME ) ; break ; case 0x0e2 : map_key_clear ( KEY_MUTE ) ; break ; case 0x0e5 : map_key_clear ( KEY_BASSBOOST ) ; break ; case 0x0e9 : map_key_clear ( KEY_VOLUMEUP ) ; break ; case 0x0ea : map_key_clear ( KEY_VOLUMEDOWN ) ; break ; case 0x0f5 : map_key_clear ( KEY_SLOW ) ; break ; case 0x181 : map_key_clear ( KEY_BUTTONCONFIG ) ; break ; case 0x182 : map_key_clear ( KEY_BOOKMARKS ) ; break ; case 0x183 : map_key_clear ( KEY_CONFIG ) ; break ; case 0x184 : map_key_clear ( KEY_WORDPROCESSOR ) ; break ; case 0x185 : map_key_clear ( KEY_EDITOR ) ; break ; case 0x186 : map_key_clear ( KEY_SPREADSHEET ) ; break ; case 0x187 : map_key_clear ( KEY_GRAPHICSEDITOR ) ; break ; case 0x188 : map_key_clear ( KEY_PRESENTATION ) ; break ; case 0x189 : map_key_clear ( KEY_DATABASE ) ; break ; case 0x18a : map_key_clear ( KEY_MAIL ) ; break ; case 0x18b : map_key_clear ( KEY_NEWS ) ; break ; case 0x18c : map_key_clear ( KEY_VOICEMAIL ) ; break ; case 0x18d : map_key_clear ( KEY_ADDRESSBOOK ) ; break ; case 0x18e : map_key_clear ( KEY_CALENDAR ) ; break ; case 0x18f : map_key_clear ( KEY_TASKMANAGER ) ; break ; case 0x190 : map_key_clear ( KEY_JOURNAL ) ; break ; case 0x191 : map_key_clear ( KEY_FINANCE ) ; break ; case 0x192 : map_key_clear ( KEY_CALC ) ; break ; case 0x193 : map_key_clear ( KEY_PLAYER ) ; break ; case 0x194 : map_key_clear ( KEY_FILE ) ; break ; case 0x196 : map_key_clear ( KEY_WWW ) ; break ; case 0x199 : map_key_clear ( KEY_CHAT ) ; break ; case 0x19c : map_key_clear ( KEY_LOGOFF ) ; break ; case 0x19e : map_key_clear ( KEY_COFFEE ) ; break ; case 0x19f : map_key_clear ( KEY_CONTROLPANEL ) ; break ; case 0x1a2 : map_key_clear ( KEY_APPSELECT ) ; break ; case 0x1a3 : map_key_clear ( KEY_NEXT ) ; break ; case 0x1a4 : map_key_clear ( KEY_PREVIOUS ) ; break ; case 0x1a6 : map_key_clear ( KEY_HELP ) ; break ; case 0x1a7 : map_key_clear ( KEY_DOCUMENTS ) ; break ; case 0x1ab : map_key_clear ( KEY_SPELLCHECK ) ; break ; case 0x1ae : map_key_clear ( KEY_KEYBOARD ) ; break ; case 0x1b1 : map_key_clear ( KEY_SCREENSAVER ) ; break ; case 0x1b4 : map_key_clear ( KEY_FILE ) ; break ; case 0x1b6 : map_key_clear ( KEY_IMAGES ) ; break ; case 0x1b7 : map_key_clear ( KEY_AUDIO ) ; break ; case 0x1b8 : map_key_clear ( KEY_VIDEO ) ; break ; case 0x1bc : map_key_clear ( KEY_MESSENGER ) ; break ; case 0x1bd : map_key_clear ( KEY_INFO ) ; break ; case 0x201 : map_key_clear ( KEY_NEW ) ; break ; case 0x202 : map_key_clear ( KEY_OPEN ) ; break ; case 0x203 : map_key_clear ( KEY_CLOSE ) ; break ; case 0x204 : map_key_clear ( KEY_EXIT ) ; break ; case 0x207 : map_key_clear ( KEY_SAVE ) ; break ; case 0x208 : map_key_clear ( KEY_PRINT ) ; break ; case 0x209 : map_key_clear ( KEY_PROPS ) ; break ; case 0x21a : map_key_clear ( KEY_UNDO ) ; break ; case 0x21b : map_key_clear ( KEY_COPY ) ; break ; case 0x21c : map_key_clear ( KEY_CUT ) ; break ; case 0x21d : map_key_clear ( KEY_PASTE ) ; break ; case 0x21f : map_key_clear ( KEY_FIND ) ; break ; case 0x221 : map_key_clear ( KEY_SEARCH ) ; break ; case 0x222 : map_key_clear ( KEY_GOTO ) ; break ; case 0x223 : map_key_clear ( KEY_HOMEPAGE ) ; break ; case 0x224 : map_key_clear ( KEY_BACK ) ; break ; case 0x225 : map_key_clear ( KEY_FORWARD ) ; break ; case 0x226 : map_key_clear ( KEY_STOP ) ; break ; case 0x227 : map_key_clear ( KEY_REFRESH ) ; break ; case 0x22a : map_key_clear ( KEY_BOOKMARKS ) ; break ; case 0x22d : map_key_clear ( KEY_ZOOMIN ) ; break ; case 0x22e : map_key_clear ( KEY_ZOOMOUT ) ; break ; case 0x22f : map_key_clear ( KEY_ZOOMRESET ) ; break ; case 0x233 : map_key_clear ( KEY_SCROLLUP ) ; break ; case 0x234 : map_key_clear ( KEY_SCROLLDOWN ) ; break ; case 0x238 : map_rel ( REL_HWHEEL ) ; break ; case 0x23d : map_key_clear ( KEY_EDIT ) ; break ; case 0x25f : map_key_clear ( KEY_CANCEL ) ; break ; case 0x269 : map_key_clear ( KEY_INSERT ) ; break ; case 0x26a : map_key_clear ( KEY_DELETE ) ; break ; case 0x279 : map_key_clear ( KEY_REDO ) ; break ; case 0x289 : map_key_clear ( KEY_REPLY ) ; break ; case 0x28b : map_key_clear ( KEY_FORWARDMAIL ) ; break ; case 0x28c : map_key_clear ( KEY_SEND ) ; break ; case 0x2c7 : map_key_clear ( KEY_KBDINPUTASSIST_PREV ) ; break ; case 0x2c8 : map_key_clear ( KEY_KBDINPUTASSIST_NEXT ) ; break ; case 0x2c9 : map_key_clear ( KEY_KBDINPUTASSIST_PREVGROUP ) ; break ; case 0x2ca : map_key_clear ( KEY_KBDINPUTASSIST_NEXTGROUP ) ; break ; case 0x2cb : map_key_clear ( KEY_KBDINPUTASSIST_ACCEPT ) ; break ; case 0x2cc : map_key_clear ( KEY_KBDINPUTASSIST_CANCEL ) ; break ; default : map_key_clear ( KEY_UNKNOWN ) ; } break ; case HID_UP_GENDEVCTRLS : if ( hidinput_setup_battery ( device , HID_INPUT_REPORT , field ) ) { ignore } else { unknown } break ; case HID_UP_HPVENDOR : set_bit ( EV_REP , input -> evbit ) ; switch ( usage -> hid & HID_USAGE ) { case 0x021 : map_key_clear ( KEY_PRINT ) ; break ; case 0x070 : map_key_clear ( KEY_HP ) ; break ; case 0x071 : map_key_clear ( KEY_CAMERA ) ; break ; case 0x072 : map_key_clear ( KEY_SOUND ) ; break ; case 0x073 : map_key_clear ( KEY_QUESTION ) ; break ; case 0x080 : map_key_clear ( KEY_EMAIL ) ; break ; case 0x081 : map_key_clear ( KEY_CHAT ) ; break ; case 0x082 : map_key_clear ( KEY_SEARCH ) ; break ; case 0x083 : map_key_clear ( KEY_CONNECT ) ; break ; case 0x084 : map_key_clear ( KEY_FINANCE ) ; break ; case 0x085 : map_key_clear ( KEY_SPORT ) ; break ; case 0x086 : map_key_clear ( KEY_SHOP ) ; break ; default : ignore } break ; case HID_UP_HPVENDOR2 : set_bit ( EV_REP , input -> evbit ) ; switch ( usage -> hid & HID_USAGE ) { case 0x001 : map_key_clear ( KEY_MICMUTE ) ; break ; case 0x003 : map_key_clear ( KEY_BRIGHTNESSDOWN ) ; break ; case 0x004 : map_key_clear ( KEY_BRIGHTNESSUP ) ; break ; default : ignore } break ; case HID_UP_MSVENDOR : ignore case HID_UP_CUSTOM : set_bit ( EV_REP , input -> evbit ) ; ignore case HID_UP_LOGIVENDOR : case HID_UP_LOGIVENDOR2 : case HID_UP_LOGIVENDOR3 : ignore case HID_UP_PID : switch ( usage -> hid & HID_USAGE ) { case 0xa4 : map_key_clear ( BTN_DEAD ) ; break ; default : ignore } break ; default : unknown if ( field -> report_size == 1 ) { if ( field -> report -> type == HID_OUTPUT_REPORT ) { map_led ( LED_MISC ) ; break ; } map_key ( BTN_MISC ) ; break ; } if ( field -> flags & HID_MAIN_ITEM_RELATIVE ) { map_rel ( REL_MISC ) ; break ; } map_abs ( ABS_MISC ) ; break ; } mapped if ( device -> driver -> input_mapped && device -> driver -> input_mapped ( device , hidinput , field , usage , & bit , & max ) < 0 ) { ignore } set_bit ( usage -> type , input -> evbit ) ; while ( usage -> code <= max && test_and_set_bit ( usage -> code , bit ) ) { usage -> code = find_next_zero_bit ( bit , max + 1 , usage -> code ) ; } if ( usage -> code > max ) { ignore } if ( usage -> type == EV_ABS ) { int a = field -> logical_minimum ; int b = field -> logical_maximum ; if ( ( device -> quirks & HID_QUIRK_BADPAD ) && ( usage -> code == ABS_X || usage -> code == ABS_Y ) ) { a = field -> logical_minimum = 0 ; b = field -> logical_maximum = 255 ; } if ( field -> application == HID_GD_GAMEPAD || field -> application == HID_GD_JOYSTICK ) { input_set_abs_params ( input , usage -> code , a , b , ( b - a ) >> 8 , ( b - a ) >> 4 ) ; } else { input_set_abs_params ( input , usage -> code , a , b , 0 , 0 ) ; } input_abs_set_res ( input , usage -> code , hidinput_calc_abs_res ( field , usage -> code ) ) ; if ( usage -> code == ABS_MT_POSITION_X && input -> hint_events_per_packet == 0 ) { input_set_events_per_packet ( input , 60 ) ; } } if ( usage -> type == EV_ABS && ( usage -> hat_min < usage -> hat_max || usage -> hat_dir ) ) { int i ; for ( i = usage -> code ; i < usage -> code + 2 && i <= max ; i ++ ) { input_set_abs_params ( input , i , - 1 , 1 , 0 , 0 ) ; set_bit ( i , input -> absbit ) ; } if ( usage -> hat_dir && ! field -> dpad ) { field -> dpad = usage -> code ; } } if ( ( usage -> type == EV_ABS ) && ( field -> flags & HID_MAIN_ITEM_RELATIVE ) && ( usage -> code == ABS_VOLUME ) ) { set_bit ( KEY_VOLUMEUP , input -> keybit ) ; set_bit ( KEY_VOLUMEDOWN , input -> keybit ) ; } ignore return ; } 