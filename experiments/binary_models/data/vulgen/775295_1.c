int etherbridge_rtfind ( struct etherbridge * eb , struct ifbaconf * baconf ) { struct eb_entry * ebe ; struct ifbareq bareq ; caddr_t buf ; size_t len , nlen ; time_t age , now = getuptime ( ) ; int error ; if ( baconf -> ifbac_len == 0 ) { baconf -> ifbac_len = eb -> eb_num * sizeof ( bareq ) ; return ( 0 ) ; } buf = malloc ( baconf -> ifbac_len , M_TEMP , M_WAITOK | M_CANFAIL ) ; if ( buf == NULL ) { return ( ENOMEM ) ; } len = 0 ; mtx_enter ( & eb -> eb_lock ) ; RBT_FOREACH ( , , ) { nlen = len + sizeof ( bareq ) ; strlcpy ( bareq . ifba_name , eb -> eb_name , sizeof ( bareq . ifba_name ) ) ; eb_port_ifname ( eb , bareq . ifba_ifsname , sizeof ( bareq . ifba_ifsname ) , ebe -> ebe_port ) ; ether_e64_to_addr ( & bareq . ifba_dst , ebe -> ebe_addr ) ; memset ( & bareq . ifba_dstsa , 0 , sizeof ( bareq . ifba_dstsa ) ) ; eb_port_sa ( eb , & bareq . ifba_dstsa , ebe -> ebe_port ) ; switch ( ebe -> ebe_type ) { case EBE_DYNAMIC : age = now - ebe -> ebe_age ; bareq . ifba_age = MIN ( age , 0xff ) ; bareq . ifba_flags = IFBAF_DYNAMIC ; break ; case EBE_STATIC : bareq . ifba_age = 0 ; bareq . ifba_flags = IFBAF_STATIC ; break ; } memcpy ( buf + len , & bareq , sizeof ( bareq ) ) ; len = nlen ; } nlen = baconf -> ifbac_len ; baconf -> ifbac_len = eb -> eb_num * sizeof ( bareq ) ; mtx_leave ( & eb -> eb_lock ) ; error = copyout ( buf , baconf -> ifbac_buf , len ) ; free ( buf , M_TEMP , nlen ) ; return ( error ) ; } 