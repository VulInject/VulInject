daddr_t ffs_alloccg ( struct inode * ip , u_int cg , daddr_t bpref , int size ) { struct fs * fs ; struct cg * cgp ; struct buf * bp ; struct timespec now ; daddr_t bno , blkno ; int i , frags , allocsiz ; fs = ip -> i_fs ; if ( fs -> fs_cs ( fs , cg ) . cs_nbfree == 0 && size == fs -> fs_bsize ) { return ( 0 ) ; } if ( ! ( bp = ffs_cgread ( fs , ip , cg ) ) ) { return ( 0 ) ; } cgp = ( cg * ) bp -> b_data ; if ( cgp -> cg_cs . cs_nbfree == 0 && size == fs -> fs_bsize ) { brelse ( bp ) ; return ( 0 ) ; } nanotime ( & now ) ; cgp -> cg_ffs2_time = now . tv_sec ; cgp -> cg_time = now . tv_sec ; if ( size == fs -> fs_bsize ) { bno = ffs_alloccgblk ( ip , bp , bpref ) ; bdwrite ( bp ) ; return ( bno ) ; } frags = numfrags ( fs , size ) ; for ( allocsiz = frags ; allocsiz < fs -> fs_frag ; allocsiz ++ ) { if ( cgp -> cg_frsum [ allocsiz ] != 0 ) { break ; } } if ( allocsiz == fs -> fs_frag ) { if ( cgp -> cg_cs . cs_nbfree == 0 ) { brelse ( bp ) ; return ( 0 ) ; } bno = ffs_alloccgblk ( ip , bp , bpref ) ; bpref = dtogd ( fs , bno ) ; for ( i = frags ; i < fs -> fs_frag ; i ++ ) { setbit ( cg_blksfree ( cgp ) , bpref + i ) ; } i = fs -> fs_frag - frags ; cgp -> cg_cs . cs_nffree += i ; fs -> fs_cstotal . cs_nffree += i ; fs -> fs_cs ( fs , cg ) . cs_nffree += i ; fs -> fs_fmod = 1 ; cgp -> cg_frsum [ i ] ++ ; bdwrite ( bp ) ; return ( bno ) ; } bno = ffs_mapsearch ( fs , cgp , bpref , allocsiz ) ; if ( bno < 0 ) { brelse ( bp ) ; return ( 0 ) ; } for ( i = 0 ; i < frags ; i ++ ) { clrbit ( cg_blksfree ( cgp ) , bno + i ) ; } cgp -> cg_cs . cs_nffree -= frags ; fs -> fs_cstotal . cs_nffree -= frags ; fs -> fs_cs ( fs , cg ) . cs_nffree -= frags ; fs -> fs_fmod = 1 ; cgp -> cg_frsum [ allocsiz ] -- ; blkno = cgbase ( fs , cg ) + bno ; if ( DOINGSOFTDEP ( ITOV ( ip ) ) ) { softdep_setup_blkmapdep ( bp , fs , blkno ) ; } bdwrite ( bp ) ; return ( blkno ) ; } 