int repost_pending_registrations ( struct omgt_port * port ) { int new_timeout_ms = - 1 ; struct omgt_sa_msg * msg ; struct omgt_sa_msg * del_msg ; struct omgt_thread_msg thread_msg ; omgt_sa_registration_t * reg ; struct iovec iov [ 2 ] ; size_t write_size , write_count ; omgt_lock_sem ( & port -> lock ) ; LIST_FOR_EACH ( , ) { if ( msg -> retries ) { new_timeout_ms = NOTICE_REG_TIMEOUT_MS ; post_send_sa_msg ( port , msg , OMGT_RRS_SEND_RETRY ) ; } else { if ( msg -> reg ) { reg = msg -> reg ; thread_msg . size = sizeof reg ; thread_msg . evt = OMGT_TH_EVT_TRAP_REG_ERR_TIMEOUT ; iov [ 0 ] . iov_base = & thread_msg ; iov [ 0 ] . iov_len = sizeof thread_msg ; iov [ 1 ] . iov_base = reg ; iov [ 1 ] . iov_len = sizeof reg ; write_size = iov [ 0 ] . iov_len + iov [ 1 ] . iov_len ; write_count = writev ( port -> umad_port_sv [ 1 ] , iov , 2 ) ; if ( write_size != write_count ) { OMGT_OUTPUT_ERROR ( port , "bad write count %d\n" , ( int ) write_count ) ; } } del_msg = msg ; msg = msg -> prev ; if ( del_msg -> reg ) { OMGT_DBGPRINT ( port , "registration timeout on trap %d : req %p\n" , del_msg -> reg -> trap_num , del_msg -> reg ) ; } else { OMGT_DBGPRINT ( port , "registration timeout on trap: No information available.\n" ) ; } if ( del_msg -> reg ) { del_msg -> reg -> reg_msg = NULL ; } LIST_DEL ( del_msg ) ; } } omgt_unlock_sem ( & port -> lock ) ; return new_timeout_ms ; } 