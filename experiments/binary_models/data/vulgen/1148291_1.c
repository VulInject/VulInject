static void _edit_and_update_crontab ( char * crontab ) { char * * lines ; char * badline = NULL ; int lineno , line_start ; char * line ; List jobs , env_vars ; int line_count ; bool setup_next_entry = true ; char * script ; crontab_update_response_msg_t * response ; edit if ( edit_only ) { _edit_crontab ( & crontab ) ; } jobs = list_create ( ( ListDelF ) slurm_free_job_desc_msg ) ; env_vars = list_create ( destroy_config_key_pair ) ; lines = convert_file_to_line_array ( xstrdup ( crontab ) , & line_count ) ; lineno = 0 ; line_start = - 1 ; setup_next_entry = true ; while ( ( line = lines [ lineno ] ) ) { char * pos = line ; cron_entry_t * entry ; if ( setup_next_entry ) { _reset_options ( ) ; script = _job_script_header ( ) ; setup_next_entry = false ; } while ( * pos == ' ' || * pos == '\t' ) { pos ++ ; } if ( * pos == '\0' || * pos == '\n' ) { lineno ++ ; continue ; } if ( ! xstrncmp ( pos , "#SCRON" , 6 ) ) { xstrfmtcat ( script , "%s\n" , line ) ; if ( line_start == - 1 ) { line_start = lineno ; } if ( parse_scron_line ( line + 6 , lineno ) ) { badline = xstrdup_printf ( "%d" , lineno ) ; break ; } lineno ++ ; continue ; } if ( * pos == '#' ) { lineno ++ ; continue ; } else { char * name = NULL , * value = NULL ; if ( load_env ( pos , & name , & value ) ) { config_key_pair_t * key_pair = xmalloc ( sizeof ( * key_pair ) ) ; xassert ( name ) ; xassert ( value ) ; key_pair -> name = name ; key_pair -> value = value ; list_append ( env_vars , key_pair ) ; lineno ++ ; continue ; } } if ( ! ( entry = cronspec_to_bitstring ( pos ) ) ) { badline = xstrdup_printf ( "%d" , lineno ) ; break ; } _expand_variables ( entry , env_vars ) ; if ( cli_filter_g_pre_submit ( & opt , 0 ) ) { free_cron_entry ( entry ) ; badline = xstrdup_printf ( "%d-%d" , line_start , lineno ) ; printf ( "cli_filter plugin terminated with error\n" ) ; break ; } if ( line_start != - 1 ) { entry -> line_start = line_start ; } else { entry -> line_start = lineno ; } line_start = - 1 ; entry -> line_end = lineno ; list_append ( jobs , _entry_to_job ( entry , script ) ) ; script = NULL ; setup_next_entry = true ; lineno ++ ; } xfree ( * ( lines + 1 ) ) ; xfree ( lines ) ; xfree ( script ) ; FREE_NULL_LIST ( env_vars ) ; if ( badline ) { if ( first_form ) { printf ( "There are errors in your crontab.\n" ) ; xfree ( badline ) ; xfree ( crontab ) ; FREE_NULL_LIST ( jobs ) ; exit ( 1 ) ; } char c = '\0' ; FREE_NULL_LIST ( jobs ) ; while ( tolower ( c ) != 'y' && tolower ( c ) != 'n' ) { printf ( "There are errors in your crontab.\n" "The failed line(s) is commented out with #BAD:\n" "Do you want to retry the edit? (y/n) " ) ; c = ( char ) getchar ( ) ; } if ( c == 'n' ) { exit ( 0 ) ; } _update_crontab_with_disabled_lines ( & crontab , badline , "#BAD: " ) ; xfree ( badline ) ; edit } response = slurm_update_crontab ( uid , gid , crontab , jobs ) ; if ( response -> return_code ) { if ( first_form ) { printf ( "There was an issue with the job submission on lines %s\n" "The error code return was: %s\n" "The error message was: %s\n" , response -> failed_lines , slurm_strerror ( response -> return_code ) , response -> err_msg ) ; slurm_free_crontab_update_response_msg ( response ) ; xfree ( crontab ) ; FREE_NULL_LIST ( jobs ) ; exit ( 1 ) ; } char c = '\0' ; FREE_NULL_LIST ( jobs ) ; while ( tolower ( c ) != 'y' && tolower ( c ) != 'n' ) { printf ( "There was an issue with the job submission on lines %s\n" "The error code return was: %s\n" "The error message was: %s\n" "The failed lines are commented out with #BAD:\n" "Do you want to retry the edit? (y/n) " , response -> failed_lines , slurm_strerror ( response -> return_code ) , response -> err_msg ) ; c = ( char ) getchar ( ) ; } if ( c == 'n' ) { exit ( 0 ) ; } _update_crontab_with_disabled_lines ( & crontab , response -> failed_lines , "#BAD: " ) ; slurm_free_crontab_update_response_msg ( response ) ; edit } if ( response -> job_submit_user_msg ) { print_multi_line_string ( response -> job_submit_user_msg , - 1 , LOG_LEVEL_INFO ) ; } for ( int i = 0 ; i < response -> jobids_count ; i ++ ) { cli_filter_g_post_submit ( 0 , response -> jobids [ i ] , NO_VAL ) ; } slurm_free_crontab_update_response_msg ( response ) ; xfree ( crontab ) ; FREE_NULL_LIST ( jobs ) ; } 