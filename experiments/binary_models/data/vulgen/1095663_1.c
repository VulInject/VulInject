static void smc_cdc_tx_handler ( struct smc_wr_tx_pend_priv * pnd_snd , struct smc_link * link , enum ib_wc_status wc_status ) { struct smc_cdc_tx_pend * cdcpend = ( smc_cdc_tx_pend * ) pnd_snd ; struct smc_connection * conn = cdcpend -> conn ; struct smc_sock * smc ; int diff ; smc = container_of ( conn , smc_sock , conn ) ; bh_lock_sock ( & smc -> sk ) ; if ( ! wc_status ) { diff = smc_curs_diff ( cdcpend -> conn -> sndbuf_desc -> len , & cdcpend -> conn -> tx_curs_fin , & cdcpend -> cursor ) ; smp_mb__before_atomic ( ) ; smp_mb__after_atomic ( ) ; smc_curs_copy ( & conn -> tx_curs_fin , & cdcpend -> cursor , conn ) ; smc_curs_copy ( & conn -> local_tx_ctrl_fin , & cdcpend -> p_cursor , conn ) ; conn -> tx_cdc_seq_fin = cdcpend -> ctrl_seq ; } if ( atomic_dec_and_test ( & conn -> cdc_pend_tx_wr ) ) { if ( sock_owned_by_user ( & smc -> sk ) ) { conn -> tx_in_release_sock = true ; } else { smc_tx_pending ( conn ) ; } if ( unlikely ( wq_has_sleeper ( & conn -> cdc_pend_tx_wq ) ) ) { wake_up ( & conn -> cdc_pend_tx_wq ) ; } } WARN_ON ( atomic_read ( & conn -> cdc_pend_tx_wr ) < 0 ) ; smc_tx_sndbuf_nonfull ( smc ) ; bh_unlock_sock ( & smc -> sk ) ; } 