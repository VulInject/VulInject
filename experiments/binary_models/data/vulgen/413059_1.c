there is no way to include an iscntrl ( ) separator as part of the data . Arguments listptr points to a pointer to the current start of the list ; the pointer gets updated to point after the end of the next item separator a pointer to the separator character in an int ( see above ) buffer where to put a copy of the next string in the list ; NULL the next string is returned in memory Note that , ; . If we ; { the allocation , taint is handled there . buflen when buffer is NULL , the size of buffer ; } , , , , , , , , , { int sep = * separator ; const uschar * s = * listptr ; BOOL sep_is_special ; if ( ! s ) { return NULL ; } while ( isspace ( * s ) && * s != sep ) { s ++ ; } if ( sep <= 0 ) { if ( * s == '<' && ( ispunct ( s [ 1 ] ) || iscntrl ( s [ 1 ] ) ) ) { sep = s [ 1 ] ; if ( * ++ s ) { ++ s ; } while ( isspace ( * s ) && * s != sep ) { s ++ ; } } else { sep = sep ?- sep : ':' ; } * separator = sep ; } if ( ! * s ) { return NULL ; } sep_is_special = iscntrl ( sep ) ; if { int p = 0 ; if ( is_tainted ( s ) && ! is_tainted ( buffer ) ) { die_tainted ( US "string_nextinlist" , func , line ) ; } for ( ; * s ; s ++ ) { if ( * s == sep && ( * ( ++ s ) != sep || sep_is_special ) ) { break ; } if ( p < buflen - 1 ) { buffer [ p ++ ] = * s ; } } while ( p > 0 && isspace ( buffer [ p - 1 ] ) ) { p -- ; } buffer [ p ] = '\0' ; } else { gstring * g = NULL ; if ( * s == sep ) { if ( * ++ s != sep || sep_is_special ) { * listptr = s ; return string_copy ( US "" ) ; } } for ( ; ; ) { const uschar * ss ; for ( ss = s + 1 ; * ss && * ss != sep ; ) { ss ++ ; } g = string_catn ( g , s , ss - s ) ; s = ss ; if ( ! * s || * ++ s != sep || sep_is_special ) { break ; } } while ( g -> ptr > 0 && isspace ( g -> s [ g -> ptr - 1 ] ) && ( g -> ptr == 1 || g -> s [ g -> ptr - 2 ] != '\\' ) ) { g -> ptr -- ; } buffer = string_from_gstring ( g ) ; gstring_release_unused_trc ( , , ) } * listptr = s ; return buffer ; } 