( ( ( index ) < ( q ) -> last_desc ) ?( ( index ) + 1 ) : 0 ) ALIGN ( , ) ( ( addr >= txq -> tso_hdrs_phys ) && ( addr < txq -> tso_hdrs_phys + txq -> size * TSO_HEADER_SIZE ) ) ( ( ( rxd ) -> status & MVNETA_RXD_BM_POOL_MASK ) >> MVNETA_RXD_BM_POOL_SHIFT ) mvneta_statistic { unsigned short offset unsigned short type const char name [ ETH_GSTRING_LEN ] } ; static const struct mvneta_statistic mvneta_statistics [ ] { { 0x3000 T_REG_64 "good_octets_received" } { 0x3010 T_REG_32 "good_frames_received" } { 0x3008 T_REG_32 "bad_octets_received" } { 0x3014 T_REG_32 "bad_frames_received" } { 0x3018 T_REG_32 "broadcast_frames_received" } { 0x301c T_REG_32 "multicast_frames_received" } { 0x3050 T_REG_32 "unrec_mac_control_received" } { 0x3058 T_REG_32 "good_fc_received" } { 0x305c T_REG_32 "bad_fc_received" } { 0x3060 T_REG_32 "undersize_received" } { 0x3064 T_REG_32 "fragments_received" } { 0x3068 T_REG_32 "oversize_received" } { 0x306c T_REG_32 "jabber_received" } { 0x3070 T_REG_32 "mac_receive_error" } { 0x3074 T_REG_32 "bad_crc_event" } { 0x3078 T_REG_32 "collision" } { 0x307c T_REG_32 "late_collision" } { 0x2484 T_REG_32 "rx_discard" } { 0x2488 T_REG_32 "rx_overrun" } { 0x3020 T_REG_32 "frames_64_octets" } { 0x3024 T_REG_32 "frames_65_to_127_octets" } { 0x3028 T_REG_32 "frames_128_to_255_octets" } { 0x302c T_REG_32 "frames_256_to_511_octets" } { 0x3030 T_REG_32 "frames_512_to_1023_octets" } { 0x3034 T_REG_32 "frames_1024_to_max_octets" } { 0x3038 T_REG_64 "good_octets_sent" } { 0x3040 T_REG_32 "good_frames_sent" } { 0x3044 T_REG_32 "excessive_collision" } { 0x3048 T_REG_32 "multicast_frames_sent" } { 0x304c T_REG_32 "broadcast_frames_sent" } { 0x3054 T_REG_32 "fc_sent" } { 0x300c T_REG_32 "internal_mac_transmit_err" } } ; ; mvneta_pcpu_stats { struct u64_stats_sync syncp ; u64 rx_packets ; u64 rx_bytes ; u64 tx_packets ; u64 tx_bytes ; } mvneta_pcpu_port { struct mvneta_port * pp ; struct napi_struct napi ; u32 cause_rx_tx ; } mvneta_port { u8 id ; struct mvneta_pcpu_port __percpu * ports ; struct mvneta_pcpu_stats __percpu * stats ; int pkt_size ; unsigned int frag_size ; void __iomem * base ; struct mvneta_rx_queue * rxqs ; struct mvneta_tx_queue * txqs ; struct net_device * dev ; struct hlist_node node_online ; struct hlist_node node_dead ; int rxq_def ; spinlock_t lock ; bool is_stopped ; u32 cause_rx_tx ; struct napi_struct napi ; struct clk * clk ; struct clk * clk_bus ; u8 mcast_count [ 256 ] ; u16 tx_ring_size ; u16 rx_ring_size ; struct mii_bus * mii_bus ; phy_interface_t phy_interface ; struct device_node * phy_node ; unsigned int link ; unsigned int duplex ; unsigned int speed ; unsigned int tx_csum_limit ; unsigned int use_inband_status 1 ; struct mvneta_bm * bm_priv ; struct mvneta_bm_pool * pool_long ; struct mvneta_bm_pool * pool_short ; int bm_win_id ; u64 ethtool_stats [ ARRAY_SIZE ( mvneta_statistics ) ] ; u32 indir [ MVNETA_RSS_LU_TABLE_SIZE ] ; bool neta_armada3700 ; u16 rx_offset_correction ; const struct mbus_dram_target_info * dram_target_info ; } mvneta_tx_desc { u32 command ; u16 reserverd1 ; u16 data_size ; u32 buf_phys_addr ; u32 reserved2 ; u32 reserved3 [ 4 ] ; } mvneta_rx_desc { u32 status ; u16 reserved1 ; u16 data_size ; u32 buf_phys_addr ; u32 reserved2 ; u32 buf_cookie ; u16 reserved3 ; u16 reserved4 ; u32 reserved5 ; u32 reserved6 ; } 