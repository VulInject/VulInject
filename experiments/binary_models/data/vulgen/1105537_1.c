void br_vlan_notify ( const struct net_bridge * br , const struct net_bridge_port * p , u16 vid , u16 vid_range , int cmd ) { struct net_bridge_vlan_group * vg ; struct net_bridge_vlan * v = NULL ; struct br_vlan_msg * bvm ; struct nlmsghdr * nlh ; struct sk_buff * skb ; int err = - ENOBUFS ; struct net * net ; u16 flags = 0 ; int ifindex ; ASSERT_RTNL ( ) ; if ( p ) { ifindex = p -> dev -> ifindex ; vg = nbp_vlan_group ( p ) ; net = dev_net ( p -> dev ) ; } else { ifindex = br -> dev -> ifindex ; vg = br_vlan_group ( br ) ; net = dev_net ( br -> dev ) ; } skb = nlmsg_new ( rtnl_vlan_nlmsg_size ( ) , GFP_KERNEL ) ; if ( ! skb ) { out_err } err = - EMSGSIZE ; nlh = nlmsg_put ( skb , 0 , 0 , cmd , sizeof ( * bvm ) , 0 ) ; if ( ! nlh ) { out_err } bvm = nlmsg_data ( nlh ) ; bvm -> family = AF_BRIDGE ; bvm -> ifindex = ifindex ; switch ( cmd ) { case RTM_NEWVLAN : v = br_vlan_find ( vg , vid ) ; if ( ! v || ! br_vlan_should_use ( v ) ) { out_kfree } flags = v -> flags ; if ( br_get_pvid ( vg ) == v -> vid ) { flags |= BRIDGE_VLAN_INFO_PVID ; } break ; case RTM_DELVLAN : break ; default : out_kfree } if ( ! br_vlan_fill_vids ( skb , vid , vid_range , v , p , flags , false ) ) { out_err } nlmsg_end ( skb , nlh ) ; rtnl_notify ( skb , net , 0 , RTNLGRP_BRVLAN , NULL , GFP_KERNEL ) ; return ; out_err rtnl_set_sk_err ( net , RTNLGRP_BRVLAN , err ) ; out_kfree kfree_skb ( skb ) ; } 