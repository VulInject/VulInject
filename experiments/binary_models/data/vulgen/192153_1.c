bool test_r_anal_block_query ( ) { RAnal * anal = r_anal_new ( ) ; assert_invariants ( anal ) ; RAnalBlock * blocks [ N ] ; size_t i ; for ( i = 0 ; i < N ; i ++ ) { blocks [ i ] = r_anal_create_block ( anal , rand ( ) % SPACE , rand ( ) % MAXSIZE ) ; assert_invariants ( anal ) ; } for ( i = 0 ; i < N ; i ++ ) { mu_assert_ptreq ( r_anal_get_block_at ( anal , blocks [ i ] -> addr ) , blocks [ i ] , "r_anal_get_block_at" ) ; } for ( i = 0 ; i < SAMPLES ; i ++ ) { ut64 addr = rand ( ) % SPACE ; size_t j ; RAnalBlock * block = NULL ; for ( j = 0 ; j < N ; j ++ ) { if ( ! blocks [ j ] ) { continue ; } if ( blocks [ j ] -> addr == addr ) { block = blocks [ j ] ; break ; } } mu_assert_ptreq ( r_anal_get_block_at ( anal , addr ) , block , "r_anal_get_block_at" ) ; } for ( i = 0 ; i < SAMPLES ; i ++ ) { ut64 addr = rand ( ) % SPACE ; RList * in = r_anal_get_blocks_in ( anal , addr ) ; RAnalBlock * block ; RListIter * it ; r_list_foreach ( , , ) { mu_assert_eq ( block -> ref , 2 , "block refd in returned list" ) ; } size_t linear_found = 0 ; size_t j ; for ( j = 0 ; j < N ; j ++ ) { if ( ! blocks [ j ] ) { continue ; } if ( r_anal_block_contains ( blocks [ j ] , addr ) ) { linear_found ++ ; mu_assert ( "intersect linear found in list" , r_list_contains ( in , blocks [ j ] ) ) ; } } mu_assert_eq ( ( size_t ) r_list_length ( in ) , linear_found , "r_anal_get_blocks_in count" ) ; r_list_free ( in ) ; } for ( i = 0 ; i < SAMPLES ; i ++ ) { ut64 addr = rand ( ) % SPACE ; ut64 size = rand ( ) % MAXSIZE ; RList * in = r_anal_get_blocks_intersect ( anal , addr , size ) ; RAnalBlock * block ; RListIter * it ; r_list_foreach ( , , ) { mu_assert_eq ( block -> ref , 2 , "block refd in returned list" ) ; } size_t linear_found = 0 ; size_t j ; for ( j = 0 ; j < N ; j ++ ) { RAnalBlock * block = blocks [ j ] ; if ( ! block || addr + size <= block -> addr || addr >= block -> addr + block -> size ) { continue ; } linear_found ++ ; mu_assert ( "in linear found in list" , r_list_contains ( in , blocks [ j ] ) ) ; } mu_assert_eq ( ( size_t ) r_list_length ( in ) , linear_found , "r_anal_get_blocks_intersect count" ) ; r_list_free ( in ) ; } for ( i = 0 ; i < N ; i ++ ) { r_anal_block_unref ( blocks [ i ] ) ; } assert_leaks ( anal ) ; r_anal_free ( anal ) ; mu_end ; } 