static void aus_kill ( struct t_audit_data * tad ) { klwp_t * clwp = ttolwp ( curthread ) ; struct proc * p ; uint32_t signo ; uid_t uid , ruid ; gid_t gid , rgid ; pid_t pid ; const auditinfo_addr_t * ainfo ; cred_t * cr ; a { long pid ; long signo ; } , * uap = ( a * ) clwp -> lwp_ap pid = ( pid_t ) uap -> pid ; signo = ( uint32_t ) uap -> signo ; au_uwrite ( au_to_arg32 ( 2 , "signal" , signo ) ) ; if ( pid > 0 ) { mutex_enter ( & pidlock ) ; if ( ( ( p = prfind ( pid ) ) == ( proc * ) 0 ) || ( p -> p_stat == SIDL ) ) { mutex_exit ( & pidlock ) ; au_uwrite ( au_to_arg32 ( 1 , "process" , ( uint32_t ) pid ) ) ; return ; } mutex_enter ( & p -> p_lock ) ; mutex_exit ( & pidlock ) ; mutex_enter ( & p -> p_crlock ) ; crhold ( cr = p -> p_cred ) ; mutex_exit ( & p -> p_crlock ) ; mutex_exit ( & p -> p_lock ) ; ainfo = crgetauinfo ( cr ) ; if ( ainfo == NULL ) { crfree ( cr ) ; au_uwrite ( au_to_arg32 ( 1 , "process" , ( uint32_t ) pid ) ) ; return ; } uid = crgetuid ( cr ) ; gid = crgetgid ( cr ) ; ruid = crgetruid ( cr ) ; rgid = crgetrgid ( cr ) ; au_uwrite ( au_to_process ( uid , gid , ruid , rgid , pid , ainfo -> ai_auid , ainfo -> ai_asid , & ainfo -> ai_termid ) ) ; crfree ( cr ) ; } else { au_uwrite ( au_to_arg32 ( 1 , "process" , ( uint32_t ) pid ) ) ; } } 