void fusbtc_attach ( struct device * parent , struct device * self , void * aux ) { struct fusbtc_softc * sc = ( fusbtc_softc * ) self ; struct i2c_attach_args * ia = aux ; uint8_t reg ; char * role ; int child ; int len ; sc -> sc_tag = ia -> ia_tag ; sc -> sc_addr = ia -> ia_addr ; sc -> sc_node = * ( int * ) ia -> ia_cookie ; sc -> sc_vbus = OF_getpropint ( sc -> sc_node , "vbus-supply" , 0 ) ; sc -> sc_drp_mode = FUSB_CONTROL2_MODE_NONE ; for ( child = OF_child ( sc -> sc_node ) ; child != 0 ; child = OF_peer ( child ) ) { if ( ! OF_is_compatible ( child , "usb-c-connector" ) ) { continue ; } len = OF_getproplen ( child , "power-role" ) ; role = malloc ( len , M_TEMP , M_WAITOK ) ; OF_getprop ( child , "power-role" , role , len ) ; if ( ! strcmp ( role , "dual" ) ) { sc -> sc_drp_mode = FUSB_CONTROL2_MODE_DRP ; } if ( ! strcmp ( role , "sink" ) ) { sc -> sc_drp_mode = FUSB_CONTROL2_MODE_SNK ; } if ( ! strcmp ( role , "source" ) ) { sc -> sc_drp_mode = FUSB_CONTROL2_MODE_SRC ; } } if ( sc -> sc_drp_mode == FUSB_CONTROL2_MODE_NONE && sc -> sc_vbus ) { sc -> sc_drp_mode = FUSB_CONTROL2_MODE_SRC ; } if ( sc -> sc_drp_mode == FUSB_CONTROL2_MODE_NONE ) { printf ( ": no USB-C connector defined\n" ) ; return ; } timeout_set_proc ( & sc -> sc_bclvl_tmo , fusbtc_bclvl_change , sc ) ; pinctrl_byname ( sc -> sc_node , "default" ) ; task_set ( & sc -> sc_task , fusbtc_task , sc ) ; sc -> sc_ih = fdt_intr_establish ( sc -> sc_node , IPL_BIO , fusbtc_intr , sc , sc -> sc_dev . dv_xname ) ; if ( sc -> sc_ih == NULL ) { printf ( ": unable to establish interrupt\n" ) ; return ; } len = OF_getproplen ( sc -> sc_node , "ss-sel-gpios" ) ; if ( len > 0 ) { sc -> sc_ss_sel = malloc ( len , M_TEMP , M_WAITOK ) ; OF_getpropintarray ( sc -> sc_node , "ss-sel-gpios" , sc -> sc_ss_sel , len ) ; gpio_controller_config_pin ( sc -> sc_ss_sel , GPIO_CONFIG_OUTPUT ) ; gpio_controller_set_pin ( sc -> sc_ss_sel , 1 ) ; } fusbtc_write_reg ( sc , FUSB_RESET , FUSB_RESET_SW ) ; reg = fusbtc_read_reg ( sc , FUSB_CONTROL3 ) ; reg |= FUSB_CONTROL3_AUTO_RETRY ; reg |= FUSB_CONTROL3_N_RETRIES ( 3 ) ; fusbtc_write_reg ( sc , FUSB_CONTROL3 , reg ) ; fusbtc_write_reg ( sc , FUSB_MASK , ~ FUSB_MASK_VBUSOK ) ; fusbtc_write_reg ( sc , FUSB_MASKA , ~ FUSB_MASKA_TOGDONE ) ; fusbtc_write_reg ( sc , FUSB_MASKB , 0xff ) ; reg = fusbtc_read_reg ( sc , FUSB_CONTROL0 ) ; reg &= ~ FUSB_CONTROL0_INT_MASK ; fusbtc_write_reg ( sc , FUSB_CONTROL0 , reg ) ; fusbtc_write_reg ( sc , FUSB_POWER , FUSB_POWER_ALL ) ; sc -> sc_vbus_det = fusbtc_read_reg ( sc , FUSB_STATUS0 ) & FUSB_STATUS0_VBUSOK ; fusbtc_toggle ( sc , 1 ) ; printf ( "\n" ) ; } 