static int read_header ( AVFormatContext * s ) { JVDemuxContext * jv = s -> priv_data ; AVIOContext * pb = s -> pb ; AVStream * vst , * ast ; FFStream * asti ; int64_t audio_pts ; int64_t offset ; avio_skip ( pb , 80 ) ; ast = avformat_new_stream ( s , NULL ) ; vst = avformat_new_stream ( s , NULL ) ; if ( ! ast || ! vst ) { return AVERROR ( ENOMEM ) ; } asti = ffstream ( ast ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; vst -> codecpar -> codec_id = AV_CODEC_ID_JV ; vst -> codecpar -> codec_tag = 0 ; vst -> codecpar -> width = avio_rl16 ( pb ) ; vst -> codecpar -> height = avio_rl16 ( pb ) ; vst -> duration = vst -> nb_frames = asti -> nb_index_entries = avio_rl16 ( pb ) ; avpriv_set_pts_info ( vst , 64 , avio_rl16 ( pb ) , 1000 ) ; avio_skip ( pb , 4 ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; ast -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ; ast -> codecpar -> codec_tag = 0 ; ast -> codecpar -> sample_rate = avio_rl16 ( pb ) ; ast -> codecpar -> ch_layout = ( AVChannelLayout ) AV_CHANNEL_LAYOUT_MONO ; avpriv_set_pts_info ( ast , 64 , 1 , ast -> codecpar -> sample_rate ) ; avio_skip ( pb , 10 ) ; asti -> index_entries = av_malloc ( asti -> nb_index_entries * sizeof ( * asti -> index_entries ) ) ; if ( ! asti -> index_entries ) { return AVERROR ( ENOMEM ) ; } jv -> frames = av_malloc ( asti -> nb_index_entries * sizeof ( * jv -> frames ) ) ; if ( ! jv -> frames ) { return AVERROR ( ENOMEM ) ; } offset = 0x68 + asti -> nb_index_entries * 16 ; for ( int i = 0 ; i < asti -> nb_index_entries ; i ++ ) { AVIndexEntry * e = asti -> index_entries + i ; JVFrame * jvf = jv -> frames + i ; e -> size = avio_rl32 ( pb ) ; e -> timestamp = i ; e -> pos = offset ; offset += e -> size ; jvf -> audio_size = avio_rl32 ( pb ) ; jvf -> video_size = avio_rl32 ( pb ) ; jvf -> palette_size = avio_r8 ( pb ) ?768 : 0 ; if ( ( jvf -> video_size | jvf -> audio_size ) & ~ 0xFFFFFF || e -> size - jvf -> audio_size - jvf -> video_size - jvf -> palette_size < 0 ) { if ( s -> error_recognition & AV_EF_EXPLODE ) { return AVERROR_INVALIDDATA ; } jvf -> audio_size = jvf -> video_size = jvf -> palette_size = 0 ; } if ( avio_r8 ( pb ) ) { av_log ( s , AV_LOG_WARNING , "unsupported audio codec\n" ) ; } jvf -> video_type = avio_r8 ( pb ) ; avio_skip ( pb , 1 ) ; e -> timestamp = jvf -> audio_size ?audio_pts : AV_NOPTS_VALUE ; audio_pts += jvf -> audio_size ; e -> flags = jvf -> video_type != 1 ?AVINDEX_KEYFRAME : 0 ; } jv -> state = JV_AUDIO ; return 0 ; } 