static void __bpf_offload_dev_netdev_unregister ( struct bpf_offload_dev * offdev , struct net_device * netdev ) { struct bpf_offload_netdev * ondev , * altdev = NULL ; struct bpf_offloaded_map * offmap , * mtmp ; struct bpf_prog_offload * offload , * ptmp ; ASSERT_RTNL ( ) ; ondev = rhashtable_lookup_fast ( & offdevs , & netdev , offdevs_params ) ; WARN_ON ( rhashtable_remove_fast ( & offdevs , & ondev -> l , offdevs_params ) ) ; if ( offdev ) { list_del ( & ondev -> offdev_netdevs ) ; altdev = list_first_entry_or_null ( & offdev -> netdevs , bpf_offload_netdev , offdev_netdevs ) ; } if ( altdev ) { list_for_each_entry ( , , ) offload -> netdev = altdev -> netdev ; list_splice_init ( & ondev -> progs , & altdev -> progs ) ; list_for_each_entry ( , , ) offmap -> netdev = altdev -> netdev ; list_splice_init ( & ondev -> maps , & altdev -> maps ) ; } else { list_for_each_entry_safe ( , , , ) __bpf_prog_offload_destroy ( offload -> prog ) ; list_for_each_entry_safe ( , , , ) __bpf_map_offload_destroy ( offmap ) ; } WARN_ON ( ! list_empty ( & ondev -> progs ) ) ; WARN_ON ( ! list_empty ( & ondev -> maps ) ) ; kfree ( ondev ) ; } 