int copy_and_convert_field ( StatementClass * stmt , Int4 field_type , void * value , Int2 fCType , PTR rgbValue , SDWORD cbValueMax , SQLLEN * pcbValue ) { Int4 len = 0 , copy_len = 0 ; SIMPLE_TIME st ; time_t t ; struct tm * tim ; int pcbValueOffset , rgbValueOffset ; char * rgbValueBindRow , * ptr ; int bind_row = stmt -> bind_row ; int bind_size = stmt -> options . bind_size ; int result = COPY_OK ; char * tempBuf ; char saved_locale [ 256 ] ; struct tm tp ; tempBuf = ( char * ) malloc ( TEXT_FIELD_SIZE + 5 ) ; if ( bind_size > 0 ) { pcbValueOffset = rgbValueOffset = ( bind_size * bind_row ) ; } else { pcbValueOffset = bind_row * sizeof ( SDWORD ) ; rgbValueOffset = bind_row * cbValueMax ; } memset ( & st , 0 , sizeof ( SIMPLE_TIME ) ) ; mylog ( "copy_and_convert: field_type = %d, fctype = %d, value = '%s', cbValueMax=%d\n" , field_type , fCType , ( value == NULL ) ?"<NULL>" : value , cbValueMax ) ; if ( ! value ) { if ( pcbValue ) { * ( SDWORD * ) ( ( char * ) pcbValue + pcbValueOffset ) = SQL_NULL_DATA ; } return COPY_OK ; } if ( stmt -> hdbc -> DataSourceToDriver != NULL ) { int length = strlen ( value ) ; stmt -> hdbc -> DataSourceToDriver ( stmt -> hdbc -> translation_option , SQL_CHAR , value , length , value , length , NULL , NULL , 0 , NULL ) ; } switch ( field_type ) { case PG_TYPE_DATE : setup_ts ( st ) ; sscanf ( value , "%4d-%2d-%2d" , & st . y , & st . m , & st . d ) ; break ; case PG_TYPE_TIME : setup_ts ( st ) ; sscanf ( value , "%2d:%2d:%2d" , & st . hh , & st . mm , & st . ss ) ; break ; case PG_TYPE_ABSTIME : case PG_TYPE_DATETIME : case PG_TYPE_TIMESTAMP : case PG_TYPE_TIMESTAMP_NO_TMZONE : setup_ts ( st ) ; if ( strnicmp ( value , "invalid" , 7 ) != 0 ) { sscanf ( value , "%4d-%2d-%2d %2d:%2d:%2d" , & st . y , & st . m , & st . d , & st . hh , & st . mm , & st . ss ) ; } else { t = 0 ; tim = localtime_r ( & t , & tp ) ; tim = localtime ( & t ) ; st . m = tim -> tm_mon + 1 ; st . d = tim -> tm_mday ; st . y = tim -> tm_year + 1900 ; st . hh = tim -> tm_hour ; st . mm = tim -> tm_min ; st . ss = tim -> tm_sec ; } break ; case PG_TYPE_BOOL : { char * s = ( char * ) value ; if ( s [ 0 ] == 'T' || s [ 0 ] == 't' ) { s [ 0 ] = '1' ; } else { s [ 0 ] = '0' ; } } break ; case PG_TYPE_INT2VECTOR : { int nval , i ; char * vp ; short * short_array = ( short * ) ( ( char * ) rgbValue + rgbValueOffset ) ; len = 16 ; vp = value ; nval = 0 ; for ( i = 0 ; i < 8 ; i ++ ) { if ( sscanf ( vp , "%hd" , & short_array [ i ] ) != 1 ) { break ; } nval ++ ; while ( ( * vp != '\0' ) && ( ! isspace ( ( unsigned char ) * vp ) ) ) { vp ++ ; } while ( ( * vp != '\0' ) && ( isspace ( ( unsigned char ) * vp ) ) ) { vp ++ ; } if ( * vp == '\0' ) { break ; } } for ( i = nval ; i < 8 ; i ++ ) { short_array [ i ] = 0 ; } sscanf ( value , "%hd %hd %hd %hd %hd %hd %hd %hd" , & short_array [ 0 ] , & short_array [ 1 ] , & short_array [ 2 ] , & short_array [ 3 ] , & short_array [ 4 ] , & short_array [ 5 ] , & short_array [ 6 ] , & short_array [ 7 ] ) ; if ( pcbValue ) { * ( SDWORD * ) ( ( char * ) pcbValue + pcbValueOffset ) = len ; } free ( tempBuf ) ; return COPY_OK ; } case PG_TYPE_LO : free ( tempBuf ) ; return convert_lo ( stmt , value , fCType , ( ( char * ) rgbValue + rgbValueOffset ) , cbValueMax , ( SDWORD * ) ( ( char * ) pcbValue + pcbValueOffset ) ) ; default : if ( field_type == stmt -> hdbc -> lobj_type ) { free ( tempBuf ) ; return convert_lo ( stmt , value , fCType , ( ( char * ) rgbValue + rgbValueOffset ) , cbValueMax , ( SDWORD * ) ( ( char * ) pcbValue + pcbValueOffset ) ) ; } } if ( fCType == SQL_C_DEFAULT ) { fCType = pgtype_to_ctype ( stmt , field_type ) ; mylog ( "copy_and_convert, SQL_C_DEFAULT: fCType = %d\n" , fCType ) ; } rgbValueBindRow = ( char * ) rgbValue + rgbValueOffset ; if ( fCType == SQL_C_CHAR ) { switch ( field_type ) { case PG_TYPE_DATE : len = 10 ; if ( cbValueMax > len ) { sprintf ( rgbValueBindRow , "%.4d-%.2d-%.2d" , st . y , st . m , st . d ) ; } break ; case PG_TYPE_TIME : len = 8 ; if ( cbValueMax > len ) { sprintf ( rgbValueBindRow , "%.2d:%.2d:%.2d" , st . hh , st . mm , st . ss ) ; } break ; case PG_TYPE_ABSTIME : case PG_TYPE_DATETIME : case PG_TYPE_TIMESTAMP : case PG_TYPE_TIMESTAMP_NO_TMZONE : len = 19 ; if ( cbValueMax > len ) { sprintf ( rgbValueBindRow , "%.4d-%.2d-%.2d %.2d:%.2d:%.2d" , st . y , st . m , st . d , st . hh , st . mm , st . ss ) ; } break ; case PG_TYPE_BOOL : len = 1 ; if ( cbValueMax > len ) { strcpy ( rgbValueBindRow , value ) ; mylog ( "PG_TYPE_BOOL: rgbValueBindRow = '%s'\n" , rgbValueBindRow ) ; } break ; case PG_TYPE_BYTEA : len = convert_pgbinary_to_char ( value , rgbValueBindRow , cbValueMax ) ; break ; default : len = convert_linefeeds ( value , tempBuf , TEXT_FIELD_SIZE + 5 ) ; ptr = tempBuf ; mylog ( "DEFAULT: len = %d, ptr = '%s'\n" , len , ptr ) ; if ( stmt -> current_col >= 0 ) { if ( stmt -> bindings [ stmt -> current_col ] . data_left == 0 ) { free ( tempBuf ) ; return COPY_NO_DATA_FOUND ; } if ( stmt -> bindings [ stmt -> current_col ] . data_left > 0 ) { ptr += len - stmt -> bindings [ stmt -> current_col ] . data_left ; len = stmt -> bindings [ stmt -> current_col ] . data_left ; } else { stmt -> bindings [ stmt -> current_col ] . data_left = strlen ( ptr ) ; } } if ( cbValueMax > 0 ) { copy_len = ( len >= cbValueMax ) ?cbValueMax - 1 : len ; switch ( field_type ) { case PG_TYPE_FLOAT4 : case PG_TYPE_FLOAT8 : case PG_TYPE_NUMERIC : { struct lconv * lc ; char * new_string ; int i , j , dplen ; new_string = malloc ( cbValueMax ) ; lc = localeconv ( ) ; dplen = strlen ( lc -> decimal_point ) ; for ( i = 0 , j = 0 ; ( j < cbValueMax - 1 ) && ptr [ i ] ; i ++ ) { if ( ptr [ i ] == '.' ) { if ( ( j + dplen ) <= ( cbValueMax - 1 ) ) { strncpy ( & new_string [ j ] , lc -> decimal_point , dplen ) ; j += dplen ; } else { break ; } } else { new_string [ j ++ ] = ptr [ i ] ; } } new_string [ j ] = '\0' ; strncpy_null ( rgbValueBindRow , new_string , copy_len + 1 ) ; free ( new_string ) ; break ; } default : strncpy_null ( rgbValueBindRow , ptr , copy_len + 1 ) ; } strncpy_null ( rgbValueBindRow , ptr , copy_len + 1 ) ; if ( stmt -> current_col >= 0 ) { stmt -> bindings [ stmt -> current_col ] . data_left -= copy_len ; } } if ( len >= cbValueMax ) { result = COPY_RESULT_TRUNCATED ; } mylog ( "    SQL_C_CHAR, default: len = %d, cbValueMax = %d, rgbValueBindRow = '%s'\n" , len , cbValueMax , rgbValueBindRow ) ; break ; } } else { if ( field_type == PG_TYPE_MONEY ) { convert_money ( value ) ; } switch ( fCType ) { case SQL_C_DATE : len = 6 ; { DATE_STRUCT * ds ; if ( bind_size > 0 ) { ds = ( DATE_STRUCT * ) ( ( char * ) rgbValue + ( bind_row * bind_size ) ) ; } else { ds = ( DATE_STRUCT * ) rgbValue + bind_row ; } ds -> year = st . y ; ds -> month = st . m ; ds -> day = st . d ; } break ; case SQL_C_TIME : len = 6 ; { TIME_STRUCT * ts ; if ( bind_size > 0 ) { ts = ( TIME_STRUCT * ) ( ( char * ) rgbValue + ( bind_row * bind_size ) ) ; } else { ts = ( TIME_STRUCT * ) rgbValue + bind_row ; } ts -> hour = st . hh ; ts -> minute = st . mm ; ts -> second = st . ss ; } break ; case SQL_C_TIMESTAMP : len = 16 ; { TIMESTAMP_STRUCT * ts ; if ( bind_size > 0 ) { ts = ( TIMESTAMP_STRUCT * ) ( ( char * ) rgbValue + ( bind_row * bind_size ) ) ; } else { ts = ( TIMESTAMP_STRUCT * ) rgbValue + bind_row ; } ts -> year = st . y ; ts -> month = st . m ; ts -> day = st . d ; ts -> hour = st . hh ; ts -> minute = st . mm ; ts -> second = st . ss ; ts -> fraction = 0 ; } break ; case SQL_C_BIT : len = 1 ; if ( bind_size > 0 ) { * ( UCHAR * ) ( ( char * ) rgbValue + ( bind_row * bind_size ) ) = atoi ( value ) ; } else { * ( ( UCHAR * ) rgbValue + bind_row ) = atoi ( value ) ; } break ; case SQL_C_STINYINT : case SQL_C_TINYINT : len = 1 ; if ( bind_size > 0 ) { * ( SCHAR * ) ( ( char * ) rgbValue + ( bind_row * bind_size ) ) = atoi ( value ) ; } else { * ( ( SCHAR * ) rgbValue + bind_row ) = atoi ( value ) ; } break ; case SQL_C_UTINYINT : len = 1 ; if ( bind_size > 0 ) { * ( UCHAR * ) ( ( char * ) rgbValue + ( bind_row * bind_size ) ) = atoi ( value ) ; } else { * ( ( UCHAR * ) rgbValue + bind_row ) = atoi ( value ) ; } break ; case SQL_C_FLOAT : strcpy ( saved_locale , setlocale ( LC_ALL , NULL ) ) ; setlocale ( LC_ALL , "C" ) ; len = 4 ; if ( bind_size > 0 ) { * ( SFLOAT * ) ( ( char * ) rgbValue + ( bind_row * bind_size ) ) = ( float ) atof ( value ) ; } else { * ( ( SFLOAT * ) rgbValue + bind_row ) = ( float ) atof ( value ) ; } setlocale ( LC_ALL , saved_locale ) ; break ; case SQL_C_DOUBLE : strcpy ( saved_locale , setlocale ( LC_ALL , NULL ) ) ; setlocale ( LC_ALL , "C" ) ; len = 8 ; if ( bind_size > 0 ) { * ( SDOUBLE * ) ( ( char * ) rgbValue + ( bind_row * bind_size ) ) = atof ( value ) ; } else { * ( ( SDOUBLE * ) rgbValue + bind_row ) = atof ( value ) ; } setlocale ( LC_ALL , saved_locale ) ; break ; case SQL_C_SSHORT : case SQL_C_SHORT : len = 2 ; if ( bind_size > 0 ) { * ( SWORD * ) ( ( char * ) rgbValue + ( bind_row * bind_size ) ) = atoi ( value ) ; } else { * ( ( SWORD * ) rgbValue + bind_row ) = atoi ( value ) ; } break ; case SQL_C_USHORT : len = 2 ; if ( bind_size > 0 ) { * ( UWORD * ) ( ( char * ) rgbValue + ( bind_row * bind_size ) ) = atoi ( value ) ; } else { * ( ( UWORD * ) rgbValue + bind_row ) = atoi ( value ) ; } break ; case SQL_C_SLONG : case SQL_C_LONG : len = 4 ; if ( bind_size > 0 ) { * ( SDWORD * ) ( ( char * ) rgbValue + ( bind_row * bind_size ) ) = atol ( value ) ; } else { * ( ( SDWORD * ) rgbValue + bind_row ) = atol ( value ) ; } break ; case SQL_C_ULONG : len = 4 ; if ( bind_size > 0 ) { * ( UDWORD * ) ( ( char * ) rgbValue + ( bind_row * bind_size ) ) = atol ( value ) ; } else { * ( ( UDWORD * ) rgbValue + bind_row ) = atol ( value ) ; } break ; case SQL_BIGINT : { long long lv ; len = 8 ; lv = atoll ( value ) ; lv = strtoll ( value , NULL , 10 ) ; lv = atol ( value ) ; if ( bind_size > 0 ) { * ( long long * ) ( ( char * ) rgbValue + ( bind_row * bind_size ) ) = lv ; } else { * ( ( long long * ) rgbValue + bind_row ) = lv ; } } break ; case SQL_C_BINARY : len = convert_from_pgbinary ( value , ( SQLCHAR * ) tempBuf , TEXT_FIELD_SIZE + 5 ) ; ptr = tempBuf ; if ( stmt -> current_col >= 0 ) { if ( stmt -> bindings [ stmt -> current_col ] . data_left == 0 ) { free ( tempBuf ) ; return COPY_NO_DATA_FOUND ; } if ( stmt -> bindings [ stmt -> current_col ] . data_left > 0 ) { ptr += len - stmt -> bindings [ stmt -> current_col ] . data_left ; len = stmt -> bindings [ stmt -> current_col ] . data_left ; } else { stmt -> bindings [ stmt -> current_col ] . data_left = len ; } } if ( cbValueMax > 0 ) { copy_len = ( len > cbValueMax ) ?cbValueMax : len ; memcpy ( rgbValueBindRow , ptr , copy_len ) ; if ( stmt -> current_col >= 0 ) { stmt -> bindings [ stmt -> current_col ] . data_left -= copy_len ; } } if ( len > cbValueMax ) { result = COPY_RESULT_TRUNCATED ; } mylog ( "SQL_C_BINARY: len = %d, copy_len = %d\n" , len , copy_len ) ; break ; default : free ( tempBuf ) ; return COPY_UNSUPPORTED_TYPE ; } } if ( pcbValue ) { * ( SDWORD * ) ( ( char * ) pcbValue + pcbValueOffset ) = len ; } free ( tempBuf ) ; return result ; } 