static void ni1up ( struct PStack * st , int pr , void * arg ) { int i , mt , cr , callState ; char * ptr ; u_char * p ; struct sk_buff * skb = arg ; struct l3_process * proc ; switch ( pr ) { case ( DL_DATA | INDICATION ) : case ( DL_UNIT_DATA | INDICATION ) : break ; case ( DL_ESTABLISH | INDICATION ) : case ( DL_RELEASE | INDICATION ) : case ( DL_RELEASE | CONFIRM ) : l3_msg ( st , pr , arg ) ; return ; break ; case ( DL_ESTABLISH | CONFIRM ) : global_handler ( st , MT_DL_ESTABLISHED , NULL ) ; return ; default : printk ( KERN_ERR "HiSax ni1up unknown pr=%04x\n" , pr ) ; return ; } if ( skb -> len < 3 ) { l3_debug ( st , "ni1up frame too short(%d)" , skb -> len ) ; dev_kfree_skb ( skb ) ; return ; } if ( skb -> data [ 0 ] != PROTO_DIS_EURO ) { if ( st -> l3 . debug & L3_DEB_PROTERR ) { l3_debug ( st , "ni1up%sunexpected discriminator %x message len %d" , ( pr == ( DL_DATA | INDICATION ) ) ?" " : "(broadcast) " , skb -> data [ 0 ] , skb -> len ) ; } dev_kfree_skb ( skb ) ; return ; } cr = getcallref ( skb -> data ) ; if ( skb -> len < ( ( skb -> data [ 1 ] & 0x0f ) + 3 ) ) { l3_debug ( st , "ni1up frame too short(%d)" , skb -> len ) ; dev_kfree_skb ( skb ) ; return ; } mt = skb -> data [ skb -> data [ 1 ] + 2 ] ; if ( st -> l3 . debug & L3_DEB_STATE ) { l3_debug ( st , "ni1up cr %d" , cr ) ; } if ( cr == - 2 ) { if ( st -> l3 . debug & L3_DEB_WARN ) { l3_debug ( st , "ni1up wrong Callref" ) ; } dev_kfree_skb ( skb ) ; return ; } if ( cr == - 1 ) { if ( mt == MT_FACILITY ) { if ( ( p = findie ( skb -> data , skb -> len , IE_FACILITY , 0 ) ) ) { l3ni1_parse_facility ( st , NULL , ( pr == ( DL_DATA | INDICATION ) ) ?- 1 : - 2 , p ) ; dev_kfree_skb ( skb ) ; return ; } } else { global_handler ( st , mt , skb ) ; return ; } if ( st -> l3 . debug & L3_DEB_WARN ) { l3_debug ( st , "ni1up dummy Callref (no facility msg or ie)" ) ; } dev_kfree_skb ( skb ) ; return ; } if ( ( ( ( skb -> data [ 1 ] & 0x0f ) == 1 ) && ( 0 == ( cr & 0x7f ) ) ) || ( ( ( skb -> data [ 1 ] & 0x0f ) == 2 ) && ( 0 == ( cr & 0x7fff ) ) ) ) { if ( st -> l3 . debug & L3_DEB_STATE ) { l3_debug ( st , "ni1up Global CallRef" ) ; } global_handler ( st , mt , skb ) ; dev_kfree_skb ( skb ) ; return ; } if ( ! ( proc = getl3proc ( st , cr ) ) ) { if ( mt == MT_SETUP ) { if ( skb -> data [ 2 ] & 0x80 ) { if ( st -> l3 . debug & L3_DEB_STATE ) { l3_debug ( st , "ni1up wrong CRef flag" ) ; } dev_kfree_skb ( skb ) ; return ; } if ( ! ( proc = ni1_new_l3_process ( st , cr ) ) ) { dev_kfree_skb ( skb ) ; return ; } } if ( mt == MT_STATUS ) { if ( ( ptr = findie ( skb -> data , skb -> len , IE_CAUSE , 0 ) ) != NULL ) { ptr ++ ; if ( * ptr ++ == 2 ) { ptr ++ ; } } callState = 0 ; if ( ( ptr = findie ( skb -> data , skb -> len , IE_CALL_STATE , 0 ) ) != NULL ) { ptr ++ ; if ( * ptr ++ == 2 ) { ptr ++ ; } callState = * ptr ; } if ( callState != 0 ) { if ( ( proc = ni1_new_l3_process ( st , cr ) ) ) { proc -> para . cause = 101 ; l3ni1_msg_without_setup ( proc , 0 , NULL ) ; } } dev_kfree_skb ( skb ) ; return ; } if ( mt == MT_RELEASE_COMPLETE ) { dev_kfree_skb ( skb ) ; return ; } else { dev_kfree_skb ( skb ) ; if ( ( proc = ni1_new_l3_process ( st , cr ) ) ) { proc -> para . cause = 81 ; l3ni1_msg_without_setup ( proc , 0 , NULL ) ; } return ; } } if ( l3ni1_check_messagetype_validity ( proc , mt , skb ) ) { dev_kfree_skb ( skb ) ; return ; } if ( ( p = findie ( skb -> data , skb -> len , IE_DISPLAY , 0 ) ) != NULL ) { l3ni1_deliver_display ( proc , pr , p ) ; } for ( i = 0 ; i < ARRAY_SIZE ( datastatelist ) ; i ++ ) { if ( ( mt == datastatelist [ i ] . primitive ) && ( ( 1 << proc -> state ) & datastatelist [ i ] . state ) ) { break ; } } if ( i == ARRAY_SIZE ( datastatelist ) ) { if ( st -> l3 . debug & L3_DEB_STATE ) { l3_debug ( st , "ni1up%sstate %d mt %#x unhandled" , ( pr == ( DL_DATA | INDICATION ) ) ?" " : "(broadcast) " , proc -> state , mt ) ; } if ( ( MT_RELEASE_COMPLETE != mt ) && ( MT_RELEASE != mt ) ) { proc -> para . cause = 101 ; l3ni1_status_send ( proc , pr , skb ) ; } } else { datastatelist [ i ] . rout ( proc , pr , skb ) ; } dev_kfree_skb ( skb ) ; return ; } 