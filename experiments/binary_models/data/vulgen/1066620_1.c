int nf_log_dump_tcp_header ( struct nf_log_buf * m , const struct sk_buff * skb , u8 proto , int fragment , unsigned int offset , unsigned int logflags ) { struct tcphdr _tcph ; const struct tcphdr * th ; nf_log_buf_add ( m , "PROTO=TCP " ) ; if ( fragment ) { return 0 ; } th = skb_header_pointer ( skb , offset , sizeof ( _tcph ) , & _tcph ) ; if ( th == NULL ) { nf_log_buf_add ( m , "INCOMPLETE [%u bytes] " , skb -> len - offset ) ; return 1 ; } nf_log_buf_add ( m , "SPT=%u DPT=%u " , ntohs ( th -> source ) , ntohs ( th -> dest ) ) ; if ( logflags & NF_LOG_TCPSEQ ) { nf_log_buf_add ( m , "SEQ=%u ACK=%u " , ntohl ( th -> seq ) , ntohl ( th -> ack_seq ) ) ; } nf_log_buf_add ( m , "WINDOW=%u " , ntohs ( th -> window ) ) ; nf_log_buf_add ( m , "RES=0x%02x " , ( u_int8_t ) ( ntohl ( tcp_flag_word ( th ) & TCP_RESERVED_BITS ) >> 22 ) ) ; if ( th -> cwr ) { nf_log_buf_add ( m , "CWR " ) ; } if ( th -> ece ) { nf_log_buf_add ( m , "ECE " ) ; } if ( th -> urg ) { nf_log_buf_add ( m , "URG " ) ; } if ( th -> ack ) { nf_log_buf_add ( m , "ACK " ) ; } if ( th -> psh ) { nf_log_buf_add ( m , "PSH " ) ; } if ( th -> rst ) { nf_log_buf_add ( m , "RST " ) ; } if ( th -> syn ) { nf_log_buf_add ( m , "SYN " ) ; } if ( th -> fin ) { nf_log_buf_add ( m , "FIN " ) ; } nf_log_buf_add ( m , "URGP=%u " , ntohs ( th -> urg_ptr ) ) ; if ( ( logflags & NF_LOG_TCPOPT ) && th -> doff * 4 > sizeof ( tcphdr ) ) { u_int8_t _opt [ 60 - sizeof ( tcphdr ) ] ; const u_int8_t * op ; unsigned int i ; unsigned int optsize = th -> doff * 4 - sizeof ( tcphdr ) ; op = skb_header_pointer ( skb , offset + sizeof ( tcphdr ) , optsize , _opt ) ; nf_log_buf_add ( m , "OPT (" ) ; for ( i = 0 ; i < optsize ; i ++ ) { nf_log_buf_add ( m , "%02X" , op [ i ] ) ; } nf_log_buf_add ( m , ") " ) ; } return 0 ; } 