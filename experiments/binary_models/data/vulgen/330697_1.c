Status_t pa_getVFListResp ( Mai_t * maip , pa_cntxt_t * pa_cntxt ) { uint8_t * data = pa_data ; uint32_t records = 0 ; uint32_t responseSize = 0 , recordSize ; uint32_t attribOffset ; FSTATUS status ; Status_t vStatus ; PmVFList_t VFList = { 0 } ; uint8_t * response = NULL ; int i ; STL_PA_IMAGE_ID_DATA imageId , retImageId ; IB_ENTER ( __func__ , maip , 0 , 0 , 0 ) ; INCREMENT_PM_COUNTER ( pmCounterPaRxGetVFList ) ; IB_LOG_DEBUG1_FMT ( __func__ , "Getting VF list" ) ; if ( maip -> base . aid == STL_PA_ATTRID_GET_VF_LIST2 ) { STL_PA_IMAGE_ID_DATA * p = ( STL_PA_IMAGE_ID_DATA * ) & maip -> data [ STL_PA_DATA_OFFSET ] ; BSWAP_STL_PA_IMAGE_ID ( p ) ; imageId = * p ; recordSize = sizeof ( STL_PA_VF_LIST2 ) ; } else { memset ( & imageId , 0 , sizeof ( STL_PA_IMAGE_ID_DATA ) ) ; recordSize = sizeof ( STL_PA_VF_LIST ) ; } status = paGetVFList ( & g_pmSweepData , & VFList , imageId , & retImageId ) ; if ( status == FSUCCESS && VFList . NumVFs > 0 ) { records = VFList . NumVFs ; responseSize = VFList . NumVFs * recordSize ; if ( responseSize ) { vStatus = vs_pool_alloc ( & pm_pool , responseSize , ( void * ) & response ) ; if ( vStatus != VSTATUS_OK ) { IB_LOG_ERRORRC ( "Failed to allocate response buffer for VFList rc:" , vStatus ) ; status = FINSUFFICIENT_MEMORY ; done } memset ( response , 0 , responseSize ) ; } else { done } IB_LOG_DEBUG2_FMT ( __func__ , "Number of VFs: %u" , VFList . NumVFs ) ; if ( maip -> base . aid == STL_PA_ATTRID_GET_VF_LIST2 ) { STL_PA_VF_LIST2 * resp = ( STL_PA_VF_LIST2 * ) response ; for ( i = 0 ; i < VFList . NumVFs ; i ++ ) { StringCopy ( resp [ i ] . vfName , VFList . VfList [ i ] . Name , STL_PM_VFNAMELEN ) ; IB_LOG_DEBUG2_FMT ( __func__ , "VF %d: %.*s" , i + 1 , ( int ) sizeof ( resp [ i ] . vfName ) , resp [ i ] . vfName ) ; resp [ i ] . imageId = retImageId ; BSWAP_STL_PA_IMAGE_ID ( & resp [ i ] . imageId ) ; } } else { STL_PA_VF_LIST * resp = ( STL_PA_VF_LIST * ) response ; for ( i = 0 ; i < VFList . NumVFs ; i ++ ) { StringCopy ( resp [ i ] . vfName , VFList . VfList [ i ] . Name , STL_PM_VFNAMELEN ) ; IB_LOG_DEBUG2_FMT ( __func__ , "VF %d: %.*s" , i + 1 , ( int ) sizeof ( resp [ i ] . vfName ) , resp [ i ] . vfName ) ; } } memcpy ( data , response , responseSize ) ; } done if ( status == FUNAVAILABLE ) { maip -> base . status = STL_MAD_STATUS_STL_PA_UNAVAILABLE ; } if ( status == FINSUFFICIENT_MEMORY ) { maip -> base . status = MAD_STATUS_SA_NO_RESOURCES ; } if ( status == FINVALID_PARAMETER ) { maip -> base . status = MAD_STATUS_BAD_FIELD ; } if ( status == ( FNOT_FOUND | STL_MAD_STATUS_STL_PA_NO_VF ) ) { maip -> base . status = STL_MAD_STATUS_STL_PA_NO_VF ; } if ( status == ( FINVALID_PARAMETER | STL_MAD_STATUS_STL_PA_INVALID_PARAMETER ) ) { maip -> base . status = STL_MAD_STATUS_STL_PA_INVALID_PARAMETER ; } if ( status == FNOT_FOUND ) { if ( retImageId . imageNumber == BAD_IMAGE_ID ) { maip -> base . status = STL_MAD_STATUS_STL_PA_NO_IMAGE ; } } if ( maip -> base . status != MAD_STATUS_OK ) { records = 0 ; } if ( records == 0 ) { maip -> base . status = MAD_STATUS_SA_NO_RECORDS ; } if ( ( maip -> base . method == STL_PA_CMD_GET ) && ( records != 1 ) ) { IB_LOG_WARN ( "too many records for STL_PA_CMD_GET:" , records ) ; records = 0 ; maip -> base . status = MAD_STATUS_SA_TOO_MANY_RECS ; } attribOffset = recordSize + Calculate_Padding ( recordSize ) ; pa_cntxt -> attribLen = attribOffset / 8 ; pa_cntxt_data ( pa_cntxt , data , records * attribOffset ) ; ( void ) pa_send_reply ( maip , pa_cntxt ) ; if ( VFList . VfList != NULL ) { vs_pool_free ( & pm_pool , VFList . VfList ) ; } IB_EXIT ( __func__ , status ) ; return ( status ) ; } 