void nlm_do_cancel ( nlm4_cancargs * argp , nlm4_res * resp , struct svc_req * sr , nlm_res_cb cb ) { struct nlm_globals * g ; struct nlm_host * host ; struct netbuf * addr ; struct nlm_vhold * nvp = NULL ; nlm_rpc_t * rpcp = NULL ; char * netid ; char * name ; int error ; struct flock64 fl ; nlm_copy_netobj ( & resp -> cookie , & argp -> cookie ) ; netid = svc_getnetid ( sr -> rq_xprt ) ; addr = svc_getrpccaller ( sr -> rq_xprt ) ; name = argp -> alock . caller_name ; host = nlm_host_findcreate ( g , name , netid , addr ) ; if ( host == NULL ) { resp -> stat . stat = nlm4_denied_nolocks ; return ; } if ( cb != NULL ) { error = nlm_host_get_rpc ( host , sr -> rq_vers , & rpcp ) ; if ( error != 0 ) { resp -> stat . stat = nlm4_denied_nolocks ; out } } DTRACE_PROBE3 ( start , nlm_globals * , g , nlm_host * , host , nlm4_cancargs * , argp ) ; if ( NLM_IN_GRACE ( g ) ) { resp -> stat . stat = nlm4_denied_grace_period ; out } nvp = nlm_fh_to_vhold ( host , & argp -> alock . fh ) ; if ( nvp == NULL ) { resp -> stat . stat = nlm4_stale_fh ; out } error = nlm_init_flock ( & fl , & argp -> alock , host , sr -> rq_vers , ( argp -> exclusive ) ?F_WRLCK : F_RDLCK ) ; if ( error ) { resp -> stat . stat = nlm4_failed ; out } error = nlm_slreq_unregister ( host , nvp , & fl ) ; if ( error != 0 ) { resp -> stat . stat = nlm4_denied ; out } fl . l_type = F_UNLCK ; error = nlm_vop_frlock ( nvp -> nv_vp , F_SETLK , & fl , F_REMOTELOCK | FREAD | FWRITE , ( u_offset_t ) 0 , NULL , CRED ( ) , NULL ) ; resp -> stat . stat = ( error == 0 ) ?nlm4_granted : nlm4_denied ; out if ( cb != NULL && rpcp != NULL ) { NLM_INVOKE_CALLBACK ( "cancel" , rpcp , resp , cb ) ; } DTRACE_PROBE3 ( cancel__end , nlm_globals * , g , nlm_host * , host , nlm4_res * , resp ) ; if ( rpcp != NULL ) { nlm_host_rele_rpc ( host , rpcp ) ; } nlm_vhold_release ( host , nvp ) ; nlm_host_release ( g , host ) ; } 