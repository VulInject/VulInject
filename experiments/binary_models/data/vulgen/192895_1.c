static int lkkbd_connect ( struct serio * serio , struct serio_driver * drv ) { struct lkkbd * lk ; struct input_dev * input_dev ; int i ; int err ; lk = kzalloc ( sizeof ( lkkbd ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! lk || ! input_dev ) { err = - ENOMEM ; fail1 } lk -> serio = serio ; lk -> dev = input_dev ; INIT_WORK ( & lk -> tq , lkkbd_reinit ) ; lk -> bell_volume = bell_volume ; lk -> keyclick_volume = keyclick_volume ; lk -> ctrlclick_volume = ctrlclick_volume ; memcpy ( lk -> keycode , lkkbd_keycode , sizeof ( lk -> keycode ) ) ; strlcpy ( lk -> name , "DEC LK keyboard" , sizeof ( lk -> name ) ) ; input_dev -> name = lk -> name ; input_dev -> phys = lk -> phys ; input_dev -> id . bustype = BUS_RS232 ; input_dev -> id . vendor = SERIO_LKKBD ; input_dev -> id . product = 0 ; input_dev -> id . version = 0x0100 ; input_dev -> dev . parent = & serio -> dev ; input_dev -> event = lkkbd_event ; input_set_drvdata ( input_dev , lk ) ; __set_bit ( EV_KEY , input_dev -> evbit ) ; __set_bit ( EV_LED , input_dev -> evbit ) ; __set_bit ( EV_SND , input_dev -> evbit ) ; __set_bit ( EV_REP , input_dev -> evbit ) ; __set_bit ( LED_CAPSL , input_dev -> ledbit ) ; __set_bit ( LED_SLEEP , input_dev -> ledbit ) ; __set_bit ( LED_COMPOSE , input_dev -> ledbit ) ; __set_bit ( LED_SCROLLL , input_dev -> ledbit ) ; __set_bit ( SND_BELL , input_dev -> sndbit ) ; __set_bit ( SND_CLICK , input_dev -> sndbit ) ; input_dev -> keycode = lk -> keycode ; input_dev -> keycodesize = sizeof ( lk -> keycode [ 0 ] ) ; input_dev -> keycodemax = ARRAY_SIZE ( lk -> keycode ) ; for ( i = 0 ; i < LK_NUM_KEYCODES ; i ++ ) { __set_bit ( lk -> keycode [ i ] , input_dev -> keybit ) ; } __clear_bit ( KEY_RESERVED , input_dev -> keybit ) ; serio_set_drvdata ( serio , lk ) ; err = serio_open ( serio , drv ) ; if ( err ) { fail2 } err = input_register_device ( lk -> dev ) ; if ( err ) { fail3 } serio_write ( lk -> serio , LK_CMD_POWERCYCLE_RESET ) ; return 0 ; fail3 serio_close ( serio ) ; fail2 serio_set_drvdata ( serio , NULL ) ; fail1 input_free_device ( input_dev ) ; kfree ( lk ) ; return err ; } 