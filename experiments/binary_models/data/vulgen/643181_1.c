static void sig_print_text ( TEXT_DEST_REC * dest , const char * text , const char * stripped ) { HILIGHT_REC * hilight ; char * color , * newstr ; int old_level , hilight_start , hilight_end , hilight_len ; int nick_match ; if ( dest -> level & MSGLEVEL_NOHILIGHT ) { return ; } hilight_start = hilight_end = 0 ; hilight = hilight_match ( dest -> server , dest -> target , NULL , NULL , dest -> level , stripped , & hilight_start , & hilight_end ) ; if ( hilight == NULL ) { return ; } nick_match = hilight -> nick && ( dest -> level & ( MSGLEVEL_PUBLIC | MSGLEVEL_ACTIONS ) ) == MSGLEVEL_PUBLIC ; old_level = dest -> level ; if ( ! nick_match || ( dest -> level & MSGLEVEL_HILIGHT ) ) { hilight_update_text_dest ( dest , hilight ) ; } if ( nick_match ) { return ; } if ( old_level & MSGLEVEL_HILIGHT ) { return ; } color = hilight_get_color ( hilight ) ; hilight_len = hilight_end - hilight_start ; if ( ! hilight -> word ) { char * tmp = strip_codes ( text ) ; newstr = g_strconcat ( color , tmp , NULL ) ; } else { GString * tmp ; char * middle ; int pos , color_pos , color_len ; tmp = g_string_new ( NULL ) ; pos = strip_real_length ( text , hilight_start , NULL , NULL ) ; g_string_append ( tmp , text ) ; g_string_truncate ( tmp , pos ) ; g_string_append ( tmp , color ) ; middle = strip_codes ( text + pos ) ; pos = tmp -> len ; g_string_append ( tmp , middle ) ; g_string_truncate ( tmp , pos + hilight_len ) ; g_free ( middle ) ; pos = strip_real_length ( text , hilight_end , & color_pos , & color_len ) ; if ( color_pos > 0 ) { g_string_append_len ( tmp , text + color_pos , color_len ) ; } else { g_string_append_c ( tmp , 4 ) ; g_string_append_c ( tmp , FORMAT_STYLE_DEFAULTS ) ; } g_string_append ( tmp , text + pos ) ; newstr = tmp -> str ; g_string_free ( tmp , FALSE ) ; } signal_emit ( "print text" , 3 , dest , newstr , stripped ) ; g_free ( color ) ; g_free ( newstr ) ; signal_stop ( ) ; } 