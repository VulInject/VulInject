SplitedPageLayout * gistSplit ( Relation r , Page page , IndexTuple * itup , int len , GISTSTATE * giststate ) { IndexTuple * lvectup , * rvectup ; GistSplitVector v ; int i ; SplitedPageLayout * res = NULL ; check_stack_depth ( ) ; Assert ( len > 0 ) ; memset ( v . spl_lisnull , true , sizeof ( bool ) * giststate -> nonLeafTupdesc -> natts ) ; memset ( v . spl_risnull , true , sizeof ( bool ) * giststate -> nonLeafTupdesc -> natts ) ; gistSplitByKey ( r , page , itup , len , giststate , & v , 0 ) ; lvectup = ( IndexTuple * ) palloc ( sizeof ( IndexTuple ) * ( len + 1 ) ) ; rvectup = ( IndexTuple * ) palloc ( sizeof ( IndexTuple ) * ( len + 1 ) ) ; for ( i = 0 ; i < v . splitVector . spl_nleft ; i ++ ) { lvectup [ i ] = itup [ v . splitVector . spl_left [ i ] - 1 ] ; } for ( i = 0 ; i < v . splitVector . spl_nright ; i ++ ) { rvectup [ i ] = itup [ v . splitVector . spl_right [ i ] - 1 ] ; } if ( ! gistfitpage ( rvectup , v . splitVector . spl_nright ) ) { res = gistSplit ( r , page , rvectup , v . splitVector . spl_nright , giststate ) ; } else { ROTATEDIST ( res ) ; res -> block . num = v . splitVector . spl_nright ; res -> list = gistfillitupvec ( rvectup , v . splitVector . spl_nright , & ( res -> lenlist ) ) ; res -> itup = gistFormTuple ( giststate , r , v . spl_rattr , v . spl_risnull , false ) ; } if ( ! gistfitpage ( lvectup , v . splitVector . spl_nleft ) ) { SplitedPageLayout * resptr , * subres ; resptr = subres = gistSplit ( r , page , lvectup , v . splitVector . spl_nleft , giststate ) ; while ( resptr -> next ) { resptr = resptr -> next ; } resptr -> next = res ; res = subres ; } else { ROTATEDIST ( res ) ; res -> block . num = v . splitVector . spl_nleft ; res -> list = gistfillitupvec ( lvectup , v . splitVector . spl_nleft , & ( res -> lenlist ) ) ; res -> itup = gistFormTuple ( giststate , r , v . spl_lattr , v . spl_lisnull , false ) ; } return res ; } 