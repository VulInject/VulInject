static CURLcode ossl_connect_step1 ( struct Curl_cfilter * cf , struct Curl_easy * data ) { CURLcode result = CURLE_OK ; char * ciphers ; SSL_METHOD_QUAL SSL_METHOD * req_method = NULL ; struct ssl_connect_data * connssl = cf -> ctx ; ctx_option_t ctx_options = 0 ; void * ssl_sessionid = NULL ; struct ssl_primary_config * conn_config = Curl_ssl_cf_get_primary_config ( cf ) ; struct ssl_config_data * ssl_config = Curl_ssl_cf_get_config ( cf , data ) ; BIO * bio ; bool sni ; const char * hostname = connssl -> hostname ; struct in6_addr addr ; struct in_addr addr ; const long int ssl_version = conn_config -> version ; char * const ssl_cert = ssl_config -> primary . clientcert ; const struct curl_blob * ssl_cert_blob = ssl_config -> primary . cert_blob ; const char * const ssl_cert_type = ssl_config -> cert_type ; const bool verifypeer = conn_config -> verifypeer ; char error_buffer [ 256 ] ; struct ssl_backend_data * backend = connssl -> backend ; DEBUGASSERT ( ssl_connect_1 == connssl -> connecting_state ) ; DEBUGASSERT ( backend ) ; result = ossl_seed ( data ) ; if ( result ) { return result ; } ssl_config -> certverifyresult = ! X509_V_OK ; switch ( ssl_version ) { case CURL_SSLVERSION_DEFAULT : case CURL_SSLVERSION_TLSv1 : case CURL_SSLVERSION_TLSv1_0 : case CURL_SSLVERSION_TLSv1_1 : case CURL_SSLVERSION_TLSv1_2 : case CURL_SSLVERSION_TLSv1_3 : req_method = TLS_client_method ( ) ; use_sni ( TRUE ) ; break ; case CURL_SSLVERSION_SSLv2 : failf ( data , "No SSLv2 support" ) ; return CURLE_NOT_BUILT_IN ; case CURL_SSLVERSION_SSLv3 : failf ( data , "No SSLv3 support" ) ; return CURLE_NOT_BUILT_IN ; default : failf ( data , "Unrecognized parameter passed via CURLOPT_SSLVERSION" ) ; return CURLE_SSL_CONNECT_ERROR ; } if ( backend -> ctx ) { ossl_close ( cf , data ) ; } backend -> ctx = SSL_CTX_new ( req_method ) ; if ( ! backend -> ctx ) { failf ( data , "SSL: couldn't create a context: %s" , ossl_strerror ( ERR_peek_error ( ) , error_buffer , sizeof ( error_buffer ) ) ) ; return CURLE_OUT_OF_MEMORY ; } SSL_CTX_set_mode ( backend -> ctx , SSL_MODE_RELEASE_BUFFERS ) ; if ( data -> set . fdebug && data -> set . verbose ) { SSL_CTX_set_msg_callback ( backend -> ctx , ossl_trace ) ; SSL_CTX_set_msg_callback_arg ( backend -> ctx , cf ) ; } ctx_options = SSL_OP_ALL ; ctx_options |= SSL_OP_NO_TICKET ; ctx_options |= SSL_OP_NO_COMPRESSION ; ctx_options &= ~ SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG ; if ( ! ssl_config -> enable_beast ) { ctx_options &= ~ SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS ; } switch ( ssl_version ) { case CURL_SSLVERSION_SSLv2 : case CURL_SSLVERSION_SSLv3 : return CURLE_NOT_BUILT_IN ; case CURL_SSLVERSION_DEFAULT : case CURL_SSLVERSION_TLSv1 : case CURL_SSLVERSION_TLSv1_0 : case CURL_SSLVERSION_TLSv1_1 : case CURL_SSLVERSION_TLSv1_2 : case CURL_SSLVERSION_TLSv1_3 : ctx_options |= SSL_OP_NO_SSLv2 ; ctx_options |= SSL_OP_NO_SSLv3 ; result = set_ssl_version_min_max ( cf , backend -> ctx ) ; result = set_ssl_version_min_max_legacy ( & ctx_options , cf , data ) ; if ( result != CURLE_OK ) { return result ; } break ; default : failf ( data , "Unrecognized parameter passed via CURLOPT_SSLVERSION" ) ; return CURLE_SSL_CONNECT_ERROR ; } SSL_CTX_set_options ( backend -> ctx , ctx_options ) ; if ( connssl -> alpn ) { struct alpn_proto_buf proto ; result = Curl_alpn_to_proto_buf ( & proto , connssl -> alpn ) ; if ( result || SSL_CTX_set_alpn_protos ( backend -> ctx , proto . data , proto . len ) ) { failf ( data , "Error setting ALPN" ) ; return CURLE_SSL_CONNECT_ERROR ; } Curl_alpn_to_proto_str ( & proto , connssl -> alpn ) ; infof ( data , VTLS_INFOF_ALPN_OFFER_1STR , proto . data ) ; } if ( ssl_cert || ssl_cert_blob || ssl_cert_type ) { if ( ! result && ! cert_stuff ( data , backend -> ctx , ssl_cert , ssl_cert_blob , ssl_cert_type , ssl_config -> key , ssl_config -> key_blob , ssl_config -> key_type , ssl_config -> key_passwd ) ) { result = CURLE_SSL_CERTPROBLEM ; } if ( result ) { return result ; } } ciphers = conn_config -> cipher_list ; if ( ! ciphers ) { ciphers = ( char * ) DEFAULT_CIPHER_SELECTION ; } if ( ciphers ) { if ( ! SSL_CTX_set_cipher_list ( backend -> ctx , ciphers ) ) { failf ( data , "failed setting cipher list: %s" , ciphers ) ; return CURLE_SSL_CIPHER ; } infof ( data , "Cipher selection: %s" , ciphers ) ; } { char * ciphers13 = conn_config -> cipher_list13 ; if ( ciphers13 ) { if ( ! SSL_CTX_set_ciphersuites ( backend -> ctx , ciphers13 ) ) { failf ( data , "failed setting TLS 1.3 cipher suite: %s" , ciphers13 ) ; return CURLE_SSL_CIPHER ; } infof ( data , "TLS 1.3 cipher selection: %s" , ciphers13 ) ; } } SSL_CTX_set_post_handshake_auth ( backend -> ctx , 1 ) ; { char * curves = conn_config -> curves ; if ( curves ) { if ( ! SSL_CTX_set1_curves_list ( backend -> ctx , curves ) ) { failf ( data , "failed setting curves list: '%s'" , curves ) ; return CURLE_SSL_CIPHER ; } } } if ( ssl_config -> primary . username && Curl_auth_allowed_to_host ( data ) ) { char * const ssl_username = ssl_config -> primary . username ; char * const ssl_password = ssl_config -> primary . password ; infof ( data , "Using TLS-SRP username: %s" , ssl_username ) ; if ( ! SSL_CTX_set_srp_username ( backend -> ctx , ssl_username ) ) { failf ( data , "Unable to set SRP user name" ) ; return CURLE_BAD_FUNCTION_ARGUMENT ; } if ( ! SSL_CTX_set_srp_password ( backend -> ctx , ssl_password ) ) { failf ( data , "failed setting SRP password" ) ; return CURLE_BAD_FUNCTION_ARGUMENT ; } if ( ! conn_config -> cipher_list ) { infof ( data , "Setting cipher list SRP" ) ; if ( ! SSL_CTX_set_cipher_list ( backend -> ctx , "SRP" ) ) { failf ( data , "failed setting SRP cipher list" ) ; return CURLE_SSL_CIPHER ; } } } SSL_CTX_set_verify ( backend -> ctx , verifypeer ?SSL_VERIFY_PEER : SSL_VERIFY_NONE , NULL ) ; if ( Curl_tls_keylog_enabled ( ) ) { SSL_CTX_set_keylog_callback ( backend -> ctx , ossl_keylog_callback ) ; } SSL_CTX_set_session_cache_mode ( backend -> ctx , SSL_SESS_CACHE_CLIENT | SSL_SESS_CACHE_NO_INTERNAL ) ; SSL_CTX_sess_set_new_cb ( backend -> ctx , ossl_new_session_cb ) ; if ( data -> set . ssl . fsslctx ) { Curl_set_in_callback ( data , true ) ; result = * data -> set . ssl . fsslctx ( data , backend -> ctx , data -> set . ssl . fsslctxp ) ; Curl_set_in_callback ( data , false ) ; if ( result ) { failf ( data , "error signaled by ssl ctx callback" ) ; return result ; } } if ( backend -> handle ) { SSL_free ( backend -> handle ) ; } backend -> handle = SSL_new ( backend -> ctx ) ; if ( ! backend -> handle ) { failf ( data , "SSL: couldn't create a context (handle)" ) ; return CURLE_OUT_OF_MEMORY ; } SSL_set_app_data ( backend -> handle , cf ) ; ! defined ( ) ; if ( conn_config -> verifystatus ) { SSL_set_tlsext_status_type ( backend -> handle , TLSEXT_STATUSTYPE_ocsp ) ; } SSL_set_renegotiate_mode ( backend -> handle , ssl_renegotiate_freely ) ; SSL_set_connect_state ( backend -> handle ) ; backend -> server_cert = 0x0 ; if ( ( 0 == Curl_inet_pton ( AF_INET , hostname , & addr ) ) && ( 0 == Curl_inet_pton ( AF_INET6 , hostname , & addr ) ) && sni ) { char * snihost = Curl_ssl_snihost ( data , hostname , NULL ) ; if ( ! snihost || ! SSL_set_tlsext_host_name ( backend -> handle , snihost ) ) { failf ( data , "Failed set SNI" ) ; return CURLE_SSL_CONNECT_ERROR ; } } SSL_set_app_data ( backend -> handle , cf ) ; if ( ssl_config -> primary . sessionid ) { Curl_ssl_sessionid_lock ( data ) ; if ( ! Curl_ssl_getsessionid ( cf , data , & ssl_sessionid , NULL ) ) { if ( ! SSL_set_session ( backend -> handle , ssl_sessionid ) ) { Curl_ssl_sessionid_unlock ( data ) ; failf ( data , "SSL: SSL_set_session failed: %s" , ossl_strerror ( ERR_get_error ( ) , error_buffer , sizeof ( error_buffer ) ) ) ; return CURLE_SSL_CONNECT_ERROR ; } infof ( data , "SSL re-using session ID" ) ; } Curl_ssl_sessionid_unlock ( data ) ; } backend -> bio_method = bio_cf_method_create ( ) ; if ( ! backend -> bio_method ) { return CURLE_OUT_OF_MEMORY ; } bio = BIO_new ( backend -> bio_method ) ; if ( ! bio ) { return CURLE_OUT_OF_MEMORY ; } BIO_set_data ( bio , cf ) ; BIO_up_ref ( bio ) ; SSL_set0_rbio ( backend -> handle , bio ) ; SSL_set0_wbio ( backend -> handle , bio ) ; SSL_set_bio ( backend -> handle , bio , bio ) ; connssl -> connecting_state = ssl_connect_2 ; return CURLE_OK ; } 