static struct buffer_head * ocfs2_find_entry_el ( const char * name , int namelen , struct inode * dir , struct ocfs2_dir_entry * * res_dir ) { struct super_block * sb ; struct buffer_head * bh_use [ NAMEI_RA_SIZE ] ; struct buffer_head * bh , * ret = NULL ; unsigned long start , block , b ; int ra_max = 0 ; int ra_ptr = 0 ; int num = 0 ; int nblocks , i ; sb = dir -> i_sb ; nblocks = i_size_read ( dir ) >> sb -> s_blocksize_bits ; start = OCFS2_I ( dir ) -> ip_dir_start_lookup ; if ( start >= nblocks ) { start = 0 ; } block = start ; restart { if ( ra_ptr >= ra_max ) { ra_ptr = 0 ; b = block ; for ( ra_max = 0 ; ra_max < NAMEI_RA_SIZE ; ra_max ++ ) { if ( b >= nblocks || ( num && block == start ) ) { bh_use [ ra_max ] = NULL ; break ; } num ++ ; bh = NULL ; ocfs2_read_dir_block ( dir , b ++ , & bh , OCFS2_BH_READAHEAD ) ; bh_use [ ra_max ] = bh ; } } if ( ( bh = bh_use [ ra_ptr ++ ] ) == NULL ) { next } if ( ocfs2_read_dir_block ( dir , block , & bh , 0 ) ) { mlog ( ML_ERROR , "reading directory %llu, " "offset %lu\n" , ( unsigned long long ) OCFS2_I ( dir ) -> ip_blkno , block ) ; next } i = ocfs2_search_dirblock ( bh , dir , name , namelen , block << sb -> s_blocksize_bits , bh -> b_data , sb -> s_blocksize , res_dir ) ; if ( i == 1 ) { OCFS2_I ( dir ) -> ip_dir_start_lookup = block ; ret = bh ; cleanup_and_exit } else { brelse ( bh ) ; if ( i < 0 ) { cleanup_and_exit } } next if ( ++ block >= nblocks ) { block = 0 ; } } block != start ; block = nblocks ; nblocks = i_size_read ( dir ) >> sb -> s_blocksize_bits ; cleanup_and_exit for ( ; ra_ptr < ra_max ; ra_ptr ++ ) { brelse ( bh_use [ ra_ptr ] ) ; } trace_ocfs2_find_entry_el ( ret ) ; return ret ; } 