static void _trigger_node_event ( trig_mgr_info_t * trig_in , time_t now ) { xassert ( verify_lock ( NODE_LOCK , READ_LOCK ) ) ; if ( ( trig_in -> trig_type & TRIGGER_TYPE_DOWN ) && trigger_down_nodes_bitmap && ( bit_ffs ( trigger_down_nodes_bitmap ) != - 1 ) ) { if ( trig_in -> nodes_bitmap == NULL ) { xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trigger_down_nodes_bitmap ) ; trig_in -> state = 1 ; } if ( bit_overlap_any ( trig_in -> nodes_bitmap , trigger_down_nodes_bitmap ) ) { bit_and ( trig_in -> nodes_bitmap , trigger_down_nodes_bitmap ) ; xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trig_in -> nodes_bitmap ) ; trig_in -> state = 1 ; } if ( trig_in -> state == 1 ) { trig_in -> trig_time = now + ( trig_in -> trig_time - 0x8000 ) ; log_flag ( TRIGGERS , "trigger[%u] for node %s down" , trig_in -> trig_id , trig_in -> res_id ) ; return ; } } if ( ( trig_in -> trig_type & TRIGGER_TYPE_DRAINED ) && trigger_drained_nodes_bitmap && ( bit_ffs ( trigger_drained_nodes_bitmap ) != - 1 ) ) { if ( trig_in -> nodes_bitmap == NULL ) { xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trigger_drained_nodes_bitmap ) ; trig_in -> state = 1 ; } if ( bit_overlap_any ( trig_in -> nodes_bitmap , trigger_drained_nodes_bitmap ) ) { bit_and ( trig_in -> nodes_bitmap , trigger_drained_nodes_bitmap ) ; xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trig_in -> nodes_bitmap ) ; trig_in -> state = 1 ; } if ( trig_in -> state == 1 ) { trig_in -> trig_time = now + ( trig_in -> trig_time - 0x8000 ) ; log_flag ( TRIGGERS , "trigger[%u] for node %s drained" , trig_in -> trig_id , trig_in -> res_id ) ; return ; } } if ( ( trig_in -> trig_type & TRIGGER_TYPE_FAIL ) && trigger_fail_nodes_bitmap && ( bit_ffs ( trigger_fail_nodes_bitmap ) != - 1 ) ) { if ( trig_in -> nodes_bitmap == NULL ) { xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trigger_fail_nodes_bitmap ) ; trig_in -> state = 1 ; } if ( bit_overlap_any ( trig_in -> nodes_bitmap , trigger_fail_nodes_bitmap ) ) { bit_and ( trig_in -> nodes_bitmap , trigger_fail_nodes_bitmap ) ; xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trig_in -> nodes_bitmap ) ; trig_in -> state = 1 ; } if ( trig_in -> state == 1 ) { trig_in -> trig_time = now + ( trig_in -> trig_time - 0x8000 ) ; log_flag ( TRIGGERS , "trigger[%u] for node %s fail" , trig_in -> trig_id , trig_in -> res_id ) ; return ; } } if ( trig_in -> trig_type & TRIGGER_TYPE_IDLE ) { time_t min_idle = now - ( trig_in -> trig_time - 0x8000 ) ; int i ; node_record_t * node_ptr ; bitstr_t * trigger_idle_node_bitmap ; trigger_idle_node_bitmap = bit_alloc ( node_record_count ) ; for ( i = 0 ; ( node_ptr = next_node ( & i ) ) ; i ++ ) { if ( ! IS_NODE_IDLE ( node_ptr ) || ( node_ptr -> last_busy > min_idle ) ) { continue ; } bit_set ( trigger_idle_node_bitmap , node_ptr -> index ) ; } if ( trig_in -> nodes_bitmap == NULL ) { xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trigger_idle_node_bitmap ) ; trig_in -> state = 1 ; } if ( bit_overlap_any ( trig_in -> nodes_bitmap , trigger_idle_node_bitmap ) ) { bit_and ( trig_in -> nodes_bitmap , trigger_idle_node_bitmap ) ; xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trig_in -> nodes_bitmap ) ; trig_in -> state = 1 ; } FREE_NULL_BITMAP ( trigger_idle_node_bitmap ) ; if ( trig_in -> state == 1 ) { trig_in -> trig_time = now ; log_flag ( TRIGGERS , "trigger[%u] for node %s idle" , trig_in -> trig_id , trig_in -> res_id ) ; return ; } } if ( ( trig_in -> trig_type & TRIGGER_TYPE_UP ) && trigger_up_nodes_bitmap && ( bit_ffs ( trigger_up_nodes_bitmap ) != - 1 ) ) { if ( trig_in -> nodes_bitmap == NULL ) { xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trigger_up_nodes_bitmap ) ; trig_in -> state = 1 ; } if ( bit_overlap_any ( trig_in -> nodes_bitmap , trigger_up_nodes_bitmap ) ) { bit_and ( trig_in -> nodes_bitmap , trigger_up_nodes_bitmap ) ; xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trig_in -> nodes_bitmap ) ; trig_in -> state = 1 ; } if ( trig_in -> state == 1 ) { trig_in -> trig_time = now + ( trig_in -> trig_time - 0x8000 ) ; log_flag ( TRIGGERS , "trigger[%u] for node %s up" , trig_in -> trig_id , trig_in -> res_id ) ; return ; } } if ( ( trig_in -> trig_type & TRIGGER_TYPE_DRAINING ) && trigger_draining_nodes_bitmap && ( bit_ffs ( trigger_draining_nodes_bitmap ) != - 1 ) ) { if ( ! trig_in -> nodes_bitmap ) { xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trigger_draining_nodes_bitmap ) ; trig_in -> state = 1 ; } if ( bit_overlap_any ( trig_in -> nodes_bitmap , trigger_draining_nodes_bitmap ) ) { bit_and ( trig_in -> nodes_bitmap , trigger_draining_nodes_bitmap ) ; xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trig_in -> nodes_bitmap ) ; trig_in -> state = 1 ; } if ( trig_in -> state == 1 ) { trig_in -> trig_time = now + ( trig_in -> trig_time - 0x8000 ) ; log_flag ( TRIGGERS , "trigger[%u] for node %s draining" , trig_in -> trig_id , trig_in -> res_id ) ; return ; } } if ( ( trig_in -> trig_type & TRIGGER_TYPE_RESUME ) && trigger_resume_nodes_bitmap && ( bit_ffs ( trigger_resume_nodes_bitmap ) != - 1 ) ) { if ( ! trig_in -> nodes_bitmap ) { xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trigger_resume_nodes_bitmap ) ; trig_in -> state = 1 ; } if ( bit_overlap_any ( trig_in -> nodes_bitmap , trigger_resume_nodes_bitmap ) ) { bit_and ( trig_in -> nodes_bitmap , trigger_resume_nodes_bitmap ) ; xfree ( trig_in -> res_id ) ; trig_in -> res_id = bitmap2node_name ( trig_in -> nodes_bitmap ) ; trig_in -> state = 1 ; } } if ( ( trig_in -> trig_type & TRIGGER_TYPE_RECONFIG ) && trigger_node_reconfig ) { trig_in -> state = 1 ; trig_in -> trig_time = now + ( trig_in -> trig_time - 0x8000 ) ; xfree ( trig_in -> res_id ) ; trig_in -> res_id = xstrdup ( "reconfig" ) ; log_flag ( TRIGGERS , "trigger[%u] for reconfig" , trig_in -> trig_id ) ; return ; } } 