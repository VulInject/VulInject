if ( pp . test & 0x0020 ) { error ( 1 , "VDB#%d %s %s index=%d data=<%lu,%lu>" , __LINE__ , dp -> name , xp -> name , index , ap -> offset , ap -> size ) ; } = e + 1 ; ( sfseek ( sp , 0L , SEEK_SET ) ) ; notvdb if ( ! ( pp . test & 0x4000 ) && ( pp . pool . input || ! ( dp -> type & TYPE_CHECKPOINT ) ) ! ( dp -> type & TYPE_CHECKPOINT ) && ( dp -> info . buffer = sfreserve ( sp , off , 0 ) ) ) { dp -> type |= TYPE_BUFFER ; } else { dp -> info . sp = sp ; if ( pp . pool . input ) { sfset ( sp , SF_SHARE , 1 ) ; } } dp -> type |= TYPE_DIRECTORY ; ( streq ( fp -> name , "." ) ) ; continue ; if ( prefix && * fp -> name != '/' && dp -> index != INC_PREFIX ) { if ( dp -> type & TYPE_DIRECTORY ) { for ( up = dp -> info . subdir ; up ; up = up -> next ) { if ( up -> name == prefix ) { break ; } } if ( ! up ) { up = newof ( 0 , ppdirs , 1 , 0 ) ; up -> name = prefix ; up -> type = dp -> type ; up -> next = dp -> info . subdir ; dp -> info . subdir = up ; if ( ! * dp -> name ) { t = prefix ; } else { sfsprintf ( t = pp . path , PATH_MAX - 1 , "%s/%s" , dp -> name , prefix ) ; } if ( eaccess ( t , X_OK ) ) { message ( ( - 3 , "search: omit %s" , t ) ) ; continue ; } up -> type |= TYPE_HOSTED ; } if ( ! ( up -> type & TYPE_HOSTED ) ) { continue ; } } } mp = xp = 0 ; if ( ! ( flags & SEARCH_NEXT ) && index != dp -> index && ( ! ( need & TYPE_HOSTED ) || dp -> index == INC_STANDARD ) && ( ! ( need & TYPE_VENDOR ) || dp -> index == INC_VENDOR ) ) { if ( index >= 0 && ! ( fp -> flags & INC_MEMBER ( index ) ) ) { fp -> flags |= INC_BOUND ( index ) ; } index = dp -> index ; if ( fp -> flags & INC_BOUND ( index ) ) { xp = fp -> bound [ index ] ; if ( index == INC_PREFIX ) { if ( * fp -> name == '/' || ! * dp -> name ) { strcpy ( pp . path , fp -> name ) ; } else { sfsprintf ( pp . path , PATH_MAX - 1 , "%s/%s" , dp -> name , fp -> name ) ; } pathcanon ( pp . path , PATH_MAX , 0 ) ; if ( ! xp || ! streq ( xp -> name , pp . path ) ) { fp -> bound [ index ] = xp = ppsetfile ( pp . path ) ; if ( dp -> type & TYPE_HOSTED ) { xp -> flags |= INC_HOSTED ; } if ( ( flags & SEARCH_INCLUDE ) || ( xp -> flags & INC_EXISTS ) ) { if ( ! ( flags & SEARCH_INCLUDE ) ) { return 0 ; } if ( ! ppmultiple ( xp , INC_TEST ) ) { if ( flags & SEARCH_TEST ) { pp . include = xp -> name ; } return 0 ; } mp = xp ; } } } if ( ! xp ) { while ( dp -> next && dp -> next -> index == index ) { dp = dp -> next ; } message ( ( - 3 , "search: omit %s/%s" , dp -> name , fp -> name ) ) ; continue ; } else { strcpy ( pp . path , xp -> name ) ; if ( ! ( flags & SEARCH_INCLUDE ) ) { return 0 ; } if ( ! ppmultiple ( xp , INC_TEST ) ) { if ( flags & SEARCH_TEST ) { pp . include = xp -> name ; } return 0 ; } mp = xp ; } } } if ( ! ( fp -> flags & INC_BOUND ( index ) ) || ( flags & SEARCH_NEXT ) ) { if ( * fp -> name == '/' || ! * dp -> name ) { strcpy ( pp . path , fp -> name ) ; } else { sfsprintf ( pp . path , PATH_MAX - 1 , "%s/%s" , dp -> name , fp -> name ) ; } pathcanon ( pp . path , PATH_MAX , 0 ) ; if ( ! ( flags & SEARCH_SKIP ) ) { int found ; struct ppinstk * in ; if ( streq ( error_info . file , pp . path ) ) { found = 1 ; } else { found = 0 ; for ( in = pp . in ; in ; in = in -> prev ) { if ( in -> type == IN_FILE && in -> file && streq ( in -> file , pp . path ) ) { found = 1 ; break ; } } } if ( found ) { flags |= SEARCH_FOUND ; continue ; } if ( ! ( flags & SEARCH_FOUND ) ) { continue ; } } } if ( ( xp || ( xp = ppgetfile ( pp . path ) ) ) && ( xp -> flags & INC_SELF ) ) { if ( xp -> flags & INC_EXISTS ) { if ( ! ( flags & SEARCH_INCLUDE ) ) { return 0 ; } if ( ! ( flags & SEARCH_NEXT ) && mp != xp && ( mp = xp ) && ! ppmultiple ( xp , INC_TEST ) ) { if ( flags & SEARCH_TEST ) { pp . include = xp -> name ; } return 0 ; } } if ( * fp -> name == '/' ) { break ; } else { continue ; } } message ( ( - 3 , "search: file=%s path=%s" , fp -> name , pp . path ) ) ; if ( pp . test & 0x0040 ) { error ( 1 , "SEARCH#%d dir=%s%s%s%s%s file=%s%s path=%s index=%d" , __LINE__ , dp -> name , ( dp -> type & TYPE_ARCHIVE ) ?" ARCHIVE" : "" , ( dp -> type & TYPE_BUFFER ) ?" BUFFER" : "" , ( dp -> type & TYPE_CHECKPOINT ) ?" CHECKPOINT" : "" , ( dp -> type & TYPE_DIRECTORY ) ?" DIRECTORY" : "" , fp -> name , ( fp -> flags & INC_MEMBER ( index ) ) ?" MEMBER" : "" , pp . path , index ) ; } if ( ( fp -> flags & INC_MEMBER ( index ) ) && ( ( ppmember * ) fp -> bound [ index ] ) -> archive == dp ) { fd = 0 ; pp . member = ( ppmember * ) fp -> bound [ index ] ; if ( pp . test & 0x0010 ) { error ( 1 , "SEARCH#%d file=%s path=%s index=%d data=<%lu,%lu>" , __LINE__ , fp -> name , pp . path , index , pp . member -> offset , pp . member -> size ) ; } } if ( ! ( dp -> type & TYPE_DIRECTORY ) ) { continue ; } else { pp . member = 0 ; fd = ( flags & SEARCH_INCLUDE ) ?open ( pp . path , O_RDONLY ) : eaccess ( pp . path , R_OK ) ; } if ( fd >= 0 ) { pp . found = dp ; if ( ( pp . option & ( PLUSPLUS | NOPROTO ) ) == PLUSPLUS && ! ( pp . test & TEST_noproto ) ) { if ( dp -> c ) { pp . mode |= MARKC ; } else { pp . mode &= ~ MARKC ; } } if ( xp ) { markhosted = xp -> flags & INC_HOSTED ; } if ( ! ( markhosted = ( dp -> type & TYPE_HOSTED ) ) && dp -> index == INC_PREFIX && ( pp . mode & ( FILEDEPS | HEADERDEPS | INIT ) ) == FILEDEPS ) { up = dp ; while ( ( up = up -> next ) && ! streq ( up -> name , dp -> name ) ) { } if ( up && ( up -> type & TYPE_HOSTED ) ) { markhosted = 1 ; } } if ( markhosted ) { pp . mode |= MARKHOSTED ; } else { pp . mode &= ~ MARKHOSTED ; } xp = ppsetfile ( pp . path ) ; if ( markhosted ) { xp -> flags |= INC_HOSTED ; } message ( ( - 2 , "search: %s ->%s%s%s" , fp -> name , pp . path , ( pp . mode & MARKC ) ?" [C]" : "" , ( pp . mode & MARKHOSTED ) ?" [hosted]" : "" ) ) ; if ( ! pp . member ) { fp -> flags |= INC_BOUND ( index ) ; fp -> bound [ index ] = xp ; if ( ( index == INC_STANDARD || index == INC_VENDOR ) && type != T_HEADER && ! ( fp -> flags & INC_BOUND ( INC_LOCAL ) ) ) { fp -> flags |= INC_BOUND ( INC_LOCAL ) ; fp -> bound [ INC_LOCAL ] = xp ; } } xp -> flags |= INC_SELF | INC_EXISTS ; if ( flags & SEARCH_INCLUDE ) { if ( ( pp . prefix = prefix ) || ( pp . prefix = pp . in -> prefix ) ) { message ( ( - 2 , "search: %s: prefix=%s" , xp -> name , pp . prefix ) ) ; } if ( ! ( pp . mode & ALLMULTIPLE ) ) { if ( xp -> guard == INC_CLEAR || xp == mp ) { xp -> guard = INC_TEST ; } else { if ( ( pp . state & WARN ) && ( pp . mode & ( HOSTED | MARKHOSTED | RELAX | PEDANTIC ) ) == PEDANTIC ) { error ( 1 , "%s: ignored -- already included" , xp -> name ) ; } else { message ( ( - 3 , "%s: ignored -- already included" , xp -> name ) ) ; } xp -> guard = fp -> guard = INC_IGNORE ; if ( ! pp . member ) { if ( fd > 0 ) { close ( fd ) ; } } return 0 ; } } pp . include = xp -> name ; if ( ( pp . mode & ( FILEDEPS | INIT ) ) == FILEDEPS && ( ( pp . mode & HEADERDEPS ) || ! ( pp . mode & MARKHOSTED ) ) && ! ( xp -> flags & INC_LISTED ) ) { xp -> flags |= INC_LISTED ; if ( ( pp . column + strlen ( xp -> name ) ) >= COLUMN_MAX ) { sfprintf ( pp . filedeps . sp , " \\\n" ) ; pp . column = COLUMN_TAB ; index = '\t' ; } else { index = ' ' ; } pp . column += sfprintf ( pp . filedeps . sp , "%c%s" , index , xp -> name ) ; } } return fd ; } if ( xp ) { xp -> flags |= INC_SELF ; } if ( errno == EMFILE ) { error ( 3 , "%s: too many open files" , fp -> name ) ; } if ( errno != ENOENT && errno != ENOTDIR ) { error ( ERROR_SYSTEM | 1 , "%s: cannot open file for reading" , pp . path ) ; } if ( * fp -> name == '/' ) { break ; } ( pp . path , fp -> name ) ; message ( ( - 2 , "search: %s%s not found" , ( flags & SEARCH_NEXT ) ?"next " : "" , fp -> name ) ) ; return - 1 ; 