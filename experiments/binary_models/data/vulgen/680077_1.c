int o2net_send_message_vec ( u32 msg_type , u32 key , struct kvec * caller_vec , size_t caller_veclen , u8 target_node , int * status ) { int ret = 0 ; struct o2net_msg * msg = NULL ; size_t veclen , caller_bytes = 0 ; struct kvec * vec = NULL ; struct o2net_sock_container * sc = NULL ; struct o2net_node * nn = o2net_nn_from_num ( target_node ) ; struct o2net_status_wait nsw = { . ns_node_item = LIST_HEAD_INIT ( nsw . ns_node_item ) } ; struct o2net_send_tracking nst ; o2net_init_nst ( & nst , msg_type , key , current , target_node ) ; if ( o2net_wq == NULL ) { mlog ( 0 , "attempt to tx without o2netd running\n" ) ; ret = - ESRCH ; out } if ( caller_veclen == 0 ) { mlog ( 0 , "bad kvec array length\n" ) ; ret = - EINVAL ; out } caller_bytes = iov_length ( ( iovec * ) caller_vec , caller_veclen ) ; if ( caller_bytes > O2NET_MAX_PAYLOAD_BYTES ) { mlog ( 0 , "total payload len %zu too large\n" , caller_bytes ) ; ret = - EINVAL ; out } if ( target_node == o2nm_this_node ( ) ) { ret = - ELOOP ; out } o2net_debug_add_nst ( & nst ) ; o2net_set_nst_sock_time ( & nst ) ; wait_event ( nn -> nn_sc_wq , o2net_tx_can_proceed ( nn , & sc , & ret ) ) ; if ( ret ) { out } o2net_set_nst_sock_container ( & nst , sc ) ; veclen = caller_veclen + 1 ; vec = kmalloc_array ( veclen , sizeof ( kvec ) , GFP_ATOMIC ) ; if ( vec == NULL ) { mlog ( 0 , "failed to %zu element kvec!\n" , veclen ) ; ret = - ENOMEM ; out } msg = kmalloc ( sizeof ( o2net_msg ) , GFP_ATOMIC ) ; if ( ! msg ) { mlog ( 0 , "failed to allocate a o2net_msg!\n" ) ; ret = - ENOMEM ; out } o2net_init_msg ( msg , caller_bytes , msg_type , key ) ; vec [ 0 ] . iov_len = sizeof ( o2net_msg ) ; vec [ 0 ] . iov_base = msg ; memcpy ( & vec [ 1 ] , caller_vec , caller_veclen * sizeof ( kvec ) ) ; ret = o2net_prep_nsw ( nn , & nsw ) ; if ( ret ) { out } msg -> msg_num = cpu_to_be32 ( nsw . ns_id ) ; o2net_set_nst_msg_id ( & nst , nsw . ns_id ) ; o2net_set_nst_send_time ( & nst ) ; mutex_lock ( & sc -> sc_send_lock ) ; ret = o2net_send_tcp_msg ( sc -> sc_sock , vec , veclen , sizeof ( o2net_msg ) + caller_bytes ) ; mutex_unlock ( & sc -> sc_send_lock ) ; msglog ( msg , "sending returned %d\n" , ret ) ; o2net_set_nst_status_time ( & nst ) ; wait_event ( nsw . ns_wq , o2net_nsw_completed ( nn , & nsw ) ) ; o2net_update_send_stats ( & nst , sc ) ; ret = o2net_sys_err_to_errno ( nsw . ns_sys_status ) ; if ( status && ! ret ) { * status = nsw . ns_status ; } mlog ( 0 , "woken, returning system status %d, user status %d\n" , ret , nsw . ns_status ) ; out o2net_debug_del_nst ( & nst ) ; if ( sc ) { sc_put ( sc ) ; } kfree ( vec ) ; kfree ( msg ) ; o2net_complete_nsw ( nn , & nsw , 0 , 0 , 0 ) ; return ret ; } 