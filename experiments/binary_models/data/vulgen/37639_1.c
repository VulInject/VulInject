static int mlxsw_pci_cmd_exec ( void * bus_priv , u16 opcode , u8 opcode_mod , u32 in_mod , bool out_mbox_direct , char * in_mbox , size_t in_mbox_size , char * out_mbox , size_t out_mbox_size , u8 * p_status ) { struct mlxsw_pci * mlxsw_pci = bus_priv ; dma_addr_t in_mapaddr = 0 , out_mapaddr = 0 ; bool evreq = mlxsw_pci -> cmd . nopoll ; unsigned long timeout = msecs_to_jiffies ( MLXSW_PCI_CIR_TIMEOUT_MSECS ) ; bool * p_wait_done = & mlxsw_pci -> cmd . wait_done ; int err ; * p_status = MLXSW_CMD_STATUS_OK ; err = mutex_lock_interruptible ( & mlxsw_pci -> cmd . lock ) ; if ( err ) { return err ; } if ( in_mbox ) { memcpy ( mlxsw_pci -> cmd . in_mbox . buf , in_mbox , in_mbox_size ) ; in_mapaddr = mlxsw_pci -> cmd . in_mbox . mapaddr ; } mlxsw_pci_write32 ( mlxsw_pci , CIR_IN_PARAM_HI , upper_32_bits ( in_mapaddr ) ) ; mlxsw_pci_write32 ( mlxsw_pci , CIR_IN_PARAM_LO , lower_32_bits ( in_mapaddr ) ) ; if ( out_mbox ) { out_mapaddr = mlxsw_pci -> cmd . out_mbox . mapaddr ; } mlxsw_pci_write32 ( mlxsw_pci , CIR_OUT_PARAM_HI , upper_32_bits ( out_mapaddr ) ) ; mlxsw_pci_write32 ( mlxsw_pci , CIR_OUT_PARAM_LO , lower_32_bits ( out_mapaddr ) ) ; mlxsw_pci_write32 ( mlxsw_pci , CIR_IN_MODIFIER , in_mod ) ; mlxsw_pci_write32 ( mlxsw_pci , CIR_TOKEN , 0 ) ; * p_wait_done = false ; wmb ( ) ; mlxsw_pci_write32 ( mlxsw_pci , CIR_CTRL , MLXSW_PCI_CIR_CTRL_GO_BIT | ( evreq ?MLXSW_PCI_CIR_CTRL_EVREQ_BIT : 0 ) | ( opcode_mod << MLXSW_PCI_CIR_CTRL_OPCODE_MOD_SHIFT ) | opcode ) ; if ( ! evreq ) { unsigned long end ; end = jiffies + timeout ; { u32 ctrl = mlxsw_pci_read32 ( mlxsw_pci , CIR_CTRL ) ; cond_resched ( ) ; } time_before ( jiffies , end ) ; } else { wait_event_timeout ( mlxsw_pci -> cmd . wait , * p_wait_done , timeout ) ; * p_status = mlxsw_pci -> cmd . comp . status ; } err = 0 ; if ( * p_wait_done ) { if ( * p_status ) { err = - EIO ; } } else { err = - ETIMEDOUT ; } if ( ! err && out_mbox && out_mbox_direct ) { __be32 tmp ; if ( ! evreq ) { tmp = cpu_to_be32 ( mlxsw_pci_read32 ( mlxsw_pci , CIR_OUT_PARAM_HI ) ) ; memcpy ( out_mbox , & tmp , sizeof ( tmp ) ) ; tmp = cpu_to_be32 ( mlxsw_pci_read32 ( mlxsw_pci , CIR_OUT_PARAM_LO ) ) ; memcpy ( out_mbox + sizeof ( tmp ) , & tmp , sizeof ( tmp ) ) ; } } if ( ! err && out_mbox ) { memcpy ( out_mbox , mlxsw_pci -> cmd . out_mbox . buf , out_mbox_size ) ; } mutex_unlock ( & mlxsw_pci -> cmd . lock ) ; return err ; } 