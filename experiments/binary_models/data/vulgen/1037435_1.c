static int mipi_dbi_spi1e_transfer ( struct mipi_dbi * dbi , int dc , const void * buf , size_t len , unsigned int bpw ) { bool swap_bytes = ( bpw == 16 && mipi_dbi_machine_little_endian ( ) ) ; size_t chunk , max_chunk = dbi -> tx_buf9_len ; struct spi_device * spi = dbi -> spi ; struct spi_transfer tr = { . tx_buf = dbi -> tx_buf9 . bits_per_word = 8 } ; struct spi_message m ; const u8 * src = buf ; int i , ret ; u8 * dst ; if ( drm_debug_enabled ( DRM_UT_DRIVER ) ) { pr_debug ( "[drm:%s] dc=%d, max_chunk=%zu, transfers:\n" , __func__ , dc , max_chunk ) ; } tr . speed_hz = mipi_dbi_spi_cmd_max_speed ( spi , len ) ; spi_message_init_with_transfers ( & m , & tr , 1 ) ; if ( ! dc ) { if ( WARN_ON_ONCE ( len != 1 ) ) { return - EINVAL ; } dst = dbi -> tx_buf9 ; memset ( dst , 0 , 9 ) ; tr . len = 9 ; return spi_sync ( spi , & m ) ; } max_chunk = max_chunk / 9 * 8 ; max_chunk = min ( max_chunk , len ) ; max_chunk = max_t ( size_t , 8 , max_chunk & ~ 0x7 ) ; while ( len ) { size_t added = 0 ; chunk = min ( len , max_chunk ) ; len -= chunk ; dst = dbi -> tx_buf9 ; if ( chunk < 8 ) { u8 val , carry = 0 ; memset ( dst , 0 , 9 ) ; if ( swap_bytes ) { for ( i = 1 ; i < ( chunk + 1 ) ; i ++ ) { val = src [ 1 ] ; * dst ++ = carry | BIT ( 8 - i ) | ( val >> i ) ; carry = val << ( 8 - i ) ; i ++ ; val = src [ 0 ] ; * dst ++ = carry | BIT ( 8 - i ) | ( val >> i ) ; carry = val << ( 8 - i ) ; src += 2 ; } * dst ++ = carry ; } else { for ( i = 1 ; i < ( chunk + 1 ) ; i ++ ) { val = * src ++ ; * dst ++ = carry | BIT ( 8 - i ) | ( val >> i ) ; carry = val << ( 8 - i ) ; } * dst ++ = carry ; } chunk = 8 ; added = 1 ; } else { for ( i = 0 ; i < chunk ; i += 8 ) { if ( swap_bytes ) { * dst ++ = BIT ( 7 ) | ( src [ 1 ] >> 1 ) ; * dst ++ = ( src [ 1 ] << 7 ) | BIT ( 6 ) | ( src [ 0 ] >> 2 ) ; * dst ++ = ( src [ 0 ] << 6 ) | BIT ( 5 ) | ( src [ 3 ] >> 3 ) ; * dst ++ = ( src [ 3 ] << 5 ) | BIT ( 4 ) | ( src [ 2 ] >> 4 ) ; * dst ++ = ( src [ 2 ] << 4 ) | BIT ( 3 ) | ( src [ 5 ] >> 5 ) ; * dst ++ = ( src [ 5 ] << 3 ) | BIT ( 2 ) | ( src [ 4 ] >> 6 ) ; * dst ++ = ( src [ 4 ] << 2 ) | BIT ( 1 ) | ( src [ 7 ] >> 7 ) ; * dst ++ = ( src [ 7 ] << 1 ) | BIT ( 0 ) ; * dst ++ = src [ 6 ] ; } else { * dst ++ = BIT ( 7 ) | ( src [ 0 ] >> 1 ) ; * dst ++ = ( src [ 0 ] << 7 ) | BIT ( 6 ) | ( src [ 1 ] >> 2 ) ; * dst ++ = ( src [ 1 ] << 6 ) | BIT ( 5 ) | ( src [ 2 ] >> 3 ) ; * dst ++ = ( src [ 2 ] << 5 ) | BIT ( 4 ) | ( src [ 3 ] >> 4 ) ; * dst ++ = ( src [ 3 ] << 4 ) | BIT ( 3 ) | ( src [ 4 ] >> 5 ) ; * dst ++ = ( src [ 4 ] << 3 ) | BIT ( 2 ) | ( src [ 5 ] >> 6 ) ; * dst ++ = ( src [ 5 ] << 2 ) | BIT ( 1 ) | ( src [ 6 ] >> 7 ) ; * dst ++ = ( src [ 6 ] << 1 ) | BIT ( 0 ) ; * dst ++ = src [ 7 ] ; } src += 8 ; added ++ ; } } tr . len = chunk + added ; ret = spi_sync ( spi , & m ) ; if ( ret ) { return ret ; } } return 0 ; } 