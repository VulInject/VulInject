static void fc_fcp_rec_resp ( struct fc_seq * seq , struct fc_frame * fp , void * arg ) { struct fc_fcp_pkt * fsp = ( fc_fcp_pkt * ) arg ; struct fc_els_rec_acc * recp ; struct fc_els_ls_rjt * rjt ; u32 e_stat ; u8 opcode ; u32 offset ; enum dma_data_direction data_dir ; enum fc_rctl r_ctl ; struct fc_rport_libfc_priv * rpriv ; if ( IS_ERR ( fp ) ) { fc_fcp_rec_error ( fsp , fp ) ; return ; } if ( fc_fcp_lock_pkt ( fsp ) ) { out } fsp -> recov_retry = 0 ; opcode = fc_frame_payload_op ( fp ) ; if ( opcode == ELS_LS_RJT ) { rjt = fc_frame_payload_get ( fp , sizeof ( * rjt ) ) ; switch ( rjt -> er_reason ) { default : FC_FCP_DBG ( fsp , "device %x invalid REC reject %d/%d\n" , fsp -> rport -> port_id , rjt -> er_reason , rjt -> er_explan ) ; fallthrough ; case ELS_RJT_UNSUP : FC_FCP_DBG ( fsp , "device does not support REC\n" ) ; rpriv = fsp -> rport -> dd_data ; rpriv -> flags &= ~ FC_RP_FLAGS_REC_SUPPORTED ; break ; case ELS_RJT_LOGIC : case ELS_RJT_UNAB : FC_FCP_DBG ( fsp , "device %x REC reject %d/%d\n" , fsp -> rport -> port_id , rjt -> er_reason , rjt -> er_explan ) ; if ( rjt -> er_explan == ELS_EXPL_OXID_RXID ) { struct fc_exch * ep = fc_seq_exch ( fsp -> seq_ptr ) ; ep -> state |= FC_EX_QUARANTINE ; fsp -> state |= FC_SRB_ABORTED ; fc_fcp_retry_cmd ( fsp , FC_TRANS_RESET ) ; break ; } fc_fcp_recovery ( fsp , FC_TRANS_RESET ) ; break ; } } if ( opcode == ELS_LS_ACC ) { if ( fsp -> state & FC_SRB_ABORTED ) { unlock_out } data_dir = fsp -> cmd -> sc_data_direction ; recp = fc_frame_payload_get ( fp , sizeof ( * recp ) ) ; offset = ntohl ( recp -> reca_fc4value ) ; e_stat = ntohl ( recp -> reca_e_stat ) ; if ( e_stat & ESB_ST_COMPLETE ) { if ( data_dir == DMA_TO_DEVICE ) { r_ctl = FC_RCTL_DD_CMD_STATUS ; } if ( fsp -> xfer_contig_end == offset ) { r_ctl = FC_RCTL_DD_CMD_STATUS ; } else { offset = fsp -> xfer_contig_end ; r_ctl = FC_RCTL_DD_SOL_DATA ; } fc_fcp_srr ( fsp , r_ctl , offset ) ; } if ( e_stat & ESB_ST_SEQ_INIT ) { fc_fcp_timer_set ( fsp , get_fsp_rec_tov ( fsp ) ) ; } else { r_ctl = FC_RCTL_DD_SOL_DATA ; if ( data_dir == DMA_TO_DEVICE ) { r_ctl = FC_RCTL_DD_CMD_STATUS ; } if ( offset == fsp -> xfer_contig_end ) { r_ctl = FC_RCTL_DD_CMD_STATUS ; } if ( fsp -> xfer_contig_end < offset ) { offset = fsp -> xfer_contig_end ; } fc_fcp_srr ( fsp , r_ctl , offset ) ; } } unlock_out fc_fcp_unlock_pkt ( fsp ) ; out fc_fcp_pkt_release ( fsp ) ; fc_frame_free ( fp ) ; } 