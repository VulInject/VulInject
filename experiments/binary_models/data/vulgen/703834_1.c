static int check_allowed_keys_line ( const char * path , u_long linenum , char * line , const struct sshkey * sign_key , const char * principal , const char * sig_namespace , uint64_t verify_time , char * * principalsp ) { struct sshkey * found_key = NULL ; char * principals = NULL ; int r , success = 0 ; const char * reason = NULL ; struct sshsigopt * sigopts = NULL ; char tvalid [ 64 ] , tverify [ 64 ] ; if ( ( r = parse_principals_key_and_options ( path , linenum , line , principal , & principals , & found_key , & sigopts ) ) != 0 ) { done } if ( ! sigopts -> ca && sshkey_equal ( found_key , sign_key ) ) { debug ( "%s:%lu: matched key" , path , linenum ) ; } if ( sigopts -> ca && sshkey_is_cert ( sign_key ) && sshkey_equal_public ( sign_key -> cert -> signature_key , found_key ) ) { if ( principal ) { if ( ( r = sshkey_cert_check_authority ( sign_key , 0 , 1 , 0 , verify_time , principal , & reason ) ) != 0 ) { error ( "%s:%lu: certificate not authorized: %s" , path , linenum , reason ) ; done } debug ( "%s:%lu: matched certificate CA key" , path , linenum ) ; } else { if ( ( r = cert_filter_principals ( path , linenum , & principals , sign_key , verify_time ) ) != 0 ) { debug_r ( r , "%s:%lu: cert_filter_principals" , path , linenum ) ; done } debug ( "%s:%lu: matched certificate CA key" , path , linenum ) ; } } else { done } if ( sigopts -> namespaces != NULL && sig_namespace != NULL && match_pattern_list ( sig_namespace , sigopts -> namespaces , 0 ) != 1 ) { error ( "%s:%lu: key is not permitted for use in signature " "namespace \"%s\"" , path , linenum , sig_namespace ) ; done } format_absolute_time ( ( uint64_t ) verify_time , tverify , sizeof ( tverify ) ) ; if ( sigopts -> valid_after != 0 && ( uint64_t ) verify_time < sigopts -> valid_after ) { format_absolute_time ( sigopts -> valid_after , tvalid , sizeof ( tvalid ) ) ; error ( "%s:%lu: key is not yet valid: " "verify time %s<valid-after %s" , path , linenum , tverify , tvalid ) ; done } if ( sigopts -> valid_before != 0 && ( uint64_t ) verify_time > sigopts -> valid_before ) { format_absolute_time ( sigopts -> valid_before , tvalid , sizeof ( tvalid ) ) ; error ( "%s:%lu: key has expired: " "verify time %s>valid-before %s" , path , linenum , tverify , tvalid ) ; done } success = 1 ; done if ( success && principalsp != NULL ) { * principalsp = principals ; principals = NULL ; } free ( principals ) ; sshkey_free ( found_key ) ; sshsigopt_free ( sigopts ) ; return success ?0 : SSH_ERR_KEY_NOT_FOUND ; } 