td -> td_cb = * tp ; bzero ( & td -> td_ti6 , sizeof ( tcpipv6hdr ) ) ; bzero ( & td -> td_ti , sizeof ( tcpiphdr ) ) ; if ( headers ) { if ( pf == PF_UNSPEC ) { switch ( ti6 -> ti6_i . ip6_vfc & IPV6_VERSION_MASK ) { case IPV6_VERSION : pf = PF_INET6 ; break ; case IPVERSION : pf = PF_INET ; break ; } } switch ( pf ) { case PF_INET6 : th = & ti6 -> ti6_t ; td -> td_ti6 = * ti6 ; td -> td_ti6 . ti6_plen = len ; break ; case PF_INET : th = & ti -> ti_t ; td -> td_ti = * ti ; td -> td_ti . ti_len = len ; break ; default : headers = NULL ; break ; } } td -> td_req = req ; if ( tcpconsdebug == 0 ) { return ; } if ( otp ) { printf ( "%p %s:" , otp , tcpstates [ ostate ] ) ; } else { printf ( "???????? " ) ; } printf ( "%s " , tanames [ act ] ) ; switch ( act ) { case TA_INPUT : case TA_OUTPUT : case TA_DROP : if ( headers == NULL ) { break ; } seq = th -> th_seq ; ack = th -> th_ack ; if ( act == TA_OUTPUT ) { seq = ntohl ( seq ) ; ack = ntohl ( ack ) ; } if ( len ) { printf ( "[%x..%x)" , seq , seq + len ) ; } else { printf ( "%x" , seq ) ; } printf ( "@%x, urp=%x" , ack , th -> th_urp ) ; flags = th -> th_flags ; if ( flags ) { char * cp = "<" ; pf ( SYN ) ; pf ( ACK ) ; pf ( FIN ) ; pf ( RST ) ; pf ( PUSH ) ; pf ( URG ) ; printf ( ">" ) ; } break ; case TA_USER : printf ( "%s" , prurequests [ req ] ) ; break ; case TA_TIMER : printf ( "%s" , tcptimers [ req ] ) ; break ; } if ( tp ) { printf ( " ->%s" , tcpstates [ tp -> t_state ] ) ; } printf ( "\n" ) ; if ( tp == NULL ) { return ; } printf ( "\trcv_(nxt,wnd,up) (%x,%lx,%x) snd_(una,nxt,max) (%x,%x,%x)\n" , tp -> rcv_nxt , tp -> rcv_wnd , tp -> rcv_up , tp -> snd_una , tp -> snd_nxt , tp -> snd_max ) ; printf ( "\tsnd_(wl1,wl2,wnd) (%x,%x,%lx)\n" , tp -> snd_wl1 , tp -> snd_wl2 , tp -> snd_wnd ) ; 