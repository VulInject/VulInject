static int page_reporting_cycle ( struct page_reporting_dev_info * prdev , struct zone * zone , unsigned int order , unsigned int mt , struct scatterlist * sgl , unsigned int * offset ) { struct free_area * area = & zone -> free_area [ order ] ; struct list_head * list = & area -> free_list [ mt ] ; unsigned int page_len = PAGE_SIZE << order ; struct page * page , * next ; long budget ; int err = 0 ; if ( list_empty ( list ) ) { return err ; } spin_lock_irq ( & zone -> lock ) ; budget = DIV_ROUND_UP ( area -> nr_free , PAGE_REPORTING_CAPACITY * 16 ) ; list_for_each_entry_safe ( , , , ) { if ( PageReported ( page ) ) { continue ; } if ( budget < 0 ) { atomic_set ( & prdev -> state , PAGE_REPORTING_REQUESTED ) ; next = page ; break ; } if ( * offset ) { if ( ! __isolate_free_page ( page , order ) ) { next = page ; break ; } -- ( * offset ) ; sg_set_page ( & sgl [ * offset ] , page , page_len , 0 ) ; continue ; } if ( ! list_is_first ( & page -> lru , list ) ) { list_rotate_to_front ( & page -> lru , list ) ; } spin_unlock_irq ( & zone -> lock ) ; err = prdev -> report ( prdev , sgl , PAGE_REPORTING_CAPACITY ) ; * offset = PAGE_REPORTING_CAPACITY ; budget -- ; spin_lock_irq ( & zone -> lock ) ; next = list_first_entry ( list , page , lru ) ; if ( err ) { break ; } } if ( ! list_entry_is_head ( next , list , lru ) && ! list_is_first ( & next -> lru , list ) ) { list_rotate_to_front ( & next -> lru , list ) ; } spin_unlock_irq ( & zone -> lock ) ; return err ; } 