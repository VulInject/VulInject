uintptr_t ld_unwind_make_hdr ( Ofl_desc * ofl ) { int bswap = ( ofl -> ofl_flags1 & FLG_OF1_ENCDIFF ) != 0 ; Shdr * shdr ; Elf_Data * elfdata ; Is_desc * isp ; size_t size ; Xword fde_cnt ; Aliste idx1 ; Os_desc * osp ; if ( ( elfdata = libld_calloc ( 1 , sizeof ( Elf_Data ) ) ) == NULL ) { return ( S_ERROR ) ; } elfdata -> d_type = ELF_T_BYTE ; elfdata -> d_align = ld_targ . t_m . m_word_align ; elfdata -> d_version = ofl -> ofl_dehdr -> e_version ; if ( ( shdr = libld_calloc ( 1 , sizeof ( Shdr ) ) ) == NULL ) { return ( S_ERROR ) ; } shdr -> sh_type = ld_targ . t_m . m_sht_unwind ; shdr -> sh_flags = SHF_ALLOC ; shdr -> sh_addralign = ld_targ . t_m . m_word_align ; shdr -> sh_entsize = 0 ; if ( ( isp = libld_calloc ( 1 , sizeof ( Is_desc ) ) ) == NULL ) { return ( S_ERROR ) ; } isp -> is_name = MSG_ORIG ( MSG_SCN_UNWINDHDR ) ; isp -> is_shdr = shdr ; isp -> is_indata = elfdata ; if ( ( ofl -> ofl_unwindhdr = ld_place_section ( ofl , isp , NULL , ld_targ . t_id . id_unwindhdr , NULL ) ) == ( Os_desc * ) S_ERROR ) { return ( S_ERROR ) ; } fde_cnt = 0 ; for ( APLIST_TRAVERSE ( ofl -> ofl_unwind , idx1 , osp ) ; ) { Aliste idx2 ; int os_isdescs_idx ; OS_ISDESCS_TRAVERSE ( , , , ) { uchar_t * data ; uint64_t off = 0 ; data = isp -> is_indata -> d_buf ; size = isp -> is_indata -> d_size ; while ( off < size ) { uint_t length , id ; uint64_t ndx = 0 ; length = extract_uint ( data + off , & ndx , bswap ) ; if ( length == 0 ) { break ; } id = extract_uint ( data + off , & ndx , bswap ) ; if ( id == 0 ) { uint_t cieversion ; cieversion = data [ off + ndx ] ; ndx += 1 ; if ( cieversion != 1 && cieversion != 3 ) { ld_eprintf ( ofl , ERR_FATAL , MSG_INTL ( MSG_UNW_BADCIEVERS ) , isp -> is_file -> ifl_name , isp -> is_name , off ) ; return ( S_ERROR ) ; } } else { fde_cnt ++ ; } off += length + 4 ; } } } size = 12 + ( 8 * fde_cnt ) ; if ( ( elfdata -> d_buf = libld_calloc ( size , 1 ) ) == NULL ) { return ( S_ERROR ) ; } elfdata -> d_size = size ; shdr -> sh_size = ( Xword ) size ; return ( 1 ) ; } 