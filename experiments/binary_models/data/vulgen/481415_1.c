int send_subscribe ( subs_info_t * subs ) { ua_pres_t * presentity = NULL ; str met = { "SUBSCRIBE" 9 } ; str * str_hdr = NULL ; int ret = - 1 ; unsigned int hash_code = 0 ; ua_pres_t * hentity = NULL ; int expires ; int flag ; int result ; uac_req_t uac_r ; db1_res_t * res = NULL ; ua_pres_t dbpres ; str pres_uri = { 0 0 } , watcher_uri = { 0 0 } , extra_headers = { 0 0 } ; dlg_t * td = NULL ; memset ( & dbpres , 0 , sizeof ( dbpres ) ) ; dbpres . pres_uri = & pres_uri ; dbpres . watcher_uri = & watcher_uri ; dbpres . extra_headers = & extra_headers ; print_subs ( subs ) ; flag = subs -> source_flag ; if ( subs -> source_flag & XMPP_INITIAL_SUBS ) { subs -> source_flag = XMPP_SUBSCRIBE ; } if ( subs -> expires < 0 ) { expires = pua_default_expires ; } else { expires = subs -> expires ; } str_hdr = subs_build_hdr ( subs -> contact , expires , subs -> event , subs -> extra_headers ) ; if ( str_hdr == NULL || str_hdr -> s == NULL ) { LM_ERR ( "while building extra headers\n" ) ; if ( str_hdr ) { LM_ERR ( 0 ) ; } return - 1 ; } if ( dbmode == PUA_DB_ONLY && pua_dbf . start_transaction ) { if ( pua_dbf . start_transaction ( pua_db , db_table_lock ) < 0 ) { LM_ERR ( "in start_transaction\n" ) ; error } } if ( dbmode == PUA_DB_ONLY ) { presentity = get_dialog_puadb ( subs -> id , subs -> pres_uri , & dbpres , & res ) ; } else { ua_pres_t pres ; memset ( & pres , 0 , sizeof ( ua_pres_t ) ) ; pres . pres_uri = subs -> pres_uri ; pres . watcher_uri = subs -> watcher_uri ; pres . flag = subs -> source_flag ; pres . id = subs -> id ; pres . event = subs -> event ; if ( subs -> remote_target ) { pres . remote_contact = * subs -> remote_target ; } hash_code = core_hash ( subs -> pres_uri , subs -> watcher_uri , HASH_SIZE ) ; lock_get ( & HashT -> p_records [ hash_code ] . lock ) ; presentity = search_htable ( & pres , hash_code ) ; } if ( subs -> flag & INSERT_TYPE ) { LM_DBG ( "A subscription request with insert type\n" ) ; insert } if ( presentity == NULL ) { int size ; insert if ( subs -> expires == 0 ) { if ( dbmode != PUA_DB_ONLY ) { lock_release ( & HashT -> p_records [ hash_code ] . lock ) ; } done } if ( subs -> flag & UPDATE_TYPE ) { LM_DBG ( "request for a subscription with update type" " and no record found\n" ) ; subs -> flag = INSERT_TYPE ; } hentity = subscribe_cbparam ( subs , REQ_OTHER ) ; if ( hentity == NULL ) { LM_ERR ( "while building callback" " param\n" ) ; if ( dbmode != PUA_DB_ONLY ) { lock_release ( & HashT -> p_records [ hash_code ] . lock ) ; } error } hentity -> flag = flag ; set_uac_req ( & uac_r , & met , str_hdr , 0 , 0 , TMCB_LOCAL_COMPLETED , subs_cback_func , ( void * ) hentity ) ; result = tmb . t_request_outside ( & uac_r , subs -> remote_target ?subs -> remote_target : subs -> pres_uri , subs -> pres_uri , subs -> watcher_uri , subs -> outbound_proxy ) ; if ( result < 0 ) { LM_ERR ( "while sending request with t_request\n" ) ; if ( uac_r . dialog != NULL ) { uac_r . dialog -> rem_target . s = 0 ; uac_r . dialog -> dst_uri . s = 0 ; tmb . free_dlg ( uac_r . dialog ) ; uac_r . dialog = 0 ; } shm_free ( hentity ) ; if ( dbmode != PUA_DB_ONLY ) { lock_release ( & HashT -> p_records [ hash_code ] . lock ) ; } ret = 0 ; error } size = sizeof ( ua_pres_t ) + 2 * sizeof ( str ) + ( subs -> pres_uri -> len + subs -> watcher_uri -> len + uac_r . dialog -> id . loc_tag . len + uac_r . dialog -> id . call_id . len + subs -> id . len ) * sizeof ( char ) ; presentity = ( ua_pres_t * ) shm_malloc ( size ) ; if ( presentity == NULL ) { SHM_MEM_ERROR ; if ( dbmode != PUA_DB_ONLY ) { lock_release ( & HashT -> p_records [ hash_code ] . lock ) ; } error } memset ( presentity , 0 , size ) ; size = sizeof ( ua_pres_t ) ; presentity -> pres_uri = ( str * ) ( ( char * ) presentity + size ) ; size += sizeof ( str ) ; presentity -> pres_uri -> s = ( char * ) presentity + size ; memcpy ( presentity -> pres_uri -> s , subs -> pres_uri -> s , subs -> pres_uri -> len ) ; presentity -> pres_uri -> len = subs -> pres_uri -> len ; size += subs -> pres_uri -> len ; presentity -> watcher_uri = ( str * ) ( ( char * ) presentity + size ) ; size += sizeof ( str ) ; presentity -> watcher_uri -> s = ( char * ) presentity + size ; memcpy ( presentity -> watcher_uri -> s , subs -> watcher_uri -> s , subs -> watcher_uri -> len ) ; presentity -> watcher_uri -> len = subs -> watcher_uri -> len ; size += subs -> watcher_uri -> len ; presentity -> call_id . s = ( char * ) presentity + size ; memcpy ( presentity -> call_id . s , uac_r . dialog -> id . call_id . s , uac_r . dialog -> id . call_id . len ) ; presentity -> call_id . len = uac_r . dialog -> id . call_id . len ; size += uac_r . dialog -> id . call_id . len ; presentity -> from_tag . s = ( char * ) presentity + size ; memcpy ( presentity -> from_tag . s , uac_r . dialog -> id . loc_tag . s , uac_r . dialog -> id . loc_tag . len ) ; presentity -> from_tag . len = uac_r . dialog -> id . loc_tag . len ; size += uac_r . dialog -> id . loc_tag . len ; presentity -> id . s = ( char * ) presentity + size ; memcpy ( presentity -> id . s , subs -> id . s , subs -> id . len ) ; presentity -> id . len = subs -> id . len ; size += subs -> id . len ; presentity -> event = subs -> event ; presentity -> flag = subs -> source_flag ; presentity -> cseq = uac_r . dialog -> loc_seq . value ; presentity -> expires = ( int ) time ( NULL ) + 64 ; presentity -> desired_expires = presentity -> expires ; if ( dbmode == PUA_DB_ONLY ) { insert_dialog_puadb ( presentity ) ; shm_free ( presentity ) ; } else { insert_htable ( presentity , hash_code ) ; lock_release ( & HashT -> p_records [ hash_code ] . lock ) ; } uac_r . dialog -> rem_target . s = 0 ; uac_r . dialog -> dst_uri . s = 0 ; tmb . free_dlg ( uac_r . dialog ) ; uac_r . dialog = 0 ; } else { if ( subs -> internal_update_flag == INTERNAL_UPDATE_TRUE ) { LM_INFO ( "attempting to re-SUBSCRIBE on internal (rls_update_subs()) update - skipping\n" ) ; if ( dbmode != PUA_DB_ONLY ) { lock_release ( & HashT -> p_records [ hash_code ] . lock ) ; } done } if ( presentity -> to_tag . len == 0 ) { if ( subs -> expires > 0 ) { LM_WARN ( "attempting to re-SUBSCRIBE to a temporary (non-established) dialog - skipping\n" ) ; } else { LM_WARN ( "attempting to un-SUBSCRIBE from a temporary (non-established) dialog - skipping and deleting dialog\n" ) ; if ( dbmode == PUA_DB_ONLY ) { delete_dialog_puadb ( presentity ) ; } else { delete_htable ( presentity , hash_code ) ; } } if ( dbmode != PUA_DB_ONLY ) { lock_release ( & HashT -> p_records [ hash_code ] . lock ) ; } done } td = pua_build_dlg_t ( presentity ) ; if ( td == NULL ) { LM_ERR ( "while building tm dlg_t structure" ) ; if ( dbmode != PUA_DB_ONLY ) { lock_release ( & HashT -> p_records [ hash_code ] . lock ) ; } error } hentity = subs_cbparam_indlg ( presentity , expires , REQ_OTHER ) ; if ( hentity == NULL ) { LM_ERR ( "while building callback param\n" ) ; if ( dbmode != PUA_DB_ONLY ) { lock_release ( & HashT -> p_records [ hash_code ] . lock ) ; } error } if ( dbmode != PUA_DB_ONLY ) { lock_release ( & HashT -> p_records [ hash_code ] . lock ) ; } LM_DBG ( "event parameter: %d\n" , hentity -> event ) ; set_uac_req ( & uac_r , & met , str_hdr , 0 , td , TMCB_LOCAL_COMPLETED , subs_cback_func , ( void * ) hentity ) ; result = tmb . t_request_within ( & uac_r ) ; if ( result < 0 ) { shm_free ( hentity ) ; hentity = NULL ; LM_ERR ( "while sending request with t_request\n" ) ; error } } done if ( dbmode == PUA_DB_ONLY && pua_dbf . end_transaction ) { if ( pua_dbf . end_transaction ( pua_db ) < 0 ) { LM_ERR ( "in end_transaction\n" ) ; error } } ret = 0 ; error pua_free_tm_dlg ( td ) ; pkg_free ( str_hdr ) ; free_results_puadb ( res ) ; if ( dbmode == PUA_DB_ONLY && pua_dbf . abort_transaction ) { if ( pua_dbf . abort_transaction ( pua_db ) < 0 ) { LM_ERR ( "in abort_transaction\n" ) ; } } return ret ; } 