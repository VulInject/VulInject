FSTATUS AcceptA ( IN CM_CEP_OBJECT * pCEP , IN CM_CONN_INFO * pSendConnInfo ) { FSTATUS Status = FSUCCESS ; uint64 elapsed_us ; _DBG_ENTER_LVL ( _DBG_LVL_FUNC_TRACE , AcceptA ) ; SpinLockAcquire ( & gCM -> ListLock ) ; switch ( pCEP -> State ) { case CMS_IDLE : if ( BitTest ( pCEP -> EventFlags , USRE_CANCEL ) ) { Status = FCM_CONNECT_CANCEL ; } else { Status = FERROR ; } break ; case CMS_REP_RCVD : case CMS_MRA_REP_SENT : elapsed_us = CmGetElapsedTime ( pCEP ) ; gCM -> turnaround_time_us = UpdateTurnaroundTime ( gCM -> turnaround_time_us , elapsed_us ) ; _DBG_INFO ( ( "Update turnaround time<tat %" PRIu64 "us>.\n" , gCM -> turnaround_time_us ) ) ; FormatRTU ( ( CM_MAD * ) GsiDgrmGetSendMad ( pCEP -> pDgrmElement ) , pSendConnInfo ?pSendConnInfo -> Info . Rtu . PrivateData : NULL , pSendConnInfo ?CMM_RTU_USER_LEN : 0 , pCEP -> TransactionID , pCEP -> LocalCommID , pCEP -> RemoteCommID ) ; _DBG_INFO ( ( "<cep 0x%p>RTU's dgrm address field<portguid 0x%" PRIx64 ", dlid 0x%x, slm %d, pathbits %d, rate %d>\n" , _DBG_PTR ( pCEP ) , pCEP -> pDgrmElement -> PortGuid , pCEP -> pDgrmElement -> RemoteLID , pCEP -> pDgrmElement -> ServiceLevel , pCEP -> pDgrmElement -> PathBits , pCEP -> pDgrmElement -> StaticRate ) ) ; Status = CmDgrmSend ( pCEP -> pDgrmElement ) ; if ( Status != FSUCCESS ) { _DBG_WARN ( ( "<cep 0x%p>DgrmSend() failed for RTU!!!<%s>\n" , _DBG_PTR ( pCEP ) , _DBG_PTR ( FSTATUS_MSG ( Status ) ) ) ) ; Status = FSUCCESS ; } else { AtomicIncrementVoid ( & gCM -> Sent . Rtu ) ; } Status = FCM_CONNECT_ESTABLISHED ; if ( pSendConnInfo ) { pSendConnInfo -> Status = Status ; } CepSetState ( pCEP , CMS_ESTABLISHED ) ; _DBG_INFO ( ( "<cep 0x%p>*** Connection established ***<lcid 0x%x rcid 0x%x slid 0x%x dlid 0x%x>.\n" , _DBG_PTR ( pCEP ) , pCEP -> LocalCommID , pCEP -> RemoteCommID , pCEP -> PrimaryPath . LocalLID , pCEP -> PrimaryPath . RemoteLID ) ) ; break ; default : Status = FINVALID_STATE ; break ; } SpinLockRelease ( & gCM -> ListLock ) ; _DBG_LEAVE_LVL ( _DBG_LVL_FUNC_TRACE ) ; return Status ; } 