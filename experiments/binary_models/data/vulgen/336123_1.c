itm_tbl_hdr_t * map_table ( itm_data_t * name , itmc_map_t * map_list , itmc_map_attr_t * attr ) { itm_size_t num ; itm_size_t num2 ; itmc_map_t * ml ; itmc_data_pair_t * * tpp ; itm_tbl_hdr_t * table ; long source_len = 0 ; long result_len = 0 ; long source_fixed_len = 1 ; long pass_through = 0 ; long default_count = 0 ; itm_data_t * default_data = NULL ; long error_deferred_local = 0 ; unsigned long dense_encoded_map_ent ; unsigned long simple_indexed_map_ent ; itm_size_t source_start ; itm_size_t source_end ; unsigned long u ; unsigned char * byte_seq_min ; unsigned char * byte_seq_max ; unsigned char * p ; long i ; itmc_map_type_t map_type = ITMC_MAP_UNKNOWN ; itmc_map_name_type_t * map_name_type ; long hash_factor ; long result_len_specfied = 0 ; size_t j ; long n ; itmc_data_pair_t * * dp1 ; itm_num_t error_count = 0 ; if ( attr != NULL ) { map_type = check_map_type ( attr ) ; } if ( ITMC_MAP_UNKNOWN == map_type ) { map_type = ITMC_MAP_AUTOMATIC ; } hash_factor = ( ( NULL != attr ) && ( attr -> hash_factor != 0 ) ) ?attr -> hash_factor : 200 ; map_name_type = cmd_opt . map_name_type ; for ( ; map_name_type = map_name_type -> next ) { if ( '\0' == * ( map_name_type -> name ) ) { map_type = map_name_type -> type ; hash_factor = map_name_type -> hash_factor ; break ; } } map_name_type = cmd_opt . map_name_type ; if ( ( NULL != name ) && ( NULL != cmd_opt . map_name_type ) ) { p = NSPTR ( name ) ; for ( ; map_name_type ; map_name_type = map_name_type -> next ) { if ( 0 == strcmp ( map_name_type -> name , ( char * ) p ) ) { map_type = map_name_type -> type ; hash_factor = map_name_type -> hash_factor ; break ; } } } if ( NULL != attr ) { if ( MAXSEQUENCE < attr -> resultlen ) { itm_error ( gettext ( "output_byte_length must be less than %1$d\n" ) , MAXSEQUENCE ) ; error_deferred += 1 ; return ( NULL ) ; } result_len_specfied = attr -> resultlen ; } else { result_len_specfied = 0 ; } for ( num = 0 , ml = map_list ; ml ; ml = ml -> next , num ++ ) { if ( 0 == ml -> data_pair . data0 . size ) { if ( 0 == ml -> data_pair . data1 . size ) { pass_through += 1 ; default_data = ( itm_data_t * ) ( - 1 ) ; } else { default_count += 1 ; default_data = & ( ml -> data_pair . data1 ) ; } -- num ; } if ( 0 == ml -> data_pair . data1 . size ) { continue ; } if ( ( 0 < source_len ) && ( 0 < ml -> data_pair . data0 . size ) && ( source_len != ml -> data_pair . data0 . size ) ) { source_fixed_len = 0 ; } if ( source_len < ml -> data_pair . data0 . size ) { source_len = ml -> data_pair . data0 . size ; } if ( result_len < ml -> data_pair . data1 . size ) { result_len = ml -> data_pair . data1 . size ; } if ( 0 < ml -> data_pair . range . size ) { if ( ml -> data_pair . range . size != ml -> data_pair . data0 . size ) { itm_error ( gettext ( "length of source range must be " "the same: 0x%1$s 0x%2$s\n" ) , data_to_hexadecimal ( & ( ml -> data_pair . data0 ) ) , data_to_hexadecimal ( & ( ml -> data_pair . range ) ) ) ; error_deferred += 1 ; return ( NULL ) ; } if ( 0 <= data_compare ( & ( ml -> data_pair . data0 ) , & ( ( ml -> data_pair . range ) ) ) ) { itm_error ( gettext ( "source range error: 0x%1$s 0x%2$s\n" ) , data_to_hexadecimal ( & ( ml -> data_pair . data0 ) ) , data_to_hexadecimal ( & ( ml -> data_pair . range ) ) ) ; error_deferred += 1 ; return ( NULL ) ; } j = map_table_resultlen ( ml ) ; if ( result_len < j ) { result_len = j ; } } } if ( num == 0 ) { itm_error ( gettext ( "no mapping pair\n" ) ) ; error_deferred += 1 ; return ( NULL ) ; } if ( 0 != result_len_specfied ) { if ( result_len > result_len_specfied ) { itm_error ( gettext ( "result value length is " "over specifed output_byte_length(%1$ld)\n" ) , result_len_specfied ) ; error_deferred += 1 ; return ( NULL ) ; } result_len = result_len_specfied ; } byte_seq_min = malloc_vital ( ( ( unsigned char ) ) * source_len ) ; byte_seq_max = malloc_vital ( ( ( unsigned char ) ) * source_len ) ; for ( num = 0 , ml = map_list ; ml ; ml = ml -> next , num ++ ) { if ( 0 == ml -> data_pair . data0 . size ) { continue ; } p = ( unsigned char * ) ( NSPTR ( & ( ( ml -> data_pair ) . data0 ) ) ) ; for ( i = 0 ; i < source_len ; i ++ ) { * ( byte_seq_min + i ) = * ( p + i ) ; * ( byte_seq_max + i ) = * ( p + i ) ; } break ; } for ( num = 0 , ml = map_list ; ml ; ml = ml -> next , num ++ ) { if ( 0 == ml -> data_pair . data0 . size ) { num -- ; continue ; } if ( ml -> data_pair . range . size > 0 ) { map_range_adjust_byte_seq ( byte_seq_min , byte_seq_max , source_len , & ( ml -> data_pair ) ) ; } else { p = ( unsigned char * ) ( NSPTR ( & ( ( ml -> data_pair ) . data0 ) ) ) ; for ( i = 0 ; i < source_len ; i ++ ) { if ( * ( p + i ) < * ( byte_seq_min + i ) ) { * ( byte_seq_min + i ) = * ( p + i ) ; } if ( * ( byte_seq_max + i ) < * ( p + i ) ) { * ( byte_seq_max + i ) = * ( p + i ) ; } } } } for ( dense_encoded_map_ent = 1 , i = 0 ; i < source_len ; i ++ ) { u = dense_encoded_map_ent ; dense_encoded_map_ent *= ( * ( byte_seq_max + i ) - * ( byte_seq_min + i ) + 1 ) ; if ( dense_encoded_map_ent < u ) { dense_encoded_map_ent = ( ulong_t ) ( ~ 0 ) ; break ; } } if ( TRACE ( 'm' ) ) { int i ; TRACE_MESSAGE ( 'm' , ( "map_table: ent=%lu num=%lu	" , dense_encoded_map_ent , num ) ) ; TRACE_MESSAGE ( 'm' , ( "byte_seq_min=0x" ) ) ; for ( i = 0 ; i < source_len ; i ++ ) { TRACE_MESSAGE ( 'm' , ( "%02x" , * ( byte_seq_min + i ) ) ) ; } TRACE_MESSAGE ( 'm' , ( "  byte_seq_max=0x" ) ) ; for ( i = 0 ; i < source_len ; i ++ ) { TRACE_MESSAGE ( 'm' , ( "%02x" , * ( byte_seq_max + i ) ) ) ; } TRACE_MESSAGE ( 'm' , ( "\n" ) ) ; } tpp = malloc_vital ( ( sizeof ( itmc_data_pair_t * ) ) * num ) ; for ( num = 0 , num2 = 0 , ml = map_list ; ml ; ml = ml -> next ) { if ( 0 < ml -> data_pair . data0 . size ) { itm_num_t range_num ; * ( tpp + num ) = & ( ml -> data_pair ) ; num ++ ; range_num = 1 ; if ( ml -> data_pair . range . size > 0 ) { range_num += map_table_num_range ( & ( ml -> data_pair ) ) ; } num2 += range_num ; if ( 0 == ml -> data_pair . data1 . size ) { error_count += range_num ; } } } ( void ) qsort ( tpp , num , sizeof ( itmc_data_pair_t * ) , ( int ( * ) ( const void * , const void * ) ) data_pair_compare ) ; for ( n = 0 , dp1 = tpp ; n < ( num - 1 ) ; n ++ , dp1 ++ ) { if ( ( ( * ( dp1 + 0 ) ) -> range . size != 0 ) && ( 0 <= data_compare ( & ( ( * ( dp1 + 0 ) ) -> range ) , & ( ( * ( dp1 + 1 ) ) -> data0 ) ) ) ) { itm_error ( gettext ( "ranges of source sequences " "overrapped: %1$s %2$s\n" ) , data_to_hexadecimal ( & ( ( * ( dp1 + 0 ) ) -> range ) ) , data_to_hexadecimal ( & ( ( * ( dp1 + 1 ) ) -> data0 ) ) ) ; error_deferred += 1 ; return ( NULL ) ; } } if ( 1 < default_count ) { itm_error ( gettext ( "default is specified %1$d times in a map\n" ) , default_count ) ; error_deferred_local += 1 ; } if ( ( 1 == default_count ) && ( ! source_fixed_len ) ) { itm_error ( gettext ( "default is specified," " but length of source data is not fixed\n" ) ) ; error_deferred_local += 1 ; } if ( ( 1 <= pass_through ) && ( source_len != result_len ) ) { itm_error ( gettext ( "\"default no_change_copy\" is " "specified, but size does not match\n" ) ) ; error_deferred_local += 1 ; } if ( error_deferred_local ) { error_deferred += error_deferred_local ; return ( NULL ) ; } if ( source_fixed_len ) { source_start = data_to_long ( & ( ( * ( tpp + 0 ) ) -> data0 ) ) ; source_end = data_to_long ( & ( ( * ( tpp + num - 1 ) ) -> data0 ) ) ; if ( 0 < ( * ( tpp + num - 1 ) ) -> range . size ) { source_end = data_to_long ( & ( ( * ( tpp + num - 1 ) ) -> range ) ) ; } simple_indexed_map_ent = source_end - source_start + 1 ; TRACE_MESSAGE ( 'm' , ( "map_table: simple_indexed_map_ent=%lu\n" , simple_indexed_map_ent ) ) ; switch ( map_type ) { case ITMC_MAP_AUTOMATIC : if ( ( source_len <= 2 ) && ( ( ( ulong_t ) ( ~ 0 ) == dense_encoded_map_ent ) || ( simple_indexed_map_ent < ( dense_encoded_map_ent * 2 ) ) ) ) { map_type = ITMC_MAP_SIMPLE_INDEX ; } if ( cmd_opt . large_table ) { if ( ( sizeof ( long ) ) < source_len ) { itm_error ( gettext ( "length of source is too long " "for large table: %ld\n" ) , source_len ) ; error_deferred += 1 ; return ( NULL ) ; } map_type = ITMC_MAP_SIMPLE_INDEX ; } if ( ( ( ulong_t ) ( ~ 0 ) == dense_encoded_map_ent ) || ( ( 0xffff < dense_encoded_map_ent ) && ( ( num2 * 8 ) < dense_encoded_map_ent ) ) ) { map_type = ITMC_MAP_SIMPLE_HASH ; } else { map_type = ITMC_MAP_DENSE_ENCODING ; } break ; case ITMC_MAP_SIMPLE_INDEX : if ( ( sizeof ( long ) ) < source_len ) { itm_error ( gettext ( "length of source is too long " "for index lookup: %ld\n" ) , source_len ) ; error_deferred += 1 ; return ( NULL ) ; } break ; case ITMC_MAP_SIMPLE_HASH : for ( i = 2 , u = 256 ; i < ( sizeof ( long ) ) ; i ++ ) { u *= 256 ; } if ( u < num2 ) { itm_error ( gettext ( "map is too large for hashing: %lu\n" ) , num2 ) ; error_deferred += 1 ; return ( NULL ) ; } break ; case ITMC_MAP_DENSE_ENCODING : for ( i = 2 , u = 256 ; i < ( sizeof ( long ) ) ; i ++ ) { u *= 256 ; } if ( u < dense_encoded_map_ent ) { itm_error ( gettext ( "map is too large for dense encoding: " "%lu\n" ) , dense_encoded_map_ent ) ; error_deferred += 1 ; return ( NULL ) ; } break ; case ITMC_MAP_BINARY_SEARCH : for ( i = 2 , u = 256 ; i < ( sizeof ( long ) ) ; i ++ ) { u *= 256 ; } if ( u < num2 ) { itm_error ( gettext ( "length of source is too long for " "binary search: %ld\n" ) , source_len ) ; error_deferred += 1 ; return ( NULL ) ; } break ; default : break ; } switch ( map_type ) { case ITMC_MAP_SIMPLE_INDEX : table = map_table_indexed_fixed ( tpp , num , default_data , result_len , error_count ) ; break ; case ITMC_MAP_SIMPLE_HASH : table = map_table_hash ( tpp , num , default_data , hash_factor , result_len , num2 , error_count ) ; break ; case ITMC_MAP_DENSE_ENCODING : table = map_table_dense_encoding ( tpp , num , default_data , dense_encoded_map_ent , byte_seq_min , byte_seq_max , result_len , error_count ) ; break ; case ITMC_MAP_BINARY_SEARCH : table = map_table_lookup_fixed ( tpp , num , default_data , result_len , num2 ) ; break ; } } else { table = map_table_lookup_var ( ) ; } if ( ( NULL != name ) && ( NULL != table ) ) { table -> name . itm_ptr = ( itm_place2_t ) name ; } return ( table ) ; } 