static void cypress_atacb_passthrough ( struct scsi_cmnd * srb , struct us_data * us ) { unsigned char save_cmnd [ MAX_COMMAND_SIZE ] ; if ( likely ( srb -> cmnd [ 0 ] != ATA_16 && srb -> cmnd [ 0 ] != ATA_12 ) ) { usb_stor_transparent_scsi_command ( srb , us ) ; return ; } memcpy ( save_cmnd , srb -> cmnd , sizeof ( save_cmnd ) ) ; if ( save_cmnd [ 1 ] >> 5 ) { invalid_fld } switch ( ( save_cmnd [ 1 ] >> 1 ) & 0xf ) { case 3 : case 4 : case 5 : break ; default : invalid_fld } srb -> cmd_len = 16 ; srb -> cmnd [ 0 ] = 0x24 ; srb -> cmnd [ 1 ] = 0x24 ; srb -> cmnd [ 3 ] = 0xff - 1 ; srb -> cmnd [ 4 ] = 1 ; if ( save_cmnd [ 0 ] == ATA_16 ) { srb -> cmnd [ 6 ] = save_cmnd [ 4 ] ; srb -> cmnd [ 7 ] = save_cmnd [ 6 ] ; srb -> cmnd [ 8 ] = save_cmnd [ 8 ] ; srb -> cmnd [ 9 ] = save_cmnd [ 10 ] ; srb -> cmnd [ 10 ] = save_cmnd [ 12 ] ; srb -> cmnd [ 11 ] = save_cmnd [ 13 ] ; srb -> cmnd [ 12 ] = save_cmnd [ 14 ] ; if ( save_cmnd [ 1 ] & 0x01 ) { if ( save_cmnd [ 3 ] || save_cmnd [ 5 ] || save_cmnd [ 7 ] || save_cmnd [ 9 ] || save_cmnd [ 11 ] ) { invalid_fld } } } else { srb -> cmnd [ 6 ] = save_cmnd [ 3 ] ; srb -> cmnd [ 7 ] = save_cmnd [ 4 ] ; srb -> cmnd [ 8 ] = save_cmnd [ 5 ] ; srb -> cmnd [ 9 ] = save_cmnd [ 6 ] ; srb -> cmnd [ 10 ] = save_cmnd [ 7 ] ; srb -> cmnd [ 11 ] = save_cmnd [ 8 ] ; srb -> cmnd [ 12 ] = save_cmnd [ 9 ] ; } if ( ( srb -> cmnd [ 12 ] == ATA_CMD_SET_FEATURES ) && ( srb -> cmnd [ 6 ] == SETFEATURES_XFER ) ) { invalid_fld } if ( srb -> cmnd [ 12 ] == ATA_CMD_ID_ATA || srb -> cmnd [ 12 ] == ATA_CMD_ID_ATAPI ) { srb -> cmnd [ 2 ] |= ( 1 << 7 ) ; } usb_stor_transparent_scsi_command ( srb , us ) ; if ( srb -> result == SAM_STAT_CHECK_CONDITION && memcmp ( srb -> sense_buffer , usb_stor_sense_invalidCDB , sizeof ( usb_stor_sense_invalidCDB ) ) == 0 ) { usb_stor_dbg ( us , "cypress atacb not supported ???\n" ) ; end } if ( ( srb -> result != ( DID_ERROR << 16 ) && srb -> result != ( DID_ABORT << 16 ) ) && save_cmnd [ 2 ] & 0x20 ) { struct scsi_eh_save ses ; unsigned char regs [ 8 ] ; unsigned char * sb = srb -> sense_buffer ; unsigned char * desc = sb + 8 ; int tmp_result ; scsi_eh_prep_cmnd ( srb , & ses , NULL , 0 , sizeof ( regs ) ) ; srb -> cmd_len = 16 ; srb -> cmnd [ 2 ] = 1 ; usb_stor_transparent_scsi_command ( srb , us ) ; memcpy ( regs , srb -> sense_buffer , sizeof ( regs ) ) ; tmp_result = srb -> result ; scsi_eh_restore_cmnd ( srb , & ses ) ; if ( tmp_result != SAM_STAT_GOOD ) { invalid_fld } memset ( sb , 0 , SCSI_SENSE_BUFFERSIZE ) ; sb [ 1 ] = RECOVERED_ERROR ; sb [ 2 ] = 0 ; sb [ 3 ] = 0x1D ; sb [ 0 ] = 0x72 ; desc [ 0 ] = 0x09 ; sb [ 7 ] = 14 ; desc [ 1 ] = 12 ; desc [ 2 ] = 0x00 ; desc [ 3 ] = regs [ 1 ] ; desc [ 5 ] = regs [ 2 ] ; desc [ 7 ] = regs [ 3 ] ; desc [ 9 ] = regs [ 4 ] ; desc [ 11 ] = regs [ 5 ] ; desc [ 12 ] = regs [ 6 ] ; desc [ 13 ] = regs [ 7 ] ; srb -> result = SAM_STAT_CHECK_CONDITION ; } end invalid_fld srb -> result = SAM_STAT_CHECK_CONDITION ; memcpy ( srb -> sense_buffer , usb_stor_sense_invalidCDB , sizeof ( usb_stor_sense_invalidCDB ) ) ; end memcpy ( srb -> cmnd , save_cmnd , sizeof ( save_cmnd ) ) ; if ( srb -> cmnd [ 0 ] == ATA_12 ) { srb -> cmd_len = 12 ; } } 