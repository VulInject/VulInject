unpack_d ( , ) { fractype fraction ; int exp ; int sign ; FLO_union_type swapped ; swapped . words [ 0 ] = src -> words [ 3 ] ; swapped . words [ 1 ] = src -> words [ 2 ] ; swapped . words [ 2 ] = src -> words [ 1 ] ; swapped . words [ 3 ] = src -> words [ 0 ] ; swapped . words [ 0 ] = src -> words [ 1 ] ; swapped . words [ 1 ] = src -> words [ 0 ] ; src = & swapped ; fraction = src -> bits . fraction ; exp = src -> bits . exp ; sign = src -> bits . sign ; { halffractype high , low ; high = src -> value_raw >> HALFSHIFT ; low = src -> value_raw & ( ( ( fractype ) 1 << HALFSHIFT ) - 1 ) ; fraction = high & ( ( ( ( fractype ) 1 ) << HALFFRACBITS ) - 1 ) ; exp = ( ( int ) ( high >> HALFFRACBITS ) ) & ( ( 1 << EXPBITS ) - 1 ) ; sign = ( ( int ) ( high >> ( ( ( HALFFRACBITS + EXPBITS ) ) ) ) ) & 1 ; if ( exp != EXPMAX && exp != 0 && low != 0 ) { int lowexp = ( ( int ) ( low >> HALFFRACBITS ) ) & ( ( 1 << EXPBITS ) - 1 ) ; int lowsign = ( ( int ) ( low >> ( ( ( HALFFRACBITS + EXPBITS ) ) ) ) ) & 1 ; int shift ; fractype xlow ; xlow = low & ( ( ( ( fractype ) 1 ) << HALFFRACBITS ) - 1 ) ; if ( lowexp ) { xlow |= ( ( ( halffractype ) 1 ) << HALFFRACBITS ) ; } else { lowexp = 1 ; } shift = ( FRACBITS - HALFFRACBITS ) - ( exp - lowexp ) ; if ( shift > 0 ) { xlow <<= shift ; } if ( shift < 0 ) { xlow >>= - shift ; } if ( sign == lowsign ) { fraction += xlow ; } else { fraction -= xlow ; } } } fraction = src -> value_raw & ( ( ( ( fractype ) 1 ) << FRACBITS ) - 1 ) ; exp = ( ( int ) ( src -> value_raw >> FRACBITS ) ) & ( ( 1 << EXPBITS ) - 1 ) ; sign = ( ( int ) ( src -> value_raw >> ( FRACBITS + EXPBITS ) ) ) & 1 ; dst -> sign = sign ; if ( exp == 0 ) { if ( fraction == 0 || 1 ) { dst -> class = CLASS_ZERO ; } else { dst -> normal_exp = exp - EXPBIAS + 1 ; fraction <<= NGARDS ; dst -> class = CLASS_NUMBER ; while ( fraction < IMPLICIT_1 ) { fraction <<= 1 ; dst -> normal_exp -- ; } dst -> fraction . ll = fraction ; } } if ( ! LARGEST_EXPONENT_IS_NORMAL ( FRAC_NBITS ) && exp == EXPMAX ) { if ( fraction == 0 ) { dst -> class = CLASS_INFINITY ; } else { if ( fraction & QUIET_NAN ) { dst -> class = CLASS_QNAN ; } else { dst -> class = CLASS_SNAN ; } dst -> fraction . ll = fraction ; } } else { dst -> normal_exp = exp - EXPBIAS ; dst -> class = CLASS_NUMBER ; dst -> fraction . ll = ( fraction << NGARDS ) | IMPLICIT_1 ; } } 