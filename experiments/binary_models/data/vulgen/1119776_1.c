int evsel__parse_sample ( struct evsel * evsel , union perf_event * event , struct perf_sample * data ) { u64 type = evsel -> core . attr . sample_type ; bool swapped = evsel -> needs_swap ; const __u64 * array ; u16 max_size = event -> header . size ; const void * endp = ( void * ) event + max_size ; u64 sz ; union u64_swap u ; data -> cpu = data -> pid = data -> tid = - 1 ; data -> stream_id = data -> id = data -> time = - 1ULL ; data -> period = evsel -> core . attr . sample_period ; data -> cpumode = event -> header . misc & PERF_RECORD_MISC_CPUMODE_MASK ; data -> misc = event -> header . misc ; data -> id = - 1ULL ; data -> data_src = PERF_MEM_DATA_SRC_NONE ; data -> vcpu = - 1 ; if ( event -> header . type != PERF_RECORD_SAMPLE ) { if ( ! evsel -> core . attr . sample_id_all ) { return 0 ; } return perf_evsel__parse_id_sample ( evsel , event , data ) ; } array = event -> sample . array ; if ( perf_event__check_size ( event , evsel -> sample_size ) ) { return - EFAULT ; } if ( type & PERF_SAMPLE_IDENTIFIER ) { data -> id = * array ; array ++ ; } if ( type & PERF_SAMPLE_IP ) { data -> ip = * array ; array ++ ; } if ( type & PERF_SAMPLE_TID ) { u . val64 = * array ; if ( swapped ) { u . val64 = bswap_64 ( u . val64 ) ; u . val32 [ 0 ] = bswap_32 ( u . val32 [ 0 ] ) ; u . val32 [ 1 ] = bswap_32 ( u . val32 [ 1 ] ) ; } data -> pid = u . val32 [ 0 ] ; data -> tid = u . val32 [ 1 ] ; array ++ ; } if ( type & PERF_SAMPLE_TIME ) { data -> time = * array ; array ++ ; } if ( type & PERF_SAMPLE_ADDR ) { data -> addr = * array ; array ++ ; } if ( type & PERF_SAMPLE_ID ) { data -> id = * array ; array ++ ; } if ( type & PERF_SAMPLE_STREAM_ID ) { data -> stream_id = * array ; array ++ ; } if ( type & PERF_SAMPLE_CPU ) { u . val64 = * array ; if ( swapped ) { u . val64 = bswap_64 ( u . val64 ) ; u . val32 [ 0 ] = bswap_32 ( u . val32 [ 0 ] ) ; } data -> cpu = u . val32 [ 0 ] ; array ++ ; } if ( type & PERF_SAMPLE_PERIOD ) { data -> period = * array ; array ++ ; } if ( type & PERF_SAMPLE_READ ) { u64 read_format = evsel -> core . attr . read_format ; OVERFLOW_CHECK_u64 ( array ) ; if ( read_format & PERF_FORMAT_GROUP ) { data -> read . group . nr = * array ; } else { data -> read . one . value = * array ; } array ++ ; if ( read_format & PERF_FORMAT_TOTAL_TIME_ENABLED ) { OVERFLOW_CHECK_u64 ( array ) ; data -> read . time_enabled = * array ; array ++ ; } if ( read_format & PERF_FORMAT_TOTAL_TIME_RUNNING ) { OVERFLOW_CHECK_u64 ( array ) ; data -> read . time_running = * array ; array ++ ; } if ( read_format & PERF_FORMAT_GROUP ) { const u64 max_group_nr = UINT64_MAX / sizeof ( sample_read_value ) ; if ( data -> read . group . nr > max_group_nr ) { return - EFAULT ; } sz = data -> read . group . nr * sample_read_value_size ( read_format ) ; OVERFLOW_CHECK ( array , sz , max_size ) ; data -> read . group . values = ( sample_read_value * ) array ; array = ( void * ) array + sz ; } else { OVERFLOW_CHECK_u64 ( array ) ; data -> read . one . id = * array ; array ++ ; if ( read_format & PERF_FORMAT_LOST ) { OVERFLOW_CHECK_u64 ( array ) ; data -> read . one . lost = * array ; array ++ ; } } } if ( type & PERF_SAMPLE_CALLCHAIN ) { const u64 max_callchain_nr = UINT64_MAX / sizeof ( u64 ) ; OVERFLOW_CHECK_u64 ( array ) ; data -> callchain = ( ip_callchain * ) array ++ ; if ( data -> callchain -> nr > max_callchain_nr ) { return - EFAULT ; } sz = data -> callchain -> nr * sizeof ( u64 ) ; OVERFLOW_CHECK ( array , sz , max_size ) ; array = ( void * ) array + sz ; } if ( type & PERF_SAMPLE_RAW ) { OVERFLOW_CHECK_u64 ( array ) ; u . val64 = * array ; if ( swapped ) { u . val64 = bswap_64 ( u . val64 ) ; u . val32 [ 0 ] = bswap_32 ( u . val32 [ 0 ] ) ; u . val32 [ 1 ] = bswap_32 ( u . val32 [ 1 ] ) ; } data -> raw_size = u . val32 [ 0 ] ; if ( swapped ) { mem_bswap_64 ( ( void * ) array , data -> raw_size ) ; } array = ( void * ) array + sizeof ( u32 ) ; OVERFLOW_CHECK ( array , data -> raw_size , max_size ) ; data -> raw_data = ( void * ) array ; array = ( void * ) array + data -> raw_size ; } if ( type & PERF_SAMPLE_BRANCH_STACK ) { const u64 max_branch_nr = UINT64_MAX / sizeof ( branch_entry ) ; struct branch_entry * e ; unsigned int i ; OVERFLOW_CHECK_u64 ( array ) ; data -> branch_stack = ( branch_stack * ) array ++ ; if ( data -> branch_stack -> nr > max_branch_nr ) { return - EFAULT ; } sz = data -> branch_stack -> nr * sizeof ( branch_entry ) ; if ( evsel__has_branch_hw_idx ( evsel ) ) { sz += sizeof ( u64 ) ; e = & data -> branch_stack -> entries [ 0 ] ; } else { data -> no_hw_idx = true ; e = ( branch_entry * ) & data -> branch_stack -> hw_idx ; } if ( swapped ) { for ( i = 0 ; i < data -> branch_stack -> nr ; i ++ , e ++ ) { e -> flags . value = evsel__bitfield_swap_branch_flags ( e -> flags . value ) ; } } OVERFLOW_CHECK ( array , sz , max_size ) ; array = ( void * ) array + sz ; } if ( type & PERF_SAMPLE_REGS_USER ) { OVERFLOW_CHECK_u64 ( array ) ; data -> user_regs . abi = * array ; array ++ ; if ( data -> user_regs . abi ) { u64 mask = evsel -> core . attr . sample_regs_user ; sz = hweight64 ( mask ) * sizeof ( u64 ) ; OVERFLOW_CHECK ( array , sz , max_size ) ; data -> user_regs . mask = mask ; data -> user_regs . regs = ( u64 * ) array ; array = ( void * ) array + sz ; } } if ( type & PERF_SAMPLE_STACK_USER ) { OVERFLOW_CHECK_u64 ( array ) ; sz = * array ++ ; data -> user_stack . offset = ( ( char * ) ( array - 1 ) - ( char * ) event ) ; if ( ! sz ) { data -> user_stack . size = 0 ; } else { OVERFLOW_CHECK ( array , sz , max_size ) ; data -> user_stack . data = ( char * ) array ; array = ( void * ) array + sz ; OVERFLOW_CHECK_u64 ( array ) ; data -> user_stack . size = * array ++ ; if ( WARN_ONCE ( data -> user_stack . size > sz , "user stack dump failure\n" ) ) { return - EFAULT ; } } } if ( type & PERF_SAMPLE_WEIGHT_TYPE ) { OVERFLOW_CHECK_u64 ( array ) ; arch_perf_parse_sample_weight ( data , array , type ) ; array ++ ; } if ( type & PERF_SAMPLE_DATA_SRC ) { OVERFLOW_CHECK_u64 ( array ) ; data -> data_src = * array ; array ++ ; } if ( type & PERF_SAMPLE_TRANSACTION ) { OVERFLOW_CHECK_u64 ( array ) ; data -> transaction = * array ; array ++ ; } data -> intr_regs . abi = PERF_SAMPLE_REGS_ABI_NONE ; if ( type & PERF_SAMPLE_REGS_INTR ) { OVERFLOW_CHECK_u64 ( array ) ; data -> intr_regs . abi = * array ; array ++ ; if ( data -> intr_regs . abi != PERF_SAMPLE_REGS_ABI_NONE ) { u64 mask = evsel -> core . attr . sample_regs_intr ; sz = hweight64 ( mask ) * sizeof ( u64 ) ; OVERFLOW_CHECK ( array , sz , max_size ) ; data -> intr_regs . mask = mask ; data -> intr_regs . regs = ( u64 * ) array ; array = ( void * ) array + sz ; } } data -> phys_addr = 0 ; if ( type & PERF_SAMPLE_PHYS_ADDR ) { data -> phys_addr = * array ; array ++ ; } data -> cgroup = 0 ; if ( type & PERF_SAMPLE_CGROUP ) { data -> cgroup = * array ; array ++ ; } data -> data_page_size = 0 ; if ( type & PERF_SAMPLE_DATA_PAGE_SIZE ) { data -> data_page_size = * array ; array ++ ; } data -> code_page_size = 0 ; if ( type & PERF_SAMPLE_CODE_PAGE_SIZE ) { data -> code_page_size = * array ; array ++ ; } if ( type & PERF_SAMPLE_AUX ) { OVERFLOW_CHECK_u64 ( array ) ; sz = * array ++ ; OVERFLOW_CHECK ( array , sz , max_size ) ; if ( swapped ) { mem_bswap_64 ( ( char * ) array , sz ) ; } data -> aux_sample . size = sz ; data -> aux_sample . data = ( char * ) array ; array = ( void * ) array + sz ; } return 0 ; } 