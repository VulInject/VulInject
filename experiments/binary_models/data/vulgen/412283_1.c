static int restore_message_list_cb ( const mbentry_t * mbentry , void * rock ) { struct restore_rock * rrock = ( restore_rock * ) rock ; const char * sched_mboxname = ( const char * ) rrock -> context ; int log_level = rrock -> jrestore -> log_level ; struct mail_rock * mrock = rrock -> rock ; struct mailbox * mailbox = NULL ; const message_t * msg ; time_t timestamp = 0 ; int userflag = - 1 , isdestroyed_mbox = 0 ; int r ; syslog ( log_level , "restore_message_list_cb: processing '%s'  (type = 0x%03x)" , mbentry -> name , mbentry -> mbtype ) ; if ( mbtype_isa ( mbentry -> mbtype ) != MBTYPE_EMAIL ) { syslog ( log_level , "skipping '%s': not type EMAIL" , mbentry -> name ) ; return 0 ; } if ( mboxname_isnotesmailbox ( mbentry -> name , MBTYPE_EMAIL ) ) { syslog ( log_level , "skipping '%s': Notes mailbox" , mbentry -> name ) ; return 0 ; } if ( ! strcmpnull ( mbentry -> name , sched_mboxname ) ) { syslog ( log_level , "skipping '%s': \\Scheduled mailbox" , mbentry -> name ) ; return 0 ; } if ( mboxname_isdeletedmailbox ( mbentry -> name , & timestamp ) ) { if ( timestamp <= rrock -> jrestore -> cutoff ) { syslog ( log_level , "skipping '%s': destroyed (%ld) before cutoff" , mbentry -> name , timestamp ) ; return 0 ; } isdestroyed_mbox = 1 ; } r = jmap_openmbox ( rrock -> req , mbentry -> name , & mailbox , 0 ) ; if ( r ) { syslog ( LOG_ERR , "IOERROR: failed to open mailbox %s" , mbentry -> name ) ; return r ; } mailbox_user_flag ( mailbox , "$restored" , & userflag , 0 ) ; struct mailbox_iter * iter = mailbox_iter_init ( mailbox , 0 , 0 ) ; while ( ( msg = mailbox_iter_step ( iter ) ) ) { const struct index_record * record = msg_record ( msg ) ; const char * guid = message_guid_encode ( & record -> guid ) ; const char * msgid = NULL ; int isdestroyed_msg = isdestroyed_mbox ; int ignore_draft = 0 ; syslog ( log_level , "UID %u: expunged: %x, draft: %x, intdate: %ld, updated: %ld" , record -> uid , ( record -> internal_flags & FLAG_INTERNAL_EXPUNGED ) , ( record -> system_flags & FLAG_DRAFT ) , record -> internaldate , record -> last_updated ) ; if ( rrock -> jrestore -> mode & UNDO_DRAFTS ) { struct conversations_state * cstate = mailbox_get_cstate_full ( mailbox , 1 ) ; if ( ( ! cstate || conversations_guid_cid_lookup ( cstate , guid ) ) && ! message_get_messageid ( ( message_t * ) msg , & mrock -> buf ) ) { msgid = buf_cstring ( & mrock -> buf ) ; } syslog ( log_level , "UID: %u, msgid = '%s'" , record -> uid , msgid ?msgid : "" ) ; } if ( ! ( rrock -> jrestore -> mode & DRY_RUN ) && userflag >= 0 && ( record -> user_flags [ userflag / 32 ] & ( 1 << userflag % 31 ) ) ) { struct mailbox_plan * plan = hash_lookup ( mailbox_name ( mailbox ) , mrock -> mailboxes ) ; if ( ! plan ) { plan = xzmalloc ( sizeof ( mailbox_plan ) ) ; hash_insert ( mailbox_name ( mailbox ) , plan , mrock -> mailboxes ) ; } arrayu64_append ( & plan -> unflag , record -> uid ) ; } struct message_t * message = hash_lookup ( guid , mrock -> emailids ) ; if ( message && message -> ignore ) { syslog ( log_level , "skipping UID %u: undeleted copy exists" , record -> uid ) ; continue ; } if ( ( record -> system_flags & FLAG_DELETED ) || ( record -> internal_flags & FLAG_INTERNAL_EXPUNGED ) ) { if ( record -> last_updated <= rrock -> jrestore -> cutoff ) { syslog ( log_level , "skipping UID %u: destroyed before cutoff" , record -> uid ) ; continue ; } isdestroyed_msg = 1 ; } if ( isdestroyed_msg ) { if ( record -> system_flags & FLAG_DRAFT ) { if ( ! msgid ) { syslog ( log_level , "skipping UID %u: no msgid" , record -> uid ) ; continue ; } message = hash_lookup ( msgid , mrock -> msgids ) ; if ( ! message ) { message = xzmalloc ( sizeof ( message_t ) ) ; hash_insert ( msgid , message , mrock -> msgids ) ; } if ( message -> ignore ) { syslog ( log_level , "skipping UID %u: non-draft / undeleted draft exists" , record -> uid ) ; continue ; } } else { ignore_draft = 1 ; if ( ! message && ( rrock -> jrestore -> mode & UNDO_NONDRAFTS ) ) { message = xzmalloc ( sizeof ( message_t ) ) ; hash_insert ( guid , message , mrock -> emailids ) ; } } if ( message ) { struct removed_mail * rmail = xmalloc ( sizeof ( removed_mail ) ) ; rmail -> mboxname = xstrdup ( mbentry -> name ) ; rmail -> guid = ( record -> system_flags & FLAG_DRAFT ) ?xstrdup ( guid ) : NULL ; rmail -> removed = isdestroyed_mbox ?timestamp : record -> last_updated ; rmail -> uid = record -> uid ; rmail -> size = record -> size ; ptrarray_append ( & message -> deleted , rmail ) ; } } else { ignore_draft = 1 ; if ( ! message ) { message = xzmalloc ( sizeof ( message_t ) ) ; hash_insert ( guid , message , mrock -> emailids ) ; } message -> ignore = 1 ; } } mailbox_iter_done ( & iter ) ; jmap_closembox ( rrock -> req , & mailbox ) ; return 0 ; } 