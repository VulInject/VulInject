static void ath10k_tpc_stats_fill ( struct ath10k * ar , struct ath10k_tpc_stats * tpc_stats , char * buf ) { int j ; size_t len , buf_len ; len = 0 ; buf_len = ATH10K_TPC_CONFIG_BUF_SIZE ; spin_lock_bh ( & ar -> data_lock ) ; if ( ! tpc_stats ) { ath10k_warn ( ar , "failed to get tpc stats\n" ) ; unlock } len += scnprintf ( buf + len , buf_len - len , "\n" ) ; len += scnprintf ( buf + len , buf_len - len , "*************************************\n" ) ; len += scnprintf ( buf + len , buf_len - len , "TPC config for channel %4d mode %d\n" , tpc_stats -> chan_freq , tpc_stats -> phy_mode ) ; len += scnprintf ( buf + len , buf_len - len , "*************************************\n" ) ; len += scnprintf ( buf + len , buf_len - len , "CTL		=  0x%2x Reg. Domain		= %2d\n" , tpc_stats -> ctl , tpc_stats -> reg_domain ) ; len += scnprintf ( buf + len , buf_len - len , "Antenna Gain	= %2d Reg. Max Antenna Gain	=  %2d\n" , tpc_stats -> twice_antenna_gain , tpc_stats -> twice_antenna_reduction ) ; len += scnprintf ( buf + len , buf_len - len , "Power Limit	= %2d Reg. Max Power		= %2d\n" , tpc_stats -> power_limit , tpc_stats -> twice_max_rd_power / 2 ) ; len += scnprintf ( buf + len , buf_len - len , "Num tx chains	= %2d Num supported rates	= %2d\n" , tpc_stats -> num_tx_chain , tpc_stats -> rate_max ) ; for ( j = 0 ; j < WMI_TPC_FLAG ; j ++ ) { switch ( j ) { case WMI_TPC_TABLE_TYPE_CDD : if ( tpc_stats -> flag [ j ] == ATH10K_TPC_TABLE_TYPE_FLAG ) { len += scnprintf ( buf + len , buf_len - len , "CDD not supported\n" ) ; break ; } ath10k_tpc_stats_print ( tpc_stats , j , buf , & len ) ; break ; case WMI_TPC_TABLE_TYPE_STBC : if ( tpc_stats -> flag [ j ] == ATH10K_TPC_TABLE_TYPE_FLAG ) { len += scnprintf ( buf + len , buf_len - len , "STBC not supported\n" ) ; break ; } ath10k_tpc_stats_print ( tpc_stats , j , buf , & len ) ; break ; case WMI_TPC_TABLE_TYPE_TXBF : ath10k_tpc_stats_print ( tpc_stats , j , buf , & len ) ; break ; default : len += scnprintf ( buf + len , buf_len - len , "Invalid Type\n" ) ; break ; } } unlock spin_unlock_bh ( & ar -> data_lock ) ; if ( len >= buf_len ) { buf [ len - 1 ] = 0 ; } else { buf [ len ] = 0 ; } } 