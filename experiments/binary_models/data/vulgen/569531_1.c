static int hermon_qp_sqd2sqd ( hermon_state_t * state , hermon_qphdl_t qp , ibt_cep_modify_flags_t flags , ibt_qp_info_t * info_p ) { hermon_hw_qpc_t * qpc ; ibt_qp_rc_attr_t * rc ; ibt_qp_ud_attr_t * ud ; ibt_qp_uc_attr_t * uc ; hermon_hw_addr_path_t * qpc_path ; ibt_adds_vect_t * adds_vect ; uint_t portnum , pkeyindx ; uint_t rra_max , sra_max ; uint32_t opmask = 0 ; int status ; ASSERT ( MUTEX_HELD ( & qp -> qp_lock ) ) ; qpc = & qp -> qpc ; if ( qp -> qp_type == IBT_UD_RQP ) { ud = & info_p -> qp_transport . ud ; if ( flags & IBT_CEP_SET_PORT ) { portnum = ud -> ud_port ; if ( hermon_portnum_is_valid ( state , portnum ) ) { qp -> qp_portnum = portnum - 1 ; qpc -> pri_addr_path . sched_q = HERMON_QP_SCHEDQ_GET ( portnum - 1 , 0 , qp -> qp_is_special ) ; } else { return ( IBT_HCA_PORT_INVALID ) ; } opmask |= HERMON_CMD_OP_SCHEDQUEUE ; } if ( flags & IBT_CEP_SET_PKEY_IX ) { pkeyindx = ud -> ud_pkey_ix ; if ( hermon_pkeyindex_is_valid ( state , pkeyindx ) ) { qpc -> pri_addr_path . pkey_indx = pkeyindx ; opmask |= HERMON_CMD_OP_PKEYINDX ; qp -> qp_pkeyindx = pkeyindx ; } else { return ( IBT_PKEY_IX_ILLEGAL ) ; } } if ( flags & IBT_CEP_SET_QKEY ) { qpc -> qkey = ud -> ud_qkey ; opmask |= HERMON_CMD_OP_QKEY ; } } if ( qp -> qp_serv_type == HERMON_QP_RC ) { rc = & info_p -> qp_transport . rc ; opmask |= hermon_check_rdma_enable_flags ( flags , info_p , qpc ) ; if ( flags & IBT_CEP_SET_ADDS_VECT ) { qpc_path = & qpc -> pri_addr_path ; adds_vect = & rc -> rc_path . cep_adds_vect ; status = hermon_set_addr_path ( state , adds_vect , qpc_path , HERMON_ADDRPATH_QP ) ; if ( status != DDI_SUCCESS ) { return ( status ) ; } qpc -> rnr_retry = rc -> rc_rnr_retry_cnt ; qpc_path -> ack_timeout = rc -> rc_path . cep_timeout ; qpc -> retry_cnt = rc -> rc_retry_cnt ; portnum = qp -> qp_portnum + 1 ; if ( hermon_portnum_is_valid ( state , portnum ) ) { qpc -> pri_addr_path . sched_q = HERMON_QP_SCHEDQ_GET ( qp -> qp_portnum , adds_vect -> av_srvl , qp -> qp_is_special ) ; } else { return ( IBT_HCA_PORT_INVALID ) ; } qpc -> mtu = qp -> qp_save_mtu ; opmask |= ( HERMON_CMD_OP_PRIM_PATH | HERMON_CMD_OP_RETRYCNT | HERMON_CMD_OP_ACKTIMEOUT | HERMON_CMD_OP_PRIM_RNRRETRY ) ; } if ( flags & IBT_CEP_SET_MIG ) { if ( rc -> rc_mig_state == IBT_STATE_MIGRATED ) { qpc -> pm_state = HERMON_QP_PMSTATE_MIGRATED ; } if ( rc -> rc_mig_state == IBT_STATE_REARMED ) { qpc -> pm_state = HERMON_QP_PMSTATE_REARM ; } else { return ( IBT_QP_APM_STATE_INVALID ) ; } opmask |= HERMON_CMD_OP_PM_STATE ; } if ( flags & IBT_CEP_SET_PKEY_IX ) { pkeyindx = rc -> rc_path . cep_pkey_ix ; if ( hermon_pkeyindex_is_valid ( state , pkeyindx ) ) { qpc -> pri_addr_path . pkey_indx = pkeyindx ; opmask |= HERMON_CMD_OP_PKEYINDX ; } else { return ( IBT_PKEY_IX_ILLEGAL ) ; } } if ( flags & IBT_CEP_SET_PORT ) { portnum = rc -> rc_path . cep_hca_port_num ; if ( hermon_portnum_is_valid ( state , portnum ) ) { qp -> qp_portnum = portnum - 1 ; qpc -> pri_addr_path . sched_q = HERMON_QP_SCHEDQ_GET ( portnum - 1 , adds_vect -> av_srvl , qp -> qp_is_special ) ; } else { return ( IBT_HCA_PORT_INVALID ) ; } opmask |= HERMON_CMD_OP_SCHEDQUEUE ; } if ( flags & IBT_CEP_SET_ALT_PATH ) { qpc_path = & qpc -> alt_addr_path ; adds_vect = & rc -> rc_alt_path . cep_adds_vect ; status = hermon_set_addr_path ( state , adds_vect , qpc_path , HERMON_ADDRPATH_QP ) ; if ( status != DDI_SUCCESS ) { return ( status ) ; } qpc_path -> ack_timeout = rc -> rc_alt_path . cep_timeout ; portnum = rc -> rc_alt_path . cep_hca_port_num ; if ( hermon_portnum_is_valid ( state , portnum ) ) { qp -> qp_portnum_alt = portnum - 1 ; qpc -> alt_addr_path . sched_q = HERMON_QP_SCHEDQ_GET ( portnum - 1 , adds_vect -> av_srvl , qp -> qp_is_special ) ; } else { return ( IBT_HCA_PORT_INVALID ) ; } pkeyindx = rc -> rc_alt_path . cep_pkey_ix ; if ( hermon_pkeyindex_is_valid ( state , pkeyindx ) ) { qpc -> alt_addr_path . pkey_indx = pkeyindx ; } else { return ( IBT_PKEY_IX_ILLEGAL ) ; } opmask |= HERMON_CMD_OP_ALT_PATH ; } if ( flags & IBT_CEP_SET_RDMARA_OUT ) { if ( hermon_qp_validate_init_depth ( state , rc , & sra_max ) != DDI_SUCCESS ) { return ( IBT_INVALID_PARAM ) ; } qpc -> sra_max = sra_max ; opmask |= HERMON_CMD_OP_SRA_SET ; } if ( flags & IBT_CEP_SET_RDMARA_IN ) { if ( hermon_qp_validate_resp_rsrc ( state , rc , & rra_max ) != DDI_SUCCESS ) { return ( IBT_INVALID_PARAM ) ; } qpc -> rra_max = rra_max ; opmask |= HERMON_CMD_OP_RRA_SET ; } if ( flags & IBT_CEP_SET_TIMEOUT ) { qpc_path = & qpc -> pri_addr_path ; qpc_path -> ack_timeout = rc -> rc_path . cep_timeout ; opmask |= HERMON_CMD_OP_ACKTIMEOUT ; } if ( flags & IBT_CEP_SET_RETRY ) { qpc -> retry_cnt = rc -> rc_retry_cnt ; opmask |= HERMON_CMD_OP_PRIM_RNRRETRY ; } if ( flags & IBT_CEP_SET_RNR_NAK_RETRY ) { qpc_path = & qpc -> pri_addr_path ; qpc -> rnr_retry = rc -> rc_rnr_retry_cnt ; opmask |= HERMON_CMD_OP_RETRYCNT ; } if ( flags & IBT_CEP_SET_MIN_RNR_NAK ) { qpc -> min_rnr_nak = rc -> rc_min_rnr_nak ; opmask |= HERMON_CMD_OP_MINRNRNAK ; } } if ( qp -> qp_serv_type == HERMON_QP_UC ) { uc = & info_p -> qp_transport . uc ; if ( flags & IBT_CEP_SET_RDMA_W ) { qpc -> rwe = ( info_p -> qp_flags & IBT_CEP_RDMA_WR ) ?1 : 0 ; opmask |= HERMON_CMD_OP_RWE ; } if ( flags & IBT_CEP_SET_ADDS_VECT ) { qpc_path = & qpc -> pri_addr_path ; adds_vect = & uc -> uc_path . cep_adds_vect ; status = hermon_set_addr_path ( state , adds_vect , qpc_path , HERMON_ADDRPATH_QP ) ; if ( status != DDI_SUCCESS ) { return ( status ) ; } portnum = qp -> qp_portnum + 1 ; if ( hermon_portnum_is_valid ( state , portnum ) ) { qpc -> pri_addr_path . sched_q = HERMON_QP_SCHEDQ_GET ( qp -> qp_portnum , adds_vect -> av_srvl , qp -> qp_is_special ) ; } else { return ( IBT_HCA_PORT_INVALID ) ; } qpc -> mtu = qp -> qp_save_mtu ; opmask |= HERMON_CMD_OP_PRIM_PATH ; } if ( flags & IBT_CEP_SET_MIG ) { if ( uc -> uc_mig_state == IBT_STATE_MIGRATED ) { qpc -> pm_state = HERMON_QP_PMSTATE_MIGRATED ; } if ( uc -> uc_mig_state == IBT_STATE_REARMED ) { qpc -> pm_state = HERMON_QP_PMSTATE_REARM ; } else { return ( IBT_QP_APM_STATE_INVALID ) ; } opmask |= HERMON_CMD_OP_PM_STATE ; } if ( flags & IBT_CEP_SET_PKEY_IX ) { pkeyindx = uc -> uc_path . cep_pkey_ix ; if ( hermon_pkeyindex_is_valid ( state , pkeyindx ) ) { qpc -> pri_addr_path . pkey_indx = pkeyindx ; opmask |= HERMON_CMD_OP_PKEYINDX ; } else { return ( IBT_PKEY_IX_ILLEGAL ) ; } } if ( flags & IBT_CEP_SET_ALT_PATH ) { qpc_path = & qpc -> alt_addr_path ; adds_vect = & uc -> uc_alt_path . cep_adds_vect ; status = hermon_set_addr_path ( state , adds_vect , qpc_path , HERMON_ADDRPATH_QP ) ; if ( status != DDI_SUCCESS ) { return ( status ) ; } portnum = uc -> uc_alt_path . cep_hca_port_num ; if ( hermon_portnum_is_valid ( state , portnum ) ) { qp -> qp_portnum_alt = portnum - 1 ; qpc -> alt_addr_path . sched_q = HERMON_QP_SCHEDQ_GET ( portnum - 1 , adds_vect -> av_srvl , qp -> qp_is_special ) ; } else { return ( IBT_HCA_PORT_INVALID ) ; } pkeyindx = uc -> uc_alt_path . cep_pkey_ix ; if ( hermon_pkeyindex_is_valid ( state , pkeyindx ) ) { qpc -> alt_addr_path . pkey_indx = pkeyindx ; } else { return ( IBT_PKEY_IX_ILLEGAL ) ; } opmask |= HERMON_CMD_OP_ALT_PATH ; } } else { HERMON_WARNING ( state , "unknown QP transport type in sqd2sqd" ) ; return ( ibc_get_ci_failure ( 0 ) ) ; } status = hermon_cmn_qp_cmd_post ( state , SQD2SQD_QP , qpc , qp -> qp_qpnum , opmask , HERMON_CMD_NOSLEEP_SPIN ) ; if ( status != HERMON_CMD_SUCCESS ) { if ( status != HERMON_CMD_BAD_QP_STATE ) { cmn_err ( CE_NOTE , "hermon%d: SQD2SQD_QP command failed: " "%08x\n" , state -> hs_instance , status ) ; return ( ibc_get_ci_failure ( 0 ) ) ; } else { return ( IBT_QP_STATE_INVALID ) ; } } return ( DDI_SUCCESS ) ; } 