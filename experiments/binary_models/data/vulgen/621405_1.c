static void __init read_obp_memory ( const char * property , struct linux_prom64_registers * regs , int * num_ents ) { phandle node = prom_finddevice ( "/memory" ) ; int prop_size = prom_getproplen ( node , property ) ; int ents , ret , i ; ents = prop_size / sizeof ( linux_prom64_registers ) ; if ( ents > MAX_BANKS ) { prom_printf ( "The machine has more %s property entries than " "this kernel can support (%d).\n" , property , MAX_BANKS ) ; prom_halt ( ) ; } ret = prom_getproperty ( node , property , ( char * ) regs , prop_size ) ; if ( ret == - 1 ) { prom_printf ( "Couldn't get %s property from /memory.\n" , property ) ; prom_halt ( ) ; } for ( i = 0 ; i < ents ; i ++ ) { unsigned long base , size ; base = regs [ i ] . phys_addr ; size = regs [ i ] . reg_size ; size &= PAGE_MASK ; if ( base & ~ PAGE_MASK ) { unsigned long new_base = PAGE_ALIGN ( base ) ; size -= new_base - base ; base = new_base ; } if ( size == 0UL ) { memmove ( & regs [ i ] , & regs [ i + 1 ] , ( ents - i - 1 ) * sizeof ( regs [ 0 ] ) ) ; i -- ; ents -- ; continue ; } regs [ i ] . phys_addr = base ; regs [ i ] . reg_size = size ; } * num_ents = ents ; sort ( regs , ents , sizeof ( linux_prom64_registers ) , cmp_p64 , NULL ) ; } unsigned long kern_base __read_mostly ; unsigned long kern_size __read_mostly ; extern unsigned long sparc_ramdisk_image64 ; extern unsigned int sparc_ramdisk_image ; extern unsigned int sparc_ramdisk_size ; struct page * mem_map_zero __read_mostly ; EXPORT_SYMBOL ( mem_map_zero ) ; unsigned int sparc64_highest_unlocked_tlb_ent __read_mostly ; unsigned long sparc64_kern_pri_context __read_mostly ; unsigned long sparc64_kern_pri_nuc_bits __read_mostly ; unsigned long sparc64_kern_sec_context __read_mostly ; int num_kernel_image_mappings ; atomic_t dcpage_flushes = ATOMIC_INIT ( 0 ) ; atomic_t dcpage_flushes_xcall = ATOMIC_INIT ( 0 ) ; inline void flush_dcache_page_impl ( struct page * page ) { BUG_ON ( tlb_type == hypervisor ) ; atomic_inc ( & dcpage_flushes ) ; __flush_dcache_page ( page_address ( page ) , ( ( tlb_type == spitfire ) && page_mapping ( page ) != NULL ) ) ; if ( page_mapping ( page ) != NULL && tlb_type == spitfire ) { __flush_icache_page ( __pa ( page_address ( page ) ) ) ; } } 