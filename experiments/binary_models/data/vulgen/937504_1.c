static u8 smp_cmd_pairing_random ( struct l2cap_conn * conn , struct sk_buff * skb ) { struct l2cap_chan * chan = conn -> smp ; struct smp_chan * smp = chan -> data ; struct hci_conn * hcon = conn -> hcon ; u8 * pkax , * pkbx , * na , * nb , confirm_hint ; u32 passkey ; int err ; bt_dev_dbg ( hcon -> hdev , "conn %p" , conn ) ; memcpy ( smp -> rrnd , skb -> data , sizeof ( smp -> rrnd ) ) ; skb_pull ( skb , sizeof ( smp -> rrnd ) ) ; if ( ! test_bit ( SMP_FLAG_SC , & smp -> flags ) ) { return smp_random ( smp ) ; } if ( hcon -> out ) { pkax = smp -> local_pk ; pkbx = smp -> remote_pk ; na = smp -> prnd ; nb = smp -> rrnd ; } else { pkax = smp -> remote_pk ; pkbx = smp -> local_pk ; na = smp -> rrnd ; nb = smp -> prnd ; } if ( smp -> method == REQ_OOB ) { if ( ! hcon -> out ) { smp_send_cmd ( conn , SMP_CMD_PAIRING_RANDOM , sizeof ( smp -> prnd ) , smp -> prnd ) ; } SMP_ALLOW_CMD ( smp , SMP_CMD_DHKEY_CHECK ) ; mackey_and_ltk } if ( smp -> method == REQ_PASSKEY || smp -> method == DSP_PASSKEY ) { return sc_passkey_round ( smp , SMP_CMD_PAIRING_RANDOM ) ; } if ( hcon -> out ) { u8 cfm [ 16 ] ; err = smp_f4 ( smp -> tfm_cmac , smp -> remote_pk , smp -> local_pk , smp -> rrnd , 0 , cfm ) ; if ( err ) { return SMP_UNSPECIFIED ; } if ( crypto_memneq ( smp -> pcnf , cfm , 16 ) ) { return SMP_CONFIRM_FAILED ; } } else { smp_send_cmd ( conn , SMP_CMD_PAIRING_RANDOM , sizeof ( smp -> prnd ) , smp -> prnd ) ; SMP_ALLOW_CMD ( smp , SMP_CMD_DHKEY_CHECK ) ; if ( smp -> method != JUST_WORKS ) { mackey_and_ltk } if ( hci_find_ltk ( hcon -> hdev , & hcon -> dst , hcon -> dst_type , hcon -> role ) ) { passkey = 0 ; confirm_hint = 1 ; confirm } } mackey_and_ltk err = sc_mackey_and_ltk ( smp , smp -> mackey , smp -> tk ) ; if ( err ) { return SMP_UNSPECIFIED ; } if ( smp -> method == REQ_OOB ) { if ( hcon -> out ) { sc_dhkey_check ( smp ) ; SMP_ALLOW_CMD ( smp , SMP_CMD_DHKEY_CHECK ) ; } return 0 ; } err = smp_g2 ( smp -> tfm_cmac , pkax , pkbx , na , nb , & passkey ) ; if ( err ) { return SMP_UNSPECIFIED ; } confirm_hint = 0 ; confirm if ( smp -> method == JUST_WORKS ) { confirm_hint = 1 ; } err = mgmt_user_confirm_request ( hcon -> hdev , & hcon -> dst , hcon -> type , hcon -> dst_type , passkey , confirm_hint ) ; if ( err ) { return SMP_UNSPECIFIED ; } set_bit ( SMP_FLAG_WAIT_USER , & smp -> flags ) ; return 0 ; } 