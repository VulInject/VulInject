static guint32 dissect_dcm_tag ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , dcm_state_pdv_t * pdv , guint32 offset , guint32 endpos , gboolean is_first_tag , const gchar * * tag_description , gboolean * end_of_seq_or_item ) { proto_tree * tag_ptree = NULL ; proto_tree * seq_ptree = NULL ; proto_item * tag_pitem = NULL ; dcm_tag_t * tag_def = NULL ; gint ett ; const gchar * vr = NULL ; gchar * tag_value = "" ; gchar * tag_summary ; guint32 vl = 0 ; guint16 vl_1 = 0 ; guint16 vl_2 = 0 ; guint32 offset_tag = 0 ; guint32 offset_vr = 0 ; guint32 offset_vl = 0 ; guint32 vl_max = 0 ; guint16 grp = 0 ; guint16 elm = 0 ; guint32 len_decoded_remaing = 0 ; guint32 encoding = ( pdv -> syntax == DCM_EBE ) ?ENC_BIG_ENDIAN : ENC_LITTLE_ENDIAN ; gboolean is_implicit = ( pdv -> syntax == DCM_ILE ) ; gboolean is_vl_long = FALSE ; gboolean is_sequence = FALSE ; gboolean is_item = FALSE ; * tag_description = NULL ; offset_tag = offset ; if ( pdv -> prev && is_first_tag ) { len_decoded_remaing = pdv -> prev -> open_tag . len_decoded ; } if ( len_decoded_remaing >= 2 ) { grp = pdv -> prev -> open_tag . grp ; len_decoded_remaing -= 2 ; } else { grp = tvb_get_guint16 ( tvb , offset , encoding ) ; offset += 2 ; pdv -> open_tag . grp = grp ; } if ( len_decoded_remaing >= 2 ) { elm = pdv -> prev -> open_tag . elm ; len_decoded_remaing -= 2 ; } else { if ( dcm_tag_is_open ( pdv , offset_tag , offset , endpos , 2 ) ) { return endpos ; } elm = tvb_get_guint16 ( tvb , offset , encoding ) ; offset += 2 ; pdv -> open_tag . elm = elm ; } tag_def = dcm_tag_lookup ( grp , elm ) ; offset_vr = offset ; if ( ( grp == 0xFFFE ) && ( elm == 0xE000 || elm == 0xE00D || elm == 0xE0DD ) ) { vr = "UL" ; is_vl_long = TRUE ; } if ( is_implicit ) { vr = wmem_strdup ( pinfo -> pool , tag_def -> vr ) ; is_vl_long = TRUE ; } else { if ( len_decoded_remaing >= 2 ) { vr = wmem_strdup ( pinfo -> pool , pdv -> prev -> open_tag . vr ) ; len_decoded_remaing -= 2 ; } else { if ( dcm_tag_is_open ( pdv , offset_tag , offset_vr , endpos , 2 ) ) { return endpos ; } vr = ( gchar * ) tvb_get_string_enc ( pinfo -> pool , tvb , offset , 2 , ENC_ASCII ) ; offset += 2 ; g_free ( pdv -> open_tag . vr ) ; pdv -> open_tag . vr = g_strdup ( vr ) ; } if ( ( strcmp ( vr , "OB" ) == 0 ) || ( strcmp ( vr , "OW" ) == 0 ) || ( strcmp ( vr , "OF" ) == 0 ) || ( strcmp ( vr , "OD" ) == 0 ) || ( strcmp ( vr , "OL" ) == 0 ) || ( strcmp ( vr , "SQ" ) == 0 ) || ( strcmp ( vr , "UC" ) == 0 ) || ( strcmp ( vr , "UR" ) == 0 ) || ( strcmp ( vr , "UT" ) == 0 ) || ( strcmp ( vr , "UN" ) == 0 ) ) { is_vl_long = TRUE ; if ( len_decoded_remaing >= 2 ) { len_decoded_remaing -= 2 ; } else { if ( dcm_tag_is_open ( pdv , offset_tag , offset_vr , endpos , 2 ) ) { return endpos ; } offset += 2 ; } } else { is_vl_long = FALSE ; } } offset_vl = offset ; if ( len_decoded_remaing >= 2 ) { vl_1 = pdv -> prev -> open_tag . vl_1 ; len_decoded_remaing -= 2 ; } else { if ( dcm_tag_is_open ( pdv , offset_tag , offset_vl , endpos , 2 ) ) { return endpos ; } vl_1 = tvb_get_guint16 ( tvb , offset , encoding ) ; offset += 2 ; pdv -> open_tag . vl_1 = vl_1 ; } if ( is_vl_long ) { if ( len_decoded_remaing >= 2 ) { vl_2 = pdv -> prev -> open_tag . vl_2 ; } else { if ( dcm_tag_is_open ( pdv , offset_tag , offset_vl + 2 , endpos , 2 ) ) { return endpos ; } vl_2 = tvb_get_guint16 ( tvb , offset , encoding ) ; offset += 2 ; pdv -> open_tag . vl_2 = vl_2 ; } if ( encoding == ENC_LITTLE_ENDIAN ) { vl = ( vl_2 << 16 ) + vl_1 ; } else { vl = ( vl_1 << 16 ) + vl_2 ; } } else { vl = vl_1 ; } tag_summary = dcm_tag_summary ( pinfo , grp , elm , vl , tag_def -> description , vr , tag_def -> is_retired , is_implicit ) ; is_sequence = ( strcmp ( vr , "SQ" ) == 0 ) || ( vl == 0xFFFFFFFF ) ; is_item = ( ( grp == 0xFFFE ) && ( elm == 0xE000 ) ) ; if ( ( is_sequence | is_item ) && global_dcm_seq_subtree ) { ett = is_sequence ?ett_dcm_data_seq : ett_dcm_data_item ; } else { ett = ett_dcm_data_tag ; } if ( vl == 0xFFFFFFFF ) { tag_ptree = proto_tree_add_subtree ( tree , tvb , offset_tag , offset - offset_tag , ett , & tag_pitem , tag_summary ) ; vl_max = 0 ; } if ( offset + vl <= endpos ) { tag_ptree = proto_tree_add_subtree ( tree , tvb , offset_tag , offset + vl - offset_tag , ett , & tag_pitem , tag_summary ) ; vl_max = vl ; } else { tag_ptree = proto_tree_add_subtree ( tree , tvb , offset_tag , endpos - offset_tag , ett , & tag_pitem , tag_summary ) ; vl_max = endpos - offset ; } if ( is_sequence | is_item ) { if ( global_dcm_seq_subtree ) { seq_ptree = tag_ptree ; if ( ! global_dcm_tag_subtree ) { tag_ptree = NULL ; } } else { seq_ptree = tree ; if ( ! global_dcm_tag_subtree ) { tag_ptree = NULL ; } } } else { if ( ! global_dcm_tag_subtree ) { tag_ptree = NULL ; } } proto_tree_add_uint_format_value ( tag_ptree , hf_dcm_tag , tvb , offset_tag , 4 , ( grp << 16 ) | elm , "%04x,%04x (%s)" , grp , elm , tag_def -> description ) ; if ( ! is_item ) { if ( is_implicit ) { proto_tree_add_string ( tag_ptree , hf_dcm_tag_vr , tvb , offset_tag , 4 , vr ) ; } else { proto_tree_add_string ( tag_ptree , hf_dcm_tag_vr , tvb , offset_vr , 2 , vr ) ; } } proto_tree_add_uint ( tag_ptree , hf_dcm_tag_vl , tvb , offset_vl , ( is_vl_long ?4 : 2 ) , vl ) ; if ( ( is_sequence || is_item ) && ( vl > 0 ) ) { guint32 endpos_item = 0 ; gboolean local_end_of_seq_or_item = FALSE ; gboolean is_first_desc = TRUE ; const gchar * item_description = NULL ; if ( vl == 0xFFFFFFFF ) { while ( ( ! local_end_of_seq_or_item ) && ( ! pdv -> open_tag . is_header_fragmented ) && ( offset < endpos ) ) { offset = dissect_dcm_tag ( tvb , pinfo , seq_ptree , pdv , offset , endpos , FALSE , & item_description , & local_end_of_seq_or_item ) ; if ( item_description && global_dcm_seq_subtree ) { proto_item_append_text ( tag_pitem , ( is_first_desc ?" %s" : ", %s" ) , item_description ) ; is_first_desc = FALSE ; } } } else { endpos_item = offset + vl_max ; while ( offset < endpos_item ) { offset = dissect_dcm_tag ( tvb , pinfo , seq_ptree , pdv , offset , endpos_item , FALSE , & item_description , & local_end_of_seq_or_item ) ; if ( item_description && global_dcm_seq_subtree ) { proto_item_append_text ( tag_pitem , ( is_first_desc ?" %s" : ", %s" ) , item_description ) ; is_first_desc = FALSE ; } } } } if ( ( grp == 0xFFFE ) && ( elm == 0xE00D ) ) { * end_of_seq_or_item = TRUE ; } if ( ( grp == 0xFFFE ) && ( elm == 0xE0DD ) ) { * end_of_seq_or_item = TRUE ; } if ( vl == 0 ) { tag_value = wmem_strdup ( pinfo -> pool , "<Empty>" ) ; } if ( vl > vl_max ) { gchar * tag_desc ; proto_tree_add_bytes_format ( tag_ptree , hf_dcm_tag_value_byte , tvb , offset , vl_max , NULL , "%-8.8sBytes %d - %d [start]" , "Value:" , 1 , vl_max ) ; tag_value = wmem_strdup_printf ( pinfo -> pool , "<Bytes %d - %d, start>" , 1 , vl_max ) ; offset += vl_max ; tag_desc = dcm_tag_summary ( pinfo , grp , elm , vl , tag_def -> description , vr , tag_def -> is_retired , is_implicit ) ; if ( pdv -> open_tag . desc == NULL ) { pdv -> open_tag . is_value_fragmented = TRUE ; pdv -> open_tag . desc = wmem_strdup ( wmem_file_scope ( ) , tag_desc ) ; pdv -> open_tag . len_total = vl ; pdv -> open_tag . len_remaining = vl - vl_max ; } } else { offset = dissect_dcm_tag_value ( tvb , pinfo , tag_ptree , pdv , offset , grp , elm , vl , vl_max , vr , & tag_value ) ; if ( grp == 0x0008 && elm == 0x0016 ) { dcm_state_pdv_get_obj_start ( pdv ) -> sop_class_uid = wmem_strdup ( wmem_file_scope ( ) , tag_value ) ; } if ( grp == 0x0008 && elm == 0x0018 ) { dcm_state_pdv_get_obj_start ( pdv ) -> sop_instance_uid = wmem_strdup ( wmem_file_scope ( ) , tag_value ) ; } if ( grp == 0x0000 && elm == 0x0100 ) { pdv -> desc = wmem_strdup ( wmem_file_scope ( ) , tag_value ) ; } } proto_item_append_text ( tag_pitem , " %s" , tag_value ) ; if ( tag_def -> add_to_summary ) { * tag_description = wmem_strdup ( pinfo -> pool , g_strstrip ( tag_value ) ) ; } return offset ; } 