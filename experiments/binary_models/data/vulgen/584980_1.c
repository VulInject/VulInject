int AAS_BestReachableArea ( vec3_t origin , vec3_t mins , vec3_t maxs , vec3_t goalorigin ) { int areanum , i , j , k , l ; aas_link_t * areas ; vec3_t absmins , absmaxs ; vec3_t start , end ; aas_trace_t trace ; if ( ! ( * aasworld ) . loaded ) { botimport . Print ( PRT_ERROR , "AAS_BestReachableArea: aas not loaded\n" ) ; return 0 ; } VectorCopy ( origin , start ) ; areanum = AAS_PointAreaNum ( start ) ; for ( i = 0 ; i < 5 && ! areanum ; i ++ ) { for ( j = 0 ; j < 5 && ! areanum ; j ++ ) { for ( k = - 1 ; k <= 1 && ! areanum ; k ++ ) { for ( l = - 1 ; l <= 1 && ! areanum ; l ++ ) { VectorCopy ( origin , start ) ; start [ 0 ] += ( float ) j * 4 * k ; start [ 1 ] += ( float ) j * 4 * l ; start [ 2 ] += ( float ) i * 4 ; areanum = AAS_PointAreaNum ( start ) ; } } } } if ( areanum ) { VectorCopy ( start , end ) ; start [ 2 ] += 0.25 ; end [ 2 ] -= 50 ; trace = AAS_TraceClientBBox ( start , end , PRESENCE_CROUCH , - 1 ) ; if ( ! trace . startsolid ) { areanum = AAS_PointAreaNum ( trace . endpos ) ; VectorCopy ( trace . endpos , goalorigin ) ; if ( areanum ) { return areanum ; } } else { VectorCopy ( start , goalorigin ) ; return areanum ; } } VectorCopy ( origin , goalorigin ) ; VectorAdd ( origin , maxs , absmaxs ) ; areas = AAS_AASLinkEntity ( absmins , absmaxs , - 1 ) ; areanum = AAS_BestReachableLinkArea ( areas ) ; AAS_UnlinkFromAreas ( areas ) ; return areanum ; } 