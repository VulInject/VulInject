static void dissect_srt_control_packet ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , proto_item * srt_item ) { guint32 type = 0 ; guint32 exttype = 0 ; proto_tree_add_item_ret_uint ( tree , hf_srt_type , tvb , 0 , 2 , ENC_BIG_ENDIAN , & type ) ; if ( type != UMSG_EXT ) { proto_tree_add_item ( tree , hf_srt_exttype_none , tvb , 2 , 2 , ENC_BIG_ENDIAN ) ; } else { proto_tree_add_item_ret_uint ( tree , hf_srt_exttype , tvb , 2 , 2 , ENC_BIG_ENDIAN , & exttype ) ; } switch ( type ) { case UMSG_EXT : col_add_fstr ( pinfo -> cinfo , COL_INFO , "Control/ext: %s  socket: 0x%x" , val_to_str ( exttype , srt_ctrlmsg_exttypes , "Unknown SRT Control Type (0x%x)" ) , tvb_get_ntohl ( tvb , 12 ) ) ; break ; case UMSG_ACK : col_add_fstr ( pinfo -> cinfo , COL_INFO , "Control: UMSG_ACK %d ackseq: %d  socket: 0x%x" , tvb_get_ntohl ( tvb , 4 ) , tvb_get_ntohl ( tvb , 16 ) , tvb_get_ntohl ( tvb , 12 ) ) ; break ; case UMSG_ACKACK : col_add_fstr ( pinfo -> cinfo , COL_INFO , "Control: UMSG_ACKACK %d socket: 0x%x" , tvb_get_ntohl ( tvb , 4 ) , tvb_get_ntohl ( tvb , 12 ) ) ; break ; default : col_add_fstr ( pinfo -> cinfo , COL_INFO , "Control: %s  socket: 0x%x" , val_to_str ( type , srt_ctrlmsg_types , "Unknown UDT Control Type (%x)" ) , tvb_get_ntohl ( tvb , 12 ) ) ; break ; } switch ( type ) { case UMSG_ACK : case UMSG_ACKACK : proto_tree_add_item ( tree , hf_srt_ackno , tvb , 4 , 4 , ENC_BIG_ENDIAN ) ; break ; case UMSG_DROPREQ : proto_tree_add_item ( tree , hf_srt_msgno , tvb , 4 , 4 , ENC_BIG_ENDIAN ) ; break ; default : proto_tree_add_item ( tree , hf_srt_addinfo , tvb , 4 , 4 , ENC_BIG_ENDIAN ) ; break ; } proto_tree_add_item ( tree , hf_srt_timestamp , tvb , 8 , 4 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( tree , hf_srt_id , tvb , 12 , 4 , ENC_BIG_ENDIAN ) ; switch ( type ) { case UMSG_HANDSHAKE : { char ipbuf [ IP_BUFFER_SIZE ] ; const int version = tvb_get_ntohl ( tvb , 16 ) ; const int final_length = tvb_reported_length ( tvb ) ; int baselen = 64 ; proto_tree_add_item ( tree , hf_srt_handshake_version , tvb , 16 , 4 , ENC_BIG_ENDIAN ) ; if ( version == 4 ) { proto_tree_add_item ( tree , hf_srt_handshake_type_v4 , tvb , 20 , 4 , ENC_BIG_ENDIAN ) ; } else { proto_tree_add_item ( tree , hf_srt_handshake_enc_field_v5 , tvb , 20 , 2 , ENC_BIG_ENDIAN ) ; dissect_srt_hs_ext_field ( tree , tvb , 22 ) ; } proto_tree_add_item ( tree , hf_srt_handshake_isn , tvb , 24 , 4 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( tree , hf_srt_handshake_mtu , tvb , 28 , 4 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( tree , hf_srt_handshake_flow_window , tvb , 32 , 4 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( tree , hf_srt_handshake_reqtype , tvb , 36 , 4 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( tree , hf_srt_handshake_id , tvb , 40 , 4 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( tree , hf_srt_handshake_cookie , tvb , 44 , 4 , ENC_BIG_ENDIAN ) ; srt_format_ip_address ( ipbuf , sizeof ipbuf , ( const gchar * ) tvb_memdup ( wmem_packet_scope ( ) , tvb , 48 , 16 ) ) ; proto_tree_add_string ( tree , hf_srt_handshake_peerip , tvb , 48 , 16 , ipbuf ) ; if ( final_length > baselen ) { int begin = baselen ; for ( ; ; ) { const guint16 blockid = tvb_get_ntohs ( tvb , begin ) ; const guint16 blocklen = tvb_get_ntohs ( tvb , begin + 2 ) ; proto_tree_add_item ( tree , hf_srt_srths_blocktype , tvb , begin , 2 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( tree , hf_srt_srths_blocklen , tvb , begin + 2 , 2 , ENC_BIG_ENDIAN ) ; begin += 4 ; switch ( blockid ) { case SRT_CMD_HSREQ : case SRT_CMD_HSRSP : if ( blocklen == 3 ) { srt_format_hs_ext_hsreq ( tree , tvb , begin ) ; } else { proto_tree_add_expert_format ( tree , pinfo , & ei_srt_hs_ext_hsreq_len , tvb , begin , 4 * blocklen , "Actual length is %u" , blocklen ) ; } break ; case SRT_CMD_KMREQ : case SRT_CMD_KMRSP : srt_format_kmx ( tree , tvb , begin , blocklen * 4 ) ; break ; case SRT_CMD_SID : format_text_reorder_32 ( tree , tvb , hf_srt_srths_sid , begin , 4 * blocklen ) ; break ; case SRT_CMD_CONJESTCTRL : format_text_reorder_32 ( tree , tvb , hf_srt_srths_conjestcontrol , begin , 4 * blocklen ) ; break ; default : proto_tree_add_expert_format ( tree , pinfo , & ei_srt_hs_ext_type , tvb , begin , 4 * blocklen , "Ext Type value is %u" , blockid ) ; break ; } begin += blocklen * 4 ; if ( begin >= final_length ) { break ; } } baselen = begin ; } proto_item_set_len ( srt_item , baselen ) ; } break ; case UMSG_ACK : { guint len = tvb_reported_length ( tvb ) ; proto_tree_add_item ( tree , hf_srt_ack_seqno , tvb , 4 * 4 , 4 , ENC_BIG_ENDIAN ) ; if ( len <= ( 4 + 1 ) * 4 ) { proto_item_set_len ( srt_item , ( 4 + 1 ) * 4 ) ; } else { proto_tree_add_item ( tree , hf_srt_rtt , tvb , ( 4 + 1 ) * 4 , 4 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( tree , hf_srt_rttvar , tvb , ( 4 + 2 ) * 4 , 4 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( tree , hf_srt_bufavail , tvb , ( 4 + 3 ) * 4 , 4 , ENC_BIG_ENDIAN ) ; if ( len > ( 4 + 4 ) * 4 ) { proto_tree_add_item ( tree , hf_srt_rate , tvb , ( 4 + 4 ) * 4 , 4 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( tree , hf_srt_bandwidth , tvb , ( 4 + 5 ) * 4 , 4 , ENC_BIG_ENDIAN ) ; if ( len > ( 4 + 6 ) * 4 ) { proto_tree_add_item ( tree , hf_srt_rcvrate , tvb , ( 4 + 6 ) * 4 , 4 , ENC_BIG_ENDIAN ) ; len = ( 4 + 7 ) * 4 ; } proto_item_set_len ( srt_item , ( gint ) len ) ; } else { proto_item_set_len ( srt_item , ( 4 + 4 ) * 4 ) ; } } } break ; case UMSG_LOSSREPORT : { guint len = tvb_reported_length ( tvb ) ; guint pos ; guint32 val ; guint prev = 0 ; for ( pos = 16 ; pos < len ; pos += 4 ) { val = tvb_get_ntohl ( tvb , pos ) ; if ( val & SRT_LOSS_SEQUENCE_FIRST ) { prev = val ; continue ; } if ( prev & SRT_LOSS_SEQUENCE_FIRST ) { proto_tree_add_expert_format ( tree , pinfo , & ei_srt_nak_seqno , tvb , pos - 4 , 8 , "Loss sequence range: %u-%u" , ( prev & SRT_LOSS_SEQUENCE_MASK ) , val ) ; prev = 0 ; } else { proto_tree_add_expert_format ( tree , pinfo , & ei_srt_nak_seqno , tvb , pos , 4 , "Loss sequence: %u" , val ) ; } } if ( prev ) { proto_tree_add_expert_format ( tree , pinfo , & ei_srt_nak_seqno , tvb , pos - 4 , 4 , "ERROR: loss sequence range begin only: %u (%x)" , val & SRT_LOSS_SEQUENCE_MASK , val ) ; } proto_item_set_len ( srt_item , len ) ; } break ; case UMSG_EXT : switch ( exttype ) { case SRT_CMD_HSREQ : case SRT_CMD_HSRSP : srt_format_hs_ext_hsreq ( tree , tvb , 16 ) ; break ; case SRT_CMD_KMREQ : case SRT_CMD_KMRSP : { int plen = tvb_reported_length ( tvb ) - 16 ; srt_format_kmx ( tree , tvb , 16 , plen ) ; } break ; default : break ; } break ; default : proto_tree_add_item ( tree , hf_srt_addinfo , tvb , 16 , 4 , ENC_BIG_ENDIAN ) ; break ; } } 