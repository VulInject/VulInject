static int osc_brw_prep_request ( int cmd , struct client_obd * cli , struct obdo * oa , u32 page_count , struct brw_page * * pga , struct ptlrpc_request * * reqp , int reserve , int resend ) { struct ptlrpc_request * req ; struct ptlrpc_bulk_desc * desc ; struct ost_body * body ; struct obd_ioobj * ioobj ; struct niobuf_remote * niobuf ; int niocount , i , requested_nob , opc , rc ; struct osc_brw_async_args * aa ; struct req_capsule * pill ; struct brw_page * pg_prev ; if ( OBD_FAIL_CHECK ( OBD_FAIL_OSC_BRW_PREP_REQ ) ) { return - ENOMEM ; } if ( ( cmd & OBD_BRW_WRITE ) != 0 ) { opc = OST_WRITE ; req = ptlrpc_request_alloc_pool ( cli -> cl_import , osc_rq_pool , & RQF_OST_BRW_WRITE ) ; } else { opc = OST_READ ; req = ptlrpc_request_alloc ( cli -> cl_import , & RQF_OST_BRW_READ ) ; } if ( ! req ) { return - ENOMEM ; } for ( niocount = i = 1 ; i < page_count ; i ++ ) { if ( ! can_merge_pages ( pga [ i - 1 ] , pga [ i ] ) ) { niocount ++ ; } } pill = & req -> rq_pill ; req_capsule_set_size ( pill , & RMF_OBD_IOOBJ , RCL_CLIENT , sizeof ( * ioobj ) ) ; req_capsule_set_size ( pill , & RMF_NIOBUF_REMOTE , RCL_CLIENT , niocount * sizeof ( * niobuf ) ) ; rc = ptlrpc_request_pack ( req , LUSTRE_OST_VERSION , opc ) ; if ( rc ) { ptlrpc_request_free ( req ) ; return rc ; } req -> rq_request_portal = OST_IO_PORTAL ; ptlrpc_at_set_req_timeout ( req ) ; req -> rq_no_retry_einprogress = 1 ; desc = ptlrpc_prep_bulk_imp ( req , page_count , cli -> cl_import -> imp_connect_data . ocd_brw_size >> LNET_MTU_BITS , ( opc == OST_WRITE ?PTLRPC_BULK_GET_SOURCE : PTLRPC_BULK_PUT_SINK ) | PTLRPC_BULK_BUF_KIOV , OST_BULK_PORTAL , & ptlrpc_bulk_kiov_pin_ops ) ; if ( ! desc ) { rc = - ENOMEM ; out } body = req_capsule_client_get ( pill , & RMF_OST_BODY ) ; ioobj = req_capsule_client_get ( pill , & RMF_OBD_IOOBJ ) ; niobuf = req_capsule_client_get ( pill , & RMF_NIOBUF_REMOTE ) ; LASSERT ( body && ioobj && niobuf ) ; lustre_set_wire_obdo ( & req -> rq_import -> imp_connect_data , & body -> oa , oa ) ; obdo_to_ioobj ( oa , ioobj ) ; ioobj -> ioo_bufcnt = niocount ; ioobj_max_brw_set ( ioobj , desc -> bd_md_max_brw ) ; LASSERT ( page_count > 0 ) ; pg_prev = pga [ 0 ] ; for ( requested_nob = i = 0 ; i < page_count ; i ++ , niobuf ++ ) { struct brw_page * pg = pga [ i ] ; int poff = pg -> off & ~ PAGE_MASK ; LASSERT ( pg -> count > 0 ) ; LASSERTF ( page_count == 1 || ( ergo ( i == 0 , poff + pg -> count == PAGE_SIZE ) && ergo ( i > 0 && i < page_count - 1 , poff == 0 && pg -> count == PAGE_SIZE ) && ergo ( i == page_count - 1 , poff == 0 ) ) , "i: %d/%d pg: %p off: %llu, count: %u\n" , i , page_count , pg , pg -> off , pg -> count ) ; LASSERTF ( i == 0 || pg -> off > pg_prev -> off , "i %d p_c %u pg %p [pri %lu ind %lu] off %llu prev_pg %p [pri %lu ind %lu]off %llu\n" , i , page_count , pg -> pg , page_private ( pg -> pg ) , pg -> pg -> index , pg -> off , pg_prev -> pg , page_private ( pg_prev -> pg ) , pg_prev -> pg -> index , pg_prev -> off ) ; LASSERT ( ( pga [ 0 ] -> flag & OBD_BRW_SRVLOCK ) == ( pg -> flag & OBD_BRW_SRVLOCK ) ) ; desc -> bd_frag_ops -> add_kiov_frag ( desc , pg -> pg , poff , pg -> count ) ; requested_nob += pg -> count ; if ( i > 0 && can_merge_pages ( pg_prev , pg ) ) { niobuf -- ; niobuf -> rnb_len += pg -> count ; } else { niobuf -> rnb_offset = pg -> off ; niobuf -> rnb_len = pg -> count ; niobuf -> rnb_flags = pg -> flag ; } pg_prev = pg ; } LASSERTF ( ( void * ) ( niobuf - niocount ) == req_capsule_client_get ( & req -> rq_pill , & RMF_NIOBUF_REMOTE ) , "want %p - real %p\n" , req_capsule_client_get ( & req -> rq_pill , & RMF_NIOBUF_REMOTE ) , ( void * ) ( niobuf - niocount ) ) ; osc_announce_cached ( cli , & body -> oa , opc == OST_WRITE ?requested_nob : 0 ) ; if ( resend ) { if ( ( body -> oa . o_valid & OBD_MD_FLFLAGS ) == 0 ) { body -> oa . o_valid |= OBD_MD_FLFLAGS ; body -> oa . o_flags = 0 ; } body -> oa . o_flags |= OBD_FL_RECOV_RESEND ; } if ( osc_should_shrink_grant ( cli ) ) { osc_shrink_grant_local ( cli , & body -> oa ) ; } if ( opc == OST_WRITE ) { if ( cli -> cl_checksum && ! sptlrpc_flavor_has_bulk ( & req -> rq_flvr ) ) { enum cksum_type cksum_type = cli -> cl_cksum_type ; if ( ( body -> oa . o_valid & OBD_MD_FLFLAGS ) == 0 ) { oa -> o_flags &= OBD_FL_LOCAL_MASK ; body -> oa . o_flags = 0 ; } body -> oa . o_flags |= cksum_type_pack ( cksum_type ) ; body -> oa . o_valid |= OBD_MD_FLCKSUM | OBD_MD_FLFLAGS ; body -> oa . o_cksum = osc_checksum_bulk ( requested_nob , page_count , pga , OST_WRITE , cksum_type ) ; CDEBUG ( D_PAGE , "checksum at write origin: %x\n" , body -> oa . o_cksum ) ; oa -> o_valid |= OBD_MD_FLCKSUM | OBD_MD_FLFLAGS ; oa -> o_flags |= cksum_type_pack ( cksum_type ) ; } else { oa -> o_valid &= ~ OBD_MD_FLCKSUM ; } oa -> o_cksum = body -> oa . o_cksum ; req_capsule_set_size ( pill , & RMF_RCS , RCL_SERVER , sizeof ( __u32 ) * niocount ) ; } else { if ( cli -> cl_checksum && ! sptlrpc_flavor_has_bulk ( & req -> rq_flvr ) ) { if ( ( body -> oa . o_valid & OBD_MD_FLFLAGS ) == 0 ) { body -> oa . o_flags = 0 ; } body -> oa . o_flags |= cksum_type_pack ( cli -> cl_cksum_type ) ; body -> oa . o_valid |= OBD_MD_FLCKSUM | OBD_MD_FLFLAGS ; } } ptlrpc_request_set_replen ( req ) ; BUILD_BUG_ON ( sizeof ( * aa ) > sizeof ( req -> rq_async_args ) ) ; aa = ptlrpc_req_async_args ( req ) ; aa -> aa_oa = oa ; aa -> aa_requested_nob = requested_nob ; aa -> aa_nio_count = niocount ; aa -> aa_page_count = page_count ; aa -> aa_resends = 0 ; aa -> aa_ppga = pga ; aa -> aa_cli = cli ; INIT_LIST_HEAD ( & aa -> aa_oaps ) ; * reqp = req ; niobuf = req_capsule_client_get ( pill , & RMF_NIOBUF_REMOTE ) ; CDEBUG ( D_RPCTRACE , "brw rpc %p - object " DOSTID " offset %lld<>%lld\n" , req , POSTID ( & oa -> o_oi ) , niobuf [ 0 ] . rnb_offset , niobuf [ niocount - 1 ] . rnb_offset + niobuf [ niocount - 1 ] . rnb_len ) ; return 0 ; out ptlrpc_req_finished ( req ) ; return rc ; } 