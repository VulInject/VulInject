int ssl_stapling_init_cert ( server_rec * s , apr_pool_t * p , apr_pool_t * ptemp , modssl_ctx_t * mctx , X509 * x ) { UCHAR idx [ SHA_DIGEST_LENGTH ] ; certinfo * cinf = NULL ; X509 * issuer = NULL ; OCSP_CERTID * cid = NULL ; STACK_OF ( OPENSSL_STRING ) * aia = NULL ; const char * pem = NULL ; int rv = 1 ; if ( ! ( issuer = stapling_get_issuer ( mctx , x ) ) ) { if ( mctx -> stapling_enabled == TRUE ) { ssl_log_xerror ( SSLLOG_MARK , APLOG_ERR , 0 , ptemp , s , x , APLOGNO ( 02217 ) "ssl_stapling_init_cert: can't retrieve issuer " "certificate!" ) ; return 0 ; } return 1 ; } if ( X509_digest ( x , EVP_sha1 ( ) , idx , NULL ) != 1 ) { rv = 0 ; cleanup } if ( modssl_cert_get_pem ( ptemp , x , issuer , & pem ) != APR_SUCCESS ) { rv = 0 ; cleanup } if ( ap_ssl_ocsp_prime ( s , p , ( const char * ) idx , sizeof ( idx ) , pem ) == APR_SUCCESS || ssl_run_init_stapling_status ( s , p , x , issuer ) == OK ) { if ( mctx -> stapling_enabled != TRUE ) { SSL_CTX_set_tlsext_status_cb ( mctx -> ssl_ctx , stapling_cb ) ; ap_log_error ( APLOG_MARK , APLOG_DEBUG , 0 , s , APLOGNO ( 10177 ) "OCSP stapling added via hook" ) ; } cleanup } if ( mctx -> stapling_enabled != TRUE ) { cleanup } cinf = apr_hash_get ( stapling_certinfo , idx , sizeof ( idx ) ) ; if ( cinf ) { if ( ! cinf -> uri && ! mctx -> stapling_force_url ) { ssl_log_xerror ( SSLLOG_MARK , APLOG_ERR , 0 , ptemp , s , x , APLOGNO ( 02814 ) "ssl_stapling_init_cert: no OCSP URI " "in certificate and no SSLStaplingForceURL " "configured for server %s" , mctx -> sc -> vhost_id ) ; rv = 0 ; } cleanup } cid = OCSP_cert_to_id ( NULL , x , issuer ) ; if ( ! cid ) { ssl_log_xerror ( SSLLOG_MARK , APLOG_ERR , 0 , ptemp , s , x , APLOGNO ( 02815 ) "ssl_stapling_init_cert: can't create CertID " "for OCSP request" ) ; rv = 0 ; cleanup } aia = X509_get1_ocsp ( x ) ; if ( ! aia && ! mctx -> stapling_force_url ) { OCSP_CERTID_free ( cid ) ; ssl_log_xerror ( SSLLOG_MARK , APLOG_ERR , 0 , ptemp , s , x , APLOGNO ( 02218 ) "ssl_stapling_init_cert: no OCSP URI " "in certificate and no SSLStaplingForceURL set" ) ; rv = 0 ; cleanup } cinf = apr_pcalloc ( p , sizeof ( certinfo ) ) ; memcpy ( cinf -> idx , idx , sizeof ( idx ) ) ; cinf -> cid = cid ; apr_pool_cleanup_register ( p , cid , ssl_stapling_certid_free , apr_pool_cleanup_null ) ; if ( aia ) { cinf -> uri = apr_pstrdup ( p , sk_OPENSSL_STRING_value ( aia , 0 ) ) ; X509_email_free ( aia ) ; } ssl_log_xerror ( SSLLOG_MARK , APLOG_TRACE1 , 0 , ptemp , s , x , "ssl_stapling_init_cert: storing certinfo for server %s" , mctx -> sc -> vhost_id ) ; apr_hash_set ( stapling_certinfo , cinf -> idx , sizeof ( cinf -> idx ) , cinf ) ; cleanup X509_free ( issuer ) ; return rv ; } 