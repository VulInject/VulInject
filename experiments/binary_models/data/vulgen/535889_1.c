static void print_mesg ( FILE * tf , CTL_MSG * request , char * remote_machine ) { struct timeval clock ; struct tm * localclock ; char line_buf [ N_LINES ] [ N_CHARS ] ; int sizes [ N_LINES ] ; char * bptr , * lptr ; int i , j , max_size ; char big_buf [ 3 + ( N_LINES * ( N_CHARS - 1 ) ) + ( N_LINES * 2 ) + 1 ] ; char l_username [ ( ( NAME_SIZE - 1 ) * 4 ) + 1 ] ; int len , k ; i = 0 ; max_size = 0 ; ( void ) gettimeofday ( & clock , NULL ) ; localclock = localtime ( & clock . tv_sec ) ; ( void ) sprintf ( line_buf [ i ] , " " ) ; sizes [ i ] = strlen ( line_buf [ i ] ) ; max_size = max ( max_size , sizes [ i ] ) ; i ++ ; ( void ) snprintf ( line_buf [ i ] , N_CHARS , "Message from Talk_Daemon@%s at %d:%02d ..." , hostname , localclock -> tm_hour , localclock -> tm_min ) ; sizes [ i ] = strlen ( line_buf [ i ] ) ; max_size = max ( max_size , sizes [ i ] ) ; i ++ ; len = ( strlen ( request -> l_name ) > NAME_SIZE - 1 ) ?( NAME_SIZE - 1 ) : strlen ( request -> l_name ) ; for ( j = 0 , k = 0 ; j < len ; j ++ ) { if ( ! isprint ( ( unsigned char ) request -> l_name [ j ] ) ) { char c ; if ( ! isascii ( ( unsigned char ) request -> l_name [ j ] ) ) { l_username [ k ++ ] = 'M' ; l_username [ k ++ ] = '-' ; c = toascii ( request -> l_name [ j ] ) ; } l_username [ k ++ ] = c ; } else { l_username [ k ++ ] = request -> l_name [ j ] ; } } l_username [ k ] = '\0' ; ( void ) snprintf ( line_buf [ i ] , N_CHARS , "talk: connection requested by %s@%s." , l_username , remote_machine ) ; sizes [ i ] = strlen ( line_buf [ i ] ) ; max_size = max ( max_size , sizes [ i ] ) ; i ++ ; ( void ) snprintf ( line_buf [ i ] , N_CHARS , "talk: respond with:  talk %s@%s" , l_username , remote_machine ) ; sizes [ i ] = strlen ( line_buf [ i ] ) ; max_size = max ( max_size , sizes [ i ] ) ; i ++ ; ( void ) sprintf ( line_buf [ i ] , " " ) ; sizes [ i ] = strlen ( line_buf [ i ] ) ; max_size = max ( max_size , sizes [ i ] ) ; i ++ ; bptr = big_buf ; * ( bptr ++ ) = '\a' ; * ( bptr ++ ) = '\r' ; * ( bptr ++ ) = '\n' ; for ( i = 0 ; i < N_LINES ; i ++ ) { lptr = line_buf [ i ] ; while ( * lptr != '\0' ) { * ( bptr ++ ) = * ( lptr ++ ) ; } for ( j = sizes [ i ] ; j < max_size ; j ++ ) { * ( bptr ++ ) = ' ' ; } * ( bptr ++ ) = '\r' ; * ( bptr ++ ) = '\n' ; } * bptr = '\0' ; ( void ) fputs ( big_buf , tf ) ; ( void ) fflush ( tf ) ; ( void ) setsid ( ) ; } 