static int tda998x_create ( struct i2c_client * client , struct tda998x_priv * priv ) { struct device_node * np = client -> dev . of_node ; u32 video ; int rev_lo , rev_hi , ret ; priv -> vip_cntrl_0 = VIP_CNTRL_0_SWAP_A ( 2 ) | VIP_CNTRL_0_SWAP_B ( 3 ) ; priv -> vip_cntrl_1 = VIP_CNTRL_1_SWAP_C ( 0 ) | VIP_CNTRL_1_SWAP_D ( 1 ) ; priv -> vip_cntrl_2 = VIP_CNTRL_2_SWAP_E ( 4 ) | VIP_CNTRL_2_SWAP_F ( 5 ) ; priv -> cec_addr = 0x34 + ( client -> addr & 0x03 ) ; priv -> current_page = 0xff ; priv -> hdmi = client ; priv -> cec = i2c_new_dummy ( client -> adapter , priv -> cec_addr ) ; if ( ! priv -> cec ) { return - ENODEV ; } mutex_init ( & priv -> mutex ) ; init_waitqueue_head ( & priv -> edid_delay_waitq ) ; setup_timer ( & priv -> edid_delay_timer , tda998x_edid_delay_done , ( unsigned long ) priv ) ; INIT_WORK ( & priv -> detect_work , tda998x_detect_work ) ; cec_write ( priv , REG_CEC_ENAMODS , CEC_ENAMODS_EN_RXSENS | CEC_ENAMODS_EN_HDMI ) ; tda998x_reset ( priv ) ; rev_lo = reg_read ( priv , REG_VERSION_LSB ) ; rev_hi = reg_read ( priv , REG_VERSION_MSB ) ; if ( rev_lo < 0 || rev_hi < 0 ) { ret = rev_lo < 0 ?rev_lo : rev_hi ; fail } priv -> rev = rev_lo | rev_hi << 8 ; priv -> rev &= ~ 0x30 ; switch ( priv -> rev ) { case TDA9989N2 : dev_info ( & client -> dev , "found TDA9989 n2" ) ; break ; case TDA19989 : dev_info ( & client -> dev , "found TDA19989" ) ; break ; case TDA19989N2 : dev_info ( & client -> dev , "found TDA19989 n2" ) ; break ; case TDA19988 : dev_info ( & client -> dev , "found TDA19988" ) ; break ; default : dev_err ( & client -> dev , "found unsupported device: %04x\n" , priv -> rev ) ; fail } reg_write ( priv , REG_DDC_DISABLE , 0x00 ) ; reg_write ( priv , REG_TX3 , 39 ) ; if ( priv -> rev == TDA19989 ) { reg_set ( priv , REG_I2C_MASTER , I2C_MASTER_DIS_MM ) ; } cec_write ( priv , REG_CEC_FRO_IM_CLK_CTRL , CEC_FRO_IM_CLK_CTRL_GHOST_DIS | CEC_FRO_IM_CLK_CTRL_IMCLK_SEL ) ; if ( client -> irq ) { unsigned long irq_flags ; init_waitqueue_head ( & priv -> wq_edid ) ; reg_read ( priv , REG_INT_FLAGS_0 ) ; reg_read ( priv , REG_INT_FLAGS_1 ) ; reg_read ( priv , REG_INT_FLAGS_2 ) ; irq_flags = irqd_get_trigger_type ( irq_get_irq_data ( client -> irq ) ) ; irq_flags |= IRQF_SHARED | IRQF_ONESHOT ; ret = request_threaded_irq ( client -> irq , NULL , tda998x_irq_thread , irq_flags , "tda998x" , priv ) ; if ( ret ) { dev_err ( & client -> dev , "failed to request IRQ#%u: %d\n" , client -> irq , ret ) ; fail } cec_write ( priv , REG_CEC_RXSHPDINTENA , CEC_RXSHPDLEV_HPD ) ; } reg_set ( priv , REG_INT_FLAGS_2 , INT_FLAGS_2_EDID_BLK_RD ) ; if ( ! np ) { return 0 ; } ret = of_property_read_u32 ( np , "video-ports" , & video ) ; if ( ret == 0 ) { priv -> vip_cntrl_0 = video >> 16 ; priv -> vip_cntrl_1 = video >> 8 ; priv -> vip_cntrl_2 = video ; } ret = tda998x_get_audio_ports ( priv , np ) ; if ( ret ) { fail } if ( priv -> audio_port [ 0 ] . format != AFMT_UNUSED ) { tda998x_audio_codec_init ( priv , & client -> dev ) ; } return 0 ; fail if ( priv -> cec ) { i2c_unregister_device ( priv -> cec ) ; } return - ENXIO ; } 