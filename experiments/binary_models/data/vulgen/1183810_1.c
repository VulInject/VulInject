static int ips_conf_to_pfpol_msg ( int ipsec_cmd , ips_conf_t * inConf , int num_ips , struct iovec * msg ) { int i ; ips_conf_t * conf ; uint64_t * scratch = NULL ; for ( i = 0 ; i < num_ips ; i ++ ) { uint16_t * msg_len ; uint16_t act_cnt = 0 ; uint64_t * next = NULL ; spd_msg_t * spd_msg ; spd_address_t * spd_address ; struct spd_rule * spd_rule ; struct spd_proto * spd_proto ; struct spd_portrange * spd_portrange ; struct spd_ext_actions * spd_ext_actions ; struct spd_attribute * ap ; struct spd_typecode * spd_typecode ; spd_if_t * spd_if ; ips_act_props_t * act_ptr ; uint32_t rule_priority = 0 ; scratch = calloc ( 1 , MAX_POL_MSG_LEN ) ; msg [ i ] . iov_base = ( char * ) scratch ; if ( scratch == NULL ) { warn ( gettext ( "memory" ) ) ; return ( 1 ) ; } conf = & ( inConf [ i ] ) ; spd_msg = ( spd_msg_t * ) scratch ; next = ( uint64_t * ) & ( spd_msg [ 1 ] ) ; msg_len = & ( spd_msg -> spd_msg_len ) ; spd_msg -> spd_msg_version = PF_POLICY_V1 ; spd_msg -> spd_msg_pid = getpid ( ) ; spd_msg -> spd_msg_seq = ++ seq_cnt ; switch ( ipsec_cmd ) { case SPD_ADDRULE : spd_msg -> spd_msg_type = SPD_ADDRULE ; break ; default : warnx ( "%s %d" , gettext ( "bad command:" ) , ipsec_cmd ) ; spd_msg -> spd_msg_type = SPD_ADDRULE ; break ; } spd_msg -> spd_msg_spdid = SPD_STANDBY ; spd_rule = ( spd_rule * ) next ; spd_rule -> spd_rule_len = SPD_8TO64 ( sizeof ( spd_rule ) ) ; spd_rule -> spd_rule_type = SPD_EXT_RULE ; spd_rule -> spd_rule_flags = conf -> ips_dir ; if ( conf -> ips_tunnel ) { spd_rule -> spd_rule_flags |= SPD_RULE_FLAG_TUNNEL ; } next = ( uint64_t * ) & ( spd_rule [ 1 ] ) ; if ( conf -> ips_ulp_prot != 0 ) { spd_proto = ( spd_proto * ) next ; spd_proto -> spd_proto_len = SPD_8TO64 ( sizeof ( spd_proto ) ) ; spd_proto -> spd_proto_exttype = SPD_EXT_PROTO ; spd_proto -> spd_proto_number = conf -> ips_ulp_prot ; next = ( uint64_t * ) & ( spd_proto [ 1 ] ) ; } if ( conf -> ips_ulp_prot == IPPROTO_ICMP || conf -> ips_ulp_prot == IPPROTO_ICMPV6 ) { if ( conf -> has_type ) { spd_typecode = ( spd_typecode * ) next ; spd_typecode -> spd_typecode_len = SPD_8TO64 ( sizeof ( spd_typecode ) ) ; spd_typecode -> spd_typecode_exttype = SPD_EXT_ICMP_TYPECODE ; spd_typecode -> spd_typecode_type = conf -> ips_icmp_type ; spd_typecode -> spd_typecode_type_end = conf -> ips_icmp_type_end ; if ( conf -> has_code ) { spd_typecode -> spd_typecode_code = conf -> ips_icmp_code ; spd_typecode -> spd_typecode_code_end = conf -> ips_icmp_code_end ; } else { spd_typecode -> spd_typecode_code = 255 ; spd_typecode -> spd_typecode_code_end = 255 ; } next = ( uint64_t * ) & ( spd_typecode [ 1 ] ) ; } } if ( conf -> ips_src_port_min != 0 || conf -> ips_src_port_max != 0 ) { spd_portrange = ( spd_portrange * ) next ; spd_portrange -> spd_ports_len = SPD_8TO64 ( sizeof ( spd_portrange ) ) ; spd_portrange -> spd_ports_exttype = ( conf -> swap ) ?SPD_EXT_REMPORT : SPD_EXT_LCLPORT ; spd_portrange -> spd_ports_minport = conf -> ips_src_port_min ; spd_portrange -> spd_ports_maxport = conf -> ips_src_port_max ; next = ( uint64_t * ) & ( spd_portrange [ 1 ] ) ; } if ( conf -> ips_dst_port_min != 0 || conf -> ips_dst_port_max != 0 ) { spd_portrange = ( spd_portrange * ) next ; spd_portrange -> spd_ports_len = SPD_8TO64 ( sizeof ( spd_portrange ) ) ; spd_portrange -> spd_ports_exttype = ( conf -> swap ) ?SPD_EXT_LCLPORT : SPD_EXT_REMPORT ; spd_portrange -> spd_ports_minport = conf -> ips_dst_port_min ; spd_portrange -> spd_ports_maxport = conf -> ips_dst_port_max ; next = ( uint64_t * ) & ( spd_portrange [ 1 ] ) ; } if ( conf -> has_saddr ) { spd_address = ( spd_address_t * ) next ; next = ( uint64_t * ) ( spd_address + 1 ) ; spd_address -> spd_address_exttype = ( conf -> swap ) ?SPD_EXT_REMADDR : SPD_EXT_LCLADDR ; spd_address -> spd_address_prefixlen = conf -> ips_src_mask_len ; if ( conf -> ips_isv4 ) { spd_address -> spd_address_af = AF_INET ; ( void ) memcpy ( next , & ( conf -> ips_src_addr ) , sizeof ( ipaddr_t ) ) ; spd_address -> spd_address_len = 2 ; next += SPD_8TO64 ( sizeof ( ipaddr_t ) + 4 ) ; if ( ! conf -> has_smask ) { spd_address -> spd_address_prefixlen = 32 ; } } else { spd_address -> spd_address_af = AF_INET6 ; ( void ) memcpy ( next , & ( conf -> ips_src_addr_v6 ) , sizeof ( in6_addr_t ) ) ; spd_address -> spd_address_len = 3 ; next += SPD_8TO64 ( sizeof ( in6_addr_t ) ) ; if ( ! conf -> has_smask ) { spd_address -> spd_address_prefixlen = 128 ; } } } if ( conf -> has_daddr ) { spd_address = ( spd_address_t * ) next ; next = ( uint64_t * ) ( spd_address + 1 ) ; spd_address -> spd_address_exttype = ( conf -> swap ) ?SPD_EXT_LCLADDR : SPD_EXT_REMADDR ; spd_address -> spd_address_prefixlen = conf -> ips_dst_mask_len ; if ( conf -> ips_isv4 ) { spd_address -> spd_address_af = AF_INET ; ( void ) memcpy ( next , & conf -> ips_dst_addr , sizeof ( ipaddr_t ) ) ; spd_address -> spd_address_len = 2 ; next += SPD_8TO64 ( sizeof ( ipaddr_t ) + 4 ) ; if ( ! conf -> has_dmask ) { spd_address -> spd_address_prefixlen = 32 ; } } else { spd_address -> spd_address_af = AF_INET6 ; ( void ) memcpy ( next , & ( conf -> ips_dst_addr_v6 ) , sizeof ( in6_addr_t ) ) ; spd_address -> spd_address_len = 3 ; next += SPD_8TO64 ( sizeof ( in6_addr_t ) ) ; if ( ! conf -> has_dmask ) { spd_address -> spd_address_prefixlen = 128 ; } } } spd_ext_actions = ( spd_ext_actions * ) next ; spd_ext_actions -> spd_actions_exttype = SPD_EXT_ACTION ; act_ptr = conf -> ips_acts ; ap = ( spd_attribute * ) ( & spd_ext_actions [ 1 ] ) ; rule_priority = priority -- ; for ( act_ptr = conf -> ips_acts ; act_ptr != NULL ; act_ptr = act_ptr -> iap_next ) { ap = ips_act_wild_props_to_action ( ap , & rule_priority , & act_cnt , act_ptr ) ; } ap [ - 1 ] . spd_attr_tag = SPD_ATTR_END ; next = ( uint64_t * ) ap ; spd_rule -> spd_rule_priority = rule_priority ; msg [ i ] . iov_len = ( uintptr_t ) next - ( uintptr_t ) msg [ i ] . iov_base ; * msg_len = ( uint16_t ) SPD_8TO64 ( msg [ i ] . iov_len ) ; spd_ext_actions -> spd_actions_count = act_cnt ; spd_ext_actions -> spd_actions_len = SPD_8TO64 ( ( uintptr_t ) next - ( uintptr_t ) spd_ext_actions ) ; printf ( "pfpol msg len in uint64_t's = %d\n" , * msg_len ) ; printf ( "pfpol test_len in bytes = %d\n" , msg [ i ] . iov_len ) ; pfpol_msg_dump ( ( spd_msg_t * ) scratch , "ips_conf_to_pfpol_msg" ) ; } return ( 0 ) ; } 