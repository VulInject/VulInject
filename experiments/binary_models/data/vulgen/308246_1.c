ipa_utils_reduced_inorder ( , , ) { struct cgraph_node * node ; struct searchc_env env ; splay_tree_node result ; env . stack = XCNEWVEC ( cgraph_node * , cgraph_n_nodes ) ; env . stack_size = 0 ; env . result = order ; env . order_pos = 0 ; env . nodes_marked_new = splay_tree_new ( splay_tree_compare_ints , 0 , 0 ) ; env . count = 1 ; env . reduce = reduce ; for ( node = cgraph_nodes ; node ; node = node -> next ) { if ( ( node -> analyzed ) && ( cgraph_is_master_clone ( node ) || ( allow_overwritable && ( cgraph_function_body_availability ( node ) == AVAIL_OVERWRITABLE ) ) ) ) { struct ipa_dfs_info * info = node -> aux ; info -> new = true ; info -> on_stack = false ; info -> next_cycle = NULL ; node -> aux = info ; splay_tree_insert ( env . nodes_marked_new , ( splay_tree_key ) node -> uid , ( splay_tree_value ) node ) ; } else { node -> aux = NULL ; } } result = splay_tree_min ( env . nodes_marked_new ) ; while ( result ) { node = ( cgraph_node * ) result -> value ; searchc ( & env , node ) ; result = splay_tree_min ( env . nodes_marked_new ) ; } splay_tree_delete ( env . nodes_marked_new ) ; free ( env . stack ) ; return env . order_pos ; } 