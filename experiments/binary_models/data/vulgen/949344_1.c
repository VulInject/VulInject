static void br_multicast_leave_group ( struct net_bridge_mcast * brmctx , struct net_bridge_mcast_port * pmctx , struct br_ip * group , struct bridge_mcast_other_query * other_query , struct bridge_mcast_own_query * own_query , const unsigned char * src ) { struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; unsigned long now ; unsigned long time ; spin_lock ( & brmctx -> br -> multicast_lock ) ; if ( ! br_multicast_ctx_should_use ( brmctx , pmctx ) ) { out } mp = br_mdb_ip_get ( brmctx -> br , group ) ; if ( ! mp ) { out } if ( pmctx && ( pmctx -> port -> flags & BR_MULTICAST_FAST_LEAVE ) ) { struct net_bridge_port_group __rcu * * pp ; for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , brmctx -> br ) ) != NULL ; pp = & p -> next ) { if ( ! br_port_group_equal ( p , pmctx -> port , src ) ) { continue ; } if ( p -> flags & MDB_PG_FLAGS_PERMANENT ) { break ; } p -> flags |= MDB_PG_FLAGS_FAST_LEAVE ; br_multicast_del_pg ( mp , p , pp ) ; } out } if ( timer_pending ( & other_query -> timer ) ) { out } if ( brmctx -> multicast_querier ) { __br_multicast_send_query ( brmctx , pmctx , NULL , NULL , & mp -> addr , false , 0 , NULL ) ; time = jiffies + brmctx -> multicast_last_member_count * brmctx -> multicast_last_member_interval ; mod_timer ( & own_query -> timer , time ) ; for ( p = mlock_dereference ( mp -> ports , brmctx -> br ) ; p != NULL && pmctx != NULL ; p = mlock_dereference ( p -> next , brmctx -> br ) ) { if ( ! br_port_group_equal ( p , pmctx -> port , src ) ) { continue ; } if ( ! hlist_unhashed ( & p -> mglist ) && ( timer_pending ( & p -> timer ) ?time_after ( p -> timer . expires , time ) : try_to_del_timer_sync ( & p -> timer ) >= 0 ) ) { mod_timer ( & p -> timer , time ) ; } break ; } } now = jiffies ; time = now + brmctx -> multicast_last_member_count * brmctx -> multicast_last_member_interval ; if ( ! pmctx ) { if ( mp -> host_joined && ( timer_pending ( & mp -> timer ) ?time_after ( mp -> timer . expires , time ) : try_to_del_timer_sync ( & mp -> timer ) >= 0 ) ) { mod_timer ( & mp -> timer , time ) ; } out } for ( p = mlock_dereference ( mp -> ports , brmctx -> br ) ; p != NULL ; p = mlock_dereference ( p -> next , brmctx -> br ) ) { if ( ! hlist_unhashed ( & p -> mglist ) && ( timer_pending ( & p -> timer ) ?time_after ( p -> timer . expires , time ) : try_to_del_timer_sync ( & p -> timer ) >= 0 ) ) { mod_timer ( & p -> timer , time ) ; } break ; } out spin_unlock ( & brmctx -> br -> multicast_lock ) ; } 