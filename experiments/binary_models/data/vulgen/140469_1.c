static void writepages_finish ( struct ceph_osd_request * req ) { struct inode * inode = req -> r_inode ; struct ceph_inode_info * ci = ceph_inode ( inode ) ; struct ceph_osd_data * osd_data ; struct page * page ; int num_pages , total_pages = 0 ; int i , j ; int rc = req -> r_result ; struct ceph_snap_context * snapc = req -> r_snapc ; struct address_space * mapping = inode -> i_mapping ; struct ceph_fs_client * fsc = ceph_inode_to_client ( inode ) ; bool remove_page ; dout ( "writepages_finish %p rc %d\n" , inode , rc ) ; if ( rc < 0 ) { mapping_set_error ( mapping , rc ) ; ceph_set_error_write ( ci ) ; } else { ceph_clear_error_write ( ci ) ; } remove_page = ! ( ceph_caps_issued ( ci ) & ( CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO ) ) ; for ( i = 0 ; i < req -> r_num_ops ; i ++ ) { if ( req -> r_ops [ i ] . op != CEPH_OSD_OP_WRITE ) { break ; } osd_data = osd_req_op_extent_osd_data ( req , i ) ; BUG_ON ( osd_data -> type != CEPH_OSD_DATA_TYPE_PAGES ) ; num_pages = calc_pages_for ( ( u64 ) osd_data -> alignment , ( u64 ) osd_data -> length ) ; total_pages += num_pages ; for ( j = 0 ; j < num_pages ; j ++ ) { page = osd_data -> pages [ j ] ; BUG_ON ( ! page ) ; WARN_ON ( ! PageUptodate ( page ) ) ; if ( atomic_long_dec_return ( & fsc -> writeback_count ) < CONGESTION_OFF_THRESH ( fsc -> mount_options -> congestion_kb ) ) { clear_bdi_congested ( inode_to_bdi ( inode ) , BLK_RW_ASYNC ) ; } ceph_put_snap_context ( page_snap_context ( page ) ) ; page -> private = 0 ; ClearPagePrivate ( page ) ; dout ( "unlocking %p\n" , page ) ; end_page_writeback ( page ) ; unlock_page ( page ) ; } dout ( "writepages_finish %p wrote %llu bytes cleaned %d pages\n" , inode , osd_data -> length , rc >= 0 ?num_pages : 0 ) ; ceph_release_pages ( osd_data -> pages , num_pages ) ; } ceph_put_wrbuffer_cap_refs ( ci , total_pages , snapc ) ; osd_data = osd_req_op_extent_osd_data ( req , 0 ) ; if ( osd_data -> pages_from_pool ) { mempool_free ( osd_data -> pages , ceph_sb_to_client ( inode -> i_sb ) -> wb_pagevec_pool ) ; } else { kfree ( osd_data -> pages ) ; } ceph_osdc_put_request ( req ) ; } 