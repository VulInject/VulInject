static int pppuwput ( q , mp ) queue_t * q ; mblk_t * mp ; { upperstr_t * us , * ppa , * nps ; struct iocblk * iop ; struct linkblk * lb ; struct ifreq * ifr ; int i ; queue_t * lq ; int error , n , sap ; mblk_t * mq ; struct ppp_idle * pip ; queue_t * tlq ; upperstr_t * os ; us = ( upperstr_t * ) q -> q_ptr ; if ( us == 0 ) { DPRINT ( "pppuwput: q_ptr = 0!\n" ) ; return 0 ; } if ( mp == 0 ) { DPRINT1 ( "pppuwput/%d: mp = 0!\n" , us -> mn ) ; return 0 ; } if ( mp -> b_datap == 0 ) { DPRINT1 ( "pppuwput/%d: mp->b_datap = 0!\n" , us -> mn ) ; return 0 ; } switch ( mp -> b_datap -> db_type ) { case M_PCPROTO : case M_PROTO : dlpi_request ( q , mp , us ) ; break ; case M_DATA : if ( us -> flags & US_DBGLOG ) { DPRINT3 ( "ppp/%d: uwput M_DATA len=%d flags=%x\n" , us -> mn , msgdsize ( mp ) , us -> flags ) ; } if ( us -> ppa == 0 || msgdsize ( mp ) > us -> ppa -> mtu + PPP_HDRLEN || ( us -> flags & US_CONTROL ) == 0 ) { DPRINT1 ( "pppuwput: junk data len=%d\n" , msgdsize ( mp ) ) ; break ; } if ( ( us -> flags & US_CONTROL ) == 0 && ! pass_packet ( us , mp , 1 ) ) { break ; } if ( ! send_data ( mp , us ) ) { putq ( q , mp ) ; } break ; case M_IOCTL : iop = ( iocblk * ) mp -> b_rptr ; error = EINVAL ; if ( us -> flags & US_DBGLOG ) { DPRINT3 ( "ppp/%d: ioctl %x count=%d\n" , us -> mn , iop -> ioc_cmd , iop -> ioc_count ) ; } switch ( iop -> ioc_cmd ) { case DLIOCRAW : us -> flags |= US_RAWDATA ; error = 0 ; break ; case I_LINK : if ( ( us -> flags & US_CONTROL ) == 0 || us -> lowerq != 0 ) { break ; } if ( mp -> b_cont == 0 ) { DPRINT1 ( "pppuwput/%d: ioctl I_LINK b_cont = 0!\n" , us -> mn ) ; break ; } lb = ( linkblk * ) mp -> b_cont -> b_rptr ; lq = lb -> l_qbot ; if ( lq == 0 ) { DPRINT1 ( "pppuwput/%d: ioctl I_LINK l_qbot = 0!\n" , us -> mn ) ; break ; } LOCK_LOWER_W ; us -> lowerq = lq ; lq -> q_ptr = ( caddr_t ) q ; RD ( lq ) -> q_ptr = ( caddr_t ) us -> q ; UNLOCK_LOWER ; iop -> ioc_count = 0 ; error = 0 ; us -> flags &= ~ US_LASTMOD ; qenable ( q ) ; putctl2 ( lq , M_CTL , PPPCTL_UNIT , us -> ppa_id ) ; putctl4 ( lq , M_CTL , PPPCTL_MRU , us -> mru ) ; putctl4 ( lq , M_CTL , PPPCTL_MTU , us -> mtu ) ; freezestr ( lq ) ; for ( tlq = lq ; tlq -> q_next != NULL ; tlq = tlq -> q_next ) { } strqset ( tlq , QHIWAT , 0 , 256 ) ; strqset ( tlq , QLOWAT , 0 , 128 ) ; unfreezestr ( lq ) ; break ; case I_UNLINK : if ( mp -> b_cont == 0 ) { DPRINT1 ( "pppuwput/%d: ioctl I_UNLINK b_cont = 0!\n" , us -> mn ) ; break ; } lb = ( linkblk * ) mp -> b_cont -> b_rptr ; if ( us -> lowerq != lb -> l_qbot ) { DPRINT2 ( "ppp unlink: lowerq=%x qbot=%x\n" , us -> lowerq , lb -> l_qbot ) ; break ; } iop -> ioc_count = 0 ; qwriter ( q , mp , detach_lower , PERIM_OUTER ) ; error = - 1 ; break ; case PPPIO_NEWPPA : if ( us -> flags & US_CONTROL ) { break ; } if ( ( us -> flags & US_PRIV ) == 0 ) { error = EPERM ; break ; } if ( ( mq = mp -> b_cont ) == 0 || mq -> b_datap -> db_lim - mq -> b_rptr < sizeof ( int ) ) { mq = allocb ( sizeof ( int ) , BPRI_HI ) ; if ( mq == 0 ) { error = ENOSR ; break ; } if ( mp -> b_cont != 0 ) { freemsg ( mp -> b_cont ) ; } mp -> b_cont = mq ; mq -> b_cont = 0 ; } iop -> ioc_count = sizeof ( int ) ; mq -> b_wptr = mq -> b_rptr + sizeof ( int ) ; qwriter ( q , mp , new_ppa , PERIM_OUTER ) ; error = - 1 ; break ; case PPPIO_ATTACH : if ( iop -> ioc_count != sizeof ( int ) || us -> ppa != 0 ) { break ; } if ( mp -> b_cont == 0 ) { DPRINT1 ( "pppuwput/%d: ioctl PPPIO_ATTACH b_cont = 0!\n" , us -> mn ) ; break ; } n = * ( int * ) mp -> b_cont -> b_rptr ; for ( ppa = ppas ; ppa != 0 ; ppa = ppa -> nextppa ) { if ( ppa -> ppa_id == n ) { break ; } } if ( ppa == 0 ) { break ; } us -> ppa = ppa ; iop -> ioc_count = 0 ; qwriter ( q , mp , attach_ppa , PERIM_OUTER ) ; error = - 1 ; break ; case PPPIO_BIND : if ( iop -> ioc_count != sizeof ( int ) || us -> ppa == 0 ) { break ; } if ( mp -> b_cont == 0 ) { DPRINT1 ( "pppuwput/%d: ioctl PPPIO_BIND b_cont = 0!\n" , us -> mn ) ; break ; } n = * ( int * ) mp -> b_cont -> b_rptr ; if ( n ( 0x21 || n ) 0x3fff || ( n & 0x101 ) != 1 ) { break ; } for ( os = us -> ppa ; os != 0 ; os = os -> next ) { if ( os -> sap == n ) { break ; } } if ( os != 0 ) { break ; } us -> sap = n ; iop -> ioc_count = 0 ; error = 0 ; break ; case PPPIO_MRU : if ( iop -> ioc_count != sizeof ( int ) || ( us -> flags & US_CONTROL ) == 0 ) { break ; } if ( mp -> b_cont == 0 ) { DPRINT1 ( "pppuwput/%d: ioctl PPPIO_MRU b_cont = 0!\n" , us -> mn ) ; break ; } n = * ( int * ) mp -> b_cont -> b_rptr ; if ( n <= 0 || n > PPP_MAXMRU ) { break ; } if ( n < PPP_MRU ) { n = PPP_MRU ; } us -> mru = n ; if ( us -> lowerq ) { putctl4 ( us -> lowerq , M_CTL , PPPCTL_MRU , n ) ; } error = 0 ; iop -> ioc_count = 0 ; break ; case PPPIO_MTU : if ( iop -> ioc_count != sizeof ( int ) || ( us -> flags & US_CONTROL ) == 0 ) { break ; } if ( mp -> b_cont == 0 ) { DPRINT1 ( "pppuwput/%d: ioctl PPPIO_MTU b_cont = 0!\n" , us -> mn ) ; break ; } n = * ( int * ) mp -> b_cont -> b_rptr ; if ( n <= 0 || n > PPP_MAXMTU ) { break ; } us -> mtu = n ; us -> ifstats . ifs_mtu = n ; if ( us -> lowerq ) { putctl4 ( us -> lowerq , M_CTL , PPPCTL_MTU , n ) ; } error = 0 ; iop -> ioc_count = 0 ; break ; case PPPIO_LASTMOD : us -> flags |= US_LASTMOD ; error = 0 ; break ; case PPPIO_DEBUG : if ( iop -> ioc_count != sizeof ( int ) ) { break ; } if ( mp -> b_cont == 0 ) { DPRINT1 ( "pppuwput/%d: ioctl PPPIO_DEBUG b_cont = 0!\n" , us -> mn ) ; break ; } n = * ( int * ) mp -> b_cont -> b_rptr ; if ( n == PPPDBG_DUMP + PPPDBG_DRIVER ) { qwriter ( q , NULL , debug_dump , PERIM_OUTER ) ; iop -> ioc_count = 0 ; error = - 1 ; } if ( n == PPPDBG_LOG + PPPDBG_DRIVER ) { DPRINT1 ( "ppp/%d: debug log enabled\n" , us -> mn ) ; us -> flags |= US_DBGLOG ; iop -> ioc_count = 0 ; error = 0 ; } else { if ( us -> ppa == 0 || us -> ppa -> lowerq == 0 ) { break ; } putnext ( us -> ppa -> lowerq , mp ) ; error = - 1 ; } break ; case PPPIO_NPMODE : if ( iop -> ioc_count != 2 * sizeof ( int ) ) { break ; } if ( ( us -> flags & US_CONTROL ) == 0 ) { break ; } if ( mp -> b_cont == 0 ) { DPRINT1 ( "pppuwput/%d: ioctl PPPIO_NPMODE b_cont = 0!\n" , us -> mn ) ; break ; } sap = ( ( int * ) mp -> b_cont -> b_rptr ) [ 0 ] ; for ( nps = us -> next ; nps != 0 ; nps = nps -> next ) { if ( us -> flags & US_DBGLOG ) { DPRINT2 ( "us = 0x%x, us->next->sap = 0x%x\n" , nps , nps -> sap ) ; } if ( nps -> sap == sap ) { break ; } } if ( nps == 0 ) { if ( us -> flags & US_DBGLOG ) { DPRINT2 ( "ppp/%d: no stream for sap %x\n" , us -> mn , sap ) ; } break ; } nps -> npmode = ( NPmode ) ( ( int * ) mp -> b_cont -> b_rptr ) [ 1 ] ; if ( nps -> npmode != NPMODE_QUEUE && ( nps -> flags & US_BLOCKED ) != 0 ) { qenable ( WR ( nps -> q ) ) ; } iop -> ioc_count = 0 ; error = 0 ; break ; case PPPIO_GIDLE : if ( ( ppa = us -> ppa ) == 0 ) { break ; } mq = allocb ( sizeof ( ppp_idle ) , BPRI_HI ) ; if ( mq == 0 ) { error = ENOSR ; break ; } if ( mp -> b_cont != 0 ) { freemsg ( mp -> b_cont ) ; } mp -> b_cont = mq ; mq -> b_cont = 0 ; pip = ( ppp_idle * ) mq -> b_wptr ; pip -> xmit_idle = time - ppa -> last_sent ; pip -> recv_idle = time - ppa -> last_recv ; mq -> b_wptr += sizeof ( ppp_idle ) ; iop -> ioc_count = sizeof ( ppp_idle ) ; error = 0 ; break ; case SIOCSIFNAME : if ( iop -> ioc_count != sizeof ( ifreq ) || us -> ppa == 0 ) { break ; } ifr = ( ifreq * ) mp -> b_cont -> b_rptr ; for ( i = 0 ; i < IFNAMSIZ ; i ++ ) { if ( ifr -> ifr_name [ i ] == 0 || ( ifr -> ifr_name [ i ] >= '0' && ifr -> ifr_name [ i ] <= '9' ) ) { break ; } else { us -> ifname [ i ] = ifr -> ifr_name [ i ] ; } } us -> ifname [ i ] = 0 ; for ( n = 0 ; i < IFNAMSIZ ; i ++ ) { if ( ifr -> ifr_name [ i ] == 0 ) { break ; } else { n = n * 10 + ifr -> ifr_name [ i ] - '0' ; } } if ( us -> ppa -> ppa_id != n ) { break ; } ppa = us -> ppa ; strncpy ( ppa -> ifname , us -> ifname , IFNAMSIZ ) ; ppa -> ifstats . ifs_name = ppa -> ifname ; ppa -> ifstats . ifs_unit = n ; ppa -> ifstats . ifs_active = us -> state != DL_UNBOUND ; ppa -> ifstats . ifs_mtu = ppa -> mtu ; ppa -> ifstats . ifs_next = ifstats ; ifstats = & ppa -> ifstats ; iop -> ioc_count = 0 ; error = 0 ; break ; case SIOCGIFFLAGS : if ( ! ( us -> flags & US_CONTROL ) ) { if ( us -> ppa ) { us = us -> ppa ; } else { break ; } } ( ( iocblk_in * ) iop ) -> ioc_ifflags = us -> ifflags ; error = 0 ; break ; case SIOCSIFFLAGS : if ( ! ( us -> flags & US_CONTROL ) ) { if ( us -> ppa ) { us = us -> ppa ; } else { break ; } } us -> ifflags = ( ( iocblk_in * ) iop ) -> ioc_ifflags ; error = 0 ; break ; case SIOCSIFADDR : if ( ! ( us -> flags & US_CONTROL ) ) { if ( us -> ppa ) { us = us -> ppa ; } else { break ; } } us -> ifflags |= IFF_RUNNING ; ( ( iocblk_in * ) iop ) -> ioc_ifflags |= IFF_RUNNING ; error = 0 ; break ; case SIOCSIFMTU : if ( ( mq = allocb ( sizeof ( dl_info_req_t ) , BPRI_HI ) ) == 0 ) { break ; } ( ( DL_primitives * ) mq -> b_rptr ) -> dl_primitive = DL_INFO_REQ ; mq -> b_wptr = mq -> b_rptr + sizeof ( dl_info_req_t ) ; dlpi_request ( q , mq , us ) ; error = 0 ; break ; case SIOCGIFNETMASK : case SIOCSIFNETMASK : case SIOCGIFADDR : case SIOCGIFDSTADDR : case SIOCSIFDSTADDR : case SIOCGIFMETRIC : error = 0 ; break ; default : if ( us -> ppa == 0 || us -> ppa -> lowerq == 0 ) { break ; } us -> ioc_id = iop -> ioc_id ; error = - 1 ; switch ( iop -> ioc_cmd ) { case PPPIO_GETSTAT : case PPPIO_GETCSTAT : if ( us -> flags & US_LASTMOD ) { error = EINVAL ; break ; } putnext ( us -> ppa -> lowerq , mp ) ; break ; default : if ( us -> flags & US_PRIV ) { putnext ( us -> ppa -> lowerq , mp ) ; } else { DPRINT1 ( "ppp ioctl %x rejected\n" , iop -> ioc_cmd ) ; error = EPERM ; } break ; } break ; } if ( error > 0 ) { iop -> ioc_error = error ; mp -> b_datap -> db_type = M_IOCNAK ; qreply ( q , mp ) ; } if ( error == 0 ) { mp -> b_datap -> db_type = M_IOCACK ; qreply ( q , mp ) ; } break ; case M_FLUSH : if ( us -> flags & US_DBGLOG ) { DPRINT2 ( "ppp/%d: flush %x\n" , us -> mn , * mp -> b_rptr ) ; } if ( * mp -> b_rptr & FLUSHW ) { flushq ( q , FLUSHDATA ) ; } if ( * mp -> b_rptr & FLUSHR ) { * mp -> b_rptr &= ~ FLUSHW ; qreply ( q , mp ) ; } else { freemsg ( mp ) ; } break ; default : freemsg ( mp ) ; break ; } return 0 ; } 