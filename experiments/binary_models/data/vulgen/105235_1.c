void sig_dccget_connected ( GET_DCC_REC * dcc ) { struct stat statbuf ; char * fname , * tempfname , * str ; int ret , ret_errno , temphandle , old_umask ; if ( ! dcc -> from_dccserver ) { if ( net_geterror ( dcc -> handle ) != 0 ) { signal_emit ( "dcc error connect" , 1 , dcc ) ; dcc_destroy ( DCC ( dcc ) ) ; return ; } g_source_remove ( dcc -> tagconn ) ; dcc -> tagconn = - 1 ; } g_free_not_null ( dcc -> file ) ; dcc -> file = dcc_get_download_path ( dcc -> arg ) ; signal_emit ( "dcc get receive" , 1 , dcc ) ; if ( stat ( dcc -> file , & statbuf ) == 0 && dcc -> get_type == DCC_GET_RENAME ) { fname = dcc_get_rename_file ( dcc -> file ) ; dcc -> file = fname ; } if ( dcc -> get_type != DCC_GET_RESUME ) { int dcc_file_create_mode = octal2dec ( settings_get_int ( "dcc_file_create_mode" ) ) ; unlink ( dcc -> file ) ; tempfname = g_strconcat ( dcc -> file , ".XXXXXX" , NULL ) ; old_umask = umask ( 0077 ) ; temphandle = mkstemp ( tempfname ) ; umask ( old_umask ) ; if ( temphandle == - 1 ) { ret = - 1 ; } else { ret = fchmod ( temphandle , dcc_file_create_mode ) ; } if ( ret != - 1 ) { ret = link ( tempfname , dcc -> file ) ; if ( ret == - 1 && ( errno == EPERM || errno == ENOSYS || errno == EOPNOTSUPP ) ) { ret = rename ( tempfname , dcc -> file ) ; } } dcc -> fhandle = ret == - 1 ?- 1 : open ( dcc -> file , O_WRONLY | O_TRUNC ) ; ret_errno = errno ; close ( temphandle ) ; unlink ( tempfname ) ; g_free ( tempfname ) ; if ( dcc -> fhandle == - 1 ) { signal_emit ( "dcc error file create" , 3 , dcc , dcc -> file , g_strerror ( ret_errno ) ) ; dcc_destroy ( DCC ( dcc ) ) ; return ; } } dcc -> starttime = time ( NULL ) ; if ( dcc -> size == 0 ) { dcc_close ( DCC ( dcc ) ) ; return ; } dcc -> tagread = g_input_add ( dcc -> handle , G_INPUT_READ , ( GInputFunction ) sig_dccget_receive , dcc ) ; signal_emit ( "dcc connected" , 1 , dcc ) ; if ( dcc -> from_dccserver ) { str = g_strdup_printf ( "121 %s %d\n" , dcc -> server ?dcc -> server -> nick : "??" , 0 ) ; net_transmit ( dcc -> handle , str , strlen ( str ) ) ; } } 