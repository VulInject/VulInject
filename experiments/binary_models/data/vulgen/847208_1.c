void vpdma_add_in_dtd ( struct vpdma_desc_list * list , int width , int stride , const struct v4l2_rect * c_rect , const struct vpdma_data_format * fmt , dma_addr_t dma_addr , enum vpdma_channel chan , int field , u32 flags , int frame_width , int frame_height , int start_h , int start_v ) { int priority = 0 ; int notify = 1 ; int depth = fmt -> depth ; int channel , next_chan ; struct v4l2_rect rect = * c_rect ; struct vpdma_dtd * dtd ; channel = next_chan = chan_info [ chan ] . num ; if ( fmt -> type == VPDMA_DATA_FMT_TYPE_YUV && fmt -> data_type == DATA_TYPE_C420 ) { rect . height >>= 1 ; rect . top >>= 1 ; depth = 8 ; } dma_addr += rect . top * stride + ( rect . left * depth >> 3 ) ; dtd = list -> next ; WARN_ON ( ( void * ) ( dtd + 1 ) > ( list -> buf . addr + list -> buf . size ) ) ; dtd -> xfer_length_height = dtd_xfer_length_height ( rect . width , rect . height ) ; dtd -> start_addr = ( u32 ) dma_addr ; dtd -> pkt_ctl = dtd_pkt_ctl ( ! ! ( flags & VPDMA_DATA_MODE_TILED ) , DTD_DIR_IN , channel , priority , next_chan ) ; dtd -> frame_width_height = dtd_frame_width_height ( frame_width , frame_height ) ; dtd -> start_h_v = dtd_start_h_v ( start_h , start_v ) ; dtd -> client_attr0 = 0 ; dtd -> client_attr1 = 0 ; list -> next = dtd + 1 ; dump_dtd ( dtd ) ; } 