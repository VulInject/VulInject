static void * read_thread ( void * reference ) { unsigned char readbuffer [ 512 ] ; int rbytes ; int readstatus ; struct timeval now , delay , end , timeleft ; ( void ) reference ; delay . tv_sec = 0 ; delay . tv_usec = 250000 ; { gettimeofday ( & now , NULL ) ; rbytes = sizeof ( readbuffer ) ; readstatus = libusb_bulk_transfer ( g . printer -> handle , g . printer -> read_endp , readbuffer , rbytes , & rbytes , 60000 ) ; if ( readstatus == LIBUSB_SUCCESS && rbytes > 0 ) { fprintf ( stderr , "DEBUG: Read %d bytes of back-channel data...\n" , ( int ) rbytes ) ; cupsBackChannelWrite ( ( const char * ) readbuffer , ( size_t ) rbytes , 1.0 ) ; } if ( readstatus == LIBUSB_ERROR_TIMEOUT ) { fputs ( "DEBUG: Got USB transaction timeout during read.\n" , stderr ) ; } if ( readstatus == LIBUSB_ERROR_PIPE ) { fputs ( "DEBUG: Got USB pipe stalled during read.\n" , stderr ) ; } if ( readstatus == LIBUSB_ERROR_INTERRUPTED ) { fputs ( "DEBUG: Got USB return aborted during read.\n" , stderr ) ; } if ( ( g . wait_eof || ! g . read_thread_stop ) ) { gettimeofday ( & now , NULL ) ; if ( timercmp ( & now , & end , < ) ) { timersub ( & end , & now , & timeleft ) ; usleep ( 1000000 * timeleft . tv_sec + timeleft . tv_usec ) ; } } } g . wait_eof || ! g . read_thread_stop ; pthread_mutex_lock ( & g . read_thread_mutex ) ; g . read_thread_done = 1 ; pthread_cond_signal ( & g . read_thread_cond ) ; pthread_mutex_unlock ( & g . read_thread_mutex ) ; return ( NULL ) ; } 