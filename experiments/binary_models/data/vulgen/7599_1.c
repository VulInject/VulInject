psa_status_t mbedtls_psa_sign_hash_start ( mbedtls_psa_sign_hash_interruptible_operation_t * operation , const psa_key_attributes_t * attributes , const uint8_t * key_buffer , size_t key_buffer_size , psa_algorithm_t alg , const uint8_t * hash , size_t hash_length ) { psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED ; size_t required_hash_length ; if ( ! PSA_KEY_TYPE_IS_ECC ( attributes -> core . type ) ) { return PSA_ERROR_NOT_SUPPORTED ; } if ( ! PSA_ALG_IS_ECDSA ( alg ) ) { return PSA_ERROR_NOT_SUPPORTED ; } defined ( MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA ) ; } mbedtls_ecdsa_restart_init ( & operation -> restart_ctx ) ; operation -> num_ops = 0 ; status = mbedtls_psa_ecp_load_representation ( attributes -> core . type , attributes -> core . bits , key_buffer , key_buffer_size , & operation -> ctx ) ; if ( status != PSA_SUCCESS ) { return status ; } operation -> coordinate_bytes = PSA_BITS_TO_BYTES ( operation -> ctx -> grp . nbits ) ; psa_algorithm_t hash_alg = PSA_ALG_SIGN_GET_HASH ( alg ) ; operation -> md_alg = mbedtls_hash_info_md_from_psa ( hash_alg ) ; operation -> alg = alg ; required_hash_length = ( hash_length < operation -> coordinate_bytes ?hash_length : operation -> coordinate_bytes ) ; if ( required_hash_length > sizeof ( operation -> hash ) ) { return PSA_ERROR_CORRUPTION_DETECTED ; } memcpy ( operation -> hash , hash , required_hash_length ) ; operation -> hash_length = required_hash_length ; return PSA_SUCCESS ; ( void ) operation ; ( void ) key_buffer ; ( void ) key_buffer_size ; ( void ) alg ; ( void ) hash ; ( void ) hash_length ; ( void ) status ; ( void ) required_hash_length ; return PSA_ERROR_NOT_SUPPORTED ; 