struct radnode * radix_insert ( struct radtree * rt , uint8_t * k , radstrlen_type len , void * elem ) { struct radnode * n ; radstrlen_type pos ; struct radnode * add = ( radnode * ) region_alloc_zero ( rt -> region , sizeof ( * add ) ) ; if ( ! add ) { return NULL ; } add -> elem = elem ; if ( ! radix_find_prefix_node ( rt , k , len , & n , & pos ) ) { assert ( rt -> root == NULL ) ; if ( len == 0 ) { rt -> root = add ; } else { n = ( radnode * ) region_alloc_zero ( rt -> region , sizeof ( * n ) ) ; if ( ! n ) { region_recycle ( rt -> region , add , sizeof ( * add ) ) ; return NULL ; } if ( ! radnode_array_space ( rt -> region , n , k [ 0 ] ) ) { region_recycle ( rt -> region , n -> array , n -> capacity * sizeof ( radsel ) ) ; region_recycle ( rt -> region , n , sizeof ( * n ) ) ; region_recycle ( rt -> region , add , sizeof ( * add ) ) ; return NULL ; } add -> parent = n ; add -> pidx = 0 ; n -> array [ 0 ] . node = add ; if ( len > 1 ) { if ( ! radsel_prefix_remainder ( rt -> region , 1 , k , len , & n -> array [ 0 ] . str , & n -> array [ 0 ] . len ) ) { region_recycle ( rt -> region , n -> array , n -> capacity * sizeof ( radsel ) ) ; region_recycle ( rt -> region , n , sizeof ( * n ) ) ; region_recycle ( rt -> region , add , sizeof ( * add ) ) ; return NULL ; } } rt -> root = n ; } } if ( pos == len ) { if ( n -> elem ) { region_recycle ( rt -> region , add , sizeof ( * add ) ) ; return NULL ; } n -> elem = elem ; region_recycle ( rt -> region , add , sizeof ( * add ) ) ; add = n ; } else { uint8_t byte ; assert ( pos < len ) ; byte = k [ pos ] ; if ( byte < n -> offset || byte - n -> offset >= n -> len ) { if ( ! radnode_array_space ( rt -> region , n , byte ) ) { region_recycle ( rt -> region , add , sizeof ( * add ) ) ; return NULL ; } assert ( byte >= n -> offset && byte - n -> offset < n -> len ) ; byte -= n -> offset ; if ( pos + 1 < len ) { if ( ! radsel_str_create ( rt -> region , & n -> array [ byte ] , k , pos + 1 , len ) ) { region_recycle ( rt -> region , add , sizeof ( * add ) ) ; return NULL ; } } add -> parent = n ; add -> pidx = byte ; n -> array [ byte ] . node = add ; } if ( n -> array [ byte - n -> offset ] . node == NULL ) { byte -= n -> offset ; if ( pos + 1 < len ) { if ( ! radsel_str_create ( rt -> region , & n -> array [ byte ] , k , pos + 1 , len ) ) { region_recycle ( rt -> region , add , sizeof ( * add ) ) ; return NULL ; } } add -> parent = n ; add -> pidx = byte ; n -> array [ byte ] . node = add ; } else { if ( ! radsel_split ( rt -> region , & n -> array [ byte - n -> offset ] , k , pos + 1 , len , add ) ) { region_recycle ( rt -> region , add , sizeof ( * add ) ) ; return NULL ; } } } rt -> count ++ ; return add ; } 