static int __init alchemy_time_init ( unsigned int m2int ) { struct clock_event_device * cd = & au1x_rtcmatch2_clockdev ; unsigned long t ; au1x_rtcmatch2_clockdev . irq = m2int ; if ( CNTR_OK != ( alchemy_rdsys ( AU1000_SYS_CNTRCTRL ) & CNTR_OK ) ) { cntr_err } t = 0xffffff ; while ( ( alchemy_rdsys ( AU1000_SYS_CNTRCTRL ) & SYS_CNTRL_T1S ) && -- t ) { volatile } if ( ! t ) { cntr_err } alchemy_wrsys ( 0 , AU1000_SYS_RTCTRIM ) ; t = 0xffffff ; while ( ( alchemy_rdsys ( AU1000_SYS_CNTRCTRL ) & SYS_CNTRL_C1S ) && -- t ) { volatile } if ( ! t ) { cntr_err } alchemy_wrsys ( 0 , AU1000_SYS_RTCWRITE ) ; t = 0xffffff ; while ( ( alchemy_rdsys ( AU1000_SYS_CNTRCTRL ) & SYS_CNTRL_C1S ) && -- t ) { volatile } if ( ! t ) { cntr_err } clocksource_register_hz ( & au1x_counter1_clocksource , 32768 ) ; cd -> shift = 32 ; cd -> mult = div_sc ( 32768 , NSEC_PER_SEC , cd -> shift ) ; cd -> max_delta_ns = clockevent_delta2ns ( 0xffffffff , cd ) ; cd -> max_delta_ticks = 0xffffffff ; cd -> min_delta_ns = clockevent_delta2ns ( 9 , cd ) ; cd -> min_delta_ticks = 9 ; setup_irq ( m2int , & au1x_rtcmatch2_irqaction ) ; printk ( KERN_INFO "Alchemy clocksource installed\n" ) ; return 0 ; cntr_err return - 1 ; } 