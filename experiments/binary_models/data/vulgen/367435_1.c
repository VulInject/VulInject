static int pass2check ( struct inodesc * idesc ) { struct direct * dirp = idesc -> id_dirp ; struct inodesc ldesc ; struct inoinfo * inp ; short reclen , entrysize ; int ret = 0 ; int act , update_lncntp ; struct dinode * dp , * pdirp , * attrdirp ; caddr_t errmsg ; struct direct proto ; char namebuf [ MAXPATHLEN + 1 ] ; char pathbuf [ MAXPATHLEN + 1 ] ; int isattr ; int pdirtype ; int breakout = 0 ; int dontreconnect ; if ( idesc -> id_entryno != 0 ) { chk1 } if ( dirp -> d_ino != 0 && strcmp ( dirp -> d_name , "." ) == 0 ) { if ( dirp -> d_ino != idesc -> id_number ) { direrror ( idesc -> id_number , "BAD INODE NUMBER FOR '.'" ) ; dirp -> d_ino = idesc -> id_number ; if ( reply ( "FIX" ) == 1 ) { ret |= ALTERED ; } else { iscorrupt = 1 ; } } chk1 } direrror ( idesc -> id_number , "MISSING '.'" ) ; proto . d_ino = idesc -> id_number ; proto . d_namlen = 1 ; ( void ) strcpy ( proto . d_name , "." ) ; entrysize = DIRSIZ ( & proto ) ; if ( dirp -> d_ino != 0 && strcmp ( dirp -> d_name , ".." ) != 0 ) { pfatal ( "CANNOT FIX, FIRST ENTRY IN DIRECTORY CONTAINS %s\n" , dirp -> d_name ) ; iscorrupt = 1 ; } if ( ( int ) dirp -> d_reclen < entrysize ) { pfatal ( "CANNOT FIX, INSUFFICIENT SPACE TO ADD '.'\n" ) ; iscorrupt = 1 ; } if ( ( int ) dirp -> d_reclen < 2 * entrysize ) { proto . d_reclen = dirp -> d_reclen ; ( void ) memmove ( ( void * ) dirp , ( void * ) & proto , ( size_t ) entrysize ) ; if ( reply ( "FIX" ) == 1 ) { ret |= ALTERED ; } else { iscorrupt = 1 ; } } else { reclen = dirp -> d_reclen - entrysize ; proto . d_reclen = entrysize ; ( void ) memmove ( ( void * ) dirp , ( void * ) & proto , ( size_t ) entrysize ) ; idesc -> id_entryno ++ ; LINK_RANGE ( errmsg , lncntp [ dirp -> d_ino ] , - 1 ) ; if ( errmsg != NULL ) { LINK_CLEAR ( errmsg , dirp -> d_ino , IFDIR , & ldesc ) ; if ( statemap [ dirp -> d_ino ] == USTATE ) { dirp -> d_ino = 0 ; dirp -> d_reclen += reclen ; ret |= ALTERED ; return ( ret ) ; } } dirp = ( direct * ) ( ( char * ) ( dirp ) + entrysize ) ; ( void ) memset ( ( void * ) dirp , 0 , ( size_t ) reclen ) ; dirp -> d_reclen = reclen ; if ( reply ( "FIX" ) == 1 ) { TRACK_LNCNTP ( idesc -> id_number , lncntp [ idesc -> id_number ] -- ) ; ret |= ALTERED ; } else { iscorrupt = 1 ; } } chk1 if ( idesc -> id_entryno > 1 ) { chk2 } inp = getinoinfo ( idesc -> id_number ) ; if ( inp == NULL ) { errexit ( "pass2check got NULL from getinoinfo at chk1 I=%d\n" , idesc -> id_number ) ; } proto . d_ino = inp -> i_parent ; proto . d_namlen = 2 ; ( void ) strcpy ( proto . d_name , ".." ) ; entrysize = DIRSIZ ( & proto ) ; if ( idesc -> id_entryno == 0 ) { reclen = DIRSIZ ( dirp ) ; if ( ( int ) dirp -> d_reclen < reclen + entrysize ) { chk2 } proto . d_reclen = dirp -> d_reclen - reclen ; dirp -> d_reclen = reclen ; idesc -> id_entryno ++ ; if ( dirp -> d_ino > 0 && dirp -> d_ino <= maxino ) { LINK_RANGE ( errmsg , lncntp [ dirp -> d_ino ] , - 1 ) ; if ( errmsg != NULL ) { LINK_CLEAR ( errmsg , dirp -> d_ino , IFDIR , & ldesc ) ; if ( statemap [ dirp -> d_ino ] == USTATE ) { dirp -> d_ino = 0 ; dirp -> d_reclen += proto . d_reclen ; ret |= ALTERED ; return ( ret ) ; } } TRACK_LNCNTP ( dirp -> d_ino , lncntp [ dirp -> d_ino ] -- ) ; dirp = ( direct * ) ( ( char * ) ( dirp ) + reclen ) ; ( void ) memset ( ( void * ) dirp , 0 , ( size_t ) proto . d_reclen ) ; dirp -> d_reclen = proto . d_reclen ; } else { fileerror ( idesc -> id_number , dirp -> d_ino , "I OUT OF RANGE" ) ; dirp -> d_ino = 0 ; if ( reply ( "FIX" ) == 1 ) { ret |= ALTERED ; } else { iscorrupt = 1 ; } } } if ( dirp -> d_ino != 0 && inp -> i_dotdot == 0 && strcmp ( dirp -> d_name , ".." ) == 0 ) { inp -> i_dotdot = dirp -> d_ino ; chk2 } if ( dirp -> d_ino != 0 && strcmp ( dirp -> d_name , ".." ) != 0 ) { fileerror ( inp -> i_parent , idesc -> id_number , "MISSING '..'" ) ; pfatal ( "CANNOT FIX, SECOND ENTRY IN DIRECTORY CONTAINS %s\n" , dirp -> d_name ) ; iscorrupt = 1 ; inp -> i_dotdot = ( fsck_ino_t ) - 1 ; } if ( ( int ) dirp -> d_reclen < entrysize ) { fileerror ( inp -> i_parent , idesc -> id_number , "MISSING '..'" ) ; pfatal ( "CANNOT FIX, INSUFFICIENT SPACE TO ADD '..'\n" ) ; iscorrupt = 1 ; inp -> i_dotdot = ( fsck_ino_t ) - 1 ; } if ( inp -> i_parent != 0 ) { proto . d_ino = inp -> i_dotdot = inp -> i_parent ; fileerror ( inp -> i_parent , idesc -> id_number , "MISSING '..'" ) ; proto . d_reclen = dirp -> d_reclen ; ( void ) memmove ( ( void * ) dirp , ( void * ) & proto , ( size_t ) entrysize ) ; if ( reply ( "FIX" ) == 1 ) { ret |= ALTERED ; } else { iscorrupt = 1 ; } } if ( inp -> i_number == UFSROOTINO ) { proto . d_ino = inp -> i_dotdot = inp -> i_parent = UFSROOTINO ; fileerror ( inp -> i_parent , idesc -> id_number , "MISSING '..'" ) ; proto . d_reclen = dirp -> d_reclen ; ( void ) memmove ( ( void * ) dirp , ( void * ) & proto , ( size_t ) entrysize ) ; if ( reply ( "FIX" ) == 1 ) { ret |= ALTERED ; } else { iscorrupt = 1 ; } } idesc -> id_entryno ++ ; if ( dirp -> d_ino != 0 ) { LINK_RANGE ( errmsg , lncntp [ dirp -> d_ino ] , - 1 ) ; if ( errmsg != NULL ) { LINK_CLEAR ( errmsg , dirp -> d_ino , IFDIR , & ldesc ) ; if ( statemap [ dirp -> d_ino ] == USTATE ) { dirp -> d_ino = 0 ; ret |= ALTERED ; } } TRACK_LNCNTP ( dirp -> d_ino , lncntp [ dirp -> d_ino ] -- ) ; } return ( ret | KEEPON ) ; chk2 if ( dirp -> d_ino == 0 ) { return ( ret | KEEPON ) ; } if ( dirp -> d_namlen <= 2 && dirp -> d_name [ 0 ] == '.' && idesc -> id_entryno >= 2 ) { if ( dirp -> d_namlen == 1 ) { direrror ( idesc -> id_number , "EXTRA '.' ENTRY" ) ; dirp -> d_ino = 0 ; if ( reply ( "FIX" ) == 1 ) { ret |= ALTERED ; } else { iscorrupt = 1 ; } return ( KEEPON | ret ) ; } if ( dirp -> d_name [ 1 ] == '.' ) { direrror ( idesc -> id_number , "EXTRA '..' ENTRY" ) ; dirp -> d_ino = 0 ; if ( reply ( "FIX" ) == 1 ) { ret |= ALTERED ; } else { iscorrupt = 1 ; } return ( KEEPON | ret ) ; } } idesc -> id_entryno ++ ; act = - 1 ; update_lncntp = 0 ; if ( dirp -> d_ino > maxino || dirp -> d_ino == 0 ) { fileerror ( idesc -> id_number , dirp -> d_ino , "I OUT OF RANGE" ) ; act = ( reply ( PASS2B_PROMPT , idesc -> id_number ) == 1 ) ; } else { again update_lncntp = 0 ; switch ( statemap [ dirp -> d_ino ] & ~ ( INDELAYD ) ) { case USTATE : if ( idesc -> id_entryno <= 2 ) { break ; } fileerror ( idesc -> id_number , dirp -> d_ino , "UNALLOCATED" ) ; act = ( reply ( PASS2B_PROMPT , idesc -> id_number ) == 1 ) ; break ; case DCLEAR : case FCLEAR : case SCLEAR : if ( idesc -> id_entryno <= 2 ) { break ; } dp = ginode ( dirp -> d_ino ) ; if ( statemap [ dirp -> d_ino ] == DCLEAR ) { errmsg = ( ( dp -> di_mode & IFMT ) == IFATTRDIR ) ?"REFERENCE TO ZERO LENGTH ATTRIBUTE DIRECTORY" : "REFERENCE TO ZERO LENGTH DIRECTORY" ; inp = getinoinfo ( dirp -> d_ino ) ; if ( inp == NULL ) { errexit ( "pass2check found a zero-len " "reference to bad I=%d\n" , dirp -> d_ino ) ; } if ( inp -> i_parent != 0 ) { ( void ) printf ( "Multiple links to I=%d, link counts wrong, rerun fsck\n" , inp -> i_number ) ; iscorrupt = 1 ; } } if ( statemap [ dirp -> d_ino ] == SCLEAR ) { errmsg = "ZERO LENGTH SHADOW" ; } else { errmsg = "DUP/BAD" ; } fileerror ( idesc -> id_number , dirp -> d_ino , errmsg ) ; if ( ( act = reply ( PASS2B_PROMPT , idesc -> id_number ) ) == 1 ) { break ; } dp = ginode ( dirp -> d_ino ) ; statemap [ dirp -> d_ino ] &= STMASK ; TRACK_LNCNTP ( dirp -> d_ino , lncntp [ dirp -> d_ino ] = 0 ) ; again case DSTATE : case DZLINK : if ( statemap [ idesc -> id_number ] == DFOUND ) { statemap [ dirp -> d_ino ] = DFOUND ; } case DFOUND : inp = getinoinfo ( dirp -> d_ino ) ; if ( inp == NULL ) { errexit ( "pass2check found bad reference to " "hard-linked directory I=%d\n" , dirp -> d_ino ) ; } dp = ginode ( idesc -> id_number ) ; if ( inp -> i_parent != 0 && idesc -> id_entryno > 2 && ( ( dp -> di_mode & IFMT ) != IFATTRDIR ) ) { getpathname ( pathbuf , idesc -> id_number , dirp -> d_ino ) ; getpathname ( namebuf , dirp -> d_ino , dirp -> d_ino ) ; pwarn ( "%s IS AN EXTRANEOUS HARD LINK TO DIRECTORY %s\n" , pathbuf , namebuf ) ; if ( preen ) { ( void ) printf ( " (IGNORED)\n" ) ; } else { act = reply ( PASS2B_PROMPT , idesc -> id_number ) ; if ( act == 1 ) { update_lncntp = 1 ; broke_dir_link = 1 ; break ; } } } if ( ( idesc -> id_entryno > 2 ) && ( inp -> i_extattr != idesc -> id_number ) ) { inp -> i_parent = idesc -> id_number ; } case FSTATE : case FZLINK : pdirp = ginode ( idesc -> id_number ) ; pdirtype = ( pdirp -> di_mode & IFMT ) ; dp = ginode ( dirp -> d_ino ) ; isattr = ( dp -> di_cflags & IXATTR ) ; act = - 1 ; if ( pdirtype == IFATTRDIR && ( strcmp ( dirp -> d_name , ".." ) == 0 ) ) { dontreconnect = 0 ; if ( dp -> di_oeftflag != 0 ) { attrdirp = ginode ( dp -> di_oeftflag ) ; if ( ( attrdirp -> di_mode & IFMT ) == IFATTRDIR ) { dontreconnect = 1 ; } dp = ginode ( dirp -> d_ino ) ; } if ( dirp -> d_ino == idesc -> id_number ) { dontreconnect = 1 ; TRACK_LNCNTP ( idesc -> id_number , lncntp [ idesc -> id_number ] -- ) ; } if ( ( dp -> di_oeftflag != idesc -> id_number ) && ( dontreconnect == 0 ) ) { fileerror ( idesc -> id_number , dirp -> d_ino , "Attribute directory I=%d not " "attached to file I=%d\n" , idesc -> id_number , dirp -> d_ino ) ; if ( ( act = reply ( "FIX" ) ) == 1 ) { dp = ginode ( dirp -> d_ino ) ; if ( debug ) { ( void ) printf ( "debug: changing i=%d's oeft from %d " , dirp -> d_ino , dp -> di_oeftflag ) ; } dp -> di_oeftflag = idesc -> id_number ; if ( debug ) { ( void ) printf ( "to %d\n" , dp -> di_oeftflag ) ; } inodirty ( ) ; registershadowclient ( idesc -> id_number , dirp -> d_ino , & attrclientinfo ) ; } dp = ginode ( dirp -> d_ino ) ; } if ( act > 0 ) { return ( KEEPON | ALTERED ) ; } if ( ( pdirtype == IFATTRDIR ) && ( ( dp -> di_mode & IFMT ) == IFDIR ) ) { breakout = 1 ; } if ( ( dp -> di_mode & IFMT ) != IFDIR ) { breakout = 1 ; } } if ( ( pdirtype != IFATTRDIR ) || ( strcmp ( dirp -> d_name , "." ) != 0 ) ) { if ( ( pdirtype == IFDIR ) && isattr ) { fileerror ( idesc -> id_number , dirp -> d_ino , "File should NOT be marked as " "extended attribute\n" ) ; if ( ( act = reply ( "FIX" ) ) == 1 ) { dp = ginode ( dirp -> d_ino ) ; if ( debug ) { ( void ) printf ( "changing i=%d's cflags from 0x%x to " , dirp -> d_ino , dp -> di_cflags ) ; } dp -> di_cflags &= ~ IXATTR ; if ( debug ) { ( void ) printf ( "0x%x\n" , dp -> di_cflags ) ; } inodirty ( ) ; if ( ( dp -> di_mode & IFMT ) == IFATTRDIR ) { dp -> di_mode &= ~ IFATTRDIR ; dp -> di_mode |= IFDIR ; inodirty ( ) ; pdirp = ginode ( idesc -> id_number ) ; if ( pdirp -> di_oeftflag != 0 ) { pdirp -> di_oeftflag = 0 ; inodirty ( ) ; } } } } else { if ( pdirtype == IFATTRDIR && ( isattr == 0 ) ) { fileerror ( idesc -> id_number , dirp -> d_ino , "File should BE marked as " "extended attribute\n" ) ; if ( ( act = reply ( "FIX" ) ) == 1 ) { dp = ginode ( dirp -> d_ino ) ; dp -> di_cflags |= IXATTR ; dp -> di_mode &= ~ IFMT ; dp -> di_mode |= IFREG ; inodirty ( ) ; } } } } if ( breakout == 0 || dontreconnect == 0 ) { TRACK_LNCNTP ( dirp -> d_ino , lncntp [ dirp -> d_ino ] -- ) ; if ( act > 0 ) { return ( KEEPON | ALTERED ) ; } } break ; case SSTATE : errmsg = "ACL IN DIRECTORY" ; fileerror ( idesc -> id_number , dirp -> d_ino , errmsg ) ; act = ( reply ( PASS2B_PROMPT , idesc -> id_number ) == 1 ) ; break ; default : errexit ( "BAD STATE 0x%x FOR INODE I=%d" , statemap [ dirp -> d_ino ] , dirp -> d_ino ) ; } } if ( act == 0 ) { iscorrupt = 1 ; } if ( act <= 0 ) { return ( ret | KEEPON ) ; } if ( update_lncntp ) { LINK_RANGE ( errmsg , lncntp [ idesc -> id_number ] , 1 ) ; if ( errmsg != NULL ) { LINK_CLEAR ( errmsg , idesc -> id_number , IFDIR , & ldesc ) ; } TRACK_LNCNTP ( idesc -> id_number , lncntp [ idesc -> id_number ] ++ ) ; } dirp -> d_ino = 0 ; return ( ret | KEEPON | ALTERED ) ; } 