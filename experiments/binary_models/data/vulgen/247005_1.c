static void virt_init ( MachineState * machine ) { M68kCPU * cpu = NULL ; int32_t kernel_size ; uint64_t elf_entry ; ram_addr_t initrd_base ; int32_t initrd_size ; ram_addr_t ram_size = machine -> ram_size ; const char * kernel_filename = machine -> kernel_filename ; const char * initrd_filename = machine -> initrd_filename ; const char * kernel_cmdline = machine -> kernel_cmdline ; hwaddr parameters_base ; DeviceState * dev ; DeviceState * irqc_dev ; DeviceState * pic_dev [ VIRT_GF_PIC_NB ] ; SysBusDevice * sysbus ; hwaddr io_base ; int i ; ResetInfo * reset_info ; if ( ram_size > 3399672 * KiB ) { error_report ( "Too much memory for this machine: %" PRId64 " KiB, " "maximum 3399672 KiB" , ram_size / KiB ) ; exit ( 1 ) ; } cpu = M68K_CPU ( cpu_create ( machine -> cpu_type ) ) ; reset_info -> cpu = cpu ; qemu_register_reset ( main_cpu_reset , reset_info ) ; memory_region_add_subregion ( get_system_memory ( ) , 0 , machine -> ram ) ; irqc_dev = qdev_new ( TYPE_M68K_IRQC ) ; sysbus_realize_and_unref ( SYS_BUS_DEVICE ( irqc_dev ) , & error_fatal ) ; io_base = VIRT_GF_PIC_MMIO_BASE ; for ( i = 0 ; i < VIRT_GF_PIC_NB ; i ++ ) { pic_dev [ i ] = qdev_new ( TYPE_GOLDFISH_PIC ) ; sysbus = SYS_BUS_DEVICE ( pic_dev [ i ] ) ; qdev_prop_set_uint8 ( pic_dev [ i ] , "index" , i ) ; sysbus_realize_and_unref ( sysbus , & error_fatal ) ; sysbus_mmio_map ( sysbus , 0 , io_base ) ; sysbus_connect_irq ( sysbus , 0 , qdev_get_gpio_in ( irqc_dev , i ) ) ; io_base += 0x1000 ; } io_base = VIRT_GF_RTC_MMIO_BASE ; for ( i = 0 ; i < VIRT_GF_RTC_NB ; i ++ ) { dev = qdev_new ( TYPE_GOLDFISH_RTC ) ; sysbus = SYS_BUS_DEVICE ( dev ) ; sysbus_realize_and_unref ( sysbus , & error_fatal ) ; sysbus_mmio_map ( sysbus , 0 , io_base ) ; sysbus_connect_irq ( sysbus , 0 , PIC_GPIO ( VIRT_GF_RTC_IRQ_BASE + i ) ) ; io_base += 0x1000 ; } dev = qdev_new ( TYPE_GOLDFISH_TTY ) ; sysbus = SYS_BUS_DEVICE ( dev ) ; qdev_prop_set_chr ( dev , "chardev" , serial_hd ( 0 ) ) ; sysbus_realize_and_unref ( sysbus , & error_fatal ) ; sysbus_mmio_map ( sysbus , 0 , VIRT_GF_TTY_MMIO_BASE ) ; sysbus_connect_irq ( sysbus , 0 , PIC_GPIO ( VIRT_GF_TTY_IRQ_BASE ) ) ; dev = qdev_new ( TYPE_VIRT_CTRL ) ; sysbus = SYS_BUS_DEVICE ( dev ) ; sysbus_realize_and_unref ( sysbus , & error_fatal ) ; sysbus_mmio_map ( sysbus , 0 , VIRT_CTRL_MMIO_BASE ) ; sysbus_connect_irq ( sysbus , 0 , PIC_GPIO ( VIRT_CTRL_IRQ_BASE ) ) ; io_base = VIRT_VIRTIO_MMIO_BASE ; for ( i = 0 ; i < 128 ; i ++ ) { dev = qdev_new ( TYPE_VIRTIO_MMIO ) ; qdev_prop_set_bit ( dev , "force-legacy" , false ) ; sysbus = SYS_BUS_DEVICE ( dev ) ; sysbus_realize_and_unref ( sysbus , & error_fatal ) ; sysbus_connect_irq ( sysbus , 0 , PIC_GPIO ( VIRT_VIRTIO_IRQ_BASE + i ) ) ; sysbus_mmio_map ( sysbus , 0 , io_base ) ; io_base += 0x200 ; } if ( kernel_filename ) { CPUState * cs = CPU ( cpu ) ; uint64_t high ; kernel_size = load_elf ( kernel_filename , NULL , NULL , NULL , & elf_entry , NULL , & high , NULL , 1 , EM_68K , 0 , 0 ) ; if ( kernel_size < 0 ) { error_report ( "could not load kernel '%s'" , kernel_filename ) ; exit ( 1 ) ; } reset_info -> initial_pc = elf_entry ; parameters_base = ( high + 1 ) & ~ 1 ; BOOTINFO1 ( cs -> as , parameters_base , BI_MACHTYPE , MACH_VIRT ) ; BOOTINFO1 ( cs -> as , parameters_base , BI_FPUTYPE , FPU_68040 ) ; BOOTINFO1 ( cs -> as , parameters_base , BI_MMUTYPE , MMU_68040 ) ; BOOTINFO1 ( cs -> as , parameters_base , BI_CPUTYPE , CPU_68040 ) ; BOOTINFO2 ( cs -> as , parameters_base , BI_MEMCHUNK , 0 , ram_size ) ; BOOTINFO1 ( cs -> as , parameters_base , BI_VIRT_QEMU_VERSION , ( ( QEMU_VERSION_MAJOR << 24 ) | ( QEMU_VERSION_MINOR << 16 ) | ( QEMU_VERSION_MICRO << 8 ) ) ) ; BOOTINFO2 ( cs -> as , parameters_base , BI_VIRT_GF_PIC_BASE , VIRT_GF_PIC_MMIO_BASE , VIRT_GF_PIC_IRQ_BASE ) ; BOOTINFO2 ( cs -> as , parameters_base , BI_VIRT_GF_RTC_BASE , VIRT_GF_RTC_MMIO_BASE , VIRT_GF_RTC_IRQ_BASE ) ; BOOTINFO2 ( cs -> as , parameters_base , BI_VIRT_GF_TTY_BASE , VIRT_GF_TTY_MMIO_BASE , VIRT_GF_TTY_IRQ_BASE ) ; BOOTINFO2 ( cs -> as , parameters_base , BI_VIRT_CTRL_BASE , VIRT_CTRL_MMIO_BASE , VIRT_CTRL_IRQ_BASE ) ; BOOTINFO2 ( cs -> as , parameters_base , BI_VIRT_VIRTIO_BASE , VIRT_VIRTIO_MMIO_BASE , VIRT_VIRTIO_IRQ_BASE ) ; if ( kernel_cmdline ) { BOOTINFOSTR ( cs -> as , parameters_base , BI_COMMAND_LINE , kernel_cmdline ) ; } if ( initrd_filename ) { initrd_size = get_image_size ( initrd_filename ) ; if ( initrd_size < 0 ) { error_report ( "could not load initial ram disk '%s'" , initrd_filename ) ; exit ( 1 ) ; } initrd_base = ( ram_size - initrd_size ) & TARGET_PAGE_MASK ; load_image_targphys ( initrd_filename , initrd_base , ram_size - initrd_base ) ; BOOTINFO2 ( cs -> as , parameters_base , BI_RAMDISK , initrd_base , initrd_size ) ; } else { initrd_base = 0 ; initrd_size = 0 ; } BOOTINFO0 ( cs -> as , parameters_base , BI_LAST ) ; } } 