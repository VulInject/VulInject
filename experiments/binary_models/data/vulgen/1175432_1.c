* * This file is part of the FreeType project , and may only be used , * modified , and distributed under the terms of the FreeType project * license , LICENSE . TXT . By continuing to use , modify , or distribute * this file you indicate that you have read the license and * understand and accept it fully . * * / FT_LOCAL_DEF ( ) pfr_extra_items_skip ( , ) { return pfr_extra_items_parse ( pp , limit , NULL , NULL ) ; } ; FT_LOCAL_DEF ( ) pfr_extra_items_parse ( , , , ) { FT_Error error = FT_Err_Ok ; FT_Byte * p = * pp ; FT_UInt num_items , item_type , item_size ; PFR_CHECK ( 1 ) ; num_items = PFR_NEXT_BYTE ( p ) ; for ( ; num_items > 0 ; num_items -- ) { PFR_CHECK ( 2 ) ; item_size = PFR_NEXT_BYTE ( p ) ; item_type = PFR_NEXT_BYTE ( p ) ; PFR_CHECK ( item_size ) ; if ( item_list ) { PFR_ExtraItem extra = item_list ; for ( extra = item_list ; extra -> parser != NULL ; extra ++ ) { if ( extra -> type == item_type ) { error = extra -> parser ( p , p + item_size , item_data ) ; if ( error ) { Exit } break ; } } } p += item_size ; } Exit * pp = p ; return error ; Too_Short FT_ERROR ( ( "pfr_extra_items_parse: invalid extra items table\n" ) ) ; error = FT_THROW ( Invalid_Table ) ; Exit } static const FT_Frame_Field pfr_header_fields [ ] { FT_FRAME_START ( 58 ) FT_FRAME_ULONG ( signature ) FT_FRAME_USHORT ( version ) FT_FRAME_USHORT ( signature2 ) FT_FRAME_USHORT ( header_size ) FT_FRAME_USHORT ( log_dir_size ) FT_FRAME_USHORT ( log_dir_offset ) FT_FRAME_USHORT ( log_font_max_size ) FT_FRAME_UOFF3 ( log_font_section_size ) FT_FRAME_UOFF3 ( log_font_section_offset ) FT_FRAME_USHORT ( phy_font_max_size ) FT_FRAME_UOFF3 ( phy_font_section_size ) FT_FRAME_UOFF3 ( phy_font_section_offset ) FT_FRAME_USHORT ( gps_max_size ) FT_FRAME_UOFF3 ( gps_section_size ) FT_FRAME_UOFF3 ( gps_section_offset ) FT_FRAME_BYTE ( max_blue_values ) FT_FRAME_BYTE ( max_x_orus ) FT_FRAME_BYTE ( max_y_orus ) FT_FRAME_BYTE ( phy_font_max_size_high ) FT_FRAME_BYTE ( color_flags ) FT_FRAME_UOFF3 ( bct_max_size ) FT_FRAME_UOFF3 ( bct_set_max_size ) FT_FRAME_UOFF3 ( phy_bct_set_max_size ) FT_FRAME_USHORT ( num_phy_fonts ) FT_FRAME_BYTE ( max_vert_stem_snap ) FT_FRAME_BYTE ( max_horz_stem_snap ) FT_FRAME_USHORT ( max_chars ) FT_FRAME_END } ; ; FT_LOCAL_DEF ( ) pfr_header_load ( , ) { FT_Error error ; if ( ! FT_STREAM_SEEK ( 0 ) && ! FT_STREAM_READ_FIELDS ( pfr_header_fields , header ) ) { header -> phy_font_max_size += ( FT_UInt32 ) header -> phy_font_max_size_high << 16 ; } return error ; } FT_LOCAL_DEF ( ) pfr_header_check ( ) { FT_Bool result = 1 ; if ( header -> signature != 0x50465230L || header -> version > 4 || header -> header_size < 58 || header -> signature2 != 0x0D0A ) { result = 0 ; } return result ; } FT_LOCAL_DEF ( ) pfr_log_font_count ( , , ) { FT_Error error ; FT_UInt count ; FT_UInt result = 0 ; if ( FT_STREAM_SEEK ( section_offset ) || FT_READ_USHORT ( count ) ) { Exit } if ( count > ( ( 1 << 16 ) - 2 ) / 5 || 2 + count * 5 >= stream -> size - section_offset || 95 + count * ( 5 + 18 ) >= stream -> size ) { FT_ERROR ( ( "pfr_log_font_count:" " invalid number of logical fonts\n" ) ) ; error = FT_THROW ( Invalid_Table ) ; Exit } result = count ; Exit * acount = ( FT_Long ) result ; return error ; } FT_LOCAL_DEF ( ) pfr_log_font_load ( , , , , ) { FT_UInt num_log_fonts ; FT_UInt flags ; FT_UInt32 offset ; FT_UInt32 size ; FT_Error error ; if ( FT_STREAM_SEEK ( section_offset ) || FT_READ_USHORT ( num_log_fonts ) ) { Exit } if ( idx >= num_log_fonts ) { return FT_THROW ( Invalid_Argument ) ; } if ( FT_STREAM_SKIP ( idx * 5 ) || FT_READ_USHORT ( size ) || FT_READ_UOFF3 ( offset ) ) { Exit } log_font -> size = size ; log_font -> offset = offset ; { FT_Byte * p ; FT_Byte * limit ; FT_UInt local ; if ( FT_STREAM_SEEK ( offset ) || FT_FRAME_ENTER ( size ) ) { Exit } p = stream -> cursor ; limit = p + size ; PFR_CHECK ( 13 ) ; log_font -> matrix [ 0 ] = PFR_NEXT_LONG ( p ) ; log_font -> matrix [ 1 ] = PFR_NEXT_LONG ( p ) ; log_font -> matrix [ 2 ] = PFR_NEXT_LONG ( p ) ; log_font -> matrix [ 3 ] = PFR_NEXT_LONG ( p ) ; flags = PFR_NEXT_BYTE ( p ) ; local = 0 ; if ( flags & PFR_LOG_STROKE ) { local ++ ; if ( flags & PFR_LOG_2BYTE_STROKE ) { local ++ ; } if ( ( flags & PFR_LINE_JOIN_MASK ) == PFR_LINE_JOIN_MITER ) { local += 3 ; } } if ( flags & PFR_LOG_BOLD ) { local ++ ; if ( flags & PFR_LOG_2BYTE_BOLD ) { local ++ ; } } PFR_CHECK ( local ) ; if ( flags & PFR_LOG_STROKE ) { log_font -> stroke_thickness = ( flags & PFR_LOG_2BYTE_STROKE ) ?PFR_NEXT_SHORT ( p ) : PFR_NEXT_BYTE ( p ) ; if ( ( flags & PFR_LINE_JOIN_MASK ) == PFR_LINE_JOIN_MITER ) { log_font -> miter_limit = PFR_NEXT_LONG ( p ) ; } } if ( flags & PFR_LOG_BOLD ) { log_font -> bold_thickness = ( flags & PFR_LOG_2BYTE_BOLD ) ?PFR_NEXT_SHORT ( p ) : PFR_NEXT_BYTE ( p ) ; } if ( flags & PFR_LOG_EXTRA_ITEMS ) { error = pfr_extra_items_skip ( & p , limit ) ; if ( error ) { Fail } } PFR_CHECK ( 5 ) ; log_font -> phys_size = PFR_NEXT_USHORT ( p ) ; log_font -> phys_offset = PFR_NEXT_ULONG ( p ) ; if ( size_increment ) { PFR_CHECK ( 1 ) ; log_font -> phys_size += ( FT_UInt32 ) PFR_NEXT_BYTE ( p ) << 16 ; } } Fail FT_FRAME_EXIT ( ) ; Exit return error ; Too_Short FT_ERROR ( ( "pfr_log_font_load: invalid logical font table\n" ) ) ; error = FT_THROW ( Invalid_Table ) ; Fail } FT_CALLBACK_DEF ( ) pfr_extra_item_load_bitmap_info ( , , ) { FT_Memory memory = phy_font -> memory ; PFR_Strike strike ; FT_UInt flags0 ; FT_UInt n , count , size1 ; FT_Error error = FT_Err_Ok ; PFR_CHECK ( 5 ) ; p += 3 ; flags0 = PFR_NEXT_BYTE ( p ) ; count = PFR_NEXT_BYTE ( p ) ; if ( phy_font -> num_strikes + count > phy_font -> max_strikes ) { FT_UInt new_max = FT_PAD_CEIL ( phy_font -> num_strikes + count , 4 ) ; if ( FT_RENEW_ARRAY ( phy_font -> strikes , phy_font -> num_strikes , new_max ) ) { Exit } phy_font -> max_strikes = new_max ; } size1 = 1 + 1 + 1 + 2 + 2 + 1 ; if ( flags0 & PFR_STRIKE_2BYTE_XPPM ) { size1 ++ ; } if ( flags0 & PFR_STRIKE_2BYTE_YPPM ) { size1 ++ ; } if ( flags0 & PFR_STRIKE_3BYTE_SIZE ) { size1 ++ ; } if ( flags0 & PFR_STRIKE_3BYTE_OFFSET ) { size1 ++ ; } strike = phy_font -> strikes + phy_font -> num_strikes ; PFR_CHECK ( count * size1 ) ; for ( n = 0 ; n < count ; n ++ , strike ++ ) { strike -> x_ppm = ( flags0 & PFR_STRIKE_2BYTE_XPPM ) ?PFR_NEXT_USHORT ( p ) : PFR_NEXT_BYTE ( p ) ; strike -> y_ppm = ( flags0 & PFR_STRIKE_2BYTE_YPPM ) ?PFR_NEXT_USHORT ( p ) : PFR_NEXT_BYTE ( p ) ; strike -> flags = PFR_NEXT_BYTE ( p ) ; strike -> bct_size = ( flags0 & PFR_STRIKE_3BYTE_SIZE ) ?PFR_NEXT_ULONG ( p ) : PFR_NEXT_USHORT ( p ) ; strike -> bct_offset = ( flags0 & PFR_STRIKE_3BYTE_OFFSET ) ?PFR_NEXT_ULONG ( p ) : PFR_NEXT_USHORT ( p ) ; strike -> num_bitmaps = ( flags0 & PFR_STRIKE_2BYTE_COUNT ) ?PFR_NEXT_USHORT ( p ) : PFR_NEXT_BYTE ( p ) ; } phy_font -> num_strikes += count ; Exit return error ; Too_Short error = FT_THROW ( Invalid_Table ) ; FT_ERROR ( ( "pfr_extra_item_load_bitmap_info:" " invalid bitmap info table\n" ) ) ; Exit } FT_CALLBACK_DEF ( ) pfr_extra_item_load_font_id ( , , ) { FT_Error error = FT_Err_Ok ; FT_Memory memory = phy_font -> memory ; FT_UInt len = ( FT_UInt ) ( limit - p ) ; if ( phy_font -> font_id ) { Exit } if ( FT_QALLOC ( phy_font -> font_id , len + 1 ) ) { Exit } FT_MEM_COPY ( phy_font -> font_id , p , len ) ; phy_font -> font_id [ len ] = 0 ; Exit return error ; } FT_CALLBACK_DEF ( ) pfr_extra_item_load_stem_snaps ( , , ) { FT_UInt count , num_vert , num_horz ; FT_Int * snaps = NULL ; FT_Error error = FT_Err_Ok ; FT_Memory memory = phy_font -> memory ; if ( phy_font -> vertical . stem_snaps ) { Exit } PFR_CHECK ( 1 ) ; count = PFR_NEXT_BYTE ( p ) ; num_vert = count & 15 ; num_horz = count >> 4 ; count = num_vert + num_horz ; PFR_CHECK ( count * 2 ) ; if ( FT_QNEW_ARRAY ( snaps , count ) ) { Exit } phy_font -> vertical . stem_snaps = snaps ; phy_font -> horizontal . stem_snaps = snaps + num_vert ; for ( ; count > 0 ; count -- , snaps ++ ) { * snaps = FT_NEXT_SHORT ( p ) ; } Exit return error ; Too_Short error = FT_THROW ( Invalid_Table ) ; FT_ERROR ( ( "pfr_extra_item_load_stem_snaps:" " invalid stem snaps table\n" ) ) ; Exit } FT_CALLBACK_DEF ( ) pfr_extra_item_load_kerning_pairs ( , , ) { PFR_KernItem item = NULL ; FT_Error error = FT_Err_Ok ; FT_Memory memory = phy_font -> memory ; if ( FT_NEW ( item ) ) { Exit } } 