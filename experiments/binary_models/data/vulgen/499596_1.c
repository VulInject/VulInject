static void fmd_ckpt_restore_events ( fmd_ckpt_t * ckp , fcf_secidx_t sid , int * func ( void * , fmd_event_t * ) , void * arg ) { const fcf_event_t * fcfe ; const fcf_sec_t * sp ; fmd_timeval_t ftv ; fmd_log_t * lp , * errlp ; uint_t i , n ; uint32_t e_maj , e_min ; uint64_t e_ino ; if ( ( sp = fmd_ckpt_secptr ( ckp , sid , FCF_SECT_EVENTS ) ) == NULL ) { fmd_ckpt_error ( ckp , EFMD_CKPT_INVAL , "invalid link to section %u: expected events\n" , sid ) ; } fcfe = fmd_ckpt_dataptr ( ckp , sp ) ; n = sp -> fcfs_size / sp -> fcfs_entsize ; ( void ) pthread_rwlock_rdlock ( & fmd . d_log_lock ) ; errlp = fmd . d_errlog ; e_maj = major ( errlp -> log_stat . st_dev ) ; e_min = minor ( errlp -> log_stat . st_dev ) ; e_ino = errlp -> log_stat . st_ino ; for ( i = 0 ; i < n ; i ++ ) { fmd_event_t * ep ; ftv . ftv_sec = fcfe -> fcfe_todsec ; ftv . ftv_nsec = fcfe -> fcfe_todnsec ; if ( e_ino == fcfe -> fcfe_inode && e_maj == fcfe -> fcfe_major && e_min == fcfe -> fcfe_minor ) { lp = errlp ; } else { lp = NULL ; } ep = fmd_event_recreate ( FMD_EVT_PROTOCOL , & ftv , NULL , NULL , lp , fcfe -> fcfe_offset , 0 ) ; fmd_event_hold ( ep ) ; ( void ) func ( arg , ep ) ; fmd_event_rele ( ep ) ; fcfe = ( fcf_event_t * ) ( ( uintptr_t ) fcfe + sp -> fcfs_entsize ) ; } ( void ) pthread_rwlock_unlock ( & fmd . d_log_lock ) ; } 