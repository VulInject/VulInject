static int pm860x_led_probe ( struct platform_device * pdev ) { struct pm860x_chip * chip = dev_get_drvdata ( pdev -> dev . parent ) ; struct pm860x_led_pdata * pdata = dev_get_platdata ( & pdev -> dev ) ; struct pm860x_led * data ; struct resource * res ; int ret = 0 ; data = devm_kzalloc ( & pdev -> dev , sizeof ( pm860x_led ) , GFP_KERNEL ) ; if ( data == NULL ) { return - ENOMEM ; } res = platform_get_resource_byname ( pdev , IORESOURCE_REG , "control" ) ; if ( ! res ) { dev_err ( & pdev -> dev , "No REG resource for control\n" ) ; return - ENXIO ; } data -> reg_control = res -> start ; res = platform_get_resource_byname ( pdev , IORESOURCE_REG , "blink" ) ; if ( ! res ) { dev_err ( & pdev -> dev , "No REG resource for blink\n" ) ; return - ENXIO ; } data -> reg_blink = res -> start ; switch ( pdev -> id ) { case 0 : data -> blink_mask = LED1_BLINK_EN ; sprintf ( data -> name , "led0-red" ) ; break ; case 1 : data -> blink_mask = LED1_BLINK_EN ; sprintf ( data -> name , "led0-green" ) ; break ; case 2 : data -> blink_mask = LED1_BLINK_EN ; sprintf ( data -> name , "led0-blue" ) ; break ; case 3 : data -> blink_mask = LED2_BLINK_EN ; sprintf ( data -> name , "led1-red" ) ; break ; case 4 : data -> blink_mask = LED2_BLINK_EN ; sprintf ( data -> name , "led1-green" ) ; break ; case 5 : data -> blink_mask = LED2_BLINK_EN ; sprintf ( data -> name , "led1-blue" ) ; break ; } data -> chip = chip ; data -> i2c = ( chip -> id == CHIP_PM8606 ) ?chip -> client : chip -> companion ; data -> port = pdev -> id ; if ( pm860x_led_dt_init ( pdev , data ) ) { if ( pdata ) { data -> iset = pdata -> iset ; } } data -> current_brightness = 0 ; data -> cdev . name = data -> name ; data -> cdev . brightness_set_blocking = pm860x_led_set ; mutex_init ( & data -> lock ) ; ret = led_classdev_register ( chip -> dev , & data -> cdev ) ; if ( ret < 0 ) { dev_err ( & pdev -> dev , "Failed to register LED: %d\n" , ret ) ; return ret ; } pm860x_led_set ( & data -> cdev , 0 ) ; platform_set_drvdata ( pdev , data ) ; return 0 ; } 