static int dlpar_memory_add_by_count ( u32 lmbs_to_add , struct property * prop ) { struct of_drconf_cell * lmbs ; u32 num_lmbs , * p ; int lmbs_available = 0 ; int lmbs_added = 0 ; int i , rc ; pr_info ( "Attempting to hot-add %d LMB(s)\n" , lmbs_to_add ) ; p = prop -> value ; num_lmbs = * p ++ ; lmbs = ( of_drconf_cell * ) p ; for ( i = 0 ; i < num_lmbs ; i ++ ) { if ( ! ( lmbs [ i ] . flags & DRCONF_MEM_ASSIGNED ) ) { lmbs_available ++ ; } } if ( lmbs_available < lmbs_to_add ) { return - EINVAL ; } for ( i = 0 ; i < num_lmbs && lmbs_to_add != lmbs_added ; i ++ ) { rc = dlpar_acquire_drc ( lmbs [ i ] . drc_index ) ; if ( rc ) { continue ; } rc = dlpar_add_lmb ( & lmbs [ i ] ) ; if ( rc ) { dlpar_release_drc ( lmbs [ i ] . drc_index ) ; continue ; } lmbs_added ++ ; lmbs [ i ] . reserved = 1 ; } if ( lmbs_added != lmbs_to_add ) { pr_err ( "Memory hot-add failed, removing any added LMBs\n" ) ; for ( i = 0 ; i < num_lmbs ; i ++ ) { if ( ! lmbs [ i ] . reserved ) { continue ; } rc = dlpar_remove_lmb ( & lmbs [ i ] ) ; if ( rc ) { pr_err ( "Failed to remove LMB, drc index %x\n" , be32_to_cpu ( lmbs [ i ] . drc_index ) ) ; } else { dlpar_release_drc ( lmbs [ i ] . drc_index ) ; } } rc = - EINVAL ; } else { for ( i = 0 ; i < num_lmbs ; i ++ ) { if ( ! lmbs [ i ] . reserved ) { continue ; } pr_info ( "Memory at %llx (drc index %x) was hot-added\n" , lmbs [ i ] . base_addr , lmbs [ i ] . drc_index ) ; lmbs [ i ] . reserved = 0 ; } } return rc ; } 