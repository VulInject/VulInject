static noinline void do_fault_error ( struct pt_regs * regs , int access , int fault ) { int si_code ; switch ( fault ) { case VM_FAULT_BADACCESS : if ( access == VM_EXEC && signal_return ( regs ) == 0 ) { break ; } case VM_FAULT_BADMAP : if ( user_mode ( regs ) ) { si_code = ( fault == VM_FAULT_BADMAP ) ?SEGV_MAPERR : SEGV_ACCERR ; do_sigsegv ( regs , si_code ) ; break ; } case VM_FAULT_BADCONTEXT : case VM_FAULT_PFAULT : do_no_context ( regs ) ; break ; case VM_FAULT_SIGNAL : if ( ! user_mode ( regs ) ) { do_no_context ( regs ) ; } break ; default : if ( fault & VM_FAULT_OOM ) { if ( ! user_mode ( regs ) ) { do_no_context ( regs ) ; } else { pagefault_out_of_memory ( ) ; } } if ( fault & VM_FAULT_SIGSEGV ) { if ( ! user_mode ( regs ) ) { do_no_context ( regs ) ; } else { do_sigsegv ( regs , SEGV_MAPERR ) ; } } else { BUG ( ) ; } break ; } } 