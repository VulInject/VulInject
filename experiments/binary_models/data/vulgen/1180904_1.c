void ohci_voyager_attach ( struct device * parent , struct device * self , void * aux ) { struct ohci_voyager_softc * sc = ( ohci_voyager_softc * ) self ; struct voyager_attach_args * vaa = ( voyager_attach_args * ) aux ; struct pci_attach_args * pa = vaa -> vaa_pa ; int s ; const char * vendor ; char * devname = sc -> sc . sc_bus . bdev . dv_xname ; sc -> sc . sc_size = VOYAGER_OHCI_SIZE ; sc -> sc . iot = vaa -> vaa_mmiot ; if ( bus_space_subregion ( vaa -> vaa_mmiot , vaa -> vaa_mmioh , VOYAGER_OHCI_BASE , VOYAGER_OHCI_SIZE , & sc -> sc . ioh ) != 0 ) { printf ( ": can't map mem space\n" ) ; return ; } sc -> sc . sc_intre = bus_space_read_4 ( sc -> sc . iot , sc -> sc . ioh , OHCI_INTERRUPT_ENABLE ) ; bus_space_write_4 ( sc -> sc . iot , sc -> sc . ioh , OHCI_INTERRUPT_DISABLE , OHCI_MIE ) ; sc -> sc . sc_bus . dmatag = pa -> pa_dmat ; bus_space_barrier ( sc -> sc . iot , sc -> sc . ioh , 0 , sc -> sc . sc_size , BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE ) ; bus_space_write_4 ( sc -> sc . iot , sc -> sc . ioh , OHCI_INTERRUPT_DISABLE , OHCI_MIE ) ; s = splusb ( ) ; sc -> sc_ih = voyager_intr_establish ( parent , VOYAGER_INTR_USB_HOST , IPL_USB , ohci_intr , sc , devname ) ; printf ( ": %s, " , voyager_intr_string ( sc -> sc_ih ) ) ; vendor = pci_findvendor ( pa -> pa_id ) ; sc -> sc . sc_id_vendor = PCI_VENDOR ( pa -> pa_id ) ; if ( vendor ) { strlcpy ( sc -> sc . sc_vendor , vendor , sizeof ( sc -> sc . sc_vendor ) ) ; } else { snprintf ( sc -> sc . sc_vendor , sizeof ( sc -> sc . sc_vendor ) , "vendor 0x%04x" , PCI_VENDOR ( pa -> pa_id ) ) ; } if ( ohci_checkrev ( & sc -> sc ) != USBD_NORMAL_COMPLETION || ohci_handover ( & sc -> sc ) != USBD_NORMAL_COMPLETION ) { splx ( s ) ; return ; } sc -> sc . sc_bus . dying = 1 ; config_defer ( self , ohci_voyager_attach_deferred ) ; splx ( s ) ; } 