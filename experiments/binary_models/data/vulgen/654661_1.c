static void svc_i3c_master_start_xfer_locked ( struct svc_i3c_master * master ) { struct svc_i3c_xfer * xfer = master -> xferqueue . cur ; int ret , i ; ret = pm_runtime_resume_and_get ( master -> dev ) ; if ( ret < 0 ) { dev_err ( master -> dev , "<%s>Cannot get runtime PM.\n" , __func__ ) ; return ; } svc_i3c_master_clear_merrwarn ( master ) ; svc_i3c_master_flush_fifo ( master ) ; for ( i = 0 ; i < xfer -> ncmds ; i ++ ) { struct svc_i3c_cmd * cmd = & xfer -> cmds [ i ] ; ret = svc_i3c_master_xfer ( master , cmd -> rnw , xfer -> type , cmd -> addr , cmd -> in , cmd -> out , cmd -> len , & cmd -> read_len , cmd -> continued ) ; if ( ret ) { break ; } } pm_runtime_mark_last_busy ( master -> dev ) ; pm_runtime_put_autosuspend ( master -> dev ) ; xfer -> ret = ret ; complete ( & xfer -> comp ) ; if ( ret < 0 ) { svc_i3c_master_dequeue_xfer_locked ( master , xfer ) ; } xfer = list_first_entry_or_null ( & master -> xferqueue . list , svc_i3c_xfer , node ) ; if ( xfer ) { list_del_init ( & xfer -> node ) ; } master -> xferqueue . cur = xfer ; svc_i3c_master_start_xfer_locked ( master ) ; } 