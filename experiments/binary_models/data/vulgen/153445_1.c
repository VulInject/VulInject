static Image * ReadSCTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char magick [ 2 ] ; Image * image ; MagickBooleanType status ; double height , width ; int c ; Quantum pixel ; ssize_t i , x ; Quantum * q ; ssize_t count , y ; unsigned char buffer [ 768 ] ; size_t separations , separations_mask , units ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; if ( IsEventLogging ( ) != MagickFalse ) { ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; } image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } memset ( magick , 0 , sizeof ( magick ) ) ; memset ( buffer , 0 , sizeof ( buffer ) ) ; count = ReadBlob ( image , 80 , buffer ) ; ( void ) count ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( LocaleNCompare ( ( char * ) magick , "CT" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , "LW" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , "BM" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , "PG" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , "TX" , 2 ) != 0 ) ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , 0 ) ; } if ( ( LocaleNCompare ( ( char * ) magick , "LW" , 2 ) == 0 ) || ( LocaleNCompare ( ( char * ) magick , "BM" , 2 ) == 0 ) || ( LocaleNCompare ( ( char * ) magick , "PG" , 2 ) == 0 ) || ( LocaleNCompare ( ( char * ) magick , "TX" , 2 ) == 0 ) ) { ThrowReaderException ( CoderError , "OnlyContinuousTonePictureSupported" ) ; } count = ReadBlob ( image , 174 , buffer ) ; count = ReadBlob ( image , 768 , buffer ) ; units = 1UL * ReadBlobByte ( image ) ; if ( units == 0 ) { image -> units = PixelsPerCentimeterResolution ; } separations = 1UL * ReadBlobByte ( image ) ; separations_mask = ReadBlobMSBShort ( image ) ; count = ReadBlob ( image , 14 , buffer ) ; buffer [ 14 ] = '\0' ; height = StringToDouble ( ( char * ) buffer , ( char * * ) NULL ) ; count = ReadBlob ( image , 14 , buffer ) ; width = StringToDouble ( ( char * ) buffer , ( char * * ) NULL ) ; count = ReadBlob ( image , 12 , buffer ) ; buffer [ 12 ] = '\0' ; image -> rows = StringToUnsignedLong ( ( char * ) buffer ) ; count = ReadBlob ( image , 12 , buffer ) ; image -> columns = StringToUnsignedLong ( ( char * ) buffer ) ; count = ReadBlob ( image , 200 , buffer ) ; count = ReadBlob ( image , 768 , buffer ) ; if ( separations_mask == 0x0f ) { SetImageColorspace ( image , CMYKColorspace , exception ) ; } if ( ( image -> columns < 1 ) || ( image -> rows < 1 ) || ( width < MagickEpsilon ) || ( height < MagickEpsilon ) ) { ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } if ( EOFBlob ( image ) != MagickFalse ) { ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } image -> resolution . x = 1.0 * image -> columns / width ; image -> resolution . y = 1.0 * image -> rows / height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { return ( DestroyImageList ( image ) ) ; } ( void ) SetImageBackgroundColor ( image , exception ) ; c = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { for ( i = 0 ; i < ( ssize_t ) separations ; i ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { break ; } for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { break ; } pixel = ( Quantum ) ScaleCharToQuantum ( ( unsigned char ) c ) ; if ( image -> colorspace == CMYKColorspace ) { pixel = ( Quantum ) ( QuantumRange - pixel ) ; } switch ( i ) { case 0 : { SetPixelRed ( image , pixel , q ) ; SetPixelGreen ( image , pixel , q ) ; SetPixelBlue ( image , pixel , q ) ; break ; } case 1 : { SetPixelGreen ( image , pixel , q ) ; break ; } case 2 : { SetPixelBlue ( image , pixel , q ) ; break ; } case 3 : { if ( image -> colorspace == CMYKColorspace ) { SetPixelBlack ( image , pixel , q ) ; } break ; } } q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) { break ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) { break ; } if ( ( image -> columns % 2 ) != 0 ) { ( void ) ReadBlobByte ( image ) ; } } if ( i < ( ssize_t ) separations ) { break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) { break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } 