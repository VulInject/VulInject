krb5_mcc_generate_new ( , ) { krb5_ccache lid ; char uniquename [ 8 ] ; krb5_error_code err ; krb5_mcc_data * d ; lid = ( krb5_ccache ) malloc ( sizeof ( _krb5_ccache ) ) ; if ( lid == NULL ) { return KRB5_CC_NOMEM ; } lid -> ops = & krb5_mcc_ops ; err = k5_mutex_lock ( & krb5int_mcc_mutex ) ; if ( err ) { return err ; } while ( 1 ) { krb5_mcc_list_node * ptr ; random_string ( context , uniquename , sizeof ( uniquename ) ) ; for ( ptr = mcc_head ; ptr ; ptr = ptr -> next ) { if ( ! strcmp ( ptr -> cache -> name , uniquename ) ) { break ; } } if ( ! ptr ) { break ; } } err = new_mcc_data ( uniquename , & d ) ; k5_mutex_unlock ( & krb5int_mcc_mutex ) ; if ( err ) { krb5_xfree ( lid ) ; return err ; } lid -> data = d ; * id = lid ; krb5_change_cache ( ) ; return KRB5_OK ; } 