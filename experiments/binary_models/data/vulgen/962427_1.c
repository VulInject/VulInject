static long btrfs_ioctl_balance ( struct file * file , void __user * arg ) { struct btrfs_root * root = BTRFS_I ( file_inode ( file ) ) -> root ; struct btrfs_fs_info * fs_info = root -> fs_info ; struct btrfs_ioctl_balance_args * bargs ; struct btrfs_balance_control * bctl ; bool need_unlock ; int ret ; ret = mnt_want_write_file ( file ) ; if ( ret ) { return ret ; } again if ( ! test_and_set_bit ( BTRFS_FS_EXCL_OP , & fs_info -> flags ) ) { mutex_lock ( & fs_info -> volume_mutex ) ; mutex_lock ( & fs_info -> balance_mutex ) ; need_unlock = true ; locked } mutex_lock ( & fs_info -> balance_mutex ) ; if ( fs_info -> balance_ctl ) { if ( ! atomic_read ( & fs_info -> balance_running ) ) { mutex_unlock ( & fs_info -> balance_mutex ) ; if ( ! mutex_trylock ( & fs_info -> volume_mutex ) ) { again } mutex_lock ( & fs_info -> balance_mutex ) ; if ( fs_info -> balance_ctl && ! atomic_read ( & fs_info -> balance_running ) ) { need_unlock = false ; locked } mutex_unlock ( & fs_info -> balance_mutex ) ; mutex_unlock ( & fs_info -> volume_mutex ) ; again } else { mutex_unlock ( & fs_info -> balance_mutex ) ; ret = - EINPROGRESS ; out } } else { mutex_unlock ( & fs_info -> balance_mutex ) ; ret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS ; out } locked BUG_ON ( ! test_bit ( BTRFS_FS_EXCL_OP , & fs_info -> flags ) ) ; if ( arg ) { bargs = memdup_user ( arg , sizeof ( * bargs ) ) ; if ( IS_ERR ( bargs ) ) { ret = PTR_ERR ( bargs ) ; out_unlock } if ( bargs -> flags & BTRFS_BALANCE_RESUME ) { if ( ! fs_info -> balance_ctl ) { ret = - ENOTCONN ; out_bargs } bctl = fs_info -> balance_ctl ; spin_lock ( & fs_info -> balance_lock ) ; bctl -> flags |= BTRFS_BALANCE_RESUME ; spin_unlock ( & fs_info -> balance_lock ) ; do_balance } } else { bargs = NULL ; } if ( fs_info -> balance_ctl ) { ret = - EINPROGRESS ; out_bargs } bctl = kzalloc ( sizeof ( * bctl ) , GFP_KERNEL ) ; if ( ! bctl ) { ret = - ENOMEM ; out_bargs } bctl -> fs_info = fs_info ; if ( arg ) { memcpy ( & bctl -> data , & bargs -> data , sizeof ( bctl -> data ) ) ; memcpy ( & bctl -> meta , & bargs -> meta , sizeof ( bctl -> meta ) ) ; memcpy ( & bctl -> sys , & bargs -> sys , sizeof ( bctl -> sys ) ) ; bctl -> flags = bargs -> flags ; } else { bctl -> flags |= BTRFS_BALANCE_TYPE_MASK ; } if ( bctl -> flags & ~ ( BTRFS_BALANCE_ARGS_MASK | BTRFS_BALANCE_TYPE_MASK ) ) { ret = - EINVAL ; out_bctl } do_balance need_unlock = false ; ret = btrfs_balance ( bctl , bargs ) ; bctl = NULL ; if ( arg ) { if ( copy_to_user ( arg , bargs , sizeof ( * bargs ) ) ) { ret = - EFAULT ; } } out_bctl kfree ( bctl ) ; out_bargs kfree ( bargs ) ; out_unlock mutex_unlock ( & fs_info -> balance_mutex ) ; mutex_unlock ( & fs_info -> volume_mutex ) ; if ( need_unlock ) { clear_bit ( BTRFS_FS_EXCL_OP , & fs_info -> flags ) ; } out mnt_drop_write_file ( file ) ; return ret ; } 