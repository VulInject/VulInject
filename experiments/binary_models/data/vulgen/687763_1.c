static void ieee80211_rx_handlers ( struct ieee80211_rx_data * rx , struct sk_buff_head * frames ) { ieee80211_rx_result res = RX_DROP_MONITOR ; struct sk_buff * skb ; { res = rxh ( rx ) ; if ( res != RX_CONTINUE ) { rxh_next } } 0 ; } while ( ( skb = __skb_dequeue ( frames ) ) ) { rx -> skb = skb ; if ( WARN_ON_ONCE ( ! rx -> link ) ) { rxh_next } CALL_RXH ( ieee80211_rx_h_check_more_data ) ; CALL_RXH ( ieee80211_rx_h_uapsd_and_pspoll ) ; CALL_RXH ( ieee80211_rx_h_sta_process ) ; CALL_RXH ( ieee80211_rx_h_decrypt ) ; CALL_RXH ( ieee80211_rx_h_defragment ) ; CALL_RXH ( ieee80211_rx_h_michael_mic_verify ) ; CALL_RXH ( ieee80211_rx_h_amsdu ) ; CALL_RXH ( ieee80211_rx_h_data ) ; res = ieee80211_rx_h_ctrl ( rx , frames ) ; CALL_RXH ( ieee80211_rx_h_mgmt_check ) ; CALL_RXH ( ieee80211_rx_h_action ) ; CALL_RXH ( ieee80211_rx_h_userspace_mgmt ) ; CALL_RXH ( ieee80211_rx_h_action_post_userspace ) ; CALL_RXH ( ieee80211_rx_h_action_return ) ; CALL_RXH ( ieee80211_rx_h_ext ) ; CALL_RXH ( ieee80211_rx_h_mgmt ) ; rxh_next ieee80211_rx_handlers_result ( rx , res ) ; } spin_unlock_bh ( & rx -> local -> rx_path_lock ) ; 