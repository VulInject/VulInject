int btrfs_commit_transaction ( struct btrfs_trans_handle * trans ) { struct btrfs_fs_info * fs_info = trans -> fs_info ; struct btrfs_transaction * cur_trans = trans -> transaction ; struct btrfs_transaction * prev_trans = NULL ; int ret ; ktime_t start_time ; ktime_t interval ; ASSERT ( refcount_read ( & trans -> use_count ) == 1 ) ; btrfs_trans_state_lockdep_acquire ( fs_info , BTRFS_LOCKDEP_TRANS_COMMIT_START ) ; clear_bit ( BTRFS_FS_NEED_TRANS_COMMIT , & fs_info -> flags ) ; if ( TRANS_ABORTED ( cur_trans ) ) { ret = cur_trans -> aborted ; lockdep_trans_commit_start_release } btrfs_trans_release_metadata ( trans ) ; trans -> block_rsv = NULL ; if ( ! test_and_set_bit ( BTRFS_DELAYED_REFS_FLUSHING , & cur_trans -> delayed_refs . flags ) ) { ret = btrfs_run_delayed_refs ( trans , 0 ) ; if ( ret ) { lockdep_trans_commit_start_release } } btrfs_create_pending_block_groups ( trans ) ; if ( ! test_bit ( BTRFS_TRANS_DIRTY_BG_RUN , & cur_trans -> flags ) ) { int run_it = 0 ; mutex_lock ( & fs_info -> ro_block_group_mutex ) ; if ( ! test_and_set_bit ( BTRFS_TRANS_DIRTY_BG_RUN , & cur_trans -> flags ) ) { run_it = 1 ; } mutex_unlock ( & fs_info -> ro_block_group_mutex ) ; if ( run_it ) { ret = btrfs_start_dirty_block_groups ( trans ) ; if ( ret ) { lockdep_trans_commit_start_release } } } spin_lock ( & fs_info -> trans_lock ) ; if ( cur_trans -> state >= TRANS_STATE_COMMIT_START ) { enum btrfs_trans_state want_state = TRANS_STATE_COMPLETED ; add_pending_snapshot ( trans ) ; spin_unlock ( & fs_info -> trans_lock ) ; refcount_inc ( & cur_trans -> use_count ) ; if ( trans -> in_fsync ) { want_state = TRANS_STATE_SUPER_COMMITTED ; } btrfs_trans_state_lockdep_release ( fs_info , BTRFS_LOCKDEP_TRANS_COMMIT_START ) ; ret = btrfs_end_transaction ( trans ) ; wait_for_commit ( cur_trans , want_state ) ; if ( TRANS_ABORTED ( cur_trans ) ) { ret = cur_trans -> aborted ; } btrfs_put_transaction ( cur_trans ) ; return ret ; } cur_trans -> state = TRANS_STATE_COMMIT_START ; wake_up ( & fs_info -> transaction_blocked_wait ) ; btrfs_trans_state_lockdep_release ( fs_info , BTRFS_LOCKDEP_TRANS_COMMIT_START ) ; if ( cur_trans -> list . prev != & fs_info -> trans_list ) { enum btrfs_trans_state want_state = TRANS_STATE_COMPLETED ; if ( trans -> in_fsync ) { want_state = TRANS_STATE_SUPER_COMMITTED ; } prev_trans = list_entry ( cur_trans -> list . prev , btrfs_transaction , list ) ; if ( prev_trans -> state < want_state ) { refcount_inc ( & prev_trans -> use_count ) ; spin_unlock ( & fs_info -> trans_lock ) ; wait_for_commit ( prev_trans , want_state ) ; ret = READ_ONCE ( prev_trans -> aborted ) ; btrfs_put_transaction ( prev_trans ) ; if ( ret ) { lockdep_release } } else { spin_unlock ( & fs_info -> trans_lock ) ; } } else { spin_unlock ( & fs_info -> trans_lock ) ; if ( BTRFS_FS_ERROR ( fs_info ) ) { ret = - EROFS ; lockdep_release } } start_time = ktime_get_ns ( ) ; extwriter_counter_dec ( cur_trans , trans -> type ) ; ret = btrfs_start_delalloc_flush ( fs_info ) ; if ( ret ) { lockdep_release } ret = btrfs_run_delayed_items ( trans ) ; if ( ret ) { lockdep_release } btrfs_lockdep_release ( fs_info , btrfs_trans_num_extwriters ) ; btrfs_might_wait_for_event ( fs_info , btrfs_trans_num_extwriters ) ; wait_event ( cur_trans -> writer_wait , extwriter_counter_read ( cur_trans ) == 0 ) ; ret = btrfs_run_delayed_items ( trans ) ; if ( ret ) { btrfs_lockdep_release ( fs_info , btrfs_trans_num_writers ) ; cleanup_transaction } btrfs_wait_delalloc_flush ( fs_info ) ; btrfs_might_wait_for_event ( fs_info , btrfs_trans_pending_ordered ) ; wait_event ( cur_trans -> pending_wait , atomic_read ( & cur_trans -> pending_ordered ) == 0 ) ; btrfs_scrub_pause ( fs_info ) ; spin_lock ( & fs_info -> trans_lock ) ; add_pending_snapshot ( trans ) ; cur_trans -> state = TRANS_STATE_COMMIT_DOING ; spin_unlock ( & fs_info -> trans_lock ) ; btrfs_lockdep_release ( fs_info , btrfs_trans_num_writers ) ; btrfs_might_wait_for_event ( fs_info , btrfs_trans_num_writers ) ; wait_event ( cur_trans -> writer_wait , atomic_read ( & cur_trans -> num_writers ) == 1 ) ; btrfs_trans_state_lockdep_acquire ( fs_info , BTRFS_LOCKDEP_TRANS_COMPLETED ) ; btrfs_trans_state_lockdep_acquire ( fs_info , BTRFS_LOCKDEP_TRANS_SUPER_COMMITTED ) ; btrfs_trans_state_lockdep_acquire ( fs_info , BTRFS_LOCKDEP_TRANS_UNBLOCKED ) ; clear_bit ( BTRFS_FS_COMMIT_TRANS , & fs_info -> flags ) ; if ( TRANS_ABORTED ( cur_trans ) ) { ret = cur_trans -> aborted ; btrfs_trans_state_lockdep_release ( fs_info , BTRFS_LOCKDEP_TRANS_UNBLOCKED ) ; scrub_continue } mutex_lock ( & fs_info -> reloc_mutex ) ; ret = create_pending_snapshots ( trans ) ; if ( ret ) { unlock_reloc } ret = btrfs_run_delayed_items ( trans ) ; if ( ret ) { unlock_reloc } ret = btrfs_run_delayed_refs ( trans , ( unsigned long ) - 1 ) ; if ( ret ) { unlock_reloc } btrfs_assert_delayed_root_empty ( fs_info ) ; WARN_ON ( cur_trans != trans -> transaction ) ; ret = commit_fs_roots ( trans ) ; if ( ret ) { unlock_reloc } btrfs_free_log_root_tree ( trans , fs_info ) ; ret = btrfs_qgroup_account_extents ( trans ) ; if ( ret < 0 ) { unlock_reloc } ret = commit_cowonly_roots ( trans ) ; if ( ret ) { unlock_reloc } if ( TRANS_ABORTED ( cur_trans ) ) { ret = cur_trans -> aborted ; unlock_reloc } cur_trans = fs_info -> running_transaction ; btrfs_set_root_node ( & fs_info -> tree_root -> root_item , fs_info -> tree_root -> node ) ; list_add_tail ( & fs_info -> tree_root -> dirty_list , & cur_trans -> switch_commits ) ; btrfs_set_root_node ( & fs_info -> chunk_root -> root_item , fs_info -> chunk_root -> node ) ; list_add_tail ( & fs_info -> chunk_root -> dirty_list , & cur_trans -> switch_commits ) ; if ( btrfs_fs_incompat ( fs_info , EXTENT_TREE_V2 ) ) { btrfs_set_root_node ( & fs_info -> block_group_root -> root_item , fs_info -> block_group_root -> node ) ; list_add_tail ( & fs_info -> block_group_root -> dirty_list , & cur_trans -> switch_commits ) ; } switch_commit_roots ( trans ) ; ASSERT ( list_empty ( & cur_trans -> dirty_bgs ) ) ; ASSERT ( list_empty ( & cur_trans -> io_bgs ) ) ; update_super_roots ( fs_info ) ; btrfs_set_super_log_root ( fs_info -> super_copy , 0 ) ; btrfs_set_super_log_root_level ( fs_info -> super_copy , 0 ) ; memcpy ( fs_info -> super_for_commit , fs_info -> super_copy , sizeof ( * fs_info -> super_copy ) ) ; btrfs_commit_device_sizes ( cur_trans ) ; clear_bit ( BTRFS_FS_LOG1_ERR , & fs_info -> flags ) ; clear_bit ( BTRFS_FS_LOG2_ERR , & fs_info -> flags ) ; btrfs_trans_release_chunk_metadata ( trans ) ; mutex_lock ( & fs_info -> tree_log_mutex ) ; spin_lock ( & fs_info -> trans_lock ) ; cur_trans -> state = TRANS_STATE_UNBLOCKED ; fs_info -> running_transaction = NULL ; spin_unlock ( & fs_info -> trans_lock ) ; mutex_unlock ( & fs_info -> reloc_mutex ) ; wake_up ( & fs_info -> transaction_wait ) ; btrfs_trans_state_lockdep_release ( fs_info , BTRFS_LOCKDEP_TRANS_UNBLOCKED ) ; if ( test_bit ( BTRFS_FS_FEATURE_CHANGED , & fs_info -> flags ) && fs_info -> cleaner_kthread ) { wake_up_process ( fs_info -> cleaner_kthread ) ; } ret = btrfs_write_and_wait_transaction ( trans ) ; if ( ret ) { btrfs_handle_fs_error ( fs_info , ret , "Error while writing out transaction" ) ; mutex_unlock ( & fs_info -> tree_log_mutex ) ; scrub_continue } btrfs_free_redirty_list ( cur_trans ) ; ret = write_all_supers ( fs_info , 0 ) ; mutex_unlock ( & fs_info -> tree_log_mutex ) ; if ( ret ) { scrub_continue } cur_trans -> state = TRANS_STATE_SUPER_COMMITTED ; wake_up ( & cur_trans -> commit_wait ) ; btrfs_trans_state_lockdep_release ( fs_info , BTRFS_LOCKDEP_TRANS_SUPER_COMMITTED ) ; btrfs_finish_extent_commit ( trans ) ; if ( test_bit ( BTRFS_TRANS_HAVE_FREE_BGS , & cur_trans -> flags ) ) { btrfs_clear_space_info_full ( fs_info ) ; } fs_info -> last_trans_committed = cur_trans -> transid ; cur_trans -> state = TRANS_STATE_COMPLETED ; wake_up ( & cur_trans -> commit_wait ) ; btrfs_trans_state_lockdep_release ( fs_info , BTRFS_LOCKDEP_TRANS_COMPLETED ) ; spin_lock ( & fs_info -> trans_lock ) ; list_del_init ( & cur_trans -> list ) ; spin_unlock ( & fs_info -> trans_lock ) ; btrfs_put_transaction ( cur_trans ) ; btrfs_put_transaction ( cur_trans ) ; if ( trans -> type & __TRANS_FREEZABLE ) { sb_end_intwrite ( fs_info -> sb ) ; } trace_btrfs_transaction_commit ( fs_info ) ; interval = ktime_get_ns ( ) - start_time ; btrfs_scrub_continue ( fs_info ) ; if ( current -> journal_info == trans ) { current -> journal_info = NULL ; } kmem_cache_free ( btrfs_trans_handle_cachep , trans ) ; update_commit_stats ( fs_info , interval ) ; return ret ; unlock_reloc mutex_unlock ( & fs_info -> reloc_mutex ) ; btrfs_trans_state_lockdep_release ( fs_info , BTRFS_LOCKDEP_TRANS_UNBLOCKED ) ; scrub_continue btrfs_trans_state_lockdep_release ( fs_info , BTRFS_LOCKDEP_TRANS_SUPER_COMMITTED ) ; btrfs_trans_state_lockdep_release ( fs_info , BTRFS_LOCKDEP_TRANS_COMPLETED ) ; btrfs_scrub_continue ( fs_info ) ; cleanup_transaction btrfs_trans_release_metadata ( trans ) ; btrfs_cleanup_pending_block_groups ( trans ) ; btrfs_trans_release_chunk_metadata ( trans ) ; trans -> block_rsv = NULL ; btrfs_warn ( fs_info , "Skipping commit of aborted transaction." ) ; cleanup_transaction ( trans , ret ) ; return ret ; lockdep_release btrfs_lockdep_release ( fs_info , btrfs_trans_num_extwriters ) ; btrfs_lockdep_release ( fs_info , btrfs_trans_num_writers ) ; cleanup_transaction lockdep_trans_commit_start_release btrfs_trans_state_lockdep_release ( fs_info , BTRFS_LOCKDEP_TRANS_COMMIT_START ) ; btrfs_end_transaction ( trans ) ; return ret ; } 