void _thread_set_callbacks ( const struct thread_callbacks * cb , size_t len ) { sigset_t allmask , omask ; if ( sizeof ( * cb ) != len ) { fprintf ( stderr , "library mismatch: libc expected %zu but" " libpthread gave %zu\n" , sizeof ( * cb ) , len ) ; fflush ( stderr ) ; _exit ( 44 ) ; } sigfillset ( & allmask ) ; if ( sigprocmask ( SIG_BLOCK , & allmask , & omask ) == 0 ) { memcpy ( & _thread_cb , cb , sizeof ( _thread_cb ) ) ; _thread_cb . tc_canceled = _thread_canceled ; _thread_cb . tc_flockfile = _thread_flockfile ; _thread_cb . tc_ftrylockfile = _thread_ftrylockfile ; _thread_cb . tc_funlockfile = _thread_funlockfile ; _thread_cb . tc_malloc_lock = _thread_malloc_lock ; _thread_cb . tc_malloc_unlock = _thread_malloc_unlock ; _thread_cb . tc_atexit_lock = _thread_atexit_lock ; _thread_cb . tc_atexit_unlock = _thread_atexit_unlock ; _thread_cb . tc_atfork_lock = _thread_atfork_lock ; _thread_cb . tc_atfork_unlock = _thread_atfork_unlock ; _thread_cb . tc_arc4_lock = _thread_arc4_lock ; _thread_cb . tc_arc4_unlock = _thread_arc4_unlock ; _thread_cb . tc_mutex_lock = _thread_mutex_lock ; _thread_cb . tc_mutex_unlock = _thread_mutex_unlock ; _thread_cb . tc_mutex_destroy = _thread_mutex_destroy ; _thread_cb . tc_tag_lock = _thread_tag_lock ; _thread_cb . tc_tag_unlock = _thread_tag_unlock ; _thread_cb . tc_tag_storage = _thread_tag_storage ; } } 