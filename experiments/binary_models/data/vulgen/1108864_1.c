static irqreturn_t __gdth_interrupt ( gdth_ha_str * ha , int gdth_from_wait , int * pIndex ) { gdt6m_dpram_str __iomem * dp6m_ptr = NULL ; gdt6_dpram_str __iomem * dp6_ptr ; gdt2_dpram_str __iomem * dp2_ptr ; Scsi_Cmnd * scp ; int rval , i ; u8 IStatus ; u16 Service ; unsigned long flags = 0 ; int coalesced = FALSE ; int next = FALSE ; gdth_coal_status * pcs = NULL ; int act_int_coal = 0 ; TRACE ( ( "gdth_interrupt() IRQ %d\n" , ha -> irq ) ) ; if ( gdth_polling ) { if ( ! gdth_from_wait ) { return IRQ_HANDLED ; } } if ( ! gdth_polling ) { spin_lock_irqsave ( & ha -> smp_lock , flags ) ; } IStatus = gdth_get_status ( ha ) ; if ( IStatus == 0 ) { if ( ! gdth_polling ) { spin_unlock_irqrestore ( & ha -> smp_lock , flags ) ; } return IRQ_HANDLED ; } ++ act_ints ; if ( IStatus == COALINDEX ) { pcs = ha -> coal_stat ; coalesced = TRUE ; next = TRUE ; } { if ( coalesced ) { IStatus = ( u8 ) ( pcs -> status & 0xff ) ; } if ( ha -> type == GDT_EISA ) { if ( IStatus & 0x80 ) { IStatus &= ~ 0x80 ; ha -> status = inw ( ha -> bmic + MAILBOXREG + 8 ) ; TRACE2 ( ( "gdth_interrupt() error %d/%d\n" , IStatus , ha -> status ) ) ; } else { ha -> status = S_OK ; } ha -> info = inl ( ha -> bmic + MAILBOXREG + 12 ) ; ha -> service = inw ( ha -> bmic + MAILBOXREG + 10 ) ; ha -> info2 = inl ( ha -> bmic + MAILBOXREG + 4 ) ; outb ( 0xff , ha -> bmic + EDOORREG ) ; outb ( 0x00 , ha -> bmic + SEMA1REG ) ; } if ( ha -> type == GDT_ISA ) { dp2_ptr = ha -> brd ; if ( IStatus & 0x80 ) { IStatus &= ~ 0x80 ; ha -> status = readw ( & dp2_ptr -> u . ic . Status ) ; TRACE2 ( ( "gdth_interrupt() error %d/%d\n" , IStatus , ha -> status ) ) ; } else { ha -> status = S_OK ; } ha -> info = readl ( & dp2_ptr -> u . ic . Info [ 0 ] ) ; ha -> service = readw ( & dp2_ptr -> u . ic . Service ) ; ha -> info2 = readl ( & dp2_ptr -> u . ic . Info [ 1 ] ) ; writeb ( 0xff , & dp2_ptr -> io . irqdel ) ; writeb ( 0 , & dp2_ptr -> u . ic . Cmd_Index ) ; writeb ( 0 , & dp2_ptr -> io . Sema1 ) ; } if ( ha -> type == GDT_PCI ) { dp6_ptr = ha -> brd ; if ( IStatus & 0x80 ) { IStatus &= ~ 0x80 ; ha -> status = readw ( & dp6_ptr -> u . ic . Status ) ; TRACE2 ( ( "gdth_interrupt() error %d/%d\n" , IStatus , ha -> status ) ) ; } else { ha -> status = S_OK ; } ha -> info = readl ( & dp6_ptr -> u . ic . Info [ 0 ] ) ; ha -> service = readw ( & dp6_ptr -> u . ic . Service ) ; ha -> info2 = readl ( & dp6_ptr -> u . ic . Info [ 1 ] ) ; writeb ( 0xff , & dp6_ptr -> io . irqdel ) ; writeb ( 0 , & dp6_ptr -> u . ic . Cmd_Index ) ; writeb ( 0 , & dp6_ptr -> io . Sema1 ) ; } if ( ha -> type == GDT_PCINEW ) { if ( IStatus & 0x80 ) { IStatus &= ~ 0x80 ; ha -> status = inw ( PTR2USHORT ( & ha -> plx -> status ) ) ; TRACE2 ( ( "gdth_interrupt() error %d/%d\n" , IStatus , ha -> status ) ) ; } else { ha -> status = S_OK ; } ha -> info = inl ( PTR2USHORT ( & ha -> plx -> info [ 0 ] ) ) ; ha -> service = inw ( PTR2USHORT ( & ha -> plx -> service ) ) ; ha -> info2 = inl ( PTR2USHORT ( & ha -> plx -> info [ 1 ] ) ) ; outb ( 0xff , PTR2USHORT ( & ha -> plx -> edoor_reg ) ) ; outb ( 0x00 , PTR2USHORT ( & ha -> plx -> sema1_reg ) ) ; } if ( ha -> type == GDT_PCIMPR ) { dp6m_ptr = ha -> brd ; if ( IStatus & 0x80 ) { IStatus &= ~ 0x80 ; if ( coalesced ) { ha -> status = pcs -> ext_status & 0xffff ; } else { ha -> status = readw ( & dp6m_ptr -> i960r . status ) ; } TRACE2 ( ( "gdth_interrupt() error %d/%d\n" , IStatus , ha -> status ) ) ; } else { ha -> status = S_OK ; } if ( coalesced ) { ha -> info = pcs -> info0 ; ha -> info2 = pcs -> info1 ; ha -> service = ( pcs -> ext_status >> 16 ) & 0xffff ; } else { ha -> info = readl ( & dp6m_ptr -> i960r . info [ 0 ] ) ; ha -> service = readw ( & dp6m_ptr -> i960r . service ) ; ha -> info2 = readl ( & dp6m_ptr -> i960r . info [ 1 ] ) ; } if ( IStatus == ASYNCINDEX ) { if ( ha -> service != SCREENSERVICE && ( ha -> fw_vers & 0xff ) >= 0x1a ) { ha -> dvr . severity = readb ( & ( ( gdt6m_dpram_str __iomem * ) ha -> brd ) -> i960r . severity ) ; for ( i = 0 ; i < 256 ; ++ i ) { ha -> dvr . event_string [ i ] = readb ( & ( ( gdt6m_dpram_str __iomem * ) ha -> brd ) -> i960r . evt_str [ i ] ) ; if ( ha -> dvr . event_string [ i ] == 0 ) { break ; } } } } if ( ! coalesced ) { writeb ( 0xff , & dp6m_ptr -> i960r . edoor_reg ) ; writeb ( 0 , & dp6m_ptr -> i960r . sema1_reg ) ; } } else { TRACE2 ( ( "gdth_interrupt() unknown controller type\n" ) ) ; if ( ! gdth_polling ) { spin_unlock_irqrestore ( & ha -> smp_lock , flags ) ; } return IRQ_HANDLED ; } TRACE ( ( "gdth_interrupt() index %d stat %d info %d\n" , IStatus , ha -> status , ha -> info ) ) ; if ( gdth_from_wait ) { * pIndex = ( int ) IStatus ; } if ( IStatus == ASYNCINDEX ) { TRACE2 ( ( "gdth_interrupt() async. event\n" ) ) ; gdth_async_event ( ha ) ; if ( ! gdth_polling ) { spin_unlock_irqrestore ( & ha -> smp_lock , flags ) ; } gdth_next ( ha ) ; return IRQ_HANDLED ; } if ( IStatus == SPEZINDEX ) { TRACE2 ( ( "Service unknown or not initialized !\n" ) ) ; ha -> dvr . size = sizeof ( ha -> dvr . eu . driver ) ; ha -> dvr . eu . driver . ionode = ha -> hanum ; gdth_store_event ( ha , ES_DRIVER , 4 , & ha -> dvr ) ; if ( ! gdth_polling ) { spin_unlock_irqrestore ( & ha -> smp_lock , flags ) ; } return IRQ_HANDLED ; } scp = ha -> cmd_tab [ IStatus - 2 ] . cmnd ; Service = ha -> cmd_tab [ IStatus - 2 ] . service ; ha -> cmd_tab [ IStatus - 2 ] . cmnd = UNUSED_CMND ; if ( scp == UNUSED_CMND ) { TRACE2 ( ( "gdth_interrupt() index to unused command (%d)\n" , IStatus ) ) ; ha -> dvr . size = sizeof ( ha -> dvr . eu . driver ) ; ha -> dvr . eu . driver . ionode = ha -> hanum ; ha -> dvr . eu . driver . index = IStatus ; gdth_store_event ( ha , ES_DRIVER , 1 , & ha -> dvr ) ; if ( ! gdth_polling ) { spin_unlock_irqrestore ( & ha -> smp_lock , flags ) ; } return IRQ_HANDLED ; } if ( scp == INTERNAL_CMND ) { TRACE ( ( "gdth_interrupt() answer to internal command\n" ) ) ; if ( ! gdth_polling ) { spin_unlock_irqrestore ( & ha -> smp_lock , flags ) ; } return IRQ_HANDLED ; } TRACE ( ( "gdth_interrupt() sync. status\n" ) ) ; rval = gdth_sync_event ( ha , Service , IStatus , scp ) ; if ( ! gdth_polling ) { spin_unlock_irqrestore ( & ha -> smp_lock , flags ) ; } if ( rval == 2 ) { gdth_putq ( ha , scp , gdth_cmnd_priv ( scp ) -> priority ) ; } if ( rval == 1 ) { gdth_scsi_done ( scp ) ; } if ( coalesced ) { ++ pcs ; ++ act_int_coal ; if ( act_int_coal > max_int_coal ) { max_int_coal = act_int_coal ; printk ( "GDT: max_int_coal = %d\n" , ( u16 ) max_int_coal ) ; } } } next ; if ( ha -> type == GDT_PCIMPR && coalesced ) { writeb ( 0xff , & dp6m_ptr -> i960r . edoor_reg ) ; writeb ( 0 , & dp6m_ptr -> i960r . sema1_reg ) ; } gdth_next ( ha ) ; return IRQ_HANDLED ; } 