static void i_mac_notify_thread ( void * arg ) { mac_impl_t * mip = arg ; callb_cpr_t cprinfo ; mac_cb_t * mcb ; mac_cb_info_t * mcbi ; mac_notify_cb_t * mncb ; mcbi = & mip -> mi_notify_cb_info ; CALLB_CPR_INIT ( & cprinfo , mcbi -> mcbi_lockp , callb_generic_cpr , "i_mac_notify_thread" ) ; mutex_enter ( mcbi -> mcbi_lockp ) ; for ( ; ; ) { uint32_t bits ; uint32_t type ; bits = mip -> mi_notify_bits ; if ( bits == 0 ) { CALLB_CPR_SAFE_BEGIN ( & cprinfo ) ; cv_wait ( & mcbi -> mcbi_cv , mcbi -> mcbi_lockp ) ; CALLB_CPR_SAFE_END ( & cprinfo , mcbi -> mcbi_lockp ) ; continue ; } mip -> mi_notify_bits = 0 ; if ( ( bits & ( 1 << MAC_NNOTE ) ) != 0 ) { ASSERT ( mip -> mi_state_flags & MIS_DISABLED ) ; break ; } mutex_exit ( mcbi -> mcbi_lockp ) ; if ( ( bits & ( 1 << MAC_NOTE_LOWLINK ) ) != 0 ) { link_state_t newstate ; mac_handle_t mh ; i_mac_log_link_state ( mip ) ; newstate = mip -> mi_lowlinkstate ; if ( mip -> mi_bridge_link != NULL ) { mutex_enter ( & mip -> mi_bridge_lock ) ; if ( ( mh = mip -> mi_bridge_link ) != NULL ) { newstate = mac_bridge_ls_cb ( mh , newstate ) ; } mutex_exit ( & mip -> mi_bridge_lock ) ; } if ( newstate != mip -> mi_linkstate ) { mip -> mi_linkstate = newstate ; bits |= 1 << MAC_NOTE_LINK ; } } if ( ( bits & ( 1 << MAC_NOTE_CAPAB_CHG ) ) != 0 ) { mac_perim_handle_t mph ; mac_handle_t mh = ( mac_handle_t ) mip ; mac_perim_enter_by_mh ( mh , & mph ) ; mip -> mi_tx_cksum_flags = mac_features_to_flags ( mh ) ; mac_perim_exit ( mph ) ; } for ( type = 0 ; type < MAC_NNOTE ; type ++ ) { if ( ( bits & ( 1 << type ) ) == 0 ) { continue ; } MAC_CALLBACK_WALKER_INC ( & mip -> mi_notify_cb_info ) ; for ( mcb = mip -> mi_notify_cb_list ; mcb != NULL ; mcb = mcb -> mcb_nextp ) { mncb = ( mac_notify_cb_t * ) mcb -> mcb_objp ; mncb -> mncb_fn ( mncb -> mncb_arg , type ) ; } MAC_CALLBACK_WALKER_DCR ( & mip -> mi_notify_cb_info , & mip -> mi_notify_cb_list ) ; } mutex_enter ( mcbi -> mcbi_lockp ) ; } mip -> mi_state_flags |= MIS_NOTIFY_DONE ; cv_broadcast ( & mcbi -> mcbi_cv ) ; CALLB_CPR_EXIT ( & cprinfo ) ; thread_exit ( ) ; } 