int pv_get_hdr_helper ( sip_msg_t * msg , pv_param_t * param , pv_value_t * res , pv_value_t * tv , int idx , int idxf ) { struct hdr_field * hf ; struct hdr_field * hf0 ; char * p , * p_ini ; int n , p_size ; if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) { LM_ERR ( "error parsing headers\n" ) ; return pv_get_null ( msg , param , res ) ; } for ( hf = msg -> headers ; hf ; hf = hf -> next ) { if ( tv -> flags == 0 ) { if ( tv -> ri == hf -> type ) { break ; } } else { if ( tv -> rs . len == 1 && tv -> rs . s [ 0 ] == '*' ) { break ; } if ( cmp_hdrname_str ( & hf -> name , & tv -> rs ) == 0 ) { break ; } } } if ( hf == NULL ) { return pv_get_null ( msg , param , res ) ; } res -> flags = PV_VAL_STR ; if ( idx == 0 && ( idxf == PV_IDX_INT || idxf == PV_IDX_NONE ) ) { res -> rs = hf -> body ; return 0 ; } if ( idxf == PV_IDX_ALL ) { p_ini = pv_get_buffer ( ) ; p = p_ini ; p_size = pv_get_buffer_size ( ) ; { if ( p != p_ini ) { if ( p - p_ini + PV_FIELD_DELIM_LEN + 1 > p_size ) { LM_ERR ( "local buffer length exceeded\n" ) ; return pv_get_null ( msg , param , res ) ; } memcpy ( p , PV_HDR_DELIM , PV_HDR_DELIM_LEN ) ; p += PV_HDR_DELIM_LEN ; } if ( p - p_ini + hf -> body . len + 1 > p_size ) { LM_ERR ( "local buffer length exceeded [%d/%d]!\n" , ( int ) ( p - p_ini + hf -> body . len + 1 ) , hf -> body . len ) ; return pv_get_null ( msg , param , res ) ; } memcpy ( p , hf -> body . s , hf -> body . len ) ; p += hf -> body . len ; for ( hf = hf -> next ; hf ; hf = hf -> next ) { if ( tv -> flags == 0 ) { if ( tv -> ri == hf -> type ) { break ; } } else { if ( tv -> rs . len == 1 && tv -> rs . s [ 0 ] == '*' ) { break ; } if ( cmp_hdrname_str ( & hf -> name , & tv -> rs ) == 0 ) { break ; } } } } hf ; res -> rs . s = p_ini ; res -> rs . len = p - p_ini ; return 0 ; } hf0 = 0 ; if ( idx < 0 ) { n = 1 ; for ( hf0 = hf -> next ; hf0 ; hf0 = hf0 -> next ) { if ( tv -> flags == 0 ) { if ( tv -> ri == hf0 -> type ) { n ++ ; } } else { if ( tv -> rs . len == 1 && tv -> rs . s [ 0 ] == '*' ) { n ++ ; } if ( cmp_hdrname_str ( & hf0 -> name , & tv -> rs ) == 0 ) { n ++ ; } } } idx = - idx ; if ( idx > n ) { LM_DBG ( "index out of range\n" ) ; return pv_get_null ( msg , param , res ) ; } idx = n - idx ; if ( idx == 0 ) { res -> rs = hf -> body ; return 0 ; } } n = 0 ; while ( n < idx ) { for ( hf0 = hf -> next ; hf0 ; hf0 = hf0 -> next ) { if ( tv -> flags == 0 ) { if ( tv -> ri == hf0 -> type ) { n ++ ; } } else { if ( tv -> rs . len == 1 && tv -> rs . s [ 0 ] == '*' ) { n ++ ; } if ( cmp_hdrname_str ( & hf0 -> name , & tv -> rs ) == 0 ) { n ++ ; } } if ( n == idx ) { break ; } } if ( hf0 == NULL ) { break ; } } LM_DBG ( "index out of range\n" ) ; return pv_get_null ( msg , param , res ) ; } 