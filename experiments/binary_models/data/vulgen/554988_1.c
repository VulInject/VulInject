int schd_get_queues ( void ) { int ret ; QueueList * qptr ; ret = schd_get_queue_limits ( schd_SubmitQueue -> queue ) ; if ( ret ) { DBPRT ( ( "schd_get_queues: get_queue_limits for %s failed.\n" , schd_SubmitQueue -> queue -> qname ) ) ; return ( - 1 ) ; } for ( qptr = schd_BatchQueues ; qptr != NULL ; qptr = qptr -> next ) { ret = schd_get_queue_limits ( qptr -> queue ) ; if ( ret ) { DBPRT ( ( "schd_get_queues: get_queue_limits for %s failed.\n" , qptr -> queue -> qname ) ) ; } } return ( 0 ) ; } int schd_get_queue_limits ( Queue * queue ) { char * id = "schd_get_queue_limits" ; int istrue ; int local_errno = 0 ; Batch_Status * bs ; AttrList * attr ; static AttrList alist [ ] { { & alist [ 1 ] ATTR_start "" "" } { & alist [ 2 ] ATTR_enable "" "" } { & alist [ 3 ] ATTR_count "" "" } { & alist [ 4 ] ATTR_maxuserrun "" "" } { & alist [ 5 ] ATTR_rescavail "" "" } { & alist [ 6 ] ATTR_rescassn "" "" } { & alist [ 7 ] ATTR_rescdflt "" "" } { & alist [ 8 ] ATTR_rescmax "" "" } { & alist [ 9 ] ATTR_rescmin "" "" } { & alist [ 10 ] ATTR_acluren "" "" } { & alist [ 11 ] ATTR_acluser "" "" } { NULL ATTR_maxrun "" "" } } ; ; queue -> running = UNSPECIFIED ; queue -> queued = UNSPECIFIED ; queue -> maxrun = UNSPECIFIED ; queue -> userrun = UNSPECIFIED ; queue -> ncpus_max = UNSPECIFIED ; queue -> ncpus_min = UNSPECIFIED ; queue -> ncpus_default = UNSPECIFIED ; queue -> ncpus_assn = UNSPECIFIED ; queue -> mem_assn = UNSPECIFIED ; queue -> mem_max = UNSPECIFIED ; queue -> mem_min = UNSPECIFIED ; queue -> mem_default = UNSPECIFIED ; queue -> wallt_max = UNSPECIFIED ; queue -> wallt_min = UNSPECIFIED ; queue -> wallt_default = UNSPECIFIED ; queue -> rsrcs = NULL ; queue -> flags = 0 ; if ( queue -> rsrcs ) { DBPRT ( ( "%s: found resource list on queue '%s'!  Freeing them...\n" , id , queue -> qname ) ) ; cleanup_rsrcs ( queue -> rsrcs ) ; queue -> rsrcs = NULL ; } if ( queue -> jobs ) { DBPRT ( ( "%s: found jobs on queue '%s'!  Freeing them...\n" , id , queue -> qname ) ) ; schd_free_jobs ( queue -> jobs ) ; queue -> jobs = NULL ; } if ( queue -> useracl ) { DBPRT ( ( "%s: found user ACL list on queue '%s'!  Freeing it...\n" , id , queue -> qname ) ) ; schd_free_useracl ( queue -> useracl ) ; queue -> useracl = NULL ; } if ( ( bs = pbs_statque_err ( connector , queue -> qname , alist , NULL , & local_errno ) ) == NULL ) { sprintf ( log_buffer , "pbs_statque failed, \"%s\" %d" , queue -> qname , local_errno ) ; log_record ( PBSEVENT_ERROR , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; return ( - 1 ) ; } for ( attr = bs -> attribs ; attr != NULL ; attr = attr -> next ) { if ( ! strcmp ( attr -> name , ATTR_start ) ) { if ( schd_val2bool ( attr -> value , & istrue ) == 0 ) { if ( istrue ) { queue -> flags &= ~ QFLAGS_STOPPED ; } else { queue -> flags |= QFLAGS_STOPPED ; } } else { DBPRT ( ( "%s: couldn't parse attr %s value %s to boolean\n" , id , attr -> name , attr -> value ) ) ; } continue ; } if ( ! strcmp ( attr -> name , ATTR_enable ) ) { if ( schd_val2bool ( attr -> value , & istrue ) == 0 ) { if ( istrue ) { queue -> flags &= ~ QFLAGS_DISABLED ; } else { queue -> flags |= QFLAGS_DISABLED ; } } else { DBPRT ( ( "%s: couldn't parse attr %s value %s to boolean\n" , id , attr -> name , attr -> value ) ) ; } continue ; } if ( ! strcmp ( attr -> name , ATTR_count ) ) { queue -> queued = schd_how_many ( attr -> value , SC_QUEUED ) ; queue -> running = schd_how_many ( attr -> value , SC_RUNNING ) ; continue ; } if ( ! strcmp ( attr -> name , ATTR_maxrun ) ) { queue -> maxrun = atoi ( attr -> value ) ; continue ; } if ( ! strcmp ( attr -> name , ATTR_maxuserrun ) ) { queue -> userrun = atoi ( attr -> value ) ; continue ; } if ( ! strcmp ( attr -> name , ATTR_acluren ) ) { if ( schd_val2bool ( attr -> value , & istrue ) == 0 ) { if ( istrue ) { queue -> flags |= QFLAGS_USER_ACL ; } else { queue -> flags &= ~ QFLAGS_USER_ACL ; } } else { DBPRT ( ( "%s: couldn't parse attr %s value %s to boolean\n" , id , attr -> name , attr -> value ) ) ; } continue ; } if ( ! strcmp ( attr -> name , ATTR_acluser ) ) { if ( queue -> useracl ) { DBPRT ( ( "queue %s acluser already set!\n" , queue -> qname ) ) ; schd_free_useracl ( queue -> useracl ) ; } queue -> useracl = schd_create_useracl ( attr -> value ) ; continue ; } if ( ! strcmp ( attr -> name , ATTR_rescmax ) ) { if ( ! strcmp ( "mem" , attr -> resource ) ) { queue -> mem_max = schd_val2byte ( attr -> value ) ; continue ; } if ( ! strcmp ( "ncpus" , attr -> resource ) ) { queue -> ncpus_max = atoi ( attr -> value ) ; continue ; } if ( ! strcmp ( "walltime" , attr -> resource ) ) { queue -> wallt_max = schd_val2sec ( attr -> value ) ; continue ; } continue ; } if ( ! strcmp ( attr -> name , ATTR_rescmin ) ) { if ( ! strcmp ( "mem" , attr -> resource ) ) { queue -> mem_min = schd_val2byte ( attr -> value ) ; continue ; } if ( ! strcmp ( "ncpus" , attr -> resource ) ) { queue -> ncpus_min = atoi ( attr -> value ) ; continue ; } if ( ! strcmp ( "walltime" , attr -> resource ) ) { queue -> wallt_min = schd_val2sec ( attr -> value ) ; continue ; } continue ; } if ( ! strcmp ( attr -> name , ATTR_rescassn ) ) { if ( ! strcmp ( "mem" , attr -> resource ) ) { queue -> mem_assn = schd_val2byte ( attr -> value ) ; continue ; } if ( ! strcmp ( "ncpus" , attr -> resource ) ) { queue -> ncpus_assn = atoi ( attr -> value ) ; } continue ; } if ( ! strcmp ( attr -> name , ATTR_rescdflt ) ) { if ( ! strcmp ( "mem" , attr -> resource ) ) { queue -> mem_default = schd_val2byte ( attr -> value ) ; continue ; } if ( ! strcmp ( "ncpus" , attr -> resource ) ) { queue -> ncpus_default = atoi ( attr -> value ) ; continue ; } if ( ! strcmp ( "walltime" , attr -> resource ) ) { queue -> wallt_default = schd_val2sec ( attr -> value ) ; } } } pbs_statfree ( bs ) ; return ( 0 ) ; } int schd_get_queue_util ( void ) { int ret ; char * id = "get_queue_util" ; QueueList * qptr ; void schd_calc_suspended_jobs ( void ) ; get_node_status ( ) ; qptr = schd_SubmitQueue ; ret = schd_get_queue_info ( qptr -> queue ) ; if ( ret ) { DBPRT ( ( "get_queue_util: get_queue_info for %s failed.\n" , schd_SubmitQueue -> queue -> qname ) ) ; } for ( qptr = schd_BatchQueues ; qptr != NULL ; qptr = qptr -> next ) { if ( qptr -> queue -> flags & QFLAGS_NODEDOWN ) { sprintf ( log_buffer , "Skipping UNAVAILABLE node %s" , qptr -> queue -> exechost ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; log_record ( PBSEVENT_ERROR , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; } else { ret = schd_get_queue_info ( qptr -> queue ) ; if ( ret ) { DBPRT ( ( "get_queue_util: get_queue_info for %s failed.\n" , qptr -> queue -> qname ) ) ; } } } schd_calc_suspended_jobs ( ) ; return ( 0 ) ; } int schd_get_queue_info ( Queue * queue ) { char * id = "get_queue_info" ; double tmpval ; int moved = 0 ; if ( schd_AllJobs ) { moved = queue_claim_jobs ( queue , & schd_AllJobs ) ; } if ( moved < 0 ) { sprintf ( log_buffer , "%s: WARNING! Queue '%s' failed to claim jobs." , id , queue -> qname ) ; log_record ( PBSEVENT_ERROR , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; } if ( queue -> ncpus_assn == UNSPECIFIED ) { queue -> ncpus_assn = 0 ; } if ( queue -> mem_assn == UNSPECIFIED ) { queue -> mem_assn = 0 ; } if ( queue -> running == UNSPECIFIED ) { queue -> running = 0 ; } if ( strcmp ( queue -> qname , schd_SubmitQueue -> queue -> qname ) != 0 && ( queue -> flags & QFLAGS_STOPPED ) == 0 ) { queue -> rsrcs = schd_get_resources ( queue -> exechost ) ; if ( queue -> rsrcs != NULL ) { queue -> rsrcs -> ncpus_alloc += queue -> ncpus_assn ; queue -> rsrcs -> mem_alloc += queue -> mem_assn ; if ( queue -> rsrcs -> freemem < 1 ) { tmpval = queue -> rsrcs -> mem_total - queue -> rsrcs -> mem_alloc ; if ( tmpval < 1 ) { queue -> rsrcs -> freemem = 0 ; } else { queue -> rsrcs -> freemem = tmpval ; } } queue -> rsrcs -> njobs += queue -> running ; queue -> ncpus_max = ( queue -> ncpus_max <= queue -> rsrcs -> ncpus_total ?queue -> ncpus_max : queue -> rsrcs -> ncpus_total ) ; } else { ( void ) sprintf ( log_buffer , "Can't get resources for %s@%s - marking unavailable." , queue -> qname , queue -> exechost ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; queue -> flags |= QFLAGS_NODEDOWN ; } } return ( 0 ) ; } int queue_claim_jobs ( Queue * queue , Job * * joblist_ptr ) { Job * job , * prev , * next , * qtail , * longest ; int moved ; int running , queued , held , other ; longest = NULL ; running = 0 ; queued = 0 ; held = 0 ; other = 0 ; moved = 0 ; qtail = NULL ; if ( queue -> jobs ) { for ( qtail = queue -> jobs ; qtail -> next != NULL ; qtail = qtail -> next ) { } } prev = NULL ; for ( job = * joblist_ptr ; job != NULL ; job = next ) { next = job -> next ; if ( strcmp ( job -> qname , queue -> qname ) ) { prev = job ; continue ; } if ( job == * joblist_ptr ) { * joblist_ptr = next ; prev = * joblist_ptr ; } else { prev -> next = job -> next ; } if ( qtail == NULL ) { queue -> jobs = job ; } else { qtail -> next = job ; } qtail = job ; job -> next = NULL ; if ( job -> flags & JFLAGS_QNAME_LOCAL ) { free ( job -> qname ) ; job -> qname = queue -> qname ; job -> queue = queue ; job -> flags &= ~ JFLAGS_QNAME_LOCAL ; } moved ++ ; switch ( job -> state ) { case 'R' : running ++ ; if ( job -> time_left < 0 ) { job -> time_left = JOB_OVERTIME_SLOP ; } if ( ( longest == NULL ) || ( job -> time_left > longest -> time_left ) ) { longest = job ; } break ; case 'Q' : queued ++ ; break ; case 'H' : held ++ ; break ; default : other ++ ; break ; } } if ( longest ) { queue -> empty_by = schd_TimeNow + longest -> time_left ; } else { queue -> empty_by = 0 ; } return ( moved ) ; } int queue_sanity ( Queue * queue ) { char * id = "queue_sanity" ; Job * job ; int queued , running ; int is_sane ; is_sane = 1 ; queued = running = 0 ; for ( job = queue -> jobs ; job != NULL ; job = job -> next ) { switch ( job -> state ) { case 'R' : running ++ ; break ; case 'Q' : queued ++ ; break ; default : break ; } } if ( queue -> running != running ) { sprintf ( log_buffer , "Queue '%s' expected %d running jobs, but found %d" , queue -> qname , queue -> running , running ) ; log_record ( PBSEVENT_ERROR , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; is_sane = 0 ; } if ( queue -> queued != queued ) { sprintf ( log_buffer , "Queue '%s' expected %d queued jobs, but found %d" , queue -> qname , queue -> queued , queued ) ; log_record ( PBSEVENT_ERROR , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; is_sane = 0 ; } if ( queue -> running && ( queue -> empty_by < schd_TimeNow ) ) { sprintf ( log_buffer , "Queue '%s' was expected to be empty %ld seconds ago" , queue -> qname , ( long ) ( schd_TimeNow - queue -> empty_by ) ) ; log_record ( PBSEVENT_ERROR , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; is_sane = 0 ; } return ( is_sane ) ; } int get_node_status ( void ) { char * id = "get_node_status" ; QueueList * qptr ; int local_errno = 0 ; Batch_Status * bs , * bsp ; AttrList * attr ; static AttrList alist [ ] { { NULL ATTR_NODE_state "" "" } } ; ; if ( ( bs = pbs_statnode_err ( connector , NULL , alist , NULL , & local_errno ) ) == NULL ) { sprintf ( log_buffer , "pbs_statnode failed: %d" , local_errno ) ; log_record ( PBSEVENT_ERROR , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; return ( - 1 ) ; } for ( qptr = schd_BatchQueues ; qptr != NULL ; qptr = qptr -> next ) { qptr -> queue -> flags |= QFLAGS_NODEDOWN ; } for ( bsp = bs ; bsp != NULL ; bsp = bsp -> next ) { for ( attr = bsp -> attribs ; attr != NULL ; attr = attr -> next ) { if ( ( strstr ( attr -> value , ND_free ) ) || ( strstr ( attr -> value , ND_busy ) ) || ( strstr ( attr -> value , ND_reserve ) ) || ( strstr ( attr -> value , "job-" ) ) ) { for ( qptr = schd_BatchQueues ; qptr != NULL ; qptr = qptr -> next ) { if ( strstr ( qptr -> queue -> exechost , bsp -> name ) ) { qptr -> queue -> flags &= ~ QFLAGS_NODEDOWN ; break ; } } } else { sprintf ( log_buffer , "%s (state=%s)" , bsp -> name , attr -> value ) ; log_record ( PBSEVENT_ERROR , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; } } } pbs_statfree ( bs ) ; return ( 0 ) ; } size_t schd_get_queue_memory ( char * qName ) { char * id = "schd_get_queue_limits" ; size_t mem_max , mem_default ; Batch_Status * bs ; int local_errno = 0 ; AttrList * attr ; static AttrList alist [ ] { { & alist [ 1 ] ATTR_rescdflt "" "" } { NULL ATTR_rescmax "" "" } } ; ; mem_default = ( size_t ) 0 ; mem_max = ( size_t ) 0 ; if ( ( bs = pbs_statque_err ( connector , qName , alist , NULL , & local_errno ) ) == NULL ) { sprintf ( log_buffer , "pbs_statque failed, \"%s\" %d" , qName , local_errno ) ; log_record ( PBSEVENT_ERROR , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; return ( UNSPECIFIED ) ; } for ( attr = bs -> attribs ; attr != NULL ; attr = attr -> next ) { if ( ! strcmp ( attr -> name , ATTR_rescmax ) ) { if ( ! strcmp ( "mem" , attr -> resource ) ) { mem_max = schd_val2byte ( attr -> value ) ; continue ; } continue ; } if ( ! strcmp ( attr -> name , ATTR_rescdflt ) ) { if ( ! strcmp ( "mem" , attr -> resource ) ) { mem_default = schd_val2byte ( attr -> value ) ; continue ; } } } pbs_statfree ( bs ) ; if ( mem_default != ( size_t ) 0 ) { return ( mem_default ) ; } if ( mem_max != ( size_t ) 0 ) { return ( mem_max ) ; } return ( UNSPECIFIED ) ; } void schd_calc_suspended_jobs ( void ) { Job * job , * next ; Queue * queue , * schd_find_queue ( char * exechost ) ; for ( job = schd_SubmitQueue -> queue -> jobs ; job != NULL ; job = next ) { next = job -> next ; if ( job -> flags & JFLAGS_SUSPENDED ) { queue = schd_find_queue ( job -> exechost ) ; if ( queue -> flags & QFLAGS_NODEDOWN ) { continue ; } } } } Queue * schd_find_queue ( char * exechost ) { QueueList * qptr ; for ( qptr = schd_BatchQueues ; qptr != NULL ; qptr = qptr -> next ) { if ( ! strcmp ( qptr -> queue -> exechost , exechost ) ) { return ( qptr -> queue ) ; } } return ( NULL ) ; } 