static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; AudioPhaseMeterContext * s = ctx -> priv ; AVFilterLink * outlink = s -> do_video ?ctx -> outputs [ 1 ] : NULL ; AVFilterLink * aoutlink = ctx -> outputs [ 0 ] ; AVDictionary * * metadata ; const int rc = s -> contrast [ 0 ] ; const int gc = s -> contrast [ 1 ] ; const int bc = s -> contrast [ 2 ] ; float fphase = 0 ; AVFrame * out ; uint8_t * dst ; int i , ret ; int mono_measurement ; int out_phase_measurement ; float tolerance = 1.0f - s -> tolerance ; float angle = cosf ( s -> angle / 180.0f * M_PI ) ; if ( s -> do_video && ( ! s -> out || s -> out -> width != outlink -> w || s -> out -> height != outlink -> h ) ) { av_frame_free ( & s -> out ) ; s -> out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! s -> out ) { return AVERROR ( ENOMEM ) ; } out = s -> out ; for ( i = 0 ; i < outlink -> h ; i ++ ) { memset ( out -> data [ 0 ] + i * out -> linesize [ 0 ] , 0 , outlink -> w * 4 ) ; } } if ( s -> do_video ) { ret = ff_inlink_make_frame_writable ( outlink , & s -> out ) ; if ( ret < 0 ) { av_frame_free ( & in ) ; return ret ; } out = s -> out ; for ( i = outlink -> h - 1 ; i >= 10 ; i -- ) { memmove ( out -> data [ 0 ] + ( i ) * out -> linesize [ 0 ] , out -> data [ 0 ] + ( i - 1 ) * out -> linesize [ 0 ] , outlink -> w * 4 ) ; } for ( i = 0 ; i < outlink -> w ; i ++ ) { AV_WL32 ( out -> data [ 0 ] + i * 4 , 0 ) ; } } for ( i = 0 ; i < in -> nb_samples ; i ++ ) { const float * src = ( float * ) in -> data [ 0 ] + i * 2 ; const float f = src [ 0 ] * src [ 1 ] / ( src [ 0 ] * src [ 0 ] + src [ 1 ] * src [ 1 ] ) * 2 ; const float phase = isnan ( f ) ?1 : f ; const int x = get_x ( phase , s -> w ) ; if ( s -> do_video ) { dst = out -> data [ 0 ] + x * 4 ; dst [ 0 ] = FFMIN ( 255 , dst [ 0 ] + rc ) ; dst [ 1 ] = FFMIN ( 255 , dst [ 1 ] + gc ) ; dst [ 2 ] = FFMIN ( 255 , dst [ 2 ] + bc ) ; dst [ 3 ] = 255 ; } fphase += phase ; } fphase /= in -> nb_samples ; s -> phase = fphase ; if ( s -> do_video ) { if ( s -> draw_median_phase ) { dst = out -> data [ 0 ] + get_x ( fphase , s -> w ) * 4 ; AV_WL32 ( dst , AV_RL32 ( s -> mpc ) ) ; } for ( i = 1 ; i < 10 && i < outlink -> h ; i ++ ) { memcpy ( out -> data [ 0 ] + i * out -> linesize [ 0 ] , out -> data [ 0 ] , outlink -> w * 4 ) ; } } metadata = & in -> metadata ; if ( metadata ) { uint8_t value [ 128 ] ; snprintf ( value , sizeof ( value ) , "%f" , fphase ) ; add_metadata ( in , "phase" , value ) ; } if ( s -> do_phasing_detection ) { s -> time_base = inlink -> time_base ; s -> frame_end = in -> pts + av_rescale_q ( in -> nb_samples , ( AVRational ) { 1 in -> sample_rate } , inlink -> time_base ) ; mono_measurement = ( tolerance - fphase ) < FLT_EPSILON ; out_phase_measurement = ( angle - fphase ) > FLT_EPSILON ; update_mono_detection ( s , in , mono_measurement ) ; update_out_phase_detection ( s , in , out_phase_measurement ) ; } if ( s -> do_video ) { AVFrame * clone ; s -> out -> pts = in -> pts ; s -> out -> duration = av_rescale_q ( 1 , av_inv_q ( outlink -> frame_rate ) , outlink -> time_base ) ; clone = av_frame_clone ( s -> out ) ; if ( ! clone ) { return AVERROR ( ENOMEM ) ; } ff_filter_frame ( outlink , clone ) ; } return ff_filter_frame ( aoutlink , in ) ; } 