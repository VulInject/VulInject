static void test_handshake ( void ) { quicly_address_t dest , src ; struct iovec packets [ 8 ] ; uint8_t packetsbuf [ PTLS_ELEMENTSOF ( packets ) * quic_ctx . transport_params . max_udp_payload_size ] ; size_t num_packets , num_decoded ; quicly_decoded_packet_t decoded [ PTLS_ELEMENTSOF ( packets ) * 4 ] ; int ret , i ; ret = quicly_connect ( & client , & quic_ctx , "example.com" , & fake_address . sa , NULL , new_master_id ( ) , ptls_iovec_init ( NULL , 0 ) , NULL , NULL , NULL ) ; ok ( ret == 0 ) ; num_packets = PTLS_ELEMENTSOF ( packets ) ; ret = quicly_send ( client , & dest , & src , packets , & num_packets , packetsbuf , sizeof ( packetsbuf ) ) ; ok ( ret == 0 ) ; ok ( num_packets == 1 ) ; ok ( packets [ 0 ] . iov_len == 1280 ) ; num_decoded = decode_packets ( decoded , packets , num_packets ) ; ok ( num_decoded == 1 ) ; ret = quicly_accept ( & server , & quic_ctx , NULL , & fake_address . sa , decoded , NULL , new_master_id ( ) , NULL , NULL ) ; ok ( ret == 0 ) ; ok ( quicly_get_state ( server ) == QUICLY_STATE_CONNECTED ) ; ok ( quicly_connection_is_ready ( server ) ) ; num_packets = PTLS_ELEMENTSOF ( packets ) ; ret = quicly_send ( server , & dest , & src , packets , & num_packets , packetsbuf , sizeof ( packetsbuf ) ) ; ok ( ret == 0 ) ; ok ( num_packets != 0 ) ; num_decoded = decode_packets ( decoded , packets , num_packets ) ; for ( i = 0 ; i != num_decoded ; ++ i ) { ret = quicly_receive ( client , NULL , & fake_address . sa , decoded + i ) ; ok ( ret == 0 ) ; } ok ( quicly_get_state ( client ) == QUICLY_STATE_CONNECTED ) ; ok ( quicly_connection_is_ready ( client ) ) ; num_packets = PTLS_ELEMENTSOF ( packets ) ; ret = quicly_send ( client , & dest , & src , packets , & num_packets , packetsbuf , sizeof ( packetsbuf ) ) ; ok ( ret == 0 ) ; ok ( num_packets != 0 ) ; ok ( ptls_handshake_is_complete ( quicly_get_tls ( client ) ) ) ; num_decoded = decode_packets ( decoded , packets , num_packets ) ; for ( i = 0 ; i != num_decoded ; ++ i ) { ret = quicly_receive ( server , NULL , & fake_address . sa , decoded + i ) ; ok ( ret == 0 ) ; } ok ( quicly_get_state ( server ) == QUICLY_STATE_CONNECTED ) ; ok ( ptls_handshake_is_complete ( quicly_get_tls ( server ) ) ) ; num_packets = PTLS_ELEMENTSOF ( packets ) ; ret = quicly_send ( server , & dest , & src , packets , & num_packets , packetsbuf , sizeof ( packetsbuf ) ) ; ok ( ret == 0 ) ; ok ( num_packets != 0 ) ; num_decoded = decode_packets ( decoded , packets , num_packets ) ; for ( i = 0 ; i != num_decoded ; ++ i ) { ret = quicly_receive ( client , NULL , & fake_address . sa , decoded + i ) ; ok ( ret == 0 ) ; } ok ( quicly_get_state ( client ) == QUICLY_STATE_CONNECTED ) ; ok ( quicly_get_first_timeout ( client ) == quic_now + QUICLY_DELAYED_ACK_TIMEOUT ) ; quic_now = quicly_get_first_timeout ( client ) ; num_packets = PTLS_ELEMENTSOF ( packets ) ; ret = quicly_send ( client , & dest , & src , packets , & num_packets , packetsbuf , sizeof ( packetsbuf ) ) ; ok ( ret == 0 ) ; ok ( num_packets != 0 ) ; num_decoded = decode_packets ( decoded , packets , num_packets ) ; for ( i = 0 ; i != num_decoded ; ++ i ) { ret = quicly_receive ( server , NULL , & fake_address . sa , decoded + i ) ; ok ( ret == 0 ) ; } ok ( quicly_get_state ( server ) == QUICLY_STATE_CONNECTED ) ; ok ( quicly_get_first_timeout ( server ) == quic_now + quic_ctx . transport_params . max_idle_timeout ) ; } 