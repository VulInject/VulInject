static int visornic_disable_with_timeout ( struct net_device * netdev , const int timeout ) { struct visornic_devdata * devdata = netdev_priv ( netdev ) ; int i ; unsigned long flags ; int wait = 0 ; int err ; spin_lock_irqsave ( & devdata -> priv_lock , flags ) ; devdata -> enabled = 0 ; devdata -> enab_dis_acked = 0 ; err = send_enbdis ( netdev , 0 , devdata ) ; if ( err ) { return err ; } spin_lock_irqsave ( & devdata -> priv_lock , flags ) ; while ( ( timeout == VISORNIC_INFINITE_RSP_WAIT ) || ( wait < timeout ) ) { if ( devdata -> enab_dis_acked ) { break ; } if ( devdata -> server_down || devdata -> server_change_state ) { dev_dbg ( & netdev -> dev , "%s server went away\n" , __func__ ) ; break ; } set_current_state ( TASK_INTERRUPTIBLE ) ; spin_unlock_irqrestore ( & devdata -> priv_lock , flags ) ; wait += schedule_timeout ( msecs_to_jiffies ( 10 ) ) ; spin_lock_irqsave ( & devdata -> priv_lock , flags ) ; } if ( atomic_read ( & devdata -> usage ) > 1 ) { while ( 1 ) { set_current_state ( TASK_INTERRUPTIBLE ) ; spin_unlock_irqrestore ( & devdata -> priv_lock , flags ) ; schedule_timeout ( msecs_to_jiffies ( 10 ) ) ; spin_lock_irqsave ( & devdata -> priv_lock , flags ) ; if ( atomic_read ( & devdata -> usage ) ) { break ; } } } spin_unlock_irqrestore ( & devdata -> priv_lock , flags ) ; netif_stop_queue ( netdev ) ; napi_disable ( & devdata -> napi ) ; skb_queue_purge ( & devdata -> xmitbufhead ) ; for ( i = 0 ; i < devdata -> num_rcv_bufs ; i ++ ) { if ( devdata -> rcvbuf [ i ] ) { kfree_skb ( devdata -> rcvbuf [ i ] ) ; devdata -> rcvbuf [ i ] = NULL ; } } return 0 ; } 