ecma_line_info_dump ( ) { bool block_last = false ; uint32_t block_line = 1 ; uint32_t block_byte_code_offset = 0 ; uint32_t value ; value = ecma_line_info_decode_vlq ( & line_info_p ) ; JERRY_DEBUG_MSG ( "\nLine info size: %d bytes\n" , ( int ) value ) ; while ( true ) { value = ecma_line_info_decode_vlq ( & line_info_p ) ; block_line = ecma_line_info_difference_update ( block_line , value ) ; JERRY_DEBUG_MSG ( "\nNew block: line: %d" , ( int ) block_line ) ; if ( * line_info_p == 0 ) { JERRY_DEBUG_MSG ( " StreamLength: [last]\n" ) ; block_last = true ; } else { value = ecma_line_info_decode_vlq ( & size_p ) ; JERRY_DEBUG_MSG ( " StreamLength: %d ByteCodeSize: %d\n" , ( int ) ( * line_info_p + ECMA_LINE_INFO_STREAM_SIZE_MIN ) , ( int ) value ) ; } line_info_p ++ ; uint32_t stream_line = block_line ; uint32_t stream_column = ECMA_LINE_INFO_COLUMN_DEFAULT ; uint32_t stream_end_offset = block_byte_code_offset ; while ( true ) { uint32_t stream_end_offset_increase = ecma_line_info_decode_small ( & line_info_p ) ; if ( stream_end_offset_increase & ECMA_LINE_INFO_HAS_LINE ) { value = ecma_line_info_decode_small ( & line_info_p ) ; stream_line = ecma_line_info_difference_update ( stream_line , value ) ; stream_column = ECMA_LINE_INFO_COLUMN_DEFAULT ; } stream_end_offset_increase >>= 1 ; value = ecma_line_info_decode_small ( & line_info_p ) ; stream_column = ecma_line_info_difference_update ( stream_column , value ) ; if ( stream_end_offset_increase == 0 ) { JERRY_DEBUG_MSG ( "  ByteCodeEndOffset: [unterminated] Line: %d Column: %d\n" , ( int ) stream_line , ( int ) stream_column ) ; break ; } stream_end_offset += stream_end_offset_increase ; JERRY_DEBUG_MSG ( "  ByteCodeEndOffset: %d Line: %d Column: %d\n" , ( int ) stream_end_offset , ( int ) stream_line , ( int ) stream_column ) ; } if ( block_last ) { break ; } block_byte_code_offset += ecma_line_info_decode_vlq ( & line_info_p ) ; } } 