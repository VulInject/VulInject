char * translate ( const char * loc , const char * cmd , const char * cat , const char * msg ) { register char * r ; char * t ; int p ; int oerrno ; Catalog_t * cp ; Message_t * mp ; static uint32_t serial ; static char * nlspath ; oerrno = errno ; r = ( char * ) msg ; if ( ! cmd && ! cat ) { done } if ( cmd && ( t = strrchr ( cmd , '/' ) ) ) { cmd = ( const char * ) ( t + 1 ) ; } if ( ! state . catalogs ) { if ( state . error ) { done } if ( ! ( state . tmp = sfstropen ( ) ) ) { state . error = 1 ; done } if ( ! ( state . catalogs = dtopen ( & state . catalog_disc , Dtset ) ) ) { sfclose ( state . tmp ) ; state . error = 1 ; done } } if ( ( ! cmd || ! ( mp = match ( cmd , msg ) ) ) && ( ! cat || ! ( mp = match ( cat , msg ) ) ) && ( ! error_info . catalog || ! ( mp = match ( error_info . catalog , msg ) ) ) && ( ! ast . id || ! ( mp = match ( ast . id , msg ) ) ) || ! ( cp = mp -> cat ) ) { sfprintf ( sfstderr , "AHA#%d:%s cmd %s cat %s:%s id %s msg `%s'\n" , __LINE__ , __FILE__ , cmd , cat , error_info . catalog , ast . id , msg ) ; cp = 0 ; done } sfprintf ( sfstderr , "AHA#%d:%s cp->locale `%s' %p loc `%s' %p\n" , __LINE__ , __FILE__ , cp -> locale , cp -> locale , loc , loc ) ; if ( serial != ast . env_serial ) { serial = ast . env_serial ; nlspath = getenv ( "NLSPATH" ) ; } if ( cp -> locale != loc || cp -> nlspath != nlspath ) { cp -> locale = loc ; cp -> nlspath = nlspath ; if ( cp -> cat != NOCAT ) { catclose ( cp -> cat ) ; } if ( ( cp -> cat = find ( cp -> locale , cp -> name ) ) == NOCAT ) { cp -> debug = streq ( cp -> locale , "debug" ) ; } else { cp -> debug = 0 ; } sfprintf ( sfstderr , "AHA#%d:%s cp->cat %p cp->debug %d NOCAT %p\n" , __LINE__ , __FILE__ , cp -> cat , cp -> debug , NOCAT ) ; } if ( cp -> cat == NOCAT ) { if ( cp -> debug ) { p = tempget ( state . tmp ) ; sfprintf ( state . tmp , "(%s,%d,%d)" , cp -> name , mp -> set , mp -> seq ) ; r = tempuse ( state . tmp , p ) ; } if ( ast . locale . set & AST_LC_debug ) { p = tempget ( state . tmp ) ; sfprintf ( state . tmp , "(%s,%d,%d)%s" , cp -> name , mp -> set , mp -> seq , r ) ; r = tempuse ( state . tmp , p ) ; } } else { r = catgets ( cp -> cat , mp -> set , mp -> seq , msg ) ; if ( r != ( char * ) msg ) { if ( streq ( r , ( char * ) msg ) ) { r = ( char * ) msg ; } if ( strcmp ( fmtfmt ( r ) , fmtfmt ( msg ) ) ) { sfprintf ( sfstderr , "locale %s catalog %s message %d.%d \"%s\" does not match \"%s\"\n" , cp -> locale , cp -> name , mp -> set , mp -> seq , r , msg ) ; r = ( char * ) msg ; } } if ( ast . locale . set & AST_LC_debug ) { p = tempget ( state . tmp ) ; sfprintf ( state . tmp , "(%s,%d,%d)%s" , cp -> name , mp -> set , mp -> seq , r ) ; r = tempuse ( state . tmp , p ) ; } } done if ( r == ( char * ) msg && ( ! cp && streq ( loc , "debug" ) || cp && cp -> debug ) ) { p = tempget ( state . tmp ) ; sfprintf ( state . tmp , "(%s,%s,%s,%s)" , loc , cmd , cat , r ) ; r = tempuse ( state . tmp , p ) ; } errno = oerrno ; return r ; } 