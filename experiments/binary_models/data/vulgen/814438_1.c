CK_RV soft_aes_decrypt_final ( soft_session_t * session_p , CK_BYTE_PTR pLastPart , CK_ULONG_PTR pulLastPartLen ) { aes_ctx_t * aes_ctx = session_p -> decrypt . context ; CK_MECHANISM_TYPE mech = session_p -> decrypt . mech . mechanism ; CK_RV rv = CKR_OK ; int rc = CRYPTO_SUCCESS ; size_t out_len ; crypto_data_t out = { . cd_format = CRYPTO_DATA_RAW . cd_offset = 0 . cd_length = * pulLastPartLen . cd_raw . iov_base = ( char * ) pLastPart . cd_raw . iov_len = * pulLastPartLen } ; switch ( mech ) { case CKM_AES_CBC_PAD : if ( ( aes_ctx -> ac_flags & P11_DECRYPTED ) == 0 ) { uint8_t block [ AES_BLOCK_LEN ] { 0 } ; ; crypto_data_t block_out = { . cd_format = CRYPTO_DATA_RAW . cd_offset = 0 . cd_length = sizeof ( block ) . cd_raw . iov_base = ( char * ) block . cd_raw . iov_len = ( block ) } ; size_t amt , i ; uint8_t pad_len ; if ( aes_ctx -> ac_remainder_len != AES_BLOCK_LEN ) { return ( CKR_DATA_LEN_RANGE ) ; } rc = aes_decrypt_contiguous_blocks ( aes_ctx , ( char * ) block , 0 , & block_out ) ; if ( rc != CRYPTO_SUCCESS ) { explicit_bzero ( block , sizeof ( block ) ) ; return ( CKR_FUNCTION_FAILED ) ; } pad_len = block [ AES_BLOCK_LEN - 1 ] ; if ( pad_len == 0 || pad_len > AES_BLOCK_LEN ) { rv = CKR_ENCRYPTED_DATA_INVALID ; explicit_bzero ( block , sizeof ( block ) ) ; done } amt = AES_BLOCK_LEN - pad_len ; for ( i = amt ; i < AES_BLOCK_LEN ; i ++ ) { if ( block [ i ] != pad_len ) { rv = CKR_ENCRYPTED_DATA_INVALID ; } } if ( rv != CKR_OK ) { explicit_bzero ( block , sizeof ( block ) ) ; done } bcopy ( block , aes_ctx -> ac_remainder , amt ) ; explicit_bzero ( block , sizeof ( block ) ) ; aes_ctx -> ac_flags |= P11_DECRYPTED ; aes_ctx -> ac_remainder_len = amt ; } out_len = aes_ctx -> ac_remainder_len ; break ; case CKM_AES_CTR : out_len = 0 ; break ; case CKM_AES_CCM : out_len = aes_ctx -> ac_data_len ; break ; case CKM_AES_GCM : out_len = aes_ctx -> acu . acu_gcm . gcm_processed_data_len - aes_ctx -> acu . acu_gcm . gcm_tag_len ; break ; default : if ( aes_ctx -> ac_remainder_len > 0 ) { rv = CKR_DATA_LEN_RANGE ; done } out_len = 0 ; break ; } if ( * pulLastPartLen < out_len || pLastPart == NULL ) { * pulLastPartLen = out_len ; return ( ( pLastPart == NULL ) ?CKR_OK : CKR_BUFFER_TOO_SMALL ) ; } switch ( mech ) { case CKM_AES_CBC_PAD : * pulLastPartLen = out_len ; if ( out_len == 0 ) { break ; } bcopy ( aes_ctx -> ac_remainder , pLastPart , out_len ) ; out . cd_offset += out_len ; break ; case CKM_AES_CCM : ASSERT3U ( aes_ctx -> ac_processed_data_len , == , out_len ) ; ASSERT3U ( aes_ctx -> ac_processed_mac_len , == , aes_ctx -> ac_mac_len ) ; rc = ccm_decrypt_final ( ( ccm_ctx_t * ) aes_ctx , & out , AES_BLOCK_LEN , aes_encrypt_block , aes_copy_block , aes_xor_block ) ; break ; case CKM_AES_GCM : rc = gcm_decrypt_final ( ( gcm_ctx_t * ) aes_ctx , & out , AES_BLOCK_LEN , aes_encrypt_block , aes_xor_block ) ; break ; default : break ; } VERIFY3U ( out . cd_offset , == , out_len ) ; rv = crypto2pkcs11_error_number ( rc ) ; done soft_aes_free_ctx ( aes_ctx ) ; session_p -> decrypt . context = NULL ; return ( rv ) ; } 