md_apply_fix3 ( , , ) fixS * fixP ; valueT * val ; segT seg ATTRIBUTE_UNUSED ; { char * buf = fixP -> fx_where + fixP -> fx_frag -> fr_literal ; long t_val ; t_val = ( long ) * val ; printf ( "md_apply_fix val:%x\n" , t_val ) ; fixP -> fx_addnumber = t_val ; know ( fixP -> fx_size == 4 ) ; know ( fixP -> fx_r_type < BFD_RELOC_NONE ) ; switch ( fixP -> fx_r_type ) { case BFD_RELOC_32 : printf ( "reloc_const: val=%x\n" , t_val ) ; buf [ 0 ] = t_val >> 24 ; buf [ 1 ] = t_val >> 16 ; buf [ 2 ] = t_val >> 8 ; buf [ 3 ] = t_val ; break ; case BFD_RELOC_16 : printf ( "reloc_const: val=%x\n" , t_val ) ; buf [ 0 ] = t_val >> 8 ; buf [ 1 ] = t_val ; break ; case BFD_RELOC_8 : printf ( "reloc_const: val=%x\n" , t_val ) ; buf [ 0 ] = t_val ; break ; case BFD_RELOC_LO16 : printf ( "reloc_const: val=%x\n" , t_val ) ; buf [ 2 ] = t_val >> 8 ; buf [ 3 ] = t_val ; break ; case BFD_RELOC_HI16 : printf ( "reloc_consth: val=%x\n" , t_val ) ; buf [ 2 ] = t_val >> 24 ; buf [ 3 ] = t_val >> 16 ; break ; case BFD_RELOC_32_GOT_PCREL : if ( ! fixP -> fx_done ) { if ( fixP -> fx_pcrel && t_val != 0 && t_val == - ( fixP -> fx_frag -> fr_address + fixP -> fx_where ) ) { as_bad_where ( fixP -> fx_file , fixP -> fx_line , _ ( "the linker will not handle this relocation correctly (1)" ) ) ; } } if ( fixP -> fx_pcrel ) { long v = t_val >> 28 ; if ( v != 0 && v != - 1 ) { as_bad_where ( fixP -> fx_file , fixP -> fx_line , _ ( "call/jmp target out of range (2)" ) ) ; } } else { abort ( ) ; } buf [ 0 ] |= ( t_val >> 26 ) & 0x03 ; buf [ 1 ] = t_val >> 18 ; buf [ 2 ] = t_val >> 10 ; buf [ 3 ] = t_val >> 2 ; break ; case BFD_RELOC_VTABLE_INHERIT : case BFD_RELOC_VTABLE_ENTRY : fixP -> fx_done = 0 ; break ; case BFD_RELOC_NONE : default : as_bad ( _ ( "bad relocation type: 0x%02x" ) , fixP -> fx_r_type ) ; break ; } } 