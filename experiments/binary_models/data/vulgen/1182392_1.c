int iwk_detach ( dev_info_t * dip , ddi_detach_cmd_t cmd ) { iwk_sc_t * sc ; int err ; sc = ddi_get_soft_state ( iwk_soft_state_p , ddi_get_instance ( dip ) ) ; ASSERT ( sc != NULL ) ; switch ( cmd ) { case DDI_DETACH : break ; case DDI_SUSPEND : mutex_enter ( & sc -> sc_glock ) ; sc -> sc_flags |= IWK_F_SUSPEND ; mutex_exit ( & sc -> sc_glock ) ; if ( sc -> sc_flags & IWK_F_RUNNING ) { iwk_stop ( sc ) ; } IWK_DBG ( ( IWK_DEBUG_RESUME , "iwk: suspend\n" ) ) ; return ( DDI_SUCCESS ) ; default : return ( DDI_FAILURE ) ; } if ( ! ( sc -> sc_flags & IWK_F_ATTACHED ) ) { return ( DDI_FAILURE ) ; } err = mac_disable ( sc -> sc_ic . ic_mach ) ; if ( err != DDI_SUCCESS ) { return ( err ) ; } mutex_enter ( & sc -> sc_mt_lock ) ; while ( sc -> sc_mf_thread != NULL ) { if ( cv_wait_sig ( & sc -> sc_mt_cv , & sc -> sc_mt_lock ) == 0 ) { break ; } } mutex_exit ( & sc -> sc_mt_lock ) ; iwk_stop ( sc ) ; DELAY ( 500000 ) ; ( void ) mac_unregister ( sc -> sc_ic . ic_mach ) ; mutex_enter ( & sc -> sc_glock ) ; iwk_free_fw_dma ( sc ) ; iwk_ring_free ( sc ) ; iwk_free_kw ( sc ) ; iwk_free_shared ( sc ) ; mutex_exit ( & sc -> sc_glock ) ; ( void ) ddi_intr_disable ( sc -> sc_intr_htable [ 0 ] ) ; ( void ) ddi_intr_remove_handler ( sc -> sc_intr_htable [ 0 ] ) ; ( void ) ddi_intr_free ( sc -> sc_intr_htable [ 0 ] ) ; kmem_free ( sc -> sc_intr_htable , sizeof ( ddi_intr_handle_t ) ) ; ( void ) ddi_intr_remove_softint ( sc -> sc_soft_hdl ) ; sc -> sc_soft_hdl = NULL ; ieee80211_detach ( & sc -> sc_ic ) ; iwk_destroy_locks ( sc ) ; ddi_regs_map_free ( & sc -> sc_handle ) ; ddi_regs_map_free ( & sc -> sc_cfg_handle ) ; ddi_remove_minor_node ( dip , NULL ) ; ddi_soft_state_free ( iwk_soft_state_p , ddi_get_instance ( dip ) ) ; return ( DDI_SUCCESS ) ; } 