int sotpi_connect ( struct sonode * so , struct sockaddr * name , socklen_t namelen , int fflag , int flags , struct cred * cr ) { struct T_conn_req conn_req ; int error = 0 ; mblk_t * mp ; void * src ; socklen_t srclen ; void * addr ; socklen_t addrlen ; boolean_t need_unlock ; sotpi_info_t * sti = SOTOTPI ( so ) ; dprintso ( so , 1 , ( "sotpi_connect(%p, %p, %d, 0x%x, 0x%x) %s\n" , ( void * ) so , ( void * ) name , namelen , fflag , flags , pr_state ( so -> so_state , so -> so_mode ) ) ) ; mp = soallocproto ( sizeof ( T_conn_req ) + 2 * sti -> sti_faddr_maxlen + sizeof ( T_opthdr ) , _ALLOC_INTR , cr ) ; if ( mp == NULL ) { error = EINTR ; eprintsoline ( so , error ) ; return ( error ) ; } mutex_enter ( & so -> so_lock ) ; so_lock_single ( so ) ; need_unlock = B_TRUE ; if ( sti -> sti_unbind_mp == NULL ) { dprintso ( so , 1 , ( "sotpi_connect: allocating unbind_req\n" ) ) ; sti -> sti_unbind_mp = soallocproto ( sizeof ( T_unbind_req ) , _ALLOC_INTR , cr ) ; if ( sti -> sti_unbind_mp == NULL ) { error = EINTR ; done } } if ( so -> so_state & SS_ACCEPTCONN ) { error = EOPNOTSUPP ; done } if ( ! ( so -> so_state & SS_ISBOUND ) ) { else { error = sotpi_bind ( so , NULL , 0 , _SOBIND_UNSPEC | _SOBIND_LOCK_HELD , cr ) ; if ( error ) { done } } ASSERT ( so -> so_state & SS_ISBOUND ) ; flags |= _SOCONNECT_DID_BIND ; } if ( ( namelen >= sizeof ( sa_family_t ) ) && ( name -> sa_family == AF_UNSPEC ) ) { name = NULL ; namelen = 0 ; } if ( so -> so_state & ( SS_ISCONNECTED | SS_ISCONNECTING ) ) { ASSERT ( ! ( flags & _SOCONNECT_DID_BIND ) ) ; if ( so -> so_mode & SM_CONNREQUIRED ) { error = so -> so_state & SS_ISCONNECTED ?EISCONN : EALREADY ; done } if ( name == NULL ) { int val ; if ( ( so -> so_family == AF_INET || so -> so_family == AF_INET6 ) && ( so -> so_type == SOCK_DGRAM || so -> so_type == SOCK_RAW ) && ! soconnect_tpi_udp ) { error = sodisconnect ( so , - 1 , _SODISCONNECT_LOCK_HELD ) ; } else { so -> so_state &= ~ ( SS_ISCONNECTED | SS_ISCONNECTING ) ; sti -> sti_faddr_valid = 0 ; sti -> sti_faddr_len = 0 ; } so_unlock_single ( so , SOLOCKED ) ; mutex_exit ( & so -> so_lock ) ; val = 0 ; ( void ) sotpi_setsockopt ( so , SOL_SOCKET , SO_DGRAM_ERRIND , & val , ( t_uscalar_t ) sizeof ( val ) , cr ) ; mutex_enter ( & so -> so_lock ) ; so_lock_single ( so ) ; done } } ASSERT ( so -> so_state & SS_ISBOUND ) ; if ( name == NULL || namelen == 0 ) { error = EINVAL ; done } if ( flags & _SOCONNECT_NOXLATE ) { struct sockaddr_ux * soaddr_ux ; ASSERT ( so -> so_family == AF_UNIX ) ; if ( namelen != sizeof ( sockaddr_ux ) ) { error = EINVAL ; done } soaddr_ux = ( sockaddr_ux * ) name ; name = ( sockaddr * ) & soaddr_ux -> sou_addr ; namelen = sizeof ( soaddr_ux -> sou_addr ) ; sti -> sti_faddr_noxlate = 1 ; } error = so_addr_verify ( so , name , namelen ) ; if ( error ) { bad } if ( namelen > ( t_uscalar_t ) sti -> sti_faddr_maxlen ) { error = EINVAL ; done } sti -> sti_faddr_len = ( socklen_t ) namelen ; ASSERT ( sti -> sti_faddr_len <= sti -> sti_faddr_maxlen ) ; bcopy ( name , sti -> sti_faddr_sa , namelen ) ; sti -> sti_faddr_valid = 1 ; if ( so -> so_family == AF_UNIX ) { if ( sti -> sti_faddr_noxlate ) { src = NULL ; srclen = 0 ; addr = sti -> sti_faddr_sa ; addrlen = ( t_uscalar_t ) sti -> sti_faddr_len ; bcopy ( addr , & sti -> sti_ux_faddr , sizeof ( sti -> sti_ux_faddr ) ) ; } else { src = sti -> sti_laddr_sa ; srclen = ( t_uscalar_t ) sti -> sti_laddr_len ; dprintso ( so , 1 , ( "sotpi_connect UNIX: srclen %d, src %p\n" , srclen , src ) ) ; error = so_ux_addr_xlate ( so , sti -> sti_faddr_sa , ( socklen_t ) sti -> sti_faddr_len , ( flags & _SOCONNECT_XPG4_2 ) , & addr , & addrlen ) ; if ( error ) { bad } bcopy ( & sti -> sti_ux_taddr , & sti -> sti_ux_faddr , sizeof ( sti -> sti_ux_faddr ) ) ; } } else { addr = sti -> sti_faddr_sa ; addrlen = ( t_uscalar_t ) sti -> sti_faddr_len ; src = NULL ; srclen = 0 ; } if ( ! ( so -> so_mode & SM_CONNREQUIRED ) ) { int32_t val ; so_unlock_single ( so , SOLOCKED ) ; mutex_exit ( & so -> so_lock ) ; val = 1 ; ( void ) sotpi_setsockopt ( so , SOL_SOCKET , SO_DGRAM_ERRIND , & val , ( t_uscalar_t ) sizeof ( val ) , cr ) ; mutex_enter ( & so -> so_lock ) ; so_lock_single ( so ) ; if ( ( so -> so_family != AF_INET && so -> so_family != AF_INET6 ) || ( so -> so_type != SOCK_DGRAM && so -> so_type != SOCK_RAW ) || soconnect_tpi_udp ) { soisconnected ( so ) ; done } fflag = 0 ; ASSERT ( so -> so_family != AF_UNIX ) ; sti -> sti_laddr_valid = 0 ; } if ( sti -> sti_laddr_len != 0 ) { switch ( so -> so_family ) { case AF_INET : ASSERT ( sti -> sti_laddr_len == ( socklen_t ) sizeof ( sin_t ) ) ; if ( ( ( sin_t * ) sti -> sti_laddr_sa ) -> sin_addr . s_addr == INADDR_ANY || ( ( sin_t * ) sti -> sti_laddr_sa ) -> sin_port == 0 ) { sti -> sti_laddr_valid = 0 ; } break ; case AF_INET6 : ASSERT ( sti -> sti_laddr_len == ( socklen_t ) sizeof ( sin6_t ) ) ; if ( IN6_IS_ADDR_UNSPECIFIED ( & ( ( sin6_t * ) sti -> sti_laddr_sa ) -> sin6_addr ) || IN6_IS_ADDR_V4MAPPED_ANY ( & ( ( sin6_t * ) sti -> sti_laddr_sa ) -> sin6_addr ) || ( ( sin6_t * ) sti -> sti_laddr_sa ) -> sin6_port == 0 ) { sti -> sti_laddr_valid = 0 ; } break ; default : break ; } } if ( so -> so_error != 0 ) { so_bad } conn_req . PRIM_type = T_CONN_REQ ; conn_req . DEST_length = addrlen ; conn_req . DEST_offset = ( t_scalar_t ) sizeof ( conn_req ) ; if ( srclen == 0 ) { conn_req . OPT_length = 0 ; conn_req . OPT_offset = 0 ; soappendmsg ( mp , & conn_req , sizeof ( conn_req ) ) ; soappendmsg ( mp , addr , addrlen ) ; } else { struct T_opthdr toh ; toh . level = SOL_SOCKET ; toh . name = SO_SRCADDR ; toh . len = ( t_uscalar_t ) ( srclen + sizeof ( T_opthdr ) ) ; toh . status = 0 ; conn_req . OPT_length = ( t_scalar_t ) ( sizeof ( toh ) + _TPI_ALIGN_TOPT ( srclen ) ) ; conn_req . OPT_offset = ( t_scalar_t ) ( sizeof ( conn_req ) + _TPI_ALIGN_TOPT ( addrlen ) ) ; soappendmsg ( mp , & conn_req , sizeof ( conn_req ) ) ; soappendmsg ( mp , addr , addrlen ) ; mp -> b_wptr += _TPI_ALIGN_TOPT ( addrlen ) - addrlen ; soappendmsg ( mp , & toh , sizeof ( toh ) ) ; soappendmsg ( mp , src , srclen ) ; mp -> b_wptr += _TPI_ALIGN_TOPT ( srclen ) - srclen ; ASSERT ( mp -> b_wptr <= mp -> b_datap -> db_lim ) ; } soisconnecting ( so ) ; mutex_exit ( & so -> so_lock ) ; if ( AU_AUDITING ( ) ) { audit_sock ( T_CONN_REQ , strvp2wq ( SOTOV ( so ) ) , mp , 0 ) ; } error = kstrputmsg ( SOTOV ( so ) , mp , NULL , 0 , 0 , MSG_BAND | MSG_HOLDSIG | MSG_IGNERROR , 0 ) ; mp = NULL ; mutex_enter ( & so -> so_lock ) ; if ( error != 0 ) { bad } if ( ( error = sowaitokack ( so , T_CONN_REQ ) ) != 0 ) { bad } so_unlock_single ( so , SOLOCKED ) ; need_unlock = B_FALSE ; if ( ( error = sowaitconnected ( so , fflag , 0 ) ) != 0 ) { so_lock_single ( so ) ; need_unlock = B_TRUE ; } done freemsg ( mp ) ; switch ( error ) { case EINPROGRESS : case EALREADY : case EISCONN : case EINTR : sti -> sti_laddr_valid = 0 ; case 0 : break ; default : ASSERT ( need_unlock ) ; so -> so_state &= ~ SS_ISCONNECTING ; sti -> sti_laddr_valid = 0 ; if ( ( flags & _SOCONNECT_DID_BIND ) && ( so -> so_state & SS_ISBOUND ) ) { int err ; err = sotpi_unbind ( so , 0 ) ; if ( err ) { eprintsoline ( so , err ) ; } } break ; } if ( need_unlock ) { so_unlock_single ( so , SOLOCKED ) ; } mutex_exit ( & so -> so_lock ) ; return ( error ) ; so_bad error = sogeterr ( so , B_TRUE ) ; bad eprintsoline ( so , error ) ; done } 