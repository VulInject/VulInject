CURLMcode curl_multi_perform ( struct Curl_multi * multi , int * running_handles ) { struct Curl_easy * data ; CURLMcode returncode = CURLM_OK ; struct Curl_tree * t ; struct curltime now = Curl_now ( ) ; if ( ! GOOD_MULTI_HANDLE ( multi ) ) { return CURLM_BAD_HANDLE ; } data = multi -> easyp ; while ( data ) { CURLMcode result ; SIGPIPE_VARIABLE ( pipe_st ) ; sigpipe_ignore ( data , & pipe_st ) ; result = multi_runsingle ( multi , & now , data ) ; sigpipe_restore ( & pipe_st ) ; if ( result ) { returncode = result ; } data = data -> next ; } { multi -> timetree = Curl_splaygetbest ( now , multi -> timetree , & t ) ; if ( t ) { ( void ) add_next_timeout ( now , multi , t -> payload ) ; } } t ; * running_handles = multi -> num_alive ; if ( CURLM_OK >= returncode ) { returncode = Curl_update_timer ( multi ) ; } return returncode ; } 