static int efi_read ( int fd , struct dk_gpt * vtoc ) { int i , j ; int label_len ; int rval = 0 ; int md_flag = 0 ; int vdc_flag = 0 ; diskaddr_t capacity = 0 ; uint_t lbsize = 0 ; struct dk_minfo disk_info ; dk_efi_t dk_ioc ; efi_gpt_t * efi ; efi_gpe_t * efi_parts ; struct dk_cinfo dki_info ; uint32_t user_length ; boolean_t legacy_label = B_FALSE ; if ( ( rval = efi_get_info ( fd , & dki_info ) ) != 0 ) { return ( rval ) ; } if ( ( strncmp ( dki_info . dki_cname , "pseudo" , 7 ) == 0 ) && ( strncmp ( dki_info . dki_dname , "md" , 3 ) == 0 ) ) { md_flag ++ ; } if ( ( strncmp ( dki_info . dki_cname , "vdc" , 4 ) == 0 ) && ( strncmp ( dki_info . dki_dname , "vdc" , 4 ) == 0 ) ) { vdc_flag ++ ; } if ( read_disk_info ( fd , & capacity , & lbsize ) == - 1 ) { if ( efi_debug ) { ( void ) fprintf ( stderr , "unable to read disk info: %d" , errno ) ; } return ( VT_EINVAL ) ; } disk_info . dki_lbsize = lbsize ; disk_info . dki_capacity = capacity ; if ( disk_info . dki_lbsize == 0 ) { if ( efi_debug ) { ( void ) fprintf ( stderr , "efi_read: assuming LBA 512 bytes\n" ) ; } disk_info . dki_lbsize = DEV_BSIZE ; } dk_ioc . dki_lba = 1 ; if ( NBLOCKS ( vtoc -> efi_nparts , disk_info . dki_lbsize ) < 34 ) { label_len = EFI_MIN_ARRAY_SIZE + disk_info . dki_lbsize ; } else { label_len = vtoc -> efi_nparts * ( int ) sizeof ( efi_gpe_t ) + disk_info . dki_lbsize ; if ( label_len % disk_info . dki_lbsize ) { label_len += disk_info . dki_lbsize ; label_len &= ~ ( disk_info . dki_lbsize - 1 ) ; } } if ( posix_memalign ( ( void * * ) & dk_ioc . dki_data , disk_info . dki_lbsize , label_len ) ) { return ( VT_ERROR ) ; } memset ( dk_ioc . dki_data , 0 , label_len ) ; dk_ioc . dki_length = disk_info . dki_lbsize ; user_length = vtoc -> efi_nparts ; efi = dk_ioc . dki_data ; if ( md_flag ) { dk_ioc . dki_length = label_len ; if ( efi_ioctl ( fd , DKIOCGETEFI , & dk_ioc ) == - 1 ) { switch ( errno ) { case EIO : return ( VT_EIO ) ; default : return ( VT_ERROR ) ; } } } if ( ( rval = check_label ( fd , & dk_ioc ) ) == VT_EINVAL ) { dk_ioc . dki_lba = disk_info . dki_capacity - 2 ; dk_ioc . dki_length = disk_info . dki_lbsize ; rval = check_label ( fd , & dk_ioc ) ; if ( rval == VT_EINVAL ) { dk_ioc . dki_lba = disk_info . dki_capacity - 1 ; dk_ioc . dki_length = disk_info . dki_lbsize ; rval = check_label ( fd , & dk_ioc ) ; if ( rval == 0 ) { legacy_label = B_TRUE ; if ( efi_debug ) { ( void ) fprintf ( stderr , "efi_read: primary label corrupt; " "using EFI backup label located on" " the last block\n" ) ; } } } else { if ( ( efi_debug ) && ( rval == 0 ) ) { ( void ) fprintf ( stderr , "efi_read: primary label" " corrupt; using legacy EFI backup label " " located on the next to last block\n" ) ; } } if ( rval == 0 ) { dk_ioc . dki_lba = LE_64 ( efi -> efi_gpt_PartitionEntryLBA ) ; vtoc -> efi_flags |= EFI_GPT_PRIMARY_CORRUPT ; vtoc -> efi_nparts = LE_32 ( efi -> efi_gpt_NumberOfPartitionEntries ) ; dk_ioc . dki_data = ( efi_gpt_t * ) ( ( char * ) dk_ioc . dki_data + disk_info . dki_lbsize ) ; if ( legacy_label ) { dk_ioc . dki_length = disk_info . dki_capacity - 1 - dk_ioc . dki_lba ; } else { dk_ioc . dki_length = disk_info . dki_capacity - 2 - dk_ioc . dki_lba ; } dk_ioc . dki_length *= disk_info . dki_lbsize ; if ( dk_ioc . dki_length > ( ( len_t ) label_len - sizeof ( * dk_ioc . dki_data ) ) ) { rval = VT_EINVAL ; } else { rval = efi_ioctl ( fd , DKIOCGETEFI , & dk_ioc ) ; } } } if ( rval == 0 ) { dk_ioc . dki_lba = LE_64 ( efi -> efi_gpt_PartitionEntryLBA ) ; dk_ioc . dki_data = ( efi_gpt_t * ) ( ( char * ) dk_ioc . dki_data + disk_info . dki_lbsize ) ; dk_ioc . dki_length = label_len - disk_info . dki_lbsize ; rval = efi_ioctl ( fd , DKIOCGETEFI , & dk_ioc ) ; } if ( vdc_flag && rval == VT_ERROR && errno == EINVAL ) { dk_ioc . dki_lba = 1 ; dk_ioc . dki_length = label_len ; rval = check_label ( fd , & dk_ioc ) ; } if ( rval < 0 ) { free ( efi ) ; return ( rval ) ; } efi_parts = ( efi_gpe_t * ) ( ( ( char * ) efi ) + disk_info . dki_lbsize ) ; vtoc -> efi_version = LE_32 ( efi -> efi_gpt_Revision ) ; vtoc -> efi_nparts = LE_32 ( efi -> efi_gpt_NumberOfPartitionEntries ) ; vtoc -> efi_part_size = LE_32 ( efi -> efi_gpt_SizeOfPartitionEntry ) ; vtoc -> efi_lbasize = disk_info . dki_lbsize ; vtoc -> efi_last_lba = disk_info . dki_capacity - 1 ; vtoc -> efi_first_u_lba = LE_64 ( efi -> efi_gpt_FirstUsableLBA ) ; vtoc -> efi_last_u_lba = LE_64 ( efi -> efi_gpt_LastUsableLBA ) ; vtoc -> efi_altern_lba = LE_64 ( efi -> efi_gpt_AlternateLBA ) ; UUID_LE_CONVERT ( vtoc -> efi_disk_uguid , efi -> efi_gpt_DiskGUID ) ; for ( i = 0 ; i < vtoc -> efi_nparts ; i ++ ) { UUID_LE_CONVERT ( vtoc -> efi_parts [ i ] . p_guid , efi_parts [ i ] . efi_gpe_PartitionTypeGUID ) ; for ( j = 0 ; j < sizeof ( conversion_array ) / sizeof ( uuid_to_ptag ) ; j ++ ) { if ( bcmp ( & vtoc -> efi_parts [ i ] . p_guid , & conversion_array [ j ] . uuid , sizeof ( uuid ) ) == 0 ) { vtoc -> efi_parts [ i ] . p_tag = j ; break ; } } if ( vtoc -> efi_parts [ i ] . p_tag == V_UNASSIGNED ) { continue ; } vtoc -> efi_parts [ i ] . p_flag = LE_16 ( efi_parts [ i ] . efi_gpe_Attributes . PartitionAttrs ) ; vtoc -> efi_parts [ i ] . p_start = LE_64 ( efi_parts [ i ] . efi_gpe_StartingLBA ) ; vtoc -> efi_parts [ i ] . p_size = LE_64 ( efi_parts [ i ] . efi_gpe_EndingLBA ) - vtoc -> efi_parts [ i ] . p_start + 1 ; for ( j = 0 ; j < EFI_PART_NAME_LEN ; j ++ ) { vtoc -> efi_parts [ i ] . p_name [ j ] = ( uchar_t ) LE_16 ( efi_parts [ i ] . efi_gpe_PartitionName [ j ] ) ; } UUID_LE_CONVERT ( vtoc -> efi_parts [ i ] . p_uguid , efi_parts [ i ] . efi_gpe_UniquePartitionGUID ) ; } free ( efi ) ; return ( dki_info . dki_partition ) ; } 