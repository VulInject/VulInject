static void ud_cursor ( struct vc_data * vc , struct fb_info * info , int mode , int softback_lines , int fg , int bg ) { struct fb_cursor cursor ; struct fbcon_ops * ops = info -> fbcon_par ; unsigned short charmask = vc -> vc_hi_font_mask ?0x1ff : 0xff ; int w = ( vc -> vc_font . width + 7 ) >> 3 , c ; int y = real_y ( ops -> p , vc -> vc_y ) ; int attribute , use_sw = ( vc -> vc_cursor_type & 0x10 ) ; int err = 1 , dx , dy ; char * src ; u32 vyres = GETVYRES ( ops -> p -> scrollmode , info ) ; u32 vxres = GETVXRES ( ops -> p -> scrollmode , info ) ; if ( ! ops -> fontbuffer ) { return ; } cursor . set = 0 ; if ( softback_lines ) { if ( y + softback_lines >= vc -> vc_rows ) { mode = CM_ERASE ; ops -> cursor_flash = 0 ; return ; } else { y += softback_lines ; } } c = scr_readw ( ( u16 * ) vc -> vc_pos ) ; attribute = get_attribute ( info , c ) ; src = ops -> fontbuffer + ( ( c & charmask ) * ( w * vc -> vc_font . height ) ) ; if ( ops -> cursor_state . image . data != src || ops -> cursor_reset ) { ops -> cursor_state . image . data = src ; cursor . set |= FB_CUR_SETIMAGE ; } if ( attribute ) { u8 * dst ; dst = kmalloc ( w * vc -> vc_font . height , GFP_ATOMIC ) ; if ( ! dst ) { return ; } ops -> cursor_data = dst ; ud_update_attr ( dst , src , attribute , vc ) ; src = dst ; } if ( ops -> cursor_state . image . fg_color != fg || ops -> cursor_state . image . bg_color != bg || ops -> cursor_reset ) { ops -> cursor_state . image . fg_color = fg ; ops -> cursor_state . image . bg_color = bg ; cursor . set |= FB_CUR_SETCMAP ; } if ( ops -> cursor_state . image . height != vc -> vc_font . height || ops -> cursor_state . image . width != vc -> vc_font . width || ops -> cursor_reset ) { ops -> cursor_state . image . height = vc -> vc_font . height ; ops -> cursor_state . image . width = vc -> vc_font . width ; cursor . set |= FB_CUR_SETSIZE ; } dy = vyres - ( ( y * vc -> vc_font . height ) + vc -> vc_font . height ) ; dx = vxres - ( ( vc -> vc_x * vc -> vc_font . width ) + vc -> vc_font . width ) ; if ( ops -> cursor_state . image . dx != dx || ops -> cursor_state . image . dy != dy || ops -> cursor_reset ) { ops -> cursor_state . image . dx = dx ; ops -> cursor_state . image . dy = dy ; cursor . set |= FB_CUR_SETPOS ; } if ( ops -> cursor_state . hot . x || ops -> cursor_state . hot . y || ops -> cursor_reset ) { ops -> cursor_state . hot . x = cursor . hot . y = 0 ; cursor . set |= FB_CUR_SETHOT ; } if ( cursor . set & FB_CUR_SETSIZE || vc -> vc_cursor_type != ops -> p -> cursor_shape || ops -> cursor_state . mask == NULL || ops -> cursor_reset ) { char * mask = kmalloc ( w * vc -> vc_font . height , GFP_ATOMIC ) ; int cur_height , size , i = 0 ; u8 msk = 0xff ; if ( ! mask ) { return ; } kfree ( ops -> cursor_state . mask ) ; ops -> cursor_state . mask = mask ; ops -> p -> cursor_shape = vc -> vc_cursor_type ; cursor . set |= FB_CUR_SETSHAPE ; switch ( ops -> p -> cursor_shape & CUR_HWMASK ) { case CUR_NONE : cur_height = 0 ; break ; case CUR_UNDERLINE : cur_height = ( vc -> vc_font . height < 10 ) ?1 : 2 ; break ; case CUR_LOWER_THIRD : cur_height = vc -> vc_font . height / 3 ; break ; case CUR_LOWER_HALF : cur_height = vc -> vc_font . height >> 1 ; break ; case CUR_TWO_THIRDS : cur_height = ( vc -> vc_font . height << 1 ) / 3 ; break ; case CUR_BLOCK : default : cur_height = vc -> vc_font . height ; break ; } size = cur_height * w ; while ( size -- ) { mask [ i ++ ] = msk ; } size = ( vc -> vc_font . height - cur_height ) * w ; while ( size -- ) { mask [ i ++ ] = ~ msk ; } } switch ( mode ) { case CM_ERASE : ops -> cursor_state . enable = 0 ; break ; case CM_DRAW : case CM_MOVE : default : ops -> cursor_state . enable = ( use_sw ) ?0 : 1 ; break ; } cursor . image . data = src ; cursor . image . fg_color = ops -> cursor_state . image . fg_color ; cursor . image . bg_color = ops -> cursor_state . image . bg_color ; cursor . image . dx = ops -> cursor_state . image . dx ; cursor . image . dy = ops -> cursor_state . image . dy ; cursor . image . height = ops -> cursor_state . image . height ; cursor . image . width = ops -> cursor_state . image . width ; cursor . hot . x = ops -> cursor_state . hot . x ; cursor . hot . y = ops -> cursor_state . hot . y ; cursor . mask = ops -> cursor_state . mask ; cursor . enable = ops -> cursor_state . enable ; cursor . image . depth = 1 ; cursor . rop = ROP_XOR ; if ( info -> fbops -> fb_cursor ) { err = info -> fbops -> fb_cursor ( info , & cursor ) ; } if ( err ) { soft_cursor ( info , & cursor ) ; } ops -> cursor_reset = 0 ; } 