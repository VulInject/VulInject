void ztest_vdev_add_remove ( ztest_ds_t * zd , uint64_t id ) { ztest_shared_t * zs = ztest_shared ; spa_t * spa = ztest_spa ; uint64_t leaves ; uint64_t guid ; nvlist_t * nvroot ; int error ; mutex_enter ( & ztest_vdev_lock ) ; leaves = MAX ( zs -> zs_mirrors + zs -> zs_splits , 1 ) * ztest_opts . zo_raidz ; spa_config_enter ( spa , SCL_VDEV , FTAG , RW_READER ) ; ztest_shared -> zs_vdev_next_leaf = spa_num_top_vdevs ( spa ) * leaves ; if ( spa_has_slogs ( spa ) && ztest_random ( 4 ) == 0 ) { metaslab_group_t * mg ; mg = spa_log_class ( spa ) -> mc_rotor ; while ( ! mg -> mg_vd -> vdev_islog ) { mg = mg -> mg_next ; } guid = mg -> mg_vd -> vdev_guid ; spa_config_exit ( spa , SCL_VDEV , FTAG ) ; rw_enter ( & ztest_name_lock , RW_WRITER ) ; error = spa_vdev_remove ( spa , guid , B_FALSE ) ; rw_exit ( & ztest_name_lock ) ; switch ( error ) { case 0 : case EEXIST : case ZFS_ERR_CHECKPOINT_EXISTS : case ZFS_ERR_DISCARDING_CHECKPOINT : break ; default : fatal ( 0 , "spa_vdev_remove() = %d" , error ) ; } } else { spa_config_exit ( spa , SCL_VDEV , FTAG ) ; nvroot = make_vdev_root ( NULL , NULL , NULL , ztest_opts . zo_vdev_size , 0 , ( ztest_random ( 4 ) == 0 ) ?"log" : NULL , ztest_opts . zo_raidz , zs -> zs_mirrors , 1 ) ; error = spa_vdev_add ( spa , nvroot ) ; nvlist_free ( nvroot ) ; switch ( error ) { case 0 : break ; case ENOSPC : ztest_record_enospc ( "spa_vdev_add" ) ; break ; default : fatal ( 0 , "spa_vdev_add() = %d" , error ) ; } } mutex_exit ( & ztest_vdev_lock ) ; } 