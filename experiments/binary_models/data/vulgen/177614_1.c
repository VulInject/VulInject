void ip_tunnel_xmit ( struct sk_buff * skb , struct net_device * dev , const struct iphdr * tnl_params , u8 protocol ) { struct ip_tunnel * tunnel = netdev_priv ( dev ) ; struct ip_tunnel_info * tun_info = NULL ; const struct iphdr * inner_iph ; unsigned int max_headroom ; struct rtable * rt = NULL ; __be16 payload_protocol ; bool use_cache = false ; struct flowi4 fl4 ; bool md = false ; bool connected ; u8 tos , ttl ; __be32 dst ; __be16 df ; inner_iph = ( const iphdr * ) skb_inner_network_header ( skb ) ; connected = ( tunnel -> parms . iph . daddr != 0 ) ; payload_protocol = skb_protocol ( skb , true ) ; memset ( & ( IPCB ( skb ) -> opt ) , 0 , sizeof ( IPCB ( skb ) -> opt ) ) ; dst = tnl_params -> daddr ; if ( dst == 0 ) { if ( ! skb_dst ( skb ) ) { DEV_STATS_INC ( dev , tx_fifo_errors ) ; tx_error } tun_info = skb_tunnel_info ( skb ) ; if ( tun_info && ( tun_info -> mode & IP_TUNNEL_INFO_TX ) && ip_tunnel_info_af ( tun_info ) == AF_INET && tun_info -> key . u . ipv4 . dst ) { dst = tun_info -> key . u . ipv4 . dst ; md = true ; connected = true ; } if ( payload_protocol == htons ( ETH_P_IP ) ) { rt = skb_rtable ( skb ) ; dst = rt_nexthop ( rt , inner_iph -> daddr ) ; } if ( payload_protocol == htons ( ETH_P_IPV6 ) ) { const struct in6_addr * addr6 ; struct neighbour * neigh ; bool do_tx_error_icmp ; int addr_type ; neigh = dst_neigh_lookup ( skb_dst ( skb ) , & ipv6_hdr ( skb ) -> daddr ) ; if ( ! neigh ) { tx_error } addr6 = ( const in6_addr * ) & neigh -> primary_key ; addr_type = ipv6_addr_type ( addr6 ) ; if ( addr_type == IPV6_ADDR_ANY ) { addr6 = & ipv6_hdr ( skb ) -> daddr ; addr_type = ipv6_addr_type ( addr6 ) ; } if ( ( addr_type & IPV6_ADDR_COMPATv4 ) == 0 ) { do_tx_error_icmp = true ; } else { do_tx_error_icmp = false ; dst = addr6 -> s6_addr32 [ 3 ] ; } neigh_release ( neigh ) ; if ( do_tx_error_icmp ) { tx_error_icmp } } else { tx_error } if ( ! md ) { connected = false ; } } tos = tnl_params -> tos ; if ( tos & 0x1 ) { tos &= ~ 0x1 ; if ( payload_protocol == htons ( ETH_P_IP ) ) { tos = inner_iph -> tos ; connected = false ; } if ( payload_protocol == htons ( ETH_P_IPV6 ) ) { tos = ipv6_get_dsfield ( ( const ipv6hdr * ) inner_iph ) ; connected = false ; } } ip_tunnel_init_flow ( & fl4 , protocol , dst , tnl_params -> saddr , tunnel -> parms . o_key , RT_TOS ( tos ) , dev_net ( dev ) , tunnel -> parms . link , tunnel -> fwmark , skb_get_hash ( skb ) , 0 ) ; if ( ip_tunnel_encap ( skb , tunnel , & protocol , & fl4 ) < 0 ) { tx_error } if ( connected && md ) { use_cache = ip_tunnel_dst_cache_usable ( skb , tun_info ) ; if ( use_cache ) { rt = dst_cache_get_ip4 ( & tun_info -> dst_cache , & fl4 . saddr ) ; } } else { rt = connected ?dst_cache_get_ip4 ( & tunnel -> dst_cache , & fl4 . saddr ) : NULL ; } if ( ! rt ) { rt = ip_route_output_key ( tunnel -> net , & fl4 ) ; if ( IS_ERR ( rt ) ) { DEV_STATS_INC ( dev , tx_carrier_errors ) ; tx_error } if ( use_cache ) { dst_cache_set_ip4 ( & tun_info -> dst_cache , & rt -> dst , fl4 . saddr ) ; } if ( ! md && connected ) { dst_cache_set_ip4 ( & tunnel -> dst_cache , & rt -> dst , fl4 . saddr ) ; } } if ( rt -> dst . dev == dev ) { ip_rt_put ( rt ) ; DEV_STATS_INC ( dev , collisions ) ; tx_error } df = tnl_params -> frag_off ; if ( payload_protocol == htons ( ETH_P_IP ) && ! tunnel -> ignore_df ) { df |= ( inner_iph -> frag_off & htons ( IP_DF ) ) ; } if ( tnl_update_pmtu ( dev , skb , rt , df , inner_iph , 0 , 0 , false ) ) { ip_rt_put ( rt ) ; tx_error } if ( tunnel -> err_count > 0 ) { if ( time_before ( jiffies , tunnel -> err_time + IPTUNNEL_ERR_TIMEO ) ) { tunnel -> err_count -- ; dst_link_failure ( skb ) ; } else { tunnel -> err_count = 0 ; } } tos = ip_tunnel_ecn_encap ( tos , inner_iph , skb ) ; ttl = tnl_params -> ttl ; if ( ttl == 0 ) { if ( payload_protocol == htons ( ETH_P_IP ) ) { ttl = inner_iph -> ttl ; } if ( payload_protocol == htons ( ETH_P_IPV6 ) ) { ttl = ( ( const ipv6hdr * ) inner_iph ) -> hop_limit ; } else { ttl = ip4_dst_hoplimit ( & rt -> dst ) ; } } max_headroom = LL_RESERVED_SPACE ( rt -> dst . dev ) + sizeof ( iphdr ) + rt -> dst . header_len + ip_encap_hlen ( & tunnel -> encap ) ; if ( skb_cow_head ( skb , dev -> needed_headroom ) ) { ip_rt_put ( rt ) ; DEV_STATS_INC ( dev , tx_dropped ) ; kfree_skb ( skb ) ; return ; } iptunnel_xmit ( NULL , rt , skb , fl4 . saddr , fl4 . daddr , protocol , tos , ttl , df , ! net_eq ( tunnel -> net , dev_net ( dev ) ) ) ; return ; tx_error_icmp dst_link_failure ( skb ) ; tx_error DEV_STATS_INC ( dev , tx_errors ) ; kfree_skb ( skb ) ; } 