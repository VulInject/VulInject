static size_t event_timer_test ( M_uint64 start_delay_ms , M_uint64 end_ms , M_uint64 interval_ms , M_uint64 max_runtime_ms , size_t fire_cnt , M_event_timer_mode_t mode , M_bool use_trigger , M_uint64 first_event_delay_ms ) { M_event_t * event = M_event_create ( M_EVENT_FLAG_EXITONEMPTY ) ; event_data_t * data = M_malloc_zero ( sizeof ( * data ) ) ; M_event_timer_t * timer ; size_t events ; event_debug ( "start_delay_ms=%llu, end_ms=%llu, interval_ms=%llu, max_runtime_ms=%llu, fire_cnt=%zu, mode=%s, use_trigger=%s, first_event_delay_ms=%llu" , start_delay_ms , end_ms , interval_ms , max_runtime_ms , fire_cnt , mode == M_EVENT_TIMER_MODE_RELATIVE ?"RELATIVE" : "MONOTONIC" , use_trigger ?"yes" : "no" , first_event_delay_ms ) ; data -> use_trigger = use_trigger ; if ( use_trigger ) { data -> trigger = M_event_trigger_add ( event , trigger_cb , data ) ; } timer = M_event_timer_add ( event , timer_cb , data ) ; if ( start_delay_ms ) { M_timeval_t tv ; M_time_gettimeofday ( & tv ) ; tv . tv_usec += ( M_uint32 ) ( start_delay_ms * 1000 ) ; tv . tv_sec += tv . tv_usec / 1000000 ; tv . tv_usec %= 1000000 ; M_event_timer_set_starttv ( timer , & tv ) ; } if ( end_ms ) { M_timeval_t tv ; M_time_gettimeofday ( & tv ) ; tv . tv_usec += ( M_uint32 ) ( end_ms * 1000 ) ; tv . tv_sec += tv . tv_usec / 1000000 ; tv . tv_usec %= 1000000 ; M_event_timer_set_endtv ( timer , & tv ) ; } data -> delay = first_event_delay_ms ; M_event_timer_set_mode ( timer , mode ) ; M_event_timer_set_firecount ( timer , fire_cnt ) ; M_event_timer_set_autoremove ( timer , M_TRUE ) ; if ( ! M_event_timer_start ( timer , interval_ms ) ) { cleanup } event_debug ( "entering loop" ) ; M_event_loop ( event , max_runtime_ms ) ; cleanup events = data -> events ; M_event_destroy ( event ) ; M_library_cleanup ( ) ; event_debug ( "exited (%zu events)" , events ) ; return events ; } 