int crypto_create_ctx_template ( crypto_mechanism_t * mech , crypto_key_t * key , crypto_ctx_template_t * ptmpl , int kmflag ) { int error ; kcf_mech_entry_t * me ; kcf_provider_desc_t * pd ; kcf_ctx_template_t * ctx_tmpl ; crypto_mechanism_t prov_mech ; if ( mech == NULL ) { return ( CRYPTO_MECHANISM_INVALID ) ; } error = kcf_get_sw_prov ( mech -> cm_type , & pd , & me , B_TRUE ) ; if ( error != CRYPTO_SUCCESS ) { return ( error ) ; } if ( ( ctx_tmpl = ( kcf_ctx_template_t * ) kmem_alloc ( sizeof ( kcf_ctx_template_t ) , kmflag ) ) == NULL ) { KCF_PROV_REFRELE ( pd ) ; return ( CRYPTO_HOST_MEMORY ) ; } prov_mech . cm_type = KCF_TO_PROV_MECHNUM ( pd , mech -> cm_type ) ; prov_mech . cm_param = mech -> cm_param ; prov_mech . cm_param_len = mech -> cm_param_len ; error = KCF_PROV_CREATE_CTX_TEMPLATE ( pd , & prov_mech , key , & ( ctx_tmpl -> ct_prov_tmpl ) , & ( ctx_tmpl -> ct_size ) , KCF_RHNDL ( kmflag ) ) ; if ( error == CRYPTO_SUCCESS ) { ctx_tmpl -> ct_generation = me -> me_gen_swprov ; * ptmpl = ctx_tmpl ; } else { kmem_free ( ctx_tmpl , sizeof ( kcf_ctx_template_t ) ) ; } KCF_PROV_REFRELE ( pd ) ; return ( error ) ; } 