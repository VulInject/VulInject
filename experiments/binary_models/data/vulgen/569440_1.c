char * cli_filter_json_set_options ( slurm_opt_t * options ) { int rc ; int argc = 0 ; char * * argv = NULL ; char * json = NULL ; char * name = NULL ; char * value = NULL ; char * plugin = NULL ; size_t st = 0 ; void * spst = NULL ; data_t * d , * dargv ; d = data_set_dict ( data_new ( ) ) ; while ( slurm_option_get_next_set ( options , & name , & value , & st ) ) { data_set_string_own ( data_key_set ( d , name ) , value ) ; } while ( spank_option_get_next_set ( & plugin , & name , & value , & spst ) ) { char * sname = xstrdup_printf ( "spank:%s" , name ) ; data_set_string_own ( data_key_set ( d , sname ) , value ) ; xfree ( sname ) ; } argv = options -> argv ; argc = options -> argc ; dargv = data_set_list ( data_key_set ( d , "argv" ) ) ; for ( char * * ptr = argv ; ptr && * ptr && ptr - argv < argc ; ptr ++ ) { data_set_string ( data_list_append ( dargv ) , * ptr ) ; } if ( ( rc = serialize_g_data_to_string ( & json , NULL , d , MIME_TYPE_JSON , SER_FLAGS_COMPACT ) ) ) { error ( "%s: unable to serialize JSON: %s" , __func__ , slurm_strerror ( rc ) ) ; } FREE_NULL_DATA ( d ) ; xfree ( plugin ) ; return json ; } 