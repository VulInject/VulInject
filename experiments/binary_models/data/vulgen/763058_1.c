static int dasd_diag_check_device ( struct dasd_device * device ) { struct dasd_diag_private * device -> private ; ; struct dasd_diag_characteristics * rdc_data ; struct vtoc_cms_label * label ; struct dasd_block * block ; struct dasd_diag_bio * bio ; unsigned int sb , bsize ; blocknum_t end_block ; int rc ; if ( private == NULL ) { private = kzalloc ( sizeof ( * private ) , GFP_KERNEL ) ; if ( private == NULL ) { DBF_DEV_EVENT ( DBF_WARNING , device , "%s" , "Allocating memory for private DASD data " "failed\n" ) ; return - ENOMEM ; } ccw_device_get_id ( device -> cdev , & private -> dev_id ) ; device -> private = private ; } block = dasd_alloc_block ( ) ; if ( IS_ERR ( block ) ) { DBF_DEV_EVENT ( DBF_WARNING , device , "%s" , "could not allocate dasd block structure" ) ; device -> private = NULL ; return PTR_ERR ( block ) ; } device -> block = block ; block -> base = device ; rdc_data = & private -> rdc_data ; rdc_data -> dev_nr = private -> dev_id . devno ; rdc_data -> rdc_len = sizeof ( dasd_diag_characteristics ) ; rc = diag210 ( ( diag210 * ) rdc_data ) ; if ( rc ) { DBF_DEV_EVENT ( DBF_WARNING , device , "failed to retrieve device " "information (rc=%d)" , rc ) ; rc = - EOPNOTSUPP ; out } device -> default_expires = DIAG_TIMEOUT ; device -> default_retries = DIAG_MAX_RETRIES ; switch ( private -> rdc_data . vdev_class ) { case DEV_CLASS_FBA : private -> pt_block = 1 ; break ; case DEV_CLASS_ECKD : private -> pt_block = 2 ; break ; default : pr_warn ( "%s: Device type %d is not supported in DIAG mode\n" , dev_name ( & device -> cdev -> dev ) , private -> rdc_data . vdev_class ) ; rc = - EOPNOTSUPP ; out } DBF_DEV_EVENT ( DBF_INFO , device , "%04X: %04X on real %04X/%02X" , rdc_data -> dev_nr , rdc_data -> vdev_type , rdc_data -> rdev_type , rdc_data -> rdev_model ) ; mdsk_term_io ( device ) ; label = ( vtoc_cms_label * ) get_zeroed_page ( GFP_KERNEL ) ; if ( label == NULL ) { DBF_DEV_EVENT ( DBF_WARNING , device , "%s" , "No memory to allocate initialization request" ) ; rc = - ENOMEM ; out } bio = kzalloc ( sizeof ( * bio ) , GFP_KERNEL ) ; if ( bio == NULL ) { DBF_DEV_EVENT ( DBF_WARNING , device , "%s" , "No memory to allocate initialization bio" ) ; rc = - ENOMEM ; out_label } rc = 0 ; end_block = 0 ; for ( bsize = 512 ; bsize <= PAGE_SIZE ; bsize <<= 1 ) { mdsk_init_io ( device , bsize , 0 , & end_block ) ; memset ( bio , 0 , sizeof ( * bio ) ) ; bio -> type = MDSK_READ_REQ ; bio -> block_number = private -> pt_block + 1 ; bio -> buffer = label ; memset ( & private -> iob , 0 , sizeof ( dasd_diag_rw_io ) ) ; private -> iob . dev_nr = rdc_data -> dev_nr ; private -> iob . key = 0 ; private -> iob . flags = 0 ; private -> iob . block_count = 1 ; private -> iob . interrupt_params = 0 ; private -> iob . bio_list = bio ; private -> iob . flaga = DASD_DIAG_FLAGA_DEFAULT ; rc = dia250 ( & private -> iob , RW_BIO ) ; if ( rc == 3 ) { pr_warn ( "%s: A 64-bit DIAG call failed\n" , dev_name ( & device -> cdev -> dev ) ) ; rc = - EOPNOTSUPP ; out_bio } mdsk_term_io ( device ) ; if ( rc == 0 ) { break ; } } if ( bsize > PAGE_SIZE ) { pr_warn ( "%s: Accessing the DASD failed because of an incorrect format (rc=%d)\n" , dev_name ( & device -> cdev -> dev ) , rc ) ; rc = - EIO ; out_bio } if ( memcmp ( label -> label_id , DASD_DIAG_CMS1 , sizeof ( DASD_DIAG_CMS1 ) ) == 0 ) { bsize = ( unsigned int ) label -> block_size ; block -> blocks = ( unsigned long ) label -> block_count ; } else { block -> blocks = end_block ; } block -> bp_block = bsize ; block -> s2b_shift = 0 ; for ( sb = 512 ; sb < bsize ; sb = sb << 1 ) { block -> s2b_shift ++ ; } rc = mdsk_init_io ( device , block -> bp_block , 0 , NULL ) ; if ( rc && ( rc != 4 ) ) { pr_warn ( "%s: DIAG initialization failed with rc=%d\n" , dev_name ( & device -> cdev -> dev ) , rc ) ; rc = - EIO ; } else { if ( rc == 4 ) { set_bit ( DASD_FLAG_DEVICE_RO , & device -> flags ) ; } pr_info ( "%s: New DASD with %ld byte/block, total size %ld " "KB%s\n" , dev_name ( & device -> cdev -> dev ) , ( unsigned long ) block -> bp_block , ( unsigned long ) ( block -> blocks << block -> s2b_shift ) >> 1 , ( rc == 4 ) ?", read-only device" : "" ) ; rc = 0 ; } out_bio kfree ( bio ) ; out_label free_page ( ( long ) label ) ; out if ( rc ) { device -> block = NULL ; dasd_free_block ( block ) ; device -> private = NULL ; kfree ( private ) ; } return rc ; } 