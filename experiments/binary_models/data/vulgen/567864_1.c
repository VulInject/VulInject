static rsRetVal lookupReloadOrStub ( lookup_ref_t * pThis , const uchar * stub_val ) { lookup_t * newlu , * oldlu ; DEFiRet ; oldlu = pThis -> self ; newlu = NULL ; DBGPRINTF ( "reload requested for lookup table '%s'\n" , pThis -> name ) ; if ( stub_val == NULL ) { CHKiRet ( lookupReadFile ( newlu , pThis -> name , pThis -> filename ) ) ; } else { CHKiRet ( lookupBuildStubbedTable ( newlu , stub_val ) ) ; } pthread_rwlock_wrlock ( & pThis -> rwlock ) ; pThis -> self = newlu ; pthread_rwlock_unlock ( & pThis -> rwlock ) ; finalize_it if ( iRet != RS_RET_OK ) { if ( stub_val == NULL ) { LogError ( 0 , RS_RET_INTERNAL_ERROR , "lookup table '%s' could not be reloaded from file '%s'" , pThis -> name , pThis -> filename ) ; } else { LogError ( 0 , RS_RET_INTERNAL_ERROR , "lookup table '%s' could not be stubbed with value '%s'" , pThis -> name , stub_val ) ; } lookupDestruct ( newlu ) ; } else { if ( stub_val == NULL ) { LogMsg ( 0 , RS_RET_OK , LOG_INFO , "lookup table '%s' reloaded from file '%s'" , pThis -> name , pThis -> filename ) ; } else { LogError ( 0 , RS_RET_OK , "lookup table '%s' stubbed with value '%s'" , pThis -> name , stub_val ) ; } lookupDestruct ( oldlu ) ; } RETiRet ; } 