static void vfio_pci_relocate_msix ( VFIOPCIDevice * vdev , Error * * errp ) { int target_bar = - 1 ; size_t msix_sz ; if ( ! vdev -> msix || vdev -> msix_relo == OFF_AUTOPCIBAR_OFF ) { return ; } msix_sz = ( vdev -> msix -> entries * PCI_MSIX_ENTRY_SIZE ) + ( QEMU_ALIGN_UP ( vdev -> msix -> entries , 64 ) / 8 ) ; msix_sz = REAL_HOST_PAGE_ALIGN ( msix_sz ) ; msix_sz = pow2ceil ( msix_sz ) ; if ( vdev -> msix_relo == OFF_AUTOPCIBAR_AUTO ) { if ( target_bar < 0 ) { error_setg ( errp , "No automatic MSI-X relocation available for " "device %04x:%04x" , vdev -> vendor_id , vdev -> device_id ) ; return ; } } else { target_bar = ( int ) ( vdev -> msix_relo - OFF_AUTOPCIBAR_BAR0 ) ; } if ( ! vdev -> bars [ target_bar ] . size && target_bar > 0 && vdev -> bars [ target_bar - 1 ] . mem64 ) { error_setg ( errp , "Invalid MSI-X relocation BAR %d, " "consumed by 64-bit BAR %d" , target_bar , target_bar - 1 ) ; return ; } if ( vdev -> bars [ target_bar ] . size > 1 * GiB && ! vdev -> bars [ target_bar ] . mem64 ) { error_setg ( errp , "Invalid MSI-X relocation BAR %d, " "no space to extend 32-bit BAR" , target_bar ) ; return ; } if ( ! vdev -> bars [ target_bar ] . size ) { if ( target_bar < ( PCI_ROM_SLOT - 1 ) && ! vdev -> bars [ target_bar + 1 ] . size ) { vdev -> bars [ target_bar ] . mem64 = true ; vdev -> bars [ target_bar ] . type = PCI_BASE_ADDRESS_MEM_TYPE_64 ; } vdev -> bars [ target_bar ] . type |= PCI_BASE_ADDRESS_MEM_PREFETCH ; vdev -> bars [ target_bar ] . size = msix_sz ; vdev -> msix -> table_offset = 0 ; } else { vdev -> bars [ target_bar ] . size = MAX ( vdev -> bars [ target_bar ] . size * 2 , msix_sz * 2 ) ; vdev -> msix -> table_offset = vdev -> bars [ target_bar ] . size / 2 ; } vdev -> msix -> table_bar = target_bar ; vdev -> msix -> pba_bar = target_bar ; vdev -> msix -> pba_offset = vdev -> msix -> table_offset + ( vdev -> msix -> entries * PCI_MSIX_ENTRY_SIZE ) ; trace_vfio_msix_relo ( vdev -> vbasedev . name , vdev -> msix -> table_bar , vdev -> msix -> table_offset ) ; } 