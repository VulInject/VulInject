int pci_alloc_resource ( dev_info_t * dip , pci_regspec_t phys_spec ) { uint64_t answer ; uint64_t alen ; int offset , tmp ; pci_regspec_t config ; caddr_t virt , v ; ddi_device_acc_attr_t acc ; ddi_acc_handle_t h ; ndi_ra_request_t request ; pci_regspec_t * assigned ; int assigned_len , entries , i , l , flags = 0 , error ; l = phys_spec . pci_size_low ; if ( ddi_getlongprop ( DDI_DEV_T_ANY , dip , DDI_PROP_DONTPASS , "assigned-addresses" , ( caddr_t ) & assigned , & assigned_len ) == DDI_PROP_SUCCESS ) { entries = assigned_len / ( sizeof ( pci_regspec_t ) ) ; for ( i = 0 ; i < entries ; i ++ ) { if ( assigned [ i ] . pci_phys_hi == phys_spec . pci_phys_hi ) { if ( assigned [ i ] . pci_size_low >= phys_spec . pci_size_low ) { return ( 0 ) ; } ( void ) pci_free_resource ( dip , assigned [ i ] ) ; break ; } if ( PCI_REG_BDFR_G ( assigned [ i ] . pci_phys_hi ) == PCI_REG_BDFR_G ( phys_spec . pci_phys_hi ) ) { if ( PCI_REG_ADDR_G ( assigned [ i ] . pci_phys_hi ) != PCI_REG_ADDR_G ( phys_spec . pci_phys_hi ) ) { FC_DEBUG2 ( 2 , CE_WARN , "Fcode changing " "ss bits in reg %x -- %x" , assigned [ i ] . pci_phys_hi , phys_spec . pci_phys_hi ) ; } l = MAX ( assigned [ i ] . pci_size_low , phys_spec . pci_size_low ) ; phys_spec . pci_size_low = l ; ( void ) pci_free_resource ( dip , assigned [ i ] ) ; break ; } } kmem_free ( assigned , assigned_len ) ; } bzero ( ( caddr_t ) & request , sizeof ( ndi_ra_request_t ) ) ; config . pci_phys_hi = PCI_CONF_ADDR_MASK & phys_spec . pci_phys_hi ; config . pci_phys_hi &= ~ PCI_REG_REG_M ; config . pci_phys_mid = config . pci_phys_low = 0 ; config . pci_size_hi = config . pci_size_low = 0 ; acc . devacc_attr_version = DDI_DEVICE_ATTR_V0 ; acc . devacc_attr_endian_flags = DDI_STRUCTURE_LE_ACC ; acc . devacc_attr_dataorder = DDI_STRICTORDER_ACC ; if ( error = pci_map_phys ( dip , & config , & virt , & acc , & h ) ) { return ( 1 ) ; } if ( fcpci_indirect_map ( dip ) == DDI_SUCCESS ) { flags |= PCICFG_CONF_INDIRECT_MAP ; } if ( flags & PCICFG_CONF_INDIRECT_MAP ) { tmp = ( int32_t ) ddi_get32 ( h , ( uint32_t * ) virt ) ; error = DDI_SUCCESS ; } else { error = ddi_peek32 ( dip , ( int32_t * ) virt , ( int32_t * ) & tmp ) ; } if ( error == DDI_SUCCESS ) { if ( ( tmp == ( int32_t ) 0xffffffff ) || ( tmp == - 1 ) ) { error = DDI_FAILURE ; } } if ( error != DDI_SUCCESS ) { return ( 1 ) ; } request . ra_flags |= NDI_RA_ALIGN_SIZE ; request . ra_boundbase = 0 ; request . ra_boundlen = PCI_4GIG_LIMIT ; offset = PCI_REG_REG_G ( phys_spec . pci_phys_hi ) ; v = virt + offset ; if ( PCI_REG_REG_G ( phys_spec . pci_phys_hi ) == PCI_CONF_ROM ) { request . ra_len = l ; request . ra_flags ^= NDI_RA_ALLOC_BOUNDED ; if ( ndi_ra_alloc ( ddi_get_parent ( dip ) , & request , & answer , & alen , NDI_RA_TYPE_MEM , NDI_RA_PASS ) != NDI_SUCCESS ) { pci_unmap_phys ( & h , & config ) ; return ( 1 ) ; } FC_DEBUG3 ( 1 , CE_CONT , "ROM addr = [0x%x.%x] len [0x%x]\n" , HIADDR ( answer ) , LOADDR ( answer ) , alen ) ; ddi_put32 ( h , ( uint32_t * ) v , LOADDR ( answer ) ) ; phys_spec . pci_phys_low = LOADDR ( answer ) ; phys_spec . pci_phys_mid = HIADDR ( answer ) ; } else { request . ra_len = l ; switch ( PCI_REG_ADDR_G ( phys_spec . pci_phys_hi ) ) { case PCI_REG_ADDR_G ( PCI_ADDR_MEM64 ) : request . ra_flags ^= NDI_RA_ALLOC_BOUNDED ; if ( phys_spec . pci_phys_hi & PCI_REG_REL_M ) { request . ra_flags = NDI_RA_ALLOC_SPECIFIED ; request . ra_addr = ( uint64_t ) LADDR ( phys_spec . pci_phys_low , phys_spec . pci_phys_mid ) ; } if ( ndi_ra_alloc ( ddi_get_parent ( dip ) , & request , & answer , & alen , NDI_RA_TYPE_MEM , NDI_RA_PASS ) != NDI_SUCCESS ) { pci_unmap_phys ( & h , & config ) ; if ( request . ra_flags == NDI_RA_ALLOC_SPECIFIED ) { cmn_err ( CE_WARN , "Unable to allocate " "non relocatable address 0x%p\n" , ( void * ) request . ra_addr ) ; } return ( 1 ) ; } FC_DEBUG3 ( 1 , CE_CONT , "64 addr = [0x%x.%x] len [0x%x]\n" , HIADDR ( answer ) , LOADDR ( answer ) , alen ) ; ddi_put32 ( h , ( uint32_t * ) v , LOADDR ( answer ) ) ; v += 4 ; ddi_put32 ( h , ( uint32_t * ) v , HIADDR ( answer ) ) ; phys_spec . pci_phys_low = LOADDR ( answer ) ; phys_spec . pci_phys_mid = HIADDR ( answer ) ; phys_spec . pci_phys_hi ^= PCI_ADDR_MEM64 ^ PCI_ADDR_MEM32 ; break ; case PCI_REG_ADDR_G ( PCI_ADDR_MEM32 ) : request . ra_flags |= NDI_RA_ALLOC_BOUNDED ; if ( phys_spec . pci_phys_hi & PCI_REG_REL_M ) { request . ra_flags = NDI_RA_ALLOC_SPECIFIED ; request . ra_addr = ( uint64_t ) phys_spec . pci_phys_low ; } if ( ndi_ra_alloc ( ddi_get_parent ( dip ) , & request , & answer , & alen , NDI_RA_TYPE_MEM , NDI_RA_PASS ) != NDI_SUCCESS ) { pci_unmap_phys ( & h , & config ) ; if ( request . ra_flags == NDI_RA_ALLOC_SPECIFIED ) { cmn_err ( CE_WARN , "Unable to allocate " "non relocatable address 0x%p\n" , ( void * ) request . ra_addr ) ; } return ( 1 ) ; } FC_DEBUG3 ( 1 , CE_CONT , "32 addr = [0x%x.%x] len [0x%x]\n" , HIADDR ( answer ) , LOADDR ( answer ) , alen ) ; ddi_put32 ( h , ( uint32_t * ) v , LOADDR ( answer ) ) ; phys_spec . pci_phys_low = LOADDR ( answer ) ; break ; case PCI_REG_ADDR_G ( PCI_ADDR_IO ) : request . ra_flags |= NDI_RA_ALLOC_BOUNDED ; if ( phys_spec . pci_phys_hi & PCI_REG_REL_M ) { request . ra_flags = NDI_RA_ALLOC_SPECIFIED ; request . ra_addr = ( uint64_t ) phys_spec . pci_phys_low ; } if ( ndi_ra_alloc ( ddi_get_parent ( dip ) , & request , & answer , & alen , NDI_RA_TYPE_IO , NDI_RA_PASS ) != NDI_SUCCESS ) { pci_unmap_phys ( & h , & config ) ; if ( request . ra_flags == NDI_RA_ALLOC_SPECIFIED ) { cmn_err ( CE_WARN , "Unable to allocate " "non relocatable IO Space 0x%p\n" , ( void * ) request . ra_addr ) ; } return ( 1 ) ; } FC_DEBUG3 ( 1 , CE_CONT , "I/O addr = [0x%x.%x] len [0x%x]\n" , HIADDR ( answer ) , LOADDR ( answer ) , alen ) ; ddi_put32 ( h , ( uint32_t * ) v , LOADDR ( answer ) ) ; phys_spec . pci_phys_low = LOADDR ( answer ) ; break ; default : pci_unmap_phys ( & h , & config ) ; return ( 1 ) ; } } if ( pfc_update_assigned_prop ( dip , & phys_spec ) ) { pci_unmap_phys ( & h , & config ) ; return ( 1 ) ; } pci_unmap_phys ( & h , & config ) ; return ( 0 ) ; } 