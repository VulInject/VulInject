static void __debug_check_no_obj_freed ( const void * address , unsigned long size ) { unsigned long flags , oaddr , saddr , eaddr , paddr , chunks ; const struct debug_obj_descr * descr ; enum debug_obj_state state ; struct debug_bucket * db ; struct hlist_node * tmp ; struct debug_obj * obj ; int cnt , objs_checked = 0 ; saddr = ( unsigned long ) address ; eaddr = saddr + size ; paddr = saddr & ODEBUG_CHUNK_MASK ; chunks = ( ( eaddr - paddr ) + ( ODEBUG_CHUNK_SIZE - 1 ) ) ; chunks >>= ODEBUG_CHUNK_SHIFT ; for ( ; chunks > 0 ; chunks -- , paddr += ODEBUG_CHUNK_SIZE ) { db = get_bucket ( paddr ) ; repeat cnt = 0 ; raw_spin_lock_irqsave ( & db -> lock , flags ) ; hlist_for_each_entry_safe ( , , , ) { cnt ++ ; oaddr = ( unsigned long ) obj -> object ; switch ( obj -> state ) { case ODEBUG_STATE_ACTIVE : descr = obj -> descr ; state = obj -> state ; raw_spin_unlock_irqrestore ( & db -> lock , flags ) ; debug_print_object ( obj , "free" ) ; debug_object_fixup ( descr -> fixup_free , ( void * ) oaddr , state ) ; repeat default : hlist_del ( & obj -> node ) ; __free_object ( obj ) ; break ; } } raw_spin_unlock_irqrestore ( & db -> lock , flags ) ; if ( cnt > debug_objects_maxchain ) { debug_objects_maxchain = cnt ; } objs_checked += cnt ; } if ( objs_checked > debug_objects_maxchecked ) { debug_objects_maxchecked = objs_checked ; } if ( ! READ_ONCE ( obj_freeing ) && READ_ONCE ( obj_nr_tofree ) ) { WRITE_ONCE ( obj_freeing , true ) ; schedule_delayed_work ( & debug_obj_work , ODEBUG_FREE_WORK_DELAY ) ; } } 