setsockopt ( , , , , ) if ( strncmp ( sep -> se_proto , "tcp" , 3 ) == 0 && debug && turnon ( sep -> se_fd , SO_DEBUG ) < 0 ) { syslog ( LOG_ERR , "setsockopt (SO_DEBUG): %m" ) ; } if ( turnon ( sep -> se_fd , SO_REUSEADDR ) < 0 ) { syslog ( LOG_ERR , "setsockopt (SO_REUSEADDR): %m" ) ; } if ( isrpcservice ( sep ) ) { struct passwd * pwd ; sep -> se_ctrladdr_in . sin_port = 0 ; if ( sep -> se_user && ( pwd = getpwnam ( sep -> se_user ) ) && pwd -> pw_uid == 0 && uid == 0 ) { r = bindresvport ( sep -> se_fd , & sep -> se_ctrladdr_in ) ; } else { r = bind ( sep -> se_fd , & sep -> se_ctrladdr , sep -> se_ctrladdr_size ) ; if ( r == 0 ) { socklen_t len = sep -> se_ctrladdr_size ; int saveerrno = errno ; r = getsockname ( sep -> se_fd , & sep -> se_ctrladdr , & len ) ; if ( r <= 0 ) { errno = saveerrno ; } } } } else { if ( sep -> se_family == AF_UNIX ) { mask = umask ( 0111 ) ; } r = bind ( sep -> se_fd , & sep -> se_ctrladdr , sep -> se_ctrladdr_size ) ; if ( sep -> se_family == AF_UNIX ) { umask ( mask ) ; } } if ( r == - 1 ) { syslog ( LOG_ERR , "%s/%s: bind: %m" , sep -> se_service , sep -> se_proto ) ; ( void ) close ( sep -> se_fd ) ; sep -> se_fd = - 1 ; if ( ! timingout ) { alarm ( RETRYTIME ) ; } return ; } if ( sep -> se_socktype == SOCK_STREAM ) { listen ( sep -> se_fd , 10 ) ; } if ( ! sep -> se_wait && sep -> se_socktype == SOCK_STREAM ) { event_set ( & sep -> se_event , sep -> se_fd , EV_READ | EV_PERSIST , gettcp , sep ) ; } else { event_set ( & sep -> se_event , sep -> se_fd , EV_READ | EV_PERSIST , spawn , sep ) ; } event_add ( & sep -> se_event , NULL ) ; if ( sep -> se_fd > maxsock ) { maxsock = sep -> se_fd ; if ( maxsock > rlim_nofile_cur - FD_MARGIN ) { bump_nofile ( ) ; } } 