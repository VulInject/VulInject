static void ppp_async_input ( struct asyncppp * ap , const unsigned char * buf , const char * flags , int count ) { struct sk_buff * skb ; int c , i , j , n , s , f ; unsigned char * sp ; if ( ~ ap -> rbits & SC_RCV_BITS ) { s = 0 ; for ( i = 0 ; i < count ; ++ i ) { c = buf [ i ] ; if ( flags && flags [ i ] != 0 ) { continue ; } s |= ( c & 0x80 ) ?SC_RCV_B7_1 : SC_RCV_B7_0 ; c = ( ( c >> 4 ) ^ c ) & 0xf ; s |= ( 0x6996 & ( 1 << c ) ) ?SC_RCV_ODDP : SC_RCV_EVNP ; } ap -> rbits |= s ; } while ( count > 0 ) { if ( ( ap -> state & SC_ESCAPE ) && buf [ 0 ] == PPP_ESCAPE ) { n = 1 ; } else { n = scan_ordinary ( ap , buf , count ) ; } f = 0 ; if ( flags && ( ap -> state & SC_TOSS ) == 0 ) { for ( j = 0 ; j < n ; ++ j ) { if ( ( f = flags [ j ] ) != 0 ) { break ; } } } if ( f != 0 ) { ap -> state |= SC_TOSS ; } if ( n > 0 && ( ap -> state & SC_TOSS ) == 0 ) { skb = ap -> rpkt ; if ( ! skb ) { skb = dev_alloc_skb ( ap -> mru + PPP_HDRLEN + 2 ) ; if ( ! skb ) { nomem } ap -> rpkt = skb ; } if ( skb -> len == 0 ) { if ( buf [ 0 ] != PPP_ALLSTATIONS ) { skb_reserve ( skb , 2 + ( buf [ 0 ] & 1 ) ) ; } } if ( n > skb_tailroom ( skb ) ) { ap -> state |= SC_TOSS ; } else { if ( ap -> state & SC_ESCAPE ) { sp [ 0 ] ^= PPP_TRANS ; ap -> state &= ~ SC_ESCAPE ; } } } if ( n >= count ) { break ; } c = buf [ n ] ; if ( flags != NULL && flags [ n ] != 0 ) { ap -> state |= SC_TOSS ; } if ( c == PPP_FLAG ) { process_input_packet ( ap ) ; } if ( c == PPP_ESCAPE ) { ap -> state |= SC_ESCAPE ; } if ( I_IXON ( ap -> tty ) ) { if ( c == START_CHAR ( ap -> tty ) ) { start_tty ( ap -> tty ) ; } if ( c == STOP_CHAR ( ap -> tty ) ) { stop_tty ( ap -> tty ) ; } } ++ n ; buf += n ; if ( flags ) { flags += n ; } count -= n ; } return ; nomem printk ( KERN_ERR "PPPasync: no memory (input pkt)\n" ) ; ap -> state |= SC_TOSS ; } 