static void smb_netbios_datagram_error ( unsigned char * buf ) { int error ; int datagram_id ; if ( buf [ 0 ] != DATAGRAM_TYPE_ERROR_DATAGRAM ) { return ; } datagram_id = BE_IN16 ( & buf [ 2 ] ) ; error = buf [ DATAGRAM_ERR_HEADER_LENGTH - 1 ] ; switch ( error ) { case DATAGRAM_INVALID_SOURCE_NAME_FORMAT : smb_tracef ( "NbtDatagramError[%d]: invalid source name format" , datagram_id ) ; break ; case DATAGRAM_INVALID_DESTINATION_NAME_FORMAT : smb_tracef ( "NbtDatagramError[%d]: invalid destination name " "format" , datagram_id ) ; break ; case DATAGRAM_DESTINATION_NAME_NOT_PRESENT : default : break ; } } static struct datagram * smb_netbios_datagram_getq ( struct datagram * datagram ) { struct datagram * prev = 0 ; ( void ) mutex_lock ( & smb_dgq_mtx ) ; for ( prev = smb_datagram_queue . forw ; prev != ( datagram * ) ( ( uintptr_t ) & smb_datagram_queue ) ; prev = prev -> forw ) { if ( prev -> src . addr_list . sin . sin_addr . s_addr == datagram -> src . addr_list . sin . sin_addr . s_addr ) { QUEUE_CLIP ( prev ) ; ( void ) mutex_unlock ( & smb_dgq_mtx ) ; bcopy ( datagram -> data , & prev -> data [ prev -> data_length ] , datagram -> data_length ) ; prev -> data_length += datagram -> data_length ; return ( prev ) ; } } ( void ) mutex_unlock ( & smb_dgq_mtx ) ; return ( 0 ) ; } 