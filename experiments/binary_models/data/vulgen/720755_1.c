static void spu_bind_context ( struct spu * spu , struct spu_context * ctx ) { spu_context_trace ( spu_bind_context__enter , ctx , spu ) ; spuctx_switch_state ( ctx , SPU_UTIL_SYSTEM ) ; if ( ctx -> flags & SPU_CREATE_NOSCHED ) { atomic_inc ( & cbe_spu_info [ spu -> node ] . reserved_spus ) ; } ctx -> stats . slb_flt_base = spu -> stats . slb_flt ; ctx -> stats . class2_intr_base = spu -> stats . class2_intr ; spu_associate_mm ( spu , ctx -> owner ) ; spin_lock_irq ( & spu -> register_lock ) ; spu -> ctx = ctx ; spu -> flags = 0 ; ctx -> spu = spu ; ctx -> ops = & spu_hw_ops ; spu -> pid = current -> pid ; spu -> tgid = current -> tgid ; spu -> ibox_callback = spufs_ibox_callback ; spu -> wbox_callback = spufs_wbox_callback ; spu -> stop_callback = spufs_stop_callback ; spu -> mfc_callback = spufs_mfc_callback ; spin_unlock_irq ( & spu -> register_lock ) ; spu_unmap_mappings ( ctx ) ; spu_switch_log_notify ( spu , ctx , SWITCH_LOG_START , 0 ) ; spu_restore ( & ctx -> csa , spu ) ; spu_switch_notify ( spu , ctx ) ; ctx -> state = SPU_STATE_RUNNABLE ; spuctx_switch_state ( ctx , SPU_UTIL_USER ) ; } 