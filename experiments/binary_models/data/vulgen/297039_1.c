int topo_method_sensor_failure ( topo_mod_t * mod , tnode_t * node , topo_version_t version , nvlist_t * in , nvlist_t * * out ) { topo_faclist_t faclist , * fp ; int err ; nvlist_t * nvl , * props , * propval , * tmp ; int ret = - 1 ; uint32_t type , state , units ; nvpair_t * elem ; double reading ; char * propname ; boolean_t has_reading , is_spoofed = B_FALSE ; struct sensor_errinfo seinfo ; if ( topo_node_facility ( mod -> tm_hdl , node , TOPO_FAC_TYPE_SENSOR , TOPO_FAC_TYPE_ANY , & faclist , & err ) != 0 ) { return ( topo_mod_seterrno ( mod , ETOPO_METHOD_NOTSUP ) ) ; } if ( topo_mod_nvalloc ( mod , & nvl , NV_UNIQUE_NAME ) != 0 ) { error } for ( fp = topo_list_next ( & faclist . tf_list ) ; fp != NULL ; fp = topo_list_next ( fp ) ) { if ( topo_prop_getpgrp ( fp -> tf_node , TOPO_PGROUP_FACILITY , & props , & err ) != 0 ) { error } type = state = units = 0 ; reading = 0 ; has_reading = B_FALSE ; elem = NULL ; while ( ( elem = nvlist_next_nvpair ( props , elem ) ) != NULL ) { if ( strcmp ( nvpair_name ( elem ) , TOPO_PROP_VAL ) != 0 || nvpair_type ( elem ) != DATA_TYPE_NVLIST ) { continue ; } ( void ) nvpair_value_nvlist ( elem , & propval ) ; if ( nvlist_lookup_string ( propval , TOPO_PROP_VAL_NAME , & propname ) != 0 ) { continue ; } if ( strcmp ( propname , TOPO_FACILITY_TYPE ) == 0 ) { ( void ) nvlist_lookup_uint32 ( propval , TOPO_PROP_VAL_VAL , & type ) ; } if ( strcmp ( propname , TOPO_SENSOR_STATE ) == 0 ) { ( void ) nvlist_lookup_uint32 ( propval , TOPO_PROP_VAL_VAL , & state ) ; } if ( strcmp ( propname , TOPO_SENSOR_UNITS ) == 0 ) { ( void ) nvlist_lookup_uint32 ( propval , TOPO_PROP_VAL_VAL , & units ) ; } if ( strcmp ( propname , TOPO_SENSOR_READING ) == 0 ) { has_reading = B_TRUE ; ( void ) nvlist_lookup_double ( propval , TOPO_PROP_VAL_VAL , & reading ) ; } } if ( in != NULL ) { is_spoofed = topo_spoof_apply ( mod -> tm_hdl , node , fp -> tf_node , in , & state ) ; } if ( topo_sensor_failed ( type , state , & seinfo ) ) { tmp = NULL ; if ( topo_mod_nvalloc ( mod , & tmp , NV_UNIQUE_NAME ) != 0 || nvlist_add_uint32 ( tmp , TOPO_FACILITY_TYPE , type ) != 0 || nvlist_add_uint32 ( tmp , TOPO_SENSOR_STATE , state ) != 0 || nvlist_add_uint32 ( tmp , TOPO_SENSOR_UNITS , units ) != 0 || nvlist_add_boolean_value ( tmp , "nonrecov" , seinfo . se_nonrecov ) != 0 || nvlist_add_boolean_value ( tmp , "predictive" , seinfo . se_predictive ) != 0 || nvlist_add_uint32 ( tmp , "source" , seinfo . se_src ) != 0 || nvlist_add_boolean_value ( nvl , "injected" , is_spoofed ) != 0 || ( has_reading && nvlist_add_double ( tmp , TOPO_SENSOR_READING , reading ) != 0 ) || nvlist_add_nvlist ( nvl , topo_node_name ( fp -> tf_node ) , tmp ) != 0 ) { nvlist_free ( props ) ; nvlist_free ( tmp ) ; nvlist_free ( nvl ) ; ret = topo_mod_seterrno ( mod , ETOPO_METHOD_NOMEM ) ; error } nvlist_free ( tmp ) ; } nvlist_free ( props ) ; is_spoofed = B_FALSE ; } * out = nvl ; ret = 0 ; error while ( ( fp = topo_list_next ( & faclist . tf_list ) ) != NULL ) { topo_list_delete ( & faclist . tf_list , fp ) ; topo_mod_free ( mod , fp , sizeof ( topo_faclist_t ) ) ; } return ( ret ) ; } 