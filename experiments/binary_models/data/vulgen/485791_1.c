sh64_get_contents_type_disasm ( , ) { struct sh64_disassemble_info * sh64_infop = info -> private_data ; if ( sh64_infop -> crange . cr_type != CRT_NONE && memaddr >= sh64_infop -> crange . cr_addr && memaddr < sh64_infop -> crange . cr_addr + sh64_infop -> crange . cr_size ) { return sh64_infop -> crange . cr_type ; } if ( info -> section && bfd_get_flavour ( info -> section -> owner ) == bfd_target_elf_flavour ) { enum sh64_elf_cr_type cr_type = sh64_get_contents_type ( info -> section , memaddr , & sh64_infop -> crange ) ; if ( cr_type != CRT_NONE ) { return cr_type ; } } if ( info -> symbols != NULL && bfd_asymbol_flavour ( info -> symbols [ 0 ] ) == bfd_target_elf_flavour && ! bfd_is_und_section ( bfd_get_section ( info -> symbols [ 0 ] ) ) && ! bfd_is_abs_section ( bfd_get_section ( info -> symbols [ 0 ] ) ) ) { enum sh64_elf_cr_type cr_type = sh64_get_contents_type ( bfd_get_section ( info -> symbols [ 0 ] ) , memaddr , & sh64_infop -> crange ) ; } if ( info -> symbols && bfd_asymbol_flavour ( info -> symbols [ 0 ] ) == bfd_target_elf_flavour && elf_symbol_from ( bfd_asymbol_bfd ( info -> symbols [ 0 ] ) , info -> symbols [ 0 ] ) -> internal_elf_sym . st_other == STO_SH5_ISA32 ) { return CRT_SH5_ISA32 ; } return ( memaddr & 1 ) == 1 ?CRT_SH5_ISA32 : CRT_SH5_ISA16 ; } 