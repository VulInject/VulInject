static void fsl_elbc_cmdfunc ( struct nand_chip * chip , unsigned int command , int column , int page_addr ) { struct mtd_info * mtd = nand_to_mtd ( chip ) ; struct fsl_elbc_mtd * priv = nand_get_controller_data ( chip ) ; struct fsl_lbc_ctrl * ctrl = priv -> ctrl ; struct fsl_elbc_fcm_ctrl * elbc_fcm_ctrl = ctrl -> nand ; struct fsl_lbc_regs __iomem * lbc = ctrl -> regs ; elbc_fcm_ctrl -> use_mdr = 0 ; elbc_fcm_ctrl -> read_bytes = 0 ; switch ( command ) { case NAND_CMD_READ1 : column += 256 ; fallthrough ; case NAND_CMD_READ0 : dev_dbg ( priv -> dev , "fsl_elbc_cmdfunc: NAND_CMD_READ0, page_addr:" " 0x%x, column: 0x%x.\n" , page_addr , column ) ; out_be32 ( & lbc -> fbcr , 0 ) ; set_addr ( mtd , 0 , page_addr , 0 ) ; elbc_fcm_ctrl -> read_bytes = mtd -> writesize + mtd -> oobsize ; elbc_fcm_ctrl -> index += column ; fsl_elbc_do_read ( chip , 0 ) ; fsl_elbc_run_command ( mtd ) ; return ; case NAND_CMD_RNDOUT : dev_dbg ( priv -> dev , "fsl_elbc_cmdfunc: NAND_CMD_RNDOUT, column: 0x%x.\n" , column ) ; elbc_fcm_ctrl -> index = column ; return ; case NAND_CMD_READOOB : dev_vdbg ( priv -> dev , "fsl_elbc_cmdfunc: NAND_CMD_READOOB, page_addr:" " 0x%x, column: 0x%x.\n" , page_addr , column ) ; out_be32 ( & lbc -> fbcr , mtd -> oobsize - column ) ; set_addr ( mtd , column , page_addr , 1 ) ; elbc_fcm_ctrl -> read_bytes = mtd -> writesize + mtd -> oobsize ; fsl_elbc_do_read ( chip , 1 ) ; fsl_elbc_run_command ( mtd ) ; return ; case NAND_CMD_READID : case NAND_CMD_PARAM : dev_vdbg ( priv -> dev , "fsl_elbc_cmdfunc: NAND_CMD %x\n" , command ) ; out_be32 ( & lbc -> fir , ( FIR_OP_CM0 << FIR_OP0_SHIFT ) | ( FIR_OP_UA << FIR_OP1_SHIFT ) | ( FIR_OP_RBW << FIR_OP2_SHIFT ) ) ; out_be32 ( & lbc -> fcr , command << FCR_CMD0_SHIFT ) ; out_be32 ( & lbc -> fbcr , 256 ) ; elbc_fcm_ctrl -> read_bytes = 256 ; elbc_fcm_ctrl -> use_mdr = 1 ; elbc_fcm_ctrl -> mdr = column ; set_addr ( mtd , 0 , 0 , 0 ) ; fsl_elbc_run_command ( mtd ) ; return ; case NAND_CMD_ERASE1 : dev_vdbg ( priv -> dev , "fsl_elbc_cmdfunc: NAND_CMD_ERASE1, " "page_addr: 0x%x.\n" , page_addr ) ; set_addr ( mtd , 0 , page_addr , 0 ) ; return ; case NAND_CMD_ERASE2 : dev_vdbg ( priv -> dev , "fsl_elbc_cmdfunc: NAND_CMD_ERASE2.\n" ) ; out_be32 ( & lbc -> fir , ( FIR_OP_CM0 << FIR_OP0_SHIFT ) | ( FIR_OP_PA << FIR_OP1_SHIFT ) | ( FIR_OP_CM2 << FIR_OP2_SHIFT ) | ( FIR_OP_CW1 << FIR_OP3_SHIFT ) | ( FIR_OP_RS << FIR_OP4_SHIFT ) ) ; out_be32 ( & lbc -> fcr , ( NAND_CMD_ERASE1 << FCR_CMD0_SHIFT ) | ( NAND_CMD_STATUS << FCR_CMD1_SHIFT ) | ( NAND_CMD_ERASE2 << FCR_CMD2_SHIFT ) ) ; out_be32 ( & lbc -> fbcr , 0 ) ; elbc_fcm_ctrl -> read_bytes = 0 ; elbc_fcm_ctrl -> use_mdr = 1 ; fsl_elbc_run_command ( mtd ) ; return ; case NAND_CMD_SEQIN : { __be32 fcr ; dev_vdbg ( priv -> dev , "fsl_elbc_cmdfunc: NAND_CMD_SEQIN/PAGE_PROG, " "page_addr: 0x%x, column: 0x%x.\n" , page_addr , column ) ; elbc_fcm_ctrl -> column = column ; elbc_fcm_ctrl -> use_mdr = 1 ; if ( column >= mtd -> writesize ) { column -= mtd -> writesize ; elbc_fcm_ctrl -> oob = 1 ; } else { WARN_ON ( column != 0 ) ; elbc_fcm_ctrl -> oob = 0 ; } fcr = ( NAND_CMD_STATUS << FCR_CMD1_SHIFT ) | ( NAND_CMD_SEQIN << FCR_CMD2_SHIFT ) | ( NAND_CMD_PAGEPROG << FCR_CMD3_SHIFT ) ; if ( priv -> page_size ) { out_be32 ( & lbc -> fir , ( FIR_OP_CM2 << FIR_OP0_SHIFT ) | ( FIR_OP_CA << FIR_OP1_SHIFT ) | ( FIR_OP_PA << FIR_OP2_SHIFT ) | ( FIR_OP_WB << FIR_OP3_SHIFT ) | ( FIR_OP_CM3 << FIR_OP4_SHIFT ) | ( FIR_OP_CW1 << FIR_OP5_SHIFT ) | ( FIR_OP_RS << FIR_OP6_SHIFT ) ) ; } else { out_be32 ( & lbc -> fir , ( FIR_OP_CM0 << FIR_OP0_SHIFT ) | ( FIR_OP_CM2 << FIR_OP1_SHIFT ) | ( FIR_OP_CA << FIR_OP2_SHIFT ) | ( FIR_OP_PA << FIR_OP3_SHIFT ) | ( FIR_OP_WB << FIR_OP4_SHIFT ) | ( FIR_OP_CM3 << FIR_OP5_SHIFT ) | ( FIR_OP_CW1 << FIR_OP6_SHIFT ) | ( FIR_OP_RS << FIR_OP7_SHIFT ) ) ; if ( elbc_fcm_ctrl -> oob ) { fcr |= NAND_CMD_READOOB << FCR_CMD0_SHIFT ; } else { fcr |= NAND_CMD_READ0 << FCR_CMD0_SHIFT ; } } out_be32 ( & lbc -> fcr , fcr ) ; set_addr ( mtd , column , page_addr , elbc_fcm_ctrl -> oob ) ; return ; } case NAND_CMD_PAGEPROG : { dev_vdbg ( priv -> dev , "fsl_elbc_cmdfunc: NAND_CMD_PAGEPROG " "writing %d bytes.\n" , elbc_fcm_ctrl -> index ) ; if ( elbc_fcm_ctrl -> oob || elbc_fcm_ctrl -> column != 0 || elbc_fcm_ctrl -> index != mtd -> writesize + mtd -> oobsize ) { out_be32 ( & lbc -> fbcr , elbc_fcm_ctrl -> index - elbc_fcm_ctrl -> column ) ; } else { out_be32 ( & lbc -> fbcr , 0 ) ; } fsl_elbc_run_command ( mtd ) ; return ; } case NAND_CMD_STATUS : out_be32 ( & lbc -> fir , ( FIR_OP_CM0 << FIR_OP0_SHIFT ) | ( FIR_OP_RBW << FIR_OP1_SHIFT ) ) ; out_be32 ( & lbc -> fcr , NAND_CMD_STATUS << FCR_CMD0_SHIFT ) ; out_be32 ( & lbc -> fbcr , 1 ) ; set_addr ( mtd , 0 , 0 , 0 ) ; elbc_fcm_ctrl -> read_bytes = 1 ; fsl_elbc_run_command ( mtd ) ; setbits8 ( elbc_fcm_ctrl -> addr , NAND_STATUS_WP ) ; return ; case NAND_CMD_RESET : dev_dbg ( priv -> dev , "fsl_elbc_cmdfunc: NAND_CMD_RESET.\n" ) ; out_be32 ( & lbc -> fir , FIR_OP_CM0 << FIR_OP0_SHIFT ) ; out_be32 ( & lbc -> fcr , NAND_CMD_RESET << FCR_CMD0_SHIFT ) ; fsl_elbc_run_command ( mtd ) ; return ; default : dev_err ( priv -> dev , "fsl_elbc_cmdfunc: error, unsupported command 0x%x.\n" , command ) ; } } 