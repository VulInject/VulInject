static uint32_t ccmap_inc_bfs ( struct ccmap_impl * impl , uint32_t hash , struct ccmap_bucket * b1 , struct ccmap_bucket * b2 , uint32_t inc ) { { MAX_DEPTH = 4 } ccmap_path { struct ccmap_bucket * start ; struct ccmap_bucket * end ; uint8_t slots [ MAX_DEPTH ] ; int n ; } { MAX_QUEUE = 500 } struct ccmap_path queue [ MAX_QUEUE ] ; int head = 0 ; int tail = 0 ; queue [ head ] . start = b1 ; queue [ head ] . end = b1 ; queue [ head ] . n = 0 ; head ++ ; if ( b1 != b2 ) { queue [ head ] . start = b2 ; queue [ head ] . end = b2 ; queue [ head ] . n = 0 ; head ++ ; } while ( tail < head ) { const struct ccmap_path * path = & queue [ tail ++ ] ; struct ccmap_bucket * this = path -> end ; int i ; for ( i = 0 ; i < CCMAP_K ; i ++ ) { struct ccmap_bucket * next = other_bucket_protected ( impl , this , i ) ; int j ; if ( this == next ) { continue ; } j = ccmap_find_empty_slot_protected ( next ) ; if ( j >= 0 ) { struct ccmap_bucket * buckets [ MAX_DEPTH + 2 ] ; int slots [ MAX_DEPTH + 2 ] ; int k ; for ( k = 0 ; k < path -> n ; k ++ ) { slots [ k ] = path -> slots [ k ] ; } slots [ path -> n ] = i ; slots [ path -> n + 1 ] = j ; buckets [ 0 ] = path -> start ; for ( k = 0 ; k <= path -> n ; k ++ ) { buckets [ k + 1 ] = other_bucket_protected ( impl , buckets [ k ] , slots [ k ] ) ; } for ( k = path -> n + 1 ; k > 0 ; k -- ) { ccmap_node_set_protected ( & buckets [ k ] -> nodes [ slots [ k ] ] , node ) ; } ccmap_set_bucket ( buckets [ 0 ] , slots [ 0 ] , inc , hash ) ; return inc ; } if ( path -> n < MAX_DEPTH && head < MAX_QUEUE ) { struct ccmap_path * new_path = & queue [ head ++ ] ; * new_path = * path ; new_path -> end = next ; new_path -> slots [ new_path -> n ++ ] = i ; } } } return 0 ; } 