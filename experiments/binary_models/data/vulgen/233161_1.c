static lm_status_t lm_tcp_init_tcp_state_machine ( struct _lm_device_t * pdev , lm_tcp_state_t * tcp ) { lm_tcp_con_t * con = tcp -> rx_con ; lm_tcp_state_calculation_t * state_calc = & tcp -> tcp_state_calc ; u64_t curr_time ; lm_status_t lm_status = LM_STATUS_SUCCESS ; DbgMessage ( pdev , VERBOSEl4sp , "##lm_tcp_init_tcp_state_machine\n" ) ; state_calc -> fin_request_time = state_calc -> fin_completed_time = state_calc -> fin_reception_time = 0 ; curr_time = mm_get_current_time ( pdev ) ; switch ( tcp -> tcp_delegated . con_state ) { case L4_TCP_CON_STATE_ESTABLISHED : break ; case L4_TCP_CON_STATE_FIN_WAIT1 : DbgMessage ( pdev , WARNl4sp , "#tcp state offloaded in state FIN_WAIT1 (tcp=%p)\n" , tcp ) ; state_calc -> fin_request_time = curr_time ; break ; case L4_TCP_CON_STATE_FIN_WAIT2 : DbgMessage ( pdev , WARNl4sp , "#tcp state offloaded in state FIN_WAIT2 (tcp=%p)\n" , tcp ) ; state_calc -> fin_request_time = curr_time - 1 ; state_calc -> fin_completed_time = curr_time ; break ; case L4_TCP_CON_STATE_CLOSE_WAIT : DbgMessage ( pdev , WARNl4sp , "#tcp state offloaded in state CLOSE_WAIT (tcp=%p)\n" , tcp ) ; state_calc -> fin_reception_time = curr_time ; break ; case L4_TCP_CON_STATE_CLOSING : DbgMessage ( pdev , WARNl4sp , "#tcp state offloaded in state CLOSING (tcp=%p)\n" , tcp ) ; state_calc -> fin_request_time = curr_time - 1 ; state_calc -> fin_reception_time = curr_time ; break ; case L4_TCP_CON_STATE_LAST_ACK : DbgMessage ( pdev , WARNl4sp , "#tcp state offloaded in state LAST_ACK (tcp=%p)\n" , tcp ) ; state_calc -> fin_reception_time = curr_time - 1 ; state_calc -> fin_request_time = curr_time ; break ; default : DbgMessage ( pdev , FATAL , "Initiate offload in con state=%d is not allowed by WDK!\n" , tcp -> tcp_delegated . con_state ) ; DbgBreak ( ) ; return LM_STATUS_FAILURE ; } if ( state_calc -> fin_reception_time ) { DbgBreakIf ( con -> flags & TCP_REMOTE_FIN_RECEIVED ) ; con -> flags |= TCP_REMOTE_FIN_RECEIVED ; if ( con -> flags & TCP_INDICATE_REJECTED ) { con -> u . rx . flags |= TCP_CON_FIN_IND_PENDING ; } else { con -> flags |= TCP_REMOTE_FIN_RECEIVED_ALL_RX_INDICATED ; con -> flags |= TCP_BUFFERS_ABORTED ; } } con = tcp -> tx_con ; if ( state_calc -> fin_completed_time ) { volatile struct toe_tx_db_data * db_data = con -> db_data . tx ; DbgBreakIf ( ! state_calc -> fin_request_time ) ; DbgBreakIf ( ! s_list_is_empty ( & con -> active_tb_list ) ) ; con -> flags |= ( TCP_FIN_REQ_POSTED | TCP_FIN_REQ_COMPLETED ) ; db_data -> flags |= ( TOE_TX_DB_DATA_FIN << TOE_TX_DB_DATA_FIN_SHIFT ) ; db_data -> bytes_prod_seq -- ; } if ( state_calc -> fin_request_time ) { DbgBreakIf ( con -> flags & TCP_DB_BLOCKED ) ; con -> flags |= TCP_DB_BLOCKED ; DbgBreakIf ( ! ( con -> flags & TCP_POST_BLOCKED ) ) ; con -> flags &= ~ TCP_POST_BLOCKED ; con -> u . tx . flags |= TCP_CON_FIN_REQ_LM_INTERNAL ; lm_status = lm_tcp_graceful_disconnect ( pdev , tcp ) ; DbgBreakIf ( lm_status != LM_STATUS_SUCCESS ) ; con -> flags &= ~ TCP_DB_BLOCKED ; con -> flags |= TCP_POST_BLOCKED ; } return LM_STATUS_SUCCESS ; } 