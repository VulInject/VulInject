int fusefs_getattr ( void * v ) { struct vop_getattr_args * ap = v ; struct vnode * vp = ap -> a_vp ; struct fusefs_mnt * fmp ; struct vattr * vap = ap -> a_vap ; struct proc * p = ap -> a_p ; struct ucred * cred = p -> p_ucred ; struct fusefs_node * ip ; struct fusebuf * fbuf ; struct stat * st ; int error = 0 ; ip = VTOI ( vp ) ; fmp = ( fusefs_mnt * ) ip -> ufs_ino . i_ump ; if ( ! fmp -> allow_other && cred -> cr_uid != fmp -> mp -> mnt_stat . f_owner ) { memset ( vap , 0 , sizeof ( * vap ) ) ; vap -> va_type = VNON ; else { vap -> va_mode = S_IRWXU ; } vap -> va_nlink = 1 ; vap -> va_uid = fmp -> mp -> mnt_stat . f_owner ; vap -> va_gid = fmp -> mp -> mnt_stat . f_owner ; vap -> va_fsid = fmp -> mp -> mnt_stat . f_fsid . val [ 0 ] ; vap -> va_fileid = ip -> ufs_ino . i_number ; vap -> va_size = S_BLKSIZE ; vap -> va_blocksize = S_BLKSIZE ; vap -> va_atime . tv_sec = fmp -> mp -> mnt_stat . f_ctime ; vap -> va_mtime . tv_sec = fmp -> mp -> mnt_stat . f_ctime ; vap -> va_ctime . tv_sec = fmp -> mp -> mnt_stat . f_ctime ; vap -> va_rdev = fmp -> dev ; vap -> va_bytes = S_BLKSIZE ; return ( 0 ) ; } if ( ! fmp -> sess_init ) { return ( ENXIO ) ; } fbuf = fb_setup ( 0 , ip -> ufs_ino . i_number , FBT_GETATTR , p ) ; error = fb_queue ( fmp -> dev , fbuf ) ; if ( error ) { fb_delete ( fbuf ) ; return ( error ) ; } st = & fbuf -> fb_attr ; memset ( vap , 0 , sizeof ( * vap ) ) ; vap -> va_type = IFTOVT ( st -> st_mode ) ; vap -> va_mode = st -> st_mode & ~ S_IFMT ; vap -> va_nlink = st -> st_nlink ; vap -> va_uid = st -> st_uid ; vap -> va_gid = st -> st_gid ; vap -> va_fsid = fmp -> mp -> mnt_stat . f_fsid . val [ 0 ] ; vap -> va_fileid = st -> st_ino ; vap -> va_size = st -> st_size ; vap -> va_blocksize = st -> st_blksize ; vap -> va_atime = st -> st_atim ; vap -> va_mtime = st -> st_mtim ; vap -> va_ctime = st -> st_ctim ; vap -> va_rdev = st -> st_rdev ; vap -> va_bytes = st -> st_blocks * S_BLKSIZE ; fb_delete ( fbuf ) ; return ( error ) ; } 