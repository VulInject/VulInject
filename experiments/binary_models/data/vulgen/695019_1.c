static void ttyin ( char buf [ ] , register int nmax , char pchar ) { register char * sptr ; register unsigned char ch ; int LengthBuffer [ 80 ] ; int * BufferPointer ; int csno ; register int slash = 0 ; int maxlen ; char cbuf ; BufferPointer = LengthBuffer ; sptr = buf ; maxlen = 0 ; while ( sptr - buf < nmax ) { if ( promptlen > maxlen ) { maxlen = promptlen ; } ch = readch ( ) ; csno = csetno ( ch ) ; if ( ! csno ) { if ( ch == '\\' ) { slash ++ ; } if ( ( ch == otty . c_cc [ VERASE ] ) && ! slash ) { if ( sptr > buf ) { -- promptlen ; write ( 2 , & BS , 1 ) ; sptr -= ( * -- BufferPointer ) ; if ( ( * sptr < ' ' && * sptr != '\n' ) || * sptr == RUBOUT ) { -- promptlen ; write ( 2 , & BS , 1 ) ; } continue ; } else { if ( ! clr_eol ) { promptlen = maxlen ; } } } if ( ( ch == otty . c_cc [ VKILL ] ) && ! slash ) { if ( hard ) { show ( ch ) ; putchar ( '\n' ) ; putchar ( pchar ) ; } else { putchar ( '\r' ) ; putchar ( pchar ) ; if ( clr_eol ) { prmpt_erase ( 1 ) ; } promptlen = 1 ; } sptr = buf ; fflush ( stdout ) ; continue ; } if ( slash && ( ch == otty . c_cc [ VKILL ] || ch == otty . c_cc [ VERASE ] ) ) { write ( 2 , & BS , 1 ) ; sptr -= ( * -- BufferPointer ) ; } if ( ch != '\\' ) { slash = 0 ; } * BufferPointer ++ = 1 ; * sptr ++ = ch ; if ( ( ch < ' ' && ch != '\n' && ch != ESC ) || ch == RUBOUT ) { ch += ch == RUBOUT ?- 0100 : 0100 ; write ( 2 , & CARAT , 1 ) ; promptlen ++ ; } cbuf = ch ; if ( ch != '\n' && ch != ESC ) { write ( 2 , & cbuf , 1 ) ; promptlen ++ ; } else { break ; } } else { int i ; u_char buffer [ 5 ] ; * BufferPointer ++ = cw [ csno ] ; buffer [ 0 ] = * sptr ++ = ch ; for ( i = 1 ; i < cw [ csno ] ; i ++ ) { buffer [ i ] = * sptr ++ = readch ( ) ; } buffer [ i ] = '\0' ; write ( 2 , buffer , strlen ( ( char * ) buffer ) ) ; } } * -- sptr = '\0' ; if ( ! clr_eol ) { promptlen = maxlen ; } if ( sptr - buf >= nmax - 1 ) { error ( gettext ( "Line too long" ) ) ; } } 