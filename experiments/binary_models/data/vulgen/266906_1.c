static int sgx_encl_add_page ( struct sgx_encl * encl , unsigned long src , unsigned long offset , struct sgx_secinfo * secinfo , unsigned long flags ) { struct sgx_encl_page * encl_page ; struct sgx_epc_page * epc_page ; struct sgx_va_page * va_page ; int ret ; encl_page = sgx_encl_page_alloc ( encl , offset , secinfo -> flags ) ; if ( IS_ERR ( encl_page ) ) { return PTR_ERR ( encl_page ) ; } epc_page = sgx_alloc_epc_page ( encl_page , true ) ; if ( IS_ERR ( epc_page ) ) { return PTR_ERR ( epc_page ) ; } va_page = sgx_encl_grow ( encl , true ) ; if ( IS_ERR ( va_page ) ) { ret = PTR_ERR ( va_page ) ; err_out_free } mmap_read_lock ( current -> mm ) ; mutex_lock ( & encl -> lock ) ; if ( va_page ) { list_add ( & va_page -> list , & encl -> va_pages ) ; } ret = xa_insert ( & encl -> page_array , PFN_DOWN ( encl_page -> desc ) , encl_page , GFP_KERNEL ) ; if ( ret ) { err_out_unlock } ret = __sgx_encl_add_page ( encl , encl_page , epc_page , secinfo , src ) ; if ( ret ) { err_out } encl_page -> encl = encl ; encl_page -> epc_page = epc_page ; encl_page -> type = ( secinfo -> flags & SGX_SECINFO_PAGE_TYPE_MASK ) >> 8 ; encl -> secs_child_cnt ++ ; if ( flags & SGX_PAGE_MEASURE ) { ret = __sgx_encl_extend ( encl , epc_page ) ; if ( ret ) { err_out } } sgx_mark_page_reclaimable ( encl_page -> epc_page ) ; mutex_unlock ( & encl -> lock ) ; mmap_read_unlock ( current -> mm ) ; return ret ; err_out xa_erase ( & encl -> page_array , PFN_DOWN ( encl_page -> desc ) ) ; err_out_unlock sgx_encl_shrink ( encl , va_page ) ; mutex_unlock ( & encl -> lock ) ; mmap_read_unlock ( current -> mm ) ; err_out_free sgx_encl_free_epc_page ( epc_page ) ; kfree ( encl_page ) ; return ret ; } 