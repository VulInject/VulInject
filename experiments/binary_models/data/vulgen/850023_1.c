static int sdhci_esdhc_imx_probe ( struct platform_device * pdev ) { const struct of_device_id * of_id = of_match_device ( imx_esdhc_dt_ids , & pdev -> dev ) ; struct sdhci_pltfm_host * pltfm_host ; struct sdhci_host * host ; int err ; struct pltfm_imx_data * imx_data ; host = sdhci_pltfm_init ( pdev , & sdhci_esdhc_imx_pdata , sizeof ( * imx_data ) ) ; if ( IS_ERR ( host ) ) { return PTR_ERR ( host ) ; } pltfm_host = sdhci_priv ( host ) ; imx_data = sdhci_pltfm_priv ( pltfm_host ) ; imx_data -> socdata = of_id ?of_id -> data : ( esdhc_soc_data * ) pdev -> id_entry -> driver_data ; imx_data -> clk_ipg = devm_clk_get ( & pdev -> dev , "ipg" ) ; if ( IS_ERR ( imx_data -> clk_ipg ) ) { err = PTR_ERR ( imx_data -> clk_ipg ) ; free_sdhci } imx_data -> clk_ahb = devm_clk_get ( & pdev -> dev , "ahb" ) ; if ( IS_ERR ( imx_data -> clk_ahb ) ) { err = PTR_ERR ( imx_data -> clk_ahb ) ; free_sdhci } imx_data -> clk_per = devm_clk_get ( & pdev -> dev , "per" ) ; if ( IS_ERR ( imx_data -> clk_per ) ) { err = PTR_ERR ( imx_data -> clk_per ) ; free_sdhci } pltfm_host -> clk = imx_data -> clk_per ; pltfm_host -> clock = clk_get_rate ( pltfm_host -> clk ) ; clk_prepare_enable ( imx_data -> clk_per ) ; clk_prepare_enable ( imx_data -> clk_ipg ) ; clk_prepare_enable ( imx_data -> clk_ahb ) ; imx_data -> pinctrl = devm_pinctrl_get ( & pdev -> dev ) ; if ( IS_ERR ( imx_data -> pinctrl ) ) { err = PTR_ERR ( imx_data -> pinctrl ) ; disable_clk } imx_data -> pins_default = pinctrl_lookup_state ( imx_data -> pinctrl , PINCTRL_STATE_DEFAULT ) ; if ( IS_ERR ( imx_data -> pins_default ) ) { dev_warn ( mmc_dev ( host -> mmc ) , "could not get default state\n" ) ; } if ( imx_data -> socdata -> flags & ESDHC_FLAG_ENGCM07207 ) { host -> quirks |= SDHCI_QUIRK_NO_MULTIBLOCK | SDHCI_QUIRK_BROKEN_ADMA ; } if ( esdhc_is_usdhc ( imx_data ) ) { host -> quirks2 |= SDHCI_QUIRK2_PRESET_VALUE_BROKEN ; host -> mmc -> caps |= MMC_CAP_1_8V_DDR ; if ( ! ( imx_data -> socdata -> flags & ESDHC_FLAG_HS200 ) ) { host -> quirks2 |= SDHCI_QUIRK2_BROKEN_HS200 ; } writel ( 0x0 , host -> ioaddr + ESDHC_MIX_CTRL ) ; writel ( 0x0 , host -> ioaddr + SDHCI_ACMD12_ERR ) ; writel ( 0x0 , host -> ioaddr + ESDHC_TUNE_CTRL_STATUS ) ; } if ( imx_data -> socdata -> flags & ESDHC_FLAG_MAN_TUNING ) { sdhci_esdhc_ops . platform_execute_tuning = esdhc_executing_tuning ; } if ( imx_data -> socdata -> flags & ESDHC_FLAG_ERR004536 ) { host -> quirks |= SDHCI_QUIRK_BROKEN_ADMA ; } if ( of_id ) { err = sdhci_esdhc_imx_probe_dt ( pdev , host , imx_data ) ; } else { err = sdhci_esdhc_imx_probe_nondt ( pdev , host , imx_data ) ; } if ( err ) { disable_clk } sdhci_esdhc_imx_hwinit ( host ) ; err = sdhci_add_host ( host ) ; if ( err ) { disable_clk } pm_runtime_set_active ( & pdev -> dev ) ; pm_runtime_set_autosuspend_delay ( & pdev -> dev , 50 ) ; pm_runtime_use_autosuspend ( & pdev -> dev ) ; pm_suspend_ignore_children ( & pdev -> dev , 1 ) ; pm_runtime_enable ( & pdev -> dev ) ; return 0 ; disable_clk clk_disable_unprepare ( imx_data -> clk_per ) ; clk_disable_unprepare ( imx_data -> clk_ipg ) ; clk_disable_unprepare ( imx_data -> clk_ahb ) ; free_sdhci sdhci_pltfm_free ( pdev ) ; return err ; } 