int virCommandRun ( virCommand * cmd , int * exitstatus ) { int ret = 0 ; char * outbuf = NULL ; char * errbuf = NULL ; struct stat st ; bool string_io ; bool async_io = false ; char * str ; int tmpfd ; if ( virCommandHasError ( cmd ) ) { virCommandRaiseError ( cmd ) ; return - 1 ; } string_io = cmd -> inbuf || cmd -> outbuf || cmd -> errbuf ; if ( cmd -> infd != - 1 && ( fstat ( cmd -> infd , & st ) < 0 || ! S_ISREG ( st . st_mode ) ) ) { async_io = true ; } if ( cmd -> outfdptr && cmd -> outfdptr != & cmd -> outfd && ( * cmd -> outfdptr == - 1 || fstat ( * cmd -> outfdptr , & st ) < 0 || ! S_ISREG ( st . st_mode ) ) ) { async_io = true ; } if ( cmd -> errfdptr && cmd -> errfdptr != & cmd -> errfd && ( * cmd -> errfdptr == - 1 || fstat ( * cmd -> errfdptr , & st ) < 0 || ! S_ISREG ( st . st_mode ) ) ) { async_io = true ; } if ( async_io ) { if ( ! ( cmd -> flags & VIR_EXEC_DAEMON ) || string_io ) { virReportError ( VIR_ERR_INTERNAL_ERROR , "%s" , _ ( "cannot mix caller fds with blocking execution" ) ) ; return - 1 ; } } else { if ( ( cmd -> flags & VIR_EXEC_DAEMON ) && string_io ) { virReportError ( VIR_ERR_INTERNAL_ERROR , "%s" , _ ( "cannot mix string I/O with daemon" ) ) ; return - 1 ; } } if ( cmd -> outbuf && cmd -> outbuf == cmd -> errbuf ) { cmd -> errfdptr = & cmd -> outfd ; cmd -> errbuf = NULL ; } if ( ! ( cmd -> flags & VIR_EXEC_DAEMON ) ) { if ( ! cmd -> outfdptr ) { cmd -> outfdptr = & cmd -> outfd ; cmd -> outbuf = & outbuf ; string_io = true ; } if ( ! cmd -> errfdptr ) { cmd -> errfdptr = & cmd -> errfd ; cmd -> errbuf = & errbuf ; string_io = true ; } } cmd -> flags |= VIR_EXEC_RUN_SYNC ; if ( virCommandRunAsync ( cmd , NULL ) < 0 ) { cmd -> has_error = - 1 ; return - 1 ; } if ( string_io ) { VIR_FORCE_CLOSE ( cmd -> infd ) ; ret = virCommandProcessIO ( cmd ) ; } if ( virCommandWait ( cmd , exitstatus ) < 0 ) { ret = - 1 ; } str = ( exitstatus ?virProcessTranslateStatus ( * exitstatus ) : ( char * ) "status 0" ) ; VIR_DEBUG ( "Result %s, stdout: '%s' stderr: '%s'" , NULLSTR ( str ) , cmd -> outbuf ?NULLSTR ( * cmd -> outbuf ) : "(null)" , cmd -> errbuf ?NULLSTR ( * cmd -> errbuf ) : "(null)" ) ; if ( exitstatus ) { VIR_FREE ( str ) ; } VIR_FORCE_CLOSE ( cmd -> inpipe ) ; if ( cmd -> outbuf == & outbuf ) { tmpfd = cmd -> outfd ; if ( VIR_CLOSE ( cmd -> outfd ) < 0 ) { VIR_DEBUG ( "ignoring failed close on fd %d" , tmpfd ) ; } cmd -> outfdptr = NULL ; VIR_FREE ( outbuf ) ; } if ( cmd -> errbuf == & errbuf ) { tmpfd = cmd -> errfd ; if ( VIR_CLOSE ( cmd -> errfd ) < 0 ) { VIR_DEBUG ( "ignoring failed close on fd %d" , tmpfd ) ; } cmd -> errfdptr = NULL ; cmd -> errbuf = NULL ; VIR_FREE ( errbuf ) ; } return ret ; } 