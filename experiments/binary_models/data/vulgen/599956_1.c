static int PKCS12_create_safe ( WC_PKCS12 * pkcs12 , byte * certCi , word32 certCiSz , byte * keyCi , word32 keyCiSz , WC_RNG * rng , char * pass , word32 passSz , int iter ) { int length ; int ret ; byte seq [ MAX_SEQ_SZ ] ; word32 safeDataSz ; word32 innerDataSz ; byte * innerData = NULL ; byte * safeData = NULL ; word32 idx ; innerDataSz = certCiSz + keyCiSz + SetSequence ( certCiSz + keyCiSz , seq ) ; ret = wc_PKCS12_encrypt_content ( pkcs12 , rng , NULL , & safeDataSz , NULL , innerDataSz , 0 , NULL , 0 , 0 , WC_PKCS12_DATA ) ; if ( ret != LENGTH_ONLY_E ) { return ret ; } safeData = ( byte * ) XMALLOC ( safeDataSz , pkcs12 -> heap , DYNAMIC_TYPE_TMP_BUFFER ) ; if ( safeData == NULL ) { WOLFSSL_MSG ( "Error malloc'ing safe data buffer" ) ; return MEMORY_E ; } innerData = ( byte * ) XMALLOC ( innerDataSz , pkcs12 -> heap , DYNAMIC_TYPE_PKCS ) ; if ( innerData == NULL ) { WOLFSSL_MSG ( "Error malloc'ing inner data buffer" ) ; XFREE ( safeData , pkcs12 -> heap , DYNAMIC_TYPE_TMP_BUFFER ) ; return MEMORY_E ; } idx = 0 ; idx += SetSequence ( certCiSz + keyCiSz , innerData ) ; XMEMCPY ( innerData + idx , certCi , certCiSz ) ; XMEMCPY ( innerData + idx + certCiSz , keyCi , keyCiSz ) ; ret = wc_PKCS12_encrypt_content ( pkcs12 , rng , safeData , & safeDataSz , innerData , innerDataSz , 0 , pass , passSz , iter , WC_PKCS12_DATA ) ; XFREE ( innerData , pkcs12 -> heap , DYNAMIC_TYPE_PKCS ) ; if ( ret < 0 ) { WOLFSSL_MSG ( "Error setting data type for safe contents" ) ; XFREE ( safeData , pkcs12 -> heap , DYNAMIC_TYPE_TMP_BUFFER ) ; return ret ; } idx = 0 ; ret = GetSequence ( safeData , & idx , & length , safeDataSz ) ; if ( ret < 0 ) { WOLFSSL_MSG ( "Error getting first sequence of safe" ) ; XFREE ( safeData , pkcs12 -> heap , DYNAMIC_TYPE_TMP_BUFFER ) ; return ret ; } ret = GetSafeContent ( pkcs12 , safeData , & idx , safeDataSz ) ; XFREE ( safeData , pkcs12 -> heap , DYNAMIC_TYPE_TMP_BUFFER ) ; return 0 ; } 