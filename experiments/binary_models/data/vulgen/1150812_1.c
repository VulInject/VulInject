of this software and associated documentation files ( the "Software" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to ; { so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED "AS IS" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . * / static const char * const tableNames [ ] = { "properties" "accelerators" "metrics" "bitmaps" "ink metrics" "encodings" "swidths" "glyph names" "BDF accelerators" } ; } { FT_FRAME_START ( 8 ) , FT_FRAME_ULONG_LE ( version ) , FT_FRAME_ULONG_LE ( count ) , FT_FRAME_END ; } { FT_FRAME_START ( 16 ) , FT_FRAME_ULONG_LE ( type ) , FT_FRAME_ULONG_LE ( format ) , FT_FRAME_ULONG_LE ( size ) , FT_FRAME_ULONG_LE ( offset ) , FT_FRAME_END ; } , { FT_Error error ; PCF_Toc toc = & face -> toc ; PCF_Table tables ; FT_Memory memory = FT_FACE ( face ) -> memory ; FT_UInt n ; FT_ULong size ; if ( FT_STREAM_SEEK ( 0 ) || FT_STREAM_READ_FIELDS ( pcf_toc_header , toc ) ) { return FT_THROW ( Cannot_Open_Resource ) ; } if ( toc -> version != PCF_FILE_VERSION || toc -> count == 0 ) { return FT_THROW ( Invalid_File_Format ) ; } if ( toc -> count > ( stream -> size >> 4 ) || toc -> count > 9 ) { FT_TRACE0 ( ( "pcf_read_TOC: adjusting number of tables" " (from %ld to %ld)\n" , toc -> count , FT_MIN ( stream -> size >> 4 , 9 ) ) ) ; toc -> count = FT_MIN ( stream -> size >> 4 , 9 ) ; } if ( FT_QNEW_ARRAY ( face -> toc . tables , toc -> count ) ) { return error ; } tables = face -> toc . tables ; for ( n = 0 ; n < toc -> count ; n ++ ) { if ( FT_STREAM_READ_FIELDS ( pcf_table_header , tables ) ) { Exit } tables ++ ; } tables = face -> toc . tables ; for ( n = 0 ; n < toc -> count - 1 ; n ++ ) { FT_UInt i , have_change ; have_change = 0 ; for ( i = 0 ; i < toc -> count - 1 - n ; i ++ ) { PCF_TableRec tmp ; if ( tables [ i ] . offset > tables [ i + 1 ] . offset ) { tmp = tables [ i ] ; tables [ i ] = tables [ i + 1 ] ; tables [ i + 1 ] = tmp ; have_change = 1 ; } if ( ( tables [ i ] . size > tables [ i + 1 ] . offset ) || ( tables [ i ] . offset > tables [ i + 1 ] . offset - tables [ i ] . size ) ) { error = FT_THROW ( Invalid_Offset ) ; Exit } } if ( ! have_change ) { break ; } } tables = face -> toc . tables ; size = stream -> size ; for ( n = 0 ; n < toc -> count - 1 ; n ++ ) { if ( ( tables -> size > size ) || ( tables -> offset > size - tables -> size ) ) { error = FT_THROW ( Invalid_Table ) ; Exit } tables ++ ; } if ( ( tables -> offset > size ) ) { error = FT_THROW ( Invalid_Table ) ; Exit } if ( tables -> size > size - tables -> offset ) { tables -> size = size - tables -> offset ; } { FT_UInt i , j ; const char * name = "?" ; FT_TRACE4 ( ( "pcf_read_TOC:\n" ) ) ; FT_TRACE4 ( ( "  number of tables: %ld\n" , face -> toc . count ) ) ; tables = face -> toc . tables ; for ( i = 0 ; i < toc -> count ; i ++ ) { for ( j = 0 ; j < sizeof ( tableNames ) / sizeof ( tableNames [ 0 ] ) ; j ++ ) { if ( tables [ i ] . type == 1UL << j ) { name = tableNames [ j ] ; } } FT_TRACE4 ( ( "  %d: type=%s, format=0x%lX," " size=%ld (0x%lX), offset=%ld (0x%lX)\n" , i , name , tables [ i ] . format , tables [ i ] . size , tables [ i ] . size , tables [ i ] . offset , tables [ i ] . offset ) ) ; } } return FT_Err_Ok ; Exit FT_FREE ( face -> toc . tables ) ; return error ; } static const FT_Frame_Field pcf_metric_header [ ] { FT_FRAME_START ( PCF_METRIC_SIZE ) FT_FRAME_SHORT_LE ( leftSideBearing ) FT_FRAME_SHORT_LE ( rightSideBearing ) FT_FRAME_SHORT_LE ( characterWidth ) FT_FRAME_SHORT_LE ( ascent ) FT_FRAME_SHORT_LE ( descent ) FT_FRAME_SHORT_LE ( attributes ) FT_FRAME_END } ; ; static const FT_Frame_Field pcf_metric_msb_header [ ] { FT_FRAME_START ( PCF_METRIC_SIZE ) FT_FRAME_SHORT ( leftSideBearing ) FT_FRAME_SHORT ( rightSideBearing ) FT_FRAME_SHORT ( characterWidth ) FT_FRAME_SHORT ( ascent ) FT_FRAME_SHORT ( descent ) FT_FRAME_SHORT ( attributes ) FT_FRAME_END } ; ; , static const FT_Frame_Field pcf_compressed_metric_header [ ] { } ; 