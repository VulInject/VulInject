static TEE_Result do_update_streaming ( struct drvcrypt_cipher_update * dupdate ) { TEE_Result ret = TEE_ERROR_GENERIC ; enum caam_status retstatus = CAAM_FAILURE ; struct cipherdata * ctx = dupdate -> ctx ; struct caamdmaobj src = { } ; struct caamdmaobj dst = { } ; struct caamblock trash_bck = { } ; size_t fullsize = 0 ; size_t size_topost = 0 ; size_t size_todo = 0 ; size_t size_inmade = 0 ; size_t size_done = 0 ; size_t offset ; CIPHER_TRACE ( "Length=%zu - %s" , dupdate -> src . length , ctx -> encrypt ?"Encrypt" : "Decrypt" ) ; fullsize = ctx -> blockbuf . filled + dupdate -> src . length ; CIPHER_TRACE ( "Fullsize %zu" , fullsize ) ; if ( fullsize < ctx -> alg -> size_block ) { size_topost = dupdate -> src . length ; end_streaming_post } else { size_topost = fullsize % ctx -> alg -> size_block ; size_todo = fullsize - size_topost ; size_inmade = size_todo - ctx -> blockbuf . filled ; } CIPHER_TRACE ( "FullSize %zu - posted %zu - todo %zu" , fullsize , size_topost , size_todo ) ; if ( size_todo ) { ret = caam_dmaobj_init_input ( & src , dupdate -> src . data , dupdate -> src . length ) ; if ( ret ) { end_streaming } ret = caam_dmaobj_init_output ( & dst , dupdate -> dst . data , dupdate -> dst . length , dupdate -> dst . length ) ; if ( ret ) { end_streaming } ret = caam_dmaobj_prepare ( & src , & dst , ctx -> alg -> size_block ) ; if ( ret ) { end_streaming } } if ( ctx -> blockbuf . filled ) { ret = caam_dmaobj_add_first_block ( & src , & ctx -> blockbuf ) ; if ( ret ) { end_streaming } ret = caam_dmaobj_add_first_block ( & dst , & ctx -> blockbuf ) ; if ( ret ) { end_streaming } ctx -> blockbuf . filled = 0 ; } size_done = size_todo ; dupdate -> dst . length = 0 ; for ( offset = 0 ; size_todo ; offset += size_done , size_todo -= size_done ) { CIPHER_TRACE ( "Do input %zu bytes (%zu), offset %zu" , size_done , size_todo , offset ) ; size_done = size_todo ; ret = caam_dmaobj_sgtbuf_inout_build ( & src , & dst , & size_done , offset , ctx -> alg -> size_block ) ; if ( ret ) { end_streaming } retstatus = caam_cipher_block ( ctx , true , NEED_KEY1 , ctx -> encrypt , & src , & dst ) ; if ( retstatus != CAAM_NO_ERROR ) { ret = caam_status_to_tee_result ( retstatus ) ; end_streaming } dupdate -> dst . length += caam_dmaobj_copy_to_orig ( & dst ) ; } CIPHER_DUMPBUF ( "Source" , dupdate -> src . data , dupdate -> src . length ) ; CIPHER_DUMPBUF ( "Result" , dupdate -> dst . data , dupdate -> dst . length ) ; end_streaming_post if ( size_topost ) { struct caambuf cpysrc = { . data = dupdate -> src . data . length = dupdate -> src . length } ; caam_dmaobj_free ( & src ) ; caam_dmaobj_free ( & dst ) ; CIPHER_TRACE ( "Save input data %zu bytes (done %zu) - off %zu" , size_topost , size_inmade , offset ) ; size_todo = size_topost + ctx -> blockbuf . filled ; ret = caam_dmaobj_init_output ( & dst , dupdate -> dst . data + size_inmade , size_topost , size_topost ) ; if ( ret ) { end_streaming } ret = caam_dmaobj_prepare ( NULL , & dst , ctx -> alg -> size_block ) ; if ( ret ) { end_streaming } if ( ctx -> blockbuf . filled ) { ret = caam_alloc_align_buf ( & trash_bck . buf , ctx -> blockbuf . filled ) ; if ( ret != CAAM_NO_ERROR ) { CIPHER_TRACE ( "Allocation Trash Block error" ) ; end_streaming } trash_bck . filled = ctx -> blockbuf . filled ; ret = caam_dmaobj_add_first_block ( & dst , & trash_bck ) ; if ( ret ) { end_streaming } } retstatus = caam_cpy_block_src ( & ctx -> blockbuf , & cpysrc , size_inmade ) ; if ( retstatus != CAAM_NO_ERROR ) { ret = caam_status_to_tee_result ( retstatus ) ; end_streaming } ret = caam_dmaobj_init_input ( & src , ctx -> blockbuf . buf . data , ctx -> blockbuf . filled ) ; if ( ret ) { end_streaming } ret = caam_dmaobj_prepare ( & src , NULL , ctx -> alg -> size_block ) ; if ( ret ) { end_streaming } size_done = size_todo ; ret = caam_dmaobj_sgtbuf_inout_build ( & src , & dst , & size_done , 0 , size_todo ) ; if ( ret ) { end_streaming } if ( size_todo != size_done ) { CIPHER_TRACE ( "Invalid end streaming size %zu vs %zu" , size_done , size_todo ) ; ret = TEE_ERROR_GENERIC ; end_streaming } retstatus = caam_cipher_block ( ctx , false , NEED_KEY1 , ctx -> encrypt , & src , & dst ) ; if ( retstatus != CAAM_NO_ERROR ) { ret = caam_status_to_tee_result ( retstatus ) ; end_streaming } dupdate -> dst . length += caam_dmaobj_copy_to_orig ( & dst ) ; CIPHER_DUMPBUF ( "Source" , ctx -> blockbuf . buf . data , ctx -> blockbuf . filled ) ; CIPHER_DUMPBUF ( "Result" , dupdate -> dst . data + size_inmade , size_topost ) ; } ret = TEE_SUCCESS ; end_streaming caam_dmaobj_free ( & src ) ; caam_dmaobj_free ( & dst ) ; caam_free_buf ( & trash_bck . buf ) ; return ret ; } 