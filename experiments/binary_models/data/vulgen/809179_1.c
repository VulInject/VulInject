static void gdraw_8_on_1_nomag_dithered_masked ( GXDisplay * gdisp , GImage * image , GRect * src ) { struct gcol clut [ 256 ] ; int i , j , index ; struct _GImage * base = image -> list_len == 0 ?image -> u . image : image -> u . images [ 0 ] ; int trans = base -> trans ; unsigned char * pt , * ipt , * mpt ; short * g_d ; register int gd ; struct gcol * pos ; int bit ; _GDraw_getimageclut ( base , clut ) ; for ( i = src -> width - 1 ; i >= 0 ; -- i ) { gdisp -> gg . green_dith [ i ] = 0 ; } for ( i = src -> y ; i < src -> y + src -> height ; ++ i ) { pt = ( unsigned char * ) ( base -> data ) + i * base -> bytes_per_line + src -> x ; ipt = ( unsigned char * ) ( gdisp -> gg . img -> data ) + ( i - src -> y ) * gdisp -> gg . img -> bytes_per_line ; mpt = ( unsigned char * ) ( gdisp -> gg . mask -> data ) + ( i - src -> y ) * gdisp -> gg . mask -> bytes_per_line ; if ( gdisp -> gg . img -> bitmap_bit_order == MSBFirst ) { bit = 0x80 ; } else { bit = 0x1 ; } gd = 0 ; g_d = gdisp -> gg . green_dith ; for ( j = src -> width - 1 ; j >= 0 ; -- j ) { index = * pt ++ ; if ( index == trans ) { * mpt |= bit ; * ipt &= ~ bit ; ++ g_d ; } else { * mpt &= ~ bit ; pos = & clut [ index ] ; gd += * g_d + pos -> red + pos -> green + pos -> blue ; if ( gd < 3 * 128 ) { * ipt &= ~ bit ; * g_d ++ = gd /= 2 ; } else { * ipt |= bit ; } } if ( gdisp -> gg . img -> bitmap_bit_order == MSBFirst ) { if ( ( bit >>= 1 ) == 0 ) { bit = 0x80 ; ++ ipt ; ++ mpt ; } } else { if ( ( bit <<= 1 ) == 256 ) { bit = 0x1 ; ++ ipt ; ++ mpt ; } } } } } 