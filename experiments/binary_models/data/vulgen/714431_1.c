int t4_load_phy_fw ( struct adapter * adap , int win , int * phy_fw_version ( const u8 * , size_t ) , const u8 * phy_fw_data , size_t phy_fw_size ) { int cur_phy_fw_ver = 0 , new_phy_fw_vers = 0 ; unsigned long mtype = 0 , maddr ; u32 param , val ; int ret ; if ( phy_fw_version ) { new_phy_fw_vers = phy_fw_version ( phy_fw_data , phy_fw_size ) ; ret = t4_phy_fw_ver ( adap , & cur_phy_fw_ver ) ; if ( ret < 0 ) { return ret ; } if ( cur_phy_fw_ver >= new_phy_fw_vers ) { CH_WARN ( adap , "PHY Firmware already up-to-date, " "version %#x\n" , cur_phy_fw_ver ) ; return 0 ; } } param = ( FW_PARAMS_MNEM_V ( FW_PARAMS_MNEM_DEV ) | FW_PARAMS_PARAM_X_V ( FW_PARAMS_PARAM_DEV_PHYFW ) | FW_PARAMS_PARAM_Y_V ( adap -> params . portvec ) | FW_PARAMS_PARAM_Z_V ( FW_PARAMS_PARAM_DEV_PHYFW_DOWNLOAD ) ) ; val = phy_fw_size ; ret = t4_query_params_rw ( adap , adap -> mbox , adap -> pf , 0 , 1 , & param , & val , 1 , true ) ; if ( ret < 0 ) { return ret ; } mtype = val >> 8 ; maddr = ( val & 0xff ) << 16 ; spin_lock_bh ( & adap -> win0_lock ) ; ret = t4_memory_rw ( adap , win , mtype , maddr , phy_fw_size , ( __be32 * ) phy_fw_data , T4_MEMORY_WRITE ) ; spin_unlock_bh ( & adap -> win0_lock ) ; if ( ret ) { return ret ; } param = ( FW_PARAMS_MNEM_V ( FW_PARAMS_MNEM_DEV ) | FW_PARAMS_PARAM_X_V ( FW_PARAMS_PARAM_DEV_PHYFW ) | FW_PARAMS_PARAM_Y_V ( adap -> params . portvec ) | FW_PARAMS_PARAM_Z_V ( FW_PARAMS_PARAM_DEV_PHYFW_DOWNLOAD ) ) ; ret = t4_set_params_timeout ( adap , adap -> mbox , adap -> pf , 0 , 1 , & param , & val , 30000 ) ; if ( phy_fw_version ) { ret = t4_phy_fw_ver ( adap , & cur_phy_fw_ver ) ; if ( ret < 0 ) { return ret ; } if ( cur_phy_fw_ver != new_phy_fw_vers ) { CH_WARN ( adap , "PHY Firmware did not update: " "version on adapter %#x, " "version flashed %#x\n" , cur_phy_fw_ver , new_phy_fw_vers ) ; return - ENXIO ; } } return 1 ; } 