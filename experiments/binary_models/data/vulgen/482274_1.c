static int ov13b10_probe ( struct i2c_client * client ) { struct ov13b10 * ov13b ; int ret ; ret = ov13b10_check_hwcfg ( & client -> dev ) ; if ( ret ) { dev_err ( & client -> dev , "failed to check hwcfg: %d" , ret ) ; return ret ; } ov13b = devm_kzalloc ( & client -> dev , sizeof ( * ov13b ) , GFP_KERNEL ) ; if ( ! ov13b ) { return - ENOMEM ; } v4l2_i2c_subdev_init ( & ov13b -> sd , client , & ov13b10_subdev_ops ) ; ret = ov13b10_identify_module ( ov13b ) ; if ( ret ) { dev_err ( & client -> dev , "failed to find sensor: %d\n" , ret ) ; return ret ; } ov13b -> cur_mode = & supported_modes [ 0 ] ; ret = ov13b10_init_controls ( ov13b ) ; if ( ret ) { return ret ; } ov13b -> sd . internal_ops = & ov13b10_internal_ops ; ov13b -> sd . flags |= V4L2_SUBDEV_FL_HAS_DEVNODE ; ov13b -> sd . entity . ops = & ov13b10_subdev_entity_ops ; ov13b -> sd . entity . function = MEDIA_ENT_F_CAM_SENSOR ; ov13b -> pad . flags = MEDIA_PAD_FL_SOURCE ; ret = media_entity_pads_init ( & ov13b -> sd . entity , 1 , & ov13b -> pad ) ; if ( ret ) { dev_err ( & client -> dev , "%s failed:%d\n" , __func__ , ret ) ; error_handler_free } ret = v4l2_async_register_subdev_sensor ( & ov13b -> sd ) ; pm_runtime_set_active ( & client -> dev ) ; pm_runtime_enable ( & client -> dev ) ; pm_runtime_idle ( & client -> dev ) ; return 0 ; error_media_entity media_entity_cleanup ( & ov13b -> sd . entity ) ; error_handler_free ov13b10_free_controls ( ov13b ) ; dev_err ( & client -> dev , "%s failed:%d\n" , __func__ , ret ) ; return ret ; } 