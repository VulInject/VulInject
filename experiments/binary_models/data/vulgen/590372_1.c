static void run_tests ( LookupScope scope , char * * patterns ) { _cleanup_ ( ) char * runtime_dir = NULL ; _cleanup_free_ char * unit_paths = NULL ; _cleanup_ ( ) Manager * m = NULL ; int r ; static const test_entry tests [ ] { entry ( test_exec_basic ) entry ( test_exec_ambientcapabilities ) entry ( test_exec_bindpaths ) entry ( test_exec_capabilityboundingset ) entry ( test_exec_condition ) entry ( test_exec_cpuaffinity ) entry ( test_exec_credentials ) entry ( test_exec_dynamicuser ) entry ( test_exec_environment ) entry ( test_exec_environmentfile ) entry ( test_exec_execsearchpath ) entry ( test_exec_execsearchpath_environment ) entry ( test_exec_execsearchpath_environment_files ) entry ( test_exec_execsearchpath_passenvironment ) entry ( test_exec_execsearchpath_specifier ) entry ( test_exec_group ) entry ( test_exec_ignoresigpipe ) entry ( test_exec_inaccessiblepaths ) entry ( test_exec_ioschedulingclass ) entry ( test_exec_mount_apivfs ) entry ( test_exec_noexecpaths ) entry ( test_exec_oomscoreadjust ) entry ( test_exec_passenvironment ) entry ( test_exec_personality ) entry ( test_exec_privatedevices ) entry ( test_exec_privatenetwork ) entry ( test_exec_privatetmp ) entry ( test_exec_protecthome ) entry ( test_exec_protectkernelmodules ) entry ( test_exec_readonlypaths ) entry ( test_exec_readwritepaths ) entry ( test_exec_restrictnamespaces ) entry ( test_exec_runtimedirectory ) entry ( test_exec_specifier ) entry ( test_exec_standardinput ) entry ( test_exec_standardoutput ) entry ( test_exec_standardoutput_append ) entry ( test_exec_standardoutput_truncate ) entry ( test_exec_supplementarygroups ) entry ( test_exec_systemcallerrornumber ) entry ( test_exec_systemcallfilter ) entry ( test_exec_systemcallfilter_system ) entry ( test_exec_temporaryfilesystem ) entry ( test_exec_umask ) entry ( test_exec_umask_namespace ) entry ( test_exec_unsetenvironment ) entry ( test_exec_user ) entry ( test_exec_workingdirectory ) { } } ; ; assert_se ( unsetenv ( "USER" ) == 0 ) ; assert_se ( unsetenv ( "LOGNAME" ) == 0 ) ; assert_se ( unsetenv ( "SHELL" ) == 0 ) ; assert_se ( unsetenv ( "HOME" ) == 0 ) ; assert_se ( unsetenv ( "TMPDIR" ) == 0 ) ; assert_se ( unsetenv ( "VAR1" ) == 0 ) ; assert_se ( unsetenv ( "VAR2" ) == 0 ) ; assert_se ( unsetenv ( "VAR3" ) == 0 ) ; assert_se ( unsetenv ( "VAR4" ) == 0 ) ; assert_se ( unsetenv ( "VAR5" ) == 0 ) ; assert_se ( runtime_dir = setup_fake_runtime_dir ( ) ) ; assert_se ( user_runtime_unit_dir = path_join ( runtime_dir , "systemd/user" ) ) ; assert_se ( unit_paths = strjoin ( PRIVATE_UNIT_DIR , ":" , user_runtime_unit_dir ) ) ; assert_se ( set_unit_path ( unit_paths ) >= 0 ) ; r = manager_new ( scope , MANAGER_TEST_RUN_BASIC , & m ) ; assert_se ( r >= 0 ) ; m -> default_std_output = EXEC_OUTPUT_NULL ; assert_se ( manager_startup ( m , NULL , NULL , NULL ) >= 0 ) ; for ( const test_entry * test = tests ; test -> f ; test ++ ) { if ( strv_fnmatch_or_empty ( patterns , test -> name , FNM_NOESCAPE ) ) { test -> f ( m ) ; } else { log_info ( "Skipping %s because it does not match any pattern." , test -> name ) ; } } } 