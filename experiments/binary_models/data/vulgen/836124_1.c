gimp_operation_anti_erase_process ( , , , , , , , ) { GimpOperationLayerMode * layer_mode = ( gpointer ) op ; gfloat * in = in_p ; gfloat * out = out_p ; gfloat * layer = layer_p ; gfloat * mask = mask_p ; gfloat opacity = layer_mode -> opacity ; switch ( layer_mode -> composite_mode ) { case GIMP_LAYER_COMPOSITE_UNION : case GIMP_LAYER_COMPOSITE_AUTO : while ( samples -- ) { gfloat value = opacity ; gint b ; if ( has_mask ) { value *= * mask ; } out [ ALPHA ] = in [ ALPHA ] + ( 1.0 - in [ ALPHA ] ) * layer [ ALPHA ] * value ; for ( b = RED ; b < ALPHA ; b ++ ) { out [ b ] = in [ b ] ; } in += 4 ; layer += 4 ; out += 4 ; if ( has_mask ) { mask ++ ; } } break ; case GIMP_LAYER_COMPOSITE_CLIP_TO_BACKDROP : while ( samples -- ) { gint b ; out [ ALPHA ] = in [ ALPHA ] ; for ( b = RED ; b < ALPHA ; b ++ ) { out [ b ] = in [ b ] ; } in += 4 ; out += 4 ; } break ; case GIMP_LAYER_COMPOSITE_CLIP_TO_LAYER : while ( samples -- ) { gfloat value = opacity ; gint b ; if ( has_mask ) { value *= * mask ; } out [ ALPHA ] = layer [ ALPHA ] * value ; for ( b = RED ; b < ALPHA ; b ++ ) { out [ b ] = in [ b ] ; } in += 4 ; layer += 4 ; out += 4 ; if ( has_mask ) { mask ++ ; } } break ; case GIMP_LAYER_COMPOSITE_INTERSECTION : while ( samples -- ) { gfloat value = opacity ; gint b ; if ( has_mask ) { value *= * mask ; } out [ ALPHA ] = in [ ALPHA ] * layer [ ALPHA ] * value ; for ( b = RED ; b < ALPHA ; b ++ ) { out [ b ] = in [ b ] ; } in += 4 ; layer += 4 ; out += 4 ; if ( has_mask ) { mask ++ ; } } break ; } return TRUE ; } 