int pcacheset_resolve ( pollstate_t * ps , nfds_t nfds , int * fdcntp , int which ) { int i ; pollcache_t * pcp = ps -> ps_pcache ; pollfd_t * newlist = NULL ; pollfd_t * current = ps -> ps_pollfd ; pollfd_t * cached ; pollcacheset_t * pcsp ; int common ; int count = 0 ; int offset ; int remain ; int fd ; file_t * fp ; int fdcnt = 0 ; int cnt = 0 ; nfds_t old_nfds ; int error = 0 ; int mismatch = 0 ; ASSERT ( MUTEX_HELD ( & ps -> ps_lock ) ) ; checkpolldat ( ps ) ; pcsp = & ps -> ps_pcacheset [ which ] ; old_nfds = pcsp -> pcs_nfds ; common = ( nfds > old_nfds ) ?old_nfds : nfds ; if ( nfds != old_nfds ) { newlist = kmem_alloc ( nfds * sizeof ( pollfd_t ) , KM_SLEEP ) ; bcopy ( current , newlist , sizeof ( pollfd_t ) * nfds ) ; } cached = pcsp -> pcs_pollfd ; remain = common ; while ( count < common ) { int tmpfd ; pollfd_t * np ; np = ( newlist != NULL ) ?& newlist [ count ] : NULL ; offset = pcacheset_cmp ( & current [ count ] , & cached [ count ] , np , remain ) ; if ( ( count == 0 ) && ( offset == common ) ) { pollstats . pollcachehit . value . ui64 ++ ; } else { mismatch ++ ; } count += offset ; if ( offset < remain ) { ASSERT ( count < common ) ; ASSERT ( ( current [ count ] . fd != cached [ count ] . fd ) || ( current [ count ] . events != cached [ count ] . events ) ) ; if ( current [ count ] . events & ~ VALID_POLL_EVENTS ) { if ( newlist != NULL ) { newlist [ count ] . events = current [ count ] . events &= VALID_POLL_EVENTS ; } else { current [ count ] . events &= VALID_POLL_EVENTS ; } } if ( cached [ count ] . fd >= 0 ) { tmpfd = cached [ count ] . fd ; if ( pcache_delete_fd ( ps , tmpfd , count , which , ( uint_t ) cached [ count ] . events ) ) { for ( i = count + 1 ; i < old_nfds ; i ++ ) { if ( cached [ i ] . fd == tmpfd ) { pcache_update_xref ( pcp , tmpfd , ( ssize_t ) i , which ) ; break ; } } ASSERT ( i <= old_nfds ) ; } cached [ count ] . fd = - 1 ; if ( newlist != NULL ) { newlist [ count ] . fd = - 1 ; } } if ( ( tmpfd = current [ count ] . fd ) >= 0 ) { if ( ( fp = getf ( tmpfd ) ) == NULL ) { current [ count ] . revents = POLLNVAL ; if ( newlist != NULL ) { newlist [ count ] . fd = - 1 ; } cached [ count ] . fd = - 1 ; fdcnt ++ ; } else { error = pcache_insert ( ps , fp , & current [ count ] , & cnt , ( ssize_t ) count , which ) ; if ( error ) { releasef ( tmpfd ) ; if ( newlist != NULL ) { kmem_free ( newlist , nfds * sizeof ( pollfd_t ) ) ; } return ( error ) ; } if ( newlist != NULL ) { newlist [ count ] . fd = current [ count ] . fd ; newlist [ count ] . events = current [ count ] . events ; } cached [ count ] . fd = current [ count ] . fd ; cached [ count ] . events = current [ count ] . events ; releasef ( tmpfd ) ; } } else { current [ count ] . revents = 0 ; } count ++ ; remain = common - count ; } } if ( mismatch != 0 ) { if ( mismatch == common ) { pollstats . pollcachemiss . value . ui64 ++ ; } else { pollstats . pollcachephit . value . ui64 ++ ; } } if ( nfds > old_nfds ) { ASSERT ( newlist != NULL ) ; for ( i = old_nfds ; i < nfds ; i ++ ) { if ( current [ i ] . events & ~ VALID_POLL_EVENTS ) { newlist [ i ] . events = current [ i ] . events = current [ i ] . events & VALID_POLL_EVENTS ; } if ( ( fd = current [ i ] . fd ) < 0 ) { current [ i ] . revents = 0 ; continue ; } if ( ( fp = getf ( fd ) ) == NULL ) { current [ i ] . revents = POLLNVAL ; newlist [ i ] . fd = - 1 ; fdcnt ++ ; continue ; } error = pcache_insert ( ps , fp , & current [ i ] , & cnt , ( ssize_t ) i , which ) ; releasef ( fd ) ; if ( error ) { pcacheset_remove_list ( ps , current , old_nfds , i , which , 0 ) ; kmem_free ( newlist , nfds * sizeof ( pollfd_t ) ) ; return ( error ) ; } } } if ( old_nfds > nfds ) { pcacheset_remove_list ( ps , pcsp -> pcs_pollfd , nfds , old_nfds , which , 1 ) ; } ASSERT ( * fdcntp == 0 ) ; * fdcntp = fdcnt ; ASSERT ( pollchecksanity ( ps , nfds ) ) ; ASSERT ( pollcheckxref ( ps , which ) ) ; checkpolldat ( ps ) ; return ( 0 ) ; } 