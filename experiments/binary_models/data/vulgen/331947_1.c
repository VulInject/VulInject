BdrvDirtyBitmap * block_dirty_bitmap_merge ( const char * node , const char * target , BlockDirtyBitmapMergeSourceList * bms , HBitmap * * backup , Error * * errp ) { BlockDriverState * bs ; BdrvDirtyBitmap * dst , * src , * anon ; BlockDirtyBitmapMergeSourceList * lst ; Error * local_err = NULL ; dst = block_dirty_bitmap_lookup ( node , target , & bs , errp ) ; if ( ! dst ) { return NULL ; } anon = bdrv_create_dirty_bitmap ( bs , bdrv_dirty_bitmap_granularity ( dst ) , NULL , errp ) ; if ( ! anon ) { return NULL ; } for ( lst = bms ; lst ; lst = lst -> next ) { switch ( lst -> value -> type ) { const char * name , * node ; case QTYPE_QSTRING : name = lst -> value -> u . local ; src = bdrv_find_dirty_bitmap ( bs , name ) ; if ( ! src ) { error_setg ( errp , "Dirty bitmap '%s' not found" , name ) ; dst = NULL ; out } break ; case QTYPE_QDICT : node = lst -> value -> u . external . node ; name = lst -> value -> u . external . name ; src = block_dirty_bitmap_lookup ( node , name , NULL , errp ) ; if ( ! src ) { dst = NULL ; out } break ; default : abort ( ) ; } bdrv_merge_dirty_bitmap ( anon , src , NULL , & local_err ) ; if ( local_err ) { error_propagate ( errp , local_err ) ; dst = NULL ; out } } bdrv_merge_dirty_bitmap ( dst , anon , backup , errp ) ; out return dst ; } 