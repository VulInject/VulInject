static int speedstep_init ( cpu_t * cp ) { cpupm_mach_state_t * mach_state = ( cpupm_mach_state_t * ) cp -> cpu_m . mcpu_pm_mach_state ; cpu_acpi_handle_t handle = mach_state -> ms_acpi_handle ; cpu_acpi_pct_t * pct_stat ; static int logged = 0 ; ESSDEBUG ( ( "speedstep_init: processor %d\n" , cp -> cpu_id ) ) ; if ( cpu_acpi_cache_pstate_data ( handle ) != 0 ) { speedstep_fini ( cp ) ; return ( ESS_RET_NO_PM ) ; } pct_stat = CPU_ACPI_PCT_STATUS ( handle ) ; switch ( pct_stat -> cr_addrspace_id ) { case ACPI_ADR_SPACE_FIXED_HARDWARE : ESSDEBUG ( ( "Transitions will use fixed hardware\n" ) ) ; break ; case ACPI_ADR_SPACE_SYSTEM_IO : ESSDEBUG ( ( "Transitions will use system IO\n" ) ) ; break ; default : cmn_err ( CE_WARN , "!_PCT conifgured for unsupported " "addrspace = %d." , pct_stat -> cr_addrspace_id ) ; cmn_err ( CE_NOTE , "!CPU power management will not function." ) ; speedstep_fini ( cp ) ; return ( ESS_RET_NO_PM ) ; } cpupm_alloc_domains ( cp , CPUPM_P_STATES ) ; if ( speedstep_turbo_supported ( ) ) { mach_state -> ms_turbo = cpupm_turbo_init ( cp ) ; } ESSDEBUG ( "Processor %d succeeded.\n" ) return ( ESS_RET_SUCCESS ) ; } 