static void brcmf_pcie_setup ( struct device * dev , const struct firmware * fw , void * nvram , u32 nvram_len ) { struct brcmf_bus * bus = dev_get_drvdata ( dev ) ; struct brcmf_pciedev * pcie_bus_dev = bus -> bus_priv . pcie ; struct brcmf_pciedev_info * devinfo = pcie_bus_dev -> devinfo ; struct brcmf_commonring * * flowrings ; int ret ; u32 i ; brcmf_pcie_attach ( devinfo ) ; brcmf_pcie_adjust_ramsize ( devinfo , ( u8 * ) fw -> data , fw -> size ) ; ret = brcmf_pcie_download_fw_nvram ( devinfo , fw , nvram , nvram_len ) ; devinfo -> state = BRCMFMAC_PCIE_STATE_UP ; ret = brcmf_pcie_init_ringbuffers ( devinfo ) ; if ( ret ) { fail } ret = brcmf_pcie_init_scratchbuffers ( devinfo ) ; if ( ret ) { fail } brcmf_pcie_select_core ( devinfo , BCMA_CORE_PCIE2 ) ; ret = brcmf_pcie_request_irq ( devinfo ) ; if ( ret ) { fail } for ( i = 0 ; i < BRCMF_NROF_COMMON_MSGRINGS ; i ++ ) { bus -> msgbuf -> commonrings [ i ] = & devinfo -> shared . commonrings [ i ] -> commonring ; } flowrings = kcalloc ( devinfo -> shared . max_flowrings , sizeof ( * flowrings ) , GFP_KERNEL ) ; if ( ! flowrings ) { fail } for ( i = 0 ; i < devinfo -> shared . max_flowrings ; i ++ ) { flowrings [ i ] = & devinfo -> shared . flowrings [ i ] . commonring ; } bus -> msgbuf -> flowrings = flowrings ; bus -> msgbuf -> rx_dataoffset = devinfo -> shared . rx_dataoffset ; bus -> msgbuf -> max_rxbufpost = devinfo -> shared . max_rxbufpost ; bus -> msgbuf -> max_flowrings = devinfo -> shared . max_flowrings ; init_waitqueue_head ( & devinfo -> mbdata_resp_wait ) ; brcmf_pcie_intr_enable ( devinfo ) ; if ( brcmf_pcie_attach_bus ( devinfo ) == 0 ) { return ; } brcmf_pcie_bus_console_read ( devinfo ) ; fail device_release_driver ( dev ) ; } 