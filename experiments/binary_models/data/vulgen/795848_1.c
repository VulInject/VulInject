CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES , LOSS OF USE , DATA , OR PROFITS , OR BUSINESS INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE . * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * silk_float silk_residual_energy_covar_FLP ( const silk_float * c , silk_float * wXX , const silk_float * wXx , const silk_float wxx , const opus_int D ) ( opus_int i , j , k , silk_float tmp , nrg = 0.0f , regularization , silk_assert ( D >= 0 ) , regularization = REGULARIZATION_FACTOR * ( wXX [ 0 ] + wXX [ D * D - 1 ] ) , ( k = 0 k < MAX_ITERATIONS_RESIDUAL_NRG k ++ ) { nrg = wxx tmp = 0.0f for ( i = 0 ; i < D ; i ++ ) { tmp += wXx [ i ] * c [ i ] } nrg -= 2.0f * tmp ; } for ( i = 0 ; i < D ; i ++ ) { tmp = 0.0f for ( j = i + 1 ; j < D ; j ++ ) { tmp += matrix_c_ptr ( wXX , i , j , D ) * c [ j ] } nrg += c [ i ] * ( 2.0f * tmp + matrix_c_ptr ( wXX , i , i , D ) * c [ i ] ) ; } ; ) ; else { for ( i = 0 ; i < D ; i ++ ) { matrix_c_ptr ( wXX , i , i , D ) += regularization ; } regularization *= 2.0f ; } ( k == MAX_ITERATIONS_RESIDUAL_NRG ) { silk_assert ( nrg == 0 ) nrg = 1.0f } ; return nrg ; 