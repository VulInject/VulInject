static void _guid_cycle_sort ( SwitchportToNextGuid_t * ports , int portCount , void * scratch , int useSysGuid ) { int i , j ; int uniqueGuids = 0 ; GuidCounter_t * gc = ( GuidCounter_t * ) scratch ; SwitchportToNextGuid_t tmpPort ; uint64_t prevGuid = 0 ; uint16_t sortIndex = 0 ; for ( i = 0 ; i < portCount ; i ++ ) { if ( ( useSysGuid ?ports [ i ] . sysGuid : ports [ i ] . guid ) != prevGuid ) { gc [ uniqueGuids ] . guid = useSysGuid ?ports [ i ] . sysGuid : ports [ i ] . guid ; gc [ uniqueGuids ] . offset = i ; gc [ uniqueGuids ] . count = 1 ; uniqueGuids ++ ; } else { gc [ uniqueGuids - 1 ] . count ++ ; } ports [ i ] . sortIndex = 0 ; prevGuid = useSysGuid ?ports [ i ] . sysGuid : ports [ i ] . guid ; } if ( uniqueGuids <= 1 || uniqueGuids == portCount ) { return ; } for ( i = 0 , j = 0 ; i < portCount ; i ++ , j = ( j + 1 ) % uniqueGuids ) { while ( gc [ j ] . count == 0 ) { j = ( j + 1 ) % uniqueGuids ; } ports [ gc [ j ] . offset ++ ] . sortIndex = sortIndex ++ ; gc [ j ] . count -- ; } for ( i = 0 ; i < portCount ; i ++ ) { while ( ports [ i ] . sortIndex != i ) { memcpy ( & tmpPort , & ports [ i ] , sizeof ( SwitchportToNextGuid_t ) ) ; memcpy ( & ports [ i ] , & ports [ tmpPort . sortIndex ] , sizeof ( SwitchportToNextGuid_t ) ) ; memcpy ( & ports [ tmpPort . sortIndex ] , & tmpPort , sizeof ( SwitchportToNextGuid_t ) ) ; } } } 