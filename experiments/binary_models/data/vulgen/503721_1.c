static inline void SCACBSCreateModDeltaTable ( MpmCtx * mpm_ctx ) { SCACBSCtx * ctx = ( SCACBSCtx * ) mpm_ctx -> ctx ; if ( ctx -> state_count < 32767 ) { int size = 0 ; uint32_t state ; for ( state = 1 ; state < ctx -> state_count ; state ++ ) { int ascii_code ; int k = 0 ; for ( ascii_code = 0 ; ascii_code < 256 ; ascii_code ++ ) { if ( SCACBSZeroTransitionPresent ( ctx , temp_state ) ) { continue ; } k ++ ; } size += sizeof ( uint16_t ) * k * 2 ; } size += ( ctx -> state_count * sizeof ( SC_AC_BS_STATE_TYPE_U16 ) + 256 * sizeof ( SC_AC_BS_STATE_TYPE_U16 ) * 1 ) ; ctx -> state_table_mod = SCMalloc ( size ) ; if ( ctx -> state_table_mod == NULL ) { FatalError ( "Error allocating memory" ) ; } memset ( ctx -> state_table_mod , 0 , size ) ; mpm_ctx -> memory_cnt ++ ; mpm_ctx -> memory_size += size ; ctx -> state_table_mod_pointers = SCMalloc ( ctx -> state_count * sizeof ( uint8_t * ) ) ; if ( ctx -> state_table_mod_pointers == NULL ) { FatalError ( "Error allocating memory" ) ; } memset ( ctx -> state_table_mod_pointers , 0 , ctx -> state_count * sizeof ( uint8_t * ) ) ; SC_AC_BS_STATE_TYPE_U16 temp_states [ 256 ] ; uint16_t * curr_loc = ( uint16_t * ) ctx -> state_table_mod ; uint16_t * no_of_entries = NULL ; uint16_t * ascii_codes = NULL ; uint16_t ascii_code = 0 ; uint16_t k = 0 ; for ( state = 0 ; state < ctx -> state_count ; state ++ ) { ctx -> state_table_mod_pointers [ state ] = ( uint8_t * ) curr_loc ; no_of_entries = curr_loc ++ ; ascii_codes = curr_loc ; k = 0 ; for ( ascii_code = 0 ; ascii_code < 256 ; ascii_code ++ ) { uint32_t temp_state = ctx -> state_table_u16 [ state ] [ ascii_code ] ; if ( state != 0 && SCACBSZeroTransitionPresent ( ctx , temp_state ) ) { continue ; } ascii_codes [ k ] = ascii_code ; temp_states [ k ] = ctx -> state_table_u16 [ state ] [ ascii_code ] ; k ++ ; } if ( k > 0 ) { no_of_entries [ 0 ] = k ; if ( state != 0 ) { curr_loc += k ; } memcpy ( curr_loc , temp_states , k * sizeof ( SC_AC_BS_STATE_TYPE_U16 ) ) ; curr_loc += k ; } } } else { int size = 0 ; uint32_t state ; for ( state = 1 ; state < ctx -> state_count ; state ++ ) { int ascii_code ; int k = 0 ; for ( ascii_code = 0 ; ascii_code < 256 ; ascii_code ++ ) { uint32_t temp_state = ctx -> state_table_u32 [ state ] [ ascii_code ] ; if ( SCACBSZeroTransitionPresent ( ctx , temp_state ) ) { continue ; } k ++ ; } size += sizeof ( uint32_t ) * k * 2 ; } size += ( ctx -> state_count * sizeof ( SC_AC_BS_STATE_TYPE_U32 ) + 256 * sizeof ( SC_AC_BS_STATE_TYPE_U32 ) * 1 ) ; ctx -> state_table_mod = SCMalloc ( size ) ; if ( ctx -> state_table_mod == NULL ) { FatalError ( "Error allocating memory" ) ; } memset ( ctx -> state_table_mod , 0 , size ) ; mpm_ctx -> memory_cnt ++ ; mpm_ctx -> memory_size += size ; ctx -> state_table_mod_pointers = SCMalloc ( ctx -> state_count * sizeof ( uint8_t * ) ) ; if ( ctx -> state_table_mod_pointers == NULL ) { FatalError ( "Error allocating memory" ) ; } memset ( ctx -> state_table_mod_pointers , 0 , ctx -> state_count * sizeof ( uint8_t * ) ) ; SC_AC_BS_STATE_TYPE_U32 temp_states [ 256 ] ; uint32_t * curr_loc = ( uint32_t * ) ctx -> state_table_mod ; uint32_t * no_of_entries = NULL ; uint32_t * ascii_codes = NULL ; uint32_t ascii_code = 0 ; uint32_t k = 0 ; for ( state = 0 ; state < ctx -> state_count ; state ++ ) { ctx -> state_table_mod_pointers [ state ] = ( uint8_t * ) curr_loc ; no_of_entries = curr_loc ++ ; ascii_codes = curr_loc ; k = 0 ; for ( ascii_code = 0 ; ascii_code < 256 ; ascii_code ++ ) { uint32_t temp_state = ctx -> state_table_u32 [ state ] [ ascii_code ] ; if ( state != 0 && SCACBSZeroTransitionPresent ( ctx , temp_state ) ) { continue ; } ascii_codes [ k ] = ascii_code ; temp_states [ k ] = ctx -> state_table_u32 [ state ] [ ascii_code ] ; k ++ ; } if ( k > 0 ) { no_of_entries [ 0 ] = k ; if ( state != 0 ) { curr_loc += k ; } memcpy ( curr_loc , temp_states , k * sizeof ( SC_AC_BS_STATE_TYPE_U32 ) ) ; curr_loc += k ; } } } return ; } 