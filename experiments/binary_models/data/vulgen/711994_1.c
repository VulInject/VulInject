static int op_thumb ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len , ut32 mask ) { int op_code ; ut16 * _ins = ( ut16 * ) data ; ut16 ins = * _ins ; ut32 * _ins32 = ( ut32 * ) data ; ut32 ins32 = * _ins32 ; struct winedbg_arm_insn * arminsn = arm_new ( ) ; arm_set_thumb ( arminsn , true ) ; arm_set_input_buffer ( arminsn , data ) ; arm_set_pc ( arminsn , addr ) ; op -> delay = 0 ; op -> size = arm_disasm_one_insn ( arminsn ) ; op -> jump = arminsn -> jmp ; op -> fail = arminsn -> fail ; if ( mask & R_ARCH_OP_MASK_DISASM ) { if ( ! strcmp ( cpu , "wd" ) ) { const char * asmstr = winedbg_arm_insn_asm ( arminsn ) ; if ( asmstr ) { op -> mnemonic = strdup ( asmstr ) ; } else { op -> mnemonic = strdup ( "invalid" ) ; } } } arm_free ( arminsn ) ; if ( ( ( ins & B4 ( B1110 , 0 , 0 , 0 ) ) == B4 ( B0010 , 0 , 0 , 0 ) ) && ( 1 == ( ins & B4 ( 1 , B1000 , 0 , 0 ) ) >> 11 ) ) { op -> type = R_ANAL_OP_TYPE_CMP ; return op -> size ; } if ( ( ins & B4 ( B1111 , B1100 , 0 , 0 ) ) == B4 ( B0100 , 0 , 0 , 0 ) ) { op_code = ( ins & B4 ( 0 , B0011 , B1100 , 0 ) ) >> 6 ; if ( op_code == 8 || op_code == 10 ) { op -> type = R_ANAL_OP_TYPE_CMP ; return op -> size ; } } if ( ( ins & B4 ( B1111 , B1100 , 0 , 0 ) ) == B4 ( B0100 , B0100 , 0 , 0 ) ) { op_code = ( ins & B4 ( 0 , B0011 , 0 , 0 ) ) >> 8 ; if ( op_code == 1 ) { op -> type = R_ANAL_OP_TYPE_CMP ; return op -> size ; } } if ( ins == 0xbf ) { op -> type = R_ANAL_OP_TYPE_NOP ; } if ( ( ( op_code = ( ( ins & B4 ( B1111 , B1000 , 0 , 0 ) ) >> 11 ) ) >= 12 && op_code <= 17 ) ) { if ( op_code % 2 ) { op -> type = R_ANAL_OP_TYPE_LOAD ; } else { op -> type = R_ANAL_OP_TYPE_STORE ; } } if ( ( ins & B4 ( B1111 , 0 , 0 , 0 ) ) == B4 ( B0101 , 0 , 0 , 0 ) ) { op_code = ( ins & B4 ( 0 , B1110 , 0 , 0 ) ) >> 9 ; if ( op_code % 2 ) { op -> type = R_ANAL_OP_TYPE_LOAD ; } else { op -> type = R_ANAL_OP_TYPE_STORE ; } } if ( ( ins & B4 ( B1111 , 0 , 0 , 0 ) ) == B4 ( B1101 , 0 , 0 , 0 ) ) { int delta = ( ins & B4 ( 0 , 0 , B1111 , B1111 ) ) ; op -> type = R_ANAL_OP_TYPE_CJMP ; op -> jump = addr + 4 + ( delta << 1 ) ; op -> fail = addr + 4 ; } if ( ( ins & B4 ( B1111 , B1000 , 0 , 0 ) ) == B4 ( B1110 , 0 , 0 , 0 ) ) { int delta = ( ins & B4 ( 0 , 0 , B1111 , B1111 ) ) ; op -> type = R_ANAL_OP_TYPE_JMP ; op -> jump = addr + 4 + ( delta << 1 ) ; op -> fail = addr + 4 ; } if ( ( ins & B4 ( B1111 , B1111 , B1000 , 0 ) ) == B4 ( B0100 , B0111 , B1000 , 0 ) ) { op -> type = R_ANAL_OP_TYPE_UCALL ; op -> fail = addr + 4 ; } if ( ( ins & B4 ( B1111 , B1111 , B1000 , 0 ) ) == B4 ( B0100 , B0111 , 0 , 0 ) ) { op -> type = R_ANAL_OP_TYPE_UJMP ; op -> fail = addr + 4 ; } if ( ( ins & B4 ( B1111 , B1000 , 0 , 0 ) ) == B4 ( B1111 , 0 , 0 , 0 ) ) { ut16 nextins = ( ins32 & 0xFFFF0000 ) >> 16 ; ut32 high = ( ins & B4 ( 0 , B0111 , B1111 , B1111 ) ) << 12 ; if ( ins & B4 ( 0 , B0100 , 0 , 0 ) ) { high |= B4 ( B1111 , B1000 , 0 , 0 ) << 16 ; } int delta = high + ( ( nextins & B4 ( 0 , B0111 , B1111 , B1111 ) ) * 2 ) ; op -> jump = ( int ) ( addr + 4 + ( delta ) ) ; op -> type = R_ANAL_OP_TYPE_CALL ; op -> fail = addr + 4 ; } if ( ( ins & B4 ( B1111 , B1111 , 0 , 0 ) ) == B4 ( B1011 , B1110 , 0 , 0 ) ) { op -> type = R_ANAL_OP_TYPE_TRAP ; op -> val = ( ut64 ) ( ins >> 8 ) ; } if ( ( ins & B4 ( B1111 , B1111 , 0 , 0 ) ) == B4 ( B1101 , B1111 , 0 , 0 ) ) { op -> type = R_ANAL_OP_TYPE_SWI ; op -> val = ( ut64 ) ( ins >> 8 ) ; } return op -> size ; } "eq" , "ne" , "cs" , "cc" , "mi" , "pl" , "vs" , "vc" , "hi" , "ls" , "ge" , "lt" , "gt" , "le" , "al" , "nv" , static const int iconds [ ] = { R_ANAL_COND_EQ R_ANAL_COND_NE 0 0 0 0 0 0 0 0 R_ANAL_COND_GE R_ANAL_COND_LT R_ANAL_COND_GT R_ANAL_COND_LE R_ANAL_COND_AL R_ANAL_COND_NV } ; 