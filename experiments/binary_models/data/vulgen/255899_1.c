struct pbsnode * get_numa_from_str ( const char * str , struct pbsnode * np ) { const char * numa_id ; struct pbsnode * numa ; unsigned long numa_index ; char log_buf [ LOCAL_LOG_BUF_SIZE ] ; if ( np -> node_boards == NULL ) { snprintf ( log_buf , sizeof ( log_buf ) , "Node %s isn't declared to be NUMA, but mom is reporting\n" , np -> get_name ( ) ) ; log_err ( - 1 , __func__ , log_buf ) ; np -> unlock_node ( __func__ , "np numa update" , LOGLEVEL ) ; return ( NULL ) ; } numa_id = str + strlen ( NUMA_KEYWORD ) ; numa_index = atoi ( numa_id ) ; numa = AVL_find ( numa_index , np -> nd_mom_port , np -> node_boards ) ; if ( numa == NULL ) { snprintf ( log_buf , sizeof ( log_buf ) , "Could not find NUMA index %lu for node %s\n" , numa_index , np -> get_name ( ) ) ; log_err ( - 1 , __func__ , log_buf ) ; np -> unlock_node ( __func__ , "np numa update" , LOGLEVEL ) ; return ( NULL ) ; } np -> unlock_node ( __func__ , "np numa update" , LOGLEVEL ) ; numa -> lock_node ( __func__ , "numa numa update" , LOGLEVEL ) ; numa -> nd_lastupdate = time ( NULL ) ; return ( numa ) ; } struct pbsnode * get_node_from_str ( const char * str , const char * orig_id , struct pbsnode * np ) { const char * node_id = str + strlen ( "node=" ) ; struct pbsnode * next = NULL ; char log_buf [ LOCAL_LOG_BUF_SIZE ] ; if ( strcmp ( node_id , np -> get_name ( ) ) ) { np -> unlock_node ( __func__ , "np not numa update" , LOGLEVEL ) ; next = find_nodebyname ( node_id ) ; if ( next == NULL ) { snprintf ( log_buf , sizeof ( log_buf ) , "Node %s is reporting on node %s, which pbs_server doesn't know about\n" , orig_id , node_id ) ; log_err ( - 1 , __func__ , log_buf ) ; } else { if ( LOGLEVEL >= 7 ) { snprintf ( log_buf , sizeof ( log_buf ) , "Node %s is reporting for node %s\n" , orig_id , node_id ) ; log_event ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , __func__ , log_buf ) ; } next -> nd_lastupdate = time ( NULL ) ; } } else { next = np ; next -> nd_lastupdate = time ( NULL ) ; } return ( next ) ; } int handle_auto_np ( struct pbsnode * np , const char * str ) { pbs_attribute nattr ; if ( ( node_attr_def + ND_ATR_np ) -> at_decode ( & nattr , ATTR_NODE_np , NULL , str + 6 , 0 ) == 0 ) { if ( nattr . at_val . at_long != np -> nd_slots . get_total_execution_slots ( ) ) { ( node_attr_def + ND_ATR_np ) -> at_action ( & nattr , ( void * ) np , ATR_ACTION_ALTER ) ; update_nodes_file ( np ) ; } } return ( PBSE_NONE ) ; } void update_job_data ( struct pbsnode * np , const char * jobstring_in ) { char * jobdata ; char * jobdata_ptr ; char * jobidstr ; char * attr_name ; char * attr_value ; char log_buf [ LOCAL_LOG_BUF_SIZE ] ; job * pjob = NULL ; int on_node = FALSE ; if ( ( jobstring_in == NULL ) || ( ! isdigit ( * jobstring_in ) ) ) { return ; } jobdata = strdup ( jobstring_in ) ; jobdata_ptr = jobdata ; jobidstr = threadsafe_tokenizer ( & jobdata_ptr , ":" ) ; if ( ( jobidstr != NULL ) && isdigit ( * jobidstr ) ) { if ( strstr ( jobidstr , server_name ) != NULL ) { on_node = is_job_on_node ( np , job_mapper . get_id ( jobidstr ) ) ; pjob = svr_find_job ( jobidstr , TRUE ) ; if ( pjob != NULL ) { int bad ; svrattrl tA ; mutex_mgr job_mutex ( pjob -> ji_mutex , true ) ; attr_name = threadsafe_tokenizer ( & jobdata_ptr , "=" ) ; while ( attr_name != NULL ) { attr_value = threadsafe_tokenizer ( & jobdata_ptr , "," ) ; if ( LOGLEVEL >= 9 ) { sprintf ( log_buf , "Mom sent changed attribute %s value %s for job %s" , attr_name , attr_value , pjob -> ji_qs . ji_jobid ) ; log_event ( PBSEVENT_JOB , PBS_EVENTCLASS_JOB , pjob -> ji_qs . ji_jobid , log_buf ) ; } memset ( & tA , 0 , sizeof ( tA ) ) ; tA . al_name = attr_name ; tA . al_resc = ( char * ) "" ; tA . al_value = attr_value ; tA . al_op = SET ; modify_job_attr ( pjob , & tA , ATR_DFLAG_MGWR | ATR_DFLAG_SvWR , & bad ) ; attr_name = threadsafe_tokenizer ( & jobdata_ptr , "=" ) ; } } } } } 