static irqreturn_t cs35l35_irq ( int irq , void * data ) { struct cs35l35_private * cs35l35 = data ; unsigned int sticky1 , sticky2 , sticky3 , sticky4 ; unsigned int mask1 , mask2 , mask3 , mask4 , current1 ; regmap_read ( cs35l35 -> regmap , CS35L35_INT_STATUS_4 , & sticky4 ) ; regmap_read ( cs35l35 -> regmap , CS35L35_INT_STATUS_3 , & sticky3 ) ; regmap_read ( cs35l35 -> regmap , CS35L35_INT_STATUS_2 , & sticky2 ) ; regmap_read ( cs35l35 -> regmap , CS35L35_INT_STATUS_1 , & sticky1 ) ; regmap_read ( cs35l35 -> regmap , CS35L35_INT_MASK_4 , & mask4 ) ; regmap_read ( cs35l35 -> regmap , CS35L35_INT_MASK_3 , & mask3 ) ; regmap_read ( cs35l35 -> regmap , CS35L35_INT_MASK_2 , & mask2 ) ; regmap_read ( cs35l35 -> regmap , CS35L35_INT_MASK_1 , & mask1 ) ; if ( sticky2 & CS35L35_PDN_DONE ) { complete ( & cs35l35 -> pdn_done ) ; } regmap_read ( cs35l35 -> regmap , CS35L35_INT_STATUS_1 , & current1 ) ; if ( sticky1 & CS35L35_CAL_ERR ) { dev_crit ( cs35l35 -> dev , "Calibration Error\n" ) ; if ( ! ( current1 & CS35L35_CAL_ERR ) ) { pr_debug ( "%s : Cal error release\n" , __func__ ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PROT_RELEASE_CTL , CS35L35_CAL_ERR_RLS , 0 ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PROT_RELEASE_CTL , CS35L35_CAL_ERR_RLS , CS35L35_CAL_ERR_RLS ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PROT_RELEASE_CTL , CS35L35_CAL_ERR_RLS , 0 ) ; } } if ( sticky1 & CS35L35_AMP_SHORT ) { dev_crit ( cs35l35 -> dev , "AMP Short Error\n" ) ; if ( ! ( current1 & CS35L35_AMP_SHORT ) ) { dev_dbg ( cs35l35 -> dev , "Amp short error release\n" ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PROT_RELEASE_CTL , CS35L35_SHORT_RLS , 0 ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PROT_RELEASE_CTL , CS35L35_SHORT_RLS , CS35L35_SHORT_RLS ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PROT_RELEASE_CTL , CS35L35_SHORT_RLS , 0 ) ; } } if ( sticky1 & CS35L35_OTW ) { dev_warn ( cs35l35 -> dev , "Over temperature warning\n" ) ; if ( ! ( current1 & CS35L35_OTW ) ) { dev_dbg ( cs35l35 -> dev , "Over temperature warn release\n" ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PROT_RELEASE_CTL , CS35L35_OTW_RLS , 0 ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PROT_RELEASE_CTL , CS35L35_OTW_RLS , CS35L35_OTW_RLS ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PROT_RELEASE_CTL , CS35L35_OTW_RLS , 0 ) ; } } if ( sticky1 & CS35L35_OTE ) { dev_crit ( cs35l35 -> dev , "Over temperature error\n" ) ; if ( ! ( current1 & CS35L35_OTE ) ) { dev_dbg ( cs35l35 -> dev , "Over temperature error release\n" ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PROT_RELEASE_CTL , CS35L35_OTE_RLS , 0 ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PROT_RELEASE_CTL , CS35L35_OTE_RLS , CS35L35_OTE_RLS ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PROT_RELEASE_CTL , CS35L35_OTE_RLS , 0 ) ; } } if ( sticky3 & CS35L35_BST_HIGH ) { dev_crit ( cs35l35 -> dev , "VBST error: powering off!\n" ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PWRCTL2 , CS35L35_PDN_AMP , CS35L35_PDN_AMP ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PWRCTL1 , CS35L35_PDN_ALL , CS35L35_PDN_ALL ) ; } if ( sticky3 & CS35L35_LBST_SHORT ) { dev_crit ( cs35l35 -> dev , "LBST error: powering off!\n" ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PWRCTL2 , CS35L35_PDN_AMP , CS35L35_PDN_AMP ) ; regmap_update_bits ( cs35l35 -> regmap , CS35L35_PWRCTL1 , CS35L35_PDN_ALL , CS35L35_PDN_ALL ) ; } if ( sticky2 & CS35L35_VPBR_ERR ) { dev_dbg ( cs35l35 -> dev , "Error: Reactive Brownout\n" ) ; } if ( sticky4 & CS35L35_VMON_OVFL ) { dev_dbg ( cs35l35 -> dev , "Error: VMON overflow\n" ) ; } if ( sticky4 & CS35L35_IMON_OVFL ) { dev_dbg ( cs35l35 -> dev , "Error: IMON overflow\n" ) ; } return IRQ_HANDLED ; } 