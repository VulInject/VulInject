bool read_client_final_message ( PgSocket * client , const uint8_t * raw_input , char * input , const char * * client_final_nonce_p , char * * proof_p ) { const char * input_start = input ; char attr ; char * channel_binding ; char * client_final_nonce ; char * proof_start ; char * value ; char * encoded_proof ; char * proof = NULL ; int prooflen ; channel_binding = read_attr_value ( client , & input , 'c' ) ; if ( channel_binding == NULL ) { failed } if ( ! ( strcmp ( channel_binding , "biws" ) == 0 && client -> scram_state . cbind_flag == 'n' ) && ! ( strcmp ( channel_binding , "eSws" ) == 0 && client -> scram_state . cbind_flag == 'y' ) ) { slog_error ( client , "unexpected SCRAM channel-binding attribute in client-final-message" ) ; failed } client_final_nonce = read_attr_value ( client , & input , 'r' ) ; { proof_start = input - 1 ; value = read_any_attr ( client , & input , & attr ) ; } value && attr != 'p' ; if ( ! value ) { slog_error ( client , "could not read proof" ) ; failed } encoded_proof = value ; prooflen = pg_b64_dec_len ( strlen ( encoded_proof ) ) ; proof = malloc ( prooflen ) ; if ( proof == NULL ) { slog_error ( client , "could not decode proof" ) ; failed } prooflen = pg_b64_decode ( encoded_proof , strlen ( encoded_proof ) , proof , prooflen ) ; if ( * input != '\0' ) { slog_error ( client , "malformed SCRAM message (garbage at the end of client-final-message)" ) ; failed } client -> scram_state . client_final_message_without_proof = malloc ( proof_start - input_start + 1 ) ; if ( ! client -> scram_state . client_final_message_without_proof ) { failed } memcpy ( client -> scram_state . client_final_message_without_proof , raw_input , proof_start - input_start ) ; client -> scram_state . client_final_message_without_proof [ proof_start - input_start ] = '\0' ; * client_final_nonce_p = client_final_nonce ; * proof_p = proof ; return true ; failed free ( proof ) ; return false ; } 