static int drmach_setup_mc_info ( dev_info_t * dip , drmach_mem_t * mp ) { uint64_t memory_ranges [ 128 ] ; int len ; struct memlist * ml ; int rv ; hwd_sb_t * hwd ; hwd_memory_t * pm ; len = sizeof ( memory_ranges ) ; if ( ddi_getlongprop_buf ( DDI_DEV_T_ANY , dip , DDI_PROP_DONTPASS , "sb-mem-ranges" , ( caddr_t ) & memory_ranges [ 0 ] , & len ) != DDI_PROP_SUCCESS ) { mp -> slice_base = 0 ; mp -> slice_size = 0 ; return ( - 1 ) ; } mp -> slice_base = memory_ranges [ 0 ] ; mp -> slice_size = memory_ranges [ 1 ] ; if ( ! mp -> dev . bp -> boot_board ) { int i ; rv = opl_read_hwd ( mp -> dev . bp -> bnum , NULL , NULL , NULL , & hwd ) ; ml = NULL ; pm = & hwd -> sb_cmu . cmu_memory ; for ( i = 0 ; i < HWD_MAX_MEM_CHUNKS ; i ++ ) { if ( pm -> mem_chunks [ i ] . chnk_size > 0 ) { ml = memlist_add_span ( ml , pm -> mem_chunks [ i ] . chnk_start_address , pm -> mem_chunks [ i ] . chnk_size ) ; } } } else { memlist_read_lock ( ) ; ml = memlist_dup ( phys_install ) ; memlist_read_unlock ( ) ; ml = memlist_del_span ( ml , 0ull , mp -> slice_base ) ; if ( ml ) { uint64_t basepa , endpa ; endpa = _ptob64 ( physmax + 1 ) ; basepa = mp -> slice_base + mp -> slice_size ; ml = memlist_del_span ( ml , basepa , endpa - basepa ) ; } } if ( ml ) { uint64_t nbytes = 0 ; struct memlist * p ; for ( p = ml ; p ; p = p -> ml_next ) { nbytes += p -> ml_size ; } if ( ( mp -> nbytes = nbytes ) > 0 ) { mp -> base_pa = ml -> ml_address ; } else { mp -> base_pa = 0 ; } mp -> memlist = ml ; } else { mp -> base_pa = 0 ; mp -> nbytes = 0 ; } return ( 0 ) ; } 