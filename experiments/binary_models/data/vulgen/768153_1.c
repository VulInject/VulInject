s32 rtl8188eu_xmitframe_complete ( struct adapter * adapt , struct xmit_priv * pxmitpriv ) { struct xmit_frame * pxmitframe = NULL ; struct xmit_frame * pfirstframe = NULL ; struct xmit_buf * pxmitbuf ; struct hw_xmit * phwxmit ; struct sta_info * psta = NULL ; struct tx_servq * ptxservq = NULL ; struct list_head * xmitframe_plist = NULL , * xmitframe_phead = NULL ; u32 pbuf ; u32 pbuf_tail ; u32 len ; u32 bulksize = adapt -> HalData -> UsbBulkOutSize ; u8 desc_cnt ; u32 bulkptr ; u32 ff_hwaddr ; RT_TRACE ( _module_rtl8192c_xmit_c_ , _drv_info_ , ( "+xmitframe_complete\n" ) ) ; pxmitbuf = rtw_alloc_xmitbuf ( pxmitpriv ) ; if ( pxmitbuf == NULL ) { return false ; } rtw_free_xmitframe ( pxmitpriv , pxmitframe ) ; pxmitframe = rtw_dequeue_xframe ( pxmitpriv , pxmitpriv -> hwxmits , pxmitpriv -> hwxmit_entry ) ; if ( pxmitframe == NULL ) { rtw_free_xmitbuf ( pxmitpriv , pxmitbuf ) ; return false ; } pxmitframe -> pxmitbuf = pxmitbuf ; pxmitframe -> buf_addr = pxmitbuf -> pbuf ; pxmitbuf -> priv_data = pxmitframe ; pxmitframe -> agg_num = 1 ; rtw_xmitframe_coalesce ( adapt , pxmitframe -> pkt , pxmitframe ) ; rtw_os_xmit_complete ( adapt , pxmitframe ) ; pfirstframe = pxmitframe ; len = xmitframe_need_length ( pfirstframe ) + TXDESC_SIZE + ( pfirstframe -> pkt_offset * PACKET_OFFSET_SZ ) ; pbuf_tail = len ; pbuf = round_up ( pbuf_tail , 8 ) ; desc_cnt = 0 ; bulkptr = bulksize ; if ( pbuf < bulkptr ) { desc_cnt ++ ; } else { desc_cnt = 0 ; bulkptr = ( ( pbuf / bulksize ) + 1 ) * bulksize ; } psta = pfirstframe -> attrib . psta ; switch ( pfirstframe -> attrib . priority ) { case 1 : case 2 : ptxservq = & ( psta -> sta_xmitpriv . bk_q ) ; phwxmit = pxmitpriv -> hwxmits + 3 ; break ; case 4 : case 5 : ptxservq = & ( psta -> sta_xmitpriv . vi_q ) ; phwxmit = pxmitpriv -> hwxmits + 1 ; break ; case 6 : case 7 : ptxservq = & ( psta -> sta_xmitpriv . vo_q ) ; phwxmit = pxmitpriv -> hwxmits ; break ; case 0 : case 3 : default : ptxservq = & ( psta -> sta_xmitpriv . be_q ) ; phwxmit = pxmitpriv -> hwxmits + 2 ; break ; } spin_lock_bh ( & pxmitpriv -> lock ) ; xmitframe_phead = get_list_head ( & ptxservq -> sta_pending ) ; xmitframe_plist = xmitframe_phead -> next ; while ( xmitframe_phead != xmitframe_plist ) { pxmitframe = container_of ( xmitframe_plist , xmit_frame , list ) ; xmitframe_plist = xmitframe_plist -> next ; pxmitframe -> agg_num = 0 ; pxmitframe -> pkt_offset = 0 ; len = xmitframe_need_length ( pxmitframe ) + TXDESC_SIZE + ( pxmitframe -> pkt_offset * PACKET_OFFSET_SZ ) ; if ( round_up ( pbuf + len , 8 ) > MAX_XMITBUF_SZ ) { pxmitframe -> agg_num = 1 ; pxmitframe -> pkt_offset = 1 ; break ; } list_del_init ( & pxmitframe -> list ) ; ptxservq -> qcnt -- ; phwxmit -> accnt -- ; pxmitframe -> buf_addr = pxmitbuf -> pbuf + pbuf ; rtw_xmitframe_coalesce ( adapt , pxmitframe -> pkt , pxmitframe ) ; rtw_os_xmit_complete ( adapt , pxmitframe ) ; update_txdesc ( pxmitframe , pxmitframe -> buf_addr , pxmitframe -> attrib . last_txcmdsz , true ) ; rtw_free_xmitframe ( pxmitpriv , pxmitframe ) ; pbuf_tail = pbuf + len ; pbuf = round_up ( pbuf_tail , 8 ) ; pfirstframe -> agg_num ++ ; if ( MAX_TX_AGG_PACKET_NUMBER == pfirstframe -> agg_num ) { break ; } if ( pbuf < bulkptr ) { desc_cnt ++ ; if ( desc_cnt == adapt -> HalData -> UsbTxAggDescNum ) { break ; } } else { desc_cnt = 0 ; bulkptr = ( ( pbuf / bulksize ) + 1 ) * bulksize ; } } if ( list_empty ( & ptxservq -> sta_pending . queue ) ) { list_del_init ( & ptxservq -> tx_pending ) ; } spin_unlock_bh ( & pxmitpriv -> lock ) ; if ( ( pfirstframe -> attrib . ether_type != 0x0806 ) && ( pfirstframe -> attrib . ether_type != 0x888e ) && ( pfirstframe -> attrib . ether_type != 0x88b4 ) && ( pfirstframe -> attrib . dhcp_pkt != 1 ) ) { rtw_issue_addbareq_cmd ( adapt , pfirstframe ) ; } if ( ( pbuf_tail % bulksize ) == 0 ) { pbuf_tail -= PACKET_OFFSET_SZ ; pfirstframe -> buf_addr += PACKET_OFFSET_SZ ; pfirstframe -> pkt_offset -- ; } update_txdesc ( pfirstframe , pfirstframe -> buf_addr , pfirstframe -> attrib . last_txcmdsz , true ) ; ff_hwaddr = rtw_get_ff_hwaddr ( pfirstframe ) ; usb_write_port ( adapt , ff_hwaddr , pbuf_tail , pxmitbuf ) ; pbuf_tail -= ( pfirstframe -> agg_num * TXDESC_SIZE ) ; pbuf_tail -= ( pfirstframe -> pkt_offset * PACKET_OFFSET_SZ ) ; rtw_count_tx_stats ( adapt , pfirstframe , pbuf_tail ) ; rtw_free_xmitframe ( pxmitpriv , pfirstframe ) ; return true ; } 