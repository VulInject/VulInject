static int mv64x60_cpu_err_probe ( struct platform_device * pdev ) { struct edac_device_ctl_info * edac_dev ; struct resource * r ; struct mv64x60_cpu_pdata * pdata ; int res = 0 ; if ( ! devres_open_group ( & pdev -> dev , mv64x60_cpu_err_probe , GFP_KERNEL ) ) { return - ENOMEM ; } if ( ! edac_dev ) { devres_release_group ( & pdev -> dev , mv64x60_cpu_err_probe ) ; return - ENOMEM ; } pdata = edac_dev -> pvt_info ; pdata -> name = "mv64x60_cpu_err" ; edac_dev -> dev = & pdev -> dev ; platform_set_drvdata ( pdev , edac_dev ) ; edac_dev -> dev_name = dev_name ( & pdev -> dev ) ; r = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! r ) { printk ( KERN_ERR "%s: Unable to get resource for " "CPU err regs\n" , __func__ ) ; res = - ENOENT ; err } if ( ! devm_request_mem_region ( & pdev -> dev , r -> start , resource_size ( r ) , pdata -> name ) ) { printk ( KERN_ERR "%s: Error while requesting mem region\n" , __func__ ) ; res = - EBUSY ; err } pdata -> cpu_vbase [ 0 ] = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ; if ( ! pdata -> cpu_vbase [ 0 ] ) { printk ( KERN_ERR "%s: Unable to setup CPU err regs\n" , __func__ ) ; res = - ENOMEM ; err } r = platform_get_resource ( pdev , IORESOURCE_MEM , 1 ) ; if ( ! r ) { printk ( KERN_ERR "%s: Unable to get resource for " "CPU err regs\n" , __func__ ) ; res = - ENOENT ; err } if ( ! devm_request_mem_region ( & pdev -> dev , r -> start , resource_size ( r ) , pdata -> name ) ) { printk ( KERN_ERR "%s: Error while requesting mem region\n" , __func__ ) ; res = - EBUSY ; err } pdata -> cpu_vbase [ 1 ] = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ; if ( ! pdata -> cpu_vbase [ 1 ] ) { printk ( KERN_ERR "%s: Unable to setup CPU err regs\n" , __func__ ) ; res = - ENOMEM ; err } out_le32 ( pdata -> cpu_vbase [ 1 ] + MV64x60_CPU_ERR_CAUSE , 0 ) ; out_le32 ( pdata -> cpu_vbase [ 1 ] + MV64x60_CPU_ERR_MASK , 0 ) ; out_le32 ( pdata -> cpu_vbase [ 1 ] + MV64x60_CPU_ERR_MASK , 0x000000ff ) ; edac_dev -> mod_name = EDAC_MOD_STR ; edac_dev -> ctl_name = pdata -> name ; if ( edac_op_state == EDAC_OPSTATE_POLL ) { edac_dev -> edac_check = mv64x60_cpu_check ; } pdata -> edac_idx = edac_dev_idx ++ ; if ( edac_device_add_device ( edac_dev ) > 0 ) { edac_dbg ( 3 , "failed edac_device_add_device()\n" ) ; err } if ( edac_op_state == EDAC_OPSTATE_INT ) { pdata -> irq = platform_get_irq ( pdev , 0 ) ; res = devm_request_irq ( & pdev -> dev , pdata -> irq , mv64x60_cpu_isr , 0 , "[EDAC] CPU err" , edac_dev ) ; if ( res < 0 ) { printk ( KERN_ERR "%s: Unable to request irq %d for MV64x60 " "CPU ERR\n" , __func__ , pdata -> irq ) ; res = - ENODEV ; err2 } printk ( " acquired irq %d for CPU Err\n" , ) } devres_remove_group ( & pdev -> dev , mv64x60_cpu_err_probe ) ; edac_dbg ( 3 , "success\n" ) ; return 0 ; err2 edac_device_del_device ( & pdev -> dev ) ; err devres_release_group ( & pdev -> dev , mv64x60_cpu_err_probe ) ; edac_device_free_ctl_info ( edac_dev ) ; return res ; } 