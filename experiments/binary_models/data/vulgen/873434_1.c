void sppp_input ( struct ifnet * ifp , struct mbuf * m ) { struct ppp_header ht ; struct sppp * sp = ( sppp * ) ifp ; struct timeval tv ; int debug = ifp -> if_flags & IFF_DEBUG ; getmicrouptime ( & tv ) ; if ( ifp -> if_flags & IFF_UP ) { ifp -> if_ibytes += m -> m_pkthdr . len + sp -> pp_framebytes ; sp -> pp_last_receive = tv . tv_sec ; } if ( m -> m_pkthdr . len <= PPP_HEADER_LEN ) { if ( debug ) { log ( LOG_DEBUG , SPP_FMT "input packet is too small, %d bytes\n" , SPP_ARGS ( ifp ) , m -> m_pkthdr . len ) ; } drop m_freem ( m ) ; ++ ifp -> if_ierrors ; ++ ifp -> if_iqdrops ; return ; } m -> m_pkthdr . ph_rtableid = ifp -> if_rdomain ; m_copydata ( m , 0 , sizeof ( ht . protocol ) , ( caddr_t ) & ht . protocol ) ; m_adj ( m , 2 ) ; ht . control = PPP_UI ; ht . address = PPP_ALLSTATIONS ; if ( m -> m_len < m -> m_pkthdr . len ) { m = m_pullup ( m , m -> m_pkthdr . len ) ; if ( m == NULL ) { if ( debug ) { log ( LOG_DEBUG , SPP_FMT "Failed to align packet!\n" , SPP_ARGS ( ifp ) ) ; } ++ ifp -> if_ierrors ; ++ ifp -> if_iqdrops ; return ; } } switch ( ht . address ) { case PPP_ALLSTATIONS : if ( ht . control != PPP_UI ) { invalid } switch ( ntohs ( ht . protocol ) ) { default : if ( sp -> state [ IDX_LCP ] == STATE_OPENED ) { sppp_cp_send ( sp , PPP_LCP , PROTO_REJ , ++ sp -> pp_seq , 2 , & ht . protocol ) ; } if ( debug ) { log ( LOG_DEBUG , SPP_FMT "invalid input protocol " "<addr=0x%x ctrl=0x%x proto=0x%x>\n" , SPP_ARGS ( ifp ) , ht . address , ht . control , ntohs ( ht . protocol ) ) ; } ++ ifp -> if_noproto ; drop case PPP_LCP : sppp_cp_input ( & lcp , sp , m ) ; m_freem ( m ) ; return ; case PPP_PAP : if ( sp -> pp_phase >= PHASE_AUTHENTICATE ) { sppp_pap_input ( sp , m ) ; } m_freem ( m ) ; return ; case PPP_CHAP : if ( sp -> pp_phase >= PHASE_AUTHENTICATE ) { sppp_chap_input ( sp , m ) ; } m_freem ( m ) ; return ; case PPP_IPCP : if ( sp -> pp_phase == PHASE_NETWORK ) { sppp_cp_input ( & ipcp , sp , m ) ; } m_freem ( m ) ; return ; case PPP_IP : if ( sp -> state [ IDX_IPCP ] == STATE_OPENED ) { sp -> pp_last_activity = tv . tv_sec ; if ( ifp -> if_flags & IFF_UP ) { ipv4_input ( ifp , m ) ; return ; } } break ; case PPP_IPV6CP : if ( sp -> pp_phase == PHASE_NETWORK ) { sppp_cp_input ( & ipv6cp , sp , m ) ; } m_freem ( m ) ; return ; case PPP_IPV6 : if ( sp -> state [ IDX_IPV6CP ] == STATE_OPENED ) { sp -> pp_last_activity = tv . tv_sec ; } break ; } break ; default : invalid if ( debug ) { log ( LOG_DEBUG , SPP_FMT "invalid input packet " "<addr=0x%x ctrl=0x%x proto=0x%x>\n" , SPP_ARGS ( ifp ) , ht . address , ht . control , ntohs ( ht . protocol ) ) ; } drop } drop } 