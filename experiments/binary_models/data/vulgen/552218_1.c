for ( ; ; ) { condition_block * c ; if ( ! * ptr ) { * error_pointer = US "\"then\" missing at end of filter file" ; break ; } if ( * ptr == '(' ) { ptr = read_condition ( nextsigchar ( ptr + 1 , TRUE ) , & c , FALSE ) ; if ( * error_pointer != NULL ) { break ; } if ( * ptr != ')' ) { * error_pointer = string_sprintf ( "expected \")\" in line %d of " "filter file" , line_number ) ; break ; } if ( ! testfor ) { c -> testfor = ! c -> testfor ; testfor = TRUE ; } ptr = nextsigchar ( ptr + 1 , TRUE ) ; } if ( * ptr == ')' ) { * error_pointer = string_sprintf ( "unexpected \")\" in line %d of " "filter file" , line_number ) ; break ; } else { ptr = nextitem ( ptr , buffer , sizeof ( buffer ) , TRUE ) ; if ( * error_pointer ) { break ; } if ( Ustrcmp ( buffer , "then" ) == 0 ) { * error_pointer = string_sprintf ( "unexpected \"then\" near line %d of " "filter file" , line_number ) ; break ; } if ( Ustrcmp ( buffer , "not" ) == 0 ) { testfor = ! testfor ; continue ; } c -> left . u = c -> right . u = NULL ; c -> testfor = testfor ; testfor = TRUE ; if ( Ustrcmp ( buffer , "delivered" ) == 0 ) { c -> type = cond_delivered ; } if ( Ustrcmp ( buffer , "error_message" ) == 0 ) { c -> type = cond_errormsg ; } if ( Ustrcmp ( buffer , "first_delivery" ) == 0 ) { c -> type = cond_firsttime ; } if ( Ustrcmp ( buffer , "manually_thawed" ) == 0 ) { c -> type = cond_manualthaw ; } if ( Ustrcmp ( buffer , "personal" ) == 0 ) { c -> type = cond_personal ; for ( ; ; ) { string_item * aa ; const uschar * saveptr = ptr ; ptr = nextword ( ptr , buffer , sizeof ( buffer ) , TRUE ) ; if ( * error_pointer ) { break ; } if ( Ustrcmp ( buffer , "alias" ) != 0 ) { ptr = saveptr ; break ; } ptr = nextitem ( ptr , buffer , sizeof ( buffer ) , TRUE ) ; if ( * error_pointer ) { break ; } aa = store_get ( sizeof ( string_item ) , GET_UNTAINTED ) ; aa -> text = string_copy ( buffer ) ; aa -> next = c -> left . a ; c -> left . a = aa ; } } if ( Ustrcmp ( buffer , "foranyaddress" ) == 0 ) { ptr = nextitem ( ptr , buffer , sizeof ( buffer ) , TRUE ) ; if ( * error_pointer ) { break ; } if ( * ptr != '(' ) { * error_pointer = string_sprintf ( "\"(\" expected after \"foranyaddress\" " "near line %d of filter file" , line_number ) ; break ; } c -> type = cond_foranyaddress ; c -> left . u = string_copy ( buffer ) ; ptr = read_condition ( nextsigchar ( ptr + 1 , TRUE ) , & ( c -> right . c ) , FALSE ) ; if ( * error_pointer ) { break ; } if ( * ptr != ')' ) { * error_pointer = string_sprintf ( "expected \")\" in line %d of " "filter file" , line_number ) ; break ; } ptr = nextsigchar ( ptr + 1 , TRUE ) ; } else { int i ; const uschar * isptr = NULL ; c -> left . u = string_copy ( buffer ) ; ptr = nextword ( ptr , buffer , sizeof ( buffer ) , TRUE ) ; if ( * error_pointer ) { break ; } if ( strcmpic ( buffer , US "does" ) == 0 || strcmpic ( buffer , US "is" ) == 0 ) { if ( buffer [ 0 ] == 'i' ) { c -> type = cond_is ; isptr = ptr ; } if ( buffer [ 0 ] == 'I' ) { c -> type = cond_IS ; isptr = ptr ; } ptr = nextword ( ptr , buffer , sizeof ( buffer ) , TRUE ) ; if ( * error_pointer ) { break ; } if ( strcmpic ( buffer , US "not" ) == 0 ) { c -> testfor = ! c -> testfor ; if ( isptr ) { isptr = ptr ; } ptr = nextword ( ptr , buffer , sizeof ( buffer ) , TRUE ) ; if ( * error_pointer ) { break ; } } } for ( i = 0 ; i < cond_word_count ; i ++ ) { if ( Ustrcmp ( buffer , cond_words [ i ] ) == 0 ) { c -> type = cond_types [ i ] ; break ; } } if ( i >= cond_word_count ) { if ( ! isptr ) { * error_pointer = string_sprintf ( "unrecognized condition word \"%s\" " "near line %d of filter file" , buffer , line_number ) ; break ; } ptr = isptr ; } ptr = nextitem ( ptr , buffer , sizeof ( buffer ) , TRUE ) ; if ( * error_pointer ) { break ; } c -> right . u = string_copy ( buffer ) ; } } * current = c ; if ( * ptr == ')' ) { if ( toplevel ) { * error_pointer = string_sprintf ( "unexpected \")\" in line %d of " "filter file" , line_number ) ; } break ; } if ( * ptr == '(' ) { * error_pointer = string_sprintf ( "unexpected \"(\" in line %d of " "filter file" , line_number ) ; break ; } else { ptr = nextword ( ptr , buffer , sizeof ( buffer ) , FALSE ) ; if ( * error_pointer ) { break ; } if ( Ustrcmp ( buffer , "then" ) == 0 ) { if ( ! toplevel ) { * error_pointer = string_sprintf ( "missing \")\" at end of " "condition near line %d of filter file" , line_number ) ; } break ; } if ( Ustrcmp ( buffer , "and" ) == 0 ) { condition_block * andc = store_get ( sizeof ( condition_block ) , GET_UNTAINTED ) ; andc -> parent = current_parent ; andc -> type = cond_and ; andc -> testfor = TRUE ; andc -> left . c = c ; andc -> right . u = NULL ; * current = andc ; current = & ( andc -> right . c ) ; current_parent = andc ; } if ( Ustrcmp ( buffer , "or" ) == 0 ) { condition_block * orc = store_get ( sizeof ( condition_block ) , GET_UNTAINTED ) ; condition_block * or_parent = NULL ; if ( current_parent ) { while ( current_parent -> parent && current_parent -> parent -> type == cond_and ) { current_parent = current_parent -> parent ; } if ( current_parent -> parent ) { or_parent = current_parent -> parent ; } } orc -> parent = or_parent ; if ( ! or_parent ) { * cond = orc ; } else { or_parent -> right . c = orc ; } orc -> type = cond_or ; orc -> testfor = TRUE ; orc -> left . c = ( current_parent == NULL ) ?c : current_parent ; orc -> right . c = NULL ; current = & ( orc -> right . c ) ; current_parent = orc ; } else { * error_pointer = string_sprintf ( "\"and\" or \"or\" or \"%s\" " "expected near line %d of filter file, but found \"%s\"" , toplevel ?"then" : ")" , line_number , buffer ) ; break ; } } } return nextsigchar ( ptr , TRUE ) ; 