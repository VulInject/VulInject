CLIENT * getgssd_handle ( void ) { struct vnode * vp ; int error ; CLIENT * clnt ; enum clnt_stat stat ; struct netbuf tmpaddr ; struct gss_globals * gssg ; struct netbuf * netaddrp ; gssg = zone_getspecific ( gss_zone_key , curproc -> p_zone ) ; if ( gssg -> gss_config . knc_rdev == 0 ) { if ( ( error = lookupname ( "/dev/ticotsord" , UIO_SYSSPACE , FOLLOW , NULLVPP , & vp ) ) != 0 ) { GSSLOG ( 1 , "getgssd_handle: lookupname: %d\n" , error ) ; return ( NULL ) ; } gssg -> gss_config . knc_rdev = vp -> v_rdev ; gssg -> gss_config . knc_protofmly = loopback_name ; VN_RELE ( vp ) ; gssg -> gss_config . knc_semantics = NC_TPI_COTS_ORD ; } mutex_enter ( & gssrpcb_lock ) ; netaddrp = & gssg -> gss_netaddr ; if ( netaddrp -> len == 0 || gssg -> gss_last_stat != RPC_SUCCESS ) { if ( netaddrp -> buf != NULL ) { GSSLOG ( 1 , "getgssd_handle: clnt_tli_kcreate: error %d\n" , 0 ) ; return ( NULL ) ; } netaddrp -> len = netaddrp -> maxlen = 10 ; netaddrp -> buf = kmem_alloc ( netaddrp -> len , KM_SLEEP ) ; ( void ) strncpy ( netaddrp -> buf , "localhost." , netaddrp -> len ) ; stat = rpcbind_getaddr ( & gssg -> gss_config , GSSPROG , GSSVERS , netaddrp ) ; if ( stat != RPC_SUCCESS ) { kmem_free ( netaddrp -> buf , netaddrp -> maxlen ) ; netaddrp -> buf = NULL ; netaddrp -> len = netaddrp -> maxlen = 0 ; mutex_exit ( & gssrpcb_lock ) ; return ( NULL ) ; } } tmpaddr . buf = kmem_zalloc ( netaddrp -> maxlen , KM_SLEEP ) ; bcopy ( netaddrp -> buf , tmpaddr . buf , netaddrp -> maxlen ) ; tmpaddr . maxlen = netaddrp -> maxlen ; tmpaddr . len = netaddrp -> len ; mutex_exit ( & gssrpcb_lock ) ; error = clnt_tli_kcreate ( & gssg -> gss_config , & tmpaddr , GSSPROG , GSSVERS , 0 , GSSD_RETRY , kcred , & clnt ) ; kmem_free ( tmpaddr . buf , tmpaddr . maxlen ) ; if ( error != 0 ) { GSSLOG ( 1 , "getgssd_handle: clnt_tli_kcreate: error %d\n" , error ) ; return ( NULL ) ; } return ( clnt ) ; } 