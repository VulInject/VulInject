static int sst_hsw_dx_state_dump ( struct sst_hsw * hsw ) { struct sst_dsp * sst = hsw -> dsp ; u32 item , offset , size ; int ret = 0 ; trace_ipc_request ( "PM state dump. Items #" , SST_HSW_MAX_DX_REGIONS ) ; if ( hsw -> dx . entries_no > SST_HSW_MAX_DX_REGIONS ) { dev_err ( hsw -> dev , "error: number of FW context regions greater than %d\n" , SST_HSW_MAX_DX_REGIONS ) ; return - EINVAL ; } ret = sst_dsp_dma_get_channel ( sst , 0 ) ; if ( ret < 0 ) { dev_err ( hsw -> dev , "error: cant allocate dma channel %d\n" , ret ) ; return ret ; } sst_dsp_shim_update_bits ( sst , SST_HMDC , SST_HMDC_HDDA_E0_ALLCH | SST_HMDC_HDDA_E1_ALLCH , SST_HMDC_HDDA_E0_ALLCH | SST_HMDC_HDDA_E1_ALLCH ) ; for ( item = 0 ; item < hsw -> dx . entries_no ; item ++ ) { if ( hsw -> dx . mem_info [ item ] . source == SST_HSW_DX_TYPE_MEMORY_DUMP && hsw -> dx . mem_info [ item ] . offset > DSP_DRAM_ADDR_OFFSET && hsw -> dx . mem_info [ item ] . offset < DSP_DRAM_ADDR_OFFSET + SST_HSW_DX_CONTEXT_SIZE ) { offset = hsw -> dx . mem_info [ item ] . offset - DSP_DRAM_ADDR_OFFSET ; size = ( hsw -> dx . mem_info [ item ] . size + 3 ) & ( ~ 3 ) ; ret = sst_dsp_dma_copyfrom ( sst , hsw -> dx_context_paddr + offset , sst -> addr . lpe_base + offset , size ) ; if ( ret < 0 ) { dev_err ( hsw -> dev , "error: FW context dump failed\n" ) ; memset ( & hsw -> dx , 0 , sizeof ( hsw -> dx ) ) ; out } } } out sst_dsp_dma_put_channel ( sst ) ; return ret ; } 