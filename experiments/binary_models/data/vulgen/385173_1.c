static int mt9m032_probe ( struct i2c_client * client , const struct i2c_device_id * devid ) { struct mt9m032_platform_data * pdata = client -> dev . platform_data ; struct i2c_adapter * adapter = client -> adapter ; struct mt9m032 * sensor ; int chip_version ; int ret ; if ( pdata == NULL ) { dev_err ( & client -> dev , "No platform data\n" ) ; return - EINVAL ; } if ( ! i2c_check_functionality ( adapter , I2C_FUNC_SMBUS_WORD_DATA ) ) { dev_warn ( & client -> dev , "I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n" ) ; return - EIO ; } if ( ! client -> dev . platform_data ) { return - ENODEV ; } sensor = devm_kzalloc ( & client -> dev , sizeof ( * sensor ) , GFP_KERNEL ) ; if ( sensor == NULL ) { return - ENOMEM ; } sensor -> pdata = pdata ; v4l2_i2c_subdev_init ( & sensor -> subdev , client , & mt9m032_ops ) ; sensor -> subdev . flags |= V4L2_SUBDEV_FL_HAS_DEVNODE ; chip_version = mt9m032_read ( client , MT9M032_CHIP_VERSION ) ; if ( chip_version != MT9M032_CHIP_VERSION_VALUE ) { dev_err ( & client -> dev , "MT9M032 not detected, wrong version " "0x%04x\n" , chip_version ) ; ret = - ENODEV ; error_sensor } dev_info ( & client -> dev , "MT9M032 detected at address 0x%02x\n" , client -> addr ) ; sensor -> frame_interval . numerator = 1 ; sensor -> frame_interval . denominator = 30 ; sensor -> crop . left = MT9M032_COLUMN_START_DEF ; sensor -> crop . top = MT9M032_ROW_START_DEF ; sensor -> crop . width = MT9M032_COLUMN_SIZE_DEF ; sensor -> crop . height = MT9M032_ROW_SIZE_DEF ; sensor -> format . width = sensor -> crop . width ; sensor -> format . height = sensor -> crop . height ; sensor -> format . code = MEDIA_BUS_FMT_Y8_1X8 ; sensor -> format . field = V4L2_FIELD_NONE ; sensor -> format . colorspace = V4L2_COLORSPACE_SRGB ; v4l2_ctrl_handler_init ( & sensor -> ctrls , 5 ) ; v4l2_ctrl_new_std ( & sensor -> ctrls , & mt9m032_ctrl_ops , V4L2_CID_GAIN , 0 , 127 , 1 , 64 ) ; sensor -> hflip = v4l2_ctrl_new_std ( & sensor -> ctrls , & mt9m032_ctrl_ops , V4L2_CID_HFLIP , 0 , 1 , 1 , 0 ) ; sensor -> vflip = v4l2_ctrl_new_std ( & sensor -> ctrls , & mt9m032_ctrl_ops , V4L2_CID_VFLIP , 0 , 1 , 1 , 0 ) ; v4l2_ctrl_new_std ( & sensor -> ctrls , & mt9m032_ctrl_ops , V4L2_CID_EXPOSURE , MT9M032_SHUTTER_WIDTH_MIN , MT9M032_SHUTTER_WIDTH_MAX , 1 , MT9M032_SHUTTER_WIDTH_DEF ) ; v4l2_ctrl_new_std ( & sensor -> ctrls , & mt9m032_ctrl_ops , V4L2_CID_PIXEL_RATE , pdata -> pix_clock , pdata -> pix_clock , 1 , pdata -> pix_clock ) ; if ( sensor -> ctrls . error ) { ret = sensor -> ctrls . error ; dev_err ( & client -> dev , "control initialization error %d\n" , ret ) ; error_ctrl } v4l2_ctrl_cluster ( 2 , & sensor -> hflip ) ; sensor -> subdev . ctrl_handler = & sensor -> ctrls ; sensor -> pad . flags = MEDIA_PAD_FL_SOURCE ; ret = media_entity_pads_init ( & sensor -> subdev . entity , 1 , & sensor -> pad ) ; if ( ret < 0 ) { error_ctrl } ret = mt9m032_write ( client , MT9M032_RESET , 1 ) ; if ( ret < 0 ) { error_entity } ret = mt9m032_write ( client , MT9M032_RESET , 0 ) ; if ( ret < 0 ) { error_entity } ret = mt9m032_setup_pll ( sensor ) ; if ( ret < 0 ) { error_entity } usleep_range ( 10000 , 11000 ) ; ret = v4l2_ctrl_handler_setup ( & sensor -> ctrls ) ; if ( ret < 0 ) { error_entity } ret = mt9m032_update_geom_timing ( sensor ) ; if ( ret < 0 ) { error_entity } ret = mt9m032_write ( client , 0x41 , 0x0000 ) ; if ( ret < 0 ) { error_entity } ret = mt9m032_write ( client , 0x42 , 0x0003 ) ; if ( ret < 0 ) { error_entity } ret = mt9m032_write ( client , 0x43 , 0x0003 ) ; if ( ret < 0 ) { error_entity } ret = mt9m032_write ( client , 0x7f , 0x0000 ) ; if ( ret < 0 ) { error_entity } if ( sensor -> pdata -> invert_pixclock ) { ret = mt9m032_write ( client , MT9M032_PIX_CLK_CTRL , MT9M032_PIX_CLK_CTRL_INV_PIXCLK ) ; if ( ret < 0 ) { error_entity } } ret = mt9m032_write ( client , MT9M032_RESTART , 1 ) ; if ( ret < 0 ) { error_entity } msleep ( 100 ) ; ret = mt9m032_write ( client , MT9M032_RESTART , 0 ) ; if ( ret < 0 ) { error_entity } msleep ( 100 ) ; ret = update_formatter2 ( sensor , false ) ; if ( ret < 0 ) { error_entity } return ret ; error_entity media_entity_cleanup ( & sensor -> subdev . entity ) ; error_ctrl v4l2_ctrl_handler_free ( & sensor -> ctrls ) ; error_sensor mutex_destroy ( & sensor -> lock ) ; return ret ; } 