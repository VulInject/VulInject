static netdev_tx_t de_start_xmit ( struct sk_buff * skb , struct net_device * dev ) { struct de_private * de = netdev_priv ( dev ) ; unsigned int entry , tx_free ; u32 mapping , len , flags = FirstFrag | LastFrag ; struct de_desc * txd ; spin_lock_irq ( & de -> lock ) ; tx_free = TX_BUFFS_AVAIL ( de ) ; if ( tx_free == 0 ) { netif_stop_queue ( dev ) ; spin_unlock_irq ( & de -> lock ) ; return NETDEV_TX_BUSY ; } tx_free -- ; entry = de -> tx_head ; txd = & de -> tx_ring [ entry ] ; len = skb -> len ; mapping = dma_map_single ( & de -> pdev -> dev , skb -> data , len , DMA_TO_DEVICE ) ; if ( entry == ( DE_TX_RING_SIZE - 1 ) ) { flags |= RingEnd ; } if ( ! tx_free || ( tx_free == ( DE_TX_RING_SIZE / 2 ) ) ) { flags |= TxSwInt ; } flags |= len ; txd -> opts2 = cpu_to_le32 ( flags ) ; txd -> addr1 = cpu_to_le32 ( mapping ) ; de -> tx_skb [ entry ] . skb = skb ; de -> tx_skb [ entry ] . mapping = mapping ; wmb ( ) ; txd -> opts1 = cpu_to_le32 ( DescOwn ) ; wmb ( ) ; de -> tx_head = NEXT_TX ( entry ) ; netif_dbg ( de , tx_queued , dev , "tx queued, slot %d, skblen %d\n" , entry , skb -> len ) ; spin_unlock_irq ( & de -> lock ) ; dw32 ( TxPoll , NormalTxPoll ) ; return NETDEV_TX_OK ; } 