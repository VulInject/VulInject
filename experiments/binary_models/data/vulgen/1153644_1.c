static double imagf ( void * priv , double x , double ch ) { return getimag ( priv , x , ch ) ; } static const char * const func2_names [ ] { "real" "imag" NULL } ; ; static double ( * const func2 [ ] ) ( void * , double , double ) = { realf imagf NULL } ; static int config_input ( AVFilterLink * inlink ) { AVFilterContext * ctx = inlink -> dst ; AFFTFiltContext * s = ctx -> priv ; char * saveptr = NULL ; int ret = 0 , ch ; float overlap , scale = 1.f ; char * args ; const char * last_expr = "1" ; int buf_size ; s -> channels = inlink -> ch_layout . nb_channels ; s -> fft = av_calloc ( s -> channels , sizeof ( * s -> fft ) ) ; s -> ifft = av_calloc ( s -> channels , sizeof ( * s -> ifft ) ) ; for ( int ch = 0 ; ch < s -> channels ; ch ++ ) { ret = av_tx_init ( & s -> fft [ ch ] , & s -> tx_fn , AV_TX_FLOAT_FFT , 0 , s -> fft_size , & scale , 0 ) ; if ( ret < 0 ) { return ret ; } } for ( int ch = 0 ; ch < s -> channels ; ch ++ ) { ret = av_tx_init ( & s -> ifft [ ch ] , & s -> itx_fn , AV_TX_FLOAT_FFT , 1 , s -> fft_size , & scale , 0 ) ; if ( ret < 0 ) { return ret ; } } s -> window_size = s -> fft_size ; buf_size = FFALIGN ( s -> window_size , av_cpu_max_align ( ) ) ; s -> fft_in = av_calloc ( inlink -> ch_layout . nb_channels , sizeof ( * s -> fft_in ) ) ; if ( ! s -> fft_in ) { return AVERROR ( ENOMEM ) ; } s -> fft_out = av_calloc ( inlink -> ch_layout . nb_channels , sizeof ( * s -> fft_out ) ) ; if ( ! s -> fft_out ) { return AVERROR ( ENOMEM ) ; } s -> fft_temp = av_calloc ( inlink -> ch_layout . nb_channels , sizeof ( * s -> fft_temp ) ) ; if ( ! s -> fft_temp ) { return AVERROR ( ENOMEM ) ; } for ( ch = 0 ; ch < inlink -> ch_layout . nb_channels ; ch ++ ) { s -> fft_in [ ch ] = av_calloc ( buf_size , sizeof ( * * s -> fft_in ) ) ; if ( ! s -> fft_in [ ch ] ) { return AVERROR ( ENOMEM ) ; } s -> fft_out [ ch ] = av_calloc ( buf_size , sizeof ( * * s -> fft_out ) ) ; if ( ! s -> fft_out [ ch ] ) { return AVERROR ( ENOMEM ) ; } s -> fft_temp [ ch ] = av_calloc ( buf_size , sizeof ( * * s -> fft_temp ) ) ; if ( ! s -> fft_temp [ ch ] ) { return AVERROR ( ENOMEM ) ; } } s -> real = av_calloc ( inlink -> ch_layout . nb_channels , sizeof ( * s -> real ) ) ; if ( ! s -> real ) { return AVERROR ( ENOMEM ) ; } s -> imag = av_calloc ( inlink -> ch_layout . nb_channels , sizeof ( * s -> imag ) ) ; if ( ! s -> imag ) { return AVERROR ( ENOMEM ) ; } args = av_strdup ( s -> real_str ) ; if ( ! args ) { return AVERROR ( ENOMEM ) ; } for ( ch = 0 ; ch < inlink -> ch_layout . nb_channels ; ch ++ ) { char * arg = av_strtok ( ch == 0 ?args : NULL , "|" , & saveptr ) ; ret = av_expr_parse ( & s -> real [ ch ] , arg ?arg : last_expr , var_names , NULL , NULL , func2_names , func2 , 0 , ctx ) ; if ( ret < 0 ) { fail } if ( arg ) { last_expr = arg ; } s -> nb_exprs ++ ; } av_freep ( & args ) ; args = av_strdup ( s -> img_str ?s -> img_str : s -> real_str ) ; if ( ! args ) { return AVERROR ( ENOMEM ) ; } saveptr = NULL ; last_expr = "1" ; for ( ch = 0 ; ch < inlink -> ch_layout . nb_channels ; ch ++ ) { char * arg = av_strtok ( ch == 0 ?args : NULL , "|" , & saveptr ) ; ret = av_expr_parse ( & s -> imag [ ch ] , arg ?arg : last_expr , var_names , NULL , NULL , func2_names , func2 , 0 , ctx ) ; if ( ret < 0 ) { fail } if ( arg ) { last_expr = arg ; } } av_freep ( & args ) ; s -> window_func_lut = av_realloc_f ( s -> window_func_lut , s -> window_size , sizeof ( * s -> window_func_lut ) ) ; if ( ! s -> window_func_lut ) { return AVERROR ( ENOMEM ) ; } generate_window_func ( s -> window_func_lut , s -> window_size , s -> win_func , & overlap ) ; for ( int i = 0 ; i < s -> window_size ; i ++ ) { s -> window_func_lut [ i ] = sqrtf ( s -> window_func_lut [ i ] / s -> window_size ) ; } if ( s -> overlap == 1 ) { s -> overlap = overlap ; } s -> hop_size = s -> window_size * ( 1 - s -> overlap ) ; if ( s -> hop_size <= 0 ) { return AVERROR ( EINVAL ) ; } s -> window = ff_get_audio_buffer ( inlink , s -> window_size * 2 ) ; if ( ! s -> window ) { return AVERROR ( ENOMEM ) ; } s -> buffer = ff_get_audio_buffer ( inlink , s -> window_size * 2 ) ; if ( ! s -> buffer ) { return AVERROR ( ENOMEM ) ; } fail av_freep ( & args ) ; return ret ; } 