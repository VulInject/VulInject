CK_RV C_VerifyInit ( CK_SESSION_HANDLE hSession , CK_MECHANISM_PTR pMechanism , CK_OBJECT_HANDLE hKey ) { CK_RV rv ; soft_session_t * session_p ; soft_object_t * key_p ; boolean_t lock_held = B_FALSE ; rv = handle2session ( hSession , & session_p ) ; if ( rv != CKR_OK ) { return ( rv ) ; } if ( pMechanism == NULL ) { rv = CKR_ARGUMENTS_BAD ; clean_exit } HANDLE2OBJECT ( hKey , key_p , rv ) ; if ( rv != CKR_OK ) { clean_exit } if ( ! ( key_p -> bool_attr_mask & VERIFY_BOOL_ON ) ) { rv = CKR_KEY_FUNCTION_NOT_PERMITTED ; clean_exit1 } ( void ) pthread_mutex_lock ( & session_p -> session_mutex ) ; lock_held = B_TRUE ; if ( session_p -> verify . flags & CRYPTO_OPERATION_ACTIVE ) { soft_sign_verify_cleanup ( session_p , B_FALSE , B_TRUE ) ; } session_p -> verify . flags = CRYPTO_OPERATION_ACTIVE ; ( void ) pthread_mutex_unlock ( & session_p -> session_mutex ) ; lock_held = B_FALSE ; rv = soft_verify_init ( session_p , pMechanism , key_p ) ; if ( rv != CKR_OK ) { ( void ) pthread_mutex_lock ( & session_p -> session_mutex ) ; session_p -> verify . flags &= ~ CRYPTO_OPERATION_ACTIVE ; lock_held = B_TRUE ; } clean_exit1 OBJ_REFRELE ( key_p ) ; clean_exit SES_REFRELE ( session_p , lock_held ) ; return ( rv ) ; } 