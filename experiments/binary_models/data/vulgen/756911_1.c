int md2_test ( void ) { return CRYPT_NOP ; static const { const char * msg ; } , tests [ ] { { "" { 0x83 0x50 0xe5 0xa3 0xe2 0x4c 0x15 0x3d 0xf2 0x27 0x5c 0x9f 0x80 0x69 0x27 0x73 } } { "a" { 0x32 0xec 0x01 0xec 0x4a 0x6d 0xac 0x72 0xc0 0xab 0x96 0xfb 0x34 0xc0 0xb5 0xd1 } } { "message digest" { 0xab 0x4f 0x49 0x6b 0xfb 0x2a 0x53 0x0b 0x21 0x9f 0xf3 0x30 0x31 0xfe 0x06 0xb0 } } { "abcdefghijklmnopqrstuvwxyz" { 0x4e 0x8d 0xdf 0xf3 0x65 0x02 0x92 0xab 0x5a 0x41 0x08 0xc3 0xaa 0x47 0x94 0x0b } } { "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" { 0xda 0x33 0xde 0xf2 0xa4 0x2d 0xf1 0x39 0x75 0x35 0x28 0x46 0xc3 0x03 0x38 0xcd } } { "12345678901234567890123456789012345678901234567890123456789012345678901234567890" { 0xd5 0x97 0x6f 0x79 0xd8 0x3d 0x3a 0x0d 0xc9 0x80 0x6c 0x3c 0x66 0xf3 0xef 0xd8 } } } ; int i ; unsigned char tmp [ 16 ] ; hash_state md ; for ( i = 0 ; i < ( int ) ( sizeof ( tests ) / sizeof ( tests [ 0 ] ) ) ; i ++ ) { md2_init ( & md ) ; md2_process ( & md , ( unsigned char * ) tests [ i ] . msg , ( unsigned long ) XSTRLEN ( tests [ i ] . msg ) ) ; md2_done ( & md , tmp ) ; if ( compare_testvector ( tmp , sizeof ( tmp ) , tests [ i ] . hash , sizeof ( tests [ i ] . hash ) , "MD2" , i ) ) { return CRYPT_FAIL_TESTVECTOR ; } } return CRYPT_OK ; } 