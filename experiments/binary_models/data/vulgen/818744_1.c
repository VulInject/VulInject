OM_uint32 gss_add_cred ( minor_status , input_cred_handle , desired_name , desired_mech , cred_usage , initiator_time_req , acceptor_time_req , output_cred_handle , actual_mechs , initiator_time_rec , acceptor_time_rec ) OM_uint32 * minor_status ; const gss_cred_id_t input_cred_handle ; const gss_name_t desired_name ; const gss_OID desired_mech ; gss_cred_usage_t cred_usage ; OM_uint32 initiator_time_req ; OM_uint32 acceptor_time_req ; gss_cred_id_t * output_cred_handle ; gss_OID_set * actual_mechs ; OM_uint32 * initiator_time_rec ; OM_uint32 * acceptor_time_rec ; { OM_uint32 status , time_req , time_rec , temp_minor_status ; gss_mechanism mech ; gss_union_name_t union_name = NULL ; gss_union_cred_t union_cred , new_union_cred ; gss_name_t internal_name = GSS_C_NO_NAME ; gss_name_t allocated_name = GSS_C_NO_NAME ; gss_cred_id_t cred = NULL ; gss_OID new_mechs_array = NULL ; gss_cred_id_t * new_cred_array = NULL ; status = val_add_cred_args ( minor_status , input_cred_handle , desired_name , desired_mech , cred_usage , initiator_time_req , acceptor_time_req , output_cred_handle , actual_mechs , initiator_time_rec , acceptor_time_rec ) ; if ( status != GSS_S_COMPLETE ) { return ( status ) ; } mech = __gss_get_mechanism ( desired_mech ) ; if ( ! mech ) { return ( GSS_S_BAD_MECH ) ; } if ( ! mech -> gss_acquire_cred ) { return ( GSS_S_UNAVAILABLE ) ; } if ( input_cred_handle == GSS_C_NO_CREDENTIAL ) { union_cred = malloc ( sizeof ( gss_union_cred_desc ) ) ; if ( union_cred == NULL ) { return ( GSS_S_FAILURE ) ; } ( void ) memset ( union_cred , 0 , sizeof ( gss_union_cred_desc ) ) ; } else { union_cred = ( gss_union_cred_t ) input_cred_handle ; if ( __gss_get_mechanism_cred ( union_cred , desired_mech ) != GSS_C_NO_CREDENTIAL ) { status = GSS_S_DUPLICATE_ELEMENT ; errout } if ( desired_name == GSS_C_NO_NAME ) { if ( gss_import_name ( minor_status , & union_cred -> auxinfo . name , union_cred -> auxinfo . name_type , & allocated_name ) == GSS_S_COMPLETE && ( gss_canonicalize_name ( minor_status , allocated_name , & mech -> mech_type , NULL ) == GSS_S_COMPLETE ) ) { internal_name = allocated_name ; } } } if ( desired_name != GSS_C_NO_NAME ) { union_name = ( gss_union_name_t ) desired_name ; if ( union_name -> mech_type && g_OID_equal ( union_name -> mech_type , & mech -> mech_type ) ) { internal_name = union_name -> mech_name ; } else { if ( __gss_import_internal_name ( minor_status , & mech -> mech_type , union_name , & allocated_name ) != GSS_S_COMPLETE ) { status = GSS_S_BAD_NAME ; errout } internal_name = allocated_name ; } } if ( cred_usage == GSS_C_ACCEPT ) { time_req = acceptor_time_req ; } if ( cred_usage == GSS_C_INITIATE ) { time_req = initiator_time_req ; } if ( cred_usage == GSS_C_BOTH ) { time_req = ( acceptor_time_req > initiator_time_req ) ?acceptor_time_req : initiator_time_req ; } else { time_req = 0 ; } status = mech -> gss_acquire_cred ( mech -> context , minor_status , internal_name , time_req , GSS_C_NULL_OID_SET , cred_usage , & cred , NULL , & time_rec ) ; if ( status != GSS_S_COMPLETE ) { map_error ( minor_status , mech ) ; errout } if ( union_cred -> auxinfo . creation_time == 0 ) { union_cred -> auxinfo . creation_time = time ( NULL ) ; union_cred -> auxinfo . time_rec = time_rec ; union_cred -> auxinfo . cred_usage = cred_usage ; if ( internal_name != GSS_C_NO_NAME ) { if ( ( status = mech -> gss_display_name ( mech -> context , & temp_minor_status , internal_name , & union_cred -> auxinfo . name , & union_cred -> auxinfo . name_type ) ) != GSS_S_COMPLETE ) { errout } } } new_mechs_array = ( gss_OID ) malloc ( sizeof ( gss_OID_desc ) * ( union_cred -> count + 1 ) ) ; new_cred_array = ( gss_cred_id_t * ) malloc ( sizeof ( gss_cred_id_t ) * ( union_cred -> count + 1 ) ) ; if ( ! new_mechs_array || ! new_cred_array ) { status = GSS_S_FAILURE ; errout } if ( acceptor_time_rec ) { if ( cred_usage == GSS_C_ACCEPT || cred_usage == GSS_C_BOTH ) { * acceptor_time_rec = time_rec ; } } if ( initiator_time_rec ) { if ( cred_usage == GSS_C_INITIATE || cred_usage == GSS_C_BOTH ) { * initiator_time_rec = time_rec ; } } ( void ) memcpy ( new_mechs_array , union_cred -> mechs_array , sizeof ( gss_OID_desc ) * union_cred -> count ) ; ( void ) memcpy ( new_cred_array , union_cred -> cred_array , sizeof ( gss_cred_id_t ) * union_cred -> count ) ; new_cred_array [ union_cred -> count ] = cred ; if ( ( new_mechs_array [ union_cred -> count ] . elements = malloc ( mech -> mech_type . length ) ) == NULL ) { errout } g_OID_copy ( & new_mechs_array [ union_cred -> count ] , & mech -> mech_type ) ; if ( actual_mechs ) { * actual_mechs = create_actual_mechs ( new_mechs_array , union_cred -> count + 1 ) ; if ( * actual_mechs == NULL ) { free ( new_mechs_array [ union_cred -> count ] . elements ) ; errout } } if ( output_cred_handle == NULL ) { free ( union_cred -> mechs_array ) ; free ( union_cred -> cred_array ) ; new_union_cred = union_cred ; } else { new_union_cred = malloc ( sizeof ( gss_union_cred_desc ) ) ; * new_union_cred = * union_cred ; * output_cred_handle = ( gss_cred_id_t ) new_union_cred ; } new_union_cred -> mechs_array = new_mechs_array ; new_union_cred -> cred_array = new_cred_array ; new_union_cred -> count ++ ; if ( allocated_name ) { ( void ) __gss_release_internal_name ( & temp_minor_status , & mech -> mech_type , & allocated_name ) ; } return ( GSS_S_COMPLETE ) ; errout if ( new_mechs_array ) { free ( new_mechs_array ) ; } if ( new_cred_array ) { free ( new_cred_array ) ; } if ( cred != NULL && mech -> gss_release_cred ) { mech -> gss_release_cred ( mech -> context , & temp_minor_status , & cred ) ; } if ( allocated_name ) { ( void ) __gss_release_internal_name ( & temp_minor_status , & mech -> mech_type , & allocated_name ) ; } if ( input_cred_handle == GSS_C_NO_CREDENTIAL && union_cred ) { if ( union_cred -> auxinfo . name . value ) { free ( union_cred -> auxinfo . name . value ) ; } free ( union_cred ) ; } return ( status ) ; } 