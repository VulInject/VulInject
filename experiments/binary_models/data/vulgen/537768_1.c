static int qsv_frames_derive_to ( AVHWFramesContext * dst_ctx , AVHWFramesContext * src_ctx , int flags ) { QSVFramesContext * s = dst_ctx -> internal -> priv ; AVQSVFramesContext * dst_hwctx = dst_ctx -> hwctx ; int i ; if ( src_ctx -> initial_pool_size == 0 ) { av_log ( dst_ctx , AV_LOG_ERROR , "Only fixed-size pools can be " "mapped to QSV frames.\n" ) ; return AVERROR ( EINVAL ) ; } switch ( src_ctx -> device_ctx -> type ) { case AV_HWDEVICE_TYPE_VAAPI : { AVVAAPIFramesContext * src_hwctx = src_ctx -> hwctx ; s -> handle_pairs_internal = av_calloc ( src_ctx -> initial_pool_size , sizeof ( * s -> handle_pairs_internal ) ) ; if ( ! s -> handle_pairs_internal ) { return AVERROR ( ENOMEM ) ; } s -> surfaces_internal = av_calloc ( src_hwctx -> nb_surfaces , sizeof ( * s -> surfaces_internal ) ) ; if ( ! s -> surfaces_internal ) { return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < src_hwctx -> nb_surfaces ; i ++ ) { qsv_init_surface ( dst_ctx , & s -> surfaces_internal [ i ] ) ; s -> handle_pairs_internal [ i ] . first = src_hwctx -> surface_ids + i ; s -> handle_pairs_internal [ i ] . second = ( mfxMemId ) MFX_INFINITE ; s -> surfaces_internal [ i ] . Data . MemId = ( mfxMemId ) & s -> handle_pairs_internal [ i ] ; } dst_hwctx -> nb_surfaces = src_hwctx -> nb_surfaces ; } break ; case AV_HWDEVICE_TYPE_D3D11VA : { AVD3D11VAFramesContext * src_hwctx = src_ctx -> hwctx ; s -> handle_pairs_internal = av_calloc ( src_ctx -> initial_pool_size , sizeof ( * s -> handle_pairs_internal ) ) ; if ( ! s -> handle_pairs_internal ) { return AVERROR ( ENOMEM ) ; } s -> surfaces_internal = av_calloc ( src_ctx -> initial_pool_size , sizeof ( * s -> surfaces_internal ) ) ; if ( ! s -> surfaces_internal ) { return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < src_ctx -> initial_pool_size ; i ++ ) { qsv_init_surface ( dst_ctx , & s -> surfaces_internal [ i ] ) ; s -> handle_pairs_internal [ i ] . first = ( mfxMemId ) src_hwctx -> texture_infos [ i ] . texture ; if ( src_hwctx -> BindFlags & D3D11_BIND_RENDER_TARGET ) { s -> handle_pairs_internal [ i ] . second = ( mfxMemId ) MFX_INFINITE ; } else { s -> handle_pairs_internal [ i ] . second = ( mfxMemId ) src_hwctx -> texture_infos [ i ] . index ; } s -> surfaces_internal [ i ] . Data . MemId = ( mfxMemId ) & s -> handle_pairs_internal [ i ] ; } dst_hwctx -> nb_surfaces = src_ctx -> initial_pool_size ; if ( src_hwctx -> BindFlags & D3D11_BIND_RENDER_TARGET ) { dst_hwctx -> frame_type |= MFX_MEMTYPE_VIDEO_MEMORY_PROCESSOR_TARGET ; } else { dst_hwctx -> frame_type |= MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET ; } } break ; case AV_HWDEVICE_TYPE_DXVA2 : { AVDXVA2FramesContext * src_hwctx = src_ctx -> hwctx ; s -> handle_pairs_internal = av_calloc ( src_ctx -> initial_pool_size , sizeof ( * s -> handle_pairs_internal ) ) ; if ( ! s -> handle_pairs_internal ) { return AVERROR ( ENOMEM ) ; } s -> surfaces_internal = av_calloc ( src_hwctx -> nb_surfaces , sizeof ( * s -> surfaces_internal ) ) ; if ( ! s -> surfaces_internal ) { return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < src_hwctx -> nb_surfaces ; i ++ ) { qsv_init_surface ( dst_ctx , & s -> surfaces_internal [ i ] ) ; s -> handle_pairs_internal [ i ] . first = ( mfxMemId ) src_hwctx -> surfaces [ i ] ; s -> handle_pairs_internal [ i ] . second = ( mfxMemId ) MFX_INFINITE ; s -> surfaces_internal [ i ] . Data . MemId = ( mfxMemId ) & s -> handle_pairs_internal [ i ] ; } dst_hwctx -> nb_surfaces = src_hwctx -> nb_surfaces ; if ( src_hwctx -> surface_type == DXVA2_VideoProcessorRenderTarget ) { dst_hwctx -> frame_type = MFX_MEMTYPE_VIDEO_MEMORY_PROCESSOR_TARGET ; } else { dst_hwctx -> frame_type = MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET ; } } break ; default : return AVERROR ( ENOSYS ) ; } dst_hwctx -> surfaces = s -> surfaces_internal ; return 0 ; } 