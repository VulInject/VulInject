void dlm_copy_master_names ( struct dlm_ls * ls , char * inbuf , int inlen , char * outbuf , int outlen , int nodeid ) { struct list_head * list ; struct dlm_rsb * r ; int offset = 0 , dir_nodeid ; __be16 be_namelen ; down_read ( & ls -> ls_root_sem ) ; if ( inlen > 1 ) { r = find_rsb_root ( ls , inbuf , inlen ) ; if ( ! r ) { inbuf [ inlen - 1 ] = '\0' ; log_error ( ls , "copy_master_names from %d start %d %s" , nodeid , inlen , inbuf ) ; out } list = r -> res_root_list . next ; } else { list = ls -> ls_root_list . next ; } for ( offset = 0 ; list != & ls -> ls_root_list ; list = list -> next ) { r = list_entry ( list , dlm_rsb , res_root_list ) ; if ( r -> res_nodeid ) { continue ; } dir_nodeid = dlm_dir_nodeid ( r ) ; if ( dir_nodeid != nodeid ) { continue ; } if ( offset + sizeof ( uint16_t ) * 2 + r -> res_length > outlen ) { memcpy ( outbuf + offset , & be_namelen , sizeof ( __be16 ) ) ; offset += sizeof ( __be16 ) ; ls -> ls_recover_dir_sent_msg ++ ; out } be_namelen = cpu_to_be16 ( r -> res_length ) ; memcpy ( outbuf + offset , & be_namelen , sizeof ( __be16 ) ) ; offset += sizeof ( __be16 ) ; memcpy ( outbuf + offset , r -> res_name , r -> res_length ) ; offset += r -> res_length ; ls -> ls_recover_dir_sent_res ++ ; } if ( ( list == & ls -> ls_root_list ) && ( offset + sizeof ( uint16_t ) <= outlen ) ) { be_namelen = cpu_to_be16 ( 0xFFFF ) ; memcpy ( outbuf + offset , & be_namelen , sizeof ( __be16 ) ) ; offset += sizeof ( __be16 ) ; ls -> ls_recover_dir_sent_msg ++ ; } out up_read ( & ls -> ls_root_sem ) ; } 