int ret_value ; int not_parsed ; dmq_node_t * dmq_node = NULL ; worker = & dmq_workers [ id ] ; for ( ; ; ) { if ( dmq_worker_usleep <= 0 ) { LM_DBG ( "dmq_worker [%d %d] getting lock\n" , id , my_pid ( ) ) ; lock_get ( & worker -> lock ) ; LM_DBG ( "dmq_worker [%d %d] lock acquired\n" , id , my_pid ( ) ) ; } else { sleep_us ( dmq_worker_usleep ) ; } cfg_update ( ) ; while ( job_queue_size ( worker -> queue ) > 0 ) { current_job = job_queue_pop ( worker -> queue ) ; if ( current_job ) { if ( current_job -> msg -> from -> parsed ) { not_parsed = 0 ; } else { not_parsed = 1 ; } if ( parse_from_header ( current_job -> msg ) < 0 ) { LM_ERR ( "bad sip message or missing From hdr\n" ) ; } else { dmq_node = find_dmq_node_uri ( dmq_node_list , & ( ( to_body * ) current_job -> msg -> from -> parsed ) -> uri ) ; } ret_value = current_job -> f ( current_job -> msg , & peer_response , dmq_node ) ; if ( ret_value < 0 ) { LM_ERR ( "running job failed\n" ) ; nextjob } if ( peer_response . body . s ) { if ( set_reply_body ( current_job -> msg , & peer_response . body , & peer_response . content_type ) < 0 ) { LM_ERR ( "error adding lumps\n" ) ; nextjob } } if ( peer_response . resp_code > 0 && peer_response . reason . s != NULL && peer_response . reason . len > 0 ) { if ( slb . freply ( current_job -> msg , peer_response . resp_code , & peer_response . reason ) < 0 ) { LM_ERR ( "error sending reply\n" ) ; } else { LM_DBG ( "done sending reply\n" ) ; } } else { LM_WARN ( "no reply sent\n" ) ; } worker -> jobs_processed ++ ; nextjob if ( peer_response . body . s ) { del_nonshm_lump_rpl ( & current_job -> msg -> reply_lump ) ; pkg_free ( peer_response . body . s ) ; } if ( ( current_job -> msg -> from -> parsed ) && ( not_parsed ) ) { free_to ( current_job -> msg -> from -> parsed ) ; } shm_free ( current_job -> msg ) ; shm_free ( current_job ) ; } } } 