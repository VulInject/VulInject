parse_branch ( , , , , , ) { bin_tree_t * tree , * expr ; re_dfa_t * dfa = preg -> buffer ; tree = parse_expression ( regexp , preg , token , syntax , nest , err ) ; if ( __glibc_unlikely ( * err != REG_NOERROR && tree == NULL ) ) { return NULL ; } while ( token -> type != OP_ALT && token -> type != END_OF_RE && ( nest == 0 || token -> type != OP_CLOSE_SUBEXP ) ) { expr = parse_expression ( regexp , preg , token , syntax , nest , err ) ; if ( __glibc_unlikely ( * err != REG_NOERROR && expr == NULL ) ) { return NULL ; } if ( tree != NULL && expr != NULL ) { bin_tree_t * newtree = create_tree ( dfa , tree , expr , CONCAT ) ; if ( newtree == NULL ) { postorder ( expr , free_tree , NULL ) ; postorder ( tree , free_tree , NULL ) ; * err = REG_ESPACE ; return NULL ; } tree = newtree ; } if ( tree == NULL ) { tree = expr ; } } return tree ; } 