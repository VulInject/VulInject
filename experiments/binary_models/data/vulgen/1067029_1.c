int pool_knl_connection_alloc ( pool_conf_t * conf , int oflags ) { pool_knl_connection_t * prov ; if ( ( prov = malloc ( sizeof ( pool_knl_connection_t ) ) ) == NULL ) { pool_seterror ( POE_SYSTEM ) ; return ( PO_FAIL ) ; } ( void ) memset ( prov , 0 , sizeof ( pool_knl_connection_t ) ) ; prov -> pc_name = strdup ( "kernel" ) ; prov -> pc_store_type = KERNEL_DATA_STORE ; prov -> pc_oflags = oflags ; prov -> pc_close = pool_knl_close ; prov -> pc_validate = pool_knl_validate ; prov -> pc_commit = pool_knl_commit ; prov -> pc_export = pool_knl_export ; prov -> pc_rollback = pool_knl_rollback ; prov -> pc_exec_query = pool_knl_exec_query ; prov -> pc_elem_create = pool_knl_elem_create ; prov -> pc_remove = pool_knl_remove ; prov -> pc_res_xxfer = pool_knl_res_xtransfer ; prov -> pc_get_binding = pool_knl_get_binding ; prov -> pc_set_binding = pool_knl_set_binding ; prov -> pc_get_resource_binding = pool_knl_get_resource_binding ; conf -> pc_prov = ( pool_connection_t * ) prov ; if ( oflags & PO_RDWR ) { if ( ( prov -> pkc_fd = blocking_open ( pool_dynamic_location ( ) , O_RDWR ) ) < 0 ) { free ( prov ) ; conf -> pc_prov = NULL ; pool_seterror ( POE_SYSTEM ) ; return ( PO_FAIL ) ; } } else { if ( ( prov -> pkc_fd = open ( pool_info_location , O_RDWR ) ) < 0 ) { free ( prov ) ; conf -> pc_prov = NULL ; pool_seterror ( POE_SYSTEM ) ; return ( PO_FAIL ) ; } } if ( ( prov -> pkc_elements = dict_new ( ( int ( * ) ( const void * , const void * ) ) pool_elem_compare , ( uint64_t ( * ) ( const void * ) ) hash_id ) ) == NULL ) { ( void ) close ( prov -> pkc_fd ) ; free ( prov ) ; conf -> pc_prov = NULL ; pool_seterror ( POE_SYSTEM ) ; return ( PO_FAIL ) ; } if ( ( prov -> pkc_leaks = dict_new ( NULL , NULL ) ) == NULL ) { dict_free ( & prov -> pkc_elements ) ; ( void ) close ( prov -> pkc_fd ) ; free ( prov ) ; conf -> pc_prov = NULL ; pool_seterror ( POE_SYSTEM ) ; return ( PO_FAIL ) ; } if ( ( prov -> pkc_log = log_alloc ( conf ) ) == NULL ) { dict_free ( & prov -> pkc_leaks ) ; dict_free ( & prov -> pkc_elements ) ; ( void ) close ( prov -> pkc_fd ) ; free ( prov ) ; conf -> pc_prov = NULL ; return ( PO_FAIL ) ; } conf -> pc_state = POF_VALID ; if ( pool_knl_update ( conf , NULL ) != PO_SUCCESS ) { dict_free ( & prov -> pkc_leaks ) ; dict_free ( & prov -> pkc_elements ) ; ( void ) close ( prov -> pkc_fd ) ; free ( prov ) ; conf -> pc_prov = NULL ; conf -> pc_state = POF_INVALID ; return ( PO_FAIL ) ; } return ( PO_SUCCESS ) ; } 