void mk_dirhtml_cb_body_rows ( struct mk_stream_input * in ) { int len ; char tmp [ 16 ] ; struct mk_stream * stream = in -> stream ; struct mk_dirhtml_request * req = stream -> context ; void * cb_ok ( struct mk_stream_input * ) NULL ; if ( req -> iov_entry ) { req -> iov_entry = NULL ; } if ( req -> toc_idx >= req -> toc_len ) { if ( req -> chunked ) { len = snprintf ( tmp , sizeof ( tmp ) , "%x\r\n" , ( int ) req -> iov_footer -> total_len ) ; mk_stream_in_raw ( req -> stream , NULL , tmp , len , NULL , NULL ) ; cb_ok = NULL ; } else { cb_ok = mk_dirhtml_cb_complete ; } mk_stream_in_iov ( req -> stream , NULL , req -> iov_footer , NULL , NULL ) ; if ( req -> chunked ) { mk_stream_in_raw ( req -> stream , NULL , "\r\n0\r\n\r\n" , 7 , NULL , mk_dirhtml_cb_complete ) ; } return ; } req -> iov_entry = enqueue_row ( req -> toc_idx , req ) ; if ( req -> chunked ) { len = snprintf ( tmp , sizeof ( tmp ) , "%x\r\n" , ( int ) req -> iov_entry -> total_len ) ; mk_stream_in_raw ( req -> stream , NULL , tmp , len , NULL , NULL ) ; cb_ok = NULL ; } else { cb_ok = mk_dirhtml_cb_body_rows ; } mk_stream_in_iov ( req -> stream , NULL , req -> iov_entry , NULL , cb_ok ) ; if ( req -> chunked ) { mk_stream_in_raw ( req -> stream , NULL , "\r\n" , 2 , mk_dirhtml_cb_chunk_body_rows , NULL ) ; } req -> toc_idx ++ ; } 