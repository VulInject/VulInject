static ssize_t ta_if_load_debugfs_write ( struct file * fp , const char * buf , size_t len , loff_t * off ) { uint32_t ta_type = 0 ; uint32_t ta_bin_len = 0 ; uint8_t * ta_bin = NULL ; uint32_t copy_pos = 0 ; int ret = 0 ; struct amdgpu_device * adev = ( amdgpu_device * ) file_inode ( fp ) -> i_private ; struct psp_context * psp = & adev -> psp ; struct ta_context * context = NULL ; if ( ! buf ) { return - EINVAL ; } ret = copy_from_user ( ( void * ) & ta_type , & buf [ copy_pos ] , sizeof ( uint32_t ) ) ; if ( ret || ( ! is_ta_type_valid ( ta_type ) ) ) { return - EFAULT ; } copy_pos += sizeof ( uint32_t ) ; ret = copy_from_user ( ( void * ) & ta_bin_len , & buf [ copy_pos ] , sizeof ( uint32_t ) ) ; if ( ret ) { return - EFAULT ; } copy_pos += sizeof ( uint32_t ) ; ta_bin = kzalloc ( ta_bin_len , GFP_KERNEL ) ; if ( copy_from_user ( ( void * ) ta_bin , & buf [ copy_pos ] , ta_bin_len ) ) { ret = - EFAULT ; err_free_bin } set_ta_context_funcs ( psp , ta_type , & context ) ; if ( ! psp -> ta_funcs || ! psp -> ta_funcs -> fn_ta_terminate ) { dev_err ( adev -> dev , "Unsupported function to terminate TA\n" ) ; ret = - EOPNOTSUPP ; err_free_bin } if ( ! context -> mem_context . shared_buf ) { ret = psp_ta_init_shared_buf ( psp , & context -> mem_context ) ; if ( ret ) { ret = - ENOMEM ; err_free_bin } } ret = psp_fn_ta_terminate ( psp ) ; if ( ret || context -> resp_status ) { dev_err ( adev -> dev , "Failed to unload embedded TA (%d) and status (0x%X)\n" , ret , context -> resp_status ) ; if ( ! ret ) { ret = - EINVAL ; } err_free_ta_shared_buf } context -> ta_type = ta_type ; context -> bin_desc . fw_version = get_bin_version ( ta_bin ) ; context -> bin_desc . size_bytes = ta_bin_len ; context -> bin_desc . start_addr = ta_bin ; if ( ! psp -> ta_funcs -> fn_ta_initialize ) { dev_err ( adev -> dev , "Unsupported function to initialize TA\n" ) ; ret = - EOPNOTSUPP ; err_free_ta_shared_buf } ret = psp_fn_ta_initialize ( psp ) ; if ( ret || context -> resp_status ) { dev_err ( adev -> dev , "Failed to load TA via debugfs (%d) and status (0x%X)\n" , ret , context -> resp_status ) ; if ( ! ret ) { ret = - EINVAL ; } err_free_ta_shared_buf } if ( copy_to_user ( ( char * ) buf , ( void * ) & context -> session_id , sizeof ( uint32_t ) ) ) { ret = - EFAULT ; } err_free_ta_shared_buf if ( ret && context -> mem_context . shared_buf ) { psp_ta_free_shared_buf ( & context -> mem_context ) ; } err_free_bin kfree ( ta_bin ) ; return ret ; } 