int sbdp_disconnect_board ( sbdp_handle_t * hp ) { sbbc_msg_t request , * reqp = & request ; sbbc_msg_t response , * resp = & response ; int rv = 0 ; int board , node ; sbd_error_t * sep ; static fn_t f = "sbdp_disconnect_board" ; SBDP_DBG_FUNC ( "%s\n" , f ) ; board = hp -> h_board ; node = hp -> h_wnode ; sep = hp -> h_err ; SBDP_DBG_MISC ( "sbdp_disconnect_board: board = %d node = %d\n" , board , node ) ; if ( hp -> h_opts != NULL && hp -> h_opts -> copts != NULL ) { sbdp_set_err ( sep , ESBD_INVAL_OPT , hp -> h_opts -> copts ) ; return ( - 1 ) ; } if ( sbdp_detach_bd ( node , board , sep ) ) { sbdp_attach_bd ( node , board ) ; SBDP_DBG_ALL ( "failed to detach board %d\n" , board ) ; return ( - 1 ) ; } rv = prom_tree_update ( sg_detach_board , hp ) ; if ( rv == - 1 ) { sbdp_attach_bd ( node , board ) ; SBDP_DBG_MISC ( "failed to prom detach board: rv = %d\n" , rv ) ; sbdp_set_err ( sep , ESGT_PROM_DETACH , NULL ) ; return ( rv ) ; } SBDP_DBG_MISC ( "prom detach worked\n" ) ; sbdp_init_msg_pkt ( reqp , DR_MBOX_UNCLAIM , 0 , ( caddr_t ) NULL ) ; reqp -> msg_data [ 0 ] = node ; reqp -> msg_data [ 1 ] = board ; sbdp_init_msg_pkt ( resp , DR_MBOX_UNCLAIM , 0 , ( caddr_t ) NULL ) ; rv = sbbc_mbox_request_response ( reqp , resp , sbdp_mbox_wait ) ; if ( rv != 0 || ( rv = resp -> msg_status != SG_MBOX_STATUS_SUCCESS ) ) { SBDP_DBG_MISC ( "failed to unclaim board: rv = %d\n" , rv ) ; sbdp_set_err ( sep , sbdp_sc_err_translation ( resp -> msg_status ) , NULL ) ; ( void ) prom_tree_update ( sg_attach_board , hp ) ; } return ( rv ) ; } 