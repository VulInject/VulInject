__be32 vgda_psn [ 2 ] ; char reserved36 [ 10 ] ; __be16 pp_size ; char reserved46 [ 12 ] ; __be16 version ; vgda { __be32 secs ; __be32 usec ; char reserved8 [ 16 ] ; __be16 numlvs ; __be16 maxlvs ; __be16 pp_size ; __be16 numpvs ; __be16 total_vgdas ; __be16 vgda_size ; } lvd { __be16 lv_ix ; __be16 res2 ; __be16 res4 ; __be16 maxsize ; __be16 lv_state ; __be16 mirror ; __be16 mirror_policy ; __be16 num_lps ; __be16 res10 [ 8 ] ; } lvname { char name [ 64 ] ; } ppe { __be16 lv_ix ; unsigned short res2 ; unsigned short res4 ; __be16 lp_ix ; unsigned short res8 [ 12 ] ; } pvd { char reserved0 [ 16 ] ; __be16 pp_count ; char reserved18 [ 2 ] ; __be32 psn_part1 ; char reserved24 [ 8 ] ; struct ppe ppe [ 1016 ] ; } static size_t read_lba ( struct parsed_partitions * state , u64 lba , u8 * buffer , size_t count ) { size_t totalreadcount = 0 ; while ( count ) { int copied = 512 ; Sector sect ; unsigned char * data = read_part_sector ( state , lba ++ , & sect ) ; if ( ! data ) { break ; } if ( copied > count ) { copied = count ; } memcpy ( buffer , data , copied ) ; put_dev_sector ( sect ) ; buffer += copied ; totalreadcount += copied ; count -= copied ; } return totalreadcount ; } 