static netdev_tx_t ftgmac100_hard_start_xmit ( struct sk_buff * skb , struct net_device * netdev ) { struct ftgmac100 * priv = netdev_priv ( netdev ) ; struct ftgmac100_txdes * txdes , * first ; unsigned int pointer , nfrags , len , i , j ; u32 f_ctl_stat , ctl_stat , csum_vlan ; dma_addr_t map ; if ( eth_skb_pad ( skb ) ) { netdev -> stats . tx_dropped ++ ; return NETDEV_TX_OK ; } if ( unlikely ( skb -> len > MAX_PKT_SIZE ) ) { if ( net_ratelimit ( ) ) { netdev_dbg ( netdev , "tx packet too big\n" ) ; } drop } nfrags = skb_shinfo ( skb ) -> nr_frags ; csum_vlan = 0 ; if ( skb -> ip_summed == CHECKSUM_PARTIAL && ! ftgmac100_prep_tx_csum ( skb , & csum_vlan ) ) { drop } if ( skb_vlan_tag_present ( skb ) ) { csum_vlan |= FTGMAC100_TXDES1_INS_VLANTAG ; csum_vlan |= skb_vlan_tag_get ( skb ) & 0xffff ; } len = skb_headlen ( skb ) ; map = dma_map_single ( priv -> dev , skb -> data , len , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( priv -> dev , map ) ) { if ( net_ratelimit ( ) ) { netdev_err ( netdev , "map tx packet head failed\n" ) ; } drop } pointer = priv -> tx_pointer ; txdes = first = & priv -> txdes [ pointer ] ; priv -> tx_skbs [ pointer ] = skb ; f_ctl_stat = ftgmac100_base_tx_ctlstat ( priv , pointer ) ; f_ctl_stat |= FTGMAC100_TXDES0_TXDMA_OWN ; f_ctl_stat |= FTGMAC100_TXDES0_TXBUF_SIZE ( len ) ; f_ctl_stat |= FTGMAC100_TXDES0_FTS ; txdes -> txdes3 = cpu_to_le32 ( map ) ; txdes -> txdes1 = cpu_to_le32 ( csum_vlan ) ; pointer = ftgmac100_next_tx_pointer ( priv , pointer ) ; for ( i = 0 ; i < nfrags ; i ++ ) { skb_frag_t * frag = & skb_shinfo ( skb ) -> frags [ i ] ; len = skb_frag_size ( frag ) ; map = skb_frag_dma_map ( priv -> dev , frag , 0 , len , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( priv -> dev , map ) ) { dma_err } priv -> tx_skbs [ pointer ] = skb ; txdes = & priv -> txdes [ pointer ] ; ctl_stat = ftgmac100_base_tx_ctlstat ( priv , pointer ) ; ctl_stat |= FTGMAC100_TXDES0_TXDMA_OWN ; ctl_stat |= FTGMAC100_TXDES0_TXBUF_SIZE ( len ) ; if ( i == ( nfrags - 1 ) ) { ctl_stat |= FTGMAC100_TXDES0_LTS ; } txdes -> txdes0 = cpu_to_le32 ( ctl_stat ) ; txdes -> txdes1 = 0 ; txdes -> txdes3 = cpu_to_le32 ( map ) ; pointer = ftgmac100_next_tx_pointer ( priv , pointer ) ; } dma_wmb ( ) ; first -> txdes0 = cpu_to_le32 ( f_ctl_stat ) ; priv -> tx_pointer = pointer ; if ( unlikely ( ftgmac100_tx_buf_avail ( priv ) < TX_THRESHOLD ) ) { netif_stop_queue ( netdev ) ; smp_mb ( ) ; if ( ftgmac100_tx_buf_avail ( priv ) >= TX_THRESHOLD ) { netif_wake_queue ( netdev ) ; } } iowrite32 ( 1 , priv -> base + FTGMAC100_OFFSET_NPTXPD ) ; return NETDEV_TX_OK ; dma_err if ( net_ratelimit ( ) ) { netdev_err ( netdev , "map tx fragment failed\n" ) ; } pointer = priv -> tx_pointer ; ftgmac100_free_tx_packet ( priv , pointer , skb , first , f_ctl_stat ) ; first -> txdes0 = cpu_to_le32 ( f_ctl_stat & priv -> txdes0_edotr_mask ) ; for ( j = 0 ; j < i ; j ++ ) { pointer = ftgmac100_next_tx_pointer ( priv , pointer ) ; txdes = & priv -> txdes [ pointer ] ; ctl_stat = le32_to_cpu ( txdes -> txdes0 ) ; ftgmac100_free_tx_packet ( priv , pointer , skb , txdes , ctl_stat ) ; txdes -> txdes0 = cpu_to_le32 ( ctl_stat & priv -> txdes0_edotr_mask ) ; } drop dev_kfree_skb_any ( skb ) ; netdev -> stats . tx_dropped ++ ; return NETDEV_TX_OK ; } 