static int lov_iocontrol ( unsigned int cmd , struct obd_export * exp , int len , void * karg , void __user * uarg ) { struct obd_device * obddev = class_exp2obd ( exp ) ; struct lov_obd * lov = & obddev -> u . lov ; int i = 0 , rc = 0 , count = lov -> desc . ld_tgt_count ; struct obd_uuid * uuidp ; switch ( cmd ) { case IOC_OBD_STATFS : { struct obd_ioctl_data * data = karg ; struct obd_device * osc_obd ; struct obd_statfs stat_buf = { 0 } ; __u32 index ; __u32 flags ; memcpy ( & index , data -> ioc_inlbuf2 , sizeof ( __u32 ) ) ; if ( ! lov -> lov_tgts [ index ] ) { return - EAGAIN ; } if ( ! lov -> lov_tgts [ index ] -> ltd_active ) { return - ENODATA ; } osc_obd = class_exp2obd ( lov -> lov_tgts [ index ] -> ltd_exp ) ; if ( ! osc_obd ) { return - EINVAL ; } if ( copy_to_user ( data -> ioc_pbuf2 , obd2cli_tgt ( osc_obd ) , min_t ( , , ) ) ) { return - EFAULT ; } memcpy ( & flags , data -> ioc_inlbuf1 , sizeof ( __u32 ) ) ; flags = flags & LL_STATFS_NODELAY ?OBD_STATFS_NODELAY : 0 ; rc = obd_statfs ( NULL , lov -> lov_tgts [ index ] -> ltd_exp , & stat_buf , cfs_time_shift_64 ( - OBD_STATFS_CACHE_SECONDS ) , flags ) ; if ( rc ) { return rc ; } if ( copy_to_user ( data -> ioc_pbuf1 , & stat_buf , min_t ( , , ) ) ) { return - EFAULT ; } break ; } case OBD_IOC_LOV_GET_CONFIG : { struct obd_ioctl_data * data ; struct lov_desc * desc ; char * buf = NULL ; __u32 * genp ; len = 0 ; if ( obd_ioctl_getdata ( & buf , & len , uarg ) ) { return - EINVAL ; } data = ( obd_ioctl_data * ) buf ; if ( sizeof ( * desc ) > data -> ioc_inllen1 ) { obd_ioctl_freedata ( buf , len ) ; return - EINVAL ; } if ( sizeof ( uuidp -> uuid ) * count > data -> ioc_inllen2 ) { obd_ioctl_freedata ( buf , len ) ; return - EINVAL ; } if ( sizeof ( __u32 ) * count > data -> ioc_inllen3 ) { obd_ioctl_freedata ( buf , len ) ; return - EINVAL ; } desc = ( lov_desc * ) data -> ioc_inlbuf1 ; memcpy ( desc , & lov -> desc , sizeof ( * desc ) ) ; uuidp = ( obd_uuid * ) data -> ioc_inlbuf2 ; genp = ( __u32 * ) data -> ioc_inlbuf3 ; for ( i = 0 ; i < count ; i ++ , uuidp ++ , genp ++ ) { if ( ! lov -> lov_tgts [ i ] ) { continue ; } * uuidp = lov -> lov_tgts [ i ] -> ltd_uuid ; * genp = lov -> lov_tgts [ i ] -> ltd_gen ; } if ( copy_to_user ( uarg , buf , len ) ) { rc = - EFAULT ; } obd_ioctl_freedata ( buf , len ) ; break ; } case OBD_IOC_QUOTACTL : { struct if_quotactl * qctl = karg ; struct lov_tgt_desc * tgt = NULL ; struct obd_quotactl * oqctl ; if ( qctl -> qc_valid == QC_OSTIDX ) { if ( count <= qctl -> qc_idx ) { return - EINVAL ; } tgt = lov -> lov_tgts [ qctl -> qc_idx ] ; if ( ! tgt || ! tgt -> ltd_exp ) { return - EINVAL ; } } if ( qctl -> qc_valid == QC_UUID ) { for ( i = 0 ; i < count ; i ++ ) { tgt = lov -> lov_tgts [ i ] ; if ( ! tgt || ! obd_uuid_equals ( & tgt -> ltd_uuid , & qctl -> obd_uuid ) ) { continue ; } if ( ! tgt -> ltd_exp ) { return - EINVAL ; } break ; } } else { return - EINVAL ; } if ( i >= count ) { return - EAGAIN ; } LASSERT ( tgt && tgt -> ltd_exp ) ; oqctl = kzalloc ( sizeof ( * oqctl ) , GFP_NOFS ) ; if ( ! oqctl ) { return - ENOMEM ; } QCTL_COPY ( oqctl , qctl ) ; rc = obd_quotactl ( tgt -> ltd_exp , oqctl ) ; if ( rc == 0 ) { QCTL_COPY ( qctl , oqctl ) ; qctl -> qc_valid = QC_OSTIDX ; qctl -> obd_uuid = tgt -> ltd_uuid ; } kfree ( oqctl ) ; break ; } default : { int set = 0 ; if ( count == 0 ) { return - ENOTTY ; } for ( i = 0 ; i < count ; i ++ ) { int err ; struct obd_device * osc_obd ; if ( ! lov -> lov_tgts [ i ] || ! lov -> lov_tgts [ i ] -> ltd_exp ) { continue ; } osc_obd = class_exp2obd ( lov -> lov_tgts [ i ] -> ltd_exp ) ; osc_obd -> obd_force = obddev -> obd_force ; err = obd_iocontrol ( cmd , lov -> lov_tgts [ i ] -> ltd_exp , len , karg , uarg ) ; if ( err ) { if ( lov -> lov_tgts [ i ] -> ltd_active ) { CDEBUG ( err == - ENOTTY ?D_IOCTL : D_WARNING , "iocontrol OSC %s on OST idx %d cmd %x: err = %d\n" , lov_uuid2str ( lov , i ) , i , cmd , err ) ; if ( ! rc ) { rc = err ; } } } else { set = 1 ; } } if ( ! set && ! rc ) { rc = - EIO ; } } } return rc ; } 