static int fwalk ( const char * path , int * fn ( const char * , const struct stat * , int ) , int depth , struct Var * vp ) { size_t n ; int rc ; int save_errno ; DIR * dirp ; char * subpath ; struct stat sb ; struct dirent * direntp ; vp -> level ++ ; if ( nocdstat ( path , & sb , vp , 0 ) < 0 ) { save_errno = errno ; if ( ( nocdstat ( path , & sb , vp , AT_SYMLINK_NOFOLLOW ) != - 1 ) && ( ( sb . st_mode & S_IFMT ) == S_IFLNK ) ) { errno = save_errno ; return * fn ( path , & sb , FTW_NS ) ; } else { errno = save_errno ; } return ( errno == EACCES ?* fn ( path , & sb , FTW_NS ) : - 1 ) ; } if ( ( sb . st_mode & S_IFMT ) != S_IFDIR ) { return ( * fn ( path , & sb , FTW_F ) ) ; } dirp = nocdopendir ( path , vp ) ; if ( dirp == NULL ) { return ( errno == EACCES ?* fn ( path , & sb , FTW_DNR ) : - 1 ) ; } rc = * fn ( path , & sb , FTW_D ) ; if ( rc != 0 ) { ( void ) closedir ( dirp ) ; return ( rc ) ; } while ( ( direntp = readdir ( dirp ) ) != NULL ) { long here ; if ( strcmp ( direntp -> d_name , "." ) == 0 || strcmp ( direntp -> d_name , ".." ) == 0 ) { continue ; } n = strlen ( path ) ; subpath = malloc ( n + strlen ( direntp -> d_name ) + 2 ) ; if ( subpath == 0 ) { ( void ) closedir ( dirp ) ; errno = ENOMEM ; return ( - 1 ) ; } ( void ) strcpy ( subpath , path ) ; if ( subpath [ 0 ] != '\0' && subpath [ n - 1 ] != '/' ) { subpath [ n ++ ] = '/' ; } ( void ) strlcpy ( & subpath [ n ] , direntp -> d_name , MAXNAMELEN ) ; if ( depth <= 1 ) { here = telldir ( dirp ) ; if ( closedir ( dirp ) < 0 ) { free ( subpath ) ; return ( - 1 ) ; } } rc = fwalk ( subpath , fn , depth - 1 , vp ) ; if ( rc != 0 ) { free ( subpath ) ; if ( depth > 1 ) { ( void ) closedir ( dirp ) ; } return ( rc ) ; } if ( depth <= 1 ) { dirp = nocdopendir ( path , vp ) ; seekdir ( dirp , here ) ; } free ( subpath ) ; } ( void ) closedir ( dirp ) ; return ( 0 ) ; } 