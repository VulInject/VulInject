void spdmem_sdram_decode ( struct spdmem_softc * sc , struct spdmem * s ) { const char * type ; int dimm_size , p_clk ; int num_banks , per_chip ; uint8_t rows , cols ; type = spdmem_basic_types [ s -> sm_type ] ; if ( s -> sm_data [ SPDMEM_SDR_SUPERSET ] == SPDMEM_SUPERSET_SDR_PEM ) { type = spdmem_superset_types [ SPDMEM_SUPERSET_SDR_PEM ] ; } if ( s -> sm_data [ SPDMEM_SDR_SUPERSET ] == SPDMEM_SUPERSET_ESDRAM ) { type = spdmem_superset_types [ SPDMEM_SUPERSET_ESDRAM ] ; } num_banks = s -> sm_data [ SPDMEM_SDR_BANKS ] ; per_chip = s -> sm_data [ SPDMEM_SDR_BANKS_PER_CHIP ] ; rows = s -> sm_data [ SPDMEM_SDR_ROWS ] & 0x0f ; cols = s -> sm_data [ SPDMEM_SDR_COLS ] & 0x0f ; dimm_size = ( 1 << ( rows + cols - 17 ) ) * num_banks * per_chip ; if ( dimm_size > 0 ) { if ( dimm_size < 1024 ) { printf ( " %dMB" , dimm_size ) ; } else { printf ( " %dGB" , dimm_size / 1024 ) ; } } printf ( " %s" , type ) ; if ( s -> sm_data [ SPDMEM_DDR_MOD_ATTRIB ] & SPDMEM_DDR_ATTRIB_REG ) { printf ( " registered" ) ; } if ( s -> sm_data [ SPDMEM_FPM_CONFIG ] < 8 ) { printf ( " %s" , spdmem_parity_types [ s -> sm_data [ SPDMEM_FPM_CONFIG ] ] ) ; } if ( s -> sm_len >= 128 ) { switch ( spdmem_read ( sc , SPDMEM_SDR_FREQUENCY ) ) { case SPDMEM_SDR_FREQ_100 : case SPDMEM_SDR_FREQ_133 : if ( s -> sm_data [ SPDMEM_SDR_CYCLE ] < 0x80 ) { p_clk = 133 ; } else { p_clk = 100 ; } break ; case SPDMEM_SDR_FREQ_66 : default : p_clk = 66 ; break ; } } printf ( " PC%d" , p_clk ) ; if ( s -> sm_len < 128 ) { return ; } if ( spdmem_read ( sc , SPDMEM_SDR_CAS ) & SPDMEM_SDR_CAS2 ) { printf ( "CL2" ) ; } if ( spdmem_read ( sc , SPDMEM_SDR_CAS ) & SPDMEM_SDR_CAS3 ) { printf ( "CL3" ) ; } } 