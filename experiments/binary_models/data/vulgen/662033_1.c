static ssize_t spdy_inflate_http_headers ( struct http_session * hr ) { Bytef zbuf [ 4096 ] ; uint8_t * src = ( uint8_t * ) hr -> session . main_peer -> in -> buf ; hr -> spdy_z_in . avail_in = hr -> spdy_control_length - 10 ; hr -> spdy_z_in . next_in = src + 10 ; struct uwsgi_buffer * ub = uwsgi_buffer_new ( 4096 ) ; while ( hr -> spdy_z_in . avail_in > 0 ) { hr -> spdy_z_in . avail_out = 4096 ; hr -> spdy_z_in . next_out = zbuf ; int ret = inflate ( & hr -> spdy_z_in , Z_NO_FLUSH ) ; if ( ret == Z_NEED_DICT ) { inflateSetDictionary ( & hr -> spdy_z_in , ( Bytef * ) SPDY_dictionary_txt , sizeof ( SPDY_dictionary_txt ) ) ; ret = inflate ( & hr -> spdy_z_in , Z_NO_FLUSH ) ; } if ( ret != Z_OK ) { return - 1 ; } size_t zlen = hr -> spdy_z_in . next_out - zbuf ; if ( uwsgi_buffer_append ( ub , ( char * ) zbuf , zlen ) ) { uwsgi_buffer_destroy ( ub ) ; return - 1 ; } } if ( ub -> pos < 4 ) { uwsgi_buffer_destroy ( ub ) ; return - 1 ; } uint32_t headers_num = uwsgi_be32 ( ub -> buf ) ; uint32_t i , watermark = ub -> pos , pos = 4 ; struct corerouter_peer * new_peer = uwsgi_cr_peer_add ( & hr -> session ) ; new_peer -> last_hook_read = hr_instance_read_to_spdy ; new_peer -> out = uwsgi_buffer_new ( uwsgi . page_size ) ; new_peer -> out_need_free = 2 ; new_peer -> out -> pos = 4 ; new_peer -> sid = hr -> spdy_data_stream_id ; for ( i = 0 ; i < headers_num ; i ++ ) { if ( pos + 4 > watermark ) { uwsgi_buffer_destroy ( ub ) ; return - 1 ; } uint32_t k_len = uwsgi_be32 ( ub -> buf + pos ) ; pos += 4 ; if ( pos + k_len > watermark ) { uwsgi_buffer_destroy ( ub ) ; return - 1 ; } char * k = ub -> buf + pos ; pos += k_len ; if ( pos + 4 > watermark ) { uwsgi_buffer_destroy ( ub ) ; return - 1 ; } uint32_t v_len = uwsgi_be32 ( ub -> buf + pos ) ; pos += 4 ; if ( pos + v_len > watermark ) { uwsgi_buffer_destroy ( ub ) ; return - 1 ; } char * v = ub -> buf + pos ; pos += v_len ; uint16_t nk_len = 0 ; char * cgi_name = spdy_translate ( k , k_len , & nk_len ) ; if ( ! cgi_name ) { uwsgi_buffer_destroy ( ub ) ; return - 1 ; } if ( uwsgi_buffer_append_keyval ( new_peer -> out , cgi_name , nk_len , v , v_len ) ) { uwsgi_buffer_destroy ( ub ) ; return - 1 ; } if ( ! uwsgi_strncmp ( cgi_name , nk_len , "HTTP_HOST" , 9 ) ) { if ( v_len <= 0xff ) { memcpy ( new_peer -> key , new_peer -> out -> buf + ( new_peer -> out -> pos - v_len ) , v_len ) ; new_peer -> key_len = v_len ; } } if ( ! uwsgi_strncmp ( cgi_name , nk_len , "REQUEST_URI" , 11 ) ) { char * path_info = new_peer -> out -> buf + ( new_peer -> out -> pos - v_len ) ; uint16_t path_info_len = v_len ; char * query_string = memchr ( path_info , '?' , v_len ) ; if ( query_string ) { query_string ++ ; path_info_len = ( query_string - path_info ) - 1 ; uint16_t query_string_len = v_len - ( path_info_len + 1 ) ; if ( uwsgi_buffer_append_keyval ( new_peer -> out , "QUERY_STRING" , 12 , query_string , query_string_len ) ) { free ( cgi_name ) ; uwsgi_buffer_destroy ( ub ) ; return - 1 ; } } if ( uwsgi_buffer_append_keyval ( new_peer -> out , "PATH_INFO" , 9 , path_info , path_info_len ) ) { free ( cgi_name ) ; uwsgi_buffer_destroy ( ub ) ; return - 1 ; } } free ( cgi_name ) ; } uwsgi_buffer_destroy ( ub ) ; if ( new_peer -> key_len == 0 ) { return - 1 ; } if ( uwsgi_buffer_append_keyval ( new_peer -> out , "HTTPS" , 5 , "on" , 2 ) ) { return - 1 ; } if ( uwsgi_buffer_append_keyval ( new_peer -> out , "SPDY" , 4 , "on" , 2 ) ) { return - 1 ; } if ( uwsgi_buffer_append_keynum ( new_peer -> out , "SPDY.version" , 12 , 3 ) ) { return - 1 ; } if ( uwsgi_buffer_append_keynum ( new_peer -> out , "SPDY.stream" , 11 , new_peer -> sid ) ) { return - 1 ; } struct uwsgi_corerouter * ucr = hr -> session . corerouter ; if ( ucr -> mapper ( ucr , new_peer ) ) { return - 1 ; } if ( new_peer -> instance_address_len == 0 ) { return - 1 ; } uint16_t pktsize = new_peer -> out -> pos - 4 ; new_peer -> out -> buf [ 0 ] = new_peer -> session -> main_peer -> modifier1 ; new_peer -> out -> buf [ 3 ] = new_peer -> session -> main_peer -> modifier2 ; new_peer -> out -> buf [ 1 ] = ( uint8_t ) ( pktsize & 0xff ) ; new_peer -> out -> buf [ 2 ] = ( uint8_t ) ( ( pktsize >> 8 ) & 0xff ) ; new_peer -> can_retry = 1 ; cr_connect ( new_peer , hr_instance_connected ) ; return 1 ; } 