static StringInfo * GenerateEntropicChaos ( RandomInfo * random_info ) { MagickThreadType tid ; StringInfo * chaos , * entropy ; size_t nanoseconds , seconds ; ssize_t pid ; entropy = AcquireStringInfo ( 0 ) ; LockSemaphoreInfo ( random_info -> semaphore ) ; { int status ; SetStringInfoLength ( entropy , MaxEntropyExtent ) ; status = getentropy ( GetStringInfoDatum ( entropy ) , MaxEntropyExtent ) ; if ( status == 0 ) { UnlockSemaphoreInfo ( random_info -> semaphore ) ; return ( entropy ) ; } } chaos = AcquireStringInfo ( ( unsigned char * ) ) ; SetStringInfoDatum ( chaos , ( unsigned char * ) & entropy ) ; ConcatenateStringInfo ( entropy , chaos ) ; SetStringInfoDatum ( chaos , ( unsigned char * ) entropy ) ; ConcatenateStringInfo ( entropy , chaos ) ; pid = ( ssize_t ) getpid ( ) ; SetStringInfoLength ( chaos , sizeof ( pid ) ) ; SetStringInfoDatum ( chaos , ( unsigned char * ) & pid ) ; ConcatenateStringInfo ( entropy , chaos ) ; tid = GetMagickThreadId ( ) ; SetStringInfoLength ( chaos , sizeof ( tid ) ) ; SetStringInfoDatum ( chaos , ( unsigned char * ) & tid ) ; ConcatenateStringInfo ( entropy , chaos ) ; { ssize_t pages ; pages = ( ssize_t ) sysconf ( _SC_PHYS_PAGES ) ; SetStringInfoLength ( chaos , sizeof ( pages ) ) ; SetStringInfoDatum ( chaos , ( unsigned char * ) & pages ) ; ConcatenateStringInfo ( entropy , chaos ) ; } { struct rusage usage ; if ( getrusage ( RUSAGE_SELF , & usage ) == 0 ) { SetStringInfoLength ( chaos , sizeof ( usage ) ) ; SetStringInfoDatum ( chaos , ( unsigned char * ) & usage ) ; } } seconds = time ( ( time_t * ) 0 ) ; nanoseconds = 0 ; { struct timeval timer ; if ( gettimeofday ( & timer , ( timezone * ) NULL ) == 0 ) { seconds = ( size_t ) timer . tv_sec ; nanoseconds = ( size_t ) ( 1000UL * timer . tv_usec ) ; } } { struct timespec timer ; if ( clock_gettime ( CLOCK_REALTIME_HR , & timer ) == 0 ) { seconds = timer . tv_sec ; nanoseconds = timer . tv_nsec ; } } SetStringInfoLength ( chaos , sizeof ( seconds ) ) ; SetStringInfoDatum ( chaos , ( unsigned char * ) & seconds ) ; ConcatenateStringInfo ( entropy , chaos ) ; SetStringInfoLength ( chaos , sizeof ( nanoseconds ) ) ; SetStringInfoDatum ( chaos , ( unsigned char * ) & nanoseconds ) ; ConcatenateStringInfo ( entropy , chaos ) ; nanoseconds = 0 ; nanoseconds = clock ( ) ; { struct tms timer ; ( void ) times ( & timer ) ; nanoseconds = timer . tms_utime + timer . tms_stime ; } SetStringInfoLength ( chaos , sizeof ( nanoseconds ) ) ; SetStringInfoDatum ( chaos , ( unsigned char * ) & nanoseconds ) ; ConcatenateStringInfo ( entropy , chaos ) ; { double seconds ; LARGE_INTEGER nanoseconds ; seconds = NTElapsedTime ( ) + NTUserTime ( ) ; SetStringInfoLength ( chaos , sizeof ( seconds ) ) ; SetStringInfoDatum ( chaos , ( unsigned char * ) & seconds ) ; ConcatenateStringInfo ( entropy , chaos ) ; if ( QueryPerformanceCounter ( & nanoseconds ) != 0 ) { SetStringInfoLength ( chaos , sizeof ( nanoseconds ) ) ; SetStringInfoDatum ( chaos , ( unsigned char * ) & nanoseconds ) ; ConcatenateStringInfo ( entropy , chaos ) ; } SetStringInfoLength ( chaos , MaxEntropyExtent ) ; ( void ) NTGatherRandomData ( MaxEntropyExtent , GetStringInfoDatum ( chaos ) ) ; ConcatenateStringInfo ( entropy , chaos ) ; } { char * filename ; int file ; ssize_t count ; StringInfo * device ; if ( environ != ( char * * ) NULL ) { ssize_t i ; for ( i = 0 ; environ [ i ] != ( char * ) NULL ; i ++ ) { SetStringInfoLength ( chaos , strlen ( environ [ i ] ) ) ; SetStringInfoDatum ( chaos , ( unsigned char * ) environ [ i ] ) ; ConcatenateStringInfo ( entropy , chaos ) ; } } filename = AcquireString ( "/dev/urandom" ) ; device = StringToStringInfo ( filename ) ; device = DestroyStringInfo ( device ) ; file = open_utf8 ( filename , O_RDONLY | O_BINARY , 0 ) ; filename = DestroyString ( filename ) ; if ( file != - 1 ) { SetStringInfoLength ( chaos , MaxEntropyExtent ) ; count = ReadRandom ( file , GetStringInfoDatum ( chaos ) , MaxEntropyExtent ) ; ( void ) close ( file ) ; SetStringInfoLength ( chaos , ( size_t ) count ) ; ConcatenateStringInfo ( entropy , chaos ) ; } } chaos = DestroyStringInfo ( chaos ) ; UnlockSemaphoreInfo ( random_info -> semaphore ) ; return ( entropy ) ; } 