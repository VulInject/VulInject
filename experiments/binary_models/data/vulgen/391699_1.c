* * ( at your option ) any later version . * * * * This program is distributed in the hope that it will be useful , * * but WITHOUT ANY WARRANTY ; without even the implied warranty of * * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the * * GNU Lesser General Public License ; for if , write to the Free Software * * Foundation , Inc . , Temple Place Suite , Boston , MA , USA . * int raw_open ( SF_PRIVATE * psf ) ( int subformat , error = SFE_NO_ERROR ) ; subformat = SF_CODEC ( psf -> sf . format ) ; psf -> endian = SF_ENDIAN ( psf -> sf . format ) ; if ( CPU_IS_LITTLE_ENDIAN && ( psf -> endian == 0 || psf -> endian == SF_ENDIAN_CPU ) ) { psf -> endian = SF_ENDIAN_LITTLE ; } psf -> blockwidth = psf -> bytewidth * psf -> sf . channels ; psf -> dataoffset = 0 ; psf -> datalength = psf -> filelength ; switch ( subformat ) { case SF_FORMAT_PCM_S8 : error = pcm_init ( psf ) ; break ; case SF_FORMAT_PCM_U8 : error = pcm_init ( psf ) ; break ; case SF_FORMAT_PCM_16 : case SF_FORMAT_PCM_24 : case SF_FORMAT_PCM_32 : error = pcm_init ( psf ) ; break ; case SF_FORMAT_ULAW : error = ulaw_init ( psf ) ; break ; case SF_FORMAT_ALAW : error = alaw_init ( psf ) ; break ; case SF_FORMAT_GSM610 : error = gsm610_init ( psf ) ; break ; case SF_FORMAT_NMS_ADPCM_16 : case SF_FORMAT_NMS_ADPCM_24 : case SF_FORMAT_NMS_ADPCM_32 : error = nms_adpcm_init ( psf ) ; break ; case SF_FORMAT_FLOAT : error = float32_init ( psf ) ; break ; case SF_FORMAT_DOUBLE : error = double64_init ( psf ) ; break ; case SF_FORMAT_DWVW_12 : error = dwvw_init ( psf , 12 ) ; break ; case SF_FORMAT_DWVW_16 : error = dwvw_init ( psf , 16 ) ; break ; case SF_FORMAT_DWVW_24 : error = dwvw_init ( psf , 24 ) ; break ; case SF_FORMAT_VOX_ADPCM : error = vox_adpcm_init ( psf ) ; break ; default : return SFE_BAD_OPEN_FORMAT ; } return error ; 