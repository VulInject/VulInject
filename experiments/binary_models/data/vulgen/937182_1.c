int cmd_config ( int argc , const char * * argv ) { int i , ret = - 1 ; struct perf_config_set * set ; char * user_config = mkpath ( "%s/.perfconfig" , getenv ( "HOME" ) ) ; const char * config_filename ; bool changed = false ; argc = parse_options ( argc , argv , config_options , config_usage , PARSE_OPT_STOP_AT_NON_OPTION ) ; if ( use_system_config && use_user_config ) { pr_err ( "Error: only one config file at a time\n" ) ; parse_options_usage ( config_usage , config_options , "user" , 0 ) ; parse_options_usage ( NULL , config_options , "system" , 0 ) ; return - 1 ; } if ( use_system_config ) { config_exclusive_filename = perf_etc_perfconfig ( ) ; } if ( use_user_config ) { config_exclusive_filename = user_config ; } if ( ! config_exclusive_filename ) { config_filename = user_config ; } else { config_filename = config_exclusive_filename ; } set = perf_config_set__new ( ) ; if ( ! set ) { out_err } switch ( actions ) { case ACTION_LIST : if ( argc ) { pr_err ( "Error: takes no arguments\n" ) ; parse_options_usage ( config_usage , config_options , "l" , 1 ) ; } else { do_action_list if ( show_config ( set ) < 0 ) { pr_err ( "Nothing configured, " "please check your %s \n" , config_filename ) ; out_err } } break ; default : if ( ! argc ) { do_action_list } for ( i = 0 ; argv [ i ] ; i ++ ) { char * var , * value ; char * arg = strdup ( argv [ i ] ) ; if ( ! arg ) { pr_err ( "%s: strdup failed\n" , __func__ ) ; out_err } if ( parse_config_arg ( arg , & var , & value ) < 0 ) { out_err } if ( value == NULL ) { if ( show_spec_config ( set , var ) < 0 ) { pr_err ( "%s is not configured: %s\n" , var , config_filename ) ; free ( arg ) ; out_err } } else { if ( perf_config_set__collect ( set , config_filename , var , value ) < 0 ) { pr_err ( "Failed to add '%s=%s'\n" , var , value ) ; free ( arg ) ; out_err } changed = true ; } free ( arg ) ; } if ( ! changed ) { break ; } if ( set_config ( set , config_filename ) < 0 ) { pr_err ( "Failed to set the configs on %s\n" , config_filename ) ; out_err } } ret = 0 ; out_err perf_config_set__delete ( set ) ; return ret ; } 