static rsRetVal readAndSendFile ( instanceConf_t * pInst , char * filename , char * fpath , struct stat * fstat ) { smsg_t * pMsg = NULL ; size_t file_len , read_len = 0 , sd_buf_l , msg_len = 0 , idx = 0 ; int last_is_space = 0 ; struct timeval tvm ; uchar sd_buffer [ SRUCTDATA_BUFFER_LEN ] ; uchar read_buffer [ READ_BUFFER_LEN ] ; DEFiRet ; CHKiRet ( msgConstruct ( & pMsg ) ) ; msgAddMetadata ( pMsg , ( uchar * ) "filename" , ( uchar * ) filename ) ; tvm . tv_sec = fstat -> st_mtime ; tvm . tv_usec = 0 ; file_len = lseek ( pInst -> fd , 0 , SEEK_END ) ; MsgSetStructuredData ( pMsg , "-" ) ; sd_buf_l = ( file_len < SRUCTDATA_BUFFER_LEN ) ?file_len : SRUCTDATA_BUFFER_LEN ; if ( lseek ( pInst -> fd , file_len - sd_buf_l , SEEK_SET ) >= 0 ) { uchar * sdp = sd_buffer + sd_buf_l - 1 ; int nb_rm = 0 ; size_t stdata_len = 0 , t ; char * tmp ; if ( ( t = read ( pInst -> fd , sd_buffer , sd_buf_l ) ) != sd_buf_l ) { LogError ( 0 , RS_RET_READ_ERR , "read end of file for structured data failed (%zu / %zu)" , t , sd_buf_l ) ; return RS_RET_READ_ERR ; } for ( ; sdp > sd_buffer && ( * sdp == '\n' || * sdp == '\t' || * sdp == ' ' ) ; sdp -- , sd_buf_l -- ) { file_len -- ; } if ( sd_buf_l > 1 && * sdp == ']' ) { stdata_len = 1 ; for ( ; sdp > sd_buffer && * sdp != '[' ; sdp -- , stdata_len ++ ) { if ( * sdp == '\n' ) { stdata_len -- ; memmove ( sdp , sdp + 1 , stdata_len ) ; nb_rm ++ ; } } if ( * sdp == '[' ) { DBGPRINTF ( "structured data : %.*s\n" , ( int ) stdata_len , sdp ) ; MsgAddToStructuredData ( pMsg , sdp , stdata_len ) ; if ( pInst -> pszTSk ) { uchar * field = ( uchar * ) strstr ( ( char * ) sdp , ( char * ) pInst -> pszTSk ) , v ; if ( field != NULL ) { tvm . tv_sec = 0 ; tvm . tv_usec = 0 ; for ( field += pInst -> lenTSk ; ( v = * field ^ 0x30 ) <= 9 ; field ++ ) { tvm . tv_sec = tvm . tv_sec * 10 + v ; } } } if ( pInst -> pszProgk ) { char * field = strstr ( ( char * ) sdp , ( char * ) pInst -> pszProgk ) ; } for ( sdp -- ; sdp > sd_buffer && ( * sdp == '\n' || * sdp == '\t' || * sdp == ' ' ) ; sdp -- ) { nb_rm ++ ; } } } file_len -= nb_rm + stdata_len ; } datetime . timeval2syslogTime ( & tvm , & pMsg -> tTIMESTAMP , TIME_IN_UTC ) ; pMsg -> ttGenTime = tvm . tv_sec ; if ( lseek ( pInst -> fd , 0 , SEEK_SET ) < 0 ) { LogError ( 0 , RS_RET_READ_ERR , "readAndSendFile : error while seeking to beginning." ) ; return RS_RET_READ_ERR ; } msg_len = 0 ; while ( msg_len < fixedModConf . max_msg_size && ( read_len = read ( pInst -> fd , read_buffer , ( file_len > READ_BUFFER_LEN ) ?READ_BUFFER_LEN : file_len ) ) > 0 ) { file_len -= read_len ; idx = 0 ; while ( read_len > 0 && msg_len < fixedModConf . max_msg_size ) { switch ( read_buffer [ idx ] ) { case '\t' : case ' ' : if ( ! last_is_space ) { fixedModConf . msg_buffer [ msg_len ++ ] = ' ' ; } last_is_space = pInst -> bDedupSpace ; break ; case '\n' : if ( last_is_space ) { msg_len -- ; } fixedModConf . msg_buffer [ msg_len ++ ] = '\\' ; fixedModConf . msg_buffer [ msg_len ++ ] = 'n' ; break ; default : fixedModConf . msg_buffer [ msg_len ++ ] = read_buffer [ idx ] ; last_is_space = 0 ; } idx ++ ; read_len -- ; } } close ( pInst -> fd ) ; pInst -> fd = 0 ; if ( file_len > 0 || read_len > 0 ) { memcpy ( fixedModConf . msg_buffer , FILE_TOO_LARGE , FILE_TOO_LARGE_LEN ) ; msg_len = strlen ( fpath ) ; memcpy ( fixedModConf . msg_buffer + FILE_TOO_LARGE_LEN , fpath , msg_len ) ; msg_len += FILE_TOO_LARGE_LEN ; } MsgSetRawMsg ( pMsg , fixedModConf . msg_buffer , msg_len ) ; MsgSetMSGoffs ( pMsg , 0 ) ; if ( ( iRet = enqMsg ( pInst , pMsg ) ) == RS_RET_OK && ( file_len > 0 || read_len > 0 ) ) { iRet = RS_RET_FILE_TOO_LARGE ; } finalize_it RETiRet ; } 