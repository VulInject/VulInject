static bool drillbit_parse_options ( __maybe_unused struct cgpu_info * drillbit ) { char * next_opt = opt_drillbit_options ; while ( next_opt && strlen ( next_opt ) ) { BoardConfig parsed_config ; config_setting * new_setting ; char key [ 9 ] ; int count , freq , clockdiv , voltage ; char clksrc [ 4 ] ; count = sscanf ( next_opt , "%8[^:]:%3s:%d:%d:%d" , key , clksrc , & freq , & clockdiv , & voltage ) ; if ( count < 5 ) { key [ 0 ] = 0 ; count = sscanf ( next_opt , "%3s:%d:%d:%d" , clksrc , & freq , & clockdiv , & voltage ) ; if ( count < 4 ) { quithere ( 1 , "Failed to parse drillbit-options. Invalid options string: '%s'" , next_opt ) ; } } if ( clockdiv != 1 && clockdiv != 2 ) { quithere ( 1 , "Invalid clock divider value %d. Valid values are 1&2." , clockdiv ) ; } parsed_config . clock_div2 = count > 2 && clockdiv == 2 ; if ( ! strcmp ( "int" , clksrc ) ) { parsed_config . use_ext_clock = 0 ; } if ( ! strcmp ( "ext" , clksrc ) ) { parsed_config . use_ext_clock = 1 ; } else { quithere ( 1 , "Invalid clock source. Valid choices are int, ext." ) ; } parsed_config . clock_freq = freq ; parsed_config . core_voltage = voltage ; new_setting = ( config_setting * ) calloc ( sizeof ( config_setting ) , 1 ) ; memcpy ( & new_setting -> config , & parsed_config , sizeof ( BoardConfig ) ) ; memcpy ( & new_setting -> key , key , 8 ) ; config_setting * ignore ; HASH_REPLACE_STR ( settings , key , new_setting , ignore ) ; next_opt = strstr ( next_opt , "," ) ; if ( next_opt ) { next_opt ++ ; } } if ( opt_drillbit_auto ) { sscanf ( opt_drillbit_auto , "%d:%d:%d:%d" , & auto_every , & auto_good , & auto_bad , & auto_max ) ; if ( auto_max < auto_bad ) { quithere ( 1 , "Bad drillbit-auto: MAX limit must be greater than BAD limit" ) ; } if ( auto_bad < auto_good ) { quithere ( 1 , "Bad drillbit-auto: GOOD limit must be greater than BAD limit" ) ; } } return true ; } 