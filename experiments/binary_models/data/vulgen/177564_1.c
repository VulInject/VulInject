static enum si_sm_result error_recovery ( struct si_sm_data * bt , unsigned char status , unsigned char cCode ) { char * reason ; bt -> timeout = bt -> BT_CAP_req2rsp ; switch ( cCode ) { case IPMI_TIMEOUT_ERR : reason = "timeout" ; break ; default : reason = "internal error" ; break ; } dev_warn ( bt -> io -> dev , "IPMI BT: %s in %s %s " , reason , STATE2TXT , STATUS2TXT ) ; ( bt -> error_retries ) ++ ; if ( bt -> error_retries < bt -> BT_CAP_retries ) { pr_cont ( "%d retries left\n" , bt -> BT_CAP_retries - bt -> error_retries ) ; bt -> state = BT_STATE_RESTART ; return SI_SM_CALL_WITHOUT_DELAY ; } dev_warn ( bt -> io -> dev , "failed %d retries, sending error response\n" , bt -> BT_CAP_retries ) ; if ( ! bt -> nonzero_status ) { dev_err ( bt -> io -> dev , "stuck, try power cycle\n" ) ; } if ( bt -> seq <= ( unsigned char ) ( bt -> BT_CAP_retries & 0xFF ) ) { dev_warn ( bt -> io -> dev , "BT reset (takes 5 secs)\n" ) ; bt -> state = BT_STATE_RESET1 ; return SI_SM_CALL_WITHOUT_DELAY ; } switch ( cCode ) { case IPMI_TIMEOUT_ERR : if ( status & BT_B_BUSY ) { cCode = IPMI_NODE_BUSY_ERR ; bt -> state = BT_STATE_LONG_BUSY ; } break ; default : break ; } force_result ( bt , cCode ) ; return SI_SM_TRANSACTION_COMPLETE ; } 