static void mlx4_master_do_cmd ( struct mlx4_dev * dev , int slave , u8 cmd , u16 param , u8 toggle ) { struct mlx4_priv * priv = mlx4_priv ( dev ) ; struct mlx4_slave_state * slave_state = priv -> mfunc . master . slave_state ; u32 reply ; u8 is_going_down = 0 ; int i ; unsigned long flags ; slave_state [ slave ] . comm_toggle ^= 1 ; reply = ( u32 ) slave_state [ slave ] . comm_toggle << 31 ; if ( toggle != slave_state [ slave ] . comm_toggle ) { mlx4_warn ( dev , "Incorrect toggle %d from slave %d. *** MASTER STATE COMPROMISED ***\n" , toggle , slave ) ; reset_slave } if ( cmd == MLX4_COMM_CMD_RESET ) { mlx4_warn ( dev , "Received reset from slave:%d\n" , slave ) ; slave_state [ slave ] . active = false ; slave_state [ slave ] . old_vlan_api = false ; slave_state [ slave ] . vst_qinq_supported = false ; mlx4_master_deactivate_admin_state ( priv , slave ) ; for ( i = 0 ; i < MLX4_EVENT_TYPES_NUM ; ++ i ) { slave_state [ slave ] . event_eq [ i ] . eqn = - 1 ; slave_state [ slave ] . event_eq [ i ] . token = 0 ; } if ( MLX4_COMM_CMD_FLR == slave_state [ slave ] . last_cmd ) { inform_slave_state } mlx4_dispatch_event ( dev , MLX4_DEV_EVENT_SLAVE_SHUTDOWN , slave ) ; reply |= mlx4_comm_get_version ( ) ; reset_slave } if ( cmd != MLX4_COMM_CMD_RESET && MLX4_COMM_CMD_FLR == slave_state [ slave ] . last_cmd ) { mlx4_warn ( dev , "slave:%d is Trying to run cmd(0x%x) in the middle of FLR\n" , slave , cmd ) ; return ; } switch ( cmd ) { case MLX4_COMM_CMD_VHCR0 : if ( slave_state [ slave ] . last_cmd != MLX4_COMM_CMD_RESET ) { reset_slave } slave_state [ slave ] . vhcr_dma = ( ( u64 ) param ) << 48 ; priv -> mfunc . master . slave_state [ slave ] . cookie = 0 ; break ; case MLX4_COMM_CMD_VHCR1 : if ( slave_state [ slave ] . last_cmd != MLX4_COMM_CMD_VHCR0 ) { reset_slave } slave_state [ slave ] . vhcr_dma |= ( ( u64 ) param ) << 32 ; break ; case MLX4_COMM_CMD_VHCR2 : if ( slave_state [ slave ] . last_cmd != MLX4_COMM_CMD_VHCR1 ) { reset_slave } slave_state [ slave ] . vhcr_dma |= ( ( u64 ) param ) << 16 ; break ; case MLX4_COMM_CMD_VHCR_EN : if ( slave_state [ slave ] . last_cmd != MLX4_COMM_CMD_VHCR2 ) { reset_slave } slave_state [ slave ] . vhcr_dma |= param ; if ( mlx4_master_activate_admin_state ( priv , slave ) ) { reset_slave } slave_state [ slave ] . active = true ; mlx4_dispatch_event ( dev , MLX4_DEV_EVENT_SLAVE_INIT , slave ) ; break ; case MLX4_COMM_CMD_VHCR_POST : if ( ( slave_state [ slave ] . last_cmd != MLX4_COMM_CMD_VHCR_EN ) && ( slave_state [ slave ] . last_cmd != MLX4_COMM_CMD_VHCR_POST ) ) { mlx4_warn ( dev , "slave:%d is out of sync, cmd=0x%x, last command=0x%x, reset is needed\n" , slave , cmd , slave_state [ slave ] . last_cmd ) ; reset_slave } mutex_lock ( & priv -> cmd . slave_cmd_mutex ) ; if ( mlx4_master_process_vhcr ( dev , slave , NULL ) ) { mlx4_err ( dev , "Failed processing vhcr for slave:%d, resetting slave\n" , slave ) ; mutex_unlock ( & priv -> cmd . slave_cmd_mutex ) ; reset_slave } mutex_unlock ( & priv -> cmd . slave_cmd_mutex ) ; break ; default : mlx4_warn ( dev , "Bad comm cmd:%d from slave:%d\n" , cmd , slave ) ; reset_slave } spin_lock_irqsave ( & priv -> mfunc . master . slave_state_lock , flags ) ; if ( ! slave_state [ slave ] . is_slave_going_down ) { slave_state [ slave ] . last_cmd = cmd ; } else { is_going_down = 1 ; } spin_unlock_irqrestore ( & priv -> mfunc . master . slave_state_lock , flags ) ; if ( is_going_down ) { mlx4_warn ( dev , "Slave is going down aborting command(%d) executing from slave:%d\n" , cmd , slave ) ; return ; } __raw_writel ( ( __force u32 ) cpu_to_be32 ( reply ) , & priv -> mfunc . comm [ slave ] . slave_read ) ; mmiowb ( ) ; return ; reset_slave if ( dev -> persist -> interface_state & MLX4_INTERFACE_STATE_UP ) { mlx4_delete_all_resources_for_slave ( dev , slave ) ; } spin_lock_irqsave ( & priv -> mfunc . master . slave_state_lock , flags ) ; if ( ! slave_state [ slave ] . is_slave_going_down ) { slave_state [ slave ] . last_cmd = MLX4_COMM_CMD_RESET ; } spin_unlock_irqrestore ( & priv -> mfunc . master . slave_state_lock , flags ) ; inform_slave_state memset ( & slave_state [ slave ] . event_eq , 0 , sizeof ( mlx4_slave_event_eq_info ) ) ; __raw_writel ( ( __force u32 ) cpu_to_be32 ( reply ) , & priv -> mfunc . comm [ slave ] . slave_read ) ; wmb ( ) ; } 