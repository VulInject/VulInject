void hfi1_uc_rcv ( struct hfi1_packet * packet ) { struct hfi1_ibport * ibp = rcd_to_iport ( packet -> rcd ) ; struct ib_header * hdr = packet -> hdr ; u32 rcv_flags = packet -> rcv_flags ; void * data = packet -> ebuf ; u32 tlen = packet -> tlen ; struct rvt_qp * qp = packet -> qp ; struct ib_other_headers * ohdr = packet -> ohdr ; u32 bth0 , opcode ; u32 hdrsize = packet -> hlen ; u32 psn ; u32 pad ; struct ib_wc wc ; u32 pmtu = qp -> pmtu ; struct ib_reth * reth ; int has_grh = rcv_flags & HFI1_HAS_GRH ; int ret ; bth0 = be32_to_cpu ( ohdr -> bth [ 0 ] ) ; process_ecn ( qp , packet , true ) ; psn = be32_to_cpu ( ohdr -> bth [ 2 ] ) ; opcode = ib_bth_get_opcode ( ohdr ) ; if ( unlikely ( cmp_psn ( psn , qp -> r_psn ) != 0 ) ) { qp -> r_psn = psn ; inv if ( qp -> r_state == OP ( SEND_FIRST ) || qp -> r_state == OP ( SEND_MIDDLE ) ) { set_bit ( RVT_R_REWIND_SGE , & qp -> r_aflags ) ; qp -> r_sge . num_sge = 0 ; } else { rvt_put_ss ( & qp -> r_sge ) ; } qp -> r_state = OP ( SEND_LAST ) ; switch ( opcode ) { case OP ( SEND_FIRST ) : case OP ( SEND_ONLY ) : case OP ( SEND_ONLY_WITH_IMMEDIATE ) : send_first case OP ( RDMA_WRITE_FIRST ) : case OP ( RDMA_WRITE_ONLY ) : case OP ( RDMA_WRITE_ONLY_WITH_IMMEDIATE ) : rdma_first default : drop } } switch ( qp -> r_state ) { case OP ( SEND_FIRST ) : case OP ( SEND_MIDDLE ) : if ( opcode == OP ( SEND_MIDDLE ) || opcode == OP ( SEND_LAST ) || opcode == OP ( SEND_LAST_WITH_IMMEDIATE ) ) { break ; } inv case OP ( RDMA_WRITE_FIRST ) : case OP ( RDMA_WRITE_MIDDLE ) : if ( opcode == OP ( RDMA_WRITE_MIDDLE ) || opcode == OP ( RDMA_WRITE_LAST ) || opcode == OP ( RDMA_WRITE_LAST_WITH_IMMEDIATE ) ) { break ; } inv default : if ( opcode == OP ( SEND_FIRST ) || opcode == OP ( SEND_ONLY ) || opcode == OP ( SEND_ONLY_WITH_IMMEDIATE ) || opcode == OP ( RDMA_WRITE_FIRST ) || opcode == OP ( RDMA_WRITE_ONLY ) || opcode == OP ( RDMA_WRITE_ONLY_WITH_IMMEDIATE ) ) { break ; } inv } if ( qp -> state == IB_QPS_RTR && ! ( qp -> r_flags & RVT_R_COMM_EST ) ) { rvt_comm_est ( qp ) ; } switch ( opcode ) { case OP ( SEND_FIRST ) : case OP ( SEND_ONLY ) : case OP ( SEND_ONLY_WITH_IMMEDIATE ) : send_first if ( test_and_clear_bit ( RVT_R_REWIND_SGE , & qp -> r_aflags ) ) { qp -> r_sge = qp -> s_rdma_read_sge ; } else { ret = hfi1_rvt_get_rwqe ( qp , 0 ) ; if ( ret < 0 ) { op_err } if ( ! ret ) { drop } qp -> s_rdma_read_sge = qp -> r_sge ; } qp -> r_rcv_len = 0 ; if ( opcode == OP ( SEND_ONLY ) ) { no_immediate_data } if ( opcode == OP ( SEND_ONLY_WITH_IMMEDIATE ) ) { send_last_imm } case OP ( SEND_MIDDLE ) : if ( unlikely ( tlen != ( hdrsize + pmtu + 4 ) ) ) { rewind } qp -> r_rcv_len += pmtu ; if ( unlikely ( qp -> r_rcv_len > qp -> r_len ) ) { rewind } hfi1_copy_sge ( & qp -> r_sge , data , pmtu , false , false ) ; break ; case OP ( SEND_LAST_WITH_IMMEDIATE ) : send_last_imm wc . ex . imm_data = ohdr -> u . imm_data ; wc . wc_flags = IB_WC_WITH_IMM ; send_last case OP ( SEND_LAST ) : no_immediate_data wc . ex . imm_data = 0 ; wc . wc_flags = 0 ; send_last pad = ib_bth_get_pad ( ohdr ) ; if ( unlikely ( tlen < ( hdrsize + pad + 4 ) ) ) { rewind } tlen -= ( hdrsize + pad + 4 ) ; wc . byte_len = tlen + qp -> r_rcv_len ; if ( unlikely ( wc . byte_len > qp -> r_len ) ) { rewind } wc . opcode = IB_WC_RECV ; hfi1_copy_sge ( & qp -> r_sge , data , tlen , false , false ) ; rvt_put_ss ( & qp -> s_rdma_read_sge ) ; last_imm wc . wr_id = qp -> r_wr_id ; wc . status = IB_WC_SUCCESS ; wc . qp = & qp -> ibqp ; wc . src_qp = qp -> remote_qpn ; wc . slid = rdma_ah_get_dlid ( & qp -> remote_ah_attr ) ; wc . sl = rdma_ah_get_sl ( & qp -> remote_ah_attr ) ; wc . vendor_err = 0 ; wc . pkey_index = 0 ; wc . dlid_path_bits = 0 ; wc . port_num = 0 ; rvt_cq_enter ( ibcq_to_rvtcq ( qp -> ibqp . recv_cq ) , & wc , ( ohdr -> bth [ 0 ] & cpu_to_be32 ( IB_BTH_SOLICITED ) ) != 0 ) ; break ; case OP ( RDMA_WRITE_FIRST ) : case OP ( RDMA_WRITE_ONLY ) : case OP ( RDMA_WRITE_ONLY_WITH_IMMEDIATE ) : rdma_first if ( unlikely ( ! ( qp -> qp_access_flags & IB_ACCESS_REMOTE_WRITE ) ) ) { drop } reth = & ohdr -> u . rc . reth ; qp -> r_len = be32_to_cpu ( reth -> length ) ; qp -> r_rcv_len = 0 ; qp -> r_sge . sg_list = NULL ; if ( qp -> r_len != 0 ) { u32 rkey = be32_to_cpu ( reth -> rkey ) ; u64 vaddr = be64_to_cpu ( reth -> vaddr ) ; int ok ; ok = rvt_rkey_ok ( qp , & qp -> r_sge . sge , qp -> r_len , vaddr , rkey , IB_ACCESS_REMOTE_WRITE ) ; if ( unlikely ( ! ok ) ) { drop } qp -> r_sge . num_sge = 1 ; } else { qp -> r_sge . num_sge = 0 ; qp -> r_sge . sge . mr = NULL ; qp -> r_sge . sge . vaddr = NULL ; qp -> r_sge . sge . length = 0 ; qp -> r_sge . sge . sge_length = 0 ; } if ( opcode == OP ( RDMA_WRITE_ONLY ) ) { rdma_last } if ( opcode == OP ( RDMA_WRITE_ONLY_WITH_IMMEDIATE ) ) { wc . ex . imm_data = ohdr -> u . rc . imm_data ; rdma_last_imm } case OP ( RDMA_WRITE_MIDDLE ) : if ( unlikely ( tlen != ( hdrsize + pmtu + 4 ) ) ) { drop } qp -> r_rcv_len += pmtu ; if ( unlikely ( qp -> r_rcv_len > qp -> r_len ) ) { drop } hfi1_copy_sge ( & qp -> r_sge , data , pmtu , true , false ) ; break ; case OP ( RDMA_WRITE_LAST_WITH_IMMEDIATE ) : wc . ex . imm_data = ohdr -> u . imm_data ; rdma_last_imm wc . wc_flags = IB_WC_WITH_IMM ; pad = ib_bth_get_pad ( ohdr ) ; if ( unlikely ( tlen < ( hdrsize + pad + 4 ) ) ) { drop } tlen -= ( hdrsize + pad + 4 ) ; if ( unlikely ( tlen + qp -> r_rcv_len != qp -> r_len ) ) { drop } if ( test_and_clear_bit ( RVT_R_REWIND_SGE , & qp -> r_aflags ) ) { rvt_put_ss ( & qp -> s_rdma_read_sge ) ; } else { ret = hfi1_rvt_get_rwqe ( qp , 1 ) ; if ( ret < 0 ) { op_err } if ( ! ret ) { drop } } wc . byte_len = qp -> r_len ; wc . opcode = IB_WC_RECV_RDMA_WITH_IMM ; hfi1_copy_sge ( & qp -> r_sge , data , tlen , true , false ) ; rvt_put_ss ( & qp -> r_sge ) ; last_imm case OP ( RDMA_WRITE_LAST ) : rdma_last pad = ib_bth_get_pad ( ohdr ) ; if ( unlikely ( tlen < ( hdrsize + pad + 4 ) ) ) { drop } tlen -= ( hdrsize + pad + 4 ) ; if ( unlikely ( tlen + qp -> r_rcv_len != qp -> r_len ) ) { drop } hfi1_copy_sge ( & qp -> r_sge , data , tlen , true , false ) ; rvt_put_ss ( & qp -> r_sge ) ; break ; default : drop } qp -> r_psn ++ ; qp -> r_state = opcode ; return ; rewind set_bit ( RVT_R_REWIND_SGE , & qp -> r_aflags ) ; qp -> r_sge . num_sge = 0 ; drop ibp -> rvp . n_pkt_drops ++ ; return ; op_err rvt_rc_error ( qp , IB_WC_LOC_QP_OP_ERR ) ; } 