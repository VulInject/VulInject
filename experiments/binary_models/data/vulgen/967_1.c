static void test_hdb_concurrency ( char * name , const char * ext , int threaded ) { krb5_error_code ret ; krb5_context context ; char * fname = strchr ( name , ':' ) + 1 ; char * fname_ext = NULL ; pthread_t reader_thread ; struct tsync ts ; hdb_entry entw ; pid_t child = getpid ( ) ; HDB * dbw = NULL ; int status ; int fd ; memset ( & ts , 0 , sizeof ( ts ) ) ; ( void ) pthread_cond_init ( & ts . rcv , NULL ) ; ( void ) pthread_cond_init ( & ts . wcv , NULL ) ; ( void ) pthread_mutex_init ( & ts . lock , NULL ) ; if ( ( krb5_init_context ( & context ) ) ) { errx ( 1 , "krb5_init_context failed" ) ; } if ( ( fd = mkstemp ( fname ) ) == - 1 ) { err ( 1 , "mkstemp(%s)" , fname ) ; } ( void ) close ( fd ) ; ( void ) unlink ( fname ) ; if ( asprintf ( & fname_ext , "%s%s" , fname , ext ?ext : "" ) == - 1 || fname_ext == NULL ) { err ( 1 , "Out of memory" ) ; } ts . hdb_name = name ; ts . fname = fname_ext ; if ( threaded ) { printf ( "Starting reader thread\n" ) ; ( void ) pthread_mutex_lock ( & ts . lock ) ; if ( ( errno = pthread_create ( & reader_thread , NULL , threaded_reader , & ts ) ) ) { ( void ) unlink ( fname_ext ) ; krb5_err ( context , 1 , errno , "Could not create a thread to read HDB" ) ; } while ( ! ts . writer_go ) { ( void ) pthread_cond_wait ( & ts . wcv , & ts . lock ) ; } ( void ) pthread_mutex_unlock ( & ts . lock ) ; } else { printf ( "Starting reader process\n" ) ; if ( pipe ( ts . writer_go_pipe ) == - 1 ) { err ( 1 , "Could not create a pipe" ) ; } if ( pipe ( ts . reader_go_pipe ) == - 1 ) { err ( 1 , "Could not create a pipe" ) ; } switch ( ( child = fork ( ) ) ) { case - 1 : err ( 1 , "Could not fork a child" ) ; case 0 : forked_reader ( & ts ) ; _exit ( 0 ) ; default : break ; } ( void ) close ( ts . writer_go_pipe [ 1 ] ) ; ts . writer_go_pipe [ 1 ] = - 1 ; } printf ( "Writing two entries into HDB\n" ) ; if ( ( ret = hdb_create ( context , & dbw , name ) ) ) { krb5_err ( context , 1 , ret , "Could not get a handle for HDB %s (write)" , name ) ; } if ( ( ret = dbw -> hdb_open ( context , dbw , O_RDWR | O_CREAT , 0600 ) ) ) { krb5_err ( context , 1 , ret , "Could not create HDB %s" , name ) ; } memset ( & entw , 0 , sizeof ( entw ) ) ; if ( ( ret = make_entry ( context , & entw , "foo" ) ) || ( ret = dbw -> hdb_store ( context , dbw , 0 , & entw ) ) ) { ( void ) unlink ( fname_ext ) ; krb5_err ( context , 1 , ret , "Could not store entry for \"foo\" in HDB %s" , name ) ; } free_HDB_entry ( & entw ) ; if ( ( ret = make_entry ( context , & entw , "bar" ) ) || ( ret = dbw -> hdb_store ( context , dbw , 0 , & entw ) ) ) { ( void ) unlink ( fname_ext ) ; krb5_err ( context , 1 , ret , "Could not store entry for \"foo\" in HDB %s" , name ) ; } free_HDB_entry ( & entw ) ; readers_turn ( & ts , child , threaded ) ; if ( ( ret = make_entry ( context , & entw , "foobar" ) ) || ( ret = dbw -> hdb_store ( context , dbw , 0 , & entw ) ) ) { ( void ) unlink ( fname_ext ) ; krb5_err ( context , 1 , ret , "Could not store entry for \"foobar\" in HDB %s " "while iterating it" , name ) ; } free_HDB_entry ( & entw ) ; readers_turn ( & ts , child , threaded ) ; dbw -> hdb_close ( context , dbw ) ; dbw -> hdb_destroy ( context , dbw ) ; if ( threaded ) { ( void ) pthread_join ( reader_thread , NULL ) ; } else { ( void ) close ( ts . writer_go_pipe [ 1 ] ) ; ( void ) close ( ts . reader_go_pipe [ 0 ] ) ; ( void ) close ( ts . reader_go_pipe [ 1 ] ) ; while ( wait ( & status ) == - 1 && errno == EINTR ) { } ( void ) close ( ts . writer_go_pipe [ 0 ] ) ; if ( WEXITSTATUS ( status ) != 0 ) { errx ( 1 , "Child reader errored" ) ; } } ( void ) unlink ( fname_ext ) ; krb5_free_context ( context ) ; } 