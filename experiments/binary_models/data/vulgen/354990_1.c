static void epf_ntb_cmd_handler ( struct work_struct * work ) { struct epf_ntb_ctrl * ctrl ; u32 command , argument ; struct epf_ntb * ntb ; struct device * dev ; int ret ; int i ; ntb = container_of ( work , epf_ntb , cmd_handler . work ) ; for ( i = 1 ; i < ntb -> db_count ; i ++ ) { if ( ntb -> epf_db [ i ] ) { ntb_db_event ( & ntb -> ntb , i ) ; ntb -> epf_db [ i ] = 0 ; } } ctrl = ntb -> reg ; command = ctrl -> command ; if ( ! command ) { reset_handler } argument = ctrl -> argument ; ctrl -> command = 0 ; ctrl -> argument = 0 ; ctrl = ntb -> reg ; dev = & ntb -> epf -> dev ; switch ( command ) { case COMMAND_CONFIGURE_DOORBELL : ctrl -> command_status = COMMAND_STATUS_OK ; break ; case COMMAND_TEARDOWN_DOORBELL : ctrl -> command_status = COMMAND_STATUS_OK ; break ; case COMMAND_CONFIGURE_MW : ret = epf_ntb_configure_mw ( ntb , argument ) ; if ( ret < 0 ) { ctrl -> command_status = COMMAND_STATUS_ERROR ; } else { ctrl -> command_status = COMMAND_STATUS_OK ; } break ; case COMMAND_TEARDOWN_MW : epf_ntb_teardown_mw ( ntb , argument ) ; ctrl -> command_status = COMMAND_STATUS_OK ; break ; case COMMAND_LINK_UP : ntb -> linkup = true ; ret = epf_ntb_link_up ( ntb , true ) ; if ( ret < 0 ) { ctrl -> command_status = COMMAND_STATUS_ERROR ; } else { ctrl -> command_status = COMMAND_STATUS_OK ; } reset_handler case COMMAND_LINK_DOWN : ntb -> linkup = false ; ret = epf_ntb_link_up ( ntb , false ) ; if ( ret < 0 ) { ctrl -> command_status = COMMAND_STATUS_ERROR ; } else { ctrl -> command_status = COMMAND_STATUS_OK ; } break ; default : dev_err ( dev , "UNKNOWN command: %d\n" , command ) ; break ; } reset_handler queue_delayed_work ( kpcintb_workqueue , & ntb -> cmd_handler , msecs_to_jiffies ( 5 ) ) ; } 