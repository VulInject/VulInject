static int isp1362_urb_enqueue ( struct usb_hcd * hcd , struct urb * urb , gfp_t mem_flags ) { struct isp1362_hcd * isp1362_hcd = hcd_to_isp1362_hcd ( hcd ) ; struct usb_device * udev = urb -> dev ; unsigned int pipe = urb -> pipe ; int is_out = ! usb_pipein ( pipe ) ; int type = usb_pipetype ( pipe ) ; int epnum = usb_pipeendpoint ( pipe ) ; struct usb_host_endpoint * hep = urb -> ep ; struct isp1362_ep * ep = NULL ; unsigned long flags ; int retval = 0 ; DBG ( 3 , "%s: urb %p\n" , __func__ , urb ) ; if ( type == PIPE_ISOCHRONOUS ) { pr_err ( "Isochronous transfers not supported\n" ) ; return - ENOSPC ; } URB_DBG ( "%s: FA %d ep%d%s %s: len %d %s%s\n" , __func__ , usb_pipedevice ( pipe ) , epnum , is_out ?"out" : "in" , usb_pipecontrol ( pipe ) ?"ctrl" : usb_pipeint ( pipe ) ?"int" : usb_pipebulk ( pipe ) ?"bulk" : "iso" , urb -> transfer_buffer_length , ( urb -> transfer_flags & URB_ZERO_PACKET ) ?"ZERO_PACKET " : "" , ! ( urb -> transfer_flags & URB_SHORT_NOT_OK ) ?"short_ok" : "" ) ; if ( ! hep -> hcpriv ) { ep = kzalloc ( sizeof ep , mem_flags ) ; if ( ! ep ) { return - ENOMEM ; } } spin_lock_irqsave ( & isp1362_hcd -> lock , flags ) ; if ( ! ( ( isp1362_hcd -> rhport [ 0 ] | isp1362_hcd -> rhport [ 1 ] ) & USB_PORT_STAT_ENABLE ) || ! HC_IS_RUNNING ( hcd -> state ) ) { kfree ( ep ) ; retval = - ENODEV ; fail_not_linked } retval = usb_hcd_link_urb_to_ep ( hcd , urb ) ; if ( retval ) { kfree ( ep ) ; fail_not_linked } if ( hep -> hcpriv ) { ep = hep -> hcpriv ; } else { INIT_LIST_HEAD ( & ep -> schedule ) ; INIT_LIST_HEAD ( & ep -> active ) ; INIT_LIST_HEAD ( & ep -> remove_list ) ; ep -> udev = usb_get_dev ( udev ) ; ep -> hep = hep ; ep -> epnum = epnum ; ep -> maxpacket = usb_maxpacket ( udev , urb -> pipe ) ; ep -> ptd_offset = - EINVAL ; ep -> ptd_index = - EINVAL ; usb_settoggle ( udev , epnum , is_out , 0 ) ; if ( type == PIPE_CONTROL ) { ep -> nextpid = USB_PID_SETUP ; } if ( is_out ) { ep -> nextpid = USB_PID_OUT ; } else { ep -> nextpid = USB_PID_IN ; } switch ( type ) { case PIPE_ISOCHRONOUS : case PIPE_INTERRUPT : if ( urb -> interval > PERIODIC_SIZE ) { urb -> interval = PERIODIC_SIZE ; } ep -> interval = urb -> interval ; ep -> branch = PERIODIC_SIZE ; ep -> load = usb_calc_bus_time ( udev -> speed , ! is_out , type == PIPE_ISOCHRONOUS , usb_maxpacket ( udev , pipe ) ) / 1000 ; break ; } hep -> hcpriv = ep ; } ep -> num_req = isp1362_hcd -> req_serial ++ ; switch ( type ) { case PIPE_CONTROL : case PIPE_BULK : if ( list_empty ( & ep -> schedule ) ) { DBG ( 1 , "%s: Adding ep %p req %d to async schedule\n" , __func__ , ep , ep -> num_req ) ; list_add_tail ( & ep -> schedule , & isp1362_hcd -> async ) ; } break ; case PIPE_ISOCHRONOUS : case PIPE_INTERRUPT : urb -> interval = ep -> interval ; if ( ep -> branch < PERIODIC_SIZE ) { break ; } retval = balance ( isp1362_hcd , ep -> interval , ep -> load ) ; ep -> branch = retval ; retval = 0 ; isp1362_hcd -> fmindex = isp1362_read_reg32 ( isp1362_hcd , HCFMNUM ) ; DBG ( 1 , "%s: Current frame %04x branch %02x start_frame %04x(%04x)\n" , __func__ , isp1362_hcd -> fmindex , ep -> branch , ( ( isp1362_hcd -> fmindex + PERIODIC_SIZE - 1 ) & ~ ( PERIODIC_SIZE - 1 ) ) + ep -> branch , ( isp1362_hcd -> fmindex & ( PERIODIC_SIZE - 1 ) ) + ep -> branch ) ; if ( list_empty ( & ep -> schedule ) ) { if ( type == PIPE_ISOCHRONOUS ) { u16 frame = isp1362_hcd -> fmindex ; frame += max_t ( u16 , 8 , ep -> interval ) ; frame &= ~ ( ep -> interval - 1 ) ; frame |= ep -> branch ; if ( frame_before ( frame , isp1362_hcd -> fmindex ) ) { frame += ep -> interval ; } urb -> start_frame = frame ; DBG ( 1 , "%s: Adding ep %p to isoc schedule\n" , __func__ , ep ) ; list_add_tail ( & ep -> schedule , & isp1362_hcd -> isoc ) ; } else { DBG ( 1 , "%s: Adding ep %p to periodic schedule\n" , __func__ , ep ) ; list_add_tail ( & ep -> schedule , & isp1362_hcd -> periodic ) ; } } else { DBG ( 1 , "%s: ep %p already scheduled\n" , __func__ , ep ) ; } DBG ( 2 , "%s: load %d bandwidth %d ->%d\n" , __func__ , ep -> load / ep -> interval , isp1362_hcd -> load [ ep -> branch ] , isp1362_hcd -> load [ ep -> branch ] + ep -> load ) ; isp1362_hcd -> load [ ep -> branch ] += ep -> load ; } urb -> hcpriv = hep ; ALIGNSTAT ( isp1362_hcd , urb -> transfer_buffer ) ; switch ( type ) { case PIPE_CONTROL : case PIPE_BULK : start_atl_transfers ( isp1362_hcd ) ; break ; case PIPE_INTERRUPT : start_intl_transfers ( isp1362_hcd ) ; break ; case PIPE_ISOCHRONOUS : start_iso_transfers ( isp1362_hcd ) ; break ; default : BUG ( ) ; } fail if ( retval ) { usb_hcd_unlink_urb_from_ep ( hcd , urb ) ; } fail_not_linked spin_unlock_irqrestore ( & isp1362_hcd -> lock , flags ) ; if ( retval ) { DBG ( 0 , "%s: urb %p failed with %d\n" , __func__ , urb , retval ) ; } return retval ; } 