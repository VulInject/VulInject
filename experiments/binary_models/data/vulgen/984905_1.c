void pc_basic_device_init ( struct PCMachineState * pcms , ISABus * isa_bus , qemu_irq * gsi , ISADevice * * rtc_state , bool create_fdctrl , uint32_t hpet_irqs ) { int i ; DeviceState * hpet = NULL ; int pit_isa_irq = 0 ; qemu_irq pit_alt_irq = NULL ; qemu_irq rtc_irq = NULL ; ISADevice * pit = NULL ; MemoryRegion * ioport80_io = g_new ( MemoryRegion , 1 ) ; MemoryRegion * ioportF0_io = g_new ( MemoryRegion , 1 ) ; memory_region_init_io ( ioport80_io , NULL , & ioport80_io_ops , NULL , "ioport80" , 1 ) ; memory_region_add_subregion ( isa_bus -> address_space_io , 0x80 , ioport80_io ) ; memory_region_init_io ( ioportF0_io , NULL , & ioportF0_io_ops , NULL , "ioportF0" , 1 ) ; memory_region_add_subregion ( isa_bus -> address_space_io , 0xf0 , ioportF0_io ) ; if ( pcms -> hpet_enabled && ( ! kvm_irqchip_in_kernel ( ) || kvm_has_pit_state2 ( ) ) ) { hpet = qdev_try_new ( TYPE_HPET ) ; if ( ! hpet ) { error_report ( "couldn't create HPET device" ) ; exit ( 1 ) ; } uint8_t compat = object_property_get_uint ( OBJECT ( hpet ) , HPET_INTCAP , NULL ) ; if ( ! compat ) { qdev_connect_gpio_out ( hpet , 0 , 0 ) ; } sysbus_realize_and_unref ( SYS_BUS_DEVICE ( hpet ) , & error_fatal ) ; sysbus_mmio_map ( SYS_BUS_DEVICE ( hpet ) , 0 , HPET_BASE ) ; for ( i = 0 ; i < GSI_NUM_PINS ; i ++ ) { sysbus_connect_irq ( SYS_BUS_DEVICE ( hpet ) , i , gsi [ i ] ) ; } pit_isa_irq = - 1 ; pit_alt_irq = qdev_get_gpio_in ( hpet , HPET_LEGACY_PIT_INT ) ; rtc_irq = qdev_get_gpio_in ( hpet , HPET_LEGACY_RTC_INT ) ; } * rtc_state = mc146818_rtc_init ( isa_bus , 2000 , rtc_irq ) ; qemu_register_boot_set ( pc_boot_set , * rtc_state ) ; if ( ! xen_enabled ( ) && pcms -> pit_enabled ) { if ( kvm_pit_in_kernel ( ) ) { pit = kvm_pit_init ( isa_bus , 0x40 ) ; } else { pit = i8254_pit_init ( isa_bus , 0x40 , pit_isa_irq , pit_alt_irq ) ; } if ( hpet ) { qdev_connect_gpio_out ( hpet , 0 , qdev_get_gpio_in ( DEVICE ( pit ) , 0 ) ) ; } pcspk_init ( pcms -> pcspk , isa_bus , pit ) ; } i8257_dma_init ( isa_bus , 0 ) ; pc_superio_init ( isa_bus , create_fdctrl , pcms -> vmport != ON_OFF_AUTO_ON ) ; } 