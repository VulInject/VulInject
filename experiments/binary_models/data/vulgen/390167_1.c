static void handle_timeouts ( struct event_base * base , struct timeval * now , struct timeval * wait ) { struct event * p ; verbose ( VERB_CLIENT , "winsock_event handle_timeouts" ) ; while ( ( rbnode_type * ) ( p = ( event * ) rbtree_first ( base -> times ) ) != RBTREE_NULL ) { if ( p -> ev_timeout . tv_sec > now -> tv_sec || ( p -> ev_timeout . tv_sec == now -> tv_sec && p -> ev_timeout . tv_usec > now -> tv_usec ) ) { wait -> tv_sec = p -> ev_timeout . tv_sec - now -> tv_sec ; if ( now -> tv_usec > p -> ev_timeout . tv_usec ) { wait -> tv_sec -- ; wait -> tv_usec = 1000000 - ( now -> tv_usec - p -> ev_timeout . tv_usec ) ; } else { wait -> tv_usec = p -> ev_timeout . tv_usec - now -> tv_usec ; } verbose ( VERB_CLIENT , "winsock_event wait=" ARG_LL "d.%6.6d" , ( long long ) wait -> tv_sec , ( int ) wait -> tv_usec ) ; return ; } ( void ) rbtree_delete ( base -> times , p ) ; p -> ev_events &= ~ EV_TIMEOUT ; fptr_ok ( fptr_whitelist_event ( p -> ev_callback ) ) ; * p -> ev_callback ( p -> ev_fd , EV_TIMEOUT , p -> ev_arg ) ; } verbose ( VERB_CLIENT , "winsock_event wait=(-1)" ) ; } 