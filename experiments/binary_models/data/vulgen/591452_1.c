static int nfcmrvl_spi_probe ( struct spi_device * spi ) { const struct nfcmrvl_platform_data * pdata ; struct nfcmrvl_platform_data config ; struct nfcmrvl_spi_drv_data * drv_data ; int ret = 0 ; drv_data = devm_kzalloc ( & spi -> dev , sizeof ( * drv_data ) , GFP_KERNEL ) ; if ( ! drv_data ) { return - ENOMEM ; } drv_data -> spi = spi ; drv_data -> priv = NULL ; spi_set_drvdata ( spi , drv_data ) ; pdata = spi -> dev . platform_data ; if ( ! pdata && spi -> dev . of_node ) { if ( nfcmrvl_spi_parse_dt ( spi -> dev . of_node , & config ) == 0 ) { pdata = & config ; } } ret = devm_request_threaded_irq ( & drv_data -> spi -> dev , pdata -> irq , NULL , nfcmrvl_spi_int_irq_thread_fn , IRQF_TRIGGER_FALLING | IRQF_ONESHOT , "nfcmrvl_spi_int" , drv_data ) ; if ( ret < 0 ) { nfc_err ( & drv_data -> spi -> dev , "Unable to register IRQ handler" ) ; return - ENODEV ; } drv_data -> priv = nfcmrvl_nci_register_dev ( NFCMRVL_PHY_SPI , drv_data , & spi_ops , & drv_data -> spi -> dev , pdata ) ; if ( IS_ERR ( drv_data -> priv ) ) { return PTR_ERR ( drv_data -> priv ) ; } drv_data -> priv -> support_fw_dnld = true ; drv_data -> nci_spi = nci_spi_allocate_spi ( drv_data -> spi , 0 , 10 , drv_data -> priv -> ndev ) ; init_completion ( & drv_data -> handshake_completion ) ; return 0 ; } 