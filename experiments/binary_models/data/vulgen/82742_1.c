static sa_jm_cmd_resp_t sa_jm_cmd_create ( Mai_t * mad , uint8_t * data , uint32_t len , uint8_t * * outData , int * outLen ) { Status_t s ; sa_jm_cmd_resp_t resp = SA_JM_CMDRESP_OK ; JmEntry_t * job ; JmMsgReqCreate_t input ; JmWireJobOptions_t options ; uint16_t count ; int costLen ; time_t timestamp ; INCREMENT_COUNTER ( smCounterJmReqCreateJob ) ; s = sm_jm_decode_req_create ( data , len , & input ) ; if ( s != VSTATUS_OK ) { IB_LOG_ERROR_FMT ( __func__ , "Failed to decode job input (status %d)" , s ) ; resp = SA_JM_CMDRESP_ERROR ; fail1 } s = sm_jm_alloc_job ( & job ) ; if ( s != VSTATUS_OK ) { IB_LOG_ERROR_FMT ( __func__ , "Failed to allocate job entry (status %d)" , s ) ; resp = SA_JM_CMDRESP_ERROR ; fail2 } options = input . options ; job -> params = input . params ; job -> state = JM_STATE_INITIALIZED ; vs_stdtime_get ( & timestamp ) ; job -> timestamp = timestamp ; s = vs_wrlock ( & old_topology_lock ) ; if ( s != VSTATUS_OK ) { IB_LOG_ERROR_FMT ( __func__ , "Failed to lock the old topology (status %d)" , s ) ; resp = SA_JM_CMDRESP_ERROR ; fail3 } job -> passcount = topology_passcount ; s = sm_jm_fill_ports ( & old_topology , & input , job , & count ) ; if ( s != VSTATUS_OK ) { IB_LOG_ERROR_FMT ( __func__ , "Failed to resolve port information from input (status %d)" , s ) ; resp = SA_JM_CMDRESP_ERROR ; fail4 } if ( job -> switchCount == 0 ) { IB_LOG_ERROR_FMT ( __func__ , "Failed to resolve switch information from input" ) ; resp = SA_JM_CMDRESP_ERROR ; fail4 } if ( count < input . guids . count ) { resp = SA_JM_CMDRESP_PARTIAL ; } s = sm_jm_get_cost ( & old_topology , job , & cost , & costLen ) ; if ( s != VSTATUS_OK ) { IB_LOG_ERROR_FMT ( __func__ , "Failed to get topology cost information (status %d)" , s ) ; resp = SA_JM_CMDRESP_ERROR ; fail4 } ( void ) vs_rwunlock ( & old_topology_lock ) ; sm_jm_free_req_create ( & input ) ; s = sm_jm_insert_job ( job ) ; if ( s != VSTATUS_OK ) { sm_jm_free_cost ( cost ) ; sm_jm_free_job ( job ) ; IB_LOG_ERROR_FMT ( __func__ , "Failed to insert the job into the job table (status %d)" , s ) ; return SA_JM_CMDRESP_ERROR ; } s = sm_jm_encode_resp_create ( job , cost , costLen , outData , outLen ) ; if ( s != VSTATUS_OK ) { sm_jm_remove_job ( job ) ; sm_jm_free_cost ( cost ) ; sm_jm_free_job ( job ) ; IB_LOG_ERROR_FMT ( __func__ , "Failed to create the message response (status %d)" , s ) ; return SA_JM_CMDRESP_ERROR ; } if ( options . no_create ) { sm_jm_remove_job ( job ) ; sm_jm_free_cost ( cost ) ; sm_jm_free_job ( job ) ; } else { sm_jm_free_cost ( cost ) ; } return resp ; fail4 ( void ) vs_rwunlock ( & old_topology_lock ) ; fail3 sm_jm_free_job ( job ) ; fail2 sm_jm_free_req_create ( & input ) ; fail1 return resp ; } 