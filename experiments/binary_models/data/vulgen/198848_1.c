void nouveau_dp_irq ( struct work_struct * work ) { struct nouveau_connector * nv_connector = container_of ( work , typeof ( * nv_connector ) , irq_work ) ; struct drm_connector * connector = & nv_connector -> base ; struct nouveau_encoder * outp = find_encoder ( connector , DCB_OUTPUT_DP ) ; struct nouveau_drm * drm = nouveau_drm ( outp -> base . base . dev ) ; struct nv50_mstm * mstm ; u64 hpd = 0 ; int ret ; mstm = outp -> dp . mstm ; NV_DEBUG ( drm , "service %s\n" , connector -> name ) ; mutex_lock ( & outp -> dp . hpd_irq_lock ) ; if ( mstm && mstm -> is_mst ) { if ( ! nv50_mstm_service ( drm , nv_connector , mstm ) ) { hpd |= NVIF_CONN_EVENT_V0_UNPLUG ; } } else { drm_dp_cec_irq ( & nv_connector -> aux ) ; if ( nouveau_dp_has_sink_count ( connector , outp ) ) { ret = drm_dp_read_sink_count ( & nv_connector -> aux ) ; if ( ret != outp -> dp . sink_count ) { hpd |= NVIF_CONN_EVENT_V0_PLUG ; } if ( ret >= 0 ) { outp -> dp . sink_count = ret ; } } } mutex_unlock ( & outp -> dp . hpd_irq_lock ) ; nouveau_connector_hpd ( nv_connector , NVIF_CONN_EVENT_V0_IRQ | hpd ) ; } 