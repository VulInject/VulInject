static int nb8800_dma_stop ( struct net_device * dev ) { struct nb8800_priv * priv = netdev_priv ( dev ) ; struct nb8800_tx_buf * txb = & priv -> tx_bufs [ 0 ] ; struct nb8800_tx_desc * txd = & priv -> tx_descs [ 0 ] ; int retry = 5 ; u32 txcr ; u32 rxcr ; int err ; unsigned int i ; err = readl_poll_timeout_atomic ( priv -> base + NB8800_TXC_CR , txcr , ! ( txcr & TCR_EN ) && priv -> tx_done == priv -> tx_next , 1000 , 1000000 ) ; if ( err ) { return err ; } for ( i = 0 ; i < RX_DESC_COUNT ; i ++ ) { priv -> rx_descs [ i ] . desc . config |= DESC_EOC ; } txd -> desc [ 0 ] . s_addr = txb -> dma_desc + offsetof ( nb8800_tx_desc , buf ) ; txd -> desc [ 0 ] . config = DESC_BTS ( 2 ) | DESC_DS | DESC_EOF | DESC_EOC | 8 ; nb8800_mac_af ( dev , false ) ; nb8800_setb ( priv , NB8800_MAC_MODE , LOOPBACK_EN ) ; { nb8800_writel ( priv , NB8800_TX_DESC_ADDR , txb -> dma_desc ) ; wmb ( ) ; nb8800_writel ( priv , NB8800_TXC_CR , txcr | TCR_EN ) ; err = readl_poll_timeout_atomic ( priv -> base + NB8800_RXC_CR , rxcr , ! ( rxcr & RCR_EN ) , 1000 , 100000 ) ; } err && -- retry ; nb8800_mac_af ( dev , true ) ; nb8800_clearb ( priv , NB8800_MAC_MODE , LOOPBACK_EN ) ; nb8800_dma_reset ( dev ) ; return retry ?0 : - ETIMEDOUT ; } 