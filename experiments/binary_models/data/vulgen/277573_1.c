static gboolean dissect_pktgen ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) { proto_item * ti = NULL ; proto_item * tmp = NULL ; proto_tree * pktgen_tree = NULL ; guint32 offset = 0 ; nstime_t tstamp ; guint32 magic ; magic = tvb_get_ntohl ( tvb , 0 ) ; if ( magic != PKTGEN_MAGIC ) { return FALSE ; } col_set_str ( pinfo -> cinfo , COL_PROTOCOL , "PKTGEN" ) ; col_add_fstr ( pinfo -> cinfo , COL_INFO , "Seq: %u" , tvb_get_ntohl ( tvb , 4 ) ) ; if ( tree ) { ti = proto_tree_add_item ( tree , proto_pktgen , tvb , 0 , - 1 , ENC_NA ) ; pktgen_tree = proto_item_add_subtree ( ti , ett_pktgen ) ; proto_tree_add_item ( pktgen_tree , hf_pktgen_magic , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( pktgen_tree , hf_pktgen_seqnum , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; tstamp . secs = tvb_get_ntohl ( tvb , offset ) ; tmp = proto_tree_add_item ( pktgen_tree , hf_pktgen_tvsec , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; proto_item_set_generated ( tmp ) ; offset += 4 ; tstamp . nsecs = tvb_get_ntohl ( tvb , offset ) * 1000 ; tmp = proto_tree_add_item ( pktgen_tree , hf_pktgen_tvusec , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; proto_item_set_generated ( tmp ) ; offset += 4 ; proto_tree_add_time ( pktgen_tree , hf_pktgen_timestamp , tvb , offset - 8 , 8 , & tstamp ) ; if ( tvb_reported_length_remaining ( tvb , offset ) ) { call_data_dissector ( tvb_new_subset_remaining ( tvb , offset ) , pinfo , pktgen_tree ) ; } } return TRUE ; } 