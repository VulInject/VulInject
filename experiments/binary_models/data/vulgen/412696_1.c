dt_module_t * dt_module_create ( dtrace_hdl_t * dtp , const char * name ) { long pid ; char * eptr ; dt_ident_t * idp ; uint_t h = dt_strtab_hash ( name , NULL ) % dtp -> dt_modbuckets ; dt_module_t * dmp ; for ( dmp = dtp -> dt_mods [ h ] ; dmp != NULL ; dmp = dmp -> dm_next ) { if ( strcmp ( dmp -> dm_name , name ) == 0 ) { return ( dmp ) ; } } if ( ( dmp = malloc ( sizeof ( dt_module_t ) ) ) == NULL ) { return ( NULL ) ; } ( void ) strlcpy ( dmp -> dm_name , name , sizeof ( dmp -> dm_name ) ) ; dt_list_append ( & dtp -> dt_modlist , dmp ) ; dmp -> dm_next = dtp -> dt_mods [ h ] ; dtp -> dt_mods [ h ] = dmp ; dtp -> dt_nmods ++ ; if ( dtp -> dt_conf . dtc_ctfmodel == CTF_MODEL_LP64 ) { dmp -> dm_ops = & dt_modops_64 ; } else { dmp -> dm_ops = & dt_modops_32 ; } if ( strncmp ( dmp -> dm_name , "pid" , 3 ) == 0 ) { errno = 0 ; if ( dmp -> dm_name [ 3 ] == '\0' ) { idp = dt_idhash_lookup ( dtp -> dt_macros , "target" ) ; if ( idp != NULL && idp -> di_id != 0 ) { dmp -> dm_pid = idp -> di_id ; } } else { pid = strtol ( dmp -> dm_name + 3 , & eptr , 10 ) ; if ( errno == 0 && * eptr == '\0' ) { dmp -> dm_pid = ( pid_t ) pid ; } else { dt_dprintf ( "encountered malformed pid " "module: %s\n" , dmp -> dm_name ) ; } } } return ( dmp ) ; } 