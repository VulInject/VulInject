pipeconf = REG_READ ( map -> conf ) ; if ( is_edp ) { switch ( dev_priv -> edp . bpp ) { case 24 : pipeconf |= PIPE_8BPC ; break ; case 18 : pipeconf |= PIPE_6BPC ; break ; case 30 : pipeconf |= PIPE_10BPC ; break ; default : pipeconf |= PIPE_8BPC ; break ; } } if ( is_lvds ) { if ( ( REG_READ ( LVDS ) & LVDS_A3_POWER_MASK ) == LVDS_A3_POWER_UP ) { pipeconf |= PIPE_8BPC ; } else { pipeconf |= PIPE_6BPC ; } } else { pipeconf |= PIPE_8BPC ; } dspcntr = DISPPLANE_GAMMA_ENABLE ; if ( pipe == 0 ) { dspcntr |= DISPPLANE_SEL_PIPE_A ; } else { dspcntr |= DISPPLANE_SEL_PIPE_B ; } dspcntr |= DISPLAY_PLANE_ENABLE ; pipeconf |= PIPEACONF_ENABLE ; REG_WRITE ( map -> dpll , dpll | DPLL_VGA_MODE_DIS | DPLL_SYNCLOCK_ENABLE ) ; REG_READ ( map -> dpll ) ; cdv_dpll_set_clock_cdv ( dev , crtc , & clock , is_lvds , ddi_select ) ; udelay ( 150 ) ; if ( is_lvds ) { u32 lvds = REG_READ ( LVDS ) ; lvds |= LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP | LVDS_PIPEB_SELECT ; if ( clock . p2 == 7 ) { lvds |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP ; } else { lvds &= ~ ( LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP ) ; } REG_WRITE ( LVDS , lvds ) ; REG_READ ( LVDS ) ; } dpll |= DPLL_VCO_ENABLE ; if ( cdv_intel_panel_fitter_pipe ( dev ) == pipe ) { REG_WRITE ( PFIT_CONTROL , 0 ) ; } DRM_DEBUG_KMS ( "Mode for pipe %c:\n" , pipe == 0 ?'A' : 'B' ) ; drm_mode_debug_printmodeline ( mode ) ; REG_WRITE ( map -> dpll , ( REG_READ ( map -> dpll ) & ~ DPLL_LOCK ) | DPLL_VCO_ENABLE ) ; REG_READ ( map -> dpll ) ; udelay ( 150 ) ; if ( ! ( REG_READ ( map -> dpll ) & DPLL_LOCK ) ) { dev_err ( dev -> dev , "Failed to get DPLL lock\n" ) ; return - EBUSY ; } { int sdvo_pixel_multiply = adjusted_mode -> clock / mode -> clock ; REG_WRITE ( map -> dpll_md , ( 0 << DPLL_MD_UDI_DIVIDER_SHIFT ) | ( ( sdvo_pixel_multiply - 1 ) << DPLL_MD_UDI_MULTIPLIER_SHIFT ) ) ; } REG_WRITE ( map -> htotal , ( adjusted_mode -> crtc_hdisplay - 1 ) | ( ( adjusted_mode -> crtc_htotal - 1 ) << 16 ) ) ; REG_WRITE ( map -> hblank , ( adjusted_mode -> crtc_hblank_start - 1 ) | ( ( adjusted_mode -> crtc_hblank_end - 1 ) << 16 ) ) ; REG_WRITE ( map -> hsync , ( adjusted_mode -> crtc_hsync_start - 1 ) | ( ( adjusted_mode -> crtc_hsync_end - 1 ) << 16 ) ) ; REG_WRITE ( map -> vtotal , ( adjusted_mode -> crtc_vdisplay - 1 ) | ( ( adjusted_mode -> crtc_vtotal - 1 ) << 16 ) ) ; REG_WRITE ( map -> vblank , ( adjusted_mode -> crtc_vblank_start - 1 ) | ( ( adjusted_mode -> crtc_vblank_end - 1 ) << 16 ) ) ; REG_WRITE ( map -> vsync , ( adjusted_mode -> crtc_vsync_start - 1 ) | ( ( adjusted_mode -> crtc_vsync_end - 1 ) << 16 ) ) ; REG_WRITE ( map -> size , ( ( mode -> vdisplay - 1 ) << 16 ) | ( mode -> hdisplay - 1 ) ) ; REG_WRITE ( map -> pos , 0 ) ; REG_WRITE ( map -> src , ( ( mode -> hdisplay - 1 ) << 16 ) | ( mode -> vdisplay - 1 ) ) ; REG_WRITE ( map -> conf , pipeconf ) ; REG_READ ( map -> conf ) ; gma_wait_for_vblank ( dev ) ; REG_WRITE ( map -> cntr , dspcntr ) ; { const struct drm_crtc_helper_funcs * crtc_funcs = crtc -> helper_private ; crtc_funcs -> mode_set_base ( crtc , x , y , old_fb ) ; } gma_wait_for_vblank ( dev ) ; return 0 ; 