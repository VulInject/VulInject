int mwifiex_send_addba ( struct mwifiex_private * priv , int tid , u8 * peer_mac ) { struct host_cmd_ds_11n_addba_req add_ba_req ; u32 tx_win_size = priv -> add_ba_param . tx_win_size ; static u8 dialog_tok ; int ret ; u16 block_ack_param_set ; mwifiex_dbg ( priv -> adapter , CMD , "cmd: %s: tid %d\n" , __func__ , tid ) ; if ( ( GET_BSS_ROLE ( priv ) == MWIFIEX_BSS_ROLE_STA ) && ISSUPP_TDLS_ENABLED ( priv -> adapter -> fw_cap_info ) && priv -> adapter -> is_hw_11ac_capable && memcmp ( priv -> cfg_bssid , peer_mac , ETH_ALEN ) ) { struct mwifiex_sta_node * sta_ptr ; spin_lock_bh ( & priv -> sta_list_spinlock ) ; sta_ptr = mwifiex_get_sta_entry ( priv , peer_mac ) ; if ( ! sta_ptr ) { spin_unlock_bh ( & priv -> sta_list_spinlock ) ; mwifiex_dbg ( priv -> adapter , ERROR , "BA setup with unknown TDLS peer %pM!\n" , peer_mac ) ; return - 1 ; } if ( sta_ptr -> is_11ac_enabled ) { tx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE ; } spin_unlock_bh ( & priv -> sta_list_spinlock ) ; } block_ack_param_set = ( u16 ) ( ( tid << BLOCKACKPARAM_TID_POS ) | tx_win_size << BLOCKACKPARAM_WINSIZE_POS | IMMEDIATE_BLOCK_ACK ) ; if ( priv -> add_ba_param . tx_amsdu && ( priv -> aggr_prio_tbl [ tid ] . amsdu != BA_STREAM_NOT_ALLOWED ) ) { block_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK ; } add_ba_req . block_ack_param_set = cpu_to_le16 ( block_ack_param_set ) ; add_ba_req . block_ack_tmo = cpu_to_le16 ( ( u16 ) priv -> add_ba_param . timeout ) ; ++ dialog_tok ; if ( dialog_tok == 0 ) { dialog_tok = 1 ; } add_ba_req . dialog_token = dialog_tok ; memcpy ( & add_ba_req . peer_mac_addr , peer_mac , ETH_ALEN ) ; ret = mwifiex_send_cmd ( priv , HostCmd_CMD_11N_ADDBA_REQ , 0 , 0 , & add_ba_req , false ) ; return ret ; } 