static nss_status_t getbyname ( be , a ) dns_backend_ptr_t be ; void * a ; { struct hostent * he = NULL ; nss_XbyY_args_t * argp = ( nss_XbyY_args_t * ) a ; int ret , mt_disabled ; sigset_t oldmask ; char * * v6Aliases = 0 , * * mergeAliases ; struct hostent v6he ; struct hostent mhe ; char * v6Name = 0 ; struct in6_addr * * v6Addrs = 0 , * * mergeAddrs = 0 ; char * * v6Aliases = 0 , * * mergeAliases = 0 ; int v6_h_errno ; int old_retry ; int af = argp -> key . ipnode . af_family ; int flags = argp -> key . ipnode . flags ; switch_resolver_setup ( & mt_disabled , & oldmask , & old_retry ) ; if ( af == AF_INET6 ) { he = _nss_dns_gethostbyname2 ( & argp -> h_errno , argp -> key . ipnode . name ) ; } if ( he != NULL ) { v6Name = cloneName ( he , & converr ) ; if ( converr ) { argp -> h_errno = HOST_NOT_FOUND ; argp -> erange = 1 ; switch_resolver_reset ( mt_disabled , oldmask , old_retry ) ; return ( _herrno2nss ( argp -> h_errno ) ) ; } v6Addrs = cloneAddrList ( he , 0 , & converr ) ; if ( converr ) { if ( v6Name != 0 ) { free ( v6Name ) ; } argp -> h_errno = HOST_NOT_FOUND ; argp -> erange = 1 ; switch_resolver_reset ( mt_disabled , oldmask , old_retry ) ; return ( _herrno2nss ( argp -> h_errno ) ) ; } v6Aliases = cloneAliasList ( he , 0 , & converr ) ; if ( converr ) { if ( v6Name != 0 ) { free ( v6Name ) ; } if ( v6Addrs != 0 ) { free ( v6Addrs ) ; } argp -> h_errno = HOST_NOT_FOUND ; argp -> erange = 1 ; switch_resolver_reset ( mt_disabled , oldmask , old_retry ) ; return ( _herrno2nss ( argp -> h_errno ) ) ; } v6_h_errno = argp -> h_errno ; gotv6 = 1 ; } if ( ( af == AF_INET ) || ( ( af == AF_INET6 ) && ( ( flags & ( AI_ALL | AI_V4MAPPED ) ) || ( ( flags & AI_V4MAPPED ) && he == NULL ) ) ) ) { he = _gethostbyname ( & argp -> h_errno , argp -> key . ipnode . name ) ; } else { he = NULL ; } if ( he != NULL ) { mhe = * he ; mergeAddrs = cloneAddrList ( he , v6Addrs , & converr ) ; if ( converr ) { if ( v6Name != 0 ) { free ( v6Name ) ; } if ( v6Addrs != 0 ) { free ( v6Addrs ) ; } if ( v6Aliases != 0 ) { free ( v6Aliases ) ; } argp -> h_errno = HOST_NOT_FOUND ; argp -> erange = 1 ; switch_resolver_reset ( mt_disabled , oldmask , old_retry ) ; return ( _herrno2nss ( argp -> h_errno ) ) ; } mhe . h_addr_list = ( char * * ) mergeAddrs ; mergeAliases = cloneAliasList ( he , v6Aliases , & converr ) ; if ( converr ) { if ( v6Name != 0 ) { free ( v6Name ) ; } if ( v6Addrs != 0 ) { free ( v6Addrs ) ; } if ( v6Aliases != 0 ) { free ( v6Aliases ) ; } if ( mergeAddrs != 0 ) { free ( mergeAddrs ) ; } argp -> h_errno = HOST_NOT_FOUND ; argp -> erange = 1 ; switch_resolver_reset ( mt_disabled , oldmask , old_retry ) ; return ( _herrno2nss ( argp -> h_errno ) ) ; } mhe . h_aliases = mergeAliases ; mhe . h_length = sizeof ( in6_addr ) ; mhe . h_addrtype = AF_INET6 ; he = & mhe ; } if ( gotv6 ) { v6he . h_name = v6Name ; v6he . h_length = sizeof ( in6_addr ) ; v6he . h_addrtype = AF_INET6 ; v6he . h_addr_list = ( char * * ) v6Addrs ; v6he . h_aliases = v6Aliases ; he = & v6he ; argp -> h_errno = v6_h_errno ; } if ( he != NULL ) { if ( argp -> buf . result == NULL ) { ret = ent2str ( he , a , AF_INET6 ) ; if ( ret == NSS_STR_PARSE_SUCCESS ) { argp -> returnval = argp -> buf . buffer ; } } else { ret = ent2result ( he , a , AF_INET6 ) ; if ( ret == NSS_STR_PARSE_SUCCESS ) { argp -> returnval = argp -> buf . result ; } } if ( ret != NSS_STR_PARSE_SUCCESS ) { argp -> h_errno = HOST_NOT_FOUND ; if ( ret == NSS_STR_PARSE_ERANGE ) { argp -> erange = 1 ; } } } if ( v6Name != 0 ) { free ( v6Name ) ; } if ( v6Addrs != 0 ) { free ( v6Addrs ) ; } if ( v6Aliases != 0 ) { free ( v6Aliases ) ; } if ( mergeAddrs != 0 ) { free ( mergeAddrs ) ; } if ( mergeAliases != 0 ) { free ( mergeAliases ) ; } switch_resolver_reset ( mt_disabled , oldmask , old_retry ) ; return ( _herrno2nss ( argp -> h_errno ) ) ; } 