void cpu_loop ( CPUOpenRISCState * env ) { CPUState * cs = env_cpu ( env ) ; int trapnr ; for ( ; ; ) { cpu_exec_start ( cs ) ; trapnr = cpu_exec ( cs ) ; cpu_exec_end ( cs ) ; process_queued_cpu_work ( cs ) ; switch ( trapnr ) { case EXCP_SYSCALL : env -> pc += 4 ; ret = do_syscall ( env , cpu_get_gpr ( env , 11 ) , cpu_get_gpr ( env , 3 ) , cpu_get_gpr ( env , 4 ) , cpu_get_gpr ( env , 5 ) , cpu_get_gpr ( env , 6 ) , cpu_get_gpr ( env , 7 ) , cpu_get_gpr ( env , 8 ) , 0 , 0 ) ; if ( ret == - QEMU_ERESTARTSYS ) { env -> pc -= 4 ; } if ( ret != - QEMU_ESIGRETURN ) { cpu_set_gpr ( env , 11 , ret ) ; } break ; case EXCP_ALIGN : force_sig_fault ( TARGET_SIGBUS , TARGET_BUS_ADRALN , env -> eear ) ; break ; case EXCP_ILLEGAL : force_sig_fault ( TARGET_SIGILL , TARGET_ILL_ILLOPC , env -> pc ) ; break ; case EXCP_INTERRUPT : break ; case EXCP_DEBUG : force_sig_fault ( TARGET_SIGTRAP , TARGET_TRAP_BRKPT , env -> pc ) ; break ; case EXCP_ATOMIC : cpu_exec_step_atomic ( cs ) ; break ; case EXCP_RANGE : cpu_abort ( cs , "Unexpected RANGE exception" ) ; case EXCP_FPE : cpu_abort ( cs , "Unexpected FPE exception" ) ; default : g_assert_not_reached ( ) ; } process_pending_signals ( env ) ; } } 