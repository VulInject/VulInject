boolean_t mxfe_receive ( mxfe_t * mxfep , mblk_t * * rxchain ) { unsigned len ; mxfe_rxbuf_t * rxb ; mxfe_desc_t * rmd ; uint32_t status ; mblk_t * mpchain , * * mpp , * mp ; int head , cnt ; boolean_t error = B_FALSE ; mpchain = NULL ; mpp = & mpchain ; head = mxfep -> mxfe_rxhead ; for ( cnt = 0 ; cnt < MXFE_RXRING ; cnt ++ ) { DBG ( DRECV , "receive at index %d" , head ) ; rmd = & mxfep -> mxfe_rxdescp [ head ] ; rxb = mxfep -> mxfe_rxbufs [ head ] ; SYNCRXDESC ( mxfep , head , DDI_DMA_SYNC_FORKERNEL ) ; status = GETRXDESC ( mxfep , rmd -> desc_status ) ; if ( status & RXSTAT_OWN ) { break ; } len = RXLENGTH ( status ) - ETHERFCSL ; DBG ( DRECV , "recv length %d, status %x" , len , status ) ; if ( ( status & ( RXSTAT_ERRS | RXSTAT_FIRST | RXSTAT_LAST ) ) != ( RXSTAT_FIRST | RXSTAT_LAST ) ) { mxfep -> mxfe_errrcv ++ ; if ( ( status & ( RXSTAT_LAST | RXSTAT_FIRST ) ) != ( RXSTAT_LAST | RXSTAT_FIRST ) ) { DBG ( DRECV , "rx packet overspill" ) ; if ( status & RXSTAT_FIRST ) { mxfep -> mxfe_toolong_errors ++ ; } } if ( status & RXSTAT_DESCERR ) { mxfep -> mxfe_macrcv_errors ++ ; error = B_TRUE ; } if ( status & RXSTAT_RUNT ) { mxfep -> mxfe_runt ++ ; } if ( status & RXSTAT_COLLSEEN ) { mxfep -> mxfe_macrcv_errors ++ ; } if ( status & RXSTAT_DRIBBLE ) { mxfep -> mxfe_align_errors ++ ; } if ( status & RXSTAT_CRCERR ) { mxfep -> mxfe_fcs_errors ++ ; } if ( status & RXSTAT_OFLOW ) { mxfep -> mxfe_overflow ++ ; error = B_TRUE ; } } if ( len > ETHERVLANMTU ) { mxfep -> mxfe_errrcv ++ ; mxfep -> mxfe_toolong_errors ++ ; } else { mp = allocb ( len + MXFE_HEADROOM , 0 ) ; if ( mp == NULL ) { mxfep -> mxfe_errrcv ++ ; mxfep -> mxfe_norcvbuf ++ ; skip } SYNCRXBUF ( rxb , len , DDI_DMA_SYNC_FORKERNEL ) ; mp -> b_rptr += MXFE_HEADROOM ; mp -> b_wptr = mp -> b_rptr + len ; bcopy ( ( char * ) rxb -> rxb_buf , mp -> b_rptr , len ) ; mxfep -> mxfe_ipackets ++ ; mxfep -> mxfe_rbytes += len ; * mpp = mp ; mpp = & mp -> b_next ; } skip PUTRXDESC ( mxfep , rmd -> desc_status , RXSTAT_OWN ) ; SYNCRXDESC ( mxfep , head , DDI_DMA_SYNC_FORDEV ) ; head = ( head + 1 ) % MXFE_RXRING ; } mxfep -> mxfe_rxhead = head ; * rxchain = mpchain ; return ( error ) ; } 