int convert ( char * buff1 , char * buff2 ) { int i = 0 , j = 0 , k , l ; char errbuff [ BUFFERLEN ] ; int chr , wclen ; char buff3 [ 3 ] ; while ( 1 ) { if ( buff1 [ i ] == '\0' ) { break ; } else { if ( ( unsigned char ) buff1 [ i ] < 0x80 ) { wclen = 1 ; } if ( is_internalUPTEX ( ) ) { wclen = multibytelen ( ( unsigned char ) buff1 [ i ] ) ; if ( wclen < 0 ) { verb_printf ( efp , "\nWarning: Illegal lead byte 0x%x in UTF-8." , ( unsigned char ) buff1 [ i ] ) ; i ++ ; continue ; } chr = UCS2toJIS ( UTF8StoUCS ( ( unsigned char * ) & buff1 [ i ] ) ) ; if ( chr == 0 ) { chr = 0xffff ; } chr |= 0x8080 ; buff3 [ 0 ] = BYTE3 ( chr ) ; buff3 [ 1 ] = BYTE4 ( chr ) ; buff3 [ 2 ] = '\0' ; } else { wclen = 2 ; buff3 [ 0 ] = buff1 [ i ] ; buff3 [ 1 ] = buff1 [ i + 1 ] ; buff3 [ 2 ] = '\0' ; } if ( ( buff1 [ i ] >= 'a' ) && ( buff1 [ i ] <= 'z' ) ) { buff2 [ j ] = buff1 [ i ] - 32 ; i ++ ; j ++ ; } if ( ( lorder == 1 ) && ( ( buff1 [ i ] == ' ' ) || ( buff1 [ i ] == '\t' ) ) ) { i ++ ; } if ( ( unsigned char ) buff1 [ i ] < 0x80 ) { buff2 [ j ] = buff1 [ i ] ; i ++ ; j ++ ; } if ( is_katakana ( buff3 ) ) { for ( k = 0 ; k < strlen ( katakana ) ; k += 2 ) { if ( strncmp ( buff3 , & katakana [ k ] , 2 ) == 0 ) { strncpy ( & buff2 [ j ] , & kanatable [ k ] , 2 ) ; MATCH1 } } sprintf ( errbuff , "\nError: %s is bad katakana " , buff3 ) ; fputs ( errbuff , efp ) ; if ( efp != stderr ) { fputs ( errbuff , stderr ) ; } return - 1 ; MATCH1 i += wclen ; j += 2 ; } if ( is_hiragana ( buff3 ) ) { for ( k = 0 ; k < strlen ( hiragana ) ; k += 2 ) { if ( strncmp ( buff3 , & hiragana [ k ] , 2 ) == 0 ) { strncpy ( & buff2 [ j ] , & kanatable [ k ] , 2 ) ; MATCH2 } } sprintf ( errbuff , "\nError: %s is bad hiragana " , buff3 ) ; fputs ( errbuff , efp ) ; if ( efp != stderr ) { fputs ( errbuff , stderr ) ; } return - 1 ; MATCH2 i += wclen ; j += 2 ; } if ( is_onbiki ( buff3 ) ) { if ( j >= 2 ) { for ( k = 0 ; k < 20 ; k += 2 ) { for ( l = 0 ; l < 6 ; l ++ ) { if ( strncmp ( & buff2 [ j - 2 ] , & btable [ l ] [ k ] , 2 ) == 0 ) { strncpy ( & buff2 [ j ] , & btable [ l ] [ 0 ] , 2 ) ; MATCH3 } } } } sprintf ( errbuff , "\nError: %s is Illegal line " , buff1 ) ; fputs ( errbuff , efp ) ; if ( efp != stderr ) { fputs ( errbuff , stderr ) ; } return - 1 ; MATCH3 i += wclen ; j += 2 ; } if ( ( unsigned char ) buff1 [ i ] >= 0x80 ) { if ( is_alpha_numeric ( buff3 ) ) { for ( k = 0 ; k < strlen ( symboltable ) ; k += 2 ) { if ( strncmp ( buff3 , & symboltable [ k ] , 2 ) == 0 ) { buff2 [ j ] = k / 2 + 0x20 ; if ( ( buff2 [ j ] >= 'a' ) && ( buff2 [ j ] <= 'z' ) ) { buff2 [ j ] -= 32 ; } i += wclen ; j ++ ; break ; } } if ( k == strlen ( symboltable ) ) { i += wclen ; buff2 [ j ++ ] = buff3 [ 0 ] ; buff2 [ j ++ ] = buff3 [ 1 ] ; } } else { for ( k = 0 ; k < dlines ; k ++ ) { if ( strncmp ( dictable [ k ] . dic [ 0 ] , & buff1 [ i ] , strlen ( dictable [ k ] . dic [ 0 ] ) ) == 0 ) { strncpy ( & buff2 [ j ] , dictable [ k ] . dic [ 1 ] , strlen ( dictable [ k ] . dic [ 1 ] ) ) ; i += strlen ( dictable [ k ] . dic [ 0 ] ) ; j += strlen ( dictable [ k ] . dic [ 1 ] ) ; break ; } } if ( ( k == dlines ) && ( elines != 0 ) ) { for ( k = 0 ; k < elines ; k ++ ) { if ( strncmp ( envdic [ k ] . dic [ 0 ] , & buff1 [ i ] , strlen ( envdic [ k ] . dic [ 0 ] ) ) == 0 ) { strncpy ( & buff2 [ j ] , envdic [ k ] . dic [ 1 ] , strlen ( envdic [ k ] . dic [ 1 ] ) ) ; i += strlen ( envdic [ k ] . dic [ 0 ] ) ; j += strlen ( envdic [ k ] . dic [ 1 ] ) ; break ; } } } if ( ( ( k == dlines ) && ( elines == 0 ) ) || ( ( k == elines ) && ( elines != 0 ) ) ) { if ( force == 1 ) { i += wclen ; buff2 [ j ++ ] = buff3 [ 0 ] ; buff2 [ j ++ ] = buff3 [ 1 ] ; } else { sprintf ( errbuff , "\nError: %s is no entry in dictionary file " , & buff1 [ i ] ) ; fputs ( errbuff , efp ) ; if ( efp != stderr ) { fputs ( errbuff , stderr ) ; } return - 1 ; } } } } } } return 0 ; } 