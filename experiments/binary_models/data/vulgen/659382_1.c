void check_func ( struct node * np ) { struct node * arglist = np -> u . func . arglist ; ASSERTinfo ( np -> t == T_FUNC , ptree_nodetype2str ( np -> t ) ) ; if ( np -> u . func . s == L_within ) { switch ( arglist -> t ) { case T_NUM : if ( arglist -> u . ull != 0ULL ) { outfl ( O_ERR , arglist -> file , arglist -> line , "parameter of within must be 0" ", \"infinity\" or a time value." ) ; } break ; case T_NAME : if ( arglist -> u . name . s != L_infinity ) { outfl ( O_ERR , arglist -> file , arglist -> line , "parameter of within must be 0" ", \"infinity\" or a time value." ) ; } break ; case T_LIST : if ( arglist -> u . expr . left -> t != T_NUM && arglist -> u . expr . left -> t != T_TIMEVAL ) { outfl ( O_ERR , arglist -> file , arglist -> line , "first parameter of within must be" " either a time value or zero." ) ; } if ( arglist -> u . expr . right -> t != T_NUM && arglist -> u . expr . right -> t != T_TIMEVAL && arglist -> u . expr . right -> t != T_NAME ) { outfl ( O_ERR , arglist -> file , arglist -> line , "second parameter of within must " "be 0, \"infinity\" or time value." ) ; } if ( ( arglist -> u . expr . left -> t == T_NUM ) && ( arglist -> u . expr . left -> u . ull != 0ULL ) ) { outfl ( O_ERR , arglist -> file , arglist -> line , "within parameter must be " "0 or a time value." ) ; } if ( ( arglist -> u . expr . right -> t == T_NUM ) && ( arglist -> u . expr . right -> u . ull != 0ULL ) ) { outfl ( O_ERR , arglist -> file , arglist -> line , "within parameter must be " "0 or a time value." ) ; } if ( ( arglist -> u . expr . right -> t == T_NAME ) && ( arglist -> u . expr . right -> u . name . s != L_infinity ) ) { outfl ( O_ERR , arglist -> file , arglist -> line , "\"infinity\" is the only " "valid name for within parameter." ) ; } if ( arglist -> u . expr . left -> u . ull > arglist -> u . expr . right -> u . ull ) { outfl ( O_ERR , arglist -> file , arglist -> line , "the first value (min) of" " within must be less than" " the second (max) value" ) ; } break ; case T_TIMEVAL : break ; default : outfl ( O_ERR , arglist -> file , arglist -> line , "parameter of within must be 0" ", \"infinity\" or a time value." ) ; } } if ( np -> u . func . s == L_call ) { if ( arglist -> t != T_QUOTE && arglist -> t != T_LIST && arglist -> t != T_GLOBID && arglist -> t != T_CONDIF && arglist -> t != T_LIST && arglist -> t != T_FUNC ) { outfl ( O_ERR , arglist -> file , arglist -> line , "invalid first argument to call()" ) ; } } if ( np -> u . func . s == L_fru ) { if ( arglist -> t != T_NAME ) { outfl ( O_ERR , arglist -> file , arglist -> line , "argument to fru() must be a path" ) ; } } if ( np -> u . func . s == L_asru ) { if ( arglist -> t != T_NAME ) { outfl ( O_ERR , arglist -> file , arglist -> line , "argument to asru() must be a path" ) ; } } if ( np -> u . func . s == L_is_connected || np -> u . func . s == L_is_under ) { if ( arglist -> t == T_LIST && ( arglist -> u . expr . left -> t == T_NAME || arglist -> u . expr . left -> t == T_FUNC ) && ( arglist -> u . expr . right -> t == T_NAME || arglist -> u . expr . right -> t == T_FUNC ) ) { if ( arglist -> u . expr . left -> t == T_FUNC ) { check_func ( arglist -> u . expr . left ) ; } if ( arglist -> u . expr . right -> t == T_FUNC ) { check_func ( arglist -> u . expr . right ) ; } } else { outfl ( O_ERR , arglist -> file , arglist -> line , "%s() must have paths or calls to " "fru() and/or asru() as arguments" , np -> u . func . s ) ; } } if ( np -> u . func . s == L_is_on ) { if ( arglist -> t == T_NAME || arglist -> t == T_FUNC ) { if ( arglist -> t == T_FUNC ) { check_func ( arglist ) ; } } else { outfl ( O_ERR , arglist -> file , arglist -> line , "argument to is_on() must be a path or a call to " "fru() or asru()" ) ; } } if ( np -> u . func . s == L_is_present ) { if ( arglist -> t == T_NAME || arglist -> t == T_FUNC ) { if ( arglist -> t == T_FUNC ) { check_func ( arglist ) ; } } else { outfl ( O_ERR , arglist -> file , arglist -> line , "argument to is_present() must be a path or a call " "to fru() or asru()" ) ; } } if ( np -> u . func . s == L_has_fault ) { if ( arglist -> t == T_LIST && ( arglist -> u . expr . left -> t == T_NAME || arglist -> u . expr . left -> t == T_FUNC ) && arglist -> u . expr . right -> t == T_QUOTE ) { if ( arglist -> u . expr . left -> t == T_FUNC ) { check_func ( arglist -> u . expr . left ) ; } } else { outfl ( O_ERR , arglist -> file , arglist -> line , "%s() must have path or call to " "fru() and/or asru() as first argument; " "second argument must be a string" , np -> u . func . s ) ; } } if ( np -> u . func . s == L_is_type ) { if ( arglist -> t == T_NAME || arglist -> t == T_FUNC ) { if ( arglist -> t == T_FUNC ) { check_func ( arglist ) ; } } else { outfl ( O_ERR , arglist -> file , arglist -> line , "argument to is_type() must be a path or a call to " "fru() or asru()" ) ; } } if ( np -> u . func . s == L_confcall ) { if ( arglist -> t != T_QUOTE && ( arglist -> t != T_LIST || arglist -> u . expr . left -> t != T_QUOTE ) ) { outfl ( O_ERR , arglist -> file , arglist -> line , "confcall(): first argument must be a string " "(the name of the operation)" ) ; } } if ( np -> u . func . s == L_confprop || np -> u . func . s == L_confprop_defined ) { if ( arglist -> t == T_LIST && ( arglist -> u . expr . left -> t == T_NAME || arglist -> u . expr . left -> t == T_FUNC ) && arglist -> u . expr . right -> t == T_QUOTE ) { if ( arglist -> u . expr . left -> t == T_FUNC ) { check_func ( arglist -> u . expr . left ) ; } } else { outfl ( O_ERR , arglist -> file , arglist -> line , "%s(): first argument must be a path or a call to " "fru() or asru(); " "second argument must be a string" , np -> u . func . s ) ; } } if ( np -> u . func . s == L_count ) { if ( arglist -> t != T_EVENT ) { outfl ( O_ERR , arglist -> file , arglist -> line , "count(): argument must be an engine name" ) ; } } if ( np -> u . func . s == L_defined ) { if ( arglist -> t != T_GLOBID ) { outfl ( O_ERR , arglist -> file , arglist -> line , "argument to defined() must be a global" ) ; } } if ( np -> u . func . s == L_payloadprop ) { if ( arglist -> t != T_QUOTE ) { outfl ( O_ERR , arglist -> file , arglist -> line , "argument to payloadprop() must be a string" ) ; } } if ( np -> u . func . s == L_payloadprop_contains ) { if ( arglist -> t != T_LIST || arglist -> u . expr . left -> t != T_QUOTE || arglist -> u . expr . right == NULL ) { outfl ( O_ERR , arglist -> file , arglist -> line , "args to payloadprop_contains(): must be a quoted " "string (property name) and an expression " "(to match)" ) ; } } if ( np -> u . func . s == L_payloadprop_defined ) { if ( arglist -> t != T_QUOTE ) { outfl ( O_ERR , arglist -> file , arglist -> line , "arg to payloadprop_defined(): must be a quoted " "string" ) ; } } if ( np -> u . func . s == L_setpayloadprop ) { if ( arglist -> t == T_LIST && arglist -> u . expr . left -> t == T_QUOTE ) { if ( arglist -> u . expr . right -> t == T_FUNC ) { check_func ( arglist -> u . expr . right ) ; } } else { outfl ( O_ERR , arglist -> file , arglist -> line , "setpayloadprop(): " "first arg must be a string, " "second arg a value" ) ; } } if ( np -> u . func . s == L_setserdn || np -> u . func . s == L_setserdt || np -> u . func . s == L_setserdsuffix || np -> u . func . s == L_setserdincrement ) { if ( arglist -> t == T_FUNC ) { check_func ( arglist ) ; } } if ( np -> u . func . s == L_cat ) { check_cat_list ( arglist ) ; } if ( np -> u . func . s == L_envprop ) { } else { outfl ( O_WARN , np -> file , np -> line , "possible platform-specific function: %s" , np -> u . func . s ) ; } } 