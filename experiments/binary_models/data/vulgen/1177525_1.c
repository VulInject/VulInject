static ssize_t musb_softconnect_write ( struct file * file , const char __user * ubuf , size_t count , loff_t * ppos ) { struct seq_file * s = file -> private_data ; struct musb * musb = s -> private ; char buf [ 2 ] ; u8 reg ; if ( copy_from_user ( & buf , ubuf , min_t ( size_t , sizeof ( buf ) - 1 , count ) ) ) { return - EFAULT ; } pm_runtime_get_sync ( musb -> controller ) ; if ( ! strncmp ( buf , "0" , 1 ) ) { switch ( musb_get_state ( musb ) ) { case OTG_STATE_A_HOST : musb_root_disconnect ( musb ) ; reg = musb_readb ( musb -> mregs , MUSB_DEVCTL ) ; reg &= ~ MUSB_DEVCTL_SESSION ; musb_writeb ( musb -> mregs , MUSB_DEVCTL , reg ) ; break ; default : break ; } } if ( ! strncmp ( buf , "1" , 1 ) ) { switch ( musb_get_state ( musb ) ) { case OTG_STATE_A_WAIT_BCON : musb -> context . devctl |= MUSB_DEVCTL_SESSION ; reg = musb_readb ( musb -> mregs , MUSB_DEVCTL ) ; reg |= MUSB_DEVCTL_SESSION ; musb_writeb ( musb -> mregs , MUSB_DEVCTL , reg ) ; break ; default : break ; } } pm_runtime_mark_last_busy ( musb -> controller ) ; pm_runtime_put_autosuspend ( musb -> controller ) ; return count ; } 