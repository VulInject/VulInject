extern char * get_local_script_path ( job * pjob , char * base ) u_long gettime ( resource * ) u_long getsize ( resource * ) int send_back_std_and_staged_files ( job * pjob , int exit_status ) void exit_mom_job ( job * pjob , int mom_radix ) void catch_child ( int sig ) { termin_child = 1 ; return ; } bool are_all_sisters_done ( job * pjob ) { bool done = true ; int num_nodes ; if ( pjob -> ji_radix > 1 ) { num_nodes = pjob -> ji_radix ; } else { num_nodes = pjob -> ji_numnodes ; } if ( LOGLEVEL >= 7 ) { char bf [ 40 ] ; sprintf ( bf , "num_nodes = %d" , num_nodes ) ; log_record ( PBSEVENT_DEBUG , PBS_EVENTCLASS_SERVER , __func__ , bf ) ; } for ( int i = 1 ; i < num_nodes ; i ++ ) { if ( pjob -> ji_hosts [ i ] . hn_sister == SISTER_OKAY ) { if ( LOGLEVEL >= 7 ) { char bf [ 400 ] ; sprintf ( bf , "nodes = %s is not done" , pjob -> ji_hosts [ i ] . hn_host ) ; log_record ( PBSEVENT_DEBUG , PBS_EVENTCLASS_SERVER , __func__ , bf ) ; } done = false ; break ; } } return ( done ) ; } hnodent * get_node ( job * pjob , tm_node_id nodeid ) { int i ; vnodent * vp = pjob -> ji_vnods ; for ( i = 0 ; i < pjob -> ji_numvnod ; i ++ , vp ++ ) { if ( vp -> vn_node == nodeid ) { return ( vp -> vn_host ) ; } } return ( NULL ) ; } int terminate_sisters ( job * pjob , int sig ) { int mom_radix ; int NumSisters ; mom_radix = pjob -> ji_wattr [ JOB_ATR_job_radix ] . at_val . at_long ; if ( mom_radix < 2 ) { NumSisters = send_sisters ( pjob , IM_KILL_JOB , FALSE ) ; if ( NumSisters > 0 ) { pjob -> ji_qs . ji_substate = JOB_SUBSTATE_MOM_WAIT ; pjob -> ji_kill_started = time ( NULL ) ; } } else { NumSisters = 1 ; if ( pjob -> ji_sampletim == 0 ) { pjob -> ji_sampletim = time ( NULL ) ; if ( ( pjob -> ji_qs . ji_svrflags & JOB_SVFLG_INTERMEDIATE_MOM ) == 0 ) { NumSisters = send_sisters ( pjob , IM_KILL_JOB_RADIX , TRUE ) ; pjob -> ji_outstanding = NumSisters ; } } else { time_t time_now ; time_now = time ( NULL ) ; if ( time_now - pjob -> ji_sampletim > 5 ) { if ( ( pjob -> ji_qs . ji_svrflags & JOB_SVFLG_INTERMEDIATE_MOM ) == 0 ) { NumSisters = send_sisters ( pjob , IM_KILL_JOB_RADIX , TRUE ) ; pjob -> ji_outstanding = NumSisters ; } } } } return ( PBSE_NONE ) ; } int send_task_obit_response ( job * pjob , hnodent * pnode , char * cookie , obitent * pobit , int exitstat ) { int i ; int ret ; int stream ; struct tcp_chan * chan = NULL ; for ( i = 0 ; i < 5 ; i ++ ) { ret = - 1 ; stream = tcp_connect_sockaddr ( ( sockaddr * ) & pnode -> sock_addr , sizeof ( pnode -> sock_addr ) , false ) ; if ( IS_VALID_STREAM ( stream ) ) { if ( ( chan = DIS_tcp_setup ( stream ) ) != NULL ) { if ( ( ret = im_compose ( chan , pjob -> ji_qs . ji_jobid , cookie , IM_ALL_OKAY , pobit -> oe_info . fe_event , pobit -> oe_info . fe_taskid ) ) != DIS_SUCCESS ) { } if ( ( ret = diswsi ( chan , exitstat ) ) != DIS_SUCCESS ) { } else { ret = DIS_tcp_wflush ( chan ) ; } DIS_tcp_close ( chan ) ; } else { close ( stream ) ; } } if ( stream == PERMANENT_SOCKET_FAIL ) { break ; } if ( ret == DIS_SUCCESS ) { break ; } usleep ( 10 ) ; } return ( ret ) ; } bool eligible_for_exiting_check ( job * pjob ) { if ( is_mom_server_down ( pjob -> ji_qs . ji_un . ji_momt . ji_svraddr ) ) { if ( LOGLEVEL >= 3 ) { snprintf ( log_buffer , sizeof ( log_buffer ) , "not checking job %s - server is down" , pjob -> ji_qs . ji_jobid ) ; log_record ( PBSEVENT_DEBUG , PBS_EVENTCLASS_SERVER , __func__ , log_buffer ) ; } return ( false ) ; } if ( pjob -> ji_flags & MOM_CHECKPOINT_ACTIVE ) { return ( false ) ; } if ( pjob -> ji_flags & MOM_CHECKPOINT_POST ) { checkpoint_partial ( pjob ) ; return ( false ) ; } if ( ! ( pjob -> ji_wattr [ JOB_ATR_Cookie ] . at_flags & ATR_VFLAG_SET ) ) { return ( false ) ; } return ( true ) ; } void check_jobs_main_process ( job * pjob , task * ptask ) { int mom_radix ; int NumSisters ; unsigned int momport = 0 ; if ( ( pjob -> ji_qs . ji_un . ji_momt . ji_exitstat != JOB_EXEC_OVERLIMIT_MEM ) && ( pjob -> ji_qs . ji_un . ji_momt . ji_exitstat != JOB_EXEC_OVERLIMIT_WT ) && ( pjob -> ji_qs . ji_un . ji_momt . ji_exitstat != JOB_EXEC_OVERLIMIT_CPUT ) ) { pjob -> ji_qs . ji_un . ji_momt . ji_exitstat = ptask -> ti_qs . ti_exitstat ; } log_event ( PBSEVENT_JOB , PBS_EVENTCLASS_JOB , pjob -> ji_qs . ji_jobid , "job was terminated" ) ; mom_radix = pjob -> ji_wattr [ JOB_ATR_job_radix ] . at_val . at_long ; if ( mom_radix < 2 ) { NumSisters = send_sisters ( pjob , IM_KILL_JOB , FALSE ) ; if ( NumSisters > 0 ) { pjob -> ji_qs . ji_substate = JOB_SUBSTATE_MOM_WAIT ; pjob -> ji_kill_started = time ( NULL ) ; } } else { NumSisters = 1 ; if ( pjob -> ji_sampletim == 0 ) { pjob -> ji_sampletim = time ( NULL ) ; if ( ( pjob -> ji_qs . ji_svrflags & JOB_SVFLG_INTERMEDIATE_MOM ) == 0 ) { NumSisters = send_sisters ( pjob , IM_KILL_JOB_RADIX , TRUE ) ; pjob -> ji_outstanding = NumSisters ; } } else { if ( time ( NULL ) - pjob -> ji_sampletim > 5 ) { if ( ( pjob -> ji_qs . ji_svrflags & JOB_SVFLG_INTERMEDIATE_MOM ) == 0 ) { NumSisters = send_sisters ( pjob , IM_KILL_JOB_RADIX , TRUE ) ; pjob -> ji_outstanding = NumSisters ; } } } pjob -> ji_qs . ji_substate = JOB_SUBSTATE_MOM_WAIT ; pjob -> ji_kill_started = time ( NULL ) ; } if ( NumSisters == 0 ) { if ( LOGLEVEL >= 3 ) { log_event ( PBSEVENT_JOB , PBS_EVENTCLASS_JOB , pjob -> ji_qs . ji_jobid , "no sisters contacted - setting job substate to EXITING" ) ; } pjob -> ji_qs . ji_substate = JOB_SUBSTATE_EXITING ; if ( multi_mom ) { momport = pbs_rm_port ; } job_save ( pjob , SAVEJOB_QUICK , momport ) ; } if ( LOGLEVEL >= 3 ) { snprintf ( log_buffer , sizeof ( log_buffer ) , "%s: master task has exited - sent kill job request to %d sisters" , __func__ , NumSisters ) ; log_event ( PBSEVENT_JOB , PBS_EVENTCLASS_JOB , pjob -> ji_qs . ji_jobid , log_buffer ) ; } } void process_tm_obits ( job * pjob , task * ptask , char * cookie ) { for ( unsigned int i = 0 ; i < ptask -> ti_obits . size ( ) ; i ++ ) { obitent & pobit = ptask -> ti_obits [ i ] ; hnodent * pnode ; pnode = get_node ( pjob , pobit . oe_info . fe_node ) ; if ( ( pnode != NULL ) && ( pjob -> ji_nodeid == pnode -> hn_node ) ) { task * tmp_task ; tmp_task = task_find ( pjob , pobit . oe_info . fe_taskid ) ; if ( ( tmp_task != NULL ) && ( tmp_task -> ti_chan != NULL ) ) { tm_reply ( tmp_task -> ti_chan , IM_ALL_OKAY , pobit . oe_info . fe_event ) ; diswsi ( tmp_task -> ti_chan , ptask -> ti_qs . ti_exitstat ) ; DIS_tcp_wflush ( tmp_task -> ti_chan ) ; } } else { if ( pnode != NULL ) { send_task_obit_response ( pjob , pnode , cookie , & pobit , ptask -> ti_qs . ti_exitstat ) ; } } } } void cleanup_task ( job * pjob , task * ptask ) { if ( ptask -> ti_chan != NULL ) { DIS_tcp_cleanup ( ptask -> ti_chan ) ; ptask -> ti_chan = NULL ; } ptask -> ti_qs . ti_status = TI_STATE_DEAD ; if ( LOGLEVEL >= 3 ) { log_event ( PBSEVENT_JOB , PBS_EVENTCLASS_JOB , pjob -> ji_qs . ji_jobid , "task is dead" ) ; } task_save ( ptask ) ; } void update_job_based_on_tasks ( job * pjob ) { if ( LOGLEVEL >= 6 ) { snprintf ( log_buffer , sizeof ( log_buffer ) , "Checking tasks for '%s'" , pjob -> ji_qs . ji_jobid ) ; log_record ( PBSEVENT_DEBUG , PBS_EVENTCLASS_SERVER , __func__ , log_buffer ) ; } for ( unsigned int i = 0 ; i < pjob -> ji_tasks -> size ( ) ; i ++ ) { task * ptask = pjob -> ji_tasks -> at ( i ) ; if ( ptask -> ti_qs . ti_status != TI_STATE_EXITED ) { continue ; } if ( ptask -> ti_qs . ti_parenttask == TM_NULL_TASK ) { check_jobs_main_process ( pjob , ptask ) ; } process_tm_obits ( pjob , ptask , pjob -> ji_wattr [ JOB_ATR_Cookie ] . at_val . at_str ) ; cleanup_task ( pjob , ptask ) ; } } bool is_job_state_exiting ( job * pjob ) { if ( ( pjob -> ji_qs . ji_substate != JOB_SUBSTATE_EXITING ) && ( pjob -> ji_qs . ji_substate != JOB_SUBSTATE_EXIT_WAIT ) && ( pjob -> ji_qs . ji_substate != JOB_SUBSTATE_NOTERM_REQUE ) ) { if ( LOGLEVEL >= 3 ) { snprintf ( log_buffer , sizeof ( log_buffer ) , "%s:job is in non-exiting substate %s, no obit sent at this time" , __func__ , PJobSubState [ pjob -> ji_qs . ji_substate ] ) ; log_event ( PBSEVENT_JOB , PBS_EVENTCLASS_JOB , pjob -> ji_qs . ji_jobid , log_buffer ) ; } if ( pjob -> ji_qs . ji_substate == JOB_SUBSTATE_EXITED ) { if ( pjob -> ji_tasks -> size ( ) == 0 ) { mom_deljob ( pjob ) ; } } return ( false ) ; } return ( true ) ; } 