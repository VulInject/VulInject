static void iwl_mvm_mac_ctxt_cmd_common ( struct iwl_mvm * mvm , struct ieee80211_vif * vif , struct iwl_mac_ctx_cmd * cmd , const u8 * bssid_override , u32 action ) { struct iwl_mvm_vif * mvmvif = iwl_mvm_vif_from_mac80211 ( vif ) ; struct ieee80211_chanctx_conf * chanctx ; bool ht_enabled = ! ! ( vif -> bss_conf . ht_operation_mode & IEEE80211_HT_OP_MODE_PROTECTION ) ; u8 cck_ack_rates , ofdm_ack_rates ; const u8 * bssid = bssid_override ?: vif -> bss_conf . bssid ; int i ; cmd -> id_and_color = cpu_to_le32 ( FW_CMD_ID_AND_COLOR ( mvmvif -> id , mvmvif -> color ) ) ; cmd -> action = cpu_to_le32 ( action ) ; switch ( vif -> type ) { case NL80211_IFTYPE_STATION : if ( vif -> p2p ) { cmd -> mac_type = cpu_to_le32 ( FW_MAC_TYPE_P2P_STA ) ; } else { cmd -> mac_type = cpu_to_le32 ( FW_MAC_TYPE_BSS_STA ) ; } break ; case NL80211_IFTYPE_AP : cmd -> mac_type = cpu_to_le32 ( FW_MAC_TYPE_GO ) ; break ; case NL80211_IFTYPE_MONITOR : cmd -> mac_type = cpu_to_le32 ( FW_MAC_TYPE_LISTENER ) ; break ; case NL80211_IFTYPE_P2P_DEVICE : cmd -> mac_type = cpu_to_le32 ( FW_MAC_TYPE_P2P_DEVICE ) ; break ; case NL80211_IFTYPE_ADHOC : cmd -> mac_type = cpu_to_le32 ( FW_MAC_TYPE_IBSS ) ; break ; default : WARN_ON_ONCE ( 1 ) ; } cmd -> tsf_id = cpu_to_le32 ( mvmvif -> tsf_id ) ; memcpy ( cmd -> node_addr , vif -> addr , ETH_ALEN ) ; if ( bssid ) { memcpy ( cmd -> bssid_addr , bssid , ETH_ALEN ) ; } else { eth_broadcast_addr ( cmd -> bssid_addr ) ; } rcu_read_lock ( ) ; chanctx = rcu_dereference ( vif -> bss_conf . chanctx_conf ) ; iwl_mvm_ack_rates ( mvm , vif , chanctx ?chanctx -> def . chan -> band : NL80211_BAND_2GHZ , & cck_ack_rates , & ofdm_ack_rates ) ; rcu_read_unlock ( ) ; cmd -> cck_rates = cpu_to_le32 ( ( u32 ) cck_ack_rates ) ; cmd -> ofdm_rates = cpu_to_le32 ( ( u32 ) ofdm_ack_rates ) ; cmd -> cck_short_preamble = cpu_to_le32 ( vif -> bss_conf . use_short_preamble ?MAC_FLG_SHORT_PREAMBLE : 0 ) ; cmd -> short_slot = cpu_to_le32 ( vif -> bss_conf . use_short_slot ?MAC_FLG_SHORT_SLOT : 0 ) ; cmd -> filter_flags = 0 ; for ( i = 0 ; i < IEEE80211_NUM_ACS ; i ++ ) { u8 txf = iwl_mvm_mac_ac_to_tx_fifo ( mvm , i ) ; u8 ucode_ac = iwl_mvm_mac80211_ac_to_ucode_ac ( i ) ; cmd -> ac [ ucode_ac ] . cw_min = cpu_to_le16 ( mvmvif -> queue_params [ i ] . cw_min ) ; cmd -> ac [ ucode_ac ] . cw_max = cpu_to_le16 ( mvmvif -> queue_params [ i ] . cw_max ) ; cmd -> ac [ ucode_ac ] . edca_txop = cpu_to_le16 ( mvmvif -> queue_params [ i ] . txop * 32 ) ; cmd -> ac [ ucode_ac ] . aifsn = mvmvif -> queue_params [ i ] . aifs ; cmd -> ac [ ucode_ac ] . fifos_mask = BIT ( txf ) ; } if ( vif -> bss_conf . qos ) { cmd -> qos_flags |= cpu_to_le32 ( MAC_QOS_FLG_UPDATE_EDCA ) ; } if ( vif -> bss_conf . use_cts_prot ) { cmd -> protection_flags |= cpu_to_le32 ( MAC_PROT_FLG_TGG_PROTECT ) ; } IWL_DEBUG_RATE ( mvm , "use_cts_prot %d, ht_operation_mode %d\n" , vif -> bss_conf . use_cts_prot , vif -> bss_conf . ht_operation_mode ) ; if ( ht_enabled ) { iwl_mvm_mac_ctxt_set_ht_flags ( mvm , vif , cmd ) ; } } 