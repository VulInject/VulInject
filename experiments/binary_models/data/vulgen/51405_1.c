static int libxlStateInitialize ( bool privileged , const char * root , bool monolithic G_GNUC_UNUSED , virStateInhibitCallback callback , void * opaque ) { libxlDriverConfig * cfg ; g_autofree char * driverConf = NULL ; bool autostart = true ; if ( root != NULL ) { virReportError ( VIR_ERR_INVALID_ARG , "%s" , _ ( "Driver does not support embedded mode" ) ) ; return - 1 ; } if ( ! libxlDriverShouldLoad ( privileged ) ) { return VIR_DRV_STATE_INIT_SKIPPED ; } libxl_driver -> lockFD = - 1 ; if ( virMutexInit ( & libxl_driver -> lock ) < 0 ) { virReportError ( VIR_ERR_INTERNAL_ERROR , "%s" , _ ( "cannot initialize mutex" ) ) ; VIR_FREE ( libxl_driver ) ; return VIR_DRV_STATE_INIT_ERROR ; } libxl_driver -> inhibitCallback = callback ; libxl_driver -> inhibitOpaque = opaque ; if ( ! ( libxl_driver -> reservedGraphicsPorts = virPortAllocatorRangeNew ( _ ( "VNC" ) , LIBXL_VNC_PORT_MIN , LIBXL_VNC_PORT_MAX ) ) ) { error } if ( ! ( libxl_driver -> migrationPorts = virPortAllocatorRangeNew ( _ ( "migration" ) , LIBXL_MIGRATION_PORT_MIN , LIBXL_MIGRATION_PORT_MAX ) ) ) { error } if ( ! ( libxl_driver -> domains = virDomainObjListNew ( ) ) ) { error } if ( ! ( libxl_driver -> hostdevMgr = virHostdevManagerGetDefault ( ) ) ) { error } if ( ! ( cfg = libxlDriverConfigNew ( ) ) ) { error } if ( libxlDriverConfigInit ( cfg ) < 0 ) { error } driverConf = g_strdup_printf ( "%s/libxl.conf" , cfg -> configBaseDir ) ; if ( libxlDriverConfigLoadFile ( cfg , driverConf ) < 0 ) { error } libxl_osevent_register_hooks ( cfg -> ctx , & libxl_osevent_callbacks , cfg -> ctx ) ; libxl_childproc_setmode ( cfg -> ctx , & libxl_child_hooks , cfg -> ctx ) ; libxl_event_register_callbacks ( cfg -> ctx , & ev_hooks , libxl_driver ) ; libxl_driver -> config = cfg ; if ( g_mkdir_with_parents ( cfg -> stateDir , 0777 ) < 0 ) { virReportSystemError ( errno , _ ( "failed to create state dir '%s'" ) , cfg -> stateDir ) ; error } if ( g_mkdir_with_parents ( cfg -> libDir , 0777 ) < 0 ) { virReportSystemError ( errno , _ ( "failed to create lib dir '%s'" ) , cfg -> libDir ) ; error } if ( g_mkdir_with_parents ( cfg -> saveDir , 0777 ) < 0 ) { virReportSystemError ( errno , _ ( "failed to create save dir '%s'" ) , cfg -> saveDir ) ; error } if ( g_mkdir_with_parents ( cfg -> autoDumpDir , 0777 ) < 0 ) { virReportSystemError ( errno , _ ( "failed to create dump dir '%s'" ) , cfg -> autoDumpDir ) ; error } if ( g_mkdir_with_parents ( cfg -> channelDir , 0777 ) < 0 ) { virReportSystemError ( errno , _ ( "failed to create channel dir '%s'" ) , cfg -> channelDir ) ; error } if ( ( libxl_driver -> lockFD = virPidFileAcquire ( cfg -> stateDir , "driver" , false , getpid ( ) ) ) < 0 ) { error } if ( ! ( libxl_driver -> lockManager = virLockManagerPluginNew ( cfg -> lockManagerName ?cfg -> lockManagerName : "nop" , "libxl" , cfg -> configBaseDir , 0 ) ) ) { error } libxl_driver -> hostsysinfo = virSysinfoRead ( ) ; libxl_driver -> domainEventState = virObjectEventStateNew ( ) ; if ( ! libxl_driver -> domainEventState ) { error } if ( ( cfg -> caps = libxlMakeCapabilities ( cfg -> ctx ) ) == NULL ) { virReportError ( VIR_ERR_INTERNAL_ERROR , "%s" , _ ( "cannot create capabilities for libxenlight" ) ) ; error } if ( ! ( libxl_driver -> xmlopt = libxlCreateXMLConf ( libxl_driver ) ) ) { error } if ( virDomainObjListLoadAllConfigs ( libxl_driver -> domains , cfg -> stateDir , cfg -> autostartDir , true , libxl_driver -> xmlopt , NULL , NULL ) < 0 ) { error } if ( libxlAddDom0 ( libxl_driver ) < 0 ) { error } libxlReconnectDomains ( libxl_driver ) ; if ( virDomainObjListLoadAllConfigs ( libxl_driver -> domains , cfg -> configDir , cfg -> autostartDir , false , libxl_driver -> xmlopt , NULL , NULL ) < 0 ) { error } if ( virDriverShouldAutostart ( cfg -> stateDir , & autostart ) < 0 ) { error } if ( autostart ) { virDomainObjListForEach ( libxl_driver -> domains , false , libxlAutostartDomain , libxl_driver ) ; } virDomainObjListForEach ( libxl_driver -> domains , false , libxlDomainManagedSaveLoad , libxl_driver ) ; return VIR_DRV_STATE_INIT_COMPLETE ; error libxlStateCleanup ( ) ; return VIR_DRV_STATE_INIT_ERROR ; } 