static NODE * clean_stopword_intree ( NODE * node , int * ladd , int * radd ) { * ladd = * radd = 0 ; if ( node -> valnode -> type == QI_VAL ) { return node ; } if ( node -> valnode -> type == QI_VALSTOP ) { pfree ( node ) ; return NULL ; } Assert ( node -> valnode -> type == QI_OPR ) ; if ( node -> valnode -> qoperator . oper == OP_NOT ) { node -> right = clean_stopword_intree ( node -> right , ladd , radd ) ; if ( ! node -> right ) { freetree ( node ) ; return NULL ; } } else { NODE * res = node ; bool isphrase ; int ndistance , lladd , lradd , rladd , rradd ; node -> left = clean_stopword_intree ( node -> left , & lladd , & lradd ) ; node -> right = clean_stopword_intree ( node -> right , & rladd , & rradd ) ; isphrase = ( node -> valnode -> qoperator . oper == OP_PHRASE ) ; ndistance = isphrase ?node -> valnode -> qoperator . distance : 0 ; if ( node -> left == NULL && node -> right == NULL ) { if ( isphrase ) { * ladd = * radd = lladd + ndistance + rladd ; } else { * ladd = * radd = Max ( lladd , rladd ) ; } freetree ( node ) ; return NULL ; } if ( node -> left == NULL ) { if ( isphrase ) { * ladd = lladd + ndistance + rladd ; * radd = rradd ; } else { * ladd = rladd ; * radd = rradd ; } res = node -> right ; pfree ( node ) ; } if ( node -> right == NULL ) { if ( isphrase ) { * ladd = lladd ; * radd = lradd + ndistance + rradd ; } else { * ladd = lladd ; * radd = lradd ; } res = node -> left ; pfree ( node ) ; } if ( isphrase ) { node -> valnode -> qoperator . distance += lradd + rladd ; * ladd = lladd ; * radd = rradd ; } else { } return res ; } return node ; } 