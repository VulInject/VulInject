M_io_layer_t * M_io_layer_add ( M_io_t * comm , const char * layer_name , M_io_handle_t * handle , const M_io_callbacks_t * callbacks ) { M_io_layer_t * layer ; if ( comm == NULL || layer_name == NULL || handle == NULL || callbacks == NULL ) { return NULL ; } M_io_lock ( comm ) ; if ( comm -> type == M_IO_TYPE_EVENT && M_list_len ( comm -> layer ) == 1 ) { M_io_unlock ( comm ) ; return NULL ; } if ( M_list_len ( comm -> layer ) == M_IO_LAYERS_MAX - 1 ) { M_io_unlock ( comm ) ; return NULL ; } layer = M_malloc_zero ( sizeof ( * layer ) ) ; layer -> comm = comm ; layer -> idx = M_list_len ( comm -> layer ) ; layer -> name = M_strdup ( layer_name ) ; layer -> handle = handle ; M_mem_copy ( & layer -> cb , callbacks , sizeof ( layer -> cb ) ) ; if ( comm -> reg_event != NULL && layer -> cb . cb_init != NULL ) { if ( ! layer -> cb . cb_init ( layer ) ) { M_io_unlock ( comm ) ; M_free ( layer ) ; return NULL ; } } M_list_insert ( comm -> layer , layer ) ; if ( M_io_get_layer_state ( comm , layer -> idx - 1 ) == M_IO_STATE_CONNECTED ) { M_io_layer_softevent_add ( layer , M_FALSE , M_EVENT_TYPE_CONNECTED , M_IO_ERROR_SUCCESS ) ; } M_io_unlock ( comm ) ; return layer ; } 