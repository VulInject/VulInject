static GF_Err mp4_mux_process_item ( GF_MP4MuxCtx * ctx , TrackWriter * tkw , GF_FilterPacket * pck ) { GF_Err e ; u32 meta_type , item_id , size , item_type , nb_items , media_brand = GF_ISOM_BRAND_HEIF ; GF_ImageItemProperties image_props ; GF_ImageItemProtection cenc_info ; const char * data , * item_name = NULL ; const GF_PropertyValue * p , * dsi , * dsi_enh ; GF_Box * config_box = NULL ; if ( ctx -> init_movie_done ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "[MP4Mux] Cannot add item to a finalized movie, not supported\n" ) ) ; return GF_NOT_SUPPORTED ; } if ( tkw -> stream_type != GF_STREAM_VISUAL ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "[MP4Mux] Cannot add item other than visual, not supported - use MP4Box for this\n" ) ) ; return GF_NOT_SUPPORTED ; } ctx -> update_report = GF_TRUE ; meta_type = gf_isom_get_meta_type ( ctx -> file , GF_TRUE , 0 ) ; if ( ! meta_type ) { e = gf_isom_set_meta_type ( ctx -> file , GF_TRUE , 0 , GF_META_ITEM_TYPE_PICT ) ; } if ( meta_type != GF_META_ITEM_TYPE_PICT ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "[MP4Mux] File already has a root 'meta' box of type %s\n" , gf_4cc_to_str ( meta_type ) ) ) ; e = GF_BAD_PARAM ; } else { e = GF_OK ; } if ( e ) { return e ; } data = ( char * ) gf_filter_pck_get_data ( pck , & size ) ; if ( ! data ) { if ( gf_filter_pck_get_frame_interface ( pck ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "[MP4Mux] Cannot add items from raw decoder outputs, not supported\n" ) ) ; return GF_NOT_SUPPORTED ; } return GF_OK ; } ctx -> total_bytes_in += size ; ctx -> total_samples ++ ; item_id = 0 ; p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_ITEM_ID ) ; if ( p ) { item_id = p -> value . uint ; } item_name = "Image" ; p = gf_filter_pid_get_property_str ( tkw -> ipid , "meta:name" ) ; if ( p && p -> value . string ) { item_name = p -> value . string ; } memset ( & image_props , 0 , sizeof ( GF_ImageItemProperties ) ) ; dsi = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_DECODER_CONFIG ) ; dsi_enh = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT ) ; switch ( tkw -> codecid ) { case GF_CODECID_AVC : case GF_ISOM_SUBTYPE_SVC_H264 : case GF_ISOM_SUBTYPE_MVC_H264 : if ( ! dsi ) { return GF_OK ; } if ( tkw -> codecid == GF_CODECID_AVC ) { config_box = gf_isom_box_new ( GF_ISOM_BOX_TYPE_AVCC ) ; item_type = GF_ISOM_SUBTYPE_AVC_H264 ; } if ( tkw -> codecid == GF_CODECID_MVC ) { config_box = gf_isom_box_new ( GF_ISOM_BOX_TYPE_MVCC ) ; item_type = GF_ISOM_SUBTYPE_MVC_H264 ; if ( dsi_enh ) { dsi = dsi_enh ; } } else { config_box = gf_isom_box_new ( GF_ISOM_BOX_TYPE_SVCC ) ; item_type = GF_ISOM_SUBTYPE_SVC_H264 ; if ( dsi_enh ) { dsi = dsi_enh ; } } ( ( GF_AVCConfigurationBox * ) config_box ) -> config = gf_odf_avc_cfg_read ( dsi -> value . data . ptr , dsi -> value . data . size ) ; if ( ! ( ( GF_AVCConfigurationBox * ) config_box ) -> config ) { return GF_NON_COMPLIANT_BITSTREAM ; } image_props . num_channels = 3 ; image_props . bits_per_channel [ 0 ] = ( ( GF_AVCConfigurationBox * ) config_box ) -> config -> luma_bit_depth ; image_props . bits_per_channel [ 1 ] = ( ( GF_AVCConfigurationBox * ) config_box ) -> config -> chroma_bit_depth ; image_props . bits_per_channel [ 2 ] = ( ( GF_AVCConfigurationBox * ) config_box ) -> config -> chroma_bit_depth ; media_brand = GF_ISOM_BRAND_AVCI ; break ; case GF_CODECID_HEVC : case GF_CODECID_HEVC_TILES : case GF_CODECID_LHVC : if ( tkw -> codecid == GF_CODECID_LHVC ) { if ( dsi_enh ) { dsi = dsi_enh ; } if ( ! dsi ) { return GF_OK ; } } config_box = gf_isom_box_new ( GF_ISOM_BOX_TYPE_HVCC ) ; if ( dsi_enh ) { ( ( GF_HEVCConfigurationBox * ) config_box ) -> config = gf_odf_hevc_cfg_read ( dsi -> value . data . ptr , dsi -> value . data . size , GF_TRUE ) ; item_type = GF_ISOM_SUBTYPE_LHV1 ; } else { if ( ( tkw -> codecid == GF_CODECID_HEVC ) && ! dsi ) { return GF_OK ; } ( ( GF_HEVCConfigurationBox * ) config_box ) -> config = gf_odf_hevc_cfg_read ( dsi -> value . data . ptr , dsi -> value . data . size , GF_FALSE ) ; item_type = ( tkw -> codecid == GF_CODECID_HEVC_TILES ) ?GF_ISOM_SUBTYPE_HVT1 : GF_ISOM_SUBTYPE_HVC1 ; } if ( ! ( ( GF_HEVCConfigurationBox * ) config_box ) -> config ) { if ( ( tkw -> codecid != GF_CODECID_HEVC_TILES ) && ! dsi ) { return GF_NON_COMPLIANT_BITSTREAM ; } } else { image_props . num_channels = 3 ; image_props . bits_per_channel [ 0 ] = ( ( GF_HEVCConfigurationBox * ) config_box ) -> config -> luma_bit_depth ; image_props . bits_per_channel [ 1 ] = ( ( GF_HEVCConfigurationBox * ) config_box ) -> config -> chroma_bit_depth ; image_props . bits_per_channel [ 2 ] = ( ( GF_HEVCConfigurationBox * ) config_box ) -> config -> chroma_bit_depth ; } media_brand = GF_ISOM_BRAND_HEIC ; if ( tkw -> codecid == GF_CODECID_LHVC ) { media_brand = GF_ISOM_BRAND_HEIM ; } break ; case GF_CODECID_AV1 : if ( ! dsi ) { return GF_OK ; } config_box = gf_isom_box_new ( GF_ISOM_BOX_TYPE_AV1C ) ; ( ( GF_AV1ConfigurationBox * ) config_box ) -> config = gf_odf_av1_cfg_read ( dsi -> value . data . ptr , dsi -> value . data . size ) ; if ( ! ( ( GF_AV1ConfigurationBox * ) config_box ) -> config ) { return GF_NON_COMPLIANT_BITSTREAM ; } item_type = GF_ISOM_SUBTYPE_AV01 ; u8 depth = ( ( GF_AV1ConfigurationBox * ) config_box ) -> config -> high_bitdepth ?( ( ( GF_AV1ConfigurationBox * ) config_box ) -> config -> twelve_bit ?12 : 10 ) else 8 ; if ( ( ( GF_AV1ConfigurationBox * ) config_box ) -> config -> monochrome ) { image_props . num_channels = 1 ; image_props . bits_per_channel [ 0 ] = depth ; image_props . bits_per_channel [ 1 ] = 0 ; image_props . bits_per_channel [ 2 ] = 0 ; } else { image_props . num_channels = 3 ; image_props . bits_per_channel [ 0 ] = depth ; image_props . bits_per_channel [ 1 ] = depth ; image_props . bits_per_channel [ 2 ] = depth ; } media_brand = GF_ISOM_BRAND_AVIF ; break ; case GF_CODECID_JPEG : item_type = GF_ISOM_SUBTYPE_JPEG ; media_brand = GF_ISOM_SUBTYPE_JPEG ; break ; case GF_CODECID_J2K : item_type = GF_ISOM_SUBTYPE_JP2K ; media_brand = GF_4CC ( 'j' , '2' , 'k' , 'i' ) ; break ; case GF_CODECID_PNG : item_type = GF_ISOM_SUBTYPE_PNG ; media_brand = GF_ISOM_SUBTYPE_PNG ; break ; case GF_CODECID_VVC : config_box = gf_isom_box_new ( GF_ISOM_BOX_TYPE_VVCC ) ; if ( ( tkw -> codecid == GF_CODECID_VVC ) && ! dsi ) { return GF_OK ; } ( ( GF_VVCConfigurationBox * ) config_box ) -> config = gf_odf_vvc_cfg_read ( dsi -> value . data . ptr , dsi -> value . data . size ) ; item_type = GF_ISOM_SUBTYPE_VVC1 ; if ( ! ( ( GF_VVCConfigurationBox * ) config_box ) -> config ) { return GF_NON_COMPLIANT_BITSTREAM ; } else { image_props . num_channels = 3 ; image_props . bits_per_channel [ 0 ] = ( ( GF_VVCConfigurationBox * ) config_box ) -> config -> bit_depth ; image_props . bits_per_channel [ 1 ] = ( ( GF_VVCConfigurationBox * ) config_box ) -> config -> bit_depth ; image_props . bits_per_channel [ 2 ] = ( ( GF_VVCConfigurationBox * ) config_box ) -> config -> bit_depth ; } media_brand = GF_ISOM_BRAND_VVIC ; break ; case GF_CODECID_RAW : p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_PIXFMT ) ; if ( p && ( p -> value . uint == GF_PIXEL_UNCV ) ) { image_props . config_ba = dsi -> value . data . ptr ; image_props . config_ba_size = dsi -> value . data . size ; item_type = GF_4CC ( 'u' , 'n' , 'c' , 'i' ) ; break ; } default : GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "Error: Codec %s not supported to create HEIF image items\n" , gf_codecid_name ( tkw -> codecid ) ) ) ; return GF_NOT_SUPPORTED ; } p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_WIDTH ) ; if ( p ) { image_props . width = p -> value . uint ; } p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_HEIGHT ) ; if ( p ) { image_props . height = p -> value . uint ; } p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_ALPHA ) ; if ( p ) { image_props . alpha = p -> value . boolean ; } p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_SAR ) ; if ( p ) { image_props . hSpacing = p -> value . frac . num ; image_props . vSpacing = p -> value . frac . den ; } else { image_props . hSpacing = image_props . vSpacing = 1 ; } image_props . config = config_box ; p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_HIDDEN ) ; if ( p ) { image_props . hidden = p -> value . boolean ; } p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_MIRROR ) ; if ( p && p -> value . uint ) { image_props . mirror = p -> value . uint ; } p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_ROTATE ) ; if ( p ) { image_props . angle = p -> value . uint ; } p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_CLAP_W ) ; if ( p ) { image_props . clap_wnum = p -> value . frac . num ; image_props . clap_wden = p -> value . frac . den ; } p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_CLAP_H ) ; if ( p ) { image_props . clap_hnum = p -> value . frac . num ; image_props . clap_hden = p -> value . frac . den ; } p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_CLAP_X ) ; if ( p ) { image_props . clap_honum = p -> value . frac . num ; image_props . clap_hoden = p -> value . frac . den ; } p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_CLAP_Y ) ; if ( p ) { image_props . clap_vonum = p -> value . frac . num ; image_props . clap_voden = p -> value . frac . den ; } nb_items = gf_isom_get_meta_item_count ( ctx -> file , GF_TRUE , 0 ) ; e = gf_isom_add_meta_item_memory ( ctx -> file , GF_TRUE , 0 , item_name , & item_id , item_type , NULL , NULL , & image_props , ( u8 * ) data , size , NULL ) ; if ( config_box ) { gf_isom_box_del ( config_box ) ; } if ( e ) { return e ; } gf_isom_get_meta_item_info ( ctx -> file , GF_TRUE , 0 , nb_items + 1 , & item_id , NULL , NULL , NULL , NULL , NULL , NULL , NULL , NULL , NULL ) ; tkw -> item_id = item_id ; p = gf_filter_pid_get_property ( tkw -> ipid , GF_PROP_PID_PRIMARY_ITEM ) ; if ( p && p -> value . boolean ) { e = gf_isom_set_meta_primary_item ( ctx -> file , GF_TRUE , 0 , item_id ) ; if ( e ) { return e ; } } if ( ! gf_isom_get_meta_primary_item_id ( ctx -> file , GF_TRUE , 0 ) ) { e = gf_isom_set_meta_primary_item ( ctx -> file , GF_TRUE , 0 , item_id ) ; if ( e ) { return e ; } } if ( ! ctx -> major_brand_set ) { gf_isom_set_brand_info ( ctx -> file , GF_ISOM_BRAND_MIF1 , 0 ) ; gf_isom_reset_alt_brands ( ctx -> file ) ; ctx -> major_brand_set = 2 ; } if ( media_brand && ( ctx -> major_brand_set == 2 ) ) { gf_isom_modify_alternate_brand ( ctx -> file , media_brand , 1 ) ; } if ( e == GF_OK && meta -> ref_type ) { e = gf_isom_meta_add_item_ref ( file , meta -> root_meta , tk , meta -> item_id , meta -> ref_item_id , meta -> ref_type , NULL ) ; } return GF_OK ; } 