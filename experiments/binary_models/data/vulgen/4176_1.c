static struct sk_buff * create_monitor_ctrl_open ( struct sock * sk ) { struct hci_mon_hdr * hdr ; struct sk_buff * skb ; u16 format ; u8 ver [ 3 ] ; u32 flags ; if ( ! hci_pi ( sk ) -> cookie ) { return NULL ; } switch ( hci_pi ( sk ) -> channel ) { case HCI_CHANNEL_RAW : format = 0x0000 ; ver [ 0 ] = BT_SUBSYS_VERSION ; put_unaligned_le16 ( BT_SUBSYS_REVISION , ver + 1 ) ; break ; case HCI_CHANNEL_USER : format = 0x0001 ; ver [ 0 ] = BT_SUBSYS_VERSION ; put_unaligned_le16 ( BT_SUBSYS_REVISION , ver + 1 ) ; break ; case HCI_CHANNEL_CONTROL : format = 0x0002 ; mgmt_fill_version_info ( ver ) ; break ; default : return NULL ; } skb = bt_skb_alloc ( 14 + TASK_COMM_LEN , GFP_ATOMIC ) ; if ( ! skb ) { return NULL ; } flags = hci_sock_test_flag ( sk , HCI_SOCK_TRUSTED ) ?0x1 : 0x0 ; put_unaligned_le32 ( hci_pi ( sk ) -> cookie , skb_put ( skb , 4 ) ) ; put_unaligned_le16 ( format , skb_put ( skb , 2 ) ) ; memcpy ( skb_put ( skb , sizeof ( ver ) ) , ver , sizeof ( ver ) ) ; put_unaligned_le32 ( flags , skb_put ( skb , 4 ) ) ; * skb_put ( skb , 1 ) = TASK_COMM_LEN ; memcpy ( skb_put ( skb , TASK_COMM_LEN ) , hci_pi ( sk ) -> comm , TASK_COMM_LEN ) ; __net_timestamp ( skb ) ; hdr = ( void * ) skb_push ( skb , HCI_MON_HDR_SIZE ) ; hdr -> opcode = cpu_to_le16 ( HCI_MON_CTRL_OPEN ) ; else { hdr -> index = cpu_to_le16 ( HCI_DEV_NONE ) ; } hdr -> len = cpu_to_le16 ( skb -> len - HCI_MON_HDR_SIZE ) ; return skb ; } 