allocate_dynrelocs ( , ) struct elf_link_hash_entry * h ; PTR inf ; { struct bfd_link_info * info ; struct elf_s390_link_hash_table * htab ; struct elf_s390_link_hash_entry * eh ; struct elf_s390_dyn_relocs * p ; if ( h -> root . type == bfd_link_hash_indirect ) { return TRUE ; } if ( h -> root . type == bfd_link_hash_warning ) { h = ( elf_link_hash_entry * ) h -> root . u . i . link ; } info = ( bfd_link_info * ) inf ; htab = elf_s390_hash_table ( info ) ; if ( htab -> elf . dynamic_sections_created && h -> plt . refcount > 0 && ( ELF_ST_VISIBILITY ( h -> other ) == STV_DEFAULT || h -> root . type != bfd_link_hash_undefweak ) ) { if ( h -> dynindx == - 1 && ! h -> forced_local ) { if ( ! bfd_elf_link_record_dynamic_symbol ( info , h ) ) { return FALSE ; } } if ( info -> shared || WILL_CALL_FINISH_DYNAMIC_SYMBOL ( 1 , 0 , h ) ) { asection * s = htab -> splt ; if ( s -> size == 0 ) { s -> size += PLT_FIRST_ENTRY_SIZE ; } h -> plt . offset = s -> size ; if ( ! info -> shared && ! h -> def_regular ) { h -> root . u . def . section = s ; h -> root . u . def . value = h -> plt . offset ; } s -> size += PLT_ENTRY_SIZE ; htab -> sgotplt -> size += GOT_ENTRY_SIZE ; htab -> srelplt -> size += sizeof ( Elf32_External_Rela ) ; } else { h -> plt . offset = ( bfd_vma ) - 1 ; h -> needs_plt = 0 ; elf_s390_adjust_gotplt ( ( elf_s390_link_hash_entry * ) h ) ; } } else { h -> plt . offset = ( bfd_vma ) - 1 ; h -> needs_plt = 0 ; elf_s390_adjust_gotplt ( ( elf_s390_link_hash_entry * ) h ) ; } if ( h -> got . refcount > 0 && ! info -> shared && h -> dynindx == - 1 && elf_s390_hash_entry ( h ) -> tls_type >= GOT_TLS_IE ) { if ( elf_s390_hash_entry ( h ) -> tls_type == GOT_TLS_IE_NLT ) { h -> got . offset = htab -> sgot -> size ; htab -> sgot -> size += GOT_ENTRY_SIZE ; } else { h -> got . offset = ( bfd_vma ) - 1 ; } } if ( h -> got . refcount > 0 ) { asection * s ; bfd_boolean dyn ; int tls_type = elf_s390_hash_entry ( h ) -> tls_type ; if ( h -> dynindx == - 1 && ! h -> forced_local ) { if ( ! bfd_elf_link_record_dynamic_symbol ( info , h ) ) { return FALSE ; } } s = htab -> sgot ; h -> got . offset = s -> size ; s -> size += GOT_ENTRY_SIZE ; if ( tls_type == GOT_TLS_GD ) { s -> size += GOT_ENTRY_SIZE ; } dyn = htab -> elf . dynamic_sections_created ; if ( ( tls_type == GOT_TLS_GD && h -> dynindx == - 1 ) || tls_type >= GOT_TLS_IE ) { htab -> srelgot -> size += sizeof ( Elf32_External_Rela ) ; } if ( tls_type == GOT_TLS_GD ) { htab -> srelgot -> size += 2 * sizeof ( Elf32_External_Rela ) ; } if ( ( ELF_ST_VISIBILITY ( h -> other ) == STV_DEFAULT || h -> root . type != bfd_link_hash_undefweak ) && ( info -> shared || WILL_CALL_FINISH_DYNAMIC_SYMBOL ( dyn , 0 , h ) ) ) { htab -> srelgot -> size += sizeof ( Elf32_External_Rela ) ; } } else { h -> got . offset = ( bfd_vma ) - 1 ; } eh = ( elf_s390_link_hash_entry * ) h ; if ( info -> shared ) { if ( SYMBOL_REFERENCES_LOCAL ( info , h ) ) { struct elf_s390_dyn_relocs * * pp ; for ( pp = & eh -> dyn_relocs ; ( p = * pp ) != NULL ; ) { p -> count -= p -> pc_count ; p -> pc_count = 0 ; if ( p -> count == 0 ) { * pp = p -> next ; } else { pp = & p -> next ; } } } if ( eh -> dyn_relocs != NULL && h -> root . type == bfd_link_hash_undefweak ) { if ( ELF_ST_VISIBILITY ( h -> other ) != STV_DEFAULT ) { eh -> dyn_relocs = NULL ; } if ( h -> dynindx == - 1 && ! h -> forced_local ) { if ( ! bfd_elf_link_record_dynamic_symbol ( info , h ) ) { return FALSE ; } } } } if ( ELIMINATE_COPY_RELOCS ) { if ( ! h -> non_got_ref && ( ( h -> def_dynamic && ! h -> def_regular ) || ( htab -> elf . dynamic_sections_created && ( h -> root . type == bfd_link_hash_undefweak || h -> root . type == bfd_link_hash_undefined ) ) ) ) { if ( h -> dynindx == - 1 && ! h -> forced_local ) { if ( ! bfd_elf_link_record_dynamic_symbol ( info , h ) ) { return FALSE ; } } if ( h -> dynindx != - 1 ) { keep } } eh -> dyn_relocs = NULL ; keep } for ( p = eh -> dyn_relocs ; p != NULL ; p = p -> next ) { asection * sreloc = elf_section_data ( p -> sec ) -> sreloc ; sreloc -> size += p -> count * sizeof ( Elf32_External_Rela ) ; } return TRUE ; } 