static void lba_fixup_bus ( struct pci_bus * bus ) { struct pci_dev * dev ; u16 status ; struct lba_device * ldev = LBA_DEV ( parisc_walk_tree ( bus -> bridge ) ) ; DBG ( "lba_fixup_bus(0x%p) bus %d platform_data 0x%p\n" , bus , ( int ) bus -> busn_res . start , bus -> bridge -> platform_data ) ; if ( bus -> parent ) { int i ; pci_read_bridge_bases ( bus ) ; for ( i = PCI_BRIDGE_RESOURCES ; i < PCI_NUM_RESOURCES ; i ++ ) { pci_claim_bridge_resource ( bus -> self , i ) ; } } else { int err ; DBG ( "lba_fixup_bus() %s [%lx/%lx]/%lx\n" , ldev -> hba . io_space . name , ldev -> hba . io_space . start , ldev -> hba . io_space . end , ldev -> hba . io_space . flags ) ; DBG ( "lba_fixup_bus() %s [%lx/%lx]/%lx\n" , ldev -> hba . lmmio_space . name , ldev -> hba . lmmio_space . start , ldev -> hba . lmmio_space . end , ldev -> hba . lmmio_space . flags ) ; err = request_resource ( & ioport_resource , & ( ldev -> hba . io_space ) ) ; if ( err < 0 ) { lba_dump_res ( & ioport_resource , 2 ) ; BUG ( ) ; } if ( ldev -> hba . elmmio_space . flags ) { err = request_resource ( & iomem_resource , & ( ldev -> hba . elmmio_space ) ) ; if ( err < 0 ) { printk ( "FAILED: lba_fixup_bus() request for " "elmmio_space [%lx/%lx]\n" , ( long ) ldev -> hba . elmmio_space . start , ( long ) ldev -> hba . elmmio_space . end ) ; } } if ( ldev -> hba . lmmio_space . flags ) { err = request_resource ( & iomem_resource , & ( ldev -> hba . lmmio_space ) ) ; if ( err < 0 ) { printk ( KERN_ERR "FAILED: lba_fixup_bus() request for " "lmmio_space [%lx/%lx]\n" , ( long ) ldev -> hba . lmmio_space . start , ( long ) ldev -> hba . lmmio_space . end ) ; } } if ( ldev -> hba . gmmio_space . flags ) { err = request_resource ( & iomem_resource , & ( ldev -> hba . gmmio_space ) ) ; if ( err < 0 ) { printk ( "FAILED: lba_fixup_bus() request for " "gmmio_space [%lx/%lx]\n" , ( long ) ldev -> hba . gmmio_space . start , ( long ) ldev -> hba . gmmio_space . end ) ; BUG ( ) ; } } } list_for_each_entry ( , , ) { int i ; DBG ( "lba_fixup_bus() %s\n" , pci_name ( dev ) ) ; for ( i = 0 ; i < PCI_BRIDGE_RESOURCES ; i ++ ) { struct resource * res = & dev -> resource [ i ] ; if ( ! res -> start ) { continue ; } pci_claim_resource ( dev , i ) ; } ( void ) pci_read_config_word ( dev , PCI_STATUS , & status ) ; bus -> bridge_ctl &= ~ ( status & PCI_STATUS_FAST_BACK ) ; if ( ( dev -> class >> 8 ) == PCI_CLASS_BRIDGE_PCI ) { pcibios_init_bridge ( dev ) ; continue ; } iosapic_fixup_irq ( ldev -> iosapic_obj , dev ) ; } if ( fbb_enable ) { if ( bus -> parent ) { u8 control ; ( void ) pci_read_config_byte ( bus -> self , PCI_BRIDGE_CONTROL , & control ) ; ( void ) pci_write_config_byte ( bus -> self , PCI_BRIDGE_CONTROL , control | PCI_STATUS_FAST_BACK ) ; } else { } fbb_enable = PCI_COMMAND_FAST_BACK ; } list_for_each_entry ( , , ) { ( void ) pci_read_config_word ( dev , PCI_COMMAND , & status ) ; status |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR | fbb_enable ; ( void ) pci_write_config_word ( dev , PCI_COMMAND , status ) ; } } 