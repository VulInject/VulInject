static gpgme_key_t _ox_key_lookup ( const char * const barejid , gboolean secret_only ) { g_assert ( barejid ) ; log_debug ( "OX: Looking for %s key: %s" , secret_only == TRUE ?"Private" : "Public" , barejid ) ; gpgme_key_t key = NULL ; gpgme_error_t error ; gpgme_ctx_t ctx ; error = gpgme_new ( & ctx ) ; if ( error ) { log_error ( "OX: gpgme_new failed: %s %s" , gpgme_strsource ( error ) , gpgme_strerror ( error ) ) ; return NULL ; } error = gpgme_op_keylist_start ( ctx , NULL , secret_only ) ; if ( error == GPG_ERR_NO_ERROR ) { error = gpgme_op_keylist_next ( ctx , & key ) ; if ( error != GPG_ERR_EOF && error != GPG_ERR_NO_ERROR ) { log_error ( "OX: gpgme_op_keylist_next %s %s" , gpgme_strsource ( error ) , gpgme_strerror ( error ) ) ; return NULL ; } GString * xmppuri = g_string_new ( "xmpp:" ) ; g_string_append ( xmppuri , barejid ) ; while ( ! error ) { gpgme_user_id_t uid = key -> uids ; while ( uid ) { if ( uid -> name && strlen ( uid -> name ) >= 10 ) { if ( g_strcmp0 ( uid -> name , xmppuri -> str ) == 0 ) { gpgme_release ( ctx ) ; return key ; } } uid = uid -> next ; } error = gpgme_op_keylist_next ( ctx , & key ) ; } } gpgme_release ( ctx ) ; return key ; } 