md_apply_fix3 ( , , ) fixS * fixP ; valueT * valP ; segT seg ; { valueT value = * valP ; if ( fixP -> fx_addsy != NULL ) { printf ( "\nmd_apply_fix3: symbol %s at 0x%x (%s:%d) val=0x%x addend=0x%x\n" , S_GET_NAME ( fixP -> fx_addsy ) , fixP -> fx_frag -> fr_address + fixP -> fx_where , fixP -> fx_file , fixP -> fx_line , S_GET_VALUE ( fixP -> fx_addsy ) , value ) ; } else { fixP -> fx_done = 1 ; } if ( ( int ) fixP -> fx_r_type >= ( int ) BFD_RELOC_UNUSED ) { int opindex ; const struct i370_operand * operand ; char * where ; i370_insn_t insn ; opindex = ( int ) fixP -> fx_r_type - ( int ) BFD_RELOC_UNUSED ; printf ( "\nmd_apply_fix3: fixup operand %s at 0x%x in %s:%d addend=0x%x\n" , operand -> name , fixP -> fx_frag -> fr_address + fixP -> fx_where , fixP -> fx_file , fixP -> fx_line , value ) ; where = fixP -> fx_frag -> fr_literal + fixP -> fx_where ; insn . i [ 0 ] = bfd_getb32 ( ( unsigned char * ) where ) ; if ( 6 <= fixP -> fx_size ) { insn . i [ 1 ] = bfd_getb32 ( ( ( unsigned char * ) where ) + 4 ) ; } insn = i370_insert_operand ( insn , operand , ( offsetT ) value ) ; bfd_putb32 ( ( bfd_vma ) insn . i [ 0 ] , ( unsigned char * ) where ) ; if ( 6 <= fixP -> fx_size ) { bfd_putb32 ( ( bfd_vma ) insn . i [ 1 ] , ( ( ( unsigned char * ) where ) + 4 ) ) ; } fixP -> fx_done = 1 ; if ( fixP -> fx_done ) { return ; } if ( ( operand -> flags & I370_OPERAND_RELATIVE ) != 0 && operand -> bits == 12 && operand -> shift == 0 ) { fixP -> fx_r_type = BFD_RELOC_I370_D12 ; } else { char * sfile ; unsigned int sline ; if ( expr_symbol_where ( fixP -> fx_addsy , & sfile , & sline ) ) { as_bad_where ( fixP -> fx_file , fixP -> fx_line , "unresolved expression that must be resolved" ) ; } else { as_bad_where ( fixP -> fx_file , fixP -> fx_line , "unsupported relocation type" ) ; } fixP -> fx_done = 1 ; return ; } } else { i370_elf_validate_fix ( fixP , seg ) ; printf ( "md_apply_fix3: reloc case %d in segment  %s %s:%d\n" , fixP -> fx_r_type , segment_name ( seg ) , fixP -> fx_file , fixP -> fx_line ) ; printf ( "\tcurrent fixup value is 0x%x \n" , value ) ; switch ( fixP -> fx_r_type ) { case BFD_RELOC_32 : case BFD_RELOC_CTOR : if ( fixP -> fx_pcrel ) { fixP -> fx_r_type = BFD_RELOC_32_PCREL ; } case BFD_RELOC_RVA : case BFD_RELOC_32_PCREL : case BFD_RELOC_32_BASEREL : printf ( "\t32 bit relocation at 0x%x\n" , fixP -> fx_frag -> fr_address + fixP -> fx_where ) ; md_number_to_chars ( fixP -> fx_frag -> fr_literal + fixP -> fx_where , value , 4 ) ; break ; case BFD_RELOC_LO16 : case BFD_RELOC_16 : if ( fixP -> fx_pcrel ) { as_bad_where ( fixP -> fx_file , fixP -> fx_line , "cannot emit PC relative %s relocation%s%s" , bfd_get_reloc_code_name ( fixP -> fx_r_type ) , fixP -> fx_addsy != NULL ?" against " : "" , ( fixP -> fx_addsy != NULL ?S_GET_NAME ( fixP -> fx_addsy ) : "" ) ) ; } md_number_to_chars ( fixP -> fx_frag -> fr_literal + fixP -> fx_where , value , 2 ) ; break ; case BFD_RELOC_HI16 : if ( fixP -> fx_pcrel ) { abort ( ) ; } md_number_to_chars ( fixP -> fx_frag -> fr_literal + fixP -> fx_where , value >> 16 , 2 ) ; break ; case BFD_RELOC_HI16_S : if ( fixP -> fx_pcrel ) { abort ( ) ; } md_number_to_chars ( fixP -> fx_frag -> fr_literal + fixP -> fx_where , ( value + 0x8000 ) >> 16 , 2 ) ; break ; case BFD_RELOC_8 : if ( fixP -> fx_pcrel ) { abort ( ) ; } md_number_to_chars ( fixP -> fx_frag -> fr_literal + fixP -> fx_where , value , 1 ) ; break ; default : fprintf ( stderr , "Gas failure, reloc value %d\n" , fixP -> fx_r_type ) ; fflush ( stderr ) ; abort ( ) ; } } fixP -> fx_addnumber = value ; } 