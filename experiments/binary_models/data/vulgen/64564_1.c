Resources * schd_get_resources ( char * exechost ) { char * id = "schd_get_resources" ; Resources * rptr , * new_rsrcs ; int rm ; char * response = NULL ; int badreply = 0 ; int local_errno = 0 ; struct sigaction act , oact ; unsigned int remain ; time_t then ; if ( schd_RsrcsList != NULL ) { for ( rptr = schd_RsrcsList ; rptr != NULL ; rptr = rptr -> next ) { if ( strcmp ( rptr -> exechost , exechost ) == 0 ) { return ( rptr ) ; } } } schd_timestamp ( "get_rsrcs" ) ; if ( ( new_rsrcs = ( Resources * ) malloc ( sizeof ( Resources ) ) ) == NULL ) { ( void ) sprintf ( log_buffer , "Unable to alloc space for Resources." ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; return ( NULL ) ; } act . sa_flags = 0 ; act . sa_handler = connect_interrupt ; sigemptyset ( & act . sa_mask ) ; remain = 0 ; then = 0 ; if ( sigaction ( SIGALRM , & act , & oact ) == 0 ) { remain = alarm ( GETRSRCS_CONNECT_TIME ) ; then = time ( NULL ) ; } if ( ( rm = openrm ( exechost , 0 ) ) == - 1 ) { ( void ) sprintf ( log_buffer , "Unable to contact resmom@%s " , exechost ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; badreply = 1 ; bail } fullresp ( 0 ) ; addreq ( rm , "loadave" ) ; addreq ( rm , "availmem" ) ; addreq ( rm , "physmem" ) ; addreq ( rm , "ncpus" ) ; addreq ( rm , "tmpdir" ) ; addreq ( rm , "arch" ) ; response = getreq_err ( & local_errno , rm ) ; if ( response != NULL ) { new_rsrcs -> loadave = atof ( response ) ; ( void ) free ( response ) ; } else { ( void ) sprintf ( log_buffer , "bad return from getreq(loadave), %d, %d" , local_errno , errno ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; badreply = 1 ; bail } response = getreq_err ( & local_errno , rm ) ; if ( response != NULL ) { new_rsrcs -> freemem = schd_val2byte ( response ) ; ( void ) free ( response ) ; } else { ( void ) sprintf ( log_buffer , "bad return from getreq(freemem), %d, %d" , local_errno , errno ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; badreply = 1 ; bail } response = getreq_err ( & local_errno , rm ) ; if ( response != NULL ) { new_rsrcs -> mem_total = schd_val2byte ( response ) ; ( void ) free ( response ) ; } else { ( void ) sprintf ( log_buffer , "bad return from getreq(realmem), %d, %d" , local_errno , errno ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; badreply = 1 ; bail } response = getreq_err ( & local_errno , rm ) ; if ( response != NULL ) { new_rsrcs -> ncpus_total = atoi ( response ) ; ( void ) free ( response ) ; } else { ( void ) sprintf ( log_buffer , "bad return from getreq(ncpus), %d, %d" , local_errno , errno ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; badreply = 1 ; bail } response = getreq_err ( & local_errno , rm ) ; if ( response != NULL ) { new_rsrcs -> tmpdir = schd_val2byte ( response ) ; ( void ) free ( response ) ; } else { ( void ) sprintf ( log_buffer , "bad return from getreq(tmpdir), %d, %d" , local_errno , errno ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; badreply = 1 ; bail } response = getreq_err ( & local_errno , rm ) ; if ( response != NULL ) { new_rsrcs -> arch = schd_strdup ( response ) ; ( void ) free ( response ) ; } else { ( void ) sprintf ( log_buffer , "bad return from getreq(arch), %d, %d" , local_errno , errno ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; badreply = 1 ; bail } bail if ( rm >= 0 ) { closerm ( rm ) ; } alarm ( 0 ) ; sigaction ( SIGALRM , & oact , & act ) ; if ( remain ) { DBPRT ( ( "%s: old alarm had %d secs remaining, %d elapsed, " , id , remain , ( time ( NULL ) - then ) ) ) ; remain -= ( time ( NULL ) - then ) ; if ( remain < 1 ) { remain = 1 ; } DBPRT ( ( "reset to %d secs\n" , remain ) ) ; alarm ( remain ) ; } if ( badreply ) { ( void ) sprintf ( log_buffer , "Got bad info from mom@%s - skipping this node" , exechost ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; free ( new_rsrcs ) ; return ( NULL ) ; } new_rsrcs -> exechost = schd_strdup ( exechost ) ; if ( new_rsrcs -> exechost == NULL ) { ( void ) sprintf ( log_buffer , "Unable to copy exechost %s to rsrcs" , exechost ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; free ( new_rsrcs ) ; return ( NULL ) ; } if ( schd_RsrcsList == NULL ) { schd_RsrcsList = new_rsrcs ; } else { for ( rptr = schd_RsrcsList ; rptr -> next != NULL ; rptr = rptr -> next ) { } rptr -> next = new_rsrcs ; } new_rsrcs -> next = NULL ; return ( new_rsrcs ) ; } void schd_dump_rsrclist ( void ) { Resources * rsrcs ; for ( rsrcs = schd_RsrcsList ; rsrcs != NULL ; rsrcs = rsrcs -> next ) { dump_resources ( rsrcs ) ; } } static void dump_resources ( Resources * rsrcs ) { char * id = "dump_res" ; ( void ) sprintf ( log_buffer , "Resources for host %s" , rsrcs -> exechost ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; ( void ) sprintf ( log_buffer , " :: %-20s = %s" , "SYSTEM Architecture:" , rsrcs -> arch ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; ( void ) sprintf ( log_buffer , " :: %-20s = %d / %d (%.2f%%)" , "CPUs allocated:" , rsrcs -> ncpus_alloc , rsrcs -> ncpus_total , ( rsrcs -> ncpus_alloc * 100.0 ) / rsrcs -> ncpus_total ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; } 