int mbedtls_pk_parse_key ( mbedtls_pk_context * pk , const unsigned char * key , size_t keylen , const unsigned char * pwd , size_t pwdlen , int * f_rng ( void * , unsigned char * , size_t ) , void * p_rng ) { int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED ; const mbedtls_pk_info_t * pk_info ; size_t len ; mbedtls_pem_context pem ; mbedtls_pem_init ( & pem ) ; if ( key [ keylen - 1 ] != '\0' ) { ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT ; } else { ret = mbedtls_pem_read_buffer ( & pem , "-----BEGIN RSA PRIVATE KEY-----" , "-----END RSA PRIVATE KEY-----" , key , pwd , pwdlen , & len ) ; } if ( ret == 0 ) { pk_info = mbedtls_pk_info_from_type ( MBEDTLS_PK_RSA ) ; if ( ( ret = mbedtls_pk_setup ( pk , pk_info ) ) != 0 || ( ret = pk_parse_key_pkcs1_der ( mbedtls_pk_rsa ( * pk ) , pem . buf , pem . buflen ) ) != 0 ) { mbedtls_pk_free ( pk ) ; } mbedtls_pem_free ( & pem ) ; return ret ; } if ( ret == MBEDTLS_ERR_PEM_PASSWORD_MISMATCH ) { return MBEDTLS_ERR_PK_PASSWORD_MISMATCH ; } if ( ret == MBEDTLS_ERR_PEM_PASSWORD_REQUIRED ) { return MBEDTLS_ERR_PK_PASSWORD_REQUIRED ; } if ( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT ) { return ret ; } if ( key [ keylen - 1 ] != '\0' ) { ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT ; } else { ret = mbedtls_pem_read_buffer ( & pem , "-----BEGIN EC PRIVATE KEY-----" , "-----END EC PRIVATE KEY-----" , key , pwd , pwdlen , & len ) ; } if ( ret == 0 ) { pk_info = mbedtls_pk_info_from_type ( MBEDTLS_PK_ECKEY ) ; if ( ( ret = mbedtls_pk_setup ( pk , pk_info ) ) != 0 || ( ret = pk_parse_key_sec1_der ( mbedtls_pk_ec ( * pk ) , pem . buf , pem . buflen , f_rng , p_rng ) ) != 0 ) { mbedtls_pk_free ( pk ) ; } mbedtls_pem_free ( & pem ) ; return ret ; } if ( ret == MBEDTLS_ERR_PEM_PASSWORD_MISMATCH ) { return MBEDTLS_ERR_PK_PASSWORD_MISMATCH ; } if ( ret == MBEDTLS_ERR_PEM_PASSWORD_REQUIRED ) { return MBEDTLS_ERR_PK_PASSWORD_REQUIRED ; } if ( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT ) { return ret ; } if ( key [ keylen - 1 ] != '\0' ) { ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT ; } else { ret = mbedtls_pem_read_buffer ( & pem , "-----BEGIN PRIVATE KEY-----" , "-----END PRIVATE KEY-----" , key , NULL , 0 , & len ) ; } if ( ret == 0 ) { if ( ( ret = pk_parse_key_pkcs8_unencrypted_der ( pk , pem . buf , pem . buflen , f_rng , p_rng ) ) != 0 ) { mbedtls_pk_free ( pk ) ; } mbedtls_pem_free ( & pem ) ; return ret ; } if ( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT ) { return ret ; } if ( key [ keylen - 1 ] != '\0' ) { ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT ; } else { ret = mbedtls_pem_read_buffer ( & pem , "-----BEGIN ENCRYPTED PRIVATE KEY-----" , "-----END ENCRYPTED PRIVATE KEY-----" , key , NULL , 0 , & len ) ; } if ( ret == 0 ) { if ( ( ret = pk_parse_key_pkcs8_encrypted_der ( pk , pem . buf , pem . buflen , pwd , pwdlen , f_rng , p_rng ) ) != 0 ) { mbedtls_pk_free ( pk ) ; } mbedtls_pem_free ( & pem ) ; return ret ; } if ( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT ) { return ret ; } ( ( void ) pwd ) ; ( ( void ) pwdlen ) ; if ( pwdlen != 0 ) { unsigned char * key_copy ; if ( ( key_copy = mbedtls_calloc ( 1 , keylen ) ) == NULL ) { return MBEDTLS_ERR_PK_ALLOC_FAILED ; } memcpy ( key_copy , key , keylen ) ; ret = pk_parse_key_pkcs8_encrypted_der ( pk , key_copy , keylen , pwd , pwdlen , f_rng , p_rng ) ; mbedtls_platform_zeroize ( key_copy , keylen ) ; mbedtls_free ( key_copy ) ; } if ( ret == 0 ) { return 0 ; } mbedtls_pk_free ( pk ) ; mbedtls_pk_init ( pk ) ; if ( ret == MBEDTLS_ERR_PK_PASSWORD_MISMATCH ) { return ret ; } ret = pk_parse_key_pkcs8_unencrypted_der ( pk , key , keylen , f_rng , p_rng ) ; if ( ret == 0 ) { return 0 ; } mbedtls_pk_free ( pk ) ; mbedtls_pk_init ( pk ) ; pk_info = mbedtls_pk_info_from_type ( MBEDTLS_PK_RSA ) ; if ( mbedtls_pk_setup ( pk , pk_info ) == 0 && pk_parse_key_pkcs1_der ( mbedtls_pk_rsa ( * pk ) , key , keylen ) == 0 ) { return 0 ; } mbedtls_pk_free ( pk ) ; mbedtls_pk_init ( pk ) ; pk_info = mbedtls_pk_info_from_type ( MBEDTLS_PK_ECKEY ) ; if ( mbedtls_pk_setup ( pk , pk_info ) == 0 && pk_parse_key_sec1_der ( mbedtls_pk_ec ( * pk ) , key , keylen , f_rng , p_rng ) == 0 ) { return 0 ; } mbedtls_pk_free ( pk ) ; return MBEDTLS_ERR_PK_KEY_INVALID_FORMAT ; } 