settings_t * set_load ( int argc , char * argv [ ] ) { settings_t * set ; int opt , i ; set = malloc ( sizeof ( settings_t ) ) ; memset ( set , 0 , sizeof ( settings_t ) ) ; set -> interface = NULL ; set -> port = 6667 ; set -> local = 0 ; set -> debug = 0 ; set -> rate_seconds = 600 ; set -> rate_times = 5 ; while ( ( opt = getopt ( argc , argv , "i:p:n:t:l:r:hud" ) ) >= 0 ) { if ( opt == 'i' ) { set -> interface = strdup ( optarg ) ; } if ( opt == 'p' ) { if ( ( sscanf ( optarg , "%d" , & i ) != 1 ) || ( i <= 0 ) || ( i > 65535 ) ) { fprintf ( stderr , "Invalid port number: %s\n" , optarg ) ; return ( NULL ) ; } set -> port = i ; } if ( opt == 'n' ) { if ( ( sscanf ( optarg , "%d" , & i ) != 1 ) || ( i < 0 ) ) { fprintf ( stderr , "Invalid number of connections: %s\n" , optarg ) ; return ( NULL ) ; } set -> max_conn = i ; } if ( opt == 't' ) { if ( ( sscanf ( optarg , "%d" , & i ) != 1 ) || ( i < 0 ) || ( i > 600 ) ) { fprintf ( stderr , "Invalid number of seconds: %s\n" , optarg ) ; return ( NULL ) ; } set -> seconds = i ; } if ( opt == 'l' ) { if ( ! ( logfile = fopen ( optarg , "a" ) ) ) { perror ( "fopen" ) ; fprintf ( stderr , "Error opening logfile, giving up.\n" ) ; return ( NULL ) ; } setbuf ( logfile , NULL ) ; } if ( opt == 'r' ) { if ( sscanf ( optarg , "%d,%d,%d" , & set -> rate_seconds , & set -> rate_times , & set -> rate_ignore ) != 3 ) { fprintf ( stderr , "Invalid argument to -r.\n" ) ; return ( NULL ) ; } } if ( opt == 'u' ) { set -> local = 1 ; } if ( opt == 'd' ) { set -> debug = 1 ; } if ( opt == 'h' ) { printf ( "Usage: %s [-i<interface>] [-p<port>] [-n<num>] [-r x,y,z]...\n" "          ...<command><args...>\n" "A simple inetd-like daemon to have a program listening on a TCP socket without\n" "needing root access to the machine\n" "\n" "  -i  Specify the interface (by IP address) to listen on.\n" "      (Default: 0.0.0.0 (any interface))\n" "  -p  Port number to listen on. (Default: 6667)\n" "  -n  Maximum number of connections. (Default: 0 (unlimited))\n" "  -t  Specify the maximum number of CPU seconds per process.\n" "      (Default: 0 (unlimited))\n" "  -l  Specify a logfile. (Default: none)\n" "  -r  Rate limiting: Ignore a host for z seconds when it connects for more\n" "      than y times in x seconds. (Default: 600,5,900. Disable: 0,0,0)\n" "  -u  Use a local socket, by default /tmp/bitlbee (override with -i<filename>)\n" "  -d  Don't fork for listening (for debugging purposes)\n" "  -h  This information\n" , argv [ 0 ] ) ; return ( NULL ) ; } } if ( set -> interface == NULL ) { set -> interface = ( set -> local ) ?"/tmp/bitlbee" : "0.0.0.0" ; } if ( optind == argc ) { fprintf ( stderr , "Missing program parameter!\n" ) ; return ( NULL ) ; } set -> call = malloc ( ( argc - optind + 1 ) * sizeof ( char * ) ) ; memcpy ( set -> call , argv + optind , sizeof ( char * ) * ( argc - optind ) ) ; set -> call [ argc - optind ] = NULL ; return ( set ) ; } 