static int musb_urb_enqueue ( struct usb_hcd * hcd , struct urb * urb , gfp_t mem_flags ) { unsigned long flags ; struct musb * musb = hcd_to_musb ( hcd ) ; struct usb_host_endpoint * hep = urb -> ep ; struct musb_qh * qh ; struct usb_endpoint_descriptor * epd = & hep -> desc ; int ret ; unsigned type_reg ; unsigned interval ; if ( ! is_host_active ( musb ) || ! musb -> is_active ) { return - ENODEV ; } trace_musb_urb_enq ( musb , urb ) ; spin_lock_irqsave ( & musb -> lock , flags ) ; ret = usb_hcd_link_urb_to_ep ( hcd , urb ) ; qh = ret ?NULL : hep -> hcpriv ; if ( qh ) { urb -> hcpriv = qh ; } spin_unlock_irqrestore ( & musb -> lock , flags ) ; if ( qh || ret ) { return ret ; } qh = kzalloc ( sizeof qh , mem_flags ) ; if ( ! qh ) { spin_lock_irqsave ( & musb -> lock , flags ) ; usb_hcd_unlink_urb_from_ep ( hcd , urb ) ; spin_unlock_irqrestore ( & musb -> lock , flags ) ; return - ENOMEM ; } qh -> hep = hep ; qh -> dev = urb -> dev ; INIT_LIST_HEAD ( & qh -> ring ) ; qh -> is_ready = 1 ; qh -> maxpacket = usb_endpoint_maxp ( epd ) ; qh -> type = usb_endpoint_type ( epd ) ; qh -> hb_mult = usb_endpoint_maxp_mult ( epd ) ; if ( qh -> hb_mult > 1 ) { int ok = ( qh -> type == USB_ENDPOINT_XFER_ISOC ) ; if ( ok ) { ok = ( usb_pipein ( urb -> pipe ) && musb -> hb_iso_rx ) || ( usb_pipeout ( urb -> pipe ) && musb -> hb_iso_tx ) ; } if ( ! ok ) { dev_err ( musb -> controller , "high bandwidth %s (%dx%d) not supported\n" , musb_ep_xfertype_string ( qh -> type ) , qh -> hb_mult , qh -> maxpacket & 0x7ff ) ; ret = - EMSGSIZE ; done } qh -> maxpacket &= 0x7ff ; } qh -> epnum = usb_endpoint_num ( epd ) ; qh -> addr_reg = ( u8 ) usb_pipedevice ( urb -> pipe ) ; type_reg = ( qh -> type << 4 ) | qh -> epnum ; switch ( urb -> dev -> speed ) { case USB_SPEED_LOW : type_reg |= 0xc0 ; break ; case USB_SPEED_FULL : type_reg |= 0x80 ; break ; default : type_reg |= 0x40 ; } qh -> type_reg = type_reg ; switch ( qh -> type ) { case USB_ENDPOINT_XFER_INT : if ( urb -> dev -> speed <= USB_SPEED_FULL ) { interval = max_t ( u8 , epd -> bInterval , 1 ) ; break ; } fallthrough ; case USB_ENDPOINT_XFER_ISOC : interval = min_t ( u8 , epd -> bInterval , 16 ) ; break ; default : interval = 0 ; } qh -> intv_reg = interval ; if ( musb -> is_multipoint ) { struct usb_device * parent = urb -> dev -> parent ; if ( parent != hcd -> self . root_hub ) { qh -> h_addr_reg = ( u8 ) parent -> devnum ; if ( urb -> dev -> tt ) { qh -> h_port_reg = ( u8 ) urb -> dev -> ttport ; if ( urb -> dev -> tt -> hub ) { qh -> h_addr_reg = ( u8 ) urb -> dev -> tt -> hub -> devnum ; } if ( urb -> dev -> tt -> multi ) { qh -> h_addr_reg |= 0x80 ; } } } } spin_lock_irqsave ( & musb -> lock , flags ) ; if ( hep -> hcpriv || ! next_urb ( qh ) ) { kfree ( qh ) ; qh = NULL ; ret = 0 ; } else { ret = musb_schedule ( musb , qh , epd -> bEndpointAddress & USB_ENDPOINT_DIR_MASK ) ; } if ( ret == 0 ) { urb -> hcpriv = qh ; } spin_unlock_irqrestore ( & musb -> lock , flags ) ; done return ret ; } 