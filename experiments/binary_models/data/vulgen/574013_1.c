if ( tno -> zo_data . zo_type != TABLE_OBJ ) { * errmsg = string_sprintf ( "NIS+ error: %s is not a table" , p ) ; NISPLUS_EXIT } ta = & tno -> zo_data . objdata_u . ta_data ; nre = nis_list ( , , , ) ; if ( nre -> status != NIS_SUCCESS ) { * errmsg = string_sprintf ( "NIS+ error accessing entry %s: %s" , query , nis_sperrno ( nre -> status ) ) ; NISPLUS_EXIT } if ( nre -> objects . objects_len > 1 ) { * errmsg = string_sprintf ( "NIS+ returned more than one object for %s" , query ) ; NISPLUS_EXIT } if ( nre -> objects . objects_len < 1 ) { * errmsg = string_sprintf ( "NIS+ returned no data for %s" , query ) ; NISPLUS_EXIT } eno = nre -> objects . objects_val ; if ( eno -> zo_data . zo_type != ENTRY_OBJ ) { * errmsg = string_sprintf ( "NIS+ error: %s is not an entry" , query ) ; NISPLUS_EXIT } eo = & ( eno -> zo_data . objdata_u . en_data ) ; for ( int i = 0 ; i < eo -> en_cols . en_cols_len ; i ++ ) { table_col * tc = ta -> ta_cols . ta_cols_val + i ; entry_col * ec = eo -> en_cols . en_cols_val + i ; int len = ec -> ec_value . ec_value_len ; uschar * value = US ec -> ec_value . ec_value_val ; else { while ( len > 0 && ( value [ len - 1 ] == 0 || isspace ( value [ len - 1 ] ) ) ) { len -- ; } } if ( ! field_name ) { yield = string_cat ( , ) ; yield = string_catn ( yield , US "=" , 1 ) ; if ( value [ 0 ] == 0 || Ustrchr ( value , ' ' ) != NULL ) { yield = string_catn ( yield , US "\"" , 1 ) ; for ( int j = 0 ; j < len ; j ++ ) { if ( value [ j ] == '\"' || value [ j ] == '\\' ) { yield = string_catn ( yield , US "\\" , 1 ) ; } yield = string_catn ( yield , value + j , 1 ) ; } yield = string_catn ( yield , US "\"" , 1 ) ; } else { yield = string_catn ( yield , value , len ) ; } yield = string_catn ( yield , US " " , 1 ) ; } if ( Ustrcmp ( field_name , tc -> tc_name ) == 0 ) { yield = string_catn ( yield , value , len ) ; NISPLUS_EXIT } } if ( field_name ) { * errmsg = string_sprintf ( "NIS+ field %s not found for %s" , field_name , query ) ; } else { gstring_release_unused ( yield ) ; } NISPLUS_EXIT if ( nrt ) { nis_freeresult ( nrt ) ; } if ( nre ) { nis_freeresult ( nre ) ; } if ( yield ) { * result = string_from_gstring ( yield ) ; return OK ; } return error_error ; 