static int snd_sb16_probe ( struct snd_card * card , int dev ) { int xirq , xdma8 , xdma16 ; struct snd_sb * chip ; struct snd_card_sb16 * acard = card -> private_data ; struct snd_opl3 * opl3 ; struct snd_hwdep * synth = NULL ; struct snd_hwdep * xcsp = NULL ; unsigned long flags ; int err ; xirq = irq [ dev ] ; xdma8 = dma8 [ dev ] ; xdma16 = dma16 [ dev ] ; err = snd_sbdsp_create ( card , port [ dev ] , xirq , snd_sb16dsp_interrupt , xdma8 , xdma16 , SB_HW_AUTO , & chip ) ; if ( err < 0 ) { return err ; } acard -> chip = chip ; if ( chip -> hardware != SB_HW_16 ) { snd_printk ( "SB 16 chip was not detected at 0x%lx\n" , ) return - ENODEV ; } chip -> mpu_port = mpu_port [ dev ] ; if ( ! is_isapnp_selected ( dev ) ) { err = snd_sb16dsp_configure ( chip ) ; if ( err < 0 ) { return err ; } } err = snd_sb16dsp_pcm ( chip , 0 ) ; if ( err < 0 ) { return err ; } strcpy ( card -> driver , awe_port [ dev ] > 0 ?"SB AWE" : "SB16" ) ; strcpy ( card -> shortname , chip -> name ) ; sprintf ( card -> longname , "%s at 0x%lx, irq %i, dma " , chip -> name , chip -> port , xirq ) ; if ( xdma8 >= 0 ) { sprintf ( card -> longname + strlen ( card -> longname ) , "%d" , xdma8 ) ; } if ( xdma16 >= 0 ) { sprintf ( card -> longname + strlen ( card -> longname ) , "%s%d" , xdma8 >= 0 ?"&" : "" , xdma16 ) ; } if ( chip -> mpu_port > 0 && chip -> mpu_port != SNDRV_AUTO_PORT ) { err = snd_mpu401_uart_new ( card , 0 , MPU401_HW_SB , chip -> mpu_port , MPU401_INFO_IRQ_HOOK , - 1 , & chip -> rmidi ) ; if ( err < 0 ) { return err ; } chip -> rmidi_callback = snd_mpu401_uart_interrupt ; } if ( awe_port [ dev ] == SNDRV_AUTO_PORT ) { awe_port [ dev ] = 0 ; } if ( fm_port [ dev ] > 0 && fm_port [ dev ] != SNDRV_AUTO_PORT ) { if ( snd_opl3_create ( card , fm_port [ dev ] , fm_port [ dev ] + 2 , OPL3_HW_OPL3 , acard -> fm_res != NULL || fm_port [ dev ] == port [ dev ] , & opl3 ) < 0 ) { snd_printk ( "no OPL device at 0x%lx-0x%lx\n" , , 2 ) } else { int seqdev = awe_port [ dev ] > 0 ?2 : 1 ; int seqdev = 1 ; err = snd_opl3_hwdep_new ( opl3 , 0 , seqdev , & synth ) ; if ( err < 0 ) { return err ; } } } err = snd_sbmixer_new ( chip ) ; if ( err < 0 ) { return err ; } if ( ( chip -> hardware == SB_HW_16 ) && csp [ dev ] ) { snd_sb_csp_new ( chip , synth != NULL ?1 : 0 , & xcsp ) ; if ( xcsp ) { chip -> csp = xcsp -> private_data ; chip -> hardware = SB_HW_16CSP ; } else { snd_printk ( "warning - CSP chip not detected on soundcard #%i\n" , 1 ) } } if ( awe_port [ dev ] > 0 ) { err = snd_emu8000_new ( card , 1 , awe_port [ dev ] , seq_ports [ dev ] , NULL ) ; if ( err < 0 ) { snd_printk ( "fatal error - EMU-8000 synthesizer not detected at 0x%lx\n" , ) return err ; } } spin_lock_irqsave ( & chip -> mixer_lock , flags ) ; snd_sbmixer_write ( chip , SB_DSP4_MIC_AGC , ( snd_sbmixer_read ( chip , SB_DSP4_MIC_AGC ) & 0x01 ) | ( mic_agc [ dev ] ?0x00 : 0x01 ) ) ; spin_unlock_irqrestore ( & chip -> mixer_lock , flags ) ; err = snd_card_register ( card ) ; return 0 ; } 