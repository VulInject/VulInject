void virtio_reset ( void * opaque ) { VirtIODevice * vdev = opaque ; VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; int i ; virtio_set_status ( vdev , 0 ) ; if ( current_cpu ) { vdev -> device_endian = virtio_current_cpu_endian ( ) ; } else { vdev -> device_endian = virtio_default_endian ( ) ; } if ( k -> reset ) { k -> reset ( vdev ) ; } vdev -> start_on_kick = false ; vdev -> started = false ; vdev -> broken = false ; vdev -> guest_features = 0 ; vdev -> queue_sel = 0 ; vdev -> status = 0 ; vdev -> disabled = false ; qatomic_set ( & vdev -> isr , 0 ) ; vdev -> config_vector = VIRTIO_NO_VECTOR ; virtio_notify_vector ( vdev , vdev -> config_vector ) ; for ( i = 0 ; i < VIRTIO_QUEUE_MAX ; i ++ ) { vdev -> vq [ i ] . vring . desc = 0 ; vdev -> vq [ i ] . vring . avail = 0 ; vdev -> vq [ i ] . vring . used = 0 ; vdev -> vq [ i ] . last_avail_idx = 0 ; vdev -> vq [ i ] . shadow_avail_idx = 0 ; vdev -> vq [ i ] . used_idx = 0 ; vdev -> vq [ i ] . last_avail_wrap_counter = true ; vdev -> vq [ i ] . shadow_avail_wrap_counter = true ; vdev -> vq [ i ] . used_wrap_counter = true ; vdev -> vq [ i ] . signalled_used = 0 ; vdev -> vq [ i ] . signalled_used_valid = false ; vdev -> vq [ i ] . notification = true ; vdev -> vq [ i ] . vring . num = vdev -> vq [ i ] . vring . num_default ; vdev -> vq [ i ] . inuse = 0 ; virtio_virtqueue_reset_region_cache ( & vdev -> vq [ i ] ) ; } } 