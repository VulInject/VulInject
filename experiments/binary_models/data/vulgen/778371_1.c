void ipf_destroy ( struct ipf * ipf ) { ovs_mutex_lock ( & ipf -> ipf_lock ) ; latch_set ( & ipf -> ipf_clean_thread_exit ) ; pthread_join ( ipf -> ipf_clean_thread , NULL ) ; latch_destroy ( & ipf -> ipf_clean_thread_exit ) ; struct ipf_list * ipf_list ; HMAP_FOR_EACH_POP ( , , ) { while ( ipf_list -> last_sent_idx < ipf_list -> last_inuse_idx ) { struct dp_packet * pkt = ipf_list -> frag_list [ ipf_list -> last_sent_idx + 1 ] . pkt ; dp_packet_delete ( pkt ) ; atomic_count_dec ( & ipf -> nfrag ) ; ipf_list -> last_sent_idx ++ ; } free ( ipf_list -> frag_list ) ; free ( ipf_list ) ; } if ( atomic_count_get ( & ipf -> nfrag ) ) { VLOG_WARN ( "ipf destroy with non-zero fragment count. " ) ; } struct reassembled_pkt * rp ; LIST_FOR_EACH_POP ( , , ) { dp_packet_delete ( rp -> pkt ) ; free ( rp ) ; } ovs_list_poison ( & ipf -> frag_exp_list ) ; ovs_list_poison ( & ipf -> frag_complete_list ) ; ovs_list_poison ( & ipf -> reassembled_pkt_list ) ; ovs_mutex_unlock ( & ipf -> ipf_lock ) ; ovs_mutex_destroy ( & ipf -> ipf_lock ) ; free ( ipf ) ; } 