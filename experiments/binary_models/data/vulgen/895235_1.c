print_operand ( , , ) FILE * file ; rtx x ; int code ; { int i ; switch ( code ) { case '~' : assemble_name ( file , alpha_fnname ) ; break ; case '&' : break ; case '/' : { const char * trap = get_trap_mode_suffix ( ) ; const char * round = get_round_mode_suffix ( ) ; if ( trap || round ) { fprintf ( file , ( TARGET_AS_SLASH_BEFORE_SUFFIX ?"/%s%s" : "%s%s" ) , ( trap ?trap : "" ) , ( round ?round : "" ) ) ; } break ; } case ',' : fputc ( ( TARGET_FLOAT_VAX ?'f' : 's' ) , file ) ; break ; case '-' : fputc ( ( TARGET_FLOAT_VAX ?'g' : 't' ) , file ) ; break ; case '#' : if ( alpha_this_literal_sequence_number == 0 ) { alpha_this_literal_sequence_number = alpha_next_sequence_number ++ ; } fprintf ( file , "%d" , alpha_this_literal_sequence_number ) ; break ; case '*' : if ( alpha_this_gpdisp_sequence_number == 0 ) { alpha_this_gpdisp_sequence_number = alpha_next_sequence_number ++ ; } fprintf ( file , "%d" , alpha_this_gpdisp_sequence_number ) ; break ; case 'H' : if ( GET_CODE ( x ) == HIGH ) { output_addr_const ( file , XEXP ( x , 0 ) ) ; } else { output_operand_lossage ( "invalid %%H value" ) ; } break ; case 'J' : { const char * lituse ; if ( GET_CODE ( x ) == UNSPEC && XINT ( x , 1 ) == UNSPEC_TLSGD_CALL ) { x = XVECEXP ( x , 0 , 0 ) ; lituse = "lituse_tlsgd" ; } if ( GET_CODE ( x ) == UNSPEC && XINT ( x , 1 ) == UNSPEC_TLSLDM_CALL ) { x = XVECEXP ( x , 0 , 0 ) ; lituse = "lituse_tlsldm" ; } if ( GET_CODE ( x ) == CONST_INT ) { lituse = "lituse_jsr" ; } else { output_operand_lossage ( "invalid %%J value" ) ; break ; } if ( x != const0_rtx ) { fprintf ( file , "\t\t!%s!%d" , lituse , ( int ) INTVAL ( x ) ) ; } } break ; case 'r' : if ( GET_CODE ( x ) == REG ) { fprintf ( file , "%s" , reg_names [ REGNO ( x ) ] ) ; } if ( x == CONST0_RTX ( GET_MODE ( x ) ) ) { fprintf ( file , "$31" ) ; } else { output_operand_lossage ( "invalid %%r value" ) ; } break ; case 'R' : if ( GET_CODE ( x ) == REG ) { fprintf ( file , "%s" , reg_names [ REGNO ( x ) ] ) ; } if ( x == CONST0_RTX ( GET_MODE ( x ) ) ) { fprintf ( file , "$f31" ) ; } else { output_operand_lossage ( "invalid %%R value" ) ; } break ; case 'N' : if ( GET_CODE ( x ) != CONST_INT ) { output_operand_lossage ( "invalid %%N value" ) ; } fprintf ( file , HOST_WIDE_INT_PRINT_DEC , ~ INTVAL ( x ) ) ; break ; case 'P' : if ( GET_CODE ( x ) != CONST_INT ) { output_operand_lossage ( "invalid %%P value" ) ; } fprintf ( file , HOST_WIDE_INT_PRINT_DEC , ( HOST_WIDE_INT ) 1 << INTVAL ( x ) ) ; break ; case 'h' : if ( GET_CODE ( x ) != CONST_INT ) { output_operand_lossage ( "invalid %%h value" ) ; } fprintf ( file , HOST_WIDE_INT_PRINT_DEC , INTVAL ( x ) >> 16 ) ; break ; case 'L' : if ( GET_CODE ( x ) != CONST_INT ) { output_operand_lossage ( "invalid %%L value" ) ; } fprintf ( file , HOST_WIDE_INT_PRINT_DEC , ( INTVAL ( x ) & 0xffff ) - 2 * ( INTVAL ( x ) & 0x8000 ) ) ; break ; case 'm' : if ( GET_CODE ( x ) == CONST_DOUBLE ) { HOST_WIDE_INT mask = 0 ; HOST_WIDE_INT value ; value = CONST_DOUBLE_LOW ( x ) ; for ( i = 0 ; i < HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR ; i ++ , value >>= 8 ) { if ( value & 0xff ) { mask |= ( 1 << i ) ; } } value = CONST_DOUBLE_HIGH ( x ) ; for ( i = 0 ; i < HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR ; i ++ , value >>= 8 ) { if ( value & 0xff ) { mask |= ( 1 << ( i + sizeof ( int ) ) ) ; } } fprintf ( file , HOST_WIDE_INT_PRINT_DEC , mask & 0xff ) ; } if ( GET_CODE ( x ) == CONST_INT ) { HOST_WIDE_INT mask = 0 , value = INTVAL ( x ) ; for ( i = 0 ; i < 8 ; i ++ , value >>= 8 ) { if ( value & 0xff ) { mask |= ( 1 << i ) ; } } fprintf ( file , HOST_WIDE_INT_PRINT_DEC , mask ) ; } else { output_operand_lossage ( "invalid %%m value" ) ; } break ; case 'M' : if ( GET_CODE ( x ) != CONST_INT || ( INTVAL ( x ) != 8 && INTVAL ( x ) != 16 && INTVAL ( x ) != 32 && INTVAL ( x ) != 64 ) ) { output_operand_lossage ( "invalid %%M value" ) ; } fprintf ( file , "%s" , ( INTVAL ( x ) == 8 ?"b" : INTVAL ( x ) == 16 ?"w" : INTVAL ( x ) == 32 ?"l" : "q" ) ) ; break ; case 'U' : if ( GET_CODE ( x ) == CONST_INT ) { HOST_WIDE_INT value = INTVAL ( x ) ; if ( value == 0xff ) { fputc ( 'b' , file ) ; break ; } if ( value == 0xffff ) { fputc ( 'w' , file ) ; break ; } if ( value == 0xffffffff ) { fputc ( 'l' , file ) ; break ; } if ( value == - 1 ) { fputc ( 'q' , file ) ; break ; } } if ( HOST_BITS_PER_WIDE_INT == 32 && GET_CODE ( x ) == CONST_DOUBLE && CONST_DOUBLE_LOW ( x ) == 0xffffffff && CONST_DOUBLE_HIGH ( x ) == 0 ) { fputc ( 'l' , file ) ; break ; } output_operand_lossage ( "invalid %%U value" ) ; break ; case 's' : if ( GET_CODE ( x ) != CONST_INT || ( unsigned HOST_WIDE_INT ) INTVAL ( x ) >= ( WORDS_BIG_ENDIAN ?56 : 64 ) || ( INTVAL ( x ) & 7 ) != 0 ) { output_operand_lossage ( "invalid %%s value" ) ; } fprintf ( file , HOST_WIDE_INT_PRINT_DEC , WORDS_BIG_ENDIAN ?( 56 - INTVAL ( x ) ) / 8 : INTVAL ( x ) / 8 ) ; break ; case 'S' : if ( GET_CODE ( x ) != CONST_INT && ( unsigned HOST_WIDE_INT ) INTVAL ( x ) >= 64 && ( INTVAL ( x ) & 7 ) != 8 ) { output_operand_lossage ( "invalid %%s value" ) ; } fprintf ( file , HOST_WIDE_INT_PRINT_DEC , ( 64 - INTVAL ( x ) ) / 8 ) ; break ; case 't' : { int dex = unicosmk_need_dex ( x ) ; if ( dex ) { fprintf ( file , "DEX(%d)" , dex ) ; } else { output_addr_const ( file , x ) ; } } break ; case 'C' : case 'D' : case 'c' : case 'd' : { enum rtx_code c = GET_CODE ( x ) ; if ( GET_RTX_CLASS ( c ) != '<' ) { output_operand_lossage ( "invalid %%C value" ) ; } if ( code == 'D' ) { c = reverse_condition ( c ) ; } if ( code == 'c' ) { c = swap_condition ( c ) ; } if ( code == 'd' ) { c = swap_condition ( reverse_condition ( c ) ) ; } if ( c == LEU ) { fprintf ( file , "ule" ) ; } if ( c == LTU ) { fprintf ( file , "ult" ) ; } if ( c == UNORDERED ) { fprintf ( file , "un" ) ; } else { fprintf ( file , "%s" , GET_RTX_NAME ( c ) ) ; } } break ; case 'E' : switch ( GET_CODE ( x ) ) { case DIV : fprintf ( file , "div%s" , GET_MODE ( x ) == SImode ?"l" : "q" ) ; break ; case UDIV : fprintf ( file , "div%su" , GET_MODE ( x ) == SImode ?"l" : "q" ) ; break ; case MOD : fprintf ( file , "rem%s" , GET_MODE ( x ) == SImode ?"l" : "q" ) ; break ; case UMOD : fprintf ( file , "rem%su" , GET_MODE ( x ) == SImode ?"l" : "q" ) ; break ; default : output_operand_lossage ( "invalid %%E value" ) ; break ; } break ; case 'A' : if ( GET_CODE ( x ) == MEM && GET_CODE ( XEXP ( x , 0 ) ) == AND ) { fprintf ( file , "_u" ) ; } break ; case 0 : if ( GET_CODE ( x ) == REG ) { fprintf ( file , "%s" , reg_names [ REGNO ( x ) ] ) ; } if ( GET_CODE ( x ) == MEM ) { output_address ( XEXP ( x , 0 ) ) ; } if ( GET_CODE ( x ) == CONST && GET_CODE ( XEXP ( x , 0 ) ) == UNSPEC ) { switch ( XINT ( XEXP ( x , 0 ) , 1 ) ) { case UNSPEC_DTPREL : case UNSPEC_TPREL : output_addr_const ( file , XVECEXP ( XEXP ( x , 0 ) , 0 , 0 ) ) ; break ; default : output_operand_lossage ( "unknown relocation unspec" ) ; break ; } } else { output_addr_const ( file , x ) ; } break ; default : output_operand_lossage ( "invalid %%xn code" ) ; } } 