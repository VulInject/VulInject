static void consolidateMarkArray ( otfcc_Font * font , table_OTL * table , const otfcc_Options * options , otl_MarkArray * markArray , glyphclass_t classCount ) { mark_hash * hm = NULL ; for ( glyphid_t k = 0 ; k < markArray -> length ; k ++ ) { if ( ! GlyphOrder . consolidateHandle ( font -> glyph_order , & markArray -> items [ k ] . glyph ) ) { logWarning ( "[Consolidate] Ignored unknown glyph name %s." , markArray -> items [ k ] . glyph . name ) ; continue ; } mark_hash * s = NULL ; int gid = markArray -> items [ k ] . glyph . index ; HASH_FIND_INT ( hm , & gid , s ) ; if ( ! s && markArray -> items [ k ] . anchor . present && markArray -> items [ k ] . markClass < classCount ) { NEW ( s ) ; s -> gid = markArray -> items [ k ] . glyph . index ; s -> name = sdsdup ( markArray -> items [ k ] . glyph . name ) ; s -> markClass = markArray -> items [ k ] . markClass ; s -> anchor = markArray -> items [ k ] . anchor ; HASH_ADD_INT ( hm , gid , s ) ; } else { logWarning ( "[Consolidate] Ignored invalid or double-mapping mark definition for /%s." , markArray -> items [ k ] . glyph . name ) ; } } HASH_SORT ( hm , mark_by_gid ) ; otl_iMarkArray . clear ( markArray ) ; mark_hash * s , * tmp ; HASH_ITER ( , , , ) { otl_iMarkArray . push ( markArray , ( ( otl_MarkRecord ) { . glyph = Handle . fromConsolidated ( s -> gid , s -> name ) . markClass = s -> markClass . anchor = s -> anchor } ) ) ; HASH_DEL ( hm , s ) ; FREE ( s ) ; } } 