static void set_avi_info_frame ( struct dc_info_packet * info_packet , struct pipe_ctx * pipe_ctx ) { struct dc_stream_state * stream = pipe_ctx -> stream ; enum dc_color_space color_space = COLOR_SPACE_UNKNOWN ; uint8_t byte_index ; enum scanning_type scan_type = SCANNING_TYPE_NODATA ; enum dc_aspect_ratio aspect = ASPECT_RATIO_NO_DATA ; bool itc = false ; uint8_t itc_value = 0 ; uint8_t cn0_cn1 = 0 ; unsigned int cn0_cn1_value = 0 ; uint8_t * check_sum = NULL ; uint8_t byte_index = 0 ; union hdmi_info_packet hdmi_info ; union display_content_support support = { 0 } ; unsigned int vic = pipe_ctx -> stream -> timing . vic ; unsigned int rid = pipe_ctx -> stream -> timing . rid ; unsigned int fr_ind = pipe_ctx -> stream -> timing . fr_index ; enum dc_timing_3d_format format ; memset ( & hdmi_info , 0 , sizeof ( hdmi_info_packet ) ) ; color_space = pipe_ctx -> stream -> output_color_space ; if ( color_space == COLOR_SPACE_UNKNOWN ) { color_space = ( stream -> timing . pixel_encoding == PIXEL_ENCODING_RGB ) ?COLOR_SPACE_SRGB : COLOR_SPACE_YCBCR709 ; } hdmi_info . bits . header . info_frame_type = HDMI_INFOFRAME_TYPE_AVI ; hdmi_info . bits . header . version = 2 ; hdmi_info . bits . header . length = HDMI_AVI_INFOFRAME_SIZE ; switch ( stream -> timing . pixel_encoding ) { case PIXEL_ENCODING_YCBCR422 : pixel_encoding = 1 ; break ; case PIXEL_ENCODING_YCBCR444 : pixel_encoding = 2 ; break ; case PIXEL_ENCODING_YCBCR420 : pixel_encoding = 3 ; break ; case PIXEL_ENCODING_RGB : default : pixel_encoding = 0 ; } hdmi_info . bits . Y0_Y1_Y2 = pixel_encoding ; hdmi_info . bits . A0 = ACTIVE_FORMAT_VALID ; hdmi_info . bits . B0_B1 = BAR_INFO_BOTH_VALID ; hdmi_info . bits . SC0_SC1 = PICTURE_SCALING_UNIFORM ; scan_type = SCANNING_TYPE_UNDERSCAN ; hdmi_info . bits . S0_S1 = scan_type ; if ( color_space == COLOR_SPACE_YCBCR709 || color_space == COLOR_SPACE_YCBCR709_LIMITED ) { hdmi_info . bits . C0_C1 = COLORIMETRY_ITU709 ; } if ( color_space == COLOR_SPACE_YCBCR601 || color_space == COLOR_SPACE_YCBCR601_LIMITED ) { hdmi_info . bits . C0_C1 = COLORIMETRY_ITU601 ; } else { hdmi_info . bits . C0_C1 = COLORIMETRY_NO_DATA ; } if ( color_space == COLOR_SPACE_2020_RGB_FULLRANGE || color_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE || color_space == COLOR_SPACE_2020_YCBCR ) { hdmi_info . bits . EC0_EC2 = COLORIMETRYEX_BT2020RGBYCBCR ; hdmi_info . bits . C0_C1 = COLORIMETRY_EXTENDED ; } if ( color_space == COLOR_SPACE_ADOBERGB ) { hdmi_info . bits . EC0_EC2 = COLORIMETRYEX_ADOBERGB ; hdmi_info . bits . C0_C1 = COLORIMETRY_EXTENDED ; } if ( pixel_encoding && color_space == COLOR_SPACE_2020_YCBCR && stream -> out_transfer_func -> tf == TRANSFER_FUNCTION_GAMMA22 ) { hdmi_info . bits . EC0_EC2 = 0 ; hdmi_info . bits . C0_C1 = COLORIMETRY_ITU709 ; } aspect = stream -> timing . aspect_ratio ; switch ( aspect ) { case ASPECT_RATIO_4_3 : case ASPECT_RATIO_16_9 : hdmi_info . bits . M0_M1 = aspect ; break ; case ASPECT_RATIO_NO_DATA : case ASPECT_RATIO_64_27 : case ASPECT_RATIO_256_135 : default : hdmi_info . bits . M0_M1 = 0 ; } hdmi_info . bits . R0_R3 = ACTIVE_FORMAT_ASPECT_RATIO_SAME_AS_PICTURE ; cn0_cn1 = 0 ; cn0_cn1_value = 0 ; itc = true ; itc_value = 1 ; support = stream -> content_support ; if ( itc ) { if ( ! support . bits . valid_content_type ) { cn0_cn1_value = 0 ; } else { if ( cn0_cn1 == DISPLAY_CONTENT_TYPE_GRAPHICS ) { if ( support . bits . graphics_content == 1 ) { cn0_cn1_value = 0 ; } } if ( cn0_cn1 == DISPLAY_CONTENT_TYPE_PHOTO ) { if ( support . bits . photo_content == 1 ) { cn0_cn1_value = 1 ; } else { cn0_cn1_value = 0 ; itc_value = 0 ; } } if ( cn0_cn1 == DISPLAY_CONTENT_TYPE_CINEMA ) { if ( support . bits . cinema_content == 1 ) { cn0_cn1_value = 2 ; } else { cn0_cn1_value = 0 ; itc_value = 0 ; } } if ( cn0_cn1 == DISPLAY_CONTENT_TYPE_GAME ) { if ( support . bits . game_content == 1 ) { cn0_cn1_value = 3 ; } else { cn0_cn1_value = 0 ; itc_value = 0 ; } } } hdmi_info . bits . CN0_CN1 = cn0_cn1_value ; hdmi_info . bits . ITC = itc_value ; } if ( stream -> qs_bit == 1 ) { if ( color_space == COLOR_SPACE_SRGB || color_space == COLOR_SPACE_2020_RGB_FULLRANGE ) { hdmi_info . bits . Q0_Q1 = RGB_QUANTIZATION_FULL_RANGE ; } if ( color_space == COLOR_SPACE_SRGB_LIMITED || color_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE ) { hdmi_info . bits . Q0_Q1 = RGB_QUANTIZATION_LIMITED_RANGE ; } else { hdmi_info . bits . Q0_Q1 = RGB_QUANTIZATION_DEFAULT_RANGE ; } } else { hdmi_info . bits . Q0_Q1 = RGB_QUANTIZATION_DEFAULT_RANGE ; } hdmi_info . bits . YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE ; if ( pipe_ctx -> stream -> timing . hdmi_vic != 0 ) { vic = 0 ; } format = stream -> timing . timing_3d_format ; if ( format != TIMING_3D_FORMAT_NONE ) { switch ( pipe_ctx -> stream -> timing . hdmi_vic ) { case 1 : vic = 95 ; break ; case 2 : vic = 94 ; break ; case 3 : vic = 93 ; break ; case 4 : vic = 98 ; break ; default : break ; } } hdmi_info . bits . VIC0_VIC7 = vic ; if ( vic >= 128 ) { hdmi_info . bits . header . version = 3 ; } if ( hdmi_info . bits . C0_C1 == COLORIMETRY_EXTENDED && hdmi_info . bits . EC0_EC2 == COLORIMETRYEX_RESERVED ) { hdmi_info . bits . header . version = 4 ; hdmi_info . bits . header . length = 14 ; } if ( rid != 0 && fr_ind != 0 ) { hdmi_info . bits . header . version = 5 ; hdmi_info . bits . header . length = 15 ; hdmi_info . bits . FR0_FR3 = fr_ind & 0xF ; hdmi_info . bits . FR4 = ( fr_ind >> 4 ) & 0x1 ; hdmi_info . bits . RID0_RID5 = rid ; } hdmi_info . bits . PR0_PR3 = 0 ; hdmi_info . bits . bar_top = stream -> timing . v_border_top ; hdmi_info . bits . bar_bottom = ( stream -> timing . v_total - stream -> timing . v_border_bottom + 1 ) ; hdmi_info . bits . bar_left = stream -> timing . h_border_left ; hdmi_info . bits . bar_right = ( stream -> timing . h_total - stream -> timing . h_border_right + 1 ) ; hdmi_info . bits . ACE0_ACE3 = 0 ; check_sum = & hdmi_info . packet_raw_data . sb [ 0 ] ; * check_sum = HDMI_INFOFRAME_TYPE_AVI + hdmi_info . bits . header . length + hdmi_info . bits . header . version ; for ( byte_index = 1 ; byte_index <= hdmi_info . bits . header . length ; byte_index ++ ) { * check_sum += hdmi_info . packet_raw_data . sb [ byte_index ] ; } * check_sum = ( uint8_t ) ( 0x100 - * check_sum ) ; info_packet -> hb0 = hdmi_info . packet_raw_data . hb0 ; info_packet -> hb1 = hdmi_info . packet_raw_data . hb1 ; info_packet -> hb2 = hdmi_info . packet_raw_data . hb2 ; for ( byte_index = 0 ; byte_index < sizeof ( hdmi_info . packet_raw_data . sb ) ; byte_index ++ ) { info_packet -> sb [ byte_index ] = hdmi_info . packet_raw_data . sb [ byte_index ] ; } info_packet -> valid = true ; } 