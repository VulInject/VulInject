static void SCFindEdges ( struct charone * ch , WidthInfo * wi ) { RefChar * ref ; SplineChar * sc ; int i ; DBounds bb ; SplineCharQuickConservativeBounds ( ch -> sc , & bb ) ; ch -> base = rint ( bb . miny / wi -> decimation ) ; ch -> top = rint ( bb . maxy / wi -> decimation ) ; ch -> ledge = malloc ( ( ch -> top - ch -> base + 1 ) * sizeof ( short ) ) ; ch -> redge = malloc ( ( ch -> top - ch -> base + 1 ) * sizeof ( short ) ) ; for ( i = 0 ; i <= ch -> top - ch -> base ; ++ i ) { ch -> ledge [ i ] = ch -> redge [ i ] = NOTREACHED ; } SSFindEdges ( ch -> sc -> layers [ wi -> layer ] . splines , ch , wi ) ; for ( ref = ch -> sc -> layers [ wi -> layer ] . refs ; ref != NULL ; ref = ref -> next ) { SSFindEdges ( ref -> layers [ 0 ] . splines , ch , wi ) ; } ch -> lbearing = ch -> rmax = NOTREACHED ; for ( i = 0 ; i <= ch -> top - ch -> base ; ++ i ) { if ( ch -> ledge [ i ] != NOTREACHED ) { if ( ch -> lbearing == NOTREACHED || ch -> ledge [ i ] < ch -> lbearing ) { ch -> lbearing = ch -> ledge [ i ] ; } } if ( ch -> redge [ i ] != NOTREACHED ) { if ( ch -> rmax == NOTREACHED || ch -> redge [ i ] > ch -> rmax ) { ch -> rmax = ch -> redge [ i ] ; } } } sc = ch -> sc ; while ( sc -> layers [ wi -> layer ] . refs != NULL ) { for ( ref = ch -> sc -> layers [ wi -> layer ] . refs ; ref != NULL ; ref = ref -> next ) { if ( ref -> sc -> unicodeenc != - 1 && isalpha ( ref -> sc -> unicodeenc ) ) { break ; } } sc = ref -> sc ; } SplineCharQuickBounds ( ch -> sc , & bb ) ; if ( sc -> unicodeenc == 'k' ) { ch -> baseserif = 1 ; ch -> lefttops = 3 ; ch -> righttops = 2 ; } else { ch -> baseserif = ( bb . miny >= 0 || - bb . miny < - wi -> descent / 2 ) ?1 : 0 ; ch -> lefttops = ch -> righttops = ( bb . maxy <= wi -> xheight || bb . maxy - wi -> xheight < wi -> caph - bb . maxy ) ?2 : 3 ; } } 