void ff_vp9_decode_block ( VP9TileData * td , int row , int col , VP9Filter * lflvl , ptrdiff_t yoff , ptrdiff_t uvoff , enum BlockLevel bl , enum BlockPartition bp ) { const VP9Context * s = td -> s ; VP9Block * b = td -> b ; enum BlockSize bs = bl * 3 + bp ; int bytesperpixel = s -> bytesperpixel ; int w4 = ff_vp9_bwh_tab [ 1 ] [ bs ] [ 0 ] , h4 = ff_vp9_bwh_tab [ 1 ] [ bs ] [ 1 ] , lvl ; int emu [ 2 ] ; AVFrame * f = s -> s . frames [ CUR_FRAME ] . tf . f ; td -> row = row ; td -> row7 = row & 7 ; td -> col = col ; td -> col7 = col & 7 ; td -> min_mv . x = - ( 128 + col * 64 ) ; td -> min_mv . y = - ( 128 + row * 64 ) ; td -> max_mv . x = 128 + ( s -> cols - col - w4 ) * 64 ; td -> max_mv . y = 128 + ( s -> rows - row - h4 ) * 64 ; if ( s -> pass < 2 ) { b -> bs = bs ; b -> bl = bl ; b -> bp = bp ; decode_mode ( td ) ; b -> uvtx = b -> tx - ( ( s -> ss_h && w4 * 2 == ( 1 << b -> tx ) ) || ( s -> ss_v && h4 * 2 == ( 1 << b -> tx ) ) ) ; if ( td -> block_structure ) { td -> block_structure [ td -> nb_block_structure ] . row = row ; td -> block_structure [ td -> nb_block_structure ] . col = col ; td -> block_structure [ td -> nb_block_structure ] . block_size_idx_x = av_log2 ( w4 ) ; td -> block_structure [ td -> nb_block_structure ] . block_size_idx_y = av_log2 ( h4 ) ; td -> nb_block_structure ++ ; } if ( ! b -> skip ) { int has_coeffs ; if ( bytesperpixel == 1 ) { has_coeffs = decode_coeffs_8bpp ( td ) ; } else { has_coeffs = decode_coeffs_16bpp ( td ) ; } if ( ! has_coeffs && b -> bs <= BS_8x8 && ! b -> intra ) { b -> skip = 1 ; memset ( & s -> above_skip_ctx [ col ] , 1 , w4 ) ; memset ( & td -> left_skip_ctx [ td -> row7 ] , 1 , h4 ) ; } } else { int row7 = td -> row7 ; switch ( n ) { case 1 : v = 0 ; break ; case 2 : AV_ZERO16 ( & v ) ; break ; case 4 : AV_ZERO32 ( & v ) ; break ; case 8 : AV_ZERO64 ( & v ) ; break ; case 16 : AV_ZERO128 ( & v ) ; break ; } { SPLAT_ZERO_CTX ( dir # # _y_ # # var [ off * 2 ] , n * 2 ) ; if ( s -> ss_ # # dir2 ) { SPLAT_ZERO_CTX ( dir # # _uv_ # # var [ 0 ] [ off ] , n ) ; SPLAT_ZERO_CTX ( dir # # _uv_ # # var [ 1 ] [ off ] , n ) ; } else { SPLAT_ZERO_CTX ( dir # # _uv_ # # var [ 0 ] [ off * 2 ] , n * 2 ) ; SPLAT_ZERO_CTX ( dir # # _uv_ # # var [ 1 ] [ off * 2 ] , n * 2 ) ; } } { case 1 : SPLAT_ZERO_YUV ( s -> above , nnz_ctx , col , 1 , h ) ; break ; case 2 : SPLAT_ZERO_YUV ( s -> above , nnz_ctx , col , 2 , h ) ; break ; case 4 : SPLAT_ZERO_YUV ( s -> above , nnz_ctx , col , 4 , h ) ; break ; case 8 : SPLAT_ZERO_YUV ( s -> above , nnz_ctx , col , 8 , h ) ; break ; } } switch ( h4 ) { case 1 : SPLAT_ZERO_YUV ( td -> left , nnz_ctx , row7 , 1 , v ) ; break ; case 2 : SPLAT_ZERO_YUV ( td -> left , nnz_ctx , row7 , 2 , v ) ; break ; case 4 : SPLAT_ZERO_YUV ( td -> left , nnz_ctx , row7 , 4 , v ) ; break ; case 8 : SPLAT_ZERO_YUV ( td -> left , nnz_ctx , row7 , 8 , v ) ; break ; } } if ( s -> pass == 1 ) { s -> td [ 0 ] . b ++ ; s -> td [ 0 ] . block += w4 * h4 * 64 * bytesperpixel ; s -> td [ 0 ] . uvblock [ 0 ] += w4 * h4 * 64 * bytesperpixel >> ( s -> ss_h + s -> ss_v ) ; s -> td [ 0 ] . uvblock [ 1 ] += w4 * h4 * 64 * bytesperpixel >> ( s -> ss_h + s -> ss_v ) ; s -> td [ 0 ] . eob += 4 * w4 * h4 ; s -> td [ 0 ] . uveob [ 0 ] += 4 * w4 * h4 >> ( s -> ss_h + s -> ss_v ) ; s -> td [ 0 ] . uveob [ 1 ] += 4 * w4 * h4 >> ( s -> ss_h + s -> ss_v ) ; return ; } } emu [ 0 ] = ( col + w4 ) * 8 * bytesperpixel > f -> linesize [ 0 ] || ( row + h4 ) > s -> rows ; emu [ 1 ] = ( ( col + w4 ) * 8 >> s -> ss_h ) * bytesperpixel > f -> linesize [ 1 ] || ( row + h4 ) > s -> rows ; if ( emu [ 0 ] ) { td -> dst [ 0 ] = td -> tmp_y ; td -> y_stride = 128 ; } else { td -> dst [ 0 ] = f -> data [ 0 ] + yoff ; td -> y_stride = f -> linesize [ 0 ] ; } if ( emu [ 1 ] ) { td -> dst [ 1 ] = td -> tmp_uv [ 0 ] ; td -> dst [ 2 ] = td -> tmp_uv [ 1 ] ; td -> uv_stride = 128 ; } else { td -> dst [ 1 ] = f -> data [ 1 ] + uvoff ; td -> dst [ 2 ] = f -> data [ 2 ] + uvoff ; td -> uv_stride = f -> linesize [ 1 ] ; } if ( b -> intra ) { if ( s -> s . h . bpp > 8 ) { ff_vp9_intra_recon_16bpp ( td , yoff , uvoff ) ; } else { ff_vp9_intra_recon_8bpp ( td , yoff , uvoff ) ; } } else { if ( s -> s . h . bpp > 8 ) { ff_vp9_inter_recon_16bpp ( td ) ; } else { ff_vp9_inter_recon_8bpp ( td ) ; } } if ( emu [ 0 ] ) { int w = FFMIN ( s -> cols - col , w4 ) * 8 , h = FFMIN ( s -> rows - row , h4 ) * 8 , n , o = 0 ; for ( n = 0 ; o < w ; n ++ ) { int bw = 64 >> n ; av_assert2 ( n <= 4 ) ; if ( w & bw ) { s -> dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( f -> data [ 0 ] + yoff + o * bytesperpixel , f -> linesize [ 0 ] , td -> tmp_y + o * bytesperpixel , 128 , h , 0 , 0 ) ; o += bw ; } } } if ( emu [ 1 ] ) { int w = FFMIN ( s -> cols - col , w4 ) * 8 >> s -> ss_h ; int h = FFMIN ( s -> rows - row , h4 ) * 8 >> s -> ss_v , n , o = 0 ; for ( n = s -> ss_h ; o < w ; n ++ ) { int bw = 64 >> n ; av_assert2 ( n <= 4 ) ; if ( w & bw ) { s -> dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( f -> data [ 1 ] + uvoff + o * bytesperpixel , f -> linesize [ 1 ] , td -> tmp_uv [ 0 ] + o * bytesperpixel , 128 , h , 0 , 0 ) ; s -> dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( f -> data [ 2 ] + uvoff + o * bytesperpixel , f -> linesize [ 2 ] , td -> tmp_uv [ 1 ] + o * bytesperpixel , 128 , h , 0 , 0 ) ; o += bw ; } } } if ( s -> s . h . filter . level && ( lvl = s -> s . h . segmentation . feat [ b -> seg_id ] . lflvl [ b -> intra ?0 : b -> ref [ 0 ] + 1 ] [ b -> mode [ 3 ] != ZEROMV ] ) > 0 ) { int x_end = FFMIN ( s -> cols - col , w4 ) , y_end = FFMIN ( s -> rows - row , h4 ) ; int skip_inter = ! b -> intra && b -> skip , col7 = td -> col7 , row7 = td -> row7 ; setctx_2d ( & lflvl -> level [ row7 * 8 + col7 ] , w4 , h4 , 8 , lvl ) ; mask_edges ( lflvl -> mask [ 0 ] , 0 , 0 , row7 , col7 , x_end , y_end , 0 , 0 , b -> tx , skip_inter ) ; if ( s -> ss_h || s -> ss_v ) { mask_edges ( lflvl -> mask [ 1 ] , s -> ss_h , s -> ss_v , row7 , col7 , x_end , y_end , s -> cols & 1 && col + w4 >= s -> cols ?s -> cols & 7 : 0 , s -> rows & 1 && row + h4 >= s -> rows ?s -> rows & 7 : 0 , b -> uvtx , skip_inter ) ; } } if ( s -> pass == 2 ) { s -> td [ 0 ] . b ++ ; s -> td [ 0 ] . block += w4 * h4 * 64 * bytesperpixel ; s -> td [ 0 ] . uvblock [ 0 ] += w4 * h4 * 64 * bytesperpixel >> ( s -> ss_v + s -> ss_h ) ; s -> td [ 0 ] . uvblock [ 1 ] += w4 * h4 * 64 * bytesperpixel >> ( s -> ss_v + s -> ss_h ) ; s -> td [ 0 ] . eob += 4 * w4 * h4 ; s -> td [ 0 ] . uveob [ 0 ] += 4 * w4 * h4 >> ( s -> ss_v + s -> ss_h ) ; s -> td [ 0 ] . uveob [ 1 ] += 4 * w4 * h4 >> ( s -> ss_v + s -> ss_h ) ; } 