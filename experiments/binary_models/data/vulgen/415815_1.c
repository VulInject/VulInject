static gboolean val_from_literal ( fvalue_t * fv , const char * s , gboolean allow_partial_value _U_ , gchar * * err_msg ) { guint32 addr ; unsigned int nmask_bits ; const char * slash , * net_str ; const char * addr_str ; char * addr_str_to_free = NULL ; fvalue_t * nmask_fvalue ; slash = strchr ( s , '/' ) ; if ( slash ) { addr_str_to_free = wmem_strndup ( NULL , s , slash - s ) ; addr_str = addr_str_to_free ; } else { addr_str = s ; } if ( ! get_host_ipaddr ( addr_str , & addr ) ) { if ( err_msg != NULL ) { * err_msg = ws_strdup_printf ( "\"%s\" is not a valid hostname or IPv4 address." , addr_str ) ; } return FALSE ; } if ( addr_str_to_free ) { wmem_free ( NULL , addr_str_to_free ) ; } fv -> value . ipv4 . addr = g_ntohl ( addr ) ; if ( slash ) { net_str = slash + 1 ; nmask_fvalue = fvalue_from_literal ( FT_UINT32 , net_str , FALSE , err_msg ) ; if ( ! nmask_fvalue ) { return FALSE ; } nmask_bits = fvalue_get_uinteger ( nmask_fvalue ) ; fvalue_free ( nmask_fvalue ) ; if ( nmask_bits > 32 ) { if ( err_msg != NULL ) { * err_msg = ws_strdup_printf ( "Netmask bits in a CIDR IPv4 address should be<= 32, not %u" , nmask_bits ) ; } return FALSE ; } fv -> value . ipv4 . nmask = ip_get_subnet_mask ( nmask_bits ) ; } else { fv -> value . ipv4 . nmask = ip_get_subnet_mask ( 32 ) ; } return TRUE ; } 