static void fmd_case_match_suspects ( fmd_asru_link_t * alp , void * arg ) { fcms_t * fcmsp = ( fcms_t * ) arg ; fmd_case_impl_t * cip = fcmsp -> fcms_cip ; fmd_case_susp_t * cis ; int i = 0 ; int state = fmd_asru_al_getstate ( alp ) ; if ( ! ( state & FMD_ASRU_PRESENT ) || ( ! ( state & FMD_ASRU_FAULTY ) && alp -> al_reason == FMD_ASRU_REMOVED ) ) { fcmsp -> fcms_old_susp_state [ * fcmsp -> fcms_countp ] = SUSPECT_STATE_REMOVED ; } if ( ( state & FMD_ASRU_UNUSABLE ) && ( state & FMD_ASRU_FAULTY ) ) { fcmsp -> fcms_old_susp_state [ * fcmsp -> fcms_countp ] = SUSPECT_STATE_ISOLATED ; } if ( state & FMD_ASRU_FAULTY ) { fcmsp -> fcms_old_susp_state [ * fcmsp -> fcms_countp ] = SUSPECT_STATE_FAULTY ; } if ( alp -> al_reason == FMD_ASRU_REPLACED ) { fcmsp -> fcms_old_susp_state [ * fcmsp -> fcms_countp ] = SUSPECT_STATE_REPLACED ; } if ( alp -> al_reason == FMD_ASRU_ACQUITTED ) { fcmsp -> fcms_old_susp_state [ * fcmsp -> fcms_countp ] = SUSPECT_STATE_ACQUITED ; } else { fcmsp -> fcms_old_susp_state [ * fcmsp -> fcms_countp ] = SUSPECT_STATE_REPAIRED ; } for ( cis = cip -> ci_suspects ; cis != NULL ; cis = cis -> cis_next , i ++ ) { if ( fmd_case_match_suspect ( cis -> cis_nvl , alp -> al_event ) == 1 ) { break ; } } if ( cis != NULL ) { fcmsp -> fcms_new_susp_state [ i ] = fcmsp -> fcms_old_susp_state [ * fcmsp -> fcms_countp ] ; } else { fcmsp -> fcms_old_match_state [ * fcmsp -> fcms_countp ] |= SUSPECT_STATE_NO_MATCH ; } ( * fcmsp -> fcms_countp ) ++ ; } 