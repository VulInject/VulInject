PIX * pixLinearMapToTargetColor ( PIX * pixd , PIX * pixs , l_uint32 srcval , l_uint32 dstval ) { l_int32 i , j , w , h , wpl ; l_int32 rval , gval , bval , rsval , gsval , bsval , rdval , gdval , bdval ; l_int32 * rtab , * gtab , * btab ; l_uint32 pixel ; l_uint32 * line , * data ; if ( ! pixs || pixGetDepth ( pixs ) != 32 ) { return ( PIX * ) ERROR_PTR ( "pixs undefined or not 32 bpp" , __func__ , pixd ) ; } if ( pixd && ( pixd != pixs ) ) { return ( PIX * ) ERROR_PTR ( "pixd exists, but != pixs" , __func__ , pixd ) ; } if ( ! pixd ) { pixd = pixCopy ( NULL , pixs ) ; } extractRGBValues ( srcval , & rsval , & gsval , & bsval ) ; extractRGBValues ( dstval , & rdval , & gdval , & bdval ) ; rsval = L_MIN ( 254 , L_MAX ( 1 , rsval ) ) ; gsval = L_MIN ( 254 , L_MAX ( 1 , gsval ) ) ; bsval = L_MIN ( 254 , L_MAX ( 1 , bsval ) ) ; rtab = ( l_int32 * ) LEPT_CALLOC ( 256 , sizeof ( l_int32 ) ) ; gtab = ( l_int32 * ) LEPT_CALLOC ( 256 , sizeof ( l_int32 ) ) ; btab = ( l_int32 * ) LEPT_CALLOC ( 256 , sizeof ( l_int32 ) ) ; if ( ! rtab || ! gtab || ! btab ) { return ( PIX * ) ERROR_PTR ( "calloc fail for tab" , __func__ , pixd ) ; } for ( i = 0 ; i < 256 ; i ++ ) { if ( i <= rsval ) { rtab [ i ] = ( i * rdval ) / rsval ; } else { rtab [ i ] = rdval + ( ( 255 - rdval ) * ( i - rsval ) ) / ( 255 - rsval ) ; } if ( i <= gsval ) { gtab [ i ] = ( i * gdval ) / gsval ; } else { gtab [ i ] = gdval + ( ( 255 - gdval ) * ( i - gsval ) ) / ( 255 - gsval ) ; } else { btab [ i ] = bdval + ( ( 255 - bdval ) * ( i - bsval ) ) / ( 255 - bsval ) ; } } pixGetDimensions ( pixd , & w , & h , NULL ) ; data = pixGetData ( pixd ) ; wpl = pixGetWpl ( pixd ) ; for ( i = 0 ; i < h ; i ++ ) { line = data + i * wpl ; for ( j = 0 ; j < w ; j ++ ) { pixel = line [ j ] ; extractRGBValues ( pixel , & rval , & gval , & bval ) ; composeRGBPixel ( rtab [ rval ] , gtab [ gval ] , btab [ bval ] , & pixel ) ; line [ j ] = pixel ; } } LEPT_FREE ( rtab ) ; LEPT_FREE ( gtab ) ; LEPT_FREE ( btab ) ; return pixd ; } 