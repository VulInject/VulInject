static uint32_t emlxs_sli4_issue_mbox_cmd ( emlxs_hba_t * hba , MAILBOXQ * mbq , int32_t flag , uint32_t tmo ) { emlxs_port_t * port ; MAILBOX4 * mb4 ; MAILBOX * mb ; mbox_rsp_hdr_t * hdr_rsp ; MATCHMAP * mp ; uint32_t * iptr ; uint32_t rc ; uint32_t i ; uint32_t tmo_local ; port = ( emlxs_port_t * ) mbq -> port ; mb4 = ( MAILBOX4 * ) mbq ; mb = ( MAILBOX * ) mbq ; mb -> mbxStatus = MBX_SUCCESS ; rc = MBX_SUCCESS ; switch ( mb -> mbxCommand ) { case MBX_DOWN_LOAD : case MBX_UPDATE_CFG : case MBX_LOAD_AREA : case MBX_LOAD_EXP_ROM : case MBX_WRITE_NV : case MBX_FLASH_WR_ULA : case MBX_DEL_LD_ENTRY : case MBX_LOAD_SM : case MBX_DUMP_MEMORY : case MBX_WRITE_VPARMS : case MBX_ACCESS_VDATA : if ( tmo < 300 ) { tmo = 300 ; } break ; case MBX_SLI_CONFIG : { mbox_req_hdr_t * hdr_req ; hdr_req = ( mbox_req_hdr_t * ) & mb4 -> un . varSLIConfig . be . un_hdr . hdr_req ; if ( hdr_req -> subsystem == IOCTL_SUBSYSTEM_COMMON ) { switch ( hdr_req -> opcode ) { case COMMON_OPCODE_WRITE_OBJ : case COMMON_OPCODE_READ_OBJ : case COMMON_OPCODE_READ_OBJ_LIST : case COMMON_OPCODE_DELETE_OBJ : case COMMON_OPCODE_SET_BOOT_CFG : case COMMON_OPCODE_GET_PROFILE_CFG : case COMMON_OPCODE_SET_PROFILE_CFG : case COMMON_OPCODE_GET_PROFILE_LIST : case COMMON_OPCODE_SET_ACTIVE_PROFILE : case COMMON_OPCODE_GET_PROFILE_CAPS : case COMMON_OPCODE_GET_MR_PROFILE_CAPS : case COMMON_OPCODE_SET_MR_PROFILE_CAPS : case COMMON_OPCODE_SET_FACTORY_PROFILE_CFG : case COMMON_OPCODE_SEND_ACTIVATION : case COMMON_OPCODE_RESET_LICENSES : case COMMON_OPCODE_SET_PHYSICAL_LINK_CFG_V1 : case COMMON_OPCODE_GET_VPD_DATA : if ( tmo < 300 ) { tmo = 300 ; } break ; default : if ( tmo < 30 ) { tmo = 30 ; } } } if ( hdr_req -> subsystem == IOCTL_SUBSYSTEM_FCOE ) { switch ( hdr_req -> opcode ) { case FCOE_OPCODE_SET_FCLINK_SETTINGS : if ( tmo < 300 ) { tmo = 300 ; } break ; default : if ( tmo < 30 ) { tmo = 30 ; } } } else { if ( tmo < 30 ) { tmo = 30 ; } } break ; } default : if ( tmo < 30 ) { tmo = 30 ; } break ; } tmo_local = tmo * 100 ; mutex_enter ( & EMLXS_PORT_LOCK ) ; if ( flag != MBX_NOWAIT ) { if ( hba -> sli . sli4 . flag & EMLXS_SLI4_INTR_ENABLED ) { flag = MBX_SLEEP ; } else { flag = MBX_POLL ; } } else { if ( ! ( hba -> sli . sli4 . flag & EMLXS_SLI4_INTR_ENABLED ) ) { mb -> mbxStatus = MBX_HARDWARE_ERROR ; mutex_exit ( & EMLXS_PORT_LOCK ) ; EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "Interrupts disabled. %s failed." , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) ) ; return ( MBX_HARDWARE_ERROR ) ; } } if ( ( hba -> flag & FC_HARDWARE_ERROR ) && ! ( ( mb4 -> mbxCommand == MBX_SLI_CONFIG ) && ( mb4 -> un . varSLIConfig . be . un_hdr . hdr_req . opcode == COMMON_OPCODE_RESET ) ) ) { mb -> mbxStatus = MBX_HARDWARE_ERROR ; mutex_exit ( & EMLXS_PORT_LOCK ) ; EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "Hardware error reported. %s failed. status=%x mb=%p" , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) , mb -> mbxStatus , mb ) ; return ( MBX_HARDWARE_ERROR ) ; } if ( hba -> mbox_queue_flag ) { if ( flag == MBX_NOWAIT ) { EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "Busy.      %s: mb=%p NoWait." , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) , mb ) ; emlxs_mb_put ( hba , mbq ) ; HBASTATS . MboxBusy ++ ; mutex_exit ( & EMLXS_PORT_LOCK ) ; return ( MBX_BUSY ) ; } while ( hba -> mbox_queue_flag ) { mutex_exit ( & EMLXS_PORT_LOCK ) ; if ( tmo_local -- == 0 ) { EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_event_msg , "Timeout.   %s: mb=%p tmo=%d Waiting." , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) , mb , tmo ) ; mb -> mbxStatus = MBX_TIMEOUT ; return ( MBX_TIMEOUT ) ; } BUSYWAIT_MS ( 10 ) ; mutex_enter ( & EMLXS_PORT_LOCK ) ; if ( ( hba -> flag & FC_HARDWARE_ERROR ) && ! ( ( mb4 -> mbxCommand == MBX_SLI_CONFIG ) && ( mb4 -> un . varSLIConfig . be . un_hdr . hdr_req . opcode == COMMON_OPCODE_RESET ) ) ) { mb -> mbxStatus = MBX_HARDWARE_ERROR ; mutex_exit ( & EMLXS_PORT_LOCK ) ; EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "Hardware error reported. %s failed. " "status=%x mb=%p" , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) , mb -> mbxStatus , mb ) ; return ( MBX_HARDWARE_ERROR ) ; } } } emlxs_mb_init ( hba , mbq , flag , tmo ) ; if ( mb -> mbxCommand == MBX_DOWN_LINK ) { hba -> sli . sli4 . flag |= EMLXS_SLI4_DOWN_LINK ; } mutex_exit ( & EMLXS_PORT_LOCK ) ; switch ( flag ) { case MBX_NOWAIT : if ( mb -> mbxCommand != MBX_HEARTBEAT ) { if ( mb -> mbxCommand != MBX_DOWN_LOAD ) { EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "Sending.   %s: mb=%p NoWait. embedded %d" , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) , mb , ( ( mb -> mbxCommand != MBX_SLI_CONFIG ) ?1 : ( mb4 -> un . varSLIConfig . be . embedded ) ) ) ; } } iptr = hba -> sli . sli4 . mq . addr . virt ; iptr += ( hba -> sli . sli4 . mq . host_index * MAILBOX_CMD_SLI4_WSIZE ) ; hba -> sli . sli4 . mq . host_index ++ ; if ( hba -> sli . sli4 . mq . host_index >= hba -> sli . sli4 . mq . max_index ) { hba -> sli . sli4 . mq . host_index = 0 ; } if ( mbq -> bp ) { EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "BDE virt %p phys %p size x%x" , ( ( MATCHMAP * ) mbq -> bp ) -> virt , ( ( MATCHMAP * ) mbq -> bp ) -> phys , ( ( MATCHMAP * ) mbq -> bp ) -> size ) ; emlxs_data_dump ( port , "DATA" , ( uint32_t * ) ( ( ( MATCHMAP * ) mbq -> bp ) -> virt ) , 30 , 0 ) ; } rc = emlxs_sli4_issue_mq ( port , ( MAILBOX4 * ) iptr , mb , tmo_local ) ; break ; case MBX_POLL : if ( mb -> mbxCommand != MBX_DOWN_LOAD ) { EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "Sending.   %s: mb=%p Poll. embedded %d" , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) , mb , ( ( mb -> mbxCommand != MBX_SLI_CONFIG ) ?1 : ( mb4 -> un . varSLIConfig . be . embedded ) ) ) ; } rc = emlxs_sli4_issue_bootstrap ( hba , mb , tmo_local ) ; if ( rc == MBX_TIMEOUT ) { EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "Timeout.   %s: mb=%p tmo=%x Poll. embedded %d" , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) , mb , tmo , ( ( mb -> mbxCommand != MBX_SLI_CONFIG ) ?1 : ( mb4 -> un . varSLIConfig . be . embedded ) ) ) ; hba -> flag |= FC_MBOX_TIMEOUT ; EMLXS_STATE_CHANGE ( hba , FC_ERROR ) ; emlxs_mb_fini ( hba , NULL , MBX_TIMEOUT ) ; } else { if ( mb -> mbxCommand != MBX_DOWN_LOAD ) { EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "Completed.   %s: mb=%p status=%x Poll. " "embedded %d" , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) , mb , rc , ( ( mb -> mbxCommand != MBX_SLI_CONFIG ) ?1 : ( mb4 -> un . varSLIConfig . be . embedded ) ) ) ; } if ( ! ( mbq -> flag & MBQ_PASSTHRU ) ) { if ( mbq -> mbox_cmpl ) { ( void ) ( mbq -> mbox_cmpl ) ( hba , mbq ) ; } } emlxs_mb_fini ( hba , NULL , mb -> mbxStatus ) ; } mp = ( MATCHMAP * ) mbq -> nonembed ; if ( mp ) { hdr_rsp = ( mbox_rsp_hdr_t * ) mp -> virt ; if ( hdr_rsp -> status ) { EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "%s: MBX_NONEMBED_ERROR: 0x%x, 0x%x" , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) , hdr_rsp -> status , hdr_rsp -> extra_status ) ; mb -> mbxStatus = MBX_NONEMBED_ERROR ; } } rc = mb -> mbxStatus ; mbq = ( MAILBOXQ * ) emlxs_mb_get ( hba ) ; if ( mbq ) { i = emlxs_sli4_issue_mbox_cmd ( hba , mbq , MBX_NOWAIT , 0 ) ; if ( ( i != MBX_BUSY ) && ( i != MBX_SUCCESS ) ) { emlxs_mem_put ( hba , MEM_MBOX , ( void * ) mbq ) ; } } break ; case MBX_SLEEP : if ( mb -> mbxCommand != MBX_DOWN_LOAD ) { EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "Sending.   %s: mb=%p Sleep. embedded %d" , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) , mb , ( ( mb -> mbxCommand != MBX_SLI_CONFIG ) ?1 : ( mb4 -> un . varSLIConfig . be . embedded ) ) ) ; } iptr = hba -> sli . sli4 . mq . addr . virt ; iptr += ( hba -> sli . sli4 . mq . host_index * MAILBOX_CMD_SLI4_WSIZE ) ; hba -> sli . sli4 . mq . host_index ++ ; if ( hba -> sli . sli4 . mq . host_index >= hba -> sli . sli4 . mq . max_index ) { hba -> sli . sli4 . mq . host_index = 0 ; } rc = emlxs_sli4_issue_mq ( port , ( MAILBOX4 * ) iptr , mb , tmo_local ) ; if ( rc != MBX_SUCCESS ) { break ; } mutex_enter ( & EMLXS_MBOX_LOCK ) ; while ( ! ( mbq -> flag & MBQ_COMPLETED ) ) { cv_wait ( & EMLXS_MBOX_CV , & EMLXS_MBOX_LOCK ) ; } mutex_exit ( & EMLXS_MBOX_LOCK ) ; mp = ( MATCHMAP * ) mbq -> nonembed ; if ( mp ) { hdr_rsp = ( mbox_rsp_hdr_t * ) mp -> virt ; if ( hdr_rsp -> status ) { EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "%s: MBX_NONEMBED_ERROR: 0x%x, 0x%x" , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) , hdr_rsp -> status , hdr_rsp -> extra_status ) ; mb -> mbxStatus = MBX_NONEMBED_ERROR ; } } rc = mb -> mbxStatus ; if ( rc == MBX_TIMEOUT ) { EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "Timeout.   %s: mb=%p tmo=%x Sleep. embedded %d" , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) , mb , tmo , ( ( mb -> mbxCommand != MBX_SLI_CONFIG ) ?1 : ( mb4 -> un . varSLIConfig . be . embedded ) ) ) ; } else { if ( mb -> mbxCommand != MBX_DOWN_LOAD ) { EMLXS_MSGF ( EMLXS_CONTEXT , & emlxs_mbox_detail_msg , "Completed.   %s: mb=%p status=%x Sleep. " "embedded %d" , emlxs_mb_cmd_xlate ( mb -> mbxCommand ) , mb , rc , ( ( mb -> mbxCommand != MBX_SLI_CONFIG ) ?1 : ( mb4 -> un . varSLIConfig . be . embedded ) ) ) ; } } break ; } return ( rc ) ; } 