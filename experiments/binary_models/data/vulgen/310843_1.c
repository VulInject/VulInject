int file_write ( SCR * sp , MARK * fm , MARK * tm , char * name , int flags ) { { NEWFILE , OLDFILE } , mtype struct stat sb ; EXF * ep ; FILE * fp ; FREF * frp ; MARK from , to ; size_t len ; u_long nlno , nch ; int fd , nf , noname , oflags , rval ; char * p , * s , * t , buf [ PATH_MAX + 64 ] ; const char * msgstr ; ep = sp -> ep ; frp = sp -> frp ; if ( name == NULL || ! strcmp ( name , frp -> name ) ) { noname = 1 ; name = frp -> name ; } else { noname = 0 ; } if ( ! LF_ISSET ( FS_FORCE ) && noname && O_ISSET ( sp , O_READONLY ) ) { msgq ( sp , M_ERR , LF_ISSET ( FS_POSSIBLE ) ?"Read-only file, not written; use ! to override" : "Read-only file, not written" ) ; return ( 1 ) ; } if ( ! LF_ISSET ( FS_FORCE | FS_APPEND ) && ! O_ISSET ( sp , O_WRITEANY ) ) { if ( ( ! noname || F_ISSET ( frp , FR_NAMECHANGE ) ) && ! stat ( name , & sb ) ) { msgq_str ( sp , M_ERR , name , LF_ISSET ( FS_POSSIBLE ) ?"%s exists, not written; use ! to override" : "%s exists, not written" ) ; return ( 1 ) ; } if ( ! LF_ISSET ( FS_ALL ) && noname && ! stat ( name , & sb ) ) { msgq ( sp , M_ERR , LF_ISSET ( FS_POSSIBLE ) ?"Partial file, not written; use ! to override" : "Partial file, not written" ) ; return ( 1 ) ; } } if ( stat ( name , & sb ) ) { mtype = NEWFILE ; } else { if ( noname && ! LF_ISSET ( FS_FORCE | FS_APPEND ) && ( ( F_ISSET ( ep , F_DEVSET ) && ( sb . st_dev != ep -> mdev || sb . st_ino != ep -> minode ) ) || timespeccmp ( & sb . st_mtim , & ep -> mtim , != ) ) ) { msgq_str ( sp , M_ERR , name , LF_ISSET ( FS_POSSIBLE ) ?"%s: file modified more recently than this copy; use ! to override" : "%s: file modified more recently than this copy" ) ; return ( 1 ) ; } mtype = OLDFILE ; } oflags = O_CREAT | O_WRONLY | ( LF_ISSET ( FS_APPEND ) ?O_APPEND : O_TRUNC ) ; if ( ! opts_empty ( sp , O_BACKUP , 1 ) && file_backup ( sp , name , O_STR ( sp , O_BACKUP ) ) && ! LF_ISSET ( FS_FORCE ) ) { return ( 1 ) ; } if ( ( fd = open ( name , oflags , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH ) ) < 0 ) { msgq_str ( sp , M_SYSERR , name , "%s" ) ; return ( 1 ) ; } if ( ! noname && file_lock ( sp , NULL , NULL , fd , 0 ) == LOCK_UNAVAIL ) { msgq_str ( sp , M_ERR , name , "%s: write lock was unavailable" ) ; } if ( ( fp = fdopen ( fd , LF_ISSET ( FS_APPEND ) ?"a" : "w" ) ) == NULL ) { msgq_str ( sp , M_SYSERR , name , "%s" ) ; ( void ) close ( fd ) ; return ( 1 ) ; } if ( fm == NULL ) { from . lno = 1 ; from . cno = 0 ; fm = & from ; if ( db_last ( sp , & to . lno ) ) { return ( 1 ) ; } to . cno = 0 ; tm = & to ; } rval = ex_writefp ( sp , name , fp , fm , tm , & nlno , & nch , 0 ) ; if ( noname ) { if ( stat ( name , & sb ) ) { ( void ) clock_gettime ( CLOCK_REALTIME , & ep -> mtim ) ; } else { F_SET ( ep , F_DEVSET ) ; ep -> mdev = sb . st_dev ; ep -> minode = sb . st_ino ; ep -> mtim = sb . st_mtim ; } } if ( rval ) { if ( ! LF_ISSET ( FS_APPEND ) ) { msgq_str ( sp , M_ERR , name , "%s: WARNING: FILE TRUNCATED" ) ; } return ( 1 ) ; } F_CLR ( frp , FR_NAMECHANGE ) ; if ( LF_ISSET ( FS_ALL ) && ! LF_ISSET ( FS_APPEND ) ) { F_CLR ( ep , F_MODIFIED ) ; if ( F_ISSET ( frp , FR_TMPFILE ) ) { if ( noname ) { F_SET ( frp , FR_TMPEXIT ) ; } else { F_CLR ( frp , FR_TMPEXIT ) ; } } } p = msg_print ( sp , name , & nf ) ; switch ( mtype ) { case NEWFILE : len = snprintf ( buf , sizeof ( buf ) , "%s: new file: %lu lines, %lu characters" , p , nlno , nch ) ; if ( len >= sizeof ( buf ) ) { len = sizeof ( buf ) - 1 ; } break ; case OLDFILE : msgstr = LF_ISSET ( FS_APPEND ) ?"%s: appended: %lu lines, %lu characters" : "%s: %lu lines, %lu characters" ; len = snprintf ( buf , sizeof ( buf ) , msgstr , p , nlno , nch ) ; if ( len >= sizeof ( buf ) ) { len = sizeof ( buf ) - 1 ; } break ; default : abort ( ) ; } s = buf ; msgq ( sp , M_INFO , "%s" , s ) ; if ( nf ) { FREE_SPACE ( sp , p , 0 ) ; } return ( 0 ) ; } 