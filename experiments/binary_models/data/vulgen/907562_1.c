yyparse ( ) { int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken ; YYSTYPE yyval ; char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; int yylen = 0 ; yytoken = 0 ; yyss = yyssa ; yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , "Starting parse\n" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; yyssp = yyss ; yyvsp = yyvs ; yysetstate yynewstate yyssp ++ ; yysetstate * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( "memory exhausted" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } yyexhaustedlab if ( YYMAXDEPTH <= yystacksize ) { yyexhaustedlab } yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) { yystacksize = YYMAXDEPTH ; } { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) { yyexhaustedlab } YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; if ( yyss1 != yyssa ) { YYSTACK_FREE ( yyss1 ) ; } } yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , "Stack size increased to %lu\n" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) { YYABORT ; } } YYDPRINTF ( ( stderr , "Entering state %d\n" , yystate ) ) ; if ( yystate == YYFINAL ) { YYACCEPT ; } yybackup yybackup yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) { yydefault } if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , "Reading a token: " ) ) ; yychar = YYLEX ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , "Now at end of input.\n" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( "Next token is" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) { yydefault } yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) { yyerrlab } yyn = - yyn ; yyreduce } if ( yyerrstatus ) { yyerrstatus -- ; } YY_SYMBOL_PRINT ( "Shifting" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; * ++ yyvsp = yylval ; yynewstate yydefault yyn = yydefact [ yystate ] ; if ( yyn == 0 ) { yyerrlab } yyreduce yyreduce yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 3 : { g_strreplace ( & _map_info -> image_name , ( yyvsp [ ( 5 ) - ( 7 ) ] . id ) ) ; g_free ( ( yyvsp [ ( 5 ) - ( 7 ) ] . id ) ) ; } break ; case 8 : { } break ; case 9 : { g_free ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ; } break ; case 10 : { g_free ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ; } break ; case 11 : { _map_info -> old_image_width = ( yyvsp [ ( 3 ) - ( 3 ) ] . val ) ; } break ; case 12 : { _map_info -> old_image_height = ( yyvsp [ ( 3 ) - ( 3 ) ] . val ) ; } break ; case 13 : { ( yyval . val ) = ( gint ) ( yyvsp [ ( 1 ) - ( 1 ) ] . value ) ; } break ; case 14 : { ( yyval . val ) = ( gint ) g_ascii_strtod ( ( yyvsp [ ( 1 ) - ( 1 ) ] . id ) , NULL ) ; g_free ( ( yyvsp [ ( 1 ) - ( 1 ) ] . id ) ) ; } break ; case 15 : { g_strreplace ( & _map_info -> title , ( yyvsp [ ( 5 ) - ( 6 ) ] . id ) ) ; g_free ( ( yyvsp [ ( 5 ) - ( 6 ) ] . id ) ) ; } break ; case 21 : { g_free ( ( yyvsp [ ( 2 ) - ( 3 ) ] . id ) ) ; } break ; case 22 : { g_strreplace ( & _map_info -> author , ( yyvsp [ ( 2 ) - ( 3 ) ] . id ) ) ; g_free ( ( yyvsp [ ( 2 ) - ( 3 ) ] . id ) ) ; } break ; case 23 : { gchar * description ; description = g_strconcat ( _map_info -> description , ( yyvsp [ ( 2 ) - ( 3 ) ] . id ) , "\n" , NULL ) ; g_strreplace ( & _map_info -> description , description ) ; g_free ( ( yyvsp [ ( 2 ) - ( 3 ) ] . id ) ) ; } break ; case 26 : { if ( current_type != UNDEFINED ) { add_shape ( current_object ) ; } } break ; case 41 : { if ( ! g_ascii_strcasecmp ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) , "RECT" ) ) { current_object = create_rectangle ( 0 , 0 , 0 , 0 ) ; current_type = RECTANGLE ; } if ( ! g_ascii_strcasecmp ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) , "CIRCLE" ) ) { current_object = create_circle ( 0 , 0 , 0 ) ; current_type = CIRCLE ; } if ( ! g_ascii_strcasecmp ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) , "POLY" ) ) { current_object = create_polygon ( NULL ) ; current_type = POLYGON ; } if ( ! g_ascii_strcasecmp ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) , "DEFAULT" ) ) { current_type = UNDEFINED ; } g_free ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ; } break ; case 42 : { char * p ; if ( current_type == RECTANGLE ) { Rectangle_t * rectangle ; rectangle = ObjectToRectangle ( current_object ) ; p = strtok ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) , "," ) ; rectangle -> x = atoi ( p ) ; p = strtok ( NULL , "," ) ; rectangle -> y = atoi ( p ) ; p = strtok ( NULL , "," ) ; rectangle -> width = atoi ( p ) - rectangle -> x ; p = strtok ( NULL , "," ) ; rectangle -> height = atoi ( p ) - rectangle -> y ; } if ( current_type == CIRCLE ) { Circle_t * circle ; circle = ObjectToCircle ( current_object ) ; p = strtok ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) , "," ) ; circle -> x = atoi ( p ) ; p = strtok ( NULL , "," ) ; circle -> y = atoi ( p ) ; p = strtok ( NULL , "," ) ; circle -> r = atoi ( p ) ; } if ( current_type == POLYGON ) { Polygon_t * polygon = ObjectToPolygon ( current_object ) ; GList * points ; GdkPoint * point , * first ; gint x , y ; p = strtok ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) , "," ) ; x = atoi ( p ) ; p = strtok ( NULL , "," ) ; y = atoi ( p ) ; point = new_point ( x , y ) ; points = g_list_append ( NULL , ( gpointer ) point ) ; while ( 1 ) { p = strtok ( NULL , "," ) ; if ( ! p ) { break ; } x = atoi ( p ) ; p = strtok ( NULL , "," ) ; y = atoi ( p ) ; point = new_point ( x , y ) ; points = g_list_append ( points , ( gpointer ) point ) ; } first = ( GdkPoint * ) points -> data ; polygon -> points = points ; if ( first -> x == point -> x && first -> y == point -> y ) { polygon_remove_last_point ( polygon ) ; } polygon -> points = points ; } g_free ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ; } break ; case 43 : { if ( current_type == UNDEFINED ) { g_strreplace ( & _map_info -> default_url , ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ; } else { object_set_url ( current_object , unescape_text ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ) ; } g_free ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ; } break ; case 44 : { } break ; case 46 : { g_free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . id ) ) ; } break ; case 47 : { object_set_comment ( current_object , unescape_text ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ) ; g_free ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ; } break ; case 48 : { object_set_target ( current_object , unescape_text ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ) ; g_free ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ; } break ; case 49 : { object_set_mouse_over ( current_object , unescape_text ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ) ; g_free ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ; } break ; case 50 : { object_set_mouse_out ( current_object , unescape_text ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ) ; g_free ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ; } break ; case 51 : { object_set_focus ( current_object , unescape_text ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ) ; g_free ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ; } break ; case 52 : { object_set_blur ( current_object , unescape_text ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ) ; g_free ( ( yyvsp [ ( 3 ) - ( 3 ) ] . id ) ) ; } break ; default : break ; } YY_SYMBOL_PRINT ( "->$$ =" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) { yystate = yytable [ yystate ] ; } else { yystate = yydefgoto [ yyn - YYNTOKENS ] ; } yynewstate yyerrlab yytoken = yychar == YYEMPTY ?YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; yyerror ( YY_ ( "syntax error" ) ) ; yyssp , yytoken ; { char const * yymsgp = YY_ ( "syntax error" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) { yymsgp = yymsg ; } if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) { YYSTACK_FREE ( yymsg ) ; } yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yymsgp ) ; if ( yysyntax_error_status == 2 ) { yyexhaustedlab } } } } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) { YYABORT ; } } else { yydestruct ( "Error: discarding" , yytoken , & yylval ) ; yychar = YYEMPTY ; } } yyerrlab1 yyerrorlab if ( 0 ) { yyerrorlab } YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; yyerrlab1 yyerrlab1 yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) { break ; } } } if ( yyssp == yyss ) { YYABORT ; } yydestruct ( "Error: popping" , yystos [ yystate ] , yyvsp ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } * ++ yyvsp = yylval ; YY_SYMBOL_PRINT ( "Shifting" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; yynewstate yyacceptlab yyresult = 0 ; yyreturn yyabortlab yyresult = 1 ; yyreturn yyexhaustedlab yyerror ( YY_ ( "memory exhausted" ) ) ; yyresult = 2 ; yyreturn if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( "Cleanup: discarding lookahead" , yytoken , & yylval ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( "Cleanup: popping" , yystos [ * yyssp ] , yyvsp ) ; YYPOPSTACK ( 1 ) ; } if ( yyss != yyssa ) { YYSTACK_FREE ( yyss ) ; } return YYID ( yyresult ) ; 