int cxlflash_ioctl ( struct scsi_device * sdev , unsigned int cmd , void __user * arg ) { int * sioctl ( struct scsi_device * , void * ) struct cxlflash_cfg * cfg = shost_priv ( sdev -> host ) ; struct device * dev = & cfg -> dev -> dev ; struct afu * afu = cfg -> afu ; struct dk_cxlflash_hdr * hdr ; char buf [ sizeof ( cxlflash_ioctls ) ] ; size_t size = 0 ; bool known_ioctl = false ; int idx ; int rc = 0 ; struct Scsi_Host * shost = sdev -> host ; sioctl do_ioctl = NULL ; static const { size_t size ; sioctl ioctl ; } , ioctl_tbl [ ] { { sizeof ( dk_cxlflash_attach ) ( sioctl ) cxlflash_disk_attach } { sizeof ( dk_cxlflash_udirect ) cxlflash_disk_direct_open } { sizeof ( dk_cxlflash_release ) ( sioctl ) cxlflash_disk_release } { sizeof ( dk_cxlflash_detach ) ( sioctl ) cxlflash_disk_detach } { sizeof ( dk_cxlflash_verify ) ( sioctl ) cxlflash_disk_verify } { sizeof ( dk_cxlflash_recover_afu ) ( sioctl ) cxlflash_afu_recover } { sizeof ( dk_cxlflash_manage_lun ) ( sioctl ) cxlflash_manage_lun } { sizeof ( dk_cxlflash_uvirtual ) cxlflash_disk_virtual_open } { sizeof ( dk_cxlflash_resize ) ( sioctl ) cxlflash_vlun_resize } { sizeof ( dk_cxlflash_clone ) ( sioctl ) cxlflash_disk_clone } } ; down_read ( & cfg -> ioctl_rwsem ) ; if ( afu -> internal_lun ) { switch ( cmd ) { case DK_CXLFLASH_RELEASE : case DK_CXLFLASH_USER_VIRTUAL : case DK_CXLFLASH_VLUN_RESIZE : case DK_CXLFLASH_VLUN_CLONE : dev_dbg ( dev , "%s: %s not supported for lun_mode=%d\n" , __func__ , decode_ioctl ( cmd ) , afu -> internal_lun ) ; rc = - EINVAL ; cxlflash_ioctl_exit } } switch ( cmd ) { case DK_CXLFLASH_ATTACH : case DK_CXLFLASH_USER_DIRECT : case DK_CXLFLASH_RELEASE : case DK_CXLFLASH_DETACH : case DK_CXLFLASH_VERIFY : case DK_CXLFLASH_RECOVER_AFU : case DK_CXLFLASH_USER_VIRTUAL : case DK_CXLFLASH_VLUN_RESIZE : case DK_CXLFLASH_VLUN_CLONE : dev_dbg ( dev , "%s: %s (%08X) on dev(%d/%d/%d/%llu)\n" , __func__ , decode_ioctl ( cmd ) , cmd , shost -> host_no , sdev -> channel , sdev -> id , sdev -> lun ) ; rc = ioctl_common ( sdev , cmd ) ; if ( unlikely ( rc ) ) { cxlflash_ioctl_exit } fallthrough ; case DK_CXLFLASH_MANAGE_LUN : known_ioctl = true ; idx = _IOC_NR ( cmd ) - _IOC_NR ( DK_CXLFLASH_ATTACH ) ; size = ioctl_tbl [ idx ] . size ; do_ioctl = ioctl_tbl [ idx ] . ioctl ; if ( likely ( do_ioctl ) ) { break ; } fallthrough ; default : rc = - EINVAL ; cxlflash_ioctl_exit } if ( unlikely ( copy_from_user ( & buf , arg , size ) ) ) { dev_err ( dev , "%s: copy_from_user() fail size=%lu cmd=%u (%s) arg=%p\n" , __func__ , size , cmd , decode_ioctl ( cmd ) , arg ) ; rc = - EFAULT ; cxlflash_ioctl_exit } hdr = ( dk_cxlflash_hdr * ) & buf ; if ( hdr -> rsvd [ 0 ] || hdr -> rsvd [ 1 ] || hdr -> rsvd [ 2 ] || hdr -> return_flags ) { dev_dbg ( dev , "%s: Reserved/rflags populated\n" , __func__ ) ; rc = - EINVAL ; cxlflash_ioctl_exit } rc = do_ioctl ( sdev , ( void * ) & buf ) ; if ( likely ( ! rc ) ) { if ( unlikely ( copy_to_user ( arg , & buf , size ) ) ) { dev_err ( dev , "%s: copy_to_user() fail size=%lu cmd=%u (%s) arg=%p\n" , __func__ , size , cmd , decode_ioctl ( cmd ) , arg ) ; rc = - EFAULT ; } } cxlflash_ioctl_exit up_read ( & cfg -> ioctl_rwsem ) ; if ( unlikely ( rc && known_ioctl ) ) { dev_err ( dev , "%s: ioctl %s (%08X) on dev(%d/%d/%d/%llu) " "returned rc %d\n" , __func__ , decode_ioctl ( cmd ) , cmd , shost -> host_no , sdev -> channel , sdev -> id , sdev -> lun , rc ) ; } else { dev_dbg ( dev , "%s: ioctl %s (%08X) on dev(%d/%d/%d/%llu) " "returned rc %d\n" , __func__ , decode_ioctl ( cmd ) , cmd , shost -> host_no , sdev -> channel , sdev -> id , sdev -> lun , rc ) ; } return rc ; } 