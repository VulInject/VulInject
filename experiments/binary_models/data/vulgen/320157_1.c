re_compile_bytecode ( , ) { re_compiled_code_t * cached_bytecode_p = re_cache_lookup ( pattern_str_p , flags ) ; re_compiler_ctx_t re_ctx ; re_ctx . flags = flags ; re_ctx . captures_count = 1 ; re_ctx . non_captures_count = 0 ; re_initialize_regexp_bytecode ( & re_ctx ) ; ECMA_STRING_TO_UTF8_STRING ( pattern_str_p , pattern_start_p , pattern_start_size ) ; re_ctx . input_start_p = pattern_start_p ; re_ctx . input_curr_p = ( lit_utf8_byte_t * ) pattern_start_p ; re_ctx . input_end_p = pattern_start_p + pattern_start_size ; re_ctx . groups_count = - 1 ; ecma_value_t result = re_parse_alternative ( & re_ctx , true ) ; ECMA_FINALIZE_UTF8_STRING ( pattern_start_p , pattern_start_size ) ; if ( ECMA_IS_VALUE_ERROR ( result ) ) { jmem_heap_free_block ( re_ctx . bytecode_start_p , re_ctx . bytecode_size ) ; return NULL ; } const uint32_t final_size = JERRY_ALIGNUP ( re_ctx . bytecode_size , JMEM_ALIGNMENT ) ; re_compiled_code_t * re_compiled_code_p = ( re_compiled_code_t * ) jmem_heap_realloc_block ( re_ctx . bytecode_start_p , re_ctx . bytecode_size , final_size ) ; re_compiled_code_p -> header . refs = 2 ; re_compiled_code_p -> header . size = ( uint16_t ) ( final_size >> JMEM_ALIGNMENT_LOG ) ; re_compiled_code_p -> header . status_flags = re_ctx . flags ; ecma_ref_ecma_string ( pattern_str_p ) ; re_compiled_code_p -> source = ecma_make_string_value ( pattern_str_p ) ; re_compiled_code_p -> captures_count = re_ctx . captures_count ; re_compiled_code_p -> non_captures_count = re_ctx . non_captures_count ; if ( JERRY_CONTEXT ( jerry_init_flags ) & JERRY_INIT_SHOW_REGEXP_OPCODES ) { re_dump_bytecode ( & re_ctx ) ; } uint8_t cache_idx = JERRY_CONTEXT ( re_cache_idx ) ; if ( JERRY_CONTEXT ( re_cache ) [ cache_idx ] != NULL ) { ecma_bytecode_deref ( ( ecma_compiled_code_t * ) JERRY_CONTEXT ( re_cache ) [ cache_idx ] ) ; } JERRY_CONTEXT ( re_cache ) [ cache_idx ] = re_compiled_code_p ; JERRY_CONTEXT ( re_cache_idx ) = ( uint8_t ) ( cache_idx + 1 ) % RE_CACHE_SIZE ; return re_compiled_code_p ; } 