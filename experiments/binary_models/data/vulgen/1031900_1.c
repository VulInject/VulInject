static struct nf_conn * __bpf_nf_ct_alloc_entry ( struct net * net , struct bpf_sock_tuple * bpf_tuple , u32 tuple_len , struct bpf_ct_opts * opts , u32 opts_len , u32 timeout ) { struct nf_conntrack_tuple otuple , rtuple ; struct nf_conn * ct ; int err ; if ( ! opts || ! bpf_tuple || opts -> reserved [ 0 ] || opts -> reserved [ 1 ] || opts_len != NF_BPF_CT_OPTS_SZ ) { return ERR_PTR ( - EINVAL ) ; } if ( unlikely ( opts -> netns_id < BPF_F_CURRENT_NETNS ) ) { return ERR_PTR ( - EINVAL ) ; } err = bpf_nf_ct_tuple_parse ( bpf_tuple , tuple_len , opts -> l4proto , IP_CT_DIR_ORIGINAL , & otuple ) ; if ( err < 0 ) { return ERR_PTR ( err ) ; } err = bpf_nf_ct_tuple_parse ( bpf_tuple , tuple_len , opts -> l4proto , IP_CT_DIR_REPLY , & rtuple ) ; if ( err < 0 ) { return ERR_PTR ( err ) ; } if ( opts -> netns_id >= 0 ) { net = get_net_ns_by_id ( net , opts -> netns_id ) ; if ( unlikely ( ! net ) ) { return ERR_PTR ( - ENONET ) ; } } ct = nf_conntrack_alloc ( net , & nf_ct_zone_dflt , & otuple , & rtuple , GFP_ATOMIC ) ; if ( IS_ERR ( ct ) ) { out } __nf_ct_set_timeout ( ct , timeout * HZ ) ; out if ( opts -> netns_id >= 0 ) { put_net ( net ) ; } return ct ; } 