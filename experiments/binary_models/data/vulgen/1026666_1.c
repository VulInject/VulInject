static int gp2ap020a00f_probe ( struct i2c_client * client ) { const struct i2c_device_id * id = i2c_client_get_device_id ( client ) ; struct gp2ap020a00f_data * data ; struct iio_dev * indio_dev ; struct regmap * regmap ; int err ; indio_dev = devm_iio_device_alloc ( & client -> dev , sizeof ( * data ) ) ; if ( ! indio_dev ) { return - ENOMEM ; } data = iio_priv ( indio_dev ) ; data -> vled_reg = devm_regulator_get ( & client -> dev , "vled" ) ; if ( IS_ERR ( data -> vled_reg ) ) { return PTR_ERR ( data -> vled_reg ) ; } err = regulator_enable ( data -> vled_reg ) ; if ( err ) { return err ; } regmap = devm_regmap_init_i2c ( client , & gp2ap020a00f_regmap_config ) ; if ( IS_ERR ( regmap ) ) { dev_err ( & client -> dev , "Regmap initialization failed.\n" ) ; err = PTR_ERR ( regmap ) ; error_regulator_disable } err = regmap_bulk_write ( regmap , GP2AP020A00F_OP_REG , gp2ap020a00f_reg_init_tab , ARRAY_SIZE ( gp2ap020a00f_reg_init_tab ) ) ; if ( err < 0 ) { dev_err ( & client -> dev , "Device initialization failed.\n" ) ; error_regulator_disable } i2c_set_clientdata ( client , indio_dev ) ; data -> client = client ; data -> cur_opmode = GP2AP020A00F_OPMODE_SHUTDOWN ; data -> regmap = regmap ; init_waitqueue_head ( & data -> data_ready_queue ) ; indio_dev -> channels = gp2ap020a00f_channels ; indio_dev -> num_channels = ARRAY_SIZE ( gp2ap020a00f_channels ) ; indio_dev -> info = & gp2ap020a00f_info ; indio_dev -> name = id -> name ; indio_dev -> modes = INDIO_DIRECT_MODE ; err = iio_triggered_buffer_setup ( indio_dev , & iio_pollfunc_store_time , & gp2ap020a00f_trigger_handler , & gp2ap020a00f_buffer_setup_ops ) ; if ( err < 0 ) { error_regulator_disable } data -> trig = devm_iio_trigger_alloc ( & client -> dev , "%s-trigger" , indio_dev -> name ) ; if ( data -> trig == NULL ) { err = - ENOMEM ; dev_err ( & indio_dev -> dev , "Failed to allocate iio trigger.\n" ) ; error_uninit_buffer } err = request_threaded_irq ( client -> irq , NULL , & gp2ap020a00f_thresh_event_handler , IRQF_TRIGGER_FALLING | IRQF_ONESHOT , "gp2ap020a00f_als_event" , indio_dev ) ; if ( err < 0 ) { dev_err ( & client -> dev , "Irq request failed.\n" ) ; error_uninit_buffer } init_irq_work ( & data -> work , gp2ap020a00f_iio_trigger_work ) ; err = iio_trigger_register ( data -> trig ) ; if ( err < 0 ) { dev_err ( & client -> dev , "Failed to register iio trigger.\n" ) ; error_free_irq } err = iio_device_register ( indio_dev ) ; if ( err < 0 ) { error_trigger_unregister } return 0 ; error_trigger_unregister iio_trigger_unregister ( data -> trig ) ; error_free_irq free_irq ( client -> irq , indio_dev ) ; error_uninit_buffer iio_triggered_buffer_cleanup ( indio_dev ) ; error_regulator_disable regulator_disable ( data -> vled_reg ) ; return err ; } 