static int conn_connect ( struct drbd_connection * connection ) { struct drbd_socket sock , msock ; struct drbd_peer_device * peer_device ; struct net_conf * nc ; int vnr , timeout , h ; bool discard_my_data , ok ; enum drbd_state_rv rv ; struct accept_wait_data ad = { . connection = connection . door_bell = COMPLETION_INITIALIZER_ONSTACK ( ad . door_bell ) } ; clear_bit ( DISCONNECT_SENT , & connection -> flags ) ; mutex_init ( & sock . mutex ) ; sock . sbuf = connection -> data . sbuf ; sock . rbuf = connection -> data . rbuf ; sock . socket = NULL ; mutex_init ( & msock . mutex ) ; msock . sbuf = connection -> meta . sbuf ; msock . rbuf = connection -> meta . rbuf ; msock . socket = NULL ; connection -> agreed_pro_version = 80 ; if ( prepare_listen_socket ( connection , & ad ) ) { return 0 ; } { struct socket * s ; s = drbd_try_connect ( connection ) ; if ( s ) { if ( ! sock . socket ) { sock . socket = s ; send_first_packet ( connection , & sock , P_INITIAL_DATA ) ; } if ( ! msock . socket ) { clear_bit ( RESOLVE_CONFLICTS , & connection -> flags ) ; msock . socket = s ; send_first_packet ( connection , & msock , P_INITIAL_META ) ; } else { drbd_err ( connection , "Logic error in conn_connect()\n" ) ; out_release_sockets } } if ( connection_established ( connection , & sock . socket , & msock . socket ) ) { break ; } retry s = drbd_wait_for_connect ( connection , & ad ) ; if ( s ) { int fp = receive_first_packet ( connection , s ) ; drbd_socket_okay ( & sock . socket ) ; drbd_socket_okay ( & msock . socket ) ; switch ( fp ) { case P_INITIAL_DATA : if ( sock . socket ) { drbd_warn ( connection , "initial packet S crossed\n" ) ; sock_release ( sock . socket ) ; sock . socket = s ; randomize } sock . socket = s ; break ; case P_INITIAL_META : set_bit ( RESOLVE_CONFLICTS , & connection -> flags ) ; if ( msock . socket ) { drbd_warn ( connection , "initial packet M crossed\n" ) ; sock_release ( msock . socket ) ; msock . socket = s ; randomize } msock . socket = s ; break ; default : drbd_warn ( connection , "Error receiving initial packet\n" ) ; sock_release ( s ) ; randomize if ( prandom_u32 ( ) & 1 ) { retry } } } if ( connection -> cstate <= C_DISCONNECTING ) { out_release_sockets } if ( signal_pending ( current ) ) { flush_signals ( current ) ; smp_rmb ( ) ; if ( get_t_state ( & connection -> receiver ) == EXITING ) { out_release_sockets } } ok = connection_established ( connection , & sock . socket , & msock . socket ) ; } ! ok ; if ( ad . s_listen ) { sock_release ( ad . s_listen ) ; } sock . socket -> sk -> sk_reuse = SK_CAN_REUSE ; msock . socket -> sk -> sk_reuse = SK_CAN_REUSE ; sock . socket -> sk -> sk_allocation = GFP_NOIO ; msock . socket -> sk -> sk_allocation = GFP_NOIO ; sock . socket -> sk -> sk_priority = TC_PRIO_INTERACTIVE_BULK ; msock . socket -> sk -> sk_priority = TC_PRIO_INTERACTIVE ; rcu_read_lock ( ) ; nc = rcu_dereference ( connection -> net_conf ) ; sock . socket -> sk -> sk_sndtimeo = sock . socket -> sk -> sk_rcvtimeo = nc -> ping_timeo * 4 * HZ / 10 ; msock . socket -> sk -> sk_rcvtimeo = nc -> ping_int * HZ ; timeout = nc -> timeout * HZ / 10 ; discard_my_data = nc -> discard_my_data ; rcu_read_unlock ( ) ; msock . socket -> sk -> sk_sndtimeo = timeout ; drbd_tcp_nodelay ( sock . socket ) ; drbd_tcp_nodelay ( msock . socket ) ; connection -> data . socket = sock . socket ; connection -> meta . socket = msock . socket ; connection -> last_received = jiffies ; h = drbd_do_features ( connection ) ; if ( h <= 0 ) { return h ; } if ( connection -> cram_hmac_tfm ) { switch ( drbd_do_auth ( connection ) ) { case - 1 : drbd_err ( connection , "Authentication of peer failed\n" ) ; return - 1 ; case 0 : drbd_err ( connection , "Authentication of peer failed, trying again.\n" ) ; return 0 ; } } connection -> data . socket -> sk -> sk_sndtimeo = timeout ; connection -> data . socket -> sk -> sk_rcvtimeo = MAX_SCHEDULE_TIMEOUT ; if ( drbd_send_protocol ( connection ) == - EOPNOTSUPP ) { return - 1 ; } idr_for_each_entry ( , , ) mutex_lock ( peer_device -> device -> state_mutex ) ; set_bit ( STATE_SENT , & connection -> flags ) ; idr_for_each_entry ( , , ) mutex_unlock ( peer_device -> device -> state_mutex ) ; rcu_read_lock ( ) ; idr_for_each_entry ( , , ) { struct drbd_device * device = peer_device -> device ; kref_get ( & device -> kref ) ; rcu_read_unlock ( ) ; if ( discard_my_data ) { set_bit ( DISCARD_MY_DATA , & device -> flags ) ; } else { clear_bit ( DISCARD_MY_DATA , & device -> flags ) ; } drbd_connected ( peer_device ) ; kref_put ( & device -> kref , drbd_destroy_device ) ; rcu_read_lock ( ) ; } rcu_read_unlock ( ) ; rv = conn_request_state ( connection , NS ( conn , C_WF_REPORT_PARAMS ) , CS_VERBOSE ) ; if ( rv < SS_SUCCESS || connection -> cstate != C_WF_REPORT_PARAMS ) { clear_bit ( STATE_SENT , & connection -> flags ) ; return 0 ; } drbd_thread_start ( & connection -> ack_receiver ) ; connection -> ack_sender = alloc_ordered_workqueue ( "drbd_as_%s" , WQ_MEM_RECLAIM , connection -> resource -> name ) ; if ( ! connection -> ack_sender ) { drbd_err ( connection , "Failed to create workqueue ack_sender\n" ) ; return 0 ; } mutex_lock ( & connection -> resource -> conf_update ) ; connection -> net_conf -> discard_my_data = 0 ; mutex_unlock ( & connection -> resource -> conf_update ) ; return h ; out_release_sockets if ( ad . s_listen ) { sock_release ( ad . s_listen ) ; } if ( sock . socket ) { sock_release ( sock . socket ) ; } if ( msock . socket ) { sock_release ( msock . socket ) ; } return - 1 ; } 