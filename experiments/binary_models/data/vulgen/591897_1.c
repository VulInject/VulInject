static int __init early_init_dt_scan_cpus ( unsigned long node , const char * uname , int depth , void * data ) { const char * type = of_get_flat_dt_prop ( node , "device_type" , NULL ) ; const __be32 * prop ; const __be32 * intserv ; int i , nthreads ; int len ; int found = - 1 ; int found_thread = 0 ; intserv = of_get_flat_dt_prop ( node , "ibm,ppc-interrupt-server#s" , & len ) ; if ( ! intserv ) { intserv = of_get_flat_dt_prop ( node , "reg" , & len ) ; } nthreads = len / sizeof ( int ) ; for ( i = 0 ; i < nthreads ; i ++ ) { if ( fdt_version ( initial_boot_params ) >= 2 ) { if ( be32_to_cpu ( intserv [ i ] ) == fdt_boot_cpuid_phys ( initial_boot_params ) ) { found = boot_cpu_count ; found_thread = i ; } } else { if ( of_get_flat_dt_prop ( node , "linux,boot-cpu" , NULL ) != NULL ) { found = boot_cpu_count ; } } boot_cpu_count ++ ; } if ( found < 0 ) { return 0 ; } DBG ( "boot cpu: logical %d physical %d\n" , found , be32_to_cpu ( intserv [ found_thread ] ) ) ; boot_cpuid = found ; set_hard_smp_processor_id ( found , be32_to_cpu ( intserv [ found_thread ] ) ) ; if ( ! dt_cpu_ftrs_in_use ( ) ) { prop = of_get_flat_dt_prop ( node , "cpu-version" , NULL ) ; if ( prop && ( be32_to_cpup ( prop ) & 0xff000000 ) == 0x0f000000 ) { identify_cpu ( 0 , be32_to_cpup ( prop ) ) ; } check_cpu_feature_properties ( node ) ; check_cpu_pa_features ( node ) ; } identical_pvr_fixup ( node ) ; init_mmu_slb_size ( node ) ; if ( nthreads == 1 ) { cur_cpu_spec -> cpu_features &= ~ CPU_FTR_SMT ; } if ( ! dt_cpu_ftrs_in_use ( ) ) { cur_cpu_spec -> cpu_features |= CPU_FTR_SMT ; } return 0 ; } 