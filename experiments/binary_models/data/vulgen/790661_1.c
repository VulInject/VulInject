static int dp_display_get_next_bridge ( struct msm_dp * dp ) { int rc ; struct dp_display_private * dp_priv ; struct device_node * aux_bus ; struct device * dev ; dp_priv = container_of ( dp , dp_display_private , dp_display ) ; dev = & dp_priv -> pdev -> dev ; aux_bus = of_get_child_by_name ( dev -> of_node , "aux-bus" ) ; if ( aux_bus && dp -> is_edp ) { dp_display_host_init ( dp_priv ) ; dp_display_host_phy_init ( dp_priv ) ; enable_irq ( dp_priv -> irq ) ; rc = of_dp_aux_populate_bus ( dp_priv -> aux , NULL ) ; of_node_put ( aux_bus ) ; if ( rc ) { error } rc = devm_add_action_or_reset ( dp -> drm_dev -> dev , of_dp_aux_depopulate_bus_void , dp_priv -> aux ) ; if ( rc ) { error } } if ( dp -> is_edp ) { DRM_ERROR ( "eDP aux_bus not found\n" ) ; return - ENODEV ; } rc = devm_dp_parser_find_next_bridge ( dp -> drm_dev -> dev , dp_priv -> parser ) ; if ( ! dp -> is_edp && rc == - ENODEV ) { return 0 ; } if ( ! rc ) { dp -> next_bridge = dp_priv -> parser -> next_bridge ; return 0 ; } error if ( dp -> is_edp ) { disable_irq ( dp_priv -> irq ) ; dp_display_host_phy_exit ( dp_priv ) ; dp_display_host_deinit ( dp_priv ) ; } return rc ; } 