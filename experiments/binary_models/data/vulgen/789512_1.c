static void validate_nodata_response ( struct module_env * env , struct val_env * ve , struct query_info * qchase , struct reply_info * chase_reply , struct key_entry_key * kkey ) { int has_valid_nsec = 0 ; uint8_t * ce = NULL ; uint8_t * wc = NULL ; int nsec3s_seen = 0 ; struct ub_packed_rrset_key * s ; size_t i ; for ( i = chase_reply -> an_numrrsets ; i < chase_reply -> an_numrrsets + chase_reply -> ns_numrrsets ; i ++ ) { s = chase_reply -> rrsets [ i ] ; if ( ntohs ( s -> rk . type ) == LDNS_RR_TYPE_NSEC ) { if ( nsec_proves_nodata ( s , qchase , & wc ) ) { has_valid_nsec = 1 ; } if ( val_nsec_proves_name_error ( s , qchase -> qname ) ) { ce = nsec_closest_encloser ( qchase -> qname , s ) ; } if ( val_nsec_proves_insecuredelegation ( s , qchase ) ) { verbose ( VERB_ALGO , "delegation is insecure" ) ; chase_reply -> security = sec_status_insecure ; return ; } } if ( ntohs ( s -> rk . type ) == LDNS_RR_TYPE_NSEC3 ) { nsec3s_seen = 1 ; } } if ( wc && ce ) { if ( query_dname_compare ( wc , ce ) != 0 ) { has_valid_nsec = 0 ; } } if ( ! has_valid_nsec && nsec3s_seen ) { enum sec_status sec = nsec3_prove_nodata ( env , ve , chase_reply -> rrsets + chase_reply -> an_numrrsets , chase_reply -> ns_numrrsets , qchase , kkey ) ; if ( sec == sec_status_insecure ) { verbose ( VERB_ALGO , "NODATA response is insecure" ) ; chase_reply -> security = sec_status_insecure ; return ; } if ( sec == sec_status_secure ) { has_valid_nsec = 1 ; } } if ( ! has_valid_nsec ) { verbose ( VERB_QUERY , "NODATA response failed to prove NODATA " "status with NSEC/NSEC3" ) ; if ( verbosity >= VERB_ALGO ) { log_dns_msg ( "Failed NODATA" , qchase , chase_reply ) ; } chase_reply -> security = sec_status_bogus ; update_reason_bogus ( chase_reply , LDNS_EDE_DNSSEC_BOGUS ) ; return ; } verbose ( VERB_ALGO , "successfully validated NODATA response." ) ; chase_reply -> security = sec_status_secure ; } 