static int do_fdt ( struct cmd_tbl * cmdtp , int flag , int argc , char * const argv [ ] ) { if ( argc < 2 ) { return CMD_RET_USAGE ; } if ( strncmp ( argv [ 1 ] , "ad" , 2 ) == 0 ) { unsigned long addr ; int control = 0 ; int quiet = 0 ; struct fdt_header * blob ; argc -= 2 ; argv += 2 ; while ( argc > 0 && * * argv == '-' ) { char * arg = * argv ; while ( * ++ arg ) { switch ( * arg ) { case 'c' : control = 1 ; break ; case 'q' : quiet = 1 ; break ; default : return CMD_RET_USAGE ; } } argc -- ; argv ++ ; } if ( argc == 0 ) { if ( control ) { blob = ( fdt_header * ) gd -> fdt_blob ; } else { blob = working_fdt ; } printf ( "%s fdt: %08lx\n" , control ?"Control" : "Working" , control ?( ulong ) map_to_sysmem ( blob ) : env_get_hex ( "fdtaddr" , 0 ) ) ; return 0 ; } addr = hextoul ( argv [ 0 ] , NULL ) ; blob = map_sysmem ( addr , 0 ) ; if ( ( quiet && fdt_check_header ( blob ) ) || ( ! quiet && ! fdt_valid ( & blob ) ) ) { return 1 ; } if ( control ) { gd -> fdt_blob = blob ; } else { set_working_fdt_addr ( addr ) ; } if ( argc >= 2 ) { int len ; int err ; len = hextoul ( argv [ 1 ] , NULL ) ; if ( len < fdt_totalsize ( blob ) ) { if ( ! quiet ) { printf ( "New length %d<existing length %d, ignoring\n" , len , fdt_totalsize ( blob ) ) ; } } else { err = fdt_open_into ( blob , blob , len ) ; if ( ! quiet && err != 0 ) { printf ( "libfdt fdt_open_into(): %s\n" , fdt_strerror ( err ) ) ; } } } return CMD_RET_SUCCESS ; } if ( strncmp ( argv [ 1 ] , "mo" , 2 ) == 0 ) { struct fdt_header * newaddr ; int len ; int err ; if ( argc < 4 ) { return CMD_RET_USAGE ; } working_fdt = map_sysmem ( hextoul ( argv [ 2 ] , NULL ) , 0 ) ; if ( ! fdt_valid ( & working_fdt ) ) { return 1 ; } newaddr = map_sysmem ( hextoul ( argv [ 3 ] , NULL ) , 0 ) ; if ( argc <= 4 ) { len = fdt_totalsize ( working_fdt ) ; } else { len = hextoul ( argv [ 4 ] , NULL ) ; if ( len < fdt_totalsize ( working_fdt ) ) { printf ( "New length 0x%X<existing length " "0x%X, aborting.\n" , len , fdt_totalsize ( working_fdt ) ) ; return 1 ; } } err = fdt_open_into ( working_fdt , newaddr , len ) ; if ( err != 0 ) { printf ( "libfdt fdt_open_into(): %s\n" , fdt_strerror ( err ) ) ; return 1 ; } set_working_fdt_addr ( map_to_sysmem ( newaddr ) ) ; return CMD_RET_SUCCESS ; } if ( ! working_fdt ) { puts ( "No FDT memory address configured. Please configure\n" "the FDT address via \"fdt addr<address>\" command.\n" "Aborting!\n" ) ; return CMD_RET_FAILURE ; } if ( strncmp ( argv [ 1 ] , "sys" , 3 ) == 0 ) { int err = ft_system_setup ( working_fdt , gd -> bd ) ; if ( err ) { printf ( "Failed to add system information to FDT: %s\n" , fdt_strerror ( err ) ) ; return CMD_RET_FAILURE ; } return CMD_RET_SUCCESS ; } if ( strncmp ( argv [ 1 ] , "mk" , 2 ) == 0 ) { char * pathp ; char * nodep ; int nodeoffset ; int err ; if ( argc < 4 ) { return CMD_RET_USAGE ; } pathp = argv [ 2 ] ; nodep = argv [ 3 ] ; nodeoffset = fdt_path_offset ( working_fdt , pathp ) ; if ( nodeoffset < 0 ) { printf ( "libfdt fdt_path_offset() returned %s\n" , fdt_strerror ( nodeoffset ) ) ; return 1 ; } err = fdt_add_subnode ( working_fdt , nodeoffset , nodep ) ; if ( err < 0 ) { printf ( "libfdt fdt_add_subnode(): %s\n" , fdt_strerror ( err ) ) ; return 1 ; } } if ( strncmp ( argv [ 1 ] , "se" , 2 ) == 0 ) { char * pathp ; char * prop ; int nodeoffset ; static char data [ SCRATCHPAD ] __aligned ( 4 ) ; const void * ptmp ; int len ; int ret ; if ( argc < 4 ) { return CMD_RET_USAGE ; } pathp = argv [ 2 ] ; prop = argv [ 3 ] ; nodeoffset = fdt_path_offset ( working_fdt , pathp ) ; if ( nodeoffset < 0 ) { printf ( "libfdt fdt_path_offset() returned %s\n" , fdt_strerror ( nodeoffset ) ) ; return 1 ; } if ( argc == 4 ) { len = 0 ; } else { ptmp = fdt_getprop ( working_fdt , nodeoffset , prop , & len ) ; if ( len > SCRATCHPAD ) { printf ( "prop (%d) doesn't fit in scratchpad!\n" , len ) ; return 1 ; } if ( ptmp != NULL ) { memcpy ( data , ptmp , len ) ; } ret = fdt_parse_prop ( & argv [ 4 ] , argc - 4 , data , & len ) ; if ( ret != 0 ) { return ret ; } } ret = fdt_setprop ( working_fdt , nodeoffset , prop , data , len ) ; if ( ret < 0 ) { printf ( "libfdt fdt_setprop(): %s\n" , fdt_strerror ( ret ) ) ; return 1 ; } } if ( argv [ 1 ] [ 0 ] == 'g' ) { char * subcmd ; char * pathp ; char * prop ; char * var ; int nodeoffset ; const void * nodep ; int len = 0 ; if ( argc < 5 ) { return CMD_RET_USAGE ; } subcmd = argv [ 2 ] ; if ( argc < 6 && subcmd [ 0 ] != 's' ) { return CMD_RET_USAGE ; } var = argv [ 3 ] ; pathp = argv [ 4 ] ; prop = argv [ 5 ] ; nodeoffset = fdt_path_offset ( working_fdt , pathp ) ; if ( nodeoffset < 0 ) { printf ( "libfdt fdt_path_offset() returned %s\n" , fdt_strerror ( nodeoffset ) ) ; return 1 ; } if ( subcmd [ 0 ] == 'n' || ( subcmd [ 0 ] == 's' && argc == 5 ) ) { int req_index = - 1 ; int startDepth = fdt_node_depth ( working_fdt , nodeoffset ) ; int curDepth = startDepth ; int cur_index = - 1 ; int nextNodeOffset = fdt_next_node ( working_fdt , nodeoffset , & curDepth ) ; if ( subcmd [ 0 ] == 'n' ) { req_index = hextoul ( argv [ 5 ] , NULL ) ; } while ( curDepth > startDepth ) { if ( curDepth == startDepth + 1 ) { cur_index ++ ; } if ( subcmd [ 0 ] == 'n' && cur_index == req_index ) { const char * node_name ; node_name = fdt_get_name ( working_fdt , nextNodeOffset , NULL ) ; env_set ( var , node_name ) ; return 0 ; } nextNodeOffset = fdt_next_node ( working_fdt , nextNodeOffset , & curDepth ) ; if ( nextNodeOffset < 0 ) { break ; } } if ( subcmd [ 0 ] == 's' ) { env_set_ulong ( var , cur_index + 1 ) ; } else { printf ( "libfdt node not found\n" ) ; return 1 ; } } else { nodep = fdt_getprop ( working_fdt , nodeoffset , prop , & len ) ; if ( len == 0 ) { env_set ( var , "" ) ; return 0 ; } if ( nodep && len > 0 ) { if ( subcmd [ 0 ] == 'v' ) { int index = 0 ; int ret ; if ( argc == 7 ) { index = simple_strtoul ( argv [ 6 ] , NULL , 10 ) ; } ret = fdt_value_env_set ( nodep , len , var , index ) ; if ( ret != 0 ) { return ret ; } } if ( subcmd [ 0 ] == 'a' ) { char buf [ 11 ] ; sprintf ( buf , "0x%p" , nodep ) ; env_set ( var , buf ) ; } if ( subcmd [ 0 ] == 's' ) { char buf [ 11 ] ; sprintf ( buf , "0x%08X" , len ) ; env_set ( var , buf ) ; } else { return CMD_RET_USAGE ; } return 0 ; } else { printf ( "libfdt fdt_getprop(): %s\n" , fdt_strerror ( len ) ) ; return 1 ; } } } if ( ( argv [ 1 ] [ 0 ] == 'p' ) || ( argv [ 1 ] [ 0 ] == 'l' ) ) { int depth = MAX_LEVEL ; char * pathp ; char * prop ; int ret ; static char root [ 2 ] "/" ; ; if ( argv [ 1 ] [ 0 ] == 'l' ) { depth = 1 ; } if ( argc == 2 ) { pathp = root ; } else { pathp = argv [ 2 ] ; } if ( argc > 3 ) { prop = argv [ 3 ] ; } else { prop = NULL ; } ret = fdt_print ( pathp , prop , depth ) ; if ( ret != 0 ) { return ret ; } } if ( strncmp ( argv [ 1 ] , "rm" , 2 ) == 0 ) { int nodeoffset ; int err ; nodeoffset = fdt_path_offset ( working_fdt , argv [ 2 ] ) ; if ( nodeoffset < 0 ) { printf ( "libfdt fdt_path_offset() returned %s\n" , fdt_strerror ( nodeoffset ) ) ; return 1 ; } if ( argc > 3 ) { err = fdt_delprop ( working_fdt , nodeoffset , argv [ 3 ] ) ; if ( err < 0 ) { printf ( "libfdt fdt_delprop():  %s\n" , fdt_strerror ( err ) ) ; return err ; } } else { err = fdt_del_node ( working_fdt , nodeoffset ) ; if ( err < 0 ) { printf ( "libfdt fdt_del_node():  %s\n" , fdt_strerror ( err ) ) ; return err ; } } } if ( argv [ 1 ] [ 0 ] == 'h' ) { if ( argc == 5 ) { return fdt_get_header_value ( argc , argv ) ; } u32 version = fdt_version ( working_fdt ) ; printf ( "magic:\t\t\t0x%x\n" , fdt_magic ( working_fdt ) ) ; printf ( "totalsize:\t\t0x%x (%d)\n" , fdt_totalsize ( working_fdt ) , fdt_totalsize ( working_fdt ) ) ; printf ( "off_dt_struct:\t\t0x%x\n" , fdt_off_dt_struct ( working_fdt ) ) ; printf ( "off_dt_strings:\t\t0x%x\n" , fdt_off_dt_strings ( working_fdt ) ) ; printf ( "off_mem_rsvmap:\t\t0x%x\n" , fdt_off_mem_rsvmap ( working_fdt ) ) ; printf ( "version:\t\t%d\n" , version ) ; printf ( "last_comp_version:\t%d\n" , fdt_last_comp_version ( working_fdt ) ) ; if ( version >= 2 ) { printf ( "boot_cpuid_phys:\t0x%x\n" , fdt_boot_cpuid_phys ( working_fdt ) ) ; } if ( version >= 3 ) { printf ( "size_dt_strings:\t0x%x\n" , fdt_size_dt_strings ( working_fdt ) ) ; } if ( version >= 17 ) { printf ( "size_dt_struct:\t\t0x%x\n" , fdt_size_dt_struct ( working_fdt ) ) ; } printf ( "number mem_rsv:\t\t0x%x\n" , fdt_num_mem_rsv ( working_fdt ) ) ; printf ( "\n" ) ; } if ( strncmp ( argv [ 1 ] , "boo" , 3 ) == 0 ) { unsigned long tmp = hextoul ( argv [ 2 ] , NULL ) ; fdt_set_boot_cpuid_phys ( working_fdt , tmp ) ; } if ( strncmp ( argv [ 1 ] , "me" , 2 ) == 0 ) { uint64_t addr , size ; int err ; addr = simple_strtoull ( argv [ 2 ] , NULL , 16 ) ; size = simple_strtoull ( argv [ 3 ] , NULL , 16 ) ; err = fdt_fixup_memory ( working_fdt , addr , size ) ; if ( err < 0 ) { return err ; } } if ( strncmp ( argv [ 1 ] , "rs" , 2 ) == 0 ) { if ( argv [ 2 ] [ 0 ] == 'p' ) { uint64_t addr , size ; int total = fdt_num_mem_rsv ( working_fdt ) ; int j , err ; printf ( "index\t\t   start\t\t    size\n" ) ; printf ( "-------------------------------" "-----------------\n" ) ; for ( j = 0 ; j < total ; j ++ ) { err = fdt_get_mem_rsv ( working_fdt , j , & addr , & size ) ; if ( err < 0 ) { printf ( "libfdt fdt_get_mem_rsv():  %s\n" , fdt_strerror ( err ) ) ; return err ; } printf ( "    %x\t%08x%08x\t%08x%08x\n" , j , ( u32 ) ( addr >> 32 ) , ( u32 ) ( addr & 0xffffffff ) , ( u32 ) ( size >> 32 ) , ( u32 ) ( size & 0xffffffff ) ) ; } } if ( argv [ 2 ] [ 0 ] == 'a' ) { uint64_t addr , size ; int err ; addr = simple_strtoull ( argv [ 3 ] , NULL , 16 ) ; size = simple_strtoull ( argv [ 4 ] , NULL , 16 ) ; err = fdt_add_mem_rsv ( working_fdt , addr , size ) ; if ( err < 0 ) { printf ( "libfdt fdt_add_mem_rsv():  %s\n" , fdt_strerror ( err ) ) ; return err ; } } if ( argv [ 2 ] [ 0 ] == 'd' ) { unsigned long idx = hextoul ( argv [ 3 ] , NULL ) ; int err = fdt_del_mem_rsv ( working_fdt , idx ) ; if ( err < 0 ) { printf ( "libfdt fdt_del_mem_rsv():  %s\n" , fdt_strerror ( err ) ) ; return err ; } } else { return CMD_RET_USAGE ; } } if ( strncmp ( argv [ 1 ] , "boa" , 3 ) == 0 ) { int err = ft_board_setup ( working_fdt , gd -> bd ) ; if ( err ) { printf ( "Failed to update board information in FDT: %s\n" , fdt_strerror ( err ) ) ; return CMD_RET_FAILURE ; } ft_board_setup_ex ( working_fdt , gd -> bd ) ; } if ( strncmp ( argv [ 1 ] , "cho" , 3 ) == 0 ) { unsigned long initrd_start = 0 , initrd_end = 0 ; if ( ( argc != 2 ) && ( argc != 4 ) ) { return CMD_RET_USAGE ; } if ( argc == 4 ) { initrd_start = hextoul ( argv [ 2 ] , NULL ) ; initrd_end = initrd_start + hextoul ( argv [ 3 ] , NULL ) - 1 ; } fdt_chosen ( working_fdt ) ; fdt_initrd ( working_fdt , initrd_start , initrd_end ) ; } if ( strncmp ( argv [ 1 ] , "che" , 3 ) == 0 ) { int cfg_noffset ; int ret ; unsigned long addr ; struct fdt_header * blob ; if ( ! working_fdt ) { return CMD_RET_FAILURE ; } if ( argc > 2 ) { addr = hextoul ( argv [ 2 ] , NULL ) ; blob = map_sysmem ( addr , 0 ) ; } else { blob = ( fdt_header * ) gd -> fdt_blob ; } if ( ! fdt_valid ( & blob ) ) { return 1 ; } gd -> fdt_blob = blob ; cfg_noffset = fit_conf_get_node ( working_fdt , NULL ) ; if ( ! cfg_noffset ) { printf ( "Could not find configuration node: %s\n" , fdt_strerror ( cfg_noffset ) ) ; return CMD_RET_FAILURE ; } ret = fit_config_verify ( working_fdt , cfg_noffset ) ; if ( ret == 0 ) { return CMD_RET_SUCCESS ; } else { return CMD_RET_FAILURE ; } } if ( strncmp ( argv [ 1 ] , "ap" , 2 ) == 0 ) { unsigned long addr ; struct fdt_header * blob ; int ret ; if ( argc != 3 ) { return CMD_RET_USAGE ; } if ( ! working_fdt ) { return CMD_RET_FAILURE ; } addr = hextoul ( argv [ 2 ] , NULL ) ; blob = map_sysmem ( addr , 0 ) ; if ( ! fdt_valid ( & blob ) ) { return CMD_RET_FAILURE ; } ret = fdt_overlay_apply_verbose ( working_fdt , blob ) ; if ( ret ) { return CMD_RET_FAILURE ; } } if ( strncmp ( argv [ 1 ] , "re" , 2 ) == 0 ) { uint extrasize ; if ( argc > 2 ) { extrasize = hextoul ( argv [ 2 ] , NULL ) ; } else { extrasize = 0 ; } fdt_shrink_to_minimum ( working_fdt , extrasize ) ; } else { return CMD_RET_USAGE ; } return 0 ; } 