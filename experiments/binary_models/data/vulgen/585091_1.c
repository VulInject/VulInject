v850_elf_relax_delete_bytes ( , , , , ) bfd * abfd ; asection * sec ; bfd_vma addr ; bfd_vma toaddr ; int count ; { Elf_Internal_Shdr * symtab_hdr ; Elf32_External_Sym * extsyms ; Elf32_External_Sym * esym ; Elf32_External_Sym * esymend ; int index ; unsigned int sec_shndx ; bfd_byte * contents ; Elf_Internal_Rela * irel ; Elf_Internal_Rela * irelend ; struct elf_link_hash_entry * sym_hash ; Elf_Internal_Shdr * shndx_hdr ; Elf_External_Sym_Shndx * shndx ; symtab_hdr = & elf_tdata ( abfd ) -> symtab_hdr ; extsyms = ( Elf32_External_Sym * ) symtab_hdr -> contents ; sec_shndx = _bfd_elf_section_from_bfd_section ( abfd , sec ) ; contents = elf_section_data ( sec ) -> this_hdr . contents ; fprintf ( stderr , "relax_delete: contents: sec: %s  %p .. %p %x\n" , sec -> name , addr , toaddr , count ) ; memmove ( contents + addr , contents + addr + count , toaddr - addr - count ) ; memset ( contents + toaddr - count , 0 , count ) ; irel = elf_section_data ( sec ) -> relocs ; irelend = irel + sec -> reloc_count ; shndx_hdr = & elf_tdata ( abfd ) -> symtab_shndx_hdr ; shndx = ( Elf_External_Sym_Shndx * ) shndx_hdr -> contents ; for ( ; irel < irelend ; irel ++ ) { bfd_vma raddr , paddr , symval ; Elf_Internal_Sym isym ; raddr = irel -> r_offset ; if ( ( raddr >= ( addr + count ) && raddr < toaddr ) ) { irel -> r_offset -= count ; } if ( raddr >= addr && raddr < addr + count ) { irel -> r_info = ELF32_R_INFO ( ELF32_R_SYM ( irel -> r_info ) , ( int ) R_V850_NONE ) ; continue ; } if ( ELF32_R_TYPE ( irel -> r_info ) == ( int ) R_V850_ALIGN ) { continue ; } bfd_elf32_swap_symbol_in ( abfd , extsyms + ELF32_R_SYM ( irel -> r_info ) , shndx ?shndx + ELF32_R_SYM ( irel -> r_info ) : NULL , & isym ) ; if ( ELF32_R_SYM ( irel -> r_info ) < symtab_hdr -> sh_info ) { symval = isym . st_value ; { char * name = bfd_elf_string_from_elf_section ( abfd , symtab_hdr -> sh_link , isym . st_name ) ; fprintf ( stderr , "relax_delete: local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n" , sec -> name , name , isym . st_name , sec -> output_section -> vma , sec -> output_offset , isym . st_value , irel -> r_addend ) ; } } else { unsigned long indx ; struct elf_link_hash_entry * h ; indx = ELF32_R_SYM ( irel -> r_info ) - symtab_hdr -> sh_info ; h = elf_sym_hashes ( abfd ) [ indx ] ; BFD_ASSERT ( h != NULL ) ; symval = h -> root . u . def . value ; fprintf ( stderr , "relax_delete: defined: sec: %s, name: %s, value: %x + %x + %x addend %x\n" , sec -> name , h -> root . root . string , h -> root . u . def . value , sec -> output_section -> vma , sec -> output_offset , irel -> r_addend ) ; } paddr = symval + irel -> r_addend ; if ( ( symval >= addr + count && symval < toaddr ) && ( paddr < addr + count || paddr >= toaddr ) ) { irel -> r_addend += count ; } if ( ( symval < addr + count || symval >= toaddr ) && ( paddr >= addr + count && paddr < toaddr ) ) { irel -> r_addend -= count ; } } esym = extsyms ; esymend = esym + symtab_hdr -> sh_info ; for ( ; esym < esymend ; esym ++ , shndx = ( shndx ?shndx + 1 : NULL ) ) { Elf_Internal_Sym isym ; bfd_elf32_swap_symbol_in ( abfd , esym , shndx , & isym ) ; if ( isym . st_shndx == sec_shndx && isym . st_value >= addr + count && isym . st_value < toaddr ) { isym . st_value -= count ; if ( isym . st_value + isym . st_size >= toaddr ) { isym . st_size += count ; } bfd_elf32_swap_symbol_out ( abfd , & isym , esym , shndx ) ; } if ( isym . st_shndx == sec_shndx && isym . st_value < addr + count ) { if ( isym . st_value + isym . st_size >= addr + count && isym . st_value + isym . st_size < toaddr ) { isym . st_size -= count ; } if ( isym . st_value >= addr && isym . st_value < addr + count ) { isym . st_value = addr ; } bfd_elf32_swap_symbol_out ( abfd , & isym , esym , shndx ) ; } } esym = extsyms + symtab_hdr -> sh_info ; esymend = extsyms + ( symtab_hdr -> sh_size / sizeof ( Elf32_External_Sym ) ) ; for ( index = 0 ; esym < esymend ; esym ++ , index ++ ) { Elf_Internal_Sym isym ; bfd_elf32_swap_symbol_in ( abfd , esym , shndx , & isym ) ; sym_hash = elf_sym_hashes ( abfd ) [ index ] ; if ( isym . st_shndx == sec_shndx && ( ( sym_hash ) -> root . type == bfd_link_hash_defined || ( sym_hash ) -> root . type == bfd_link_hash_defweak ) && ( sym_hash ) -> root . u . def . section == sec && ( sym_hash ) -> root . u . def . value >= addr + count && ( sym_hash ) -> root . u . def . value < toaddr ) { if ( ( sym_hash ) -> root . u . def . value + isym . st_size >= toaddr ) { isym . st_size += count ; bfd_elf32_swap_symbol_out ( abfd , & isym , esym , shndx ) ; } ( sym_hash ) -> root . u . def . value -= count ; } if ( isym . st_shndx == sec_shndx && ( ( sym_hash ) -> root . type == bfd_link_hash_defined || ( sym_hash ) -> root . type == bfd_link_hash_defweak ) && ( sym_hash ) -> root . u . def . section == sec && ( sym_hash ) -> root . u . def . value < addr + count ) { if ( ( sym_hash ) -> root . u . def . value + isym . st_size >= addr + count && ( sym_hash ) -> root . u . def . value + isym . st_size < toaddr ) { isym . st_size -= count ; } if ( ( sym_hash ) -> root . u . def . value >= addr && ( sym_hash ) -> root . u . def . value < addr + count ) { ( sym_hash ) -> root . u . def . value = addr ; } bfd_elf32_swap_symbol_out ( abfd , & isym , esym , shndx ) ; } if ( shndx ) { ++ shndx ; } } return TRUE ; } 