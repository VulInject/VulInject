_pop_callback ( , , , ) { bson_json_reader_t * reader ; bson_json_reader_bson_t * reader_bson ; ssize_t len ; double d ; const char * obj_text ; BSON_UNUSED ( action ) ; reader = ( bson_json_reader_t * ) json -> data ; reader_bson = & reader -> bson ; switch ( state -> type ) { case JSONSL_T_HKEY : case JSONSL_T_STRING : obj_text = _get_json_text ( json , state , buf , & len ) ; BSON_ASSERT ( obj_text [ 0 ] == '"' ) ; if ( ! _bson_json_unescape ( reader , state , obj_text + 1 , len - 1 ) ) { break ; } if ( state -> type == JSONSL_T_HKEY ) { _bson_json_read_map_key ( reader , reader_bson -> unescaped . buf , reader_bson -> unescaped . len ) ; } else { _bson_json_read_string ( reader , reader_bson -> unescaped . buf , reader_bson -> unescaped . len ) ; } break ; case JSONSL_T_OBJECT : _bson_json_read_end_map ( reader ) ; break ; case JSONSL_T_LIST : _bson_json_read_end_array ( reader ) ; break ; case JSONSL_T_SPECIAL : obj_text = _get_json_text ( json , state , buf , & len ) ; if ( state -> special_flags & JSONSL_SPECIALf_NUMNOINT ) { if ( _bson_json_parse_double ( reader , obj_text , ( size_t ) len , & d ) ) { _bson_json_read_double ( reader , d ) ; } } if ( state -> special_flags & JSONSL_SPECIALf_NUMERIC ) { _bson_json_read_integer ( reader , state -> nelem , state -> special_flags & JSONSL_SPECIALf_SIGNED ?- 1 : 1 ) ; } if ( state -> special_flags & JSONSL_SPECIALf_BOOLEAN ) { _bson_json_read_boolean ( reader , obj_text [ 0 ] == 't' ?1 : 0 ) ; } if ( state -> special_flags & JSONSL_SPECIALf_NULL ) { _bson_json_read_null ( reader ) ; } break ; default : break ; } reader -> json_text_pos = - 1 ; reader -> tok_accumulator . len = 0 ; } 