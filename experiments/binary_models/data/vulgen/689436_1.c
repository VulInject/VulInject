static int apple_wdt_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct apple_wdt * wdt ; struct clk * clk ; u32 wdt_ctrl ; int ret ; wdt = devm_kzalloc ( dev , sizeof ( * wdt ) , GFP_KERNEL ) ; if ( ! wdt ) { return - ENOMEM ; } wdt -> regs = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( wdt -> regs ) ) { return PTR_ERR ( wdt -> regs ) ; } clk = devm_clk_get ( dev , NULL ) ; if ( IS_ERR ( clk ) ) { return PTR_ERR ( clk ) ; } ret = clk_prepare_enable ( clk ) ; if ( ret ) { return ret ; } ret = devm_add_action_or_reset ( dev , apple_wdt_clk_disable_unprepare , clk ) ; if ( ret ) { return ret ; } wdt -> clk_rate = clk_get_rate ( clk ) ; if ( ! wdt -> clk_rate ) { return - EINVAL ; } wdt -> wdd . ops = & apple_wdt_ops ; wdt -> wdd . info = & apple_wdt_info ; wdt -> wdd . max_timeout = U32_MAX / wdt -> clk_rate ; wdt -> wdd . timeout = APPLE_WDT_TIMEOUT_DEFAULT ; wdt_ctrl = readl_relaxed ( wdt -> regs + APPLE_WDT_WD1_CTRL ) ; if ( wdt_ctrl & APPLE_WDT_CTRL_RESET_EN ) { set_bit ( WDOG_HW_RUNNING , & wdt -> wdd . status ) ; } watchdog_init_timeout ( & wdt -> wdd , 0 , dev ) ; apple_wdt_set_timeout ( & wdt -> wdd , wdt -> wdd . timeout ) ; watchdog_set_restart_priority ( & wdt -> wdd , 128 ) ; return devm_watchdog_register_device ( dev , & wdt -> wdd ) ; } 