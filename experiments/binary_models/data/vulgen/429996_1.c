void eib_manage_keepalives ( eib_t * ss ) { eib_ka_vnics_t * elem ; eib_ka_vnics_t * nxt ; clock_t deadline ; int64_t lbolt64 ; int err ; kmutex_t ci_lock ; callb_cpr_t ci ; mutex_init ( & ci_lock , NULL , MUTEX_DRIVER , NULL ) ; CALLB_CPR_INIT ( & ci , & ci_lock , callb_generic_cpr , EIB_EVENTS_HDLR ) ; mutex_enter ( & ss -> ei_ka_vnics_lock ) ; periodic_keepalive deadline = ddi_get_lbolt ( ) + ss -> ei_gw_props -> pp_vnic_ka_ticks ; while ( ( ss -> ei_ka_vnics_event & ( EIB_KA_VNICS_DIE | EIB_KA_VNICS_TIMED_OUT ) ) == 0 ) { mutex_enter ( & ci_lock ) ; CALLB_CPR_SAFE_BEGIN ( & ci ) ; mutex_exit ( & ci_lock ) ; if ( cv_timedwait ( & ss -> ei_ka_vnics_cv , & ss -> ei_ka_vnics_lock , deadline ) == - 1 ) { ss -> ei_ka_vnics_event |= EIB_KA_VNICS_TIMED_OUT ; } mutex_enter ( & ci_lock ) ; CALLB_CPR_SAFE_END ( & ci , & ci_lock ) ; mutex_exit ( & ci_lock ) ; } if ( ss -> ei_ka_vnics_event & EIB_KA_VNICS_DIE ) { for ( elem = ss -> ei_ka_vnics ; elem ; elem = nxt ) { nxt = elem -> ka_next ; } ss -> ei_ka_vnics = NULL ; mutex_exit ( & ss -> ei_ka_vnics_lock ) ; mutex_enter ( & ci_lock ) ; CALLB_CPR_EXIT ( & ci ) ; mutex_destroy ( & ci_lock ) ; return ; } ss -> ei_ka_vnics_event &= ~ EIB_KA_VNICS_TIMED_OUT ; if ( ss -> ei_ka_vnics == NULL ) { periodic_keepalive } mutex_enter ( & ss -> ei_vnic_lock ) ; lbolt64 = ddi_get_lbolt64 ( ) ; if ( ss -> ei_gw_last_heartbeat != 0 ) { if ( ( lbolt64 - ss -> ei_gw_last_heartbeat ) > ss -> ei_gw_props -> pp_gw_ka_ticks ) { EIB_DPRINTF_WARN ( ss -> ei_instance , "eib_manage_keepalives: no keepalives from gateway " "0x%x for hca_guid=0x%llx, port=0x%x, " "last_gw_ka=0x%llx" , ss -> ei_gw_props -> pp_gw_portid , ss -> ei_props -> ep_hca_guid , ss -> ei_props -> ep_port_num , ss -> ei_gw_last_heartbeat ) ; for ( elem = ss -> ei_ka_vnics ; elem ; elem = nxt ) { nxt = elem -> ka_next ; ss -> ei_zombie_vnics |= ( ( uint64_t ) 1 << elem -> ka_vnic -> vn_instance ) ; kmem_free ( elem , sizeof ( eib_ka_vnics_t ) ) ; } ss -> ei_ka_vnics = NULL ; ss -> ei_gw_unreachable = B_TRUE ; mutex_exit ( & ss -> ei_vnic_lock ) ; eib_mac_link_down ( ss , B_FALSE ) ; periodic_keepalive } } mutex_exit ( & ss -> ei_vnic_lock ) ; for ( elem = ss -> ei_ka_vnics ; elem ; elem = elem -> ka_next ) { ( void ) eib_fip_heartbeat ( ss , elem -> ka_vnic , & err ) ; } periodic_keepalive } 