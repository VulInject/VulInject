OpenAndConfHTTPSocket ( ) { int s ; int i = 1 ; struct sockaddr_in6 listenname6 ; struct sockaddr_in listenname4 ; struct sockaddr_in listenname ; socklen_t listenname_len ; s = socket ( ipv6 ?PF_INET6 : PF_INET , PF_INET , SOCK_STREAM , 0 ) ; if ( s < 0 && ipv6 && errno == EAFNOSUPPORT ) { syslog ( LOG_WARNING , "socket(PF_INET6, ...) failed with EAFNOSUPPORT, disabling IPv6" ) ; SETFLAG ( IPV6DISABLEDMASK ) ; ipv6 = 0 ; s = socket ( PF_INET , SOCK_STREAM , 0 ) ; } if ( setsockopt ( s , SOL_SOCKET , SO_REUSEADDR , & i , sizeof ( i ) ) < 0 ) { syslog ( LOG_WARNING , "setsockopt(http, SO_REUSEADDR): %m" ) ; } if ( setsockopt ( s , IPPROTO_IPV6 , IPV6_V6ONLY , & i , sizeof ( i ) ) < 0 ) { syslog ( LOG_WARNING , "setsockopt(http, IPV6_V6ONLY): %m" ) ; } if ( ! set_non_blocking ( s ) ) { syslog ( LOG_WARNING , "set_non_blocking(http): %m" ) ; } if ( ipv6 ) { memset ( & listenname6 , 0 , sizeof ( sockaddr_in6 ) ) ; listenname6 . sin6_family = AF_INET6 ; listenname6 . sin6_port = htons ( * port ) ; listenname6 . sin6_addr = ipv6_bind_addr ; listenname_len = sizeof ( sockaddr_in6 ) ; } else { memset ( & listenname4 , 0 , sizeof ( sockaddr_in ) ) ; listenname4 . sin_family = AF_INET ; listenname4 . sin_port = htons ( * port ) ; listenname4 . sin_addr . s_addr = htonl ( INADDR_ANY ) ; listenname_len = sizeof ( sockaddr_in ) ; } memset ( & listenname , 0 , sizeof ( sockaddr_in ) ) ; listenname . sin_family = AF_INET ; listenname . sin_port = htons ( * port ) ; listenname . sin_addr . s_addr = htonl ( INADDR_ANY ) ; listenname_len = sizeof ( sockaddr_in ) ; if ( lan_addrs . lh_first != NULL && lan_addrs . lh_first -> list . le_next == NULL && lan_addrs . lh_first -> ifname [ 0 ] != '\0' ) { if ( setsockopt ( s , SOL_SOCKET , SO_BINDTODEVICE , lan_addrs . lh_first -> ifname , strlen ( lan_addrs . lh_first -> ifname ) ) < 0 ) { syslog ( LOG_WARNING , "setsockopt(http, SO_BINDTODEVICE, %s): %m" , lan_addrs . lh_first -> ifname ) ; } } if ( bind ( s , ipv6 ?( sockaddr * ) & listenname6 : ( sockaddr * ) & listenname4 , listenname_len ) < 0 ) { if ( bind ( s , ( sockaddr * ) & listenname , listenname_len ) < 0 ) { syslog ( LOG_ERR , "bind(http): %m" ) ; close ( s ) ; return - 1 ; } } if ( listen ( s , 5 ) < 0 ) { syslog ( LOG_ERR , "listen(http): %m" ) ; close ( s ) ; return - 1 ; } if ( * port == 0 ) { if ( ipv6 ) { struct sockaddr_in6 sockinfo ; socklen_t len = sizeof ( sockaddr_in6 ) ; if ( getsockname ( s , ( sockaddr * ) & sockinfo , & len ) < 0 ) { syslog ( LOG_ERR , "getsockname(): %m" ) ; } else { * port = ntohs ( sockinfo . sin6_port ) ; } } else { struct sockaddr_in sockinfo ; socklen_t len = sizeof ( sockaddr_in ) ; if ( getsockname ( s , ( sockaddr * ) & sockinfo , & len ) < 0 ) { syslog ( LOG_ERR , "getsockname(): %m" ) ; } else { * port = ntohs ( sockinfo . sin_port ) ; } } } return s ; } 