static CURLcode file_range ( struct connectdata * conn ) { curl_off_t from , to ; curl_off_t totalsize = - 1 ; char * ptr ; char * ptr2 ; struct Curl_easy * data = conn -> data ; if ( data -> state . use_range && data -> state . range ) { from = curlx_strtoofft ( data -> state . range , & ptr , 0 ) ; while ( * ptr && ( ISSPACE ( * ptr ) || ( * ptr == '-' ) ) ) { ptr ++ ; } to = curlx_strtoofft ( ptr , & ptr2 , 0 ) ; if ( ( - 1 == to ) && ( from >= 0 ) ) { data -> state . resume_from = from ; DEBUGF ( infof ( data , "RANGE %" CURL_FORMAT_CURL_OFF_T " to end of file\n" , from ) ) ; } if ( from < 0 ) { data -> req . maxdownload = - from ; data -> state . resume_from = from ; DEBUGF ( infof ( data , "RANGE the last %" CURL_FORMAT_CURL_OFF_T " bytes\n" , - from ) ) ; } else { totalsize = to - from ; data -> req . maxdownload = totalsize + 1 ; data -> state . resume_from = from ; DEBUGF ( infof ( data , "RANGE from %" CURL_FORMAT_CURL_OFF_T " getting %" CURL_FORMAT_CURL_OFF_T " bytes\n" , from , data -> req . maxdownload ) ) ; } DEBUGF ( infof ( data , "range-download from %" CURL_FORMAT_CURL_OFF_T " to %" CURL_FORMAT_CURL_OFF_T ", totally %" CURL_FORMAT_CURL_OFF_T " bytes\n" , from , to , data -> req . maxdownload ) ) ; } else { data -> req . maxdownload = - 1 ; } return CURLE_OK ; } 