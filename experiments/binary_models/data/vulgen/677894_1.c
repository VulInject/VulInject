int ll_file_open ( struct inode * inode , struct file * file ) { struct ll_inode_info * lli = ll_i2info ( inode ) ; struct lookup_intent * it , oit = { . it_op = IT_OPEN . it_flags = file -> f_flags } ; struct obd_client_handle * * och_p = NULL ; __u64 * och_usecount = NULL ; struct ll_file_data * fd ; int rc = 0 ; CDEBUG ( D_VFSTRACE , "VFS Op:inode=" DFID "(%p), flags %o\n" , PFID ( ll_inode2fid ( inode ) ) , inode , file -> f_flags ) ; it = file -> private_data ; file -> private_data = NULL ; fd = ll_file_data_get ( ) ; if ( ! fd ) { rc = - ENOMEM ; out_openerr } fd -> fd_file = file ; if ( S_ISDIR ( inode -> i_mode ) ) { ll_authorize_statahead ( inode , fd ) ; } if ( is_root_inode ( inode ) ) { LUSTRE_FPRIVATE ( file ) = fd ; return 0 ; } if ( ! it || ! it -> it_disposition ) { if ( ( oit . it_flags + 1 ) & O_ACCMODE ) { oit . it_flags ++ ; } if ( file -> f_flags & O_TRUNC ) { oit . it_flags |= FMODE_WRITE ; } if ( oit . it_flags & ( FMODE_WRITE | FMODE_READ ) ) { oit . it_flags |= MDS_OPEN_OWNEROVERRIDE ; } oit . it_flags &= ~ O_EXCL ; if ( oit . it_flags & O_CREAT ) { oit . it_op |= IT_CREAT ; } it = & oit ; } restart if ( it -> it_flags & FMODE_WRITE ) { och_p = & lli -> lli_mds_write_och ; och_usecount = & lli -> lli_open_fd_write_count ; } if ( it -> it_flags & FMODE_EXEC ) { och_p = & lli -> lli_mds_exec_och ; och_usecount = & lli -> lli_open_fd_exec_count ; } else { och_p = & lli -> lli_mds_read_och ; och_usecount = & lli -> lli_open_fd_read_count ; } mutex_lock ( & lli -> lli_och_mutex ) ; if ( * och_p ) { if ( it_disposition ( it , DISP_OPEN_OPEN ) ) { rc = it_open_error ( DISP_OPEN_OPEN , it ) ; if ( rc ) { mutex_unlock ( & lli -> lli_och_mutex ) ; out_openerr } ll_release_openhandle ( inode , it ) ; } ( * och_usecount ) ++ ; rc = ll_local_open ( file , it , fd , NULL ) ; if ( rc ) { ( * och_usecount ) -- ; mutex_unlock ( & lli -> lli_och_mutex ) ; out_openerr } } else { LASSERT ( * och_usecount == 0 ) ; if ( ! it -> it_disposition ) { mutex_unlock ( & lli -> lli_och_mutex ) ; it -> it_flags |= MDS_OPEN_LOCK | MDS_OPEN_BY_FID ; rc = ll_intent_file_open ( file -> f_path . dentry , NULL , 0 , it ) ; if ( rc ) { out_openerr } restart } * och_p = kzalloc ( sizeof ( obd_client_handle ) , GFP_NOFS ) ; if ( ! * och_p ) { rc = - ENOMEM ; out_och_free } ( * och_usecount ) ++ ; rc = it_open_error ( DISP_OPEN_OPEN , it ) ; if ( rc ) { out_och_free } LASSERTF ( it_disposition ( it , DISP_ENQ_OPEN_REF ) , "inode %p: disposition %x, status %d\n" , inode , it_disposition ( it , ~ 0 ) , it -> it_status ) ; rc = ll_local_open ( file , it , fd , * och_p ) ; if ( rc ) { out_och_free } } mutex_unlock ( & lli -> lli_och_mutex ) ; fd = NULL ; if ( ! S_ISREG ( inode -> i_mode ) ) { out_och_free } cl_lov_delay_create_clear ( & file -> f_flags ) ; out_och_free out_och_free if ( rc ) { if ( och_p && * och_p ) { kfree ( * och_p ) ; * och_p = NULL ; ( * och_usecount ) -- ; } mutex_unlock ( & lli -> lli_och_mutex ) ; out_openerr if ( lli -> lli_opendir_key == fd ) { ll_deauthorize_statahead ( inode , fd ) ; } if ( fd ) { ll_file_data_put ( fd ) ; } } else { ll_stats_ops_tally ( ll_i2sbi ( inode ) , LPROC_LL_OPEN , 1 ) ; } return rc ; } 