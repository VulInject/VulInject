EQN_TOK_DOTDOT , EQN_TOK_FWD , EQN_TOK_BACK , EQN_TOK_DOWN , EQN_TOK_UP , EQN_TOK_FAT , EQN_TOK_ROMAN , EQN_TOK_ITALIC , EQN_TOK_BOLD , EQN_TOK_SIZE , EQN_TOK_SUB , EQN_TOK_SUP , EQN_TOK_SQRT , EQN_TOK_OVER , EQN_TOK_FROM , EQN_TOK_TO , EQN_TOK_BRACE_OPEN , EQN_TOK_BRACE_CLOSE , EQN_TOK_GSIZE , EQN_TOK_GFONT , EQN_TOK_MARK , EQN_TOK_LINEUP , EQN_TOK_LEFT , EQN_TOK_RIGHT , EQN_TOK_PILE , EQN_TOK_LPILE , EQN_TOK_RPILE , EQN_TOK_CPILE , EQN_TOK_MATRIX , EQN_TOK_CCOL , EQN_TOK_LCOL , EQN_TOK_RCOL , EQN_TOK_DELIM , EQN_TOK_DEFINE , EQN_TOK_TDEFINE , EQN_TOK_NDEFINE , EQN_TOK_UNDEF , EQN_TOK_ABOVE , EQN_TOK__MAX , EQN_TOK_FUNC , EQN_TOK_QUOTED , EQN_TOK_SYM , EQN_TOK_EOF ; static const char * eqn_toks [ EQN_TOK__MAX ] { "dyad" "vec" "under" "bar" "tilde" "hat" "dot" "dotdot" "fwd" "back" "down" "up" "fat" "roman" "italic" "bold" "size" "sub" "sup" "sqrt" "over" "from" "to" "{" "}" "gsize" "gfont" "mark" "lineup" "left" "right" "pile" "lpile" "rpile" "cpile" "matrix" "ccol" "lcol" "rcol" "delim" "define" "tdefine" "ndefine" "undef" "above" } ; ; static const char * const eqn_func [ ] { "acos" "acsc" "and" "arc" "asec" "asin" "atan" "cos" "cosh" "coth" "csc" "det" "exp" "for" "if" "lim" "ln" "log" "max" "min" "sec" "sin" "sinh" "tan" "tanh" "Im" "Re" } ; ; eqn_symt { EQNSYM_alpha = 0 , EQNSYM_beta , EQNSYM_chi , EQNSYM_delta , EQNSYM_epsilon , EQNSYM_eta , EQNSYM_gamma , EQNSYM_iota , EQNSYM_kappa , EQNSYM_lambda , EQNSYM_mu , EQNSYM_nu , EQNSYM_omega , EQNSYM_omicron , EQNSYM_phi , EQNSYM_pi , EQNSYM_ps , EQNSYM_rho , EQNSYM_sigma , EQNSYM_tau , EQNSYM_theta , EQNSYM_upsilon , EQNSYM_xi , EQNSYM_zeta , EQNSYM_DELTA , EQNSYM_GAMMA , EQNSYM_LAMBDA , EQNSYM_OMEGA , EQNSYM_PHI , EQNSYM_PI , EQNSYM_PSI , EQNSYM_SIGMA , EQNSYM_THETA , EQNSYM_UPSILON , EQNSYM_XI , EQNSYM_inter , EQNSYM_union , EQNSYM_prod , EQNSYM_int , EQNSYM_sum , EQNSYM_grad , EQNSYM_del , EQNSYM_times , EQNSYM_cdot , EQNSYM_nothing , EQNSYM_approx , EQNSYM_prime , EQNSYM_half , EQNSYM_partial , EQNSYM_inf , EQNSYM_muchgreat , EQNSYM_muchless , EQNSYM_larrow , EQNSYM_rarrow , EQNSYM_pm , EQNSYM_nequal , EQNSYM_equiv , EQNSYM_lessequal , EQNSYM_moreequal , EQNSYM_minus , EQNSYM__MAX } eqnsym { const char * str ; const char * sym ; } static const struct eqnsym eqnsyms [ EQNSYM__MAX ] { { "alpha" "*a" } { "beta" "*b" } { "chi" "*x" } { "delta" "*d" } { "epsilon" "*e" } { "eta" "*y" } { "gamma" "*g" } { "iota" "*i" } { "kappa" "*k" } { "lambda" "*l" } { "mu" "*m" } { "nu" "*n" } { "omega" "*w" } { "omicron" "*o" } { "phi" "*f" } { "pi" "*p" } { "psi" "*q" } { "rho" "*r" } { "sigma" "*s" } { "tau" "*t" } { "theta" "*h" } { "upsilon" "*u" } { "xi" "*c" } { "zeta" "*z" } { "DELTA" "*D" } { "GAMMA" "*G" } { "LAMBDA" "*L" } { "OMEGA" "*W" } { "PHI" "*F" } { "PI" "*P" } { "PSI" "*Q" } { "SIGMA" "*S" } { "THETA" "*H" } { "UPSILON" "*U" } { "XI" "*C" } { "inter" "ca" } { "union" "cu" } { "prod" "product" } { "int" "integral" } { "sum" "sum" } { "grad" "gr" } { "del" "gr" } { "times" "mu" } { "cdot" "pc" } { "nothing" "&" } { "approx" "~~" } { "prime" "fm" } { "half" "12" } { "partial" "pd" } { "inf" "if" } { ">>" ">>" } { "<<" "<<" } { "<-" "<-" } { "->" "->" } { "+-" "+-" } { "!=" "!=" } { "==" "==" } { "<=" "<=" } { ">=" ">=" } { "-" "mi" } } ; ; parse_mode { MODE_QUOTED , MODE_NOSUB , MODE_SUB , MODE_TOK } eqn_def { char * key ; size_t keysz ; char * val ; int valsz ; } 