static void sbr_hf_inverse_filter_mips ( SBRDSPContext * dsp , float ( * alpha0 ) [ 2 ] , float ( * alpha1 ) [ 2 ] , const float X_low [ 32 ] [ 40 ] [ 2 ] , int k0 ) ( int k , float temp0 , temp1 , temp2 , temp3 , temp4 , temp5 , temp6 , temp7 , c , float * phi1 , * alpha_1 , * alpha_0 , res1 , res2 , temp_real , temp_im , c = 1.000001f , ( k = 0 k < k0 k ++ ) { LOCAL_ALIGNED_16 ( float , phi , [ 3 ] , [ 2 ] [ 2 ] ) float dk phi1 = & phi [ 0 ] [ 0 ] [ 0 ] alpha_1 = & alpha1 [ k ] [ 0 ] alpha_0 = & alpha0 [ k ] [ 0 ] dsp -> autocorrelate ( X_low [ k ] , phi ) __asm__ volatile ( "lwc1    %[temp0],  40(%[phi1])                       \n\t" "lwc1    %[temp1],  16(%[phi1])                       \n\t" "lwc1    %[temp2],  24(%[phi1])                       \n\t" "lwc1    %[temp3],  28(%[phi1])                       \n\t" "mul.s   %[dk],     %[temp0],    %[temp1]             \n\t" "lwc1    %[temp4],  0(%[phi1])                        \n\t" "mul.s   %[res2],   %[temp2],    %[temp2]             \n\t" "lwc1    %[temp5],  4(%[phi1])                        \n\t" "madd.s  %[res2],   %[res2],     %[temp3],  %[temp3]\n\t" "lwc1    %[temp6],  8(%[phi1])                        \n\t" "div.s   %[res2],   %[res2],     %[c]                 \n\t" "lwc1    %[temp0],  12(%[phi1])                       \n\t" "sub.s   %[dk],     %[dk],       %[res2]              \n\t" : [ temp0 ] "=&f" ( temp0 ) , [ temp1 ] "=&f" ( temp1 ) , [ temp2 ] "=&f" ( temp2 ) , [ temp3 ] "=&f" ( temp3 ) , [ temp4 ] "=&f" ( temp4 ) , [ temp5 ] "=&f" ( temp5 ) , [ temp6 ] "=&f" ( temp6 ) , [ res2 ] "=&f" ( res2 ) , [ dk ] "=&f" ( dk ) : [ phi1 ] "r" ( phi1 ) , [ c ] "f" ( c ) : "memory" ) if ( ! dk ) { alpha_1 [ 0 ] = 0 alpha_1 [ 1 ] = 0 } ; } else { __asm__ volatile ( "mul.s   %[temp_real], %[temp4],     %[temp2]            \n\t" "nmsub.s %[temp_real], %[temp_real], %[temp5], %[temp3]\n\t" "nmsub.s %[temp_real], %[temp_real], %[temp6], %[temp1]\n\t" "mul.s   %[temp_im],   %[temp4],     %[temp3]            \n\t" "madd.s  %[temp_im],   %[temp_im],   %[temp5], %[temp2]\n\t" "nmsub.s %[temp_im],   %[temp_im],   %[temp0], %[temp1]\n\t" "div.s   %[temp_real], %[temp_real], %[dk]               \n\t" "div.s   %[temp_im],   %[temp_im],   %[dk]               \n\t" "swc1    %[temp_real], 0(%[alpha_1])                     \n\t" "swc1    %[temp_im],   4(%[alpha_1])                     \n\t" : [ temp_real ] "=&f" ( temp_real ) , [ temp_im ] "=&f" ( temp_im ) : [ phi1 ] "r" ( phi1 ) , [ temp0 ] "f" ( temp0 ) , [ temp1 ] "f" ( temp1 ) , [ temp2 ] "f" ( temp2 ) , [ temp3 ] "f" ( temp3 ) , [ temp4 ] "f" ( temp4 ) , [ temp5 ] "f" ( temp5 ) , [ temp6 ] "f" ( temp6 ) , [ alpha_1 ] "r" ( alpha_1 ) , [ dk ] "f" ( dk ) : "memory" ) } ; ) ; if ( ! phi1 [ 4 ] ) { alpha_0 [ 0 ] = 0 ; alpha_0 [ 1 ] = 0 ; } else { volatile } volatile 