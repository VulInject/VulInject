( qcom_nandc_ecc_caps , qcom_nandc_calc_ecc_bytes , NANDC_STEP_SIZE , 4 , 8 ) ; static int qcom_nand_attach_chip ( struct nand_chip * chip ) { struct mtd_info * mtd = nand_to_mtd ( chip ) ; struct qcom_nand_host * host = to_qcom_nand_host ( chip ) ; struct nand_ecc_ctrl * ecc = & chip -> ecc ; struct qcom_nand_controller * nandc = get_qcom_nand_controller ( chip ) ; int cwperpage , bad_block_byte , ret ; bool wide_bus ; int ecc_mode = 1 ; ecc -> size = NANDC_STEP_SIZE ; wide_bus = chip -> options & NAND_BUSWIDTH_16 ?true : false ; cwperpage = mtd -> writesize / NANDC_STEP_SIZE ; if ( ret ) { dev_err ( nandc -> dev , "No valid ECC settings possible\n" ) ; return ret ; } if ( ecc -> strength >= 8 ) { host -> bch_enabled = true ; ecc_mode = 1 ; if ( wide_bus ) { host -> ecc_bytes_hw = 14 ; host -> spare_bytes = 0 ; host -> bbm_size = 2 ; } else { host -> ecc_bytes_hw = 13 ; host -> spare_bytes = 2 ; host -> bbm_size = 1 ; } } else { if ( nandc -> props -> ecc_modes & ECC_BCH_4BIT ) { host -> bch_enabled = true ; ecc_mode = 0 ; if ( wide_bus ) { host -> ecc_bytes_hw = 8 ; host -> spare_bytes = 2 ; host -> bbm_size = 2 ; } else { host -> ecc_bytes_hw = 7 ; host -> spare_bytes = 4 ; host -> bbm_size = 1 ; } } else { host -> ecc_bytes_hw = 10 ; if ( wide_bus ) { host -> spare_bytes = 0 ; host -> bbm_size = 2 ; } else { host -> spare_bytes = 1 ; host -> bbm_size = 1 ; } } } ecc -> bytes = host -> ecc_bytes_hw + host -> spare_bytes + host -> bbm_size ; ecc -> read_page = qcom_nandc_read_page ; ecc -> read_page_raw = qcom_nandc_read_page_raw ; ecc -> read_oob = qcom_nandc_read_oob ; ecc -> write_page = qcom_nandc_write_page ; ecc -> write_page_raw = qcom_nandc_write_page_raw ; ecc -> write_oob = qcom_nandc_write_oob ; ecc -> engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST ; mtd_set_ooblayout ( mtd , & qcom_nand_ooblayout_ops ) ; if ( nandc -> props -> is_bam ) { free_bam_transaction ( nandc ) ; } nandc -> max_cwperpage = max_t ( , , ) ; if ( nandc -> props -> is_bam ) { nandc -> bam_txn = alloc_bam_transaction ( nandc ) ; if ( ! nandc -> bam_txn ) { dev_err ( nandc -> dev , "failed to allocate bam transaction\n" ) ; return - ENOMEM ; } } host -> cw_data = 516 ; host -> cw_size = host -> cw_data + ecc -> bytes ; bad_block_byte = mtd -> writesize - host -> cw_size * ( cwperpage - 1 ) + 1 ; host -> cfg0 = ( cwperpage - 1 ) << CW_PER_PAGE | host -> cw_data << UD_SIZE_BYTES | 0 << DISABLE_STATUS_AFTER_WRITE | 5 << NUM_ADDR_CYCLES | host -> ecc_bytes_hw << ECC_PARITY_SIZE_BYTES_RS | 0 << STATUS_BFR_READ | 1 << SET_RD_MODE_AFTER_STATUS | host -> spare_bytes << SPARE_SIZE_BYTES ; host -> cfg1 = 7 << NAND_RECOVERY_CYCLES | 0 << CS_ACTIVE_BSY | bad_block_byte << BAD_BLOCK_BYTE_NUM | 0 << BAD_BLOCK_IN_SPARE_AREA | 2 << WR_RD_BSY_GAP | wide_bus << WIDE_FLASH | host -> bch_enabled << ENABLE_BCH_ECC ; host -> cfg0_raw = ( cwperpage - 1 ) << CW_PER_PAGE | host -> cw_size << UD_SIZE_BYTES | 5 << NUM_ADDR_CYCLES | 0 << SPARE_SIZE_BYTES ; host -> cfg1_raw = 7 << NAND_RECOVERY_CYCLES | 0 << CS_ACTIVE_BSY | 17 << BAD_BLOCK_BYTE_NUM | 1 << BAD_BLOCK_IN_SPARE_AREA | 2 << WR_RD_BSY_GAP | wide_bus << WIDE_FLASH | 1 << DEV0_CFG1_ECC_DISABLE ; host -> ecc_bch_cfg = ! host -> bch_enabled << ECC_CFG_ECC_DISABLE | 0 << ECC_SW_RESET | host -> cw_data << ECC_NUM_DATA_BYTES | 1 << ECC_FORCE_CLK_OPEN | ecc_mode << ECC_MODE | host -> ecc_bytes_hw << ECC_PARITY_SIZE_BYTES_BCH ; if ( ! nandc -> props -> qpic_v2 ) { host -> ecc_buf_cfg = 0x203 << NUM_STEPS ; } host -> clrflashstatus = FS_READY_BSY_N ; host -> clrreadstatus = 0xc0 ; nandc -> regs -> erased_cw_detect_cfg_clr = cpu_to_le32 ( CLR_ERASED_PAGE_DET ) ; nandc -> regs -> erased_cw_detect_cfg_set = cpu_to_le32 ( SET_ERASED_PAGE_DET ) ; dev_dbg ( nandc -> dev , "cfg0 %x cfg1 %x ecc_buf_cfg %x ecc_bch cfg %x cw_size %d cw_data %d strength %d parity_bytes %d steps %d\n" , host -> cfg0 , host -> cfg1 , host -> ecc_buf_cfg , host -> ecc_bch_cfg , host -> cw_size , host -> cw_data , ecc -> strength , ecc -> bytes , cwperpage ) ; return 0 ; } 