static gboolean infc_browser_handle_lookup_acl_accounts ( InfcBrowser * browser , InfXmlConnection * connection , xmlNodePtr xml , GError * * error ) { InfcBrowserPrivate * priv ; GError * local_error ; InfcRequest * request ; xmlNodePtr child ; GPtrArray * accounts ; InfAclAccount * account ; InfAclAccount * existing_account ; InfAclAccount req_account ; InfcBrowserLookupAclAccountByByNameData lookup_data ; GArray * req_accounts ; guint i ; guint len ; gchar * name ; const InfAclAccountId * ids ; guint n_ids ; priv = INFC_BROWSER_PRIVATE ( browser ) ; local_error = NULL ; request = infc_request_manager_get_request_by_xml ( priv -> request_manager , "lookup-acl-accounts" , xml , error ) ; if ( local_error != NULL ) { g_propagate_error ( error , local_error ) ; return FALSE ; } accounts = g_ptr_array_new ( ) ; for ( child = xml -> children ; child != NULL ; child = child -> next ) { if ( child -> type != XML_ELEMENT_NODE ) { continue ; } if ( strcmp ( ( const gchar * ) child -> name , "account" ) == 0 ) { account = inf_acl_account_from_xml ( child , error ) ; if ( account == NULL ) { for ( i = 0 ; i < accounts -> len ; ++ i ) { inf_acl_account_free ( accounts -> pdata [ i ] ) ; } return FALSE ; } g_ptr_array_add ( accounts , account ) ; } } for ( i = 0 ; i < accounts -> len ; ++ i ) { account = ( InfAclAccount * ) accounts -> pdata [ i ] ; existing_account = g_hash_table_lookup ( priv -> accounts , INF_ACL_ACCOUNT_ID_TO_POINTER ( account -> id ) ) ; if ( existing_account != NULL ) { if ( strcmp ( existing_account -> name , account -> name ) != 0 ) { g_free ( existing_account -> name ) ; existing_account -> name = g_strdup ( account -> name ) ; } inf_acl_account_free ( account ) ; } else { if ( priv -> account_list_status == INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS ) { g_warning ( _ ( "Unknown account ID \"%s\" in server reply of " "\"%s\". Typically, this means the server claimed it notified us " "about new connections as soon as they are available, but it " "did not do so." ) , inf_acl_account_id_to_string ( account -> id ) , "lookup-acl-accounts" ) ; } g_hash_table_insert ( priv -> accounts , INF_ACL_ACCOUNT_ID_TO_POINTER ( account -> id ) , account ) ; inf_browser_acl_account_added ( INF_BROWSER ( browser ) , account , INF_REQUEST ( request ) ) ; } } g_ptr_array_free ( accounts , TRUE ) ; if ( request != NULL ) { ids = g_object_get_qdata ( G_OBJECT ( request ) , infc_browser_lookup_acl_accounts_ids_quark ) ; n_ids = GPOINTER_TO_UINT ( g_object_get_qdata ( G_OBJECT ( request ) , infc_browser_lookup_acl_accounts_n_ids_quark ) ) ; name = g_object_get_qdata ( G_OBJECT ( request ) , infc_browser_lookup_acl_accounts_name_quark ) ; req_accounts = g_array_new ( FALSE , FALSE , sizeof ( InfAclAccount ) ) ; if ( ids != NULL ) { g_assert ( n_ids > 0 ) ; for ( i = 0 ; i < n_ids ; ++ i ) { account = g_hash_table_lookup ( priv -> accounts , INF_ACL_ACCOUNT_ID_TO_POINTER ( ids [ i ] ) ) ; if ( account != NULL ) { g_array_append_val ( req_accounts , * account ) ; } else { req_account . id = ids [ i ] ; req_account . name = NULL ; g_array_append_val ( req_accounts , req_account ) ; } } } if ( name != NULL ) { len = req_accounts -> len ; lookup_data . name = name ; lookup_data . accounts = req_accounts ; g_hash_table_foreach ( priv -> accounts , infc_browser_browser_lookup_acl_account_by_name_find_func , & lookup_data ) ; if ( req_accounts -> len == len ) { req_account . id = 0 ; req_account . name = name ; g_array_append_val ( req_accounts , req_account ) ; } } infc_request_manager_finish_request ( priv -> request_manager , request , inf_request_result_make_lookup_acl_accounts ( INF_BROWSER ( browser ) , ( InfAclAccount * ) req_accounts -> data , req_accounts -> len ) ) ; g_array_free ( req_accounts , TRUE ) ; } return TRUE ; } 