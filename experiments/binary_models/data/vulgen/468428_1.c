static ssize_t fan_div_store ( struct device * dev , struct device_attribute * devattr , const char * buf , size_t count ) { struct sensor_device_attribute * attr = to_sensor_dev_attr ( devattr ) ; struct smsc47m1_data * data = dev_get_drvdata ( dev ) ; int nr = attr -> index ; long new_div ; int err ; long tmp ; u8 old_div = DIV_FROM_REG ( data -> fan_div [ nr ] ) ; err = kstrtol ( buf , 10 , & new_div ) ; if ( err ) { return err ; } if ( new_div == old_div ) { return count ; } mutex_lock ( & data -> update_lock ) ; switch { case 1 : data -> fan_div [ nr ] = 0 ; break ; case 2 : data -> fan_div [ nr ] = 1 ; break ; case 4 : data -> fan_div [ nr ] = 2 ; break ; case 8 : data -> fan_div [ nr ] = 3 ; break ; default : mutex_unlock ( & data -> update_lock ) ; return - EINVAL ; } switch ( nr ) { case 0 : case 1 : tmp = smsc47m1_read_value ( data , SMSC47M1_REG_FANDIV ) & ~ ( 0x03 << ( 4 + 2 * nr ) ) ; tmp |= data -> fan_div [ nr ] << ( 4 + 2 * nr ) ; smsc47m1_write_value ( data , SMSC47M1_REG_FANDIV , tmp ) ; break ; case 2 : tmp = smsc47m1_read_value ( data , SMSC47M2_REG_FANDIV3 ) & 0xCF ; tmp |= data -> fan_div [ 2 ] << 4 ; smsc47m1_write_value ( data , SMSC47M2_REG_FANDIV3 , tmp ) ; break ; default : BUG ( ) ; } tmp = 192 - ( old_div * ( 192 - data -> fan_preload [ nr ] ) + new_div / 2 ) / new_div ; data -> fan_preload [ nr ] = clamp_val ( tmp , 0 , 191 ) ; smsc47m1_write_value ( data , SMSC47M1_REG_FAN_PRELOAD [ nr ] , data -> fan_preload [ nr ] ) ; mutex_unlock ( & data -> update_lock ) ; return count ; } 