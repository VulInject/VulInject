mylog ( "%s: entering...stmt=%u\n" , func , stmt ) ; if ( ! stmt ) { SC_log_error ( func , "" , NULL ) ; return SQL_INVALID_HANDLE ; } stmt -> manual_result = TRUE ; conn = ( ConnectionClass * ) ( stmt -> hdbc ) ; ci = & stmt -> hdbc -> connInfo ; result = PG_SQLAllocStmt ( stmt -> hdbc , & htbl_stmt ) ; if ( ( result != SQL_SUCCESS ) && ( result != SQL_SUCCESS_WITH_INFO ) ) { SC_set_error ( stmt , STMT_NO_MEMORY_ERROR , "Couldn't allocate statement for SQLTables result." ) ; SC_log_error ( func , "" , stmt ) ; return SQL_ERROR ; } tbl_stmt = ( StatementClass * ) htbl_stmt ; if ( PG_VERSION_GE ( conn , 7.1 ) ) { strcpy ( tables_query , "select relname, usename, relkind from pg_class, pg_user" ) ; strcat ( tables_query , " where relkind in ('r', 'v')" ) ; } else { strcpy ( tables_query , "select relname, usename, relhasrules from pg_class, pg_user" ) ; strcat ( tables_query , " where relkind = 'r'" ) ; } my_strcat ( tables_query , " and usename like '%.*s'" , ( char * ) szTableOwner , cbTableOwner ) ; my_strcat ( tables_query , " and relname like '%.*s'" , ( char * ) szTableName , cbTableName ) ; strcpy ( prefixes , globals . extra_systable_prefixes ) ; i = 0 ; prefix [ i ] = strtok ( prefixes , ";" ) ; while ( prefix [ i ] && i < sizeof ( prefix ) - 1 ) { prefix [ ++ i ] = strtok ( NULL , ";" ) ; } show_system_tables = FALSE ; show_regular_tables = FALSE ; show_views = FALSE ; tableType = make_string ( ( char * ) szTableType , cbTableType , NULL ) ; if ( tableType ) { strcpy ( table_types , tableType ) ; free ( tableType ) ; i = 0 ; table_type [ i ] = strtok ( table_types , "," ) ; while ( table_type [ i ] && i < sizeof ( table_type ) - 1 ) { table_type [ ++ i ] = strtok ( NULL , "," ) ; } i = 0 ; while ( table_type [ i ] ) { if ( strstr ( table_type [ i ] , "SYSTEM TABLE" ) ) { show_system_tables = TRUE ; } if ( strstr ( table_type [ i ] , "TABLE" ) ) { show_regular_tables = TRUE ; } if ( strstr ( table_type [ i ] , "VIEW" ) ) { show_views = TRUE ; } i ++ ; } } else { show_regular_tables = TRUE ; show_views = TRUE ; } if ( ! atoi ( ci -> show_system_tables ) && ! show_system_tables ) { strcat ( tables_query , " and relname !~ '^" POSTGRES_SYS_PREFIX ) ; i = 0 ; while ( prefix [ i ] ) { strcat ( tables_query , "|^" ) ; strcat ( tables_query , prefix [ i ] ) ; i ++ ; } strcat ( tables_query , "'" ) ; } if ( PG_VERSION_LT ( conn , 7.1 ) ) { strcat ( tables_query , " and relname !~ '^xinv[0-9]+'" ) ; } strcat ( tables_query , " and usesysid = relowner" ) ; strcat ( tables_query , " order by relname" ) ; result = PG_SQLExecDirect ( htbl_stmt , tables_query , strlen ( tables_query ) ) ; if ( ( result != SQL_SUCCESS ) && ( result != SQL_SUCCESS_WITH_INFO ) ) { SC_set_error ( stmt , SC_get_errornumber ( tbl_stmt ) , SC_create_errormsg ( ( StatementClass * ) htbl_stmt ) ) ; SC_log_error ( func , "" , stmt ) ; PG_SQLFreeStmt ( htbl_stmt , SQL_DROP ) ; return SQL_ERROR ; } result = PG_SQLBindCol ( htbl_stmt , 1 , SQL_C_CHAR , table_name , MAX_INFO_STRING , NULL ) ; if ( ( result != SQL_SUCCESS ) && ( result != SQL_SUCCESS_WITH_INFO ) ) { SC_set_error ( stmt , SC_get_errornumber ( tbl_stmt ) , SC_get_errormsg ( tbl_stmt ) ) ; SC_log_error ( func , "" , stmt ) ; PG_SQLFreeStmt ( htbl_stmt , SQL_DROP ) ; return SQL_ERROR ; } result = PG_SQLBindCol ( htbl_stmt , 2 , SQL_C_CHAR , table_owner , MAX_INFO_STRING , NULL ) ; if ( ( result != SQL_SUCCESS ) && ( result != SQL_SUCCESS_WITH_INFO ) ) { SC_set_error ( stmt , SC_get_errornumber ( tbl_stmt ) , SC_get_errormsg ( tbl_stmt ) ) ; SC_log_error ( func , "" , stmt ) ; PG_SQLFreeStmt ( htbl_stmt , SQL_DROP ) ; return SQL_ERROR ; } result = PG_SQLBindCol ( htbl_stmt , 3 , SQL_C_CHAR , relkind_or_hasrules , MAX_INFO_STRING , NULL ) ; if ( ( result != SQL_SUCCESS ) && ( result != SQL_SUCCESS_WITH_INFO ) ) { SC_set_error ( stmt , SC_get_errornumber ( tbl_stmt ) , SC_get_errormsg ( tbl_stmt ) ) ; SC_log_error ( func , "" , stmt ) ; PG_SQLFreeStmt ( htbl_stmt , SQL_DROP ) ; return SQL_ERROR ; } stmt -> result = QR_Constructor ( ) ; if ( ! stmt -> result ) { SC_set_error ( stmt , STMT_NO_MEMORY_ERROR , "Couldn't allocate memory for SQLTables result." ) ; SC_log_error ( func , "" , stmt ) ; PG_SQLFreeStmt ( htbl_stmt , SQL_DROP ) ; return SQL_ERROR ; } extend_bindings ( stmt , 5 ) ; QR_set_num_fields ( stmt -> result , 5 ) ; QR_set_field_info ( stmt -> result , 0 , "TABLE_QUALIFIER" , PG_TYPE_TEXT , MAX_INFO_STRING ) ; QR_set_field_info ( stmt -> result , 1 , "TABLE_OWNER" , PG_TYPE_TEXT , MAX_INFO_STRING ) ; QR_set_field_info ( stmt -> result , 2 , "TABLE_NAME" , PG_TYPE_TEXT , MAX_INFO_STRING ) ; QR_set_field_info ( stmt -> result , 3 , "TABLE_TYPE" , PG_TYPE_TEXT , MAX_INFO_STRING ) ; QR_set_field_info ( stmt -> result , 4 , "REMARKS" , PG_TYPE_TEXT , 254 ) ; result = PG_SQLFetch ( htbl_stmt ) ; while ( ( result == SQL_SUCCESS ) || ( result == SQL_SUCCESS_WITH_INFO ) ) { systable = FALSE ; if ( ! atoi ( ci -> show_system_tables ) ) { if ( strncmp ( table_name , POSTGRES_SYS_PREFIX , strlen ( POSTGRES_SYS_PREFIX ) ) == 0 ) { systable = TRUE ; } else { i = 0 ; while ( prefix [ i ] ) { mylog ( "table_name='%s', prefix[%d]='%s'\n" , table_name , i , prefix [ i ] ) ; if ( strncmp ( table_name , prefix [ i ] , strlen ( prefix [ i ] ) ) == 0 ) { systable = TRUE ; break ; } i ++ ; } } } if ( PG_VERSION_GE ( conn , 7.1 ) ) { view = ( relkind_or_hasrules [ 0 ] == 'v' ) ; } else { view = ( relkind_or_hasrules [ 0 ] == '1' ) ; } regular_table = ( ! systable && ! view ) ; if ( ( systable && show_system_tables ) || ( view && show_views ) || ( regular_table && show_regular_tables ) ) { row = ( TupleNode * ) malloc ( sizeof ( TupleNode ) + ( 5 - 1 ) * sizeof ( TupleField ) ) ; set_tuplefield_string ( & row -> tuple [ 0 ] , "" ) ; mylog ( "SQLTables: table_name = '%s'\n" , table_name ) ; set_tuplefield_string ( & row -> tuple [ 1 ] , "" ) ; set_tuplefield_string ( & row -> tuple [ 2 ] , table_name ) ; set_tuplefield_string ( & row -> tuple [ 3 ] , systable ?"SYSTEM TABLE" : ( view ?"VIEW" : "TABLE" ) ) ; set_tuplefield_string ( & row -> tuple [ 4 ] , "" ) ; QR_add_tuple ( stmt -> result , row ) ; } result = PG_SQLFetch ( htbl_stmt ) ; } if ( result != SQL_NO_DATA_FOUND ) { SC_set_error ( stmt , SC_get_errornumber ( tbl_stmt ) , SC_create_errormsg ( ( StatementClass * ) htbl_stmt ) ) ; SC_log_error ( func , "" , stmt ) ; PG_SQLFreeStmt ( htbl_stmt , SQL_DROP ) ; return SQL_ERROR ; } stmt -> status = STMT_FINISHED ; stmt -> currTuple = - 1 ; stmt -> rowset_start = - 1 ; stmt -> current_col = - 1 ; PG_SQLFreeStmt ( htbl_stmt , SQL_DROP ) ; mylog ( "SQLTables(): EXIT,  stmt=%u\n" , stmt ) ; return SQL_SUCCESS ; 