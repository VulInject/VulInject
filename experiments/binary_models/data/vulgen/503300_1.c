struct config_generic * * get_explain_guc_options ( int * num ) { struct config_generic * * result ; dlist_iter iter ; * num = 0 ; result = palloc ( sizeof ( config_generic * ) * hash_get_num_entries ( guc_hashtab ) ) ; dlist_foreach ( , ) { struct config_generic * conf = dlist_container ( config_generic , nondef_link , iter . cur ) ; bool modified ; if ( ! ConfigOptionIsVisible ( conf ) ) { continue ; } modified = false ; switch ( conf -> vartype ) { case PGC_BOOL : { struct config_bool * lconf = ( config_bool * ) conf ; modified = ( lconf -> boot_val != * ( lconf -> variable ) ) ; } break ; case PGC_INT : { struct config_int * lconf = ( config_int * ) conf ; modified = ( lconf -> boot_val != * ( lconf -> variable ) ) ; } break ; case PGC_REAL : { struct config_real * lconf = ( config_real * ) conf ; modified = ( lconf -> boot_val != * ( lconf -> variable ) ) ; } break ; case PGC_STRING : { struct config_string * lconf = ( config_string * ) conf ; modified = ( strcmp ( lconf -> boot_val , * ( lconf -> variable ) ) != 0 ) ; } break ; case PGC_ENUM : { struct config_enum * lconf = ( config_enum * ) conf ; modified = ( lconf -> boot_val != * ( lconf -> variable ) ) ; } break ; default : elog ( ERROR , "unexpected GUC type: %d" , conf -> vartype ) ; } if ( ! modified ) { continue ; } result [ * num ] = conf ; * num = * num + 1 ; } return result ; } 