static void regmap_irq_sync_unlock ( struct irq_data * data ) { struct regmap_irq_chip_data * d = irq_data_get_irq_chip_data ( data ) ; struct regmap * map = d -> map ; int i , j , ret ; u32 reg ; u32 val ; if ( d -> chip -> runtime_pm ) { if ( ret < 0 ) { dev_err ( map -> dev , "IRQ sync failed to resume: %d\n" , ret ) ; } } if ( d -> clear_status ) { for ( i = 0 ; i < d -> chip -> num_regs ; i ++ ) { reg = d -> get_irq_reg ( d , d -> chip -> status_base , i ) ; ret = regmap_read ( map , reg , & val ) ; if ( ret ) { dev_err ( d -> map -> dev , "Failed to clear the interrupt status bits\n" ) ; } } d -> clear_status = false ; } for ( i = 0 ; i < d -> chip -> num_regs ; i ++ ) { if ( d -> mask_base ) { if ( d -> chip -> handle_mask_sync ) { d -> chip -> handle_mask_sync ( d -> map , i , d -> mask_buf_def [ i ] , d -> mask_buf [ i ] , d -> chip -> irq_drv_data ) ; } else { reg = d -> get_irq_reg ( d , d -> mask_base , i ) ; ret = regmap_update_bits ( d -> map , reg , d -> mask_buf_def [ i ] , d -> mask_buf [ i ] ) ; if ( ret ) { dev_err ( d -> map -> dev , "Failed to sync masks in %x\n" , reg ) ; } } } if ( d -> unmask_base ) { reg = d -> get_irq_reg ( d , d -> unmask_base , i ) ; ret = regmap_update_bits ( d -> map , reg , d -> mask_buf_def [ i ] , ~ d -> mask_buf [ i ] ) ; if ( ret ) { dev_err ( d -> map -> dev , "Failed to sync masks in %x\n" , reg ) ; } } reg = d -> get_irq_reg ( d , d -> chip -> wake_base , i ) ; if ( d -> wake_buf ) { if ( d -> chip -> wake_invert ) { ret = regmap_update_bits ( d -> map , reg , d -> mask_buf_def [ i ] , ~ d -> wake_buf [ i ] ) ; } else { ret = regmap_update_bits ( d -> map , reg , d -> mask_buf_def [ i ] , d -> wake_buf [ i ] ) ; } if ( ret != 0 ) { dev_err ( d -> map -> dev , "Failed to sync wakes in %x: %d\n" , reg , ret ) ; } } if ( ! d -> chip -> init_ack_masked ) { continue ; } if ( d -> mask_buf [ i ] && ( d -> chip -> ack_base || d -> chip -> use_ack ) ) { reg = d -> get_irq_reg ( d , d -> chip -> ack_base , i ) ; if ( d -> chip -> ack_invert ) { ret = regmap_write ( map , reg , ~ d -> mask_buf [ i ] ) ; } else { ret = regmap_write ( map , reg , d -> mask_buf [ i ] ) ; } if ( d -> chip -> clear_ack ) { if ( d -> chip -> ack_invert && ! ret ) { ret = regmap_write ( map , reg , UINT_MAX ) ; } if ( ! ret ) { ret = regmap_write ( map , reg , 0 ) ; } } if ( ret != 0 ) { dev_err ( d -> map -> dev , "Failed to ack 0x%x: %d\n" , reg , ret ) ; } } } if ( ! d -> chip -> type_in_mask ) { for ( i = 0 ; i < d -> chip -> num_type_reg ; i ++ ) { if ( ! d -> type_buf_def [ i ] ) { continue ; } reg = d -> get_irq_reg ( d , d -> chip -> type_base , i ) ; ret = regmap_update_bits ( d -> map , reg , d -> type_buf_def [ i ] , d -> type_buf [ i ] ) ; if ( ret != 0 ) { dev_err ( d -> map -> dev , "Failed to sync type in %x\n" , reg ) ; } } } if ( d -> chip -> num_virt_regs ) { for ( i = 0 ; i < d -> chip -> num_virt_regs ; i ++ ) { for ( j = 0 ; j < d -> chip -> num_regs ; j ++ ) { reg = d -> get_irq_reg ( d , d -> chip -> virt_reg_base [ i ] , j ) ; ret = regmap_write ( map , reg , d -> virt_buf [ i ] [ j ] ) ; if ( ret != 0 ) { dev_err ( d -> map -> dev , "Failed to write virt 0x%x: %d\n" , reg , ret ) ; } } } } for ( i = 0 ; i < d -> chip -> num_config_bases ; i ++ ) { for ( j = 0 ; j < d -> chip -> num_config_regs ; j ++ ) { reg = d -> get_irq_reg ( d , d -> chip -> config_base [ i ] , j ) ; ret = regmap_write ( map , reg , d -> config_buf [ i ] [ j ] ) ; if ( ret ) { dev_err ( d -> map -> dev , "Failed to write config %x: %d\n" , reg , ret ) ; } } } if ( d -> chip -> runtime_pm ) { pm_runtime_put ( map -> dev ) ; } if ( d -> wake_count < 0 ) { for ( i = d -> wake_count ; i < 0 ; i ++ ) { irq_set_irq_wake ( d -> irq , 0 ) ; } } if ( d -> wake_count > 0 ) { for ( i = 0 ; i < d -> wake_count ; i ++ ) { irq_set_irq_wake ( d -> irq , 1 ) ; } } d -> wake_count = 0 ; mutex_unlock ( & d -> lock ) ; } 