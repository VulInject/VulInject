static void messages_deliver_to_app ( struct totemsrp_instance * instance , int skip , unsigned int end_point ) { struct sort_queue_item * sort_queue_item_p ; unsigned int i ; int res ; struct mcast * mcast_in ; struct mcast mcast_header ; unsigned int range = 0 ; int endian_conversion_required ; unsigned int my_high_delivered_stored = 0 ; struct srp_addr aligned_system_from ; range = end_point - instance -> my_high_delivered ; if ( range ) { log_printf ( instance -> totemsrp_log_level_trace , "Delivering %x to %x" , instance -> my_high_delivered , end_point ) ; } assert ( range < QUEUE_RTR_ITEMS_SIZE_MAX ) ; my_high_delivered_stored = instance -> my_high_delivered ; for ( i = 1 ; i <= range ; i ++ ) { void * ptr = 0 ; res = sq_in_range ( & instance -> regular_sort_queue , my_high_delivered_stored + i ) ; if ( res == 0 ) { break ; } res = sq_item_get ( & instance -> regular_sort_queue , my_high_delivered_stored + i , & ptr ) ; if ( res != 0 && skip == 0 ) { break ; } instance -> my_high_delivered = my_high_delivered_stored + i ; sort_queue_item_p = ptr ; mcast_in = sort_queue_item_p -> mcast ; assert ( mcast_in != ( mcast * ) 0xdeadbeef ) ; endian_conversion_required = 0 ; if ( mcast_in -> header . magic != TOTEM_MH_MAGIC ) { endian_conversion_required = 1 ; mcast_endian_convert ( mcast_in , & mcast_header ) ; } else { memcpy ( & mcast_header , mcast_in , sizeof ( mcast ) ) ; } aligned_system_from = mcast_header . system_from ; if ( skip && memb_set_subset ( & aligned_system_from , 1 , instance -> my_deliver_memb_list , instance -> my_deliver_memb_entries ) == 0 ) { instance -> my_high_delivered = my_high_delivered_stored + i ; continue ; } log_printf ( instance -> totemsrp_log_level_trace , "Delivering MCAST message with seq %x to pending delivery queue" , mcast_header . seq ) ; instance -> totemsrp_deliver_fn ( mcast_header . header . nodeid , ( ( char * ) sort_queue_item_p -> mcast ) + sizeof ( mcast ) , sort_queue_item_p -> msg_len - sizeof ( mcast ) , endian_conversion_required ) ; } } 