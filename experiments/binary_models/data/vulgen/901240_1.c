static Boolean map_equal ( Mapfile * mf , Sg_desc * sgp ) { { const char * name ; Word p_type ; sg_flags_t sg_flags ; } seg_types_t static seg_types_t seg_type_arr [ ] { { MSG_ORIG ( MSG_MAP_LOAD ) PT_LOAD FLG_SG_P_TYPE } { MSG_ORIG ( MSG_MAP_STACK ) PT_SUNWSTACK FLG_SG_P_TYPE | FLG_SG_EMPTY } { MSG_ORIG ( MSG_MAP_NULL ) PT_NULL FLG_SG_P_TYPE } { MSG_ORIG ( MSG_MAP_NOTE ) PT_NOTE FLG_SG_P_TYPE } { NULL } } ; ; seg_types_t * seg_type ; Token tok ; ld_map_tkval_t tkv ; Boolean b_type = FALSE ; Boolean b_flags = FALSE ; Boolean b_len = FALSE ; Boolean b_round = FALSE ; Boolean b_vaddr = FALSE ; Boolean b_paddr = FALSE ; Boolean b_align = FALSE ; while ( ( tok = ld_map_gettoken ( mf , TK_F_STRLC , & tkv ) ) != TK_SEMICOLON ) { if ( tok != TK_STRING ) { if ( tok != TK_ERROR ) { mf_fatal0 ( mf , MSG_INTL ( MSG_MAP_EXPSEGATT ) ) ; } return ( FALSE ) ; } for ( seg_type = seg_type_arr ; seg_type -> name ; seg_type ++ ) { if ( strcmp ( tkv . tkv_str , seg_type -> name ) == 0 ) { if ( b_type ) { mf_fatal ( mf , MSG_INTL ( MSG_MAP_MOREONCE ) , MSG_INTL ( MSG_MAP_SEGTYP ) ) ; return ( FALSE ) ; } if ( ( sgp -> sg_flags & FLG_SG_P_TYPE ) && ( sgp -> sg_phdr . p_type != seg_type -> p_type ) ) { mf_warn ( mf , MSG_INTL ( MSG_MAP_REDEFATT ) , MSG_INTL ( MSG_MAP_SEGTYP ) , sgp -> sg_name ) ; } sgp -> sg_phdr . p_type = seg_type -> p_type ; sgp -> sg_flags |= seg_type -> sg_flags ; break ; } } if ( seg_type -> name != NULL ) { continue ; } if ( * tkv . tkv_str == '?' ) { if ( ! map_equal_flags ( mf , sgp , & b_flags , tkv . tkv_str ) ) { return ( FALSE ) ; } continue ; } if ( ( tkv . tkv_str [ 0 ] == 'l' ) || ( tkv . tkv_str [ 0 ] == 'v' ) || ( tkv . tkv_str [ 0 ] == 'a' ) || ( tkv . tkv_str [ 0 ] == 'p' ) || ( tkv . tkv_str [ 0 ] == 'r' ) ) { Xword number ; if ( ! valuetoxword ( mf , & tkv , & number ) ) { return ( FALSE ) ; } switch ( * tkv . tkv_str ) { case 'l' : if ( b_len ) { mf_fatal ( mf , MSG_INTL ( MSG_MAP_MOREONCE ) , MSG_INTL ( MSG_MAP_SEGLEN ) ) ; return ( FALSE ) ; } if ( ( sgp -> sg_flags & FLG_SG_LENGTH ) && ( sgp -> sg_length != number ) ) { mf_warn ( mf , MSG_INTL ( MSG_MAP_REDEFATT ) , MSG_INTL ( MSG_MAP_SEGLEN ) , sgp -> sg_name ) ; } sgp -> sg_length = number ; sgp -> sg_flags |= FLG_SG_LENGTH ; b_len = TRUE ; break ; case 'r' : if ( b_round ) { mf_fatal ( mf , MSG_INTL ( MSG_MAP_MOREONCE ) , MSG_INTL ( MSG_MAP_SEGROUND ) ) ; return ( FALSE ) ; } if ( ( sgp -> sg_flags & FLG_SG_ROUND ) && ( sgp -> sg_round != number ) ) { mf_warn ( mf , MSG_INTL ( MSG_MAP_REDEFATT ) , MSG_INTL ( MSG_MAP_SEGROUND ) , sgp -> sg_name ) ; } sgp -> sg_round = number ; sgp -> sg_flags |= FLG_SG_ROUND ; b_round = TRUE ; break ; case 'v' : if ( b_vaddr ) { mf_fatal ( mf , MSG_INTL ( MSG_MAP_MOREONCE ) , MSG_INTL ( MSG_MAP_SEGVADDR ) ) ; return ( FALSE ) ; } if ( ( sgp -> sg_flags & FLG_SG_P_VADDR ) && ( sgp -> sg_phdr . p_vaddr != number ) ) { mf_warn ( mf , MSG_INTL ( MSG_MAP_REDEFATT ) , MSG_INTL ( MSG_MAP_SEGVADDR ) , sgp -> sg_name ) ; } sgp -> sg_phdr . p_vaddr = ( Addr ) number ; sgp -> sg_flags |= FLG_SG_P_VADDR ; b_vaddr = TRUE ; break ; case 'p' : if ( b_paddr ) { mf_fatal ( mf , MSG_INTL ( MSG_MAP_MOREONCE ) , MSG_INTL ( MSG_MAP_SEGPHYS ) ) ; return ( FALSE ) ; } if ( ( sgp -> sg_flags & FLG_SG_P_PADDR ) && ( sgp -> sg_phdr . p_paddr != number ) ) { mf_warn ( mf , MSG_INTL ( MSG_MAP_REDEFATT ) , MSG_INTL ( MSG_MAP_SEGPHYS ) , sgp -> sg_name ) ; } sgp -> sg_phdr . p_paddr = ( Addr ) number ; sgp -> sg_flags |= FLG_SG_P_PADDR ; b_paddr = TRUE ; break ; case 'a' : if ( b_align ) { mf_fatal ( mf , MSG_INTL ( MSG_MAP_MOREONCE ) , MSG_INTL ( MSG_MAP_SEGALIGN ) ) ; return ( FALSE ) ; } if ( ( sgp -> sg_flags & FLG_SG_P_ALIGN ) && ( sgp -> sg_phdr . p_align != number ) ) { mf_warn ( mf , MSG_INTL ( MSG_MAP_REDEFATT ) , MSG_INTL ( MSG_MAP_SEGALIGN ) , sgp -> sg_name ) ; } sgp -> sg_phdr . p_align = ( Xword ) number ; sgp -> sg_flags |= FLG_SG_P_ALIGN ; b_align = TRUE ; break ; } continue ; } mf_fatal ( mf , MSG_INTL ( MSG_MAP_UNKSEGATT ) , tkv . tkv_str ) ; return ( FALSE ) ; } if ( ( sgp -> sg_flags & FLG_SG_EMPTY ) && ( sgp -> sg_phdr . p_type != PT_SUNWSTACK ) ) { if ( sgp -> sg_phdr . p_flags != 0 ) { mf_fatal ( mf , MSG_INTL ( MSG_MAP_SEGEMNOPERM ) , EC_WORD ( sgp -> sg_phdr . p_flags ) ) ; return ( FALSE ) ; } if ( sgp -> sg_phdr . p_type == PT_LOAD ) { if ( ( mf -> mf_ofl -> ofl_flags & FLG_OF_EXEC ) == 0 ) { mf_fatal0 ( mf , MSG_INTL ( MSG_MAP_SEGEMPEXE ) ) ; return ( FALSE ) ; } if ( ( sgp -> sg_flags & ( FLG_SG_LENGTH | FLG_SG_P_VADDR ) ) != ( FLG_SG_LENGTH | FLG_SG_P_VADDR ) ) { mf_fatal0 ( mf , MSG_INTL ( MSG_MAP_SEGEMPATT ) ) ; return ( FALSE ) ; } } if ( sgp -> sg_phdr . p_type == PT_NULL ) { if ( ( sgp -> sg_flags & ( FLG_SG_LENGTH | FLG_SG_P_VADDR ) ) && ( ( sgp -> sg_length != 0 ) || ( sgp -> sg_phdr . p_vaddr != 0 ) ) ) { mf_fatal0 ( mf , MSG_INTL ( MSG_MAP_SEGEMPNOATT ) ) ; return ( FALSE ) ; } } else { mf_warn0 ( mf , MSG_INTL ( MSG_MAP_SEGEMPLOAD ) ) ; sgp -> sg_phdr . p_type = PT_LOAD ; } } if ( ( sgp -> sg_phdr . p_type != PT_NULL ) && ( sgp -> sg_phdr . p_type != PT_LOAD ) ) { const char * fmt ; if ( sgp -> sg_phdr . p_type == PT_SUNWSTACK ) { fmt = MSG_INTL ( MSG_MAP_NOSTACK1 ) ; } else { fmt = MSG_INTL ( MSG_MAP_NONLOAD ) ; } if ( ( sgp -> sg_flags & FLG_SG_P_FLAGS ) && ( sgp -> sg_phdr . p_type != PT_SUNWSTACK ) ) { if ( sgp -> sg_phdr . p_flags != 0 ) { mf_warn ( mf , MSG_INTL ( MSG_MAP_NONLOAD ) , MSG_INTL ( MSG_MAP_SEGFLAG ) ) ; sgp -> sg_phdr . p_flags = 0 ; } } if ( sgp -> sg_flags & FLG_SG_LENGTH ) { if ( sgp -> sg_length != 0 ) { mf_warn ( mf , fmt , MSG_INTL ( MSG_MAP_SEGLEN ) ) ; sgp -> sg_length = 0 ; } } if ( sgp -> sg_flags & FLG_SG_ROUND ) { if ( sgp -> sg_round != 0 ) { mf_warn ( mf , fmt , MSG_INTL ( MSG_MAP_SEGROUND ) ) ; sgp -> sg_round = 0 ; } } if ( sgp -> sg_flags & FLG_SG_P_VADDR ) { if ( sgp -> sg_phdr . p_vaddr != 0 ) { mf_warn ( mf , fmt , MSG_INTL ( MSG_MAP_SEGVADDR ) ) ; sgp -> sg_phdr . p_vaddr = 0 ; } } if ( sgp -> sg_flags & FLG_SG_P_PADDR ) { if ( sgp -> sg_phdr . p_paddr != 0 ) { mf_warn ( mf , fmt , MSG_INTL ( MSG_MAP_SEGPHYS ) ) ; sgp -> sg_phdr . p_paddr = 0 ; } } if ( sgp -> sg_flags & FLG_SG_P_ALIGN ) { } } return ( TRUE ) ; } 