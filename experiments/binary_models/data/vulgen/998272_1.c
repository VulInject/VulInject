void CL_ParseSnapshot ( msg_t * msg ) { int len ; clSnapshot_t * old ; clSnapshot_t newSnap ; int deltaNum ; int oldMessageNum ; int i , packetNum ; memset ( & newSnap , 0 , sizeof ( newSnap ) ) ; newSnap . serverCommandNum = clc . serverCommandSequence ; newSnap . serverTime = MSG_ReadLong ( msg ) ; cl_paused -> modified = 0 ; newSnap . messageNum = clc . serverMessageSequence ; deltaNum = MSG_ReadByte ( msg ) ; if ( ! deltaNum ) { newSnap . deltaNum = - 1 ; } else { newSnap . deltaNum = newSnap . messageNum - deltaNum ; } newSnap . snapFlags = MSG_ReadByte ( msg ) ; if ( newSnap . deltaNum <= 0 ) { newSnap . valid = qtrue ; old = NULL ; clc . demowaiting = qfalse ; } else { old = & cl . snapshots [ newSnap . deltaNum & PACKET_MASK ] ; if ( ! old -> valid ) { Com_Printf ( "Delta from invalid frame (not supposed to happen!).\n" ) ; } if ( old -> messageNum != newSnap . deltaNum ) { Com_DPrintf ( "Delta frame too old.\n" ) ; } if ( cl . parseEntitiesNum - old -> parseEntitiesNum > MAX_PARSE_ENTITIES - MAX_SNAPSHOT_ENTITIES ) { Com_DPrintf ( "Delta parseEntitiesNum too old.\n" ) ; } else { newSnap . valid = qtrue ; } } len = MSG_ReadByte ( msg ) ; if ( len > sizeof ( newSnap . areamask ) ) { Com_Error ( ERR_DROP , "CL_ParseSnapshot: Invalid size %d for areamask." , len ) ; return ; } MSG_ReadData ( msg , & newSnap . areamask , len ) ; SHOWNET ( msg , "playerstate" ) ; if ( old ) { MSG_ReadDeltaPlayerstate ( msg , & old -> ps , & newSnap . ps ) ; } else { MSG_ReadDeltaPlayerstate ( msg , NULL , & newSnap . ps ) ; } SHOWNET ( msg , "packet entities" ) ; CL_ParsePacketEntities ( msg , old , & newSnap ) ; if ( ! newSnap . valid ) { return ; } oldMessageNum = cl . snap . messageNum + 1 ; if ( newSnap . messageNum - oldMessageNum >= PACKET_BACKUP ) { oldMessageNum = newSnap . messageNum - ( PACKET_BACKUP - 1 ) ; } for ( ; oldMessageNum < newSnap . messageNum ; oldMessageNum ++ ) { cl . snapshots [ oldMessageNum & PACKET_MASK ] . valid = qfalse ; } cl . snap = newSnap ; cl . snap . ping = 999 ; for ( i = 0 ; i < PACKET_BACKUP ; i ++ ) { packetNum = ( clc . netchan . outgoingSequence - 1 - i ) & PACKET_MASK ; if ( cl . snap . ps . commandTime >= cl . outPackets [ packetNum ] . p_serverTime ) { cl . snap . ping = cls . realtime - cl . outPackets [ packetNum ] . p_realtime ; break ; } } cl . snapshots [ cl . snap . messageNum & PACKET_MASK ] = cl . snap ; cl . newSnapshots = qtrue ; } 