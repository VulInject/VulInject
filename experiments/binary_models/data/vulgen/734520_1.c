static int sonic_decode_frame ( AVCodecContext * avctx , AVFrame * frame , int * got_frame_ptr , AVPacket * avpkt ) { const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; SonicContext * s = avctx -> priv_data ; RangeCoder c ; uint8_t state [ 32 ] ; int i , quant , ch , j , ret ; int16_t * samples ; if ( buf_size == 0 ) { return 0 ; } frame -> nb_samples = s -> frame_size / avctx -> ch_layout . nb_channels ; if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) { return ret ; } samples = ( int16_t * ) frame -> data [ 0 ] ; memset ( state , 128 , sizeof ( state ) ) ; ff_init_range_decoder ( & c , buf , buf_size ) ; ff_build_rac_states ( & c , 0.05 * ( 1LL << 32 ) , 256 - 8 ) ; intlist_read ( & c , state , s -> predictor_k , s -> num_taps , 0 ) ; for ( i = 0 ; i < s -> num_taps ; i ++ ) { s -> predictor_k [ i ] *= ( unsigned ) s -> tap_quant [ i ] ; } if ( s -> lossless ) { quant = 1 ; } else { quant = get_symbol ( & c , state , 0 ) * SAMPLE_FACTOR ; } for ( ch = 0 ; ch < s -> channels ; ch ++ ) { int x = ch ; predictor_init_state ( s -> predictor_k , s -> predictor_state [ ch ] , s -> num_taps ) ; intlist_read ( & c , state , s -> coded_samples [ ch ] , s -> block_align , 1 ) ; for ( i = 0 ; i < s -> block_align ; i ++ ) { for ( j = 0 ; j < s -> downsampling - 1 ; j ++ ) { s -> int_samples [ x ] = predictor_calc_error ( s -> predictor_k , s -> predictor_state [ ch ] , s -> num_taps , 0 ) ; x += s -> channels ; } s -> int_samples [ x ] = predictor_calc_error ( s -> predictor_k , s -> predictor_state [ ch ] , s -> num_taps , s -> coded_samples [ ch ] [ i ] * ( unsigned ) quant ) ; x += s -> channels ; } for ( i = 0 ; i < s -> num_taps ; i ++ ) { s -> predictor_state [ ch ] [ i ] = s -> int_samples [ s -> frame_size - s -> channels + ch - i * s -> channels ] ; } } switch ( s -> decorrelation ) { case MID_SIDE : for ( i = 0 ; i < s -> frame_size ; i += s -> channels ) { s -> int_samples [ i + 1 ] += shift ( s -> int_samples [ i ] , 1 ) ; s -> int_samples [ i ] -= s -> int_samples [ i + 1 ] ; } break ; case LEFT_SIDE : for ( i = 0 ; i < s -> frame_size ; i += s -> channels ) { s -> int_samples [ i + 1 ] += s -> int_samples [ i ] ; } break ; case RIGHT_SIDE : for ( i = 0 ; i < s -> frame_size ; i += s -> channels ) { s -> int_samples [ i ] += s -> int_samples [ i + 1 ] ; } break ; } if ( ! s -> lossless ) { for ( i = 0 ; i < s -> frame_size ; i ++ ) { s -> int_samples [ i ] = shift ( s -> int_samples [ i ] , SAMPLE_SHIFT ) ; } } for ( i = 0 ; i < s -> frame_size ; i ++ ) { samples [ i ] = av_clip_int16 ( s -> int_samples [ i ] ) ; } * got_frame_ptr = 1 ; return buf_size ; } 