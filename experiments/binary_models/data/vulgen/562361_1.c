static void ei_watchdog ( u_long arg ) { struct net_device * dev = ( net_device * ) arg ; struct pcnet_dev * info = PRIV ( dev ) ; unsigned int nic_base = dev -> base_addr ; unsigned int mii_addr = nic_base + DLINK_GPIO ; u_short link ; if ( ! netif_device_present ( dev ) ) { reschedule } if ( info -> stale ++ && ( inb_p ( nic_base + EN0_ISR ) & ENISR_ALL ) ) { if ( ! info -> fast_poll ) { netdev_info ( dev , "interrupt(s) dropped!\n" ) ; } ei_irq_wrapper ( dev -> irq , dev ) ; info -> fast_poll = HZ ; } if ( info -> fast_poll ) { info -> fast_poll -- ; info -> watchdog . expires = jiffies + 1 ; add_timer ( & info -> watchdog ) ; return ; } if ( ! ( info -> flags & HAS_MII ) ) { reschedule } mdio_read ( mii_addr , info -> phy_id , 1 ) ; link = mdio_read ( mii_addr , info -> phy_id , 1 ) ; if ( ! link || ( link == 0xffff ) ) { if ( info -> eth_phy ) { info -> phy_id = info -> eth_phy = 0 ; } else { netdev_info ( dev , "MII is missing!\n" ) ; info -> flags &= ~ HAS_MII ; } reschedule } link &= 0x0004 ; if ( link != info -> link_status ) { u_short p = mdio_read ( mii_addr , info -> phy_id , 5 ) ; netdev_info ( dev , "%s link beat\n" , link ?"found" : "lost" ) ; if ( link && ( info -> flags & IS_DL10022 ) ) { outb ( ( p & 0x0140 ) ?4 : 0 , nic_base + DLINK_DIAG ) ; } if ( link && ( info -> flags & IS_DL10019 ) ) { write_asic ( dev -> base_addr , 4 , ( p & 0x140 ) ?DL19FDUPLX : 0 ) ; } if ( link ) { if ( info -> phy_id == info -> eth_phy ) { if ( p ) { netdev_info ( dev , "autonegotiation complete: " "%sbaseT-%cD selected\n" , ( ( p & 0x0180 ) ?"100" : "10" ) , ( ( p & 0x0140 ) ?'F' : 'H' ) ) ; } else { netdev_info ( dev , "link partner did not autonegotiate\n" ) ; } } NS8390_init ( dev , 1 ) ; } info -> link_status = link ; } reschedule info -> watchdog . expires = jiffies + HZ ; add_timer ( & info -> watchdog ) ; } 