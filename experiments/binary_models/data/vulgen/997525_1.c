BOOL GetDevices ( DWORD devnum ) { const char * usbstor_name [ ] { "USBSTOR" "RTSUER" "CMIUCR" "EUCR" "UASPSTOR" "VUSBSTOR" "ETRONSTOR" "ASUSSTPT" } ; ; const char * genstor_name [ ] { "SCSI" "SD" "PCISTOR" "RTSOR" "JMCR" "JMCF" "RIMMPTSK" "RIMSPTSK" "RISD" "RIXDPTSK" "TI21SONY" "ESD7SK" "ESM7SK" "O2MD" "O2SD" "VIACR" "GLREADER" } ; ; const char * scsi_disk_prefix = "SCSI\\Disk" ; const char * scsi_card_name [ ] { "_SD_" "_SDHC_" "_MMC_" "_MS_" "_MSPro_" "_xDPicture_" "_O2Media_" } ; ; const char * usb_speed_name [ USB_SPEED_MAX ] { "USB" "USB 1.0" "USB 1.1" "USB 2.0" "USB 3.0" "USB 3.1" } ; ; const char * windows_sandbox_vhd_label = "PortableBaseLayer" ; htab_table htab_devid = HTAB_EMPTY ; StrArray dev_if_path ; char letter_name [ ] " (?:)" ; ; char drive_name [ ] "?:\\" ; ; char setting_name [ 32 ] ; char uefi_togo_check [ ] "?:\\EFI\\Rufus\\ntfs_x64.efi" ; ; char scsi_card_name_copy [ 16 ] ; BOOL r = FALSE , found = FALSE , post_backslash ; HDEVINFO dev_info = NULL ; SP_DEVINFO_DATA dev_info_data ; SP_DEVICE_INTERFACE_DATA devint_data ; PSP_DEVICE_INTERFACE_DETAIL_DATA_A devint_detail_data ; DEVINST parent_inst , grandparent_inst , device_inst ; DWORD size , i , j , k , l , data_type , drive_index ; DWORD uasp_start = ARRAYSIZE ( usbstor_name ) , card_start = ARRAYSIZE ( genstor_name ) ; ULONG list_size [ ARRAYSIZE ( usbstor_name ) ] { 0 } ; , list_start [ ARRAYSIZE ( usbstor_name ) ] { 0 } ; , full_list_size , ulFlags ; HANDLE hDrive ; LONG maxwidth = 0 ; int s , u , v , score , drive_number , remove_drive , num_drives = 0 ; char drive_letters [ 27 ] , * device_id , * devid_list = NULL , display_msg [ 128 ] ; char * p , * label , * display_name , buffer [ MAX_PATH ] , str [ MAX_PATH ] , device_instance_id [ MAX_PATH ] , * method_str , * hub_path ; uint32_t ignore_vid_pid [ MAX_IGNORE_USB ] ; usb_device_props props ; IGNORE_RETVAL ( ComboBox_ResetContent ( hDeviceList ) ) ; ClearDrives ( ) ; StrArrayCreate ( & dev_if_path , 128 ) ; StrArrayAdd ( & dev_if_path , "" , TRUE ) ; device_id = ( char * ) malloc ( MAX_PATH ) ; if ( device_id == NULL ) { out } dev_info = SetupDiGetClassDevsA ( & GUID_DEVINTERFACE_USB_HUB , NULL , NULL , DIGCF_PRESENT | DIGCF_DEVICEINTERFACE ) ; if ( dev_info != INVALID_HANDLE_VALUE ) { if ( htab_create ( DEVID_HTAB_SIZE , & htab_devid ) ) { dev_info_data . cbSize = sizeof ( dev_info_data ) ; for ( i = 0 ; SetupDiEnumDeviceInfo ( dev_info , i , & dev_info_data ) ; i ++ ) { uuprintf ( "Processing Hub %d:" , i + 1 ) ; devint_detail_data = NULL ; devint_data . cbSize = sizeof ( devint_data ) ; if ( ( SetupDiEnumDeviceInterfaces ( dev_info , & dev_info_data , & GUID_DEVINTERFACE_USB_HUB , 0 , & devint_data ) ) && ( ! SetupDiGetDeviceInterfaceDetailA ( dev_info , & devint_data , NULL , 0 , & size , NULL ) ) && ( GetLastError ( ) == ERROR_INSUFFICIENT_BUFFER ) && ( ( devint_detail_data = ( PSP_DEVICE_INTERFACE_DETAIL_DATA_A ) calloc ( 1 , size ) ) != NULL ) ) { devint_detail_data -> cbSize = sizeof ( SP_DEVICE_INTERFACE_DETAIL_DATA_A ) ; if ( SetupDiGetDeviceInterfaceDetailA ( dev_info , & devint_data , devint_detail_data , size , & size , NULL ) ) { if ( CM_Get_Child ( & device_inst , dev_info_data . DevInst , 0 ) == CR_SUCCESS ) { device_id [ 0 ] = 0 ; s = StrArrayAdd ( & dev_if_path , devint_detail_data -> DevicePath , TRUE ) ; uuprintf ( "  Hub[%d] = '%s'" , s , devint_detail_data -> DevicePath ) ; if ( ( s >= 0 ) && ( CM_Get_Device_IDA ( device_inst , device_id , MAX_PATH , 0 ) == CR_SUCCESS ) ) { ToUpper ( device_id ) ; if ( ( k = htab_hash ( device_id , & htab_devid ) ) != 0 ) { htab_devid . table [ k ] . data = ( void * ) ( uintptr_t ) s ; } uuprintf ( "  Found ID[%03d]: %s" , k , device_id ) ; while ( CM_Get_Sibling ( & device_inst , device_inst , 0 ) == CR_SUCCESS ) { device_id [ 0 ] = 0 ; if ( CM_Get_Device_IDA ( device_inst , device_id , MAX_PATH , 0 ) == CR_SUCCESS ) { ToUpper ( device_id ) ; if ( ( k = htab_hash ( device_id , & htab_devid ) ) != 0 ) { htab_devid . table [ k ] . data = ( void * ) ( uintptr_t ) s ; } uuprintf ( "  Found ID[%03d]: %s" , k , device_id ) ; } } } } } free ( devint_detail_data ) ; } } } SetupDiDestroyDeviceInfoList ( dev_info ) ; } free ( device_id ) ; full_list_size = 0 ; ulFlags = CM_GETIDLIST_FILTER_SERVICE | CM_GETIDLIST_FILTER_PRESENT ; for ( s = 0 ; s < ARRAYSIZE ( usbstor_name ) ; s ++ ) { if ( strcmp ( usbstor_name [ s ] , "UASPSTOR" ) == 0 ) { uasp_start = s ; } if ( CM_Get_Device_ID_List_SizeA ( & list_size [ s ] , usbstor_name [ s ] , ulFlags ) != CR_SUCCESS ) { list_size [ s ] = 0 ; } if ( list_size [ s ] != 0 ) { full_list_size += list_size [ s ] - 1 ; } } for ( s = 0 ; s < ARRAYSIZE ( genstor_name ) ; s ++ ) { if ( strcmp ( genstor_name [ s ] , "SD" ) == 0 ) { card_start = s ; } } for ( s = 0 ; s < ARRAYSIZE ( ignore_vid_pid ) ; s ++ ) { static_sprintf ( setting_name , "IgnoreUsb%02d" , s + 1 ) ; ignore_vid_pid [ s ] = ReadSetting32 ( setting_name ) ; } assert ( ( uasp_start > 0 ) && ( uasp_start < ARRAYSIZE ( usbstor_name ) ) ) ; assert ( ( card_start > 0 ) && ( card_start < ARRAYSIZE ( genstor_name ) ) ) ; devid_list = NULL ; if ( full_list_size != 0 ) { full_list_size += 1 ; devid_list = ( char * ) malloc ( full_list_size ) ; if ( devid_list == NULL ) { uprintf ( "Could not allocate Device ID list" ) ; out } for ( s = 0 , i = 0 ; s < ARRAYSIZE ( usbstor_name ) ; s ++ ) { list_start [ s ] = i ; if ( list_size [ s ] > 1 ) { if ( CM_Get_Device_ID_ListA ( usbstor_name [ s ] , & devid_list [ i ] , list_size [ s ] , ulFlags ) != CR_SUCCESS ) { continue ; } if ( usb_debug ) { uprintf ( "Processing IDs belonging to '%s':" , usbstor_name [ s ] ) ; for ( device_id = & devid_list [ i ] ; * device_id != 0 ; device_id += strlen ( device_id ) + 1 ) { uprintf ( "  %s" , device_id ) ; } } for ( i += list_size [ s ] ; i > 2 ; i -- ) { if ( ( devid_list [ i - 2 ] != '\0' ) && ( devid_list [ i - 1 ] == '\0' ) && ( devid_list [ i ] == '\0' ) ) { break ; } } } } } dev_info = SetupDiGetClassDevsA ( & GUID_DEVINTERFACE_DISK , NULL , NULL , DIGCF_PRESENT | DIGCF_DEVICEINTERFACE ) ; if ( dev_info == INVALID_HANDLE_VALUE ) { uprintf ( "SetupDiGetClassDevs (Interface) failed: %s" , WindowsErrorString ( ) ) ; out } dev_info_data . cbSize = sizeof ( dev_info_data ) ; for ( i = 0 ; num_drives < MAX_DRIVES && SetupDiEnumDeviceInfo ( dev_info , i , & dev_info_data ) ; i ++ ) { memset ( buffer , 0 , sizeof ( buffer ) ) ; memset ( & props , 0 , sizeof ( props ) ) ; method_str = "" ; hub_path = NULL ; if ( ! SetupDiGetDeviceRegistryPropertyA ( dev_info , & dev_info_data , SPDRP_ENUMERATOR_NAME , & data_type , ( LPBYTE ) buffer , sizeof ( buffer ) , & size ) ) { uprintf ( "SetupDiGetDeviceRegistryProperty (Enumerator Name) failed: %s" , WindowsErrorString ( ) ) ; continue ; } for ( j = 0 ; j < ARRAYSIZE ( usbstor_name ) ; j ++ ) { if ( safe_stricmp ( buffer , usbstor_name [ 0 ] ) == 0 ) { props . is_USB = TRUE ; if ( ( j != 0 ) && ( j < uasp_start ) ) { props . is_CARD = TRUE ; } break ; } } for ( j = 0 ; j < ARRAYSIZE ( genstor_name ) ; j ++ ) { if ( safe_stricmp ( buffer , genstor_name [ j ] ) == 0 ) { props . is_SCSI = TRUE ; if ( j >= card_start ) { props . is_CARD = TRUE ; } break ; } } uuprintf ( "Processing '%s' device:" , buffer ) ; if ( ( ! props . is_USB ) && ( ! props . is_SCSI ) ) { uuprintf ( "  Unsupported or disabled by policy" ) ; continue ; } memset ( buffer , 0 , sizeof ( buffer ) ) ; props . is_VHD = SetupDiGetDeviceRegistryPropertyA ( dev_info , & dev_info_data , SPDRP_HARDWAREID , & data_type , ( LPBYTE ) buffer , sizeof ( buffer ) , & size ) && IsVHD ( buffer ) ; if ( ( ! props . is_CARD ) && ( safe_strnicmp ( buffer , scsi_disk_prefix , sizeof ( scsi_disk_prefix ) - 1 ) == 0 ) ) { for ( j = 0 ; j < ARRAYSIZE ( scsi_card_name ) ; j ++ ) { static_strcpy ( scsi_card_name_copy , scsi_card_name [ j ] ) ; if ( safe_strstr ( buffer , scsi_card_name_copy ) != NULL ) { props . is_CARD = TRUE ; break ; } assert ( strlen ( scsi_card_name_copy ) > 1 ) ; scsi_card_name_copy [ strlen ( scsi_card_name_copy ) - 1 ] = '&' ; if ( safe_strstr ( buffer , scsi_card_name_copy ) != NULL ) { props . is_CARD = TRUE ; break ; } } } uuprintf ( "  Hardware ID: '%s'" , buffer ) ; if ( ! SetupDiGetDeviceInstanceIdA ( dev_info , & dev_info_data , device_instance_id , sizeof ( device_instance_id ) , & size ) ) { uprintf ( "SetupDiGetDeviceInstanceId failed: %s" , WindowsErrorString ( ) ) ; strcpy ( device_instance_id , "<N/A>" ) ; } memset ( buffer , 0 , sizeof ( buffer ) ) ; props . is_Removable = SetupDiGetDeviceRegistryPropertyA ( dev_info , & dev_info_data , SPDRP_REMOVAL_POLICY , & data_type , ( LPBYTE ) buffer , sizeof ( buffer ) , & size ) && IsRemovable ( buffer ) ; memset ( buffer , 0 , sizeof ( buffer ) ) ; if ( ! SetupDiGetDeviceRegistryPropertyU ( dev_info , & dev_info_data , SPDRP_FRIENDLYNAME , & data_type , ( LPBYTE ) buffer , sizeof ( buffer ) , & size ) ) { uprintf ( "SetupDiGetDeviceRegistryProperty (Friendly Name) failed: %s" , WindowsErrorString ( ) ) ; static_strcpy ( buffer , lmprintf ( MSG_045 ) ) ; } if ( ( ! props . is_VHD ) && ( devid_list != NULL ) ) { for ( device_id = devid_list ; * device_id != 0 ; device_id += strlen ( device_id ) + 1 ) { if ( CM_Locate_DevNodeA ( & parent_inst , device_id , 0 ) != CR_SUCCESS ) { uuprintf ( "Could not locate device node for '%s'" , device_id ) ; continue ; } if ( CM_Get_Child ( & device_inst , parent_inst , 0 ) != CR_SUCCESS ) { uuprintf ( "Could not get children of '%s'" , device_id ) ; continue ; } if ( device_inst != dev_info_data . DevInst ) { while ( CM_Get_Sibling ( & device_inst , device_inst , 0 ) == CR_SUCCESS ) { if ( device_inst == dev_info_data . DevInst ) { uuprintf ( "NOTE: Matched instance from sibling for '%s'" , device_id ) ; break ; } } if ( device_inst != dev_info_data . DevInst ) { continue ; } } post_backslash = FALSE ; method_str = "" ; props . is_UASP = ( ( ( ( uintptr_t ) device_id ) + 2 ) >= ( ( uintptr_t ) devid_list ) + list_start [ uasp_start ] ) ; ToUpper ( device_id ) ; j = htab_hash ( device_id , & htab_devid ) ; uuprintf ( "  Matched with ID[%03d]: %s" , j , device_id ) ; for ( k = 0 , l = 0 ; ( k < strlen ( device_id ) ) && ( l < 2 ) ; k ++ ) { if ( device_id [ k ] == '\\' ) { post_backslash = TRUE ; } if ( ! post_backslash ) { continue ; } if ( device_id [ k ] == '_' ) { props . pid = ( uint16_t ) strtoul ( & device_id [ k + 1 ] , NULL , 16 ) ; if ( l ++ == 0 ) { props . vid = props . pid ; } } } if ( props . vid != 0 ) { method_str = "[ID]" ; } if ( ( ( uintptr_t ) htab_devid . table [ j ] . data == 0 ) && ( CM_Get_Parent ( & grandparent_inst , parent_inst , 0 ) == CR_SUCCESS ) && ( CM_Get_Device_IDA ( grandparent_inst , str , MAX_PATH , 0 ) == CR_SUCCESS ) ) { device_id = str ; method_str = "[GP]" ; ToUpper ( device_id ) ; j = htab_hash ( device_id , & htab_devid ) ; uuprintf ( "  Matched with (GP) ID[%03d]: %s" , j , device_id ) ; } if ( ( uintptr_t ) htab_devid . table [ j ] . data > 0 ) { uuprintf ( "  Matched with Hub[%d]: '%s'" , ( uintptr_t ) htab_devid . table [ j ] . data , dev_if_path . String [ ( uintptr_t ) htab_devid . table [ j ] . data ] ) ; if ( GetUSBProperties ( dev_if_path . String [ ( uintptr_t ) htab_devid . table [ j ] . data ] , device_id , & props ) ) { method_str = "" ; hub_path = dev_if_path . String [ ( uintptr_t ) htab_devid . table [ j ] . data ] ; } props . vid = FORCED_VID ; props . pid = FORCED_PID ; static_strcpy ( buffer , FORCED_NAME ) ; } break ; } } if ( props . is_VHD ) { uprintf ( "Found VHD device '%s'" , buffer ) ; } if ( ( props . is_CARD ) && ( ( ! props . is_USB ) || ( ( props . vid == 0 ) && ( props . pid == 0 ) ) ) ) { uprintf ( "Found card reader device '%s'" , buffer ) ; } if ( ( ! props . is_USB ) && ( ! props . is_UASP ) && ( props . is_Removable ) ) { if ( ! list_non_usb_removable_drives ) { uprintf ( "Found non-USB removable device '%s' =>Eliminated" , buffer ) ; uuprintf ( "If you *REALLY* need, you can enable listing of this device with<Ctrl><Alt><F>" ) ; continue ; } uprintf ( "Found non-USB removable device '%s'" , buffer ) ; } else { if ( ( props . vid == 0 ) && ( props . pid == 0 ) ) { if ( ! props . is_USB ) { uuprintf ( "Found non-USB non-removable device '%s' =>Eliminated" , buffer ) ; continue ; } static_strcpy ( str , "????:????" ) ; } else { static_sprintf ( str , "%04X:%04X" , props . vid , props . pid ) ; if ( its_a_me_mario ) { if ( ( props . vid == 0x0525 ) && ( props . pid == 0x622b ) ) { continue ; } if ( ( props . vid == 0x0781 ) && ( props . pid == 0x75a0 ) ) { continue ; } if ( ( props . vid == 0x10d6 ) && ( props . pid == 0x1101 ) ) { continue ; } } for ( s = 0 ; s < ARRAYSIZE ( ignore_vid_pid ) ; s ++ ) { if ( ( props . vid == ( ignore_vid_pid [ s ] >> 16 ) ) && ( props . pid == ( ignore_vid_pid [ s ] & 0xffff ) ) ) { uprintf ( "Ignoring '%s' (%s), per user settings" , buffer , str ) ; break ; } } if ( s < ARRAYSIZE ( ignore_vid_pid ) ) { continue ; } } if ( props . speed >= USB_SPEED_MAX ) { props . speed = 0 ; } uprintf ( "Found %s%s%s device '%s' (%s) %s" , props . is_UASP ?"UAS (" : "" , usb_speed_name [ props . speed ] , props . is_UASP ?")" : "" , buffer , str , method_str ) ; if ( props . lower_speed ) { uprintf ( "NOTE: This device is a USB 3.%c device operating at lower speed..." , '0' + props . lower_speed - 1 ) ; } } devint_data . cbSize = sizeof ( devint_data ) ; devint_detail_data = NULL ; for ( j = 0 ; ; j ++ ) { safe_free ( devint_detail_data ) ; if ( ! SetupDiEnumDeviceInterfaces ( dev_info , & dev_info_data , & GUID_DEVINTERFACE_DISK , j , & devint_data ) ) { if ( GetLastError ( ) != ERROR_NO_MORE_ITEMS ) { uprintf ( "SetupDiEnumDeviceInterfaces failed: %s" , WindowsErrorString ( ) ) ; } else { uprintf ( "A device was eliminated because it didn't report itself as a disk" ) ; } break ; } if ( ! SetupDiGetDeviceInterfaceDetailA ( dev_info , & devint_data , NULL , 0 , & size , NULL ) ) { if ( GetLastError ( ) == ERROR_INSUFFICIENT_BUFFER ) { devint_detail_data = ( PSP_DEVICE_INTERFACE_DETAIL_DATA_A ) calloc ( 1 , size ) ; if ( devint_detail_data == NULL ) { uprintf ( "Unable to allocate data for SP_DEVICE_INTERFACE_DETAIL_DATA" ) ; continue ; } devint_detail_data -> cbSize = sizeof ( SP_DEVICE_INTERFACE_DETAIL_DATA_A ) ; } else { uprintf ( "SetupDiGetDeviceInterfaceDetail (dummy) failed: %s" , WindowsErrorString ( ) ) ; continue ; } } if ( devint_detail_data == NULL ) { uprintf ( "SetupDiGetDeviceInterfaceDetail (dummy) - no data was allocated" ) ; continue ; } if ( ! SetupDiGetDeviceInterfaceDetailA ( dev_info , & devint_data , devint_detail_data , size , & size , NULL ) ) { uprintf ( "SetupDiGetDeviceInterfaceDetail (actual) failed: %s" , WindowsErrorString ( ) ) ; continue ; } hDrive = CreateFileA ( devint_detail_data -> DevicePath , GENERIC_READ | GENERIC_WRITE , FILE_SHARE_READ | FILE_SHARE_WRITE , NULL , OPEN_EXISTING , FILE_ATTRIBUTE_NORMAL , NULL ) ; if ( hDrive == INVALID_HANDLE_VALUE ) { uprintf ( "Could not open '%s': %s" , devint_detail_data -> DevicePath , WindowsErrorString ( ) ) ; continue ; } drive_number = GetDriveNumber ( hDrive , devint_detail_data -> DevicePath ) ; CloseHandle ( hDrive ) ; if ( drive_number < 0 ) { continue ; } drive_index = drive_number + DRIVE_INDEX_MIN ; if ( ! IsMediaPresent ( drive_index ) ) { uprintf ( "Device eliminated because it appears to contain no media" ) ; safe_free ( devint_detail_data ) ; break ; } if ( GetDriveSize ( drive_index ) < ( MIN_DRIVE_SIZE * MB ) ) { uprintf ( "Device eliminated because it is smaller than %d MB" , MIN_DRIVE_SIZE ) ; safe_free ( devint_detail_data ) ; break ; } if ( GetDriveLabel ( drive_index , drive_letters , & label ) ) { if ( ( props . is_SCSI ) && ( ! props . is_UASP ) && ( ! props . is_VHD ) ) { if ( ! props . is_Removable ) { safe_free ( devint_detail_data ) ; break ; } if ( ! list_non_usb_removable_drives ) { for ( p = drive_letters ; * p ; p ++ ) { drive_name [ 0 ] = * p ; if ( GetDriveTypeA ( drive_name ) != DRIVE_REMOVABLE ) { break ; } } if ( * p ) { uprintf ( "Device eliminated because it contains a mounted partition that is set as non-removable" ) ; safe_free ( devint_detail_data ) ; break ; } } } if ( ( ! enable_HDDs ) && ( ! props . is_VHD ) && ( ! props . is_CARD ) && ( ( score = IsHDD ( drive_index , ( uint16_t ) props . vid , ( uint16_t ) props . pid , buffer ) ) > 0 ) ) { uprintf ( "Device eliminated because it was detected as a Hard Drive (score %d>0)" , score ) ; if ( ! list_non_usb_removable_drives ) { uprintf ( "If this device is not a Hard Drive, please e-mail the author of this application" ) ; } uprintf ( "NOTE: You can enable the listing of Hard Drives under 'advanced drive properties'" ) ; safe_free ( devint_detail_data ) ; break ; } if ( ( ! enable_HDDs ) && ( props . is_CARD ) && ( GetDriveSize ( drive_index ) > MAX_DEFAULT_LIST_CARD_SIZE * GB ) ) { uprintf ( "Device eliminated because it was detected as a card larger than %d GB" , MAX_DEFAULT_LIST_CARD_SIZE ) ; uprintf ( "To use such a card, check 'List USB Hard Drives' under 'advanced drive properties'" ) ; safe_free ( devint_detail_data ) ; break ; } if ( safe_strcmp ( label , windows_sandbox_vhd_label ) == 0 ) { uprintf ( "Device eliminated because it is a Windows Sandbox VHD" ) ; safe_free ( devint_detail_data ) ; break ; } if ( props . is_VHD && ( ! enable_VHDs ) ) { uprintf ( "Device eliminated because listing of VHDs is disabled (Alt-G)" ) ; safe_free ( devint_detail_data ) ; break ; } if ( drive_letters [ 0 ] == 0 ) { display_name = lmprintf ( MSG_046 , label , drive_number , SizeToHumanReadable ( GetDriveSize ( drive_index ) , FALSE , use_fake_units ) ) ; } else { for ( k = 0 ; drive_letters [ k ] ; k ++ ) { uefi_togo_check [ 0 ] = drive_letters [ k ] ; if ( PathFileExistsA ( uefi_togo_check ) ) { for ( l = k ; drive_letters [ l ] ; l ++ ) { drive_letters [ l ] = drive_letters [ l + 1 ] ; } k -- ; } } static_strcpy ( display_msg , ( ( ( drive_letters [ 0 ] != 0 ) && ( drive_letters [ 1 ] != 0 ) ) ?lmprintf ( MSG_047 ) : label ) ) ; for ( k = 0 , remove_drive = 0 ; drive_letters [ k ] && ( ! remove_drive ) ; k ++ ) { letter_name [ 2 ] = drive_letters [ k ] ; if ( right_to_left_mode ) { static_strcat ( display_msg , RIGHT_TO_LEFT_MARK ) ; } static_strcat ( display_msg , letter_name ) ; if ( drive_letters [ k ] == ( PathGetDriveNumberU ( app_dir ) + 'A' ) ) { remove_drive = 1 ; } if ( drive_letters [ k ] == ( PathGetDriveNumberU ( system_dir ) + 'A' ) ) { remove_drive = 2 ; } } if ( remove_drive ) { uprintf ( "Removing %c: from the list: This is the %s!" , toupper ( drive_letters [ -- k ] ) , ( remove_drive == 1 ) ?"disk from which " APPLICATION_NAME " is running" : "system disk" ) ; safe_free ( devint_detail_data ) ; break ; } safe_sprintf ( & display_msg [ strlen ( display_msg ) ] , sizeof ( display_msg ) - strlen ( display_msg ) , "%s [%s]" , ( right_to_left_mode ) ?RIGHT_TO_LEFT_MARK : "" , SizeToHumanReadable ( GetDriveSize ( drive_index ) , FALSE , use_fake_units ) ) ; display_name = display_msg ; } rufus_drive [ num_drives ] . index = drive_index ; rufus_drive [ num_drives ] . id = safe_strdup ( device_instance_id ) ; rufus_drive [ num_drives ] . name = safe_strdup ( buffer ) ; rufus_drive [ num_drives ] . display_name = safe_strdup ( display_name ) ; rufus_drive [ num_drives ] . label = safe_strdup ( label ) ; rufus_drive [ num_drives ] . size = GetDriveSize ( drive_index ) ; assert ( rufus_drive [ num_drives ] . size != 0 ) ; if ( hub_path != NULL ) { rufus_drive [ num_drives ] . hub = safe_strdup ( hub_path ) ; rufus_drive [ num_drives ] . port = props . port ; } num_drives ++ ; if ( num_drives >= MAX_DRIVES ) { uprintf ( "Warning: Found more than %d drives - ignoring remaining ones..." , MAX_DRIVES ) ; } safe_free ( devint_detail_data ) ; break ; } } } SetupDiDestroyDeviceInfoList ( dev_info ) ; for ( u = 0 ; u < num_drives - 1 ; u ++ ) { uint64_t min_drive_size = rufus_drive [ u ] . size ; int min_index = u ; for ( v = u + 1 ; v < num_drives ; v ++ ) { if ( rufus_drive [ v ] . size < min_drive_size ) { min_drive_size = rufus_drive [ v ] . size ; min_index = v ; } } if ( min_index != u ) { RUFUS_DRIVE tmp ; memcpy ( & tmp , & rufus_drive [ u ] , sizeof ( RUFUS_DRIVE ) ) ; memcpy ( & rufus_drive [ u ] , & rufus_drive [ min_index ] , sizeof ( RUFUS_DRIVE ) ) ; memcpy ( & rufus_drive [ min_index ] , & tmp , sizeof ( RUFUS_DRIVE ) ) ; } } for ( u = 0 ; u < num_drives ; u ++ ) { IGNORE_RETVAL ( ComboBox_SetItemData ( hDeviceList , ComboBox_AddStringU ( hDeviceList , rufus_drive [ u ] . display_name ) , rufus_drive [ u ] . index ) ) ; maxwidth = max ( maxwidth , GetEntryWidth ( hDeviceList , rufus_drive [ u ] . display_name ) ) ; } SendMessage ( hDeviceList , CB_SETDROPPEDWIDTH , ( WPARAM ) maxwidth , 0 ) ; if ( ! found ) { i = 0 ; } IGNORE_RETVAL ( ComboBox_SetCurSel ( hDeviceList , i ) ) ; SendMessage ( hMainDialog , WM_COMMAND , ( CBN_SELCHANGE << 16 ) | IDC_DEVICE , 0 ) ; r = TRUE ; out SendMessage ( hMainDialog , WM_NEXTDLGCTL , ( WPARAM ) GetDlgItem ( hMainDialog , IDC_START ) , TRUE ) ; safe_free ( devid_list ) ; StrArrayDestroy ( & dev_if_path ) ; htab_destroy ( & htab_devid ) ; return r ; } 