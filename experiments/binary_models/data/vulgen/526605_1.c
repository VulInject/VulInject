static inline void tb_add_jump ( TranslationBlock * tb , int n , TranslationBlock * tb_next ) { uintptr_t old ; qemu_thread_jit_write ( ) ; assert ( n < ARRAY_SIZE ( tb -> jmp_list_next ) ) ; qemu_spin_lock ( & tb_next -> jmp_lock ) ; old = qatomic_cmpxchg ( & tb -> jmp_dest [ n ] , ( uintptr_t ) NULL , ( uintptr_t ) tb_next ) ; if ( old ) { out_unlock_next } tb_set_jmp_target ( tb , n , ( uintptr_t ) tb_next -> tc . ptr ) ; tb -> jmp_list_next [ n ] = tb_next -> jmp_list_head ; tb_next -> jmp_list_head = ( uintptr_t ) tb | n ; qemu_spin_unlock ( & tb_next -> jmp_lock ) ; qemu_log_mask_and_addr ( CPU_LOG_EXEC , tb -> pc , "Linking TBs %p [" TARGET_FMT_lx "] index %d ->%p [" TARGET_FMT_lx "]\n" , tb -> tc . ptr , tb -> pc , n , tb_next -> tc . ptr , tb_next -> pc ) ; return ; out_unlock_next qemu_spin_unlock ( & tb_next -> jmp_lock ) ; return ; } 