static int exec_stmt_call ( PLpgSQL_execstate * estate , PLpgSQL_stmt_call * stmt ) { PLpgSQL_expr * expr = stmt -> expr ; LocalTransactionId before_lxid ; LocalTransactionId after_lxid ; ParamListInfo paramLI ; SPIExecuteOptions options ; int rc ; if ( expr -> plan == NULL ) { exec_prepare_plan ( estate , expr , 0 ) ; } Assert ( ! expr -> expr_simple_expr ) ; if ( stmt -> is_call && stmt -> target == NULL ) { stmt -> target = make_callstmt_target ( estate , expr ) ; } paramLI = setup_param_list ( estate , expr ) ; before_lxid = MyProc -> lxid ; memset ( & options , 0 , sizeof ( options ) ) ; options . params = paramLI ; options . read_only = estate -> readonly_func ; options . allow_nonatomic = true ; options . owner = estate -> procedure_resowner ; rc = SPI_execute_plan_extended ( expr -> plan , & options ) ; if ( rc < 0 ) { elog ( ERROR , "SPI_execute_plan_extended failed executing query \"%s\": %s" , expr -> query , SPI_result_code_string ( rc ) ) ; } after_lxid = MyProc -> lxid ; if ( before_lxid != after_lxid ) { estate -> simple_eval_estate = NULL ; estate -> simple_eval_resowner = NULL ; plpgsql_create_econtext ( estate ) ; } if ( SPI_processed == 1 ) { SPITupleTable * tuptab = SPI_tuptable ; if ( ! stmt -> is_call ) { elog ( ERROR , "DO statement returned a row" ) ; } exec_move_row ( estate , stmt -> target , tuptab -> vals [ 0 ] , tuptab -> tupdesc ) ; } if ( SPI_processed > 1 ) { elog ( ERROR , "procedure call returned more than one row" ) ; } SPI_freetuptable ( SPI_tuptable ) ; return PLPGSQL_RC_OK ; } 