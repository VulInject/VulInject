static bool mptcp_established_options_dss ( struct sock * sk , struct sk_buff * skb , bool snd_data_fin_enable , unsigned int * size , unsigned int remaining , struct mptcp_out_options * opts ) { struct mptcp_subflow_context * subflow = mptcp_subflow_ctx ( sk ) ; struct mptcp_sock * msk = mptcp_sk ( subflow -> conn ) ; unsigned int dss_size = 0 ; struct mptcp_ext * mpext ; unsigned int ack_size ; bool ret = false ; u64 ack_seq ; opts -> csum_reqd = READ_ONCE ( msk -> csum_enabled ) ; mpext = skb ?mptcp_get_ext ( skb ) : NULL ; if ( ! skb || ( mpext && mpext -> use_map ) || snd_data_fin_enable ) { unsigned int map_size = TCPOLEN_MPTCP_DSS_BASE + TCPOLEN_MPTCP_DSS_MAP64 ; if ( mpext ) { if ( opts -> csum_reqd ) { map_size += TCPOLEN_MPTCP_DSS_CHECKSUM ; } opts -> ext_copy = * mpext ; } remaining -= map_size ; dss_size = map_size ; if ( skb && snd_data_fin_enable ) { mptcp_write_data_fin ( subflow , skb , & opts -> ext_copy ) ; } ret = true ; } opts -> ext_copy . use_ack = 0 ; if ( ! READ_ONCE ( msk -> can_ack ) ) { * size = ALIGN ( dss_size , 4 ) ; return ret ; } ack_seq = READ_ONCE ( msk -> ack_seq ) ; if ( READ_ONCE ( msk -> use_64bit_ack ) ) { ack_size = TCPOLEN_MPTCP_DSS_ACK64 ; opts -> ext_copy . data_ack = ack_seq ; opts -> ext_copy . ack64 = 1 ; } else { ack_size = TCPOLEN_MPTCP_DSS_ACK32 ; opts -> ext_copy . data_ack32 = ( uint32_t ) ack_seq ; opts -> ext_copy . ack64 = 0 ; } opts -> ext_copy . use_ack = 1 ; opts -> suboptions = OPTION_MPTCP_DSS ; WRITE_ONCE ( msk -> old_wspace , __mptcp_space ( ( sock * ) msk ) ) ; if ( dss_size == 0 ) { ack_size += TCPOLEN_MPTCP_DSS_BASE ; } dss_size += ack_size ; * size = ALIGN ( dss_size , 4 ) ; return true ; } 