void async_cdp_callback ( int is_timeout , void * param , AAAMessage * saa , long elapsed_msecs ) { struct cell * t = 0 ; int rc = - 1 , experimental_rc = - 1 ; int result = CSCF_RETURN_TRUE ; saved_transaction_t * data = 0 ; struct sip_msg * req ; str xml_data = { 0 0 } , ccf1 = { 0 0 } , ccf2 = { 0 0 } , ecf1 = { 0 0 } , ecf2 = { 0 0 } ; ims_subscription * s ; rerrno = R_FINE ; if ( ! param ) { LM_DBG ( "No transaction data this must have been called from usrloc cb impu deleted - just log result code and then exit" ) ; cxdx_get_result_code ( saa , & rc ) ; cxdx_get_experimental_result_code ( saa , & experimental_rc ) ; if ( saa ) { cdpb . AAAFreeMessage ( & saa ) ; } if ( ! rc && ! experimental_rc ) { LM_ERR ( "bad SAA result code\n" ) ; return ; } switch ( rc ) { case - 1 : LM_DBG ( "Received Diameter error\n" ) ; return ; case AAA_UNABLE_TO_COMPLY : LM_DBG ( "Unable to comply\n" ) ; return ; case AAA_SUCCESS : LM_DBG ( "received AAA success\n" ) ; return ; default : LM_ERR ( "Unknown error\n" ) ; return ; } } else { LM_DBG ( "There is transaction data this must have been called from save or assign server unreg" ) ; data = ( saved_transaction_t * ) param ; if ( tmb . t_lookup_ident ( & t , data -> tindex , data -> tlabel ) < 0 ) { LM_ERR ( "t_continue: transaction not found and t is now pointing to %p and will be set to NULL\n" , t ) ; t = NULL ; rerrno = R_SAR_FAILED ; error_no_send } set_avp_list ( AVP_TRACK_FROM | AVP_CLASS_URI , & t -> uri_avps_from ) ; set_avp_list ( AVP_TRACK_TO | AVP_CLASS_URI , & t -> uri_avps_to ) ; set_avp_list ( AVP_TRACK_FROM | AVP_CLASS_USER , & t -> user_avps_from ) ; set_avp_list ( AVP_TRACK_TO | AVP_CLASS_USER , & t -> user_avps_to ) ; set_avp_list ( AVP_TRACK_FROM | AVP_CLASS_DOMAIN , & t -> domain_avps_from ) ; set_avp_list ( AVP_TRACK_TO | AVP_CLASS_DOMAIN , & t -> domain_avps_to ) ; get_act_time ( ) ; req = get_request_from_tx ( t ) ; if ( ! req ) { LM_ERR ( "Failed to get SIP Request from Transaction\n" ) ; error_no_send } if ( is_timeout ) { update_stat ( stat_sar_timeouts , 1 ) ; LM_ERR ( "Transaction timeout - did not get SAA\n" ) ; rerrno = R_SAR_FAILED ; error } if ( ! saa ) { LM_ERR ( "Error sending message via CDP\n" ) ; rerrno = R_SAR_FAILED ; error } update_stat ( sar_replies_received , 1 ) ; update_stat ( sar_replies_response_time , elapsed_msecs ) ; if ( parse_message_for_register ( req ) < 0 ) { LM_ERR ( "Unable to parse register message correctly\n" ) ; rerrno = R_SAR_FAILED ; error } LM_DBG ( "callid for found transaction is [%.*s]\n" , req -> callid -> body . len , req -> callid -> body . s ) ; cxdx_get_result_code ( saa , & rc ) ; cxdx_get_experimental_result_code ( saa , & experimental_rc ) ; cxdx_get_charging_info ( saa , & ccf1 , & ccf2 , & ecf1 , & ecf2 ) ; if ( ! rc && ! experimental_rc ) { LM_ERR ( "bad SAA result code\n" ) ; rerrno = R_SAR_FAILED ; error } switch ( rc ) { case - 1 : LM_DBG ( "Received Diameter error\n" ) ; rerrno = R_SAR_FAILED ; error case AAA_UNABLE_TO_COMPLY : LM_DBG ( "Unable to comply\n" ) ; rerrno = R_SAR_FAILED ; error case AAA_SUCCESS : LM_DBG ( "received AAA success for SAR - SAA\n" ) ; break ; default : LM_ERR ( "Unknown error\n" ) ; rerrno = R_SAR_FAILED ; error } if ( data -> sar_assignment_type != AVP_IMS_SAR_UNREGISTERED_USER && data -> expires == 0 ) { LM_DBG ( "no need to update usrloc - already done for de-reg\n" ) ; result = CSCF_RETURN_TRUE ; success } xml_data = cxdx_get_user_data ( saa ) ; if ( xml_data . s && xml_data . len > 0 ) { LM_DBG ( "Parsing user data string from SAA\n" ) ; s = parse_user_data ( xml_data ) ; if ( ! s ) { LM_ERR ( "Unable to parse user data XML string\n" ) ; rerrno = R_SAR_FAILED ; error } LM_DBG ( "Successfully parse user data XML setting ref to 1 (we are referencing it)\n" ) ; s -> ref_count = 1 ; } else { if ( data -> require_user_data ) { LM_ERR ( "We require User data for this assignment/register and none was supplied\n" ) ; rerrno = R_SAR_FAILED ; result = CSCF_RETURN_FALSE ; done } } if ( update_contacts ( req , data -> domain , & data -> public_identity , data -> sar_assignment_type , & s , & ccf1 , & ccf2 , & ecf1 , & ecf2 , & data -> contact_header ) <= 0 ) { LM_ERR ( "Error processing REGISTER\n" ) ; rerrno = R_SAR_FAILED ; error } if ( data -> contact_header ) { LM_DBG ( "Updated contacts: %.*s\n" , data -> contact_header -> data_len , data -> contact_header -> buf ) ; } else { LM_DBG ( "Updated unreg contact\n" ) ; } } success update_stat ( accepted_registrations , 1 ) ; done if ( data -> sar_assignment_type != AVP_IMS_SAR_UNREGISTERED_USER ) { reg_send_reply_transactional ( req , data -> contact_header , t ) ; } LM_DBG ( "DBG:SAR Async CDP callback: ... Done resuming transaction\n" ) ; create_return_code ( result ) ; if ( s ) { ul . unref_subscription ( s ) ; } if ( saa ) { cdpb . AAAFreeMessage ( & saa ) ; } if ( t ) { tmb . unref_cell ( t ) ; } tmb . t_continue_skip_timer ( data -> tindex , data -> tlabel , data -> act ) ; free_saved_transaction_data ( data ) ; return ; error create_return_code ( - 2 ) ; if ( data -> sar_assignment_type != AVP_IMS_SAR_UNREGISTERED_USER ) { reg_send_reply_transactional ( req , data -> contact_header , t ) ; } error_no_send update_stat ( rejected_registrations , 1 ) ; if ( saa ) { cdpb . AAAFreeMessage ( & saa ) ; } if ( t ) { tmb . unref_cell ( t ) ; } tmb . t_continue ( data -> tindex , data -> tlabel , data -> act ) ; free_saved_transaction_data ( data ) ; return ; } 