static void ata_identify_init ( struct ahci_port * p , int atapi ) { struct ata_params * ata_ident = & p -> ata_ident ; if ( atapi ) { ata_ident -> config = ATA_PROTO_ATAPI | ATA_ATAPI_TYPE_CDROM | ATA_ATAPI_REMOVABLE | ATA_DRQ_FAST ; ata_ident -> capabilities1 = ATA_SUPPORT_LBA | ATA_SUPPORT_DMA ; ata_ident -> atavalid = ATA_FLAG_64_70 | ATA_FLAG_88 ; ata_ident -> obsolete62 = 0x3f ; ata_ident -> mwdmamodes = 7 ; if ( p -> xfermode & ATA_WDMA0 ) { ata_ident -> mwdmamodes |= ( 1 << ( ( p -> xfermode & 7 ) + 8 ) ) ; } ata_ident -> apiomodes = 3 ; ata_ident -> mwdmamin = 0x0078 ; ata_ident -> mwdmarec = 0x0078 ; ata_ident -> pioblind = 0x0078 ; ata_ident -> pioiordy = 0x0078 ; ata_ident -> satacapabilities = ( ATA_SATA_GEN1 | ATA_SATA_GEN2 | ATA_SATA_GEN3 ) ; ata_ident -> satacapabilities2 = ( ( p -> ssts & ATA_SS_SPD_MASK ) >> 3 ) ; ata_ident -> satasupport = ATA_SUPPORT_NCQ_STREAM ; ata_ident -> version_major = 0x3f0 ; ata_ident -> support . command1 = ( ATA_SUPPORT_POWERMGT | ATA_SUPPORT_PACKET | ATA_SUPPORT_RESET | ATA_SUPPORT_NOP ) ; ata_ident -> support . command2 = ( 1 << 14 ) ; ata_ident -> support . extension = ( 1 << 14 ) ; ata_ident -> enabled . command1 = ( ATA_SUPPORT_POWERMGT | ATA_SUPPORT_PACKET | ATA_SUPPORT_RESET | ATA_SUPPORT_NOP ) ; ata_ident -> enabled . extension = ( 1 << 14 ) ; ata_ident -> udmamodes = 0x7f ; if ( p -> xfermode & ATA_UDMA0 ) { ata_ident -> udmamodes |= ( 1 << ( ( p -> xfermode & 7 ) + 8 ) ) ; } ata_ident -> transport_major = 0x1020 ; ata_ident -> integrity = 0x00a5 ; } else { uint64_t sectors ; int sectsz , psectsz , psectoff , candelete , ro ; uint16_t cyl ; uint8_t sech , heads ; ro = blockif_is_ro ( p -> bctx ) ; candelete = blockif_candelete ( p -> bctx ) ; sectsz = blockif_sectsz ( p -> bctx ) ; sectors = blockif_size ( p -> bctx ) / sectsz ; blockif_chs ( p -> bctx , & cyl , & heads , & sech ) ; blockif_psectsz ( p -> bctx , & psectsz , & psectoff ) ; ata_ident -> config = ATA_DRQ_FAST ; ata_ident -> cylinders = cyl ; ata_ident -> heads = heads ; ata_ident -> sectors = sech ; ata_ident -> sectors_intr = ( 0x8000 | 128 ) ; ata_ident -> tcg = 0 ; ata_ident -> capabilities1 = ATA_SUPPORT_DMA | ATA_SUPPORT_LBA | ATA_SUPPORT_IORDY ; ata_ident -> capabilities2 = ( 1 << 14 ) ; ata_ident -> atavalid = ATA_FLAG_64_70 | ATA_FLAG_88 ; if ( p -> mult_sectors ) { ata_ident -> multi = ( ATA_MULTI_VALID | p -> mult_sectors ) ; } if ( sectors <= 0x0fffffff ) { ata_ident -> lba_size_1 = sectors ; ata_ident -> lba_size_2 = ( sectors >> 16 ) ; } else { ata_ident -> lba_size_1 = 0xffff ; ata_ident -> lba_size_2 = 0x0fff ; } ata_ident -> mwdmamodes = 0x7 ; if ( p -> xfermode & ATA_WDMA0 ) { ata_ident -> mwdmamodes |= ( 1 << ( ( p -> xfermode & 7 ) + 8 ) ) ; } ata_ident -> apiomodes = 0x3 ; ata_ident -> mwdmamin = 0x0078 ; ata_ident -> mwdmarec = 0x0078 ; ata_ident -> pioblind = 0x0078 ; ata_ident -> pioiordy = 0x0078 ; ata_ident -> support3 = 0 ; ata_ident -> queue = 31 ; ata_ident -> satacapabilities = ( ATA_SATA_GEN1 | ATA_SATA_GEN2 | ATA_SATA_GEN3 | ATA_SUPPORT_NCQ ) ; ata_ident -> satacapabilities2 = ( ATA_SUPPORT_RCVSND_FPDMA_QUEUED | ( p -> ssts & ATA_SS_SPD_MASK ) >> 3 ) ; ata_ident -> version_major = 0x3f0 ; ata_ident -> version_minor = 0x28 ; ata_ident -> support . command1 = ( ATA_SUPPORT_POWERMGT | ATA_SUPPORT_WRITECACHE | ATA_SUPPORT_LOOKAHEAD | ATA_SUPPORT_NOP ) ; ata_ident -> support . command2 = ( ATA_SUPPORT_ADDRESS48 | ATA_SUPPORT_FLUSHCACHE | ATA_SUPPORT_FLUSHCACHE48 | 1 << 14 ) ; ata_ident -> support . extension = ( 1 << 14 ) ; ata_ident -> enabled . command1 = ( ATA_SUPPORT_POWERMGT | ATA_SUPPORT_WRITECACHE | ATA_SUPPORT_LOOKAHEAD | ATA_SUPPORT_NOP ) ; ata_ident -> enabled . command2 = ( ATA_SUPPORT_ADDRESS48 | ATA_SUPPORT_FLUSHCACHE | ATA_SUPPORT_FLUSHCACHE48 | 1 << 15 ) ; ata_ident -> enabled . extension = ( 1 << 14 ) ; ata_ident -> udmamodes = 0x7f ; if ( p -> xfermode & ATA_UDMA0 ) { ata_ident -> udmamodes |= ( 1 << ( ( p -> xfermode & 7 ) + 8 ) ) ; } ata_ident -> lba_size48_1 = sectors ; ata_ident -> lba_size48_2 = ( sectors >> 16 ) ; ata_ident -> lba_size48_3 = ( sectors >> 32 ) ; ata_ident -> lba_size48_4 = ( sectors >> 48 ) ; if ( candelete && ! ro ) { ata_ident -> support3 |= ATA_SUPPORT_RZAT | ATA_SUPPORT_DRAT ; ata_ident -> max_dsm_blocks = 1 ; ata_ident -> support_dsm = ATA_SUPPORT_DSM_TRIM ; } ata_ident -> pss = ATA_PSS_VALID_VALUE ; ata_ident -> lsalign = 0x4000 ; if ( psectsz > sectsz ) { ata_ident -> pss |= ATA_PSS_MULTLS ; ata_ident -> pss |= ffsl ( psectsz / sectsz ) - 1 ; ata_ident -> lsalign |= ( psectoff / sectsz ) ; } if ( sectsz > 512 ) { ata_ident -> pss |= ATA_PSS_LSSABOVE512 ; ata_ident -> lss_1 = sectsz / 2 ; ata_ident -> lss_2 = ( ( sectsz / 2 ) >> 16 ) ; } ata_ident -> support2 = ( ATA_SUPPORT_RWLOGDMAEXT | 1 << 14 ) ; ata_ident -> enabled2 = ( ATA_SUPPORT_RWLOGDMAEXT | 1 << 14 ) ; ata_ident -> transport_major = 0x1020 ; ata_ident -> integrity = 0x00a5 ; } ahci_checksum ( ( uint8_t * ) ata_ident , sizeof ( ata_params ) ) ; } 