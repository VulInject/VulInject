int ptcioctl ( dev_t dev , int cmd , intptr_t data , int flag , struct cred * cred , int * rvalp ) { struct pty * pty = & pty_softc [ getminor ( dev ) ] ; queue_t * q ; struct ttysize tty_arg ; struct winsize win_arg ; int d_arg ; int err ; switch ( cmd ) { case TIOCPKT : copy_in ( data , d_arg ) ; mutex_enter ( & pty -> ptc_lock ) ; if ( d_arg ) { if ( pty -> pt_flags & ( PF_UCNTL | PF_43UCNTL ) ) { mutex_exit ( & pty -> ptc_lock ) ; return ( EINVAL ) ; } pty -> pt_flags |= PF_PKT ; } else { pty -> pt_flags &= ~ PF_PKT ; } mutex_exit ( & pty -> ptc_lock ) ; break ; case TIOCUCNTL : copy_in ( data , d_arg ) ; mutex_enter ( & pty -> ptc_lock ) ; if ( d_arg ) { if ( pty -> pt_flags & ( PF_PKT | PF_UCNTL ) ) { mutex_exit ( & pty -> ptc_lock ) ; return ( EINVAL ) ; } pty -> pt_flags |= PF_43UCNTL ; } else { pty -> pt_flags &= ~ PF_43UCNTL ; } mutex_exit ( & pty -> ptc_lock ) ; break ; case TIOCTCNTL : copy_in ( data , d_arg ) ; mutex_enter ( & pty -> ptc_lock ) ; if ( d_arg ) { if ( pty -> pt_flags & PF_PKT ) { mutex_exit ( & pty -> ptc_lock ) ; return ( EINVAL ) ; } pty -> pt_flags |= PF_UCNTL ; } else { pty -> pt_flags &= ~ PF_UCNTL ; } mutex_exit ( & pty -> ptc_lock ) ; break ; case TIOCREMOTE : copy_in ( data , d_arg ) ; mutex_enter ( & pty -> ptc_lock ) ; if ( d_arg ) { if ( ( q = pty -> pt_ttycommon . t_readq ) != NULL ) { ( void ) putctl1 ( q , M_CTL , MC_NOCANON ) ; } pty -> pt_flags |= PF_REMOTE ; } else { if ( ( q = pty -> pt_ttycommon . t_readq ) != NULL ) { ( void ) putctl1 ( q , M_CTL , MC_DOCANON ) ; } pty -> pt_flags &= ~ PF_REMOTE ; } mutex_exit ( & pty -> ptc_lock ) ; break ; case TIOCSIGNAL : copy_in ( data , d_arg ) ; mutex_enter ( & pty -> ptc_lock ) ; if ( ( q = pty -> pt_ttycommon . t_readq ) != NULL ) { ( void ) putctl1 ( q , M_PCSIG , ( int ) d_arg ) ; } mutex_exit ( & pty -> ptc_lock ) ; break ; case FIONBIO : copy_in ( data , d_arg ) ; mutex_enter ( & pty -> ptc_lock ) ; if ( d_arg ) { pty -> pt_flags |= PF_NBIO ; } else { pty -> pt_flags &= ~ PF_NBIO ; } mutex_exit ( & pty -> ptc_lock ) ; break ; case FIOASYNC : copy_in ( data , d_arg ) ; mutex_enter ( & pty -> ptc_lock ) ; if ( d_arg ) { pty -> pt_flags |= PF_ASYNC ; } else { pty -> pt_flags &= ~ PF_ASYNC ; } mutex_exit ( & pty -> ptc_lock ) ; break ; case FIOGETOWN : mutex_enter ( & pty -> ptc_lock ) ; d_arg = - pty -> pt_pgrp ; mutex_exit ( & pty -> ptc_lock ) ; copy_out ( d_arg , data ) ; break ; case FIOSETOWN : copy_in ( data , d_arg ) ; mutex_enter ( & pty -> ptc_lock ) ; pty -> pt_pgrp = ( short ) ( - d_arg ) ; mutex_exit ( & pty -> ptc_lock ) ; break ; case FIONREAD : { mblk_t * mp ; size_t count = 0 ; mutex_enter ( & pty -> ptc_lock ) ; if ( pty -> pt_flags & ( PF_PKT | PF_UCNTL ) && pty -> pt_send ) { count = 1 ; } if ( ( pty -> pt_flags & ( PF_UCNTL | PF_43UCNTL ) ) && pty -> pt_ucntl ) { count = 1 ; } if ( ( q = pty -> pt_ttycommon . t_writeq ) != NULL && q -> q_first != NULL && ! ( pty -> pt_flags & PF_STOPPED ) ) { for ( mp = q -> q_first ; mp != NULL ; mp = mp -> b_next ) { count += msgdsize ( mp ) ; } } if ( ( pty -> pt_flags & PF_UCNTL ) && pty -> pt_stuffqfirst != NULL ) { count = pty -> pt_stuffqlen + 1 ; } d_arg = MIN ( count , INT_MAX ) ; mutex_exit ( & pty -> ptc_lock ) ; copy_out ( d_arg , data ) ; break ; } case TIOCSWINSZ : if ( copyin ( ( caddr_t ) data , & tty_arg , sizeof ( ttysize ) ) != 0 ) { return ( EFAULT ) ; } if ( ( tty_arg . ts_lines & 0xffff0000 ) != 0 ) { win_arg = * ( winsize * ) & tty_arg ; mutex_enter ( & pty -> ptc_lock ) ; if ( bcmp ( & pty -> pt_ttycommon . t_size , & win_arg , sizeof ( winsize ) ) ) { pty -> pt_ttycommon . t_size = win_arg ; if ( ( q = pty -> pt_ttycommon . t_readq ) != NULL ) { ( void ) putctl1 ( q , M_PCSIG , SIGWINCH ) ; } } mutex_exit ( & pty -> ptc_lock ) ; break ; } case TIOCSSIZE : if ( copyin ( ( caddr_t ) data , & tty_arg , sizeof ( ttysize ) ) != 0 ) { return ( EFAULT ) ; } mutex_enter ( & pty -> ptc_lock ) ; pty -> pt_ttycommon . t_size . ws_row = ( ushort_t ) tty_arg . ts_lines ; pty -> pt_ttycommon . t_size . ws_col = ( ushort_t ) tty_arg . ts_cols ; pty -> pt_ttycommon . t_size . ws_xpixel = 0 ; pty -> pt_ttycommon . t_size . ws_ypixel = 0 ; mutex_exit ( & pty -> ptc_lock ) ; break ; case TIOCGWINSZ : mutex_enter ( & pty -> ptc_lock ) ; win_arg = pty -> pt_ttycommon . t_size ; mutex_exit ( & pty -> ptc_lock ) ; if ( copyout ( & win_arg , ( caddr_t ) data , sizeof ( winsize ) ) != 0 ) { return ( EFAULT ) ; } break ; case TIOCGSIZE : mutex_enter ( & pty -> ptc_lock ) ; tty_arg . ts_lines = pty -> pt_ttycommon . t_size . ws_row ; tty_arg . ts_cols = pty -> pt_ttycommon . t_size . ws_col ; mutex_exit ( & pty -> ptc_lock ) ; if ( copyout ( & tty_arg , ( caddr_t ) data , sizeof ( ttysize ) ) != 0 ) { return ( EFAULT ) ; } break ; case TIOCGPGRP : case TIOCSPGRP : case TIOCGETP : case TIOCSETP : case TIOCSETN : case TIOCGETC : case TIOCSETC : case TIOCGLTC : case TIOCSLTC : case TIOCLGET : case TIOCLSET : case TIOCLBIS : case TIOCLBIC : mutex_enter ( & pty -> ptc_lock ) ; if ( pty -> pt_vnode == NULL ) { mutex_exit ( & pty -> ptc_lock ) ; return ( EIO ) ; } pty -> pt_flags |= PF_IOCTL ; mutex_exit ( & pty -> ptc_lock ) ; err = strioctl ( pty -> pt_vnode , cmd , data , flag , U_TO_K , cred , rvalp ) ; mutex_enter ( & pty -> ptc_lock ) ; pty -> pt_flags &= ~ ( PF_IOCTL | PF_WAIT ) ; mutex_exit ( & pty -> ptc_lock ) ; return ( err ) ; default : return ( ENOTTY ) ; } return ( 0 ) ; } 