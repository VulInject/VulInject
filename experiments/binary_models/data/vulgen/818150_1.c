int request_winfo ( struct sip_msg * msg , char * uri , char * expires ) { subs_info_t subs ; struct sip_uri puri ; int printbuf_len = 0 ; char buffer [ PRINTBUF_SIZE ] ; str uri_str ; memset ( & puri , 0 , sizeof ( sip_uri ) ) ; if ( uri ) { printbuf_len = PRINTBUF_SIZE - 1 ; if ( pv_printf ( msg , ( pv_elem_t * ) uri , buffer , & printbuf_len ) < 0 ) { LM_ERR ( "cannot print the format\n" ) ; return - 1 ; } if ( parse_uri ( buffer , printbuf_len , & puri ) != 0 ) { LM_ERR ( "bad owner SIP address!\n" ) ; error } else { LM_DBG ( "using user id [%.*s]\n" , printbuf_len , buffer ) ; } } if ( printbuf_len == 0 || puri . user . len <= 0 || puri . user . s == NULL || puri . host . len <= 0 || puri . host . s == NULL ) { LM_ERR ( "bad owner URI!\n" ) ; error } uri_str . s = buffer ; uri_str . len = printbuf_len ; LM_DBG ( "uri= %.*s:\n" , uri_str . len , uri_str . s ) ; subs . pres_uri = & uri_str ; subs . watcher_uri = & uri_str ; subs . contact = & server_address ; if ( strncmp ( expires , "0" , 1 ) == 0 ) { subs . expires = 0 ; } else { subs . expires = - 1 ; } subs . source_flag |= XMPP_SUBSCRIBE ; subs . event = PWINFO_EVENT ; if ( pua_send_subscribe ( & subs ) < 0 ) { LM_ERR ( "while sending subscribe\n" ) ; error } return 1 ; error return 0 ; } 