m68hc11_address_cost ( ) { int cost = 4 ; switch ( GET_CODE ( addr ) ) { case REG : else { cost = 1 ; } break ; case SYMBOL_REF : cost = 8 ; break ; case LABEL_REF : case CONST : cost = 0 ; break ; case PLUS : { register rtx plus0 = XEXP ( addr , 0 ) ; register rtx plus1 = XEXP ( addr , 1 ) ; if ( GET_CODE ( plus0 ) != REG ) { break ; } switch ( GET_CODE ( plus1 ) ) { case CONST_INT : if ( INTVAL ( plus1 ) >= 2 * m68hc11_max_offset || INTVAL ( plus1 ) < m68hc11_min_offset ) { cost = 3 ; } if ( INTVAL ( plus1 ) >= m68hc11_max_offset ) { cost = 2 ; } else { cost = 1 ; } if ( REGNO ( plus0 ) < FIRST_PSEUDO_REGISTER ) { cost += 0 ; } else { cost += 1 ; } break ; case SYMBOL_REF : cost = 8 ; break ; case CONST : case LABEL_REF : cost = 0 ; break ; default : break ; } break ; } case PRE_DEC : case PRE_INC : if ( SP_REG_P ( XEXP ( addr , 0 ) ) ) { cost = 1 ; } break ; default : break ; } if ( debug_m6811 ) { printf ( "Address cost: %d for :" , cost ) ; fflush ( stdout ) ; debug_rtx ( addr ) ; } return cost ; } 