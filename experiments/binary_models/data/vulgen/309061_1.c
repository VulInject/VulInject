static void process_delete_command ( conn * c , token_t * tokens , const size_t ntokens ) { char * key ; size_t nkey ; item * it ; uint32_t hv ; assert ( c != NULL ) ; if ( ntokens > 3 ) { bool hold_is_zero = strcmp ( tokens [ KEY_TOKEN + 1 ] . value , "0" ) == 0 ; bool sets_noreply = set_noreply_maybe ( c , tokens , ntokens ) ; bool valid = ( ntokens == 4 && ( hold_is_zero || sets_noreply ) ) || ( ntokens == 5 && hold_is_zero && sets_noreply ) ; if ( ! valid ) { out_string ( c , "CLIENT_ERROR bad command line format.  " "Usage: delete<key>[noreply]" ) ; return ; } } key = tokens [ KEY_TOKEN ] . value ; nkey = tokens [ KEY_TOKEN ] . length ; if ( settings . detail_enabled ) { stats_prefix_record_delete ( key , nkey ) ; } it = item_get_locked ( key , nkey , c , DONT_UPDATE , & hv ) ; if ( it ) { MEMCACHED_COMMAND_DELETE ( c -> sfd , ITEM_key ( it ) , it -> nkey ) ; pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . slab_stats [ ITEM_clsid ( it ) ] . delete_hits ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; do_item_unlink ( it , hv ) ; STORAGE_delete ( c -> thread -> storage , it ) ; do_item_remove ( it ) ; out_string ( c , "DELETED" ) ; } else { pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . delete_misses ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; out_string ( c , "NOT_FOUND" ) ; } item_unlock ( hv ) ; } 