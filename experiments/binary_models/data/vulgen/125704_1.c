extern void check_allocation ( con_mgr_t * conmgr , con_mgr_fd_t * con , con_mgr_work_type_t type , con_mgr_work_status_t status , const char * tag , void * arg ) { static long delay = 1 ; bool bail = false ; int rc , job_id ; read_lock_state ( ) ; bail = ( state . status != CONTAINER_ST_CREATING ) ; job_id = state . jobid ; unlock_state ( ) ; if ( bail ) { debug ( "%s: bailing due to status %s != %s" , __func__ , slurm_container_status_to_str ( state . status ) , slurm_container_status_to_str ( CONTAINER_ST_CREATING ) ) ; stop_anchor ( ESLURM_ALREADY_DONE ) ; return ; } if ( status != CONMGR_WORK_STATUS_RUN ) { debug ( "%s: bailing due to callback status %s" , __func__ , con_mgr_work_status_string ( status ) ) ; stop_anchor ( ESLURM_ALREADY_DONE ) ; return ; } if ( get_log_level ( ) >= LOG_LEVEL_DEBUG ) { read_lock_state ( ) ; debug ( "%s: checking JobId=%d for nodes ready" , __func__ , state . jobid ) ; unlock_state ( ) ; } rc = slurm_job_node_ready ( job_id ) ; if ( ( rc == READY_JOB_ERROR ) || ( rc == EAGAIN ) ) { delay *= 2 ; if ( ( delay < 0 ) || ( delay > MAX_DELAY ) ) { delay = MAX_DELAY ; } if ( get_log_level ( ) >= LOG_LEVEL_DEBUG ) { read_lock_state ( ) ; debug ( "%s: rechecking JobId=%d for nodes ready in %" PRId64 "ns" , __func__ , state . jobid , delay ) ; unlock_state ( ) ; } } if ( ( rc == READY_JOB_FATAL ) || ! ( rc & READY_JOB_STATE ) ) { if ( get_log_level ( ) >= LOG_LEVEL_DEBUG ) { read_lock_state ( ) ; debug ( "%s: JobId=%d failed. Bailing on checking for nodes." , __func__ , state . jobid ) ; unlock_state ( ) ; } stop_anchor ( ESLURM_ALREADY_DONE ) ; return ; } else { if ( get_log_level ( ) >= LOG_LEVEL_DEBUG ) { read_lock_state ( ) ; debug ( "%s: JobId=%d is ready" , __func__ , state . jobid ) ; unlock_state ( ) ; } if ( ( rc = _stage_in ( ) ) ) { stop_anchor ( rc ) ; } else { con_mgr_add_work ( conmgr , NULL , on_allocation , CONMGR_WORK_TYPE_FIFO , NULL , __func__ ) ; } } } 