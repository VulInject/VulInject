struct itype * it_new ( uint64_t , size_t , const char * , uint32_t , uint16_t , uint64_t , uint16_t , unsigned int ) void it_merge ( struct itype * , struct itype * ) void it_reference ( struct itype * ) void it_free ( struct itype * ) int it_cmp ( struct itype * , struct itype * ) int it_name_cmp ( struct itype * , struct itype * ) int it_off_cmp ( struct itype * , struct itype * ) void ir_add ( struct itype * , struct itype * ) void ir_purge ( struct itype * ) struct imember * im_new ( const char * , size_t , size_t ) RB_GENERATE ( itype_tree , itype , it_node , it_cmp ) ; RB_GENERATE ( isymb_tree , itype , it_node , it_name_cmp ) ; RB_GENERATE ( ioff_tree , itype , it_node , it_off_cmp ) ; void dwarf_parse ( const char * infobuf , size_t infolen , const char * abbuf , size_t ablen ) { struct dwbuf info = { . buf = infobuf . len = infolen } ; struct dwbuf abbrev = { . buf = abbuf . len = ablen } ; struct dwcu * dcu = NULL ; struct ioff_tree cu_iofft ; struct itype_queue cu_itypeq ; struct itype * it ; int i ; for ( i = 0 ; i < CTF_K_MAX ; i ++ ) { RB_INIT ( & itypet [ i ] ) ; } RB_INIT ( & isymbt ) ; void_it = it_new ( ++ tidx , VOID_OFFSET , "void" , 0 , CTF_INT_SIGNED , 0 , CTF_K_INTEGER , 0 ) ; TAILQ_INSERT_TAIL ( & itypeq , void_it , it_next ) ; while ( dw_cu_parse ( & info , & abbrev , infolen , & dcu ) == 0 ) { TAILQ_INIT ( & cu_itypeq ) ; RB_INIT ( & cu_iofft ) ; cu_parse ( dcu , & cu_itypeq , & cu_iofft ) ; cu_resolve ( dcu , & cu_itypeq , & cu_iofft ) ; assert ( RB_EMPTY ( & cu_iofft ) ) ; cu_reference ( dcu , & cu_itypeq ) ; cu_stat ( ) ; cu_merge ( dcu , & cu_itypeq ) ; dw_dcu_free ( dcu ) ; } RB_FOREACH ( , , ) { if ( strcmp ( it_name ( it ) , "unsigned" ) == 0 ) { long_tidx = it -> it_idx ; break ; } } } 