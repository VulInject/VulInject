void mai_init ( ) { int rc ; int i ; Threadname_t my_pid ; uint8_t name [ 16 ] ; IB_ENTER ( __func__ , 0 , 0 , 0 , 0 ) ; ( void ) vs_thread_name ( & my_pid ) ; if ( gMAI_INITIALIZED == 0 ) { if ( mai_init_pid == 0ull ) { mai_init_pid = my_pid ; ( void ) vs_thread_sleep ( VTIMER_1S ) ; } i = 0 ; if ( mai_init_pid != my_pid ) { while ( gMAI_INITIALIZED == 0 && i < 30 ) { ( void ) vs_thread_sleep ( VTIMER_1S ) ; i ++ ; } if ( gMAI_INITIALIZED == 0 ) { IB_LOG_ERROR0 ( "failed to initialized" ) ; } return ; } } else { IB_LOG_INFO ( "Already initialized" , 0 ) ; return ; } if ( gMAI_INITIALIZED ) { IB_LOG_INFO ( "Already initialized" , 0 ) ; return ; } gMAI_FILT_CNT = gMAI_MAD_CNT = gMAI_HDL_CNT = 0 ; MSTATS_INIT ( ) ; gMAI_UP_CHANNELS = NULL ; gMAI_DATA_FREE = NULL ; gMAI_HANDLE_FREE = NULL ; gMAI_FILT_FREE = NULL ; gMAI_DCTHREAD_HANDLE = MAI_INVALID ; cs_sema_create ( & gMAI_DCTHREAD_SEMA , 0 ) ; mai_dc_read_exit = 0 ; ( void ) memset ( & gmai_uplock , 0 , sizeof ( MLock_t ) ) ; ( void ) memset ( & gmai_hlock , 0 , sizeof ( MLock_t ) ) ; ( void ) memset ( & gmai_flock , 0 , sizeof ( MLock_t ) ) ; ( void ) memset ( & gmai_mlock , 0 , sizeof ( MLock_t ) ) ; ( void ) memset ( & gmai_dcthr_lock , 0 , sizeof ( MLock_t ) ) ; rc = vs_lock_init ( & gmai_uplock . lock , VLOCK_FREE , VLOCK_THREAD ) ; if ( rc ) { IB_LOG_ERRORRC ( "vs_lock_init rc:" , rc ) ; IB_EXIT ( __func__ , VSTATUS_BAD ) ; return ; } rc = vs_lock_init ( & gmai_hlock . lock , VLOCK_FREE , VLOCK_THREAD ) ; if ( rc ) { IB_LOG_ERRORRC ( "vs_lock_init rc:" , rc ) ; IB_EXIT ( __func__ , VSTATUS_BAD ) ; return ; } rc = vs_lock_init ( & gmai_flock . lock , VLOCK_FREE , VLOCK_THREAD ) ; if ( rc ) { IB_LOG_ERRORRC ( "vs_lock_init rc:" , rc ) ; IB_EXIT ( __func__ , VSTATUS_BAD ) ; return ; } rc = vs_lock_init ( & gmai_mlock . lock , VLOCK_FREE , VLOCK_THREAD ) ; if ( rc ) { IB_LOG_ERRORRC ( "vs_lock_init rc:" , rc ) ; IB_EXIT ( __func__ , VSTATUS_BAD ) ; return ; } rc = vs_lock_init ( & gmai_dcthr_lock . lock , VLOCK_FREE , VLOCK_THREAD ) ; if ( rc ) { IB_LOG_ERRORRC ( "gmai_dcthr_lock vs_lock_init rc:" , rc ) ; IB_EXIT ( __func__ , VSTATUS_BAD ) ; return ; } ( void ) memset ( gMAI_DOWN_CL , 0 , sizeof ( gMAI_DOWN_CL ) ) ; for ( i = 0 ; i < MAI_MAXDC_CHANNELS ; i ++ ) { struct mai_dc * p ; p = & gMAI_DOWN_CL [ i ] ; p -> next = NULL ; p -> state = MAI_FREE ; p -> ref = 0 ; p -> readt_state = QPS_DEAD ; rc = vs_lock_init ( & p -> lock . lock , VLOCK_FREE , VLOCK_THREAD ) ; if ( rc ) { IB_LOG_ERRORRC ( "vs_lock_init rc:" , rc ) ; IB_EXIT ( __func__ , VSTATUS_BAD ) ; return ; } } ( void ) memset ( ev_array , 0 , sizeof ( ev_array ) ) ; for ( i = 0 ; i < MAI_MAX_EVENTS ; i ++ ) { sprintf ( ( char * ) name , "EVT_chan%d" , i ) ; rc = vs_event_create ( & ev_array [ i ] , name , ( Eventset_t ) 0x00U ) ; if ( rc ) { IB_LOG_ERRORRC ( "vs_event_create failed rc:" , rc ) ; IB_EXIT ( __func__ , VSTATUS_BAD ) ; return ; } else { IB_LOG_VERBOSE ( "vs_event_created event " , i ) ; } } ( void ) memset ( gMAI_CHANNELS , 0 , sizeof ( gMAI_CHANNELS ) ) ; for ( i = 0 ; i < MAI_MAX_CHANNELS ; i ++ ) { struct mai_fd * p ; p = & gMAI_CHANNELS [ i ] ; p -> state = MAI_FREE ; p -> up_fd = i ; p -> dev = MAI_INVALID ; p -> port = MAI_INVALID ; p -> qp = MAI_INVALID ; p -> hdl_ehdl = ev_array [ i / VEVENT_NUM_EVENTS ] . event_handle ; p -> hdl_emask = ( Eventset_t ) ( 1 << ( i % VEVENT_NUM_EVENTS ) ) ; rc = vs_lock_init ( & p -> lock . lock , VLOCK_FREE , VLOCK_THREAD ) ; if ( rc ) { IB_LOG_ERRORRC ( "vs_lock_init rc:" , rc ) ; IB_EXIT ( __func__ , VSTATUS_BAD ) ; return ; } p -> state = MAI_BUSY ; ( void ) mai_free_handle ( p ) ; } ( void ) memset ( gMAI_FILTERS , 0 , sizeof ( gMAI_FILTERS ) ) ; for ( i = 0 ; i < MAI_MAX_FILTERS ; i ++ ) { struct mai_filter * p ; p = & gMAI_FILTERS [ i ] ; p -> next = NULL ; p -> next = NULL ; p -> owner = NULL ; p -> state = MAI_FREE ; p -> qp = MAI_INVALID ; p -> flags = 0 ; p -> hndl = i ; mai_free_filter ( p ) ; } IB_LOG_INFO ( "Allocating MAI MAD buffers" , gMAI_MAX_DATA ) ; IB_LOG_INFO ( "Setting max queue depth to" , gMAI_MAX_QUEUED ) ; IB_LOG_INFO ( "Total memory required is" , gMAI_MAX_DATA * sizeof ( mai_data ) ) ; gMAI_MAD_BUFFS = vs_malloc ( gMAI_MAX_DATA * sizeof ( mai_data ) ) ; if ( ! gMAI_MAD_BUFFS ) { IB_LOG_ERROR ( "Failed to allocate MAI MAD buffers:" , gMAI_MAX_DATA ) ; IB_LOG_ERROR ( "Total memory required was" , gMAI_MAX_DATA * sizeof ( mai_data ) ) ; IB_EXIT ( __func__ , VSTATUS_NOMEM ) ; return ; } ( void ) memset ( gMAI_MAD_BUFFS , 0 , gMAI_MAX_DATA * sizeof ( mai_data ) ) ; for ( i = 0 ; i < gMAI_MAX_DATA ; i ++ ) { struct mai_data * p ; p = & gMAI_MAD_BUFFS [ i ] ; mai_free_mbuff ( p ) ; } maif_init ( ) ; rc = ib_init_sma ( gMAI_MAX_DATA ) ; gMAI_INITIALIZED = 1 ; IB_EXIT ( __func__ , 0 ) ; return ; } 