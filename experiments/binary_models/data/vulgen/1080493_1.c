static int ci_set_mc_special_registers ( struct pp_hwmgr * hwmgr , struct ci_mc_reg_table * table ) { uint8_t i , j , k ; uint32_t temp_reg ; struct smu7_hwmgr * data = ( smu7_hwmgr * ) ( hwmgr -> backend ) ; for ( i = 0 , j = table -> last ; i < table -> last ; i ++ ) { PP_ASSERT_WITH_CODE ( , "Invalid VramInfo table." , ) switch ( table -> mc_reg_address [ i ] . s1 ) { case mmMC_SEQ_MISC1 : temp_reg = cgs_read_register ( hwmgr -> device , mmMC_PMG_CMD_EMRS ) ; table -> mc_reg_address [ j ] . s1 = mmMC_PMG_CMD_EMRS ; table -> mc_reg_address [ j ] . s0 = mmMC_SEQ_PMG_CMD_EMRS_LP ; for ( k = 0 ; k < table -> num_entries ; k ++ ) { table -> mc_reg_table_entry [ k ] . mc_data [ j ] = ( ( temp_reg & 0xffff0000 ) ) | ( ( table -> mc_reg_table_entry [ k ] . mc_data [ i ] & 0xffff0000 ) >> 16 ) ; } j ++ ; PP_ASSERT_WITH_CODE ( , "Invalid VramInfo table." , ) temp_reg = cgs_read_register ( hwmgr -> device , mmMC_PMG_CMD_MRS ) ; table -> mc_reg_address [ j ] . s1 = mmMC_PMG_CMD_MRS ; table -> mc_reg_address [ j ] . s0 = mmMC_SEQ_PMG_CMD_MRS_LP ; for ( k = 0 ; k < table -> num_entries ; k ++ ) { table -> mc_reg_table_entry [ k ] . mc_data [ j ] = ( temp_reg & 0xffff0000 ) | ( table -> mc_reg_table_entry [ k ] . mc_data [ i ] & 0x0000ffff ) ; if ( ! data -> is_memory_gddr5 ) { table -> mc_reg_table_entry [ k ] . mc_data [ j ] |= 0x100 ; } } j ++ ; break ; case mmMC_SEQ_RESERVE_M : temp_reg = cgs_read_register ( hwmgr -> device , mmMC_PMG_CMD_MRS1 ) ; table -> mc_reg_address [ j ] . s1 = mmMC_PMG_CMD_MRS1 ; table -> mc_reg_address [ j ] . s0 = mmMC_SEQ_PMG_CMD_MRS1_LP ; for ( k = 0 ; k < table -> num_entries ; k ++ ) { table -> mc_reg_table_entry [ k ] . mc_data [ j ] = ( temp_reg & 0xffff0000 ) | ( table -> mc_reg_table_entry [ k ] . mc_data [ i ] & 0x0000ffff ) ; } j ++ ; break ; default : break ; } } table -> last = j ; return 0 ; } 