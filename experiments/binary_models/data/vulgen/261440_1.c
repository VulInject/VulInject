static int esw_vport_enable_egress_acl ( struct mlx5_eswitch * esw , struct mlx5_vport * vport ) { int inlen = MLX5_ST_SZ_BYTES ( create_flow_group_in ) ; struct mlx5_flow_group * vlan_grp = NULL ; struct mlx5_flow_group * drop_grp = NULL ; struct mlx5_core_dev * dev = esw -> dev ; struct mlx5_flow_namespace * root_ns ; struct mlx5_flow_table * acl ; void * match_criteria ; u32 * flow_group_in ; int table_size = 2 ; int err = 0 ; if ( ! IS_ERR_OR_NULL ( vport -> egress . acl ) ) { return 0 ; } esw_debug ( dev , "Create vport[%d] egress ACL log_max_size(%d)\n" , vport -> vport , MLX5_CAP_ESW_EGRESS_ACL ( dev , log_max_ft_size ) ) ; root_ns = mlx5_get_flow_namespace ( dev , MLX5_FLOW_NAMESPACE_ESW_EGRESS ) ; if ( ! root_ns ) { esw_warn ( dev , "Failed to get E-Switch egress flow namespace\n" ) ; return - EOPNOTSUPP ; } flow_group_in = mlx5_vzalloc ( inlen ) ; if ( ! flow_group_in ) { return - ENOMEM ; } acl = mlx5_create_vport_flow_table ( root_ns , 0 , table_size , 0 , vport -> vport ) ; if ( IS_ERR ( acl ) ) { err = PTR_ERR ( acl ) ; esw_warn ( dev , "Failed to create E-Switch vport[%d] egress flow Table, err(%d)\n" , vport -> vport , err ) ; out } MLX5_SET ( create_flow_group_in , flow_group_in , match_criteria_enable , MLX5_MATCH_OUTER_HEADERS ) ; match_criteria = MLX5_ADDR_OF ( create_flow_group_in , flow_group_in , match_criteria ) ; MLX5_SET_TO_ONES ( fte_match_param , match_criteria , outer_headers . cvlan_tag ) ; MLX5_SET_TO_ONES ( fte_match_param , match_criteria , outer_headers . first_vid ) ; MLX5_SET ( create_flow_group_in , flow_group_in , start_flow_index , 0 ) ; MLX5_SET ( create_flow_group_in , flow_group_in , end_flow_index , 0 ) ; vlan_grp = mlx5_create_flow_group ( acl , flow_group_in ) ; if ( IS_ERR ( vlan_grp ) ) { err = PTR_ERR ( vlan_grp ) ; esw_warn ( dev , "Failed to create E-Switch vport[%d] egress allowed vlans flow group, err(%d)\n" , vport -> vport , err ) ; out } memset ( flow_group_in , 0 , inlen ) ; MLX5_SET ( create_flow_group_in , flow_group_in , start_flow_index , 1 ) ; MLX5_SET ( create_flow_group_in , flow_group_in , end_flow_index , 1 ) ; drop_grp = mlx5_create_flow_group ( acl , flow_group_in ) ; if ( IS_ERR ( drop_grp ) ) { err = PTR_ERR ( drop_grp ) ; esw_warn ( dev , "Failed to create E-Switch vport[%d] egress drop flow group, err(%d)\n" , vport -> vport , err ) ; out } vport -> egress . acl = acl ; vport -> egress . drop_grp = drop_grp ; vport -> egress . allowed_vlans_grp = vlan_grp ; out kvfree ( flow_group_in ) ; if ( err && ! IS_ERR_OR_NULL ( vlan_grp ) ) { mlx5_destroy_flow_group ( vlan_grp ) ; } if ( err && ! IS_ERR_OR_NULL ( acl ) ) { mlx5_destroy_flow_table ( acl ) ; } return err ; } 