lm_status_t lm_get_dev_info ( lm_device_t * pdev ) { lm_status_t lm_status = LM_STATUS_SUCCESS ; DbgMessage ( pdev , INFORMi , "### lm_get_dev_info\n" ) ; mm_memset ( pdev -> product_version , 0xff , sizeof ( pdev -> product_version ) ) ; lm_status = lm_get_pcicfg_info ( pdev ) ; if ( lm_status != LM_STATUS_SUCCESS ) { return lm_status ; } lm_status = lm_get_bars_info ( pdev ) ; if ( lm_status != LM_STATUS_SUCCESS ) { return lm_status ; } if ( ! IS_CHANNEL_VFDEV ( pdev ) ) { lm_status = lm_get_chip_id_and_mode ( pdev ) ; if ( lm_status != LM_STATUS_SUCCESS ) { return lm_status ; } } if ( IS_PFDEV ( pdev ) ) { lm_status = lm_get_function_num ( pdev ) ; if ( lm_status != LM_STATUS_SUCCESS ) { return lm_status ; } if ( lm_set_init_arrs ( pdev ) != 0 ) { DbgMessage ( pdev , FATAL , "Unknown chip revision\n" ) ; return LM_STATUS_UNKNOWN_ADAPTER ; } } else { if ( IS_VFDEV ( pdev ) ) { lm_vf_get_vf_id ( pdev ) ; } } if ( lm_is_function_after_flr ( pdev ) ) { if ( IS_PFDEV ( pdev ) ) { lm_status = lm_cleanup_after_flr ( pdev ) ; if ( lm_status != LM_STATUS_SUCCESS ) { return lm_status ; } } else { u32_t pcie_caps_offset = mm_get_cap_offset ( pdev , PCI_CAP_PCIE ) ; if ( pcie_caps_offset != 0 && pcie_caps_offset != 0xFFFFFFFF ) { u32_t dev_control_and_status = 0xFFFFFFFF ; mm_read_pci ( pdev , pcie_caps_offset + PCIE_DEV_CTRL , & dev_control_and_status ) ; DbgMessage ( pdev , FATAL , "Device Control&Status of PCIe caps is %x\n" , dev_control_and_status ) ; if ( dev_control_and_status & ( PCIE_DEV_STATUS_PENDING_TRANSACTION << 16 ) ) { DbgBreak ( ) ; } } DbgMessage ( pdev , FATAL , "Function mm_get_cap_offset is not implemented yet\n" ) ; DbgBreak ( ) ; lm_fl_reset_clear_inprogress ( pdev ) ; } } if ( IS_CHANNEL_VIRT_MODE_MASTER_PFDEV ( pdev ) ) { pdev -> params . max_eth_including_vfs_conns = 1 << ( LM_VF_MAX_RVFID_SIZE + LM_VF_CID_WND_SIZE ( pdev ) + 1 ) ; } if ( IS_PFDEV ( pdev ) ) { pdev -> params . max_eth_including_vfs_conns = MAX_VF_ETH_CONS ; if ( IS_DCB_SUPPORTED_BY_CHIP ( pdev ) ) { pdev -> params . max_eth_including_vfs_conns += 3 * MAX_HW_CHAINS + MAX_NON_RSS_CHAINS ; pdev -> params . max_eth_including_vfs_conns += MAX_ETH_CONS ; } else { pdev -> params . max_eth_including_vfs_conns += MAX_ETH_REG_CHAINS ; pdev -> params . max_eth_including_vfs_conns += MAX_ETH_REG_CONS ; } } else { pdev -> params . max_eth_including_vfs_conns = MAX_RSS_CHAINS ; } if ( IS_PFDEV ( pdev ) ) { lm_status = lm_get_sriov_info ( pdev ) ; if ( lm_status != LM_STATUS_SUCCESS ) { return lm_status ; } lm_status = lm_get_nvm_info ( pdev ) ; if ( lm_status != LM_STATUS_SUCCESS ) { return lm_status ; } lm_status = lm_get_shmem_info ( pdev ) ; if ( lm_status != LM_STATUS_SUCCESS ) { return lm_status ; } } if ( IS_CHANNEL_VFDEV ( pdev ) ) { pdev -> hw_info . mf_info . multi_vnics_mode = 0 ; pdev -> hw_info . mf_info . vnics_per_port = 1 ; pdev -> hw_info . mf_info . ext_id = 0xffff ; pdev -> hw_info . mcp_detected = FALSE ; pdev -> hw_info . chip_id = CHIP_NUM_5712E ; pdev -> hw_info . max_port_conns = log2_align ( MAX_ETH_CONS ) ; pdev -> debug_info . ack_en [ 0 ] = 1 ; } if ( IS_VFDEV ( pdev ) ) { lm_vf_enable_vf ( pdev ) ; } pdev -> ver_num = ( LM_DRIVER_MAJOR_VER << 24 ) | ( LM_DRIVER_MINOR_VER << 16 ) | ( LM_DRIVER_FIX_NUM << 8 ) | LM_DRIVER_ENG_NUM ; mm_build_ver_string ( pdev ) ; pdev -> ver_num_fw = ( BCM_5710_FW_MAJOR_VERSION << 24 ) | ( BCM_5710_FW_MINOR_VERSION << 16 ) | ( BCM_5710_FW_REVISION_VERSION << 8 ) | ( BCM_5710_FW_ENGINEERING_VERSION ) ; pdev -> params . vnics_per_port = pdev -> hw_info . mf_info . vnics_per_port ; pdev -> params . ovlan = VALID_OVLAN ( OVLAN ( pdev ) ) ?OVLAN ( pdev ) : 0 ; pdev -> params . multi_vnics_mode = pdev -> hw_info . mf_info . multi_vnics_mode ; pdev -> params . path_has_ovlan = pdev -> hw_info . mf_info . path_has_ovlan ; if ( pdev ) { lm_cmng_calc_params ( pdev ) ; } if ( IS_PFDEV ( pdev ) ) { init_link_params ( pdev ) ; } if ( IS_CHANNEL_VFDEV ( pdev ) ) { pdev -> hw_info . intr_blk_info . blk_type = INTR_BLK_IGU ; pdev -> hw_info . intr_blk_info . blk_mode = INTR_BLK_MODE_NORM ; pdev -> hw_info . intr_blk_info . access_type = INTR_BLK_ACCESS_IGUMEM ; } else { lm_status = lm_get_intr_blk_info ( pdev ) ; if ( lm_status != LM_STATUS_SUCCESS ) { return lm_status ; } } lm_status = lm_init_params ( pdev , 0 ) ; if ( lm_status != LM_STATUS_SUCCESS ) { return lm_status ; } lm_status = lm_mcp_cmd_init ( pdev ) ; if ( LM_STATUS_SUCCESS != lm_status ) { DbgMessage ( pdev , FATAL , "lm_get_shmem_info: mcp_cmd_init failed. lm_status=0x%x\n" , lm_status ) ; } if ( CHIP_PORT_MODE ( pdev ) == LM_CHIP_PORT_MODE_4 ) { if ( pdev -> params . path_has_ovlan && ! pdev -> params . multi_vnics_mode ) { DbgMessage ( pdev , WARN , "func_id = %d Setting link speed to 1000MBPS\n" , ABS_FUNC_ID ( pdev ) ) ; SET_MEDIUM_SPEED ( pdev -> params . req_medium , LM_MEDIUM_SPEED_1000MBPS ) ; } } lm_status = mm_get_user_config ( pdev ) ; if ( lm_status != LM_STATUS_SUCCESS ) { return lm_status ; } lm_status = lm_init_params ( pdev , 1 ) ; DbgMessage ( pdev , INFORMi , "### lm_get_dev_info exit\n" ) ; return LM_STATUS_SUCCESS ; } 