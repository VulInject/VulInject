int nfsrv_getstream ( struct nfssvc_sock * slp , int waitflag ) { struct mbuf * m , * * mpp ; char * cp1 , * cp2 ; int len ; struct mbuf * om , * m2 , * recm ; u_int32_t recmark ; if ( slp -> ns_flag & SLP_GETSTREAM ) { return ( 0 ) ; } slp -> ns_flag |= SLP_GETSTREAM ; for ( ; ; ) { if ( slp -> ns_reclen == 0 ) { if ( slp -> ns_cc < NFSX_UNSIGNED ) { return ( 0 ) ; } m = slp -> ns_raw ; if ( m -> m_len >= NFSX_UNSIGNED ) { bcopy ( mtod ( m , caddr_t ) , & recmark , NFSX_UNSIGNED ) ; m -> m_data += NFSX_UNSIGNED ; m -> m_len -= NFSX_UNSIGNED ; } else { cp1 = ( caddr_t ) & recmark ; cp2 = mtod ( m , caddr_t ) ; while ( cp1 < ( ( caddr_t ) & recmark ) + NFSX_UNSIGNED ) { while ( m -> m_len == 0 ) { m = m -> m_next ; cp2 = mtod ( m , caddr_t ) ; } * cp1 ++ = * cp2 ++ ; m -> m_data ++ ; m -> m_len -- ; } } slp -> ns_cc -= NFSX_UNSIGNED ; recmark = ntohl ( recmark ) ; slp -> ns_reclen = recmark & ~ 0x80000000 ; if ( recmark & 0x80000000 ) { slp -> ns_flag |= SLP_LASTFRAG ; } else { slp -> ns_flag &= ~ SLP_LASTFRAG ; } if ( slp -> ns_reclen > NFS_MAXPACKET ) { slp -> ns_flag &= ~ SLP_GETSTREAM ; return ( EPERM ) ; } } recm = NULL ; if ( slp -> ns_cc == slp -> ns_reclen ) { recm = slp -> ns_raw ; slp -> ns_raw = slp -> ns_rawend = NULL ; slp -> ns_cc = slp -> ns_reclen = 0 ; } if ( slp -> ns_cc > slp -> ns_reclen ) { len = 0 ; m = slp -> ns_raw ; om = NULL ; while ( len < slp -> ns_reclen ) { if ( ( len + m -> m_len ) > slp -> ns_reclen ) { m2 = m_copym ( m , 0 , slp -> ns_reclen - len , waitflag ) ; if ( m2 ) { if ( om ) { om -> m_next = m2 ; recm = slp -> ns_raw ; } else { recm = m2 ; } m -> m_data += slp -> ns_reclen - len ; m -> m_len -= slp -> ns_reclen - len ; len = slp -> ns_reclen ; } else { slp -> ns_flag &= ~ SLP_GETSTREAM ; return ( EWOULDBLOCK ) ; } } if ( ( len + m -> m_len ) == slp -> ns_reclen ) { om = m ; len += m -> m_len ; m = m -> m_next ; recm = slp -> ns_raw ; om -> m_next = NULL ; } else { om = m ; len += m -> m_len ; m = m -> m_next ; } } slp -> ns_raw = m ; slp -> ns_cc -= len ; slp -> ns_reclen = 0 ; } else { slp -> ns_flag &= ~ SLP_GETSTREAM ; return ( 0 ) ; } mpp = & slp -> ns_frag ; while ( * mpp ) { mpp = & ( ( * mpp ) -> m_next ) ; } * mpp = recm ; if ( slp -> ns_flag & SLP_LASTFRAG ) { if ( slp -> ns_recend ) { slp -> ns_recend -> m_nextpkt = slp -> ns_frag ; } else { slp -> ns_rec = slp -> ns_frag ; } slp -> ns_recend = slp -> ns_frag ; slp -> ns_frag = NULL ; } } } 