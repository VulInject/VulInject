NCURSES_EXPORT ( ) _nc_parse_entry ( , , ) { int token_type ; struct name_table_entry const * entry_ptr ; char * ptr , * base ; bool bad_tc_usage = FALSE ; token_type = _nc_get_token ( silent ) ; if ( token_type == EOF ) { return ( EOF ) ; } if ( token_type != NAMES ) { _nc_err_abort ( "Entry does not start with terminal names in column one" ) ; } _nc_init_entry ( & entryp -> tterm ) ; entryp -> cstart = _nc_comment_start ; entryp -> cend = _nc_comment_end ; entryp -> startline = _nc_start_line ; DEBUG ( 2 , ( "Comment range is %ld to %ld" , entryp -> cstart , entryp -> cend ) ) ; ptr = _nc_curr_token . tk_name ; if ( _nc_syntax == SYN_TERMCAP && ! _nc_user_definable ) { if ( ptr [ 2 ] == '|' ) { ptr += 3 ; _nc_curr_token . tk_name [ 2 ] = '\0' ; } } entryp -> tterm . str_table = entryp -> tterm . term_names = _nc_save_str ( ptr ) ; if ( entryp -> tterm . str_table == 0 ) { return ( ERR ) ; } DEBUG ( 1 , ( "Starting '%s'" , ptr ) ) ; _nc_set_type ( _nc_first_name ( entryp -> tterm . term_names ) ) ; for ( base = entryp -> tterm . term_names ; ( ptr = strchr ( base , '|' ) ) != 0 ; base = ptr + 1 ) { if ( ptr - base > MAX_ALIAS ) { _nc_warning ( "%s `%.*s' may be too long" , ( base == entryp -> tterm . term_names ) ?"primary name" : "alias" , ( int ) ( ptr - base ) , base ) ; } } entryp -> nuses = 0 ; for ( token_type = _nc_get_token ( silent ) ; token_type != EOF && token_type != NAMES ; token_type = _nc_get_token ( silent ) ) { bool is_use = ( strcmp ( _nc_curr_token . tk_name , "use" ) == 0 ) ; bool is_tc = ! is_use && ( strcmp ( _nc_curr_token . tk_name , "tc" ) == 0 ) ; if ( is_use || is_tc ) { entryp -> uses [ entryp -> nuses ] . name = _nc_save_str ( _nc_curr_token . tk_valstring ) ; entryp -> uses [ entryp -> nuses ] . line = _nc_curr_line ; entryp -> nuses ++ ; if ( entryp -> nuses > 1 && is_tc ) { BAD_TC_USAGE ; } } else { entry_ptr = _nc_find_entry ( _nc_curr_token . tk_name , _nc_get_hash_table ( _nc_syntax ) ) ; if ( entry_ptr == NOTFOUND ) { const struct alias * ap ; if ( _nc_syntax == SYN_TERMCAP ) { if ( entryp -> nuses != 0 ) { BAD_TC_USAGE ; } for ( ap = _nc_get_alias_table ( TRUE ) ; ap -> from ; ap ++ ) { if ( strcmp ( ap -> from , _nc_curr_token . tk_name ) == 0 ) { if ( ap -> to == ( char * ) 0 ) { _nc_warning ( "%s (%s termcap extension) ignored" , ap -> from , ap -> source ) ; nexttok } entry_ptr = _nc_find_entry ( ap -> to , _nc_get_hash_table ( TRUE ) ) ; if ( entry_ptr && ! silent ) { _nc_warning ( "%s (%s termcap extension) aliased to %s" , ap -> from , ap -> source , ap -> to ) ; } break ; } } } else { for ( ap = _nc_get_alias_table ( FALSE ) ; ap -> from ; ap ++ ) { if ( strcmp ( ap -> from , _nc_curr_token . tk_name ) == 0 ) { if ( ap -> to == ( char * ) 0 ) { _nc_warning ( "%s (%s terminfo extension) ignored" , ap -> from , ap -> source ) ; nexttok } entry_ptr = _nc_find_entry ( ap -> to , _nc_get_hash_table ( FALSE ) ) ; if ( entry_ptr && ! silent ) { _nc_warning ( "%s (%s terminfo extension) aliased to %s" , ap -> from , ap -> source , ap -> to ) ; } break ; } } if ( entry_ptr == NOTFOUND ) { entry_ptr = lookup_fullname ( _nc_curr_token . tk_name ) ; } } } if ( entry_ptr == NOTFOUND && _nc_user_definable && ( entry_ptr = _nc_extend_names ( entryp , _nc_curr_token . tk_name , token_type ) ) != 0 ) { if ( _nc_tracing >= DEBUG_LEVEL ( 1 ) ) { _nc_warning ( "extended capability '%s'" , _nc_curr_token . tk_name ) ; } } if ( entry_ptr == NOTFOUND ) { if ( ! silent ) { _nc_warning ( "unknown capability '%s'" , _nc_curr_token . tk_name ) ; } continue ; } if ( token_type != CANCEL && entry_ptr -> nte_type != token_type ) { if ( token_type == NUMBER && ! strcmp ( "ma" , _nc_curr_token . tk_name ) ) { entry_ptr = _nc_find_type_entry ( "ma" , NUMBER , _nc_get_table ( _nc_syntax != 0 ) ) ; assert ( entry_ptr != 0 ) ; } if ( token_type == STRING && ! strcmp ( "MT" , _nc_curr_token . tk_name ) ) { entry_ptr = _nc_find_type_entry ( "MT" , STRING , _nc_get_table ( _nc_syntax != 0 ) ) ; assert ( entry_ptr != 0 ) ; } if ( token_type == BOOLEAN && entry_ptr -> nte_type == STRING ) { token_type = STRING ; } else { if ( ! silent ) { const char * type_name ; switch ( entry_ptr -> nte_type ) { case BOOLEAN : type_name = "boolean" ; break ; case STRING : type_name = "string" ; break ; case NUMBER : type_name = "numeric" ; break ; default : type_name = "unknown" ; break ; } _nc_warning ( "wrong type used for %s capability '%s'" , type_name , _nc_curr_token . tk_name ) ; } continue ; } } switch ( token_type ) { case CANCEL : switch ( entry_ptr -> nte_type ) { case BOOLEAN : entryp -> tterm . Booleans [ entry_ptr -> nte_index ] = CANCELLED_BOOLEAN ; break ; case NUMBER : entryp -> tterm . Numbers [ entry_ptr -> nte_index ] = CANCELLED_NUMERIC ; break ; case STRING : entryp -> tterm . Strings [ entry_ptr -> nte_index ] = CANCELLED_STRING ; break ; } break ; case BOOLEAN : entryp -> tterm . Booleans [ entry_ptr -> nte_index ] = TRUE ; break ; case NUMBER : entryp -> tterm . Numbers [ entry_ptr -> nte_index ] = _nc_curr_token . tk_valnumber ; break ; case STRING : ptr = _nc_curr_token . tk_valstring ; entryp -> tterm . Strings [ entry_ptr -> nte_index ] = _nc_save_str ( ptr ) ; break ; default : if ( ! silent ) { _nc_warning ( "unknown token type" ) ; } _nc_panic_mode ( ( char ) ( ( _nc_syntax == SYN_TERMCAP ) ?':' : ',' ) ) ; continue ; } } nexttok continue ; } _nc_push_token ( token_type ) ; _nc_set_type ( _nc_first_name ( entryp -> tterm . term_names ) ) ; if ( ! literal ) { if ( _nc_syntax == SYN_TERMCAP ) { bool has_base_entry = FALSE ; unsigned i ; if ( strchr ( entryp -> tterm . term_names , '+' ) ) { has_base_entry = TRUE ; } else { for ( i = 0 ; i < entryp -> nuses ; i ++ ) { if ( ! strchr ( ( char * ) entryp -> uses [ i ] . name , '+' ) ) { has_base_entry = TRUE ; } } } postprocess_termcap ( & entryp -> tterm , has_base_entry ) ; } else { postprocess_terminfo ( & entryp -> tterm ) ; } } _nc_wrap_entry ( entryp , FALSE ) ; return ( OK ) ; } 