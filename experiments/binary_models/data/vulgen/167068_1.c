static void evpn_show_route_rd ( struct vty * vty , struct bgp * bgp , struct prefix_rd * prd , int type , json_object * json ) { struct bgp_dest * rd_dest ; struct bgp_table * table ; struct bgp_dest * dest ; struct bgp_path_info * pi ; int rd_header = 1 ; afi_t afi ; safi_t safi ; uint32_t prefix_cnt , path_cnt ; json_object * json_rd = NULL ; int add_rd_to_json = 0 ; afi = AFI_L2VPN ; safi = SAFI_EVPN ; prefix_cnt = path_cnt = 0 ; rd_dest = bgp_node_lookup ( bgp -> rib [ afi ] [ safi ] , ( prefix * ) prd ) ; if ( ! rd_dest ) { return ; } table = bgp_dest_get_bgp_table_info ( rd_dest ) ; if ( json ) { json_rd = json_object_new_object ( ) ; json_object_string_addf ( json_rd , "rd" , BGP_RD_AS_FORMAT ( bgp -> asnotation ) , prd ) ; } bgp_dest_unlock_node ( rd_dest ) ; for ( dest = bgp_table_top ( table ) ; dest ; dest = bgp_route_next ( dest ) ) { const struct prefix_evpn * evp = ( const prefix_evpn * ) bgp_dest_get_prefix ( dest ) ; json_object * json_prefix = NULL ; json_object * json_paths = NULL ; int add_prefix_to_json = 0 ; if ( type && evp -> prefix . route_type != type ) { continue ; } if ( json ) { json_prefix = json_object_new_object ( ) ; } pi = bgp_dest_get_bgp_path_info ( dest ) ; if ( pi ) { if ( rd_header && ! json ) { vty_out ( vty , "EVPN type-1 prefix: [1]:[EthTag]:[ESI]:[IPlen]:[VTEP-IP]:[Frag-id]\n" ) ; vty_out ( vty , "EVPN type-2 prefix: [2]:[EthTag]:[MAClen]:[MAC]\n" ) ; vty_out ( vty , "EVPN type-3 prefix: [3]:[EthTag]:[IPlen]:[OrigIP]\n" ) ; vty_out ( vty , "EVPN type-4 prefix: [4]:[ESI]:[IPlen]:[OrigIP]\n" ) ; vty_out ( vty , "EVPN type-5 prefix: [5]:[EthTag]:[IPlen]:[IP]\n\n" ) ; rd_header = 0 ; } route_vty_out_detail_header ( vty , bgp , dest , bgp_dest_get_prefix ( dest ) , prd , afi , safi , json_prefix , false ) ; prefix_cnt ++ ; } if ( json ) { json_paths = json_object_new_array ( ) ; } for ( ; pi ; pi = pi -> next ) { json_object * json_path = NULL ; if ( json ) { json_path = json_object_new_array ( ) ; } route_vty_out_detail ( vty , bgp , dest , bgp_dest_get_prefix ( dest ) , pi , afi , safi , RPKI_NOT_BEING_USED , json_path ) ; if ( json ) { json_object_array_add ( json_paths , json_path ) ; } path_cnt ++ ; add_prefix_to_json = 1 ; add_rd_to_json = 1 ; } if ( json ) { if ( add_prefix_to_json ) { json_object_object_add ( json_prefix , "paths" , json_paths ) ; json_object_object_addf ( json_rd , json_prefix , "%pFX" , evp ) ; } else { json_object_free ( json_paths ) ; json_object_free ( json_prefix ) ; json_paths = NULL ; json_prefix = NULL ; } } } if ( json ) { if ( add_rd_to_json ) { json_object_object_addf ( json , json_rd , BGP_RD_AS_FORMAT ( bgp -> asnotation ) , prd ) ; } else { json_object_free ( json_rd ) ; json_rd = NULL ; } json_object_int_add ( json , "numPrefix" , prefix_cnt ) ; json_object_int_add ( json , "numPaths" , path_cnt ) ; } else { if ( prefix_cnt == 0 ) { vty_out ( vty , "No prefixes exist with this RD%s\n" , type ?" (of requested type)" : "" ) ; } else { vty_out ( vty , "\nDisplayed %u prefixes (%u paths) with this RD%s\n" , prefix_cnt , path_cnt , type ?" (of requested type)" : "" ) ; } } } 