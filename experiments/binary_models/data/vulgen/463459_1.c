( ( ( ( x ) & 0xfe000000 ) == 0x00000000 ) || ( ( ( x ) & 0xfe000000 ) == 0xfe000000 ) ) void _dl_bind_start ( void ) ; Elf_Addr _dl_bind ( elf_object_t * object , int reloff ) int _dl_md_reloc ( elf_object_t * object , int rel , int relasz ) { int i ; int numrela ; long relrel ; int fails = 0 ; Elf_Addr loff ; Elf_RelA * relas ; Elf_Addr prev_value = 0 , prev_ooff = 0 ; const Elf_Sym * prev_sym = NULL ; loff = object -> obj_base ; numrela = object -> Dyn . info [ relasz ] / sizeof ( Elf_RelA ) ; relrel = rel == DT_RELA ?object -> relacount : 0 ; relas = ( Elf_RelA * ) ( object -> Dyn . info [ rel ] ) ; if ( relas == NULL ) { return 0 ; } if ( relrel > numrela ) { _dl_die ( "relcount>numrel: %ld>%d" , relrel , numrela ) ; } for ( i = 0 ; i < relrel ; i ++ , relas ++ ) { Elf_Addr * r_addr ; r_addr = ( Elf_Addr * ) ( relas -> r_offset + loff ) ; * r_addr = loff + relas -> r_addend ; } for ( ; i < numrela ; i ++ , relas ++ ) { Elf_Addr * r_addr = ( Elf_Addr * ) ( relas -> r_offset + loff ) ; const Elf_Sym * sym ; const char * symn ; int type ; if ( ELF_R_SYM ( relas -> r_info ) == 0xffffff ) { continue ; } type = ELF_R_TYPE ( relas -> r_info ) ; if ( type == R_PPC64_JMP_SLOT && rel != DT_JMPREL ) { continue ; } sym = object -> dyn . symtab ; sym += ELF_R_SYM ( relas -> r_info ) ; symn = object -> dyn . strtab + sym -> st_name ; if ( ELF_R_SYM ( relas -> r_info ) && ! ( ELF_ST_BIND ( sym -> st_info ) == STB_LOCAL && ELF_ST_TYPE ( sym -> st_info ) == STT_NOTYPE ) && sym != prev_sym ) { struct sym_res sr ; sr = _dl_find_symbol ( symn , SYM_SEARCH_ALL | SYM_WARNNOTFOUND | ( ( type == R_PPC64_JMP_SLOT ) ?SYM_PLT : SYM_NOTPLT ) , sym , object ) ; if ( sr . sym == NULL ) { if ( ELF_ST_BIND ( sym -> st_info ) != STB_WEAK ) { fails ++ ; } continue ; } prev_sym = sym ; prev_value = sr . sym -> st_value ; prev_ooff = sr . obj -> obj_base ; } switch ( type ) { case R_PPC64_ADDR64 : if ( ELF_ST_BIND ( sym -> st_info ) == STB_LOCAL && ( ELF_ST_TYPE ( sym -> st_info ) == STT_SECTION || ELF_ST_TYPE ( sym -> st_info ) == STT_NOTYPE ) ) { * r_addr = prev_ooff + relas -> r_addend ; } else { * r_addr = prev_ooff + prev_value + relas -> r_addend ; } break ; case R_PPC64_RELATIVE : if ( ELF_ST_BIND ( sym -> st_info ) == STB_LOCAL && ( ELF_ST_TYPE ( sym -> st_info ) == STT_SECTION || ELF_ST_TYPE ( sym -> st_info ) == STT_NOTYPE ) ) { * r_addr = loff + relas -> r_addend ; } else { * r_addr = loff + prev_value + relas -> r_addend ; } break ; case R_PPC64_JMP_SLOT : case R_PPC64_GLOB_DAT : * r_addr = prev_ooff + prev_value + relas -> r_addend ; break ; case RELOC_REL24 : { Elf_Addr val = prev_ooff + prev_value + relas -> r_addend - ( Elf_Addr ) r_addr ; if ( ! B24_VALID_RANGE ( val ) ) { _dl_die ( "%s: invalid %s offset %llx at %p" , object -> load_name , "REL24" , val , ( void * ) r_addr ) ; } val &= ~ 0xfc000003 ; val |= ( * r_addr & 0xfc000003 ) ; * r_addr = val ; _dl_dcbf ( r_addr ) ; } break ; case RELOC_16_LO : { Elf_Addr val ; val = loff + relas -> r_addend ; * ( Elf_Half * ) r_addr = val ; _dl_dcbf ( r_addr ) ; } break ; case RELOC_16_HI : { Elf_Addr val ; val = loff + relas -> r_addend ; * ( Elf_Half * ) r_addr = ( val >> 16 ) ; _dl_dcbf ( r_addr ) ; } break ; case RELOC_16_HA : { Elf_Addr val ; val = loff + relas -> r_addend ; * ( Elf_Half * ) r_addr = ( ( val + 0x8000 ) >> 16 ) ; _dl_dcbf ( r_addr ) ; } break ; case RELOC_REL14_TAKEN : case RELOC_REL14 : case RELOC_REL14_NTAKEN : { Elf_Addr val = prev_ooff + prev_value + relas -> r_addend - ( Elf_Addr ) r_addr ; if ( ( ( val & 0xffff8000 ) != 0 ) && ( ( val & 0xffff8000 ) != 0xffff8000 ) ) { _dl_die ( "%s: invalid %s offset %llx at %p" , object -> load_name , "REL14" , val , ( void * ) r_addr ) ; } val &= ~ 0xffff0003 ; val |= ( * r_addr & 0xffff0003 ) ; * r_addr = val ; _dl_dcbf ( r_addr ) ; } break ; case R_PPC64_COPY : { struct sym_res sr ; sr = _dl_find_symbol ( symn , SYM_SEARCH_OTHER | SYM_WARNNOTFOUND | SYM_NOTPLT , sym , object ) ; if ( sr . sym != NULL ) { _dl_bcopy ( ( void * ) ( sr . obj -> obj_base + sr . sym -> st_value ) , r_addr , sym -> st_size ) ; } else { fails ++ ; } } break ; case R_PPC64_NONE : break ; default : _dl_die ( "%s: unsupported relocation '%s' %lld at %p\n" , object -> load_name , symn , ELF_R_TYPE ( relas -> r_info ) , ( void * ) r_addr ) ; } } return fails ; } 