static ssize_t uhid_char_write ( struct file * file , const char __user * buffer , size_t count , loff_t * ppos ) { struct uhid_device * uhid = file -> private_data ; int ret ; size_t len ; if ( count < sizeof ( __u32 ) ) { return - EINVAL ; } ret = mutex_lock_interruptible ( & uhid -> devlock ) ; if ( ret ) { return ret ; } len = min ( count , sizeof ( uhid -> input_buf ) ) ; ret = uhid_event_from_user ( buffer , len , & uhid -> input_buf ) ; if ( ret ) { unlock } switch ( uhid -> input_buf . type ) { case UHID_CREATE : if ( file -> f_cred != current_cred ( ) ) { pr_err_once ( "UHID_CREATE from different security context by process %d (%s), this is not allowed.\n" , task_tgid_vnr ( current ) , current -> comm ) ; ret = - EACCES ; unlock } ret = uhid_dev_create ( uhid , & uhid -> input_buf ) ; break ; case UHID_CREATE2 : ret = uhid_dev_create2 ( uhid , & uhid -> input_buf ) ; break ; case UHID_DESTROY : ret = uhid_dev_destroy ( uhid ) ; break ; case UHID_INPUT : ret = uhid_dev_input ( uhid , & uhid -> input_buf ) ; break ; case UHID_INPUT2 : ret = uhid_dev_input2 ( uhid , & uhid -> input_buf ) ; break ; case UHID_GET_REPORT_REPLY : ret = uhid_dev_get_report_reply ( uhid , & uhid -> input_buf ) ; break ; case UHID_SET_REPORT_REPLY : ret = uhid_dev_set_report_reply ( uhid , & uhid -> input_buf ) ; break ; default : ret = - EOPNOTSUPP ; } unlock mutex_unlock ( & uhid -> devlock ) ; return ret ?ret : count ; } 