MODULE_DESCRIPTION ( "Finite state machine helper functions" ) ; MODULE_LICENSE ( "GPL" ) ; fsm_instance * init_fsm ( char * name , const char * * state_names , const char * * event_names , int nr_states , int nr_events , const fsm_node * tmpl , int tmpl_len , gfp_t order ) { int i ; fsm_instance * this ; fsm_function_t * m ; fsm * f ; this = kzalloc ( sizeof ( fsm_instance ) , order ) ; if ( this == NULL ) { printk ( KERN_WARNING "fsm(%s): init_fsm: Couldn't alloc instance\n" , name ) ; return NULL ; } strscpy ( this -> name , name , sizeof ( this -> name ) ) ; init_waitqueue_head ( & this -> wait_q ) ; f = kzalloc ( sizeof ( fsm ) , order ) ; if ( f == NULL ) { printk ( KERN_WARNING "fsm(%s): init_fsm: Couldn't alloc fsm\n" , name ) ; return NULL ; } f -> nr_events = nr_events ; f -> nr_states = nr_states ; f -> event_names = event_names ; f -> state_names = state_names ; this -> f = f ; m = kcalloc ( nr_states * nr_events , sizeof ( fsm_function_t ) , order ) ; if ( m == NULL ) { printk ( KERN_WARNING "fsm(%s): init_fsm: Couldn't alloc jumptable\n" , name ) ; kfree_fsm ( this ) ; return NULL ; } f -> jumpmatrix = m ; for ( i = 0 ; i < tmpl_len ; i ++ ) { if ( ( tmpl [ i ] . cond_state >= nr_states ) || ( tmpl [ i ] . cond_event >= nr_events ) ) { printk ( KERN_ERR "fsm(%s): init_fsm: Bad template l=%d st(%ld/%ld) ev(%ld/%ld)\n" , name , i , ( long ) tmpl [ i ] . cond_state , ( long ) f -> nr_states , ( long ) tmpl [ i ] . cond_event , ( long ) f -> nr_events ) ; kfree_fsm ( this ) ; return NULL ; } else { m [ nr_states * tmpl [ i ] . cond_event + tmpl [ i ] . cond_state ] = tmpl [ i ] . function ; } } return this ; } 