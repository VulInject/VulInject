void add_out_pool ( StrNumber_T p_str ) BEGIN BufPointer_T break_ptr ; BufPointer_T end_ptr ; Boolean_T break_pt_found ; Boolean_T unbreakable_tail ; p_ptr1 = str_start [ p_str ] p_ptr2 = str_start [ p_str + 1 ] ; END out_buf_ptr = out_buf_length ; while ( p_ptr1 < p_ptr2 ) { BEGIN out_buf [ out_buf_ptr ] str_pool [ p_ptr1 ] ; ; } INCR ( p_ptr1 ) ; INCR ( out_buf_ptr ) ; END out_buf_length = out_buf_ptr ; unbreakable_tail = FALSE ; while ( ( out_buf_length > MAX_PRINT_LINE ) && ! unbreakable_tail ) { BEGIN end_ptr = out_buf_length ; } out_buf_ptr = MAX_PRINT_LINE ; break_pt_found = FALSE ; while ( ( lex_class [ out_buf [ out_buf_ptr ] ] != WHITE_SPACE ) && ( out_buf_ptr >= MIN_PRINT_LINE ) ) { BEGIN DECR ( out_buf_ptr ) } END if ( out_buf_ptr == ( MIN_PRINT_LINE - 1 ) ) { BEGIN out_buf_ptr = MAX_PRINT_LINE + 1 ; } while ( out_buf_ptr < end_ptr ) { BEGIN if ( lex_class [ out_buf [ out_buf_ptr ] ] == WHITE_SPACE ) { BEGIN UChar32 ch ; } } U8_GET_OR_FFFD ( out_buf , out_buf_ptr - 4 , out_buf_ptr - 1 , - 1 , ch ) ; switch ( ublock_getCode ( ch ) ) { BEGIN case UBLOCK_BASIC_LATIN : case UBLOCK_LATIN_1_SUPPLEMENT : case UBLOCK_LATIN_EXTENDED_A : case UBLOCK_LATIN_EXTENDED_B : case UBLOCK_LATIN_EXTENDED_C : case UBLOCK_LATIN_EXTENDED_D : case UBLOCK_LATIN_EXTENDED_E : case UBLOCK_LATIN_EXTENDED_F : case UBLOCK_LATIN_EXTENDED_G : case UBLOCK_LATIN_EXTENDED_ADDITIONAL : case UBLOCK_GREEK : case UBLOCK_GREEK_EXTENDED : case UBLOCK_CYRILLIC : case UBLOCK_CYRILLIC_SUPPLEMENT : case UBLOCK_CYRILLIC_EXTENDED_A : case UBLOCK_CYRILLIC_EXTENDED_B : case UBLOCK_CYRILLIC_EXTENDED_C : case UBLOCK_HANGUL_SYLLABLES : Loop1_Exit } break ; END END INCR ( out_buf_ptr ) if ( lex_class [ out_buf [ out_buf_ptr ] ] != WHITE_SPACE ) { BEGIN INCR ( out_buf_ptr ) } END else { BEGIN Loop1_Exit } END END Loop1_Exit ; if ( out_buf_ptr == end_ptr ) { BEGIN unbreakable_tail = TRUE ; } END else { BEGIN break_pt_found = TRUE ; } while ( out_buf_ptr + 1 < end_ptr ) { BEGIN if ( lex_class [ out_buf [ out_buf_ptr + 1 ] ] == WHITE_SPACE ) { BEGIN INCR ( out_buf_ptr ) } } END else { BEGIN Loop2_Exit } END END Loop2_Exit DO_NOTHING ; END END BEGIN break_pt_found = TRUE ; END if ( break_pt_found ) { BEGIN out_buf_length = out_buf_ptr ; } break_ptr = out_buf_length + 1 ; output_bbl_line ( ) ; out_buf [ 0 ] = SPACE ; out_buf [ 1 ] = SPACE ; out_buf_ptr = 2 ; tmp_ptr = break_ptr ; while ( tmp_ptr < end_ptr ) { BEGIN out_buf [ out_buf_ptr ] out_buf [ tmp_ptr ] ; ; } INCR ( out_buf_ptr ) ; INCR ( tmp_ptr ) ; END out_buf_length = end_ptr - break_ptr + 2 ; END END END void add_pool_buf_and_push ( void ) BEGIN STR_ROOM ( ex_buf_length ) ; ex_buf_ptr = 0 ; while ( ex_buf_ptr < ex_buf_length ) { BEGIN APPEND_CHAR ( ex_buf [ ex_buf_ptr ] ) } INCR ( ex_buf_ptr ) ; END push_lit_stk ( make_string ( ) , STK_STR ) ; END void already_seen_function_print ( HashLoc_T seen_fn_loc ) BEGIN PRINT_POOL_STR ( hash_text [ seen_fn_loc ] ) ; PRINT ( " is already a type \"" ) ; print_fn_class ( seen_fn_loc ) ; PRINT_LN ( "\" function name" ) ; BST_ERR_PRINT_AND_LOOK_FOR_BLAN ; Exit_Label DO_NOTHING ; END void aux_bib_data_command ( void ) BEGIN ( bib_seen ) BEGIN AUX_ERR_ILLEGAL_ANOTHER ( N_AUX_BIBDATA ) ; END bib_seen = TRUE ; while ( SCAN_CHAR != RIGHT_BRACE ) { BEGIN INCR ( buf_ptr2 ) } if ( ! scan2_white ( RIGHT_BRACE , COMMA ) ) { BEGIN AUX_ERR_NO_RIGHT_BRACE ; } END if ( lex_class [ SCAN_CHAR ] == WHITE_SPACE ) { BEGIN AUX_ERR_WHITE_SPACE_IN_ARGUMENT ; } END if ( ( last > ( buf_ptr2 + 1 ) ) && ( SCAN_CHAR == RIGHT_BRACE ) ) { BEGIN AUX_ERR_STUFF_AFTER_RIGHT_BRACE ; } END BEGIN ( bib_ptr == Max_Bib_Files ) BEGIN BIB_XRETALLOC_NOSET ( "bib_file" , bib_file , AlphaFile_T , Max_Bib_Files , Max_Bib_Files + MAX_BIB_FILES ) ; BIB_XRETALLOC_NOSET ( "bib_list" , bib_list , StrNumber_T , Max_Bib_Files , Max_Bib_Files + MAX_BIB_FILES ) ; BIB_XRETALLOC ( "s_preamble" , s_preamble , StrNumber_T , Max_Bib_Files , Max_Bib_Files + MAX_BIB_FILES ) ; END CUR_BIB_STR = hash_text [ str_lookup ( buffer , buf_ptr1 , TOKEN_LEN , BIB_FILE_ILK , DO_INSERT ) ] ; if ( hash_found ) { BEGIN OPEN_BIBDATA_AUX_ERR ( "This database file appears more than once: " ) ; } END start_name ( CUR_BIB_STR ) add_extension ( s_bib_extension ) ; if ( ! a_open_in ( & CUR_BIB_FILE , BIB_FILE_SEARCH_PATH ) ) { BEGIN BEGIN OPEN_BIBDATA_AUX_ERR ( "I couldn't open database file " ) ; } perror ( "\nReason" ) ; END END ( Flag_trace ) ( TRACE_PR_POOL_STR ( CUR_BIB_STR ) , TRACE_PR_POOL_STR ( s_bib_extension ) , TRACE_PR_LN ( " is a bibdata file" ) ) INCR ( bib_ptr ) ; END END Exit_Label DO_NOTHING ; END void aux_bib_style_command ( void ) BEGIN ( bst_seen ) BEGIN AUX_ERR_ILLEGAL_ANOTHER ( N_AUX_BIBSTYLE ) ; END bst_seen = TRUE ; INCR ( buf_ptr2 ) ; if ( ! scan1_white ( RIGHT_BRACE ) ) { BEGIN AUX_ERR_NO_RIGHT_BRACE ; } END if ( lex_class [ SCAN_CHAR ] == WHITE_SPACE ) { BEGIN AUX_ERR_WHITE_SPACE_IN_ARGUMENT ; } END if ( last > ( buf_ptr2 + 1 ) ) { BEGIN AUX_ERR_STUFF_AFTER_RIGHT_BRACE ; } END BEGIN bst_str = hash_text [ str_lookup ( buffer , buf_ptr1 , TOKEN_LEN , BST_FILE_ILK , DO_INSERT ) ] ; if ( hash_found ) { BEGIN if ( Flag_trace ) { print_bst_name ( ) ; } } CONFUSION ( "Already encountered style file" ) ; END start_name ( bst_str ) add_extension ( s_bst_extension ) ; if ( ! a_open_in ( & bst_file , BST_FILE_SEARCH_PATH ) ) { BEGIN BEGIN PRINT ( "I couldn't open style file " ) ; } print_bst_name ( ) ; perror ( "\nReason" ) ; bst_str = 0 ; AUX_ERR_RETURN ; END END PRINT ( "The style file: " ) ; print_bst_name ( ) ; END Exit_Label DO_NOTHING ; END void aux_citation_command ( void ) BEGIN citation_seen ; while ( SCAN_CHAR != RIGHT_BRACE ) { BEGIN INCR ( buf_ptr2 ) } if ( ! scan2_white ( RIGHT_BRACE , COMMA ) ) { BEGIN AUX_ERR_NO_RIGHT_BRACE ; } END if ( lex_class [ SCAN_CHAR ] == WHITE_SPACE ) { BEGIN AUX_ERR_WHITE_SPACE_IN_ARGUMENT ; } END if ( ( last > ( buf_ptr2 + 1 ) ) && ( SCAN_CHAR == RIGHT_BRACE ) ) { BEGIN AUX_ERR_STUFF_AFTER_RIGHT_BRACE ; } END BEGIN ( Flag_trace ) ( TRACE_PR_TOKEN , TRACE_PR ( " cite key encountered" ) ) BEGIN ( TOKEN_LEN == 1 ) BEGIN ( buffer [ buf_ptr1 ] == STAR ) BEGIN ( Flag_trace ) TRACE_PR_LN ( "---entire database to be included" ) ; if ( all_entries ) { BEGIN PRINT_LN ( "Multiple inclusions of entire database" ) ; } AUX_ERR_RETURN ; END else { BEGIN all_entries = TRUE ; } all_marker = cite_ptr ; Next_Cite_Label END END END END tmp_ptr = buf_ptr1 ; while ( tmp_ptr < buf_ptr2 ) { BEGIN ex_buf [ tmp_ptr ] buffer [ tmp_ptr ] ; ; } INCR ( tmp_ptr ) ; END lower_case ( ex_buf , buf_ptr1 , TOKEN_LEN ) 