List * find_inheritance_children_extended ( Oid parentrelId , bool omit_detached , LOCKMODE lockmode , bool * detached_exist , TransactionId * detached_xmin ) { List * list = NIL ; Relation relation ; SysScanDesc scan ; ScanKeyData key [ 1 ] ; HeapTuple inheritsTuple ; Oid inhrelid ; Oid * oidarr ; int maxoids , numoids , i ; maxoids = 32 ; oidarr = ( Oid * ) palloc ( maxoids * sizeof ( Oid ) ) ; numoids = 0 ; relation = table_open ( InheritsRelationId , AccessShareLock ) ; ScanKeyInit ( & key [ 0 ] , Anum_pg_inherits_inhparent , BTEqualStrategyNumber , F_OIDEQ , ObjectIdGetDatum ( parentrelId ) ) ; scan = systable_beginscan ( relation , InheritsParentIndexId , true , NULL , 1 , key ) ; while ( ( inheritsTuple = systable_getnext ( scan ) ) != NULL ) { if ( ( ( Form_pg_inherits ) GETSTRUCT ( inheritsTuple ) ) -> inhdetachpending ) { if ( detached_exist ) { * detached_exist = true ; } if ( omit_detached && ActiveSnapshotSet ( ) ) { TransactionId xmin ; Snapshot snap ; xmin = HeapTupleHeaderGetXmin ( inheritsTuple -> t_data ) ; snap = GetActiveSnapshot ( ) ; if ( ! XidInMVCCSnapshot ( xmin , snap ) ) { if ( detached_xmin ) { if ( * detached_xmin != InvalidTransactionId ) { elog ( WARNING , "more than one partition pending detach found for table with OID %u" , parentrelId ) ; if ( TransactionIdFollows ( xmin , * detached_xmin ) ) { * detached_xmin = xmin ; } } else { * detached_xmin = xmin ; } } continue ; } } } inhrelid = ( ( Form_pg_inherits ) GETSTRUCT ( inheritsTuple ) ) -> inhrelid ; if ( numoids >= maxoids ) { maxoids *= 2 ; oidarr = ( Oid * ) repalloc ( oidarr , maxoids * sizeof ( Oid ) ) ; } oidarr [ numoids ++ ] = inhrelid ; } systable_endscan ( scan ) ; table_close ( relation , AccessShareLock ) ; if ( numoids > 1 ) { qsort ( oidarr , numoids , sizeof ( Oid ) , oid_cmp ) ; } for ( i = 0 ; i < numoids ; i ++ ) { inhrelid = oidarr [ i ] ; if ( lockmode != NoLock ) { LockRelationOid ( inhrelid , lockmode ) ; if ( ! SearchSysCacheExists1 ( RELOID , ObjectIdGetDatum ( inhrelid ) ) ) { UnlockRelationOid ( inhrelid , lockmode ) ; continue ; } } list = lappend_oid ( list , inhrelid ) ; } pfree ( oidarr ) ; return list ; } 