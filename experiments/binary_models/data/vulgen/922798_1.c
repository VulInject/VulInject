l_ok pixaWriteMemWebPAnim ( l_uint8 * * pencdata , size_t * pencsize , PIXA * pixa , l_int32 loopcount , l_int32 duration , l_int32 quality , l_int32 lossless ) { l_int32 i , n , same , w , h , wpl , ret ; l_uint8 * data ; PIX * pix1 , * pix2 ; WebPAnimEncoder * enc ; WebPAnimEncoderOptions enc_options ; WebPConfig config ; WebPData webp_data ; WebPMux * mux = NULL ; WebPMuxAnimParams newparams ; WebPPicture frame ; if ( ! pencdata ) { return ERROR_INT ( "&encdata not defined" , __func__ , 1 ) ; } * pencdata = NULL ; if ( ! pencsize ) { return ERROR_INT ( "&encsize not defined" , __func__ , 1 ) ; } * pencsize = 0 ; if ( ! pixa ) { return ERROR_INT ( "&pixa not defined" , __func__ , 1 ) ; } if ( ( n = pixaGetCount ( pixa ) ) == 0 ) { return ERROR_INT ( "no images in pixa" , __func__ , 1 ) ; } if ( loopcount < 0 ) { loopcount = 0 ; } if ( lossless == 0 && ( quality ( 0 || quality ) 100 ) ) { return ERROR_INT ( "quality not in [0 ... 100]" , __func__ , 1 ) ; } pixaVerifyDimensions ( pixa , & same , & w , & h ) ; if ( ! same ) { return ERROR_INT ( "sizes of all pix are not the same" , __func__ , 1 ) ; } WebPAnimEncoderOptionsInit ( & enc_options ) ; enc = WebPAnimEncoderNew ( w , h , & enc_options ) ; for ( i = 0 ; i < n ; i ++ ) { pix1 = pixaGetPix ( pixa , i , L_CLONE ) ; pix2 = pixConvertTo32 ( pix1 ) ; pixSetComponentArbitrary ( pix2 , L_ALPHA_CHANNEL , 255 ) ; pixEndianByteSwap ( pix2 ) ; data = ( l_uint8 * ) pixGetData ( pix2 ) ; wpl = pixGetWpl ( pix2 ) ; WebPPictureInit ( & frame ) ; frame . width = w ; frame . height = h ; WebPPictureImportRGBA ( & frame , data , 4 * wpl ) ; pixDestroy ( & pix1 ) ; pixDestroy ( & pix2 ) ; WebPConfigInit ( & config ) ; config . lossless = lossless ; config . quality = quality ; WebPAnimEncoderAdd ( enc , & frame , duration * i , & config ) ; WebPPictureFree ( & frame ) ; } WebPAnimEncoderAdd ( enc , NULL , duration * i , NULL ) ; WebPAnimEncoderAssemble ( enc , & webp_data ) ; WebPAnimEncoderDelete ( enc ) ; if ( loopcount > 0 ) { mux = WebPMuxCreate ( & webp_data , 1 ) ; if ( ! mux ) { L_ERROR ( "could not re-mux to add loop count\n" , __func__ ) ; } else { ret = WebPMuxGetAnimationParams ( mux , & newparams ) ; if ( ret != WEBP_MUX_OK ) { L_ERROR ( "failed to get loop count\n" , __func__ ) ; } else { newparams . loop_count = loopcount ; ret = WebPMuxSetAnimationParams ( mux , & newparams ) ; } WebPDataClear ( & webp_data ) ; WebPMuxAssemble ( mux , & webp_data ) ; WebPMuxDelete ( mux ) ; } } * pencdata = ( l_uint8 * ) webp_data . bytes ; * pencsize = webp_data . size ; L_INFO ( "data size = %zu\n" , __func__ , webp_data . size ) ; return 0 ; } 