HE * Perl_hv_iternext_flags ( pTHX_ HV * hv , I32 flags ) { HE * entry ; HE * oldentry ; MAGIC * mg ; struct xpvhv_aux * iter ; PERL_ARGS_ASSERT_HV_ITERNEXT_FLAGS ; if ( ! SvOOK ( hv ) ) { hv_iterinit ( hv ) ; } if ( ! HvARRAY ( hv ) ) { char * array ; Newxz ( array , PERL_HV_ARRAY_ALLOC_BYTES ( HvMAX ( hv ) + 1 ) , char ) ; HvARRAY ( hv ) = ( HE * * ) array ; } iter = HvAUX ( hv ) ; oldentry = entry = iter -> xhv_eiter ; if ( SvMAGICAL ( hv ) && SvRMAGICAL ( hv ) ) { if ( ( mg = mg_find ( ( const SV * ) hv , PERL_MAGIC_tied ) ) ) { SV * const key = sv_newmortal ( ) ; if ( entry ) { sv_setsv ( key , HeSVKEY_force ( entry ) ) ; SvREFCNT_dec ( HeSVKEY ( entry ) ) ; HeSVKEY_set ( entry , NULL ) ; } else { char * k ; HEK * hek ; iter -> xhv_eiter = entry = new_HE ( ) ; HvLAZYDEL_on ( hv ) ; Zero ( entry , 1 , HE ) ; Newxz ( k , HEK_BASESIZE + sizeof ( const SV * ) , char ) ; hek = ( HEK * ) k ; HeKEY_hek ( entry ) = hek ; HeKLEN ( entry ) = HEf_SVKEY ; } magic_nextpack ( MUTABLE_SV ( hv ) , mg , key ) ; if ( SvOK ( key ) ) { HeSVKEY_set ( entry , SvREFCNT_inc_simple_NN ( key ) ) ; return entry ; } SvREFCNT_dec ( HeVAL ( entry ) ) ; del_HE ( entry ) ; iter -> xhv_eiter = NULL ; HvLAZYDEL_off ( hv ) ; return NULL ; } } if ( ! entry && SvRMAGICAL ( ( const SV * ) hv ) && mg_find ( ( const SV * ) hv , PERL_MAGIC_env ) ) { prime_env_iter ( ) ; } assert ( HvARRAY ( hv ) ) ; if ( entry ) { entry = HeNEXT ( entry ) ; if ( ! ( flags & HV_ITERNEXT_WANTPLACEHOLDERS ) ) { while ( entry && HeVAL ( entry ) == & PL_sv_placeholder ) { entry = HeNEXT ( entry ) ; } } } if ( iter -> xhv_last_rand != iter -> xhv_rand ) { if ( iter -> xhv_riter != - 1 ) { Perl_ck_warner_d ( , "Use of each() on hash after insertion without resetting hash iterator results in undefined behavior" ) } iter -> xhv_last_rand = iter -> xhv_rand ; } if ( ( flags & HV_ITERNEXT_WANTPLACEHOLDERS ) ?HvTOTALKEYS ( hv ) : HvUSEDKEYS ( hv ) ) { STRLEN max = HvMAX ( hv ) ; while ( ! entry ) { iter -> xhv_riter ++ ; if ( iter -> xhv_riter > ( I32 ) max ) { iter -> xhv_riter = - 1 ; iter -> xhv_last_rand = iter -> xhv_rand ; break ; } entry = ( HvARRAY ( hv ) ) [ PERL_HASH_ITER_BUCKET ( iter ) & max ] ; if ( ! ( flags & HV_ITERNEXT_WANTPLACEHOLDERS ) ) { while ( entry && HeVAL ( entry ) == & PL_sv_placeholder ) { entry = HeNEXT ( entry ) ; } } } } else { iter -> xhv_riter = - 1 ; iter -> xhv_last_rand = iter -> xhv_rand ; } if ( oldentry && HvLAZYDEL ( hv ) ) { HvLAZYDEL_off ( hv ) ; hv_free_ent ( NULL , oldentry ) ; } iter -> xhv_eiter = entry ; return entry ; } 