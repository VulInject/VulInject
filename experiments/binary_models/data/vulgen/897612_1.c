static void test_aead_speed ( const char * algo , int enc , unsigned int secs , struct aead_speed_template * , template , unsigned int tcount , u8 authsize , unsigned int aad_size , u8 * keysize ) { unsigned int i , j ; struct crypto_aead * tfm ; int ret = - ENOMEM ; const char * key ; struct aead_request * req ; struct scatterlist * sg ; struct scatterlist * sgout ; const char * e ; void * assoc ; char * iv ; char * xbuf [ XBUFSIZE ] ; char * xoutbuf [ XBUFSIZE ] ; char * axbuf [ XBUFSIZE ] ; unsigned int * b_size ; unsigned int iv_len ; struct tcrypt_result result ; iv = kzalloc ( MAX_IVLEN , GFP_KERNEL ) ; if ( ! iv ) { return ; } if ( aad_size >= PAGE_SIZE ) { pr_err ( "associate data length (%u) too big\n" , aad_size ) ; out_noxbuf } if ( enc == ENCRYPT ) { e = "encryption" ; } else { e = "decryption" ; } if ( testmgr_alloc_buf ( xbuf ) ) { out_noxbuf } if ( testmgr_alloc_buf ( axbuf ) ) { out_noaxbuf } if ( testmgr_alloc_buf ( xoutbuf ) ) { out_nooutbuf } sg = kmalloc ( sizeof ( * sg ) * 9 * 2 , GFP_KERNEL ) ; if ( ! sg ) { out_nosg } sgout = & sg [ 9 ] ; tfm = crypto_alloc_aead ( algo , 0 , 0 ) ; if ( IS_ERR ( tfm ) ) { pr_err ( "alg: aead: Failed to load transform for %s: %ld\n" , algo , PTR_ERR ( tfm ) ) ; out_notfm } init_completion ( & result . completion ) ; printk ( KERN_INFO "\ntesting speed of %s (%s) %s\n" , algo , get_driver_name ( crypto_aead , tfm ) , e ) ; req = aead_request_alloc ( tfm , GFP_KERNEL ) ; if ( ! req ) { pr_err ( "alg: aead: Failed to allocate request for %s\n" , algo ) ; out_noreq } aead_request_set_callback ( req , CRYPTO_TFM_REQ_MAY_BACKLOG , tcrypt_complete , & result ) ; i = 0 ; { b_size = aead_sizes ; { assoc = axbuf [ 0 ] ; memset ( assoc , 0xff , aad_size ) ; if ( ( * keysize + * b_size ) > TVMEMSIZE * PAGE_SIZE ) { pr_err ( "template (%u) too big for tvmem (%lu)\n" , * keysize + * b_size , TVMEMSIZE * PAGE_SIZE ) ; out } key = tvmem [ 0 ] ; for ( j = 0 ; j < tcount ; j ++ ) { if ( [ j ] . klen == * keysize ) { key = ; break ; } } ret = crypto_aead_setkey ( tfm , key , * keysize ) ; ret = crypto_aead_setauthsize ( tfm , authsize ) ; iv_len = crypto_aead_ivsize ( tfm ) ; if ( iv_len ) { memset ( iv , 0xff , iv_len ) ; } crypto_aead_clear_flags ( tfm , ~ 0 ) ; printk ( KERN_INFO "test %u (%d bit key, %d byte blocks): " , i , * keysize * 8 , * b_size ) ; memset ( tvmem [ 0 ] , 0xff , PAGE_SIZE ) ; if ( ret ) { pr_err ( "setkey() failed flags=%x\n" , crypto_aead_get_flags ( tfm ) ) ; out } sg_init_aead ( sg , xbuf , * b_size + ( enc ?authsize : 0 ) ) ; sg_init_aead ( sgout , xoutbuf , * b_size + ( enc ?authsize : 0 ) ) ; sg_set_buf ( & sg [ 0 ] , assoc , aad_size ) ; sg_set_buf ( & sgout [ 0 ] , assoc , aad_size ) ; aead_request_set_crypt ( req , sg , sgout , * b_size , iv ) ; aead_request_set_ad ( req , aad_size ) ; if ( secs ) { ret = test_aead_jiffies ( req , enc , * b_size , secs ) ; } else { ret = test_aead_cycles ( req , enc , * b_size ) ; } if ( ret ) { pr_err ( "%s() failed return code=%d\n" , e , ret ) ; break ; } b_size ++ ; i ++ ; } * b_size ; keysize ++ ; } * keysize ; out aead_request_free ( req ) ; out_noreq crypto_free_aead ( tfm ) ; out_notfm kfree ( sg ) ; out_nosg testmgr_free_buf ( xoutbuf ) ; out_nooutbuf testmgr_free_buf ( axbuf ) ; out_noaxbuf testmgr_free_buf ( xbuf ) ; out_noxbuf return ; } 