static void ktrcmsghdr ( char * data , socklen_t len ) { struct msghdr msg ; struct cmsghdr * cmsg ; int i , count , * fds ; msg . msg_control = data ; msg . msg_controllen = len ; count = 0 ; for ( cmsg = CMSG_FIRSTHDR ( & msg ) ; cmsg != NULL ; cmsg = CMSG_NXTHDR ( & msg , cmsg ) ) { count ++ ; } printf ( "struct cmsghdr" ) ; for ( cmsg = CMSG_FIRSTHDR ( & msg ) ; cmsg != NULL ; cmsg = CMSG_NXTHDR ( & msg , cmsg ) ) { printf ( " { len=%u, level=" , cmsg -> cmsg_len ) ; if ( cmsg -> cmsg_level == SOL_SOCKET ) { printf ( "SOL_SOCKET, type=" ) ; switch ( cmsg -> cmsg_type ) { case SCM_RIGHTS : printf ( "SCM_RIGHTS, data=" ) ; fds = ( int * ) CMSG_DATA ( cmsg ) ; for ( i = 0 ; cmsg -> cmsg_len > CMSG_LEN ( sizeof ( int ) * i ) && ( char * ) fds + ( i + 1 ) * sizeof ( int ) <= data + len ; i ++ ) { printf ( "%s%d" , i ?"," : "" , fds [ i ] ) ; } break ; case SCM_TIMESTAMP : default : printf ( "%d" , cmsg -> cmsg_type ) ; break ; } } else { struct protoent * p = getprotobynumber ( cmsg -> cmsg_level ) ; printf ( "%u<%s>, type=%d" , cmsg -> cmsg_level , p != NULL ?p -> p_name : "unknown" , cmsg -> cmsg_type ) ; } printf ( " }" ) ; } printf ( "\n" ) ; } 