int pgt_mgmt_request ( struct pgt_softc * sc , struct pgt_mgmt_desc * pmd ) { struct pgt_desc * pd ; struct pgt_mgmt_frame * pmf ; int error , i , ret ; if ( sc -> sc_flags & ( SC_DYING | SC_NEEDS_RESET ) ) { return ( EIO ) ; } pd = TAILQ_FIRST ( & sc -> sc_freeq [ PGT_QUEUE_MGMT_TX ] ) ; if ( pd == NULL ) { return ( ENOMEM ) ; } error = pgt_load_tx_desc_frag ( sc , PGT_QUEUE_MGMT_TX , pd ) ; if ( error ) { return ( error ) ; } pmf = ( pgt_mgmt_frame * ) pd -> pd_mem ; pmf -> pmf_version = PMF_VER ; if ( pmd -> pmd_recvbuf != NULL ) { pmf -> pmf_operation = PMF_OP_GET ; } else { pmf -> pmf_operation = PMF_OP_SET ; } pmf -> pmf_oid = htobe32 ( pmd -> pmd_oid ) ; pmf -> pmf_device = PMF_DEV ; pmf -> pmf_flags = 0 ; pmf -> pmf_size = htobe32 ( pmd -> pmd_len ) ; if ( pmd -> pmd_sendbuf != NULL ) { memcpy ( pmf + 1 , pmd -> pmd_sendbuf , pmd -> pmd_len ) ; } else { bzero ( pmf + 1 , pmd -> pmd_len ) ; } pmd -> pmd_error = EINPROGRESS ; TAILQ_INSERT_TAIL ( & sc -> sc_mgmtinprog , pmd , pmd_link ) ; if ( sc -> sc_debug & SC_DEBUG_MGMT ) { DPRINTF ( ( "%s: queue: mgmt %p ->(op %u, oid %#x, len %u)\n" , sc -> sc_dev . dv_xname , pmd , pmf -> pmf_operation , pmd -> pmd_oid , pmd -> pmd_len ) ) ; } pgt_desc_transmit ( sc , PGT_QUEUE_MGMT_TX , pd , sizeof ( * pmf ) + pmd -> pmd_len , 0 ) ; i = 0 ; { ret = tsleep_nsec ( pmd , 0 , "pgtmgm" , MSEC_TO_NSEC ( 100 ) ) ; if ( ret != EWOULDBLOCK ) { break ; } if ( pmd -> pmd_error != EINPROGRESS ) { break ; } if ( sc -> sc_flags & ( SC_DYING | SC_NEEDS_RESET ) ) { pmd -> pmd_error = EIO ; TAILQ_REMOVE ( & sc -> sc_mgmtinprog , pmd , pmd_link ) ; break ; } if ( i != 9 ) { pgt_maybe_trigger ( sc , PGT_QUEUE_MGMT_RX ) ; } pgt_update_intr ( sc , 0 ) ; } i ++ < 10 ; if ( pmd -> pmd_error == EINPROGRESS ) { printf ( "%s: timeout waiting for management " "packet response to %#x\n" , sc -> sc_dev . dv_xname , pmd -> pmd_oid ) ; TAILQ_REMOVE ( & sc -> sc_mgmtinprog , pmd , pmd_link ) ; if ( sc -> sc_debug & SC_DEBUG_UNEXPECTED ) { pgt_state_dump ( sc ) ; } pgt_async_reset ( sc ) ; error = ETIMEDOUT ; } else { error = 0 ; } return ( error ) ; } 