static int __init init_hw_perf_events ( void ) { int counters , irq ; int counter_bits ; pr_info ( "Performance counters: " ) ; counters = n_counters ( ) ; cpu_has_mipsmt_pertccounters = read_c0_config7 ( ) & ( 1 << 19 ) ; if ( ! cpu_has_mipsmt_pertccounters ) { counters = counters_total_to_per_cpu ( counters ) ; } if ( get_c0_perfcount_int ) { irq = get_c0_perfcount_int ( ) ; } if ( cp0_perfcount_irq >= 0 ) { irq = MIPS_CPU_IRQ_BASE + cp0_perfcount_irq ; } else { irq = - 1 ; } mipspmu . map_raw_event = mipsxx_pmu_map_raw_event ; switch ( current_cpu_type ( ) ) { case CPU_24K : mipspmu . name = "mips/24K" ; mipspmu . general_event_map = & mipsxxcore_event_map ; mipspmu . cache_event_map = & mipsxxcore_cache_map ; break ; case CPU_34K : mipspmu . name = "mips/34K" ; mipspmu . general_event_map = & mipsxxcore_event_map ; mipspmu . cache_event_map = & mipsxxcore_cache_map ; break ; case CPU_74K : mipspmu . name = "mips/74K" ; mipspmu . general_event_map = & mipsxxcore_event_map2 ; mipspmu . cache_event_map = & mipsxxcore_cache_map2 ; break ; case CPU_PROAPTIV : mipspmu . name = "mips/proAptiv" ; mipspmu . general_event_map = & mipsxxcore_event_map2 ; mipspmu . cache_event_map = & mipsxxcore_cache_map2 ; break ; case CPU_P5600 : mipspmu . name = "mips/P5600" ; mipspmu . general_event_map = & mipsxxcore_event_map2 ; mipspmu . cache_event_map = & mipsxxcore_cache_map2 ; break ; case CPU_P6600 : mipspmu . name = "mips/P6600" ; mipspmu . general_event_map = & mipsxxcore_event_map2 ; mipspmu . cache_event_map = & mipsxxcore_cache_map2 ; break ; case CPU_I6400 : mipspmu . name = "mips/I6400" ; mipspmu . general_event_map = & i6400_event_map ; mipspmu . cache_event_map = & i6400_cache_map ; break ; case CPU_1004K : mipspmu . name = "mips/1004K" ; mipspmu . general_event_map = & mipsxxcore_event_map ; mipspmu . cache_event_map = & mipsxxcore_cache_map ; break ; case CPU_1074K : mipspmu . name = "mips/1074K" ; mipspmu . general_event_map = & mipsxxcore_event_map ; mipspmu . cache_event_map = & mipsxxcore_cache_map ; break ; case CPU_INTERAPTIV : mipspmu . name = "mips/interAptiv" ; mipspmu . general_event_map = & mipsxxcore_event_map ; mipspmu . cache_event_map = & mipsxxcore_cache_map ; break ; case CPU_LOONGSON1 : mipspmu . name = "mips/loongson1" ; mipspmu . general_event_map = & mipsxxcore_event_map ; mipspmu . cache_event_map = & mipsxxcore_cache_map ; break ; case CPU_LOONGSON3 : mipspmu . name = "mips/loongson3" ; mipspmu . general_event_map = & loongson3_event_map ; mipspmu . cache_event_map = & loongson3_cache_map ; break ; case CPU_CAVIUM_OCTEON : case CPU_CAVIUM_OCTEON_PLUS : case CPU_CAVIUM_OCTEON2 : mipspmu . name = "octeon" ; mipspmu . general_event_map = & octeon_event_map ; mipspmu . cache_event_map = & octeon_cache_map ; mipspmu . map_raw_event = octeon_pmu_map_raw_event ; break ; case CPU_BMIPS5000 : mipspmu . name = "BMIPS5000" ; mipspmu . general_event_map = & bmips5000_event_map ; mipspmu . cache_event_map = & bmips5000_cache_map ; break ; case CPU_XLP : mipspmu . name = "xlp" ; mipspmu . general_event_map = & xlp_event_map ; mipspmu . cache_event_map = & xlp_cache_map ; mipspmu . map_raw_event = xlp_pmu_map_raw_event ; break ; default : pr_cont ( "Either hardware does not support performance " "counters, or not yet implemented.\n" ) ; return - ENODEV ; } mipspmu . num_counters = counters ; mipspmu . irq = irq ; if ( read_c0_perfctrl0 ( ) & MIPS_PERFCTRL_W ) { mipspmu . max_period = ( 1ULL << 63 ) - 1 ; mipspmu . valid_count = ( 1ULL << 63 ) - 1 ; mipspmu . overflow = 1ULL << 63 ; mipspmu . read_counter = mipsxx_pmu_read_counter_64 ; mipspmu . write_counter = mipsxx_pmu_write_counter_64 ; counter_bits = 64 ; } else { mipspmu . max_period = ( 1ULL << 31 ) - 1 ; mipspmu . valid_count = ( 1ULL << 31 ) - 1 ; mipspmu . overflow = 1ULL << 31 ; mipspmu . read_counter = mipsxx_pmu_read_counter ; mipspmu . write_counter = mipsxx_pmu_write_counter ; counter_bits = 32 ; } on_each_cpu ( reset_counters , ( void * ) ( long ) counters , 1 ) ; pr_cont ( "%s PMU enabled, %d %d-bit counters available to each " "CPU, irq %d%s\n" , mipspmu . name , counters , counter_bits , irq , irq < 0 ?" (share with timer interrupt)" : "" ) ; perf_pmu_register ( & pmu , "cpu" , PERF_TYPE_RAW ) ; return 0 ; } 