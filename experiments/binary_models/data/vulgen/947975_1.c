value_from_register ( , , ) { struct gdbarch * gdbarch = get_frame_arch ( frame ) ; struct value * v = allocate_value ( type ) ; CHECK_TYPEDEF ( type ) ; if ( TYPE_LENGTH ( type ) == 0 ) { VALUE_LVAL ( v ) = lval_register ; VALUE_ADDRESS ( v ) = regnum ; VALUE_REGNO ( v ) = regnum ; } if ( CONVERT_REGISTER_P ( regnum , type ) ) { REGISTER_TO_VALUE ( frame , regnum , type , VALUE_CONTENTS_RAW ( v ) ) ; VALUE_LVAL ( v ) = lval_reg_frame_relative ; VALUE_FRAME_ID ( v ) = get_frame_id ( frame ) ; VALUE_FRAME_REGNUM ( v ) = regnum ; } else { int local_regnum ; int mem_stor = 0 , reg_stor = 0 ; int mem_tracking = 1 ; CORE_ADDR last_addr = 0 ; CORE_ADDR first_addr = 0 ; int first_realnum = regnum ; int len = TYPE_LENGTH ( type ) ; int value_bytes_copied ; int optimized = 0 ; char * value_bytes = ( char * ) alloca ( len + MAX_REGISTER_SIZE ) ; for ( local_regnum = regnum , value_bytes_copied = 0 ; value_bytes_copied < len ; ( value_bytes_copied += register_size ( current_gdbarch , local_regnum ) , ++ local_regnum ) ) { int realnum ; int optim ; enum lval_type lval ; CORE_ADDR addr ; frame_register ( frame , local_regnum , & optim , & lval , & addr , & realnum , value_bytes + value_bytes_copied ) ; optimized += optim ; if ( regnum == local_regnum ) { first_addr = addr ; first_realnum = realnum ; } if ( lval == lval_register ) { reg_stor ++ ; } else { mem_stor ++ ; mem_tracking = ( mem_tracking && ( regnum == local_regnum || addr == last_addr ) ) ; } last_addr = addr ; } if ( ( reg_stor && mem_stor ) || ( mem_stor && ! mem_tracking ) ) { VALUE_LVAL ( v ) = lval_reg_frame_relative ; VALUE_FRAME_ID ( v ) = get_frame_id ( frame ) ; VALUE_FRAME_REGNUM ( v ) = regnum ; } if ( mem_stor ) { VALUE_LVAL ( v ) = lval_memory ; VALUE_ADDRESS ( v ) = first_addr ; } if ( reg_stor ) { VALUE_LVAL ( v ) = lval_register ; VALUE_ADDRESS ( v ) = first_addr ; VALUE_REGNO ( v ) = first_realnum ; } else { internal_error ( __FILE__ , __LINE__ , "value_from_register: Value not stored anywhere!" ) ; } VALUE_OPTIMIZED_OUT ( v ) = optimized ; if ( TARGET_BYTE_ORDER == BFD_ENDIAN_BIG && len < register_size ( current_gdbarch , regnum ) ) { VALUE_OFFSET ( v ) = register_size ( current_gdbarch , regnum ) - len ; } else { VALUE_OFFSET ( v ) = 0 ; } memcpy ( VALUE_CONTENTS_RAW ( v ) , value_bytes + VALUE_OFFSET ( v ) , len ) ; } return v ; } 