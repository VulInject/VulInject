void vmwpvs_scsi_cmd ( struct scsi_xfer * xs ) { struct scsi_link * link = xs -> sc_link ; struct vmwpvs_softc * sc = link -> bus -> sb_adapter_softc ; struct vmwpvs_ccb * ccb = xs -> io ; bus_dmamap_t dmap = ccb -> ccb_dmamap ; volatile struct vmwpvw_ring_state * s = VMWPVS_DMA_KVA ( sc -> sc_ring_state ) ; struct vmwpvs_ring_req * ring = VMWPVS_DMA_KVA ( sc -> sc_req_ring ) , * r ; u_int32_t prod ; struct vmwpvs_ccb_list list ; int error ; u_int i ; ccb -> ccb_xs = xs ; if ( xs -> datalen > 0 ) { error = bus_dmamap_load ( sc -> sc_dmat , dmap , xs -> data , xs -> datalen , NULL , ( xs -> flags & SCSI_NOSLEEP ) ?BUS_DMA_NOWAIT : BUS_DMA_WAITOK ) ; if ( error ) { xs -> error = XS_DRIVER_STUFFUP ; scsi_done ( xs ) ; return ; } bus_dmamap_sync ( sc -> sc_dmat , dmap , 0 , dmap -> dm_mapsize , ( xs -> flags & SCSI_DATA_IN ) ?BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE ) ; } bus_dmamap_sync ( sc -> sc_dmat , VMWPVS_DMA_MAP ( sc -> sc_ring_state ) , 0 , VMWPVS_PAGE_SIZE , BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE ) ; prod = s -> req_prod ; r = & ring [ prod % VMWPVS_REQ_COUNT ] ; bus_dmamap_sync ( sc -> sc_dmat , VMWPVS_DMA_MAP ( sc -> sc_req_ring ) , prod * sizeof ( * r ) , sizeof ( * r ) , BUS_DMASYNC_POSTWRITE ) ; memset ( r , 0 , sizeof ( * r ) ) ; r -> context = ccb -> ccb_ctx ; if ( xs -> datalen > 0 ) { r -> data_len = xs -> datalen ; if ( dmap -> dm_nsegs == 1 ) { r -> data_addr = dmap -> dm_segs [ 0 ] . ds_addr ; } else { struct vmwpvs_sge * sgl = ccb -> ccb_sgl -> list , * sge ; r -> data_addr = VMWPVS_DMA_DVA ( sc -> sc_sgls ) + ccb -> ccb_sgl_offset ; r -> flags = VMWPVS_REQ_SGL ; for ( i = 0 ; i < dmap -> dm_nsegs ; i ++ ) { sge = & sgl [ i ] ; sge -> addr = dmap -> dm_segs [ i ] . ds_addr ; sge -> len = dmap -> dm_segs [ i ] . ds_len ; sge -> flags = 0 ; } bus_dmamap_sync ( sc -> sc_dmat , VMWPVS_DMA_MAP ( sc -> sc_sgls ) , ccb -> ccb_sgl_offset , sizeof ( * sge ) * dmap -> dm_nsegs , BUS_DMASYNC_PREWRITE ) ; } } r -> sense_addr = VMWPVS_DMA_DVA ( sc -> sc_sense ) + ccb -> ccb_sense_offset ; r -> sense_len = sizeof ( xs -> sense ) ; bus_dmamap_sync ( sc -> sc_dmat , VMWPVS_DMA_MAP ( sc -> sc_req_ring ) , 0 , VMWPVS_RING_PAGES * VMWPVS_PAGE_SIZE , BUS_DMASYNC_POSTWRITE ) ; switch ( xs -> flags & ( SCSI_DATA_IN | SCSI_DATA_OUT ) ) { case SCSI_DATA_IN : r -> flags |= VMWPVS_REQ_DIR_IN ; break ; case SCSI_DATA_OUT : r -> flags |= VMWPVS_REQ_DIR_OUT ; break ; default : r -> flags |= VMWPVS_REQ_DIR_NONE ; break ; } memcpy ( r -> cdb , & xs -> cmd , xs -> cmdlen ) ; r -> cdblen = xs -> cmdlen ; r -> lun [ 1 ] = link -> lun ; r -> tag = MSG_SIMPLE_Q_TAG ; r -> bus = 0 ; r -> target = link -> target ; r -> vcpu_hint = 0 ; bus_dmamap_sync ( sc -> sc_dmat , VMWPVS_DMA_MAP ( sc -> sc_req_ring ) , 0 , VMWPVS_RING_PAGES * VMWPVS_PAGE_SIZE , BUS_DMASYNC_PREWRITE ) ; s -> req_prod = prod + 1 ; bus_dmamap_sync ( sc -> sc_dmat , VMWPVS_DMA_MAP ( sc -> sc_ring_state ) , 0 , VMWPVS_PAGE_SIZE , BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE ) ; vmwpvs_write ( sc , xs -> bp == NULL ?VMWPVS_R_KICK_NON_RW_IO : VMWPVS_R_KICK_RW_IO , 0 ) ; if ( ! ISSET ( xs -> flags , SCSI_POLL ) ) { mtx_leave ( & sc -> sc_ring_mtx ) ; return ; } SIMPLEQ_INIT ( & list ) ; { ccb = vmwpvs_scsi_cmd_poll ( sc ) ; SIMPLEQ_INSERT_TAIL ( & list , ccb , ccb_entry ) ; } xs -> io != ccb ; mtx_leave ( & sc -> sc_ring_mtx ) ; while ( ( ccb = SIMPLEQ_FIRST ( & list ) ) != NULL ) { SIMPLEQ_REMOVE_HEAD ( & list , ccb_entry ) ; scsi_done ( ccb -> ccb_xs ) ; } } 