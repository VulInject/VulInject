static void qed_iov_vf_mbx_acquire ( struct qed_hwfn * p_hwfn , struct qed_ptt * p_ptt , struct qed_vf_info * vf ) { struct qed_iov_vf_mbx * mbx = & vf -> vf_mbx ; struct pfvf_acquire_resp_tlv * resp = & mbx -> reply_virt -> acquire_resp ; struct pf_vf_pfdev_info * pfdev_info = & resp -> pfdev_info ; struct vfpf_acquire_tlv * req = & mbx -> req_virt -> acquire ; u8 vfpf_status = PFVF_STATUS_NOT_SUPPORTED ; struct pf_vf_resc * resc = & resp -> resc ; int rc ; pfdev_info -> major_fp_hsi = ETH_HSI_VER_MAJOR ; pfdev_info -> minor_fp_hsi = ETH_HSI_VER_MINOR ; if ( vf -> state != VF_FREE && vf -> state != VF_STOPPED ) { DP_VERBOSE ( p_hwfn , QED_MSG_IOV , "VF[%d] sent ACQUIRE but is already in state %d - fail request\n" , vf -> abs_vf_id , vf -> state ) ; out } if ( req -> vfdev_info . eth_fp_hsi_major != ETH_HSI_VER_MAJOR ) { if ( req -> vfdev_info . capabilities & VFPF_ACQUIRE_CAP_PRE_FP_HSI ) { struct vf_pf_vfdev_info * p_vfdev = & req -> vfdev_info ; DP_VERBOSE ( p_hwfn , QED_MSG_IOV , "VF[%d] is pre-fastpath HSI\n" , vf -> abs_vf_id ) ; p_vfdev -> eth_fp_hsi_major = ETH_HSI_VER_MAJOR ; p_vfdev -> eth_fp_hsi_minor = ETH_HSI_VER_NO_PKT_LEN_TUNN ; } else { DP_INFO ( p_hwfn , "VF[%d] needs fastpath HSI %02x.%02x, which is incompatible with loaded FW's fastpath HSI %02x.%02x\n" , vf -> abs_vf_id , req -> vfdev_info . eth_fp_hsi_major , req -> vfdev_info . eth_fp_hsi_minor , ETH_HSI_VER_MAJOR , ETH_HSI_VER_MINOR ) ; out } } if ( ( p_hwfn -> cdev -> num_hwfns > 1 ) && ! ( req -> vfdev_info . capabilities & VFPF_ACQUIRE_CAP_100G ) ) { DP_INFO ( p_hwfn , "VF[%d] is running an old driver that doesn't support 100g\n" , vf -> abs_vf_id ) ; out } memcpy ( & vf -> acquire , req , sizeof ( vf -> acquire ) ) ; vf -> opaque_fid = req -> vfdev_info . opaque_fid ; vf -> vf_bulletin = req -> bulletin_addr ; vf -> bulletin . size = ( vf -> bulletin . size < req -> bulletin_size ) ?vf -> bulletin . size : req -> bulletin_size ; pfdev_info -> chip_num = p_hwfn -> cdev -> chip_num ; pfdev_info -> db_size = 0 ; pfdev_info -> indices_per_sb = PIS_PER_SB ; pfdev_info -> capabilities = PFVF_ACQUIRE_CAP_DEFAULT_UNTAGGED | PFVF_ACQUIRE_CAP_POST_FW_OVERRIDE ; if ( p_hwfn -> cdev -> num_hwfns > 1 ) { pfdev_info -> capabilities |= PFVF_ACQUIRE_CAP_100G ; } if ( req -> vfdev_info . capabilities & VFPF_ACQUIRE_CAP_QUEUE_QIDS ) { pfdev_info -> capabilities |= PFVF_ACQUIRE_CAP_QUEUE_QIDS ; } resp -> pfdev_info . bar_size = qed_iov_vf_db_bar_size ( p_hwfn , p_ptt ) ; qed_iov_vf_mbx_acquire_stats ( p_hwfn , & pfdev_info -> stats_info ) ; memcpy ( pfdev_info -> port_mac , p_hwfn -> hw_info . hw_mac_addr , ETH_ALEN ) ; pfdev_info -> fw_major = FW_MAJOR_VERSION ; pfdev_info -> fw_minor = FW_MINOR_VERSION ; pfdev_info -> fw_rev = FW_REVISION_VERSION ; pfdev_info -> fw_eng = FW_ENGINEERING_VERSION ; pfdev_info -> minor_fp_hsi = min_t ( u8 , ETH_HSI_VER_MINOR , req -> vfdev_info . eth_fp_hsi_minor ) ; pfdev_info -> os_type = VFPF_ACQUIRE_OS_LINUX ; qed_mcp_get_mfw_ver ( p_hwfn , p_ptt , & pfdev_info -> mfw_ver , NULL ) ; pfdev_info -> dev_type = p_hwfn -> cdev -> type ; pfdev_info -> chip_rev = p_hwfn -> cdev -> chip_rev ; vfpf_status = qed_iov_vf_mbx_acquire_resc ( p_hwfn , p_ptt , vf , & req -> resc_request , resc ) ; if ( vfpf_status != PFVF_STATUS_SUCCESS ) { out } rc = qed_sp_vf_start ( p_hwfn , vf ) ; if ( rc ) { DP_NOTICE ( p_hwfn , "Failed to start VF[%02x]\n" , vf -> abs_vf_id ) ; vfpf_status = PFVF_STATUS_FAILURE ; out } resp -> bulletin_size = vf -> bulletin . size ; qed_iov_post_vf_bulletin ( p_hwfn , vf -> relative_vf_id , p_ptt ) ; DP_VERBOSE ( p_hwfn , QED_MSG_IOV , "VF[%d] ACQUIRE_RESPONSE: pfdev_info- chip_num=0x%x, db_size=%d, idx_per_sb=%d, pf_cap=0x%llx\n" "resources- n_rxq-%d, n_txq-%d, n_sbs-%d, n_macs-%d, n_vlans-%d\n" , vf -> abs_vf_id , resp -> pfdev_info . chip_num , resp -> pfdev_info . db_size , resp -> pfdev_info . indices_per_sb , resp -> pfdev_info . capabilities , resc -> num_rxqs , resc -> num_txqs , resc -> num_sbs , resc -> num_mac_filters , resc -> num_vlan_filters ) ; vf -> state = VF_ACQUIRED ; out qed_iov_prepare_resp ( p_hwfn , p_ptt , vf , CHANNEL_TLV_ACQUIRE , sizeof ( pfvf_acquire_resp_tlv ) , vfpf_status ) ; } 