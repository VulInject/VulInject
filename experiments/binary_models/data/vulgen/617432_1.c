static TupleDesc ConstructTupleDescriptor ( Relation heapRelation , IndexInfo * indexInfo , List * indexColNames , Oid accessMethodObjectId , Oid * collationObjectId , Oid * classObjectId ) { int numatts = indexInfo -> ii_NumIndexAttrs ; int numkeyatts = indexInfo -> ii_NumIndexKeyAttrs ; ListCell * colnames_item = list_head ( indexColNames ) ; ListCell * indexpr_item = list_head ( indexInfo -> ii_Expressions ) ; IndexAmRoutine * amroutine ; TupleDesc heapTupDesc ; TupleDesc indexTupDesc ; int natts ; int i ; amroutine = GetIndexAmRoutineByAmId ( accessMethodObjectId , false ) ; heapTupDesc = RelationGetDescr ( heapRelation ) ; natts = RelationGetForm ( heapRelation ) -> relnatts ; indexTupDesc = CreateTemplateTupleDesc ( numatts ) ; for ( i = 0 ; i < numatts ; i ++ ) { AttrNumber atnum = indexInfo -> ii_IndexAttrNumbers [ i ] ; Form_pg_attribute to = TupleDescAttr ( indexTupDesc , i ) ; HeapTuple tuple ; Form_pg_type typeTup ; Form_pg_opclass opclassTup ; Oid keyType ; MemSet ( to , 0 , ATTRIBUTE_FIXED_PART_SIZE ) ; to -> attnum = i + 1 ; to -> attstattarget = - 1 ; to -> attcacheoff = - 1 ; to -> attislocal = true ; to -> attcollation = ( i < numkeyatts ) ?collationObjectId [ i ] : InvalidOid ; if ( colnames_item == NULL ) { elog ( ERROR , "too few entries in colnames list" ) ; } namestrcpy ( & to -> attname , ( const char * ) lfirst ( colnames_item ) ) ; colnames_item = lnext ( indexColNames , colnames_item ) ; if ( atnum != 0 ) { const FormData_pg_attribute * from ; Assert ( atnum > 0 ) ; if ( atnum > natts ) { elog ( ERROR , "invalid column number %d" , atnum ) ; } from = TupleDescAttr ( heapTupDesc , AttrNumberGetAttrOffset ( atnum ) ) ; to -> atttypid = from -> atttypid ; to -> attlen = from -> attlen ; to -> attndims = from -> attndims ; to -> atttypmod = from -> atttypmod ; to -> attbyval = from -> attbyval ; to -> attalign = from -> attalign ; to -> attstorage = from -> attstorage ; to -> attcompression = from -> attcompression ; } else { Node * indexkey ; if ( indexpr_item == NULL ) { elog ( ERROR , "too few entries in indexprs list" ) ; } indexkey = ( Node * ) lfirst ( indexpr_item ) ; indexpr_item = lnext ( indexInfo -> ii_Expressions , indexpr_item ) ; keyType = exprType ( indexkey ) ; tuple = SearchSysCache1 ( TYPEOID , ObjectIdGetDatum ( keyType ) ) ; if ( ! HeapTupleIsValid ( tuple ) ) { elog ( ERROR , "cache lookup failed for type %u" , keyType ) ; } typeTup = ( Form_pg_type ) GETSTRUCT ( tuple ) ; to -> atttypid = keyType ; to -> attlen = typeTup -> typlen ; to -> atttypmod = exprTypmod ( indexkey ) ; to -> attbyval = typeTup -> typbyval ; to -> attalign = typeTup -> typalign ; to -> attstorage = typeTup -> typstorage ; to -> attcompression = InvalidCompressionMethod ; ReleaseSysCache ( tuple ) ; CheckAttributeType ( NameStr ( to -> attname ) , to -> atttypid , to -> attcollation , NIL , 0 ) ; } to -> attrelid = InvalidOid ; keyType = amroutine -> amkeytype ; if ( OidIsValid ( keyType ) && keyType != to -> atttypid ) { tuple = SearchSysCache1 ( TYPEOID , ObjectIdGetDatum ( keyType ) ) ; if ( ! HeapTupleIsValid ( tuple ) ) { elog ( ERROR , "cache lookup failed for type %u" , keyType ) ; } typeTup = ( Form_pg_type ) GETSTRUCT ( tuple ) ; to -> atttypid = keyType ; to -> atttypmod = - 1 ; to -> attlen = typeTup -> typlen ; to -> attbyval = typeTup -> typbyval ; to -> attalign = typeTup -> typalign ; to -> attstorage = typeTup -> typstorage ; to -> attcompression = InvalidCompressionMethod ; ReleaseSysCache ( tuple ) ; } } pfree ( amroutine ) ; return indexTupDesc ; } 