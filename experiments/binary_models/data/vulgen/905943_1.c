static void usbback_do_response ( struct usbback_req * usbback_req , int32_t status , int32_t actual_length , int32_t error_count ) { struct usbback_info * usbif ; struct usbif_urb_response * res ; struct XenLegacyDevice * xendev ; unsigned int notify ; usbif = usbback_req -> usbif ; xendev = & usbif -> xendev ; TR_REQ ( xendev , "id %d, status %d, length %d, errcnt %d\n" , usbback_req -> req . id , status , actual_length , error_count ) ; if ( usbback_req -> packet . iov . iov ) { qemu_iovec_destroy ( & usbback_req -> packet . iov ) ; } if ( usbback_req -> buffer ) { xen_be_unmap_grant_refs ( xendev , usbback_req -> buffer , usbback_req -> nr_buffer_segs ) ; usbback_req -> buffer = NULL ; } if ( usbback_req -> isoc_buffer ) { xen_be_unmap_grant_refs ( xendev , usbback_req -> isoc_buffer , usbback_req -> nr_extra_segs ) ; usbback_req -> isoc_buffer = NULL ; } if ( usbif -> urb_sring ) { res = RING_GET_RESPONSE ( & usbif -> urb_ring , usbif -> urb_ring . rsp_prod_pvt ) ; res -> id = usbback_req -> req . id ; res -> status = status ; res -> actual_length = actual_length ; res -> error_count = error_count ; res -> start_frame = 0 ; usbif -> urb_ring . rsp_prod_pvt ++ ; RING_PUSH_RESPONSES_AND_CHECK_NOTIFY ( & usbif -> urb_ring , notify ) ; if ( notify ) { xen_pv_send_notify ( xendev ) ; } } } 