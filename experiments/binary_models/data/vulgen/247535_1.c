static void do_writes ( struct mirror_set * ms , struct bio_list * writes ) { int state ; struct bio * bio ; struct bio_list sync , nosync , recover , * this_list = NULL ; struct bio_list requeue ; struct dm_dirty_log * log = dm_rh_dirty_log ( ms -> rh ) ; region_t region ; bio_list_init ( & sync ) ; bio_list_init ( & nosync ) ; bio_list_init ( & recover ) ; bio_list_init ( & requeue ) ; while ( ( bio = bio_list_pop ( writes ) ) ) { if ( ( bio -> bi_opf & REQ_PREFLUSH ) || ( bio_op ( bio ) == REQ_OP_DISCARD ) ) { bio_list_add ( & sync , bio ) ; continue ; } region = dm_rh_bio_to_region ( ms -> rh , bio ) ; if ( log -> type -> is_remote_recovering && log -> type -> is_remote_recovering ( log , region ) ) { bio_list_add ( & requeue , bio ) ; continue ; } state = dm_rh_get_state ( ms -> rh , region , 1 ) ; switch ( state ) { case DM_RH_CLEAN : case DM_RH_DIRTY : this_list = & sync ; break ; case DM_RH_NOSYNC : this_list = & nosync ; break ; case DM_RH_RECOVERING : this_list = & recover ; break ; } bio_list_add ( this_list , bio ) ; } if ( unlikely ( requeue . head ) ) { spin_lock_irq ( & ms -> lock ) ; bio_list_merge ( & ms -> writes , & requeue ) ; spin_unlock_irq ( & ms -> lock ) ; delayed_wake ( ms ) ; } dm_rh_inc_pending ( ms -> rh , & sync ) ; dm_rh_inc_pending ( ms -> rh , & nosync ) ; ms -> log_failure = dm_rh_flush ( ms -> rh ) ?1 : ms -> log_failure ; if ( unlikely ( ms -> log_failure ) && errors_handled ( ms ) ) { spin_lock_irq ( & ms -> lock ) ; bio_list_merge ( & ms -> failures , & sync ) ; spin_unlock_irq ( & ms -> lock ) ; wakeup_mirrord ( ms ) ; } else { while ( ( bio = bio_list_pop ( & sync ) ) ) { do_write ( ms , bio ) ; } } while ( ( bio = bio_list_pop ( & recover ) ) ) { dm_rh_delay ( ms -> rh , bio ) ; } while ( ( bio = bio_list_pop ( & nosync ) ) ) { if ( unlikely ( ms -> leg_failure ) && errors_handled ( ms ) && ! keep_log ( ms ) ) { spin_lock_irq ( & ms -> lock ) ; bio_list_add ( & ms -> failures , bio ) ; spin_unlock_irq ( & ms -> lock ) ; wakeup_mirrord ( ms ) ; } else { map_bio ( get_default_mirror ( ms ) , bio ) ; submit_bio_noacct ( bio ) ; } } } 