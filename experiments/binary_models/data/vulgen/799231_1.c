* * This file is part of the FreeType project , and may only be used , * modified , and distributed under the terms of the FreeType project * license , LICENSE . TXT . By continuing to use , modify , or distribute * this file you indicate that you have read the license and * understand and accept it fully . * * / static const FT_Outline null_outline = { 0 0 NULL NULL NULL 0 } ; FT_EXPORT_DEF ( ) FT_Outline_Decompose ( , , ) { FT_Vector v_last ; FT_Vector v_control ; FT_Vector v_start ; FT_Vector * point ; FT_Vector * limit ; char * tags ; FT_Error error ; FT_Int n ; FT_UInt first ; FT_Int tag ; FT_Int shift ; FT_Pos delta ; if ( ! outline ) { return FT_THROW ( Invalid_Outline ) ; } if ( ! func_interface ) { return FT_THROW ( Invalid_Argument ) ; } shift = func_interface -> shift ; delta = func_interface -> delta ; first = 0 ; for ( n = 0 ; n < outline -> n_contours ; n ++ ) { FT_Int last ; FT_TRACE5 ( ( "FT_Outline_Decompose: Outline %d\n" , n ) ) ; last = outline -> contours [ n ] ; if ( last < 0 ) { Invalid_Outline } limit = outline -> points + last ; v_start = outline -> points [ first ] ; v_start . x = SCALED ( v_start . x ) ; v_start . y = SCALED ( v_start . y ) ; v_last = outline -> points [ last ] ; v_last . x = SCALED ( v_last . x ) ; v_last . y = SCALED ( v_last . y ) ; v_control = v_start ; point = outline -> points + first ; tags = outline -> tags + first ; tag = FT_CURVE_TAG ( tags [ 0 ] ) ; if ( tag == FT_CURVE_TAG_CUBIC ) { Invalid_Outline } if ( tag == FT_CURVE_TAG_CONIC ) { if ( FT_CURVE_TAG ( outline -> tags [ last ] ) == FT_CURVE_TAG_ON ) { v_start = v_last ; limit -- ; } else { v_start . x = ( v_start . x + v_last . x ) / 2 ; v_start . y = ( v_start . y + v_last . y ) / 2 ; } point -- ; tags -- ; } FT_TRACE5 ( ( "  move to (%.2f, %.2f)\n" , ( double ) v_start . x / 64 , ( double ) v_start . y / 64 ) ) ; error = func_interface -> move_to ( & v_start , user ) ; if ( error ) { Exit } while ( point < limit ) { point ++ ; tags ++ ; tag = FT_CURVE_TAG ( tags [ 0 ] ) ; switch ( tag ) { case FT_CURVE_TAG_ON : { FT_Vector vec ; vec . x = SCALED ( point -> x ) ; vec . y = SCALED ( point -> y ) ; FT_TRACE5 ( ( "  line to (%.2f, %.2f)\n" , ( double ) vec . x / 64 , ( double ) vec . y / 64 ) ) ; error = func_interface -> line_to ( & vec , user ) ; if ( error ) { Exit } continue ; } case FT_CURVE_TAG_CONIC : v_control . x = SCALED ( point -> x ) ; v_control . y = SCALED ( point -> y ) ; Do_Conic if ( point < limit ) { FT_Vector vec ; FT_Vector v_middle ; point ++ ; tags ++ ; tag = FT_CURVE_TAG ( tags [ 0 ] ) ; vec . x = SCALED ( point -> x ) ; vec . y = SCALED ( point -> y ) ; if ( tag == FT_CURVE_TAG_ON ) { FT_TRACE5 ( ( "  conic to (%.2f, %.2f)" " with control (%.2f, %.2f)\n" , ( double ) vec . x / 64 , ( double ) vec . y / 64 , ( double ) v_control . x / 64 , ( double ) v_control . y / 64 ) ) ; error = func_interface -> conic_to ( & v_control , & vec , user ) ; if ( error ) { Exit } continue ; } if ( tag != FT_CURVE_TAG_CONIC ) { Invalid_Outline } v_middle . x = ( v_control . x + vec . x ) / 2 ; v_middle . y = ( v_control . y + vec . y ) / 2 ; FT_TRACE5 ( ( "  conic to (%.2f, %.2f)" " with control (%.2f, %.2f)\n" , ( double ) v_middle . x / 64 , ( double ) v_middle . y / 64 , ( double ) v_control . x / 64 , ( double ) v_control . y / 64 ) ) ; error = func_interface -> conic_to ( & v_control , & v_middle , user ) ; if ( error ) { Exit } v_control = vec ; Do_Conic } FT_TRACE5 ( ( "  conic to (%.2f, %.2f)" " with control (%.2f, %.2f)\n" , ( double ) v_start . x / 64 , ( double ) v_start . y / 64 , ( double ) v_control . x / 64 , ( double ) v_control . y / 64 ) ) ; error = func_interface -> conic_to ( & v_control , & v_start , user ) ; Close default : { FT_Vector vec1 , vec2 ; if ( point + 1 > limit || FT_CURVE_TAG ( tags [ 1 ] ) != FT_CURVE_TAG_CUBIC ) { Invalid_Outline } point += 2 ; tags += 2 ; vec1 . x = SCALED ( point [ - 2 ] . x ) ; vec1 . y = SCALED ( point [ - 2 ] . y ) ; vec2 . x = SCALED ( point [ - 1 ] . x ) ; vec2 . y = SCALED ( point [ - 1 ] . y ) ; if ( point <= limit ) { FT_Vector vec ; vec . x = SCALED ( point -> x ) ; vec . y = SCALED ( point -> y ) ; FT_TRACE5 ( ( "  cubic to (%.2f, %.2f)" " with controls (%.2f, %.2f) and (%.2f, %.2f)\n" , ( double ) vec . x / 64 , ( double ) vec . y / 64 , ( double ) vec1 . x / 64 , ( double ) vec1 . y / 64 , ( double ) vec2 . x / 64 , ( double ) vec2 . y / 64 ) ) ; error = func_interface -> cubic_to ( & vec1 , & vec2 , & vec , user ) ; if ( error ) { Exit } continue ; } FT_TRACE5 ( ( "  cubic to (%.2f, %.2f)" " with controls (%.2f, %.2f) and (%.2f, %.2f)\n" , ( double ) v_start . x / 64 , ( double ) v_start . y / 64 , ( double ) vec1 . x / 64 , ( double ) vec1 . y / 64 , ( double ) vec2 . x / 64 , ( double ) vec2 . y / 64 ) ) ; error = func_interface -> cubic_to ( & vec1 , & vec2 , & v_start , user ) ; Close } } } FT_TRACE5 ( ( "  line to (%.2f, %.2f)\n" , ( double ) v_start . x / 64 , ( double ) v_start . y / 64 ) ) ; error = func_interface -> line_to ( & v_start , user ) ; Close if ( error ) { Exit } first = ( FT_UInt ) last + 1 ; } FT_TRACE5 ( ( "FT_Outline_Decompose: Done\n" ) ) ; return FT_Err_Ok ; Invalid_Outline error = FT_THROW ( Invalid_Outline ) ; Exit FT_TRACE5 ( ( "FT_Outline_Decompose: Error 0x%x\n" , error ) ) ; return error ; } FT_EXPORT_DEF ( ) FT_Outline_New ( , , , ) { FT_Error error ; FT_Memory memory ; if ( ! library ) { return FT_THROW ( Invalid_Library_Handle ) ; } memory = library -> memory ; if ( ! anoutline || ! memory ) { return FT_THROW ( Invalid_Argument ) ; } * anoutline = null_outline ; if ( numContours ( 0 || ( FT_UInt ) numContours ) numPoints ) { return FT_THROW ( Invalid_Argument ) ; } if ( numPoints > FT_OUTLINE_POINTS_MAX ) { return FT_THROW ( Array_Too_Large ) ; } if ( FT_NEW_ARRAY ( anoutline -> points , numPoints ) || FT_NEW_ARRAY ( anoutline -> tags , numPoints ) || FT_NEW_ARRAY ( anoutline -> contours , numContours ) ) { Fail } anoutline -> n_points = ( FT_Short ) numPoints ; anoutline -> n_contours = ( FT_Short ) numContours ; anoutline -> flags |= FT_OUTLINE_OWNER ; return FT_Err_Ok ; Fail anoutline -> flags |= FT_OUTLINE_OWNER ; FT_Outline_Done ( library , anoutline ) ; return error ; } FT_EXPORT_DEF ( ) FT_Outline_Check ( ) { if ( outline ) { FT_Int n_points = outline -> n_points ; FT_Int n_contours = outline -> n_contours ; FT_Int end0 , end ; FT_Int n ; if ( n_points == 0 && n_contours == 0 ) { return FT_Err_Ok ; } if ( n_points <= 0 || n_contours <= 0 ) { Bad } end0 = end = - 1 ; for ( n = 0 ; n < n_contours ; n ++ ) { end = outline -> contours [ n ] ; if ( end <= end0 || end >= n_points ) { Bad } end0 = end ; } if ( end != n_points - 1 ) { Bad } return FT_Err_Ok ; } Bad return FT_THROW ( Invalid_Argument ) ; } FT_EXPORT_DEF ( ) FT_Outline_Copy ( , ) { FT_Int is_owner ; if ( ! source || ! target ) { return FT_THROW ( Invalid_Outline ) ; } if ( source -> n_points != target -> n_points || source -> n_contours != target -> n_contours ) { return FT_THROW ( Invalid_Argument ) ; } if ( source == target ) { return FT_Err_Ok ; } if ( source -> n_points ) { FT_ARRAY_COPY ( target -> points , source -> points , source -> n_points ) ; FT_ARRAY_COPY ( target -> tags , source -> tags , source -> n_points ) ; } if ( source -> n_contours ) { FT_ARRAY_COPY ( target -> contours , source -> contours , source -> n_contours ) ; } is_owner = target -> flags & FT_OUTLINE_OWNER ; target -> flags = source -> flags ; target -> flags &= ~ FT_OUTLINE_OWNER ; target -> flags |= is_owner ; return FT_Err_Ok ; } FT_EXPORT_DEF ( ) FT_Outline_Done ( , ) { FT_Memory memory ; if ( ! library ) { return FT_THROW ( Invalid_Library_Handle ) ; } if ( ! outline ) { return FT_THROW ( Invalid_Outline ) ; } memory = library -> memory ; if ( ! memory ) { return FT_THROW ( Invalid_Argument ) ; } if ( outline -> flags & FT_OUTLINE_OWNER ) { FT_FREE ( outline -> points ) ; FT_FREE ( outline -> tags ) ; FT_FREE ( outline -> contours ) ; } * outline = null_outline ; return FT_Err_Ok ; } FT_EXPORT_DEF ( ) FT_Outline_Get_CBox ( , ) { FT_Pos xMin , yMin , xMax , yMax ; if ( outline && acbox ) { if ( outline -> n_points == 0 ) { xMin = 0 ; yMin = 0 ; xMax = 0 ; yMax = 0 ; } else { FT_Vector * vec = outline -> points ; FT_Vector * limit = vec + outline -> n_points ; xMin = xMax = vec -> x ; yMin = yMax = vec -> y ; vec ++ ; for ( ; vec < limit ; vec ++ ) { FT_Pos x , y ; x = vec -> x ; if ( x < xMin ) { xMin = x ; } if ( x > xMax ) { xMax = x ; } y = vec -> y ; if ( y < yMin ) { yMin = y ; } } } acbox -> xMin = xMin ; acbox -> xMax = xMax ; acbox -> yMin = yMin ; acbox -> yMax = yMax ; } } FT_EXPORT_DEF ( ) FT_Outline_Translate ( , , ) { FT_UShort n ; FT_Vector * vec ; if ( ! outline ) { return ; } vec = outline -> points ; for ( n = 0 ; n < outline -> n_points ; n ++ ) { vec -> x = ADD_LONG ( vec -> x , xOffset ) ; vec -> y = ADD_LONG ( vec -> y , yOffset ) ; vec ++ ; } } FT_EXPORT_DEF ( ) FT_Outline_Reverse ( ) { FT_UShort n ; FT_Int first , last ; if ( ! outline ) { return ; } first = 0 ; for ( n = 0 ; n < outline -> n_contours ; n ++ ) { last = outline -> contours [ n ] ; { FT_Vector * p = outline -> points + first ; FT_Vector * q = outline -> points + last ; FT_Vector swap ; while ( p < q ) { swap = * p ; * p = * q ; * q = swap ; p ++ ; q -- ; } } { char * p = outline -> tags + first ; char * q = outline -> tags + last ; while ( p < q ) { char swap ; swap = * p ; * p = * q ; * q = swap ; p ++ ; q -- ; } } first = last + 1 ; } outline -> flags ^= FT_OUTLINE_REVERSE_FILL ; } FT_EXPORT_DEF ( ) FT_Outline_Render ( , , ) { FT_Error error ; FT_Renderer renderer ; FT_ListNode node ; FT_BBox cbox ; if ( ! library ) { return FT_THROW ( Invalid_Library_Handle ) ; } if ( ! outline ) { return FT_THROW ( Invalid_Outline ) ; } if ( ! params ) { return FT_THROW ( Invalid_Argument ) ; } FT_Outline_Get_CBox ( outline , & cbox ) ; if ( cbox . xMin ( - 0x1000000L || cbox . yMin ( - 0x1000000L || cbox . xMax ) 0x1000000L || cbox . yMax ) 0x1000000L ) { return FT_THROW ( Invalid_Outline ) ; } renderer = library -> cur_renderer ; node = library -> renderers . head ; params -> source = ( void * ) outline ; } 