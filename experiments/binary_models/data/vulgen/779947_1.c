static int print_array ( const char * type , const char * name , mdb_ctf_id_t id , mdb_ctf_id_t base , ulong_t off , printarg_t * pap ) { mdb_tgt_addr_t addr = pap -> pa_addr + off / NBBY ; printarg_t pa = * pap ; ssize_t eltsize ; mdb_ctf_arinfo_t r ; ctf_encoding_t e ; uint_t i , kind , limit ; int d , sou ; char buf [ 8 ] ; char * str ; if ( ! ( pap -> pa_flags & PA_SHOWVAL ) ) { return ( 0 ) ; } if ( pap -> pa_depth == pap -> pa_maxdepth ) { mdb_printf ( "[ ... ]" ) ; return ( 0 ) ; } if ( mdb_ctf_array_info ( base , & r ) == - 1 || mdb_ctf_type_resolve ( r . mta_contents , & base ) == - 1 || ( eltsize = mdb_ctf_type_size ( base ) ) == - 1 ) { mdb_printf ( "[ ??? ] (%s)" , mdb_strerror ( errno ) ) ; return ( 0 ) ; } if ( ( pap -> pa_arstrlim == MDB_ARR_NOLIMIT || r . mta_nelems <= pap -> pa_arstrlim ) && mdb_ctf_type_encoding ( base , & e ) == 0 && IS_CHAR ( e ) && mdb_tgt_readstr ( pap -> pa_tgt , pap -> pa_as , buf , MIN ( sizeof ( buf ) , r . mta_nelems ) , addr ) > 0 && strisprint ( buf ) ) { str = mdb_alloc ( r . mta_nelems + 1 , UM_SLEEP | UM_GC ) ; str [ r . mta_nelems ] = '\0' ; if ( mdb_tgt_aread ( pap -> pa_tgt , pap -> pa_as , str , r . mta_nelems , addr ) != r . mta_nelems ) { mdb_warn ( "failed to read char array at %llx" , addr ) ; return ( 1 ) ; } if ( strisprint ( str ) ) { mdb_printf ( "[ \"%s\" ]" , str ) ; return ( 0 ) ; } } if ( pap -> pa_armemlim != MDB_ARR_NOLIMIT ) { limit = MIN ( r . mta_nelems , pap -> pa_armemlim ) ; } else { limit = r . mta_nelems ; } kind = mdb_ctf_type_kind ( base ) ; sou = IS_COMPOSITE ( kind ) ; pa . pa_addr = addr ; pa . pa_maxdepth = pa . pa_maxdepth - pa . pa_depth - 1 ; pa . pa_nest += pa . pa_depth + 1 ; pa . pa_depth = 0 ; pa . pa_prefix = NULL ; if ( sou ) { pa . pa_delim = "\n" ; mdb_printf ( "[\n" ) ; } else { pa . pa_flags &= ~ ( PA_SHOWTYPE | PA_SHOWNAME | PA_SHOWADDR ) ; pa . pa_delim = ", " ; mdb_printf ( "[ " ) ; } for ( i = 0 ; i < limit ; i ++ , pa . pa_addr += eltsize ) { if ( i == limit - 1 && ! sou ) { if ( limit < r . mta_nelems ) { pa . pa_delim = ", ... ]" ; } else { pa . pa_delim = " ]" ; } } if ( mdb_ctf_type_visit ( r . mta_contents , elt_print , & pa ) == - 1 ) { mdb_warn ( "failed to print array data" ) ; return ( 1 ) ; } } if ( sou ) { for ( d = pa . pa_depth - 1 ; d >= 0 ; d -- ) { print_close_sou ( & pa , d ) ; } if ( limit < r . mta_nelems ) { mdb_printf ( "%*s... ]" , ( pap -> pa_depth + pap -> pa_nest ) * pap -> pa_tab , "" ) ; } else { mdb_printf ( "%*s]" , ( pap -> pa_depth + pap -> pa_nest ) * pap -> pa_tab , "" ) ; } } pap -> pa_holes = pa . pa_holes ; pap -> pa_nholes = pa . pa_nholes ; return ( 0 ) ; } 