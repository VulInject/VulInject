static bool _rtl8821ae_init_mac ( struct ieee80211_hw * hw ) { struct rtl_priv * rtlpriv = rtl_priv ( hw ) ; struct rtl_pci * rtlpci = rtl_pcidev ( rtl_pcipriv ( hw ) ) ; struct rtl_hal * rtlhal = rtl_hal ( rtl_priv ( hw ) ) ; u8 bytetmp = 0 ; u16 wordtmp = 0 ; rtl_write_byte ( rtlpriv , REG_RSV_CTRL , 0x00 ) ; bytetmp = rtl_read_byte ( rtlpriv , REG_APS_FSMCO + 1 ) & ( ~BIT ( 7 ) ) ; rtl_write_byte ( rtlpriv , REG_APS_FSMCO + 1 , bytetmp ) ; if ( rtlhal -> hw_type == HARDWARE_TYPE_RTL8812AE ) { if ( ! rtl_hal_pwrseqcmdparsing ( rtlpriv , PWR_CUT_ALL_MSK , PWR_FAB_ALL_MSK , PWR_INTF_PCI_MSK , RTL8812_NIC_ENABLE_FLOW ) ) { rtl_dbg ( rtlpriv , COMP_INIT , DBG_LOUD , "init 8812 MAC Fail as power on failure\n" ) ; return false ; } } else { if ( ! rtl_hal_pwrseqcmdparsing ( rtlpriv , PWR_CUT_A_MSK , PWR_FAB_ALL_MSK , PWR_INTF_PCI_MSK , RTL8821A_NIC_ENABLE_FLOW ) ) { rtl_dbg ( rtlpriv , COMP_INIT , DBG_LOUD , "init 8821 MAC Fail as power on failure\n" ) ; return false ; } } bytetmp = rtl_read_byte ( rtlpriv , REG_APS_FSMCO ) | BIT ( 4 ) ; rtl_write_byte ( rtlpriv , REG_APS_FSMCO , bytetmp ) ; bytetmp = rtl_read_byte ( rtlpriv , REG_CR ) ; bytetmp = 0xff ; rtl_write_byte ( rtlpriv , REG_CR , bytetmp ) ; mdelay ( 2 ) ; bytetmp = 0xff ; rtl_write_byte ( rtlpriv , REG_HWSEQ_CTRL , bytetmp ) ; mdelay ( 2 ) ; if ( rtlhal -> hw_type == HARDWARE_TYPE_RTL8821AE ) { bytetmp = rtl_read_byte ( rtlpriv , REG_SYS_CFG + 3 ) ; if ( bytetmp & BIT ( 0 ) ) { bytetmp = rtl_read_byte ( rtlpriv , 0x7c ) ; bytetmp |= BIT ( 6 ) ; rtl_write_byte ( rtlpriv , 0x7c , bytetmp ) ; } } bytetmp = rtl_read_byte ( rtlpriv , REG_GPIO_MUXCFG + 1 ) ; bytetmp &= ~ BIT ( 4 ) ; rtl_write_byte ( rtlpriv , REG_GPIO_MUXCFG + 1 , bytetmp ) ; rtl_write_word ( rtlpriv , REG_CR , 0x2ff ) ; if ( ! mac_func_enable ) { if ( ! _rtl8821ae_llt_table_init ( hw ) ) { return false ; } } rtl_write_dword ( rtlpriv , REG_HISR , 0xffffffff ) ; rtl_write_dword ( rtlpriv , REG_HISRE , 0xffffffff ) ; bytetmp = rtl_read_byte ( rtlpriv , REG_FWIMR + 3 ) ; rtl_write_byte ( rtlpriv , REG_FWIMR + 3 , bytetmp | BIT ( 6 ) ) ; wordtmp = rtl_read_word ( rtlpriv , REG_TRXDMA_CTRL ) ; wordtmp &= 0xf ; wordtmp |= 0xF5B1 ; rtl_write_word ( rtlpriv , REG_TRXDMA_CTRL , wordtmp ) ; rtl_write_byte ( rtlpriv , REG_FWHW_TXQ_CTRL + 1 , 0x1F ) ; rtl_write_dword ( rtlpriv , REG_RCR , rtlpci -> receive_config ) ; rtl_write_word ( rtlpriv , REG_RXFLTMAP2 , 0xFFFF ) ; rtl_write_dword ( rtlpriv , REG_BCNQ_DESA , rtlpci -> tx_ring [ BEACON_QUEUE ] . dma & DMA_BIT_MASK ( 32 ) ) ; rtl_write_dword ( rtlpriv , REG_MGQ_DESA , rtlpci -> tx_ring [ MGNT_QUEUE ] . dma & DMA_BIT_MASK ( 32 ) ) ; rtl_write_dword ( rtlpriv , REG_VOQ_DESA , rtlpci -> tx_ring [ VO_QUEUE ] . dma & DMA_BIT_MASK ( 32 ) ) ; rtl_write_dword ( rtlpriv , REG_VIQ_DESA , rtlpci -> tx_ring [ VI_QUEUE ] . dma & DMA_BIT_MASK ( 32 ) ) ; rtl_write_dword ( rtlpriv , REG_BEQ_DESA , rtlpci -> tx_ring [ BE_QUEUE ] . dma & DMA_BIT_MASK ( 32 ) ) ; rtl_write_dword ( rtlpriv , REG_BKQ_DESA , rtlpci -> tx_ring [ BK_QUEUE ] . dma & DMA_BIT_MASK ( 32 ) ) ; rtl_write_dword ( rtlpriv , REG_HQ_DESA , rtlpci -> tx_ring [ HIGH_QUEUE ] . dma & DMA_BIT_MASK ( 32 ) ) ; rtl_write_dword ( rtlpriv , REG_RX_DESA , rtlpci -> rx_ring [ RX_MPDU_QUEUE ] . dma & DMA_BIT_MASK ( 32 ) ) ; rtl_write_byte ( rtlpriv , REG_PCIE_CTRL_REG + 3 , 0x77 ) ; rtl_write_dword ( rtlpriv , REG_INT_MIG , 0 ) ; rtl_write_dword ( rtlpriv , REG_MCUTST_1 , 0 ) ; rtl_write_byte ( rtlpriv , REG_SECONDARY_CCA_CTRL , 0x3 ) ; _rtl8821ae_gen_refresh_led_state ( hw ) ; return true ; } 