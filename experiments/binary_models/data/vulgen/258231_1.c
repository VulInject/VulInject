static int mptsas_probe_hba_phys ( MPT_ADAPTER * ioc ) { struct mptsas_portinfo * port_info , * hba ; int error = - ENOMEM , i ; hba = kzalloc ( sizeof ( mptsas_portinfo ) , GFP_KERNEL ) ; if ( ! hba ) { out } error = mptsas_sas_io_unit_pg0 ( ioc , hba ) ; if ( error ) { out_free_port_info } mptsas_sas_io_unit_pg1 ( ioc ) ; mutex_lock ( & ioc -> sas_topology_mutex ) ; port_info = ioc -> hba_port_info ; if ( ! port_info ) { ioc -> hba_port_info = port_info = hba ; ioc -> hba_port_num_phy = port_info -> num_phys ; list_add_tail ( & port_info -> list , & ioc -> sas_topology ) ; } else { for ( i = 0 ; i < hba -> num_phys ; i ++ ) { port_info -> phy_info [ i ] . negotiated_link_rate = hba -> phy_info [ i ] . negotiated_link_rate ; port_info -> phy_info [ i ] . handle = hba -> phy_info [ i ] . handle ; port_info -> phy_info [ i ] . port_id = hba -> phy_info [ i ] . port_id ; } kfree ( hba ) ; hba = NULL ; } mutex_unlock ( & ioc -> sas_topology_mutex ) ; ioc -> num_ports = port_info -> num_phys ; for ( i = 0 ; i < port_info -> num_phys ; i ++ ) { mptsas_sas_phy_pg0 ( ioc , & port_info -> phy_info [ i ] , ( MPI_SAS_PHY_PGAD_FORM_PHY_NUMBER << MPI_SAS_PHY_PGAD_FORM_SHIFT ) , i ) ; port_info -> phy_info [ i ] . identify . handle = port_info -> phy_info [ i ] . handle ; mptsas_sas_device_pg0 ( ioc , & port_info -> phy_info [ i ] . identify , ( MPI_SAS_DEVICE_PGAD_FORM_HANDLE << MPI_SAS_DEVICE_PGAD_FORM_SHIFT ) , port_info -> phy_info [ i ] . identify . handle ) ; if ( ! ioc -> hba_port_sas_addr ) { ioc -> hba_port_sas_addr = port_info -> phy_info [ i ] . identify . sas_address ; } port_info -> phy_info [ i ] . identify . phy_id = port_info -> phy_info [ i ] . phy_id = i ; if ( port_info -> phy_info [ i ] . attached . handle ) { mptsas_sas_device_pg0 ( ioc , & port_info -> phy_info [ i ] . attached , ( MPI_SAS_DEVICE_PGAD_FORM_HANDLE << MPI_SAS_DEVICE_PGAD_FORM_SHIFT ) , port_info -> phy_info [ i ] . attached . handle ) ; } } mptsas_setup_wide_ports ( ioc , port_info ) ; for ( i = 0 ; i < port_info -> num_phys ; i ++ , ioc -> sas_index ++ ) { mptsas_probe_one_phy ( & ioc -> sh -> shost_gendev , & port_info -> phy_info [ i ] , ioc -> sas_index , 1 ) ; } return 0 ; out_free_port_info kfree ( hba ) ; out return error ; } 