static void spgSplitNodeAction ( Relation index , SpGistState * state , SpGistInnerTuple innerTuple , SPPageDesc * current , spgChooseOut * out ) { SpGistInnerTuple prefixTuple , postfixTuple ; SpGistNodeTuple node , * nodes ; BlockNumber postfixBlkno ; OffsetNumber postfixOffset ; int i ; spgxlogSplitTuple xlrec ; Buffer newBuffer = InvalidBuffer ; Assert ( ! SpGistPageStoresNulls ( current -> page ) ) ; if ( out -> result . splitTuple . prefixNNodes <= 0 || out -> result . splitTuple . prefixNNodes > SGITMAXNNODES ) { elog ( ERROR , "invalid number of prefix nodes: %d" , out -> result . splitTuple . prefixNNodes ) ; } if ( out -> result . splitTuple . childNodeN < 0 || out -> result . splitTuple . childNodeN >= out -> result . splitTuple . prefixNNodes ) { elog ( ERROR , "invalid child node number: %d" , out -> result . splitTuple . childNodeN ) ; } nodes = ( SpGistNodeTuple * ) palloc ( sizeof ( SpGistNodeTuple ) * out -> result . splitTuple . prefixNNodes ) ; for ( i = 0 ; i < out -> result . splitTuple . prefixNNodes ; i ++ ) { Datum label = ( Datum ) 0 ; bool labelisnull ; labelisnull = ( out -> result . splitTuple . prefixNodeLabels == NULL ) ; if ( ! labelisnull ) { label = out -> result . splitTuple . prefixNodeLabels [ i ] ; } nodes [ i ] = spgFormNodeTuple ( state , label , labelisnull ) ; } prefixTuple = spgFormInnerTuple ( state , out -> result . splitTuple . prefixHasPrefix , out -> result . splitTuple . prefixPrefixDatum , out -> result . splitTuple . prefixNNodes , nodes ) ; if ( prefixTuple -> size > innerTuple -> size ) { elog ( ERROR , "SPGiST inner-tuple split must not produce longer prefix" ) ; } nodes = palloc ( sizeof ( SpGistNodeTuple ) * innerTuple -> nNodes ) ; SGITITERATE ( , , ) { nodes [ i ] = node ; } postfixTuple = spgFormInnerTuple ( state , out -> result . splitTuple . postfixHasPrefix , out -> result . splitTuple . postfixPrefixDatum , innerTuple -> nNodes , nodes ) ; postfixTuple -> allTheSame = innerTuple -> allTheSame ; xlrec . newPage = false ; if ( SpGistBlockIsRoot ( current -> blkno ) || SpGistPageGetFreeSpace ( current -> page , 1 ) + innerTuple -> size < prefixTuple -> size + postfixTuple -> size + sizeof ( ItemIdData ) ) { newBuffer = SpGistGetBuffer ( index , GBUF_INNER_PARITY ( current -> blkno + 1 ) , postfixTuple -> size + sizeof ( ItemIdData ) , & xlrec . newPage ) ; } START_CRIT_SECTION ( ) ; PageIndexTupleDelete ( current -> page , current -> offnum ) ; xlrec . offnumPrefix = PageAddItem ( current -> page , ( Item ) prefixTuple , prefixTuple -> size , current -> offnum , false , false ) ; if ( xlrec . offnumPrefix != current -> offnum ) { elog ( ERROR , "failed to add item of size %u to SPGiST index page" , prefixTuple -> size ) ; } if ( newBuffer == InvalidBuffer ) { postfixBlkno = current -> blkno ; xlrec . offnumPostfix = postfixOffset = SpGistPageAddNewItem ( state , current -> page , ( Item ) postfixTuple , postfixTuple -> size , NULL , false ) ; xlrec . postfixBlkSame = true ; } else { postfixBlkno = BufferGetBlockNumber ( newBuffer ) ; xlrec . offnumPostfix = postfixOffset = SpGistPageAddNewItem ( state , BufferGetPage ( newBuffer ) , ( Item ) postfixTuple , postfixTuple -> size , NULL , false ) ; MarkBufferDirty ( newBuffer ) ; xlrec . postfixBlkSame = false ; } spgUpdateNodeLink ( prefixTuple , out -> result . splitTuple . childNodeN , postfixBlkno , postfixOffset ) ; prefixTuple = ( SpGistInnerTuple ) PageGetItem ( current -> page , PageGetItemId ( current -> page , current -> offnum ) ) ; spgUpdateNodeLink ( prefixTuple , out -> result . splitTuple . childNodeN , postfixBlkno , postfixOffset ) ; MarkBufferDirty ( current -> buffer ) ; if ( RelationNeedsWAL ( index ) && ! state -> isBuild ) { XLogRecPtr recptr ; XLogBeginInsert ( ) ; XLogRegisterData ( ( char * ) & xlrec , sizeof ( xlrec ) ) ; XLogRegisterData ( ( char * ) prefixTuple , prefixTuple -> size ) ; XLogRegisterData ( ( char * ) postfixTuple , postfixTuple -> size ) ; XLogRegisterBuffer ( 0 , current -> buffer , REGBUF_STANDARD ) ; if ( newBuffer != InvalidBuffer ) { int flags ; flags = REGBUF_STANDARD ; if ( xlrec . newPage ) { flags |= REGBUF_WILL_INIT ; } XLogRegisterBuffer ( 1 , newBuffer , flags ) ; } recptr = XLogInsert ( RM_SPGIST_ID , XLOG_SPGIST_SPLIT_TUPLE ) ; PageSetLSN ( current -> page , recptr ) ; if ( newBuffer != InvalidBuffer ) { PageSetLSN ( BufferGetPage ( newBuffer ) , recptr ) ; } } END_CRIT_SECTION ( ) ; } 