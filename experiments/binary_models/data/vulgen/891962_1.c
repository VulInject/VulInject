int storage_get_item ( conn * c , item * it , mc_resp * resp ) { item_hdr hdr ; memcpy ( & hdr , ITEM_data ( it ) , sizeof ( hdr ) ) ; item_hdr * hdr = ( item_hdr * ) ITEM_data ( it ) ; io_queue_t * q = conn_io_queue_get ( c , IO_QUEUE_EXTSTORE ) ; size_t ntotal = ITEM_ntotal ( it ) ; unsigned int clsid = slabs_clsid ( ntotal ) ; item * new_it ; bool chunked = false ; if ( ntotal > settings . slab_chunk_size_max ) { uint32_t flags ; FLAGS_CONV ( it , flags ) ; new_it = item_alloc ( ITEM_key ( it ) , it -> nkey , flags , it -> exptime , it -> nbytes ) ; chunked = true ; } else { new_it = do_item_alloc_pull ( ntotal , clsid ) ; } if ( new_it == NULL ) { return - 1 ; } new_it -> slabs_clsid = clsid ; io_pending_storage_t * p = do_cache_alloc ( c -> thread -> io_cache ) ; assert ( sizeof ( io_pending_t ) >= sizeof ( io_pending_storage_t ) ) ; memset ( p , 0 , sizeof ( io_pending_storage_t ) ) ; p -> active = true ; p -> miss = false ; p -> badcrc = false ; p -> noreply = c -> noreply ; p -> hdr_it = it ; p -> resp = resp ; p -> io_queue_type = IO_QUEUE_EXTSTORE ; obj_io * eio = & p -> io_ctx ; if ( chunked ) { unsigned int ciovcnt = 0 ; size_t remain = new_it -> nbytes ; item_chunk * chunk = ( item_chunk * ) ITEM_schunk ( new_it ) ; eio -> iov = malloc ( sizeof ( iovec ) * IOV_MAX ) ; if ( eio -> iov == NULL ) { item_remove ( new_it ) ; do_cache_free ( c -> thread -> io_cache , p ) ; return - 1 ; } eio -> iov [ 0 ] . iov_base = new_it ; eio -> iov [ 0 ] . iov_len = ITEM_ntotal ( new_it ) - new_it -> nbytes ; ciovcnt ++ ; while ( remain > 0 ) { chunk = do_item_alloc_chunk ( chunk , remain ) ; if ( chunk == NULL || ciovcnt > IOV_MAX - 1 ) { item_remove ( new_it ) ; free ( eio -> iov ) ; eio -> iov = NULL ; do_cache_free ( c -> thread -> io_cache , p ) ; return - 1 ; } eio -> iov [ ciovcnt ] . iov_base = chunk -> data ; eio -> iov [ ciovcnt ] . iov_len = ( remain < chunk -> size ) ?remain : chunk -> size ; chunk -> used = ( remain < chunk -> size ) ?remain : chunk -> size ; remain -= chunk -> size ; ciovcnt ++ ; } eio -> iovcnt = ciovcnt ; } p -> iovec_data = resp -> iovcnt ; int iovtotal = ( c -> protocol == binary_prot ) ?it -> nbytes - 2 : it -> nbytes ; if ( chunked ) { resp_add_chunked_iov ( resp , new_it , iovtotal ) ; } else { resp_add_iov ( resp , "" , iovtotal ) ; } resp -> io_pending = ( io_pending_t * ) p ; eio -> buf = ( void * ) new_it ; p -> c = c ; eio -> next = q -> stack_ctx ; q -> stack_ctx = eio ; assert ( q -> count >= 0 ) ; q -> count ++ ; eio -> data = ( void * ) p ; eio -> page_version = hdr . page_version ; eio -> page_id = hdr . page_id ; eio -> offset = hdr . offset ; eio -> page_version = hdr -> page_version ; eio -> page_id = hdr -> page_id ; eio -> offset = hdr -> offset ; eio -> len = ntotal ; eio -> mode = OBJ_IO_READ ; eio -> cb = _storage_get_item_cb ; pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . get_extstore ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; return 0 ; } 