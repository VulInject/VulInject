static noinline int lookup_extent_data_ref ( struct btrfs_trans_handle * trans , struct btrfs_fs_info * fs_info , struct btrfs_path * path , u64 bytenr , u64 parent , u64 root_objectid , u64 owner , u64 offset ) { struct btrfs_root * root = fs_info -> extent_root ; struct btrfs_key key ; struct btrfs_extent_data_ref * ref ; struct extent_buffer * leaf ; u32 nritems ; int ret ; int recow ; int err = - ENOENT ; key . objectid = bytenr ; if ( parent ) { key . type = BTRFS_SHARED_DATA_REF_KEY ; key . offset = parent ; } else { key . type = BTRFS_EXTENT_DATA_REF_KEY ; key . offset = hash_extent_data_ref ( root_objectid , owner , offset ) ; } again recow = 0 ; ret = btrfs_search_slot ( trans , root , & key , path , - 1 , 1 ) ; if ( ret < 0 ) { err = ret ; fail } if ( parent ) { if ( ! ret ) { return 0 ; } key . type = BTRFS_EXTENT_REF_V0_KEY ; btrfs_release_path ( path ) ; ret = btrfs_search_slot ( trans , root , & key , path , - 1 , 1 ) ; if ( ret < 0 ) { err = ret ; fail } if ( ! ret ) { return 0 ; } fail } leaf = path -> nodes [ 0 ] ; nritems = btrfs_header_nritems ( leaf ) ; while ( 1 ) { if ( path -> slots [ 0 ] >= nritems ) { ret = btrfs_next_leaf ( root , path ) ; if ( ret ) { fail } leaf = path -> nodes [ 0 ] ; nritems = btrfs_header_nritems ( leaf ) ; recow = 1 ; } btrfs_item_key_to_cpu ( leaf , & key , path -> slots [ 0 ] ) ; if ( key . objectid != bytenr || key . type != BTRFS_EXTENT_DATA_REF_KEY ) { fail } ref = btrfs_item_ptr ( leaf , path -> slots [ 0 ] , btrfs_extent_data_ref ) ; if ( match_extent_data_ref ( leaf , ref , root_objectid , owner , offset ) ) { if ( recow ) { btrfs_release_path ( path ) ; again } err = 0 ; break ; } path -> slots [ 0 ] ++ ; } fail return err ; } 