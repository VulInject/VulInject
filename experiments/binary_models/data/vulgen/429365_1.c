void uwsgi_hooks_setns_run ( struct uwsgi_string_list * l , pid_t pid , uid_t uid , gid_t gid ) { int * u_setns ( int , int ) ( int ( * ) ( int int ) ) dlsym ( RTLD_DEFAULT "setns" ) ; if ( ! u_setns ) { uwsgi_log ( "your system misses setns() syscall !!!\n" ) ; return ; } struct uwsgi_string_list * usl = NULL ; uwsgi_foreach ( , ) { pid_t new_pid = fork ( ) ; if ( new_pid > 0 ) { int status ; if ( waitpid ( new_pid , & status , 0 ) < 0 ) { uwsgi_error ( "uwsgi_hooks_setns_run()/waitpid()" ) ; } } if ( new_pid == 0 ) { char * action = strchr ( usl -> value , ' ' ) ; if ( ! action ) { uwsgi_log ( "invalid setns hook syntax, must be \"namespaces_list action:...\"\n" ) ; exit ( 1 ) ; } char * pidstr = uwsgi_num2str ( pid ) ; char * uidstr = uwsgi_num2str ( uid ) ; char * gidstr = uwsgi_num2str ( gid ) ; char * namespaces = uwsgi_concat2n ( usl -> value , action - usl -> value , "" , 0 ) ; char * p , * ctx = NULL ; uwsgi_foreach_token ( , "," , , ) { char * procfile = uwsgi_concat4 ( "/proc/" , pidstr , "/ns/" , p ) ; int fd = open ( procfile , O_RDONLY ) ; if ( u_setns ( fd , 0 ) < 0 ) { uwsgi_error ( "uwsgi_hooks_setns_run()/setns()" ) ; exit ( 1 ) ; } close ( fd ) ; free ( procfile ) ; } if ( setenv ( "UWSGI_VASSAL_PID" , pidstr , 1 ) ) { uwsgi_error ( "uwsgi_hooks_setns_run()/setenv()" ) ; exit ( 1 ) ; } if ( setenv ( "UWSGI_VASSAL_UID" , uidstr , 1 ) ) { uwsgi_error ( "uwsgi_hooks_setns_run()/setenv()" ) ; exit ( 1 ) ; } if ( setenv ( "UWSGI_VASSAL_GID" , gidstr , 1 ) ) { uwsgi_error ( "uwsgi_hooks_setns_run()/setenv()" ) ; exit ( 1 ) ; } action ++ ; char * colon = strchr ( action , ':' ) ; if ( ! colon ) { uwsgi_log ( "invalid hook syntax must be action:arg\n" ) ; exit ( 1 ) ; } * colon = 0 ; struct uwsgi_hook * uh = uwsgi_hook_by_name ( action ) ; if ( ! uh ) { uwsgi_log ( "hook action not found: %s\n" , action ) ; exit ( 1 ) ; } * colon = ':' ; uwsgi_log ( "running \"%s\" (setns)...\n" , usl -> value ) ; exit ( uh -> func ( colon + 1 ) ) ; } else { uwsgi_error ( "uwsgi_hooks_setns_run()/fork()" ) ; } } } 