static void do_operator1 ( card8 * * dest , card8 * limit , card8 * * data , card8 * endptr ) { card8 op = * * data ; * data += 1 ; switch ( op ) { case cs_hstemhm : case cs_vstemhm : case cs_hstem : case cs_vstem : if ( phase == 0 && ( cs2_stack_top % 2 ) ) { have_width = 1 ; width = cs2_arg_stack [ 0 ] ; } num_stems += cs2_stack_top / 2 ; clear_stack ( dest , limit ) ; DST_NEED ( limit , * dest + 1 ) ; * ( * dest ) ++ = op ; phase = 1 ; break ; case cs_hintmask : case cs_cntrmask : if ( phase < 2 ) { if ( phase == 0 && ( cs2_stack_top % 2 ) ) { have_width = 1 ; width = cs2_arg_stack [ 0 ] ; } num_stems += cs2_stack_top / 2 ; } clear_stack ( dest , limit ) ; DST_NEED ( limit , * dest + 1 ) ; * ( * dest ) ++ = op ; if ( num_stems > 0 ) { int masklen = ( num_stems + 7 ) / 8 ; DST_NEED ( limit , * dest + masklen ) ; memmove ( * dest , * data , ( size_t ) masklen ) ; * data += masklen ; * dest += masklen ; } phase = 2 ; break ; case cs_rmoveto : if ( phase == 0 && ( cs2_stack_top % 2 ) ) { have_width = 1 ; width = cs2_arg_stack [ 0 ] ; } clear_stack ( dest , limit ) ; DST_NEED ( limit , * dest + 1 ) ; * ( * dest ) ++ = op ; phase = 2 ; break ; case cs_hmoveto : case cs_vmoveto : if ( phase == 0 && ( cs2_stack_top % 2 ) == 0 ) { have_width = 1 ; width = cs2_arg_stack [ 0 ] ; } clear_stack ( dest , limit ) ; DST_NEED ( limit , * dest + 1 ) ; * ( * dest ) ++ = op ; phase = 2 ; break ; case cs_endchar : if ( cs2_stack_top == 1 ) { have_width = 1 ; width = cs2_arg_stack [ 0 ] ; clear_stack ( dest , limit ) ; } if ( cs2_stack_top == 4 || cs2_stack_top == 5 ) { normal_warning ( "cff" , "'seac' character deprecated in type 2 charstring" ) ; status = CS_PARSE_CFF_ERROR ; return ; } if ( cs2_stack_top > 0 ) { normal_warning ( "cff" , "operand stack not empty" ) ; } DST_NEED ( limit , * dest + 1 ) ; * ( * dest ) ++ = op ; status = CS_CHAR_END ; break ; case cs_setvsindex : normal_warning ( "cff2" , "unsupported setvindex operator" ) ; status = CS_PARSE_CFF_ERROR ; break ; case cs_blend : normal_warning ( "cff2" , "unsupported blend operator" ) ; status = CS_PARSE_CFF_ERROR ; break ; case cs_rlineto : case cs_hlineto : case cs_vlineto : case cs_rrcurveto : case cs_rcurveline : case cs_rlinecurve : case cs_vvcurveto : case cs_hhcurveto : case cs_vhcurveto : case cs_hvcurveto : if ( phase < 2 ) { normal_warning ( "cff" , "broken type 2 charstring" ) ; status = CS_PARSE_CFF_ERROR ; return ; } clear_stack ( dest , limit ) ; DST_NEED ( limit , * dest + 1 ) ; * ( * dest ) ++ = op ; break ; case cs_return : normal_error ( "cff" , "unexpected return" ) ; case cs_callgsubr : normal_error ( "cff" , "unexpected callgsubr" ) ; case cs_callsubr : normal_error ( "cff" , "unexpected callsubr" ) ; break ; default : formatted_warning ( "cff" , "%s: unknown charstring operator: 0x%02x" , CS_TYPE2_DEBUG_STR , op ) ; status = CS_PARSE_CFF_ERROR ; break ; } return ; } 