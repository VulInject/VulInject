static void lbmIODone ( struct bio * bio ) { struct lbuf * bp = bio -> bi_private ; struct lbuf * nextbp , * tail ; struct jfs_log * log ; unsigned long flags ; jfs_info ( "lbmIODone: bp:0x%p flag:0x%x" , bp , bp -> l_flag ) ; LCACHE_LOCK ( flags ) ; bp -> l_flag |= lbmDONE ; if ( bio -> bi_error ) { bp -> l_flag |= lbmERROR ; jfs_err ( "lbmIODone: I/O error in JFS log" ) ; } bio_put ( bio ) ; if ( bp -> l_flag & lbmREAD ) { bp -> l_flag &= ~ lbmREAD ; LCACHE_UNLOCK ( flags ) ; LCACHE_WAKEUP ( & bp -> l_ioevent ) ; return ; } bp -> l_flag &= ~ lbmWRITE ; INCREMENT ( lmStat . pagedone ) ; log = bp -> l_log ; log -> clsn = ( bp -> l_pn << L2LOGPSIZE ) + bp -> l_ceor ; if ( bp -> l_flag & lbmDIRECT ) { LCACHE_WAKEUP ( & bp -> l_ioevent ) ; LCACHE_UNLOCK ( flags ) ; return ; } tail = log -> wqueue ; if ( bp == tail ) { if ( bp -> l_flag & lbmRELEASE ) { log -> wqueue = NULL ; bp -> l_wqnext = NULL ; } } else { if ( bp -> l_flag & lbmRELEASE ) { nextbp = tail -> l_wqnext = bp -> l_wqnext ; bp -> l_wqnext = NULL ; } } if ( bp -> l_flag & lbmSYNC ) { LCACHE_UNLOCK ( flags ) ; LCACHE_WAKEUP ( & bp -> l_ioevent ) ; } if ( bp -> l_flag & lbmGC ) { LCACHE_UNLOCK ( flags ) ; lmPostGC ( bp ) ; } else { assert ( bp -> l_flag & lbmRELEASE ) ; assert ( bp -> l_flag & lbmFREE ) ; lbmfree ( bp ) ; LCACHE_UNLOCK ( flags ) ; } } 