static void ec_verify ( krb5_context context , krb5_data * req_pkt , krb5_kdc_req * request , krb5_enc_tkt_part * enc_tkt_reply , krb5_pa_data * data , krb5_kdcpreauth_callbacks cb , krb5_kdcpreauth_rock rock , krb5_kdcpreauth_moddata moddata , krb5_kdcpreauth_verify_respond_fn respond , void * arg ) { krb5_error_code ret ; krb5_enc_data * enc = NULL ; krb5_data der_enc_ts = empty_data ( ) , der_enc_data ; krb5_keyblock * armor_key = cb -> fast_armor ( context , rock ) ; krb5_pa_enc_ts * ts = NULL ; krb5_keyblock * client_keys = NULL ; krb5_keyblock * challenge_key = NULL ; krb5_keyblock * kdc_challenge_key ; krb5_kdcpreauth_modreq modreq = NULL ; int i = 0 ; char * ai = NULL , * realmstr = NULL ; krb5_data realm = request -> server -> realm ; if ( armor_key == NULL ) { ret = ENOENT ; k5_setmsg ( context , ret , _ ( "Encrypted Challenge used outside of FAST tunnel" ) ) ; cleanup } der_enc_data = make_data ( data -> contents , data -> length ) ; ret = decode_krb5_enc_data ( & der_enc_data , & enc ) ; if ( ret ) { cleanup } ret = alloc_data ( & der_enc_ts , enc -> ciphertext . length ) ; if ( ret ) { cleanup } realmstr = k5memdup0 ( realm . data , realm . length , & ret ) ; if ( realmstr == NULL ) { cleanup } ret = profile_get_string ( context -> profile , KRB5_CONF_REALMS , realmstr , KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR , NULL , & ai ) ; if ( ret ) { cleanup } ret = cb -> client_keys ( context , rock , & client_keys ) ; if ( ret ) { cleanup } for ( i = 0 ; client_keys [ i ] . enctype != ENCTYPE_NULL ; i ++ ) { ret = krb5_c_fx_cf2_simple ( context , armor_key , "clientchallengearmor" , & client_keys [ i ] , "challengelongterm" , & challenge_key ) ; if ( ret ) { cleanup } ret = krb5_c_decrypt ( context , challenge_key , KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT , NULL , enc , & der_enc_ts ) ; krb5_free_keyblock ( context , challenge_key ) ; if ( ! ret ) { break ; } } if ( client_keys [ i ] . enctype == ENCTYPE_NULL ) { ret = KRB5KDC_ERR_PREAUTH_FAILED ; k5_setmsg ( context , ret , _ ( "Incorrect password in encrypted challenge" ) ) ; cleanup } ret = decode_krb5_pa_enc_ts ( & der_enc_ts , & ts ) ; if ( ret ) { cleanup } ret = krb5_check_clockskew ( context , ts -> patimestamp ) ; if ( ret ) { cleanup } enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; if ( krb5_c_fx_cf2_simple ( context , armor_key , "kdcchallengearmor" , & client_keys [ i ] , "challengelongterm" , & kdc_challenge_key ) == 0 ) { modreq = ( krb5_kdcpreauth_modreq ) kdc_challenge_key ; } cleanup cb -> free_keys ( context , rock , client_keys ) ; free ( der_enc_ts . data ) ; krb5_free_enc_data ( context , enc ) ; krb5_free_pa_enc_ts ( context , ts ) ; free ( realmstr ) ; free ( ai ) ; * respond ( arg , ret , modreq , NULL , NULL ) ; } 