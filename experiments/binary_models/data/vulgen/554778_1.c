cg . predictedPlayerState . venomTime = oldPlayerState . venomTime ; if ( cg_animState . integer ) { cg . predictedPlayerState . aiState = cg_animState . integer - 1 ; } moved = qfalse ; for ( cmdNum = current - CMD_BACKUP + 1 ; cmdNum <= current ; cmdNum ++ ) { trap_GetUserCmd ( cmdNum , & cg_pmove . cmd ) ; trap_GetUserCmd ( cmdNum - 1 , & cg_pmove . oldcmd ) ; if ( cg_pmove . pmove_fixed ) { PM_UpdateViewAngles ( cg_pmove . ps , & cg_pmove . cmd , CG_Trace ) ; } if ( cg_pmove . cmd . serverTime <= cg . predictedPlayerState . commandTime ) { continue ; } if ( cg_pmove . cmd . serverTime > latestCmd . serverTime ) { continue ; } if ( cg . predictedPlayerState . commandTime == oldPlayerState . commandTime ) { vec3_t delta ; float len ; if ( cg_pmove . ps -> eFlags & EF_MG42_ACTIVE ) { VectorClear ( cg . predictedError ) ; } if ( cg . thisFrameTeleport ) { VectorClear ( cg . predictedError ) ; if ( cg_showmiss . integer ) { CG_Printf ( "PredictionTeleport\n" ) ; } cg . thisFrameTeleport = qfalse ; } else { vec3_t adjusted , new_angles ; CG_AdjustPositionForMover ( cg . predictedPlayerState . origin , cg . predictedPlayerState . groundEntityNum , cg . physicsTime , cg . oldTime , adjusted , cg . predictedPlayerState . viewangles , new_angles ) ; cg . predictedPlayerState . delta_angles [ YAW ] += ANGLE2SHORT ( deltaAngles [ YAW ] ) ; if ( cg_showmiss . integer ) { if ( ! VectorCompare ( oldPlayerState . origin , adjusted ) ) { CG_Printf ( "prediction error\n" ) ; } } VectorSubtract ( oldPlayerState . origin , adjusted , delta ) ; len = VectorLength ( delta ) ; if ( len > 0.1 ) { if ( cg_showmiss . integer ) { CG_Printf ( "Prediction miss: %f\n" , len ) ; } if ( cg_errorDecay . integer ) { int t ; float f ; t = cg . time - cg . predictedErrorTime ; f = ( cg_errorDecay . value - t ) / cg_errorDecay . value ; if ( f < 0 ) { f = 0 ; } if ( f > 0 && cg_showmiss . integer ) { CG_Printf ( "Double prediction decay: %f\n" , f ) ; } VectorScale ( cg . predictedError , f , cg . predictedError ) ; } else { VectorClear ( cg . predictedError ) ; } VectorAdd ( delta , cg . predictedError , cg . predictedError ) ; cg . predictedErrorTime = cg . oldTime ; } } } cg_pmove . gauntletHit = qfalse ; if ( cg_pmove . pmove_fixed ) { cg_pmove . cmd . serverTime = ( ( cg_pmove . cmd . serverTime + pmove_msec . integer - 1 ) / pmove_msec . integer ) * pmove_msec . integer ; } if ( strlen ( cg_missionStats . string ) > 1 || cg_norender . integer ) { cg_pmove . cmd . buttons = 0 ; cg_pmove . cmd . forwardmove = 0 ; cg_pmove . cmd . rightmove = 0 ; cg_pmove . cmd . upmove = 0 ; cg_pmove . cmd . wbuttons = 0 ; cg_pmove . cmd . wolfkick = 0 ; cg_pmove . cmd . angles [ 0 ] = cg_pmove . oldcmd . angles [ 0 ] ; cg_pmove . cmd . angles [ 1 ] = cg_pmove . oldcmd . angles [ 1 ] ; cg_pmove . cmd . angles [ 2 ] = cg_pmove . oldcmd . angles [ 2 ] ; } cg_pmove . gametype = cgs . gametype ; cg_pmove . ltChargeTime = cg_LTChargeTime . integer ; cg_pmove . soldierChargeTime = cg_soldierChargeTime . integer ; cg_pmove . engineerChargeTime = cg_engineerChargeTime . integer ; cg_pmove . medicChargeTime = cg_medicChargeTime . integer ; Pmove ( & cg_pmove ) ; moved = qtrue ; CG_TouchTriggerPrediction ( ) ; } if ( ! moved ) { if ( cg_showmiss . integer ) { CG_Printf ( "not moved\n" ) ; } return ; } CG_AdjustPositionForMover ( cg . predictedPlayerState . origin , cg . predictedPlayerState . groundEntityNum , cg . physicsTime , cg . time , cg . predictedPlayerState . origin , cg . predictedPlayerState . viewangles , cg . predictedPlayerState . viewangles ) ; CG_TransitionPlayerState ( & cg . predictedPlayerState , & oldPlayerState ) ; 