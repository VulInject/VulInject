int qede_get_cls_rule_entry ( struct qede_dev * edev , struct ethtool_rxnfc * cmd ) { struct qede_arfs_fltr_node * fltr = NULL ; int rc = 0 ; cmd -> data = QEDE_RFS_MAX_FLTR ; __qede_lock ( edev ) ; if ( ! edev -> arfs ) { rc = - EPERM ; unlock } fltr = qede_get_arfs_fltr_by_loc ( QEDE_ARFS_BUCKET_HEAD ( edev , 0 ) , fsp -> location ) ; if ( ! fltr ) { DP_NOTICE ( edev , "Rule not found - location=0x%x\n" , fsp -> location ) ; rc = - EINVAL ; unlock } if ( fltr -> tuple . eth_proto == htons ( ETH_P_IP ) ) { if ( fltr -> tuple . ip_proto == IPPROTO_TCP ) { fsp -> flow_type = TCP_V4_FLOW ; } else { fsp -> flow_type = UDP_V4_FLOW ; } fsp -> h_u . tcp_ip4_spec . psrc = fltr -> tuple . src_port ; fsp -> h_u . tcp_ip4_spec . pdst = fltr -> tuple . dst_port ; fsp -> h_u . tcp_ip4_spec . ip4src = fltr -> tuple . src_ipv4 ; fsp -> h_u . tcp_ip4_spec . ip4dst = fltr -> tuple . dst_ipv4 ; } else { if ( fltr -> tuple . ip_proto == IPPROTO_TCP ) { fsp -> flow_type = TCP_V6_FLOW ; } else { fsp -> flow_type = UDP_V6_FLOW ; } fsp -> h_u . tcp_ip6_spec . psrc = fltr -> tuple . src_port ; fsp -> h_u . tcp_ip6_spec . pdst = fltr -> tuple . dst_port ; memcpy ( & fsp -> h_u . tcp_ip6_spec . ip6src , & fltr -> tuple . src_ipv6 , sizeof ( in6_addr ) ) ; memcpy ( & fsp -> h_u . tcp_ip6_spec . ip6dst , & fltr -> tuple . dst_ipv6 , sizeof ( in6_addr ) ) ; } fsp -> ring_cookie = fltr -> rxq_id ; if ( fltr -> vfid ) { fsp -> ring_cookie |= ( ( u64 ) fltr -> vfid ) << ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF ; } if ( fltr -> b_is_drop ) { fsp -> ring_cookie = RX_CLS_FLOW_DISC ; } unlock __qede_unlock ( edev ) ; return rc ; } 