* * ; { * * ; case TRUE : { * pmap ; * pmaplist_t foo ; * ; } * * ; case FALSE : { } * ; } pmaplist_t ; * * Notice that the xdr declaration has no nxt pointer ; while if if , and then ( ) by the * xdr , pamplist_t . * * This could be implemented via the xdr_union primitive , though this * would cause a one recursive call per element in the list . Rather than ; { * that we can ` ` unwind '' the recursion * into a ; } while , yet is the data that the pointer points to which is interesting ; , { bool_t more_elements ; struct pmaplist * * next ; while ( TRUE ) { more_elements = ( bool_t ) ( * rp != NULL ) ; if ( ! xdr_bool ( xdrs , & more_elements ) ) { return ( FALSE ) ; } if ( ! more_elements ) { return ( TRUE ) ; } if ( freeing ) { next = & ( ( * rp ) -> pml_next ) ; } if ( ! xdr_reference ( xdrs , ( caddr_t * ) rp , ( u_int ) sizeof ( pmaplist ) , xdr_pmap ) ) { return ( FALSE ) ; } rp = ( freeing ) ?next : & ( ( * rp ) -> pml_next ) ; } } 