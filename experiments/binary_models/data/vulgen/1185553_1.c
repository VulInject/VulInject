static bool __ieee80211_sta_handle_tspec_ac_params ( struct ieee80211_sub_if_data * sdata ) { struct ieee80211_local * local = sdata -> local ; struct ieee80211_if_managed * ifmgd = & sdata -> u . mgd ; bool ret = false ; int ac ; if ( local -> hw . queues < IEEE80211_NUM_ACS ) { return false ; } for ( ac = 0 ; ac < IEEE80211_NUM_ACS ; ac ++ ) { struct ieee80211_sta_tx_tspec * tx_tspec = & ifmgd -> tx_tspec [ ac ] ; int non_acm_ac ; if ( tx_tspec -> action == TX_TSPEC_ACTION_NONE && tx_tspec -> admitted_time && time_after ( now , tx_tspec -> time_slice_start + HZ ) ) { tx_tspec -> consumed_tx_time = 0 ; tx_tspec -> time_slice_start = now ; if ( tx_tspec -> downgraded ) { tx_tspec -> action = TX_TSPEC_ACTION_STOP_DOWNGRADE ; } } switch ( tx_tspec -> action ) { case TX_TSPEC_ACTION_STOP_DOWNGRADE : if ( drv_conf_tx ( local , & sdata -> deflink , ac , & sdata -> deflink . tx_conf [ ac ] ) ) { link_err ( & sdata -> deflink , "failed to set TX queue parameters for queue %d\n" , ac ) ; } tx_tspec -> action = TX_TSPEC_ACTION_NONE ; tx_tspec -> downgraded = false ; ret = true ; break ; case TX_TSPEC_ACTION_DOWNGRADE : if ( time_after ( now , tx_tspec -> time_slice_start + HZ ) ) { tx_tspec -> action = TX_TSPEC_ACTION_NONE ; ret = true ; break ; } for ( non_acm_ac = ac + 1 ; non_acm_ac < IEEE80211_NUM_ACS ; non_acm_ac ++ ) { if ( ! ( sdata -> wmm_acm & BIT ( 7 - 2 * non_acm_ac ) ) ) { break ; } } if ( non_acm_ac >= IEEE80211_NUM_ACS ) { non_acm_ac = IEEE80211_AC_BK ; } if ( drv_conf_tx ( local , & sdata -> deflink , ac , & sdata -> deflink . tx_conf [ non_acm_ac ] ) ) { link_err ( & sdata -> deflink , "failed to set TX queue parameters for queue %d\n" , ac ) ; } tx_tspec -> action = TX_TSPEC_ACTION_NONE ; ret = true ; schedule_delayed_work ( & ifmgd -> tx_tspec_wk , tx_tspec -> time_slice_start + HZ - now + 1 ) ; break ; case TX_TSPEC_ACTION_NONE : break ; } } return ret ; } 