int emac_sgmii_config ( struct platform_device * pdev , struct emac_adapter * adpt ) { struct platform_device * sgmii_pdev = NULL ; struct emac_sgmii * phy = & adpt -> phy ; struct resource * res ; int ret ; if ( has_acpi_companion ( & pdev -> dev ) ) { struct device * dev ; dev = device_find_child ( & pdev -> dev , & phy -> initialize , emac_sgmii_acpi_match ) ; if ( ! dev ) { dev_err ( & pdev -> dev , "cannot find internal phy node\n" ) ; return - ENODEV ; } sgmii_pdev = to_platform_device ( dev ) ; } else { const struct of_device_id * match ; struct device_node * np ; np = of_parse_phandle ( pdev -> dev . of_node , "internal-phy" , 0 ) ; if ( ! np ) { dev_err ( & pdev -> dev , "missing internal-phy property\n" ) ; return - ENODEV ; } sgmii_pdev = of_find_device_by_node ( np ) ; if ( ! sgmii_pdev ) { dev_err ( & pdev -> dev , "invalid internal-phy property\n" ) ; return - ENODEV ; } match = of_match_device ( emac_sgmii_dt_match , & sgmii_pdev -> dev ) ; if ( ! match ) { dev_err ( & pdev -> dev , "unrecognized internal phy node\n" ) ; ret = - ENODEV ; error_put_device } phy -> initialize = ( emac_sgmii_function ) match -> data ; } phy -> open = emac_sgmii_open ; phy -> close = emac_sgmii_close ; phy -> link_up = emac_sgmii_link_up ; phy -> link_down = emac_sgmii_link_down ; res = platform_get_resource ( sgmii_pdev , IORESOURCE_MEM , 0 ) ; if ( ! res ) { ret = - EINVAL ; error_put_device } phy -> base = ioremap ( res -> start , resource_size ( res ) ) ; if ( ! phy -> base ) { ret = - ENOMEM ; error_put_device } res = platform_get_resource ( sgmii_pdev , IORESOURCE_MEM , 1 ) ; if ( res ) { phy -> digital = ioremap ( res -> start , resource_size ( res ) ) ; if ( ! phy -> digital ) { ret = - ENOMEM ; error_unmap_base } } ret = phy -> initialize ( adpt ) ; if ( ret ) { error } emac_sgmii_link_init ( adpt ) ; ret = platform_get_irq ( sgmii_pdev , 0 ) ; put_device ( & sgmii_pdev -> dev ) ; return 0 ; error if ( phy -> digital ) { iounmap ( phy -> digital ) ; } error_unmap_base iounmap ( phy -> base ) ; error_put_device put_device ( & sgmii_pdev -> dev ) ; return ret ; } 