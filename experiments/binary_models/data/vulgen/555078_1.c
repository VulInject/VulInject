static int ixgbe_ipsec_check_mgmt_ip ( struct xfrm_state * xs ) { struct net_device * dev = xs -> xso . real_dev ; struct ixgbe_adapter * adapter = netdev_priv ( dev ) ; struct ixgbe_hw * hw = & adapter -> hw ; u32 mfval , manc , reg ; int num_filters = 4 ; bool manc_ipv4 ; u32 bmcipval ; int i , j ; manc = IXGBE_READ_REG ( hw , IXGBE_MANC ) ; manc_ipv4 = ! ! ( manc & MANC_EN_IPV4_FILTER ) ; mfval = IXGBE_READ_REG ( hw , IXGBE_MFVAL ) ; bmcipval = IXGBE_READ_REG ( hw , IXGBE_BMCIPVAL ) ; if ( xs -> props . family == AF_INET ) { if ( manc_ipv4 ) { for ( i = 0 ; i < num_filters ; i ++ ) { reg = IXGBE_READ_REG ( hw , MIPAF_ARR ( 3 , i ) ) ; if ( reg == ( __force u32 ) xs -> id . daddr . a4 ) { return 1 ; } } } if ( ( bmcipval & BMCIP_MASK ) == BMCIP_V4 ) { reg = IXGBE_READ_REG ( hw , IXGBE_BMCIP ( 3 ) ) ; if ( reg == ( __force u32 ) xs -> id . daddr . a4 ) { return 1 ; } } } else { if ( manc_ipv4 ) { num_filters = 3 ; } for ( i = 0 ; i < num_filters ; i ++ ) { if ( ! ( mfval & BIT ( MFVAL_IPV6_FILTER_SHIFT + i ) ) ) { continue ; } for ( j = 0 ; j < 4 ; j ++ ) { reg = IXGBE_READ_REG ( hw , MIPAF_ARR ( i , j ) ) ; if ( reg != ( __force u32 ) xs -> id . daddr . a6 [ j ] ) { break ; } } if ( j == 4 ) { return 1 ; } } if ( ( bmcipval & BMCIP_MASK ) == BMCIP_V6 ) { for ( j = 0 ; j < 4 ; j ++ ) { reg = IXGBE_READ_REG ( hw , IXGBE_BMCIP ( j ) ) ; if ( reg != ( __force u32 ) xs -> id . daddr . a6 [ j ] ) { break ; } } if ( j == 4 ) { return 1 ; } } } return 0 ; } 