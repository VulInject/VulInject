convert_class_to_reference ( , , ) { tree conversions ; tree arglist ; conversion * conv ; tree reference_type ; struct z_candidate * candidates ; struct z_candidate * cand ; bool any_viable_p ; conversions = lookup_conversions ( s ) ; if ( ! conversions ) { return NULL ; } candidates = 0 ; arglist = build_int_cst ( build_pointer_type ( s ) , 0 ) ; arglist = build_tree_list ( NULL_TREE , arglist ) ; reference_type = build_reference_type ( t ) ; while ( conversions ) { tree fns = TREE_VALUE ( conversions ) ; for ( ; fns ; fns = OVL_NEXT ( fns ) ) { tree f = OVL_CURRENT ( fns ) ; tree t2 = TREE_TYPE ( TREE_TYPE ( f ) ) ; cand = NULL ; if ( TREE_CODE ( t2 ) == REFERENCE_TYPE && reference_compatible_p ( t , TREE_TYPE ( t2 ) ) ) { cand = add_function_candidate ( & candidates , f , s , arglist , TYPE_BINFO ( s ) , TREE_PURPOSE ( conversions ) , LOOKUP_NORMAL ) ; } if ( cand ) { conversion * identity_conv ; identity_conv = build_identity_conv ( TREE_TYPE ( TREE_TYPE ( TREE_TYPE ( cand -> fn ) ) ) , NULL_TREE ) ; cand -> second_conv = ( direct_reference_binding ( reference_type , identity_conv ) ) ; cand -> second_conv -> bad_p |= cand -> convs [ 0 ] -> bad_p ; } } conversions = TREE_CHAIN ( conversions ) ; } candidates = splice_viable ( candidates , pedantic , & any_viable_p ) ; if ( ! any_viable_p ) { return NULL ; } cand = tourney ( candidates ) ; if ( ! cand ) { return NULL ; } cand -> args = tree_cons ( NULL_TREE , build_this ( expr ) , TREE_CHAIN ( cand -> args ) ) ; conv = build_conv ( ck_user , TREE_TYPE ( TREE_TYPE ( cand -> fn ) ) , build_identity_conv ( TREE_TYPE ( expr ) , expr ) ) ; conv -> cand = cand ; cand -> second_conv = merge_conversion_sequences ( conv , cand -> second_conv ) ; if ( cand -> viable == - 1 ) { conv -> bad_p = true ; } return cand -> second_conv ; } 