static void soap_error_handler ( int error_num , zend_string * error_filename , const uint32_t error_lineno , zend_string * message ) bool _old_handler = SOAP_GLOBAL ( use_soap_error_handler ) ; char * _old_error_code = SOAP_GLOBAL ( error_code ) ; zend_object * _old_error_object = Z_OBJ ( SOAP_GLOBAL ( error_object ) ) ; int _old_soap_version = SOAP_GLOBAL ( soap_version ) ; SOAP_GLOBAL ( use_soap_error_handler ) = 1 ; SOAP_GLOBAL ( error_code ) = "Server" ; Z_OBJ ( SOAP_GLOBAL ( error_object ) ) = Z_OBJ_P ( ZEND_THIS ) ; SOAP_GLOBAL ( use_soap_error_handler ) = _old_handler ; SOAP_GLOBAL ( error_code ) = _old_error_code ; Z_OBJ ( SOAP_GLOBAL ( error_object ) ) = _old_error_object ; SOAP_GLOBAL ( soap_version ) = _old_soap_version ; bool _old_handler = SOAP_GLOBAL ( use_soap_error_handler ) ; char * _old_error_code = SOAP_GLOBAL ( error_code ) ; zend_object * _old_error_object = Z_OBJ ( SOAP_GLOBAL ( error_object ) ) ; int _old_soap_version = SOAP_GLOBAL ( soap_version ) ; bool _old_in_compilation = CG ( in_compilation ) ; zend_execute_data * _old_current_execute_data = EG ( current_execute_data ) ; int _bailout = 0 ; SOAP_GLOBAL ( use_soap_error_handler ) = 1 ; SOAP_GLOBAL ( error_code ) = "Client" ; Z_OBJ ( SOAP_GLOBAL ( error_object ) ) = Z_OBJ_P ( ZEND_THIS ) ; zend_try { } zend_catch { CG ( in_compilation ) = _old_in_compilation ; EG ( current_execute_data ) = _old_current_execute_data ; if ( EG ( exception ) == NULL || ! instanceof_function ( EG ( exception ) -> ce , soap_fault_class_entry ) ) { _bailout = 1 ; } if ( _old_stack_top != EG ( vm_stack_top ) ) { while ( EG ( vm_stack ) -> prev != NULL && ( ( char * ) _old_stack_top < ( char * ) EG ( vm_stack ) || ( char * ) _old_stack_top > ( char * ) EG ( vm_stack ) -> end ) ) { zend_vm_stack tmp = EG ( vm_stack ) -> prev ; efree ( EG ( vm_stack ) ) ; EG ( vm_stack ) = tmp ; EG ( vm_stack_end ) = tmp -> end ; } EG ( vm_stack ) -> top = _old_stack_top ; } } zend_end_try ( ) ; SOAP_GLOBAL ( use_soap_error_handler ) = _old_handler ; SOAP_GLOBAL ( error_code ) = _old_error_code ; Z_OBJ ( SOAP_GLOBAL ( error_object ) ) = _old_error_object ; SOAP_GLOBAL ( soap_version ) = _old_soap_version ; if ( _bailout ) { zend_bailout ( ) ; } { zval * __tmp = Z_CLIENT_SDL_P ( ZEND_THIS ) ; if ( Z_TYPE_P ( __tmp ) == IS_RESOURCE ) { FETCH_SDL_RES ( ss , __tmp ) ; } else { ss = NULL ; } } { ss = soap_server_object_fetch ( Z_OBJ_P ( ZEND_THIS ) ) -> service ; if ( ! ss ) { zend_throw_error ( NULL , "Cannot fetch SoapServer object" ) ; SOAP_SERVER_END_CODE ( ) ; RETURN_THROWS ( ) ; } } zend_class_entry * soap_class_entry ; static zend_class_entry * soap_server_class_entry ; static zend_class_entry * soap_fault_class_entry ; static zend_class_entry * soap_header_class_entry ; static zend_class_entry * soap_param_class_entry ; zend_class_entry * soap_var_class_entry ; static zend_object_handlers soap_server_object_handlers ; { soapServicePtr service ; zend_object std ; } soap_server_object 