sh_coff_get_relocated_section_contents ( , , , , , ) bfd * output_bfd ; struct bfd_link_info * link_info ; struct bfd_link_order * link_order ; bfd_byte * data ; bfd_boolean relocatable ; asymbol * * symbols ; { asection * input_section = link_order -> u . indirect . section ; bfd * input_bfd = input_section -> owner ; asection * * sections = NULL ; struct internal_reloc * internal_relocs = NULL ; struct internal_syment * internal_syms = NULL ; if ( relocatable || coff_section_data ( input_bfd , input_section ) == NULL || coff_section_data ( input_bfd , input_section ) -> contents == NULL ) { return bfd_generic_get_relocated_section_contents ( output_bfd , link_info , link_order , data , relocatable , symbols ) ; } memcpy ( data , coff_section_data ( input_bfd , input_section ) -> contents , ( size_t ) input_section -> size ) ; if ( ( input_section -> flags & SEC_RELOC ) != 0 && input_section -> reloc_count > 0 ) { bfd_size_type symesz = bfd_coff_symesz ( input_bfd ) ; bfd_byte * esym , * esymend ; struct internal_syment * isymp ; asection * * secpp ; bfd_size_type amt ; if ( ! _bfd_coff_get_external_symbols ( input_bfd ) ) { error_return } internal_relocs = ( _bfd_coff_read_internal_relocs ( input_bfd , input_section , FALSE , ( bfd_byte * ) NULL , FALSE , ( internal_reloc * ) NULL ) ) ; if ( internal_relocs == NULL ) { error_return } amt = obj_raw_syment_count ( input_bfd ) ; amt *= sizeof ( internal_syment ) ; internal_syms = ( internal_syment * ) bfd_malloc ( amt ) ; if ( internal_syms == NULL ) { error_return } amt = obj_raw_syment_count ( input_bfd ) ; amt *= sizeof ( asection * ) ; sections = ( asection * * ) bfd_malloc ( amt ) ; if ( sections == NULL ) { error_return } isymp = internal_syms ; secpp = sections ; esym = ( bfd_byte * ) obj_coff_external_syms ( input_bfd ) ; esymend = esym + obj_raw_syment_count ( input_bfd ) * symesz ; while ( esym < esymend ) { bfd_coff_swap_sym_in ( input_bfd , ( PTR ) esym , ( PTR ) isymp ) ; if ( isymp -> n_scnum != 0 ) { * secpp = coff_section_from_bfd_index ( input_bfd , isymp -> n_scnum ) ; } else { if ( isymp -> n_value == 0 ) { * secpp = bfd_und_section_ptr ; } else { * secpp = bfd_com_section_ptr ; } } esym += ( isymp -> n_numaux + 1 ) * symesz ; secpp += isymp -> n_numaux + 1 ; isymp += isymp -> n_numaux + 1 ; } if ( ! sh_relocate_section ( output_bfd , link_info , input_bfd , input_section , data , internal_relocs , internal_syms , sections ) ) { error_return } free ( sections ) ; sections = NULL ; free ( internal_syms ) ; internal_syms = NULL ; free ( internal_relocs ) ; internal_relocs = NULL ; } return data ; error_return if ( internal_relocs != NULL ) { free ( internal_relocs ) ; } if ( internal_syms != NULL ) { free ( internal_syms ) ; } return NULL ; } 