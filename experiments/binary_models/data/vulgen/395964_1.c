void fnic_handle_fip_timer ( struct fnic * fnic ) { unsigned long flags ; struct fcoe_vlan * vlan ; struct fnic_stats * fnic_stats = & fnic -> fnic_stats ; u64 sol_time ; spin_lock_irqsave ( & fnic -> fnic_lock , flags ) ; if ( fnic -> stop_rx_link_events ) { spin_unlock_irqrestore ( & fnic -> fnic_lock , flags ) ; return ; } spin_unlock_irqrestore ( & fnic -> fnic_lock , flags ) ; if ( fnic -> ctlr . mode == FIP_MODE_NON_FIP ) { return ; } spin_lock_irqsave ( & fnic -> vlans_lock , flags ) ; if ( list_empty ( & fnic -> vlans ) ) { if ( printk_ratelimit ( ) ) { FNIC_FCS_DBG ( KERN_DEBUG , fnic -> lport -> host , "Start VLAN Discovery\n" ) ; } fnic_event_enq ( fnic , FNIC_EVT_START_VLAN_DISC ) ; return ; } vlan = list_first_entry ( & fnic -> vlans , fcoe_vlan , list ) ; shost_printk ( KERN_DEBUG , fnic -> lport -> host , "fip_timer: vlan %d state %d sol_count %d\n" , vlan -> vid , vlan -> state , vlan -> sol_count ) ; switch ( vlan -> state ) { case FIP_VLAN_USED : FNIC_FCS_DBG ( KERN_DEBUG , fnic -> lport -> host , "FIP VLAN is selected for FC transaction\n" ) ; spin_unlock_irqrestore ( & fnic -> vlans_lock , flags ) ; break ; case FIP_VLAN_FAILED : spin_unlock_irqrestore ( & fnic -> vlans_lock , flags ) ; if ( printk_ratelimit ( ) ) { FNIC_FCS_DBG ( KERN_DEBUG , fnic -> lport -> host , "Start VLAN Discovery\n" ) ; } fnic_event_enq ( fnic , FNIC_EVT_START_VLAN_DISC ) ; break ; case FIP_VLAN_SENT : if ( vlan -> sol_count >= FCOE_CTLR_MAX_SOL ) { shost_printk ( KERN_INFO , fnic -> lport -> host , "Dequeue this VLAN ID %d from list\n" , vlan -> vid ) ; list_del ( & vlan -> list ) ; kfree ( vlan ) ; vlan = NULL ; if ( list_empty ( & fnic -> vlans ) ) { spin_unlock_irqrestore ( & fnic -> vlans_lock , flags ) ; shost_printk ( KERN_INFO , fnic -> lport -> host , "fip_timer: vlan list empty, " "trigger vlan disc\n" ) ; fnic_event_enq ( fnic , FNIC_EVT_START_VLAN_DISC ) ; return ; } vlan = list_first_entry ( & fnic -> vlans , fcoe_vlan , list ) ; fnic -> set_vlan ( fnic , vlan -> vid ) ; vlan -> state = FIP_VLAN_SENT ; } spin_unlock_irqrestore ( & fnic -> vlans_lock , flags ) ; atomic64_inc ( & fnic_stats -> vlan_stats . sol_expiry_count ) ; vlan -> sol_count ++ ; sol_time = jiffies + msecs_to_jiffies ( FCOE_CTLR_START_DELAY ) ; mod_timer ( & fnic -> fip_timer , round_jiffies ( sol_time ) ) ; break ; } } 