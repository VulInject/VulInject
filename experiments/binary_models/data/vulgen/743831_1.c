static int rtl_op_add_interface ( struct ieee80211_hw * hw , struct ieee80211_vif * vif ) { struct rtl_priv * rtlpriv = rtl_priv ( hw ) ; struct rtl_mac * mac = rtl_mac ( rtl_priv ( hw ) ) ; int err = 0 ; u8 retry_limit = 0x30 ; if ( mac -> vif ) { rtl_dbg ( rtlpriv , COMP_ERR , DBG_WARNING , "vif has been set!! mac->vif = 0x%p\n" , mac -> vif ) ; return - EOPNOTSUPP ; } vif -> driver_flags |= IEEE80211_VIF_BEACON_FILTER ; rtl_ips_nic_on ( hw ) ; mutex_lock ( & rtlpriv -> locks . conf_mutex ) ; switch ( ieee80211_vif_type_p2p ( vif ) ) { case NL80211_IFTYPE_P2P_CLIENT : mac -> p2p = P2P_ROLE_CLIENT ; fallthrough ; case NL80211_IFTYPE_STATION : if ( mac -> beacon_enabled == 1 ) { rtl_dbg ( rtlpriv , COMP_MAC80211 , DBG_LOUD , "NL80211_IFTYPE_STATION\n" ) ; mac -> beacon_enabled = 0 ; } break ; case NL80211_IFTYPE_ADHOC : rtl_dbg ( rtlpriv , COMP_MAC80211 , DBG_LOUD , "NL80211_IFTYPE_ADHOC\n" ) ; mac -> link_state = MAC80211_LINKED ; rtlpriv -> cfg -> ops -> set_bcn_reg ( hw ) ; if ( rtlpriv -> rtlhal . current_bandtype == BAND_ON_2_4G ) { mac -> basic_rates = 0xfff ; } else { mac -> basic_rates = 0xff0 ; } rtlpriv -> cfg -> ops -> set_hw_reg ( hw , HW_VAR_BASIC_RATE , ( u8 * ) ( & mac -> basic_rates ) ) ; retry_limit = 0x07 ; break ; case NL80211_IFTYPE_P2P_GO : mac -> p2p = P2P_ROLE_GO ; fallthrough ; case NL80211_IFTYPE_AP : rtl_dbg ( rtlpriv , COMP_MAC80211 , DBG_LOUD , "NL80211_IFTYPE_AP\n" ) ; mac -> link_state = MAC80211_LINKED ; rtlpriv -> cfg -> ops -> set_bcn_reg ( hw ) ; if ( rtlpriv -> rtlhal . current_bandtype == BAND_ON_2_4G ) { mac -> basic_rates = 0xfff ; } else { mac -> basic_rates = 0xff0 ; } rtlpriv -> cfg -> ops -> set_hw_reg ( hw , HW_VAR_BASIC_RATE , ( u8 * ) ( & mac -> basic_rates ) ) ; retry_limit = 0x07 ; break ; case NL80211_IFTYPE_MESH_POINT : rtl_dbg ( rtlpriv , COMP_MAC80211 , DBG_LOUD , "NL80211_IFTYPE_MESH_POINT\n" ) ; mac -> link_state = MAC80211_LINKED ; rtlpriv -> cfg -> ops -> set_bcn_reg ( hw ) ; if ( rtlpriv -> rtlhal . current_bandtype == BAND_ON_2_4G ) { mac -> basic_rates = 0xfff ; } else { mac -> basic_rates = 0xff0 ; } rtlpriv -> cfg -> ops -> set_hw_reg ( hw , HW_VAR_BASIC_RATE , ( u8 * ) ( & mac -> basic_rates ) ) ; retry_limit = 0x07 ; break ; default : pr_err ( "operation mode %d is not supported!\n" , vif -> type ) ; err = - EOPNOTSUPP ; out } if ( mac -> p2p ) { rtl_dbg ( rtlpriv , COMP_MAC80211 , DBG_LOUD , "p2p role %x\n" , vif -> type ) ; mac -> basic_rates = 0xff0 ; rtlpriv -> cfg -> ops -> set_hw_reg ( hw , HW_VAR_BASIC_RATE , ( u8 * ) ( & mac -> basic_rates ) ) ; } mac -> vif = vif ; mac -> opmode = vif -> type ; rtlpriv -> cfg -> ops -> set_network_type ( hw , vif -> type ) ; memcpy ( mac -> mac_addr , vif -> addr , ETH_ALEN ) ; rtlpriv -> cfg -> ops -> set_hw_reg ( hw , HW_VAR_ETHER_ADDR , mac -> mac_addr ) ; mac -> retry_long = retry_limit ; mac -> retry_short = retry_limit ; rtlpriv -> cfg -> ops -> set_hw_reg ( hw , HW_VAR_RETRY_LIMIT , ( u8 * ) ( & retry_limit ) ) ; out mutex_unlock ( & rtlpriv -> locks . conf_mutex ) ; return err ; } 