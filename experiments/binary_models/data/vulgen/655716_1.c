static int gpio_ir_recv_probe ( struct platform_device * pdev ) { struct gpio_rc_dev * gpio_dev ; struct rc_dev * rcdev ; const struct gpio_ir_recv_platform_data * pdata = pdev -> dev . platform_data ; int rc ; if ( pdev -> dev . of_node ) { struct gpio_ir_recv_platform_data * dtpdata = devm_kzalloc ( & pdev -> dev , sizeof ( * dtpdata ) , GFP_KERNEL ) ; if ( ! dtpdata ) { return - ENOMEM ; } rc = gpio_ir_recv_get_devtree_pdata ( & pdev -> dev , dtpdata ) ; if ( rc ) { return rc ; } pdata = dtpdata ; } if ( ! pdata ) { return - EINVAL ; } if ( pdata -> gpio_nr < 0 ) { return - EINVAL ; } gpio_dev = kzalloc ( sizeof ( gpio_rc_dev ) , GFP_KERNEL ) ; if ( ! gpio_dev ) { return - ENOMEM ; } rcdev = rc_allocate_device ( RC_DRIVER_IR_RAW ) ; if ( ! rcdev ) { rc = - ENOMEM ; err_allocate_device } rcdev -> priv = gpio_dev ; rcdev -> input_name = GPIO_IR_DEVICE_NAME ; rcdev -> input_phys = GPIO_IR_DEVICE_NAME "/input0" ; rcdev -> input_id . bustype = BUS_HOST ; rcdev -> input_id . vendor = 0x0001 ; rcdev -> input_id . product = 0x0001 ; rcdev -> input_id . version = 0x0100 ; rcdev -> dev . parent = & pdev -> dev ; rcdev -> driver_name = GPIO_IR_DRIVER_NAME ; rcdev -> min_timeout = 1 ; rcdev -> timeout = IR_DEFAULT_TIMEOUT ; if ( pdata -> allowed_protos ) { rcdev -> allowed_protocols = pdata -> allowed_protos ; } else { rcdev -> allowed_protocols = RC_BIT_ALL_IR_DECODER ; } rcdev -> map_name = pdata -> map_name ?: RC_MAP_EMPTY ; gpio_dev -> rcdev = rcdev ; gpio_dev -> gpio_nr = pdata -> gpio_nr ; gpio_dev -> active_low = pdata -> active_low ; setup_timer ( & gpio_dev -> flush_timer , flush_timer , ( unsigned long ) gpio_dev ) ; rc = gpio_request ( pdata -> gpio_nr , "gpio-ir-recv" ) ; if ( rc < 0 ) { err_gpio_request } rc = gpio_direction_input ( pdata -> gpio_nr ) ; if ( rc < 0 ) { err_gpio_direction_input } rc = rc_register_device ( rcdev ) ; if ( rc < 0 ) { dev_err ( & pdev -> dev , "failed to register rc device\n" ) ; err_register_rc_device } platform_set_drvdata ( pdev , gpio_dev ) ; rc = request_any_context_irq ( gpio_to_irq ( pdata -> gpio_nr ) , gpio_ir_recv_irq , IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING , "gpio-ir-recv-irq" , gpio_dev ) ; if ( rc < 0 ) { err_request_irq } return 0 ; err_request_irq rc_unregister_device ( rcdev ) ; rcdev = NULL ; err_register_rc_device err_gpio_direction_input gpio_free ( pdata -> gpio_nr ) ; err_gpio_request rc_free_device ( rcdev ) ; err_allocate_device kfree ( gpio_dev ) ; return rc ; } 