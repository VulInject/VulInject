int BufferLoadCRL ( WOLFSSL_CRL * crl , const byte * buff , long sz , int type , int verify ) { int ret = WOLFSSL_SUCCESS ; const byte * myBuffer = buff ; DerBuffer * der = NULL ; DecodedCRL * dcrl ; DecodedCRL dcrl [ 1 ] ; WOLFSSL_ENTER ( "BufferLoadCRL" ) ; if ( crl == NULL || buff == NULL || sz == 0 ) { return BAD_FUNC_ARG ; } if ( type == WOLFSSL_FILETYPE_PEM ) { ret = PemToDer ( buff , sz , CRL_TYPE , & der , NULL , NULL , NULL ) ; if ( ret == 0 ) { myBuffer = der -> buffer ; sz = der -> length ; } else { WOLFSSL_MSG ( "Pem to Der failed" ) ; return - 1 ; } ret = NOT_COMPILED_IN ; } dcrl = ( DecodedCRL * ) XMALLOC ( sizeof ( DecodedCRL ) , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ; if ( dcrl == NULL ) { FreeDer ( & der ) ; return MEMORY_E ; } crl -> currentEntry = ( CRL_Entry * ) XMALLOC ( sizeof ( CRL_Entry ) , crl -> heap , DYNAMIC_TYPE_CRL_ENTRY ) ; if ( crl -> currentEntry == NULL ) { WOLFSSL_MSG ( "alloc CRL Entry failed" ) ; return MEMORY_E ; } XMEMSET ( crl -> currentEntry , 0 , sizeof ( CRL_Entry ) ) ; InitDecodedCRL ( dcrl , crl -> heap ) ; ret = ParseCRL ( crl -> currentEntry -> certs , dcrl , myBuffer , ( word32 ) sz , verify , crl -> cm ) ; if ( ret != 0 && ! ( ret == ASN_CRL_NO_SIGNER_E && verify == NO_VERIFY ) ) { WOLFSSL_MSG ( "ParseCRL error" ) ; XFREE ( crl -> currentEntry , crl -> heap , DYNAMIC_TYPE_CRL_ENTRY ) ; crl -> currentEntry = NULL ; } else { ret = AddCRL ( crl , dcrl , myBuffer , ret != ASN_CRL_NO_SIGNER_E ) ; if ( ret != 0 ) { WOLFSSL_MSG ( "AddCRL error" ) ; } } FreeDecodedCRL ( dcrl ) ; XFREE ( dcrl , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ; FreeDer ( & der ) ; return ret ?ret : WOLFSSL_SUCCESS ; } 