char * gcvt ( double value , int ndigit , char * buf ) { char * digits , * dst , * src ; int i , decpt , sign ; struct lconv * lconv ; lconv = localeconv ( ) ; if ( ndigit <= 0 ) { ndigit = ndigit ?DEFPREC : 1 ; } digits = __dtoa ( value , 2 , ndigit , & decpt , & sign , NULL ) ; if ( digits == NULL ) { return ( NULL ) ; } if ( decpt == 9999 ) { snprintf ( buf , 5 , "%s%s" , sign ?"-" : "" , * digits == 'I' ?"inf" : "nan" ) ; return ( buf ) ; } dst = buf ; if ( sign ) { * dst ++ = '-' ; } if ( decpt <= - 4 || decpt > ndigit ) { if ( -- decpt < 0 ) { sign = 1 ; decpt = - decpt ; } else { sign = 0 ; } src = digits ; * dst ++ = * src ++ ; if ( * src != '\0' ) { * dst ++ = * lconv -> decimal_point ; { * dst ++ = * src ++ ; } * src != '\0' ; } * dst ++ = 'e' ; if ( sign ) { * dst ++ = '-' ; } else { * dst ++ = '+' ; } if ( decpt < 10 ) { * dst ++ = '0' ; * dst ++ = '0' + decpt ; * dst = '\0' ; } else { for ( sign = decpt , i = 0 ; ( sign /= 10 ) != 0 ; i ++ ) { continue ; } dst [ i + 1 ] = '\0' ; while ( decpt != 0 ) { dst [ i -- ] = '0' + decpt % 10 ; decpt /= 10 ; } } } else { for ( i = 0 , src = digits ; i < decpt ; i ++ ) { if ( * src != '\0' ) { * dst ++ = * src ++ ; } else { * dst ++ = '0' ; } } if ( * src != '\0' ) { if ( src == digits ) { * dst ++ = '0' ; } * dst ++ = * lconv -> decimal_point ; while ( decpt < 0 ) { * dst ++ = '0' ; decpt ++ ; } for ( i = decpt ; digits [ i ] != '\0' ; i ++ ) { * dst ++ = digits [ i ] ; } } * dst = '\0' ; } __freedtoa ( digits ) ; return ( buf ) ; } 