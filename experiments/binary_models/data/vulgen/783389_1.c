static int lnet_ptl_match_delay ( struct lnet_portal * ptl , struct lnet_match_info * info , struct lnet_msg * msg ) { int first = ptl -> ptl_mt_maps [ 0 ] ; int rc = 0 ; int i ; LASSERT ( lnet_ptl_is_wildcard ( ptl ) ) ; for ( i = 0 ; i < LNET_CPT_NUMBER ; i ++ ) { struct lnet_match_table * mtable ; int cpt ; cpt = ( first + i ) % LNET_CPT_NUMBER ; mtable = ptl -> ptl_mtables [ cpt ] ; if ( i && i != LNET_CPT_NUMBER - 1 && ! mtable -> mt_enabled ) { continue ; } lnet_res_lock ( cpt ) ; lnet_ptl_lock ( ptl ) ; if ( ! i ) { list_add_tail ( & msg -> msg_list , & ptl -> ptl_msg_stealing ) ; } if ( ! list_empty ( & msg -> msg_list ) ) { rc = lnet_mt_match_md ( mtable , info , msg ) ; if ( ( rc & LNET_MATCHMD_EXHAUSTED ) && mtable -> mt_enabled ) { lnet_ptl_disable_mt ( ptl , cpt ) ; } if ( rc & LNET_MATCHMD_FINISH ) { list_del_init ( & msg -> msg_list ) ; } if ( i == LNET_CPT_NUMBER - 1 || ! ptl -> ptl_mt_nmaps || ( ptl -> ptl_mt_nmaps == 1 && ptl -> ptl_mt_maps [ 0 ] == cpt ) ) { list_del_init ( & msg -> msg_list ) ; if ( lnet_ptl_is_lazy ( ptl ) ) { list_add_tail ( & msg -> msg_list , & ptl -> ptl_msg_delayed ) ; rc = LNET_MATCHMD_NONE ; } else { rc = LNET_MATCHMD_DROP ; } } else { rc = 0 ; } } else { rc = ! msg -> msg_md ?LNET_MATCHMD_DROP : LNET_MATCHMD_OK ; } lnet_ptl_unlock ( ptl ) ; lnet_res_unlock ( cpt ) ; if ( rc & ( LNET_MATCHMD_FINISH | LNET_MATCHMD_NONE ) ) { break ; } } return rc ; } 