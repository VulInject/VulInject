uint32_t dpif_miniflow_extract_autovalidator ( struct dp_packet_batch * packets , struct netdev_flow_key * keys , uint32_t keys_size , odp_port_t in_port , struct dp_netdev_pmd_thread * pmd_handle ) { const size_t cnt = dp_packet_batch_size ( packets ) ; uint16_t good_l2_5_ofs [ NETDEV_MAX_BURST ] ; uint16_t good_l3_ofs [ NETDEV_MAX_BURST ] ; uint16_t good_l4_ofs [ NETDEV_MAX_BURST ] ; uint16_t good_l2_pad_size [ NETDEV_MAX_BURST ] ; struct dp_packet * packet ; struct dp_netdev_pmd_thread * pmd = pmd_handle ; struct netdev_flow_key test_keys [ NETDEV_MAX_BURST ] ; if ( keys_size < cnt ) { VLOG_ERR ( "Invalid key size supplied, Key_size: %d less than" "batch_size:  %" PRIuSIZE "\n" , keys_size , cnt ) ; VLOG_ERR ( "Autovalidatior is disabled.\n" ) ; return 0 ; } DP_PACKET_BATCH_FOR_EACH ( , , ) { pkt_metadata_init ( & packet -> md , in_port ) ; miniflow_extract ( packet , & keys [ i ] . mf ) ; good_l2_5_ofs [ i ] = packet -> l2_5_ofs ; good_l3_ofs [ i ] = packet -> l3_ofs ; good_l4_ofs [ i ] = packet -> l4_ofs ; good_l2_pad_size [ i ] = packet -> l2_pad_size ; } uint32_t batch_failed = 0 ; for ( int j = MFEX_IMPL_START_IDX ; j < MFEX_IMPL_MAX ; j ++ ) { if ( ! mfex_impls [ j ] . available ) { continue ; } memset ( test_keys , 0 , keys_size * sizeof ( netdev_flow_key ) ) ; DP_PACKET_BATCH_FOR_EACH ( , , ) { dp_packet_reset_offsets ( packet ) ; } uint32_t hit_mask = mfex_impls [ j ] . extract_func ( packets , test_keys , keys_size , in_port , pmd_handle ) ; while ( hit_mask ) { uint32_t i = raw_ctz ( hit_mask ) ; hit_mask &= ( hit_mask - 1 ) ; uint32_t failed = 0 ; struct ds log_msg = DS_EMPTY_INITIALIZER ; ds_put_format ( & log_msg , "MFEX autovalidator pkt %d\n" , i ) ; if ( ( keys [ i ] . mf . map . bits [ 0 ] != test_keys [ i ] . mf . map . bits [ 0 ] ) || ( keys [ i ] . mf . map . bits [ 1 ] != test_keys [ i ] . mf . map . bits [ 1 ] ) ) { ds_put_format ( & log_msg , "Autovalidation map failed\n" "Good: 0x%llx 0x%llx    Test: 0x%llx 0x%llx\n" , keys [ i ] . mf . map . bits [ 0 ] , keys [ i ] . mf . map . bits [ 1 ] , test_keys [ i ] . mf . map . bits [ 0 ] , test_keys [ i ] . mf . map . bits [ 1 ] ) ; failed = 1 ; } if ( ! miniflow_equal ( & keys [ i ] . mf , & test_keys [ i ] . mf ) ) { uint32_t block_cnt = miniflow_n_values ( & keys [ i ] . mf ) ; uint32_t test_block_cnt = miniflow_n_values ( & test_keys [ i ] . mf ) ; ds_put_format ( & log_msg , "Autovalidation blocks failed\n" "Good hex:\n" ) ; ds_put_hex_dump ( & log_msg , & keys [ i ] . buf , block_cnt * 8 , 0 , false ) ; ds_put_format ( & log_msg , "Test hex:\n" ) ; ds_put_hex_dump ( & log_msg , & test_keys [ i ] . buf , test_block_cnt * 8 , 0 , false ) ; failed = 1 ; } packet = packets -> packets [ i ] ; if ( ( packet -> l2_pad_size != good_l2_pad_size [ i ] ) || ( packet -> l2_5_ofs != good_l2_5_ofs [ i ] ) || ( packet -> l3_ofs != good_l3_ofs [ i ] ) || ( packet -> l4_ofs != good_l4_ofs [ i ] ) ) { ds_put_format ( & log_msg , "Autovalidation packet offsets failed\n" ) ; ds_put_format ( & log_msg , "Good offsets: " "l2_pad_size: %" PRIu16 ", l2_5_ofs: %" PRIu16 ", " "l3_ofs: %" PRIu16 ", l4_ofs: %" PRIu16 "\n" , good_l2_pad_size [ i ] , good_l2_5_ofs [ i ] , good_l3_ofs [ i ] , good_l4_ofs [ i ] ) ; ds_put_format ( & log_msg , "Test offsets: " "l2_pad_size: %" PRIu16 ", l2_5_ofs: %" PRIu16 ", " "l3_ofs: %" PRIu16 ", l4_ofs: %" PRIu16 "\n" , packet -> l2_pad_size , packet -> l2_5_ofs , packet -> l3_ofs , packet -> l4_ofs ) ; failed = 1 ; } if ( failed ) { VLOG_ERR ( "Autovalidation for %s failed in pkt %d," " disabling." , mfex_impls [ j ] . name , i ) ; VLOG_ERR ( "Autovalidation failure details:\n%s" , ds_cstr ( & log_msg ) ) ; batch_failed = 1 ; } ds_destroy ( & log_msg ) ; } } if ( batch_failed ) { atomic_store_relaxed ( & pmd -> miniflow_extract_opt , NULL ) ; } DP_PACKET_BATCH_FOR_EACH ( , , ) { packet -> l2_5_ofs = good_l2_5_ofs [ i ] ; packet -> l3_ofs = good_l3_ofs [ i ] ; packet -> l4_ofs = good_l4_ofs [ i ] ; packet -> l2_pad_size = good_l2_pad_size [ i ] ; } return 0 ; } 