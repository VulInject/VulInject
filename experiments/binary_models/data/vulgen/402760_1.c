void handle_message ( struct entry * id , struct entry * str ) { char * charset , * nplurals , * tmp , * p ; struct messages * msg , * dupmsg ; size_t len ; unsigned int hash_val ; unsigned int nmsg , n , thash_idx ; if ( cur_mo == NULL ) { char * default_domain ; default_domain = strict_flag ?DEFAULT_DOMAIN_MO : DEFAULT_DOMAIN ; catalog_init ( default_domain ) ; } hash_val = hashpjw ( id -> str ) ; dupmsg = search_msg ( cur_catalog , id -> str , hash_val ) ; if ( dupmsg ) { if ( ( dupmsg -> str_len == str -> len ) && ( memcmp ( dupmsg -> str , str -> str , str -> len ) == 0 ) ) { if ( verbose_flag ) { warning ( gettext ( WARN_DUP_ENTRIES ) , dupmsg -> num , po_names [ dupmsg -> po ] , id -> num , cur_po ) ; } free ( id -> str ) ; if ( id -> pos ) { free ( id -> pos ) ; } free ( str -> str ) ; if ( str -> pos ) { free ( str -> pos ) ; } return ; } if ( verbose_flag ) { diag ( gettext ( ERR_DUP_ENTRIES ) , dupmsg -> num , po_names [ dupmsg -> po ] , id -> num , cur_po ) ; po_error ++ ; } free ( id -> str ) ; if ( id -> pos ) { free ( id -> pos ) ; } free ( str -> str ) ; if ( str -> pos ) { free ( str -> pos ) ; } return ; } if ( next_entry_is_fuzzy ) { cur_catalog -> fnum ++ ; if ( ! fuzzy_flag ) { free ( id -> str ) ; if ( id -> pos ) { free ( id -> pos ) ; } free ( str -> str ) ; if ( str -> pos ) { free ( str -> pos ) ; } return ; } } if ( str -> len == str -> no ) { cur_catalog -> unum ++ ; free ( id -> str ) ; if ( id -> pos ) { free ( id -> pos ) ; } free ( str -> str ) ; if ( str -> pos ) { free ( str -> pos ) ; } return ; } if ( ( id -> no == 1 ) && ( id -> len == 1 ) ) { cur_catalog -> header ++ ; charset = strstr ( str -> str , CHARSET_STR ) ; if ( charset == NULL ) { warning ( gettext ( WARN_NOCHARSET ) , id -> num , cur_po , str -> num ) ; conv_init ( NULL ) ; } else { charset += CHARSET_LEN ; p = strpbrk ( charset , " \t\n" ) ; if ( p != NULL ) { len = p - charset ; } else { len = strlen ( charset ) ; } tmp = Xmalloc ( len + 1 ) ; ( void ) memcpy ( tmp , charset , len ) ; * ( tmp + len ) = '\0' ; charset = tmp ; conv_init ( charset ) ; free ( charset ) ; } nplurals = strstr ( str -> str , NPLURALS_STR ) ; if ( nplurals == NULL ) { cur_catalog -> nplurals = 0 ; } else { unsigned int num ; nplurals += NPLURALS_LEN ; p = nplurals ; num = 0 ; while ( isdigit ( ( unsigned char ) * p ) ) { num = num * 10 + * p ++ - '0' ; } cur_catalog -> nplurals = num ; } } if ( verbose_flag ) { check_format ( id , str , next_entry_is_c_format ) ; } if ( id -> pos ) { free ( id -> pos ) ; } if ( str -> pos ) { free ( str -> pos ) ; } msg = cur_catalog -> msg ; nmsg = cur_catalog -> nmsg ; msg [ nmsg ] . po = cur_po_index ; msg [ nmsg ] . num = id -> num ; msg [ nmsg ] . id = id -> str ; msg [ nmsg ] . id_len = id -> len ; msg [ nmsg ] . str = str -> str ; msg [ nmsg ] . str_len = str -> len ; msg [ nmsg ] . hash = hash_val ; thash_idx = get_hash_index ( cur_catalog -> thash , hash_val , cur_catalog -> thash_size ) ; cur_catalog -> thash [ thash_idx ] = nmsg + 1 ; cur_catalog -> nmsg ++ ; } 