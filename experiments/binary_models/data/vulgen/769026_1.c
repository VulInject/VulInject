static void meson_plane_atomic_update ( struct drm_plane * plane , struct drm_atomic_state * state ) { struct meson_plane * meson_plane = to_meson_plane ( plane ) ; struct drm_plane_state * new_state = drm_atomic_get_new_plane_state ( state , plane ) ; struct drm_rect dest = drm_plane_state_dest ( new_state ) ; struct meson_drm * priv = meson_plane -> priv ; struct drm_framebuffer * fb = new_state -> fb ; struct drm_gem_dma_object * gem ; unsigned long flags ; int vsc_ini_rcv_num , vsc_ini_rpt_p0_num ; int vsc_bot_rcv_num , vsc_bot_rpt_p0_num ; int hsc_ini_rcv_num , hsc_ini_rpt_p0_num ; int hf_phase_step , vf_phase_step ; int src_w , src_h , dst_w , dst_h ; int bot_ini_phase ; int hf_bank_len ; int vf_bank_len ; u8 canvas_id_osd1 ; spin_lock_irqsave ( & priv -> drm -> event_lock , flags ) ; if ( ( meson_vpu_is_compatible ( priv , VPU_COMPATIBLE_GXM ) || meson_vpu_is_compatible ( priv , VPU_COMPATIBLE_G12A ) ) && fb -> modifier & DRM_FORMAT_MOD_ARM_AFBC ( MESON_MOD_AFBC_VALID_BITS ) ) { priv -> viu . osd1_afbcd = true ; } else { priv -> viu . osd1_afbcd = false ; } priv -> viu . osd1_ctrl_stat = OSD_ENABLE | ( 0x100 << OSD_GLOBAL_ALPHA_SHIFT ) | OSD_BLK0_ENABLE ; priv -> viu . osd1_ctrl_stat2 = readl ( priv -> io_base + _REG ( VIU_OSD1_CTRL_STAT2 ) ) ; canvas_id_osd1 = priv -> canvas_id_osd1 ; priv -> viu . osd1_blk0_cfg [ 0 ] = canvas_id_osd1 << OSD_CANVAS_SEL ; if ( priv -> viu . osd1_afbcd ) { if ( meson_vpu_is_compatible ( priv , VPU_COMPATIBLE_G12A ) ) { priv -> viu . osd1_blk1_cfg4 = MESON_G12A_AFBCD_OUT_ADDR ; priv -> viu . osd1_blk0_cfg [ 0 ] |= OSD_ENDIANNESS_BE ; priv -> viu . osd1_ctrl_stat2 |= OSD_PENDING_STAT_CLEAN ; priv -> viu . osd1_ctrl_stat |= VIU_OSD1_CFG_SYN_EN ; } if ( meson_vpu_is_compatible ( priv , VPU_COMPATIBLE_GXM ) ) { priv -> viu . osd1_blk0_cfg [ 0 ] |= OSD_ENDIANNESS_LE ; priv -> viu . osd1_ctrl_stat2 |= OSD_DPATH_MALI_AFBCD ; } } else { priv -> viu . osd1_blk0_cfg [ 0 ] |= OSD_ENDIANNESS_LE ; if ( meson_vpu_is_compatible ( priv , VPU_COMPATIBLE_GXM ) ) { priv -> viu . osd1_ctrl_stat2 &= ~ OSD_DPATH_MALI_AFBCD ; } } if ( meson_vpu_is_compatible ( priv , VPU_COMPATIBLE_GXBB ) ) { priv -> viu . osd1_blk0_cfg [ 0 ] |= OSD_OUTPUT_COLOR_RGB ; } if ( priv -> viu . osd1_afbcd && meson_vpu_is_compatible ( priv , VPU_COMPATIBLE_G12A ) ) { priv -> viu . osd1_blk0_cfg [ 0 ] |= OSD_MALI_SRC_EN | priv -> afbcd . ops -> fmt_to_blk_mode ( fb -> modifier , fb -> format -> format ) ; } else { switch ( fb -> format -> format ) { case DRM_FORMAT_XRGB8888 : case DRM_FORMAT_ARGB8888 : priv -> viu . osd1_blk0_cfg [ 0 ] |= OSD_BLK_MODE_32 | OSD_COLOR_MATRIX_32_ARGB ; break ; case DRM_FORMAT_XBGR8888 : case DRM_FORMAT_ABGR8888 : priv -> viu . osd1_blk0_cfg [ 0 ] |= OSD_BLK_MODE_32 | OSD_COLOR_MATRIX_32_ABGR ; break ; case DRM_FORMAT_RGB888 : priv -> viu . osd1_blk0_cfg [ 0 ] |= OSD_BLK_MODE_24 | OSD_COLOR_MATRIX_24_RGB ; break ; case DRM_FORMAT_RGB565 : priv -> viu . osd1_blk0_cfg [ 0 ] |= OSD_BLK_MODE_16 | OSD_COLOR_MATRIX_16_RGB565 ; break ; } } switch ( fb -> format -> format ) { case DRM_FORMAT_XRGB8888 : case DRM_FORMAT_XBGR8888 : priv -> viu . osd1_ctrl_stat2 |= OSD_REPLACE_EN ; break ; case DRM_FORMAT_ARGB8888 : case DRM_FORMAT_ABGR8888 : priv -> viu . osd1_ctrl_stat2 &= ~ OSD_REPLACE_EN ; break ; } vsc_bot_rcv_num = 0 ; vsc_bot_rpt_p0_num = 0 ; hf_bank_len = 4 ; vf_bank_len = 4 ; if ( new_state -> crtc -> mode . flags & DRM_MODE_FLAG_INTERLACE ) { vsc_bot_rcv_num = 6 ; vsc_bot_rpt_p0_num = 2 ; } hsc_ini_rcv_num = hf_bank_len ; vsc_ini_rcv_num = vf_bank_len ; hsc_ini_rpt_p0_num = ( hf_bank_len / 2 ) - 1 ; vsc_ini_rpt_p0_num = ( vf_bank_len / 2 ) - 1 ; src_w = fixed16_to_int ( new_state -> src_w ) ; src_h = fixed16_to_int ( new_state -> src_h ) ; dst_w = new_state -> crtc_w ; dst_h = new_state -> crtc_h ; if ( new_state -> crtc -> mode . flags & DRM_MODE_FLAG_INTERLACE ) { dest . y1 /= 2 ; dest . y2 /= 2 ; dst_h /= 2 ; } hf_phase_step = ( ( src_w << 18 ) / dst_w ) << 6 ; vf_phase_step = ( src_h << 20 ) / dst_h ; if ( new_state -> crtc -> mode . flags & DRM_MODE_FLAG_INTERLACE ) { bot_ini_phase = ( ( vf_phase_step / 2 ) >> 4 ) ; } else { bot_ini_phase = 0 ; } vf_phase_step = ( vf_phase_step << 4 ) ; if ( src_h != dst_h || src_w != dst_w ) { priv -> viu . osd_sc_i_wh_m1 = SCI_WH_M1_W ( src_w - 1 ) | SCI_WH_M1_H ( src_h - 1 ) ; priv -> viu . osd_sc_o_h_start_end = SCO_HV_START ( dest . x1 ) | SCO_HV_END ( dest . x2 - 1 ) ; priv -> viu . osd_sc_o_v_start_end = SCO_HV_START ( dest . y1 ) | SCO_HV_END ( dest . y2 - 1 ) ; priv -> viu . osd_sc_ctrl0 = SC_CTRL0_PATH_EN | SC_CTRL0_SEL_OSD1 ; } else { priv -> viu . osd_sc_i_wh_m1 = 0 ; priv -> viu . osd_sc_o_h_start_end = 0 ; priv -> viu . osd_sc_o_v_start_end = 0 ; priv -> viu . osd_sc_ctrl0 = 0 ; } if ( src_h != dst_h ) { priv -> viu . osd_sc_v_ctrl0 = VSC_BANK_LEN ( vf_bank_len ) | VSC_TOP_INI_RCV_NUM ( vsc_ini_rcv_num ) | VSC_TOP_RPT_L0_NUM ( vsc_ini_rpt_p0_num ) | VSC_VERTICAL_SCALER_EN ; priv -> viu . osd_sc_v_phase_step = SC_PHASE_STEP ( vf_phase_step ) ; priv -> viu . osd_sc_v_ini_phase = VSC_INI_PHASE_BOT ( bot_ini_phase ) ; } else { priv -> viu . osd_sc_v_ctrl0 = 0 ; priv -> viu . osd_sc_v_phase_step = 0 ; priv -> viu . osd_sc_v_ini_phase = 0 ; } if ( src_w != dst_w ) { priv -> viu . osd_sc_h_ctrl0 = HSC_BANK_LENGTH ( hf_bank_len ) | HSC_INI_RCV_NUM0 ( hsc_ini_rcv_num ) | HSC_RPT_P0_NUM0 ( hsc_ini_rpt_p0_num ) | HSC_HORIZ_SCALER_EN ; priv -> viu . osd_sc_h_phase_step = SC_PHASE_STEP ( hf_phase_step ) ; priv -> viu . osd_sc_h_ini_phase = 0 ; } else { priv -> viu . osd_sc_h_ctrl0 = 0 ; priv -> viu . osd_sc_h_phase_step = 0 ; priv -> viu . osd_sc_h_ini_phase = 0 ; } priv -> viu . osd1_blk0_cfg [ 1 ] = ( ( fixed16_to_int ( new_state -> src . x2 ) - 1 ) << 16 ) | fixed16_to_int ( new_state -> src . x1 ) ; priv -> viu . osd1_blk0_cfg [ 2 ] = ( ( fixed16_to_int ( new_state -> src . y2 ) - 1 ) << 16 ) | fixed16_to_int ( new_state -> src . y1 ) ; priv -> viu . osd1_blk0_cfg [ 3 ] = ( ( dest . x2 - 1 ) << 16 ) | dest . x1 ; priv -> viu . osd1_blk0_cfg [ 4 ] = ( ( dest . y2 - 1 ) << 16 ) | dest . y1 ; if ( meson_vpu_is_compatible ( priv , VPU_COMPATIBLE_G12A ) ) { priv -> viu . osd_blend_din0_scope_h = ( ( dest . x2 - 1 ) << 16 ) | dest . x1 ; priv -> viu . osd_blend_din0_scope_v = ( ( dest . y2 - 1 ) << 16 ) | dest . y1 ; priv -> viu . osb_blend0_size = dst_h << 16 | dst_w ; priv -> viu . osb_blend1_size = dst_h << 16 | dst_w ; } gem = drm_fb_dma_get_gem_obj ( fb , 0 ) ; priv -> viu . osd1_addr = gem -> dma_addr ; priv -> viu . osd1_stride = fb -> pitches [ 0 ] ; priv -> viu . osd1_height = fb -> height ; priv -> viu . osd1_width = fb -> width ; if ( priv -> viu . osd1_afbcd ) { priv -> afbcd . modifier = fb -> modifier ; priv -> afbcd . format = fb -> format -> format ; if ( meson_vpu_is_compatible ( priv , VPU_COMPATIBLE_G12A ) ) { priv -> viu . osd1_blk2_cfg4 = meson_g12a_afbcd_line_stride ( priv ) ; } } if ( ! meson_plane -> enabled ) { if ( meson_vpu_is_compatible ( priv , VPU_COMPATIBLE_GXM ) || meson_vpu_is_compatible ( priv , VPU_COMPATIBLE_GXL ) ) { meson_viu_osd1_reset ( priv ) ; } meson_plane -> enabled = true ; } priv -> viu . osd1_enabled = true ; spin_unlock_irqrestore ( & priv -> drm -> event_lock , flags ) ; } 