flush_tlb_range ( , , ) { struct mm_struct * mm = vma -> vm_mm ; unsigned long size = end - start ; unsigned long nbits ; if ( mm != current -> active_mm ) { mm -> context = 0 ; return ; } nbits = ia64_fls ( size + 0xfff ) ; while ( unlikely ( ( ( 1UL << nbits ) & purge . mask ) == 0 ) && ( nbits < purge . max_bits ) ) { ++ nbits ; } if ( nbits > purge . max_bits ) { nbits = purge . max_bits ; } start &= ~ ( ( 1UL << nbits ) - 1 ) ; preempt_disable ( ) ; if ( mm != current -> active_mm || cpumask_weight ( mm_cpumask ( mm ) ) != 1 ) { preempt_enable ( ) ; return ; } { ia64_ptcl ( start , ( nbits << 2 ) ) ; start += ( 1UL << nbits ) ; } start < end ; preempt_enable ( ) ; ia64_srlz_i ( ) ; } 