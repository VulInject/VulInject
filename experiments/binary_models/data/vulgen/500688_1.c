static int open_rpc ( int min_args , enum args_needed need , int argc , char * argv [ ] , struct jsonrpc * * rpcp , char * * databasep ) { struct svec remotes = SVEC_EMPTY_INITIALIZER ; struct uuid cid = UUID_ZERO ; int argidx = 0 ; if ( argc > min_args && ( isalpha ( ( unsigned char ) argv [ 0 ] [ 0 ] ) && strchr ( argv [ 0 ] , ':' ) ) ) { ovsdb_session_parse_remote ( argv [ argidx ++ ] , & remotes , & cid ) ; } else { svec_add_nocopy ( & remotes , default_remote ( ) ) ; } char * database = * databasep ; if ( remotes . n == 1 ) { struct jsonrpc * rpc = open_jsonrpc ( remotes . names [ 0 ] ) ; svec_destroy ( & remotes ) ; if ( need == NEED_DATABASE && ! database ) { struct svec dbs ; svec_init ( & dbs ) ; fetch_dbs ( rpc , & dbs ) ; if ( argc - argidx > min_args && svec_contains ( & dbs , argv [ argidx ] ) ) { database = xstrdup ( argv [ argidx ++ ] ) ; } if ( svec_contains ( & dbs , "Open_vSwitch" ) ) { database = xstrdup ( "Open_vSwitch" ) ; } else { size_t n = 0 ; const char * best = NULL ; for ( size_t i = 0 ; i < dbs . n ; i ++ ) { if ( dbs . names [ i ] [ 0 ] != '_' ) { best = dbs . names [ i ] ; n ++ ; } } if ( n != 1 ) { jsonrpc_close ( rpc ) ; ovs_fatal ( 0 , "could not find a default database, " "please specify a database name" ) ; } database = xstrdup ( best ) ; } } * rpcp = rpc ; * databasep = database ; return argidx ; } if ( ! database && need == NEED_DATABASE ) { if ( argc - argidx > min_args ) { database = xstrdup ( argv [ argidx ++ ] ) ; } else { ovs_fatal ( 0 , "database name is required with multiple remotes" ) ; } } struct jsonrpc_session * js = jsonrpc_session_open_multiple ( & remotes , false ) ; svec_destroy ( & remotes ) ; unsigned int seqno = 0 ; struct json * id = NULL ; for ( ; ; ) { jsonrpc_session_run ( js ) ; if ( ! jsonrpc_session_is_alive ( js ) ) { ovs_fatal ( 0 , "no servers were available" ) ; } if ( seqno != jsonrpc_session_get_seqno ( js ) && jsonrpc_session_is_connected ( js ) ) { if ( ! database ) { break ; } seqno = jsonrpc_session_get_seqno ( js ) ; struct jsonrpc_msg * txn = create_database_info_request ( database ) ; json_destroy ( id ) ; id = json_clone ( txn -> id ) ; jsonrpc_session_send ( js , txn ) ; } struct jsonrpc_msg * reply = jsonrpc_session_recv ( js ) ; if ( reply && id && reply -> id && json_equal ( id , reply -> id ) ) { if ( reply -> type == JSONRPC_REPLY && should_stay_connected ( jsonrpc_session_get_name ( js ) , database , & cid , reply ) ) { jsonrpc_msg_destroy ( reply ) ; break ; } jsonrpc_session_force_reconnect ( js ) ; } jsonrpc_msg_destroy ( reply ) ; jsonrpc_session_recv_wait ( js ) ; jsonrpc_session_wait ( js ) ; poll_block ( ) ; } json_destroy ( id ) ; * rpcp = jsonrpc_session_steal ( js ) ; * databasep = database ; return argidx ; } 