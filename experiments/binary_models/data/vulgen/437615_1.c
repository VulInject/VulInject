static int s_build_lut ( int idx , void * a , void * modulus , void * mp , void * mu ) { unsigned x , y , err , bitlen , lut_gap ; void * tmp ; if ( ( sizeof ( lut_orders ) / sizeof ( lut_orders [ 0 ] ) ) < ( 1U << FP_LUT ) ) { err = CRYPT_INVALID_ARG ; DONE } bitlen = mp_unsigned_bin_size ( modulus ) << 3 ; x = bitlen % FP_LUT ; if ( x ) { bitlen += FP_LUT - x ; } lut_gap = bitlen / FP_LUT ; if ( ( err = mp_init_copy ( & fp_cache [ idx ] . mu , mu ) ) != CRYPT_OK ) { ERR } if ( ( mp_mulmod ( fp_cache [ idx ] . g -> x , mu , modulus , fp_cache [ idx ] . LUT [ 1 ] -> x ) != CRYPT_OK ) || ( mp_mulmod ( fp_cache [ idx ] . g -> y , mu , modulus , fp_cache [ idx ] . LUT [ 1 ] -> y ) != CRYPT_OK ) || ( mp_mulmod ( fp_cache [ idx ] . g -> z , mu , modulus , fp_cache [ idx ] . LUT [ 1 ] -> z ) != CRYPT_OK ) ) { ERR } for ( x = 1 ; x < FP_LUT ; x ++ ) { if ( ( mp_copy ( fp_cache [ idx ] . LUT [ 1 << ( x - 1 ) ] -> x , fp_cache [ idx ] . LUT [ 1 << x ] -> x ) != CRYPT_OK ) || ( mp_copy ( fp_cache [ idx ] . LUT [ 1 << ( x - 1 ) ] -> y , fp_cache [ idx ] . LUT [ 1 << x ] -> y ) != CRYPT_OK ) || ( mp_copy ( fp_cache [ idx ] . LUT [ 1 << ( x - 1 ) ] -> z , fp_cache [ idx ] . LUT [ 1 << x ] -> z ) != CRYPT_OK ) ) { ERR } for ( y = 0 ; y < lut_gap ; y ++ ) { if ( ( err = ltc_mp . ecc_ptdbl ( fp_cache [ idx ] . LUT [ 1 << x ] , fp_cache [ idx ] . LUT [ 1 << x ] , a , modulus , mp ) ) != CRYPT_OK ) { ERR } } } for ( x = 2 ; x <= FP_LUT ; x ++ ) { for ( y = 0 ; y < ( 1UL << FP_LUT ) ; y ++ ) { if ( lut_orders [ y ] . ham != ( int ) x ) { continue ; } if ( ( err = ltc_mp . ecc_ptadd ( fp_cache [ idx ] . LUT [ lut_orders [ y ] . terma ] , fp_cache [ idx ] . LUT [ lut_orders [ y ] . termb ] , fp_cache [ idx ] . LUT [ y ] , a , modulus , mp ) ) != CRYPT_OK ) { ERR } } } if ( ( err = mp_init ( & tmp ) ) != CRYPT_OK ) { ERR } for ( x = 1 ; x < ( 1UL << FP_LUT ) ; x ++ ) { if ( ( err = mp_montgomery_reduce ( fp_cache [ idx ] . LUT [ x ] -> z , modulus , mp ) ) != CRYPT_OK ) { ERR } if ( ( err = mp_invmod ( fp_cache [ idx ] . LUT [ x ] -> z , modulus , fp_cache [ idx ] . LUT [ x ] -> z ) ) != CRYPT_OK ) { ERR } if ( ( err = mp_sqrmod ( fp_cache [ idx ] . LUT [ x ] -> z , modulus , tmp ) ) != CRYPT_OK ) { ERR } if ( ( err = mp_mulmod ( fp_cache [ idx ] . LUT [ x ] -> x , tmp , modulus , fp_cache [ idx ] . LUT [ x ] -> x ) ) != CRYPT_OK ) { ERR } if ( ( err = mp_mulmod ( tmp , fp_cache [ idx ] . LUT [ x ] -> z , modulus , tmp ) ) != CRYPT_OK ) { ERR } if ( ( err = mp_mulmod ( fp_cache [ idx ] . LUT [ x ] -> y , tmp , modulus , fp_cache [ idx ] . LUT [ x ] -> y ) ) != CRYPT_OK ) { ERR } mp_clear ( fp_cache [ idx ] . LUT [ x ] -> z ) ; fp_cache [ idx ] . LUT [ x ] -> z = NULL ; } mp_clear ( tmp ) ; return CRYPT_OK ; ERR err = CRYPT_MEM ; DONE for ( y = 0 ; y < ( 1U << FP_LUT ) ; y ++ ) { ltc_ecc_del_point ( fp_cache [ idx ] . LUT [ y ] ) ; fp_cache [ idx ] . LUT [ y ] = NULL ; } ltc_ecc_del_point ( fp_cache [ idx ] . g ) ; fp_cache [ idx ] . g = NULL ; fp_cache [ idx ] . lru_count = 0 ; if ( fp_cache [ idx ] . mu != NULL ) { mp_clear ( fp_cache [ idx ] . mu ) ; fp_cache [ idx ] . mu = NULL ; } if ( tmp != NULL ) { mp_clear ( tmp ) ; } return err ; } 