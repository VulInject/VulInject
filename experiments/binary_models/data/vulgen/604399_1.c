static void ptp_event_rx ( struct efx_nic * efx , struct efx_ptp_data * ptp ) { struct efx_ptp_event_rx * evt = NULL ; if ( WARN_ON_ONCE ( ptp -> rx_ts_inline ) ) { return ; } if ( ptp -> evt_frag_idx != 3 ) { return ; } spin_lock_bh ( & ptp -> evt_lock ) ; if ( ! list_empty ( & ptp -> evt_free_list ) ) { evt = list_first_entry ( & ptp -> evt_free_list , efx_ptp_event_rx , link ) ; list_del ( & evt -> link ) ; evt -> seq0 = EFX_QWORD_FIELD ( ptp -> evt_frags [ 2 ] , MCDI_EVENT_DATA ) ; evt -> seq1 = ( EFX_QWORD_FIELD ( ptp -> evt_frags [ 2 ] , MCDI_EVENT_SRC ) | ( EFX_QWORD_FIELD ( ptp -> evt_frags [ 1 ] , MCDI_EVENT_SRC ) << 8 ) | ( EFX_QWORD_FIELD ( ptp -> evt_frags [ 0 ] , MCDI_EVENT_SRC ) << 16 ) ) ; evt -> hwtimestamp = efx -> ptp_data -> nic_to_kernel_time ( EFX_QWORD_FIELD ( ptp -> evt_frags [ 0 ] , MCDI_EVENT_DATA ) , EFX_QWORD_FIELD ( ptp -> evt_frags [ 1 ] , MCDI_EVENT_DATA ) , ptp -> ts_corrections . rx ) ; evt -> expiry = jiffies + msecs_to_jiffies ( PKT_EVENT_LIFETIME_MS ) ; list_add_tail ( & evt -> link , & ptp -> evt_list ) ; queue_work ( ptp -> workwq , & ptp -> work ) ; } if ( net_ratelimit ( ) ) { netif_err ( efx , rx_err , efx -> net_dev , "PTP event queue overflow\n" ) ; } spin_unlock_bh ( & ptp -> evt_lock ) ; } 