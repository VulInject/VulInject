static void process_onefile ( struct mparse * mp , struct manpage * resp , int startdir , struct outstate * outst , struct manconf * conf ) { int fd ; if ( resp -> ipath != SIZE_MAX ) { ( void ) chdir ( conf -> manpath . paths [ resp -> ipath ] ) ; } if ( startdir != - 1 ) { ( void ) fchdir ( startdir ) ; } mandoc_msg_setinfilename ( resp -> file ) ; if ( resp -> file != NULL ) { if ( ( fd = mparse_open ( mp , resp -> file ) ) == - 1 ) { mandoc_msg ( resp -> ipath == SIZE_MAX ?MANDOCERR_BADARG_BAD : MANDOCERR_OPEN , 0 , 0 , "%s" , strerror ( errno ) ) ; mandoc_msg_setinfilename ( NULL ) ; return ; } } else { fd = STDIN_FILENO ; } if ( outst -> use_pager ) { outst -> use_pager = 0 ; outst -> tag_files = term_tag_init ( conf -> output . outfilename , outst -> outtype == OUTT_HTML ?".html" : "" , conf -> output . tagfilename ) ; if ( ( conf -> output . outfilename != NULL || conf -> output . tagfilename != NULL ) && pledge ( "stdio rpath cpath" , NULL ) == - 1 ) { mandoc_msg ( MANDOCERR_PLEDGE , 0 , 0 , "%s" , strerror ( errno ) ) ; exit ( mandoc_msg_getrc ( ) ) ; } } if ( outst -> had_output && outst -> outtype <= OUTT_UTF8 ) { terminal_sepline ( outst -> outdata ) ; } if ( resp -> form == FORM_SRC ) { parse ( mp , fd , resp -> file , outst , conf ) ; } else { passthrough ( fd , conf -> output . synopsisonly ) ; outst -> had_output = 1 ; } if ( ferror ( stdout ) ) { if ( outst -> tag_files != NULL ) { mandoc_msg ( MANDOCERR_WRITE , 0 , 0 , "%s: %s" , outst -> tag_files -> ofn , strerror ( errno ) ) ; term_tag_unlink ( ) ; outst -> tag_files = NULL ; } else { mandoc_msg ( MANDOCERR_WRITE , 0 , 0 , "%s" , strerror ( errno ) ) ; } } mandoc_msg_setinfilename ( NULL ) ; } 