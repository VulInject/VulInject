void workingset_refault ( struct folio * folio , void * shadow ) { bool file = folio_is_file_lru ( folio ) ; struct mem_cgroup * eviction_memcg ; struct lruvec * eviction_lruvec ; unsigned long refault_distance ; unsigned long workingset_size ; struct pglist_data * pgdat ; struct mem_cgroup * memcg ; unsigned long eviction ; struct lruvec * lruvec ; unsigned long refault ; bool workingset ; int memcgid ; long nr ; if ( lru_gen_enabled ( ) ) { lru_gen_refault ( folio , shadow ) ; return ; } unpack_shadow ( shadow , & memcgid , & pgdat , & eviction , & workingset ) ; eviction <<= bucket_order ; rcu_read_lock ( ) ; eviction_memcg = mem_cgroup_from_id ( memcgid ) ; if ( ! mem_cgroup_disabled ( ) && ! eviction_memcg ) { out } eviction_lruvec = mem_cgroup_lruvec ( eviction_memcg , pgdat ) ; refault = atomic_long_read ( & eviction_lruvec -> nonresident_age ) ; refault_distance = ( refault - eviction ) & EVICTION_MASK ; nr = folio_nr_pages ( folio ) ; memcg = folio_memcg ( folio ) ; pgdat = folio_pgdat ( folio ) ; lruvec = mem_cgroup_lruvec ( memcg , pgdat ) ; mod_lruvec_state ( lruvec , WORKINGSET_REFAULT_BASE + file , nr ) ; mem_cgroup_flush_stats_delayed ( ) ; workingset_size = lruvec_page_state ( eviction_lruvec , NR_ACTIVE_FILE ) ; if ( ! file ) { workingset_size += lruvec_page_state ( eviction_lruvec , NR_INACTIVE_FILE ) ; } if ( mem_cgroup_get_nr_swap_pages ( eviction_memcg ) > 0 ) { workingset_size += lruvec_page_state ( eviction_lruvec , NR_ACTIVE_ANON ) ; if ( file ) { workingset_size += lruvec_page_state ( eviction_lruvec , NR_INACTIVE_ANON ) ; } } folio_set_active ( folio ) ; workingset_age_nonresident ( lruvec , nr ) ; mod_lruvec_state ( lruvec , WORKINGSET_ACTIVATE_BASE + file , nr ) ; if ( workingset ) { folio_set_workingset ( folio ) ; lru_note_cost_refault ( folio ) ; mod_lruvec_state ( lruvec , WORKINGSET_RESTORE_BASE + file , nr ) ; } out rcu_read_unlock ( ) ; } 