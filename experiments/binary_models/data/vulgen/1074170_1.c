void jsble_central_connect ( ble_gap_addr_t peer_addr , JsVar * options ) { uint32_t err_code ; ble_gap_scan_params_t m_scan_param ; memset ( & m_scan_param , 0 , sizeof ( m_scan_param ) ) ; m_scan_param . active = 1 ; m_scan_param . interval = MSEC_TO_UNITS ( 100 , UNIT_0_625_MS ) ; m_scan_param . window = MSEC_TO_UNITS ( 90 , UNIT_0_625_MS ) ; m_scan_param . timeout = 4 ; ble_gap_conn_params_t gap_conn_params ; memset ( & gap_conn_params , 0 , sizeof ( gap_conn_params ) ) ; BLEFlags flags = jsvGetIntegerAndUnLock ( jsvObjectGetChild ( execInfo . hiddenRoot , BLE_NAME_FLAGS , 0 ) ) ; else { gap_conn_params . min_conn_interval = MSEC_TO_UNITS ( 20 , UNIT_1_25_MS ) ; gap_conn_params . max_conn_interval = MSEC_TO_UNITS ( 200 , UNIT_1_25_MS ) ; } gap_conn_params . slave_latency = SLAVE_LATENCY ; gap_conn_params . conn_sup_timeout = CONN_SUP_TIMEOUT ; if ( jsvIsObject ( options ) ) { JsVarFloat v ; v = jsvGetFloatAndUnLock ( jsvObjectGetChild ( options , "minInterval" , 0 ) ) ; if ( ! isnan ( v ) ) { gap_conn_params . min_conn_interval = ( uint16_t ) ( MSEC_TO_UNITS ( v , UNIT_1_25_MS ) + 0.5 ) ; } v = jsvGetFloatAndUnLock ( jsvObjectGetChild ( options , "maxInterval" , 0 ) ) ; if ( ! isnan ( v ) ) { gap_conn_params . max_conn_interval = ( uint16_t ) ( MSEC_TO_UNITS ( v , UNIT_1_25_MS ) + 0.5 ) ; } } ble_gap_addr_t addr ; addr = peer_addr ; err_code = sd_ble_gap_connect ( & addr , & m_scan_param , & gap_conn_params ) ; err_code = sd_ble_gap_connect ( & addr , & m_scan_param , & gap_conn_params , APP_BLE_CONN_CFG_TAG ) ; JsVar * errStr = jsble_get_error_string ( err_code ) ; if ( errStr ) { bleCompleteTaskFail ( BLETASK_CONNECT , errStr ) ; jsvUnLock ( errStr ) ; } } 