void term_tbl ( struct termp * tp , const struct tbl_span * sp ) { const struct tbl_cell * cp , * cpn , * cpp , * cps ; const struct tbl_dat * dp ; static size_t offset ; size_t save_offset ; size_t coloff , tsz ; int hspans , ic , more ; int dvert , fc , horiz , lhori , rhori , uvert ; tp -> flags |= TERMP_NOSPACE | TERMP_NONOSPACE ; save_offset = tp -> tcol -> offset ; if ( tp -> tbl . cols == NULL ) { borders_locale = tp -> enc == TERMENC_UTF8 ?borders_utf8 : borders_ascii ; tp -> tbl . len = term_tbl_len ; tp -> tbl . slen = term_tbl_strlen ; tp -> tbl . sulen = term_tbl_sulen ; tp -> tbl . arg = tp ; tblcalc ( & tp -> tbl , sp , tp -> tcol -> offset , tp -> tcol -> rmargin ) ; offset = tp -> tcol -> offset ; if ( sp -> opts -> opts & TBL_OPT_CENTRE ) { tsz = sp -> opts -> opts & ( TBL_OPT_BOX | TBL_OPT_DBOX ) ?2 : ! ! sp -> opts -> lvert + ! ! sp -> opts -> rvert ; for ( ic = 0 ; ic + 1 < sp -> opts -> cols ; ic ++ ) { tsz += tp -> tbl . cols [ ic ] . width + tp -> tbl . cols [ ic ] . spacing ; } if ( sp -> opts -> cols ) { tsz += tp -> tbl . cols [ sp -> opts -> cols - 1 ] . width ; } if ( offset + tsz > tp -> tcol -> rmargin ) { tsz -= 1 ; } offset = offset + tp -> tcol -> rmargin > tsz ?( offset + tp -> tcol -> rmargin - tsz ) / 2 : 0 ; tp -> tcol -> offset = offset ; } if ( tp -> enc == TERMENC_ASCII && sp -> opts -> opts & TBL_OPT_DBOX ) { tbl_hrule ( tp , NULL , sp , sp , TBL_OPT_DBOX ) ; } if ( sp -> opts -> opts & ( TBL_OPT_DBOX | TBL_OPT_BOX ) ) { tbl_hrule ( tp , NULL , sp , sp , TBL_OPT_BOX ) ; } } tp -> flags |= TERMP_MULTICOL ; tp -> tcol -> offset = offset ; horiz = 0 ; switch ( sp -> pos ) { case TBL_SPAN_HORIZ : case TBL_SPAN_DHORIZ : horiz = 1 ; term_setcol ( tp , 1 ) ; break ; case TBL_SPAN_DATA : term_setcol ( tp , sp -> opts -> cols + 2 ) ; coloff = tp -> tcol -> offset ; if ( sp -> opts -> opts & ( TBL_OPT_BOX | TBL_OPT_DBOX ) || sp -> opts -> lvert ) { coloff ++ ; } tp -> tcol -> rmargin = coloff ; dp = sp -> first ; hspans = 0 ; for ( ic = 0 ; ic < sp -> opts -> cols ; ic ++ ) { if ( hspans == 0 ) { tp -> tcol ++ ; tp -> tcol -> offset = coloff ; } coloff += tp -> tbl . cols [ ic ] . width ; tp -> tcol -> rmargin = coloff ; if ( ic + 1 < sp -> opts -> cols ) { coloff += tp -> tbl . cols [ ic ] . spacing ; } if ( hspans ) { hspans -- ; continue ; } if ( dp != NULL && ( ic || sp -> layout -> first -> pos != TBL_CELL_SPAN ) ) { hspans = dp -> hspans ; dp = dp -> next ; } } tp -> tcol ++ ; tp -> tcol -> offset = coloff + 1 ; tp -> tcol -> rmargin = tp -> maxrmargin ; tp -> lasttcol = tp -> tcol - tp -> tcols ; tp -> tcol = tp -> tcols ; cp = cpn = sp -> layout -> first ; dp = sp -> first ; hspans = 0 ; for ( ic = 0 ; ic < sp -> opts -> cols ; ic ++ ) { if ( cpn != NULL ) { cp = cpn ; cpn = cpn -> next ; } if ( hspans ) { hspans -- ; continue ; } tp -> tcol ++ ; tp -> col = 0 ; tbl_data ( tp , sp -> opts , cp , dp , tp -> tbl . cols + ic ) ; if ( dp != NULL && ( ic || sp -> layout -> first -> pos != TBL_CELL_SPAN ) ) { hspans = dp -> hspans ; dp = dp -> next ; } } break ; } { tp -> tcol = tp -> tcols ; uvert = dvert = sp -> opts -> opts & TBL_OPT_DBOX ?2 : sp -> opts -> opts & TBL_OPT_BOX ?1 : 0 ; if ( sp -> pos == TBL_SPAN_DATA && uvert < sp -> layout -> vert ) { uvert = dvert = sp -> layout -> vert ; } if ( sp -> next != NULL && sp -> next -> pos == TBL_SPAN_DATA && dvert < sp -> next -> layout -> vert ) { dvert = sp -> next -> layout -> vert ; } if ( sp -> prev != NULL && uvert < sp -> prev -> layout -> vert && ( horiz || ( IS_HORIZ ( sp -> layout -> first ) && ! IS_HORIZ ( sp -> prev -> layout -> first ) ) ) ) { uvert = sp -> prev -> layout -> vert ; } rhori = sp -> pos == TBL_SPAN_DHORIZ || ( sp -> first != NULL && sp -> first -> pos == TBL_DATA_DHORIZ ) || sp -> layout -> first -> pos == TBL_CELL_DHORIZ ?2 : sp -> pos == TBL_SPAN_HORIZ || ( sp -> first != NULL && sp -> first -> pos == TBL_DATA_HORIZ ) || sp -> layout -> first -> pos == TBL_CELL_HORIZ ?1 : 0 ; fc = BUP * uvert + BDOWN * dvert + BRIGHT * rhori ; if ( uvert > 0 || dvert > 0 || ( horiz && sp -> opts -> lvert ) ) { * tp -> advance ( tp , tp -> tcols -> offset ) ; tp -> viscol = tp -> tcol -> offset ; tbl_direct_border ( tp , fc , 1 ) ; } more = 0 ; if ( horiz ) { tbl_hrule ( tp , sp -> prev , sp , sp -> next , 0 ) ; } else { cp = sp -> layout -> first ; cpn = sp -> next == NULL ?NULL : sp -> next -> layout -> first ; cpp = sp -> prev == NULL ?NULL : sp -> prev -> layout -> first ; dp = sp -> first ; hspans = 0 ; for ( ic = 0 ; ic < sp -> opts -> cols ; ic ++ ) { uvert = dvert = fc = 0 ; if ( cp != NULL ) { cps = cp ; while ( cps -> next != NULL && cps -> next -> pos == TBL_CELL_SPAN ) { cps = cps -> next ; } if ( sp -> pos == TBL_SPAN_DATA ) { uvert = dvert = cps -> vert ; } switch ( cp -> pos ) { case TBL_CELL_HORIZ : fc = BHORIZ ; break ; case TBL_CELL_DHORIZ : fc = BHORIZ * 2 ; break ; default : break ; } } if ( cpp != NULL ) { if ( uvert < cpp -> vert && cp != NULL && ( ( IS_HORIZ ( cp ) && ! IS_HORIZ ( cpp ) ) || ( cp -> next != NULL && cpp -> next != NULL && IS_HORIZ ( cp -> next ) && ! IS_HORIZ ( cpp -> next ) ) ) ) { uvert = cpp -> vert ; } cpp = cpp -> next ; } if ( sp -> opts -> opts & TBL_OPT_ALLBOX ) { if ( uvert == 0 ) { uvert = 1 ; } if ( dvert == 0 ) { dvert = 1 ; } } if ( cpn != NULL ) { if ( dvert == 0 || ( dvert < cpn -> vert && tp -> enc == TERMENC_UTF8 ) ) { dvert = cpn -> vert ; } cpn = cpn -> next ; } lhori = ( cp != NULL && cp -> pos == TBL_CELL_DHORIZ ) || ( dp != NULL && dp -> pos == TBL_DATA_DHORIZ ) ?2 : ( cp != NULL && cp -> pos == TBL_CELL_HORIZ ) || ( dp != NULL && dp -> pos == TBL_DATA_HORIZ ) ?1 : 0 ; if ( hspans ) { hspans -- ; cp = cp -> next ; continue ; } if ( dp != NULL && ( ic || sp -> layout -> first -> pos != TBL_CELL_SPAN ) ) { hspans = dp -> hspans ; dp = dp -> next ; } tp -> tcol ++ ; if ( tp -> tcol -> col < tp -> tcol -> lastcol ) { term_flushln ( tp ) ; } if ( tp -> tcol -> col < tp -> tcol -> lastcol ) { more = 1 ; } if ( fc == 0 && ( ( uvert == 0 && dvert == 0 && cp != NULL && ( cp -> next == NULL || ! IS_HORIZ ( cp -> next ) ) ) || tp -> tcol + 1 == tp -> tcols + tp -> lasttcol ) ) { if ( cp != NULL ) { cp = cp -> next ; } continue ; } if ( tp -> viscol < tp -> tcol -> rmargin ) { * tp -> advance ( tp , tp -> tcol -> rmargin - tp -> viscol ) ; tp -> viscol = tp -> tcol -> rmargin ; } while ( tp -> viscol < tp -> tcol -> rmargin + tp -> tbl . cols [ ic ] . spacing / 2 ) { tbl_direct_border ( tp , BHORIZ * lhori , 1 ) ; } if ( tp -> tcol + 1 == tp -> tcols + tp -> lasttcol ) { continue ; } if ( cp != NULL ) { cp = cp -> next ; } rhori = ( cp != NULL && cp -> pos == TBL_CELL_DHORIZ ) || ( dp != NULL && dp -> pos == TBL_DATA_DHORIZ ) ?2 : ( cp != NULL && cp -> pos == TBL_CELL_HORIZ ) || ( dp != NULL && dp -> pos == TBL_DATA_HORIZ ) ?1 : 0 ; if ( tp -> tbl . cols [ ic ] . spacing ) { tbl_direct_border ( tp , BLEFT * lhori + BRIGHT * rhori + BUP * uvert + BDOWN * dvert , 1 ) ; } if ( tp -> tbl . cols [ ic ] . spacing > 2 && ( uvert > 1 || dvert > 1 || rhori ) ) { tbl_direct_border ( tp , BHORIZ * rhori + BUP * ( uvert > 1 ) + BDOWN * ( dvert > 1 ) , 1 ) ; } } } uvert = dvert = sp -> opts -> opts & TBL_OPT_DBOX ?2 : sp -> opts -> opts & TBL_OPT_BOX ?1 : 0 ; if ( sp -> pos == TBL_SPAN_DATA && uvert < sp -> layout -> last -> vert && sp -> layout -> last -> col + 1 == sp -> opts -> cols ) { uvert = dvert = sp -> layout -> last -> vert ; } if ( sp -> next != NULL && dvert < sp -> next -> layout -> last -> vert && sp -> next -> layout -> last -> col + 1 == sp -> opts -> cols ) { dvert = sp -> next -> layout -> last -> vert ; } if ( sp -> prev != NULL && uvert < sp -> prev -> layout -> last -> vert && sp -> prev -> layout -> last -> col + 1 == sp -> opts -> cols && ( horiz || ( IS_HORIZ ( sp -> layout -> last ) && ! IS_HORIZ ( sp -> prev -> layout -> last ) ) ) ) { uvert = sp -> prev -> layout -> last -> vert ; } lhori = sp -> pos == TBL_SPAN_DHORIZ || ( sp -> last != NULL && sp -> last -> pos == TBL_DATA_DHORIZ && sp -> last -> layout -> col + 1 == sp -> opts -> cols ) || ( sp -> layout -> last -> pos == TBL_CELL_DHORIZ && sp -> layout -> last -> col + 1 == sp -> opts -> cols ) ?2 : sp -> pos == TBL_SPAN_HORIZ || ( sp -> last != NULL && sp -> last -> pos == TBL_DATA_HORIZ && sp -> last -> layout -> col + 1 == sp -> opts -> cols ) || ( sp -> layout -> last -> pos == TBL_CELL_HORIZ && sp -> layout -> last -> col + 1 == sp -> opts -> cols ) ?1 : 0 ; fc = BUP * uvert + BDOWN * dvert + BLEFT * lhori ; if ( uvert > 0 || dvert > 0 || ( horiz && sp -> opts -> rvert ) ) { if ( horiz == 0 && ( IS_HORIZ ( sp -> layout -> last ) == 0 || sp -> layout -> last -> col + 1 < sp -> opts -> cols ) ) { tp -> tcol ++ ; { tbl_direct_border ( tp , BHORIZ * lhori , 1 ) ; } tp -> viscol < tp -> tcol -> offset ; } tbl_direct_border ( tp , fc , 1 ) ; } * tp -> endline ( tp ) ; tp -> viscol = 0 ; } more ; term_setcol ( tp , 1 ) ; tp -> flags &= ~ TERMP_MULTICOL ; tp -> tcol -> rmargin = tp -> maxrmargin ; if ( sp -> next == NULL ) { if ( sp -> opts -> opts & ( TBL_OPT_DBOX | TBL_OPT_BOX ) ) { tbl_hrule ( tp , sp , sp , NULL , TBL_OPT_BOX ) ; tp -> skipvsp = 1 ; } if ( tp -> enc == TERMENC_ASCII && sp -> opts -> opts & TBL_OPT_DBOX ) { tbl_hrule ( tp , sp , sp , NULL , TBL_OPT_DBOX ) ; tp -> skipvsp = 2 ; } assert ( tp -> tbl . cols ) ; free ( tp -> tbl . cols ) ; tp -> tbl . cols = NULL ; } if ( horiz == 0 && sp -> opts -> opts & TBL_OPT_ALLBOX && ( sp -> next == NULL || sp -> next -> pos == TBL_SPAN_DATA || sp -> next -> next != NULL ) ) { tbl_hrule ( tp , sp , sp , sp -> next , TBL_OPT_ALLBOX ) ; } tp -> tcol -> offset = save_offset ; tp -> flags &= ~ TERMP_NONOSPACE ; } 