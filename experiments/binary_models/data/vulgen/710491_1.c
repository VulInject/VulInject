void e1000e_ptp_init ( struct e1000_adapter * adapter ) { struct e1000_hw * hw = & adapter -> hw ; adapter -> ptp_clock = NULL ; adapter -> ptp_clock_info = e1000e_ptp_clock_info ; snprintf ( adapter -> ptp_clock_info . name , sizeof ( adapter -> ptp_clock_info . name ) , "%pm" , adapter -> netdev -> perm_addr ) ; switch ( hw -> mac . type ) { case e1000_pch2lan : case e1000_pch_lpt : case e1000_pch_spt : case e1000_pch_cnp : if ( ( hw -> mac . type < e1000_pch_lpt ) || ( er32 ( TSYNCRXCTL ) & E1000_TSYNCRXCTL_SYSCFI ) ) { adapter -> ptp_clock_info . max_adj = 24000000 - 1 ; break ; } case e1000_82574 : case e1000_82583 : adapter -> ptp_clock_info . max_adj = 600000000 - 1 ; break ; default : break ; } if ( hw -> mac . type >= e1000_pch_spt && boot_cpu_has ( X86_FEATURE_ART ) ) { adapter -> ptp_clock_info . getcrosststamp = e1000e_phc_getcrosststamp ; } INIT_DELAYED_WORK ( & adapter -> systim_overflow_work , e1000e_systim_overflow_work ) ; schedule_delayed_work ( & adapter -> systim_overflow_work , E1000_SYSTIM_OVERFLOW_PERIOD ) ; adapter -> ptp_clock = ptp_clock_register ( & adapter -> ptp_clock_info , & adapter -> pdev -> dev ) ; if ( IS_ERR ( adapter -> ptp_clock ) ) { adapter -> ptp_clock = NULL ; e_err ( "ptp_clock_register failed\n" ) ; } if ( adapter -> ptp_clock ) { e_info ( "registered PHC clock\n" ) ; } } 