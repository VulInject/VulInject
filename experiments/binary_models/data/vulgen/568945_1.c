static void rt2x00queue_create_tx_descriptor ( struct rt2x00_dev * rt2x00dev , struct sk_buff * skb , struct txentry_desc * txdesc , struct ieee80211_sta * sta ) { struct ieee80211_tx_info * tx_info = IEEE80211_SKB_CB ( skb ) ; struct ieee80211_hdr * hdr = ( ieee80211_hdr * ) skb -> data ; struct ieee80211_tx_rate * txrate = & tx_info -> control . rates [ 0 ] ; struct ieee80211_rate * rate ; const struct rt2x00_rate * hwrate = NULL ; txdesc -> length = skb -> len ; txdesc -> header_length = ieee80211_get_hdrlen_from_skb ( skb ) ; if ( ! ( tx_info -> flags & IEEE80211_TX_CTL_NO_ACK ) ) { __set_bit ( ENTRY_TXD_ACK , & txdesc -> flags ) ; } if ( ieee80211_is_rts ( hdr -> frame_control ) || ieee80211_is_cts ( hdr -> frame_control ) ) { __set_bit ( ENTRY_TXD_BURST , & txdesc -> flags ) ; if ( ieee80211_is_rts ( hdr -> frame_control ) ) { __set_bit ( ENTRY_TXD_RTS_FRAME , & txdesc -> flags ) ; } else { __set_bit ( ENTRY_TXD_CTS_FRAME , & txdesc -> flags ) ; } if ( tx_info -> control . rts_cts_rate_idx >= 0 ) { rate = ieee80211_get_rts_cts_rate ( rt2x00dev -> hw , tx_info ) ; } } txdesc -> retry_limit = tx_info -> control . rates [ 0 ] . count - 1 ; if ( txdesc -> retry_limit >= rt2x00dev -> long_retry ) { __set_bit ( ENTRY_TXD_RETRY_MODE , & txdesc -> flags ) ; } if ( ieee80211_has_morefrags ( hdr -> frame_control ) ) { __set_bit ( ENTRY_TXD_BURST , & txdesc -> flags ) ; __set_bit ( ENTRY_TXD_MORE_FRAG , & txdesc -> flags ) ; } if ( tx_info -> flags & IEEE80211_TX_CTL_MORE_FRAMES ) { __set_bit ( ENTRY_TXD_BURST , & txdesc -> flags ) ; } if ( ieee80211_is_beacon ( hdr -> frame_control ) || ieee80211_is_probe_resp ( hdr -> frame_control ) ) { __set_bit ( ENTRY_TXD_REQ_TIMESTAMP , & txdesc -> flags ) ; } if ( ( tx_info -> flags & IEEE80211_TX_CTL_FIRST_FRAGMENT ) && ! test_bit ( ENTRY_TXD_RTS_FRAME , & txdesc -> flags ) ) { __set_bit ( ENTRY_TXD_FIRST_FRAGMENT , & txdesc -> flags ) ; } if ( txrate -> flags & IEEE80211_TX_RC_GREEN_FIELD ) { txdesc -> rate_mode = RATE_MODE_HT_GREENFIELD ; } if ( txrate -> flags & IEEE80211_TX_RC_MCS ) { txdesc -> rate_mode = RATE_MODE_HT_MIX ; } else { rate = ieee80211_get_tx_rate ( rt2x00dev -> hw , tx_info ) ; hwrate = rt2x00_get_rate ( rate -> hw_value ) ; if ( hwrate -> flags & DEV_RATE_OFDM ) { txdesc -> rate_mode = RATE_MODE_OFDM ; } else { txdesc -> rate_mode = RATE_MODE_CCK ; } } rt2x00crypto_create_tx_descriptor ( rt2x00dev , skb , txdesc ) ; rt2x00queue_create_tx_descriptor_seq ( rt2x00dev , skb , txdesc ) ; if ( rt2x00_has_cap_flag ( rt2x00dev , REQUIRE_HT_TX_DESC ) ) { rt2x00queue_create_tx_descriptor_ht ( rt2x00dev , skb , txdesc , sta , hwrate ) ; } else { rt2x00queue_create_tx_descriptor_plcp ( rt2x00dev , skb , txdesc , hwrate ) ; } } 