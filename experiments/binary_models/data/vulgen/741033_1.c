int qtree_read_dquot ( struct qtree_mem_dqinfo * info , struct dquot * dquot ) { int type = dquot -> dq_id . type ; struct super_block * sb = dquot -> dq_sb ; loff_t offset ; char * ddquot ; int ret = 0 ; if ( ! sb_dqopt ( dquot -> dq_sb ) -> files [ type ] ) { quota_error ( sb , "Quota invalidated while reading!" ) ; return - EIO ; } if ( ! dquot -> dq_off ) { offset = find_dqentry ( info , dquot ) ; if ( offset <= 0 ) { if ( offset < 0 ) { quota_error ( sb , "Can't read quota structure " "for id %u" , from_kqid ( & init_user_ns , dquot -> dq_id ) ) ; } dquot -> dq_off = 0 ; set_bit ( DQ_FAKE_B , & dquot -> dq_flags ) ; memset ( & dquot -> dq_dqb , 0 , sizeof ( mem_dqblk ) ) ; ret = offset ; out } dquot -> dq_off = offset ; } ddquot = kmalloc ( info -> dqi_entry_size , GFP_NOFS ) ; if ( ! ddquot ) { return - ENOMEM ; } ret = sb -> s_op -> quota_read ( sb , type , ddquot , info -> dqi_entry_size , dquot -> dq_off ) ; if ( ret != info -> dqi_entry_size ) { if ( ret >= 0 ) { ret = - EIO ; } quota_error ( sb , "Error while reading quota structure for id %u" , from_kqid ( & init_user_ns , dquot -> dq_id ) ) ; set_bit ( DQ_FAKE_B , & dquot -> dq_flags ) ; memset ( & dquot -> dq_dqb , 0 , sizeof ( mem_dqblk ) ) ; out } spin_lock ( & dquot -> dq_dqb_lock ) ; info -> dqi_ops -> disk2mem_dqblk ( dquot , ddquot ) ; if ( ! dquot -> dq_dqb . dqb_bhardlimit && ! dquot -> dq_dqb . dqb_bsoftlimit && ! dquot -> dq_dqb . dqb_ihardlimit && ! dquot -> dq_dqb . dqb_isoftlimit ) { set_bit ( DQ_FAKE_B , & dquot -> dq_flags ) ; } spin_unlock ( & dquot -> dq_dqb_lock ) ; kfree ( ddquot ) ; out dqstats_inc ( DQST_READS ) ; return ret ; } 