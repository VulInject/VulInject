static int iss_video_open ( struct file * file ) { struct iss_video * video = video_drvdata ( file ) ; struct iss_video_fh * handle ; struct vb2_queue * q ; int ret = 0 ; handle = kzalloc ( sizeof ( * handle ) , GFP_KERNEL ) ; if ( ! handle ) { return - ENOMEM ; } v4l2_fh_init ( & handle -> vfh , & video -> video ) ; v4l2_fh_add ( & handle -> vfh ) ; if ( ! omap4iss_get ( video -> iss ) ) { ret = - EBUSY ; done } ret = v4l2_pipeline_pm_use ( & video -> video . entity , 1 ) ; if ( ret < 0 ) { omap4iss_put ( video -> iss ) ; done } q = & handle -> queue ; q -> type = video -> type ; q -> io_modes = VB2_MMAP | VB2_DMABUF ; q -> drv_priv = handle ; q -> ops = & iss_video_vb2ops ; q -> mem_ops = & vb2_dma_contig_memops ; q -> buf_struct_size = sizeof ( iss_buffer ) ; q -> timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC ; q -> dev = video -> iss -> dev ; ret = vb2_queue_init ( q ) ; if ( ret ) { omap4iss_put ( video -> iss ) ; done } handle -> format . type = video -> type ; handle -> timeperframe . denominator = 1 ; handle -> video = video ; file -> private_data = & handle -> vfh ; done if ( ret < 0 ) { v4l2_fh_del ( & handle -> vfh ) ; v4l2_fh_exit ( & handle -> vfh ) ; kfree ( handle ) ; } return ret ; } 