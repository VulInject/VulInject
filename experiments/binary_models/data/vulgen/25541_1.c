static KMF_RETURN readAltFormatPrivateKey ( KMF_DATA * filedata , EVP_PKEY * * pkey ) { KMF_RETURN ret = KMF_OK ; KMF_RAW_RSA_KEY rsa ; BerElement * asn1 = NULL ; BerValue filebuf ; BerValue OID = { 0 0 } ; BerValue * Mod = NULL , * PubExp = NULL ; BerValue * PriExp = NULL , * Prime1 = NULL , * Prime2 = NULL ; BerValue * Coef = NULL ; BIGNUM * D = NULL , * P = NULL , * Q = NULL , * COEF = NULL ; BIGNUM * Exp1 = NULL , * Exp2 = NULL , * pminus1 = NULL ; BIGNUM * qminus1 = NULL ; BN_CTX * ctx = NULL ; * pkey = NULL ; filebuf . bv_val = ( char * ) filedata -> Data ; filebuf . bv_len = filedata -> Length ; asn1 = kmfder_init ( & filebuf ) ; if ( asn1 == NULL ) { out } if ( kmfber_scanf ( asn1 , "{{Dn{IIIIII}}}" , & OID , & Mod , & PubExp , & PriExp , & Prime1 , & Prime2 , & Coef ) == - 1 ) { ret = KMF_ERR_ENCODING ; out } D = BN_bin2bn ( ( const uchar_t * ) PriExp -> bv_val , PriExp -> bv_len , D ) ; if ( D == NULL ) { ret = KMF_ERR_MEMORY ; out } P = BN_bin2bn ( ( const uchar_t * ) Prime1 -> bv_val , Prime1 -> bv_len , P ) ; if ( D == NULL ) { ret = KMF_ERR_MEMORY ; out } Q = BN_bin2bn ( ( const uchar_t * ) Prime2 -> bv_val , Prime2 -> bv_len , Q ) ; if ( ( ctx = BN_CTX_new ( ) ) == NULL ) { ret = KMF_ERR_MEMORY ; out } pminus1 = BN_new ( ) ; ( void ) BN_sub ( pminus1 , P , BN_value_one ( ) ) ; Exp1 = BN_new ( ) ; ( void ) BN_mod ( Exp1 , D , pminus1 , ctx ) ; qminus1 = BN_new ( ) ; ( void ) BN_sub ( qminus1 , Q , BN_value_one ( ) ) ; Exp2 = BN_new ( ) ; ( void ) BN_mod ( Exp2 , D , qminus1 , ctx ) ; COEF = BN_new ( ) ; ( void ) BN_mod_inverse ( COEF , Q , P , ctx ) ; ( void ) memset ( & rsa , 0 , sizeof ( rsa ) ) ; if ( ( ret = sslBN2KMFBN ( Exp1 , & rsa . exp1 ) ) != KMF_OK ) { out } if ( ( ret = sslBN2KMFBN ( Exp2 , & rsa . exp2 ) ) != KMF_OK ) { out } if ( ( ret = sslBN2KMFBN ( COEF , & rsa . coef ) ) != KMF_OK ) { out } rsa . mod . val = ( uchar_t * ) Mod -> bv_val ; rsa . mod . len = Mod -> bv_len ; rsa . pubexp . val = ( uchar_t * ) PubExp -> bv_val ; rsa . pubexp . len = PubExp -> bv_len ; rsa . priexp . val = ( uchar_t * ) PriExp -> bv_val ; rsa . priexp . len = PriExp -> bv_len ; rsa . prime1 . val = ( uchar_t * ) Prime1 -> bv_val ; rsa . prime1 . len = Prime1 -> bv_len ; rsa . prime2 . val = ( uchar_t * ) Prime2 -> bv_val ; rsa . prime2 . len = Prime2 -> bv_len ; * pkey = ImportRawRSAKey ( & rsa ) ; out if ( asn1 != NULL ) { kmfber_free ( asn1 , 1 ) ; } if ( OID . bv_val ) { free ( OID . bv_val ) ; } if ( PriExp ) { free ( PriExp ) ; } if ( Mod ) { free ( Mod ) ; } if ( PubExp ) { free ( PubExp ) ; } if ( Coef ) { ( void ) memset ( Coef -> bv_val , 0 , Coef -> bv_len ) ; free ( Coef -> bv_val ) ; free ( Coef ) ; } if ( Prime1 ) { free ( Prime1 ) ; } if ( Prime2 ) { free ( Prime2 ) ; } if ( ctx != NULL ) { BN_CTX_free ( ctx ) ; } if ( D ) { BN_clear_free ( D ) ; } if ( P ) { BN_clear_free ( P ) ; } if ( Q ) { BN_clear_free ( Q ) ; } if ( pminus1 ) { BN_clear_free ( pminus1 ) ; } if ( qminus1 ) { BN_clear_free ( qminus1 ) ; } if ( Exp1 ) { BN_clear_free ( Exp1 ) ; } if ( Exp2 ) { BN_clear_free ( Exp2 ) ; } return ( ret ) ; } 