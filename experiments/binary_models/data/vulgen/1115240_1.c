bool init_route_list ( struct route_list * rl , const struct route_option_list * opt , const char * remote_endpoint , int default_metric , in_addr_t remote_host , struct env_set * es , openvpn_net_ctx_t * ctx ) { struct gc_arena gc = gc_new ( ) ; bool ret = true ; clear_route_list ( rl ) ; rl -> flags = opt -> flags ; if ( remote_host != IPV4_INVALID_ADDR ) { rl -> spec . remote_host = remote_host ; rl -> spec . flags |= RTSA_REMOTE_HOST ; } if ( default_metric ) { rl -> spec . default_metric = default_metric ; rl -> spec . flags |= RTSA_DEFAULT_METRIC ; } get_default_gateway ( & rl -> rgi , ctx ) ; if ( rl -> rgi . flags & RGI_ADDR_DEFINED ) { setenv_route_addr ( es , "net_gateway" , rl -> rgi . gateway . addr , - 1 ) ; print_default_gateway ( D_ROUTE , & rl -> rgi , NULL ) ; } else { dmsg ( D_ROUTE , "ROUTE: default_gateway=UNDEF" ) ; } if ( rl -> spec . flags & RTSA_REMOTE_HOST ) { rl -> spec . remote_host_local = test_local_addr ( remote_host , & rl -> rgi ) ; } if ( is_route_parm_defined ( remote_endpoint ) ) { bool defined = false ; rl -> spec . remote_endpoint = getaddr ( GETADDR_RESOLVE | GETADDR_HOST_ORDER | GETADDR_WARN_ON_SIGNAL , remote_endpoint , 0 , & defined , NULL ) ; if ( defined ) { setenv_route_addr ( es , "vpn_gateway" , rl -> spec . remote_endpoint , - 1 ) ; rl -> spec . flags |= RTSA_REMOTE_ENDPOINT ; } else { msg ( M_WARN , PACKAGE_NAME " ROUTE: failed to parse/resolve default gateway: %s" , remote_endpoint ) ; ret = false ; } } { struct route_option * ro ; for ( ro = opt -> routes ; ro ; ro = ro -> next ) { struct addrinfo * netlist = NULL ; struct route_ipv4 r ; if ( ! init_route ( & r , & netlist , ro , rl ) ) { ret = false ; } else { struct addrinfo * curele ; for ( curele = netlist ; curele ; curele = curele -> ai_next ) { route_ipv4 * new ; ALLOC_OBJ_GC ( new , route_ipv4 , & rl -> gc ) ; * new = r ; new -> network = ntohl ( ( ( sockaddr_in * ) curele -> ai_addr ) -> sin_addr . s_addr ) ; new -> next = rl -> routes ; rl -> routes = new ; } } if ( netlist ) { gc_addspecial ( netlist , & gc_freeaddrinfo_callback , & gc ) ; } } } gc_free ( & gc ) ; return ret ; } 