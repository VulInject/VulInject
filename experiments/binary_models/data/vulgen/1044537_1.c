void stmf_deregister_scsi_session ( stmf_local_port_t * lport , stmf_scsi_session_t * ss ) { stmf_i_local_port_t * ilport = ( stmf_i_local_port_t * ) lport -> lport_stmf_private ; stmf_i_scsi_session_t * iss , * * ppss ; int found = 0 ; stmf_ic_msg_t * ic_session_dereg ; stmf_status_t ic_ret = STMF_FAILURE ; stmf_lun_map_t * sm ; stmf_i_lu_t * ilu ; uint16_t n ; stmf_lun_map_ent_t * ent ; DTRACE_PROBE2 ( session__offline , stmf_local_port_t * , lport , stmf_scsi_session_t * , ss ) ; iss = ( stmf_i_scsi_session_t * ) ss -> ss_stmf_private ; if ( ss -> ss_rport_alias ) { ss -> ss_rport_alias = NULL ; } try_dereg_ss_again mutex_enter ( & stmf_state . stmf_lock ) ; if ( iss -> iss_flags & ISS_EVENT_ACTIVE ) { mutex_exit ( & stmf_state . stmf_lock ) ; delay ( 1 ) ; try_dereg_ss_again } if ( stmf_state . stmf_alua_state == 1 && ilport -> ilport_standby == 0 && ilport -> ilport_alua == 1 ) { ic_session_dereg = ic_session_dereg_msg_alloc ( ss , stmf_proxy_msg_id ) ; if ( ic_session_dereg ) { ic_ret = ic_tx_msg ( ic_session_dereg ) ; if ( ic_ret == STMF_IC_MSG_SUCCESS ) { stmf_proxy_msg_id ++ ; } } } rw_enter ( & ilport -> ilport_lock , RW_WRITER ) ; for ( ppss = & ilport -> ilport_ss_list ; * ppss != NULL ; ppss = & ( ( * ppss ) -> iss_next ) ) { if ( iss == ( * ppss ) ) { * ppss = ( * ppss ) -> iss_next ; found = 1 ; break ; } } if ( ! found ) { cmn_err ( CE_PANIC , "Deregister session called for non existent" " session" ) ; } ilport -> ilport_nsessions -- ; stmf_irport_deregister ( iss -> iss_irport ) ; sm = iss -> iss_sm ; iss -> iss_sm = NULL ; iss -> iss_hg = NULL ; rw_exit ( & ilport -> ilport_lock ) ; if ( sm -> lm_nentries ) { for ( n = 0 ; n < sm -> lm_nentries ; n ++ ) { if ( ( ent = ( stmf_lun_map_ent_t * ) sm -> lm_plus [ n ] ) != NULL ) { if ( ent -> ent_itl_datap ) { stmf_do_itl_dereg ( ent -> ent_lu , ent -> ent_itl_datap , STMF_ITL_REASON_IT_NEXUS_LOSS ) ; } ilu = ( stmf_i_lu_t * ) ent -> ent_lu -> lu_stmf_private ; atomic_dec_32 ( & ilu -> ilu_ref_cnt ) ; kmem_free ( sm -> lm_plus [ n ] , sizeof ( stmf_lun_map_ent_t ) ) ; } } kmem_free ( sm -> lm_plus , sizeof ( stmf_lun_map_ent_t * ) * sm -> lm_nentries ) ; } kmem_free ( sm , sizeof ( * sm ) ) ; if ( iss -> iss_flags & ISS_NULL_TPTID ) { stmf_remote_port_free ( ss -> ss_rport ) ; } mutex_exit ( & stmf_state . stmf_lock ) ; } 