asmlinkage void do_cpu ( struct pt_regs * regs ) { enum ctx_state prev_state ; unsigned int __user * epc ; unsigned long old_epc , old31 ; unsigned int opcode ; unsigned int cpid ; int status ; prev_state = exception_enter ( ) ; cpid = ( regs -> cp0_cause >> CAUSEB_CE ) & 3 ; if ( cpid != 2 ) { die_if_kernel ( "do_cpu invoked from kernel context!" , regs ) ; } switch ( cpid ) { case 0 : epc = ( unsigned int __user * ) exception_epc ( regs ) ; old_epc = regs -> cp0_epc ; old31 = regs -> regs [ 31 ] ; opcode = 0 ; status = - 1 ; if ( unlikely ( compute_return_epc ( regs ) < 0 ) ) { break ; } if ( ! get_isa16_mode ( regs -> cp0_epc ) ) { if ( unlikely ( get_user ( opcode , epc ) < 0 ) ) { status = SIGSEGV ; } } if ( status < 0 ) { status = SIGILL ; } if ( unlikely ( status > 0 ) ) { regs -> cp0_epc = old_epc ; regs -> regs [ 31 ] = old31 ; force_sig ( status ) ; } break ; case 3 : if ( raw_cpu_has_fpu || ! cpu_has_mips_4_5_64_r2_r6 ) { force_sig ( SIGILL ) ; break ; } fallthrough ; case 1 : { void __user * fault_addr ; unsigned long fcr31 ; int err , sig ; err = enable_restore_fp_context ( 0 ) ; if ( raw_cpu_has_fpu && ! err ) { break ; } sig = fpu_emulator_cop1Handler ( regs , & current -> thread . fpu , 0 , & fault_addr ) ; fcr31 = mask_fcr31_x ( current -> thread . fpu . fcr31 ) ; current -> thread . fpu . fcr31 &= ~ fcr31 ; if ( ! process_fpemu_return ( sig , fault_addr , fcr31 ) && ! err ) { mt_ase_fp_affinity ( ) ; } break ; } case 1 : case 3 : force_sig ( SIGILL ) ; break ; case 2 : raw_notifier_call_chain ( & cu2_chain , CU2_EXCEPTION , regs ) ; break ; } exception_exit ( prev_state ) ; } 