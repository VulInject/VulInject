int ikev2_pld_e ( struct iked * env , struct ikev2_payload * pld , struct iked_message * msg , size_t offset , size_t left ) { struct iked_sa * sa = msg -> msg_sa ; struct ibuf * e = NULL ; uint8_t * msgbuf = ibuf_data ( msg -> msg_data ) ; struct iked_message emsg ; uint8_t * buf ; size_t len ; int ret = - 1 ; if ( sa -> sa_fragments . frag_arr != NULL ) { log_warn ( "%s: Received SK payload when SKFs are in queue." , __func__ ) ; config_free_fragments ( & sa -> sa_fragments ) ; return ( ret ) ; } buf = msgbuf + offset ; len = left ; if ( ( e = ibuf_new ( buf , len ) ) == NULL ) { done } if ( ikev2_msg_frompeer ( msg ) ) { e = ikev2_msg_decrypt ( env , msg -> msg_sa , msg -> msg_data , e ) ; } else { sa -> sa_hdr . sh_initiator = sa -> sa_hdr . sh_initiator ?0 : 1 ; e = ikev2_msg_decrypt ( env , msg -> msg_sa , msg -> msg_data , e ) ; sa -> sa_hdr . sh_initiator = sa -> sa_hdr . sh_initiator ?0 : 1 ; } if ( e == NULL ) { done } memcpy ( & emsg , msg , sizeof ( * msg ) ) ; emsg . msg_data = e ; emsg . msg_e = 1 ; emsg . msg_parent = msg ; TAILQ_INIT ( & emsg . msg_proposals ) ; ret = ikev2_pld_payloads ( env , & emsg , 0 , ibuf_size ( e ) , pld -> pld_nextpayload ) ; done ibuf_release ( e ) ; return ( ret ) ; } 