BOOL search ( void ) { char * volatile egreperror = NULL ; FINDINIT volatile rc = NOERROR ; SIGTYPE ( * volatile savesig ) ( ) = SIG_DFL ; FP f ; char * s ; int c ; if ( caseless == YES ) { for ( s = pattern ; * s != '\0' ; ++ s ) { * s = tolower ( * s ) ; } } if ( writerefsfound ( ) == NO ) { return ( NO ) ; } if ( linemode == NO ) { putmsg ( "Searching" ) ; } initprogress ( ) ; if ( setjmp ( env ) == 0 ) { savesig = signal ( SIGINT , jumpback ) ; f = fields [ field ] . findfcn ; if ( fields [ field ] . patterntype == EGREP ) { egreperror = * f ( pattern ) ; } else { if ( ( nonglobalrefs = fopen ( temp2 , "w" ) ) == NULL ) { cannotopen ( temp2 ) ; return ( NO ) ; } if ( ( rc = findinit ( ) ) == NOERROR ) { * f ( ) ; findcleanup ( ) ; ( void ) freopen ( temp2 , "r" , nonglobalrefs ) ; while ( ( c = getc ( nonglobalrefs ) ) != EOF ) { ( void ) putc ( c , refsfound ) ; } } ( void ) fclose ( nonglobalrefs ) ; } } ( void ) signal ( SIGINT , savesig ) ; ( void ) freopen ( temp1 , "r" , refsfound ) ; nextline = 1 ; totallines = 0 ; if ( ( c = getc ( refsfound ) ) == EOF ) { if ( egreperror != NULL ) { ( void ) sprintf ( lastmsg , "Egrep %s in this pattern: %s" , egreperror , pattern ) ; } if ( rc == NOTSYMBOL ) { ( void ) sprintf ( lastmsg , "This is not a C symbol: %s" , pattern ) ; } if ( rc == REGCMPERROR ) { ( void ) sprintf ( lastmsg , "Error in this regcmp(3C) regular expression: %s" , pattern ) ; } else { ( void ) sprintf ( lastmsg , "Could not find the %s: %s" , fields [ field ] . text2 , pattern ) ; } return ( NO ) ; } ( void ) ungetc ( c , refsfound ) ; countrefs ( ) ; return ( YES ) ; } 