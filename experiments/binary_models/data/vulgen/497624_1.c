int savage_bci_cmdbuf ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { drm_savage_private_t * dev_priv = dev -> dev_private ; struct drm_device_dma * dma = dev -> dma ; struct drm_buf * dmabuf ; drm_savage_cmdbuf_t * cmdbuf = data ; drm_savage_cmd_header_t * kcmd_addr = NULL ; drm_savage_cmd_header_t * first_draw_cmd ; unsigned int * kvb_addr = NULL ; struct drm_clip_rect * kbox_addr = NULL ; unsigned int i , j ; int ret = 0 ; DRM_DEBUG ( "\n" ) ; LOCK_TEST_WITH_RETURN ( dev , file_priv ) ; if ( dma && dma -> buflist ) { if ( cmdbuf -> dma_idx > dma -> buf_count ) { DRM_ERROR ( "vertex buffer index %u out of range (0-%u)\n" , cmdbuf -> dma_idx , dma -> buf_count - 1 ) ; return - EINVAL ; } dmabuf = dma -> buflist [ cmdbuf -> dma_idx ] ; } else { dmabuf = NULL ; } if ( cmdbuf -> size ) { kcmd_addr = kmalloc_array ( cmdbuf -> size , 8 , GFP_KERNEL ) ; if ( kcmd_addr == NULL ) { return - ENOMEM ; } if ( copy_from_user ( kcmd_addr , cmdbuf -> cmd_addr , cmdbuf -> size * 8 ) ) { return - EFAULT ; } cmdbuf -> cmd_addr = kcmd_addr ; } if ( cmdbuf -> vb_size ) { kvb_addr = memdup_user ( cmdbuf -> vb_addr , cmdbuf -> vb_size ) ; if ( IS_ERR ( kvb_addr ) ) { ret = PTR_ERR ( kvb_addr ) ; kvb_addr = NULL ; done } cmdbuf -> vb_addr = kvb_addr ; } if ( cmdbuf -> nbox ) { kbox_addr = kmalloc_array ( cmdbuf -> nbox , sizeof ( drm_clip_rect ) , GFP_KERNEL ) ; if ( kbox_addr == NULL ) { ret = - ENOMEM ; done } if ( copy_from_user ( kbox_addr , cmdbuf -> box_addr , cmdbuf -> nbox * sizeof ( drm_clip_rect ) ) ) { ret = - EFAULT ; done } cmdbuf -> box_addr = kbox_addr ; } mb ( ) ; dev_priv -> waiting = 1 ; i = 0 ; first_draw_cmd = NULL ; while ( i < cmdbuf -> size ) { drm_savage_cmd_header_t cmd_header ; cmd_header = * ( drm_savage_cmd_header_t * ) cmdbuf -> cmd_addr ; cmdbuf -> cmd_addr ++ ; i ++ ; j = 0 ; switch ( cmd_header . cmd . cmd ) { case SAVAGE_CMD_DMA_IDX : case SAVAGE_CMD_VB_IDX : j = ( cmd_header . idx . count + 3 ) / 4 ; if ( i + j > cmdbuf -> size ) { DRM_ERROR ( "indexed drawing command extends " "beyond end of command buffer\n" ) ; DMA_FLUSH ( ) ; ret = - EINVAL ; done } case SAVAGE_CMD_DMA_PRIM : case SAVAGE_CMD_VB_PRIM : if ( ! first_draw_cmd ) { first_draw_cmd = cmdbuf -> cmd_addr - 1 ; } cmdbuf -> cmd_addr += j ; i += j ; break ; default : if ( first_draw_cmd ) { ret = savage_dispatch_draw ( dev_priv , first_draw_cmd , cmdbuf -> cmd_addr - 1 , dmabuf , cmdbuf -> vb_addr , cmdbuf -> vb_size , cmdbuf -> vb_stride , cmdbuf -> nbox , cmdbuf -> box_addr ) ; if ( ret != 0 ) { done } first_draw_cmd = NULL ; } } if ( first_draw_cmd ) { continue ; } switch ( cmd_header . cmd . cmd ) { case SAVAGE_CMD_STATE : j = ( cmd_header . state . count + 1 ) / 2 ; if ( i + j > cmdbuf -> size ) { DRM_ERROR ( "command SAVAGE_CMD_STATE extends " "beyond end of command buffer\n" ) ; DMA_FLUSH ( ) ; ret = - EINVAL ; done } ret = savage_dispatch_state ( dev_priv , & cmd_header , ( const uint32_t * ) cmdbuf -> cmd_addr ) ; cmdbuf -> cmd_addr += j ; i += j ; break ; case SAVAGE_CMD_CLEAR : if ( i + 1 > cmdbuf -> size ) { DRM_ERROR ( "command SAVAGE_CMD_CLEAR extends " "beyond end of command buffer\n" ) ; DMA_FLUSH ( ) ; ret = - EINVAL ; done } ret = savage_dispatch_clear ( dev_priv , & cmd_header , cmdbuf -> cmd_addr , cmdbuf -> nbox , cmdbuf -> box_addr ) ; cmdbuf -> cmd_addr ++ ; i ++ ; break ; case SAVAGE_CMD_SWAP : ret = savage_dispatch_swap ( dev_priv , cmdbuf -> nbox , cmdbuf -> box_addr ) ; break ; default : DRM_ERROR ( "invalid command 0x%x\n" , cmd_header . cmd . cmd ) ; DMA_FLUSH ( ) ; ret = - EINVAL ; done } if ( ret != 0 ) { DMA_FLUSH ( ) ; done } } if ( first_draw_cmd ) { ret = savage_dispatch_draw ( dev_priv , first_draw_cmd , cmdbuf -> cmd_addr , dmabuf , cmdbuf -> vb_addr , cmdbuf -> vb_size , cmdbuf -> vb_stride , cmdbuf -> nbox , cmdbuf -> box_addr ) ; if ( ret != 0 ) { DMA_FLUSH ( ) ; done } } DMA_FLUSH ( ) ; if ( dmabuf && cmdbuf -> discard ) { drm_savage_buf_priv_t * buf_priv = dmabuf -> dev_private ; uint16_t event ; event = savage_bci_emit_event ( dev_priv , SAVAGE_WAIT_3D ) ; SET_AGE ( & buf_priv -> age , event , dev_priv -> event_wrap ) ; savage_freelist_put ( dev , dmabuf ) ; } done kfree ( kcmd_addr ) ; kfree ( kvb_addr ) ; kfree ( kbox_addr ) ; return ret ; } 