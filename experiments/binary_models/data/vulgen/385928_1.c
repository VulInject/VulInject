static int tls_exec_passphrase_provider ( server_rec * s , char * buf , int buflen , int flags ) { pid_t pid ; int status ; int stdout_pipe [ 2 ] , stderr_pipe [ 2 ] ; struct sigaction sa_ignore , sa_intr , sa_quit ; sigset_t set_chldmask , set_save ; sa_ignore . sa_handler = SIG_IGN ; sigemptyset ( & sa_ignore . sa_mask ) ; sa_ignore . sa_flags = 0 ; if ( sigaction ( SIGINT , & sa_ignore , & sa_intr ) < 0 ) { return - 1 ; } if ( sigaction ( SIGQUIT , & sa_ignore , & sa_quit ) < 0 ) { return - 1 ; } sigemptyset ( & set_chldmask ) ; sigaddset ( & set_chldmask , SIGCHLD ) ; if ( sigprocmask ( SIG_BLOCK , & set_chldmask , & set_save ) < 0 ) { return - 1 ; } tls_prepare_provider_pipes ( stdout_pipe , stderr_pipe ) ; pid = fork ( ) ; if ( pid < 0 ) { int xerrno = errno ; pr_log_pri ( PR_LOG_ALERT , MOD_TLS_VERSION ": error: unable to fork: %s" , strerror ( xerrno ) ) ; errno = xerrno ; status = - 1 ; } if ( pid == 0 ) { char nbuf [ 32 ] ; pool * tmp_pool ; char * stdin_argv [ 4 ] ; session . pid = getpid ( ) ; tmp_pool = make_sub_pool ( s -> pool ) ; sigaction ( SIGINT , & sa_intr , NULL ) ; sigaction ( SIGQUIT , & sa_quit , NULL ) ; sigprocmask ( SIG_SETMASK , & set_save , NULL ) ; stdin_argv [ 0 ] = pstrdup ( tmp_pool , tls_passphrase_provider ) ; pr_snprintf ( nbuf , sizeof ( nbuf ) - 1 , "%u" , ( unsigned int ) s -> ServerPort ) ; nbuf [ sizeof ( nbuf ) - 1 ] = '\0' ; stdin_argv [ 1 ] = pstrcat ( tmp_pool , s -> ServerName , ":" , nbuf , NULL ) ; if ( flags & TLS_PASSPHRASE_FL_RSA_KEY ) { stdin_argv [ 2 ] = pstrdup ( tmp_pool , "RSA" ) ; } if ( flags & TLS_PASSPHRASE_FL_DSA_KEY ) { stdin_argv [ 2 ] = pstrdup ( tmp_pool , "DSA" ) ; } if ( flags & TLS_PASSPHRASE_FL_EC_KEY ) { stdin_argv [ 2 ] = pstrdup ( tmp_pool , "EC" ) ; } if ( flags & TLS_PASSPHRASE_FL_PKCS12_PASSWD ) { stdin_argv [ 2 ] = pstrdup ( tmp_pool , "PKCS12" ) ; } stdin_argv [ 3 ] = NULL ; PRIVS_ROOT pr_trace_msg ( trace_channel , 17 , "executing '%s' with uid %lu (euid %lu), gid %lu (egid %lu)" , tls_passphrase_provider , ( unsigned long ) getuid ( ) , ( unsigned long ) geteuid ( ) , ( unsigned long ) getgid ( ) , ( unsigned long ) getegid ( ) ) ; pr_log_debug ( DEBUG6 , MOD_TLS_VERSION ": executing '%s' with uid %lu (euid %lu), gid %lu (egid %lu)" , tls_passphrase_provider , ( unsigned long ) getuid ( ) , ( unsigned long ) geteuid ( ) , ( unsigned long ) getgid ( ) , ( unsigned long ) getegid ( ) ) ; tls_prepare_provider_fds ( stdout_pipe [ 1 ] , stderr_pipe [ 1 ] ) ; errno = 0 ; execv ( tls_passphrase_provider , stdin_argv ) ; exit ( errno ) ; } else { int res ; int maxfd , fds , send_sigterm = 1 ; fd_set readfds ; time_t start_time = time ( NULL ) ; struct timeval tv ; close ( stdout_pipe [ 1 ] ) ; close ( stderr_pipe [ 1 ] ) ; maxfd = ( stderr_pipe [ 0 ] > stdout_pipe [ 0 ] ) ?stderr_pipe [ 0 ] : stdout_pipe [ 0 ] ; res = waitpid ( pid , & status , WNOHANG ) ; while ( res <= 0 ) { if ( res < 0 ) { if ( errno != EINTR ) { pr_trace_msg ( trace_channel , 2 , "passphrase provider error: unable to wait for pid %u: %s" , ( unsigned int ) pid , strerror ( errno ) ) ; status = - 1 ; break ; } else { pr_signals_handle ( ) ; } } if ( ( time ( NULL ) - start_time ) > TLS_PASSPHRASE_TIMEOUT ) { if ( send_sigterm ) { send_sigterm = 0 ; pr_log_debug ( DEBUG6 , MOD_TLS_VERSION ": '%s' has exceeded the timeout (%lu seconds), sending " "SIGTERM (signal %d)" , tls_passphrase_provider , ( unsigned long ) TLS_PASSPHRASE_TIMEOUT , SIGTERM ) ; kill ( pid , SIGTERM ) ; } else { pr_log_debug ( DEBUG6 , MOD_TLS_VERSION ": '%s' has exceeded the timeout (%lu seconds), sending " "SIGKILL (signal %d)" , tls_passphrase_provider , ( unsigned long ) TLS_PASSPHRASE_TIMEOUT , SIGKILL ) ; kill ( pid , SIGKILL ) ; } } FD_ZERO ( & readfds ) ; FD_SET ( stdout_pipe [ 0 ] , & readfds ) ; FD_SET ( stderr_pipe [ 0 ] , & readfds ) ; tv . tv_sec = 2L ; tv . tv_usec = 0L ; fds = select ( maxfd + 1 , & readfds , NULL , NULL , & tv ) ; if ( fds == - 1 && errno == EINTR ) { pr_signals_handle ( ) ; } if ( fds > 0 ) { if ( FD_ISSET ( stdout_pipe [ 0 ] , & readfds ) ) { res = read ( stdout_pipe [ 0 ] , buf , buflen ) ; if ( res > 0 ) { buf [ buflen - 1 ] = '\0' ; while ( res && ( buf [ res - 1 ] == '\r' || buf [ res - 1 ] == '\n' ) ) { pr_signals_handle ( ) ; res -- ; } buf [ res ] = '\0' ; pr_trace_msg ( trace_channel , 18 , "read passphrase from '%s'" , tls_passphrase_provider ) ; } if ( res < 0 ) { int xerrno = errno ; pr_trace_msg ( trace_channel , 3 , "error reading stdout from '%s': %s" , tls_passphrase_provider , strerror ( xerrno ) ) ; pr_log_debug ( DEBUG2 , MOD_TLS_VERSION ": error reading stdout from '%s': %s" , tls_passphrase_provider , strerror ( xerrno ) ) ; } } if ( FD_ISSET ( stderr_pipe [ 0 ] , & readfds ) ) { long stderrlen , stderrsz ; char * stderrbuf ; pool * tmp_pool = make_sub_pool ( s -> pool ) ; stderrbuf = pr_fsio_getpipebuf ( tmp_pool , stderr_pipe [ 0 ] , & stderrsz ) ; memset ( stderrbuf , '\0' , stderrsz ) ; stderrlen = read ( stderr_pipe [ 0 ] , stderrbuf , stderrsz - 1 ) ; if ( stderrlen > 0 ) { while ( stderrlen && ( stderrbuf [ stderrlen - 1 ] == '\r' || stderrbuf [ stderrlen - 1 ] == '\n' ) ) { stderrlen -- ; } stderrbuf [ stderrlen ] = '\0' ; pr_trace_msg ( trace_channel , 5 , "stderr from '%s': %s" , tls_passphrase_provider , stderrbuf ) ; pr_log_debug ( DEBUG5 , MOD_TLS_VERSION ": stderr from '%s': %s" , tls_passphrase_provider , stderrbuf ) ; } if ( res < 0 ) { int xerrno = errno ; pr_trace_msg ( trace_channel , 2 , "error reading stderr from '%s': %s" , tls_passphrase_provider , strerror ( xerrno ) ) ; pr_log_debug ( DEBUG2 , MOD_TLS_VERSION ": error reading stderr from '%s': %s" , tls_passphrase_provider , strerror ( xerrno ) ) ; } destroy_pool ( tmp_pool ) ; tmp_pool = NULL ; } } res = waitpid ( pid , & status , WNOHANG ) ; } } if ( sigaction ( SIGINT , & sa_intr , NULL ) < 0 ) { return - 1 ; } if ( sigaction ( SIGQUIT , & sa_quit , NULL ) < 0 ) { return - 1 ; } if ( sigprocmask ( SIG_SETMASK , & set_save , NULL ) < 0 ) { return - 1 ; } if ( WIFSIGNALED ( status ) ) { pr_log_debug ( DEBUG2 , MOD_TLS_VERSION ": '%s' died from signal %d" , tls_passphrase_provider , WTERMSIG ( status ) ) ; errno = EPERM ; return - 1 ; } return 0 ; } 