void bcddate ( char * , char * ) char * lifname ( char * ) int cksum ( int , int * , int ) char * to_file ; int loadpoint , verbose ; u_long entry ; int main ( int argc , char * * argv ) { int to ; register int n , pos , c ; char buf [ LIF_FILESTART ] ; struct lifvol * lifv = ( lifvol * ) buf ; struct lifdir * lifd = ( lifdir * ) ( buf + LIF_DIRSTART ) ; while ( ( c = getopt ( argc , argv , "vl:" ) ) != - 1 ) { switch ( c ) { case 'v' : verbose ++ ; break ; case 'l' : sscanf ( optarg , "0x%x" , & loadpoint ) ; break ; default : usage ( ) ; } } if ( argc - optind < 2 ) { usage ( ) ; } if ( argc - optind > 8 ) { errx ( 1 , "too many boot programs (max 8 supported)" ) ; } to_file = argv [ -- argc ] ; if ( ( to = open ( to_file , O_RDWR | O_TRUNC | O_CREAT , 0644 ) ) < 0 ) { err ( 1 , "%s: open" , to_file ) ; } bzero ( buf , sizeof ( buf ) ) ; memset ( lifd [ 1 ] . dir_name , ' ' , sizeof lifd [ 1 ] . dir_name ) ; lifd [ 1 ] . dir_type = - 1 ; lifd [ 1 ] . dir_addr = 0 ; lifd [ 1 ] . dir_length = 0 ; lifd [ 1 ] . dir_flag = 0xFF ; lifd [ 1 ] . dir_implement = 0 ; lifd [ 7 ] = lifd [ 6 ] = lifd [ 5 ] = lifd [ 4 ] = lifd [ 3 ] = lifd [ 2 ] = lifd [ 1 ] ; lifv -> vol_id = htobe16 ( LIF_VOL_ID ) ; strncpy ( lifv -> vol_label , "BOOT44" , 6 ) ; lifv -> vol_addr = htobe32 ( btolifs ( LIF_DIRSTART ) ) ; lifv -> vol_oct = htobe16 ( LIF_VOL_OCT ) ; lifv -> vol_dirsize = htobe32 ( btolifs ( LIF_DIRSIZE ) ) ; lifv -> vol_version = htobe16 ( 1 ) ; lifv -> vol_lastvol = lifv -> vol_number = htobe16 ( 1 ) ; lifv -> vol_length = LIF_FILESTART ; bcddate ( to_file , lifv -> vol_toc ) ; lifv -> ipl_addr = htobe32 ( LIF_FILESTART ) ; lifv -> ipl_size = 0 ; lifv -> ipl_entry = 0 ; argv += optind ; argc -= optind ; optind = 0 ; for ( pos = LIF_FILESTART ; optind < argc ; optind ++ ) { lseek ( to , pos , 0 ) ; lifd [ optind ] . dir_addr = htobe32 ( btolifs ( pos ) ) ; n = btolifs ( putfile ( argv [ optind ] , to ) ) ; if ( lifv -> ipl_entry == 0 ) { lifv -> ipl_entry = htobe32 ( loadpoint + entry ) ; lifv -> ipl_size = htobe32 ( lifstob ( n ) ) ; lifd [ optind ] . dir_type = htobe16 ( LIF_DIR_ISL ) ; lifd [ optind ] . dir_implement = 0 ; } else { lifd [ optind ] . dir_type = htobe16 ( LIF_DIR_TYPE ) ; lifd [ 1 ] . dir_implement = htobe32 ( loadpoint + entry ) ; } strlcpy ( lifd [ optind ] . dir_name , lifname ( argv [ optind ] ) , sizeof lifd [ optind ] . dir_name ) ; lifd [ optind ] . dir_length = htobe32 ( n ) ; bcddate ( argv [ optind ] , lifd [ optind ] . dir_toc ) ; lifd [ optind ] . dir_flag = htobe16 ( LIF_DIR_FLAG ) ; lifv -> vol_length += n ; pos += lifstob ( n ) ; } lifv -> vol_length = htobe32 ( lifv -> vol_length ) ; lseek ( to , LIF_VOLSTART , 0 ) ; if ( write ( to , buf , sizeof ( buf ) ) != sizeof ( buf ) ) { err ( 1 , "%s: write LIF volume" , to_file ) ; } lseek ( to , 0 , SEEK_END ) ; return ( 0 ) ; } 