static int fuse_flush ( struct file * file , fl_owner_t id ) { struct inode * inode = file_inode ( file ) ; struct fuse_conn * fc = get_fuse_conn ( inode ) ; struct fuse_file * ff = file -> private_data ; struct fuse_req * req ; struct fuse_flush_in inarg ; int err ; if ( is_bad_inode ( inode ) ) { return - EIO ; } if ( fc -> no_flush ) { return 0 ; } err = write_inode_now ( inode , 1 ) ; if ( err ) { return err ; } inode_lock ( inode ) ; fuse_sync_writes ( inode ) ; inode_unlock ( inode ) ; err = filemap_check_errors ( file -> f_mapping ) ; if ( err ) { return err ; } req = fuse_get_req_nofail_nopages ( fc , file ) ; memset ( & inarg , 0 , sizeof ( inarg ) ) ; inarg . fh = ff -> fh ; inarg . lock_owner = fuse_lock_owner_id ( fc , id ) ; req -> in . h . opcode = FUSE_FLUSH ; req -> in . h . nodeid = get_node_id ( inode ) ; req -> in . numargs = 1 ; req -> in . args [ 0 ] . size = sizeof ( inarg ) ; req -> in . args [ 0 ] . value = & inarg ; __set_bit ( FR_FORCE , & req -> flags ) ; fuse_request_send ( fc , req ) ; err = req -> out . h . error ; fuse_put_request ( fc , req ) ; return err ; } 