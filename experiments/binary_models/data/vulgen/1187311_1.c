static long privcmd_ioctl_mmap ( struct file * file , void __user * udata ) { struct privcmd_data * data = file -> private_data ; struct privcmd_mmap mmapcmd ; struct mm_struct * mm = current -> mm ; struct vm_area_struct * vma ; int rc ; LIST_HEAD ( pagelist ) ; struct mmap_gfn_state state ; if ( copy_from_user ( & mmapcmd , udata , sizeof ( mmapcmd ) ) ) { return - EFAULT ; } if ( data -> domid != DOMID_INVALID && data -> domid != mmapcmd . dom ) { return - EPERM ; } rc = gather_array ( & pagelist , mmapcmd . num , sizeof ( privcmd_mmap_entry ) , mmapcmd . entry ) ; if ( rc || list_empty ( & pagelist ) ) { out } down_write ( & mm -> mmap_sem ) ; { struct page * page = list_first_entry ( & pagelist , page , lru ) ; struct privcmd_mmap_entry * msg = page_address ( page ) ; vma = find_vma ( mm , msg -> va ) ; rc = - EINVAL ; if ( ! vma || ( msg -> va != vma -> vm_start ) || vma -> vm_private_data ) { out_up } vma -> vm_private_data = PRIV_VMA_LOCKED ; } state . va = vma -> vm_start ; state . vma = vma ; state . domain = mmapcmd . dom ; rc = traverse_pages ( mmapcmd . num , sizeof ( privcmd_mmap_entry ) , & pagelist , mmap_gfn_range , & state ) ; out_up up_write ( & mm -> mmap_sem ) ; out free_page_list ( & pagelist ) ; return rc ; } 