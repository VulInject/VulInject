struct drm_gem_object * msm_gem_import ( struct drm_device * dev , struct dma_buf * dmabuf , struct sg_table * sgt ) { struct msm_drm_private * priv = dev -> dev_private ; struct msm_gem_object * msm_obj ; struct drm_gem_object * obj ; uint32_t size ; int ret , npages ; if ( ! msm_use_mmu ( dev ) ) { DRM_DEV_ERROR ( dev -> dev , "cannot import without IOMMU\n" ) ; return ERR_PTR ( - EINVAL ) ; } size = PAGE_ALIGN ( dmabuf -> size ) ; ret = msm_gem_new_impl ( dev , size , MSM_BO_WC , & obj ) ; if ( ret ) { return ERR_PTR ( ret ) ; } drm_gem_private_object_init ( dev , obj , size ) ; npages = size / PAGE_SIZE ; msm_obj = to_msm_bo ( obj ) ; msm_gem_lock ( obj ) ; msm_obj -> sgt = sgt ; msm_obj -> pages = kvmalloc_array ( npages , sizeof ( page * ) , GFP_KERNEL ) ; if ( ! msm_obj -> pages ) { msm_gem_unlock ( obj ) ; ret = - ENOMEM ; fail } ret = drm_prime_sg_to_page_array ( sgt , msm_obj -> pages , npages ) ; if ( ret ) { msm_gem_unlock ( obj ) ; fail } msm_gem_unlock ( obj ) ; drm_gem_lru_move_tail ( & priv -> lru . pinned , obj ) ; mutex_lock ( & priv -> obj_lock ) ; list_add_tail ( & msm_obj -> node , & priv -> objects ) ; return obj ; fail drm_gem_object_put ( obj ) ; return ERR_PTR ( ret ) ; } 