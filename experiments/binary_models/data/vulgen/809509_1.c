int v_resolve ( hfsvol * * vol , char * path , CatDataRec * data , long * parid , char * fname , node * np ) { long dirid ; char name [ HFS_MAX_FLEN + 1 ] , * nptr ; int found ; if ( * path == 0 ) { ERROR ( ENOENT , "empty path" ) ; return - 1 ; } if ( parid ) { * parid = 0 ; } nptr = strchr ( path , ':' ) ; if ( * path == ':' || nptr == 0 ) { dirid = ( * vol ) -> cwd ; if ( * path == ':' ) { ++ path ; } if ( * path == 0 ) { found = v_getdthread ( * vol , dirid , data , 0 ) ; if ( found <= 0 ) { return found ; } if ( parid ) { * parid = data -> u . dthd . thdParID ; } return v_catsearch ( * vol , data -> u . dthd . thdParID , data -> u . dthd . thdCName , data , fname , np ) ; } } else { hfsvol * check ; dirid = HFS_CNID_ROOTPAR ; if ( nptr - path > HFS_MAX_VLEN ) { return - 1 ; } strncpy ( name , path , nptr - path ) ; name [ nptr - path ] = 0 ; for ( check = hfs_mounts ; check ; check = check -> next ) { if ( d_relstring ( check -> mdb . drVN , name ) == 0 ) { * vol = check ; break ; } } } while ( 1 ) { while ( * path == ':' ) { ++ path ; found = v_getdthread ( * vol , dirid , data , 0 ) ; if ( found <= 0 ) { return found ; } dirid = data -> u . dthd . thdParID ; } if ( * path == 0 ) { found = v_getdthread ( * vol , dirid , data , 0 ) ; if ( found <= 0 ) { return found ; } if ( parid ) { * parid = data -> u . dthd . thdParID ; } return v_catsearch ( * vol , data -> u . dthd . thdParID , data -> u . dthd . thdCName , data , fname , np ) ; } nptr = name ; while ( nptr < name + sizeof ( name ) - 1 && * path && * path != ':' ) { * nptr ++ = * path ++ ; } if ( * path && * path != ':' ) { ERROR ( ENAMETOOLONG , 0 ) ; return - 1 ; } * nptr = 0 ; if ( * path == ':' ) { ++ path ; } if ( parid ) { * parid = dirid ; } found = v_catsearch ( * vol , dirid , name , data , fname , np ) ; if ( found < 0 ) { return - 1 ; } if ( found == 0 ) { if ( * path && parid ) { * parid = 0 ; } if ( * path == 0 && fname ) { strcpy ( fname , name ) ; } return 0 ; } switch ( data -> cdrType ) { case cdrDirRec : if ( * path == 0 ) { return 1 ; } dirid = data -> u . dir . dirDirID ; break ; case cdrFilRec : if ( * path == 0 ) { return 1 ; } ERROR ( ENOTDIR , "invalid pathname" ) ; return - 1 ; default : ERROR ( EIO , "unexpected catalog record" ) ; return - 1 ; } } } 