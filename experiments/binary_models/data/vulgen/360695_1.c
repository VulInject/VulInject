bool wg_noise_handshake_begin_session ( struct noise_handshake * handshake , struct noise_keypairs * keypairs ) { struct noise_keypair * new_keypair ; bool ret = false ; down_write ( & handshake -> lock ) ; new_keypair = keypair_create ( handshake -> entry . peer ) ; if ( ! new_keypair ) { out } new_keypair -> i_am_the_initiator = handshake -> state == HANDSHAKE_CONSUMED_RESPONSE ; new_keypair -> remote_index = handshake -> remote_index ; if ( new_keypair -> i_am_the_initiator ) { derive_keys ( & new_keypair -> sending , & new_keypair -> receiving , handshake -> chaining_key ) ; } else { derive_keys ( & new_keypair -> receiving , & new_keypair -> sending , handshake -> chaining_key ) ; } handshake_zero ( handshake ) ; rcu_read_lock_bh ( ) ; if ( likely ( ! READ_ONCE ( container_of ( handshake , wg_peer , handshake ) -> is_dead ) ) ) { add_new_keypair ( keypairs , new_keypair ) ; net_dbg_ratelimited ( "%s: Keypair %llu created for peer %llu\n" , handshake -> entry . peer -> device -> dev -> name , new_keypair -> internal_id , handshake -> entry . peer -> internal_id ) ; ret = wg_index_hashtable_replace ( handshake -> entry . peer -> device -> index_hashtable , & handshake -> entry , & new_keypair -> entry ) ; } else { kfree_sensitive ( new_keypair ) ; } rcu_read_unlock_bh ( ) ; out up_write ( & handshake -> lock ) ; return ret ; } 