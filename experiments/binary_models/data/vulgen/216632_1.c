static void digicolor_uart_set_termios ( struct uart_port * port , struct ktermios * termios , const struct ktermios * old ) { unsigned int baud , divisor ; u8 config ; unsigned long flags ; termios -> c_cflag &= ~ CMSPAR ; termios -> c_iflag &= ~ ( BRKINT | IGNBRK ) ; baud = uart_get_baud_rate ( port , termios , old , port -> uartclk / ( 0x10000 * 16 ) , port -> uartclk / 256 ) ; divisor = uart_get_divisor ( port , baud ) - 1 ; switch ( termios -> c_cflag & CSIZE ) { case CS7 : break ; case CS8 : default : config |= UA_CONFIG_CHAR_LEN ; termios -> c_cflag &= ~ CSIZE ; termios -> c_cflag |= CS8 ; break ; } if ( termios -> c_cflag & CSTOPB ) { config |= UA_CONFIG_STOP_BITS ; } if ( termios -> c_cflag & PARENB ) { config |= UA_CONFIG_PARITY ; if ( termios -> c_cflag & PARODD ) { config |= UA_CONFIG_ODD_PARITY ; } } port -> read_status_mask = UA_STATUS_OVERRUN_ERR ; if ( termios -> c_iflag & INPCK ) { port -> read_status_mask |= UA_STATUS_PARITY_ERR | UA_STATUS_FRAME_ERR ; } port -> ignore_status_mask = 0 ; if ( ! ( termios -> c_cflag & CREAD ) ) { port -> ignore_status_mask |= UA_STATUS_OVERRUN_ERR | UA_STATUS_PARITY_ERR | UA_STATUS_FRAME_ERR ; } spin_lock_irqsave ( & port -> lock , flags ) ; uart_update_timeout ( port , termios -> c_cflag , baud ) ; writeb_relaxed ( config , port -> membase + UA_CONFIG ) ; writeb_relaxed ( divisor & 0xff , port -> membase + UA_HBAUD_LO ) ; writeb_relaxed ( divisor >> 8 , port -> membase + UA_HBAUD_HI ) ; spin_unlock_irqrestore ( & port -> lock , flags ) ; } 