static void fallbackdaemon ( void ) { int fd , sysmfd , ret = 0 ; char * * devpaths ; pollfd_t * fds ; nfds_t nfds = 0 ; int index ; int pollagain ; struct sigaction sa ; int bufsize = 0 ; int cachesize = 0 ; char * infop , * ptr , * p ; sa . sa_handler = catch_term ; sa . sa_flags = 0 ; ( void ) sigemptyset ( & sa . sa_mask ) ; ( void ) sigaction ( SIGTERM , & sa , NULL ) ; sa . sa_handler = catch_hup ; sa . sa_flags = 0 ; ( void ) sigemptyset ( & sa . sa_mask ) ; ( void ) sigaction ( SIGHUP , & sa , NULL ) ; if ( ( sysmfd = safeopen ( SYSMSG ) ) < 0 ) { die ( gettext ( "%s is missing or not a valid device\n" ) , SYSMSG ) ; } if ( ( bufsize = ioctl ( sysmfd , CIOCGETCONSOLE , NULL ) ) < 0 ) { die ( gettext ( "cannot get table entry\n" ) ) ; } if ( bufsize == 0 ) { return ; } if ( ( infop = calloc ( bufsize , sizeof ( char ) ) ) == NULL ) { die ( gettext ( "cannot allocate buffer" ) ) ; } if ( ioctl ( sysmfd , CIOCGETCONSOLE , infop ) < 0 ) { die ( gettext ( "cannot get table entry\n" ) ) ; } ptr = infop ; while ( ptr != NULL ) { p = strchr ( ptr , ' ' ) ; if ( p == NULL ) { cachesize ++ ; break ; } p ++ ; cachesize ++ ; ptr = p ; } if ( ( fds = calloc ( cachesize , sizeof ( pollfd ) ) ) == NULL ) { die ( gettext ( "cannot allocate buffer" ) ) ; } if ( ( devpaths = calloc ( cachesize , sizeof ( char * ) ) ) == NULL ) { die ( gettext ( "cannot allocate buffer" ) ) ; } ptr = infop ; while ( ptr != NULL ) { p = strchr ( ptr , ' ' ) ; if ( p == NULL ) { if ( ( fd = safeopen ( ptr ) ) < 0 ) { warn ( gettext ( "cannot open %s, continuing" ) , ptr ) ; break ; } if ( ! has_carrier ( fd ) ) { ( void ) close ( fd ) ; warn ( gettext ( "no carrier on %s, device will not be monitored.\n" ) , ptr ) ; break ; } else { fds [ nfds ] . fd = fd ; fds [ nfds ] . events = 0 ; if ( ( devpaths [ nfds ] = malloc ( strlen ( ptr ) + 1 ) ) == NULL ) { die ( gettext ( "cannot allocate buffer" ) ) ; } ( void ) strcpy ( devpaths [ nfds ] , ptr ) ; nfds ++ ; if ( nfds >= cachesize ) { break ; } } break ; } * p ++ = '\0' ; if ( ( fd = safeopen ( ptr ) ) < 0 ) { warn ( gettext ( "cannot open %s, continuing" ) , ptr ) ; ptr = p ; continue ; } if ( ! has_carrier ( fd ) ) { ( void ) close ( fd ) ; warn ( gettext ( "no carrier on %s, device will not be monitored.\n" ) , ptr ) ; ptr = p ; continue ; } else { fds [ nfds ] . fd = fd ; fds [ nfds ] . events = 0 ; if ( ( devpaths [ nfds ] = malloc ( strlen ( ptr ) + 1 ) ) == NULL ) { die ( gettext ( "cannot allocate buffer" ) ) ; } ( void ) strcpy ( devpaths [ nfds ] , ptr ) ; nfds ++ ; if ( nfds >= cachesize ) { break ; } } ptr = p ; } ( void ) close ( sysmfd ) ; if ( nfds == 0 ) { return ; } for ( ; ; ) { ret = poll ( fds , nfds , INFTIM ) ; if ( ret == - 1 ) { warn ( gettext ( "cannot poll device" ) ) ; return ; } if ( ret == 0 ) { warn ( gettext ( "timeout (%d milleseconds) occured\n" ) , INFTIM ) ; return ; } else { for ( index = 0 ; index < nfds ; index ++ ) { if ( ( fds [ index ] . revents & POLLHUP ) == POLLHUP ) { unsetaux ( ( char * ) devpaths [ index ] ) ; warn ( gettext ( "lost carrier, unsetting console %s\n" ) , devpaths [ index ] ) ; syslog ( LOG_WARNING , "%s: lost carrier, unsetting auxiliary device %s" , CONSADM , devpaths [ index ] ) ; free ( devpaths [ index ] ) ; devpaths [ index ] = NULL ; ( void ) close ( fds [ index ] . fd ) ; fds [ index ] . fd = - 1 ; fds [ index ] . revents = 0 ; continue ; } if ( ( fds [ index ] . revents & POLLERR ) == POLLERR ) { warn ( gettext ( "poll error\n" ) ) ; continue ; } if ( fds [ index ] . revents != 0 ) { warn ( gettext ( "unexpected poll result 0x%x\n" ) , fds [ index ] . revents ) ; continue ; } } pollagain = B_FALSE ; for ( index = 0 ; index < nfds ; index ++ ) { if ( fds [ index ] . fd != - 1 ) { pollagain = B_TRUE ; } } if ( pollagain == B_TRUE ) { continue ; } else { return ; } } } } 