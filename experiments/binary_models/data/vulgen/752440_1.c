static int yy_did_buffer_switch_on_eof ; void ncsa_restart ( FILE * input_file ) void ncsa__switch_to_buffer ( YY_BUFFER_STATE new_buffer ) YY_BUFFER_STATE ncsa__create_buffer ( FILE * file , int size ) void ncsa__delete_buffer ( YY_BUFFER_STATE b ) void ncsa__flush_buffer ( YY_BUFFER_STATE b ) void ncsa_push_buffer_state ( YY_BUFFER_STATE new_buffer ) void ncsa_pop_buffer_state ( void ) static void ncsa_ensure_buffer_stack ( void ) static void ncsa__load_buffer_state ( void ) static void ncsa__init_buffer ( YY_BUFFER_STATE b , FILE * file ) YY_BUFFER_STATE ncsa__scan_buffer ( char * base , yy_size_t size ) YY_BUFFER_STATE ncsa__scan_string ( yyconst char * yy_str ) YY_BUFFER_STATE ncsa__scan_bytes ( yyconst char * bytes , yy_size_t len ) void * ncsa_alloc ( yy_size_t ) void * ncsa_realloc ( void * , yy_size_t ) void ncsa_free ( void * ) { if ( ! YY_CURRENT_BUFFER ) { ncsa_ensure_buffer_stack ( ) ; YY_CURRENT_BUFFER_LVALUE = ncsa__create_buffer ( ncsa_in , YY_BUF_SIZE ) ; } YY_CURRENT_BUFFER_LVALUE -> yy_is_interactive = is_interactive ; } { if ( ! YY_CURRENT_BUFFER ) { ncsa_ensure_buffer_stack ( ) ; YY_CURRENT_BUFFER_LVALUE = ncsa__create_buffer ( ncsa_in , YY_BUF_SIZE ) ; } YY_CURRENT_BUFFER_LVALUE -> yy_at_bol = at_bol ; } unsigned char YY_CHAR FILE * ncsa_in = ( FILE * ) 0 , * ncsa_out = ( FILE * ) 0 ; int yy_state_type extern int ncsa_lineno ; int ncsa_lineno = 1 ; extern char * ncsa_text ; static yy_state_type yy_get_previous_state ( void ) static yy_state_type yy_try_NUL_trans ( yy_state_type current_state ) static int yy_get_next_buffer ( void ) static void yy_fatal_error ( yyconst char msg [ ] ) ( yytext_ptr ) = yy_bp ; ncsa_leng = ( size_t ) ( yy_cp - yy_bp ) ; ( yy_hold_char ) = * yy_cp ; * yy_cp = '\0' ; ( yy_c_buf_p ) = yy_cp ; yy_trans_info { flex_int32_t yy_verify ; flex_int32_t yy_nxt ; } static yyconst flex_int16_t yy_accept [ 76 ] { 0 11 11 0 0 5 5 15 13 12 12 4 11 11 11 13 13 11 13 13 10 14 5 12 0 11 11 11 11 0 0 11 11 0 0 10 5 0 0 0 0 0 0 0 0 0 0 0 0 8 6 0 0 0 0 0 0 0 0 7 0 0 0 0 9 0 0 2 1 0 0 0 0 0 3 0 } ; ; static yyconst flex_int32_t yy_ec [ 256 ] { 0 1 1 1 1 1 1 1 1 2 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 4 5 1 1 1 1 1 1 6 7 8 9 1 10 10 10 10 10 10 10 10 10 10 11 1 1 1 1 1 1 12 1 13 14 15 16 1 17 18 1 1 19 1 20 21 22 1 23 24 25 26 1 1 1 27 1 1 1 1 1 1 1 28 1 29 30 31 32 1 33 34 1 1 35 1 36 37 38 1 39 40 41 42 1 1 1 43 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 } ; ; static yyconst flex_int32_t yy_meta [ 44 ] { 0 1 2 3 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 } ; ; static yyconst flex_int16_t yy_base [ 81 ] { 0 0 38 4 14 62 61 58 178 16 22 49 18 35 47 2 28 64 34 48 0 178 0 32 61 70 72 82 83 60 68 34 27 75 82 0 0 70 82 86 92 94 80 83 84 91 91 98 92 178 178 102 113 108 113 110 109 113 122 178 113 116 122 21 178 15 119 178 178 122 130 128 130 1 178 178 166 169 172 0 175 } ; ; static yyconst flex_int16_t yy_def [ 81 ] { 0 76 76 77 77 78 78 75 75 75 75 75 75 75 75 75 75 75 75 75 79 75 80 75 75 75 75 75 75 75 75 75 75 75 75 79 80 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 0 75 75 75 75 75 } ; ; static yyconst flex_int16_t yy_nxt [ 222 ] { 0 35 9 10 11 75 21 21 12 13 14 21 74 15 16 17 21 21 23 23 29 21 18 19 23 23 68 25 26 15 16 17 67 27 23 23 29 32 18 19 9 10 11 30 32 28 12 13 14 27 27 15 16 17 24 33 25 26 75 30 18 19 27 34 21 21 27 15 16 17 31 33 31 37 32 38 18 19 27 34 28 25 26 40 41 27 39 27 31 37 31 38 32 28 42 43 44 45 27 40 41 27 39 27 46 47 48 49 50 51 42 43 44 45 27 52 53 54 55 56 46 47 48 49 50 51 57 58 59 60 61 52 53 54 55 56 62 63 64 65 66 69 57 58 59 60 61 70 71 72 73 75 62 63 64 65 66 69 75 75 75 75 75 70 71 72 73 8 8 8 20 20 20 22 22 22 36 36 7 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 } ; ; static yyconst flex_int16_t yy_chk [ 222 ] { 0 79 1 1 1 0 3 3 1 1 1 3 73 1 1 1 4 4 9 9 15 4 1 1 10 10 65 12 12 1 1 1 63 12 23 23 15 32 1 1 2 2 2 16 31 13 2 2 2 12 13 2 2 2 11 18 14 14 7 16 2 2 14 19 6 5 13 2 2 2 17 18 17 24 17 24 2 2 14 19 25 26 26 29 30 25 24 26 27 24 27 24 27 28 33 34 37 38 28 29 30 25 24 26 39 40 41 42 43 44 33 34 37 38 28 45 46 47 48 51 39 40 41 42 43 44 52 53 54 55 56 45 46 47 48 51 57 58 60 61 62 66 52 53 54 55 56 69 70 71 72 0 57 58 60 61 62 66 0 0 0 0 0 69 70 71 72 76 76 76 77 77 77 78 78 78 80 80 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 } ; ; static yy_state_type yy_last_accepting_state ; static char * yy_last_accepting_cpos ; extern int ncsa__flex_debug ; int ncsa__flex_debug = 0 ; char * ncsa_text ; static int yy_init_globals ( void ) int ncsa_lex_destroy ( void ) int ncsa_get_debug ( void ) void ncsa_set_debug ( int debug_flag ) YY_EXTRA_TYPE ncsa_get_extra ( void ) void ncsa_set_extra ( YY_EXTRA_TYPE user_defined ) FILE * ncsa_get_in ( void ) void ncsa_set_in ( FILE * in_str ) FILE * ncsa_get_out ( void ) void ncsa_set_out ( FILE * out_str ) yy_size_t ncsa_get_leng ( void ) char * ncsa_get_text ( void ) int ncsa_get_lineno ( void ) void ncsa_set_lineno ( int line_number ) "C" int ncsa_wrap ( void ) extern int ncsa_wrap ( void ) static void yy_flex_strncpy ( char * , yyconst char * , int ) static int yy_flex_strlen ( yyconst char * ) static int yyinput ( void ) static int input ( void ) if ( YY_CURRENT_BUFFER_LVALUE -> yy_is_interactive ) { int c = '*' ; size_t n ; for ( n = 0 ; n < max_size && ( c = getc ( ncsa_in ) ) != EOF && c != '\n' ; ++ n ) { buf [ n ] = ( char ) c ; } if ( c == '\n' ) { buf [ n ++ ] = ( char ) c ; } if ( c == EOF && ferror ( ncsa_in ) ) { YY_FATAL_ERROR ( "input in flex scanner failed" ) ; } result = n ; } else { errno = 0 ; while ( ( result = fread ( buf , 1 , max_size , ncsa_in ) ) == 0 && ferror ( ncsa_in ) ) { if ( errno != EINTR ) { YY_FATAL_ERROR ( "input in flex scanner failed" ) ; break ; } errno = 0 ; clearerr ( ncsa_in ) ; } } extern int ncsa_lex ( void ) YY_USER_ACTION YY_DECL ( register yy_state_type yy_current_state , register char * yy_cp , * yy_bp , register int yy_act , ( ! ( yy_init ) ) { ( yy_init ) = 1 YY_USER_INIT if ( ! ( yy_start ) ) { ( yy_start ) = 1 ; } } if ( ! ncsa_in ) { ncsa_in = stdin ; } ) ; if ( ! ncsa_out ) { ncsa_out = stdout ; } if ( ! YY_CURRENT_BUFFER ) { ncsa_ensure_buffer_stack ( ) ; YY_CURRENT_BUFFER_LVALUE = ncsa__create_buffer ( ncsa_in , YY_BUF_SIZE ) ; } ncsa__load_buffer_state ( ) ; ( 1 ) { yy_cp = ( yy_c_buf_p ) * yy_cp = ( yy_hold_char ) yy_bp = yy_cp yy_current_state = ( yy_start ) yy_match : { register YY_CHAR yy_c = yy_ec [ YY_SC_TO_UI ( * yy_cp ) ] ; if ( yy_accept [ yy_current_state ] ) { ( yy_last_accepting_state ) = yy_current_state ; ( yy_last_accepting_cpos ) = yy_cp ; ; } } } ; while ( yy_chk [ yy_base [ yy_current_state ] + yy_c ] != yy_current_state ) { yy_current_state = ( int ) yy_def [ yy_current_state ] ; if ( yy_current_state >= 76 ) { yy_c = yy_meta [ ( unsigned int ) yy_c ] ; } } yy_current_state = yy_nxt [ yy_base [ yy_current_state ] + ( unsigned int ) yy_c ] ; ++ yy_cp ; ( yy_base [ yy_current_state ] != 178 ) ; yy_find_action yy_act = yy_accept [ yy_current_state ] ; if ( yy_act == 0 ) { yy_cp = ( yy_last_accepting_cpos ) ; yy_current_state = ( yy_last_accepting_state ) ; yy_act = yy_accept [ yy_current_state ] ; } YY_DO_BEFORE_ACTION ; do_action switch ( yy_act ) { case 0 : * yy_cp = ( yy_hold_char ) ; yy_cp = ( yy_last_accepting_cpos ) ; yy_current_state = ( yy_last_accepting_state ) ; yy_find_action case 1 : YY_RULE_SETUP { BEGIN ( comment ) ; return AUTHOR ; } YY_BREAK case 2 : YY_RULE_SETUP { BEGIN ( comment ) ; return TITLE ; } YY_BREAK case 3 : YY_RULE_SETUP { BEGIN ( comment ) ; return DESCRIPTION ; } YY_BREAK case 4 : YY_RULE_SETUP { BEGIN ( comment ) ; return BEGIN_COMMENT ; } YY_BREAK case 5 : YY_RULE_SETUP { BEGIN ( INITIAL ) ; ncsa_lval . id = g_strndup ( ncsa_text , ncsa_leng ) ; return COMMENT ; } YY_BREAK case 6 : YY_RULE_SETUP { BEGIN ( imap_link ) ; return RECTANGLE ; } YY_BREAK case 7 : YY_RULE_SETUP { BEGIN ( imap_link ) ; return CIRCLE ; } YY_BREAK case 8 : YY_RULE_SETUP { BEGIN ( imap_link ) ; return POLYGON ; } YY_BREAK case 9 : YY_RULE_SETUP { BEGIN ( imap_link ) ; return DEFAULT ; } YY_BREAK case 10 : YY_RULE_SETUP { BEGIN ( INITIAL ) ; ncsa_lval . id = g_strndup ( ncsa_text , ncsa_leng ) ; return LINK ; } YY_BREAK case 11 : YY_RULE_SETUP { ncsa_lval . value = g_ascii_strtod ( ncsa_text , NULL ) ; return FLOAT ; } YY_BREAK case 12 : YY_RULE_SETUP ; YY_BREAK case 13 : YY_RULE_SETUP return * ncsa_text ; YY_BREAK case 14 : YY_RULE_SETUP ECHO ; YY_BREAK case YY_STATE_EOF ( INITIAL ) : case YY_STATE_EOF ( imap_link ) : case YY_STATE_EOF ( comment ) : yyterminate ( ) ; case YY_END_OF_BUFFER : { int yy_amount_of_matched_text = ( int ) ( yy_cp - ( yytext_ptr ) ) - 1 ; * yy_cp = ( yy_hold_char ) ; YY_RESTORE_YY_MORE_OFFSET if ( ( yy_c_buf_p ) <= & YY_CURRENT_BUFFER_LVALUE -> yy_ch_buf [ ( yy_n_chars ) ] ) { yy_state_type yy_next_state ; ( yy_c_buf_p ) = ( yytext_ptr ) + yy_amount_of_matched_text ; yy_current_state = yy_get_previous_state ( ) ; yy_next_state = yy_try_NUL_trans ( yy_current_state ) ; yy_bp = ( yytext_ptr ) + YY_MORE_ADJ ; if ( yy_next_state ) { yy_cp = ++ ( yy_c_buf_p ) ; yy_current_state = yy_next_state ; yy_match } else { yy_cp = ( yy_c_buf_p ) ; yy_find_action } } else { switch ( yy_get_next_buffer ( ) ) { case EOB_ACT_END_OF_FILE : { ( yy_did_buffer_switch_on_eof ) = 0 ; if ( ncsa_wrap ( ) ) { ( yy_c_buf_p ) = ( yytext_ptr ) + YY_MORE_ADJ ; yy_act = YY_STATE_EOF ( YY_START ) ; do_action } else { if ( ! ( yy_did_buffer_switch_on_eof ) ) { YY_NEW_FILE ; } } break ; } case EOB_ACT_CONTINUE_SCAN : ( yy_c_buf_p ) = ( yytext_ptr ) + yy_amount_of_matched_text ; yy_current_state = yy_get_previous_state ( ) ; yy_cp = ( yy_c_buf_p ) ; yy_bp = ( yytext_ptr ) + YY_MORE_ADJ ; yy_match case EOB_ACT_LAST_MATCH : ( yy_c_buf_p ) = & YY_CURRENT_BUFFER_LVALUE -> yy_ch_buf [ ( yy_n_chars ) ] ; yy_current_state = yy_get_previous_state ( ) ; yy_cp = ( yy_c_buf_p ) ; yy_bp = ( yytext_ptr ) + YY_MORE_ADJ ; yy_find_action } } break ; } default : YY_FATAL_ERROR ( "fatal flex scanner internal error--no action found" ) ; } 