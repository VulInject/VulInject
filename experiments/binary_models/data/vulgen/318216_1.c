switch ( type ) { case opt_stringptr : case opt_uid : case opt_gid : case opt_expand_uid : case opt_expand_gid : case opt_uidlist : case opt_gidlist : case opt_rewrite : reset_point = store_mark ( ) ; sptr = read_string ( s , name ) ; switch ( type ) { case opt_stringptr : str_target = data_block ?USS ( ) : USS ol -> v . value ; if ( ol -> type & opt_rep_con ) { uschar * saved_condition ; * str_target = string_copy_perm ( ( saved_condition = * str_target ) ?string_sprintf ( "${if and{{bool_lax{%s}}{bool_lax{%s}}}}" , saved_condition , sptr ) : sptr , FALSE ) ; } if ( ol -> type & opt_rep_str ) { uschar sep_o = Ustrncmp ( name , "headers_add" , 11 ) == 0 ?'\n' : Ustrncmp ( name , "set" , 3 ) == 0 ?';' : ':' ; int sep_i = - ( int ) sep_o ; const uschar * list = sptr ; uschar * s ; gstring * list_o = NULL ; if ( * str_target ) { list_o = string_get ( Ustrlen ( * str_target ) + Ustrlen ( sptr ) ) ; list_o = string_cat ( list_o , * str_target ) ; } while ( ( s = string_nextinlist ( & list , & sep_i , NULL , 0 ) ) ) { list_o = string_append_listele ( list_o , sep_o , s ) ; } } else { * str_target = sptr ; freesptr = FALSE ; } break ; case opt_rewrite : if ( data_block ) { * USS ( ) = sptr ; } else { * USS ol -> v . value = sptr ; } freesptr = FALSE ; if ( type == opt_rewrite ) { int sep = 0 ; int * flagptr ; uschar * p = sptr ; rewrite_rule * * chain ; optionlist * ol3 ; sprintf ( , "*%.50s_rules" , ) ol2 = find_option ( name2 , oltop , last ) ; sprintf ( , "*%.50s_flags" , ) ol3 = find_option ( name2 , oltop , last ) ; if ( ! ol2 || ! ol3 ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "rewrite rules not available for driver" ) ; } if ( data_block ) { chain = ( rewrite_rule * * ) ( US data_block + ol2 -> v . offset ) ; flagptr = ( int * ) ( US data_block + ol3 -> v . offset ) ; } else { chain = ( rewrite_rule * * ) ol2 -> v . value ; flagptr = ( int * ) ol3 -> v . value ; } while ( ( p = string_nextinlist ( CUSS & sptr , & sep , big_buffer , BIG_BUFFER_SIZE ) ) ) { rewrite_rule * next = readconf_one_rewrite ( p , flagptr , FALSE ) ; * chain = next ; chain = & ( next -> next ) ; } if ( ( * flagptr & ( rewrite_all_envelope | rewrite_smtp ) ) != 0 ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "rewrite rule specifies a " "non-header rewrite - not allowed at transport time -" ) ; } } break ; case opt_expand_uid : sprintf ( , "*expand_%.50s" , ) if ( ( ol2 = find_option ( name2 , oltop , last ) ) ) { uschar * ss = ( Ustrchr ( sptr , '$' ) != NULL ) ?sptr : NULL ; if ( data_block ) { * ( USS ( ) ) = ss ; } else { * ( USS ol2 -> v . value ) = ss ; } if ( ss ) { * ( get_set_flag ( name , oltop , last , data_block ) ) = FALSE ; freesptr = FALSE ; break ; } } case opt_uid : if ( ! route_finduser ( sptr , & pw , & uid ) ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "user %s was not found" , sptr ) ; } if ( data_block ) { * ( uid_t * ) ( US data_block + ol -> v . offset ) = uid ; } else { * ( uid_t * ) ol -> v . value = uid ; } * ( get_set_flag ( name , oltop , last , data_block ) ) = TRUE ; if ( pw == NULL ) { break ; } Ustrcpy ( name + Ustrlen ( name ) - 4 , US "group" ) ; ol2 = find_option ( name , oltop , last ) ; if ( ol2 && ( ( ol2 -> type & opt_mask ) == opt_gid || ( ol2 -> type & opt_mask ) == opt_expand_gid ) ) { BOOL * set_flag = get_set_flag ( name , oltop , last , data_block ) ; if ( ! * set_flag ) { if ( data_block ) { * ( ( gid_t * ) ( US data_block + ol2 -> v . offset ) ) = pw -> pw_gid ; } else { * ( ( gid_t * ) ol2 -> v . value ) = pw -> pw_gid ; } * set_flag = TRUE ; } } break ; case opt_expand_gid : sprintf ( , "*expand_%.50s" , ) if ( ( ol2 = find_option ( name2 , oltop , last ) ) ) { uschar * ss = ( Ustrchr ( sptr , '$' ) != NULL ) ?sptr : NULL ; if ( data_block ) { * ( USS ( ) ) = ss ; } else { * ( USS ol2 -> v . value ) = ss ; } if ( ss ) { * ( get_set_flag ( name , oltop , last , data_block ) ) = FALSE ; freesptr = FALSE ; break ; } } case opt_gid : if ( ! route_findgroup ( sptr , & gid ) ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "group %s was not found" , sptr ) ; } if ( data_block ) { * ( ( gid_t * ) ( US data_block + ol -> v . offset ) ) = gid ; } else { * ( ( gid_t * ) ol -> v . value ) = gid ; } * ( get_set_flag ( name , oltop , last , data_block ) ) = TRUE ; break ; case opt_uidlist : { int count = 1 ; uid_t * list ; int ptr = 0 ; const uschar * p ; const uschar * op = expand_string ( sptr ) ; if ( op == NULL ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "failed to expand %s: %s" , name , expand_string_message ) ; } p = op ; if ( * p != 0 ) { count ++ ; } while ( * p != 0 ) { if ( * p ++ == ':' && * p != 0 ) { count ++ ; } } list = store_malloc ( count * sizeof ( uid_t ) ) ; list [ ptr ++ ] = ( uid_t ) ( count - 1 ) ; if ( data_block ) { * ( ( uid_t * * ) ( US data_block + ol -> v . offset ) ) = list ; } else { * ( ( uid_t * * ) ol -> v . value ) = list ; } p = op ; while ( count -- > 1 ) { int sep = 0 ; ( void ) string_nextinlist ( & p , & sep , big_buffer , BIG_BUFFER_SIZE ) ; if ( ! route_finduser ( big_buffer , NULL , & uid ) ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "user %s was not found" , big_buffer ) ; } list [ ptr ++ ] = uid ; } break ; } case opt_gidlist : { int count = 1 ; gid_t * list ; int ptr = 0 ; const uschar * p ; const uschar * op = expand_string ( sptr ) ; if ( ! op ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "failed to expand %s: %s" , name , expand_string_message ) ; } p = op ; if ( * p != 0 ) { count ++ ; } while ( * p != 0 ) { if ( * p ++ == ':' && * p != 0 ) { count ++ ; } } list = store_malloc ( count * sizeof ( gid_t ) ) ; list [ ptr ++ ] = ( gid_t ) ( count - 1 ) ; if ( data_block ) { * ( ( gid_t * * ) ( US data_block + ol -> v . offset ) ) = list ; } else { * ( ( gid_t * * ) ol -> v . value ) = list ; } p = op ; while ( count -- > 1 ) { int sep = 0 ; ( void ) string_nextinlist ( & p , & sep , big_buffer , BIG_BUFFER_SIZE ) ; if ( ! route_findgroup ( big_buffer , & gid ) ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "group %s was not found" , big_buffer ) ; } list [ ptr ++ ] = gid ; } break ; } } if ( freesptr ) { reset_point = store_reset ( reset_point ) ; } break ; case opt_expand_bool : if ( * s && Ustrchr ( s , '$' ) != 0 ) { sprintf ( , "*expand_%.50s" , ) if ( ( ol2 = find_option ( name2 , oltop , last ) ) ) { reset_point = store_mark ( ) ; sptr = read_string ( s , name ) ; if ( data_block ) { * ( USS ( ) ) = sptr ; } else { * ( USS ol2 -> v . value ) = sptr ; } freesptr = FALSE ; break ; } } case opt_bool : case opt_bit : case opt_bool_verify : case opt_bool_set : if ( * s ) { s = readconf_readname ( name2 , EXIM_DRIVERNAME_MAX , s ) ; if ( strcmpic ( name2 , US "true" ) == 0 || strcmpic ( name2 , US "yes" ) == 0 ) { boolvalue = TRUE ; } if ( strcmpic ( name2 , US "false" ) == 0 || strcmpic ( name2 , US "no" ) == 0 ) { boolvalue = FALSE ; } else { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "\"%s\" is not a valid value for the \"%s\" option" , name2 , name ) ; } if ( * s != 0 ) { extra_chars_error ( s , string_sprintf ( "\"%s\" " , name2 ) , US "for boolean option " , name ) ; } } if ( type == opt_bit ) { int bit = 1 << ( ( ol -> type >> 16 ) & 31 ) ; int * ptr = data_block ?( int * ) ( US data_block + ol -> v . offset ) : ( int * ) ol -> v . value ; if ( boolvalue ) { * ptr |= bit ; } else { * ptr &= ~ bit ; } break ; } if ( data_block ) { * ( ( BOOL * ) ( US data_block + ol -> v . offset ) ) = boolvalue ; } else { * ( ( BOOL * ) ol -> v . value ) = boolvalue ; } if ( type == opt_bool_verify ) { sprintf ( , "%.50s_recipient" , ) if ( ( ol2 = find_option ( name2 , oltop , last ) ) ) { if ( data_block ) { * ( ( BOOL * ) ( US data_block + ol2 -> v . offset ) ) = boolvalue ; } else { * ( ( BOOL * ) ol2 -> v . value ) = boolvalue ; } } } if ( type == opt_bool_set ) { sprintf ( , "*set_%.50s" , ) if ( ( ol2 = find_option ( name2 , oltop , last ) ) ) { if ( data_block ) { * ( ( BOOL * ) ( US data_block + ol2 -> v . offset ) ) = TRUE ; } else { * ( ( BOOL * ) ol2 -> v . value ) = TRUE ; } } } break ; case opt_octint : intbase = 8 ; inttype = US "octal " ; case opt_mkint : case opt_int : { uschar * endptr ; long int lvalue ; errno = 0 ; lvalue = strtol ( , , ) ; if ( endptr == s ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "%sinteger expected for %s" , inttype , name ) ; } if ( errno != ERANGE && * endptr ) { uschar * mp = US "TtGgMmKk\0" ; if ( ( mp = Ustrchr ( mp , * endptr ) ) ) { endptr ++ ; { if ( lvalue > INT_MAX / 1024 || lvalue < INT_MIN / 1024 ) { errno = ERANGE ; break ; } lvalue *= 1024 ; } * ( mp += 2 ) ; } } if ( errno == ERANGE || lvalue > INT_MAX || lvalue < INT_MIN ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "absolute value of integer \"%s\" is too large (overflow)" , s ) ; } while ( isspace ( * endptr ) ) { endptr ++ ; } if ( * endptr ) { extra_chars_error ( endptr , inttype , US "integer value for " , name ) ; } value = ( int ) lvalue ; } if ( data_block ) { * ( int * ) ( US data_block + ol -> v . offset ) = value ; } else { * ( int * ) ol -> v . value = value ; } break ; case opt_Kint : { uschar * endptr ; errno = 0 ; int_eximarith_t lvalue = strtol ( , , ) ; if ( endptr == s ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "%sinteger expected for %s" , inttype , name ) ; } if ( errno != ERANGE && * endptr ) { uschar * mp = US "ZzEePpTtGgMmKk\0" ; if ( ( mp = Ustrchr ( mp , * endptr ) ) ) { endptr ++ ; while ( * ( mp += 2 ) ) { if ( lvalue > EXIM_ARITH_MAX / 1024 || lvalue < EXIM_ARITH_MIN / 1024 ) { errno = ERANGE ; break ; } lvalue *= 1024 ; } } else { lvalue = ( lvalue + 512 ) / 1024 ; } } if ( errno == ERANGE ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "absolute value of integer \"%s\" is too large (overflow)" , s ) ; } while ( isspace ( * endptr ) ) { endptr ++ ; } if ( * endptr != 0 ) { extra_chars_error ( endptr , inttype , US "integer value for " , name ) ; } if ( data_block ) { * ( int_eximarith_t * ) ( US data_block + ol -> v . offset ) = lvalue ; } else { * ( int_eximarith_t * ) ol -> v . value = lvalue ; } break ; } case opt_fixed : if ( sscanf ( , "%d%n" , , ) != 1 ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "fixed-point number expected for %s" , name ) ; } if ( value < 0 ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "integer \"%s\" is too large (overflow)" , s ) ; } value *= 1000 ; if ( value < 0 ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "integer \"%s\" is too large (overflow)" , s ) ; } if ( s [ count ] == '.' ) { int d = 100 ; while ( isdigit ( s [ ++ count ] ) ) { value += ( s [ count ] - '0' ) * d ; d /= 10 ; } } while ( isspace ( s [ count ] ) ) { count ++ ; } if ( s [ count ] != 0 ) { extra_chars_error ( s + count , US "fixed-point value for " , name , US "" ) ; } if ( data_block ) { * ( ( int * ) ( US data_block + ol -> v . offset ) ) = value ; } else { * ( ( int * ) ol -> v . value ) = value ; } break ; case opt_time : value = readconf_readtime ( s , 0 , FALSE ) ; if ( value < 0 ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "invalid time value for %s" , name ) ; } if ( data_block ) { * ( ( int * ) ( US data_block + ol -> v . offset ) ) = value ; } else { * ( ( int * ) ol -> v . value ) = value ; } break ; case opt_timelist : { int count = 0 ; int * list = data_block ?( int * ) ( US data_block + ol -> v . offset ) : ( int * ) ol -> v . value ; if ( * s != 0 ) { for ( count = 1 ; count <= list [ 0 ] - 2 ; count ++ ) { int terminator = 0 ; uschar * snext = Ustrchr ( s , ':' ) ; if ( snext != NULL ) { uschar * ss = snext ; while ( ss > s && isspace ( ss [ - 1 ] ) ) { ss -- ; } terminator = * ss ; } value = readconf_readtime ( s , terminator , FALSE ) ; if ( value < 0 ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "invalid time value for %s" , name ) ; } if ( count > 1 && value <= list [ count ] ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "time value out of order for %s" , name ) ; } list [ count + 1 ] = value ; if ( snext == NULL ) { break ; } s = snext + 1 ; while ( isspace ( * s ) ) { s ++ ; } } } if ( count > list [ 0 ] - 2 ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG_IN , "too many time values for %s" , name ) ; } if ( count > 0 && list [ 2 ] == 0 ) { count = 0 ; } list [ 1 ] = count ; break ; } case opt_func : { void * fn ( ) = ol -> v . fn fn ( name , s , 0 ) ; break ; } } return TRUE ; 