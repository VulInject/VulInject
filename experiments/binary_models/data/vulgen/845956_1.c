static void routeout_fetch_packet ( GF_ROUTEOutCtx * ctx , ROUTEPid * rpid ) { const GF_PropertyValue * p ; Bool start , end ; u64 pck_dur ; u64 ts ; Bool has_ts ; Bool pck_dur_for_segment ; retry rpid -> current_pck = gf_filter_pid_get_packet ( rpid -> pid ) ; if ( ! rpid -> current_pck ) { if ( gf_filter_pid_is_eos ( rpid -> pid ) ) { if ( gf_filter_reporting_enabled ( filter ) ) { char szStatus [ 1024 ] ; snprintf ( szStatus , 1024 , "%s: done - wrote " LLU " bytes" , gf_file_basename ( ctx -> szFileName ) , ctx -> nb_write ) ; gf_filter_update_status ( filter , 10000 , szStatus ) ; } if ( rpid -> route -> dash_mode && rpid -> res_size ) { GF_FilterEvent evt ; GF_FEVT_INIT ( evt , GF_FEVT_SEGMENT_SIZE , rpid -> pid ) ; evt . seg_size . seg_url = NULL ; if ( rpid -> route -> dash_mode == 1 ) { evt . seg_size . is_init = 1 ; rpid -> route -> dash_mode = 2 ; evt . seg_size . media_range_start = 0 ; evt . seg_size . media_range_end = 0 ; gf_filter_pid_send_event ( rpid -> pid , & evt ) ; } else { evt . seg_size . is_init = 0 ; evt . seg_size . media_range_start = rpid -> offset_at_seg_start ; evt . seg_size . media_range_end = rpid -> res_size - 1 ; gf_filter_pid_send_event ( rpid -> pid , & evt ) ; } } rpid -> res_size = 0 ; return ; } return ; } gf_filter_pck_ref ( & rpid -> current_pck ) ; gf_filter_pid_drop_packet ( rpid -> pid ) ; gf_filter_pck_get_framing ( rpid -> current_pck , & start , & end ) ; if ( rpid -> raw_file ) { u32 dep_flags = gf_filter_pck_get_dependency_flags ( rpid -> current_pck ) ; if ( ( dep_flags & 0x3 ) == 1 ) { gf_filter_pck_unref ( rpid -> current_pck ) ; rpid -> current_pck = NULL ; retry } } rpid -> pck_data = gf_filter_pck_get_data ( rpid -> current_pck , & rpid -> pck_size ) ; rpid -> pck_offset = 0 ; p = gf_filter_pck_get_property ( rpid -> current_pck , GF_PROP_PCK_INIT ) ; if ( p && p -> value . boolean ) { u32 crc ; assert ( start && end ) ; crc = gf_crc_32 ( rpid -> pck_data , rpid -> pck_size ) ; if ( crc != rpid -> init_seg_crc ) { rpid -> init_seg_crc = crc ; rpid -> route -> stsid_changed = GF_TRUE ; rpid -> current_toi = 0 ; if ( rpid -> init_seg_data ) { gf_free ( rpid -> init_seg_data ) ; } rpid -> init_seg_data = gf_malloc ( rpid -> pck_size ) ; memcpy ( rpid -> init_seg_data , rpid -> pck_data , rpid -> pck_size ) ; rpid -> init_seg_size = rpid -> pck_size ; rpid -> init_seg_sent = GF_FALSE ; p = gf_filter_pck_get_property ( rpid -> current_pck , GF_PROP_PCK_FILENAME ) ; if ( rpid -> init_seg_name ) { gf_free ( rpid -> init_seg_name ) ; } rpid -> init_seg_name = p ?routeout_strip_base ( rpid -> route , p -> value . string ) : NULL ; } gf_filter_pck_unref ( rpid -> current_pck ) ; rpid -> current_pck = NULL ; retry } p = gf_filter_pck_get_property ( rpid -> current_pck , GF_PROP_PID_HLS_PLAYLIST ) ; if ( p && p -> value . string ) { u32 crc ; assert ( start && end ) ; crc = gf_crc_32 ( rpid -> pck_data , rpid -> pck_size ) ; if ( crc != rpid -> hld_child_pl_crc ) { rpid -> hld_child_pl_crc = crc ; if ( rpid -> hld_child_pl ) { gf_free ( rpid -> hld_child_pl ) ; } rpid -> hld_child_pl = gf_malloc ( rpid -> pck_size + 1 ) ; memcpy ( rpid -> hld_child_pl , rpid -> pck_data , rpid -> pck_size ) ; rpid -> hld_child_pl [ rpid -> pck_size ] = 0 ; if ( ! rpid -> hld_child_pl_name || strcmp ( rpid -> hld_child_pl_name , p -> value . string ) ) { rpid -> route -> stsid_changed = GF_TRUE ; if ( rpid -> hld_child_pl_name ) { gf_free ( rpid -> hld_child_pl_name ) ; } rpid -> hld_child_pl_name = routeout_strip_base ( rpid -> route , p -> value . string ) ; } } gf_filter_pck_unref ( rpid -> current_pck ) ; rpid -> current_pck = NULL ; retry } if ( rpid -> route -> dash_mode ) { p = gf_filter_pck_get_property ( rpid -> current_pck , GF_PROP_PCK_FILENUM ) ; if ( p ) { GF_FilterEvent evt ; GF_FEVT_INIT ( evt , GF_FEVT_SEGMENT_SIZE , rpid -> pid ) ; evt . seg_size . seg_url = NULL ; if ( rpid -> route -> dash_mode == 1 ) { evt . seg_size . is_init = 1 ; rpid -> route -> dash_mode = 2 ; evt . seg_size . media_range_start = 0 ; evt . seg_size . media_range_end = 0 ; gf_filter_pid_send_event ( rpid -> pid , & evt ) ; } else { evt . seg_size . is_init = 0 ; evt . seg_size . media_range_start = rpid -> offset_at_seg_start ; evt . seg_size . media_range_end = rpid -> res_size - 1 ; rpid -> offset_at_seg_start = evt . seg_size . media_range_end ; gf_filter_pid_send_event ( rpid -> pid , & evt ) ; } if ( gf_filter_pck_get_property ( rpid -> current_pck , GF_PROP_PCK_FILENAME ) ) { start = GF_TRUE ; } } } if ( rpid -> raw_file ) { assert ( start && end ) ; if ( rpid -> seg_name ) { gf_free ( rpid -> seg_name ) ; } rpid -> seg_name = "unknown" ; p = gf_filter_pid_get_property ( rpid -> pid , GF_PROP_PID_ROUTE_NAME ) ; if ( p ) { rpid -> seg_name = p -> value . string ; } else { p = gf_filter_pid_get_property ( rpid -> pid , GF_PROP_PID_URL ) ; if ( p ) { rpid -> seg_name = gf_file_basename ( p -> value . string ) ; } } rpid -> seg_name = gf_strdup ( rpid -> seg_name ) ; rpid -> carousel_time_us = ctx -> carousel ; p = gf_filter_pid_get_property ( rpid -> pid , GF_PROP_PID_ROUTE_CAROUSEL ) ; if ( p ) { rpid -> carousel_time_us = p -> value . frac . num ; rpid -> carousel_time_us *= 1000000 ; rpid -> carousel_time_us /= p -> value . frac . den ; } rpid -> current_dur_us = ctx -> carousel ; p = gf_filter_pid_get_property ( rpid -> pid , GF_PROP_PID_ROUTE_SENDTIME ) ; if ( p ) { rpid -> current_dur_us = p -> value . frac . num ; rpid -> current_dur_us *= 1000000 ; rpid -> current_dur_us /= p -> value . frac . den ; } if ( rpid -> carousel_time_us && ( rpid -> current_dur_us > rpid -> carousel_time_us ) ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_ROUTE , ( "[ROUTE] Requested upload time of file " LLU " is greater than its carousel time " LLU ", adjusting carousel\n" , rpid -> current_dur_us , rpid -> carousel_time_us ) ) ; rpid -> carousel_time_us = rpid -> current_dur_us ; } rpid -> clock_at_pck = rpid -> current_cts_us = rpid -> cts_us_at_frame_start = ctx -> clock ; rpid -> full_frame_size = rpid -> pck_size ; return ; } if ( start ) { p = gf_filter_pck_get_property ( rpid -> current_pck , GF_PROP_PCK_FILENAME ) ; if ( rpid -> seg_name ) { gf_free ( rpid -> seg_name ) ; } if ( p ) { rpid -> seg_name = rpid -> use_basename ?gf_file_basename ( p -> value . string ) : p -> value . string ; } else { rpid -> seg_name = "unknown" ; } rpid -> seg_name = gf_strdup ( rpid -> seg_name ) ; p = gf_filter_pck_get_property ( rpid -> current_pck , GF_PROP_PCK_FILENUM ) ; if ( p ) { rpid -> current_toi = p -> value . uint ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_ROUTE , ( "[ROUTE] Missing filenum on segment %s, something is wrong in demux chain - assuming +1 increase\n" , rpid -> seg_name ) ) ; rpid -> current_toi ++ ; } rpid -> frag_idx = 0 ; rpid -> full_frame_size = end ?rpid -> pck_size : 0 ; rpid -> cumulated_frag_size = rpid -> pck_size ; rpid -> push_init = GF_TRUE ; rpid -> frag_offset = 0 ; } else { rpid -> frag_idx ++ ; rpid -> cumulated_frag_size += rpid -> pck_size ; if ( end ) { rpid -> full_frame_size = rpid -> cumulated_frag_size ; rpid -> force_tol_send = GF_TRUE ; } } pck_dur = gf_filter_pck_get_duration ( rpid -> current_pck ) ; pck_dur_for_segment = GF_FALSE ; if ( start ) { rpid -> pck_dur_at_frame_start = 0 ; if ( gf_filter_pck_get_carousel_version ( rpid -> current_pck ) ) { pck_dur_for_segment = GF_TRUE ; } } ts = gf_filter_pck_get_cts ( rpid -> current_pck ) ; has_ts = ( ts == GF_FILTER_NO_TS ) ?GF_FALSE : GF_TRUE ; if ( ( ! start && ! has_ts && rpid -> bitrate && rpid -> pck_dur_at_frame_start ) || ( has_ts && start && ! end && pck_dur && pck_dur_for_segment ) ) { u64 frag_time , tot_est_size ; if ( has_ts ) { rpid -> pck_dur_at_frame_start = ( u32 ) pck_dur ; } tot_est_size = gf_timestamp_rescale ( rpid -> bitrate , rpid -> timescale , rpid -> pck_dur_at_frame_start ) ; tot_est_size /= 8 ; pck_dur = rpid -> pck_size * rpid -> pck_dur_at_frame_start / tot_est_size ; if ( ! pck_dur ) { pck_dur = 1 ; } if ( ! has_ts ) { frag_time = ( rpid -> cumulated_frag_size - rpid -> pck_size ) * rpid -> pck_dur_at_frame_start / tot_est_size ; ts = rpid -> cts_at_frame_start + frag_time ; } else { frag_time = 0 ; } GF_LOG ( GF_LOG_DEBUG , GF_LOG_ROUTE , ( "[ROUTE] Missing timing for fragment %d of segment %s - timing estimated from bitrate: TS " LLU " (" LLU " in segment) dur " LLU "\n" , rpid -> frag_idx , rpid -> seg_name , ts , frag_time , pck_dur ) ) ; } if ( ts != GF_FILTER_NO_TS ) { u64 diff ; if ( ! rpid -> clock_at_first_pck ) { rpid -> clock_at_first_pck = ctx -> clock ; rpid -> cts_first_pck = ts ; } diff = gf_timestamp_rescale ( ts - rpid -> cts_first_pck , rpid -> timescale , 1000000 ) ; rpid -> current_cts_us = rpid -> clock_at_first_pck + diff ; rpid -> clock_at_pck = ctx -> clock ; if ( start ) { rpid -> clock_at_frame_start = ctx -> clock ; rpid -> cts_us_at_frame_start = rpid -> current_cts_us ; rpid -> cts_at_frame_start = ts ; } rpid -> current_dur_us = pck_dur ; if ( ! rpid -> current_dur_us ) { rpid -> current_dur_us = rpid -> timescale ; GF_LOG ( GF_LOG_ERROR , GF_LOG_ROUTE , ( "[ROUTE] Missing duration on segment %s, something is wrong in demux chain, will not be able to regulate correctly\n" , rpid -> seg_name ) ) ; } rpid -> current_dur_us = gf_timestamp_rescale ( rpid -> current_dur_us , rpid -> timescale , 1000000 ) ; } if ( start && end ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_ROUTE , ( "[ROUTE] Missing timing on segment %s, using previous fragment timing CTS " LLU " duration " LLU " us\nSomething could be wrong in demux chain, will not be able to regulate correctly\n" , rpid -> seg_name , rpid -> current_cts_us - rpid -> clock_at_first_pck , rpid -> current_dur_us ) ) ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_ROUTE , ( "[ROUTE] Missing timing on fragment %d of segment %s, using previous fragment timing CTS " LLU " duration " LLU " us\nSomething could be wrong in demux chain, will not be able to regulate correctly\n" , rpid -> frag_idx , rpid -> seg_name , rpid -> current_cts_us - rpid -> clock_at_first_pck , rpid -> current_dur_us ) ) ; } rpid -> res_size += rpid -> pck_size ; } 