int processInlineBuffer ( client * c ) { char * newline ; int argc , j , linefeed_chars = 1 ; sds * argv , aux ; size_t querylen ; newline = strchr ( c -> querybuf + c -> qb_pos , '\n' ) ; if ( newline == NULL ) { if ( sdslen ( c -> querybuf ) - c -> qb_pos > PROTO_INLINE_MAX_SIZE ) { addReplyError ( c , "Protocol error: too big inline request" ) ; setProtocolError ( "too big inline request" , c ) ; } return C_ERR ; } if ( newline != c -> querybuf + c -> qb_pos && * ( newline - 1 ) == '\r' ) { newline -- , linefeed_chars ++ ; } querylen = newline - ( c -> querybuf + c -> qb_pos ) ; aux = sdsnewlen ( c -> querybuf + c -> qb_pos , querylen ) ; argv = sdssplitargs ( aux , & argc ) ; sdsfree ( aux ) ; if ( querylen == 0 && getClientType ( c ) == CLIENT_TYPE_SLAVE ) { c -> repl_ack_time = server . unixtime ; } if ( querylen != 0 && c -> flags & CLIENT_MASTER ) { sdsfreesplitres ( argv , argc ) ; serverLog ( LL_WARNING , "WARNING: Receiving inline protocol from master, master stream corruption? Closing the master connection and discarding the cached master." ) ; setProtocolError ( "Master using the inline protocol. Desync?" , c ) ; return C_ERR ; } c -> qb_pos += querylen + linefeed_chars ; if ( argc ) { if ( c -> argv ) { zfree ( c -> argv ) ; } c -> argv_len = argc ; c -> argv = zmalloc ( sizeof ( robj * ) * c -> argv_len ) ; c -> argv_len_sum = 0 ; } for ( c -> argc = 0 , j = 0 ; j < argc ; j ++ ) { c -> argv [ c -> argc ] = createObject ( OBJ_STRING , argv [ j ] ) ; c -> argc ++ ; c -> argv_len_sum += sdslen ( argv [ j ] ) ; } zfree ( argv ) ; return C_OK ; } 