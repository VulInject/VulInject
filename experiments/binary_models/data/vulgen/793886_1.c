int php_oci_statement_execute ( php_oci_statement * statement , ub4 mode ) { php_oci_out_column * outcol ; OCIParam * param = NULL ; text * colname ; ub4 counter ; ub2 define_type ; ub4 iters ; ub4 colcount ; ub2 dynamic ; dvoid * buf ; sword errstatus ; switch ( mode ) { case OCI_COMMIT_ON_SUCCESS : case OCI_DESCRIBE_ONLY : case OCI_DEFAULT : if ( DTRACE_OCI8_EXECUTE_MODE_ENABLED ( ) ) { DTRACE_OCI8_EXECUTE_MODE ( statement -> connection , statement -> connection -> client_id , statement , mode ) ; } break ; default : php_error_docref ( NULL , E_WARNING , "Invalid execute mode given: %d" , mode ) ; return 1 ; break ; } if ( ! statement -> stmttype ) { PHP_OCI_CALL_RETURN ( errstatus , OCIAttrGet , ( ( dvoid * ) statement -> stmt , OCI_HTYPE_STMT , ( ub2 * ) & statement -> stmttype , ( ub4 * ) 0 , OCI_ATTR_STMT_TYPE , statement -> err ) ) ; if ( errstatus != OCI_SUCCESS ) { statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } else { statement -> errcode = 0 ; } } if ( statement -> stmttype == OCI_STMT_SELECT ) { iters = 0 ; } else { iters = 1 ; } if ( statement -> last_query ) { if ( statement -> binds ) { int result = 0 ; zend_hash_apply_with_argument ( statement -> binds , php_oci_bind_pre_exec , ( void * ) & result ) ; if ( result ) { return 1 ; } } PHP_OCI_CALL_RETURN ( errstatus , OCIStmtExecute , ( statement -> connection -> svc , statement -> stmt , statement -> err , iters , 0 , NULL , NULL , mode ) ) ; if ( errstatus != OCI_SUCCESS ) { statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } if ( statement -> binds ) { zend_hash_apply ( statement -> binds , php_oci_bind_post_exec ) ; } if ( mode & OCI_COMMIT_ON_SUCCESS ) { statement -> connection -> rb_on_disconnect = 0 ; } if ( statement -> stmttype != OCI_STMT_SELECT ) { statement -> connection -> rb_on_disconnect = 1 ; } statement -> errcode = 0 ; } if ( statement -> stmttype == OCI_STMT_SELECT && statement -> executed == 0 ) { statement -> executed = 1 ; ALLOC_HASHTABLE ( statement -> columns ) ; zend_hash_init ( statement -> columns , 13 , NULL , php_oci_column_hash_dtor , 0 ) ; counter = 1 ; PHP_OCI_CALL_RETURN ( errstatus , OCIAttrGet , ( ( dvoid * ) statement -> stmt , OCI_HTYPE_STMT , ( dvoid * ) & colcount , ( ub4 * ) 0 , OCI_ATTR_PARAM_COUNT , statement -> err ) ) ; if ( errstatus != OCI_SUCCESS ) { statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } statement -> ncolumns = colcount ; for ( counter = 1 ; counter <= colcount ; counter ++ ) { outcol = ( php_oci_out_column * ) ecalloc ( 1 , sizeof ( php_oci_out_column ) ) ; outcol = zend_hash_index_update_ptr ( statement -> columns , counter , outcol ) ; PHP_OCI_CALL_RETURN ( errstatus , OCIParamGet , ( ( dvoid * ) statement -> stmt , OCI_HTYPE_STMT , statement -> err , ( dvoid * * ) & param , counter ) ) ; if ( errstatus != OCI_SUCCESS ) { statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } PHP_OCI_CALL_RETURN ( errstatus , OCIAttrGet , ( ( dvoid * ) param , OCI_DTYPE_PARAM , ( dvoid * ) & outcol -> data_type , ( ub4 * ) 0 , OCI_ATTR_DATA_TYPE , statement -> err ) ) ; if ( errstatus != OCI_SUCCESS ) { PHP_OCI_CALL ( OCIDescriptorFree , ( param , OCI_DTYPE_PARAM ) ) ; statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } PHP_OCI_CALL_RETURN ( errstatus , OCIAttrGet , ( ( dvoid * ) param , OCI_DTYPE_PARAM , ( dvoid * ) & outcol -> charset_form , ( ub4 * ) 0 , OCI_ATTR_CHARSET_FORM , statement -> err ) ) ; if ( errstatus != OCI_SUCCESS ) { PHP_OCI_CALL ( OCIDescriptorFree , ( param , OCI_DTYPE_PARAM ) ) ; statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } PHP_OCI_CALL_RETURN ( errstatus , OCIAttrGet , ( ( dvoid * ) param , OCI_DTYPE_PARAM , ( dvoid * ) & outcol -> charset_id , ( ub4 * ) 0 , OCI_ATTR_CHARSET_ID , statement -> err ) ) ; if ( errstatus != OCI_SUCCESS ) { PHP_OCI_CALL ( OCIDescriptorFree , ( param , OCI_DTYPE_PARAM ) ) ; statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } PHP_OCI_CALL_RETURN ( errstatus , OCIAttrGet , ( ( dvoid * ) param , OCI_DTYPE_PARAM , ( dvoid * ) & outcol -> data_size , ( dvoid * ) 0 , OCI_ATTR_DATA_SIZE , statement -> err ) ) ; if ( errstatus != OCI_SUCCESS ) { PHP_OCI_CALL ( OCIDescriptorFree , ( param , OCI_DTYPE_PARAM ) ) ; statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } outcol -> storage_size4 = outcol -> data_size ; outcol -> retlen = outcol -> data_size ; PHP_OCI_CALL_RETURN ( errstatus , OCIAttrGet , ( ( dvoid * ) param , OCI_DTYPE_PARAM , ( dvoid * ) & outcol -> scale , ( dvoid * ) 0 , OCI_ATTR_SCALE , statement -> err ) ) ; if ( errstatus != OCI_SUCCESS ) { PHP_OCI_CALL ( OCIDescriptorFree , ( param , OCI_DTYPE_PARAM ) ) ; statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } PHP_OCI_CALL_RETURN ( errstatus , OCIAttrGet , ( ( dvoid * ) param , OCI_DTYPE_PARAM , ( dvoid * ) & outcol -> precision , ( dvoid * ) 0 , OCI_ATTR_PRECISION , statement -> err ) ) ; if ( errstatus != OCI_SUCCESS ) { PHP_OCI_CALL ( OCIDescriptorFree , ( param , OCI_DTYPE_PARAM ) ) ; statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } PHP_OCI_CALL_RETURN ( errstatus , OCIAttrGet , ( ( dvoid * ) param , OCI_DTYPE_PARAM , ( dvoid * * ) & colname , ( ub4 * ) & outcol -> name_len , ( ub4 ) OCI_ATTR_NAME , statement -> err ) ) ; if ( errstatus != OCI_SUCCESS ) { PHP_OCI_CALL ( OCIDescriptorFree , ( param , OCI_DTYPE_PARAM ) ) ; statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } PHP_OCI_CALL ( OCIDescriptorFree , ( param , OCI_DTYPE_PARAM ) ) ; outcol -> name = ecalloc ( 1 , outcol -> name_len + 1 ) ; memcpy ( outcol -> name , colname , outcol -> name_len ) ; if ( statement -> defines ) { if ( ( outcol -> define = zend_hash_str_find_ptr ( statement -> defines , outcol -> name , outcol -> name_len ) ) != NULL ) { if ( outcol -> define -> type ) { outcol -> data_type = outcol -> define -> type ; } } } buf = 0 ; switch ( outcol -> data_type ) { case SQLT_RSET : outcol -> statement = statement ; define_type = SQLT_RSET ; outcol -> is_cursor = 1 ; outcol -> statement -> has_descr = 1 ; outcol -> storage_size4 = - 1 ; outcol -> retlen = - 1 ; dynamic = OCI_DYNAMIC_FETCH ; break ; case SQLT_RDD : case SQLT_BLOB : case SQLT_CLOB : case SQLT_BFILE : outcol -> statement = statement ; define_type = outcol -> data_type ; outcol -> is_descr = 1 ; outcol -> statement -> has_descr = 1 ; outcol -> storage_size4 = - 1 ; outcol -> chunk_size = 0 ; dynamic = OCI_DYNAMIC_FETCH ; break ; case SQLT_LNG : case SQLT_LBI : if ( outcol -> data_type == SQLT_LBI ) { define_type = SQLT_BIN ; } else { define_type = SQLT_CHR ; } outcol -> storage_size4 = PHP_OCI_MAX_DATA_SIZE ; outcol -> piecewise = 1 ; dynamic = OCI_DYNAMIC_FETCH ; break ; case SQLT_BIN : default : define_type = SQLT_CHR ; if ( outcol -> data_type == SQLT_BIN ) { define_type = SQLT_BIN ; } if ( ( outcol -> data_type == SQLT_DAT ) || ( outcol -> data_type == SQLT_NUM ) || ( outcol -> data_type == SQLT_TIMESTAMP ) || ( outcol -> data_type == SQLT_TIMESTAMP_TZ ) || ( outcol -> data_type == SQLT_TIMESTAMP_LTZ ) || ( outcol -> data_type == SQLT_INTERVAL_YM ) || ( outcol -> data_type == SQLT_INTERVAL_DS ) ) { outcol -> storage_size4 = 512 ; } if ( outcol -> data_type == SQLT_IBFLOAT || outcol -> data_type == SQLT_IBDOUBLE ) { outcol -> storage_size4 = 1024 ; } else { outcol -> storage_size4 ++ ; } outcol -> storage_size4 *= 3 ; dynamic = OCI_DEFAULT ; buf = outcol -> data = ( text * ) safe_emalloc ( 1 , outcol -> storage_size4 , 0 ) ; memset ( buf , 0 , outcol -> storage_size4 ) ; break ; } if ( dynamic == OCI_DYNAMIC_FETCH ) { PHP_OCI_CALL_RETURN ( errstatus , OCIDefineByPos , ( statement -> stmt , ( OCIDefine * * ) & outcol -> oci_define , statement -> err , counter , ( dvoid * ) NULL , outcol -> storage_size4 , define_type , ( dvoid * ) & outcol -> indicator , ( ub2 * ) NULL , ( ub2 * ) NULL , OCI_DYNAMIC_FETCH ) ) ; } else { PHP_OCI_CALL_RETURN ( errstatus , OCIDefineByPos , ( statement -> stmt , ( OCIDefine * * ) & outcol -> oci_define , statement -> err , counter , ( dvoid * ) buf , outcol -> storage_size4 , define_type , ( dvoid * ) & outcol -> indicator , ( ub2 * ) & outcol -> retlen , ( ub2 * ) & outcol -> retcode , OCI_DEFAULT ) ) ; } if ( errstatus != OCI_SUCCESS ) { statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } if ( ( outcol -> data_type == SQLT_CLOB || outcol -> data_type == SQLT_BLOB ) && statement -> prefetch_lob_size > 0 ) { int get_lob_len = 1 ; PHP_OCI_CALL_RETURN ( errstatus , OCIAttrSet , ( outcol -> oci_define , OCI_HTYPE_DEFINE , & get_lob_len , 0 , OCI_ATTR_LOBPREFETCH_LENGTH , statement -> err ) ) ; if ( errstatus != OCI_SUCCESS ) { statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } PHP_OCI_CALL_RETURN ( errstatus , OCIAttrSet , ( outcol -> oci_define , OCI_HTYPE_DEFINE , & ( statement -> prefetch_lob_size ) , 0 , OCI_ATTR_LOBPREFETCH_SIZE , statement -> err ) ) ; if ( errstatus != OCI_SUCCESS ) { statement -> errcode = php_oci_error ( statement -> err , errstatus ) ; PHP_OCI_HANDLE_ERROR ( statement -> connection , statement -> errcode ) ; return 1 ; } } switch ( outcol -> data_type ) { case SQLT_RSET : case SQLT_BLOB : case SQLT_CLOB : case SQLT_RDD : case SQLT_BFILE : PHP_OCI_CALL_RETURN ( errstatus , OCIDefineDynamic , ( outcol -> oci_define , statement -> err , ( dvoid * ) outcol , php_oci_define_callback ) ) ; break ; } } statement -> errcode = 0 ; } return 0 ; } 