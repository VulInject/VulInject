static int cell_edac_probe ( struct platform_device * pdev ) { struct cbe_mic_tm_regs __iomem * regs ; struct mem_ctl_info * mci ; struct edac_mc_layer layers [ 2 ] ; struct cell_edac_priv * priv ; u64 reg ; int rc , chanmask , num_chans ; regs = cbe_get_cpu_mic_tm_regs ( cbe_node_to_cpu ( pdev -> id ) ) ; edac_op_state = EDAC_OPSTATE_POLL ; reg = in_be64 ( & regs -> mic_mnt_cfg ) ; dev_dbg ( & pdev -> dev , "MIC_MNT_CFG = 0x%016llx\n" , reg ) ; chanmask = 0 ; if ( reg & CBE_MIC_MNT_CFG_CHAN_0_POP ) { chanmask |= 0x1 ; } if ( reg & CBE_MIC_MNT_CFG_CHAN_1_POP ) { chanmask |= 0x2 ; } if ( chanmask == 0 ) { dev_warn ( & pdev -> dev , "Yuck ! No channel populated ? Aborting !\n" ) ; return - ENODEV ; } dev_dbg ( & pdev -> dev , "Initial FIR = 0x%016llx\n" , in_be64 ( & regs -> mic_fir ) ) ; num_chans = chanmask == 3 ?2 : 1 ; layers [ 0 ] . type = EDAC_MC_LAYER_CHIP_SELECT ; layers [ 0 ] . size = 1 ; layers [ 0 ] . is_virt_csrow = true ; layers [ 1 ] . type = EDAC_MC_LAYER_CHANNEL ; layers [ 1 ] . size = num_chans ; layers [ 1 ] . is_virt_csrow = false ; mci = edac_mc_alloc ( pdev -> id , ARRAY_SIZE ( layers ) , layers , sizeof ( cell_edac_priv ) ) ; if ( mci == NULL ) { return - ENOMEM ; } priv = mci -> pvt_info ; priv -> regs = regs ; priv -> node = pdev -> id ; priv -> chanmask = chanmask ; mci -> pdev = & pdev -> dev ; mci -> mtype_cap = MEM_FLAG_XDR ; mci -> edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_EC | EDAC_FLAG_SECDED ; mci -> edac_cap = EDAC_FLAG_EC | EDAC_FLAG_SECDED ; mci -> mod_name = "cell_edac" ; mci -> ctl_name = "MIC" ; mci -> dev_name = dev_name ( & pdev -> dev ) ; mci -> edac_check = cell_edac_check ; cell_edac_init_csrows ( mci ) ; rc = edac_mc_add_mc ( mci ) ; if ( rc ) { dev_err ( & pdev -> dev , "failed to register with EDAC core\n" ) ; edac_mc_free ( mci ) ; return rc ; } return 0 ; } 