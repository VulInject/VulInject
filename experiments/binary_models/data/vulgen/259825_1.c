int atomisp_subdev_set_selection ( struct v4l2_subdev * sd , struct v4l2_subdev_pad_config * cfg , uint32_t which , uint32_t pad , uint32_t target , uint32_t flags , struct v4l2_rect * r ) { struct atomisp_sub_device * isp_sd = v4l2_get_subdevdata ( sd ) ; struct atomisp_device * isp = isp_sd -> isp ; struct v4l2_mbus_framefmt * ffmt [ ATOMISP_SUBDEV_PADS_NUM ] ; uint16_t vdev_pad = atomisp_subdev_source_pad ( sd -> devnode ) ; struct v4l2_rect * crop [ ATOMISP_SUBDEV_PADS_NUM ] , * comp [ ATOMISP_SUBDEV_PADS_NUM ] ; enum atomisp_input_stream_id stream_id ; unsigned int i ; unsigned int padding_w = pad_w ; unsigned int padding_h = pad_h ; stream_id = atomisp_source_pad_to_stream_id ( isp_sd , vdev_pad ) ; isp_get_fmt_rect ( sd , cfg , which , ffmt , crop , comp ) ; dev_dbg ( isp -> dev , "sel: pad %s tgt %s l %d t %d w %d h %d which %s f 0x%8.8x\n" , atomisp_pad_str [ pad ] , target == V4L2_SEL_TGT_CROP ?"V4L2_SEL_TGT_CROP" : "V4L2_SEL_TGT_COMPOSE" , r -> left , r -> top , r -> width , r -> height , which == V4L2_SUBDEV_FORMAT_TRY ?"V4L2_SUBDEV_FORMAT_TRY" : "V4L2_SUBDEV_FORMAT_ACTIVE" , flags ) ; r -> width = rounddown ( r -> width , ATOM_ISP_STEP_WIDTH ) ; r -> height = rounddown ( r -> height , ATOM_ISP_STEP_HEIGHT ) ; switch ( pad ) { case ATOMISP_SUBDEV_PAD_SINK : { unsigned int dvs_w , dvs_h ; crop [ pad ] -> width = ffmt [ pad ] -> width ; crop [ pad ] -> height = ffmt [ pad ] -> height ; if ( ! strncmp ( isp -> inputs [ isp_sd -> input_curr ] . camera -> name , "ov2722" , 6 ) && crop [ pad ] -> height == 1092 ) { padding_w = 12 ; padding_h = 12 ; } if ( isp -> inputs [ isp_sd -> input_curr ] . type == SOC_CAMERA ) { padding_w = 0 ; padding_h = 0 ; } if ( atomisp_subdev_format_conversion ( isp_sd , isp_sd -> capture_pad ) && crop [ pad ] -> width && crop [ pad ] -> height ) { crop [ pad ] -> width -= padding_w , crop [ pad ] -> height -= padding_h ; } if ( isp -> inputs [ isp_sd -> input_curr ] . type == SOC_CAMERA ) { isp_sd -> params . video_dis_en = 0 ; } if ( isp_sd -> params . video_dis_en && isp_sd -> run_mode -> val == ATOMISP_RUN_MODE_VIDEO && ! isp_sd -> continuous_mode -> val ) { crop [ pad ] -> width = roundup ( crop [ pad ] -> width * 5 / 6 , ATOM_ISP_STEP_WIDTH ) ; crop [ pad ] -> height = roundup ( crop [ pad ] -> height * 5 / 6 , ATOM_ISP_STEP_HEIGHT ) ; } crop [ pad ] -> width = min ( crop [ pad ] -> width , r -> width ) ; crop [ pad ] -> height = min ( crop [ pad ] -> height , r -> height ) ; if ( ! ( flags & V4L2_SEL_FLAG_KEEP_CONFIG ) ) { for ( i = ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE ; i < ATOMISP_SUBDEV_PADS_NUM ; i ++ ) { struct v4l2_rect tmp = * crop [ pad ] ; atomisp_subdev_set_selection ( sd , cfg , which , i , V4L2_SEL_TGT_COMPOSE , flags , & tmp ) ; } } if ( which == V4L2_SUBDEV_FORMAT_TRY ) { break ; } if ( isp_sd -> params . video_dis_en && isp_sd -> run_mode -> val == ATOMISP_RUN_MODE_VIDEO && ! isp_sd -> continuous_mode -> val ) { dvs_w = rounddown ( crop [ pad ] -> width / 5 , ATOM_ISP_STEP_WIDTH ) ; dvs_h = rounddown ( crop [ pad ] -> height / 5 , ATOM_ISP_STEP_HEIGHT ) ; } if ( ! isp_sd -> params . video_dis_en && isp_sd -> run_mode -> val == ATOMISP_RUN_MODE_VIDEO ) { dvs_w = dvs_h = 12 ; } else { dvs_w = dvs_h = 0 ; } atomisp_css_video_set_dis_envelope ( isp_sd , dvs_w , dvs_h ) ; atomisp_css_input_set_effective_resolution ( isp_sd , stream_id , crop [ pad ] -> width , crop [ pad ] -> height ) ; break ; } case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE : case ATOMISP_SUBDEV_PAD_SOURCE_VIDEO : { if ( isp_sd -> vfpp -> val == ATOMISP_VFPP_DISABLE_LOWLAT ) { r -> width = crop [ ATOMISP_SUBDEV_PAD_SINK ] -> width ; r -> height = crop [ ATOMISP_SUBDEV_PAD_SINK ] -> height ; } if ( crop [ ATOMISP_SUBDEV_PAD_SINK ] -> width == r -> width && crop [ ATOMISP_SUBDEV_PAD_SINK ] -> height == r -> height ) { isp_sd -> params . yuv_ds_en = false ; } else { isp_sd -> params . yuv_ds_en = true ; } comp [ pad ] -> width = r -> width ; comp [ pad ] -> height = r -> height ; if ( r -> width == 0 || r -> height == 0 || crop [ ATOMISP_SUBDEV_PAD_SINK ] -> width == 0 || crop [ ATOMISP_SUBDEV_PAD_SINK ] -> height == 0 ) { break ; } if ( r -> width * crop [ ATOMISP_SUBDEV_PAD_SINK ] -> height < crop [ ATOMISP_SUBDEV_PAD_SINK ] -> width * r -> height ) { atomisp_css_input_set_effective_resolution ( isp_sd , stream_id , rounddown ( crop [ ATOMISP_SUBDEV_PAD_SINK ] -> height * r -> width / r -> height , ATOM_ISP_STEP_WIDTH ) , crop [ ATOMISP_SUBDEV_PAD_SINK ] -> height ) ; } else { atomisp_css_input_set_effective_resolution ( isp_sd , stream_id , crop [ ATOMISP_SUBDEV_PAD_SINK ] -> width , rounddown ( crop [ ATOMISP_SUBDEV_PAD_SINK ] -> width * r -> height / r -> width , ATOM_ISP_STEP_WIDTH ) ) ; } break ; } case ATOMISP_SUBDEV_PAD_SOURCE_VF : case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW : comp [ pad ] -> width = r -> width ; comp [ pad ] -> height = r -> height ; break ; default : return - EINVAL ; } if ( ! atomisp_subdev_get_rect ( sd , cfg , which , pad , target ) ) { return - EINVAL ; } * r = * atomisp_subdev_get_rect ( sd , cfg , which , pad , target ) ; dev_dbg ( isp -> dev , "sel actual: l %d t %d w %d h %d\n" , r -> left , r -> top , r -> width , r -> height ) ; return 0 ; } 