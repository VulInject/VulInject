bool hvf_inject_interrupts ( CPUState * cpu_state ) { X86CPU * x86cpu = X86_CPU ( cpu_state ) ; CPUX86State * env = & x86cpu -> env ; uint8_t vector ; uint64_t intr_type ; bool have_event = true ; if ( env -> interrupt_injected != - 1 ) { vector = env -> interrupt_injected ; if ( env -> ins_len ) { intr_type = VMCS_INTR_T_SWINTR ; } else { intr_type = VMCS_INTR_T_HWINTR ; } } if ( env -> exception_nr != - 1 ) { vector = env -> exception_nr ; if ( vector == EXCP03_INT3 || vector == EXCP04_INTO ) { intr_type = VMCS_INTR_T_SWEXCEPTION ; } else { intr_type = VMCS_INTR_T_HWEXCEPTION ; } } if ( env -> nmi_injected ) { vector = EXCP02_NMI ; intr_type = VMCS_INTR_T_NMI ; } else { have_event = false ; } uint64_t info = 0 ; if ( have_event ) { info = vector | intr_type | VMCS_INTR_VALID ; uint64_t reason = rvmcs ( cpu_state -> hvf -> fd , VMCS_EXIT_REASON ) ; if ( env -> nmi_injected && reason != EXIT_REASON_TASK_SWITCH ) { vmx_clear_nmi_blocking ( cpu_state ) ; } if ( ! ( env -> hflags2 & HF2_NMI_MASK ) || intr_type != VMCS_INTR_T_NMI ) { info &= ~ ( 1 << 12 ) ; if ( intr_type == VMCS_INTR_T_SWINTR || intr_type == VMCS_INTR_T_SWEXCEPTION ) { wvmcs ( cpu_state -> hvf -> fd , VMCS_ENTRY_INST_LENGTH , env -> ins_len ) ; } if ( env -> has_error_code ) { info |= VMCS_INTR_DEL_ERRCODE ; } wvmcs ( cpu_state -> hvf -> fd , VMCS_ENTRY_INTR_INFO , info ) ; } } if ( cpu_state -> interrupt_request & CPU_INTERRUPT_NMI ) { if ( ! ( env -> hflags2 & HF2_NMI_MASK ) && ! ( info & VMCS_INTR_VALID ) ) { cpu_state -> interrupt_request &= ~ CPU_INTERRUPT_NMI ; info = VMCS_INTR_VALID | VMCS_INTR_T_NMI | EXCP02_NMI ; wvmcs ( cpu_state -> hvf -> fd , VMCS_ENTRY_INTR_INFO , info ) ; } else { vmx_set_nmi_window_exiting ( cpu_state ) ; } } if ( ! ( env -> hflags & HF_INHIBIT_IRQ_MASK ) && ( cpu_state -> interrupt_request & CPU_INTERRUPT_HARD ) && ( env -> eflags & IF_MASK ) && ! ( info & VMCS_INTR_VALID ) ) { int line = cpu_get_pic_interrupt ( & x86cpu -> env ) ; cpu_state -> interrupt_request &= ~ CPU_INTERRUPT_HARD ; if ( line >= 0 ) { wvmcs ( cpu_state -> hvf -> fd , VMCS_ENTRY_INTR_INFO , line | VMCS_INTR_VALID | VMCS_INTR_T_HWINTR ) ; } } if ( cpu_state -> interrupt_request & CPU_INTERRUPT_HARD ) { vmx_set_int_window_exiting ( cpu_state ) ; } return ( cpu_state -> interrupt_request & ( CPU_INTERRUPT_INIT | CPU_INTERRUPT_TPR ) ) ; } 