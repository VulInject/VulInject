static void mhi_ep_ch_ring_worker ( struct work_struct * work ) { struct mhi_ep_cntrl * mhi_cntrl = container_of ( work , mhi_ep_cntrl , ch_ring_work ) ; struct device * dev = & mhi_cntrl -> mhi_dev -> dev ; struct mhi_ep_ring_item * itr , * tmp ; struct mhi_ring_element * el ; struct mhi_ep_ring * ring ; struct mhi_ep_chan * chan ; unsigned long flags ; LIST_HEAD ( head ) ; int ret ; spin_lock_irqsave ( & mhi_cntrl -> list_lock , flags ) ; list_splice_tail_init ( & mhi_cntrl -> ch_db_list , & head ) ; spin_unlock_irqrestore ( & mhi_cntrl -> list_lock , flags ) ; list_for_each_entry_safe ( , , , ) { list_del ( & itr -> node ) ; ring = itr -> ring ; chan = & mhi_cntrl -> mhi_chan [ ring -> ch_id ] ; mutex_lock ( & chan -> lock ) ; if ( ! ring -> started ) { mutex_unlock ( & chan -> lock ) ; continue ; } ret = mhi_ep_update_wr_offset ( ring ) ; if ( ret ) { dev_err ( dev , "Error updating write offset for ring\n" ) ; mutex_unlock ( & chan -> lock ) ; kfree ( itr ) ; continue ; } if ( ring -> rd_offset == ring -> wr_offset ) { mutex_unlock ( & chan -> lock ) ; kfree ( itr ) ; continue ; } el = & ring -> ring_cache [ ring -> rd_offset ] ; dev_dbg ( dev , "Processing the ring for channel (%u)\n" , ring -> ch_id ) ; ret = mhi_ep_process_ch_ring ( ring , el ) ; if ( ret ) { dev_err ( dev , "Error processing ring for channel (%u): %d\n" , ring -> ch_id , ret ) ; mutex_unlock ( & chan -> lock ) ; kfree ( itr ) ; continue ; } mutex_unlock ( & chan -> lock ) ; kfree ( itr ) ; } } 