void parse_channel_modes ( IRC_CHANNEL_REC * channel , const char * setby , const char * mode , int update_key ) { IRC_SERVER_REC * server = channel -> server ; GString * newmode ; char * dup , * modestr , * arg , * curmode , type , * old_key ; int umode ; g_return_if_fail ( IS_IRC_CHANNEL ( channel ) ) ; g_return_if_fail ( mode != NULL ) ; type = '+' ; newmode = g_string_new ( channel -> mode ) ; old_key = update_key ?NULL : g_strdup ( channel -> key ) ; dup = modestr = g_strdup ( mode ) ; curmode = cmd_get_param ( & modestr ) ; while ( * curmode != '\0' ) { if ( HAS_MODE_ARG ( server , type , * curmode ) ) { arg = cmd_get_param ( & modestr ) ; } else { arg = NULL ; } switch ( * curmode ) { case '+' : case '-' : type = * curmode ; break ; default : umode = ( unsigned char ) * curmode ; if ( server -> modes [ umode ] . func != NULL ) { server -> modes [ umode ] . func ( channel , setby , type , * curmode , arg , newmode ) ; } else { modes_type_d ( channel , setby , type , * curmode , arg , newmode ) ; } } curmode ++ ; } if ( channel -> key != NULL && strchr ( channel -> mode , 'k' ) == NULL && strchr ( newmode -> str , 'k' ) == NULL ) { g_free ( channel -> key ) ; channel -> key = NULL ; } if ( ! update_key && old_key != NULL ) { g_free ( channel -> key ) ; channel -> key = old_key ; mode_set_arg ( channel -> server , newmode , '+' , 'k' , old_key , FALSE ) ; old_key = NULL ; } if ( g_strcmp0 ( newmode -> str , channel -> mode ) != 0 ) { g_free ( channel -> mode ) ; channel -> mode = g_strdup ( newmode -> str ) ; signal_emit ( "channel mode changed" , 2 , channel , setby ) ; } g_string_free ( newmode , TRUE ) ; g_free ( old_key ) ; } 