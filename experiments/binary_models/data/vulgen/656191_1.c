mblk_t * ip_input_common_v4 ( ill_t * ill , ill_rx_ring_t * ip_ring , mblk_t * mp_chain , struct mac_header_info_s * mhip , squeue_t * target_sqp , mblk_t * * last , uint_t * cnt ) { mblk_t * mp ; ipha_t * ipha ; ip_recv_attr_t iras ; rtc_t rtc ; iaflags_t chain_flags = 0 ; mblk_t * ahead = NULL ; mblk_t * atail = NULL ; uint_t acnt = 0 ; ASSERT ( mp_chain != NULL ) ; ASSERT ( ill != NULL ) ; iras . ira_ill = iras . ira_rill = ill ; iras . ira_ruifindex = ill -> ill_phyint -> phyint_ifindex ; iras . ira_rifindex = iras . ira_ruifindex ; iras . ira_sqp = NULL ; iras . ira_ring = ip_ring ; iras . ira_xmit_hint = ILL_RING_TO_XMIT_HINT ( ip_ring ) ; iras . ira_target_sqp = target_sqp ; iras . ira_target_sqp_mp = NULL ; if ( target_sqp != NULL ) { chain_flags |= IRAF_TARGET_SQP ; } iras . ira_mhip = mhip ; iras . ira_flags = 0 ; if ( mhip != NULL ) { switch ( mhip -> mhi_dsttype ) { case MAC_ADDRTYPE_MULTICAST : chain_flags |= IRAF_L2DST_MULTICAST ; break ; case MAC_ADDRTYPE_BROADCAST : chain_flags |= IRAF_L2DST_BROADCAST ; break ; } } rtc . rtc_ire = NULL ; rtc . rtc_ipaddr = INADDR_ANY ; for ( mp = mp_chain ; mp != NULL ; mp = mp_chain ) { mp_chain = mp -> b_next ; mp -> b_next = NULL ; ASSERT ( DB_TYPE ( mp ) == M_DATA ) ; if ( DB_REF ( mp ) > 1 ) { if ( ( mp = ip_fix_dbref ( mp , & iras ) ) == NULL ) { iras . ira_mhip = NULL ; continue ; } } ipha = ( ipha_t * ) mp -> b_rptr ; if ( ! OK_32PTR ( ipha ) || MBLKL ( mp ) < IP_SIMPLE_HDR_LENGTH ) { mp = ip_check_and_align_header ( mp , IP_SIMPLE_HDR_LENGTH , & iras ) ; if ( mp == NULL ) { iras . ira_mhip = NULL ; continue ; } ipha = ( ipha_t * ) mp -> b_rptr ; } if ( IPH_HDR_VERSION ( ipha ) != IPV4_VERSION ) { BUMP_MIB ( ill -> ill_ip_mib , ipIfStatsInHdrErrors ) ; ip_drop_input ( "ipIfStatsInHdrErrors" , mp , ill ) ; freemsg ( mp ) ; iras . ira_mhip = NULL ; continue ; } if ( ipha -> ipha_dst == INADDR_ANY ) { BUMP_MIB ( ill -> ill_ip_mib , ipIfStatsInAddrErrors ) ; ip_drop_input ( "ipIfStatsInAddrErrors" , mp , ill ) ; freemsg ( mp ) ; iras . ira_mhip = NULL ; continue ; } chain_flags |= ( iras . ira_flags & ( IRAF_L2SRC_SET | IRAF_VERIFIED_SRC ) ) ; iras . ira_flags = IRAF_IS_IPV4 | IRAF_VERIFY_IP_CKSUM | IRAF_VERIFY_ULP_CKSUM | chain_flags ; iras . ira_free_flags = 0 ; iras . ira_cred = NULL ; iras . ira_cpid = NOPID ; iras . ira_tsl = NULL ; iras . ira_zoneid = ALL_ZONES ; BUMP_MIB ( ill -> ill_ip_mib , ipIfStatsHCInReceives ) ; iras . ira_pktlen = ntohs ( ipha -> ipha_length ) ; UPDATE_MIB ( ill -> ill_ip_mib , ipIfStatsHCInOctets , iras . ira_pktlen ) ; * ill -> ill_inputfn ( mp , ipha , & ipha -> ipha_dst , & iras , & rtc ) ; if ( iras . ira_flags & ( IRAF_IPSEC_SECURE | IRAF_SYSTEM_LABELED ) ) { ira_cleanup ( & iras , B_FALSE ) ; } if ( iras . ira_target_sqp_mp != NULL ) { ASSERT ( target_sqp != NULL ) ; mp = iras . ira_target_sqp_mp ; iras . ira_target_sqp_mp = NULL ; ASSERT ( ip_recv_attr_is_mblk ( mp ) ) ; if ( atail != NULL ) { atail -> b_next = mp ; } else { ahead = mp ; } atail = mp ; acnt ++ ; mp = NULL ; } iras . ira_mhip = NULL ; } if ( rtc . rtc_ire != NULL ) { ASSERT ( rtc . rtc_ipaddr != INADDR_ANY ) ; ire_refrele ( rtc . rtc_ire ) ; } return ( NULL ) ; } 