static int myri10ge_open ( struct net_device * dev ) { struct myri10ge_slice_state * ss ; struct myri10ge_priv * mgp = netdev_priv ( dev ) ; struct myri10ge_cmd cmd ; int i , status , big_pow2 , slice ; u8 __iomem * itable ; if ( mgp -> running != MYRI10GE_ETH_STOPPED ) { return - EBUSY ; } mgp -> running = MYRI10GE_ETH_STARTING ; status = myri10ge_reset ( mgp ) ; if ( status != 0 ) { netdev_err ( dev , "failed reset\n" ) ; abort_with_nothing } if ( mgp -> num_slices > 1 ) { cmd . data0 = mgp -> num_slices ; cmd . data1 = MXGEFW_SLICE_INTR_MODE_ONE_PER_SLICE ; if ( mgp -> dev -> real_num_tx_queues > 1 ) { cmd . data1 |= MXGEFW_SLICE_ENABLE_MULTIPLE_TX_QUEUES ; } status = myri10ge_send_cmd ( mgp , MXGEFW_CMD_ENABLE_RSS_QUEUES , & cmd , 0 ) ; if ( status != 0 ) { netdev_err ( dev , "failed to set number of slices\n" ) ; abort_with_nothing } cmd . data0 = mgp -> num_slices ; status = myri10ge_send_cmd ( mgp , MXGEFW_CMD_SET_RSS_TABLE_SIZE , & cmd , 0 ) ; status |= myri10ge_send_cmd ( mgp , MXGEFW_CMD_GET_RSS_TABLE_OFFSET , & cmd , 0 ) ; if ( status != 0 ) { netdev_err ( dev , "failed to setup rss tables\n" ) ; abort_with_nothing } itable = mgp -> sram + cmd . data0 ; for ( i = 0 ; i < mgp -> num_slices ; i ++ ) { __raw_writeb ( i , & itable [ i ] ) ; } cmd . data0 = 1 ; cmd . data1 = myri10ge_rss_hash ; status = myri10ge_send_cmd ( mgp , MXGEFW_CMD_SET_RSS_ENABLE , & cmd , 0 ) ; if ( status != 0 ) { netdev_err ( dev , "failed to enable slices\n" ) ; abort_with_nothing } } status = myri10ge_request_irq ( mgp ) ; if ( status != 0 ) { abort_with_nothing } if ( dev -> mtu <= ETH_DATA_LEN ) { mgp -> small_bytes = ( 128 > SMP_CACHE_BYTES ) ?( 128 - MXGEFW_PAD ) : ( SMP_CACHE_BYTES - MXGEFW_PAD ) ; } else { mgp -> small_bytes = VLAN_ETH_FRAME_LEN ; } if ( myri10ge_small_bytes >= 0 ) { mgp -> small_bytes = myri10ge_small_bytes ; } big_pow2 = dev -> mtu + ETH_HLEN + VLAN_HLEN + MXGEFW_PAD ; if ( big_pow2 < MYRI10GE_ALLOC_SIZE / 2 ) { while ( ! is_power_of_2 ( big_pow2 ) ) { big_pow2 ++ ; } mgp -> big_bytes = dev -> mtu + ETH_HLEN + VLAN_HLEN + MXGEFW_PAD ; } else { big_pow2 = MYRI10GE_ALLOC_SIZE ; mgp -> big_bytes = big_pow2 ; } for ( slice = 0 ; slice < mgp -> num_slices ; slice ++ ) { ss = & mgp -> ss [ slice ] ; status = myri10ge_get_txrx ( mgp , slice ) ; if ( status != 0 ) { netdev_err ( dev , "failed to get ring sizes or locations\n" ) ; abort_with_rings } status = myri10ge_allocate_rings ( ss ) ; if ( slice == 0 || mgp -> dev -> real_num_tx_queues > 1 ) { status = myri10ge_set_stats ( mgp , slice ) ; } if ( status ) { netdev_err ( dev , "Couldn't set stats DMA\n" ) ; abort_with_rings } napi_enable ( & ( ss ) -> napi ) ; } cmd . data0 = dev -> mtu + ETH_HLEN + VLAN_HLEN ; status = myri10ge_send_cmd ( mgp , MXGEFW_CMD_SET_MTU , & cmd , 0 ) ; cmd . data0 = mgp -> small_bytes ; status |= myri10ge_send_cmd ( mgp , MXGEFW_CMD_SET_SMALL_BUFFER_SIZE , & cmd , 0 ) ; cmd . data0 = big_pow2 ; status |= myri10ge_send_cmd ( mgp , MXGEFW_CMD_SET_BIG_BUFFER_SIZE , & cmd , 0 ) ; if ( status ) { netdev_err ( dev , "Couldn't set buffer sizes\n" ) ; abort_with_rings } cmd . data0 = 0 ; status = myri10ge_send_cmd ( mgp , MXGEFW_CMD_SET_TSO_MODE , & cmd , 0 ) ; if ( status && status != - ENOSYS ) { netdev_err ( dev , "Couldn't set TSO mode\n" ) ; abort_with_rings } mgp -> link_state = ~ 0U ; mgp -> rdma_tags_available = 15 ; status = myri10ge_send_cmd ( mgp , MXGEFW_CMD_ETHERNET_UP , & cmd , 0 ) ; if ( status ) { netdev_err ( dev , "Couldn't bring up link\n" ) ; abort_with_rings } mgp -> running = MYRI10GE_ETH_RUNNING ; mgp -> watchdog_timer . expires = jiffies + myri10ge_watchdog_timeout * HZ ; add_timer ( & mgp -> watchdog_timer ) ; netif_tx_wake_all_queues ( dev ) ; return 0 ; abort_with_rings while ( slice ) { slice -- ; napi_disable ( & mgp -> ss [ slice ] . napi ) ; } for ( i = 0 ; i < mgp -> num_slices ; i ++ ) { myri10ge_free_rings ( & mgp -> ss [ i ] ) ; } myri10ge_free_irq ( mgp ) ; abort_with_nothing mgp -> running = MYRI10GE_ETH_STOPPED ; return - ENOMEM ; } 