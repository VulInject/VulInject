void create_reference_properties ( struct assoc_pair * assoc_tbl , int32_t count , char * assoc_name ) { picl_psvc_t * aobjp , * dobjp ; picl_prophdl_t tbl_hdl ; picl_nodehdl_t * dep_list ; ptree_propinfo_t propinfo ; char * funcname = "create_reference_properties" ; char name [ PICL_PROPNAMELEN_MAX ] ; int32_t i , j , offset ; int32_t dependents ; int32_t err ; char class PICL_CLASSNAMELEN_MAX ; for ( i = 0 ; i < count ; ++ i ) { aobjp = ( picl_psvc_t * ) bsearch ( assoc_tbl [ i ] . antecedent , psvc_hdl . objects , psvc_hdl . obj_count , sizeof ( picl_psvc_t ) , ( int ( * ) ( const void * , const void * ) ) name_compare_bsearch ) ; if ( aobjp == NULL ) { init_err ( ID_NOT_FOUND_MSG , funcname , assoc_tbl [ i ] . antecedent ) ; return ; } err = ptree_create_table ( & tbl_hdl ) ; if ( err != 0 ) { init_err ( PTREE_CREATE_TABLE_FAILED_MSG , funcname , picl_strerror ( err ) ) ; return ; } err = node_property ( aobjp -> node , NULL , NULL , PICL_PTYPE_TABLE , sizeof ( tbl_hdl ) , PICL_READ , assoc_name , & tbl_hdl ) ; if ( err != 0 ) { init_err ( CREATE_PROP_FAILED_MSG , funcname , picl_strerror ( err ) ) ; return ; } dependents = 0 ; for ( j = i ; j < count ; ++ j ) { if ( strcmp ( aobjp -> name , assoc_tbl [ j ] . antecedent ) == 0 ) { ++ dependents ; } } dep_list = ( picl_nodehdl_t * ) malloc ( sizeof ( picl_nodehdl_t ) * dependents ) ; if ( dep_list == NULL ) { init_err ( MALLOC_FAILED_MSG , funcname , strerror ( errno ) ) ; return ; } offset = 0 ; for ( j = i ; j < count ; ++ j ) { if ( strcmp ( aobjp -> name , assoc_tbl [ j ] . antecedent ) != 0 ) { continue ; } dobjp = ( picl_psvc_t * ) bsearch ( assoc_tbl [ j ] . dependent , psvc_hdl . objects , psvc_hdl . obj_count , sizeof ( picl_psvc_t ) , ( int ( * ) ( const void * , const void * ) ) name_compare_bsearch ) ; if ( dobjp == NULL ) { init_err ( ID_NOT_FOUND_MSG , funcname , assoc_tbl [ j ] . dependent ) ; return ; } err = ptree_get_propval_by_name ( dobjp -> node , "_class" , class , sizeof ( class ) ) ; if ( err != 0 ) { init_err ( CLASS_NOT_FOUND_MSG , funcname , assoc_tbl [ j ] . dependent ) ; return ; } ( void ) snprintf ( name , sizeof ( name ) , "_%s_subclass" , class ) ; propinfo . version = PSVC_PLUGIN_VERSION ; propinfo . read = NULL ; propinfo . write = NULL ; propinfo . piclinfo . type = PICL_PTYPE_REFERENCE ; propinfo . piclinfo . accessmode = PICL_READ ; propinfo . piclinfo . size = sizeof ( picl_nodehdl_t ) ; ( void ) strcpy ( propinfo . piclinfo . name , name ) ; err = ptree_create_prop ( & propinfo , & dobjp -> node , dep_list + offset ) ; if ( err != 0 ) { init_err ( PTREE_CREATE_PROP_FAILED_MSG , name , picl_strerror ( err ) ) ; return ; } ++ offset ; } err = ptree_add_row_to_table ( tbl_hdl , dependents , dep_list ) ; if ( err != 0 ) { init_err ( PTREE_ADD_ROW_FAILED_MSG , funcname , picl_strerror ( err ) ) ; return ; } } } 