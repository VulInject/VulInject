static krb5_error_code tgs_make_reply ( astgs_request_t r , const EncTicketPart * tgt , const EncryptionKey * serverkey , const EncryptionKey * krbtgtkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , const char * tgt_realm , uint16_t rodc_id , krb5_boolean add_ticket_sig ) { KDC_REQ_BODY * b = & r -> req . req_body ; krb5_data * reply = r -> reply ; KDC_REP * rep = & r -> rep ; EncTicketPart * et = & r -> et ; EncKDCRepPart * ek = & r -> ek ; KDCOptions f = b -> kdc_options ; krb5_error_code ret ; int is_weak = 0 ; heim_assert ( r -> client_princ != NULL , "invalid client name passed to tgs_make_reply" ) ; rep -> pvno = 5 ; rep -> msg_type = krb_tgs_rep ; et -> authtime = tgt -> authtime ; _kdc_fix_time ( & b -> till ) ; et -> endtime = min ( tgt -> endtime , * b -> till ) ; ALLOC ( et -> starttime ) ; * et -> starttime = kdc_time ; if ( ret ) { out } ( r -> config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) ( r -> config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL ) ( r -> config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST ) ret = fix_transited_encoding ( r -> context , r -> config , ! f . disable_transited_check || GLOBAL_FORCE_TRANSITED_CHECK || PRINCIPAL_FORCE_TRANSITED_CHECK ( r -> server ) || ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( r -> server ) ) || GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , & tgt -> transited , et , krb5_principal_get_realm ( r -> context , r -> client_princ ) , krb5_principal_get_realm ( r -> context , r -> server -> principal ) , tgt_realm ) ; { krb5_const_principal rsp ; if ( r -> server -> flags . force_canonicalize ) { rsp = r -> server -> principal ; } else { rsp = r -> server_princ ; } if ( ret == 0 ) { ret = copy_Realm ( & rsp -> realm , & rep -> ticket . realm ) ; } if ( ret == 0 ) { ret = _krb5_principal2principalname ( & rep -> ticket . sname , rsp ) ; } } if ( ret == 0 ) { ret = copy_Realm ( & r -> client_princ -> realm , & rep -> crealm ) ; } if ( ret ) { out } if ( et -> flags . anonymous && ! tgt -> flags . anonymous ) { _kdc_make_anonymous_principalname ( & rep -> cname ) ; } else { ret = copy_PrincipalName ( & r -> client_princ -> name , & rep -> cname ) ; } if ( ret ) { out } rep -> ticket . tkt_vno = 5 ; ek -> caddr = et -> caddr ; { time_t life ; life = et -> endtime - * et -> starttime ; if ( r -> client && r -> client -> max_life ) { life = min ( life , * r -> client -> max_life ) ; } if ( r -> server -> max_life ) { life = min ( life , * r -> server -> max_life ) ; } et -> endtime = * et -> starttime + life ; } if ( f . renewable_ok && tgt -> flags . renewable && et -> renew_till == NULL && et -> endtime < * b -> till && tgt -> renew_till != NULL ) { et -> flags . renewable = 1 ; ALLOC ( et -> renew_till ) ; * et -> renew_till = * b -> till ; } if ( et -> renew_till ) { time_t renew ; renew = * et -> renew_till - * et -> starttime ; if ( r -> client && r -> client -> max_renew ) { renew = min ( renew , * r -> client -> max_renew ) ; } if ( r -> server -> max_renew ) { renew = min ( renew , * r -> server -> max_renew ) ; } * et -> renew_till = * et -> starttime + renew ; } if ( et -> renew_till ) { * et -> renew_till = min ( * et -> renew_till , * tgt -> renew_till ) ; * et -> starttime = min ( * et -> starttime , * et -> renew_till ) ; et -> endtime = min ( et -> endtime , * et -> renew_till ) ; } * et -> starttime = min ( * et -> starttime , et -> endtime ) ; if ( * et -> starttime == et -> endtime ) { ret = KRB5KDC_ERR_NEVER_VALID ; out } if ( et -> renew_till && et -> endtime == * et -> renew_till ) { free ( et -> renew_till ) ; et -> renew_till = NULL ; et -> flags . renewable = 0 ; } et -> flags . pre_authent = tgt -> flags . pre_authent ; et -> flags . hw_authent = tgt -> flags . hw_authent ; et -> flags . ok_as_delegate = r -> server -> flags . ok_as_delegate ; if ( ! r -> server -> flags . forwardable ) { et -> flags . forwardable = 0 ; } if ( ! r -> server -> flags . proxiable ) { et -> flags . proxiable = 0 ; } if ( auth_data ) { unsigned int i = 0 ; if ( et -> authorization_data == NULL ) { et -> authorization_data = calloc ( 1 , sizeof ( * et -> authorization_data ) ) ; if ( et -> authorization_data == NULL ) { ret = ENOMEM ; krb5_set_error_message ( r -> context , ret , "malloc: out of memory" ) ; out } } for ( i = 0 ; i < auth_data -> len ; i ++ ) { ret = add_AuthorizationData ( et -> authorization_data , & auth_data -> val [ i ] ) ; if ( ret ) { krb5_set_error_message ( r -> context , ret , "malloc: out of memory" ) ; out } } } ret = krb5_copy_keyblock_contents ( r -> context , sessionkey , & et -> key ) ; if ( ret ) { out } et -> crealm = rep -> crealm ; et -> cname = rep -> cname ; ek -> key = et -> key ; ek -> last_req . val = calloc ( 1 , sizeof ( * ek -> last_req . val ) ) ; if ( ek -> last_req . val == NULL ) { ret = ENOMEM ; out } ek -> last_req . len = 1 ; ek -> nonce = b -> nonce ; ek -> flags = et -> flags ; ek -> authtime = et -> authtime ; ek -> starttime = et -> starttime ; ek -> endtime = et -> endtime ; ek -> renew_till = et -> renew_till ; ek -> srealm = rep -> ticket . realm ; ek -> sname = rep -> ticket . sname ; _kdc_log_timestamp ( r , "TGS-REQ" , et -> authtime , et -> starttime , et -> endtime , et -> renew_till ) ; if ( krb5_enctype_valid ( r -> context , serverkey -> keytype ) != 0 && _kdc_is_weak_exception ( r -> server -> principal , serverkey -> keytype ) ) { krb5_enctype_enable ( r -> context , serverkey -> keytype ) ; is_weak = 1 ; } if ( r -> canon_client_princ ) { char * cpn ; ( void ) krb5_unparse_name ( r -> context , r -> canon_client_princ , & cpn ) ; kdc_audit_addkv ( ( kdc_request_t ) r , 0 , "canon_client_name" , "%s" , cpn ?cpn : "<unknown>" ) ; krb5_xfree ( cpn ) ; } if ( r -> pac && ! et -> flags . anonymous ) { kdc_audit_setkv_number ( ( kdc_request_t ) r , "pac_attributes" , r -> pac_attributes ) ; if ( _kdc_include_pac_p ( r ) ) { krb5_boolean is_tgs = krb5_principal_is_krbtgt ( r -> context , r -> server -> principal ) ; ret = _krb5_kdc_pac_sign_ticket ( r -> context , r -> pac , r -> client_princ , serverkey , krbtgtkey , rodc_id , NULL , r -> canon_client_princ , add_ticket_sig , et , is_tgs ?& r -> pac_attributes : NULL ) ; if ( ret ) { out } } } ret = _kdc_finalize_reply ( r ) ; if ( ret ) { out } ret = _kdc_encode_reply ( r -> context , r -> config , r , b -> nonce , serverkey -> keytype , kvno , serverkey , 0 , r -> rk_is_subkey , reply ) ; if ( is_weak ) { krb5_enctype_disable ( r -> context , serverkey -> keytype ) ; } _log_astgs_req ( r , serverkey -> keytype ) ; out return ret ; } 