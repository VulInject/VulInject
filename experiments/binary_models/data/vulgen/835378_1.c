static int zfcp_fc_eval_gpn_ft ( struct zfcp_fc_req * fc_req , struct zfcp_adapter * adapter , int max_entries ) { struct zfcp_fsf_ct_els * ct_els = & fc_req -> ct_els ; struct scatterlist * sg = & fc_req -> sg_rsp ; struct fc_ct_hdr * hdr = sg_virt ( sg ) ; struct fc_gpn_ft_resp * acc = sg_virt ( sg ) ; struct zfcp_port * port , * tmp ; unsigned long flags ; LIST_HEAD ( remove_lh ) ; u32 d_id ; int ret = 0 , x , last = 0 ; if ( hdr -> ct_cmd != cpu_to_be16 ( FC_FS_ACC ) ) { if ( hdr -> ct_reason == FC_FS_RJT_UNABL ) { return - EAGAIN ; } return - EIO ; } if ( hdr -> ct_mr_size ) { dev_warn ( & adapter -> ccw_device -> dev , "The name server reported %d words residual data\n" , hdr -> ct_mr_size ) ; return - E2BIG ; } for ( x = 1 ; x < max_entries && ! last ; x ++ ) { if ( x % ( ZFCP_FC_GPN_FT_ENT_PAGE + 1 ) ) { acc ++ ; } else { acc = sg_virt ( ++ sg ) ; } last = acc -> fp_flags & FC_NS_FID_LAST ; d_id = ntoh24 ( acc -> fp_fid ) ; if ( d_id >= FC_FID_WELL_KNOWN_BASE ) { continue ; } if ( be64_to_cpu ( acc -> fp_wwpn ) == fc_host_port_name ( adapter -> scsi_host ) ) { continue ; } port = zfcp_port_enqueue ( adapter , be64_to_cpu ( acc -> fp_wwpn ) , ZFCP_STATUS_COMMON_NOESC , d_id ) ; if ( ! IS_ERR ( port ) ) { zfcp_erp_port_reopen ( port , 0 , "fcegpf1" ) ; } if ( PTR_ERR ( port ) != - EEXIST ) { ret = PTR_ERR ( port ) ; } } zfcp_erp_wait ( adapter ) ; write_lock_irqsave ( & adapter -> port_list_lock , flags ) ; list_for_each_entry_safe ( , , , ) zfcp_fc_validate_port ( port , & remove_lh ) ; write_unlock_irqrestore ( & adapter -> port_list_lock , flags ) ; list_for_each_entry_safe ( , , , ) { zfcp_erp_port_shutdown ( port , 0 , "fcegpf2" ) ; device_unregister ( & port -> dev ) ; } return ret ; } 