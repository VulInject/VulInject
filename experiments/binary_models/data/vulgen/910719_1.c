static int meson_mx_mmc_probe ( struct platform_device * pdev ) { struct platform_device * slot_pdev ; struct mmc_host * mmc ; struct meson_mx_mmc_host * host ; int ret , irq ; u32 conf ; slot_pdev = meson_mx_mmc_slot_pdev ( & pdev -> dev ) ; if ( ! slot_pdev ) { return - ENODEV ; } if ( IS_ERR ( slot_pdev ) ) { return PTR_ERR ( slot_pdev ) ; } mmc = mmc_alloc_host ( sizeof ( * host ) , & slot_pdev -> dev ) ; if ( ! mmc ) { ret = - ENOMEM ; error_unregister_slot_pdev } host = mmc_priv ( mmc ) ; host -> mmc = mmc ; host -> controller_dev = & pdev -> dev ; timer_setup ( & host -> cmd_timeout , meson_mx_mmc_timeout , 0 ) ; platform_set_drvdata ( pdev , host ) ; host -> base = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( host -> base ) ) { ret = PTR_ERR ( host -> base ) ; error_free_mmc } irq = platform_get_irq ( pdev , 0 ) ; if ( irq < 0 ) { ret = irq ; error_free_mmc } ret = devm_request_threaded_irq ( host -> controller_dev , irq , meson_mx_mmc_irq , meson_mx_mmc_irq_thread , IRQF_ONESHOT , NULL , host ) ; if ( ret ) { error_free_mmc } host -> core_clk = devm_clk_get ( host -> controller_dev , "core" ) ; if ( IS_ERR ( host -> core_clk ) ) { ret = PTR_ERR ( host -> core_clk ) ; error_free_mmc } host -> parent_clk = devm_clk_get ( host -> controller_dev , "clkin" ) ; if ( IS_ERR ( host -> parent_clk ) ) { ret = PTR_ERR ( host -> parent_clk ) ; error_free_mmc } ret = meson_mx_mmc_register_clks ( host ) ; if ( ret ) { error_free_mmc } ret = clk_prepare_enable ( host -> core_clk ) ; if ( ret ) { dev_err ( host -> controller_dev , "Failed to enable core clock\n" ) ; error_free_mmc } ret = clk_prepare_enable ( host -> cfg_div_clk ) ; if ( ret ) { dev_err ( host -> controller_dev , "Failed to enable MMC clock\n" ) ; error_disable_core_clk } conf = 0 ; conf |= FIELD_PREP ( MESON_MX_SDIO_CONF_CMD_ARGUMENT_BITS_MASK , 39 ) ; conf |= FIELD_PREP ( MESON_MX_SDIO_CONF_M_ENDIAN_MASK , 0x3 ) ; conf |= FIELD_PREP ( MESON_MX_SDIO_CONF_WRITE_NWR_MASK , 0x2 ) ; conf |= FIELD_PREP ( MESON_MX_SDIO_CONF_WRITE_CRC_OK_STATUS_MASK , 0x2 ) ; writel ( conf , host -> base + MESON_MX_SDIO_CONF ) ; meson_mx_mmc_soft_reset ( host ) ; ret = meson_mx_mmc_add_host ( host ) ; if ( ret ) { error_disable_clks } return 0 ; error_disable_clks clk_disable_unprepare ( host -> cfg_div_clk ) ; error_disable_core_clk clk_disable_unprepare ( host -> core_clk ) ; error_free_mmc mmc_free_host ( mmc ) ; error_unregister_slot_pdev of_platform_device_destroy ( & slot_pdev -> dev , NULL ) ; return ret ; } 