static void create_cmap ( struct ttf_header * hdr , struct glyph * glyphs , int numGlyphs ) { FILE * cmap = tmpfile ( ) ; struct subtables table ; { int i , j , l , mspos ; int segcnt , delta , rpos ; cmapseg { unsigned short start , end ; unsigned short delta ; unsigned short rangeoff ; } , * cmapseg unsigned short * ranges ; unsigned int * avail = malloc ( 65536 * ( unsigned int ) ) ; memset ( avail , 0xff , 65536 * ( unsigned int ) ) ; for ( i = 0 ; i < numGlyphs ; ++ i ) { if ( glyphs [ i ] . unicode < 0xffff ) { avail [ glyphs [ i ] . unicode ] = glyphs [ i ] . glyph ; } } j = - 1 ; for ( i = segcnt = 0 ; i < 65536 ; ++ i ) { if ( avail [ i ] != 0xffffffff && j == - 1 ) { j = i ; ++ segcnt ; } if ( j != - 1 && avail [ i ] == 0xffffffff ) { j = - 1 ; } } cmapseg = calloc ( segcnt + 1 , sizeof ( cmapseg ) ) ; ranges = malloc ( hdr -> num_chars * sizeof ( short ) ) ; j = - 1 ; for ( i = segcnt = 0 ; i < 65536 ; ++ i ) { if ( avail [ i ] != 0xffffffff && j == - 1 ) { j = i ; cmapseg [ segcnt ] . start = j ; ++ segcnt ; } if ( j != - 1 && avail [ i ] == 0xffffffff ) { cmapseg [ segcnt - 1 ] . end = i - 1 ; j = - 1 ; } } if ( j != - 1 ) { cmapseg [ segcnt - 1 ] . end = i - 1 ; } cmapseg [ segcnt ] . start = cmapseg [ segcnt ] . end = 0xffff ; cmapseg [ segcnt ++ ] . delta = 1 ; rpos = 0 ; for ( i = 0 ; i < segcnt - 1 ; ++ i ) { l = avail [ cmapseg [ i ] . start ] ; delta = l - cmapseg [ i ] . start ; for ( j = cmapseg [ i ] . start ; j <= cmapseg [ i ] . end ; ++ j ) { l = avail [ j ] ; if ( delta != l - j ) { break ; } } if ( j > cmapseg [ i ] . end ) { cmapseg [ i ] . delta = delta ; } else { cmapseg [ i ] . rangeoff = ( rpos + ( segcnt - i ) ) * sizeof ( short ) ; for ( j = cmapseg [ i ] . start ; j <= cmapseg [ i ] . end ; ++ j ) { l = avail [ j ] ; ranges [ rpos ++ ] = l ; } } } free ( avail ) ; putshort ( cmap , 0 ) ; putshort ( cmap , 2 ) ; mspos = 2 * ( unsigned short ) + 2 * ( 2 * ( unsigned short ) + ( unsigned int ) ) ; putshort ( cmap , 0 ) ; putshort ( cmap , 3 ) ; putlong ( cmap , mspos ) ; putshort ( cmap , 3 ) ; putshort ( cmap , 1 ) ; putlong ( cmap , mspos ) ; putshort ( cmap , 4 ) ; putshort ( cmap , ( 8 + 4 * segcnt + rpos ) * sizeof ( short ) ) ; putshort ( cmap , 0 ) ; putshort ( cmap , 2 * segcnt ) ; for ( j = 0 , i = 1 ; i <= segcnt ; i <<= 1 , ++ j ) { } putshort ( cmap , i ) ; putshort ( cmap , j - 1 ) ; putshort ( cmap , 2 * segcnt - i ) ; for ( i = 0 ; i < segcnt ; ++ i ) { putshort ( cmap , cmapseg [ i ] . end ) ; } putshort ( cmap , 0 ) ; for ( i = 0 ; i < segcnt ; ++ i ) { putshort ( cmap , cmapseg [ i ] . start ) ; } for ( i = 0 ; i < segcnt ; ++ i ) { putshort ( cmap , cmapseg [ i ] . delta ) ; } for ( i = 0 ; i < segcnt ; ++ i ) { putshort ( cmap , cmapseg [ i ] . rangeoff ) ; } for ( i = 0 ; i < rpos ; ++ i ) { putshort ( cmap , ranges [ i ] ) ; } free ( ranges ) ; free ( cmapseg ) ; } table . len = ftell ( cmap ) ; table . offset = 0 ; table . tag = CHR ( 'c' , 'm' , 'a' , 'p' ) ; table . file = cmap ; table . closeme = true ; AddTable ( hdr , & table ) ; } 