static int nfcmrvl_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct nfcmrvl_usb_drv_data * drv_data ; struct nfcmrvl_private * priv ; int i ; struct usb_device * udev = interface_to_usbdev ( intf ) ; struct nfcmrvl_platform_data config ; memset ( & config , 0 , sizeof ( config ) ) ; config . reset_n_io = - EINVAL ; nfc_info ( & udev -> dev , "intf %p id %p\n" , intf , id ) ; drv_data = devm_kzalloc ( & intf -> dev , sizeof ( * drv_data ) , GFP_KERNEL ) ; if ( ! drv_data ) { return - ENOMEM ; } for ( i = 0 ; i < intf -> cur_altsetting -> desc . bNumEndpoints ; i ++ ) { struct usb_endpoint_descriptor * ep_desc ; ep_desc = & intf -> cur_altsetting -> endpoint [ i ] . desc ; if ( ! drv_data -> bulk_tx_ep && usb_endpoint_is_bulk_out ( ep_desc ) ) { drv_data -> bulk_tx_ep = ep_desc ; } if ( ! drv_data -> bulk_rx_ep && usb_endpoint_is_bulk_in ( ep_desc ) ) { drv_data -> bulk_rx_ep = ep_desc ; } } if ( ! drv_data -> bulk_tx_ep || ! drv_data -> bulk_rx_ep ) { return - ENODEV ; } drv_data -> udev = udev ; drv_data -> intf = intf ; INIT_WORK ( & drv_data -> waker , nfcmrvl_waker ) ; init_usb_anchor ( & drv_data -> tx_anchor ) ; init_usb_anchor ( & drv_data -> bulk_anchor ) ; init_usb_anchor ( & drv_data -> deferred ) ; priv = nfcmrvl_nci_register_dev ( NFCMRVL_PHY_USB , drv_data , & usb_ops , & intf -> dev , & config ) ; if ( IS_ERR ( priv ) ) { return PTR_ERR ( priv ) ; } drv_data -> priv = priv ; drv_data -> priv -> support_fw_dnld = false ; usb_set_intfdata ( intf , drv_data ) ; return 0 ; } 