extern list_t * license_validate ( char * licenses , bool validate_configured , bool validate_existing , uint64_t * tres_req_cnt , bool * valid ) { list_itr_t * iter ; licenses_t * license_entry , * match ; list_t * job_license_list ; static bool first_run = 1 ; static slurmdb_tres_rec_t tres_req ; int tres_pos ; if ( tres_req_cnt ) { assoc_mgr_lock_t locks = { . tres = READ_LOCK } ; assoc_mgr_lock ( & locks ) ; for ( tres_pos = TRES_ARRAY_TOTAL_CNT ; tres_pos < slurmctld_tres_cnt ; tres_pos ++ ) { if ( tres_req_cnt [ tres_pos ] && ! xstrcasecmp ( assoc_mgr_tres_array [ tres_pos ] -> type , "license" ) ) { tres_req_cnt [ tres_pos ] = 0 ; } } assoc_mgr_unlock ( & locks ) ; } job_license_list = _build_license_list ( licenses , valid ) ; if ( ! job_license_list ) { return job_license_list ; } if ( first_run ) { first_run = 0 ; tres_req . type = "license" ; } slurm_mutex_lock ( & license_mutex ) ; _licenses_print ( "request_license" , job_license_list , NULL ) ; iter = list_iterator_create ( job_license_list ) ; while ( ( license_entry = list_next ( iter ) ) ) { if ( cluster_license_list ) { match = list_find_first ( cluster_license_list , _license_find_rec , license_entry -> name ) ; } else { match = NULL ; } if ( ! match ) { debug ( "License name requested (%s) does not exist" , license_entry -> name ) ; if ( ! validate_existing ) { list_delete_item ( iter ) ; continue ; } * valid = false ; break ; } if ( validate_configured && ( license_entry -> total > match -> total ) ) { debug ( "Licenses count requested higher than configured " "(%s: %u>%u)" , match -> name , license_entry -> total , match -> total ) ; * valid = false ; break ; } if ( tres_req_cnt ) { tres_req . name = license_entry -> name ; if ( ( tres_pos = assoc_mgr_find_tres_pos ( & tres_req , false ) ) != - 1 ) { tres_req_cnt [ tres_pos ] = ( uint64_t ) license_entry -> total ; } } } list_iterator_destroy ( iter ) ; slurm_mutex_unlock ( & license_mutex ) ; if ( ! ( * valid ) ) { FREE_NULL_LIST ( job_license_list ) ; } return job_license_list ; } 