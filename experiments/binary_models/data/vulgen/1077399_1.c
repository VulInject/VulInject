static void zfcp_fsf_status_read_handler ( struct zfcp_fsf_req * req ) { struct zfcp_adapter * adapter = req -> adapter ; struct fsf_status_read_buffer * sr_buf = req -> data ; if ( req -> status & ZFCP_STATUS_FSFREQ_DISMISSED ) { zfcp_dbf_hba_fsf_uss ( "fssrh_1" , req ) ; mempool_free ( virt_to_page ( sr_buf ) , adapter -> pool . sr_data ) ; zfcp_fsf_req_free ( req ) ; return ; } zfcp_dbf_hba_fsf_uss ( "fssrh_4" , req ) ; switch ( sr_buf -> status_type ) { case FSF_STATUS_READ_PORT_CLOSED : zfcp_fsf_status_read_port_closed ( req ) ; break ; case FSF_STATUS_READ_INCOMING_ELS : zfcp_fc_incoming_els ( req ) ; break ; case FSF_STATUS_READ_SENSE_DATA_AVAIL : break ; case FSF_STATUS_READ_BIT_ERROR_THRESHOLD : dev_warn ( & adapter -> ccw_device -> dev , "The error threshold for checksum statistics " "has been exceeded\n" ) ; zfcp_dbf_hba_bit_err ( "fssrh_3" , req ) ; break ; case FSF_STATUS_READ_LINK_DOWN : zfcp_fsf_status_read_link_down ( req ) ; zfcp_fc_enqueue_event ( adapter , FCH_EVT_LINKDOWN , 0 ) ; break ; case FSF_STATUS_READ_LINK_UP : dev_info ( & adapter -> ccw_device -> dev , "The local link has been restored\n" ) ; zfcp_erp_set_adapter_status ( adapter , ZFCP_STATUS_COMMON_RUNNING ) ; zfcp_erp_adapter_reopen ( adapter , ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED | ZFCP_STATUS_COMMON_ERP_FAILED , "fssrh_2" ) ; zfcp_fc_enqueue_event ( adapter , FCH_EVT_LINKUP , 0 ) ; break ; case FSF_STATUS_READ_NOTIFICATION_LOST : break ; case FSF_STATUS_READ_FEATURE_UPDATE_ALERT : adapter -> adapter_features = sr_buf -> payload . word [ 0 ] ; break ; } mempool_free ( virt_to_page ( sr_buf ) , adapter -> pool . sr_data ) ; zfcp_fsf_req_free ( req ) ; atomic_inc ( & adapter -> stat_miss ) ; queue_work ( adapter -> work_queue , & adapter -> stat_work ) ; } 