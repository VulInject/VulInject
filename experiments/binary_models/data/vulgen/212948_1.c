notification_t parse_ipsec_sa_body ( pb_stream * sa_pbs , const struct isakmp_sa * sa , pb_stream * r_sa_pbs , bool selection , struct state * st ) { const struct connection * c = st -> st_connection ; u_int32_t ipsecdoisit ; pb_stream next_proposal_pbs ; struct db_sa * p2alg ; struct isakmp_proposal next_proposal ; ipsec_spi_t next_spi ; bool next_full = TRUE ; if ( sa -> isasa_doi != ISAKMP_DOI_IPSEC ) { loglog ( RC_LOG_SERIOUS , "Unknown or unsupported DOI %s" , enum_show ( & doi_names , sa -> isasa_doi ) ) ; return DOI_NOT_SUPPORTED ; } if ( ipsecdoisit != SIT_IDENTITY_ONLY ) { loglog ( RC_LOG_SERIOUS , "unsupported IPsec DOI situation (%s)" , bitnamesof ( sit_bit_names , ipsecdoisit ) ) ; return SITUATION_NOT_SUPPORTED ; } if ( ! in_struct ( & next_proposal , & isakmp_proposal_desc , sa_pbs , & next_proposal_pbs ) ) { return BAD_PROPOSAL_SYNTAX ; } p2alg = alginfo2child_db2 ( c -> alg_info_esp ) ; while ( next_full ) { int propno = next_proposal . isap_proposal ; pb_stream esp_prop_pbs , ipcomp_prop_pbs ; struct isakmp_proposal ah_proposal , esp_proposal , ipcomp_proposal ; pb_stream ah_prop_pbs ; ipsec_spi_t ah_spi = 0 ; ipsec_spi_t esp_spi , ipcomp_cpi ; bool ah_seen = FALSE , esp_seen = FALSE , ipcomp_seen = FALSE ; int inner_proto = 0 ; bool tunnel_mode = FALSE ; u_int16_t well_known_cpi = 0 ; pb_stream ah_trans_pbs , esp_trans_pbs , ipcomp_trans_pbs ; struct isakmp_transform ah_trans , esp_trans , ipcomp_trans ; struct ipsec_trans_attrs ah_attrs , esp_attrs , ipcomp_attrs ; ipcomp_cpi = 0 ; esp_spi = 0 ; memset ( & ah_proposal , 0 , sizeof ( ah_proposal ) ) ; memset ( & esp_proposal , 0 , sizeof ( esp_proposal ) ) ; memset ( & ipcomp_proposal , 0 , sizeof ( ipcomp_proposal ) ) ; { if ( next_proposal . isap_protoid == PROTO_IPCOMP ) { if ( next_proposal . isap_spisize == IPSEC_DOI_SPI_SIZE ) { u_int8_t filler [ IPSEC_DOI_SPI_SIZE - IPCOMP_CPI_SIZE ] ; if ( ! in_raw ( filler , sizeof ( filler ) , & next_proposal_pbs , "CPI filler" ) || ! all_zero ( filler , sizeof ( filler ) ) ) { return INVALID_SPI ; } } if ( next_proposal . isap_spisize != IPCOMP_CPI_SIZE ) { loglog ( RC_LOG_SERIOUS , "IPsec Proposal with improper CPI size (%u)" , next_proposal . isap_spisize ) ; return INVALID_SPI ; } zero ( & next_spi ) ; if ( ! in_raw ( ( u_char * ) & next_spi + IPSEC_DOI_SPI_SIZE - IPCOMP_CPI_SIZE , IPCOMP_CPI_SIZE , & next_proposal_pbs , "CPI" ) ) { return INVALID_SPI ; } switch ( ntohl ( next_spi ) ) { case IPCOMP_DEFLATE : well_known_cpi = ntohl ( next_spi ) ; next_spi = uniquify_his_cpi ( next_spi , st ) ; if ( next_spi == 0 ) { loglog ( RC_LOG_SERIOUS , "IPsec Proposal contains well-known CPI that I cannot uniquify" ) ; return INVALID_SPI ; } break ; default : if ( ntohl ( next_spi ) < IPCOMP_FIRST_NEGOTIATED || ntohl ( next_spi ) > IPCOMP_LAST_NEGOTIATED ) { loglog ( RC_LOG_SERIOUS , "IPsec Proposal contains CPI from non-negotiated range (0x%lx)" , ( unsigned long ) ntohl ( next_spi ) ) ; return INVALID_SPI ; } break ; } } else { if ( next_proposal . isap_spisize != IPSEC_DOI_SPI_SIZE ) { loglog ( RC_LOG_SERIOUS , "IPsec Proposal with improper SPI size (%u)" , next_proposal . isap_spisize ) ; return INVALID_SPI ; } if ( ! in_raw ( ( u_char * ) & next_spi , sizeof ( next_spi ) , & next_proposal_pbs , "SPI" ) ) { return INVALID_SPI ; } if ( ntohl ( next_spi ) < IPSEC_DOI_SPI_MIN ) { loglog ( RC_LOG_SERIOUS , "IPsec Proposal contains invalid SPI (0x%lx)" , ( unsigned long ) ntohl ( next_spi ) ) ; return INVALID_SPI ; } } if ( next_proposal . isap_notrans == 0 ) { loglog ( RC_LOG_SERIOUS , "IPsec Proposal contains no Transforms (skipped)" ) ; continue ; } switch ( next_proposal . isap_protoid ) { case PROTO_IPSEC_AH : if ( ah_seen ) { loglog ( RC_LOG_SERIOUS , "IPsec SA contains two simultaneous AH Proposals" ) ; return BAD_PROPOSAL_SYNTAX ; } ah_seen = TRUE ; ah_prop_pbs = next_proposal_pbs ; ah_proposal = next_proposal ; ah_spi = next_spi ; break ; case PROTO_IPSEC_ESP : if ( esp_seen ) { loglog ( RC_LOG_SERIOUS , "IPsec SA contains two simultaneous ESP Proposals" ) ; return BAD_PROPOSAL_SYNTAX ; } esp_seen = TRUE ; esp_prop_pbs = next_proposal_pbs ; esp_proposal = next_proposal ; esp_spi = next_spi ; break ; case PROTO_IPCOMP : if ( ipcomp_seen ) { loglog ( RC_LOG_SERIOUS , "IPsec SA contains two simultaneous IPCOMP Proposals" ) ; return BAD_PROPOSAL_SYNTAX ; } ipcomp_seen = TRUE ; ipcomp_prop_pbs = next_proposal_pbs ; ipcomp_proposal = next_proposal ; ipcomp_cpi = next_spi ; break ; default : loglog ( RC_LOG_SERIOUS , "unexpected Protocol ID (%s) in IPsec Proposal" , enum_show ( & protocol_names , next_proposal . isap_protoid ) ) ; return INVALID_PROTOCOL_ID ; } if ( next_proposal . isap_np == ISAKMP_NEXT_NONE ) { next_full = FALSE ; break ; } if ( next_proposal . isap_np != ISAKMP_NEXT_P ) { loglog ( RC_LOG_SERIOUS , "unexpected in Proposal: %s" , enum_show ( & payload_names , next_proposal . isap_np ) ) ; return BAD_PROPOSAL_SYNTAX ; } if ( ! in_struct ( & next_proposal , & isakmp_proposal_desc , sa_pbs , & next_proposal_pbs ) ) { return BAD_PROPOSAL_SYNTAX ; } } next_proposal . isap_proposal == propno ; if ( ah_seen ) { int previous_transnum = - 1 ; int tn ; for ( tn = 0 ; tn != ah_proposal . isap_notrans ; tn ++ ) { int ok_transid = 0 ; bool ok_auth = FALSE ; if ( ! parse_ipsec_transform ( & ah_trans , & ah_attrs , & ah_prop_pbs , & ah_trans_pbs , & isakmp_ah_transform_desc , previous_transnum , selection , tn == ah_proposal . isap_notrans - 1 , FALSE , st ) ) { return BAD_PROPOSAL_SYNTAX ; } previous_transnum = ah_trans . isat_transnum ; switch ( ah_attrs . transattrs . integ_hash ) { AA XXXX ; case AUTH_ALGORITHM_NONE : loglog ( RC_LOG_SERIOUS , "AUTH_ALGORITHM attribute missing in AH Transform" ) ; return BAD_PROPOSAL_SYNTAX ; case AUTH_ALGORITHM_HMAC_MD5 : ok_auth = TRUE ; case AUTH_ALGORITHM_KPDK : ok_transid = AH_MD5 ; break ; case AUTH_ALGORITHM_HMAC_SHA1 : ok_auth = TRUE ; ok_transid = AH_SHA ; break ; case AUTH_ALGORITHM_DES_MAC : ok_transid = AH_DES ; break ; } if ( ah_attrs . transattrs . encrypt != ok_transid ) { loglog ( RC_LOG_SERIOUS , "%s attribute inappropriate in %s Transform" , enum_name ( & auth_alg_names , ah_attrs . transattrs . integ_hash ) , enum_show ( & ah_transformid_names , ah_attrs . transattrs . encrypt ) ) ; return BAD_PROPOSAL_SYNTAX ; } if ( ! ok_auth ) { DBG ( DBG_CONTROL | DBG_CRYPT , DBG_log ( "%s attribute unsupported" " in %s Transform from %s" , enum_name ( & auth_alg_names , ah_attrs . transattrs . integ_hash ) , enum_show ( & ah_transformid_names , ah_attrs . transattrs . encrypt ) , ip_str ( & c -> spd . that . host_addr ) ) ) ; continue ; } break ; } if ( tn == ah_proposal . isap_notrans ) { continue ; } ah_attrs . spi = ah_spi ; inner_proto = IPPROTO_AH ; if ( ah_attrs . encapsulation == ENCAPSULATION_MODE_TUNNEL ) { tunnel_mode = TRUE ; } loglog ( RC_LOG_SERIOUS , "AH in IKEv1 mode is not supported. Proposal rejected" ) ; continue ; } if ( esp_seen ) { int previous_transnum = - 1 ; int tn ; err_t ugh ; for ( tn = 0 ; tn != esp_proposal . isap_notrans ; tn ++ ) { if ( ! parse_ipsec_transform ( & esp_trans , & esp_attrs , & esp_prop_pbs , & esp_trans_pbs , & isakmp_esp_transform_desc , previous_transnum , selection , tn == esp_proposal . isap_notrans - 1 , FALSE , st ) ) { return BAD_PROPOSAL_SYNTAX ; } previous_transnum = esp_trans . isat_transnum ; ugh = kernel_alg_esp_enc_ok ( esp_attrs . transattrs . encrypt , esp_attrs . transattrs . enckeylen , c -> alg_info_esp ) ; if ( ugh != NULL ) { loglog ( RC_LOG_SERIOUS , "proposal refused due to: %s" , ugh ) ; loglog ( RC_LOG_SERIOUS , "unsupported ESP Transform %s from %s" , enum_show ( & esp_transformid_names , esp_attrs . transattrs . encrypt ) , ip_str ( & c -> spd . that . host_addr ) ) ; continue ; } if ( ! ESP_AALG_PRESENT ( esp_attrs . transattrs . integ_hash ) ) { loglog ( RC_LOG_SERIOUS , "unsupported ESP auth alg %s from %s" , enum_show ( & trans_type_integ_names , esp_attrs . transattrs . integ_hash ) , ip_str ( & c -> spd . that . host_addr ) ) ; continue ; } break ; } if ( tn == esp_proposal . isap_notrans ) { continue ; } esp_attrs . spi = esp_spi ; inner_proto = IPPROTO_ESP ; if ( esp_attrs . encapsulation == ENCAPSULATION_MODE_TUNNEL ) { tunnel_mode = TRUE ; } } if ( st -> st_policy & POLICY_ENCRYPT ) { DBG ( DBG_CONTROL | DBG_CRYPT , DBG_log ( "policy for \"%s\" requires encryption but ESP not in Proposal from %s" , c -> name , ip_str ( & c -> spd . that . host_addr ) ) ) ; continue ; } if ( ( st -> st_policy & POLICY_AUTHENTICATE ) && ! ah_seen ) { DBG ( DBG_CONTROL | DBG_CRYPT , DBG_log ( "policy for \"%s\" requires authentication" " but none in Proposal from %s" , c -> name , ip_str ( & c -> spd . that . host_addr ) ) ) ; continue ; } if ( ipcomp_seen ) { int previous_transnum = - 1 ; int tn ; if ( ! ( st -> st_policy & POLICY_COMPRESS ) ) { plog ( "compression proposed by %s, but policy for \"%s\" forbids it" , ip_str ( & c -> spd . that . host_addr ) , c -> name ) ; continue ; } if ( ! can_do_IPcomp ) { openswan_log ( "compression proposed by %s, but KLIPS is not configured with IPCOMP" , ip_str ( & c -> spd . that . host_addr ) ) ; continue ; } if ( well_known_cpi != 0 && ! ah_seen && ! esp_seen ) { openswan_log ( "illegal proposal: bare IPCOMP used with well-known CPI" ) ; return BAD_PROPOSAL_SYNTAX ; } for ( tn = 0 ; tn != ipcomp_proposal . isap_notrans ; tn ++ ) { if ( ! parse_ipsec_transform ( & ipcomp_trans , & ipcomp_attrs , & ipcomp_prop_pbs , & ipcomp_trans_pbs , & isakmp_ipcomp_transform_desc , previous_transnum , selection , tn == ipcomp_proposal . isap_notrans - 1 , TRUE , st ) ) { return BAD_PROPOSAL_SYNTAX ; } previous_transnum = ipcomp_trans . isat_transnum ; if ( well_known_cpi != 0 && ipcomp_attrs . transattrs . encrypt != well_known_cpi ) { openswan_log ( "illegal proposal: IPCOMP well-known CPI disagrees with transform" ) ; return BAD_PROPOSAL_SYNTAX ; } switch ( ipcomp_attrs . transattrs . encrypt ) { case IPCOMP_DEFLATE : break ; default : DBG ( DBG_CONTROL | DBG_CRYPT , DBG_log ( "unsupported IPCOMP Transform %s from %s" , enum_show ( & ipcomp_transformid_names , ipcomp_attrs . transattrs . encrypt ) , ip_str ( & c -> spd . that . host_addr ) ) ) ; continue ; } if ( ah_seen && ah_attrs . encapsulation != ipcomp_attrs . encapsulation ) { DBG ( DBG_CONTROL | DBG_CRYPT , DBG_log ( "AH and IPCOMP transforms disagree about encapsulation; TUNNEL presumed" ) ) ; } if ( esp_seen && esp_attrs . encapsulation != ipcomp_attrs . encapsulation ) { DBG ( DBG_CONTROL | DBG_CRYPT , DBG_log ( "ESP and IPCOMP transforms disagree about encapsulation; TUNNEL presumed" ) ) ; } break ; } if ( tn == ipcomp_proposal . isap_notrans ) { continue ; } ipcomp_attrs . spi = ipcomp_cpi ; inner_proto = IPPROTO_COMP ; if ( ipcomp_attrs . encapsulation == ENCAPSULATION_MODE_TUNNEL ) { tunnel_mode = TRUE ; } } if ( ! spdb_v2_match_child ( p2alg , propno , esp_attrs . transattrs . encrypt , esp_attrs . transattrs . enckeylen , esp_attrs . transattrs . integ_hash , esp_attrs . transattrs . esn ) ) { continue ; } if ( r_sa_pbs != NULL ) { if ( ! out_struct ( & ipsecdoisit , & ipsec_sit_desc , r_sa_pbs , NULL ) ) { impossible ( ) ; } if ( ah_seen ) { echo_proposal ( st , ah_proposal , ah_trans , esp_seen || ipcomp_seen ?ISAKMP_NEXT_P : ISAKMP_NEXT_NONE , r_sa_pbs , & st -> st_ah , & isakmp_ah_transform_desc , & ah_trans_pbs , tunnel_mode && inner_proto == IPPROTO_AH ) ; } if ( esp_seen ) { echo_proposal ( st , esp_proposal , esp_trans , ipcomp_seen ?ISAKMP_NEXT_P : ISAKMP_NEXT_NONE , r_sa_pbs , & st -> st_esp , & isakmp_esp_transform_desc , & esp_trans_pbs , tunnel_mode && inner_proto == IPPROTO_ESP ) ; } if ( ipcomp_seen ) { echo_proposal ( st , ipcomp_proposal , ipcomp_trans , ISAKMP_NEXT_NONE , r_sa_pbs , & st -> st_ipcomp , & isakmp_ipcomp_transform_desc , & ipcomp_trans_pbs , tunnel_mode && inner_proto == IPPROTO_COMP ) ; } } if ( r_sa_pbs != NULL ) { close_output_pbs ( r_sa_pbs ) ; } st -> st_ah . present = ah_seen ; if ( ah_seen ) { st -> st_ah . attrs = ah_attrs ; } st -> st_esp . present = esp_seen ; if ( esp_seen ) { st -> st_esp . attrs = esp_attrs ; } st -> st_ipcomp . present = ipcomp_seen ; if ( ipcomp_seen ) { st -> st_ipcomp . attrs = ipcomp_attrs ; } return NOTHING_WRONG ; } loglog ( RC_LOG_SERIOUS , "no acceptable Proposal in IPsec SA" ) ; return NO_PROPOSAL_CHOSEN ; } 