int __init e820__update_table ( struct e820_table * table ) { struct e820_entry * entries = table -> entries ; u32 max_nr_entries = ARRAY_SIZE ( table -> entries ) ; enum e820_type current_type , last_type ; unsigned long long last_addr ; u32 new_nr_entries , overlap_entries ; u32 i , chg_idx , chg_nr ; BUG_ON ( table -> nr_entries > max_nr_entries ) ; for ( i = 0 ; i < table -> nr_entries ; i ++ ) { if ( entries [ i ] . addr + entries [ i ] . size < entries [ i ] . addr ) { return - 1 ; } } for ( i = 0 ; i < 2 * table -> nr_entries ; i ++ ) { change_point [ i ] = & change_point_list [ i ] ; } chg_idx = 0 ; for ( i = 0 ; i < table -> nr_entries ; i ++ ) { if ( entries [ i ] . size != 0 ) { change_point [ chg_idx ] -> addr = entries [ i ] . addr ; change_point [ chg_idx ++ ] -> entry = & entries [ i ] ; change_point [ chg_idx ] -> addr = entries [ i ] . addr + entries [ i ] . size ; change_point [ chg_idx ++ ] -> entry = & entries [ i ] ; } } chg_nr = chg_idx ; sort ( change_point , chg_nr , sizeof ( * change_point ) , cpcompare , NULL ) ; overlap_entries = 0 ; new_nr_entries = 0 ; last_type = 0 ; last_addr = 0 ; for ( chg_idx = 0 ; chg_idx < chg_nr ; chg_idx ++ ) { if ( change_point [ chg_idx ] -> addr == change_point [ chg_idx ] -> entry -> addr ) { overlap_list [ overlap_entries ++ ] = change_point [ chg_idx ] -> entry ; } else { for ( i = 0 ; i < overlap_entries ; i ++ ) { if ( overlap_list [ i ] == change_point [ chg_idx ] -> entry ) { overlap_list [ i ] = overlap_list [ overlap_entries - 1 ] ; } } overlap_entries -- ; } current_type = 0 ; for ( i = 0 ; i < overlap_entries ; i ++ ) { if ( overlap_list [ i ] -> type > current_type ) { current_type = overlap_list [ i ] -> type ; } } if ( current_type != last_type || current_type == E820_TYPE_PRAM ) { if ( last_type != 0 ) { new_entries [ new_nr_entries ] . size = change_point [ chg_idx ] -> addr - last_addr ; if ( new_entries [ new_nr_entries ] . size != 0 ) { if ( ++ new_nr_entries >= max_nr_entries ) { break ; } } } if ( current_type != 0 ) { new_entries [ new_nr_entries ] . addr = change_point [ chg_idx ] -> addr ; new_entries [ new_nr_entries ] . type = current_type ; last_addr = change_point [ chg_idx ] -> addr ; } last_type = current_type ; } } memcpy ( entries , new_entries , new_nr_entries * sizeof ( * entries ) ) ; table -> nr_entries = new_nr_entries ; return 0 ; } 