if ( COLOR2WHITE ( col ) ) { return ( & white ) ; } else { return ( & black ) ; } ( rev -> is_grey ) { val = COLOR2GREY ( col ) return ( & rev -> greys [ val ] ) ; } ; reverse_clut r = COLOR_RED ( col ) ; g = COLOR_GREEN ( col ) ; b = COLOR_BLUE ( col ) ; if ( rev -> div_mul == 1 ) { val = r >> rev -> div_shift ; val = ( val << rev -> side_shift ) + ( g >> rev -> div_shift ) ; val = ( val << rev -> side_shift ) + ( b >> rev -> div_shift ) ; } else { val = ( ( r + rev -> div_add ) * rev -> div_mul ) >> rev -> div_shift ; t = ( ( g + rev -> div_add ) * rev -> div_mul ) >> rev -> div_shift ; val = ( val * rev -> side_cnt ) + t ; t = ( ( b + rev -> div_add ) * rev -> div_mul ) >> rev -> div_shift ; val = ( val * rev -> side_cnt ) + t ; } this = & rev -> cube [ val ] ; if ( this -> sub != NULL ) { col &= rev -> mask ; rev = this -> sub ; reverse_clut } test = this -> cols [ 0 ] ; if ( test -> next == NULL ) { return ( ( GCol * ) test ) ; } if ( ( best = ( r - test -> red ) ) < 0 ) { best = - best ; } if ( ( t = ( g - test -> green ) ) < 0 ) { t = - t ; } best += t ; if ( ( t = ( b - test -> blue ) ) < 0 ) { t = - t ; } best += t ; bestcol = test ; for ( test = test -> next ; test != NULL ; test = test -> next ) { if ( ( val = ( r - test -> red ) ) < 0 ) { val = - val ; } if ( ( t = ( g - test -> green ) ) < 0 ) { t = - t ; } val += t ; if ( ( t = ( b - test -> blue ) ) < 0 ) { t = - t ; } val += t ; } return ( ( GCol * ) bestcol ) ; 