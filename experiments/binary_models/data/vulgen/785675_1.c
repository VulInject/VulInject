static descriptor_t * * get_fixed_assocs ( descriptor_t * desc , int * errp ) { int fd ; int status ; int data_format = FMT_UNKNOWN ; int cnt ; struct extvtoc vtoc ; struct dk_gpt * efip ; int pos ; slice_t * devp ; descriptor_t * * slices ; if ( ( fd = drive_open_disk ( desc -> p . disk , NULL , 0 ) ) < 0 ) { * errp = ENODEV ; return ( NULL ) ; } if ( ( status = read_extvtoc ( fd , & vtoc ) ) >= 0 ) { data_format = FMT_VTOC ; } if ( status == VT_ENOTSUP && efi_alloc_and_read ( fd , & efip ) >= 0 ) { data_format = FMT_EFI ; } else { ( void ) close ( fd ) ; * errp = 0 ; return ( libdiskmgt_empty_desc_array ( errp ) ) ; } ( void ) close ( fd ) ; devp = desc -> p . disk -> aliases -> devpaths ; for ( cnt = 0 ; devp != NULL ; devp = devp -> next ) { cnt ++ ; } slices = ( descriptor_t * * ) calloc ( cnt + 1 , sizeof ( descriptor_t * ) ) ; if ( slices == NULL ) { if ( data_format == FMT_EFI ) { efi_free ( efip ) ; } * errp = ENOMEM ; return ( NULL ) ; } if ( desc -> type == DM_MEDIA ) { media_name = desc -> name ; } else { media_name = desc -> secondary_name ; } pos = 0 ; for ( devp = desc -> p . disk -> aliases -> devpaths ; devp != NULL ; devp = devp -> next ) { int slice_num ; char devpath [ MAXPATHLEN ] ; slice_num = get_slice_num ( devp ) ; if ( slice_num == - 1 ) { break ; } if ( data_format == FMT_VTOC ) { if ( slice_num >= vtoc . v_nparts || vtoc . v_part [ slice_num ] . p_size == 0 ) { continue ; } } else { if ( slice_num >= efip -> efi_nparts || efip -> efi_parts [ slice_num ] . p_size == 0 ) { continue ; } } slice_rdsk2dsk ( devp -> devpath , devpath , sizeof ( devpath ) ) ; slices [ pos ] = cache_get_desc ( DM_SLICE , desc -> p . disk , devpath , media_name , errp ) ; if ( * errp != 0 ) { cache_free_descriptors ( slices ) ; if ( data_format == FMT_EFI ) { efi_free ( efip ) ; } return ( NULL ) ; } pos ++ ; } slices [ pos ] = NULL ; if ( data_format == FMT_EFI ) { efi_free ( efip ) ; } * errp = 0 ; return ( slices ) ; } 