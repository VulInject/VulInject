static void populate_lsave ( struct ubifs_info * c ) { struct ubifs_lprops * lprops ; struct ubifs_lpt_heap * heap ; int i , cnt = 0 ; ubifs_assert ( c -> big_lpt ) ; if ( ! ( c -> lpt_drty_flgs & LSAVE_DIRTY ) ) { c -> lpt_drty_flgs |= LSAVE_DIRTY ; ubifs_add_lpt_dirt ( c , c -> lsave_lnum , c -> lsave_sz ) ; } list_for_each_entry ( , , ) { c -> lsave [ cnt ++ ] = lprops -> lnum ; if ( cnt >= c -> lsave_cnt ) { return ; } } list_for_each_entry ( , , ) { c -> lsave [ cnt ++ ] = lprops -> lnum ; if ( cnt >= c -> lsave_cnt ) { return ; } } list_for_each_entry ( , , ) { c -> lsave [ cnt ++ ] = lprops -> lnum ; if ( cnt >= c -> lsave_cnt ) { return ; } } heap = & c -> lpt_heap [ LPROPS_DIRTY_IDX - 1 ] ; for ( i = 0 ; i < heap -> cnt ; i ++ ) { c -> lsave [ cnt ++ ] = heap -> arr [ i ] -> lnum ; if ( cnt >= c -> lsave_cnt ) { return ; } } heap = & c -> lpt_heap [ LPROPS_DIRTY - 1 ] ; for ( i = 0 ; i < heap -> cnt ; i ++ ) { c -> lsave [ cnt ++ ] = heap -> arr [ i ] -> lnum ; if ( cnt >= c -> lsave_cnt ) { return ; } } heap = & c -> lpt_heap [ LPROPS_FREE - 1 ] ; for ( i = 0 ; i < heap -> cnt ; i ++ ) { c -> lsave [ cnt ++ ] = heap -> arr [ i ] -> lnum ; if ( cnt >= c -> lsave_cnt ) { return ; } } while ( cnt < c -> lsave_cnt ) { c -> lsave [ cnt ++ ] = c -> main_first ; } } 