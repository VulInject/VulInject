static SRP_RESULT srp6_sha512_client_key_ex ( SRP * srp , cstr * * result , const unsigned char * pubkey , int pubkeylen , BigInteger k ) { SHA512_CTX ctxt ; unsigned char dig [ SHA512_DIGESTSIZE ] ; BigInteger gb , e ; cstr * s ; int modlen ; modlen = BigIntegerByteLen ( srp -> modulus ) ; if ( pubkeylen > modlen ) { return SRP_ERROR ; } SHA512Init ( & ctxt ) ; s = cstr_new ( ) ; if ( srp -> flags & SRP_FLAG_LEFT_PAD ) { BigIntegerToCstrEx ( srp -> pubkey , s , modlen ) ; SHA512Update ( & ctxt , s -> data , s -> length ) ; if ( pubkeylen < modlen ) { memcpy ( s -> data + ( modlen - pubkeylen ) , pubkey , pubkeylen ) ; memset ( s -> data , 0 , modlen - pubkeylen ) ; SHA512Update ( & ctxt , s -> data , modlen ) ; } else { SHA512Update ( & ctxt , pubkey , pubkeylen ) ; } } else { BigIntegerToCstr ( srp -> pubkey , s ) ; SHA512Update ( & ctxt , s -> data , s -> length ) ; SHA512Update ( & ctxt , pubkey , pubkeylen ) ; } SHA512Final ( dig , & ctxt ) ; srp -> u = BigIntegerFromBytes ( dig , SHA512_DIGESTSIZE ) ; SHA512Update ( & SHA512_CLIENT_CTXP ( srp ) -> hash , pubkey , pubkeylen ) ; gb = BigIntegerFromBytes ( pubkey , pubkeylen ) ; if ( BigIntegerCmp ( gb , srp -> modulus ) >= 0 || BigIntegerCmpInt ( gb , 0 ) == 0 ) { BigIntegerFree ( gb ) ; return SRP_ERROR ; } e = BigIntegerFromInt ( 0 ) ; srp -> key = BigIntegerFromInt ( 0 ) ; BigIntegerSub ( srp -> key , srp -> modulus , srp -> verifier ) ; BigIntegerMul ( e , k , srp -> key , srp -> bctx ) ; BigIntegerAdd ( e , e , gb ) ; BigIntegerMod ( gb , e , srp -> modulus , srp -> bctx ) ; BigIntegerMul ( e , srp -> password , srp -> u , srp -> bctx ) ; BigIntegerAdd ( e , e , srp -> secret ) ; BigIntegerModExp ( srp -> key , gb , e , srp -> modulus , srp -> bctx , srp -> accel ) ; BigIntegerClearFree ( e ) ; BigIntegerClearFree ( gb ) ; BigIntegerToCstr ( srp -> key , s ) ; SHA512Init ( & ctxt ) ; SHA512Update ( & ctxt , s -> data , s -> length ) ; SHA512Final ( ( unsigned char * ) & SHA512_CLIENT_CTXP ( srp ) -> k , & ctxt ) ; cstr_clear_free ( s ) ; SHA512Update ( & SHA512_CLIENT_CTXP ( srp ) -> hash , SHA512_CLIENT_CTXP ( srp ) -> k , SRP6_SHA512_KEY_LEN ) ; if ( srp -> ex_data -> length > 0 ) { SHA512Update ( & SHA512_CLIENT_CTXP ( srp ) -> hash , srp -> ex_data -> data , srp -> ex_data -> length ) ; } if ( result ) { if ( * result == NULL ) { * result = cstr_new ( ) ; } cstr_setn ( * result , ( const char * ) SHA512_CLIENT_CTXP ( srp ) -> k , SRP6_SHA512_KEY_LEN ) ; } return SRP_SUCCESS ; } 