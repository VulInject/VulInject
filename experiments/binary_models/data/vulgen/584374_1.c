int iwl_trans_pcie_gen2_start_fw ( struct iwl_trans * trans , const struct fw_img * fw , bool run_in_rfkill ) { struct iwl_trans_pcie * trans_pcie = IWL_TRANS_GET_PCIE_TRANS ( trans ) ; bool hw_rfkill ; int ret ; if ( iwl_pcie_prepare_card_hw ( trans ) ) { IWL_WARN ( trans , "Exit HW not ready\n" ) ; return - EIO ; } iwl_enable_rfkill_int ( trans ) ; iwl_write32 ( trans , CSR_INT , 0xFFFFFFFF ) ; iwl_disable_interrupts ( trans ) ; iwl_pcie_synchronize_irqs ( trans ) ; mutex_lock ( & trans_pcie -> mutex ) ; hw_rfkill = iwl_pcie_check_hw_rf_kill ( trans ) ; if ( hw_rfkill && ! run_in_rfkill ) { ret = - ERFKILL ; out } if ( trans_pcie -> is_down ) { IWL_WARN ( trans , "Can't start_fw since the HW hasn't been started\n" ) ; ret = - EIO ; out } iwl_write32 ( trans , CSR_UCODE_DRV_GP1_CLR , CSR_UCODE_SW_BIT_RFKILL ) ; iwl_write32 ( trans , CSR_UCODE_DRV_GP1_CLR , CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED ) ; iwl_write32 ( trans , CSR_INT , 0xFFFFFFFF ) ; ret = iwl_pcie_gen2_nic_init ( trans ) ; if ( ret ) { IWL_ERR ( trans , "Unable to init nic\n" ) ; out } if ( trans -> trans_cfg -> device_family >= IWL_DEVICE_FAMILY_AX210 ) { ret = iwl_pcie_ctxt_info_gen3_init ( trans , fw ) ; } else { ret = iwl_pcie_ctxt_info_init ( trans , fw ) ; } if ( ret ) { out } iwl_pcie_set_ltr ( trans ) ; if ( trans -> trans_cfg -> device_family >= IWL_DEVICE_FAMILY_BZ ) { iwl_write32 ( trans , CSR_FUNC_SCRATCH , CSR_FUNC_SCRATCH_INIT_VALUE ) ; iwl_set_bit ( trans , CSR_GP_CNTRL , CSR_GP_CNTRL_REG_FLAG_ROM_START ) ; } else { iwl_write_prph ( trans , UREG_CPU_INIT_RUN , 1 ) ; } hw_rfkill = iwl_pcie_check_hw_rf_kill ( trans ) ; if ( hw_rfkill && ! run_in_rfkill ) { ret = - ERFKILL ; } out mutex_unlock ( & trans_pcie -> mutex ) ; return ret ; } 