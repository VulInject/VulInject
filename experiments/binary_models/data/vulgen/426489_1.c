void ExplainQuery ( ParseState * pstate , ExplainStmt * stmt , ParamListInfo params , DestReceiver * dest ) { ExplainState * es = NewExplainState ( ) ; TupOutputState * tstate ; JumbleState * jstate = NULL ; Query * query ; List * rewritten ; ListCell * lc ; bool timing_set = false ; bool summary_set = false ; ( lc stmt -> options ; ) { DefElem * opt = ( DefElem * ) lfirst ( lc ) ; if ( strcmp ( opt -> defname , "analyze" ) == 0 ) { es -> analyze = defGetBoolean ( opt ) ; } if ( strcmp ( opt -> defname , "verbose" ) == 0 ) { es -> verbose = defGetBoolean ( opt ) ; } if ( strcmp ( opt -> defname , "costs" ) == 0 ) { es -> costs = defGetBoolean ( opt ) ; } if ( strcmp ( opt -> defname , "buffers" ) == 0 ) { es -> buffers = defGetBoolean ( opt ) ; } if ( strcmp ( opt -> defname , "wal" ) == 0 ) { es -> wal = defGetBoolean ( opt ) ; } if ( strcmp ( opt -> defname , "settings" ) == 0 ) { es -> settings = defGetBoolean ( opt ) ; } if ( strcmp ( opt -> defname , "timing" ) == 0 ) { timing_set = true ; es -> timing = defGetBoolean ( opt ) ; } if ( strcmp ( opt -> defname , "summary" ) == 0 ) { summary_set = true ; es -> summary = defGetBoolean ( opt ) ; } if ( strcmp ( opt -> defname , "format" ) == 0 ) { char * p = defGetString ( opt ) ; if ( strcmp ( p , "text" ) == 0 ) { es -> format = EXPLAIN_FORMAT_TEXT ; } if ( strcmp ( p , "xml" ) == 0 ) { es -> format = EXPLAIN_FORMAT_XML ; } if ( strcmp ( p , "json" ) == 0 ) { es -> format = EXPLAIN_FORMAT_JSON ; } if ( strcmp ( p , "yaml" ) == 0 ) { es -> format = EXPLAIN_FORMAT_YAML ; } else { ereport ( ERROR , ( errcode ( ERRCODE_INVALID_PARAMETER_VALUE ) , errmsg ( "unrecognized value for EXPLAIN option \"%s\": \"%s\"" , opt -> defname , p ) , parser_errposition ( pstate , opt -> location ) ) ) ; } } else { ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( "unrecognized EXPLAIN option \"%s\"" , opt -> defname ) , parser_errposition ( pstate , opt -> location ) ) ) ; } } if ( es -> wal && ! es -> analyze ) { ereport ( ERROR , ( errcode ( ERRCODE_INVALID_PARAMETER_VALUE ) , errmsg ( "EXPLAIN option WAL requires ANALYZE" ) ) ) ; } es -> timing = ( timing_set ) ?es -> timing : es -> analyze ; if ( es -> timing && ! es -> analyze ) { ereport ( ERROR , ( errcode ( ERRCODE_INVALID_PARAMETER_VALUE ) , errmsg ( "EXPLAIN option TIMING requires ANALYZE" ) ) ) ; } es -> summary = ( summary_set ) ?es -> summary : es -> analyze ; query = castNode ( Query , stmt -> query ) ; if ( IsQueryIdEnabled ( ) ) { jstate = JumbleQuery ( query , pstate -> p_sourcetext ) ; } if ( post_parse_analyze_hook ) { * post_parse_analyze_hook ( pstate , query , jstate ) ; } rewritten = QueryRewrite ( castNode ( Query , stmt -> query ) ) ; ExplainBeginOutput ( es ) ; if ( rewritten == NIL ) { } else { ListCell * l ; ( l rewritten ; ) { ExplainOneQuery ( lfirst_node ( Query , l ) , CURSOR_OPT_PARALLEL_OK , NULL , es , pstate -> p_sourcetext , params , pstate -> p_queryEnv ) ; if ( lnext ( rewritten , l ) != NULL ) { ExplainSeparatePlans ( es ) ; } } } ExplainEndOutput ( es ) ; Assert ( es -> indent == 0 ) ; tstate = begin_tup_output_tupdesc ( dest , ExplainResultDesc ( stmt ) , & TTSOpsVirtual ) ; if ( es -> format == EXPLAIN_FORMAT_TEXT ) { do_text_output_multiline ( tstate , es -> str -> data ) ; } else { do_text_output_oneline ( tstate , es -> str -> data ) ; } end_tup_output ( tstate ) ; pfree ( es -> str -> data ) ; } 