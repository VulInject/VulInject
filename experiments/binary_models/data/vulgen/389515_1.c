int HText_beginInput ( HText * text , int underline , InputFieldData * I ) { TextAnchor * a ; FormInfo * f ; const char * cp_option = NULL ; char * IValue = NULL ; unsigned char * tmp = NULL ; int i , j ; int adjust_marker = 0 ; int MaximumSize ; char marker [ 16 ] ; CTRACE ( ( tfp , "GridText: Entering HText_beginInput type=%s\n" , NonNull ( I -> type ) ) ) ; POOLtypecalloc ( TextAnchor , a ) ; POOLtypecalloc ( FormInfo , f ) ; a -> sgml_offset = SGML_offset ( ) ; a -> inUnderline = ( BOOLEAN ) underline ; a -> line_num = text -> Lines ; a -> line_pos = ( short ) text -> last_line -> size ; if ( I -> type != NULL && ! strcmp ( I -> type , "OPTION" ) && HTCurSelectGroupType == F_RADIO_TYPE && LYSelectPopups == FALSE ) { I -> type = "RADIO" ; I -> name = HTCurSelectGroup ; I -> name_cs = HTCurSelectGroupCharset ; } if ( I -> name && I -> type && ! strcasecomp ( I -> type , "radio" ) ) { if ( ! text -> last_anchor ) { I -> checked = TRUE ; } else { TextAnchor * b ; int i2 = 0 ; for ( b = text -> first_anchor ; b != NULL ; b = b -> next ) { if ( b -> link_type == INPUT_ANCHOR && b -> input_field -> type == F_RADIO_TYPE && b -> input_field -> number == HTFormNumber ) { if ( ! strcmp ( b -> input_field -> name , I -> name ) ) { if ( I -> checked && b -> input_field -> num_value ) { b -> input_field -> num_value = 0 ; StrAllocCopy ( b -> input_field -> orig_value , "0" ) ; break ; } i2 ++ ; } } } if ( i2 == 0 ) { I -> checked = TRUE ; } } } a -> next = 0 ; a -> anchor = NULL ; a -> link_type = INPUT_ANCHOR ; a -> show_anchor = YES ; LYClearHiText ( a ) ; a -> extent = 2 ; a -> input_field = f ; f -> select_list = 0 ; f -> number = HTFormNumber ; f -> disabled = HTFormDisabled || I -> disabled ; f -> readonly = I -> readonly ; f -> no_cache = NO ; HTFormFields ++ ; if ( I -> value ) { StrAllocCopy ( IValue , I -> value ) ; } if ( IValue && IS_CJK_TTY && ( ( I -> type == NULL ) || strcasecomp ( I -> type , "hidden" ) ) ) { if ( ( tmp = typecallocn ( , 2 1 ) ) != 0 ) { if ( kanji_code == EUC ) { TO_EUC ( ( unsigned char * ) IValue , tmp ) ; I -> value_cs = current_char_set ; } if ( kanji_code == SJIS ) { TO_SJIS ( ( unsigned char * ) IValue , tmp ) ; I -> value_cs = current_char_set ; } else { for ( i = 0 , j = 0 ; IValue [ i ] ; i ++ ) { if ( IValue [ i ] != CH_ESC ) { tmp [ j ++ ] = UCH ( IValue [ i ] ) ; } } } StrAllocCopy ( IValue , ( const char * ) tmp ) ; FREE ( tmp ) ; } } if ( I -> type != NULL && ! strcmp ( I -> type , "OPTION" ) ) { cp_option = I -> type ; if ( HTCurSelectGroupType == F_RADIO_TYPE ) { I -> type = "OPTION_LIST" ; } else { I -> type = "CHECKBOX" ; } I -> name = HTCurSelectGroup ; I -> name_cs = HTCurSelectGroupCharset ; if ( HTCurSelectGroupSize != NULL ) { f -> size_l = atoi ( HTCurSelectGroupSize ) ; FREE ( HTCurSelectGroupSize ) ; } } if ( I -> size != 0 ) { f -> size = I -> size ; if ( f -> size == 0 && cp_option == NULL ) { f -> size = 20 ; } } else { f -> size = 20 ; } if ( I -> maxlength != NULL ) { f -> maxlength = ( unsigned ) atoi ( I -> maxlength ) ; } else { f -> maxlength = 0 ; } if ( I -> checked == TRUE ) { f -> num_value = 1 ; } else { f -> num_value = 0 ; } if ( I -> type != NULL ) { if ( ! strcasecomp ( I -> type , "password" ) ) { f -> type = F_PASSWORD_TYPE ; } if ( ! strcasecomp ( I -> type , "checkbox" ) ) { f -> type = F_CHECKBOX_TYPE ; } if ( ! strcasecomp ( I -> type , "radio" ) ) { f -> type = F_RADIO_TYPE ; } if ( ! strcasecomp ( I -> type , "submit" ) ) { f -> type = F_SUBMIT_TYPE ; } if ( ! strcasecomp ( I -> type , "image" ) ) { f -> type = F_IMAGE_SUBMIT_TYPE ; } if ( ! strcasecomp ( I -> type , "reset" ) ) { f -> type = F_RESET_TYPE ; } if ( ! strcasecomp ( I -> type , "OPTION_LIST" ) ) { f -> type = F_OPTION_LIST_TYPE ; } if ( ! strcasecomp ( I -> type , "hidden" ) ) { f -> type = F_HIDDEN_TYPE ; HTFormFields -- ; f -> size = 0 ; } if ( ! strcasecomp ( I -> type , "textarea" ) ) { f -> type = F_TEXTAREA_TYPE ; } if ( ! strcasecomp ( I -> type , "range" ) ) { f -> type = F_RANGE_TYPE ; } if ( ! strcasecomp ( I -> type , "file" ) ) { f -> type = F_FILE_TYPE ; CTRACE ( ( tfp , "ok, got a file uploader\n" ) ) ; } if ( ! strcasecomp ( I -> type , "keygen" ) ) { f -> type = F_KEYGEN_TYPE ; } if ( ! strcasecomp ( I -> type , "button" ) ) { f -> type = F_BUTTON_TYPE ; } else { f -> type = F_TEXT_TYPE ; } } else { f -> type = F_TEXT_TYPE ; } if ( I -> name != NULL ) { StrAllocCopy ( f -> name , I -> name ) ; f -> name_cs = I -> name_cs ; } else { if ( f -> type == F_RESET_TYPE || f -> type == F_SUBMIT_TYPE || f -> type == F_IMAGE_SUBMIT_TYPE ) { StrAllocCopy ( f -> name , "" ) ; } else { CTRACE ( ( tfp , "GridText: No name present in input field; not displaying\n" ) ) ; FREE ( IValue ) ; return ( 0 ) ; } } if ( text -> last_anchor ) { text -> last_anchor -> next = a ; } else { text -> first_anchor = a ; } if ( IValue != NULL ) { if ( f -> type == F_OPTION_LIST_TYPE || f -> type == F_CHECKBOX_TYPE ) { StrAllocCopy ( f -> value , IValue ) ; StrAllocCopy ( f -> cp_submit_value , IValue ) ; } else { StrAllocCopy ( f -> value , IValue ) ; } f -> value_cs = I -> value_cs ; } if ( f -> type != F_OPTION_LIST_TYPE ) { StrAllocCopy ( f -> value , "" ) ; f -> value_cs = current_char_set ; } if ( f -> type == F_RESET_TYPE ) { if ( non_empty ( f -> value ) ) { f -> size = ( int ) strlen ( f -> value ) ; } else { StrAllocCopy ( f -> value , "Reset" ) ; f -> size = 5 ; } } if ( f -> type == F_BUTTON_TYPE ) { if ( non_empty ( f -> value ) ) { f -> size = ( int ) strlen ( f -> value ) ; } else { StrAllocCopy ( f -> value , "BUTTON" ) ; f -> size = 5 ; } } if ( f -> type == F_IMAGE_SUBMIT_TYPE || f -> type == F_SUBMIT_TYPE ) { if ( non_empty ( f -> value ) ) { f -> size = ( int ) strlen ( f -> value ) ; } if ( f -> type == F_IMAGE_SUBMIT_TYPE ) { StrAllocCopy ( f -> value , "[IMAGE]-Submit" ) ; f -> size = 14 ; } else { StrAllocCopy ( f -> value , "Submit" ) ; f -> size = 6 ; } addFormAction ( f ) ; } if ( f -> type == F_RADIO_TYPE || f -> type == F_CHECKBOX_TYPE ) { f -> size = 3 ; if ( IValue == NULL ) { StrAllocCopy ( f -> value , ( f -> type == F_CHECKBOX_TYPE ?"on" : "" ) ) ; } } FREE ( IValue ) ; if ( f -> type == F_RADIO_TYPE || f -> type == F_CHECKBOX_TYPE ) { if ( f -> num_value ) { StrAllocCopy ( f -> orig_value , "1" ) ; } else { StrAllocCopy ( f -> orig_value , "0" ) ; } } if ( f -> type == F_OPTION_LIST_TYPE ) { f -> orig_value = NULL ; } else { StrAllocCopy ( f -> orig_value , f -> value ) ; } if ( I -> accept_cs ) { StrAllocCopy ( f -> accept_cs , I -> accept_cs ) ; LYRemoveBlanks ( f -> accept_cs ) ; LYLowerCase ( f -> accept_cs ) ; } switch ( f -> type ) { case F_HIDDEN_TYPE : case F_FILE_TYPE : case F_RANGE_TYPE : case F_KEYGEN_TYPE : case F_BUTTON_TYPE : a -> number = 0 ; break ; default : if ( fields_are_numbered ( ) ) { a -> number = ++ ( text -> last_anchor_number ) ; } else { a -> number = 0 ; } break ; } if ( fields_are_numbered ( ) && ( a -> number > 0 ) ) { if ( HTMainText != 0 ) { HText_findAnchorNumber ( a ) ; } else { a -> show_number = a -> number ; } sprintf ( marker , "[%d]" , a -> show_number ) ; adjust_marker = ( int ) strlen ( marker ) ; if ( number_fields_on_left ) { BOOL had_bracket = ( BOOL ) ( f -> type == F_OPTION_LIST_TYPE ) ; HText_appendText ( text , had_bracket ?( marker + 1 ) : marker ) ; if ( had_bracket ) { HText_appendCharacter ( text , '[' ) ; } } a -> line_num = text -> Lines ; a -> line_pos = ( short ) text -> last_line -> size ; } else { * marker = '\0' ; } MaximumSize = WRAP_COLS ( text ) + 1 - adjust_marker ; switch ( f -> type ) { case F_SUBMIT_TYPE : case F_IMAGE_SUBMIT_TYPE : case F_RESET_TYPE : case F_TEXT_TYPE : case F_TEXTAREA_TYPE : MaximumSize -= ( 1 + ( int ) text -> style -> leftIndent + ( int ) text -> style -> rightIndent ) ; if ( fields_are_numbered ( ) ) { if ( ! number_fields_on_left && f -> type == F_TEXT_TYPE && MaximumSize > a -> line_pos + 10 ) { MaximumSize -= a -> line_pos ; } else { MaximumSize -= ( int ) strlen ( marker ) ; } } if ( f -> type == F_SUBMIT_TYPE ) { FREE ( I -> value ) ; } I -> value = f -> value ; break ; default : MaximumSize -= 10 ; break ; } if ( MaximumSize < 1 ) { MaximumSize = 1 ; } if ( f -> size > MaximumSize ) { f -> size = MaximumSize ; } text -> last_anchor = a ; if ( HTCurrentForm ) { if ( ! HTCurrentForm -> first_field ) { HTCurrentForm -> first_field = f ; } HTCurrentForm -> last_field = f ; HTCurrentForm -> nfields ++ ; if ( HTCurrentForm -> data . submit_method == URL_POST_METHOD ) { f -> no_cache = TRUE ; } if ( f -> accept_cs && ! HTCurrentForm -> accept_cs ) { StrAllocCopy ( HTCurrentForm -> accept_cs , f -> accept_cs ) ; } if ( ! text -> forms ) { text -> forms = HTList_new ( ) ; } } else { CTRACE ( ( tfp , "beginInput: HTCurrentForm is missing!\n" ) ) ; } CTRACE ( ( tfp , "Input link: name=%s\nvalue=%s\nsize=%d\n" , f -> name , NonNull ( f -> value ) , f -> size ) ) ; CTRACE ( ( tfp , "Input link: name_cs=%d \"%s\" (from %d \"%s\")\n" , f -> name_cs , ( f -> name_cs >= 0 ?LYCharSet_UC [ f -> name_cs ] . MIMEname : "<UNKNOWN>" ) , I -> name_cs , ( I -> name_cs >= 0 ?LYCharSet_UC [ I -> name_cs ] . MIMEname : "<UNKNOWN>" ) ) ) ; CTRACE ( ( tfp , "            value_cs=%d \"%s\" (from %d \"%s\")\n" , f -> value_cs , ( f -> value_cs >= 0 ?LYCharSet_UC [ f -> value_cs ] . MIMEname : "<UNKNOWN>" ) , I -> value_cs , ( I -> value_cs >= 0 ?LYCharSet_UC [ I -> value_cs ] . MIMEname : "<UNKNOWN>" ) ) ) ; if ( I -> size && f -> size > adjust_marker ) { f -> size -= adjust_marker ; } return ( f -> size ) ; } 