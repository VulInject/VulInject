static int sof_rt5682_hw_params ( struct snd_pcm_substream * substream , struct snd_pcm_hw_params * params ) { struct snd_soc_pcm_runtime * rtd = asoc_substream_to_rtd ( substream ) ; struct sof_card_private * ctx = snd_soc_card_get_drvdata ( rtd -> card ) ; struct snd_soc_dai * codec_dai = asoc_rtd_to_codec ( rtd , 0 ) ; int pll_id , pll_source , pll_in , pll_out , clk_id , ret ; if ( sof_rt5682_quirk & SOF_RT5682_MCLK_EN ) { if ( sof_rt5682_quirk & SOF_RT5682_MCLK_BYTCHT_EN ) { ret = clk_prepare_enable ( ctx -> mclk ) ; if ( ret < 0 ) { dev_err ( rtd -> dev , "could not configure MCLK state" ) ; return ret ; } } if ( sof_rt5682_quirk & SOF_RT5682S_HEADPHONE_CODEC_PRESENT ) { pll_source = RT5682S_PLL_S_MCLK ; } else { pll_source = RT5682_PLL1_S_MCLK ; } pll_in = sof_dai_get_mclk ( rtd ) ; if ( sof_rt5682_quirk & SOF_RT5682_MCLK_24MHZ ) { if ( pll_in != 24000000 ) { dev_warn ( rtd -> dev , "configure wrong mclk in tplg, please use 24MHz.\n" ) ; } pll_in = 24000000 ; } if ( pll_in == 0 ) { pll_in = 19200000 ; } if ( pll_in < 0 ) { return pll_in ; } } else { if ( sof_rt5682_quirk & SOF_RT5682S_HEADPHONE_CODEC_PRESENT ) { pll_source = RT5682S_PLL_S_BCLK1 ; } else { pll_source = RT5682_PLL1_S_BCLK1 ; } pll_in = params_rate ( params ) * 50 ; } if ( sof_rt5682_quirk & SOF_RT5682S_HEADPHONE_CODEC_PRESENT ) { pll_id = RT5682S_PLL2 ; clk_id = RT5682S_SCLK_S_PLL2 ; } else { pll_id = RT5682_PLL1 ; clk_id = RT5682_SCLK_S_PLL1 ; } pll_out = params_rate ( params ) * 512 ; if ( pll_in == pll_out ) { clk_id = RT5682S_SCLK_S_MCLK ; } else { ret = snd_soc_dai_set_pll ( codec_dai , pll_id , pll_source , pll_in , pll_out ) ; if ( ret < 0 ) { dev_err ( rtd -> dev , "snd_soc_dai_set_pll err = %d\n" , ret ) ; } } ret = snd_soc_dai_set_sysclk ( codec_dai , clk_id , pll_out , SND_SOC_CLOCK_IN ) ; if ( ret < 0 ) { dev_err ( rtd -> dev , "snd_soc_dai_set_sysclk err = %d\n" , ret ) ; } ret = snd_soc_dai_set_tdm_slot ( codec_dai , 0x0 , 0x0 , 2 , params_width ( params ) ) ; return ret ; } 