void helper_vmsave ( CPUX86State * env , int aflag ) { CPUState * cs = env_cpu ( env ) ; target_ulong addr ; int prot ; cpu_svm_check_intercept_param ( env , SVM_EXIT_VMSAVE , 0 , GETPC ( ) ) ; if ( aflag == 2 ) { addr = env -> regs [ R_EAX ] ; } else { addr = ( uint32_t ) env -> regs [ R_EAX ] ; } qemu_log_mask ( CPU_LOG_TB_IN_ASM , "vmsave! " TARGET_FMT_lx "\nFS: %016" PRIx64 " | " TARGET_FMT_lx "\n" , addr , x86_ldq_phys ( cs , addr + offsetof ( vmcb , save . fs . base ) ) , env -> segs [ R_FS ] . base ) ; svm_save_seg ( env , addr + offsetof ( vmcb , save . fs ) , & env -> segs [ R_FS ] ) ; svm_save_seg ( env , addr + offsetof ( vmcb , save . gs ) , & env -> segs [ R_GS ] ) ; svm_save_seg ( env , addr + offsetof ( vmcb , save . tr ) , & env -> tr ) ; svm_save_seg ( env , addr + offsetof ( vmcb , save . ldtr ) , & env -> ldt ) ; x86_stq_phys ( cs , addr + offsetof ( vmcb , save . kernel_gs_base ) , env -> kernelgsbase ) ; x86_stq_phys ( cs , addr + offsetof ( vmcb , save . lstar ) , env -> lstar ) ; x86_stq_phys ( cs , addr + offsetof ( vmcb , save . cstar ) , env -> cstar ) ; x86_stq_phys ( cs , addr + offsetof ( vmcb , save . sfmask ) , env -> fmask ) ; x86_stq_phys ( cs , addr + offsetof ( vmcb , save . star ) , env -> star ) ; x86_stq_phys ( cs , addr + offsetof ( vmcb , save . sysenter_cs ) , env -> sysenter_cs ) ; x86_stq_phys ( cs , addr + offsetof ( vmcb , save . sysenter_esp ) , env -> sysenter_esp ) ; x86_stq_phys ( cs , addr + offsetof ( vmcb , save . sysenter_eip ) , env -> sysenter_eip ) ; } 