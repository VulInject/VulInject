void __init init_IRQ ( void ) { int i ; int j ; struct device_node * np ; struct irq_domain * domain ; for ( i = 0 ; i < NBR_REGS ; i ++ ) { REG_WR_VECT ( intr_vect , regi_irq , rw_mask , i , vect_mask ) ; } for ( i = 0 ; i < 256 ; i ++ ) { etrax_irv -> v [ i ] = weird_irq ; } np = of_find_compatible_node ( NULL , NULL , "axis,crisv32-intc" ) ; domain = irq_domain_add_legacy ( np , NBR_INTR_VECT - FIRST_IRQ , FIRST_IRQ , FIRST_IRQ , & crisv32_irq_ops , NULL ) ; BUG_ON ( ! domain ) ; irq_set_default_host ( domain ) ; of_node_put ( np ) ; for ( i = FIRST_IRQ , j = 0 ; j < NBR_INTR_VECT && j < MACH_IRQS ; i ++ , j ++ ) { set_exception_vector ( i , interrupt [ j ] ) ; } irq_allocations [ TIMER0_INTR_VECT - FIRST_IRQ ] . cpu = CPU_FIXED ; irq_set_status_flags ( TIMER0_INTR_VECT , IRQ_PER_CPU ) ; irq_allocations [ IPI_INTR_VECT - FIRST_IRQ ] . cpu = CPU_FIXED ; irq_set_status_flags ( IPI_INTR_VECT , IRQ_PER_CPU ) ; set_exception_vector ( 0x00 , nmi_interrupt ) ; set_exception_vector ( 0x30 , multiple_interrupt ) ; set_exception_vector ( 0x04 , i_mmu_refill ) ; set_exception_vector ( 0x05 , i_mmu_invalid ) ; set_exception_vector ( 0x06 , i_mmu_access ) ; set_exception_vector ( 0x07 , i_mmu_execute ) ; set_exception_vector ( 0x08 , d_mmu_refill ) ; set_exception_vector ( 0x09 , d_mmu_invalid ) ; set_exception_vector ( 0x0a , d_mmu_access ) ; set_exception_vector ( 0x0b , d_mmu_write ) ; set_exception_vector ( 0x1e , breakh_BUG ) ; set_exception_vector ( 0x1d , system_call ) ; set_exception_vector ( 0x18 , gdb_handle_exception ) ; set_exception_vector ( 0x3 , gdb_handle_exception ) ; set_exception_vector ( 0xc , gdb_handle_exception ) ; kgdb_init ( ) ; breakpoint ( ) ; } 