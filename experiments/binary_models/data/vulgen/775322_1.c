start_recursion ( , , , , , , , , , , , , ) FILEPROC fileproc ; FILESDONEPROC filesdoneproc ; DIRENTPROC direntproc ; DIRLEAVEPROC dirleaveproc ; void * callerdat ; int argc ; char * * argv ; int local ; int which ; int aflag ; int readlock ; char * update_preload ; int dosrcs ; { int i , err = 0 ; List * args_to_send_when_finished = NULL ; List * files_by_dir = NULL ; struct recursion_frame frame ; frame . fileproc = fileproc ; frame . filesdoneproc = filesdoneproc ; frame . direntproc = direntproc ; frame . dirleaveproc = dirleaveproc ; frame . callerdat = callerdat ; frame . flags = local ?R_SKIP_DIRS : R_PROCESS ; frame . which = which ; frame . aflag = aflag ; frame . readlock = readlock ; frame . dosrcs = dosrcs ; expand_wild ( argc , argv , & argc , & argv ) ; if ( update_preload == NULL ) { update_dir = xstrdup ( "" ) ; } else { update_dir = xstrdup ( update_preload ) ; } if ( repository ) { free ( repository ) ; repository = ( char * ) NULL ; } if ( filelist ) { dellist ( & filelist ) ; } if ( dirlist ) { dellist ( & dirlist ) ; } if ( server_active ) { for ( i = 0 ; i < argc ; ++ i ) { server_pathname_check ( argv [ i ] ) ; } } if ( argc == 0 ) { int just_subdirs = ( which & W_LOCAL ) && ! isdir ( CVSADM ) ; if ( ! just_subdirs && CVSroot_cmdline == NULL && current_parsed_root -> isremote ) { char * root = Name_Root ( NULL , update_dir ) ; if ( root && strcmp ( root , current_parsed_root -> original ) != 0 ) { just_subdirs = 1 ; } free ( root ) ; } if ( just_subdirs ) { dirlist = Find_Directories ( ( char * ) NULL , W_LOCAL , ( List * ) NULL ) ; if ( list_isempty ( dirlist ) ) { if ( update_dir [ 0 ] == '\0' ) { error ( 0 , 0 , "in directory .:" ) ; } else { error ( 0 , 0 , "in directory %s:" , update_dir ) ; } error ( 1 , 0 , "there is no version here; run '%s checkout' first" , program_name ) ; } if ( current_parsed_root -> isremote && server_started ) { args_to_send_when_finished = Find_Directories ( ( char * ) NULL , W_LOCAL , ( List * ) NULL ) ; } } else { addlist ( & dirlist , "." ) ; } do_the_work } for ( i = 0 ; i < argc ; i ++ ) { if ( ! wrap_name_has ( argv [ i ] , WRAP_TOCVS ) && isdir ( argv [ i ] ) ) { addlist ( & dirlist , argv [ i ] ) ; } else { char * dir ; char * comp ; char * file_to_try ; dir = xstrdup ( argv [ i ] ) ; comp = last_component ( dir ) ; if ( comp == dir ) { dir = xstrdup ( "." ) ; } else { char * p = comp ; p [ - 1 ] = '\0' ; comp = xstrdup ( p ) ; } if ( ! ( which & W_LOCAL ) ) { file_to_try = xmalloc ( strlen ( argv [ i ] ) + sizeof ( RCSEXT ) + 5 ) ; sprintf ( file_to_try , "%s%s" , argv [ i ] , RCSEXT ) ; } else { file_to_try = xstrdup ( argv [ i ] ) ; } if ( isfile ( file_to_try ) ) { addfile ( & files_by_dir , dir , comp ) ; } if ( isdir ( dir ) ) { if ( ( which & W_LOCAL ) && isdir ( CVSADM ) && ! current_parsed_root -> isremote ) { char * tmp_update_dir ; char * repos ; char * reposfile ; tmp_update_dir = xmalloc ( strlen ( update_dir ) + strlen ( dir ) + 5 ) ; strcpy ( tmp_update_dir , update_dir ) ; if ( * tmp_update_dir != '\0' ) { ( void ) strcat ( tmp_update_dir , "/" ) ; } ( void ) strcat ( tmp_update_dir , dir ) ; repos = Name_Repository ( dir , tmp_update_dir ) ; reposfile = xmalloc ( strlen ( repos ) + strlen ( comp ) + 5 ) ; ( void ) sprintf ( reposfile , "%s/%s" , repos , comp ) ; free ( repos ) ; if ( ! wrap_name_has ( comp , WRAP_TOCVS ) && isdir ( reposfile ) ) { addlist ( & dirlist , argv [ i ] ) ; } else { addfile ( & files_by_dir , dir , comp ) ; } free ( tmp_update_dir ) ; free ( reposfile ) ; } else { addfile ( & files_by_dir , dir , comp ) ; } } else { error ( 1 , 0 , "no such directory `%s'" , dir ) ; } free ( file_to_try ) ; free ( dir ) ; free ( comp ) ; } } err += walklist ( files_by_dir , unroll_files_proc , ( void * ) & frame ) ; dellist ( & files_by_dir ) ; if ( dirlist != NULL ) { do_the_work err += do_recursion ( & frame ) ; } free_names ( & argc , argv ) ; free ( update_dir ) ; update_dir = NULL ; if ( args_to_send_when_finished != NULL ) { int our_argc = 0 , i ; char * * our_argv = NULL ; if ( ! list_isempty ( args_to_send_when_finished ) ) { Node * head , * p ; head = args_to_send_when_finished -> list ; i = 0 ; for ( p = head -> next ; p != head ; p = p -> next ) { i ++ ; } our_argc = i ; our_argv = ( char * * ) xmalloc ( sizeof ( char * ) * our_argc ) ; i = 0 ; for ( p = head -> next ; p != head ; p = p -> next ) { our_argv [ i ++ ] = xstrdup ( p -> key ) ; } } send_file_names ( our_argc , our_argv , 0 ) ; dellist ( & args_to_send_when_finished ) ; } return ( err ) ; } 