static MagickBooleanType WriteJXLImage ( const ImageInfo * image_info , Image * image , ExceptionInfo * exception ) { const char * option ; const StringInfo * exif_profile = ( StringInfo * ) NULL , * xmp_profile = ( StringInfo * ) NULL ; JxlBasicInfo basic_info = { 0 } ; JxlEncoder * jxl_info ; JxlEncoderFrameSettings * frame_settings ; JxlEncoderStatus jxl_status ; JxlMemoryManager memory_manager ; JxlPixelFormat pixel_format = { 0 } ; MagickBooleanType status ; MemoryInfo * pixel_info ; MemoryManagerInfo memory_manager_info ; size_t bytes_per_row ; unsigned char * pixels ; void * runner ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; if ( IsEventLogging ( ) != MagickFalse ) { ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image -> filename ) ; } status = OpenBlob ( image_info , image , WriteBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { return ( status ) ; } if ( ( IssRGBCompatibleColorspace ( image -> colorspace ) == MagickFalse ) && ( IsCMYKColorspace ( image -> colorspace ) == MagickFalse ) ) { ( void ) TransformImageColorspace ( image , sRGBColorspace , exception ) ; } JXLSetMemoryManager ( & memory_manager , & memory_manager_info , image , exception ) ; jxl_info = JxlEncoderCreate ( & memory_manager ) ; if ( jxl_info == ( JxlEncoder * ) NULL ) { ThrowWriterException ( CoderError , "MemoryAllocationFailed" ) ; } runner = JxlThreadParallelRunnerCreate ( NULL , ( size_t ) GetMagickResourceLimit ( ThreadResource ) ) ; if ( runner == ( void * ) NULL ) { JxlEncoderDestroy ( jxl_info ) ; ThrowWriterException ( CoderError , "MemoryAllocationFailed" ) ; } jxl_status = JxlEncoderSetParallelRunner ( jxl_info , JxlThreadParallelRunner , runner ) ; if ( jxl_status != JXL_ENC_SUCCESS ) { JxlThreadParallelRunnerDestroy ( runner ) ; JxlEncoderDestroy ( jxl_info ) ; return ( MagickFalse ) ; } JXLSetFormat ( image , & pixel_format , exception ) ; JxlEncoderInitBasicInfo ( & basic_info ) ; basic_info . xsize = ( uint32_t ) image -> columns ; basic_info . ysize = ( uint32_t ) image -> rows ; basic_info . bits_per_sample = 8 ; if ( pixel_format . data_type == JXL_TYPE_UINT16 ) { basic_info . bits_per_sample = 16 ; } if ( pixel_format . data_type == JXL_TYPE_FLOAT ) { basic_info . bits_per_sample = 32 ; basic_info . exponent_bits_per_sample = 8 ; } if ( pixel_format . data_type == JXL_TYPE_FLOAT16 ) { basic_info . bits_per_sample = 16 ; basic_info . exponent_bits_per_sample = 8 ; } if ( IsGrayColorspace ( image -> colorspace ) != MagickFalse ) { basic_info . num_color_channels = 1 ; } if ( image -> alpha_trait == BlendPixelTrait ) { basic_info . alpha_bits = basic_info . bits_per_sample ; basic_info . alpha_exponent_bits = basic_info . exponent_bits_per_sample ; basic_info . num_extra_channels = 1 ; } if ( image_info -> quality == 100 ) { basic_info . uses_original_profile = JXL_TRUE ; } if ( ( image_info -> adjoin != MagickFalse ) && ( GetNextImageInList ( image ) != ( Image * ) NULL ) ) { basic_info . have_animation = JXL_TRUE ; basic_info . animation . num_loops = ( uint32_t ) image -> iterations ; basic_info . animation . tps_numerator = ( uint32_t ) image -> ticks_per_second ; basic_info . animation . tps_denominator = 1 ; JxlEncoderInitFrameHeader ( & frame_header ) ; frame_header . duration = 1 ; } jxl_status = JxlEncoderSetBasicInfo ( jxl_info , & basic_info ) ; if ( jxl_status != JXL_ENC_SUCCESS ) { JxlThreadParallelRunnerDestroy ( runner ) ; JxlEncoderDestroy ( jxl_info ) ; ThrowWriterException ( CoderError , "UnableToWriteImageData" ) ; } frame_settings = JxlEncoderFrameSettingsCreate ( jxl_info , ( JxlEncoderFrameSettings * ) NULL ) ; if ( frame_settings == ( JxlEncoderFrameSettings * ) NULL ) { JxlThreadParallelRunnerDestroy ( runner ) ; JxlEncoderDestroy ( jxl_info ) ; ThrowWriterException ( CoderError , "MemoryAllocationFailed" ) ; } if ( image_info -> quality == 100 ) { ( void ) JxlEncoderSetFrameDistance ( frame_settings , 0.f ) ; ( void ) JxlEncoderSetFrameLossless ( frame_settings , JXL_TRUE ) ; } else { ( void ) JxlEncoderSetFrameDistance ( frame_settings , JXLGetDistance ( image_info ) ) ; } option = GetImageOption ( image_info , "jxl:effort" ) ; if ( option != ( const char * ) NULL ) { ( void ) JxlEncoderFrameSettingsSetOption ( frame_settings , JXL_ENC_FRAME_SETTING_EFFORT , StringToInteger ( option ) ) ; } option = GetImageOption ( image_info , "jxl:decoding-speed" ) ; if ( option != ( const char * ) NULL ) { ( void ) JxlEncoderFrameSettingsSetOption ( frame_settings , JXL_ENC_FRAME_SETTING_DECODING_SPEED , StringToInteger ( option ) ) ; } exif_profile = GetImageProfile ( image , "exif" ) ; xmp_profile = GetImageProfile ( image , "xmp" ) ; if ( ( exif_profile != ( StringInfo * ) NULL ) || ( xmp_profile != ( StringInfo * ) NULL ) ) { ( void ) JxlEncoderUseBoxes ( jxl_info ) ; if ( ( exif_profile != ( StringInfo * ) NULL ) && ( GetStringInfoLength ( exif_profile ) > 6 ) ) { StringInfo * profile ; profile = BlobToStringInfo ( "\0\0\0\6" , 4 ) ; ConcatenateStringInfo ( profile , exif_profile ) ; ( void ) JxlEncoderAddBox ( jxl_info , "Exif" , GetStringInfoDatum ( profile ) , GetStringInfoLength ( profile ) , 0 ) ; profile = DestroyStringInfo ( profile ) ; } if ( xmp_profile != ( StringInfo * ) NULL ) { ( void ) JxlEncoderAddBox ( jxl_info , "xml " , GetStringInfoDatum ( xmp_profile ) , GetStringInfoLength ( xmp_profile ) , 0 ) ; } ( void ) JxlEncoderCloseBoxes ( jxl_info ) ; } jxl_status = JXLWriteMetadata ( image , jxl_info ) ; if ( jxl_status != JXL_ENC_SUCCESS ) { JxlThreadParallelRunnerDestroy ( runner ) ; JxlEncoderDestroy ( jxl_info ) ; ThrowWriterException ( CoderError , "UnableToWriteImageData" ) ; } bytes_per_row = image -> columns * ( ( image -> alpha_trait == BlendPixelTrait ) ?4 : 3 ) * ( ( pixel_format . data_type == JXL_TYPE_FLOAT ) ?sizeof ( float ) : ( pixel_format . data_type == JXL_TYPE_UINT16 ) ?sizeof ( short ) : sizeof ( char ) ) ; if ( IsGrayColorspace ( image -> colorspace ) != MagickFalse ) { bytes_per_row = image -> columns * ( ( image -> alpha_trait == BlendPixelTrait ) ?2 : 1 ) * ( ( pixel_format . data_type == JXL_TYPE_FLOAT ) ?sizeof ( float ) : ( pixel_format . data_type == JXL_TYPE_UINT16 ) ?sizeof ( short ) : sizeof ( char ) ) ; } pixel_info = AcquireVirtualMemory ( bytes_per_row , image -> rows * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) { JxlThreadParallelRunnerDestroy ( runner ) ; JxlEncoderDestroy ( jxl_info ) ; ThrowWriterException ( CoderError , "MemoryAllocationFailed" ) ; } { Image * next ; if ( basic_info . have_animation == JXL_TRUE ) { jxl_status = JxlEncoderSetFrameHeader ( frame_settings , & frame_header ) ; if ( jxl_status != JXL_ENC_SUCCESS ) { break ; } } pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( IsGrayColorspace ( image -> colorspace ) != MagickFalse ) { status = ExportImagePixels ( image , 0 , 0 , image -> columns , image -> rows , image -> alpha_trait == BlendPixelTrait ?"IA" : "I" , JXLDataTypeToStorageType ( image , pixel_format . data_type , exception ) , pixels , exception ) ; } else { status = ExportImagePixels ( image , 0 , 0 , image -> columns , image -> rows , image -> alpha_trait == BlendPixelTrait ?"RGBA" : "RGB" , JXLDataTypeToStorageType ( image , pixel_format . data_type , exception ) , pixels , exception ) ; } if ( status == MagickFalse ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , "MemoryAllocationFailed" , "`%s'" , image -> filename ) ; status = MagickFalse ; break ; } if ( jxl_status != JXL_ENC_SUCCESS ) { break ; } jxl_status = JxlEncoderAddImageFrame ( frame_settings , & pixel_format , pixels , bytes_per_row * image -> rows ) ; if ( jxl_status != JXL_ENC_SUCCESS ) { break ; } next = GetNextImageInList ( image ) ; if ( next == ( Image * ) NULL ) { break ; } if ( ( next -> columns != image -> columns ) || ( next -> rows != image -> rows ) ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , ImageError , "FramesNotSameDimensions" , "`%s'" , image -> filename ) ; status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; } image_info -> adjoin != MagickFalse ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( jxl_status == JXL_ENC_SUCCESS ) { unsigned char * output_buffer ; JxlEncoderCloseInput ( jxl_info ) ; output_buffer = ( unsigned char * ) AcquireQuantumMemory ( MagickMaxBufferExtent , sizeof ( * output_buffer ) ) ; if ( output_buffer == ( unsigned char * ) NULL ) { JxlThreadParallelRunnerDestroy ( runner ) ; JxlEncoderDestroy ( jxl_info ) ; ThrowWriterException ( CoderError , "MemoryAllocationFailed" ) ; } jxl_status = JXL_ENC_NEED_MORE_OUTPUT ; while ( jxl_status == JXL_ENC_NEED_MORE_OUTPUT ) { size_t extent ; ssize_t count ; unsigned char * p ; extent = MagickMaxBufferExtent ; p = output_buffer ; jxl_status = JxlEncoderProcessOutput ( jxl_info , & p , & extent ) ; count = WriteBlob ( image , MagickMaxBufferExtent - extent , output_buffer ) ; if ( count != ( ssize_t ) ( MagickMaxBufferExtent - extent ) ) { jxl_status = JXL_ENC_ERROR ; break ; } } output_buffer = ( unsigned char * ) RelinquishMagickMemory ( output_buffer ) ; } JxlThreadParallelRunnerDestroy ( runner ) ; JxlEncoderDestroy ( jxl_info ) ; if ( jxl_status != JXL_ENC_SUCCESS ) { ThrowWriterException ( CoderError , "UnableToWriteImageData" ) ; } ( void ) CloseBlob ( image ) ; return ( status ) ; } 