int qla4xxx_request_irqs ( struct scsi_qla_host * ha ) { int ret = 0 ; int rval = QLA_ERROR ; if ( is_qla40XX ( ha ) ) { try_intx } if ( ql4xenablemsix == 2 ) { if ( is_qla8032 ( ha ) || is_qla8042 ( ha ) ) { ql4_printk ( KERN_INFO , ha , "%s: MSI Interrupts not supported for ISP%04x, Falling back-to INTx mode\n" , __func__ , ha -> pdev -> device ) ; try_intx } try_msi } if ( ql4xenablemsix == 0 || ql4xenablemsix != 1 ) { try_intx } ret = qla4_8xxx_enable_msix ( ha ) ; if ( ! ret ) { DEBUG2 ( ql4_printk ( KERN_INFO , ha , "MSI-X: Enabled (0x%X).\n" , ha -> revision_id ) ) ; irq_attached } else { if ( is_qla8032 ( ha ) || is_qla8042 ( ha ) ) { ql4_printk ( KERN_INFO , ha , "%s: ISP%04x: MSI-X: Falling back-to INTx mode. ret = %d\n" , __func__ , ha -> pdev -> device , ret ) ; try_intx } } ql4_printk ( KERN_WARNING , ha , "MSI-X: Falling back-to MSI mode -- %d.\n" , ret ) ; try_msi ret = pci_alloc_irq_vectors ( ha -> pdev , 1 , 1 , PCI_IRQ_MSI ) ; try_intx if ( is_qla8022 ( ha ) ) { ql4_printk ( KERN_WARNING , ha , "%s: ISP82xx Legacy interrupt not supported\n" , __func__ ) ; irq_not_attached } ret = request_irq ( ha -> pdev -> irq , ha -> isp_ops -> intr_handler , IRQF_SHARED , DRIVER_NAME , ha ) ; if ( ! ret ) { DEBUG2 ( ql4_printk ( KERN_INFO , ha , "INTx: Enabled.\n" ) ) ; irq_attached } else { ql4_printk ( KERN_WARNING , ha , "INTx: Failed to reserve interrupt %d already in" " use.\n" , ha -> pdev -> irq ) ; irq_not_attached } irq_attached set_bit ( AF_IRQ_ATTACHED , & ha -> flags ) ; ha -> host -> irq = ha -> pdev -> irq ; ql4_printk ( KERN_INFO , ha , "%s: irq %d attached\n" , __func__ , ha -> pdev -> irq ) ; rval = QLA_SUCCESS ; irq_not_attached return rval ; } 