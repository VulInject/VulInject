int ath_intr1 ( struct ath_softc * sc ) { struct ieee80211com * ic = & sc -> sc_ic ; struct ifnet * ifp = & ic -> ic_if ; struct ath_hal * ah = sc -> sc_ah ; HAL_INT status ; if ( sc -> sc_invalid ) { DPRINTF ( ATH_DEBUG_ANY , ( "%s: invalid; ignored\n" , __func__ ) ) ; return 0 ; } if ( ! ath_hal_is_intr_pending ( ah ) ) { return 0 ; } if ( ( ifp -> if_flags & ( IFF_RUNNING | IFF_UP ) ) != ( IFF_RUNNING | IFF_UP ) ) { DPRINTF ( ATH_DEBUG_ANY , ( "%s: if_flags 0x%x\n" , __func__ , ifp -> if_flags ) ) ; ath_hal_get_isr ( ah , & status ) ; ath_hal_set_intr ( ah , 0 ) ; return 1 ; } ath_hal_get_isr ( ah , & status ) ; DPRINTF ( ATH_DEBUG_INTR , ( "%s: status 0x%x\n" , __func__ , status ) ) ; status &= sc -> sc_imask ; if ( status & HAL_INT_FATAL ) { sc -> sc_stats . ast_hardware ++ ; ath_hal_set_intr ( ah , 0 ) ; ATH_TASK_RUN_OR_ENQUEUE ( & sc -> sc_fataltask ) ; } if ( status & HAL_INT_RXORN ) { sc -> sc_stats . ast_rxorn ++ ; ath_hal_set_intr ( ah , 0 ) ; ATH_TASK_RUN_OR_ENQUEUE ( & sc -> sc_rxorntask ) ; } if ( status & HAL_INT_MIB ) { DPRINTF ( ATH_DEBUG_INTR , ( "%s: resetting MIB counters\n" , __func__ ) ) ; sc -> sc_stats . ast_mib ++ ; ath_hal_update_mib_counters ( ah , & sc -> sc_mib_stats ) ; } else { if ( status & HAL_INT_RXEOL ) { sc -> sc_stats . ast_rxeol ++ ; sc -> sc_rxlink = NULL ; } if ( status & HAL_INT_TXURN ) { sc -> sc_stats . ast_txurn ++ ; ath_hal_update_tx_triglevel ( ah , AH_TRUE ) ; } if ( status & HAL_INT_RX ) { ATH_TASK_RUN_OR_ENQUEUE ( & sc -> sc_rxtask ) ; } if ( status & HAL_INT_TX ) { ATH_TASK_RUN_OR_ENQUEUE ( & sc -> sc_txtask ) ; } if ( status & HAL_INT_SWBA ) { ATH_TASK_RUN_OR_ENQUEUE ( & sc -> sc_swbatask ) ; } } return 1 ; } 