int nitrox_process_se_request ( struct nitrox_device * ndev , struct se_crypto_request * req , completion_t callback , void * cb_arg ) { struct nitrox_softreq * sr ; dma_addr_t ctx_handle = 0 ; int qno , ret = 0 ; if ( ! nitrox_ready ( ndev ) ) { return - ENODEV ; } sr = kzalloc ( sizeof ( * sr ) , req -> gfp ) ; if ( ! sr ) { return - ENOMEM ; } sr -> ndev = ndev ; sr -> flags = req -> flags ; sr -> gfp = req -> gfp ; sr -> callback = callback ; sr -> cb_arg = cb_arg ; atomic_set ( & sr -> status , REQ_NOT_POSTED ) ; sr -> resp . orh = req -> orh ; sr -> resp . completion = req -> comp ; ret = softreq_map_iobuf ( sr , req ) ; if ( ret ) { return ret ; } if ( req -> ctx_handle ) { struct ctx_hdr * hdr ; u8 * ctx_ptr ; ctx_ptr = ( u8 * ) ( uintptr_t ) req -> ctx_handle ; hdr = ( ctx_hdr * ) ( ctx_ptr - sizeof ( ctx_hdr ) ) ; ctx_handle = hdr -> ctx_dma ; } qno = smp_processor_id ( ) % ndev -> nr_queues ; sr -> cmdq = & ndev -> pkt_inq [ qno ] ; sr -> instr . dptr0 = cpu_to_be64 ( sr -> in . sgcomp_dma ) ; sr -> instr . ih . value = 0 ; sr -> instr . ih . s . g = 1 ; sr -> instr . ih . s . gsz = sr -> in . sgmap_cnt ; sr -> instr . ih . s . ssz = sr -> out . sgmap_cnt ; sr -> instr . ih . s . fsz = FDATA_SIZE + sizeof ( gphdr ) ; sr -> instr . ih . s . tlen = sr -> instr . ih . s . fsz + sr -> in . total_bytes ; sr -> instr . ih . bev = cpu_to_be64 ( sr -> instr . ih . value ) ; sr -> instr . irh . value [ 0 ] = 0 ; sr -> instr . irh . s . uddl = MIN_UDD_LEN ; sr -> instr . irh . s . ctxl = ( req -> ctrl . s . ctxl / 8 ) ; sr -> instr . irh . s . destport = SOLICIT_BASE_DPORT + qno ; sr -> instr . irh . s . ctxc = req -> ctrl . s . ctxc ; sr -> instr . irh . s . arg = req -> ctrl . s . arg ; sr -> instr . irh . s . opcode = req -> opcode ; sr -> instr . irh . bev [ 0 ] = cpu_to_be64 ( sr -> instr . irh . value [ 0 ] ) ; sr -> instr . irh . s . ctxp = cpu_to_be64 ( ctx_handle ) ; sr -> instr . slc . value [ 0 ] = 0 ; sr -> instr . slc . s . ssz = sr -> out . sgmap_cnt ; sr -> instr . slc . bev [ 0 ] = cpu_to_be64 ( sr -> instr . slc . value [ 0 ] ) ; sr -> instr . slc . s . rptr = cpu_to_be64 ( sr -> out . sgcomp_dma ) ; sr -> instr . fdata [ 0 ] = * ( ( u64 * ) & req -> gph ) ; sr -> instr . fdata [ 1 ] = 0 ; ret = nitrox_enqueue_request ( sr ) ; if ( ret == - ENOSPC ) { send_fail } return ret ; send_fail softreq_destroy ( sr ) ; return ret ; } 