if ( ! face ) { return ; } memory = pfrface -> driver -> root . memory ; pfrface -> family_name = NULL ; pfrface -> style_name = NULL ; pfr_phy_font_done ( & face -> phy_font , FT_FACE_MEMORY ( face ) ) ; FT_FREE ( pfrface -> available_sizes ) ; ( FT_Error ) pfr_face_init ( , , , , ) { PFR_Face face = ( PFR_Face ) pfrface FT_Error error FT_UNUSED ( num_params ) FT_UNUSED ( params ) FT_TRACE2 ( ( "PFR driver\n" ) ) error = pfr_header_load ( & face -> header , stream ) if ( error ) { FT_TRACE2 ( ( "  not a PFR font\n" ) ) ; error = FT_THROW ( Unknown_File_Format ) ; Exit ; } } ; if ( ! pfr_header_check ( & face -> header ) ) { FT_TRACE2 ( ( "  not a PFR font\n" ) ) ; error = FT_THROW ( Unknown_File_Format ) ; Exit } { FT_Long num_faces ; error = pfr_log_font_count ( stream , face -> header . log_dir_offset , & num_faces ) ; if ( error ) { Exit } pfrface -> num_faces = num_faces ; } if ( face_index < 0 ) { Exit } if ( ( face_index & 0xFFFF ) >= pfrface -> num_faces ) { FT_ERROR ( ( "pfr_face_init: invalid face index\n" ) ) ; error = FT_THROW ( Invalid_Argument ) ; Exit } error = pfr_log_font_load ( & face -> log_font , stream , ( FT_UInt ) ( face_index & 0xFFFF ) , face -> header . log_dir_offset , FT_BOOL ( face -> header . phy_font_max_size_high ) ) ; if ( error ) { Exit } error = pfr_phy_font_load ( & face -> phy_font , stream , face -> log_font . phys_offset , face -> log_font . phys_size ) ; if ( error ) { Exit } { PFR_PhyFont phy_font = & face -> phy_font ; pfrface -> face_index = face_index & 0xFFFF ; pfrface -> num_glyphs = ( FT_Long ) phy_font -> num_chars + 1 ; pfrface -> face_flags |= FT_FACE_FLAG_SCALABLE ; { FT_UInt nn ; for ( nn = 0 ; nn < phy_font -> num_chars ; nn ++ ) { if ( phy_font -> chars [ nn ] . gps_offset != 0 ) { break ; } } if ( nn == phy_font -> num_chars ) { if ( phy_font -> num_strikes > 0 ) { pfrface -> face_flags &= ~ FT_FACE_FLAG_SCALABLE ; } else { FT_ERROR ( ( "pfr_face_init: font doesn't contain glyphs\n" ) ) ; error = FT_THROW ( Invalid_File_Format ) ; Exit } } } if ( ! ( phy_font -> flags & PFR_PHY_PROPORTIONAL ) ) { pfrface -> face_flags |= FT_FACE_FLAG_FIXED_WIDTH ; } if ( phy_font -> flags & PFR_PHY_VERTICAL ) { pfrface -> face_flags |= FT_FACE_FLAG_VERTICAL ; } else { pfrface -> face_flags |= FT_FACE_FLAG_HORIZONTAL ; } if ( phy_font -> num_strikes > 0 ) { pfrface -> face_flags |= FT_FACE_FLAG_FIXED_SIZES ; } if ( phy_font -> num_kern_pairs > 0 ) { pfrface -> face_flags |= FT_FACE_FLAG_KERNING ; } pfrface -> family_name = phy_font -> family_name ; if ( ! pfrface -> family_name ) { pfrface -> family_name = phy_font -> font_id ; } pfrface -> style_name = phy_font -> style_name ; pfrface -> num_fixed_sizes = 0 ; pfrface -> available_sizes = NULL ; pfrface -> bbox = phy_font -> bbox ; pfrface -> units_per_EM = ( FT_UShort ) phy_font -> outline_resolution ; pfrface -> ascender = ( FT_Short ) phy_font -> bbox . yMax ; pfrface -> descender = ( FT_Short ) phy_font -> bbox . yMin ; pfrface -> height = ( FT_Short ) ( ( pfrface -> units_per_EM * 12 ) / 10 ) ; if ( pfrface -> height < pfrface -> ascender - pfrface -> descender ) { pfrface -> height = ( FT_Short ) ( pfrface -> ascender - pfrface -> descender ) ; } if ( phy_font -> num_strikes > 0 ) { FT_UInt n , count = phy_font -> num_strikes ; FT_Bitmap_Size * size ; PFR_Strike strike ; FT_Memory memory = pfrface -> stream -> memory ; if ( FT_QNEW_ARRAY ( pfrface -> available_sizes , count ) ) { Exit } size = pfrface -> available_sizes ; strike = phy_font -> strikes ; for ( n = 0 ; n < count ; n ++ , size ++ , strike ++ ) { size -> height = ( FT_Short ) strike -> y_ppm ; size -> width = ( FT_Short ) strike -> x_ppm ; size -> size = ( FT_Pos ) ( strike -> y_ppm << 6 ) ; size -> x_ppem = ( FT_Pos ) ( strike -> x_ppm << 6 ) ; size -> y_ppem = ( FT_Pos ) ( strike -> y_ppm << 6 ) ; } pfrface -> num_fixed_sizes = ( FT_Int ) count ; } if ( ( phy_font -> flags & PFR_PHY_PROPORTIONAL ) == 0 ) { pfrface -> max_advance_width = ( FT_Short ) phy_font -> standard_advance ; } else { FT_Int max = 0 ; FT_UInt count = phy_font -> num_chars ; PFR_Char gchar = phy_font -> chars ; for ( ; count > 0 ; count -- , gchar ++ ) { } pfrface -> max_advance_width = ( FT_Short ) max ; } pfrface -> max_advance_height = pfrface -> height ; pfrface -> underline_position = ( FT_Short ) ( - pfrface -> units_per_EM / 10 ) ; pfrface -> underline_thickness = ( FT_Short ) ( pfrface -> units_per_EM / 30 ) ; { FT_CharMapRec charmap ; charmap . face = pfrface ; charmap . platform_id = TT_PLATFORM_MICROSOFT ; charmap . encoding_id = TT_MS_ID_UNICODE_CS ; charmap . encoding = FT_ENCODING_UNICODE ; error = FT_CMap_New ( & pfr_cmap_class_rec , NULL , & charmap , NULL ) ; } if ( phy_font -> num_kern_pairs ) { pfrface -> face_flags |= FT_FACE_FLAG_KERNING ; } } Exit return error ; ( FT_Error ) pfr_slot_init ( ) { PFR_Slot slot = ( PFR_Slot ) pfrslot FT_GlyphLoader loader = pfrslot -> internal -> loader pfr_glyph_init ( & slot -> glyph , loader ) return 0 ; } ; FT_LOCAL_DEF ( ) pfr_slot_done ( ) { PFR_Slot slot = ( PFR_Slot ) pfrslot ; } 