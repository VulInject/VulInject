* The macro FT_COMPONENT is used in trace mode . It is an implicit * parameter of the FT_TRACE ( ) and FT_ERROR ( ) macros , used to print / log * messages during execution . * / static void gxv_mort_feature_validate ( , ) { if ( f -> featureType >= gxv_feat_registry_length ) { GXV_TRACE ( ( "featureType %d is out of registered range, " "setting %d is unchecked\n" , f -> featureType , f -> featureSetting ) ) ; GXV_SET_ERR_IF_PARANOID ( FT_INVALID_DATA ) ; ; } } ; if ( ! gxv_feat_registry [ f -> featureType ] . existence ) { GXV_TRACE ( ( "featureType %d is within registered area " "but undefined, setting %d is unchecked\n" , f -> featureType , f -> featureSetting ) ) ; GXV_SET_ERR_IF_PARANOID ( FT_INVALID_DATA ) ; } else { FT_Byte nSettings_max ; nSettings_max = gxv_feat_registry [ f -> featureType ] . nSettings ; if ( gxv_feat_registry [ f -> featureType ] . exclusive ) { nSettings_max = ( FT_Byte ) ( 2 * nSettings_max ) ; } GXV_TRACE ( ( "featureType %d is registered" , f -> featureType ) ) ; GXV_TRACE ( ( "setting %d" , f -> featureSetting ) ) ; GXV_TRACE ( ( "\n" ) ) ; } ( void ) gxv_mort_featurearray_validate ( , , , ) { FT_Bytes p = table FT_ULong i GXV_mort_featureRec f = GXV_MORT_FEATURE_OFF GXV_NAME_ENTER ( "mort feature list" ) for ( i = 0 ; i < nFeatureFlags ; i ++ ) { GXV_LIMIT_CHECK ( 2 + 2 + 4 + 4 ) ; f . featureType = FT_NEXT_USHORT ( p ) ; f . featureSetting = FT_NEXT_USHORT ( p ) ; f . enableFlags = FT_NEXT_ULONG ( p ) ; f . disableFlags = FT_NEXT_ULONG ( p ) ; gxv_mort_feature_validate ( & f , gxvalid ) ; ; } } ; if ( ! IS_GXV_MORT_FEATURE_OFF ( f ) ) { FT_INVALID_DATA ; } gxvalid -> subtable_length = ( FT_ULong ) ( p - table ) ; GXV_EXIT ; 