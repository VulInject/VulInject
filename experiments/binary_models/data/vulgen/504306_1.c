int __rec_ret ( t , e , nrec , key , data ) BTREE * t ; EPG * e ; recno_t nrec ; DBT * key , * data ; { RLEAF * rl ; void * p ; if ( key == NULL ) { dataonly } if ( sizeof ( recno_t ) > t -> bt_rkey . size ) { p = ( void * ) ( t -> bt_rkey . data == NULL ?malloc ( sizeof ( recno_t ) ) : realloc ( t -> bt_rkey . data , sizeof ( recno_t ) ) ) ; if ( p == NULL ) { return ( RET_ERROR ) ; } t -> bt_rkey . data = p ; t -> bt_rkey . size = sizeof ( recno_t ) ; } memmove ( t -> bt_rkey . data , & nrec , sizeof ( recno_t ) ) ; key -> size = sizeof ( recno_t ) ; key -> data = t -> bt_rkey . data ; dataonly if ( data == NULL ) { return ( RET_SUCCESS ) ; } rl = GETRLEAF ( e -> page , e -> index ) ; if ( rl -> flags & P_BIGDATA ) { if ( __ovfl_get ( t , rl -> bytes , & data -> size , & t -> bt_rdata . data , & t -> bt_rdata . size ) ) { return ( RET_ERROR ) ; } data -> data = t -> bt_rdata . data ; } if ( F_ISSET ( t , B_DB_LOCK ) ) { if ( rl -> dsize + 1 > t -> bt_rdata . size ) { p = ( void * ) ( t -> bt_rdata . data == NULL ?malloc ( rl -> dsize + 1 ) : realloc ( t -> bt_rdata . data , rl -> dsize + 1 ) ) ; t -> bt_rdata . data = p ; t -> bt_rdata . size = rl -> dsize + 1 ; } memmove ( t -> bt_rdata . data , rl -> bytes , rl -> dsize ) ; data -> size = rl -> dsize ; data -> data = t -> bt_rdata . data ; } else { data -> size = rl -> dsize ; data -> data = rl -> bytes ; } return ( RET_SUCCESS ) ; } 