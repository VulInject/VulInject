static int hisi_sas_queue_command ( struct sas_task * task , gfp_t gfp_flags ) { int n_elem = 0 , n_elem_dif = 0 ; struct domain_device * device = task -> dev ; struct asd_sas_port * sas_port = device -> port ; struct hisi_sas_device * sas_dev = device -> lldd_dev ; bool internal_abort = sas_is_internal_abort ( task ) ; struct hisi_sas_dq * dq = NULL ; struct hisi_sas_port * port ; struct hisi_hba * hisi_hba ; struct hisi_sas_slot * slot ; struct request * rq = NULL ; struct device * dev ; int rc ; if ( ! sas_port ) { struct task_status_struct * ts = & task -> task_status ; ts -> resp = SAS_TASK_UNDELIVERED ; ts -> stat = SAS_PHY_DOWN ; if ( device -> dev_type != SAS_SATA_DEV && ! internal_abort ) { task -> task_done ( task ) ; } return - ECOMM ; } hisi_hba = dev_to_hisi_hba ( device ) ; dev = hisi_hba -> dev ; switch ( task -> task_proto ) { case SAS_PROTOCOL_SSP : case SAS_PROTOCOL_SMP : case SAS_PROTOCOL_SATA : case SAS_PROTOCOL_STP : case SAS_PROTOCOL_STP_ALL : if ( unlikely ( test_bit ( HISI_SAS_REJECT_CMD_BIT , & hisi_hba -> flags ) ) ) { down ( & hisi_hba -> sem ) ; up ( & hisi_hba -> sem ) ; } if ( DEV_IS_GONE ( sas_dev ) ) { if ( sas_dev ) { dev_info ( dev , "task prep: device %d not ready\n" , sas_dev -> device_id ) ; } else { dev_info ( dev , "task prep: device %016llx not ready\n" , SAS_ADDR ( device -> sas_addr ) ) ; } return - ECOMM ; } port = to_hisi_sas_port ( sas_port ) ; if ( ! port -> port_attached ) { dev_info ( dev , "task prep: %s port%d not attach device\n" , dev_is_sata ( device ) ?"SATA/STP" : "SAS" , device -> port -> id ) ; return - ECOMM ; } rq = sas_task_find_rq ( task ) ; if ( rq ) { unsigned int dq_index ; u32 blk_tag ; blk_tag = blk_mq_unique_tag ( rq ) ; dq_index = blk_mq_unique_tag_to_hwq ( blk_tag ) ; dq = & hisi_hba -> dq [ dq_index ] ; } else { struct Scsi_Host * shost = hisi_hba -> shost ; struct blk_mq_queue_map * qmap = & shost -> tag_set . map [ HCTX_TYPE_DEFAULT ] ; int queue = qmap -> mq_map [ raw_smp_processor_id ( ) ] ; dq = & hisi_hba -> dq [ queue ] ; } break ; case SAS_PROTOCOL_INTERNAL_ABORT : if ( ! hisi_hba -> hw -> prep_abort ) { return TMF_RESP_FUNC_FAILED ; } if ( test_bit ( HISI_SAS_HW_FAULT_BIT , & hisi_hba -> flags ) ) { return - EIO ; } hisi_hba = dev_to_hisi_hba ( device ) ; if ( unlikely ( test_bit ( HISI_SAS_REJECT_CMD_BIT , & hisi_hba -> flags ) ) ) { return - EINVAL ; } port = to_hisi_sas_port ( sas_port ) ; dq = & hisi_hba -> dq [ task -> abort_task . qid ] ; break ; default : dev_err ( hisi_hba -> dev , "task prep: unknown/unsupported proto (0x%x)\n" , task -> task_proto ) ; return - EINVAL ; } rc = hisi_sas_dma_map ( hisi_hba , task , & n_elem ) ; if ( rc < 0 ) { prep_out } if ( ! sas_protocol_ata ( task -> task_proto ) ) { rc = hisi_sas_dif_dma_map ( hisi_hba , & n_elem_dif , task ) ; if ( rc < 0 ) { err_out_dma_unmap } } if ( ! internal_abort && hisi_hba -> hw -> slot_index_alloc ) { rc = hisi_hba -> hw -> slot_index_alloc ( hisi_hba , device ) ; } else { rc = hisi_sas_slot_index_alloc ( hisi_hba , rq ) ; } if ( rc < 0 ) { err_out_dif_dma_unmap } slot = & hisi_hba -> slot_info [ rc ] ; slot -> n_elem = n_elem ; slot -> n_elem_dif = n_elem_dif ; slot -> task = task ; slot -> port = port ; slot -> tmf = task -> tmf ; slot -> is_internal = ! ! task -> tmf || internal_abort ; hisi_sas_task_deliver ( hisi_hba , slot , dq , sas_dev ) ; return 0 ; err_out_dif_dma_unmap if ( ! sas_protocol_ata ( task -> task_proto ) ) { hisi_sas_dif_dma_unmap ( hisi_hba , task , n_elem_dif ) ; } err_out_dma_unmap hisi_sas_dma_unmap ( hisi_hba , task , n_elem ) ; prep_out dev_err ( dev , "task exec: failed[%d]!\n" , rc ) ; return rc ; } 