IRAM bool mgos_hw_timers_dev_set ( struct mgos_hw_timer_info * ti , int usecs , int flags ) { struct mgos_hw_timer_dev_data * dd = & ti -> dev ; timg_dev_t * tg = dd -> tg ; int tn = dd -> tn ; tg -> hw_timer [ tn ] . config . val = ( TIMG_T0_INCREASE | TIMG_T0_ALARM_EN | ( ( TIMER_BASE_CLK / 1000000 ) << TIMG_T0_DIVIDER_S ) ) ; tg -> hw_timer [ tn ] . config . tx_autoreload = ( ( flags & MGOS_TIMER_REPEAT ) != 0 ) ; tg -> hw_timer [ tn ] . loadhi . tx_load_hi = 0 ; tg -> hw_timer [ tn ] . loadlo . tx_load_lo = 0 ; tg -> hw_timer [ tn ] . alarmhi . tx_alarm_hi = 0 ; tg -> hw_timer [ tn ] . alarmlo . tx_alarm_lo = usecs ; tg -> hw_timer [ tn ] . load . tx_load = 1 ; uint32_t mask = ( 1 << tn ) ; if ( dd -> inth == NULL ) { int intr_source = 0 ; switch ( dd -> tgn ) { case TIMER_GROUP_0 : default : intr_source = ETS_TG0_T0_LEVEL_INTR_SOURCE + tn ; break ; case TIMER_GROUP_1 : intr_source = ETS_TG1_T0_LEVEL_INTR_SOURCE + tn ; break ; } uint32_t status_reg = ( uint32_t ) & tg -> int_st_timers . val ; if ( esp_intr_alloc_intrstatus ( intr_source , 0 , status_reg , mask , ( void ( * ) ( void * ) ) mgos_hw_timers_isr , ti , & dd -> inth ) != ESP_OK ) { LOG ( LL_ERROR , ( "Couldn't allocate into for HW timer" ) ) ; return false ; } } bool want_iram = ( flags & MGOS_ESP32_HW_TIMER_IRAM ) != 0 ; tg -> int_ena_timers . val |= mask ; tg -> hw_timer [ tn ] . config . tx_en = true ; return true ; } 