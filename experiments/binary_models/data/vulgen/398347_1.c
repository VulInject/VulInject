static int smcr_tx_sndbuf_nonempty ( struct smc_connection * conn ) { struct smc_cdc_producer_flags * pflags = & conn -> local_tx_ctrl . prod_flags ; struct smc_link * link = conn -> lnk ; struct smc_rdma_wr * wr_rdma_buf ; struct smc_cdc_tx_pend * pend ; struct smc_wr_buf * wr_buf ; int rc ; if ( ! link || ! smc_wr_tx_link_hold ( link ) ) { return - ENOLINK ; } rc = smc_cdc_get_free_slot ( conn , link , & wr_buf , & wr_rdma_buf , & pend ) ; if ( rc < 0 ) { smc_wr_tx_link_put ( link ) ; if ( rc == - EBUSY ) { struct smc_sock * smc = container_of ( conn , smc_sock , conn ) ; if ( smc -> sk . sk_err == ECONNABORTED ) { return sock_error ( & smc -> sk ) ; } rc = 0 ; mod_delayed_work ( conn -> lgr -> tx_wq , & conn -> tx_work , SMC_TX_WORK_DELAY ) ; } return rc ; } spin_lock_bh ( & conn -> send_lock ) ; if ( link != conn -> lnk ) { smc_wr_tx_put_slot ( link , ( smc_wr_tx_pend_priv * ) pend ) ; rc = - ENOLINK ; out_unlock } if ( ! pflags -> urg_data_present ) { rc = smc_tx_rdma_writes ( conn , wr_rdma_buf ) ; if ( rc ) { smc_wr_tx_put_slot ( link , ( smc_wr_tx_pend_priv * ) pend ) ; out_unlock } } rc = smc_cdc_msg_send ( conn , wr_buf , pend ) ; if ( ! rc && pflags -> urg_data_present ) { pflags -> urg_data_pending = 0 ; pflags -> urg_data_present = 0 ; } out_unlock spin_unlock_bh ( & conn -> send_lock ) ; smc_wr_tx_link_put ( link ) ; return rc ; } 