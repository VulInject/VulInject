int ls_refs ( struct repository * r , struct packet_reader * request ) { struct ls_refs_data data ; strvec_init ( & data . prefixes ) ; strbuf_init ( & data . buf , 0 ) ; string_list_init_dup ( & data . hidden_refs ) ; ensure_config_read ( ) ; git_config ( ls_refs_config , & data ) ; while ( packet_reader_read ( request ) == PACKET_READ_NORMAL ) { const char * arg = request -> line ; const char * out ; if ( ! strcmp ( "peel" , arg ) ) { data . peel = 1 ; } if ( ! strcmp ( "symrefs" , arg ) ) { data . symrefs = 1 ; } if ( skip_prefix ( arg , "ref-prefix " , & out ) ) { if ( data . prefixes . nr < TOO_MANY_PREFIXES ) { strvec_push ( & data . prefixes , out ) ; } } if ( ! strcmp ( "unborn" , arg ) ) { data . unborn = allow_unborn ; } else { die ( _ ( "unexpected line: '%s'" ) , arg ) ; } } if ( request -> status != PACKET_READ_FLUSH ) { die ( _ ( "expected flush after ls-refs arguments" ) ) ; } if ( data . prefixes . nr >= TOO_MANY_PREFIXES ) { strvec_clear ( & data . prefixes ) ; } send_possibly_unborn_head ( & data ) ; if ( ! data . prefixes . nr ) { strvec_push ( & data . prefixes , "" ) ; } refs_for_each_fullref_in_prefixes ( get_main_ref_store ( r ) , get_git_namespace ( ) , data . prefixes . v , send_ref , & data ) ; packet_fflush ( stdout ) ; strvec_clear ( & data . prefixes ) ; strbuf_release ( & data . buf ) ; string_list_clear ( & data . hidden_refs , 0 ) ; return 0 ; } 