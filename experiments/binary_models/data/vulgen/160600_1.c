static irqreturn_t slgt_interrupt ( int dummy , void * dev_id ) { struct slgt_info * info = dev_id ; unsigned int gsr ; unsigned int i ; DBGISR ( ( "slgt_interrupt irq=%d entry\n" , info -> irq_level ) ) ; while ( ( gsr = rd_reg32 ( info , GSR ) & 0xffffff00 ) ) { DBGISR ( ( "%s gsr=%08x\n" , info -> device_name , gsr ) ) ; info -> irq_occurred = true ; for ( i = 0 ; i < info -> port_count ; i ++ ) { if ( info -> port_array [ i ] == NULL ) { continue ; } spin_lock ( & info -> port_array [ i ] -> lock ) ; if ( gsr & ( BIT8 << i ) ) { isr_serial ( info -> port_array [ i ] ) ; } if ( gsr & ( BIT16 << ( i * 2 ) ) ) { isr_rdma ( info -> port_array [ i ] ) ; } if ( gsr & ( BIT17 << ( i * 2 ) ) ) { isr_tdma ( info -> port_array [ i ] ) ; } spin_unlock ( & info -> port_array [ i ] -> lock ) ; } } if ( info -> gpio_present ) { unsigned int state ; unsigned int changed ; spin_lock ( & info -> lock ) ; while ( ( changed = rd_reg32 ( info , IOSR ) ) != 0 ) { DBGISR ( ( "%s iosr=%08x\n" , info -> device_name , changed ) ) ; state = rd_reg32 ( info , IOVR ) ; wr_reg32 ( info , IOSR , changed ) ; for ( i = 0 ; i < info -> port_count ; i ++ ) { if ( info -> port_array [ i ] != NULL ) { isr_gpio ( info -> port_array [ i ] , changed , state ) ; } } } } for ( i = 0 ; i < info -> port_count ; i ++ ) { struct slgt_info * port = info -> port_array [ i ] ; if ( port == NULL ) { continue ; } spin_lock ( & port -> lock ) ; if ( ( port -> port . count || port -> netcount ) && port -> pending_bh && ! port -> bh_running && ! port -> bh_requested ) { DBGISR ( ( "%s bh queued\n" , port -> device_name ) ) ; schedule_work ( & port -> task ) ; port -> bh_requested = true ; } spin_unlock ( & port -> lock ) ; } DBGISR ( ( "slgt_interrupt irq=%d exit\n" , info -> irq_level ) ) ; return IRQ_HANDLED ; } 