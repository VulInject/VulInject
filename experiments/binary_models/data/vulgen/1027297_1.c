static nvlist_t * zpool_find_import_impl ( libzfs_handle_t * hdl , importargs_t * iarg ) { nvlist_t * ret = NULL ; pool_list_t pools = { 0 } ; pool_entry_t * pe , * penext ; vdev_entry_t * ve , * venext ; config_entry_t * ce , * cenext ; name_entry_t * ne , * nenext ; pthread_mutex_t lock ; avl_tree_t * cache ; rdsk_node_t * slice ; void * cookie ; tpool_t * t ; verify ( iarg -> poolname == NULL || iarg -> guid == 0 ) ; pthread_mutex_init ( & lock , NULL ) ; if ( iarg -> scan || iarg -> paths != 0 ) { int dirs = iarg -> paths ; char * * dir = iarg -> path ; if ( dirs == 0 ) { dir = zpool_default_import_path ; dirs = DEFAULT_IMPORT_PATH_SIZE ; } } else { if ( zpool_find_import_blkid ( hdl , & lock , & cache ) != 0 ) { return ( NULL ) ; } } t = tpool_create ( 1 , 2 * sysconf ( _SC_NPROCESSORS_ONLN ) , 0 , NULL ) ; for ( slice = avl_first ( cache ) ; slice ; ( slice = avl_walk ( cache , slice , AVL_AFTER ) ) ) { ( void ) tpool_dispatch ( t , zpool_open_func , slice ) ; } tpool_wait ( t ) ; tpool_destroy ( t ) ; cookie = NULL ; while ( ( slice = avl_destroy_nodes ( cache , & cookie ) ) != NULL ) { if ( slice -> rn_config != NULL ) { nvlist_t * config = slice -> rn_config ; boolean_t matched = B_TRUE ; boolean_t aux = B_FALSE ; int fd ; if ( iarg -> poolname != NULL || iarg -> guid != 0 ) { uint64_t state ; aux = nvlist_lookup_uint64 ( config , ZPOOL_CONFIG_POOL_STATE , & state ) == 0 && ( state == POOL_STATE_SPARE || state == POOL_STATE_L2CACHE ) ; } if ( iarg -> poolname != NULL && ! aux ) { char * pname ; matched = nvlist_lookup_string ( config , ZPOOL_CONFIG_POOL_NAME , & pname ) == 0 && strcmp ( iarg -> poolname , pname ) == 0 ; } if ( iarg -> guid != 0 && ! aux ) { uint64_t this_guid ; matched = nvlist_lookup_uint64 ( config , ZPOOL_CONFIG_POOL_GUID , & this_guid ) == 0 && iarg -> guid == this_guid ; } if ( ! matched ) { nvlist_free ( config ) ; } else { fd = open ( slice -> rn_name , O_RDONLY | O_EXCL ) ; if ( fd >= 0 || iarg -> can_be_active ) { if ( fd >= 0 ) { close ( fd ) ; } add_config ( hdl , & pools , slice -> rn_name , slice -> rn_order , slice -> rn_num_labels , config ) ; } else { nvlist_free ( config ) ; } } } free ( slice -> rn_name ) ; free ( slice ) ; } avl_destroy ( cache ) ; free ( cache ) ; pthread_mutex_destroy ( & lock ) ; ret = get_configs ( hdl , & pools , iarg -> can_be_active ) ; for ( pe = pools . pools ; pe != NULL ; pe = penext ) { penext = pe -> pe_next ; for ( ve = pe -> pe_vdevs ; ve != NULL ; ve = venext ) { venext = ve -> ve_next ; for ( ce = ve -> ve_configs ; ce != NULL ; ce = cenext ) { cenext = ce -> ce_next ; nvlist_free ( ce -> ce_config ) ; free ( ce ) ; } free ( ve ) ; } free ( pe ) ; } for ( ne = pools . names ; ne != NULL ; ne = nenext ) { nenext = ne -> ne_next ; free ( ne -> ne_name ) ; free ( ne ) ; } return ( ret ) ; } 