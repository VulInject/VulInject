static int vfio_iommu_type1_dirty_pages ( struct vfio_iommu * iommu , unsigned long arg ) { struct vfio_iommu_type1_dirty_bitmap dirty ; uint32_t mask = VFIO_IOMMU_DIRTY_PAGES_FLAG_START | VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP | VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP ; unsigned long minsz ; int ret = 0 ; minsz = offsetofend ( vfio_iommu_type1_dirty_bitmap , flags ) ; if ( copy_from_user ( & dirty , ( void __user * ) arg , minsz ) ) { return - EFAULT ; } if ( dirty . argsz < minsz || dirty . flags & ~ mask ) { return - EINVAL ; } if ( __ffs ( dirty . flags ) != __fls ( dirty . flags ) ) { return - EINVAL ; } if ( dirty . flags & VFIO_IOMMU_DIRTY_PAGES_FLAG_START ) { size_t pgsize ; mutex_lock ( & iommu -> lock ) ; pgsize = 1 << __ffs ( iommu -> pgsize_bitmap ) ; if ( ! iommu -> dirty_page_tracking ) { ret = vfio_dma_bitmap_alloc_all ( iommu , pgsize ) ; if ( ! ret ) { iommu -> dirty_page_tracking = true ; } } mutex_unlock ( & iommu -> lock ) ; return ret ; } if ( dirty . flags & VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP ) { mutex_lock ( & iommu -> lock ) ; if ( iommu -> dirty_page_tracking ) { iommu -> dirty_page_tracking = false ; vfio_dma_bitmap_free_all ( iommu ) ; } mutex_unlock ( & iommu -> lock ) ; return 0 ; } if ( dirty . flags & VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP ) { struct vfio_iommu_type1_dirty_bitmap_get range ; unsigned long pgshift ; size_t data_size = dirty . argsz - minsz ; size_t iommu_pgsize ; if ( ! data_size || data_size < sizeof ( range ) ) { return - EINVAL ; } if ( copy_from_user ( & range , ( void __user * ) ( arg + minsz ) , sizeof ( range ) ) ) { return - EFAULT ; } if ( range . iova + range . size < range . iova ) { return - EINVAL ; } if ( ! access_ok ( ( void __user * ) range . bitmap . data , range . bitmap . size ) ) { return - EINVAL ; } pgshift = __ffs ( range . bitmap . pgsize ) ; ret = verify_bitmap_size ( range . size >> pgshift , range . bitmap . size ) ; if ( ret ) { return ret ; } mutex_lock ( & iommu -> lock ) ; iommu_pgsize = ( size_t ) 1 << __ffs ( iommu -> pgsize_bitmap ) ; if ( range . bitmap . pgsize != iommu_pgsize ) { ret = - EINVAL ; out_unlock } if ( range . iova & ( iommu_pgsize - 1 ) ) { ret = - EINVAL ; out_unlock } if ( ! range . size || range . size & ( iommu_pgsize - 1 ) ) { ret = - EINVAL ; out_unlock } if ( iommu -> dirty_page_tracking ) { ret = vfio_iova_dirty_bitmap ( range . bitmap . data , iommu , range . iova , range . size , range . bitmap . pgsize ) ; } else { ret = - EINVAL ; } out_unlock mutex_unlock ( & iommu -> lock ) ; return ret ; } return - EINVAL ; } 