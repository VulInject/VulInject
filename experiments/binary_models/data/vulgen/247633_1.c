static int dev_di_node_add ( di_node_t node , char * devid , disk_cbdata_t * cbp ) { topo_mod_t * mod = cbp -> dcb_mod ; dev_di_node_t * dnode ; di_path_t pnode ; char * path ; int mlen ; char * minorpath ; char * extn = ":a" ; char * s ; int64_t * nblocksp ; uint64_t nblocks ; int * blksizep ; uint_t blksize ; char lentry [ MAXPATHLEN ] ; int pathcount ; int * inq_dtype , itype ; int i ; if ( devid ) { for ( dnode = topo_list_next ( cbp -> dcb_list ) ; dnode != NULL ; dnode = topo_list_next ( dnode ) ) { if ( dnode -> ddn_devid && devid_str_compare ( dnode -> ddn_devid , devid ) == 0 ) { topo_mod_dprintf ( mod , "dev_di_node_add: " "already there %s\n" , devid ) ; return ( 0 ) ; } } } if ( ( dnode = topo_mod_zalloc ( mod , sizeof ( dev_di_node_t ) ) ) == NULL ) { return ( - 1 ) ; } if ( devid ) { dnode -> ddn_devid = topo_mod_strdup ( mod , devid ) ; if ( dnode -> ddn_devid == NULL ) { error } } if ( ( path = di_devfs_path ( node ) ) == NULL ) { ( void ) topo_mod_seterrno ( mod , errno ) ; error } dnode -> ddn_dpath = topo_mod_strdup ( mod , path ) ; di_devfs_path_free ( path ) ; if ( dnode -> ddn_dpath == NULL ) { error } pathcount = 0 ; pnode = NULL ; while ( ( pnode = di_path_client_next_path ( node , pnode ) ) != NULL ) { pathcount ++ ; } if ( pathcount == 0 ) { if ( ( dnode -> ddn_ppath = topo_mod_zalloc ( mod , sizeof ( char * ) ) ) == NULL ) { error } dnode -> ddn_ppath_count = 1 ; if ( ( dnode -> ddn_ppath [ 0 ] = topo_mod_strdup ( mod , dnode -> ddn_dpath ) ) == NULL ) { error } if ( ( dnode -> ddn_target_port = topo_mod_zalloc ( mod , sizeof ( char * ) ) ) == NULL ) { error } if ( ( dnode -> ddn_attached_port = topo_mod_zalloc ( mod , sizeof ( char * ) ) ) == NULL ) { error } if ( ( dnode -> ddn_bridge_port = topo_mod_zalloc ( mod , sizeof ( char * ) ) ) == NULL ) { error } if ( ( di_prop_lookup_strings ( DDI_DEV_T_ANY , node , SCSI_ADDR_PROP_TARGET_PORT , & s ) ) == 1 ) { if ( ( dnode -> ddn_target_port [ 0 ] = topo_mod_strdup ( mod , scsi_wwnstr_skip_ua_prefix ( s ) ) ) == NULL ) { error } } if ( ( di_prop_lookup_strings ( DDI_DEV_T_ANY , node , SCSI_ADDR_PROP_ATTACHED_PORT , & s ) ) == 1 ) { if ( ( dnode -> ddn_attached_port [ 0 ] = topo_mod_strdup ( mod , scsi_wwnstr_skip_ua_prefix ( s ) ) ) == NULL ) { error } } if ( ( di_prop_lookup_strings ( DDI_DEV_T_ANY , node , SCSI_ADDR_PROP_BRIDGE_PORT , & s ) ) == 1 ) { if ( ( dnode -> ddn_bridge_port [ 0 ] = topo_mod_strdup ( mod , scsi_wwnstr_skip_ua_prefix ( s ) ) ) == NULL ) { error } } } else { if ( ( dnode -> ddn_ppath = topo_mod_zalloc ( mod , pathcount * sizeof ( char * ) ) ) == NULL ) { error } dnode -> ddn_ppath_count = pathcount ; if ( ( dnode -> ddn_target_port = topo_mod_zalloc ( mod , pathcount * sizeof ( char * ) ) ) == NULL ) { error } if ( ( dnode -> ddn_attached_port = topo_mod_zalloc ( mod , pathcount * sizeof ( char * ) ) ) == NULL ) { error } if ( ( dnode -> ddn_bridge_port = topo_mod_zalloc ( mod , pathcount * sizeof ( char * ) ) ) == NULL ) { error } pnode = NULL ; pathcount = 0 ; while ( ( pnode = di_path_client_next_path ( node , pnode ) ) != NULL ) { if ( ( path = di_path_devfs_path ( pnode ) ) == NULL ) { ( void ) topo_mod_seterrno ( mod , errno ) ; error } dnode -> ddn_ppath [ pathcount ] = topo_mod_strdup ( mod , path ) ; di_devfs_path_free ( path ) ; if ( dnode -> ddn_ppath [ pathcount ] == NULL ) { error } if ( ( di_path_prop_lookup_strings ( pnode , SCSI_ADDR_PROP_TARGET_PORT , & s ) ) == 1 ) { if ( ( dnode -> ddn_target_port [ pathcount ] = topo_mod_strdup ( mod , scsi_wwnstr_skip_ua_prefix ( s ) ) ) == NULL ) { error } } if ( ( di_path_prop_lookup_strings ( pnode , SCSI_ADDR_PROP_ATTACHED_PORT , & s ) ) == 1 ) { if ( ( dnode -> ddn_attached_port [ pathcount ] = topo_mod_strdup ( mod , scsi_wwnstr_skip_ua_prefix ( s ) ) ) == NULL ) { error } } if ( ( di_path_prop_lookup_strings ( pnode , SCSI_ADDR_PROP_BRIDGE_PORT , & s ) ) == 1 ) { if ( ( dnode -> ddn_bridge_port [ pathcount ] = topo_mod_strdup ( mod , scsi_wwnstr_skip_ua_prefix ( s ) ) ) == NULL ) { error } } pathcount ++ ; } } if ( di_prop_lookup_ints ( DDI_DEV_T_ANY , node , "inquiry-device-type" , & inq_dtype ) > 0 ) { dnode -> ddn_dtype = * inq_dtype ; itype = ( * inq_dtype ) & DTYPE_MASK ; if ( itype == DTYPE_DIRECT ) { mlen = strlen ( dnode -> ddn_dpath ) + strlen ( extn ) + 1 ; if ( ( minorpath = topo_mod_alloc ( mod , mlen ) ) == NULL ) { error } ( void ) snprintf ( minorpath , mlen , "%s%s" , dnode -> ddn_dpath , extn ) ; cbp -> dcb_dnode = dnode ; ( void ) di_devlink_walk ( cbp -> dcb_devhdl , "^dsk/" , minorpath , DI_PRIMARY_LINK , cbp , disk_devlink_callback ) ; topo_mod_free ( mod , minorpath , mlen ) ; } } else { dnode -> ddn_dtype = DTYPE_UNKNOWN ; } if ( di_prop_lookup_strings ( DDI_DEV_T_ANY , node , INQUIRY_VENDOR_ID , & s ) > 0 ) { if ( ( dnode -> ddn_mfg = disk_trim_whitespace ( mod , s ) ) == NULL ) { error } } if ( di_prop_lookup_strings ( DDI_DEV_T_ANY , node , INQUIRY_PRODUCT_ID , & s ) > 0 ) { if ( ( dnode -> ddn_model = disk_trim_whitespace ( mod , s ) ) == NULL ) { error } } if ( di_prop_lookup_strings ( DDI_DEV_T_ANY , node , INQUIRY_REVISION_ID , & s ) > 0 ) { if ( ( dnode -> ddn_firm = disk_trim_whitespace ( mod , s ) ) == NULL ) { error } } if ( di_prop_lookup_strings ( DDI_DEV_T_ANY , node , INQUIRY_SERIAL_NO , & s ) > 0 ) { if ( ( dnode -> ddn_serial = disk_trim_whitespace ( mod , s ) ) == NULL ) { error } } else { di_node_t parent ; if ( ( parent = di_parent_node ( node ) ) != DI_NODE_NIL && di_prop_lookup_strings ( DDI_DEV_T_ANY , parent , "usb-serialno" , & s ) > 0 ) { if ( ( dnode -> ddn_serial = disk_trim_whitespace ( mod , s ) ) == NULL ) { error } } } if ( di_prop_lookup_int64 ( DDI_DEV_T_ANY , node , "device-nblocks" , & nblocksp ) > 0 ) { nblocks = ( uint64_t ) * nblocksp ; if ( di_prop_lookup_ints ( DDI_DEV_T_ANY , node , "device-blksize" , & blksizep ) > 0 ) { blksize = ( uint_t ) * blksizep ; } else { blksize = DEV_BSIZE ; } ( void ) snprintf ( lentry , sizeof ( lentry ) , "%" PRIu64 , nblocks * blksize ) ; if ( ( dnode -> ddn_cap = topo_mod_strdup ( mod , lentry ) ) == NULL ) { error } } topo_mod_dprintf ( mod , "dev_di_node_add: " "adding %s\n" , devid ?dnode -> ddn_devid : "NULL devid" ) ; topo_mod_dprintf ( mod , "                  " "       %s\n" , dnode -> ddn_dpath ) ; for ( i = 0 ; i < dnode -> ddn_ppath_count ; i ++ ) { topo_mod_dprintf ( mod , "                  " "       %s\n" , dnode -> ddn_ppath [ i ] ) ; } topo_list_append ( cbp -> dcb_list , dnode ) ; return ( 0 ) ; error dev_di_node_free ( mod , dnode ) ; return ( - 1 ) ; } 