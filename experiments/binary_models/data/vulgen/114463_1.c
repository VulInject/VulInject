static void sdma_desc_avail ( struct sdma_engine * sde , unsigned avail ) { struct iowait * wait , * nw ; struct iowait * waits [ SDMA_WAIT_BATCH_SIZE ] ; unsigned i , n = 0 , seq ; struct sdma_txreq * stx ; struct hfi1_ibdev * dev = & sde -> dd -> verbs_dev ; dd_dev_err ( sde -> dd , "CONFIG SDMA(%u) %s:%d %s()\n" , sde -> this_idx , slashstrip ( __FILE__ ) , __LINE__ , __func__ ) ; dd_dev_err ( sde -> dd , "avail: %u\n" , avail ) ; { seq = read_seqbegin ( & dev -> iowait_lock ) ; if ( ! list_empty ( & sde -> dmawait ) ) { write_seqlock ( & dev -> iowait_lock ) ; list_for_each_entry_safe ( , , , ) { u16 num_desc ; if ( ! wait -> wakeup ) { continue ; } if ( n == ARRAY_SIZE ( waits ) ) { break ; } if ( ! list_empty ( & wait -> tx_head ) ) { stx = list_first_entry ( & wait -> tx_head , sdma_txreq , list ) ; num_desc = stx -> num_desc ; } if ( num_desc > avail ) { break ; } avail -= num_desc ; list_del_init ( & wait -> list ) ; waits [ n ++ ] = wait ; } write_sequnlock ( & dev -> iowait_lock ) ; break ; } } read_seqretry ( & dev -> iowait_lock , seq ) ; for ( i = 0 ; i < n ; i ++ ) { waits [ i ] -> wakeup ( waits [ i ] , SDMA_AVAIL_REASON ) ; } } 