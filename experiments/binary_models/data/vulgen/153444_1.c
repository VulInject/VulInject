static void kernel_fork_after ( ) CK_RV C_Initialize ( CK_VOID_PTR pInitArgs ) { int initialize_pid ; boolean_t supplied_ok ; CK_RV rv = CKR_OK ; ( void ) pthread_mutex_lock ( & globalmutex ) ; initialize_pid = getpid ( ) ; if ( kernel_initialized ) { if ( initialize_pid == kernel_pid ) { ( void ) pthread_mutex_unlock ( & globalmutex ) ; return ( CKR_CRYPTOKI_ALREADY_INITIALIZED ) ; } else { cleanup_library ( ) ; } } if ( pInitArgs != NULL ) { CK_C_INITIALIZE_ARGS * initargs1 = ( CK_C_INITIALIZE_ARGS * ) pInitArgs ; if ( initargs1 -> pReserved != NULL ) { ( void ) pthread_mutex_unlock ( & globalmutex ) ; return ( CKR_ARGUMENTS_BAD ) ; } supplied_ok = ( initargs1 -> CreateMutex == NULL && initargs1 -> DestroyMutex == NULL && initargs1 -> LockMutex == NULL && initargs1 -> UnlockMutex == NULL ) || ( initargs1 -> CreateMutex != NULL && initargs1 -> DestroyMutex != NULL && initargs1 -> LockMutex != NULL && initargs1 -> UnlockMutex != NULL ) ; if ( ! supplied_ok ) { ( void ) pthread_mutex_unlock ( & globalmutex ) ; return ( CKR_ARGUMENTS_BAD ) ; } if ( ! ( initargs1 -> flags & CKF_OS_LOCKING_OK ) && ( initargs1 -> CreateMutex != NULL ) ) { ( void ) pthread_mutex_unlock ( & globalmutex ) ; return ( CKR_CANT_LOCK ) ; } } while ( ( kernel_fd = open ( CRYPTO_DEVICE , O_RDWR ) ) < 0 ) { if ( errno != EINTR ) { break ; } } if ( kernel_fd < 0 ) { ( void ) pthread_mutex_unlock ( & globalmutex ) ; return ( CKR_FUNCTION_FAILED ) ; } ( void ) fcntl ( kernel_fd , F_SETFD , FD_CLOEXEC ) ; if ( kernel_mechhash == NULL ) { ( void ) close ( kernel_fd ) ; ( void ) pthread_mutex_unlock ( & globalmutex ) ; return ( CKR_HOST_MEMORY ) ; } rv = kernel_slottable_init ( ) ; if ( rv != CKR_OK ) { free ( kernel_mechhash ) ; ( void ) close ( kernel_fd ) ; ( void ) pthread_mutex_unlock ( & globalmutex ) ; return ( rv ) ; } ( void ) pthread_mutex_init ( & obj_delay_freed . obj_to_be_free_mutex , NULL ) ; obj_delay_freed . count = 0 ; obj_delay_freed . first = NULL ; obj_delay_freed . last = NULL ; ( void ) pthread_mutex_init ( & ses_delay_freed . ses_to_be_free_mutex , NULL ) ; ses_delay_freed . count = 0 ; ses_delay_freed . first = NULL ; ses_delay_freed . last = NULL ; kernel_initialized = B_TRUE ; kernel_pid = initialize_pid ; ( void ) pthread_mutex_unlock ( & globalmutex ) ; return ( CKR_OK ) ; } 