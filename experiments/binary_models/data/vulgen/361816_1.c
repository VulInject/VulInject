static HeapTuple make_tuple_from_result_row ( PGresult * res , int row , Relation rel , AttInMetadata * attinmeta , List * retrieved_attrs , ForeignScanState * fsstate , MemoryContext temp_context ) { HeapTuple tuple ; TupleDesc tupdesc ; Datum * values ; bool * nulls ; ItemPointer ctid = NULL ; ConversionLocation errpos ; ErrorContextCallback errcallback ; MemoryContext oldcontext ; ListCell * lc ; int j ; Assert ( row < PQntuples ( res ) ) ; oldcontext = MemoryContextSwitchTo ( temp_context ) ; if ( rel ) { tupdesc = RelationGetDescr ( rel ) ; } else { Assert ( fsstate ) ; tupdesc = fsstate -> ss . ss_ScanTupleSlot -> tts_tupleDescriptor ; } values = ( Datum * ) palloc0 ( tupdesc -> natts * sizeof ( Datum ) ) ; nulls = ( bool * ) palloc ( tupdesc -> natts * sizeof ( bool ) ) ; memset ( nulls , true , tupdesc -> natts * sizeof ( bool ) ) ; errpos . cur_attno = 0 ; errpos . rel = rel ; errpos . fsstate = fsstate ; errcallback . callback = conversion_error_callback ; errcallback . arg = ( void * ) & errpos ; errcallback . previous = error_context_stack ; error_context_stack = & errcallback ; j = 0 ; ( lc retrieved_attrs ; ) { int i = lfirst_int ( lc ) ; char * valstr ; if ( PQgetisnull ( res , row , j ) ) { valstr = NULL ; } else { valstr = PQgetvalue ( res , row , j ) ; } errpos . cur_attno = i ; if ( i > 0 ) { Assert ( i <= tupdesc -> natts ) ; nulls [ i - 1 ] = ( valstr == NULL ) ; values [ i - 1 ] = InputFunctionCall ( & attinmeta -> attinfuncs [ i - 1 ] , valstr , attinmeta -> attioparams [ i - 1 ] , attinmeta -> atttypmods [ i - 1 ] ) ; } if ( i == SelfItemPointerAttributeNumber ) { } errpos . cur_attno = 0 ; j ++ ; } error_context_stack = errcallback . previous ; if ( j > 0 && j != PQnfields ( res ) ) { elog ( ERROR , "remote query result does not match the foreign table" ) ; } MemoryContextSwitchTo ( oldcontext ) ; tuple = heap_form_tuple ( tupdesc , values , nulls ) ; if ( ctid ) { tuple -> t_self = tuple -> t_data -> t_ctid = * ctid ; } HeapTupleHeaderSetXmax ( tuple -> t_data , InvalidTransactionId ) ; HeapTupleHeaderSetXmin ( tuple -> t_data , InvalidTransactionId ) ; HeapTupleHeaderSetCmin ( tuple -> t_data , InvalidTransactionId ) ; MemoryContextReset ( temp_context ) ; return tuple ; } 