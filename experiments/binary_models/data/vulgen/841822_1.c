void test_pcep_msg_read_pcep_open ( ) { char filename [ BASE_TMPFILE_SIZE ] ; if ( fd == - 1 ) { CU_ASSERT_TRUE ( fd >= 0 ) ; return ; } double_linked_list * msg_list = pcep_msg_read ( fd ) ; CU_ASSERT_PTR_NOT_NULL ( msg_list ) ; assert ( msg_list != NULL ) ; CU_ASSERT_EQUAL ( msg_list -> num_entries , 1 ) ; struct pcep_message * msg = ( pcep_message * ) msg_list -> head -> data ; CU_ASSERT_EQUAL ( msg -> obj_list -> num_entries , 1 ) ; CU_ASSERT_EQUAL ( msg -> msg_header -> type , PCEP_TYPE_OPEN ) ; CU_ASSERT_EQUAL ( msg -> encoded_message_length , pcep_open_hexbyte_strs_length ) ; struct pcep_object_header * obj_hdr = ( pcep_object_header * ) msg -> obj_list -> head -> data ; CU_ASSERT_EQUAL ( obj_hdr -> object_class , PCEP_OBJ_CLASS_OPEN ) ; CU_ASSERT_EQUAL ( obj_hdr -> object_type , PCEP_OBJ_TYPE_OPEN ) ; CU_ASSERT_EQUAL ( obj_hdr -> encoded_object_length , 24 ) ; CU_ASSERT_TRUE ( pcep_obj_has_tlv ( obj_hdr ) ) ; CU_ASSERT_EQUAL ( obj_hdr -> tlv_list -> num_entries , 2 ) ; double_linked_list_node * tlv_node = obj_hdr -> tlv_list -> head ; struct pcep_object_tlv_header * tlv = ( pcep_object_tlv_header * ) tlv_node -> data ; CU_ASSERT_EQUAL ( tlv -> type , PCEP_OBJ_TLV_TYPE_STATEFUL_PCE_CAPABILITY ) ; CU_ASSERT_EQUAL ( tlv -> encoded_tlv_length , 4 ) ; tlv_node = tlv_node -> next_node ; tlv = ( pcep_object_tlv_header * ) tlv_node -> data ; CU_ASSERT_EQUAL ( tlv -> type , PCEP_OBJ_TLV_TYPE_SR_PCE_CAPABILITY ) ; CU_ASSERT_EQUAL ( tlv -> encoded_tlv_length , 4 ) ; pcep_msg_free_message_list ( msg_list ) ; close ( fd ) ; unlink ( filename ) ; } 