void nrf_drv_twis_state_machine ( uint8_t instNr ) { if ( ! TWIS_NO_SYNC_MODE ) { m_sm_semaphore [ instNr ] = 1 ; } NRF_TWIS_Type * const p_reg = m_const_inst [ instNr ] . p_reg ; nrf_drv_twis_evt_t evdata ; nrf_drv_twis_substate_t substate = m_var_inst [ instNr ] . substate ; uint32_t ev = 0 ; ev |= nrf_drv_twis_event_bit_get ( p_reg , NRF_TWIS_EVENT_STOPPED ) ; ev |= nrf_drv_twis_event_bit_get ( p_reg , NRF_TWIS_EVENT_ERROR ) ; ev |= nrf_drv_twis_event_bit_get ( p_reg , NRF_TWIS_EVENT_RXSTARTED ) ; ev |= nrf_drv_twis_event_bit_get ( p_reg , NRF_TWIS_EVENT_TXSTARTED ) ; ev |= nrf_drv_twis_event_bit_get ( p_reg , NRF_TWIS_EVENT_WRITE ) ; ev |= nrf_drv_twis_event_bit_get ( p_reg , NRF_TWIS_EVENT_READ ) ; while ( 0 != ev ) { switch ( substate ) { case NRF_DRV_TWIS_SUBSTATE_IDLE : if ( nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_STOPPED ) ) { ev = nrf_drv_twis_clear_bit ( ev , NRF_TWIS_EVENT_STOPPED ) ; } if ( nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_READ ) ) { evdata . type = TWIS_EVT_READ_REQ ; if ( nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_TXSTARTED ) ) { substate = NRF_DRV_TWIS_SUBSTATE_READ_PENDING ; evdata . data . buf_req = false ; } else { substate = NRF_DRV_TWIS_SUBSTATE_READ_WAITING ; evdata . data . buf_req = true ; } nrf_drv_call_event_handler ( instNr , & evdata ) ; ev = nrf_drv_twis_clear_bit ( ev , NRF_TWIS_EVENT_READ ) ; ev = nrf_drv_twis_clear_bit ( ev , NRF_TWIS_EVENT_TXSTARTED ) ; ev = nrf_drv_twis_clear_bit ( ev , NRF_TWIS_EVENT_WRITE ) ; ev = nrf_drv_twis_clear_bit ( ev , NRF_TWIS_EVENT_RXSTARTED ) ; } if ( nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_WRITE ) ) { evdata . type = TWIS_EVT_WRITE_REQ ; if ( nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_RXSTARTED ) ) { substate = NRF_DRV_TWIS_SUBSTATE_WRITE_PENDING ; evdata . data . buf_req = false ; } else { substate = NRF_DRV_TWIS_SUBSTATE_WRITE_WAITING ; evdata . data . buf_req = true ; } nrf_drv_call_event_handler ( instNr , & evdata ) ; ev = nrf_drv_twis_clear_bit ( ev , NRF_TWIS_EVENT_READ ) ; ev = nrf_drv_twis_clear_bit ( ev , NRF_TWIS_EVENT_TXSTARTED ) ; ev = nrf_drv_twis_clear_bit ( ev , NRF_TWIS_EVENT_WRITE ) ; ev = nrf_drv_twis_clear_bit ( ev , NRF_TWIS_EVENT_RXSTARTED ) ; } else { nrf_drv_twis_process_error ( instNr , TWIS_EVT_GENERAL_ERROR , nrf_twis_error_source_get_and_clear ( p_reg ) ) ; ev = 0 ; } break ; case NRF_DRV_TWIS_SUBSTATE_READ_WAITING : if ( nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_TXSTARTED ) || nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_WRITE ) || nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_READ ) || nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_STOPPED ) ) { substate = NRF_DRV_TWIS_SUBSTATE_READ_PENDING ; ev = nrf_drv_twis_clear_bit ( ev , NRF_TWIS_EVENT_TXSTARTED ) ; } else { nrf_drv_twis_process_error ( instNr , TWIS_EVT_READ_ERROR , nrf_twis_error_source_get_and_clear ( p_reg ) ) ; substate = NRF_DRV_TWIS_SUBSTATE_IDLE ; ev = 0 ; } break ; case NRF_DRV_TWIS_SUBSTATE_READ_PENDING : if ( nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_WRITE ) || nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_READ ) || nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_STOPPED ) ) { evdata . type = TWIS_EVT_READ_DONE ; evdata . data . tx_amount = nrf_twis_tx_amount_get ( p_reg ) ; NRF_LOG_INFO ( "Transfer rx_len:%d\r\n" , evdata . data . tx_amount ) ; NRF_LOG_DEBUG ( "Tx data:\r\n" ) ; NRF_LOG_HEXDUMP_DEBUG ( ( uint8_t * ) p_reg -> TXD . PTR , evdata . data . tx_amount * sizeof ( p_reg -> TXD . PTR ) ) ; nrf_drv_call_event_handler ( instNr , & evdata ) ; substate = NRF_DRV_TWIS_SUBSTATE_IDLE ; ev = nrf_drv_twis_clear_bit ( ev , NRF_TWIS_EVENT_STOPPED ) ; } else { nrf_drv_twis_process_error ( instNr , TWIS_EVT_READ_ERROR , nrf_twis_error_source_get_and_clear ( p_reg ) ) ; substate = NRF_DRV_TWIS_SUBSTATE_IDLE ; ev = 0 ; } break ; case NRF_DRV_TWIS_SUBSTATE_WRITE_WAITING : if ( nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_RXSTARTED ) || nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_WRITE ) || nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_READ ) || nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_STOPPED ) ) { substate = NRF_DRV_TWIS_SUBSTATE_WRITE_PENDING ; ev = nrf_drv_twis_clear_bit ( ev , NRF_TWIS_EVENT_RXSTARTED ) ; } else { nrf_drv_twis_process_error ( instNr , TWIS_EVT_WRITE_ERROR , nrf_twis_error_source_get_and_clear ( p_reg ) ) ; substate = NRF_DRV_TWIS_SUBSTATE_IDLE ; ev = 0 ; } break ; case NRF_DRV_TWIS_SUBSTATE_WRITE_PENDING : if ( nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_WRITE ) || nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_READ ) || nrf_drv_twis_check_bit ( ev , NRF_TWIS_EVENT_STOPPED ) ) { evdata . type = TWIS_EVT_WRITE_DONE ; evdata . data . rx_amount = nrf_twis_rx_amount_get ( p_reg ) ; nrf_drv_call_event_handler ( instNr , & evdata ) ; substate = NRF_DRV_TWIS_SUBSTATE_IDLE ; ev = nrf_drv_twis_clear_bit ( ev , NRF_TWIS_EVENT_STOPPED ) ; } else { nrf_drv_twis_process_error ( instNr , TWIS_EVT_WRITE_ERROR , nrf_twis_error_source_get_and_clear ( p_reg ) ) ; substate = NRF_DRV_TWIS_SUBSTATE_IDLE ; ev = 0 ; } break ; default : substate = NRF_DRV_TWIS_SUBSTATE_IDLE ; break ; } } m_var_inst [ instNr ] . substate = substate ; if ( ! TWIS_NO_SYNC_MODE ) { m_sm_semaphore [ instNr ] = 0 ; } } 