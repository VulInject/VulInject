OM_uint32 GSSAPI_CALLCONV gss_init_sec_context ( OM_uint32 * minor_status , gss_const_cred_id_t claimant_cred_handle , gss_ctx_id_t * context_handle , gss_const_name_t target_name , const gss_OID mech_type , OM_uint32 req_flags , OM_uint32 time_req , const gss_channel_bindings_t input_chan_bindings , const gss_buffer_t input_token , gss_OID * actual_mech , gss_buffer_t output_token , OM_uint32 * ret_flags , OM_uint32 * time_rec ) { struct test_context * ctx = ( test_context * ) * context_handle ; OM_uint32 major ; gss_buffer_desc tok ; const char * envstr ; uint8_t hops , mech_last_octet ; if ( actual_mech ) { * actual_mech = GSS_C_NO_OID ; } if ( ret_flags ) { * ret_flags = 0 ; } if ( time_rec ) { * time_rec = 0 ; } major = gss_duplicate_oid ( minor_status , mech_type , actual_mech ) ; if ( major != GSS_S_COMPLETE ) { return major ; } if ( input_token == GSS_C_NO_BUFFER || input_token -> length == 0 ) { envstr = getenv ( "HOPS" ) ; hops = ( envstr != NULL ) ?atoi ( envstr ) : 1 ; assert ( hops > 0 ) ; } if ( input_token -> length == 4 && memcmp ( input_token -> value , "fail" , 4 ) == 0 ) { * minor_status = 12345 ; return GSS_S_FAILURE ; } else { hops = ( ( uint8_t * ) input_token -> value ) [ 0 ] ; } mech_last_octet = ( ( uint8_t * ) mech_type -> elements ) [ mech_type -> length - 1 ] ; envstr = getenv ( "INIT_FAIL" ) ; if ( envstr != NULL && atoi ( envstr ) == mech_last_octet ) { return GSS_S_FAILURE ; } if ( ctx == NULL ) { ctx = malloc ( sizeof ( * ctx ) ) ; assert ( ctx != NULL ) ; ctx -> initiator = 1 ; ctx -> hops = hops ; * context_handle = ( gss_ctx_id_t ) ctx ; } if ( ctx != NULL ) { assert ( ctx -> initiator ) ; ctx -> hops -- ; assert ( ctx -> hops == hops ) ; } return ( ctx -> hops > 0 ) ?GSS_S_CONTINUE_NEEDED : GSS_S_COMPLETE ; } 