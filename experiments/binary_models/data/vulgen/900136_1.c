static void wipe_auth_tok_list ( struct list_head * auth_tok_list_head ) { struct ecryptfs_auth_tok_list_item * auth_tok_list_item ; struct ecryptfs_auth_tok_list_item * auth_tok_list_item_tmp ; list_for_each_entry_safe ( , , , ) { list_del ( & auth_tok_list_item -> list ) ; } } struct kmem_cache * ecryptfs_auth_tok_list_item_cache ; static int parse_tag_1_packet ( struct ecryptfs_crypt_stat * crypt_stat , unsigned char * data , struct list_head * auth_tok_list , struct ecryptfs_auth_tok * * new_auth_tok , size_t * packet_size , size_t max_packet_size ) { size_t body_size ; struct ecryptfs_auth_tok_list_item * auth_tok_list_item ; size_t length_size ; int rc = 0 ; ( * packet_size ) = 0 ; ( * new_auth_tok ) = NULL ; if ( unlikely ( max_packet_size < 12 ) ) { printk ( KERN_ERR "Invalid max packet size; must be>=12\n" ) ; rc = - EINVAL ; out } if ( data [ ( * packet_size ) ++ ] != ECRYPTFS_TAG_1_PACKET_TYPE ) { printk ( KERN_ERR "Enter w/ first byte != 0x%.2x\n" , ECRYPTFS_TAG_1_PACKET_TYPE ) ; rc = - EINVAL ; out } auth_tok_list_item = kmem_cache_zalloc ( ecryptfs_auth_tok_list_item_cache , GFP_KERNEL ) ; if ( ! auth_tok_list_item ) { printk ( KERN_ERR "Unable to allocate memory\n" ) ; rc = - ENOMEM ; out } ( * new_auth_tok ) = & auth_tok_list_item -> auth_tok ; rc = ecryptfs_parse_packet_length ( & data [ ( * packet_size ) ] , & body_size , & length_size ) ; if ( rc ) { printk ( KERN_WARNING "Error parsing packet length; " "rc = [%d]\n" , rc ) ; out_free } if ( unlikely ( body_size < ( ECRYPTFS_SIG_SIZE + 2 ) ) ) { printk ( KERN_WARNING "Invalid body size ([%td])\n" , body_size ) ; rc = - EINVAL ; out_free } ( * packet_size ) += length_size ; if ( unlikely ( ( * packet_size ) + body_size > max_packet_size ) ) { printk ( KERN_WARNING "Packet size exceeds max\n" ) ; rc = - EINVAL ; out_free } if ( unlikely ( data [ ( * packet_size ) ++ ] != 0x03 ) ) { printk ( KERN_WARNING "Unknown version number [%d]\n" , data [ ( * packet_size ) - 1 ] ) ; rc = - EINVAL ; out_free } ecryptfs_to_hex ( ( * new_auth_tok ) -> token . private_key . signature , & data [ ( * packet_size ) ] , ECRYPTFS_SIG_SIZE ) ; * packet_size += ECRYPTFS_SIG_SIZE ; ( * packet_size ) ++ ; ( * new_auth_tok ) -> session_key . encrypted_key_size = body_size - ( ECRYPTFS_SIG_SIZE + 2 ) ; if ( ( * new_auth_tok ) -> session_key . encrypted_key_size > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES ) { printk ( KERN_WARNING "Tag 1 packet contains key larger " "than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\n" ) ; rc = - EINVAL ; out_free } memcpy ( ( * new_auth_tok ) -> session_key . encrypted_key , & data [ ( * packet_size ) ] , ( body_size - ( ECRYPTFS_SIG_SIZE + 2 ) ) ) ; ( * packet_size ) += ( * new_auth_tok ) -> session_key . encrypted_key_size ; ( * new_auth_tok ) -> session_key . flags &= ~ ECRYPTFS_CONTAINS_DECRYPTED_KEY ; ( * new_auth_tok ) -> session_key . flags |= ECRYPTFS_CONTAINS_ENCRYPTED_KEY ; ( * new_auth_tok ) -> token_type = ECRYPTFS_PRIVATE_KEY ; ( * new_auth_tok ) -> flags = 0 ; ( * new_auth_tok ) -> session_key . flags &= ~ ( ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT ) ; ( * new_auth_tok ) -> session_key . flags &= ~ ( ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT ) ; list_add ( & auth_tok_list_item -> list , auth_tok_list ) ; out out_free ( * new_auth_tok ) = NULL ; memset ( auth_tok_list_item , 0 , sizeof ( ecryptfs_auth_tok_list_item ) ) ; kmem_cache_free ( ecryptfs_auth_tok_list_item_cache , auth_tok_list_item ) ; out if ( rc ) { ( * packet_size ) = 0 ; } return rc ; } 