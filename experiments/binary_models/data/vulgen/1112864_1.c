void uvm_total ( struct vmtotal * totalp ) { struct proc * p ; struct vm_map_entry * entry ; struct vm_map * map ; int paging ; memset ( totalp , 0 , sizeof totalp ) ; LIST_FOREACH ( , , ) { switch ( p -> p_stat ) { case 0 : continue ; case SSLEEP : case SSTOP : totalp -> t_sl ++ ; break ; case SRUN : case SONPROC : if ( p == p -> p_cpu -> ci_schedstate . spc_idleproc ) { continue ; } case SIDL : totalp -> t_rq ++ ; break ; } paging = 0 ; vm_map_lock ( map ) ; for ( map = & p -> p_vmspace -> vm_map , entry = map -> header . next ; entry != & map -> header ; entry = entry -> next ) { if ( entry -> is_a_map || entry -> is_sub_map || entry -> object . uvm_obj == NULL ) { continue ; } } vm_map_unlock ( map ) ; if ( paging ) { totalp -> t_pw ++ ; } } totalp -> t_free = uvmexp . free ; totalp -> t_vm = uvmexp . npages - uvmexp . free + uvmexp . swpginuse ; totalp -> t_avm = uvmexp . active + uvmexp . swpginuse ; totalp -> t_rm = uvmexp . npages - uvmexp . free ; totalp -> t_arm = uvmexp . active ; totalp -> t_vmshr = 0 ; totalp -> t_avmshr = 0 ; totalp -> t_rmshr = 0 ; totalp -> t_armshr = 0 ; } 