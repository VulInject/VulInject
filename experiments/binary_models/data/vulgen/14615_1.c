static int fsl_pwm_probe ( struct platform_device * pdev ) { struct fsl_pwm_chip * fpc ; struct resource * res ; void __iomem * base ; int ret ; fpc = devm_kzalloc ( & pdev -> dev , sizeof ( * fpc ) , GFP_KERNEL ) ; if ( ! fpc ) { return - ENOMEM ; } fpc -> chip . dev = & pdev -> dev ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; base = devm_ioremap_resource ( & pdev -> dev , res ) ; if ( IS_ERR ( base ) ) { return PTR_ERR ( base ) ; } fpc -> regmap = devm_regmap_init_mmio_clk ( & pdev -> dev , "ftm_sys" , base , & fsl_pwm_regmap_config ) ; if ( IS_ERR ( fpc -> regmap ) ) { dev_err ( & pdev -> dev , "regmap init failed\n" ) ; return PTR_ERR ( fpc -> regmap ) ; } fpc -> clk [ FSL_PWM_CLK_SYS ] = devm_clk_get ( & pdev -> dev , "ftm_sys" ) ; if ( IS_ERR ( fpc -> clk [ FSL_PWM_CLK_SYS ] ) ) { dev_err ( & pdev -> dev , "failed to get \"ftm_sys\" clock\n" ) ; return PTR_ERR ( fpc -> clk [ FSL_PWM_CLK_SYS ] ) ; } fpc -> clk [ FSL_PWM_CLK_FIX ] = devm_clk_get ( fpc -> chip . dev , "ftm_fix" ) ; if ( IS_ERR ( fpc -> clk [ FSL_PWM_CLK_FIX ] ) ) { return PTR_ERR ( fpc -> clk [ FSL_PWM_CLK_FIX ] ) ; } fpc -> clk [ FSL_PWM_CLK_EXT ] = devm_clk_get ( fpc -> chip . dev , "ftm_ext" ) ; if ( IS_ERR ( fpc -> clk [ FSL_PWM_CLK_EXT ] ) ) { return PTR_ERR ( fpc -> clk [ FSL_PWM_CLK_EXT ] ) ; } fpc -> clk [ FSL_PWM_CLK_CNTEN ] = devm_clk_get ( fpc -> chip . dev , "ftm_cnt_clk_en" ) ; if ( IS_ERR ( fpc -> clk [ FSL_PWM_CLK_CNTEN ] ) ) { return PTR_ERR ( fpc -> clk [ FSL_PWM_CLK_CNTEN ] ) ; } fpc -> chip . ops = & fsl_pwm_ops ; fpc -> chip . of_xlate = of_pwm_xlate_with_flags ; fpc -> chip . of_pwm_n_cells = 3 ; fpc -> chip . base = - 1 ; fpc -> chip . npwm = 8 ; ret = pwmchip_add ( & fpc -> chip ) ; if ( ret < 0 ) { dev_err ( & pdev -> dev , "failed to add PWM chip: %d\n" , ret ) ; return ret ; } platform_set_drvdata ( pdev , fpc ) ; return fsl_pwm_init ( fpc ) ; } 