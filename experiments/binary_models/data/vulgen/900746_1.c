static void t42_parse_font_matrix ( T42_Face face , T42_Loader loader ) static void t42_parse_encoding ( T42_Face face , T42_Loader loader ) static void t42_parse_charstrings ( T42_Face face , T42_Loader loader ) static void t42_parse_sfnts ( T42_Face face , T42_Loader loader ) static const T1_FieldRec t42_keywords [ ] { T1_FIELD_STRING ( "version" , , 0 ) T1_FIELD_STRING ( "Notice" , , 0 ) T1_FIELD_STRING ( "FullName" , , 0 ) T1_FIELD_STRING ( "FamilyName" , , 0 ) T1_FIELD_STRING ( "Weight" , , 0 ) T1_FIELD_NUM ( "ItalicAngle" , , 0 ) T1_FIELD_BOOL ( "isFixedPitch" , , 0 ) T1_FIELD_NUM ( "UnderlinePosition" , , 0 ) T1_FIELD_NUM ( "UnderlineThickness" , , 0 ) T1_FIELD_NUM ( "FSType" , , 0 ) T1_FIELD_KEY ( "FontName" , , 0 ) T1_FIELD_NUM ( "PaintType" , , 0 ) T1_FIELD_NUM ( "FontType" , , 0 ) T1_FIELD_FIXED ( "StrokeWidth" , , 0 ) T1_FIELD_BBOX ( "FontBBox" , , 0 ) T1_FIELD_CALLBACK ( "FontMatrix" , , 0 ) T1_FIELD_CALLBACK ( "Encoding" , , 0 ) T1_FIELD_CALLBACK ( "CharStrings" , , 0 ) T1_FIELD_CALLBACK ( "sfnts" , , 0 ) { 0 T1_FIELD_LOCATION_CID_INFO T1_FIELD_TYPE_NONE 0 0 0 0 0 0 } } ; ; { if ( ( p ) -> funcs . release ) { ( p ) -> funcs . release ( p ) ; } } 0 ; -> root . funcs . to_int ( & ( p ) -> root ) ( p ) -> root . funcs . to_bytes ( & ( p ) -> root , b , m , n , d ) ( p ) -> root . funcs . to_fixed_array ( & ( p ) -> root , m , f , t ) ( p ) -> root . funcs . to_token ( & ( p ) -> root , t ) ( p ) -> root . funcs . load_field ( & ( p ) -> root , f , o , m , pf ) ( p ) -> root . funcs . load_field_table ( , , , , ) FT_LOCAL_DEF ( ) t42_parser_init ( , , , ) { FT_Error error = FT_Err_Ok FT_Long size psaux -> ps_parser_funcs -> init ( & parser -> root , NULL , NULL , memory ) parser -> stream = stream parser -> base_len = 0 parser -> base_dict = NULL parser -> in_memory = 0 if ( FT_STREAM_SEEK ( 0L ) || FT_FRAME_ENTER ( 17 ) ) { Exit } } ; if ( ft_memcmp ( stream -> cursor , "%!PS-TrueTypeFont" , 17 ) != 0 ) { FT_TRACE2 ( ( "  not a Type42 font\n" ) ) ; error = FT_THROW ( Unknown_File_Format ) ; } FT_FRAME_EXIT ( ) ; size = ( FT_Long ) stream -> size ; if ( ! stream -> read ) { parser -> base_dict = ( FT_Byte * ) stream -> base + stream -> pos ; parser -> base_len = size ; parser -> in_memory = 1 ; if ( FT_STREAM_SKIP ( size ) ) { Exit } } else { if ( FT_ALLOC ( parser -> base_dict , size ) || FT_STREAM_READ ( parser -> base_dict , size ) ) { Exit } parser -> base_len = size ; } parser -> root . base = parser -> base_dict ; parser -> root . cursor = parser -> base_dict ; parser -> root . limit = parser -> root . cursor + parser -> base_len ; Exit if ( error && ! parser -> in_memory ) { FT_FREE ( parser -> base_dict ) ; } return error ; ( void ) t42_parser_done ( ) { FT_Memory memory = parser -> root . memory if ( ! parser -> in_memory ) { FT_FREE ( parser -> base_dict ) ; } parser -> root . funcs . done ( & parser -> root ) } ; int t42_is_space ( FT_Byte c ) { return ( c == ' ' || c == '\t' || c == '\r' || c == '\n' || c == '\f' || ; } 