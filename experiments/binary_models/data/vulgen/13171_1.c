int sftp_keys_send_hostkeys ( pool * p ) { int res , * nids = NULL ; pool * tmp_pool ; struct ssh2_packet * pkt ; unsigned char * buf , * ptr ; const unsigned char * hostkey_data = NULL ; uint32_t buflen , bufsz , hostkey_datalen ; if ( ! sftp_interop_supports_feature ( SFTP_SSH2_FEAT_HOSTKEYS ) ) { return 0 ; } if ( sftp_opts & SFTP_OPT_NO_HOSTKEY_ROTATION ) { return 0 ; } tmp_pool = make_sub_pool ( p ) ; pr_pool_tag ( tmp_pool , "hostkeys-00@openssh.com pool" ) ; pkt = sftp_ssh2_packet_create ( tmp_pool ) ; buflen = bufsz = 32768 ; ptr = buf = palloc ( pkt -> pool , bufsz ) ; sftp_msg_write_byte ( & buf , & buflen , SFTP_SSH2_MSG_GLOBAL_REQUEST ) ; sftp_msg_write_string ( & buf , & buflen , "hostkeys-00@openssh.com" ) ; sftp_msg_write_bool ( & buf , & buflen , FALSE ) ; res = sftp_keys_have_rsa_hostkey ( ) ; if ( res == 0 ) { hostkey_data = sftp_keys_get_hostkey_data ( tmp_pool , SFTP_KEY_RSA , & hostkey_datalen ) ; if ( hostkey_data != NULL ) { pr_trace_msg ( trace_channel , 17 , "adding RSA hostkey to hostkeys message" ) ; sftp_msg_write_data ( & buf , & buflen , hostkey_data , hostkey_datalen , TRUE ) ; } } res = sftp_keys_have_dsa_hostkey ( ) ; if ( res == 0 ) { hostkey_data = sftp_keys_get_hostkey_data ( tmp_pool , SFTP_KEY_DSA , & hostkey_datalen ) ; if ( hostkey_data != NULL ) { pr_trace_msg ( trace_channel , 17 , "adding DSA hostkey to hostkeys message" ) ; sftp_msg_write_data ( & buf , & buflen , hostkey_data , hostkey_datalen , TRUE ) ; } } res = sftp_keys_have_ed25519_hostkey ( ) ; if ( res == 0 ) { hostkey_data = sftp_keys_get_hostkey_data ( tmp_pool , SFTP_KEY_ED25519 , & hostkey_datalen ) ; if ( hostkey_data != NULL ) { pr_trace_msg ( trace_channel , 17 , "adding Ed25519 hostkey to hostkeys message" ) ; sftp_msg_write_data ( & buf , & buflen , hostkey_data , hostkey_datalen , TRUE ) ; } } res = sftp_keys_have_ed448_hostkey ( ) ; if ( res == 0 ) { hostkey_data = sftp_keys_get_hostkey_data ( tmp_pool , SFTP_KEY_ED448 , & hostkey_datalen ) ; if ( hostkey_data != NULL ) { pr_trace_msg ( trace_channel , 17 , "adding Ed448 hostkey to hostkeys message" ) ; sftp_msg_write_data ( & buf , & buflen , hostkey_data , hostkey_datalen , TRUE ) ; } } res = sftp_keys_have_ecdsa_hostkey ( tmp_pool , & nids ) ; if ( res > 0 ) { register int i ; for ( i = 0 ; i < res ; i ++ ) { enum sftp_key_type_e key_type ; const char * key_desc ; switch ( nids [ i ] ) { case NID_X9_62_prime256v1 : key_type = SFTP_KEY_ECDSA_256 ; key_desc = "ECDSA256" ; break ; case NID_secp384r1 : key_type = SFTP_KEY_ECDSA_384 ; key_desc = "ECDSA384" ; break ; case NID_secp521r1 : key_type = SFTP_KEY_ECDSA_521 ; key_desc = "ECDSA521" ; break ; default : continue ; } hostkey_data = sftp_keys_get_hostkey_data ( tmp_pool , key_type , & hostkey_datalen ) ; if ( hostkey_data != NULL ) { pr_trace_msg ( trace_channel , 17 , "adding %s hostkey to hostkeys message" , key_desc ) ; sftp_msg_write_data ( & buf , & buflen , hostkey_data , hostkey_datalen , TRUE ) ; } } } pkt -> payload = ptr ; pkt -> payload_len = ( bufsz - buflen ) ; pr_trace_msg ( trace_channel , 17 , "sending 'hostkeys-00@openssh.com' GLOBAL_REQUEST (%lu bytes)" , ( unsigned long ) pkt -> payload_len ) ; ( void ) sftp_ssh2_packet_write ( sftp_conn -> wfd , pkt ) ; destroy_pool ( tmp_pool ) ; return 0 ; } 