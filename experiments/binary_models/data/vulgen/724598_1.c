static int ext2_xattr_set2 ( struct inode * inode , struct buffer_head * old_bh , struct ext2_xattr_header * header ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * new_bh = NULL ; int error ; struct mb_cache * ea_block_cache = EA_BLOCK_CACHE ( inode ) ; if ( header ) { new_bh = ext2_xattr_cache_find ( inode , header ) ; if ( new_bh ) { if ( new_bh == old_bh ) { ea_bdebug ( new_bh , "keeping this block" ) ; } else { ea_bdebug ( new_bh , "reusing block" ) ; error = dquot_alloc_block ( inode , 1 ) ; if ( error ) { unlock_buffer ( new_bh ) ; cleanup } le32_add_cpu ( & HDR ( new_bh ) -> h_refcount , 1 ) ; ea_bdebug ( new_bh , "refcount now=%d" , le32_to_cpu ( HDR ( new_bh ) -> h_refcount ) ) ; } unlock_buffer ( new_bh ) ; } if ( old_bh && header == HDR ( old_bh ) ) { new_bh = old_bh ; get_bh ( new_bh ) ; ext2_xattr_cache_insert ( ea_block_cache , new_bh ) ; } else { ext2_fsblk_t goal = ext2_group_first_block_no ( sb , EXT2_I ( inode ) -> i_block_group ) ; if ( error ) { cleanup } ea_idebug ( inode , "creating block %d" , block ) ; new_bh = sb_getblk ( sb , block ) ; if ( unlikely ( ! new_bh ) ) { ext2_free_blocks ( inode , block , 1 ) ; mark_inode_dirty ( inode ) ; error = - ENOMEM ; cleanup } lock_buffer ( new_bh ) ; memcpy ( new_bh -> b_data , header , new_bh -> b_size ) ; set_buffer_uptodate ( new_bh ) ; unlock_buffer ( new_bh ) ; ext2_xattr_cache_insert ( ea_block_cache , new_bh ) ; ext2_xattr_update_super_block ( sb ) ; } mark_buffer_dirty ( new_bh ) ; if ( IS_SYNC ( inode ) ) { sync_dirty_buffer ( new_bh ) ; error = - EIO ; if ( buffer_req ( new_bh ) && ! buffer_uptodate ( new_bh ) ) { cleanup } } } EXT2_I ( inode ) -> i_file_acl = new_bh ?new_bh -> b_blocknr : 0 ; inode -> i_ctime = current_time ( inode ) ; if ( IS_SYNC ( inode ) ) { error = sync_inode_metadata ( inode , 1 ) ; if ( error && error != - ENOSPC ) { if ( new_bh && new_bh != old_bh ) { dquot_free_block_nodirty ( inode , 1 ) ; mark_inode_dirty ( inode ) ; } cleanup } } else { mark_inode_dirty ( inode ) ; } error = 0 ; if ( old_bh && old_bh != new_bh ) { ext2_xattr_release_block ( inode , old_bh ) ; } cleanup brelse ( new_bh ) ; return error ; } 