mbuf * int int tsp_bus_dmamap_load_uio_sgmap ( bus_dma_tag_t , bus_dmamap_t , struct uio * , int ) int tsp_bus_dmamap_load_raw_sgmap ( bus_dma_tag_t , bus_dmamap_t , bus_dma_segment_t * , int , bus_size_t , int ) void tsp_bus_dmamap_unload_sgmap ( bus_dma_tag_t , bus_dmamap_t ) void tsp_tlb_invalidate ( struct tsp_config * ) void tsp_dma_init ( struct device * tsp , struct tsp_config * pcp ) { int i ; bus_dma_tag_t t ; struct ts_pchip * pccsr = pcp -> pc_csr ; bus_addr_t dwbase , dwlen , sgwbase , sgwlen , tbase ; static const map_expected { u_int32_t base , mask , physbase , enables ; } , premap [ 4 ] { { 0x00800000 0x00700000 0x00000000 WSBA_ENA | WSBA_SG } { 0x80000000 0x3ff00000 0x00000000 WSBA_ENA } { 0 0 0 } { 0 0 0 } } ; alpha_mb ( ) ; for ( i = 0 ; i < 4 ; ++ i ) { pccsr -> tsp_wsba [ i ] . tsg_r = premap [ i ] . base | premap [ i ] . enables ; pccsr -> tsp_wsm [ i ] . tsg_r = premap [ i ] . mask ; if ( ( premap [ i ] . enables & WSBA_SG ) == 0 ) { pccsr -> tsp_tba [ i ] . tsg_r = premap [ i ] . physbase ; } } alpha_mb ( ) ; t = & pcp -> pc_dmat_direct ; t -> _cookie = pcp ; t -> _wbase = dwbase = WSBA_ADDR ( pccsr -> tsp_wsba [ 1 ] . tsg_r ) ; t -> _wsize = dwlen = WSM_LEN ( pccsr -> tsp_wsm [ 1 ] . tsg_r ) ; t -> _next_window = & pcp -> pc_dmat_sgmap ; t -> _boundary = 0 ; t -> _sgmap = NULL ; t -> _get_tag = tsp_dma_get_tag ; t -> _dmamap_create = alpha_sgmap_dmamap_create ; t -> _dmamap_destroy = alpha_sgmap_dmamap_destroy ; t -> _dmamap_load = _bus_dmamap_load_direct ; t -> _dmamap_load_mbuf = _bus_dmamap_load_mbuf_direct ; t -> _dmamap_load_uio = _bus_dmamap_load_uio_direct ; t -> _dmamap_load_raw = _bus_dmamap_load_raw_direct ; t -> _dmamap_unload = _bus_dmamap_unload ; t -> _dmamap_sync = _bus_dmamap_sync ; t -> _dmamem_alloc = _bus_dmamem_alloc ; t -> _dmamem_free = _bus_dmamem_free ; t -> _dmamem_map = _bus_dmamem_map ; t -> _dmamem_unmap = _bus_dmamem_unmap ; t -> _dmamem_mmap = _bus_dmamem_mmap ; t = & pcp -> pc_dmat_sgmap ; t -> _cookie = pcp ; t -> _wbase = sgwbase = WSBA_ADDR ( pccsr -> tsp_wsba [ 0 ] . tsg_r ) ; t -> _wsize = sgwlen = WSM_LEN ( pccsr -> tsp_wsm [ 0 ] . tsg_r ) ; t -> _next_window = NULL ; t -> _boundary = 0 ; t -> _sgmap = & pcp -> pc_sgmap ; t -> _get_tag = tsp_dma_get_tag ; t -> _dmamap_create = alpha_sgmap_dmamap_create ; t -> _dmamap_destroy = alpha_sgmap_dmamap_destroy ; t -> _dmamap_load = tsp_bus_dmamap_load_sgmap ; t -> _dmamap_load_mbuf = tsp_bus_dmamap_load_mbuf_sgmap ; t -> _dmamap_load_uio = tsp_bus_dmamap_load_uio_sgmap ; t -> _dmamap_load_raw = tsp_bus_dmamap_load_raw_sgmap ; t -> _dmamap_unload = tsp_bus_dmamap_unload_sgmap ; t -> _dmamap_sync = _bus_dmamap_sync ; t -> _dmamem_alloc = _bus_dmamem_alloc ; t -> _dmamem_free = _bus_dmamem_free ; t -> _dmamem_map = _bus_dmamem_map ; t -> _dmamem_unmap = _bus_dmamem_unmap ; t -> _dmamem_mmap = _bus_dmamem_mmap ; alpha_sgmap_init ( t , & pcp -> pc_sgmap , "tsp_sgmap" , sgwbase , 0 , sgwlen , sizeof ( u_int64_t ) , NULL , ( 32 * 1024 ) ) ; if ( ( sgwbase <= dwbase && dwbase < sgwbase + sgwlen ) || ( dwbase <= sgwbase && sgwbase < dwbase + dwlen ) ) { panic ( "%s: overlap sg 0x%lx len 0x%lx d 0x%lx len 0x%lx" , __func__ , sgwbase , sgwlen , dwbase , dwlen ) ; } tbase = pcp -> pc_sgmap . aps_ptpa ; if ( tbase & ~ 0x7fffffc00UL ) { panic ( "tsp_dma_init: bad page table address" ) ; } alpha_mb ( ) ; pccsr -> tsp_tba [ 0 ] . tsg_r = tbase ; alpha_mb ( ) ; tsp_tlb_invalidate ( pcp ) ; alpha_mb ( ) ; { extern paddr_t alpha_XXX_dmamap_or ; alpha_XXX_dmamap_or = dwbase ; } } 