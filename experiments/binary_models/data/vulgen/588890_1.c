CURLcode Curl_read ( struct connectdata * conn , curl_socket_t sockfd , char * buf , size_t sizerequested , ssize_t * n ) { CURLcode result = CURLE_RECV_ERROR ; ssize_t nread = 0 ; size_t bytesfromsocket = 0 ; char * buffertofill = NULL ; int num = ( sockfd == conn -> sock [ SECONDARYSOCKET ] ) ; * n = 0 ; if ( pipelining ) { size_t bytestocopy = CURLMIN ( conn -> buf_len - conn -> read_pos , sizerequested ) ; if ( bytestocopy > 0 ) { memcpy ( buf , conn -> master_buffer + conn -> read_pos , bytestocopy ) ; conn -> read_pos += bytestocopy ; conn -> bits . stream_was_rewound = FALSE ; * n = ( ssize_t ) bytestocopy ; return CURLE_OK ; } bytesfromsocket = CURLMIN ( sizerequested , BUFSIZE * sizeof ( char ) ) ; buffertofill = conn -> master_buffer ; } else { bytesfromsocket = CURLMIN ( ( long ) sizerequested , conn -> data -> set . buffer_size ?conn -> data -> set . buffer_size : BUFSIZE ) ; buffertofill = buf ; } nread = conn -> recv [ num ] ( conn , num , buffertofill , bytesfromsocket , & result ) ; if ( nread < 0 ) { return result ; } if ( pipelining ) { memcpy ( buf , conn -> master_buffer , nread ) ; conn -> buf_len = nread ; conn -> read_pos = nread ; } * n += nread ; return CURLE_OK ; } 