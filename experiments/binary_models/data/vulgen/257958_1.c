static int stm32_gpiolib_register_bank ( struct stm32_pinctrl * pctl , struct device_node * np ) { struct stm32_gpio_bank * bank = & pctl -> banks [ pctl -> nbanks ] ; struct pinctrl_gpio_range * range = & bank -> range ; struct of_phandle_args args ; struct device * dev = pctl -> dev ; struct resource res ; struct reset_control * rstc ; int npins = STM32_GPIO_PINS_PER_BANK ; int bank_nr , err ; rstc = of_reset_control_get ( np , NULL ) ; if ( ! IS_ERR ( rstc ) ) { reset_control_deassert ( rstc ) ; } if ( of_address_to_resource ( np , 0 , & res ) ) { return - ENODEV ; } bank -> base = devm_ioremap_resource ( dev , & res ) ; if ( IS_ERR ( bank -> base ) ) { return PTR_ERR ( bank -> base ) ; } bank -> clk = of_clk_get_by_name ( np , NULL ) ; if ( IS_ERR ( bank -> clk ) ) { dev_err ( dev , "failed to get clk (%ld)\n" , PTR_ERR ( bank -> clk ) ) ; return PTR_ERR ( bank -> clk ) ; } err = clk_prepare ( bank -> clk ) ; if ( err ) { dev_err ( dev , "failed to prepare clk (%d)\n" , err ) ; return err ; } bank -> gpio_chip = stm32_gpio_template ; of_property_read_string ( np , "st,bank-name" , & bank -> gpio_chip . label ) ; if ( ! of_parse_phandle_with_fixed_args ( np , "gpio-ranges" , 3 , 0 , & args ) ) { bank_nr = args . args [ 1 ] / STM32_GPIO_PINS_PER_BANK ; bank -> gpio_chip . base = args . args [ 1 ] ; } else { bank -> gpio_chip . base = bank_nr * STM32_GPIO_PINS_PER_BANK ; range -> name = bank -> gpio_chip . label ; range -> id = bank_nr ; range -> pin_base = range -> id * STM32_GPIO_PINS_PER_BANK ; range -> base = range -> id * STM32_GPIO_PINS_PER_BANK ; range -> npins = npins ; range -> gc = & bank -> gpio_chip ; pinctrl_add_gpio_range ( pctl -> pctl_dev , & pctl -> banks [ bank_nr ] . range ) ; } bank -> gpio_chip . base = bank_nr * STM32_GPIO_PINS_PER_BANK ; bank -> gpio_chip . ngpio = npins ; bank -> gpio_chip . of_node = np ; bank -> gpio_chip . parent = dev ; bank -> bank_nr = bank_nr ; spin_lock_init ( & bank -> lock ) ; bank -> fwnode = of_node_to_fwnode ( np ) ; bank -> domain = irq_domain_create_hierarchy ( pctl -> domain , 0 , STM32_GPIO_IRQ_LINE , bank -> fwnode , & stm32_gpio_domain_ops , bank ) ; if ( ! bank -> domain ) { return - ENODEV ; } err = gpiochip_add_data ( & bank -> gpio_chip , bank ) ; if ( err ) { dev_err ( dev , "Failed to add gpiochip(%d)!\n" , bank_nr ) ; return err ; } dev_info ( dev , "%s bank added\n" , bank -> gpio_chip . label ) ; return 0 ; } 