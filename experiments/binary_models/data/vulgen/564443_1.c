static int m66592_probe ( struct platform_device * pdev ) { struct resource * res , * ires ; void __iomem * reg = NULL ; struct m66592 * m66592 = NULL ; char clk_name [ 8 ] ; int ret = 0 ; int i ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! res ) { ret = - ENODEV ; pr_err ( "platform_get_resource error.\n" ) ; clean_up } ires = platform_get_resource ( pdev , IORESOURCE_IRQ , 0 ) ; if ( ! ires ) { ret = - ENODEV ; dev_err ( & pdev -> dev , "platform_get_resource IORESOURCE_IRQ error.\n" ) ; clean_up } reg = ioremap ( res -> start , resource_size ( res ) ) ; if ( reg == NULL ) { ret = - ENOMEM ; pr_err ( "ioremap error.\n" ) ; clean_up } if ( dev_get_platdata ( & pdev -> dev ) == NULL ) { dev_err ( & pdev -> dev , "no platform data\n" ) ; ret = - ENODEV ; clean_up } m66592 = kzalloc ( sizeof ( m66592 ) , GFP_KERNEL ) ; if ( m66592 == NULL ) { ret = - ENOMEM ; clean_up } m66592 -> pdata = dev_get_platdata ( & pdev -> dev ) ; m66592 -> irq_trigger = ires -> flags & IRQF_TRIGGER_MASK ; platform_set_drvdata ( pdev , m66592 ) ; m66592 -> gadget . ops = & m66592_gadget_ops ; m66592 -> gadget . max_speed = USB_SPEED_HIGH ; m66592 -> gadget . name = udc_name ; init_timer ( & m66592 -> timer ) ; m66592 -> timer . function = m66592_timer ; m66592 -> timer . data = ( unsigned long ) m66592 ; m66592 -> reg = reg ; ret = request_irq ( ires -> start , m66592_irq , IRQF_SHARED , udc_name , m66592 ) ; if ( ret < 0 ) { pr_err ( "request_irq error (%d)\n" , ret ) ; clean_up } if ( m66592 -> pdata -> on_chip ) { snprintf ( clk_name , sizeof ( clk_name ) , "usbf%d" , pdev -> id ) ; m66592 -> clk = clk_get ( & pdev -> dev , clk_name ) ; if ( IS_ERR ( m66592 -> clk ) ) { dev_err ( & pdev -> dev , "cannot get clock \"%s\"\n" , clk_name ) ; ret = PTR_ERR ( m66592 -> clk ) ; clean_up2 } clk_enable ( m66592 -> clk ) ; } INIT_LIST_HEAD ( & m66592 -> gadget . ep_list ) ; m66592 -> gadget . ep0 = & m66592 -> ep [ 0 ] . ep ; INIT_LIST_HEAD ( & m66592 -> gadget . ep0 -> ep_list ) ; for ( i = 0 ; i < M66592_MAX_NUM_PIPE ; i ++ ) { struct m66592_ep * ep = & m66592 -> ep [ i ] ; if ( i != 0 ) { INIT_LIST_HEAD ( & m66592 -> ep [ i ] . ep . ep_list ) ; list_add_tail ( & m66592 -> ep [ i ] . ep . ep_list , & m66592 -> gadget . ep_list ) ; } ep -> m66592 = m66592 ; INIT_LIST_HEAD ( & ep -> queue ) ; ep -> ep . name = m66592_ep_name [ i ] ; ep -> ep . ops = & m66592_ep_ops ; usb_ep_set_maxpacket_limit ( & ep -> ep , 512 ) ; if ( i == 0 ) { ep -> ep . caps . type_control = true ; } else { ep -> ep . caps . type_iso = true ; ep -> ep . caps . type_bulk = true ; ep -> ep . caps . type_int = true ; } ep -> ep . caps . dir_in = true ; ep -> ep . caps . dir_out = true ; } usb_ep_set_maxpacket_limit ( & m66592 -> ep [ 0 ] . ep , 64 ) ; m66592 -> ep [ 0 ] . pipenum = 0 ; m66592 -> ep [ 0 ] . fifoaddr = M66592_CFIFO ; m66592 -> ep [ 0 ] . fifosel = M66592_CFIFOSEL ; m66592 -> ep [ 0 ] . fifoctr = M66592_CFIFOCTR ; m66592 -> ep [ 0 ] . fifotrn = 0 ; m66592 -> ep [ 0 ] . pipectr = get_pipectr_addr ( 0 ) ; m66592 -> pipenum2ep [ 0 ] = & m66592 -> ep [ 0 ] ; m66592 -> epaddr2ep [ 0 ] = & m66592 -> ep [ 0 ] ; m66592 -> ep0_req = m66592_alloc_request ( & m66592 -> ep [ 0 ] . ep , GFP_KERNEL ) ; if ( m66592 -> ep0_req == NULL ) { ret = - ENOMEM ; clean_up3 } m66592 -> ep0_req -> complete = nop_completion ; init_controller ( m66592 ) ; ret = usb_add_gadget_udc ( & pdev -> dev , & m66592 -> gadget ) ; if ( ret ) { err_add_udc } dev_info ( & pdev -> dev , "version %s\n" , DRIVER_VERSION ) ; return 0 ; err_add_udc m66592_free_request ( & m66592 -> ep [ 0 ] . ep , m66592 -> ep0_req ) ; clean_up3 if ( m66592 -> pdata -> on_chip ) { clk_disable ( m66592 -> clk ) ; clk_put ( m66592 -> clk ) ; } clean_up2 free_irq ( ires -> start , m66592 ) ; clean_up if ( m66592 ) { if ( m66592 -> ep0_req ) { m66592_free_request ( & m66592 -> ep [ 0 ] . ep , m66592 -> ep0_req ) ; } kfree ( m66592 ) ; } if ( reg ) { iounmap ( reg ) ; } return ret ; } 