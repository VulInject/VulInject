ssize_t seq_read ( struct file * file , char __user * buf , size_t size , loff_t * ppos ) { struct seq_file * m = file -> private_data ; size_t copied = 0 ; loff_t pos ; size_t n ; void * p ; int err = 0 ; mutex_lock ( & m -> lock ) ; m -> version = file -> f_version ; if ( * ppos == 0 ) { m -> index = 0 ; } if ( unlikely ( * ppos != m -> read_pos ) ) { while ( ( err = traverse ( m , * ppos ) ) == - EAGAIN ) { } if ( err ) { m -> read_pos = 0 ; m -> version = 0 ; m -> index = 0 ; m -> count = 0 ; Done } else { m -> read_pos = * ppos ; } } if ( ! m -> buf ) { if ( ! m -> buf ) { Enomem } } if ( m -> count ) { n = min ( m -> count , size ) ; err = copy_to_user ( buf , m -> buf + m -> from , n ) ; if ( err ) { Efault } m -> count -= n ; m -> from += n ; size -= n ; buf += n ; copied += n ; if ( ! m -> count ) { m -> from = 0 ; m -> index ++ ; } if ( ! size ) { Done } } pos = m -> index ; p = m -> op -> start ( m , & pos ) ; while ( 1 ) { err = PTR_ERR ( p ) ; if ( ! p || IS_ERR ( p ) ) { break ; } err = m -> op -> show ( m , p ) ; if ( err < 0 ) { break ; } if ( unlikely ( err ) ) { m -> count = 0 ; } if ( unlikely ( ! m -> count ) ) { p = m -> op -> next ( m , p , & pos ) ; m -> index = pos ; continue ; } if ( m -> count < m -> size ) { Fill } m -> op -> stop ( m , p ) ; kvfree ( m -> buf ) ; m -> count = 0 ; m -> buf = seq_buf_alloc ( m -> size <<= 1 ) ; if ( ! m -> buf ) { Enomem } m -> version = 0 ; pos = m -> index ; p = m -> op -> start ( m , & pos ) ; } m -> op -> stop ( m , p ) ; m -> count = 0 ; Done Fill while ( m -> count < size ) { size_t offs = m -> count ; loff_t next = pos ; p = m -> op -> next ( m , p , & next ) ; if ( ! p || IS_ERR ( p ) ) { err = PTR_ERR ( p ) ; break ; } err = m -> op -> show ( m , p ) ; if ( seq_has_overflowed ( m ) || err ) { m -> count = offs ; if ( likely ( err <= 0 ) ) { break ; } } pos = next ; } m -> op -> stop ( m , p ) ; n = min ( m -> count , size ) ; err = copy_to_user ( buf , m -> buf , n ) ; if ( err ) { Efault } copied += n ; m -> count -= n ; if ( m -> count ) { m -> from = n ; } else { pos ++ ; } m -> index = pos ; Done if ( ! copied ) { copied = err ; } else { * ppos += copied ; m -> read_pos += copied ; } file -> f_version = m -> version ; mutex_unlock ( & m -> lock ) ; return copied ; Enomem err = - ENOMEM ; Done Efault err = - EFAULT ; Done } 