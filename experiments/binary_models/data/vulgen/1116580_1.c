static int hermon_hw_init ( hermon_state_t * state ) { hermon_drv_cleanup_level_t cleanup ; sm_nodeinfo_t nodeinfo ; uint64_t clr_intr_offset ; int status ; uint32_t fw_size ; uint64_t offset ; cleanup = HERMON_DRV_CLEANUP_LEVEL0 ; state -> hs_reg_accattr . devacc_attr_version = DDI_DEVICE_ATTR_V1 ; state -> hs_reg_accattr . devacc_attr_endian_flags = DDI_STRUCTURE_BE_ACC ; state -> hs_reg_accattr . devacc_attr_dataorder = DDI_STRICTORDER_ACC ; state -> hs_reg_accattr . devacc_attr_access = DDI_DEFAULT_ACC ; state -> hs_fm_accattr . devacc_attr_version = hermon_devacc_attr_version ( state ) ; state -> hs_fm_accattr . devacc_attr_endian_flags = DDI_STRUCTURE_BE_ACC ; state -> hs_fm_accattr . devacc_attr_dataorder = DDI_STRICTORDER_ACC ; state -> hs_fm_accattr . devacc_attr_access = hermon_devacc_attr_access ( state ) ; status = hermon_pci_config_setup ( state , & state -> hs_fm_pcihdl ) ; if ( status != DDI_SUCCESS ) { hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_PCI_config_space_regmap_fail" ) ; return ( DDI_FAILURE ) ; } hermon_set_msix_info ( state ) ; status = hermon_regs_map_setup ( state , HERMON_CMD_BAR , & state -> hs_reg_cmd_baseaddr , 0 , 0 , & state -> hs_fm_accattr , & state -> hs_fm_cmdhdl ) ; if ( status != DDI_SUCCESS ) { hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_CMD_BAR_regmap_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL1 ; status = ddi_regs_map_setup ( state -> hs_dip , HERMON_MSIX_BAR , & state -> hs_reg_msi_baseaddr , 0 , 0 , & state -> hs_reg_accattr , & state -> hs_reg_msihdl ) ; if ( status != DDI_SUCCESS ) { hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_MSIX_BAR_regmap_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL2 ; state -> hs_cmd_regs . hcr = ( hermon_hw_hcr_t * ) ( ( uintptr_t ) state -> hs_reg_cmd_baseaddr + HERMON_CMD_HCR_OFFSET ) ; state -> hs_cmd_toggle = 0 ; state -> hs_cmd_regs . sw_reset = ( uint32_t * ) ( ( uintptr_t ) state -> hs_reg_cmd_baseaddr + HERMON_CMD_SW_RESET_OFFSET ) ; state -> hs_cmd_regs . sw_semaphore = ( uint32_t * ) ( ( uintptr_t ) state -> hs_reg_cmd_baseaddr + HERMON_CMD_SW_SEMAPHORE_OFFSET ) ; bzero ( & state -> hs_hcaparams , sizeof ( hermon_hw_initqueryhca_s ) ) ; status = hermon_cfg_profile_init_phase1 ( state ) ; if ( status != DDI_SUCCESS ) { hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_cfginit1_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL3 ; status = hermon_sw_reset ( state ) ; if ( status != HERMON_CMD_SUCCESS ) { hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_sw_reset_fail" ) ; return ( DDI_FAILURE ) ; } status = hermon_rsrc_init_phase1 ( state ) ; if ( status != DDI_SUCCESS ) { hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_rsrcinit1_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL4 ; status = hermon_cmn_query_cmd_post ( state , QUERY_FW , 0 , 0 , & state -> hs_fw , sizeof ( hermon_hw_queryfw_t ) , HERMON_CMD_NOSLEEP_SPIN ) ; if ( status != HERMON_CMD_SUCCESS ) { cmn_err ( CE_NOTE , "QUERY_FW command failed: %08x\n" , status ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_query_fw_cmd_fail" ) ; return ( DDI_FAILURE ) ; } status = hermon_fw_version_check ( state ) ; if ( status != DDI_SUCCESS ) { HERMON_FMANOTE ( state , HERMON_FMA_FWVER ) ; if ( state -> hs_operational_mode == HERMON_HCA_MODE ) { cmn_err ( CE_CONT , "Unsupported Hermon FW version: " "expected: %04d.%04d.%04d, " "actual: %04d.%04d.%04d\n" , HERMON_FW_VER_MAJOR , HERMON_FW_VER_MINOR , HERMON_FW_VER_SUBMINOR , state -> hs_fw . fw_rev_major , state -> hs_fw . fw_rev_minor , state -> hs_fw . fw_rev_subminor ) ; } else { cmn_err ( CE_CONT , "Unsupported FW version: " "%04d.%04d.%04d\n" , state -> hs_fw . fw_rev_major , state -> hs_fw . fw_rev_minor , state -> hs_fw . fw_rev_subminor ) ; } state -> hs_operational_mode = HERMON_MAINTENANCE_MODE ; state -> hs_fm_degraded_reason = HCA_FW_MISMATCH ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_checkfwver_fail" ) ; return ( HERMON_CMD_BAD_NVMEM ) ; } clr_intr_offset = state -> hs_fw . clr_intr_offs & HERMON_CMD_OFFSET_MASK ; state -> hs_cmd_regs . clr_intr = ( uint64_t * ) ( uintptr_t ) ( state -> hs_reg_cmd_baseaddr + clr_intr_offset ) ; state -> hs_cmd_regs . fw_err_buf = ( uint32_t * ) ( uintptr_t ) ( state -> hs_reg_cmd_baseaddr + state -> hs_fw . error_buf_addr ) ; if ( ! hermon_no_inter_err_chk ) { state -> hs_fm_poll_thread = ddi_periodic_add ( hermon_inter_err_chk , ( void * ) state , FM_POLL_INTERVAL , DDI_IPL_0 ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL5 ; fw_size = 1 << highbit ( state -> hs_fw . fw_pages ) ; state -> hs_fw_dma . length = fw_size << HERMON_PAGESHIFT ; status = hermon_dma_alloc ( state , & state -> hs_fw_dma , MAP_FA ) ; if ( status != DDI_SUCCESS ) { cmn_err ( CE_NOTE , "FW alloc failed\n" ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_dma_alloc_fw_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL6 ; status = hermon_run_fw_cmd_post ( state ) ; if ( status != DDI_SUCCESS ) { cmn_err ( CE_NOTE , "RUN_FW command failed: 0x%08x\n" , status ) ; if ( status == HERMON_CMD_BAD_NVMEM ) { state -> hs_operational_mode = HERMON_MAINTENANCE_MODE ; state -> hs_fm_degraded_reason = HCA_FW_CORRUPT ; } hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_run_fw_fail" ) ; return ( status == HERMON_CMD_BAD_NVMEM ?HERMON_CMD_BAD_NVMEM : DDI_FAILURE ) ; } status = hermon_cmn_query_cmd_post ( state , QUERY_DEV_CAP , 0 , 0 , & state -> hs_devlim , sizeof ( hermon_hw_querydevlim_t ) , HERMON_CMD_NOSLEEP_SPIN ) ; if ( status != HERMON_CMD_SUCCESS ) { cmn_err ( CE_NOTE , "QUERY_DEV_CAP command failed: 0x%08x\n" , status ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_devcap_fail" ) ; return ( DDI_FAILURE ) ; } state -> hs_rsvd_eqs = max ( state -> hs_devlim . num_rsvd_eq , ( 4 * state -> hs_devlim . num_rsvd_uar ) ) ; if ( state -> hs_devlim . blu_flm ) { offset = ( uint64_t ) 1 << ( state -> hs_devlim . log_max_uar_sz + 20 ) ; } else { offset = 0 ; } status = hermon_regs_map_setup ( state , HERMON_UAR_BAR , & state -> hs_reg_uar_baseaddr , 0 , offset , & state -> hs_fm_accattr , & state -> hs_fm_uarhdl ) ; if ( status != DDI_SUCCESS ) { HERMON_ATTACH_MSG ( state -> hs_attach_buf , "UAR BAR mapping" ) ; return ( DDI_FAILURE ) ; } if ( state -> hs_devlim . blu_flm ) { offset = ( uint64_t ) 1 << ( state -> hs_devlim . log_max_uar_sz + 20 ) ; status = ddi_regs_map_setup ( state -> hs_dip , HERMON_UAR_BAR , & state -> hs_reg_bf_baseaddr , offset , offset , & state -> hs_reg_accattr , & state -> hs_reg_bfhdl ) ; if ( status != DDI_SUCCESS ) { HERMON_ATTACH_MSG ( state -> hs_attach_buf , "BlueFlame BAR mapping" ) ; return ( DDI_FAILURE ) ; } state -> hs_bf_offset = offset ; } cleanup = HERMON_DRV_CLEANUP_LEVEL7 ; status = hermon_cmn_query_cmd_post ( state , QUERY_PORT , 0 , 0x01 , & state -> hs_queryport , sizeof ( hermon_hw_query_port_t ) , HERMON_CMD_NOSLEEP_SPIN ) ; if ( status != HERMON_CMD_SUCCESS ) { cmn_err ( CE_NOTE , "QUERY_PORT command failed: 0x%08x\n" , status ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_queryport_fail" ) ; return ( DDI_FAILURE ) ; } status = hermon_cfg_profile_init_phase2 ( state ) ; if ( status != DDI_SUCCESS ) { cmn_err ( CE_NOTE , "CFG phase 2 failed: 0x%08x\n" , status ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_cfginit2_fail" ) ; return ( DDI_FAILURE ) ; } state -> hs_icm_sz = hermon_size_icm ( state ) ; status = hermon_set_icm_size_cmd_post ( state ) ; if ( status != DDI_SUCCESS ) { cmn_err ( CE_NOTE , "Hermon: SET_ICM_SIZE cmd failed: 0x%08x\n" , status ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_seticmsz_fail" ) ; return ( DDI_FAILURE ) ; } state -> hs_icma_dma . length = 1 << highbit ( state -> hs_icma_sz ) ; status = hermon_dma_alloc ( state , & state -> hs_icma_dma , MAP_ICM_AUX ) ; if ( status != DDI_SUCCESS ) { cmn_err ( CE_NOTE , "failed to alloc (0x%llx) bytes for ICMA\n" , ( longlong_t ) state -> hs_icma_dma . length ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_dma_alloc_icm_aux_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL8 ; cleanup = HERMON_DRV_CLEANUP_LEVEL9 ; state -> hs_icm = kmem_zalloc ( HERMON_NUM_ICM_RESOURCES * sizeof ( hermon_icm_table_t ) , KM_SLEEP ) ; status = hermon_icm_config_setup ( state , & state -> hs_hcaparams ) ; if ( status != HERMON_CMD_SUCCESS ) { cmn_err ( CE_NOTE , "ICM configuration failed\n" ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_icm_config_setup_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL10 ; status = hermon_init_hca_cmd_post ( state , & state -> hs_hcaparams , HERMON_CMD_NOSLEEP_SPIN ) ; if ( status != HERMON_CMD_SUCCESS ) { cmn_err ( CE_NOTE , "INIT_HCA command failed: %08x\n" , status ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_hca_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL11 ; status = hermon_rsrc_init_phase2 ( state ) ; if ( status != DDI_SUCCESS ) { hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_rsrcinit2_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL12 ; status = hermon_cmn_query_cmd_post ( state , QUERY_ADAPTER , 0 , 0 , & state -> hs_adapter , sizeof ( hermon_hw_queryadapter_t ) , HERMON_CMD_NOSLEEP_SPIN ) ; if ( status != HERMON_CMD_SUCCESS ) { cmn_err ( CE_NOTE , "Hermon: QUERY_ADAPTER command failed: %08x\n" , status ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_query_adapter_fail" ) ; return ( DDI_FAILURE ) ; } status = hermon_pd_alloc ( state , & state -> hs_pdhdl_internal , HERMON_SLEEP ) ; if ( status != DDI_SUCCESS ) { cmn_err ( CE_NOTE , "failed to alloc internal PD\n" ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_internal_pd_alloc_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL13 ; status = hermon_internal_uarpg_init ( state ) ; if ( status != DDI_SUCCESS ) { cmn_err ( CE_NOTE , "failed to setup internal UAR\n" ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_internal_uarpg_alloc_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL14 ; status = hermon_intr_or_msi_init ( state ) ; if ( status != DDI_SUCCESS ) { cmn_err ( CE_NOTE , "failed to setup INTR/MSI\n" ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_intr_or_msi_init_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL15 ; status = hermon_isr_init ( state ) ; if ( status != DDI_SUCCESS ) { cmn_err ( CE_NOTE , "failed to init isr\n" ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_isrinit_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL16 ; status = hermon_eq_init_all ( state ) ; if ( status != DDI_SUCCESS ) { cmn_err ( CE_NOTE , "failed to init EQs\n" ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_eqinitall_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL17 ; status = hermon_special_qp_contexts_reserve ( state ) ; if ( status != DDI_SUCCESS ) { cmn_err ( CE_NOTE , "failed to init special QPs\n" ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_rsrv_sqp_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL18 ; status = hermon_mcg_init ( state ) ; if ( status != DDI_SUCCESS ) { cmn_err ( CE_NOTE , "failed to init multicast\n" ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_mcg_init_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_LEVEL19 ; status = hermon_hca_port_init ( state ) ; if ( status != DDI_SUCCESS ) { cmn_err ( CE_NOTE , "failed to init HCA Port\n" ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_hca_port_init_fail" ) ; return ( DDI_FAILURE ) ; } cleanup = HERMON_DRV_CLEANUP_ALL ; status = hermon_getnodeinfo_cmd_post ( state , HERMON_CMD_NOSLEEP_SPIN , & nodeinfo ) ; if ( status != HERMON_CMD_SUCCESS ) { cmn_err ( CE_NOTE , "GetNodeInfo command failed: %08x\n" , status ) ; hermon_hw_fini ( state , cleanup ) ; HERMON_ATTACH_MSG ( state -> hs_attach_buf , "hw_init_getnodeinfo_cmd_fail" ) ; return ( DDI_FAILURE ) ; } if ( state -> hs_cfg_profile -> cp_nodeguid ) { state -> hs_nodeguid = state -> hs_cfg_profile -> cp_nodeguid ; } else { state -> hs_nodeguid = nodeinfo . NodeGUID ; } if ( state -> hs_nodeguid != nodeinfo . NodeGUID ) { cmn_err ( CE_NOTE , "!NodeGUID value queried from firmware " "does not match value set by device property" ) ; } if ( state -> hs_cfg_profile -> cp_sysimgguid ) { state -> hs_sysimgguid = state -> hs_cfg_profile -> cp_sysimgguid ; } else { state -> hs_sysimgguid = nodeinfo . SystemImageGUID ; } if ( state -> hs_sysimgguid != nodeinfo . SystemImageGUID ) { cmn_err ( CE_NOTE , "!SystemImageGUID value queried from firmware " "does not match value set by device property" ) ; } status = hermon_getnodedesc_cmd_post ( state , HERMON_CMD_NOSLEEP_SPIN , ( sm_nodedesc_t * ) & state -> hs_nodedesc ) ; return ( DDI_SUCCESS ) ; } 