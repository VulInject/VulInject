decimal128 * decimal128FromNumber ( decimal128 * d128 , const decNumber * dn , decContext * set ) { uInt status = 0 ; Int ae ; decNumber dw ; decContext dc ; uInt comb , exp ; uInt uiwork ; uInt targar [ 4 ] { 0 0 0 0 } ; ; ae = dn -> exponent + dn -> digits - 1 ; if ( dn -> digits > DECIMAL128_Pmax || ae > DECIMAL128_Emax || ae < DECIMAL128_Emin ) { decContextDefault ( & dc , DEC_INIT_DECIMAL128 ) ; dc . round = set -> round ; decNumberPlus ( & dw , dn , & dc ) ; dw . bits |= dn -> bits & DECNEG ; status = dc . status ; dn = & dw ; } if ( dn -> bits & DECSPECIAL ) { if ( dn -> bits & DECINF ) { targhi = DECIMAL_Inf << 24 ; } else { if ( ( * dn -> lsu != 0 || dn -> digits > 1 ) && ( dn -> digits < DECIMAL128_Pmax ) ) { decDigitsToDPD ( dn , targar , 0 ) ; } if ( dn -> bits & DECNAN ) { targhi |= DECIMAL_NaN << 24 ; } else { targhi |= DECIMAL_sNaN << 24 ; } } } else { if ( decNumberIsZero ( dn ) ) { if ( dn -> exponent < - DECIMAL128_Bias ) { exp = 0 ; status |= DEC_Clamped ; } else { exp = dn -> exponent + DECIMAL128_Bias ; if ( exp > DECIMAL128_Ehigh ) { exp = DECIMAL128_Ehigh ; status |= DEC_Clamped ; } } comb = ( exp >> 9 ) & 0x18 ; } else { uInt msd ; Int pad = 0 ; exp = ( uInt ) ( dn -> exponent + DECIMAL128_Bias ) ; if ( exp > DECIMAL128_Ehigh ) { pad = exp - DECIMAL128_Ehigh ; exp = DECIMAL128_Ehigh ; status |= DEC_Clamped ; } decDigitsToDPD ( dn , targar , pad ) ; msd = targhi >> 14 ; targhi &= 0x00003fff ; if ( msd >= 8 ) { comb = 0x18 | ( ( exp >> 11 ) & 0x06 ) | ( msd & 0x01 ) ; } else { comb = ( ( exp >> 9 ) & 0x18 ) | msd ; } } targhi |= comb << 26 ; targhi |= ( exp & 0xfff ) << 14 ; } if ( dn -> bits & DECNEG ) { targhi |= 0x80000000 ; } if ( DECLITEND ) { UBFROMUI ( d128 -> bytes , targlo ) ; UBFROMUI ( d128 -> bytes + 4 , targml ) ; UBFROMUI ( d128 -> bytes + 8 , targmh ) ; UBFROMUI ( d128 -> bytes + 12 , targhi ) ; } else { UBFROMUI ( d128 -> bytes , targhi ) ; UBFROMUI ( d128 -> bytes + 4 , targmh ) ; UBFROMUI ( d128 -> bytes + 8 , targml ) ; UBFROMUI ( d128 -> bytes + 12 , targlo ) ; } if ( status != 0 ) { decContextSetStatus ( set , status ) ; } return d128 ; } decNumber * decimal128ToNumber ( const decimal128 * d128 , decNumber * dn ) { uInt msd ; uInt exp ; uInt comb ; Int need ; uInt uiwork ; uInt sourar [ 4 ] ; if ( DECLITEND ) { sourlo = UBTOUI ( d128 -> bytes ) ; sourml = UBTOUI ( d128 -> bytes + 4 ) ; sourmh = UBTOUI ( d128 -> bytes + 8 ) ; sourhi = UBTOUI ( d128 -> bytes + 12 ) ; } else { sourhi = UBTOUI ( d128 -> bytes ) ; sourmh = UBTOUI ( d128 -> bytes + 4 ) ; sourml = UBTOUI ( d128 -> bytes + 8 ) ; sourlo = UBTOUI ( d128 -> bytes + 12 ) ; } comb = ( sourhi >> 26 ) & 0x1f ; decNumberZero ( dn ) ; if ( sourhi & 0x80000000 ) { dn -> bits = DECNEG ; } msd = COMBMSD [ comb ] ; exp = COMBEXP [ comb ] ; if ( exp == 3 ) { if ( msd == 0 ) { dn -> bits |= DECINF ; return dn ; } if ( sourhi & 0x02000000 ) { dn -> bits |= DECSNAN ; } else { dn -> bits |= DECNAN ; } msd = 0 ; } else { dn -> exponent = ( exp << 12 ) + ( ( sourhi >> 14 ) & 0xfff ) - DECIMAL128_Bias ; } sourhi &= 0x00003fff ; if ( msd ) { sourhi |= msd << 14 ; need = 12 ; } else { if ( sourhi ) { need = 11 ; } if ( sourmh ) { need = 10 ; } if ( sourml ) { need = 7 ; } if ( sourlo ) { need = 4 ; } else { return dn ; } } decDigitsFromDPD ( dn , sourar , need ) ; return dn ; } char * decimal128ToEngString ( const decimal128 * d128 , char * string ) { decNumber dn ; decimal128ToNumber ( d128 , & dn ) ; decNumberToEngString ( & dn , string ) ; return string ; } char * decimal128ToString ( const decimal128 * d128 , char * string ) { uInt msd ; Int exp ; uInt comb ; char * cstart ; char * c ; const uByte * u ; char * s , * t ; Int dpd ; Int pre , e ; uInt uiwork ; uInt sourar [ 4 ] ; if ( DECLITEND ) { sourlo = UBTOUI ( d128 -> bytes ) ; sourml = UBTOUI ( d128 -> bytes + 4 ) ; sourmh = UBTOUI ( d128 -> bytes + 8 ) ; sourhi = UBTOUI ( d128 -> bytes + 12 ) ; } else { sourhi = UBTOUI ( d128 -> bytes ) ; sourmh = UBTOUI ( d128 -> bytes + 4 ) ; sourml = UBTOUI ( d128 -> bytes + 8 ) ; sourlo = UBTOUI ( d128 -> bytes + 12 ) ; } c = string ; if ( ( ( Int ) sourhi ) < 0 ) { * c ++ = '-' ; } comb = ( sourhi >> 26 ) & 0x1f ; msd = COMBMSD [ comb ] ; exp = COMBEXP [ comb ] ; if ( exp == 3 ) { if ( msd == 0 ) { strcpy ( c , "Inf" ) ; strcpy ( c + 3 , "inity" ) ; return string ; } if ( sourhi & 0x02000000 ) { * c ++ = 's' ; } strcpy ( c , "NaN" ) ; c += 3 ; if ( sourlo == 0 && sourml == 0 && sourmh == 0 && ( sourhi & 0x0003ffff ) == 0 ) { return string ; } exp = 0 ; msd = 0 ; } else { exp = ( exp << 12 ) + ( ( sourhi >> 14 ) & 0xfff ) - DECIMAL128_Bias ; } cstart = c ; if ( msd ) { * c ++ = '0' + ( char ) msd ; } if ( c != cstart ) { memcpy ( c , u + 1 , 4 ) ; c += 3 ; } if ( * u ) { memcpy ( c , u + 4 - * u , 4 ) ; c += * u ; } dpd = ( sourhi >> 4 ) & 0x3ff ; dpd2char ; dpd = ( ( sourhi & 0xf ) << 6 ) | ( sourmh >> 26 ) ; dpd2char ; dpd = ( sourmh >> 16 ) & 0x3ff ; dpd2char ; dpd = ( sourmh >> 6 ) & 0x3ff ; dpd2char ; dpd = ( ( sourmh & 0x3f ) << 4 ) | ( sourml >> 28 ) ; dpd2char ; dpd = ( sourml >> 18 ) & 0x3ff ; dpd2char ; dpd = ( sourml >> 8 ) & 0x3ff ; dpd2char ; dpd = ( ( sourml & 0xff ) << 2 ) | ( sourlo >> 30 ) ; dpd2char ; dpd = ( sourlo >> 20 ) & 0x3ff ; dpd2char ; dpd = ( sourlo >> 10 ) & 0x3ff ; dpd2char ; dpd = ( sourlo ) & 0x3ff ; dpd2char ; if ( c == cstart ) { * c ++ = '0' ; } if ( exp == 0 ) { * c = '\0' ; return string ; } e = 0 ; pre = c - cstart + exp ; if ( exp > 0 || pre < - 5 ) { e = pre - 1 ; pre = 1 ; } s = c - 1 ; if ( pre > 0 ) { char * dotat = cstart + pre ; } } 