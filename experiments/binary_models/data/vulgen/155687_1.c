static int issue_mfi_stp ( struct megasas_instance * instance , struct megasas_ioctl * ioctl , struct megasas_cmd * cmd , int mode ) { void * fis_ubuf ; void * data_ubuf ; uint32_t fis_xferlen = 0 ; uint32_t data_xferlen = 0 ; uint_t model ; dma_obj_t fis_dma_obj ; dma_obj_t data_dma_obj ; struct megasas_stp_frame * kstp ; struct megasas_stp_frame * stp ; stp = & cmd -> frame -> stp ; kstp = ( megasas_stp_frame * ) & ioctl -> frame [ 0 ] ; model = ddi_model_convert_from ( mode & FMODELS ) ; if ( model == DDI_MODEL_ILP32 ) { con_log ( CL_ANN1 , ( CE_NOTE , "issue_mfi_stp: DDI_MODEL_ILP32" ) ) ; fis_xferlen = kstp -> sgl . sge32 [ 0 ] . length ; data_xferlen = kstp -> sgl . sge32 [ 1 ] . length ; fis_ubuf = ( void * ) ( ulong_t ) kstp -> sgl . sge32 [ 0 ] . phys_addr ; data_ubuf = ( void * ) ( ulong_t ) kstp -> sgl . sge32 [ 1 ] . phys_addr ; } else { con_log ( CL_ANN1 , ( CE_NOTE , "issue_mfi_stp: DDI_MODEL_ILP32" ) ) ; fis_xferlen = kstp -> sgl . sge32 [ 0 ] . length ; data_xferlen = kstp -> sgl . sge32 [ 1 ] . length ; fis_ubuf = ( void * ) ( ulong_t ) kstp -> sgl . sge32 [ 0 ] . phys_addr ; data_ubuf = ( void * ) ( ulong_t ) kstp -> sgl . sge32 [ 1 ] . phys_addr ; con_log ( CL_ANN1 , ( CE_NOTE , "issue_mfi_stp: DDI_MODEL_LP64" ) ) ; fis_xferlen = kstp -> sgl . sge64 [ 0 ] . length ; data_xferlen = kstp -> sgl . sge64 [ 1 ] . length ; fis_ubuf = ( void * ) ( ulong_t ) kstp -> sgl . sge64 [ 0 ] . phys_addr ; data_ubuf = ( void * ) ( ulong_t ) kstp -> sgl . sge64 [ 1 ] . phys_addr ; } if ( fis_xferlen ) { con_log ( CL_ANN , ( CE_NOTE , "issue_mfi_stp: " "fis_ubuf = %p fis_xferlen = %x" , fis_ubuf , fis_xferlen ) ) ; fis_dma_obj . size = fis_xferlen ; fis_dma_obj . dma_attr = megasas_generic_dma_attr ; fis_dma_obj . dma_attr . dma_attr_addr_hi = 0xFFFFFFFFU ; fis_dma_obj . dma_attr . dma_attr_count_max = 0xFFFFFFFFU ; fis_dma_obj . dma_attr . dma_attr_sgllen = 1 ; fis_dma_obj . dma_attr . dma_attr_align = 1 ; if ( mega_alloc_dma_obj ( instance , & fis_dma_obj ) != 1 ) { con_log ( CL_ANN , ( CE_WARN , "issue_mfi_stp: " "could not data transfer buffer alloc." ) ) ; return ( DDI_FAILURE ) ; } if ( ddi_copyin ( fis_ubuf , ( void * ) fis_dma_obj . buffer , fis_xferlen , mode ) ) { con_log ( CL_ANN , ( CE_WARN , "issue_mfi_stp: " "copy from user space failed\n" ) ) ; return ( 1 ) ; } } if ( data_xferlen ) { con_log ( CL_ANN , ( CE_NOTE , "issue_mfi_stp: data_ubuf = %p " "data_xferlen = %x" , data_ubuf , data_xferlen ) ) ; data_dma_obj . size = data_xferlen ; data_dma_obj . dma_attr = megasas_generic_dma_attr ; data_dma_obj . dma_attr . dma_attr_addr_hi = 0xFFFFFFFFU ; data_dma_obj . dma_attr . dma_attr_count_max = 0xFFFFFFFFU ; data_dma_obj . dma_attr . dma_attr_sgllen = 1 ; data_dma_obj . dma_attr . dma_attr_align = 1 ; if ( mega_alloc_dma_obj ( instance , & data_dma_obj ) != 1 ) { con_log ( CL_ANN , ( CE_WARN , "issue_mfi_stp: " "could not data transfer buffer alloc." ) ) ; return ( DDI_FAILURE ) ; } if ( ddi_copyin ( data_ubuf , ( void * ) data_dma_obj . buffer , data_xferlen , mode ) ) { con_log ( CL_ANN , ( CE_WARN , "issue_mfi_stp: " "copy from user space failed\n" ) ) ; return ( 1 ) ; } } stp -> cmd = kstp -> cmd ; stp -> cmd_status = kstp -> cmd_status ; stp -> connection_status = kstp -> connection_status ; stp -> target_id = kstp -> target_id ; stp -> sge_count = kstp -> sge_count ; stp -> timeout = kstp -> timeout ; stp -> data_xfer_len = kstp -> data_xfer_len ; bcopy ( ( void * ) kstp -> fis , ( void * ) stp -> fis , 10 ) ; stp -> flags = kstp -> flags & ~ MFI_FRAME_SGL64 ; stp -> stp_flags = kstp -> stp_flags ; stp -> sgl . sge32 [ 0 ] . length = fis_xferlen ; stp -> sgl . sge32 [ 0 ] . phys_addr = fis_dma_obj . dma_cookie [ 0 ] . dmac_address ; stp -> sgl . sge32 [ 1 ] . length = data_xferlen ; stp -> sgl . sge32 [ 1 ] . phys_addr = data_dma_obj . dma_cookie [ 0 ] . dmac_address ; cmd -> sync_cmd = MEGASAS_TRUE ; cmd -> frame_count = 1 ; if ( instance -> func_ptr -> issue_cmd_in_sync_mode ( instance , cmd ) ) { con_log ( CL_ANN , ( CE_WARN , "issue_mfi_stp: fw_ioctl failed\n" ) ) ; } else { if ( fis_xferlen ) { if ( ddi_copyout ( fis_dma_obj . buffer , fis_ubuf , fis_xferlen , mode ) ) { con_log ( CL_ANN , ( CE_WARN , "issue_mfi_stp: " "copy to user space failed\n" ) ) ; return ( 1 ) ; } } if ( data_xferlen ) { if ( ddi_copyout ( data_dma_obj . buffer , data_ubuf , data_xferlen , mode ) ) { con_log ( CL_ANN , ( CE_WARN , "issue_mfi_stp: " "copy to user space failed\n" ) ) ; return ( 1 ) ; } } } kstp -> cmd_status = stp -> cmd_status ; if ( fis_xferlen ) { if ( mega_free_dma_obj ( instance , fis_dma_obj ) != DDI_SUCCESS ) { return ( 1 ) ; } } if ( data_xferlen ) { } return ( 0 ) ; } 