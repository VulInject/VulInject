static int cpu_stat_ks_update ( kstat_t * ksp , int rw ) { cpu_stat_t * cso ; cpu_t * cp ; int i ; hrtime_t msnsecs [ NCMSTATES ] ; cso = ( cpu_stat_t * ) ksp -> ks_data ; cp = ( cpu_t * ) ksp -> ks_private ; if ( rw == KSTAT_WRITE ) { return ( EACCES ) ; } get_cpu_mstate ( cp , msnsecs ) ; msnsecs [ CMS_IDLE ] = NSEC_TO_TICK ( msnsecs [ CMS_IDLE ] ) ; msnsecs [ CMS_USER ] = NSEC_TO_TICK ( msnsecs [ CMS_USER ] ) ; msnsecs [ CMS_SYSTEM ] = NSEC_TO_TICK ( msnsecs [ CMS_SYSTEM ] ) ; if ( cso -> cpu_sysinfo . cpu [ CPU_IDLE ] < msnsecs [ CMS_IDLE ] ) { cso -> cpu_sysinfo . cpu [ CPU_IDLE ] = msnsecs [ CMS_IDLE ] ; } if ( cso -> cpu_sysinfo . cpu [ CPU_USER ] < msnsecs [ CMS_USER ] ) { cso -> cpu_sysinfo . cpu [ CPU_USER ] = msnsecs [ CMS_USER ] ; } cso -> cpu_sysinfo . cpu [ CPU_WAIT ] = 0 ; cso -> cpu_sysinfo . wait [ W_IO ] = 0 ; cso -> cpu_sysinfo . wait [ W_SWAP ] = 0 ; cso -> cpu_sysinfo . wait [ W_PIO ] = 0 ; cso -> cpu_sysinfo . bread = CPU_STATS ( cp , sys . bread ) ; cso -> cpu_sysinfo . bwrite = CPU_STATS ( cp , sys . bwrite ) ; cso -> cpu_sysinfo . lread = CPU_STATS ( cp , sys . lread ) ; cso -> cpu_sysinfo . lwrite = CPU_STATS ( cp , sys . lwrite ) ; cso -> cpu_sysinfo . phread = CPU_STATS ( cp , sys . phread ) ; cso -> cpu_sysinfo . phwrite = CPU_STATS ( cp , sys . phwrite ) ; cso -> cpu_sysinfo . pswitch = CPU_STATS ( cp , sys . pswitch ) ; cso -> cpu_sysinfo . trap = CPU_STATS ( cp , sys . trap ) ; cso -> cpu_sysinfo . intr = 0 ; for ( i = 0 ; i < PIL_MAX ; i ++ ) { cso -> cpu_sysinfo . intr += CPU_STATS ( cp , sys . intr [ i ] ) ; } cso -> cpu_sysinfo . syscall = CPU_STATS ( cp , sys . syscall ) ; cso -> cpu_sysinfo . sysread = CPU_STATS ( cp , sys . sysread ) ; cso -> cpu_sysinfo . syswrite = CPU_STATS ( cp , sys . syswrite ) ; cso -> cpu_sysinfo . sysfork = CPU_STATS ( cp , sys . sysfork ) ; cso -> cpu_sysinfo . sysvfork = CPU_STATS ( cp , sys . sysvfork ) ; cso -> cpu_sysinfo . sysexec = CPU_STATS ( cp , sys . sysexec ) ; cso -> cpu_sysinfo . readch = CPU_STATS ( cp , sys . readch ) ; cso -> cpu_sysinfo . writech = CPU_STATS ( cp , sys . writech ) ; cso -> cpu_sysinfo . rcvint = CPU_STATS ( cp , sys . rcvint ) ; cso -> cpu_sysinfo . xmtint = CPU_STATS ( cp , sys . xmtint ) ; cso -> cpu_sysinfo . mdmint = CPU_STATS ( cp , sys . mdmint ) ; cso -> cpu_sysinfo . rawch = CPU_STATS ( cp , sys . rawch ) ; cso -> cpu_sysinfo . canch = CPU_STATS ( cp , sys . canch ) ; cso -> cpu_sysinfo . outch = CPU_STATS ( cp , sys . outch ) ; cso -> cpu_sysinfo . msg = CPU_STATS ( cp , sys . msg ) ; cso -> cpu_sysinfo . sema = CPU_STATS ( cp , sys . sema ) ; cso -> cpu_sysinfo . namei = CPU_STATS ( cp , sys . namei ) ; cso -> cpu_sysinfo . ufsiget = CPU_STATS ( cp , sys . ufsiget ) ; cso -> cpu_sysinfo . ufsdirblk = CPU_STATS ( cp , sys . ufsdirblk ) ; cso -> cpu_sysinfo . ufsipage = CPU_STATS ( cp , sys . ufsipage ) ; cso -> cpu_sysinfo . ufsinopage = CPU_STATS ( cp , sys . ufsinopage ) ; cso -> cpu_sysinfo . inodeovf = 0 ; cso -> cpu_sysinfo . fileovf = 0 ; cso -> cpu_sysinfo . procovf = CPU_STATS ( cp , sys . procovf ) ; cso -> cpu_sysinfo . intrthread = 0 ; for ( i = 0 ; i < LOCK_LEVEL - 1 ; i ++ ) { cso -> cpu_sysinfo . intrthread += CPU_STATS ( cp , sys . intr [ i ] ) ; } cso -> cpu_sysinfo . intrblk = CPU_STATS ( cp , sys . intrblk ) ; cso -> cpu_sysinfo . idlethread = CPU_STATS ( cp , sys . idlethread ) ; cso -> cpu_sysinfo . inv_swtch = CPU_STATS ( cp , sys . inv_swtch ) ; cso -> cpu_sysinfo . nthreads = CPU_STATS ( cp , sys . nthreads ) ; cso -> cpu_sysinfo . cpumigrate = CPU_STATS ( cp , sys . cpumigrate ) ; cso -> cpu_sysinfo . xcalls = CPU_STATS ( cp , sys . xcalls ) ; cso -> cpu_sysinfo . mutex_adenters = CPU_STATS ( cp , sys . mutex_adenters ) ; cso -> cpu_sysinfo . rw_rdfails = CPU_STATS ( cp , sys . rw_rdfails ) ; cso -> cpu_sysinfo . rw_wrfails = CPU_STATS ( cp , sys . rw_wrfails ) ; cso -> cpu_sysinfo . modload = CPU_STATS ( cp , sys . modload ) ; cso -> cpu_sysinfo . modunload = CPU_STATS ( cp , sys . modunload ) ; cso -> cpu_sysinfo . bawrite = CPU_STATS ( cp , sys . bawrite ) ; cso -> cpu_sysinfo . rw_enters = 0 ; cso -> cpu_sysinfo . win_uo_cnt = 0 ; cso -> cpu_sysinfo . win_uu_cnt = 0 ; cso -> cpu_sysinfo . win_so_cnt = 0 ; cso -> cpu_sysinfo . win_su_cnt = 0 ; cso -> cpu_sysinfo . win_suo_cnt = 0 ; cso -> cpu_syswait . iowait = CPU_STATS ( cp , sys . iowait ) ; cso -> cpu_syswait . swap = 0 ; cso -> cpu_syswait . physio = 0 ; cso -> cpu_vminfo . pgrec = CPU_STATS ( cp , vm . pgrec ) ; cso -> cpu_vminfo . pgfrec = CPU_STATS ( cp , vm . pgfrec ) ; cso -> cpu_vminfo . pgin = CPU_STATS ( cp , vm . pgin ) ; cso -> cpu_vminfo . pgpgin = CPU_STATS ( cp , vm . pgpgin ) ; cso -> cpu_vminfo . pgout = CPU_STATS ( cp , vm . pgout ) ; cso -> cpu_vminfo . pgpgout = CPU_STATS ( cp , vm . pgpgout ) ; cso -> cpu_vminfo . swapin = CPU_STATS ( cp , vm . swapin ) ; cso -> cpu_vminfo . pgswapin = CPU_STATS ( cp , vm . pgswapin ) ; cso -> cpu_vminfo . swapout = CPU_STATS ( cp , vm . swapout ) ; cso -> cpu_vminfo . pgswapout = CPU_STATS ( cp , vm . pgswapout ) ; cso -> cpu_vminfo . zfod = CPU_STATS ( cp , vm . zfod ) ; cso -> cpu_vminfo . dfree = CPU_STATS ( cp , vm . dfree ) ; cso -> cpu_vminfo . scan = CPU_STATS ( cp , vm . scan ) ; cso -> cpu_vminfo . rev = CPU_STATS ( cp , vm . rev ) ; cso -> cpu_vminfo . hat_fault = CPU_STATS ( cp , vm . hat_fault ) ; cso -> cpu_vminfo . as_fault = CPU_STATS ( cp , vm . as_fault ) ; cso -> cpu_vminfo . maj_fault = CPU_STATS ( cp , vm . maj_fault ) ; cso -> cpu_vminfo . cow_fault = CPU_STATS ( cp , vm . cow_fault ) ; cso -> cpu_vminfo . prot_fault = CPU_STATS ( cp , vm . prot_fault ) ; cso -> cpu_vminfo . softlock = CPU_STATS ( cp , vm . softlock ) ; cso -> cpu_vminfo . kernel_asflt = CPU_STATS ( cp , vm . kernel_asflt ) ; cso -> cpu_vminfo . pgrrun = CPU_STATS ( cp , vm . pgrrun ) ; cso -> cpu_vminfo . execpgin = CPU_STATS ( cp , vm . execpgin ) ; cso -> cpu_vminfo . execpgout = CPU_STATS ( cp , vm . execpgout ) ; cso -> cpu_vminfo . execfree = CPU_STATS ( cp , vm . execfree ) ; cso -> cpu_vminfo . anonpgin = CPU_STATS ( cp , vm . anonpgin ) ; cso -> cpu_vminfo . anonpgout = CPU_STATS ( cp , vm . anonpgout ) ; cso -> cpu_vminfo . anonfree = CPU_STATS ( cp , vm . anonfree ) ; cso -> cpu_vminfo . fspgin = CPU_STATS ( cp , vm . fspgin ) ; cso -> cpu_vminfo . fspgout = CPU_STATS ( cp , vm . fspgout ) ; cso -> cpu_vminfo . fsfree = CPU_STATS ( cp , vm . fsfree ) ; return ( 0 ) ; } 