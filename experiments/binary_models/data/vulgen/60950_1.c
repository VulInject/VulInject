void * mom_process_request ( void * sock_num ) { int rc ; struct batch_request * request = NULL ; int sfds = * ( int * ) sock_num ; struct tcp_chan * chan = NULL ; time_now = time ( NULL ) ; if ( ( request = alloc_br ( 0 ) ) == NULL ) { mom_close_client ( sfds ) ; return NULL ; } request -> rq_conn = sfds ; if ( ( chan = DIS_tcp_setup ( sfds ) ) == NULL ) { mom_close_client ( sfds ) ; return NULL ; } rc = dis_request_read ( chan , request ) ; if ( rc == - 1 ) { mom_close_client ( chan -> sock ) ; free_br ( request ) ; DIS_tcp_cleanup ( chan ) ; return NULL ; } if ( ( rc == PBSE_SYSTEM ) || ( rc == PBSE_INTERNAL ) || ( rc == PBSE_SOCKET_CLOSE ) ) { mom_close_client ( chan -> sock ) ; free_br ( request ) ; DIS_tcp_cleanup ( chan ) ; return NULL ; } if ( rc != PBSE_NONE ) { req_reject ( rc , 0 , request , NULL , "cannot decode message" ) ; mom_close_client ( chan -> sock ) ; DIS_tcp_cleanup ( chan ) ; return NULL ; } if ( get_connecthost ( chan -> sock , request -> rq_host , PBS_MAXHOSTNAME ) != 0 ) { char tmpLine [ MAXLINE ] ; char ipstr [ 128 ] ; sprintf ( log_buffer , "%s: %s" , pbse_to_txt ( PBSE_BADHOST ) , netaddr_long ( get_connectaddr ( chan -> sock , FALSE ) , ipstr ) ) ; log_event ( PBSEVENT_DEBUG , PBS_EVENTCLASS_REQUEST , "" , log_buffer ) ; snprintf ( tmpLine , sizeof ( tmpLine ) , "cannot determine hostname for connection from %s" , ipstr ) ; req_reject ( PBSE_BADHOST , 0 , request , NULL , tmpLine ) ; mom_close_client ( chan -> sock ) ; DIS_tcp_cleanup ( chan ) ; return NULL ; } if ( LOGLEVEL >= 1 ) { sprintf ( log_buffer , msg_request , reqtype_to_txt ( request -> rq_type ) , request -> rq_user , request -> rq_host , chan -> sock ) ; log_event ( PBSEVENT_DEBUG2 , PBS_EVENTCLASS_REQUEST , "" , log_buffer ) ; } { extern void mom_server_update_receive_time_by_ip ( u_long ipaddr , const char * cmd ) ; if ( LOGLEVEL >= 6 ) { sprintf ( log_buffer , "request type %s from host %s received" , reqtype_to_txt ( request -> rq_type ) , request -> rq_host ) ; log_record ( PBSEVENT_JOB , PBS_EVENTCLASS_JOB , __func__ , log_buffer ) ; } if ( svr_conn [ chan -> sock ] . cn_authen != PBS_NET_CONN_FROM_PRIVIL ) { sprintf ( log_buffer , "request type %s from host %s rejected (connection not privileged)" , reqtype_to_txt ( request -> rq_type ) , request -> rq_host ) ; log_record ( PBSEVENT_JOB , PBS_EVENTCLASS_JOB , __func__ , log_buffer ) ; req_reject ( PBSE_BADHOST , 0 , request , NULL , "request not authorized" ) ; mom_close_client ( chan -> sock ) ; DIS_tcp_cleanup ( chan ) ; return NULL ; } if ( auth_hosts . is_authorized ( svr_conn [ chan -> sock ] . cn_addr ) == false ) { sprintf ( log_buffer , "request type %s from host %s rejected (host not authorized)" , reqtype_to_txt ( request -> rq_type ) , request -> rq_host ) ; log_record ( PBSEVENT_JOB , PBS_EVENTCLASS_JOB , __func__ , log_buffer ) ; req_reject ( PBSE_BADHOST , 0 , request , NULL , "request not authorized" ) ; mom_close_client ( chan -> sock ) ; DIS_tcp_cleanup ( chan ) ; return NULL ; } if ( LOGLEVEL >= 3 ) { sprintf ( log_buffer , "request type %s from host %s allowed" , reqtype_to_txt ( request -> rq_type ) , request -> rq_host ) ; log_record ( PBSEVENT_JOB , PBS_EVENTCLASS_JOB , __func__ , log_buffer ) ; } mom_server_update_receive_time_by_ip ( svr_conn [ chan -> sock ] . cn_addr , reqtype_to_txt ( request -> rq_type ) ) ; } request -> rq_fromsvr = 1 ; request -> rq_perm = ATR_DFLAG_USRD | ATR_DFLAG_USWR | ATR_DFLAG_OPRD | ATR_DFLAG_OPWR | ATR_DFLAG_MGRD | ATR_DFLAG_MGWR | ATR_DFLAG_SvWR | ATR_DFLAG_MOM ; mom_dispatch_request ( chan -> sock , request ) ; DIS_tcp_cleanup ( chan ) ; return NULL ; } void mom_dispatch_request ( int sfds , struct batch_request * request ) { if ( LOGLEVEL >= 5 ) { sprintf ( log_buffer , "dispatching request %s on sd=%d" , reqtype_to_txt ( request -> rq_type ) , sfds ) ; log_record ( PBSEVENT_JOB , PBS_EVENTCLASS_JOB , __func__ , log_buffer ) ; } switch ( request -> rq_type ) { case PBS_BATCH_QueueJob : net_add_close_func ( sfds , close_quejob ) ; mom_req_quejob ( request ) ; break ; case PBS_BATCH_JobCred : req_jobcredential ( request ) ; break ; case PBS_BATCH_jobscript : req_jobscript ( request ) ; break ; case PBS_BATCH_RdytoCommit : req_rdytocommit ( request ) ; break ; case PBS_BATCH_Commit : req_commit ( request ) ; net_add_close_func ( sfds , NULL ) ; break ; case PBS_BATCH_DeleteJob : req_deletejob ( request ) ; break ; case PBS_BATCH_HoldJob : mom_req_holdjob ( request ) ; break ; case PBS_BATCH_CheckpointJob : req_checkpointjob ( request ) ; break ; case PBS_BATCH_MessJob : req_messagejob ( request ) ; break ; case PBS_BATCH_AsyModifyJob : case PBS_BATCH_ModifyJob : req_modifyjob ( request ) ; break ; case PBS_BATCH_Rerun : req_rerunjob ( request ) ; break ; case PBS_BATCH_Shutdown : req_shutdown ( request ) ; break ; case PBS_BATCH_SignalJob : case PBS_BATCH_AsySignalJob : mom_req_signal_job ( request ) ; break ; case PBS_BATCH_MvJobFile : req_mvjobfile ( request ) ; break ; case PBS_BATCH_StatusJob : req_stat_job ( request ) ; break ; case PBS_BATCH_ReturnFiles : req_returnfiles ( request ) ; break ; case PBS_BATCH_CopyFiles : req_cpyfile ( request ) ; break ; case PBS_BATCH_DelFiles : req_delfile ( request ) ; break ; case PBS_BATCH_DeleteReservation : req_delete_reservation ( request ) ; break ; case PBS_BATCH_ChangePowerState : req_change_power_state ( request ) ; break ; default : req_reject ( PBSE_UNKREQ , 0 , request , NULL , NULL ) ; mom_close_client ( sfds ) ; break ; } return ; } static void mom_close_client ( int sfds ) { struct batch_request * preq ; close_conn ( sfds , FALSE ) ; preq = ( batch_request * ) GET_NEXT ( svr_requests ) ; while ( preq != NULL ) { if ( preq -> rq_conn == sfds ) { preq -> rq_conn = - 1 ; } if ( preq -> rq_orgconn == sfds ) { preq -> rq_orgconn = - 1 ; } preq = ( batch_request * ) GET_NEXT ( preq -> rq_link ) ; } return ; } struct batch_request * alloc_br ( int type ) { struct batch_request * req = NULL ; req = ( batch_request * ) calloc ( 1 , sizeof ( batch_request ) ) ; if ( req == NULL ) { log_err ( errno , "alloc_br" , msg_err_malloc ) ; return ( NULL ) ; } req -> rq_type = type ; req -> rq_conn = - 1 ; req -> rq_orgconn = - 1 ; req -> rq_time = time_now ; req -> rq_reply . brp_choice = BATCH_REPLY_CHOICE_NULL ; req -> rq_noreply = FALSE ; CLEAR_LINK ( req -> rq_link ) ; append_link ( & svr_requests , & req -> rq_link , req ) ; return ( req ) ; } static void close_quejob ( int sfds ) { job * pjob ; job * npjob ; pjob = ( job * ) GET_NEXT ( svr_newjobs ) ; while ( pjob != NULL ) { npjob = ( job * ) GET_NEXT ( pjob -> ji_alljobs ) ; if ( pjob -> ji_qs . ji_un . ji_newt . ji_fromsock == sfds ) { if ( pjob -> ji_qs . ji_substate != JOB_SUBSTATE_TRANSICM ) { delete_link ( & pjob -> ji_alljobs ) ; mom_job_purge ( pjob ) ; pjob = NULL ; } break ; } pjob = npjob ; } return ; } void free_br ( batch_request * preq ) { if ( preq == NULL ) { return ; } delete_link ( & preq -> rq_link ) ; reply_free ( & preq -> rq_reply ) ; if ( preq -> rq_extend ) { free ( preq -> rq_extend ) ; } if ( preq -> rq_extra ) { free ( preq -> rq_extra ) ; } switch ( preq -> rq_type ) { case PBS_BATCH_QueueJob : free_attrlist ( & preq -> rq_ind . rq_queuejob . rq_attr ) ; break ; case PBS_BATCH_JobCred : if ( preq -> rq_ind . rq_jobcred . rq_data ) { free ( preq -> rq_ind . rq_jobcred . rq_data ) ; } break ; case PBS_BATCH_MvJobFile : case PBS_BATCH_jobscript : if ( preq -> rq_ind . rq_jobfile . rq_data ) { free ( preq -> rq_ind . rq_jobfile . rq_data ) ; } break ; case PBS_BATCH_HoldJob : freebr_manage ( & preq -> rq_ind . rq_hold . rq_orig ) ; break ; case PBS_BATCH_CheckpointJob : freebr_manage ( & preq -> rq_ind . rq_manager ) ; break ; case PBS_BATCH_MessJob : if ( preq -> rq_ind . rq_message . rq_text ) { free ( preq -> rq_ind . rq_message . rq_text ) ; } break ; case PBS_BATCH_ModifyJob : case PBS_BATCH_AsyModifyJob : freebr_manage ( & preq -> rq_ind . rq_modify ) ; break ; case PBS_BATCH_StatusJob : case PBS_BATCH_StatusQue : case PBS_BATCH_StatusNode : case PBS_BATCH_StatusSvr : free_attrlist ( & preq -> rq_ind . rq_status . rq_attr ) ; break ; case PBS_BATCH_JobObit : free_attrlist ( & preq -> rq_ind . rq_jobobit . rq_attr ) ; break ; case PBS_BATCH_CopyFiles : case PBS_BATCH_DelFiles : freebr_cpyfile ( & preq -> rq_ind . rq_cpyfile ) ; break ; default : break ; } free ( preq ) ; return ; } 