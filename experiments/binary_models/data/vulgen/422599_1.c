static CK_RV common_digest_init ( CK_SESSION_HANDLE hSession , CK_MECHANISM_PTR pMechanism , boolean_t is_external_caller ) { CK_RV rv ; kernel_session_t * session_p ; boolean_t ses_lock_held = B_FALSE ; crypto_digest_init_t digest_init ; crypto_mech_type_t k_mech_type ; int r ; if ( ! kernel_initialized ) { return ( CKR_CRYPTOKI_NOT_INITIALIZED ) ; } rv = kernel_mech ( pMechanism -> mechanism , & k_mech_type ) ; if ( rv != CKR_OK ) { return ( rv ) ; } rv = handle2session ( hSession , & session_p ) ; if ( rv != CKR_OK ) { return ( rv ) ; } ( void ) pthread_mutex_lock ( & session_p -> session_mutex ) ; ses_lock_held = B_TRUE ; session_p -> digest . flags |= CRYPTO_OPERATION_ACTIVE ; if ( SLOT_HAS_LIMITED_HASH ( session_p ) && is_external_caller ) { session_p -> digest . mech . mechanism = pMechanism -> mechanism ; session_p -> digest . mech . pParameter = NULL ; session_p -> digest . mech . ulParameterLen = 0 ; session_p -> digest . flags |= CRYPTO_EMULATE ; rv = emulate_buf_init ( session_p , EDIGEST_LENGTH , OP_DIGEST ) ; REFRELE ( session_p , ses_lock_held ) ; return ( rv ) ; } digest_init . di_session = session_p -> k_session ; ( void ) pthread_mutex_unlock ( & session_p -> session_mutex ) ; ses_lock_held = B_FALSE ; digest_init . di_mech . cm_type = k_mech_type ; digest_init . di_mech . cm_param = pMechanism -> pParameter ; if ( pMechanism -> pParameter != NULL ) { digest_init . di_mech . cm_param_len = pMechanism -> ulParameterLen ; } else { digest_init . di_mech . cm_param_len = 0 ; } while ( ( r = ioctl ( kernel_fd , CRYPTO_DIGEST_INIT , & digest_init ) ) < 0 ) { if ( errno != EINTR ) { break ; } } if ( r < 0 ) { rv = CKR_FUNCTION_FAILED ; } else { rv = crypto2pkcs11_error_number ( digest_init . di_return_value ) ; } if ( rv != CKR_OK ) { ( void ) pthread_mutex_lock ( & session_p -> session_mutex ) ; ses_lock_held = B_TRUE ; session_p -> digest . flags &= ~ CRYPTO_OPERATION_ACTIVE ; REFRELE ( session_p , ses_lock_held ) ; return ( rv ) ; } REFRELE ( session_p , ses_lock_held ) ; return ( rv ) ; } 