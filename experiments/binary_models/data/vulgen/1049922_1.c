GF_PropertyValue gf_props_parse_value ( u32 type , const char * name , const char * value , const char * enum_values , char list_sep_char ) { GF_PropertyValue p ; char * unit_sep = NULL ; s32 unit = 0 ; p . value . data . size = 0 ; p . type = type ; if ( ! name ) { name = "" ; } unit_sep = NULL ; if ( value ) { u32 len = ( u32 ) strlen ( value ) ; unit_sep = len ?strrchr ( "kKgGmMsS" , value [ len - 1 ] ) : NULL ; if ( unit_sep ) { u8 unit_char = unit_sep [ 0 ] ; if ( ( unit_char == 'k' ) || ( unit_char == 'K' ) ) { unit = 1000 ; } if ( ( unit_char == 'm' ) || ( unit_char == 'M' ) ) { unit = 1000000 ; } if ( ( unit_char == 'G' ) || ( unit_char == 'g' ) ) { unit = 1000000000 ; } if ( ( unit_char == 's' ) || ( unit_char == 'S' ) ) { unit = 1000 ; } } if ( type == GF_PROP_UINT ) { unit_sep = strstr ( value , "sec" ) ; if ( unit_sep && strlen ( unit_sep ) == 3 ) { unit = 1000 ; } else { unit_sep = strstr ( value , "min" ) ; if ( unit_sep && strlen ( unit_sep ) == 3 ) { unit = 60000 ; } } } } switch ( p . type ) { case GF_PROP_BOOL : if ( ! value || ! strcmp ( value , "yes" ) || ! strcmp ( value , "true" ) || ! strcmp ( value , "1" ) ) { p . value . boolean = GF_TRUE ; } if ( ! strcmp ( value , "no" ) || ! strcmp ( value , "false" ) || ! strcmp ( value , "0" ) ) { p . value . boolean = GF_FALSE ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for boolean arg %s - using false\n" , value , name ) ) ; p . value . boolean = GF_FALSE ; } break ; case GF_PROP_SINT : if ( value && ! strcmp ( value , "+I" ) ) { p . value . sint = GF_INT_MAX ; } if ( value && ! strcmp ( value , "-I" ) ) { p . value . sint = GF_INT_MIN ; } if ( ! value || ( sscanf ( value , "%d" , & p . value . sint ) != 1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for int arg %s - using 0\n" , value , name ) ) ; p . value . sint = 0 ; } if ( unit ) { p . value . sint *= unit ; } break ; case GF_PROP_UINT : if ( value && ! strcmp ( value , "+I" ) ) { p . value . sint = 0xFFFFFFFF ; break ; } if ( ! value && ! enum_values ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for unsigned int arg %s - using 0\n" , value , name ) ) ; p . value . uint = 0 ; break ; } if ( enum_values && strchr ( enum_values , '|' ) ) { u32 a_len = value ?( u32 ) strlen ( value ) : 0 ; u32 val = 0 ; char * str_start = ( char * ) enum_values ; while ( str_start ) { u32 len ; char * sep = strchr ( str_start , '|' ) ; if ( sep ) { len = ( u32 ) ( sep - str_start ) ; } else { len = ( u32 ) strlen ( str_start ) ; } if ( ! a_len && len ) { char szVal [ 50 ] ; gf_strlcpy ( szVal , str_start , MIN ( len + 1 , 50 ) ) ; GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for unsigned int arg %s enum %s - using `%s`\n" , value , name , enum_values , szVal ) ) ; break ; } if ( ( a_len == len ) && value && ! strncmp ( str_start , value , len ) ) { break ; } if ( ! sep ) { str_start = NULL ; break ; } str_start = sep + 1 ; val ++ ; } if ( ! str_start ) { if ( value && ! strcmp ( value , "-1" ) ) { p . value . uint = ( u32 ) - 1 ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for unsigned int arg %s enum %s - using 0\n" , value , name , enum_values ) ) ; p . value . uint = 0 ; } } else { p . value . uint = val ; } } if ( value && ! strnicmp ( value , "0x" , 2 ) ) { if ( sscanf ( value , "0x%x" , & p . value . uint ) != 1 ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for unsigned int arg %s - using 0\n" , value , name ) ) ; } if ( unit ) { p . value . uint *= unit ; } } if ( value ) { if ( sscanf ( value , "%d" , & p . value . uint ) != 1 ) { if ( strlen ( value ) == 4 ) { p . value . uint = GF_4CC ( value [ 0 ] , value [ 1 ] , value [ 2 ] , value [ 3 ] ) ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for unsigned int arg %s - using 0\n" , value , name ) ) ; } } if ( unit ) { p . value . uint *= unit ; } } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Missing argument value for unsigned int arg %s - using 0\n" , name ) ) ; } break ; case GF_PROP_4CC : if ( value && ( strlen ( value ) == 4 ) ) { p . value . sint = GF_4CC ( value [ 0 ] , value [ 1 ] , value [ 2 ] , value [ 3 ] ) ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for 4CC arg %s - using 0\n" , value , name ) ) ; } break ; case GF_PROP_LSINT : if ( value && ! strcmp ( value , "+I" ) ) { p . value . longsint = 0x7FFFFFFFFFFFFFFFUL ; } if ( value && ! strcmp ( value , "-I" ) ) { p . value . longsint = 0x8000000000000000UL ; } if ( ! value || ( sscanf ( value , "" LLD , & p . value . longsint ) != 1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for long int arg %s - using 0\n" , value , name ) ) ; p . value . uint = 0 ; } if ( unit ) { p . value . longsint *= unit ; } break ; case GF_PROP_LUINT : if ( value && ! strcmp ( value , "+I" ) ) { p . value . longuint = 0xFFFFFFFFFFFFFFFFUL ; } if ( ! value || ( sscanf ( value , "" LLU , & p . value . longuint ) != 1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for long unsigned int arg %s - using 0\n" , value , name ) ) ; p . value . uint = 0 ; } if ( unit ) { p . value . longuint *= unit ; } break ; case GF_PROP_FRACTION : if ( gf_parse_frac ( value , & p . value . frac ) == GF_FALSE ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for fraction arg %s - using 0/1\n" , value , name ) ) ; p . value . frac . num = 0 ; p . value . frac . den = 1 ; } break ; case GF_PROP_FRACTION64 : if ( gf_parse_lfrac ( value , & p . value . lfrac ) == GF_FALSE ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for fraction arg %s - using 0/1\n" , value , name ) ) ; p . value . lfrac . num = 0 ; p . value . lfrac . den = 1 ; } break ; case GF_PROP_FLOAT : if ( value && ! strcmp ( value , "+I" ) ) { p . value . fnumber = FIX_MAX ; } if ( value && ! strcmp ( value , "-I" ) ) { p . value . fnumber = FIX_MIN ; } if ( ! value ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for float arg %s - using 0\n" , value , name ) ) ; p . value . fnumber = 0 ; } else { Float f ; if ( sscanf ( value , "%f" , & f ) != 1 ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for float arg %s - using 0\n" , value , name ) ) ; p . value . fnumber = 0 ; } else { if ( unit ) { f *= unit ; } p . value . fnumber = FLT2FIX ( f ) ; } } break ; case GF_PROP_DOUBLE : if ( value && ! strcmp ( value , "+I" ) ) { p . value . number = GF_MAX_DOUBLE ; } if ( value && ! strcmp ( value , "-I" ) ) { p . value . number = GF_MIN_DOUBLE ; } if ( ! value || ( sscanf ( value , "%lg" , & p . value . number ) != 1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for double arg %s - using 0\n" , value , name ) ) ; p . value . number = 0 ; } if ( unit ) { p . value . number *= unit ; } break ; case GF_PROP_VEC2I : if ( ! value || ( sscanf ( value , "%dx%d" , & p . value . vec2i . x , & p . value . vec2i . y ) != 2 ) ) { if ( value && ! strcmp ( value , "720" ) ) { p . value . vec2i . x = 1280 ; p . value . vec2i . y = 720 ; } if ( value && ( ! strcmp ( value , "1080" ) || ! stricmp ( value , "hd" ) ) ) { p . value . vec2i . x = 1920 ; p . value . vec2i . y = 1080 ; } if ( value && ! strcmp ( value , "360" ) ) { p . value . vec2i . x = 640 ; p . value . vec2i . y = 360 ; } if ( value && ! strcmp ( value , "480" ) ) { p . value . vec2i . x = 640 ; p . value . vec2i . y = 480 ; } if ( value && ! strcmp ( value , "576" ) ) { p . value . vec2i . x = 720 ; p . value . vec2i . y = 576 ; } if ( value && ! stricmp ( value , "2k" ) ) { p . value . vec2i . x = 2048 ; p . value . vec2i . y = 1080 ; } if ( value && ( ! strcmp ( value , "2160" ) || ! stricmp ( value , "4k" ) ) ) { p . value . vec2i . x = 3840 ; p . value . vec2i . y = 2160 ; } if ( value && ( ! strcmp ( value , "4320" ) || ! stricmp ( value , "8k" ) ) ) { p . value . vec2i . x = 7680 ; p . value . vec2i . y = 4320 ; } else { if ( value && strcmp ( value , "0x0" ) && strcmp ( value , "0" ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for vec2i arg %s - using {0,0}\n" , value , name ) ) ; } p . value . vec2i . x = p . value . vec2i . y = 0 ; } } break ; case GF_PROP_VEC2 : if ( ! value || ( sscanf ( value , "%lgx%lg" , & p . value . vec2 . x , & p . value . vec2 . y ) != 2 ) ) { if ( value && strcmp ( value , "0x0" ) && strcmp ( value , "0" ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for vec2 arg %s - using {0,0}\n" , value , name ) ) ; } p . value . vec2 . x = p . value . vec2 . y = 0 ; } break ; case GF_PROP_VEC3I : if ( ! value || ( sscanf ( value , "%dx%dx%d" , & p . value . vec3i . x , & p . value . vec3i . y , & p . value . vec3i . z ) != 3 ) ) { if ( value && strcmp ( value , "0x0x0" ) && strcmp ( value , "0" ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for vec3i arg %s - using {0,0,0}\n" , value , name ) ) ; } p . value . vec3i . x = p . value . vec3i . y = p . value . vec3i . z = 0 ; } break ; case GF_PROP_VEC4I : if ( ! value || ( sscanf ( value , "%dx%dx%dx%d" , & p . value . vec4i . x , & p . value . vec4i . y , & p . value . vec4i . z , & p . value . vec4i . w ) != 4 ) ) { if ( value && strcmp ( value , "0x0x0x0" ) && strcmp ( value , "0" ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for vec4i arg %s - using {0,0,0}\n" , value , name ) ) ; } p . value . vec4i . x = p . value . vec4i . y = p . value . vec4i . z = p . value . vec4i . w = 0 ; } break ; case GF_PROP_NAME : case GF_PROP_STRING : case GF_PROP_STRING_NO_COPY : p . type = GF_PROP_STRING ; if ( value && ! strnicmp ( value , "file@" , 5 ) ) { u8 * data ; u32 len ; GF_Err e = gf_file_load_data ( value + 5 , ( u8 * * ) & data , & len ) ; if ( e ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Cannot load data from file %s\n" , value + 5 ) ) ; } else { p . value . string = data ; } } if ( value && ! strnicmp ( value , "bxml@" , 5 ) ) { GF_Err e ; GF_DOMParser * dom = gf_xml_dom_new ( ) ; e = gf_xml_dom_parse ( dom , value + 5 , NULL , NULL ) ; if ( e ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Cannot parse XML from file %s\n" , value + 5 ) ) ; } else { GF_XMLNode * root = gf_xml_dom_get_root_idx ( dom , 0 ) ; if ( root ) { e = gf_xml_parse_bit_sequence ( root , value + 5 , & p . value . data . ptr , & p . value . data . size ) ; } if ( e < 0 ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Failed to binarize XML file %s: %s\n" , value + 5 , gf_error_to_string ( e ) ) ) ; } else { p . type = GF_PROP_DATA ; } } gf_xml_dom_del ( dom ) ; } else { p . value . string = value ?gf_strdup ( value ) : NULL ; } break ; case GF_PROP_DATA : case GF_PROP_CONST_DATA : case GF_PROP_DATA_NO_COPY : if ( ! value ) { p . value . data . ptr = NULL ; p . value . data . size = 0 ; } if ( sscanf ( value , "%d@%p" , & p . value . data . size , & p . value . data . ptr ) == 2 ) { p . type = GF_PROP_CONST_DATA ; } if ( ! strnicmp ( value , "0x" , 2 ) ) { u32 i ; value += 2 ; p . value . data . size = ( u32 ) strlen ( value ) / 2 ; p . value . data . ptr = gf_malloc ( sizeof ( char ) * p . value . data . size ) ; for ( i = 0 ; i < p . value . data . size ; i ++ ) { char szV [ 3 ] ; u32 res ; szV [ 0 ] = value [ 2 * i ] ; szV [ 1 ] = value [ 2 * i + 1 ] ; szV [ 2 ] = 0 ; sscanf ( szV , "%x" , & res ) ; p . value . data . ptr [ i ] = res ; } } if ( ! strnicmp ( value , "bxml@" , 5 ) ) { GF_Err e ; GF_DOMParser * dom = gf_xml_dom_new ( ) ; e = gf_xml_dom_parse ( dom , value + 5 , NULL , NULL ) ; if ( e ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Cannot parse XML from file %s\n" , value + 5 ) ) ; } else { GF_XMLNode * root = gf_xml_dom_get_root_idx ( dom , 0 ) ; if ( root ) { e = gf_xml_parse_bit_sequence ( root , value + 5 , & p . value . data . ptr , & p . value . data . size ) ; } if ( e < 0 ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Failed to binarize XML file %s: %s\n" , value + 5 , gf_error_to_string ( e ) ) ) ; } } gf_xml_dom_del ( dom ) ; } if ( ! strnicmp ( value , "file@" , 5 ) ) { GF_Err e = gf_file_load_data ( value + 5 , ( u8 * * ) & p . value . data . ptr , & p . value . data . size ) ; if ( e ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Cannot load data from file %s\n" , value + 5 ) ) ; p . value . data . ptr = NULL ; p . value . data . size = 0 ; } } if ( ! strnicmp ( value , "b64@" , 4 ) ) { u8 * b64 = ( u8 * ) value + 5 ; u32 size = ( u32 ) strlen ( b64 ) ; p . value . data . ptr = gf_malloc ( sizeof ( char ) * size ) ; if ( p . value . data . ptr ) { p . value . data . size = gf_base64_decode ( ( u8 * ) b64 , size , p . value . data . ptr , size ) ; if ( ! p . value . data . size ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Failed to decode base64 value %s\n" , value , name ) ) ; p . type = GF_PROP_FORBIDEN ; } p . value . data . ptr [ p . value . data . size ] = 0 ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Failed to allocate memory for decoding base64 value %s\n" , value , name ) ) ; p . value . data . size = 0 ; p . type = GF_PROP_FORBIDEN ; } } else { p . value . data . size = ( u32 ) strlen ( value ) ; if ( p . value . data . size ) { p . value . data . ptr = gf_strdup ( value ) ; } else { p . value . data . ptr = NULL ; } p . type = GF_PROP_DATA ; } break ; case GF_PROP_POINTER : if ( ! value || ( sscanf ( value , "%p" , & p . value . ptr ) != 1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for pointer arg %s - using 0\n" , value , name ) ) ; } break ; case GF_PROP_STRING_LIST : { Bool is_xml = GF_FALSE ; char * v = ( char * ) value ; if ( v && v [ 0 ] == '<' ) { is_xml = GF_TRUE ; } if ( ! list_sep_char ) { list_sep_char = ',' ; } while ( v ) { u32 len = 0 ; char * nv ; char * sep = strchr ( v , list_sep_char ) ; if ( sep && is_xml ) { char * xml_end = strchr ( v , '>' ) ; len = ( u32 ) ( sep - v ) ; if ( xml_end ) { u32 xml_len = ( u32 ) ( xml_end - v ) ; if ( xml_len > len ) { sep = strchr ( xml_end , list_sep_char ) ; } } } if ( ! sep ) { len = ( u32 ) strlen ( v ) ; } else { len = ( u32 ) ( sep - v ) ; } nv = gf_malloc ( sizeof ( char ) * ( len + 1 ) ) ; strncpy ( nv , v , sizeof ( char ) * len ) ; nv [ len ] = 0 ; if ( ! strnicmp ( nv , "file@" , 5 ) ) { u8 * data ; u32 flen ; GF_Err e = gf_file_load_data ( nv + 5 , ( u8 * * ) & data , & flen ) ; if ( e ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Cannot load data from file %s\n" , nv + 5 ) ) ; } else { p . value . string_list . vals = gf_realloc ( p . value . string_list . vals , sizeof ( char * ) * ( p . value . string_list . nb_items + 1 ) ) ; p . value . string_list . vals [ p . value . string_list . nb_items ] = data ; p . value . string_list . nb_items ++ ; } gf_free ( nv ) ; } else { p . value . string_list . vals = gf_realloc ( p . value . string_list . vals , sizeof ( char * ) * ( p . value . string_list . nb_items + 1 ) ) ; p . value . string_list . vals [ p . value . string_list . nb_items ] = nv ; p . value . string_list . nb_items ++ ; } if ( ! sep ) { break ; } v = sep + 1 ; } } break ; case GF_PROP_UINT_LIST : case GF_PROP_4CC_LIST : case GF_PROP_SINT_LIST : case GF_PROP_VEC2I_LIST : { char * v = ( char * ) value ; if ( ! list_sep_char ) { list_sep_char = ',' ; } while ( v && v [ 0 ] ) { char szV [ 100 ] ; u32 len = 0 ; char * sep = strchr ( v , list_sep_char ) ; if ( sep ) { len = ( u32 ) ( sep - v ) ; } if ( ! sep ) { len = ( u32 ) strlen ( v ) ; } if ( len >= 99 ) { len = 99 ; } strncpy ( szV , v , len ) ; szV [ len ] = 0 ; if ( p . type == GF_PROP_UINT_LIST ) { u32 val_uint ; if ( sscanf ( szV , "%u" , & val_uint ) != 1 ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for uint arg %s[%d] - using 0\n" , value , name , p . value . uint_list . nb_items ) ) ; val_uint = 0 ; } p . value . uint_list . vals = gf_realloc ( p . value . uint_list . vals , ( p . value . uint_list . nb_items + 1 ) * sizeof ( u32 ) ) ; p . value . uint_list . vals [ p . value . uint_list . nb_items ] = val_uint ; } if ( p . type == GF_PROP_4CC_LIST ) { u32 val_uint = gf_4cc_parse ( szV ) ; if ( ! val_uint ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for 4CC arg %s[%d] - using 0\n" , value , name , p . value . uint_list . nb_items ) ) ; val_uint = 0 ; } p . value . uint_list . vals = gf_realloc ( p . value . uint_list . vals , ( p . value . uint_list . nb_items + 1 ) * sizeof ( u32 ) ) ; p . value . uint_list . vals [ p . value . uint_list . nb_items ] = val_uint ; } if ( p . type == GF_PROP_SINT_LIST ) { s32 val_int ; sscanf ( szV , "%d" , & val_int ) ; p . value . sint_list . vals = gf_realloc ( p . value . sint_list . vals , ( p . value . sint_list . nb_items + 1 ) * sizeof ( u32 ) ) ; p . value . sint_list . vals [ p . value . sint_list . nb_items ] = val_int ; } else { s32 v1 = 0 , v2 = 0 ; if ( sscanf ( szV , "%dx%d" , & v1 , & v2 ) != 2 ) { if ( strcmp ( value , "0x0" ) && strcmp ( value , "0" ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Wrong argument value %s for vec2i arg %s[%d] - using {0,0}\n" , value , name , p . value . v2i_list . nb_items ) ) ; } v1 = v2 = 0 ; } p . value . v2i_list . vals = gf_realloc ( p . value . v2i_list . vals , ( p . value . v2i_list . nb_items + 1 ) * sizeof ( GF_PropVec2i ) ) ; p . value . v2i_list . vals [ p . value . v2i_list . nb_items ] . x = v1 ; p . value . v2i_list . vals [ p . value . v2i_list . nb_items ] . y = v2 ; } p . value . uint_list . nb_items ++ ; if ( ! sep ) { break ; } v = sep + 1 ; } } break ; case GF_PROP_FORBIDEN : default : if ( gf_props_type_is_enum ( type ) ) { p . type = type ; p . value . uint = gf_props_parse_enum ( type , value ) ; break ; } GF_LOG ( GF_LOG_ERROR , GF_LOG_FILTER , ( "Forbidden property type %d for arg %s - ignoring\n" , type , name ) ) ; p . type = GF_PROP_FORBIDEN ; break ; } return p ; } 