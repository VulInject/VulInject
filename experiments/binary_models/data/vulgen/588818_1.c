int readLine ( rpmSpec spec , int strip ) { char * s ; int match = 0 ; struct ReadLevelEntry * rl ; OFI_t * ofi = spec -> fileStack ; int rc ; int startLine = 0 ; parsedSpecLine lineType ; int prevType = spec -> readStack -> lastConditional -> id ; int checkCondition ; if ( ! restoreFirstChar ( spec ) ) { retry if ( ( rc = readLineFromOFI ( spec , ofi ) ) != 0 ) { if ( spec -> readStack -> next ) { rpmlog ( RPMLOG_ERR , _ ( "line %d: Unclosed %%if\n" ) , spec -> readStack -> lineNum ) ; rc = PART_ERROR ; } if ( startLine > 0 ) { rpmlog ( RPMLOG_ERR , _ ( "line %d: unclosed macro or bad line continuation\n" ) , startLine ) ; rc = PART_ERROR ; } return rc ; } ofi = spec -> fileStack ; rc = copyNextLineFromOFI ( spec , ofi , strip ) ; if ( rc > 0 ) { if ( startLine == 0 ) { startLine = spec -> lineNum ; } retry } if ( rc < 0 ) { return PART_ERROR ; } } lineType = copyNextLineFinish ( spec , strip ) ; s = spec -> line ; SKIPSPACE ( s ) ; if ( ! lineType ) { after_classification } if ( lineType -> isConditional && ( prevType & lineType -> wrongPrecursors ) ) { if ( prevType == LINE_ENDIF ) { rpmlog ( RPMLOG_ERR , _ ( "%s: line %d: %s with no %%if\n" ) , ofi -> fileName , ofi -> lineNum , lineType -> text ) ; } else { rpmlog ( RPMLOG_ERR , _ ( "%s: line %d: %s after %s\n" ) , ofi -> fileName , ofi -> lineNum , lineType -> text , spec -> readStack -> lastConditional -> text ) ; } return PART_ERROR ; } if ( lineType -> id & ( LINE_IFARCH | LINE_ELIFARCH ) ) { ARGMATCH ( s , "%{_target_cpu}" , match ) ; } if ( lineType -> id == LINE_IFNARCH ) { ARGMATCH ( s , "%{_target_cpu}" , match ) ; match = ! match ; } if ( lineType -> id & ( LINE_IFOS | LINE_ELIFOS ) ) { ARGMATCH ( s , "%{_target_os}" , match ) ; } if ( lineType -> id == LINE_IFNOS ) { ARGMATCH ( s , "%{_target_os}" , match ) ; match = ! match ; } if ( lineType -> id & ( LINE_IF | LINE_ELIF ) ) { s += lineType -> textLen ; if ( lineType -> id == LINE_IF ) { checkCondition = spec -> readStack -> reading ; } else { checkCondition = spec -> readStack -> readable ; } if ( checkCondition ) { match = rpmExprBoolFlags ( s , 0 ) ; if ( match < 0 ) { rpmlog ( RPMLOG_ERR , _ ( "%s:%d: bad %s condition: %s\n" ) , ofi -> fileName , ofi -> lineNum , lineType -> text , s ) ; return PART_ERROR ; } } } if ( lineType -> id == LINE_ELSE ) { spec -> readStack -> lastConditional = lineType ; spec -> readStack -> reading = spec -> readStack -> next -> reading && spec -> readStack -> readable ; spec -> line [ 0 ] = '\0' ; } if ( lineType -> id == LINE_ENDIF ) { rl = spec -> readStack ; spec -> readStack = spec -> readStack -> next ; free ( rl ) ; spec -> line [ 0 ] = '\0' ; } if ( spec -> readStack -> reading && ( lineType -> id == LINE_INCLUDE ) ) { char * fileName , * endFileName , * p ; fileName = s + 8 ; SKIPSPACE ( fileName ) ; endFileName = fileName ; { SKIPNONSPACE ( endFileName ) ; p = endFileName ; SKIPSPACE ( p ) ; if ( * p != '\0' ) { endFileName = p ; } } * p != '\0' ; if ( * fileName == '\0' ) { rpmlog ( RPMLOG_ERR , _ ( "%s:%d: malformed %%include statement\n" ) , ofi -> fileName , ofi -> lineNum ) ; return PART_ERROR ; } * endFileName = '\0' ; ofi = pushOFI ( spec , fileName ) ; retry } if ( lineType -> id & LINE_IFANY ) { rl = xmalloc ( sizeof ( * rl ) ) ; rl -> reading = spec -> readStack -> reading && match ; rl -> next = spec -> readStack ; rl -> lineNum = ofi -> lineNum ; rl -> readable = ( ! rl -> reading ) && ( spec -> readStack -> reading ) ; rl -> lastConditional = lineType ; spec -> readStack = rl ; spec -> line [ 0 ] = '\0' ; } if ( lineType -> id & LINE_ELIFANY ) { spec -> readStack -> reading = spec -> readStack -> readable && match ; if ( spec -> readStack -> reading ) { spec -> readStack -> readable = 0 ; } spec -> line [ 0 ] = '\0' ; } after_classification if ( ! spec -> readStack -> reading ) { spec -> line [ 0 ] = '\0' ; } if ( ! ( strip & STRIP_PARSED ) ) { appendStringBufAux ( spec -> parsed , spec -> line , ( strip & STRIP_TRAILINGSPACE ) ) ; } return 0 ; } 