static void nouveau_dsm_pci_probe ( struct pci_dev * pdev , acpi_handle * dhandle_out , bool * has_mux , bool * has_opt , bool * has_opt_flags , bool * has_pr3 ) { acpi_handle dhandle ; bool supports_mux ; int optimus_funcs ; struct pci_dev * parent_pdev ; * has_pr3 = false ; parent_pdev = pci_upstream_bridge ( pdev ) ; if ( parent_pdev ) { if ( parent_pdev -> bridge_d3 ) { * has_pr3 = pci_pr3_present ( parent_pdev ) ; } else { pci_d3cold_disable ( pdev ) ; } } dhandle = ACPI_HANDLE ( & pdev -> dev ) ; if ( ! acpi_has_method ( dhandle , "_DSM" ) ) { return ; } supports_mux = acpi_check_dsm ( dhandle , & nouveau_dsm_muid , 0x00000102 , 1 << NOUVEAU_DSM_POWER ) ; optimus_funcs = nouveau_dsm_get_optimus_functions ( dhandle ) ; if ( ! supports_mux && ! optimus_funcs ) { return ; } * dhandle_out = dhandle ; * has_mux = supports_mux ; * has_opt = ! ! optimus_funcs ; * has_opt_flags = optimus_funcs & ( 1 << NOUVEAU_DSM_OPTIMUS_FLAGS ) ; if ( optimus_funcs ) { uint32_t result ; nouveau_optimus_dsm ( dhandle , NOUVEAU_DSM_OPTIMUS_CAPS , 0 , & result ) ; dev_info ( & pdev -> dev , "optimus capabilities: %s, status %s%s\n" , ( result & OPTIMUS_ENABLED ) ?"enabled" : "disabled" , ( result & OPTIMUS_DYNAMIC_PWR_CAP ) ?"dynamic power, " : "" , ( result & OPTIMUS_HDA_CODEC_MASK ) ?"hda bios codec supported" : "" ) ; } } 