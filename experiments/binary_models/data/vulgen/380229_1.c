void __ipipe_handle_irq ( unsigned irq , struct pt_regs * regs ) { struct ipipe_percpu_domain_data * p = ipipe_root_cpudom_ptr ( ) ; struct ipipe_domain * this_domain , * next_domain ; struct list_head * head , * pos ; struct ipipe_irqdesc * idesc ; int m_ack , s = - 1 ; m_ack = ( regs == NULL || irq == IRQ_SYSTMR || irq == IRQ_CORETMR ) ; this_domain = __ipipe_current_domain ; idesc = & this_domain -> irqs [ irq ] ; if ( unlikely ( test_bit ( IPIPE_STICKY_FLAG , & idesc -> control ) ) ) { head = & this_domain -> p_link ; } else { head = __ipipe_pipeline . next ; next_domain = list_entry ( head , ipipe_domain , p_link ) ; idesc = & next_domain -> irqs [ irq ] ; if ( likely ( test_bit ( IPIPE_WIRED_FLAG , & idesc -> control ) ) ) { if ( ! m_ack && idesc -> acknowledge != NULL ) { idesc -> acknowledge ( irq , irq_to_desc ( irq ) ) ; } __ipipe_dispatch_wired ( next_domain , irq ) ; out } } pos = head ; while ( pos != & __ipipe_pipeline ) { next_domain = list_entry ( pos , ipipe_domain , p_link ) ; idesc = & next_domain -> irqs [ irq ] ; if ( test_bit ( IPIPE_HANDLE_FLAG , & idesc -> control ) ) { __ipipe_set_irq_pending ( next_domain , irq ) ; if ( ! m_ack && idesc -> acknowledge != NULL ) { idesc -> acknowledge ( irq , irq_to_desc ( irq ) ) ; m_ack = 1 ; } } if ( ! test_bit ( IPIPE_PASS_FLAG , & idesc -> control ) ) { break ; } pos = next_domain -> p_link . next ; } if ( test_bit ( IPIPE_SYNCDEFER_FLAG , & p -> status ) ) { s = __test_and_set_bit ( IPIPE_STALL_FLAG , & p -> status ) ; } if ( test_bit ( IPIPE_AHEAD_FLAG , & this_domain -> flags ) && ! __ipipe_ipending_p ( ipipe_head_cpudom_ptr ( ) ) ) { out } __ipipe_walk_pipeline ( head ) ; out if ( ! s ) { __clear_bit ( IPIPE_STALL_FLAG , & p -> status ) ; } } 