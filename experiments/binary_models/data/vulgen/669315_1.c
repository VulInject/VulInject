int ubi_more_update_data ( struct ubi_device * ubi , struct ubi_volume * vol , const void __user * buf , int count ) { int lnum , offs , err = 0 , len , to_write = count ; int lnum , err = 0 , len , to_write = count ; u32 offs ; dbg_gen ( "write %d of %lld bytes, %lld already passed" , count , vol -> upd_bytes , vol -> upd_received ) ; if ( ubi -> ro_mode ) { return - EROFS ; } lnum = div_u64_rem ( vol -> upd_received , vol -> usable_leb_size , & offs ) ; if ( vol -> upd_received + count > vol -> upd_bytes ) { to_write = count = vol -> upd_bytes - vol -> upd_received ; } if ( offs != 0 ) { len = vol -> usable_leb_size - offs ; if ( len > count ) { len = count ; } err = copy_from_user ( vol -> upd_buf + offs , buf , len ) ; if ( err ) { return - EFAULT ; } if ( offs + len == vol -> usable_leb_size || vol -> upd_received + len == vol -> upd_bytes ) { int flush_len = offs + len ; ubi_assert ( flush_len <= vol -> usable_leb_size ) ; err = write_leb ( ubi , vol , lnum , vol -> upd_buf , flush_len , vol -> upd_ebs ) ; if ( err ) { return err ; } } vol -> upd_received += len ; count -= len ; buf += len ; lnum += 1 ; } while ( count ) { if ( count > vol -> usable_leb_size ) { len = vol -> usable_leb_size ; } else { len = count ; } err = copy_from_user ( vol -> upd_buf , buf , len ) ; if ( err ) { return - EFAULT ; } if ( len == vol -> usable_leb_size || vol -> upd_received + len == vol -> upd_bytes ) { if ( err ) { break ; } } vol -> upd_received += len ; count -= len ; lnum += 1 ; buf += len ; } ubi_assert ( vol -> upd_received <= vol -> upd_bytes ) ; if ( vol -> upd_received == vol -> upd_bytes ) { err = ubi_wl_flush ( ubi , UBI_ALL , UBI_ALL ) ; if ( err ) { return err ; } err = clear_update_marker ( ubi , vol , vol -> upd_bytes ) ; if ( err ) { return err ; } vol -> updating = 0 ; err = to_write ; vfree ( vol -> upd_buf ) ; } return err ; } 