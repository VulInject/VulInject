static void ipoib_ib_handle_rx_wc ( struct net_device * dev , struct ib_wc * wc ) { struct ipoib_dev_priv * priv = ipoib_priv ( dev ) ; unsigned int wr_id = wc -> wr_id & ~ IPOIB_OP_RECV ; struct sk_buff * skb ; u64 mapping [ IPOIB_UD_RX_SG ] ; union ib_gid * dgid ; union ib_gid * sgid ; ipoib_dbg_data ( priv , "recv completion: id %d, status: %d\n" , wr_id , wc -> status ) ; if ( unlikely ( wr_id >= ipoib_recvq_size ) ) { ipoib_warn ( priv , "recv completion event with wrid %d (>%d)\n" , wr_id , ipoib_recvq_size ) ; return ; } skb = priv -> rx_ring [ wr_id ] . skb ; if ( unlikely ( wc -> status != IB_WC_SUCCESS ) ) { ipoib_ud_dma_unmap_rx ( priv , priv -> rx_ring [ wr_id ] . mapping ) ; dev_kfree_skb_any ( skb ) ; priv -> rx_ring [ wr_id ] . skb = NULL ; return ; } memcpy ( mapping , priv -> rx_ring [ wr_id ] . mapping , IPOIB_UD_RX_SG * sizeof mapping ) ; if ( unlikely ( ! ipoib_alloc_rx_skb ( dev , wr_id ) ) ) { ++ dev -> stats . rx_dropped ; repost } ipoib_dbg_data ( priv , "received %d bytes, SLID 0x%04x\n" , wc -> byte_len , wc -> slid ) ; ipoib_ud_dma_unmap_rx ( priv , mapping ) ; skb_put ( skb , wc -> byte_len ) ; dgid = & ( ( ib_grh * ) skb -> data ) -> dgid ; if ( ! ( wc -> wc_flags & IB_WC_GRH ) || dgid -> raw [ 0 ] != 0xff ) { skb -> pkt_type = PACKET_HOST ; } if ( memcmp ( dgid , dev -> broadcast + 4 , sizeof ( ib_gid ) ) == 0 ) { skb -> pkt_type = PACKET_BROADCAST ; } else { skb -> pkt_type = PACKET_MULTICAST ; } sgid = & ( ( ib_grh * ) skb -> data ) -> sgid ; if ( wc -> slid == priv -> local_lid && wc -> src_qp == priv -> qp -> qp_num ) { int need_repost = 1 ; if ( ( wc -> wc_flags & IB_WC_GRH ) && sgid -> global . interface_id != priv -> local_gid . global . interface_id ) { need_repost = 0 ; } if ( need_repost ) { dev_kfree_skb_any ( skb ) ; repost } } skb_pull ( skb , IB_GRH_BYTES ) ; skb -> protocol = ( ( ipoib_header * ) skb -> data ) -> proto ; skb_add_pseudo_hdr ( skb ) ; ++ dev -> stats . rx_packets ; dev -> stats . rx_bytes += skb -> len ; skb -> dev = dev ; if ( ( dev -> features & NETIF_F_RXCSUM ) && likely ( wc -> wc_flags & IB_WC_IP_CSUM_OK ) ) { skb -> ip_summed = CHECKSUM_UNNECESSARY ; } napi_gro_receive ( & priv -> napi , skb ) ; repost if ( unlikely ( ipoib_ib_post_receive ( dev , wr_id ) ) ) { ipoib_warn ( priv , "ipoib_ib_post_receive failed " "for buf %d\n" , wr_id ) ; } } 