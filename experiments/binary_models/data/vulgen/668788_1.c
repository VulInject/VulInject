static gboolean visual_dump_finish ( wtap_dumper * wdh , int * err , gchar * * err_info ) static void visual_dump_free ( wtap_dumper * wdh ) static int visual_file_type_subtype = - 1 ; void register_visual ( void ) wtap_open_return_val visual_open ( wtap * wth , int * err , gchar * * err_info ) { char magic [ sizeof visual_magic ] ; struct visual_file_hdr vfile_hdr ; struct visual_read_info * visual ; int encap ; if ( ! wtap_read_bytes ( wth -> fh , magic , sizeof magic , err , err_info ) ) { if ( * err != WTAP_ERR_SHORT_READ ) { return WTAP_OPEN_ERROR ; } return WTAP_OPEN_NOT_MINE ; } if ( memcmp ( magic , visual_magic , sizeof visual_magic ) != 0 ) { return WTAP_OPEN_NOT_MINE ; } if ( ! wtap_read_bytes ( wth -> fh , & vfile_hdr , sizeof vfile_hdr , err , err_info ) ) { return WTAP_OPEN_ERROR ; } vfile_hdr . file_version = pletoh16 ( & vfile_hdr . file_version ) ; switch ( pletoh16 ( & vfile_hdr . media_type ) ) { case 6 : encap = WTAP_ENCAP_ETHERNET ; break ; case 9 : encap = WTAP_ENCAP_TOKEN_RING ; break ; case 16 : encap = WTAP_ENCAP_LAPB ; break ; case 22 : case 118 : encap = WTAP_ENCAP_CHDLC_WITH_PHDR ; break ; case 32 : encap = WTAP_ENCAP_FRELAY_WITH_PHDR ; break ; case 37 : encap = WTAP_ENCAP_ATM_PDUS ; break ; default : * err = WTAP_ERR_UNSUPPORTED ; * err_info = ws_strdup_printf ( "visual: network type %u unknown or unsupported" , vfile_hdr . media_type ) ; return WTAP_OPEN_ERROR ; } wth -> file_type_subtype = visual_file_type_subtype ; wth -> file_encap = encap ; wth -> snapshot_length = pletoh16 ( & vfile_hdr . max_length ) ; wth -> subtype_read = visual_read ; wth -> subtype_seek_read = visual_seek_read ; wth -> file_tsprec = WTAP_TSPREC_MSEC ; visual = g_new ( visual_read_info , 1 ) ; wth -> priv = ( void * ) visual ; visual -> num_pkts = pletoh32 ( & vfile_hdr . num_pkts ) ; visual -> start_time = pletoh32 ( & vfile_hdr . start_time ) ; visual -> current_pkt = 1 ; wtap_add_generated_idb ( wth ) ; return WTAP_OPEN_MINE ; } 