static int set_src_addr ( struct pr_set * pr , struct ifaddrlist * * alp ) { union any_in_addr * ap ; struct ifaddrlist * al = NULL ; struct ifaddrlist * tmp1_al = NULL ; struct ifaddrlist * tmp2_al = NULL ; struct sockaddr_in * sin_from = ( sockaddr_in * ) pr -> from ; struct sockaddr_in6 * sin6_from = ( sockaddr_in6 * ) pr -> from ; struct addrinfo * aip ; char errbuf [ ERRBUFSIZE ] ; char abuf [ INET6_ADDRSTRLEN ] ; int num_ifs ; int num_src_ifs ; int i ; uint_t ifaddrflags = 0 ; source = source_input ; if ( device != NULL ) { ifaddrflags |= LIFC_UNDER_IPMP ; } num_ifs = ifaddrlist ( & al , pr -> family , ifaddrflags , errbuf ) ; if ( num_ifs < 0 ) { Fprintf ( stderr , "%s: ifaddrlist: %s\n" , prog , errbuf ) ; exit ( EXIT_FAILURE ) ; } num_src_ifs = 0 ; for ( i = 0 ; i < num_ifs ; i ++ ) { if ( ! ( al [ i ] . flags & IFF_LOOPBACK ) && ( al [ i ] . flags & IFF_UP ) ) { num_src_ifs ++ ; } } if ( num_src_ifs == 0 ) { Fprintf ( stderr , "%s: can't find any %s network interfaces\n" , prog , pr -> name ) ; return ( 0 ) ; } if ( device != NULL ) { tmp1_al = find_device ( al , num_ifs , device ) ; if ( tmp1_al == NULL ) { Fprintf ( stderr , "%s: %s (index %d) is an invalid %s" " interface\n" , prog , device , if_index , pr -> name ) ; return ( 0 ) ; } } if ( source != NULL ) { get_hostinfo ( source , pr -> family , & aip ) ; if ( aip == NULL ) { Fprintf ( stderr , "%s: %s is an invalid %s source address\n" , prog , source , pr -> name ) ; free ( al ) ; return ( 0 ) ; } source = aip -> ai_canonname ; if ( pr -> family == AF_INET ) { ap = ( any_in_addr * ) & ( ( sockaddr_in * ) aip -> ai_addr ) -> sin_addr ; } else { ap = ( any_in_addr * ) & ( ( sockaddr_in6 * ) aip -> ai_addr ) -> sin6_addr ; } tmp2_al = find_ifaddr ( al , num_ifs , ap , pr -> family ) ; if ( tmp2_al == NULL ) { ( void ) inet_ntop ( pr -> family , ap , abuf , sizeof ( abuf ) ) ; Fprintf ( stderr , "%s: %s is not a local %s address\n" , prog , abuf , pr -> name ) ; free ( al ) ; freeaddrinfo ( aip ) ; return ( 0 ) ; } } pick_src = _B_FALSE ; if ( source == NULL ) { if ( device == NULL ) { pick_src = _B_TRUE ; } else { if ( pr -> family == AF_INET ) { set_sin ( pr -> from , & ( tmp1_al -> addr ) , pr -> family ) ; } else { pick_src = _B_TRUE ; } } } else { if ( device == NULL ) { set_sin ( pr -> from , ap , pr -> family ) ; if ( aip -> ai_next != NULL ) { ( void ) inet_ntop ( pr -> family , pr -> from_sin_addr , abuf , sizeof ( abuf ) ) ; Fprintf ( stderr , "%s: Warning: %s has multiple " "addresses; using %s\n" , prog , source , abuf ) ; } } else { if ( pr -> family == AF_INET ) { if ( ! has_addr ( aip , & tmp1_al -> addr ) ) { Fprintf ( stderr , "%s: %s is not on interface %s\n" , prog , source , device ) ; exit ( EXIT_FAILURE ) ; } * ap = tmp1_al -> addr ; } set_sin ( pr -> from , ap , pr -> family ) ; } } if ( pr -> family == AF_INET && ! raw_req ) { sin_from -> sin_family = AF_INET ; sin_from -> sin_port = htons ( ident ) ; if ( bind ( sndsock4 , ( sockaddr * ) pr -> from , sizeof ( sockaddr_in ) ) < 0 ) { Fprintf ( stderr , "%s: bind: %s\n" , prog , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } } if ( pr -> family == AF_INET6 ) { sin6_from -> sin6_family = AF_INET6 ; sin6_from -> sin6_port = htons ( ident ) ; if ( bind ( sndsock6 , ( sockaddr * ) pr -> from , sizeof ( sockaddr_in6 ) ) < 0 ) { Fprintf ( stderr , "%s: bind: %s\n" , prog , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } whereto6 . sin6_flowinfo = htonl ( ( class << 20 ) | flow ) ; } * alp = al ; return ( num_ifs ) ; } 