static int bfi_read_packet ( AVFormatContext * s , AVPacket * pkt ) { BFIContext * bfi = s -> priv_data ; AVIOContext * pb = s -> pb ; int ret , audio_offset , video_offset , chunk_size , audio_size = 0 ; if ( bfi -> nframes == 0 || avio_feof ( pb ) ) { return AVERROR_EOF ; } if ( ! bfi -> avflag ) { uint32_t state = 0 ; while ( state != MKTAG ( 'S' , 'A' , 'V' , 'I' ) ) { if ( avio_feof ( pb ) ) { return AVERROR ( EIO ) ; } state = 256 * state + avio_r8 ( pb ) ; } chunk_size = avio_rl32 ( pb ) ; avio_rl32 ( pb ) ; audio_offset = avio_rl32 ( pb ) ; avio_rl32 ( pb ) ; video_offset = avio_rl32 ( pb ) ; if ( audio_offset < 0 || video_offset < audio_offset || chunk_size < video_offset ) { av_log ( s , AV_LOG_ERROR , "Invalid audio/video offsets or chunk size\n" ) ; return AVERROR_INVALIDDATA ; } audio_size = video_offset - audio_offset ; ret = av_get_packet ( pb , pkt , audio_size ) ; if ( ret < 0 ) { return ret ; } pkt -> pts = bfi -> audio_frame ; bfi -> audio_frame += ret ; } if ( bfi -> video_size > 0 ) { ret = av_get_packet ( pb , pkt , bfi -> video_size ) ; if ( ret < 0 ) { return ret ; } pkt -> pts = bfi -> video_frame ; bfi -> video_frame += ret / bfi -> video_size ; bfi -> nframes -- ; } else { ret = AVERROR ( EAGAIN ) ; } bfi -> avflag = ! bfi -> avflag ; pkt -> stream_index = bfi -> avflag ; return ret ; } const AVInputFormat ff_bfi_demuxer = { . name = "bfi" . long_name = NULL_IF_CONFIG_SMALL ( "Brute Force&Ignorance" ) . priv_data_size = sizeof ( BFIContext ) . read_probe = bfi_probe . read_header = bfi_read_header . read_packet = bfi_read_packet } ; 