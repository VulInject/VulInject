void read_png_info ( image_dict * idict ) { png_structp png_p ; png_infop info_p ; if ( img_type ( idict ) != IMG_TYPE_PNG ) { normal_error ( "readpng" , "conflicting image dictionary" ) ; } if ( img_file ( idict ) != NULL ) { normal_error ( "readpng" , "image data already read" ) ; } img_totalpages ( idict ) = 1 ; img_pagenum ( idict ) = 1 ; img_xres ( idict ) = img_yres ( idict ) = 0 ; img_file ( idict ) = xfopen ( img_filepath ( idict ) , FOPEN_RBIN_MODE ) ; if ( ( png_p = png_create_read_struct ( PNG_LIBPNG_VER_STRING , NULL , NULL , warn ) ) == NULL ) { normal_error ( "readpng" , "png_create_read_struct() failed" ) ; } img_png_png_ptr ( idict ) = png_p ; if ( ( info_p = png_create_info_struct ( png_p ) ) == NULL ) { normal_error ( "readpng" , "png_create_info_struct() failed" ) ; } img_png_info_ptr ( idict ) = info_p ; if ( setjmp ( png_jmpbuf ( png_p ) ) ) { normal_error ( "readpng" , "internal error" ) ; } png_set_option ( png_p , PNG_MAXIMUM_INFLATE_WINDOW , PNG_OPTION_ON ) ; png_init_io ( png_p , img_file ( idict ) ) ; png_read_info ( png_p , info_p ) ; img_xsize ( idict ) = ( int ) png_get_image_width ( png_p , info_p ) ; img_ysize ( idict ) = ( int ) png_get_image_height ( png_p , info_p ) ; if ( png_get_valid ( png_p , info_p , PNG_INFO_pHYs ) ) { img_xres ( idict ) = round ( 0.0254 * ( double ) png_get_x_pixels_per_meter ( png_p , info_p ) ) ; img_yres ( idict ) = round ( 0.0254 * ( double ) png_get_y_pixels_per_meter ( png_p , info_p ) ) ; } switch ( png_get_color_type ( png_p , info_p ) ) { case PNG_COLOR_TYPE_PALETTE : img_procset ( idict ) |= PROCSET_IMAGE_C | PROCSET_IMAGE_I ; break ; case PNG_COLOR_TYPE_GRAY : case PNG_COLOR_TYPE_GRAY_ALPHA : img_procset ( idict ) |= PROCSET_IMAGE_B ; break ; case PNG_COLOR_TYPE_RGB : case PNG_COLOR_TYPE_RGB_ALPHA : img_procset ( idict ) |= PROCSET_IMAGE_C ; break ; default : formatted_error ( "readpng" , "unsupported type of color_type '%i'" , ( int ) png_get_color_type ( png_p , info_p ) ) ; } img_colordepth ( idict ) = png_get_bit_depth ( png_p , info_p ) ; if ( ! img_keepopen ( idict ) ) { close_and_cleanup_png ( idict ) ; } } if ( j % 4 == 0 || j % 4 == 1 ) { pdf_quick_out ( pdf , * r ++ ) ; } else { smask [ smask_ptr ++ ] = * r ++ ; } if ( j % 2 == 0 ) { pdf_quick_out ( pdf , * r ++ ) ; } else { smask [ smask_ptr ++ ] = * r ++ ; } if ( ! ( j % 8 == 6 || j % 8 == 7 ) ) { pdf_quick_out ( pdf , * r ++ ) ; } else { smask [ smask_ptr ++ ] = * r ++ ; } if ( j % 4 != 3 ) { pdf_quick_out ( pdf , * r ++ ) ; } else { smask [ smask_ptr ++ ] = * r ++ ; } for ( i = 0 ; i < ( int ) png_get_image_height ( png_p , info_p ) ; i ++ ) { png_read_row ( png_p , row , NULL ) ; r = row ; k = ( size_t ) png_get_rowbytes ( png_p , info_p ) ; while ( k > 0 ) { l = ( k > pdf -> buf -> size ) ?pdf -> buf -> size : k ; pdf_room ( pdf , l ) ; for ( j = 0 ; j < l ; j ++ ) { outmac ; } k -= l ; } } for ( i = 0 ; i < ( int ) png_get_image_height ( png_p , info_p ) ; i ++ ) { row = rows [ i ] ; k = ( size_t ) png_get_rowbytes ( png_p , info_p ) ; while ( k > 0 ) { l = ( k > pdf -> buf -> size ) ?pdf -> buf -> size : k ; pdf_room ( pdf , l ) ; for ( j = 0 ; j < l ; j ++ ) { outmac ; } k -= l ; } xfree ( rows [ i ] ) ; } static void write_palette_streamobj ( PDF pdf , int palette_objnum , png_colorp palette , int num_palette ) { int i ; if ( palette_objnum == 0 ) { return ; } assert ( palette != NULL ) ; pdf_begin_obj ( pdf , palette_objnum , OBJSTM_NEVER ) ; pdf_begin_dict ( pdf ) ; pdf_dict_add_streaminfo ( pdf ) ; pdf_end_dict ( pdf ) ; pdf_begin_stream ( pdf ) ; for ( i = 0 ; i < num_palette ; i ++ ) { pdf_room ( pdf , 3 ) ; pdf_quick_out ( pdf , palette [ i ] . red ) ; pdf_quick_out ( pdf , palette [ i ] . green ) ; pdf_quick_out ( pdf , palette [ i ] . blue ) ; } pdf_end_stream ( pdf ) ; pdf_end_obj ( pdf ) ; } 