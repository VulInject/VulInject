static handler_t proxy_create_env ( gw_handler_ctx * gwhctx ) { handler_ctx * hctx = ( handler_ctx * ) gwhctx ; request_st * const r = hctx -> gw . r ; const int remap_headers = ( NULL != hctx -> conf . header . urlpaths || NULL != hctx -> conf . header . hosts_request ) ; size_t rsz = ( size_t ) ( r -> read_queue . bytes_out - hctx -> gw . wb . bytes_in ) ; if ( rsz >= 65536 ) { rsz = r -> rqst_header_len ; } buffer * const b = chunkqueue_prepend_buffer_open_sz ( & hctx -> gw . wb , rsz ) ; const buffer * const m = http_method_buf ( ! r -> h2_connect_ext ?r -> http_method : HTTP_METHOD_GET ) ; buffer_append_str3 ( b , BUF_PTR_LEN ( m ) , CONST_STR_LEN ( " " ) , BUF_PTR_LEN ( & r -> target ) ) ; if ( remap_headers ) { http_header_remap_uri ( b , buffer_clen ( b ) - buffer_clen ( & r -> target ) , & hctx -> conf . header , 1 ) ; } buffer_append_string_len ( b , ! hctx -> conf . header . force_http10 ?" HTTP/1.1" : " HTTP/1.0" , sizeof ( " HTTP/1.1" ) - 1 ) ; if ( hctx -> conf . replace_http_host && ! buffer_is_blank ( hctx -> gw . host -> id ) ) { if ( hctx -> gw . conf . debug > 1 ) { log_error ( r -> conf . errh , __FILE__ , __LINE__ , "proxy - using \"%s\" as HTTP Host" , hctx -> gw . host -> id -> ptr ) ; } buffer_append_str2 ( b , CONST_STR_LEN ( "\r\nHost: " ) , BUF_PTR_LEN ( hctx -> gw . host -> id ) ) ; } if ( r -> http_host && ! buffer_is_unset ( r -> http_host ) ) { buffer_append_str2 ( b , CONST_STR_LEN ( "\r\nHost: " ) , BUF_PTR_LEN ( r -> http_host ) ) ; if ( remap_headers ) { size_t alen = buffer_clen ( r -> http_host ) ; http_header_remap_host ( b , buffer_clen ( b ) - alen , & hctx -> conf . header , 1 , alen ) ; } } else { b -> ptr [ b -> used - 2 ] = '0' ; } if ( r -> reqbody_length > 0 || ( 0 == r -> reqbody_length && ! http_method_get_or_head ( r -> http_method ) ) ) { const buffer * vb = http_header_request_get ( r , HTTP_HEADER_CONTENT_LENGTH , CONST_STR_LEN ( "Content-Length" ) ) ; if ( NULL == vb ) { buffer_append_int ( http_header_request_set_ptr ( r , HTTP_HEADER_CONTENT_LENGTH , CONST_STR_LEN ( "Content-Length" ) ) , r -> reqbody_length ) ; } } if ( r -> h2_connect_ext ) { } if ( - 1 == r -> reqbody_length && ( r -> conf . stream_request_body & ( FDEVENT_STREAM_REQUEST | FDEVENT_STREAM_REQUEST_BUFMIN ) ) ) { if ( __builtin_expect ( ( hctx -> conf . header . force_http10 ) , 0 ) ) { return http_response_reqbody_read_error ( r , 411 ) ; } hctx -> gw . stdin_append = proxy_stdin_append ; buffer_append_string_len ( b , CONST_STR_LEN ( "\r\nTransfer-Encoding: chunked" ) ) ; } proxy_set_Forwarded ( r -> con , r , hctx -> conf . forwarded ) ; const buffer * connhdr = NULL ; const buffer * te = NULL ; const buffer * upgrade = NULL ; for ( size_t i = 0 , used = r -> rqst_headers . used ; i < used ; ++ i ) { const data_string * const ds = ( data_string * ) r -> rqst_headers . data [ i ] ; switch ( ds -> ext ) { default : break ; case HTTP_HEADER_HOST : continue ; case HTTP_HEADER_OTHER : if ( __builtin_expect ( ( 'p' == ( ds -> key . ptr [ 0 ] | 0x20 ) ) , 0 ) ) { if ( buffer_eq_icase_slen ( & ds -> key , CONST_STR_LEN ( "Proxy-Connection" ) ) ) { continue ; } if ( buffer_eq_icase_slen ( & ds -> key , CONST_STR_LEN ( "Proxy" ) ) ) { continue ; } } break ; case HTTP_HEADER_TE : if ( hctx -> conf . header . force_http10 || r -> http_version == HTTP_VERSION_1_0 ) { continue ; } if ( ! buffer_eq_icase_slen ( & ds -> value , CONST_STR_LEN ( "trailers" ) ) ) { continue ; } te = & ds -> value ; break ; case HTTP_HEADER_UPGRADE : if ( hctx -> conf . header . force_http10 || ( r -> http_version != HTTP_VERSION_1_1 && ! r -> h2_connect_ext ) ) { continue ; } if ( ! hctx -> conf . header . upgrade ) { continue ; } if ( ! buffer_is_blank ( & ds -> value ) ) { upgrade = & ds -> value ; } break ; case HTTP_HEADER_CONNECTION : connhdr = & ds -> value ; continue ; case HTTP_HEADER_SET_COOKIE : continue ; } const uint32_t klen = buffer_clen ( & ds -> key ) ; const uint32_t vlen = buffer_clen ( & ds -> value ) ; if ( 0 == klen || 0 == vlen ) { continue ; } char * restrict s = buffer_extend ( b , klen + vlen + 4 ) ; s [ 0 ] = '\r' ; s [ 1 ] = '\n' ; memcpy ( s + 2 , ds -> key . ptr , klen ) ; s += 2 + klen ; s [ 0 ] = ':' ; s [ 1 ] = ' ' ; memcpy ( s + 2 , ds -> value . ptr , vlen ) ; if ( ! remap_headers ) { continue ; } switch ( klen ) { default : continue ; case 3 : if ( ds -> ext == HTTP_HEADER_OTHER && buffer_eq_icase_slen ( & ds -> key , CONST_STR_LEN ( "URI" ) ) ) { break ; } continue ; case 8 : if ( ds -> ext == HTTP_HEADER_LOCATION ) { break ; } continue ; case 11 : if ( ds -> ext == HTTP_HEADER_OTHER && buffer_eq_icase_slen ( & ds -> key , CONST_STR_LEN ( "Destination" ) ) ) { break ; } continue ; case 16 : continue ; } http_header_remap_uri ( b , buffer_clen ( b ) - vlen , & hctx -> conf . header , 1 ) ; } if ( connhdr && ! hctx -> conf . header . force_http10 && r -> http_version >= HTTP_VERSION_1_1 && ! buffer_eq_icase_slen ( connhdr , CONST_STR_LEN ( "close" ) ) ) { buffer_append_string_len ( b , CONST_STR_LEN ( "\r\nConnection: close" ) ) ; if ( te ) { buffer_append_string_len ( b , CONST_STR_LEN ( ", te" ) ) ; } if ( upgrade ) { buffer_append_string_len ( b , CONST_STR_LEN ( ", upgrade" ) ) ; } buffer_append_string_len ( b , CONST_STR_LEN ( "\r\n\r\n" ) ) ; } if ( r -> h2_connect_ext ) { if ( ! http_header_request_get ( r , HTTP_HEADER_OTHER , CONST_STR_LEN ( "Sec-WebSocket-Key" ) ) ) { buffer_append_string_len ( b , CONST_STR_LEN ( "\r\nSec-WebSocket-Key: MDAwMDAwMDAwMDAwMDAwMA==" ) ) ; } buffer_append_string_len ( b , CONST_STR_LEN ( "\r\nUpgrade: websocket" "\r\nConnection: close, upgrade\r\n\r\n" ) ) ; } else { buffer_append_string_len ( b , CONST_STR_LEN ( "\r\nConnection: close\r\n\r\n" ) ) ; } hctx -> gw . wb_reqlen = buffer_clen ( b ) ; chunkqueue_prepend_buffer_commit ( & hctx -> gw . wb ) ; if ( r -> reqbody_length ) { if ( r -> reqbody_length > 0 ) { hctx -> gw . wb_reqlen += r -> reqbody_length ; } else { hctx -> gw . wb_reqlen = - hctx -> gw . wb_reqlen ; } if ( hctx -> gw . stdin_append == proxy_stdin_append ) { proxy_stdin_append ( & hctx -> gw ) ; } else { chunkqueue_append_chunkqueue ( & hctx -> gw . wb , & r -> reqbody_queue ) ; } } plugin_stats_inc ( "proxy.requests" ) ; return HANDLER_GO_ON ; } 