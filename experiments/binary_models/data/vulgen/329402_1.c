subsym_substitute ( , ) char * line ; int forced ; { char * replacement ; char * head ; char * ptr ; int changed = 0 ; int eval_line = 0 ; int eval_symbol = 0 ; char * eval_end = NULL ; int recurse = 1 ; int line_conditional = 0 ; char * tmp ; replacement = xmalloc ( strlen ( line ) + 1 ) ; strcpy ( replacement , line ) ; ptr = head = replacement ; if ( strstr ( line , ".if" ) || strstr ( line , ".elseif" ) || strstr ( line , ".break" ) ) { line_conditional = 1 ; } if ( strstr ( line , ".eval" ) || strstr ( line , ".asg" ) ) { eval_line = 1 ; } if ( strstr ( line , ".macro" ) ) { return line ; } while ( ! is_end_of_line [ ( int ) * ptr ] ) { int current_char = * ptr ; if ( eval_line ) { eval_end = strrchr ( ptr , ',' ) ; } if ( current_char == '"' && ptr [ 1 ] == '"' && ptr [ 2 ] == '"' ) { ptr [ 1 ] = '\\' ; tmp = strstr ( ptr + 2 , "\"\"\"" ) ; if ( tmp ) { tmp [ 0 ] = '\\' ; } changed = 1 ; } if ( line_conditional && current_char == '=' ) { if ( ptr [ 1 ] == '=' ) { ptr += 2 ; continue ; } * ptr ++ = '\0' ; tmp = xmalloc ( strlen ( head ) + 2 + strlen ( ptr ) + 1 ) ; sprintf ( tmp , "%s==%s" , head , ptr ) ; ptr = tmp + strlen ( head ) + 2 ; head = replacement = tmp ; changed = 1 ; } if ( eval_line && ptr >= eval_end ) { eval_symbol = 1 ; } if ( ( forced && current_char == ':' ) || ( ! forced && is_name_beginner ( current_char ) ) ) { char * name ; char * savedp = input_line_pointer ; int c ; char * value = NULL ; char * tail ; if ( forced ) { ++ ptr ; } name = input_line_pointer = ptr ; c = get_symbol_end ( ) ; if ( c == '?' ) { * input_line_pointer ++ = c ; c = * input_line_pointer ; * input_line_pointer = '\0' ; } if ( hash_find ( subsym_recurse_hash , name ) == NULL ) { value = subsym_lookup ( name , macro_level ) ; } else { as_warn ( _ ( "%s symbol recursion stopped at " "second appearance of '%s'" ) , forced ?"Forced substitution" : "Substitution" , name ) ; } ptr = tail = input_line_pointer ; input_line_pointer = savedp ; if ( ( * name == '$' && ISDIGIT ( name [ 1 ] ) && name [ 2 ] == '\0' ) || name [ strlen ( name ) - 1 ] == '?' ) { value = hash_find ( local_label_hash [ macro_level ] , name ) ; if ( value == NULL ) { char digit [ 11 ] ; char * namecopy = strcpy ( xmalloc ( strlen ( name ) + 1 ) , name ) ; value = strcpy ( xmalloc ( strlen ( name ) + sizeof ( digit ) + 1 ) , name ) ; if ( * value != '$' ) { value [ strlen ( value ) - 1 ] = '\0' ; } sprintf ( digit , ".%d" , local_label_id ++ ) ; strcat ( value , digit ) ; hash_insert ( local_label_hash [ macro_level ] , namecopy , value ) ; } ptr = tail ; } if ( value != NULL && * name == '$' ) { subsym_proc_entry * entry = ( subsym_proc_entry * ) value ; math_proc_entry * math_entry = hash_find ( math_hash , name ) ; char * arg1 , * arg2 = NULL ; * ptr = c ; if ( entry == NULL ) { as_bad ( _ ( "Unrecognized substitution symbol function" ) ) ; break ; } if ( * ptr != '(' ) { as_bad ( _ ( "Missing '(' after substitution symbol function" ) ) ; break ; } ++ ptr ; if ( math_entry != NULL ) { float arg1 , arg2 = 0 ; volatile float fresult ; arg1 = ( float ) strtod ( ptr , & ptr ) ; if ( math_entry -> nargs == 2 ) { if ( * ptr ++ != ',' ) { as_bad ( _ ( "Expecting second argument" ) ) ; break ; } arg2 = ( float ) strtod ( ptr , & ptr ) ; } fresult = * math_entry -> proc ( arg1 , arg2 ) ; value = xmalloc ( 128 ) ; if ( math_entry -> int_return ) { sprintf ( value , "%d" , ( int ) fresult ) ; } else { sprintf ( value , "%f" , fresult ) ; } if ( * ptr ++ != ')' ) { as_bad ( _ ( "Extra junk in function call, expecting ')'" ) ) ; break ; } recurse = 0 ; } else { int val ; int arg_type [ 2 ] { * ptr == '"' 0 } ; ; int ismember = ! strcmp ( entry -> name , "$ismember" ) ; ptr = subsym_get_arg ( ptr , ",)" , & arg1 , ismember ) ; if ( ! arg1 ) { break ; } if ( entry -> nargs == 2 ) { if ( * ptr ++ != ',' ) { as_bad ( _ ( "Function expects two arguments" ) ) ; break ; } arg_type [ 1 ] = ( ISDIGIT ( * ptr ) ) ?2 : ( * ptr == '"' ) ; ptr = subsym_get_arg ( ptr , ")" , & arg2 , ismember ) ; } if ( ( ! strcmp ( entry -> name , "$firstch" ) || ! strcmp ( entry -> name , "$lastch" ) ) && arg_type [ 1 ] != 2 ) { as_bad ( _ ( "Expecting character constant argument" ) ) ; break ; } if ( ismember && ( arg_type [ 0 ] != 0 || arg_type [ 1 ] != 0 ) ) { as_bad ( _ ( "Both arguments must be substitution symbols" ) ) ; break ; } if ( * ptr ++ != ')' ) { as_bad ( _ ( "Extra junk in function call, expecting ')'" ) ) ; break ; } val = * entry -> proc ( arg1 , arg2 ) ; value = xmalloc ( 64 ) ; sprintf ( value , "%d" , val ) ; } tail = ptr ; c = * tail ; } if ( value != NULL && ! eval_symbol ) { if ( recurse ) { hash_insert ( subsym_recurse_hash , name , name ) ; value = subsym_substitute ( value , macro_level > 0 ) ; hash_delete ( subsym_recurse_hash , name ) ; } * name = 0 ; if ( forced ) { if ( c == '(' ) { unsigned beg , len = 1 ; char * newval = strcpy ( xmalloc ( strlen ( value ) + 1 ) , value ) ; savedp = input_line_pointer ; input_line_pointer = tail + 1 ; beg = get_absolute_expression ( ) ; if ( beg < 1 ) { as_bad ( _ ( "Invalid subscript (use 1 to %d)" ) , ( int ) strlen ( value ) ) ; break ; } if ( * input_line_pointer == ',' ) { ++ input_line_pointer ; len = get_absolute_expression ( ) ; if ( beg + len > strlen ( value ) ) { as_bad ( _ ( "Invalid length (use 0 to %d" ) , ( int ) strlen ( value ) - beg ) ; break ; } } newval += beg - 1 ; newval [ len ] = 0 ; tail = input_line_pointer ; if ( * tail ++ != ')' ) { as_bad ( _ ( "Missing ')' in subscripted substitution " "symbol expression" ) ) ; break ; } c = * tail ; input_line_pointer = savedp ; value = newval ; } name [ - 1 ] = 0 ; } tmp = xmalloc ( strlen ( head ) + strlen ( value ) + strlen ( tail + 1 ) + 2 ) ; strcpy ( tmp , head ) ; strcat ( tmp , value ) ; if ( forced ) { if ( c != ':' ) { as_bad ( _ ( "Missing forced substitution terminator ':'" ) ) ; break ; } ++ tail ; } else { * tail = c ; } strcat ( tmp , tail ) ; ptr = tmp + strlen ( head ) + strlen ( value ) ; free ( replacement ) ; head = replacement = tmp ; changed = 1 ; } else { * ptr = c ; } } else { ++ ptr ; } } if ( changed ) { return replacement ; } else { return line ; } } 