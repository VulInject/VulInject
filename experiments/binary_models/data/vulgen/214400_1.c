static int inverse ( AudioFWTDNContext * s , double * * in , int * in_length , double * out , int out_length , int ch , uint64_t sn ) { ChannelParams * cp = & s -> cp [ ch ] ; const int levels = s -> levels ; int leftext = left_ext ( s -> wavelet_length , levels , sn ) ; int temp_skip = 0 ; if ( sn == 0 ) { temp_skip = cp -> min_left_ext ; } memset ( out , 0 , out_length * sizeof ( * out ) ) ; if ( cp -> temp_in_max_length < out_length + cp -> max_left_ext + s -> wavelet_length - 1 ) { av_freep ( & cp -> temp_in ) ; cp -> temp_in_max_length = out_length + cp -> max_left_ext + s -> wavelet_length - 1 ; if ( ! cp -> temp_in ) { cp -> temp_in_max_length = 0 ; return AVERROR ( ENOMEM ) ; } } memset ( cp -> temp_in , 0 , cp -> temp_in_max_length * sizeof ( * cp -> temp_in ) ) ; cp -> temp_in_length = out_length + cp -> max_left_ext ; if ( levels == 1 ) { conv_up ( in [ 1 ] , in [ 0 ] , in_length [ 1 ] , cp -> temp_in , cp -> temp_in_length , s -> ilp , s -> ihp , s -> wavelet_length , cp -> buffer , cp -> buffer2 , cp -> buffer_length ) ; memcpy ( out + cp -> max_left_ext - leftext , cp -> temp_in + temp_skip , FFMAX ( 0 , out_length - ( cp -> max_left_ext - leftext ) ) * sizeof ( * out ) ) ; } else { double * hp1 , * hp2 ; int add , add2 ; if ( cp -> tempa_len_max < ( out_length + cp -> max_left_ext + s -> wavelet_length - 1 ) / 2 ) { av_freep ( & cp -> tempa ) ; cp -> tempa_len_max = ( out_length + cp -> max_left_ext + s -> wavelet_length - 1 ) / 2 ; cp -> tempa = av_calloc ( cp -> tempa_len_max , sizeof ( * cp -> tempa ) ) ; if ( ! cp -> tempa ) { cp -> tempa_len_max = 0 ; return AVERROR ( ENOMEM ) ; } } memset ( cp -> tempa , 0 , cp -> tempa_len_max * sizeof ( * cp -> tempa ) ) ; hp1 = levels & 1 ?cp -> temp_in : cp -> tempa ; hp2 = levels & 1 ?cp -> tempa : cp -> temp_in ; add = append_left_ext ( s -> wavelet_length , levels , levels - 1 , sn ) ; conv_up ( in [ levels ] , in [ levels - 1 ] , in_length [ levels ] , hp1 , in_length [ levels - 2 ] + add , s -> ilp , s -> ihp , s -> wavelet_length , cp -> buffer , cp -> buffer2 , cp -> buffer_length ) ; for ( int level = levels - 1 ; level > 1 ; level -- ) { add2 = append_left_ext ( s -> wavelet_length , levels , level - 1 , sn ) ; add = append_left_ext ( s -> wavelet_length , levels , level , sn ) ; conv_up ( hp1 , in [ level - 1 ] - add , in_length [ level - 1 ] + add , hp2 , in_length [ level - 2 ] + add2 , s -> ilp , s -> ihp , s -> wavelet_length , cp -> buffer , cp -> buffer2 , cp -> buffer_length ) ; FFSWAP ( double * , hp1 , hp2 ) ; } add = append_left_ext ( s -> wavelet_length , levels , 1 , sn ) ; conv_up ( hp1 , in [ 0 ] - add , in_length [ 0 ] + add , cp -> temp_in , cp -> temp_in_length , s -> ilp , s -> ihp , s -> wavelet_length , cp -> buffer , cp -> buffer2 , cp -> buffer_length ) ; } memset ( cp -> temp_in , 0 , temp_skip * sizeof ( * cp -> temp_in ) ) ; if ( s -> overlap_length <= out_length ) { memcpy ( out + cp -> max_left_ext - leftext , cp -> temp_in + temp_skip , FFMAX ( 0 , out_length - ( cp -> max_left_ext - leftext ) ) * sizeof ( * out ) ) ; for ( int i = 0 ; i < FFMIN ( s -> overlap_length , out_length ) ; i ++ ) { out [ i ] += cp -> overlap [ i ] ; } memcpy ( cp -> overlap , cp -> temp_in + out_length - ( cp -> max_left_ext - leftext ) , s -> overlap_length * sizeof ( * cp -> overlap ) ) ; } else { for ( int i = 0 ; i < s -> overlap_length - ( cp -> max_left_ext - leftext ) ; i ++ ) { cp -> overlap [ i + cp -> max_left_ext - leftext ] += cp -> temp_in [ i ] ; } memcpy ( out , cp -> overlap , out_length * sizeof ( * out ) ) ; memmove ( cp -> overlap , cp -> overlap + out_length , ( s -> overlap_length - out_length ) * sizeof ( * cp -> overlap ) ) ; memcpy ( cp -> overlap + s -> overlap_length - out_length , cp -> temp_in + leftext , out_length * sizeof ( * cp -> overlap ) ) ; } return 0 ; } 