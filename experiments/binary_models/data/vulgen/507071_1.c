static void * mlx4_en_add ( struct mlx4_dev * dev ) { struct mlx4_en_dev * mdev ; int i ; printk_once ( KERN_INFO "%s" , mlx4_en_version ) ; mdev = kzalloc ( sizeof ( * mdev ) , GFP_KERNEL ) ; if ( mlx4_pd_alloc ( dev , & mdev -> priv_pdn ) ) { err_free_dev } if ( mlx4_uar_alloc ( dev , & mdev -> priv_uar ) ) { err_pd } mdev -> uar_map = ioremap ( ( phys_addr_t ) mdev -> priv_uar . pfn << PAGE_SHIFT , PAGE_SIZE ) ; if ( ! mdev -> uar_map ) { err_uar } spin_lock_init ( & mdev -> uar_lock ) ; mdev -> dev = dev ; mdev -> dma_device = & dev -> persist -> pdev -> dev ; mdev -> pdev = dev -> persist -> pdev ; mdev -> device_up = false ; mdev -> LSO_support = ! ! ( dev -> caps . flags & ( 1 << 15 ) ) ; if ( ! mdev -> LSO_support ) { mlx4_warn ( mdev , "LSO not supported, please upgrade to later FW version to enable LSO\n" ) ; } if ( mlx4_mr_alloc ( mdev -> dev , mdev -> priv_pdn , 0 , ~ 0ull , MLX4_PERM_LOCAL_WRITE | MLX4_PERM_LOCAL_READ , 0 , 0 , & mdev -> mr ) ) { mlx4_err ( mdev , "Failed allocating memory region\n" ) ; err_map } if ( mlx4_mr_enable ( mdev -> dev , & mdev -> mr ) ) { mlx4_err ( mdev , "Failed enabling memory region\n" ) ; err_mr } mlx4_en_get_profile ( mdev ) ; mdev -> port_cnt = 0 ; mlx4_foreach_port ( , , ) mdev -> port_cnt ++ ; mlx4_en_set_num_rx_rings ( mdev ) ; mdev -> workqueue = create_singlethread_workqueue ( "mlx4_en" ) ; if ( ! mdev -> workqueue ) { err_mr } mutex_init ( & mdev -> state_lock ) ; mdev -> device_up = true ; return mdev ; err_mr ( void ) mlx4_mr_free ( dev , & mdev -> mr ) ; err_map if ( mdev -> uar_map ) { iounmap ( mdev -> uar_map ) ; } err_uar mlx4_uar_free ( dev , & mdev -> priv_uar ) ; err_pd mlx4_pd_free ( dev , mdev -> priv_pdn ) ; err_free_dev kfree ( mdev ) ; err_free_res return NULL ; } 