static void populate_segments ( struct ta_elf * elf ) { TEE_Result res = TEE_SUCCESS ; struct segment * seg = NULL ; vaddr_t va = 0 ; size_t pad_begin = 0 ; assert ( ! elf -> is_legacy ) ; TAILQ_FOREACH ( , , ) { struct segment * last_seg = TAILQ_LAST ( & elf -> segs , segment_head ) ; size_t pad_end = roundup ( last_seg -> vaddr + last_seg -> memsz - seg -> vaddr - seg -> memsz ) ; if ( seg -> remapped_writeable ) { size_t num_bytes = roundup ( seg -> vaddr + seg -> memsz ) - rounddown ( seg -> vaddr ) ; assert ( elf -> load_addr ) ; va = rounddown ( elf -> load_addr + seg -> vaddr ) ; assert ( va >= elf -> max_addr ) ; res = sys_map_zi ( num_bytes , 0 , & va , 0 , pad_end ) ; if ( res ) { err ( res , "sys_map_zi" ) ; } copy_remapped_to ( elf , seg ) ; elf -> max_addr = va + num_bytes ; } else { uint32_t flags = 0 ; size_t filesz = seg -> filesz ; size_t memsz = seg -> memsz ; size_t offset = seg -> offset ; size_t vaddr = seg -> vaddr ; if ( offset < elf -> max_offs ) { if ( vaddr + filesz < SMALL_PAGE_SIZE ) { size_t num_bytes = 0 ; if ( vaddr + memsz <= SMALL_PAGE_SIZE ) { continue ; } va = elf -> max_addr ; num_bytes = roundup ( vaddr + memsz ) - roundup ( vaddr ) - SMALL_PAGE_SIZE ; assert ( num_bytes ) ; res = sys_map_zi ( num_bytes , 0 , & va , 0 , 0 ) ; if ( res ) { err ( res , "sys_map_zi" ) ; } continue ; } vaddr += SMALL_PAGE_SIZE ; filesz -= SMALL_PAGE_SIZE ; memsz -= SMALL_PAGE_SIZE ; offset += SMALL_PAGE_SIZE ; } if ( ! elf -> load_addr ) { va = 0 ; pad_begin = get_pad_begin ( ) ; } else { va = vaddr + elf -> load_addr ; pad_begin = 0 ; } if ( seg -> flags & PF_W ) { flags |= LDELF_MAP_FLAG_WRITEABLE ; } else { flags |= LDELF_MAP_FLAG_SHAREABLE ; } if ( seg -> flags & PF_X ) { flags |= LDELF_MAP_FLAG_EXECUTABLE ; } if ( ! ( seg -> flags & PF_R ) ) { err ( TEE_ERROR_NOT_SUPPORTED , "Segment must be readable" ) ; } if ( flags & LDELF_MAP_FLAG_WRITEABLE ) { res = sys_map_zi ( memsz , 0 , & va , pad_begin , pad_end ) ; if ( pad_begin && res == TEE_ERROR_OUT_OF_MEMORY ) { res = sys_map_zi ( memsz , 0 , & va , 0 , pad_end ) ; } if ( res ) { err ( res , "sys_map_zi" ) ; } res = sys_copy_from_ta_bin ( ( void * ) va , filesz , elf -> handle , offset ) ; if ( res ) { err ( res , "sys_copy_from_ta_bin" ) ; } } else { if ( filesz != memsz ) { err ( TEE_ERROR_BAD_FORMAT , "Filesz and memsz mismatch" ) ; } res = sys_map_ta_bin ( & va , filesz , flags , elf -> handle , offset , pad_begin , pad_end ) ; if ( pad_begin && res == TEE_ERROR_OUT_OF_MEMORY ) { res = sys_map_ta_bin ( & va , filesz , flags , elf -> handle , offset , 0 , pad_end ) ; } if ( res ) { err ( res , "sys_map_ta_bin" ) ; } } if ( ! elf -> load_addr ) { elf -> load_addr = va ; } elf -> max_addr = roundup ( va + memsz ) ; elf -> max_offs += filesz ; } } } 