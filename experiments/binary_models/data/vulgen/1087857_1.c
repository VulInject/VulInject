static void __init omap_hsmmc_init_one ( struct omap2_hsmmc_info * hsmmcinfo , int ctrl_nr ) { struct omap_hwmod * oh ; struct omap_hwmod * ohs [ 1 ] ; struct omap_device * od ; struct platform_device * pdev ; char oh_name [ MAX_OMAP_MMC_HWMOD_NAME_LEN ] ; struct omap_hsmmc_platform_data * mmc_data ; struct omap_hsmmc_dev_attr * mmc_dev_attr ; char * name ; int res ; mmc_data = kzalloc ( sizeof ( * mmc_data ) , GFP_KERNEL ) ; if ( ! mmc_data ) { pr_err ( "Cannot allocate memory for mmc device!\n" ) ; return ; } res = omap_hsmmc_pdata_init ( hsmmcinfo , mmc_data ) ; if ( res < 0 ) { free_mmc } name = "omap_hsmmc" ; res = snprintf ( oh_name , MAX_OMAP_MMC_HWMOD_NAME_LEN , "mmc%d" , ctrl_nr ) ; WARN ( res >= MAX_OMAP_MMC_HWMOD_NAME_LEN , "String buffer overflow in MMC%d device setup\n" , ctrl_nr ) ; oh = omap_hwmod_lookup ( oh_name ) ; if ( ! oh ) { pr_err ( "Could not look up %s\n" , oh_name ) ; free_name } ohs [ 0 ] = oh ; pdev = platform_device_alloc ( name , ctrl_nr - 1 ) ; if ( ! pdev ) { pr_err ( "Could not allocate pdev for %s\n" , name ) ; free_name } dev_set_name ( & pdev -> dev , "%s.%d" , pdev -> name , pdev -> id ) ; od = omap_device_alloc ( pdev , ohs , 1 ) ; if ( IS_ERR ( od ) ) { pr_err ( "Could not allocate od for %s\n" , name ) ; put_pdev } res = platform_device_add_data ( pdev , mmc_data , sizeof ( omap_hsmmc_platform_data ) ) ; if ( res ) { pr_err ( "Could not add pdata for %s\n" , name ) ; put_pdev } hsmmcinfo -> pdev = pdev ; if ( hsmmcinfo -> deferred ) { free_mmc } res = omap_device_register ( pdev ) ; if ( res ) { pr_err ( "Could not register od for %s\n" , name ) ; free_od } free_mmc free_od omap_device_delete ( od ) ; put_pdev platform_device_put ( pdev ) ; free_name kfree ( mmc_data -> name ) ; free_mmc kfree ( mmc_data ) ; } 