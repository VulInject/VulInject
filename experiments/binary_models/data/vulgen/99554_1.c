void ip6_protocol_deliver_rcu ( struct net * net , struct sk_buff * skb , int nexthdr , bool have_final ) { const struct inet6_protocol * ipprot ; struct inet6_dev * idev ; unsigned int nhoff ; SKB_DR ( reason ) ; bool raw ; resubmit idev = ip6_dst_idev ( skb_dst ( skb ) ) ; nhoff = IP6CB ( skb ) -> nhoff ; if ( ! have_final ) { if ( ! pskb_pull ( skb , skb_transport_offset ( skb ) ) ) { discard } nexthdr = skb_network_header ( skb ) [ nhoff ] ; } resubmit_final raw = raw6_local_deliver ( skb , nexthdr ) ; ipprot = rcu_dereference ( inet6_protos [ nexthdr ] ) ; if ( ipprot ) { int ret ; if ( have_final ) { if ( ! ( ipprot -> flags & INET6_PROTO_FINAL ) ) { discard } } if ( ipprot -> flags & INET6_PROTO_FINAL ) { const struct ipv6hdr * hdr ; int sdif = inet6_sdif ( skb ) ; struct net_device * dev ; have_final = true ; nf_reset_ct ( skb ) ; skb_postpull_rcsum ( skb , skb_network_header ( skb ) , skb_network_header_len ( skb ) ) ; hdr = ipv6_hdr ( skb ) ; if ( sdif ) { dev = dev_get_by_index_rcu ( net , sdif ) ; if ( ! dev ) { discard } } else { dev = skb -> dev ; } if ( ipv6_addr_is_multicast ( & hdr -> daddr ) && ! ipv6_chk_mcast_addr ( dev , & hdr -> daddr , & hdr -> saddr ) && ! ipv6_is_mld ( skb , nexthdr , skb_network_header_len ( skb ) ) ) { SKB_DR_SET ( reason , IP_INADDRERRORS ) ; discard } } if ( ! ( ipprot -> flags & INET6_PROTO_NOPOLICY ) && ! xfrm6_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) { SKB_DR_SET ( reason , XFRM_POLICY ) ; discard } ret = INDIRECT_CALL_2 ( ipprot -> handler , tcp_v6_rcv , udpv6_rcv , skb ) ; if ( ret > 0 ) { else { resubmit } } if ( ret == 0 ) { __IP6_INC_STATS ( net , idev , IPSTATS_MIB_INDELIVERS ) ; } } else { if ( ! raw ) { if ( xfrm6_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) { __IP6_INC_STATS ( net , idev , IPSTATS_MIB_INUNKNOWNPROTOS ) ; icmpv6_send ( skb , ICMPV6_PARAMPROB , ICMPV6_UNK_NEXTHDR , nhoff ) ; SKB_DR_SET ( reason , IP_NOPROTO ) ; } else { SKB_DR_SET ( reason , XFRM_POLICY ) ; } kfree_skb_reason ( skb , reason ) ; } else { __IP6_INC_STATS ( net , idev , IPSTATS_MIB_INDELIVERS ) ; consume_skb ( skb ) ; } } return ; discard __IP6_INC_STATS ( net , idev , IPSTATS_MIB_INDISCARDS ) ; kfree_skb_reason ( skb , reason ) ; } 