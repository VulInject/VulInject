db_query * * createNisPlusEntry ( __nis_table_mapping_t * t , __nis_rule_value_t * rv , db_query * qin , __nis_obj_attr_t * * * objAttr , int * numQueries ) { db_query * * query = 0 ; int r , i , j , ir ; __nis_value_t * rval , * lval ; __nis_mapping_item_t * litem ; int numItems ; int nq ; __nis_obj_attr_t * * attr = 0 ; char * * dn = 0 ; int numDN = 0 ; char * myself = "createNisPlusEntry" ; __nisdb_get_tsd ( ) -> searchBase = t -> objectDN -> read . base ; for ( r = 0 , nq = 0 ; r < t -> numRulesFromLDAP ; r ++ ) { int nrq , ntq , err ; db_query * * newq ; __nis_obj_attr_t * * newattr ; rval = buildRvalue ( & t -> ruleFromLDAP [ r ] -> rhs , mit_ldap , rv , NULL ) ; if ( rval == 0 ) { continue ; } litem = buildLvalue ( & t -> ruleFromLDAP [ r ] -> lhs , & rval , & numItems ) ; if ( litem == 0 ) { freeValue ( rval , 1 ) ; continue ; } lval = 0 ; for ( i = 0 ; i < numItems ; i ++ ) { __nis_value_t * tmpval , * old ; tmpval = getMappingItem ( & litem [ i ] , mit_nisplus , 0 , 0 , NULL ) ; if ( litem [ i ] . type == mit_ldap ) { int stat ; if ( dn == 0 ) { dn = findDNs ( myself , rv , 1 , t -> objectDN -> write . base , & numDN ) ; } stat = storeLDAP ( & litem [ i ] , i , numItems , rval , t -> objectDN , dn , numDN ) ; if ( stat != LDAP_SUCCESS ) { char * iname = "<unknown>" ; if ( tmpval != 0 && tmpval -> numVals == 1 ) { iname = tmpval -> val [ 0 ] . value ; } logmsg ( MSG_NOTIMECHECK , LOG_ERR , "%s: LDAP store \"%s\": %s" , myself , iname , ldap_err2string ( stat ) ) ; } freeValue ( tmpval , 1 ) ; continue ; } old = lval ; lval = concatenateValues ( old , tmpval ) ; freeValue ( tmpval , 1 ) ; freeValue ( old , 1 ) ; } freeMappingItem ( litem , numItems ) ; if ( lval == 0 || lval -> numVals <= 0 || rval -> numVals <= 0 ) { freeValue ( lval , 1 ) ; freeValue ( rval , 1 ) ; continue ; } if ( rval -> numVals > 1 ) { if ( lval -> numVals == 1 && lval -> repeat ) { nrq = rval -> numVals ; } if ( lval -> numVals > 1 && rval -> repeat ) { nrq = 1 + ( ( rval -> numVals - 1 ) / lval -> numVals ) ; } else { nrq = 1 ; } } else { nrq = 1 ; } if ( nq <= 0 ) { ntq = nrq ; } else { ntq = nq * nrq ; } if ( ntq > nq ) { newq = realloc ( query , ntq * sizeof ( query [ 0 ] ) ) ; newattr = realloc ( attr , ntq * sizeof ( attr [ 0 ] ) ) ; if ( newq == 0 || newattr == 0 ) { logmsg ( MSG_NOMEM , LOG_ERR , "%s: realloc(%d) =>NULL" , myself , ntq * sizeof ( query [ 0 ] ) ) ; freeValue ( lval , 1 ) ; freeValue ( rval , 1 ) ; freeQueries ( query , nq ) ; freeObjAttr ( attr , nq ) ; sfree ( newq ) ; freeDNs ( dn , numDN ) ; return ( 0 ) ; } query = newq ; attr = newattr ; } for ( i = 1 , err = 0 ; i < nrq ; i ++ ) { for ( j = 0 ; j < nq ; j ++ ) { query [ ( nq * i ) + j ] = cloneQuery ( query [ j ] , t -> numColumns ) ; if ( query [ ( nq * i ) + j ] == 0 && query [ j ] != 0 ) { err ++ ; } attr [ ( nq * i ) + j ] = cloneObjAttr ( attr [ j ] ) ; if ( attr [ ( nq * i ) + j ] == 0 && attr [ j ] != 0 ) { err ++ ; } } } if ( err > 0 ) { freeValue ( lval , 1 ) ; freeValue ( rval , 1 ) ; freeQueries ( query , ntq ) ; freeObjAttr ( attr , ntq ) ; freeDNs ( dn , numDN ) ; return ( 0 ) ; } if ( nq <= 0 ) { ( void ) memset ( query , 0 , ntq * sizeof ( query [ 0 ] ) ) ; ( void ) memset ( attr , 0 , ntq * sizeof ( attr [ 0 ] ) ) ; for ( i = 0 , err = 0 ; i < ntq ; i ++ ) { query [ i ] = am ( myself , sizeof ( * query [ i ] ) ) ; if ( query [ i ] == 0 ) { err ++ ; break ; } query [ i ] -> components . components_val = am ( myself , t -> numColumns * sizeof ( query [ i ] -> components . components_val [ 0 ] ) ) ; if ( query [ i ] -> components . components_val == 0 ) { err ++ ; break ; } query [ i ] -> components . components_len = 0 ; } if ( err > 0 ) { freeValue ( lval , 1 ) ; freeValue ( rval , 1 ) ; freeQueries ( query , ntq ) ; freeObjAttr ( attr , ntq ) ; freeDNs ( dn , numDN ) ; return ( 0 ) ; } } for ( i = 0 , ir = 0 ; i < lval -> numVals ; i ++ ) { char * oaName = 0 ; int index ; for ( index = 0 ; index < t -> numColumns ; index ++ ) { if ( strncmp ( t -> column [ index ] , lval -> val [ i ] . value , lval -> val [ i ] . length ) == 0 ) { break ; } } if ( index >= t -> numColumns ) { oaName = isObjAttr ( & lval -> val [ i ] ) ; if ( oaName == 0 ) { continue ; } } for ( j = i * nrq ; j < ( i + 1 ) * nrq ; j ++ ) { int k ; ir = ( j < rval -> numVals ) ?j : rval -> numVals - 1 ; for ( k = j % nrq , err = 0 ; k < ntq ; k += nrq ) { int ic , c ; if ( oaName != 0 ) { int fail = setObjAttrField ( oaName , & rval -> val [ ir ] , & attr [ k ] ) ; if ( fail ) { err ++ ; break ; } continue ; } ic = query [ k ] -> components . components_len ; if ( ic >= t -> numColumns ) { continue ; } for ( c = 0 ; c < ic ; c ++ ) { if ( query [ k ] -> components . components_val [ c ] . which_index == index ) { break ; } } if ( c >= ic ) { int l ; char * v ; query [ k ] -> components . components_val [ ic ] . which_index = index ; l = rval -> val [ ir ] . length ; v = rval -> val [ ir ] . value ; if ( rval -> type == vt_string && l > 0 && v [ l - 1 ] != '\0' && v [ l ] == '\0' ) { l ++ ; } query [ k ] -> components . components_val [ ic ] . index_value = buildItem ( l , v ) ; if ( query [ k ] -> components . components_val [ ic ] . index_value == 0 ) { err ++ ; break ; } query [ k ] -> components . components_len ++ ; } } if ( err > 0 ) { freeValue ( lval , 1 ) ; freeValue ( rval , 1 ) ; freeQueries ( query , ntq ) ; freeObjAttr ( attr , ntq ) ; freeDNs ( dn , numDN ) ; return ( 0 ) ; } } } freeValue ( lval , 1 ) ; freeValue ( rval , 1 ) ; nq = ntq ; } freeDNs ( dn , numDN ) ; if ( nq <= 0 ) { sfree ( query ) ; query = 0 ; } if ( query != 0 ) { if ( t -> index . numIndexes > 0 ) { query = filterQuery ( t , query , qin , & attr , & nq ) ; } if ( qin != 0 ) { query = filterQuery ( 0 , query , qin , & attr , & nq ) ; } } if ( query != 0 && numQueries != 0 ) { * numQueries = nq ; } if ( objAttr != 0 ) { * objAttr = attr ; } else { freeObjAttr ( attr , nq ) ; } return ( query ) ; } 