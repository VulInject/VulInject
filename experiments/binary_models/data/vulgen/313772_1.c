void mac_entry_set_port ( mac_learning * ml , mac_entry * e , void * port ) OVS_REQ_WRLOCK ( ml -> rwlock ) ( ( mac_entry_get_port ( ml , e ) != port ) { ml -> need_revalidate = true if ( e -> mlport ) { mac_learning_port * mlport = e -> mlport ovs_list_remove ( & e -> port_lru_node ) } ; } if ( ovs_list_is_empty ( & mlport -> port_lrus ) ) { ovs_assert ( mlport -> heap_node . priority == 1 ) hmap_remove ( & ml -> ports_by_ptr , & mlport -> hmap_node ) } ; ) ; heap_remove ( & ml -> ports_by_usage , & mlport -> heap_node ) ; free ( mlport ) ; { ovs_assert ( mlport -> heap_node . priority > 1 ) ; heap_change ( & ml -> ports_by_usage , & mlport -> heap_node , mlport -> heap_node . priority - 1 ) ; } e -> mlport = NULL ; ( port ) { mac_learning_port * mlport mlport = mac_learning_port_lookup ( ml , port ) if ( ! mlport ) { mlport = xzalloc ( sizeof mlport ) ; hmap_insert ( & ml -> ports_by_ptr , & mlport -> hmap_node , hash_pointer ( port , ml -> secret ) ) ; heap_insert ( & ml -> ports_by_usage , & mlport -> heap_node , 1 ) ; mlport -> port = port ; ovs_list_init ( & mlport -> port_lrus ) ; ; } } ; else { heap_change ( & ml -> ports_by_usage , & mlport -> heap_node , mlport -> heap_node . priority + 1 ) ; } e -> mlport = mlport ; 