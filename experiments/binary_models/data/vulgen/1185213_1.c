u32 rtw_free_stainfo ( struct adapter * padapter , struct sta_info * psta ) { int i ; struct __queue * pfree_sta_queue ; struct recv_reorder_ctrl * preorder_ctrl ; struct sta_xmit_priv * pstaxmitpriv ; struct xmit_priv * pxmitpriv = & padapter -> xmitpriv ; struct sta_priv * pstapriv = & padapter -> stapriv ; struct hw_xmit * phwxmit ; if ( psta == NULL ) { exit } spin_lock_bh ( & psta -> lock ) ; psta -> state &= ~ _FW_LINKED ; spin_unlock_bh ( & psta -> lock ) ; pfree_sta_queue = & pstapriv -> free_sta_queue ; pstaxmitpriv = & psta -> sta_xmitpriv ; spin_lock_bh ( & pxmitpriv -> lock ) ; rtw_free_xmitframe_queue ( pxmitpriv , & psta -> sleep_q ) ; rtw_free_xmitframe_queue ( pxmitpriv , & pstaxmitpriv -> vo_q . sta_pending ) ; list_del_init ( & ( pstaxmitpriv -> vo_q . tx_pending ) ) ; phwxmit = pxmitpriv -> hwxmits ; phwxmit -> accnt -= pstaxmitpriv -> vo_q . qcnt ; pstaxmitpriv -> vo_q . qcnt = 0 ; rtw_free_xmitframe_queue ( pxmitpriv , & pstaxmitpriv -> vi_q . sta_pending ) ; list_del_init ( & ( pstaxmitpriv -> vi_q . tx_pending ) ) ; phwxmit = pxmitpriv -> hwxmits + 1 ; phwxmit -> accnt -= pstaxmitpriv -> vi_q . qcnt ; pstaxmitpriv -> vi_q . qcnt = 0 ; rtw_free_xmitframe_queue ( pxmitpriv , & pstaxmitpriv -> be_q . sta_pending ) ; list_del_init ( & ( pstaxmitpriv -> be_q . tx_pending ) ) ; phwxmit = pxmitpriv -> hwxmits + 2 ; phwxmit -> accnt -= pstaxmitpriv -> be_q . qcnt ; pstaxmitpriv -> be_q . qcnt = 0 ; rtw_free_xmitframe_queue ( pxmitpriv , & pstaxmitpriv -> bk_q . sta_pending ) ; list_del_init ( & ( pstaxmitpriv -> bk_q . tx_pending ) ) ; phwxmit = pxmitpriv -> hwxmits + 3 ; phwxmit -> accnt -= pstaxmitpriv -> bk_q . qcnt ; pstaxmitpriv -> bk_q . qcnt = 0 ; spin_unlock_bh ( & pxmitpriv -> lock ) ; list_del_init ( & psta -> hash_list ) ; RT_TRACE ( _module_rtl871x_sta_mgt_c_ , _drv_err_ , ( "\n free number_%d stainfo  with hwaddr = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x \n" , pstapriv -> asoc_sta_count , psta -> hwaddr [ 0 ] , psta -> hwaddr [ 1 ] , psta -> hwaddr [ 2 ] , psta -> hwaddr [ 3 ] , psta -> hwaddr [ 4 ] , psta -> hwaddr [ 5 ] ) ) ; pstapriv -> asoc_sta_count -- ; del_timer_sync ( & psta -> addba_retry_timer ) ; for ( i = 0 ; i < 16 ; i ++ ) { struct list_head * phead , * plist ; union recv_frame * prframe ; struct __queue * ppending_recvframe_queue ; struct __queue * pfree_recv_queue = & padapter -> recvpriv . free_recv_queue ; preorder_ctrl = & psta -> recvreorder_ctrl [ i ] ; del_timer_sync ( & preorder_ctrl -> reordering_ctrl_timer ) ; ppending_recvframe_queue = & preorder_ctrl -> pending_recvframe_queue ; spin_lock_bh ( & ppending_recvframe_queue -> lock ) ; phead = get_list_head ( ppending_recvframe_queue ) ; plist = get_next ( phead ) ; while ( ! list_empty ( phead ) ) { prframe = LIST_CONTAINOR ( plist , recv_frame , u ) ; plist = get_next ( plist ) ; list_del_init ( & ( prframe -> u . hdr . list ) ) ; rtw_free_recvframe ( prframe , pfree_recv_queue ) ; } spin_unlock_bh ( & ppending_recvframe_queue -> lock ) ; } if ( ! ( psta -> state & WIFI_AP_STATE ) ) { rtw_hal_set_odm_var ( padapter , HAL_ODM_STA_INFO , psta , false ) ; } rtw_release_macid ( pstapriv -> padapter , psta ) ; spin_lock_bh ( & pstapriv -> auth_list_lock ) ; if ( ! list_empty ( & psta -> auth_list ) ) { list_del_init ( & psta -> auth_list ) ; pstapriv -> auth_list_cnt -- ; } spin_unlock_bh ( & pstapriv -> auth_list_lock ) ; psta -> expire_to = 0 ; psta -> sleepq_ac_len = 0 ; psta -> qos_info = 0 ; psta -> max_sp_len = 0 ; psta -> uapsd_bk = 0 ; psta -> uapsd_be = 0 ; psta -> uapsd_vi = 0 ; psta -> uapsd_vo = 0 ; psta -> has_legacy_ac = 0 ; pstapriv -> sta_dz_bitmap &= ~ BIT ( psta -> aid ) ; pstapriv -> tim_bitmap &= ~ BIT ( psta -> aid ) ; if ( ( psta -> aid > 0 ) && ( pstapriv -> sta_aid [ psta -> aid - 1 ] == psta ) ) { pstapriv -> sta_aid [ psta -> aid - 1 ] = NULL ; psta -> aid = 0 ; } psta -> under_exist_checking = 0 ; list_add_tail ( & psta -> list , get_list_head ( pfree_sta_queue ) ) ; exit return _SUCCESS ; } 