static void nft_payload_eval ( const struct nft_expr * expr , struct nft_regs * regs , const struct nft_pktinfo * pkt ) { const struct nft_payload * priv = nft_expr_priv ( expr ) ; const struct sk_buff * skb = pkt -> skb ; u32 * dest = & regs -> data [ priv -> dreg ] ; int offset ; switch ( priv -> base ) { case NFT_PAYLOAD_LL_HEADER : if ( ! skb_mac_header_was_set ( skb ) ) { err } if ( skb_vlan_tag_present ( skb ) ) { if ( ! nft_payload_copy_vlan ( dest , skb , priv -> offset , priv -> len ) ) { err } return ; } offset = skb_mac_header ( skb ) - skb -> data ; break ; case NFT_PAYLOAD_NETWORK_HEADER : offset = skb_network_offset ( skb ) ; break ; case NFT_PAYLOAD_TRANSPORT_HEADER : if ( ! pkt -> tprot_set ) { err } offset = pkt -> xt . thoff ; break ; default : BUG ( ) ; } offset += priv -> offset ; if ( skb_copy_bits ( skb , offset , dest , priv -> len ) < 0 ) { err } return ; err regs -> verdict . code = NFT_BREAK ; } static const struct nla_policy nft_payload_policy [ NFTA_PAYLOAD_MAX + 1 ] { [ NFTA_PAYLOAD_SREG ] = { . type = NLA_U32 } [ NFTA_PAYLOAD_DREG ] = { . type = NLA_U32 } [ NFTA_PAYLOAD_BASE ] = { . type = NLA_U32 } [ NFTA_PAYLOAD_OFFSET ] = { . type = NLA_U32 } [ NFTA_PAYLOAD_LEN ] = { . type = NLA_U32 } [ NFTA_PAYLOAD_CSUM_TYPE ] = { . type = NLA_U32 } [ NFTA_PAYLOAD_CSUM_OFFSET ] = { . type = NLA_U32 } } ; ; 