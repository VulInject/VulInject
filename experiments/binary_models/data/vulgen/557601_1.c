static bool parse_command_line ( int argc , char * argv [ ] ) { int args_index = 1 ; const char * command = "build" ; bool have_debug_flag = false ; bool have_in_dir = false ; path_t * script_path ; const char * short_args ; int i ; size_t i_arg ; s_mode = MODE_BUILD ; s_in_path = NULL ; s_out_path = NULL ; s_package_path = NULL ; s_script_path = NULL ; s_want_rebuild = false ; s_debug_build = false ; if ( argc >= 2 && argv [ 1 ] [ 0 ] != '-' ) { args_index = 2 ; command = argv [ 1 ] ; if ( strcmp ( command , "build" ) == 0 || strcmp ( command , "b" ) == 0 ) { command = "build" ; s_mode = MODE_BUILD ; have_in_dir = true ; } if ( strcmp ( command , "clean" ) == 0 || strcmp ( command , "c" ) == 0 ) { command = "clean" ; s_mode = MODE_CLEAN ; have_in_dir = true ; } if ( strcmp ( command , "init" ) == 0 ) { command = "init" ; s_mode = MODE_INIT ; } if ( strcmp ( command , "pack" ) == 0 || strcmp ( command , "p" ) == 0 ) { command = "pack" ; s_mode = MODE_PACK ; } if ( strcmp ( command , "version" ) == 0 || strcmp ( command , "v" ) == 0 ) { return false ; } if ( strcmp ( command , "explode" ) == 0 ) { print_cell_quote ( ) ; return false ; } if ( strcmp ( command , "help" ) == 0 || strcmp ( command , "h" ) == 0 ) { print_usage ( ) ; return false ; } else { printf ( "cell: '%s' is not a valid Cell command\n" , command ) ; return false ; } } for ( i = args_index ; i < argc ; ++ i ) { if ( strstr ( argv [ i ] , "--" ) == argv [ i ] ) { if ( strcmp ( argv [ i ] , "--help" ) == 0 ) { print_usage ( ) ; return false ; } if ( strcmp ( argv [ i ] , "--version" ) == 0 ) { print_banner ( true , true ) ; return false ; } if ( strcmp ( argv [ i ] , "--in-dir" ) == 0 ) { if ( ++ i >= argc ) { missing_argument } path_free ( s_in_path ) ; s_in_path = path_new_dir ( argv [ i ] ) ; have_in_dir = true ; } if ( strcmp ( argv [ i ] , "--out-dir" ) == 0 ) { if ( ++ i >= argc ) { missing_argument } path_free ( s_out_path ) ; s_out_path = path_new_dir ( argv [ i ] ) ; } if ( strcmp ( argv [ i ] , "--rebuild" ) == 0 ) { s_want_rebuild = true ; have_in_dir = true ; } if ( strcmp ( argv [ i ] , "--debug" ) == 0 ) { if ( have_debug_flag && ! s_debug_build ) { printf ( "cell: illegal command line, both '--debug' and '--release' specified\n" ) ; return false ; } s_debug_build = true ; have_debug_flag = true ; have_in_dir = true ; } if ( strcmp ( argv [ i ] , "--release" ) == 0 ) { if ( have_debug_flag && s_debug_build ) { printf ( "cell: illegal command line, both '--debug' and '--release' specified\n" ) ; return false ; } s_debug_build = false ; have_debug_flag = true ; have_in_dir = true ; } else { printf ( "cell: invalid option '%s' for 'cell %s'\n" , argv [ i ] , command ) ; return false ; } } if ( argv [ i ] [ 0 ] == '-' ) { short_args = argv [ i ] ; for ( i_arg = strlen ( short_args ) - 1 ; i_arg >= 1 ; -- i_arg ) { switch ( short_args [ i_arg ] ) { case 'i' : if ( ++ i >= argc ) { missing_argument } path_free ( s_in_path ) ; s_in_path = path_new_dir ( argv [ i ] ) ; have_in_dir = true ; break ; case 'o' : if ( ++ i >= argc ) { missing_argument } path_free ( s_out_path ) ; s_out_path = path_new_dir ( argv [ i ] ) ; have_in_dir = true ; break ; case 'r' : s_want_rebuild = true ; have_in_dir = true ; break ; case 'd' : if ( have_debug_flag && ! s_debug_build ) { printf ( "cell: illegal command line, both '--debug' and '--release' specified\n" ) ; return false ; } s_debug_build = true ; have_debug_flag = true ; have_in_dir = true ; break ; case 'h' : print_usage ( ) ; return false ; case 'v' : print_banner ( true , true ) ; return false ; default : printf ( "cell: invalid option '-%c' for 'cell %s'\n" , short_args [ i_arg ] , command ) ; return false ; } } } if ( s_mode == MODE_PACK && s_package_path == NULL ) { s_package_path = path_new ( argv [ i ] ) ; if ( path_filename ( s_package_path ) == NULL ) { printf ( "cell: 'cell pack' target '%s' cannot be a directory\n" , argv [ i - 1 ] ) ; return false ; } have_in_dir = true ; } if ( s_mode == MODE_INIT && s_in_path == NULL ) { s_in_path = path_new_dir ( argv [ i ] ) ; have_in_dir = true ; } else { printf ( "cell: unexpected argument '%s'\n" , argv [ i ] ) ; return false ; } } if ( s_in_path == NULL ) { s_in_path = path_new ( "./" ) ; } if ( s_out_path == NULL ) { s_out_path = path_rebase ( path_new ( "dist/" ) , s_in_path ) ; } if ( ! have_debug_flag ) { s_debug_build = s_mode == MODE_BUILD ; } if ( s_mode == MODE_PACK && s_package_path == NULL ) { printf ( "cell: no SPK filename was provided for 'cell %s'\n" , command ) ; return false ; } for ( i = 0 ; i < ( int ) ( sizeof CELLSCRIPT_NAMES / sizeof ( const char * ) ) ; ++ i ) { script_path = path_rebase ( path_new ( CELLSCRIPT_NAMES [ i ] ) , s_in_path ) ; if ( path_resolve ( script_path , NULL ) ) { s_script_path = path_new ( CELLSCRIPT_NAMES [ i ] ) ; path_insert_hop ( s_script_path , 0 , "$" ) ; } path_free ( script_path ) ; if ( s_script_path != NULL ) { break ; } } if ( s_script_path == NULL ) { if ( s_mode != MODE_INIT ) { if ( have_in_dir ) { printf ( "cell: no Cellscript found in source directory '%s'\n" , path_cstr ( s_in_path ) ) ; } else { print_usage ( ) ; } return false ; } } if ( s_mode == MODE_INIT ) { printf ( "cell %s: directory '%s' already contains a Cellscript\n" , command , path_cstr ( s_in_path ) ) ; return false ; } return true ; missing_argument printf ( "cell: '%s' requires an argument\n" , argv [ i - 1 ] ) ; return false ; } 