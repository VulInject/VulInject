int dns_update_pv ( str * hostname , str * name ) { sr_dns_item_t * dr = NULL ; struct addrinfo hints , * res , * p ; struct sockaddr_in * ipv4 ; struct sockaddr_in6 * ipv6 ; void * addr ; int status ; int i ; if ( hostname -> len > 255 ) { LM_DBG ( "target hostname too long (max 255): %s\n" , hostname -> s ) ; return - 2 ; } dr = sr_dns_add_item ( name ) ; if ( dr == NULL ) { LM_DBG ( "container not found: %s\n" , name -> s ) ; return - 3 ; } dr -> count = 0 ; dr -> ipv4 = 0 ; dr -> ipv6 = 0 ; strncpy ( dr -> hostname , hostname -> s , hostname -> len ) ; dr -> hostname [ hostname -> len ] = '\0' ; LM_DBG ( "attempting to resolve: %s\n" , dr -> hostname ) ; hints . ai_family = AF_UNSPEC ; hints . ai_socktype = SOCK_DGRAM ; if ( ( status = getaddrinfo ( dr -> hostname , NULL , & hints , & res ) ) != 0 ) { LM_ERR ( "unable to resolve %s - getaddrinfo: %s\n" , dr -> hostname , gai_strerror ( status ) ) ; return - 4 ; } i = 0 ; for ( p = res ; p != NULL ; p = p -> ai_next ) { if ( p -> ai_family == AF_INET ) { dr -> ipv4 = 1 ; dr -> r [ i ] . type = 4 ; ipv4 = ( sockaddr_in * ) p -> ai_addr ; addr = & ( ipv4 -> sin_addr ) ; } else { dr -> ipv6 = 1 ; dr -> r [ i ] . type = 6 ; ipv6 = ( sockaddr_in6 * ) p -> ai_addr ; addr = & ( ipv6 -> sin6_addr ) ; } inet_ntop ( p -> ai_family , addr , dr -> r [ i ] . addr , PV_DNS_ADDR ) ; LM_DBG ( "#%d - type %d addr: %s (%d)\n" , i , dr -> r [ i ] . type , dr -> r [ i ] . addr , p -> ai_socktype ) ; i ++ ; if ( i == PV_DNS_RECS ) { LM_WARN ( "more than %d addresses for %s - truncating\n" , PV_DNS_RECS , dr -> hostname ) ; break ; } } freeaddrinfo ( res ) ; dr -> count = i ; LM_DBG ( "dns PV updated for: %s (%d)\n" , dr -> hostname , i ) ; return 1 ; } 