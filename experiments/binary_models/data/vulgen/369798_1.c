static guint chunked_encoding_dissector ( tvbuff_t * * tvb_ptr , packet_info * pinfo , proto_tree * tree , int offset ) { tvbuff_t * tvb ; guint32 datalen ; guint32 orig_datalen ; gint chunked_data_size ; proto_tree * subtree ; proto_item * pi_chunked = NULL ; guint8 * raw_data ; gint raw_len ; if ( ( tvb_ptr == NULL ) || ( * tvb_ptr == NULL ) ) { return 0 ; } tvb = * tvb_ptr ; datalen = tvb_reported_length_remaining ( tvb , offset ) ; subtree = proto_tree_add_subtree ( tree , tvb , offset , datalen , ett_http_chunked_response , & pi_chunked , "HTTP chunked response" ) ; orig_datalen = datalen ; raw_data = ( guint8 * ) wmem_alloc ( pinfo -> pool , datalen ) ; raw_len = 0 ; chunked_data_size = 0 ; while ( datalen > 0 ) { guint32 chunk_size ; gint chunk_offset ; guint8 * chunk_string ; gint linelen ; gchar * c ; linelen = tvb_find_line_end ( tvb , offset , - 1 , & chunk_offset , TRUE ) ; if ( linelen <= 0 ) { break ; } chunk_string = tvb_get_string_enc ( pinfo -> pool , tvb , offset , linelen , ENC_ASCII ) ; if ( chunk_string == NULL ) { break ; } c = ( gchar * ) chunk_string ; chunk_size = ( guint32 ) strtol ( ( gchar * ) chunk_string , NULL , 16 ) ; if ( chunk_size > datalen ) { chunk_size = datalen ; } chunked_data_size += chunk_size ; DISSECTOR_ASSERT ( ( raw_len + chunk_size ) <= orig_datalen ) ; tvb_memcpy ( tvb , ( guint8 * ) ( raw_data + raw_len ) , chunk_offset , chunk_size ) ; raw_len += chunk_size ; if ( subtree ) { proto_tree * chunk_subtree ; proto_item * chunk_size_item ; if ( chunk_size == 0 ) { chunk_subtree = proto_tree_add_subtree ( subtree , tvb , offset , chunk_offset - offset + chunk_size + 2 , ett_http_chunk_data , NULL , "End of chunked encoding" ) ; } else { chunk_subtree = proto_tree_add_subtree_format ( subtree , tvb , offset , chunk_offset - offset + chunk_size + 2 , ett_http_chunk_data , NULL , "Data chunk (%u octets)" , chunk_size ) ; } chunk_size_item = proto_tree_add_uint ( chunk_subtree , hf_http_chunk_size , tvb , offset , 1 , chunk_size ) ; proto_item_set_len ( chunk_size_item , chunk_offset - offset ) ; if ( chunk_size > 0 ) { proto_tree_add_item ( chunk_subtree , hf_http_chunk_data , tvb , chunk_offset , chunk_size , ENC_NA ) ; proto_tree_add_item ( chunk_subtree , hf_http_chunk_boundary , tvb , chunk_offset + chunk_size , 2 , ENC_NA ) ; } } offset = chunk_offset + chunk_size ; if ( chunk_size > 0 ) { offset += 2 ; } datalen = tvb_reported_length_remaining ( tvb , offset ) ; if ( chunk_size == 0 ) { gint trailer_offset = offset , trailer_len ; gint header_field_len ; { trailer_len = trailer_offset - offset ; header_field_len = tvb_find_line_end ( tvb , trailer_offset , datalen - trailer_len , & trailer_offset , TRUE ) ; } header_field_len > 0 ; if ( trailer_len > 0 ) { proto_tree_add_item ( subtree , hf_http_chunked_trailer_part , tvb , offset , trailer_len , ENC_ASCII ) ; offset += trailer_len ; datalen -= trailer_len ; } if ( header_field_len == 0 ) { proto_tree_add_format_text ( subtree , tvb , offset , trailer_offset - offset ) ; datalen -= trailer_offset - offset ; } break ; } } if ( datalen < orig_datalen ) { tvbuff_t * new_tvb ; proto_item_set_len ( pi_chunked , orig_datalen - datalen ) ; new_tvb = tvb_new_child_real_data ( tvb , raw_data , chunked_data_size , chunked_data_size ) ; * tvb_ptr = new_tvb ; } return orig_datalen - datalen ; } 