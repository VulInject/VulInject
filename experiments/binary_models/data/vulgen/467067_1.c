void ufsdirhash_add ( struct inode * ip , struct direct * dirp , doff_t offset ) { struct dirhash * dh ; int slot ; if ( ( dh = ip -> i_dirhash ) == NULL ) { return ; } DIRHASH_LOCK ( dh ) ; if ( dh -> dh_hash == NULL ) { ufsdirhash_free ( ip ) ; return ; } DIRHASH_ASSERT ( offset < dh -> dh_dirblks * DIRBLKSIZ , ( "ufsdirhash_add: bad offset" ) ) ; if ( dh -> dh_hused >= ( dh -> dh_hlen * 3 ) / 4 ) { DIRHASH_UNLOCK ( dh ) ; ufsdirhash_free ( ip ) ; return ; } slot = ufsdirhash_hash ( dh , dirp -> d_name , dirp -> d_namlen ) ; while ( DH_ENTRY ( dh , slot ) >= 0 ) { slot = WRAPINCR ( slot , dh -> dh_hlen ) ; } if ( DH_ENTRY ( dh , slot ) == DIRHASH_EMPTY ) { dh -> dh_hused ++ ; } DH_ENTRY ( dh , slot ) = offset ; ufsdirhash_adjfree ( dh , offset , - DIRSIZ ( 0 , dirp ) ) ; DIRHASH_UNLOCK ( dh ) ; } 