static int omapvid_setup_overlay ( struct omap_vout_device * vout , struct omap_overlay * ovl , int posx , int posy , int outw , int outh , dma_addr_t addr ) { int ret = 0 ; struct omap_overlay_info info ; int cropheight , cropwidth , pixwidth ; if ( ( ovl -> caps & OMAP_DSS_OVL_CAP_SCALE ) == 0 && ( outw != vout -> pix . width || outh != vout -> pix . height ) ) { setup_ovl_err } vout -> dss_mode = video_mode_to_dss_mode ( vout ) ; if ( vout -> dss_mode == - EINVAL ) { ret = - EINVAL ; setup_ovl_err } if ( is_rotation_90_or_270 ( vout ) ) { cropheight = vout -> crop . width ; cropwidth = vout -> crop . height ; pixwidth = vout -> pix . height ; } else { cropheight = vout -> crop . height ; cropwidth = vout -> crop . width ; pixwidth = vout -> pix . width ; } ovl -> get_overlay_info ( ovl , & info ) ; info . paddr = addr ; info . width = cropwidth ; info . height = cropheight ; info . color_mode = vout -> dss_mode ; info . mirror = vout -> mirror ; info . pos_x = posx ; info . pos_y = posy ; info . out_width = outw ; info . out_height = outh ; info . global_alpha = vout -> win . global_alpha ; if ( ! is_rotation_enabled ( vout ) ) { info . rotation = 0 ; info . rotation_type = OMAP_DSS_ROT_DMA ; info . screen_width = pixwidth ; } else { info . rotation = vout -> rotation ; info . rotation_type = OMAP_DSS_ROT_VRFB ; info . screen_width = 2048 ; } v4l2_dbg ( 1 , debug , & vout -> vid_dev -> v4l2_dev , "%s enable=%d addr=%pad width=%d\n height=%d color_mode=%d\n" "rotation=%d mirror=%d posx=%d posy=%d out_width = %d \n" "out_height=%d rotation_type=%d screen_width=%d\n" , __func__ , ovl -> is_enabled ( ovl ) , & info . paddr , info . width , info . height , info . color_mode , info . rotation , info . mirror , info . pos_x , info . pos_y , info . out_width , info . out_height , info . rotation_type , info . screen_width ) ; ret = ovl -> set_overlay_info ( ovl , & info ) ; if ( ret ) { setup_ovl_err } return 0 ; setup_ovl_err v4l2_warn ( & vout -> vid_dev -> v4l2_dev , "setup_overlay failed\n" ) ; return ret ; } 