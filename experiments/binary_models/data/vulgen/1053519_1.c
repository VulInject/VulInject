static int remoteDispatchDomainGetVcpuPinInfo ( virNetServer * server G_GNUC_UNUSED , virNetServerClient * client , virNetMessage * msg G_GNUC_UNUSED , struct virNetMessageError * rerr , remote_domain_get_vcpu_pin_info_args * args , remote_domain_get_vcpu_pin_info_ret * ret ) { virDomainPtr dom = NULL ; unsigned char * cpumaps = NULL ; int num ; int rv = - 1 ; virConnectPtr conn = remoteGetHypervisorConn ( client ) ; if ( ! conn ) { cleanup } if ( ! ( dom = get_nonnull_domain ( conn , args -> dom ) ) ) { cleanup } if ( args -> ncpumaps > REMOTE_VCPUINFO_MAX ) { virReportError ( VIR_ERR_INTERNAL_ERROR , "%s" , _ ( "ncpumaps>REMOTE_VCPUINFO_MAX" ) ) ; cleanup } if ( VIR_INT_MULTIPLY_OVERFLOW ( args -> ncpumaps , args -> maplen ) || args -> ncpumaps * args -> maplen > REMOTE_CPUMAPS_MAX ) { virReportError ( VIR_ERR_INTERNAL_ERROR , "%s" , _ ( "maxinfo * maplen>REMOTE_CPUMAPS_MAX" ) ) ; cleanup } if ( args -> maplen > 0 ) { cpumaps = g_new0 ( , ) ; } if ( ( num = virDomainGetVcpuPinInfo ( dom , args -> ncpumaps , cpumaps , args -> maplen , args -> flags ) ) < 0 ) { cleanup } ret -> num = num ; ret -> cpumaps . cpumaps_len = args -> ncpumaps * args -> maplen ; ret -> cpumaps . cpumaps_val = ( char * ) cpumaps ; cpumaps = NULL ; rv = 0 ; cleanup VIR_FREE ( cpumaps ) ; virObjectUnref ( dom ) ; return rv ; } 