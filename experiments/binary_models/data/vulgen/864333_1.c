static SLPError make_mc_target ( slp_handle_impl_t * hp , struct sockaddr_in * sin , char * header , struct pollfd * * fds , nfds_t * nfds , struct bc_ifs * bcifs ) { unsigned char ttl = slp_get_multicastTTL ( ) ; char * ifs_string ; SLPBoolean have_valid_if = SLP_FALSE ; SLPBoolean use_broadcast = slp_get_usebroadcast ( ) ; int fd , i , num_givenifs ; struct in_addr * given_ifs = NULL ; nfds_t nfd_i ; sin -> sin_port = htons ( SLP_PORT ) ; sin -> sin_family = AF_INET ; slp_set_mcast ( header ) ; bcifs -> sin = NULL ; * fds = NULL ; if ( ( ifs_string = ( char * ) SLPGetProperty ( SLP_CONFIG_INTERFACES ) ) != NULL && * ifs_string ) { char * p , * tstate ; p = strchr ( ifs_string , ',' ) ; for ( num_givenifs = 1 ; p ; num_givenifs ++ ) { p = strchr ( p + 1 , ',' ) ; } if ( ! ( given_ifs = calloc ( num_givenifs , sizeof ( * given_ifs ) ) ) ) { slp_err ( LOG_CRIT , 0 , "make_mc_target" , "out of memory" ) ; return ( SLP_MEMORY_ALLOC_FAILED ) ; } i = 0 ; if ( ! ( ifs_string = strdup ( ifs_string ) ) ) { slp_err ( LOG_CRIT , 0 , "make_mc_target" , "out of memory" ) ; free ( given_ifs ) ; return ( SLP_MEMORY_ALLOC_FAILED ) ; } for ( p = strtok_r ( ifs_string , "," , & tstate ) ; p ; p = strtok_r ( NULL , "," , & tstate ) ) { if ( slp_pton ( p , & ( given_ifs [ i ] ) ) < 1 ) { num_givenifs -- ; continue ; } i ++ ; } * nfds = num_givenifs ; free ( ifs_string ) ; if ( ! ( * fds = calloc ( num_givenifs , sizeof ( * * fds ) ) ) ) { slp_err ( LOG_CRIT , 0 , "make_mc_target" , "out of memory" ) ; free ( ifs_string ) ; free ( given_ifs ) ; return ( SLP_MEMORY_ALLOC_FAILED ) ; } for ( i = 0 ; i < num_givenifs ; i ++ ) { if ( ( fd = socket ( AF_INET , SOCK_DGRAM , 0 ) ) < 0 ) { slp_err ( LOG_CRIT , 0 , "make_mc_target" , "could not create socket: %s" , strerror ( errno ) ) ; free_pfds ( * fds , * nfds ) ; return ( SLP_INTERNAL_SYSTEM_ERROR ) ; } ( * fds ) [ i ] . fd = fd ; ( * fds ) [ i ] . events |= POLLRDNORM ; if ( use_broadcast ) { struct sockaddr_in bcsin [ 1 ] ; ( void ) memcpy ( & ( bcsin -> sin_addr ) , & ( given_ifs [ i ] ) , sizeof ( bcsin -> sin_addr ) ) ; bcsin -> sin_family = AF_INET ; bcsin -> sin_port = 0 ; if ( bind ( fd , ( sockaddr * ) bcsin , sizeof ( * bcsin ) ) == 0 ) { continue ; } slp_err ( LOG_INFO , 0 , "make_mc_target" , "could not set broadcast interface: %s" , strerror ( errno ) ) ; } if ( setsockopt ( fd , IPPROTO_IP , IP_MULTICAST_IF , & ( given_ifs [ i ] ) , sizeof ( given_ifs [ i ] ) ) < 0 ) { slp_err ( LOG_INFO , 0 , "make_mc_target" , "could not set multicast interface: %s" , strerror ( errno ) ) ; continue ; } have_valid_if = SLP_TRUE ; } if ( use_broadcast ) { SLPError err ; if ( ( err = make_bc_target ( hp , given_ifs , num_givenifs , bcifs ) ) != SLP_OK ) { have_valid_if = SLP_FALSE ; } } free ( given_ifs ) ; } if ( ! have_valid_if ) { if ( * fds && ! have_valid_if ) { free ( * fds ) ; } if ( ! ( * fds = calloc ( 1 , sizeof ( * * fds ) ) ) ) { slp_err ( LOG_CRIT , 0 , "make_mc_target" , "out of memory" ) ; return ( SLP_MEMORY_ALLOC_FAILED ) ; } if ( ( fd = socket ( AF_INET , SOCK_DGRAM , 0 ) ) < 0 ) { slp_err ( LOG_CRIT , 0 , "make_mc_target" , "could not create socket: %s" , strerror ( errno ) ) ; free ( * fds ) ; return ( SLP_INTERNAL_SYSTEM_ERROR ) ; } ( * * fds ) . fd = fd ; ( * * fds ) . events |= POLLRDNORM ; * nfds = 1 ; } for ( nfd_i = 0 ; nfd_i < * nfds ; nfd_i ++ ) { if ( use_broadcast ) { const int on = 1 ; if ( setsockopt ( ( * fds ) [ nfd_i ] . fd , SOL_SOCKET , SO_BROADCAST , ( void * ) & on , sizeof ( on ) ) < 0 ) { slp_err ( LOG_CRIT , 0 , "make_mc_target" , "could not enable broadcast: %s" , strerror ( errno ) ) ; } } else { if ( setsockopt ( ( * fds ) [ nfd_i ] . fd , IPPROTO_IP , IP_MULTICAST_TTL , & ttl , 1 ) < 0 ) { slp_err ( LOG_CRIT , 0 , "make_mc_target" , "could not set multicast TTL: %s" , strerror ( errno ) ) ; } } } if ( use_broadcast ) { sin -> sin_addr . s_addr = INADDR_BROADCAST ; } else { sin -> sin_addr . s_addr = SLP_MULTICAST_ADDRESS ; } return ( SLP_OK ) ; } 