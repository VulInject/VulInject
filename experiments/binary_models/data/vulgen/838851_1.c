static void R_RecursiveWorldNode ( mnode_t * node , uint32_t planeBits , uint32_t dlightBits , uint32_t pshadowBits ) { { uint32_t newDlights [ 2 ] ; uint32_t newPShadows [ 2 ] ; if ( ! ( tr . viewParms . flags & VPF_DEPTHSHADOW ) && node -> visCounts [ tr . visIndex ] != tr . visCounts [ tr . visIndex ] ) { return ; } if ( ! r_nocull -> integer ) { int r ; if ( planeBits & 1 ) { r = BoxOnPlaneSide ( node -> mins , node -> maxs , & tr . viewParms . frustum [ 0 ] ) ; if ( r == 2 ) { return ; } if ( r == 1 ) { planeBits &= ~ 1 ; } } if ( planeBits & 2 ) { r = BoxOnPlaneSide ( node -> mins , node -> maxs , & tr . viewParms . frustum [ 1 ] ) ; if ( r == 2 ) { return ; } if ( r == 1 ) { planeBits &= ~ 2 ; } } if ( planeBits & 4 ) { r = BoxOnPlaneSide ( node -> mins , node -> maxs , & tr . viewParms . frustum [ 2 ] ) ; if ( r == 2 ) { return ; } if ( r == 1 ) { planeBits &= ~ 4 ; } } if ( planeBits & 8 ) { r = BoxOnPlaneSide ( node -> mins , node -> maxs , & tr . viewParms . frustum [ 3 ] ) ; if ( r == 2 ) { return ; } if ( r == 1 ) { planeBits &= ~ 8 ; } } if ( planeBits & 16 ) { r = BoxOnPlaneSide ( node -> mins , node -> maxs , & tr . viewParms . frustum [ 4 ] ) ; if ( r == 2 ) { return ; } if ( r == 1 ) { planeBits &= ~ 16 ; } } } if ( node -> contents != - 1 ) { break ; } newDlights [ 0 ] = 0 ; newDlights [ 1 ] = 0 ; if ( dlightBits ) { int i ; for ( i = 0 ; i < tr . refdef . num_dlights ; i ++ ) { dlight_t * dl ; float dist ; if ( dlightBits & ( 1 << i ) ) { dl = & tr . refdef . dlights [ i ] ; dist = DotProduct ( dl -> origin , node -> plane -> normal ) - node -> plane -> dist ; if ( dist > - dl -> radius ) { newDlights [ 0 ] |= ( 1 << i ) ; } if ( dist < dl -> radius ) { newDlights [ 1 ] |= ( 1 << i ) ; } } } } newPShadows [ 0 ] = 0 ; newPShadows [ 1 ] = 0 ; if ( pshadowBits ) { int i ; for ( i = 0 ; i < tr . refdef . num_pshadows ; i ++ ) { pshadow_t * shadow ; float dist ; if ( pshadowBits & ( 1 << i ) ) { shadow = & tr . refdef . pshadows [ i ] ; dist = DotProduct ( shadow -> lightOrigin , node -> plane -> normal ) - node -> plane -> dist ; if ( dist > - shadow -> lightRadius ) { newPShadows [ 0 ] |= ( 1 << i ) ; } if ( dist < shadow -> lightRadius ) { newPShadows [ 1 ] |= ( 1 << i ) ; } } } } R_RecursiveWorldNode ( node -> children [ 0 ] , planeBits , newDlights [ 0 ] , newPShadows [ 0 ] ) ; node = node -> children [ 1 ] ; dlightBits = newDlights [ 1 ] ; pshadowBits = newPShadows [ 1 ] ; } { int c ; int surf , * view ; tr . pc . c_leafs ++ ; if ( node -> mins [ 0 ] < tr . viewParms . visBounds [ 0 ] [ 0 ] ) { tr . viewParms . visBounds [ 0 ] [ 0 ] = node -> mins [ 0 ] ; } if ( node -> mins [ 1 ] < tr . viewParms . visBounds [ 0 ] [ 1 ] ) { tr . viewParms . visBounds [ 0 ] [ 1 ] = node -> mins [ 1 ] ; } if ( node -> mins [ 2 ] < tr . viewParms . visBounds [ 0 ] [ 2 ] ) { tr . viewParms . visBounds [ 0 ] [ 2 ] = node -> mins [ 2 ] ; } if ( node -> maxs [ 0 ] > tr . viewParms . visBounds [ 1 ] [ 0 ] ) { tr . viewParms . visBounds [ 1 ] [ 0 ] = node -> maxs [ 0 ] ; } if ( node -> maxs [ 1 ] > tr . viewParms . visBounds [ 1 ] [ 1 ] ) { tr . viewParms . visBounds [ 1 ] [ 1 ] = node -> maxs [ 1 ] ; } if ( node -> maxs [ 2 ] > tr . viewParms . visBounds [ 1 ] [ 2 ] ) { tr . viewParms . visBounds [ 1 ] [ 2 ] = node -> maxs [ 2 ] ; } view = tr . world -> marksurfaces + node -> firstmarksurface ; c = node -> nummarksurfaces ; while ( c -- ) { surf = * view ; if ( tr . world -> surfacesViewCount [ surf ] != tr . viewCount ) { tr . world -> surfacesViewCount [ surf ] = tr . viewCount ; tr . world -> surfacesDlightBits [ surf ] = dlightBits ; tr . world -> surfacesPshadowBits [ surf ] = pshadowBits ; } else { tr . world -> surfacesDlightBits [ surf ] |= dlightBits ; tr . world -> surfacesPshadowBits [ surf ] |= pshadowBits ; } view ++ ; } } } 