static size_t wrt ( Elf * elf , Xword outsz , unsigned fill , int update_cmd ) { Elf_Data dst , src ; unsigned flag ; Xword hi , sz ; char * image ; Elf_Scn * s ; Ehdr * eh = elf -> ed_ehdr ; unsigned ver = eh -> e_version ; unsigned encode ; int byte ; _elf_execfill_func_t * execfill_func ; encode = ( update_cmd == ELF_C_WRIMAGE ) ?_elf_sys_encoding ( ) : eh -> e_ident [ EI_DATA ] ; if ( ( elf -> ed_myflags & EDF_READ ) && ( _elf_vm ( elf , ( size_t ) 0 , elf -> ed_fsz ) != OK_YES ) ) { return ( 0 ) ; } flag = elf -> ed_myflags & EDF_WRALLOC ; if ( ( image = _elf_outmap ( elf -> ed_fd , outsz , & flag ) ) == 0 ) { return ( 0 ) ; } if ( flag == 0 ) { elf -> ed_myflags |= EDF_IMALLOC ; } src . d_buf = ( Elf_Void * ) eh ; src . d_type = ELF_T_EHDR ; src . d_size = sizeof ( Ehdr ) ; src . d_version = EV_CURRENT ; dst . d_buf = ( Elf_Void * ) image ; dst . d_size = eh -> e_ehsize ; dst . d_version = ver ; if ( elf_xlatetof ( & dst , & src , encode ) == 0 ) { return ( 0 ) ; } elf -> ed_ehflags &= ~ ELF_F_DIRTY ; hi = eh -> e_ehsize ; if ( eh -> e_phnum != 0 ) { unsigned work ; src . d_buf = ( Elf_Void * ) elf -> ed_phdr ; src . d_type = ELF_T_PHDR ; src . d_size = elf -> ed_phdrsz ; ELFACCESSDATA ( , ) src . d_version = work ; dst . d_buf = ( Elf_Void * ) ( image + eh -> e_phoff ) ; dst . d_size = eh -> e_phnum * eh -> e_phentsize ; hi = ( Xword ) ( eh -> e_phoff + dst . d_size ) ; if ( elf_xlatetof ( & dst , & src , encode ) == 0 ) { elf -> ed_uflags |= ELF_F_DIRTY ; return ( 0 ) ; } elf -> ed_phflags &= ~ ELF_F_DIRTY ; src . d_version = EV_CURRENT ; } ELFACCESSDATA ( byte , _elf_byte ) ; ELFACCESSDATA ( execfill_func , _elf_execfill_func ) ; for ( s = elf -> ed_hdscn ; s != 0 ; s = s -> s_next ) { register Dnode * d , * prevd ; Xword off = 0 ; Shdr * sh = s -> s_shdr ; char * start = image + sh -> sh_offset ; char * here ; _elf_execfill_func_t * execfill ; execfill = ( sh -> sh_flags & SHF_EXECINSTR ) ?execfill_func : NULL ; if ( ( sh -> sh_type == SHT_NOBITS ) || ( sh -> sh_type == SHT_NULL ) ) { d = s -> s_hdnode , prevd = 0 ; for ( ; d != 0 ; prevd = d , d = d -> db_next ) { d -> db_uflags &= ~ ELF_F_DIRTY ; } continue ; } if ( fill && ( sh -> sh_offset > hi ) ) { sz = sh -> sh_offset - hi ; ( void ) memset ( start - sz , byte , sz ) ; } for ( d = s -> s_hdnode , prevd = 0 ; d != 0 ; prevd = d , d = d -> db_next ) { d -> db_uflags &= ~ ELF_F_DIRTY ; here = start + d -> db_data . d_off ; if ( fill && ( d -> db_data . d_off > off ) ) { sz = ( Xword ) ( d -> db_data . d_off - off ) ; if ( execfill != NULL ) { * execfill ( start , here - start - sz , sz ) ; } else { ( void ) memset ( here - sz , byte , sz ) ; } } if ( ( d -> db_myflags & DBF_READY ) == 0 ) { SCNLOCK ( s ) ; if ( _elf_locked_getdata ( s , & prevd -> db_data ) != & d -> db_data ) { elf -> ed_uflags |= ELF_F_DIRTY ; SCNUNLOCK ( s ) ; return ( 0 ) ; } SCNUNLOCK ( s ) ; } dst . d_buf = ( Elf_Void * ) here ; dst . d_size = d -> db_osz ; if ( elf_xlatetof ( & dst , & d -> db_data , encode ) == 0 ) { elf -> ed_uflags |= ELF_F_DIRTY ; return ( 0 ) ; } off = ( Xword ) ( d -> db_data . d_off + dst . d_size ) ; } hi = sh -> sh_offset + sh -> sh_size ; } if ( fill && ( eh -> e_shoff > hi ) ) { sz = eh -> e_shoff - hi ; ( void ) memset ( image + hi , byte , sz ) ; } src . d_type = ELF_T_SHDR ; src . d_size = sizeof ( Shdr ) ; dst . d_buf = ( Elf_Void * ) ( image + eh -> e_shoff ) ; dst . d_size = eh -> e_shentsize ; for ( s = elf -> ed_hdscn ; s != 0 ; s = s -> s_next ) { assert ( ( uintptr_t ) dst . d_buf < ( ( uintptr_t ) image + outsz ) ) ; s -> s_shflags &= ~ ELF_F_DIRTY ; s -> s_uflags &= ~ ELF_F_DIRTY ; src . d_buf = s -> s_shdr ; if ( elf_xlatetof ( & dst , & src , encode ) == 0 ) { elf -> ed_uflags |= ELF_F_DIRTY ; return ( 0 ) ; } dst . d_buf = ( char * ) dst . d_buf + eh -> e_shentsize ; } if ( _elf_outsync ( elf -> ed_fd , image , outsz , ( ( elf -> ed_myflags & EDF_IMALLOC ) ?0 : 1 ) ) != 0 ) { elf -> ed_uflags &= ~ ELF_F_DIRTY ; elf -> ed_myflags &= ~ EDF_IMALLOC ; return ( outsz ) ; } elf -> ed_uflags |= ELF_F_DIRTY ; return ( 0 ) ; } 