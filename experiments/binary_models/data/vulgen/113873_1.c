static mrb_value int_powm ( mrb_state * mrb , mrb_value x ) { mrb_value m ; mrb_int base , exp , mod , result = 1 ; if ( mrb_get_argc ( mrb ) == 1 ) { return mrb_int_pow ( mrb , x ) ; } mrb_get_args ( mrb , "io" , & exp , & m ) ; if ( exp < 0 ) { mrb_raise ( mrb , E_ARGUMENT_ERROR , "int.pow(n,m): n must be positive" ) ; } if ( mrb_bigint_p ( x ) ) { return mrb_bint_powm ( mrb , x , exp , m ) ; } if ( mrb_bigint_p ( m ) ) { return mrb_bint_powm ( mrb , mrb_bint_new_int ( mrb , mrb_integer ( x ) ) , exp , m ) ; } if ( ! mrb_integer_p ( m ) ) { mrb_raise ( mrb , E_TYPE_ERROR , "int.pow(n,m): m must be integer" ) ; } mod = mrb_integer ( m ) ; if ( mod < 0 ) { mrb_raise ( mrb , E_ARGUMENT_ERROR , "int.pow(n,m): m must be positive" ) ; } if ( mod == 1 ) { return mrb_fixnum_value ( 0 ) ; } base = mrb_integer ( x ) ; for ( ; ; ) { if ( exp & 1 ) { if ( mrb_int_mul_overflow ( result , base , & result ) ) { mrb_int_overflow ( mrb , "pow" ) ; } result %= mod ; } exp >>= 1 ; if ( exp == 0 ) { break ; } if ( mrb_int_mul_overflow ( base , base , & base ) ) { mrb_int_overflow ( mrb , "pow" ) ; } base %= mod ; } return mrb_int_value ( mrb , result ) ; } 