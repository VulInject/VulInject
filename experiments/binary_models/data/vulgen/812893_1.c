void smb2_lease_send_break ( smb_request_t * sr ) { smb_ofile_t * old_ofile ; smb_ofile_t * ofile = sr -> fid_ofile ; smb_node_t * node = ofile -> f_node ; smb_lease_t * lease = ofile -> f_lease ; smb_arg_olbrk_t * olbrk = & sr -> arg . olbrk ; boolean_t AckReq = olbrk -> AckRequired ; uint32_t OldLevel = olbrk -> OldLevel ; uint32_t NewLevel = olbrk -> NewLevel ; uint32_t status ; int rc ; NewLevel |= OPLOCK_LEVEL_GRANULAR ; sr -> reply . max_bytes = MLEN ; smb2_lease_break_notification ( sr , OldLevel , NewLevel , lease -> ls_epoch , AckReq ) ; rc = lease_send_any_cn ( sr ) ; if ( rc != 0 ) { lease_close_notconn ( sr , NewLevel ) ; if ( ! AckReq ) { return ; } } else { if ( ! AckReq ) { return ; } status = smb_oplock_wait_ack ( sr , NewLevel ) ; if ( status == 0 ) { return ; } cmn_err ( CE_NOTE , "clnt %s oplock break timeout" , sr -> session -> ip_addr_str ) ; DTRACE_PROBE1 ( ack_timeout , smb_request_t * , sr ) ; NewLevel = OPLOCK_LEVEL_GRANULAR ; } smb_llist_enter ( & node -> n_ofile_list , RW_READER ) ; mutex_enter ( & node -> n_oplock . ol_mutex ) ; old_ofile = ofile ; sr -> fid_ofile = NULL ; status = lease_find_oplock ( sr , lease ) ; if ( status != 0 ) { sr -> fid_ofile = old_ofile ; unlock_out } ofile = sr -> fid_ofile ; ofile -> f_oplock . og_breaking = B_FALSE ; lease -> ls_breaking = B_FALSE ; cv_broadcast ( & lease -> ls_ack_cv ) ; status = smb_oplock_ack_break ( sr , ofile , & NewLevel ) ; ofile -> f_oplock . og_state = NewLevel ; lease -> ls_state = NewLevel ; if ( ofile -> dh_persist ) { smb2_dh_update_oplock ( sr , ofile ) ; } unlock_out mutex_exit ( & node -> n_oplock . ol_mutex ) ; smb_llist_exit ( & node -> n_ofile_list ) ; if ( status != 0 ) { cmn_err ( CE_NOTE , "clnt %s local oplock ack, status=0x%x" , sr -> session -> ip_addr_str , status ) ; } } 