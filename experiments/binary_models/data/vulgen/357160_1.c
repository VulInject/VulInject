PlannedStmt * standard_planner ( Query * parse , const char * query_string , int cursorOptions , ParamListInfo boundParams ) { PlannedStmt * result ; PlannerGlobal * glob ; double tuple_fraction ; PlannerInfo * root ; RelOptInfo * final_rel ; Path * best_path ; Plan * top_plan ; ListCell * lp , * lr ; glob = makeNode ( PlannerGlobal ) ; glob -> boundParams = boundParams ; glob -> subplans = NIL ; glob -> subroots = NIL ; glob -> rewindPlanIDs = NULL ; glob -> finalrtable = NIL ; glob -> finalrowmarks = NIL ; glob -> resultRelations = NIL ; glob -> appendRelations = NIL ; glob -> relationOids = NIL ; glob -> invalItems = NIL ; glob -> paramExecTypes = NIL ; glob -> lastPHId = 0 ; glob -> lastRowMarkId = 0 ; glob -> lastPlanNodeId = 0 ; glob -> transientPlan = false ; glob -> dependsOnRole = false ; if ( ( cursorOptions & CURSOR_OPT_PARALLEL_OK ) != 0 && IsUnderPostmaster && parse -> commandType == CMD_SELECT && ! parse -> hasModifyingCTE && max_parallel_workers_per_gather > 0 && ! IsParallelWorker ( ) ) { glob -> maxParallelHazard = max_parallel_hazard ( parse ) ; glob -> parallelModeOK = ( glob -> maxParallelHazard != PROPARALLEL_UNSAFE ) ; } else { glob -> maxParallelHazard = PROPARALLEL_UNSAFE ; glob -> parallelModeOK = false ; } glob -> parallelModeNeeded = glob -> parallelModeOK && ( debug_parallel_query != DEBUG_PARALLEL_OFF ) ; if ( cursorOptions & CURSOR_OPT_FAST_PLAN ) { tuple_fraction = cursor_tuple_fraction ; if ( tuple_fraction >= 1.0 ) { tuple_fraction = 0.0 ; } if ( tuple_fraction <= 0.0 ) { tuple_fraction = 1e-10 ; } } else { tuple_fraction = 0.0 ; } root = subquery_planner ( glob , parse , NULL , false , tuple_fraction ) ; final_rel = fetch_upper_rel ( root , UPPERREL_FINAL , NULL ) ; best_path = get_cheapest_fractional_path ( final_rel , tuple_fraction ) ; top_plan = create_plan ( root , best_path ) ; if ( cursorOptions & CURSOR_OPT_SCROLL ) { if ( ! ExecSupportsBackwardScan ( top_plan ) ) { top_plan = materialize_finished_plan ( top_plan ) ; } } if ( debug_parallel_query != DEBUG_PARALLEL_OFF && top_plan -> parallel_safe ) { Gather * gather = makeNode ( Gather ) ; gather -> plan . initPlan = top_plan -> initPlan ; top_plan -> initPlan = NIL ; gather -> plan . targetlist = top_plan -> targetlist ; gather -> plan . qual = NIL ; gather -> plan . lefttree = top_plan ; gather -> plan . righttree = NULL ; gather -> num_workers = 1 ; gather -> single_copy = true ; gather -> invisible = ( debug_parallel_query == DEBUG_PARALLEL_REGRESS ) ; gather -> rescan_param = - 1 ; gather -> plan . startup_cost = top_plan -> startup_cost + parallel_setup_cost ; gather -> plan . total_cost = top_plan -> total_cost + parallel_setup_cost + parallel_tuple_cost * top_plan -> plan_rows ; gather -> plan . plan_rows = top_plan -> plan_rows ; gather -> plan . plan_width = top_plan -> plan_width ; gather -> plan . parallel_aware = false ; gather -> plan . parallel_safe = false ; root -> glob -> parallelModeNeeded = true ; top_plan = & gather -> plan ; } if ( glob -> paramExecTypes != NIL ) { Assert ( list_length ( glob -> subplans ) == list_length ( glob -> subroots ) ) ; forboth ( , , , ) { Plan * subplan = ( Plan * ) lfirst ( lp ) ; PlannerInfo * subroot = lfirst_node ( PlannerInfo , lr ) ; SS_finalize_plan ( subroot , subplan ) ; } SS_finalize_plan ( root , top_plan ) ; } Assert ( glob -> finalrtable == NIL ) ; Assert ( glob -> finalrteperminfos == NIL ) ; Assert ( glob -> finalrowmarks == NIL ) ; Assert ( glob -> resultRelations == NIL ) ; Assert ( glob -> appendRelations == NIL ) ; top_plan = set_plan_references ( root , top_plan ) ; Assert ( list_length ( glob -> subplans ) == list_length ( glob -> subroots ) ) ; forboth ( , , , ) { Plan * subplan = ( Plan * ) lfirst ( lp ) ; PlannerInfo * subroot = lfirst_node ( PlannerInfo , lr ) ; lfirst ( lp ) = set_plan_references ( subroot , subplan ) ; } result = makeNode ( PlannedStmt ) ; result -> commandType = parse -> commandType ; result -> queryId = parse -> queryId ; result -> hasReturning = ( parse -> returningList != NIL ) ; result -> hasModifyingCTE = parse -> hasModifyingCTE ; result -> canSetTag = parse -> canSetTag ; result -> transientPlan = glob -> transientPlan ; result -> dependsOnRole = glob -> dependsOnRole ; result -> parallelModeNeeded = glob -> parallelModeNeeded ; result -> planTree = top_plan ; result -> partPruneInfos = glob -> partPruneInfos ; result -> rtable = glob -> finalrtable ; result -> permInfos = glob -> finalrteperminfos ; result -> resultRelations = glob -> resultRelations ; result -> appendRelations = glob -> appendRelations ; result -> subplans = glob -> subplans ; result -> rewindPlanIDs = glob -> rewindPlanIDs ; result -> rowMarks = glob -> finalrowmarks ; result -> relationOids = glob -> relationOids ; result -> invalItems = glob -> invalItems ; result -> paramExecTypes = glob -> paramExecTypes ; result -> utilityStmt = parse -> utilityStmt ; result -> stmt_location = parse -> stmt_location ; result -> stmt_len = parse -> stmt_len ; result -> jitFlags = PGJIT_NONE ; if ( jit_enabled && jit_above_cost >= 0 && top_plan -> total_cost > jit_above_cost ) { result -> jitFlags |= PGJIT_PERFORM ; if ( jit_optimize_above_cost >= 0 && top_plan -> total_cost > jit_optimize_above_cost ) { result -> jitFlags |= PGJIT_OPT3 ; } if ( jit_inline_above_cost >= 0 && top_plan -> total_cost > jit_inline_above_cost ) { result -> jitFlags |= PGJIT_INLINE ; } if ( jit_expressions ) { result -> jitFlags |= PGJIT_EXPR ; } if ( jit_tuple_deforming ) { result -> jitFlags |= PGJIT_DEFORM ; } } if ( glob -> partition_directory != NULL ) { DestroyPartitionDirectory ( glob -> partition_directory ) ; } return result ; } 