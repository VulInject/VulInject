static int meson_pwm_probe ( struct udevice * dev ) { struct meson_pwm * priv = dev_get_priv ( dev ) ; struct meson_pwm_data * data ; unsigned int i , p ; char name [ 255 ] ; int err ; u32 reg ; data = ( meson_pwm_data * ) dev_get_driver_data ( dev ) ; if ( ! data ) { return - EINVAL ; } for ( i = 0 ; i < MESON_NUM_PWMS ; i ++ ) { struct meson_pwm_channel * channel = & priv -> channels [ i ] ; struct meson_pwm_channel_data * channel_data = & meson_pwm_per_channel_data [ i ] ; snprintf ( name , sizeof ( name ) , "clkin%u" , i ) ; err = clk_get_by_name ( dev , name , & channel -> clk ) ; if ( err == - ENODATA ) { struct udevice * cdev ; struct uclass * uc ; p = ( readl ( priv -> base + REG_MISC_AB ) >> channel_data -> clk_sel_shift ) & MISC_CLK_SEL_MASK ; if ( p >= data -> num_parents ) { printf ( "%s%d: hw parent is invalid\n" , __func__ , i ) ; return - EINVAL ; } if ( data -> parent_ids [ p ] == - 1 ) { const char * str ; err = uclass_get ( UCLASS_CLK , & uc ) ; if ( err ) { return err ; } uclass_foreach_dev ( , ) { if ( strcmp ( cdev -> driver -> name , "fixed_rate_clock" ) ) { continue ; } str = ofnode_read_string ( dev_ofnode ( cdev ) , "clock-output-names" ) ; if ( ! str ) { continue ; } if ( ! strcmp ( str , "xtal" ) ) { err = uclass_get_device_by_ofnode ( UCLASS_CLK , dev_ofnode ( cdev ) , & cdev ) ; if ( err ) { printf ( "%s%d: Failed to get xtal clk\n" , __func__ , i ) ; return err ; } break ; } } if ( ! cdev ) { printf ( "%s%d: Failed to find xtal clk device\n" , __func__ , i ) ; return - EINVAL ; } channel -> clk . dev = cdev ; channel -> clk . id = 0 ; channel -> clk . data = 0 ; } else { err = uclass_get ( UCLASS_CLK , & uc ) ; if ( err ) { return err ; } uclass_foreach_dev ( , ) { if ( strstr ( cdev -> driver -> name , "meson_clk" ) ) { break ; } } if ( ! cdev ) { printf ( "%s%d: Failed to find clk device\n" , __func__ , i ) ; return - EINVAL ; } err = uclass_get_device_by_ofnode ( UCLASS_CLK , dev_ofnode ( cdev ) , & cdev ) ; if ( err ) { printf ( "%s%d: Failed to get clk controller\n" , __func__ , i ) ; return err ; } channel -> clk . dev = cdev ; channel -> clk . id = data -> parent_ids [ p ] ; channel -> clk . data = 0 ; } continue ; } else { return err ; } for ( p = 0 ; p < data -> num_parents ; ++ p ) { if ( ! strcmp ( channel -> clk . dev -> driver -> name , "fixed_rate_clock" ) ) { if ( data -> parent_ids [ p ] == - 1 ) { break ; } } else { if ( data -> parent_ids [ p ] == channel -> clk . id ) { break ; } } } reg = readl ( priv -> base + REG_MISC_AB ) ; debug ( "%s%d: switching parent %d to %d\n" , __func__ , i , ( reg >> channel_data -> clk_sel_shift ) & MISC_CLK_SEL_MASK , p ) ; reg &= MISC_CLK_SEL_MASK << channel_data -> clk_sel_shift ; reg |= ( p & MISC_CLK_SEL_MASK ) << channel_data -> clk_sel_shift ; writel ( reg , priv -> base + REG_MISC_AB ) ; } return 0 ; } static const struct pwm_ops meson_pwm_ops = { . set_config = meson_pwm_set_config . set_enable = meson_pwm_set_enable . set_invert = meson_pwm_set_invert } ; 