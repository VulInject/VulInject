int ufs_xattrmkdir ( struct inode * tdp , struct inode * * ipp , int flags , struct cred * cr ) { struct inode * ip ; struct vattr va ; int err ; int retry = 1 ; struct ufsvfs * ufsvfsp ; struct ulockfs * ulp ; int issync ; int trans_size ; int dorwlock ; if ( ( err = ufs_iaccess ( tdp , IWRITE , cr , 1 ) ) != 0 ) { return ( err ) ; } again dorwlock = 0 ; va . va_type = VDIR ; va . va_uid = tdp -> i_uid ; va . va_gid = tdp -> i_gid ; if ( ( tdp -> i_mode & IFMT ) == IFDIR ) { va . va_mode = ( o_mode_t ) IFATTRDIR ; va . va_mode |= tdp -> i_mode & 0777 ; } else { va . va_mode = ( o_mode_t ) IFATTRDIR | 0700 ; if ( tdp -> i_mode & 0040 ) { va . va_mode |= 0750 ; } if ( tdp -> i_mode & 0004 ) { va . va_mode |= 0705 ; } } va . va_mask = AT_TYPE | AT_MODE ; ufsvfsp = tdp -> i_ufsvfs ; err = ufs_lockfs_begin ( ufsvfsp , & ulp , ULOCKFS_MKDIR_MASK ) ; if ( err ) { return ( err ) ; } if ( ITOV ( tdp ) -> v_type != VDIR ) { rw_enter ( & tdp -> i_rwlock , RW_WRITER ) ; dorwlock = 1 ; } if ( ulp ) { trans_size = ( int ) TOP_MKDIR_SIZE ( tdp ) ; TRANS_BEGIN_CSYNC ( ufsvfsp , issync , TOP_MKDIR , trans_size ) ; } if ( dorwlock == 0 ) { rw_enter ( & tdp -> i_rwlock , RW_WRITER ) ; dorwlock = 2 ; } rw_enter ( & ufsvfsp -> vfs_dqrwlock , RW_READER ) ; rw_enter ( & tdp -> i_contents , RW_WRITER ) ; if ( retry ) { tdp -> i_flag |= IQUIET ; } err = ufs_dirmakeinode ( tdp , & ip , & va , DE_ATTRDIR , cr ) ; tdp -> i_flag &= ~ IQUIET ; if ( err ) { fail } if ( flags ) { tdp -> i_oeftflag = ip -> i_number ; } ip -> i_cflags |= IXATTR ; ITOV ( ip ) -> v_flag |= V_XATTRDIR ; TRANS_INODE ( ufsvfsp , tdp ) ; tdp -> i_flag |= ICHG | IUPD ; tdp -> i_seq ++ ; ufs_iupdat ( tdp , I_SYNC ) ; rw_exit ( & tdp -> i_contents ) ; rw_exit ( & ufsvfsp -> vfs_dqrwlock ) ; rw_enter ( & ip -> i_rwlock , RW_WRITER ) ; rw_enter ( & ip -> i_contents , RW_WRITER ) ; TRANS_INODE ( ufsvfsp , ip ) ; ip -> i_flag |= ICHG | IUPD ; ip -> i_seq ++ ; ufs_iupdat ( ip , I_SYNC ) ; rw_exit ( & ip -> i_contents ) ; rw_exit ( & ip -> i_rwlock ) ; if ( dorwlock == 2 ) { rw_exit ( & tdp -> i_rwlock ) ; } if ( ulp ) { int terr = 0 ; TRANS_END_CSYNC ( ufsvfsp , err , issync , TOP_MKDIR , trans_size ) ; ufs_lockfs_end ( ulp ) ; if ( err == 0 ) { err = terr ; } } if ( dorwlock == 1 ) { rw_exit ( & tdp -> i_rwlock ) ; } * ipp = ip ; return ( err ) ; fail rw_exit ( & tdp -> i_contents ) ; rw_exit ( & ufsvfsp -> vfs_dqrwlock ) ; if ( dorwlock == 2 ) { rw_exit ( & tdp -> i_rwlock ) ; } if ( ulp ) { TRANS_END_CSYNC ( ufsvfsp , err , issync , TOP_MKDIR , trans_size ) ; ufs_lockfs_end ( ulp ) ; } if ( dorwlock == 1 ) { rw_exit ( & tdp -> i_rwlock ) ; } if ( ip != NULL ) { VN_RELE ( ITOV ( ip ) ) ; } if ( ( err == ENOSPC ) && retry && TRANS_ISTRANS ( ufsvfsp ) ) { ufs_delete_drain_wait ( ufsvfsp , 1 ) ; retry = 0 ; again } return ( err ) ; } 