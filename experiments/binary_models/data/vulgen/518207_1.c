static enum xp_retval xpc_setup_ch_structures ( struct xpc_partition * part ) { enum xp_retval ret ; int ch_number ; struct xpc_channel * ch ; short partid = XPC_PARTID ( part ) ; DBUG_ON ( part -> channels != NULL ) ; part -> channels = kzalloc ( sizeof ( xpc_channel ) * XPC_MAX_NCHANNELS , GFP_KERNEL ) ; if ( part -> channels == NULL ) { dev_err ( xpc_chan , "can't get memory for channels\n" ) ; return xpNoMemory ; } part -> remote_openclose_args = xpc_kzalloc_cacheline_aligned ( XPC_OPENCLOSE_ARGS_SIZE , GFP_KERNEL , & part -> remote_openclose_args_base ) ; if ( part -> remote_openclose_args == NULL ) { dev_err ( xpc_chan , "can't get memory for remote connect args\n" ) ; ret = xpNoMemory ; out_1 } part -> chctl . all_flags = 0 ; spin_lock_init ( & part -> chctl_lock ) ; atomic_set ( & part -> channel_mgr_requests , 1 ) ; init_waitqueue_head ( & part -> channel_mgr_wq ) ; part -> nchannels = XPC_MAX_NCHANNELS ; atomic_set ( & part -> nchannels_active , 0 ) ; for ( ch_number = 0 ; ch_number < part -> nchannels ; ch_number ++ ) { ch = & part -> channels [ ch_number ] ; ch -> partid = partid ; ch -> number = ch_number ; ch -> flags = XPC_C_DISCONNECTED ; atomic_set ( & ch -> kthreads_assigned , 0 ) ; atomic_set ( & ch -> kthreads_idle , 0 ) ; atomic_set ( & ch -> kthreads_active , 0 ) ; atomic_set ( & ch -> references , 0 ) ; atomic_set ( & ch -> n_to_notify , 0 ) ; spin_lock_init ( & ch -> lock ) ; init_completion ( & ch -> wdisconnect_wait ) ; atomic_set ( & ch -> n_on_msg_allocate_wq , 0 ) ; init_waitqueue_head ( & ch -> msg_allocate_wq ) ; init_waitqueue_head ( & ch -> idle_wq ) ; } ret = xpc_arch_ops . setup_ch_structures ( part ) ; if ( ret != xpSuccess ) { out_2 } part -> setup_state = XPC_P_SS_SETUP ; return xpSuccess ; out_2 kfree ( part -> remote_openclose_args_base ) ; part -> remote_openclose_args = NULL ; out_1 kfree ( part -> channels ) ; part -> channels = NULL ; return ret ; } 