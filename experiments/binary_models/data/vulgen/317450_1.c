decoder . builder . metrics_only = 1 ; decoder . builder . load_points = 0 ; for ( glyph_index = 0 ; glyph_index < face -> root . num_glyphs ; glyph_index ++ ) { error = cid_load_glyph ( & decoder , glyph_index ) ; } * max_advance = FIXED_TO_INT ( decoder . builder . advance . x ) ; psaux -> t1_decoder_funcs -> done ( & decoder ) ; return FT_Err_Ok ; ( FT_Error ) cid_slot_load_glyph ( , , , ) { CID_GlyphSlot glyph = ( CID_GlyphSlot ) cidglyph FT_Error error T1_DecoderRec decoder CID_Face face = ( CID_Face ) cidglyph -> face FT_Bool hinting FT_Bool scaled PSAux_Service psaux = ( PSAux_Service ) face -> psaux FT_Matrix font_matrix FT_Vector font_offset FT_Bool must_finish_decoder = FALSE if ( glyph_index >= ( FT_UInt ) face -> root . num_glyphs ) { error = FT_THROW ( Invalid_Argument ) ; Exit ; } } ; if ( load_flags & FT_LOAD_NO_RECURSE ) { load_flags |= FT_LOAD_NO_SCALE | FT_LOAD_NO_HINTING ; } glyph -> x_scale = cidsize -> metrics . x_scale ; glyph -> y_scale = cidsize -> metrics . y_scale ; cidglyph -> outline . n_points = 0 ; cidglyph -> outline . n_contours = 0 ; hinting = FT_BOOL ( ( load_flags & FT_LOAD_NO_SCALE ) == 0 && ( load_flags & FT_LOAD_NO_HINTING ) == 0 ) ; scaled = FT_BOOL ( ( load_flags & FT_LOAD_NO_SCALE ) == 0 ) ; glyph -> hint = hinting ; glyph -> scaled = scaled ; cidglyph -> format = FT_GLYPH_FORMAT_OUTLINE ; error = psaux -> t1_decoder_funcs -> init ( & decoder , cidglyph -> face , cidsize , cidglyph , 0 , 0 , hinting , FT_LOAD_TARGET_MODE ( load_flags ) , cid_load_glyph ) ; if ( error ) { Exit } must_finish_decoder = TRUE ; decoder . builder . no_recurse = FT_BOOL ( load_flags & FT_LOAD_NO_RECURSE ) ; error = cid_load_glyph ( & decoder , glyph_index ) ; if ( error ) { Exit } hinting = glyph -> hint ; scaled = glyph -> scaled ; font_matrix = decoder . font_matrix ; font_offset = decoder . font_offset ; psaux -> t1_decoder_funcs -> done ( & decoder ) ; must_finish_decoder = FALSE ; cidglyph -> outline . flags &= FT_OUTLINE_OWNER ; cidglyph -> outline . flags |= FT_OUTLINE_REVERSE_FILL ; if ( load_flags & FT_LOAD_NO_RECURSE ) { FT_Slot_Internal internal = cidglyph -> internal ; cidglyph -> metrics . horiBearingX = FIXED_TO_INT ( decoder . builder . left_bearing . x ) ; cidglyph -> metrics . horiAdvance = FIXED_TO_INT ( decoder . builder . advance . x ) ; internal -> glyph_matrix = font_matrix ; internal -> glyph_delta = font_offset ; internal -> glyph_transformed = 1 ; } else { FT_BBox cbox ; FT_Glyph_Metrics * metrics = & cidglyph -> metrics ; metrics -> horiAdvance = FIXED_TO_INT ( decoder . builder . advance . x ) ; cidglyph -> linearHoriAdvance = FIXED_TO_INT ( decoder . builder . advance . x ) ; cidglyph -> internal -> glyph_transformed = 0 ; metrics -> vertAdvance = ( face -> cid . font_bbox . yMax - face -> cid . font_bbox . yMin ) >> 16 ; cidglyph -> linearVertAdvance = metrics -> vertAdvance ; cidglyph -> format = FT_GLYPH_FORMAT_OUTLINE ; if ( cidsize -> metrics . y_ppem < 24 ) { cidglyph -> outline . flags |= FT_OUTLINE_HIGH_PRECISION ; } if ( font_matrix . xx != 0x10000L || font_matrix . yy != 0x10000L || font_matrix . xy != 0 || font_matrix . yx != 0 ) { FT_Outline_Transform ( & cidglyph -> outline , & font_matrix ) ; metrics -> horiAdvance = FT_MulFix ( metrics -> horiAdvance , font_matrix . xx ) ; metrics -> vertAdvance = FT_MulFix ( metrics -> vertAdvance , font_matrix . yy ) ; } if ( ( load_flags & FT_LOAD_NO_SCALE ) == 0 || scaled ) { } } 