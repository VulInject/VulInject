int bpfwrite ( dev_t dev , struct uio * uio , int ioflag ) { struct bpf_d * d ; struct ifnet * ifp ; struct mbuf * m ; int error ; struct sockaddr_storage dst ; KERNEL_ASSERT_LOCKED ( ) ; d = bpfilter_lookup ( minor ( dev ) ) ; if ( d -> bd_bif == NULL ) { return ( ENXIO ) ; } bpf_get ( d ) ; ifp = d -> bd_bif -> bif_ifp ; if ( ifp == NULL || ( ifp -> if_flags & IFF_UP ) == 0 ) { error = ENETDOWN ; out } if ( uio -> uio_resid == 0 ) { error = 0 ; out } if ( error ) { out } if ( m -> m_pkthdr . len > ifp -> if_mtu ) { m_freem ( m ) ; error = EMSGSIZE ; out } m -> m_pkthdr . ph_rtableid = ifp -> if_rdomain ; m -> m_pkthdr . pf . prio = ifp -> if_llprio ; if ( d -> bd_hdrcmplt && dst . ss_family == AF_UNSPEC ) { dst . ss_family = pseudo_AF_HDRCMPLT ; } NET_LOCK ( ) ; error = ifp -> if_output ( ifp , m , sstosa ( & dst ) , NULL ) ; NET_UNLOCK ( ) ; out bpf_put ( d ) ; return ( error ) ; } 