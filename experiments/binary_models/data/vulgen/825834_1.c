static void reparsed_doorfunc ( void * cookie , char * argp , size_t arg_size , door_desc_t * dp , uint_t n_desc ) { int err ; size_t bufsz ; char * svc_type , * svc_data ; char * cp , * buf , * sbuf , res_buf [ DOOR_RESULT_BUFSZ ] ; reparsed_door_res_t * resp ; if ( ( argp == NULL ) || ( arg_size == 0 ) ) { reparsed_door_call_error ( EINVAL , 0 ) ; } if ( verbose ) { syslog ( LOG_NOTICE , "reparsed_door: [%s, %d]" , argp , arg_size ) ; } if ( ( svc_type = strdup ( argp ) ) == NULL ) { reparsed_door_call_error ( ENOMEM , 0 ) ; } if ( ( cp = strchr ( svc_type , ':' ) ) == NULL ) { reparsed_door_call_error ( EINVAL , 0 ) ; } * cp ++ = '\0' ; svc_data = cp ; resp = ( reparsed_door_res_t * ) res_buf ; buf = resp -> res_data ; bufsz = sizeof ( res_buf ) - sizeof ( reparsed_door_res_t ) ; err = reparse_deref ( svc_type , svc_data , buf , & bufsz ) ; if ( verbose ) { syslog ( LOG_NOTICE , "reparsed_deref(svc_type: %s, data: %s, size: %d) ->%d" , svc_type , svc_data , bufsz , err ) ; } switch ( err ) { case 0 : break ; case EOVERFLOW : sbuf = alloca ( bufsz + sizeof ( reparsed_door_res_t ) ) ; if ( sbuf == NULL || stack_inbounds ( buf ) == 0 || stack_inbounds ( buf + sizeof ( reparsed_door_res_t ) + SAFETY_BUFFER - 1 ) == 0 ) { free ( svc_type ) ; reparsed_door_call_error ( ENOMEM , 0 ) ; } resp = ( reparsed_door_res_t * ) sbuf ; if ( ( err = reparse_deref ( svc_type , svc_data , resp -> res_data , & bufsz ) ) == 0 ) { break ; } default : free ( svc_type ) ; reparsed_door_call_error ( err , 0 ) ; } free ( svc_type ) ; if ( verbose ) { syslog ( LOG_NOTICE , "reparsed_door_return<buf=%s>size=%d" , buf , bufsz ) ; } resp -> res_status = 0 ; resp -> res_len = bufsz ; ( void ) door_return ( ( char * ) resp , bufsz + sizeof ( reparsed_door_res_t ) , NULL , 0 ) ; ( void ) door_return ( NULL , 0 , NULL , 0 ) ; } 