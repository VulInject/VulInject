void * alist_insert ( Alist * * lpp , const void * datap , size_t size , Aliste init_arritems , Aliste idx ) { Alist * lp = * lpp ; char * addr ; ASSERT ( init_arritems != 0 ) ; ASSERT ( size != 0 ) ; if ( lp == NULL ) { Aliste bsize ; bsize = size * init_arritems ; bsize = S_ROUND ( bsize , sizeof ( void * ) ) ; bsize = ALIST_OFF_DATA + bsize ; if ( ( lp = malloc ( ( size_t ) bsize ) ) == NULL ) { return ( NULL ) ; } lp -> al_arritems = init_arritems ; lp -> al_nitems = 0 ; lp -> al_next = ALIST_OFF_DATA ; lp -> al_size = size ; * lpp = lp ; } else { ASSERT ( size == lp -> al_size ) ; if ( lp -> al_nitems >= lp -> al_arritems ) { Aliste bsize ; bsize = lp -> al_size * lp -> al_arritems * 2 ; bsize = S_ROUND ( bsize , sizeof ( void * ) ) ; bsize = ALIST_OFF_DATA + bsize ; if ( ( lp = realloc ( lp , ( size_t ) bsize ) ) == NULL ) { return ( NULL ) ; } * lpp = lp ; } } ASSERT ( idx <= lp -> al_nitems ) ; addr = ( idx * lp -> al_size ) + ( char * ) lp -> al_data ; if ( idx < lp -> al_nitems ) { ( void ) memmove ( addr + lp -> al_size , addr , ( lp -> al_nitems - idx ) * lp -> al_size ) ; } lp -> al_nitems ++ ; lp -> al_next += lp -> al_size ; if ( datap != NULL ) { ( void ) memcpy ( addr , datap , lp -> al_size ) ; } else { ( void ) memset ( addr , 0 , lp -> al_size ) ; } return ( addr ) ; } 