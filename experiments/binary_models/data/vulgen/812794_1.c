if ( istad & 0x80 ) { rstad = cs -> readisac ( cs , IPACX_RSTAD ) ; if ( ( rstad & 0xf0 ) != 0xa0 ) { if ( ! ( rstad & 0x80 ) ) { if ( cs -> debug & L1_DEB_WARN ) { debugl1 ( cs , "dch_int(): invalid frame" ) ; } } if ( ( rstad & 0x40 ) ) { if ( cs -> debug & L1_DEB_WARN ) { debugl1 ( cs , "dch_int(): RDO" ) ; } } if ( ! ( rstad & 0x20 ) ) { if ( cs -> debug & L1_DEB_WARN ) { debugl1 ( cs , "dch_int(): CRC error" ) ; } } cs -> writeisac ( cs , IPACX_CMDRD , 0x80 ) ; } else { count = cs -> readisac ( cs , IPACX_RBCLD ) ; if ( count ) { count -- ; } count &= D_FIFO_SIZE - 1 ; if ( count == 0 ) { count = D_FIFO_SIZE ; } dch_empty_fifo ( cs , count ) ; if ( ( count = cs -> rcvidx ) > 0 ) { cs -> rcvidx = 0 ; if ( ! ( skb = dev_alloc_skb ( count ) ) ) { printk ( KERN_WARNING "HiSax dch_int(): receive out of memory\n" ) ; } else { memcpy ( skb_put ( skb , count ) , cs -> rcvbuf , count ) ; skb_queue_tail ( & cs -> rq , skb ) ; } } } cs -> rcvidx = 0 ; schedule_event ( cs , D_RCVBUFREADY ) ; } if ( istad & 0x40 ) { dch_empty_fifo ( cs , D_FIFO_SIZE ) ; } if ( istad & 0x20 ) { if ( cs -> debug & L1_DEB_WARN ) { debugl1 ( cs , "dch_int(): RFO" ) ; } cs -> writeisac ( cs , IPACX_CMDRD , 0x40 ) ; } if ( istad & 0x10 ) { if ( test_and_clear_bit ( FLG_DBUSY_TIMER , & cs -> HW_Flags ) ) { del_timer ( & cs -> dbusytimer ) ; } if ( test_and_clear_bit ( FLG_L1_DBUSY , & cs -> HW_Flags ) ) { schedule_event ( cs , D_CLEARBUSY ) ; } if ( cs -> tx_skb ) { if ( cs -> tx_skb -> len ) { dch_fill_fifo ( cs ) ; afterXPR } else { dev_kfree_skb_irq ( cs -> tx_skb ) ; cs -> tx_skb = NULL ; cs -> tx_cnt = 0 ; } } if ( ( cs -> tx_skb = skb_dequeue ( & cs -> sq ) ) ) { cs -> tx_cnt = 0 ; dch_fill_fifo ( cs ) ; } else { schedule_event ( cs , D_XMTBUFREADY ) ; } } afterXPR if ( istad & 0x0C ) { if ( cs -> tx_skb ) { skb_push ( cs -> tx_skb , cs -> tx_cnt ) ; cs -> tx_cnt = 0 ; dch_fill_fifo ( cs ) ; } else { printk ( KERN_WARNING "HiSax: ISAC XDU no skb\n" ) ; debugl1 ( cs , "ISAC XDU no skb" ) ; } } 