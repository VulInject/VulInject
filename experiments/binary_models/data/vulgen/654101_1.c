static int npppd_pool_regist_radish ( npppd_pool * _this , struct in_addr_range * range , struct sockaddr_npppd * snp , int is_dynamic ) { int rval ; struct sockaddr_in sin4a , sin4b ; struct sockaddr_npppd * snp0 ; npppd_pool * npool0 ; memset ( & sin4a , 0 , sizeof ( sin4a ) ) ; memset ( & sin4b , 0 , sizeof ( sin4b ) ) ; sin4a . sin_len = sin4b . sin_len = sizeof ( sin4a ) ; sin4a . sin_family = sin4b . sin_family = AF_INET ; sin4a . sin_addr . s_addr = htonl ( range -> addr ) ; sin4b . sin_addr . s_addr = htonl ( range -> mask ) ; snp -> snp_len = sizeof ( sockaddr_npppd ) ; snp -> snp_family = AF_INET ; snp -> snp_addr . s_addr = htonl ( range -> addr ) ; snp -> snp_mask . s_addr = htonl ( range -> mask ) ; snp -> snp_data_ptr = _this ; if ( is_dynamic ) { snp -> snp_type = SNP_DYN_POOL ; } else { snp -> snp_type = SNP_POOL ; } if ( ( snp0 = rd_lookup ( SA ( & sin4a ) , SA ( & sin4b ) , _this -> npppd -> rd ) ) != NULL ) { NPPPD_POOL_ASSERT ( snp0 -> snp_type != SNP_PPP ) ; npool0 = snp0 -> snp_data_ptr ; npppd_pool_log ( _this , LOG_WARNING , "%d.%d.%d.%d/%d is already defined as '%s'(%s)" , A ( range -> addr ) , netmask2prefixlen ( range -> mask ) , npool0 -> ipcp_name , ( snp0 -> snp_type == SNP_POOL ) ?"static" : "dynamic" ) ; fail } if ( ( rval = rd_insert ( SA ( & sin4a ) , SA ( & sin4b ) , _this -> npppd -> rd , snp ) ) != 0 ) { errno = rval ; npppd_pool_log ( _this , LOG_WARNING , "rd_insert(%d.%d.%d.%d/%d) failed: %m" , A ( range -> addr ) , netmask2prefixlen ( range -> mask ) ) ; fail } return 0 ; fail return 1 ; } 