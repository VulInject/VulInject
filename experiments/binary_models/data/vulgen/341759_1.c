static int config_output ( AVFilterLink * outlink ) { AVFilterContext * ctx = outlink -> src ; AVFilterLink * inlink0 = ctx -> inputs [ 0 ] ; AVFilterLink * inlink1 = ctx -> inputs [ 1 ] ; XFadeContext * s = ctx -> priv ; if ( inlink0 -> w != inlink1 -> w || inlink0 -> h != inlink1 -> h ) { av_log ( ctx , AV_LOG_ERROR , "First input link %s parameters " "(size %dx%d) do not match the corresponding " "second input link %s parameters (size %dx%d)\n" , ctx -> input_pads [ 0 ] . name , inlink0 -> w , inlink0 -> h , ctx -> input_pads [ 1 ] . name , inlink1 -> w , inlink1 -> h ) ; return AVERROR ( EINVAL ) ; } if ( inlink0 -> time_base . num != inlink1 -> time_base . num || inlink0 -> time_base . den != inlink1 -> time_base . den ) { av_log ( ctx , AV_LOG_ERROR , "First input link %s timebase " "(%d/%d) do not match the corresponding " "second input link %s timebase (%d/%d)\n" , ctx -> input_pads [ 0 ] . name , inlink0 -> time_base . num , inlink0 -> time_base . den , ctx -> input_pads [ 1 ] . name , inlink1 -> time_base . num , inlink1 -> time_base . den ) ; return AVERROR ( EINVAL ) ; } if ( ! inlink0 -> frame_rate . num || ! inlink0 -> frame_rate . den ) { av_log ( ctx , AV_LOG_ERROR , "The inputs needs to be a constant frame rate; " "current rate of %d/%d is invalid\n" , inlink0 -> frame_rate . num , inlink0 -> frame_rate . den ) ; return AVERROR ( EINVAL ) ; } if ( inlink0 -> frame_rate . num != inlink1 -> frame_rate . num || inlink0 -> frame_rate . den != inlink1 -> frame_rate . den ) { av_log ( ctx , AV_LOG_ERROR , "First input link %s frame rate " "(%d/%d) do not match the corresponding " "second input link %s frame rate (%d/%d)\n" , ctx -> input_pads [ 0 ] . name , inlink0 -> frame_rate . num , inlink0 -> frame_rate . den , ctx -> input_pads [ 1 ] . name , inlink1 -> frame_rate . num , inlink1 -> frame_rate . den ) ; return AVERROR ( EINVAL ) ; } outlink -> w = inlink0 -> w ; outlink -> h = inlink0 -> h ; outlink -> time_base = inlink0 -> time_base ; outlink -> sample_aspect_ratio = inlink0 -> sample_aspect_ratio ; outlink -> frame_rate = inlink0 -> frame_rate ; s -> depth = pix_desc -> comp [ 0 ] . depth ; s -> is_rgb = ! ! ( pix_desc -> flags & AV_PIX_FMT_FLAG_RGB ) ; s -> nb_planes = av_pix_fmt_count_planes ( inlink0 -> format ) ; s -> max_value = ( 1 << s -> depth ) - 1 ; s -> black [ 0 ] = 0 ; s -> black [ 1 ] = s -> black [ 2 ] = s -> is_rgb ?0 : s -> max_value / 2 ; s -> black [ 3 ] = s -> max_value ; s -> white [ 0 ] = s -> white [ 3 ] = s -> max_value ; s -> white [ 1 ] = s -> white [ 2 ] = s -> is_rgb ?s -> max_value : s -> max_value / 2 ; s -> first_pts = s -> last_pts = s -> pts = AV_NOPTS_VALUE ; if ( s -> duration ) { s -> duration_pts = av_rescale_q ( s -> duration , AV_TIME_BASE_Q , outlink -> time_base ) ; } if ( s -> offset ) { s -> offset_pts = av_rescale_q ( s -> offset , AV_TIME_BASE_Q , outlink -> time_base ) ; } switch ( s -> transition ) { case CUSTOM : s -> transitionf = s -> depth <= 8 ?custom8_transition : custom16_transition ; break ; case FADE : s -> transitionf = s -> depth <= 8 ?fade8_transition : fade16_transition ; break ; case WIPELEFT : s -> transitionf = s -> depth <= 8 ?wipeleft8_transition : wipeleft16_transition ; break ; case WIPERIGHT : s -> transitionf = s -> depth <= 8 ?wiperight8_transition : wiperight16_transition ; break ; case WIPEUP : s -> transitionf = s -> depth <= 8 ?wipeup8_transition : wipeup16_transition ; break ; case WIPEDOWN : s -> transitionf = s -> depth <= 8 ?wipedown8_transition : wipedown16_transition ; break ; case SLIDELEFT : s -> transitionf = s -> depth <= 8 ?slideleft8_transition : slideleft16_transition ; break ; case SLIDERIGHT : s -> transitionf = s -> depth <= 8 ?slideright8_transition : slideright16_transition ; break ; case SLIDEUP : s -> transitionf = s -> depth <= 8 ?slideup8_transition : slideup16_transition ; break ; case SLIDEDOWN : s -> transitionf = s -> depth <= 8 ?slidedown8_transition : slidedown16_transition ; break ; case CIRCLECROP : s -> transitionf = s -> depth <= 8 ?circlecrop8_transition : circlecrop16_transition ; break ; case RECTCROP : s -> transitionf = s -> depth <= 8 ?rectcrop8_transition : rectcrop16_transition ; break ; case DISTANCE : s -> transitionf = s -> depth <= 8 ?distance8_transition : distance16_transition ; break ; case FADEBLACK : s -> transitionf = s -> depth <= 8 ?fadeblack8_transition : fadeblack16_transition ; break ; case FADEWHITE : s -> transitionf = s -> depth <= 8 ?fadewhite8_transition : fadewhite16_transition ; break ; case RADIAL : s -> transitionf = s -> depth <= 8 ?radial8_transition : radial16_transition ; break ; case SMOOTHLEFT : s -> transitionf = s -> depth <= 8 ?smoothleft8_transition : smoothleft16_transition ; break ; case SMOOTHRIGHT : s -> transitionf = s -> depth <= 8 ?smoothright8_transition : smoothright16_transition ; break ; case SMOOTHUP : s -> transitionf = s -> depth <= 8 ?smoothup8_transition : smoothup16_transition ; break ; case SMOOTHDOWN : s -> transitionf = s -> depth <= 8 ?smoothdown8_transition : smoothdown16_transition ; break ; case CIRCLEOPEN : s -> transitionf = s -> depth <= 8 ?circleopen8_transition : circleopen16_transition ; break ; case CIRCLECLOSE : s -> transitionf = s -> depth <= 8 ?circleclose8_transition : circleclose16_transition ; break ; case VERTOPEN : s -> transitionf = s -> depth <= 8 ?vertopen8_transition : vertopen16_transition ; break ; case VERTCLOSE : s -> transitionf = s -> depth <= 8 ?vertclose8_transition : vertclose16_transition ; break ; case HORZOPEN : s -> transitionf = s -> depth <= 8 ?horzopen8_transition : horzopen16_transition ; break ; case HORZCLOSE : s -> transitionf = s -> depth <= 8 ?horzclose8_transition : horzclose16_transition ; break ; case DISSOLVE : s -> transitionf = s -> depth <= 8 ?dissolve8_transition : dissolve16_transition ; break ; case PIXELIZE : s -> transitionf = s -> depth <= 8 ?pixelize8_transition : pixelize16_transition ; break ; case DIAGTL : s -> transitionf = s -> depth <= 8 ?diagtl8_transition : diagtl16_transition ; break ; case DIAGTR : s -> transitionf = s -> depth <= 8 ?diagtr8_transition : diagtr16_transition ; break ; case DIAGBL : s -> transitionf = s -> depth <= 8 ?diagbl8_transition : diagbl16_transition ; break ; case DIAGBR : s -> transitionf = s -> depth <= 8 ?diagbr8_transition : diagbr16_transition ; break ; case HLSLICE : s -> transitionf = s -> depth <= 8 ?hlslice8_transition : hlslice16_transition ; break ; case HRSLICE : s -> transitionf = s -> depth <= 8 ?hrslice8_transition : hrslice16_transition ; break ; case VUSLICE : s -> transitionf = s -> depth <= 8 ?vuslice8_transition : vuslice16_transition ; break ; case VDSLICE : s -> transitionf = s -> depth <= 8 ?vdslice8_transition : vdslice16_transition ; break ; case HBLUR : s -> transitionf = s -> depth <= 8 ?hblur8_transition : hblur16_transition ; break ; case FADEGRAYS : s -> transitionf = s -> depth <= 8 ?fadegrays8_transition : fadegrays16_transition ; break ; case WIPETL : s -> transitionf = s -> depth <= 8 ?wipetl8_transition : wipetl16_transition ; break ; case WIPETR : s -> transitionf = s -> depth <= 8 ?wipetr8_transition : wipetr16_transition ; break ; case WIPEBL : s -> transitionf = s -> depth <= 8 ?wipebl8_transition : wipebl16_transition ; break ; case WIPEBR : s -> transitionf = s -> depth <= 8 ?wipebr8_transition : wipebr16_transition ; break ; case SQUEEZEH : s -> transitionf = s -> depth <= 8 ?squeezeh8_transition : squeezeh16_transition ; break ; case SQUEEZEV : s -> transitionf = s -> depth <= 8 ?squeezev8_transition : squeezev16_transition ; break ; case ZOOMIN : s -> transitionf = s -> depth <= 8 ?zoomin8_transition : zoomin16_transition ; break ; case FADEFAST : s -> transitionf = s -> depth <= 8 ?fadefast8_transition : fadefast16_transition ; break ; case FADESLOW : s -> transitionf = s -> depth <= 8 ?fadeslow8_transition : fadeslow16_transition ; break ; default : return AVERROR_BUG ; } if ( s -> transition == CUSTOM ) { static const char * const func2_names [ ] { "a0" "a1" "a2" "a3" "b0" "b1" "b2" "b3" NULL } ; ; double * func2 [ ] ( void * , double , double ) { a0 } ; , a1 , a2 , a3 , b0 , b1 , b2 , b3 , NULL } int ret ; if ( ! s -> custom_str ) { return AVERROR ( EINVAL ) ; } ret = av_expr_parse ( & s -> e , s -> custom_str , var_names , NULL , NULL , func2_names , func2 , 0 , ctx ) ; if ( ret < 0 ) { return ret ; } } return 0 ; 