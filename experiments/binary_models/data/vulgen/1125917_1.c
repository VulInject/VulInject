static enum drm_connector_status nouveau_connector_detect ( struct drm_connector * connector , bool force ) { struct drm_device * dev = connector -> dev ; struct nouveau_drm * drm = nouveau_drm ( dev ) ; struct nouveau_connector * nv_connector = nouveau_connector ( connector ) ; struct nouveau_encoder * nv_encoder = NULL ; struct nouveau_encoder * nv_partner ; struct i2c_adapter * i2c ; int type ; int ret ; enum drm_connector_status conn_status = connector_status_disconnected ; if ( nv_connector -> edid ) { drm_mode_connector_update_edid_property ( connector , NULL ) ; kfree ( nv_connector -> edid ) ; nv_connector -> edid = NULL ; } ret = pm_runtime_get_sync ( connector -> dev -> dev ) ; if ( ret < 0 && ret != - EACCES ) { return conn_status ; } nv_encoder = nouveau_connector_ddc_detect ( connector ) ; if ( nv_encoder && ( i2c = nv_encoder -> i2c ) != NULL ) { if ( ( vga_switcheroo_handler_flags ( ) & VGA_SWITCHEROO_CAN_SWITCH_DDC ) && nv_connector -> type == DCB_CONNECTOR_LVDS ) { nv_connector -> edid = drm_get_edid_switcheroo ( connector , i2c ) ; } else { nv_connector -> edid = drm_get_edid ( connector , i2c ) ; } drm_mode_connector_update_edid_property ( connector , nv_connector -> edid ) ; if ( ! nv_connector -> edid ) { NV_ERROR ( drm , "DDC responded, but no EDID for %s\n" , connector -> name ) ; detect_analog } nv_partner = NULL ; if ( nv_encoder -> dcb -> type == DCB_OUTPUT_TMDS ) { nv_partner = find_encoder ( connector , DCB_OUTPUT_ANALOG ) ; } if ( nv_encoder -> dcb -> type == DCB_OUTPUT_ANALOG ) { nv_partner = find_encoder ( connector , DCB_OUTPUT_TMDS ) ; } if ( nv_partner && ( ( nv_encoder -> dcb -> type == DCB_OUTPUT_ANALOG && nv_partner -> dcb -> type == DCB_OUTPUT_TMDS ) || ( nv_encoder -> dcb -> type == DCB_OUTPUT_TMDS && nv_partner -> dcb -> type == DCB_OUTPUT_ANALOG ) ) ) { if ( nv_connector -> edid -> input & DRM_EDID_INPUT_DIGITAL ) { type = DCB_OUTPUT_TMDS ; } else { type = DCB_OUTPUT_ANALOG ; } nv_encoder = find_encoder ( connector , type ) ; } nouveau_connector_set_encoder ( connector , nv_encoder ) ; conn_status = connector_status_connected ; out } nv_encoder = nouveau_connector_of_detect ( connector ) ; if ( nv_encoder ) { nouveau_connector_set_encoder ( connector , nv_encoder ) ; conn_status = connector_status_connected ; out } detect_analog nv_encoder = find_encoder ( connector , DCB_OUTPUT_ANALOG ) ; if ( ! nv_encoder && ! nouveau_tv_disable ) { nv_encoder = find_encoder ( connector , DCB_OUTPUT_TV ) ; } out pm_runtime_mark_last_busy ( connector -> dev -> dev ) ; pm_runtime_put_autosuspend ( connector -> dev -> dev ) ; return conn_status ; } 