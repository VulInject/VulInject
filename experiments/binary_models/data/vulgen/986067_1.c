PIX * pixFlipLR ( PIX * pixd , PIX * pixs ) { l_uint8 * tab ; l_int32 w , h , d , wpl ; l_int32 extra , shift , databpl , bpl , i , j ; l_uint32 val ; l_uint32 * line , * data , * buffer ; if ( ! pixs ) { return ( PIX * ) ERROR_PTR ( "pixs not defined" , __func__ , NULL ) ; } pixGetDimensions ( pixs , & w , & h , & d ) ; if ( d != 1 && d != 2 && d != 4 && d != 8 && d != 16 && d != 32 ) { return ( PIX * ) ERROR_PTR ( "pixs not in {1,2,4,8,16,32} bpp" , __func__ , NULL ) ; } if ( ( pixd = pixCopy ( pixd , pixs ) ) == NULL ) { return ( PIX * ) ERROR_PTR ( "pixd not made" , __func__ , NULL ) ; } data = pixGetData ( pixd ) ; wpl = pixGetWpl ( pixd ) ; switch ( d ) { case 1 : tab = makeReverseByteTab1 ( ) ; break ; case 2 : tab = makeReverseByteTab2 ( ) ; break ; case 4 : tab = makeReverseByteTab4 ( ) ; break ; default : tab = NULL ; break ; } if ( ( buffer = ( l_uint32 * ) LEPT_CALLOC ( wpl , sizeof ( l_uint32 ) ) ) == NULL ) { return ( PIX * ) ERROR_PTR ( "buffer not made" , __func__ , pixd ) ; } bpl = 4 * wpl ; switch ( d ) { case 32 : for ( i = 0 ; i < h ; i ++ ) { line = data + i * wpl ; memcpy ( buffer , line , bpl ) ; for ( j = 0 ; j < w ; j ++ ) { line [ j ] = buffer [ w - 1 - j ] ; } } break ; case 16 : for ( i = 0 ; i < h ; i ++ ) { line = data + i * wpl ; memcpy ( buffer , line , bpl ) ; for ( j = 0 ; j < w ; j ++ ) { val = GET_DATA_TWO_BYTES ( buffer , w - 1 - j ) ; SET_DATA_TWO_BYTES ( line , j , val ) ; } } break ; case 8 : for ( i = 0 ; i < h ; i ++ ) { line = data + i * wpl ; memcpy ( buffer , line , bpl ) ; for ( j = 0 ; j < w ; j ++ ) { val = GET_DATA_BYTE ( buffer , w - 1 - j ) ; SET_DATA_BYTE ( line , j , val ) ; } } break ; case 4 : extra = ( w * d ) & 31 ; if ( extra ) { shift = 8 - extra / 4 ; } else { shift = 0 ; } if ( shift ) { rasteropHipLow ( data , h , d , wpl , 0 , h , shift ) ; } databpl = ( w + 1 ) / 2 ; for ( i = 0 ; i < h ; i ++ ) { line = data + i * wpl ; memcpy ( buffer , line , bpl ) ; for ( j = 0 ; j < databpl ; j ++ ) { val = GET_DATA_BYTE ( buffer , bpl - 1 - j ) ; SET_DATA_BYTE ( line , j , tab [ val ] ) ; } } break ; case 2 : extra = ( w * d ) & 31 ; if ( extra ) { shift = 16 - extra / 2 ; } else { shift = 0 ; } if ( shift ) { rasteropHipLow ( data , h , d , wpl , 0 , h , shift ) ; } databpl = ( w + 3 ) / 4 ; for ( i = 0 ; i < h ; i ++ ) { line = data + i * wpl ; memcpy ( buffer , line , bpl ) ; for ( j = 0 ; j < databpl ; j ++ ) { val = GET_DATA_BYTE ( buffer , bpl - 1 - j ) ; SET_DATA_BYTE ( line , j , tab [ val ] ) ; } } break ; case 1 : extra = ( w * d ) & 31 ; if ( extra ) { shift = 32 - extra ; } else { shift = 0 ; } if ( shift ) { rasteropHipLow ( data , h , d , wpl , 0 , h , shift ) ; } databpl = ( w + 7 ) / 8 ; for ( i = 0 ; i < h ; i ++ ) { line = data + i * wpl ; memcpy ( buffer , line , bpl ) ; for ( j = 0 ; j < databpl ; j ++ ) { val = GET_DATA_BYTE ( buffer , bpl - 1 - j ) ; SET_DATA_BYTE ( line , j , tab [ val ] ) ; } } break ; default : pixDestroy ( & pixd ) ; L_ERROR ( "illegal depth: %d\n" , __func__ , d ) ; break ; } LEPT_FREE ( buffer ) ; if ( tab ) { LEPT_FREE ( tab ) ; } return pixd ; } 