CK_RV C_DecryptFinal ( CK_SESSION_HANDLE hSession , CK_BYTE_PTR pLastPart , CK_ULONG_PTR pulLastPartLen ) { CK_RV rv ; soft_session_t * session_p ; boolean_t lock_held = B_FALSE ; rv = handle2session ( hSession , & session_p ) ; if ( rv != CKR_OK ) { return ( rv ) ; } if ( pulLastPartLen == NULL ) { rv = CKR_ARGUMENTS_BAD ; clean_exit } ( void ) pthread_mutex_lock ( & session_p -> session_mutex ) ; lock_held = B_TRUE ; if ( ! ( session_p -> decrypt . flags & CRYPTO_OPERATION_ACTIVE ) ) { SES_REFRELE ( session_p , lock_held ) ; return ( CKR_OPERATION_NOT_INITIALIZED ) ; } ( void ) pthread_mutex_unlock ( & session_p -> session_mutex ) ; lock_held = B_FALSE ; rv = soft_decrypt_final ( session_p , pLastPart , pulLastPartLen ) ; if ( ( rv == CKR_BUFFER_TOO_SMALL ) || ( pLastPart == NULL && rv == CKR_OK ) ) { SES_REFRELE ( session_p , lock_held ) ; return ( rv ) ; } ( void ) pthread_mutex_lock ( & session_p -> session_mutex ) ; session_p -> decrypt . flags = 0 ; lock_held = B_TRUE ; SES_REFRELE ( session_p , lock_held ) ; return ( rv ) ; clean_exit soft_crypt_cleanup ( session_p , B_FALSE , lock_held ) ; return ( rv ) ; } 