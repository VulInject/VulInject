static irqreturn_t sun4i_dma_interrupt ( int irq , void * dev_id ) { struct sun4i_dma_dev * priv = dev_id ; struct sun4i_dma_pchan * pchans = priv -> pchans , * pchan ; struct sun4i_dma_vchan * vchan ; struct sun4i_dma_contract * contract ; struct sun4i_dma_promise * promise ; unsigned long pendirq , irqs , disableirqs ; int bit , i , free_room , allow_mitigation = 1 ; pendirq = readl_relaxed ( priv -> base + SUN4I_DMA_IRQ_PENDING_STATUS_REG ) ; handle_pending disableirqs = 0 ; free_room = 0 ; for_each_set_bit ( , , 32 ) { pchan = & pchans [ bit >> 1 ] ; vchan = pchan -> vchan ; contract = vchan -> contract ; if ( bit & 1 ) { spin_lock ( & vchan -> vc . lock ) ; list_move_tail ( & vchan -> processing -> list , & contract -> completed_demands ) ; if ( contract -> is_cyclic ) { promise = get_next_cyclic_promise ( contract ) ; vchan -> processing = promise ; configure_pchan ( pchan , promise ) ; vchan_cyclic_callback ( & contract -> vd ) ; } else { vchan -> processing = NULL ; vchan -> pchan = NULL ; free_room = 1 ; disableirqs |= BIT ( bit ) ; release_pchan ( priv , pchan ) ; } spin_unlock ( & vchan -> vc . lock ) ; } else { if ( contract -> is_cyclic ) { vchan_cyclic_callback ( & contract -> vd ) ; } else { disableirqs |= BIT ( bit ) ; } } } spin_lock ( & priv -> lock ) ; irqs = readl_relaxed ( priv -> base + SUN4I_DMA_IRQ_ENABLE_REG ) ; writel_relaxed ( irqs & ~ disableirqs , priv -> base + SUN4I_DMA_IRQ_ENABLE_REG ) ; spin_unlock ( & priv -> lock ) ; writel_relaxed ( pendirq , priv -> base + SUN4I_DMA_IRQ_PENDING_STATUS_REG ) ; if ( free_room ) { for ( i = 0 ; i < SUN4I_DMA_NR_MAX_VCHANS ; i ++ ) { vchan = & priv -> vchans [ i ] ; spin_lock ( & vchan -> vc . lock ) ; __execute_vchan_pending ( priv , vchan ) ; spin_unlock ( & vchan -> vc . lock ) ; } } if ( allow_mitigation ) { pendirq = readl_relaxed ( priv -> base + SUN4I_DMA_IRQ_PENDING_STATUS_REG ) ; if ( pendirq ) { allow_mitigation = 0 ; handle_pending } } return IRQ_HANDLED ; } 