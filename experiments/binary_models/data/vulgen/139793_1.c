static void prof_add_rule ( char * name , char * tgt , struct sdev_node * dir , int type ) { int error ; nvlist_t * * nvlp = NULL ; int rv ; ASSERT ( SDEVTOV ( dir ) -> v_type == VDIR ) ; rw_enter ( & dir -> sdev_contents , RW_WRITER ) ; switch ( type ) { case PROFILE_TYPE_INCLUDE : if ( tgt ) { nvlp = & ( dir -> sdev_prof . dev_glob_incdir ) ; } else { nvlp = & ( dir -> sdev_prof . dev_name ) ; } break ; case PROFILE_TYPE_EXCLUDE : if ( tgt ) { nvlp = & ( dir -> sdev_prof . dev_glob_excdir ) ; } else { nvlp = & ( dir -> sdev_prof . dev_name ) ; } break ; case PROFILE_TYPE_MAP : nvlp = & ( dir -> sdev_prof . dev_map ) ; break ; case PROFILE_TYPE_SYMLINK : nvlp = & ( dir -> sdev_prof . dev_symlink ) ; break ; } if ( tgt ) { rv = nvlist_add_string ( * nvlp , name , tgt ) ; } else { rv = nvlist_add_int32 ( * nvlp , name , type ) ; } ASSERT ( rv == 0 ) ; dir -> sdev_flags |= SDEV_BUILD ; if ( ( type == PROFILE_TYPE_INCLUDE ) && ( strpbrk ( name , "*?[]" ) != NULL ) ) { dir -> sdev_prof . has_glob = 1 ; } rw_exit ( & dir -> sdev_contents ) ; switch ( type ) { case PROFILE_TYPE_INCLUDE : case PROFILE_TYPE_EXCLUDE : apply_dir_pattern ( dir , name , tgt , type ) ; break ; } } 