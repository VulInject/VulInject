int xfs_getfsmap ( struct xfs_mount * mp , struct xfs_fsmap_head * head , xfs_fsmap_format_t formatter , void * arg ) { struct xfs_trans * tp = NULL ; struct xfs_fsmap dkeys [ 2 ] ; struct xfs_getfsmap_dev handlers [ XFS_GETFSMAP_DEVS ] ; int i ; int error = 0 ; if ( head -> fmh_iflags & ~ FMH_IF_VALID ) { return - EINVAL ; } if ( ! xfs_getfsmap_is_valid_device ( mp , & head -> fmh_keys [ 0 ] ) || ! xfs_getfsmap_is_valid_device ( mp , & head -> fmh_keys [ 1 ] ) ) { return - EINVAL ; } head -> fmh_entries = 0 ; memset ( handlers , 0 , sizeof ( handlers ) ) ; handlers [ 0 ] . dev = new_encode_dev ( mp -> m_ddev_targp -> bt_dev ) ; if ( xfs_sb_version_hasrmapbt ( & mp -> m_sb ) ) { handlers [ 0 ] . fn = xfs_getfsmap_datadev_rmapbt ; } else { handlers [ 0 ] . fn = xfs_getfsmap_datadev_bnobt ; } if ( mp -> m_logdev_targp != mp -> m_ddev_targp ) { handlers [ 1 ] . dev = new_encode_dev ( mp -> m_logdev_targp -> bt_dev ) ; handlers [ 1 ] . fn = xfs_getfsmap_logdev ; } if ( mp -> m_rtdev_targp ) { handlers [ 2 ] . dev = new_encode_dev ( mp -> m_rtdev_targp -> bt_dev ) ; handlers [ 2 ] . fn = xfs_getfsmap_rtdev_rtbitmap ; } xfs_sort ( handlers , XFS_GETFSMAP_DEVS , sizeof ( xfs_getfsmap_dev ) , xfs_getfsmap_dev_compare ) ; dkeys [ 0 ] = head -> fmh_keys [ 0 ] ; if ( dkeys [ 0 ] . fmr_flags & ( FMR_OF_SPECIAL_OWNER | FMR_OF_EXTENT_MAP ) ) { dkeys [ 0 ] . fmr_physical += dkeys [ 0 ] . fmr_length ; dkeys [ 0 ] . fmr_owner = 0 ; if ( dkeys [ 0 ] . fmr_offset ) { return - EINVAL ; } } else { dkeys [ 0 ] . fmr_offset += dkeys [ 0 ] . fmr_length ; } dkeys [ 0 ] . fmr_length = 0 ; memset ( & dkeys [ 1 ] , 0xFF , sizeof ( xfs_fsmap ) ) ; if ( ! xfs_getfsmap_check_keys ( dkeys , & head -> fmh_keys [ 1 ] ) ) { return - EINVAL ; } info . next_daddr = head -> fmh_keys [ 0 ] . fmr_physical + head -> fmh_keys [ 0 ] . fmr_length ; info . formatter = formatter ; info . format_arg = arg ; info . head = head ; for ( i = 0 ; i < XFS_GETFSMAP_DEVS ; i ++ ) { if ( ! handlers [ i ] . fn ) { continue ; } if ( head -> fmh_keys [ 0 ] . fmr_device > handlers [ i ] . dev ) { continue ; } if ( head -> fmh_keys [ 1 ] . fmr_device < handlers [ i ] . dev ) { break ; } if ( handlers [ i ] . dev == head -> fmh_keys [ 1 ] . fmr_device ) { dkeys [ 1 ] = head -> fmh_keys [ 1 ] ; } if ( handlers [ i ] . dev > head -> fmh_keys [ 0 ] . fmr_device ) { memset ( & dkeys [ 0 ] , 0 , sizeof ( xfs_fsmap ) ) ; } error = xfs_trans_alloc_empty ( mp , & tp ) ; if ( error ) { break ; } info . dev = handlers [ i ] . dev ; info . last = false ; info . agno = NULLAGNUMBER ; error = handlers [ i ] . fn ( tp , dkeys , & info ) ; if ( error ) { break ; } xfs_trans_cancel ( tp ) ; tp = NULL ; info . next_daddr = 0 ; } if ( tp ) { xfs_trans_cancel ( tp ) ; } head -> fmh_oflags = FMH_OF_DEV_T ; return error ; } 