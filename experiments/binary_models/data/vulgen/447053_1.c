static void script_in ( int fd , struct event * ev , struct request * c , uint8_t type ) { struct fcgi_response * resp ; struct fcgi_record_header * header ; ssize_t n ; if ( ( resp = calloc ( 1 , sizeof ( fcgi_response ) ) ) == NULL ) { lwarnx ( "cannot malloc fcgi_response" ) ; return ; } header = ( fcgi_record_header * ) resp -> data ; header -> version = 1 ; header -> type = type ; header -> id = htons ( c -> id ) ; header -> padding_len = 0 ; header -> reserved = 0 ; n = read ( fd , resp -> data + sizeof ( fcgi_record_header ) , FCGI_CONTENT_SIZE ) ; if ( n == - 1 ) { switch ( errno ) { case EINTR : case EAGAIN : free ( resp ) ; return ; default : n = 0 ; } } header -> content_len = htons ( n ) ; resp -> data_pos = 0 ; resp -> data_len = n + sizeof ( fcgi_record_header ) ; slowcgi_add_response ( c , resp ) ; if ( n == 0 ) { if ( type == FCGI_STDOUT ) { c -> script_flags |= STDOUT_DONE ; } else { c -> script_flags |= STDERR_DONE ; } event_del ( ev ) ; close ( fd ) ; } } 