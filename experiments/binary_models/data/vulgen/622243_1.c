void client_dispatch_parent ( int fd , short events , void * p ) { int n ; int shut = 0 ; struct imsg imsg ; struct env * env = p ; struct imsgev * iev = env -> sc_iev ; struct imsgbuf * ibuf = & iev -> ibuf ; if ( ( events & ( EV_READ | EV_WRITE ) ) == 0 ) { fatalx ( "unknown event" ) ; } if ( events & EV_READ ) { if ( ( n = imsg_read ( ibuf ) ) == - 1 && errno != EAGAIN ) { fatal ( "imsg_read error" ) ; } if ( n == 0 ) { shut = 1 ; } } if ( events & EV_WRITE ) { if ( ( n = msgbuf_write ( & ibuf -> w ) ) == - 1 && errno != EAGAIN ) { fatal ( "msgbuf_write" ) ; } if ( n == 0 ) { shut = 1 ; } done } for ( ; ; ) { if ( ( n = imsg_get ( ibuf , & imsg ) ) == - 1 ) { fatal ( "client_dispatch_parent: imsg_get error" ) ; } if ( n == 0 ) { break ; } switch ( imsg . hdr . type ) { case IMSG_CONF_START : { struct env params ; if ( env -> sc_flags & F_CONFIGURING ) { log_warnx ( "configuration already in progress" ) ; break ; } memcpy ( & params , imsg . data , sizeof ( params ) ) ; log_debug ( "configuration starting" ) ; env -> sc_flags |= F_CONFIGURING ; purge_config ( env ) ; memcpy ( & env -> sc_conf_tv , & params . sc_conf_tv , sizeof ( env -> sc_conf_tv ) ) ; env -> sc_flags |= params . sc_flags ; break ; } case IMSG_CONF_IDM : { struct idm * idm ; if ( ! ( env -> sc_flags & F_CONFIGURING ) ) { break ; } memcpy ( idm , imsg . data , sizeof ( * idm ) ) ; idm -> idm_env = env ; TAILQ_INSERT_TAIL ( & env -> sc_idms , idm , idm_entry ) ; break ; } case IMSG_CONF_END : env -> sc_flags &= ~ F_CONFIGURING ; log_debug ( "applying configuration" ) ; client_configure ( env ) ; break ; default : log_debug ( "client_dispatch_parent: unexpect imsg %d" , imsg . hdr . type ) ; break ; } imsg_free ( & imsg ) ; } done if ( ! shut ) { imsg_event_add ( iev ) ; } else { event_del ( & iev -> ev ) ; event_loopexit ( NULL ) ; } } 