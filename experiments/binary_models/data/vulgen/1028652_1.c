file_protected const char * file_getbuffer ( struct magic_set * ms ) { char * pbuf , * op , * np ; size_t psize , len ; if ( ms -> event_flags & EVENT_HAD_ERR ) { return NULL ; } if ( ms -> flags & MAGIC_RAW ) { return ms -> o . buf ; } if ( ms -> o . buf == NULL ) { return NULL ; } len = strlen ( ms -> o . buf ) ; if ( len > ( SIZE_MAX - 1 ) / 4 ) { return NULL ; } psize = len * 4 + 1 ; if ( ( pbuf = CAST ( char * , realloc ( ms -> o . pbuf , psize ) ) ) == NULL ) { file_oomem ( ms , psize ) ; return NULL ; } ms -> o . pbuf = pbuf ; { mbstate_t state ; wchar_t nextchar ; int mb_conv = 1 ; size_t bytesconsumed ; char * eop ; ( void ) memset ( & state , 0 , sizeof ( mbstate_t ) ) ; np = ms -> o . pbuf ; op = ms -> o . buf ; eop = op + len ; while ( op < eop ) { bytesconsumed = mbrtowc ( & nextchar , op , CAST ( size_t , eop - op ) , & state ) ; if ( bytesconsumed == CAST ( size_t , - 1 ) || bytesconsumed == CAST ( size_t , - 2 ) ) { mb_conv = 0 ; break ; } if ( iswprint ( nextchar ) ) { ( void ) memcpy ( np , op , bytesconsumed ) ; op += bytesconsumed ; np += bytesconsumed ; } else { while ( bytesconsumed -- > 0 ) { OCTALIFY ( np , op ) ; } } } * np = '\0' ; if ( mb_conv != 0 ) { return ms -> o . pbuf ; } } for ( np = ms -> o . pbuf , op = ms -> o . buf ; * op ; ) { if ( isprint ( CAST ( , ) ) ) { * np ++ = * op ++ ; } else { OCTALIFY ( np , op ) ; } } * np = '\0' ; return ms -> o . pbuf ; } 