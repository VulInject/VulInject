int nfp_shared_buf_register ( struct nfp_pf * pf ) { struct devlink * devlink = priv_to_devlink ( pf ) ; unsigned int i , num_entries , entry_sz ; struct nfp_cpp_area * sb_desc_area ; u8 __iomem * sb_desc ; int n , err ; if ( ! pf -> mbox ) { return 0 ; } if ( n <= 0 ) { return n ; } num_entries = n ; sb_desc = nfp_pf_map_rtsym ( pf , "sb_tbl" , NFP_SHARED_BUF_TABLE_SYM_NAME , num_entries * sizeof ( pf -> shared_bufs [ 0 ] ) , & sb_desc_area ) ; if ( IS_ERR ( sb_desc ) ) { return PTR_ERR ( sb_desc ) ; } entry_sz = nfp_cpp_area_size ( sb_desc_area ) / num_entries ; pf -> shared_bufs = kmalloc_array ( num_entries , sizeof ( pf -> shared_bufs [ 0 ] ) , GFP_KERNEL ) ; if ( ! pf -> shared_bufs ) { err = - ENOMEM ; err_release_area } for ( i = 0 ; i < num_entries ; i ++ ) { struct nfp_shared_buf * sb = & pf -> shared_bufs [ i ] ; memcpy_fromio ( sb , sb_desc + i * entry_sz , sizeof ( * sb ) ) ; err = devlink_sb_register ( devlink , le32_to_cpu ( sb -> id ) , le32_to_cpu ( sb -> size ) , le16_to_cpu ( sb -> ingress_pools_count ) , le16_to_cpu ( sb -> egress_pools_count ) , le16_to_cpu ( sb -> ingress_tc_count ) , le16_to_cpu ( sb -> egress_tc_count ) ) ; if ( err ) { err_unreg_prev } } pf -> num_shared_bufs = num_entries ; nfp_cpp_area_release_free ( sb_desc_area ) ; return 0 ; err_unreg_prev while ( i -- ) { devlink_sb_unregister ( devlink , le32_to_cpu ( pf -> shared_bufs [ i ] . id ) ) ; } kfree ( pf -> shared_bufs ) ; err_release_area nfp_cpp_area_release_free ( sb_desc_area ) ; return err ; } 