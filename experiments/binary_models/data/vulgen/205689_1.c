static struct sem_undo * find_alloc_undo ( struct ipc_namespace * ns , int semid ) { struct sem_array * sma ; struct sem_undo_list * ulp ; struct sem_undo * un , * ; int nsems , error ; error = get_undo_list ( & ulp ) ; if ( error ) { return ERR_PTR ( error ) ; } rcu_read_lock ( ) ; spin_lock ( & ulp -> lock ) ; un = lookup_undo ( ulp , semid ) ; spin_unlock ( & ulp -> lock ) ; if ( likely ( un != NULL ) ) { out } sma = sem_obtain_object_check ( ns , semid ) ; if ( IS_ERR ( sma ) ) { rcu_read_unlock ( ) ; return ERR_CAST ( sma ) ; } nsems = sma -> sem_nsems ; if ( ! ipc_rcu_getref ( & sma -> sem_perm ) ) { rcu_read_unlock ( ) ; un = ERR_PTR ( - EIDRM ) ; out } rcu_read_unlock ( ) ; new = kvzalloc ( sizeof ( sem_undo ) + sizeof ( short ) * nsems , GFP_KERNEL_ACCOUNT ) ; if ( ! new ) { ipc_rcu_putref ( & sma -> sem_perm , sem_rcu_free ) ; return ERR_PTR ( - ENOMEM ) ; } rcu_read_lock ( ) ; sem_lock_and_putref ( sma ) ; if ( ! ipc_valid_object ( & sma -> sem_perm ) ) { rcu_read_unlock ( ) ; kvfree ( new ) ; un = ERR_PTR ( - EIDRM ) ; out } spin_lock ( & ulp -> lock ) ; un = lookup_undo ( ulp , semid ) ; if ( un ) { spin_unlock ( & ulp -> lock ) ; kvfree ( new ) ; success } new -> semadj = ( short * ) & new [ 1 ] ; new -> ulp = ulp ; new -> semid = semid ; assert_spin_locked ( & ulp -> lock ) ; list_add_rcu ( & new -> list_proc , & ulp -> list_proc ) ; ipc_assert_locked_object ( & sma -> sem_perm ) ; list_add ( & new -> list_id , & sma -> list_id ) ; un = new ; spin_unlock ( & ulp -> lock ) ; success sem_unlock ( sma , - 1 ) ; out return un ; } 