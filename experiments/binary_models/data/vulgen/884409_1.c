int hfsplus_block_free ( struct super_block * sb , u32 offset , u32 count ) { struct hfsplus_sb_info * sbi = HFSPLUS_SB ( sb ) ; struct page * page ; struct address_space * mapping ; __be32 * pptr , * curr , * end ; u32 mask , len , pnr ; int i ; if ( ! count ) { return 0 ; } hfs_dbg ( BITMAP , "block_free: %u,%u\n" , offset , count ) ; mutex_lock ( & sbi -> alloc_mutex ) ; mapping = sbi -> alloc_file -> i_mapping ; pnr = offset / PAGE_CACHE_BITS ; page = read_mapping_page ( mapping , pnr , NULL ) ; if ( IS_ERR ( page ) ) { kaboom } pptr = kmap_local_page ( page ) ; curr = pptr + ( offset & ( PAGE_CACHE_BITS - 1 ) ) / 32 ; end = pptr + PAGE_CACHE_BITS / 32 ; len = count ; i = offset % 32 ; if ( i ) { int j = 32 - i ; mask = 0xffffffffU << j ; if ( j > count ) { mask |= 0xffffffffU >> ( i + count ) ; * curr ++ &= cpu_to_be32 ( mask ) ; out } * curr ++ &= cpu_to_be32 ( mask ) ; count -= j ; } while ( 1 ) { while ( curr < end ) { if ( count < 32 ) { done } * curr ++ = 0 ; count -= 32 ; } if ( ! count ) { break ; } set_page_dirty ( page ) ; kunmap_local ( pptr ) ; page = read_mapping_page ( mapping , ++ pnr , NULL ) ; if ( IS_ERR ( page ) ) { kaboom } pptr = kmap_local_page ( page ) ; curr = pptr ; end = pptr + PAGE_CACHE_BITS / 32 ; } done if ( count ) { mask = 0xffffffffU >> count ; * curr &= cpu_to_be32 ( mask ) ; } out set_page_dirty ( page ) ; kunmap_local ( pptr ) ; sbi -> free_blocks += len ; hfsplus_mark_mdb_dirty ( sb ) ; mutex_unlock ( & sbi -> alloc_mutex ) ; return 0 ; kaboom pr_crit ( "unable to mark blocks free: error %ld\n" , PTR_ERR ( page ) ) ; mutex_unlock ( & sbi -> alloc_mutex ) ; return - EIO ; } 