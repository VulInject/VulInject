static int cacl ( int cmd , int nentries , void * aclbufp , vnode_t * vp , int * rv ) { int error ; int aclbsize ; int dfaclbsize ; int numacls ; caddr_t uaddrp ; aclent_t * aclp , * aaclp ; vsecattr_t vsecattr ; size_t entry_size ; ASSERT ( vp ) ; bzero ( & vsecattr , sizeof ( vsecattr_t ) ) ; dfaclbsize = 0 ; switch ( cmd ) { case ACE_GETACLCNT : case GETACLCNT : if ( cmd == GETACLCNT ) { entry_size = sizeof ( aclent_t ) ; vsecattr . vsa_mask = VSA_ACLCNT | VSA_DFACLCNT ; } else { entry_size = sizeof ( ace_t ) ; vsecattr . vsa_mask = VSA_ACECNT ; } if ( error = VOP_GETSECATTR ( vp , & vsecattr , 0 , CRED ( ) , NULL ) ) { return ( error ) ; } * rv = vsecattr . vsa_aclcnt + vsecattr . vsa_dfaclcnt ; if ( vsecattr . vsa_aclcnt && vsecattr . vsa_aclentp ) { kmem_free ( vsecattr . vsa_aclentp , vsecattr . vsa_aclcnt * entry_size ) ; } if ( vsecattr . vsa_dfaclcnt && vsecattr . vsa_dfaclentp ) { kmem_free ( vsecattr . vsa_dfaclentp , vsecattr . vsa_dfaclcnt * entry_size ) ; } break ; case GETACL : if ( aclbufp == NULL ) { return ( EFAULT ) ; } vsecattr . vsa_mask = VSA_ACL | VSA_ACLCNT | VSA_DFACL | VSA_DFACLCNT ; if ( error = VOP_GETSECATTR ( vp , & vsecattr , 0 , CRED ( ) , NULL ) ) { return ( error ) ; } numacls = vsecattr . vsa_aclcnt + vsecattr . vsa_dfaclcnt ; aclbsize = vsecattr . vsa_aclcnt * sizeof ( aclent_t ) ; dfaclbsize = vsecattr . vsa_dfaclcnt * sizeof ( aclent_t ) ; if ( numacls > nentries ) { error = ENOSPC ; errout } if ( vsecattr . vsa_aclcnt > 1 ) { ksort ( ( caddr_t ) vsecattr . vsa_aclentp , vsecattr . vsa_aclcnt , sizeof ( aclent_t ) , cmp2acls ) ; } if ( vsecattr . vsa_dfaclcnt > 1 ) { ksort ( ( caddr_t ) vsecattr . vsa_dfaclentp , vsecattr . vsa_dfaclcnt , sizeof ( aclent_t ) , cmp2acls ) ; } uaddrp = ( caddr_t ) aclbufp ; if ( aclbsize > 0 ) { if ( copyout ( vsecattr . vsa_aclentp , uaddrp , aclbsize ) ) { error = EFAULT ; errout } } if ( dfaclbsize > 0 ) { uaddrp += aclbsize ; if ( copyout ( vsecattr . vsa_dfaclentp , uaddrp , dfaclbsize ) ) { error = EFAULT ; errout } } * rv = numacls ; if ( vsecattr . vsa_aclcnt ) { kmem_free ( vsecattr . vsa_aclentp , vsecattr . vsa_aclcnt * sizeof ( aclent_t ) ) ; } if ( vsecattr . vsa_dfaclcnt ) { kmem_free ( vsecattr . vsa_dfaclentp , vsecattr . vsa_dfaclcnt * sizeof ( aclent_t ) ) ; } break ; case ACE_GETACL : if ( aclbufp == NULL ) { return ( EFAULT ) ; } vsecattr . vsa_mask = VSA_ACE | VSA_ACECNT ; if ( error = VOP_GETSECATTR ( vp , & vsecattr , 0 , CRED ( ) , NULL ) ) { return ( error ) ; } aclbsize = vsecattr . vsa_aclcnt * sizeof ( ace_t ) ; if ( vsecattr . vsa_aclcnt > nentries ) { error = ENOSPC ; errout } if ( aclbsize > 0 ) { if ( ( error = copyout ( vsecattr . vsa_aclentp , aclbufp , aclbsize ) ) != 0 ) { errout } } * rv = vsecattr . vsa_aclcnt ; if ( vsecattr . vsa_aclcnt ) { kmem_free ( vsecattr . vsa_aclentp , vsecattr . vsa_aclentsz ) ; } break ; case SETACL : if ( nentries ( 3 || nentries ) ( MAX_ACL_ENTRIES * 2 ) ) { return ( EINVAL ) ; } if ( aclbufp == NULL ) { return ( EFAULT ) ; } vsecattr . vsa_mask = VSA_ACL ; aclbsize = nentries * sizeof ( aclent_t ) ; vsecattr . vsa_aclentp = kmem_alloc ( aclbsize , KM_SLEEP ) ; aaclp = vsecattr . vsa_aclentp ; vsecattr . vsa_aclcnt = nentries ; uaddrp = ( caddr_t ) aclbufp ; if ( copyin ( uaddrp , vsecattr . vsa_aclentp , aclbsize ) ) { kmem_free ( aaclp , aclbsize ) ; return ( EFAULT ) ; } ksort ( ( caddr_t ) vsecattr . vsa_aclentp , vsecattr . vsa_aclcnt , sizeof ( aclent_t ) , cmp2acls ) ; for ( numacls = 0 , aclp = vsecattr . vsa_aclentp ; numacls < vsecattr . vsa_aclcnt ; aclp ++ , numacls ++ ) { if ( aclp -> a_type & ACL_DEFAULT ) { break ; } } if ( numacls < vsecattr . vsa_aclcnt ) { vsecattr . vsa_mask |= VSA_DFACL ; vsecattr . vsa_dfaclcnt = nentries - numacls ; vsecattr . vsa_dfaclentp = aclp ; vsecattr . vsa_aclcnt = numacls ; } if ( vsecattr . vsa_aclcnt == 0 ) { vsecattr . vsa_mask &= ~ VSA_ACL ; vsecattr . vsa_aclentp = NULL ; } if ( vsecattr . vsa_dfaclcnt && vp -> v_type != VDIR ) { kmem_free ( aaclp , aclbsize ) ; return ( ENOTDIR ) ; } ( void ) VOP_RWLOCK ( vp , V_WRITELOCK_TRUE , NULL ) ; if ( error = VOP_SETSECATTR ( vp , & vsecattr , 0 , CRED ( ) , NULL ) ) { kmem_free ( aaclp , aclbsize ) ; VOP_RWUNLOCK ( vp , V_WRITELOCK_TRUE , NULL ) ; return ( error ) ; } * rv = 0 ; kmem_free ( aaclp , aclbsize ) ; VOP_RWUNLOCK ( vp , V_WRITELOCK_TRUE , NULL ) ; break ; case ACE_SETACL : if ( nentries ( 1 || nentries ) MAX_ACL_ENTRIES ) { return ( EINVAL ) ; } if ( aclbufp == NULL ) { return ( EFAULT ) ; } vsecattr . vsa_mask = VSA_ACE ; aclbsize = nentries * sizeof ( ace_t ) ; vsecattr . vsa_aclentp = kmem_alloc ( aclbsize , KM_SLEEP ) ; aaclp = vsecattr . vsa_aclentp ; vsecattr . vsa_aclcnt = nentries ; vsecattr . vsa_aclentsz = aclbsize ; uaddrp = ( caddr_t ) aclbufp ; if ( copyin ( uaddrp , vsecattr . vsa_aclentp , aclbsize ) ) { kmem_free ( aaclp , aclbsize ) ; return ( EFAULT ) ; } ( void ) VOP_RWLOCK ( vp , V_WRITELOCK_TRUE , NULL ) ; if ( error = VOP_SETSECATTR ( vp , & vsecattr , 0 , CRED ( ) , NULL ) ) { kmem_free ( aaclp , aclbsize ) ; VOP_RWUNLOCK ( vp , V_WRITELOCK_TRUE , NULL ) ; return ( error ) ; } * rv = 0 ; kmem_free ( aaclp , aclbsize ) ; VOP_RWUNLOCK ( vp , V_WRITELOCK_TRUE , NULL ) ; break ; default : return ( EINVAL ) ; } return ( 0 ) ; errout if ( aclbsize && vsecattr . vsa_aclentp ) { kmem_free ( vsecattr . vsa_aclentp , aclbsize ) ; } if ( dfaclbsize && vsecattr . vsa_dfaclentp ) { kmem_free ( vsecattr . vsa_dfaclentp , dfaclbsize ) ; } return ( error ) ; } 