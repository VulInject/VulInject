static int nouveau_channel_ctor ( struct nouveau_drm * drm , struct nvif_device * device , bool priv , u64 runm , struct nouveau_channel * * pchan ) { static const { s32 oclass ; int version ; } , hosts [ ] { { AMPERE_CHANNEL_GPFIFO_B 0 } { AMPERE_CHANNEL_GPFIFO_A 0 } { TURING_CHANNEL_GPFIFO_A 0 } { VOLTA_CHANNEL_GPFIFO_A 0 } { PASCAL_CHANNEL_GPFIFO_A 0 } { MAXWELL_CHANNEL_GPFIFO_A 0 } { KEPLER_CHANNEL_GPFIFO_B 0 } { KEPLER_CHANNEL_GPFIFO_A 0 } { FERMI_CHANNEL_GPFIFO 0 } { G82_CHANNEL_GPFIFO 0 } { NV50_CHANNEL_GPFIFO 0 } { NV40_CHANNEL_DMA 0 } { NV17_CHANNEL_DMA 0 } { NV10_CHANNEL_DMA 0 } { NV03_CHANNEL_DMA 0 } { } } ; { struct nvif_chan_v0 chan ; char name [ TASK_COMM_LEN + 16 ] ; } , args struct nouveau_cli * cli = ( void * ) device -> object . client ; struct nouveau_channel * chan ; const u64 plength = 0x10000 ; const u64 ioffset = plength ; const u64 ilength = 0x02000 ; char name [ TASK_COMM_LEN ] ; int cid , ret ; u64 size ; cid = nvif_mclass ( & device -> object , hosts ) ; if ( hosts [ cid ] . oclass < NV50_CHANNEL_GPFIFO ) { size = plength ; } else { size = ioffset + ilength ; } ret = nouveau_channel_prep ( drm , device , size , & chan ) ; * pchan = chan ; if ( ret ) { return ret ; } args . chan . version = 0 ; args . chan . namelen = sizeof ( args . name ) ; args . chan . runlist = __ffs64 ( runm ) ; args . chan . runq = 0 ; args . chan . priv = priv ; args . chan . devm = BIT ( 0 ) ; if ( hosts [ cid ] . oclass < NV50_CHANNEL_GPFIFO ) { args . chan . vmm = 0 ; args . chan . ctxdma = nvif_handle ( & chan -> push . ctxdma ) ; args . chan . offset = chan -> push . addr ; args . chan . length = 0 ; } else { args . chan . vmm = nvif_handle ( & chan -> vmm -> vmm . object ) ; if ( hosts [ cid ] . oclass < FERMI_CHANNEL_GPFIFO ) { args . chan . ctxdma = nvif_handle ( & chan -> push . ctxdma ) ; } else { args . chan . ctxdma = 0 ; } args . chan . offset = ioffset + chan -> push . addr ; args . chan . length = ilength ; } args . chan . huserd = 0 ; args . chan . ouserd = 0 ; if ( hosts [ cid ] . oclass >= VOLTA_CHANNEL_GPFIFO_A ) { ret = nvif_mem_ctor ( & cli -> mmu , "abi16ChanUSERD" , NVIF_CLASS_MEM_GF100 , NVIF_MEM_VRAM | NVIF_MEM_COHERENT | NVIF_MEM_MAPPABLE , 0 , PAGE_SIZE , NULL , 0 , & chan -> mem_userd ) ; if ( ret ) { return ret ; } args . chan . huserd = nvif_handle ( & chan -> mem_userd . object ) ; args . chan . ouserd = 0 ; chan -> userd = & chan -> mem_userd . object ; } else { chan -> userd = & chan -> user ; } get_task_comm ( name , current ) ; snprintf ( args . name , sizeof ( args . name ) , "%s[%d]" , name , task_pid_nr ( current ) ) ; ret = nvif_object_ctor ( & device -> object , "abi16ChanUser" , 0 , hosts [ cid ] . oclass , & args , sizeof ( args ) , & chan -> user ) ; if ( ret ) { nouveau_channel_del ( pchan ) ; return ret ; } chan -> runlist = args . chan . runlist ; chan -> chid = args . chan . chid ; chan -> inst = args . chan . inst ; chan -> token = args . chan . token ; return 0 ; } 