bool hashfast_poll_msg ( struct thr_info * const master_thr ) { struct cgpu_info * const dev = master_thr -> cgpu ; struct hashfast_dev_state * const devstate = dev -> device_data ; const int fd = devstate -> fd ; struct hashfast_parsed_msg msg ; if ( ! hashfast_parse_msg ( fd , & msg ) ) { return false ; } switch ( msg . opcode ) { case HFOP_NONCE : { const uint8_t * data = msg . data ; for ( int i = msg . datalen / 8 ; i ; -- i , ( data = & data [ 8 ] ) ) { const uint32_t nonce = ( data [ 0 ] << 0 ) | ( data [ 1 ] << 8 ) | ( data [ 2 ] << 16 ) | ( data [ 3 ] << 24 ) ; const uint8_t seq = data [ 4 ] ; const uint8_t coreaddr = data [ 5 ] ; const bool search = data [ 7 ] & 0x10 ; struct cgpu_info * const proc = hashfast_find_proc ( master_thr , msg . chipaddr , coreaddr ) ; if ( unlikely ( ! proc ) ) { applog ( LOG_ERR , "%s: Unknown chip/core address %u/%u" , dev -> dev_repr , ( unsigned ) msg . chipaddr , ( unsigned ) coreaddr ) ; continue ; } struct thr_info * const thr = proc -> thr [ 0 ] ; struct hashfast_core_state * const cs = thr -> cgpu_data ; struct work * work ; DL_SEARCH_SCALAR ( thr -> work , work , device_id , seq ) ; if ( unlikely ( ! work ) ) { applog ( LOG_WARNING , "%" PRIpreprv ": Unknown seq %02x (last=%02x)" , proc -> proc_repr , ( unsigned ) seq , ( unsigned ) cs -> last_seq ) ; inc_hw_errors2 ( thr , NULL , & nonce ) ; continue ; } unsigned nonces_found = 1 ; hashfast_submit_nonce ( thr , work , nonce , false ) ; if ( search ) { for ( int noffset = 1 ; noffset <= 0x80 ; ++ noffset ) { const uint32_t nonce2 = nonce + noffset ; if ( test_nonce ( work , nonce2 , false ) ) { hashfast_submit_nonce ( thr , work , nonce2 , true ) ; ++ nonces_found ; } } if ( ! nonces_found ) { inc_hw_errors_only ( thr ) ; applog ( LOG_WARNING , "%" PRIpreprv ": search=1, but failed to turn up any additional solutions" , proc -> proc_repr ) ; } } hashes_done2 ( thr , 0x100000000 * nonces_found , NULL ) ; } break ; } case HFOP_STATUS : { const uint8_t * data = & msg . data [ 8 ] ; struct cgpu_info * proc = hashfast_find_proc ( master_thr , msg . chipaddr , 0 ) ; struct cgpu_info * first_proc = proc ; if ( unlikely ( ! proc ) ) { applog ( LOG_ERR , "%s: Unknown chip address %u" , dev -> dev_repr , ( unsigned ) msg . chipaddr ) ; inc_hw_errors_only ( master_thr ) ; break ; } struct hashfast_chip_state * const chipstate = & devstate -> chipstates [ msg . chipaddr ] ; hashfast_isn_t isn = hashfast_get_isn ( chipstate , msg . hdata ) ; const float temp = hashfast_temperature_conv ( & msg . data [ 0 ] ) ; for ( int i = 0 ; i < HASHFAST_MAX_VOLTAGES ; ++ i ) { chipstate -> voltages [ i ] = hashfast_voltage_conv ( msg . data [ 2 + i ] ) ; } int cores_uptodate , cores_active , cores_pending , cores_transitioned ; cores_uptodate = cores_active = cores_pending = cores_transitioned = 0 ; for ( int i = 0 ; i < devstate -> cores_per_chip ; ++ i , ( proc = proc -> next_proc ) ) { struct thr_info * const thr = proc -> thr [ 0 ] ; struct hashfast_core_state * const cs = thr -> cgpu_data ; const uint8_t bits = data [ i / 4 ] >> ( 2 * ( i % 4 ) ) ; const bool has_active = bits & 1 ; const bool has_pending = bits & 2 ; bool try_transition = true ; proc -> temp = temp ; if ( cs -> last_isn <= isn ) { ++ cores_uptodate ; } else { try_transition = false ; } if ( has_active ) { ++ cores_active ; } if ( has_pending ) { ++ cores_pending ; } if ( try_transition ) { ++ cores_transitioned ; cs -> has_pending = false ; if ( chipstate -> clock_desired == chipstate -> clock ) { thr -> queue_full = false ; } } } applog ( LOG_DEBUG , "%s: STATUS from chipaddr=0x%02x with hdata=0x%04x (isn=0x%lx): total=%d uptodate=%d active=%d pending=%d transitioned=%d" , dev -> dev_repr , ( unsigned ) msg . chipaddr , ( unsigned ) msg . hdata , isn , devstate -> cores_per_chip , cores_uptodate , cores_active , cores_pending , cores_transitioned ) ; if ( ( ! cores_active ) && chipstate -> clock_desired != chipstate -> clock ) { uint8_t buf [ HASHFAST_HEADER_SIZE + HASHFAST_CONFIG_DATA_SIZE ] ; uint16_t clock = chipstate -> clock_desired , hdata ; if ( ! hashfast_send_msg ( fd , buf , HFOP_UMS_CLOCK_CHANGE , msg . chipaddr , 0 , HFWR_SET_CLOCK | clock , 0 ) ) { applog ( LOG_ERR , "%" PRIpreprv ": Clock change failure (%s)" , proc -> proc_repr , "OP_UMS_CLOCK_CHANGE" ) ; clockchangefailed } chipstate -> clock = 0 ; hdata = HFCH_WRITE ; hdata |= hashfast_chip_thermal_cutoff_hdata ( 110 ) ; pk_uNle ( chipstate -> cfgdata , 8 , 0 , 0xc , clock ) ; memcpy ( & buf [ HASHFAST_HEADER_SIZE ] , chipstate -> cfgdata , HASHFAST_CONFIG_DATA_SIZE ) ; if ( ! hashfast_send_msg ( fd , buf , HFOP_CONFIG , msg . chipaddr , 0 , hdata , HASHFAST_CONFIG_DATA_SIZE ) ) { applog ( LOG_ERR , "%" PRIpreprv ": Clock change failure (%s)" , proc -> proc_repr , "OP_CONFIG" ) ; clockchangefailed } chipstate -> clock = clock ; proc = first_proc ; for ( int i = 0 ; i < devstate -> cores_per_chip ; ++ i , ( proc = proc -> next_proc ) ) { struct thr_info * const thr = proc -> thr [ 0 ] ; thr -> queue_full = false ; } clockchangefailed } break ; } } return true ; } 