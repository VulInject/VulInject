u32 hevcmerge_rewrite_slice ( GF_HEVCMergeCtx * ctx , HEVCTilePidCtx * tile_pid , char * in_slice , u32 in_slice_length ) { u64 header_end ; u32 out_slice_size_no_epb = 0 , out_slice_length ; u32 num_entry_point_start ; u32 pps_id ; Bool RapPicFlag = GF_FALSE ; u32 slice_qp_delta_start ; HEVC_PPS * pps ; HEVC_SPS * sps ; u32 al , slice_size , in_slice_size_no_epb , slice_offset_orig , slice_offset_dst ; u32 first_slice_segment_in_pic_flag ; u32 dependent_slice_segment_flag ; u8 nal_unit_type ; s32 new_slice_qp_delta ; HEVCState * hevc = & tile_pid -> hevc_state ; if ( ctx -> buffer_nal_in_no_epb_alloc < in_slice_length ) { ctx -> buffer_nal_in_no_epb_alloc = in_slice_length ; ctx -> buffer_nal_in_no_epb = gf_realloc ( ctx -> buffer_nal_in_no_epb , in_slice_length ) ; } in_slice_size_no_epb = gf_media_nalu_remove_emulation_bytes ( in_slice , ctx -> buffer_nal_in_no_epb , in_slice_length ) ; gf_bs_reassign_buffer ( ctx -> bs_nal_in , ctx -> buffer_nal_in_no_epb , in_slice_size_no_epb ) ; gf_bs_enable_emulation_byte_removal ( ctx -> bs_nal_in , GF_FALSE ) ; if ( ! ctx -> bs_nal_out ) { ctx -> bs_nal_out = gf_bs_new ( NULL , 0 , GF_BITSTREAM_WRITE ) ; } else { gf_bs_reassign_buffer ( ctx -> bs_nal_out , ctx -> buffer_nal_no_epb , ctx -> buffer_nal_no_epb_alloc ) ; } assert ( hevc -> s_info . header_size_bits >= 0 ) ; assert ( hevc -> s_info . entry_point_start_bits >= 0 ) ; header_end = ( u64 ) hevc -> s_info . header_size_bits ; num_entry_point_start = ( u32 ) hevc -> s_info . entry_point_start_bits ; slice_qp_delta_start = ( u32 ) hevc -> s_info . slice_qp_delta_start_bits ; gf_bs_write_int ( ctx -> bs_nal_out , gf_bs_read_int ( ctx -> bs_nal_in , 1 ) , 1 ) ; nal_unit_type = gf_bs_read_int ( ctx -> bs_nal_in , 6 ) ; gf_bs_write_int ( ctx -> bs_nal_out , nal_unit_type , 6 ) ; gf_bs_write_int ( ctx -> bs_nal_out , gf_bs_read_int ( ctx -> bs_nal_in , 9 ) , 9 ) ; first_slice_segment_in_pic_flag = gf_bs_read_int ( ctx -> bs_nal_in , 1 ) ; if ( tile_pid -> slice_segment_address == 0 ) { gf_bs_write_int ( ctx -> bs_nal_out , 1 , 1 ) ; } else { gf_bs_write_int ( ctx -> bs_nal_out , 0 , 1 ) ; } switch ( nal_unit_type ) { case GF_HEVC_NALU_SLICE_IDR_W_DLP : case GF_HEVC_NALU_SLICE_IDR_N_LP : RapPicFlag = GF_TRUE ; break ; case GF_HEVC_NALU_SLICE_BLA_W_LP : case GF_HEVC_NALU_SLICE_BLA_W_DLP : case GF_HEVC_NALU_SLICE_BLA_N_LP : case GF_HEVC_NALU_SLICE_CRA : RapPicFlag = GF_TRUE ; break ; } if ( RapPicFlag ) { gf_bs_write_int ( ctx -> bs_nal_out , gf_bs_read_int ( ctx -> bs_nal_in , 1 ) , 1 ) ; } pps_id = gf_bs_read_ue ( ctx -> bs_nal_in ) ; gf_bs_write_ue ( ctx -> bs_nal_out , pps_id ) ; pps = & hevc -> pps [ pps_id ] ; sps = & hevc -> sps [ pps -> sps_id ] ; if ( ! first_slice_segment_in_pic_flag && pps -> dependent_slice_segments_enabled_flag ) { dependent_slice_segment_flag = gf_bs_read_int ( ctx -> bs_nal_in , 1 ) ; } else { dependent_slice_segment_flag = GF_FALSE ; } if ( ! first_slice_segment_in_pic_flag ) { gf_bs_read_int ( ctx -> bs_nal_in , sps -> bitsSliceSegmentAddress ) ; } if ( tile_pid -> slice_segment_address > 0 ) { if ( pps -> dependent_slice_segments_enabled_flag ) { gf_bs_write_int ( ctx -> bs_nal_out , dependent_slice_segment_flag , 1 ) ; } gf_bs_write_int ( ctx -> bs_nal_out , tile_pid -> slice_segment_address , ctx -> nb_bits_per_address_dst ) ; } while ( slice_qp_delta_start != ( gf_bs_get_position ( ctx -> bs_nal_in ) - 1 ) * 8 + gf_bs_get_bit_position ( ctx -> bs_nal_in ) ) { gf_bs_write_int ( ctx -> bs_nal_out , gf_bs_read_int ( ctx -> bs_nal_in , 1 ) , 1 ) ; } new_slice_qp_delta = hevc -> s_info . pps -> pic_init_qp_minus26 + hevc -> s_info . slice_qp_delta - ctx -> base_pps_init_qp_delta_minus26 ; gf_bs_write_se ( ctx -> bs_nal_out , new_slice_qp_delta ) ; gf_bs_read_se ( ctx -> bs_nal_in ) ; while ( num_entry_point_start != ( gf_bs_get_position ( ctx -> bs_nal_in ) - 1 ) * 8 + gf_bs_get_bit_position ( ctx -> bs_nal_in ) ) { gf_bs_write_int ( ctx -> bs_nal_out , gf_bs_read_int ( ctx -> bs_nal_in , 1 ) , 1 ) ; } gf_bs_write_ue ( ctx -> bs_nal_out , 0 ) ; if ( pps -> slice_segment_header_extension_present_flag ) { gf_bs_write_int ( ctx -> bs_nal_out , 0 , 1 ) ; } while ( header_end != ( gf_bs_get_position ( ctx -> bs_nal_in ) - 1 ) * 8 + gf_bs_get_bit_position ( ctx -> bs_nal_in ) ) { gf_bs_read_int ( ctx -> bs_nal_in , 1 ) ; } al = gf_bs_read_int ( ctx -> bs_nal_in , 1 ) ; if ( al != 1 ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_MEDIA , ( "[HEVCMerge] source slice header not properly aligned\n" ) ) ; } gf_bs_align ( ctx -> bs_nal_in ) ; gf_bs_write_int ( ctx -> bs_nal_out , 1 , 1 ) ; gf_bs_align ( ctx -> bs_nal_out ) ; gf_bs_get_content_no_truncate ( ctx -> bs_nal_out , & ctx -> buffer_nal_no_epb , & out_slice_size_no_epb , & ctx -> buffer_nal_no_epb_alloc ) ; slice_size = ( u32 ) gf_bs_available ( ctx -> bs_nal_in ) ; slice_offset_orig = ( u32 ) gf_bs_get_position ( ctx -> bs_nal_in ) ; slice_offset_dst = out_slice_size_no_epb ; out_slice_size_no_epb += slice_size ; if ( ctx -> buffer_nal_no_epb_alloc < out_slice_size_no_epb ) { ctx -> buffer_nal_no_epb_alloc = out_slice_size_no_epb ; ctx -> buffer_nal_no_epb = gf_realloc ( ctx -> buffer_nal_no_epb , out_slice_size_no_epb ) ; } memcpy ( ctx -> buffer_nal_no_epb + slice_offset_dst , ctx -> buffer_nal_in_no_epb + slice_offset_orig , sizeof ( char ) * slice_size ) ; out_slice_length = out_slice_size_no_epb + gf_media_nalu_emulation_bytes_add_count ( ctx -> buffer_nal_no_epb , out_slice_size_no_epb ) ; gf_media_nalu_add_emulation_bytes ( ctx -> buffer_nal_no_epb , ctx -> buffer_nal , out_slice_size_no_epb ) ; return out_slice_length ; } 