void irlmp_expire_discoveries ( hashbin_t * log , __u32 saddr , int force ) { discovery_t * discovery ; discovery_t * curr ; unsigned long flags ; discinfo_t * buffer = NULL ; int n ; int i = 0 ; IRDA_ASSERT ( , ) spin_lock_irqsave ( & log -> hb_spinlock , flags ) ; discovery = ( discovery_t * ) hashbin_get_first ( log ) ; while ( discovery != NULL ) { curr = discovery ; discovery = ( discovery_t * ) hashbin_get_next ( log ) ; if ( ( curr -> data . saddr == saddr ) && ( force || ( ( jiffies - curr -> timestamp ) > DISCOVERY_EXPIRE_TIMEOUT ) ) ) { if ( buffer == NULL ) { n = HASHBIN_GET_SIZE ( log ) ; buffer = kmalloc ( n * sizeof ( irda_device_info ) , GFP_ATOMIC ) ; if ( buffer == NULL ) { spin_unlock_irqrestore ( & log -> hb_spinlock , flags ) ; return ; } } memcpy ( & ( buffer [ i ] ) , & ( curr -> data ) , sizeof ( discinfo_t ) ) ; i ++ ; curr = hashbin_remove_this ( log , ( irda_queue_t * ) curr ) ; kfree ( curr ) ; } } spin_unlock_irqrestore ( & log -> hb_spinlock , flags ) ; irlmp_discovery_expiry ( buffer , i ) ; kfree ( buffer ) ; } 