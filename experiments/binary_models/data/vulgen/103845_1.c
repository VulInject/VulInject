static irqreturn_t dspi_interrupt ( int irq , void * dev_id ) { struct fsl_dspi * dspi = ( fsl_dspi * ) dev_id ; struct spi_message * msg = dspi -> cur_msg ; enum dspi_trans_mode trans_mode ; u32 spi_sr , spi_tcr ; u32 spi_tcnt , tcnt_diff ; int tx_word ; regmap_read ( dspi -> regmap , SPI_SR , & spi_sr ) ; regmap_write ( dspi -> regmap , SPI_SR , spi_sr ) ; if ( spi_sr & ( SPI_SR_EOQF | SPI_SR_TCFQF ) ) { tx_word = is_double_byte_mode ( dspi ) ; regmap_read ( dspi -> regmap , SPI_TCR , & spi_tcr ) ; spi_tcnt = SPI_TCR_GET_TCNT ( spi_tcr ) ; tcnt_diff = ( ( spi_tcnt + SPI_TCR_TCNT_MAX ) - dspi -> spi_tcnt ) % SPI_TCR_TCNT_MAX ; tcnt_diff *= ( tx_word + 1 ) ; if ( dspi -> dataflags & TRAN_STATE_WORD_ODD_NUM ) { tcnt_diff -- ; } msg -> actual_length += tcnt_diff ; dspi -> spi_tcnt = spi_tcnt ; trans_mode = dspi -> devtype_data -> trans_mode ; switch ( trans_mode ) { case DSPI_EOQ_MODE : dspi_eoq_read ( dspi ) ; break ; case DSPI_TCFQ_MODE : dspi_tcfq_read ( dspi ) ; break ; default : dev_err ( & dspi -> pdev -> dev , "unsupported trans_mode %u\n" , trans_mode ) ; return IRQ_HANDLED ; } if ( ! dspi -> len ) { dspi -> waitflags = 1 ; wake_up_interruptible ( & dspi -> waitq ) ; } else { switch ( trans_mode ) { case DSPI_EOQ_MODE : dspi_eoq_write ( dspi ) ; break ; case DSPI_TCFQ_MODE : dspi_tcfq_write ( dspi ) ; break ; default : dev_err ( & dspi -> pdev -> dev , "unsupported trans_mode %u\n" , trans_mode ) ; } } } return IRQ_HANDLED ; } 