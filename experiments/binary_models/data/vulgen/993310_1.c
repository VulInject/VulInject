void print_rtmsg ( struct rt_msghdr * rtm , int msglen ) { long long relative_expire ; struct if_msghdr * ifm ; struct ifa_msghdr * ifam ; struct if_announcemsghdr * ifan ; char ifname [ IF_NAMESIZE ] ; if ( verbose == 0 ) { return ; } if ( rtm -> rtm_version != RTM_VERSION ) { warnx ( "routing message version %u not understood" , rtm -> rtm_version ) ; return ; } if ( rtm -> rtm_type > 0 && rtm -> rtm_type < sizeof ( msgtypes ) / sizeof ( msgtypes [ 0 ] ) ) { printf ( "%s" , msgtypes [ rtm -> rtm_type ] ) ; } else { printf ( "[rtm_type %u out of range]" , rtm -> rtm_type ) ; } printf ( ": len %u" , rtm -> rtm_msglen ) ; switch ( rtm -> rtm_type ) { case RTM_DESYNC : printf ( "\n" ) ; break ; case RTM_IFINFO : ifm = ( if_msghdr * ) rtm ; printf ( ", if# %u, " , ifm -> ifm_index ) ; if ( if_indextoname ( ifm -> ifm_index , ifname ) != NULL ) { printf ( "name %s, " , ifname ) ; } printf ( "link: %s, mtu: %u, flags:" , get_linkstate ( ifm -> ifm_data . ifi_type , ifm -> ifm_data . ifi_link_state ) , ifm -> ifm_data . ifi_mtu ) ; pmsg_addrs ( ( char * ) ifm + ifm -> ifm_hdrlen , ifm -> ifm_addrs ) ; break ; case RTM_80211INFO : printf ( ", if# %u, " , rtm -> rtm_index ) ; if ( if_indextoname ( rtm -> rtm_index , ifname ) != NULL ) { printf ( "name %s, " , ifname ) ; } print_80211info ( ( if_ieee80211_msghdr * ) rtm ) ; break ; case RTM_NEWADDR : case RTM_DELADDR : case RTM_CHGADDRATTR : ifam = ( ifa_msghdr * ) rtm ; printf ( ", if# %u, " , ifam -> ifam_index ) ; if ( if_indextoname ( ifam -> ifam_index , ifname ) != NULL ) { printf ( "name %s, " , ifname ) ; } printf ( "metric %d, flags:" , ifam -> ifam_metric ) ; bprintf ( stdout , ifam -> ifam_flags , routeflags ) ; pmsg_addrs ( ( char * ) ifam + ifam -> ifam_hdrlen , ifam -> ifam_addrs ) ; break ; case RTM_IFANNOUNCE : ifan = ( if_announcemsghdr * ) rtm ; printf ( ", if# %u, name %s, what: " , ifan -> ifan_index , ifan -> ifan_name ) ; switch ( ifan -> ifan_what ) { case IFAN_ARRIVAL : printf ( "arrival" ) ; break ; case IFAN_DEPARTURE : printf ( "departure" ) ; break ; default : printf ( "#%u" , ifan -> ifan_what ) ; break ; } printf ( "\n" ) ; break ; case RTM_BFD : print_bfdmsg ( rtm ) ; break ; case RTM_PROPOSAL : printf ( ", source " ) ; switch ( rtm -> rtm_priority ) { case RTP_PROPOSAL_STATIC : printf ( "static" ) ; break ; case RTP_PROPOSAL_DHCLIENT : printf ( "dhcp" ) ; break ; case RTP_PROPOSAL_SLAAC : printf ( "slaac" ) ; break ; case RTP_PROPOSAL_UMB : printf ( "umb" ) ; break ; case RTP_PROPOSAL_PPP : printf ( "ppp" ) ; break ; case RTP_PROPOSAL_SOLICIT : printf ( "solicit" ) ; break ; default : printf ( "unknown" ) ; break ; } printf ( ", table %u, if# %u, " , rtm -> rtm_tableid , rtm -> rtm_index ) ; if ( if_indextoname ( rtm -> rtm_index , ifname ) != NULL ) { printf ( "name %s, " , ifname ) ; } printf ( "pid: %ld, seq %d, errno %d\nflags:" , ( long ) rtm -> rtm_pid , rtm -> rtm_seq , rtm -> rtm_errno ) ; bprintf ( stdout , rtm -> rtm_flags , routeflags ) ; printf ( "\nfmask:" ) ; bprintf ( stdout , rtm -> rtm_fmask , routeflags ) ; if ( verbose ) { relative_expire = rtm -> rtm_rmx . rmx_expire ?rtm -> rtm_rmx . rmx_expire - time ( NULL ) : 0 ; printf ( "\nuse: %8llu   mtu: %8u%c   expire: %8lld%c" , rtm -> rtm_rmx . rmx_pksent , rtm -> rtm_rmx . rmx_mtu , lock ( MTU ) , relative_expire , lock ( EXPIRE ) ) ; } printf ( "\nlocks: " ) ; bprintf ( stdout , rtm -> rtm_rmx . rmx_locks , metricnames ) ; printf ( " inits: " ) ; bprintf ( stdout , rtm -> rtm_inits , metricnames ) ; pmsg_addrs ( ( ( char * ) rtm + rtm -> rtm_hdrlen ) , rtm -> rtm_addrs & ~ ( RTA_STATIC | RTA_SEARCH | RTA_DNS ) ) ; if ( ! ( rtm -> rtm_addrs & ( RTA_STATIC | RTA_SEARCH | RTA_DNS ) ) ) { break ; } printf ( "proposals: " ) ; bprintf ( stdout , rtm -> rtm_addrs & ( RTA_STATIC | RTA_SEARCH | RTA_DNS ) , addrnames ) ; putchar ( '\n' ) ; if ( rtm -> rtm_addrs & RTA_STATIC ) { char * next = ( char * ) rtm + rtm -> rtm_hdrlen ; struct sockaddr * sa , * rti_info [ RTAX_MAX ] ; struct sockaddr_rtstatic * rtstatic ; sa = ( sockaddr * ) next ; get_rtaddrs ( rtm -> rtm_addrs , sa , rti_info ) ; rtstatic = ( sockaddr_rtstatic * ) rti_info [ RTAX_STATIC ] ; if ( rtstatic != NULL ) { print_rtstatic ( rtstatic ) ; } } if ( rtm -> rtm_addrs & RTA_SEARCH ) { char * next = ( char * ) rtm + rtm -> rtm_hdrlen ; struct sockaddr * sa , * rti_info [ RTAX_MAX ] ; struct sockaddr_rtsearch * rtsearch ; sa = ( sockaddr * ) next ; get_rtaddrs ( rtm -> rtm_addrs , sa , rti_info ) ; rtsearch = ( sockaddr_rtsearch * ) rti_info [ RTAX_SEARCH ] ; if ( rtsearch != NULL ) { print_rtsearch ( rtsearch ) ; } } if ( rtm -> rtm_addrs & RTA_DNS ) { char * next = ( char * ) rtm + rtm -> rtm_hdrlen ; struct sockaddr * sa , * rti_info [ RTAX_MAX ] ; struct sockaddr_rtdns * rtdns ; sa = ( sockaddr * ) next ; get_rtaddrs ( rtm -> rtm_addrs , sa , rti_info ) ; rtdns = ( sockaddr_rtdns * ) rti_info [ RTAX_DNS ] ; if ( rtdns != NULL ) { print_rtdns ( rtdns ) ; } } putchar ( '\n' ) ; break ; default : printf ( ", priority %u, table %u, if# %u, " , rtm -> rtm_priority , rtm -> rtm_tableid , rtm -> rtm_index ) ; if ( if_indextoname ( rtm -> rtm_index , ifname ) != NULL ) { printf ( "name %s, " , ifname ) ; } printf ( "pid: %ld, seq %d, errno %d\nflags:" , ( long ) rtm -> rtm_pid , rtm -> rtm_seq , rtm -> rtm_errno ) ; bprintf ( stdout , rtm -> rtm_flags , routeflags ) ; printf ( "\nfmask:" ) ; bprintf ( stdout , rtm -> rtm_fmask , routeflags ) ; if ( verbose ) { relative_expire = rtm -> rtm_rmx . rmx_expire ?rtm -> rtm_rmx . rmx_expire - time ( NULL ) : 0 ; printf ( "\nuse: %8llu   mtu: %8u%c   expire: %8lld%c" , rtm -> rtm_rmx . rmx_pksent , rtm -> rtm_rmx . rmx_mtu , lock ( MTU ) , relative_expire , lock ( EXPIRE ) ) ; } pmsg_common ( rtm ) ; } } 