struct zs_pool * zs_create_pool ( const char * name ) { int i ; struct zs_pool * pool ; struct size_class * prev_class = NULL ; pool = kzalloc ( sizeof ( * pool ) , GFP_KERNEL ) ; if ( ! pool ) { return NULL ; } init_deferred_free ( pool ) ; spin_lock_init ( & pool -> lock ) ; pool -> name = kstrdup ( name , GFP_KERNEL ) ; if ( ! pool -> name ) { err } if ( create_cache ( pool ) ) { err } for ( i = ZS_SIZE_CLASSES - 1 ; i >= 0 ; i -- ) { int size ; int pages_per_zspage ; int objs_per_zspage ; struct size_class * class ; int fullness = 0 ; size = ZS_MIN_ALLOC_SIZE + i * ZS_SIZE_CLASS_DELTA ; pages_per_zspage = calculate_zspage_chain_size ( size ) ; objs_per_zspage = pages_per_zspage * PAGE_SIZE / size ; if ( pages_per_zspage != 1 && objs_per_zspage != 1 && ! huge_class_size ) { huge_class_size = size ; huge_class_size -= ( ZS_HANDLE_SIZE - 1 ) ; } if ( prev_class ) { if ( can_merge ( prev_class , pages_per_zspage , objs_per_zspage ) ) { pool -> size_class [ i ] = prev_class ; continue ; } } class = kzalloc ( sizeof ( size_class ) , GFP_KERNEL ) ; if ( ! class ) { err } class -> size = size ; class -> index = i ; class -> pages_per_zspage = pages_per_zspage ; class -> objs_per_zspage = objs_per_zspage ; pool -> size_class [ i ] = class ; for ( fullness = ZS_EMPTY ; fullness < NR_ZS_FULLNESS ; fullness ++ ) { INIT_LIST_HEAD ( & class -> fullness_list [ fullness ] ) ; } prev_class = class ; } zs_pool_stat_create ( pool , name ) ; zs_register_shrinker ( pool ) ; INIT_LIST_HEAD ( & pool -> lru ) ; return pool ; err zs_destroy_pool ( pool ) ; return NULL ; } 