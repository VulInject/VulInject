int memlist ( uintptr_t addr , uint_t flags , int argc , const mdb_arg_t * argv ) { struct memlist ml ; if ( ! ( flags & DCMD_ADDRSPEC ) ) { uintptr_t ptr ; uint_t list ; int i ; static const char * lists [ ] { "phys_install" "phys_avail" "virt_avail" } ; ; if ( mdb_getopts ( argc , argv , 'i' , MDB_OPT_SETBITS , ( 1 << 0 ) , & list , 'a' , MDB_OPT_SETBITS , ( 1 << 1 ) , & list , 'v' , MDB_OPT_SETBITS , ( 1 << 2 ) , & list , NULL ) != argc ) { return ( DCMD_USAGE ) ; } if ( ! list ) { list = 1 ; } for ( i = 0 ; list ; i ++ , list >>= 1 ) { if ( ! ( list & 1 ) ) { continue ; } if ( ( mdb_readvar ( & ptr , lists [ i ] ) == - 1 ) || ( ptr == 0 ) ) { mdb_warn ( "%s not found or invalid" , lists [ i ] ) ; return ( DCMD_ERR ) ; } mdb_printf ( "%s:\n" , lists [ i ] ) ; if ( mdb_pwalk_dcmd ( "memlist" , "memlist" , 0 , NULL , ptr ) == - 1 ) { mdb_warn ( "can't walk memlist" ) ; return ( DCMD_ERR ) ; } } return ( DCMD_OK ) ; } if ( DCMD_HDRSPEC ( flags ) ) { mdb_printf ( "%<u>%?s %16s %16s%</u>\n" , "ADDR" , "BASE" , "SIZE" ) ; } if ( mdb_vread ( & ml , sizeof ( memlist ) , addr ) == - 1 ) { mdb_warn ( "can't read memlist at %#lx" , addr ) ; return ( DCMD_ERR ) ; } mdb_printf ( "%0?lx %16llx %16llx\n" , addr , ml . ml_address , ml . ml_size ) ; return ( DCMD_OK ) ; } 