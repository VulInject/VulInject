void * relay_dns_validate ( struct rsession * con , struct relay * rlay , struct sockaddr_storage * ss , u_int8_t * buf , size_t len ) { struct relay_dnshdr * hdr = ( relay_dnshdr * ) buf ; struct rsession lookup ; u_int16_t key ; struct relay_dns_priv * priv , lpriv ; key = ntohs ( hdr -> dns_id ) ; if ( ( hdr -> dns_flags0 & DNS_F0_QR ) == 0 ) { priv = malloc ( sizeof ( relay_dns_priv ) ) ; if ( priv == NULL ) { return ( NULL ) ; } priv -> dp_inkey = shuffle_generate16 ( & relay_shuffle ) ; priv -> dp_outkey = key ; return ( ( void * ) priv ) ; } if ( con == NULL ) { lpriv . dp_inkey = key ; lookup . se_priv = & lpriv ; if ( ( con = SPLAY_FIND ( session_tree , & rlay -> rl_sessions , & lookup ) ) != NULL && con -> se_priv != NULL && relay_cmp_af ( ss , & con -> se_out . ss ) == 0 ) { relay_dns_result ( con , buf , len ) ; } } else { priv = con -> se_priv ; if ( priv == NULL || key != priv -> dp_inkey ) { relay_close ( con , "invalid response" , 1 ) ; return ( NULL ) ; } relay_dns_result ( con , buf , len ) ; } return ( NULL ) ; } 