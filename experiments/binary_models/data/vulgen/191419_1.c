static taskq_ent_t * task_alloc ( taskq_t * tq , int tqflags ) { taskq_ent_t * t ; int rv ; again if ( ( t = tq -> tq_freelist ) != NULL && tq -> tq_nalloc >= tq -> tq_minalloc ) { ASSERT ( ! ( t -> tqent_flags & TQENT_FLAG_PREALLOC ) ) ; tq -> tq_freelist = t -> tqent_next ; } else { if ( tq -> tq_nalloc >= tq -> tq_maxalloc ) { if ( ! ( tqflags & KM_SLEEP ) ) { return ( NULL ) ; } tq -> tq_maxalloc_wait ++ ; rv = cv_timedwait ( & tq -> tq_maxalloc_cv , & tq -> tq_lock , ddi_get_lbolt ( ) + hz ) ; tq -> tq_maxalloc_wait -- ; if ( rv > 0 ) { again } } mutex_exit ( & tq -> tq_lock ) ; t = kmem_alloc ( sizeof ( taskq_ent_t ) , tqflags ) ; mutex_enter ( & tq -> tq_lock ) ; if ( t != NULL ) { tq -> tq_nalloc ++ ; } } return ( t ) ; } 