struct drm_connector * nouveau_connector_create ( struct drm_device * dev , const struct dcb_output * dcbe ) { const struct drm_connector_funcs * funcs = & nouveau_connector_funcs ; struct nouveau_drm * drm = nouveau_drm ( dev ) ; struct nouveau_display * disp = nouveau_display ( dev ) ; struct nouveau_connector * nv_connector = NULL ; struct drm_connector * connector ; struct drm_connector_list_iter conn_iter ; char aux_name [ 48 ] { 0 } ; ; int index = dcbe -> connector ; int type , ret = 0 ; bool dummy ; drm_connector_list_iter_begin ( dev , & conn_iter ) ; nouveau_for_each_non_mst_connector_iter ( , ) { nv_connector = nouveau_connector ( connector ) ; if ( nv_connector -> index == index ) { drm_connector_list_iter_end ( & conn_iter ) ; return connector ; } } drm_connector_list_iter_end ( & conn_iter ) ; nv_connector = kzalloc ( sizeof ( * nv_connector ) , GFP_KERNEL ) ; connector = & nv_connector -> base ; nv_connector -> index = index ; INIT_WORK ( & nv_connector -> irq_work , nouveau_dp_irq ) ; nv_connector -> dcb = olddcb_conn ( dev , index ) ; if ( nv_connector -> dcb ) { u32 entry = ROM16 ( nv_connector -> dcb [ 0 ] ) ; if ( olddcb_conntab ( dev ) [ 3 ] >= 4 ) { entry |= ( u32 ) ROM16 ( nv_connector -> dcb [ 2 ] ) << 16 ; } nv_connector -> type = nv_connector -> dcb [ 0 ] ; if ( drm_conntype_from_dcb ( nv_connector -> type ) == DRM_MODE_CONNECTOR_Unknown ) { NV_WARN ( drm , "unknown connector type %02x\n" , nv_connector -> type ) ; nv_connector -> type = DCB_CONNECTOR_NONE ; } if ( nv_match_device ( dev , 0x0421 , 0x1458 , 0x344c ) ) { if ( nv_connector -> type == DCB_CONNECTOR_HDMI_1 ) { nv_connector -> type = DCB_CONNECTOR_DVI_I ; } } if ( nv_match_device ( dev , 0x0402 , 0x1458 , 0x3455 ) ) { if ( nv_connector -> type == DCB_CONNECTOR_HDMI_1 ) { nv_connector -> type = DCB_CONNECTOR_DVI_I ; } } } else { nv_connector -> type = DCB_CONNECTOR_NONE ; } if ( nv_connector -> type == DCB_CONNECTOR_NONE ) { struct nouveau_drm * drm = nouveau_drm ( dev ) ; struct dcb_table * dcbt = & drm -> vbios . dcb ; u32 encoders = 0 ; int i ; for ( i = 0 ; i < dcbt -> entries ; i ++ ) { if ( dcbt -> entry [ i ] . connector == nv_connector -> index ) { encoders |= ( 1 << dcbt -> entry [ i ] . type ) ; } } if ( encoders & ( 1 << DCB_OUTPUT_DP ) ) { if ( encoders & ( 1 << DCB_OUTPUT_TMDS ) ) { nv_connector -> type = DCB_CONNECTOR_DP ; } else { nv_connector -> type = DCB_CONNECTOR_eDP ; } } if ( encoders & ( 1 << DCB_OUTPUT_TMDS ) ) { if ( encoders & ( 1 << DCB_OUTPUT_ANALOG ) ) { nv_connector -> type = DCB_CONNECTOR_DVI_I ; } else { nv_connector -> type = DCB_CONNECTOR_DVI_D ; } } if ( encoders & ( 1 << DCB_OUTPUT_ANALOG ) ) { nv_connector -> type = DCB_CONNECTOR_VGA ; } if ( encoders & ( 1 << DCB_OUTPUT_LVDS ) ) { nv_connector -> type = DCB_CONNECTOR_LVDS ; } if ( encoders & ( 1 << DCB_OUTPUT_TV ) ) { nv_connector -> type = DCB_CONNECTOR_TV_0 ; } } switch ( ( type = drm_conntype_from_dcb ( nv_connector -> type ) ) ) { case DRM_MODE_CONNECTOR_LVDS : ret = nouveau_bios_parse_lvds_table ( dev , 0 , & dummy , & dummy ) ; if ( ret ) { NV_ERROR ( drm , "Error parsing LVDS table, disabling\n" ) ; kfree ( nv_connector ) ; return ERR_PTR ( ret ) ; } funcs = & nouveau_connector_funcs_lvds ; break ; case DRM_MODE_CONNECTOR_DisplayPort : case DRM_MODE_CONNECTOR_eDP : nv_connector -> aux . dev = connector -> kdev ; nv_connector -> aux . drm_dev = dev ; nv_connector -> aux . transfer = nouveau_connector_aux_xfer ; snprintf ( aux_name , sizeof ( aux_name ) , "sor-%04x-%04x" , dcbe -> hasht , dcbe -> hashm ) ; nv_connector -> aux . name = kstrdup ( aux_name , GFP_KERNEL ) ; if ( ! nv_connector -> aux . name ) { kfree ( nv_connector ) ; return ERR_PTR ( - ENOMEM ) ; } drm_dp_aux_init ( & nv_connector -> aux ) ; break ; default : funcs = & nouveau_connector_funcs ; break ; } if ( ( disp -> disp . object . oclass >= G82_DISP ) && ( ( type == DRM_MODE_CONNECTOR_DisplayPort ) || ( type == DRM_MODE_CONNECTOR_eDP ) || ( type == DRM_MODE_CONNECTOR_HDMIA ) ) ) { connector -> stereo_allowed = true ; } connector -> interlace_allowed = false ; connector -> doublescan_allowed = false ; drm_connector_init ( dev , connector , funcs , type ) ; drm_connector_helper_add ( connector , & nouveau_connector_helper_funcs ) ; connector -> polled = DRM_CONNECTOR_POLL_CONNECT ; if ( nv_connector -> dcb && ( disp -> disp . conn_mask & BIT ( nv_connector -> index ) ) ) { ret = nvif_conn_ctor ( & disp -> disp , nv_connector -> base . name , nv_connector -> index , & nv_connector -> conn ) ; if ( ret ) { kfree ( nv_connector ) ; return ERR_PTR ( ret ) ; } ret = nvif_conn_event_ctor ( & nv_connector -> conn , "kmsHotplug" , nouveau_connector_hotplug , NVIF_CONN_EVENT_V0_PLUG | NVIF_CONN_EVENT_V0_UNPLUG , & nv_connector -> hpd ) ; if ( ret == 0 ) { connector -> polled = DRM_CONNECTOR_POLL_HPD ; } if ( nv_connector -> aux . transfer ) { ret = nvif_conn_event_ctor ( & nv_connector -> conn , "kmsDpIrq" , nouveau_connector_irq , NVIF_CONN_EVENT_V0_IRQ , & nv_connector -> irq ) ; if ( ret ) { nvif_event_dtor ( & nv_connector -> hpd ) ; nvif_conn_dtor ( & nv_connector -> conn ) ; kfree ( nv_connector ) ; return ERR_PTR ( ret ) ; } } } connector -> funcs -> reset ( connector ) ; nouveau_conn_attach_properties ( connector ) ; switch ( nv_connector -> type ) { case DCB_CONNECTOR_LVDS : case DCB_CONNECTOR_LVDS_SPWG : case DCB_CONNECTOR_eDP : if ( disp -> disp . object . oclass < NV50_DISP ) { nv_connector -> scaling_mode = DRM_MODE_SCALE_FULLSCREEN ; break ; } nv_connector -> scaling_mode = DRM_MODE_SCALE_NONE ; break ; default : nv_connector -> scaling_mode = DRM_MODE_SCALE_NONE ; break ; } switch ( nv_connector -> type ) { case DCB_CONNECTOR_TV_0 : case DCB_CONNECTOR_TV_1 : case DCB_CONNECTOR_TV_3 : case DCB_CONNECTOR_VGA : break ; default : nv_connector -> dithering_mode = DITHERING_MODE_AUTO ; break ; } switch ( type ) { case DRM_MODE_CONNECTOR_DisplayPort : nv_connector -> dp_encoder = find_encoder ( & nv_connector -> base , DCB_OUTPUT_DP ) ; fallthrough ; case DRM_MODE_CONNECTOR_eDP : drm_dp_cec_register_connector ( & nv_connector -> aux , connector ) ; break ; } drm_connector_register ( connector ) ; return connector ; } 