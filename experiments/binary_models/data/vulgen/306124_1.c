void eigrp_send_siaquery ( struct eigrp_neighbor * nbr , struct eigrp_prefix_descriptor * pe ) { struct eigrp_packet * ep ; uint16_t length = EIGRP_HEADER_LEN ; ep = eigrp_packet_new ( EIGRP_PACKET_MTU ( nbr -> ei -> ifp -> mtu ) , nbr ) ; eigrp_packet_header_init ( EIGRP_OPC_SIAQUERY , nbr -> ei -> eigrp , ep -> s , 0 , nbr -> ei -> eigrp -> sequence_number , 0 ) ; if ( ( nbr -> ei -> params . auth_type == EIGRP_AUTH_TYPE_MD5 ) && ( nbr -> ei -> params . auth_keychain != NULL ) ) { length += eigrp_add_authTLV_MD5_to_stream ( ep -> s , nbr -> ei ) ; } length += eigrp_add_internalTLV_to_stream ( ep -> s , pe ) ; if ( ( nbr -> ei -> params . auth_type == EIGRP_AUTH_TYPE_MD5 ) && ( nbr -> ei -> params . auth_keychain != NULL ) ) { eigrp_make_md5_digest ( nbr -> ei , ep -> s , EIGRP_AUTH_UPDATE_FLAG ) ; } eigrp_packet_checksum ( nbr -> ei , ep -> s , length ) ; ep -> dst . s_addr = nbr -> src . s_addr ; ep -> sequence_number = nbr -> ei -> eigrp -> sequence_number ; if ( nbr -> state == EIGRP_NEIGHBOR_UP ) { eigrp_fifo_push ( nbr -> retrans_queue , ep ) ; if ( nbr -> retrans_queue -> count == 1 ) { eigrp_send_packet_reliably ( nbr ) ; } } else { eigrp_packet_free ( ep ) ; } } 