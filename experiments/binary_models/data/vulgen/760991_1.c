static struct samsung_keypad_platdata * samsung_keypad_parse_dt ( struct device * dev ) { struct samsung_keypad_platdata * pdata ; struct matrix_keymap_data * keymap_data ; uint32_t * keymap , num_rows = 0 , num_cols = 0 ; struct device_node * np = dev -> of_node , * key_np ; unsigned int key_count ; if ( ! np ) { dev_err ( dev , "missing device tree data\n" ) ; return ERR_PTR ( - EINVAL ) ; } pdata = devm_kzalloc ( dev , sizeof ( * pdata ) , GFP_KERNEL ) ; if ( ! pdata ) { dev_err ( dev , "could not allocate memory for platform data\n" ) ; return ERR_PTR ( - ENOMEM ) ; } of_property_read_u32 ( np , "samsung,keypad-num-rows" , & num_rows ) ; of_property_read_u32 ( np , "samsung,keypad-num-columns" , & num_cols ) ; if ( ! num_rows || ! num_cols ) { dev_err ( dev , "number of keypad rows/columns not specified\n" ) ; return ERR_PTR ( - EINVAL ) ; } pdata -> rows = num_rows ; pdata -> cols = num_cols ; keymap_data = devm_kzalloc ( dev , sizeof ( * keymap_data ) , GFP_KERNEL ) ; if ( ! keymap_data ) { dev_err ( dev , "could not allocate memory for keymap data\n" ) ; return ERR_PTR ( - ENOMEM ) ; } pdata -> keymap_data = keymap_data ; key_count = of_get_child_count ( np ) ; keymap_data -> keymap_size = key_count ; if ( ! keymap ) { dev_err ( dev , "could not allocate memory for keymap\n" ) ; return ERR_PTR ( - ENOMEM ) ; } keymap_data -> keymap = keymap ; for_each_child_of_node ( , ) { u32 row , col , key_code ; of_property_read_u32 ( key_np , "keypad,row" , & row ) ; of_property_read_u32 ( key_np , "keypad,column" , & col ) ; of_property_read_u32 ( key_np , "linux,code" , & key_code ) ; * keymap ++ = KEY ( row , col , key_code ) ; } if ( of_get_property ( np , "linux,input-no-autorepeat" , NULL ) ) { pdata -> no_autorepeat = true ; } pdata -> wakeup = of_property_read_bool ( np , "wakeup-source" ) || of_property_read_bool ( np , "linux,input-wakeup" ) ; return pdata ; } 