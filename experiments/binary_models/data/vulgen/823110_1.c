static int dissect_p_mul ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) { proto_tree * p_mul_tree , * field_tree , * checksum_tree ; proto_item * ti , * en , * len_en ; gboolean save_fragmented ; guint32 message_id = 0 ; guint16 no_dest = 0 , count = 0 , len , data_len = 0 ; guint16 checksum_calc , checksum_found ; guint16 pdu_length , no_pdus = 0 , seq_no = 0 ; guint8 pdu_type , * value , map = 0 , fec_len ; gint i , tot_no_missing = 0 , no_missing = 0 , offset = 0 ; address src , dst ; wmem_strbuf_t * message_id_list = NULL ; gboolean fletcher = FALSE ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , "P_MUL" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; pdu_type = tvb_get_guint8 ( tvb , offset + 3 ) & 0x3F ; ti = proto_tree_add_item ( tree , proto_p_mul , tvb , offset , - 1 , ENC_NA ) ; proto_item_append_text ( ti , ", %s" , get_type ( pdu_type ) ) ; p_mul_tree = proto_item_add_subtree ( ti , ett_p_mul ) ; pdu_length = tvb_get_ntohs ( tvb , offset ) ; len_en = proto_tree_add_item ( p_mul_tree , hf_length , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; offset += 2 ; switch ( pdu_type ) { case Data_PDU : case Ack_PDU : case Address_PDU : case Discard_Message_PDU : case Extra_Address_PDU : case FEC_Address_PDU : case Extra_FEC_Address_PDU : proto_tree_add_item ( p_mul_tree , hf_priority , tvb , offset , 1 , ENC_BIG_ENDIAN ) ; break ; default : proto_tree_add_item ( p_mul_tree , hf_unused8 , tvb , offset , 1 , ENC_BIG_ENDIAN ) ; } offset += 1 ; en = proto_tree_add_uint_format ( p_mul_tree , hf_pdu_type , tvb , offset , 1 , pdu_type , "PDU Type: %s (0x%02x)" , get_type ( pdu_type ) , pdu_type ) ; field_tree = proto_item_add_subtree ( en , ett_pdu_type ) ; if ( pdu_type == Discard_Message_PDU ) { expert_add_info ( pinfo , en , & ei_message_discarded ) ; } switch ( pdu_type ) { case Address_PDU : case Announce_PDU : case Extra_Address_PDU : case FEC_Address_PDU : case Extra_FEC_Address_PDU : map = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_item ( field_tree , hf_map_first , tvb , offset , 1 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( field_tree , hf_map_last , tvb , offset , 1 , ENC_BIG_ENDIAN ) ; if ( ( map & 0x80 ) || ( map & 0x40 ) ) { proto_item_append_text ( en , ", %s / %s" , ( map & 0x80 ) ?"Not first" : "First" , ( map & 0x40 ) ?"Not last" : "Last" ) ; } else { proto_item_append_text ( en , ", Only one PDU" ) ; } break ; default : proto_tree_add_item ( field_tree , hf_map_unused , tvb , offset , 1 , ENC_BIG_ENDIAN ) ; break ; } proto_tree_add_item ( field_tree , hf_pdu_type_value , tvb , offset , 1 , ENC_BIG_ENDIAN ) ; offset += 1 ; switch ( pdu_type ) { case Address_PDU : case Extra_Address_PDU : case FEC_Address_PDU : case Extra_FEC_Address_PDU : no_pdus = tvb_get_ntohs ( tvb , offset ) ; seq_no = 0 ; proto_tree_add_item ( p_mul_tree , hf_no_pdus , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; proto_item_append_text ( ti , ", No PDUs: %u" , no_pdus ) ; break ; case Data_PDU : seq_no = tvb_get_ntohs ( tvb , offset ) ; en = proto_tree_add_item ( p_mul_tree , hf_seq_no , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; if ( seq_no == 0 ) { expert_add_info ( pinfo , en , & ei_illegal_seq_no ) ; } proto_item_append_text ( ti , ", Seq no: %u" , seq_no ) ; break ; case Announce_PDU : count = tvb_get_ntohs ( tvb , offset ) ; proto_tree_add_item ( p_mul_tree , hf_count_of_dest , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; break ; default : proto_tree_add_item ( p_mul_tree , hf_unused16 , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; break ; } offset += 2 ; en = proto_tree_add_item ( p_mul_tree , hf_checksum , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; checksum_tree = proto_item_add_subtree ( en , ett_checksum ) ; len = tvb_captured_length ( tvb ) ; value = ( guint8 * ) tvb_memdup ( pinfo -> pool , tvb , 0 , len ) ; if ( len >= offset + 2 ) { value [ offset ] = 0 ; value [ offset + 1 ] = 0 ; } checksum_found = tvb_get_ntohs ( tvb , offset ) ; checksum_calc = g_ntohs ( ip_checksum ( value , len ) ) ; if ( checksum_calc != checksum_found ) { guint16 checksum1 = checksum_acp142 ( value , len , offset ) ; if ( checksum1 == checksum_found ) { checksum_calc = checksum1 ; fletcher = TRUE ; } } if ( checksum_calc == checksum_found ) { if ( fletcher ) { proto_item_append_text ( en , " [Fletcher algorithm]" ) ; } proto_item_append_text ( en , " (correct)" ) ; en = proto_tree_add_boolean ( checksum_tree , hf_checksum_good , tvb , offset , 2 , TRUE ) ; proto_item_set_generated ( en ) ; en = proto_tree_add_boolean ( checksum_tree , hf_checksum_bad , tvb , offset , 2 , FALSE ) ; proto_item_set_generated ( en ) ; } else { proto_item_append_text ( en , " (incorrect, should be 0x%04x)" , checksum_calc ) ; expert_add_info ( pinfo , en , & ei_checksum_bad ) ; en = proto_tree_add_boolean ( checksum_tree , hf_checksum_good , tvb , offset , 2 , FALSE ) ; proto_item_set_generated ( en ) ; en = proto_tree_add_boolean ( checksum_tree , hf_checksum_bad , tvb , offset , 2 , TRUE ) ; proto_item_set_generated ( en ) ; } offset += 2 ; if ( pdu_type == Ack_PDU ) { set_address_tvb ( & dst , AT_IPv4 , 4 , tvb , offset ) ; proto_tree_add_item ( p_mul_tree , hf_source_id_ack , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; count = tvb_get_ntohs ( tvb , offset ) ; proto_tree_add_item ( p_mul_tree , hf_ack_count , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; offset += 2 ; } else { set_address_tvb ( & src , AT_IPv4 , 4 , tvb , offset ) ; proto_tree_add_item ( p_mul_tree , hf_source_id , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; message_id = tvb_get_ntohl ( tvb , offset ) ; if ( use_relative_msgid ) { if ( message_id_offset == 0 ) { message_id_offset = message_id ; } message_id -= message_id_offset ; proto_tree_add_uint_format_value ( p_mul_tree , hf_message_id , tvb , offset , 4 , message_id , "%u    (relative message id)" , message_id ) ; } else { proto_tree_add_item ( p_mul_tree , hf_message_id , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; } offset += 4 ; proto_item_append_text ( ti , ", MSID: %u" , message_id ) ; } if ( pdu_type == Address_PDU || pdu_type == Announce_PDU || pdu_type == Extra_Address_PDU || pdu_type == FEC_Address_PDU || pdu_type == Extra_FEC_Address_PDU ) { proto_tree_add_item ( p_mul_tree , hf_expiry_time , tvb , offset , 4 , ENC_TIME_SECS | ENC_BIG_ENDIAN ) ; offset += 4 ; } if ( pdu_type == FEC_Address_PDU || pdu_type == Extra_FEC_Address_PDU ) { fec_len = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_item ( p_mul_tree , hf_fec_len , tvb , offset , 1 , ENC_BIG_ENDIAN ) ; offset += 1 ; proto_tree_add_item ( p_mul_tree , hf_fec_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ; offset += 1 ; if ( fec_len > 0 ) { proto_tree_add_none_format ( p_mul_tree , hf_fec_parameters , tvb , offset , fec_len , "FEC Parameters (%d byte%s)" , fec_len , plurality ( fec_len , "" , "s" ) ) ; offset += fec_len ; } } switch ( pdu_type ) { case Address_PDU : case Extra_Address_PDU : case FEC_Address_PDU : case Extra_FEC_Address_PDU : no_dest = tvb_get_ntohs ( tvb , offset ) ; proto_tree_add_item ( p_mul_tree , hf_count_of_dest , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; offset += 2 ; len = tvb_get_ntohs ( tvb , offset ) ; proto_tree_add_item ( p_mul_tree , hf_length_of_res , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; offset += 2 ; for ( i = 0 ; i < no_dest ; i ++ ) { en = proto_tree_add_none_format ( p_mul_tree , hf_dest_entry , tvb , offset , 8 + len , "Destination Entry #%d" , i + 1 ) ; field_tree = proto_item_add_subtree ( en , ett_dest_entry ) ; set_address_tvb ( & dst , AT_IPv4 , 4 , tvb , offset ) ; proto_tree_add_item ( field_tree , hf_dest_id , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( field_tree , hf_msg_seq_no , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; if ( len > 0 ) { proto_tree_add_none_format ( field_tree , hf_sym_key , tvb , offset , len , "Symmetric Key (%d byte%s)" , len , plurality ( len , "" , "s" ) ) ; offset += len ; } if ( use_seq_ack_analysis ) { add_ack_analysis ( tvb , pinfo , field_tree , offset , pdu_type , & src , & dst , message_id , 0 ) ; } } if ( no_dest == 0 && use_seq_ack_analysis ) { add_ack_analysis ( tvb , pinfo , p_mul_tree , offset , pdu_type , & src , NULL , message_id , 0 ) ; } proto_item_append_text ( ti , ", Count of Dest: %u" , no_dest ) ; break ; case Data_PDU : data_len = tvb_captured_length_remaining ( tvb , offset ) ; proto_tree_add_none_format ( p_mul_tree , hf_data_fragment , tvb , offset , data_len , "Fragment %d of Data (%d byte%s)" , seq_no , data_len , plurality ( data_len , "" , "s" ) ) ; break ; case Ack_PDU : message_id_list = wmem_strbuf_create ( pinfo -> pool ) ; for ( i = 0 ; i < count ; i ++ ) { len = tvb_get_ntohs ( tvb , offset ) ; en = proto_tree_add_none_format ( p_mul_tree , hf_ack_entry , tvb , offset , len , "Ack Info Entry #%d" , i + 1 ) ; field_tree = proto_item_add_subtree ( en , ett_ack_entry ) ; en = proto_tree_add_item ( field_tree , hf_ack_length , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; offset += 2 ; if ( len < 10 ) { proto_item_append_text ( en , "    (invalid length)" ) ; expert_add_info ( pinfo , en , & ei_ack_length ) ; } set_address_tvb ( & src , AT_IPv4 , 4 , tvb , offset ) ; proto_tree_add_item ( field_tree , hf_source_id , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; message_id = tvb_get_ntohl ( tvb , offset ) ; if ( use_relative_msgid ) { if ( message_id_offset == 0 ) { message_id_offset = message_id ; } message_id -= message_id_offset ; proto_tree_add_uint_format_value ( field_tree , hf_message_id , tvb , offset , 4 , message_id , "%u    (relative message id)" , message_id ) ; } else { proto_tree_add_item ( field_tree , hf_message_id , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; } offset += 4 ; if ( i == 0 ) { wmem_strbuf_append_printf ( message_id_list , "%u" , message_id ) ; } else { wmem_strbuf_append_printf ( message_id_list , ",%u" , message_id ) ; } if ( len > 10 ) { gint num_seq_no = ( len - 10 ) / 2 ; guint16 ack_seq_no , prev_ack_seq_no = 0 ; for ( no_missing = 0 ; no_missing < num_seq_no ; no_missing ++ ) { ack_seq_no = tvb_get_ntohs ( tvb , offset ) ; if ( ( ack_seq_no != 0 ) && ( no_missing < num_seq_no - 2 ) && tvb_get_ntohs ( tvb , offset + 2 ) == 0 ) { guint16 end_seq_no = tvb_get_ntohs ( tvb , offset + 4 ) ; en = proto_tree_add_bytes_format_value ( field_tree , hf_miss_seq_range , tvb , offset , 6 , NULL , "%d - %d" , ack_seq_no , end_seq_no ) ; if ( ack_seq_no >= end_seq_no ) { proto_item_append_text ( en , "    (invalid)" ) ; expert_add_info ( pinfo , en , & ei_miss_seq_range ) ; } else { proto_tree * missing_tree = proto_item_add_subtree ( en , ett_range_entry ) ; proto_tree_add_item ( missing_tree , hf_miss_seq_range_from , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( missing_tree , hf_miss_seq_range_delimiter , tvb , offset + 2 , 2 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( missing_tree , hf_miss_seq_range_to , tvb , offset + 4 , 2 , ENC_BIG_ENDIAN ) ; tot_no_missing += ( end_seq_no - ack_seq_no + 1 ) ; } offset += 6 ; no_missing += 2 ; prev_ack_seq_no = end_seq_no ; } else { en = proto_tree_add_item ( field_tree , hf_miss_seq_no , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; offset += 2 ; if ( ack_seq_no == 0 ) { proto_item_append_text ( en , "    (invalid)" ) ; expert_add_info ( pinfo , en , & ei_miss_seq_no ) ; } if ( ack_seq_no <= prev_ack_seq_no ) { proto_item_append_text ( en , "    (end of list indicator)" ) ; } else { tot_no_missing ++ ; } prev_ack_seq_no = ack_seq_no ; } } } if ( use_seq_ack_analysis ) { add_ack_analysis ( tvb , pinfo , field_tree , offset , pdu_type , & src , & dst , message_id , no_missing ) ; } } proto_item_append_text ( ti , ", Count of Ack: %u" , count ) ; if ( tvb_reported_length_remaining ( tvb , offset ) >= 8 ) { guint64 timestamp ; timestamp = tvb_get_ntoh64 ( tvb , offset ) ; proto_tree_add_uint64_format_value ( p_mul_tree , hf_timestamp_option , tvb , offset , 8 , timestamp , "%" PRId64 ".%d second%s (%" PRIu64 ")" , timestamp / 10 , ( int ) timestamp % 10 , ( timestamp == 10 ) ?"" : "s" , timestamp ) ; offset += 8 ; } if ( tot_no_missing ) { proto_item_append_text ( ti , ", Missing seq numbers: %u" , tot_no_missing ) ; en = proto_tree_add_uint ( p_mul_tree , hf_tot_miss_seq_no , tvb , 0 , 0 , tot_no_missing ) ; proto_item_set_generated ( en ) ; expert_add_info_format ( pinfo , en , & ei_tot_miss_seq_no , "Missing seq numbers: %d" , tot_no_missing ) ; } break ; case Discard_Message_PDU : seq_no = G_MAXUINT16 ; break ; case Announce_PDU : proto_tree_add_item ( p_mul_tree , hf_ann_mc_group , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; for ( i = 0 ; i < count ; i ++ ) { proto_tree_add_item ( p_mul_tree , hf_dest_id , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; } break ; case Request_PDU : case Reject_PDU : case Release_PDU : proto_tree_add_item ( p_mul_tree , hf_mc_group , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; break ; default : break ; } if ( use_seq_ack_analysis && ( pdu_type <= Discard_Message_PDU ) && ( pdu_type != Ack_PDU ) && ( pdu_type != Address_PDU || no_dest != 0 ) ) { add_seq_analysis ( tvb , pinfo , p_mul_tree , & src , offset , pdu_type , message_id , seq_no , tot_no_missing ) ; } if ( pdu_type == Address_PDU && no_dest == 0 ) { col_append_str ( pinfo -> cinfo , COL_INFO , get_type ( Ack_Ack_PDU ) ) ; } else { col_append_str ( pinfo -> cinfo , COL_INFO , get_type ( pdu_type ) ) ; } if ( pdu_type == Address_PDU || pdu_type == Extra_Address_PDU || pdu_type == FEC_Address_PDU || pdu_type == Extra_FEC_Address_PDU ) { col_append_fstr ( pinfo -> cinfo , COL_INFO , ", No PDUs: %u" , no_pdus ) ; } if ( pdu_type == Data_PDU ) { col_append_fstr ( pinfo -> cinfo , COL_INFO , ", Seq no: %u" , seq_no ) ; } if ( pdu_type == Address_PDU || pdu_type == Extra_Address_PDU || pdu_type == FEC_Address_PDU || pdu_type == Extra_FEC_Address_PDU ) { } if ( pdu_type == Ack_PDU ) { if ( tot_no_missing ) { col_append_fstr ( pinfo -> cinfo , COL_INFO , ", Missing seq numbers: %u" , tot_no_missing ) ; } col_append_fstr ( pinfo -> cinfo , COL_INFO , ", Count of Ack: %u" , count ) ; } if ( pdu_type != Ack_PDU ) { col_append_fstr ( pinfo -> cinfo , COL_INFO , ", MSID: %u" , message_id ) ; } else { if ( message_id_list && wmem_strbuf_get_len ( message_id_list ) > 0 ) { col_append_fstr ( pinfo -> cinfo , COL_INFO , ", MSID: %s" , wmem_strbuf_get_str ( message_id_list ) ) ; } } if ( p_mul_reassemble ) { save_fragmented = pinfo -> fragmented ; if ( pdu_type == Address_PDU && no_pdus > 0 ) { fragment_start_seq_check ( & p_mul_reassembly_table , pinfo , message_id , NULL , no_pdus - 1 ) ; } if ( pdu_type == Data_PDU ) { fragment_head * frag_msg ; tvbuff_t * new_tvb ; pinfo -> fragmented = TRUE ; frag_msg = fragment_add_seq_check ( & p_mul_reassembly_table , tvb , offset , pinfo , message_id , NULL , seq_no - 1 , data_len , TRUE ) ; new_tvb = process_reassembled_data ( tvb , offset , pinfo , "Reassembled P_MUL" , frag_msg , & p_mul_frag_items , NULL , tree ) ; if ( frag_msg ) { col_append_str ( pinfo -> cinfo , COL_INFO , " (Message Reassembled)" ) ; } if ( new_tvb ) { dissect_reassembled_data ( new_tvb , pinfo , tree ) ; } } pinfo -> fragmented = save_fragmented ; } proto_item_set_len ( ti , offset ) ; if ( pdu_length != ( offset + data_len ) ) { proto_item_append_text ( len_en , " (incorrect, should be: %d)" , offset + data_len ) ; expert_add_info ( pinfo , len_en , & ei_length ) ; } if ( ( len = tvb_reported_length_remaining ( tvb , pdu_length ) ) > 0 ) { proto_item_append_text ( len_en , " (more data in packet: %d)" , len ) ; expert_add_info ( pinfo , len_en , & ei_more_data ) ; } return offset ; } 