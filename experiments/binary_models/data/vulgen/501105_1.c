find_reloads_address_1 ( , , , , , , , , , ) { ( ( CONTEXT ) == 0 ?regno_ok_for_base_p ( REGNO , MODE , OUTER , INDEX ) : REGNO_OK_FOR_INDEX_P ( REGNO ) ) reg_class context_reg_class ; RTX_CODE code = GET_CODE ( x ) ; if ( context == 1 ) { context_reg_class = INDEX_REG_CLASS ; } else { context_reg_class = base_reg_class ( mode , outer_code , index_code ) ; } switch ( code ) { case PLUS : { rtx orig_op0 = XEXP ( x , 0 ) ; rtx orig_op1 = XEXP ( x , 1 ) ; RTX_CODE code0 = GET_CODE ( orig_op0 ) ; RTX_CODE code1 = GET_CODE ( orig_op1 ) ; rtx op0 = orig_op0 ; rtx op1 = orig_op1 ; if ( GET_CODE ( op0 ) == SUBREG ) { op0 = SUBREG_REG ( op0 ) ; code0 = GET_CODE ( op0 ) ; if ( code0 == REG && REGNO ( op0 ) < FIRST_PSEUDO_REGISTER ) { op0 = gen_rtx_REG ( word_mode , ( REGNO ( op0 ) + subreg_regno_offset ( REGNO ( SUBREG_REG ( orig_op0 ) ) , GET_MODE ( SUBREG_REG ( orig_op0 ) ) , SUBREG_BYTE ( orig_op0 ) , GET_MODE ( orig_op0 ) ) ) ) ; } } if ( GET_CODE ( op1 ) == SUBREG ) { op1 = SUBREG_REG ( op1 ) ; code1 = GET_CODE ( op1 ) ; if ( code1 == REG && REGNO ( op1 ) < FIRST_PSEUDO_REGISTER ) { op1 = gen_rtx_REG ( GET_MODE ( op1 ) , ( REGNO ( op1 ) + subreg_regno_offset ( REGNO ( SUBREG_REG ( orig_op1 ) ) , GET_MODE ( SUBREG_REG ( orig_op1 ) ) , SUBREG_BYTE ( orig_op1 ) , GET_MODE ( orig_op1 ) ) ) ) ; } } if ( context == 1 ) { find_reloads_address ( GET_MODE ( x ) , loc , XEXP ( x , 0 ) , & XEXP ( x , 0 ) , opnum , ADDR_TYPE ( type ) , ind_levels , insn ) ; push_reload ( * loc , NULL_RTX , loc , ( rtx * ) 0 , context_reg_class , GET_MODE ( x ) , VOIDmode , 0 , 0 , opnum , type ) ; return 1 ; } if ( code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE || code0 == ZERO_EXTEND || code1 == MEM ) { find_reloads_address_1 ( mode , orig_op0 , 1 , PLUS , SCRATCH , & XEXP ( x , 0 ) , opnum , type , ind_levels , insn ) ; find_reloads_address_1 ( mode , orig_op1 , 0 , PLUS , code0 , & XEXP ( x , 1 ) , opnum , type , ind_levels , insn ) ; } if ( code1 == MULT || code1 == SIGN_EXTEND || code1 == TRUNCATE || code1 == ZERO_EXTEND || code0 == MEM ) { find_reloads_address_1 ( mode , orig_op0 , 0 , PLUS , code1 , & XEXP ( x , 0 ) , opnum , type , ind_levels , insn ) ; find_reloads_address_1 ( mode , orig_op1 , 1 , PLUS , SCRATCH , & XEXP ( x , 1 ) , opnum , type , ind_levels , insn ) ; } if ( code0 == CONST_INT || code0 == CONST || code0 == SYMBOL_REF || code0 == LABEL_REF ) { find_reloads_address_1 ( mode , orig_op1 , 0 , PLUS , code0 , & XEXP ( x , 1 ) , opnum , type , ind_levels , insn ) ; } if ( code1 == CONST_INT || code1 == CONST || code1 == SYMBOL_REF || code1 == LABEL_REF ) { find_reloads_address_1 ( mode , orig_op0 , 0 , PLUS , code1 , & XEXP ( x , 0 ) , opnum , type , ind_levels , insn ) ; } if ( code0 == REG && code1 == REG ) { if ( REGNO_OK_FOR_INDEX_P ( REGNO ( op0 ) ) && regno_ok_for_base_p ( REGNO ( op1 ) , mode , PLUS , REG ) ) { return 0 ; } if ( REGNO_OK_FOR_INDEX_P ( REGNO ( op1 ) ) && regno_ok_for_base_p ( REGNO ( op0 ) , mode , PLUS , REG ) ) { return 0 ; } if ( regno_ok_for_base_p ( REGNO ( op1 ) , mode , PLUS , REG ) ) { find_reloads_address_1 ( mode , orig_op0 , 1 , PLUS , SCRATCH , & XEXP ( x , 0 ) , opnum , type , ind_levels , insn ) ; } if ( regno_ok_for_base_p ( REGNO ( op0 ) , mode , PLUS , REG ) ) { find_reloads_address_1 ( mode , orig_op1 , 1 , PLUS , SCRATCH , & XEXP ( x , 1 ) , opnum , type , ind_levels , insn ) ; } if ( REGNO_OK_FOR_INDEX_P ( REGNO ( op1 ) ) ) { find_reloads_address_1 ( mode , orig_op0 , 0 , PLUS , REG , & XEXP ( x , 0 ) , opnum , type , ind_levels , insn ) ; } if ( REGNO_OK_FOR_INDEX_P ( REGNO ( op0 ) ) ) { find_reloads_address_1 ( mode , orig_op1 , 0 , PLUS , REG , & XEXP ( x , 1 ) , opnum , type , ind_levels , insn ) ; } else { find_reloads_address_1 ( mode , orig_op0 , 1 , PLUS , SCRATCH , & XEXP ( x , 0 ) , opnum , type , ind_levels , insn ) ; find_reloads_address_1 ( mode , orig_op1 , 0 , PLUS , REG , & XEXP ( x , 1 ) , opnum , type , ind_levels , insn ) ; } } if ( code0 == REG ) { find_reloads_address_1 ( mode , orig_op0 , 1 , PLUS , SCRATCH , & XEXP ( x , 0 ) , opnum , type , ind_levels , insn ) ; find_reloads_address_1 ( mode , orig_op1 , 0 , PLUS , REG , & XEXP ( x , 1 ) , opnum , type , ind_levels , insn ) ; } if ( code1 == REG ) { find_reloads_address_1 ( mode , orig_op1 , 1 , PLUS , SCRATCH , & XEXP ( x , 1 ) , opnum , type , ind_levels , insn ) ; find_reloads_address_1 ( mode , orig_op0 , 0 , PLUS , REG , & XEXP ( x , 0 ) , opnum , type , ind_levels , insn ) ; } } return 0 ; case POST_MODIFY : case PRE_MODIFY : { rtx op0 = XEXP ( x , 0 ) ; rtx op1 = XEXP ( x , 1 ) ; enum rtx_code index_code ; int regno ; int reloadnum ; if ( GET_CODE ( op1 ) != PLUS && GET_CODE ( op1 ) != MINUS ) { return 0 ; } gcc_assert ( op0 == XEXP ( op1 , 0 ) ) ; if ( REG_P ( XEXP ( op1 , 1 ) ) ) { if ( ! REGNO_OK_FOR_INDEX_P ( REGNO ( XEXP ( op1 , 1 ) ) ) ) { find_reloads_address_1 ( mode , XEXP ( op1 , 1 ) , 1 , code , SCRATCH , & XEXP ( op1 , 1 ) , opnum , RELOAD_OTHER , ind_levels , insn ) ; } } gcc_assert ( REG_P ( XEXP ( op1 , 0 ) ) ) ; regno = REGNO ( XEXP ( op1 , 0 ) ) ; index_code = GET_CODE ( XEXP ( op1 , 1 ) ) ; gcc_assert ( regno < FIRST_PSEUDO_REGISTER || reg_equiv_constant [ regno ] == 0 ) ; if ( reg_equiv_memory_loc [ regno ] != 0 && ( reg_equiv_address [ regno ] != 0 || num_not_at_initial_offset ) ) { rtx tem = make_memloc ( XEXP ( x , 0 ) , regno ) ; if ( reg_equiv_address [ regno ] || ! rtx_equal_p ( tem , reg_equiv_mem [ regno ] ) ) { rtx orig = tem ; find_reloads_address ( GET_MODE ( tem ) , & tem , XEXP ( tem , 0 ) , & XEXP ( tem , 0 ) , opnum , RELOAD_OTHER , ind_levels , insn ) ; if ( tem != orig ) { push_reg_equiv_alt_mem ( regno , tem ) ; } reloadnum = push_reload ( tem , tem , & XEXP ( x , 0 ) , & XEXP ( op1 , 0 ) , base_reg_class ( mode , code , index_code ) , GET_MODE ( x ) , GET_MODE ( x ) , 0 , 0 , opnum , RELOAD_OTHER ) ; update_auto_inc_notes ( this_insn , regno , reloadnum ) ; return 0 ; } } if ( reg_renumber [ regno ] >= 0 ) { regno = reg_renumber [ regno ] ; } if ( ! regno_ok_for_base_p ( regno , GET_MODE ( x ) , code , index_code ) ) { reloadnum = push_reload ( XEXP ( op1 , 0 ) , XEXP ( x , 0 ) , & XEXP ( op1 , 0 ) , & XEXP ( x , 0 ) , base_reg_class ( mode , code , index_code ) , GET_MODE ( x ) , GET_MODE ( x ) , 0 , 0 , opnum , RELOAD_OTHER ) ; update_auto_inc_notes ( this_insn , regno , reloadnum ) ; return 0 ; } } return 0 ; case POST_INC : case POST_DEC : case PRE_INC : case PRE_DEC : if ( REG_P ( XEXP ( x , 0 ) ) ) { int regno = REGNO ( XEXP ( x , 0 ) ) ; int value = 0 ; rtx x_orig = x ; gcc_assert ( regno < FIRST_PSEUDO_REGISTER || reg_equiv_constant [ regno ] == 0 ) ; if ( reg_equiv_memory_loc [ regno ] != 0 && ( reg_equiv_address [ regno ] != 0 || num_not_at_initial_offset ) ) { rtx tem = make_memloc ( XEXP ( x , 0 ) , regno ) ; if ( reg_equiv_address [ regno ] || ! rtx_equal_p ( tem , reg_equiv_mem [ regno ] ) ) { rtx orig = tem ; find_reloads_address ( GET_MODE ( tem ) , & tem , XEXP ( tem , 0 ) , & XEXP ( tem , 0 ) , opnum , type , ind_levels , insn ) ; if ( tem != orig ) { push_reg_equiv_alt_mem ( regno , tem ) ; } x = gen_rtx_fmt_e ( GET_CODE ( x ) , GET_MODE ( x ) , tem ) ; } } if ( reg_renumber [ regno ] >= 0 ) { regno = reg_renumber [ regno ] ; } if ( regno >= FIRST_PSEUDO_REGISTER || ! REG_OK_FOR_CONTEXT ( context , regno , mode , outer_code , index_code ) ) { int reloadnum ; rtx equiv = ( MEM_P ( XEXP ( x , 0 ) ) ?XEXP ( x , 0 ) : reg_equiv_mem [ regno ] ) ; int icode = ( int ) add_optab -> handlers [ ( int ) Pmode ] . insn_code ; if ( insn && NONJUMP_INSN_P ( insn ) && equiv && memory_operand ( equiv , GET_MODE ( equiv ) ) && ! sets_cc0_p ( PATTERN ( insn ) ) && ! ( icode != CODE_FOR_nothing && ( ( * insn_data [ icode ] . operand [ 0 ] . predicate ) ( equiv , Pmode ) ) && ( ( * insn_data [ icode ] . operand [ 1 ] . predicate ) ( equiv , Pmode ) ) ) ) { loc = & XEXP ( x_orig , 0 ) ; x = XEXP ( x , 0 ) ; reloadnum = push_reload ( x , x , loc , loc , context_reg_class , GET_MODE ( x ) , GET_MODE ( x ) , 0 , 0 , opnum , RELOAD_OTHER ) ; } else { reloadnum = push_reload ( x , NULL_RTX , loc , ( rtx * ) 0 , context_reg_class , GET_MODE ( x ) , GET_MODE ( x ) , 0 , 0 , opnum , type ) ; rld [ reloadnum ] . inc = find_inc_amount ( PATTERN ( this_insn ) , XEXP ( x_orig , 0 ) ) ; value = 1 ; } update_auto_inc_notes ( this_insn , REGNO ( XEXP ( x_orig , 0 ) ) , reloadnum ) ; } return value ; } if ( MEM_P ( XEXP ( x , 0 ) ) ) { rtx tem ATTRIBUTE_UNUSED = XEXP ( x , 0 ) ; rtx link ; int reloadnum ; find_reloads_address ( GET_MODE ( x ) , & XEXP ( x , 0 ) , XEXP ( XEXP ( x , 0 ) , 0 ) , & XEXP ( XEXP ( x , 0 ) , 0 ) , opnum , type , ind_levels , insn ) ; reloadnum = push_reload ( x , NULL_RTX , loc , ( rtx * ) 0 , context_reg_class , GET_MODE ( x ) , VOIDmode , 0 , 0 , opnum , type ) ; rld [ reloadnum ] . inc = find_inc_amount ( PATTERN ( this_insn ) , XEXP ( x , 0 ) ) ; link = FIND_REG_INC_NOTE ( this_insn , tem ) ; if ( link != 0 ) { push_replacement ( & XEXP ( link , 0 ) , reloadnum , VOIDmode ) ; } return 1 ; } return 0 ; case TRUNCATE : case SIGN_EXTEND : case ZERO_EXTEND : find_reloads_address_1 ( GET_MODE ( XEXP ( x , 0 ) ) , XEXP ( x , 0 ) , context , code , SCRATCH , & XEXP ( x , 0 ) , opnum , type , ind_levels , insn ) ; push_reload ( x , NULL_RTX , loc , ( rtx * ) 0 , context_reg_class , GET_MODE ( x ) , VOIDmode , 0 , 0 , opnum , type ) ; return 1 ; case MEM : find_reloads_address ( GET_MODE ( x ) , loc , XEXP ( x , 0 ) , & XEXP ( x , 0 ) , opnum , ADDR_TYPE ( type ) , ind_levels , insn ) ; push_reload ( * loc , NULL_RTX , loc , ( rtx * ) 0 , context_reg_class , GET_MODE ( x ) , VOIDmode , 0 , 0 , opnum , type ) ; return 1 ; case REG : { int regno = REGNO ( x ) ; if ( reg_equiv_constant [ regno ] != 0 ) { find_reloads_address_part ( reg_equiv_constant [ regno ] , loc , context_reg_class , GET_MODE ( x ) , opnum , type , ind_levels ) ; return 1 ; } if ( reg_equiv_mem [ regno ] != 0 ) { push_reload ( reg_equiv_mem [ regno ] , NULL_RTX , loc , ( rtx * ) 0 , context_reg_class , GET_MODE ( x ) , VOIDmode , 0 , 0 , opnum , type ) ; return 1 ; } if ( reg_equiv_memory_loc [ regno ] && ( reg_equiv_address [ regno ] != 0 || num_not_at_initial_offset ) ) { rtx tem = make_memloc ( x , regno ) ; if ( reg_equiv_address [ regno ] != 0 || ! rtx_equal_p ( tem , reg_equiv_mem [ regno ] ) ) { x = tem ; find_reloads_address ( GET_MODE ( x ) , & x , XEXP ( x , 0 ) , & XEXP ( x , 0 ) , opnum , ADDR_TYPE ( type ) , ind_levels , insn ) ; if ( x != tem ) { push_reg_equiv_alt_mem ( regno , x ) ; } } } if ( reg_renumber [ regno ] >= 0 ) { regno = reg_renumber [ regno ] ; } if ( regno >= FIRST_PSEUDO_REGISTER || ! REG_OK_FOR_CONTEXT ( context , regno , mode , outer_code , index_code ) ) { push_reload ( x , NULL_RTX , loc , ( rtx * ) 0 , context_reg_class , GET_MODE ( x ) , VOIDmode , 0 , 0 , opnum , type ) ; return 1 ; } if ( regno_clobbered_p ( regno , this_insn , GET_MODE ( x ) , 0 ) ) { push_reload ( x , NULL_RTX , loc , ( rtx * ) 0 , context_reg_class , GET_MODE ( x ) , VOIDmode , 0 , 0 , opnum , type ) ; return 1 ; } } return 0 ; case SUBREG : if ( REG_P ( SUBREG_REG ( x ) ) ) { if ( REGNO ( SUBREG_REG ( x ) ) < FIRST_PSEUDO_REGISTER ) { int regno ATTRIBUTE_UNUSED = subreg_regno ( x ) ; if ( ! REG_OK_FOR_CONTEXT ( context , regno , mode , outer_code , index_code ) ) { push_reload ( x , NULL_RTX , loc , ( rtx * ) 0 , context_reg_class , GET_MODE ( x ) , VOIDmode , 0 , 0 , opnum , type ) ; return 1 ; } } else { enum reg_class class = context_reg_class ; if ( ( unsigned ) CLASS_MAX_NREGS ( class , GET_MODE ( SUBREG_REG ( x ) ) ) > reg_class_size [ class ] ) { x = find_reloads_subreg_address ( x , 0 , opnum , ADDR_TYPE ( type ) , ind_levels , insn ) ; push_reload ( x , NULL_RTX , loc , ( rtx * ) 0 , class , GET_MODE ( x ) , VOIDmode , 0 , 0 , opnum , type ) ; return 1 ; } } } break ; default : break ; } { const char * fmt = GET_RTX_FORMAT ( code ) ; int i ; for ( i = GET_RTX_LENGTH ( code ) - 1 ; i >= 0 ; i -- ) { } } return 0 ; } 