struct_equiv_block_eq ( , ) { rtx x_stop , y_stop ; rtx xi , yi ; int i ; if ( mode & STRUCT_EQUIV_START ) { x_stop = BB_HEAD ( info -> x_block ) ; y_stop = BB_HEAD ( info -> y_block ) ; } else { x_stop = info -> cur . x_start ; y_stop = info -> cur . y_start ; } if ( ! struct_equiv_init ( mode , info ) ) { gcc_unreachable ( ) ; } xi = BB_END ( info -> x_block ) ; if ( onlyjump_p ( xi ) || ( returnjump_p ( xi ) && ! side_effects_p ( PATTERN ( xi ) ) ) ) { info -> cur . x_start = xi ; xi = PREV_INSN ( xi ) ; } yi = BB_END ( info -> y_block ) ; if ( onlyjump_p ( yi ) || ( returnjump_p ( yi ) && ! side_effects_p ( PATTERN ( yi ) ) ) ) { info -> cur . y_start = yi ; if ( ! simplejump_p ( yi ) && ! returnjump_p ( yi ) && info -> cur . x_start ) { info -> cur . ninsns ++ ; } yi = PREV_INSN ( yi ) ; } if ( mode & STRUCT_EQUIV_MATCH_JUMPS ) { gcc_assert ( ! info -> cur . x_start == ! info -> cur . y_start ) ; if ( info -> cur . x_start ) { if ( any_condjump_p ( info -> cur . x_start ) ?! condjump_equiv_p ( info , false ) : ! insns_match_p ( info -> cur . x_start , info -> cur . y_start , info ) ) { gcc_unreachable ( ) ; } } if ( any_condjump_p ( xi ) && any_condjump_p ( yi ) ) { info -> cur . x_start = xi ; info -> cur . y_start = yi ; xi = PREV_INSN ( xi ) ; yi = PREV_INSN ( yi ) ; info -> cur . ninsns ++ ; if ( ! condjump_equiv_p ( info , false ) ) { gcc_unreachable ( ) ; } } if ( info -> cur . x_start && info -> mode & STRUCT_EQUIV_FINAL ) { struct_equiv_merge ( info -> cur . x_start , info -> cur . y_start , info ) ; } } struct_equiv_improve_checkpoint ( & info -> best_match , info ) ; info -> x_end = xi ; info -> y_end = yi ; if ( info -> cur . x_start != x_stop ) { for ( ; ; ) { while ( ! INSN_P ( xi ) && xi != x_stop ) { xi = PREV_INSN ( xi ) ; } while ( ! INSN_P ( yi ) && yi != y_stop ) { yi = PREV_INSN ( yi ) ; } if ( ! insns_match_p ( xi , yi , info ) ) { break ; } if ( INSN_P ( xi ) ) { if ( info -> mode & STRUCT_EQUIV_FINAL ) { struct_equiv_merge ( xi , yi , info ) ; } info -> cur . ninsns ++ ; struct_equiv_improve_checkpoint ( & info -> best_match , info ) ; } if ( xi == x_stop || yi == y_stop ) { if ( info -> best_match . x_start != info -> cur . x_start && ( xi == BB_HEAD ( info -> x_block ) || yi == BB_HEAD ( info -> y_block ) ) ) { info -> cur . ninsns ++ ; struct_equiv_improve_checkpoint ( & info -> best_match , info ) ; info -> cur . ninsns -- ; if ( info -> best_match . ninsns > info -> cur . ninsns ) { info -> best_match . ninsns = info -> cur . ninsns ; } } break ; } xi = PREV_INSN ( xi ) ; yi = PREV_INSN ( yi ) ; } } cancel_changes ( 0 ) ; struct_equiv_restore_checkpoint ( & info -> best_match , info ) ; if ( info -> cur . ninsns ) { xi = info -> cur . x_start ; yi = info -> cur . y_start ; while ( xi != x_stop && ! INSN_P ( PREV_INSN ( xi ) ) ) { xi = PREV_INSN ( xi ) ; } while ( yi != y_stop && ! INSN_P ( PREV_INSN ( yi ) ) ) { yi = PREV_INSN ( yi ) ; } info -> cur . x_start = xi ; info -> cur . y_start = yi ; } if ( ! info -> cur . input_valid ) { info -> x_input = info -> y_input = info -> input_reg = NULL_RTX ; } if ( ! info -> need_rerun ) { find_dying_inputs ( info ) ; if ( info -> mode & STRUCT_EQUIV_FINAL ) { if ( info -> check_input_conflict && ! resolve_input_conflict ( info ) ) { gcc_unreachable ( ) ; } } else { bool input_conflict = info -> had_input_conflict ; if ( ! input_conflict && info -> dying_inputs > 1 && bitmap_intersect_p ( info -> x_local_live , info -> y_local_live ) ) { regset_head clobbered_regs ; INIT_REG_SET ( & clobbered_regs ) ; for ( i = 0 ; i < info -> cur . local_count ; i ++ ) { if ( assign_reg_reg_set ( & clobbered_regs , info -> y_local [ i ] , 0 ) ) { input_conflict = true ; break ; } assign_reg_reg_set ( & clobbered_regs , info -> x_local [ i ] , 1 ) ; } CLEAR_REG_SET ( & clobbered_regs ) ; } if ( input_conflict && ! info -> check_input_conflict ) { info -> need_rerun = true ; } info -> check_input_conflict = input_conflict ; } } if ( info -> mode & STRUCT_EQUIV_NEED_FULL_BLOCK && ( info -> cur . x_start != x_stop || info -> cur . y_start != y_stop ) ) { return 0 ; } return info -> cur . ninsns ; } 