static int vpif_probe_complete ( void ) { struct common_obj * common ; struct video_device * vdev ; struct channel_obj * ch ; struct vb2_queue * q ; int j , err , k ; for ( j = 0 ; j < VPIF_DISPLAY_MAX_DEVICES ; j ++ ) { ch = vpif_obj . dev [ j ] ; for ( k = 0 ; k < VPIF_NUMOBJECTS ; k ++ ) { common = & ch -> common [ k ] ; spin_lock_init ( & common -> irqlock ) ; mutex_init ( & common -> lock ) ; common -> set_addr = NULL ; common -> ytop_off = 0 ; common -> ybtm_off = 0 ; common -> ctop_off = 0 ; common -> cbtm_off = 0 ; common -> cur_frm = NULL ; common -> next_frm = NULL ; memset ( & common -> fmt , 0 , sizeof ( common -> fmt ) ) ; } ch -> initialized = 0 ; if ( vpif_obj . config -> subdev_count ) { ch -> sd = vpif_obj . sd [ 0 ] ; } ch -> channel_id = j ; memset ( & ch -> vpifparams , 0 , sizeof ( ch -> vpifparams ) ) ; ch -> common [ VPIF_VIDEO_INDEX ] . fmt . type = V4L2_BUF_TYPE_VIDEO_OUTPUT ; err = vpif_set_output ( vpif_obj . config , ch , 0 ) ; if ( err ) { probe_out } ch -> video . stdid = V4L2_STD_525_60 ; memset ( & ch -> video . dv_timings , 0 , sizeof ( ch -> video . dv_timings ) ) ; vpif_update_resolution ( ch ) ; q = & common -> buffer_queue ; q -> type = V4L2_BUF_TYPE_VIDEO_OUTPUT ; q -> io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF ; q -> drv_priv = ch ; q -> ops = & video_qops ; q -> mem_ops = & vb2_dma_contig_memops ; q -> buf_struct_size = sizeof ( vpif_disp_buffer ) ; q -> timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC ; q -> min_buffers_needed = 1 ; q -> lock = & common -> lock ; q -> dev = vpif_dev ; err = vb2_queue_init ( q ) ; if ( err ) { vpif_err ( "vpif_display: vb2_queue_init() failed\n" ) ; probe_out } INIT_LIST_HEAD ( & common -> dma_queue ) ; vpif_dbg ( 1 , debug , "channel=%p,channel->video_dev=%p\n" , ch , & ch -> video_dev ) ; vdev = & ch -> video_dev ; strscpy ( vdev -> name , VPIF_DRIVER_NAME , sizeof ( vdev -> name ) ) ; vdev -> release = video_device_release_empty ; vdev -> fops = & vpif_fops ; vdev -> ioctl_ops = & vpif_ioctl_ops ; vdev -> v4l2_dev = & vpif_obj . v4l2_dev ; vdev -> vfl_dir = VFL_DIR_TX ; vdev -> queue = q ; vdev -> lock = & common -> lock ; vdev -> device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING ; video_set_drvdata ( & ch -> video_dev , ch ) ; err = video_register_device ( vdev , VFL_TYPE_VIDEO , ( j ?3 : 2 ) ) ; } return 0 ; probe_out for ( k = 0 ; k < j ; k ++ ) { ch = vpif_obj . dev [ k ] ; video_unregister_device ( & ch -> video_dev ) ; } return err ; } 