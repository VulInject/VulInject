static void parse_test ( struct peer * peer , struct test_segment * t , int type ) { int parse_ret = 0 , nlri_ret = 0 ; struct attr attr = { } ; struct bgp_nlri nlri = { } ; struct bgp_attr_parser_args attr_args = { . peer = peer . length = t -> len . total = 1 . attr = & attr . type = type . flags = BGP_ATTR_FLAG_OPTIONAL . startp = BGP_INPUT_PNT ( peer ) } ; stream_reset ( peer -> curr ) ; stream_put ( peer -> curr , NULL , RANDOM_FUZZ ) ; stream_set_getp ( peer -> curr , RANDOM_FUZZ ) ; stream_write ( peer -> curr , t -> data , t -> len ) ; printf ( "%s: %s\n" , t -> name , t -> desc ) ; switch ( type ) { case BGP_ATTR_MP_REACH_NLRI : parse_ret = bgp_mp_reach_parse ( & attr_args , & nlri ) ; break ; case BGP_ATTR_MP_UNREACH_NLRI : parse_ret = bgp_mp_unreach_parse ( & attr_args , & nlri ) ; break ; case BGP_ATTR_PREFIX_SID : parse_ret = bgp_attr_prefix_sid ( & attr_args ) ; break ; default : printf ( "unknown type" ) ; return ; } if ( ! parse_ret ) { iana_afi_t pkt_afi ; iana_safi_t pkt_safi ; if ( bgp_map_afi_safi_int2iana ( nlri . afi , nlri . safi , & pkt_afi , & pkt_safi ) ) { assert ( 0 ) ; } printf ( "MP: %u(%u)/%u(%u): recv %u, nego %u\n" , nlri . afi , pkt_afi , nlri . safi , pkt_safi , peer -> afc_recv [ nlri . afi ] [ nlri . safi ] , peer -> afc_nego [ nlri . afi ] [ nlri . safi ] ) ; } if ( ! parse_ret ) { if ( type == BGP_ATTR_MP_REACH_NLRI ) { nlri_ret = bgp_nlri_parse ( peer , & attr , & nlri , 0 ) ; } if ( type == BGP_ATTR_MP_UNREACH_NLRI ) { nlri_ret = bgp_nlri_parse ( peer , & attr , & nlri , 1 ) ; } } handle_result ( peer , t , parse_ret , nlri_ret ) ; } 