static enum bisect_error bisect_start ( struct bisect_terms * terms , int argc , const char * * argv ) { int no_checkout = 0 ; int first_parent_only = 0 ; int i , has_double_dash = 0 , must_write_terms = 0 , bad_seen = 0 ; int flags , pathspec_pos ; enum bisect_error res = BISECT_OK ; struct string_list revs = STRING_LIST_INIT_DUP ; struct string_list states = STRING_LIST_INIT_DUP ; struct strbuf start_head = STRBUF_INIT ; struct strbuf bisect_names = STRBUF_INIT ; struct object_id head_oid ; struct object_id oid ; const char * head ; if ( is_bare_repository ( ) ) { no_checkout = 1 ; } for ( i = 0 ; i < argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , "--" ) ) { has_double_dash = 1 ; break ; } } for ( i = 0 ; i < argc ; i ++ ) { const char * arg = argv [ i ] ; if ( ! strcmp ( argv [ i ] , "--" ) ) { break ; } if ( ! strcmp ( arg , "--no-checkout" ) ) { no_checkout = 1 ; } if ( ! strcmp ( arg , "--first-parent" ) ) { first_parent_only = 1 ; } if ( ! strcmp ( arg , "--term-good" ) || ! strcmp ( arg , "--term-old" ) ) { i ++ ; if ( argc <= i ) { return error ( _ ( "'' is not a valid term" ) ) ; } must_write_terms = 1 ; terms -> term_good = xstrdup ( argv [ i ] ) ; } if ( skip_prefix ( arg , "--term-good=" , & arg ) || skip_prefix ( arg , "--term-old=" , & arg ) ) { must_write_terms = 1 ; free ( ( void * ) terms -> term_good ) ; terms -> term_good = xstrdup ( arg ) ; } if ( ! strcmp ( arg , "--term-bad" ) || ! strcmp ( arg , "--term-new" ) ) { i ++ ; if ( argc <= i ) { return error ( _ ( "'' is not a valid term" ) ) ; } must_write_terms = 1 ; free ( ( void * ) terms -> term_bad ) ; terms -> term_bad = xstrdup ( argv [ i ] ) ; } if ( skip_prefix ( arg , "--term-bad=" , & arg ) || skip_prefix ( arg , "--term-new=" , & arg ) ) { must_write_terms = 1 ; free ( ( void * ) terms -> term_bad ) ; terms -> term_bad = xstrdup ( arg ) ; } if ( starts_with ( arg , "--" ) ) { return error ( _ ( "unrecognized option: '%s'" ) , arg ) ; } if ( ! get_oidf ( & oid , "%s^{commit}" , arg ) ) { string_list_append ( & revs , oid_to_hex ( & oid ) ) ; } if ( has_double_dash ) { die ( _ ( "'%s' does not appear to be a valid " "revision" ) , arg ) ; } else { break ; } } pathspec_pos = i ; if ( revs . nr ) { must_write_terms = 1 ; } for ( i = 0 ; i < revs . nr ; i ++ ) { if ( bad_seen ) { string_list_append ( & states , terms -> term_good ) ; } else { bad_seen = 1 ; string_list_append ( & states , terms -> term_bad ) ; } } head = resolve_ref_unsafe ( "HEAD" , 0 , & head_oid , & flags ) ; if ( ! head ) { if ( get_oid ( "HEAD" , & head_oid ) ) { return error ( _ ( "bad HEAD - I need a HEAD" ) ) ; } } if ( ! is_empty_or_missing_file ( git_path_bisect_start ( ) ) ) { strbuf_read_file ( & start_head , git_path_bisect_start ( ) , 0 ) ; strbuf_trim ( & start_head ) ; if ( ! no_checkout ) { struct child_process cmd = CHILD_PROCESS_INIT ; cmd . git_cmd = 1 ; strvec_pushl ( & cmd . args , "checkout" , start_head . buf , "--" , NULL ) ; if ( run_command ( & cmd ) ) { res = error ( _ ( "checking out '%s' failed." " Try 'git bisect start " "<valid-branch>'." ) , start_head . buf ) ; finish } } } else { if ( ! get_oid ( head , & head_oid ) && ! starts_with ( head , "refs/heads/" ) ) { strbuf_reset ( & start_head ) ; strbuf_addstr ( & start_head , oid_to_hex ( & head_oid ) ) ; } if ( ! get_oid ( head , & head_oid ) && skip_prefix ( head , "refs/heads/" , & head ) ) { strbuf_addstr ( & start_head , head ) ; } else { return error ( _ ( "bad HEAD - strange symbolic ref" ) ) ; } } if ( bisect_clean_state ( ) ) { return BISECT_FAILED ; } write_file ( git_path_bisect_start ( ) , "%s\n" , start_head . buf ) ; if ( first_parent_only ) { write_file ( git_path_bisect_first_parent ( ) , "\n" ) ; } if ( no_checkout ) { if ( get_oid ( start_head . buf , & oid ) < 0 ) { res = error ( _ ( "invalid ref: '%s'" ) , start_head . buf ) ; finish } if ( update_ref ( NULL , "BISECT_HEAD" , & oid , NULL , 0 , UPDATE_REFS_MSG_ON_ERR ) ) { res = BISECT_FAILED ; finish } } if ( pathspec_pos < argc - 1 ) { sq_quote_argv ( & bisect_names , argv + pathspec_pos ) ; } write_file ( git_path_bisect_names ( ) , "%s\n" , bisect_names . buf ) ; for ( i = 0 ; i < states . nr ; i ++ ) { if ( bisect_write ( states . items [ i ] . string , revs . items [ i ] . string , terms , 1 ) ) { res = BISECT_FAILED ; finish } } if ( must_write_terms && write_terms ( terms -> term_bad , terms -> term_good ) ) { res = BISECT_FAILED ; finish } res = bisect_append_log_quoted ( argv ) ; if ( res ) { res = BISECT_FAILED ; } finish string_list_clear ( & revs , 0 ) ; string_list_clear ( & states , 0 ) ; strbuf_release ( & start_head ) ; strbuf_release ( & bisect_names ) ; if ( res ) { return res ; } res = bisect_auto_next ( terms , NULL ) ; if ( ! is_bisect_success ( res ) ) { bisect_clean_state ( ) ; } return res ; } 