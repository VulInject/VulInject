static krb5_error_code LDAP_entry2mods ( krb5_context context , HDB * db , hdb_entry * ent , LDAPMessage * msg , LDAPMod * * * pmods , krb5_boolean * pis_new_entry ) { krb5_error_code ret ; krb5_boolean is_new_entry = FALSE ; char * tmp = NULL ; LDAPMod * * mods = NULL ; hdb_entry orig ; unsigned long oflags , nflags ; int i ; krb5_boolean is_samba_account = FALSE ; krb5_boolean is_account = FALSE ; krb5_boolean is_heimdal_entry = FALSE ; krb5_boolean is_heimdal_principal = FALSE ; struct berval * * vals ; * pmods = NULL ; if ( msg != NULL ) { ret = LDAP_message2entry ( context , db , msg , 0 , & orig ) ; if ( ret ) { out } vals = ldap_get_values_len ( HDB2LDAP ( db ) , msg , "objectClass" ) ; if ( vals ) { int num_objectclasses = ldap_count_values_len ( vals ) ; for ( i = 0 ; i < num_objectclasses ; i ++ ) { if ( bervalstrcmp ( vals [ i ] , "sambaSamAccount" ) ) { is_samba_account = TRUE ; } if ( bervalstrcmp ( vals [ i ] , structural_object ) ) { is_account = TRUE ; } if ( bervalstrcmp ( vals [ i ] , "krb5Principal" ) ) { is_heimdal_principal = TRUE ; } if ( bervalstrcmp ( vals [ i ] , "krb5KDCEntry" ) ) { is_heimdal_entry = TRUE ; } } ldap_value_free_len ( vals ) ; } if ( is_samba_account == FALSE && is_heimdal_principal == FALSE && is_heimdal_entry == FALSE ) { if ( is_account == TRUE ) { is_new_entry = TRUE ; } else { ret = HDB_ERR_NOENTRY ; out } } } else { is_new_entry = TRUE ; } if ( is_new_entry ) { memset ( & orig , 0 , sizeof ( orig ) ) ; if ( is_account == FALSE ) { ret = LDAP_addmod ( & mods , LDAP_MOD_ADD , "objectClass" , "top" ) ; if ( ret ) { out } ret = LDAP_addmod ( & mods , LDAP_MOD_ADD , "objectClass" , structural_object ) ; is_account = TRUE ; if ( ret ) { out } } ret = LDAP_addmod ( & mods , LDAP_MOD_ADD , "objectClass" , "krb5Principal" ) ; is_heimdal_principal = TRUE ; if ( ret ) { out } ret = LDAP_addmod ( & mods , LDAP_MOD_ADD , "objectClass" , "krb5KDCEntry" ) ; is_heimdal_entry = TRUE ; if ( ret ) { out } } if ( is_new_entry || krb5_principal_compare ( context , ent -> principal , orig . principal ) == FALSE ) { if ( is_heimdal_principal || is_heimdal_entry ) { ret = krb5_unparse_name ( context , ent -> principal , & tmp ) ; if ( ret ) { out } ret = LDAP_addmod ( & mods , LDAP_MOD_REPLACE , "krb5PrincipalName" , tmp ) ; if ( ret ) { free ( tmp ) ; out } free ( tmp ) ; } if ( is_account || is_samba_account ) { ret = krb5_unparse_name_short ( context , ent -> principal , & tmp ) ; if ( ret ) { out } ret = LDAP_addmod ( & mods , LDAP_MOD_REPLACE , "uid" , tmp ) ; if ( ret ) { free ( tmp ) ; out } free ( tmp ) ; } } if ( is_heimdal_entry && ( ent -> kvno != orig . kvno || is_new_entry ) ) { ret = LDAP_addmod_integer ( context , & mods , LDAP_MOD_REPLACE , "krb5KeyVersionNumber" , ent -> kvno ) ; if ( ret ) { out } } if ( is_heimdal_entry && ent -> extensions ) { if ( ! is_new_entry ) { vals = ldap_get_values_len ( HDB2LDAP ( db ) , msg , "krb5ExtendedAttributes" ) ; if ( vals ) { ldap_value_free_len ( vals ) ; ret = LDAP_addmod ( & mods , LDAP_MOD_DELETE , "krb5ExtendedAttributes" , NULL ) ; if ( ret ) { out } } } for ( i = 0 ; i < ent -> extensions -> len ; i ++ ) { unsigned char * buf ; size_t size , sz = 0 ; ASN1_MALLOC_ENCODE ( HDB_extension , buf , size , & ent -> extensions -> val [ i ] , & sz , ret ) ; if ( ret ) { out } if ( size != sz ) { krb5_abortx ( context , "internal error in ASN.1 encoder" ) ; } ret = LDAP_addmod_len ( & mods , LDAP_MOD_ADD , "krb5ExtendedAttributes" , buf , sz ) ; if ( ret ) { out } } } if ( is_heimdal_entry && ent -> valid_start ) { if ( orig . valid_end == NULL || ( * ( ent -> valid_start ) != * ( orig . valid_start ) ) ) { ret = LDAP_addmod_generalized_time ( & mods , LDAP_MOD_REPLACE , "krb5ValidStart" , ent -> valid_start ) ; if ( ret ) { out } } } if ( ent -> valid_end ) { if ( orig . valid_end == NULL || ( * ( ent -> valid_end ) != * ( orig . valid_end ) ) ) { if ( is_heimdal_entry ) { ret = LDAP_addmod_generalized_time ( & mods , LDAP_MOD_REPLACE , "krb5ValidEnd" , ent -> valid_end ) ; if ( ret ) { out } } if ( is_samba_account ) { ret = LDAP_addmod_integer ( context , & mods , LDAP_MOD_REPLACE , "sambaKickoffTime" , * ( ent -> valid_end ) ) ; if ( ret ) { out } } } } if ( ent -> pw_end ) { if ( orig . pw_end == NULL || ( * ( ent -> pw_end ) != * ( orig . pw_end ) ) ) { if ( is_heimdal_entry ) { ret = LDAP_addmod_generalized_time ( & mods , LDAP_MOD_REPLACE , "krb5PasswordEnd" , ent -> pw_end ) ; if ( ret ) { out } } if ( is_samba_account ) { ret = LDAP_addmod_integer ( context , & mods , LDAP_MOD_REPLACE , "sambaPwdMustChange" , * ( ent -> pw_end ) ) ; if ( ret ) { out } } } } if ( is_samba_account && ent -> last_pw_change ) { if ( orig . last_pw_change == NULL || ( * ( ent -> last_pw_change ) != * ( orig . last_pw_change ) ) ) { ret = LDAP_addmod_integer ( context , & mods , LDAP_MOD_REPLACE , "sambaPwdLastSet" , * ( ent -> last_pw_change ) ) ; if ( ret ) { out } } } if ( is_heimdal_entry && ent -> max_life ) { if ( orig . max_life == NULL || ( * ( ent -> max_life ) != * ( orig . max_life ) ) ) { ret = LDAP_addmod_integer ( context , & mods , LDAP_MOD_REPLACE , "krb5MaxLife" , * ( ent -> max_life ) ) ; if ( ret ) { out } } } if ( is_heimdal_entry && ent -> max_renew ) { if ( orig . max_renew == NULL || ( * ( ent -> max_renew ) != * ( orig . max_renew ) ) ) { ret = LDAP_addmod_integer ( context , & mods , LDAP_MOD_REPLACE , "krb5MaxRenew" , * ( ent -> max_renew ) ) ; if ( ret ) { out } } } oflags = HDBFlags2int ( orig . flags ) ; nflags = HDBFlags2int ( ent -> flags ) ; if ( is_heimdal_entry && oflags != nflags ) { ret = LDAP_addmod_integer ( context , & mods , LDAP_MOD_REPLACE , "krb5KDCFlags" , nflags ) ; if ( ret ) { out } } if ( ! is_new_entry && orig . keys . len > 0 ) { vals = ldap_get_values_len ( HDB2LDAP ( db ) , msg , "krb5Key" ) ; if ( vals ) { ldap_value_free_len ( vals ) ; ret = LDAP_addmod ( & mods , LDAP_MOD_DELETE , "krb5Key" , NULL ) ; if ( ret ) { out } } } for ( i = 0 ; i < ent -> keys . len ; i ++ ) { if ( is_samba_account && ent -> keys . val [ i ] . key . keytype == ETYPE_ARCFOUR_HMAC_MD5 ) { char * ntHexPassword ; char * nt ; time_t now = time ( NULL ) ; ret = hdb_unseal_key ( context , db , & ent -> keys . val [ i ] ) ; if ( ret ) { out } nt = ent -> keys . val [ i ] . key . keyvalue . data ; ret = hex_encode ( nt , 16 , & ntHexPassword ) ; if ( ret < 0 ) { ret = ENOMEM ; krb5_set_error_message ( context , ret , "hdb-ldap: failed to " "hex encode key" ) ; out } ret = LDAP_addmod ( & mods , LDAP_MOD_REPLACE , "sambaNTPassword" , ntHexPassword ) ; free ( ntHexPassword ) ; if ( ret ) { out } ret = LDAP_addmod_integer ( context , & mods , LDAP_MOD_REPLACE , "sambaPwdLastSet" , now ) ; if ( ret ) { out } vals = ldap_get_values_len ( HDB2LDAP ( db ) , msg , "sambaLMPassword" ) ; if ( vals ) { ldap_value_free_len ( vals ) ; ret = LDAP_addmod ( & mods , LDAP_MOD_DELETE , "sambaLMPassword" , NULL ) ; if ( ret ) { out } } } if ( is_heimdal_entry ) { unsigned char * buf ; size_t len , buf_size ; ASN1_MALLOC_ENCODE ( Key , buf , buf_size , & ent -> keys . val [ i ] , & len , ret ) ; if ( ret ) { out } ret = LDAP_addmod_len ( & mods , LDAP_MOD_ADD , "krb5Key" , buf , len ) ; if ( ret ) { out } } } if ( ent -> etypes ) { int add_krb5EncryptionType = 0 ; if ( ! is_new_entry ) { vals = ldap_get_values_len ( HDB2LDAP ( db ) , msg , "krb5EncryptionType" ) ; if ( vals ) { ldap_value_free_len ( vals ) ; ret = LDAP_addmod ( & mods , LDAP_MOD_DELETE , "krb5EncryptionType" , NULL ) ; if ( ret ) { out } add_krb5EncryptionType = 1 ; } } if ( is_heimdal_entry ) { add_krb5EncryptionType = 1 ; } if ( add_krb5EncryptionType ) { for ( i = 0 ; i < ent -> etypes -> len ; i ++ ) { if ( is_samba_account && ent -> keys . val [ i ] . key . keytype == ETYPE_ARCFOUR_HMAC_MD5 ) { } if ( is_heimdal_entry ) { ret = LDAP_addmod_integer ( context , & mods , LDAP_MOD_ADD , "krb5EncryptionType" , ent -> etypes -> val [ i ] ) ; if ( ret ) { out } } } } } ret = 0 ; out * pis_new_entry = is_new_entry ; if ( ret == 0 ) { * pmods = mods ; } if ( mods != NULL ) { ldap_mods_free ( mods , 1 ) ; * pmods = NULL ; } if ( msg ) { hdb_free_entry ( context , db , & orig ) ; } return ret ; } 