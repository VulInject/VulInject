int xl_intr ( void * arg ) { struct xl_softc * sc ; struct ifnet * ifp ; u_int16_t status ; int claimed = 0 ; sc = arg ; ifp = & sc -> sc_arpcom . ac_if ; while ( ( status = CSR_READ_2 ( sc , XL_STATUS ) ) & XL_INTRS && status != 0xFFFF ) { claimed = 1 ; CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_INTR_ACK | ( status & XL_INTRS ) ) ; if ( sc -> intr_ack ) { * sc -> intr_ack ( sc ) ; } if ( status & XL_STAT_UP_COMPLETE ) { xl_rxeof ( sc ) ; } if ( status & XL_STAT_DOWN_COMPLETE ) { if ( sc -> xl_type == XL_TYPE_905B ) { xl_txeof_90xB ( sc ) ; } else { xl_txeof ( sc ) ; } } if ( status & XL_STAT_TX_COMPLETE ) { ifp -> if_oerrors ++ ; xl_txeoc ( sc ) ; } if ( status & XL_STAT_ADFAIL ) { xl_init ( sc ) ; } if ( status & XL_STAT_STATSOFLOW ) { sc -> xl_stats_no_timeout = 1 ; xl_stats_update ( sc ) ; sc -> xl_stats_no_timeout = 0 ; } } if ( ! ifq_empty ( & ifp -> if_snd ) ) { * ifp -> if_start ( ifp ) ; } return ( claimed ) ; } 