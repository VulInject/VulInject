static ocsd_datapath_resp_t cs_etm_decoder__buffer_range ( struct cs_etm_queue * etmq , struct cs_etm_packet_queue * packet_queue , const ocsd_generic_trace_elem * elem , const uint8_t trace_chan_id ) { int ret = 0 ; struct cs_etm_packet * packet ; if ( ret != OCSD_RESP_CONT && ret != OCSD_RESP_WAIT ) { return ret ; } packet = & packet_queue -> packet_buffer [ packet_queue -> tail ] ; switch ( elem -> isa ) { case ocsd_isa_aarch64 : packet -> isa = CS_ETM_ISA_A64 ; break ; case ocsd_isa_arm : packet -> isa = CS_ETM_ISA_A32 ; break ; case ocsd_isa_thumb2 : packet -> isa = CS_ETM_ISA_T32 ; break ; case ocsd_isa_tee : case ocsd_isa_jazelle : case ocsd_isa_custom : case ocsd_isa_unknown : default : packet -> isa = CS_ETM_ISA_UNKNOWN ; } packet -> start_addr = elem -> st_addr ; packet -> end_addr = elem -> en_addr ; packet -> instr_count = elem -> num_instr_range ; packet -> last_instr_type = elem -> last_i_type ; packet -> last_instr_subtype = elem -> last_i_subtype ; packet -> last_instr_cond = elem -> last_instr_cond ; if ( elem -> last_i_type == OCSD_INSTR_BR || elem -> last_i_type == OCSD_INSTR_BR_INDIRECT ) { packet -> last_instr_taken_branch = elem -> last_instr_exec ; } else { packet -> last_instr_taken_branch = false ; } packet -> last_instr_size = elem -> last_instr_sz ; if ( cs_etm__etmq_is_timeless ( etmq ) ) { out } if ( ret == OCSD_RESP_WAIT ) { out } packet_queue -> instr_count += elem -> num_instr_range ; ret = cs_etm_decoder__do_soft_timestamp ( etmq , packet_queue , trace_chan_id ) ; out return ret ; } 