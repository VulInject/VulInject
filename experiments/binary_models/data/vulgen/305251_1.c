static int get_parts ( disk_t * disk , struct ipart * iparts , char * opath , int opath_len ) { int fd ; struct dk_minfo minfo ; struct mboot bootblk ; char bootsect [ 512 ] ; int i ; int j , ret ; ext_part_t * epp ; char * device ; size_t len ; logical_drive_t * log_drv ; uint64_t tmpsect ; if ( ( fd = open_disk ( disk , opath , opath_len ) ) < 0 ) { return ( ENODEV ) ; } if ( ! media_read_info ( fd , & minfo ) ) { return ( ENODEV ) ; } if ( ! partition_has_fdisk ( disk , fd ) ) { ( void ) close ( fd ) ; return ( ENOTTY ) ; } if ( lseek ( fd , 0 , 0 ) == - 1 ) { ( void ) close ( fd ) ; return ( ENODEV ) ; } if ( read ( fd , bootsect , 512 ) != 512 ) { ( void ) close ( fd ) ; return ( ENODEV ) ; } ( void ) close ( fd ) ; ( void ) memcpy ( & bootblk , bootsect , sizeof ( bootblk ) ) ; if ( les ( bootblk . signature ) != MBB_MAGIC ) { return ( ENOTTY ) ; } for ( i = 0 ; i < TOTAL_NUMPART ; i ++ ) { ( void ) memset ( & iparts [ i ] , 0 , sizeof ( ipart ) ) ; iparts [ i ] . systid = UNUSED ; } ( void ) memcpy ( iparts , bootblk . parts , ISIZE ) ; for ( i = 0 ; i < FD_NUMPART ; i ++ ) { if ( iparts [ i ] . systid == UNUSED ) { continue ; } iparts [ i ] . relsect = lel ( iparts [ i ] . relsect ) ; iparts [ i ] . numsect = lel ( iparts [ i ] . numsect ) ; if ( ! fdisk_is_dos_extended ( iparts [ i ] . systid ) ) { continue ; } len = strlen ( disk -> aliases -> alias ) + 1 ; if ( ( device = malloc ( len ) ) == NULL ) { if ( device ) { free ( device ) ; } continue ; } ( void ) snprintf ( device , len , "%s" , disk -> aliases -> alias ) ; if ( ( ret = libfdisk_init ( & epp , device , & iparts [ i ] , FDISK_READ_DISK ) ) != FDISK_SUCCESS ) { switch ( ret ) { case FDISK_EBADLOGDRIVE : case FDISK_ENOLOGDRIVE : free ( device ) ; libfdisk_fini ( & epp ) ; continue ; case FDISK_EBADMAGIC : free ( device ) ; libfdisk_fini ( & epp ) ; return ( ENOTTY ) ; default : free ( device ) ; libfdisk_fini ( & epp ) ; return ( ENODEV ) ; } } for ( log_drv = fdisk_get_ld_head ( epp ) , j = FD_NUMPART , tmpsect = 0 ; ( j < TOTAL_NUMPART ) && ( log_drv != NULL ) ; log_drv = log_drv -> next , j ++ ) { iparts [ j ] . bootid = log_drv -> parts [ 0 ] . bootid ; iparts [ j ] . beghead = log_drv -> parts [ 0 ] . beghead ; iparts [ j ] . begsect = log_drv -> parts [ 0 ] . begsect ; iparts [ j ] . begcyl = log_drv -> parts [ 0 ] . begcyl ; iparts [ j ] . systid = log_drv -> parts [ 0 ] . systid ; iparts [ j ] . endhead = log_drv -> parts [ 0 ] . endhead ; iparts [ j ] . endsect = log_drv -> parts [ 0 ] . endsect ; iparts [ j ] . endcyl = log_drv -> parts [ 0 ] . endcyl ; iparts [ j ] . relsect = ( tmpsect + lel ( log_drv -> parts [ 0 ] . relsect ) + epp -> ext_beg_sec ) ; iparts [ j ] . numsect = lel ( log_drv -> parts [ 0 ] . numsect ) ; tmpsect = lel ( log_drv -> parts [ 1 ] . relsect ) ; } free ( device ) ; libfdisk_fini ( & epp ) ; } return ( 0 ) ; } 