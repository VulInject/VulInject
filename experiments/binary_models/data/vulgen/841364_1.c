load_image ( , ) { GInputStream * input ; GeglBuffer * buffer ; GimpImage * volatile image = NULL ; GimpLayer * layer ; char buf [ BUFLEN + 4 ] ; PNMInfo * pnminfo ; PNMScanner * volatile scan ; gint ctr ; GimpPrecision precision ; gboolean is_pam = FALSE ; GimpImageType layer_type ; gimp_progress_init_printf ( _ ( "Opening '%s'" ) , g_file_get_parse_name ( file ) ) ; input = G_INPUT_STREAM ( g_file_read ( file , NULL , error ) ) ; if ( ! input ) { return NULL ; } pnminfo = g_new ( PNMInfo , 1 ) ; scan = NULL ; if ( setjmp ( pnminfo -> jmpbuf ) ) { if ( scan ) { pnmscanner_destroy ( scan ) ; } g_object_unref ( input ) ; g_free ( pnminfo ) ; return NULL ; } if ( ! ( scan = pnmscanner_create ( input ) ) ) { longjmp ( pnminfo -> jmpbuf , 1 ) ; } pnmscanner_gettoken ( scan , buf , BUFLEN ) ; CHECK_FOR_ERROR ( pnmscanner_eof ( scan ) , pnminfo -> jmpbuf , _ ( "Premature end of file." ) ) ; CHECK_FOR_ERROR ( ( buf [ 0 ] != 'P' || buf [ 2 ] ) , pnminfo -> jmpbuf , _ ( "Invalid file." ) ) ; for ( ctr = 0 ; pnm_types [ ctr ] . name ; ctr ++ ) { if ( buf [ 1 ] == pnm_types [ ctr ] . name ) { pnminfo -> np = pnm_types [ ctr ] . np ; pnminfo -> asciibody = pnm_types [ ctr ] . asciibody ; pnminfo -> float_format = g_ascii_tolower ( pnm_types [ ctr ] . name ) == 'f' ; pnminfo -> maxval = pnm_types [ ctr ] . maxval ; pnminfo -> loader = pnm_types [ ctr ] . loader ; if ( pnm_types [ ctr ] . name == '7' ) { is_pam = TRUE ; } } } if ( ! pnminfo -> loader ) { g_message ( _ ( "File not in a supported format." ) ) ; longjmp ( pnminfo -> jmpbuf , 1 ) ; } if ( is_pam ) { process_pam_header ( scan , pnminfo ) ; } else { pnmscanner_gettoken ( scan , buf , BUFLEN ) ; CHECK_FOR_ERROR ( pnmscanner_eof ( scan ) , pnminfo -> jmpbuf , _ ( "Premature end of file." ) ) ; pnminfo -> xres = g_ascii_isdigit ( * buf ) ?atoi ( buf ) : 0 ; CHECK_FOR_ERROR ( pnminfo -> xres <= 0 , pnminfo -> jmpbuf , _ ( "Invalid X resolution." ) ) ; CHECK_FOR_ERROR ( pnminfo -> xres > GIMP_MAX_IMAGE_SIZE , pnminfo -> jmpbuf , _ ( "Image width is larger than GIMP can handle." ) ) ; pnmscanner_gettoken ( scan , buf , BUFLEN ) ; CHECK_FOR_ERROR ( pnmscanner_eof ( scan ) , pnminfo -> jmpbuf , _ ( "Premature end of file." ) ) ; pnminfo -> yres = g_ascii_isdigit ( * buf ) ?atoi ( buf ) : 0 ; CHECK_FOR_ERROR ( pnminfo -> yres <= 0 , pnminfo -> jmpbuf , _ ( "Invalid Y resolution." ) ) ; CHECK_FOR_ERROR ( pnminfo -> yres > GIMP_MAX_IMAGE_SIZE , pnminfo -> jmpbuf , _ ( "Image height is larger than GIMP can handle." ) ) ; } if ( pnminfo -> float_format ) { gchar * endptr = NULL ; pnmscanner_gettoken ( scan , buf , BUFLEN ) ; CHECK_FOR_ERROR ( pnmscanner_eof ( scan ) , pnminfo -> jmpbuf , _ ( "Premature end of file." ) ) ; pnminfo -> scale_factor = g_ascii_strtod ( buf , & endptr ) ; CHECK_FOR_ERROR ( endptr == NULL || * endptr != 0 || errno == ERANGE , pnminfo -> jmpbuf , _ ( "Bogus scale factor." ) ) ; CHECK_FOR_ERROR ( ! isnormal ( pnminfo -> scale_factor ) , pnminfo -> jmpbuf , _ ( "Unsupported scale factor." ) ) ; precision = GIMP_PRECISION_FLOAT_LINEAR ; } if ( pnminfo -> np != 0 ) { if ( ! is_pam ) { pnmscanner_gettoken ( scan , buf , BUFLEN ) ; CHECK_FOR_ERROR ( pnmscanner_eof ( scan ) , pnminfo -> jmpbuf , _ ( "Premature end of file." ) ) ; pnminfo -> maxval = g_ascii_isdigit ( * buf ) ?atoi ( buf ) : 0 ; } CHECK_FOR_ERROR ( ( ( pnminfo -> maxval <= 0 ) || ( pnminfo -> maxval > 65535 ) ) , pnminfo -> jmpbuf , _ ( "Unsupported maximum value." ) ) ; if ( pnminfo -> maxval < 256 ) { precision = GIMP_PRECISION_U8_NON_LINEAR ; } else { precision = GIMP_PRECISION_U16_NON_LINEAR ; } } else { precision = GIMP_PRECISION_U8_NON_LINEAR ; } image = gimp_image_new_with_precision ( pnminfo -> xres , pnminfo -> yres , ( pnminfo -> np >= 3 ) ?GIMP_RGB : GIMP_GRAY , precision ) ; switch ( pnminfo -> np ) { case 0 : case 1 : layer_type = GIMP_GRAY_IMAGE ; break ; case 2 : layer_type = GIMP_GRAYA_IMAGE ; break ; case 3 : layer_type = GIMP_RGB_IMAGE ; break ; case 4 : layer_type = GIMP_RGBA_IMAGE ; break ; default : layer_type = GIMP_GRAY_IMAGE ; } layer = gimp_layer_new ( image , _ ( "Background" ) , pnminfo -> xres , pnminfo -> yres , layer_type , 100 , gimp_image_get_default_new_layer_mode ( image ) ) ; gimp_image_insert_layer ( image , layer , NULL , 0 ) ; buffer = gimp_drawable_get_buffer ( GIMP_DRAWABLE ( layer ) ) ; pnminfo -> loader ( scan , pnminfo , buffer ) ; pnmscanner_destroy ( scan ) ; g_object_unref ( buffer ) ; g_free ( pnminfo ) ; g_object_unref ( input ) ; return image ; } 