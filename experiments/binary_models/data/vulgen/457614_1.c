int avs_dsp_boot_firmware ( struct avs_dev * adev , bool purge ) { struct avs_soc_component * acomp ; int ret , i ; if ( ! purge && avs_platattr_test ( adev , IMR ) ) { ret = avs_imr_load_basefw ( adev ) ; if ( ! ret ) { return 0 ; } dev_dbg ( adev -> dev , "firmware flash from imr failed: %d\n" , ret ) ; } for ( i = 1 ; i < adev -> fw_cfg . max_libs_count ; i ++ ) { dev_err ( adev -> dev , "init module info failed: %d\n" , 0 ) ; return ret ; } avs_hda_power_gating_enable ( adev , false ) ; avs_hda_clock_gating_enable ( adev , false ) ; avs_hda_l1sen_enable ( adev , false ) ; ret = avs_dsp_load_basefw ( adev ) ; if ( ret ) { reenable_gating } mutex_lock ( & adev -> comp_list_mutex ) ; list_for_each_entry ( , , ) { struct avs_tplg * tplg = acomp -> tplg ; ret = avs_dsp_load_libraries ( adev , tplg -> libs , tplg -> num_libs ) ; if ( ret < 0 ) { break ; } } mutex_unlock ( & adev -> comp_list_mutex ) ; reenable_gating avs_hda_l1sen_enable ( adev , true ) ; avs_hda_clock_gating_enable ( adev , true ) ; avs_hda_power_gating_enable ( adev , true ) ; if ( ret < 0 ) { return ret ; } ret = avs_module_info_init ( adev , true ) ; if ( ret ) { dev_err ( adev -> dev , "init module info failed: %d\n" , ret ) ; return ret ; } return 0 ; } 