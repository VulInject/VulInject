ObjectAddress AlterOperator ( AlterOperatorStmt * stmt ) { ObjectAddress address ; Oid oprId ; Relation catalog ; HeapTuple tup ; Form_pg_operator oprForm ; int i ; ListCell * pl ; Datum values [ Natts_pg_operator ] ; bool nulls [ Natts_pg_operator ] ; bool replaces [ Natts_pg_operator ] ; List * restrictionName = NIL ; bool updateRestriction = false ; Oid restrictionOid ; List * joinName = NIL ; bool updateJoin = false ; Oid joinOid ; oprId = LookupOperWithArgs ( stmt -> opername , false ) ; catalog = table_open ( OperatorRelationId , RowExclusiveLock ) ; tup = SearchSysCacheCopy1 ( OPEROID , ObjectIdGetDatum ( oprId ) ) ; if ( ! HeapTupleIsValid ( tup ) ) { elog ( ERROR , "cache lookup failed for operator %u" , oprId ) ; } oprForm = ( Form_pg_operator ) GETSTRUCT ( tup ) ; ( pl stmt -> options ; ) { DefElem * defel = ( DefElem * ) lfirst ( pl ) ; List * param ; if ( defel -> arg == NULL ) { param = NIL ; } else { param = defGetQualifiedName ( defel ) ; } if ( strcmp ( defel -> defname , "restrict" ) == 0 ) { restrictionName = param ; updateRestriction = true ; } if ( strcmp ( defel -> defname , "join" ) == 0 ) { joinName = param ; updateJoin = true ; } if ( strcmp ( defel -> defname , "leftarg" ) == 0 || strcmp ( defel -> defname , "rightarg" ) == 0 || strcmp ( defel -> defname , "function" ) == 0 || strcmp ( defel -> defname , "procedure" ) == 0 || strcmp ( defel -> defname , "commutator" ) == 0 || strcmp ( defel -> defname , "negator" ) == 0 || strcmp ( defel -> defname , "hashes" ) == 0 || strcmp ( defel -> defname , "merges" ) == 0 ) { ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( "operator attribute \"%s\" cannot be changed" , defel -> defname ) ) ) ; } else { ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( "operator attribute \"%s\" not recognized" , defel -> defname ) ) ) ; } } if ( ! object_ownercheck ( OperatorRelationId , oprId , GetUserId ( ) ) ) { aclcheck_error ( ACLCHECK_NOT_OWNER , OBJECT_OPERATOR , NameStr ( oprForm -> oprname ) ) ; } if ( restrictionName ) { restrictionOid = ValidateRestrictionEstimator ( restrictionName ) ; } else { restrictionOid = InvalidOid ; } if ( joinName ) { joinOid = ValidateJoinEstimator ( joinName ) ; } else { joinOid = InvalidOid ; } if ( ! ( OidIsValid ( oprForm -> oprleft ) && OidIsValid ( oprForm -> oprright ) ) ) { if ( OidIsValid ( joinOid ) ) { ereport ( ERROR , ( errcode ( ERRCODE_INVALID_FUNCTION_DEFINITION ) , errmsg ( "only binary operators can have join selectivity" ) ) ) ; } } for ( i = 0 ; i < Natts_pg_operator ; ++ i ) { values [ i ] = ( Datum ) 0 ; replaces [ i ] = false ; nulls [ i ] = false ; } if ( updateRestriction ) { replaces [ Anum_pg_operator_oprrest - 1 ] = true ; values [ Anum_pg_operator_oprrest - 1 ] = restrictionOid ; } if ( updateJoin ) { replaces [ Anum_pg_operator_oprjoin - 1 ] = true ; values [ Anum_pg_operator_oprjoin - 1 ] = joinOid ; } tup = heap_modify_tuple ( tup , RelationGetDescr ( catalog ) , values , nulls , replaces ) ; CatalogTupleUpdate ( catalog , & tup -> t_self , tup ) ; address = makeOperatorDependencies ( tup , false , true ) ; InvokeObjectPostAlterHook ( OperatorRelationId , oprId , 0 ) ; table_close ( catalog , NoLock ) ; return address ; } 