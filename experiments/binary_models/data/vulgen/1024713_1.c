static yrmcds_error connect_to_server ( const char * node , uint16_t port , int * server_fd ) { if ( node == NULL ) { return YRMCDS_BAD_ARGUMENT ; } long fl ; char sport [ 8 ] ; snprintf ( sport , sizeof ( sport ) , "%u" , ( unsigned int ) port ) ; struct addrinfo hint , * res ; hint . ai_family = AF_INET ; hint . ai_socktype = SOCK_STREAM ; hint . ai_flags = AI_NUMERICSERV | AI_ADDRCONFIG ; int e = getaddrinfo ( node , sport , & hint , & res ) ; if ( e == EAI_FAMILY || e == EAI_NONAME || e == EAI_ADDRFAMILY || e == EAI_NODATA ) { hint . ai_family = AF_INET6 ; hint . ai_flags = AI_NUMERICSERV | AI_V4MAPPED ; e = getaddrinfo ( node , sport , & hint , & res ) ; } if ( e == EAI_SYSTEM ) { return YRMCDS_SYSTEM_ERROR ; } if ( e != 0 ) { return YRMCDS_NOT_RESOLVED ; } int s = socket ( res -> ai_family , res -> ai_socktype | SOCK_NONBLOCK | SOCK_CLOEXEC , res -> ai_protocol ) ; if ( s == - 1 ) { e = errno ; freeaddrinfo ( res ) ; errno = e ; return YRMCDS_SYSTEM_ERROR ; } fl = fcntl ( s , F_GETFD , 0 ) ; fcntl ( s , F_SETFD , fl | FD_CLOEXEC ) ; fl = fcntl ( s , F_GETFL , 0 ) ; fcntl ( s , F_SETFL , fl | O_NONBLOCK ) ; e = connect ( s , res -> ai_addr , res -> ai_addrlen ) ; freeaddrinfo ( res ) ; if ( e == - 1 && errno != EINPROGRESS ) { e = errno ; close ( s ) ; errno = e ; return YRMCDS_SYSTEM_ERROR ; } if ( e != 0 ) { struct pollfd fds ; fds . fd = s ; fds . events = POLLOUT ; int n = poll ( & fds , 1 , 5000 ) ; if ( n == 0 ) { close ( s ) ; return YRMCDS_TIMEOUT ; } if ( n == - 1 ) { e = errno ; close ( s ) ; errno = e ; return YRMCDS_SYSTEM_ERROR ; } if ( fds . revents & ( POLLERR | POLLHUP | POLLNVAL ) ) { close ( s ) ; return YRMCDS_DISCONNECTED ; } socklen_t l = sizeof ( e ) ; if ( getsockopt ( s , SOL_SOCKET , SO_ERROR , & e , & l ) == - 1 ) { close ( s ) ; return YRMCDS_SYSTEM_ERROR ; } if ( e != 0 ) { close ( s ) ; errno = e ; return YRMCDS_SYSTEM_ERROR ; } } fl = fcntl ( s , F_GETFL , 0 ) ; if ( fcntl ( s , F_SETFL , fl & ~ O_NONBLOCK ) == - 1 ) { e = errno ; close ( s ) ; errno = e ; return YRMCDS_SYSTEM_ERROR ; } int ok = 1 ; if ( setsockopt ( s , IPPROTO_TCP , TCP_NODELAY , & ok , sizeof ( ok ) ) == - 1 ) { e = errno ; close ( s ) ; errno = e ; return YRMCDS_SYSTEM_ERROR ; } * server_fd = s ; return YRMCDS_OK ; } 