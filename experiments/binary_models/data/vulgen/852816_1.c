int sctp_check_abandoned_msg ( sctp_t * sctp , mblk_t * meta ) { sctp_data_hdr_t * dh ; mblk_t * nmp ; mblk_t * head ; int32_t unsent = 0 ; mblk_t * mp1 = meta -> b_cont ; uint32_t adv_pap = sctp -> sctp_adv_pap ; sctp_faddr_t * fp = sctp -> sctp_current ; sctp_stack_t * sctps = sctp -> sctp_sctps ; dh = ( sctp_data_hdr_t * ) mp1 -> b_rptr ; if ( SEQ_GEQ ( sctp -> sctp_lastack_rxd , ntohl ( dh -> sdh_tsn ) ) ) { sctp_ftsn_set_t * sets = NULL ; uint_t nsets = 0 ; uint32_t seglen = sizeof ( uint32_t ) ; boolean_t ubit = SCTP_DATA_GET_UBIT ( dh ) ; while ( mp1 -> b_next != NULL && SCTP_CHUNK_ISSENT ( mp1 -> b_next ) ) { mp1 = mp1 -> b_next ; } dh = ( sctp_data_hdr_t * ) mp1 -> b_rptr ; sctp -> sctp_adv_pap = ntohl ( dh -> sdh_tsn ) ; if ( ! ubit && ! sctp_add_ftsn_set ( & sets , fp , meta , & nsets , & seglen ) ) { sctp -> sctp_adv_pap = adv_pap ; return ( ENOMEM ) ; } nmp = sctp_make_ftsn_chunk ( sctp , fp , sets , nsets , seglen ) ; sctp_free_ftsn_set ( sets ) ; if ( nmp == NULL ) { sctp -> sctp_adv_pap = adv_pap ; return ( ENOMEM ) ; } head = sctp_add_proto_hdr ( sctp , fp , nmp , 0 , NULL ) ; SCTP_MSG_SET_ABANDONED ( meta ) ; sctp_set_iplen ( sctp , head , fp -> sf_ixa ) ; ( void ) conn_ip_output ( head , fp -> sf_ixa ) ; BUMP_LOCAL ( sctp -> sctp_opkts ) ; if ( ! fp -> sf_timer_running ) { SCTP_FADDR_TIMER_RESTART ( sctp , fp , fp -> sf_rto ) ; } mp1 = mp1 -> b_next ; while ( mp1 != NULL ) { ASSERT ( ! SCTP_CHUNK_ISSENT ( mp1 ) ) ; ASSERT ( ! SCTP_CHUNK_ABANDONED ( mp1 ) ) ; SCTP_ABANDON_CHUNK ( mp1 ) ; dh = ( sctp_data_hdr_t * ) mp1 -> b_rptr ; unsent += ntohs ( dh -> sdh_len ) - sizeof ( * dh ) ; mp1 = mp1 -> b_next ; } ASSERT ( sctp -> sctp_unsent >= unsent ) ; sctp -> sctp_unsent -= unsent ; if ( ! SCTP_IS_DETACHED ( sctp ) ) { SCTP_TXQ_UPDATE ( sctp ) ; } return ( 0 ) ; } return ( - 1 ) ; } 