void statclock ( struct clockframe * frame ) { struct gmonparam * g ; u_long i ; struct cpu_info * ci = curcpu ( ) ; struct schedstate_percpu * spc = & ci -> ci_schedstate ; struct proc * p = curproc ; struct process * pr ; if ( spc -> spc_psdiv != psdiv ) { spc -> spc_psdiv = psdiv ; spc -> spc_pscnt = psdiv ; if ( psdiv == 1 ) { setstatclockrate ( stathz ) ; } else { setstatclockrate ( profhz ) ; } } if ( CLKF_USERMODE ( frame ) ) { pr = p -> p_p ; if ( pr -> ps_flags & PS_PROFIL ) { addupc_intr ( p , CLKF_PC ( frame ) ) ; } p -> p_uticks ++ ; if ( pr -> ps_nice > NZERO ) { spc -> spc_cp_time [ CP_NICE ] ++ ; } else { spc -> spc_cp_time [ CP_USER ] ++ ; } } else { g = ci -> ci_gmon ; if ( g != NULL && g -> state == GMON_PROF_ON ) { i = CLKF_PC ( frame ) - g -> lowpc ; if ( i < g -> textsize ) { i /= HISTFRACTION * sizeof ( * g -> kcount ) ; g -> kcount [ i ] ++ ; } } if ( p != NULL && p -> p_p -> ps_flags & PS_PROFIL ) { addupc_intr ( p , PROC_PC ( p ) ) ; } if ( -- spc -> spc_pscnt > 0 ) { return ; } if ( CLKF_INTR ( frame ) ) { if ( p != NULL ) { p -> p_iticks ++ ; } spc -> spc_cp_time [ spc -> spc_spinning ?CP_SPIN : CP_INTR ] ++ ; } if ( p != NULL && p != spc -> spc_idleproc ) { p -> p_sticks ++ ; spc -> spc_cp_time [ spc -> spc_spinning ?CP_SPIN : CP_SYS ] ++ ; } else { spc -> spc_cp_time [ spc -> spc_spinning ?CP_SPIN : CP_IDLE ] ++ ; } } spc -> spc_pscnt = psdiv ; if ( p != NULL ) { p -> p_cpticks ++ ; if ( schedhz == 0 ) { if ( ( ++ spc -> spc_schedticks & 3 ) == 0 ) { schedclock ( p ) ; } } } } 