static void prvAddCurrentTaskToDelayedList ( TickType_t xTicksToWait , const BaseType_t xCanBlockIndefinitely ) { TickType_t xTimeToWake ; const TickType_t xConstTickCount = xTickCount ; { pxCurrentTCB -> ucDelayAborted = pdFALSE ; } if ( uxListRemove ( & ( pxCurrentTCB -> xStateListItem ) ) == ( UBaseType_t ) 0 ) { portRESET_READY_PRIORITY ( pxCurrentTCB -> uxPriority , uxTopReadyPriority ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } { if ( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) ) { vListInsertEnd ( & xSuspendedTaskList , & ( pxCurrentTCB -> xStateListItem ) ) ; } else { xTimeToWake = xConstTickCount + xTicksToWait ; listSET_LIST_ITEM_VALUE ( & ( pxCurrentTCB -> xStateListItem ) , xTimeToWake ) ; if ( xTimeToWake < xConstTickCount ) { vListInsert ( pxOverflowDelayedTaskList , & ( pxCurrentTCB -> xStateListItem ) ) ; } else { vListInsert ( pxDelayedTaskList , & ( pxCurrentTCB -> xStateListItem ) ) ; if ( xTimeToWake < xNextTaskUnblockTime ) { xNextTaskUnblockTime = xTimeToWake ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } } } { xTimeToWake = xConstTickCount + xTicksToWait ; listSET_LIST_ITEM_VALUE ( & ( pxCurrentTCB -> xStateListItem ) , xTimeToWake ) ; if ( xTimeToWake < xConstTickCount ) { vListInsert ( pxOverflowDelayedTaskList , & ( pxCurrentTCB -> xStateListItem ) ) ; } else { vListInsert ( pxDelayedTaskList , & ( pxCurrentTCB -> xStateListItem ) ) ; else { mtCOVERAGE_TEST_MARKER ( ) ; } } ( void ) xCanBlockIndefinitely ; } } 