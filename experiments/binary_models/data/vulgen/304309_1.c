static int gud_connector_add_properties ( struct gud_device * gdrm , struct gud_connector * gconn ) { struct drm_connector * connector = & gconn -> connector ; struct drm_device * drm = & gdrm -> drm ; struct gud_property_req * properties ; unsigned int i , num_properties ; int ret ; properties = kcalloc ( GUD_CONNECTOR_PROPERTIES_MAX_NUM , sizeof ( * properties ) , GFP_KERNEL ) ; if ( ! properties ) { return - ENOMEM ; } ret = gud_usb_get ( gdrm , GUD_REQ_GET_CONNECTOR_PROPERTIES , connector -> index , properties , GUD_CONNECTOR_PROPERTIES_MAX_NUM * sizeof ( * properties ) ) ; if ( ret <= 0 ) { out } if ( ret % sizeof ( * properties ) ) { ret = - EIO ; out } num_properties = ret / sizeof ( * properties ) ; ret = 0 ; if ( ! gconn -> properties ) { ret = - ENOMEM ; out } for ( i = 0 ; i < num_properties ; i ++ ) { u16 prop = le16_to_cpu ( properties [ i ] . prop ) ; u64 val = le64_to_cpu ( properties [ i ] . val ) ; struct drm_property * property ; unsigned int * state_val ; drm_dbg ( drm , "property: %u = %llu(0x%llx)\n" , prop , val , val ) ; switch ( prop ) { case GUD_PROPERTY_TV_LEFT_MARGIN : fallthrough ; case GUD_PROPERTY_TV_RIGHT_MARGIN : fallthrough ; case GUD_PROPERTY_TV_TOP_MARGIN : fallthrough ; case GUD_PROPERTY_TV_BOTTOM_MARGIN : ret = drm_mode_create_tv_margin_properties ( drm ) ; if ( ret ) { out } break ; case GUD_PROPERTY_TV_MODE : ret = gud_connector_add_tv_mode ( gdrm , connector ) ; if ( ret ) { out } break ; case GUD_PROPERTY_TV_BRIGHTNESS : fallthrough ; case GUD_PROPERTY_TV_CONTRAST : fallthrough ; case GUD_PROPERTY_TV_FLICKER_REDUCTION : fallthrough ; case GUD_PROPERTY_TV_OVERSCAN : fallthrough ; case GUD_PROPERTY_TV_SATURATION : fallthrough ; case GUD_PROPERTY_TV_HUE : ret = drm_mode_create_tv_properties_legacy ( drm , 0 , NULL ) ; if ( ret ) { out } break ; case GUD_PROPERTY_BACKLIGHT_BRIGHTNESS : if ( val > 100 ) { ret = - EINVAL ; out } gconn -> initial_brightness = val ; break ; default : drm_dbg ( drm , "Ignoring unknown property: %u\n" , prop ) ; continue ; } gconn -> properties [ gconn -> num_properties ++ ] = prop ; if ( prop == GUD_PROPERTY_BACKLIGHT_BRIGHTNESS ) { continue ; } property = gud_connector_property_lookup ( connector , prop ) ; if ( WARN_ON ( IS_ERR ( property ) ) ) { continue ; } state_val = gud_connector_tv_state_val ( prop , & gconn -> initial_tv_state ) ; if ( WARN_ON ( IS_ERR ( state_val ) ) ) { continue ; } * state_val = val ; drm_object_attach_property ( & connector -> base , property , 0 ) ; } out kfree ( properties ) ; return ret ; } 