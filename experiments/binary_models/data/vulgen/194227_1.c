static Symbol dcllocal ( int sclass , char * id , Type ty , Coordinate * pos ) { Symbol p , q ; if ( sclass == 0 ) { sclass = isfunc ( ty ) ?EXTERN : AUTO ; } if ( isfunc ( ty ) && sclass != EXTERN ) { error ( "invalid storage class `%k' for `%t %s'\n" , sclass , ty , id ) ; sclass = EXTERN ; } if ( sclass == REGISTER && ( isvolatile ( ty ) || isstruct ( ty ) || isarray ( ty ) ) ) { warning ( "register declaration ignored for `%t %s'\n" , ty , id ) ; sclass = AUTO ; } q = lookup ( id , identifiers ) ; if ( ( q && q -> scope >= level ) || ( q && q -> scope == PARAM && level == LOCAL ) ) { if ( sclass == EXTERN && q -> sclass == EXTERN && eqtype ( q -> type , ty , 1 ) ) { ty = compose ( ty , q -> type ) ; } else { error ( "redeclaration of `%s' previously declared at %w\n" , q -> name , & q -> src ) ; } } p = install ( id , & identifiers , level , sclass == STATIC || sclass == EXTERN ?PERM : FUNC ) ; p -> type = ty ; p -> sclass = sclass ; p -> src = * pos ; switch ( sclass ) { case EXTERN : q = lookup ( id , globals ) ; if ( q == NULL || q -> sclass == TYPEDEF || q -> sclass == ENUM ) { q = lookup ( id , externals ) ; if ( q == NULL ) { q = install ( p -> name , & externals , GLOBAL , PERM ) ; q -> type = p -> type ; q -> sclass = EXTERN ; q -> src = src ; * IR -> defsymbol ( q ) ; } } if ( ! eqtype ( p -> type , q -> type , 1 ) ) { warning ( "declaration of `%s' does not match previous declaration at %w\n" , q -> name , & q -> src ) ; } p -> u . alias = q ; break ; case STATIC : * IR -> defsymbol ( p ) ; initglobal ( p , 0 ) ; if ( ! p -> defined ) { if ( p -> type -> size > 0 ) { defglobal ( p , BSS ) ; * IR -> space ( p -> type -> size ) ; } else { error ( "undefined size for `%t %s'\n" , p -> type , p -> name ) ; } } p -> defined = 1 ; break ; case REGISTER : registers = append ( p , registers ) ; regcount ++ ; p -> defined = 1 ; break ; case AUTO : autos = append ( p , autos ) ; p -> defined = 1 ; break ; default : assert ( 0 ) ; } if ( t == '=' ) { Tree e ; if ( sclass == EXTERN ) { error ( "illegal initialization of `extern %s'\n" , id ) ; } t = gettok ( ) ; definept ( NULL ) ; if ( isscalar ( p -> type ) || ( isstruct ( p -> type ) && t != '{' ) ) { if ( t == '{' ) { t = gettok ( ) ; e = expr1 ( 0 ) ; expect ( '}' ) ; } else { e = expr1 ( 0 ) ; } } else { Symbol t1 ; Type ty = p -> type , ty1 = ty ; while ( isarray ( ty1 ) ) { ty1 = ty1 -> type ; } if ( ! isconst ( ty ) && ( ! isarray ( ty ) || ! isconst ( ty1 ) ) ) { ty = qual ( CONST , ty ) ; } t1 = genident ( STATIC , ty , GLOBAL ) ; initglobal ( t1 , 1 ) ; if ( isarray ( p -> type ) && p -> type -> size == 0 && t1 -> type -> size > 0 ) { p -> type = array ( p -> type -> type , t1 -> type -> size / t1 -> type -> type -> size , 0 ) ; } e = idtree ( t1 ) ; } walk ( root ( asgn ( p , e ) ) , 0 , 0 ) ; p -> ref = 1 ; } if ( ! isfunc ( p -> type ) && p -> defined && p -> type -> size <= 0 ) { error ( "undefined size for `%t %s'\n" , p -> type , id ) ; } return p ; } 