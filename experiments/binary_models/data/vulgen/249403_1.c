void bch_btree_verify ( struct btree * b ) { struct btree * v = b -> c -> verify_data ; struct bset * ondisk , * sorted , * inmemory ; struct bio * bio ; down ( & b -> io_mutex ) ; mutex_lock ( & b -> c -> verify_lock ) ; ondisk = b -> c -> verify_ondisk ; sorted = b -> c -> verify_data -> keys . set -> data ; inmemory = b -> keys . set -> data ; bkey_copy ( & v -> key , & b -> key ) ; v -> written = 0 ; v -> level = b -> level ; v -> keys . ops = b -> keys . ops ; bio = bch_bbio_alloc ( b -> c ) ; bio_set_dev ( bio , b -> c -> cache -> bdev ) ; bio -> bi_iter . bi_sector = PTR_OFFSET ( & b -> key , 0 ) ; bio -> bi_iter . bi_size = KEY_SIZE ( & v -> key ) << 9 ; bio -> bi_opf = REQ_OP_READ | REQ_META ; bch_bio_map ( bio , sorted ) ; submit_bio_wait ( bio ) ; bch_bbio_free ( bio , b -> c ) ; memcpy ( ondisk , sorted , KEY_SIZE ( & v -> key ) << 9 ) ; bch_btree_node_read_done ( v ) ; sorted = v -> keys . set -> data ; if ( inmemory -> keys != sorted -> keys || memcmp ( inmemory -> start , sorted -> start , ( void * ) bset_bkey_last ( inmemory ) - ( void * ) inmemory -> start ) ) { struct bset * i ; unsigned int j ; console_lock ( ) ; pr_err ( "*** in memory:\n" ) ; bch_dump_bset ( & b -> keys , inmemory , 0 ) ; pr_err ( "*** read back in:\n" ) ; bch_dump_bset ( & v -> keys , sorted , 0 ) ; for_each_written_bset ( , , ) { unsigned int block = ( ( void * ) i - ( void * ) ondisk ) / block_bytes ( b -> c -> cache ) ; pr_err ( "*** on disk block %u:\n" , block ) ; bch_dump_bset ( & b -> keys , i , block ) ; } pr_err ( "*** block %zu not written\n" , ( ( void * ) i - ( void * ) ondisk ) / block_bytes ( b -> c -> cache ) ) ; for ( j = 0 ; j < inmemory -> keys ; j ++ ) { if ( inmemory -> d [ j ] != sorted -> d [ j ] ) { break ; } } pr_err ( "b->written %u\n" , b -> written ) ; console_unlock ( ) ; panic ( "verify failed at %u\n" , j ) ; } mutex_unlock ( & b -> c -> verify_lock ) ; up ( & b -> io_mutex ) ; } 