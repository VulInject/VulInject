void mi_copyout ( queue_t * q , MBLKP mp ) { struct iocblk * iocp = ( iocblk * ) mp -> b_rptr ; struct copyreq * cq = ( copyreq * ) iocp ; struct copyresp * cp = ( copyresp * ) cq ; MBLKP mp1 ; MBLKP mp2 ; if ( mp -> b_datap -> db_type != M_IOCDATA || ! mp -> b_cont ) { mi_copy_done ( q , mp , EPROTO ) ; return ; } mp1 = mp -> b_cont ; if ( ( int ) ( uintptr_t ) cp -> cp_rval || ! mp1 -> b_cont ) { mi_copy_done ( q , mp , ( int ) ( uintptr_t ) cp -> cp_rval ) ; return ; } if ( ! mp1 -> b_cont -> b_cont && ! MI_IS_TRANSPARENT ( mp ) ) { mp1 -> b_next = NULL ; mp1 -> b_prev = NULL ; mp -> b_cont = mp1 -> b_cont ; freeb ( mp1 ) ; mp1 = mp -> b_cont ; mp1 -> b_next = NULL ; mp1 -> b_prev = NULL ; iocp -> ioc_count = mp1 -> b_wptr - mp1 -> b_rptr ; iocp -> ioc_error = 0 ; mp -> b_datap -> db_type = M_IOCACK ; qreply ( q , mp ) ; return ; } if ( MI_COPY_DIRECTION ( mp ) == MI_COPY_IN ) { MI_COPY_DIRECTION ( mp ) = MI_COPY_OUT ; MI_COPY_COUNT ( mp ) = 1 ; } else { ++ MI_COPY_COUNT ( mp ) ; } cq -> cq_private = mp1 ; for ( mp2 = mp1 ; mp2 -> b_cont -> b_cont ; mp2 = mp2 -> b_cont ) { } if ( mp2 == mp1 ) { bcopy ( ( char * ) mp1 -> b_rptr , ( char * ) & cq -> cq_addr , 0 ) ; } else { cq -> cq_addr = ( char * ) mp2 -> b_cont -> b_next ; } mp1 = mp2 -> b_cont ; mp -> b_datap -> db_type = M_COPYOUT ; mp -> b_cont = mp1 ; mp2 -> b_cont = NULL ; mp1 -> b_next = NULL ; cq -> cq_size = mp1 -> b_wptr - mp1 -> b_rptr ; cq -> cq_flag = 0 ; qreply ( q , mp ) ; } 