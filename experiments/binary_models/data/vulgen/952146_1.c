enum auth_stat _svcauth_des ( struct svc_req * rqst , struct rpc_msg * msg ) { int32_t * ixdr ; des_block cryptbuf [ 2 ] ; struct authdes_cred * cred ; struct authdes_verf verf ; int status ; des_block * sessionkey ; des_block ivec ; uint32_t window , winverf , namelen ; bool_t nick ; struct timeval timestamp , current_time ; struct authdes_cache_entry * nick_entry ; area { struct authdes_cred area_cred ; char area_netname [ MAXNETNAMELEN + 1 ] ; } , * area timestruc_t now ; mutex_enter ( & authdes_lock ) ; if ( authdes_cache == NULL ) { authdes_cache = kmem_zalloc ( sizeof ( authdes_cache_entry * ) * authdes_cachesz , KM_SLEEP ) ; } mutex_exit ( & authdes_lock ) ; CTASSERT ( sizeof ( area ) <= RQCRED_SIZE ) ; area = ( area * ) rqst -> rq_clntcred ; cred = ( authdes_cred * ) & area -> area_cred ; ixdr = ( int32_t * ) msg -> rm_call . cb_cred . oa_base ; cred -> adc_namekind = IXDR_GET_ENUM ( ixdr , authdes_namekind ) ; switch ( cred -> adc_namekind ) { case ADN_FULLNAME : namelen = IXDR_GET_U_INT32 ( ixdr ) ; if ( namelen > MAXNETNAMELEN ) { return ( AUTH_BADCRED ) ; } cred -> adc_fullname . name = area -> area_netname ; bcopy ( ixdr , cred -> adc_fullname . name , namelen ) ; cred -> adc_fullname . name [ namelen ] = 0 ; ixdr += ( RNDUP ( namelen ) / BYTES_PER_XDR_UNIT ) ; cred -> adc_fullname . key . key . high = ( uint32_t ) * ixdr ++ ; cred -> adc_fullname . key . key . low = ( uint32_t ) * ixdr ++ ; cred -> adc_fullname . window = ( uint32_t ) * ixdr ++ ; nick = FALSE ; break ; case ADN_NICKNAME : cred -> adc_nickname = ( uint32_t ) * ixdr ++ ; nick = TRUE ; break ; default : return ( AUTH_BADCRED ) ; } ixdr = ( int32_t * ) msg -> rm_call . cb_verf . oa_base ; verf . adv_xtimestamp . key . high = ( uint32_t ) * ixdr ++ ; verf . adv_xtimestamp . key . low = ( uint32_t ) * ixdr ++ ; verf . adv_int_u = ( uint32_t ) * ixdr ++ ; if ( ! nick ) { sessionkey = & cred -> adc_fullname . key ; if ( key_decryptsession ( cred -> adc_fullname . name , sessionkey ) != RPC_SUCCESS ) { return ( AUTH_BADCRED ) ; } } else { mutex_enter ( & authdes_lock ) ; if ( ! ( nick_entry = authdes_cache_get ( cred -> adc_nickname ) ) ) { RPCLOG ( 1 , "_svcauth_des: nickname %d not in the cache\n" , cred -> adc_nickname ) ; mutex_exit ( & authdes_lock ) ; return ( AUTH_BADCRED ) ; } sessionkey = & nick_entry -> key ; mutex_enter ( & nick_entry -> lock ) ; mutex_exit ( & authdes_lock ) ; } cryptbuf [ 0 ] = verf . adv_xtimestamp ; if ( ! nick ) { cryptbuf [ 1 ] . key . high = cred -> adc_fullname . window ; cryptbuf [ 1 ] . key . low = verf . adv_winverf ; ivec . key . high = ivec . key . low = 0 ; status = cbc_crypt ( ( char * ) sessionkey , ( char * ) cryptbuf , 2 * sizeof ( des_block ) , DES_DECRYPT , ( char * ) & ivec ) ; } else { status = ecb_crypt ( ( char * ) sessionkey , ( char * ) cryptbuf , sizeof ( des_block ) , DES_DECRYPT ) ; } if ( DES_FAILED ( status ) ) { RPCLOG0 ( 1 , "_svcauth_des: decryption failure\n" ) ; if ( nick ) { mutex_exit ( & nick_entry -> lock ) ; } return ( AUTH_FAILED ) ; } ixdr = ( int32_t * ) cryptbuf ; timestamp . tv_sec = IXDR_GET_INT32 ( ixdr ) ; timestamp . tv_usec = IXDR_GET_INT32 ( ixdr ) ; if ( ! nick ) { window = IXDR_GET_U_INT32 ( ixdr ) ; winverf = IXDR_GET_U_INT32 ( ixdr ) ; if ( winverf != window - 1 ) { RPCLOG ( 1 , "_svcauth_des: window verifier mismatch %d\n" , winverf ) ; return ( AUTH_BADCRED ) ; } } else { window = nick_entry -> window ; } if ( timestamp . tv_usec >= USEC_PER_SEC ) { RPCLOG ( 1 , "_svcauth_des: invalid usecs %ld\n" , timestamp . tv_usec ) ; if ( nick ) { mutex_exit ( & nick_entry -> lock ) ; } return ( nick ?AUTH_REJECTEDVERF : AUTH_BADVERF ) ; } gethrestime ( & now ) ; current_time . tv_sec = now . tv_sec ; current_time . tv_usec = now . tv_nsec / 1000 ; current_time . tv_sec -= window ; if ( ! BEFORE ( & current_time , & timestamp ) ) { RPCLOG0 ( 1 , "_svcauth_des: timestamp expired\n" ) ; if ( nick ) { mutex_exit ( & nick_entry -> lock ) ; } return ( nick ?AUTH_REJECTEDVERF : AUTH_BADCRED ) ; } ixdr = ( int32_t * ) cryptbuf ; IXDR_PUT_INT32 ( ixdr , timestamp . tv_sec - 1 ) ; IXDR_PUT_INT32 ( ixdr , timestamp . tv_usec ) ; status = ecb_crypt ( ( char * ) sessionkey , ( char * ) cryptbuf , sizeof ( des_block ) , DES_ENCRYPT ) ; if ( DES_FAILED ( status ) ) { RPCLOG0 ( 1 , "_svcauth_des: encryption failure\n" ) ; if ( nick ) { mutex_exit ( & nick_entry -> lock ) ; } return ( AUTH_FAILED ) ; } verf . adv_xtimestamp = cryptbuf [ 0 ] ; if ( ! nick ) { mutex_enter ( & authdes_lock ) ; if ( ! ( nick_entry = authdes_cache_new ( cred -> adc_fullname . name , sessionkey , window ) ) ) { RPCLOG0 ( 1 , "_svcauth_des: can not create new cache entry\n" ) ; mutex_exit ( & authdes_lock ) ; return ( AUTH_FAILED ) ; } mutex_enter ( & nick_entry -> lock ) ; mutex_exit ( & authdes_lock ) ; } verf . adv_nickname = nick_entry -> nickname ; ixdr = ( int32_t * ) msg -> rm_call . cb_verf . oa_base ; * ixdr ++ = ( int32_t ) verf . adv_xtimestamp . key . high ; * ixdr ++ = ( int32_t ) verf . adv_xtimestamp . key . low ; * ixdr ++ = ( int32_t ) verf . adv_int_u ; rqst -> rq_xprt -> xp_verf . oa_flavor = AUTH_DES ; rqst -> rq_xprt -> xp_verf . oa_base = msg -> rm_call . cb_verf . oa_base ; rqst -> rq_xprt -> xp_verf . oa_length = ( uint_t ) ( ( char * ) ixdr - msg -> rm_call . cb_verf . oa_base ) ; if ( ! nick ) { cred -> adc_nickname = nick_entry -> nickname ; cred -> adc_fullname . window = window ; } else { cred -> adc_namekind = ADN_FULLNAME ; cred -> adc_fullname . name = nick_entry -> rname ; cred -> adc_fullname . key = nick_entry -> key ; cred -> adc_fullname . window = nick_entry -> window ; } mutex_exit ( & nick_entry -> lock ) ; mutex_enter ( & authdes_lock ) ; if ( ( gethrestime_sec ( ) - authdes_last_swept ) > authdes_sweep_interval ) { sweep_cache ( ) ; } mutex_exit ( & authdes_lock ) ; return ( AUTH_OK ) ; } 