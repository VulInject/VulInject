static void tuner_status ( struct dvb_frontend * fe ) { struct tuner * t = fe -> analog_demod_priv ; unsigned long freq , freq_fraction ; struct dvb_tuner_ops * fe_tuner_ops = & fe -> ops . tuner_ops ; struct analog_demod_ops * analog_ops = & fe -> ops . analog_ops ; const char * p ; switch ( t -> mode ) { case V4L2_TUNER_RADIO : p = "radio" ; break ; case V4L2_TUNER_DIGITAL_TV : p = "digital TV" ; break ; case V4L2_TUNER_ANALOG_TV : default : p = "analog TV" ; break ; } if ( t -> mode == V4L2_TUNER_RADIO ) { freq = t -> radio_freq / 16000 ; freq_fraction = ( t -> radio_freq % 16000 ) * 100 / 16000 ; } else { freq = t -> tv_freq / 16 ; freq_fraction = ( t -> tv_freq % 16 ) * 100 / 16 ; } pr_info ( "Tuner mode:      %s%s\n" , p , t -> standby ?" on standby mode" : "" ) ; pr_info ( "Frequency:       %lu.%02lu MHz\n" , freq , freq_fraction ) ; pr_info ( "Standard:        0x%08lx\n" , ( unsigned long ) t -> std ) ; if ( t -> mode != V4L2_TUNER_RADIO ) { return ; } if ( fe_tuner_ops -> get_status ) { u32 tuner_status ; fe_tuner_ops -> get_status ( & t -> fe , & tuner_status ) ; if ( tuner_status & TUNER_STATUS_LOCKED ) { pr_info ( "Tuner is locked.\n" ) ; } } if ( analog_ops -> has_signal ) { u16 signal ; if ( ! analog_ops -> has_signal ( fe , & signal ) ) { pr_info ( "Signal strength: %hu\n" , signal ) ; } } } 