static void cxgb4_process_flow_match ( struct net_device * dev , struct flow_rule * rule , struct ch_filter_specification * fs ) { u16 addr_type ; if ( flow_rule_match_key ( rule , FLOW_DISSECTOR_KEY_CONTROL ) ) { struct flow_match_control match ; flow_rule_match_control ( rule , & match ) ; addr_type = match . key -> addr_type ; } if ( flow_rule_match_key ( rule , FLOW_DISSECTOR_KEY_IPV4_ADDRS ) ) { addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS ; } if ( flow_rule_match_key ( rule , FLOW_DISSECTOR_KEY_IPV6_ADDRS ) ) { addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS ; } if ( flow_rule_match_key ( rule , FLOW_DISSECTOR_KEY_BASIC ) ) { struct flow_match_basic match ; u16 ethtype_key , ethtype_mask ; flow_rule_match_basic ( rule , & match ) ; ethtype_key = ntohs ( match . key -> n_proto ) ; ethtype_mask = ntohs ( match . mask -> n_proto ) ; if ( ethtype_key == ETH_P_ALL ) { ethtype_key = 0 ; ethtype_mask = 0 ; } if ( ethtype_key == ETH_P_IPV6 ) { fs -> type = 1 ; } fs -> val . ethtype = ethtype_key ; fs -> mask . ethtype = ethtype_mask ; fs -> val . proto = match . key -> ip_proto ; fs -> mask . proto = match . mask -> ip_proto ; } if ( addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS ) { struct flow_match_ipv4_addrs match ; flow_rule_match_ipv4_addrs ( rule , & match ) ; fs -> type = 0 ; memcpy ( & fs -> val . lip [ 0 ] , & match . key -> dst , sizeof ( match . key -> dst ) ) ; memcpy ( & fs -> val . fip [ 0 ] , & match . key -> src , sizeof ( match . key -> src ) ) ; memcpy ( & fs -> mask . lip [ 0 ] , & match . mask -> dst , sizeof ( match . mask -> dst ) ) ; memcpy ( & fs -> mask . fip [ 0 ] , & match . mask -> src , sizeof ( match . mask -> src ) ) ; memcpy ( & fs -> nat_lip [ 0 ] , & match . key -> dst , sizeof ( match . key -> dst ) ) ; memcpy ( & fs -> nat_fip [ 0 ] , & match . key -> src , sizeof ( match . key -> src ) ) ; } if ( addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS ) { struct flow_match_ipv6_addrs match ; flow_rule_match_ipv6_addrs ( rule , & match ) ; fs -> type = 1 ; memcpy ( & fs -> val . lip [ 0 ] , match . key -> dst . s6_addr , sizeof ( match . key -> dst ) ) ; memcpy ( & fs -> val . fip [ 0 ] , match . key -> src . s6_addr , sizeof ( match . key -> src ) ) ; memcpy ( & fs -> mask . lip [ 0 ] , match . mask -> dst . s6_addr , sizeof ( match . mask -> dst ) ) ; memcpy ( & fs -> mask . fip [ 0 ] , match . mask -> src . s6_addr , sizeof ( match . mask -> src ) ) ; memcpy ( & fs -> nat_lip [ 0 ] , match . key -> dst . s6_addr , sizeof ( match . key -> dst ) ) ; memcpy ( & fs -> nat_fip [ 0 ] , match . key -> src . s6_addr , sizeof ( match . key -> src ) ) ; } if ( flow_rule_match_key ( rule , FLOW_DISSECTOR_KEY_PORTS ) ) { struct flow_match_ports match ; flow_rule_match_ports ( rule , & match ) ; fs -> val . lport = be16_to_cpu ( match . key -> dst ) ; fs -> mask . lport = be16_to_cpu ( match . mask -> dst ) ; fs -> val . fport = be16_to_cpu ( match . key -> src ) ; fs -> mask . fport = be16_to_cpu ( match . mask -> src ) ; fs -> nat_lport = fs -> val . lport ; fs -> nat_fport = fs -> val . fport ; } if ( flow_rule_match_key ( rule , FLOW_DISSECTOR_KEY_IP ) ) { struct flow_match_ip match ; flow_rule_match_ip ( rule , & match ) ; fs -> val . tos = match . key -> tos ; fs -> mask . tos = match . mask -> tos ; } if ( flow_rule_match_key ( rule , FLOW_DISSECTOR_KEY_ENC_KEYID ) ) { struct flow_match_enc_keyid match ; flow_rule_match_enc_keyid ( rule , & match ) ; fs -> val . vni = be32_to_cpu ( match . key -> keyid ) ; fs -> mask . vni = be32_to_cpu ( match . mask -> keyid ) ; if ( fs -> mask . vni ) { fs -> val . encap_vld = 1 ; fs -> mask . encap_vld = 1 ; } } if ( flow_rule_match_key ( rule , FLOW_DISSECTOR_KEY_VLAN ) ) { struct flow_match_vlan match ; u16 vlan_tci , vlan_tci_mask ; flow_rule_match_vlan ( rule , & match ) ; vlan_tci = match . key -> vlan_id | ( match . key -> vlan_priority << VLAN_PRIO_SHIFT ) ; vlan_tci_mask = match . mask -> vlan_id | ( match . mask -> vlan_priority << VLAN_PRIO_SHIFT ) ; fs -> val . ivlan = vlan_tci ; fs -> mask . ivlan = vlan_tci_mask ; fs -> val . ivlan_vld = 1 ; fs -> mask . ivlan_vld = 1 ; if ( fs -> val . ethtype == ETH_P_8021Q ) { fs -> val . ethtype = 0 ; fs -> mask . ethtype = 0 ; } } fs -> val . iport = netdev2pinfo ( dev ) -> port_id ; fs -> mask . iport = ~ 0 ; } 