static int clusterManagerCommandAddNode ( int argc , char * * argv ) { int success = 1 ; redisReply * reply = NULL ; redisReply * function_restore_reply = NULL ; redisReply * function_list_reply = NULL ; char * ref_ip = NULL , * ip = NULL ; int ref_port = 0 , port = 0 ; if ( ! getClusterHostFromCmdArgs ( argc - 1 , argv + 1 , & ref_ip , & ref_port ) ) { invalid_args } if ( ! getClusterHostFromCmdArgs ( 1 , argv , & ip , & port ) ) { invalid_args } clusterManagerLogInfo ( ">>>Adding node %s:%d to cluster %s:%d\n" , ip , port , ref_ip , ref_port ) ; clusterManagerNode * refnode = clusterManagerNewNode ( ref_ip , ref_port , 0 ) ; if ( ! clusterManagerLoadInfoFromNode ( refnode ) ) { return 0 ; } if ( ! clusterManagerCheckCluster ( 0 ) ) { return 0 ; } clusterManagerNode * master_node = NULL ; if ( config . cluster_manager_command . flags & CLUSTER_MANAGER_CMD_FLAG_SLAVE ) { char * master_id = config . cluster_manager_command . master_id ; if ( master_id != NULL ) { master_node = clusterManagerNodeByName ( master_id ) ; if ( master_node == NULL ) { clusterManagerLogErr ( "[ERR] No such master ID %s\n" , master_id ) ; return 0 ; } } else { master_node = clusterManagerNodeWithLeastReplicas ( ) ; assert ( master_node != NULL ) ; printf ( "Automatically selected master %s:%d\n" , master_node -> ip , master_node -> port ) ; } } clusterManagerNode * new_node = clusterManagerNewNode ( ip , port , 0 ) ; int added = 0 ; if ( ! clusterManagerNodeConnect ( new_node ) ) { clusterManagerLogErr ( "[ERR] Sorry, can't connect to node %s:%d\n" , ip , port ) ; success = 0 ; cleanup } char * err = NULL ; if ( ! ( success = clusterManagerNodeIsCluster ( new_node , & err ) ) ) { clusterManagerPrintNotClusterNodeError ( new_node , err ) ; if ( err ) { zfree ( err ) ; } cleanup } if ( ! clusterManagerNodeLoadInfo ( new_node , 0 , & err ) ) { if ( err ) { CLUSTER_MANAGER_PRINT_REPLY_ERROR ( new_node , err ) ; zfree ( err ) ; } success = 0 ; cleanup } if ( ! ( success = clusterManagerNodeIsEmpty ( new_node , & err ) ) ) { clusterManagerPrintNotEmptyNodeError ( new_node , err ) ; if ( err ) { zfree ( err ) ; } cleanup } clusterManagerNode * first = listFirst ( cluster_manager . nodes ) -> value ; listAddNodeTail ( cluster_manager . nodes , new_node ) ; added = 1 ; if ( ! master_node ) { clusterManagerLogInfo ( ">>>Getting functions from cluster\n" ) ; reply = CLUSTER_MANAGER_COMMAND ( refnode , "FUNCTION DUMP" ) ; if ( ! clusterManagerCheckRedisReply ( refnode , reply , & err ) ) { clusterManagerLogInfo ( ">>>Failed retrieving Functions from the cluster, " "skip this step as Redis version do not support function command (error = '%s')\n" , err ?err : "NULL reply" ) ; if ( err ) { zfree ( err ) ; } } else { assert ( reply -> type == REDIS_REPLY_STRING ) ; clusterManagerLogInfo ( ">>>Send FUNCTION LIST to %s:%d to verify there is no functions in it\n" , ip , port ) ; function_list_reply = CLUSTER_MANAGER_COMMAND ( new_node , "FUNCTION LIST" ) ; if ( ! clusterManagerCheckRedisReply ( new_node , function_list_reply , & err ) ) { clusterManagerLogErr ( ">>>Failed on CLUSTER LIST (error = '%s')\r\n" , err ?err : "NULL reply" ) ; if ( err ) { zfree ( err ) ; } success = 0 ; cleanup } assert ( function_list_reply -> type == REDIS_REPLY_ARRAY ) ; clusterManagerLogInfo ( ">>>Send FUNCTION RESTORE to %s:%d\n" , ip , port ) ; function_restore_reply = CLUSTER_MANAGER_COMMAND ( new_node , "FUNCTION RESTORE %b" , reply -> str , reply -> len ) ; if ( ! clusterManagerCheckRedisReply ( new_node , function_restore_reply , & err ) ) { clusterManagerLogErr ( ">>>Failed loading functions to the new node (error = '%s')\r\n" , err ?err : "NULL reply" ) ; if ( err ) { zfree ( err ) ; } success = 0 ; cleanup } } } if ( reply ) { freeReplyObject ( reply ) ; } clusterManagerLogInfo ( ">>>Send CLUSTER MEET to node %s:%d to make it " "join the cluster.\n" , ip , port ) ; char first_ip [ NET_IP_STR_LEN ] ; if ( anetResolve ( NULL , first -> ip , first_ip , sizeof ( first_ip ) , ANET_NONE ) == ANET_ERR ) { fprintf ( stderr , "Invalid IP address or hostname specified: %s\n" , first -> ip ) ; success = 0 ; cleanup } if ( first -> bus_port == 0 || ( first -> bus_port == first -> port + CLUSTER_MANAGER_PORT_INCR ) ) { reply = CLUSTER_MANAGER_COMMAND ( new_node , "CLUSTER MEET %s %d" , first_ip , first -> port ) ; } else { reply = CLUSTER_MANAGER_COMMAND ( new_node , "CLUSTER MEET %s %d %d" , first_ip , first -> port , first -> bus_port ) ; } if ( ! ( success = clusterManagerCheckRedisReply ( new_node , reply , NULL ) ) ) { cleanup } if ( master_node ) { sleep ( 1 ) ; clusterManagerWaitForClusterJoin ( ) ; clusterManagerLogInfo ( ">>>Configure node as replica of %s:%d.\n" , master_node -> ip , master_node -> port ) ; freeReplyObject ( reply ) ; reply = CLUSTER_MANAGER_COMMAND ( new_node , "CLUSTER REPLICATE %s" , master_node -> name ) ; if ( ! ( success = clusterManagerCheckRedisReply ( new_node , reply , NULL ) ) ) { cleanup } } clusterManagerLogOk ( "[OK] New node added correctly.\n" ) ; cleanup if ( ! added && new_node ) { freeClusterManagerNode ( new_node ) ; } if ( reply ) { freeReplyObject ( reply ) ; } if ( function_restore_reply ) { freeReplyObject ( function_restore_reply ) ; } if ( function_list_reply ) { freeReplyObject ( function_list_reply ) ; } return success ; invalid_args fprintf ( stderr , CLUSTER_MANAGER_INVALID_HOST_ARG ) ; return 0 ; } 