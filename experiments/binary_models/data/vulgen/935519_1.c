int main ( int argc , char * argv [ ] ) { char hostbuf [ 256 ] ; extern int optind ; extern char * optarg ; int i , c ; while ( ( c = getopt ( argc , argv , "h" ) ) != EOF ) { switch ( c ) { case 'h' : hflg ++ ; break ; default : usage ( ) ; exit ( 1 ) ; } } if ( optind < argc ) { for ( i = optind ; i < argc ; i ++ ) { pr_exports ( argv [ i ] ) ; } } else { if ( gethostname ( hostbuf , sizeof ( hostbuf ) ) < 0 ) { perror ( "nfs dfshares: gethostname" ) ; exit ( 1 ) ; } pr_exports ( hostbuf ) ; } return ( 0 ) ; } struct timeval rpc_totout_new = { 15 0 } ; void pr_exports ( host ) char * host ; { CLIENT * cl ; struct exportnode * ex = NULL ; enum clnt_stat err ; struct timeval tout , rpc_totout_old ; ( void ) __rpc_control ( CLCR_GET_RPCB_TIMEOUT , & rpc_totout_old ) ; ( void ) __rpc_control ( CLCR_SET_RPCB_TIMEOUT , & rpc_totout_new ) ; cl = clnt_create ( host , MOUNTPROG , MOUNTVERS , "circuit_n" ) ; if ( cl == NULL ) { if ( rpc_createerr . cf_stat == RPC_PROGNOTREGISTERED ) { cl = clnt_create ( host , MOUNTPROG , MOUNTVERS , "datagram_n" ) ; } if ( cl == NULL ) { ( void ) fprintf ( stderr , "nfs dfshares:" ) ; clnt_pcreateerror ( host ) ; ( void ) __rpc_control ( CLCR_SET_RPCB_TIMEOUT , & rpc_totout_old ) ; exit ( 1 ) ; } } ( void ) __rpc_control ( CLCR_SET_RPCB_TIMEOUT , & rpc_totout_old ) ; tout . tv_sec = 10 ; tout . tv_usec = 0 ; if ( err = clnt_call ( cl , MOUNTPROC_EXPORT , xdr_void , 0 , xdr_exports , ( caddr_t ) & ex , tout ) ) { ( void ) fprintf ( stderr , "nfs dfshares: %s\n" , clnt_sperrno ( err ) ) ; clnt_destroy ( cl ) ; exit ( 1 ) ; } if ( ! hflg ) { printf ( "%-35s %12s %-8s  %s\n" , "RESOURCE" , "SERVER" , "ACCESS" , "TRANSPORT" ) ; hflg ++ ; } while ( ex ) { printf ( "%10s:%-24s %12s %-8s  %s\n" , host , ex -> ex_dir , host , " -" , " -" ) ; ex = ex -> ex_next ; } free_ex ( ex ) ; clnt_destroy ( cl ) ; } 