static int tps65910_gpio_probe ( struct platform_device * pdev ) { struct tps65910 * tps65910 = dev_get_drvdata ( pdev -> dev . parent ) ; struct tps65910_board * pdata = dev_get_platdata ( tps65910 -> dev ) ; struct tps65910_gpio * tps65910_gpio ; int ret ; int i ; device_set_node ( & pdev -> dev , dev_fwnode ( pdev -> dev . parent ) ) ; tps65910_gpio = devm_kzalloc ( & pdev -> dev , sizeof ( * tps65910_gpio ) , GFP_KERNEL ) ; if ( ! tps65910_gpio ) { return - ENOMEM ; } tps65910_gpio -> gpio_chip . owner = THIS_MODULE ; tps65910_gpio -> gpio_chip . label = tps65910 -> i2c_client -> name ; switch ( tps65910_chip_id ( tps65910 ) ) { case TPS65910 : tps65910_gpio -> gpio_chip . ngpio = TPS65910_NUM_GPIO ; break ; case TPS65911 : tps65910_gpio -> gpio_chip . ngpio = TPS65911_NUM_GPIO ; break ; default : return - EINVAL ; } tps65910_gpio -> gpio_chip . can_sleep = true ; tps65910_gpio -> gpio_chip . direction_input = tps65910_gpio_input ; tps65910_gpio -> gpio_chip . direction_output = tps65910_gpio_output ; tps65910_gpio -> gpio_chip . set = tps65910_gpio_set ; tps65910_gpio -> gpio_chip . get = tps65910_gpio_get ; tps65910_gpio -> gpio_chip . parent = & pdev -> dev ; if ( pdata && pdata -> gpio_base ) { tps65910_gpio -> gpio_chip . base = pdata -> gpio_base ; } else { tps65910_gpio -> gpio_chip . base = - 1 ; } if ( ! pdata && tps65910 -> dev -> of_node ) { pdata = tps65910_parse_dt_for_gpio ( & pdev -> dev , tps65910 , tps65910_gpio -> gpio_chip . ngpio ) ; } if ( ! pdata ) { skip_init } for ( i = 0 ; i < tps65910_gpio -> gpio_chip . ngpio ; ++ i ) { if ( ! pdata -> en_gpio_sleep [ i ] ) { continue ; } ret = regmap_set_bits ( tps65910 -> regmap , TPS65910_GPIO0 + i , GPIO_SLEEP_MASK ) ; if ( ret < 0 ) { dev_warn ( tps65910 -> dev , "GPIO Sleep setting failed with err %d\n" , ret ) ; } } skip_init return devm_gpiochip_add_data ( & pdev -> dev , & tps65910_gpio -> gpio_chip , tps65910_gpio ) ; } 