static void acpi_ns_resolve_references ( struct acpi_evaluate_info * info ) { union acpi_operand_object * obj_desc = NULL ; struct acpi_namespace_node * node ; if ( ( info -> return_object ) -> common . type != ACPI_TYPE_LOCAL_REFERENCE ) { return ; } switch ( info -> return_object -> reference . class ) { case ACPI_REFCLASS_INDEX : obj_desc = * ( info -> return_object -> reference . where ) ; break ; case ACPI_REFCLASS_REFOF : node = info -> return_object -> reference . object ; if ( node ) { obj_desc = node -> object ; } break ; default : return ; } if ( obj_desc ) { acpi_ut_add_reference ( obj_desc ) ; acpi_ut_remove_reference ( info -> return_object ) ; info -> return_object = obj_desc ; } return ; } acpi_status acpi_walk_namespace ( acpi_object_type type , acpi_handle start_object , u32 max_depth , acpi_walk_callback descending_callback , acpi_walk_callback ascending_callback , void * context , void * * return_value ) { acpi_status status ; ACPI_FUNCTION_TRACE ( acpi_walk_namespace ) ; status = acpi_ut_acquire_read_lock ( & acpi_gbl_namespace_rw_lock ) ; if ( ACPI_FAILURE ( status ) ) { return_ACPI_STATUS ( status ) ; } status = acpi_ut_acquire_mutex ( ACPI_MTX_NAMESPACE ) ; if ( ACPI_FAILURE ( status ) ) { unlock_and_exit } if ( ! acpi_ns_validate_handle ( start_object ) ) { status = AE_BAD_PARAMETER ; unlock_and_exit2 } status = acpi_ns_walk_namespace ( type , start_object , max_depth , ACPI_NS_WALK_UNLOCK , descending_callback , ascending_callback , context , return_value ) ; unlock_and_exit2 ( void ) acpi_ut_release_mutex ( ACPI_MTX_NAMESPACE ) ; unlock_and_exit ( void ) acpi_ut_release_read_lock ( & acpi_gbl_namespace_rw_lock ) ; return_ACPI_STATUS ( status ) ; } 