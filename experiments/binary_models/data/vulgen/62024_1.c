static int isac_l1cmd ( struct dchannel * dch , u32 cmd ) { struct isac_hw * isac = container_of ( dch , isac_hw , dch ) ; u_long flags ; pr_debug ( "%s: cmd(%x) state(%02x)\n" , isac -> name , cmd , isac -> state ) ; switch ( cmd ) { case INFO3_P8 : spin_lock_irqsave ( isac -> hwlock , flags ) ; ph_command ( isac , ISAC_CMD_AR8 ) ; spin_unlock_irqrestore ( isac -> hwlock , flags ) ; break ; case INFO3_P10 : spin_lock_irqsave ( isac -> hwlock , flags ) ; ph_command ( isac , ISAC_CMD_AR10 ) ; spin_unlock_irqrestore ( isac -> hwlock , flags ) ; break ; case HW_RESET_REQ : spin_lock_irqsave ( isac -> hwlock , flags ) ; if ( ( isac -> state == ISAC_IND_EI ) || ( isac -> state == ISAC_IND_DR ) || ( isac -> state == ISAC_IND_DR6 ) || ( isac -> state == ISAC_IND_RS ) ) { ph_command ( isac , ISAC_CMD_TIM ) ; } else { ph_command ( isac , ISAC_CMD_RS ) ; } spin_unlock_irqrestore ( isac -> hwlock , flags ) ; break ; case HW_DEACT_REQ : skb_queue_purge ( & dch -> squeue ) ; dch -> tx_idx = 0 ; if ( dch -> rx_skb ) { dev_kfree_skb ( dch -> rx_skb ) ; dch -> rx_skb = NULL ; } test_and_clear_bit ( FLG_TX_BUSY , & dch -> Flags ) ; if ( test_and_clear_bit ( FLG_BUSY_TIMER , & dch -> Flags ) ) { del_timer ( & dch -> timer ) ; } break ; case HW_POWERUP_REQ : spin_lock_irqsave ( isac -> hwlock , flags ) ; ph_command ( isac , ISAC_CMD_TIM ) ; spin_unlock_irqrestore ( isac -> hwlock , flags ) ; break ; case PH_ACTIVATE_IND : test_and_set_bit ( FLG_ACTIVE , & dch -> Flags ) ; _queue_data ( & dch -> dev . D , cmd , MISDN_ID_ANY , 0 , NULL , GFP_ATOMIC ) ; break ; case PH_DEACTIVATE_IND : test_and_clear_bit ( FLG_ACTIVE , & dch -> Flags ) ; _queue_data ( & dch -> dev . D , cmd , MISDN_ID_ANY , 0 , NULL , GFP_ATOMIC ) ; break ; default : pr_debug ( "%s: %s unknown command %x\n" , isac -> name , __func__ , cmd ) ; return - 1 ; } return 0 ; } 