static void nhrp_shortcut_send_resolution_req ( struct nhrp_shortcut * s ) { struct zbuf * zb ; struct nhrp_packet_header * hdr ; struct interface * ifp ; struct nhrp_interface * nifp ; struct nhrp_afi_data * if_ad ; struct nhrp_peer * peer ; struct nhrp_cie_header * cie ; struct nhrp_extension_header * ext ; if ( nhrp_route_address ( NULL , & s -> addr , NULL , & peer ) != NHRP_ROUTE_NBMA_NEXTHOP ) { return ; } if ( s -> type == NHRP_CACHE_INVALID || s -> type == NHRP_CACHE_NEGATIVE ) { s -> type = NHRP_CACHE_INCOMPLETE ; } ifp = peer -> ifp ; nifp = ifp -> info ; zb = zbuf_alloc ( 1500 ) ; hdr = nhrp_packet_push ( zb , NHRP_PACKET_RESOLUTION_REQUEST , & nifp -> nbma , & nifp -> afi [ family2afi ( sockunion_family ( & s -> addr ) ) ] . addr , & s -> addr ) ; hdr -> u . request_id = htonl ( nhrp_reqid_alloc ( & nhrp_packet_reqid , & s -> reqid , nhrp_shortcut_recv_resolution_rep ) ) ; hdr -> flags = htons ( NHRP_FLAG_RESOLUTION_SOURCE_IS_ROUTER | NHRP_FLAG_RESOLUTION_AUTHORATIVE | NHRP_FLAG_RESOLUTION_SOURCE_STABLE ) ; cie = nhrp_cie_push ( zb , NHRP_CODE_SUCCESS , NULL , NULL ) ; if_ad = & nifp -> afi [ family2afi ( sockunion_family ( & s -> addr ) ) ] ; cie -> prefix_length = ( if_ad -> flags & NHRP_IFF_REG_NO_UNIQUE ) ?8 * sockunion_get_addrlen ( & s -> addr ) : 0xff ; cie -> holding_time = htons ( if_ad -> holdtime ) ; cie -> mtu = htons ( if_ad -> mtu ) ; debugf ( NHRP_DEBUG_COMMON , "Shortcut res_req: set cie ht to %u and mtu to %u. shortcut ht is %u" , ntohs ( cie -> holding_time ) , ntohs ( cie -> mtu ) , s -> holding_time ) ; nhrp_ext_request ( zb , hdr , ifp ) ; hdr -> flags |= htons ( NHRP_FLAG_RESOLUTION_NAT ) ; ext = nhrp_ext_push ( zb , hdr , NHRP_EXTENSION_NAT_ADDRESS ) ; nhrp_packet_complete ( zb , hdr ) ; nhrp_peer_send ( peer , zb ) ; nhrp_peer_unref ( peer ) ; zbuf_free ( zb ) ; } 