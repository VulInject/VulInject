void vfio_pci_write_config ( PCIDevice * pdev , uint32_t addr , uint32_t val , int len ) { VFIOPCIDevice * vdev = VFIO_PCI ( pdev ) ; uint32_t val_le = cpu_to_le32 ( val ) ; trace_vfio_pci_write_config ( vdev -> vbasedev . name , addr , val , len ) ; if ( pdev -> cap_present & QEMU_PCI_CAP_MSI && ranges_overlap ( addr , len , pdev -> msi_cap , vdev -> msi_cap_size ) ) { int is_enabled , was_enabled = msi_enabled ( pdev ) ; pci_default_write_config ( pdev , addr , val , len ) ; is_enabled = msi_enabled ( pdev ) ; if ( ! was_enabled ) { if ( is_enabled ) { vfio_msi_enable ( vdev ) ; } } else { if ( ! is_enabled ) { vfio_msi_disable ( vdev ) ; } else { vfio_update_msi ( vdev ) ; } } } if ( pdev -> cap_present & QEMU_PCI_CAP_MSIX && ranges_overlap ( addr , len , pdev -> msix_cap , MSIX_CAP_LENGTH ) ) { int is_enabled , was_enabled = msix_enabled ( pdev ) ; pci_default_write_config ( pdev , addr , val , len ) ; is_enabled = msix_enabled ( pdev ) ; if ( ! was_enabled && is_enabled ) { vfio_msix_enable ( vdev ) ; } if ( was_enabled && ! is_enabled ) { vfio_msix_disable ( vdev ) ; } } if ( ranges_overlap ( addr , len , PCI_BASE_ADDRESS_0 , 24 ) || range_covers_byte ( addr , len , PCI_COMMAND ) ) { pcibus_t old_addr [ PCI_NUM_REGIONS - 1 ] ; int bar ; for ( bar = 0 ; bar < PCI_ROM_SLOT ; bar ++ ) { old_addr [ bar ] = pdev -> io_regions [ bar ] . addr ; } pci_default_write_config ( pdev , addr , val , len ) ; for ( bar = 0 ; bar < PCI_ROM_SLOT ; bar ++ ) { if ( old_addr [ bar ] != pdev -> io_regions [ bar ] . addr && vdev -> bars [ bar ] . region . size > 0 && vdev -> bars [ bar ] . region . size < qemu_real_host_page_size ) { vfio_sub_page_bar_update_mapping ( pdev , bar ) ; } } } else { pci_default_write_config ( pdev , addr , val , len ) ; } } 