int sbd_pre_release_mem ( sbd_handle_t * hp , sbd_devlist_t devlist [ ] , int devnum ) { extern int kcage_on ; int d ; int err_flag = 0 ; sbd_board_t * sbp = SBDH2BD ( hp -> h_sbd ) ; sbderror_t * ep = SBD_HD2ERR ( hp ) ; sbderror_t * lep ; static fn_t f = "sbd_pre_release_mem" ; PR_MEM ( "%s...\n" , f ) ; if ( kcage_on == 0 ) { cmn_err ( CE_WARN , "%s: kernel cage is disabled" , f ) ; SBD_SET_ERR ( ep , ESBD_KCAGE_OFF ) ; return ( - 1 ) ; } for ( d = 0 ; d < devnum ; d ++ ) { int rv ; memquery_t mq ; sbd_mem_unit_t * mp ; struct memlist * ml ; ASSERT ( devlist [ d ] . dv_dip != NULL ) ; mp = SBD_GET_BOARD_MEMUNIT ( sbp , d ) ; if ( mp -> sbm_cm . sbdev_cond == SBD_COND_FAILED ) { SBD_SET_ERR ( ep , ESBD_STATE ) ; SBD_SET_ERRSTR ( ep , sbp -> sb_mempath [ d ] ) ; err_flag = - 1 ; break ; } ASSERT ( d == mp -> sbm_cm . sbdev_unum ) ; if ( mp -> sbm_interleave ) { SBD_SET_ERR ( ep , ESBD_MEMINTLV ) ; SBD_SET_ERRSTR ( ep , sbp -> sb_mempath [ d ] ) ; err_flag = - 1 ; break ; } lep = & devlist [ d ] . dv_error ; if ( SBD_GET_ERR ( lep ) != 0 ) { err_flag = - 1 ; ( void ) sbd_set_err_in_hdl ( hp , lep ) ; break ; } if ( mp -> sbm_flags & SBD_MFLAG_RESERVED ) { cmn_err ( CE_WARN , "%s: ineligible mem-unit (%d.%d) for detach" , f , sbp -> sb_num , mp -> sbm_cm . sbdev_unum ) ; SBD_SET_ERR ( lep , ESBD_INVAL ) ; SBD_SET_ERRSTR ( lep , sbp -> sb_mempath [ d ] ) ; ( void ) sbd_set_err_in_hdl ( hp , lep ) ; err_flag = - 1 ; break ; } ASSERT ( mp -> sbm_npages != 0 ) ; rv = kphysm_del_span_query ( mp -> sbm_basepfn , mp -> sbm_npages , & mq ) ; if ( rv != KPHYSM_OK ) { cmn_err ( CE_WARN , "%s: unexpected kphysm_del_span_query" " return value %d;" " basepfn 0x%lx, npages 0x%lx," " mem-unit (%d.%d), dip 0x%p" , f , rv , mp -> sbm_basepfn , mp -> sbm_npages , sbp -> sb_num , mp -> sbm_cm . sbdev_unum , ( void * ) mp -> sbm_cm . sbdev_dip ) ; SBD_SET_ERR ( lep , ESBD_INTERNAL ) ; SBD_SET_ERRSTR ( lep , sbp -> sb_mempath [ d ] ) ; ( void ) sbd_set_err_in_hdl ( hp , lep ) ; err_flag = - 1 ; break ; } if ( mq . nonrelocatable != 0 ) { if ( ! ( hp -> h_iap -> i_flags & SBD_FLAG_QUIESCE_OKAY ) ) { SBD_SET_ERR ( lep , ESBD_QUIESCE_REQD ) ; SBD_SET_ERRSTR ( lep , sbp -> sb_mempath [ d ] ) ; ( void ) sbd_set_err_in_hdl ( hp , lep ) ; err_flag = 1 ; break ; } } ASSERT ( mp -> sbm_flags == 0 ) ; ASSERT ( mp -> sbm_del_mlist == NULL ) ; if ( mp -> sbm_mlist != NULL ) { memlist_delete ( mp -> sbm_mlist ) ; mp -> sbm_mlist = NULL ; } ml = sbd_get_memlist ( mp , lep ) ; ( void ) sbd_set_err_in_hdl ( hp , lep ) ; if ( ml == NULL ) { PR_MEM ( "%s: no memlist found for board %d\n" , f , sbp -> sb_num ) ; err_flag = - 1 ; break ; } rv = kphysm_del_gethandle ( & mp -> sbm_memhandle ) ; if ( rv != KPHYSM_OK ) { memlist_delete ( ml ) ; cmn_err ( CE_WARN , "%s: unexpected kphysm_del_gethandle" " return value %d" , f , rv ) ; SBD_SET_ERR ( lep , ESBD_INTERNAL ) ; SBD_SET_ERRSTR ( lep , sbp -> sb_mempath [ d ] ) ; ( void ) sbd_set_err_in_hdl ( hp , lep ) ; err_flag = - 1 ; break ; } mp -> sbm_flags |= SBD_MFLAG_RELOWNER ; if ( ( mq . nonrelocatable != 0 ) || sbd_reserve_mem_spans ( & mp -> sbm_memhandle , ml ) ) { if ( sbd_select_mem_target ( hp , mp , ml ) ) { int rv ; rv = kphysm_del_release ( mp -> sbm_memhandle ) ; mp -> sbm_flags &= ~ SBD_MFLAG_RELOWNER ; memlist_delete ( ml ) ; ASSERT ( mp -> sbm_flags == 0 ) ; cmn_err ( CE_WARN , "%s: no available target for " "mem-unit (%d.%d)" , f , sbp -> sb_num , mp -> sbm_cm . sbdev_unum ) ; SBD_SET_ERR ( lep , ESBD_NO_TARGET ) ; SBD_SET_ERRSTR ( lep , sbp -> sb_mempath [ mp -> sbm_cm . sbdev_unum ] ) ; ( void ) sbd_set_err_in_hdl ( hp , lep ) ; err_flag = - 1 ; break ; } } else { mp -> sbm_flags |= SBD_MFLAG_RESERVED ; mp -> sbm_peer = NULL ; mp -> sbm_del_mlist = ml ; mp -> sbm_mlist = ml ; mp -> sbm_cm . sbdev_busy = 1 ; } ASSERT ( mp -> sbm_mlist != NULL ) ; if ( mp -> sbm_flags & SBD_MFLAG_SOURCE ) { int src , targ ; sbp = ( sbd_board_t * ) mp -> sbm_peer -> sbm_cm . sbdev_sbp ; targ = sbp -> sb_num ; sbp = ( sbd_board_t * ) mp -> sbm_cm . sbdev_sbp ; src = sbp -> sb_num ; PR_MEM ( "%s: release of board %d requires copy/rename;" " selected target board %d\n" , f , src , targ ) ; } else { sbp = ( sbd_board_t * ) mp -> sbm_cm . sbdev_sbp ; PR_MEM ( "%s: copy/rename not required to release" " board %d\n" , f , sbp -> sb_num ) ; } ASSERT ( mp -> sbm_flags & SBD_MFLAG_RELOWNER ) ; ASSERT ( mp -> sbm_flags & SBD_MFLAG_RESERVED ) ; } return ( err_flag ) ; } 