static int __erase_worker ( struct ubi_device * ubi , struct ubi_work * wl_wrk ) { struct ubi_wl_entry * e = wl_wrk -> e ; int pnum = e -> pnum ; int vol_id = wl_wrk -> vol_id ; int lnum = wl_wrk -> lnum ; int err , available_consumed = 0 ; dbg_wl ( "erase PEB %d EC %d LEB %d:%d" , pnum , e -> ec , wl_wrk -> vol_id , wl_wrk -> lnum ) ; err = sync_erase ( ubi , e , wl_wrk -> torture ) ; if ( ! err ) { spin_lock ( & ubi -> wl_lock ) ; if ( ! ubi -> fm_disabled && ! ubi -> fm_anchor && e -> pnum < UBI_FM_MAX_START ) { ubi -> fm_anchor = e ; ubi -> fm_do_produce_anchor = 0 ; } else { wl_tree_add ( e , & ubi -> free ) ; ubi -> free_count ++ ; } spin_unlock ( & ubi -> wl_lock ) ; serve_prot_queue ( ubi ) ; err = ensure_wear_leveling ( ubi , 1 ) ; return err ; } ubi_err ( ubi , "failed to erase PEB %d, error %d" , pnum , err ) ; if ( err == - EINTR || err == - ENOMEM || err == - EAGAIN || err == - EBUSY ) { int err1 ; err1 = schedule_erase ( ubi , e , vol_id , lnum , 0 , false ) ; if ( err1 ) { wl_entry_destroy ( ubi , e ) ; err = err1 ; out_ro } return err ; } wl_entry_destroy ( ubi , e ) ; if ( err != - EIO ) { out_ro } if ( ! ubi -> bad_allowed ) { ubi_err ( ubi , "bad physical eraseblock %d detected" , pnum ) ; out_ro } spin_lock ( & ubi -> volumes_lock ) ; if ( ubi -> beb_rsvd_pebs == 0 ) { if ( ubi -> avail_pebs == 0 ) { spin_unlock ( & ubi -> volumes_lock ) ; ubi_err ( ubi , "no reserved/available physical eraseblocks" ) ; out_ro } ubi -> avail_pebs -= 1 ; available_consumed = 1 ; } spin_unlock ( & ubi -> volumes_lock ) ; ubi_msg ( ubi , "mark PEB %d as bad" , pnum ) ; err = ubi_io_mark_bad ( ubi , pnum ) ; if ( err ) { out_ro } spin_lock ( & ubi -> volumes_lock ) ; ubi -> bad_peb_count += 1 ; ubi -> good_peb_count -= 1 ; ubi_calculate_reserved ( ubi ) ; if ( available_consumed ) { ubi_warn ( ubi , "no PEBs in the reserved pool, used an available PEB" ) ; } if ( ubi -> beb_rsvd_pebs ) { ubi_msg ( ubi , "%d PEBs left in the reserve" , ubi -> beb_rsvd_pebs ) ; } else { ubi_warn ( ubi , "last PEB from the reserve was used" ) ; } spin_unlock ( & ubi -> volumes_lock ) ; return err ; out_ro if ( available_consumed ) { spin_lock ( & ubi -> volumes_lock ) ; ubi -> avail_pebs += 1 ; spin_unlock ( & ubi -> volumes_lock ) ; } ubi_ro_mode ( ubi ) ; return err ; } 