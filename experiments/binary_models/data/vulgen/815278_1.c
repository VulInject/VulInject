void gena_process_subscription_request ( SOCKINFO * info , http_message_t * request ) { UpnpSubscriptionRequest * request_struct = UpnpSubscriptionRequest_new ( ) ; Upnp_SID temp_sid ; int return_code = 1 ; int time_out = 1801 ; service_info * service ; subscription * sub ; uuid_upnp uid ; struct Handle_Info * handle_info ; void * cookie ; Upnp_FunPtr callback_fun ; UpnpDevice_Handle device_handle ; memptr nt_hdr ; char * event_url_path = NULL ; memptr callback_hdr ; memptr timeout_hdr ; int rc = 0 ; UpnpPrintf ( UPNP_INFO , GENA , __FILE__ , __LINE__ , "Subscription Request Received:\n" ) ; if ( httpmsg_find_hdr ( request , HDR_NT , & nt_hdr ) == NULL ) { error_respond ( info , HTTP_BAD_REQUEST , request ) ; exit_function } if ( memptr_cmp_nocase ( & nt_hdr , "upnp:event" ) != 0 ) { error_respond ( info , HTTP_PRECONDITION_FAILED , request ) ; exit_function } if ( httpmsg_find_hdr ( request , HDR_SID , NULL ) != NULL ) { error_respond ( info , HTTP_BAD_REQUEST , request ) ; exit_function } event_url_path = str_alloc ( request -> uri . pathquery . buff , request -> uri . pathquery . size ) ; if ( event_url_path == NULL ) { error_respond ( info , HTTP_INTERNAL_SERVER_ERROR , request ) ; exit_function } UpnpPrintf ( UPNP_INFO , GENA , __FILE__ , __LINE__ , "SubscriptionRequest for event URL path: %s\n" , event_url_path ) ; HandleLock ( ) ; if ( GetDeviceHandleInfo ( info -> foreign_sockaddr . ss_family , & device_handle , & handle_info ) != HND_DEVICE ) { error_respond ( info , HTTP_INTERNAL_SERVER_ERROR , request ) ; HandleUnlock ( ) ; exit_function } service = FindServiceEventURLPath ( & handle_info -> ServiceTable , event_url_path ) ; free ( event_url_path ) ; if ( service == NULL || ! service -> active ) { error_respond ( info , HTTP_NOT_FOUND , request ) ; HandleUnlock ( ) ; exit_function } UpnpPrintf ( UPNP_INFO , GENA , __FILE__ , __LINE__ , "Subscription Request: Number of Subscriptions already %d\n " "Max Subscriptions allowed: %d\n" , service -> TotalSubscriptions , handle_info -> MaxSubscriptions ) ; if ( handle_info -> MaxSubscriptions != - 1 && service -> TotalSubscriptions >= handle_info -> MaxSubscriptions ) { error_respond ( info , HTTP_INTERNAL_SERVER_ERROR , request ) ; HandleUnlock ( ) ; exit_function } sub = ( subscription * ) malloc ( sizeof ( subscription ) ) ; if ( sub == NULL ) { error_respond ( info , HTTP_INTERNAL_SERVER_ERROR , request ) ; HandleUnlock ( ) ; exit_function } sub -> eventKey = 0 ; sub -> ToSendEventKey = 0 ; sub -> active = 0 ; sub -> next = NULL ; sub -> DeliveryURLs . size = 0 ; sub -> DeliveryURLs . URLs = NULL ; sub -> DeliveryURLs . parsedURLs = NULL ; if ( httpmsg_find_hdr ( request , HDR_CALLBACK , & callback_hdr ) == NULL ) { error_respond ( info , HTTP_PRECONDITION_FAILED , request ) ; freeSubscriptionList ( sub ) ; HandleUnlock ( ) ; exit_function } return_code = create_url_list ( & callback_hdr , & sub -> DeliveryURLs ) ; if ( return_code == 0 ) { error_respond ( info , HTTP_PRECONDITION_FAILED , request ) ; freeSubscriptionList ( sub ) ; HandleUnlock ( ) ; exit_function } if ( return_code == UPNP_E_OUTOF_MEMORY ) { error_respond ( info , HTTP_INTERNAL_SERVER_ERROR , request ) ; freeSubscriptionList ( sub ) ; HandleUnlock ( ) ; exit_function } if ( httpmsg_find_hdr ( request , HDR_TIMEOUT , & timeout_hdr ) != NULL ) { if ( matchstr ( timeout_hdr . buf , timeout_hdr . length , "%iSecond-%d%0" , & time_out ) == PARSE_OK ) { } if ( memptr_cmp_nocase ( & timeout_hdr , "Second-infinite" ) == 0 ) { time_out = - 1 ; } else { time_out = DEFAULT_TIMEOUT ; } } if ( handle_info -> MaxSubscriptionTimeOut != - 1 ) { if ( time_out == - 1 || time_out > handle_info -> MaxSubscriptionTimeOut ) { time_out = handle_info -> MaxSubscriptionTimeOut ; } } if ( time_out >= 0 ) { sub -> expireTime = time ( NULL ) + time_out ; } else { sub -> expireTime = 0 ; } uuid_create ( & uid ) ; uuid_unpack ( & uid , temp_sid ) ; rc = snprintf ( sub -> sid , sizeof ( sub -> sid ) , "uuid:%s" , temp_sid ) ; if ( rc < 0 || ( unsigned int ) rc >= sizeof ( sub -> sid ) || ( respond_ok ( info , time_out , sub , request ) != UPNP_E_SUCCESS ) ) { freeSubscriptionList ( sub ) ; HandleUnlock ( ) ; exit_function } sub -> next = service -> subscriptionList ; service -> subscriptionList = sub ; service -> TotalSubscriptions ++ ; UpnpSubscriptionRequest_strcpy_ServiceId ( request_struct , service -> serviceId ) ; UpnpSubscriptionRequest_strcpy_UDN ( request_struct , service -> UDN ) ; UpnpSubscriptionRequest_strcpy_SID ( request_struct , sub -> sid ) ; callback_fun = handle_info -> Callback ; cookie = handle_info -> Cookie ; HandleUnlock ( ) ; callback_fun ( UPNP_EVENT_SUBSCRIPTION_REQUEST , request_struct , cookie ) ; exit_function UpnpSubscriptionRequest_delete ( request_struct ) ; } 