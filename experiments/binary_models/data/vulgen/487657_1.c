JU_LEAF_UPLEVEL ( 1 , uint16_t * , cJU_LEAF2_MAXPOP1 , cJU_JPLEAF2 , j__udyLeaf1ToLeaf2 , j__udyAllocJLL2 , JL_LEAF2VALUEAREA ) ; if ( ( pop1 - 1 ) == cJU_IMMED1_MAXPOP1 ) { Pjlb_t PjlbRaw ; Pjlb_t Pjlb ; uint8_t * Pleafnew ; Word_t ldigit ; PjlbRaw = ( Pjlb_t ) ( Pjp -> jp_Addr ) ; Pjlb = P_JLB ( PjlbRaw ) ; Pleafnew = Pjp -> jp_1Index ; JU_BITMAPCLEARL ( Pjlb , Index ) ; for ( ldigit = 0 ; ldigit < cJU_BRANCHUNUMJPS ; ++ ldigit ) { if ( JU_BITMAPTESTL ( Pjlb , ldigit ) ) { * Pleafnew ++ = ldigit ; assert ( Pleafnew - ( Pjp -> jp_1Index ) <= cJU_IMMED1_MAXPOP1 ) ; } } DBGCODE ( 1 ) j__udyFreeJLB1 ( PjlbRaw , Pjpm ) ; Pjp -> jp_Type = cJ1_JPIMMED_1_15 ; return ( 1 ) ; } if ( pop1 == cJU_LEAF1_MAXPOP1 ) { if ( j__udyLeafB1ToLeaf1 ( Pjp , Pjpm ) == - 1 ) { return ( - 1 ) ; } ContinueDelWalk } JU_BITMAPCLEARL ( P_JLB ( Pjp -> jp_Addr ) , Index ) ; digit = JU_DIGITATSTATE ( Index , 1 ) ; Pjlb = P_JLB ( Pjp -> jp_Addr ) ; subexp = digit / cJU_BITSPERSUBEXPL ; bitmap = JU_JLB_BITMAP ( Pjlb , subexp ) ; PjvRaw = JL_JLB_PVALUE ( Pjlb , subexp ) ; Pjv = P_JV ( PjvRaw ) ; bitmask = JU_BITPOSMASKL ( digit ) ; assert ( bitmap & bitmask ) ; if ( bitmap == cJU_FULLBITMAPL ) { pop1 = cJU_BITSPERSUBEXPL ; offset = digit % cJU_BITSPERSUBEXPL ; } else { pop1 = j__udyCountBitsL ( bitmap ) ; offset = j__udyCountBitsL ( bitmap & ( bitmask - 1 ) ) ; } if ( JL_LEAFVGROWINPLACE ( pop1 - 1 ) ) { JU_DELETEINPLACE ( Pjv , pop1 , offset , ignore ) ; } else { if ( ( PjvnewRaw = j__udyLAllocJV ( pop1 - 1 , Pjpm ) ) == ( Pjv_t ) NULL ) { return ( - 1 ) ; } Pjvnew = P_JV ( PjvnewRaw ) ; JU_DELETECOPY ( Pjvnew , Pjv , pop1 , offset , ignore ) ; j__udyLFreeJV ( PjvRaw , pop1 , Pjpm ) ; JL_JLB_PVALUE ( Pjlb , subexp ) = ( Pjv_t ) PjvnewRaw ; } JU_JLB_BITMAP ( Pjlb , subexp ) ^= bitmask ; return ( 1 ) ; cJ1_JPFULLPOPU1 { Pjlb_t PjlbRaw ; Pjlb_t Pjlb ; Word_t subexp ; assert ( ! JU_DCDNOTMATCHINDEX ( Index , Pjp , 2 ) ) ; assert ( ParentLevel > 1 ) ; if ( ( PjlbRaw = j__udyAllocJLB1 ( Pjpm ) ) == ( Pjlb_t ) NULL ) { return ( - 1 ) ; } Pjlb = P_JLB ( PjlbRaw ) ; for ( subexp = 0 ; subexp < cJU_NUMSUBEXPL ; ++ subexp ) { JU_JLB_BITMAP ( Pjlb , subexp ) = cJU_FULLBITMAPL ; } JU_BITMAPCLEARL ( Pjlb , Index ) ; Pjp -> jp_Addr = ( Word_t ) PjlbRaw ; Pjp -> jp_Type = cJU_JPLEAF_B1 ; return ( 1 ) ; } assert ( parentJPtype == ( ParentJPType ) ) ; assert ( JU_JPDCDPOP0 ( Pjp ) == JU_TRIMTODCDSIZE ( Index ) ) ; JU_JPSETADT ( Pjp , 0 , 0 , NewJPType ) ; return ( 1 ) { LeafType Pleaf assert ( ( ParentLevel - 1 ) == ( cIS ) ) JUDY1CODE ( ) JUDYLCODE ( ) JUDYLCODE ( ) JUDYLCODE ( ) JU_TOIMMED_01_EVEN ( cIS , ignore , ignore ) JUDYLCODE ( 2 ) Pjp -> jp_Type = ( NewJPType ) return ( 1 ) ; } ; { uint8_t * Pleaf ; assert ( ( ParentLevel - 1 ) == ( cIS ) ) ; JUDY1CODE ( ) JUDYLCODE ( ) JUDYLCODE ( ) JUDYLCODE ( ) JU_TOIMMED_01_ODD ( cIS , SearchLeaf , CopyPIndex ) ; JUDYLCODE ( 2 ) Pjp -> jp_Type = ( NewJPType ) ; return ( 1 ) ; } DeleteInPlace ( Pleaf , pop1 , offset , cIS ) ; DBGCODE ( 1 ) if ( JL_LEAFVGROWINPLACE ( pop1 - 1 ) ) { DeleteInPlace ( Pleaf , pop1 , offset , cIS ) ; JU_DELETEINPLACE ( Pjv , pop1 , offset , ignore ) ; DBGCODE ( 1 ) } else { Pjv_t PjvnewRaw ; Pjv_t Pjvnew ; if ( ( PjvnewRaw = j__udyLAllocJV ( pop1 - 1 , Pjpm ) ) == ( Pjv_t ) NULL ) { return ( - 1 ) ; } Pjvnew = P_JV ( PjvnewRaw ) ; DeleteInPlace ( Pleaf , pop1 , offset , cIS ) ; JU_DELETECOPY ( Pjvnew , Pjv , pop1 , offset , ignore ) ; DBGCODE ( 1 ) j__udyLFreeJV ( PjvRaw , pop1 , Pjpm ) ; ( Pjp -> jp_Addr ) = ( Word_t ) PjvnewRaw ; } { LeafType Pleaf ; assert ( ( ParentLevel - 1 ) == ( cIS ) ) ; JUDY1CODE ( ) JUDYLCODE ( ) JUDYLCODE ( ) JUDYLCODE ( ) pop1 = ( JU_JPTYPE ( Pjp ) ) - ( BaseJPType ) + 2 ; offset = SearchLeaf ( Pleaf , pop1 , Index ) ; assert ( offset >= 0 ) ; JU_IMMED_DEL ( cIS , DeleteInPlace ) ; -- ( Pjp -> jp_Type ) ; return ( 1 ) ; } case cJU_JPIMMED_1_01 : JU_IMMED_01 ( cJU_JPNULL1 , cJU_JPBRANCH_U2 ) ; case cJU_JPIMMED_2_01 : JU_IMMED_01 ( cJU_JPNULL2 , cJU_JPBRANCH_U3 ) ; case cJU_JPIMMED_3_01 : JU_IMMED_01 ( cJU_JPNULL3 , cJU_JPBRANCH_U ) ; case cJU_JPIMMED_3_01 : JU_IMMED_01 ( cJU_JPNULL3 , cJU_JPBRANCH_U4 ) ; case cJU_JPIMMED_4_01 : JU_IMMED_01 ( cJU_JPNULL4 , cJU_JPBRANCH_U5 ) ; case cJU_JPIMMED_5_01 : JU_IMMED_01 ( cJU_JPNULL5 , cJU_JPBRANCH_U6 ) ; case cJU_JPIMMED_6_01 : JU_IMMED_01 ( cJU_JPNULL6 , cJU_JPBRANCH_U7 ) ; case cJU_JPIMMED_7_01 : JU_IMMED_01 ( cJU_JPNULL7 , cJU_JPBRANCH_U ) ; case cJU_JPIMMED_1_02 : JU_IMMED_02 ( 1 , uint8_t * , cJU_JPIMMED_1_01 ) ; case cJU_JPIMMED_1_03 : case cJU_JPIMMED_1_04 : case cJU_JPIMMED_1_05 : case cJU_JPIMMED_1_06 : case cJU_JPIMMED_1_07 : case cJ1_JPIMMED_1_08 : case cJ1_JPIMMED_1_09 : case cJ1_JPIMMED_1_10 : case cJ1_JPIMMED_1_11 : case cJ1_JPIMMED_1_12 : case cJ1_JPIMMED_1_13 : case cJ1_JPIMMED_1_14 : case cJ1_JPIMMED_1_15 : JU_IMMED ( 1 , uint8_t * , cJU_JPIMMED_1_02 , j__udySearchLeaf1 , JU_DELETEINPLACE ) ; case cJU_JPIMMED_2_02 : JU_IMMED_02 ( 2 , uint16_t * , cJU_JPIMMED_2_01 ) ; case cJU_JPIMMED_2_03 : case cJ1_JPIMMED_2_04 : case cJ1_JPIMMED_2_05 : case cJ1_JPIMMED_2_06 : case cJ1_JPIMMED_2_07 : JU_IMMED ( 2 , uint16_t * , cJU_JPIMMED_2_02 , j__udySearchLeaf2 , JU_DELETEINPLACE ) ; case cJU_JPIMMED_3_02 : JU_IMMED_02_ODD ( 3 , cJU_JPIMMED_3_01 , j__udySearchLeaf3 , JU_COPY3_PINDEX_TO_LONG ) ; case cJ1_JPIMMED_3_03 : case cJ1_JPIMMED_3_04 : case cJ1_JPIMMED_3_05 : JU_IMMED ( 3 , uint8_t * , cJU_JPIMMED_3_02 , j__udySearchLeaf3 , JU_DELETEINPLACE_ODD ) ; case cJ1_JPIMMED_4_02 : JU_IMMED_02 ( 4 , uint32_t * , cJU_JPIMMED_4_01 ) ; case cJ1_JPIMMED_4_03 : JU_IMMED ( 4 , uint32_t * , cJ1_JPIMMED_4_02 , j__udySearchLeaf4 , JU_DELETEINPLACE ) ; case cJ1_JPIMMED_5_02 : JU_IMMED_02_ODD ( 5 , cJU_JPIMMED_5_01 , j__udySearchLeaf5 , JU_COPY5_PINDEX_TO_LONG ) ; case cJ1_JPIMMED_5_03 : JU_IMMED ( 5 , uint8_t * , cJ1_JPIMMED_5_02 , j__udySearchLeaf5 , JU_DELETEINPLACE_ODD ) ; case cJ1_JPIMMED_6_02 : JU_IMMED_02_ODD ( 6 , cJU_JPIMMED_6_01 , j__udySearchLeaf6 , JU_COPY6_PINDEX_TO_LONG ) ; case cJ1_JPIMMED_7_02 : JU_IMMED_02_ODD ( 7 , cJU_JPIMMED_7_01 , j__udySearchLeaf7 , JU_COPY7_PINDEX_TO_LONG ) ; default : JU_SET_ERRNO_NONNULL ( Pjpm , JU_ERRNO_CORRUPT ) ; return ( - 1 ) ; ( level ) ; retcode = j__udyDelWalk ( Pjp , Index , level , Pjpm ) ; assert ( retcode != 0 ) ; if ( ( JU_JPTYPE ( Pjp ) ) < cJU_JPIMMED_1_01 ) { switch ( retcode ) { case 1 : { jp_t JP = * Pjp ; Word_t DcdP0 ; DcdP0 = JU_JPDCDPOP0 ( Pjp ) - 1 ; JU_JPSETADT ( Pjp , JP . jp_Addr , DcdP0 , JU_JPTYPE ( & JP ) ) ; break ; } case 2 : { Pjbl_t PjblRaw = ( Pjbl_t ) ( Pjp -> jp_Addr ) ; Pjbl_t Pjbl = P_JBL ( PjblRaw ) ; * Pjp = Pjbl -> jbl_jp [ 0 ] ; j__udyFreeJBL ( PjblRaw , Pjpm ) ; retcode = 1 ; } } } return ( retcode ) ; 