decimal64 * decimal64FromNumber ( decimal64 * d64 , const decNumber * dn , decContext * set ) { uInt status = 0 ; Int pad = 0 ; decNumber dw ; decContext dc ; uByte isneg = dn -> bits & DECNEG ; uInt comb , exp ; if ( ! ( dn -> bits & DECSPECIAL ) ) { Int ae = dn -> exponent + dn -> digits - 1 ; if ( dn -> digits > DECIMAL64_Pmax || ae > DECIMAL64_Emax || ae < DECIMAL64_Emin ) { decContextDefault ( & dc , DEC_INIT_DECIMAL64 ) ; dc . round = set -> round ; decNumberPlus ( & dw , dn , & dc ) ; status |= dc . status ; dn = & dw ; } } DEC_clear ( d64 ) ; if ( dn -> bits & DECSPECIAL ) { uByte top ; if ( dn -> bits & DECINF ) { top = DECIMAL_Inf ; } else { if ( dn -> bits & DECNAN ) { top = DECIMAL_NaN ; } else { top = DECIMAL_sNaN ; } } d64 -> bytes [ 0 ] = top ; } if ( decNumberIsZero ( dn ) ) { if ( dn -> exponent < - DECIMAL64_Bias ) { exp = 0 ; status |= DEC_Clamped ; } else { exp = dn -> exponent + DECIMAL64_Bias ; if ( exp > DECIMAL64_Ehigh ) { exp = DECIMAL64_Ehigh ; status |= DEC_Clamped ; } } comb = ( exp >> 5 ) & 0x18 ; d64 -> bytes [ 0 ] = ( uByte ) ( comb << 2 ) ; exp &= 0xff ; decimal64SetExpCon ( d64 , exp ) ; } else { uInt msd ; exp = ( uInt ) ( dn -> exponent + DECIMAL64_Bias ) ; if ( exp > DECIMAL64_Ehigh ) { pad = exp - DECIMAL64_Ehigh ; exp = DECIMAL64_Ehigh ; status |= DEC_Clamped ; } decDensePackCoeff ( dn , d64 -> bytes , sizeof ( d64 -> bytes ) , pad ) ; msd = ( ( unsigned ) d64 -> bytes [ 1 ] >> 2 ) & 0x0f ; d64 -> bytes [ 1 ] &= 0x03 ; if ( msd >= 8 ) { comb = 0x18 | ( msd & 0x01 ) | ( ( exp >> 7 ) & 0x06 ) ; } else { comb = ( msd & 0x07 ) | ( ( exp >> 5 ) & 0x18 ) ; } d64 -> bytes [ 0 ] = ( uByte ) ( comb << 2 ) ; exp &= 0xff ; decimal64SetExpCon ( d64 , exp ) ; } if ( isneg ) { decimal64SetSign ( d64 , 1 ) ; } if ( status != 0 ) { decContextSetStatus ( set , status ) ; } return d64 ; } 