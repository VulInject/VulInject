static void nft_ct_set_eval ( const struct nft_expr * expr , struct nft_regs * regs , const struct nft_pktinfo * pkt ) { const struct nft_ct * priv = nft_expr_priv ( expr ) ; struct sk_buff * skb = pkt -> skb ; u32 value = regs -> data [ priv -> sreg ] ; enum ip_conntrack_info ctinfo ; struct nf_conn * ct ; ct = nf_ct_get ( skb , & ctinfo ) ; if ( ct == NULL || nf_ct_is_template ( ct ) ) { return ; } switch ( priv -> key ) { case NFT_CT_MARK : if ( ct -> mark != value ) { ct -> mark = value ; nf_conntrack_event_cache ( IPCT_MARK , ct ) ; } break ; case NFT_CT_LABELS : nf_connlabels_replace ( ct , & regs -> data [ priv -> sreg ] , & regs -> data [ priv -> sreg ] , NF_CT_LABELS_MAX_SIZE / sizeof ( u32 ) ) ; break ; case NFT_CT_EVENTMASK : { struct nf_conntrack_ecache * e = nf_ct_ecache_find ( ct ) ; u32 ctmask = regs -> data [ priv -> sreg ] ; if ( e ) { if ( e -> ctmask != ctmask ) { e -> ctmask = ctmask ; } break ; } if ( ctmask && ! nf_ct_is_confirmed ( ct ) ) { nf_ct_ecache_ext_add ( ct , ctmask , 0 , 0 ) ; } break ; } default : break ; } } 