void savagefb_imageblit ( struct fb_info * info , const struct fb_image * image ) { struct savagefb_par * par = info -> par ; int fg , bg , size , i , width ; int cmd ; u32 * src = ( u32 * ) image -> data ; if ( ! image -> width || ! image -> height ) { return ; } if ( image -> depth != 1 ) { cfb_imageblit ( info , image ) ; return ; } if ( info -> fix . visual == FB_VISUAL_PSEUDOCOLOR ) { fg = image -> fg_color ; bg = image -> bg_color ; } else { fg = ( ( u32 * ) info -> pseudo_palette ) [ image -> fg_color ] ; bg = ( ( u32 * ) info -> pseudo_palette ) [ image -> bg_color ] ; } cmd = BCI_CMD_RECT | BCI_CMD_RECT_XP | BCI_CMD_RECT_YP | BCI_CMD_CLIP_LR | BCI_CMD_DEST_GBD | BCI_CMD_SRC_MONO | BCI_CMD_SEND_COLOR ; par -> bci_ptr = 0 ; width = ( image -> width + 31 ) & ~ 31 ; size = ( width * image -> height ) / 8 ; size >>= 2 ; par -> SavageWaitFifo ( par , size + 5 ) ; BCI_SEND ( cmd ) ; BCI_SEND ( BCI_CLIP_LR ( image -> dx , image -> dx + image -> width - 1 ) ) ; BCI_SEND ( fg ) ; BCI_SEND ( bg ) ; BCI_SEND ( BCI_X_Y ( image -> dx , image -> dy ) ) ; BCI_SEND ( BCI_W_H ( width , image -> height ) ) ; for ( i = 0 ; i < size ; i ++ ) { BCI_SEND ( src [ i ] ) ; } } 