static int wm8994_device_init ( struct wm8994 * wm8994 , int irq ) { struct wm8994_pdata * pdata ; struct regmap_config * regmap_config ; const struct reg_sequence * regmap_patch = NULL ; const char * devname ; int pulls ; int pulls = 0 ; if ( dev_get_platdata ( wm8994 -> dev ) ) { pdata = dev_get_platdata ( wm8994 -> dev ) ; wm8994 -> pdata = * pdata ; } pdata = & wm8994 -> pdata ; ret = wm8994_set_pdata_from_of ( wm8994 ) ; if ( ret != 0 ) { return ret ; } dev_set_drvdata ( wm8994 -> dev , wm8994 ) ; ret = mfd_add_devices ( wm8994 -> dev , 0 , wm8994_regulator_devs , ARRAY_SIZE ( wm8994_regulator_devs ) , NULL , 0 , NULL ) ; if ( ret != 0 ) { dev_err ( wm8994 -> dev , "Failed to add children: %d\n" , ret ) ; err } switch ( wm8994 -> type ) { case WM1811 : wm8994 -> num_supplies = ARRAY_SIZE ( wm1811_main_supplies ) ; break ; case WM8994 : wm8994 -> num_supplies = ARRAY_SIZE ( wm8994_main_supplies ) ; break ; case WM8958 : wm8994 -> num_supplies = ARRAY_SIZE ( wm8958_main_supplies ) ; break ; default : BUG ( ) ; err } wm8994 -> supplies = devm_kzalloc ( wm8994 -> dev , sizeof ( regulator_bulk_data ) * wm8994 -> num_supplies , GFP_KERNEL ) ; if ( ! wm8994 -> supplies ) { ret = - ENOMEM ; err } switch ( wm8994 -> type ) { case WM1811 : for ( i = 0 ; i < ARRAY_SIZE ( wm1811_main_supplies ) ; i ++ ) { wm8994 -> supplies [ i ] . supply = wm1811_main_supplies [ i ] ; } break ; case WM8994 : for ( i = 0 ; i < ARRAY_SIZE ( wm8994_main_supplies ) ; i ++ ) { wm8994 -> supplies [ i ] . supply = wm8994_main_supplies [ i ] ; } break ; case WM8958 : for ( i = 0 ; i < ARRAY_SIZE ( wm8958_main_supplies ) ; i ++ ) { wm8994 -> supplies [ i ] . supply = wm8958_main_supplies [ i ] ; } break ; default : BUG ( ) ; err } ret = regulator_bulk_get ( wm8994 -> dev , wm8994 -> num_supplies , wm8994 -> supplies ) ; if ( ret != 0 ) { dev_err ( wm8994 -> dev , "Failed to get supplies: %d\n" , ret ) ; err } ret = regulator_bulk_enable ( wm8994 -> num_supplies , wm8994 -> supplies ) ; if ( ret != 0 ) { dev_err ( wm8994 -> dev , "Failed to enable supplies: %d\n" , ret ) ; err_regulator_free } ret = wm8994_reg_read ( wm8994 , WM8994_SOFTWARE_RESET ) ; if ( ret < 0 ) { dev_err ( wm8994 -> dev , "Failed to read ID register\n" ) ; err_enable } switch ( ret ) { case 0x1811 : devname = "WM1811" ; if ( wm8994 -> type != WM1811 ) { dev_warn ( wm8994 -> dev , "Device registered as type %d\n" , wm8994 -> type ) ; } wm8994 -> type = WM1811 ; break ; case 0x8994 : devname = "WM8994" ; if ( wm8994 -> type != WM8994 ) { dev_warn ( wm8994 -> dev , "Device registered as type %d\n" , wm8994 -> type ) ; } wm8994 -> type = WM8994 ; break ; case 0x8958 : devname = "WM8958" ; if ( wm8994 -> type != WM8958 ) { dev_warn ( wm8994 -> dev , "Device registered as type %d\n" , wm8994 -> type ) ; } wm8994 -> type = WM8958 ; break ; default : dev_err ( wm8994 -> dev , "Device is not a WM8994, ID is %x\n" , ret ) ; ret = - EINVAL ; err_enable } ret = wm8994_reg_read ( wm8994 , WM8994_CHIP_REVISION ) ; if ( ret < 0 ) { dev_err ( wm8994 -> dev , "Failed to read revision register: %d\n" , ret ) ; err_enable } wm8994 -> revision = ret & WM8994_CHIP_REV_MASK ; wm8994 -> cust_id = ( ret & WM8994_CUST_ID_MASK ) >> WM8994_CUST_ID_SHIFT ; switch ( wm8994 -> type ) { case WM8994 : switch ( wm8994 -> revision ) { case 0 : case 1 : dev_warn ( wm8994 -> dev , "revision %c not fully supported\n" , 'A' + wm8994 -> revision ) ; break ; case 2 : case 3 : default : regmap_patch = wm8994_revc_patch ; patch_regs = ARRAY_SIZE ( wm8994_revc_patch ) ; break ; } break ; case WM8958 : switch ( wm8994 -> revision ) { case 0 : regmap_patch = wm8958_reva_patch ; patch_regs = ARRAY_SIZE ( wm8958_reva_patch ) ; break ; default : break ; } break ; case WM1811 : if ( wm8994 -> revision > 1 ) { wm8994 -> revision ++ ; } regmap_patch = wm1811_reva_patch ; patch_regs = ARRAY_SIZE ( wm1811_reva_patch ) ; break ; default : break ; } dev_info ( wm8994 -> dev , "%s revision %c CUST_ID %02x\n" , devname , 'A' + wm8994 -> revision , wm8994 -> cust_id ) ; switch ( wm8994 -> type ) { case WM1811 : regmap_config = & wm1811_regmap_config ; break ; case WM8994 : regmap_config = & wm8994_regmap_config ; break ; case WM8958 : regmap_config = & wm8958_regmap_config ; break ; default : dev_err ( wm8994 -> dev , "Unknown device type %d\n" , wm8994 -> type ) ; return - EINVAL ; } ret = regmap_reinit_cache ( wm8994 -> regmap , regmap_config ) ; if ( ret != 0 ) { dev_err ( wm8994 -> dev , "Failed to reinit register cache: %d\n" , ret ) ; return ret ; } ret = wm8994_reg_write ( wm8994 , WM8994_SOFTWARE_RESET , wm8994_reg_read ( wm8994 , WM8994_SOFTWARE_RESET ) ) ; if ( ret != 0 ) { dev_err ( wm8994 -> dev , "Failed to reset device: %d\n" , ret ) ; return ret ; } if ( regmap_patch ) { ret = regmap_register_patch ( wm8994 -> regmap , regmap_patch , patch_regs ) ; if ( ret != 0 ) { dev_err ( wm8994 -> dev , "Failed to register patch: %d\n" , ret ) ; err } } wm8994 -> irq_base = pdata -> irq_base ; wm8994 -> gpio_base = pdata -> gpio_base ; for ( i = 0 ; i < ARRAY_SIZE ( pdata -> gpio_defaults ) ; i ++ ) { if ( pdata -> gpio_defaults [ i ] ) { wm8994_set_bits ( wm8994 , WM8994_GPIO_1 + i , 0xffff , pdata -> gpio_defaults [ i ] ) ; } } wm8994 -> ldo_ena_always_driven = pdata -> ldo_ena_always_driven ; if ( pdata -> spkmode_pu ) { pulls |= WM8994_SPKMODE_PU ; } wm8994_set_bits ( wm8994 , WM8994_PULL_CONTROL_2 , WM8994_LDO1ENA_PD | WM8994_LDO2ENA_PD | WM8994_SPKMODE_PU | WM8994_CSNADDR_PD , pulls ) ; for ( i = 0 ; i < WM8994_NUM_LDO_REGS ; i ++ ) { if ( wm8994_ldo_in_use ( pdata , i ) ) { wm8994_set_bits ( wm8994 , WM8994_LDO_1 + i , WM8994_LDO1_DISCH , WM8994_LDO1_DISCH ) ; } else { wm8994_set_bits ( wm8994 , WM8994_LDO_1 + i , WM8994_LDO1_DISCH , 0 ) ; } } wm8994_irq_init ( wm8994 ) ; ret = mfd_add_devices ( wm8994 -> dev , - 1 , wm8994_devs , ARRAY_SIZE ( wm8994_devs ) , NULL , 0 , NULL ) ; if ( ret != 0 ) { dev_err ( wm8994 -> dev , "Failed to add children: %d\n" , ret ) ; err_irq } pm_runtime_enable ( wm8994 -> dev ) ; pm_runtime_idle ( wm8994 -> dev ) ; return 0 ; err_irq wm8994_irq_exit ( wm8994 ) ; err_enable regulator_bulk_disable ( wm8994 -> num_supplies , wm8994 -> supplies ) ; err_regulator_free regulator_bulk_free ( wm8994 -> num_supplies , wm8994 -> supplies ) ; err mfd_remove_devices ( wm8994 -> dev ) ; return ret ; } 