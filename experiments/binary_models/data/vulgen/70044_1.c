static int mt8195_afe_pcm_dev_probe ( struct platform_device * pdev ) { struct mtk_base_afe * afe ; struct mt8195_afe_private * afe_priv ; struct device * dev = & pdev -> dev ; struct reset_control * rstc ; int i , irq_id , ret ; struct snd_soc_component * component ; ret = of_reserved_mem_device_init ( dev ) ; if ( ret ) { dev_err ( dev , "failed to assign memory region: %d\n" , ret ) ; return ret ; } ret = dma_set_mask_and_coherent ( dev , DMA_BIT_MASK ( 33 ) ) ; if ( ret ) { return ret ; } afe = devm_kzalloc ( dev , sizeof ( * afe ) , GFP_KERNEL ) ; if ( ! afe ) { return - ENOMEM ; } if ( ! afe -> platform_priv ) { return - ENOMEM ; } afe_priv = afe -> platform_priv ; afe -> dev = & pdev -> dev ; afe -> base_addr = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( afe -> base_addr ) ) { return PTR_ERR ( afe -> base_addr ) ; } ret = mt8195_afe_init_clock ( afe ) ; if ( ret ) { dev_err ( dev , "init clock error\n" ) ; return ret ; } rstc = devm_reset_control_get_exclusive ( dev , "audiosys" ) ; if ( IS_ERR ( rstc ) ) { ret = PTR_ERR ( rstc ) ; dev_err ( dev , "could not get audiosys reset:%d\n" , ret ) ; return ret ; } ret = reset_control_reset ( rstc ) ; if ( ret ) { dev_err ( dev , "failed to trigger audio reset:%d\n" , ret ) ; return ret ; } spin_lock_init ( & afe_priv -> afe_ctrl_lock ) ; mutex_init ( & afe -> irq_alloc_lock ) ; afe -> irqs_size = MT8195_AFE_IRQ_NUM ; afe -> irqs = devm_kcalloc ( dev , afe -> irqs_size , sizeof ( * afe -> irqs ) , GFP_KERNEL ) ; if ( ! afe -> irqs ) { return - ENOMEM ; } for ( i = 0 ; i < afe -> irqs_size ; i ++ ) { afe -> irqs [ i ] . irq_data = & irq_data_array [ i ] ; } afe -> memif_size = MT8195_AFE_MEMIF_NUM ; afe -> memif = devm_kcalloc ( dev , afe -> memif_size , sizeof ( * afe -> memif ) , GFP_KERNEL ) ; if ( ! afe -> memif ) { return - ENOMEM ; } for ( i = 0 ; i < afe -> memif_size ; i ++ ) { afe -> memif [ i ] . data = & memif_data [ i ] ; afe -> memif [ i ] . irq_usage = mt8195_afe_memif_const_irqs [ i ] ; afe -> memif [ i ] . const_irq = 1 ; afe -> irqs [ afe -> memif [ i ] . irq_usage ] . irq_occupyed = true ; } irq_id = platform_get_irq ( pdev , 0 ) ; if ( irq_id < 0 ) { return - ENXIO ; } ret = devm_request_irq ( dev , irq_id , mt8195_afe_irq_handler , IRQF_TRIGGER_NONE , "asys-isr" , ( void * ) afe ) ; if ( ret ) { dev_err ( dev , "could not request_irq for asys-isr\n" ) ; return ret ; } INIT_LIST_HEAD ( & afe -> sub_dais ) ; for ( i = 0 ; i < ARRAY_SIZE ( dai_register_cbs ) ; i ++ ) { ret = dai_register_cbs [ i ] ( afe ) ; if ( ret ) { dev_warn ( dev , "dai register i %d fail, ret %d\n" , i , ret ) ; return ret ; } } ret = mtk_afe_combine_sub_dai ( afe ) ; if ( ret ) { dev_warn ( dev , "mtk_afe_combine_sub_dai fail, ret %d\n" , ret ) ; return ret ; } afe -> mtk_afe_hardware = & mt8195_afe_hardware ; afe -> memif_fs = mt8195_memif_fs ; afe -> irq_fs = mt8195_irq_fs ; afe -> runtime_resume = mt8195_afe_runtime_resume ; afe -> runtime_suspend = mt8195_afe_runtime_suspend ; platform_set_drvdata ( pdev , afe ) ; mt8195_afe_parse_of ( afe , pdev -> dev . of_node ) ; pm_runtime_enable ( dev ) ; if ( ! pm_runtime_enabled ( dev ) ) { ret = mt8195_afe_runtime_resume ( dev ) ; if ( ret ) { return ret ; } } afe_priv -> pm_runtime_bypass_reg_ctl = true ; pm_runtime_get_sync ( dev ) ; afe -> regmap = devm_regmap_init_mmio ( & pdev -> dev , afe -> base_addr , & mt8195_afe_regmap_config ) ; if ( IS_ERR ( afe -> regmap ) ) { ret = PTR_ERR ( afe -> regmap ) ; err_pm_put } ret = regmap_register_patch ( afe -> regmap , mt8195_cg_patch , ARRAY_SIZE ( mt8195_cg_patch ) ) ; if ( ret < 0 ) { dev_err ( dev , "Failed to apply cg patch\n" ) ; err_pm_put } ret = devm_snd_soc_register_component ( dev , & mt8195_afe_component , NULL , 0 ) ; if ( ret ) { dev_warn ( dev , "err_platform\n" ) ; err_pm_put } component = devm_kzalloc ( dev , sizeof ( * component ) , GFP_KERNEL ) ; if ( ! component ) { ret = - ENOMEM ; err_pm_put } ret = snd_soc_component_initialize ( component , & mt8195_afe_pcm_dai_component , dev ) ; if ( ret ) { err_pm_put } component -> debugfs_prefix = "pcm" ; ret = snd_soc_add_component ( component , afe -> dai_drivers , afe -> num_dai_drivers ) ; if ( ret ) { dev_warn ( dev , "err_dai_component\n" ) ; err_pm_put } mt8195_afe_init_registers ( afe ) ; pm_runtime_put_sync ( dev ) ; afe_priv -> pm_runtime_bypass_reg_ctl = false ; regcache_cache_only ( afe -> regmap , true ) ; regcache_mark_dirty ( afe -> regmap ) ; return 0 ; err_pm_put pm_runtime_put_sync ( dev ) ; pm_runtime_disable ( dev ) ; return ret ; } 