static void cdv_intel_dp_mode_set ( struct drm_encoder * encoder , struct drm_display_mode * mode , struct drm_display_mode * adjusted_mode ) { struct gma_encoder * intel_encoder = to_gma_encoder ( encoder ) ; struct drm_crtc * crtc = encoder -> crtc ; struct gma_crtc * gma_crtc = to_gma_crtc ( crtc ) ; struct cdv_intel_dp * intel_dp = intel_encoder -> dev_priv ; struct drm_device * dev = encoder -> dev ; intel_dp -> DP = DP_VOLTAGE_0_4 | DP_PRE_EMPHASIS_0 ; intel_dp -> DP |= intel_dp -> color_range ; if ( adjusted_mode -> flags & DRM_MODE_FLAG_PHSYNC ) { intel_dp -> DP |= DP_SYNC_HS_HIGH ; } if ( adjusted_mode -> flags & DRM_MODE_FLAG_PVSYNC ) { intel_dp -> DP |= DP_SYNC_VS_HIGH ; } intel_dp -> DP |= DP_LINK_TRAIN_OFF ; switch ( intel_dp -> lane_count ) { case 1 : intel_dp -> DP |= DP_PORT_WIDTH_1 ; break ; case 2 : intel_dp -> DP |= DP_PORT_WIDTH_2 ; break ; case 4 : intel_dp -> DP |= DP_PORT_WIDTH_4 ; break ; } if ( intel_dp -> has_audio ) { intel_dp -> DP |= DP_AUDIO_OUTPUT_ENABLE ; } intel_dp -> link_configuration [ 0 ] = intel_dp -> link_bw ; intel_dp -> link_configuration [ 1 ] = intel_dp -> lane_count ; if ( intel_dp -> dpcd [ DP_DPCD_REV ] >= 0x11 && ( intel_dp -> dpcd [ DP_MAX_LANE_COUNT ] & DP_ENHANCED_FRAME_CAP ) ) { intel_dp -> link_configuration [ 1 ] |= DP_LANE_COUNT_ENHANCED_FRAME_EN ; intel_dp -> DP |= DP_ENHANCED_FRAMING ; } if ( gma_crtc -> pipe == 1 ) { intel_dp -> DP |= DP_PIPEB_SELECT ; } REG_WRITE ( intel_dp -> output_reg , ( intel_dp -> DP | DP_PORT_EN ) ) ; DRM_DEBUG_KMS ( "DP expected reg is %x\n" , intel_dp -> DP ) ; if ( is_edp ( intel_encoder ) ) { uint32_t pfit_control ; cdv_intel_edp_panel_on ( intel_encoder ) ; if ( mode -> hdisplay != adjusted_mode -> hdisplay || mode -> vdisplay != adjusted_mode -> vdisplay ) { pfit_control = PFIT_ENABLE ; } else { pfit_control = 0 ; } pfit_control |= gma_crtc -> pipe << PFIT_PIPE_SHIFT ; REG_WRITE ( PFIT_CONTROL , pfit_control ) ; } } 