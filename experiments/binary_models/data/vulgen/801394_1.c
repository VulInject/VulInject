static s32 ixgbe_write_i2c_byte_generic_int ( struct ixgbe_hw * hw , u8 byte_offset , u8 dev_addr , u8 data , bool lock ) { s32 status ; u32 retry = 0 ; u32 swfw_mask = hw -> phy . phy_semaphore_mask ; DEBUGFUNC ( "ixgbe_write_i2c_byte_generic" ) ; if ( lock && hw -> mac . ops . acquire_swfw_sync ( hw , swfw_mask ) != IXGBE_SUCCESS ) { return IXGBE_ERR_SWFW_SYNC ; } { ixgbe_i2c_start ( hw ) ; status = ixgbe_clock_out_i2c_byte ( hw , dev_addr ) ; if ( status != IXGBE_SUCCESS ) { fail } status = ixgbe_get_i2c_ack ( hw ) ; if ( status != IXGBE_SUCCESS ) { fail } status = ixgbe_clock_out_i2c_byte ( hw , byte_offset ) ; if ( status != IXGBE_SUCCESS ) { fail } status = ixgbe_get_i2c_ack ( hw ) ; if ( status != IXGBE_SUCCESS ) { fail } status = ixgbe_clock_out_i2c_byte ( hw , data ) ; if ( status != IXGBE_SUCCESS ) { fail } status = ixgbe_get_i2c_ack ( hw ) ; if ( status != IXGBE_SUCCESS ) { fail } ixgbe_i2c_stop ( hw ) ; if ( lock ) { hw -> mac . ops . release_swfw_sync ( hw , swfw_mask ) ; } return IXGBE_SUCCESS ; fail ixgbe_i2c_bus_clear ( hw ) ; retry ++ ; if ( retry < max_retry ) { DEBUGOUT ( "I2C byte write error - Retrying.\n" ) ; } else { DEBUGOUT ( "I2C byte write error.\n" ) ; } } retry < max_retry ; if ( lock ) { hw -> mac . ops . release_swfw_sync ( hw , swfw_mask ) ; } return status ; } 