void btrfs_set_token_ # # bits ( , , , ) { const unsigned long member_offset = ( unsigned long ) ptr + off const unsigned long idx = get_eb_page_index ( member_offset ) const unsigned long oip = get_eb_offset_in_page ( token -> eb , member_offset ) const int size = sizeof ( u # # bits ) u8 lebytes [ sizeof ( u # # bits ) ] const int part = PAGE_SIZE - oip ASSERT ( token ) ASSERT ( token -> kaddr ) ASSERT ( check_setget_bounds ( token -> eb , ptr , off , size ) ) if ( token -> offset <= member_offset && member_offset + size <= token -> offset + PAGE_SIZE ) { put_unaligned_le # # bits ( val , token -> kaddr + oip ) ; return ; ; } } token -> kaddr = page_address ( token -> eb -> pages [ idx ] ) ; token -> offset = idx << PAGE_SHIFT ; put_unaligned_le # # bits ( val , lebytes ) ; memcpy ( token -> kaddr + oip , lebytes , part ) ; token -> kaddr = page_address ( token -> eb -> pages [ idx + 1 ] ) ; token -> offset = ( idx + 1 ) << PAGE_SHIFT ; memcpy ( token -> kaddr , lebytes + part , size - part ) ; 