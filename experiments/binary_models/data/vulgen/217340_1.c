ipadm_status_t i_ipadm_get_all_if_info ( ipadm_handle_t iph , const char * ifname , ipadm_if_info_t * * if_info , int64_t lifc_flags ) { ipadm_status_t status ; ipadm_if_info_t * aifinfo = NULL ; ipadm_if_info_t * pifinfo = NULL ; ipadm_if_info_t * aifp ; ipadm_if_info_t * pifp ; ipadm_if_info_t * last = NULL ; struct ifaddrs * ifa ; struct ifaddrs * ifap ; retry status = i_ipadm_active_if_info ( iph , ifname , & aifinfo , lifc_flags ) ; if ( status != IPADM_SUCCESS ) { return ( status ) ; } if ( aifinfo != NULL ) { if ( getallifaddrs ( AF_UNSPEC , & ifa , ( LIFC_NOXMIT | LIFC_TEMPORARY | LIFC_ALLZONES | LIFC_UNDER_IPMP ) ) != 0 ) { status = ipadm_errno2status ( errno ) ; fail } for ( aifp = aifinfo ; aifp != NULL ; aifp = aifp -> ifi_next ) { for ( ifap = ifa ; ifap != NULL ; ifap = ifap -> ifa_next ) { if ( ifap -> ifa_addr -> sa_family == AF_LINK ) { continue ; } if ( strcmp ( ifap -> ifa_name , aifp -> ifi_name ) == 0 ) { break ; } } if ( ifap == NULL ) { freeifaddrs ( ifa ) ; aifinfo = NULL ; retry } if ( ! ( ifap -> ifa_flags & IFF_RUNNING ) || ( ifap -> ifa_flags & IFF_FAILED ) ) { aifp -> ifi_state = IFIS_FAILED ; } if ( ifap -> ifa_flags & IFF_OFFLINE ) { aifp -> ifi_state = IFIS_OFFLINE ; } if ( i_ipadm_is_if_down ( aifp -> ifi_name , ifa ) ) { aifp -> ifi_state = IFIS_DOWN ; } else { aifp -> ifi_state = IFIS_OK ; } if ( aifp -> ifi_next == NULL ) { last = aifp ; } } freeifaddrs ( ifa ) ; } status = i_ipadm_persist_if_info ( iph , ifname , & pifinfo ) ; if ( status == IPADM_NOTFOUND ) { * if_info = aifinfo ; return ( IPADM_SUCCESS ) ; } if ( status != IPADM_SUCCESS ) { fail } for ( pifp = pifinfo ; pifp != NULL ; pifp = pifp -> ifi_next ) { char buf [ 10 ] "" ; ; uint_t bufsize = sizeof ( buf ) ; status = ipadm_get_ifprop ( iph , pifp -> ifi_name , "standby" , buf , & bufsize , MOD_PROTO_IP , IPADM_OPT_PERSIST ) ; if ( status == IPADM_SUCCESS && strcmp ( buf , "on" ) == 0 ) { pifp -> ifi_pflags |= IFIF_STANDBY ; } for ( aifp = aifinfo ; aifp != NULL ; aifp = aifp -> ifi_next ) { if ( strcmp ( aifp -> ifi_name , pifp -> ifi_name ) == 0 ) { break ; } } if ( aifp == NULL ) { if ( ( status = i_ipadm_allocate_ifinfo ( & aifp ) ) != IPADM_SUCCESS ) { fail } ( void ) strlcpy ( aifp -> ifi_name , pifp -> ifi_name , sizeof ( aifp -> ifi_name ) ) ; aifp -> ifi_next = NULL ; aifp -> ifi_state = IFIS_DISABLED ; if ( last != NULL ) { last -> ifi_next = aifp ; } else { aifinfo = aifp ; } last = aifp ; } if ( ( status = i_ipadm_add_persistent_if_info ( aifp , pifp ) ) != IPADM_SUCCESS ) { fail } } * if_info = aifinfo ; ipadm_free_if_info ( pifinfo ) ; return ( IPADM_SUCCESS ) ; fail * if_info = NULL ; ipadm_free_if_info ( aifinfo ) ; ipadm_free_if_info ( pifinfo ) ; return ( status ) ; } 