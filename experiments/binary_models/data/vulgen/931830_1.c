static int __init early_root_info_init ( void ) { int i ; unsigned bus ; unsigned slot ; int node ; int link ; int def_node ; int def_link ; struct pci_root_info * info ; u32 reg ; u64 start ; u64 end ; struct range range [ RANGE_NUM ] ; u64 val ; u32 address ; bool found ; struct resource fam10h_mmconf_res , * fam10h_mmconf ; u64 fam10h_mmconf_start ; u64 fam10h_mmconf_end ; found = false ; for ( i = 0 ; i < ARRAY_SIZE ( hb_probes ) ; i ++ ) { u32 id ; u16 device ; u16 vendor ; bus = hb_probes [ i ] . bus ; slot = hb_probes [ i ] . slot ; id = read_pci_config ( bus , slot , 0 , PCI_VENDOR_ID ) ; vendor = id & 0xffff ; device = ( id >> 16 ) & 0xffff ; if ( vendor != PCI_VENDOR_ID_AMD && vendor != PCI_VENDOR_ID_HYGON ) { continue ; } if ( hb_probes [ i ] . device == device ) { found = true ; break ; } } if ( ! found ) { return 0 ; } for ( i = 0 ; i < AMD_NB_F1_CONFIG_MAP_RANGES ; i ++ ) { int min_bus ; int max_bus ; reg = read_pci_config ( bus , slot , 1 , AMD_NB_F1_CONFIG_MAP_REG + ( i << 2 ) ) ; if ( ( reg & 7 ) != 3 ) { continue ; } min_bus = ( reg >> 16 ) & 0xff ; max_bus = ( reg >> 24 ) & 0xff ; node = ( reg >> 4 ) & 0x07 ; link = ( reg >> 8 ) & 0x03 ; alloc_pci_root_info ( min_bus , max_bus , node , link ) ; } if ( boot_cpu_data . x86 > 0x11 ) { return 0 ; } reg = read_pci_config ( bus , slot , 0 , AMD_NB_F0_NODE_ID ) ; def_node = ( reg >> 8 ) & 0x07 ; reg = read_pci_config ( bus , slot , 0 , AMD_NB_F0_UNIT_ID ) ; def_link = ( reg >> 8 ) & 0x03 ; memset ( range , 0 , sizeof ( range ) ) ; add_range ( range , RANGE_NUM , 0 , 0 , 0xffff + 1 ) ; for ( i = 0 ; i < 4 ; i ++ ) { reg = read_pci_config ( bus , slot , 1 , 0xc0 + ( i << 3 ) ) ; if ( ! ( reg & 3 ) ) { continue ; } start = reg & 0xfff000 ; reg = read_pci_config ( bus , slot , 1 , 0xc4 + ( i << 3 ) ) ; node = reg & 0x07 ; link = ( reg >> 4 ) & 0x03 ; end = ( reg & 0xfff000 ) | 0xfff ; info = find_pci_root_info ( node , link ) ; if ( ! info ) { continue ; } printk ( KERN_DEBUG "node %d link %d: io port [%llx, %llx]\n" , node , link , start , end ) ; if ( end > 0xffff ) { end = 0xffff ; } update_res ( info , start , end , IORESOURCE_IO , 1 ) ; subtract_range ( range , RANGE_NUM , start , end + 1 ) ; } info = find_pci_root_info ( def_node , def_link ) ; if ( info ) { for ( i = 0 ; i < RANGE_NUM ; i ++ ) { if ( ! range [ i ] . end ) { continue ; } update_res ( info , range [ i ] . start , range [ i ] . end - 1 , IORESOURCE_IO , 1 ) ; } } memset ( range , 0 , sizeof ( range ) ) ; end = cap_resource ( ( 0xfdULL << 32 ) - 1 ) ; end ++ ; add_range ( range , RANGE_NUM , 0 , 0 , end ) ; address = MSR_K8_TOP_MEM1 ; rdmsrl ( address , val ) ; end = ( val & 0xffffff800000ULL ) ; printk ( KERN_INFO "TOM: %016llx aka %lldM\n" , end , end >> 20 ) ; if ( end < ( 1ULL << 32 ) ) { subtract_range ( range , RANGE_NUM , 0 , end ) ; } fam10h_mmconf = amd_get_mmconfig_range ( & fam10h_mmconf_res ) ; if ( fam10h_mmconf ) { printk ( KERN_DEBUG "Fam 10h mmconf %pR\n" , fam10h_mmconf ) ; fam10h_mmconf_start = fam10h_mmconf -> start ; fam10h_mmconf_end = fam10h_mmconf -> end ; subtract_range ( range , RANGE_NUM , fam10h_mmconf_start , fam10h_mmconf_end + 1 ) ; } else { fam10h_mmconf_start = 0 ; fam10h_mmconf_end = 0 ; } for ( i = 0 ; i < 8 ; i ++ ) { reg = read_pci_config ( bus , slot , 1 , 0x80 + ( i << 3 ) ) ; if ( ! ( reg & 3 ) ) { continue ; } start = reg & 0xffffff00 ; start <<= 8 ; reg = read_pci_config ( bus , slot , 1 , 0x84 + ( i << 3 ) ) ; node = reg & 0x07 ; link = ( reg >> 4 ) & 0x03 ; end = ( reg & 0xffffff00 ) ; end <<= 8 ; end |= 0xffff ; info = find_pci_root_info ( node , link ) ; if ( ! info ) { continue ; } printk ( KERN_DEBUG "node %d link %d: mmio [%llx, %llx]" , node , link , start , end ) ; if ( fam10h_mmconf_end ) { int changed = 0 ; u64 endx = 0 ; if ( start >= fam10h_mmconf_start && start <= fam10h_mmconf_end ) { start = fam10h_mmconf_end + 1 ; changed = 1 ; } if ( end >= fam10h_mmconf_start && end <= fam10h_mmconf_end ) { end = fam10h_mmconf_start - 1 ; changed = 1 ; } if ( start ( fam10h_mmconf_start && end ) fam10h_mmconf_end ) { endx = fam10h_mmconf_start - 1 ; update_res ( info , start , endx , IORESOURCE_MEM , 0 ) ; subtract_range ( range , RANGE_NUM , start , endx + 1 ) ; printk ( KERN_CONT " ==>[%llx, %llx]" , start , endx ) ; start = fam10h_mmconf_end + 1 ; changed = 1 ; } if ( changed ) { if ( start <= end ) { printk ( KERN_CONT " %s [%llx, %llx]" , endx ?"and" : "==>" , start , end ) ; } else { printk ( KERN_CONT "%s\n" , endx ?"" : " ==>none" ) ; continue ; } } } update_res ( info , cap_resource ( start ) , cap_resource ( end ) , IORESOURCE_MEM , 1 ) ; subtract_range ( range , RANGE_NUM , start , end + 1 ) ; printk ( KERN_CONT "\n" ) ; } address = MSR_AMD64_SYSCFG ; rdmsrl ( address , val ) ; if ( val & ( 1 << 21 ) ) { address = MSR_K8_TOP_MEM2 ; rdmsrl ( address , val ) ; end = ( val & 0xffffff800000ULL ) ; printk ( KERN_INFO "TOM2: %016llx aka %lldM\n" , end , end >> 20 ) ; subtract_range ( range , RANGE_NUM , 1ULL << 32 , end ) ; } info = find_pci_root_info ( def_node , def_link ) ; if ( info ) { for ( i = 0 ; i < RANGE_NUM ; i ++ ) { if ( ! range [ i ] . end ) { continue ; } update_res ( info , cap_resource ( range [ i ] . start ) , cap_resource ( range [ i ] . end - 1 ) , IORESOURCE_MEM , 1 ) ; } } list_for_each_entry ( , , ) { int busnum ; struct pci_root_res * root_res ; busnum = info -> busn . start ; printk ( KERN_DEBUG "bus: %pR on node %x link %x\n" , & info -> busn , info -> node , info -> link ) ; list_for_each_entry ( , , ) printk ( KERN_DEBUG "bus: %02x %pR\n" , busnum , & root_res -> res ) ; } return 0 ; } 