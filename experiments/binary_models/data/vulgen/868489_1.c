static int usba_udc_probe ( struct platform_device * pdev ) { struct resource * res ; struct clk * pclk , * hclk ; struct usba_udc * udc ; int irq , ret , i ; udc = devm_kzalloc ( & pdev -> dev , sizeof ( * udc ) , GFP_KERNEL ) ; if ( ! udc ) { return - ENOMEM ; } udc -> gadget = usba_gadget_template ; INIT_LIST_HEAD ( & udc -> gadget . ep_list ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , CTRL_IOMEM_ID ) ; udc -> regs = devm_ioremap_resource ( & pdev -> dev , res ) ; if ( IS_ERR ( udc -> regs ) ) { return PTR_ERR ( udc -> regs ) ; } dev_info ( & pdev -> dev , "MMIO registers at %pR mapped at %p\n" , res , udc -> regs ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , FIFO_IOMEM_ID ) ; udc -> fifo = devm_ioremap_resource ( & pdev -> dev , res ) ; if ( IS_ERR ( udc -> fifo ) ) { return PTR_ERR ( udc -> fifo ) ; } dev_info ( & pdev -> dev , "FIFO at %pR mapped at %p\n" , res , udc -> fifo ) ; irq = platform_get_irq ( pdev , 0 ) ; if ( irq < 0 ) { return irq ; } pclk = devm_clk_get ( & pdev -> dev , "pclk" ) ; if ( IS_ERR ( pclk ) ) { return PTR_ERR ( pclk ) ; } hclk = devm_clk_get ( & pdev -> dev , "hclk" ) ; if ( IS_ERR ( hclk ) ) { return PTR_ERR ( hclk ) ; } spin_lock_init ( & udc -> lock ) ; udc -> pdev = pdev ; udc -> pclk = pclk ; udc -> hclk = hclk ; platform_set_drvdata ( pdev , udc ) ; ret = clk_prepare_enable ( pclk ) ; if ( ret ) { dev_err ( & pdev -> dev , "Unable to enable pclk, aborting.\n" ) ; return ret ; } usba_writel ( udc , CTRL , USBA_DISABLE_MASK ) ; clk_disable_unprepare ( pclk ) ; udc -> usba_ep = atmel_udc_of_init ( pdev , udc ) ; toggle_bias ( udc , 0 ) ; if ( IS_ERR ( udc -> usba_ep ) ) { return PTR_ERR ( udc -> usba_ep ) ; } ret = devm_request_irq ( & pdev -> dev , irq , usba_udc_irq , 0 , "atmel_usba_udc" , udc ) ; if ( ret ) { dev_err ( & pdev -> dev , "Cannot request irq %d (error %d)\n" , irq , ret ) ; return ret ; } udc -> irq = irq ; if ( udc -> vbus_pin ) { irq_set_status_flags ( gpiod_to_irq ( udc -> vbus_pin ) , IRQ_NOAUTOEN ) ; ret = devm_request_threaded_irq ( & pdev -> dev , gpiod_to_irq ( udc -> vbus_pin ) , NULL , usba_vbus_irq_thread , USBA_VBUS_IRQFLAGS , "atmel_usba_udc" , udc ) ; if ( ret ) { udc -> vbus_pin = NULL ; dev_warn ( & udc -> pdev -> dev , "failed to request vbus irq; " "assuming always on\n" ) ; } } ret = usb_add_gadget_udc ( & pdev -> dev , & udc -> gadget ) ; if ( ret ) { return ret ; } device_init_wakeup ( & pdev -> dev , 1 ) ; usba_init_debugfs ( udc ) ; for ( i = 1 ; i < udc -> num_ep ; i ++ ) { usba_ep_init_debugfs ( udc , & udc -> usba_ep [ i ] ) ; } return 0 ; } 