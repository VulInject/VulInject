static struct Curl_dns_entry * fetch_addr ( struct Curl_easy * data , const char * hostname , int port ) { size_t entry_len ; char entry_id [ MAX_HOSTCACHE_LEN ] ; create_hostcache_id ( hostname , port , entry_id , sizeof ( entry_id ) ) ; entry_len = strlen ( entry_id ) ; dns = Curl_hash_pick ( data -> dns . hostcache , entry_id , entry_len + 1 ) ; if ( ! dns && data -> state . wildcard_resolve ) { create_hostcache_id ( "*" , port , entry_id , sizeof ( entry_id ) ) ; entry_len = strlen ( entry_id ) ; dns = Curl_hash_pick ( data -> dns . hostcache , entry_id , entry_len + 1 ) ; } if ( dns && ( data -> set . dns_cache_timeout != - 1 ) ) { struct hostcache_prune_data user ; time ( & user . now ) ; user . cache_timeout = data -> set . dns_cache_timeout ; if ( hostcache_timestamp_remove ( & user , dns ) ) { infof ( data , "Hostname in DNS cache was stale, zapped" ) ; dns = NULL ; Curl_hash_delete ( data -> dns . hostcache , entry_id , entry_len + 1 ) ; } } if ( dns && data -> conn -> ip_version != CURL_IPRESOLVE_WHATEVER ) { int pf = PF_INET ; bool found = false ; struct Curl_addrinfo * addr = dns -> addr ; if ( data -> conn -> ip_version == CURL_IPRESOLVE_V6 ) { pf = PF_INET6 ; } while ( addr ) { if ( addr -> ai_family == pf ) { found = true ; break ; } addr = addr -> ai_next ; } if ( ! found ) { infof ( data , "Hostname in DNS cache doesn't have needed family, zapped" ) ; dns = NULL ; Curl_hash_delete ( data -> dns . hostcache , entry_id , entry_len + 1 ) ; } } return dns ; } 