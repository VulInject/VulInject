static void ovs_fragment ( struct net * net , struct vport * vport , struct sk_buff * skb , u16 mru , struct sw_flow_key * key ) { u16 orig_network_offset = 0 ; if ( eth_p_mpls ( skb -> protocol ) ) { orig_network_offset = skb_network_offset ( skb ) ; skb -> network_header = skb -> inner_network_header ; } if ( skb_network_offset ( skb ) > MAX_L2_LEN ) { OVS_NLERR ( 1 , "L2 header too long to fragment" ) ; err } if ( key -> eth . type == htons ( ETH_P_IP ) ) { struct dst_entry ovs_dst ; unsigned long orig_dst ; prepare_frag ( vport , skb , orig_network_offset , ovs_key_mac_proto ( key ) ) ; dst_init ( & ovs_dst , & ovs_dst_ops , NULL , 1 , DST_OBSOLETE_NONE , DST_NOCOUNT ) ; ovs_dst . dev = vport -> dev ; orig_dst = skb -> _skb_refdst ; skb_dst_set_noref ( skb , & ovs_dst ) ; IPCB ( skb ) -> frag_max_size = mru ; ip_do_fragment ( net , skb -> sk , skb , ovs_vport_output ) ; refdst_drop ( orig_dst ) ; } if ( key -> eth . type == htons ( ETH_P_IPV6 ) ) { const struct nf_ipv6_ops * v6ops = nf_get_ipv6_ops ( ) ; unsigned long orig_dst ; struct rt6_info ovs_rt ; if ( ! v6ops ) { err } prepare_frag ( vport , skb , orig_network_offset , ovs_key_mac_proto ( key ) ) ; dst_init ( & ovs_rt . dst , & ovs_dst_ops , NULL , 1 , DST_OBSOLETE_NONE , DST_NOCOUNT ) ; ovs_rt . dst . dev = vport -> dev ; orig_dst = skb -> _skb_refdst ; skb_dst_set_noref ( skb , & ovs_rt . dst ) ; IP6CB ( skb ) -> frag_max_size = mru ; v6ops -> fragment ( net , skb -> sk , skb , ovs_vport_output ) ; refdst_drop ( orig_dst ) ; } else { WARN_ONCE ( 1 , "Failed fragment ->%s: eth=%04x, MRU=%d, MTU=%d." , ovs_vport_name ( vport ) , ntohs ( key -> eth . type ) , mru , vport -> dev -> mtu ) ; err } return ; err kfree_skb ( skb ) ; } 