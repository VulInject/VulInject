static IOMMUTLBEntry s390_translate_iommu ( IOMMUMemoryRegion * mr , hwaddr addr , IOMMUAccessFlags flag , int iommu_idx ) { S390PCIIOMMU * iommu = container_of ( mr , S390PCIIOMMU , iommu_mr ) ; S390IOTLBEntry * entry ; uint64_t iova = addr & TARGET_PAGE_MASK ; uint16_t error = 0 ; IOMMUTLBEntry ret = { . target_as = & address_space_memory . iova = 0 . translated_addr = 0 . addr_mask = ~ ( hwaddr ) 0 . perm = IOMMU_NONE } ; switch ( iommu -> pbdev -> state ) { case ZPCI_FS_ENABLED : case ZPCI_FS_BLOCKED : if ( ! iommu -> enabled ) { return ret ; } break ; default : return ret ; } DPRINTF ( "iommu trans addr 0x%" PRIx64 "\n" , addr ) ; if ( addr ( iommu -> pba || addr ) iommu -> pal ) { error = ERR_EVENT_OORANGE ; err } if ( entry ) { ret . iova = entry -> iova ; ret . translated_addr = entry -> translated_addr ; ret . addr_mask = entry -> len - 1 ; ret . perm = entry -> perm ; } else { ret . iova = iova ; ret . addr_mask = ~ TARGET_PAGE_MASK ; ret . perm = IOMMU_NONE ; } if ( flag != IOMMU_NONE && ! ( flag & ret . perm ) ) { error = ERR_EVENT_TPROTE ; } err if ( error ) { iommu -> pbdev -> state = ZPCI_FS_ERROR ; s390_pci_generate_error_event ( error , iommu -> pbdev -> fh , iommu -> pbdev -> fid , addr , 0 ) ; } return ret ; } 