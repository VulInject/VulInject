void openrisc_cpu_do_interrupt ( CPUState * cs ) { OpenRISCCPU * cpu = OPENRISC_CPU ( cs ) ; CPUOpenRISCState * env = & cpu -> env ; int exception = cs -> exception_index ; env -> epcr = env -> pc ; if ( exception == EXCP_SYSCALL ) { env -> epcr += 4 ; } if ( exception == EXCP_ILLEGAL ) { env -> eear = env -> pc ; } env -> esr = cpu_get_sr ( env ) ; env -> sr &= ~ SR_DME ; env -> sr &= ~ SR_IME ; env -> sr |= SR_SM ; env -> sr &= ~ SR_IEE ; env -> sr &= ~ SR_TEE ; env -> pmr &= ~ PMR_DME ; env -> pmr &= ~ PMR_SME ; if ( env -> dflag ) { env -> dflag = 0 ; env -> sr |= SR_DSX ; env -> epcr -= 4 ; } else { env -> sr &= ~ SR_DSX ; } if ( exception > 0 && exception < EXCP_NR ) { static const char * const int_name [ EXCP_NR ] { [ EXCP_RESET ] = "RESET" [ EXCP_BUSERR ] = "BUSERR (bus error)" [ EXCP_DPF ] = "DFP (data protection fault)" [ EXCP_IPF ] = "IPF (code protection fault)" [ EXCP_TICK ] = "TICK (timer interrupt)" [ EXCP_ALIGN ] = "ALIGN" [ EXCP_ILLEGAL ] = "ILLEGAL" [ EXCP_INT ] = "INT (device interrupt)" [ EXCP_DTLBMISS ] = "DTLBMISS (data tlb miss)" [ EXCP_ITLBMISS ] = "ITLBMISS (code tlb miss)" [ EXCP_RANGE ] = "RANGE" [ EXCP_SYSCALL ] = "SYSCALL" [ EXCP_FPE ] = "FPE" [ EXCP_TRAP ] = "TRAP" } ; ; qemu_log_mask ( CPU_LOG_INT , "INT: %s\n" , int_name [ exception ] ) ; hwaddr vect_pc = exception << 8 ; if ( env -> cpucfgr & CPUCFGR_EVBARP ) { vect_pc |= env -> evbar ; } if ( env -> sr & SR_EPH ) { vect_pc |= 0xf0000000 ; } env -> pc = vect_pc ; } else { cpu_abort ( cs , "Unhandled exception 0x%x\n" , exception ) ; } cs -> exception_index = - 1 ; } 