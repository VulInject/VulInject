static inline int insert_contacts ( struct sip_msg * _m , udomain_t * _d , str * _a , int _use_regid , int novariation ) { ucontact_info_t * ci ; urecord_t * r = NULL ; ucontact_t * c ; contact_t * _c ; unsigned int flags ; int num , expires ; int maxc ; int e_max , tcp_check ; struct sip_uri uri ; sip_uri_t * u ; u = parse_to_uri ( _m ) ; if ( u == NULL ) { error } flags = mem_only ; if ( ( _m -> flags & tcp_persistent_flag ) && ( _m -> rcv . proto == PROTO_TCP || _m -> rcv . proto == PROTO_TLS || _m -> rcv . proto == PROTO_WS || _m -> rcv . proto == PROTO_WSS ) ) { e_max = 0 ; tcp_check = 1 ; } else { e_max = tcp_check = 0 ; } _c = get_first_contact ( _m ) ; maxc = reg_get_crt_max_contacts ( ) ; for ( num = 0 , r = 0 , ci = 0 ; _c ; _c = get_next_contact ( _c ) ) { calc_contact_expires ( _m , _c -> expires , & expires , novariation ) ; if ( rerrno == R_LOW_EXP ) { LM_DBG ( "expires lower than minimum value\n" ) ; error } if ( expires == 0 ) { continue ; } if ( maxc > 0 && num >= maxc ) { LM_INFO ( "too many contacts (n:%d max:%d) for AOR<%.*s>\n" , num , maxc , _a -> len , _a -> s ) ; rerrno = R_TOO_MANY ; error } num ++ ; if ( r == 0 ) { if ( ul . insert_urecord ( _d , _a , & r ) < 0 ) { rerrno = R_UL_NEW_R ; LM_ERR ( "failed to insert new record structure\n" ) ; error } } if ( ( ci = pack_ci ( ( ci == 0 ) ?_m : 0 , _c , expires , flags , _use_regid ) ) == 0 ) { LM_ERR ( "failed to extract contact info\n" ) ; error } ci -> cseq ++ ; if ( r -> contacts == 0 || ul . get_ucontact_by_instance ( r , & _c -> uri , ci , & c ) != 0 ) { ci -> cseq -- ; if ( ul . insert_ucontact ( r , & _c -> uri , ci , & c ) < 0 ) { rerrno = R_UL_INS_C ; LM_ERR ( "failed to insert contact\n" ) ; error } } else { ci -> cseq -- ; if ( ul . update_ucontact ( r , c , ci ) < 0 ) { rerrno = R_UL_UPD_C ; LM_ERR ( "failed to update contact\n" ) ; error } } if ( tcp_check ) { if ( parse_uri ( _c -> uri . s , _c -> uri . len , & uri ) < 0 ) { LM_ERR ( "failed to parse contact<%.*s>\n" , _c -> uri . len , _c -> uri . s ) ; } if ( uri . proto == PROTO_TCP || uri . proto == PROTO_TLS || uri . proto == PROTO_WS || uri . proto == PROTO_WSS ) { if ( e_max ) { LM_WARN ( "multiple TCP contacts on single REGISTER\n" ) ; if ( expires > e_max ) { e_max = expires ; } } else { e_max = expires ; } } } } if { if ( r -> contacts ) { build_contact ( _m , r -> contacts , & u -> host ) ; } ul . release_urecord ( r ) ; } else { build_contact ( _m , NULL , & u -> host ) ; } if ( tcp_check && e_max > 0 ) { e_max -= act_time ; } return 0 ; error if ( r ) { ul . delete_urecord ( _d , _a , r ) ; } return - 1 ; } 