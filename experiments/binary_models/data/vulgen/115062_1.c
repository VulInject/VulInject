static int __maybe_unused dwc2_suspend ( struct device * dev ) { struct dwc2_hsotg * dwc2 = dev_get_drvdata ( dev ) ; bool is_device_mode = dwc2_is_device_mode ( dwc2 ) ; int ret = 0 ; if ( is_device_mode ) { dwc2_hsotg_suspend ( dwc2 ) ; } dwc2_drd_suspend ( dwc2 ) ; if ( dwc2 -> params . activate_stm_id_vb_detection ) { unsigned long flags ; u32 ggpio , gotgctl ; dwc2_force_mode ( dwc2 , ! is_device_mode ) ; spin_lock_irqsave ( & dwc2 -> lock , flags ) ; gotgctl = dwc2_readl ( dwc2 , GOTGCTL ) ; gotgctl |= GOTGCTL_DBNCE_FLTR_BYPASS ; gotgctl |= GOTGCTL_BVALOEN | GOTGCTL_AVALOEN ; if ( gotgctl & GOTGCTL_ASESVLD ) { gotgctl |= GOTGCTL_AVALOVAL ; } dwc2_writel ( dwc2 , gotgctl , GOTGCTL ) ; spin_unlock_irqrestore ( & dwc2 -> lock , flags ) ; ggpio = dwc2_readl ( dwc2 , GGPIO ) ; ggpio &= ~ GGPIO_STM32_OTG_GCCFG_IDEN ; ggpio &= ~ GGPIO_STM32_OTG_GCCFG_VBDEN ; dwc2_writel ( dwc2 , ggpio , GGPIO ) ; regulator_disable ( dwc2 -> usb33d ) ; } if ( dwc2 -> ll_hw_enabled && ( is_device_mode || dwc2_host_can_poweroff_phy ( dwc2 ) ) ) { ret = __dwc2_lowlevel_hw_disable ( dwc2 ) ; dwc2 -> phy_off_for_suspend = true ; } return ret ; } 