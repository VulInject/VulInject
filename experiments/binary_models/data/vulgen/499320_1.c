static acpi_status acpi_db_walk_for_execute ( acpi_handle obj_handle , u32 nesting_level , void * context , void * * return_value ) { struct acpi_namespace_node * node = ( acpi_namespace_node * ) obj_handle ; struct acpi_db_execute_walk * info = ( acpi_db_execute_walk * ) context ; struct acpi_buffer return_obj ; acpi_status status ; char * pathname ; u32 i ; struct acpi_device_info * obj_info ; struct acpi_object_list param_objects ; union acpi_object params [ ACPI_METHOD_NUM_ARGS ] ; const union acpi_predefined_info * predefined ; predefined = acpi_ut_match_predefined_method ( node -> name . ascii ) ; if ( ! predefined ) { return ( AE_OK ) ; } if ( node -> type == ACPI_TYPE_LOCAL_SCOPE ) { return ( AE_OK ) ; } pathname = acpi_ns_get_external_pathname ( node ) ; if ( ! pathname ) { return ( AE_OK ) ; } status = acpi_get_object_info ( obj_handle , & obj_info ) ; if ( ACPI_FAILURE ( status ) ) { return ( status ) ; } param_objects . pointer = NULL ; param_objects . count = 0 ; if ( obj_info -> type == ACPI_TYPE_METHOD ) { for ( i = 0 ; i < obj_info -> param_count ; i ++ ) { params [ i ] . type = ACPI_TYPE_INTEGER ; params [ i ] . integer . value = 1 ; } param_objects . pointer = params ; param_objects . count = obj_info -> param_count ; } ACPI_FREE ( obj_info ) ; return_obj . pointer = NULL ; return_obj . length = ACPI_ALLOCATE_BUFFER ; acpi_gbl_method_executing = TRUE ; status = acpi_evaluate_object ( node , NULL , & param_objects , & return_obj ) ; acpi_os_printf ( "%-32s returned %s\n" , pathname , acpi_format_exception ( status ) ) ; acpi_gbl_method_executing = FALSE ; ACPI_FREE ( pathname ) ; status = AE_OK ; info -> count ++ ; if ( info -> count >= info -> max_count ) { status = AE_CTRL_TERMINATE ; } return ( status ) ; } 