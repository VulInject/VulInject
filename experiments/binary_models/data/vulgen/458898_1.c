krb5_error_code KRB5_CALLCONV krb5_init_creds_set_keytab ( krb5_context context , krb5_init_creds_context ctx , krb5_keytab keytab ) { krb5_enctype * etype_list = NULL ; krb5_error_code ret ; struct canonprinc iter = { ctx -> request -> client . subst_defrealm = TRUE } ; krb5_const_principal canonprinc ; krb5_principal copy ; char * name ; ctx -> gak_fct = get_as_key_keytab ; ctx -> gak_data = keytab ; while ( ( ret = k5_canonprinc ( context , & iter , & canonprinc ) ) == 0 && canonprinc != NULL ) { ret = lookup_etypes_for_keytab ( context , keytab , canonprinc , & etype_list ) ; if ( ret || etype_list != NULL ) { break ; } } if ( ! ret && canonprinc != NULL ) { ret = krb5_copy_principal ( context , canonprinc , & copy ) ; if ( ! ret ) { krb5_free_principal ( context , ctx -> request -> client ) ; ctx -> request -> client = copy ; } } free_canonprinc ( & iter ) ; if ( ret ) { TRACE_INIT_CREDS_KEYTAB_LOOKUP_FAILED ( context , ret ) ; return 0 ; } TRACE_INIT_CREDS_KEYTAB_LOOKUP ( context , ctx -> request -> client , etype_list ) ; if ( etype_list == NULL ) { ret = krb5_unparse_name ( context , ctx -> request -> client , & name ) ; if ( ret == 0 ) { k5_setmsg ( context , KRB5_KT_NOTFOUND , _ ( "Keytab contains no suitable keys for %s" ) , name ) ; } krb5_free_unparsed_name ( context , name ) ; return KRB5_KT_NOTFOUND ; } ret = sort_enctypes ( ctx -> request -> ktype , ctx -> request -> nktypes , etype_list ) ; free ( etype_list ) ; return ret ; } 