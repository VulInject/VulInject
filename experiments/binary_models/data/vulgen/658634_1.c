static int yyl_leftcurly ( pTHX_ char * s , const U8 formbrack ) { char * d ; if ( PL_lex_brackets > 100 ) { Renew ( PL_lex_brackstack , PL_lex_brackets + 10 , char ) ; } switch ( PL_expect ) { case XTERM : case XTERMORDORDOR : PL_lex_brackstack [ PL_lex_brackets ++ ] = XOPERATOR ; PL_lex_allbrackets ++ ; OPERATOR ( HASHBRACK ) ; case XOPERATOR : while ( s < PL_bufend && SPACE_OR_TAB ( * s ) ) { s ++ ; } d = s ; PL_tokenbuf [ 0 ] = '\0' ; if ( d < PL_bufend && * d == '-' ) { PL_tokenbuf [ 0 ] = '-' ; while ( d < PL_bufend && SPACE_OR_TAB ( * d ) ) { d ++ ; } } if ( d < PL_bufend && isIDFIRST_lazy_if_safe ( d , PL_bufend , UTF ) ) { STRLEN len ; d = scan_word ( d , PL_tokenbuf + 1 , sizeof PL_tokenbuf - 1 , FALSE , & len ) ; while ( d < PL_bufend && SPACE_OR_TAB ( * d ) ) { d ++ ; } if ( * d == '}' ) { const char minus = ( PL_tokenbuf [ 0 ] == '-' ) ; s = force_word ( s + minus , BAREWORD , FALSE , TRUE ) ; if ( minus ) { force_next ( PERLY_MINUS ) ; } } } case XATTRTERM : case XTERMBLOCK : PL_lex_brackstack [ PL_lex_brackets ++ ] = XOPERATOR ; PL_lex_allbrackets ++ ; PL_expect = XSTATE ; break ; case XATTRBLOCK : case XBLOCK : PL_lex_brackstack [ PL_lex_brackets ++ ] = XSTATE ; PL_lex_allbrackets ++ ; PL_expect = XSTATE ; break ; case XBLOCKTERM : PL_lex_brackstack [ PL_lex_brackets ++ ] = XTERM ; PL_lex_allbrackets ++ ; PL_expect = XSTATE ; break ; default : { const char * t ; if ( PL_oldoldbufptr == PL_last_lop ) { PL_lex_brackstack [ PL_lex_brackets ++ ] = XTERM ; } else { PL_lex_brackstack [ PL_lex_brackets ++ ] = XOPERATOR ; } PL_lex_allbrackets ++ ; s = skipspace ( s ) ; if ( * s == '}' ) { if ( PL_expect == XREF && PL_lex_state == LEX_INTERPNORMAL ) { PL_expect = XTERM ; PL_bufptr = s + 1 ; yyerror ( "syntax error" ) ; break ; } OPERATOR ( HASHBRACK ) ; } if ( PL_expect == XREF && PL_oldoldbufptr != PL_last_lop ) { block_expectation } t = s ; if ( * s == '\'' || * s == '"' || * s == '`' ) { for ( t ++ ; t < PL_bufend && * t != * s ; ) { if ( * t ++ == '\\' ) { t ++ ; } } t ++ ; } if ( * s == 'q' ) { if ( ++ t < PL_bufend && ( ! isWORDCHAR ( * t ) || ( ( * t == 'q' || * t == 'x' ) && ++ t < PL_bufend && ! isWORDCHAR ( * t ) ) ) ) { const char * tmps ; char open , close , term ; I32 brackets = 1 ; while ( t < PL_bufend && isSPACE ( * t ) ) { t ++ ; } if ( t + 1 < PL_bufend && t [ 0 ] == '=' && t [ 1 ] == '>' ) { OPERATOR ( HASHBRACK ) ; } term = * t ; open = term ; if ( term && ( tmps = memCHRs ( "([{<)]}>)]}>" , term ) ) ) { term = tmps [ 5 ] ; } close = term ; if ( open == close ) { for ( t ++ ; t < PL_bufend ; t ++ ) { if ( * t == '\\' && t + 1 < PL_bufend && open != '\\' ) { t ++ ; } if ( * t == open ) { break ; } } } else { for ( t ++ ; t < PL_bufend ; t ++ ) { if ( * t == '\\' && t + 1 < PL_bufend ) { t ++ ; } if ( * t == close && -- brackets <= 0 ) { break ; } if ( * t == open ) { brackets ++ ; } } } t ++ ; } else { while ( t < PL_bufend && isWORDCHAR_lazy_if_safe ( t , PL_bufend , UTF ) ) { t += UTF ?UTF8SKIP ( t ) : 1 ; } } } if ( isWORDCHAR_lazy_if_safe ( t , PL_bufend , UTF ) ) { t += UTF ?UTF8SKIP ( t ) : 1 ; while ( t < PL_bufend && isWORDCHAR_lazy_if_safe ( t , PL_bufend , UTF ) ) { t += UTF ?UTF8SKIP ( t ) : 1 ; } } while ( t < PL_bufend && isSPACE ( * t ) ) { t ++ ; } if ( t < PL_bufend && ( ( * t == ',' && ( * s == 'q' || ! isLOWER ( * s ) ) ) || ( * t == '=' && t [ 1 ] == '>' ) ) ) { OPERATOR ( HASHBRACK ) ; } if ( PL_expect == XREF ) { block_expectation s = skipspace ( s ) ; if ( * s == '{' ) { PL_expect = XTERM ; break ; } if ( memBEGINs ( s , ( STRLEN ) ( PL_bufend - s ) , "sub" ) ) { PL_bufptr = s ; d = s + 3 ; d = skipspace ( d ) ; s = PL_bufptr ; if ( * d == ':' ) { PL_expect = XTERM ; break ; } } PL_expect = XSTATE ; } else { PL_lex_brackstack [ PL_lex_brackets - 1 ] = XSTATE ; PL_expect = XSTATE ; } } break ; } pl_yylval . ival = CopLINE ( PL_curcop ) ; PL_copline = NOLINE ; TOKEN ( formbrack ?PERLY_EQUAL_SIGN : PERLY_BRACE_OPEN ) ; } 