void mpi_ec_init ( struct mpi_ec_ctx * ctx , enum gcry_mpi_ec_models model , enum ecc_dialects dialect , int flags , MPI p , MPI a , MPI b ) { int i ; static int use_barrett = - 1 ; mpi_ec_coefficient_normalize ( a , p ) ; mpi_ec_coefficient_normalize ( b , p ) ; ctx -> model = model ; ctx -> dialect = dialect ; ctx -> flags = flags ; if ( dialect == ECC_DIALECT_ED25519 ) { ctx -> nbits = 256 ; } else { ctx -> nbits = mpi_get_nbits ( p ) ; } ctx -> p = mpi_copy ( p ) ; ctx -> a = mpi_copy ( a ) ; ctx -> b = mpi_copy ( b ) ; ctx -> t . p_barrett = use_barrett > 0 ?mpi_barrett_init ( ctx -> p , 0 ) : NULL ; mpi_ec_get_reset ( ctx ) ; else { for ( i = 0 ; i < DIM ( ctx -> t . scratch ) ; i ++ ) { ctx -> t . scratch [ i ] = mpi_alloc_like ( ctx -> p ) ; } } ctx -> addm = ec_addm ; ctx -> subm = ec_subm ; ctx -> mulm = ec_mulm ; ctx -> mul2 = ec_mul2 ; ctx -> pow2 = ec_pow2 ; for ( i = 0 ; field_table [ i ] . p ; i ++ ) { MPI f_p ; f_p = mpi_scanval ( field_table [ i ] . p ) ; if ( ! f_p ) { break ; } if ( ! mpi_cmp ( p , f_p ) ) { ctx -> addm = field_table [ i ] . addm ; ctx -> subm = field_table [ i ] . subm ; ctx -> mulm = field_table [ i ] . mulm ; ctx -> mul2 = field_table [ i ] . mul2 ; ctx -> pow2 = field_table [ i ] . pow2 ; mpi_free ( f_p ) ; mpi_resize ( ctx -> a , ctx -> p -> nlimbs ) ; ctx -> a -> nlimbs = ctx -> p -> nlimbs ; mpi_resize ( ctx -> b , ctx -> p -> nlimbs ) ; ctx -> b -> nlimbs = ctx -> p -> nlimbs ; for ( i = 0 ; i < DIM ( ctx -> t . scratch ) && ctx -> t . scratch [ i ] ; i ++ ) { ctx -> t . scratch [ i ] -> nlimbs = ctx -> p -> nlimbs ; } break ; } mpi_free ( f_p ) ; } } 