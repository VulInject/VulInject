void handler ( int signum , siginfo_t * si , void * vucontext ) { int i ; int trapno ; unsigned long ip ; dprintf1 ( "entered signal handler\n" ) ; trapno = uctxt -> uc_mcontext . gregs [ REG_TRAPNO ] ; ip = uctxt -> uc_mcontext . gregs [ REG_IP_IDX ] ; if ( trapno == 5 ) { typeof ( si -> si_addr ) * si_addr_ptr = & si -> si_addr ; uint64_t status = read_mpx_status_sig ( uctxt ) ; uint64_t br_reason = status & 0x3 ; br_count ++ ; dprintf1 ( "#BR 0x%jx (total seen: %d)\n" , status , br_count ) ; dprintf2 ( "Saw a #BR! status 0x%jx at %016lx br_reason: %jx\n" , status , ip , br_reason ) ; dprintf2 ( "si_signo: %d\n" , si -> si_signo ) ; dprintf2 ( "  signum: %d\n" , signum ) ; dprintf2 ( "info->si_code == SEGV_BNDERR: %d\n" , ( si -> si_code == SEGV_BNDERR ) ) ; dprintf2 ( "info->si_code: %d\n" , si -> si_code ) ; dprintf2 ( "info->si_lower: %p\n" , __si_bounds_lower ( si ) ) ; dprintf2 ( "info->si_upper: %p\n" , __si_bounds_upper ( si ) ) ; for ( i = 0 ; i < 8 ; i ++ ) { dprintf3 ( "[%d]: %p\n" , i , si_addr_ptr [ i ] ) ; } switch ( br_reason ) { case 0 : fprintf ( stderr , "Undefined status with bound exception:%jx\n" , status ) ; exit ( 5 ) ; case 1 : check_siginfo_vs_shadow ( si ) ; dprintf1 ( "bounds exception (normal): status 0x%jx at %p si_addr: %p\n" , status , ( void * ) ip , si -> si_addr ) ; num_bnd_chk ++ ; uctxt -> uc_mcontext . gregs [ REG_IP_IDX ] = ( greg_t ) get_next_inst_ip ( ( uint8_t * ) ip ) ; break ; case 2 : fprintf ( stderr , "#BR status == 2, missing bounds table," "kernel should have handled!!\n" ) ; exit ( 4 ) ; break ; default : fprintf ( stderr , "bound check error: status 0x%jx at %p\n" , status , ( void * ) ip ) ; num_bnd_chk ++ ; uctxt -> uc_mcontext . gregs [ REG_IP_IDX ] = ( greg_t ) get_next_inst_ip ( ( uint8_t * ) ip ) ; fprintf ( stderr , "bound check error: si_addr %p\n" , si -> si_addr ) ; exit ( 3 ) ; } } if ( trapno == 14 ) { eprintf ( "ERROR: In signal handler, page fault, trapno = %d, ip = %016lx\n" , trapno , ip ) ; eprintf ( "si_addr %p\n" , si -> si_addr ) ; eprintf ( "REG_ERR: %lx\n" , ( unsigned long ) uctxt -> uc_mcontext . gregs [ REG_ERR ] ) ; test_failed ( ) ; } else { eprintf ( "unexpected trap %d! at 0x%lx\n" , trapno , ip ) ; eprintf ( "si_addr %p\n" , si -> si_addr ) ; eprintf ( "REG_ERR: %lx\n" , ( unsigned long ) uctxt -> uc_mcontext . gregs [ REG_ERR ] ) ; test_failed ( ) ; } } 