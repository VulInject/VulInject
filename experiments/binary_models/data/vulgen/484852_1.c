static int ec168_ctrl_msg ( struct dvb_usb_device * d , struct ec168_req * req ) { int ret ; unsigned int pipe ; u8 request , requesttype ; u8 * buf ; switch ( req -> cmd ) { case DOWNLOAD_FIRMWARE : case GPIO : case WRITE_I2C : case STREAMING_CTRL : requesttype = ( USB_TYPE_VENDOR | USB_DIR_OUT ) ; request = req -> cmd ; break ; case READ_I2C : requesttype = ( USB_TYPE_VENDOR | USB_DIR_IN ) ; request = req -> cmd ; break ; case GET_CONFIG : requesttype = ( USB_TYPE_VENDOR | USB_DIR_IN ) ; request = CONFIG ; break ; case SET_CONFIG : requesttype = ( USB_TYPE_VENDOR | USB_DIR_OUT ) ; request = CONFIG ; break ; case WRITE_DEMOD : requesttype = ( USB_TYPE_VENDOR | USB_DIR_OUT ) ; request = DEMOD_RW ; break ; case READ_DEMOD : requesttype = ( USB_TYPE_VENDOR | USB_DIR_IN ) ; request = DEMOD_RW ; break ; default : dev_err ( & d -> udev -> dev , "%s: unknown command=%02x\n" , KBUILD_MODNAME , req -> cmd ) ; ret = - EINVAL ; error } buf = kmalloc ( req -> size , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; error } if ( requesttype == ( USB_TYPE_VENDOR | USB_DIR_OUT ) ) { memcpy ( buf , req -> data , req -> size ) ; pipe = usb_sndctrlpipe ( d -> udev , 0 ) ; } else { pipe = usb_rcvctrlpipe ( d -> udev , 0 ) ; } msleep ( 1 ) ; ret = usb_control_msg ( d -> udev , pipe , request , requesttype , req -> value , req -> index , buf , req -> size , EC168_USB_TIMEOUT ) ; dvb_usb_dbg_usb_control_msg ( d -> udev , request , requesttype , req -> value , req -> index , buf , req -> size ) ; if ( ret < 0 ) { err_dealloc } else { ret = 0 ; } if ( ! ret && requesttype == ( USB_TYPE_VENDOR | USB_DIR_IN ) ) { memcpy ( req -> data , buf , req -> size ) ; } return ret ; err_dealloc kfree ( buf ) ; error dev_dbg ( & d -> udev -> dev , "%s: failed=%d\n" , __func__ , ret ) ; return ret ; } static struct ec100_config ec168_ec100_config ; static int ec168_i2c_xfer ( struct i2c_adapter * adap , struct i2c_msg msg [ ] , int num ) { struct dvb_usb_device * d = i2c_get_adapdata ( adap ) ; struct ec168_req req ; int i = 0 ; int ret ; if ( num > 2 ) { return - EINVAL ; } if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) { return - EAGAIN ; } while ( i < num ) { if ( num > i + 1 && ( msg [ i + 1 ] . flags & I2C_M_RD ) ) { if ( msg [ i ] . addr == ec168_ec100_config . demod_address ) { req . cmd = READ_DEMOD ; req . value = 0 ; req . index = 0xff00 + msg [ i ] . buf [ 0 ] ; req . size = msg [ i + 1 ] . len ; req . data = & msg [ i + 1 ] . buf [ 0 ] ; ret = ec168_ctrl_msg ( d , & req ) ; i += 2 ; } else { dev_err ( & d -> udev -> dev , "%s: I2C read not " "implemented\n" , KBUILD_MODNAME ) ; ret = - EOPNOTSUPP ; i += 2 ; } } else { if ( msg [ i ] . addr == ec168_ec100_config . demod_address ) { req . cmd = WRITE_DEMOD ; req . value = msg [ i ] . buf [ 1 ] ; req . index = 0xff00 + msg [ i ] . buf [ 0 ] ; req . size = 0 ; req . data = NULL ; ret = ec168_ctrl_msg ( d , & req ) ; i += 1 ; } else { req . cmd = WRITE_I2C ; req . value = msg [ i ] . buf [ 0 ] ; req . index = 0x0100 + msg [ i ] . addr ; req . size = msg [ i ] . len - 1 ; req . data = & msg [ i ] . buf [ 1 ] ; ret = ec168_ctrl_msg ( d , & req ) ; i += 1 ; } } if ( ret ) { error } } ret = i ; error mutex_unlock ( & d -> i2c_mutex ) ; return ret ; } 