void proto_register_mctp ( void ) { static hf_register_info hf [ ] { { & hf_mctp_ver { "Version" "mctp.version" FT_UINT8 BASE_DEC NULL 0x0f NULL HFILL } } { & hf_mctp_dst { "Destination" "mctp.dst" FT_UINT8 BASE_DEC NULL 0x00 NULL HFILL } } { & hf_mctp_src { "Source" "mctp.src" FT_UINT8 BASE_DEC NULL 0x00 NULL HFILL } } { & hf_mctp_flags { "Flags" "mctp.flags" FT_UINT8 BASE_HEX NULL 0xc0 NULL HFILL } } { & hf_mctp_flags_som { "Start of message" "mctp.flags.som" FT_BOOLEAN 8 TFS ( & tfs_set_notset ) 0x80 NULL HFILL } } { & hf_mctp_flags_eom { "End of message" "mctp.flags.eom" FT_BOOLEAN 8 TFS ( & tfs_set_notset ) 0x40 NULL HFILL } } { & hf_mctp_seq { "Sequence" "mctp.seq" FT_UINT8 BASE_HEX NULL 0x30 NULL HFILL } } { & hf_mctp_tag { "Tag" "mctp.tag" FT_UINT8 BASE_HEX NULL 0x0f NULL HFILL } } { & hf_mctp_tag_to { "Tag owner" "mctp.tag.to" FT_BOOLEAN 8 TFS ( & tfs_tag_to ) 0x08 NULL HFILL } } { & hf_mctp_tag_value { "Tag value" "mctp.tag.value" FT_UINT8 BASE_HEX NULL 0x07 NULL HFILL } } { & hf_mctp_msg_ic { "Integrity check" "mctp.msg.ic" FT_BOOLEAN 8 TFS ( & tfs_present_absent ) 0x80 NULL HFILL } } { & hf_mctp_msg_type { "Message type" "mctp.msg.type" FT_UINT8 BASE_HEX VALS ( type_vals ) 0x7f NULL HFILL } } { & hf_mctp_fragments { "Message fragments" "mctp.fragments" FT_NONE BASE_NONE NULL 0x00 NULL HFILL } } { & hf_mctp_fragment { "Message fragment" "mctp.fragment" FT_FRAMENUM BASE_NONE NULL 0x00 NULL HFILL } } { & hf_mctp_fragment_overlap { "Message fragment overlap" "mctp.fragment.overlap" FT_BOOLEAN 0 NULL 0x00 NULL HFILL } } { & hf_mctp_fragment_overlap_conflicts { "Message fragment overlapping with conflicting data" "mctp.fragment.overlap.conflicts" FT_BOOLEAN 0 NULL 0x00 NULL HFILL } } { & hf_mctp_fragment_multiple_tails { "Message has multiple tail fragments" "mctp.fragment.multiple_tails" FT_BOOLEAN 0 NULL 0x00 NULL HFILL } } { & hf_mctp_fragment_too_long_fragment { "Message fragment too long" "mctp.fragment.too_long_fragment" FT_BOOLEAN 0 NULL 0x00 NULL HFILL } } { & hf_mctp_fragment_error { "Message defragmentation error" "mctp.fragment.error" FT_FRAMENUM BASE_NONE NULL 0x00 NULL HFILL } } { & hf_mctp_fragment_count { "Message fragment count" "mctp.fragment.count" FT_UINT32 BASE_DEC NULL 0x00 NULL HFILL } } { & hf_mctp_reassembled_in { "Reassembled in" "mctp.reassembled.in" FT_FRAMENUM BASE_NONE NULL 0x00 NULL HFILL } } { & hf_mctp_reassembled_length { "Reassembled length" "mctp.reassembled.length" FT_UINT32 BASE_DEC NULL 0x00 NULL HFILL } } { & hf_mctp_reassembled_data { "Reassembled data" "mctp.reassembled.data" FT_BYTES SEP_SPACE NULL 0x00 NULL HFILL } } } ; ; static gint * ett [ ] { & ett_mctp & ett_mctp_flags & ett_mctp_fst & ett_mctp_tag & ett_mctp_type & ett_mctp_fragment & ett_mctp_fragments } ; ; proto_mctp = proto_register_protocol ( "MCTP" , "MCTP" , "mctp" ) ; proto_register_field_array ( proto_mctp , hf , array_length ( hf ) ) ; proto_register_subtree_array ( ett , array_length ( ett ) ) ; mctp_dissector_table = register_dissector_table ( "mctp.type" , "MCTP type" , proto_mctp , FT_UINT8 , BASE_HEX ) ; mctp_encap_dissector_table = register_dissector_table ( "mctp.encap-type" , "MCTP encapsulated type" , proto_mctp , FT_UINT8 , BASE_HEX ) ; } 