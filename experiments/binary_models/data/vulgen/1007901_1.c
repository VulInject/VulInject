static int write_completed_directory ( struct merge_options * opt , const char * new_directory_name , struct directory_versions * info ) { const char * prev_dir ; struct merged_info * dir_info = NULL ; unsigned int offset , ret = 0 ; if ( new_directory_name == info -> last_directory ) { return 0 ; } if ( info -> last_directory == NULL || ! strncmp ( new_directory_name , info -> last_directory , info -> last_directory_len ) ) { uintptr_t offset = info -> versions . nr ; info -> last_directory = new_directory_name ; info -> last_directory_len = strlen ( info -> last_directory ) ; string_list_append ( & info -> offsets , info -> last_directory ) -> util = ( void * ) offset ; return 0 ; } dir_info = strmap_get ( & opt -> priv -> paths , info -> last_directory ) ; assert ( dir_info ) ; offset = ( uintptr_t ) info -> offsets . items [ info -> offsets . nr - 1 ] . util ; if ( offset == info -> versions . nr ) { dir_info -> is_null = 1 ; } else { dir_info -> is_null = 0 ; dir_info -> result . mode = S_IFDIR ; if ( write_tree ( & dir_info -> result . oid , & info -> versions , offset , opt -> repo -> hash_algo -> rawsz ) < 0 ) { ret = - 1 ; } } info -> offsets . nr -- ; info -> versions . nr = offset ; prev_dir = info -> offsets . nr == 0 ?NULL : info -> offsets . items [ info -> offsets . nr - 1 ] . string ; info -> last_directory = new_directory_name ; info -> last_directory_len = strlen ( info -> last_directory ) ; return ret ; } 