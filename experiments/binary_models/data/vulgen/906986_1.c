LIBXSMM_API int libxsmm_mhd_read ( const char filename [ ] , const size_t offset [ ] , const size_t size [ ] , const size_t pitch [ ] , size_t ndims , size_t ncomponents , size_t header_size , libxsmm_mhd_elemtype type_stored , const libxsmm_mhd_elemtype * type_data , void * data , libxsmm_mhd_element_handler handle_element , char extension [ ] , size_t extension_size ) { int result = EXIT_SUCCESS ; FILE * const file = ( NULL != filename && 0 != * filename && NULL != size && 0 != ndims && 0 != ncomponents && LIBXSMM_MHD_ELEMTYPE_UNKNOWN != type_stored && ( NULL == type_data || LIBXSMM_MHD_ELEMTYPE_UNKNOWN != * type_data ) && ( NULL != data ) ) ?fopen ( filename , "rb" ) : NULL ; if ( NULL != file ) { const libxsmm_mhd_elemtype datatype = ( type_data ?* type_data : type_stored ) ; const size_t * const shape = ( NULL != pitch ?pitch : size ) ; size_t offset1 = ( NULL != offset ?offset [ 0 ] : 0 ) , typesize = 0 , i ; if ( EXIT_SUCCESS == result ) { for ( i = 0 ; i < ndims ; ++ i ) { if ( size [ i ] > shape [ i ] ) { break ; } } } if ( EXIT_SUCCESS == result ) { if ( NULL != libxsmm_mhd_typename ( datatype , & typesize , NULL ) ) { size_t size1 = size [ 0 ] , pitch1 = shape [ 0 ] ; for ( i = 1 ; i < ndims ; ++ i ) { offset1 += ( NULL != offset ?offset [ i ] : 0 ) * pitch1 ; pitch1 *= shape [ i ] ; size1 *= size [ i ] ; } LIBXSMM_ASSERT ( size1 <= pitch1 ) ; if ( size1 != pitch1 && NULL == handle_element ) { memset ( data , 0 , pitch1 * ncomponents * typesize ) ; } } else { result = EXIT_FAILURE ; } } if ( EXIT_SUCCESS == result ) { char * const output = ( ( char * ) data ) + offset1 * ncomponents * typesize ; char minmax [ 2 * ( LIBXSMM_MHD_MAX_ELEMSIZE ) ] ; if ( 0 != header_size ) { result = fseek ( file , ( long ) header_size , SEEK_SET ) ; } if ( EXIT_SUCCESS == result && datatype != type_stored ) { if ( 1 == fread ( minmax , typesize , 1 , file ) ) { LIBXSMM_ASSERT ( typesize <= ( LIBXSMM_MHD_MAX_ELEMSIZE ) ) ; LIBXSMM_MEMCPY127 ( minmax + ( LIBXSMM_MHD_MAX_ELEMSIZE ) , minmax , typesize ) ; result = fseek ( file , ( long ) header_size , SEEK_SET ) ; if ( EXIT_SUCCESS == result ) { result = internal_mhd_read ( file , NULL , size , shape , ndims , ncomponents , type_stored , datatype , typesize , handle_element , 1 , minmax , minmax + ( LIBXSMM_MHD_MAX_ELEMSIZE ) ) ; } if ( EXIT_SUCCESS == result ) { result = fseek ( file , ( long ) header_size , SEEK_SET ) ; } } else { result = EXIT_FAILURE ; } } if ( EXIT_SUCCESS == result ) { result = internal_mhd_read ( file , output , size , shape , ndims , ncomponents , type_stored , datatype , typesize , handle_element , 0 , minmax , minmax + ( LIBXSMM_MHD_MAX_ELEMSIZE ) ) ; } } if ( NULL != extension && 0 < extension_size ) { if ( extension_size != fread ( extension , 1 , extension_size , file ) ) { result = EXIT_FAILURE ; } } if ( 0 != fclose ( file ) && EXIT_SUCCESS == result ) { result = EXIT_FAILURE ; } } else { result = EXIT_FAILURE ; } return result ; } 