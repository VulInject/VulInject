spill_restore_mem ( , ) { int iter = spill_fill_data . next_iter ; HOST_WIDE_INT disp = spill_fill_data . prev_off [ iter ] - cfa_off ; rtx disp_rtx = GEN_INT ( disp ) ; rtx mem ; if ( spill_fill_data . prev_addr [ iter ] ) { if ( CONST_OK_FOR_N ( disp ) ) { * spill_fill_data . prev_addr [ iter ] = gen_rtx_POST_MODIFY ( DImode , spill_fill_data . iter_reg [ iter ] , gen_rtx_PLUS ( DImode , spill_fill_data . iter_reg [ iter ] , disp_rtx ) ) ; REG_NOTES ( spill_fill_data . prev_insn [ iter ] ) = gen_rtx_EXPR_LIST ( REG_INC , spill_fill_data . iter_reg [ iter ] , REG_NOTES ( spill_fill_data . prev_insn [ iter ] ) ) ; } else { if ( ! CONST_OK_FOR_I ( disp ) ) { rtx tmp = gen_rtx_REG ( DImode , next_scratch_gr_reg ( ) ) ; emit_move_insn ( tmp , disp_rtx ) ; disp_rtx = tmp ; } emit_insn ( gen_adddi3 ( spill_fill_data . iter_reg [ iter ] , spill_fill_data . iter_reg [ iter ] , disp_rtx ) ) ; } } if ( disp == 0 && spill_fill_data . init_reg [ iter ] == stack_pointer_rtx && frame_pointer_needed ) { mem = gen_rtx_MEM ( GET_MODE ( reg ) , hard_frame_pointer_rtx ) ; set_mem_alias_set ( mem , get_varargs_alias_set ( ) ) ; return mem ; } else { rtx seq , insn ; if ( disp == 0 ) { seq = gen_movdi ( spill_fill_data . iter_reg [ iter ] , spill_fill_data . init_reg [ iter ] ) ; } else { start_sequence ( ) ; if ( ! CONST_OK_FOR_I ( disp ) ) { rtx tmp = gen_rtx_REG ( DImode , next_scratch_gr_reg ( ) ) ; emit_move_insn ( tmp , disp_rtx ) ; disp_rtx = tmp ; } emit_insn ( gen_adddi3 ( spill_fill_data . iter_reg [ iter ] , spill_fill_data . init_reg [ iter ] , disp_rtx ) ) ; seq = get_insns ( ) ; end_sequence ( ) ; } if ( spill_fill_data . init_after ) { insn = emit_insn_after ( seq , spill_fill_data . init_after ) ; } else { rtx first = get_insns ( ) ; if ( first ) { insn = emit_insn_before ( seq , first ) ; } else { insn = emit_insn ( seq ) ; } } spill_fill_data . init_after = insn ; } mem = gen_rtx_MEM ( GET_MODE ( reg ) , spill_fill_data . iter_reg [ iter ] ) ; set_mem_alias_set ( mem , get_varargs_alias_set ( ) ) ; spill_fill_data . prev_addr [ iter ] = & XEXP ( mem , 0 ) ; spill_fill_data . prev_off [ iter ] = cfa_off ; if ( ++ iter >= spill_fill_data . n_iter ) { iter = 0 ; } spill_fill_data . next_iter = iter ; return mem ; } 