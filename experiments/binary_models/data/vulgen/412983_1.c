int se050_ecc_shared_secret ( ecc_key * private_key , ecc_key * public_key , byte * out , word32 * outlen ) { int ret ; sss_status_t status = kStatus_SSS_Success ; sss_key_store_t host_keystore ; sss_object_t ref_private_key ; sss_object_t ref_public_key ; sss_object_t deriveKey ; sss_derive_key_t ctx_derive_key ; word32 keyId ; int keySize ; int keySizeBits ; sss_cipher_type_t curveType ; int keyCreated = 0 ; int deriveKeyCreated = 0 ; printf ( "se050_ecc_shared_secret: priv %p, pub %p, out %p (%d)\n" , private_key , public_key , out , * outlen ) ; if ( cfg_se050_i2c_pi == NULL ) { return WC_HW_E ; } if ( private_key == NULL || public_key == NULL || private_key -> keyIdSet == 0 ) { return BAD_FUNC_ARG ; } keySize = private_key -> dp -> size ; ret = se050_map_curve ( private_key -> dp -> id , keySize , & keySizeBits , & curveType ) ; if ( ret != 0 ) { return ret ; } status = sss_key_store_context_init ( & host_keystore , cfg_se050_i2c_pi ) ; if ( status == kStatus_SSS_Success ) { status = sss_key_store_allocate ( & host_keystore , SE050_KEYSTOREID_ECC ) ; } if ( status == kStatus_SSS_Success ) { status = sss_key_object_init ( & ref_private_key , & host_keystore ) ; } if ( status == kStatus_SSS_Success ) { status = sss_key_object_get_handle ( & ref_private_key , private_key -> keyId ) ; } if ( status == kStatus_SSS_Success ) { status = sss_key_object_init ( & ref_public_key , & host_keystore ) ; } if ( status == kStatus_SSS_Success ) { keyId = public_key -> keyId ; if ( public_key -> keyIdSet == 0 ) { byte derBuf [ SE050_ECC_DER_MAX ] ; word32 derSz ; ret = wc_EccPublicKeyToDer ( public_key , derBuf , ( word32 ) sizeof ( derBuf ) , 1 ) ; if ( ret >= 0 ) { derSz = ret ; ret = 0 ; } else { status = kStatus_SSS_Fail ; } if ( status == kStatus_SSS_Success ) { keyId = se050_allocate_key ( SE050_ECC_KEY ) ; status = sss_key_object_allocate_handle ( & ref_public_key , keyId , kSSS_KeyPart_Public , curveType , keySize , kKeyObject_Mode_Persistent ) ; } if ( status == kStatus_SSS_Success ) { sss_key_store_erase_key ( & host_keystore , & ref_public_key ) ; status = sss_key_store_set_key ( & host_keystore , & ref_public_key , derBuf , derSz , keySizeBits , NULL , 0 ) ; keyCreated = 1 ; } } else { status = sss_key_object_get_handle ( & ref_public_key , keyId ) ; } } if ( status == kStatus_SSS_Success ) { status = sss_key_object_init ( & deriveKey , & host_keystore ) ; } if ( status == kStatus_SSS_Success ) { word32 keyIdAes = se050_allocate_key ( SE050_AES_KEY ) ; status = sss_key_object_allocate_handle ( & deriveKey , keyIdAes , kSSS_KeyPart_Default , kSSS_CipherType_Binary , keySize , kKeyObject_Mode_Transient ) ; } if ( status == kStatus_SSS_Success ) { status = sss_derive_key_context_init ( & ctx_derive_key , cfg_se050_i2c_pi , & ref_private_key , kAlgorithm_SSS_ECDH , kMode_SSS_ComputeSharedSecret ) ; if ( status == kStatus_SSS_Success ) { sss_key_store_erase_key ( & host_keystore , & deriveKey ) ; status = sss_derive_key_dh ( & ctx_derive_key , & ref_public_key , & deriveKey ) ; } if ( status == kStatus_SSS_Success ) { size_t outlenSz = ( size_t ) * outlen ; size_t outlenSzBits = outlenSz * 8 ; deriveKeyCreated = 1 ; status = sss_key_store_get_key ( & host_keystore , & deriveKey , out , & outlenSz , & outlenSzBits ) ; * outlen = ( word32 ) outlenSz ; ( void ) outlenSzBits ; } sss_derive_key_context_free ( & ctx_derive_key ) ; } if ( deriveKeyCreated ) { sss_key_store_erase_key ( & host_keystore , & deriveKey ) ; sss_key_object_free ( & deriveKey ) ; } if ( status == kStatus_SSS_Success ) { public_key -> keyId = keyId ; public_key -> keyIdSet = 1 ; ret = 0 ; } else { if ( keyCreated ) { sss_key_store_erase_key ( & host_keystore , & ref_public_key ) ; sss_key_object_free ( & ref_public_key ) ; } if ( ret == 0 ) { ret = WC_HW_E ; } } wolfSSL_CryptHwMutexUnLock ( ) ; printf ( "se050_ecc_shared_secret: ret %d, outlen %d\n" , ret , * outlen ) ; return ret ; } 