void setup_rt_frame ( int sig , struct target_sigaction * ka , target_siginfo_t * info , target_sigset_t * set , CPUArchState * env ) { abi_ulong frame_addr , sp , haddr ; struct target_rt_sigframe * frame ; int i ; TaskState * ts = ( TaskState * ) thread_cpu -> opaque ; sp = get_sp_from_cpustate ( env ) ; if ( ( ka -> sa_flags & TARGET_SA_ONSTACK ) && ! sas_ss_flags ( sp ) ) { sp = ( ts -> sigaltstack_used . ss_sp + 0x7f ) & ~ 0x3f ; } frame_addr = QEMU_ALIGN_UP ( sp , 64 ) ; sp = frame_addr + PARISC_RT_SIGFRAME_SIZE32 ; trace_user_setup_rt_frame ( env , frame_addr ) ; if ( ! lock_user_struct ( VERIFY_WRITE , frame , frame_addr , 0 ) ) { give_sigsegv } tswap_siginfo ( & frame -> info , info ) ; frame -> uc . tuc_flags = 0 ; frame -> uc . tuc_link = 0 ; target_save_altstack ( & frame -> uc . tuc_stack , env ) ; for ( i = 0 ; i < TARGET_NSIG_WORDS ; i ++ ) { __put_user ( set -> sig [ i ] , & frame -> uc . tuc_sigmask . sig [ i ] ) ; } setup_sigcontext ( & frame -> uc . tuc_mcontext , env ) ; __put_user ( 0x34190000 , frame -> tramp + 0 ) ; __put_user ( 0x3414015a , frame -> tramp + 1 ) ; __put_user ( 0xe4008200 , frame -> tramp + 2 ) ; __put_user ( 0x08000240 , frame -> tramp + 3 ) ; unlock_user_struct ( frame , frame_addr , 1 ) ; env -> gr [ 2 ] = h2g ( frame -> tramp ) ; env -> gr [ 30 ] = sp ; env -> gr [ 26 ] = sig ; env -> gr [ 25 ] = h2g ( & frame -> info ) ; env -> gr [ 24 ] = h2g ( & frame -> uc ) ; haddr = ka -> _sa_handler ; env -> iaoq_f = haddr ; env -> iaoq_b = haddr + 4 ; return ; give_sigsegv force_sigsegv ( sig ) ; } 