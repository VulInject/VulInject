void ProcArrayRemove ( PGPROC * proc , TransactionId latestXid ) { ProcArrayStruct * arrayP = procArray ; int myoff ; int movecount ; LWLockAcquire ( ProcArrayLock , LW_EXCLUSIVE ) ; LWLockAcquire ( XidGenLock , LW_EXCLUSIVE ) ; myoff = proc -> pgxactoff ; Assert ( myoff >= 0 && myoff < arrayP -> numProcs ) ; Assert ( ProcGlobal -> allProcs [ arrayP -> pgprocnos [ myoff ] ] . pgxactoff == myoff ) ; if ( TransactionIdIsValid ( latestXid ) ) { Assert ( TransactionIdIsValid ( ProcGlobal -> xids [ myoff ] ) ) ; MaintainLatestCompletedXid ( latestXid ) ; ShmemVariableCache -> xactCompletionCount ++ ; ProcGlobal -> xids [ myoff ] = InvalidTransactionId ; ProcGlobal -> subxidStates [ myoff ] . overflowed = false ; ProcGlobal -> subxidStates [ myoff ] . count = 0 ; } else { Assert ( ! TransactionIdIsValid ( ProcGlobal -> xids [ myoff ] ) ) ; } Assert ( ! TransactionIdIsValid ( ProcGlobal -> xids [ myoff ] ) ) ; Assert ( ProcGlobal -> subxidStates [ myoff ] . count == 0 ) ; Assert ( ProcGlobal -> subxidStates [ myoff ] . overflowed == false ) ; ProcGlobal -> statusFlags [ myoff ] = 0 ; movecount = arrayP -> numProcs - myoff - 1 ; memmove ( & arrayP -> pgprocnos [ myoff ] , & arrayP -> pgprocnos [ myoff + 1 ] , movecount * sizeof ( * arrayP -> pgprocnos ) ) ; memmove ( & ProcGlobal -> xids [ myoff ] , & ProcGlobal -> xids [ myoff + 1 ] , movecount * sizeof ( * ProcGlobal -> xids ) ) ; memmove ( & ProcGlobal -> subxidStates [ myoff ] , & ProcGlobal -> subxidStates [ myoff + 1 ] , movecount * sizeof ( * ProcGlobal -> subxidStates ) ) ; memmove ( & ProcGlobal -> statusFlags [ myoff ] , & ProcGlobal -> statusFlags [ myoff + 1 ] , movecount * sizeof ( * ProcGlobal -> statusFlags ) ) ; arrayP -> pgprocnos [ arrayP -> numProcs - 1 ] = - 1 ; arrayP -> numProcs -- ; for ( int index = myoff ; index < arrayP -> numProcs ; index ++ ) { int procno = arrayP -> pgprocnos [ index ] ; Assert ( procno >= 0 && procno < ( arrayP -> maxProcs + NUM_AUXILIARY_PROCS ) ) ; Assert ( allProcs [ procno ] . pgxactoff - 1 == index ) ; allProcs [ procno ] . pgxactoff = index ; } LWLockRelease ( XidGenLock ) ; LWLockRelease ( ProcArrayLock ) ; } 