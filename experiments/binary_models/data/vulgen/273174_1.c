int __memp_pg ( dbmfp , bhp , is_pgin ) DB_MPOOLFILE * dbmfp ; BH * bhp ; int is_pgin ; { DBT dbt , * dbtp ; DB_MPOOL * dbmp ; DB_MPREG * mpreg ; MPOOLFILE * mfp ; int ftype , ret ; dbmp = dbmfp -> dbmp ; mfp = dbmfp -> mfp ; ftype = mfp -> ftype ; for ( mpreg = LIST_FIRST ( & dbmp -> dbregq ) ; mpreg != NULL ; mpreg = LIST_NEXT ( mpreg , q ) ) { if ( ftype != mpreg -> ftype ) { continue ; } if ( mfp -> pgcookie_len == 0 ) { dbtp = NULL ; } else { dbt . size = mfp -> pgcookie_len ; dbt . data = R_ADDR ( dbmp , mfp -> pgcookie_off ) ; dbtp = & dbt ; } UNLOCKHANDLE ( dbmp , dbmp -> mutexp ) ; if ( is_pgin ) { if ( mpreg -> pgin != NULL && ( ret = mpreg -> pgin ( bhp -> pgno , bhp -> buf , dbtp ) ) != 0 ) { err } } if ( mpreg -> pgout != NULL && ( ret = mpreg -> pgout ( bhp -> pgno , bhp -> buf , dbtp ) ) != 0 ) { err } break ; } if ( mpreg == NULL ) { UNLOCKHANDLE ( dbmp , dbmp -> mutexp ) ; } return ( 0 ) ; err UNLOCKHANDLE ( dbmp , dbmp -> mutexp ) ; __db_err ( dbmp -> dbenv , "%s: %s failed for page %lu" , __memp_fn ( dbmfp ) , is_pgin ?"pgin" : "pgout" , ( u_long ) bhp -> pgno ) ; return ( ret ) ; } 