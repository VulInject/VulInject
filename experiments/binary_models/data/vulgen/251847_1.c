* LIABILITY , WHETHER IN CONTRACT , STRICT LIABILITY , OR TORT ( ) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE . * * This license will be governed by the laws of the Commonwealth of Virginia , * without reference to its choice of law rules . * / extern int connector ; int schd_run_job_on ( Job * job , Queue * destq , char * exechost , int set_comment ) { char * id = "schd_run_job_on" ; Queue * srcq = NULL ; char * date ; char reason [ 128 ] ; int local_errno = 0 ; date = ctime ( & schd_TimeNow ) ; date [ strlen ( date ) - 1 ] = '\0' ; if ( job -> state != 'Q' ) { ( void ) sprintf ( log_buffer , "run_job_on(%s, %s) called with job not in 'Q' state.\n" , job -> jobid , ( destq ?destq -> qname : "(NULL)" ) ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; return ( - 1 ) ; } if ( set_comment ) { sprintf ( reason , "Started on %s" , date ) ; if ( job -> flags & JFLAGS_PRIORITY ) { strcat ( reason , " (special access job)" ) ; } if ( job -> flags & JFLAGS_WAITING ) { strcat ( reason , " (waited too long)" ) ; } } srcq = job -> queue ; if ( ( destq != NULL ) && ( strcmp ( destq -> qname , srcq -> qname ) != 0 ) ) { if ( schd_TEST_ONLY ) { DBPRT ( ( "%s: would have moved %s from queue %s to queue %s\n" , id , job -> jobid , srcq -> qname , destq -> qname ) ) ; } else { if ( pbs_movejob ( connector , job -> jobid , destq -> qname , NULL ) ) { ( void ) sprintf ( log_buffer , "move job %s to queue %s failed, %d" , job -> jobid , destq -> qname , pbs_errno ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; return ( - 1 ) ; } } schd_move_job_to ( job , destq ) ; } if ( schd_TEST_ONLY ) { DBPRT ( ( "%s: would have run %s on queue %s\n" , id , job -> jobid , destq -> qname ) ) ; } else { if ( pbs_runjob_err ( connector , job -> jobid , exechost , NULL , & local_errno ) ) { ( void ) sprintf ( log_buffer , "failed start job %s on queue %s@%s, %d" , job -> jobid , destq -> qname , exechost , local_errno ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; if ( srcq ) { DBPRT ( ( "Attempting to move job %s back to queue %s\n" , job -> jobid , srcq -> qname ) ) ; if ( pbs_movejob ( connector , job -> jobid , srcq -> qname , NULL ) ) { ( void ) sprintf ( log_buffer , "failed to move job %s back to queue %s, %d" , job -> jobid , srcq -> qname , pbs_errno ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; } schd_move_job_to ( job , srcq ) ; } return ( - 1 ) ; } } ( void ) sprintf ( log_buffer , "job %s started on %s@%s" , job -> jobid , destq -> qname , exechost ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; DBPRT ( ( "%s: %s\n" , id , log_buffer ) ) ; job -> state = 'R' ; job -> queue -> queued -- ; job -> queue -> running ++ ; job -> queue -> idle_since = 0 ; return ( 0 ) ; } int schd_charge_job ( Job * job , Queue * queue , Resources * rsrcs ) { char * id = "schd_charge_job" ; time_t job_ends ; queue -> nodes_assn += job -> nodes ; rsrcs -> nodes_alloc += job -> nodes ; rsrcs -> freemem -= ( job -> nodes * MB_PER_NODE ) ; rsrcs -> njobs ++ ; if ( ( queue -> nodes_max != UNSPECIFIED ) && ( queue -> nodes_max <= queue -> nodes_assn ) ) { DBPRT ( ( "%s: Queue %s node limit (%d) reached - mark full\n" , id , queue -> qname , queue -> nodes_max ) ) ; queue -> flags |= QFLAGS_FULL ; } if ( job -> walltime != UNSPECIFIED ) { job_ends = schd_TimeNow + job -> walltime ; if ( job_ends > queue -> empty_by ) { DBPRT ( ( "%s: Queue %s empty_by %s to %s" , id , queue -> qname , queue -> empty_by ?"bumped" : "set to" , ctime ( & job_ends ) ) ) ; queue -> empty_by = job_ends ; } } schd_update_resource_usage ( job ) ; return ( 0 ) ; } 