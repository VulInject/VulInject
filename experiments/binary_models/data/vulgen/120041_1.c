static int tcf_connmark_init ( struct net * net , struct nlattr * nla , struct nlattr * est , struct tc_action * * a , struct tcf_proto * tp , u32 flags , struct netlink_ext_ack * extack ) { struct tc_action_net * tn = net_generic ( net , act_connmark_ops . net_id ) ; struct tcf_connmark_parms * nparms , * oparms ; struct nlattr * tb [ TCA_CONNMARK_MAX + 1 ] ; bool bind = flags & TCA_ACT_FLAGS_BIND ; struct tcf_chain * goto_ch = NULL ; struct tcf_connmark_info * ci ; struct tc_connmark * parm ; int ret = 0 , err ; u32 index ; if ( ! nla ) { return - EINVAL ; } ret = nla_parse_nested_deprecated ( tb , TCA_CONNMARK_MAX , nla , connmark_policy , NULL ) ; if ( ret < 0 ) { return ret ; } if ( ! tb [ TCA_CONNMARK_PARMS ] ) { return - EINVAL ; } nparms = kzalloc ( sizeof ( * nparms ) , GFP_KERNEL ) ; if ( ! nparms ) { return - ENOMEM ; } parm = nla_data ( tb [ TCA_CONNMARK_PARMS ] ) ; index = parm -> index ; ret = tcf_idr_check_alloc ( tn , & index , a , bind ) ; if ( ! ret ) { ret = tcf_idr_create_from_flags ( tn , index , est , a , & act_connmark_ops , bind , flags ) ; if ( ret ) { tcf_idr_cleanup ( tn , index ) ; err = ret ; out_free } ci = to_connmark ( * a ) ; nparms -> net = net ; nparms -> zone = parm -> zone ; ret = ACT_P_CREATED ; } if ( ret > 0 ) { ci = to_connmark ( * a ) ; if ( bind ) { err = 0 ; out_free } if ( ! ( flags & TCA_ACT_FLAGS_REPLACE ) ) { err = - EEXIST ; release_idr } nparms -> net = rtnl_dereference ( ci -> parms ) -> net ; nparms -> zone = parm -> zone ; ret = 0 ; } err = tcf_action_check_ctrlact ( parm -> action , tp , & goto_ch , extack ) ; spin_lock_bh ( & ci -> tcf_lock ) ; goto_ch = tcf_action_set_ctrlact ( * a , parm -> action , goto_ch ) ; oparms = rcu_replace_pointer ( ci -> parms , nparms , lockdep_is_held ( & ci -> tcf_lock ) ) ; spin_unlock_bh ( & ci -> tcf_lock ) ; if ( goto_ch ) { tcf_chain_put_by_act ( goto_ch ) ; } if ( oparms ) { kfree_rcu ( oparms , rcu ) ; } return ret ; release_idr tcf_idr_release ( * a , bind ) ; out_free kfree ( nparms ) ; return err ; } 