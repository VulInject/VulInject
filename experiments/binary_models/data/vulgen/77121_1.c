int sqliteExprCheck ( Parse * pParse , Expr * pExpr , int allowAgg , int * pIsAgg ) { int nErr = 0 ; switch ( pExpr -> op ) { case TK_GLOB : case TK_LIKE : case TK_FUNCTION : { int n = pExpr -> pList ?pExpr -> pList -> nExpr : 0 ; int no_such_func = 0 ; int wrong_num_args = 0 ; int is_agg = 0 ; int i ; int nId ; const char * zId ; FuncDef * pDef ; getFunctionName ( pExpr , & zId , & nId ) ; pDef = sqliteFindFunction ( pParse -> db , zId , nId , n , 0 ) ; if ( pDef == 0 ) { pDef = sqliteFindFunction ( pParse -> db , zId , nId , - 1 , 0 ) ; if ( pDef == 0 ) { no_such_func = 1 ; } else { wrong_num_args = 1 ; } } else { is_agg = pDef -> xFunc == 0 ; } if ( is_agg && ! allowAgg ) { sqliteErrorMsg ( pParse , "misuse of aggregate function %.*s()" , nId , zId ) ; nErr ++ ; is_agg = 0 ; } if ( no_such_func ) { sqliteErrorMsg ( pParse , "no such function: %.*s" , nId , zId ) ; nErr ++ ; } if ( wrong_num_args ) { sqliteErrorMsg ( pParse , "wrong number of arguments to function %.*s()" , nId , zId ) ; nErr ++ ; } if ( is_agg ) { pExpr -> op = TK_AGG_FUNCTION ; if ( pIsAgg ) { * pIsAgg = 1 ; } } for ( i = 0 ; nErr == 0 && i < n ; i ++ ) { nErr = sqliteExprCheck ( pParse , pExpr -> pList -> a [ i ] . pExpr , allowAgg && ! is_agg , pIsAgg ) ; } if ( pDef == 0 ) { } if ( pDef -> dataType >= 0 ) { if ( pDef -> dataType < n ) { pExpr -> dataType = sqliteExprType ( pExpr -> pList -> a [ pDef -> dataType ] . pExpr ) ; } else { pExpr -> dataType = SQLITE_SO_NUM ; } } if ( pDef -> dataType == SQLITE_ARGS ) { pDef -> dataType = SQLITE_SO_TEXT ; for ( i = 0 ; i < n ; i ++ ) { if ( sqliteExprType ( pExpr -> pList -> a [ i ] . pExpr ) == SQLITE_SO_NUM ) { pExpr -> dataType = SQLITE_SO_NUM ; break ; } } } if ( pDef -> dataType == SQLITE_NUMERIC ) { pExpr -> dataType = SQLITE_SO_NUM ; } else { pExpr -> dataType = SQLITE_SO_TEXT ; } } default : { if ( pExpr -> pLeft ) { nErr = sqliteExprCheck ( pParse , pExpr -> pLeft , allowAgg , pIsAgg ) ; } if ( nErr == 0 && pExpr -> pRight ) { nErr = sqliteExprCheck ( pParse , pExpr -> pRight , allowAgg , pIsAgg ) ; } if ( nErr == 0 && pExpr -> pList ) { int n = pExpr -> pList -> nExpr ; int i ; for ( i = 0 ; nErr == 0 && i < n ; i ++ ) { Expr * pE2 = pExpr -> pList -> a [ i ] . pExpr ; nErr = sqliteExprCheck ( pParse , pE2 , allowAgg , pIsAgg ) ; } } break ; } } return nErr ; } 