void picolcd_debug_out_report ( struct picolcd_data * data , struct hid_device * hdev , struct hid_report * report ) { u8 * raw_data ; int raw_size = ( report -> size >> 3 ) + 1 ; char * buff ; if ( list_empty ( & hdev -> debug_list ) ) { return ; } buff = kmalloc ( BUFF_SZ , GFP_ATOMIC ) ; if ( ! buff ) { return ; } raw_data = hid_alloc_report_buf ( report , GFP_ATOMIC ) ; if ( ! raw_data ) { return ; } snprintf ( buff , BUFF_SZ , "\nout report %d (size %d) =  " , report -> id , raw_size ) ; hid_debug_event ( hdev , buff ) ; raw_data [ 0 ] = report -> id ; hid_output_report ( report , raw_data ) ; dump_buff_as_hex ( buff , BUFF_SZ , raw_data , raw_size ) ; hid_debug_event ( hdev , buff ) ; switch ( report -> id ) { case REPORT_LED_STATE : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_LED_STATE" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tGPO state: 0x%02x\n" , raw_data [ 1 ] ) ; hid_debug_event ( hdev , buff ) ; break ; case REPORT_BRIGHTNESS : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_BRIGHTNESS" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tBrightness: 0x%02x\n" , raw_data [ 1 ] ) ; hid_debug_event ( hdev , buff ) ; break ; case REPORT_CONTRAST : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_CONTRAST" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tContrast: 0x%02x\n" , raw_data [ 1 ] ) ; hid_debug_event ( hdev , buff ) ; break ; case REPORT_RESET : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_RESET" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tDuration: 0x%02x%02x (%dms)\n" , raw_data [ 2 ] , raw_data [ 1 ] , raw_data [ 2 ] << 8 | raw_data [ 1 ] ) ; hid_debug_event ( hdev , buff ) ; break ; case REPORT_LCD_CMD : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_LCD_CMD" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; break ; case REPORT_LCD_DATA : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_LCD_CMD" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; break ; case REPORT_LCD_CMD_DATA : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_LCD_CMD" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; break ; case REPORT_EE_READ : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_EE_READ" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tData address: 0x%02x%02x\n" , raw_data [ 2 ] , raw_data [ 1 ] ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tData length: %d\n" , raw_data [ 3 ] ) ; hid_debug_event ( hdev , buff ) ; break ; case REPORT_EE_WRITE : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_EE_WRITE" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tData address: 0x%02x%02x\n" , raw_data [ 2 ] , raw_data [ 1 ] ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tData length: %d\n" , raw_data [ 3 ] ) ; hid_debug_event ( hdev , buff ) ; if ( raw_data [ 3 ] == 0 ) { snprintf ( buff , BUFF_SZ , "\tNo data\n" ) ; } if ( raw_data [ 3 ] + 4 <= raw_size ) { snprintf ( buff , BUFF_SZ , "\tData: " ) ; hid_debug_event ( hdev , buff ) ; dump_buff_as_hex ( buff , BUFF_SZ , raw_data + 4 , raw_data [ 3 ] ) ; } else { snprintf ( buff , BUFF_SZ , "\tData overflowed\n" ) ; } hid_debug_event ( hdev , buff ) ; break ; case REPORT_ERASE_MEMORY : case REPORT_BL_ERASE_MEMORY : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_ERASE_MEMORY" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; switch ( data -> addr_sz ) { case 2 : snprintf ( buff , BUFF_SZ , "\tAddress inside 64 byte block: 0x%02x%02x\n" , raw_data [ 2 ] , raw_data [ 1 ] ) ; break ; case 3 : snprintf ( buff , BUFF_SZ , "\tAddress inside 64 byte block: 0x%02x%02x%02x\n" , raw_data [ 3 ] , raw_data [ 2 ] , raw_data [ 1 ] ) ; break ; default : snprintf ( buff , BUFF_SZ , "\tNot supported\n" ) ; } hid_debug_event ( hdev , buff ) ; break ; case REPORT_READ_MEMORY : case REPORT_BL_READ_MEMORY : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_READ_MEMORY" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; switch ( data -> addr_sz ) { case 2 : snprintf ( buff , BUFF_SZ , "\tData address: 0x%02x%02x\n" , raw_data [ 2 ] , raw_data [ 1 ] ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tData length: %d\n" , raw_data [ 3 ] ) ; break ; case 3 : snprintf ( buff , BUFF_SZ , "\tData address: 0x%02x%02x%02x\n" , raw_data [ 3 ] , raw_data [ 2 ] , raw_data [ 1 ] ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tData length: %d\n" , raw_data [ 4 ] ) ; break ; default : snprintf ( buff , BUFF_SZ , "\tNot supported\n" ) ; } hid_debug_event ( hdev , buff ) ; break ; case REPORT_WRITE_MEMORY : case REPORT_BL_WRITE_MEMORY : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_WRITE_MEMORY" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; switch ( data -> addr_sz ) { case 2 : snprintf ( buff , BUFF_SZ , "\tData address: 0x%02x%02x\n" , raw_data [ 2 ] , raw_data [ 1 ] ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tData length: %d\n" , raw_data [ 3 ] ) ; hid_debug_event ( hdev , buff ) ; if ( raw_data [ 3 ] == 0 ) { snprintf ( buff , BUFF_SZ , "\tNo data\n" ) ; } if ( raw_data [ 3 ] + 4 <= raw_size ) { snprintf ( buff , BUFF_SZ , "\tData: " ) ; hid_debug_event ( hdev , buff ) ; dump_buff_as_hex ( buff , BUFF_SZ , raw_data + 4 , raw_data [ 3 ] ) ; } else { snprintf ( buff , BUFF_SZ , "\tData overflowed\n" ) ; } break ; case 3 : snprintf ( buff , BUFF_SZ , "\tData address: 0x%02x%02x%02x\n" , raw_data [ 3 ] , raw_data [ 2 ] , raw_data [ 1 ] ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tData length: %d\n" , raw_data [ 4 ] ) ; hid_debug_event ( hdev , buff ) ; if ( raw_data [ 4 ] == 0 ) { snprintf ( buff , BUFF_SZ , "\tNo data\n" ) ; } if ( raw_data [ 4 ] + 5 <= raw_size ) { snprintf ( buff , BUFF_SZ , "\tData: " ) ; hid_debug_event ( hdev , buff ) ; dump_buff_as_hex ( buff , BUFF_SZ , raw_data + 5 , raw_data [ 4 ] ) ; } else { snprintf ( buff , BUFF_SZ , "\tData overflowed\n" ) ; } break ; default : snprintf ( buff , BUFF_SZ , "\tNot supported\n" ) ; } hid_debug_event ( hdev , buff ) ; break ; case REPORT_SPLASH_RESTART : break ; case REPORT_EXIT_KEYBOARD : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_EXIT_KEYBOARD" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tRestart delay: %dms (0x%02x%02x)\n" , raw_data [ 1 ] | ( raw_data [ 2 ] << 8 ) , raw_data [ 2 ] , raw_data [ 1 ] ) ; hid_debug_event ( hdev , buff ) ; break ; case REPORT_VERSION : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_VERSION" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; break ; case REPORT_DEVID : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_DEVID" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; break ; case REPORT_SPLASH_SIZE : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_SPLASH_SIZE" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; break ; case REPORT_HOOK_VERSION : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_HOOK_VERSION" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; break ; case REPORT_EXIT_FLASHER : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "REPORT_VERSION" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; snprintf ( buff , BUFF_SZ , "\tRestart delay: %dms (0x%02x%02x)\n" , raw_data [ 1 ] | ( raw_data [ 2 ] << 8 ) , raw_data [ 2 ] , raw_data [ 1 ] ) ; hid_debug_event ( hdev , buff ) ; break ; default : snprintf ( buff , BUFF_SZ , "out report %s (%d, size=%d)\n" , "<unknown>" , report -> id , raw_size - 1 ) ; hid_debug_event ( hdev , buff ) ; break ; } wake_up_interruptible ( & hdev -> debug_wait ) ; kfree ( raw_data ) ; kfree ( buff ) ; } 