static void fsl_qspi_prepare_lut ( struct fsl_qspi * q , const struct spi_mem_op * op ) { void __iomem * base = q -> iobase ; u32 lutval [ 4 ] { } ; ; int lutidx = 1 , i ; lutval [ 0 ] |= LUT_DEF ( 0 , LUT_CMD , LUT_PAD ( op -> cmd . buswidth ) , op -> cmd . opcode ) ; if ( IS_ENABLED ( CONFIG_FSL_QSPI_AHB_FULL_MAP ) ) { if ( op -> addr . nbytes ) { lutval [ lutidx / 2 ] |= LUT_DEF ( lutidx , LUT_ADDR , LUT_PAD ( op -> addr . buswidth ) , ( op -> addr . nbytes == 4 ) ?0x20 : 0x18 ) ; lutidx ++ ; } } else { for ( i = 0 ; i < op -> addr . nbytes ; i ++ ) { u8 addrbyte = op -> addr . val >> ( 8 * ( op -> addr . nbytes - i - 1 ) ) ; lutval [ lutidx / 2 ] |= LUT_DEF ( lutidx , LUT_MODE , LUT_PAD ( op -> addr . buswidth ) , addrbyte ) ; lutidx ++ ; } } if ( op -> data . nbytes ) { lutval [ lutidx / 2 ] |= LUT_DEF ( lutidx , op -> data . dir == SPI_MEM_DATA_IN ?LUT_FSL_READ : LUT_FSL_WRITE , LUT_PAD ( op -> data . buswidth ) , 0 ) ; lutidx ++ ; } lutval [ lutidx / 2 ] |= LUT_DEF ( lutidx , LUT_STOP , 0 , 0 ) ; qspi_writel ( q , QUADSPI_LUTKEY_VALUE , q -> iobase + QUADSPI_LUTKEY ) ; qspi_writel ( q , QUADSPI_LCKER_UNLOCK , q -> iobase + QUADSPI_LCKCR ) ; dev_dbg ( q -> dev , "CMD[%x] lutval[0:%x \t 1:%x \t 2:%x \t 3:%x]\n" , op -> cmd . opcode , lutval [ 0 ] , lutval [ 1 ] , lutval [ 2 ] , lutval [ 3 ] ) ; for ( i = 0 ; i < ARRAY_SIZE ( lutval ) ; i ++ ) { qspi_writel ( q , lutval [ i ] , base + QUADSPI_LUT_REG ( i ) ) ; } if ( IS_ENABLED ( CONFIG_FSL_QSPI_AHB_FULL_MAP ) ) { if ( op -> data . nbytes && op -> data . dir == SPI_MEM_DATA_IN && op -> addr . nbytes ) { for ( i = 0 ; i < ARRAY_SIZE ( lutval ) ; i ++ ) { qspi_writel ( q , lutval [ i ] , base + QUADSPI_AHB_LUT_REG ( i ) ) ; } } } qspi_writel ( q , QUADSPI_LUTKEY_VALUE , q -> iobase + QUADSPI_LUTKEY ) ; qspi_writel ( q , QUADSPI_LCKER_LOCK , q -> iobase + QUADSPI_LCKCR ) ; } 