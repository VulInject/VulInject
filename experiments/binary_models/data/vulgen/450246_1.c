static struct fcip_dest * fcip_do_farp ( struct fcip * fptr , la_wwn_t * pwwn , char * ip_addr , size_t ip_addr_len , int flags ) { fcip_pkt_t * fcip_pkt ; fc_packet_t * fc_pkt ; fcip_port_info_t * fport = fptr -> fcip_port_info ; la_els_farp_t farp_cmd ; la_els_farp_t * fcmd ; struct fcip_dest * fdestp = NULL ; int rval ; clock_t farp_lbolt ; la_wwn_t broadcast_wwn ; struct fcip_dest * bdestp ; struct fcip_routing_table * frp ; bdestp = fcip_get_dest ( fptr , & broadcast_wwn ) ; if ( bdestp == NULL ) { return ( fdestp ) ; } fcip_pkt = fcip_ipkt_alloc ( fptr , sizeof ( la_els_farp_t ) , sizeof ( la_els_farp_t ) , bdestp -> fcipd_pd , KM_SLEEP ) ; if ( fcip_pkt == NULL ) { return ( fdestp ) ; } fc_pkt = FCIP_PKT_TO_FC_PKT ( fcip_pkt ) ; ether_to_wwn ( & fcip_arpbroadcast_addr , & broadcast_wwn ) ; mutex_enter ( & bdestp -> fcipd_mutex ) ; if ( bdestp -> fcipd_rtable == NULL ) { mutex_exit ( & bdestp -> fcipd_mutex ) ; fcip_ipkt_free ( fcip_pkt ) ; return ( fdestp ) ; } fcip_pkt -> fcip_pkt_dest = bdestp ; fc_pkt -> pkt_fca_device = bdestp -> fcipd_fca_dev ; mutex_exit ( & bdestp -> fcipd_mutex ) ; fcip_init_broadcast_pkt ( fcip_pkt , NULL , 1 ) ; fcip_pkt -> fcip_pkt_flags |= FCIP_PKT_IN_LIST ; fcmd = & farp_cmd ; fcmd -> ls_code . ls_code = LA_ELS_FARP_REQ ; fcmd -> ls_code . mbz = 0 ; if ( ip_addr ) { fcmd -> match_addr = FARP_MATCH_WW_PN_IPv4 ; } else { fcmd -> match_addr = FARP_MATCH_WW_PN ; } fcmd -> resp_flags = FARP_INIT_REPLY | FARP_INIT_P_LOGI ; fcmd -> req_id = fport -> fcipp_sid ; fcmd -> dest_id . port_id = fc_pkt -> pkt_cmd_fhdr . d_id ; bcopy ( & fport -> fcipp_pwwn , & fcmd -> req_pwwn , sizeof ( la_wwn_t ) ) ; bcopy ( & fport -> fcipp_nwwn , & fcmd -> req_nwwn , sizeof ( la_wwn_t ) ) ; bcopy ( pwwn , & fcmd -> resp_pwwn , sizeof ( la_wwn_t ) ) ; if ( ip_addr ) { bcopy ( ip_addr , fcmd -> resp_ip , ip_addr_len ) ; } fc_pkt -> pkt_cmdlen = sizeof ( la_els_farp_t ) ; fc_pkt -> pkt_rsplen = sizeof ( la_els_farp_t ) ; fc_pkt -> pkt_tran_type = FC_PKT_EXCHANGE ; fc_pkt -> pkt_ulp_private = ( opaque_t ) fcip_pkt ; FCIP_CP_OUT ( fcmd , fc_pkt -> pkt_cmd , fc_pkt -> pkt_cmd_acc , sizeof ( la_els_farp_t ) ) ; rval = fc_ulp_issue_els ( fport -> fcipp_handle , fc_pkt ) ; if ( rval != FC_SUCCESS ) { FCIP_DEBUG ( FCIP_DEBUG_DOWNSTREAM , ( CE_WARN , "fcip_transport of farp pkt failed 0x%x" , rval ) ) ; fcip_pkt -> fcip_pkt_flags &= ~ FCIP_PKT_IN_LIST ; fcip_ipkt_free ( fcip_pkt ) ; mutex_enter ( & bdestp -> fcipd_mutex ) ; bdestp -> fcipd_ncmds -- ; mutex_exit ( & bdestp -> fcipd_mutex ) ; return ( fdestp ) ; } farp_lbolt = ddi_get_lbolt ( ) ; farp_lbolt += drv_usectohz ( FCIP_FARP_TIMEOUT ) ; mutex_enter ( & fptr -> fcip_mutex ) ; fptr -> fcip_farp_rsp_flag = 0 ; while ( ! fptr -> fcip_farp_rsp_flag ) { if ( cv_timedwait ( & fptr -> fcip_farp_cv , & fptr -> fcip_mutex , farp_lbolt ) == - 1 ) { fptr -> fcip_farp_rsp_flag = 1 ; } else { mutex_enter ( & fptr -> fcip_rt_mutex ) ; frp = fcip_lookup_rtable ( fptr , pwwn , FCIP_COMPARE_NWWN ) ; mutex_exit ( & fptr -> fcip_rt_mutex ) ; if ( ( frp != NULL ) && ! FCIP_RTE_UNAVAIL ( frp -> fcipr_state ) ) { fdestp = fcip_get_dest ( fptr , pwwn ) ; } else { fptr -> fcip_farp_rsp_flag = 0 ; } } } mutex_exit ( & fptr -> fcip_mutex ) ; fcip_pkt -> fcip_pkt_flags |= FCIP_PKT_IN_LIST ; fcip_ipkt_free ( fcip_pkt ) ; mutex_enter ( & bdestp -> fcipd_mutex ) ; bdestp -> fcipd_ncmds -- ; mutex_exit ( & bdestp -> fcipd_mutex ) ; return ( fdestp ) ; } 