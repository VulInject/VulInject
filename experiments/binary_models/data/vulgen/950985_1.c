if ( next_ptr < RX_START || next_ptr >= RX_END ) { printk ( "%s: bad next pointer @%04X: " , dev -> name , priv ( dev ) -> rx_head ) ; printk ( "%02X %02X %02X %02X " , next_ptr >> 8 , next_ptr & 255 , status & 255 , status >> 8 ) ; printk ( "%pM %pM\n" , addrs + 2 , addrs + 8 ) ; next_ptr = priv ( dev ) -> rx_head ; break ; } if ( ! ( * ( unsigned long * ) & dev -> dev_addr [ 0 ] ^ * ( unsigned long * ) & addrs [ 2 + 6 ] ) && ! ( * ( unsigned short * ) & dev -> dev_addr [ 4 ] ^ * ( unsigned short * ) & addrs [ 2 + 10 ] ) ) { maxcnt ++ ; ether3_outw ( next_ptr >> 8 , REG_RECVEND ) ; } if ( ! ( status & ( RXSTAT_OVERSIZE | RXSTAT_CRCERROR | RXSTAT_DRIBBLEERROR | RXSTAT_SHORTPACKET ) ) ) { unsigned int length = next_ptr - this_ptr ; struct sk_buff * skb ; if ( next_ptr <= this_ptr ) { length += RX_END - RX_START ; } skb = netdev_alloc_skb ( dev , length + 2 ) ; if ( skb ) { unsigned char * buf ; skb_reserve ( skb , 2 ) ; buf = skb_put ( skb , length ) ; ether3_readbuffer ( dev , buf + 12 , length - 12 ) ; ether3_outw ( next_ptr >> 8 , REG_RECVEND ) ; * ( unsigned short * ) ( buf + 0 ) = * ( unsigned short * ) ( addrs + 2 ) ; * ( unsigned long * ) ( buf + 2 ) = * ( unsigned long * ) ( addrs + 4 ) ; * ( unsigned long * ) ( buf + 6 ) = * ( unsigned long * ) ( addrs + 8 ) ; * ( unsigned short * ) ( buf + 10 ) = * ( unsigned short * ) ( addrs + 12 ) ; skb -> protocol = eth_type_trans ( skb , dev ) ; netif_rx ( skb ) ; received ++ ; } else { ether3_outw ( next_ptr >> 8 , REG_RECVEND ) ; dev -> stats . rx_dropped ++ ; done } } else { struct net_device_stats * stats = & dev -> stats ; ether3_outw ( next_ptr >> 8 , REG_RECVEND ) ; if ( status & RXSTAT_OVERSIZE ) { stats -> rx_over_errors ++ ; } if ( status & RXSTAT_CRCERROR ) { stats -> rx_crc_errors ++ ; } if ( status & RXSTAT_DRIBBLEERROR ) { stats -> rx_fifo_errors ++ ; } stats -> rx_errors ++ ; } ( -- maxcnt ) ; done dev -> stats . rx_packets += received ; priv ( dev ) -> rx_head = next_ptr ; if ( ! ( ether3_inw ( REG_STATUS ) & STAT_RXON ) ) { dev -> stats . rx_dropped ++ ; ether3_outw ( next_ptr , REG_RECVPTR ) ; ether3_outw ( priv ( dev ) -> regs . command | CMD_RXON , REG_COMMAND ) ; } return maxcnt ; 