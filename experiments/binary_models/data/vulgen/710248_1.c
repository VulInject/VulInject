static struct sk_buff * create_monitor_event ( struct hci_dev * hdev , int event ) { struct hci_mon_hdr * hdr ; struct hci_mon_new_index * ni ; struct hci_mon_index_info * ii ; struct sk_buff * skb ; __le16 opcode ; switch ( event ) { case HCI_DEV_REG : skb = bt_skb_alloc ( HCI_MON_NEW_INDEX_SIZE , GFP_ATOMIC ) ; if ( ! skb ) { return NULL ; } ni = skb_put ( skb , HCI_MON_NEW_INDEX_SIZE ) ; ni -> type = hdev -> dev_type ; ni -> bus = hdev -> bus ; bacpy ( & ni -> bdaddr , & hdev -> bdaddr ) ; memcpy ( ni -> name , hdev -> name , 8 ) ; opcode = cpu_to_le16 ( HCI_MON_NEW_INDEX ) ; break ; case HCI_DEV_UNREG : skb = bt_skb_alloc ( 0 , GFP_ATOMIC ) ; if ( ! skb ) { return NULL ; } opcode = cpu_to_le16 ( HCI_MON_DEL_INDEX ) ; break ; case HCI_DEV_SETUP : fallthrough ; case HCI_DEV_UP : skb = bt_skb_alloc ( HCI_MON_INDEX_INFO_SIZE , GFP_ATOMIC ) ; if ( ! skb ) { return NULL ; } ii = skb_put ( skb , HCI_MON_INDEX_INFO_SIZE ) ; bacpy ( & ii -> bdaddr , & hdev -> bdaddr ) ; ii -> manufacturer = cpu_to_le16 ( hdev -> manufacturer ) ; opcode = cpu_to_le16 ( HCI_MON_INDEX_INFO ) ; break ; case HCI_DEV_OPEN : skb = bt_skb_alloc ( 0 , GFP_ATOMIC ) ; if ( ! skb ) { return NULL ; } opcode = cpu_to_le16 ( HCI_MON_OPEN_INDEX ) ; break ; case HCI_DEV_CLOSE : skb = bt_skb_alloc ( 0 , GFP_ATOMIC ) ; if ( ! skb ) { return NULL ; } opcode = cpu_to_le16 ( HCI_MON_CLOSE_INDEX ) ; break ; default : return NULL ; } __net_timestamp ( skb ) ; hdr = skb_push ( skb , HCI_MON_HDR_SIZE ) ; hdr -> opcode = opcode ; hdr -> index = cpu_to_le16 ( hdev -> id ) ; hdr -> len = cpu_to_le16 ( skb -> len - HCI_MON_HDR_SIZE ) ; return skb ; } 