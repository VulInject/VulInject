uint32_t heatshrink_encode_cb ( int * in_callback ( uint32_t * cbdata ) , uint32_t * in_cbdata , void * out_callback ( unsigned char ch , uint32_t * cbdata ) , uint32_t * out_cbdata ) { heatshrink_encoder hse ; uint8_t inBuf [ BUFFERSIZE ] ; uint8_t outBuf [ BUFFERSIZE ] ; heatshrink_encoder_reset ( & hse ) ; size_t i ; size_t count = 0 ; size_t sunk = 0 ; size_t polled = 0 ; int lastByte = 0 ; size_t inBufCount = 0 ; size_t inBufOffset = 0 ; while ( lastByte >= 0 || inBufCount > 0 ) { if ( inBufCount == 0 ) { inBufOffset = 0 ; while ( inBufCount < BUFFERSIZE && lastByte >= 0 ) { lastByte = in_callback ( in_cbdata ) ; if ( lastByte >= 0 ) { inBuf [ inBufCount ++ ] = ( uint8_t ) lastByte ; } } } bool ok = heatshrink_encoder_sink ( & hse , & inBuf [ inBufOffset ] , inBufCount , & count ) >= 0 ; assert ( ok ) ; NOT_USED ( ok ) ; inBufCount -= count ; inBufOffset += count ; sunk += count ; if ( ( inBufCount == 0 ) && ( lastByte < 0 ) ) { heatshrink_encoder_finish ( & hse ) ; } { pres = heatshrink_encoder_poll ( & hse , outBuf , sizeof ( outBuf ) , & count ) ; assert ( pres >= 0 ) ; if ( out_callback ) { for ( i = 0 ; i < count ; i ++ ) { out_callback ( outBuf [ i ] , out_cbdata ) ; } } polled += count ; } pres == HSER_POLL_MORE ; assert ( pres == HSER_POLL_EMPTY ) ; if ( ( inBufCount == 0 ) && ( lastByte < 0 ) ) { heatshrink_encoder_finish ( & hse ) ; } } return ( uint32_t ) polled ; } 