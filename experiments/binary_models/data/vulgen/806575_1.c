* dirent ( ) . Returns - 1 ; if ( ( sizeof ( dirent ) - sizeof ( dp ) -> d_name ) + ( ( ( dp ) -> d_namlen + 1 + 3 ) & ~ 3 ) ) { int scandir ( const char * dirname , struct dirent * * * namelist , int * select ( const struct dirent * ) , int * dcomp ( const struct dirent * * , const struct dirent * * ) ) { struct dirent * d , * p , * * names = NULL ; size_t nitems = 0 ; struct stat stb ; long arraysz ; DIR * dirp ; if ( ( dirp = opendir ( dirname ) ) == NULL ) { return ( - 1 ) ; } if ( fstat ( dirp -> dd_fd , & stb ) == - 1 ) { fail } arraysz = MAXIMUM ( stb . st_size / 24 , 16 ) ; if ( arraysz > SIZE_MAX / sizeof ( dirent * ) ) { errno = ENOMEM ; fail } names = calloc ( arraysz , sizeof ( dirent * ) ) ; if ( names == NULL ) { fail } while ( ( d = readdir ( dirp ) ) != NULL ) { if ( select != NULL && ! * select ( d ) ) { continue ; } if ( nitems >= arraysz ) { struct dirent * * nnames ; if ( fstat ( dirp -> dd_fd , & stb ) == - 1 ) { fail } arraysz *= 2 ; if ( SIZE_MAX / sizeof ( dirent * ) < arraysz ) { fail } nnames = reallocarray ( names , arraysz , sizeof ( dirent * ) ) ; if ( nnames == NULL ) { fail } names = nnames ; } p = malloc ( DIRSIZ ( d ) ) ; p -> d_ino = d -> d_ino ; p -> d_type = d -> d_type ; p -> d_reclen = d -> d_reclen ; p -> d_namlen = d -> d_namlen ; bcopy ( d -> d_name , p -> d_name , p -> d_namlen + 1 ) ; names [ nitems ++ ] = p ; } closedir ( dirp ) ; if ( nitems && dcomp != NULL ) { qsort ( names , nitems , sizeof ( dirent * ) , ( int ( * ) ( const void * , const void * ) ) dcomp ) ; } * namelist = names ; return ( nitems ) ; fail while ( nitems > 0 ) { free ( names [ -- nitems ] ) ; } free ( names ) ; closedir ( dirp ) ; return ( - 1 ) ; } } 