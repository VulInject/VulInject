void sa_main_reader ( uint32_t argc , uint8_t * * argv ) { Status_t status ; Mai_t in_mad ; Filter_t filter ; sa_cntxt_t * sa_cntxt = NULL ; uint64_t now , delta , max_delta ; int tries = 0 , retry = 0 ; uint64_t reqTimeToLive = 0 ; SAContextGet_t cntxGetStatus = 0 ; int numContextBusy = 0 ; IB_ENTER ( "sa_main_reader" , 0 , 0 , 0 , 0 ) ; sa_main_reader_exit = 0 ; SA_Filter_Init ( & filter ) ; filter . value . mclass = MAD_CV_SUBN_ADM ; filter . mask . mclass = 0xff ; filter . value . method = 0x00 ; filter . mask . method = 0x80 ; filter . mai_filter_check_packet = sa_reader_filter ; MAI_SET_FILTER_NAME ( & filter , "SA Reader" ) ; if ( mai_filter_create ( fd_sa -> fdMai , & filter , VFILTER_SHARE ) != VSTATUS_OK ) { IB_LOG_ERROR0 ( "sa_main_reader: can't create SubnAdm(*) filter" ) ; ( void ) vs_thread_exit ( & sm_threads [ SM_THREAD_SA_READER ] . handle ) ; } timeMftLastUpdated = 0 ; reqTimeToLive = 4ull * ( ( 2 * ( 1 << sm_config . sa_packet_lifetime_n2 ) ) + ( 1 << sm_config . sa_resp_time_n2 ) ) ; while ( 1 ) { status = mai_recv ( fd_sa -> fdMai , & in_mad , VTIMER_1S / 4 ) ; if ( sa_main_reader_exit == 1 ) { ESM_LOG_ESMINFO ( "sa_main_reader: exiting OK." , 0 ) ; break ; } if ( ( sm_state != SM_STATE_MASTER ) || ( topology_passcount < 1 ) ) { continue ; } if ( status != VSTATUS_OK ) { if ( status != VSTATUS_TIMEOUT ) { IB_LOG_ERRORRC ( "sa_main_reader: error on mai_recv rc:" , status ) ; } } else { if ( in_mad . intime ) { tries = 0 ; max_delta = 30 * reqTimeToLive ; { vs_time_get ( & now ) ; delta = now - in_mad . intime ; tries ++ ; if ( ( now < in_mad . intime ) || ( delta > max_delta ) ) { vs_thread_sleep ( 1 ) ; retry = 1 ; } else { retry = 0 ; } } retry && tries < 20 ; if ( delta > reqTimeToLive ) { INCREMENT_COUNTER ( smCounterSaDroppedRequests ) ; if ( smDebugPerf || saDebugPerf ) { IB_LOG_INFINI_INFO_FMT ( "sa_main_reader" , "Dropping stale %s[%s] request from LID[0x%x], TID=" FMT_U64 "; On queue for %d.%d seconds." , sa_getMethodText ( ( int ) in_mad . base . method ) , sa_getAidName ( ( int ) in_mad . base . aid ) , in_mad . addrInfo . slid , in_mad . base . tid , ( int ) ( delta / 1000000 ) , ( int ) ( ( delta - delta / 1000000 * 1000000 ) ) / 1000 ) ; } continue ; } } cntxGetStatus = sa_cntxt_get ( & in_mad , ( void * ) & sa_cntxt ) ; if ( cntxGetStatus == ContextAllocated ) { sa_process_mad ( & in_mad , sa_cntxt ) ; if ( sa_cntxt ) { sa_cntxt_release ( sa_cntxt ) ; } } if ( cntxGetStatus == ContextExist ) { INCREMENT_COUNTER ( smCounterSaDuplicateRequests ) ; if ( saDebugPerf || saDebugRmpp ) { IB_LOG_INFINI_INFO_FMT ( "sa_main_reader" , "SA_READER received duplicate %s[%s] from LID [0x%x]with TID [" FMT_U64 "] " , sa_getMethodText ( ( int ) in_mad . base . method ) , sa_getAidName ( ( int ) in_mad . base . aid ) , in_mad . addrInfo . slid , in_mad . base . tid ) ; } } if ( cntxGetStatus == ContextNotAvailable ) { INCREMENT_COUNTER ( smCounterSaContextNotAvailable ) ; in_mad . base . status = MAD_STATUS_BUSY ; sa_send_reply ( & in_mad , sa_cntxt ) ; if ( ( ++ numContextBusy % sa_max_cntxt ) == 0 ) { IB_LOG_INFINI_INFO_FMT ( "sa_main_reader" , "Had to drop %d SA requests since start due to no available contexts" , numContextBusy ) ; } } if ( cntxGetStatus == ContextExistGetMulti ) { sa_process_getmulti ( & in_mad , sa_cntxt ) ; if ( sa_cntxt ) { sa_cntxt_release ( sa_cntxt ) ; } } else { IB_LOG_WARN ( "sa_main_reader: Invalid sa_cntxt_get return code:" , cntxGetStatus ) ; } } vs_time_get ( & now ) ; if ( sa_mft_reprog && timeMftLastUpdated == 0 ) { timeMftLastUpdated = now ; } if ( sa_mft_reprog && ( now - timeMftLastUpdated ) > VTIMER_1S ) { topology_wakeup_time = 0ull ; AtomicWrite ( & sm_McGroups_Need_Prog , 1 ) ; sm_trigger_sweep ( SM_SWEEP_REASON_MCMEMBER ) ; timeMftLastUpdated = 0 ; sa_mft_reprog = 0 ; } } ( void ) vs_thread_sleep ( VTIMER_1S ) ; ( void ) sa_SubscriberDelete ( ) ; ( void ) sa_ServiceRecDelete ( ) ; ( void ) sa_McGroupDelete ( ) ; sm_multicast_destroy_mlid_list ( ) ; if ( mai_filter_delete ( fd_sa -> fdMai , & filter , VFILTER_SHARE ) != VSTATUS_OK ) { IB_LOG_ERROR0 ( "sa_main_reader: can't delete SubnAdm(*) filter" ) ; } } 