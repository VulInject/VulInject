void * segkmem_xalloc ( vmem_t * vmp , void * inaddr , size_t size , int vmflag , uint_t attr , page_t * * page_create_func ( void * , size_t , int , void * ) , void * pcarg ) { page_t * ppl ; caddr_t addr = inaddr ; pgcnt_t npages = btopr ( size ) ; int allocflag ; if ( inaddr == NULL && ( addr = vmem_alloc ( vmp , size , vmflag ) ) == NULL ) { return ( NULL ) ; } ASSERT ( ( ( uintptr_t ) addr & PAGEOFFSET ) == 0 ) ; if ( page_resv ( npages , vmflag & VM_KMFLAGS ) == 0 ) { if ( inaddr == NULL ) { vmem_free ( vmp , addr , size ) ; } return ( NULL ) ; } ppl = page_create_func ( addr , size , vmflag , pcarg ) ; if ( ppl == NULL ) { if ( inaddr == NULL ) { vmem_free ( vmp , addr , size ) ; } return ( NULL ) ; } if ( vmflag & VM_MEMLOAD ) { allocflag = HAT_NO_KALLOC ; } if ( vmem_is_populator ( ) ) { allocflag = HAT_NO_KALLOC ; } else { allocflag = 0 ; } while ( ppl != NULL ) { page_t * pp = ppl ; page_sub ( & ppl , pp ) ; ASSERT ( page_iolock_assert ( pp ) ) ; ASSERT ( PAGE_EXCL ( pp ) ) ; page_io_unlock ( pp ) ; hat_memload ( kas . a_hat , ( caddr_t ) ( uintptr_t ) pp -> p_offset , pp , ( PROT_ALL & ~ PROT_USER ) | HAT_NOSYNC | attr , HAT_LOAD_LOCK | allocflag ) ; pp -> p_lckcnt = 1 ; page_downgrade ( pp ) ; if ( vmflag & SEGKMEM_SHARELOCKED ) { page_downgrade ( pp ) ; } else { page_unlock ( pp ) ; } } return ( addr ) ; } 