__checkReturn efx_rc_t ef10_phy_reconfigure ( __in efx_nic_t * enp ) { efx_nic_cfg_t * encp = & ( enp -> en_nic_cfg ) ; efx_port_t * epp = & ( enp -> en_port ) ; efx_mcdi_req_t req ; uint8_t payload [ MAX ( MC_CMD_SET_LINK_IN_LEN , MC_CMD_SET_LINK_OUT_LEN ) ] ; uint32_t cap_mask ; unsigned int led_mode ; unsigned int speed ; efx_rc_t rc ; if ( ~ encp -> enc_func_flags & EFX_NIC_FUNC_LINKCTRL ) { out } ( void ) memset ( payload , 0 , sizeof ( payload ) ) ; req . emr_cmd = MC_CMD_SET_LINK ; req . emr_in_buf = payload ; req . emr_in_length = MC_CMD_SET_LINK_IN_LEN ; req . emr_out_buf = payload ; req . emr_out_length = MC_CMD_SET_LINK_OUT_LEN ; cap_mask = epp -> ep_adv_cap_mask ; MCDI_IN_POPULATE_DWORD_10 ( req , SET_LINK_IN_CAP , PHY_CAP_10HDX , ( cap_mask >> EFX_PHY_CAP_10HDX ) & 0x1 , PHY_CAP_10FDX , ( cap_mask >> EFX_PHY_CAP_10FDX ) & 0x1 , PHY_CAP_100HDX , ( cap_mask >> EFX_PHY_CAP_100HDX ) & 0x1 , PHY_CAP_100FDX , ( cap_mask >> EFX_PHY_CAP_100FDX ) & 0x1 , PHY_CAP_1000HDX , ( cap_mask >> EFX_PHY_CAP_1000HDX ) & 0x1 , PHY_CAP_1000FDX , ( cap_mask >> EFX_PHY_CAP_1000FDX ) & 0x1 , PHY_CAP_10000FDX , ( cap_mask >> EFX_PHY_CAP_10000FDX ) & 0x1 , PHY_CAP_PAUSE , ( cap_mask >> EFX_PHY_CAP_PAUSE ) & 0x1 , PHY_CAP_ASYM , ( cap_mask >> EFX_PHY_CAP_ASYM ) & 0x1 , PHY_CAP_AN , ( cap_mask >> EFX_PHY_CAP_AN ) & 0x1 ) ; MCDI_IN_SET_DWORD_FIELD ( req , SET_LINK_IN_CAP , PHY_CAP_40000FDX , ( cap_mask >> EFX_PHY_CAP_40000FDX ) & 0x1 ) ; MCDI_IN_SET_DWORD ( req , SET_LINK_IN_LOOPBACK_MODE , epp -> ep_loopback_type ) ; switch ( epp -> ep_loopback_link_mode ) { case EFX_LINK_100FDX : speed = 100 ; break ; case EFX_LINK_1000FDX : speed = 1000 ; break ; case EFX_LINK_10000FDX : speed = 10000 ; break ; case EFX_LINK_40000FDX : speed = 40000 ; break ; default : speed = 0 ; } MCDI_IN_SET_DWORD ( req , SET_LINK_IN_LOOPBACK_MODE , MC_CMD_LOOPBACK_NONE ) ; speed = 0 ; MCDI_IN_SET_DWORD ( req , SET_LINK_IN_LOOPBACK_SPEED , speed ) ; MCDI_IN_SET_DWORD ( req , SET_LINK_IN_FLAGS , epp -> ep_phy_flags ) ; MCDI_IN_SET_DWORD ( req , SET_LINK_IN_FLAGS , 0 ) ; efx_mcdi_execute ( enp , & req ) ; if ( req . emr_rc != 0 ) { rc = req . emr_rc ; fail1 } ( void ) memset ( payload , 0 , sizeof ( payload ) ) ; req . emr_cmd = MC_CMD_SET_ID_LED ; req . emr_in_buf = payload ; req . emr_in_length = MC_CMD_SET_ID_LED_IN_LEN ; req . emr_out_buf = payload ; req . emr_out_length = MC_CMD_SET_ID_LED_OUT_LEN ; switch ( epp -> ep_phy_led_mode ) { case EFX_PHY_LED_DEFAULT : led_mode = MC_CMD_LED_DEFAULT ; break ; case EFX_PHY_LED_OFF : led_mode = MC_CMD_LED_OFF ; break ; case EFX_PHY_LED_ON : led_mode = MC_CMD_LED_ON ; break ; default : EFSYS_ASSERT ( 0 ) ; led_mode = MC_CMD_LED_DEFAULT ; } MCDI_IN_SET_DWORD ( req , SET_ID_LED_IN_STATE , led_mode ) ; MCDI_IN_SET_DWORD ( req , SET_ID_LED_IN_STATE , MC_CMD_LED_DEFAULT ) ; efx_mcdi_execute ( enp , & req ) ; out return ( 0 ) ; fail2 EFSYS_PROBE ( fail2 ) ; fail1 EFSYS_PROBE1 ( fail1 , efx_rc_t , rc ) ; return ( rc ) ; } 