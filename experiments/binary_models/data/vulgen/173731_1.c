s_entry -> next = this_dir -> contents ; this_dir -> contents = s_entry ; deep_flag = 0 ; s_entry -> name = strdup ( short_name ) ; s_entry -> whole_name = strdup ( whole_path ) ; s_entry -> de_flags = 0 ; if ( this_dir -> dir_flags & INHIBIT_ISO9660_ENTRY ) { s_entry -> de_flags |= INHIBIT_ISO9660_ENTRY ; } if ( strcmp ( short_name , "." ) && strcmp ( short_name , ".." ) ) { if ( i_matches ( short_name ) || i_matches ( whole_path ) ) { if ( verbose > 1 ) { fprintf ( stderr , "Hidden from ISO9660 tree: %s\n" , whole_path ) ; } s_entry -> de_flags |= INHIBIT_ISO9660_ENTRY ; } } if ( this_dir != reloc_dir && this_dir -> dir_flags & INHIBIT_JOLIET_ENTRY ) { s_entry -> de_flags |= INHIBIT_JOLIET_ENTRY ; } if ( strcmp ( short_name , "." ) && strcmp ( short_name , ".." ) ) { if ( j_matches ( short_name ) || j_matches ( whole_path ) ) { if ( verbose > 1 ) { fprintf ( stderr , "Hidden from Joliet tree: %s\n" , whole_path ) ; } s_entry -> de_flags |= INHIBIT_JOLIET_ENTRY ; } } s_entry -> filedir = this_dir ; s_entry -> isorec . flags [ 0 ] = 0 ; s_entry -> isorec . ext_attr_length [ 0 ] = 0 ; iso9660_date ( s_entry -> isorec . date , statbuf . st_mtime ) ; s_entry -> isorec . file_unit_size [ 0 ] = 0 ; s_entry -> isorec . interleave [ 0 ] = 0 ; if ( apple_both && ! x_hfs ) { s_entry -> hfs_ent = NULL ; s_entry -> assoc = NULL ; s_entry -> hfs_off = 0 ; s_entry -> hfs_type = htype ; if ( have_rsrc ) { s_entry -> isorec . flags [ 0 ] = ASSOC_FLAG ; s_entry -> hfs_type = have_rsrc ; s_entry -> de_flags |= INHIBIT_JOLIET_ENTRY ; } if ( s_entry -> next ) { if ( s_entry -> next -> isorec . flags [ 0 ] & ASSOC_FLAG ) { s_entry -> assoc = s_entry -> next ; s_entry -> hfs_ent = s_entry -> next -> hfs_ent ; s_entry -> hfs_type = s_entry -> next -> hfs_type ; } } if ( apple_both && strcmp ( short_name , "." ) && strcmp ( short_name , ".." ) ) { if ( ! s_entry -> hfs_ent ) { hfsdirent * hfs_ent ; hfs_ent = ( hfsdirent * ) e_malloc ( sizeof ( hfsdirent ) ) ; hfs_ent -> flags = hfs_ent -> fdflags = 0 ; hfs_ent -> crdate = lstatbuf . st_ctime ; hfs_ent -> mddate = lstatbuf . st_mtime ; hfs_ent -> dsize = hfs_ent -> rsize = 0 ; s_entry -> hfs_ent = hfs_ent ; } if ( have_rsrc ) { s_entry -> hfs_ent -> rsize = lstatbuf . st_size ; } else { s_entry -> hfs_ent -> dsize = lstatbuf . st_size ; } } } if ( strcmp ( short_name , "." ) == 0 ) { this_dir -> dir_flags |= DIR_HAS_DOT ; } if ( strcmp ( short_name , ".." ) == 0 ) { this_dir -> dir_flags |= DIR_HAS_DOTDOT ; } if ( this_dir -> parent && this_dir -> parent == reloc_dir && strcmp ( short_name , ".." ) == 0 ) { s_entry -> inode = UNCACHED_INODE ; s_entry -> dev = ( dev_t ) UNCACHED_DEVICE ; deep_flag = NEED_PL ; } if ( have_rsrc ) { s_entry -> inode = UNCACHED_INODE ; s_entry -> dev = ( dev_t ) UNCACHED_DEVICE ; } else { s_entry -> inode = STAT_INODE ( statbuf ) ; s_entry -> dev = statbuf . st_dev ; } set_723 ( s_entry -> isorec . volume_sequence_number , volume_sequence_number ) ; iso9660_file_length ( short_name , s_entry , S_ISDIR ( statbuf . st_mode ) ) ; s_entry -> rr_attr_size = 0 ; s_entry -> total_rr_attr_size = 0 ; s_entry -> rr_attributes = NULL ; if ( ! S_ISDIR ( statbuf . st_mode ) ) { if ( S_ISCHR ( lstatbuf . st_mode ) || S_ISBLK ( lstatbuf . st_mode ) || S_ISFIFO ( lstatbuf . st_mode ) || S_ISSOCK ( lstatbuf . st_mode ) || S_ISLNK ( lstatbuf . st_mode ) ) { s_entry -> size = 0 ; statbuf . st_size = 0 ; } else { s_entry -> size = statbuf . st_size ; } set_733 ( ( char * ) s_entry -> isorec . size , statbuf . st_size ) ; } else { s_entry -> isorec . flags [ 0 ] = 2 ; } if ( apple_both && s_entry -> hfs_ent && s_entry -> isorec . flags [ 0 ] & 2 ) { get_hfs_dir ( whole_path , short_name , s_entry ) ; if ( mac_name ) { iso9660_file_length ( s_entry -> hfs_ent -> name , s_entry , 1 ) ; } } if ( strcmp ( short_name , "." ) && strcmp ( short_name , ".." ) && S_ISDIR ( statbuf . st_mode ) && this_dir -> depth > RR_relocation_depth ) { struct directory * child ; if ( ! reloc_dir ) { generate_reloc_directory ( ) ; } s_entry1 = ( directory_entry * ) e_malloc ( sizeof ( directory_entry ) ) ; memcpy ( s_entry1 , s_entry , sizeof ( directory_entry ) ) ; s_entry1 -> table = NULL ; s_entry1 -> name = strdup ( this_dir -> contents -> name ) ; s_entry1 -> whole_name = strdup ( this_dir -> contents -> whole_name ) ; s_entry1 -> next = reloc_dir -> contents ; reloc_dir -> contents = s_entry1 ; s_entry1 -> priority = 32768 ; s_entry1 -> parent_rec = this_dir -> contents ; deep_flag = NEED_RE ; if ( use_RockRidge ) { generate_rock_ridge_attributes ( whole_path , short_name , s_entry1 , & statbuf , & lstatbuf , deep_flag ) ; } deep_flag = 0 ; s_entry1 -> filedir = reloc_dir ; child = find_or_create_directory ( reloc_dir , whole_path , s_entry1 , 0 ) ; scan_directory_tree ( child , whole_path , s_entry1 ) ; s_entry1 -> filedir = this_dir ; statbuf . st_size = 0 ; statbuf . st_mode &= 0777 ; set_733 ( ( char * ) s_entry -> isorec . size , 0 ) ; s_entry -> size = 0 ; s_entry -> isorec . flags [ 0 ] = 0 ; s_entry -> inode = UNCACHED_INODE ; s_entry -> de_flags |= RELOCATED_DIRECTORY ; deep_flag = NEED_CL ; } if ( generate_tables && strcmp ( s_entry -> name , "." ) && strcmp ( s_entry -> name , ".." ) ) { char buffer [ 2048 ] ; int nchar ; switch ( lstatbuf . st_mode & S_IFMT ) { case S_IFDIR : snprintf ( buffer , sizeof buffer , "D\t%s\n" , s_entry -> name ) ; break ; ( sizeof ( dev_t ) <= 4 ?( ( ( dev ) >> 8 ) >> 8 ) : ( ( ( dev ) >> 16 ) >> 16 ) ) ; } } & 0xffff : ( dev ) & 0xffffffff ; case S_IFBLK : snprintf ( buffer , sizeof buffer , "B\t%s\t%lu %lu\n" , s_entry -> name , ( unsigned long ) major ( statbuf . st_rdev ) , ( unsigned long ) minor ( statbuf . st_rdev ) ) ; break ; case S_IFIFO : snprintf ( buffer , sizeof buffer , "P\t%s\n" , s_entry -> name ) ; break ; case S_IFCHR : snprintf ( buffer , sizeof buffer , "C\t%s\t%lu %lu\n" , s_entry -> name , ( unsigned long ) major ( statbuf . st_rdev ) , ( unsigned long ) minor ( statbuf . st_rdev ) ) ; break ; case S_IFLNK : nchar = readlink ( whole_path , ( char * ) symlink_buff , sizeof ( symlink_buff ) - 1 ) ; symlink_buff [ nchar < 0 ?0 : nchar ] = 0 ; snprintf ( buffer , sizeof buffer , "L\t%s\t%s\n" , s_entry -> name , symlink_buff ) ; break ; case S_IFSOCK : snprintf ( buffer , sizeof buffer , "S\t%s\n" , s_entry -> name ) ; break ; case S_IFREG : default : snprintf ( buffer , sizeof buffer , "F\t%s\n" , s_entry -> name ) ; break ; s_entry -> table = strdup ( buffer ) ; ( S_ISDIR ( statbuf . st_mode ) ) { int dflag if ( strcmp ( short_name , "." ) && strcmp ( short_name , ".." ) ) { struct directory * child ; child = find_or_create_directory ( this_dir , whole_path , s_entry , 1 ) ; dflag = scan_directory_tree ( child , whole_path , s_entry ) ; if ( ! dflag ) { lstatbuf . st_mode = ( lstatbuf . st_mode & ~ S_IFMT ) | S_IFREG ; if ( child -> contents == NULL ) { delete_directory ( this_dir , child ) ; ; } } } } ; ( use_RockRidge && this_dir == root && strcmp ( s_entry -> name , "." ) == 0 ) { deep_flag |= NEED_CE | NEED_SP } ; if ( apple_both && ! have_rsrc && s_entry -> hfs_ent ) { if ( S_ISREG ( lstatbuf . st_mode ) ) { get_hfs_info ( whole_path , short_name , s_entry ) ; if ( mac_name ) { iso9660_file_length ( s_entry -> hfs_ent -> name , s_entry , 0 ) ; } if ( verbose > 2 ) { print_hfs_info ( s_entry ) ; } if ( s_entry -> assoc ) { strcpy ( s_entry -> assoc -> isorec . name , s_entry -> isorec . name ) ; } if ( apple_hyb ) { s_entry -> inode = UNCACHED_INODE ; s_entry -> dev = ( dev_t ) UNCACHED_DEVICE ; } } if ( ! ( s_entry -> isorec . flags [ 0 ] & 2 ) ) { if ( s_entry -> hfs_ent && ! ( s_entry -> de_flags & RELOCATED_DIRECTORY ) ) { free ( s_entry -> hfs_ent ) ; } s_entry -> hfs_ent = NULL ; } if ( s_entry -> assoc && s_entry -> assoc -> size == 0 ) { delete_rsrc_ent ( s_entry ) ; } } if ( apple_ext && s_entry -> assoc ) { generate_rock_ridge_attributes ( whole_path , short_name , s_entry -> assoc , & statbuf , & lstatbuf , deep_flag ) ; } if ( use_RockRidge && ! have_rsrc ) { if ( use_RockRidge ) { generate_rock_ridge_attributes ( whole_path , short_name , s_entry , & statbuf , & lstatbuf , deep_flag ) ; } return 1 ; } 