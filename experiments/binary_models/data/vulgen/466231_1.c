int vflag ; int aflag ; char * * listbuf ; char * mntopt ( ) , * hasvfsopt ( ) , * hasmntopt ( ) ; char * whoami ; static void fixmntent ( ) static void mnterror ( ) static void usage ( char * ) static int oneof ( ) static int quotaonoff ( ) static int quotactl ( int , char * , uid_t , caddr_t ) extern int optind ; extern char * optarg ; int main ( int argc , char * * argv ) { struct mnttab mntp ; struct vfstab vfsbuf ; char * * listp ; int listcnt ; FILE * mtab , * vfstab , * tmp ; int offmode = 0 ; int listmax = 0 ; int errs = 0 ; char * tmpname = "/etc/mnttab.temp" ; int status ; int opt ; mode_t oldumask ; struct stat statbuf ; whoami = ( char * ) rindex ( * argv , '/' ) + 1 ; if ( whoami == ( char * ) 1 ) { whoami = * argv ; } if ( strcmp ( whoami , "quotaoff" ) == 0 ) { offmode ++ ; } if ( strcmp ( whoami , "quotaon" ) != 0 ) { fprintf ( stderr , "Name must be quotaon or quotaoff not %s\n" , whoami ) ; exit ( 31 + 1 ) ; } if ( ( listbuf = ( char * * ) malloc ( sizeof ( char * ) * CHUNK ) ) == NULL ) { fprintf ( stderr , "Can't alloc lisbuf array." ) ; exit ( 31 + 1 ) ; } listmax = CHUNK ; while ( ( opt = getopt ( argc , argv , "avV" ) ) != EOF ) { switch ( opt ) { case 'v' : vflag ++ ; break ; case 'a' : aflag ++ ; break ; case 'V' : { char * opt_text ; int opt_cnt ; ( void ) fprintf ( stdout , "%s -F UFS " , whoami ) ; for ( opt_cnt = 1 ; opt_cnt < argc ; opt_cnt ++ ) { opt_text = argv [ opt_cnt ] ; if ( opt_text ) { ( void ) fprintf ( stdout , " %s " , opt_text ) ; } } ( void ) fprintf ( stdout , "\n" ) ; } break ; case '?' : usage ( whoami ) ; } } if ( argc <= optind && ! aflag ) { usage ( whoami ) ; } if ( aflag ) { listp = listbuf ; listcnt = 0 ; vfstab = fopen ( VFSTAB , "r" ) ; if ( vfstab == NULL ) { fprintf ( stderr , "Can't open %s\n" , VFSTAB ) ; perror ( VFSTAB ) ; exit ( 31 + 1 ) ; } while ( ( status = getvfsent ( vfstab , & vfsbuf ) ) == 0 ) { if ( strcmp ( vfsbuf . vfs_fstype , MNTTYPE_UFS ) != 0 || ( vfsbuf . vfs_mntopts == 0 ) || hasvfsopt ( & vfsbuf , MNTOPT_RO ) || ( ! hasvfsopt ( & vfsbuf , MNTOPT_RQ ) && ! hasvfsopt ( & vfsbuf , MNTOPT_QUOTA ) ) ) { continue ; } * listp = malloc ( strlen ( vfsbuf . vfs_special ) + 1 ) ; strcpy ( * listp , vfsbuf . vfs_special ) ; listp ++ ; listcnt ++ ; if ( listcnt >= listmax ) { listmax += CHUNK ; listbuf = ( char * * ) realloc ( listbuf , sizeof ( char * ) * listmax ) ; if ( listbuf == NULL ) { fprintf ( stderr , "Can't grow listbuf.\n" ) ; exit ( 31 + 1 ) ; } listp = & listbuf [ listcnt ] ; } } fclose ( vfstab ) ; * listp = ( char * ) 0 ; listp = listbuf ; } else { listp = & argv [ optind ] ; listcnt = argc - optind ; } mtab = fopen ( MNTTAB , "r" ) ; if ( mtab == NULL ) { fprintf ( stderr , "Can't open %s\n" , MNTTAB ) ; perror ( whoami ) ; exit ( 31 + 1 ) ; } while ( ( status = getmntent ( mtab , & mntp ) ) == 0 ) { } if ( status > 0 ) { mnterror ( status ) ; } rewind ( mtab ) ; signal ( SIGHUP , SIG_IGN ) ; signal ( SIGQUIT , SIG_IGN ) ; signal ( SIGINT , SIG_IGN ) ; while ( ( status = getmntent ( mtab , & mntp ) ) == 0 ) { if ( strcmp ( mntp . mnt_fstype , MNTTYPE_UFS ) == 0 && ! hasmntopt ( & mntp , MNTOPT_RO ) && ( oneof ( mntp . mnt_special , listp , listcnt ) || oneof ( mntp . mnt_mountp , listp , listcnt ) ) ) { errs += quotaonoff ( & mntp , offmode ) ; } } fclose ( mtab ) ; while ( listcnt -- ) { if ( * listp ) { fprintf ( stderr , "Cannot do %s\n" , * listp ) ; errs ++ ; } listp ++ ; } return ( errs ) ; } 