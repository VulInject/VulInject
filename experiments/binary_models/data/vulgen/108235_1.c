zend_result zend_call_function ( zend_fcall_info * fci , zend_fcall_info_cache * fci_cache ) { uint32_t i ; zend_execute_data * call ; zend_fcall_info_cache fci_cache_local ; zend_function * func ; uint32_t call_info ; void * object_or_called_scope ; zend_class_entry * orig_fake_scope ; ZVAL_UNDEF ( fci -> retval ) ; if ( ! EG ( active ) ) { return FAILURE ; } if ( EG ( exception ) ) { if ( fci_cache ) { zend_release_fcall_info_cache ( fci_cache ) ; } return SUCCESS ; } ZEND_ASSERT ( fci -> size == sizeof ( zend_fcall_info ) ) ; if ( ! fci_cache || ! fci_cache -> function_handler ) { char * error = NULL ; if ( ! fci_cache ) { fci_cache = & fci_cache_local ; } if ( ! zend_is_callable_ex ( & fci -> function_name , fci -> object , 0 , NULL , fci_cache , & error ) ) { ZEND_ASSERT ( error && "Should have error if not callable" ) ; zend_string * callable_name = zend_get_callable_name_ex ( & fci -> function_name , fci -> object ) ; zend_throw_error ( NULL , "Invalid callback %s, %s" , ZSTR_VAL ( callable_name ) , error ) ; zend_string_release_ex ( callable_name , 0 ) ; return SUCCESS ; } ZEND_ASSERT ( ! error ) ; } func = fci_cache -> function_handler ; if ( ( func -> common . fn_flags & ZEND_ACC_STATIC ) || ! fci_cache -> object ) { object_or_called_scope = fci_cache -> called_scope ; call_info = ZEND_CALL_TOP_FUNCTION | ZEND_CALL_DYNAMIC ; } else { object_or_called_scope = fci_cache -> object ; call_info = ZEND_CALL_TOP_FUNCTION | ZEND_CALL_DYNAMIC | ZEND_CALL_HAS_THIS ; } call = zend_vm_stack_push_call_frame ( call_info , func , fci -> param_count , object_or_called_scope ) ; if ( UNEXPECTED ( func -> common . fn_flags & ZEND_ACC_DEPRECATED ) ) { zend_deprecated_function ( func ) ; if ( UNEXPECTED ( EG ( exception ) ) ) { zend_vm_stack_free_call_frame ( call ) ; return SUCCESS ; } } for ( i = 0 ; i < fci -> param_count ; i ++ ) { zval * param = ZEND_CALL_ARG ( call , i + 1 ) ; zval * arg = & fci -> params [ i ] ; bool must_wrap = 0 ; if ( UNEXPECTED ( Z_ISUNDEF_P ( arg ) ) ) { ZVAL_UNDEF ( param ) ; ZEND_ADD_CALL_FLAG ( call , ZEND_CALL_MAY_HAVE_UNDEF ) ; continue ; } if ( ARG_SHOULD_BE_SENT_BY_REF ( func , i + 1 ) ) { if ( UNEXPECTED ( ! Z_ISREF_P ( arg ) ) ) { if ( ! ARG_MAY_BE_SENT_BY_REF ( func , i + 1 ) ) { zend_param_must_be_ref ( func , i + 1 ) ; must_wrap = 1 ; if ( UNEXPECTED ( EG ( exception ) ) ) { ZEND_CALL_NUM_ARGS ( call ) = i ; cleanup_args zend_vm_stack_free_args ( call ) ; zend_vm_stack_free_call_frame ( call ) ; return SUCCESS ; } } } } else { if ( Z_ISREF_P ( arg ) && ! ( func -> common . fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE ) ) { arg = Z_REFVAL_P ( arg ) ; } } if ( EXPECTED ( ! must_wrap ) ) { ZVAL_COPY ( param , arg ) ; } else { Z_TRY_ADDREF_P ( arg ) ; ZVAL_NEW_REF ( param , arg ) ; } } if ( fci -> named_params ) { zend_string * name ; zval * arg ; uint32_t arg_num = ZEND_CALL_NUM_ARGS ( call ) + 1 ; bool have_named_params = 0 ; ZEND_HASH_FOREACH_STR_KEY_VAL ( , , ) { bool must_wrap = 0 ; zval * target ; if ( name ) { void * cache_slot [ 2 ] { NULL NULL } ; ; have_named_params = 1 ; target = zend_handle_named_arg ( & call , name , & arg_num , cache_slot ) ; if ( ! target ) { cleanup_args } } else { if ( have_named_params ) { zend_throw_error ( NULL , "Cannot use positional argument after named argument" ) ; cleanup_args } zend_vm_stack_extend_call_frame ( & call , arg_num - 1 , 1 ) ; target = ZEND_CALL_ARG ( call , arg_num ) ; } if ( ARG_SHOULD_BE_SENT_BY_REF ( func , arg_num ) ) { if ( UNEXPECTED ( ! Z_ISREF_P ( arg ) ) ) { if ( ! ARG_MAY_BE_SENT_BY_REF ( func , arg_num ) ) { zend_param_must_be_ref ( func , arg_num ) ; must_wrap = 1 ; if ( UNEXPECTED ( EG ( exception ) ) ) { cleanup_args } } } } else { if ( Z_ISREF_P ( arg ) && ! ( func -> common . fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE ) ) { arg = Z_REFVAL_P ( arg ) ; } } if ( EXPECTED ( ! must_wrap ) ) { ZVAL_COPY ( target , arg ) ; } else { Z_TRY_ADDREF_P ( arg ) ; ZVAL_NEW_REF ( target , arg ) ; } if ( ! name ) { ZEND_CALL_NUM_ARGS ( call ) ++ ; arg_num ++ ; } } ZEND_HASH_FOREACH_END ( ) ; } if ( UNEXPECTED ( ZEND_CALL_INFO ( call ) & ZEND_CALL_MAY_HAVE_UNDEF ) ) { if ( zend_handle_undef_args ( call ) == FAILURE ) { zend_vm_stack_free_args ( call ) ; zend_vm_stack_free_call_frame ( call ) ; return SUCCESS ; } } if ( UNEXPECTED ( func -> op_array . fn_flags & ZEND_ACC_CLOSURE ) ) { uint32_t call_info ; GC_ADDREF ( ZEND_CLOSURE_OBJECT ( func ) ) ; call_info = ZEND_CALL_CLOSURE ; if ( func -> common . fn_flags & ZEND_ACC_FAKE_CLOSURE ) { call_info |= ZEND_CALL_FAKE_CLOSURE ; } ZEND_ADD_CALL_FLAG ( call , call_info ) ; } if ( func -> common . fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE ) { fci_cache -> function_handler = NULL ; } orig_fake_scope = EG ( fake_scope ) ; EG ( fake_scope ) = NULL ; if ( func -> type == ZEND_USER_FUNCTION ) { uint32_t orig_jit_trace_num = EG ( jit_trace_num ) ; zend_init_func_execute_data ( call , & func -> op_array , fci -> retval ) ; ZEND_OBSERVER_FCALL_BEGIN ( call ) ; zend_execute_ex ( call ) ; EG ( jit_trace_num ) = orig_jit_trace_num ; } else { ZEND_ASSERT ( func -> type == ZEND_INTERNAL_FUNCTION ) ; ZVAL_NULL ( fci -> retval ) ; call -> prev_execute_data = EG ( current_execute_data ) ; EG ( current_execute_data ) = call ; bool should_throw = zend_internal_call_should_throw ( func , call ) ; ZEND_OBSERVER_FCALL_BEGIN ( call ) ; if ( EXPECTED ( zend_execute_internal == NULL ) ) { func -> internal_function . handler ( call , fci -> retval ) ; } else { zend_execute_internal ( call , fci -> retval ) ; } if ( ! EG ( exception ) && call -> func ) { if ( should_throw ) { zend_internal_call_arginfo_violation ( call -> func ) ; } ZEND_ASSERT ( ! ( call -> func -> common . fn_flags & ZEND_ACC_HAS_RETURN_TYPE ) || zend_verify_internal_return_type ( call -> func , fci -> retval ) ) ; ZEND_ASSERT ( ( call -> func -> common . fn_flags & ZEND_ACC_RETURN_REFERENCE ) ?Z_ISREF_P ( fci -> retval ) : ! Z_ISREF_P ( fci -> retval ) ) ; } ZEND_OBSERVER_FCALL_END ( call , fci -> retval ) ; EG ( current_execute_data ) = call -> prev_execute_data ; zend_vm_stack_free_args ( call ) ; if ( UNEXPECTED ( ZEND_CALL_INFO ( call ) & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS ) ) { zend_array_release ( call -> extra_named_params ) ; } if ( EG ( exception ) ) { zval_ptr_dtor ( fci -> retval ) ; ZVAL_UNDEF ( fci -> retval ) ; } if ( zend_atomic_bool_exchange_ex ( & EG ( vm_interrupt ) , false ) ) { if ( zend_atomic_bool_load_ex ( & EG ( timed_out ) ) ) { zend_timeout ( ) ; } if ( zend_interrupt_function ) { zend_interrupt_function ( EG ( current_execute_data ) ) ; } } if ( UNEXPECTED ( ZEND_CALL_INFO ( call ) & ZEND_CALL_RELEASE_THIS ) ) { OBJ_RELEASE ( Z_OBJ ( call -> This ) ) ; } } EG ( fake_scope ) = orig_fake_scope ; zend_vm_stack_free_call_frame ( call ) ; if ( UNEXPECTED ( EG ( exception ) ) ) { if ( UNEXPECTED ( ! EG ( current_execute_data ) ) ) { zend_throw_exception_internal ( NULL ) ; } if ( EG ( current_execute_data ) -> func && ZEND_USER_CODE ( EG ( current_execute_data ) -> func -> common . type ) ) { zend_rethrow_exception ( EG ( current_execute_data ) ) ; } } return SUCCESS ; } 