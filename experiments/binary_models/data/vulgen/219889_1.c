static int exec_ssystem ( cmd_rec * cmd , config_rec * c , int flags ) { pid_t pid ; int status ; struct sigaction sa_ignore , sa_intr , sa_quit ; sigset_t set_chldmask , set_save ; sa_ignore . sa_handler = SIG_IGN ; sigemptyset ( & sa_ignore . sa_mask ) ; sa_ignore . sa_flags = 0 ; if ( sigaction ( SIGINT , & sa_ignore , & sa_intr ) < 0 ) { return errno ; } if ( sigaction ( SIGQUIT , & sa_ignore , & sa_quit ) < 0 ) { return errno ; } sigemptyset ( & set_chldmask ) ; sigaddset ( & set_chldmask , SIGCHLD ) ; if ( sigprocmask ( SIG_BLOCK , & set_chldmask , & set_save ) < 0 ) { exec_log ( "sigprocmask error: %s" , strerror ( errno ) ) ; return errno ; } exec_prepare_pipes ( ) ; pid = fork ( ) ; if ( pid < 0 ) { int xerrno = errno ; pr_log_pri ( PR_LOG_ALERT , MOD_EXEC_VERSION ": error: unable to fork: %s" , strerror ( xerrno ) ) ; exec_log ( "error: unable to fork: %s" , strerror ( xerrno ) ) ; errno = xerrno ; status = - 1 ; } if ( pid == 0 ) { char * * env = NULL , * path = NULL , * ptr = NULL ; register unsigned int i = 0 ; pool * tmp_pool = cmd ?cmd -> tmp_pool : make_sub_pool ( session . pool ) ; session . pid = getpid ( ) ; if ( ! ( exec_opts & EXEC_OPT_USE_STDIN ) ) { env = exec_prepare_environ ( tmp_pool , cmd ) ; for ( i = 3 ; i < c -> argc ; i ++ ) { pr_signals_handle ( ) ; c -> argv [ i ] = ( void * ) exec_subst_var ( tmp_pool , c -> argv [ i ] , cmd ) ; } } else { env = pcalloc ( tmp_pool , sizeof ( char * * ) ) ; } sigaction ( SIGINT , & sa_intr , NULL ) ; sigaction ( SIGQUIT , & sa_quit , NULL ) ; sigprocmask ( SIG_SETMASK , & set_save , NULL ) ; if ( flags & EXEC_FL_RUN_AS_USER ) { flags &= ~ EXEC_FL_CLEAR_GROUPS ; } if ( flags & EXEC_FL_CLEAR_GROUPS ) { PRIVS_ROOT setgroups ( 0 , NULL ) ; PRIVS_RELINQUISH ; } if ( flags & EXEC_FL_RUN_AS_ROOT ) { PRIVS_ROOT ; } if ( flags & EXEC_FL_RUN_AS_USER ) { if ( geteuid ( ) != session . login_uid ) { PRIVS_SETUP ( , ) } PRIVS_REVOKE ; } else { PRIVS_REVOKE ; } exec_log ( "preparing to execute '%s' with uid %s (euid %s), " "gid %s (egid %s)" , ( const char * ) c -> argv [ 2 ] , pr_uid2str ( tmp_pool , getuid ( ) ) , pr_uid2str ( tmp_pool , geteuid ( ) ) , pr_gid2str ( tmp_pool , getgid ( ) ) , pr_gid2str ( tmp_pool , getegid ( ) ) ) ; path = c -> argv [ 2 ] ; ptr = strrchr ( c -> argv [ 2 ] , '/' ) ; c -> argv [ 2 ] = ptr + 1 ; for ( i = 3 ; i < c -> argc ; i ++ ) { if ( c -> argv [ i ] != NULL ) { exec_log ( " + '%s': argv[%u] = %s" , ( const char * ) path , i - 2 , ( const char * ) c -> argv [ i ] ) ; } } if ( exec_opts & EXEC_OPT_USE_STDIN ) { exec_prepare_fds ( exec_stdin_pipe [ 0 ] , exec_stdout_pipe [ 1 ] , exec_stderr_pipe [ 1 ] ) ; } else { exec_prepare_fds ( - 1 , exec_stdout_pipe [ 1 ] , exec_stderr_pipe [ 1 ] ) ; } errno = 0 ; if ( exec_opts & EXEC_OPT_USE_STDIN ) { char * args [ ] { ptr + 1 NULL } ; ; execve ( path , args , env ) ; } else { execve ( path , ( char * * ) ( c -> argv + 2 ) , env ) ; } exit ( errno ) ; } else { int res ; if ( exec_opts & EXEC_OPT_USE_STDIN ) { register unsigned int i ; int maxfd = - 1 , fds ; fd_set writefds ; struct timeval tv ; pool * tmp_pool = cmd ?cmd -> tmp_pool : make_sub_pool ( session . pool ) ; FD_ZERO ( & writefds ) ; FD_SET ( exec_stdin_pipe [ 1 ] , & writefds ) ; if ( exec_stdin_pipe [ 1 ] > maxfd ) { maxfd = exec_stdin_pipe [ 1 ] ; } tv . tv_sec = 2L ; tv . tv_usec = 0L ; fds = select ( maxfd + 1 , & writefds , NULL , NULL , & tv ) ; if ( fds == - 1 && errno == EINTR ) { pr_signals_handle ( ) ; } for ( i = 3 ; i < c -> argc && c -> argv [ i ] != NULL ; i ++ ) { pr_signals_handle ( ) ; c -> argv [ i ] = ( void * ) exec_subst_var ( tmp_pool , c -> argv [ i ] , cmd ) ; if ( write ( exec_stdin_pipe [ 1 ] , c -> argv [ i ] , strlen ( c -> argv [ i ] ) ) < 0 ) { exec_log ( "error writing argument to stdin: %s" , strerror ( errno ) ) ; } else { exec_log ( "wrote argument %u (%s) to stdin (%d)" , i - 3 , ( char * ) c -> argv [ i ] , exec_stdin_pipe [ 1 ] ) ; } if ( write ( exec_stdin_pipe [ 1 ] , "\n" , 1 ) < 0 ) { exec_log ( "error writing newline to stdin: %s" , strerror ( errno ) ) ; } } if ( write ( exec_stdin_pipe [ 1 ] , ".\n" , 2 ) < 0 ) { exec_log ( "error writing end-of-argument indicator: %s" , strerror ( errno ) ) ; } if ( cmd == NULL ) { destroy_pool ( tmp_pool ) ; } } if ( exec_opts & EXEC_OPT_USE_STDIN ) { ( void ) close ( exec_stdin_pipe [ 0 ] ) ; exec_stdin_pipe [ 0 ] = - 1 ; } ( void ) close ( exec_stdout_pipe [ 1 ] ) ; exec_stdout_pipe [ 1 ] = - 1 ; ( void ) close ( exec_stderr_pipe [ 1 ] ) ; exec_stderr_pipe [ 1 ] = - 1 ; if ( ( exec_opts & EXEC_OPT_LOG_STDOUT ) || ( exec_opts & EXEC_OPT_LOG_STDERR ) || ( exec_opts & EXEC_OPT_SEND_STDOUT ) || exec_timeout > 0 ) { int maxfd = - 1 , fds , send_sigterm = 1 ; fd_set readfds ; struct timeval tv ; time_t start_time = time ( NULL ) ; pool * tmp_pool = cmd ?cmd -> tmp_pool : make_sub_pool ( session . pool ) ; res = 0 ; while ( res <= 0 ) { if ( res < 0 ) { if ( errno != EINTR ) { exec_log ( "error: unable to wait for pid %d: %s" , pid , strerror ( errno ) ) ; status = - 1 ; break ; } else { pr_signals_handle ( ) ; continue ; } } if ( exec_timeout > 0 ) { if ( ( time ( NULL ) - start_time ) > exec_timeout ) { if ( send_sigterm ) { send_sigterm = 0 ; exec_log ( "'%s' has exceeded ExecTimeout (%lu seconds), sending " "SIGTERM (signal %d)" , ( const char * ) c -> argv [ 2 ] , ( unsigned long ) exec_timeout , SIGTERM ) ; kill ( pid , SIGTERM ) ; } else { exec_log ( "'%s' has exceeded ExecTimeout (%lu seconds), sending " "SIGKILL (signal %d)" , ( const char * ) c -> argv [ 2 ] , ( unsigned long ) exec_timeout , SIGKILL ) ; kill ( pid , SIGKILL ) ; } } } FD_ZERO ( & readfds ) ; if ( ( exec_opts & EXEC_OPT_LOG_STDOUT ) || ( exec_opts & EXEC_OPT_SEND_STDOUT ) ) { FD_SET ( exec_stdout_pipe [ 0 ] , & readfds ) ; if ( exec_stdout_pipe [ 0 ] > maxfd ) { maxfd = exec_stdout_pipe [ 0 ] ; } } if ( exec_opts & EXEC_OPT_LOG_STDERR ) { FD_SET ( exec_stderr_pipe [ 0 ] , & readfds ) ; if ( exec_stderr_pipe [ 0 ] > maxfd ) { maxfd = exec_stderr_pipe [ 0 ] ; } } tv . tv_sec = 2L ; tv . tv_usec = 0L ; fds = select ( maxfd + 1 , & readfds , NULL , NULL , & tv ) ; if ( fds == - 1 && errno == EINTR ) { pr_signals_handle ( ) ; } if ( fds >= 0 ) { long buflen , bufsz ; char * buf ; buf = pr_fsio_getpipebuf ( tmp_pool , exec_stdout_pipe [ 0 ] , & bufsz ) ; if ( FD_ISSET ( exec_stdout_pipe [ 0 ] , & readfds ) ) { memset ( buf , '\0' , bufsz ) ; buflen = read ( exec_stdout_pipe [ 0 ] , buf , bufsz - 1 ) ; if ( buflen > 0 ) { if ( exec_opts & EXEC_OPT_SEND_STDOUT ) { if ( ! ( flags & EXEC_FL_NO_SEND ) ) { if ( flags & EXEC_FL_USE_SEND ) { pr_response_send ( R_220 , "%s" , buf ) ; } else { pr_response_add ( R_DUP , "%s" , buf ) ; } } else { exec_log ( "not appropriate to send stdout to client at " "this time" ) ; } } while ( buflen > 0 && ( buf [ buflen - 1 ] == '\r' || buf [ buflen - 1 ] == '\n' ) ) { pr_signals_handle ( ) ; buf [ buflen - 1 ] = '\0' ; buflen -- ; } buf [ buflen ] = '\0' ; if ( exec_opts & EXEC_OPT_LOG_STDOUT ) { exec_log ( "stdout from '%s': '%s'" , ( const char * ) c -> argv [ 2 ] , buf ) ; } } if ( buflen < 0 ) { if ( errno != 0 ) { exec_log ( "error reading stdout from '%s': %s" , ( const char * ) c -> argv [ 2 ] , strerror ( errno ) ) ; } } } if ( FD_ISSET ( exec_stderr_pipe [ 0 ] , & readfds ) ) { memset ( buf , '\0' , bufsz ) ; buflen = read ( exec_stderr_pipe [ 0 ] , buf , bufsz - 1 ) ; if ( buflen > 0 ) { while ( buflen > 0 && ( buf [ buflen - 1 ] == '\r' || buf [ buflen - 1 ] == '\n' ) ) { pr_signals_handle ( ) ; buf [ buflen - 1 ] = '\0' ; buflen -- ; } buf [ buflen ] = '\0' ; if ( exec_opts & EXEC_OPT_LOG_STDERR ) { exec_log ( "stderr from '%s': '%s'" , ( const char * ) c -> argv [ 2 ] , buf ) ; } } if ( buflen < 0 ) { if ( errno != 0 ) { exec_log ( "error reading stderr from '%s': %s" , ( const char * ) c -> argv [ 2 ] , strerror ( errno ) ) ; } } } } res = waitpid ( pid , & status , WNOHANG ) ; } if ( cmd == NULL ) { destroy_pool ( tmp_pool ) ; } } else { res = waitpid ( pid , & status , 0 ) ; while ( res <= 0 ) { res = waitpid ( pid , & status , 0 ) ; } } } close ( exec_stdout_pipe [ 0 ] ) ; close ( exec_stderr_pipe [ 0 ] ) ; if ( sigaction ( SIGINT , & sa_intr , NULL ) < 0 ) { exec_log ( "sigaction() error: %s" , strerror ( errno ) ) ; return errno ; } if ( sigaction ( SIGQUIT , & sa_quit , NULL ) < 0 ) { exec_log ( "sigaction() error: %s" , strerror ( errno ) ) ; return errno ; } if ( sigprocmask ( SIG_SETMASK , & set_save , NULL ) < 0 ) { exec_log ( "sigprocmask() error: %s" , strerror ( errno ) ) ; return errno ; } if ( WIFEXITED ( status ) ) { int exit_status ; exit_status = WEXITSTATUS ( status ) ; exec_log ( "'%s' terminated normally, with exit status %d" , ( const char * ) c -> argv [ 2 ] , exit_status ) ; return exit_status ; } if ( WIFSIGNALED ( status ) ) { exec_log ( "'%s' died from signal %d" , ( const char * ) c -> argv [ 2 ] , WTERMSIG ( status ) ) ; if ( WCOREDUMP ( status ) ) { exec_log ( "'%s' created a coredump" , ( const char * ) c -> argv [ 2 ] ) ; } return EPERM ; } return status ; } 