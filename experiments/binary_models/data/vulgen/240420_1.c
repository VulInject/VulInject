static int uwsgi_routing_func_rpc_ret ( struct wsgi_request * wsgi_req , struct uwsgi_route * ur ) { int ret = - 1 ; char * argv [ UMAX8 ] ; uint16_t argvs [ UMAX8 ] ; struct uwsgi_buffer * ubs [ UMAX8 ] ; uint64_t num_translated , i ; if ( ! uwsgi_rpc_apply_translations ( wsgi_req , ur , ubs , & num_translated , argv , argvs ) ) { end } char * func = uwsgi_str ( ur -> data ) ; char * remote = uwsgi_rpc_get_remote ( func ) ; uint64_t size ; char * response = uwsgi_do_rpc ( remote , func , ur -> custom , argv , argvs , & size ) ; free ( func ) ; if ( ! response ) { end } ret = UWSGI_ROUTE_CONTINUE ; if ( ! uwsgi_strncmp ( response , size , "next" , 4 ) ) { ret = UWSGI_ROUTE_NEXT ; } if ( ! uwsgi_strncmp ( response , size , "continue" , 8 ) ) { ret = UWSGI_ROUTE_CONTINUE ; } if ( ! uwsgi_starts_with ( response , size , "break" , 5 ) ) { ret = UWSGI_ROUTE_BREAK ; if ( size > 6 ) { if ( uwsgi_response_prepare_headers ( wsgi_req , response + 6 , size - 6 ) ) { end0 } if ( uwsgi_response_add_connection_close ( wsgi_req ) ) { end0 } if ( uwsgi_response_add_content_type ( wsgi_req , "text/plain" , 10 ) ) { end0 } uwsgi_response_write_headers_do ( wsgi_req ) ; } } if ( ! uwsgi_starts_with ( response , size , "goto " , 5 ) ) { ret = UWSGI_ROUTE_BREAK ; if ( size > 5 ) { struct uwsgi_route * routes = uwsgi . routes ; while ( routes ) { if ( ! routes -> label ) { next } if ( ! uwsgi_strncmp ( routes -> label , routes -> label_len , response + 5 , size - 5 ) ) { ret = UWSGI_ROUTE_NEXT ; wsgi_req -> route_goto = routes -> pos ; found } next routes = routes -> next ; } end0 found } } end0 free ( response ) ; end for ( i = 0 ; i < num_translated ; i ++ ) { uwsgi_buffer_destroy ( ubs [ i ] ) ; } return ret ; } 