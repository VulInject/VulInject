static void qcom_nandc_command ( struct mtd_info * mtd , unsigned int command , int column , int page_addr ) { struct nand_chip * chip = mtd_to_nand ( mtd ) ; struct qcom_nand_host * host = to_qcom_nand_host ( chip ) ; struct nand_ecc_ctrl * ecc = & chip -> ecc ; struct qcom_nand_controller * nandc = get_qcom_nand_controller ( chip ) ; bool wait = false ; int ret = 0 ; pre_command ( host , command ) ; switch ( command ) { case NAND_CMD_RESET : ret = reset ( host ) ; wait = true ; break ; case NAND_CMD_READID : nandc -> buf_count = 4 ; ret = read_id ( host , column ) ; wait = true ; break ; case NAND_CMD_PARAM : ret = nandc_param ( host ) ; wait = true ; break ; case NAND_CMD_ERASE1 : ret = erase_block ( host , page_addr ) ; wait = true ; break ; case NAND_CMD_READ0 : WARN_ON ( column != 0 ) ; host -> use_ecc = true ; set_address ( host , 0 , page_addr ) ; update_rw_regs ( host , ecc -> steps , true ) ; break ; case NAND_CMD_SEQIN : WARN_ON ( column != 0 ) ; set_address ( host , 0 , page_addr ) ; break ; case NAND_CMD_PAGEPROG : case NAND_CMD_STATUS : case NAND_CMD_NONE : default : break ; } if ( ret ) { dev_err ( nandc -> dev , "failure executing command %d\n" , command ) ; return ; } if ( wait ) { ret = submit_descs ( nandc ) ; if ( ret ) { dev_err ( nandc -> dev , "failure submitting descs for command %d\n" , command ) ; } } free_descs ( nandc ) ; post_command ( host , command ) ; } 