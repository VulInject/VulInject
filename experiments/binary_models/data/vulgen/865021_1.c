int lgrp_affinity_set ( lgrp_affinity_args_t * ap ) { lgrp_affinity_t aff ; lgrp_affinity_t * aff_buf ; lgrp_affinity_args_t args ; id_t id ; idtype_t idtype ; lgrp_id_t lgrp ; int nthreads ; proc_t * p ; int retval ; if ( copyin ( ap , & args , sizeof ( lgrp_affinity_args_t ) ) != 0 ) { return ( set_errno ( EFAULT ) ) ; } idtype = args . idtype ; id = args . id ; lgrp = args . lgrp ; aff = args . aff ; if ( lgrp > lgrp_alloc_max ) { return ( set_errno ( ESRCH ) ) ; } if ( aff != LGRP_AFF_NONE && aff != LGRP_AFF_WEAK && aff != LGRP_AFF_STRONG ) { return ( set_errno ( EINVAL ) ) ; } if ( idtype != P_LWPID && idtype != P_PID ) { return ( set_errno ( EINVAL ) ) ; } retval = EINVAL ; switch ( idtype ) { case P_LWPID : aff_buf = kmem_zalloc ( nlgrpsmax * sizeof ( lgrp_affinity_t ) , KM_SLEEP ) ; p = curproc ; mutex_enter ( & p -> p_lock ) ; if ( id == P_MYID ) { retval = lgrp_affinity_set_thread ( curthread , lgrp , aff , & aff_buf ) ; } if ( p -> p_tlist == NULL ) { retval = set_errno ( ESRCH ) ; } else { int found = 0 ; kthread_t * t ; t = p -> p_tlist ; { if ( t -> t_tid == id ) { retval = lgrp_affinity_set_thread ( t , lgrp , aff , & aff_buf ) ; found = 1 ; break ; } } ( t = t -> t_forw ) != p -> p_tlist ; if ( ! found ) { retval = set_errno ( ESRCH ) ; } } mutex_exit ( & p -> p_lock ) ; if ( aff_buf ) { kmem_free ( aff_buf , nlgrpsmax * sizeof ( lgrp_affinity_t ) ) ; } break ; case P_PID : { lgrp_affinity_t * * aff_buf_array ; int i ; size_t size ; mutex_enter ( & pidlock ) ; if ( id == P_MYID ) { p = curproc ; } else { p = prfind ( id ) ; } if ( p == NULL ) { mutex_exit ( & pidlock ) ; return ( set_errno ( ESRCH ) ) ; } mutex_enter ( & p -> p_lock ) ; nthreads = p -> p_lwpcnt ; mutex_exit ( & p -> p_lock ) ; mutex_exit ( & pidlock ) ; if ( nthreads < 1 ) { return ( set_errno ( ESRCH ) ) ; } aff_buf_array = kmem_zalloc ( nthreads * sizeof ( lgrp_affinity_t * ) , KM_SLEEP ) ; size = nlgrpsmax * sizeof ( lgrp_affinity_t ) ; for ( i = 0 ; i < nthreads ; i ++ ) { aff_buf_array [ i ] = kmem_zalloc ( size , KM_SLEEP ) ; } mutex_enter ( & pidlock ) ; if ( id != P_MYID ) { p = prfind ( id ) ; } if ( p == NULL ) { mutex_exit ( & pidlock ) ; for ( i = 0 ; i < nthreads ; i ++ ) { kmem_free ( aff_buf_array [ i ] , size ) ; } kmem_free ( aff_buf_array , nthreads * sizeof ( lgrp_affinity_t * ) ) ; return ( set_errno ( ESRCH ) ) ; } mutex_enter ( & p -> p_lock ) ; if ( nthreads != p -> p_lwpcnt ) { mutex_exit ( & p -> p_lock ) ; mutex_exit ( & pidlock ) ; for ( i = 0 ; i < nthreads ; i ++ ) { kmem_free ( aff_buf_array [ i ] , size ) ; } kmem_free ( aff_buf_array , nthreads * sizeof ( lgrp_affinity_t * ) ) ; continue ; } retval = lgrp_affinity_set_proc ( p , lgrp , aff , aff_buf_array ) ; mutex_exit ( & p -> p_lock ) ; mutex_exit ( & pidlock ) ; for ( i = 0 ; i < nthreads ; i ++ ) { if ( aff_buf_array [ i ] != NULL ) { kmem_free ( aff_buf_array [ i ] , size ) ; } } kmem_free ( aff_buf_array , nthreads * sizeof ( lgrp_affinity_t * ) ) ; break ; } nthreads != p -> p_lwpcnt ; break ; default : retval = set_errno ( EINVAL ) ; break ; } return ( retval ) ; } 