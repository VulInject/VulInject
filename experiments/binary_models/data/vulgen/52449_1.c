otl_Subtable * otl_read_gsub_single ( const font_file_pointer data , uint32_t tableLength , uint32_t subtableOffset , const glyphid_t maxGlyphs , const otfcc_Options * options ) { subtable_gsub_single * subtable = iSubtable_gsub_single . create ( ) ; otl_Coverage * from = NULL ; otl_Coverage * to = NULL ; if ( tableLength < subtableOffset + 6 ) { FAIL } uint16_t subtableFormat = read_16u ( data + subtableOffset ) ; from = Coverage . read ( data , tableLength , subtableOffset + read_16u ( data + subtableOffset + 2 ) ) ; if ( ! from || from -> numGlyphs == 0 ) { FAIL } if ( subtableFormat == 1 ) { NEW ( to ) ; to -> numGlyphs = from -> numGlyphs ; NEW ( to -> glyphs , to -> numGlyphs ) ; uint16_t delta = read_16u ( data + subtableOffset + 4 ) ; for ( glyphid_t j = 0 ; j < from -> numGlyphs ; j ++ ) { to -> glyphs [ j ] = Handle . fromIndex ( from -> glyphs [ j ] . index + delta ) ; } } else { glyphid_t toglyphs = read_16u ( data + subtableOffset + 4 ) ; if ( tableLength < subtableOffset + 6 + toglyphs * 2 || toglyphs != from -> numGlyphs ) { FAIL } NEW ( to ) ; to -> numGlyphs = toglyphs ; NEW ( to -> glyphs , to -> numGlyphs ) ; for ( glyphid_t j = 0 ; j < to -> numGlyphs ; j ++ ) { to -> glyphs [ j ] = Handle . fromIndex ( read_16u ( data + subtableOffset + 6 + j * 2 ) ) ; } } OK FAIL iSubtable_gsub_single . free ( subtable ) ; if ( from ) { Coverage . free ( from ) ; } if ( to ) { Coverage . free ( to ) ; } return NULL ; OK for ( glyphid_t j = 0 ; j < from -> numGlyphs ; j ++ ) { iSubtable_gsub_single . push ( subtable , ( ( otl_GsubSingleEntry ) { . from = Handle . dup ( from -> glyphs [ j ] ) . to = Handle . dup ( to -> glyphs [ j ] ) } ) ) ; } if ( from ) { Coverage . free ( from ) ; } return ( otl_Subtable * ) subtable ; } 