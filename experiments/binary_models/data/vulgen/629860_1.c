static enum ia_css_err pipeline_stage_create ( struct ia_css_pipeline_stage_desc * stage_desc , struct ia_css_pipeline_stage * * new_stage ) { enum ia_css_err err = IA_CSS_SUCCESS ; struct ia_css_pipeline_stage * stage = NULL ; struct ia_css_binary * binary ; struct ia_css_frame * vf_frame ; struct ia_css_frame * out_frame [ IA_CSS_BINARY_MAX_OUTPUT_PORTS ] ; const struct ia_css_fw_info * firmware ; unsigned int i ; if ( ! ( stage_desc -> in_frame ) && ! ( stage_desc -> firmware ) && ( stage_desc -> binary ) && ! ( stage_desc -> binary -> online ) ) { err = IA_CSS_ERR_INTERNAL_ERROR ; ERR } binary = stage_desc -> binary ; firmware = stage_desc -> firmware ; vf_frame = stage_desc -> vf_frame ; for ( i = 0 ; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS ; i ++ ) { out_frame [ i ] = stage_desc -> out_frame [ i ] ; } stage = sh_css_malloc ( sizeof ( * stage ) ) ; if ( stage == NULL ) { err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY ; ERR } if ( firmware ) { stage -> binary = NULL ; stage -> binary_info = ( ia_css_binary_info * ) & firmware -> info . isp ; } else { stage -> binary = binary ; if ( binary ) { stage -> binary_info = ( ia_css_binary_info * ) binary -> info ; } else { stage -> binary_info = NULL ; } } stage -> firmware = firmware ; stage -> sp_func = stage_desc -> sp_func ; stage -> max_input_width = stage_desc -> max_input_width ; stage -> mode = stage_desc -> mode ; for ( i = 0 ; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS ; i ++ ) { stage -> out_frame_allocated [ i ] = false ; } stage -> vf_frame_allocated = false ; stage -> next = NULL ; sh_css_binary_args_reset ( & stage -> args ) ; for ( i = 0 ; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS ; i ++ ) { if ( ! ( out_frame [ i ] ) && ( binary ) && ( binary -> out_frame_info [ i ] . res . width ) ) { err = ia_css_frame_allocate_from_info ( & out_frame [ i ] , & binary -> out_frame_info [ i ] ) ; if ( err != IA_CSS_SUCCESS ) { ERR } stage -> out_frame_allocated [ i ] = true ; } } if ( ! vf_frame ) { if ( ( binary && binary -> vf_frame_info . res . width ) || ( firmware && firmware -> info . isp . sp . enable . vf_veceven ) ) { err = ia_css_frame_allocate_from_info ( & vf_frame , & binary -> vf_frame_info ) ; if ( err != IA_CSS_SUCCESS ) { ERR } stage -> vf_frame_allocated = true ; } } if ( vf_frame && binary && binary -> vf_frame_info . res . width && ! firmware ) { if ( vf_frame -> data != mmgr_NULL ) { stage -> vf_frame_allocated = true ; } } stage -> args . in_frame = stage_desc -> in_frame ; for ( i = 0 ; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS ; i ++ ) { stage -> args . out_frame [ i ] = out_frame [ i ] ; } stage -> args . out_vf_frame = vf_frame ; * new_stage = stage ; return err ; ERR if ( stage != NULL ) { pipeline_stage_destroy ( stage ) ; } return err ; } 