static void celt_decode_lost ( CELTDecoder * OPUS_RESTRICT st , int N , int LM ) { int c ; int i ; const int C = st -> channels ; celt_sig * decode_mem [ 2 ] ; celt_sig * out_syn [ 2 ] ; opus_val16 * lpc ; opus_val16 * oldBandE , * oldLogE , * oldLogE2 , * backgroundLogE ; const OpusCustomMode * mode ; int nbEBands ; int overlap ; int start ; int loss_count ; int noise_based ; const opus_int16 * eBands ; SAVE_STACK ; mode = st -> mode ; nbEBands = mode -> nbEBands ; overlap = mode -> overlap ; eBands = mode -> eBands ; c = 0 ; { decode_mem [ c ] = st -> _decode_mem + c * ( DECODE_BUFFER_SIZE + overlap ) ; out_syn [ c ] = decode_mem [ c ] + DECODE_BUFFER_SIZE - N ; } ++ c < C ; lpc = ( opus_val16 * ) ( st -> _decode_mem + ( DECODE_BUFFER_SIZE + overlap ) * C ) ; oldBandE = lpc + C * LPC_ORDER ; oldLogE = oldBandE + 2 * nbEBands ; oldLogE2 = oldLogE + 2 * nbEBands ; backgroundLogE = oldLogE2 + 2 * nbEBands ; loss_count = st -> loss_count ; start = st -> start ; noise_based = loss_count >= 5 || start != 0 || st -> skip_plc ; if ( noise_based ) { celt_norm * X ; VARDECL ( celt_norm , X ) ; opus_uint32 seed ; int end ; int effEnd ; opus_val16 decay ; end = st -> end ; effEnd = IMAX ( start , IMIN ( end , mode -> effEBands ) ) ; X = ( celt_norm * ) ( out_syn [ C - 1 ] + overlap / 2 ) ; ALLOC ( X , C * N , celt_norm ) ; decay = loss_count == 0 ?QCONST16 ( 1.5f , DB_SHIFT ) : QCONST16 ( .5f , DB_SHIFT ) ; c = 0 ; { for ( i = start ; i < end ; i ++ ) { oldBandE [ c * nbEBands + i ] = MAX16 ( backgroundLogE [ c * nbEBands + i ] , oldBandE [ c * nbEBands + i ] - decay ) ; } } ++ c < C ; seed = st -> rng ; for ( c = 0 ; c < C ; c ++ ) { for ( i = start ; i < effEnd ; i ++ ) { int j ; int boffs ; int blen ; boffs = N * c + ( eBands [ i ] << LM ) ; blen = ( eBands [ i + 1 ] - eBands [ i ] ) << LM ; for ( j = 0 ; j < blen ; j ++ ) { seed = celt_lcg_rand ( seed ) ; X [ boffs + j ] = ( celt_norm ) ( ( opus_int32 ) seed >> 20 ) ; } renormalise_vector ( X + boffs , blen , Q15ONE , st -> arch ) ; } } st -> rng = seed ; c = 0 ; { OPUS_MOVE ( decode_mem [ c ] , decode_mem [ c ] + N , DECODE_BUFFER_SIZE - N + ( overlap >> 1 ) ) ; } ++ c < C ; celt_synthesis ( mode , X , out_syn , oldBandE , start , effEnd , C , C , 0 , LM , st -> downsample , 0 , st -> arch ) ; } else { const opus_val16 * window ; opus_val16 * exc ; opus_val16 fade = Q15ONE ; int pitch_index ; VARDECL ( opus_val32 , etmp ) ; VARDECL ( opus_val16 , _exc ) ; if ( loss_count == 0 ) { st -> last_pitch_index = pitch_index = celt_plc_pitch_search ( decode_mem , C , st -> arch ) ; } else { pitch_index = st -> last_pitch_index ; fade = QCONST16 ( .8f , 15 ) ; } ALLOC ( etmp , overlap , opus_val32 ) ; ALLOC ( _exc , MAX_PERIOD + LPC_ORDER , opus_val16 ) ; exc = _exc + LPC_ORDER ; window = mode -> window ; c = 0 ; { opus_val16 decay ; opus_val16 attenuation ; opus_val32 S1 = 0 ; celt_sig * buf ; int extrapolation_offset ; int extrapolation_len ; int exc_length ; int j ; buf = decode_mem [ c ] ; for ( i = 0 ; i < MAX_PERIOD ; i ++ ) { exc [ i ] = ROUND16 ( buf [ DECODE_BUFFER_SIZE - MAX_PERIOD + i ] , SIG_SHIFT ) ; } if ( loss_count == 0 ) { opus_val32 ac [ LPC_ORDER + 1 ] ; _celt_autocorr ( exc , ac , window , overlap , LPC_ORDER , MAX_PERIOD , st -> arch ) ; ac [ 0 ] += SHR32 ( ac [ 0 ] , 13 ) ; ac [ 0 ] *= 1.0001f ; for ( i = 1 ; i <= LPC_ORDER ; i ++ ) { ac [ i ] -= MULT16_32_Q15 ( 2 * i * i , ac [ i ] ) ; ac [ i ] -= ac [ i ] * ( 0.008f * 0.008f ) * i * i ; } _celt_lpc ( lpc + c * LPC_ORDER , ac , LPC_ORDER ) ; while ( 1 ) { opus_val16 tmp = Q15ONE ; opus_val32 sum = QCONST16 ( 1. , SIG_SHIFT ) ; for ( i = 0 ; i < LPC_ORDER ; i ++ ) { sum += ABS16 ( lpc [ c * LPC_ORDER + i ] ) ; } if ( sum < 65535 ) { break ; } for ( i = 0 ; i < LPC_ORDER ; i ++ ) { tmp = MULT16_16_Q15 ( QCONST16 ( .99f , 15 ) , tmp ) ; lpc [ c * LPC_ORDER + i ] = MULT16_16_Q15 ( lpc [ c * LPC_ORDER + i ] , tmp ) ; } } } exc_length = IMIN ( 2 * pitch_index , MAX_PERIOD ) ; { for ( i = 0 ; i < LPC_ORDER ; i ++ ) { exc [ MAX_PERIOD - exc_length - LPC_ORDER + i ] = ROUND16 ( buf [ DECODE_BUFFER_SIZE - exc_length - LPC_ORDER + i ] , SIG_SHIFT ) ; } celt_fir ( exc + MAX_PERIOD - exc_length , lpc + c * LPC_ORDER , exc + MAX_PERIOD - exc_length , exc_length , LPC_ORDER , st -> arch ) ; } { opus_val32 E1 = 1 , E2 = 1 ; int decay_length ; int shift = IMAX ( 0 , 2 * celt_zlog2 ( celt_maxabs16 ( & exc [ MAX_PERIOD - exc_length ] , exc_length ) ) - 20 ) ; decay_length = exc_length >> 1 ; for ( i = 0 ; i < decay_length ; i ++ ) { opus_val16 e ; e = exc [ MAX_PERIOD - decay_length + i ] ; E1 += SHR32 ( MULT16_16 ( e , e ) , shift ) ; e = exc [ MAX_PERIOD - 2 * decay_length + i ] ; E2 += SHR32 ( MULT16_16 ( e , e ) , shift ) ; } E1 = MIN32 ( E1 , E2 ) ; decay = celt_sqrt ( frac_div32 ( SHR32 ( E1 , 1 ) , E2 ) ) ; } OPUS_MOVE ( buf , buf + N , DECODE_BUFFER_SIZE - N ) ; extrapolation_offset = MAX_PERIOD - pitch_index ; extrapolation_len = N + overlap ; attenuation = MULT16_16_Q15 ( fade , decay ) ; for ( i = j = 0 ; i < extrapolation_len ; i ++ , j ++ ) { opus_val16 tmp ; buf [ DECODE_BUFFER_SIZE - N + i ] = SHL32 ( EXTEND32 ( MULT16_16_Q15 ( attenuation , exc [ extrapolation_offset + j ] ) ) , SIG_SHIFT ) ; tmp = ROUND16 ( buf [ DECODE_BUFFER_SIZE - MAX_PERIOD - N + extrapolation_offset + j ] , SIG_SHIFT ) ; S1 += SHR32 ( MULT16_16 ( tmp , tmp ) , 10 ) ; } { opus_val16 lpc_mem [ LPC_ORDER ] ; for ( i = 0 ; i < LPC_ORDER ; i ++ ) { lpc_mem [ i ] = ROUND16 ( buf [ DECODE_BUFFER_SIZE - N - 1 - i ] , SIG_SHIFT ) ; } celt_iir ( buf + DECODE_BUFFER_SIZE - N , lpc + c * LPC_ORDER , buf + DECODE_BUFFER_SIZE - N , extrapolation_len , LPC_ORDER , lpc_mem , st -> arch ) ; for ( i = 0 ; i < extrapolation_len ; i ++ ) { buf [ DECODE_BUFFER_SIZE - N + i ] = SATURATE ( buf [ DECODE_BUFFER_SIZE - N + i ] , SIG_SAT ) ; } } { opus_val32 S2 = 0 ; for ( i = 0 ; i < extrapolation_len ; i ++ ) { opus_val16 tmp = ROUND16 ( buf [ DECODE_BUFFER_SIZE - N + i ] , SIG_SHIFT ) ; S2 += SHR32 ( MULT16_16 ( tmp , tmp ) , 10 ) ; } if ( ! ( S1 > SHR32 ( S2 , 2 ) ) ) { if ( ! ( S1 > 0.2f * S2 ) ) { for ( i = 0 ; i < extrapolation_len ; i ++ ) { buf [ DECODE_BUFFER_SIZE - N + i ] = 0 ; } } if ( S1 < S2 ) { opus_val16 ratio = celt_sqrt ( frac_div32 ( SHR32 ( S1 , 1 ) + 1 , S2 + 1 ) ) ; for ( i = 0 ; i < overlap ; i ++ ) { opus_val16 tmp_g = Q15ONE - MULT16_16_Q15 ( window [ i ] , Q15ONE - ratio ) ; buf [ DECODE_BUFFER_SIZE - N + i ] = MULT16_32_Q15 ( tmp_g , buf [ DECODE_BUFFER_SIZE - N + i ] ) ; } for ( i = overlap ; i < extrapolation_len ; i ++ ) { buf [ DECODE_BUFFER_SIZE - N + i ] = MULT16_32_Q15 ( ratio , buf [ DECODE_BUFFER_SIZE - N + i ] ) ; } } } } comb_filter ( etmp , buf + DECODE_BUFFER_SIZE , st -> postfilter_period , st -> postfilter_period , overlap , - st -> postfilter_gain , - st -> postfilter_gain , st -> postfilter_tapset , st -> postfilter_tapset , NULL , 0 , st -> arch ) ; for ( i = 0 ; i < overlap / 2 ; i ++ ) { buf [ DECODE_BUFFER_SIZE + i ] = MULT16_32_Q15 ( window [ i ] , etmp [ overlap - 1 - i ] ) + MULT16_32_Q15 ( window [ overlap - i - 1 ] , etmp [ i ] ) ; } } ++ c < C ; } st -> loss_count = loss_count + 1 ; RESTORE_STACK ; } 