static int jz4725b_correct ( struct ingenic_ecc * bch , struct ingenic_ecc_params * params , u8 * buf , u8 * ecc_code ) { u32 reg , errors , bit ; unsigned int i ; int ret ; mutex_lock ( & bch -> lock ) ; ret = jz4725b_bch_reset ( bch , params , false ) ; if ( ret ) { dev_err ( bch -> dev , "Unable to init BCH with given parameters\n" ) ; out } jz4725b_bch_write_data ( bch , ecc_code , params -> bytes ) ; ret = jz4725b_bch_wait_complete ( bch , BCH_BHINT_DECF , & reg ) ; if ( ret ) { dev_err ( bch -> dev , "timed out while correcting data\n" ) ; out } if ( reg & ( BCH_BHINT_ALL_F | BCH_BHINT_ALL_0 ) ) { ret = 0 ; out } if ( reg & BCH_BHINT_UNCOR ) { ret = - EBADMSG ; out } errors = ( reg & BCH_BHINT_ERRC_MASK ) >> BCH_BHINT_ERRC_SHIFT ; for ( i = 0 ; i < errors ; i ++ ) { if ( i & 1 ) { bit = ( reg & BCH_BHERR_INDEX1_MASK ) >> BCH_BHERR_INDEX1_SHIFT ; } else { reg = readl ( bch -> base + BCH_BHERR0 + ( i * 4 ) ) ; bit = ( reg & BCH_BHERR_INDEX0_MASK ) >> BCH_BHERR_INDEX0_SHIFT ; } buf [ ( bit >> 3 ) ] ^= BIT ( bit & 0x7 ) ; } out jz4725b_bch_disable ( bch ) ; mutex_unlock ( & bch -> lock ) ; return ret ; } 