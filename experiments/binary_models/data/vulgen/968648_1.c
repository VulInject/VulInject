cpu_t * mac_soft_ring_bind ( mac_soft_ring_t * ringp , processorid_t cpuid ) { cpu_t * cp ; boolean_t clear = B_FALSE ; ASSERT ( MUTEX_HELD ( & cpu_lock ) ) ; if ( mac_soft_ring_thread_bind == 0 ) { DTRACE_PROBE1 ( mac__soft__ring__no__cpu__bound , mac_soft_ring_t * , ringp ) ; return ( NULL ) ; } cp = cpu_get ( cpuid ) ; if ( cp == NULL || ! cpu_is_online ( cp ) ) { return ( NULL ) ; } mutex_enter ( & ringp -> s_ring_lock ) ; ringp -> s_ring_state |= S_RING_BOUND ; if ( ringp -> s_ring_cpuid != - 1 ) { clear = B_TRUE ; } ringp -> s_ring_cpuid = cpuid ; mutex_exit ( & ringp -> s_ring_lock ) ; DTRACE_PROBE2 ( mac__soft__ring__cpu__bound , mac_soft_ring_t * , ringp , processorid_t , cpuid ) ; thread_affinity_set ( ringp -> s_ring_worker , cpuid ) ; return ( cp ) ; } 