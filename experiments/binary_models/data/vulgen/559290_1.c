void dpm_resume ( pm_message_t state ) { struct device * dev ; ktime_t starttime = ktime_get ( ) ; trace_suspend_resume ( TPS ( "dpm_resume" ) , state . event , true ) ; might_sleep ( ) ; mutex_lock ( & dpm_list_mtx ) ; pm_transition = state ; list_for_each_entry ( , , ) dpm_async_fn ( dev , async_resume ) ; while ( ! list_empty ( & dpm_suspended_list ) ) { dev = to_device ( dpm_suspended_list . next ) ; get_device ( dev ) ; if ( ! is_async ( dev ) ) { int error ; mutex_unlock ( & dpm_list_mtx ) ; error = device_resume ( dev , state , false ) ; if ( error ) { suspend_stats . failed_resume ++ ; dpm_save_failed_step ( SUSPEND_RESUME ) ; dpm_save_failed_dev ( dev_name ( dev ) ) ; pm_dev_err ( dev , state , "" , error ) ; } mutex_lock ( & dpm_list_mtx ) ; } if ( ! list_empty ( & dev -> power . entry ) ) { list_move_tail ( & dev -> power . entry , & dpm_prepared_list ) ; } mutex_unlock ( & dpm_list_mtx ) ; put_device ( dev ) ; mutex_lock ( & dpm_list_mtx ) ; } mutex_unlock ( & dpm_list_mtx ) ; async_synchronize_full ( ) ; dpm_show_time ( starttime , state , 0 , NULL ) ; cpufreq_resume ( ) ; devfreq_resume ( ) ; trace_suspend_resume ( TPS ( "dpm_resume" ) , state . event , false ) ; } 