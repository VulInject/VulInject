static MagickBooleanType WriteSUNImage ( const ImageInfo * image_info , Image * image ) { _SUNInfo { unsigned int magic width height depth length type maptype maplength ; } SUNInfo const IndexPacket * indexes ; const PixelPacket * p ; MagickBooleanType status ; MagickOffsetType scene ; MagickSizeType number_pixels ; size_t number_scenes ; ssize_t i , x , y ; SUNInfo sun_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( IsEventLogging ( ) != MagickFalse ) { ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image -> filename ) ; } status = OpenBlob ( image_info , image , WriteBinaryBlobMode , & image -> exception ) ; if ( status == MagickFalse ) { return ( status ) ; } scene = 0 ; number_scenes = GetImageListLength ( image ) ; { if ( IssRGBCompatibleColorspace ( image -> colorspace ) == MagickFalse ) { ( void ) TransformImageColorspace ( image , sRGBColorspace ) ; } sun_info . magic = 0x59a66a95 ; if ( ( image -> columns != ( unsigned int ) image -> columns ) || ( image -> rows != ( unsigned int ) image -> rows ) ) { ThrowWriterException ( ImageError , "WidthOrHeightExceedsLimit" ) ; } sun_info . width = ( unsigned int ) image -> columns ; sun_info . height = ( unsigned int ) image -> rows ; sun_info . type = ( unsigned int ) ( image -> storage_class == DirectClass ?RT_FORMAT_RGB : RT_STANDARD ) ; sun_info . maptype = RMT_NONE ; sun_info . maplength = 0 ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( 4 * number_pixels ) != ( size_t ) ( 4 * number_pixels ) ) { ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } if ( image -> storage_class == DirectClass ) { sun_info . depth = ( unsigned int ) image -> matte ?32U : 24U ; sun_info . length = ( unsigned int ) ( ( image -> matte ?4 : 3 ) * number_pixels ) ; sun_info . length += sun_info . length & 0x01 ?( unsigned int ) image -> rows : 0 ; } if ( SetImageMonochrome ( image , & image -> exception ) ) { sun_info . depth = 1 ; sun_info . length = ( unsigned int ) ( ( ( image -> columns + 7 ) >> 3 ) * image -> rows ) ; sun_info . length += ( unsigned int ) ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ?1 : 0 ) ) % 2 ?image -> rows else 0 ) ; } else { sun_info . depth = 8 ; sun_info . length = ( unsigned int ) number_pixels ; sun_info . length += ( unsigned int ) ( image -> columns & 0x01 ?image -> rows : 0 ) ; sun_info . maptype = RMT_EQUAL_RGB ; sun_info . maplength = ( unsigned int ) ( 3 * image -> colors ) ; } ( void ) WriteBlobMSBLong ( image , sun_info . magic ) ; ( void ) WriteBlobMSBLong ( image , sun_info . width ) ; ( void ) WriteBlobMSBLong ( image , sun_info . height ) ; ( void ) WriteBlobMSBLong ( image , sun_info . depth ) ; ( void ) WriteBlobMSBLong ( image , sun_info . length ) ; ( void ) WriteBlobMSBLong ( image , sun_info . type ) ; ( void ) WriteBlobMSBLong ( image , sun_info . maptype ) ; ( void ) WriteBlobMSBLong ( image , sun_info . maplength ) ; x = 0 ; y = 0 ; if ( image -> storage_class == DirectClass ) { unsigned char * q ; size_t bytes_per_pixel , length ; unsigned char * pixels ; bytes_per_pixel = 3 ; if ( image -> matte != MagickFalse ) { bytes_per_pixel ++ ; } length = image -> columns ; pixels = ( unsigned char * ) AcquireQuantumMemory ( length , 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) { ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = GetVirtualPixels ( image , 0 , y , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) { break ; } q = pixels ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> matte != MagickFalse ) { * q ++ = ScaleQuantumToChar ( GetPixelAlpha ( p ) ) ; } * q ++ = ScaleQuantumToChar ( GetPixelRed ( p ) ) ; * q ++ = ScaleQuantumToChar ( GetPixelGreen ( p ) ) ; * q ++ = ScaleQuantumToChar ( GetPixelBlue ( p ) ) ; p ++ ; } if ( ( ( bytes_per_pixel * image -> columns ) & 0x01 ) != 0 ) { * q ++ = '\0' ; } ( void ) WriteBlob ( image , ( size_t ) ( q - pixels ) , pixels ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , SaveImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) { break ; } } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; } if ( SetImageMonochrome ( image , & image -> exception ) ) { unsigned char bit , byte ; ( void ) SetImageType ( image , BilevelType ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = GetVirtualPixels ( image , 0 , y , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) { break ; } indexes = GetVirtualIndexQueue ( image ) ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { byte <<= 1 ; if ( GetPixelLuma ( image , p ) < ( QuantumRange / 2.0 ) ) { byte |= 0x01 ; } bit ++ ; if ( bit == 8 ) { ( void ) WriteBlobByte ( image , byte ) ; bit = 0 ; byte = 0 ; } p ++ ; } if ( bit != 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) ( byte << ( 8 - bit ) ) ) ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ?1 : 0 ) ) % 2 ) != 0 ) { ( void ) WriteBlobByte ( image , 0 ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , SaveImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) { break ; } } } } else { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { ( void ) WriteBlobByte ( image , ScaleQuantumToChar ( image -> colormap [ i ] . red ) ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { ( void ) WriteBlobByte ( image , ScaleQuantumToChar ( image -> colormap [ i ] . green ) ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { ( void ) WriteBlobByte ( image , ScaleQuantumToChar ( image -> colormap [ i ] . blue ) ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = GetVirtualPixels ( image , 0 , y , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) { break ; } indexes = GetVirtualIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ( void ) WriteBlobByte ( image , ( unsigned char ) GetPixelIndex ( indexes + x ) ) ; p ++ ; } if ( image -> columns & 0x01 ) { ( void ) WriteBlobByte ( image , 0 ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , SaveImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) { break ; } } } } if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , SaveImagesTag , scene ++ , number_scenes ) ; } image_info -> adjoin != MagickFalse ; ( void ) CloseBlob ( image ) ; return ( MagickTrue ) ; } 