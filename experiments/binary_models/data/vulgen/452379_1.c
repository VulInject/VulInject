while ( 1 ) { if ( context ) { for ( ; ; ) { if ( ! fgets ( , , ) ) { DEBUG ( ) debug_printf_indent ( "MIME: Hit EOF ...\n" ) ; return rc ; } if ( Ustrncmp ( header , "--" , 2 ) == 0 && Ustrncmp ( header + 2 , context -> boundary , Ustrlen ( context -> boundary ) ) == 0 ) { if ( Ustrncmp ( ( header + 2 + Ustrlen ( context -> boundary ) ) , "--" , 2 ) == 0 ) { DEBUG ( ) debug_printf_indent ( "MIME: End boundary found %s\n" , context -> boundary ) ; return rc ; } DEBUG ( ) debug_printf_indent ( "MIME: Next part with boundary %s\n" , context -> boundary ) ; break ; } } } while ( mime_get_header ( f , header ) ) { for ( struct mime_header * mh mime_header_list ; ; mh < mime_header_list + mime_header_list_size ; mh ++ ) { if ( strncmpic ( mh -> name , header , mh -> namelen ) == 0 ) { uschar * p = header + mh -> namelen ; uschar * q ; for ( q = p ; * q != ';' && * q ; q ++ ) { } * mh -> value = string_copynlc ( p , q - p ) ; DEBUG ( ) debug_printf_indent ( "MIME: found %s header, value is '%s'\n" , mh -> name , * mh -> value ) ; if ( * ( p = q ) ) { p ++ ; } { uschar * mime_fname = NULL ; uschar * mime_fname_rfc2231 = NULL ; uschar * mime_filename_charset = NULL ; BOOL decoding_failed = FALSE ; while ( * p ) { DEBUG ( ) debug_printf_indent ( "MIME:   considering paramlist '%s'\n" , p ) ; if ( ! mime_filename && strncmpic ( CUS "content-disposition:" , header , 20 ) == 0 && strncmpic ( CUS "filename*" , p , 9 ) == 0 ) { uschar * q ; p += 9 ; while ( * p != '=' && * p ) { p ++ ; } if ( * p ) { p ++ ; } q = mime_param_val ( & p ) ; if ( q && * q ) { uschar * temp_string , * err_msg ; int slen ; mime_fname_rfc2231 = string_sprintf ( "%#s%s" , mime_fname_rfc2231 , q ) ; if ( ! decoding_failed ) { int size ; if ( ! mime_filename_charset ) { uschar * s = q ; while ( * s != '\'' && * s ) { s ++ ; } if ( ( size = s - q ) > 0 ) { mime_filename_charset = string_copyn ( q , size ) ; } if ( * ( p = s ) ) { p ++ ; } while ( * p == '\'' ) { p ++ ; } } else { p = q ; } DEBUG ( ) debug_printf_indent ( "MIME:    charset %s fname '%s'\n" , mime_filename_charset ?mime_filename_charset : US "<NULL>" , p ) ; temp_string = rfc2231_to_2047 ( p , mime_filename_charset , & slen ) ; DEBUG ( ) debug_printf_indent ( "MIME:    2047-name %s\n" , temp_string ) ; temp_string = rfc2047_decode ( temp_string , FALSE , NULL , ' ' , NULL , & err_msg ) ; DEBUG ( ) debug_printf_indent ( "MIME:    plain-name %s\n" , temp_string ) ; if ( ! temp_string || ( size = Ustrlen ( temp_string ) ) == slen ) { decoding_failed = TRUE ; } else { mime_filename = mime_fname = mime_fname ?string_sprintf ( "%s%s" , mime_fname , temp_string ) : temp_string ; } } } } else { for ( mime_parameter * mp = mime_parameter_list ; mp < mime_parameter_list + nelem ( mime_parameter_list ) ; mp ++ ) { if ( strncmpic ( mp -> name , p , mp -> namelen ) == 0 ) { uschar * q ; uschar * dummy_errstr ; p += mp -> namelen ; q = mime_param_val ( & p ) ; * mp -> value = q && * q ?rfc2047_decode ( q , check_rfc2047_length , NULL , 32 , NULL , & dummy_errstr ) : NULL ; DEBUG ( ) debug_printf_indent ( "MIME:  found %s parameter in %s header, value '%s'\n" , mp -> name , mh -> name , * mp -> value ) ; break ; } } } p = mime_next_semicolon ( p ) ; if ( * p ) { p ++ ; } } if ( strncmpic ( CUS "content-disposition:" , header , 20 ) == 0 ) { if ( decoding_failed ) { mime_filename = mime_fname_rfc2231 ; } DEBUG ( ) debug_printf_indent ( "MIME:  found %s parameter in %s header, value is '%s'\n" , "filename" , mh -> name , mime_filename ) ; } } } } } if ( mime_content_type && Ustrncmp ( mime_content_type , "multipart" , 9 ) == 0 ) { mime_is_multipart = 1 ; } nested_context . boundary = mime_boundary ; mime_part_count ++ ; mime_stream = f ; mime_current_boundary = context ?context -> boundary : 0 ; mime_is_coverletter = ! ( context && context -> context == MBC_ATTACHMENT ) ; rc = acl_check ( ACL_WHERE_MIME , NULL , acl , user_msgptr , log_msgptr ) ; mime_stream = NULL ; mime_current_boundary = NULL ; if ( rc != OK ) { break ; } if ( mime_content_type && nested_context . boundary && Ustrncmp ( mime_content_type , "multipart" , 9 ) == 0 ) { DEBUG ( ) debug_printf_indent ( "MIME: Entering multipart recursion, boundary '%s'\n" , nested_context . boundary ) ; nested_context . context = context && context -> context == MBC_ATTACHMENT ?MBC_ATTACHMENT : Ustrcmp ( mime_content_type , "multipart/alternative" ) == 0 || Ustrcmp ( mime_content_type , "multipart/related" ) == 0 ?MBC_COVERLETTER_ALL : MBC_COVERLETTER_ONESHOT ; rc = mime_acl_check ( acl , f , & nested_context , user_msgptr , log_msgptr ) ; if ( rc != OK ) { break ; } } if ( mime_content_type && Ustrncmp ( mime_content_type , "message/rfc822" , 14 ) == 0 ) { const uschar * rfc822name = NULL ; uschar * filename ; int file_nr = 0 ; int result = 0 ; for ( gstring * g = string_get ( 64 ) ; result != - 1 ; gstring_reset ( g ) ) { struct stat mystat ; g = string_fmt_append ( g , "%s/scan/%s/__rfc822_%05u" , spool_directory , message_id , file_nr ++ ) ; if ( file_nr >= 128 ) { NO_RFC822 } result = stat ( CS ( filename = string_from_gstring ( g ) ) , & mystat ) ; } rfc822name = filename ; mime_decoded_filename = NULL ; mime_stream = f ; mime_current_boundary = context ?context -> boundary : NULL ; mime_decode ( & rfc822name ) ; mime_stream = NULL ; mime_current_boundary = NULL ; if ( ! mime_decoded_filename ) { log_write ( 0 , LOG_MAIN , "MIME acl condition warning - could not decode RFC822 MIME part to file." ) ; rc = DEFER ; out } mime_decoded_filename = NULL ; } NO_RFC822 if ( ! context ) { break ; } if ( context -> context == MBC_COVERLETTER_ONESHOT ) { context -> context = MBC_ATTACHMENT ; } } out mime_vars_reset ( ) ; return rc ; 