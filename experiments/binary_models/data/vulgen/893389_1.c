static void hubd_reset_thread ( void * arg ) { hubd_reset_arg_t * hd_arg = ( hubd_reset_arg_t * ) arg ; hubd_t * hubd = hd_arg -> hubd ; uint16_t reset_port = hd_arg -> reset_port ; uint16_t status , change ; hub_power_t * hubpm ; dev_info_t * hdip = hubd -> h_dip ; dev_info_t * rh_dip = hubd -> h_usba_device -> usb_root_hub_dip ; dev_info_t * child_dip ; boolean_t online_child = B_FALSE ; int prh_circ , rh_circ , circ , devinst ; char * devname ; int i = 0 ; int rval = USB_FAILURE ; USB_DPRINTF_L4 ( DPRINT_MASK_HOTPLUG , hubd -> h_log_handle , "hubd_reset_thread:  started, hubd_reset_port = 0x%x" , reset_port ) ; mutex_enter ( HUBD_MUTEX ( hubd ) ) ; child_dip = hubd -> h_children_dips [ reset_port ] ; ASSERT ( child_dip != NULL ) ; devname = ( char * ) ddi_driver_name ( child_dip ) ; devinst = ddi_get_instance ( child_dip ) ; if ( hubd -> h_bus_pwr ) { USB_DPRINTF_L0 ( DPRINT_MASK_HOTPLUG , hubd -> h_log_handle , "%s%d is under bus power management, cannot be reset. " "Please disconnect and reconnect this device." , devname , devinst ) ; Fail } if ( hubd_wait_for_hotplug_exit ( hubd ) == USB_FAILURE ) { USB_DPRINTF_L0 ( DPRINT_MASK_HOTPLUG , hubd -> h_log_handle , "Time out when resetting the device" " %s%d. Please disconnect and reconnect this device." , devname , devinst ) ; Fail } hubd -> h_hotplug_thread ++ ; if ( ( hdip == rh_dip ) && ( hubd -> h_dev_state == USB_DEV_PWRED_DOWN ) ) { hubpm = hubd -> h_hubpm ; hubpm -> hubp_current_power = USB_DEV_OS_FULL_PWR ; hubpm -> hubp_time_at_full_power = gethrtime ( ) ; mutex_exit ( HUBD_MUTEX ( hubd ) ) ; USB_DPRINTF_L3 ( DPRINT_MASK_HOTPLUG , hubd -> h_log_handle , "hubd_reset_thread: call pm_power_has_changed" ) ; ( void ) pm_power_has_changed ( hdip , 0 , USB_DEV_OS_FULL_PWR ) ; mutex_enter ( HUBD_MUTEX ( hubd ) ) ; hubd -> h_dev_state = USB_DEV_ONLINE ; } mutex_exit ( HUBD_MUTEX ( hubd ) ) ; ndi_devi_enter ( ddi_get_parent ( rh_dip ) , & prh_circ ) ; ndi_devi_enter ( rh_dip , & rh_circ ) ; ndi_devi_enter ( hdip , & circ ) ; mutex_enter ( HUBD_MUTEX ( hubd ) ) ; if ( hubd -> h_children_dips [ reset_port ] ) { mutex_exit ( HUBD_MUTEX ( hubd ) ) ; hubd_post_event ( hubd , reset_port , USBA_EVENT_TAG_HOT_REMOVAL ) ; ndi_devi_exit ( hdip , circ ) ; ndi_devi_exit ( rh_dip , rh_circ ) ; ndi_devi_exit ( ddi_get_parent ( rh_dip ) , prh_circ ) ; ( void ) devfs_clean ( rh_dip , NULL , DV_CLEAN_FORCE ) ; if ( ( strcmp ( devname , "scsa2usb" ) == 0 ) && DEVI ( child_dip ) -> devi_ref != 0 ) { while ( i ++ < hubdi_reset_delay ) { mutex_enter ( HUBD_MUTEX ( hubd ) ) ; rval = hubd_delete_child ( hubd , reset_port , NDI_DEVI_REMOVE , B_FALSE ) ; mutex_exit ( HUBD_MUTEX ( hubd ) ) ; if ( rval == USB_SUCCESS ) { break ; } delay ( drv_usectohz ( 1000000 ) ) ; } } ndi_devi_enter ( ddi_get_parent ( rh_dip ) , & prh_circ ) ; ndi_devi_enter ( rh_dip , & rh_circ ) ; ndi_devi_enter ( hdip , & circ ) ; mutex_enter ( HUBD_MUTEX ( hubd ) ) ; if ( ( rval != USB_SUCCESS ) && ( hubd_delete_child ( hubd , reset_port , NDI_DEVI_REMOVE , B_FALSE ) != USB_SUCCESS ) ) { USB_DPRINTF_L0 ( DPRINT_MASK_HOTPLUG , hubd -> h_log_handle , "%s%d cannot be reset due to other applications " "are using it, please first close these " "applications, then disconnect and reconnect" "the device." , devname , devinst ) ; mutex_exit ( HUBD_MUTEX ( hubd ) ) ; hubd_post_event ( hubd , reset_port , USBA_EVENT_TAG_HOT_INSERTION ) ; mutex_enter ( HUBD_MUTEX ( hubd ) ) ; } else { ( void ) hubd_determine_port_status ( hubd , reset_port , & status , & change , NULL , HUBD_ACK_ALL_CHANGES ) ; if ( status & PORT_STATUS_CCS ) { online_child |= ( hubd_handle_port_connect ( hubd , reset_port ) == USB_SUCCESS ) ; } } } mutex_exit ( HUBD_MUTEX ( hubd ) ) ; ndi_devi_exit ( hdip , circ ) ; ndi_devi_exit ( rh_dip , rh_circ ) ; ndi_devi_exit ( ddi_get_parent ( rh_dip ) , prh_circ ) ; ( void ) devfs_clean ( rh_dip , NULL , 0 ) ; if ( online_child ) { USB_DPRINTF_L3 ( DPRINT_MASK_HOTPLUG , hubd -> h_log_handle , "hubd_reset_thread: onlining children" ) ; ( void ) ndi_devi_online ( hubd -> h_dip , 0 ) ; } mutex_enter ( HUBD_MUTEX ( hubd ) ) ; hubd -> h_hotplug_thread -- ; Fail hubd_start_polling ( hubd , 0 ) ; ( void ) hubd_pm_idle_component ( hubd , hubd -> h_dip , 0 ) ; USB_DPRINTF_L4 ( DPRINT_MASK_HOTPLUG , hubd -> h_log_handle , "hubd_reset_thread: exit, %d" , hubd -> h_hotplug_thread ) ; hubd -> h_reset_port [ reset_port ] = B_FALSE ; mutex_exit ( HUBD_MUTEX ( hubd ) ) ; ndi_rele_devi ( hdip ) ; } 