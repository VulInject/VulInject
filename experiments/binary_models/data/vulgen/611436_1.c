static enum htc_send_queue_result htc_try_send ( struct htc_target * target , struct htc_endpoint * ep , struct list_head * txq ) { struct list_head send_queue ; struct htc_packet * packet , * tmp_pkt ; struct ath6kl * ar = target -> dev -> ar ; enum htc_send_full_action action ; int tx_resources , overflow , txqueue_depth , i , good_pkts ; u8 pipeid ; ath6kl_dbg ( ATH6KL_DBG_HTC , "%s: (queue:0x%p depth:%d)\n" , __func__ , txq , ( txq == NULL ) ?0 : get_queue_depth ( txq ) ) ; INIT_LIST_HEAD ( & send_queue ) ; if ( txq != NULL ) { if ( list_empty ( txq ) ) { return HTC_SEND_QUEUE_DROP ; } spin_lock_bh ( & target -> tx_lock ) ; txqueue_depth = get_queue_depth ( & ep -> txq ) ; spin_unlock_bh ( & target -> tx_lock ) ; if ( txqueue_depth >= ep -> max_txq_depth ) { overflow = get_queue_depth ( txq ) ; } else { overflow = txqueue_depth ; overflow += get_queue_depth ( txq ) ; overflow -= ep -> max_txq_depth ; } if ( overflow > 0 ) { ath6kl_dbg ( ATH6KL_DBG_HTC , "%s: Endpoint %d, TX queue will overflow :%d, Tx Depth:%d, Max:%d\n" , __func__ , ep -> eid , overflow , txqueue_depth , ep -> max_txq_depth ) ; } if ( ( overflow <= 0 ) || ( ep -> ep_cb . tx_full == NULL ) ) { list_splice_tail_init ( txq , & send_queue ) ; } else { good_pkts = get_queue_depth ( txq ) - overflow ; if ( good_pkts < 0 ) { return HTC_SEND_QUEUE_DROP ; } for ( i = 0 ; i < good_pkts ; i ++ ) { packet = list_first_entry ( txq , htc_packet , list ) ; list_move_tail ( & packet -> list , & send_queue ) ; } list_for_each_entry_safe ( , , , ) { ath6kl_dbg ( ATH6KL_DBG_HTC , "%s: Indicate overflowed TX pkts: %p\n" , __func__ , packet ) ; action = ep -> ep_cb . tx_full ( ep -> target , packet ) ; if ( action == HTC_SEND_FULL_DROP ) { ep -> ep_st . tx_dropped += 1 ; } else { list_move_tail ( & packet -> list , & send_queue ) ; } } if ( list_empty ( & send_queue ) ) { return HTC_SEND_QUEUE_DROP ; } } } if ( ! ep -> pipe . tx_credit_flow_enabled ) { tx_resources = ath6kl_hif_pipe_get_free_queue_number ( ar , ep -> pipe . pipeid_ul ) ; } else { tx_resources = 0 ; } spin_lock_bh ( & target -> tx_lock ) ; if ( ! list_empty ( & send_queue ) ) { list_splice_tail_init ( & send_queue , & ep -> txq ) ; if ( ! list_empty ( & send_queue ) ) { WARN_ON_ONCE ( 1 ) ; spin_unlock_bh ( & target -> tx_lock ) ; return HTC_SEND_QUEUE_DROP ; } INIT_LIST_HEAD ( & send_queue ) ; } ep -> tx_proc_cnt ++ ; if ( ep -> tx_proc_cnt > 1 ) { ep -> tx_proc_cnt -- ; spin_unlock_bh ( & target -> tx_lock ) ; return HTC_SEND_QUEUE_OK ; } while ( true ) { if ( get_queue_depth ( & ep -> txq ) == 0 ) { break ; } if ( ep -> pipe . tx_credit_flow_enabled ) { get_htc_packet_credit_based ( target , ep , & send_queue ) ; } else { get_htc_packet ( target , ep , & send_queue , tx_resources ) ; } if ( get_queue_depth ( & send_queue ) == 0 ) { break ; } spin_unlock_bh ( & target -> tx_lock ) ; htc_issue_packets ( target , ep , & send_queue ) ; if ( ! ep -> pipe . tx_credit_flow_enabled ) { pipeid = ep -> pipe . pipeid_ul ; tx_resources = ath6kl_hif_pipe_get_free_queue_number ( ar , pipeid ) ; } spin_lock_bh ( & target -> tx_lock ) ; } ep -> tx_proc_cnt = 0 ; spin_unlock_bh ( & target -> tx_lock ) ; return HTC_SEND_QUEUE_OK ; } 