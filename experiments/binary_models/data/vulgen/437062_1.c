enum vxge_hw_status vxge_hw_vpath_rts_rth_itable_set ( struct __vxge_hw_vpath_handle * * vpath_handles , u32 vpath_count , u8 * mtable , u8 * itable , u32 itable_size ) { u32 i , j , action , rts_table ; u64 data0 ; u64 data1 ; u32 max_entries ; enum vxge_hw_status status = VXGE_HW_OK ; struct __vxge_hw_vpath_handle * vp = vpath_handles [ 0 ] ; if ( vp == NULL ) { status = VXGE_HW_ERR_INVALID_HANDLE ; exit } max_entries = ( ( ( u32 ) 1 ) << itable_size ) ; if ( vp -> vpath -> hldev -> config . rth_it_type == VXGE_HW_RTH_IT_TYPE_SOLO_IT ) { action = VXGE_HW_RTS_ACCESS_STEER_CTRL_ACTION_WRITE_ENTRY ; rts_table = VXGE_HW_RTS_ACS_STEER_CTRL_DATA_STRUCT_SEL_RTH_SOLO_IT ; for ( j = 0 ; j < max_entries ; j ++ ) { data1 = 0 ; data0 = VXGE_HW_RTS_ACCESS_STEER_DATA0_RTH_SOLO_IT_BUCKET_DATA ( itable [ j ] ) ; status = __vxge_hw_vpath_rts_table_set ( vpath_handles [ 0 ] , action , rts_table , j , data0 , data1 ) ; if ( status != VXGE_HW_OK ) { exit } } for ( j = 0 ; j < max_entries ; j ++ ) { data1 = 0 ; data0 = VXGE_HW_RTS_ACCESS_STEER_DATA0_RTH_SOLO_IT_ENTRY_EN | VXGE_HW_RTS_ACCESS_STEER_DATA0_RTH_SOLO_IT_BUCKET_DATA ( itable [ j ] ) ; status = __vxge_hw_vpath_rts_table_set ( vpath_handles [ mtable [ itable [ j ] ] ] , action , rts_table , j , data0 , data1 ) ; if ( status != VXGE_HW_OK ) { exit } } } else { action = VXGE_HW_RTS_ACCESS_STEER_CTRL_ACTION_WRITE_ENTRY ; rts_table = VXGE_HW_RTS_ACS_STEER_CTRL_DATA_STRUCT_SEL_RTH_MULTI_IT ; for ( i = 0 ; i < vpath_count ; i ++ ) { for ( j = 0 ; j < max_entries ; ) { data0 = 0 ; data1 = 0 ; while ( j < max_entries ) { if ( mtable [ itable [ j ] ] != i ) { j ++ ; continue ; } vxge_hw_rts_rth_data0_data1_get ( j , & data0 , & data1 , 1 , itable ) ; j ++ ; break ; } while ( j < max_entries ) { if ( mtable [ itable [ j ] ] != i ) { j ++ ; continue ; } vxge_hw_rts_rth_data0_data1_get ( j , & data0 , & data1 , 2 , itable ) ; j ++ ; break ; } while ( j < max_entries ) { if ( mtable [ itable [ j ] ] != i ) { j ++ ; continue ; } vxge_hw_rts_rth_data0_data1_get ( j , & data0 , & data1 , 3 , itable ) ; j ++ ; break ; } while ( j < max_entries ) { if ( mtable [ itable [ j ] ] != i ) { j ++ ; continue ; } vxge_hw_rts_rth_data0_data1_get ( j , & data0 , & data1 , 4 , itable ) ; j ++ ; break ; } if ( data0 != 0 ) { status = __vxge_hw_vpath_rts_table_set ( vpath_handles [ i ] , action , rts_table , 0 , data0 , data1 ) ; } } } } exit return status ; } 