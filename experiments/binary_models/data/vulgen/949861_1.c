void test_circuitpadding_negotiation ( void * arg ) { int64_t actual_mocked_monotime_start ; ( void ) arg ; MOCK ( circuitmux_attach_circuit , circuitmux_attach_circuit_mock ) ; client_side = TO_CIRCUIT ( origin_circuit_new ( ) ) ; dummy_channel . cmux = circuitmux_alloc ( ) ; relay_side = TO_CIRCUIT ( new_fake_orcirc ( & dummy_channel , & dummy_channel ) ) ; relay_side -> purpose = CIRCUIT_PURPOSE_OR ; client_side -> purpose = CIRCUIT_PURPOSE_C_GENERAL ; nodes_init ( ) ; monotime_init ( ) ; monotime_enable_test_mocking ( ) ; actual_mocked_monotime_start = MONOTIME_MOCK_START ; monotime_set_mock_time_nsec ( actual_mocked_monotime_start ) ; monotime_coarse_set_mock_time_nsec ( actual_mocked_monotime_start ) ; curr_mocked_time = actual_mocked_monotime_start ; timers_initialize ( ) ; circpad_machines_init ( ) ; MOCK ( node_get_by_id , node_get_by_id_mock ) ; MOCK ( circuit_package_relay_cell , circuit_package_relay_cell_mock ) ; simulate_single_hop_extend ( client_side , relay_side , 1 ) ; simulate_single_hop_extend ( client_side , relay_side , 1 ) ; tt_ptr_op ( relay_side -> padding_machine [ 0 ] , OP_NE , NULL ) ; tt_ptr_op ( relay_side -> padding_info [ 0 ] , OP_NE , NULL ) ; tt_int_op ( n_relay_cells , OP_EQ , 1 ) ; tt_int_op ( n_client_cells , OP_EQ , 1 ) ; simulate_single_hop_extend ( client_side , relay_side , 1 ) ; free_fake_orcirc ( TO_OR_CIRCUIT ( relay_side ) ) ; client_side = TO_CIRCUIT ( origin_circuit_new ( ) ) ; relay_side = TO_CIRCUIT ( new_fake_orcirc ( & dummy_channel , & dummy_channel ) ) ; relay_side -> purpose = CIRCUIT_PURPOSE_OR ; client_side -> purpose = CIRCUIT_PURPOSE_C_GENERAL ; simulate_single_hop_extend ( client_side , relay_side , 1 ) ; simulate_single_hop_extend ( client_side , relay_side , 0 ) ; tt_ptr_op ( client_side -> padding_machine [ 0 ] , OP_EQ , NULL ) ; tt_ptr_op ( relay_side -> padding_machine [ 0 ] , OP_EQ , NULL ) ; tt_int_op ( n_relay_cells , OP_EQ , 1 ) ; tt_int_op ( n_client_cells , OP_EQ , 1 ) ; tt_int_op ( n_relay_cells , OP_EQ , 1 ) ; tt_int_op ( n_client_cells , OP_EQ , 1 ) ; simulate_single_hop_extend ( client_side , relay_side , 1 ) ; circpad_negotiate_padding ( TO_ORIGIN_CIRCUIT ( client_side ) , CIRCPAD_MACHINE_CIRC_SETUP , 2 , CIRCPAD_COMMAND_START , 0 ) ; tt_ptr_op ( relay_side -> padding_machine [ 0 ] , OP_EQ , NULL ) ; tt_ptr_op ( client_side -> padding_machine [ 0 ] , OP_EQ , NULL ) ; tt_int_op ( n_relay_cells , OP_EQ , 1 ) ; tt_int_op ( n_client_cells , OP_EQ , 1 ) ; free_fake_origin_circuit ( TO_ORIGIN_CIRCUIT ( client_side ) ) ; free_fake_orcirc ( TO_OR_CIRCUIT ( relay_side ) ) ; client_side = TO_CIRCUIT ( origin_circuit_new ( ) ) ; relay_side = TO_CIRCUIT ( new_fake_orcirc ( & dummy_channel , & dummy_channel ) ) ; relay_side -> purpose = CIRCUIT_PURPOSE_OR ; client_side -> purpose = CIRCUIT_PURPOSE_C_GENERAL ; SMARTLIST_FOREACH ( , , , ) smartlist_free ( relay_padding_machines ) ; relay_padding_machines = smartlist_new ( ) ; simulate_single_hop_extend ( client_side , relay_side , 1 ) ; simulate_single_hop_extend ( client_side , relay_side , 1 ) ; tt_int_op ( n_client_cells , OP_EQ , 2 ) ; tt_int_op ( n_relay_cells , OP_EQ , 2 ) ; tt_ptr_op ( client_side -> padding_info [ 0 ] , OP_EQ , NULL ) ; tt_ptr_op ( client_side -> padding_machine [ 0 ] , OP_EQ , NULL ) ; tt_ptr_op ( relay_side -> padding_machine [ 0 ] , OP_EQ , NULL ) ; tt_ptr_op ( relay_side -> padding_info [ 0 ] , OP_EQ , NULL ) ; done free_fake_origin_circuit ( TO_ORIGIN_CIRCUIT ( client_side ) ) ; free_fake_orcirc ( TO_OR_CIRCUIT ( relay_side ) ) ; circuitmux_detach_all_circuits ( dummy_channel . cmux , NULL ) ; circuitmux_free ( dummy_channel . cmux ) ; monotime_disable_test_mocking ( ) ; UNMOCK ( node_get_by_id ) ; UNMOCK ( circuit_package_relay_cell ) ; UNMOCK ( circuitmux_attach_circuit ) ; nodes_free ( ) ; } 