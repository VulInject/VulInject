static int smbfs_setattr ( vnode_t * vp , struct vattr * vap , int flags , cred_t * cr , caller_context_t * ct ) { vfs_t * vfsp ; smbmntinfo_t * smi ; int error ; uint_t mask ; struct vattr oldva ; vfsp = vp -> v_vfsp ; smi = VFTOSMI ( vfsp ) ; if ( curproc -> p_zone != smi -> smi_zone_ref . zref_zone ) { return ( EIO ) ; } if ( smi -> smi_flags & SMI_DEAD || vfsp -> vfs_flag & VFS_UNMOUNTED ) { return ( EIO ) ; } mask = vap -> va_mask ; if ( mask & AT_NOSET ) { return ( EINVAL ) ; } if ( vfsp -> vfs_flag & VFS_RDONLY ) { return ( EROFS ) ; } oldva . va_mask = AT_TYPE | AT_MODE ; error = smbfsgetattr ( vp , & oldva , cr ) ; if ( error ) { return ( error ) ; } oldva . va_mask |= AT_UID | AT_GID ; oldva . va_uid = smi -> smi_uid ; oldva . va_gid = smi -> smi_gid ; error = secpolicy_vnode_setattr ( cr , vp , vap , & oldva , flags , smbfs_accessx , vp ) ; if ( error ) { return ( error ) ; } if ( mask & ( AT_UID | AT_GID ) ) { if ( smi -> smi_flags & SMI_ACL ) { error = smbfs_acl_setids ( vp , vap , cr ) ; } else { error = ENOSYS ; } if ( error != 0 ) { SMBVDEBUG ( "error %d seting UID/GID on %s" , error , VTOSMB ( vp ) -> n_rpath ) ; } } error = smbfssetattr ( vp , vap , flags , cr ) ; if ( error == 0 && ( vap -> va_mask & AT_SIZE ) && vap -> va_size == 0 ) { vnevent_truncate ( vp , ct ) ; } return ( error ) ; } 