os_region_check ( , , , ) { if ( ( region -> current < region -> origin || ( region -> current - region -> origin > region -> length ) ) && ( ( region -> current != region -> origin + region -> length ) || base == 0 ) ) { if ( tree != NULL ) { einfo ( _ ( "%X%P: address 0x%v of %B section %s is not within region %s\n" ) , region -> current , os -> bfd_section -> owner , os -> bfd_section -> name , region -> name ) ; } else { einfo ( _ ( "%X%P: region %s is full (%B section %s)\n" ) , region -> name , os -> bfd_section -> owner , os -> bfd_section -> name ) ; } region -> current = region -> origin ; } } static bfd_vma lang_size_sections_1 ( lang_statement_union_type * s , lang_output_section_statement_type * output_section_statement , lang_statement_union_type * * prev , fill_type * fill , bfd_vma dot , bfd_boolean * relax , bfd_boolean check_regions ) { for ( ; s != NULL ; s = s -> header . next ) { switch ( s -> header . type ) { case lang_output_section_statement_enum : { bfd_vma after ; lang_output_section_statement_type * os ; os = & s -> output_section_statement ; if ( os -> bfd_section == NULL ) { break ; } if ( ( os -> bfd_section -> flags & SEC_COFF_SHARED_LIBRARY ) != 0 ) { asection * input ; if ( os -> children . head == NULL || os -> children . head -> header . next != NULL || os -> children . head -> header . type != lang_input_section_enum ) { einfo ( _ ( "%P%X: Internal error on COFF shared library section %s\n" ) , os -> name ) ; } input = os -> children . head -> input_section . section ; bfd_set_section_vma ( os -> bfd_section -> owner , os -> bfd_section , bfd_section_vma ( input -> owner , input ) ) ; os -> bfd_section -> _raw_size = input -> _raw_size ; break ; } if ( bfd_is_abs_section ( os -> bfd_section ) ) { ASSERT ( os -> bfd_section -> vma == 0 ) ; } else { if ( os -> addr_tree == NULL ) { if ( os -> region == NULL || ( ( ( bfd_get_section_flags ( output_bfd , os -> bfd_section ) & ( SEC_ALLOC | SEC_LOAD ) ) != 0 ) && os -> region -> name [ 0 ] == '*' && strcmp ( os -> region -> name , DEFAULT_MEMORY_REGION ) == 0 ) ) { os -> region = lang_memory_default ( os -> bfd_section ) ; } if ( ! IGNORE_SECTION ( output_bfd , os -> bfd_section ) && ! link_info . relocatable && check_regions && strcmp ( os -> region -> name , DEFAULT_MEMORY_REGION ) == 0 && lang_memory_region_list != NULL && ( strcmp ( lang_memory_region_list -> name , DEFAULT_MEMORY_REGION ) != 0 || lang_memory_region_list -> next != NULL ) ) { if ( command_line . check_section_addresses ) { einfo ( _ ( "%P%F: error: no memory region specified for loadable section `%s'\n" ) , bfd_get_section_name ( output_bfd , os -> bfd_section ) ) ; } else { einfo ( _ ( "%P: warning: no memory region specified for loadable section `%s'\n" ) , bfd_get_section_name ( output_bfd , os -> bfd_section ) ) ; } } dot = os -> region -> current ; if ( os -> section_alignment == - 1 ) { bfd_vma olddot ; olddot = dot ; dot = align_power ( dot , os -> bfd_section -> alignment_power ) ; if ( dot != olddot && config . warn_section_align ) { einfo ( _ ( "%P: warning: changing start of section %s by %u bytes\n" ) , os -> name , ( unsigned int ) ( dot - olddot ) ) ; } } } else { etree_value_type r ; os -> processed = - 1 ; r = exp_fold_tree ( os -> addr_tree , abs_output_section , lang_allocating_phase_enum , dot , & dot ) ; os -> processed = 0 ; if ( ! r . valid_p ) { einfo ( _ ( "%F%S: non constant or forward reference address expression for section %s\n" ) , os -> name ) ; } dot = r . value + r . section -> bfd_section -> vma ; } if ( os -> section_alignment != - 1 ) { dot = align_power ( dot , os -> section_alignment ) ; } bfd_set_section_vma ( 0 , os -> bfd_section , dot ) ; os -> bfd_section -> output_offset = 0 ; } lang_size_sections_1 ( os -> children . head , os , & os -> children . head , os -> fill , dot , relax , check_regions ) ; after = ( ( os -> bfd_section -> vma + TO_ADDR ( os -> bfd_section -> _raw_size ) + os -> block_value - 1 ) & - ( bfd_vma ) os -> block_value ) ; if ( bfd_is_abs_section ( os -> bfd_section ) ) { ASSERT ( after == os -> bfd_section -> vma ) ; } else { os -> bfd_section -> _raw_size = TO_SIZE ( after - os -> bfd_section -> vma ) ; } dot = os -> bfd_section -> vma ; if ( ( os -> bfd_section -> flags & SEC_HAS_CONTENTS ) != 0 || ( os -> bfd_section -> flags & SEC_THREAD_LOCAL ) == 0 || link_info . relocatable ) { dot += TO_ADDR ( os -> bfd_section -> _raw_size ) ; } os -> processed = 1 ; if ( os -> update_dot_tree != 0 ) { exp_fold_tree ( os -> update_dot_tree , abs_output_section , lang_allocating_phase_enum , dot , & dot ) ; } if ( os -> region != NULL && ( ( bfd_get_section_flags ( output_bfd , os -> bfd_section ) & SEC_NEVER_LOAD ) == 0 || ( bfd_get_section_flags ( output_bfd , os -> bfd_section ) & ( SEC_ALLOC | SEC_LOAD ) ) ) ) { os -> region -> current = dot ; if ( check_regions ) { os_region_check ( os , os -> region , os -> addr_tree , os -> bfd_section -> vma ) ; } if ( os -> lma_region == NULL && os -> load_base == NULL ) { os -> lma_region = os -> region ; } if ( os -> lma_region != NULL && os -> lma_region != os -> region ) { os -> load_base = exp_intop ( os -> lma_region -> current ) ; os -> lma_region -> current += TO_ADDR ( os -> bfd_section -> _raw_size ) ; if ( check_regions ) { os_region_check ( os , os -> lma_region , NULL , os -> bfd_section -> lma ) ; } } } } break ; case lang_constructors_statement_enum : dot = lang_size_sections_1 ( constructor_list . head , output_section_statement , & s -> wild_statement . children . head , fill , dot , relax , check_regions ) ; break ; case lang_data_statement_enum : { unsigned int size = 0 ; s -> data_statement . output_vma = dot - output_section_statement -> bfd_section -> vma ; s -> data_statement . output_section = output_section_statement -> bfd_section ; exp_fold_tree ( s -> data_statement . exp , abs_output_section , lang_allocating_phase_enum , dot , & dot ) ; switch ( s -> data_statement . type ) { default : abort ( ) ; case QUAD : case SQUAD : size = QUAD_SIZE ; break ; case LONG : size = LONG_SIZE ; break ; case SHORT : size = SHORT_SIZE ; break ; case BYTE : size = BYTE_SIZE ; break ; } if ( size < TO_SIZE ( ( unsigned ) 1 ) ) { size = TO_SIZE ( ( unsigned ) 1 ) ; } dot += TO_ADDR ( size ) ; output_section_statement -> bfd_section -> _raw_size += size ; output_section_statement -> bfd_section -> flags |= SEC_HAS_CONTENTS ; if ( ! ( output_section_statement -> flags & SEC_NEVER_LOAD ) ) { output_section_statement -> bfd_section -> flags |= SEC_ALLOC | SEC_LOAD ; } } break ; case lang_reloc_statement_enum : { int size ; s -> reloc_statement . output_vma = dot - output_section_statement -> bfd_section -> vma ; s -> reloc_statement . output_section = output_section_statement -> bfd_section ; size = bfd_get_reloc_size ( s -> reloc_statement . howto ) ; dot += TO_ADDR ( size ) ; output_section_statement -> bfd_section -> _raw_size += size ; } break ; case lang_wild_statement_enum : dot = lang_size_sections_1 ( s -> wild_statement . children . head , output_section_statement , & s -> wild_statement . children . head , fill , dot , relax , check_regions ) ; break ; case lang_object_symbols_statement_enum : link_info . create_object_symbols_section = output_section_statement -> bfd_section ; break ; case lang_output_statement_enum : case lang_target_statement_enum : break ; case lang_input_section_enum : { asection * i ; i = ( * prev ) -> input_section . section ; if ( ! relax ) { if ( i -> _cooked_size == 0 ) { i -> _cooked_size = i -> _raw_size ; } } else { bfd_boolean again ; if ( ! bfd_relax_section ( i -> owner , i , & link_info , & again ) ) { einfo ( _ ( "%P%F: can't relax section: %E\n" ) ) ; } if ( again ) { * relax = TRUE ; } } dot = size_input_section ( prev , output_section_statement , output_section_statement -> fill , dot ) ; } break ; case lang_input_statement_enum : break ; case lang_fill_statement_enum : s -> fill_statement . output_section = output_section_statement -> bfd_section ; fill = s -> fill_statement . fill ; break ; case lang_assignment_statement_enum : { bfd_vma newdot = dot ; exp_fold_tree ( s -> assignment_statement . exp , output_section_statement , lang_allocating_phase_enum , dot , & newdot ) ; } break ; case lang_padding_statement_enum : s -> padding_statement . size = 0 ; s -> padding_statement . output_offset = dot - output_section_statement -> bfd_section -> vma ; break ; case lang_group_statement_enum : dot = lang_size_sections_1 ( s -> group_statement . children . head , output_section_statement , & s -> group_statement . children . head , fill , dot , relax , check_regions ) ; break ; default : FAIL ( ) ; break ; case lang_address_statement_enum : break ; } prev = & s -> header . next ; } return dot ; } 