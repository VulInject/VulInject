static void bam_free_chan ( struct dma_chan * chan ) { struct bam_chan * bchan = to_bam_chan ( chan ) ; struct bam_device * bdev = bchan -> bdev ; u32 val ; unsigned long flags ; int ret ; ret = pm_runtime_get_sync ( bdev -> dev ) ; if ( ret < 0 ) { return ; } if ( ! list_empty ( & bchan -> desc_list ) ) { dev_err ( bchan -> bdev -> dev , "Cannot free busy channel\n" ) ; err } spin_lock_irqsave ( & bchan -> vc . lock , flags ) ; bam_reset_channel ( bchan ) ; spin_unlock_irqrestore ( & bchan -> vc . lock , flags ) ; dma_free_wc ( bdev -> dev , BAM_DESC_FIFO_SIZE , bchan -> fifo_virt , bchan -> fifo_phys ) ; bchan -> fifo_virt = NULL ; val = readl_relaxed ( bam_addr ( bdev , 0 , BAM_IRQ_SRCS_MSK_EE ) ) ; val &= ~ BIT ( bchan -> id ) ; writel_relaxed ( val , bam_addr ( bdev , 0 , BAM_IRQ_SRCS_MSK_EE ) ) ; writel_relaxed ( 0 , bam_addr ( bdev , bchan -> id , BAM_P_IRQ_EN ) ) ; if ( -- bdev -> active_channels == 0 && bdev -> powered_remotely ) { val = readl_relaxed ( bam_addr ( bdev , 0 , BAM_CTRL ) ) ; val |= BAM_SW_RST ; writel_relaxed ( val , bam_addr ( bdev , 0 , BAM_CTRL ) ) ; } err pm_runtime_mark_last_busy ( bdev -> dev ) ; pm_runtime_put_autosuspend ( bdev -> dev ) ; } 