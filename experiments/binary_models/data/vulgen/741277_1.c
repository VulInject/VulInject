static int macro_subst_tok ( TCCState * s1 , TokenString * tok_str , Sym * * nested_list , Sym * s , struct macro_level * * can_read_stream ) { Sym * args , * sa , * sa1 ; int mstr_allocated , parlevel , * mstr , t , t1 , spc ; const int * p ; TokenString str ; char * cstrval ; CValue cval ; CString cstr ; char buf [ 32 ] ; if ( s1 -> tok == TOK___LINE__ ) { snprintf ( buf , sizeof ( buf ) , "%d" , s1 -> file -> line_num ) ; cstrval = buf ; t1 = TOK_PPNUM ; add_cstr1 } if ( s1 -> tok == TOK___FILE__ ) { cstrval = s1 -> file -> filename ; add_cstr } if ( s1 -> tok == TOK___DATE__ || s1 -> tok == TOK___TIME__ ) { time_t ti ; struct tm * tm ; time ( & ti ) ; tm = localtime ( & ti ) ; if ( s1 -> tok == TOK___DATE__ ) { snprintf ( buf , sizeof ( buf ) , "%s %2d %d" , ab_month_name [ tm -> tm_mon ] , tm -> tm_mday , tm -> tm_year + 1900 ) ; } else { snprintf ( buf , sizeof ( buf ) , "%02d:%02d:%02d" , tm -> tm_hour , tm -> tm_min , tm -> tm_sec ) ; } cstrval = buf ; add_cstr t1 = TOK_STR ; add_cstr1 cstr_new ( & cstr ) ; cstr_cat ( & cstr , cstrval ) ; cstr_ccat ( & cstr , '\0' ) ; cval . cstr = & cstr ; tok_str_add2 ( tok_str , t1 , & cval ) ; } else { mstr = s -> d ; mstr_allocated = 0 ; if ( s -> type . t == MACRO_FUNC ) { redo if ( s1 -> macro_ptr ) { p = s1 -> macro_ptr ; while ( is_space ( t = * p ) || TOK_LINEFEED == t ) { p ++ ; } if ( t == 0 && can_read_stream ) { struct macro_level * ml = * can_read_stream ; s1 -> macro_ptr = NULL ; if ( ml ) { s1 -> macro_ptr = ml -> p ; ml -> p = NULL ; * can_read_stream = ml -> prev ; } ( * nested_list ) -> v = - 1 ; redo } } else { s1 -> ch = s1 -> file -> buf_ptr [ 0 ] ; while ( is_space ( s1 -> ch ) || s1 -> ch == '\n' || s1 -> ch == '/' ) { if ( s1 -> ch == '/' ) { int c ; uint8_t * sp = s1 -> file -> buf_ptr ; PEEKC ( s1 , c , sp ) ; if ( c == '*' ) { sp = parse_comment ( s1 , sp ) ; s1 -> file -> buf_ptr = sp - 1 ; } if ( c == '/' ) { p = ( int * ) parse_line_comment ( s1 , sp ) ; s1 -> file -> buf_ptr = sp - 1 ; } else { break ; } } minp ( s1 ) ; } t = s1 -> ch ; } if ( t != '(' ) { return - 1 ; } next_nomacro ( s1 ) ; next_nomacro ( s1 ) ; args = NULL ; sa = s -> next ; while ( tcc_nerr ( s1 ) == 0 ) { if ( ! args && ! sa && s1 -> tok == ')' ) { break ; } if ( ! sa ) { tcc_error ( s1 , "macro '%s' used with too many args" , get_tok_str ( s1 , s -> v , 0 ) ) ; } tok_str_new ( & str ) ; parlevel = spc = 0 ; while ( ( parlevel > 0 || ( s1 -> tok != ')' && ( s1 -> tok != ',' || ( sa && sa -> type . t ) ) ) ) && s1 -> tok != - 1 ) { if ( s1 -> tok == '(' ) { parlevel ++ ; } if ( s1 -> tok == ')' ) { parlevel -- ; } if ( s1 -> tok == TOK_LINEFEED ) { s1 -> tok = ' ' ; } if ( ! check_space ( s1 -> tok , & spc ) ) { tok_str_add2 ( & str , s1 -> tok , & s1 -> tokc ) ; } next_nomacro_spc ( s1 ) ; } str . len -= spc ; tok_str_add ( s1 , & str , 0 ) ; sa1 = sa ?sym_push2 ( s1 , & args , sa -> v & ~ SYM_FIELD , sa -> type . t , 0 ) : NULL ; if ( ! sa1 ) { return - 1 ; } sa1 -> d = str . str ; sa = sa -> next ; if ( s1 -> tok == ')' ) { if ( sa && sa -> type . t && gnu_ext ) { continue ; } else { break ; } } if ( s1 -> tok != ',' ) { expect ( s1 , "," ) ; return 1 ; } next_nomacro ( s1 ) ; } if ( sa ) { tcc_error ( s1 , "macro '%s' used with too few args" , get_tok_str ( s1 , s -> v , 0 ) ) ; } mstr = macro_arg_subst ( s1 , nested_list , mstr , args ) ; sa = args ; while ( sa ) { sa1 = sa -> prev ; tok_str_free ( sa -> d ) ; sym_free ( s1 , sa ) ; sa = sa1 ; } mstr_allocated = 1 ; } if ( sym_push2 ( s1 , nested_list , s -> v , 0 , 0 ) == 0 ) { return - 1 ; } macro_subst ( s1 , tok_str , nested_list , mstr , can_read_stream ) ; sa1 = * nested_list ; * nested_list = sa1 -> prev ; sym_free ( s1 , sa1 ) ; if ( mstr_allocated ) { tok_str_free ( mstr ) ; } } return 0 ; } 