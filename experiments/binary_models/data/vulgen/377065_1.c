static int netdev_tc_flow_get ( struct netdev * netdev , struct match * match , struct nlattr * * actions , const ovs_u128 * ufid , struct dpif_flow_stats * stats , struct dpif_flow_attrs * attrs , struct ofpbuf * buf ) { struct tc_flower flower ; odp_port_t in_port ; struct tcf_id id ; int err ; err = get_ufid_tc_mapping ( ufid , & id ) ; if ( err ) { return err ; } VLOG_DBG_RL ( & rl , "flow get (dev %s prio %d handle %d block_id %d)" , netdev_get_name ( netdev ) , id . prio , id . handle , id . block_id ) ; err = tc_get_flower ( & id , & flower ) ; if ( err ) { VLOG_ERR_RL ( & error_rl , "flow get failed (dev %s prio %d handle %d): %s" , netdev_get_name ( netdev ) , id . prio , id . handle , ovs_strerror ( err ) ) ; return err ; } in_port = netdev_ifindex_to_odp_port ( id . ifindex ) ; parse_tc_flower_to_match ( netdev , & flower , match , actions , stats , attrs , buf , false ) ; if ( stats ) { struct dpif_flow_stats adjust_stats ; if ( ! get_ufid_adjust_stats ( ufid , & adjust_stats ) ) { netdev_tc_adjust_stats ( stats , & adjust_stats ) ; } } match -> wc . masks . in_port . odp_port = u32_to_odp ( UINT32_MAX ) ; match -> flow . in_port . odp_port = in_port ; match_set_recirc_id ( match , id . chain ) ; return 0 ; } 