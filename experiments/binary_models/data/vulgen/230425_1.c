char * pretty_print_option ( unsigned int code , struct option_data * option , int emit_punct ) { static char optbuf [ 8192 ] ; char fmtbuf [ 32 ] ; struct in_addr foo ; unsigned char * data = option -> data ; unsigned char * dp = data ; char * op = optbuf , * buf , * name , * fmt ; int hunksize = 0 , numhunk = - 1 , numelem = 0 ; int i , j , k , opleft = sizeof ( optbuf ) ; int len = option -> len ; int opcount = 0 ; int32_t int32val ; uint32_t uint32val ; uint16_t uint16val ; char comma ; memset ( optbuf , 0 , sizeof ( optbuf ) ) ; if ( code > 255 ) { log_warnx ( "%s: pretty_print_option: bad code %d" , log_procname , code ) ; done } if ( emit_punct != 0 ) { comma = ',' ; } else { comma = ' ' ; } switch ( code ) { case DHO_CLASSLESS_STATIC_ROUTES : case DHO_CLASSLESS_MS_STATIC_ROUTES : pretty_print_classless_routes ( dp , len , optbuf , sizeof ( optbuf ) ) ; done case DHO_DOMAIN_SEARCH : pretty_print_domain_list ( dp , len , optbuf , sizeof ( optbuf ) ) ; done default : break ; } name = code_to_name ( code ) ; fmt = code_to_format ( code ) ; for ( i = 0 ; fmt [ i ] ; i ++ ) { if ( numhunk == 0 ) { log_warnx ( "%s: %s: excess information in format " "string: %s" , log_procname , name , & fmt [ i ] ) ; done } numelem ++ ; fmtbuf [ i ] = fmt [ i ] ; switch ( fmt [ i ] ) { case 'A' : -- numelem ; fmtbuf [ i ] = 0 ; numhunk = 0 ; if ( hunksize == 0 ) { log_warnx ( "%s: %s: no size indicator before A" " in format string: %s" , log_procname , name , fmt ) ; done } break ; case 'X' : for ( k = 0 ; k < len ; k ++ ) { if ( isascii ( data [ k ] ) == 0 || isprint ( data [ k ] ) == 0 ) { break ; } } if ( k == len ) { fmtbuf [ i ] = 't' ; numhunk = - 2 ; } else { hunksize ++ ; comma = ':' ; numhunk = 0 ; } fmtbuf [ i + 1 ] = 0 ; break ; case 't' : fmtbuf [ i + 1 ] = 0 ; numhunk = - 2 ; break ; case 'I' : case 'l' : case 'L' : hunksize += 4 ; break ; case 'S' : hunksize += 2 ; break ; case 'B' : case 'f' : hunksize ++ ; break ; case 'e' : break ; default : log_warnx ( "%s: %s: garbage in format string: %s" , log_procname , name , & fmt [ i ] ) ; done } } if ( hunksize > len ) { log_warnx ( "%s: %s: expecting at least %d bytes; got %d" , log_procname , name , hunksize , len ) ; done } if ( numhunk == - 1 && hunksize < len ) { log_warnx ( "%s: %s: expecting only %d bytes: got %d" , log_procname , name , hunksize , len ) ; done } if ( numhunk == 0 ) { numhunk = len / hunksize ; } if ( numhunk > 0 && numhunk * hunksize != len ) { log_warnx ( "%s: %s: expecting %d bytes: got %d" , log_procname , name , numhunk * hunksize , len ) ; done } for ( i = 0 ; i < numhunk ; i ++ ) { for ( j = 0 ; j < numelem ; j ++ ) { switch ( fmtbuf [ j ] ) { case 't' : buf = pretty_print_string ( dp , len , emit_punct ) ; if ( buf == NULL ) { opcount = - 1 ; } else { opcount = strlcat ( op , buf , opleft ) ; } break ; case 'I' : memcpy ( & foo . s_addr , dp , sizeof ( foo . s_addr ) ) ; opcount = snprintf ( op , opleft , "%s" , inet_ntoa ( foo ) ) ; dp += sizeof ( foo . s_addr ) ; break ; case 'l' : memcpy ( & int32val , dp , sizeof ( int32val ) ) ; opcount = snprintf ( op , opleft , "%d" , ntohl ( int32val ) ) ; dp += sizeof ( int32val ) ; break ; case 'L' : memcpy ( & uint32val , dp , sizeof ( uint32val ) ) ; opcount = snprintf ( op , opleft , "%u" , ntohl ( uint32val ) ) ; dp += sizeof ( uint32val ) ; break ; case 'S' : memcpy ( & uint16val , dp , sizeof ( uint16val ) ) ; opcount = snprintf ( op , opleft , "%hu" , ntohs ( uint16val ) ) ; dp += sizeof ( uint16val ) ; break ; case 'B' : opcount = snprintf ( op , opleft , "%u" , * dp ) ; dp ++ ; break ; case 'X' : opcount = snprintf ( op , opleft , "%x" , * dp ) ; dp ++ ; break ; case 'f' : opcount = snprintf ( op , opleft , "%s" , * dp ?"true" : "false" ) ; dp ++ ; break ; default : log_warnx ( "%s: unexpected format code %c" , log_procname , fmtbuf [ j ] ) ; toobig } if ( opcount < 0 || opcount >= opleft ) { toobig } opleft -= opcount ; op += opcount ; if ( j + 1 < numelem && comma != ':' ) { opcount = snprintf ( op , opleft , " " ) ; if ( opcount < 0 || opcount >= opleft ) { toobig } opleft -= opcount ; op += opcount ; } } if ( i + 1 < numhunk ) { opcount = snprintf ( op , opleft , "%c" , comma ) ; if ( opcount < 0 || opcount >= opleft ) { toobig } opleft -= opcount ; op += opcount ; } } done return optbuf ; toobig memset ( optbuf , 0 , sizeof ( optbuf ) ) ; return optbuf ; } 