void autri_attach ( struct device * parent , struct device * self , void * aux ) { struct autri_softc * sc = ( autri_softc * ) self ; struct pci_attach_args * pa = ( pci_attach_args * ) aux ; pci_chipset_tag_t pc = pa -> pa_pc ; struct autri_codec_softc * codec ; bus_size_t iosize ; pci_intr_handle_t ih ; char const * intrstr ; mixer_ctrl_t ctl ; int i , r ; sc -> sc_devid = pa -> pa_id ; sc -> sc_class = pa -> pa_class ; sc -> sc_revision = PCI_REVISION ( pa -> pa_class ) ; if ( pci_mapreg_map ( pa , AUTRI_PCI_MEMORY_BASE , PCI_MAPREG_TYPE_MEM , 0 , & sc -> memt , & sc -> memh , NULL , & iosize , 0 ) ) { printf ( "%s: can't map mem space\n" , sc -> sc_dev . dv_xname ) ; return ; } if ( pci_intr_map ( pa , & ih ) ) { printf ( "%s: couldn't map interrupt\n" , sc -> sc_dev . dv_xname ) ; bus_space_unmap ( sc -> memt , sc -> memh , iosize ) ; return ; } intrstr = pci_intr_string ( pc , ih ) ; sc -> sc_ih = pci_intr_establish ( pc , ih , IPL_AUDIO | IPL_MPSAFE , autri_intr , sc , sc -> sc_dev . dv_xname ) ; if ( sc -> sc_ih == NULL ) { printf ( "%s: couldn't establish interrupt" , sc -> sc_dev . dv_xname ) ; if ( intrstr != NULL ) { printf ( " at %s" , intrstr ) ; } printf ( "\n" ) ; bus_space_unmap ( sc -> memt , sc -> memh , iosize ) ; return ; } printf ( ": %s\n" , intrstr ) ; sc -> sc_dmatag = pa -> pa_dmat ; sc -> sc_pc = pc ; sc -> sc_pt = pa -> pa_tag ; autri_init ( sc ) ; codec = & sc -> sc_codec ; memcpy ( & codec -> sc_dev , & sc -> sc_dev , sizeof ( codec -> sc_dev ) ) ; codec -> sc = sc ; codec -> host_if . arg = codec ; codec -> host_if . attach = autri_attach_codec ; codec -> host_if . reset = autri_reset_codec ; codec -> host_if . read = autri_read_codec ; codec -> host_if . write = autri_write_codec ; codec -> host_if . flags = autri_flags_codec ; codec -> flags = AC97_HOST_DONT_READ | AC97_HOST_SWAPPED_CHANNELS ; if ( ( r = ac97_attach ( & codec -> host_if ) ) != 0 ) { printf ( "%s: can't attach codec (error 0x%X)\n" , sc -> sc_dev . dv_xname , r ) ; pci_intr_disestablish ( pc , sc -> sc_ih ) ; bus_space_unmap ( sc -> memt , sc -> memh , iosize ) ; return ; } for ( i = 0 ; i < 4 ; i ++ ) { static { char * class , * device ; } , d [ ] { { AudioCoutputs AudioNmaster } { AudioCinputs AudioNdac } { AudioCinputs AudioNcd } { AudioCrecord AudioNvolume } } ; ctl . type = AUDIO_MIXER_ENUM ; ctl . un . ord = 0 ; ctl . dev = sc -> sc_codec . codec_if -> vtbl -> get_portnum_by_name ( sc -> sc_codec . codec_if , d [ i ] . class , d [ i ] . device , AudioNmute ) ; ctl . dev = autri_get_portnum_by_name ( sc , d [ i ] . class , d [ i ] . device , AudioNmute ) ; autri_mixer_set_port ( sc , & ctl ) ; } ctl . type = AUDIO_MIXER_VALUE ; ctl . un . value . num_channels = 2 ; ctl . un . value . level [ AUDIO_MIXER_LEVEL_LEFT ] = ctl . un . value . level [ AUDIO_MIXER_LEVEL_RIGHT ] = 127 ; ctl . dev = autri_get_portnum_by_name ( sc , AudioCoutputs , AudioNmaster , NULL ) ; autri_mixer_set_port ( sc , & ctl ) ; audio_attach_mi ( & autri_hw_if , sc , NULL , & sc -> sc_dev ) ; midi_attach_mi ( & autri_midi_hw_if , sc , & sc -> sc_dev ) ; } 