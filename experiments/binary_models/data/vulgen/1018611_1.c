static irqreturn_t handle_temp_alert ( void __iomem * base , struct emif_data * emif ) { irqreturn_t ret = IRQ_HANDLED ; struct emif_custom_configs * custom_configs ; spin_lock_irqsave ( & emif_lock , irq_state ) ; old_temp_level = emif -> temperature_level ; get_temperature_level ( emif ) ; if ( unlikely ( emif -> temperature_level == old_temp_level ) ) { out } if ( ! emif -> curr_regs ) { dev_err ( emif -> dev , "temperature alert before registers are calculated, not de-rating timings\n" ) ; out } custom_configs = emif -> plat_data -> custom_configs ; if ( custom_configs && ! ( custom_configs -> mask & EMIF_CUSTOM_CONFIG_EXTENDED_TEMP_PART ) ) { if ( emif -> temperature_level >= SDRAM_TEMP_HIGH_DERATE_REFRESH ) { dev_err ( emif -> dev , "%s:NOT Extended temperature capable memory." "Converting MR4=0x%02x as shutdown event\n" , __func__ , emif -> temperature_level ) ; emif -> temperature_level = SDRAM_TEMP_VERY_HIGH_SHUTDOWN ; ret = IRQ_WAKE_THREAD ; out } } if ( emif -> temperature_level < old_temp_level || emif -> temperature_level == SDRAM_TEMP_VERY_HIGH_SHUTDOWN ) { ret = IRQ_WAKE_THREAD ; } else { setup_temperature_sensitive_regs ( emif , emif -> curr_regs ) ; do_freq_update ( ) ; } out spin_unlock_irqrestore ( & emif_lock , irq_state ) ; return ret ; } 