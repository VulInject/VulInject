static int __create_free_space_inode ( struct btrfs_root * root , struct btrfs_trans_handle * trans , struct btrfs_path * path , u64 ino , u64 offset ) { struct btrfs_key key ; struct btrfs_disk_key disk_key ; struct btrfs_free_space_header * header ; struct btrfs_inode_item * inode_item ; struct extent_buffer * leaf ; u64 flags = BTRFS_INODE_NOCOMPRESS | BTRFS_INODE_PREALLOC ; int ret ; ret = btrfs_insert_empty_inode ( trans , root , path , ino ) ; if ( ret ) { return ret ; } if ( ino != BTRFS_FREE_INO_OBJECTID ) { flags |= BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW ; } leaf = path -> nodes [ 0 ] ; inode_item = btrfs_item_ptr ( leaf , path -> slots [ 0 ] , btrfs_inode_item ) ; btrfs_item_key ( leaf , & disk_key , path -> slots [ 0 ] ) ; memzero_extent_buffer ( leaf , ( unsigned long ) inode_item , sizeof ( * inode_item ) ) ; btrfs_set_inode_generation ( leaf , inode_item , trans -> transid ) ; btrfs_set_inode_size ( leaf , inode_item , 0 ) ; btrfs_set_inode_nbytes ( leaf , inode_item , 0 ) ; btrfs_set_inode_uid ( leaf , inode_item , 0 ) ; btrfs_set_inode_gid ( leaf , inode_item , 0 ) ; btrfs_set_inode_mode ( leaf , inode_item , S_IFREG | 0600 ) ; btrfs_set_inode_flags ( leaf , inode_item , flags ) ; btrfs_set_inode_nlink ( leaf , inode_item , 1 ) ; btrfs_set_inode_transid ( leaf , inode_item , trans -> transid ) ; btrfs_set_inode_block_group ( leaf , inode_item , offset ) ; btrfs_mark_buffer_dirty ( leaf ) ; btrfs_release_path ( path ) ; key . objectid = BTRFS_FREE_SPACE_OBJECTID ; key . offset = offset ; key . type = 0 ; ret = btrfs_insert_empty_item ( trans , root , path , & key , sizeof ( btrfs_free_space_header ) ) ; leaf = path -> nodes [ 0 ] ; header = btrfs_item_ptr ( leaf , path -> slots [ 0 ] , btrfs_free_space_header ) ; memzero_extent_buffer ( leaf , ( unsigned long ) header , sizeof ( * header ) ) ; btrfs_set_free_space_key ( leaf , header , & disk_key ) ; btrfs_mark_buffer_dirty ( leaf ) ; btrfs_release_path ( path ) ; return 0 ; } 