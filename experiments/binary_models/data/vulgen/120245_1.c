krb5_error_code pkinit_as_req_create ( krb5_context context , pkinit_context plgctx , pkinit_req_context reqctx , krb5_timestamp ctsec , krb5_int32 cusec , krb5_ui_4 nonce , const krb5_checksum * cksum , krb5_principal server , krb5_data * * as_req ) { krb5_error_code retval = ENOMEM ; krb5_subject_pk_info * info = NULL ; krb5_data * coded_auth_pack = NULL ; krb5_auth_pack * auth_pack = NULL ; krb5_pa_pk_as_req * req = NULL ; krb5_auth_pack_draft9 * auth_pack9 = NULL ; krb5_pa_pk_as_req_draft9 * req9 = NULL ; int protocol = reqctx -> opts -> dh_or_rsa ; pkiDebug ( "pkinit_as_req_create pa_type = %d\n" , reqctx -> pa_type ) ; switch ( ( int ) reqctx -> pa_type ) { case KRB5_PADATA_PK_AS_REQ_OLD : protocol = RSA_PROTOCOL ; init_krb5_auth_pack_draft9 ( & auth_pack9 ) ; if ( auth_pack9 == NULL ) { cleanup } auth_pack9 -> pkAuthenticator . ctime = ctsec ; auth_pack9 -> pkAuthenticator . cusec = cusec ; auth_pack9 -> pkAuthenticator . nonce = nonce ; auth_pack9 -> pkAuthenticator . kdcName = server ; auth_pack9 -> pkAuthenticator . kdcRealm . magic = 0 ; auth_pack9 -> pkAuthenticator . kdcRealm . data = ( unsigned char * ) server -> realm . data ; auth_pack9 -> pkAuthenticator . kdcRealm . length = server -> realm . length ; break ; case KRB5_PADATA_PK_AS_REQ : init_krb5_subject_pk_info ( & info ) ; if ( info == NULL ) { cleanup } init_krb5_auth_pack ( & auth_pack ) ; if ( auth_pack == NULL ) { cleanup } auth_pack -> pkAuthenticator . ctime = ctsec ; auth_pack -> pkAuthenticator . cusec = cusec ; auth_pack -> pkAuthenticator . nonce = nonce ; auth_pack -> pkAuthenticator . paChecksum = * cksum ; auth_pack -> clientDHNonce . length = 0 ; auth_pack -> clientPublicValue = info ; retval = create_krb5_supportedCMSTypes ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , reqctx -> idctx , & auth_pack -> supportedCMSTypes ) ; if ( retval ) { cleanup } break ; default : pkiDebug ( "as_req: unrecognized pa_type = %d\n" , ( int ) reqctx -> pa_type ) ; retval = - 1 ; cleanup } switch ( protocol ) { case DH_PROTOCOL : pkiDebug ( "as_req: DH key transport algorithm\n" ) ; retval = pkinit_copy_krb5_octet_data ( & info -> algorithm . algorithm , & dh_oid ) ; if ( retval ) { pkiDebug ( "failed to copy dh_oid\n" ) ; cleanup } if ( ( retval = client_create_dh ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , reqctx -> idctx , reqctx -> opts -> dh_size , & info -> algorithm . parameters . data , & info -> algorithm . parameters . length , & info -> subjectPublicKey . data , & info -> subjectPublicKey . length ) ) != 0 ) { pkiDebug ( "failed to create dh parameters\n" ) ; cleanup } break ; case RSA_PROTOCOL : pkiDebug ( "as_req: RSA key transport algorithm\n" ) ; switch ( ( int ) reqctx -> pa_type ) { case KRB5_PADATA_PK_AS_REQ_OLD : auth_pack9 -> clientPublicValue = NULL ; break ; case KRB5_PADATA_PK_AS_REQ : free_krb5_subject_pk_info ( & info ) ; auth_pack -> clientPublicValue = NULL ; break ; } break ; default : pkiDebug ( "as_req: unknown key transport protocol %d\n" , protocol ) ; retval = - 1 ; cleanup } switch ( ( int ) reqctx -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : retval = k5int_encode_krb5_auth_pack ( auth_pack , & coded_auth_pack ) ; break ; case KRB5_PADATA_PK_AS_REQ_OLD : retval = k5int_encode_krb5_auth_pack_draft9 ( auth_pack9 , & coded_auth_pack ) ; break ; } if ( retval ) { pkiDebug ( "failed to encode the AuthPack %d\n" , retval ) ; cleanup } print_buffer_bin ( ( unsigned char * ) coded_auth_pack -> data , coded_auth_pack -> length , "/tmp/client_auth_pack" ) ; switch ( ( int ) reqctx -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : init_krb5_pa_pk_as_req ( & req ) ; if ( req == NULL ) { retval = ENOMEM ; cleanup } retval = cms_signeddata_create ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , reqctx -> idctx , CMS_SIGN_CLIENT , 1 , ( unsigned char * ) coded_auth_pack -> data , coded_auth_pack -> length , & req -> signedAuthPack . data , & req -> signedAuthPack . length ) ; print_buffer_bin ( ( unsigned char * ) req -> signedAuthPack . data , req -> signedAuthPack . length , "/tmp/client_signed_data" ) ; break ; case KRB5_PADATA_PK_AS_REQ_OLD : init_krb5_pa_pk_as_req_draft9 ( & req9 ) ; if ( req9 == NULL ) { retval = ENOMEM ; cleanup } retval = cms_signeddata_create ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , reqctx -> idctx , CMS_SIGN_DRAFT9 , 1 , ( unsigned char * ) coded_auth_pack -> data , coded_auth_pack -> length , & req9 -> signedAuthPack . data , & req9 -> signedAuthPack . length ) ; break ; print_buffer_bin ( ( unsigned char * ) req9 -> signedAuthPack . data , req9 -> signedAuthPack . length , "/tmp/client_signed_data_draft9" ) ; } krb5_free_data ( context , coded_auth_pack ) ; if ( retval ) { pkiDebug ( "failed to create pkcs7 signed data\n" ) ; cleanup } switch ( ( int ) reqctx -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : retval = create_krb5_trustedCertifiers ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , reqctx -> idctx , & req -> trustedCertifiers ) ; if ( retval ) { cleanup } retval = create_issuerAndSerial ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , reqctx -> idctx , & req -> kdcPkId . data , & req -> kdcPkId . length ) ; if ( retval ) { cleanup } retval = k5int_encode_krb5_pa_pk_as_req ( req , as_req ) ; break ; case KRB5_PADATA_PK_AS_REQ_OLD : retval = create_krb5_trustedCas ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , reqctx -> idctx , 1 , & req9 -> trustedCertifiers ) ; if ( retval ) { cleanup } retval = create_issuerAndSerial ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , reqctx -> idctx , & req9 -> kdcCert . data , & req9 -> kdcCert . length ) ; if ( retval ) { cleanup } retval = k5int_encode_krb5_pa_pk_as_req_draft9 ( req9 , as_req ) ; break ; } if ( ! retval ) { print_buffer_bin ( ( unsigned char * ) ( * as_req ) -> data , ( * as_req ) -> length , "/tmp/client_as_req" ) ; } cleanup switch ( ( int ) reqctx -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : free_krb5_auth_pack ( & auth_pack ) ; free_krb5_pa_pk_as_req ( & req ) ; break ; case KRB5_PADATA_PK_AS_REQ_OLD : free_krb5_pa_pk_as_req_draft9 ( & req9 ) ; free ( auth_pack9 ) ; break ; } pkiDebug ( "pkinit_as_req_create retval=%d\n" , ( int ) retval ) ; return retval ; } 