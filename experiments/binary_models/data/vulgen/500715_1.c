void smp_synchronize_tick_client ( void ) { long i , delta , adj , adjust_latency = 0 , done = 0 ; unsigned long flags , rt , master_time_stamp ; { long rt ; long master ; long diff ; long lat ; } , t [ NUM_ROUNDS ] go [ MASTER ] = 1 ; while ( go [ MASTER ] ) { rmb ( ) ; } local_irq_save ( flags ) ; { for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { delta = get_delta ( & rt , & master_time_stamp ) ; if ( ! done ) { if ( i > 0 ) { adjust_latency += - delta ; adj = - delta + adjust_latency / 4 ; } else { adj = - delta ; } tick_ops -> add_tick ( adj ) ; } t [ i ] . rt = rt ; t [ i ] . master = master_time_stamp ; t [ i ] . diff = delta ; t [ i ] . lat = adjust_latency / 4 ; } } local_irq_restore ( flags ) ; for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { printk ( "rt=%5ld master=%5ld diff=%5ld adjlat=%5ld\n" , t [ i ] . rt , t [ i ] . master , t [ i ] . diff , t [ i ] . lat ) ; } printk ( KERN_INFO "CPU %d: synchronized TICK with master CPU " "(last diff %ld cycles, maxerr %lu cycles)\n" , smp_processor_id ( ) , delta , rt ) ; } 