static char * extract_subst_template ( void ) { int n = 0 ; int i = 0 ; char c ; char delimiter = * ibufp ++ ; if ( * ibufp == '%' && * ( ibufp + 1 ) == delimiter ) { ibufp ++ ; if ( ! rhbuf ) { seterrmsg ( "no previous substitution" ) ; } return rhbuf ; } while ( * ibufp != delimiter ) { REALLOC ( rhbuf , rhbufsz , i + 2 , NULL ) ; if ( ( c = rhbuf [ i ++ ] = * ibufp ++ ) == '\n' && * ibufp == '\0' ) { i -- , ibufp -- ; break ; } if ( c != '\\' ) { } if ( ( rhbuf [ i ++ ] = * ibufp ++ ) != '\n' ) { } if ( ! isglobal ) { while ( ( n = get_tty_line ( ) ) == 0 || ( n > 0 && ibuf [ n - 1 ] != '\n' ) ) { clearerr ( stdin ) ; } } } REALLOC ( rhbuf , rhbufsz , i + 1 , NULL ) ; rhbuf [ rhbufi = i ] = '\0' ; return rhbuf ; } static char * rbuf ; static int rbufsz ; int search_and_replace ( regex_t * pat , int gflag , int kth ) { undo_t * up ; char * txt ; char * eot ; int lc ; int xa = current_addr ; int nsubs = 0 ; line_t * lp ; int len ; current_addr = first_addr - 1 ; for ( lc = 0 ; lc <= second_addr - first_addr ; lc ++ ) { lp = get_addressed_line_node ( ++ current_addr ) ; if ( ( len = substitute_matching_text ( pat , lp , gflag , kth ) ) < 0 ) { return ERR ; } if ( len ) { up = NULL ; if ( delete_lines ( current_addr , current_addr ) < 0 ) { return ERR ; } txt = rbuf ; eot = rbuf + len ; SPL1 ( ) ; { if ( ( txt = put_sbuf_line ( txt ) ) == NULL ) { SPL0 ( ) ; return ERR ; } if ( up ) { up -> t = get_addressed_line_node ( current_addr ) ; } if ( ( up = push_undo_stack ( UADD , current_addr , current_addr ) ) == NULL ) { SPL0 ( ) ; return ERR ; } } txt != eot ; SPL0 ( ) ; nsubs ++ ; xa = current_addr ; } } current_addr = xa ; if ( nsubs == 0 && ! ( gflag & GLB ) ) { seterrmsg ( "no match" ) ; return ERR ; } if ( ( gflag & ( GPR | GLS | GNP ) ) && display_lines ( current_addr , current_addr , gflag ) < 0 ) { return ERR ; } return 0 ; } 