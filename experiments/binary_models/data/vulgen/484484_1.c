int dlg_bridge ( str * from , str * to , str * op , str * bd ) { dlg_transfer_ctx_t * dtc ; int ret ; str s_method = { "INVITE" 6 } ; str s_body ; uac_req_t uac_r ; dtc = ( dlg_transfer_ctx_t * ) shm_malloc ( sizeof ( dlg_transfer_ctx_t ) ) ; if ( dtc == NULL ) { LM_ERR ( "no shm\n" ) ; return - 1 ; } dtc -> from . s = ( char * ) shm_malloc ( ( from -> len + 1 ) * sizeof ( char ) ) ; if ( dtc -> from . s == NULL ) { LM_ERR ( "no shm\n" ) ; shm_free ( dtc ) ; return - 1 ; } dtc -> to . s = ( char * ) shm_malloc ( ( to -> len + 1 ) * sizeof ( char ) ) ; if ( dtc -> to . s == NULL ) { LM_ERR ( "no shm\n" ) ; shm_free ( dtc -> from . s ) ; shm_free ( dtc ) ; return - 1 ; } memcpy ( dtc -> from . s , from -> s , from -> len ) ; dtc -> from . len = from -> len ; dtc -> from . s [ dtc -> from . len ] = '\0' ; memcpy ( dtc -> to . s , to -> s , to -> len ) ; dtc -> to . len = to -> len ; dtc -> to . s [ dtc -> to . len ] = '\0' ; LM_DBG ( "bridge<%.*s>to<%.*s>\n" , dtc -> from . len , dtc -> from . s , dtc -> to . len , dtc -> to . s ) ; if ( bd != NULL && bd -> s != NULL ) { s_body . s = bd -> s ; s_body . len = bd -> len ; } else { s_body . s = DLG_HOLD_SDP ; s_body . len = DLG_HOLD_SDP_LEN ; } memset ( & uac_r , '\0' , sizeof ( uac_req_t ) ) ; uac_r . method = & s_method ; uac_r . headers = & dlg_bridge_inv_hdrs ; uac_r . body = & s_body ; uac_r . cb_flags = TMCB_LOCAL_COMPLETED ; uac_r . cb = dlg_bridge_tm_callback ; uac_r . cbp = ( void * ) ( long ) dtc ; ret = d_tmb . t_request ( & uac_r , & dtc -> from , & dtc -> from , & dlg_bridge_controller , ( op != NULL && op -> len > 0 ) ?op : NULL ) ; if ( ret < 0 ) { dlg_transfer_ctx_free ( dtc ) ; return - 1 ; } return 0 ; } 