Status_t sa_HFICongCtrlRecord_GetTable ( Mai_t * maip , uint32_t * records ) { uint8_t * data ; uint32_t bytes ; Node_t * pNode ; Port_t * pPort ; STL_SA_MAD samad ; Status_t status ; bool_t checkLid ; STL_LID lid = 0 ; bool_t checkBlock ; uint16_t blockNum = 0 ; uint16_t numBlocks = 0 ; STL_HFI_CONGESTION_CONTROL_TABLE_RECORD record ; IB_ENTER ( "sa_HFICongCtrlRecord_GetTable" , maip , * records , 0 , 0 ) ; * records = 0 ; if ( ! sm_config . congestion . enable ) { return VSTATUS_OK ; } data = sa_data ; bytes = Calculate_Padding ( sizeof ( STL_HFI_CONGESTION_CONTROL_TABLE_RECORD ) ) ; if ( maip -> datasize - sizeof ( STL_SA_MAD_HEADER ) < sizeof ( STL_HFI_CONGESTION_CONTROL_TABLE_RECORD ) ) { IB_LOG_ERROR_FMT ( __func__ , "invalid MAD length; size of STL_HFI_CONGESTION_CONTROL_TABLE_RECORD[%" PRISZT "], datasize[%d]" , sizeof ( STL_HFI_CONGESTION_CONTROL_TABLE_RECORD ) , ( int ) ( maip -> datasize - sizeof ( STL_SA_MAD_HEADER ) ) ) ; maip -> base . status = MAD_STATUS_SA_REQ_INVALID ; IB_EXIT ( "sa_HFICongCtrlRecord_GetTable" , MAD_STATUS_SA_REQ_INVALID ) ; return ( MAD_STATUS_SA_REQ_INVALID ) ; } BSWAPCOPY_STL_SA_MAD ( ( STL_SA_MAD * ) maip -> data , & samad , sizeof ( STL_HFI_CONGESTION_CONTROL_TABLE_RECORD ) ) ; checkLid = ( samad . header . mask & HCCTR_COMPONENTMASK_COMP_LID ) ; if ( checkLid ) { lid = ntoh32 ( ( ( STL_HFI_CONGESTION_CONTROL_TABLE_RECORD * ) ( samad . data ) ) -> RID . LID ) ; } checkBlock = ( samad . header . mask & HCCTR_COMPONENTMASK_COMP_BLOCK ) ; if ( checkBlock ) { blockNum = ntoh16 ( ( ( STL_HFI_CONGESTION_CONTROL_TABLE_RECORD * ) ( samad . data ) ) -> RID . BlockNum ) ; } status = sa_create_template_mask ( maip -> base . aid , samad . header . mask ) ; if ( status != VSTATUS_OK ) { IB_EXIT ( "sa_HFICongCtrlRecord_GetTable" , VSTATUS_OK ) ; return ( VSTATUS_OK ) ; } ( void ) vs_rdlock ( & old_topology_lock ) ; if ( checkLid ) { if ( ( pPort = sm_find_node_and_port_lid ( & old_topology , lid , & pNode ) ) != NULL ) { if ( ! sm_valid_port ( pPort ) || pPort -> state <= IB_PORT_DOWN ) { done } if ( ( pNode -> nodeInfo . NodeType == NI_TYPE_SWITCH ) && ( ! pNode -> switchInfo . u2 . s . EnhancedPort0 ) ) { done } if ( pPort -> portData -> congConRefCount == NULL ) { done } numBlocks = pPort -> portData -> congConRefCount -> hfiCongCon . CCTI_Limit / STL_NUM_CONGESTION_CONTROL_ELEMENTS_BLOCK_ENTRIES ; if ( checkBlock && blockNum > numBlocks ) { maip -> base . status = MAD_STATUS_SA_REQ_INVALID ; IB_LOG_ERROR_FMT ( __func__ , "Requested block (%u) does not exist" , blockNum ) ; done } memset ( & record , 0 , sizeof ( record ) ) ; record . RID . LID = lid ; record . HFICongestionControlTable . CCTI_Limit = pPort -> portData -> congConRefCount -> hfiCongCon . CCTI_Limit ; for ( ; blockNum <= numBlocks ; blockNum ++ ) { if ( ( status = sa_check_len ( data , sizeof ( STL_HFI_CONGESTION_CONTROL_TABLE_RECORD ) , bytes ) ) != VSTATUS_OK ) { maip -> base . status = MAD_STATUS_SA_NO_RESOURCES ; IB_LOG_ERROR_FMT ( "sa_HFICongCtrlRecord_GetTable" , "Reached size limit at %d records" , * records ) ; done } record . RID . BlockNum = blockNum ; memcpy ( & record . HFICongestionControlTable . CCT_Block_List [ 0 ] , & pPort -> portData -> congConRefCount -> hfiCongCon . CCT_Block_List [ blockNum ] , sizeof ( record . HFICongestionControlTable . CCT_Block_List ) ) ; BSWAPCOPY_STL_HFI_CONGESTION_CONTROL_TABLE_RECORD ( & record , ( STL_HFI_CONGESTION_CONTROL_TABLE_RECORD * ) data ) ; ( void ) sa_template_test ( samad . data , & data , sizeof ( STL_HFI_CONGESTION_CONTROL_TABLE_RECORD ) , bytes , records ) ; if ( checkBlock ) { done } } } } else { for_all_nodes ( , ) { if ( ( pNode -> nodeInfo . NodeType == NI_TYPE_SWITCH ) && ( ! pNode -> switchInfo . u2 . s . EnhancedPort0 ) ) { continue ; } for_all_ports ( , ) { if ( ! sm_valid_port ( pPort ) || pPort -> state <= IB_PORT_DOWN ) { continue ; } if ( ( pNode -> nodeInfo . NodeType == NI_TYPE_SWITCH ) && ( pPort -> index != 0 ) ) { break ; } numBlocks = pPort -> portData -> congConRefCount -> hfiCongCon . CCTI_Limit / STL_NUM_CONGESTION_CONTROL_ELEMENTS_BLOCK_ENTRIES ; memset ( & record , 0 , sizeof ( record ) ) ; record . RID . LID = pPort -> portData -> lid ; record . HFICongestionControlTable . CCTI_Limit = pPort -> portData -> congConRefCount -> hfiCongCon . CCTI_Limit ; for ( blockNum = 0 ; blockNum <= numBlocks ; blockNum ++ ) { if ( ( status = sa_check_len ( data , sizeof ( STL_HFI_CONGESTION_CONTROL_TABLE_RECORD ) , bytes ) ) != VSTATUS_OK ) { maip -> base . status = MAD_STATUS_SA_NO_RESOURCES ; IB_LOG_ERROR_FMT ( "sa_HFICongCtrlRecord_GetTable" , "Reached size limit at %d records" , * records ) ; done } record . RID . BlockNum = blockNum ; memcpy ( & record . HFICongestionControlTable . CCT_Block_List [ 0 ] , & pPort -> portData -> congConRefCount -> hfiCongCon . CCT_Block_List [ blockNum ] , sizeof ( record . HFICongestionControlTable . CCT_Block_List ) ) ; BSWAPCOPY_STL_HFI_CONGESTION_CONTROL_TABLE_RECORD ( & record , ( STL_HFI_CONGESTION_CONTROL_TABLE_RECORD * ) data ) ; ( void ) sa_template_test ( samad . data , & data , sizeof ( STL_HFI_CONGESTION_CONTROL_TABLE_RECORD ) , bytes , records ) ; } } } } done ( void ) vs_rwunlock ( & old_topology_lock ) ; IB_EXIT ( "sa_HFICongCtrlRecord_GetTable" , VSTATUS_OK ) ; return ( VSTATUS_OK ) ; } 