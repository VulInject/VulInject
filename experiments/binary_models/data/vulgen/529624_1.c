static int vc4_hvs_bind ( struct device * dev , struct device * master , void * data ) { struct platform_device * pdev = to_platform_device ( dev ) ; struct drm_device * drm = dev_get_drvdata ( master ) ; struct vc4_dev * vc4 = to_vc4_dev ( drm ) ; struct vc4_hvs * hvs = NULL ; int ret ; u32 dispctrl ; u32 reg , top ; hvs = __vc4_hvs_alloc ( vc4 , NULL ) ; if ( IS_ERR ( hvs ) ) { return PTR_ERR ( hvs ) ; } hvs -> regs = vc4_ioremap_regs ( pdev , 0 ) ; if ( IS_ERR ( hvs -> regs ) ) { return PTR_ERR ( hvs -> regs ) ; } hvs -> regset . base = hvs -> regs ; hvs -> regset . regs = hvs_regs ; hvs -> regset . nregs = ARRAY_SIZE ( hvs_regs ) ; if ( vc4 -> is_vc5 ) { struct rpi_firmware * firmware ; struct device_node * node ; unsigned int max_rate ; node = rpi_firmware_find_node ( ) ; firmware = rpi_firmware_get ( node ) ; of_node_put ( node ) ; if ( ! firmware ) { return - EPROBE_DEFER ; } hvs -> core_clk = devm_clk_get ( & pdev -> dev , NULL ) ; if ( IS_ERR ( hvs -> core_clk ) ) { dev_err ( & pdev -> dev , "Couldn't get core clock\n" ) ; return PTR_ERR ( hvs -> core_clk ) ; } max_rate = rpi_firmware_clk_get_max_rate ( firmware , RPI_FIRMWARE_CORE_CLK_ID ) ; rpi_firmware_put ( firmware ) ; if ( max_rate >= 550000000 ) { hvs -> vc5_hdmi_enable_hdmi_20 = true ; } if ( max_rate >= 600000000 ) { hvs -> vc5_hdmi_enable_4096by2160 = true ; } hvs -> max_core_rate = max_rate ; ret = clk_prepare_enable ( hvs -> core_clk ) ; if ( ret ) { dev_err ( & pdev -> dev , "Couldn't enable the core clock\n" ) ; return ret ; } } if ( ! vc4 -> is_vc5 ) { hvs -> dlist = hvs -> regs + SCALER_DLIST_START ; } else { hvs -> dlist = hvs -> regs + SCALER5_DLIST_START ; } ret = vc4_hvs_upload_linear_kernel ( hvs , & hvs -> mitchell_netravali_filter , mitchell_netravali_1_3_1_3_kernel ) ; if ( ret ) { return ret ; } reg = HVS_READ ( SCALER_DISPECTRL ) ; reg &= ~ SCALER_DISPECTRL_DSP2_MUX_MASK ; HVS_WRITE ( SCALER_DISPECTRL , reg | VC4_SET_FIELD ( 0 , SCALER_DISPECTRL_DSP2_MUX ) ) ; reg = HVS_READ ( SCALER_DISPCTRL ) ; reg &= ~ SCALER_DISPCTRL_DSP3_MUX_MASK ; HVS_WRITE ( SCALER_DISPCTRL , reg | VC4_SET_FIELD ( 3 , SCALER_DISPCTRL_DSP3_MUX ) ) ; reg = HVS_READ ( SCALER_DISPEOLN ) ; reg &= ~ SCALER_DISPEOLN_DSP4_MUX_MASK ; HVS_WRITE ( SCALER_DISPEOLN , reg | VC4_SET_FIELD ( 3 , SCALER_DISPEOLN_DSP4_MUX ) ) ; reg = HVS_READ ( SCALER_DISPDITHER ) ; reg &= ~ SCALER_DISPDITHER_DSP5_MUX_MASK ; HVS_WRITE ( SCALER_DISPDITHER , reg | VC4_SET_FIELD ( 3 , SCALER_DISPDITHER_DSP5_MUX ) ) ; dispctrl = HVS_READ ( SCALER_DISPCTRL ) ; dispctrl |= SCALER_DISPCTRL_ENABLE ; dispctrl |= SCALER_DISPCTRL_DISPEIRQ ( 0 ) | SCALER_DISPCTRL_DISPEIRQ ( 1 ) | SCALER_DISPCTRL_DISPEIRQ ( 2 ) ; if ( ! vc4 -> is_vc5 ) { dispctrl &= ~ ( SCALER_DISPCTRL_DMAEIRQ | SCALER_DISPCTRL_SLVWREIRQ | SCALER_DISPCTRL_SLVRDEIRQ | SCALER_DISPCTRL_DSPEIEOF ( 0 ) | SCALER_DISPCTRL_DSPEIEOF ( 1 ) | SCALER_DISPCTRL_DSPEIEOF ( 2 ) | SCALER_DISPCTRL_DSPEIEOLN ( 0 ) | SCALER_DISPCTRL_DSPEIEOLN ( 1 ) | SCALER_DISPCTRL_DSPEIEOLN ( 2 ) | SCALER_DISPCTRL_DSPEISLUR ( 0 ) | SCALER_DISPCTRL_DSPEISLUR ( 1 ) | SCALER_DISPCTRL_DSPEISLUR ( 2 ) | SCALER_DISPCTRL_SCLEIRQ ) ; } else { dispctrl &= ~ ( SCALER_DISPCTRL_DMAEIRQ | SCALER5_DISPCTRL_SLVEIRQ | SCALER5_DISPCTRL_DSPEIEOF ( 0 ) | SCALER5_DISPCTRL_DSPEIEOF ( 1 ) | SCALER5_DISPCTRL_DSPEIEOF ( 2 ) | SCALER5_DISPCTRL_DSPEIEOLN ( 0 ) | SCALER5_DISPCTRL_DSPEIEOLN ( 1 ) | SCALER5_DISPCTRL_DSPEIEOLN ( 2 ) | SCALER5_DISPCTRL_DSPEISLUR ( 0 ) | SCALER5_DISPCTRL_DSPEISLUR ( 1 ) | SCALER5_DISPCTRL_DSPEISLUR ( 2 ) | SCALER_DISPCTRL_SCLEIRQ ) ; } dispctrl &= ~ ( SCALER_DISPCTRL_PANIC0_MASK | SCALER_DISPCTRL_PANIC1_MASK | SCALER_DISPCTRL_PANIC2_MASK ) ; dispctrl |= VC4_SET_FIELD ( 2 , SCALER_DISPCTRL_PANIC0 ) ; dispctrl |= VC4_SET_FIELD ( 2 , SCALER_DISPCTRL_PANIC1 ) ; dispctrl |= VC4_SET_FIELD ( 2 , SCALER_DISPCTRL_PANIC2 ) ; HVS_WRITE ( SCALER_DISPCTRL , dispctrl ) ; if ( ! vc4 -> is_vc5 ) { reg = 0 ; top = VC4_COB_LINE_WIDTH * VC4_COB_NUM_LINES ; reg |= ( top - 1 ) << 16 ; HVS_WRITE ( SCALER_DISPBASE2 , reg ) ; reg = top ; top += VC4_COB_LINE_WIDTH * VC4_COB_NUM_LINES ; reg |= ( top - 1 ) << 16 ; HVS_WRITE ( SCALER_DISPBASE1 , reg ) ; reg = top ; top = VC4_COB_SIZE ; reg |= ( top - 1 ) << 16 ; HVS_WRITE ( SCALER_DISPBASE0 , reg ) ; } else { reg = 0 ; top = VC5_COB_LINE_WIDTH * VC5_COB_NUM_LINES ; reg |= top << 16 ; HVS_WRITE ( SCALER_DISPBASE2 , reg ) ; top += 16 ; reg = top ; top += VC5_COB_LINE_WIDTH * VC5_COB_NUM_LINES ; reg |= top << 16 ; HVS_WRITE ( SCALER_DISPBASE1 , reg ) ; top += 16 ; reg = top ; top = VC5_COB_SIZE ; reg |= top << 16 ; HVS_WRITE ( SCALER_DISPBASE0 , reg ) ; } ret = devm_request_irq ( dev , platform_get_irq ( pdev , 0 ) , vc4_hvs_irq_handler , 0 , "vc4 hvs" , drm ) ; if ( ret ) { return ret ; } return 0 ; } 