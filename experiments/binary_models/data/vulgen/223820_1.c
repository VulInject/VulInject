apr_status_t ap_queue_create ( fd_queue_t * * pqueue , int capacity , apr_pool_t * p ) { apr_status_t rv ; fd_queue_t * queue ; queue = apr_pcalloc ( p , sizeof queue ) ; if ( ( rv = apr_thread_mutex_create ( & queue -> one_big_mutex , APR_THREAD_MUTEX_DEFAULT , p ) ) != APR_SUCCESS ) { return rv ; } if ( ( rv = apr_thread_cond_create ( & queue -> not_empty , p ) ) != APR_SUCCESS ) { return rv ; } APR_RING_INIT ( & queue -> timers , timer_event_t , link ) ; queue -> data = apr_pcalloc ( p , capacity * sizeof ( fd_queue_elem_t ) ) ; apr_pool_cleanup_register ( p , queue , ap_queue_destroy , apr_pool_cleanup_null ) ; * pqueue = queue ; return APR_SUCCESS ; } 