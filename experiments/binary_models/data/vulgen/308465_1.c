case '/' : if ( * rcp == '*' ) { int c = 0 ; for ( rcp ++ ; * rcp != '/' || c != '*' ; ) { if ( map [ * rcp ] & NEWLINE ) { if ( rcp < limit ) { c = * rcp ; } cp = rcp + 1 ; nextline ( ) ; rcp = cp ; } else { c = * rcp ++ ; } } if ( rcp < limit ) { rcp ++ ; } else { error ( "unclosed comment\n" ) ; } cp = rcp ; continue ; } return '/' ; case '<' : if ( * rcp == '=' ) { return cp ++ , LEQ ; } if ( * rcp == '<' ) { return cp ++ , LSHIFT ; } return '<' ; case '>' : if ( * rcp == '=' ) { return cp ++ , GEQ ; } if ( * rcp == '>' ) { return cp ++ , RSHIFT ; } return '>' ; case '-' : if ( * rcp == '>' ) { return cp ++ , DEREF ; } if ( * rcp == '-' ) { return cp ++ , DECR ; } return '-' ; case '=' : return * rcp == '=' ?cp ++ , EQL : '=' ; case '!' : return * rcp == '=' ?cp ++ , NEQ : '!' ; case '|' : return * rcp == '|' ?cp ++ , OROR : '|' ; case '&' : return * rcp == '&' ?cp ++ , ANDAND : '&' ; case '+' : return * rcp == '+' ?cp ++ , INCR : '+' ; case ';' : case ',' : case ':' : case '*' : case '~' : case '%' : case '^' : case '?' : case '[' : case ']' : case '{' : case '}' : case '(' : case ')' : return rcp [ - 1 ] ; case '\n' : case '\v' : case '\r' : case '\f' : nextline ( ) ; if ( cp == limit ) { tsym = NULL ; return EOI ; } continue ; case 'i' : if ( rcp [ 0 ] == 'f' && ! ( map [ rcp [ 1 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 1 ; return IF ; } if ( rcp [ 0 ] == 'n' && rcp [ 1 ] == 't' && ! ( map [ rcp [ 2 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 2 ; tsym = inttype -> u . sym ; return INT ; } id case 'h' : case 'j' : case 'k' : case 'm' : case 'n' : case 'o' : case 'p' : case 'q' : case 'x' : case 'y' : case 'z' : case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'H' : case 'I' : case 'J' : case 'K' : case 'M' : case 'N' : case 'O' : case 'P' : case 'Q' : case 'R' : case 'S' : case 'T' : case 'U' : case 'V' : case 'W' : case 'X' : case 'Y' : case 'Z' : id if ( limit - rcp < MAXLINE ) { cp = rcp - 1 ; fillbuf ( ) ; rcp = ++ cp ; } assert ( cp == rcp ) ; token = ( char * ) rcp - 1 ; while ( map [ * rcp ] & ( DIGIT | LETTER ) ) { rcp ++ ; } token = stringn ( token , ( char * ) rcp - token ) ; tsym = lookup ( token , identifiers ) ; cp = rcp ; return ID ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : { unsigned long n = 0 ; if ( limit - rcp < MAXLINE ) { cp = rcp - 1 ; fillbuf ( ) ; rcp = ++ cp ; } assert ( cp == rcp ) ; token = ( char * ) rcp - 1 ; if ( * token == '0' && ( * rcp == 'x' || * rcp == 'X' ) ) { int d , overflow = 0 ; while ( * ++ rcp ) { if ( map [ * rcp ] & DIGIT ) { d = * rcp - '0' ; } if ( * rcp >= 'a' && * rcp <= 'f' ) { d = * rcp - 'a' + 10 ; } if ( * rcp >= 'A' && * rcp <= 'F' ) { d = * rcp - 'A' + 10 ; } : { break ; } if ( n & ~ ( ~ 0UL >> 4 ) ) { overflow = 1 ; } else { n = ( n << 4 ) + d ; } } if ( ( char * ) rcp - token <= 2 ) { error ( "invalid hexadecimal constant `%S'\n" , token , ( char * ) rcp - token ) ; } cp = rcp ; tsym = icon ( n , overflow , 16 ) ; } if ( * token == '0' ) { int err = 0 , overflow = 0 ; for ( ; map [ * rcp ] & DIGIT ; rcp ++ ) { if ( * rcp == '8' || * rcp == '9' ) { err = 1 ; } if ( n & ~ ( ~ 0UL >> 3 ) ) { overflow = 1 ; } else { n = ( n << 3 ) + ( * rcp - '0' ) ; } } if ( * rcp == '.' || * rcp == 'e' || * rcp == 'E' ) { cp = rcp ; tsym = fcon ( ) ; return FCON ; } cp = rcp ; tsym = icon ( n , overflow , 8 ) ; if ( err ) { error ( "invalid octal constant `%S'\n" , token , ( char * ) cp - token ) ; } } else { int overflow = 0 ; for ( n = * token - '0' ; map [ * rcp ] & DIGIT ; ) { int d = * rcp ++ - '0' ; if ( n > ( ULONG_MAX - d ) / 10 ) { overflow = 1 ; } else { n = 10 * n + d ; } } if ( * rcp == '.' || * rcp == 'e' || * rcp == 'E' ) { cp = rcp ; tsym = fcon ( ) ; return FCON ; } cp = rcp ; tsym = icon ( n , overflow , 10 ) ; } return ICON ; } case '.' : if ( rcp [ 0 ] == '.' && rcp [ 1 ] == '.' ) { cp += 2 ; return ELLIPSIS ; } if ( ( map [ * rcp ] & DIGIT ) == 0 ) { return '.' ; } if ( limit - rcp < MAXLINE ) { cp = rcp - 1 ; fillbuf ( ) ; rcp = ++ cp ; } assert ( cp == rcp ) ; cp = rcp - 1 ; token = ( char * ) cp ; tsym = fcon ( ) ; return FCON ; case 'L' : if ( * rcp == '\'' ) { unsigned int * s = scon ( * cp , wcput , wcbuf ) ; if ( s - wcbuf > 2 ) { warning ( "excess characters in wide-character literal ignored\n" ) ; } tval . type = widechar ; tval . u . c . v . u = wcbuf [ 0 ] ; tsym = & tval ; return ICON ; } if ( * rcp == '"' ) { unsigned int * s = scon ( * cp , wcput , wcbuf ) ; tval . type = array ( widechar , s - wcbuf , 0 ) ; tval . u . c . v . p = wcbuf ; tsym = & tval ; return SCON ; } else { id } case '\'' : { char * s = scon ( * -- cp , cput , cbuf ) ; if ( s - cbuf > 2 ) { warning ( "excess characters in multibyte character literal ignored\n" ) ; } tval . type = inttype ; if ( chartype -> op == INT ) { tval . u . c . v . i = extend ( cbuf [ 0 ] , chartype ) ; } else { tval . u . c . v . i = cbuf [ 0 ] & 0xFF ; } tsym = & tval ; return ICON ; } case '"' : { char * s = scon ( * -- cp , cput , cbuf ) ; tval . type = array ( chartype , s - cbuf , 0 ) ; tval . u . c . v . p = cbuf ; tsym = & tval ; return SCON ; } case 'a' : if ( rcp [ 0 ] == 'u' && rcp [ 1 ] == 't' && rcp [ 2 ] == 'o' && ! ( map [ rcp [ 3 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 3 ; return AUTO ; } id case 'b' : if ( rcp [ 0 ] == 'r' && rcp [ 1 ] == 'e' && rcp [ 2 ] == 'a' && rcp [ 3 ] == 'k' && ! ( map [ rcp [ 4 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 4 ; return BREAK ; } id case 'c' : if ( rcp [ 0 ] == 'a' && rcp [ 1 ] == 's' && rcp [ 2 ] == 'e' && ! ( map [ rcp [ 3 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 3 ; return CASE ; } if ( rcp [ 0 ] == 'h' && rcp [ 1 ] == 'a' && rcp [ 2 ] == 'r' && ! ( map [ rcp [ 3 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 3 ; tsym = chartype -> u . sym ; return CHAR ; } if ( rcp [ 0 ] == 'o' && rcp [ 1 ] == 'n' && rcp [ 2 ] == 's' && rcp [ 3 ] == 't' && ! ( map [ rcp [ 4 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 4 ; return CONST ; } if ( rcp [ 0 ] == 'o' && rcp [ 1 ] == 'n' && rcp [ 2 ] == 't' && rcp [ 3 ] == 'i' && rcp [ 4 ] == 'n' && rcp [ 5 ] == 'u' && rcp [ 6 ] == 'e' && ! ( map [ rcp [ 7 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 7 ; return CONTINUE ; } id case 'd' : if ( rcp [ 0 ] == 'e' && rcp [ 1 ] == 'f' && rcp [ 2 ] == 'a' && rcp [ 3 ] == 'u' && rcp [ 4 ] == 'l' && rcp [ 5 ] == 't' && ! ( map [ rcp [ 6 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 6 ; return DEFAULT ; } if ( rcp [ 0 ] == 'o' && rcp [ 1 ] == 'u' && rcp [ 2 ] == 'b' && rcp [ 3 ] == 'l' && rcp [ 4 ] == 'e' && ! ( map [ rcp [ 5 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 5 ; tsym = doubletype -> u . sym ; return DOUBLE ; } if ( rcp [ 0 ] == 'o' && ! ( map [ rcp [ 1 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 1 ; return DO ; } id case 'e' : if ( rcp [ 0 ] == 'l' && rcp [ 1 ] == 's' && rcp [ 2 ] == 'e' && ! ( map [ rcp [ 3 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 3 ; return ELSE ; } if ( rcp [ 0 ] == 'n' && rcp [ 1 ] == 'u' && rcp [ 2 ] == 'm' && ! ( map [ rcp [ 3 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 3 ; return ENUM ; } if ( rcp [ 0 ] == 'x' && rcp [ 1 ] == 't' && rcp [ 2 ] == 'e' && rcp [ 3 ] == 'r' && rcp [ 4 ] == 'n' && ! ( map [ rcp [ 5 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 5 ; return EXTERN ; } id case 'f' : if ( rcp [ 0 ] == 'l' && rcp [ 1 ] == 'o' && rcp [ 2 ] == 'a' && rcp [ 3 ] == 't' && ! ( map [ rcp [ 4 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 4 ; tsym = floattype -> u . sym ; return FLOAT ; } if ( rcp [ 0 ] == 'o' && rcp [ 1 ] == 'r' && ! ( map [ rcp [ 2 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 2 ; return FOR ; } id case 'g' : if ( rcp [ 0 ] == 'o' && rcp [ 1 ] == 't' && rcp [ 2 ] == 'o' && ! ( map [ rcp [ 3 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 3 ; return GOTO ; } id case 'l' : if ( rcp [ 0 ] == 'o' && rcp [ 1 ] == 'n' && rcp [ 2 ] == 'g' && ! ( map [ rcp [ 3 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 3 ; return LONG ; } id case 'r' : if ( rcp [ 0 ] == 'e' && rcp [ 1 ] == 'g' && rcp [ 2 ] == 'i' && rcp [ 3 ] == 's' && rcp [ 4 ] == 't' && rcp [ 5 ] == 'e' && rcp [ 6 ] == 'r' && ! ( map [ rcp [ 7 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 7 ; return REGISTER ; } if ( rcp [ 0 ] == 'e' && rcp [ 1 ] == 't' && rcp [ 2 ] == 'u' && rcp [ 3 ] == 'r' && rcp [ 4 ] == 'n' && ! ( map [ rcp [ 5 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 5 ; return RETURN ; } id case 's' : if ( rcp [ 0 ] == 'h' && rcp [ 1 ] == 'o' && rcp [ 2 ] == 'r' && rcp [ 3 ] == 't' && ! ( map [ rcp [ 4 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 4 ; return SHORT ; } if ( rcp [ 0 ] == 'i' && rcp [ 1 ] == 'g' && rcp [ 2 ] == 'n' && rcp [ 3 ] == 'e' && rcp [ 4 ] == 'd' && ! ( map [ rcp [ 5 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 5 ; return SIGNED ; } if ( rcp [ 0 ] == 'i' && rcp [ 1 ] == 'z' && rcp [ 2 ] == 'e' && rcp [ 3 ] == 'o' && rcp [ 4 ] == 'f' && ! ( map [ rcp [ 5 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 5 ; return SIZEOF ; } if ( rcp [ 0 ] == 't' && rcp [ 1 ] == 'a' && rcp [ 2 ] == 't' && rcp [ 3 ] == 'i' && rcp [ 4 ] == 'c' && ! ( map [ rcp [ 5 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 5 ; return STATIC ; } if ( rcp [ 0 ] == 't' && rcp [ 1 ] == 'r' && rcp [ 2 ] == 'u' && rcp [ 3 ] == 'c' && rcp [ 4 ] == 't' && ! ( map [ rcp [ 5 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 5 ; return STRUCT ; } if ( rcp [ 0 ] == 'w' && rcp [ 1 ] == 'i' && rcp [ 2 ] == 't' && rcp [ 3 ] == 'c' && rcp [ 4 ] == 'h' && ! ( map [ rcp [ 5 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 5 ; return SWITCH ; } id case 't' : if ( rcp [ 0 ] == 'y' && rcp [ 1 ] == 'p' && rcp [ 2 ] == 'e' && rcp [ 3 ] == 'd' && rcp [ 4 ] == 'e' && rcp [ 5 ] == 'f' && ! ( map [ rcp [ 6 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 6 ; return TYPEDEF ; } id case 'u' : if ( rcp [ 0 ] == 'n' && rcp [ 1 ] == 'i' && rcp [ 2 ] == 'o' && rcp [ 3 ] == 'n' && ! ( map [ rcp [ 4 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 4 ; return UNION ; } if ( rcp [ 0 ] == 'n' && rcp [ 1 ] == 's' && rcp [ 2 ] == 'i' && rcp [ 3 ] == 'g' && rcp [ 4 ] == 'n' && rcp [ 5 ] == 'e' && rcp [ 6 ] == 'd' && ! ( map [ rcp [ 7 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 7 ; return UNSIGNED ; } id case 'v' : if ( rcp [ 0 ] == 'o' && rcp [ 1 ] == 'i' && rcp [ 2 ] == 'd' && ! ( map [ rcp [ 3 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 3 ; tsym = voidtype -> u . sym ; return VOID ; } if ( rcp [ 0 ] == 'o' && rcp [ 1 ] == 'l' && rcp [ 2 ] == 'a' && rcp [ 3 ] == 't' && rcp [ 4 ] == 'i' && rcp [ 5 ] == 'l' && rcp [ 6 ] == 'e' && ! ( map [ rcp [ 7 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 7 ; return VOLATILE ; } id case 'w' : if ( rcp [ 0 ] == 'h' && rcp [ 1 ] == 'i' && rcp [ 2 ] == 'l' && rcp [ 3 ] == 'e' && ! ( map [ rcp [ 4 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 4 ; return WHILE ; } id case '_' : if ( rcp [ 0 ] == '_' && rcp [ 1 ] == 't' && rcp [ 2 ] == 'y' && rcp [ 3 ] == 'p' && rcp [ 4 ] == 'e' && rcp [ 5 ] == 'c' && rcp [ 6 ] == 'o' && rcp [ 7 ] == 'd' && rcp [ 8 ] == 'e' && ! ( map [ rcp [ 9 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 9 ; return TYPECODE ; } if ( rcp [ 0 ] == '_' && rcp [ 1 ] == 'f' && rcp [ 2 ] == 'i' && rcp [ 3 ] == 'r' && rcp [ 4 ] == 's' && rcp [ 5 ] == 't' && rcp [ 6 ] == 'a' && rcp [ 7 ] == 'r' && rcp [ 8 ] == 'g' && ! ( map [ rcp [ 9 ] ] & ( DIGIT | LETTER ) ) ) { cp = rcp + 9 ; return FIRSTARG ; } id default : if ( ( map [ cp [ - 1 ] ] & BLANK ) == 0 ) { if ( cp [ - 1 ] < ' ' || cp [ - 1 ] >= 0177 ) { error ( "illegal character `\\0%o'\n" , cp [ - 1 ] ) ; } else { error ( "illegal character `%c'\n" , cp [ - 1 ] ) ; } } 