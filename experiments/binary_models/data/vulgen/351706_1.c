void spawn_init ( void ) { struct completion completion ; int error ; info ( "Initializing spawn client." ) ; init_spawn_cmd_queue ( ) ; completion_init ( & completion ) ; error = uv_thread_create ( & thread , spawn_client , & completion ) ; if ( error ) { error ( "uv_thread_create(): %s" , uv_strerror ( error ) ) ; after_error } completion_wait_for ( & completion ) ; completion_destroy ( & completion ) ; uv_thread_set_name_np ( thread , "DAEMON_SPAWN" ) ; if ( spawn_thread_error ) { error = uv_thread_join ( & thread ) ; after_error } signals_reset ( ) ; signals_unblock ( ) ; sleep ( 60 ) ; uint64_t serial [ CONCURRENT_SPAWNS ] ; for ( int j = 0 ; j < SPAWN_ITERATIONS ; ++ j ) { for ( int i = 0 ; i < CONCURRENT_SPAWNS ; ++ i ) { char cmd [ 64 ] ; sprintf ( cmd , "echo CONCURRENT_STRESS_TEST %d 1>&2" , j * CONCURRENT_SPAWNS + i + 1 ) ; serial [ i ] = spawn_enq_cmd ( cmd ) ; info ( "Queued command %s for spawning." , cmd ) ; } int exit_status ; time_t exec_run_timestamp ; for ( int i = 0 ; i < CONCURRENT_SPAWNS ; ++ i ) { info ( "Started waiting for serial %llu exit status %d run timestamp %llu." , serial [ i ] , exit_status , exec_run_timestamp ) ; spawn_wait_cmd ( serial [ i ] , & exit_status , & exec_run_timestamp ) ; info ( "Finished waiting for serial %llu exit status %d run timestamp %llu." , serial [ i ] , exit_status , exec_run_timestamp ) ; } } exit ( 0 ) ; return ; after_error error ( "Failed to initialize spawn service. The alarms notifications will not be spawned." ) ; } 