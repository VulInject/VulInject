static int ppb_attach ( dev_info_t * devi , ddi_attach_cmd_t cmd ) { dev_info_t * root = ddi_root_node ( ) ; int instance ; ppb_devstate_t * ppb ; dev_info_t * pdip ; ddi_acc_handle_t config_handle ; char * bus ; switch ( cmd ) { case DDI_ATTACH : ( void ) ddi_prop_update_string ( DDI_DEV_T_NONE , devi , "device_type" , "pci" ) ; instance = ddi_get_instance ( devi ) ; if ( ddi_soft_state_zalloc ( ppb_state , instance ) != DDI_SUCCESS ) { return ( DDI_FAILURE ) ; } ppb = ( ppb_devstate_t * ) ddi_get_soft_state ( ppb_state , instance ) ; ppb -> dip = devi ; ppb -> ppb_soft_state = PCI_SOFT_STATE_CLOSED ; if ( pci_config_setup ( devi , & config_handle ) != DDI_SUCCESS ) { mutex_destroy ( & ppb -> ppb_mutex ) ; ddi_soft_state_free ( ppb_state , instance ) ; return ( DDI_FAILURE ) ; } ppb_pwr_setup ( ppb , devi ) ; if ( PM_CAPABLE ( ppb -> ppb_pwr_p ) ) { mutex_enter ( & ppb -> ppb_pwr_p -> pwr_mutex ) ; ppb -> ppb_pwr_p -> pwr_fp ++ ; pci_pwr_change ( ppb -> ppb_pwr_p , ppb -> ppb_pwr_p -> current_lvl , pci_pwr_new_lvl ( ppb -> ppb_pwr_p ) ) ; } ppb -> ppb_cache_line_size = pci_config_get8 ( config_handle , PCI_CONF_CACHE_LINESZ ) ; ppb -> ppb_latency_timer = pci_config_get8 ( config_handle , PCI_CONF_LATENCY_TIMER ) ; if ( ddi_prop_exists ( DDI_DEV_T_ANY , devi , DDI_PROP_DONTPASS , "ranges" ) == 0 ) { ppb_create_ranges_prop ( devi , config_handle ) ; } pci_config_teardown ( & config_handle ) ; if ( PM_CAPABLE ( ppb -> ppb_pwr_p ) ) { ppb -> ppb_pwr_p -> pwr_fp -- ; pci_pwr_change ( ppb -> ppb_pwr_p , ppb -> ppb_pwr_p -> current_lvl , pci_pwr_new_lvl ( ppb -> ppb_pwr_p ) ) ; mutex_exit ( & ppb -> ppb_pwr_p -> pwr_mutex ) ; } ppb -> parent_bus = PCIE_PCIECAP_DEV_TYPE_PCI_PSEUDO ; for ( pdip = ddi_get_parent ( ppb -> dip ) ; pdip && ( pdip != root ) && ( ppb -> parent_bus != PCIE_PCIECAP_DEV_TYPE_PCIE_DEV ) ; pdip = ddi_get_parent ( pdip ) ) { if ( ddi_prop_lookup_string ( DDI_DEV_T_ANY , pdip , DDI_PROP_DONTPASS , "device_type" , & bus ) != DDI_PROP_SUCCESS ) { break ; } if ( strcmp ( bus , "pciex" ) == 0 ) { ppb -> parent_bus = PCIE_PCIECAP_DEV_TYPE_PCIE_DEV ; } ddi_prop_free ( bus ) ; } if ( ppb -> parent_bus == PCIE_PCIECAP_DEV_TYPE_PCIE_DEV ) { if ( pcie_init ( devi , NULL ) != DDI_SUCCESS ) { ( void ) ppb_detach ( devi , DDI_DETACH ) ; return ( DDI_FAILURE ) ; } else { ppb_init_hotplug ( ppb ) ; } } DEBUG1 ( DBG_ATTACH , devi , "ppb_attach(): this nexus %s hotplug slots\n" , ppb -> hotplug_capable == B_TRUE ?"has" : "has no" ) ; ppb_fm_init ( ppb ) ; ddi_report_dev ( devi ) ; return ( DDI_SUCCESS ) ; case DDI_RESUME : ppb = ( ppb_devstate_t * ) ddi_get_soft_state ( ppb_state , ddi_get_instance ( devi ) ) ; pci_pwr_resume ( devi , ppb -> ppb_pwr_p ) ; return ( DDI_SUCCESS ) ; } return ( DDI_FAILURE ) ; } 