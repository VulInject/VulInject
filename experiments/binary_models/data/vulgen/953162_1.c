static VacAttrStats * examine_expression ( Node * expr , int stattarget ) { HeapTuple typtuple ; VacAttrStats * stats ; int i ; bool ok ; Assert ( expr != NULL ) ; stats = ( VacAttrStats * ) palloc0 ( sizeof ( VacAttrStats ) ) ; stats -> attrtypid = exprType ( expr ) ; stats -> attrtypmod = exprTypmod ( expr ) ; stats -> attrcollid = exprCollation ( expr ) ; stats -> attr = ( Form_pg_attribute ) palloc ( ATTRIBUTE_FIXED_PART_SIZE ) ; stats -> attr -> attstattarget = stattarget ; stats -> attr -> attrelid = InvalidOid ; stats -> attr -> attnum = InvalidAttrNumber ; stats -> attr -> atttypid = stats -> attrtypid ; typtuple = SearchSysCacheCopy1 ( TYPEOID , ObjectIdGetDatum ( stats -> attrtypid ) ) ; if ( ! HeapTupleIsValid ( typtuple ) ) { elog ( ERROR , "cache lookup failed for type %u" , stats -> attrtypid ) ; } stats -> attrtype = ( Form_pg_type ) GETSTRUCT ( typtuple ) ; stats -> anl_context = CurrentMemoryContext ; stats -> tupattnum = InvalidAttrNumber ; for ( i = 0 ; i < STATISTIC_NUM_SLOTS ; i ++ ) { stats -> statypid [ i ] = stats -> attrtypid ; stats -> statyplen [ i ] = stats -> attrtype -> typlen ; stats -> statypbyval [ i ] = stats -> attrtype -> typbyval ; stats -> statypalign [ i ] = stats -> attrtype -> typalign ; } if ( OidIsValid ( stats -> attrtype -> typanalyze ) ) { ok = DatumGetBool ( OidFunctionCall1 ( stats -> attrtype -> typanalyze , PointerGetDatum ( stats ) ) ) ; } else { ok = std_typanalyze ( stats ) ; } if ( ! ok || stats -> compute_stats == NULL || stats -> minrows <= 0 ) { heap_freetuple ( typtuple ) ; return NULL ; } return stats ; } 