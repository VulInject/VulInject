void __iomem * __ioremap ( unsigned long physaddr , unsigned long size , int cacheflag ) { struct vm_struct * area ; unsigned long virtaddr , retaddr ; long offset ; pgd_t * pgd_dir ; p4d_t * p4d_dir ; pud_t * pud_dir ; pmd_t * pmd_dir ; pte_t * pte_dir ; if ( MACH_IS_AMIGA ) { if ( ( physaddr >= 0x40000000 ) && ( physaddr + size < 0x60000000 ) && ( cacheflag == IOMAP_NOCACHE_SER ) ) { return ( void __iomem * ) physaddr ; } } if ( MACH_IS_VIRT ) { if ( physaddr >= 0xff000000 && cacheflag == IOMAP_NOCACHE_SER ) { return ( void __iomem * ) physaddr ; } } if ( __cf_internalio ( physaddr ) ) { return ( void __iomem * ) physaddr ; } printk ( "ioremap: 0x%lx,0x%lx(%d) - " , physaddr , size , cacheflag ) ; offset = physaddr & ( IO_SIZE - 1 ) ; physaddr &= - IO_SIZE ; size = ( size + offset + IO_SIZE - 1 ) & - IO_SIZE ; area = get_io_area ( size ) ; if ( ! area ) { return NULL ; } virtaddr = ( unsigned long ) area -> addr ; retaddr = virtaddr + offset ; printk ( "0x%lx,0x%lx,0x%lx" , physaddr , virtaddr , retaddr ) ; if ( CPU_IS_040_OR_060 ) { physaddr |= ( _PAGE_PRESENT | _PAGE_GLOBAL040 | _PAGE_ACCESSED | _PAGE_DIRTY ) ; switch ( cacheflag ) { case IOMAP_FULL_CACHING : physaddr |= _PAGE_CACHE040 ; break ; case IOMAP_NOCACHE_SER : default : physaddr |= _PAGE_NOCACHE_S ; break ; case IOMAP_NOCACHE_NONSER : physaddr |= _PAGE_NOCACHE ; break ; case IOMAP_WRITETHROUGH : physaddr |= _PAGE_CACHE040W ; break ; } } else { physaddr |= ( _PAGE_PRESENT | _PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_READWRITE ) ; switch ( cacheflag ) { case IOMAP_NOCACHE_SER : case IOMAP_NOCACHE_NONSER : default : physaddr |= _PAGE_NOCACHE030 ; break ; case IOMAP_FULL_CACHING : case IOMAP_WRITETHROUGH : break ; } } while ( ( long ) size > 0 ) { if ( ! ( virtaddr & ( PMD_SIZE - 1 ) ) ) { printk ( "\npa=%#lx va=%#lx " , physaddr , virtaddr ) ; } pgd_dir = pgd_offset_k ( virtaddr ) ; p4d_dir = p4d_offset ( pgd_dir , virtaddr ) ; pud_dir = pud_offset ( p4d_dir , virtaddr ) ; pmd_dir = pmd_alloc ( & init_mm , pud_dir , virtaddr ) ; if ( ! pmd_dir ) { printk ( "ioremap: no mem for pmd_dir\n" ) ; return NULL ; } if ( CPU_IS_020_OR_030 ) { pmd_val ( * pmd_dir ) = physaddr ; physaddr += PMD_SIZE ; virtaddr += PMD_SIZE ; size -= PMD_SIZE ; } else { pte_dir = pte_alloc_kernel ( pmd_dir , virtaddr ) ; if ( ! pte_dir ) { printk ( "ioremap: no mem for pte_dir\n" ) ; return NULL ; } pte_val ( * pte_dir ) = physaddr ; virtaddr += PAGE_SIZE ; physaddr += PAGE_SIZE ; size -= PAGE_SIZE ; } } printk ( "\n" ) ; flush_tlb_all ( ) ; return ( void __iomem * ) retaddr ; } 