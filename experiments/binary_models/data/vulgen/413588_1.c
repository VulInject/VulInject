load_resource_1007 ( , , , , ) { DisplayInfo dsp_info ; CMColor ps_color ; GimpRGB gimp_rgb ; GimpHSV gimp_hsv ; GimpCMYK gimp_cmyk ; gint16 tot_rec ; gint cidx ; IFDBG ( 2 ) g_debug ( "Process image resource block 1007: Display Info" ) ; tot_rec = res_a -> data_len / 14 ; if ( tot_rec == 0 ) { return 0 ; } img_a -> alpha_display_count = tot_rec ; for ( cidx = 0 ; cidx < tot_rec ; ++ cidx ) { if ( psd_read ( input , & dsp_info . colorSpace , 2 , error ) < 2 || psd_read ( input , & dsp_info . color , 8 , error ) < 8 || psd_read ( input , & dsp_info . opacity , 2 , error ) < 2 || psd_read ( input , & dsp_info . kind , 1 , error ) < 1 || psd_read ( input , & dsp_info . padding , 1 , error ) < 1 ) { psd_set_error ( error ) ; return - 1 ; } dsp_info . colorSpace = GINT16_FROM_BE ( dsp_info . colorSpace ) ; ps_color . cmyk . cyan = GUINT16_FROM_BE ( dsp_info . color [ 0 ] ) ; ps_color . cmyk . magenta = GUINT16_FROM_BE ( dsp_info . color [ 1 ] ) ; ps_color . cmyk . yellow = GUINT16_FROM_BE ( dsp_info . color [ 2 ] ) ; ps_color . cmyk . black = GUINT16_FROM_BE ( dsp_info . color [ 3 ] ) ; dsp_info . opacity = GINT16_FROM_BE ( dsp_info . opacity ) ; switch ( dsp_info . colorSpace ) { case PSD_CS_RGB : gimp_rgb_set ( & gimp_rgb , ps_color . rgb . red / 65535.0 , ps_color . rgb . green / 65535.0 , ps_color . rgb . blue / 65535.0 ) ; break ; case PSD_CS_HSB : gimp_hsv_set ( & gimp_hsv , ps_color . hsv . hue / 65535.0 , ps_color . hsv . saturation / 65535.0 , ps_color . hsv . value / 65535.0 ) ; gimp_hsv_to_rgb ( & gimp_hsv , & gimp_rgb ) ; break ; case PSD_CS_CMYK : gimp_cmyk_set ( & gimp_cmyk , 1.0 - ps_color . cmyk . cyan / 65535.0 , 1.0 - ps_color . cmyk . magenta / 65535.0 , 1.0 - ps_color . cmyk . yellow / 65535.0 , 1.0 - ps_color . cmyk . black / 65535.0 ) ; gimp_cmyk_to_rgb ( & gimp_cmyk , & gimp_rgb ) ; break ; case PSD_CS_GRAYSCALE : gimp_rgb_set ( & gimp_rgb , ps_color . gray . gray / 10000.0 , ps_color . gray . gray / 10000.0 , ps_color . gray . gray / 10000.0 ) ; break ; case PSD_CS_FOCOLTONE : case PSD_CS_TRUMATCH : case PSD_CS_HKS : case PSD_CS_LAB : case PSD_CS_PANTONE : case PSD_CS_TOYO : case PSD_CS_DIC : case PSD_CS_ANPA : default : if ( CONVERSION_WARNINGS ) { g_message ( "Unsupported color space: %d" , dsp_info . colorSpace ) ; } gimp_rgb_set ( & gimp_rgb , 1.0 , 0.0 , 0.0 ) ; } gimp_rgb_set_alpha ( & gimp_rgb , 1.0 ) ; IFDBG ( 2 ) g_debug ( "PS cSpace: %d, col: %d %d %d %d, opacity: %d, kind: %d" , dsp_info . colorSpace , ps_color . cmyk . cyan , ps_color . cmyk . magenta , ps_color . cmyk . yellow , ps_color . cmyk . black , dsp_info . opacity , dsp_info . kind ) ; IFDBG ( 2 ) g_debug ( "cSpace: %d, col: %g %g %g, opacity: %d, kind: %d" , dsp_info . colorSpace , gimp_rgb . r * 255 , gimp_rgb . g * 255 , gimp_rgb . b * 255 , dsp_info . opacity , dsp_info . kind ) ; img_a -> alpha_display_info [ cidx ] = g_malloc0 ( sizeof ( PSDchanneldata ) ) ; img_a -> alpha_display_info [ cidx ] -> gimp_color = gimp_rgb ; img_a -> alpha_display_info [ cidx ] -> opacity = dsp_info . opacity ; img_a -> alpha_display_info [ cidx ] -> ps_kind = dsp_info . kind ; img_a -> alpha_display_info [ cidx ] -> ps_cspace = dsp_info . colorSpace ; img_a -> alpha_display_info [ cidx ] -> ps_color = ps_color ; } return 0 ; } 