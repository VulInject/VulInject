static void * rrpc_init ( struct nvm_tgt_dev * dev , struct gendisk * tdisk , int flags ) { struct request_queue * bqueue = dev -> q ; struct request_queue * tqueue = tdisk -> queue ; struct nvm_geo * geo = & dev -> geo ; struct rrpc * rrpc ; sector_t soffset ; int ret ; if ( ! ( dev -> identity . dom & NVM_RSP_L2P ) ) { pr_err ( "nvm: rrpc: device does not support l2p (%x)\n" , dev -> identity . dom ) ; return ERR_PTR ( - EINVAL ) ; } rrpc = kzalloc ( sizeof ( rrpc ) , GFP_KERNEL ) ; if ( ! rrpc ) { return ERR_PTR ( - ENOMEM ) ; } rrpc -> dev = dev ; bio_list_init ( & rrpc -> requeue_bios ) ; spin_lock_init ( & rrpc -> bio_lock ) ; INIT_WORK ( & rrpc -> ws_requeue , rrpc_requeue ) ; rrpc -> nr_luns = geo -> nr_luns ; rrpc -> nr_sects = ( unsigned long long ) geo -> sec_per_lun * rrpc -> nr_luns ; atomic_set ( & rrpc -> next_lun , - 1 ) ; ret = rrpc_area_init ( rrpc , & soffset ) ; if ( ret < 0 ) { pr_err ( "nvm: rrpc: could not initialize area\n" ) ; return ERR_PTR ( ret ) ; } rrpc -> soffset = soffset ; ret = rrpc_luns_init ( rrpc , dev -> luns ) ; if ( ret ) { pr_err ( "nvm: rrpc: could not initialize luns\n" ) ; err } ret = rrpc_core_init ( rrpc ) ; if ( ret ) { pr_err ( "nvm: rrpc: could not initialize core\n" ) ; err } ret = rrpc_map_init ( rrpc ) ; if ( ret ) { pr_err ( "nvm: rrpc: could not initialize maps\n" ) ; err } ret = rrpc_blocks_init ( rrpc ) ; if ( ret ) { pr_err ( "nvm: rrpc: could not initialize state for blocks\n" ) ; err } ret = rrpc_luns_configure ( rrpc ) ; if ( ret ) { pr_err ( "nvm: rrpc: not enough blocks available in LUNs.\n" ) ; err } ret = rrpc_gc_init ( rrpc ) ; if ( ret ) { pr_err ( "nvm: rrpc: could not initialize gc\n" ) ; err } blk_queue_logical_block_size ( tqueue , queue_physical_block_size ( bqueue ) ) ; blk_queue_max_hw_sectors ( tqueue , queue_max_hw_sectors ( bqueue ) ) ; pr_info ( "nvm: rrpc initialized with %u luns and %llu pages.\n" , rrpc -> nr_luns , ( unsigned long long ) rrpc -> nr_sects ) ; mod_timer ( & rrpc -> gc_timer , jiffies + msecs_to_jiffies ( 10 ) ) ; return rrpc ; err rrpc_free ( rrpc ) ; return ERR_PTR ( ret ) ; } 