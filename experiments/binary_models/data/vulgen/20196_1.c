static struct z8530_dev * sv11_init ( int iobase , int irq ) { struct z8530_dev * sv ; struct net_device * netdev ; if ( ! request_region ( iobase , 8 , "Comtrol SV11" ) ) { pr_warn ( "I/O 0x%X already in use\n" , iobase ) ; return NULL ; } sv = kzalloc ( sizeof ( z8530_dev ) , GFP_KERNEL ) ; if ( ! sv ) { err_kzalloc } sv -> chanA . ctrlio = iobase + 1 ; sv -> chanA . dataio = iobase + 3 ; sv -> chanB . ctrlio = - 1 ; sv -> chanB . dataio = - 1 ; sv -> chanA . irqs = & z8530_nop ; sv -> chanB . irqs = & z8530_nop ; outb ( 0 , iobase + 4 ) ; if ( request_irq ( irq , z8530_interrupt , 0 , "Hostess SV11" , sv ) < 0 ) { pr_warn ( "IRQ %d already in use\n" , irq ) ; err_irq } sv -> irq = irq ; sv -> chanA . private = sv ; sv -> chanA . dev = sv ; sv -> chanB . dev = sv ; if ( dma ) { sv -> chanA . txdma = 3 ; sv -> chanA . rxdma = 1 ; outb ( 0x03 | 0x08 , iobase + 4 ) ; if ( request_dma ( sv -> chanA . txdma , "Hostess SV/11 (TX)" ) ) { err_txdma } if ( dma == 1 ) { if ( request_dma ( sv -> chanA . rxdma , "Hostess SV/11 (RX)" ) ) { err_rxdma } } } disable_irq ( irq ) ; if ( z8530_init ( sv ) ) { pr_err ( "Z8530 series device not found\n" ) ; enable_irq ( irq ) ; free_dma } z8530_channel_load ( & sv -> chanB , z8530_dead_port ) ; if ( sv -> type == Z85C30 ) { z8530_channel_load ( & sv -> chanA , z8530_hdlc_kilostream ) ; } else { z8530_channel_load ( & sv -> chanA , z8530_hdlc_kilostream_85230 ) ; } enable_irq ( irq ) ; sv -> chanA . netdevice = netdev = alloc_hdlcdev ( sv ) ; if ( ! netdev ) { free_dma } dev_to_hdlc ( netdev ) -> attach = hostess_attach ; dev_to_hdlc ( netdev ) -> xmit = hostess_queue_xmit ; netdev -> netdev_ops = & hostess_ops ; netdev -> base_addr = iobase ; netdev -> irq = irq ; if ( register_hdlc_device ( netdev ) ) { pr_err ( "unable to register HDLC device\n" ) ; free_netdev ( netdev ) ; free_dma } z8530_describe ( sv , "I/O" , iobase ) ; sv -> active = 1 ; return sv ; free_dma if ( dma == 1 ) { free_dma ( sv -> chanA . rxdma ) ; } err_rxdma if ( dma ) { free_dma ( sv -> chanA . txdma ) ; } err_txdma free_irq ( irq , sv ) ; err_irq kfree ( sv ) ; err_kzalloc release_region ( iobase , 8 ) ; return NULL ; } 