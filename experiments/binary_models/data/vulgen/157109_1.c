static void rsxx_issue_dmas ( struct rsxx_dma_ctrl * ctrl ) { struct rsxx_dma * dma ; int tag ; int cmds_pending = 0 ; struct hw_cmd * hw_cmd_buf ; int dir ; hw_cmd_buf = ctrl -> cmd . buf ; while ( 1 ) { spin_lock_bh ( & ctrl -> queue_lock ) ; if ( list_empty ( & ctrl -> queue ) ) { spin_unlock_bh ( & ctrl -> queue_lock ) ; break ; } spin_unlock_bh ( & ctrl -> queue_lock ) ; tag = pop_tracker ( ctrl -> trackers ) ; if ( tag == - 1 ) { break ; } spin_lock_bh ( & ctrl -> queue_lock ) ; dma = list_entry ( ctrl -> queue . next , rsxx_dma , list ) ; list_del ( & dma -> list ) ; ctrl -> stats . sw_q_depth -- ; spin_unlock_bh ( & ctrl -> queue_lock ) ; if ( unlikely ( ctrl -> card -> dma_fault ) ) { push_tracker ( ctrl -> trackers , tag ) ; rsxx_complete_dma ( ctrl , dma , DMA_CANCELLED ) ; continue ; } if ( dma -> cmd != HW_CMD_BLK_DISCARD ) { if ( dma -> cmd == HW_CMD_BLK_WRITE ) { dir = PCI_DMA_TODEVICE ; } else { dir = PCI_DMA_FROMDEVICE ; } dma -> dma_addr = pci_map_page ( ctrl -> card -> dev , dma -> page , dma -> pg_off , dma -> sub_page . cnt << 9 , dir ) ; if ( pci_dma_mapping_error ( ctrl -> card -> dev , dma -> dma_addr ) ) { push_tracker ( ctrl -> trackers , tag ) ; rsxx_complete_dma ( ctrl , dma , DMA_CANCELLED ) ; continue ; } } set_tracker_dma ( ctrl -> trackers , tag , dma ) ; hw_cmd_buf [ ctrl -> cmd . idx ] . command = dma -> cmd ; hw_cmd_buf [ ctrl -> cmd . idx ] . tag = tag ; hw_cmd_buf [ ctrl -> cmd . idx ] . _rsvd = 0 ; hw_cmd_buf [ ctrl -> cmd . idx ] . sub_page = ( ( dma -> sub_page . cnt & 0x7 ) << 4 ) | ( dma -> sub_page . off & 0x7 ) ; hw_cmd_buf [ ctrl -> cmd . idx ] . device_addr = cpu_to_le32 ( dma -> laddr ) ; hw_cmd_buf [ ctrl -> cmd . idx ] . host_addr = cpu_to_le64 ( dma -> dma_addr ) ; dev_dbg ( CARD_TO_DEV ( ctrl -> card ) , "Issue DMA%d(laddr %d tag %d) to idx %d\n" , ctrl -> id , dma -> laddr , tag , ctrl -> cmd . idx ) ; ctrl -> cmd . idx = ( ctrl -> cmd . idx + 1 ) & RSXX_CS_IDX_MASK ; cmds_pending ++ ; if ( dma -> cmd == HW_CMD_BLK_WRITE ) { ctrl -> stats . writes_issued ++ ; } if ( dma -> cmd == HW_CMD_BLK_DISCARD ) { ctrl -> stats . discards_issued ++ ; } else { ctrl -> stats . reads_issued ++ ; } } if ( cmds_pending ) { atomic_add ( cmds_pending , & ctrl -> stats . hw_q_depth ) ; mod_timer ( & ctrl -> activity_timer , jiffies + DMA_ACTIVITY_TIMEOUT ) ; if ( unlikely ( ctrl -> card -> eeh_state ) ) { del_timer_sync ( & ctrl -> activity_timer ) ; return ; } iowrite32 ( ctrl -> cmd . idx , ctrl -> regmap + SW_CMD_IDX ) ; } } 