static const char * _set_job_msg ( job_desc_msg_t * job_msg , const char * new_text , int column ) { char * type = "" ; int temp_int = 0 ; long long int temp_ll = 0 ; char * p ; char * token ; char * sep_char ; int j ; global_edit_error = 0 ; if ( ! job_msg ) { return NULL ; } switch ( column ) { case SORTID_ACTION : if ( ! xstrcasecmp ( new_text , "None" ) ) { got_edit_signal = NULL ; } else { got_edit_signal = xstrdup ( new_text ) ; } break ; case SORTID_COMMENT : job_msg -> comment = xstrdup ( new_text ) ; type = "comment" ; break ; case SORTID_TIMELIMIT : if ( ! xstrcasecmp ( new_text , "infinite" ) ) { temp_int = INFINITE ; } else { temp_int = time_str2mins ( ( char * ) new_text ) ; } type = "timelimit" ; if ( temp_int <= 0 && temp_int != INFINITE ) { return_error } job_msg -> time_limit = ( uint32_t ) temp_int ; break ; case SORTID_PRIORITY : if ( ! xstrcasecmp ( new_text , "infinite" ) ) { temp_int = INFINITE ; } else { temp_int = strtol ( new_text , ( char * * ) NULL , 10 ) ; } type = "priority" ; if ( ( temp_int < 0 ) && ( temp_int != INFINITE ) ) { return_error } job_msg -> priority = ( uint32_t ) temp_int ; break ; case SORTID_NICE : temp_int = strtol ( new_text , ( char * * ) NULL , 10 ) ; type = "nice" ; if ( abs ( temp_int ) > NICE_OFFSET ) { return_error } job_msg -> nice = NICE_OFFSET + temp_int ; break ; case SORTID_CPU_REQ : temp_int = strtol ( new_text , & p , 10 ) ; if ( * p == 'k' || * p == 'K' ) { temp_int *= 1024 ; } if ( * p == 'm' || * p == 'M' ) { temp_int *= 1048576 ; } type = "min cpus per node" ; if ( temp_int <= 0 ) { return_error } job_msg -> pn_min_cpus = ( uint32_t ) temp_int ; break ; case SORTID_TASKS : temp_int = strtol ( new_text , ( char * * ) NULL , 10 ) ; type = "requested tasks" ; if ( temp_int <= 0 ) { return_error } job_msg -> num_tasks = ( uint32_t ) temp_int ; break ; case SORTID_CPUS_PER_TASK : temp_int = strtol ( new_text , ( char * * ) NULL , 10 ) ; type = "cpus per task" ; if ( temp_int <= 0 ) { return_error } job_msg -> cpus_per_task = ( uint32_t ) temp_int ; break ; case SORTID_RESV_NAME : job_msg -> reservation = xstrdup ( new_text ) ; type = "reservation name" ; break ; case SORTID_NODES_MIN : temp_int = strtol ( new_text , & p , 10 ) ; if ( * p == 'k' || * p == 'K' ) { temp_int *= 1024 ; } if ( * p == 'm' || * p == 'M' ) { temp_int *= 1048576 ; } type = "min nodes" ; if ( temp_int <= 0 ) { return_error } job_msg -> min_nodes = ( uint32_t ) temp_int ; break ; case SORTID_NODES : temp_int = strtol ( new_text , & p , 10 ) ; if ( * p == 'k' || * p == 'K' ) { temp_int *= 1024 ; } if ( * p == 'm' || * p == 'M' ) { temp_int *= 1048576 ; } type = "node count" ; if ( temp_int <= 0 ) { return_error } job_msg -> min_nodes = job_msg -> max_nodes = ( uint32_t ) temp_int ; break ; case SORTID_NODES_MAX : temp_int = strtol ( new_text , & p , 10 ) ; if ( * p == 'k' || * p == 'K' ) { temp_int *= 1024 ; } if ( * p == 'm' || * p == 'M' ) { temp_int *= 1048576 ; } type = "max nodes" ; if ( temp_int <= 0 ) { return_error } job_msg -> max_nodes = ( uint32_t ) temp_int ; break ; case SORTID_MEM_MIN : temp_ll = strtoll ( new_text , & p , 10 ) ; if ( * p == 'g' || * p == 'G' ) { temp_ll *= 1024 ; } if ( * p == 't' || * p == 'T' ) { temp_ll *= 1048576 ; } p = xstrcasestr ( ( char * ) new_text , "cpu" ) ; if ( p ) { type = "min memory per cpu" ; } else { type = "min memory per node" ; } if ( temp_ll <= 0 ) { return_error } job_msg -> pn_min_memory = ( uint64_t ) temp_ll ; if ( p ) { job_msg -> pn_min_memory |= MEM_PER_CPU ; } break ; case SORTID_TMP_DISK : temp_int = strtol ( new_text , & p , 10 ) ; if ( * p == 'g' || * p == 'G' ) { temp_int *= 1024 ; } if ( * p == 't' || * p == 'T' ) { temp_int *= 1048576 ; } type = "min tmp disk per node" ; if ( temp_int <= 0 ) { return_error } job_msg -> pn_min_tmp_disk = ( uint32_t ) temp_int ; break ; case SORTID_PARTITION : job_msg -> partition = xstrdup ( new_text ) ; type = "partition" ; break ; case SORTID_NAME : job_msg -> name = xstrdup ( new_text ) ; type = "name" ; break ; case SORTID_HET_JOB_ID : job_msg -> name = xstrdup ( new_text ) ; type = "hetjob jobid" ; break ; case SORTID_HET_JOB_ID_SET : job_msg -> name = xstrdup ( new_text ) ; type = "hetjob id set" ; break ; case SORTID_HET_JOB_OFFSET : job_msg -> name = xstrdup ( new_text ) ; type = "hetjob offset" ; break ; case SORTID_WCKEY : job_msg -> wckey = xstrdup ( new_text ) ; type = "wckey" ; break ; case SORTID_OVER_SUBSCRIBE : if ( ! xstrcasecmp ( new_text , "yes" ) ) { job_msg -> shared = 1 ; } else { job_msg -> shared = 0 ; } type = "oversubscribe" ; break ; case SORTID_CONTIGUOUS : if ( ! xstrcasecmp ( new_text , "yes" ) ) { job_msg -> contiguous = 1 ; } else { job_msg -> contiguous = 0 ; } type = "contiguous" ; break ; case SORTID_CORE_SPEC : temp_int = strtol ( new_text , ( char * * ) NULL , 10 ) ; type = "specialized cores" ; if ( temp_int <= 0 ) { return_error } job_msg -> core_spec = ( uint16_t ) temp_int ; break ; case SORTID_THREAD_SPEC : temp_int = strtol ( new_text , ( char * * ) NULL , 10 ) ; type = "specialized threads" ; if ( temp_int <= 0 ) { return_error } job_msg -> core_spec = ( uint16_t ) temp_int | CORE_SPEC_THREAD ; break ; case SORTID_REBOOT : if ( ! xstrcasecmp ( new_text , "yes" ) ) { job_msg -> reboot = 1 ; } else { job_msg -> reboot = 0 ; } type = "reboot" ; break ; case SORTID_REQUEUE : if ( ! xstrcasecmp ( new_text , "yes" ) ) { job_msg -> requeue = 1 ; } else { job_msg -> requeue = 0 ; } type = "requeue" ; break ; case SORTID_NODELIST_REQ : job_msg -> req_nodes = xstrdup ( new_text ) ; type = "requested nodelist" ; break ; case SORTID_NODELIST_EXC : job_msg -> exc_nodes = xstrdup ( new_text ) ; type = "excluded nodelist" ; break ; case SORTID_FEATURES : job_msg -> features = xstrdup ( new_text ) ; type = "features" ; break ; case SORTID_PREFER : job_msg -> prefer = xstrdup ( new_text ) ; type = "prefer" ; break ; case SORTID_CPUS_PER_TRES : job_msg -> cpus_per_tres = xstrdup ( new_text ) ; type = "cpus_per_tres" ; break ; case SORTID_MEM_PER_TRES : job_msg -> mem_per_tres = xstrdup ( new_text ) ; type = "mem_per_tres" ; break ; case SORTID_TRES_PER_JOB : job_msg -> tres_per_job = xstrdup ( new_text ) ; type = "tres_per_job" ; break ; case SORTID_TRES_PER_NODE : job_msg -> tres_per_node = xstrdup ( new_text ) ; type = "tres_per_node" ; break ; case SORTID_TRES_PER_SOCKET : job_msg -> tres_per_socket = xstrdup ( new_text ) ; type = "tres_per_socket" ; break ; case SORTID_TRES_PER_TASK : job_msg -> tres_per_task = xstrdup ( new_text ) ; type = "tres_per_task" ; break ; case SORTID_LICENSES : job_msg -> licenses = xstrdup ( new_text ) ; type = "licenses" ; break ; case SORTID_MCS_LABEL : job_msg -> mcs_label = xstrdup ( new_text ) ; type = "mcs_label" ; break ; case SORTID_ACCOUNT : job_msg -> account = xstrdup ( new_text ) ; type = "account" ; break ; case SORTID_BURST_BUFFER : job_msg -> burst_buffer = xstrdup ( new_text ) ; type = "burst buffer" ; break ; case SORTID_QOS : job_msg -> qos = xstrdup ( new_text ) ; type = "qos" ; break ; case SORTID_COMMAND : type = "script_file" ; xfree ( job_msg -> script ) ; job_msg -> script = _read_file ( new_text ) ; if ( job_msg -> script == NULL ) { return_error } if ( job_msg -> argc ) { for ( j = 0 ; j < job_msg -> argc ; j ++ ) { xfree ( job_msg -> argv [ j ] ) ; } } xfree ( job_msg -> argv ) ; xfree ( job_msg -> name ) ; job_msg -> argc = 1 ; job_msg -> argv = xmalloc ( sizeof ( char * ) * job_msg -> argc ) ; if ( new_text [ 0 ] == '/' ) { job_msg -> argv [ 0 ] = xstrdup ( new_text ) ; token = strrchr ( new_text , ( int ) '/' ) ; if ( token ) { job_msg -> name = xstrdup ( token + 1 ) ; } } else { job_msg -> argv [ 0 ] = xmalloc ( 1024 ) ; if ( ! getcwd ( job_msg -> argv [ 0 ] , 1024 ) ) { return_error } xstrcat ( job_msg -> argv [ 0 ] , "/" ) ; xstrcat ( job_msg -> argv [ 0 ] , new_text ) ; job_msg -> name = xstrdup ( new_text ) ; } break ; case SORTID_DEPENDENCY : job_msg -> dependency = xstrdup ( new_text ) ; type = "dependency" ; break ; case SORTID_TIME_ELIGIBLE : case SORTID_TIME_START : type = "start time" ; job_msg -> begin_time = parse_time ( ( char * ) new_text , 0 ) ; if ( ! job_msg -> begin_time ) { return_error } if ( job_msg -> begin_time < time ( NULL ) ) { job_msg -> begin_time = time ( NULL ) ; } break ; case SORTID_DEADLINE : type = "deadline" ; job_msg -> deadline = parse_time ( ( char * ) new_text , 0 ) ; if ( ! job_msg -> deadline ) { return_error } if ( job_msg -> deadline < time ( NULL ) ) { return_error } break ; case SORTID_EXTRA : job_msg -> extra = xstrdup ( new_text ) ; type = "extra" ; break ; case SORTID_STD_OUT : type = "StdOut" ; job_msg -> std_out = xstrdup ( new_text ) ; break ; case SORTID_SWITCHES : type = "switches" ; job_msg -> req_switch = ( uint32_t ) strtol ( new_text , & sep_char , 10 ) ; if ( sep_char && sep_char [ 0 ] == '@' ) { job_msg -> wait4switch = time_str2mins ( sep_char + 1 ) * 60 ; } break ; default : type = "unknown" ; break ; } if ( xstrcmp ( type , "unknown" ) ) { global_send_update_msg = 1 ; } return type ; return_error global_edit_error = 1 ; return type ; } 