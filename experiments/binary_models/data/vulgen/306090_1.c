void dmub_dcn32_reset ( struct dmub_srv * dmub ) { union dmub_gpint_data_register cmd ; uint32_t in_reset , scratch , i ; REG_GET ( DMCUB_CNTL2 , DMCUB_SOFT_RESET , & in_reset ) ; if ( in_reset == 0 ) { cmd . bits . status = 1 ; cmd . bits . command_code = DMUB_GPINT__STOP_FW ; cmd . bits . param = 0 ; dmub -> hw_funcs . set_gpint ( dmub , cmd ) ; for ( i = 0 ; i < timeout ; ++ i ) { if ( dmub -> hw_funcs . is_gpint_acked ( dmub , cmd ) ) { break ; } } for ( i = 0 ; i < timeout ; ++ i ) { scratch = dmub -> hw_funcs . get_gpint_response ( dmub ) ; if ( scratch == DMUB_GPINT__STOP_FW_RESPONSE ) { break ; } } cmd . all = 0 ; dmub -> hw_funcs . set_gpint ( dmub , cmd ) ; } REG_UPDATE ( DMCUB_CNTL2 , DMCUB_SOFT_RESET , 1 ) ; REG_UPDATE ( DMCUB_CNTL , DMCUB_ENABLE , 0 ) ; REG_UPDATE ( MMHUBBUB_SOFT_RESET , DMUIF_SOFT_RESET , 1 ) ; REG_WRITE ( DMCUB_INBOX1_RPTR , 0 ) ; REG_WRITE ( DMCUB_INBOX1_WPTR , 0 ) ; REG_WRITE ( DMCUB_OUTBOX1_RPTR , 0 ) ; REG_WRITE ( DMCUB_OUTBOX1_WPTR , 0 ) ; REG_WRITE ( DMCUB_SCRATCH0 , 0 ) ; } 