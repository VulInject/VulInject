Spline * ApproximateSplineFromPointsSlopes ( SplinePoint * from , SplinePoint * to , FitPoint * mid , int cnt , int order2 , enum mergetype mt ) { BasePoint tounit , fromunit , ftunit ; bigreal flen , tlen , ftlen , dot ; Spline * spline , temp ; BasePoint nextcp ; int bettern , betterp ; bigreal offn , offp , incrn , incrp , trylen ; int nocnt = 0 , totcnt ; bigreal curdiff , bestdiff [ TRY_CNT ] ; int i , j , besti [ TRY_CNT ] , bestj [ TRY_CNT ] , k , l ; bigreal fdiff , tdiff , fmax , tmax , fdotft , tdotft ; DBounds b ; struct dotbounds db ; bigreal offn_ , offp_ , finaldiff ; bigreal pt_pf_x , pt_pf_y , determinant ; bigreal consts [ 2 ] , rt_terms [ 2 ] , rf_terms [ 2 ] ; if ( ( ! from -> nonextcp && ( from -> nextcp . x == from -> me . x || from -> nextcp . y == from -> me . y ) ) || ( ! to -> noprevcp && ( to -> prevcp . x == to -> me . x || to -> prevcp . y == to -> me . y ) ) ) { } if ( ( ( from -> pointtype == pt_corner && from -> nonextcp ) || ( from -> pointtype == pt_tangent && ( ( from -> nonextcp && from -> noprevcp ) || ! from -> noprevcp ) ) ) && ( ( to -> pointtype == pt_corner && to -> noprevcp ) || ( to -> pointtype == pt_tangent && ( ( to -> nonextcp && to -> noprevcp ) || ! to -> nonextcp ) ) ) ) { from -> pointtype = to -> pointtype = pt_corner ; return ( ApproximateSplineFromPoints ( from , to , mid , cnt , order2 ) ) ; } if ( order2 ) { if ( from -> nonextcp ) { from -> nextcp = from -> next -> to -> me ; } if ( to -> noprevcp ) { to -> prevcp = to -> prev -> from -> me ; } fromunit . x = from -> nextcp . x - from -> me . x ; fromunit . y = from -> nextcp . y - from -> me . y ; tounit . x = to -> prevcp . x - to -> me . x ; tounit . y = to -> prevcp . y - to -> me . y ; if ( ! IntersectLines ( & nextcp , & from -> nextcp , & from -> me , & to -> prevcp , & to -> me ) || ( nextcp . x - from -> me . x ) * fromunit . x + ( nextcp . y - from -> me . y ) * fromunit . y < 0 || ( nextcp . x - to -> me . x ) * tounit . x + ( nextcp . y - to -> me . y ) * tounit . y < 0 ) { from -> nextcp = from -> me ; to -> prevcp = to -> me ; TestForLinear ( from , to ) ; } else { from -> nextcp = to -> prevcp = nextcp ; } return ( SplineMake2 ( from , to ) ) ; } if ( cnt == 0 ) { bigreal len = sqrt ( ( to -> me . x - from -> me . x ) * ( to -> me . x - from -> me . x ) + ( to -> me . y - from -> me . y ) * ( to -> me . y - from -> me . y ) ) ; if ( len == 0 ) { from -> nextcp = from -> me ; to -> prevcp = to -> me ; } else { BasePoint noff , poff ; bigreal nlen , plen ; noff . x = from -> nextcp . x - from -> me . x ; noff . y = from -> nextcp . y - from -> me . y ; poff . x = to -> me . x - to -> prevcp . x ; poff . y = to -> me . y - to -> prevcp . y ; nlen = sqrt ( noff . x * noff . x + noff . y + noff . y ) ; plen = sqrt ( poff . x * poff . x + poff . y + poff . y ) ; if ( nlen > len / 3 ) { noff . x *= len / 3 / nlen ; noff . y *= len / 3 / nlen ; from -> nextcp . x = from -> me . x + noff . x ; from -> nextcp . y = from -> me . y + noff . y ; } if ( plen > len / 3 ) { poff . x *= len / 3 / plen ; poff . y *= len / 3 / plen ; to -> prevcp . x = to -> me . x + poff . x ; to -> prevcp . y = to -> me . y + poff . y ; } } return ( SplineMake3 ( from , to ) ) ; } if ( to -> prev != NULL && ( ( to -> noprevcp && to -> nonextcp ) || to -> prev -> knownlinear ) ) { tounit . x = to -> prev -> from -> me . x - to -> me . x ; tounit . y = to -> prev -> from -> me . y - to -> me . y ; } if ( ! to -> noprevcp || to -> pointtype == pt_corner ) { tounit . x = to -> prevcp . x - to -> me . x ; tounit . y = to -> prevcp . y - to -> me . y ; } else { tounit . x = to -> me . x - to -> nextcp . x ; tounit . y = to -> me . y - to -> nextcp . y ; } tlen = sqrt ( tounit . x * tounit . x + tounit . y * tounit . y ) ; if ( from -> next != NULL && ( ( from -> noprevcp && from -> nonextcp ) || from -> next -> knownlinear ) ) { fromunit . x = from -> next -> to -> me . x - from -> me . x ; fromunit . y = from -> next -> to -> me . y - from -> me . y ; } if ( ! from -> nonextcp || from -> pointtype == pt_corner ) { fromunit . x = from -> nextcp . x - from -> me . x ; fromunit . y = from -> nextcp . y - from -> me . y ; } else { fromunit . x = from -> me . x - from -> prevcp . x ; fromunit . y = from -> me . y - from -> prevcp . y ; } flen = sqrt ( fromunit . x * fromunit . x + fromunit . y * fromunit . y ) ; if ( ( tlen == 0 || flen == 0 ) && ( from -> next == NULL || to -> prev == NULL ) ) { memset ( & temp , 0 , sizeof ( temp ) ) ; temp . from = from ; temp . to = to ; SplineRefigure ( & temp ) ; from -> next = to -> prev = NULL ; } if ( tlen == 0 ) { if ( to -> prev != NULL ) { temp = * to -> prev ; } if ( ( to -> pointtype == pt_curve || to -> pointtype == pt_hvcurve ) && to -> next && ! to -> nonextcp ) { tounit . x = to -> me . x - to -> nextcp . x ; tounit . y = to -> me . y - to -> nextcp . y ; } else { tounit . x = - ( ( 3 * temp . splines [ 0 ] . a * .9999 + 2 * temp . splines [ 0 ] . b ) * .9999 + temp . splines [ 0 ] . c ) ; tounit . y = - ( ( 3 * temp . splines [ 1 ] . a * .9999 + 2 * temp . splines [ 1 ] . b ) * .9999 + temp . splines [ 1 ] . c ) ; } tlen = sqrt ( tounit . x * tounit . x + tounit . y * tounit . y ) ; } tounit . x /= tlen ; tounit . y /= tlen ; if ( flen == 0 ) { if ( from -> next != NULL ) { temp = * from -> next ; } if ( ( from -> pointtype == pt_curve || from -> pointtype == pt_hvcurve ) && from -> prev && ! from -> noprevcp ) { fromunit . x = from -> me . x - from -> prevcp . x ; fromunit . y = from -> me . y - from -> prevcp . y ; } else { fromunit . x = ( ( 3 * temp . splines [ 0 ] . a * .0001 + 2 * temp . splines [ 0 ] . b ) * .0001 + temp . splines [ 0 ] . c ) ; fromunit . y = ( ( 3 * temp . splines [ 1 ] . a * .0001 + 2 * temp . splines [ 1 ] . b ) * .0001 + temp . splines [ 1 ] . c ) ; } flen = sqrt ( fromunit . x * fromunit . x + fromunit . y * fromunit . y ) ; } fromunit . x /= flen ; fromunit . y /= flen ; ftunit . x = ( to -> me . x - from -> me . x ) ; ftunit . y = ( to -> me . y - from -> me . y ) ; ftlen = sqrt ( ftunit . x * ftunit . x + ftunit . y * ftunit . y ) ; if ( ftlen != 0 ) { ftunit . x /= ftlen ; ftunit . y /= ftlen ; } if ( ( dot = fromunit . x * tounit . y - fromunit . y * tounit . x ) < .0001 && dot > - .0001 && ( dot = ftunit . x * tounit . y - ftunit . y * tounit . x ) < .0001 && dot > - .0001 ) { from -> nextcp = from -> me ; to -> prevcp = to -> me ; return ( SplineMake3 ( from , to ) ) ; } if ( ( ftlen == 0 ) && ( mt != mt_matrix ) ) { mt = mt_matrix ; } if ( mt == mt_levien ) { bigreal f , m , xa , ya , xb , yb , xc , yc , xd , yd , sasa , sab ; int numberOfSolutions ; SplinePoint * frompoint , * topoint ; f = 0 ; m = 0 ; frompoint = from ; if ( from -> next == NULL ) { topoint = to ; } else { topoint = from -> next -> to ; } for ( ; ; frompoint = topoint -> next -> from , topoint = topoint -> next -> to ) { xa = ( ( frompoint -> me . x - from -> me . x ) * ftunit . x + ( frompoint -> me . y - from -> me . y ) * ftunit . y ) / ftlen ; ya = ( - ( frompoint -> me . x - from -> me . x ) * ftunit . y + ( frompoint -> me . y - from -> me . y ) * ftunit . x ) / ftlen ; xb = ( ( frompoint -> nextcp . x - from -> me . x ) * ftunit . x + ( frompoint -> nextcp . y - from -> me . y ) * ftunit . y ) / ftlen ; yb = ( - ( frompoint -> nextcp . x - from -> me . x ) * ftunit . y + ( frompoint -> nextcp . y - from -> me . y ) * ftunit . x ) / ftlen ; xc = ( ( topoint -> prevcp . x - from -> me . x ) * ftunit . x + ( topoint -> prevcp . y - from -> me . y ) * ftunit . y ) / ftlen ; yc = ( - ( topoint -> prevcp . x - from -> me . x ) * ftunit . y + ( topoint -> prevcp . y - from -> me . y ) * ftunit . x ) / ftlen ; xd = ( ( topoint -> me . x - from -> me . x ) * ftunit . x + ( topoint -> me . y - from -> me . y ) * ftunit . y ) / ftlen ; yd = ( - ( topoint -> me . x - from -> me . x ) * ftunit . y + ( topoint -> me . y - from -> me . y ) * ftunit . x ) / ftlen ; f += ( ( xb - xa ) * ( 10 * ya + 6 * yb + 3 * yc + yd ) + ( xc - xb ) * ( 4 * ya + 6 * yb + 6 * yc + 4 * yd ) + ( xd - xc ) * ( ya + 3 * yb + 6 * yc + 10 * yd ) ) / 20 ; m += ( 280 * xd * xd * yd - 105 * xc * xd * yd - 30 * xb * xd * yd - 5 * xa * xd * yd - 45 * xc * xc * yd - 45 * xb * xc * yd - 12 * xa * xc * yd - 18 * xb * xb * yd - 15 * xa * xb * yd - 5 * xa * xa * yd + 105 * xd * xd * yc + 45 * xc * xd * yc - 3 * xa * xd * yc - 27 * xb * xc * yc - 18 * xa * xc * yc - 27 * xb * xb * yc - 45 * xa * xb * yc - 30 * xa * xa * yc + 30 * xd * xd * yb + 45 * xc * xd * yb + 18 * xb * xd * yb + 3 * xa * xd * yb + 27 * xc * xc * yb + 27 * xb * xc * yb - 45 * xa * xb * yb - 105 * xa * xa * yb + 5 * xd * xd * ya + 15 * xc * xd * ya + 12 * xb * xd * ya + 5 * xa * xd * ya + 18 * xc * xc * ya + 45 * xb * xc * ya + 30 * xa * xc * ya + 45 * xb * xb * ya + 105 * xa * xb * ya - 280 * xa * xa * ya ) / 840 ; if ( topoint == to ) { break ; } } BasePoint aunit = ( BasePoint ) { BPDot ( ftunit , fromunit ) BPCross ( , ) } ; BasePoint bunit = ( BasePoint ) { BPDot ( BPRev ( ftunit ) , tounit ) BPCross ( , ) } ; if ( aunit . y < 0 ) { aunit . y = - aunit . y ; bunit . y = - bunit . y ; m = - m ; f = - f ; } bigreal aMax = 100 ; bigreal bMax = 100 ; sab = aunit . y * bunit . x + aunit . x * bunit . y ; if ( sab != 0 ) { aMax = bunit . y / sab ; bMax = aunit . y / sab ; if ( aMax < 0 ) { aMax = 100 ; } if ( bMax < 0 ) { bMax = 100 ; } } sasa = aunit . y * aunit . y ; Quartic quad ; if ( ( aunit . x == - bunit . x && aunit . y == bunit . y ) || ( aunit . x == bunit . x && aunit . y == - bunit . y ) ) { quad . a = 0 ; quad . b = 0 ; quad . c = - 9 * aunit . x * sasa ; quad . d = 6 * aunit . y * ( 4 * aunit . y + 5 * aunit . x * f ) ; quad . e = 10 * ( ( 42 * m - 25 * f ) * aunit . y - 25 * aunit . x * f * f ) ; } else { quad . a = - 9 * aunit . x * ( ( ( 2 * bunit . y * bunit . x * aunit . x + aunit . y * ( 2 * bunit . x * bunit . x - 1 ) ) * aunit . x - 2 * bunit . y * bunit . x ) * aunit . x - bunit . x * bunit . x * aunit . y ) ; quad . b = 12 * ( ( ( ( bunit . x * ( 30 * f * bunit . x - bunit . y ) - 15 * f ) * aunit . x + 2 * aunit . y - bunit . x * aunit . y * ( bunit . x + 30 * f * bunit . y ) ) * aunit . x + bunit . x * ( bunit . y - 15 * f * bunit . x ) ) * aunit . x - aunit . y * bunit . x * bunit . x ) ; quad . c = 12 * ( ( ( ( 70 * m + 15 * f ) * bunit . y * bunit . y + bunit . x * ( 9 * bunit . y - 70 * bunit . x * m - 5 * bunit . x * f ) ) * aunit . x - 5 * aunit . y * bunit . y * ( 3 * bunit . y - 4 * bunit . x * ( 7 * m + f ) ) ) * aunit . x - bunit . x * ( 9 * bunit . y - 70 * bunit . x * m - 5 * bunit . x * f ) ) ; quad . d = 16 * ( ( ( 12 * aunit . y - 5 * aunit . x * ( 42 * m - 17 * f ) ) * bunit . y - 70 * bunit . x * ( 3 * m - f ) * aunit . y - 75 * aunit . x * bunit . x * f * f ) * bunit . y - 75 * bunit . x * bunit . x * f * f * aunit . y ) ; quad . e = 80 * bunit . y * ( 42 * bunit . y * m - 25 * f * ( bunit . y - bunit . x * f ) ) ; } extended solutions [ 4 ] { - 999999 - 999999 - 999999 - 999999 } ; ; _QuarticSolve ( & quad , solutions ) ; extended abSolutions [ 10 ] [ 2 ] ; numberOfSolutions = 0 ; extended a , b ; for ( int i = 0 ; i < 4 ; i ++ ) { a = solutions [ i ] ; if ( a >= 0 && a < aMax ) { b = ( 20 * f - 6 * a * aunit . y ) / ( 3 * ( 2 * bunit . y - a * sab ) ) ; if ( b >= 0 && b < bMax ) { abSolutions [ numberOfSolutions ] [ 0 ] = a ; abSolutions [ numberOfSolutions ++ ] [ 1 ] = b ; } } } if ( ( aunit . x == - bunit . x && aunit . y == bunit . y ) || ( aunit . x == bunit . x && aunit . y == - bunit . y ) ) { quad . a = 0 ; quad . b = 0 ; quad . c = 0 ; quad . d = - 3 * aunit . x * aunit . y ; quad . e = 4 * aunit . y + 5 * aunit . x * f ; } else { bigreal sbsb = bunit . y * bunit . y ; bigreal sabsab = sab * sab ; quad . a = - 9 * aunit . x * aunit . y * sabsab * sab ; quad . b = - 3 * sabsab * ( 9 * aunit . x * aunit . y * bunit . y - ( 17 * aunit . y + 30 * aunit . x * f ) * sab + 15 * bunit . x * sasa ) ; quad . c = 18 * sab * bunit . y * ( 21 * aunit . x * aunit . y * bunit . y - ( 17 * aunit . y + 30 * aunit . x * f ) * sab + 15 * bunit . x * sasa ) ; quad . d = - 4 * ( 144 * aunit . x * aunit . y * sbsb * bunit . y + ( ( - 78 * aunit . y - 135 * aunit . x * f ) * sab + 108 * bunit . x * sasa ) * sbsb + ( - 125 * f * sabsab - 45 * bunit . x * f * aunit . y * sab ) * bunit . y + 150 * bunit . x * f * f * sabsab ) ; quad . e = 8 * bunit . y * ( ( 24 * aunit . y + 45 * aunit . x * f ) * sbsb + ( 15 * bunit . x * f * aunit . y - 125 * f * sab ) * bunit . y + 100 * bunit . x * f * f * sab ) ; } for ( int i = 0 ; i < 4 ; i ++ ) { solutions [ i ] = - 999999 ; } _QuarticSolve ( & quad , solutions ) ; for ( int i = 0 ; i < 4 ; i ++ ) { a = solutions [ i ] ; if ( a >= 0 && a < aMax ) { b = ( 20 * f - 6 * a * aunit . y ) / ( 3 * ( 2 * bunit . y - a * sab ) ) ; if ( b >= 0 && b < bMax ) { abSolutions [ numberOfSolutions ] [ 0 ] = a ; abSolutions [ numberOfSolutions ++ ] [ 1 ] = b ; } } } a = ( 2000 * f - 6 * bunit . y ) / ( 600 * aunit . y - 3 * sab ) ; if ( a >= 0 && a < aMax ) { abSolutions [ numberOfSolutions ] [ 0 ] = a ; abSolutions [ numberOfSolutions ++ ] [ 1 ] = 0.01 ; } b = ( 2000 * f - 6 * aunit . y ) / ( 600 * bunit . y - 3 * sab ) ; if ( b >= 0 && b < bMax ) { abSolutions [ numberOfSolutions ] [ 0 ] = 0.01 ; abSolutions [ numberOfSolutions ++ ] [ 1 ] = b ; } if ( numberOfSolutions == 0 ) { b = ( 20 * f - 6 * aMax * aunit . y ) / ( 3 * ( 2 * bunit . y - aMax * sab ) ) ; if ( b >= 0 && b < bMax ) { abSolutions [ numberOfSolutions ] [ 0 ] = aMax ; abSolutions [ numberOfSolutions ++ ] [ 1 ] = b ; } a = ( 20 * f - 6 * bMax * bunit . y ) / ( 3 * ( 2 * aunit . y - bMax * sab ) ) ; if ( a >= 0 && a < aMax ) { abSolutions [ numberOfSolutions ] [ 0 ] = a ; abSolutions [ numberOfSolutions ++ ] [ 1 ] = bMax ; } } if ( numberOfSolutions == 0 ) { abSolutions [ numberOfSolutions ] [ 0 ] = aMax ; abSolutions [ numberOfSolutions ++ ] [ 1 ] = bMax ; } if ( numberOfSolutions == 1 ) { from -> nextcp . x = from -> me . x + ftlen * fromunit . x * abSolutions [ 0 ] [ 0 ] ; from -> nextcp . y = from -> me . y + ftlen * fromunit . y * abSolutions [ 0 ] [ 0 ] ; to -> prevcp . x = to -> me . x + ftlen * tounit . x * abSolutions [ 0 ] [ 1 ] ; to -> prevcp . y = to -> me . y + ftlen * tounit . y * abSolutions [ 0 ] [ 1 ] ; } else { bigreal bestError = 1e30 ; bigreal t , error , errorsum , dist ; BasePoint prevcp , nextcp , coeff1 , coeff2 , coeff3 ; int last_best_j ; for ( int k = 0 ; k < numberOfSolutions ; k ++ ) { nextcp . x = from -> me . x + ftlen * fromunit . x * abSolutions [ k ] [ 0 ] ; nextcp . y = from -> me . y + ftlen * fromunit . y * abSolutions [ k ] [ 0 ] ; prevcp . x = to -> me . x + ftlen * tounit . x * abSolutions [ k ] [ 1 ] ; prevcp . y = to -> me . y + ftlen * tounit . y * abSolutions [ k ] [ 1 ] ; coeff3 . x = - from -> me . x + 3 * nextcp . x - 3 * prevcp . x + to -> me . x ; coeff3 . y = - from -> me . y + 3 * nextcp . y - 3 * prevcp . y + to -> me . y ; coeff2 . x = 3 * from -> me . x - 6 * nextcp . x + 3 * prevcp . x ; coeff2 . y = 3 * from -> me . y - 6 * nextcp . y + 3 * prevcp . y ; coeff1 . x = - 3 * from -> me . x + 3 * nextcp . x ; coeff1 . y = - 3 * from -> me . y + 3 * nextcp . y ; BasePoint approx [ 99 ] ; for ( int i = 0 ; i < 99 ; i ++ ) { t = ( i + 1 ) / 100.0 ; approx [ i ] . x = from -> me . x + t * ( coeff1 . x + t * ( coeff2 . x + t * coeff3 . x ) ) ; approx [ i ] . y = from -> me . y + t * ( coeff1 . y + t * ( coeff2 . y + t * coeff3 . y ) ) ; } errorsum = 0.0 ; last_best_j = 0 ; for ( int i = 0 ; i < cnt ; i ++ ) { error = 1e30 ; for ( int j = last_best_j ; j < 99 ; j ++ ) { dist = ( mid [ i ] . p . x - approx [ j ] . x ) * ( mid [ i ] . p . x - approx [ j ] . x ) + ( mid [ i ] . p . y - approx [ j ] . y ) * ( mid [ i ] . p . y - approx [ j ] . y ) ; if ( dist < error ) { error = dist ; last_best_j = j ; } } errorsum += error ; if ( errorsum > bestError ) { break ; } } if ( errorsum < bestError ) { bestError = errorsum ; from -> nextcp = nextcp ; to -> prevcp = prevcp ; } } } return ( SplineMake3 ( from , to ) ) ; } if ( mt == mt_bruteforce ) { bigreal best_error = 1e30 ; bigreal t , error , errorsum , dist ; BasePoint prevcp , coeff1 , coeff2 , coeff3 ; bigreal best_fromhandle = 0.0 ; bigreal best_tohandle = 0.0 ; BasePoint approx [ 99 ] ; for ( int run = 0 ; run < 2 ; ++ run ) { for ( int fromhandle = ( ( run == 0 ) ?1 : - 29 ) ; fromhandle <= ( ( run == 0 ) ?60 : 29 ) ; ++ fromhandle ) { for ( int tohandle = ( ( run == 0 ) ?1 : - 29 ) ; tohandle <= ( ( run == 0 ) ?60 : 29 ) ; ++ tohandle ) { nextcp . x = from -> me . x + ftlen * fromunit . x * ( ( run == 0 ) ?fromhandle : best_fromhandle + fromhandle / 30.0 ) / 60.0 ; nextcp . y = from -> me . y + ftlen * fromunit . y * ( ( run == 0 ) ?fromhandle : best_fromhandle + fromhandle / 30.0 ) / 60.0 ; prevcp . x = to -> me . x + ftlen * tounit . x * ( ( run == 0 ) ?tohandle : best_tohandle + tohandle / 30.0 ) / 60.0 ; prevcp . y = to -> me . y + ftlen * tounit . y * ( ( run == 0 ) ?tohandle : best_tohandle + tohandle / 30.0 ) / 60.0 ; coeff3 . x = - from -> me . x + 3 * nextcp . x - 3 * prevcp . x + to -> me . x ; coeff3 . y = - from -> me . y + 3 * nextcp . y - 3 * prevcp . y + to -> me . y ; coeff2 . x = 3 * from -> me . x - 6 * nextcp . x + 3 * prevcp . x ; coeff2 . y = 3 * from -> me . y - 6 * nextcp . y + 3 * prevcp . y ; coeff1 . x = - 3 * from -> me . x + 3 * nextcp . x ; coeff1 . y = - 3 * from -> me . y + 3 * nextcp . y ; for ( int i = 0 ; i < 99 ; ++ i ) { t = ( i + 1 ) / 100.0 ; approx [ i ] . x = from -> me . x + t * ( coeff1 . x + t * ( coeff2 . x + t * coeff3 . x ) ) ; approx [ i ] . y = from -> me . y + t * ( coeff1 . y + t * ( coeff2 . y + t * coeff3 . y ) ) ; } errorsum = 0.0 ; for ( int i = 0 ; i < cnt ; ++ i ) { error = ( mid [ i ] . p . x - approx [ 0 ] . x ) * ( mid [ i ] . p . x - approx [ 0 ] . x ) + ( mid [ i ] . p . y - approx [ 0 ] . y ) * ( mid [ i ] . p . y - approx [ 0 ] . y ) ; for ( int j = 1 ; j < 99 ; ++ j ) { dist = ( mid [ i ] . p . x - approx [ j ] . x ) * ( mid [ i ] . p . x - approx [ j ] . x ) + ( mid [ i ] . p . y - approx [ j ] . y ) * ( mid [ i ] . p . y - approx [ j ] . y ) ; if ( dist < error ) { error = dist ; } } errorsum += error ; if ( errorsum > best_error ) { break ; } } if ( errorsum < best_error ) { best_error = errorsum ; if ( run == 0 ) { best_fromhandle = fromhandle ; best_tohandle = tohandle ; } from -> nextcp = nextcp ; to -> prevcp = prevcp ; } } } } return ( SplineMake3 ( from , to ) ) ; } else { pt_pf_x = to -> me . x - from -> me . x ; pt_pf_y = to -> me . y - from -> me . y ; consts [ 0 ] = consts [ 1 ] = rt_terms [ 0 ] = rt_terms [ 1 ] = rf_terms [ 0 ] = rf_terms [ 1 ] = 0 ; for ( i = 0 ; i < cnt ; ++ i ) { bigreal t = mid [ i ] . t , t2 = t * t , t3 = t2 * t ; bigreal factor_from = t - 2 * t2 + t3 ; bigreal factor_to = t2 - t3 ; bigreal const_x = from -> me . x - mid [ i ] . p . x + 3 * pt_pf_x * t2 - 2 * pt_pf_x * t3 ; bigreal const_y = from -> me . y - mid [ i ] . p . y + 3 * pt_pf_y * t2 - 2 * pt_pf_y * t3 ; bigreal temp1 = 3 * ( t - 2 * t2 + t3 ) ; bigreal rf_term_x = temp1 * fromunit . x ; bigreal rf_term_y = temp1 * fromunit . y ; bigreal temp2 = 3 * ( t2 - t3 ) ; bigreal rt_term_x = - temp2 * tounit . x ; bigreal rt_term_y = - temp2 * tounit . y ; consts [ 0 ] += factor_from * ( fromunit . x * const_x + fromunit . y * const_y ) ; consts [ 1 ] += factor_to * ( - tounit . x * const_x + - tounit . y * const_y ) ; rf_terms [ 0 ] += factor_from * ( fromunit . x * rf_term_x + fromunit . y * rf_term_y ) ; rf_terms [ 1 ] += factor_to * ( - tounit . x * rf_term_x + - tounit . y * rf_term_y ) ; rt_terms [ 0 ] += factor_from * ( fromunit . x * rt_term_x + fromunit . y * rt_term_y ) ; rt_terms [ 1 ] += factor_to * ( - tounit . x * rt_term_x + - tounit . y * rt_term_y ) ; } determinant = ( rt_terms [ 0 ] * rf_terms [ 1 ] - rt_terms [ 1 ] * rf_terms [ 0 ] ) ; if ( determinant != 0 ) { bigreal rt , rf ; rt = ( consts [ 1 ] * rf_terms [ 0 ] - consts [ 0 ] * rf_terms [ 1 ] ) / determinant ; if ( rf_terms [ 0 ] != 0 ) { rf = - ( consts [ 0 ] + rt * rt_terms [ 0 ] ) / rf_terms [ 0 ] ; } else { rf = - ( consts [ 1 ] + rt * rt_terms [ 1 ] ) / rf_terms [ 1 ] ; } if ( rf >= 0 && rt > 0 && rf_terms [ 0 ] != 0 && ( rf = - consts [ 0 ] / rf_terms [ 0 ] ) > 0 ) { rt = 0 ; } if ( rf < 0 && rt <= 0 && rt_terms [ 1 ] != 0 && ( rt = - consts [ 1 ] / rt_terms [ 1 ] ) < 0 ) { rf = 0 ; } if ( rt <= 0 && rf >= 0 ) { from -> nextcp . x = from -> me . x + rf * fromunit . x ; from -> nextcp . y = from -> me . y + rf * fromunit . y ; to -> prevcp . x = to -> me . x - rt * tounit . x ; to -> prevcp . y = to -> me . y - rt * tounit . y ; return ( SplineMake3 ( from , to ) ) ; } } trylen = ( to -> me . x - from -> me . x ) * fromunit . x + ( to -> me . y - from -> me . y ) * fromunit . y ; if ( trylen > flen ) { flen = trylen ; } trylen = ( from -> me . x - to -> me . x ) * tounit . x + ( from -> me . y - to -> me . y ) * tounit . y ; if ( trylen > tlen ) { tlen = trylen ; } for ( i = 0 ; i < cnt ; ++ i ) { trylen = ( mid [ i ] . p . x - from -> me . x ) * fromunit . x + ( mid [ i ] . p . y - from -> me . y ) * fromunit . y ; if ( trylen > flen ) { flen = trylen ; } trylen = ( mid [ i ] . p . x - to -> me . x ) * tounit . x + ( mid [ i ] . p . y - to -> me . y ) * tounit . y ; if ( trylen > tlen ) { tlen = trylen ; } } fdotft = fromunit . x * ftunit . x + fromunit . y * ftunit . y ; fmax = fdotft > 0 ?ftlen / fdotft : 1e10 ; tdotft = - tounit . x * ftunit . x - tounit . y * ftunit . y ; tmax = tdotft > 0 ?ftlen / tdotft : 1e10 ; db . base = from -> me ; db . unit = ftunit ; db . len = ftlen ; ApproxBounds ( & b , mid , cnt , & db ) ; for ( k = 0 ; k < TRY_CNT ; ++ k ) { bestdiff [ k ] = 1e20 ; besti [ k ] = - 1 ; bestj [ k ] = - 1 ; } fdiff = flen / DECIMATION ; tdiff = tlen / DECIMATION ; from -> nextcp = from -> me ; memset ( & temp , 0 , sizeof ( Spline ) ) ; temp . from = from ; temp . to = to ; for ( i = 1 ; i < DECIMATION ; ++ i ) { from -> nextcp . x += fdiff * fromunit . x ; from -> nextcp . y += fdiff * fromunit . y ; to -> prevcp = to -> me ; for ( j = 1 ; j < DECIMATION ; ++ j ) { to -> prevcp . x += tdiff * tounit . x ; to -> prevcp . y += tdiff * tounit . y ; SplineRefigure ( & temp ) ; curdiff = SigmaDeltas ( & temp , mid , cnt , & b , & db ) ; for ( k = 0 ; k < TRY_CNT ; ++ k ) { if ( curdiff < bestdiff [ k ] ) { for ( l = TRY_CNT - 1 ; l > k ; -- l ) { bestdiff [ l ] = bestdiff [ l - 1 ] ; besti [ l ] = besti [ l - 1 ] ; bestj [ l ] = bestj [ l - 1 ] ; } bestdiff [ k ] = curdiff ; besti [ k ] = i ; bestj [ k ] = j ; break ; } } } } finaldiff = 1e20 ; offn_ = offp_ = - 1 ; spline = SplineMake ( from , to , false ) ; for ( k = - 1 ; k < TRY_CNT ; ++ k ) { if ( k < 0 ) { BasePoint nextcp , prevcp ; bigreal temp1 , temp2 ; int ret = _ApproximateSplineFromPoints ( from , to , mid , cnt , & nextcp , & prevcp , false ) ; if ( ! ( ret & 1 ) || ! ( ret & 2 ) ) { continue ; } temp1 = ( prevcp . x - to -> me . x ) * tounit . x + ( prevcp . y - to -> me . y ) * tounit . y ; temp2 = ( nextcp . x - from -> me . x ) * fromunit . x + ( nextcp . y - from -> me . y ) * fromunit . y ; if ( temp1 <= 0 || temp2 <= 0 ) { continue ; } tlen = temp1 ; flen = temp2 ; } else { if ( bestj [ k ] < 0 || besti [ k ] < 0 ) { continue ; } tlen = bestj [ k ] * tdiff ; flen = besti [ k ] * fdiff ; } to -> prevcp . x = to -> me . x + tlen * tounit . x ; to -> prevcp . y = to -> me . y + tlen * tounit . y ; from -> nextcp . x = from -> me . x + flen * fromunit . x ; from -> nextcp . y = from -> me . y + flen * fromunit . y ; SplineRefigure ( spline ) ; bettern = betterp = false ; incrn = tdiff / 2.0 ; incrp = fdiff / 2.0 ; offn = flen ; offp = tlen ; nocnt = 0 ; curdiff = SigmaDeltas ( spline , mid , cnt , & b , & db ) ; totcnt = 0 ; for ( ; ; ) { bigreal fadiff , fsdiff ; bigreal tadiff , tsdiff ; from -> nextcp . x = from -> me . x + ( offn + incrn ) * fromunit . x ; from -> nextcp . y = from -> me . y + ( offn + incrn ) * fromunit . y ; to -> prevcp . x = to -> me . x + offp * tounit . x ; to -> prevcp . y = to -> me . y + offp * tounit . y ; SplineRefigure ( spline ) ; fadiff = SigmaDeltas ( spline , mid , cnt , & b , & db ) ; from -> nextcp . x = from -> me . x + ( offn - incrn ) * fromunit . x ; from -> nextcp . y = from -> me . y + ( offn - incrn ) * fromunit . y ; SplineRefigure ( spline ) ; fsdiff = SigmaDeltas ( spline , mid , cnt , & b , & db ) ; from -> nextcp . x = from -> me . x + offn * fromunit . x ; from -> nextcp . y = from -> me . y + offn * fromunit . y ; if ( offn - incrn <= 0 ) { fsdiff += 1e10 ; } to -> prevcp . x = to -> me . x + ( offp + incrp ) * tounit . x ; to -> prevcp . y = to -> me . y + ( offp + incrp ) * tounit . y ; SplineRefigure ( spline ) ; tadiff = SigmaDeltas ( spline , mid , cnt , & b , & db ) ; to -> prevcp . x = to -> me . x + ( offp - incrp ) * tounit . x ; to -> prevcp . y = to -> me . y + ( offp - incrp ) * tounit . y ; SplineRefigure ( spline ) ; tsdiff = SigmaDeltas ( spline , mid , cnt , & b , & db ) ; to -> prevcp . x = to -> me . x + offp * tounit . x ; to -> prevcp . y = to -> me . y + offp * tounit . y ; if ( offp - incrp <= 0 ) { tsdiff += 1e10 ; } if ( offn >= incrn && fsdiff < curdiff && ( fsdiff < fadiff && fsdiff < tsdiff && fsdiff < tadiff ) ) { offn -= incrn ; if ( bettern > 0 ) { incrn /= 2 ; } bettern = - 1 ; nocnt = 0 ; curdiff = fsdiff ; } if ( offn + incrn < fmax && fadiff < curdiff && ( fadiff <= fsdiff && fadiff < tsdiff && fadiff < tadiff ) ) { offn += incrn ; if ( bettern < 0 ) { incrn /= 2 ; } bettern = 1 ; nocnt = 0 ; curdiff = fadiff ; } if ( offp >= incrp && tsdiff < curdiff && ( tsdiff <= fsdiff && tsdiff <= fadiff && tsdiff < tadiff ) ) { offp -= incrp ; if ( betterp > 0 ) { incrp /= 2 ; } betterp = - 1 ; nocnt = 0 ; curdiff = tsdiff ; } if ( offp + incrp < tmax && tadiff < curdiff && ( tadiff <= fsdiff && tadiff <= fadiff && tadiff <= tsdiff ) ) { offp += incrp ; if ( betterp < 0 ) { incrp /= 2 ; } betterp = 1 ; nocnt = 0 ; curdiff = tadiff ; } else { if ( ++ nocnt > 6 ) { break ; } incrn /= 2 ; incrp /= 2 ; } if ( curdiff < 1 ) { break ; } if ( incrp < tdiff / 1024 || incrn < fdiff / 1024 ) { break ; } if ( ++ totcnt > 200 ) { break ; } if ( offn < 0 || offp < 0 ) { IError ( "Approximation got inverse control points" ) ; break ; } } } to -> noprevcp = offp_ == 0 ; from -> nonextcp = offn_ == 0 ; to -> prevcp . x = to -> me . x + offp_ * tounit . x ; to -> prevcp . y = to -> me . y + offp_ * tounit . y ; from -> nextcp . x = from -> me . x + offn_ * fromunit . x ; from -> nextcp . y = from -> me . y + offn_ * fromunit . y ; SplineRefigure ( spline ) ; return ( spline ) ; } } 