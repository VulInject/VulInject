static void atmarp_print ( netdissect_options * ndo , const u_char * bp , u_int length , u_int caplen ) { const struct atmarp_pkthdr * ap ; u_short pro , hrd , op ; ap = ( const atmarp_pkthdr * ) bp ; ND_TCHECK_SIZE ( ap ) ; hrd = ATMHRD ( ap ) ; pro = ATMPRO ( ap ) ; op = ATMOP ( ap ) ; if ( ! ndo -> ndo_eflag ) { ND_PRINT ( "ARP, " ) ; } if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || ATMSPROTO_LEN ( ap ) != 4 || ATMTPROTO_LEN ( ap ) != 4 || ndo -> ndo_vflag ) { ND_PRINT ( "%s, %s (len %u/%u)" , tok2str ( arphrd_values , "Unknown Hardware (%u)" , hrd ) , tok2str ( ethertype_values , "Unknown Protocol (0x%04x)" , pro ) , ATMSPROTO_LEN ( ap ) , ATMTPROTO_LEN ( ap ) ) ; if ( ! ndo -> ndo_vflag ) { out } } ND_PRINT ( "%s%s " , ndo -> ndo_vflag ?", " : "" , tok2str ( arpop_values , "Unknown (%u)" , op ) ) ; switch ( op ) { case ARPOP_REQUEST : ND_PRINT ( "who-has " ) ; atmarp_tpaddr_print ( ndo , ap , pro ) ; if ( ATMTHRD_LEN ( ap ) != 0 ) { ND_PRINT ( " (" ) ; atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , ATMTSA ( ap ) , ATMTSLN ( ap ) ) ; ND_PRINT ( ")" ) ; } ND_PRINT ( " tell " ) ; atmarp_spaddr_print ( ndo , ap , pro ) ; break ; case ARPOP_REPLY : atmarp_spaddr_print ( ndo , ap , pro ) ; ND_PRINT ( " is-at " ) ; atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; break ; case ARPOP_INVREQUEST : ND_PRINT ( "who-is " ) ; atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , ATMTSA ( ap ) , ATMTSLN ( ap ) ) ; ND_PRINT ( " tell " ) ; atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; break ; case ARPOP_INVREPLY : atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; ND_PRINT ( "at " ) ; atmarp_spaddr_print ( ndo , ap , pro ) ; break ; case ARPOP_NAK : ND_PRINT ( "for " ) ; atmarp_spaddr_print ( ndo , ap , pro ) ; break ; default : ND_DEFAULTPRINT ( ( const u_char * ) ap , caplen ) ; return ; } out ND_PRINT ( ", length %u" , length ) ; } 