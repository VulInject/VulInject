static struct commit * get_base_commit ( const char * base_commit , struct commit * * list , int total ) { struct commit * base = NULL ; struct commit * * rev ; int i = 0 , rev_nr = 0 , auto_select , die_on_failure ; switch ( auto_base ) { case AUTO_BASE_NEVER : if ( base_commit ) { auto_select = 0 ; die_on_failure = 1 ; } else { return NULL ; } break ; case AUTO_BASE_ALWAYS : case AUTO_BASE_WHEN_ABLE : if ( base_commit ) { BUG ( "requested automatic base selection but a commit was provided" ) ; } else { auto_select = 1 ; die_on_failure = auto_base == AUTO_BASE_ALWAYS ; } break ; default : BUG ( "unexpected automatic base selection method" ) ; } if ( ! auto_select ) { base = lookup_commit_reference_by_name ( base_commit ) ; if ( ! base ) { die ( _ ( "unknown commit %s" ) , base_commit ) ; } } else { struct branch * curr_branch = branch_get ( NULL ) ; const char * upstream = branch_get_upstream ( curr_branch , NULL ) ; if ( upstream ) { struct commit_list * base_list ; struct commit * commit ; struct object_id oid ; if ( get_oid ( upstream , & oid ) ) { if ( die_on_failure ) { die ( _ ( "failed to resolve '%s' as a valid ref" ) , upstream ) ; } else { return NULL ; } } commit = lookup_commit_or_die ( & oid , "upstream base" ) ; base_list = get_merge_bases_many ( commit , total , list ) ; if ( ! base_list || base_list -> next ) { if ( die_on_failure ) { die ( _ ( "could not find exact merge base" ) ) ; } else { return NULL ; } } base = base_list -> item ; free_commit_list ( base_list ) ; } else { if ( die_on_failure ) { die ( _ ( "failed to get upstream, if you want to record base commit automatically,\n" "please use git branch --set-upstream-to to track a remote branch.\n" "Or you could specify base commit by --base=<base-commit-id>manually" ) ) ; } else { return NULL ; } } } ALLOC_ARRAY ( rev , total ) ; for ( i = 0 ; i < total ; i ++ ) { rev [ i ] = list [ i ] ; } rev_nr = total ; while ( rev_nr > 1 ) { for ( i = 0 ; i < rev_nr / 2 ; i ++ ) { struct commit_list * merge_base ; merge_base = get_merge_bases ( rev [ 2 * i ] , rev [ 2 * i + 1 ] ) ; if ( ! merge_base || merge_base -> next ) { if ( die_on_failure ) { die ( _ ( "failed to find exact merge base" ) ) ; } else { free ( rev ) ; return NULL ; } } rev [ i ] = merge_base -> item ; } if ( rev_nr % 2 ) { rev [ i ] = rev [ 2 * i ] ; } rev_nr = DIV_ROUND_UP ( rev_nr , 2 ) ; } if ( ! in_merge_bases ( base , rev [ 0 ] ) ) { if ( die_on_failure ) { die ( _ ( "base commit should be the ancestor of revision list" ) ) ; } else { free ( rev ) ; return NULL ; } } for ( i = 0 ; i < total ; i ++ ) { if ( base == list [ i ] ) { if ( die_on_failure ) { die ( _ ( "base commit shouldn't be in revision list" ) ) ; } else { free ( rev ) ; return NULL ; } } } free ( rev ) ; return base ; } 