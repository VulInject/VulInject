som_set_reloc_info ( , , , , , ) { unsigned int op , varname , deallocate_contents = 0 ; unsigned char * end_fixups = & fixup [ end ] ; const struct fixup_format * fp ; const char * cp ; unsigned char * save_fixup ; int variables [ 26 ] , stack [ 20 ] , c , v , count , prev_fixup , * sp , saved_unwind_bits ; const int * subop ; arelent * rptr = internal_relocs ; unsigned int offset = 0 ; som_initialize_reloc_queue ( reloc_queue ) ; memset ( variables , 0 , sizeof ( variables ) ) ; memset ( stack , 0 , sizeof ( stack ) ) ; count = 0 ; prev_fixup = 0 ; saved_unwind_bits = 0 ; sp = stack ; while ( fixup < end_fixups ) { save_fixup = fixup ; op = * fixup ++ ; fp = & som_fixup_formats [ op ] ; if ( * fp -> format == 'P' ) { fixup = reloc_queue [ fp -> D ] . reloc ; som_reloc_queue_fix ( reloc_queue , fp -> D ) ; prev_fixup = 1 ; op = * fixup ++ ; fp = & som_fixup_formats [ op ] ; } if ( ! just_count && som_hppa_howto_table [ op ] . type != R_NO_RELOCATION && som_hppa_howto_table [ op ] . type != R_DATA_OVERRIDE ) { rptr -> address = offset ; rptr -> howto = & som_hppa_howto_table [ op ] ; rptr -> addend = 0 ; rptr -> sym_ptr_ptr = bfd_abs_section_ptr -> symbol_ptr_ptr ; } var ( 'L' ) = 0 ; var ( 'D' ) = fp -> D ; var ( 'U' ) = saved_unwind_bits ; cp = fp -> format ; while ( * cp ) { varname = * cp ++ ; { c = * cp ++ ; if ( ISUPPER ( c ) ) { push ( var ( c ) ) ; } if ( ISLOWER ( c ) ) { int bits = ( c - 'a' ) * 8 ; for ( v = 0 ; c > 'a' ; -- c ) { v = ( v << 8 ) | * fixup ++ ; } if ( varname == 'V' ) { v = sign_extend ( v , bits ) ; } push ( v ) ; } if ( ISDIGIT ( c ) ) { v = c - '0' ; while ( ISDIGIT ( * cp ) ) { v = ( v * 10 ) + ( * cp ++ - '0' ) ; } push ( v ) ; } else { switch ( c ) { case '+' : v = pop ( ) ; v += pop ( ) ; push ( v ) ; break ; case '*' : v = pop ( ) ; v *= pop ( ) ; push ( v ) ; break ; case '<' : v = pop ( ) ; v = pop ( ) << v ; push ( v ) ; break ; default : abort ( ) ; } } } * cp && * cp != '=' ; cp ++ ; c = pop ( ) ; var ( varname ) = c ; switch ( varname ) { case 'L' : offset += c ; break ; case 'S' : if ( ! just_count ) { rptr -> sym_ptr_ptr = & symbols [ c ] ; } break ; case 'R' : if ( ! just_count ) { unsigned int tmp = var ( 'R' ) ; rptr -> addend = 0 ; if ( ( som_hppa_howto_table [ op ] . type == R_PCREL_CALL && R_PCREL_CALL + 10 > op ) || ( som_hppa_howto_table [ op ] . type == R_ABS_CALL && R_ABS_CALL + 10 > op ) ) { if ( tmp > 4 ) { tmp -= 5 ; rptr -> addend |= 1 ; } if ( tmp == 4 ) { rptr -> addend |= 1 << 8 | 1 << 6 | 1 << 4 | 1 << 2 ; } if ( tmp == 3 ) { rptr -> addend |= 1 << 8 | 1 << 6 | 1 << 4 ; } if ( tmp == 2 ) { rptr -> addend |= 1 << 8 | 1 << 6 ; } if ( tmp == 1 ) { rptr -> addend |= 1 << 8 ; } } else { unsigned int tmp1 , tmp2 ; rptr -> addend = tmp & 0x3 ; tmp >>= 2 ; tmp1 = tmp / 10 ; tmp -= tmp1 * 10 ; if ( tmp1 == 9 ) { rptr -> addend += ( 0xe << 6 ) ; } else { tmp2 = tmp1 / 3 ; tmp1 -= tmp2 * 3 ; rptr -> addend += ( tmp2 << 8 ) + ( tmp1 << 6 ) ; } if ( tmp == 9 ) { rptr -> addend += ( 0xe << 2 ) ; } else { tmp2 = tmp / 3 ; tmp -= tmp2 * 3 ; rptr -> addend += ( tmp2 << 4 ) + ( tmp << 2 ) ; } } rptr -> addend = HPPA_R_ADDEND ( rptr -> addend , 0 ) ; } break ; case 'O' : switch ( op ) { case R_COMP1 : subop = comp1_opcodes ; break ; case R_COMP2 : subop = comp2_opcodes ; break ; case R_COMP3 : subop = comp3_opcodes ; break ; default : abort ( ) ; } while ( * subop <= ( unsigned char ) c ) { ++ subop ; } -- subop ; break ; case 'U' : saved_unwind_bits = var ( 'U' ) ; break ; default : break ; } } if ( prev_fixup ) { fixup = save_fixup + 1 ; prev_fixup = 0 ; } if ( fixup > save_fixup + 1 ) { som_reloc_queue_insert ( save_fixup , fixup - save_fixup , reloc_queue ) ; } if ( som_hppa_howto_table [ op ] . type != R_DATA_OVERRIDE && som_hppa_howto_table [ op ] . type != R_NO_RELOCATION ) { if ( ! just_count ) { if ( som_hppa_howto_table [ op ] . type == R_ENTRY ) { rptr -> addend = var ( 'T' ) ; } if ( som_hppa_howto_table [ op ] . type == R_EXIT ) { rptr -> addend = var ( 'U' ) ; } if ( som_hppa_howto_table [ op ] . type == R_PCREL_CALL || som_hppa_howto_table [ op ] . type == R_ABS_CALL ) { } if ( som_hppa_howto_table [ op ] . type == R_DATA_ONE_SYMBOL ) { rptr -> addend = var ( 'V' ) ; if ( rptr -> addend == 0 && ! section -> contents ) { bfd_byte * contents ; if ( ! bfd_malloc_and_get_section ( section -> owner , section , & contents ) ) { if ( contents != NULL ) { free ( contents ) ; } return ( unsigned ) - 1 ; } section -> contents = contents ; } if ( rptr -> addend == 0 ) { rptr -> addend = bfd_get_32 ( section -> owner , ( section -> contents + offset - var ( 'L' ) ) ) ; } } else { rptr -> addend = var ( 'V' ) ; } rptr ++ ; } count ++ ; memset ( variables , 0 , sizeof ( variables ) ) ; memset ( stack , 0 , sizeof ( stack ) ) ; } } if ( deallocate_contents ) { free ( section -> contents ) ; } return count ; } 