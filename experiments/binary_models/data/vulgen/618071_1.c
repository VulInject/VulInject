bool dcn21_fast_validate_bw ( struct dc * dc , struct dc_state * context , display_e2e_pipe_params_st * pipes , int * pipe_cnt_out , int * pipe_split_from , int * vlevel_out , bool fast_validate ) { bool out = false ; int split [ MAX_PIPES ] { 0 } ; ; int pipe_cnt , i , pipe_idx , vlevel ; ASSERT ( pipes ) ; dcn20_merge_pipes_for_validate ( dc , context ) ; DC_FP_START ( ) ; pipe_cnt = dc -> res_pool -> funcs -> populate_dml_pipes ( dc , context , pipes , fast_validate ) ; DC_FP_END ( ) ; * pipe_cnt_out = pipe_cnt ; if ( ! pipe_cnt ) { out = true ; validate_out } context -> bw_ctx . dml . soc . allow_dram_self_refresh_or_dram_clock_change_in_vblank = dm_allow_self_refresh_and_mclk_switch ; vlevel = dml_get_voltage_level ( & context -> bw_ctx . dml , pipes , pipe_cnt ) ; if ( vlevel > context -> bw_ctx . dml . soc . num_states ) { context -> bw_ctx . dml . soc . allow_dram_self_refresh_or_dram_clock_change_in_vblank = dm_allow_self_refresh ; vlevel = dml_get_voltage_level ( & context -> bw_ctx . dml , pipes , pipe_cnt ) ; if ( vlevel > context -> bw_ctx . dml . soc . num_states ) { validate_fail } } vlevel = dcn20_validate_apply_pipe_split_flags ( dc , context , vlevel , split , NULL ) ; for ( i = 0 , pipe_idx = 0 ; i < dc -> res_pool -> pipe_count ; i ++ ) { struct pipe_ctx * pipe = & context -> res_ctx . pipe_ctx [ i ] ; struct pipe_ctx * mpo_pipe = pipe -> bottom_pipe ; struct vba_vars_st * vba = & context -> bw_ctx . dml . vba ; if ( ! pipe -> stream ) { continue ; } if ( vba -> ODMCombineEnabled [ vba -> pipe_plane [ pipe_idx ] ] != dm_odm_combine_mode_disabled && pipe -> plane_state && mpo_pipe && memcmp ( & mpo_pipe -> plane_res . scl_data . recout , & pipe -> plane_res . scl_data . recout , sizeof ( rect ) ) != 0 ) { ASSERT ( mpo_pipe -> plane_state != pipe -> plane_state ) ; validate_fail } pipe_idx ++ ; } for ( i = 0 ; i < MAX_PIPES ; i ++ ) { pipe_split_from [ i ] = - 1 ; } for ( i = 0 , pipe_idx = - 1 ; i < dc -> res_pool -> pipe_count ; i ++ ) { struct pipe_ctx * pipe = & context -> res_ctx . pipe_ctx [ i ] ; struct pipe_ctx * hsplit_pipe = pipe -> bottom_pipe ; if ( ! pipe -> stream || pipe_split_from [ i ] >= 0 ) { continue ; } pipe_idx ++ ; if ( ! pipe -> top_pipe && ! pipe -> plane_state && context -> bw_ctx . dml . vba . ODMCombineEnabled [ pipe_idx ] ) { hsplit_pipe = dcn20_find_secondary_pipe ( dc , & context -> res_ctx , dc -> res_pool , pipe ) ; ASSERT ( hsplit_pipe ) ; if ( ! dcn20_split_stream_for_odm ( dc , & context -> res_ctx , pipe , hsplit_pipe ) ) { validate_fail } pipe_split_from [ hsplit_pipe -> pipe_idx ] = pipe_idx ; dcn20_build_mapped_resource ( dc , context , pipe -> stream ) ; } if ( ! pipe -> plane_state ) { continue ; } if ( pipe -> top_pipe && pipe -> plane_state == pipe -> top_pipe -> plane_state ) { continue ; } if ( split [ i ] == 2 ) { if ( ! hsplit_pipe || hsplit_pipe -> plane_state != pipe -> plane_state ) { hsplit_pipe = dcn20_find_secondary_pipe ( dc , & context -> res_ctx , dc -> res_pool , pipe ) ; ASSERT ( hsplit_pipe ) ; if ( ! hsplit_pipe ) { DC_FP_START ( ) ; dcn20_fpu_adjust_dppclk ( & context -> bw_ctx . dml . vba , vlevel , context -> bw_ctx . dml . vba . maxMpcComb , pipe_idx , true ) ; DC_FP_END ( ) ; continue ; } if ( context -> bw_ctx . dml . vba . ODMCombineEnabled [ pipe_idx ] ) { if ( ! dcn20_split_stream_for_odm ( dc , & context -> res_ctx , pipe , hsplit_pipe ) ) { validate_fail } dcn20_build_mapped_resource ( dc , context , pipe -> stream ) ; } else { dcn20_split_stream_for_mpc ( & context -> res_ctx , dc -> res_pool , pipe , hsplit_pipe ) ; resource_build_scaling_params ( pipe ) ; resource_build_scaling_params ( hsplit_pipe ) ; } pipe_split_from [ hsplit_pipe -> pipe_idx ] = pipe_idx ; } } if ( hsplit_pipe && hsplit_pipe -> plane_state == pipe -> plane_state ) { ASSERT ( 0 ) ; } } if ( ! dcn20_validate_dsc ( dc , context ) ) { context -> bw_ctx . dml . vba . ValidationStatus [ context -> bw_ctx . dml . vba . soc . num_states ] = DML_FAIL_DSC_VALIDATION_FAILURE ; validate_fail } * vlevel_out = vlevel ; out = true ; validate_out validate_fail out = false ; validate_out return out ; } 