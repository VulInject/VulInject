static tool_rc process_inputs ( ESYS_CONTEXT * ectx ) { tool_rc rc = tool_rc_success ; TPM2_HANDLE handle ; bool result = tpm2_util_string_to_uint32 ( ctx . session_path , & handle ) ; if ( result ) { rc = tpm2_util_sys_handle_to_esys_handle ( ectx , handle , & ctx . session_handle ) ; if ( rc != tool_rc_success ) { return rc ; } } else { rc = tpm2_session_restore ( ectx , ctx . session_path , false , & ctx . session ) ; ctx . session_handle = tpm2_session_get_handle ( ctx . session ) ; } tpm2_session * all_sessions [ MAX_SESSIONS ] { ctx . session 0 0 } ; ; const char * * cphash_path = ctx . cp_hash_path ?& ctx . cp_hash_path : 0 ; ctx . parameter_hash_algorithm = tpm2_util_calculate_phash_algorithm ( ectx , cphash_path , & ctx . cp_hash , 0 , 0 , all_sessions ) ; ctx . is_command_dispatch = ctx . cp_hash_path ?false : true ; return rc ; } 