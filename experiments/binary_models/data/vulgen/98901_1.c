static void stm32_uart_isr ( struct mgos_uart_state * us ) { bool dispatch = false ; const struct mgos_uart_config * cfg = & us -> cfg ; struct stm32_uart_state * uds = ( stm32_uart_state * ) us -> dev_data ; volatile USART_TypeDef * regs = uds -> regs ; const uint32_t ints = regs -> ISR ; const uint32_t cr1 = regs -> CR1 ; us -> stats . ints ++ ; if ( ints & USART_ISR_ORE ) { us -> stats . rx_overflows ++ ; stm32_uart_clear_ovf_int ( us ) ; } if ( ints & ( USART_ISR_FE | USART_ISR_NE ) ) { regs -> ICR = USART_ICR_FECF | USART_ICR_NCF ; } if ( ints & USART_ISR_CTSIF ) { if ( ( ints & USART_ISR_CTS ) == 0 && uds -> itx_buf . used > 0 ) { us -> stats . tx_throttles ++ ; } stm32_uart_clear_cts_int ( uds ) ; } if ( ( ints & USART_ISR_TXE ) && ( cr1 & USART_CR1_TXEIE ) ) { struct cs_rbuf * itxb = & uds -> itx_buf ; us -> stats . tx_ints ++ ; stm32_uart_tx_byte_from_buf ( us ) ; if ( itxb -> used < UART_ISR_BUF_DISP_THRESH ) { dispatch = true ; } if ( itxb -> used == 0 ) { CLEAR_BIT ( regs -> CR1 , USART_CR1_TXEIE ) ; } } if ( ( ints & USART_ISR_RXNE ) && ( cr1 & USART_CR1_RXNEIE ) ) { struct cs_rbuf * irxb = & uds -> irx_buf ; us -> stats . rx_ints ++ ; if ( irxb -> avail > 0 ) { uint8_t data = stm32_uart_rx_byte ( us ) ; cs_rbuf_append_one ( irxb , data ) ; } if ( irxb -> avail > UART_ISR_BUF_DISP_THRESH ) { regs -> ICR = USART_ICR_RTOCF ; SET_BIT ( regs -> CR1 , USART_CR1_RTOIE ) ; dispatch = true ; } else { if ( cfg -> rx_fc_type == MGOS_UART_FC_SW && irxb -> avail < UART_ISR_BUF_XOFF_THRESH && ! us -> xoff_sent ) { stm32_uart_tx_byte ( us , MGOS_UART_XOFF_CHAR ) ; us -> xoff_sent = true ; } if ( irxb -> avail == 0 ) { CLEAR_BIT ( regs -> CR1 , USART_CR1_RXNEIE ) ; } dispatch = true ; } } if ( ( ints & USART_ISR_RTOF ) && ( cr1 & USART_CR1_RTOIE ) ) { if ( uds -> irx_buf . used > 0 ) { dispatch = true ; } CLEAR_BIT ( regs -> CR1 , USART_CR1_RTOIE ) ; regs -> ICR = USART_ICR_RTOCF ; } if ( dispatch ) { mgos_uart_schedule_dispatcher ( us -> uart_no , true ) ; } } 