static void m32r_select_section PARAMS ( ( tree , int , unsigned HOST_WIDE_INT ) ) ; static void m32r_encode_section_info PARAMS ( ( tree , int ) ) ; static const char * m32r_strip_name_encoding PARAMS ( ( const char * ) ) ; static void init_idents PARAMS ( ( void ) ) ; struct gcc_target targetm = TARGET_INITIALIZER ; void m32r_init ( ) { init_reg_tables ( ) ; m32r_punct_chars [ '#' ] = 1 ; m32r_punct_chars [ '@' ] = 1 ; if ( ! g_switch_set ) { g_switch_value = SDATA_DEFAULT_SIZE ; } if ( strcmp ( m32r_model_string , "small" ) == 0 ) { m32r_model = M32R_MODEL_SMALL ; } if ( strcmp ( m32r_model_string , "medium" ) == 0 ) { m32r_model = M32R_MODEL_MEDIUM ; } if ( strcmp ( m32r_model_string , "large" ) == 0 ) { m32r_model = M32R_MODEL_LARGE ; } else { error ( "bad value (%s) for -mmodel switch" , m32r_model_string ) ; } if ( strcmp ( m32r_sdata_string , "none" ) == 0 ) { m32r_sdata = M32R_SDATA_NONE ; } if ( strcmp ( m32r_sdata_string , "sdata" ) == 0 ) { m32r_sdata = M32R_SDATA_SDATA ; } if ( strcmp ( m32r_sdata_string , "use" ) == 0 ) { m32r_sdata = M32R_SDATA_USE ; } else { error ( "bad value (%s) for -msdata switch" , m32r_sdata_string ) ; } } 