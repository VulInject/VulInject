static void dnode_sync_free ( dnode_t * dn , dmu_tx_t * tx ) { int txgoff = tx -> tx_txg & TXG_MASK ; ASSERT ( dmu_tx_is_syncing ( tx ) ) ; ASSERT0 ( DN_USED_BYTES ( dn -> dn_phys ) ) ; ASSERT ( BP_IS_HOLE ( dn -> dn_phys -> dn_blkptr ) ) ; dnode_undirty_dbufs ( & dn -> dn_dirty_records [ txgoff ] ) ; dnode_evict_dbufs ( dn ) ; dn -> dn_next_nlevels [ txgoff ] = 0 ; dn -> dn_next_indblkshift [ txgoff ] = 0 ; dn -> dn_next_blksz [ txgoff ] = 0 ; ASSERT ( dn -> dn_phys -> dn_type != DMU_OT_NONE ) ; ASSERT ( dn -> dn_type != DMU_OT_NONE ) ; ASSERT ( dn -> dn_free_txg > 0 ) ; if ( dn -> dn_allocated_txg != dn -> dn_free_txg ) { dmu_buf_will_dirty ( & dn -> dn_dbuf -> db , tx ) ; } mutex_enter ( & dn -> dn_mtx ) ; dn -> dn_type = DMU_OT_NONE ; dn -> dn_maxblkid = 0 ; dn -> dn_allocated_txg = 0 ; dn -> dn_free_txg = 0 ; dn -> dn_have_spill = B_FALSE ; mutex_exit ( & dn -> dn_mtx ) ; ASSERT ( dn -> dn_object != DMU_META_DNODE_OBJECT ) ; dnode_rele ( dn , ( void * ) ( uintptr_t ) tx -> tx_txg ) ; } 