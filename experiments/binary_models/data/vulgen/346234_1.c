static void netlink_find_offload_feature ( const char * ifname , struct logger * logger ) { netlink_esp_hw_offload . state = NIC_OFFLOAD_UNSUPPORTED ; struct ethtool_sset_info * sset_info = alloc_bytes ( sizeof ( * sset_info ) + sizeof ( sset_info -> data [ 0 ] ) , "ethtool_sset_info" ) ; sset_info -> cmd = ETHTOOL_GSSET_INFO ; sset_info -> sset_mask = 1ULL << ETH_SS_FEATURES ; if ( ! siocethtool ( ifname , sset_info , "ETHTOOL_GSSET_INFO" , logger ) || sset_info -> sset_mask != 1ULL << ETH_SS_FEATURES ) { llog ( RC_LOG , logger , "Kernel does not support NIC esp-hw-offload (ETHTOOL_GSSET_INFO failed)" ) ; return ; } uint32_t sset_len = sset_info -> data [ 0 ] ; pfree ( sset_info ) ; struct ethtool_gstrings * cmd = alloc_bytes ( sizeof ( * cmd ) + ETH_GSTRING_LEN * sset_len , "ethtool_gstrings" ) ; cmd -> cmd = ETHTOOL_GSTRINGS ; cmd -> string_set = ETH_SS_FEATURES ; if ( siocethtool ( ifname , cmd , "ETHTOOL_GSTRINGS" , logger ) ) { char * str = ( char * ) cmd -> data ; for ( uint32_t i = 0 ; i < cmd -> len ; i ++ ) { if ( strneq ( str , "esp-hw-offload" , ETH_GSTRING_LEN ) ) { netlink_esp_hw_offload . bit = i ; netlink_esp_hw_offload . total_blocks = ( sset_len + 31 ) / 32 ; netlink_esp_hw_offload . state = NIC_OFFLOAD_SUPPORTED ; break ; } str += ETH_GSTRING_LEN ; } } pfree ( cmd ) ; if ( netlink_esp_hw_offload . state == NIC_OFFLOAD_SUPPORTED ) { llog ( RC_LOG , logger , "Kernel supports NIC esp-hw-offload" ) ; } else { llog ( RC_LOG , logger , "Kernel does not support NIC esp-hw-offload" ) ; } } 