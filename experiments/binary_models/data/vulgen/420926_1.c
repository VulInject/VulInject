static int _transport_smp_handler ( struct Scsi_Host * shost , struct sas_rphy * rphy , struct request * req ) { struct MPT3SAS_ADAPTER * ioc = shost_priv ( shost ) ; Mpi2SmpPassthroughRequest_t * mpi_request ; Mpi2SmpPassthroughReply_t * mpi_reply ; int rc ; u16 smid ; u32 ioc_state ; void * psge ; u8 issue_reset = 0 ; dma_addr_t dma_addr_in = 0 ; dma_addr_t dma_addr_out = 0 ; dma_addr_t pci_dma_in = 0 ; dma_addr_t pci_dma_out = 0 ; void * pci_addr_in = NULL ; void * pci_addr_out = NULL ; u16 wait_state_count ; struct request * rsp = req -> next_rq ; struct bio_vec bvec ; struct bvec_iter iter ; if ( ! rsp ) { pr_err ( MPT3SAS_FMT "%s: the smp response space is missing\n" , ioc -> name , __func__ ) ; return - EINVAL ; } if ( ioc -> shost_recovery || ioc -> pci_error_recovery ) { pr_info ( MPT3SAS_FMT "%s: host reset in progress!\n" , __func__ , ioc -> name ) ; return - EFAULT ; } rc = mutex_lock_interruptible ( & ioc -> transport_cmds . mutex ) ; if ( rc ) { return rc ; } ioc -> transport_cmds . status = MPT3_CMD_PENDING ; if ( bio_multiple_segments ( req -> bio ) ) { u32 offset = 0 ; pci_addr_out = pci_alloc_consistent ( ioc -> pdev , blk_rq_bytes ( req ) , & pci_dma_out ) ; if ( ! pci_addr_out ) { pr_info ( MPT3SAS_FMT "%s(): PCI Addr out = NULL\n" , ioc -> name , __func__ ) ; rc = - ENOMEM ; out } bio_for_each_segment ( , , ) { memcpy ( pci_addr_out + offset , page_address ( bvec . bv_page ) + bvec . bv_offset , bvec . bv_len ) ; offset += bvec . bv_len ; } } else { dma_addr_out = pci_map_single ( ioc -> pdev , bio_data ( req -> bio ) , blk_rq_bytes ( req ) , PCI_DMA_BIDIRECTIONAL ) ; if ( pci_dma_mapping_error ( ioc -> pdev , dma_addr_out ) ) { pr_info ( MPT3SAS_FMT "%s(): DMA Addr out = NULL\n" , ioc -> name , __func__ ) ; rc = - ENOMEM ; free_pci } } if ( bio_multiple_segments ( rsp -> bio ) ) { pci_addr_in = pci_alloc_consistent ( ioc -> pdev , blk_rq_bytes ( rsp ) , & pci_dma_in ) ; if ( ! pci_addr_in ) { pr_info ( MPT3SAS_FMT "%s(): PCI Addr in = NULL\n" , ioc -> name , __func__ ) ; rc = - ENOMEM ; unmap } } else { dma_addr_in = pci_map_single ( ioc -> pdev , bio_data ( rsp -> bio ) , blk_rq_bytes ( rsp ) , PCI_DMA_BIDIRECTIONAL ) ; if ( pci_dma_mapping_error ( ioc -> pdev , dma_addr_in ) ) { pr_info ( MPT3SAS_FMT "%s(): DMA Addr in = NULL\n" , ioc -> name , __func__ ) ; rc = - ENOMEM ; unmap } } wait_state_count = 0 ; ioc_state = mpt3sas_base_get_iocstate ( ioc , 1 ) ; while ( ioc_state != MPI2_IOC_STATE_OPERATIONAL ) { if ( wait_state_count ++ == 10 ) { pr_err ( MPT3SAS_FMT "%s: failed due to ioc not operational\n" , ioc -> name , __func__ ) ; rc = - EFAULT ; unmap } ssleep ( 1 ) ; ioc_state = mpt3sas_base_get_iocstate ( ioc , 1 ) ; pr_info ( MPT3SAS_FMT "%s: waiting for operational state(count=%d)\n" , ioc -> name , __func__ , wait_state_count ) ; } if ( wait_state_count ) { pr_info ( MPT3SAS_FMT "%s: ioc is operational\n" , ioc -> name , __func__ ) ; } smid = mpt3sas_base_get_smid ( ioc , ioc -> transport_cb_idx ) ; if ( ! smid ) { pr_err ( MPT3SAS_FMT "%s: failed obtaining a smid\n" , ioc -> name , __func__ ) ; rc = - EAGAIN ; unmap } rc = 0 ; mpi_request = mpt3sas_base_get_msg_frame ( ioc , smid ) ; ioc -> transport_cmds . smid = smid ; memset ( mpi_request , 0 , sizeof ( Mpi2SmpPassthroughRequest_t ) ) ; mpi_request -> Function = MPI2_FUNCTION_SMP_PASSTHROUGH ; mpi_request -> PhysicalPort = 0xFF ; mpi_request -> SASAddress = ( rphy ) ?cpu_to_le64 ( rphy -> identify . sas_address ) : cpu_to_le64 ( ioc -> sas_hba . sas_address ) ; mpi_request -> RequestDataLength = cpu_to_le16 ( blk_rq_bytes ( req ) - 4 ) ; psge = & mpi_request -> SGL ; if ( bio_multiple_segments ( req -> bio ) ) { ioc -> build_sg ( ioc , psge , pci_dma_out , ( blk_rq_bytes ( req ) - 4 ) , pci_dma_in , ( blk_rq_bytes ( rsp ) + 4 ) ) ; } else { ioc -> build_sg ( ioc , psge , dma_addr_out , ( blk_rq_bytes ( req ) - 4 ) , dma_addr_in , ( blk_rq_bytes ( rsp ) + 4 ) ) ; } dtransportprintk ( ioc , pr_info ( MPT3SAS_FMT "%s - sending smp request\n" , ioc -> name , __func__ ) ) ; init_completion ( & ioc -> transport_cmds . done ) ; ioc -> put_smid_default ( ioc , smid ) ; wait_for_completion_timeout ( & ioc -> transport_cmds . done , 10 * HZ ) ; if ( ! ( ioc -> transport_cmds . status & MPT3_CMD_COMPLETE ) ) { pr_err ( MPT3SAS_FMT "%s : timeout\n" , __func__ , ioc -> name ) ; _debug_dump_mf ( mpi_request , sizeof ( Mpi2SmpPassthroughRequest_t ) / 4 ) ; if ( ! ( ioc -> transport_cmds . status & MPT3_CMD_RESET ) ) { issue_reset = 1 ; } issue_host_reset } dtransportprintk ( ioc , pr_info ( MPT3SAS_FMT "%s - complete\n" , ioc -> name , __func__ ) ) ; if ( ioc -> transport_cmds . status & MPT3_CMD_REPLY_VALID ) { mpi_reply = ioc -> transport_cmds . reply ; dtransportprintk ( ioc , pr_info ( MPT3SAS_FMT "%s - reply data transfer size(%d)\n" , ioc -> name , __func__ , le16_to_cpu ( mpi_reply -> ResponseDataLength ) ) ) ; memcpy ( scsi_req ( req ) -> sense , mpi_reply , sizeof ( * mpi_reply ) ) ; scsi_req ( req ) -> sense_len = sizeof ( * mpi_reply ) ; scsi_req ( req ) -> resid_len = 0 ; scsi_req ( rsp ) -> resid_len -= le16_to_cpu ( mpi_reply -> ResponseDataLength ) ; if ( bio_multiple_segments ( rsp -> bio ) ) { u32 offset = 0 ; u32 bytes_to_copy = le16_to_cpu ( mpi_reply -> ResponseDataLength ) ; bio_for_each_segment ( , , ) { if ( bytes_to_copy <= bvec . bv_len ) { memcpy ( page_address ( bvec . bv_page ) + bvec . bv_offset , pci_addr_in + offset , bytes_to_copy ) ; break ; } else { memcpy ( page_address ( bvec . bv_page ) + bvec . bv_offset , pci_addr_in + offset , bvec . bv_len ) ; bytes_to_copy -= bvec . bv_len ; } offset += bvec . bv_len ; } } } else { dtransportprintk ( ioc , pr_info ( MPT3SAS_FMT "%s - no reply\n" , ioc -> name , __func__ ) ) ; rc = - ENXIO ; } issue_host_reset if ( issue_reset ) { mpt3sas_base_hard_reset_handler ( ioc , FORCE_BIG_HAMMER ) ; rc = - ETIMEDOUT ; } unmap if ( dma_addr_out ) { pci_unmap_single ( ioc -> pdev , dma_addr_out , blk_rq_bytes ( req ) , PCI_DMA_BIDIRECTIONAL ) ; } if ( dma_addr_in ) { pci_unmap_single ( ioc -> pdev , dma_addr_in , blk_rq_bytes ( rsp ) , PCI_DMA_BIDIRECTIONAL ) ; } free_pci if ( pci_addr_out ) { pci_free_consistent ( ioc -> pdev , blk_rq_bytes ( req ) , pci_addr_out , pci_dma_out ) ; } if ( pci_addr_in ) { pci_free_consistent ( ioc -> pdev , blk_rq_bytes ( rsp ) , pci_addr_in , pci_dma_in ) ; } out ioc -> transport_cmds . status = MPT3_CMD_NOT_USED ; mutex_unlock ( & ioc -> transport_cmds . mutex ) ; return rc ; } 