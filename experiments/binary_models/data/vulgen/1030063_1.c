sval ( ) { SKIP_WHITESPACE ( ) ; if ( * input_line_pointer == '\'' ) { int c ; input_line_pointer ++ ; c = * input_line_pointer ++ ; while ( c != '\'' ) { if ( c == '%' ) { c = ( tohex ( input_line_pointer [ 0 ] ) << 4 ) | tohex ( input_line_pointer [ 1 ] ) ; input_line_pointer += 2 ; } FRAG_APPEND_1_CHAR ( c ) ; c = * input_line_pointer ++ ; } } } const pseudo_typeS md_pseudo_table [ ] { { "int" cons 2 } { "data.b" cons 1 } { "data.w" cons 2 } { "data.l" cons 4 } { "form" listing_psize 0 } { "heading" listing_title 0 } { "import" s_ignore 0 } { "page" listing_eject 0 } { "program" s_ignore 0 } { "z8001" s_segm 1 } { "z8002" s_segm 0 } { "segm" s_segm 1 } { "unsegm" s_segm 0 } { "unseg" s_segm 0 } { "name" s_app_file 0 } { "global" s_globl 0 } { "wval" cons 2 } { "lval" cons 4 } { "bval" cons 1 } { "sval" sval 0 } { "rsect" obj_coff_section 0 } { "sect" obj_coff_section 0 } { "block" s_space 0 } { "even" even 0 } { 0 0 0 } } ; ; const char EXP_CHARS [ ] "eE" ; ; const char FLT_CHARS [ ] "rRsSfFdDxXpP" ; ; static struct hash_control * opcode_hash_control ; void md_begin ( void ) { const opcode_entry_type * opcode ; int idx = - 1 ; opcode_hash_control = hash_new ( ) ; for ( opcode = z8k_table ; opcode -> name ; opcode ++ ) { if ( idx != opcode -> idx ) { hash_insert ( opcode_hash_control , opcode -> name , ( char * ) opcode ) ; } idx = opcode -> idx ; } if ( ! z8k_target_from_cmdline ) { s_segm ( 0 ) ; } for ( idx = 0 ; md_pseudo_table [ idx ] . poc_name ; idx ++ ) { opcode_entry_type * fake_opcode ; fake_opcode = ( opcode_entry_type * ) malloc ( sizeof ( opcode_entry_type ) ) ; fake_opcode -> name = md_pseudo_table [ idx ] . poc_name ; fake_opcode -> func = ( void * ) ( md_pseudo_table + idx ) ; fake_opcode -> opcode = 250 ; hash_insert ( opcode_hash_control , fake_opcode -> name , fake_opcode ) ; } } 