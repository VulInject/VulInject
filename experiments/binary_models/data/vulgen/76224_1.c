DWORD netlogon_auth ( char * server , char * domain , DWORD flags ) { mlsvc_handle_t netr_handle ; netr_info_t * netr_info ; int rc ; DWORD leout_rc [ 2 ] ; boolean_t retry ; DWORD status ; status = netr_open ( server , domain , & netr_handle ) ; if ( status != 0 ) { syslog ( LOG_ERR , "netlogon_auth remote open failed (%s)" , xlate_nt_status ( status ) ) ; return ( status ) ; } netr_info = & netr_global_info ; netr_info -> flags = flags ; rc = smb_getnetbiosname ( netr_info -> hostname , NETBIOS_NAME_SZ ) ; if ( rc != 0 ) { errout } ( void ) snprintf ( netr_info -> server , sizeof ( netr_info -> server ) , "\\\\%s" , server ) ; rc = smb_getdomainname ( netr_info -> nb_domain , sizeof ( netr_info -> nb_domain ) ) ; if ( rc != 0 ) { errout } rc = smb_getfqdomainname ( netr_info -> fqdn_domain , sizeof ( netr_info -> fqdn_domain ) ) ; if ( rc != 0 ) { errout } { retry = B_FALSE ; LE_OUT32 ( & leout_rc [ 0 ] , arc4random ( ) ) ; LE_OUT32 ( & leout_rc [ 1 ] , arc4random ( ) ) ; ( void ) memcpy ( & netr_info -> client_challenge , leout_rc , sizeof ( netr_credential ) ) ; if ( ! passes_dc_mitigation ( netr_info -> client_challenge . data ) ) { retry = B_TRUE ; } } retry ; if ( ( rc = netr_server_req_challenge ( & netr_handle , netr_info ) ) == 0 ) { rc = netr_server_authenticate2 ( & netr_handle , netr_info ) ; if ( rc == 0 ) { smb_update_netlogon_seqnum ( ) ; netr_info -> flags |= NETR_FLG_VALID ; } } errout ( void ) netr_close ( & netr_handle ) ; return ( ( rc ) ?NT_STATUS_UNSUCCESSFUL : NT_STATUS_SUCCESS ) ; } 