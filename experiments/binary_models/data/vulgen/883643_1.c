vcpu_notify_t vlapic_set_intr_ready ( struct vlapic * vlapic , int vector , bool level ) { struct LAPIC * lapic ; uint32_t * irrptr , * tmrptr , mask , tmr ; int idx ; KASSERT ( vector >= 0 && vector < 256 , ( "invalid vector %d" , vector ) ) ; lapic = vlapic -> apic_page ; if ( ! ( lapic -> svr & APIC_SVR_ENABLE ) ) { return ( VCPU_NOTIFY_NONE ) ; } if ( vector < 16 ) { return ( VCPU_NOTIFY_NONE ) ; } if ( vlapic -> ops . set_intr_ready ) { return ( * vlapic -> ops . set_intr_ready ( vlapic , vector , level ) ) ; } idx = ( vector / 32 ) * 4 ; mask = 1 << ( vector % 32 ) ; tmrptr = & lapic -> tmr0 ; irrptr = & lapic -> irr0 ; tmr = atomic_load_acq_32 ( & tmrptr [ idx ] ) ; if ( ( tmr & mask ) != ( level ?mask : 0 ) ) { if ( level ) { atomic_set_int ( & tmrptr [ idx ] , mask ) ; } else { atomic_clear_int ( & tmrptr [ idx ] , mask ) ; } } atomic_set_int ( & irrptr [ idx ] , mask ) ; return ( VCPU_NOTIFY_EXIT ) ; } 