static int imapdriver_get_envelopes_list ( mailsession * session , struct mailmessage_list * env_list ) { struct mailimap_set * set ; struct mailimap_fetch_att * fetch_att ; struct mailimap_fetch_type * fetch_type ; int res ; clist * fetch_result ; int r ; uint32_t exists ; clist * msg_list ; clistiter * set_iter ; if ( get_imap_session ( session ) -> imap_selection_info == NULL ) { res = MAIL_ERROR_BAD_STATE ; err } imap_flags_store_process ( get_imap_session ( session ) , get_data ( session ) -> imap_flags_store ) ; exists = get_imap_session ( session ) -> imap_selection_info -> sel_exists ; if ( exists == 0 ) { return MAIL_NO_ERROR ; } fetch_type = mailimap_fetch_type_new_fetch_att_list_empty ( ) ; if ( fetch_type == NULL ) { res = MAIL_ERROR_MEMORY ; err } fetch_att = mailimap_fetch_att_new_uid ( ) ; if ( fetch_att == NULL ) { res = MAIL_ERROR_MEMORY ; free_fetch_type } r = mailimap_fetch_type_new_fetch_att_list_add ( fetch_type , fetch_att ) ; if ( r != MAILIMAP_NO_ERROR ) { res = MAIL_ERROR_MEMORY ; free_fetch_type } fetch_att = mailimap_fetch_att_new_flags ( ) ; if ( fetch_att == NULL ) { res = MAIL_ERROR_MEMORY ; free_fetch_type } r = mailimap_fetch_type_new_fetch_att_list_add ( fetch_type , fetch_att ) ; if ( r != MAILIMAP_NO_ERROR ) { mailimap_fetch_att_free ( fetch_att ) ; res = MAIL_ERROR_MEMORY ; free_fetch_type } r = imap_add_envelope_fetch_att ( fetch_type ) ; if ( r != MAIL_NO_ERROR ) { res = r ; free_fetch_type } r = maildriver_env_list_to_msg_list ( env_list , & msg_list ) ; if ( r != MAIL_NO_ERROR ) { res = MAIL_ERROR_MEMORY ; free_fetch_type } if ( clist_begin ( msg_list ) == NULL ) { mailimap_fetch_type_free ( fetch_type ) ; clist_free ( msg_list ) ; return MAIL_NO_ERROR ; } r = imap_msg_list_to_imap_set ( msg_list , & set ) ; if ( r != MAIL_NO_ERROR ) { clist_foreach ( msg_list , ( clist_func ) free , NULL ) ; clist_free ( msg_list ) ; res = MAIL_ERROR_MEMORY ; free_fetch_type } clist_foreach ( msg_list , ( clist_func ) free , NULL ) ; clist_free ( msg_list ) ; set_iter = clist_begin ( set -> set_list ) ; while ( set_iter != NULL ) { struct mailimap_set * subset ; unsigned int count ; subset = mailimap_set_new_empty ( ) ; if ( subset == NULL ) { res = MAIL_ERROR_MEMORY ; mailimap_fetch_type_free ( fetch_type ) ; mailimap_set_free ( set ) ; err } count = 0 ; while ( count < IMAP_SET_MAX_COUNT ) { struct mailimap_set_item * item ; item = clist_content ( set_iter ) ; set_iter = clist_delete ( set -> set_list , set_iter ) ; r = mailimap_set_add ( subset , item ) ; if ( r != MAILIMAP_NO_ERROR ) { mailimap_set_item_free ( item ) ; mailimap_set_free ( subset ) ; mailimap_fetch_type_free ( fetch_type ) ; mailimap_set_free ( set ) ; res = MAIL_ERROR_MEMORY ; err } count ++ ; if ( set_iter == NULL ) { break ; } } r = mailimap_uid_fetch ( get_imap_session ( session ) , subset , fetch_type , & fetch_result ) ; mailimap_set_free ( subset ) ; switch ( r ) { case MAILIMAP_NO_ERROR : break ; default : mailimap_fetch_type_free ( fetch_type ) ; mailimap_set_free ( set ) ; return imap_error_to_mail_error ( r ) ; } if ( clist_begin ( fetch_result ) == NULL ) { res = MAIL_ERROR_FETCH ; err } r = imap_fetch_result_to_envelop_list ( fetch_result , env_list ) ; mailimap_fetch_list_free ( fetch_result ) ; if ( r != MAIL_NO_ERROR ) { mailimap_fetch_type_free ( fetch_type ) ; mailimap_set_free ( set ) ; res = MAIL_ERROR_MEMORY ; err } } r = mailimap_uid_fetch ( get_imap_session ( session ) , set , fetch_type , & fetch_result ) ; mailimap_fetch_type_free ( fetch_type ) ; mailimap_set_free ( set ) ; switch ( r ) { case MAILIMAP_NO_ERROR : break ; default : return imap_error_to_mail_error ( r ) ; } r = imap_fetch_result_to_envelop_list ( fetch_result , env_list ) ; mailimap_fetch_list_free ( fetch_result ) ; if ( r != MAIL_NO_ERROR ) { res = MAIL_ERROR_MEMORY ; err } return MAIL_NO_ERROR ; free_fetch_type mailimap_fetch_type_free ( fetch_type ) ; err return res ; } 