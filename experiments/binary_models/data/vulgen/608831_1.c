static int ov4689_probe ( struct i2c_client * client ) { struct device * dev = & client -> dev ; struct v4l2_subdev * sd ; struct ov4689 * ov4689 ; int ret ; ret = ov4689_check_hwcfg ( dev ) ; if ( ret ) { return ret ; } ov4689 = devm_kzalloc ( dev , sizeof ( * ov4689 ) , GFP_KERNEL ) ; if ( ! ov4689 ) { return - ENOMEM ; } ov4689 -> client = client ; ov4689 -> xvclk = devm_clk_get_optional ( dev , NULL ) ; if ( IS_ERR ( ov4689 -> xvclk ) ) { return dev_err_probe ( dev , PTR_ERR ( ov4689 -> xvclk ) , "Failed to get external clock\n" ) ; } if ( ! ov4689 -> xvclk ) { dev_dbg ( dev , "No clock provided, using clock-frequency property\n" ) ; device_property_read_u32 ( dev , "clock-frequency" , & ov4689 -> clock_rate ) ; } else { ov4689 -> clock_rate = clk_get_rate ( ov4689 -> xvclk ) ; } if ( ov4689 -> clock_rate != OV4689_XVCLK_FREQ ) { dev_err ( dev , "External clock rate mismatch: got %d Hz, expected %d Hz\n" , ov4689 -> clock_rate , OV4689_XVCLK_FREQ ) ; return - EINVAL ; } ov4689 -> reset_gpio = devm_gpiod_get_optional ( dev , "reset" , GPIOD_OUT_LOW ) ; if ( IS_ERR ( ov4689 -> reset_gpio ) ) { dev_err ( dev , "Failed to get reset-gpios\n" ) ; return PTR_ERR ( ov4689 -> reset_gpio ) ; } ov4689 -> pwdn_gpio = devm_gpiod_get_optional ( dev , "pwdn" , GPIOD_OUT_LOW ) ; if ( IS_ERR ( ov4689 -> pwdn_gpio ) ) { dev_err ( dev , "Failed to get pwdn-gpios\n" ) ; return PTR_ERR ( ov4689 -> pwdn_gpio ) ; } ret = ov4689_configure_regulators ( ov4689 ) ; if ( ret ) { return dev_err_probe ( dev , ret , "Failed to get power regulators\n" ) ; } mutex_init ( & ov4689 -> mutex ) ; sd = & ov4689 -> subdev ; v4l2_i2c_subdev_init ( sd , client , & ov4689_subdev_ops ) ; ret = ov4689_initialize_controls ( ov4689 ) ; if ( ret ) { err_destroy_mutex } ret = ov4689_power_on ( dev ) ; if ( ret ) { err_free_handler } ret = ov4689_check_sensor_id ( ov4689 , client ) ; if ( ret ) { err_power_off } sd -> internal_ops = & ov4689_internal_ops ; sd -> flags |= V4L2_SUBDEV_FL_HAS_DEVNODE ; ov4689 -> pad . flags = MEDIA_PAD_FL_SOURCE ; sd -> entity . function = MEDIA_ENT_F_CAM_SENSOR ; ret = media_entity_pads_init ( & sd -> entity , 1 , & ov4689 -> pad ) ; if ( ret < 0 ) { err_power_off } ret = v4l2_async_register_subdev_sensor ( sd ) ; if ( ret ) { dev_err ( dev , "v4l2 async register subdev failed\n" ) ; err_clean_entity } pm_runtime_set_active ( dev ) ; pm_runtime_enable ( dev ) ; pm_runtime_idle ( dev ) ; return 0 ; err_clean_entity media_entity_cleanup ( & sd -> entity ) ; err_power_off ov4689_power_off ( dev ) ; err_free_handler v4l2_ctrl_handler_free ( & ov4689 -> ctrl_handler ) ; err_destroy_mutex mutex_destroy ( & ov4689 -> mutex ) ; return ret ; } 