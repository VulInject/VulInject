_server_monitor_poll_with_interrupt ( , , , ) { const int32_t monitor_tick_ms = MONGOC_TOPOLOGY_MIN_HEARTBEAT_FREQUENCY_MS ; int64_t timeleft_ms ; while ( ( timeleft_ms = expire_at_ms - _now_ms ( ) ) > 0 ) { ssize_t ret ; mongoc_stream_poll_t poller [ 1 ] ; MONITOR_LOG ( server_monitor , "_server_monitor_poll_with_interrupt expires in: %" PRIu64 "ms" , timeleft_ms ) ; poller [ 0 ] . stream = server_monitor -> stream ; poller [ 0 ] . events = POLLIN ; poller [ 0 ] . revents = 0 ; MONITOR_LOG ( server_monitor , "polling for awaitable hello reply with timeleft_ms: %" PRId64 , timeleft_ms ) ; ret = mongoc_stream_poll ( poller , 1 , ( int32_t ) BSON_MIN ( timeleft_ms , monitor_tick_ms ) ) ; if ( ret == - 1 ) { MONITOR_LOG ( server_monitor , "mongoc_stream_poll error" ) ; bson_set_error ( error , MONGOC_ERROR_STREAM , MONGOC_ERROR_STREAM_SOCKET , "poll error" ) ; return false ; } if ( poller [ 0 ] . revents & ( POLLERR | POLLHUP ) ) { bson_set_error ( error , MONGOC_ERROR_STREAM , MONGOC_ERROR_STREAM_SOCKET , "connection closed while polling" ) ; return false ; } bson_mutex_lock ( & server_monitor -> shared . mutex ) ; * cancelled = server_monitor -> shared . cancel_requested ; server_monitor -> shared . cancel_requested = false ; bson_mutex_unlock ( & server_monitor -> shared . mutex ) ; if ( poller [ 0 ] . revents & POLLIN ) { MONITOR_LOG ( server_monitor , "mongoc_stream_poll ready to read" ) ; return true ; } } bson_set_error ( error , MONGOC_ERROR_STREAM , MONGOC_ERROR_STREAM_SOCKET , "connection timeout while polling" ) ; return false ; } 