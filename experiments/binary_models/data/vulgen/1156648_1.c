static av_cold int librav1e_encode_init ( AVCodecContext * avctx ) { librav1eContext * ctx = avctx -> priv_data ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; RaConfig * cfg = NULL ; int rret ; int ret = 0 ; if ( ! ctx -> frame ) { return AVERROR ( ENOMEM ) ; } cfg = rav1e_config_default ( ) ; if ( ! cfg ) { av_log ( avctx , AV_LOG_ERROR , "Could not allocate rav1e config.\n" ) ; return AVERROR_EXTERNAL ; } if ( avctx -> framerate . num > 0 && avctx -> framerate . den > 0 ) { rav1e_config_set_time_base ( cfg , ( RaRational ) { avctx -> framerate . den avctx -> framerate . num } ) ; } else { rav1e_config_set_time_base ( cfg , ( RaRational ) { avctx -> time_base . num * avctx -> ticks_per_frame avctx -> time_base . den } ) ; } if ( ( avctx -> flags & AV_CODEC_FLAG_PASS1 || avctx -> flags & AV_CODEC_FLAG_PASS2 ) && ! avctx -> bit_rate ) { av_log ( avctx , AV_LOG_ERROR , "A bitrate must be set to use two pass mode.\n" ) ; ret = AVERROR_INVALIDDATA ; end } if ( avctx -> flags & AV_CODEC_FLAG_PASS2 ) { if ( ! avctx -> stats_in ) { av_log ( avctx , AV_LOG_ERROR , "No stats file provided for second pass.\n" ) ; ret = AVERROR ( EINVAL ) ; end } ctx -> pass_size = ( strlen ( avctx -> stats_in ) * 3 ) / 4 ; ctx -> pass_data = av_malloc ( ctx -> pass_size ) ; if ( ! ctx -> pass_data ) { av_log ( avctx , AV_LOG_ERROR , "Could not allocate stats buffer.\n" ) ; ret = AVERROR ( ENOMEM ) ; end } ctx -> pass_size = av_base64_decode ( ctx -> pass_data , avctx -> stats_in , ctx -> pass_size ) ; if ( ctx -> pass_size < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Invalid pass file.\n" ) ; ret = AVERROR ( EINVAL ) ; end } } { const AVDictionaryEntry * en = NULL ; while ( ( en = av_dict_iterate ( ctx -> rav1e_opts , en ) ) ) { if ( rav1e_config_parse ( cfg , en -> key , en -> value ) < 0 ) { av_log ( avctx , AV_LOG_WARNING , "Invalid value for %s: %s.\n" , en -> key , en -> value ) ; } } } rret = rav1e_config_parse_int ( cfg , "width" , avctx -> width ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Invalid width passed to rav1e.\n" ) ; ret = AVERROR_INVALIDDATA ; end } rret = rav1e_config_parse_int ( cfg , "height" , avctx -> height ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Invalid height passed to rav1e.\n" ) ; ret = AVERROR_INVALIDDATA ; end } if ( avctx -> sample_aspect_ratio . num > 0 && avctx -> sample_aspect_ratio . den > 0 ) { rav1e_config_set_sample_aspect_ratio ( cfg , ( RaRational ) { avctx -> sample_aspect_ratio . num avctx -> sample_aspect_ratio . den } ) ; } rret = rav1e_config_parse_int ( cfg , "threads" , avctx -> thread_count ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_WARNING , "Invalid number of threads, defaulting to auto.\n" ) ; } if ( ctx -> speed >= 0 ) { rret = rav1e_config_parse_int ( cfg , "speed" , ctx -> speed ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Could not set speed preset.\n" ) ; ret = AVERROR_EXTERNAL ; end } } if ( ctx -> tiles > 0 ) { rret = rav1e_config_parse_int ( cfg , "tiles" , ctx -> tiles ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Could not set number of tiles to encode with.\n" ) ; ret = AVERROR_EXTERNAL ; end } } if ( ctx -> tile_rows > 0 ) { rret = rav1e_config_parse_int ( cfg , "tile_rows" , ctx -> tile_rows ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Could not set number of tile rows to encode with.\n" ) ; ret = AVERROR_EXTERNAL ; end } } if ( ctx -> tile_cols > 0 ) { rret = rav1e_config_parse_int ( cfg , "tile_cols" , ctx -> tile_cols ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Could not set number of tile cols to encode with.\n" ) ; ret = AVERROR_EXTERNAL ; end } } if ( avctx -> gop_size > 0 ) { rret = rav1e_config_parse_int ( cfg , "key_frame_interval" , avctx -> gop_size ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Could not set max keyint.\n" ) ; ret = AVERROR_EXTERNAL ; end } } if ( avctx -> keyint_min > 0 ) { rret = rav1e_config_parse_int ( cfg , "min_key_frame_interval" , avctx -> keyint_min ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Could not set min keyint.\n" ) ; ret = AVERROR_EXTERNAL ; end } } if ( avctx -> bit_rate && ctx -> quantizer < 0 ) { int max_quantizer = avctx -> qmax >= 0 ?avctx -> qmax : 255 ; rret = rav1e_config_parse_int ( cfg , "quantizer" , max_quantizer ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Could not set max quantizer.\n" ) ; ret = AVERROR_EXTERNAL ; end } if ( avctx -> qmin >= 0 ) { rret = rav1e_config_parse_int ( cfg , "min_quantizer" , avctx -> qmin ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Could not set min quantizer.\n" ) ; ret = AVERROR_EXTERNAL ; end } } rret = rav1e_config_parse_int ( cfg , "bitrate" , avctx -> bit_rate ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Could not set bitrate.\n" ) ; ret = AVERROR_INVALIDDATA ; end } } if ( ctx -> quantizer >= 0 ) { if ( avctx -> bit_rate ) { av_log ( avctx , AV_LOG_WARNING , "Both bitrate and quantizer specified. Using quantizer mode." ) ; } rret = rav1e_config_parse_int ( cfg , "quantizer" , ctx -> quantizer ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Could not set quantizer.\n" ) ; ret = AVERROR_EXTERNAL ; end } } rret = rav1e_config_set_pixel_format ( cfg , desc -> comp [ 0 ] . depth , pix_fmt_map ( avctx -> pix_fmt ) , chroma_loc_map ( avctx -> chroma_sample_location ) , range_map ( avctx -> pix_fmt , avctx -> color_range ) ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Failed to set pixel format properties.\n" ) ; ret = AVERROR_INVALIDDATA ; end } rret = rav1e_config_set_color_description ( cfg , ( RaMatrixCoefficients ) avctx -> colorspace , ( RaColorPrimaries ) avctx -> color_primaries , ( RaTransferCharacteristics ) avctx -> color_trc ) ; if ( rret < 0 ) { av_log ( avctx , AV_LOG_WARNING , "Failed to set color properties.\n" ) ; if ( avctx -> err_recognition & AV_EF_EXPLODE ) { ret = AVERROR_INVALIDDATA ; end } } ctx -> ctx = rav1e_context_new ( cfg ) ; if ( ! ctx -> ctx ) { av_log ( avctx , AV_LOG_ERROR , "Failed to create rav1e encode context.\n" ) ; ret = AVERROR_EXTERNAL ; end } if ( avctx -> flags & AV_CODEC_FLAG_GLOBAL_HEADER ) { RaData * seq_hdr = rav1e_container_sequence_header ( ctx -> ctx ) ; if ( seq_hdr ) { avctx -> extradata = av_mallocz ( seq_hdr -> len + AV_INPUT_BUFFER_PADDING_SIZE ) ; } if ( ! seq_hdr || ! avctx -> extradata ) { rav1e_data_unref ( seq_hdr ) ; av_log ( avctx , AV_LOG_ERROR , "Failed to get extradata.\n" ) ; ret = seq_hdr ?AVERROR ( ENOMEM ) : AVERROR_EXTERNAL ; end } memcpy ( avctx -> extradata , seq_hdr -> data , seq_hdr -> len ) ; avctx -> extradata_size = seq_hdr -> len ; rav1e_data_unref ( seq_hdr ) ; } ret = 0 ; end rav1e_config_unref ( cfg ) ; return ret ; } 