static bool bgp_pbr_extract_enumerate_unary ( struct bgp_pbr_match_val list [ ] , int num , uint8_t unary_operator , void * valmask , uint8_t type_entry ) { int i = 0 ; struct bgp_pbr_val_mask * and_valmask = NULL ; struct list * or_valmask = NULL ; bool ret ; if ( valmask ) { if ( unary_operator == OPERATOR_UNARY_AND ) { and_valmask = ( bgp_pbr_val_mask * ) valmask ; memset ( and_valmask , 0 , sizeof ( bgp_pbr_val_mask ) ) ; } if ( unary_operator == OPERATOR_UNARY_OR ) { or_valmask = ( list * ) valmask ; } } for ( i = 0 ; i < num ; i ++ ) { if ( i != 0 && list [ i ] . unary_operator != unary_operator ) { return false ; } if ( ! ( list [ i ] . compare_operator & OPERATOR_COMPARE_EQUAL_TO ) && ! ( list [ i ] . compare_operator & OPERATOR_COMPARE_EXACT_MATCH ) ) { if ( ( list [ i ] . compare_operator & OPERATOR_COMPARE_LESS_THAN ) && ( list [ i ] . compare_operator & OPERATOR_COMPARE_GREATER_THAN ) ) { ret = bgp_pbr_extract_enumerate_unary_opposite ( unary_operator , and_valmask , or_valmask , list [ i ] . value , type_entry ) ; if ( ! ret ) { return ret ; } continue ; } return false ; } if ( unary_operator == OPERATOR_UNARY_AND && and_valmask ) { } if ( unary_operator == OPERATOR_UNARY_OR && or_valmask ) { and_valmask = XCALLOC ( MTYPE_PBR_VALMASK , sizeof ( bgp_pbr_val_mask ) ) ; if ( type_entry == FLOWSPEC_TCP_FLAGS ) { and_valmask -> val = TCP_HEADER_ALL_FLAGS ; and_valmask -> mask |= TCP_HEADER_ALL_FLAGS & list [ i ] . value ; } if ( type_entry == FLOWSPEC_DSCP || type_entry == FLOWSPEC_FLOW_LABEL || type_entry == FLOWSPEC_ICMP_TYPE || type_entry == FLOWSPEC_ICMP_CODE || type_entry == FLOWSPEC_FRAGMENT || type_entry == FLOWSPEC_PKT_LEN ) { and_valmask -> val = list [ i ] . value ; } listnode_add ( or_valmask , and_valmask ) ; } } if ( unary_operator == OPERATOR_UNARY_AND && and_valmask && type_entry == FLOWSPEC_TCP_FLAGS ) { and_valmask -> val = TCP_HEADER_ALL_FLAGS ; } return true ; } 