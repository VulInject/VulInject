int main ( int argc , char * * argv ) { krb5_log_facility * logf ; krb5_error_code ret ; krb5_context context ; hx509_request csr ; const char * argv0 = argv [ 0 ] ; int optidx = 0 ; setprogname ( argv [ 0 ] ) ; if ( getarg ( args , num_args , argc , argv , & optidx ) ) { return usage ( 1 ) ; } if ( help_flag ) { return usage ( 0 ) ; } if ( version_flag ) { print_version ( argv [ 0 ] ) ; return 0 ; } if ( ( errno = krb5_init_context ( & context ) ) ) { err ( 1 , "Could not initialize krb5_context" ) ; } if ( ( ret = krb5_initlog ( context , argv0 , & logf ) ) || ( ret = krb5_addlog_dest ( context , logf , "0-5/STDERR" ) ) ) { krb5_err ( context , 1 , ret , "Could not set up logging to stderr" ) ; } load_plugins ( context ) ; if ( server_flag && daemon_flag ) { daemon_child_flag = roken_detach_prep ( argc , argv , "--daemon-child" ) ; } argc -= optidx ; argv += optidx ; if ( socket_dir ) { setenv ( "HEIM_IPC_DIR" , socket_dir , 1 ) ; } if ( server_flag ) { const char * svc ; heim_sipc un ; rk_pidfile ( NULL ) ; svc = krb5_config_get_string ( context , NULL , app_string ?app_string : "kdc" , "ipc_csr_authorizer" , "service" , NULL ) ; if ( svc == NULL ) { svc = "org.h5l.csr_authorizer" ; } ret = heim_sipc_service_unix ( svc , service , NULL , & un ) ; if ( ret ) { krb5_err ( context , 1 , ret , "Could not setup service on Unix domain socket " "%s/.heim_%s-socket" , socket_dir , svc ) ; } roken_detach_finish ( NULL , daemon_child_flag ) ; heim_ipc_main ( ) ; return 0 ; } if ( argc < 2 ) { usage ( 1 ) ; } if ( ( ret = hx509_request_parse ( context -> hx509ctx , argv [ 0 ] , & csr ) ) ) { krb5_err ( context , 1 , ret , "Could not parse PKCS#10 CSR from %s" , argv [ 0 ] ) ; } if ( ( ret = krb5_parse_name ( context , argv [ 1 ] , & princ ) ) ) { krb5_err ( context , 1 , ret , "Could not parse principal %s" , argv [ 1 ] ) ; } ret = kdc_authorize_csr ( context , app_string , csr , princ ) ; if ( ret ) { unsigned n = hx509_request_count_unauthorized ( csr ) ; size_t i , k ; int ret2 = 0 ; int good = - 1 ; for ( i = 0 ; ret2 == 0 ; i ++ ) { hx509_san_type san_type ; char * feature = NULL ; char * san = NULL ; int granted ; ret2 = hx509_request_get_san ( csr , i , & san_type , & san ) ; if ( ret2 ) { break ; } feature = make_feature_argument ( "san" , san_type , san ) ; granted = hx509_request_san_authorized_p ( csr , i ) ; for ( k = 2 ; k < argc ; k ++ ) { if ( strcmp ( feature , argv [ k ] ) != 0 ) { continue ; } if ( granted && good == - 1 ) { good = 1 ; } if ( ! granted ) { good = 0 ; } break ; } hx509_xfree ( san ) ; } for ( i = 0 ; ret2 == 0 ; i ++ ) { char * feature = NULL ; char * eku = NULL ; int granted ; ret2 = hx509_request_get_eku ( csr , i , & eku ) ; if ( ret2 ) { break ; } feature = make_feature_argument ( "eku" , 0 , eku ) ; granted = hx509_request_eku_authorized_p ( csr , i ) ; for ( k = 2 ; k < argc ; k ++ ) { if ( strcmp ( feature , argv [ k ] ) != 0 ) { continue ; } if ( granted && good == - 1 ) { good = 1 ; } if ( ! granted ) { good = 0 ; } break ; } hx509_xfree ( eku ) ; } if ( good != 1 ) { krb5_free_principal ( context , princ ) ; _krb5_unload_plugins ( context , "kdc" ) ; hx509_request_free ( & csr ) ; krb5_err ( context , 1 , ret , "Authorization failed with %u rejected features" , n ) ; } } printf ( "Authorized!\n" ) ; krb5_free_principal ( context , princ ) ; _krb5_unload_plugins ( context , "kdc" ) ; krb5_free_context ( context ) ; hx509_request_free ( & csr ) ; return 0 ; } 