break ; case AV_PIX_FMT_YUV422P10 : xinc = 2 ; yinc = 1 << interlaced ; pgroup = 5 ; break ; case AV_PIX_FMT_YUV420P : xinc = 4 ; yinc = 1 << interlaced ; pgroup = 6 ; break ; case AV_PIX_FMT_RGB24 : xinc = 1 ; yinc = 1 << interlaced ; pgroup = 3 ; break ; case AV_PIX_FMT_BGR24 : xinc = 1 ; yinc = 1 << interlaced ; pgroup = 3 ; break ; default : return ; ( i < height ) { int left = s -> max_payload_size uint8_t * dest = s -> buf uint8_t * headers const int head_size = 6 int next_line int length cont pixels * dest ++ = 0 * dest ++ = 0 left -= 2 headers = dest { int l_line ; pixels = width - offset ; length = ( pixels * pgroup ) / xinc ; left -= head_size ; } } ; else { pixels = ( left / pgroup ) * xinc ; length = ( pixels * pgroup ) / xinc ; next_line = 0 ; } left -= length ; * dest ++ = ( length >> 8 ) & 0xff ; * dest ++ = length & 0xff ; l_line = i >> interlaced ; * dest ++ = ( ( l_line >> 8 ) & 0x7f ) | ( ( field << 7 ) & 0x80 ) ; * dest ++ = l_line & 0xff ; if ( next_line ) { i += yinc ; } cont = ( left > ( head_size + pgroup ) && i < height ) ?0x80 : 0x00 ; * dest ++ = ( ( offset >> 8 ) & 0x7f ) | cont ; * dest ++ = offset & 0xff ; if ( next_line ) { offset = 0 ; } else { offset += pixels ; } ( cont ) ; { int l_field ; int l_line ; int l_off ; int copy_offset ; length = ( headers [ 0 ] << 8 ) | headers [ 1 ] ; l_field = ( headers [ 2 ] & 0x80 ) >> 7 ; l_line = ( ( headers [ 2 ] & 0x7f ) << 8 ) | headers [ 3 ] ; l_off = ( ( headers [ 4 ] & 0x7f ) << 8 ) | headers [ 5 ] ; cont = headers [ 4 ] & 0x80 ; headers += head_size ; if ( interlaced ) { l_line = 2 * l_line + l_field ; } copy_offset = ( l_line * width + l_off ) * pgroup / xinc ; if ( copy_offset + length > size ) { break ; } memcpy ( dest , buf + copy_offset , length ) ; dest += length ; } cont ; ff_rtp_send_data ( s1 , s -> buf , s -> max_payload_size - left , i >= height ) ; 