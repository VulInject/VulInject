int fdt_fixup_board_phy ( void * fdt ) { int fpga_offset , offset , subnodeoffset ; struct mii_dev * mii_dev ; struct list_head * mii_devs , * entry ; int ret , dpmac_id , i ; struct phy_device * phy_dev ; char ethname [ ETH_NAME_LEN ] ; phy_interface_t phy_iface ; uint32_t phandle ; ret = 0 ; fpga_offset = fdt_path_offset ( fdt , "/soc/i2c@2000000/fpga" ) ; if ( fpga_offset < 0 ) { fpga_offset = fdt_path_offset ( fdt , "/i2c@2000000/fpga" ) ; } if ( fpga_offset < 0 ) { printf ( "i2c@2000000/fpga node not found in device tree\n" ) ; return fpga_offset ; } if ( ret < 0 ) { return ret ; } mii_devs = mdio_get_list_head ( ) ; list_for_each ( , ) { mii_dev = list_entry ( entry , mii_dev , link ) ; debug ( "mii_dev name : %s\n" , mii_dev -> name ) ; offset = fdt_get_ioslot_offset ( fdt , mii_dev , fpga_offset ) ; if ( offset < 0 ) { continue ; } for ( i = 0 ; i < PHY_MAX_ADDR ; i ++ ) { phy_dev = mii_dev -> phymap [ i ] ; if ( ! phy_dev ) { continue ; } dpmac_id = WRIOP1_DPMAC1 ; while ( dpmac_id < NUM_WRIOP_PORTS ) { phy_iface = wriop_get_enet_if ( dpmac_id ) ; snprintf ( ethname , ETH_NAME_LEN , "DPMAC%d@%s" , dpmac_id , phy_string_for_interface ( phy_iface ) ) ; if ( strcmp ( ethname , phy_dev -> dev -> name ) == 0 ) { break ; } dpmac_id ++ ; } if ( dpmac_id == NUM_WRIOP_PORTS ) { continue ; } ret = fdt_create_phy_node ( fdt , offset , i , & subnodeoffset , phy_dev , phandle ) ; if ( ret ) { break ; } ret = fdt_fixup_dpmac_phy_handle ( fdt , dpmac_id , phandle ) ; if ( ret ) { fdt_del_node ( fdt , subnodeoffset ) ; break ; } offset = fdt_get_ioslot_offset ( fdt , mii_dev , fpga_offset ) ; phandle ++ ; } if ( ret ) { break ; } } return ret ; } static serdes_configuration { u8 serdes_block ; u32 serdes_protocol ; bool dts_needed ; } , supported_protocols [ ] { } ; 