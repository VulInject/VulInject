static void zfcp_fsf_open_lun_handler ( struct zfcp_fsf_req * req ) { struct zfcp_adapter * adapter = req -> adapter ; struct scsi_device * sdev = req -> data ; struct zfcp_scsi_dev * zfcp_sdev ; struct fsf_qtcb_header * header = & req -> qtcb -> header ; union fsf_status_qual * qual = & header -> fsf_status_qual ; if ( req -> status & ZFCP_STATUS_FSFREQ_ERROR ) { return ; } zfcp_sdev = sdev_to_zfcp ( sdev ) ; switch ( header -> fsf_status ) { case FSF_PORT_HANDLE_NOT_VALID : zfcp_erp_adapter_reopen ( adapter , 0 , "fsouh_1" ) ; case FSF_LUN_ALREADY_OPEN : break ; case FSF_PORT_BOXED : zfcp_erp_set_port_status ( zfcp_sdev -> port , ZFCP_STATUS_COMMON_ACCESS_BOXED ) ; zfcp_erp_port_reopen ( zfcp_sdev -> port , ZFCP_STATUS_COMMON_ERP_FAILED , "fsouh_2" ) ; req -> status |= ZFCP_STATUS_FSFREQ_ERROR ; break ; case FSF_LUN_SHARING_VIOLATION : if ( qual -> word [ 0 ] ) { dev_warn ( & zfcp_sdev -> port -> adapter -> ccw_device -> dev , "LUN 0x%Lx on port 0x%Lx is already in " "use by CSS%d, MIF Image ID %x\n" , zfcp_scsi_dev_lun ( sdev ) , ( unsigned long long ) zfcp_sdev -> port -> wwpn , qual -> fsf_queue_designator . cssid , qual -> fsf_queue_designator . hla ) ; } zfcp_erp_set_lun_status ( sdev , ZFCP_STATUS_COMMON_ERP_FAILED | ZFCP_STATUS_COMMON_ACCESS_DENIED ) ; req -> status |= ZFCP_STATUS_FSFREQ_ERROR ; break ; case FSF_MAXIMUM_NUMBER_OF_LUNS_EXCEEDED : dev_warn ( & adapter -> ccw_device -> dev , "No handle is available for LUN " "0x%016Lx on port 0x%016Lx\n" , ( unsigned long long ) zfcp_scsi_dev_lun ( sdev ) , ( unsigned long long ) zfcp_sdev -> port -> wwpn ) ; zfcp_erp_set_lun_status ( sdev , ZFCP_STATUS_COMMON_ERP_FAILED ) ; case FSF_INVALID_COMMAND_OPTION : req -> status |= ZFCP_STATUS_FSFREQ_ERROR ; break ; case FSF_ADAPTER_STATUS_AVAILABLE : switch ( header -> fsf_status_qual . word [ 0 ] ) { case FSF_SQ_INVOKE_LINK_TEST_PROCEDURE : zfcp_fc_test_link ( zfcp_sdev -> port ) ; case FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED : req -> status |= ZFCP_STATUS_FSFREQ_ERROR ; break ; } break ; case FSF_GOOD : zfcp_sdev -> lun_handle = header -> lun_handle ; atomic_or ( ZFCP_STATUS_COMMON_OPEN , & zfcp_sdev -> status ) ; break ; } } 