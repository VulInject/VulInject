static void eadm_subchannel_irq ( struct subchannel * sch ) { struct eadm_private * get_eadm_private ( sch ) ; ; struct eadm_scsw * scsw = & sch -> schib . scsw . eadm ; struct irb * irb = this_cpu_ptr ( & cio_irb ) ; int error = 0 ; EADM_LOG ( 6 , "irq" ) ; EADM_LOG_HEX ( 6 , irb , sizeof ( * irb ) ) ; if ( ( scsw -> stctl & ( SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND ) ) && scsw -> eswf == 1 && irb -> esw . eadm . erw . r ) { error = - EIO ; } if ( scsw -> fctl & SCSW_FCTL_CLEAR_FUNC ) { error = - ETIMEDOUT ; } eadm_subchannel_set_timeout ( sch , 0 ) ; if ( private -> state != EADM_BUSY ) { EADM_LOG ( 1 , "irq unsol" ) ; EADM_LOG_HEX ( 1 , irb , sizeof ( * irb ) ) ; private -> state = EADM_NOT_OPER ; css_sched_sch_todo ( sch , SCH_TODO_EVAL ) ; return ; } scm_irq_handler ( ( aob * ) ( unsigned long ) scsw -> aob , error ) ; private -> state = EADM_IDLE ; if ( private -> completion ) { complete ( private -> completion ) ; } } 