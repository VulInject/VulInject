static int xfs_attr_shortform_list ( xfs_attr_list_context_t * context ) { attrlist_cursor_kern_t * cursor ; xfs_attr_sf_sort_t * sbuf , * sbp ; xfs_attr_shortform_t * sf ; xfs_attr_sf_entry_t * sfe ; xfs_inode_t * dp ; int sbsize , nsbuf , count , i ; ASSERT ( context != NULL ) ; dp = context -> dp ; ASSERT ( dp != NULL ) ; ASSERT ( dp -> i_afp != NULL ) ; sf = ( xfs_attr_shortform_t * ) dp -> i_afp -> if_u1 . if_data ; ASSERT ( sf != NULL ) ; if ( ! sf -> hdr . count ) { return 0 ; } cursor = context -> cursor ; ASSERT ( cursor != NULL ) ; trace_xfs_attr_list_sf ( context ) ; if ( context -> bufsize == 0 || ( XFS_ISRESET_CURSOR ( cursor ) && ( dp -> i_afp -> if_bytes + sf -> hdr . count * 16 ) < context -> bufsize ) ) { for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { context -> put_listent ( context , sfe -> flags , sfe -> nameval , ( int ) sfe -> namelen , ( int ) sfe -> valuelen ) ; if ( context -> seen_enough ) { break ; } sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; } trace_xfs_attr_list_sf_all ( context ) ; return 0 ; } if ( context -> bufsize == 0 ) { return 0 ; } sbsize = sf -> hdr . count * sizeof ( * sbuf ) ; sbp = sbuf = kmem_alloc ( sbsize , KM_SLEEP | KM_NOFS ) ; nsbuf = 0 ; for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { if ( unlikely ( ( ( char * ) sfe < ( char * ) sf ) || ( ( char * ) sfe >= ( ( char * ) sf + dp -> i_afp -> if_bytes ) ) ) ) { XFS_CORRUPTION_ERROR ( "xfs_attr_shortform_list" , XFS_ERRLEVEL_LOW , context -> dp -> i_mount , sfe ) ; return - EFSCORRUPTED ; } sbp -> entno = i ; sbp -> hash = xfs_da_hashname ( sfe -> nameval , sfe -> namelen ) ; sbp -> name = sfe -> nameval ; sbp -> namelen = sfe -> namelen ; sbp -> valuelen = sfe -> valuelen ; sbp -> flags = sfe -> flags ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; sbp ++ ; nsbuf ++ ; } xfs_sort ( sbuf , nsbuf , sizeof ( * sbuf ) , xfs_attr_shortform_compare ) ; count = 0 ; cursor -> initted = 1 ; cursor -> blkno = 0 ; for ( sbp = sbuf , i = 0 ; i < nsbuf ; i ++ , sbp ++ ) { if ( sbp -> hash == cursor -> hashval ) { if ( cursor -> offset == count ) { break ; } count ++ ; } if ( sbp -> hash > cursor -> hashval ) { break ; } } if ( i == nsbuf ) { kmem_free ( sbuf ) ; return 0 ; } for ( ; i < nsbuf ; i ++ , sbp ++ ) { if ( cursor -> hashval != sbp -> hash ) { cursor -> hashval = sbp -> hash ; cursor -> offset = 0 ; } context -> put_listent ( context , sbp -> flags , sbp -> name , sbp -> namelen , sbp -> valuelen ) ; if ( context -> seen_enough ) { break ; } cursor -> offset ++ ; } kmem_free ( sbuf ) ; return 0 ; } 