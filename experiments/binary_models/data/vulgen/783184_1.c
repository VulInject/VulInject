const char * Ppltdest ( struct ps_prochandle * P , uintptr_t pltaddr ) { map_info_t * mp = Paddr2mptr ( P , pltaddr ) ; file_info_t * fp ; int i ; uintptr_t r_addr ; if ( mp == NULL || ( fp = mp -> map_file ) == NULL || fp -> file_plt_base == 0 || pltaddr - fp -> file_plt_base >= fp -> file_plt_size ) { errno = EINVAL ; return ( NULL ) ; } i = ( pltaddr - fp -> file_plt_base ) / M_PLT_ENTSIZE - M_PLT_XNumber ; if ( P -> status . pr_dmodel == PR_MODEL_LP64 ) { Elf64_Rela r ; r_addr = fp -> file_jmp_rel + i * sizeof ( r ) ; if ( Pread ( P , & r , sizeof ( r ) , r_addr ) == sizeof ( r ) && ( i = ELF64_R_SYM ( r . r_info ) ) < fp -> file_dynsym . sym_symn ) { Elf_Data * data = fp -> file_dynsym . sym_data_pri ; Elf64_Sym * symp = & ( ( ( Elf64_Sym * ) data -> d_buf ) [ i ] ) ; return ( fp -> file_dynsym . sym_strs + symp -> st_name ) ; } } else { Elf32_Rel r ; r_addr = fp -> file_jmp_rel + i * sizeof ( r ) ; if ( Pread ( P , & r , sizeof ( r ) , r_addr ) == sizeof ( r ) && ( i = ELF32_R_SYM ( r . r_info ) ) < fp -> file_dynsym . sym_symn ) { Elf_Data * data = fp -> file_dynsym . sym_data_pri ; Elf32_Sym * symp = & ( ( ( Elf32_Sym * ) data -> d_buf ) [ i ] ) ; return ( fp -> file_dynsym . sym_strs + symp -> st_name ) ; } } return ( NULL ) ; } 