static Char * dfollow ( Char * cp ) { Char * dp ; struct varent * c ; char ebuf [ PATH_MAX ] ; int serrno ; cp = globone ( cp , G_ERROR ) ; dp = dnormalize ( cp ) ; if ( chdir ( short2str ( dp ) ) >= 0 ) { free ( cp ) ; return dgoto ( dp ) ; } else { if ( chdir ( short2str ( cp ) ) >= 0 ) { return dgoto ( cp ) ; } serrno = errno ; } if ( cp [ 0 ] != '/' && ! prefix ( STRdotsl , cp ) && ! prefix ( STRdotdotsl , cp ) && ( c = adrof ( STRcdpath ) ) ) { Char * * cdp ; Char * p ; Char buf [ PATH_MAX ] ; for ( cdp = c -> vec ; * cdp ; cdp ++ ) { for ( dp = buf , p = * cdp ; ( * dp ++ = * p ++ ) != '\0' ; ) { continue ; } dp [ - 1 ] = '/' ; for ( p = cp ; ( * dp ++ = * p ++ ) != '\0' ; ) { continue ; } if ( chdir ( short2str ( buf ) ) >= 0 ) { printd = 1 ; free ( cp ) ; cp = Strsave ( buf ) ; return dgoto ( cp ) ; } } } dp = value ( cp ) ; if ( ( dp [ 0 ] == '/' || dp [ 0 ] == '.' ) && chdir ( short2str ( dp ) ) >= 0 ) { free ( cp ) ; cp = Strsave ( dp ) ; printd = 1 ; return dgoto ( cp ) ; } ( void ) strlcpy ( ebuf , short2str ( cp ) , sizeof ebuf ) ; free ( cp ) ; stderror ( ERR_SYSTEM , ebuf , strerror ( serrno ) ) ; return ( NULL ) ; } 