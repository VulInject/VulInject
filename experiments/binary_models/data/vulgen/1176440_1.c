static int bcm6328_led ( struct device * dev , struct device_node * nc , u32 reg , void __iomem * mem , spinlock_t * lock , unsigned long * blink_leds , unsigned long * blink_delay ) { struct bcm6328_led * led ; const char * state ; int rc ; led = devm_kzalloc ( dev , sizeof ( * led ) , GFP_KERNEL ) ; if ( ! led ) { return - ENOMEM ; } led -> pin = reg ; led -> mem = mem ; led -> lock = lock ; led -> blink_leds = blink_leds ; led -> blink_delay = blink_delay ; if ( of_property_read_bool ( nc , "active-low" ) ) { led -> active_low = true ; } led -> cdev . name = of_get_property ( nc , "label" , NULL ) ?: nc -> name ; led -> cdev . default_trigger = of_get_property ( nc , "linux,default-trigger" , NULL ) ; if ( ! of_property_read_string ( nc , "default-state" , & state ) ) { if ( ! strcmp ( state , "on" ) ) { led -> cdev . brightness = LED_FULL ; } if ( ! strcmp ( state , "keep" ) ) { void __iomem * mode ; unsigned long val , shift ; shift = bcm6328_pin2shift ( led -> pin ) ; if ( shift / 16 ) { mode = mem + BCM6328_REG_MODE_HI ; } else { mode = mem + BCM6328_REG_MODE_LO ; } val = bcm6328_led_read ( mode ) >> BCM6328_LED_SHIFT ( shift % 16 ) ; val &= BCM6328_LED_MODE_MASK ; if ( ( led -> active_low && val == BCM6328_LED_MODE_OFF ) || ( ! led -> active_low && val == BCM6328_LED_MODE_ON ) ) { led -> cdev . brightness = LED_FULL ; } else { led -> cdev . brightness = LED_OFF ; } } else { led -> cdev . brightness = LED_OFF ; } } else { led -> cdev . brightness = LED_OFF ; } bcm6328_led_set ( & led -> cdev , led -> cdev . brightness ) ; led -> cdev . brightness_set = bcm6328_led_set ; led -> cdev . blink_set = bcm6328_blink_set ; rc = led_classdev_register ( dev , & led -> cdev ) ; dev_dbg ( dev , "registered LED %s\n" , led -> cdev . name ) ; return 0 ; } 