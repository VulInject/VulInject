struct vcap_rule * vcap_alloc_rule ( struct vcap_control * vctrl , struct net_device * ndev , int vcap_chain_id , enum vcap_user user , u16 priority , u32 id ) { struct vcap_rule_internal * ri ; struct vcap_admin * admin ; int err , maxsize ; err = vcap_api_check ( vctrl ) ; if ( err ) { return ERR_PTR ( err ) ; } if ( ! ndev ) { return ERR_PTR ( - ENODEV ) ; } admin = vcap_find_admin ( vctrl , vcap_chain_id ) ; if ( ! admin ) { return ERR_PTR ( - ENOENT ) ; } if ( vctrl -> vcaps [ admin -> vtype ] . rows == 0 ) { return ERR_PTR ( - EINVAL ) ; } mutex_lock ( & admin -> lock ) ; if ( vcap_rule_exists ( vctrl , id ) ) { err = - EINVAL ; out_unlock } maxsize = vctrl -> vcaps [ admin -> vtype ] . sw_count ; if ( vcap_rule_space ( admin , maxsize ) ) { out_unlock } ri = kzalloc ( sizeof ( * ri ) , GFP_KERNEL ) ; if ( ! ri ) { err = - ENOMEM ; out_unlock } ri -> data . vcap_chain_id = vcap_chain_id ; ri -> data . user = user ; ri -> data . priority = priority ; ri -> data . id = id ; ri -> data . keyset = VCAP_KFS_NO_VALUE ; ri -> data . actionset = VCAP_AFS_NO_VALUE ; INIT_LIST_HEAD ( & ri -> list ) ; INIT_LIST_HEAD ( & ri -> data . keyfields ) ; INIT_LIST_HEAD ( & ri -> data . actionfields ) ; ri -> ndev = ndev ; ri -> admin = admin ; ri -> vctrl = vctrl ; if ( vcap_set_rule_id ( ri ) == 0 ) { err = - EINVAL ; out_free } mutex_unlock ( & admin -> lock ) ; return ( vcap_rule * ) ri ; out_free kfree ( ri ) ; out_unlock mutex_unlock ( & admin -> lock ) ; return ERR_PTR ( err ) ; } 