static void _function_string ( smart_str * str , zend_function * fptr , zend_class_entry * scope , char * indent ) { zend_function * overwrites ; zend_string * lc_name ; if ( fptr -> type == ZEND_USER_FUNCTION && fptr -> op_array . doc_comment ) { smart_str_append_printf ( str , "%s%s\n" , indent , ZSTR_VAL ( fptr -> op_array . doc_comment ) ) ; } smart_str_appendl ( str , indent , strlen ( indent ) ) ; smart_str_append_printf ( str , fptr -> common . fn_flags & ZEND_ACC_CLOSURE ?"Closure [ " : ( fptr -> common . scope ?"Method [ " : "Function [ " ) ) ; smart_str_append_printf ( str , ( fptr -> type == ZEND_USER_FUNCTION ) ?"<user" : "<internal" ) ; if ( fptr -> common . fn_flags & ZEND_ACC_DEPRECATED ) { smart_str_appends ( str , ", deprecated" ) ; } if ( fptr -> type == ZEND_INTERNAL_FUNCTION && ( ( zend_internal_function * ) fptr ) -> module ) { smart_str_append_printf ( str , ":%s" , ( ( zend_internal_function * ) fptr ) -> module -> name ) ; } if ( scope && fptr -> common . scope ) { if ( fptr -> common . scope != scope ) { smart_str_append_printf ( str , ", inherits %s" , ZSTR_VAL ( fptr -> common . scope -> name ) ) ; } if ( fptr -> common . scope -> parent ) { lc_name = zend_string_tolower ( fptr -> common . function_name ) ; if ( ( overwrites = zend_hash_find_ptr ( & fptr -> common . scope -> parent -> function_table , lc_name ) ) != NULL ) { if ( fptr -> common . scope != overwrites -> common . scope && ! ( overwrites -> common . fn_flags & ZEND_ACC_PRIVATE ) ) { smart_str_append_printf ( str , ", overwrites %s" , ZSTR_VAL ( overwrites -> common . scope -> name ) ) ; } } zend_string_release_ex ( lc_name , 0 ) ; } } if ( fptr -> common . prototype && fptr -> common . prototype -> common . scope ) { smart_str_append_printf ( str , ", prototype %s" , ZSTR_VAL ( fptr -> common . prototype -> common . scope -> name ) ) ; } if ( fptr -> common . fn_flags & ZEND_ACC_CTOR ) { smart_str_appends ( str , ", ctor" ) ; } smart_str_appends ( str , ">" ) ; if ( fptr -> common . fn_flags & ZEND_ACC_ABSTRACT ) { smart_str_appends ( str , "abstract " ) ; } if ( fptr -> common . fn_flags & ZEND_ACC_FINAL ) { smart_str_appends ( str , "final " ) ; } if ( fptr -> common . fn_flags & ZEND_ACC_STATIC ) { smart_str_appends ( str , "static " ) ; } if ( fptr -> common . scope ) { switch ( fptr -> common . fn_flags & ZEND_ACC_PPP_MASK ) { case ZEND_ACC_PUBLIC : smart_str_appends ( str , "public " ) ; break ; case ZEND_ACC_PRIVATE : smart_str_appends ( str , "private " ) ; break ; case ZEND_ACC_PROTECTED : smart_str_appends ( str , "protected " ) ; break ; default : smart_str_appends ( str , "<visibility error>" ) ; break ; } smart_str_appends ( str , "method " ) ; } else { smart_str_appends ( str , "function " ) ; } if ( fptr -> op_array . fn_flags & ZEND_ACC_RETURN_REFERENCE ) { smart_str_appendc ( str , '&' ) ; } smart_str_append_printf ( str , "%s ] {\n" , ZSTR_VAL ( fptr -> common . function_name ) ) ; if ( fptr -> type == ZEND_USER_FUNCTION ) { smart_str_append_printf ( str , "%s  @@ %s %d - %d\n" , indent , ZSTR_VAL ( fptr -> op_array . filename ) , fptr -> op_array . line_start , fptr -> op_array . line_end ) ; } smart_str_append_printf ( & param_indent , "%s  " , indent ) ; smart_str_0 ( & param_indent ) ; if ( fptr -> common . fn_flags & ZEND_ACC_CLOSURE ) { _function_closure_string ( str , fptr , ZSTR_VAL ( param_indent . s ) ) ; } _function_parameter_string ( str , fptr , ZSTR_VAL ( param_indent . s ) ) ; smart_str_free ( & param_indent ) ; if ( ( fptr -> op_array . fn_flags & ZEND_ACC_HAS_RETURN_TYPE ) ) { smart_str_append_printf ( str , "  %s- %s [ " , indent , ZEND_ARG_TYPE_IS_TENTATIVE ( & fptr -> common . arg_info [ - 1 ] ) ?"Tentative return" : "Return" ) ; if ( ZEND_TYPE_IS_SET ( fptr -> common . arg_info [ - 1 ] . type ) ) { zend_string * type_str = zend_type_to_string ( fptr -> common . arg_info [ - 1 ] . type ) ; smart_str_append_printf ( str , "%s " , ZSTR_VAL ( type_str ) ) ; zend_string_release ( type_str ) ; } smart_str_appends ( str , "]\n" ) ; } smart_str_append_printf ( str , "%s}\n" , indent ) ; } 