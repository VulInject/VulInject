dladm_wlan_key_t * nwamd_wlan_get_key_named ( const char * name , uint32_t security_mode ) { dladm_status_t status ; char errmsg [ DLADM_STRSIZE ] ; dladm_wlan_key_t * cooked_key ; dladm_secobj_class_t class security_mode DLADM_WLAN_SECMODE_NONE ; } if ( ( cooked_key = malloc ( sizeof ( dladm_wlan_key_t ) ) ) == NULL ) { nlog ( LOG_ERR , "nwamd_wlan_get_key_named: malloc failed" ) ; return ( NULL ) ; } ( void ) strlcpy ( cooked_key -> wk_name , name , DLADM_SECOBJ_NAME_MAX ) ; nlog ( LOG_DEBUG , "nwamd_wlan_get_key_named: len = %d, object = %s\n" , strlen ( cooked_key -> wk_name ) , cooked_key -> wk_name ) ; cooked_key -> wk_len = sizeof ( cooked_key -> wk_val ) ; cooked_key -> wk_idx = 1 ; status = dladm_get_secobj ( dld_handle , cooked_key -> wk_name , & class , cooked_key -> wk_val , & cooked_key -> wk_len , DLADM_OPT_ACTIVE ) ; if ( status != DLADM_STATUS_OK ) { nlog ( LOG_DEBUG , "nwamd_wlan_get_key_named: " "dladm_get_secobj(TEMP) failed: %s" , dladm_status2str ( status , errmsg ) ) ; status = dladm_get_secobj ( dld_handle , cooked_key -> wk_name , & class , cooked_key -> wk_val , & cooked_key -> wk_len , DLADM_OPT_PERSIST ) ; } switch ( status ) { case DLADM_STATUS_OK : nlog ( LOG_DEBUG , "nwamd_wlan_get_key_named: " "dladm_get_secobj succeeded: len %d" , cooked_key -> wk_len ) ; break ; case DLADM_STATUS_NOTFOUND : return ( NULL ) ; default : nlog ( LOG_ERR , "nwamd_wlan_get_key_named: could not get key " "from secure object '%s': %s" , cooked_key -> wk_name , dladm_status2str ( status , errmsg ) ) ; free ( cooked_key ) ; return ( NULL ) ; } if ( security_mode != 0 ) { switch ( class ) { case DLADM_SECOBJ_CLASS_WEP : if ( security_mode == DLADM_WLAN_SECMODE_WEP ) { return ( cooked_key ) ; } break ; case DLADM_SECOBJ_CLASS_WPA : if ( security_mode == DLADM_WLAN_SECMODE_WPA ) { return ( cooked_key ) ; } break ; default : nlog ( LOG_ERR , "nwamd_wlan_get_key: invalid class %d" , class ) ; break ; } nlog ( LOG_ERR , "nwamd_wlan_get_key: key type mismatch" " from secure object '%s'" , cooked_key -> wk_name ) ; free ( cooked_key ) ; return ( NULL ) ; } return ( cooked_key ) ; 