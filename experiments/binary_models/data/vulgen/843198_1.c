if ( recipients_count == 0 ) { blackholed_by = f . recipients_discarded ?US "MAIL ACL" : US "RCPT ACL" ; } else { if ( smtp_input && ! smtp_batched_input ) { if ( ! f . dkim_disable_verify ) { dkim_exim_verify_finish ( ) ; if ( acl_smtp_dkim && dkim_verify_signers && * dkim_verify_signers ) { uschar * dkim_verify_signers_expanded = expand_string ( dkim_verify_signers ) ; gstring * results = NULL ; int signer_sep = 0 ; const uschar * ptr ; uschar * item ; gstring * seen_items = NULL ; int old_pool = store_pool ; store_pool = POOL_PERM ; if ( ! ( ptr = dkim_verify_signers_expanded ) ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , "expansion of dkim_verify_signers option failed: %s" , expand_string_message ) ; } rc = OK ; while ( ( item = string_nextinlist ( & ptr , & signer_sep , NULL , 0 ) ) ) { if ( ! item || ! * item ) { continue ; } if ( seen_items ) { uschar * seen_item ; const uschar * seen_items_list = string_from_gstring ( seen_items ) ; int seen_sep = ':' ; BOOL seen_this_item = FALSE ; while ( ( seen_item = string_nextinlist ( & seen_items_list , & seen_sep , NULL , 0 ) ) ) { if ( Ustrcmp ( seen_item , item ) == 0 ) { seen_this_item = TRUE ; break ; } } if ( seen_this_item ) { DEBUG ( ) debug_printf ( "acl_smtp_dkim: skipping signer %s, " "already seen\n" , item ) ; continue ; } seen_items = string_catn ( seen_items , US ":" , 1 ) ; } seen_items = string_cat ( seen_items , item ) ; rc = dkim_exim_acl_run ( item , & results , & user_msg , & log_msg ) ; if ( rc != OK ) { DEBUG ( ) debug_printf ( "acl_smtp_dkim: acl_check returned %d on %s, " "skipping remaining items\n" , rc , item ) ; cancel_cutthrough_connection ( TRUE , US "dkim acl not ok" ) ; break ; } } dkim_verify_status = string_from_gstring ( results ) ; store_pool = old_pool ; add_acl_headers ( ACL_WHERE_DKIM , US "DKIM" ) ; if ( rc == DISCARD ) { recipients_count = 0 ; blackholed_by = US "DKIM ACL" ; if ( log_msg ) { blackhole_log_msg = string_sprintf ( ": %s" , log_msg ) ; } } if ( rc != OK ) { Uunlink ( spool_name ) ; if ( smtp_handle_acl_fail ( ACL_WHERE_DKIM , rc , user_msg , log_msg ) != 0 ) { smtp_yield = FALSE ; } smtp_reply = US "" ; message_id [ 0 ] = 0 ; TIDYUP } } else { dkim_exim_verify_log_all ( ) ; } } if ( recipients_count > 0 && acl_smtp_mime && ! run_mime_acl ( acl_smtp_mime , & smtp_yield , & smtp_reply , & blackholed_by ) ) { TIDYUP } dmarc_store_data ( from_header ) ; if ( prdr_requested && recipients_count > 1 && acl_smtp_data_prdr ) { int all_pass = OK ; int all_fail = FAIL ; smtp_printf ( "353 PRDR content analysis beginning\r\n" , TRUE ) ; for ( unsigned int c = 0 ; recipients_count > c ; c ++ ) { uschar * addr = recipients_list [ c ] . address ; uschar * msg = US "PRDR R=<%s>%s" ; uschar * code ; DEBUG ( ) debug_printf ( "PRDR processing recipient %s (%d of %d)\n" , addr , c + 1 , recipients_count ) ; rc = acl_check ( ACL_WHERE_PRDR , addr , acl_smtp_data_prdr , & user_msg , & log_msg ) ; all_pass |= rc ; all_fail &= rc ; switch ( rc ) { case OK : case DISCARD : code = US "250" ; break ; case DEFER : code = US "450" ; break ; default : code = US "550" ; break ; } if ( user_msg != NULL ) { smtp_user_msg ( code , user_msg ) ; } else { switch ( rc ) { case OK : case DISCARD : msg = string_sprintf ( , , "acceptance" ) ; break ; case DEFER : msg = string_sprintf ( , , "temporary refusal" ) ; break ; default : msg = string_sprintf ( , , "refusal" ) ; break ; } smtp_user_msg ( code , msg ) ; } if ( log_msg ) { log_write ( 0 , LOG_MAIN , "PRDR %s %s" , addr , log_msg ) ; } if ( user_msg ) { log_write ( 0 , LOG_MAIN , "PRDR %s %s" , addr , user_msg ) ; } else { log_write ( 0 , , "%s" , ) } if ( rc != OK ) { receive_remove_recipient ( addr ) ; c -- ; } } smtp_reply = string_sprintf ( "%s id=%s message %s" , all_fail == FAIL ?US "550" : US "250" , message_id , all_fail == FAIL ?US "rejected for all recipients" : all_pass == OK ?US "accepted" : US "accepted for some recipients" ) ; if ( recipients_count == 0 ) { message_id [ 0 ] = 0 ; TIDYUP } } else { prdr_requested = FALSE ; } if ( acl_smtp_data != NULL && recipients_count > 0 ) { rc = acl_check ( ACL_WHERE_DATA , NULL , acl_smtp_data , & user_msg , & log_msg ) ; add_acl_headers ( ACL_WHERE_DATA , US "DATA" ) ; if ( rc == DISCARD ) { recipients_count = 0 ; blackholed_by = US "DATA ACL" ; if ( log_msg ) { blackhole_log_msg = string_sprintf ( ": %s" , log_msg ) ; } cancel_cutthrough_connection ( TRUE , US "data acl discard" ) ; } if ( rc != OK ) { Uunlink ( spool_name ) ; cancel_cutthrough_connection ( TRUE , US "data acl not ok" ) ; unspool_mbox ( ) ; dcc_ok = 0 ; if ( smtp_handle_acl_fail ( ACL_WHERE_DATA , rc , user_msg , log_msg ) != 0 ) { smtp_yield = FALSE ; } smtp_reply = US "" ; message_id [ 0 ] = 0 ; TIDYUP } } } else { if ( acl_not_smtp_mime && ! run_mime_acl ( acl_not_smtp_mime , & smtp_yield , & smtp_reply , & blackholed_by ) ) { TIDYUP } if ( acl_not_smtp ) { uschar * user_msg , * log_msg ; f . authentication_local = TRUE ; rc = acl_check ( ACL_WHERE_NOTSMTP , NULL , acl_not_smtp , & user_msg , & log_msg ) ; if ( rc == DISCARD ) { recipients_count = 0 ; blackholed_by = US "non-SMTP ACL" ; if ( log_msg ) { blackhole_log_msg = string_sprintf ( ": %s" , log_msg ) ; } } if ( rc != OK ) { Uunlink ( spool_name ) ; unspool_mbox ( ) ; dcc_ok = 0 ; if ( log_reject_target ) { log_write ( 0 , log_reject_target , "F=<%s>rejected by non-SMTP ACL: %s" , sender_address , log_msg ) ; } if ( ! user_msg ) { user_msg = US "local configuration problem" ; } if ( smtp_batched_input ) { moan_smtp_batch ( NULL , "%d %s" , 550 , user_msg ) ; } else { fseek ( spool_data_file , ( long int ) SPOOL_DATA_START_OFFSET , SEEK_SET ) ; give_local_error ( ERRMESS_LOCAL_ACL , user_msg , US "message rejected by non-SMTP ACL: " , error_rc , spool_data_file , header_list ) ; } } add_acl_headers ( ACL_WHERE_NOTSMTP , US "non-SMTP" ) ; } } if ( f . deliver_freeze ) { frozen_by = US "ACL" ; } if ( f . queue_only_policy ) { queued_by = US "ACL" ; } } unspool_mbox ( ) ; dcc_ok = 0 ; lseek ( data_fd , ( long int ) SPOOL_DATA_START_OFFSET , SEEK_SET ) ; if ( sigsetjmp ( local_scan_env , 1 ) == 0 ) { had_local_scan_crash = 0 ; os_non_restarting_signal ( SIGSEGV , local_scan_crash_handler ) ; os_non_restarting_signal ( SIGFPE , local_scan_crash_handler ) ; os_non_restarting_signal ( SIGILL , local_scan_crash_handler ) ; os_non_restarting_signal ( SIGBUS , local_scan_crash_handler ) ; DEBUG ( ) debug_printf ( "calling local_scan(); timeout=%d\n" , local_scan_timeout ) ; local_scan_data = NULL ; had_local_scan_timeout = 0 ; os_non_restarting_signal ( SIGALRM , local_scan_timeout_handler ) ; if ( local_scan_timeout > 0 ) { ALARM ( local_scan_timeout ) ; } rc = local_scan ( data_fd , & local_scan_data ) ; ALARM_CLR ( 0 ) ; os_non_restarting_signal ( SIGALRM , sigalrm_handler ) ; f . enable_dollar_recipients = FALSE ; store_pool = POOL_MAIN ; DEBUG ( ) debug_printf ( "local_scan() returned %d %s\n" , rc , local_scan_data ) ; os_non_restarting_signal ( SIGSEGV , SIG_DFL ) ; os_non_restarting_signal ( SIGFPE , SIG_DFL ) ; os_non_restarting_signal ( SIGILL , SIG_DFL ) ; os_non_restarting_signal ( SIGBUS , SIG_DFL ) ; } else { if ( had_local_scan_crash ) { log_write ( 0 , LOG_MAIN | LOG_REJECT , "local_scan() function crashed with " "signal %d - message temporarily rejected (size %d)" , had_local_scan_crash , message_size ) ; receive_bomb_out ( US "local-scan-error" , US "local verification problem" ) ; } if ( had_local_scan_timeout ) { log_write ( 0 , LOG_MAIN | LOG_REJECT , "local_scan() function timed out - " "message temporarily rejected (size %d)" , message_size ) ; receive_bomb_out ( US "local-scan-timeout" , US "local verification problem" ) ; } } if ( local_scan_data ) { int len = Ustrlen ( local_scan_data ) ; if ( len > LOCAL_SCAN_MAX_RETURN ) { len = LOCAL_SCAN_MAX_RETURN ; } local_scan_data = string_copyn ( local_scan_data , len ) ; } if ( rc == LOCAL_SCAN_ACCEPT_FREEZE ) { if ( ! f . deliver_freeze ) { f . deliver_freeze = TRUE ; deliver_frozen_at = time ( NULL ) ; frozen_by = US "local_scan()" ; } rc = LOCAL_SCAN_ACCEPT ; } if ( rc == LOCAL_SCAN_ACCEPT_QUEUE ) { if ( ! f . queue_only_policy ) { f . queue_only_policy = TRUE ; queued_by = US "local_scan()" ; } rc = LOCAL_SCAN_ACCEPT ; } if ( rc == LOCAL_SCAN_ACCEPT ) { if ( local_scan_data ) { for ( uschar * s = local_scan_data ; * s != 0 ; s ++ ) { if ( * s == '\n' ) { * s = ' ' ; } } } for ( int i = 0 ; i < recipients_count ; i ++ ) { recipient_item * r = recipients_list + i ; r -> address = rewrite_address_qualify ( r -> address , TRUE ) ; if ( r -> errors_to ) { r -> errors_to = rewrite_address_qualify ( r -> errors_to , TRUE ) ; } } if ( recipients_count == 0 && ! blackholed_by ) { blackholed_by = US "local_scan" ; } } else { uschar * istemp = US "" ; uschar * smtp_code ; gstring * g ; errmsg = local_scan_data ; Uunlink ( spool_name ) ; switch ( rc ) { default : log_write ( 0 , LOG_MAIN , "invalid return %d from local_scan(). Temporary " "rejection given" , rc ) ; TEMPREJECT case LOCAL_SCAN_REJECT_NOLOGHDR : BIT_CLEAR ( log_selector , log_selector_size , Li_rejected_header ) ; case LOCAL_SCAN_REJECT : smtp_code = US "550" ; if ( ! errmsg ) { errmsg = US "Administrative prohibition" ; } break ; case LOCAL_SCAN_TEMPREJECT_NOLOGHDR : BIT_CLEAR ( log_selector , log_selector_size , Li_rejected_header ) ; case LOCAL_SCAN_TEMPREJECT : TEMPREJECT smtp_code = US "451" ; if ( ! errmsg ) { errmsg = US "Temporary local problem" ; } istemp = US "temporarily " ; break ; } g = string_append ( NULL , 2 , US "F=" , sender_address [ 0 ] == 0 ?US "<>" : sender_address ) ; g = add_host_info_for_log ( g ) ; log_write ( 0 , LOG_MAIN | LOG_REJECT , "%s %srejected by local_scan(): %.256s" , string_from_gstring ( g ) , istemp , string_printing ( errmsg ) ) ; if ( smtp_input ) { if ( ! smtp_batched_input ) { smtp_respond ( smtp_code , 3 , TRUE , errmsg ) ; message_id [ 0 ] = 0 ; smtp_reply = US "" ; TIDYUP } else { moan_smtp_batch ( NULL , "%s %s" , smtp_code , errmsg ) ; } } else { fseek ( spool_data_file , ( long int ) SPOOL_DATA_START_OFFSET , SEEK_SET ) ; give_local_error ( ERRMESS_LOCAL_SCAN , errmsg , US "message rejected by local scan code: " , error_rc , spool_data_file , header_list ) ; } } signal ( SIGTERM , SIG_IGN ) ; signal ( SIGINT , SIG_IGN ) ; f . deliver_firsttime = TRUE ; if ( bmi_run == 1 ) { lseek ( data_fd , ( long int ) SPOOL_DATA_START_OFFSET , SEEK_SET ) ; bmi_verdicts = bmi_process_message ( header_list , data_fd ) ; } timestamp = expand_string ( US "${tod_full}" ) ; tslen = Ustrlen ( timestamp ) ; memcpy ( received_header -> text + received_header -> slen - tslen - 1 , timestamp , tslen ) ; if ( mua_wrapper ) { f . deliver_freeze = FALSE ; f . queue_only_policy = FALSE ; } if ( host_checking || blackholed_by ) { Uunlink ( spool_name ) ; msg_size = 0 ; for ( header_line * h = header_list ; h ; h = h -> next ) { if ( h -> type != '*' ) { msg_size += h -> slen ; } } } if ( ( msg_size = spool_write_header ( message_id , SW_RECEIVING , & errmsg ) ) < 0 ) { log_write ( 0 , LOG_MAIN , "Message abandoned: %s" , errmsg ) ; Uunlink ( spool_name ) ; if ( smtp_input ) { smtp_reply = US "451 Error in writing spool file" ; message_id [ 0 ] = 0 ; TIDYUP } else { fseek ( spool_data_file , ( long int ) SPOOL_DATA_START_OFFSET , SEEK_SET ) ; give_local_error ( ERRMESS_IOERR , errmsg , US "" , error_rc , spool_data_file , header_list ) ; } } receive_messagecount ++ ; if ( fflush ( spool_data_file ) ) { errmsg = string_sprintf ( "Spool write error: %s" , strerror ( errno ) ) ; log_write ( 0 , LOG_MAIN , "%s\n" , errmsg ) ; Uunlink ( spool_name ) ; if ( smtp_input ) { smtp_reply = US "451 Error in writing spool file" ; message_id [ 0 ] = 0 ; TIDYUP } else { fseek ( spool_data_file , ( long int ) SPOOL_DATA_START_OFFSET , SEEK_SET ) ; give_local_error ( ERRMESS_IOERR , errmsg , US "" , error_rc , spool_data_file , header_list ) ; } } fstat ( data_fd , & statbuf ) ; msg_size += statbuf . st_size - SPOOL_DATA_START_OFFSET + 1 ; rcvd_log_reset_point = store_mark ( ) ; g = string_get ( 256 ) ; g = string_append ( g , 2 , fake_response == FAIL ?US "(= " : US "<= " , sender_address [ 0 ] == 0 ?US "<>" : sender_address ) ; if ( message_reference ) { g = string_append ( g , 2 , US " R=" , message_reference ) ; } g = add_host_info_for_log ( g ) ; if ( LOGGING ( tls_cipher ) && tls_in . cipher ) { g = string_append ( g , 2 , US " X=" , tls_in . cipher ) ; if ( LOGGING ( tls_resumption ) && tls_in . resumption & RESUME_USED ) { g = string_catn ( g , US "*" , 1 ) ; } } if ( LOGGING ( tls_certificate_verified ) && tls_in . cipher ) { g = string_append ( g , 2 , US " CV=" , tls_in . certificate_verified ?"yes" : "no" ) ; } if ( LOGGING ( tls_peerdn ) && tls_in . peerdn ) { g = string_append ( g , 3 , US " DN=\"" , string_printing ( tls_in . peerdn ) , US "\"" ) ; } if ( LOGGING ( tls_sni ) && tls_in . sni ) { g = string_append ( g , 2 , US " SNI=" , string_printing2 ( tls_in . sni , SP_TAB | SP_SPACE ) ) ; } if ( sender_host_authenticated ) { g = string_append ( g , 2 , US " A=" , sender_host_authenticated ) ; if ( authenticated_id ) { g = string_append ( g , 2 , US ":" , authenticated_id ) ; if ( LOGGING ( smtp_mailauth ) && authenticated_sender ) { g = string_append ( g , 2 , US ":" , authenticated_sender ) ; } } } if ( prdr_requested ) { g = string_catn ( g , US " PRDR" , 5 ) ; } if ( proxy_session && LOGGING ( proxy ) ) { g = string_append ( g , 2 , US " PRX=" , proxy_local_address ) ; } if ( chunking_state > CHUNKING_OFFERED ) { g = string_catn ( g , US " K" , 2 ) ; } g = string_fmt_append ( g , " S=%d" , msg_size ) ; if ( LOGGING ( 8bitmime ) ) { g = string_fmt_append ( g , " M8S=%d" , body_8bitmime ) ; } if ( LOGGING ( dkim ) && dkim_verify_overall ) { g = string_append ( g , 2 , US " DKIM=" , dkim_verify_overall ) ; } if ( LOGGING ( dkim ) && arc_state && Ustrcmp ( arc_state , "pass" ) == 0 ) { g = string_catn ( g , US " ARC" , 4 ) ; } if ( LOGGING ( receive_time ) ) { struct timeval diff = received_time_complete ; timediff ( & diff , & received_time ) ; g = string_append ( g , 2 , US " RT=" , string_timediff ( & diff ) ) ; } if ( * queue_name ) { g = string_append ( g , 2 , US " Q=" , queue_name ) ; } if ( LOGGING ( msg_id ) && msgid_header && ( LOGGING ( msg_id_created ) || ! msgid_header_newly_created ) ) { uschar * old_id ; BOOL save_allow_domain_literals = allow_domain_literals ; allow_domain_literals = TRUE ; int start , end , domain ; old_id = parse_extract_address ( Ustrchr ( msgid_header -> text , ':' ) + 1 , & errmsg , & start , & end , & domain , FALSE ) ; allow_domain_literals = save_allow_domain_literals ; if ( old_id ) { g = string_append ( g , 2 , msgid_header_newly_created ?US " id*=" : US " id=" , string_printing ( old_id ) ) ; } } if ( LOGGING ( subject ) && subject_header ) { uschar * p = big_buffer ; uschar * ss = expand_string ( US "$h_subject:" ) ; * p ++ = '\"' ; if ( * ss != 0 ) { for ( int i = 0 ; i < 100 && ss [ i ] != 0 ; i ++ ) { if ( ss [ i ] == '\"' || ss [ i ] == '\\' ) { * p ++ = '\\' ; } * p ++ = ss [ i ] ; } } * p ++ = '\"' ; * p = 0 ; g = string_append ( g , 2 , US " T=" , string_printing ( big_buffer ) ) ; } ( void ) string_from_gstring ( g ) ; if ( message_logs && ! blackholed_by ) { int fd ; uschar * m_name = spool_fname ( US "msglog" , message_subdir , message_id , US "" ) ; if ( ( fd = Uopen ( m_name , O_WRONLY | O_APPEND | O_CREAT , SPOOL_MODE ) ) < 0 && errno == ENOENT ) { ( void ) directory_make ( spool_directory , spool_sname ( US "msglog" , message_subdir ) , MSGLOG_DIRECTORY_MODE , TRUE ) ; fd = Uopen ( m_name , O_WRONLY | O_APPEND | O_CREAT , SPOOL_MODE ) ; } if ( fd < 0 ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , "Couldn't open message log %s: %s" , m_name , strerror ( errno ) ) ; } else { FILE * message_log = fdopen ( fd , "a" ) ; if ( ! message_log ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , "Couldn't fdopen message log %s: %s" , m_name , strerror ( errno ) ) ; ( void ) close ( fd ) ; } else { uschar * now = tod_stamp ( tod_log ) ; fprintf ( message_log , "%s Received from %s\n" , now , g -> s + 3 ) ; if ( f . deliver_freeze ) { fprintf ( message_log , "%s frozen by %s\n" , now , frozen_by ) ; } if ( f . queue_only_policy ) { fprintf ( , "%s no immediate delivery: queued%s%s by %s\n" , , " in " "" , "" , ) } ( void ) fclose ( message_log ) ; } } } f . receive_call_bombout = TRUE ; if ( smtp_input && sender_host_address && ! f . sender_host_notsocket && ! receive_hasc ( ) ) { if ( poll_one_fd ( fileno ( smtp_in ) , POLLIN , 0 ) != 0 ) { int c = ( receive_getc ) ( GETC_BUFFER_UNLIMITED ) ; if ( c != EOF ) { ( receive_ungetc ) ( c ) ; } else { smtp_notquit_exit ( US "connection-lost" , NULL , NULL ) ; smtp_reply = US "" ; smtp_yield = FALSE ; gstring_reset ( g ) ; g = string_cat ( g , US "SMTP connection lost after final dot" ) ; g = add_host_info_for_log ( g ) ; log_write ( 0 , LOG_MAIN , "%s" , string_from_gstring ( g ) ) ; Uunlink ( spool_name ) ; Uunlink ( spool_fname ( US "input" , message_subdir , message_id , US "-H" ) ) ; Uunlink ( spool_fname ( US "msglog" , message_subdir , message_id , US "" ) ) ; TIDYUP } } } if ( cutthrough . cctx . sock >= 0 && cutthrough . delivery ) { uschar * msg = cutthrough_finaldot ( ) ; switch ( msg [ 0 ] ) { case '2' : cutthrough_done = ACCEPTED ; break ; case '4' : if ( cutthrough . defer_pass ) { smtp_reply = string_copy_perm ( msg , TRUE ) ; } cutthrough_done = TMP_REJ ; break ; default : if ( cutthrough . defer_pass ) { smtp_reply = US "450 Onward transmission not accepted" ; } cutthrough_done = TMP_REJ ; break ; case '5' : smtp_reply = string_copy_perm ( msg , TRUE ) ; cutthrough_done = PERM_REJ ; break ; } } if ( ! smtp_reply || prdr_requested ) { if ( ! smtp_reply ) { log_write ( 0 , LOG_MAIN | ( LOGGING ( received_recipients ) ?LOG_RECIPIENTS : 0 ) | ( LOGGING ( received_sender ) ?LOG_SENDER : 0 ) , "%s" , g -> s ) ; if ( f . deliver_freeze ) { log_write ( 0 , LOG_MAIN , "frozen by %s" , frozen_by ) ; } if ( f . queue_only_policy ) { log_write ( , , "no immediate delivery: queued%s%s by %s" , " in " "" , "" , ) } } } f . receive_call_bombout = FALSE ; rcvd_log_reset_point = store_reset ( rcvd_log_reset_point ) ; if ( f . deliver_freeze && freeze_tell && freeze_tell [ 0 ] ) { moan_tell_someone ( freeze_tell , NULL , US "Message frozen on arrival" , "Message %s was frozen on arrival by %s.\nThe sender is<%s>.\n" , message_id , frozen_by , sender_address ) ; } TIDYUP process_info [ process_info_len ] = 0 ; if ( spool_data_file && cutthrough_done == NOT_TRIED ) { if ( fclose ( spool_data_file ) ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , "spoolfile error on close: %s" , strerror ( errno ) ) ; } spool_data_file = NULL ; } signal ( SIGTERM , SIG_DFL ) ; signal ( SIGINT , SIG_DFL ) ; if ( smtp_input ) { yield = smtp_yield ; if ( ! smtp_batched_input ) { if ( ! smtp_reply ) { if ( fake_response != OK ) { smtp_respond ( fake_response == DEFER ?US "450" : US "550" , 3 , TRUE , fake_response_text ) ; } if ( user_msg ) { uschar * code = US "250" ; int len = 3 ; smtp_message_code ( & code , & len , & user_msg , NULL , TRUE ) ; smtp_respond ( code , len , TRUE , user_msg ) ; } if ( chunking_state > CHUNKING_OFFERED ) { smtp_printf ( "250- %u byte chunk, total %d\r\n250 OK id=%s\r\n" , receive_hasc ( ) , chunking_datasize , message_size + message_linecount , message_id ) ; chunking_state = CHUNKING_OFFERED ; } else { smtp_printf ( "250 OK id=%s\r\n" , receive_hasc ( ) , message_id ) ; } if ( host_checking ) { fprintf ( stdout , "\n**** SMTP testing: that is not a real message id!\n\n" ) ; } } if ( smtp_reply [ 0 ] != 0 ) { if ( fake_response != OK && smtp_reply [ 0 ] == '2' ) { smtp_respond ( fake_response == DEFER ?US "450" : US "550" , 3 , TRUE , fake_response_text ) ; } else { smtp_printf ( "%.1024s\r\n" , FALSE , smtp_reply ) ; } } switch ( cutthrough_done ) { case ACCEPTED : log_write ( 0 , LOG_MAIN , "Completed" ) ; case PERM_REJ : Uunlink ( spool_name ) ; Uunlink ( spool_fname ( US "input" , message_subdir , message_id , US "-H" ) ) ; Uunlink ( spool_fname ( US "msglog" , message_subdir , message_id , US "" ) ) ; break ; case TMP_REJ : if ( cutthrough . defer_pass ) { Uunlink ( spool_name ) ; Uunlink ( spool_fname ( US "input" , message_subdir , message_id , US "-H" ) ) ; Uunlink ( spool_fname ( US "msglog" , message_subdir , message_id , US "" ) ) ; } default : break ; } } if ( smtp_reply ) { moan_smtp_batch ( NULL , "%s" , smtp_reply ) ; } } if ( blackholed_by ) { const uschar * detail = local_scan_data ?string_printing ( local_scan_data ) : string_sprintf ( "(%s discarded recipients)" , blackholed_by ) ; log_write ( 0 , LOG_MAIN , "=>blackhole %s%s" , detail , blackhole_log_msg ) ; log_write ( 0 , LOG_MAIN , "Completed" ) ; message_id [ 0 ] = 0 ; } header_list = header_last = NULL ; return yield ; 