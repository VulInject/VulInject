static BROTLI_BOOL EncodeData ( BrotliEncoderState * s , const BROTLI_BOOL is_last , const BROTLI_BOOL force_flush , size_t * out_size , uint8_t * * output ) { const uint64_t delta = UnprocessedInputSize ( s ) ; const uint32_t bytes = ( uint32_t ) delta ; const uint32_t wrapped_last_processed_pos = WrapPosition ( s -> last_processed_pos_ ) ; uint8_t * data ; uint32_t mask ; MemoryManager * m = & s -> memory_manager_ ; const BrotliDictionary * dictionary = BrotliGetDictionary ( ) ; data = s -> ringbuffer_ . buffer_ ; mask = s -> ringbuffer_ . mask_ ; if ( s -> is_last_block_emitted_ ) { return BROTLI_FALSE ; } if ( is_last ) { s -> is_last_block_emitted_ = BROTLI_TRUE ; } if ( delta > InputBlockSize ( s ) ) { return BROTLI_FALSE ; } if ( s -> params . quality == FAST_TWO_PASS_COMPRESSION_QUALITY && ! s -> command_buf_ ) { s -> command_buf_ = BROTLI_ALLOC ( m , uint32_t , kCompressFragmentTwoPassBlockSize ) ; s -> literal_buf_ = BROTLI_ALLOC ( m , uint8_t , kCompressFragmentTwoPassBlockSize ) ; if ( BROTLI_IS_OOM ( m ) ) { return BROTLI_FALSE ; } } if ( s -> params . quality == FAST_ONE_PASS_COMPRESSION_QUALITY || s -> params . quality == FAST_TWO_PASS_COMPRESSION_QUALITY ) { uint8_t * storage ; size_t storage_ix = s -> last_byte_bits_ ; size_t table_size ; int * table ; if ( delta == 0 && ! is_last ) { * out_size = 0 ; return BROTLI_TRUE ; } storage = GetBrotliStorage ( s , 2 * bytes + 502 ) ; if ( BROTLI_IS_OOM ( m ) ) { return BROTLI_FALSE ; } storage [ 0 ] = s -> last_byte_ ; table = GetHashTable ( s , s -> params . quality , bytes , & table_size ) ; if ( BROTLI_IS_OOM ( m ) ) { return BROTLI_FALSE ; } if ( s -> params . quality == FAST_ONE_PASS_COMPRESSION_QUALITY ) { BrotliCompressFragmentFast ( m , & data [ wrapped_last_processed_pos & mask ] , bytes , is_last , table , table_size , s -> cmd_depths_ , s -> cmd_bits_ , & s -> cmd_code_numbits_ , s -> cmd_code_ , & storage_ix , storage ) ; if ( BROTLI_IS_OOM ( m ) ) { return BROTLI_FALSE ; } } else { BrotliCompressFragmentTwoPass ( m , & data [ wrapped_last_processed_pos & mask ] , bytes , is_last , s -> command_buf_ , s -> literal_buf_ , table , table_size , & storage_ix , storage ) ; if ( BROTLI_IS_OOM ( m ) ) { return BROTLI_FALSE ; } } s -> last_byte_ = storage [ storage_ix >> 3 ] ; s -> last_byte_bits_ = storage_ix & 7u ; UpdateLastProcessedPos ( s ) ; * output = & storage [ 0 ] ; * out_size = storage_ix >> 3 ; return BROTLI_TRUE ; } { size_t newsize = s -> num_commands_ + bytes / 2 + 1 ; if ( newsize > s -> cmd_alloc_size_ ) { Command * new_commands ; newsize += ( bytes / 4 ) + 16 ; s -> cmd_alloc_size_ = newsize ; new_commands = BROTLI_ALLOC ( m , Command , newsize ) ; if ( BROTLI_IS_OOM ( m ) ) { return BROTLI_FALSE ; } if ( s -> commands_ ) { memcpy ( new_commands , s -> commands_ , sizeof ( Command ) * s -> num_commands_ ) ; BROTLI_FREE ( m , s -> commands_ ) ; } s -> commands_ = new_commands ; } } InitOrStitchToPreviousBlock ( m , & s -> hasher_ , data , mask , & s -> params , wrapped_last_processed_pos , bytes , is_last ) ; if ( BROTLI_IS_OOM ( m ) ) { return BROTLI_FALSE ; } if ( s -> params . quality == ZOPFLIFICATION_QUALITY ) { assert ( s -> params . hasher . type == 10 ) ; BrotliCreateZopfliBackwardReferences ( m , dictionary , bytes , wrapped_last_processed_pos , data , mask , & s -> params , s -> hasher_ , s -> dist_cache_ , & s -> last_insert_len_ , & s -> commands_ [ s -> num_commands_ ] , & s -> num_commands_ , & s -> num_literals_ ) ; if ( BROTLI_IS_OOM ( m ) ) { return BROTLI_FALSE ; } } if ( s -> params . quality == HQ_ZOPFLIFICATION_QUALITY ) { assert ( s -> params . hasher . type == 10 ) ; BrotliCreateHqZopfliBackwardReferences ( m , dictionary , bytes , wrapped_last_processed_pos , data , mask , & s -> params , s -> hasher_ , s -> dist_cache_ , & s -> last_insert_len_ , & s -> commands_ [ s -> num_commands_ ] , & s -> num_commands_ , & s -> num_literals_ ) ; if ( BROTLI_IS_OOM ( m ) ) { return BROTLI_FALSE ; } } else { BrotliCreateBackwardReferences ( dictionary , bytes , wrapped_last_processed_pos , data , mask , & s -> params , s -> hasher_ , s -> dist_cache_ , & s -> last_insert_len_ , & s -> commands_ [ s -> num_commands_ ] , & s -> num_commands_ , & s -> num_literals_ ) ; } { const size_t max_length = MaxMetablockSize ( & s -> params ) ; const size_t max_literals = max_length / 8 ; const size_t max_commands = max_length / 8 ; const size_t processed_bytes = ( size_t ) ( s -> input_pos_ - s -> last_flush_pos_ ) ; const BROTLI_BOOL next_input_fits_metablock = TO_BROTLI_BOOL ( processed_bytes + InputBlockSize ( s ) <= max_length ) ; const BROTLI_BOOL should_flush = TO_BROTLI_BOOL ( s -> params . quality < MIN_QUALITY_FOR_BLOCK_SPLIT && s -> num_literals_ + s -> num_commands_ >= MAX_NUM_DELAYED_SYMBOLS ) ; if ( ! is_last && ! force_flush && ! should_flush && next_input_fits_metablock && s -> num_literals_ < max_literals && s -> num_commands_ < max_commands ) { if ( UpdateLastProcessedPos ( s ) ) { HasherReset ( s -> hasher_ ) ; } * out_size = 0 ; return BROTLI_TRUE ; } } if ( s -> last_insert_len_ > 0 ) { InitInsertCommand ( & s -> commands_ [ s -> num_commands_ ++ ] , s -> last_insert_len_ ) ; s -> num_literals_ += s -> last_insert_len_ ; s -> last_insert_len_ = 0 ; } if ( ! is_last && s -> input_pos_ == s -> last_flush_pos_ ) { * out_size = 0 ; return BROTLI_TRUE ; } assert ( s -> input_pos_ >= s -> last_flush_pos_ ) ; assert ( s -> input_pos_ > s -> last_flush_pos_ || is_last ) ; assert ( s -> input_pos_ - s -> last_flush_pos_ <= 1u << 24 ) ; { const uint32_t metablock_size = ( uint32_t ) ( s -> input_pos_ - s -> last_flush_pos_ ) ; uint8_t * storage = GetBrotliStorage ( s , 2 * metablock_size + 502 ) ; size_t storage_ix = s -> last_byte_bits_ ; if ( BROTLI_IS_OOM ( m ) ) { return BROTLI_FALSE ; } storage [ 0 ] = s -> last_byte_ ; WriteMetaBlockInternal ( m , data , mask , s -> last_flush_pos_ , metablock_size , is_last , & s -> params , s -> prev_byte_ , s -> prev_byte2_ , s -> num_literals_ , s -> num_commands_ , s -> commands_ , s -> saved_dist_cache_ , s -> dist_cache_ , & storage_ix , storage ) ; if ( BROTLI_IS_OOM ( m ) ) { return BROTLI_FALSE ; } s -> last_byte_ = storage [ storage_ix >> 3 ] ; s -> last_byte_bits_ = storage_ix & 7u ; s -> last_flush_pos_ = s -> input_pos_ ; if ( UpdateLastProcessedPos ( s ) ) { HasherReset ( s -> hasher_ ) ; } if ( s -> last_flush_pos_ > 0 ) { s -> prev_byte_ = data [ ( ( uint32_t ) s -> last_flush_pos_ - 1 ) & mask ] ; } if ( s -> last_flush_pos_ > 1 ) { s -> prev_byte2_ = data [ ( uint32_t ) ( s -> last_flush_pos_ - 2 ) & mask ] ; } s -> num_commands_ = 0 ; s -> num_literals_ = 0 ; memcpy ( s -> saved_dist_cache_ , s -> dist_cache_ , sizeof ( s -> saved_dist_cache_ ) ) ; * output = & storage [ 0 ] ; * out_size = storage_ix >> 3 ; return BROTLI_TRUE ; } } 