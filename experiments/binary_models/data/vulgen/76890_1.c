void si_cache_del ( si_t * sp , int signature ) { si_t * * tspp ; int hash ; int foundacl = 0 ; rw_enter ( & si_cache_lock , RW_WRITER ) ; hash = SI_HASH ( signature ) ; for ( tspp = & si_cachea [ hash ] ; * tspp ; tspp = & ( * tspp ) -> s_next ) { if ( * tspp == sp ) { rw_enter ( & sp -> s_lock , RW_WRITER ) ; if ( sp -> s_ref ) { rw_exit ( & sp -> s_lock ) ; rw_exit ( & si_cache_lock ) ; return ; } ASSERT ( sp -> s_flags & SI_CACHED ) ; foundacl = 1 ; * tspp = sp -> s_next ; break ; } } if ( foundacl == 0 ) { rw_exit ( & si_cache_lock ) ; return ; } hash = SI_HASH ( sp -> s_shadow ) ; for ( tspp = & si_cachei [ hash ] ; * tspp ; tspp = & ( * tspp ) -> s_forw ) { if ( * tspp == sp ) { * tspp = sp -> s_forw ; break ; } } rw_exit ( & sp -> s_lock ) ; rw_exit ( & si_cache_lock ) ; sp -> s_flags &= ~ SI_CACHED ; ( void ) ufs_si_free_mem ( sp ) ; } 