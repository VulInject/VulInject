test_invalid_write_concern ( ) { mongoc_bulk_write_flags_t write_flags = MONGOC_BULK_WRITE_FLAGS_INIT ; mongoc_write_command_t command ; mongoc_write_result_t result ; mongoc_collection_t * collection ; mongoc_client_t * client ; mongoc_write_concern_t * write_concern ; mongoc_server_stream_t * server_stream ; bson_t * doc ; bson_t reply = BSON_INITIALIZER ; bson_error_t error ; bool r ; client = test_framework_new_default_client ( ) ; BSON_ASSERT ( client ) ; collection = get_test_collection ( client , "test_invalid_write_concern" ) ; BSON_ASSERT ( collection ) ; write_concern = mongoc_write_concern_new ( ) ; BSON_ASSERT ( write_concern ) ; mongoc_write_concern_set_w ( write_concern , 0 ) ; mongoc_write_concern_set_journal ( write_concern , true ) ; BSON_ASSERT ( ! mongoc_write_concern_is_valid ( write_concern ) ) ; doc = BCON_NEW ( "_id" , BCON_INT32 ( 0 ) ) ; _mongoc_write_command_init_insert ( & command , doc , NULL , write_flags , ++ client -> cluster . operation_id ) ; _mongoc_write_result_init ( & result ) ; server_stream = mongoc_cluster_stream_for_writes ( & client -> cluster , NULL , NULL , & error ) ; ASSERT_OR_PRINT ( server_stream , error ) ; _mongoc_write_command_execute ( & command , client , server_stream , collection -> db , collection -> collection , write_concern , 0 , NULL , & result ) ; r = MONGOC_WRITE_RESULT_COMPLETE ( & result , 2 , collection -> write_concern , ( mongoc_error_domain_t ) 0 , & reply , & error ) ; BSON_ASSERT ( ! r ) ; ASSERT_CMPINT ( error . domain , == , MONGOC_ERROR_COMMAND ) ; ASSERT_CMPINT ( error . code , == , MONGOC_ERROR_COMMAND_INVALID_ARG ) ; _mongoc_write_command_destroy ( & command ) ; _mongoc_write_result_destroy ( & result ) ; bson_destroy ( doc ) ; bson_destroy ( & reply ) ; mongoc_server_stream_cleanup ( server_stream ) ; mongoc_collection_destroy ( collection ) ; mongoc_client_destroy ( client ) ; } 