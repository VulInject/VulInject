static stf_status ikev2_parent_inR1outI2_tail ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r ) { struct dh_continuation * dh = ( dh_continuation * ) pcrc ; struct msg_digest * md = dh -> md ; struct state * st = md -> st ; struct connection * c = st -> st_connection ; struct ikev2_generic e ; unsigned char * encstart ; pb_stream e_pbs , e_pbs_cipher ; unsigned char * iv ; int ivsize ; stf_status ret ; unsigned char * idhash ; unsigned char * authstart ; struct state * pst = st ; msgid_t mid = INVALID_MSGID ; md -> transition_state = st ; finish_dh_v2 ( st , r ) ; if ( DBGP ( DBG_PRIVATE ) && DBGP ( DBG_CRYPT ) ) { ikev2_log_parentSA ( st ) ; ikev2_validate_key_lengths ( st ) ; } pst = st ; ret = allocate_msgid_from_parent ( pst , & mid ) ; if ( ret != STF_OK ) { return ret ; } st = duplicate_state ( pst ) ; st -> st_policy = pst -> st_connection -> policy & POLICY_IPSEC_MASK ; st -> st_msgid = mid ; insert_state ( st ) ; md -> st = st ; md -> pst = pst ; schedule_sa_replace_event ( TRUE , c -> sa_ike_life_seconds , c , pst ) ; clonetochunk ( pst -> st_firstpacket_him , md -> packet_pbs . start , pbs_offset ( & md -> packet_pbs ) , "saved first received packet" ) ; authstart = reply_stream . cur ; zero ( reply_buffer ) ; init_pbs ( & reply_stream , reply_buffer , sizeof ( reply_buffer ) , "reply packet" ) ; { struct isakmp_hdr r_hdr = md -> hdr ; r_hdr . isa_np = ISAKMP_NEXT_v2E ; r_hdr . isa_xchg = ISAKMP_v2_AUTH ; r_hdr . isa_flags = IKEv2_ORIG_INITIATOR_FLAG ( pst ) ; r_hdr . isa_msgid = htonl ( st -> st_msgid ) ; memcpy ( r_hdr . isa_icookie , st -> st_icookie , COOKIE_SIZE ) ; memcpy ( r_hdr . isa_rcookie , st -> st_rcookie , COOKIE_SIZE ) ; if ( ! out_struct ( & r_hdr , & isakmp_hdr_desc , & reply_stream , & md -> rbody ) ) { return STF_INTERNAL_ERROR ; } } e . isag_np = ISAKMP_NEXT_v2IDi ; e . isag_critical = ISAKMP_PAYLOAD_NONCRITICAL ; if ( DBGP ( IMPAIR_SEND_BOGUS_ISAKMP_FLAG ) ) { openswan_log ( " setting bogus ISAKMP_PAYLOAD_OPENSWAN_BOGUS flag in ISAKMP payload" ) ; e . isag_critical |= ISAKMP_PAYLOAD_OPENSWAN_BOGUS ; } if ( ! out_struct ( & e , & ikev2_e_desc , & md -> rbody , & e_pbs ) ) { return STF_INTERNAL_ERROR ; } iv = e_pbs . cur ; ivsize = st -> st_oakley . encrypter -> iv_size ; if ( ! out_zero ( ivsize , & e_pbs , "iv" ) ) { return STF_INTERNAL_ERROR ; } get_rnd_bytes ( iv , ivsize ) ; init_sub_pbs ( & e_pbs , & e_pbs_cipher , "cleartext" ) ; encstart = e_pbs_cipher . cur ; { struct ikev2_id r_id ; pb_stream r_id_pbs ; chunk_t id_b ; struct hmac_ctx id_ctx ; unsigned char * id_start ; unsigned int id_len ; build_id_payload ( ( isakmp_ipsec_id * ) & r_id , & id_b , & c -> spd . this ) ; r_id . isai_critical = ISAKMP_PAYLOAD_NONCRITICAL ; if ( DBGP ( IMPAIR_SEND_BOGUS_ISAKMP_FLAG ) ) { openswan_log ( " setting bogus ISAKMP_PAYLOAD_OPENSWAN_BOGUS flag in ISAKMP payload" ) ; r_id . isai_critical |= ISAKMP_PAYLOAD_OPENSWAN_BOGUS ; } r_id . isai_np = 0 ; pbs_set_np ( & e_pbs_cipher , ISAKMP_NEXT_v2IDi ) ; id_start = e_pbs_cipher . cur ; if ( ! out_struct ( & r_id , & ikev2_id_desc , & e_pbs_cipher , & r_id_pbs ) ) { return STF_INTERNAL_ERROR ; } if ( ! out_chunk ( id_b , & r_id_pbs , "my identity" ) ) { return STF_INTERNAL_ERROR ; } id_start += 4 ; id_len = r_id_pbs . cur - id_start ; hmac_init_chunk ( & id_ctx , pst -> st_oakley . prf_hasher , pst -> st_skey_pi ) ; DBG ( DBG_CRYPT , DBG_dump_chunk ( "parent SA IDi idhash pi calc" , pst -> st_skey_pi ) ) ; DBG ( DBG_CRYPT , DBG_dump ( "parent SA I2 idhash calc" , id_start , id_len ) ) ; hmac_update ( & id_ctx , id_start , id_len ) ; idhash = alloca ( pst -> st_oakley . prf_hasher -> hash_digest_len ) ; hmac_final ( idhash , & id_ctx ) ; close_output_pbs ( & r_id_pbs ) ; } if ( doi_send_ikev2_cert_thinking ( st ) ) { stf_status certstat = ikev2_send_cert ( st , md , INITIATOR , & e_pbs_cipher ) ; if ( certstat != STF_OK ) { return certstat ; } if ( st -> st_connection -> spd . this . sendcert == cert_sendifasked ) { st -> hidden_variables . st_got_certrequest = FALSE ; } } { lset_t policy ; struct connection * c0 = first_pending ( pst , & policy , & st -> st_whack_sock ) ; DBG ( DBG_CONTROL , DBG_log ( " payload after AUTH will be %s" , ( c0 ) ?"ISAKMP_NEXT_v2SA" : "ISAKMP_NEXT_NONE/NOTIFY" ) ) ; stf_status authstat = ikev2_send_auth ( c , st , INITIATOR , idhash , & e_pbs_cipher ) ; if ( authstat != STF_OK ) { return authstat ; } if ( c0 ) { chunk_t child_spi , notify_data ; st -> st_connection = c0 ; ikev2_emit_ipsec_sa ( md , & e_pbs_cipher , ISAKMP_NEXT_v2TSi , c0 , policy ) ; st -> st_ts_this = ikev2_end_to_ts ( & c0 -> spd . this , st -> st_localaddr ) ; st -> st_ts_that = ikev2_end_to_ts ( & c0 -> spd . that , st -> st_remoteaddr ) ; ikev2_calc_emit_ts ( md , & e_pbs_cipher , INITIATOR , c0 , policy ) ; if ( ! ( st -> st_connection -> policy & POLICY_TUNNEL ) ) { DBG_log ( "Initiator child policy is transport mode, sending v2N_USE_TRANSPORT_MODE" ) ; memset ( & child_spi , 0 , sizeof ( child_spi ) ) ; memset ( & notify_data , 0 , sizeof ( notify_data ) ) ; ship_v2N ( ISAKMP_NEXT_NONE , ISAKMP_PAYLOAD_NONCRITICAL , 0 , & child_spi , v2N_USE_TRANSPORT_MODE , & notify_data , & e_pbs_cipher ) ; } change_state ( st , STATE_CHILD_C0_KEYING ) ; } else { openswan_log ( "no pending SAs found, PARENT SA keyed only" ) ; } } ikev2_padup_pre_encrypt ( md , & e_pbs_cipher ) ; close_output_pbs ( & e_pbs_cipher ) ; { unsigned char * authloc = ikev2_authloc ( md , & e_pbs ) ; if ( authloc == NULL || authloc < encstart ) { return STF_INTERNAL_ERROR ; } close_output_pbs ( & e_pbs ) ; close_output_pbs ( & md -> rbody ) ; close_output_pbs ( & reply_stream ) ; ret = ikev2_encrypt_msg ( md , INITIATOR , authstart , iv , encstart , authloc , & e_pbs , & e_pbs_cipher ) ; } TCLCALLOUT ( "v2_avoidEmitting" , st , st -> st_connection , md ) ; freeanychunk ( pst -> st_tpacket ) ; clonetochunk ( pst -> st_tpacket , reply_stream . start , pbs_offset ( & reply_stream ) , "reply packet for ikev2_parent_outI1" ) ; delete_event ( st ) ; event_schedule ( EVENT_v2_RETRANSMIT , EVENT_RETRANSMIT_DELAY_0 , st ) ; return STF_OK ; } 