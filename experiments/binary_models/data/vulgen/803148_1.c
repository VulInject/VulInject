int ofputil_decode_flow_update ( struct ofputil_flow_update * update , struct ofpbuf * msg , struct ofpbuf * ofpacts ) { unsigned int length ; struct ofp_header * oh ; enum ofperr error ; enum ofpraw raw ; if ( ! msg -> header ) { ofpraw_pull_assert ( msg ) ; } error = ofpraw_decode ( & raw , msg -> header ) ; if ( error ) { return error ; } ofpbuf_clear ( ofpacts ) ; if ( ! msg -> size ) { return EOF ; } oh = msg -> header ; switch ( ( int ) raw ) { case OFPRAW_ONFST13_FLOW_MONITOR_REPLY : case OFPRAW_NXST_FLOW_MONITOR_REPLY : { struct nx_flow_update_header * nfuh ; enum nx_flow_update_event nx_event ; if ( msg -> size < sizeof ( nx_flow_update_header ) ) { bad_len } nfuh = msg -> data ; length = ntohs ( nfuh -> length ) ; if ( length > msg -> size || length % 8 ) { bad_len } nx_event = ntohs ( nfuh -> event ) ; if ( nx_event == NXFME_ABBREV ) { struct nx_flow_update_abbrev * nfua ; if ( length != sizeof nfua ) { bad_len } nfua = ofpbuf_pull ( msg , sizeof nfua ) ; update -> xid = nfua -> xid ; } if ( nx_event == NXFME_ADDED || nx_event == NXFME_DELETED || nx_event == NXFME_MODIFIED ) { struct nx_flow_update_full * nfuf ; unsigned int actions_len ; unsigned int match_len ; if ( length < sizeof nfuf ) { bad_len } nfuf = ofpbuf_pull ( msg , sizeof nfuf ) ; match_len = ntohs ( nfuf -> match_len ) ; if ( sizeof nfuf + match_len > length ) { bad_len } update -> reason = ntohs ( nfuf -> reason ) ; update -> idle_timeout = ntohs ( nfuf -> idle_timeout ) ; update -> hard_timeout = ntohs ( nfuf -> hard_timeout ) ; update -> table_id = nfuf -> table_id ; update -> cookie = nfuf -> cookie ; update -> priority = ntohs ( nfuf -> priority ) ; if ( raw == OFPRAW_ONFST13_FLOW_MONITOR_REPLY ) { uint16_t padded_match_len = 0 ; unsigned int instructions_len ; error = ofputil_pull_ofp11_match ( msg , NULL , NULL , & update -> match , & padded_match_len ) ; if ( error ) { return error ; } instructions_len = length - sizeof nfuf - padded_match_len ; error = ofpacts_pull_openflow_instructions ( msg , instructions_len , oh -> version , NULL , NULL , ofpacts ) ; if ( error ) { return error ; } } else { error = nx_pull_match ( msg , match_len , & update -> match , NULL , NULL , false , NULL , NULL ) ; if ( error ) { return error ; } actions_len = length - sizeof nfuf - ROUND_UP ( match_len , 8 ) ; error = ofpacts_pull_openflow_actions ( msg , actions_len , oh -> version , NULL , NULL , ofpacts ) ; if ( error ) { return error ; } } update -> ofpacts = ofpacts -> data ; update -> ofpacts_len = ofpacts -> size ; } else { VLOG_WARN_RL ( & rl , "NXST_FLOW_MONITOR reply has bad event %" PRIu16 , ntohs ( nfuh -> event ) ) ; return OFPERR_NXBRC_FM_BAD_EVENT ; } update -> event = nx_to_ofp_flow_update_event ( nx_event ) ; return 0 ; } case OFPRAW_OFPST14_FLOW_MONITOR_REPLY : { struct ofp_flow_update_header * ofuh ; uint16_t padded_match_len = 0 ; ofuh = msg -> data ; update -> event = ntohs ( ofuh -> event ) ; length = ntohs ( ofuh -> length ) ; if ( length > msg -> size || length % 8 ) { bad_len } if ( update -> event == OFPFME_ABBREV ) { struct ofp_flow_update_abbrev * ofua ; if ( length != sizeof ofua ) { bad_len } ofua = ofpbuf_pull ( msg , sizeof ofua ) ; update -> xid = ofua -> xid ; return 0 ; } if ( update -> event == OFPFME_PAUSED || update -> event == OFPFME_RESUMED ) { struct ofp_flow_update_paused * ofup ; if ( length != sizeof ofup ) { bad_len } ofup = ofpbuf_pull ( msg , sizeof ofup ) ; return 0 ; } if ( update -> event == OFPFME_INITIAL || update -> event == OFPFME_ADDED || update -> event == OFPFME_REMOVED || update -> event == OFPFME_MODIFIED ) { struct ofp_flow_update_full * ofuf ; unsigned int instructions_len ; if ( length < sizeof ofuf ) { bad_len } ofuf = ofpbuf_pull ( msg , sizeof ofuf ) ; if ( sizeof ofuf > length ) { bad_len } update -> reason = ofuf -> reason ; update -> idle_timeout = ntohs ( ofuf -> idle_timeout ) ; update -> hard_timeout = ntohs ( ofuf -> hard_timeout ) ; update -> table_id = ofuf -> table_id ; update -> cookie = ofuf -> cookie ; update -> priority = ntohs ( ofuf -> priority ) ; error = ofputil_pull_ofp11_match ( msg , NULL , NULL , & update -> match , & padded_match_len ) ; if ( error ) { return error ; } instructions_len = length - sizeof ofuf - padded_match_len ; error = ofpacts_pull_openflow_instructions ( msg , instructions_len , oh -> version , NULL , NULL , ofpacts ) ; if ( error ) { return error ; } update -> ofpacts = ofpacts -> data ; update -> ofpacts_len = ofpacts -> size ; return 0 ; } else { VLOG_WARN_RL ( & rl , "NXST_FLOW_MONITOR reply has bad event %" PRIu16 , ntohs ( ofuh -> event ) ) ; return OFPERR_NXBRC_FM_BAD_EVENT ; } } default : OVS_NOT_REACHED ( ) ; } bad_len VLOG_WARN_RL ( & rl , "%s has %" PRIu32 " leftover bytes at end" , ofpraw_get_name ( raw ) , msg -> size ) ; return OFPERR_OFPBRC_BAD_LEN ; } 