int lpfc_issue_els_prli ( struct lpfc_vport * vport , struct lpfc_nodelist * ndlp , uint8_t retry ) { struct Scsi_Host * shost = lpfc_shost_from_vport ( vport ) ; struct lpfc_hba * phba = vport -> phba ; PRLI * npr ; struct lpfc_nvme_prli * npr_nvme ; struct lpfc_iocbq * elsiocb ; uint8_t * pcmd ; uint16_t cmdsize ; u32 local_nlp_type , elscmd ; local_nlp_type = ndlp -> nlp_fc4_type ; send_next_prli if ( local_nlp_type & NLP_FC4_FCP ) { cmdsize = ( sizeof ( uint32_t ) + sizeof ( PRLI ) ) ; elscmd = ELS_CMD_PRLI ; } if ( local_nlp_type & NLP_FC4_NVME ) { cmdsize = ( sizeof ( uint32_t ) + sizeof ( lpfc_nvme_prli ) ) ; elscmd = ELS_CMD_NVMEPRLI ; } else { lpfc_printf_vlog ( vport , KERN_INFO , LOG_DISCOVERY , "3083 Unknown FC_TYPE x%x ndlp x%06x\n" , ndlp -> nlp_fc4_type , ndlp -> nlp_DID ) ; return 1 ; } elsiocb = lpfc_prep_els_iocb ( vport , 1 , cmdsize , retry , ndlp , ndlp -> nlp_DID , elscmd ) ; if ( ! elsiocb ) { return 1 ; } pcmd = ( uint8_t * ) ( ( ( lpfc_dmabuf * ) elsiocb -> context2 ) -> virt ) ; if ( local_nlp_type & NLP_FC4_FCP ) { * ( ( uint32_t * ) ( pcmd ) ) = ELS_CMD_PRLI ; pcmd += sizeof ( uint32_t ) ; npr = ( PRLI * ) pcmd ; if ( phba -> vpd . rev . feaLevelHigh >= 0x02 ) { npr -> ConfmComplAllowed = 1 ; npr -> Retry = 1 ; npr -> TaskRetryIdReq = 1 ; } npr -> estabImagePair = 1 ; npr -> readXferRdyDis = 1 ; if ( vport -> cfg_first_burst_size ) { npr -> writeXferRdyDis = 1 ; } npr -> prliType = PRLI_FCP_TYPE ; npr -> initiatorFunc = 1 ; elsiocb -> iocb_flag |= LPFC_PRLI_FCP_REQ ; local_nlp_type &= ~ NLP_FC4_FCP ; } if ( local_nlp_type & NLP_FC4_NVME ) { * ( ( uint32_t * ) ( pcmd ) ) = ELS_CMD_NVMEPRLI ; pcmd += sizeof ( uint32_t ) ; npr_nvme = ( lpfc_nvme_prli * ) pcmd ; bf_set ( prli_type_code , npr_nvme , PRLI_NVME_TYPE ) ; bf_set ( prli_estabImagePair , npr_nvme , 0 ) ; if ( ( phba -> cfg_nvme_enable_fb ) && ! phba -> nvmet_support ) { bf_set ( prli_fba , npr_nvme , 1 ) ; } if ( phba -> nvmet_support ) { bf_set ( prli_tgt , npr_nvme , 1 ) ; bf_set ( prli_disc , npr_nvme , 1 ) ; } else { bf_set ( prli_init , npr_nvme , 1 ) ; } npr_nvme -> word1 = cpu_to_be32 ( npr_nvme -> word1 ) ; npr_nvme -> word4 = cpu_to_be32 ( npr_nvme -> word4 ) ; elsiocb -> iocb_flag |= LPFC_PRLI_NVME_REQ ; local_nlp_type &= ~ NLP_FC4_NVME ; } lpfc_debugfs_disc_trc ( vport , LPFC_DISC_TRC_ELS_CMD , "Issue PRLI:      did:x%x" , ndlp -> nlp_DID , 0 , 0 ) ; phba -> fc_stat . elsXmitPRLI ++ ; elsiocb -> iocb_cmpl = lpfc_cmpl_els_prli ; spin_lock_irq ( shost -> host_lock ) ; ndlp -> nlp_flag |= NLP_PRLI_SND ; spin_unlock_irq ( shost -> host_lock ) ; if ( lpfc_sli_issue_iocb ( phba , LPFC_ELS_RING , elsiocb , 0 ) == IOCB_ERROR ) { spin_lock_irq ( shost -> host_lock ) ; ndlp -> nlp_flag &= ~ NLP_PRLI_SND ; spin_unlock_irq ( shost -> host_lock ) ; lpfc_els_free_iocb ( phba , elsiocb ) ; return 1 ; } vport -> fc_prli_sent ++ ; ndlp -> fc4_prli_sent ++ ; if ( local_nlp_type & ( NLP_FC4_FCP | NLP_FC4_NVME ) ) { send_next_prli } return 0 ; } 