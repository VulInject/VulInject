static void * _slurmctld_signal_hand ( void * no_data ) { int sig ; int i , rc ; int sig_array [ ] { SIGINT SIGTERM SIGHUP SIGABRT SIGUSR2 0 } ; ; sigset_t set ; slurmctld_lock_t conf_write_lock = { . conf = WRITE_LOCK } ; if ( prctl ( PR_SET_NAME , "sigmgr" , NULL , NULL , NULL ) < 0 ) { error ( "%s: cannot set my name to %s %m" , __func__ , "sigmgr" ) ; } ( void ) pthread_setcancelstate ( PTHREAD_CANCEL_ENABLE , NULL ) ; ( void ) pthread_setcanceltype ( PTHREAD_CANCEL_ASYNCHRONOUS , NULL ) ; for ( i = 0 ; sig_array [ i ] ; i ++ ) { _default_sigaction ( sig_array [ i ] ) ; } while ( 1 ) { xsignal_sigset_create ( sig_array , & set ) ; rc = sigwait ( & set , & sig ) ; switch ( sig ) { case SIGINT : case SIGTERM : info ( "Terminate signal (SIGINT or SIGTERM) received" ) ; slurmctld_config . shutdown_time = time ( NULL ) ; slurmctld_shutdown ( ) ; return NULL ; break ; case SIGHUP : info ( "Reconfigure signal (SIGHUP) received" ) ; _reconfigure_slurm ( ) ; break ; case SIGABRT : info ( "SIGABRT received" ) ; slurmctld_config . shutdown_time = time ( NULL ) ; slurmctld_shutdown ( ) ; dump_core = true ; return NULL ; case SIGUSR2 : info ( "Logrotate signal (SIGUSR2) received" ) ; lock_slurmctld ( conf_write_lock ) ; update_logging ( ) ; slurmscriptd_update_log_level ( slurm_conf . slurmctld_debug , true ) ; unlock_slurmctld ( conf_write_lock ) ; if ( jobcomp_g_set_location ( ) != SLURM_SUCCESS ) { error ( "%s: JobComp set location operation failed on SIGUSR2" , __func__ ) ; } break ; default : error ( "Invalid signal (%d) received" , sig ) ; } } } 