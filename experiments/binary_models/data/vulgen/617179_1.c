bit_to_n ( ) { return ( bit * 3 + 4 ) | 1 ; } static mp_limb_t id_to_n ( mp_limb_t id ) { return id * 3 + 1 + ( id & 1 ) ; } static mp_limb_t n_to_bit ( mp_limb_t n ) { return ( ( n - 5 ) | 1 ) / 3U ; } static mp_size_t primesieve_size ( mp_limb_t n ) { return n_to_bit ( n ) / GMP_LIMB_BITS + 1 ; } void mpz_primorial_ui ( mpz_ptr x , unsigned long n ) { ASSERT ( n <= GMP_NUMB_MAX ) ; if ( n < 5 ) { MPZ_NEWALLOC ( x , 1 ) [ 0 ] = ( 066211 >> ( n * 3 ) ) & 7 ; SIZ ( x ) = 1 ; } else { mp_limb_t * sieve , * factors ; mp_size_t size , j ; mp_limb_t prod ; TMP_DECL ; size = n / GMP_NUMB_BITS ; size = size + ( size >> 1 ) + 1 ; ASSERT ( size >= primesieve_size ( n ) ) ; sieve = MPZ_NEWALLOC ( x , size ) ; size = ( gmp_primesieve ( sieve , n ) + 1 ) / log_n_max ( n ) + 1 ; TMP_MARK ; factors = TMP_ALLOC_LIMBS ( size ) ; j = 0 ; prod = 6 ; { mp_limb_t max_prod ; max_prod = GMP_NUMB_MAX / n ; LOOP_ON_SIEVE_BEGIN ( prime , n_to_bit ( 5 ) , n_to_bit ( n ) , 0 , sieve ) ; FACTOR_LIST_STORE ( prime , prod , max_prod , factors , j ) ; LOOP_ON_SIEVE_END ; } if ( j != 0 ) { mpz_prodlimbs ( x , factors , j ) ; } else { PTR ( x ) [ 0 ] = prod ; SIZ ( x ) = 1 ; } TMP_FREE ; } } 