GC_INLINE LONG GC_get_max_thread_index ( void ) { LONG my_max = GC_max_thread_index ; return my_max ; } GC_INNER GC_thread GC_win32_dll_lookup_thread ( thread_id_t id ) { int i ; LONG my_max = GC_get_max_thread_index ( ) ; GC_ASSERT ( GC_win32_dll_threads ) ; for ( i = 0 ; i <= my_max ; i ++ ) { if ( AO_load_acquire ( & dll_thread_table [ i ] . tm . in_use ) && dll_thread_table [ i ] . id == id ) { break ; } } return i <= my_max ?( GC_thread ) ( dll_thread_table + i ) : NULL ; } thread_id_t GC_pthread_map_cache [ PTHREAD_MAP_SIZE ] { 0 } ; ; ( ( NUMERIC_THREAD_ID ( pthread_id ) >> 5 ) % PTHREAD_MAP_SIZE ) ( void ) ( GC_pthread_map_cache [ PTHREAD_MAP_INDEX ( pthread_id ) ] = ( win32_id ) ) GC_pthread_map_cache [ PTHREAD_MAP_INDEX ( pthread_id ) ] GC_INNER void GC_win32_cache_self_pthread ( ) { pthread_t self = pthread_self ( ) SET_PTHREAD_MAP_CACHE ( self , self_id ) } GC_INNER GC_thread GC_lookup_by_pthread ( ) { thread_id_t id = GET_PTHREAD_MAP_CACHE ( thread ) GC_thread p int hv GC_ASSERT ( I_HOLD_LOCK ( ) ) for ( p = GC_threads [ THREAD_TABLE_INDEX ( id ) ] ; p != NULL ; p = p -> tm . next ) { if ( THREAD_EQUAL ( p -> pthread_id , thread ) ) { return p ; } ; } } ; for ( hv = 0 ; hv < THREAD_TABLE_SZ ; ++ hv ) { for ( p = GC_threads [ hv ] ; p != NULL ; p = p -> tm . next ) { if ( THREAD_EQUAL ( p -> pthread_id , thread ) ) { return p ; } } } return NULL ; GC_bool isWow64 ; ? CONTEXT_INTEGER | CONTEXT_CONTROL | CONTEXT_EXCEPTION_REQUEST | CONTEXT_SEGMENTS : CONTEXT_INTEGER | CONTEXT_CONTROL ; STATIC void GC_suspend ( GC_thread t ) { DWORD exitCode ; int retry_cnt ; && ( ! defined ( MSWIN32 ) || defined ( CONSOLE_LOG ) ) GC_log_printf ( "Suspending 0x%x\n" , ( int ) t -> id ) ; GC_win32_unprotect_thread ( t ) ; GC_acquire_dirty_lock ( ) ; while ( SuspendThread ( THREAD_HANDLE ( t ) ) == ( DWORD ) - 1 ) { GC_release_dirty_lock ( ) ; Sleep ( 10 ) ; GC_acquire_dirty_lock ( ) ; } for ( retry_cnt = 0 ; ; ) { if ( GetExitCodeThread ( t -> handle , & exitCode ) && exitCode != STILL_ACTIVE ) { GC_release_dirty_lock ( ) ; t -> crtn -> stack_end = NULL ; GC_delete_thread ( t ) ; return ; } if ( SuspendThread ( t -> handle ) != ( DWORD ) - 1 ) { CONTEXT context ; context . ContextFlags = GET_THREAD_CONTEXT_FLAGS ; if ( GetThreadContext ( t -> handle , & context ) ) { t -> context_sp = copy_ptr_regs ( t -> context_regs , & context ) ; break ; } if ( ResumeThread ( t -> handle ) == ( DWORD ) - 1 ) { ABORT ( "ResumeThread failed in suspend loop" ) ; } } if ( retry_cnt > 1 ) { GC_release_dirty_lock ( ) ; Sleep ( 0 ) ; GC_acquire_dirty_lock ( ) ; } if ( ++ retry_cnt >= MAX_SUSPEND_THREAD_RETRIES ) { ABORT ( "SuspendThread loop failed" ) ; } } if ( GetExitCodeThread ( t -> handle , & exitCode ) && exitCode != STILL_ACTIVE ) { GC_release_dirty_lock ( ) ; t -> crtn -> stack_end = NULL ; GC_delete_thread ( t ) ; return ; } if ( SuspendThread ( t -> handle ) == ( DWORD ) - 1 ) { ABORT ( "SuspendThread failed" ) ; } t -> flags |= IS_SUSPENDED ; GC_release_dirty_lock ( ) ; if ( GC_on_thread_event ) { GC_on_thread_event ( GC_EVENT_THREAD_SUSPENDED , THREAD_HANDLE ( t ) ) ; } } 