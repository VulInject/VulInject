static int sdpfp_senduio ( sock_lower_handle_t handle , struct uio * uiop , struct nmsghdr * msg , struct cred * cred ) { struct sockaddr_ll * sol ; mac_client_handle_t mch ; struct pfpsock * ps ; boolean_t new_open ; mac_handle_t mh ; size_t mpsize ; uint_t maxsdu ; mblk_t * mp0 ; mblk_t * mp ; int error ; mp = NULL ; mp0 = NULL ; new_open = B_FALSE ; ps = ( pfpsock * ) handle ; mh = ps -> ps_mh ; mch = ps -> ps_mch ; maxsdu = ps -> ps_max_sdu ; sol = ( sockaddr_ll * ) msg -> msg_name ; if ( sol == NULL ) { if ( ! ps -> ps_bound ) { ks_stats . kp_send_unbound . value . ui64 ++ ; return ( EPROTO ) ; } sol = & ps -> ps_sock ; } else { struct sockaddr_ll * sll ; if ( msg -> msg_namelen < sizeof ( sockaddr_ll ) ) { ks_stats . kp_send_short_msg . value . ui64 ++ ; return ( EINVAL ) ; } if ( sol -> sll_family != AF_PACKET ) { ks_stats . kp_send_wrong_family . value . ui64 ++ ; return ( EAFNOSUPPORT ) ; } sll = & ps -> ps_sock ; if ( sol -> sll_ifindex != sll -> sll_ifindex ) { error = pfp_open_index ( sol -> sll_ifindex , & mh , & mch , cred ) ; if ( error != 0 ) { ks_stats . kp_send_open_fail . value . ui64 ++ ; return ( error ) ; } mac_sdu_get ( mh , NULL , & maxsdu ) ; new_open = B_TRUE ; } } mpsize = uiop -> uio_resid ; if ( mpsize > maxsdu ) { ks_stats . kp_send_too_big . value . ui64 ++ ; error = EMSGSIZE ; done } if ( ( mp = allocb ( mpsize , BPRI_HI ) ) == NULL ) { ks_stats . kp_send_alloc_fail . value . ui64 ++ ; error = ENOBUFS ; done } mp -> b_wptr = mp -> b_rptr + mpsize ; error = uiomove ( mp -> b_rptr , mpsize , UIO_WRITE , uiop ) ; if ( error != 0 ) { ks_stats . kp_send_uiomove_fail . value . ui64 ++ ; done } if ( ps -> ps_type == SOCK_DGRAM ) { mp0 = mac_header ( mh , sol -> sll_addr , sol -> sll_protocol , mp , 0 ) ; if ( mp0 == NULL ) { ks_stats . kp_send_no_memory . value . ui64 ++ ; error = ENOBUFS ; done } linkb ( mp0 , mp ) ; mp = mp0 ; } error = mac_tx ( mch , mp , 0 , MAC_DROP_ON_NO_DESC , NULL ) ; if ( error == 0 ) { mp = NULL ; ks_stats . kp_send_ok . value . ui64 ++ ; } else { ks_stats . kp_send_failed . value . ui64 ++ ; } done if ( new_open ) { ASSERT ( mch != ps -> ps_mch ) ; ASSERT ( mh != ps -> ps_mh ) ; pfp_close ( mh , mch ) ; } return ( error ) ; } 