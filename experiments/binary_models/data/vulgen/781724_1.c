static void waitForChild ( instanceData * pData , childProcessCtx_t * pChildCtx ) { int status ; int ret ; long counter ; counter = pData -> lCloseTimeout / 10 ; while ( ( ret = waitpid ( pChildCtx -> pid , & status , WNOHANG ) ) == 0 && counter > 0 ) { -- counter ; } if ( ret == 0 ) { if ( ! pData -> bKillUnresponsive ) { LogMsg ( 0 , NO_ERRCODE , LOG_WARNING , "omprog: program '%s' (pid %ld) did not terminate " "within timeout (%ld ms); ignoring it" , pData -> szBinary , ( long ) pChildCtx -> pid , pData -> lCloseTimeout ) ; return ; } LogMsg ( 0 , NO_ERRCODE , LOG_WARNING , "omprog: program '%s' (pid %ld) did not terminate " "within timeout (%ld ms); killing it" , pData -> szBinary , ( long ) pChildCtx -> pid , pData -> lCloseTimeout ) ; if ( kill ( pChildCtx -> pid , SIGKILL ) == - 1 ) { LogError ( errno , RS_RET_SYS_ERR , "omprog: could not send SIGKILL to child process" ) ; return ; } ret = waitpid ( pChildCtx -> pid , & status , 0 ) ; } if ( ret == pChildCtx -> pid ) { glblReportChildProcessExit ( runConf , pData -> szBinary , pChildCtx -> pid , status ) ; } } 