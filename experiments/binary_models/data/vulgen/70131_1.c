kms_request_new ( , , ) { kms_request_t * request = calloc ( 1 , sizeof ( kms_request_t ) ) ; const char * question_mark ; KMS_ASSERT ( request ) ; request -> failed = false ; request -> finalized = false ; request -> region = kms_request_str_new ( ) ; request -> service = kms_request_str_new ( ) ; request -> access_key_id = kms_request_str_new ( ) ; request -> secret_key = kms_request_str_new ( ) ; question_mark = strchr ( path_and_query , '?' ) ; if ( question_mark ) { request -> path = kms_request_str_new_from_chars ( path_and_query , question_mark - path_and_query ) ; request -> query = kms_request_str_new_from_chars ( question_mark + 1 , - 1 ) ; request -> query_params = parse_query_params ( request -> query ) ; if ( ! request -> query_params ) { KMS_ERROR ( request , "Cannot parse query: %s" , request -> query -> str ) ; } } else { request -> path = kms_request_str_new_from_chars ( path_and_query , - 1 ) ; request -> query = kms_request_str_new ( ) ; request -> query_params = kms_kv_list_new ( ) ; } request -> payload = kms_request_str_new ( ) ; request -> date = kms_request_str_new ( ) ; request -> datetime = kms_request_str_new ( ) ; request -> method = kms_request_str_new_from_chars ( method , - 1 ) ; request -> header_fields = kms_kv_list_new ( ) ; request -> auto_content_length = true ; if ( ! kms_request_set_date ( request , NULL ) ) { return request ; } if ( opt && opt -> crypto . sha256 ) { memcpy ( & request -> crypto , & opt -> crypto , sizeof ( opt -> crypto ) ) ; } else { request -> crypto . sha256 = kms_sha256 ; request -> crypto . sha256_hmac = kms_sha256_hmac ; } return request ; } 