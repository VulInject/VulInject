static nfsstat4 do_rfs4_op_getattr ( bitmap4 breq , fattr4 * fattrp , struct nfs4_svgetit_arg * sargp ) { int error = 0 ; int i , k ; struct nfs4_ntov_table ntov ; XDR xdr ; ulong_t xdr_size ; char * xdr_attrs ; nfsstat4 status = NFS4_OK ; nfsstat4 prev_rdattr_error = sargp -> rdattr_error ; union nfs4_attr_u * na ; uint8_t * amap ; sargp -> op = NFS4ATTR_GETIT ; sargp -> flag = 0 ; fattrp -> attrmask = 0 ; if ( breq == 0 ) { fattrp -> attrlist4 = NULL ; return ( NFS4_OK ) ; } if ( breq & ( FATTR4_TIME_ACCESS_SET_MASK | FATTR4_TIME_MODIFY_SET_MASK ) ) { return ( NFS4ERR_INVAL ) ; } nfs4_ntov_table_init ( & ntov ) ; na = ntov . na ; amap = ntov . amap ; for ( i = 0 ; i < nfs4_ntov_map_size ; i ++ ) { if ( breq & nfs4_ntov_map [ i ] . fbit ) { if ( ( * nfs4_ntov_map [ i ] . sv_getit ) ( NFS4ATTR_SUPPORTED , sargp , NULL ) == 0 ) { error = ( * nfs4_ntov_map [ i ] . sv_getit ) ( NFS4ATTR_GETIT , sargp , na ) ; if ( error && ! ( sargp -> rdattr_error_req ) ) { done } if ( error == 0 ) { fattrp -> attrmask |= nfs4_ntov_map [ i ] . fbit ; * amap ++ = ( uint8_t ) nfs4_ntov_map [ i ] . nval ; na ++ ; ( ntov . attrcnt ) ++ ; } if ( ( error > 0 ) && ( sargp -> rdattr_error == NFS4_OK ) ) { sargp -> rdattr_error = puterrno4 ( error ) ; } error = 0 ; } } } if ( prev_rdattr_error != sargp -> rdattr_error ) { na = ntov . na ; amap = ntov . amap ; for ( i = 0 ; i < ntov . attrcnt ; i ++ , na ++ , amap ++ ) { k = * amap ; if ( k < FATTR4_RDATTR_ERROR ) { continue ; } if ( ( k == FATTR4_RDATTR_ERROR ) && ( ( * nfs4_ntov_map [ k ] . sv_getit ) ( NFS4ATTR_SUPPORTED , sargp , NULL ) == 0 ) ) { ( void ) ( * nfs4_ntov_map [ k ] . sv_getit ) ( NFS4ATTR_GETIT , sargp , na ) ; } break ; } } xdr_size = 0 ; na = ntov . na ; amap = ntov . amap ; for ( i = 0 ; i < ntov . attrcnt ; i ++ , na ++ , amap ++ ) { xdr_size += xdr_sizeof ( nfs4_ntov_map [ * amap ] . xfunc , na ) ; } fattrp -> attrlist4_len = xdr_size ; if ( xdr_size ) { fattrp -> attrlist4 = xdr_attrs = kmem_zalloc ( xdr_size , KM_SLEEP ) ; xdrmem_create ( & xdr , xdr_attrs , xdr_size , XDR_ENCODE ) ; na = ntov . na ; amap = ntov . amap ; for ( i = 0 ; i < ntov . attrcnt ; i ++ , na ++ , amap ++ ) { if ( ! ( * nfs4_ntov_map [ * amap ] . xfunc ) ( & xdr , na ) ) { DTRACE_PROBE1 ( nfss__e__getattr4_encfail , int , * amap ) ; status = NFS4ERR_SERVERFAULT ; break ; } } } else { fattrp -> attrlist4 = NULL ; } done nfs4_ntov_table_free ( & ntov , sargp ) ; if ( error != 0 ) { status = puterrno4 ( error ) ; } return ( status ) ; } 