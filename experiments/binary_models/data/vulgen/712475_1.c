static void ar5523_tx_work_locked ( struct ar5523 * ar ) { struct ar5523_tx_data * data ; struct ar5523_tx_desc * desc ; struct ar5523_chunk * chunk ; struct ieee80211_tx_info * txi ; struct urb * urb ; struct sk_buff * skb ; int error = 0 , paylen ; u32 txqid ; unsigned long flags ; BUILD_BUG_ON ( sizeof ( ar5523_tx_data ) > IEEE80211_TX_INFO_DRIVER_DATA_SIZE ) ; ar5523_dbg ( ar , "%s\n" , __func__ ) ; { spin_lock_irqsave ( & ar -> tx_data_list_lock , flags ) ; if ( ! list_empty ( & ar -> tx_queue_pending ) ) { data = ( ar5523_tx_data * ) ar -> tx_queue_pending . next ; list_del ( & data -> list ) ; } else { data = NULL ; } spin_unlock_irqrestore ( & ar -> tx_data_list_lock , flags ) ; if ( ! data ) { break ; } txi = container_of ( ( void * ) data , ieee80211_tx_info , driver_data ) ; txqid = 0 ; skb = container_of ( ( void * ) txi , sk_buff , cb ) ; paylen = skb -> len ; urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! urb ) { continue ; } data -> ar = ar ; data -> urb = urb ; desc = skb_push ( skb , sizeof ( * desc ) ) ; chunk = skb_push ( skb , sizeof ( * chunk ) ) ; chunk -> seqnum = 0 ; chunk -> flags = UATH_CFLAGS_FINAL ; chunk -> length = cpu_to_be16 ( skb -> len ) ; desc -> msglen = cpu_to_be32 ( skb -> len ) ; desc -> msgid = AR5523_DATA_ID ; desc -> buflen = cpu_to_be32 ( paylen ) ; desc -> type = cpu_to_be32 ( WDCMSG_SEND ) ; desc -> flags = cpu_to_be32 ( UATH_TX_NOTIFY ) ; if ( test_bit ( AR5523_CONNECTED , & ar -> flags ) ) { desc -> connid = cpu_to_be32 ( AR5523_ID_BSS ) ; } else { desc -> connid = cpu_to_be32 ( AR5523_ID_BROADCAST ) ; } if ( txi -> flags & IEEE80211_TX_CTL_USE_MINRATE ) { txqid |= UATH_TXQID_MINRATE ; } desc -> txqid = cpu_to_be32 ( txqid ) ; urb -> transfer_flags = URB_ZERO_PACKET ; usb_fill_bulk_urb ( urb , ar -> dev , ar5523_data_tx_pipe ( ar -> dev ) , skb -> data , skb -> len , ar5523_data_tx_cb , skb ) ; spin_lock_irqsave ( & ar -> tx_data_list_lock , flags ) ; list_add_tail ( & data -> list , & ar -> tx_queue_submitted ) ; spin_unlock_irqrestore ( & ar -> tx_data_list_lock , flags ) ; mod_timer ( & ar -> tx_wd_timer , jiffies + AR5523_TX_WD_TIMEOUT ) ; atomic_inc ( & ar -> tx_nr_pending ) ; ar5523_dbg ( ar , "TX Frame (%d pending)\n" , atomic_read ( & ar -> tx_nr_pending ) ) ; error = usb_submit_urb ( urb , GFP_KERNEL ) ; if ( error ) { ar5523_err ( ar , "error %d when submitting tx urb\n" , error ) ; spin_lock_irqsave ( & ar -> tx_data_list_lock , flags ) ; list_del ( & data -> list ) ; spin_unlock_irqrestore ( & ar -> tx_data_list_lock , flags ) ; atomic_dec ( & ar -> tx_nr_pending ) ; ar5523_data_tx_pkt_put ( ar ) ; usb_free_urb ( urb ) ; ieee80211_free_txskb ( ar -> hw , skb ) ; } } true ; } 