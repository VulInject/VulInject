do_friend ( , , , , , , , ) tree ctype , declarator , decl , parmdecls , attrlist ; enum overload_flags flags ; tree quals ; int funcdef_flag ; { int is_friend_template = 0 ; if ( TREE_CODE ( declarator ) == TEMPLATE_ID_EXPR ) { declarator = TREE_OPERAND ( declarator , 0 ) ; if ( TREE_CODE ( declarator ) == LOOKUP_EXPR ) { declarator = TREE_OPERAND ( declarator , 0 ) ; } if ( is_overloaded_fn ( declarator ) ) { declarator = DECL_NAME ( get_first_fn ( declarator ) ) ; } } if ( TREE_CODE ( decl ) != FUNCTION_DECL ) { abort ( ) ; } is_friend_template = PROCESSING_REAL_TEMPLATE_DECL_P ( ) ; if ( ctype ) { tree cname = TYPE_NAME ( ctype ) ; if ( TREE_CODE ( cname ) == TYPE_DECL ) { cname = DECL_NAME ( cname ) ; } if ( flags == NO_SPECIAL && ctype && declarator == cname ) { DECL_CONSTRUCTOR_P ( decl ) = 1 ; } grokclassfn ( ctype , decl , flags , quals ) ; if ( is_friend_template ) { decl = DECL_TI_TEMPLATE ( push_template_decl ( decl ) ) ; } if ( DECL_TEMPLATE_INFO ( decl ) ) { } if ( template_class_depth ( current_class_type ) ) { decl = push_template_decl_real ( decl , 1 ) ; } if ( processing_template_decl ) { add_friend ( current_class_type , decl ) ; } if ( COMPLETE_TYPE_P ( ctype ) || TYPE_BEING_DEFINED ( ctype ) ) { decl = check_classfn ( ctype , decl ) ; if ( decl ) { add_friend ( current_class_type , decl ) ; } } else { error ( "member `%D' declared as friend before type `%T' defined" , decl , ctype ) ; } } if ( TREE_CODE ( decl ) == FUNCTION_DECL ) { DECL_ARGUMENTS ( decl ) = parmdecls ; if ( funcdef_flag ) { SET_DECL_FRIEND_CONTEXT ( decl , current_class_type ) ; } if ( ! DECL_USE_TEMPLATE ( decl ) ) { int warn = ( warn_nontemplate_friend && ! funcdef_flag && ! is_friend_template && current_template_parms && uses_template_parms ( decl ) ) ; if ( is_friend_template || template_class_depth ( current_class_type ) != 0 ) { decl = push_template_decl_real ( decl , 1 ) ; } if ( current_function_decl ) { decl = pushdecl ( decl ) ; } else { tree ns = decl_namespace_context ( decl ) ; push_nested_namespace ( ns ) ; decl = pushdecl_namespace_level ( decl ) ; pop_nested_namespace ( ns ) ; } if ( warn ) { static int explained ; warning ( "friend declaration `%#D' declares a non-template function" , decl ) ; if ( ! explained ) { warning ( "(if this is not what you intended, make sure the function template has already been declared and add<>after the function name here) -Wno-non-template-friend disables this warning" ) ; explained = 1 ; } } } add_friend ( current_class_type , is_friend_template ?DECL_TI_TEMPLATE ( decl ) : decl ) ; DECL_FRIEND_P ( decl ) = 1 ; } cplus_decl_attributes ( & decl , attrlist , 0 ) ; return decl ; } 