GF_Err gf_isom_remove_meta_item ( GF_ISOFile * file , Bool root_meta , u32 track_num , u32 item_id , Bool keep_refs , const char * keep_props ) { GF_ItemInfoEntryBox * iinf ; u32 i , count ; GF_MetaBox * meta = gf_isom_get_meta ( file , root_meta , track_num ) ; u32 item_num ; if ( ! meta || ! meta -> item_infos || ! meta -> item_locations ) { return GF_BAD_PARAM ; } item_num = gf_isom_get_meta_item_by_id ( file , root_meta , track_num , item_id ) ; if ( ! item_num ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "Error: No item with ID %d in file, cannnot remove\n" ) ) ; return GF_NOT_FOUND ; } iinf = ( GF_ItemInfoEntryBox * ) gf_list_get ( meta -> item_infos -> item_infos , item_num - 1 ) ; gf_list_rem ( meta -> item_infos -> item_infos , item_num - 1 ) ; count = gf_list_count ( meta -> item_locations -> location_entries ) ; for ( i = 0 ; i < count ; i ++ ) { GF_ItemLocationEntry * iloc = ( GF_ItemLocationEntry * ) gf_list_get ( meta -> item_locations -> location_entries , i ) ; if ( iloc -> item_ID == iinf -> item_ID ) { gf_list_rem ( meta -> item_locations -> location_entries , i ) ; iloc_entry_del ( iloc ) ; break ; } } if ( meta -> item_props && meta -> item_props -> property_association ) { Bool cleanup_associations = GF_FALSE ; GF_ItemPropertyAssociationBox * ipma = meta -> item_props -> property_association ; count = gf_list_count ( ipma -> entries ) ; for ( i = 0 ; i < count ; i ++ ) { GF_ItemPropertyAssociationEntry * pa_ent = gf_list_get ( ipma -> entries , i ) ; if ( pa_ent -> item_id == iinf -> item_ID ) { meta_cleanup_item_association ( meta , pa_ent , keep_props ) ; if ( ! pa_ent -> nb_associations ) { gf_free ( pa_ent -> associations ) ; gf_free ( pa_ent ) ; gf_list_rem ( ipma -> entries , i ) ; } cleanup_associations = GF_TRUE ; break ; } } if ( cleanup_associations ) { meta_cleanup_associations ( meta ) ; } } if ( ! keep_refs && meta -> item_refs ) { count = gf_list_count ( meta -> item_refs -> references ) ; for ( i = 0 ; i < count ; i ++ ) { GF_ItemReferenceTypeBox * iref = gf_list_get ( meta -> item_refs -> references , i ) ; Bool do_delete = GF_FALSE ; if ( iref -> from_item_id == item_id ) { do_delete = GF_FALSE ; } else { u32 k ; for ( k = 0 ; k < iref -> reference_count ; k ++ ) { if ( iref -> to_item_IDs [ k ] != item_id ) { continue ; } if ( k + 1 < iref -> reference_count ) { memmove ( & iref -> to_item_IDs [ k ] , & iref -> to_item_IDs [ k + 1 ] , sizeof ( u32 ) * ( iref -> reference_count - k - 1 ) ) ; } iref -> reference_count -- ; k -- ; } if ( ! iref -> reference_count ) { do_delete = GF_TRUE ; } } if ( do_delete ) { gf_isom_box_del_parent ( & meta -> item_refs -> child_boxes , ( GF_Box * ) iref ) ; gf_list_rem ( meta -> item_refs -> references , i ) ; i -- ; count -- ; } } } if ( meta -> use_item_item_sharing ) { u32 new_ref_id = 0 ; count = gf_list_count ( meta -> item_infos -> item_infos ) ; for ( i = 0 ; i < count ; i ++ ) { GF_ItemInfoEntryBox * iinf2 = ( GF_ItemInfoEntryBox * ) gf_list_get ( meta -> item_infos -> item_infos , i ) ; if ( iinf2 -> ref_it_id != iinf -> item_ID ) { continue ; } if ( new_ref_id ) { iinf2 -> ref_it_id = new_ref_id ; } else { new_ref_id = iinf2 -> item_ID ; iinf2 -> ref_it_id = 0 ; if ( iinf -> tk_id ) { iinf2 -> tk_id = iinf -> tk_id ; iinf2 -> sample_num = iinf -> sample_num ; iinf2 -> data_len = iinf -> data_len ; } } } } gf_isom_box_del_parent ( & meta -> item_infos -> child_boxes , ( GF_Box * ) iinf ) ; return GF_OK ; } 