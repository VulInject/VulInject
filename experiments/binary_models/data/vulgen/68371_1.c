32 bit ints ; , into the ongoing bit hash value ( five 32 bit ints ) * int sha_hash ( int * data , int * hash ) ( int W [ 80 ] , unsigned int A = hash [ 0 ] , B = hash [ 1 ] , C = hash [ 2 ] , D = hash [ 3 ] , E = hash [ 4 ] , unsigned int t , x , TEMP , ( t = 0 t < 16 t ++ ) { W [ t ] = switch_endianness ( data [ t ] ) W [ t ] = data [ t ] } for ( t = 16 ; t < 80 ; t ++ ) { x = W [ t - 3 ] ^ W [ t - 8 ] ^ W [ t - 14 ] ^ W [ t - 16 ] W [ t ] = rol1 ( x ) } ; ) ; for ( t = 0 ; t < 20 ; t ++ ) { TEMP = rol5 ( A ) + f1 ( B , C , D ) + E + W [ t ] + K1 ; E = D ; D = C ; C = rol30 ( B ) ; B = A ; A = TEMP ; } for ( ; t < 40 ; t ++ ) { TEMP = rol5 ( A ) + f2 ( B , C , D ) + E + W [ t ] + K2 ; E = D ; D = C ; C = rol30 ( B ) ; B = A ; A = TEMP ; } for ( ; t < 60 ; t ++ ) { TEMP = rol5 ( A ) + f3 ( B , C , D ) + E + W [ t ] + K3 ; E = D ; D = C ; C = rol30 ( B ) ; B = A ; A = TEMP ; } for ( ; t < 80 ; t ++ ) { TEMP = rol5 ( A ) + f2 ( B , C , D ) + E + W [ t ] + K4 ; E = D ; D = C ; C = rol30 ( B ) ; B = A ; A = TEMP ; } hash [ 0 ] += A ; hash [ 1 ] += B ; hash [ 2 ] += C ; hash [ 3 ] += D ; return 0 ; 