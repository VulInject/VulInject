int test_secret_encrypt_decrypt ( test_cert_t * o , token_info_t * info , test_mech_t * mech , CK_ULONG message_length , int multipart ) { CK_BYTE * message = NULL ; CK_BYTE * dec_message = NULL ; CK_BYTE iv [ ] { 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f } ; ; CK_AES_CTR_PARAMS ctr_params = { 64 { 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 } } ; CK_BYTE aad [ ] { 0x00 0x02 0x04 0x08 0x10 0x20 0x40 0x80 } ; ; CK_GCM_PARAMS gcm_params = { . pIv = ( void * ) iv . ulIvLen = 16 . ulIvBits = 64 . pAAD = aad . ulAADLen = sizeof ( aad ) . ulTagBits = 128 } ; int dec_message_length = 0 ; int enc_message_length , rv ; if ( o -> private_handle == CK_INVALID_HANDLE ) { debug_print ( " [SKIP %s ] Missing secret key" , o -> id_str ) ; return 0 ; } if ( o -> key_type != CKK_AES ) { debug_print ( " [ KEY %s ] Skip non-AES key for encryption" , o -> id_str ) ; return 0 ; } mech -> params = & iv ; mech -> params_len = sizeof ( iv ) ; if ( mech -> mech == CKM_AES_CBC || mech -> mech == CKM_AES_ECB ) { message = pkcs7_pad_message ( short_message , message_length , 16 , & message_length ) ; } if ( mech -> mech == CKM_AES_CBC_PAD || mech -> mech == CKM_AES_CTS ) { message = ( CK_BYTE * ) strndup ( MESSAGE_TO_SIGN , message_length ) ; } if ( mech -> mech == CKM_AES_CTR ) { mech -> params = & ctr_params ; mech -> params_len = sizeof ( ctr_params ) ; message = ( CK_BYTE * ) strndup ( MESSAGE_TO_SIGN , message_length ) ; } if ( mech -> mech == CKM_AES_GCM ) { mech -> params = & gcm_params ; mech -> params_len = sizeof ( gcm_params ) ; message = ( CK_BYTE * ) strndup ( MESSAGE_TO_SIGN , message_length ) ; } else { debug_print ( " [SKIP %s ] Unknown mechanism" , o -> id_str ) ; return 0 ; } debug_print ( " [ KEY %s ] Encrypt message using CKM_%s" , o -> id_str , get_mechanism_name ( mech -> mech ) ) ; enc_message_length = encrypt_message ( o , info , message , message_length , mech , & enc_message ) ; if ( enc_message_length <= 0 ) { mech -> params = NULL ; mech -> params_len = 0 ; free ( enc_message ) ; free ( message ) ; return - 1 ; } debug_print ( " [ KEY %s ] Decrypt message" , o -> id_str ) ; dec_message_length = decrypt_message ( o , info , enc_message , enc_message_length , mech , & dec_message ) ; free ( enc_message ) ; if ( dec_message_length <= 0 ) { mech -> params = NULL ; mech -> params_len = 0 ; free ( message ) ; return - 1 ; } if ( memcmp ( dec_message , message , dec_message_length ) == 0 && ( unsigned int ) dec_message_length == message_length ) { debug_print ( " [  OK %s ] Text decrypted successfully." , o -> id_str ) ; mech -> result_flags |= FLAGS_DECRYPT ; rv = 1 ; } else { dec_message [ dec_message_length ] = '\0' ; debug_print ( " [ ERROR %s ] Text decryption failed. Recovered text: %s" , o -> id_str , dec_message ) ; rv = 0 ; } mech -> params = NULL ; mech -> params_len = 0 ; free ( dec_message ) ; free ( message ) ; return rv ; } 