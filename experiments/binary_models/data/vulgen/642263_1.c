static void parsegvar ( struct ttfinfo * info , FILE * ttf ) { int axiscount , globaltc , gvarflags , gc , i , j , g ; uint32_t tupoff , dataoff , * gvars ; struct variations * v = info -> variations ; int warned = false ; fseek ( ttf , info -> gvar_start , SEEK_SET ) ; if ( getlong ( ttf ) != 0x00010000 ) { return ; } axiscount = getushort ( ttf ) ; if ( axiscount != info -> variations -> axis_count ) { LogError ( _ ( "Hmm, the axis count in the 'gvar' table is different from that in the 'fvar' table.\n" ) ) ; VariationFree ( info ) ; return ; } globaltc = getushort ( ttf ) ; tupoff = getlong ( ttf ) + info -> gvar_start ; gc = getushort ( ttf ) ; gvarflags = getushort ( ttf ) ; dataoff = getlong ( ttf ) + info -> gvar_start ; if ( globaltc == 0 || globaltc > AppleMmMax ) { if ( globaltc == 0 ) { LogError ( _ ( "Hmm, no global tuples specified in the 'gvar' table.\n" ) ) ; } else { LogError ( _ ( "Hmm, too many global tuples specified in the 'gvar' table.\n FontForge only supports %d\n" ) , AppleMmMax ) ; } VariationFree ( info ) ; return ; } if ( gc > info -> glyph_cnt ) { LogError ( _ ( "Hmm, more glyph variation data specified than there are glyphs in font.\n" ) ) ; VariationFree ( info ) ; return ; } gvars = malloc ( ( gc + 1 ) * sizeof ( uint32_t ) ) ; if ( gvarflags & 1 ) { for ( i = 0 ; i <= gc ; ++ i ) { gvars [ i ] = getlong ( ttf ) + dataoff ; } } else { for ( i = 0 ; i <= gc ; ++ i ) { gvars [ i ] = getushort ( ttf ) * 2 + dataoff ; } } v -> tuple_count = globaltc ; v -> tuples = calloc ( globaltc , sizeof ( tuples ) ) ; fseek ( ttf , tupoff , SEEK_SET ) ; for ( i = 0 ; i < globaltc ; ++ i ) { v -> tuples [ i ] . coords = malloc ( axiscount * sizeof ( float ) ) ; for ( j = 0 ; j < axiscount ; ++ j ) { v -> tuples [ i ] . coords [ j ] = ( ( short ) getushort ( ttf ) ) / 16384.0 ; } v -> tuples [ i ] . chars = InfoCopyGlyphs ( info ) ; } for ( g = 0 ; g < gc ; ++ g ) { if ( gvars [ g ] != gvars [ g + 1 ] ) { int tc ; uint32_t datoff ; int * sharedpoints = NULL ; fseek ( ttf , gvars [ g ] , SEEK_SET ) ; tc = getushort ( ttf ) ; datoff = gvars [ g ] + getushort ( ttf ) ; if ( tc & 0x8000 ) { uint32_t here = ftell ( ttf ) ; fseek ( ttf , datoff , SEEK_SET ) ; sharedpoints = readpackedpoints ( ttf ) ; datoff = ftell ( ttf ) ; fseek ( ttf , here , SEEK_SET ) ; } for ( i = 0 ; i < ( tc & 0xfff ) ; ++ i ) { int tupleDataSize , tupleIndex ; tupleDataSize = getushort ( ttf ) ; tupleIndex = getushort ( ttf ) ; if ( tupleIndex & 0xc000 ) { if ( ! warned ) { LogError ( _ ( "Warning: Glyph %d contains either private or intermediate tuple data.\n FontForge supports neither.\n" ) , g ) ; } warned = true ; if ( tupleIndex & 0x8000 ) { fseek ( ttf , 2 * axiscount , SEEK_CUR ) ; } if ( tupleIndex & 0x4000 ) { fseek ( ttf , 4 * axiscount , SEEK_CUR ) ; } } else { int * localpoints = NULL ; uint32_t here = ftell ( ttf ) ; fseek ( ttf , datoff , SEEK_SET ) ; if ( tupleIndex & 0x2000 ) { localpoints = readpackedpoints ( ttf ) ; } VaryGlyphs ( info , tupleIndex & 0xfff , g , ( tupleIndex & 0x2000 ) ?localpoints : sharedpoints , ttf ) ; free ( localpoints ) ; fseek ( ttf , here , SEEK_SET ) ; } datoff += tupleDataSize ; } free ( sharedpoints ) ; } } free ( gvars ) ; } 