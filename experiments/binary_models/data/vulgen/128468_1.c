static void br2684_push ( struct atm_vcc * atmvcc , struct sk_buff * skb ) { struct br2684_vcc * brvcc = BR2684_VCC ( atmvcc ) ; struct net_device * net_dev = brvcc -> device ; struct br2684_dev * brdev = BRPRIV ( net_dev ) ; pr_debug ( "\n" ) ; if ( unlikely ( skb == NULL ) ) { br2684_close_vcc ( brvcc ) ; if ( list_empty ( & brdev -> brvccs ) ) { write_lock_irq ( & devs_lock ) ; list_del ( & brdev -> br2684_devs ) ; write_unlock_irq ( & devs_lock ) ; unregister_netdev ( net_dev ) ; } return ; } skb_debug ( skb ) ; atm_return ( atmvcc , skb -> truesize ) ; pr_debug ( "skb from brdev %p\n" , brdev ) ; if ( brvcc -> encaps == e_llc ) { if ( skb -> len > 7 && skb -> data [ 7 ] == 0x01 ) { __skb_trim ( skb , skb -> len - 4 ) ; } if ( ( skb -> len >= ( sizeof ( llc_oui_ipv4 ) ) ) && ( memcmp ( skb -> data , llc_oui_ipv4 , sizeof ( llc_oui_ipv4 ) - BR2684_ETHERTYPE_LEN ) == 0 ) ) { if ( memcmp ( skb -> data + 6 , ethertype_ipv6 , sizeof ( ethertype_ipv6 ) ) == 0 ) { skb -> protocol = htons ( ETH_P_IPV6 ) ; } if ( memcmp ( skb -> data + 6 , ethertype_ipv4 , sizeof ( ethertype_ipv4 ) ) == 0 ) { skb -> protocol = htons ( ETH_P_IP ) ; } else { error } skb_pull ( skb , sizeof ( llc_oui_ipv4 ) ) ; skb_reset_network_header ( skb ) ; skb -> pkt_type = PACKET_HOST ; } if ( ( skb -> len >= sizeof ( llc_oui_pid_pad ) ) && ( memcmp ( skb -> data , llc_oui_pid_pad , 7 ) == 0 ) ) { skb_pull ( skb , sizeof ( llc_oui_pid_pad ) ) ; skb -> protocol = eth_type_trans ( skb , net_dev ) ; } else { error } } else { if ( brdev -> payload == p_routed ) { struct iphdr * iph ; skb_reset_network_header ( skb ) ; iph = ip_hdr ( skb ) ; if ( iph -> version == 4 ) { skb -> protocol = htons ( ETH_P_IP ) ; } if ( iph -> version == 6 ) { skb -> protocol = htons ( ETH_P_IPV6 ) ; } else { error } skb -> pkt_type = PACKET_HOST ; } else { if ( memcmp ( skb -> data , pad , BR2684_PAD_LEN ) != 0 ) { error } skb_pull ( skb , BR2684_PAD_LEN ) ; skb -> protocol = eth_type_trans ( skb , net_dev ) ; } } if ( unlikely ( packet_fails_filter ( skb -> protocol , brvcc , skb ) ) ) { dropped } skb -> dev = net_dev ; ATM_SKB ( skb ) -> vcc = atmvcc ; pr_debug ( "received packet's protocol: %x\n" , ntohs ( skb -> protocol ) ) ; skb_debug ( skb ) ; if ( unlikely ( ! ( net_dev -> flags & IFF_UP ) ) ) { dropped } net_dev -> stats . rx_packets ++ ; net_dev -> stats . rx_bytes += skb -> len ; memset ( ATM_SKB ( skb ) , 0 , sizeof ( atm_skb_data ) ) ; netif_rx ( skb ) ; return ; dropped net_dev -> stats . rx_dropped ++ ; free_skb error net_dev -> stats . rx_errors ++ ; free_skb dev_kfree_skb ( skb ) ; } 