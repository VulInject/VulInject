static int config_read_branches ( const char * key , const char * value , void * data UNUSED ) { const char * orig_key = key ; char * name ; struct string_list_item * item ; struct branch_info * info ; { REMOTE , MERGE , REBASE , PUSH_REMOTE } , type size_t key_len ; key += strlen ( "branch." ) ; if ( strip_suffix ( key , ".remote" , & key_len ) ) { type = REMOTE ; } if ( strip_suffix ( key , ".merge" , & key_len ) ) { type = MERGE ; } if ( strip_suffix ( key , ".rebase" , & key_len ) ) { type = REBASE ; } if ( strip_suffix ( key , ".pushremote" , & key_len ) ) { type = PUSH_REMOTE ; } else { return 0 ; } name = xmemdupz ( key , key_len ) ; item = string_list_insert ( & branch_list , name ) ; if ( ! item -> util ) { item -> util = xcalloc ( 1 , sizeof ( branch_info ) ) ; } info = item -> util ; switch ( type ) { case REMOTE : if ( info -> remote_name ) { warning ( _ ( "more than one %s" ) , orig_key ) ; } info -> remote_name = xstrdup ( value ) ; break ; case MERGE : { char * space = strchr ( value , ' ' ) ; value = abbrev_branch ( value ) ; while ( space ) { char * merge ; merge = xstrndup ( value , space - value ) ; string_list_append ( & info -> merge , merge ) ; value = abbrev_branch ( space + 1 ) ; space = strchr ( value , ' ' ) ; } string_list_append ( & info -> merge , xstrdup ( value ) ) ; break ; } case REBASE : info -> rebase = rebase_parse_value ( value ) ; if ( info -> rebase == REBASE_INVALID ) { warning ( _ ( "unhandled branch.%s.rebase=%s; assuming " "'true'" ) , name , value ) ; } break ; case PUSH_REMOTE : if ( info -> push_remote_name ) { warning ( _ ( "more than one %s" ) , orig_key ) ; } info -> push_remote_name = xstrdup ( value ) ; break ; default : BUG ( "unexpected type=%d" , type ) ; } return 0 ; } 