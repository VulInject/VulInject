int zpool_label_disk ( libzfs_handle_t * hdl , zpool_handle_t * zhp , const char * name , zpool_boot_label_t boot_type , uint64_t boot_size , int * slice ) { char path [ MAXPATHLEN ] ; struct dk_gpt * vtoc ; int fd ; size_t resv ; uint64_t slice_size ; diskaddr_t start_block ; char errbuf [ 1024 ] ; ( void ) snprintf ( errbuf , sizeof ( errbuf ) , dgettext ( TEXT_DOMAIN , "cannot label '%s'" ) , name ) ; if ( zhp ) { nvlist_t * nvroot ; verify ( nvlist_lookup_nvlist ( zhp -> zpool_config , ZPOOL_CONFIG_VDEV_TREE , & nvroot ) == 0 ) ; if ( zhp -> zpool_start_block == 0 ) { start_block = find_start_block ( nvroot ) ; } else { start_block = zhp -> zpool_start_block ; } zhp -> zpool_start_block = start_block ; } else { start_block = NEW_START_BLOCK ; } if ( ( fd = open ( path , O_RDWR | O_NDELAY ) ) < 0 ) { zfs_error_aux ( hdl , dgettext ( TEXT_DOMAIN , "unable to open device" ) ) ; return ( zfs_error ( hdl , EZFS_OPENFAILED , errbuf ) ) ; } if ( efi_alloc_and_init ( fd , EFI_NUMPAR , & vtoc ) != 0 ) { if ( errno == ENOMEM ) { ( void ) no_memory ( hdl ) ; } ( void ) close ( fd ) ; zfs_error_aux ( hdl , dgettext ( TEXT_DOMAIN , "unable to read disk capacity" ) , name ) ; return ( zfs_error ( hdl , EZFS_NOCAP , errbuf ) ) ; } resv = efi_reserved_sectors ( vtoc ) ; if ( start_block == MAXOFFSET_T ) { start_block = NEW_START_BLOCK ; } if ( boot_type == ZPOOL_CREATE_BOOT_LABEL ) { if ( boot_size % vtoc -> efi_lbasize != 0 ) { zfs_error_aux ( hdl , dgettext ( TEXT_DOMAIN , "boot partition size must be a multiple of %d" ) , vtoc -> efi_lbasize ) ; ( void ) close ( fd ) ; efi_free ( vtoc ) ; return ( zfs_error ( hdl , EZFS_LABELFAILED , errbuf ) ) ; } if ( boot_size < 1024 * 1024 ) { char buf [ 64 ] ; zfs_nicenum ( boot_size , buf , sizeof ( buf ) ) ; zfs_error_aux ( hdl , dgettext ( TEXT_DOMAIN , "Specified size %s for EFI System partition is too " "small, the minimum size is 1MB." ) , buf ) ; ( void ) close ( fd ) ; efi_free ( vtoc ) ; return ( zfs_error ( hdl , EZFS_LABELFAILED , errbuf ) ) ; } if ( hdl -> libzfs_printerr && ( ( vtoc -> efi_lbasize == 512 && boot_size < 33 * 1024 * 1024 ) || ( vtoc -> efi_lbasize == 4096 && boot_size < 256 * 1024 * 1024 ) ) ) { char buf [ 64 ] ; zfs_nicenum ( boot_size , buf , sizeof ( buf ) ) ; ( void ) fprintf ( stderr , dgettext ( TEXT_DOMAIN , "Warning: EFI System partition size %s is " "not allowing to create FAT32 file\nsystem, which " "may result in unbootable system.\n" ) , buf ) ; } start_block += boot_size / vtoc -> efi_lbasize ; } if ( start_block == NEW_START_BLOCK ) { slice_size = vtoc -> efi_last_u_lba + 1 ; slice_size -= resv ; slice_size -= start_block ; if ( slice != NULL ) { * slice = 0 ; } vtoc -> efi_parts [ 0 ] . p_start = start_block ; vtoc -> efi_parts [ 0 ] . p_size = slice_size ; vtoc -> efi_parts [ 0 ] . p_tag = V_USR ; ( void ) strcpy ( vtoc -> efi_parts [ 0 ] . p_name , "zfs" ) ; vtoc -> efi_parts [ 8 ] . p_start = slice_size + start_block ; vtoc -> efi_parts [ 8 ] . p_size = resv ; vtoc -> efi_parts [ 8 ] . p_tag = V_RESERVED ; } else { slice_size = start_block - NEW_START_BLOCK ; vtoc -> efi_parts [ 0 ] . p_start = NEW_START_BLOCK ; vtoc -> efi_parts [ 0 ] . p_size = slice_size ; vtoc -> efi_parts [ 0 ] . p_tag = V_SYSTEM ; ( void ) strcpy ( vtoc -> efi_parts [ 0 ] . p_name , "loader" ) ; if ( slice != NULL ) { * slice = 1 ; } slice_size = vtoc -> efi_last_u_lba + 1 - slice_size ; slice_size -= resv ; slice_size -= NEW_START_BLOCK ; vtoc -> efi_parts [ 1 ] . p_start = start_block ; vtoc -> efi_parts [ 1 ] . p_size = slice_size ; vtoc -> efi_parts [ 1 ] . p_tag = V_USR ; ( void ) strcpy ( vtoc -> efi_parts [ 1 ] . p_name , "zfs" ) ; vtoc -> efi_parts [ 8 ] . p_start = slice_size + start_block ; vtoc -> efi_parts [ 8 ] . p_size = resv ; vtoc -> efi_parts [ 8 ] . p_tag = V_RESERVED ; } if ( efi_write ( fd , vtoc ) != 0 ) { ( void ) close ( fd ) ; efi_free ( vtoc ) ; zfs_error_aux ( hdl , dgettext ( TEXT_DOMAIN , "try using fdisk(8) and then provide a specific slice" ) ) ; return ( zfs_error ( hdl , EZFS_LABELFAILED , errbuf ) ) ; } ( void ) close ( fd ) ; efi_free ( vtoc ) ; return ( 0 ) ; } 