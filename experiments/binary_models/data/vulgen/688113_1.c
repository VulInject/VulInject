static void match_comparison ( struct expression * expr ) { struct expression * left_orig = strip_parens ( expr -> left ) ; struct expression * right_orig = strip_parens ( expr -> right ) ; struct expression * left , * right , * tmp ; struct expression * prev ; struct symbol * type ; int redo , count ; if ( match_func_comparison ( expr ) ) { return ; } type = get_type ( expr ) ; if ( handle_integer_overflow_test ( expr ) ) { return ; } left = left_orig ; right = right_orig ; move_known_values ( & left , & right ) ; handle_comparison ( type , left , expr -> op , right ) ; left = left_orig ; right = right_orig ; if ( do_simple_algebra ( & left , & right ) ) { handle_comparison ( type , left , expr -> op , right ) ; } prev = get_assigned_expr ( left_orig ) ; if ( is_simple_math ( prev ) && has_variable ( prev , left_orig ) == 0 ) { left = prev ; right = right_orig ; move_known_values ( & left , & right ) ; handle_comparison ( type , left , expr -> op , right ) ; } prev = get_assigned_expr ( right_orig ) ; if ( is_simple_math ( prev ) && has_variable ( prev , right_orig ) == 0 ) { left = left_orig ; right = prev ; move_known_values ( & left , & right ) ; handle_comparison ( type , left , expr -> op , right ) ; } redo = 0 ; left = left_orig ; right = right_orig ; if ( get_last_expr_from_expression_stmt ( left_orig ) ) { left = get_last_expr_from_expression_stmt ( left_orig ) ; redo = 1 ; } if ( get_last_expr_from_expression_stmt ( right_orig ) ) { right = get_last_expr_from_expression_stmt ( right_orig ) ; redo = 1 ; } if ( ! redo ) { return ; } count = 0 ; while ( ( tmp = get_assigned_expr ( left ) ) ) { if ( count ++ > 3 ) { break ; } left = strip_expr ( tmp ) ; } count = 0 ; while ( ( tmp = get_assigned_expr ( right ) ) ) { if ( count ++ > 3 ) { break ; } right = strip_expr ( tmp ) ; } handle_comparison ( type , left , expr -> op , right ) ; } 