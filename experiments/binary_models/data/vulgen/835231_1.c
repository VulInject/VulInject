static irqreturn_t at91_adc_9x5_interrupt ( int irq , void * private ) { struct iio_dev * idev = private ; struct at91_adc_state * st = iio_priv ( idev ) ; u32 status = at91_adc_readl ( st , st -> registers -> status_register ) ; const uint32_t ts_data_irq_mask = AT91_ADC_IER_XRDY | AT91_ADC_IER_YRDY | AT91_ADC_IER_PRDY ; if ( status & AT91_ADC_IER_PEN ) { at91_adc_writel ( st , AT91_ADC_IDR , AT91_ADC_IER_PEN ) ; at91_adc_writel ( st , AT91_ADC_IER , AT91_ADC_IER_NOPEN | ts_data_irq_mask ) ; at91_adc_writel ( st , st -> registers -> trigger_register , AT91_ADC_TRGR_MOD_PERIOD_TRIG | AT91_ADC_TRGR_TRGPER_ ( st -> ts_sample_period_val ) ) ; } if ( status & AT91_ADC_IER_NOPEN ) { at91_adc_writel ( st , st -> registers -> trigger_register , 0 ) ; at91_adc_writel ( st , AT91_ADC_IDR , AT91_ADC_IER_NOPEN | ts_data_irq_mask ) ; at91_adc_writel ( st , AT91_ADC_IER , AT91_ADC_IER_PEN ) ; input_report_key ( st -> ts_input , BTN_TOUCH , 0 ) ; input_sync ( st -> ts_input ) ; } if ( ( status & ts_data_irq_mask ) == ts_data_irq_mask ) { if ( status & AT91_ADC_ISR_PENS ) { at91_ts_sample ( idev ) ; } else { at91_adc_readl ( st , AT91_ADC_TSXPOSR ) ; at91_adc_readl ( st , AT91_ADC_TSYPOSR ) ; at91_adc_readl ( st , AT91_ADC_TSPRESSR ) ; } } return IRQ_HANDLED ; } 