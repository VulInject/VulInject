static int dissect_edp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) { proto_item * ti ; proto_tree * edp_tree ; guint32 offset = 0 ; gboolean last = FALSE ; guint8 tlv_type ; guint16 tlv_length ; guint16 data_length ; guint16 seqno ; vec_t cksum_vec [ 1 ] ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , PROTO_SHORT_NAME ) ; col_set_str ( pinfo -> cinfo , COL_INFO , PROTO_SHORT_NAME ":" ) ; ti = proto_tree_add_item ( tree , proto_edp , tvb , offset , - 1 , ENC_NA ) ; edp_tree = proto_item_add_subtree ( ti , ett_edp ) ; proto_tree_add_item ( edp_tree , hf_edp_version , tvb , offset , 1 , ENC_BIG_ENDIAN ) ; offset += 1 ; proto_tree_add_item ( edp_tree , hf_edp_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ) ; offset += 1 ; data_length = tvb_get_ntohs ( tvb , offset ) ; proto_tree_add_uint ( edp_tree , hf_edp_length , tvb , offset , 2 , data_length ) ; offset += 2 ; if ( tvb_captured_length ( tvb ) >= data_length ) { SET_CKSUM_VEC_TVB ( cksum_vec [ 0 ] , tvb , 0 , data_length ) ; proto_tree_add_checksum ( edp_tree , tvb , offset , hf_edp_checksum , hf_edp_checksum_status , & ei_edp_checksum , pinfo , in_cksum ( & cksum_vec [ 0 ] , 1 ) , ENC_BIG_ENDIAN , PROTO_CHECKSUM_VERIFY | PROTO_CHECKSUM_IN_CKSUM ) ; } else { proto_tree_add_checksum ( edp_tree , tvb , offset , hf_edp_checksum , hf_edp_checksum_status , & ei_edp_checksum , pinfo , 0 , ENC_BIG_ENDIAN , PROTO_CHECKSUM_NO_FLAGS ) ; } offset += 2 ; seqno = tvb_get_ntohs ( tvb , offset ) ; proto_tree_add_item ( edp_tree , hf_edp_seqno , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; offset += 2 ; proto_tree_add_item ( edp_tree , hf_edp_midtype , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; offset += 2 ; proto_tree_add_item ( edp_tree , hf_edp_midmac , tvb , offset , 6 , ENC_NA ) ; offset += 6 ; while ( offset < data_length && ! last ) { if ( data_length - offset < 4 ) { proto_tree_add_expert_format ( edp_tree , pinfo , & ei_edp_short_tlv , tvb , offset , 4 , "Too few bytes left for TLV: %u (<4)" , data_length - offset ) ; break ; } tlv_type = tvb_get_guint8 ( tvb , offset + 1 ) ; tlv_length = tvb_get_ntohs ( tvb , offset + 2 ) ; if ( ( tlv_length < 4 ) || ( tlv_length > ( data_length - offset ) ) ) { proto_tree_add_expert_format ( edp_tree , pinfo , & ei_edp_short_tlv , tvb , offset , 0 , "TLV with invalid length: %u" , tlv_length ) ; break ; } if ( tlv_type != EDP_TYPE_NULL ) { col_append_fstr ( pinfo -> cinfo , COL_INFO , " %s" , val_to_str ( tlv_type , edp_type_vals , "[0x%02x]" ) ) ; } switch ( tlv_type ) { case EDP_TYPE_NULL : dissect_null_tlv ( tvb , pinfo , offset , tlv_length , edp_tree ) ; break ; case EDP_TYPE_DISPLAY : dissect_display_tlv ( tvb , pinfo , offset , tlv_length , edp_tree ) ; break ; case EDP_TYPE_INFO : dissect_info_tlv ( tvb , pinfo , offset , tlv_length , edp_tree ) ; break ; case EDP_TYPE_VLAN : dissect_vlan_tlv ( tvb , pinfo , offset , tlv_length , edp_tree ) ; break ; case EDP_TYPE_ESRP : dissect_esrp_tlv ( tvb , pinfo , offset , tlv_length , edp_tree ) ; break ; case EDP_TYPE_EAPS : dissect_eaps_tlv ( tvb , pinfo , offset , tlv_length , edp_tree ) ; break ; case EDP_TYPE_ESL : dissect_esl_tlv ( tvb , pinfo , offset , tlv_length , edp_tree ) ; break ; case EDP_TYPE_ELSM : dissect_elsm_tlv ( tvb , pinfo , offset , tlv_length , edp_tree , seqno ) ; break ; case EDP_TYPE_ELRP : dissect_elrp_tlv ( tvb , pinfo , offset , tlv_length , edp_tree ) ; break ; case EDP_TYPE_LINK : dissect_link_tlv ( tvb , pinfo , offset , tlv_length , edp_tree ) ; break ; default : dissect_unknown_tlv ( tvb , pinfo , offset , tlv_length , edp_tree ) ; break ; } offset += tlv_length ; } return tvb_captured_length ( tvb ) ; } 