STATIC int xfs_btree_delrec ( struct xfs_btree_cur * cur , int level , int * stat ) { struct xfs_btree_block * block ; union xfs_btree_ptr cptr ; struct xfs_buf * bp ; int error ; int i ; union xfs_btree_ptr lptr ; struct xfs_buf * lbp ; struct xfs_btree_block * left ; int lrecs = 0 ; int ptr ; union xfs_btree_ptr rptr ; struct xfs_buf * rbp ; struct xfs_btree_block * right ; struct xfs_btree_block * rrblock ; struct xfs_buf * rrbp ; int rrecs = 0 ; struct xfs_btree_cur * tcur ; int numrecs ; XFS_BTREE_TRACE_CURSOR ( cur , XBT_ENTRY ) ; XFS_BTREE_TRACE_ARGI ( cur , level ) ; tcur = NULL ; ptr = cur -> bc_ptrs [ level ] ; if ( ptr == 0 ) { XFS_BTREE_TRACE_CURSOR ( cur , XBT_EXIT ) ; * stat = 0 ; return 0 ; } block = xfs_btree_get_block ( cur , level , & bp ) ; numrecs = xfs_btree_get_numrecs ( block ) ; error = xfs_btree_check_block ( cur , block , level , bp ) ; if ( error ) { error0 } if ( ptr > numrecs ) { XFS_BTREE_TRACE_CURSOR ( cur , XBT_EXIT ) ; * stat = 0 ; return 0 ; } XFS_BTREE_STATS_INC ( cur , delrec ) ; XFS_BTREE_STATS_ADD ( cur , moves , numrecs - ptr ) ; if ( level > 0 ) { union xfs_btree_key * lkp ; union xfs_btree_ptr * lpp ; lkp = xfs_btree_key_addr ( cur , ptr + 1 , block ) ; lpp = xfs_btree_ptr_addr ( cur , ptr + 1 , block ) ; for ( i = 0 ; i < numrecs - ptr ; i ++ ) { error = xfs_btree_check_ptr ( cur , lpp , i , level ) ; if ( error ) { error0 } } if ( ptr < numrecs ) { xfs_btree_shift_keys ( cur , lkp , - 1 , numrecs - ptr ) ; xfs_btree_shift_ptrs ( cur , lpp , - 1 , numrecs - ptr ) ; xfs_btree_log_keys ( cur , bp , ptr , numrecs - 1 ) ; xfs_btree_log_ptrs ( cur , bp , ptr , numrecs - 1 ) ; } } else { if ( ptr < numrecs ) { xfs_btree_shift_recs ( cur , xfs_btree_rec_addr ( cur , ptr + 1 , block ) , - 1 , numrecs - ptr ) ; xfs_btree_log_recs ( cur , bp , ptr , numrecs - 1 ) ; } } xfs_btree_set_numrecs ( block , -- numrecs ) ; xfs_btree_log_block ( cur , bp , XFS_BB_NUMRECS ) ; if ( xfs_btree_is_lastrec ( cur , block , level ) ) { cur -> bc_ops -> update_lastrec ( cur , block , NULL , ptr , LASTREC_DELREC ) ; } if ( level == cur -> bc_nlevels - 1 ) { if ( cur -> bc_flags & XFS_BTREE_ROOT_IN_INODE ) { xfs_iroot_realloc ( cur -> bc_private . b . ip , - 1 , cur -> bc_private . b . whichfork ) ; error = xfs_btree_kill_iroot ( cur ) ; if ( error ) { error0 } error = xfs_btree_dec_cursor ( cur , level , stat ) ; if ( error ) { error0 } * stat = 1 ; return 0 ; } if ( numrecs == 1 && level > 0 ) { union xfs_btree_ptr * pp ; pp = xfs_btree_ptr_addr ( cur , 1 , block ) ; error = xfs_btree_kill_root ( cur , bp , level , pp ) ; if ( error ) { error0 } } if ( level > 0 ) { error = xfs_btree_dec_cursor ( cur , level , stat ) ; if ( error ) { error0 } } * stat = 1 ; return 0 ; } if ( xfs_btree_needs_key_update ( cur , ptr ) ) { error = xfs_btree_update_keys ( cur , level ) ; if ( error ) { error0 } } if ( numrecs >= cur -> bc_ops -> get_minrecs ( cur , level ) ) { error = xfs_btree_dec_cursor ( cur , level , stat ) ; if ( error ) { error0 } return 0 ; } xfs_btree_get_sibling ( cur , block , & rptr , XFS_BB_RIGHTSIB ) ; xfs_btree_get_sibling ( cur , block , & lptr , XFS_BB_LEFTSIB ) ; if ( cur -> bc_flags & XFS_BTREE_ROOT_IN_INODE ) { if ( xfs_btree_ptr_is_null ( cur , & rptr ) && xfs_btree_ptr_is_null ( cur , & lptr ) && level == cur -> bc_nlevels - 2 ) { error = xfs_btree_kill_iroot ( cur ) ; if ( ! error ) { error = xfs_btree_dec_cursor ( cur , level , stat ) ; } if ( error ) { error0 } return 0 ; } } ASSERT ( ! xfs_btree_ptr_is_null ( cur , & rptr ) || ! xfs_btree_ptr_is_null ( cur , & lptr ) ) ; error = xfs_btree_dup_cursor ( cur , & tcur ) ; if ( error ) { error0 } if ( ! xfs_btree_ptr_is_null ( cur , & rptr ) ) { i = xfs_btree_lastrec ( tcur , level ) ; XFS_WANT_CORRUPTED_GOTO ( cur -> bc_mp , i == 1 , error0 ) ; error = xfs_btree_increment ( tcur , level , & i ) ; if ( error ) { error0 } XFS_WANT_CORRUPTED_GOTO ( cur -> bc_mp , i == 1 , error0 ) ; i = xfs_btree_lastrec ( tcur , level ) ; XFS_WANT_CORRUPTED_GOTO ( cur -> bc_mp , i == 1 , error0 ) ; right = xfs_btree_get_block ( tcur , level , & rbp ) ; error = xfs_btree_check_block ( tcur , right , level , rbp ) ; if ( error ) { error0 } xfs_btree_get_sibling ( tcur , right , & cptr , XFS_BB_LEFTSIB ) ; if ( xfs_btree_get_numrecs ( right ) - 1 >= cur -> bc_ops -> get_minrecs ( tcur , level ) ) { error = xfs_btree_lshift ( tcur , level , & i ) ; if ( error ) { error0 } if ( i ) { ASSERT ( xfs_btree_get_numrecs ( block ) >= cur -> bc_ops -> get_minrecs ( tcur , level ) ) ; xfs_btree_del_cursor ( tcur , XFS_BTREE_NOERROR ) ; tcur = NULL ; error = xfs_btree_dec_cursor ( cur , level , stat ) ; if ( error ) { error0 } return 0 ; } } rrecs = xfs_btree_get_numrecs ( right ) ; if ( ! xfs_btree_ptr_is_null ( cur , & lptr ) ) { i = xfs_btree_firstrec ( tcur , level ) ; XFS_WANT_CORRUPTED_GOTO ( cur -> bc_mp , i == 1 , error0 ) ; error = xfs_btree_decrement ( tcur , level , & i ) ; if ( error ) { error0 } XFS_WANT_CORRUPTED_GOTO ( cur -> bc_mp , i == 1 , error0 ) ; } } if ( ! xfs_btree_ptr_is_null ( cur , & lptr ) ) { i = xfs_btree_firstrec ( tcur , level ) ; XFS_WANT_CORRUPTED_GOTO ( cur -> bc_mp , i == 1 , error0 ) ; error = xfs_btree_decrement ( tcur , level , & i ) ; if ( error ) { error0 } i = xfs_btree_firstrec ( tcur , level ) ; XFS_WANT_CORRUPTED_GOTO ( cur -> bc_mp , i == 1 , error0 ) ; left = xfs_btree_get_block ( tcur , level , & lbp ) ; error = xfs_btree_check_block ( cur , left , level , lbp ) ; if ( error ) { error0 } xfs_btree_get_sibling ( tcur , left , & cptr , XFS_BB_RIGHTSIB ) ; if ( xfs_btree_get_numrecs ( left ) - 1 >= cur -> bc_ops -> get_minrecs ( tcur , level ) ) { error = xfs_btree_rshift ( tcur , level , & i ) ; if ( error ) { error0 } if ( i ) { ASSERT ( xfs_btree_get_numrecs ( block ) >= cur -> bc_ops -> get_minrecs ( tcur , level ) ) ; xfs_btree_del_cursor ( tcur , XFS_BTREE_NOERROR ) ; tcur = NULL ; if ( level == 0 ) { cur -> bc_ptrs [ 0 ] ++ ; } XFS_BTREE_TRACE_CURSOR ( cur , XBT_EXIT ) ; * stat = 1 ; return 0 ; } } lrecs = xfs_btree_get_numrecs ( left ) ; } xfs_btree_del_cursor ( tcur , XFS_BTREE_NOERROR ) ; tcur = NULL ; ASSERT ( ! xfs_btree_ptr_is_null ( cur , & cptr ) ) ; if ( ! xfs_btree_ptr_is_null ( cur , & lptr ) && lrecs + xfs_btree_get_numrecs ( block ) <= cur -> bc_ops -> get_maxrecs ( cur , level ) ) { rptr = cptr ; right = block ; rbp = bp ; error = xfs_btree_read_buf_block ( cur , & lptr , 0 , & left , & lbp ) ; if ( error ) { error0 } } if ( ! xfs_btree_ptr_is_null ( cur , & rptr ) && rrecs + xfs_btree_get_numrecs ( block ) <= cur -> bc_ops -> get_maxrecs ( cur , level ) ) { lptr = cptr ; left = block ; lbp = bp ; error = xfs_btree_read_buf_block ( cur , & rptr , 0 , & right , & rbp ) ; if ( error ) { error0 } } else { error = xfs_btree_dec_cursor ( cur , level , stat ) ; if ( error ) { error0 } return 0 ; } rrecs = xfs_btree_get_numrecs ( right ) ; lrecs = xfs_btree_get_numrecs ( left ) ; XFS_BTREE_STATS_ADD ( cur , moves , rrecs ) ; if ( level > 0 ) { union xfs_btree_key * lkp ; union xfs_btree_ptr * lpp ; union xfs_btree_key * rkp ; union xfs_btree_ptr * rpp ; lkp = xfs_btree_key_addr ( cur , lrecs + 1 , left ) ; lpp = xfs_btree_ptr_addr ( cur , lrecs + 1 , left ) ; rkp = xfs_btree_key_addr ( cur , 1 , right ) ; rpp = xfs_btree_ptr_addr ( cur , 1 , right ) ; for ( i = 1 ; i < rrecs ; i ++ ) { error = xfs_btree_check_ptr ( cur , rpp , i , level ) ; if ( error ) { error0 } } xfs_btree_copy_keys ( cur , lkp , rkp , rrecs ) ; xfs_btree_copy_ptrs ( cur , lpp , rpp , rrecs ) ; xfs_btree_log_keys ( cur , lbp , lrecs + 1 , lrecs + rrecs ) ; xfs_btree_log_ptrs ( cur , lbp , lrecs + 1 , lrecs + rrecs ) ; } else { union xfs_btree_rec * lrp ; union xfs_btree_rec * rrp ; lrp = xfs_btree_rec_addr ( cur , lrecs + 1 , left ) ; rrp = xfs_btree_rec_addr ( cur , 1 , right ) ; xfs_btree_copy_recs ( cur , lrp , rrp , rrecs ) ; xfs_btree_log_recs ( cur , lbp , lrecs + 1 , lrecs + rrecs ) ; } XFS_BTREE_STATS_INC ( cur , join ) ; xfs_btree_set_numrecs ( left , lrecs + rrecs ) ; xfs_btree_get_sibling ( cur , right , & cptr , XFS_BB_RIGHTSIB ) , xfs_btree_set_sibling ( cur , left , & cptr , XFS_BB_RIGHTSIB ) ; xfs_btree_log_block ( cur , lbp , XFS_BB_NUMRECS | XFS_BB_RIGHTSIB ) ; xfs_btree_get_sibling ( cur , left , & cptr , XFS_BB_RIGHTSIB ) ; if ( ! xfs_btree_ptr_is_null ( cur , & cptr ) ) { error = xfs_btree_read_buf_block ( cur , & cptr , 0 , & rrblock , & rrbp ) ; if ( error ) { error0 } xfs_btree_set_sibling ( cur , rrblock , & lptr , XFS_BB_LEFTSIB ) ; xfs_btree_log_block ( cur , rrbp , XFS_BB_LEFTSIB ) ; } error = xfs_btree_free_block ( cur , rbp ) ; if ( error ) { error0 } if ( bp != lbp ) { cur -> bc_bufs [ level ] = lbp ; cur -> bc_ptrs [ level ] += lrecs ; cur -> bc_ra [ level ] = 0 ; } if ( ( cur -> bc_flags & XFS_BTREE_ROOT_IN_INODE ) || ( level + 1 < cur -> bc_nlevels ) ) { error = xfs_btree_increment ( cur , level + 1 , & i ) ; if ( error ) { error0 } } XFS_BTREE_TRACE_CURSOR ( cur , XBT_EXIT ) ; * stat = 2 ; return 0 ; error0 XFS_BTREE_TRACE_CURSOR ( cur , XBT_ERROR ) ; if ( tcur ) { xfs_btree_del_cursor ( tcur , XFS_BTREE_ERROR ) ; } return error ; } 