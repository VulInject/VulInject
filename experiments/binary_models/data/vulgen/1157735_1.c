static void evhttp_get_body ( struct evhttp_connection * evcon , struct evhttp_request * req ) { const char * xfer_enc ; if ( req -> kind == EVHTTP_REQUEST && ! evhttp_method_may_have_body ( req -> type ) ) { evhttp_connection_done ( evcon ) ; return ; } evcon -> state = EVCON_READING_BODY ; xfer_enc = evhttp_find_header ( req -> input_headers , "Transfer-Encoding" ) ; if ( xfer_enc != NULL && evutil_ascii_strcasecmp ( xfer_enc , "chunked" ) == 0 ) { req -> chunked = 1 ; req -> ntoread = - 1 ; } else { if ( evhttp_get_body_length ( req ) == - 1 ) { return ; } if ( req -> kind == EVHTTP_REQUEST && req -> ntoread < 1 ) { evhttp_connection_done ( evcon ) ; return ; } } if ( req -> kind == EVHTTP_REQUEST && REQ_VERSION_ATLEAST ( req , 1 , 1 ) ) { const char * expect ; expect = evhttp_find_header ( req -> input_headers , "Expect" ) ; if ( expect ) { if ( ! evutil_ascii_strcasecmp ( expect , "100-continue" ) ) { if ( req -> ntoread > 0 ) { if ( ( req -> evcon -> max_body_size <= EV_INT64_MAX ) && ( ev_uint64_t ) req -> ntoread > req -> evcon -> max_body_size ) { evhttp_send_error ( req , HTTP_ENTITYTOOLARGE , NULL ) ; return ; } } if ( ! evbuffer_get_length ( bufferevent_get_input ( evcon -> bufev ) ) ) { evhttp_send_continue ( evcon , req ) ; } } else { evhttp_send_error ( req , HTTP_EXPECTATIONFAILED , NULL ) ; return ; } } } evhttp_read_body ( evcon , req ) ; } 