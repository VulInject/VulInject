int notrace s390_do_machine_check ( struct pt_regs * regs ) { static int ipd_count ; static DEFINE_SPINLOCK ( ipd_lock ) ; static unsigned long long last_ipd ; struct mcck_struct * mcck ; unsigned long long tmp ; irqentry_state_t irq_state ; union mci mci ; unsigned long mcck_dam_code ; int mcck_pending = 0 ; irq_state = irqentry_nmi_enter ( regs ) ; inc_irq_stat ( NMI_NMI ) ; mci . val = S390_lowcore . mcck_interruption_code ; mcck = this_cpu_ptr ( & cpu_mcck ) ; if ( mci . pd && ! test_cpu_flag ( CIF_MCCK_GUEST ) ) { if ( mci . b ) { u64 z_mcic , o_mcic , t_mcic ; z_mcic = ( 1ULL << 63 | 1ULL << 59 | 1ULL << 29 ) ; o_mcic = ( 1ULL << 43 | 1ULL << 42 | 1ULL << 41 | 1ULL << 40 | 1ULL << 36 | 1ULL << 35 | 1ULL << 34 | 1ULL << 32 | 1ULL << 30 | 1ULL << 21 | 1ULL << 20 | 1ULL << 17 | 1ULL << 16 ) ; t_mcic = mci . val ; if ( ( ( t_mcic & z_mcic ) != 0 ) || ( ( t_mcic & o_mcic ) != o_mcic ) ) { s390_handle_damage ( ) ; } spin_lock ( & ipd_lock ) ; tmp = get_tod_clock ( ) ; if ( ( ( tmp - last_ipd ) >> 12 ) < MAX_IPD_TIME ) { ipd_count ++ ; } else { ipd_count = 1 ; } last_ipd = tmp ; if ( ipd_count == MAX_IPD_COUNT ) { s390_handle_damage ( ) ; } spin_unlock ( & ipd_lock ) ; } else { s390_handle_damage ( ) ; } } if ( s390_validate_registers ( mci ) ) { if ( ! user_mode ( regs ) ) { s390_handle_damage ( ) ; } mcck -> kill_task = 1 ; mcck -> mcck_code = mci . val ; mcck_pending = 1 ; } if ( test_cpu_flag ( CIF_MCCK_GUEST ) ) { s390_backup_mcck_info ( regs ) ; } if ( mci . cd ) { s390_handle_damage ( ) ; } if ( mci . ed && mci . ec ) { if ( S390_lowcore . external_damage_code & ( 1U << ED_STP_SYNC ) ) { mcck -> stp_queue |= stp_sync_check ( ) ; } if ( S390_lowcore . external_damage_code & ( 1U << ED_STP_ISLAND ) ) { mcck -> stp_queue |= stp_island_check ( ) ; } mcck_pending = 1 ; } if ( ! test_cpu_flag ( CIF_MCCK_GUEST ) ) { if ( mci . se ) { s390_handle_damage ( ) ; } if ( mci . ke ) { s390_handle_damage ( ) ; } if ( mci . ds && mci . fa ) { s390_handle_damage ( ) ; } } if ( mci . cp ) { mcck -> channel_report = 1 ; mcck_pending = 1 ; } if ( mci . w ) { mcck -> warning = 1 ; mcck_pending = 1 ; } mcck_dam_code = ( mci . val & MCIC_SUBCLASS_MASK ) ; if ( test_cpu_flag ( CIF_MCCK_GUEST ) && ( mcck_dam_code & MCCK_CODE_NO_GUEST ) != mcck_dam_code ) { * ( ( long * ) ( regs -> gprs [ 15 ] + __SF_SIE_REASON ) ) = - EINTR ; } clear_cpu_flag ( CIF_MCCK_GUEST ) ; if ( user_mode ( regs ) && mcck_pending ) { irqentry_nmi_exit ( regs , irq_state ) ; return 1 ; } if ( mcck_pending ) { schedule_mcck_handler ( ) ; } irqentry_nmi_exit ( regs , irq_state ) ; return 0 ; } 