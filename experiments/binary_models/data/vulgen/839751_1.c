int control_buf_i = 0 ; struct ModeBuf mbuf ; struct Ban * link , * next ; struct Membership * member ; for ( ; * control ; control ++ ) { for ( flag_p = flags ; flag_p [ 0 ] ; flag_p += 2 ) { if ( * control == flag_p [ 1 ] ) { del_mode |= flag_p [ 0 ] ; break ; } } for ( flag_p = exflags ; flag_p [ 0 ] ; flag_p += 2 ) { if ( * control == flag_p [ 1 ] ) { del_exmode |= flag_p [ 0 ] ; break ; } } } if ( ! del_mode && ! del_exmode ) { return 0 ; } modebuf_init ( & mbuf , sptr , cptr , chptr , ( MODEBUF_DEST_CHANNEL | MODEBUF_DEST_OPMODE | MODEBUF_DEST_HACK4 ) ) ; modebuf_mode ( & mbuf , MODE_DEL | ( del_mode & chptr -> mode . mode ) ) ; modebuf_mode ( & mbuf , MODE_DEL | ( del_exmode & chptr -> mode . exmode ) ) ; chptr -> mode . mode &= ~ del_mode ; chptr -> mode . exmode &= ~ del_exmode ; if ( del_mode & MODE_INVITEONLY ) { mode_invite_clear ( chptr ) ; } if ( del_mode & MODE_KEY && * chptr -> mode . key ) { modebuf_mode_string ( & mbuf , MODE_DEL | MODE_KEY , chptr -> mode . key , 0 ) ; } if ( del_mode & MODE_LIMIT && chptr -> mode . limit ) { modebuf_mode_uint ( & mbuf , MODE_DEL | MODE_LIMIT , chptr -> mode . limit ) ; chptr -> mode . limit = 0 ; } if ( del_mode & MODE_BAN ) { for ( link = chptr -> banlist ; link ; link = next ) { char * bandup ; next = link -> next ; DupString ( bandup , link -> banstr ) ; modebuf_mode_string ( & mbuf , MODE_DEL | MODE_BAN , bandup , 1 ) ; free_ban ( link ) ; } chptr -> banlist = 0 ; } if ( del_mode & MODE_EXCEPT ) { for ( link = chptr -> exceptlist ; link ; link = next ) { char * exdup ; next = link -> next ; DupString ( exdup , link -> banstr ) ; modebuf_mode_string ( & mbuf , MODE_DEL | MODE_EXCEPT , exdup , 1 ) ; free_ban ( link ) ; } chptr -> exceptlist = 0 ; } if ( del_mode & ( MODE_BAN | MODE_EXCEPT | MODE_CHANOP | MODE_HALFOP | MODE_VOICE ) ) { for ( member = chptr -> members ; member ; member = member -> next_member ) { if ( IsZombie ( member ) ) { continue ; } if ( del_mode & MODE_BAN ) { ClearBanValid ( member ) ; ClearBanValidQuiet ( member ) ; ClearBanValidNick ( member ) ; } if ( del_mode & MODE_EXCEPT ) { ClearExceptValid ( member ) ; ClearExceptValidQuiet ( member ) ; ClearExceptValidNick ( member ) ; } if ( IsChanOp ( member ) && del_mode & MODE_CHANOP ) { modebuf_mode_client ( & mbuf , MODE_DEL | MODE_CHANOP , member -> user , MAXOPLEVEL + 1 ) ; member -> status &= ~ CHFL_CHANOP ; } if ( IsHalfOp ( member ) && del_mode & MODE_HALFOP ) { modebuf_mode_client ( & mbuf , MODE_DEL | MODE_HALFOP , member -> user , MAXOPLEVEL + 1 ) ; member -> status &= ~ CHFL_HALFOP ; } if ( HasVoice ( member ) && del_mode & MODE_VOICE ) { modebuf_mode_client ( & mbuf , MODE_DEL | MODE_VOICE , member -> user , MAXOPLEVEL + 1 ) ; member -> status &= ~ CHFL_VOICE ; } } } modebuf_flush ( & mbuf ) ; if ( del_mode & MODE_KEY ) { chptr -> mode . key [ 0 ] = '\0' ; } for ( flag_p = flags ; flag_p [ 0 ] ; flag_p += 2 ) { if ( del_mode & flag_p [ 0 ] ) { control_buf [ control_buf_i ++ ] = flag_p [ 1 ] ; } } for ( flag_p = exflags ; flag_p [ 0 ] ; flag_p += 2 ) { } control_buf [ control_buf_i ] = '\0' ; log_write ( LS_OPERMODE , L_INFO , LOG_NOSNOTICE , "%#C CLEARMODE %H %s" , sptr , chptr , control_buf ) ; if ( ! IsLocalChannel ( chptr -> chname ) ) { sendcmdto_serv_butone ( sptr , CMD_CLEARMODE , cptr , "%H %s" , chptr , control_buf ) ; } return 0 ; 