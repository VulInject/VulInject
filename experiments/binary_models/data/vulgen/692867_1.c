static int yaffs_unlink_worker ( struct yaffs_obj * obj ) { int del_now = 0 ; if ( ! obj ) { return YAFFS_FAIL ; } yaffs_update_parent ( obj -> parent ) ; if ( obj -> variant_type == YAFFS_OBJECT_TYPE_HARDLINK ) { return yaffs_del_link ( obj ) ; } if ( ! list_empty ( & obj -> hard_links ) ) { struct yaffs_obj * hl ; struct yaffs_obj * parent ; int ret_val ; YCHAR name [ YAFFS_MAX_NAME_LENGTH + 1 ] ; hl = list_entry ( obj -> hard_links . next , yaffs_obj , hard_links ) ; yaffs_get_obj_name ( hl , name , YAFFS_MAX_NAME_LENGTH + 1 ) ; parent = hl -> parent ; list_del_init ( & hl -> hard_links ) ; yaffs_add_obj_to_dir ( obj -> my_dev -> unlinked_dir , hl ) ; ret_val = yaffs_change_obj_name ( obj , parent , name , 0 , 0 ) ; if ( ret_val == YAFFS_OK ) { ret_val = yaffs_generic_obj_del ( hl ) ; } return ret_val ; } if ( del_now ) { switch ( obj -> variant_type ) { case YAFFS_OBJECT_TYPE_FILE : return yaffs_del_file ( obj ) ; break ; case YAFFS_OBJECT_TYPE_DIRECTORY : list_del_init ( & obj -> variant . dir_variant . dirty ) ; return yaffs_del_dir ( obj ) ; break ; case YAFFS_OBJECT_TYPE_SYMLINK : return yaffs_del_symlink ( obj ) ; break ; case YAFFS_OBJECT_TYPE_SPECIAL : return yaffs_generic_obj_del ( obj ) ; break ; case YAFFS_OBJECT_TYPE_HARDLINK : case YAFFS_OBJECT_TYPE_UNKNOWN : default : return YAFFS_FAIL ; } } if ( yaffs_is_non_empty_dir ( obj ) ) { return YAFFS_FAIL ; } else { return yaffs_change_obj_name ( obj , obj -> my_dev -> unlinked_dir , _Y ( "unlinked" ) , 0 , 0 ) ; } } 