static ssize_t write ( struct file * filep , const char __user * buf , size_t n , loff_t * ppos ) { struct IR * ir = filep -> private_data ; struct IR_tx * tx ; size_t i ; int failures = 0 ; tx = get_ir_tx ( ir ) ; if ( tx == NULL ) { return - ENXIO ; } mutex_lock ( & tx -> client_lock ) ; if ( tx -> c == NULL ) { mutex_unlock ( & tx -> client_lock ) ; put_ir_tx ( tx , false ) ; return - ENXIO ; } mutex_lock ( & ir -> ir_lock ) ; for ( i = 0 ; i < n ; ) { int ret = 0 ; int command ; if ( copy_from_user ( & command , buf + i , sizeof ( command ) ) ) { mutex_unlock ( & ir -> ir_lock ) ; mutex_unlock ( & tx -> client_lock ) ; put_ir_tx ( tx , false ) ; return - EFAULT ; } if ( tx -> need_boot == 1 ) { ret = fw_load ( tx ) ; if ( ret != 0 ) { mutex_unlock ( & ir -> ir_lock ) ; mutex_unlock ( & tx -> client_lock ) ; put_ir_tx ( tx , false ) ; if ( ret != - ENOMEM ) { ret = - EIO ; } return ret ; } ret = send_boot_data ( tx ) ; if ( ret == 0 ) { tx -> need_boot = 0 ; } } if ( ret == 0 ) { ret = send_code ( tx , ( unsigned int ) command >> 16 , ( unsigned int ) command & 0xFFFF ) ; if ( ret == - EPROTO ) { mutex_unlock ( & ir -> ir_lock ) ; mutex_unlock ( & tx -> client_lock ) ; put_ir_tx ( tx , false ) ; return ret ; } } if ( ret != 0 ) { dev_err ( tx -> ir -> l . dev , "sending to the IR transmitter chip failed, trying reset\n" ) ; if ( failures >= 3 ) { dev_err ( tx -> ir -> l . dev , "unable to send to the IR chip after 3 resets, giving up\n" ) ; mutex_unlock ( & ir -> ir_lock ) ; mutex_unlock ( & tx -> client_lock ) ; put_ir_tx ( tx , false ) ; return ret ; } set_current_state ( TASK_UNINTERRUPTIBLE ) ; schedule_timeout ( ( 100 * HZ + 999 ) / 1000 ) ; tx -> need_boot = 1 ; ++ failures ; } else { i += sizeof ( int ) ; } } mutex_unlock ( & ir -> ir_lock ) ; mutex_unlock ( & tx -> client_lock ) ; put_ir_tx ( tx , false ) ; return n ; } 