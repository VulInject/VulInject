static int soc_tplg_denum_create ( struct soc_tplg * tplg , unsigned int count , size_t size ) { struct snd_soc_tplg_enum_control * ec ; struct soc_enum * se ; struct snd_kcontrol_new kc ; int i , ret , err ; if ( soc_tplg_check_elem_count ( tplg , sizeof ( snd_soc_tplg_enum_control ) , count , size , "enums" ) ) { dev_err ( tplg -> dev , "ASoC: invalid count %d for enum controls\n" , count ) ; return - EINVAL ; } for ( i = 0 ; i < count ; i ++ ) { ec = ( snd_soc_tplg_enum_control * ) tplg -> pos ; tplg -> pos += ( sizeof ( snd_soc_tplg_enum_control ) + ec -> priv . size ) ; if ( strnlen ( ec -> hdr . name , SNDRV_CTL_ELEM_ID_NAME_MAXLEN ) == SNDRV_CTL_ELEM_ID_NAME_MAXLEN ) { return - EINVAL ; } se = kzalloc ( ( sizeof ( * se ) ) , GFP_KERNEL ) ; if ( se == NULL ) { return - ENOMEM ; } dev_dbg ( tplg -> dev , "ASoC: adding enum kcontrol %s size %d\n" , ec -> hdr . name , ec -> items ) ; kc . name = ec -> hdr . name ; kc . private_value = ( long ) se ; kc . iface = SNDRV_CTL_ELEM_IFACE_MIXER ; kc . access = ec -> hdr . access ; se -> reg = tplc_chan_get_reg ( tplg , ec -> channel , SNDRV_CHMAP_FL ) ; se -> shift_l = tplc_chan_get_shift ( tplg , ec -> channel , SNDRV_CHMAP_FL ) ; se -> shift_r = tplc_chan_get_shift ( tplg , ec -> channel , SNDRV_CHMAP_FL ) ; se -> items = ec -> items ; se -> mask = ec -> mask ; se -> dobj . index = tplg -> index ; se -> dobj . type = SND_SOC_DOBJ_ENUM ; se -> dobj . ops = tplg -> ops ; INIT_LIST_HEAD ( & se -> dobj . list ) ; switch ( ec -> hdr . ops . info ) { case SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE : case SND_SOC_TPLG_CTL_ENUM_VALUE : err = soc_tplg_denum_create_values ( se , ec ) ; if ( err < 0 ) { dev_err ( tplg -> dev , "ASoC: could not create values for %s\n" , ec -> hdr . name ) ; kfree ( se ) ; continue ; } case SND_SOC_TPLG_CTL_ENUM : case SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE : case SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT : err = soc_tplg_denum_create_texts ( se , ec ) ; if ( err < 0 ) { dev_err ( tplg -> dev , "ASoC: could not create texts for %s\n" , ec -> hdr . name ) ; kfree ( se ) ; continue ; } break ; default : dev_err ( tplg -> dev , "ASoC: invalid enum control type %d for %s\n" , ec -> hdr . ops . info , ec -> hdr . name ) ; kfree ( se ) ; continue ; } err = soc_tplg_kcontrol_bind_io ( & ec -> hdr , & kc , tplg ) ; if ( err ) { soc_control_err ( tplg , & ec -> hdr , ec -> hdr . name ) ; kfree ( se ) ; continue ; } err = soc_tplg_init_kcontrol ( tplg , & kc , ( snd_soc_tplg_ctl_hdr * ) ec ) ; if ( err < 0 ) { dev_err ( tplg -> dev , "ASoC: failed to init %s\n" , ec -> hdr . name ) ; kfree ( se ) ; continue ; } ret = soc_tplg_add_kcontrol ( tplg , & kc , & se -> dobj . control . kcontrol ) ; if ( ret < 0 ) { dev_err ( tplg -> dev , "ASoC: could not add kcontrol %s\n" , ec -> hdr . name ) ; kfree ( se ) ; continue ; } list_add ( & se -> dobj . list , & tplg -> comp -> dobj_list ) ; } return 0 ; } 