static void spu_unbind_context ( struct spu * spu , struct spu_context * ctx ) { u32 status ; spu_context_trace ( spu_unbind_context__enter , ctx , spu ) ; spuctx_switch_state ( ctx , SPU_UTIL_SYSTEM ) ; if ( spu -> ctx -> flags & SPU_CREATE_NOSCHED ) { atomic_dec ( & cbe_spu_info [ spu -> node ] . reserved_spus ) ; } if ( ctx -> gang ) { atomic_dec_if_positive ( & ctx -> gang -> aff_sched_count ) ; } spu_unmap_mappings ( ctx ) ; spu_save ( & ctx -> csa , spu ) ; spu_switch_log_notify ( spu , ctx , SWITCH_LOG_STOP , 0 ) ; spin_lock_irq ( & spu -> register_lock ) ; ctx -> state = SPU_STATE_SAVED ; spu -> ibox_callback = NULL ; spu -> wbox_callback = NULL ; spu -> stop_callback = NULL ; spu -> mfc_callback = NULL ; spu -> pid = 0 ; spu -> tgid = 0 ; ctx -> ops = & spu_backing_ops ; spu -> flags = 0 ; spu -> ctx = NULL ; spin_unlock_irq ( & spu -> register_lock ) ; spu_associate_mm ( spu , NULL ) ; ctx -> stats . slb_flt += ( spu -> stats . slb_flt - ctx -> stats . slb_flt_base ) ; ctx -> stats . class2_intr += ( spu -> stats . class2_intr - ctx -> stats . class2_intr_base ) ; spuctx_switch_state ( ctx , SPU_UTIL_IDLE_LOADED ) ; ctx -> spu = NULL ; if ( spu_stopped ( ctx , & status ) ) { wake_up_all ( & ctx -> stop_wq ) ; } } 