NODE * spec ( void ) { NODE * centry , * last ; char * p ; NODE ginfo , * root ; int c_cur , c_next ; char * buf , * tbuf = NULL ; size_t len ; last = root = NULL ; centry = & ginfo ; c_cur = c_next = 0 ; for ( lineno = 1 ; ( buf = fgetln ( stdin , & len ) ) ; ++ lineno , c_cur = c_next , c_next = 0 ) { if ( buf [ len - 1 ] == '\n' ) { buf [ -- len ] = '\0' ; } else { tbuf = malloc ( len + 1 ) ; memcpy ( tbuf , buf , len ) ; tbuf [ len ] = '\0' ; buf = tbuf ; } for ( p = buf ; isspace ( ( unsigned char ) * p ) ; p ++ ) { } if ( * p == '\0' || * p == '#' ) { continue ; } if ( buf [ len - 1 ] == '\\' ) { c_next = 1 ; if ( -- len == 0 ) { continue ; } buf [ len ] = '\0' ; } ( void ) fprintf ( stderr , "line %d: {%s}\n" , lineno , p ) ; if ( c_cur ) { set ( p , centry ) ; continue ; } if ( ( p = strtok ( p , "\n\t " ) ) == NULL ) { error ( "missing field" ) ; } if ( p [ 0 ] == '/' ) { switch ( p [ 1 ] ) { case 's' : if ( strcmp ( p + 1 , "set" ) ) { break ; } set ( NULL , & ginfo ) ; continue ; case 'u' : if ( strcmp ( p + 1 , "unset" ) ) { break ; } unset ( NULL , & ginfo ) ; continue ; } } if ( strchr ( p , '/' ) ) { error ( "slash character in file name" ) ; } if ( ! strcmp ( p , ".." ) ) { if ( ! root ) { noparent } if ( last -> type != F_DIR || last -> flags & F_DONE ) { if ( last == root ) { noparent } last = last -> parent ; } last -> flags |= F_DONE ; continue ; noparent error ( "no parent node" ) ; } len = strlen ( p ) + 1 ; if ( ( centry = calloc ( 1 , sizeof ( NODE ) + len - 1 ) ) == NULL ) { error ( "%s" , strerror ( errno ) ) ; } * centry = ginfo ; if ( strpbrk ( p , MAGIC ) ) { centry -> flags |= F_MAGIC ; } if ( strunvis ( centry -> name , p ) == - 1 ) { fprintf ( stderr , "mtree: filename (%s) encoded incorrectly\n" , p ) ; strlcpy ( centry -> name , p , len ) ; } set ( NULL , centry ) ; if ( ! root ) { last = root = centry ; root -> parent = root ; } if ( last -> type == F_DIR && ! ( last -> flags & F_DONE ) ) { centry -> parent = last ; last = last -> child = centry ; } else { centry -> parent = last -> parent ; centry -> prev = last ; last = last -> next = centry ; } } free ( tbuf ) ; return ( root ) ; } 