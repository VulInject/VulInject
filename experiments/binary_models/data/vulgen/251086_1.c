elf_vax_size_dynamic_sections ( , ) bfd * output_bfd ; struct bfd_link_info * info ; { bfd * dynobj ; asection * s ; bfd_boolean plt ; bfd_boolean relocs ; bfd_boolean reltext ; dynobj = elf_hash_table ( info ) -> dynobj ; BFD_ASSERT ( dynobj != NULL ) ; if ( elf_hash_table ( info ) -> dynamic_sections_created ) { if ( info -> executable && ! info -> static_link ) { s = bfd_get_section_by_name ( dynobj , ".interp" ) ; BFD_ASSERT ( s != NULL ) ; s -> _raw_size = sizeof ELF_DYNAMIC_INTERPRETER ; } } else { s = bfd_get_section_by_name ( dynobj , ".rela.got" ) ; if ( s != NULL ) { s -> _raw_size = 0 ; } s = bfd_get_section_by_name ( dynobj , ".got.plt" ) ; if ( s != NULL ) { s -> _raw_size = 0 ; } s = bfd_get_section_by_name ( dynobj , ".got" ) ; if ( s != NULL ) { s -> _raw_size = 0 ; } } if ( info -> shared && info -> symbolic ) { elf_vax_link_hash_traverse ( elf_vax_hash_table ( info ) , elf_vax_discard_copies , ( PTR ) NULL ) ; } elf_link_hash_traverse ( elf_hash_table ( info ) , elf_vax_instantiate_got_entries , ( PTR ) info ) ; plt = FALSE ; relocs = FALSE ; reltext = FALSE ; for ( s = dynobj -> sections ; s != NULL ; s = s -> next ) { const char * name ; bfd_boolean strip ; if ( ( s -> flags & SEC_LINKER_CREATED ) == 0 ) { continue ; } name = bfd_get_section_name ( dynobj , s ) ; strip = FALSE ; if ( strcmp ( name , ".plt" ) == 0 ) { if ( s -> _raw_size == 0 ) { strip = TRUE ; } else { plt = TRUE ; } } if ( strncmp ( name , ".rela" , 5 ) == 0 ) { if ( s -> _raw_size == 0 ) { strip = TRUE ; } else { asection * target ; if ( strcmp ( name , ".rela.plt" ) != 0 ) { const char * outname ; relocs = TRUE ; outname = bfd_get_section_name ( output_bfd , s -> output_section ) ; target = bfd_get_section_by_name ( output_bfd , outname + 5 ) ; if ( target != NULL && ( target -> flags & SEC_READONLY ) != 0 && ( target -> flags & SEC_ALLOC ) != 0 ) { reltext = TRUE ; } } s -> reloc_count = 0 ; } } if ( strncmp ( name , ".got" , 4 ) != 0 ) { continue ; } if ( strip ) { _bfd_strip_section_from_output ( info , s ) ; continue ; } s -> contents = ( bfd_byte * ) bfd_zalloc ( dynobj , s -> _raw_size ) ; if ( s -> contents == NULL && s -> _raw_size != 0 ) { return FALSE ; } } if ( elf_hash_table ( info ) -> dynamic_sections_created ) { _bfd_elf_add_dynamic_entry ( , , ) if ( ! info -> shared ) { if ( ! add_dynamic_entry ( DT_DEBUG , 0 ) ) { return FALSE ; } } if ( plt ) { if ( ! add_dynamic_entry ( DT_PLTGOT , 0 ) || ! add_dynamic_entry ( DT_PLTRELSZ , 0 ) || ! add_dynamic_entry ( DT_PLTREL , DT_RELA ) || ! add_dynamic_entry ( DT_JMPREL , 0 ) ) { return FALSE ; } } if ( relocs ) { if ( ! add_dynamic_entry ( DT_RELA , 0 ) || ! add_dynamic_entry ( DT_RELASZ , 0 ) || ! add_dynamic_entry ( DT_RELAENT , sizeof ( Elf32_External_Rela ) ) ) { return FALSE ; } } if ( reltext || ( info -> flags & DF_TEXTREL ) != 0 ) { if ( ! add_dynamic_entry ( DT_TEXTREL , 0 ) ) { return FALSE ; } } } return TRUE ; } 