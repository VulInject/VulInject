static Node * create_entry ( const char __user * buffer , size_t count ) { Node * e ; int memsize , err ; char * buf , * p ; char del ; pr_debug ( "register: received %zu bytes\n" , count ) ; err = - EINVAL ; if ( ( count < 11 ) || ( count > MAX_REGISTER_LENGTH ) ) { out } err = - ENOMEM ; memsize = sizeof ( Node ) + count + 8 ; e = kmalloc ( memsize , GFP_KERNEL ) ; if ( ! e ) { out } p = buf = ( char * ) e + sizeof ( Node ) ; if ( copy_from_user ( buf , buffer , count ) ) { efault } del = * p ++ ; pr_debug ( "register: delim: %#x {%c}\n" , del , del ) ; memset ( buf + count , del , 8 ) ; e -> name = p ; p = strchr ( p , del ) ; if ( ! p ) { einval } * p ++ = '\0' ; if ( ! e -> name [ 0 ] || ! strcmp ( e -> name , "." ) || ! strcmp ( e -> name , ".." ) || strchr ( e -> name , '/' ) ) { einval } pr_debug ( "register: name: {%s}\n" , e -> name ) ; switch ( * p ++ ) { case 'E' : pr_debug ( "register: type: E (extension)\n" ) ; e -> flags = 1 << Enabled ; break ; case 'M' : pr_debug ( "register: type: M (magic)\n" ) ; e -> flags = ( 1 << Enabled ) | ( 1 << Magic ) ; break ; default : einval } if ( * p ++ != del ) { einval } if ( test_bit ( Magic , & e -> flags ) ) { char * s ; s = strchr ( p , del ) ; if ( ! s ) { einval } * s ++ = '\0' ; e -> offset = simple_strtoul ( p , & p , 10 ) ; if ( * p ++ ) { einval } pr_debug ( "register: offset: %#x\n" , e -> offset ) ; e -> magic = p ; p = scanarg ( p , del ) ; if ( ! p ) { einval } if ( ! e -> magic [ 0 ] ) { einval } if ( USE_DEBUG ) { print_hex_dump_bytes ( KBUILD_MODNAME ": register: magic[raw]: " , DUMP_PREFIX_NONE , e -> magic , p - e -> magic ) ; } e -> mask = p ; p = scanarg ( p , del ) ; if ( ! p ) { einval } if ( ! e -> mask [ 0 ] ) { e -> mask = NULL ; pr_debug ( "register:  mask[raw]: none\n" ) ; } if ( USE_DEBUG ) { print_hex_dump_bytes ( KBUILD_MODNAME ": register:  mask[raw]: " , DUMP_PREFIX_NONE , e -> mask , p - e -> mask ) ; } e -> size = string_unescape_inplace ( e -> magic , UNESCAPE_HEX ) ; if ( e -> mask && string_unescape_inplace ( e -> mask , UNESCAPE_HEX ) != e -> size ) { einval } if ( e -> size + e -> offset > BINPRM_BUF_SIZE ) { einval } pr_debug ( "register: magic/mask length: %i\n" , e -> size ) ; if ( USE_DEBUG ) { print_hex_dump_bytes ( KBUILD_MODNAME ": register: magic[decoded]: " , DUMP_PREFIX_NONE , e -> magic , e -> size ) ; if ( e -> mask ) { int i ; char * masked = kmalloc ( e -> size , GFP_KERNEL ) ; print_hex_dump_bytes ( KBUILD_MODNAME ": register:  mask[decoded]: " , DUMP_PREFIX_NONE , e -> mask , e -> size ) ; if ( masked ) { for ( i = 0 ; i < e -> size ; ++ i ) { masked [ i ] = e -> magic [ i ] & e -> mask [ i ] ; } print_hex_dump_bytes ( KBUILD_MODNAME ": register:  magic[masked]: " , DUMP_PREFIX_NONE , masked , e -> size ) ; kfree ( masked ) ; } } } } else { p = strchr ( p , del ) ; if ( ! p ) { einval } * p ++ = '\0' ; e -> magic = p ; p = strchr ( p , del ) ; if ( ! p ) { einval } * p ++ = '\0' ; if ( ! e -> magic [ 0 ] || strchr ( e -> magic , '/' ) ) { einval } pr_debug ( "register: extension: {%s}\n" , e -> magic ) ; p = strchr ( p , del ) ; if ( ! p ) { einval } * p ++ = '\0' ; } e -> interpreter = p ; p = strchr ( p , del ) ; if ( ! p ) { einval } * p ++ = '\0' ; if ( ! e -> interpreter [ 0 ] ) { einval } pr_debug ( "register: interpreter: {%s}\n" , e -> interpreter ) ; p = check_special_flags ( p , e ) ; if ( * p == '\n' ) { p ++ ; } if ( p != buf + count ) { einval } return e ; out return ERR_PTR ( err ) ; efault kfree ( e ) ; return ERR_PTR ( - EFAULT ) ; einval kfree ( e ) ; return ERR_PTR ( - EINVAL ) ; } 