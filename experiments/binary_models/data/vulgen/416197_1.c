void rds_ib_recv_refill ( struct rds_connection * conn , int prefill , gfp_t gfp ) { struct rds_ib_connection * ic = conn -> c_transport_data ; struct rds_ib_recv_work * recv ; struct ib_recv_wr * failed_wr ; unsigned int posted = 0 ; int ret = 0 ; bool can_wait = ! ! ( gfp & __GFP_DIRECT_RECLAIM ) ; u32 pos ; if ( ! acquire_refill ( conn ) ) { return ; } while ( ( prefill || rds_conn_up ( conn ) ) && rds_ib_ring_alloc ( & ic -> i_recv_ring , 1 , & pos ) ) { if ( pos >= ic -> i_recv_ring . w_nr ) { printk ( KERN_NOTICE "Argh - ring alloc returned pos=%u\n" , pos ) ; break ; } recv = & ic -> i_recvs [ pos ] ; ret = rds_ib_recv_refill_one ( conn , recv , gfp ) ; if ( ret ) { break ; } ret = ib_post_recv ( ic -> i_cm_id -> qp , & recv -> r_wr , & failed_wr ) ; rdsdebug ( "recv %p ibinc %p page %p addr %lu ret %d\n" , recv , recv -> r_ibinc , sg_page ( & recv -> r_frag -> f_sg ) , ( long ) ib_sg_dma_address ( ic -> i_cm_id -> device , & recv -> r_frag -> f_sg ) , ret ) ; if ( ret ) { rds_ib_conn_error ( conn , "recv post on " "%pI4 returned %d, disconnecting and " "reconnecting\n" , & conn -> c_faddr , ret ) ; break ; } posted ++ ; } if ( ret ) { rds_ib_ring_unalloc ( & ic -> i_recv_ring , 1 ) ; } release_refill ( conn ) ; if ( rds_conn_up ( conn ) && ( ( can_wait && rds_ib_ring_low ( & ic -> i_recv_ring ) ) || rds_ib_ring_empty ( & ic -> i_recv_ring ) ) ) { queue_delayed_work ( rds_wq , & conn -> c_recv_w , 1 ) ; } } 