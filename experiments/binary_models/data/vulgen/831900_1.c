static void nsm_change_state ( struct ospf_neighbor * nbr , int state ) { struct ospf_interface * oi = nbr -> oi ; struct ospf_area * vl_area = NULL ; uint8_t old_state ; old_state = nbr -> state ; nbr -> state = state ; nbr -> state_change ++ ; if ( oi -> type == OSPF_IFTYPE_VIRTUALLINK ) { vl_area = ospf_area_lookup_by_area_id ( oi -> ospf , oi -> vl_data -> vl_area_id ) ; } switch ( oi -> state ) { case ISM_DROther : case ISM_Backup : case ISM_DR : if ( ( old_state < NSM_TwoWay && state >= NSM_TwoWay ) || ( old_state >= NSM_TwoWay && state < NSM_TwoWay ) ) { OSPF_ISM_EVENT_EXECUTE ( oi , ISM_NeighborChange ) ; } break ; default : break ; } if ( ( old_state != NSM_Full && state == NSM_Full ) || ( old_state == NSM_Full && state != NSM_Full ) ) { if ( state == NSM_Full ) { oi -> full_nbrs ++ ; oi -> area -> full_nbrs ++ ; ospf_check_abr_status ( oi -> ospf ) ; if ( oi -> type == OSPF_IFTYPE_VIRTUALLINK && vl_area ) { if ( ++ vl_area -> full_vls == 1 ) { ospf_schedule_abr_task ( oi -> ospf ) ; } } } else { oi -> full_nbrs -- ; oi -> area -> full_nbrs -- ; ospf_check_abr_status ( oi -> ospf ) ; if ( oi -> type == OSPF_IFTYPE_VIRTUALLINK && vl_area ) { if ( vl_area -> full_vls > 0 ) { if ( -- vl_area -> full_vls == 0 ) { ospf_schedule_abr_task ( oi -> ospf ) ; } } } } if ( CHECK_FLAG ( oi -> ospf -> config , OSPF_LOG_ADJACENCY_DETAIL ) ) { zlog_info ( "%s:[%pI4:%s], %s ->%s): scheduling new router-LSA origination" , __func__ , & nbr -> router_id , ospf_get_name ( oi -> ospf ) , lookup_msg ( ospf_nsm_state_msg , old_state , NULL ) , lookup_msg ( ospf_nsm_state_msg , state , NULL ) ) ; } if ( ! OSPF_GR_IS_ACTIVE_HELPER ( nbr ) ) { ospf_router_lsa_update_area ( oi -> area ) ; } if ( oi -> type == OSPF_IFTYPE_VIRTUALLINK ) { vl_area = ospf_area_lookup_by_area_id ( oi -> ospf , oi -> vl_data -> vl_area_id ) ; if ( vl_area ) { ospf_router_lsa_update_area ( vl_area ) ; } } if ( ! OSPF_GR_IS_ACTIVE_HELPER ( nbr ) ) { if ( oi -> state == ISM_DR ) { if ( oi -> network_lsa_self && oi -> full_nbrs == 0 ) { ospf_lsa_flush_area ( oi -> network_lsa_self , oi -> area ) ; ospf_lsa_unlock ( & oi -> network_lsa_self ) ; oi -> network_lsa_self = NULL ; } else { ospf_network_lsa_update ( oi ) ; } } } if ( state == NSM_Full && oi -> ospf -> gr_info . restart_in_progress ) { ospf_gr_check_adjs ( oi -> ospf ) ; } } ospf_opaque_nsm_change ( nbr , old_state ) ; if ( ( old_state > NSM_ExStart ) && ( state <= NSM_ExStart ) ) { nsm_clear_adj ( nbr ) ; } if ( state == NSM_ExStart ) { if ( nbr -> dd_seqnum == 0 ) { nbr -> dd_seqnum = ( uint32_t ) frr_weak_random ( ) ; } else { nbr -> dd_seqnum ++ ; } nbr -> dd_flags = OSPF_DD_FLAG_I | OSPF_DD_FLAG_M | OSPF_DD_FLAG_MS ; if ( CHECK_FLAG ( oi -> ospf -> config , OSPF_LOG_ADJACENCY_DETAIL ) ) { zlog_info ( "%s: Initializing [DD]: %pI4 with seqnum:%x , flags:%x" , ospf_get_name ( oi -> ospf ) , & nbr -> router_id , nbr -> dd_seqnum , nbr -> dd_flags ) ; } ospf_db_desc_send ( nbr ) ; } if ( nbr -> bfd_session ) { ospf_bfd_trigger_event ( nbr , old_state , state ) ; } } 