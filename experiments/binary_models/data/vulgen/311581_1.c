static rsRetVal sessActivity ( ptcpsess_t * const pSess , int * const continue_polling ) { int lenRcv ; int lenBuf ; uchar * peerName ; int lenPeer ; int remsock = 0 ; sbool bEmitOnClose = 0 ; char rcvBuf [ 128 * 1024 ] ; int runs = 0 ; DEFiRet ; DBGPRINTF ( "imptcp: new activity on session socket %d\n" , pSess -> sock ) ; while ( runs ++ < 16 ) { lenBuf = sizeof ( rcvBuf ) ; lenRcv = recv ( pSess -> sock , rcvBuf , lenBuf , 0 ) ; if ( lenRcv > 0 ) { DBGPRINTF ( "imptcp: data(%d) on socket %d: %s\n" , lenBuf , pSess -> sock , rcvBuf ) ; CHKiRet ( DataRcvd ( pSess , rcvBuf , lenRcv ) ) ; } if ( lenRcv == 0 ) { if ( pSess -> pLstn -> pSrv -> bEmitMsgOnClose ) { prop . GetString ( pSess -> peerName , & peerName , & lenPeer ) , remsock = pSess -> sock ; bEmitOnClose = 1 ; } * continue_polling = 0 ; if ( bEmitOnClose ) { LogError ( 0 , RS_RET_PEER_CLOSED_CONN , "imptcp session %d closed by " "remote peer %s." , remsock , peerName ) ; } CHKiRet ( closeSess ( pSess ) ) ; break ; } else { DBGPRINTF ( "imptcp: error on session socket %d - closed.\n" , pSess -> sock ) ; * continue_polling = 0 ; closeSess ( pSess ) ; break ; } } finalize_it RETiRet ; } 