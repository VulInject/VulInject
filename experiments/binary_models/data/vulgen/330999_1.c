int __init dove_init_pmu ( void ) { struct device_node * np_pmu , * domains_node , * np ; struct pmu_data * pmu ; int ret , parent_irq ; np_pmu = of_find_compatible_node ( NULL , NULL , "marvell,dove-pmu" ) ; if ( ! np_pmu ) { return 0 ; } domains_node = of_get_child_by_name ( np_pmu , "domains" ) ; if ( ! domains_node ) { pr_err ( "%s: failed to find domains sub-node\n" , np_pmu -> name ) ; return 0 ; } pmu = kzalloc ( sizeof ( * pmu ) , GFP_KERNEL ) ; if ( ! pmu ) { return - ENOMEM ; } spin_lock_init ( & pmu -> lock ) ; pmu -> of_node = np_pmu ; pmu -> pmc_base = of_iomap ( pmu -> of_node , 0 ) ; pmu -> pmu_base = of_iomap ( pmu -> of_node , 1 ) ; if ( ! pmu -> pmc_base || ! pmu -> pmu_base ) { pr_err ( "%s: failed to map PMU\n" , np_pmu -> name ) ; iounmap ( pmu -> pmu_base ) ; iounmap ( pmu -> pmc_base ) ; kfree ( pmu ) ; return - ENOMEM ; } pmu_reset_init ( pmu ) ; for_each_available_child_of_node ( , ) { struct of_phandle_args args ; struct pmu_domain * domain ; domain = kzalloc ( sizeof ( * domain ) , GFP_KERNEL ) ; if ( ! domain ) { break ; } domain -> pmu = pmu ; domain -> base . name = kstrdup ( np -> name , GFP_KERNEL ) ; if ( ! domain -> base . name ) { break ; } of_property_read_u32 ( np , "marvell,pmu_pwr_mask" , & domain -> pwr_mask ) ; of_property_read_u32 ( np , "marvell,pmu_iso_mask" , & domain -> iso_mask ) ; ret = of_parse_phandle_with_args ( np , "resets" , "#reset-cells" , 0 , & args ) ; if ( ret == 0 ) { if ( args . np == pmu -> of_node ) { domain -> rst_mask = BIT ( args . args [ 0 ] ) ; } of_node_put ( args . np ) ; } __pmu_domain_register ( domain , np ) ; } parent_irq = irq_of_parse_and_map ( pmu -> of_node , 0 ) ; if ( ! parent_irq ) { pr_err ( "%s: no interrupt specified\n" , np_pmu -> name ) ; } else { ret = dove_init_pmu_irq ( pmu , parent_irq ) ; if ( ret ) { pr_err ( "dove_init_pmu_irq() failed: %d\n" , ret ) ; } } return 0 ; } 