static int dlh_probe ( struct i2c_client * client ) { const struct i2c_device_id * id = i2c_client_get_device_id ( client ) ; struct dlh_state * st ; struct iio_dev * indio_dev ; int ret ; if ( ! i2c_check_functionality ( client -> adapter , I2C_FUNC_I2C | I2C_FUNC_SMBUS_WRITE_BYTE ) ) { dev_err ( & client -> dev , "adapter doesn't support required i2c functionality\n" ) ; return - EOPNOTSUPP ; } indio_dev = devm_iio_device_alloc ( & client -> dev , sizeof ( * st ) ) ; if ( ! indio_dev ) { dev_err ( & client -> dev , "failed to allocate iio device\n" ) ; return - ENOMEM ; } i2c_set_clientdata ( client , indio_dev ) ; st = iio_priv ( indio_dev ) ; st -> info = dlh_info_tbl [ id -> driver_data ] ; st -> client = client ; st -> use_interrupt = false ; indio_dev -> name = id -> name ; indio_dev -> info = & dlh_info ; indio_dev -> modes = INDIO_DIRECT_MODE ; indio_dev -> num_channels = ARRAY_SIZE ( dlh_channels ) ; if ( client -> irq > 0 ) { ret = devm_request_threaded_irq ( & client -> dev , client -> irq , dlh_interrupt , NULL , IRQF_TRIGGER_RISING | IRQF_ONESHOT , id -> name , indio_dev ) ; if ( ret ) { dev_err ( & client -> dev , "failed to allocate threaded irq" ) ; return ret ; } st -> use_interrupt = true ; init_completion ( & st -> completion ) ; } ret = devm_iio_triggered_buffer_setup ( & client -> dev , indio_dev , NULL , & dlh_trigger_handler , NULL ) ; if ( ret ) { dev_err ( & client -> dev , "failed to setup iio buffer\n" ) ; return ret ; } ret = devm_iio_device_register ( & client -> dev , indio_dev ) ; if ( ret ) { dev_err ( & client -> dev , "failed to register iio device\n" ) ; } return ret ; } 