void resolver_dispatch_request ( struct imsgproc * proc , struct imsg * imsg ) { const char * hostname , * servname ; struct session * s ; struct asr_query * q ; struct addrinfo hints ; struct sockaddr_storage ss ; struct sockaddr * sa ; uint32_t reqid ; int flags , save_errno ; reqid = imsg -> hdr . peerid ; switch ( imsg -> hdr . type ) { case IMSG_GETADDRINFO : servname = NULL ; memset ( & hints , 0 , sizeof ( hints ) ) ; m_get_int ( proc , & hints . ai_flags ) ; m_get_int ( proc , & hints . ai_family ) ; m_get_int ( proc , & hints . ai_socktype ) ; m_get_int ( proc , & hints . ai_protocol ) ; m_get_string ( proc , & hostname ) ; m_get_string ( proc , & servname ) ; m_end ( proc ) ; s = NULL ; q = NULL ; if ( ( s = calloc ( 1 , sizeof ( * s ) ) ) && ( q = getaddrinfo_async ( hostname , servname , & hints , NULL ) ) && ( event_asr_run ( q , resolver_getaddrinfo_cb , s ) ) ) { s -> reqid = reqid ; s -> proc = proc ; break ; } save_errno = errno ; if ( q ) { asr_abort ( q ) ; } if ( s ) { free ( s ) ; } m_create ( proc , IMSG_GETADDRINFO_END , reqid , 0 , - 1 ) ; m_add_int ( proc , EAI_SYSTEM ) ; m_add_int ( proc , save_errno ) ; break ; case IMSG_GETNAMEINFO : sa = ( sockaddr * ) & ss ; m_get_sockaddr ( proc , sa ) ; m_get_int ( proc , & flags ) ; m_end ( proc ) ; s = NULL ; q = NULL ; if ( ( s = calloc ( 1 , sizeof ( * s ) ) ) && ( s -> host = malloc ( NI_MAXHOST ) ) && ( s -> serv = malloc ( NI_MAXSERV ) ) && ( q = getnameinfo_async ( sa , sa -> sa_len , s -> host , NI_MAXHOST , s -> serv , NI_MAXSERV , flags , NULL ) ) && ( event_asr_run ( q , resolver_getnameinfo_cb , s ) ) ) { s -> reqid = reqid ; s -> proc = proc ; break ; } save_errno = errno ; if ( q ) { asr_abort ( q ) ; } if ( s ) { free ( s -> host ) ; free ( s -> serv ) ; free ( s ) ; } m_create ( proc , IMSG_GETNAMEINFO , reqid , 0 , - 1 ) ; m_add_int ( proc , EAI_SYSTEM ) ; m_add_int ( proc , save_errno ) ; m_add_string ( proc , NULL ) ; m_add_string ( proc , NULL ) ; m_close ( proc ) ; break ; default : fatalx ( "%s: %s" , __func__ , log_fmt_imsgtype ( imsg -> hdr . type ) ) ; } } 