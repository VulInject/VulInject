void meson_vclk_setup ( struct meson_drm * priv , unsigned int target , unsigned int vclk_freq , unsigned int venc_freq , unsigned int dac_freq , bool hdmi_use_enci ) { unsigned int freq ; unsigned int hdmi_tx_div ; unsigned int venc_div ; if ( target == MESON_VCLK_TARGET_CVBS ) { return ; } hdmi_tx_div = vclk_freq / dac_freq ; if ( hdmi_tx_div == 0 ) { pr_err ( "Fatal Error, invalid HDMI-TX freq %d\n" , dac_freq ) ; return ; } venc_div = vclk_freq / venc_freq ; if ( venc_div == 0 ) { pr_err ( "Fatal Error, invalid HDMI venc freq %d\n" , venc_freq ) ; return ; } switch ( vclk_freq ) { case 54000 : if ( hdmi_use_enci ) { freq = MESON_VCLK_HDMI_ENCI_54000 ; } else { freq = MESON_VCLK_HDMI_DDR_54000 ; } break ; case 74250 : freq = MESON_VCLK_HDMI_74250 ; break ; case 148500 : if ( dac_freq != 148500 ) { freq = MESON_VCLK_HDMI_DDR_148500 ; } else { freq = MESON_VCLK_HDMI_148500 ; } break ; case 297000 : freq = MESON_VCLK_HDMI_297000 ; break ; case 594000 : freq = MESON_VCLK_HDMI_594000 ; break ; default : pr_err ( "Fatal Error, invalid HDMI vclk freq %d\n" , vclk_freq ) ; return ; } regmap_update_bits ( priv -> hhi , HHI_HDMI_CLK_CNTL , CTS_HDMI_SYS_SEL_MASK , 0 ) ; regmap_update_bits ( priv -> hhi , HHI_HDMI_CLK_CNTL , CTS_HDMI_SYS_DIV_MASK , 0 ) ; regmap_update_bits ( priv -> hhi , HHI_HDMI_CLK_CNTL , CTS_HDMI_SYS_EN , CTS_HDMI_SYS_EN ) ; meson_hdmi_pll_set ( priv , params [ freq ] . pll_base_freq , params [ freq ] . pll_od1 , params [ freq ] . pll_od2 , params [ freq ] . pll_od3 ) ; meson_vid_pll_set ( priv , params [ freq ] . vid_pll_div ) ; regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL , VCLK_SEL_MASK , 0 ) ; regmap_update_bits ( priv -> hhi , HHI_VID_CLK_DIV , VCLK_DIV_MASK , params [ freq ] . vclk_div - 1 ) ; switch ( hdmi_tx_div ) { case 1 : regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL , VCLK_DIV1_EN , VCLK_DIV1_EN ) ; regmap_update_bits ( priv -> hhi , HHI_HDMI_CLK_CNTL , HDMI_TX_PIXEL_SEL_MASK , 0 ) ; break ; case 2 : regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL , VCLK_DIV2_EN , VCLK_DIV2_EN ) ; regmap_update_bits ( priv -> hhi , HHI_HDMI_CLK_CNTL , HDMI_TX_PIXEL_SEL_MASK , 1 << HDMI_TX_PIXEL_SEL_SHIFT ) ; break ; case 4 : regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL , VCLK_DIV4_EN , VCLK_DIV4_EN ) ; regmap_update_bits ( priv -> hhi , HHI_HDMI_CLK_CNTL , HDMI_TX_PIXEL_SEL_MASK , 2 << HDMI_TX_PIXEL_SEL_SHIFT ) ; break ; case 6 : regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL , VCLK_DIV6_EN , VCLK_DIV6_EN ) ; regmap_update_bits ( priv -> hhi , HHI_HDMI_CLK_CNTL , HDMI_TX_PIXEL_SEL_MASK , 3 << HDMI_TX_PIXEL_SEL_SHIFT ) ; break ; case 12 : regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL , VCLK_DIV12_EN , VCLK_DIV12_EN ) ; regmap_update_bits ( priv -> hhi , HHI_HDMI_CLK_CNTL , HDMI_TX_PIXEL_SEL_MASK , 4 << HDMI_TX_PIXEL_SEL_SHIFT ) ; break ; } regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL2 , HDMI_TX_PIXEL_EN , HDMI_TX_PIXEL_EN ) ; switch ( venc_div ) { case 1 : regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL , VCLK_DIV1_EN , VCLK_DIV1_EN ) ; if ( hdmi_use_enci ) { regmap_update_bits ( priv -> hhi , HHI_VID_CLK_DIV , CTS_ENCI_SEL_MASK , 0 ) ; } else { regmap_update_bits ( priv -> hhi , HHI_VID_CLK_DIV , CTS_ENCP_SEL_MASK , 0 ) ; } break ; case 2 : regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL , VCLK_DIV2_EN , VCLK_DIV2_EN ) ; if ( hdmi_use_enci ) { regmap_update_bits ( priv -> hhi , HHI_VID_CLK_DIV , CTS_ENCI_SEL_MASK , 1 << CTS_ENCI_SEL_SHIFT ) ; } else { regmap_update_bits ( priv -> hhi , HHI_VID_CLK_DIV , CTS_ENCP_SEL_MASK , 1 << CTS_ENCP_SEL_SHIFT ) ; } break ; case 4 : regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL , VCLK_DIV4_EN , VCLK_DIV4_EN ) ; if ( hdmi_use_enci ) { regmap_update_bits ( priv -> hhi , HHI_VID_CLK_DIV , CTS_ENCI_SEL_MASK , 2 << CTS_ENCI_SEL_SHIFT ) ; } else { regmap_update_bits ( priv -> hhi , HHI_VID_CLK_DIV , CTS_ENCP_SEL_MASK , 2 << CTS_ENCP_SEL_SHIFT ) ; } break ; case 6 : regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL , VCLK_DIV6_EN , VCLK_DIV6_EN ) ; if ( hdmi_use_enci ) { regmap_update_bits ( priv -> hhi , HHI_VID_CLK_DIV , CTS_ENCI_SEL_MASK , 3 << CTS_ENCI_SEL_SHIFT ) ; } else { regmap_update_bits ( priv -> hhi , HHI_VID_CLK_DIV , CTS_ENCP_SEL_MASK , 3 << CTS_ENCP_SEL_SHIFT ) ; } break ; case 12 : regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL , VCLK_DIV12_EN , VCLK_DIV12_EN ) ; if ( hdmi_use_enci ) { regmap_update_bits ( priv -> hhi , HHI_VID_CLK_DIV , CTS_ENCI_SEL_MASK , 4 << CTS_ENCI_SEL_SHIFT ) ; } else { regmap_update_bits ( priv -> hhi , HHI_VID_CLK_DIV , CTS_ENCP_SEL_MASK , 4 << CTS_ENCP_SEL_SHIFT ) ; } break ; } if ( hdmi_use_enci ) { regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL2 , CTS_ENCI_EN , CTS_ENCI_EN ) ; } else { regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL2 , CTS_ENCP_EN , CTS_ENCP_EN ) ; } regmap_update_bits ( priv -> hhi , HHI_VID_CLK_CNTL , VCLK_EN , VCLK_EN ) ; } 