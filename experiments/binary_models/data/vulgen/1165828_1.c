elf32_hppa_finish_dynamic_sections ( , ) { bfd * dynobj ; struct elf32_hppa_link_hash_table * htab ; asection * sdyn ; htab = hppa_link_hash_table ( info ) ; dynobj = htab -> elf . dynobj ; sdyn = bfd_get_section_by_name ( dynobj , ".dynamic" ) ; if ( htab -> elf . dynamic_sections_created ) { Elf32_External_Dyn * dyncon , * dynconend ; if ( sdyn == NULL ) { abort ( ) ; } dyncon = ( Elf32_External_Dyn * ) sdyn -> contents ; dynconend = ( Elf32_External_Dyn * ) ( sdyn -> contents + sdyn -> _raw_size ) ; for ( ; dyncon < dynconend ; dyncon ++ ) { Elf_Internal_Dyn dyn ; asection * s ; bfd_elf32_swap_dyn_in ( dynobj , dyncon , & dyn ) ; switch ( dyn . d_tag ) { default : continue ; case DT_PLTGOT : dyn . d_un . d_ptr = elf_gp ( output_bfd ) ; break ; case DT_JMPREL : s = htab -> srelplt ; dyn . d_un . d_ptr = s -> output_section -> vma + s -> output_offset ; break ; case DT_PLTRELSZ : s = htab -> srelplt ; dyn . d_un . d_val = s -> _raw_size ; break ; case DT_RELASZ : s = htab -> srelplt ; if ( s == NULL ) { continue ; } dyn . d_un . d_val -= s -> _raw_size ; break ; case DT_RELA : s = htab -> srelplt ; if ( s == NULL ) { continue ; } if ( dyn . d_un . d_ptr != s -> output_section -> vma + s -> output_offset ) { continue ; } dyn . d_un . d_ptr += s -> _raw_size ; break ; } } } if ( htab -> sgot != NULL && htab -> sgot -> _raw_size != 0 ) { bfd_put_32 ( output_bfd , sdyn ?sdyn -> output_section -> vma + sdyn -> output_offset : 0 , htab -> sgot -> contents ) ; memset ( htab -> sgot -> contents + GOT_ENTRY_SIZE , 0 , GOT_ENTRY_SIZE ) ; elf_section_data ( htab -> sgot -> output_section ) -> this_hdr . sh_entsize = GOT_ENTRY_SIZE ; } if ( htab -> splt != NULL && htab -> splt -> _raw_size != 0 ) { elf_section_data ( htab -> splt -> output_section ) -> this_hdr . sh_entsize = PLT_ENTRY_SIZE ; if ( htab -> need_plt_stub ) { memcpy ( htab -> splt -> contents + htab -> splt -> _raw_size - sizeof ( plt_stub ) , plt_stub , sizeof ( plt_stub ) ) ; if ( ( htab -> splt -> output_offset + htab -> splt -> output_section -> vma + htab -> splt -> _raw_size ) != ( htab -> sgot -> output_offset + htab -> sgot -> output_section -> vma ) ) { * _bfd_error_handler ( _ ( ".got section not immediately after .plt section" ) ) ; return FALSE ; } } } return TRUE ; } 