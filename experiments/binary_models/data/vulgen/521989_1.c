core_create_function_syms ( ) bfd * cbfd ATTRIBUTE_UNUSED ; { bfd_vma min_vma = ~ ( bfd_vma ) 0 ; bfd_vma max_vma = 0 ; int class long i , found , skip ; unsigned int j ; symtab . len = 0 ; for ( i = 0 ; i < core_num_syms ; ++ i ) { if ( ! core_sym_class ( core_syms [ i ] ) ) { continue ; } skip = 0 ; for ( j = 0 ; j < symbol_map_count ; j ++ ) { if ( ! strcmp ( core_syms [ i ] -> name , symbol_map [ j ] . function_name ) ) { if ( j > 0 && ! strcmp ( symbol_map [ j ] . file_name , symbol_map [ j - 1 ] . file_name ) ) { skip = 1 ; } break ; } } if ( ! skip ) { ++ symtab . len ; } } if ( symtab . len == 0 ) { fprintf ( stderr , _ ( "%s: file `%s' has no symbols\n" ) , whoami , a_out_name ) ; done ( 1 ) ; } symtab . base = ( Sym * ) xmalloc ( ( symtab . len + 2 ) * sizeof ( Sym ) ) ; symtab . limit = symtab . base ; for ( i = 0 ; i < core_num_syms ; ++ i ) { asection * sym_sec ; class = core_sym_class ( core_syms [ i ] ) ; if ( ! class ) { DBG ( AOUTDEBUG , printf ( "[core_create_function_syms] rejecting: 0x%lx %s\n" , ( unsigned long ) core_syms [ i ] -> value , core_syms [ i ] -> name ) ) ; continue ; } skip = 0 ; found = 0 ; for ( j = 0 ; j < symbol_map_count ; j ++ ) { if ( ! strcmp ( core_syms [ i ] -> name , symbol_map [ j ] . function_name ) ) { if ( j > 0 && ! strcmp ( symbol_map [ j ] . file_name , symbol_map [ j - 1 ] . file_name ) ) { skip = 1 ; } else { found = j ; } break ; } } if ( skip ) { continue ; } sym_init ( symtab . limit ) ; sym_sec = core_syms [ i ] -> section ; symtab . limit -> addr = core_syms [ i ] -> value ; if ( sym_sec ) { symtab . limit -> addr += bfd_get_section_vma ( sym_sec -> owner , sym_sec ) ; } if ( symbol_map_count && ! strcmp ( core_syms [ i ] -> name , symbol_map [ found ] . function_name ) ) { symtab . limit -> name = symbol_map [ found ] . file_name ; symtab . limit -> mapped = 1 ; } else { symtab . limit -> name = core_syms [ i ] -> name ; symtab . limit -> mapped = 0 ; } { const char * filename , * func_name ; if ( get_src_info ( symtab . limit -> addr , & filename , & func_name , & symtab . limit -> line_num ) ) { symtab . limit -> file = source_file_lookup_path ( filename ) ; if ( strcmp ( symtab . limit -> name , func_name ) != 0 ) { DBG ( AOUTDEBUG , printf ( "[core_create_function_syms: rej %s (maps to %s)\n" , symtab . limit -> name , func_name ) ) ; continue ; } } } symtab . limit -> is_func = TRUE ; symtab . limit -> is_bb_head = TRUE ; min_vma = MIN ( symtab . limit -> addr , min_vma ) ; if ( sym_sec ) { max_vma = MAX ( bfd_get_section_vma ( sym_sec -> owner , sym_sec ) + bfd_section_size ( sym_sec -> owner , sym_sec ) - 1 , max_vma ) ; } else { max_vma = MAX ( symtab . limit -> addr , max_vma ) ; } if ( symtab . limit -> name [ 0 ] == 'm' && discard_underscores && strcmp ( symtab . limit -> name , "main" ) == 0 ) { discard_underscores = 0 ; } DBG ( AOUTDEBUG , printf ( "[core_create_function_syms] %ld %s 0x%lx\n" , ( long ) ( symtab . limit - symtab . base ) , symtab . limit -> name , ( unsigned long ) symtab . limit -> addr ) ) ; ++ symtab . limit ; } sym_init ( symtab . limit ) ; symtab . limit -> name = "<locore>" ; symtab . limit -> addr = 0 ; symtab . limit -> end_addr = min_vma - 1 ; ++ symtab . limit ; sym_init ( symtab . limit ) ; symtab . limit -> name = "<hicore>" ; symtab . limit -> addr = max_vma + 1 ; symtab . limit -> end_addr = ~ ( bfd_vma ) 0 ; ++ symtab . limit ; symtab . len = symtab . limit - symtab . base ; symtab_finalize ( & symtab ) ; } 