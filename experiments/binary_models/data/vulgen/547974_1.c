vm_address_t get_kernel_base ( task_t ___task ) { kern_return_t ret ; task_t task ; vm_region_submap_info_data_64_t info ; ut64 size ; mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT_64 ; unsigned int depth ; ut64 addr = KERNEL_LOWER ; int count ; ret = task_for_pid ( mach_task_self ( ) , 0 , & task ) ; if ( ret != KERN_SUCCESS ) { return 0 ; } ut64 naddr ; eprintf ( "%d vs %d\n" , task , ___task ) ; for ( count = 128 ; count ; count -- ) { naddr = addr ; ret = vm_region_recurse_64 ( task , ( vm_address_t * ) & naddr , ( vm_size_t * ) & size , & depth , ( vm_region_info_t ) & info , & info_count ) ; if ( ret != KERN_SUCCESS ) { break ; } if ( size < 1 ) { break ; } if ( addr == naddr ) { addr += size ; continue ; } eprintf ( "0x%08" PFMT64x " size 0x%08" PFMT64x " perm 0x%x\n" , ( ut64 ) addr , ( ut64 ) size , info . max_protection ) ; if ( size > 1024 * 1024 * 1024 ) { return addr + IMAGE_OFFSET ; } addr += size ; } return ( vm_address_t ) 0 ; } 