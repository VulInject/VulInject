static irqreturn_t ps3rom_interrupt ( int irq , void * data ) { struct ps3_storage_device * dev = data ; struct Scsi_Host * host ; struct ps3rom_private * priv ; struct scsi_cmnd * cmd ; int res ; u64 tag , status ; unsigned char sense_key , asc , ascq ; res = lv1_storage_get_async_status ( dev -> sbd . dev_id , & tag , & status ) ; if ( tag != dev -> tag ) { dev_err ( & dev -> sbd . core , "%s:%u: tag mismatch, got %llx, expected %llx\n" , __func__ , __LINE__ , tag , dev -> tag ) ; } if ( res ) { dev_err ( & dev -> sbd . core , "%s:%u: res=%d status=0x%llx\n" , __func__ , __LINE__ , res , status ) ; return IRQ_HANDLED ; } host = ps3_system_bus_get_drvdata ( & dev -> sbd ) ; priv = shost_priv ( host ) ; cmd = priv -> curr_cmd ; if ( ! status ) { if ( cmd -> sc_data_direction == DMA_FROM_DEVICE ) { int len ; len = scsi_sg_copy_from_buffer ( cmd , dev -> bounce_buf , dev -> bounce_size ) ; } cmd -> result = DID_OK << 16 ; done } if ( cmd -> cmnd [ 0 ] == REQUEST_SENSE ) { dev_err ( & dev -> sbd . core , "%s:%u: end error without autosense\n" , __func__ , __LINE__ ) ; cmd -> result = DID_ERROR << 16 | SAM_STAT_CHECK_CONDITION ; done } if ( decode_lv1_status ( status , & sense_key , & asc , & ascq ) ) { cmd -> result = DID_ERROR << 16 ; done } scsi_build_sense_buffer ( 0 , cmd -> sense_buffer , sense_key , asc , ascq ) ; cmd -> result = SAM_STAT_CHECK_CONDITION ; done priv -> curr_cmd = NULL ; cmd -> scsi_done ( cmd ) ; return IRQ_HANDLED ; } static struct scsi_host_template ps3rom_host_template = { . name = DEVICE_NAME . slave_configure = ps3rom_slave_configure . queuecommand = ps3rom_queuecommand . can_queue = 1 . this_id = 7 . sg_tablesize = SG_ALL . emulated = 1 . max_sectors = PS3ROM_MAX_SECTORS . use_clustering = ENABLE_CLUSTERING . module = THIS_MODULE } ; 