static VALUE int_ossl_asn1_decode0_cons ( unsigned char * * pp , long max_len , long length , long * offset , int depth , int yield , int j , int tag , VALUE tc , long * num_read ) { VALUE value , asn1data , ary ; int indefinite ; long available_len , off = * offset ; indefinite = ( j == 0x21 ) ; ary = rb_ary_new ( ) ; available_len = indefinite ?max_len : length ; while ( available_len > 0 ) { long inner_read = 0 ; value = ossl_asn1_decode0 ( pp , available_len , & off , depth + 1 , yield , & inner_read ) ; * num_read += inner_read ; available_len -= inner_read ; rb_ary_push ( ary , value ) ; } if ( tc == sym_UNIVERSAL ) { VALUE args [ 4 ] ; if ( tag == V_ASN1_SEQUENCE || tag == V_ASN1_SET ) { asn1data = rb_obj_alloc ( * ossl_asn1_info [ tag ] . klass ) ; } else { asn1data = rb_obj_alloc ( cASN1Constructive ) ; } args [ 0 ] = ary ; args [ 1 ] = INT2NUM ( tag ) ; args [ 2 ] = Qnil ; args [ 3 ] = tc ; ossl_asn1_initialize ( 4 , args , asn1data ) ; } else { asn1data = rb_obj_alloc ( cASN1Data ) ; ossl_asn1data_initialize ( asn1data , ary , INT2NUM ( tag ) , tc ) ; } if ( indefinite ) { ossl_asn1_set_indefinite_length ( asn1data , Qtrue ) ; } else { ossl_asn1_set_indefinite_length ( asn1data , Qfalse ) ; } * offset = off ; return asn1data ; } 