static int cmd_af ( RCore * core , const char * input ) { r_cons_break_timeout ( r_config_get_i ( core -> config , "anal.timeout" ) ) ; switch ( input [ 1 ] ) { case '-' : if ( ! input [ 2 ] ) { cmd_af ( core , "f-$$" ) ; r_core_anal_undefine ( core , core -> offset ) ; } if ( ! strcmp ( input + 2 , "*" ) ) { RAnalFunction * f ; RListIter * iter , * iter2 ; r_list_foreach_safe ( , , , ) { ut64 addr = f -> addr ; r_anal_del_jmprefs ( core -> anal , f ) ; r_core_anal_undefine ( core , addr ) ; } } else { ut64 addr = input [ 2 ] ?r_num_math ( core -> num , input + 2 ) : core -> offset ; r_core_anal_undefine ( core , addr ) ; } break ; case 'j' : { RList * blocks = r_anal_get_blocks_in ( core -> anal , core -> offset ) ; RAnalBlock * block = r_list_first ( blocks ) ; if ( block && ! r_list_empty ( block -> fcns ) ) { char * args = strdup ( input + 2 ) ; RList * argv = r_str_split_list ( args , " " , 0 ) ; ut64 table = r_num_math ( core -> num , r_list_get_n ( argv , 1 ) ) ; ut64 sz = r_num_math ( core -> num , r_list_get_n ( argv , 2 ) ) ; ut64 elements = r_num_math ( core -> num , r_list_get_n ( argv , 3 ) ) ; ut64 seg = r_num_math ( core -> num , r_list_get_n ( argv , 4 ) ) ; int depth = 50 ; try_walkthrough_jmptbl ( core -> anal , r_list_first ( block -> fcns ) , block , depth , core -> offset , 0 , table , seg , sz , elements , 0 , false ) ; free ( args ) ; } else { R_LOG_ERROR ( "No function defined here" ) ; } r_list_free ( blocks ) ; } break ; case 'a' : if ( input [ 2 ] == 'l' ) { int show_args = r_config_get_i ( core -> config , "dbg.funcarg" ) ; if ( show_args ) { r_core_print_func_args ( core ) ; } } else { r_core_print_func_args ( core ) ; } break ; case 'd' : { ut64 addr = 0 ; if ( input [ 2 ] == '?' ) { eprintf ( "afd [offset]\n" ) ; } if ( input [ 2 ] == ' ' ) { addr = r_num_math ( core -> num , input + 2 ) ; } else { addr = core -> offset ; } RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , addr , 0 ) ; if ( input [ 2 ] == 'j' ) { PJ * pj = r_core_pj_new ( core ) ; if ( ! pj ) { return false ; } pj_o ( pj ) ; if ( fcn ) { pj_ks ( pj , "name" , fcn -> name ) ; pj_ki ( pj , "offset" , ( int ) ( addr - fcn -> addr ) ) ; } pj_end ( pj ) ; r_cons_println ( pj_string ( pj ) ) ; pj_free ( pj ) ; } else { if ( fcn ) { if ( fcn -> addr != addr ) { r_cons_printf ( "%s + %d\n" , fcn -> name , ( int ) ( addr - fcn -> addr ) ) ; } else { r_cons_println ( fcn -> name ) ; } } else { eprintf ( "afd: Cannot find function\n" ) ; } } } break ; case 'u' : if ( input [ 2 ] == '?' ) { r_core_cmd_help ( core , help_msg_afu ) ; break ; } if ( input [ 2 ] != ' ' ) { R_LOG_ERROR ( "Missing argument" ) ; return false ; } ut64 addr = core -> offset ; ut64 addr_end = r_num_math ( core -> num , input + 2 ) ; if ( addr_end < addr ) { R_LOG_ERROR ( "Invalid address ranges" ) ; } else { ut64 a , b ; const char * c ; a = r_config_get_i ( core -> config , "anal.from" ) ; b = r_config_get_i ( core -> config , "anal.to" ) ; c = r_config_get ( core -> config , "anal.limits" ) ; r_config_set_i ( core -> config , "anal.from" , addr ) ; r_config_set_i ( core -> config , "anal.to" , addr_end ) ; r_config_set_b ( core -> config , "anal.limits" , true ) ; RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , addr , 0 ) ; if ( fcn ) { r_anal_function_resize ( fcn , addr_end - addr ) ; } r_core_anal_fcn ( core , addr , UT64_MAX , R_ANAL_REF_TYPE_NULL , 1 ) ; fcn = r_anal_get_fcn_in ( core -> anal , addr , 0 ) ; if ( fcn ) { r_anal_function_resize ( fcn , addr_end - addr ) ; } r_config_set_i ( core -> config , "anal.from" , a ) ; r_config_set_i ( core -> config , "anal.to" , b ) ; r_config_set ( core -> config , "anal.limits" , r_str_get ( c ) ) ; } break ; case '+' : { if ( input [ 2 ] == '?' || ! input [ 2 ] ) { r_core_cmd_help ( core , help_msg_af_plus ) ; break ; } char * ptr = input [ 2 ] ?r_str_trim_dup ( input + 2 ) : r_str_newf ( "0x%" PFMT64x , core -> offset ) ; const char * ptr2 ; int n = r_str_word_set0 ( ptr ) ; const char * name = NULL ; char * hname = NULL ; ut64 addr = UT64_MAX ; RAnalDiff * diff = NULL ; int type = R_ANAL_FCN_TYPE_FCN ; if ( n > 0 ) { switch ( n ) { case 4 : ptr2 = r_str_word_get0 ( ptr , 3 ) ; if ( ! ( diff = r_anal_diff_new ( ) ) ) { R_LOG_ERROR ( "Cannot initialize RAnalDiff" ) ; free ( ptr ) ; return false ; } if ( ptr2 [ 0 ] == 'm' ) { diff -> type = R_ANAL_DIFF_TYPE_MATCH ; } if ( ptr2 [ 0 ] == 'u' ) { diff -> type = R_ANAL_DIFF_TYPE_UNMATCH ; } case 3 : ptr2 = r_str_word_get0 ( ptr , 2 ) ; if ( strchr ( ptr2 , 'l' ) ) { type = R_ANAL_FCN_TYPE_LOC ; } if ( strchr ( ptr2 , 'i' ) ) { type = R_ANAL_FCN_TYPE_IMP ; } if ( strchr ( ptr2 , 's' ) ) { type = R_ANAL_FCN_TYPE_SYM ; } else { type = R_ANAL_FCN_TYPE_FCN ; } case 2 : name = r_str_word_get0 ( ptr , 1 ) ; case 1 : addr = r_num_math ( core -> num , r_str_word_get0 ( ptr , 0 ) ) ; if ( ! name ) { RFlagItem * fi = r_flag_get_at ( core -> flags , addr , false ) ; name = hname = ( fi ) ?strdup ( fi -> name ) : r_str_newf ( "fcn.%08" PFMT64x , addr ) ; } break ; } RAnalFunction * fcn = r_anal_create_function ( core -> anal , name , addr , type , diff ) ; if ( ! fcn ) { R_LOG_ERROR ( "Cannot add function '%s' (duplicated) at 0x%08" PFMT64x , name , addr ) ; } free ( hname ) ; } r_anal_diff_free ( diff ) ; free ( ptr ) ; } break ; case 'o' : switch ( input [ 2 ] ) { case '?' : eprintf ( "Usage: afo[?sj] ([name|offset])\n" ) ; break ; case 'j' : { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_NULL ) ; PJ * pj = r_core_pj_new ( core ) ; if ( ! pj ) { return false ; } pj_o ( pj ) ; if ( fcn ) { pj_ki ( pj , "address" , fcn -> addr ) ; } pj_end ( pj ) ; r_cons_println ( pj_string ( pj ) ) ; pj_free ( pj ) ; } break ; case '\0' : { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_NULL ) ; if ( fcn ) { r_cons_printf ( "0x%08" PFMT64x "\n" , fcn -> addr ) ; } } break ; case 's' : { ut64 addr = core -> offset ; RListIter * iter ; RList * list = r_anal_get_functions_in ( core -> anal , addr ) ; RAnalFunction * fcn ; r_list_foreach ( , , ) { r_cons_printf ( "= 0x%08" PFMT64x "\n" , fcn -> addr ) ; } r_list_free ( list ) ; } break ; case ' ' : { RAnalFunction * fcn ; ut64 addr = r_num_math ( core -> num , input + 3 ) ; if ( addr == 0LL ) { fcn = r_anal_get_function_byname ( core -> anal , input + 3 ) ; } else { fcn = r_anal_get_fcn_in ( core -> anal , addr , R_ANAL_FCN_TYPE_NULL ) ; } if ( fcn ) { r_cons_printf ( "0x%08" PFMT64x "\n" , fcn -> addr ) ; } } break ; } break ; case 'i' : switch ( input [ 2 ] ) { case '?' : r_core_cmd_help ( core , help_msg_afi ) ; break ; case '.' : { ut64 addr = core -> offset ; if ( input [ 3 ] == ' ' ) { addr = r_num_math ( core -> num , input + 3 ) ; } RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , addr , R_ANAL_FCN_TYPE_NULL ) ; if ( fcn ) { r_cons_printf ( "%s\n" , fcn -> name ) ; } } break ; case 'l' : if ( input [ 3 ] == '?' ) { help_msg_afll [ 1 ] = "afil" ; r_core_cmd_help ( core , help_msg_afll ) ; break ; } case 'i' : if ( input [ 3 ] == '-' ) { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_NULL ) ; if ( fcn ) { r_list_free ( fcn -> imports ) ; fcn -> imports = NULL ; } } if ( input [ 3 ] == ' ' ) { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_NULL ) ; if ( fcn ) { if ( ! fcn -> imports ) { fcn -> imports = r_list_newf ( ( RListFree ) free ) ; } r_list_append ( fcn -> imports , r_str_trim_dup ( input + 4 ) ) ; } else { R_LOG_ERROR ( "No function found" ) ; } } else { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_NULL ) ; if ( fcn && fcn -> imports ) { char * imp ; RListIter * iter ; r_list_foreach ( , , ) { r_cons_printf ( "%s\n" , imp ) ; } } } break ; case 's' : if ( input [ 3 ] == 'a' ) { __core_cmd_anal_fcn_allstats ( core , input + 4 ) ; } else { sdb_free ( __core_cmd_anal_fcn_stats ( core , input + 3 ) ) ; } break ; case 'j' : case '*' : r_core_anal_fcn_list ( core , input + 3 , input + 2 ) ; break ; case 'p' : { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_NULL ) ; if ( fcn ) { r_cons_printf ( "is-pure: %s\n" , r_str_bool ( r_anal_function_purity ( fcn ) ) ) ; } } break ; case '=' : case 'q' : { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_NULL ) ; if ( fcn ) { int nargs = r_type_func_args_count ( core -> anal -> sdb_types , 0 ) ; int nvars = r_anal_var_count_locals ( fcn ) ; int nins = r_anal_function_instrcount ( fcn ) ; int ebbs = 0 ; int edges = r_anal_function_count_edges ( fcn , & ebbs ) ; r_anal_function_count_edges ( fcn , NULL ) ; r_cons_printf ( "0x%08" PFMT64x " : %s\n" , fcn -> addr , fcn -> name ) ; char * sig = r_core_cmd_strf ( core , "afcf @ 0x%" PFMT64x , fcn -> addr ) ; if ( sig ) { r_str_trim ( sig ) ; r_cons_printf ( "  sign:  %s\n" , sig ) ; free ( sig ) ; } r_cons_printf ( "  stack: 0x%08x (vars:%d args:%d)\n" , fcn -> maxstack , nvars , nargs ) ; r_cons_printf ( "  size:  %d (0x%08" PFMT64x " .. 0x%08" PFMT64x ")\n" , ( int ) r_anal_function_realsize ( fcn ) , r_anal_function_min_addr ( fcn ) , r_anal_function_max_addr ( fcn ) ) ; r_cons_printf ( "  nbbs:  %d edges:%d ebbs:%d ninstr:%d\n" , r_list_length ( fcn -> bbs ) , edges , ebbs , nins ) ; r_cons_printf ( "  cost:  %d complexity:%d\n" , r_anal_function_cost ( fcn ) , r_anal_function_complexity ( fcn ) ) ; r_cons_printf ( "  attr:  " ) ; if ( r_anal_function_islineal ( fcn ) ) { r_cons_printf ( "lineal" ) ; } if ( fcn -> is_noreturn ) { r_cons_printf ( "noreturn" ) ; } r_cons_newline ( ) ; } } break ; case ' ' : case 0 : { const char * arg = input [ 2 ] ?input + 2 : "" ; const char * sec = "\x01" ; r_core_anal_fcn_list ( core , arg , sec ) ; } break ; default : r_core_cmd_help ( core , help_msg_afi ) ; } break ; case 'l' : switch ( input [ 2 ] ) { case '?' : r_core_cmd_help ( core , help_msg_afl ) ; break ; case 'x' : switch ( input [ 3 ] ) { default : case '?' : r_core_cmd_help ( core , help_msg_aflx ) ; return true ; case 'v' : case '*' : case 0 : { ut64 addr = faddr ( core , core -> offset , NULL ) ; RList * xrefs = r_anal_xrefs_get ( core -> anal , addr ) ; Sdb * db = sdb_new0 ( ) ; RListIter * iter ; RAnalRef * ref ; r_list_foreach ( , , ) { bool nr = false ; ut64 fa = faddr ( core , ref -> addr , & nr ) ; char * key = r_str_newf ( "0x%08" PFMT64x , fa ) ; sdb_array_add_num ( db , key , ref -> addr , 0 ) ; } SdbList * keys = sdb_foreach_list ( db , true ) ; SdbListIter * liter ; SdbKv * kv ; bool rad = input [ 3 ] == '*' ; bool verbose = input [ 3 ] == 'v' ; ls_foreach ( , , ) { const char * key = sdbkv_key ( kv ) ; const char * value = sdbkv_value ( kv ) ; if ( verbose ) { ut64 fcn_xref_addr = r_num_get ( NULL , key ) ; RAnalFunction * xref = r_anal_get_fcn_in ( core -> anal , fcn_xref_addr , R_ANAL_FCN_TYPE_ANY ) ; if ( xref ) { r_cons_printf ( "%s %s\n" , xref -> name , value ) ; continue ; } } if ( rad ) { r_cons_printf ( "s %s;af-;af;s-\n" , ( const char * ) kv -> base . key ) ; r_cons_printf ( "s %s;af-;af;s-\n" , key ) ; continue ; } r_cons_printf ( "%s %s\n" , key , value ) ; } sdb_free ( db ) ; ls_free ( keys ) ; break ; } case 'j' : cmd_aflxj ( core ) ; break ; } break ; case 's' : switch ( input [ 3 ] ) { default : case '?' : r_core_cmd_help ( core , help_msg_afls ) ; return true ; case 0 : case 'a' : core -> anal -> fcns -> sorted = false ; r_list_sort ( core -> anal -> fcns , cmpaddr ) ; break ; case 'b' : core -> anal -> fcns -> sorted = false ; r_list_sort ( core -> anal -> fcns , cmpbbs ) ; break ; case 's' : core -> anal -> fcns -> sorted = false ; r_list_sort ( core -> anal -> fcns , cmpsize ) ; break ; case 'n' : core -> anal -> fcns -> sorted = false ; r_list_sort ( core -> anal -> fcns , cmpname ) ; break ; } break ; case 'l' : if ( input [ 3 ] == '?' ) { help_msg_afll [ 1 ] = "afll" ; r_core_cmd_help ( core , help_msg_afll ) ; break ; } case ',' : case 't' : case 'j' : case 'q' : case 'm' : case '+' : case '=' : case '*' : case '.' : r_core_anal_fcn_list ( core , NULL , input + 2 ) ; break ; case 'c' : r_cons_printf ( "%d\n" , r_list_length ( core -> anal -> fcns ) ) ; break ; case ' ' : case 0 : r_core_anal_fcn_list ( core , NULL , "o" ) ; break ; default : r_core_cmd_help ( core , help_msg_afl ) ; break ; } break ; case 's' : switch ( input [ 2 ] ) { case '!' : { char * sig = r_core_cmd_str ( core , "afs" ) ; char * data = r_core_editor ( core , NULL , sig ) ; if ( sig && data ) { r_core_cmdf ( core , "\"\"afs %s" , data ) ; } free ( sig ) ; free ( data ) ; break ; } case 'r' : { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; if ( fcn ) { char * type = r_str_newf ( "type.%s" , input + 4 ) ; if ( sdb_exists ( core -> anal -> sdb_types , type ) ) { char * query = r_str_newf ( "anal/types/func.%s.ret=%s" , fcn -> name , input + 4 ) ; sdb_querys ( core -> sdb , NULL , 0 , query ) ; free ( query ) ; } free ( type ) ; } else { R_LOG_ERROR ( "There's no function defined here" ) ; } break ; } case '*' : cmd_afsr ( core , input + 2 ) ; break ; case 'j' : cmd_afsj ( core , input + 2 ) ; break ; case 0 : case ' ' : { ut64 addr = core -> offset ; RAnalFunction * f ; const char * arg = r_str_trim_head_ro ( input + 2 ) ; if ( ( f = r_anal_get_fcn_in ( core -> anal , addr , R_ANAL_FCN_TYPE_NULL ) ) ) { if ( R_STR_ISNOTEMPTY ( arg ) ) { char * fcnstr = r_str_newf ( "%s;" , arg ) , * fcnstr_copy = strdup ( fcnstr ) ; char * fcnname_aux = strtok ( fcnstr_copy , "(" ) ; r_str_trim_tail ( fcnname_aux ) ; const char * ls = r_str_lchr ( fcnname_aux , ' ' ) ; char * fcnname = strdup ( ls ?ls : fcnname_aux ) ; if ( fcnname ) { if ( strcmp ( f -> name , fcnname ) ) { ( void ) __setFunctionName ( core , addr , fcnname , false ) ; f = r_anal_get_fcn_in ( core -> anal , addr , - 1 ) ; } r_anal_str_to_fcn ( core -> anal , f , fcnstr ) ; } free ( fcnname ) ; free ( fcnstr_copy ) ; free ( fcnstr ) ; } else { char * str = r_anal_function_get_signature ( f ) ; if ( str ) { r_cons_println ( str ) ; free ( str ) ; } } } else { R_LOG_ERROR ( "No function defined at 0x%08" PFMT64x , addr ) ; } break ; } default : r_core_cmd_help ( core , help_msg_afs ) ; break ; } break ; case 'm' : if ( input [ 2 ] == '?' ) { r_core_cmd_help ( core , help_msg_afm ) ; break ; } r_core_anal_fcn_merge ( core , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; break ; case 'M' : r_core_anal_fmap ( core , input + 1 ) ; break ; case 'v' : var_cmd ( core , input + 2 ) ; break ; case 't' : type_cmd ( core , input + 2 ) ; break ; case 'C' : if ( input [ 2 ] == 'c' ) { RAnalFunction * fcn ; if ( ( fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , 0 ) ) ) { r_cons_printf ( "%i\n" , r_anal_function_complexity ( fcn ) ) ; } else { R_LOG_ERROR ( "Cannot find function at 0x08%" PFMT64x , core -> offset ) ; } } if ( input [ 2 ] == 'l' ) { RAnalFunction * fcn ; if ( ( fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , 0 ) ) ) { r_cons_printf ( "%d\n" , r_anal_function_loops ( fcn ) ) ; } else { R_LOG_ERROR ( "Cannot find function at 0x08%" PFMT64x , core -> offset ) ; } } if ( input [ 2 ] == '?' ) { r_core_cmd_help ( core , help_msg_afC ) ; } else { afCc ( core , r_str_trim_head_ro ( input + 2 ) ) ; } break ; case 'c' : { RAnalFunction * fcn = NULL ; if ( ! input [ 2 ] || input [ 2 ] == ' ' || input [ 2 ] == 'i' || input [ 2 ] == 'r' || input [ 2 ] == 'a' ) { fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , 0 ) ; if ( ! fcn ) { R_LOG_ERROR ( "afc: Cannot find function here" ) ; break ; } } switch ( input [ 2 ] ) { case '\0' : r_cons_println ( fcn -> cc ) ; break ; case ' ' : { char * cc = r_str_trim_dup ( input + 3 ) ; if ( ! r_anal_cc_exist ( core -> anal , cc ) ) { const char * asmOs = r_config_get ( core -> config , "asm.os" ) ; R_LOG_ERROR ( "afc: Unknown calling convention '%s' for '%s'. See afcl for available types" , cc , asmOs ) ; } else { fcn -> cc = r_str_constpool_get ( & core -> anal -> constpool , cc ) ; } free ( cc ) ; } break ; case 'i' : cmd_afci ( core , fcn ) ; break ; case 'f' : cmd_anal_fcn_sig ( core , input + 3 ) ; break ; case 'k' : cmd_afck ( core , NULL ) ; break ; case 'l' : if ( input [ 3 ] == '?' ) { r_core_cmd_help ( core , help_msg_afc ) ; } else { cmd_tcc ( core , input + 3 ) ; } break ; case 'o' : { char * dbpath = r_str_trim_dup ( input + 3 ) ; if ( R_STR_ISNOTEMPTY ( dbpath ) && r_file_exists ( dbpath ) ) { Sdb * db = sdb_new ( 0 , dbpath , 0 ) ; if ( db ) { sdb_merge ( core -> anal -> sdb_cc , db ) ; sdb_close ( db ) ; sdb_free ( db ) ; } } else { eprintf ( "Usage: afco [dbpath] - open calling conventions defined in local file.\n" ) ; } free ( dbpath ) ; break ; } case 'r' : { int i ; PJ * pj = NULL ; bool json = input [ 3 ] == 'j' ; if ( json ) { pj = r_core_pj_new ( core ) ; if ( ! pj ) { return false ; } pj_o ( pj ) ; } char * cmd = r_str_newf ( "cc.%s.ret" , fcn -> cc ) ; const char * regname = sdb_const_get ( core -> anal -> sdb_cc , cmd , 0 ) ; if ( regname ) { if ( json ) { pj_ks ( pj , "ret" , regname ) ; } else { r_cons_printf ( "%s: %s\n" , cmd , regname ) ; } } free ( cmd ) ; if ( json ) { pj_ka ( pj , "args" ) ; } for ( i = 0 ; i < R_ANAL_CC_MAXARG ; i ++ ) { cmd = r_str_newf ( "cc.%s.arg%d" , fcn -> cc , i ) ; regname = sdb_const_get ( core -> anal -> sdb_cc , cmd , 0 ) ; if ( regname ) { if ( json ) { pj_s ( pj , regname ) ; } else { r_cons_printf ( "%s: %s\n" , cmd , regname ) ; } } free ( cmd ) ; } if ( json ) { pj_end ( pj ) ; } cmd = r_str_newf ( "cc.%s.self" , fcn -> cc ) ; regname = sdb_const_get ( core -> anal -> sdb_cc , cmd , 0 ) ; if ( regname ) { if ( json ) { pj_ks ( pj , "self" , regname ) ; } else { r_cons_printf ( "%s: %s\n" , cmd , regname ) ; } } free ( cmd ) ; cmd = r_str_newf ( "cc.%s.error" , fcn -> cc ) ; regname = sdb_const_get ( core -> anal -> sdb_cc , cmd , 0 ) ; if ( regname ) { if ( json ) { pj_ks ( pj , "error" , regname ) ; } else { r_cons_printf ( "%s: %s\n" , cmd , regname ) ; } } free ( cmd ) ; if ( json ) { pj_end ( pj ) ; r_cons_println ( pj_string ( pj ) ) ; pj_free ( pj ) ; } break ; } case 'R' : { int i ; char * cc = r_core_cmd_str ( core , "k anal/cc/default.cc" ) ; r_str_trim ( cc ) ; for ( i = 0 ; i < 6 ; i ++ ) { char * res = r_core_cmd_strf ( core , "k anal/cc/cc.%s.arg%d" , cc , i ) ; r_str_trim_nc ( res ) ; if ( * res ) { char * row = r_core_cmd_strf ( core , "drr~%s 0x" , res ) ; r_str_trim ( row ) ; r_cons_printf ( "arg[%d] %s\n" , i , row ) ; free ( row ) ; } free ( res ) ; } free ( cc ) ; break ; } case '?' : default : r_core_cmd_help ( core , help_msg_afc ) ; } break ; } case 'B' : if ( input [ 2 ] == ' ' ) { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , 0 ) ; if ( fcn ) { int nbits = atoi ( input + 3 ) ; int obits = core -> anal -> config -> bits ; if ( nbits > 0 ) { r_anal_hint_set_bits ( core -> anal , r_anal_function_min_addr ( fcn ) , nbits ) ; r_anal_hint_set_bits ( core -> anal , r_anal_function_max_addr ( fcn ) , obits ) ; fcn -> bits = nbits ; } else { r_anal_hint_unset_bits ( core -> anal , r_anal_function_min_addr ( fcn ) ) ; fcn -> bits = 0 ; } } else { R_LOG_ERROR ( "afB: Cannot find function to set bits at 0x%08" PFMT64x , core -> offset ) ; } } else { eprintf ( "Usage: afB [bits] # bits can be: 0, 8, 16, 32 or 64. when using 0, disables the hint\n" ) ; } break ; case 'b' : switch ( input [ 2 ] ) { case '-' : anal_fcn_del_bb ( core , r_str_trim_head_ro ( input + 3 ) ) ; break ; case 'o' : afbo ( core ) ; break ; case 'e' : anal_bb_edge ( core , r_str_trim_head_ro ( input + 3 ) ) ; break ; case 'F' : { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_NULL ) ; if ( fcn ) { RAnalBlock * bb = r_anal_function_bbget_in ( core -> anal , fcn , core -> offset ) ; if ( bb ) { if ( input [ 3 ] ) { int n = atoi ( input + 3 ) ; bb -> folded = n ; } else { bb -> folded = ! bb -> folded ; } } else { r_warn_if_reached ( ) ; } } } break ; case 0 : case ' ' : case 'q' : case 'r' : case '=' : case '*' : case 'j' : case 't' : anal_fcn_list_bb ( core , input + 2 , false ) ; break ; case 'i' : anal_fcn_list_bb ( core , input + 2 , true ) ; break ; case '.' : anal_fcn_list_bb ( core , input [ 2 ] ?" $$" : input + 2 , true ) ; break ; case '+' : cmd_afbplus ( core , input + 3 ) ; break ; case 'c' : cmd_afbc ( core , r_str_trim_head_ro ( input + 3 ) ) ; break ; default : r_core_cmd_help ( core , help_msg_afb ) ; break ; } break ; case 'n' : switch ( input [ 2 ] ) { case 's' : if ( input [ 3 ] == 'j' ) { free ( r_core_anal_fcn_autoname ( core , core -> offset , 1 , input [ 3 ] ) ) ; } else { free ( r_core_anal_fcn_autoname ( core , core -> offset , 1 , 0 ) ) ; } break ; case 'a' : if ( input [ 3 ] == '?' ) { r_core_cmd_help ( core , help_msg_afna ) ; break ; } char * name = r_core_anal_fcn_autoname ( core , core -> offset , 0 , 0 ) ; if ( name ) { r_cons_printf ( "afn %s 0x%08" PFMT64x "\n" , name , core -> offset ) ; free ( name ) ; } break ; case '.' : case 0 : { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; if ( fcn ) { r_cons_printf ( "%s\n" , fcn -> name ) ; } } break ; case ' ' : { ut64 off = core -> offset ; char * p , * name = strdup ( r_str_trim_head_ro ( input + 3 ) ) ; if ( ( p = strchr ( name , ' ' ) ) ) { * p ++ = 0 ; off = r_num_math ( core -> num , p ) ; } if ( * name == '?' ) { eprintf ( "Usage: afn newname [off]   # set new name to given function\n" ) ; } else { if ( r_str_startswith ( name , "base64:" ) ) { char * res = ( char * ) r_base64_decode_dyn ( name + 7 , - 1 ) ; if ( res ) { free ( name ) ; name = res ; } } if ( ! * name || ! __setFunctionName ( core , off , name , false ) ) { R_LOG_ERROR ( "Cannot find function at 0x%08" PFMT64x , off ) ; } } free ( name ) ; } break ; default : r_core_cmd_help ( core , help_msg_afn ) ; break ; } break ; case 'S' : { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; if ( fcn ) { fcn -> maxstack = r_num_math ( core -> num , input + 3 ) ; } break ; } case 'e' : { RAnalFunction * fcn ; ut64 off = core -> offset ; char * p , * name = strdup ( ( input [ 2 ] && input [ 3 ] ) ?input + 3 : "" ) ; if ( ( p = strchr ( name , ' ' ) ) ) { * p = 0 ; off = r_num_math ( core -> num , p + 1 ) ; } fcn = r_anal_get_fcn_in ( core -> anal , off , R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM ) ; if ( fcn ) { RAnalBlock * b ; RListIter * iter ; RAnalRef * r ; r_list_foreach ( , , ) { r_cons_printf ( "0x%08" PFMT64x " -%c 0x%08" PFMT64x "\n" , r -> at , r -> type , r -> addr ) ; } r_list_foreach ( , , ) { int ok = 0 ; if ( b -> type == R_ANAL_BB_TYPE_LAST ) { ok = 1 ; } if ( b -> type == R_ANAL_BB_TYPE_FOOT ) { ok = 1 ; } if ( b -> jump == UT64_MAX && b -> fail == UT64_MAX ) { ok = 1 ; } if ( ok ) { r_cons_printf ( "0x%08" PFMT64x " -r\n" , b -> addr ) ; } } } else { eprintf ( "Cannot find function at 0x%08" PFMT64x "\n" , core -> offset ) ; } free ( name ) ; } break ; case 'x' : switch ( input [ 2 ] ) { case 'm' : xrefs_map ( core , input + 1 ) ; break ; case '\0' : case 'j' : case ' ' : { PJ * pj = r_core_pj_new ( core ) ; if ( input [ 2 ] == 'j' ) { pj_a ( pj ) ; } if ( ! pj ) { return false ; } { ut64 addr = ( input [ 2 ] == ' ' ) ?r_num_math ( core -> num , input + 2 ) : core -> offset ; RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , addr , R_ANAL_FCN_TYPE_NULL ) ; if ( fcn ) { ut64 oaddr = core -> offset ; RAnalRef * ref ; RListIter * iter ; RList * refs = r_anal_function_get_refs ( fcn ) ; r_list_foreach ( , , ) { if ( input [ 2 ] == 'j' ) { pj_o ( pj ) ; pj_ks ( pj , "type" , r_anal_ref_type_tostring ( ref -> type ) ) ; pj_kn ( pj , "from" , ref -> at ) ; pj_kn ( pj , "to" , ref -> addr ) ; pj_end ( pj ) ; } else { r_cons_printf ( "%c 0x%08" PFMT64x " ->" , ref -> type , ref -> at ) ; switch ( R_ANAL_REF_TYPE_MASK ( ref -> type ) ) { case R_ANAL_REF_TYPE_NULL : r_cons_printf ( "0x%08" PFMT64x " " , ref -> addr ) ; break ; case R_ANAL_REF_TYPE_CODE : case R_ANAL_REF_TYPE_JUMP : case R_ANAL_REF_TYPE_CALL : case R_ANAL_REF_TYPE_DATA : r_cons_printf ( "0x%08" PFMT64x " " , ref -> addr ) ; r_core_seek ( core , ref -> at , 1 ) ; r_core_print_disasm_instructions ( core , 0 , 1 ) ; break ; case R_ANAL_REF_TYPE_STRING : { char * s = r_core_cmd_strf ( core , "pxr 8 @ 0x%08" PFMT64x , ref -> addr ) ; char * nl = strchr ( s , '\n' ) ; if ( nl ) { * nl = 0 ; } r_cons_printf ( "%s\n" , s ) ; free ( s ) ; } break ; default : break ; } } } r_list_free ( refs ) ; r_core_seek ( core , oaddr , 1 ) ; } else { R_LOG_ERROR ( "afx: Cannot find function at 0x%08" PFMT64x , addr ) ; } } pj_free ( pj ) ; break ; } default : R_LOG_ERROR ( "Invalid command. Look at af?" ) ; break ; } break ; case 'F' : { int val = input [ 2 ] && r_num_math ( core -> num , input + 2 ) ; RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_NULL ) ; if ( fcn ) { fcn -> folded = input [ 2 ] ?val : ! fcn -> folded ; } } break ; case '?' : r_core_cmd_help ( core , help_msg_af ) ; break ; case 'r' : case ' ' : case '\0' : { bool anal_calls = r_config_get_b ( core -> config , "anal.calls" ) ; if ( input [ 0 ] && input [ 1 ] == 'r' ) { input ++ ; anal_calls = true ; } ut64 addr = core -> offset ; const char * name = NULL ; if ( input [ 0 ] && input [ 1 ] == ' ' ) { name = r_str_trim_head_ro ( input + 2 ) ; char * uaddr = strchr ( name , ' ' ) ; if ( uaddr ) { * uaddr ++ = 0 ; addr = r_num_math ( core -> num , uaddr ) ; } } r_core_af ( core , addr , name , anal_calls ) ; } break ; default : return false ; break ; } return true ; } 