int scsi_transport ( struct scsi_pkt * pkt ) { struct scsi_address * ap = P_TO_ADDR ( pkt ) ; int rval = TRAN_ACCEPT ; major_t major ; if ( ! scsi_pkt_allow_naca ) { ASSERT ( ! NACA_IS_SET ( pkt -> pkt_cdbp ) ) ; } if ( scsi_pkt_bad_alloc_msg ) { major = ddi_driver_major ( P_TO_TRAN ( pkt ) -> tran_hba_dip ) ; if ( ! BT_TEST ( scsi_pkt_bad_alloc_bitmap , major ) && ! scsi_pkt_allocated_correctly ( pkt ) ) { BT_SET ( scsi_pkt_bad_alloc_bitmap , major ) ; cmn_err ( CE_WARN , "%s: violates DDI scsi_pkt(9S) " "allocation rules" , ddi_driver_name ( P_TO_TRAN ( pkt ) -> tran_hba_dip ) ) ; } BT_SET ( scsi_pkt_bad_alloc_bitmap , major ) ; } pkt -> pkt_flags &= ~ FLAG_PKT_COMP_CALLED ; if ( ! do_polled_io && ( ( pkt -> pkt_flags & FLAG_NOINTR ) == 0 ) ) { return ( * A_TO_TRAN ( ap ) -> tran_start ) ( ap , pkt ) ; } if ( ( curthread -> t_flag & T_INTR_THREAD ) || do_polled_io ) { mutex_enter ( & scsi_flag_nointr_mutex ) ; scsi_poll_intr ++ ; mutex_exit ( & scsi_flag_nointr_mutex ) ; if ( ! do_polled_io || ( pkt -> pkt_flags & FLAG_NOINTR ) ) { return ( ( * A_TO_TRAN ( ap ) -> tran_start ) ( ap , pkt ) ) ; } else { uint_t savef ; void * savec ( ) savef = pkt -> pkt_flags ; savec = pkt -> pkt_comp ; pkt -> pkt_flags |= FLAG_NOINTR ; pkt -> pkt_comp = 0 ; rval = ( * A_TO_TRAN ( ap ) -> tran_start ) ( ap , pkt ) ; return ( TRAN_FATAL_ERROR ) ; } } else { uint_t savef ; void * savec ( ) mutex_enter ( & scsi_flag_nointr_mutex ) ; scsi_poll_user ++ ; mutex_exit ( & scsi_flag_nointr_mutex ) ; savef = pkt -> pkt_flags ; savec = pkt -> pkt_comp ; pkt -> pkt_comp = scsi_flag_nointr_comp ; pkt -> pkt_flags &= ~ FLAG_NOINTR ; pkt -> pkt_flags |= FLAG_IMMEDIATE_CB ; if ( ( rval = ( * A_TO_TRAN ( ap ) -> tran_start ) ( ap , pkt ) ) == TRAN_ACCEPT ) { mutex_enter ( & scsi_flag_nointr_mutex ) ; while ( pkt -> pkt_comp != CALLBACK_DONE ) { cv_wait ( & scsi_flag_nointr_cv , & scsi_flag_nointr_mutex ) ; } mutex_exit ( & scsi_flag_nointr_mutex ) ; } pkt -> pkt_flags = savef ; pkt -> pkt_comp = savec ; return ( rval ) ; } } 