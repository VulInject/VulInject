_test_insert_invalid ( , ) { mongoc_bulk_operation_t * bulk ; mongoc_collection_t * collection ; mongoc_client_t * client ; bson_t * bad_insert = tmp_bson ( "{'': 1}" ) ; bson_t * good_insert = tmp_bson ( "{'x': 1}" ) ; bson_t reply ; bson_error_t error ; bool r ; const char * err = "empty key" ; client = test_framework_new_default_client ( ) ; collection = get_test_collection ( client , "test_insert_validate" ) ; bulk = mongoc_collection_create_bulk_operation_with_opts ( collection , NULL ) ; BSON_ASSERT ( mongoc_collection_delete_many ( collection , tmp_bson ( NULL ) , NULL , NULL , NULL ) ) ; capture_logs ( true ) ; if ( with_opts ) { if ( invalid_first ) { r = mongoc_bulk_operation_insert_with_opts ( bulk , bad_insert , NULL , & error ) ; BSON_ASSERT ( ! r ) ; ASSERT_ERROR_CONTAINS ( error , MONGOC_ERROR_COMMAND , MONGOC_ERROR_COMMAND_INVALID_ARG , err ) ; r = mongoc_bulk_operation_insert_with_opts ( bulk , good_insert , NULL , & error ) ; ASSERT_OR_PRINT ( r , error ) ; ASSERT_CMPSIZE_T ( ( size_t ) 1 , == , bulk -> commands . len ) ; r = ( bool ) mongoc_bulk_operation_execute ( bulk , & reply , & error ) ; ASSERT_OR_PRINT ( r , error ) ; BSON_ASSERT ( ! bson_empty ( & reply ) ) ; } else { r = mongoc_bulk_operation_insert_with_opts ( bulk , good_insert , NULL , & error ) ; ASSERT_OR_PRINT ( r , error ) ; r = mongoc_bulk_operation_insert_with_opts ( bulk , bad_insert , NULL , & error ) ; BSON_ASSERT ( ! r ) ; ASSERT_ERROR_CONTAINS ( error , MONGOC_ERROR_COMMAND , MONGOC_ERROR_COMMAND_INVALID_ARG , err ) ; ASSERT_CMPSIZE_T ( ( size_t ) 1 , == , bulk -> commands . len ) ; r = ( bool ) mongoc_bulk_operation_execute ( bulk , & reply , & error ) ; ASSERT_OR_PRINT ( r , error ) ; BSON_ASSERT ( ! bson_empty ( & reply ) ) ; } } else { if ( invalid_first ) { mongoc_bulk_operation_insert ( bulk , bad_insert ) ; mongoc_bulk_operation_insert ( bulk , good_insert ) ; ASSERT_CMPSIZE_T ( ( size_t ) 0 , == , bulk -> commands . len ) ; r = ( bool ) mongoc_bulk_operation_execute ( bulk , & reply , & error ) ; BSON_ASSERT ( ! r ) ; BSON_ASSERT ( bson_empty ( & reply ) ) ; ASSERT_ERROR_CONTAINS ( error , MONGOC_ERROR_COMMAND , MONGOC_ERROR_COMMAND_INVALID_ARG , err ) ; } else { mongoc_bulk_operation_insert ( bulk , good_insert ) ; mongoc_bulk_operation_insert ( bulk , bad_insert ) ; ASSERT_CMPSIZE_T ( ( size_t ) 1 , == , bulk -> commands . len ) ; r = ( bool ) mongoc_bulk_operation_execute ( bulk , & reply , & error ) ; BSON_ASSERT ( ! r ) ; BSON_ASSERT ( bson_empty ( & reply ) ) ; ASSERT_ERROR_CONTAINS ( error , MONGOC_ERROR_COMMAND , MONGOC_ERROR_COMMAND_INVALID_ARG , err ) ; } } bson_destroy ( & reply ) ; mongoc_bulk_operation_destroy ( bulk ) ; mongoc_collection_destroy ( collection ) ; } 