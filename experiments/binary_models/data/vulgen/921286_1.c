static void chap_respond ( struct chap_client_state * cs , int id , unsigned char * pkt , int len ) { int clen , nlen ; int secret_len ; unsigned char * p ; unsigned char response [ RESP_MAX_PKTLEN ] ; char rname [ MAXNAMELEN + 1 ] ; char secret [ MAXSECRETLEN + 1 ] ; if ( ( cs -> flags & ( LOWERUP | AUTH_STARTED ) ) != ( LOWERUP | AUTH_STARTED ) ) { return ; } if ( len < 2 || len < pkt [ 0 ] + 1 ) { return ; } clen = pkt [ 0 ] ; nlen = len - ( clen + 1 ) ; slprintf ( rname , sizeof ( rname ) , "%.*v" , nlen , pkt + clen + 1 ) ; if ( explicit_remote || ( remote_name [ 0 ] != 0 && rname [ 0 ] == 0 ) ) { strlcpy ( rname , remote_name , sizeof ( rname ) ) ; } if ( ! get_secret ( 0 , cs -> name , rname , secret , & secret_len , 0 ) ) { secret_len = 0 ; warn ( "No CHAP secret found for authenticating us to %q" , rname ) ; } p = response ; MAKEHEADER ( p , PPP_CHAP ) ; p += CHAP_HDRLEN ; cs -> digest -> make_response ( p , id , cs -> name , pkt , secret , secret_len , cs -> priv ) ; clen = * p ; nlen = strlen ( cs -> name ) ; memcpy ( p + clen + 1 , cs -> name , nlen ) ; p = response + PPP_HDRLEN ; len = CHAP_HDRLEN + clen + 1 + nlen ; p [ 0 ] = CHAP_RESPONSE ; p [ 1 ] = id ; p [ 2 ] = len >> 8 ; p [ 3 ] = len ; output ( 0 , response , PPP_HDRLEN + len ) ; } 