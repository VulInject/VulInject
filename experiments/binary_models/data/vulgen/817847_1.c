static int upload_dma_data ( struct soundscape * s , const unsigned char * data , size_t size ) { unsigned long flags ; struct snd_dma_buffer dma ; int ret ; unsigned char val ; spin_lock_irqsave ( & s -> lock , flags ) ; val = sscape_read_unsafe ( s -> io_base , GA_HMCTL_REG ) ; sscape_write_unsafe ( s -> io_base , GA_HMCTL_REG , val & 0x3f ) ; val = ( s -> chip -> dma1 << 4 ) | DMA_8BIT ; sscape_write_unsafe ( s -> io_base , GA_DMAA_REG , val ) ; sscape_write_unsafe ( s -> io_base , GA_DMAB_REG , 0x20 ) ; val = sscape_read_unsafe ( s -> io_base , GA_HMCTL_REG ) ; sscape_write_unsafe ( s -> io_base , GA_HMCTL_REG , val | 0x80 ) ; while ( size != 0 ) { unsigned long len ; len = min ( size , dma . bytes ) ; memcpy ( dma . area , data , len ) ; data += len ; size -= len ; snd_dma_program ( s -> chip -> dma1 , dma . addr , len , DMA_MODE_WRITE ) ; sscape_start_dma_unsafe ( s -> io_base , GA_DMAA_REG ) ; if ( ! sscape_wait_dma_unsafe ( s -> io_base , GA_DMAA_REG , 5000 ) ) { spin_unlock_irqrestore ( & s -> lock , flags ) ; snd_printk ( KERN_ERR "sscape: DMA upload has timed out\n" ) ; ret = - EAGAIN ; _release_dma } } set_host_mode_unsafe ( s -> io_base ) ; outb ( 0x0 , s -> io_base ) ; val = sscape_read_unsafe ( s -> io_base , GA_HMCTL_REG ) ; sscape_write_unsafe ( s -> io_base , GA_HMCTL_REG , val | 0x40 ) ; spin_unlock_irqrestore ( & s -> lock , flags ) ; ret = 0 ; if ( ! obp_startup_ack ( s , 5000 ) ) { snd_printk ( KERN_ERR "sscape: No response " "from on-board processor after upload\n" ) ; ret = - EAGAIN ; } if ( ! host_startup_ack ( s , 5000 ) ) { snd_printk ( KERN_ERR "sscape: SoundScape failed to initialise\n" ) ; ret = - EAGAIN ; } _release_dma sscape_write ( s , GA_DMAA_REG , ( s -> ic_type == IC_OPUS ?0x40 : 0x70 ) ) ; free_dmabuf ( & dma ) ; return ret ; } 