static void options_callback ( int option , char * optarg ) { char * s , * temp_arg , * ps_ptr , * ps_arg ; switch ( option ) { case 'u' : ++ includeufn ; break ; case 't' : ++ vals2tmp ; break ; case 'U' : ++ produce_file_urls ; break ; case 'e' : ++ minimize_base64 ; break ; case 'A' : ++ attrsonly ; break ; case 'L' : break ; case 'r' : ldif = 0 ; break ; case 'o' : ldif = 0 ; break ; case 'o' : ldif = 0 ; break ; case 'B' : ++ allow_binary ; ldif = 0 ; break ; case '1' : write_ldif_version = 0 ; break ; case 's' : if ( strncasecmp ( optarg , "base" , 4 ) == 0 ) { scope = LDAP_SCOPE_BASE ; } if ( strncasecmp ( optarg , "one" , 3 ) == 0 ) { scope = LDAP_SCOPE_ONELEVEL ; } if ( strncasecmp ( optarg , "sub" , 3 ) == 0 ) { scope = LDAP_SCOPE_SUBTREE ; } else { fprintf ( stderr , gettext ( "scope should be base, one, or sub\n" ) ) ; usage ( ) ; } break ; case 'a' : if ( strncasecmp ( optarg , "never" , 5 ) == 0 ) { deref = LDAP_DEREF_NEVER ; } if ( strncasecmp ( optarg , "search" , 5 ) == 0 ) { deref = LDAP_DEREF_SEARCHING ; } if ( strncasecmp ( optarg , "find" , 4 ) == 0 ) { deref = LDAP_DEREF_FINDING ; } if ( strncasecmp ( optarg , "always" , 6 ) == 0 ) { deref = LDAP_DEREF_ALWAYS ; } else { fprintf ( stderr , gettext ( "alias deref should be never, search, find, or always\n" ) ) ; usage ( ) ; } break ; case 'F' : sep = strdup ( optarg ) ; ldif = 0 ; break ; case 'c' : if ( optarg && optarg [ 0 ] == '\0' ) { get_effectiverights_control_target_dn = NULL ; do_effective_rights_control = 1 ; } if ( strlen ( optarg ) < 3 || ( strncasecmp ( optarg , "dn:" , 3 ) != 0 ) ) { fprintf ( stderr , gettext ( "-c wrong format--should be \"\" or \"dn:...\".\n" "\"dn:\" means anonymous user." ) ) ; usage ( ) ; } else { get_effectiverights_control_target_dn = strdup ( optarg ) ; do_effective_rights_control = 1 ; } break ; case 'X' : get_effectiverights_control_attrlist = get_effectiverights_attrlist ( optarg ) ; do_effective_rights_control = 1 ; break ; case 'b' : base = strdup ( optarg ) ; break ; case 'l' : timelimit = atoi ( optarg ) ; break ; case 'x' : server_sort = 1 ; break ; case 'z' : sizelimit = atoi ( optarg ) ; break ; case 'S' : ldap_charray_add ( & sortattr , strdup ( optarg ) ) ; break ; case 'T' : fold = 0 ; break ; case 'G' : use_vlv ++ ; s = strchr ( optarg , VLV_PARAM_SEP ) ; if ( s != NULL ) { vlv_before = atoi ( optarg ) ; s ++ ; vlv_after = atoi ( s ) ; s = strchr ( s , VLV_PARAM_SEP ) ; else { fprintf ( stderr , gettext ( "Illegal 'after' paramater for virtual list\n" ) ) ; exit ( LDAP_PARAM_ERROR ) ; } } else { fprintf ( stderr , gettext ( "Illegal 'before' paramater for virtual list\n" ) ) ; exit ( LDAP_PARAM_ERROR ) ; } break ; case 'C' : use_psearch ++ ; if ( ( ps_arg = strdup ( optarg ) ) == NULL ) { perror ( "strdup" ) ; exit ( LDAP_NO_MEMORY ) ; } ps_ptr = strtok ( ps_arg , ":" ) ; if ( ps_ptr == NULL || ( strcasecmp ( ps_ptr , "ps" ) ) ) { fprintf ( stderr , gettext ( "Invalid argument for -C\n" ) ) ; usage ( ) ; } if ( NULL != ( ps_ptr = strtok ( NULL , ":" ) ) ) { if ( ( temp_arg = strdup ( ps_ptr ) ) == NULL ) { perror ( "strdup" ) ; exit ( LDAP_NO_MEMORY ) ; } } else { fprintf ( stderr , gettext ( "Invalid argument for -C\n" ) ) ; usage ( ) ; } if ( NULL != ( ps_ptr = strtok ( NULL , ":" ) ) ) { if ( ( changesonly = ldaptool_boolean_str2value ( ps_ptr , 0 ) ) == - 1 ) { fprintf ( stderr , gettext ( "Invalid option value: %s\n" ) , ps_ptr ) ; usage ( ) ; } } if ( NULL != ( ps_ptr = strtok ( NULL , ":" ) ) ) { if ( ( return_echg_ctls = ldaptool_boolean_str2value ( ps_ptr , 0 ) ) == - 1 ) { fprintf ( stderr , gettext ( "Invalid option value: %s\n" ) , ps_ptr ) ; usage ( ) ; } } if ( ( ps_ptr = strtok ( temp_arg , "," ) ) == NULL ) { usage ( ) ; } else { while ( ps_ptr ) { if ( ( strcasecmp ( ps_ptr , "add" ) ) == 0 ) { chgtype |= LDAP_CHANGETYPE_ADD ; } if ( ( strcasecmp ( ps_ptr , "delete" ) ) == 0 ) { chgtype |= LDAP_CHANGETYPE_DELETE ; } if ( ( strcasecmp ( ps_ptr , "modify" ) ) == 0 ) { chgtype |= LDAP_CHANGETYPE_MODIFY ; } if ( ( strcasecmp ( ps_ptr , "moddn" ) ) == 0 ) { chgtype |= LDAP_CHANGETYPE_MODDN ; } if ( ( strcasecmp ( ps_ptr , "any" ) ) == 0 ) { chgtype = LDAP_CHANGETYPE_ANY ; } else { fprintf ( stderr , gettext ( "Unknown changetype: %s\n" ) , ps_ptr ) ; usage ( ) ; } ps_ptr = strtok ( NULL , "," ) ; } } break ; default : usage ( ) ; break ; } } 