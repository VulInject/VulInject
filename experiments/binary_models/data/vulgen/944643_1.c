enum ia_css_err sh_css_param_update_isp_params ( struct ia_css_pipe * curr_pipe , struct ia_css_isp_parameters * params , bool commit , struct ia_css_pipe * pipe_in ) { enum ia_css_err err = IA_CSS_SUCCESS ; hrt_vaddress cpy ; int i ; unsigned int raw_bit_depth = 10 ; unsigned int isp_pipe_version = SH_CSS_ISP_PIPE_VERSION_1 ; bool acc_cluster_params_changed = false ; unsigned int thread_id , pipe_num ; ( void ) acc_cluster_params_changed ; assert ( curr_pipe != NULL ) ; IA_CSS_ENTER_PRIVATE ( "pipe=%p, isp_parameters_id=%d" , pipe_in , params -> isp_parameters_id ) ; raw_bit_depth = ia_css_stream_input_format_bits_per_pixel ( curr_pipe -> stream ) ; if ( ! commit ) { IA_CSS_LEAVE_ERR_PRIVATE ( err ) ; return err ; } for ( i = 0 ; i < curr_pipe -> stream -> num_pipes ; i ++ ) { struct ia_css_pipe * pipe ; struct sh_css_ddr_address_map * cur_map ; struct sh_css_ddr_address_map_size * cur_map_size ; struct ia_css_isp_parameter_set_info isp_params_info ; struct ia_css_pipeline * pipeline ; struct ia_css_pipeline_stage * stage ; enum sh_css_queue_id queue_id ; ( void ) stage ; pipe = curr_pipe -> stream -> pipes [ i ] ; pipeline = ia_css_pipe_get_pipeline ( pipe ) ; pipe_num = ia_css_pipe_get_pipe_num ( pipe ) ; isp_pipe_version = ia_css_pipe_get_isp_pipe_version ( pipe ) ; ia_css_pipeline_get_sp_thread_id ( pipe_num , & thread_id ) ; ia_css_query_internal_queue_id ( params -> output_frame ?IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET : IA_CSS_BUFFER_TYPE_PARAMETER_SET , thread_id , & queue_id ) ; ia_css_query_internal_queue_id ( IA_CSS_BUFFER_TYPE_PARAMETER_SET , thread_id , & queue_id ) ; if ( ! sh_css_sp_is_running ( ) ) { err = IA_CSS_ERR_RESOURCE_NOT_AVAILABLE ; break ; } cur_map = & params -> pipe_ddr_ptrs [ pipeline -> pipe_id ] ; cur_map_size = & params -> pipe_ddr_ptrs_size [ pipeline -> pipe_id ] ; { err = ia_css_process_zoom_and_motion ( params , pipeline -> stages ) ; if ( err != IA_CSS_SUCCESS ) { return err ; } } if ( pipe_in && ( pipe != pipe_in ) ) { IA_CSS_LOG ( "skipping pipe %p" , pipe ) ; continue ; } for ( stage = pipeline -> stages ; stage ; stage = stage -> next ) { unsigned mem ; if ( ! stage || ! stage -> binary ) { continue ; } process_kernel_parameters ( pipeline -> pipe_id , stage , params , isp_pipe_version , raw_bit_depth ) ; err = sh_css_params_write_to_ddr_internal ( pipe , pipeline -> pipe_id , params , stage , cur_map , cur_map_size ) ; if ( err != IA_CSS_SUCCESS ) { break ; } for ( mem = 0 ; mem < IA_CSS_NUM_MEMORIES ; mem ++ ) { params -> isp_mem_params_changed [ pipeline -> pipe_id ] [ stage -> stage_num ] [ mem ] = false ; } } if ( err != IA_CSS_SUCCESS ) { break ; } if ( params -> isp_params_changed ) { reallocate_buffer ( & cur_map -> isp_param , & cur_map_size -> isp_param , cur_map_size -> isp_param , true , & err ) ; if ( err != IA_CSS_SUCCESS ) { break ; } sh_css_update_isp_params_to_ddr ( params , cur_map -> isp_param ) ; } err = ref_sh_css_ddr_address_map ( cur_map , & isp_params_info . mem_map ) ; if ( err != IA_CSS_SUCCESS ) { break ; } isp_params_info . isp_parameters_id = params -> isp_parameters_id ; isp_params_info . output_frame_ptr = ( params -> output_frame ) ?params -> output_frame -> data : mmgr_NULL ; err = write_ia_css_isp_parameter_set_info_to_ddr ( & isp_params_info , & cpy ) ; IA_CSS_LOG ( "queue param set %x to %d" , cpy , thread_id ) ; err = ia_css_bufq_enqueue_buffer ( thread_id , queue_id , ( uint32_t ) cpy ) ; if ( IA_CSS_SUCCESS != err ) { free_ia_css_isp_parameter_set_info ( cpy ) ; IA_CSS_LOG ( "pfp: FAILED to add config id %d for OF %d to q %d on thread %d" , isp_params_info . isp_parameters_id , isp_params_info . output_frame_ptr , queue_id , thread_id ) ; break ; } else { g_param_buffer_enqueue_count ++ ; assert ( g_param_buffer_enqueue_count < g_param_buffer_dequeue_count + 50 ) ; ia_css_save_latest_paramset_ptr ( pipe , cpy ) ; if ( ! sh_css_sp_is_running ( ) ) { IA_CSS_LEAVE_ERR_PRIVATE ( IA_CSS_ERR_RESOURCE_NOT_AVAILABLE ) ; return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE ; } ia_css_bufq_enqueue_psys_event ( IA_CSS_PSYS_SW_EVENT_BUFFER_ENQUEUED , ( uint8_t ) thread_id , ( uint8_t ) queue_id , 0 ) ; IA_CSS_LOG ( "pfp: added config id %d for OF %d to q %d on thread %d" , isp_params_info . isp_parameters_id , isp_params_info . output_frame_ptr , queue_id , thread_id ) ; } ia_css_dequeue_param_buffers ( ) ; params -> pipe_dvs_6axis_config_changed [ pipeline -> pipe_id ] = false ; } params -> isp_params_changed = false ; params -> sc_table_changed = false ; params -> dis_coef_table_changed = false ; params -> dvs2_coef_table_changed = false ; params -> morph_table_changed = false ; params -> dz_config_changed = false ; params -> motion_config_changed = false ; params -> shading_settings_changed = false ; memset ( & params -> config_changed [ 0 ] , 0 , sizeof ( params -> config_changed ) ) ; IA_CSS_LEAVE_ERR_PRIVATE ( err ) ; return err ; } 