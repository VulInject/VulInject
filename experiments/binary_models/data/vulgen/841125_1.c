wchar_t s_int [ ] M_MB_L ( "int" ) ; ; wchar_t s_length [ ] M_MB_L ( "length" ) ; ; wchar_t s_log [ ] M_MB_L ( "log" ) ; ; wchar_t s_split [ ] M_MB_L ( "split" ) ; ; wchar_t s_sprintf [ ] M_MB_L ( "sprintf" ) ; ; wchar_t s_sqrt [ ] M_MB_L ( "sqrt" ) ; ; wchar_t s_substr [ ] M_MB_L ( "substr" ) ; ; wchar_t s_rand [ ] M_MB_L ( "rand" ) ; ; wchar_t s_srand [ ] M_MB_L ( "srand" ) ; ; wchar_t s_sin [ ] M_MB_L ( "sin" ) ; ; wchar_t s_cos [ ] M_MB_L ( "cos" ) ; ; wchar_t s_atan2 [ ] M_MB_L ( "atan2" ) ; ; wchar_t s_sub [ ] M_MB_L ( "sub" ) ; ; wchar_t s_gsub [ ] M_MB_L ( "gsub" ) ; ; wchar_t s_match [ ] M_MB_L ( "match" ) ; ; wchar_t s_system [ ] M_MB_L ( "system" ) ; ; wchar_t s_ord [ ] M_MB_L ( "ord" ) ; ; wchar_t s_toupper [ ] M_MB_L ( "toupper" ) ; ; wchar_t s_tolower [ ] M_MB_L ( "tolower" ) ; ; wchar_t s_asort [ ] M_MB_L ( "asort" ) ; ; wchar_t s_close [ ] M_MB_L ( "close" ) ; ; wchar_t redelim ; uchar_t inprint ; uchar_t funparm ; uchar_t splitdone ; uint npattern ; uint nfield ; uint fcount ; uint phase ; uint running = 0 ; uchar_t catterm ; uint lexlast = '\n' ; uint lineno = 0 ; uchar_t doing_begin ; uchar_t begin_getline ; uchar_t needsplit ; uchar_t needenviron ; ushort slevel ; ushort loopexit ; wchar_t radixpoint ; REGEXP resep ; wchar_t * linebuf = NULL ; size_t lbuflen ; char interr [ ] "internal execution tree error at E string" ; ; char nomem [ ] "insufficient memory for string storage" ; ; NODE * symtab [ NBUCKET ] ; NODE * yytree ; NODE * freelist ; wchar_t * ( * awkrecord ) ANSI ( ( wchar_t * , int , FILE * ) ) = defrecord ; wchar_t NODE * constant ; NODE * const0 ; NODE * const1 ; NODE * constundef ; NODE * field0 ; NODE * incNR ; NODE * incFNR ; NODE * clrFNR ; NODE * ARGVsubi ; NODE * varNR ; NODE * varFNR ; NODE * varNF ; NODE * varOFMT ; NODE * varCONVFMT ; NODE * varOFS ; NODE * varORS ; NODE * varFS ; NODE * varRS ; NODE * varARGC ; NODE * varSUBSEP ; NODE * varENVIRON ; NODE * varSYMTAB ; NODE * varFILENAME ; NODE * curnode ; NODE * inc_oper ; NODE * asn_oper ; 