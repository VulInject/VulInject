static int rockchip_pm_domain_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct device_node * np = dev -> of_node ; struct device_node * node ; struct device * parent ; struct rockchip_pmu * pmu ; const struct of_device_id * match ; const struct rockchip_pmu_info * pmu_info ; int error ; if ( ! np ) { dev_err ( dev , "device tree node not found\n" ) ; return - ENODEV ; } match = of_match_device ( dev -> driver -> of_match_table , dev ) ; if ( ! match || ! match -> data ) { dev_err ( dev , "missing pmu data\n" ) ; return - EINVAL ; } pmu_info = match -> data ; pmu = devm_kzalloc ( dev , struct_size ( pmu , domains , pmu_info -> num_domains ) , GFP_KERNEL ) ; if ( ! pmu ) { return - ENOMEM ; } pmu -> dev = & pdev -> dev ; pmu -> info = pmu_info ; pmu -> genpd_data . domains = pmu -> domains ; pmu -> genpd_data . num_domains = pmu_info -> num_domains ; parent = dev -> parent ; if ( ! parent ) { dev_err ( dev , "no parent for syscon devices\n" ) ; return - ENODEV ; } pmu -> regmap = syscon_node_to_regmap ( parent -> of_node ) ; if ( IS_ERR ( pmu -> regmap ) ) { dev_err ( dev , "no regmap available\n" ) ; return PTR_ERR ( pmu -> regmap ) ; } if ( pmu_info -> core_power_transition_time ) { rockchip_configure_pd_cnt ( pmu , pmu_info -> core_pwrcnt_offset , pmu_info -> core_power_transition_time ) ; } if ( pmu_info -> gpu_pwrcnt_offset ) { rockchip_configure_pd_cnt ( pmu , pmu_info -> gpu_pwrcnt_offset , pmu_info -> gpu_power_transition_time ) ; } error = - ENODEV ; mutex_lock ( & dmc_pmu_mutex ) ; for_each_available_child_of_node ( , ) { error = rockchip_pm_add_one_domain ( pmu , node ) ; if ( error ) { dev_err ( dev , "failed to handle node %pOFn: %d\n" , node , error ) ; of_node_put ( node ) ; err_out } error = rockchip_pm_add_subdomain ( pmu , node ) ; if ( error < 0 ) { dev_err ( dev , "failed to handle subdomain node %pOFn: %d\n" , node , error ) ; of_node_put ( node ) ; err_out } } if ( error ) { dev_dbg ( dev , "no power domains defined\n" ) ; err_out } error = of_genpd_add_provider_onecell ( np , & pmu -> genpd_data ) ; if ( error ) { dev_err ( dev , "failed to add provider: %d\n" , error ) ; err_out } if ( ! WARN_ON_ONCE ( dmc_pmu ) ) { dmc_pmu = pmu ; } mutex_unlock ( & dmc_pmu_mutex ) ; return 0 ; err_out rockchip_pm_domain_cleanup ( pmu ) ; mutex_unlock ( & dmc_pmu_mutex ) ; return error ; } 