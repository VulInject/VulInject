static void ibmvscsis_post_disconnect ( struct scsi_info * vscsi , uint new_state , uint flag_bits ) { uint state ; switch { case UNCONFIGURING : case ERR_DISCONNECT : case ERR_DISCONNECT_RECONNECT : case WAIT_IDLE : break ; default : dev_err ( & vscsi -> dev , "post_disconnect: Invalid new state %d\n" , new_state ) ; return ; } vscsi -> flags |= flag_bits ; pr_debug ( "post_disconnect: new_state 0x%x, flag_bits 0x%x, vscsi->flags 0x%x, state %hx\n" , new_state , flag_bits , vscsi -> flags , vscsi -> state ) ; if ( ! ( vscsi -> flags & ( DISCONNECT_SCHEDULED | SCHEDULE_DISCONNECT ) ) ) { vscsi -> flags |= SCHEDULE_DISCONNECT ; vscsi -> new_state = new_state ; INIT_WORK ( & vscsi -> proc_work , ibmvscsis_disconnect ) ; ( void ) queue_work ( vscsi -> work_q , & vscsi -> proc_work ) ; } else { if ( vscsi -> new_state ) { state = vscsi -> new_state ; } else { state = vscsi -> state ; } switch ( state ) { case NO_QUEUE : case UNCONFIGURING : break ; case ERR_DISCONNECTED : case ERR_DISCONNECT : case UNDEFINED : if ( new_state == UNCONFIGURING ) { vscsi -> new_state = new_state ; } break ; case ERR_DISCONNECT_RECONNECT : switch ( new_state ) { case UNCONFIGURING : case ERR_DISCONNECT : vscsi -> new_state = new_state ; break ; default : break ; } break ; case WAIT_ENABLED : case WAIT_IDLE : case WAIT_CONNECTION : case CONNECTED : case SRP_PROCESSING : vscsi -> new_state = new_state ; break ; default : break ; } } pr_debug ( "Leaving post_disconnect: flags 0x%x, new_state 0x%x\n" , vscsi -> flags , vscsi -> new_state ) ; } 