test_insert_one ( ) { bson_error_t err = { 0 } ; bson_t reply ; bson_t opts_with_wc = BSON_INITIALIZER ; bool ret ; mongoc_client_t * client = test_framework_new_default_client ( ) ; mongoc_database_t * db = get_test_database ( client ) ; mongoc_collection_t * coll = mongoc_database_get_collection ( db , "coll" ) ; mongoc_write_concern_t * wc = mongoc_write_concern_new ( ) ; mongoc_write_concern_t * wc2 = mongoc_write_concern_new ( ) ; test_crud_ctx_t ctx ; mongoc_apm_callbacks_t * callbacks = mongoc_apm_callbacks_new ( ) ; ctx . command_under_test = "insert" ; ctx . commands_tested = 0 ; mongoc_write_concern_set_w ( wc , 1 ) ; mongoc_write_concern_set_journal ( wc , false ) ; mongoc_write_concern_set_w ( wc2 , 1 ) ; mongoc_write_concern_set_journal ( wc2 , true ) ; mongoc_collection_set_write_concern ( coll , wc ) ; mongoc_apm_set_command_started_cb ( callbacks , _test_crud_command_start ) ; mongoc_client_set_apm_callbacks ( client , callbacks , & ctx ) ; mongoc_collection_drop ( coll , NULL ) ; ctx . expected_command = "{'insert': 'coll', 'bypassDocumentValidation': " "true, 'writeConcern': {'w': 1, 'j': false}}" ; ret = mongoc_collection_insert_one ( coll , tmp_bson ( "{'_id': 1}" ) , tmp_bson ( "{'bypassDocumentValidation': true}" ) , & reply , & err ) ; ASSERT_OR_PRINT ( ret , err ) ; ASSERT_MATCH ( & reply , "{'insertedCount': 1}" ) ; bson_destroy ( & reply ) ; _test_docs_in_coll_matches ( coll , tmp_bson ( "{'_id': 1}" ) , NULL , 1 ) ; ctx . expected_command = "{'insert': 'coll', 'maxTimeMS': 9999, " " 'writeConcern': {'w': 1, 'j': false}}" ; ret = mongoc_collection_insert_one ( coll , tmp_bson ( "{'_id': 2}" ) , tmp_bson ( "{'maxTimeMS': 9999}" ) , & reply , & err ) ; ASSERT_OR_PRINT ( ret , err ) ; ASSERT_MATCH ( & reply , "{'insertedCount': 1}" ) ; bson_destroy ( & reply ) ; _test_docs_in_coll_matches ( coll , tmp_bson ( "{'_id': 2}" ) , NULL , 1 ) ; mongoc_write_concern_append ( wc2 , & opts_with_wc ) ; ctx . expected_command = "{'insert': 'coll', 'writeConcern': {'w': 1, 'j': true}}" ; ret = mongoc_collection_insert_one ( coll , tmp_bson ( "{'_id': 3}" ) , & opts_with_wc , & reply , & err ) ; ASSERT_OR_PRINT ( ret , err ) ; ASSERT_MATCH ( & reply , "{'insertedCount': 1}" ) ; bson_destroy ( & reply ) ; _test_docs_in_coll_matches ( coll , tmp_bson ( "{'_id':3}" ) , NULL , 1 ) ; ctx . expected_command = "{'insert': 'coll', 'writeConcern': {'w': 1, 'j': false}}" ; ret = mongoc_collection_insert_one ( coll , tmp_bson ( "{'_id': 4}" ) , NULL , NULL , NULL ) ; ASSERT ( ret ) ; _test_docs_in_coll_matches ( coll , tmp_bson ( "{'_id': 4}" ) , NULL , 1 ) ; ret = mongoc_collection_insert_one ( coll , tmp_bson ( "{'_id': 4}" ) , NULL , & reply , & err ) ; ASSERT ( ! ret ) ; ASSERT_CMPUINT32 ( err . domain , == , ( uint32_t ) MONGOC_ERROR_COLLECTION ) ; ASSERT_MATCH ( & reply , "{'insertedCount': 0," " 'writeErrors': [" "    {'index': 0, 'code': 11000, 'errmsg': {'$exists': true}}" "]}" ) ; bson_destroy ( & reply ) ; ASSERT_CMPINT ( ctx . commands_tested , == , 5 ) ; bson_destroy ( & opts_with_wc ) ; mongoc_apm_callbacks_destroy ( callbacks ) ; mongoc_write_concern_destroy ( wc ) ; mongoc_write_concern_destroy ( wc2 ) ; mongoc_collection_destroy ( coll ) ; mongoc_database_destroy ( db ) ; mongoc_client_destroy ( client ) ; } 