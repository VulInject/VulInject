check_format_info_main ( , , , , , , ) int * status ; format_check_results * res ; function_format_info * info ; const char * format_chars ; int format_length ; tree params ; unsigned HOST_WIDE_INT arg_num ; { const char * orig_format_chars = format_chars ; tree first_fillin_param = params ; const format_kind_info * fki = & format_types [ info -> format_type ] ; const format_flag_spec * flag_specs = fki -> flag_specs ; const format_flag_pair * bad_flag_pairs = fki -> bad_flag_pairs ; int has_operand_number = - 1 ; init_dollar_format_checking ( info -> first_arg_num , first_fillin_param ) ; while ( 1 ) { int i ; int suppressed = FALSE ; const char * length_chars = NULL ; enum format_lengths length_chars_val = FMT_LEN_none ; enum format_std_version length_chars_std = STD_C89 ; int format_char ; tree cur_param ; tree wanted_type ; int main_arg_num = 0 ; tree main_arg_params = 0 ; enum format_std_version wanted_type_std ; const char * wanted_type_name ; format_wanted_type width_wanted_type ; format_wanted_type precision_wanted_type ; format_wanted_type main_wanted_type ; format_wanted_type * first_wanted_type = NULL ; format_wanted_type * last_wanted_type = NULL ; const format_length_info * fli = NULL ; const format_char_info * fci = NULL ; char flag_chars [ 256 ] ; int field_width = 0 ; int aflag = 0 ; const char * format_start = format_chars ; if ( * format_chars == 0 ) { if ( format_chars - orig_format_chars != format_length ) { status_warning ( status , "embedded `\\0' in format" ) ; } if ( info -> first_arg_num != 0 && params != 0 && has_operand_number <= 0 ) { res -> number_other -- ; res -> number_extra_args ++ ; } if ( has_operand_number > 0 ) { finish_dollar_format_checking ( status , res , fki -> flags & ( int ) FMT_FLAG_DOLLAR_GAP_POINTER_OK ) ; } return ; } if ( * format_chars ++ != '%' ) { continue ; } if ( * format_chars == 0 ) { status_warning ( status , "spurious trailing `%%' in format" ) ; continue ; } if ( * format_chars == '%' ) { ++ format_chars ; continue ; } flag_chars [ 0 ] = 0 ; if ( ( fki -> flags & ( int ) FMT_FLAG_USE_DOLLAR ) && has_operand_number != 0 ) { int opnum ; opnum = maybe_read_dollar_number ( status , & format_chars , 0 , first_fillin_param , & main_arg_params , fki ) ; if ( opnum == - 1 ) { return ; } if ( opnum > 0 ) { has_operand_number = 1 ; main_arg_num = opnum + info -> first_arg_num - 1 ; } } while ( * format_chars != 0 && strchr ( fki -> flag_chars , * format_chars ) != 0 ) { const format_flag_spec * s = get_flag_spec ( flag_specs , * format_chars , NULL ) ; if ( strchr ( flag_chars , * format_chars ) != 0 ) { status_warning ( status , "repeated %s in format" , _ ( s -> name ) ) ; } else { i = strlen ( flag_chars ) ; flag_chars [ i ++ ] = * format_chars ; flag_chars [ i ] = 0 ; } if ( s -> skip_next_char ) { ++ format_chars ; if ( * format_chars == 0 ) { status_warning ( status , "missing fill character at end of strfmon format" ) ; return ; } } ++ format_chars ; } if ( fki -> width_char != 0 ) { if ( fki -> width_type != NULL && * format_chars == '*' ) { i = strlen ( flag_chars ) ; flag_chars [ i ++ ] = fki -> width_char ; flag_chars [ i ] = 0 ; ++ format_chars ; if ( has_operand_number != 0 ) { int opnum ; opnum = maybe_read_dollar_number ( status , & format_chars , has_operand_number == 1 , first_fillin_param , & params , fki ) ; if ( opnum == - 1 ) { return ; } if ( opnum > 0 ) { has_operand_number = 1 ; arg_num = opnum + info -> first_arg_num - 1 ; } else { has_operand_number = 0 ; } } if ( info -> first_arg_num != 0 ) { if ( params == 0 ) { status_warning ( status , "too few arguments for format" ) ; return ; } cur_param = TREE_VALUE ( params ) ; if ( has_operand_number <= 0 ) { params = TREE_CHAIN ( params ) ; ++ arg_num ; } width_wanted_type . wanted_type = * fki -> width_type ; width_wanted_type . wanted_type_name = NULL ; width_wanted_type . pointer_count = 0 ; width_wanted_type . char_lenient_flag = 0 ; width_wanted_type . writing_in_flag = 0 ; width_wanted_type . reading_from_flag = 0 ; width_wanted_type . name = _ ( "field width" ) ; width_wanted_type . param = cur_param ; width_wanted_type . arg_num = arg_num ; width_wanted_type . next = NULL ; if ( last_wanted_type != 0 ) { last_wanted_type -> next = & width_wanted_type ; } if ( first_wanted_type == 0 ) { first_wanted_type = & width_wanted_type ; } last_wanted_type = & width_wanted_type ; } } else { int non_zero_width_char = FALSE ; unsigned int found_width = 0 ; char format_num_str [ 32 ] ; format_num_str [ 0 ] = '\0' ; while ( ISDIGIT ( * format_chars ) ) { if ( found_width < ( sizeof ( format_num_str ) - 2 ) ) { format_num_str [ found_width ++ ] = * format_chars ; format_num_str [ found_width ] = '\0' ; } if ( * format_chars != '0' ) { non_zero_width_char = TRUE ; } ++ format_chars ; } if ( found_width > 0 && ! non_zero_width_char && ( fki -> flags & ( int ) FMT_FLAG_ZERO_WIDTH_BAD ) ) { status_warning ( status , "zero width in %s format" , fki -> name ) ; } if ( found_width > 0 ) { field_width = atoi ( format_num_str ) ; i = strlen ( flag_chars ) ; flag_chars [ i ++ ] = fki -> width_char ; flag_chars [ i ] = 0 ; } } } if ( fki -> left_precision_char != 0 && * format_chars == '#' ) { ++ format_chars ; i = strlen ( flag_chars ) ; flag_chars [ i ++ ] = fki -> left_precision_char ; flag_chars [ i ] = 0 ; if ( ! ISDIGIT ( * format_chars ) ) { status_warning ( status , "empty left precision in %s format" , fki -> name ) ; } while ( ISDIGIT ( * format_chars ) ) { ++ format_chars ; } } if ( fki -> precision_char != 0 && * format_chars == '.' ) { ++ format_chars ; i = strlen ( flag_chars ) ; flag_chars [ i ++ ] = fki -> precision_char ; flag_chars [ i ] = 0 ; if ( fki -> precision_type != NULL && * format_chars == '*' ) { ++ format_chars ; if ( has_operand_number != 0 ) { int opnum ; opnum = maybe_read_dollar_number ( status , & format_chars , has_operand_number == 1 , first_fillin_param , & params , fki ) ; if ( opnum == - 1 ) { return ; } if ( opnum > 0 ) { has_operand_number = 1 ; arg_num = opnum + info -> first_arg_num - 1 ; } else { has_operand_number = 0 ; } } if ( info -> first_arg_num != 0 ) { if ( params == 0 ) { status_warning ( status , "too few arguments for format" ) ; return ; } cur_param = TREE_VALUE ( params ) ; if ( has_operand_number <= 0 ) { params = TREE_CHAIN ( params ) ; ++ arg_num ; } precision_wanted_type . wanted_type = * fki -> precision_type ; precision_wanted_type . wanted_type_name = NULL ; precision_wanted_type . pointer_count = 0 ; precision_wanted_type . char_lenient_flag = 0 ; precision_wanted_type . writing_in_flag = 0 ; precision_wanted_type . reading_from_flag = 0 ; precision_wanted_type . name = _ ( "field precision" ) ; precision_wanted_type . param = cur_param ; precision_wanted_type . arg_num = arg_num ; precision_wanted_type . next = NULL ; if ( last_wanted_type != 0 ) { last_wanted_type -> next = & precision_wanted_type ; } if ( first_wanted_type == 0 ) { first_wanted_type = & precision_wanted_type ; } last_wanted_type = & precision_wanted_type ; } } else { if ( ! ( fki -> flags & ( int ) FMT_FLAG_EMPTY_PREC_OK ) && ! ISDIGIT ( * format_chars ) ) { status_warning ( status , "empty precision in %s format" , fki -> name ) ; } while ( ISDIGIT ( * format_chars ) ) { ++ format_chars ; } } } fli = fki -> length_char_specs ; length_chars = NULL ; length_chars_val = FMT_LEN_none ; length_chars_std = STD_C89 ; if ( fli ) { while ( fli -> name != 0 && fli -> name [ 0 ] != * format_chars ) { fli ++ ; } if ( fli -> name != 0 ) { format_chars ++ ; if ( fli -> double_name != 0 && fli -> name [ 0 ] == * format_chars ) { format_chars ++ ; length_chars = fli -> double_name ; length_chars_val = fli -> double_index ; length_chars_std = fli -> double_std ; } else { length_chars = fli -> name ; length_chars_val = fli -> index ; length_chars_std = fli -> std ; } i = strlen ( flag_chars ) ; flag_chars [ i ++ ] = fki -> length_code_char ; flag_chars [ i ] = 0 ; } if ( pedantic ) { if ( ADJ_STD ( length_chars_std ) > C_STD_VER ) { status_warning ( status , "%s does not support the `%s' %s length modifier" , C_STD_NAME ( length_chars_std ) , length_chars , fki -> name ) ; } } } if ( fki -> modifier_chars != NULL ) { while ( * format_chars != 0 && strchr ( fki -> modifier_chars , * format_chars ) != 0 ) { if ( strchr ( flag_chars , * format_chars ) != 0 ) { const format_flag_spec * s = get_flag_spec ( flag_specs , * format_chars , NULL ) ; status_warning ( status , "repeated %s in format" , _ ( s -> name ) ) ; } else { i = strlen ( flag_chars ) ; flag_chars [ i ++ ] = * format_chars ; flag_chars [ i ] = 0 ; } ++ format_chars ; } } if ( fki -> flags & ( int ) FMT_FLAG_SCANF_A_KLUDGE ) { if ( * format_chars == 'a' && ! flag_isoc99 ) { if ( format_chars [ 1 ] == 's' || format_chars [ 1 ] == 'S' || format_chars [ 1 ] == '[' ) { i = strlen ( flag_chars ) ; flag_chars [ i ++ ] = 'a' ; flag_chars [ i ] = 0 ; format_chars ++ ; } } } format_char = * format_chars ; if ( format_char == 0 || ( ! ( fki -> flags & ( int ) FMT_FLAG_FANCY_PERCENT_OK ) && format_char == '%' ) ) { status_warning ( status , "conversion lacks type at end of format" ) ; continue ; } format_chars ++ ; fci = fki -> conversion_specs ; while ( fci -> format_chars != 0 && strchr ( fci -> format_chars , format_char ) == 0 ) { ++ fci ; } if ( fci -> format_chars == 0 ) { if ( ISGRAPH ( format_char ) ) { status_warning ( status , "unknown conversion type character `%c' in format" , format_char ) ; } else { status_warning ( status , "unknown conversion type character 0x%x in format" , format_char ) ; } continue ; } if ( pedantic ) { if ( ADJ_STD ( fci -> std ) > C_STD_VER ) { status_warning ( status , "%s does not support the `%%%c' %s format" , C_STD_NAME ( fci -> std ) , format_char , fki -> name ) ; } } { int d = 0 ; for ( i = 0 ; flag_chars [ i ] != 0 ; i ++ ) { const format_flag_spec * s = get_flag_spec ( flag_specs , flag_chars [ i ] , NULL ) ; flag_chars [ i - d ] = flag_chars [ i ] ; if ( flag_chars [ i ] == fki -> length_code_char ) { continue ; } if ( strchr ( fci -> flag_chars , flag_chars [ i ] ) == 0 ) { status_warning ( status , "%s used with `%%%c' %s format" , _ ( s -> name ) , format_char , fki -> name ) ; d ++ ; continue ; } if ( pedantic ) { const format_flag_spec * t ; if ( ADJ_STD ( s -> std ) > C_STD_VER ) { status_warning ( status , "%s does not support %s" , C_STD_NAME ( s -> std ) , _ ( s -> long_name ) ) ; } t = get_flag_spec ( flag_specs , flag_chars [ i ] , fci -> flags2 ) ; if ( t != NULL && ADJ_STD ( t -> std ) > ADJ_STD ( s -> std ) ) { const char * long_name = ( t -> long_name != NULL ?t -> long_name : s -> long_name ) ; if ( ADJ_STD ( t -> std ) > C_STD_VER ) { status_warning ( status , "%s does not support %s with the `%%%c' %s format" , C_STD_NAME ( t -> std ) , _ ( long_name ) , format_char , fki -> name ) ; } } } } flag_chars [ i - d ] = 0 ; } if ( ( fki -> flags & ( int ) FMT_FLAG_SCANF_A_KLUDGE ) && strchr ( flag_chars , 'a' ) != 0 ) { aflag = 1 ; } if ( fki -> suppression_char && strchr ( flag_chars , fki -> suppression_char ) != 0 ) { suppressed = 1 ; } for ( i = 0 ; bad_flag_pairs [ i ] . flag_char1 != 0 ; i ++ ) { const format_flag_spec * s , * t ; if ( strchr ( flag_chars , bad_flag_pairs [ i ] . flag_char1 ) == 0 ) { continue ; } if ( strchr ( flag_chars , bad_flag_pairs [ i ] . flag_char2 ) == 0 ) { continue ; } if ( bad_flag_pairs [ i ] . predicate != 0 && strchr ( fci -> flags2 , bad_flag_pairs [ i ] . predicate ) == 0 ) { continue ; } s = get_flag_spec ( flag_specs , bad_flag_pairs [ i ] . flag_char1 , NULL ) ; t = get_flag_spec ( flag_specs , bad_flag_pairs [ i ] . flag_char2 , NULL ) ; if ( bad_flag_pairs [ i ] . ignored ) { if ( bad_flag_pairs [ i ] . predicate != 0 ) { status_warning ( status , "%s ignored with %s and `%%%c' %s format" , _ ( s -> name ) , _ ( t -> name ) , format_char , fki -> name ) ; } else { status_warning ( status , "%s ignored with %s in %s format" , _ ( s -> name ) , _ ( t -> name ) , fki -> name ) ; } } else { if ( bad_flag_pairs [ i ] . predicate != 0 ) { status_warning ( status , "use of %s and %s together with `%%%c' %s format" , _ ( s -> name ) , _ ( t -> name ) , format_char , fki -> name ) ; } else { status_warning ( status , "use of %s and %s together in %s format" , _ ( s -> name ) , _ ( t -> name ) , fki -> name ) ; } } } if ( warn_format_y2k ) { int y2k_level = 0 ; if ( strchr ( fci -> flags2 , '4' ) != 0 ) { if ( strchr ( flag_chars , 'E' ) != 0 ) { y2k_level = 3 ; } else { y2k_level = 2 ; } } if ( strchr ( fci -> flags2 , '3' ) != 0 ) { y2k_level = 3 ; } if ( strchr ( fci -> flags2 , '2' ) != 0 ) { y2k_level = 2 ; } if ( y2k_level == 3 ) { status_warning ( status , "`%%%c' yields only last 2 digits of year in some locales" , format_char ) ; } if ( y2k_level == 2 ) { status_warning ( status , "`%%%c' yields only last 2 digits of year" , format_char ) ; } } if ( strchr ( fci -> flags2 , '[' ) != 0 ) { if ( * format_chars == '^' ) { ++ format_chars ; } if ( * format_chars == ']' ) { ++ format_chars ; } while ( * format_chars && * format_chars != ']' ) { ++ format_chars ; } if ( * format_chars != ']' ) { status_warning ( status , "no closing `]' for `%%[' format" ) ; } } wanted_type = 0 ; wanted_type_name = 0 ; if ( fki -> flags & ( int ) FMT_FLAG_ARG_CONVERT ) { wanted_type = ( fci -> types [ length_chars_val ] . type ?* fci -> types [ length_chars_val ] . type : 0 ) ; wanted_type_name = fci -> types [ length_chars_val ] . name ; wanted_type_std = fci -> types [ length_chars_val ] . std ; if ( wanted_type == 0 ) { status_warning ( status , "use of `%s' length modifier with `%c' type character" , length_chars , format_char ) ; arg_num ++ ; if ( params == 0 ) { status_warning ( status , "too few arguments for format" ) ; return ; } params = TREE_CHAIN ( params ) ; continue ; } if ( pedantic && ADJ_STD ( wanted_type_std ) > ADJ_STD ( length_chars_std ) && ADJ_STD ( wanted_type_std ) > ADJ_STD ( fci -> std ) ) { if ( ADJ_STD ( wanted_type_std ) > C_STD_VER ) { status_warning ( status , "%s does not support the `%%%s%c' %s format" , C_STD_NAME ( wanted_type_std ) , length_chars , format_char , fki -> name ) ; } } } if ( info -> first_arg_num == 0 ) { continue ; } if ( ( fci -> pointer_count == 0 && wanted_type == void_type_node ) || suppressed ) { if ( main_arg_num != 0 ) { if ( suppressed ) { status_warning ( status , "operand number specified with suppressed assignment" ) ; } else { status_warning ( status , "operand number specified for format taking no argument" ) ; } } } else { format_wanted_type * wanted_type_ptr ; if ( main_arg_num != 0 ) { arg_num = main_arg_num ; params = main_arg_params ; } else { ++ arg_num ; if ( has_operand_number > 0 ) { status_warning ( status , "missing $ operand number in format" ) ; return ; } else { has_operand_number = 0 ; } } wanted_type_ptr = & main_wanted_type ; while ( fci ) { if ( params == 0 ) { status_warning ( status , "too few arguments for format" ) ; return ; } cur_param = TREE_VALUE ( params ) ; params = TREE_CHAIN ( params ) ; wanted_type_ptr -> wanted_type = wanted_type ; wanted_type_ptr -> wanted_type_name = wanted_type_name ; wanted_type_ptr -> pointer_count = fci -> pointer_count + aflag ; wanted_type_ptr -> char_lenient_flag = 0 ; wanted_type_ptr -> field_width = field_width ; if ( strchr ( fci -> flags2 , 'c' ) != 0 ) { wanted_type_ptr -> char_lenient_flag = 1 ; } wanted_type_ptr -> writing_in_flag = 0 ; wanted_type_ptr -> reading_from_flag = 0 ; if ( strchr ( fci -> format_chars , 'c' ) != 0 ) { wanted_type_ptr -> size_equals_width = 1 ; } else { wanted_type_ptr -> size_equals_width = 0 ; } if ( aflag ) { wanted_type_ptr -> writing_in_flag = 1 ; } else { if ( strchr ( fci -> flags2 , 'W' ) != 0 ) { wanted_type_ptr -> writing_in_flag = 1 ; } if ( strchr ( fci -> flags2 , 'R' ) != 0 ) { wanted_type_ptr -> reading_from_flag = 1 ; } } wanted_type_ptr -> name = NULL ; wanted_type_ptr -> param = cur_param ; wanted_type_ptr -> arg_num = arg_num ; wanted_type_ptr -> next = NULL ; if ( last_wanted_type != 0 ) { last_wanted_type -> next = wanted_type_ptr ; } if ( first_wanted_type == 0 ) { first_wanted_type = wanted_type_ptr ; } last_wanted_type = wanted_type_ptr ; fci = fci -> chain ; if ( fci ) { wanted_type_ptr = ggc_alloc ( sizeof ( format_wanted_type ) ) ; arg_num ++ ; wanted_type = * fci -> types [ length_chars_val ] . type ; wanted_type_name = fci -> types [ length_chars_val ] . name ; } } } if ( first_wanted_type != 0 ) { bool apply_bounded = format_chars > format_start && ( format_chars [ - 1 ] == 's' || format_chars [ - 1 ] == 'c' ) ; check_format_types ( status , first_wanted_type , apply_bounded ) ; } } } 