calc_eclosure_iter ( , , , ) { reg_errcode_t err ; unsigned int constraint ; int i , incomplete ; re_node_set eclosure ; incomplete = 0 ; err = re_node_set_alloc ( & eclosure , dfa -> edests [ node ] . nelem + 1 ) ; if ( BE ( err != REG_NOERROR , 0 ) ) { return err ; } dfa -> eclosures [ node ] . nelem = - 1 ; constraint = ( ( dfa -> nodes [ node ] . type == ANCHOR ) ?dfa -> nodes [ node ] . opr . ctx_type : 0 ) ; if ( constraint && dfa -> edests [ node ] . nelem && ! dfa -> nodes [ dfa -> edests [ node ] . elems [ 0 ] ] . duplicated ) { err = duplicate_node_closure ( dfa , node , node , node , constraint ) ; if ( BE ( err != REG_NOERROR , 0 ) ) { return err ; } } if ( IS_EPSILON_NODE ( dfa -> nodes [ node ] . type ) ) { for ( i = 0 ; i < dfa -> edests [ node ] . nelem ; ++ i ) { re_node_set eclosure_elem ; int edest = dfa -> edests [ node ] . elems [ i ] ; if ( dfa -> eclosures [ edest ] . nelem == 0 ) { err = calc_eclosure_iter ( & eclosure_elem , dfa , edest , 0 ) ; if ( BE ( err != REG_NOERROR , 0 ) ) { return err ; } } else { eclosure_elem = dfa -> eclosures [ edest ] ; } re_node_set_merge ( & eclosure , & eclosure_elem ) ; if ( dfa -> eclosures [ edest ] . nelem == 0 ) { incomplete = 1 ; re_node_set_free ( & eclosure_elem ) ; } } } re_node_set_insert ( & eclosure , node ) ; if ( incomplete && ! root ) { dfa -> eclosures [ node ] . nelem = 0 ; } else { dfa -> eclosures [ node ] = eclosure ; } * new_set = eclosure ; return REG_NOERROR ; } 