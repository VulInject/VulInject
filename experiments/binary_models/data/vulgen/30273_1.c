static struct sk_buff * h5_prepare_pkt ( struct hci_uart * hu , u8 pkt_type , const u8 * data , size_t len ) { struct h5 * h5 = hu -> priv ; struct sk_buff * nskb ; u8 hdr [ 4 ] ; int i ; nskb = alloc_skb ( ( len + 6 ) * 2 + 2 , GFP_ATOMIC ) ; if ( ! nskb ) { return NULL ; } hci_skb_pkt_type ( nskb ) = pkt_type ; h5_slip_delim ( nskb ) ; hdr [ 0 ] = h5 -> tx_ack << 3 ; clear_bit ( H5_TX_ACK_REQ , & h5 -> flags ) ; if ( pkt_type == HCI_ACLDATA_PKT || pkt_type == HCI_COMMAND_PKT ) { hdr [ 0 ] |= 1 << 7 ; hdr [ 0 ] |= h5 -> tx_seq ; h5 -> tx_seq = ( h5 -> tx_seq + 1 ) % 8 ; } hdr [ 1 ] = pkt_type | ( ( len & 0x0f ) << 4 ) ; hdr [ 2 ] = len >> 4 ; hdr [ 3 ] = ~ ( ( hdr [ 0 ] + hdr [ 1 ] + hdr [ 2 ] ) & 0xff ) ; BT_DBG ( "%s tx: seq %u ack %u crc %u rel %u type %u len %u" , hu -> hdev -> name , H5_HDR_SEQ ( hdr ) , H5_HDR_ACK ( hdr ) , H5_HDR_CRC ( hdr ) , H5_HDR_RELIABLE ( hdr ) , H5_HDR_PKT_TYPE ( hdr ) , H5_HDR_LEN ( hdr ) ) ; for ( i = 0 ; i < 4 ; i ++ ) { h5_slip_one_byte ( nskb , hdr [ i ] ) ; } for ( i = 0 ; i < len ; i ++ ) { h5_slip_one_byte ( nskb , data [ i ] ) ; } h5_slip_delim ( nskb ) ; return nskb ; } 