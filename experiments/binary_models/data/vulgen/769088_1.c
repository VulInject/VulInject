static int scrub_handle_errored_block ( struct scrub_block * sblock_to_check ) { struct scrub_ctx * sctx = sblock_to_check -> sctx ; struct btrfs_device * dev ; struct btrfs_fs_info * fs_info ; u64 length ; u64 logical ; unsigned int failed_mirror_index ; unsigned int is_metadata ; unsigned int have_csum ; struct scrub_block * sblocks_for_recheck ; struct scrub_block * sblock_bad ; int ret ; int mirror_index ; int page_num ; int success ; bool full_stripe_locked ; static DEFINE_RATELIMIT_STATE ( _rs , DEFAULT_RATELIMIT_INTERVAL , DEFAULT_RATELIMIT_BURST ) ; BUG_ON ( sblock_to_check -> page_count < 1 ) ; fs_info = sctx -> fs_info ; if ( sblock_to_check -> pagev [ 0 ] -> flags & BTRFS_EXTENT_FLAG_SUPER ) { spin_lock ( & sctx -> stat_lock ) ; ++ sctx -> stat . super_errors ; return 0 ; } length = sblock_to_check -> page_count * PAGE_SIZE ; logical = sblock_to_check -> pagev [ 0 ] -> logical ; BUG_ON ( sblock_to_check -> pagev [ 0 ] -> mirror_num < 1 ) ; failed_mirror_index = sblock_to_check -> pagev [ 0 ] -> mirror_num - 1 ; is_metadata = ! ( sblock_to_check -> pagev [ 0 ] -> flags & BTRFS_EXTENT_FLAG_DATA ) ; have_csum = sblock_to_check -> pagev [ 0 ] -> have_csum ; dev = sblock_to_check -> pagev [ 0 ] -> dev ; ret = lock_full_stripe ( fs_info , logical , & full_stripe_locked ) ; if ( ret < 0 ) { spin_lock ( & sctx -> stat_lock ) ; if ( ret == - ENOMEM ) { sctx -> stat . malloc_errors ++ ; } sctx -> stat . read_errors ++ ; sctx -> stat . uncorrectable_errors ++ ; spin_unlock ( & sctx -> stat_lock ) ; return ret ; } if ( sctx -> is_dev_replace && ! is_metadata && ! have_csum ) { sblocks_for_recheck = NULL ; nodatasum_case } sblocks_for_recheck = kcalloc ( BTRFS_MAX_MIRRORS , sizeof ( * sblocks_for_recheck ) , GFP_NOFS ) ; if ( ! sblocks_for_recheck ) { spin_lock ( & sctx -> stat_lock ) ; sctx -> stat . malloc_errors ++ ; sctx -> stat . read_errors ++ ; sctx -> stat . uncorrectable_errors ++ ; spin_unlock ( & sctx -> stat_lock ) ; btrfs_dev_stat_inc_and_print ( dev , BTRFS_DEV_STAT_READ_ERRS ) ; out } ret = scrub_setup_recheck_block ( sblock_to_check , sblocks_for_recheck ) ; if ( ret ) { spin_lock ( & sctx -> stat_lock ) ; sctx -> stat . read_errors ++ ; sctx -> stat . uncorrectable_errors ++ ; spin_unlock ( & sctx -> stat_lock ) ; btrfs_dev_stat_inc_and_print ( dev , BTRFS_DEV_STAT_READ_ERRS ) ; out } BUG_ON ( failed_mirror_index >= BTRFS_MAX_MIRRORS ) ; sblock_bad = sblocks_for_recheck + failed_mirror_index ; scrub_recheck_block ( fs_info , sblock_bad , 1 ) ; if ( ! sblock_bad -> header_error && ! sblock_bad -> checksum_error && sblock_bad -> no_io_error_seen ) { spin_lock ( & sctx -> stat_lock ) ; sctx -> stat . unverified_errors ++ ; sblock_to_check -> data_corrected = 1 ; spin_unlock ( & sctx -> stat_lock ) ; if ( sctx -> is_dev_replace ) { scrub_write_block_to_dev_replace ( sblock_bad ) ; } out } if ( ! sblock_bad -> no_io_error_seen ) { spin_lock ( & sctx -> stat_lock ) ; sctx -> stat . read_errors ++ ; spin_unlock ( & sctx -> stat_lock ) ; if ( __ratelimit ( & _rs ) ) { scrub_print_warning ( "i/o error" , sblock_to_check ) ; } btrfs_dev_stat_inc_and_print ( dev , BTRFS_DEV_STAT_READ_ERRS ) ; } if ( sblock_bad -> checksum_error ) { spin_lock ( & sctx -> stat_lock ) ; sctx -> stat . csum_errors ++ ; spin_unlock ( & sctx -> stat_lock ) ; if ( __ratelimit ( & _rs ) ) { scrub_print_warning ( "checksum error" , sblock_to_check ) ; } btrfs_dev_stat_inc_and_print ( dev , BTRFS_DEV_STAT_CORRUPTION_ERRS ) ; } if ( sblock_bad -> header_error ) { spin_lock ( & sctx -> stat_lock ) ; sctx -> stat . verify_errors ++ ; spin_unlock ( & sctx -> stat_lock ) ; if ( __ratelimit ( & _rs ) ) { scrub_print_warning ( "checksum/header error" , sblock_to_check ) ; } if ( sblock_bad -> generation_error ) { btrfs_dev_stat_inc_and_print ( dev , BTRFS_DEV_STAT_GENERATION_ERRS ) ; } else { btrfs_dev_stat_inc_and_print ( dev , BTRFS_DEV_STAT_CORRUPTION_ERRS ) ; } } if ( sctx -> readonly ) { ASSERT ( ! sctx -> is_dev_replace ) ; out } if ( ! is_metadata && ! have_csum ) { struct scrub_fixup_nodatasum * fixup_nodatasum ; WARN_ON ( sctx -> is_dev_replace ) ; nodatasum_case fixup_nodatasum = kzalloc ( sizeof ( * fixup_nodatasum ) , GFP_NOFS ) ; if ( ! fixup_nodatasum ) { did_not_correct_error } fixup_nodatasum -> sctx = sctx ; fixup_nodatasum -> dev = dev ; fixup_nodatasum -> logical = logical ; fixup_nodatasum -> root = fs_info -> extent_root ; fixup_nodatasum -> mirror_num = failed_mirror_index + 1 ; scrub_pending_trans_workers_inc ( sctx ) ; btrfs_init_work ( & fixup_nodatasum -> work , btrfs_scrub_helper , scrub_fixup_nodatasum , NULL , NULL ) ; btrfs_queue_work ( fs_info -> scrub_workers , & fixup_nodatasum -> work ) ; out } for ( mirror_index = 0 ; mirror_index < BTRFS_MAX_MIRRORS && sblocks_for_recheck [ mirror_index ] . page_count > 0 ; mirror_index ++ ) { struct scrub_block * sblock_other ; if ( mirror_index == failed_mirror_index ) { continue ; } sblock_other = sblocks_for_recheck + mirror_index ; scrub_recheck_block ( fs_info , sblock_other , 0 ) ; if ( ! sblock_other -> header_error && ! sblock_other -> checksum_error && sblock_other -> no_io_error_seen ) { if ( sctx -> is_dev_replace ) { scrub_write_block_to_dev_replace ( sblock_other ) ; corrected_error } else { ret = scrub_repair_block_from_good_copy ( sblock_bad , sblock_other ) ; if ( ! ret ) { corrected_error } } } } if ( sblock_bad -> no_io_error_seen && ! sctx -> is_dev_replace ) { did_not_correct_error } success = 1 ; for ( page_num = 0 ; page_num < sblock_bad -> page_count ; page_num ++ ) { struct scrub_page * page_bad = sblock_bad -> pagev [ page_num ] ; struct scrub_block * sblock_other = NULL ; if ( ! page_bad -> io_error && ! sctx -> is_dev_replace ) { continue ; } if ( page_bad -> io_error ) { for ( mirror_index = 0 ; mirror_index < BTRFS_MAX_MIRRORS && sblocks_for_recheck [ mirror_index ] . page_count > 0 ; mirror_index ++ ) { if ( ! sblocks_for_recheck [ mirror_index ] . pagev [ page_num ] -> io_error ) { sblock_other = sblocks_for_recheck + mirror_index ; break ; } } if ( ! sblock_other ) { success = 0 ; } } if ( sctx -> is_dev_replace ) { if ( ! sblock_other ) { sblock_other = sblock_bad ; } if ( scrub_write_page_to_dev_replace ( sblock_other , page_num ) != 0 ) { btrfs_dev_replace_stats_inc ( & fs_info -> dev_replace . num_write_errors ) ; success = 0 ; } } if ( sblock_other ) { ret = scrub_repair_page_from_good_copy ( sblock_bad , sblock_other , page_num , 0 ) ; if ( 0 == ret ) { page_bad -> io_error = 0 ; } else { success = 0 ; } } } if ( success && ! sctx -> is_dev_replace ) { if ( is_metadata || have_csum ) { scrub_recheck_block ( fs_info , sblock_bad , 1 ) ; if ( ! sblock_bad -> header_error && ! sblock_bad -> checksum_error && sblock_bad -> no_io_error_seen ) { corrected_error } else { did_not_correct_error } } else { corrected_error spin_lock ( & sctx -> stat_lock ) ; sctx -> stat . corrected_errors ++ ; sblock_to_check -> data_corrected = 1 ; spin_unlock ( & sctx -> stat_lock ) ; btrfs_err_rl_in_rcu ( fs_info , "fixed up error at logical %llu on dev %s" , logical , rcu_str_deref ( dev -> name ) ) ; } } else { did_not_correct_error spin_lock ( & sctx -> stat_lock ) ; sctx -> stat . uncorrectable_errors ++ ; spin_unlock ( & sctx -> stat_lock ) ; btrfs_err_rl_in_rcu ( fs_info , "unable to fixup (regular) error at logical %llu on dev %s" , logical , rcu_str_deref ( dev -> name ) ) ; } out if ( sblocks_for_recheck ) { for ( mirror_index = 0 ; mirror_index < BTRFS_MAX_MIRRORS ; mirror_index ++ ) { struct scrub_block * sblock = sblocks_for_recheck + mirror_index ; struct scrub_recover * recover ; int page_index ; for ( page_index = 0 ; page_index < sblock -> page_count ; page_index ++ ) { sblock -> pagev [ page_index ] -> sblock = NULL ; recover = sblock -> pagev [ page_index ] -> recover ; if ( recover ) { scrub_put_recover ( fs_info , recover ) ; sblock -> pagev [ page_index ] -> recover = NULL ; } scrub_page_put ( sblock -> pagev [ page_index ] ) ; } } kfree ( sblocks_for_recheck ) ; } ret = unlock_full_stripe ( fs_info , logical , full_stripe_locked ) ; if ( ret < 0 ) { return ret ; } return 0 ; } 