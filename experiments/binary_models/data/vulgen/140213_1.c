static void xor_journal ( struct dm_integrity_c * ic , bool encrypt , unsigned int section , unsigned int n_sections , struct journal_completion * comp ) { struct async_submit_ctl submit ; size_t n_bytes = ( size_t ) ( n_sections * ic -> journal_section_sectors ) << SECTOR_SHIFT ; unsigned int pl_index , pl_offset , section_index ; struct page_list * source_pl , * target_pl ; if ( likely ( encrypt ) ) { source_pl = ic -> journal ; target_pl = ic -> journal_io ; } else { source_pl = ic -> journal_io ; target_pl = ic -> journal ; } page_list_location ( ic , section , 0 , & pl_index , & pl_offset ) ; init_async_submit ( & submit , ASYNC_TX_XOR_ZERO_DST , NULL , complete_journal_op , comp , NULL ) ; section_index = pl_index ; { size_t this_step ; struct page * src_pages [ 2 ] ; struct page * dst_page ; while ( unlikely ( pl_index == section_index ) ) { unsigned int dummy ; if ( likely ( encrypt ) ) { rw_section_mac ( ic , section , true ) ; } section ++ ; n_sections -- ; if ( ! n_sections ) { break ; } page_list_location ( ic , section , 0 , & section_index , & dummy ) ; } this_step = min ( n_bytes , ( size_t ) PAGE_SIZE - pl_offset ) ; dst_page = target_pl [ pl_index ] . page ; src_pages [ 0 ] = source_pl [ pl_index ] . page ; src_pages [ 1 ] = ic -> journal_xor [ pl_index ] . page ; async_xor ( dst_page , src_pages , pl_offset , 2 , this_step , & submit ) ; pl_index ++ ; pl_offset = 0 ; n_bytes -= this_step ; } n_bytes ; BUG_ON ( n_sections ) ; async_tx_issue_pending_all ( ) ; } 