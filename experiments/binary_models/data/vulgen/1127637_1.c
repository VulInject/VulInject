static size_t nilfs_lookup_dirty_data_buffers ( struct inode * inode , struct list_head * listp , size_t nlimit , loff_t start , loff_t end ) { struct address_space * mapping = inode -> i_mapping ; struct pagevec pvec ; pgoff_t index = 0 , last = ULONG_MAX ; size_t ndirties = 0 ; int i ; if ( unlikely ( start != 0 || end != LLONG_MAX ) ) { index = start >> PAGE_SHIFT ; last = end >> PAGE_SHIFT ; } pagevec_init ( & pvec , 0 ) ; repeat if ( unlikely ( index > last ) || ! pagevec_lookup_tag ( & pvec , mapping , & index , PAGECACHE_TAG_DIRTY , min_t ( pgoff_t , last - index , PAGEVEC_SIZE - 1 ) + 1 ) ) { return ndirties ; } for ( i = 0 ; i < pagevec_count ( & pvec ) ; i ++ ) { struct buffer_head * bh , * head ; struct page * page = pvec . pages [ i ] ; if ( unlikely ( page -> index > last ) ) { break ; } lock_page ( page ) ; unlock_page ( page ) ; bh = head = page_buffers ( page ) ; { if ( ! buffer_dirty ( bh ) || buffer_async_write ( bh ) ) { continue ; } get_bh ( bh ) ; list_add_tail ( & bh -> b_assoc_buffers , listp ) ; ndirties ++ ; if ( unlikely ( ndirties >= nlimit ) ) { pagevec_release ( & pvec ) ; cond_resched ( ) ; return ndirties ; } } bh = bh -> b_this_page , bh != head ; } pagevec_release ( & pvec ) ; cond_resched ( ) ; repeat } 