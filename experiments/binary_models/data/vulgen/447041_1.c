static int trie_get_next_key ( struct bpf_map * map , void * _key , void * _next_key ) { struct lpm_trie_node * node , * next_node = NULL , * parent , * search_root ; struct lpm_trie * trie = container_of ( map , lpm_trie , map ) ; struct bpf_lpm_trie_key * key = _key , * next_key = _next_key ; struct lpm_trie_node * * node_stack = NULL ; int err = 0 , stack_ptr = - 1 ; unsigned int next_bit ; size_t matchlen ; search_root = rcu_dereference ( trie -> root ) ; if ( ! search_root ) { return - ENOENT ; } if ( ! key || key -> prefixlen > trie -> max_prefixlen ) { find_leftmost } node_stack = kmalloc_array ( trie -> max_prefixlen , sizeof ( lpm_trie_node * ) , GFP_ATOMIC | __GFP_NOWARN ) ; if ( ! node_stack ) { return - ENOMEM ; } for ( node = search_root ; node ; ) { node_stack [ ++ stack_ptr ] = node ; matchlen = longest_prefix_match ( trie , node , key ) ; if ( node -> prefixlen != matchlen || node -> prefixlen == key -> prefixlen ) { break ; } next_bit = extract_bit ( key -> data , node -> prefixlen ) ; node = rcu_dereference ( node -> child [ next_bit ] ) ; } if ( ! node || node -> prefixlen != key -> prefixlen || ( node -> flags & LPM_TREE_NODE_FLAG_IM ) ) { find_leftmost } node = node_stack [ stack_ptr ] ; while ( stack_ptr > 0 ) { parent = node_stack [ stack_ptr - 1 ] ; if ( rcu_dereference ( parent -> child [ 0 ] ) == node ) { search_root = rcu_dereference ( parent -> child [ 1 ] ) ; if ( search_root ) { find_leftmost } } if ( ! ( parent -> flags & LPM_TREE_NODE_FLAG_IM ) ) { next_node = parent ; do_copy } node = parent ; stack_ptr -- ; } err = - ENOENT ; free_stack find_leftmost for ( node = search_root ; node ; ) { else { next_node = node ; node = rcu_dereference ( node -> child [ 0 ] ) ; if ( ! node ) { node = rcu_dereference ( next_node -> child [ 1 ] ) ; } } } do_copy next_key -> prefixlen = next_node -> prefixlen ; memcpy ( ( void * ) next_key + offsetof ( bpf_lpm_trie_key , data ) , next_node -> data , trie -> data_size ) ; free_stack kfree ( node_stack ) ; return err ; } 