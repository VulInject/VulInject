static int parseline ( line , ip , ifn , out ) char * line ; ip_t * ip ; char * * ifn ; int * out ; { tcphdr_t th , * tcp = & th ; struct icmp icmp , * ic = & icmp ; char * cps [ 20 ] , * * cpp , c , ipopts [ 68 ] ; int i , r ; bzero ( ( char * ) ip , MAX ( sizeof ( * tcp ) , sizeof ( * ic ) ) + sizeof ( * ip ) ) ; bzero ( ( char * ) tcp , sizeof ( * tcp ) ) ; bzero ( ( char * ) ic , sizeof ( * ic ) ) ; bzero ( ipopts , sizeof ( ipopts ) ) ; IP_HL_A ( ip , sizeof ( * ip ) >> 2 ) ; IP_V_A ( ip , IPVERSION ) ; for ( i = 0 , cps [ 0 ] = strtok ( line , " \b\t\r\n" ) ; cps [ i ] && i < 19 ; ) { cps [ ++ i ] = strtok ( NULL , " \b\t\r\n" ) ; } cpp = cps ; if ( ! * cpp ) { return 1 ; } c = * * cpp ; if ( ! ISALPHA ( c ) || ( TOLOWER ( c ) != 'o' && TOLOWER ( c ) != 'i' ) ) { fprintf ( stderr , "bad direction \"%s\"\n" , * cpp ) ; return 1 ; } * out = ( TOLOWER ( c ) == 'o' ) ?1 : 0 ; cpp ++ ; if ( ! * cpp ) { return 1 ; } if ( ! strcasecmp ( * cpp , "on" ) ) { cpp ++ ; if ( ! * cpp ) { return 1 ; } * ifn = strdup ( * cpp ++ ) ; if ( ! * cpp ) { return 1 ; } } c = * * cpp ; ip -> ip_len = sizeof ( ip_t ) ; if ( ! strcasecmp ( * cpp , "tcp" ) || ! strcasecmp ( * cpp , "udp" ) || ! strcasecmp ( * cpp , "icmp" ) ) { if ( c == 't' ) { ip -> ip_p = IPPROTO_TCP ; ip -> ip_len += sizeof ( tcphdr ) ; tx_proto = "tcp" ; } if ( c == 'u' ) { ip -> ip_p = IPPROTO_UDP ; ip -> ip_len += sizeof ( udphdr ) ; tx_proto = "udp" ; } else { ip -> ip_p = IPPROTO_ICMP ; ip -> ip_len += ICMPERR_IPICMPHLEN ; tx_proto = "icmp" ; } cpp ++ ; } if ( ISDIGIT ( * * cpp ) && ! index ( * cpp , '.' ) ) { ip -> ip_p = atoi ( * cpp ) ; cpp ++ ; } else { ip -> ip_p = IPPROTO_IP ; } if ( ! * cpp ) { return 1 ; } if ( ip -> ip_p == IPPROTO_TCP || ip -> ip_p == IPPROTO_UDP ) { char * last ; last = strchr ( * cpp , ',' ) ; if ( ! last ) { fprintf ( stderr , "tcp/udp with no source port\n" ) ; return 1 ; } * last ++ = '\0' ; tcp -> th_sport = htons ( tx_portnum ( last ) ) ; if ( ip -> ip_p == IPPROTO_TCP ) { tcp -> th_win = htons ( 4096 ) ; TCP_OFF_A ( tcp , sizeof ( * tcp ) >> 2 ) ; } } ip -> ip_src . s_addr = tx_hostnum ( * cpp , & r ) ; cpp ++ ; if ( ! * cpp ) { return 1 ; } if ( ip -> ip_p == IPPROTO_TCP || ip -> ip_p == IPPROTO_UDP ) { char * last ; last = strchr ( * cpp , ',' ) ; if ( ! last ) { fprintf ( stderr , "tcp/udp with no destination port\n" ) ; return 1 ; } * last ++ = '\0' ; tcp -> th_dport = htons ( tx_portnum ( last ) ) ; } ip -> ip_dst . s_addr = tx_hostnum ( * cpp , & r ) ; cpp ++ ; if ( * cpp && ip -> ip_p == IPPROTO_TCP ) { char * s , * t ; tcp -> th_flags = 0 ; for ( s = * cpp ; * s ; s ++ ) { if ( ( t = strchr ( myflagset , * s ) ) ) { tcp -> th_flags |= myflags [ t - myflagset ] ; } } if ( tcp -> th_flags ) { cpp ++ ; } if ( tcp -> th_flags == 0 ) { abort ( ) ; } if ( tcp -> th_flags & TH_URG ) { tcp -> th_urp = htons ( 1 ) ; } } if ( * cpp && ip -> ip_p == IPPROTO_ICMP ) { extern char * tx_icmptypes [ ] ; char * * s , * t ; int i ; for ( s = tx_icmptypes , i = 0 ; ! * s || strcmp ( * s , "END" ) ; s ++ , i ++ ) { if ( * s && ! strncasecmp ( * cpp , * s , strlen ( * s ) ) ) { ic -> icmp_type = i ; if ( ( t = strchr ( * cpp , ',' ) ) ) { ic -> icmp_code = atoi ( t + 1 ) ; } cpp ++ ; break ; } } } if ( * cpp && ! strcasecmp ( * cpp , "opt" ) ) { u_long olen ; cpp ++ ; olen = buildopts ( * cpp , ipopts , ( IP_HL ( ip ) - 5 ) << 2 ) ; if ( olen ) { bcopy ( ipopts , ( char * ) ( ip + 1 ) , olen ) ; IP_HL_A ( ip , IP_HL ( ip ) + ( olen >> 2 ) ) ; } } if ( ip -> ip_p == IPPROTO_TCP || ip -> ip_p == IPPROTO_UDP ) { bcopy ( ( char * ) tcp , ( ( char * ) ip ) + ( IP_HL ( ip ) << 2 ) , sizeof ( * tcp ) ) ; } if ( ip -> ip_p == IPPROTO_ICMP ) { bcopy ( ( char * ) ic , ( ( char * ) ip ) + ( IP_HL ( ip ) << 2 ) , sizeof ( * ic ) ) ; } ip -> ip_len = htons ( ip -> ip_len ) ; return 0 ; } 