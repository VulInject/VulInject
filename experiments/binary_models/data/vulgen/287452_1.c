OP * Perl_pmruntime ( pTHX_ OP * o , OP * expr , OP * repl , UV flags , I32 floor ) { PMOP * pm ; LOGOP * rcop ; I32 repl_has_vars = 0 ; bool is_trans = ( o -> op_type == OP_TRANS || o -> op_type == OP_TRANSR ) ; bool is_compiletime ; bool has_code ; bool isreg = cBOOL ( flags & 1 ) ; bool is_split = cBOOL ( flags & 2 ) ; PERL_ARGS_ASSERT_PMRUNTIME ; if ( is_trans ) { return pmtrans ( o , expr , repl ) ; } is_compiletime = 1 ; has_code = 0 ; if ( expr -> op_type == OP_LIST ) { OP * child ; for ( child = cLISTOPx ( expr ) -> op_first ; child ; child = OpSIBLING ( child ) ) { if ( child -> op_type == OP_NULL && ( child -> op_flags & OPf_SPECIAL ) ) { has_code = 1 ; assert ( ! child -> op_next ) ; if ( UNLIKELY ( ! OpHAS_SIBLING ( child ) ) ) { op_sibling_splice ( expr , child , 0 , newSVOP ( OP_CONST , 0 , & PL_sv_no ) ) ; } child -> op_next = OpSIBLING ( child ) ; } if ( child -> op_type != OP_CONST && child -> op_type != OP_PUSHMARK ) { is_compiletime = 0 ; } } } if ( expr -> op_type != OP_CONST ) { is_compiletime = 0 ; } LINKLIST ( expr ) ; if ( expr -> op_type == OP_LIST ) { OP * child ; for ( child = cLISTOPx ( expr ) -> op_first ; child ; child = OpSIBLING ( child ) ) { if ( child -> op_type == OP_PADAV || child -> op_type == OP_RV2AV ) { assert ( ! ( child -> op_flags & OPf_WANT ) ) ; child -> op_flags |= ( OPf_WANT_LIST | OPf_REF ) ; continue ; } if ( ! ( child -> op_type == OP_NULL && ( child -> op_flags & OPf_SPECIAL ) ) ) { continue ; } child -> op_next = NULL ; scalar ( child ) ; LINKLIST ( child ) ; if ( cLISTOPx ( child ) -> op_first -> op_type == OP_LEAVE ) { LISTOP * leaveop = cLISTOPx ( cLISTOPx ( child ) -> op_first ) ; assert ( leaveop -> op_first -> op_type == OP_ENTER ) ; assert ( OpHAS_SIBLING ( leaveop -> op_first ) ) ; child -> op_next = OpSIBLING ( leaveop -> op_first ) ; assert ( leaveop -> op_flags & OPf_KIDS ) ; assert ( leaveop -> op_last -> op_next == ( OP * ) leaveop ) ; leaveop -> op_next = NULL ; op_null ( ( OP * ) leaveop ) ; } else { OP * scope = cLISTOPx ( child ) -> op_first ; assert ( scope -> op_type == OP_SCOPE ) ; assert ( scope -> op_flags & OPf_KIDS ) ; scope -> op_next = NULL ; op_null ( scope ) ; } optimize_optree ( child ) ; CALL_PEEP ( child ) ; S_prune_chain_head ( & ( child -> op_next ) ) ; if ( is_compiletime ) { finalize_optree ( child ) ; } } } if ( expr -> op_type == OP_PADAV || expr -> op_type == OP_RV2AV ) { assert ( ! ( expr -> op_flags & OPf_WANT ) ) ; expr -> op_flags |= ( OPf_WANT_LIST | OPf_REF ) ; } PL_hints |= HINT_BLOCK_SCOPE ; pm = ( PMOP * ) o ; assert ( floor == 0 || ( pm -> op_pmflags & PMf_HAS_CV ) ) ; if ( is_compiletime ) { U32 rx_flags = pm -> op_pmflags & RXf_PMf_COMPILETIME ; regexp_engine const * eng = current_re_engine ( ) ; if ( is_split ) { pm -> op_pmflags |= PMf_SPLIT ; rx_flags |= RXf_SPLIT ; } if ( ! has_code || ! eng -> op_comp ) { if ( ( pm -> op_pmflags & PMf_HAS_CV ) && ! has_code ) { SSize_t i = 0 ; assert ( PadnamelistMAXNAMED ( PL_comppad_name ) == 0 ) ; while ( ++ i <= AvFILLp ( PL_comppad ) ) { assert ( ! PL_curpad [ i ] || SvPADTMP ( PL_curpad [ i ] ) ) ; assert ( ! PL_curpad [ i ] ) ; } LEAVE_SCOPE ( floor ) ; pm -> op_pmflags &= ~ PMf_HAS_CV ; } if ( pm -> op_pmflags & PMf_HAS_ERROR ) { return o ; } PM_SETRE ( pm , eng -> op_comp ?eng -> op_comp ( , 0 , , , , , , ) : Perl_re_op_compile ( , 0 , , , , , , ) ) ; op_free ( expr ) ; } else { REGEXP * re ; if ( pm -> op_pmflags & PMf_HAS_ERROR ) { return o ; } re = eng -> op_comp ( , 0 , , , , , , 0 ) ; PM_SETRE ( pm , re ) ; if ( pm -> op_pmflags & PMf_HAS_CV ) { CV * cv ; OP * qr = newPMOP ( OP_QR , 0 ) ; ( ( PMOP * ) qr ) -> op_code_list = expr ; SvREFCNT_inc_simple_void ( PL_compcv ) ; cv = newATTRSUB ( floor , 0 , NULL , NULL , qr ) ; ReANY ( re ) -> qr_anoncv = cv ; ( void ) pad_add_anon ( cv , o -> op_type ) ; SvREFCNT_inc_simple_void ( cv ) ; } else { pm -> op_code_list = expr ; } } } else { bool reglist ; PADOFFSET cv_targ = 0 ; reglist = isreg && expr -> op_type == OP_LIST ; if ( reglist ) { op_null ( expr ) ; } if ( has_code ) { pm -> op_code_list = expr ; pm -> op_pmflags |= PMf_CODELIST_PRIVATE ; } if ( is_split ) { pm -> op_pmflags |= PMf_SPLIT ; } if ( pm -> op_pmflags & PMf_KEEP || TAINTING_get ) { expr = newUNOP ( ( TAINTING_get ?OP_REGCRESET : OP_REGCMAYBE ) , 0 , expr ) ; } if ( pm -> op_pmflags & PMf_HAS_CV ) { SvREFCNT_inc_simple_void ( PL_compcv ) ; CvLVALUE_on ( PL_compcv ) ; expr = newSVOP ( OP_ANONCODE , 0 , MUTABLE_SV ( newATTRSUB ( floor , 0 , NULL , NULL , expr ) ) ) ; cv_targ = expr -> op_targ ; expr = newUNOP ( OP_REFGEN , 0 , expr ) ; expr = list ( force_list ( newUNOP ( OP_ENTERSUB , 0 , scalar ( expr ) ) , TRUE ) ) ; } rcop = alloc_LOGOP ( OP_REGCOMP , scalar ( expr ) , o ) ; rcop -> op_flags |= ( ( PL_hints & HINT_RE_EVAL ) ?OPf_SPECIAL : 0 ) | ( reglist ?OPf_STACKED : 0 ) ; rcop -> op_targ = cv_targ ; if ( PL_hints & HINT_RE_EVAL ) { S_set_haseval ( aTHX ) ; } if ( expr -> op_type == OP_REGCRESET || expr -> op_type == OP_REGCMAYBE ) { LINKLIST ( expr ) ; rcop -> op_next = expr ; ( ( UNOP * ) expr ) -> op_first -> op_next = ( OP * ) rcop ; } else { rcop -> op_next = LINKLIST ( expr ) ; expr -> op_next = ( OP * ) rcop ; } op_prepend_elem ( o -> op_type , scalar ( ( OP * ) rcop ) , o ) ; } if ( repl ) { OP * curop = repl ; bool konst ; if ( curop -> op_type == OP_NULL && curop -> op_flags & OPf_KIDS && cUNOPx ( curop ) -> op_first -> op_type == OP_SCOPE && cUNOPx ( curop ) -> op_first -> op_flags & OPf_KIDS ) { OP * sib ; OP * kid = cUNOPx ( cUNOPx ( curop ) -> op_first ) -> op_first ; if ( kid -> op_type == OP_NULL && ( sib = OpSIBLING ( kid ) ) && ! OpHAS_SIBLING ( sib ) ) { curop = sib ; } } if ( curop -> op_type == OP_CONST ) { konst = TRUE ; } if ( ( ( curop -> op_type == OP_RV2SV || curop -> op_type == OP_RV2AV || curop -> op_type == OP_RV2HV || curop -> op_type == OP_RV2GV ) && cUNOPx ( curop ) -> op_first && cUNOPx ( curop ) -> op_first -> op_type == OP_GV ) || curop -> op_type == OP_PADSV || curop -> op_type == OP_PADAV || curop -> op_type == OP_PADHV || curop -> op_type == OP_PADANY ) { repl_has_vars = 1 ; konst = TRUE ; } else { konst = FALSE ; } if ( konst && ! ( repl_has_vars && ( ! PM_GETRE ( pm ) || ! RX_PRELEN ( PM_GETRE ( pm ) ) || RX_EXTFLAGS ( PM_GETRE ( pm ) ) & RXf_EVAL_SEEN ) ) ) { pm -> op_pmflags |= PMf_CONST ; op_prepend_elem ( o -> op_type , scalar ( repl ) , o ) ; } else { rcop = alloc_LOGOP ( OP_SUBSTCONT , scalar ( repl ) , o ) ; rcop -> op_private = 1 ; rcop -> op_next = LINKLIST ( repl ) ; repl -> op_next = ( OP * ) rcop ; pm -> op_pmreplrootu . op_pmreplroot = scalar ( ( OP * ) rcop ) ; assert ( ! ( pm -> op_pmflags & PMf_ONCE ) ) ; pm -> op_pmstashstartu . op_pmreplstart = LINKLIST ( rcop ) ; rcop -> op_next = 0 ; } } return ( OP * ) pm ; } 