static int lmv_iocontrol ( unsigned int cmd , struct obd_export * exp , int len , void * karg , void __user * uarg ) { struct obd_device * obddev = class_exp2obd ( exp ) ; struct lmv_obd * lmv = & obddev -> u . lmv ; struct lmv_tgt_desc * tgt = NULL ; u32 i = 0 ; int rc = 0 ; int set = 0 ; u32 count = lmv -> desc . ld_tgt_count ; switch ( cmd ) { case IOC_OBD_STATFS : { struct obd_ioctl_data * data = karg ; struct obd_device * mdc_obd ; struct obd_statfs stat_buf = { 0 } ; __u32 index ; memcpy ( & index , data -> ioc_inlbuf2 , sizeof ( __u32 ) ) ; if ( index >= count ) { return - ENODEV ; } tgt = lmv -> tgts [ index ] ; if ( ! tgt || ! tgt -> ltd_active ) { return - ENODATA ; } mdc_obd = class_exp2obd ( tgt -> ltd_exp ) ; if ( ! mdc_obd ) { return - EINVAL ; } if ( copy_to_user ( data -> ioc_pbuf2 , obd2cli_tgt ( mdc_obd ) , min ( ( int ) data -> ioc_plen2 , ( int ) sizeof ( obd_uuid ) ) ) ) { return - EFAULT ; } rc = obd_statfs ( NULL , tgt -> ltd_exp , & stat_buf , cfs_time_shift_64 ( - OBD_STATFS_CACHE_SECONDS ) , 0 ) ; if ( rc ) { return rc ; } if ( copy_to_user ( data -> ioc_pbuf1 , & stat_buf , min ( ( int ) data -> ioc_plen1 , ( int ) sizeof ( stat_buf ) ) ) ) { return - EFAULT ; } break ; } case OBD_IOC_QUOTACTL : { struct if_quotactl * qctl = karg ; struct obd_quotactl * oqctl ; if ( qctl -> qc_valid == QC_MDTIDX ) { if ( count <= qctl -> qc_idx ) { return - EINVAL ; } tgt = lmv -> tgts [ qctl -> qc_idx ] ; if ( ! tgt || ! tgt -> ltd_exp ) { return - EINVAL ; } } if ( qctl -> qc_valid == QC_UUID ) { for ( i = 0 ; i < count ; i ++ ) { tgt = lmv -> tgts [ i ] ; if ( ! tgt ) { continue ; } if ( ! obd_uuid_equals ( & tgt -> ltd_uuid , & qctl -> obd_uuid ) ) { continue ; } if ( ! tgt -> ltd_exp ) { return - EINVAL ; } break ; } } else { return - EINVAL ; } if ( i >= count ) { return - EAGAIN ; } LASSERT ( tgt && tgt -> ltd_exp ) ; oqctl = kzalloc ( sizeof ( * oqctl ) , GFP_NOFS ) ; if ( ! oqctl ) { return - ENOMEM ; } QCTL_COPY ( oqctl , qctl ) ; rc = obd_quotactl ( tgt -> ltd_exp , oqctl ) ; if ( rc == 0 ) { QCTL_COPY ( qctl , oqctl ) ; qctl -> qc_valid = QC_MDTIDX ; qctl -> obd_uuid = tgt -> ltd_uuid ; } kfree ( oqctl ) ; break ; } case OBD_IOC_CHANGELOG_SEND : case OBD_IOC_CHANGELOG_CLEAR : { struct ioc_changelog * icc = karg ; if ( icc -> icc_mdtindex >= count ) { return - ENODEV ; } tgt = lmv -> tgts [ icc -> icc_mdtindex ] ; if ( ! tgt || ! tgt -> ltd_exp || ! tgt -> ltd_active ) { return - ENODEV ; } rc = obd_iocontrol ( cmd , tgt -> ltd_exp , sizeof ( * icc ) , icc , NULL ) ; break ; } case LL_IOC_GET_CONNECT_FLAGS : { tgt = lmv -> tgts [ 0 ] ; if ( ! tgt || ! tgt -> ltd_exp ) { return - ENODATA ; } rc = obd_iocontrol ( cmd , tgt -> ltd_exp , len , karg , uarg ) ; break ; } case LL_IOC_FID2MDTIDX : { struct lu_fid * fid = karg ; int mdt_index ; rc = lmv_fld_lookup ( lmv , fid , & mdt_index ) ; if ( rc ) { return rc ; } * ( __u32 * ) uarg = mdt_index ; break ; } case OBD_IOC_FID2PATH : { rc = lmv_fid2path ( exp , len , karg , uarg ) ; break ; } case LL_IOC_HSM_STATE_GET : case LL_IOC_HSM_STATE_SET : case LL_IOC_HSM_ACTION : { struct md_op_data * op_data = karg ; tgt = lmv_find_target ( lmv , & op_data -> op_fid1 ) ; if ( IS_ERR ( tgt ) ) { return PTR_ERR ( tgt ) ; } if ( ! tgt -> ltd_exp ) { return - EINVAL ; } rc = obd_iocontrol ( cmd , tgt -> ltd_exp , len , karg , uarg ) ; break ; } case LL_IOC_HSM_PROGRESS : { const struct hsm_progress_kernel * hpk = karg ; tgt = lmv_find_target ( lmv , & hpk -> hpk_fid ) ; if ( IS_ERR ( tgt ) ) { return PTR_ERR ( tgt ) ; } rc = obd_iocontrol ( cmd , tgt -> ltd_exp , len , karg , uarg ) ; break ; } case LL_IOC_HSM_REQUEST : { struct hsm_user_request * hur = karg ; unsigned int reqcount = hur -> hur_request . hr_itemcount ; if ( reqcount == 0 ) { return 0 ; } if ( reqcount == 1 || count == 1 ) { tgt = lmv_find_target ( lmv , & hur -> hur_user_item [ 0 ] . hui_fid ) ; if ( IS_ERR ( tgt ) ) { return PTR_ERR ( tgt ) ; } rc = obd_iocontrol ( cmd , tgt -> ltd_exp , len , karg , uarg ) ; } else { for ( i = 0 ; i < count ; i ++ ) { struct hsm_user_request * req ; size_t reqlen ; int nr , rc1 ; tgt = lmv -> tgts [ i ] ; if ( ! tgt || ! tgt -> ltd_exp ) { continue ; } nr = lmv_hsm_req_count ( lmv , hur , tgt ) ; if ( nr < 0 ) { return nr ; } if ( nr == 0 ) { continue ; } reqlen = offsetof ( typeof ( * hur ) , hur_user_item [ nr ] ) + hur -> hur_request . hr_data_len ; req = libcfs_kvzalloc ( reqlen , GFP_NOFS ) ; if ( ! req ) { return - ENOMEM ; } rc1 = lmv_hsm_req_build ( lmv , hur , tgt , req ) ; if ( rc1 < 0 ) { hsm_req_err } rc1 = obd_iocontrol ( cmd , tgt -> ltd_exp , reqlen , req , uarg ) ; hsm_req_err if ( rc1 != 0 && rc == 0 ) { rc = rc1 ; } kvfree ( req ) ; } } break ; } case LL_IOC_LOV_SWAP_LAYOUTS : { struct md_op_data * op_data = karg ; struct lmv_tgt_desc * tgt1 , * tgt2 ; tgt1 = lmv_find_target ( lmv , & op_data -> op_fid1 ) ; if ( IS_ERR ( tgt1 ) ) { return PTR_ERR ( tgt1 ) ; } tgt2 = lmv_find_target ( lmv , & op_data -> op_fid2 ) ; if ( IS_ERR ( tgt2 ) ) { return PTR_ERR ( tgt2 ) ; } if ( ! tgt1 -> ltd_exp || ! tgt2 -> ltd_exp ) { return - EINVAL ; } if ( tgt1 -> ltd_idx != tgt2 -> ltd_idx ) { return - EPERM ; } rc = obd_iocontrol ( cmd , tgt1 -> ltd_exp , len , karg , uarg ) ; break ; } case LL_IOC_HSM_CT_START : { struct lustre_kernelcomm * lk = karg ; if ( lk -> lk_flags & LK_FLG_STOP ) { rc = lmv_hsm_ct_unregister ( lmv , cmd , len , lk , uarg ) ; } else { rc = lmv_hsm_ct_register ( lmv , cmd , len , lk , uarg ) ; } break ; } default : for ( i = 0 ; i < count ; i ++ ) { struct obd_device * mdc_obd ; int err ; tgt = lmv -> tgts [ i ] ; if ( ! tgt || ! tgt -> ltd_exp ) { continue ; } mdc_obd = class_exp2obd ( tgt -> ltd_exp ) ; mdc_obd -> obd_force = obddev -> obd_force ; err = obd_iocontrol ( cmd , tgt -> ltd_exp , len , karg , uarg ) ; if ( err ) { if ( tgt -> ltd_active ) { CERROR ( "error: iocontrol MDC %s on MDTidx %d cmd %x: err = %d\n" , tgt -> ltd_uuid . uuid , i , cmd , err ) ; if ( ! rc ) { rc = err ; } } } else { set = 1 ; } } if ( ! set && ! rc ) { rc = - EIO ; } } return rc ; } 