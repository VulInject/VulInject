static int qsv_get_continuous_buffer ( AVCodecContext * avctx , AVFrame * frame , AVBufferPool * pool ) { int ret ; ret = ff_decode_frame_props ( avctx , frame ) ; if ( ret < 0 ) { return ret ; } frame -> width = avctx -> width ; frame -> height = avctx -> height ; switch ( avctx -> pix_fmt ) { case AV_PIX_FMT_NV12 : frame -> linesize [ 0 ] = FFALIGN ( avctx -> width , 128 ) ; break ; case AV_PIX_FMT_P010 : case AV_PIX_FMT_P012 : case AV_PIX_FMT_YUYV422 : frame -> linesize [ 0 ] = 2 * FFALIGN ( avctx -> width , 128 ) ; break ; case AV_PIX_FMT_Y210 : case AV_PIX_FMT_VUYX : case AV_PIX_FMT_XV30 : case AV_PIX_FMT_Y212 : frame -> linesize [ 0 ] = 4 * FFALIGN ( avctx -> width , 128 ) ; break ; case AV_PIX_FMT_XV36 : frame -> linesize [ 0 ] = 8 * FFALIGN ( avctx -> width , 128 ) ; break ; default : av_log ( avctx , AV_LOG_ERROR , "Unsupported pixel format.\n" ) ; return AVERROR ( EINVAL ) ; } frame -> buf [ 0 ] = av_buffer_pool_get ( pool ) ; if ( ! frame -> buf [ 0 ] ) { return AVERROR ( ENOMEM ) ; } frame -> data [ 0 ] = frame -> buf [ 0 ] -> data ; if ( avctx -> pix_fmt == AV_PIX_FMT_NV12 || avctx -> pix_fmt == AV_PIX_FMT_P010 || avctx -> pix_fmt == AV_PIX_FMT_P012 ) { frame -> linesize [ 1 ] = frame -> linesize [ 0 ] ; frame -> data [ 1 ] = frame -> data [ 0 ] + frame -> linesize [ 0 ] * FFALIGN ( avctx -> height , 64 ) ; } ret = ff_attach_decode_data ( frame ) ; if ( ret < 0 ) { return ret ; } return 0 ; } 