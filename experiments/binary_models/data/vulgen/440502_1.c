unsigned long invalidate_mapping_pages ( struct address_space * mapping , pgoff_t start , pgoff_t end ) { pgoff_t indices [ PAGEVEC_SIZE ] ; struct pagevec pvec ; pgoff_t index = start ; unsigned long ret ; unsigned long count = 0 ; int i ; pagevec_init ( & pvec , 0 ) ; while ( index <= end && pagevec_lookup_entries ( & pvec , mapping , index , min ( end - index , ( pgoff_t ) PAGEVEC_SIZE - 1 ) + 1 , indices ) ) { for ( i = 0 ; i < pagevec_count ( & pvec ) ; i ++ ) { struct page * page = pvec . pages [ i ] ; index = indices [ i ] ; if ( radix_tree_exceptional_entry ( page ) ) { invalidate_exceptional_entry ( mapping , index , page ) ; continue ; } if ( ! trylock_page ( page ) ) { continue ; } WARN_ON ( page_to_index ( page ) != index ) ; if ( PageTransTail ( page ) ) { unlock_page ( page ) ; continue ; } if ( PageTransHuge ( page ) ) { index += HPAGE_PMD_NR - 1 ; i += HPAGE_PMD_NR - 1 ; if ( index == round_down ( end , HPAGE_PMD_NR ) ) { continue ; } } ret = invalidate_inode_page ( page ) ; unlock_page ( page ) ; if ( ! ret ) { deactivate_file_page ( page ) ; } count += ret ; } pagevec_remove_exceptionals ( & pvec ) ; pagevec_release ( & pvec ) ; cond_resched ( ) ; index ++ ; } return count ; } 