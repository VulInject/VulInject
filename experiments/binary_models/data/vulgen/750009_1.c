void zfcp_dbf_scsi_common ( char * tag , int level , struct scsi_device * sdev , struct scsi_cmnd * sc , struct zfcp_fsf_req * fsf ) { struct zfcp_adapter * adapter = ( zfcp_adapter * ) sdev -> host -> hostdata [ 0 ] ; struct zfcp_dbf * dbf = adapter -> dbf ; struct zfcp_dbf_scsi * rec = & dbf -> scsi_buf ; struct fcp_resp_with_ext * fcp_rsp ; struct fcp_resp_rsp_info * fcp_rsp_info ; unsigned long flags ; spin_lock_irqsave ( & dbf -> scsi_lock , flags ) ; memset ( rec , 0 , sizeof ( * rec ) ) ; memcpy ( rec -> tag , tag , ZFCP_DBF_TAG_LEN ) ; rec -> id = ZFCP_DBF_SCSI_CMND ; if ( sc ) { rec -> scsi_result = sc -> result ; rec -> scsi_retries = sc -> retries ; rec -> scsi_allowed = sc -> allowed ; rec -> scsi_id = sc -> device -> id ; rec -> scsi_lun = ( u32 ) sc -> device -> lun ; rec -> scsi_lun_64_hi = ( u32 ) ( sc -> device -> lun >> 32 ) ; rec -> host_scribble = ( unsigned long ) sc -> host_scribble ; memcpy ( rec -> scsi_opcode , sc -> cmnd , min_t ( int , sc -> cmd_len , ZFCP_DBF_SCSI_OPCODE ) ) ; } else { rec -> scsi_result = ~ 0 ; rec -> scsi_retries = ~ 0 ; rec -> scsi_allowed = ~ 0 ; rec -> scsi_id = sdev -> id ; rec -> scsi_lun = ( u32 ) sdev -> lun ; rec -> scsi_lun_64_hi = ( u32 ) ( sdev -> lun >> 32 ) ; rec -> host_scribble = ~ 0 ; memset ( rec -> scsi_opcode , 0xff , ZFCP_DBF_SCSI_OPCODE ) ; } if ( fsf ) { rec -> fsf_req_id = fsf -> req_id ; rec -> pl_len = FCP_RESP_WITH_EXT ; fcp_rsp = & ( fsf -> qtcb -> bottom . io . fcp_rsp . iu ) ; memcpy ( & rec -> fcp_rsp , fcp_rsp , FCP_RESP_WITH_EXT ) ; if ( fcp_rsp -> resp . fr_flags & FCP_RSP_LEN_VAL ) { fcp_rsp_info = ( fcp_resp_rsp_info * ) & fcp_rsp [ 1 ] ; rec -> fcp_rsp_info = fcp_rsp_info -> rsp_code ; rec -> pl_len += be32_to_cpu ( fcp_rsp -> ext . fr_rsp_len ) ; } if ( fcp_rsp -> resp . fr_flags & FCP_SNS_LEN_VAL ) { rec -> pl_len += be32_to_cpu ( fcp_rsp -> ext . fr_sns_len ) ; } } debug_event ( dbf -> scsi , level , rec , sizeof ( * rec ) ) ; spin_unlock_irqrestore ( & dbf -> scsi_lock , flags ) ; } 