static int mvsd_probe ( struct platform_device * pdev ) { struct device_node * np = pdev -> dev . of_node ; struct mmc_host * mmc = NULL ; struct mvsd_host * host = NULL ; const struct mbus_dram_target_info * dram ; int ret , irq ; if ( ! np ) { dev_err ( & pdev -> dev , "no DT node\n" ) ; return - ENODEV ; } irq = platform_get_irq ( pdev , 0 ) ; if ( irq < 0 ) { return - ENXIO ; } mmc = mmc_alloc_host ( sizeof ( mvsd_host ) , & pdev -> dev ) ; if ( ! mmc ) { ret = - ENOMEM ; out } host = mmc_priv ( mmc ) ; host -> mmc = mmc ; host -> dev = & pdev -> dev ; host -> clk = devm_clk_get ( & pdev -> dev , NULL ) ; if ( IS_ERR ( host -> clk ) ) { dev_err ( & pdev -> dev , "no clock associated\n" ) ; ret = - EINVAL ; out } clk_prepare_enable ( host -> clk ) ; mmc -> ops = & mvsd_ops ; mmc -> ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34 ; mmc -> f_min = DIV_ROUND_UP ( host -> base_clock , MVSD_BASE_DIV_MAX ) ; mmc -> f_max = MVSD_CLOCKRATE_MAX ; mmc -> max_blk_size = 2048 ; mmc -> max_blk_count = 65535 ; mmc -> max_segs = 1 ; mmc -> max_seg_size = mmc -> max_blk_size * mmc -> max_blk_count ; host -> base_clock = clk_get_rate ( host -> clk ) / 2 ; ret = mmc_of_parse ( mmc ) ; if ( ret < 0 ) { out } if ( maxfreq ) { mmc -> f_max = maxfreq ; } spin_lock_init ( & host -> lock ) ; host -> base = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( host -> base ) ) { ret = PTR_ERR ( host -> base ) ; out } dram = mv_mbus_dram_info ( ) ; if ( dram ) { mv_conf_mbus_windows ( host , dram ) ; } mvsd_power_down ( host ) ; ret = devm_request_irq ( & pdev -> dev , irq , mvsd_irq , 0 , DRIVER_NAME , host ) ; if ( ret ) { dev_err ( & pdev -> dev , "cannot assign irq %d\n" , irq ) ; out } timer_setup ( & host -> timer , mvsd_timeout_timer , 0 ) ; platform_set_drvdata ( pdev , mmc ) ; ret = mmc_add_host ( mmc ) ; if ( ret ) { out } if ( ! ( mmc -> caps & MMC_CAP_NEEDS_POLL ) ) { dev_dbg ( & pdev -> dev , "using GPIO for card detection\n" ) ; } else { dev_dbg ( & pdev -> dev , "lacking card detect (fall back to polling)\n" ) ; } return 0 ; out if ( mmc ) { if ( ! IS_ERR ( host -> clk ) ) { clk_disable_unprepare ( host -> clk ) ; } mmc_free_host ( mmc ) ; } return ret ; } 