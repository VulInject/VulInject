static struct i915_gem_engines * user_engines ( struct i915_gem_context * ctx , unsigned int num_engines , struct i915_gem_proto_engine * pe ) { struct i915_gem_engines * e , * err ; unsigned int n ; e = alloc_engines ( num_engines ) ; if ( ! e ) { return ERR_PTR ( - ENOMEM ) ; } e -> num_engines = num_engines ; for ( n = 0 ; n < num_engines ; n ++ ) { struct intel_context * ce , * child ; int ret ; switch ( pe [ n ] . type ) { case I915_GEM_ENGINE_TYPE_PHYSICAL : ce = intel_context_create ( pe [ n ] . engine ) ; break ; case I915_GEM_ENGINE_TYPE_BALANCED : ce = intel_engine_create_virtual ( pe [ n ] . siblings , pe [ n ] . num_siblings , 0 ) ; break ; case I915_GEM_ENGINE_TYPE_PARALLEL : ce = intel_engine_create_parallel ( pe [ n ] . siblings , pe [ n ] . num_siblings , pe [ n ] . width ) ; break ; case I915_GEM_ENGINE_TYPE_INVALID : default : GEM_WARN_ON ( pe [ n ] . type != I915_GEM_ENGINE_TYPE_INVALID ) ; continue ; } if ( IS_ERR ( ce ) ) { err = ERR_CAST ( ce ) ; free_engines } e -> engines [ n ] = ce ; ret = intel_context_set_gem ( ce , ctx , pe -> sseu ) ; if ( ret ) { free_engines } for_each_child ( , ) { ret = intel_context_set_gem ( child , ctx , pe -> sseu ) ; if ( ret ) { err = ERR_PTR ( ret ) ; free_engines } } if ( pe [ n ] . type == I915_GEM_ENGINE_TYPE_PARALLEL ) { ret = perma_pin_contexts ( ce ) ; if ( ret ) { err = ERR_PTR ( ret ) ; free_engines } } } return e ; free_engines free_engines ( e ) ; return err ; } 