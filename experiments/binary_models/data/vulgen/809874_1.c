static int ns_init_card ( int i , struct pci_dev * pcidev ) { int j ; struct ns_dev * card = NULL ; unsigned char pci_latency ; unsigned error ; u32 data ; u32 u32d [ 4 ] ; u32 ns_cfg_rctsize ; int bcount ; unsigned long membase ; error = 0 ; if ( pci_enable_device ( pcidev ) ) { printk ( "nicstar%d: can't enable PCI device\n" , i ) ; error = 2 ; ns_init_card_error ( card , error ) ; return error ; } if ( dma_set_mask_and_coherent ( & pcidev -> dev , DMA_BIT_MASK ( 32 ) ) != 0 ) { printk ( KERN_WARNING "nicstar%d: No suitable DMA available.\n" , i ) ; error = 2 ; ns_init_card_error ( card , error ) ; return error ; } card = kmalloc ( sizeof ( * card ) , GFP_KERNEL ) ; if ( ! card ) { printk ( "nicstar%d: can't allocate memory for device structure.\n" , i ) ; error = 2 ; ns_init_card_error ( card , error ) ; return error ; } cards [ i ] = card ; spin_lock_init ( & card -> int_lock ) ; spin_lock_init ( & card -> res_lock ) ; pci_set_drvdata ( pcidev , card ) ; card -> index = i ; card -> atmdev = NULL ; card -> pcidev = pcidev ; membase = pci_resource_start ( pcidev , 1 ) ; card -> membase = ioremap ( membase , NS_IOREMAP_SIZE ) ; if ( ! card -> membase ) { printk ( "nicstar%d: can't ioremap() membase.\n" , i ) ; error = 3 ; ns_init_card_error ( card , error ) ; return error ; } PRINTK ( "nicstar%d: membase at 0x%p.\n" , i , card -> membase ) ; pci_set_master ( pcidev ) ; if ( pci_read_config_byte ( pcidev , PCI_LATENCY_TIMER , & pci_latency ) != 0 ) { printk ( "nicstar%d: can't read PCI latency timer.\n" , i ) ; error = 6 ; ns_init_card_error ( card , error ) ; return error ; } if ( pci_latency < NS_PCI_LATENCY ) { PRINTK ( "nicstar%d: setting PCI latency timer to %d.\n" , i , NS_PCI_LATENCY ) ; for ( j = 1 ; j < 4 ; j ++ ) { if ( pci_write_config_byte ( pcidev , PCI_LATENCY_TIMER , NS_PCI_LATENCY ) != 0 ) { break ; } } if ( j == 4 ) { printk ( "nicstar%d: can't set PCI latency timer to %d.\n" , i , NS_PCI_LATENCY ) ; error = 7 ; ns_init_card_error ( card , error ) ; return error ; } } data = readl ( card -> membase + STAT ) ; if ( data & NS_STAT_TMROF ) { writel ( NS_STAT_TMROF , card -> membase + STAT ) ; } writel ( NS_CFG_SWRST , card -> membase + CFG ) ; NS_DELAY ; writel ( 0x00000000 , card -> membase + CFG ) ; writel ( 0x00000008 , card -> membase + GP ) ; NS_DELAY ; writel ( 0x00000001 , card -> membase + GP ) ; NS_DELAY ; while ( CMD_BUSY ( card ) ) { } writel ( NS_CMD_WRITE_UTILITY | 0x00000100 , card -> membase + CMD ) ; NS_DELAY ; while ( CMD_BUSY ( card ) ) { } writel ( NS_CMD_READ_UTILITY | 0x00000200 , card -> membase + CMD ) ; while ( CMD_BUSY ( card ) ) { } data = readl ( card -> membase + DR0 ) ; switch ( data ) { case 0x00000009 : printk ( "nicstar%d: PHY seems to be 25 Mbps.\n" , i ) ; card -> max_pcr = ATM_25_PCR ; while ( CMD_BUSY ( card ) ) { } writel ( 0x00000008 , card -> membase + DR0 ) ; writel ( NS_CMD_WRITE_UTILITY | 0x00000200 , card -> membase + CMD ) ; writel ( NS_STAT_SFBQF , card -> membase + STAT ) ; while ( CMD_BUSY ( card ) ) { } writel ( 0x00000022 , card -> membase + DR0 ) ; writel ( NS_CMD_WRITE_UTILITY | 0x00000202 , card -> membase + CMD ) ; break ; case 0x00000030 : case 0x00000031 : printk ( "nicstar%d: PHY seems to be 155 Mbps.\n" , i ) ; card -> max_pcr = ATM_OC3_PCR ; while ( CMD_BUSY ( card ) ) { } writel ( 0x00000002 , card -> membase + DR0 ) ; writel ( NS_CMD_WRITE_UTILITY | 0x00000205 , card -> membase + CMD ) ; break ; default : printk ( "nicstar%d: unknown PHY type (0x%08X).\n" , i , data ) ; error = 8 ; ns_init_card_error ( card , error ) ; return error ; } writel ( 0x00000000 , card -> membase + GP ) ; data = 0x76543210 ; ns_write_sram ( card , 0x1C003 , & data , 1 ) ; data = 0x89ABCDEF ; ns_write_sram ( card , 0x14003 , & data , 1 ) ; if ( ns_read_sram ( card , 0x14003 ) == 0x89ABCDEF && ns_read_sram ( card , 0x1C003 ) == 0x76543210 ) { card -> sram_size = 128 ; } else { card -> sram_size = 32 ; } PRINTK ( "nicstar%d: %dK x 32bit SRAM size.\n" , i , card -> sram_size ) ; card -> rct_size = NS_MAX_RCTSIZE ; if ( card -> sram_size == 128 ) { printk ( "nicstar%d: limiting maximum VCI. See NS_MAX_RCTSIZE in nicstar.h\n" , i ) ; } if ( card -> sram_size == 32 ) { printk ( "nicstar%d: wasting memory. See NS_MAX_RCTSIZE in nicstar.h\n" , i ) ; card -> rct_size = 4096 ; } card -> vpibits = NS_VPIBITS ; if ( card -> rct_size == 4096 ) { card -> vcibits = 12 - NS_VPIBITS ; } else { card -> vcibits = 14 - NS_VPIBITS ; } if ( mac [ i ] == NULL ) { nicstar_init_eprom ( card -> membase ) ; } writel ( 0x00000000 , card -> membase + VPM ) ; card -> tsq . org = dma_alloc_coherent ( & card -> pcidev -> dev , NS_TSQSIZE + NS_TSQ_ALIGNMENT , & card -> tsq . dma , GFP_KERNEL ) ; if ( card -> tsq . org == NULL ) { printk ( "nicstar%d: can't allocate TSQ.\n" , i ) ; error = 10 ; ns_init_card_error ( card , error ) ; return error ; } card -> tsq . base = PTR_ALIGN ( card -> tsq . org , NS_TSQ_ALIGNMENT ) ; card -> tsq . next = card -> tsq . base ; card -> tsq . last = card -> tsq . base + ( NS_TSQ_NUM_ENTRIES - 1 ) ; for ( j = 0 ; j < NS_TSQ_NUM_ENTRIES ; j ++ ) { ns_tsi_init ( card -> tsq . base + j ) ; } writel ( 0x00000000 , card -> membase + TSQH ) ; writel ( ALIGN ( card -> tsq . dma , NS_TSQ_ALIGNMENT ) , card -> membase + TSQB ) ; PRINTK ( "nicstar%d: TSQ base at 0x%p.\n" , i , card -> tsq . base ) ; card -> rsq . org = dma_alloc_coherent ( & card -> pcidev -> dev , NS_RSQSIZE + NS_RSQ_ALIGNMENT , & card -> rsq . dma , GFP_KERNEL ) ; if ( card -> rsq . org == NULL ) { printk ( "nicstar%d: can't allocate RSQ.\n" , i ) ; error = 11 ; ns_init_card_error ( card , error ) ; return error ; } card -> rsq . base = PTR_ALIGN ( card -> rsq . org , NS_RSQ_ALIGNMENT ) ; card -> rsq . next = card -> rsq . base ; card -> rsq . last = card -> rsq . base + ( NS_RSQ_NUM_ENTRIES - 1 ) ; for ( j = 0 ; j < NS_RSQ_NUM_ENTRIES ; j ++ ) { ns_rsqe_init ( card -> rsq . base + j ) ; } writel ( 0x00000000 , card -> membase + RSQH ) ; writel ( ALIGN ( card -> rsq . dma , NS_RSQ_ALIGNMENT ) , card -> membase + RSQB ) ; PRINTK ( "nicstar%d: RSQ base at 0x%p.\n" , i , card -> rsq . base ) ; card -> scq1 = NULL ; card -> scq2 = NULL ; card -> scq0 = get_scq ( card , VBR_SCQSIZE , NS_VRSCD0 ) ; if ( card -> scq0 == NULL ) { printk ( "nicstar%d: can't get SCQ0.\n" , i ) ; error = 12 ; ns_init_card_error ( card , error ) ; return error ; } u32d [ 0 ] = scq_virt_to_bus ( card -> scq0 , card -> scq0 -> base ) ; u32d [ 1 ] = ( u32 ) 0x00000000 ; u32d [ 2 ] = ( u32 ) 0xffffffff ; u32d [ 3 ] = ( u32 ) 0x00000000 ; ns_write_sram ( card , NS_VRSCD0 , u32d , 4 ) ; ns_write_sram ( card , NS_VRSCD1 , u32d , 4 ) ; ns_write_sram ( card , NS_VRSCD2 , u32d , 4 ) ; card -> scq0 -> scd = NS_VRSCD0 ; PRINTK ( "nicstar%d: VBR-SCQ0 base at 0x%p.\n" , i , card -> scq0 -> base ) ; card -> tst_addr = NS_TST0 ; card -> tst_free_entries = NS_TST_NUM_ENTRIES ; data = NS_TST_OPCODE_VARIABLE ; for ( j = 0 ; j < NS_TST_NUM_ENTRIES ; j ++ ) { ns_write_sram ( card , NS_TST0 + j , & data , 1 ) ; } data = ns_tste_make ( NS_TST_OPCODE_END , NS_TST0 ) ; ns_write_sram ( card , NS_TST0 + NS_TST_NUM_ENTRIES , & data , 1 ) ; for ( j = 0 ; j < NS_TST_NUM_ENTRIES ; j ++ ) { ns_write_sram ( card , NS_TST1 + j , & data , 1 ) ; } data = ns_tste_make ( NS_TST_OPCODE_END , NS_TST1 ) ; ns_write_sram ( card , NS_TST1 + NS_TST_NUM_ENTRIES , & data , 1 ) ; for ( j = 0 ; j < NS_TST_NUM_ENTRIES ; j ++ ) { card -> tste2vc [ j ] = NULL ; } writel ( NS_TST0 << 2 , card -> membase + TSTB ) ; u32d [ 0 ] = NS_RCTE_RAWCELLINTEN ; u32d [ 0 ] = 0x00000000 ; u32d [ 1 ] = 0x00000000 ; u32d [ 2 ] = 0x00000000 ; u32d [ 3 ] = 0xFFFFFFFF ; for ( j = 0 ; j < card -> rct_size ; j ++ ) { ns_write_sram ( card , j * 4 , u32d , 4 ) ; } memset ( card -> vcmap , 0 , sizeof ( card -> vcmap ) ) ; for ( j = 0 ; j < NS_FRSCD_NUM ; j ++ ) { card -> scd2vc [ j ] = NULL ; } card -> sbnr . min = MIN_SB ; card -> sbnr . init = NUM_SB ; card -> sbnr . max = MAX_SB ; card -> lbnr . min = MIN_LB ; card -> lbnr . init = NUM_LB ; card -> lbnr . max = MAX_LB ; card -> iovnr . min = MIN_IOVB ; card -> iovnr . init = NUM_IOVB ; card -> iovnr . max = MAX_IOVB ; card -> hbnr . min = MIN_HB ; card -> hbnr . init = NUM_HB ; card -> hbnr . max = MAX_HB ; card -> sm_handle = NULL ; card -> sm_addr = 0x00000000 ; card -> lg_handle = NULL ; card -> lg_addr = 0x00000000 ; card -> efbie = 1 ; idr_init ( & card -> idr ) ; skb_queue_head_init ( & card -> hbpool . queue ) ; card -> hbpool . count = 0 ; for ( j = 0 ; j < NUM_HB ; j ++ ) { struct sk_buff * hb ; hb = __dev_alloc_skb ( NS_HBUFSIZE , GFP_KERNEL ) ; if ( hb == NULL ) { printk ( "nicstar%d: can't allocate %dth of %d huge buffers.\n" , i , j , NUM_HB ) ; error = 13 ; ns_init_card_error ( card , error ) ; return error ; } NS_PRV_BUFTYPE ( hb ) = BUF_NONE ; skb_queue_tail ( & card -> hbpool . queue , hb ) ; card -> hbpool . count ++ ; } skb_queue_head_init ( & card -> lbpool . queue ) ; card -> lbpool . count = 0 ; for ( j = 0 ; j < NUM_LB ; j ++ ) { struct sk_buff * lb ; lb = __dev_alloc_skb ( NS_LGSKBSIZE , GFP_KERNEL ) ; if ( lb == NULL ) { printk ( "nicstar%d: can't allocate %dth of %d large buffers.\n" , i , j , NUM_LB ) ; error = 14 ; ns_init_card_error ( card , error ) ; return error ; } NS_PRV_BUFTYPE ( lb ) = BUF_LG ; skb_queue_tail ( & card -> lbpool . queue , lb ) ; skb_reserve ( lb , NS_SMBUFSIZE ) ; push_rxbufs ( card , lb ) ; if ( j == 1 ) { card -> rcbuf = lb ; card -> rawcell = ( ns_rcqe * ) lb -> data ; card -> rawch = NS_PRV_DMA ( lb ) ; } } if ( ( bcount = ns_stat_lfbqc_get ( readl ( card -> membase + STAT ) ) ) < card -> lbnr . min ) { printk ( "nicstar%d: Strange... Just allocated %d large buffers and lfbqc = %d.\n" , i , j , bcount ) ; error = 14 ; ns_init_card_error ( card , error ) ; return error ; } skb_queue_head_init ( & card -> sbpool . queue ) ; card -> sbpool . count = 0 ; for ( j = 0 ; j < NUM_SB ; j ++ ) { struct sk_buff * sb ; sb = __dev_alloc_skb ( NS_SMSKBSIZE , GFP_KERNEL ) ; if ( sb == NULL ) { printk ( "nicstar%d: can't allocate %dth of %d small buffers.\n" , i , j , NUM_SB ) ; error = 15 ; ns_init_card_error ( card , error ) ; return error ; } NS_PRV_BUFTYPE ( sb ) = BUF_SM ; skb_queue_tail ( & card -> sbpool . queue , sb ) ; skb_reserve ( sb , NS_AAL0_HEADER ) ; push_rxbufs ( card , sb ) ; } if ( ( bcount = ns_stat_sfbqc_get ( readl ( card -> membase + STAT ) ) ) < card -> sbnr . min ) { printk ( "nicstar%d: Strange... Just allocated %d small buffers and sfbqc = %d.\n" , i , j , bcount ) ; error = 15 ; ns_init_card_error ( card , error ) ; return error ; } skb_queue_head_init ( & card -> iovpool . queue ) ; card -> iovpool . count = 0 ; for ( j = 0 ; j < NUM_IOVB ; j ++ ) { struct sk_buff * iovb ; iovb = alloc_skb ( NS_IOVBUFSIZE , GFP_KERNEL ) ; if ( iovb == NULL ) { printk ( "nicstar%d: can't allocate %dth of %d iovec buffers.\n" , i , j , NUM_IOVB ) ; error = 16 ; ns_init_card_error ( card , error ) ; return error ; } NS_PRV_BUFTYPE ( iovb ) = BUF_NONE ; skb_queue_tail ( & card -> iovpool . queue , iovb ) ; card -> iovpool . count ++ ; } if ( card -> rct_size == 4096 ) { ns_cfg_rctsize = NS_CFG_RCTSIZE_4096_ENTRIES ; } else { ns_cfg_rctsize = NS_CFG_RCTSIZE_16384_ENTRIES ; } card -> efbie = 1 ; card -> intcnt = 0 ; if ( request_irq ( pcidev -> irq , & ns_irq_handler , IRQF_SHARED , "nicstar" , card ) != 0 ) { printk ( "nicstar%d: can't allocate IRQ %d.\n" , i , pcidev -> irq ) ; error = 9 ; ns_init_card_error ( card , error ) ; return error ; } card -> atmdev = atm_dev_register ( "nicstar" , & card -> pcidev -> dev , & atm_ops , - 1 , NULL ) ; if ( card -> atmdev == NULL ) { printk ( "nicstar%d: can't register device.\n" , i ) ; error = 17 ; ns_init_card_error ( card , error ) ; return error ; } if ( mac [ i ] == NULL || ! mac_pton ( mac [ i ] , card -> atmdev -> esi ) ) { nicstar_read_eprom ( card -> membase , NICSTAR_EPROM_MAC_ADDR_OFFSET , card -> atmdev -> esi , 6 ) ; if ( ether_addr_equal ( card -> atmdev -> esi , "\x00\x00\x00\x00\x00\x00" ) ) { nicstar_read_eprom ( card -> membase , NICSTAR_EPROM_MAC_ADDR_OFFSET_ALT , card -> atmdev -> esi , 6 ) ; } } printk ( "nicstar%d: MAC address %pM\n" , i , card -> atmdev -> esi ) ; card -> atmdev -> dev_data = card ; card -> atmdev -> ci_range . vpi_bits = card -> vpibits ; card -> atmdev -> ci_range . vci_bits = card -> vcibits ; card -> atmdev -> link_rate = card -> max_pcr ; card -> atmdev -> phy = NULL ; if ( card -> max_pcr == ATM_OC3_PCR ) { suni_init ( card -> atmdev ) ; } if ( card -> max_pcr == ATM_25_PCR ) { idt77105_init ( card -> atmdev ) ; } writel ( NS_CFG_RXPATH | NS_CFG_SMBUFSIZE | NS_CFG_LGBUFSIZE | NS_CFG_EFBIE | NS_CFG_RSQSIZE | NS_CFG_VPIBITS | ns_cfg_rctsize | NS_CFG_RXINT_NODELAY | NS_CFG_RAWIE | NS_CFG_RSQAFIE | NS_CFG_TXEN | NS_CFG_TXIE | NS_CFG_TSQFIE_OPT | NS_CFG_PHYIE , card -> membase + CFG ) ; num_cards ++ ; return error ; } 