static int ipw_pci_probe ( struct pci_dev * pdev , const struct pci_device_id * ent ) { int err = 0 ; struct net_device * net_dev ; void __iomem * base ; u32 length , val ; struct ipw_priv * priv ; int i ; net_dev = alloc_libipw ( sizeof ( ipw_priv ) , 0 ) ; if ( net_dev == NULL ) { err = - ENOMEM ; out } priv = libipw_priv ( net_dev ) ; priv -> ieee = netdev_priv ( net_dev ) ; priv -> net_dev = net_dev ; priv -> pci_dev = pdev ; ipw_debug_level = debug ; spin_lock_init ( & priv -> irq_lock ) ; for ( i = 0 ; i < IPW_IBSS_MAC_HASH_SIZE ; i ++ ) { INIT_LIST_HEAD ( & priv -> ibss_mac_hash [ i ] ) ; } mutex_init ( & priv -> mutex ) ; if ( pci_enable_device ( pdev ) ) { err = - ENODEV ; out_free_libipw } pci_set_master ( pdev ) ; err = dma_set_mask ( & pdev -> dev , DMA_BIT_MASK ( 32 ) ) ; if ( ! err ) { err = dma_set_coherent_mask ( & pdev -> dev , DMA_BIT_MASK ( 32 ) ) ; } if ( err ) { printk ( ": No suitable DMA available.\n" ) out_pci_disable_device } pci_set_drvdata ( pdev , priv ) ; err = pci_request_regions ( pdev , DRV_NAME ) ; if ( err ) { out_pci_disable_device } pci_read_config_dword ( pdev , 0x40 , & val ) ; if ( ( val & 0x0000ff00 ) != 0 ) { pci_write_config_dword ( pdev , 0x40 , val & 0xffff00ff ) ; } length = pci_resource_len ( pdev , 0 ) ; priv -> hw_len = length ; base = pci_ioremap_bar ( pdev , 0 ) ; if ( ! base ) { err = - ENODEV ; out_pci_release_regions } priv -> hw_base = base ; IPW_DEBUG_INFO ( "pci_resource_len = 0x%08x\n" , length ) ; IPW_DEBUG_INFO ( "pci_resource_base = %p\n" , base ) ; ipw_setup_deferred_work ( priv ) ; ipw_sw_reset ( priv , 1 ) ; err = request_irq ( pdev -> irq , ipw_isr , IRQF_SHARED , DRV_NAME , priv ) ; if ( err ) { IPW_ERROR ( "Error allocating IRQ %d\n" , pdev -> irq ) ; out_iounmap } SET_NETDEV_DEV ( net_dev , & pdev -> dev ) ; mutex_lock ( & priv -> mutex ) ; priv -> ieee -> hard_start_xmit = ipw_net_hard_start_xmit ; priv -> ieee -> set_security = shim__set_security ; priv -> ieee -> is_queue_full = ipw_net_is_queue_full ; priv -> ieee -> is_qos_active = ipw_is_qos_active ; priv -> ieee -> handle_probe_response = ipw_handle_beacon ; priv -> ieee -> handle_beacon = ipw_handle_probe_response ; priv -> ieee -> handle_assoc_response = ipw_handle_assoc_response ; priv -> ieee -> perfect_rssi = - 20 ; priv -> ieee -> worst_rssi = - 85 ; net_dev -> netdev_ops = & ipw_netdev_ops ; priv -> wireless_data . spy_data = & priv -> ieee -> spy_data ; net_dev -> wireless_data = & priv -> wireless_data ; net_dev -> wireless_handlers = & ipw_wx_handler_def ; net_dev -> ethtool_ops = & ipw_ethtool_ops ; net_dev -> min_mtu = 68 ; net_dev -> max_mtu = LIBIPW_DATA_LEN ; err = sysfs_create_group ( & pdev -> dev . kobj , & ipw_attribute_group ) ; if ( err ) { IPW_ERROR ( "failed to create sysfs device attributes\n" ) ; mutex_unlock ( & priv -> mutex ) ; out_release_irq } if ( ipw_up ( priv ) ) { mutex_unlock ( & priv -> mutex ) ; err = - EIO ; out_remove_sysfs } mutex_unlock ( & priv -> mutex ) ; err = ipw_wdev_init ( net_dev ) ; if ( err ) { IPW_ERROR ( "failed to register wireless device\n" ) ; out_remove_sysfs } err = register_netdev ( net_dev ) ; if ( err ) { IPW_ERROR ( "failed to register network device\n" ) ; out_unregister_wiphy } if ( rtap_iface ) { err = ipw_prom_alloc ( priv ) ; if ( err ) { IPW_ERROR ( "Failed to register promiscuous network " "device (error %d).\n" , err ) ; unregister_netdev ( priv -> net_dev ) ; out_unregister_wiphy } } printk ( ": Detected geography %s (%d 802.11bg " "channels, %d 802.11a channels)\n" , , , ) return 0 ; out_unregister_wiphy wiphy_unregister ( priv -> ieee -> wdev . wiphy ) ; kfree ( priv -> ieee -> a_band . channels ) ; kfree ( priv -> ieee -> bg_band . channels ) ; out_remove_sysfs sysfs_remove_group ( & pdev -> dev . kobj , & ipw_attribute_group ) ; out_release_irq free_irq ( pdev -> irq , priv ) ; out_iounmap iounmap ( priv -> hw_base ) ; out_pci_release_regions pci_release_regions ( pdev ) ; out_pci_disable_device pci_disable_device ( pdev ) ; out_free_libipw free_libipw ( priv -> net_dev , 0 ) ; out return err ; } 