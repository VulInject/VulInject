_bfd_mips_relax_section ( , , , ) { Elf_Internal_Rela * internal_relocs ; Elf_Internal_Rela * irel , * irelend ; Elf_Internal_Shdr * symtab_hdr ; bfd_byte * contents = NULL ; bfd_byte * free_contents = NULL ; size_t extsymoff ; bfd_boolean changed_contents = FALSE ; bfd_vma sec_start = sec -> output_section -> vma + sec -> output_offset ; Elf_Internal_Sym * isymbuf = NULL ; * again = FALSE ; if ( link_info -> relocatable ) { return TRUE ; } internal_relocs = _bfd_elf_link_read_relocs ( abfd , sec , NULL , NULL , link_info -> keep_memory ) ; if ( internal_relocs == NULL ) { return TRUE ; } irelend = internal_relocs + sec -> reloc_count * get_elf_backend_data ( abfd ) -> s -> int_rels_per_ext_rel ; symtab_hdr = & elf_tdata ( abfd ) -> symtab_hdr ; extsymoff = ( elf_bad_symtab ( abfd ) ) ?0 : symtab_hdr -> sh_info ; for ( irel = internal_relocs ; irel < irelend ; irel ++ ) { bfd_vma symval ; bfd_signed_vma sym_offset ; unsigned int r_type ; unsigned long r_symndx ; asection * sym_sec ; unsigned long instruction ; r_type = ELF_R_TYPE ( abfd , irel -> r_info ) ; if ( r_type != R_MIPS_JALR ) { continue ; } r_symndx = ELF_R_SYM ( abfd , irel -> r_info ) ; if ( r_symndx >= extsymoff ) { struct mips_elf_link_hash_entry * h = ( ( mips_elf_link_hash_entry * ) elf_sym_hashes ( abfd ) [ r_symndx - extsymoff ] ) ; while ( h -> root . root . type == bfd_link_hash_indirect || h -> root . root . type == bfd_link_hash_warning ) { h = ( mips_elf_link_hash_entry * ) h -> root . root . u . i . link ; } if ( ! ( ( h -> root . root . type == bfd_link_hash_defined || h -> root . root . type == bfd_link_hash_defweak ) && h -> root . root . u . def . section ) || ( link_info -> shared && ! link_info -> symbolic && ! ( h -> root . elf_link_hash_flags & ELF_LINK_FORCED_LOCAL ) ) ) { continue ; } sym_sec = h -> root . root . u . def . section ; if ( sym_sec -> output_section ) { symval = ( h -> root . root . u . def . value + sym_sec -> output_section -> vma + sym_sec -> output_offset ) ; } else { symval = h -> root . root . u . def . value ; } } else { Elf_Internal_Sym * isym ; if ( isymbuf == NULL && symtab_hdr -> sh_info != 0 ) { isymbuf = ( Elf_Internal_Sym * ) symtab_hdr -> contents ; if ( isymbuf == NULL ) { isymbuf = bfd_elf_get_elf_syms ( abfd , symtab_hdr , symtab_hdr -> sh_info , 0 , NULL , NULL , NULL ) ; } if ( isymbuf == NULL ) { relax_return } } isym = isymbuf + r_symndx ; if ( isym -> st_shndx == SHN_UNDEF ) { continue ; } if ( isym -> st_shndx == SHN_ABS ) { sym_sec = bfd_abs_section_ptr ; } if ( isym -> st_shndx == SHN_COMMON ) { sym_sec = bfd_com_section_ptr ; } else { sym_sec = bfd_section_from_elf_index ( abfd , isym -> st_shndx ) ; } symval = isym -> st_value + sym_sec -> output_section -> vma + sym_sec -> output_offset ; } sym_offset = ( symval + irel -> r_addend ) - ( sec_start + irel -> r_offset + 4 ) ; if ( ( sym_offset & 3 ) != 0 ) { continue ; } sym_offset >>= 2 ; if ( sym_offset < - 0x8000 || sym_offset >= 0x8000 ) { continue ; } if ( contents == NULL ) { if ( elf_section_data ( sec ) -> this_hdr . contents != NULL ) { contents = elf_section_data ( sec ) -> this_hdr . contents ; } else { contents = bfd_malloc ( sec -> _raw_size ) ; if ( contents == NULL ) { relax_return } free_contents = contents ; if ( ! bfd_get_section_contents ( abfd , sec , contents , 0 , sec -> _raw_size ) ) { relax_return } } } instruction = bfd_get_32 ( abfd , contents + irel -> r_offset ) ; if ( ( instruction & 0xfc1fffff ) == 0x0000f809 ) { instruction = 0x04110000 ; } if ( ( instruction & 0xfc1fffff ) == 0x00000008 ) { instruction = 0x10000000 ; } else { continue ; } instruction |= ( sym_offset & 0xffff ) ; bfd_put_32 ( abfd , instruction , contents + irel -> r_offset ) ; changed_contents = TRUE ; } if ( contents != NULL && elf_section_data ( sec ) -> this_hdr . contents != contents ) { if ( ! changed_contents && ! link_info -> keep_memory ) { free ( contents ) ; } else { elf_section_data ( sec ) -> this_hdr . contents = contents ; } } return TRUE ; relax_return return FALSE ; } 