void ospf_ti_lfa_generate_p_spaces ( struct ospf_area * area , enum protection_type protection_type ) { struct listnode * node , * inner_node ; struct vertex * root , * child ; struct vertex_parent * vertex_parent ; uint8_t * p , * lim ; struct router_lsa_link * l = NULL ; struct prefix stub_prefix , child_prefix ; struct protected_resource * protected_resource ; area -> p_spaces = XCALLOC ( MTYPE_OSPF_P_SPACE , sizeof ( p_spaces_head ) ) ; p_spaces_init ( area -> p_spaces ) ; root = area -> spf ; stub_prefix . family = AF_INET ; child_prefix . family = AF_INET ; child_prefix . prefixlen = IPV4_MAX_BITLEN ; p = ( ( uint8_t * ) root -> lsa ) + OSPF_LSA_HEADER_SIZE + 4 ; lim = ( ( uint8_t * ) root -> lsa ) + ntohs ( root -> lsa -> length ) ; zlog_info ( "%s: Generating P spaces for area %pI4" , __func__ , & area -> area_id ) ; while ( p < lim ) { l = ( router_lsa_link * ) p ; p += ( OSPF_ROUTER_LSA_LINK_SIZE + ( l -> m [ 0 ] . tos_count * OSPF_ROUTER_LSA_TOS_SIZE ) ) ; if ( protection_type == OSPF_TI_LFA_NODE_PROTECTION ) { if ( l -> m [ 0 ] . type == LSA_LINK_TYPE_POINTOPOINT ) { protected_resource = XCALLOC ( MTYPE_OSPF_P_SPACE , sizeof ( protected_resource ) ) ; protected_resource -> type = protection_type ; protected_resource -> router_id = l -> link_id ; child = ospf_spf_vertex_find ( protected_resource -> router_id , root -> children ) ; if ( child ) { ospf_ti_lfa_generate_p_space ( area , child , protected_resource , true , NULL ) ; } } continue ; } if ( protection_type != OSPF_TI_LFA_LINK_PROTECTION ) { continue ; } if ( l -> m [ 0 ] . type != LSA_LINK_TYPE_STUB ) { continue ; } stub_prefix . prefixlen = ip_masklen ( l -> link_data ) ; stub_prefix . u . prefix4 = l -> link_id ; for ( ALL_LIST_ELEMENTS_RO ( root -> children , node , child ) ; ) { if ( child -> type != OSPF_VERTEX_ROUTER ) { continue ; } for ( ALL_LIST_ELEMENTS_RO ( child -> parents , inner_node , vertex_parent ) ; ) { child_prefix . u . prefix4 = vertex_parent -> nexthop -> router ; if ( prefix_match ( & stub_prefix , & child_prefix ) ) { zlog_info ( "%s: Generating P space for %pI4" , __func__ , & l -> link_id ) ; protected_resource = XCALLOC ( MTYPE_OSPF_P_SPACE , sizeof ( protected_resource ) ) ; protected_resource -> type = protection_type ; protected_resource -> link = l ; ospf_ti_lfa_generate_p_space ( area , child , protected_resource , true , NULL ) ; } } } } } 