ecma_gc_mark ( ) { JERRY_ASSERT ( object_p != NULL ) ; JERRY_ASSERT ( ecma_gc_is_object_visited ( object_p ) ) ; if ( ecma_is_lexical_environment ( object_p ) ) { jmem_cpointer_t outer_lex_env_cp = object_p -> u2 . outer_reference_cp ; if ( outer_lex_env_cp != JMEM_CP_NULL ) { ecma_gc_set_object_visited ( ECMA_GET_NON_NULL_POINTER ( ecma_object_t , outer_lex_env_cp ) ) ; } switch ( ecma_get_lex_env_type ( object_p ) ) { case ECMA_LEXICAL_ENVIRONMENT_CLASS : { if ( object_p -> type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA ) { ecma_gc_mark_properties ( object_p , true ) ; ecma_gc_set_object_visited ( ( ( ecma_lexical_environment_class_t * ) object_p ) -> module_p ) ; return ; } } case ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND : { ecma_object_t * binding_object_p = ecma_get_lex_env_binding_object ( object_p ) ; ecma_gc_set_object_visited ( binding_object_p ) ; return ; } default : { break ; } } } else { ecma_object_type_t object_type = ecma_get_object_type ( object_p ) ; if ( JERRY_UNLIKELY ( ecma_get_object_is_builtin ( object_p ) ) ) { ecma_value_t realm_value ; if ( ECMA_BUILTIN_IS_EXTENDED_BUILT_IN ( object_type ) ) { realm_value = ( ( ecma_extended_built_in_object_t * ) object_p ) -> built_in . realm_value ; } else { ecma_extended_object_t * extended_object_p = ( ecma_extended_object_t * ) object_p ; if ( object_type == ECMA_OBJECT_TYPE_GENERAL && extended_object_p -> u . built_in . id == ECMA_BUILTIN_ID_GLOBAL ) { ecma_gc_mark_global_object ( ( ecma_global_object_t * ) object_p ) ; } realm_value = extended_object_p -> u . built_in . realm_value ; } ecma_gc_set_object_visited ( ECMA_GET_INTERNAL_VALUE_POINTER ( ecma_object_t , realm_value ) ) ; } jmem_cpointer_t proto_cp = object_p -> u2 . prototype_cp ; switch ( object_type ) { case ECMA_OBJECT_TYPE_GENERAL : { if ( JERRY_UNLIKELY ( ecma_get_object_is_builtin ( object_p ) ) && ( ( ecma_extended_object_t * ) object_p ) -> u . built_in . id == ECMA_BUILTIN_ID_GLOBAL ) { ecma_gc_mark_global_object ( ( ecma_global_object_t * ) object_p ) ; } break ; } case ECMA_OBJECT_TYPE_CLASS : { ecma_extended_object_t * ext_object_p = ( ecma_extended_object_t * ) object_p ; switch ( ext_object_p -> u . cls . type ) { case ECMA_OBJECT_CLASS_ARGUMENTS : { ecma_gc_mark_arguments_object ( ext_object_p ) ; break ; } case ECMA_OBJECT_CLASS_SCRIPT : { const ecma_compiled_code_t * compiled_code_p ; compiled_code_p = ECMA_GET_INTERNAL_VALUE_POINTER ( ecma_compiled_code_t , ext_object_p -> u . cls . u3 . value ) ; ecma_gc_mark_compiled_code ( compiled_code_p ) ; break ; } case ECMA_OBJECT_CLASS_TYPEDARRAY : { ecma_gc_set_object_visited ( ecma_typedarray_get_arraybuffer ( object_p ) ) ; break ; } case ECMA_OBJECT_CLASS_MODULE_NAMESPACE : { JERRY_ASSERT ( proto_cp == JMEM_CP_NULL ) ; ecma_gc_set_object_visited ( ECMA_GET_INTERNAL_VALUE_POINTER ( ecma_object_t , ext_object_p -> u . cls . u3 . value ) ) ; ecma_gc_mark_properties ( object_p , true ) ; return ; } case ECMA_OBJECT_CLASS_MODULE : { ecma_module_t * module_p = ( ( ecma_module_t * ) ext_object_p ) ; if ( module_p -> scope_p != NULL ) { ecma_gc_set_object_visited ( ( ( ecma_module_t * ) ext_object_p ) -> scope_p ) ; } if ( module_p -> namespace_object_p != NULL ) { ecma_gc_set_object_visited ( ( ( ecma_module_t * ) ext_object_p ) -> namespace_object_p ) ; } if ( ! ( module_p -> header . u . cls . u2 . module_flags & ECMA_MODULE_IS_NATIVE ) && module_p -> u . compiled_code_p != NULL ) { ecma_gc_mark_compiled_code ( module_p -> u . compiled_code_p ) ; } ecma_module_node_t * node_p = module_p -> imports_p ; while ( node_p != NULL ) { if ( ecma_is_value_object ( node_p -> u . path_or_module ) ) { ecma_gc_set_object_visited ( ecma_get_object_from_value ( node_p -> u . path_or_module ) ) ; } node_p = node_p -> next_p ; } break ; } case ECMA_OBJECT_CLASS_DATAVIEW : { ecma_dataview_object_t * dataview_p = ( ecma_dataview_object_t * ) object_p ; ecma_gc_set_object_visited ( dataview_p -> buffer_p ) ; break ; } case ECMA_OBJECT_CLASS_CONTAINER : { if ( ext_object_p -> u . cls . u2 . container_id == LIT_MAGIC_STRING_MAP_UL ) { ecma_gc_mark_map_object ( object_p ) ; break ; } if ( ext_object_p -> u . cls . u2 . container_id == LIT_MAGIC_STRING_WEAKMAP_UL ) { ecma_gc_mark_weakmap_object ( object_p ) ; break ; } if ( ext_object_p -> u . cls . u2 . container_id == LIT_MAGIC_STRING_SET_UL ) { ecma_gc_mark_set_object ( object_p ) ; break ; } JERRY_ASSERT ( ext_object_p -> u . cls . u2 . container_id == LIT_MAGIC_STRING_WEAKSET_UL ) ; break ; } case ECMA_OBJECT_CLASS_GENERATOR : case ECMA_OBJECT_CLASS_ASYNC_GENERATOR : { ecma_gc_mark_executable_object ( object_p ) ; break ; } case ECMA_OBJECT_CLASS_PROMISE : { ecma_gc_mark_promise_object ( ext_object_p ) ; break ; } case ECMA_OBJECT_CLASS_PROMISE_CAPABILITY : { ecma_promise_capabality_t * capability_p = ( ecma_promise_capabality_t * ) object_p ; if ( ecma_is_value_object ( capability_p -> header . u . cls . u3 . promise ) ) { ecma_gc_set_object_visited ( ecma_get_object_from_value ( capability_p -> header . u . cls . u3 . promise ) ) ; } if ( ecma_is_value_object ( capability_p -> resolve ) ) { ecma_gc_set_object_visited ( ecma_get_object_from_value ( capability_p -> resolve ) ) ; } if ( ecma_is_value_object ( capability_p -> reject ) ) { ecma_gc_set_object_visited ( ecma_get_object_from_value ( capability_p -> reject ) ) ; } break ; } case ECMA_OBJECT_CLASS_ARRAY_ITERATOR : case ECMA_OBJECT_CLASS_SET_ITERATOR : case ECMA_OBJECT_CLASS_MAP_ITERATOR : { ecma_value_t iterated_value = ext_object_p -> u . cls . u3 . iterated_value ; if ( ! ecma_is_value_empty ( iterated_value ) ) { ecma_gc_set_object_visited ( ecma_get_object_from_value ( iterated_value ) ) ; } break ; } case ECMA_OBJECT_CLASS_REGEXP_STRING_ITERATOR : { ecma_regexp_string_iterator_t * regexp_string_iterator_obj = ( ecma_regexp_string_iterator_t * ) object_p ; ecma_value_t regexp = regexp_string_iterator_obj -> iterating_regexp ; ecma_gc_set_object_visited ( ecma_get_object_from_value ( regexp ) ) ; break ; } default : { JERRY_ASSERT ( ext_object_p -> u . cls . type <= ECMA_OBJECT_CLASS__MAX ) ; break ; } } break ; } case ECMA_OBJECT_TYPE_ARRAY : { ecma_extended_object_t * ext_object_p = ( ecma_extended_object_t * ) object_p ; if ( JERRY_UNLIKELY ( ext_object_p -> u . array . length_prop_and_hole_count & ECMA_ARRAY_TEMPLATE_LITERAL ) ) { JERRY_ASSERT ( object_p -> type_flags_refs >= ECMA_OBJECT_REF_ONE ) ; return ; } if ( ecma_op_array_is_fast_array ( ext_object_p ) ) { if ( object_p -> u1 . property_list_cp != JMEM_CP_NULL ) { ecma_value_t * values_p = ECMA_GET_NON_NULL_POINTER ( ecma_value_t , object_p -> u1 . property_list_cp ) ; for ( uint32_t i = 0 ; i < ext_object_p -> u . array . length ; i ++ ) { if ( ecma_is_value_object ( values_p [ i ] ) ) { ecma_gc_set_object_visited ( ecma_get_object_from_value ( values_p [ i ] ) ) ; } } } if ( proto_cp != JMEM_CP_NULL ) { ecma_gc_set_object_visited ( ECMA_GET_NON_NULL_POINTER ( ecma_object_t , proto_cp ) ) ; } return ; } break ; } case ECMA_OBJECT_TYPE_PROXY : { ecma_gc_mark_proxy_object ( object_p ) ; proto_cp = JMEM_CP_NULL ; break ; } case ECMA_OBJECT_TYPE_BOUND_FUNCTION : { ecma_gc_mark_bound_function_object ( object_p ) ; break ; } case ECMA_OBJECT_TYPE_FUNCTION : { JERRY_ASSERT ( ! ecma_get_object_is_builtin ( object_p ) ) ; ecma_extended_object_t * ext_func_p = ( ecma_extended_object_t * ) object_p ; ecma_gc_set_object_visited ( ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG ( ecma_object_t , ext_func_p -> u . function . scope_cp ) ) ; const ecma_compiled_code_t * byte_code_p = ecma_op_function_get_compiled_code ( ext_func_p ) ; if ( CBC_FUNCTION_IS_ARROW ( byte_code_p -> status_flags ) ) { ecma_arrow_function_t * arrow_func_p = ( ecma_arrow_function_t * ) object_p ; if ( ecma_is_value_object ( arrow_func_p -> this_binding ) ) { ecma_gc_set_object_visited ( ecma_get_object_from_value ( arrow_func_p -> this_binding ) ) ; } if ( ecma_is_value_object ( arrow_func_p -> new_target ) ) { ecma_gc_set_object_visited ( ecma_get_object_from_value ( arrow_func_p -> new_target ) ) ; } } if ( JERRY_UNLIKELY ( byte_code_p -> status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION ) ) { break ; } ecma_gc_mark_compiled_code ( byte_code_p ) ; break ; } case ECMA_OBJECT_TYPE_NATIVE_FUNCTION : { if ( ! ecma_get_object_is_builtin ( object_p ) ) { ecma_native_function_t * native_function_p = ( ecma_native_function_t * ) object_p ; ecma_gc_set_object_visited ( ECMA_GET_INTERNAL_VALUE_POINTER ( ecma_object_t , native_function_p -> realm_value ) ) ; break ; } ecma_extended_object_t * ext_func_p = ( ecma_extended_object_t * ) object_p ; if ( ext_func_p -> u . built_in . id == ECMA_BUILTIN_ID_HANDLER ) { switch ( ext_func_p -> u . built_in . routine_id ) { case ECMA_NATIVE_HANDLER_PROMISE_RESOLVE : case ECMA_NATIVE_HANDLER_PROMISE_REJECT : { ecma_promise_resolver_t * resolver_obj_p = ( ecma_promise_resolver_t * ) object_p ; ecma_gc_set_object_visited ( ecma_get_object_from_value ( resolver_obj_p -> promise ) ) ; break ; } case ECMA_NATIVE_HANDLER_PROMISE_THEN_FINALLY : case ECMA_NATIVE_HANDLER_PROMISE_CATCH_FINALLY : { ecma_promise_finally_function_t * finally_obj_p = ( ecma_promise_finally_function_t * ) object_p ; ecma_gc_set_object_visited ( ecma_get_object_from_value ( finally_obj_p -> constructor ) ) ; ecma_gc_set_object_visited ( ecma_get_object_from_value ( finally_obj_p -> on_finally ) ) ; break ; } case ECMA_NATIVE_HANDLER_PROMISE_CAPABILITY_EXECUTOR : { ecma_promise_capability_executor_t * executor_p = ( ecma_promise_capability_executor_t * ) object_p ; ecma_gc_set_object_visited ( ecma_get_object_from_value ( executor_p -> capability ) ) ; break ; } case ECMA_NATIVE_HANDLER_PROMISE_ALL_HELPER : { ecma_promise_all_executor_t * executor_p = ( ecma_promise_all_executor_t * ) object_p ; ecma_gc_set_object_visited ( ecma_get_object_from_value ( executor_p -> capability ) ) ; ecma_gc_set_object_visited ( ecma_get_object_from_value ( executor_p -> values ) ) ; ecma_gc_set_object_visited ( ecma_get_object_from_value ( executor_p -> remaining_elements ) ) ; break ; } case ECMA_NATIVE_HANDLER_PROXY_REVOKE : { ecma_revocable_proxy_object_t * rev_proxy_p = ( ecma_revocable_proxy_object_t * ) object_p ; if ( ! ecma_is_value_null ( rev_proxy_p -> proxy ) ) { ecma_gc_set_object_visited ( ecma_get_object_from_value ( rev_proxy_p -> proxy ) ) ; } break ; } case ECMA_NATIVE_HANDLER_VALUE_THUNK : case ECMA_NATIVE_HANDLER_VALUE_THROWER : { ecma_promise_value_thunk_t * thunk_obj_p = ( ecma_promise_value_thunk_t * ) object_p ; if ( ecma_is_value_object ( thunk_obj_p -> value ) ) { ecma_gc_set_object_visited ( ecma_get_object_from_value ( thunk_obj_p -> value ) ) ; } break ; } default : { JERRY_UNREACHABLE ( ) ; } } } break ; } default : { break ; } } } ecma_gc_mark_properties ( object_p , false ) ; } 