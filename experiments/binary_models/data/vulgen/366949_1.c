static void slcan_bump_frame ( struct slcan * sl ) { struct sk_buff * skb ; struct can_frame * cf ; int i , tmp ; u32 tmpid ; char * cmd = sl -> rbuff ; skb = alloc_can_skb ( sl -> dev , & cf ) ; if ( unlikely ( ! skb ) ) { sl -> dev -> stats . rx_dropped ++ ; return ; } switch ( * cmd ) { case 'r' : cf -> can_id = CAN_RTR_FLAG ; fallthrough ; case 't' : cf -> len = sl -> rbuff [ SLCAN_CMD_LEN + SLCAN_SFF_ID_LEN ] ; sl -> rbuff [ SLCAN_CMD_LEN + SLCAN_SFF_ID_LEN ] = 0 ; cmd += SLCAN_CMD_LEN + SLCAN_SFF_ID_LEN + 1 ; break ; case 'R' : cf -> can_id = CAN_RTR_FLAG ; fallthrough ; case 'T' : cf -> can_id |= CAN_EFF_FLAG ; cf -> len = sl -> rbuff [ SLCAN_CMD_LEN + SLCAN_EFF_ID_LEN ] ; sl -> rbuff [ SLCAN_CMD_LEN + SLCAN_EFF_ID_LEN ] = 0 ; cmd += SLCAN_CMD_LEN + SLCAN_EFF_ID_LEN + 1 ; break ; default : decode_failed } if ( kstrtou32 ( sl -> rbuff + SLCAN_CMD_LEN , 16 , & tmpid ) ) { decode_failed } cf -> can_id |= tmpid ; if ( cf -> len >= '0' && cf -> len < '9' ) { cf -> len -= '0' ; } else { decode_failed } if ( ! ( cf -> can_id & CAN_RTR_FLAG ) ) { for ( i = 0 ; i < cf -> len ; i ++ ) { tmp = hex_to_bin ( * cmd ++ ) ; if ( tmp < 0 ) { decode_failed } cf -> data [ i ] = ( tmp << 4 ) ; tmp = hex_to_bin ( * cmd ++ ) ; cf -> data [ i ] |= tmp ; } } sl -> dev -> stats . rx_packets ++ ; if ( ! ( cf -> can_id & CAN_RTR_FLAG ) ) { sl -> dev -> stats . rx_bytes += cf -> len ; } netif_rx ( skb ) ; return ; decode_failed sl -> dev -> stats . rx_errors ++ ; dev_kfree_skb ( skb ) ; } 