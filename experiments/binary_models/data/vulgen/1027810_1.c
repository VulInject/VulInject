static nbt_name_reply_t * smb_name_get_reply ( uint16_t tid , uint32_t timeout ) { uint16_t info ; struct resource_record * answer ; nbt_name_reply_t * reply ; uint32_t wait_time , to_save ; struct timeval wt ; timestruc_t to ; to_save = timeout ; reply = malloc ( sizeof ( nbt_name_reply_t ) ) ; if ( reply != NULL ) { reply -> reply_ready = B_FALSE ; reply -> name_trn_id = tid ; ( void ) mutex_lock ( & rq_mtx ) ; QUEUE_INSERT_TAIL ( & reply_queue , reply ) ; ( void ) mutex_unlock ( & rq_mtx ) ; for ( ; ; ) { ( void ) gettimeofday ( & wt , 0 ) ; wait_time = wt . tv_usec / 1000 ; to . tv_sec = 0 ; to . tv_nsec = timeout * 1000000 ; ( void ) mutex_lock ( & rq_mtx ) ; ( void ) cond_reltimedwait ( & rq_cv , & rq_mtx , & to ) ; ( void ) mutex_unlock ( & rq_mtx ) ; if ( reply -> reply_ready ) { info = reply -> packet -> info ; if ( PACKET_TYPE ( info ) == WACK_RESPONSE ) { answer = reply -> packet -> answer ; wait_time = ( answer ) ?TO_MILLISECONDS ( answer -> ttl ) : DEFAULT_TTL ; free ( reply -> addr ) ; timeout = to_save + wait_time ; reply -> reply_ready = B_FALSE ; reply -> name_trn_id = tid ; ( void ) mutex_lock ( & rq_mtx ) ; QUEUE_INSERT_TAIL ( & reply_queue , reply ) ; ( void ) mutex_unlock ( & rq_mtx ) ; continue ; } return ( reply ) ; } ( void ) gettimeofday ( & wt , 0 ) ; wait_time = ( wt . tv_usec / 1000 ) - wait_time ; if ( wait_time >= timeout ) { ( void ) mutex_lock ( & rq_mtx ) ; QUEUE_CLIP ( reply ) ; ( void ) mutex_unlock ( & rq_mtx ) ; free ( reply ) ; break ; } timeout -= wait_time ; } } return ( 0 ) ; } 