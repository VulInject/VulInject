int mthca_multicast_attach ( struct ib_qp * ibqp , union ib_gid * gid , u16 lid ) { struct mthca_dev * dev = to_mdev ( ibqp -> device ) ; struct mthca_mailbox * mailbox ; struct mthca_mgm * mgm ; u16 hash ; int index , prev ; int link = 0 ; int i ; int err ; mailbox = mthca_alloc_mailbox ( dev , GFP_KERNEL ) ; if ( IS_ERR ( mailbox ) ) { return PTR_ERR ( mailbox ) ; } mgm = mailbox -> buf ; mutex_lock ( & dev -> mcg_table . mutex ) ; err = find_mgm ( dev , gid -> raw , mailbox , & hash , & prev , & index ) ; if ( err ) { out } if ( index != - 1 ) { if ( ! memcmp ( mgm -> gid , zero_gid , 16 ) ) { memcpy ( mgm -> gid , gid -> raw , 16 ) ; } } else { link = 1 ; index = mthca_alloc ( & dev -> mcg_table . alloc ) ; if ( index == - 1 ) { mthca_err ( dev , "No AMGM entries left\n" ) ; err = - ENOMEM ; out } err = mthca_READ_MGM ( dev , index , mailbox ) ; if ( err ) { mthca_err ( dev , "READ_MGM failed (%d)\n" , err ) ; out } memset ( mgm , 0 , sizeof mgm ) ; memcpy ( mgm -> gid , gid -> raw , 16 ) ; } for ( i = 0 ; i < MTHCA_QP_PER_MGM ; ++ i ) { if ( mgm -> qp [ i ] == cpu_to_be32 ( ibqp -> qp_num | ( 1 << 31 ) ) ) { mthca_dbg ( dev , "QP %06x already a member of MGM\n" , ibqp -> qp_num ) ; err = 0 ; out } if ( ! ( mgm -> qp [ i ] & cpu_to_be32 ( 1 << 31 ) ) ) { mgm -> qp [ i ] = cpu_to_be32 ( ibqp -> qp_num | ( 1 << 31 ) ) ; break ; } } err = mthca_WRITE_MGM ( dev , index , mailbox ) ; if ( err ) { mthca_err ( dev , "WRITE_MGM failed %d\n" , err ) ; err = - EINVAL ; out } if ( ! link ) { out } err = mthca_READ_MGM ( dev , prev , mailbox ) ; if ( err ) { mthca_err ( dev , "READ_MGM failed %d\n" , err ) ; out } mgm -> next_gid_index = cpu_to_be32 ( index << 6 ) ; err = mthca_WRITE_MGM ( dev , prev , mailbox ) ; if ( err ) { mthca_err ( dev , "WRITE_MGM returned %d\n" , err ) ; } out if ( err && link && index != - 1 ) { BUG_ON ( index < dev -> limits . num_mgms ) ; mthca_free ( & dev -> mcg_table . alloc , index ) ; } mutex_unlock ( & dev -> mcg_table . mutex ) ; mthca_free_mailbox ( dev , mailbox ) ; return err ; } 