static struct dentry * ubifs_lookup ( struct inode * dir , struct dentry * dentry , unsigned int flags ) { int err ; union ubifs_key key ; struct inode * inode = NULL ; struct ubifs_dent_node * dent ; struct ubifs_info * c = dir -> i_sb -> s_fs_info ; struct fscrypt_name nm ; dbg_gen ( "'%pd' in dir ino %lu" , dentry , dir -> i_ino ) ; if ( ubifs_crypt_is_encrypted ( dir ) ) { err = fscrypt_get_encryption_info ( dir ) ; if ( fscrypt_has_encryption_key ( dir ) ) { fscrypt_set_encrypted_dentry ( dentry ) ; } fscrypt_set_d_op ( dentry ) ; if ( err && err != - ENOKEY ) { return ERR_PTR ( err ) ; } } err = fscrypt_setup_filename ( dir , & dentry -> d_name , 1 , & nm ) ; if ( err ) { return ERR_PTR ( err ) ; } dent = kmalloc ( UBIFS_MAX_DENT_NODE_SZ , GFP_NOFS ) ; if ( ! dent ) { err = - ENOMEM ; out_fname } if ( nm . hash ) { ubifs_assert ( fname_len ( & nm ) == 0 ) ; ubifs_assert ( fname_name ( & nm ) == NULL ) ; dent_key_init_hash ( c , & key , dir -> i_ino , nm . hash ) ; err = ubifs_tnc_lookup_dh ( c , & key , dent , nm . minor_hash ) ; } else { dent_key_init ( c , & key , dir -> i_ino , & nm ) ; err = ubifs_tnc_lookup_nm ( c , & key , dent , & nm ) ; } if ( err ) { if ( err == - ENOENT ) { dbg_gen ( "not found" ) ; done } out_dent } if ( dbg_check_name ( c , dent , & nm ) ) { err = - EINVAL ; out_dent } inode = ubifs_iget ( dir -> i_sb , le64_to_cpu ( dent -> inum ) ) ; if ( IS_ERR ( inode ) ) { err = PTR_ERR ( inode ) ; ubifs_err ( c , "dead directory entry '%pd', error %d" , dentry , err ) ; ubifs_ro_mode ( c , err ) ; out_dent } if ( ubifs_crypt_is_encrypted ( dir ) && ( S_ISDIR ( inode -> i_mode ) || S_ISLNK ( inode -> i_mode ) ) && ! fscrypt_has_permitted_context ( dir , inode ) ) { ubifs_warn ( c , "Inconsistent encryption contexts: %lu/%lu" , dir -> i_ino , inode -> i_ino ) ; err = - EPERM ; out_inode } done kfree ( dent ) ; fscrypt_free_filename ( & nm ) ; d_add ( dentry , inode ) ; return NULL ; out_inode iput ( inode ) ; out_dent kfree ( dent ) ; out_fname fscrypt_free_filename ( & nm ) ; return ERR_PTR ( err ) ; } 