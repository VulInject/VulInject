static TableSampleClause * transformRangeTableSample ( ParseState * pstate , RangeTableSample * rts ) { TableSampleClause * tablesample ; Oid handlerOid ; Oid funcargtypes [ 1 ] ; TsmRoutine * tsm ; List * fargs ; ListCell * larg , * ltyp ; funcargtypes [ 0 ] = INTERNALOID ; handlerOid = LookupFuncName ( rts -> method , 1 , funcargtypes , true ) ; if ( ! OidIsValid ( handlerOid ) ) { ereport ( ERROR , ( errcode ( ERRCODE_UNDEFINED_OBJECT ) , errmsg ( "tablesample method %s does not exist" , NameListToString ( rts -> method ) ) , parser_errposition ( pstate , rts -> location ) ) ) ; } if ( get_func_rettype ( handlerOid ) != TSM_HANDLEROID ) { ereport ( ERROR , ( errcode ( ERRCODE_WRONG_OBJECT_TYPE ) , errmsg ( "function %s must return type %s" , NameListToString ( rts -> method ) , "tsm_handler" ) , parser_errposition ( pstate , rts -> location ) ) ) ; } tsm = GetTsmRoutine ( handlerOid ) ; tablesample = makeNode ( TableSampleClause ) ; tablesample -> tsmhandler = handlerOid ; if ( list_length ( rts -> args ) != list_length ( tsm -> parameterTypes ) ) { ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TABLESAMPLE_ARGUMENT ) , errmsg_plural ( "tablesample method %s requires %d argument, not %d" , "tablesample method %s requires %d arguments, not %d" , list_length ( tsm -> parameterTypes ) , NameListToString ( rts -> method ) , list_length ( tsm -> parameterTypes ) , list_length ( rts -> args ) ) , parser_errposition ( pstate , rts -> location ) ) ) ; } fargs = NIL ; forboth ( , , , ) { Node * arg = ( Node * ) lfirst ( larg ) ; Oid argtype = lfirst_oid ( ltyp ) ; arg = transformExpr ( pstate , arg , EXPR_KIND_FROM_FUNCTION ) ; arg = coerce_to_specific_type ( pstate , arg , argtype , "TABLESAMPLE" ) ; assign_expr_collations ( pstate , arg ) ; fargs = lappend ( fargs , arg ) ; } tablesample -> args = fargs ; else { tablesample -> repeatable = NULL ; } return tablesample ; } 