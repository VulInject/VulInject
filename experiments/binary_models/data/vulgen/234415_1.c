static buffer * mod_evhost_parse_pattern ( const char * ptr ) { uint32_t used = 0 ; const uint32_t sz = 127 ; const char * pos ; buffer bptr [ 128 ] ; for ( pos = ptr ; * ptr ; ptr ++ ) { if ( * ptr == '%' ) { size_t len ; if ( used >= sz - 1 ) { return mod_evhost_parse_pattern_err ( bptr ) ; } if ( ptr [ 1 ] == '%' || ptr [ 1 ] == '_' || light_isdigit ( ptr [ 1 ] ) ) { len = 2 ; } if ( ptr [ 1 ] == '{' ) { if ( ! light_isdigit ( ptr [ 2 ] ) ) { return mod_evhost_parse_pattern_err ( bptr ) ; } if ( ptr [ 3 ] == '.' ) { if ( ! light_isdigit ( ptr [ 4 ] ) ) { return mod_evhost_parse_pattern_err ( bptr ) ; } if ( ptr [ 5 ] != '}' ) { return mod_evhost_parse_pattern_err ( bptr ) ; } len = 6 ; } if ( ptr [ 3 ] == '}' ) { len = 4 ; } else { return mod_evhost_parse_pattern_err ( bptr ) ; } } else { return mod_evhost_parse_pattern_err ( bptr ) ; } buffer_copy_string_len ( bptr + used , pos , ptr - pos ) ; pos = ptr + len ; buffer_copy_string_len ( bptr + used + 1 , ptr , len ) ; ptr += len - 1 ; used += 2 ; } } if ( * pos != '\0' ) { if ( used >= sz ) { return mod_evhost_parse_pattern_err ( bptr ) ; } buffer_copy_string_len ( bptr + used , pos , ptr - pos ) ; ++ used ; } buffer * const path_pieces = ck_malloc ( ( used + 1 ) * sizeof ( buffer ) ) ; return memcpy ( path_pieces , bptr , ( used + 1 ) * sizeof ( buffer ) ) ; } 