static unsigned long exynos542x_get_periph_rate ( int peripheral ) { struct clk_bit_info * bit_info = get_clk_bit_info ( peripheral ) ; unsigned int src = 0 , div = 0 , sub_div ; unsigned int src = 0 , div = 0 , sub_div = 0 ; struct exynos5420_clock * clk = ( exynos5420_clock * ) samsung_get_base_clock ( ) ; switch ( peripheral ) { case PERIPH_ID_UART0 : case PERIPH_ID_UART1 : case PERIPH_ID_UART2 : case PERIPH_ID_UART3 : case PERIPH_ID_PWM0 : case PERIPH_ID_PWM1 : case PERIPH_ID_PWM2 : case PERIPH_ID_PWM3 : case PERIPH_ID_PWM4 : src = readl ( & clk -> src_peric0 ) ; div = readl ( & clk -> div_peric0 ) ; break ; case PERIPH_ID_SPI0 : case PERIPH_ID_SPI1 : case PERIPH_ID_SPI2 : src = readl ( & clk -> src_peric1 ) ; div = readl ( & clk -> div_peric1 ) ; sub_div = readl ( & clk -> div_peric4 ) ; break ; case PERIPH_ID_SPI3 : case PERIPH_ID_SPI4 : src = readl ( & clk -> src_isp ) ; div = readl ( & clk -> div_isp1 ) ; sub_div = readl ( & clk -> div_isp1 ) ; break ; case PERIPH_ID_SDMMC0 : case PERIPH_ID_SDMMC1 : case PERIPH_ID_SDMMC2 : case PERIPH_ID_SDMMC3 : src = readl ( & clk -> src_fsys ) ; div = readl ( & clk -> div_fsys1 ) ; break ; case PERIPH_ID_I2C0 : case PERIPH_ID_I2C1 : case PERIPH_ID_I2C2 : case PERIPH_ID_I2C3 : case PERIPH_ID_I2C4 : case PERIPH_ID_I2C5 : case PERIPH_ID_I2C6 : case PERIPH_ID_I2C7 : case PERIPH_ID_I2C8 : case PERIPH_ID_I2C9 : case PERIPH_ID_I2C10 : src = EXYNOS542X_SRC_MPLL ; div = readl ( & clk -> div_top1 ) ; break ; default : debug ( "%s: invalid peripheral %d" , __func__ , peripheral ) ; return - 1 ; } if ( bit_info -> src_bit >= 0 ) { src = ( src >> bit_info -> src_bit ) & bit_info -> src_mask ; } switch ( src ) { case EXYNOS542X_SRC_MPLL : sclk = exynos542x_get_pll_clk ( MPLL ) ; break ; case EXYNOS542X_SRC_SPLL : sclk = exynos542x_get_pll_clk ( SPLL ) ; break ; case EXYNOS542X_SRC_EPLL : sclk = exynos542x_get_pll_clk ( EPLL ) ; break ; case EXYNOS542X_SRC_RPLL : sclk = exynos542x_get_pll_clk ( RPLL ) ; break ; default : debug ( "%s: EXYNOS542X_SRC %d not supported" , __func__ , src ) ; return 0 ; } if ( bit_info -> div_bit >= 0 ) { div = ( div >> bit_info -> div_bit ) & bit_info -> div_mask ; } if ( bit_info -> prediv_bit >= 0 ) { sub_div = ( sub_div >> bit_info -> prediv_bit ) & bit_info -> prediv_mask ; } return ( sclk / ( div + 1 ) ) / ( sub_div + 1 ) ; } 