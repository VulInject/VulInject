static int fmevt_cb ( sysevent_t * sep , void * arg ) { char * ruleset = NULL , * rawclass , * rawsubclass ; uint32_t cbarg = ( uint32_t ) arg ; nvlist_t * rawattr = NULL ; struct fmevt_ppargs ea ; nvlist_t * dtcr ; int user , priv ; fmev_pri_t pri ; BUMPSTAT ( raw_callbacks ) ; user = ( cbarg & CBF_USER ) != 0 ; priv = ( cbarg & CBF_PRIV ) != 0 ; pri = ( cbarg & CBF_HV ?FMEV_HIPRI : FMEV_LOPRI ) ; ( void ) pthread_mutex_lock ( & fmevt_lock ) ; if ( fmevt_exiting ) { while ( fmevt_xprt_refcnt > 0 ) { ( void ) pthread_cond_wait ( & fmevt_cv , & fmevt_lock ) ; } ( void ) pthread_mutex_unlock ( & fmevt_lock ) ; return ( 0 ) ; } fmevt_xprt_refcnt ++ ; ( void ) pthread_mutex_unlock ( & fmevt_lock ) ; ruleset = sysevent_get_vendor_name ( sep ) ; rawclass = sysevent_get_class_name ( sep ) ; rawsubclass = sysevent_get_subclass_name ( sep ) ; if ( sysevent_get_attr_list ( sep , & rawattr ) != 0 ) { BUMPSTAT ( raw_noattrlist ) ; done } if ( ( dtcr = fmevt_detector ( rawattr , ruleset , user , priv , pri ) ) == NULL ) { BUMPSTAT ( raw_nodetector ) ; done } ea . pp_rawclass = rawclass ; ea . pp_rawsubclass = rawsubclass ; sysevent_get_time ( sep , & ea . pp_hrt ) ; ea . pp_user = user ; ea . pp_priv = priv ; ea . pp_pri = pri ; fmevt_postprocess ( ruleset , dtcr , rawattr , & ea ) ; nvlist_free ( dtcr ) ; done ( void ) pthread_mutex_lock ( & fmevt_lock ) ; if ( -- fmevt_xprt_refcnt == 0 && fmevt_exiting ) { ( void ) pthread_cond_broadcast ( & fmevt_cv ) ; } ( void ) pthread_mutex_unlock ( & fmevt_lock ) ; if ( ruleset ) { free ( ruleset ) ; } nvlist_free ( rawattr ) ; return ( 0 ) ; } 