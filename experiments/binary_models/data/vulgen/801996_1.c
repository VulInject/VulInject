Cell * call ( Node * * a , int n ) { static const Cell newcopycell = { OCELL CCOPY 0 EMPTY 0.0 NUM | STR | DONTFREE NULL NULL } ; int i , ncall , ndef ; int freed = 0 ; Node * x ; Cell * args [ NARGS ] , * oargs [ NARGS ] ; Cell * y , * z , * fcn ; char * s ; fcn = execute ( a [ 0 ] ) ; s = fcn -> nval ; if ( ! isfcn ( fcn ) ) { FATAL ( "calling undefined function %s" , s ) ; } if ( frame == NULL ) { frp = frame = ( Frame * ) calloc ( nframe += 100 , sizeof ( * frame ) ) ; if ( frame == NULL ) { FATAL ( "out of space for stack frames calling %s" , s ) ; } } for ( ncall = 0 , x = a [ 1 ] ; x != NULL ; x = x -> nnext ) { ncall ++ ; } ndef = ( int ) fcn -> fval ; DPRINTF ( "calling %s, %d args (%d in defn), frp=%d\n" , s , ncall , ndef , ( int ) ( frp - frame ) ) ; if ( ncall > ndef ) { WARNING ( "function %s called with %d args, uses only %d" , s , ncall , ndef ) ; } if ( ncall + ndef > NARGS ) { FATAL ( "function %s has %d arguments, limit %d" , s , ncall + ndef , NARGS ) ; } for ( i = 0 , x = a [ 1 ] ; x != NULL ; i ++ , x = x -> nnext ) { DPRINTF ( "evaluate args[%d], frp=%d:\n" , i , ( int ) ( frp - frame ) ) ; y = execute ( x ) ; oargs [ i ] = y ; DPRINTF ( "args[%d]: %s %f<%s>, t=%o\n" , i , NN ( y -> nval ) , y -> fval , isarr ( y ) ?"(array)" : NN ( y -> sval ) , y -> tval ) ; if ( isfcn ( y ) ) { FATAL ( "can't use function %s as argument in %s" , y -> nval , s ) ; } if ( isarr ( y ) ) { args [ i ] = y ; } else { args [ i ] = copycell ( y ) ; } tempfree ( y ) ; } for ( ; i < ndef ; i ++ ) { args [ i ] = gettemp ( ) ; * args [ i ] = newcopycell ; } frp ++ ; if ( frp >= frame + nframe ) { int dfp = frp - frame ; frame = ( Frame * ) reallocarray ( frame , ( nframe += 100 ) , sizeof ( * frame ) ) ; if ( frame == NULL ) { FATAL ( "out of space for stack frames in %s" , s ) ; } frp = frame + dfp ; } frp -> fcncell = fcn ; frp -> args = args ; frp -> nargs = ndef ; frp -> retval = gettemp ( ) ; DPRINTF ( "start exec of %s, frp=%d\n" , s , ( int ) ( frp - frame ) ) ; y = execute ( ( Node * ) ( fcn -> sval ) ) ; DPRINTF ( "finished exec of %s, frp=%d\n" , s , ( int ) ( frp - frame ) ) ; for ( i = 0 ; i < ndef ; i ++ ) { Cell * t = frp -> args [ i ] ; if ( isarr ( t ) ) { if ( t -> csub == CCOPY ) { if ( i >= ncall ) { freesymtab ( t ) ; t -> csub = CTEMP ; tempfree ( t ) ; } else { oargs [ i ] -> tval = t -> tval ; oargs [ i ] -> tval &= ~ ( STR | NUM | DONTFREE ) ; oargs [ i ] -> sval = t -> sval ; tempfree ( t ) ; } } } if ( t != y ) { t -> csub = CTEMP ; tempfree ( t ) ; } if ( t == y && t -> csub == CCOPY ) { t -> csub = CTEMP ; tempfree ( t ) ; freed = 1 ; } } tempfree ( fcn ) ; if ( isexit ( y ) || isnext ( y ) ) { return y ; } z = frp -> retval ; DPRINTF ( "%s returns %g |%s| %o\n" , s , getfval ( z ) , getsval ( z ) , z -> tval ) ; frp -- ; return ( z ) ; } 