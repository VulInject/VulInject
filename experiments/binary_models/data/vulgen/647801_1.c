TEST_IMPL ( ) { uv_pipe_t pipe_handle ; uv_loop_t * loop ; int r ; struct stat stat_buf ; loop = uv_default_loop ( ) ; r = uv_pipe_init ( loop , & pipe_handle , 0 ) ; ASSERT ( r == 0 ) ; r = uv_pipe_bind ( & pipe_handle , TEST_PIPENAME ) ; ASSERT ( r == 0 ) ; r = uv_pipe_chmod ( & pipe_handle , UV_READABLE ) ; if ( r == UV_EPERM ) { MAKE_VALGRIND_HAPPY ( ) ; RETURN_SKIP ( "Insufficient privileges to alter pipe fmode" ) ; } ASSERT ( r == 0 ) ; ASSERT_EQ ( 0 , stat ( TEST_PIPENAME , & stat_buf ) ) ; ASSERT ( stat_buf . st_mode & S_IRUSR ) ; ASSERT ( stat_buf . st_mode & S_IRGRP ) ; ASSERT ( stat_buf . st_mode & S_IROTH ) ; r = uv_pipe_chmod ( & pipe_handle , UV_WRITABLE ) ; ASSERT ( r == 0 ) ; stat ( TEST_PIPENAME , & stat_buf ) ; ASSERT ( stat_buf . st_mode & S_IWUSR ) ; ASSERT ( stat_buf . st_mode & S_IWGRP ) ; ASSERT ( stat_buf . st_mode & S_IWOTH ) ; r = uv_pipe_chmod ( & pipe_handle , UV_WRITABLE | UV_READABLE ) ; ASSERT ( r == 0 ) ; stat ( TEST_PIPENAME , & stat_buf ) ; ASSERT ( stat_buf . st_mode & S_IRUSR ) ; ASSERT ( stat_buf . st_mode & S_IRGRP ) ; ASSERT ( stat_buf . st_mode & S_IROTH ) ; ASSERT ( stat_buf . st_mode & S_IWUSR ) ; ASSERT ( stat_buf . st_mode & S_IWGRP ) ; ASSERT ( stat_buf . st_mode & S_IWOTH ) ; r = uv_pipe_chmod ( NULL , UV_WRITABLE | UV_READABLE ) ; ASSERT ( r == UV_EBADF ) ; r = uv_pipe_chmod ( & pipe_handle , 12345678 ) ; ASSERT ( r == UV_EINVAL ) ; uv_close ( ( uv_handle_t * ) & pipe_handle , NULL ) ; r = uv_pipe_chmod ( & pipe_handle , UV_WRITABLE | UV_READABLE ) ; ASSERT ( r == UV_EBADF ) ; MAKE_VALGRIND_HAPPY ( ) ; return 0 ; } 