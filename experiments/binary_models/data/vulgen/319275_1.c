void intel_crtc_state_dump ( const struct intel_crtc_state * pipe_config , struct intel_atomic_state * state , const char * context ) { struct intel_crtc * crtc = to_intel_crtc ( pipe_config -> uapi . crtc ) ; struct drm_i915_private * i915 = to_i915 ( crtc -> base . dev ) ; const struct intel_plane_state * plane_state ; struct intel_plane * plane ; char buf [ 64 ] ; int i ; drm_dbg_kms ( & i915 -> drm , "[CRTC:%d:%s] enable: %s [%s]\n" , crtc -> base . base . id , crtc -> base . name , str_yes_no ( pipe_config -> hw . enable ) , context ) ; if ( ! pipe_config -> hw . enable ) { dump_planes } drm_dbg_kms ( & i915 -> drm , "active: %s, output_types: %s (0x%x), output format: %s\n" , str_yes_no ( pipe_config -> hw . active ) , buf , pipe_config -> output_types , output_formats ( pipe_config -> output_format ) ) ; drm_dbg_kms ( & i915 -> drm , "cpu_transcoder: %s, pipe bpp: %i, dithering: %i\n" , transcoder_name ( pipe_config -> cpu_transcoder ) , pipe_config -> pipe_bpp , pipe_config -> dither ) ; drm_dbg_kms ( & i915 -> drm , "MST master transcoder: %s\n" , transcoder_name ( pipe_config -> mst_master_transcoder ) ) ; drm_dbg_kms ( & i915 -> drm , "port sync: master transcoder: %s, slave transcoder bitmask = 0x%x\n" , transcoder_name ( pipe_config -> master_transcoder ) , pipe_config -> sync_mode_slaves_mask ) ; drm_dbg_kms ( & i915 -> drm , "bigjoiner: %s, pipes: 0x%x\n" , intel_crtc_is_bigjoiner_slave ( pipe_config ) ?"slave" : intel_crtc_is_bigjoiner_master ( pipe_config ) ?"master" : "no" , pipe_config -> bigjoiner_pipes ) ; drm_dbg_kms ( & i915 -> drm , "splitter: %s, link count %d, overlap %d\n" , str_enabled_disabled ( pipe_config -> splitter . enable ) , pipe_config -> splitter . link_count , pipe_config -> splitter . pixel_overlap ) ; if ( pipe_config -> has_pch_encoder ) { intel_dump_m_n_config ( pipe_config , "fdi" , pipe_config -> fdi_lanes , & pipe_config -> fdi_m_n ) ; } if ( intel_crtc_has_dp_encoder ( pipe_config ) ) { intel_dump_m_n_config ( pipe_config , "dp m_n" , pipe_config -> lane_count , & pipe_config -> dp_m_n ) ; intel_dump_m_n_config ( pipe_config , "dp m2_n2" , pipe_config -> lane_count , & pipe_config -> dp_m2_n2 ) ; } drm_dbg_kms ( & i915 -> drm , "framestart delay: %d, MSA timing delay: %d\n" , pipe_config -> framestart_delay , pipe_config -> msa_timing_delay ) ; drm_dbg_kms ( & i915 -> drm , "audio: %i, infoframes: %i, infoframes enabled: 0x%x\n" , pipe_config -> has_audio , pipe_config -> has_infoframe , pipe_config -> infoframes . enable ) ; if ( pipe_config -> infoframes . enable & intel_hdmi_infoframe_enable ( HDMI_PACKET_TYPE_GENERAL_CONTROL ) ) { drm_dbg_kms ( & i915 -> drm , "GCP: 0x%x\n" , pipe_config -> infoframes . gcp ) ; } if ( pipe_config -> infoframes . enable & intel_hdmi_infoframe_enable ( HDMI_INFOFRAME_TYPE_AVI ) ) { intel_dump_infoframe ( i915 , & pipe_config -> infoframes . avi ) ; } if ( pipe_config -> infoframes . enable & intel_hdmi_infoframe_enable ( HDMI_INFOFRAME_TYPE_SPD ) ) { intel_dump_infoframe ( i915 , & pipe_config -> infoframes . spd ) ; } if ( pipe_config -> infoframes . enable & intel_hdmi_infoframe_enable ( HDMI_INFOFRAME_TYPE_VENDOR ) ) { intel_dump_infoframe ( i915 , & pipe_config -> infoframes . hdmi ) ; } if ( pipe_config -> infoframes . enable & intel_hdmi_infoframe_enable ( HDMI_INFOFRAME_TYPE_DRM ) ) { intel_dump_infoframe ( i915 , & pipe_config -> infoframes . drm ) ; } if ( pipe_config -> infoframes . enable & intel_hdmi_infoframe_enable ( HDMI_PACKET_TYPE_GAMUT_METADATA ) ) { intel_dump_infoframe ( i915 , & pipe_config -> infoframes . drm ) ; } if ( pipe_config -> infoframes . enable & intel_hdmi_infoframe_enable ( DP_SDP_VSC ) ) { intel_dump_dp_vsc_sdp ( i915 , & pipe_config -> infoframes . vsc ) ; } drm_dbg_kms ( & i915 -> drm , "vrr: %s, vmin: %d, vmax: %d, pipeline full: %d, guardband: %d flipline: %d, vmin vblank: %d, vmax vblank: %d\n" , str_yes_no ( pipe_config -> vrr . enable ) , pipe_config -> vrr . vmin , pipe_config -> vrr . vmax , pipe_config -> vrr . pipeline_full , pipe_config -> vrr . guardband , pipe_config -> vrr . flipline , intel_vrr_vmin_vblank_start ( pipe_config ) , intel_vrr_vmax_vblank_start ( pipe_config ) ) ; drm_dbg_kms ( & i915 -> drm , "requested mode: " DRM_MODE_FMT "\n" , DRM_MODE_ARG ( & pipe_config -> hw . mode ) ) ; drm_dbg_kms ( & i915 -> drm , "adjusted mode: " DRM_MODE_FMT "\n" , DRM_MODE_ARG ( & pipe_config -> hw . adjusted_mode ) ) ; intel_dump_crtc_timings ( i915 , & pipe_config -> hw . adjusted_mode ) ; drm_dbg_kms ( & i915 -> drm , "pipe mode: " DRM_MODE_FMT "\n" , DRM_MODE_ARG ( & pipe_config -> hw . pipe_mode ) ) ; intel_dump_crtc_timings ( i915 , & pipe_config -> hw . pipe_mode ) ; drm_dbg_kms ( & i915 -> drm , "port clock: %d, pipe src: " DRM_RECT_FMT ", pixel rate %d\n" , pipe_config -> port_clock , DRM_RECT_ARG ( & pipe_config -> pipe_src ) , pipe_config -> pixel_rate ) ; drm_dbg_kms ( & i915 -> drm , "linetime: %d, ips linetime: %d\n" , pipe_config -> linetime , pipe_config -> ips_linetime ) ; if ( DISPLAY_VER ( i915 ) >= 9 ) { drm_dbg_kms ( & i915 -> drm , "num_scalers: %d, scaler_users: 0x%x, scaler_id: %d, scaling_filter: %d\n" , crtc -> num_scalers , pipe_config -> scaler_state . scaler_users , pipe_config -> scaler_state . scaler_id , pipe_config -> hw . scaling_filter ) ; } if ( HAS_GMCH ( i915 ) ) { drm_dbg_kms ( & i915 -> drm , "gmch pfit: control: 0x%08x, ratios: 0x%08x, lvds border: 0x%08x\n" , pipe_config -> gmch_pfit . control , pipe_config -> gmch_pfit . pgm_ratios , pipe_config -> gmch_pfit . lvds_border_bits ) ; } else { drm_dbg_kms ( & i915 -> drm , "pch pfit: " DRM_RECT_FMT ", %s, force thru: %s\n" , DRM_RECT_ARG ( & pipe_config -> pch_pfit . dst ) , str_enabled_disabled ( pipe_config -> pch_pfit . enabled ) , str_yes_no ( pipe_config -> pch_pfit . force_thru ) ) ; } drm_dbg_kms ( & i915 -> drm , "ips: %i, double wide: %i, drrs: %i\n" , pipe_config -> ips_enabled , pipe_config -> double_wide , pipe_config -> has_drrs ) ; intel_dpll_dump_hw_state ( i915 , & pipe_config -> dpll_hw_state ) ; if ( IS_CHERRYVIEW ( i915 ) ) { drm_dbg_kms ( & i915 -> drm , "cgm_mode: 0x%x gamma_mode: 0x%x gamma_enable: %d csc_enable: %d\n" , pipe_config -> cgm_mode , pipe_config -> gamma_mode , pipe_config -> gamma_enable , pipe_config -> csc_enable ) ; } else { drm_dbg_kms ( & i915 -> drm , "csc_mode: 0x%x gamma_mode: 0x%x gamma_enable: %d csc_enable: %d\n" , pipe_config -> csc_mode , pipe_config -> gamma_mode , pipe_config -> gamma_enable , pipe_config -> csc_enable ) ; } drm_dbg_kms ( & i915 -> drm , "degamma lut: %d entries, gamma lut: %d entries\n" , pipe_config -> hw . degamma_lut ?drm_color_lut_size ( pipe_config -> hw . degamma_lut ) : 0 , pipe_config -> hw . gamma_lut ?drm_color_lut_size ( pipe_config -> hw . gamma_lut ) : 0 ) ; dump_planes if ( ! state ) { return ; } for_each_new_intel_plane_in_state ( , , , ) { if ( plane -> pipe == crtc -> pipe ) { intel_dump_plane_state ( plane_state ) ; } } } 