RD_NTSTATUS disk_set_information ( RD_NTHANDLE handle , uint32 info_class , STREAM in , STREAM out ) { UNUSED ( out ) ; uint32 length , file_attributes , ft_high , ft_low ; char * newname , fullpath [ PATH_MAX ] ; struct fileinfo * pfinfo ; int mode ; struct stat filestat ; time_t write_time , change_time , access_time , mod_time ; struct utimbuf tvs ; struct STATFS_T stat_fs ; logger ( Disk , Debug , "disk_set_information(handle=0x%x, info_class=0x%x, ...)" , handle , info_class ) ; pfinfo = & ( g_fileinfo [ handle ] ) ; g_notify_stamp = True ; newname = NULL ; switch ( info_class ) { case FileBasicInformation : write_time = change_time = access_time = 0 ; in_uint8s ( in , 4 ) ; in_uint8s ( in , 24 ) ; in_uint32_le ( in , ft_low ) ; in_uint32_le ( in , ft_high ) ; in_uint32_le ( in , ft_low ) ; in_uint32_le ( in , ft_high ) ; if ( ft_low || ft_high ) { access_time = convert_1970_to_filetime ( ft_high , ft_low ) ; } in_uint32_le ( in , ft_low ) ; in_uint32_le ( in , ft_high ) ; if ( ft_low || ft_high ) { write_time = convert_1970_to_filetime ( ft_high , ft_low ) ; } in_uint32_le ( in , ft_low ) ; in_uint32_le ( in , ft_high ) ; if ( ft_low || ft_high ) { change_time = convert_1970_to_filetime ( ft_high , ft_low ) ; } in_uint32_le ( in , file_attributes ) ; tvs . modtime = filestat . st_mtime ; tvs . actime = filestat . st_atime ; if ( access_time ) { tvs . actime = access_time ; } if ( write_time || change_time ) { mod_time = MIN ( write_time , change_time ) ; } else { mod_time = write_time ?write_time : change_time ; } if ( mod_time ) { tvs . modtime = mod_time ; } if ( access_time || write_time || change_time ) { logger ( Disk , Debug , "disk_set_information(), access time='%s', modify time='%s'" , ctime ( & tvs . actime ) , ctime ( & tvs . modtime ) ) ; if ( utime ( pfinfo -> path , & tvs ) && errno != EPERM ) { return RD_STATUS_ACCESS_DENIED ; } } if ( ! file_attributes ) { break ; } mode = filestat . st_mode ; if ( file_attributes & FILE_ATTRIBUTE_READONLY ) { mode &= ~ ( S_IWUSR | S_IWGRP | S_IWOTH ) ; } else { mode |= S_IWUSR ; } mode &= 0777 ; logger ( Disk , Debug , "disk_set_information(), access mode 0%o" , mode ) ; if ( fchmod ( handle , mode ) ) { return RD_STATUS_ACCESS_DENIED ; } break ; case FileRenameInformation : in_uint8s ( in , 4 ) ; in_uint8s ( in , 0x1a ) ; in_uint32_le ( in , length ) ; if ( length && ( length / 2 ) >= 256 ) { return RD_STATUS_INVALID_PARAMETER ; } rdp_in_unistr ( in , length , & newname , & length ) ; if ( newname == NULL ) { return RD_STATUS_INVALID_PARAMETER ; } convert_to_unix_filename ( newname ) ; sprintf ( fullpath , "%s%s" , g_rdpdr_device [ pfinfo -> device_id ] . local_path , newname ) ; free ( newname ) ; if ( rename ( pfinfo -> path , fullpath ) != 0 ) { logger ( Disk , Error , "disk_set_information(), rename() failed: %s" , strerror ( errno ) ) ; return RD_STATUS_ACCESS_DENIED ; } break ; case FileDispositionInformation : in_uint8s ( in , 4 ) ; in_uint8s ( in , 24 ) ; if ( ( pfinfo -> accessmask & ( FILE_DELETE_ON_CLOSE | FILE_COMPLETE_IF_OPLOCKED ) ) ) { if ( pfinfo -> pdir ) { DIR * dp = opendir ( pfinfo -> path ) ; struct dirent * dir ; while ( ( dir = readdir ( dp ) ) != NULL ) { if ( strcmp ( dir -> d_name , "." ) != 0 && strcmp ( dir -> d_name , ".." ) != 0 ) { closedir ( dp ) ; return RD_STATUS_DIRECTORY_NOT_EMPTY ; } } closedir ( dp ) ; } pfinfo -> delete_on_close = True ; } break ; case FileAllocationInformation : case FileEndOfFileInformation : in_uint8s ( in , 28 ) ; in_uint32_le ( in , length ) ; if ( STATFS_FN ( pfinfo -> path , & stat_fs ) == 0 ) { if ( stat_fs . f_bfree * stat_fs . f_bsize < length ) { return RD_STATUS_DISK_FULL ; } } if ( ftruncate_growable ( handle , length ) != 0 ) { return RD_STATUS_DISK_FULL ; } break ; default : logger ( Disk , Warning , "disk_set_information(), unhandled information class 0x%x" , info_class ) ; return RD_STATUS_INVALID_PARAMETER ; } return RD_STATUS_SUCCESS ; } 