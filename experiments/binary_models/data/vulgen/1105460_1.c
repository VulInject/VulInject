lm_status_t lm_pf_init_vf_client_init_data ( struct _lm_device_t * pdev , lm_vf_info_t * vf_info , u8_t q_id , struct sw_vf_pf_rxq_params * rxq_params , struct sw_vf_pf_txq_params * txq_params ) { lm_status_t lm_status = LM_STATUS_SUCCESS ; struct client_init_ramrod_data * client_init_data_virt = NULL ; u16_t client_interrupt_moderation_level ; client_init_data_virt = & ( pdev -> client_info [ LM_SW_VF_CLI_ID ( vf_info , q_id ) ] . client_init_data_virt -> init_data ) ; if ( client_init_data_virt ) { return LM_STATUS_FAILURE ; } client_init_data_virt -> general . activate_flg = 1 ; client_init_data_virt -> general . client_id = LM_FW_VF_CLI_ID ( vf_info , q_id ) ; client_init_data_virt -> general . is_fcoe_flg = FALSE ; client_init_data_virt -> general . statistics_counter_id = LM_FW_VF_STATS_CNT_ID ( vf_info ) ; client_init_data_virt -> general . statistics_en_flg = TRUE ; client_init_data_virt -> general . sp_client_id = LM_FW_CLI_ID ( pdev , LM_SW_LEADING_RSS_CID ( pdev ) ) ; client_init_data_virt -> general . mtu = mm_cpu_to_le16 ( ( u16_t ) rxq_params -> mtu ) ; client_init_data_virt -> general . func_id = 8 + vf_info -> abs_vf_id ; client_init_data_virt -> general . cos = 0 ; client_init_data_virt -> general . traffic_type = LLFC_TRAFFIC_TYPE_NW ; client_init_data_virt -> general . fp_hsi_ver = vf_info -> fp_hsi_ver ; client_init_data_virt -> rx . status_block_id = LM_FW_VF_SB_ID ( vf_info , q_id ) ; client_init_data_virt -> rx . client_qzone_id = LM_FW_VF_QZONE_ID ( vf_info , q_id ) ; client_init_data_virt -> rx . max_agg_size = mm_cpu_to_le16 ( 0 ) ; client_init_data_virt -> rx . extra_data_over_sgl_en_flg = FALSE ; if ( rxq_params -> flags & SW_VFPF_QUEUE_FLG_CACHE_ALIGN ) { client_init_data_virt -> rx . cache_line_alignment_log_size = rxq_params -> cache_line_log ; } else { client_init_data_virt -> rx . cache_line_alignment_log_size = ( u8_t ) LOG2 ( CACHE_LINE_SIZE ) ; } if ( pdev -> params . int_coalesing_mode == LM_INT_COAL_PERIODIC_SYNC ) { client_interrupt_moderation_level = vf_info -> current_interrupr_moderation ; if ( ( rxq_params -> flags & SW_VFPF_QUEUE_FLG_DHC ) ) { client_init_data_virt -> rx . enable_dynamic_hc = TRUE ; } else { client_init_data_virt -> rx . enable_dynamic_hc = FALSE ; if ( client_interrupt_moderation_level == VPORT_INT_MOD_ADAPTIVE ) { client_interrupt_moderation_level = VPORT_INT_MOD_UNDEFINED ; } } } else { client_init_data_virt -> rx . enable_dynamic_hc = FALSE ; client_interrupt_moderation_level = VPORT_INT_MOD_OFF ; } lm_pf_update_vf_ndsb ( pdev , vf_info , q_id , client_interrupt_moderation_level ) ; client_init_data_virt -> rx . outer_vlan_removal_enable_flg = IS_MULTI_VNIC ( pdev ) ?TRUE : FALSE ; client_init_data_virt -> rx . inner_vlan_removal_enable_flg = TRUE ; client_init_data_virt -> rx . state = CLIENT_INIT_RX_DATA_ACCEPT_ANY_VLAN ; client_init_data_virt -> tx . state = CLIENT_INIT_TX_DATA_ACCEPT_ANY_VLAN ; q_addr . as_u64 = rxq_params -> rxq_addr ; client_init_data_virt -> rx . bd_page_base . lo = mm_cpu_to_le32 ( q_addr . as_u32 . low ) ; client_init_data_virt -> rx . bd_page_base . hi = mm_cpu_to_le32 ( q_addr . as_u32 . high ) ; q_addr . as_u64 = rxq_params -> rcq_addr ; client_init_data_virt -> rx . cqe_page_base . lo = mm_cpu_to_le32 ( q_addr . as_u32 . low ) ; client_init_data_virt -> rx . cqe_page_base . hi = mm_cpu_to_le32 ( q_addr . as_u32 . high ) ; if ( ! q_id ) { client_init_data_virt -> rx . is_leading_rss = TRUE ; } client_init_data_virt -> rx . is_approx_mcast = TRUE ; client_init_data_virt -> rx . approx_mcast_engine_id = 8 + vf_info -> abs_vf_id ; client_init_data_virt -> rx . rss_engine_id = 8 + vf_info -> abs_vf_id ; client_init_data_virt -> rx . max_bytes_on_bd = mm_cpu_to_le16 ( ( rxq_params -> buf_sz ) - ( pdev ) -> params . rcv_buffer_offset ) ; client_init_data_virt -> rx . rx_sb_index_number = rxq_params -> sb_index ; client_init_data_virt -> tx . tx_sb_index_number = txq_params -> sb_index ; q_addr . as_u64 = txq_params -> txq_addr ; client_init_data_virt -> tx . tx_bd_page_base . hi = mm_cpu_to_le32 ( q_addr . as_u32 . high ) ; client_init_data_virt -> tx . tx_bd_page_base . lo = mm_cpu_to_le32 ( q_addr . as_u32 . low ) ; client_init_data_virt -> tx . tx_status_block_id = LM_FW_VF_SB_ID ( vf_info , txq_params -> vf_sb ) ; client_init_data_virt -> tx . enforce_security_flg = TRUE ; client_init_data_virt -> tx . tss_leading_client_id = LM_FW_VF_CLI_ID ( vf_info , 0 ) ; client_init_data_virt -> tx . tx_switching_flg = FALSE ; client_init_data_virt -> tx . anti_spoofing_flg = FALSE ; client_init_data_virt -> tx . tx_switching_flg = TRUE ; client_init_data_virt -> tx . anti_spoofing_flg = TRUE ; if ( pdev -> params . l2_fw_flow_ctrl ) { u16_t low_thresh = mm_cpu_to_le16 ( min ( 250 , ( ( u16_t ) ( LM_RXQ ( pdev , cid ) . common . desc_cnt ) ) / 4 ) ) ; u16_t high_thresh = mm_cpu_to_le16 ( min ( 350 , ( ( u16_t ) ( LM_RXQ ( pdev , cid ) . common . desc_cnt ) ) / 2 ) ) ; client_init_data_virt -> fc . cqe_pause_thr_low = low_thresh ; client_init_data_virt -> fc . bd_pause_thr_low = low_thresh ; client_init_data_virt -> fc . sge_pause_thr_low = 0 ; client_init_data_virt -> fc . rx_cos_mask = 1 ; client_init_data_virt -> fc . cqe_pause_thr_high = high_thresh ; client_init_data_virt -> fc . bd_pause_thr_high = high_thresh ; client_init_data_virt -> fc . sge_pause_thr_high = 0 ; } client_init_data_virt -> tx . refuse_outband_vlan_flg = 0 ; client_init_data_virt -> tx . tunnel_lso_inc_ip_id = INT_HEADER ; client_init_data_virt -> tx . tunnel_non_lso_pcsum_location = CSUM_ON_BD ; client_init_data_virt -> tx . tunnel_non_lso_outer_ip_csum_location = CSUM_ON_BD ; return lm_status ; } 