static int decode_slice_thread ( AVCodecContext * avctx , void * arg , int jobnr , int threadnr ) { const ProresContext * ctx = avctx -> priv_data ; SliceContext * slice = & ctx -> slices [ jobnr ] ; const uint8_t * buf = slice -> data ; AVFrame * pic = ctx -> frame ; int i , hdr_size , qscale , log2_chroma_blocks_per_mb ; int luma_stride , chroma_stride ; int y_data_size , u_data_size , v_data_size , a_data_size , offset ; uint8_t * dest_y , * dest_u , * dest_v ; LOCAL_ALIGNED_16 ( int16_t , qmat_luma_scaled , [ 64 ] ) ; LOCAL_ALIGNED_16 ( int16_t , qmat_chroma_scaled , [ 64 ] ) ; int mb_x_shift ; int ret ; uint16_t val_no_chroma ; slice -> ret = - 1 ; hdr_size = buf [ 0 ] >> 3 ; qscale = av_clip ( buf [ 1 ] , 1 , 224 ) ; qscale = qscale > 128 ?qscale - 96 << 2 : qscale ; y_data_size = AV_RB16 ( buf + 2 ) ; u_data_size = AV_RB16 ( buf + 4 ) ; v_data_size = slice -> data_size - y_data_size - u_data_size - hdr_size ; a_data_size = slice -> data_size - y_data_size - u_data_size - v_data_size - hdr_size ; if ( y_data_size < 0 || u_data_size < 0 || v_data_size ( 0 || hdr_size + y_data_size + u_data_size + v_data_size ) slice -> data_size ) { av_log ( avctx , AV_LOG_ERROR , "invalid plane data size\n" ) ; return AVERROR_INVALIDDATA ; } buf += hdr_size ; for ( i = 0 ; i < 64 ; i ++ ) { qmat_luma_scaled [ i ] = ctx -> qmat_luma [ i ] * qscale ; qmat_chroma_scaled [ i ] = ctx -> qmat_chroma [ i ] * qscale ; } if ( ctx -> frame_type == 0 ) { luma_stride = pic -> linesize [ 0 ] ; chroma_stride = pic -> linesize [ 1 ] ; } else { luma_stride = pic -> linesize [ 0 ] << 1 ; chroma_stride = pic -> linesize [ 1 ] << 1 ; } if ( avctx -> pix_fmt == AV_PIX_FMT_YUV444P10 || avctx -> pix_fmt == AV_PIX_FMT_YUVA444P10 || avctx -> pix_fmt == AV_PIX_FMT_YUV444P12 || avctx -> pix_fmt == AV_PIX_FMT_YUVA444P12 ) { mb_x_shift = 5 ; log2_chroma_blocks_per_mb = 2 ; } else { mb_x_shift = 4 ; log2_chroma_blocks_per_mb = 1 ; } offset = ( slice -> mb_y << 4 ) * luma_stride + ( slice -> mb_x << 5 ) ; dest_y = pic -> data [ 0 ] + offset ; dest_u = pic -> data [ 1 ] + ( slice -> mb_y << 4 ) * chroma_stride + ( slice -> mb_x << mb_x_shift ) ; dest_v = pic -> data [ 2 ] + ( slice -> mb_y << 4 ) * chroma_stride + ( slice -> mb_x << mb_x_shift ) ; if ( ctx -> frame_type && ctx -> first_field ^ ctx -> frame -> top_field_first ) { dest_y += pic -> linesize [ 0 ] ; dest_u += pic -> linesize [ 1 ] ; dest_v += pic -> linesize [ 2 ] ; offset += pic -> linesize [ 3 ] ; } ret = decode_slice_luma ( avctx , slice , ( uint16_t * ) dest_y , luma_stride , buf , y_data_size , qmat_luma_scaled ) ; if ( ret < 0 ) { return ret ; } if ( ! ( avctx -> flags & AV_CODEC_FLAG_GRAY ) && ( u_data_size + v_data_size ) > 0 ) { ret = decode_slice_chroma ( avctx , slice , ( uint16_t * ) dest_u , chroma_stride , buf + y_data_size , u_data_size , qmat_chroma_scaled , log2_chroma_blocks_per_mb ) ; if ( ret < 0 ) { return ret ; } ret = decode_slice_chroma ( avctx , slice , ( uint16_t * ) dest_v , chroma_stride , buf + y_data_size + u_data_size , v_data_size , qmat_chroma_scaled , log2_chroma_blocks_per_mb ) ; if ( ret < 0 ) { return ret ; } } else { size_t mb_max_x = slice -> mb_count << ( mb_x_shift - 1 ) ; size_t i , j ; if ( avctx -> bits_per_raw_sample == 10 ) { val_no_chroma = 511 ; } else { val_no_chroma = 511 * 4 ; } for ( i = 0 ; i < 16 ; ++ i ) { for ( j = 0 ; j < mb_max_x ; ++ j ) { * ( uint16_t * ) ( dest_u + ( i * chroma_stride ) + ( j << 1 ) ) = val_no_chroma ; * ( uint16_t * ) ( dest_v + ( i * chroma_stride ) + ( j << 1 ) ) = val_no_chroma ; } } } if ( ctx -> alpha_info && pic -> data [ 3 ] && a_data_size ) { uint8_t * dest_a = pic -> data [ 3 ] + offset ; decode_slice_alpha ( ctx , ( uint16_t * ) dest_a , luma_stride , buf + y_data_size + u_data_size + v_data_size , a_data_size , slice -> mb_count ) ; } slice -> ret = 0 ; return 0 ; } 