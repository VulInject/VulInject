void mainbus_attach_node ( struct device * self , int node , cfmatch_t submatch ) { struct mainbus_softc * sc = ( mainbus_softc * ) self ; struct fdt_attach_args fa ; int i , len , line ; uint32_t * cell , * reg ; struct device * child ; cfprint_t print = NULL ; for ( i = 0 ; i < nitems ( sc -> sc_early_nodes ) ; i ++ ) { if ( sc -> sc_early_nodes [ i ] == node ) { return ; } if ( sc -> sc_early_nodes [ i ] == 0 ) { break ; } } fa . fa_name = "" ; fa . fa_node = node ; fa . fa_iot = sc -> sc_iot ; fa . fa_dmat = sc -> sc_dmat ; fa . fa_acells = sc -> sc_acells ; fa . fa_scells = sc -> sc_scells ; len = OF_getproplen ( node , "reg" ) ; line = ( sc -> sc_acells + sc -> sc_scells ) * sizeof ( uint32_t ) ; if ( len > 0 && ( len % line ) == 0 ) { reg = malloc ( len , M_TEMP , M_WAITOK ) ; OF_getpropintarray ( node , "reg" , reg , len ) ; fa . fa_reg = malloc ( ( len / line ) * sizeof ( fdt_reg ) , M_DEVBUF , M_WAITOK ) ; fa . fa_nreg = ( len / line ) ; for ( i = 0 , cell = reg ; i < len / line ; i ++ ) { if ( sc -> sc_acells >= 1 ) { fa . fa_reg [ i ] . addr = cell [ 0 ] ; } if ( sc -> sc_acells == 2 ) { fa . fa_reg [ i ] . addr <<= 32 ; fa . fa_reg [ i ] . addr |= cell [ 1 ] ; } cell += sc -> sc_acells ; if ( sc -> sc_scells >= 1 ) { fa . fa_reg [ i ] . size = cell [ 0 ] ; } if ( sc -> sc_scells == 2 ) { fa . fa_reg [ i ] . size <<= 32 ; fa . fa_reg [ i ] . size |= cell [ 1 ] ; } cell += sc -> sc_scells ; } free ( reg , M_TEMP , len ) ; } len = OF_getproplen ( node , "interrupts" ) ; if ( len > 0 && ( len % sizeof ( uint32_t ) ) == 0 ) { fa . fa_intr = malloc ( len , M_DEVBUF , M_WAITOK ) ; fa . fa_nintr = len / sizeof ( uint32_t ) ; OF_getpropintarray ( node , "interrupts" , fa . fa_intr , len ) ; } if ( submatch == NULL && sc -> sc_early == 0 ) { print = mainbus_print ; } if ( submatch == NULL ) { submatch = mainbus_match_status ; } child = config_found_sm ( self , & fa , print , submatch ) ; if ( child && sc -> sc_early ) { for ( i = 0 ; i < nitems ( sc -> sc_early_nodes ) ; i ++ ) { if ( sc -> sc_early_nodes [ i ] != 0 ) { continue ; } sc -> sc_early_nodes [ i ] = node ; break ; } } free ( fa . fa_reg , M_DEVBUF , fa . fa_nreg * sizeof ( fdt_reg ) ) ; free ( fa . fa_intr , M_DEVBUF , fa . fa_nintr * sizeof ( uint32_t ) ) ; } 