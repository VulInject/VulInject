static void cmd_add ( struct ctl_context * ctx ) { const char * table_name = ctx -> argv [ 1 ] ; const char * record_id = ctx -> argv [ 2 ] ; const char * column_name = ctx -> argv [ 3 ] ; const struct ovsdb_idl_table_class * table ; const struct ovsdb_idl_column * column ; const struct ovsdb_idl_row * row ; const struct ovsdb_type * type ; ovsdb_datum new ; int i ; ctx -> error = get_table ( table_name , & table ) ; if ( ctx -> error ) { return ; } ctx -> error = get_column ( table , column_name , & column ) ; if ( ctx -> error ) { return ; } ctx -> error = ctl_get_row ( ctx , table , record_id , must_exist , & row ) ; if ( ctx -> error ) { return ; } if ( ! row ) { return ; } ctx -> error = check_mutable ( row , column ) ; if ( ctx -> error ) { return ; } type = & column -> type ; if ( ctx -> last_command ) { ovsdb_datum_init_empty ( & new ) ; } else { ovsdb_datum_clone ( & new , ovsdb_idl_read ( row , column ) ) ; } for ( i = 4 ; i < ctx -> argc ; i ++ ) { struct ovsdb_type add_type ; struct ovsdb_datum add ; add_type = * type ; add_type . n_min = 1 ; add_type . n_max = UINT_MAX ; ctx -> error = ovsdb_datum_from_string ( & add , & add_type , ctx -> argv [ i ] , ctx -> symtab ) ; if ( ctx -> error ) { ovsdb_datum_destroy ( & new , & column -> type ) ; return ; } ovsdb_datum_union ( & new , & add , type ) ; ovsdb_datum_destroy ( & add , type ) ; } if ( ! ctx -> last_command && new . n > type -> n_max ) { ctl_error ( ctx , "\"add\" operation would put %u %s in column %s of " "table %s but the maximum number is %u" , new . n , type -> value . type == OVSDB_TYPE_VOID ?"values" : "pairs" , column -> name , table -> name , type -> n_max ) ; ovsdb_datum_destroy ( & new , & column -> type ) ; return ; } if ( ctx -> last_command ) { for ( i = 0 ; i < new . n ; i ++ ) { struct ovsdb_datum * datum = xmalloc ( sizeof datum ) ; ovsdb_datum_init_empty ( datum ) ; ovsdb_datum_add_from_index_unsafe ( datum , & new , i , type ) ; if ( ovsdb_type_is_map ( type ) ) { ovsdb_idl_txn_write_partial_map ( row , column , datum ) ; } else { ovsdb_idl_txn_write_partial_set ( row , column , datum ) ; } } ovsdb_datum_destroy ( & new , & column -> type ) ; } else { ovsdb_idl_txn_verify ( row , column ) ; ovsdb_idl_txn_write ( row , column , & new ) ; } invalidate_cache ( ctx ) ; } 