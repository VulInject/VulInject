static void sctp_endpoint_bh_rcv ( struct work_struct * work ) static struct sctp_endpoint * sctp_endpoint_init ( struct sctp_endpoint * ep , struct sock * sk , gfp_t gfp ) { struct net * net = sock_net ( sk ) ; struct sctp_shared_key * null_key ; ep -> digest = kzalloc ( SCTP_SIGNATURE_SIZE , gfp ) ; if ( ! ep -> digest ) { return NULL ; } ep -> asconf_enable = net -> sctp . addip_enable ; ep -> auth_enable = net -> sctp . auth_enable ; if ( ep -> auth_enable ) { if ( sctp_auth_init ( ep , gfp ) ) { nomem } if ( ep -> asconf_enable ) { sctp_auth_ep_add_chunkid ( ep , SCTP_CID_ASCONF ) ; sctp_auth_ep_add_chunkid ( ep , SCTP_CID_ASCONF_ACK ) ; } } ep -> base . type = SCTP_EP_TYPE_SOCKET ; refcount_set ( & ep -> base . refcnt , 1 ) ; ep -> base . dead = false ; sctp_inq_init ( & ep -> base . inqueue ) ; sctp_inq_set_th_handler ( & ep -> base . inqueue , sctp_endpoint_bh_rcv ) ; sctp_bind_addr_init ( & ep -> base . bind_addr , 0 ) ; INIT_LIST_HEAD ( & ep -> asocs ) ; ep -> sndbuf_policy = net -> sctp . sndbuf_policy ; sk -> sk_data_ready = sctp_data_ready ; sk -> sk_write_space = sctp_write_space ; sock_set_flag ( sk , SOCK_USE_WRITE_QUEUE ) ; ep -> rcvbuf_policy = net -> sctp . rcvbuf_policy ; get_random_bytes ( ep -> secret_key , sizeof ( ep -> secret_key ) ) ; null_key = sctp_auth_shkey_create ( 0 , gfp ) ; if ( ! null_key ) { nomem_shkey } list_add ( & null_key -> key_list , & ep -> endpoint_shared_keys ) ; ep -> prsctp_enable = net -> sctp . prsctp_enable ; ep -> reconf_enable = net -> sctp . reconf_enable ; ep -> ecn_enable = net -> sctp . ecn_enable ; ep -> base . sk = sk ; ep -> base . net = sock_net ( sk ) ; sock_hold ( ep -> base . sk ) ; return ep ; nomem_shkey sctp_auth_free ( ep ) ; nomem kfree ( ep -> digest ) ; return NULL ; } 