void cern__flush_buffer ( YY_BUFFER_STATE b ) void cern_push_buffer_state ( YY_BUFFER_STATE new_buffer ) void cern_pop_buffer_state ( void ) static void cern_ensure_buffer_stack ( void ) static void cern__load_buffer_state ( void ) static void cern__init_buffer ( YY_BUFFER_STATE b , FILE * file ) YY_BUFFER_STATE cern__scan_buffer ( char * base , yy_size_t size ) YY_BUFFER_STATE cern__scan_string ( yyconst char * yy_str ) YY_BUFFER_STATE cern__scan_bytes ( yyconst char * bytes , yy_size_t len ) void * cern_alloc ( yy_size_t ) void * cern_realloc ( void * , yy_size_t ) void cern_free ( void * ) { if ( ! YY_CURRENT_BUFFER ) { cern_ensure_buffer_stack ( ) ; YY_CURRENT_BUFFER_LVALUE = cern__create_buffer ( cern_in , YY_BUF_SIZE ) ; } YY_CURRENT_BUFFER_LVALUE -> yy_is_interactive = is_interactive ; } { if ( ! YY_CURRENT_BUFFER ) { cern_ensure_buffer_stack ( ) ; YY_CURRENT_BUFFER_LVALUE = cern__create_buffer ( cern_in , YY_BUF_SIZE ) ; } YY_CURRENT_BUFFER_LVALUE -> yy_at_bol = at_bol ; } unsigned char YY_CHAR FILE * cern_in = ( FILE * ) 0 , * cern_out = ( FILE * ) 0 ; int yy_state_type extern int cern_lineno ; int cern_lineno = 1 ; extern char * cern_text ; static yy_state_type yy_get_previous_state ( void ) static yy_state_type yy_try_NUL_trans ( yy_state_type current_state ) static int yy_get_next_buffer ( void ) static void yy_fatal_error ( yyconst char msg [ ] ) ( yytext_ptr ) = yy_bp ; cern_leng = ( size_t ) ( yy_cp - yy_bp ) ; ( yy_hold_char ) = * yy_cp ; * yy_cp = '\0' ; ( yy_c_buf_p ) = yy_cp ; yy_trans_info { flex_int32_t yy_verify ; flex_int32_t yy_nxt ; } static yyconst flex_int16_t yy_accept [ 94 ] { 0 10 10 0 0 14 12 11 11 12 10 10 10 12 12 10 12 12 13 4 0 9 11 10 10 10 10 0 0 10 10 0 0 0 4 0 0 0 0 6 0 7 5 0 0 9 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 2 0 } ; ; static yyconst flex_int32_t yy_ec [ 256 ] { 0 1 1 1 1 1 1 1 1 2 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 4 5 1 1 1 6 7 1 8 9 10 11 1 12 13 13 13 14 13 15 13 13 16 17 1 1 1 1 1 1 18 1 19 20 21 22 1 23 24 1 1 25 1 26 27 28 1 29 30 31 32 1 1 1 33 1 1 1 1 1 1 1 34 1 35 36 37 38 1 39 40 1 1 41 1 42 43 44 1 45 46 47 48 1 1 1 49 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 } ; ; static yyconst flex_int32_t yy_meta [ 50 ] { 0 1 2 3 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 } ; ; static yyconst flex_int16_t yy_base [ 98 ] { 0 0 0 276 275 277 270 48 50 309 51 86 121 52 53 156 54 56 269 309 268 309 58 170 205 240 254 65 81 101 115 55 76 262 309 103 122 72 143 261 109 260 67 136 80 141 145 248 258 235 230 230 235 224 224 218 217 223 106 147 213 199 189 187 184 161 151 139 111 113 83 81 147 161 156 141 163 150 183 194 185 195 196 199 74 205 69 227 211 233 255 197 67 309 297 300 303 306 } ; ; static yyconst flex_int16_t yy_def [ 98 ] { 0 93 1 94 94 93 95 93 93 93 95 95 95 95 95 95 95 95 96 93 95 93 93 95 95 95 95 95 95 95 95 95 95 96 93 95 95 95 95 95 95 95 95 95 93 93 95 93 95 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 0 93 93 93 93 } ; ; static yyconst flex_int16_t yy_nxt [ 359 ] { 0 6 7 8 6 6 6 6 6 9 10 11 12 12 12 12 12 6 6 13 14 15 6 6 6 6 6 6 16 17 6 6 6 6 6 13 14 15 6 6 6 6 6 6 16 17 6 6 6 6 22 22 22 22 21 21 21 21 21 21 22 22 23 24 24 24 24 24 21 44 45 72 25 72 28 21 27 32 72 21 37 31 44 44 21 72 47 72 25 21 28 86 27 32 35 38 37 31 26 26 26 26 26 36 21 41 21 25 59 59 35 38 21 30 30 30 30 30 21 36 70 41 39 25 21 21 69 30 30 30 30 30 23 24 24 24 24 24 39 21 40 43 25 44 44 72 21 47 21 59 59 72 73 60 72 68 40 43 25 21 72 46 77 67 29 72 29 72 30 30 30 30 30 21 42 66 48 46 77 74 79 75 26 26 26 26 26 72 76 72 42 25 48 65 78 74 79 75 72 72 72 72 64 72 76 63 80 25 21 72 78 62 82 81 92 72 23 24 24 24 24 24 80 85 83 84 25 61 82 81 58 72 57 87 56 89 55 72 54 85 83 84 25 21 53 52 51 50 29 87 29 89 30 30 30 30 30 21 88 72 90 21 49 21 21 34 26 26 26 26 26 21 34 21 88 25 90 93 19 19 93 91 93 93 93 93 93 93 93 93 93 25 93 93 93 93 93 91 18 18 18 20 93 20 33 33 33 71 71 5 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 } ; ; static yyconst flex_int16_t yy_chk [ 359 ] { 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7 8 8 10 13 14 16 31 17 22 22 10 10 10 10 10 10 27 42 42 92 10 86 14 37 13 17 84 32 31 16 44 44 28 71 44 70 10 11 14 84 13 17 27 32 31 16 11 11 11 11 11 28 29 37 35 11 58 58 27 32 40 29 29 29 29 29 30 28 69 37 35 11 12 36 68 30 30 30 30 30 12 12 12 12 12 12 35 43 36 40 12 45 45 75 38 45 46 59 59 72 72 59 77 67 36 40 12 15 74 43 75 66 15 73 15 76 15 15 15 15 15 23 38 65 46 43 75 73 77 73 23 23 23 23 23 78 74 80 38 23 46 64 76 73 77 73 79 81 82 91 63 83 74 62 78 23 24 85 76 61 80 79 91 88 24 24 24 24 24 24 78 83 81 82 24 60 80 79 57 87 56 85 55 88 54 89 53 83 81 82 24 25 52 51 50 49 25 85 25 88 25 25 25 25 25 26 87 90 89 48 47 41 39 33 26 26 26 26 26 20 18 6 87 26 89 5 4 3 0 90 0 0 0 0 0 0 0 0 0 26 0 0 0 0 0 90 94 94 94 95 0 95 96 96 96 97 97 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 } ; ; static yy_state_type yy_last_accepting_state ; static char * yy_last_accepting_cpos ; extern int cern__flex_debug ; int cern__flex_debug = 0 ; char * cern_text ; static int yy_init_globals ( void ) int cern_lex_destroy ( void ) int cern_get_debug ( void ) void cern_set_debug ( int debug_flag ) YY_EXTRA_TYPE cern_get_extra ( void ) void cern_set_extra ( YY_EXTRA_TYPE user_defined ) FILE * cern_get_in ( void ) void cern_set_in ( FILE * in_str ) FILE * cern_get_out ( void ) void cern_set_out ( FILE * out_str ) yy_size_t cern_get_leng ( void ) char * cern_get_text ( void ) int cern_get_lineno ( void ) void cern_set_lineno ( int line_number ) "C" int cern_wrap ( void ) extern int cern_wrap ( void ) static void yy_flex_strncpy ( char * , yyconst char * , int ) static int yy_flex_strlen ( yyconst char * ) static int yyinput ( void ) static int input ( void ) if ( YY_CURRENT_BUFFER_LVALUE -> yy_is_interactive ) { int c = '*' ; size_t n ; for ( n = 0 ; n < max_size && ( c = getc ( cern_in ) ) != EOF && c != '\n' ; ++ n ) { buf [ n ] = ( char ) c ; } if ( c == '\n' ) { buf [ n ++ ] = ( char ) c ; } if ( c == EOF && ferror ( cern_in ) ) { YY_FATAL_ERROR ( "input in flex scanner failed" ) ; } result = n ; } else { errno = 0 ; while ( ( result = fread ( buf , 1 , max_size , cern_in ) ) == 0 && ferror ( cern_in ) ) { if ( errno != EINTR ) { YY_FATAL_ERROR ( "input in flex scanner failed" ) ; break ; } errno = 0 ; clearerr ( cern_in ) ; } } extern int cern_lex ( void ) YY_USER_ACTION YY_DECL ( register yy_state_type yy_current_state , register char * yy_cp , * yy_bp , register int yy_act , ( ! ( yy_init ) ) { ( yy_init ) = 1 YY_USER_INIT if ( ! ( yy_start ) ) { ( yy_start ) = 1 ; } } if ( ! cern_in ) { cern_in = stdin ; } ) ; if ( ! cern_out ) { cern_out = stdout ; } if ( ! YY_CURRENT_BUFFER ) { cern_ensure_buffer_stack ( ) ; YY_CURRENT_BUFFER_LVALUE = cern__create_buffer ( cern_in , YY_BUF_SIZE ) ; } cern__load_buffer_state ( ) ; ( 1 ) { yy_cp = ( yy_c_buf_p ) * yy_cp = ( yy_hold_char ) yy_bp = yy_cp yy_current_state = ( yy_start ) yy_match : { register YY_CHAR yy_c = yy_ec [ YY_SC_TO_UI ( * yy_cp ) ] ; if ( yy_accept [ yy_current_state ] ) { ( yy_last_accepting_state ) = yy_current_state ; ( yy_last_accepting_cpos ) = yy_cp ; ; } } } ; while ( yy_chk [ yy_base [ yy_current_state ] + yy_c ] != yy_current_state ) { yy_current_state = ( int ) yy_def [ yy_current_state ] ; if ( yy_current_state >= 94 ) { yy_c = yy_meta [ ( unsigned int ) yy_c ] ; } } yy_current_state = yy_nxt [ yy_base [ yy_current_state ] + ( unsigned int ) yy_c ] ; ++ yy_cp ; ( yy_base [ yy_current_state ] != 309 ) ; yy_find_action yy_act = yy_accept [ yy_current_state ] ; if ( yy_act == 0 ) { yy_cp = ( yy_last_accepting_cpos ) ; yy_current_state = ( yy_last_accepting_state ) ; yy_act = yy_accept [ yy_current_state ] ; } YY_DO_BEFORE_ACTION ; do_action switch ( yy_act ) { case 0 : * yy_cp = ( yy_hold_char ) ; yy_cp = ( yy_last_accepting_cpos ) ; yy_current_state = ( yy_last_accepting_state ) ; yy_find_action case 1 : YY_RULE_SETUP { BEGIN ( comment ) ; return AUTHOR ; } YY_BREAK case 2 : YY_RULE_SETUP { BEGIN ( comment ) ; return DESCRIPTION ; } YY_BREAK case 3 : YY_RULE_SETUP { BEGIN ( comment ) ; return BEGIN_COMMENT ; } YY_BREAK case 4 : * yy_cp = ( yy_hold_char ) ; ( yy_c_buf_p ) = yy_cp -= 1 ; YY_DO_BEFORE_ACTION ; YY_RULE_SETUP { BEGIN ( INITIAL ) ; cern_lval . id = g_strndup ( cern_text , cern_leng ) ; return COMMENT ; } YY_BREAK case 5 : YY_RULE_SETUP return RECTANGLE ; YY_BREAK case 6 : YY_RULE_SETUP return CIRCLE ; YY_BREAK case 7 : YY_RULE_SETUP return POLYGON ; YY_BREAK case 8 : YY_RULE_SETUP return DEFAULT ; YY_BREAK case 9 : * yy_cp = ( yy_hold_char ) ; ( yy_c_buf_p ) = yy_cp -= 1 ; YY_DO_BEFORE_ACTION ; YY_RULE_SETUP { cern_lval . id = g_strndup ( cern_text , cern_leng ) ; return LINK ; } YY_BREAK case 10 : YY_RULE_SETUP { cern_lval . value = g_ascii_strtod ( cern_text , NULL ) ; return FLOAT ; } YY_BREAK case 11 : YY_RULE_SETUP ; YY_BREAK case 12 : YY_RULE_SETUP return * cern_text ; YY_BREAK case 13 : YY_RULE_SETUP ECHO ; YY_BREAK case YY_STATE_EOF ( INITIAL ) : case YY_STATE_EOF ( comment ) : yyterminate ( ) ; case YY_END_OF_BUFFER : { int yy_amount_of_matched_text = ( int ) ( yy_cp - ( yytext_ptr ) ) - 1 ; * yy_cp = ( yy_hold_char ) ; YY_RESTORE_YY_MORE_OFFSET if ( ( yy_c_buf_p ) <= & YY_CURRENT_BUFFER_LVALUE -> yy_ch_buf [ ( yy_n_chars ) ] ) { yy_state_type yy_next_state ; ( yy_c_buf_p ) = ( yytext_ptr ) + yy_amount_of_matched_text ; yy_current_state = yy_get_previous_state ( ) ; yy_next_state = yy_try_NUL_trans ( yy_current_state ) ; yy_bp = ( yytext_ptr ) + YY_MORE_ADJ ; if ( yy_next_state ) { yy_cp = ++ ( yy_c_buf_p ) ; yy_current_state = yy_next_state ; yy_match } else { yy_cp = ( yy_c_buf_p ) ; yy_find_action } } else { switch ( yy_get_next_buffer ( ) ) { case EOB_ACT_END_OF_FILE : { ( yy_did_buffer_switch_on_eof ) = 0 ; if ( cern_wrap ( ) ) { ( yy_c_buf_p ) = ( yytext_ptr ) + YY_MORE_ADJ ; yy_act = YY_STATE_EOF ( YY_START ) ; do_action } else { if ( ! ( yy_did_buffer_switch_on_eof ) ) { YY_NEW_FILE ; } } break ; } case EOB_ACT_CONTINUE_SCAN : ( yy_c_buf_p ) = ( yytext_ptr ) + yy_amount_of_matched_text ; yy_current_state = yy_get_previous_state ( ) ; yy_cp = ( yy_c_buf_p ) ; yy_bp = ( yytext_ptr ) + YY_MORE_ADJ ; yy_match case EOB_ACT_LAST_MATCH : ( yy_c_buf_p ) = & YY_CURRENT_BUFFER_LVALUE -> yy_ch_buf [ ( yy_n_chars ) ] ; yy_current_state = yy_get_previous_state ( ) ; yy_cp = ( yy_c_buf_p ) ; yy_bp = ( yytext_ptr ) + YY_MORE_ADJ ; yy_find_action } } break ; } default : YY_FATAL_ERROR ( "fatal flex scanner internal error--no action found" ) ; } 