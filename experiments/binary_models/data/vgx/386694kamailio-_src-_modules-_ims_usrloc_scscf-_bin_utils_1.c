static int bin_decode_filter_criteria ( bin_data * x , ims_filter_criteria * fc ) { int i , len ; str s ; char ppindicator , cnf ; if ( ! bin_decode_int ( x , & ( fc -> priority ) ) ) { error } if ( ! bin_decode_char ( x , & ppindicator ) ) { error } if ( ! ppindicator ) { fc -> profile_part_indicator = 0 ; } else { fc -> profile_part_indicator = ( char * ) shm_malloc ( sizeof ( char ) ) ; if ( ! fc -> profile_part_indicator ) { LM_ERR ( "bin_decode_filter_criteria: Error allocating %lx bytes.\n" , sizeof ( int ) ) ; error } * ( fc -> profile_part_indicator ) = ppindicator - 1 ; } if ( ! bin_decode_char ( x , & cnf ) ) { error } if ( cnf == 100 ) { fc -> trigger_point = NULL ; } else { ims_trigger_point * tp = 0 ; len = sizeof ( ims_trigger_point ) ; tp = ( ims_trigger_point * ) shm_malloc ( len ) ; fc -> trigger_point = tp ; if ( ! tp ) { LM_ERR ( "bin_decode_filter_criteria: Error allocating %d bytes.\n" , len ) ; error } memset ( tp , 0 , len ) ; tp -> condition_type_cnf = cnf ; if ( ! bin_decode_ushort ( x , & tp -> spt_cnt ) ) { error } len = sizeof ( ims_spt ) * tp -> spt_cnt ; tp -> spt = ( ims_spt * ) shm_malloc ( len ) ; if ( ! tp -> spt ) { LM_ERR ( "bin_decode_filter_criteria: Error allocating %d bytes.\n" , len ) ; error } for ( i = 0 ; i < tp -> spt_cnt ; i ++ ) { if ( ! bin_decode_spt ( x , tp -> spt + i ) ) { error } } } if ( ! bin_decode_str ( x , & s ) || ! str_shm_dup ( & ( fc -> application_server . server_name ) , & s ) ) { error } if ( ! bin_decode_char ( x , & ( fc -> application_server . default_handling ) ) ) { error } if ( ! bin_decode_str ( x , & s ) || ! str_shm_dup ( & ( fc -> application_server . service_info ) , & s ) ) { error } return 1 ; error LM_ERR ( "bin_decode_filter_criteria: Error while decoding (at %d (%04x)).\n" , x -> max , x -> max ) ; if ( fc ) { if ( fc -> trigger_point ) { if ( fc -> trigger_point ) { if ( fc -> trigger_point -> spt ) { shm_free ( fc -> trigger_point -> spt ) ; } } shm_free ( fc -> trigger_point ) ; } if ( fc -> application_server . server_name . s ) { shm_free ( fc -> application_server . server_name . s ) ; } if ( fc -> application_server . service_info . s ) { shm_free ( fc -> application_server . service_info . s ) ; } } return 0 ; } 