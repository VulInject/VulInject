static void myrs_log_event ( struct myrs_hba * cs , struct myrs_event * ev ) { unsigned char msg_buf [ MYRS_LINE_BUFFER_SIZE ] ; int ev_idx = 0 , ev_code ; unsigned char ev_type , * ev_msg ; struct Scsi_Host * shost = cs -> host ; struct scsi_device * sdev ; struct scsi_sense_hdr sshdr = { 0 } ; unsigned char sense_info [ 4 ] ; unsigned char cmd_specific [ 4 ] ; if ( ev -> ev_code == 0x1C ) { if ( ! scsi_normalize_sense ( ev -> sense_data , 40 , & sshdr ) ) { memset ( & sshdr , 0x0 , sizeof ( sshdr ) ) ; memset ( cmd_specific , 0x0 , sizeof ( cmd_specific ) ) ; } else { memcpy ( sense_info , & ev -> sense_data [ 3 ] , 4 ) ; memcpy ( cmd_specific , & ev -> sense_data [ 7 ] , 4 ) ; } } if ( sshdr . sense_key == VENDOR_SPECIFIC && ( sshdr . asc == 0x80 || sshdr . asc == 0x81 ) ) { ev -> ev_code = ( ( sshdr . asc - 0x80 ) << 8 | sshdr . ascq ) ; } while ( true ) { ev_code = myrs_ev_list [ ev_idx ] . ev_code ; if ( ev_code == ev -> ev_code || ev_code == 0 ) { break ; } ev_idx ++ ; } ev_type = myrs_ev_list [ ev_idx ] . ev_msg [ 0 ] ; ev_msg = & myrs_ev_list [ ev_idx ] . ev_msg [ 2 ] ; if ( ev_code == 0 ) { shost_printk ( KERN_WARNING , shost , "Unknown Controller Event Code %04X\n" , ev -> ev_code ) ; return ; } switch ( ev_type ) { case 'P' : sdev = scsi_device_lookup ( shost , ev -> channel , ev -> target , 0 ) ; sdev_printk ( KERN_INFO , sdev , "event %d: Physical Device %s\n" , ev -> ev_seq , ev_msg ) ; if ( sdev && sdev -> hostdata && sdev -> channel < cs -> ctlr_info -> physchan_present ) { struct myrs_pdev_info * pdev_info = sdev -> hostdata ; switch ( ev -> ev_code ) { case 0x0001 : case 0x0007 : pdev_info -> dev_state = MYRS_DEVICE_ONLINE ; break ; case 0x0002 : pdev_info -> dev_state = MYRS_DEVICE_STANDBY ; break ; case 0x000C : pdev_info -> dev_state = MYRS_DEVICE_OFFLINE ; break ; case 0x000E : pdev_info -> dev_state = MYRS_DEVICE_MISSING ; break ; case 0x000F : pdev_info -> dev_state = MYRS_DEVICE_UNCONFIGURED ; break ; } } break ; case 'L' : shost_printk ( KERN_INFO , shost , "event %d: Logical Drive %d %s\n" , ev -> ev_seq , ev -> lun , ev_msg ) ; cs -> needs_update = true ; break ; case 'M' : shost_printk ( KERN_INFO , shost , "event %d: Logical Drive %d %s\n" , ev -> ev_seq , ev -> lun , ev_msg ) ; cs -> needs_update = true ; break ; case 'S' : if ( sshdr . sense_key == NO_SENSE || ( sshdr . sense_key == NOT_READY && sshdr . asc == 0x04 && ( sshdr . ascq == 0x01 || sshdr . ascq == 0x02 ) ) ) { break ; } shost_printk ( KERN_INFO , shost , "event %d: Physical Device %d:%d %s\n" , ev -> ev_seq , ev -> channel , ev -> target , ev_msg ) ; shost_printk ( KERN_INFO , shost , "Physical Device %d:%d Sense Key = %X, ASC = %02X, ASCQ = %02X\n" , ev -> channel , ev -> target , sshdr . sense_key , sshdr . asc , sshdr . ascq ) ; shost_printk ( KERN_INFO , shost , "Physical Device %d:%d Sense Information = %02X%02X%02X%02X %02X%02X%02X%02X\n" , ev -> channel , ev -> target , sense_info [ 0 ] , sense_info [ 1 ] , sense_info [ 2 ] , sense_info [ 3 ] , cmd_specific [ 0 ] , cmd_specific [ 1 ] , cmd_specific [ 2 ] , cmd_specific [ 3 ] ) ; break ; case 'E' : if ( cs -> disable_enc_msg ) { break ; } sprintf ( msg_buf , ev_msg , ev -> lun ) ; shost_printk ( KERN_INFO , shost , "event %d: Enclosure %d %s\n" , ev -> ev_seq , ev -> target , msg_buf ) ; break ; case 'C' : shost_printk ( KERN_INFO , shost , "event %d: Controller %s\n" , ev -> ev_seq , ev_msg ) ; break ; default : shost_printk ( KERN_INFO , shost , "event %d: Unknown Event Code %04X\n" , ev -> ev_seq , ev -> ev_code ) ; break ; } } 