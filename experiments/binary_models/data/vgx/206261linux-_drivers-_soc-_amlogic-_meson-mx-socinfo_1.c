static int __init meson_mx_socinfo_init ( void ) { struct soc_device_attribute * soc_dev_attr ; struct soc_device * soc_dev ; struct device_node * np ; struct regmap * assist_regmap , * bootrom_regmap , * analog_top_regmap ; unsigned int major_ver , misc_ver , metal_rev = 0 ; int ret ; assist_regmap = syscon_regmap_lookup_by_compatible ( "amlogic,meson-mx-assist" ) ; if ( IS_ERR ( assist_regmap ) ) { return PTR_ERR ( assist_regmap ) ; } bootrom_regmap = syscon_regmap_lookup_by_compatible ( "amlogic,meson-mx-bootrom" ) ; if ( IS_ERR ( bootrom_regmap ) ) { return PTR_ERR ( bootrom_regmap ) ; } np = of_find_matching_node ( NULL , meson_mx_socinfo_analog_top_ids ) ; if ( np ) { analog_top_regmap = syscon_node_to_regmap ( np ) ; of_node_put ( np ) ; if ( IS_ERR ( analog_top_regmap ) ) { return PTR_ERR ( analog_top_regmap ) ; } ret = regmap_read ( analog_top_regmap , MESON_MX_ANALOG_TOP_METAL_REVISION , & metal_rev ) ; if ( ret ) { return ret ; } } ret = regmap_read ( assist_regmap , MESON_MX_ASSIST_HW_REV , & major_ver ) ; if ( ret < 0 ) { return ret ; } ret = regmap_read ( bootrom_regmap , MESON_MX_BOOTROM_MISC_VER , & misc_ver ) ; if ( ret < 0 ) { return ret ; } soc_dev_attr = kmalloc ( sizeof ( * soc_dev_attr ) , GFP_KERNEL ) ; if ( ! soc_dev_attr ) { return - ENODEV ; } soc_dev_attr -> family = "Amlogic Meson" ; np = of_find_node_by_path ( "/" ) ; of_property_read_string ( np , "model" , & soc_dev_attr -> machine ) ; of_node_put ( np ) ; soc_dev_attr -> revision = meson_mx_socinfo_revision ( major_ver , misc_ver , metal_rev ) ; soc_dev_attr -> soc_id = meson_mx_socinfo_soc_id ( major_ver , metal_rev ) ; soc_dev = soc_device_register ( soc_dev_attr ) ; if ( IS_ERR ( soc_dev ) ) { kfree_const ( soc_dev_attr -> revision ) ; kfree_const ( soc_dev_attr -> soc_id ) ; kfree ( soc_dev_attr ) ; return PTR_ERR ( soc_dev ) ; } dev_info ( soc_device_to_device ( soc_dev ) , "Amlogic %s %s detected\n" , soc_dev_attr -> soc_id , soc_dev_attr -> revision ) ; return 0 ; } 