static Bool pcmreframe_process_event ( GF_Filter * filter , const GF_FilterEvent * evt ) { u32 nb_frames ; GF_FilterEvent fevt ; GF_PCMReframeCtx * ctx = gf_filter_get_udta ( filter ) ; switch ( evt -> base . type ) { case GF_FEVT_PLAY : if ( ! ctx -> is_playing ) { ctx -> is_playing = GF_TRUE ; ctx -> cts = 0 ; } ctx -> done = GF_FALSE ; if ( evt -> play . start_range >= 0 ) { ctx -> cts = ( u64 ) ( evt -> play . start_range * ctx -> sr ) ; } else { ctx -> cts = ( ctx -> total_frames - 1 ) * ctx -> framelen ; } nb_frames = ( u32 ) ( ctx -> cts / ctx -> framelen ) ; if ( nb_frames == ctx -> total_frames ) { if ( evt -> play . speed >= 0 ) { ctx -> done = GF_TRUE ; return GF_TRUE ; } nb_frames -- ; ctx -> cts = nb_frames * ctx -> framelen ; } ctx -> filepos = nb_frames * ctx -> frame_size ; ctx -> reverse_play = ( evt -> play . speed < 0 ) ?GF_TRUE : GF_FALSE ; if ( ! ctx -> initial_play_done ) { ctx -> initial_play_done = GF_TRUE ; if ( ! ctx -> filepos ) { return GF_TRUE ; } } GF_FEVT_INIT ( fevt , GF_FEVT_SOURCE_SEEK , ctx -> ipid ) ; fevt . seek . start_offset = ctx -> filepos + ctx -> wav_hdr_size ; gf_filter_pid_send_event ( ctx -> ipid , & fevt ) ; return GF_TRUE ; case GF_FEVT_STOP : ctx -> is_playing = GF_FALSE ; if ( ctx -> out_pck ) { gf_filter_pck_discard ( ctx -> out_pck ) ; ctx -> out_pck = NULL ; } return GF_FALSE ; case GF_FEVT_SET_SPEED : return GF_TRUE ; default : break ; } return GF_FALSE ; } 