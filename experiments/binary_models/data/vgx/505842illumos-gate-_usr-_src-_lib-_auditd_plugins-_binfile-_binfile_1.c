auditd_rc_t auditd_plugin ( const char * input , size_t in_len , uint64_t sequence , char * * error ) { auditd_rc_t rc = AUDITD_FAIL ; int open_status ; size_t out_len ; static int allsoftfull_warning = 0 ; static int allhard_pause = 0 ; static struct timeval next_allhard ; struct timeval now ; int statrc ; static char * last_file_written_to = NULL ; static uint64_t last_sequence = 0 ; static uint64_t write_count = 0 ; if ( ( last_sequence > 0 ) && ( sequence != last_sequence + 1 ) ) { ( void ) fprintf ( dbfp , "binfile: buffer sequence=%llu but prev=%llu=n" , sequence , last_sequence ) ; } last_sequence = sequence ; ( void ) fprintf ( dbfp , "binfile: input seq=%llu, len=%d\n" , sequence , in_len ) ; * error = NULL ; ( void ) pthread_mutex_lock ( & log_mutex ) ; if ( ( binfile_maxsize != 0 ) && ( ( binfile_cursize + in_len ) > binfile_maxsize ) ) { DPRINT ( ( dbfp , "binfile: maxsize exceeded, opening new audit " "file.\n" ) ) ; openNewFile = 1 ; } while ( rc == AUDITD_FAIL ) { open_status = 1 ; if ( openNewFile ) { open_status = open_log ( activeDir ) ; if ( open_status == 1 ) { openNewFile = 0 ; } } if ( ( open_status == 1 ) && ( spacecheck ( activeDir , fullness_state , in_len ) != 0 ) ) { if ( ( open_status == 1 ) && ( statrc = spacecheck ( activeDir , fullness_state , in_len ) != 0 ) ) { DPRINT ( ( dbfp , "binfile: returned from spacecheck\n" ) ) ; if ( ( last_file_written_to != NULL ) && ( strcmp ( last_file_written_to , activeDir -> dl_filename ) != 0 ) ) { DPRINT ( ( dbfp , "binfile:  now writing to %s\n" , activeDir -> dl_filename ) ) ; } DPRINT ( ( dbfp , "binfile:  finished some debug stuff\n" ) ) ; last_file_written_to = strdup ( activeDir -> dl_filename ) ; out_len = write ( activeDir -> dl_fd , input , in_len ) ; DPRINT ( ( dbfp , "binfile:  finished the write\n" ) ) ; binfile_cursize += out_len ; if ( out_len == in_len ) { DPRINT ( ( dbfp , "binfile: write_count=%llu, sequence=%llu," " l=%u\n" , ++ write_count , sequence , out_len ) ) ; allsoftfull_warning = 0 ; activeDir -> dl_flags = 0 ; rc = AUDITD_SUCCESS ; break ; } if ( ! ( activeDir -> dl_flags & HARD_WARNED ) ) { DPRINT ( ( dbfp , "binfile: write failed, sequence=%llu, " "l=%u\n" , sequence , out_len ) ) ; DPRINT ( ( dbfp , "hard warning sent.\n" ) ) ; __audit_dowarn ( "hard" , activeDir -> dl_dirname , 0 ) ; activeDir -> dl_flags |= HARD_WARNED ; } } else { DPRINT ( ( dbfp , "binfile: statrc=%d, fullness_state=%d\n" , statrc , fullness_state ) ) ; if ( ! ( activeDir -> dl_flags & SOFT_WARNED ) && ( activeDir -> dl_space == SOFT_SPACE ) ) { DPRINT ( ( dbfp , "soft warning sent\n" ) ) ; __audit_dowarn ( "soft" , activeDir -> dl_dirname , 0 ) ; activeDir -> dl_flags |= SOFT_WARNED ; } if ( ! ( activeDir -> dl_flags & HARD_WARNED ) && ( activeDir -> dl_space == SPACE_FULL ) ) { DPRINT ( ( dbfp , "hard warning sent.\n" ) ) ; __audit_dowarn ( "hard" , activeDir -> dl_dirname , 0 ) ; activeDir -> dl_flags |= HARD_WARNED ; } } DPRINT ( ( dbfp , "binfile: activeDir=%s, next=%s\n" , activeDir -> dl_dirname , activeDir -> dl_next -> dl_dirname ) ) ; activeDir = activeDir -> dl_next ; openNewFile = 1 ; if ( activeDir == startdir ) { if ( fullness_state == PLENTY_SPACE ) { fullness_state = SOFT_SPACE ; if ( allsoftfull_warning == 0 ) { allsoftfull_warning ++ ; __audit_dowarn ( "allsoft" , "" , 0 ) ; } } else { if ( ( hung_count > 0 ) && ! allhard_pause ) { allhard_pause = 1 ; ( void ) gettimeofday ( & next_allhard , NULL ) ; next_allhard . tv_sec += ALLHARD_DELAY ; } if ( allhard_pause ) { ( void ) gettimeofday ( & now , NULL ) ; if ( now . tv_sec >= next_allhard . tv_sec ) { allhard_pause = 0 ; __audit_dowarn ( "allhard" , "" , ++ hung_count ) ; } } else { __audit_dowarn ( "allhard" , "" , ++ hung_count ) ; } minfreeblocks = AVAIL_MIN ; rc = AUDITD_RETRY ; * error = strdup ( gettext ( "all partitions full\n" ) ) ; ( void ) __logpost ( "" ) ; } } } ( void ) pthread_mutex_unlock ( & log_mutex ) ; return ( rc ) ; } } 