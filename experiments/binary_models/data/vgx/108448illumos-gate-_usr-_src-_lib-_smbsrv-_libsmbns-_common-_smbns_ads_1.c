smb_ads_status_t smb_ads_join ( char * domain , char * container , char * user , char * usr_passwd , char * machine_passwd ) { smb_ads_handle_t * ah = NULL ; krb5_context ctx = NULL ; krb5_principal * krb5princs = NULL ; krb5_kvno kvno ; boolean_t delete = B_TRUE ; smb_ads_status_t rc ; boolean_t new_acct ; int dclevel , num , usrctl_flags = 0 ; smb_ads_qstat_t qstat ; char dn [ SMB_ADS_DN_MAX ] ; char tmpfile [ ] SMBNS_KRB5_KEYTAB_TMP ; ; int cnt , x ; smb_krb5_pn_set_t spns ; krb5_enctype * encptr ; rc = smb_ads_open_main ( & ah , domain , user , usr_passwd ) ; if ( rc != 0 ) { const char * s = smb_ads_strerror ( rc ) ; syslog ( LOG_ERR , "smb_ads_join: open_main, error %s" , s ) ; smb_ccache_remove ( SMB_CCACHE_PATH , NULL ) ; return ( rc ) ; } if ( ( dclevel = smb_ads_get_dc_level ( ah ) ) == - 1 ) { smb_ads_close ( ah ) ; smb_ccache_remove ( SMB_CCACHE_PATH ) ; return ( SMB_ADJOIN_ERR_GET_DCLEVEL ) ; } qstat = smb_ads_find_computer ( ah , dn ) ; switch ( qstat ) { case SMB_ADS_STAT_FOUND : new_acct = B_FALSE ; syslog ( LOG_INFO , "smb_ads_join: machine account found." " Updating: %s" , dn ) ; if ( smb_ads_modify_computer ( ah , dclevel , dn ) != 0 ) { smb_ads_close ( ah ) ; smb_ccache_remove ( SMB_CCACHE_PATH ) ; return ( SMB_ADJOIN_ERR_MOD_TRUST_ACCT ) ; } break ; case SMB_ADS_STAT_NOT_FOUND : new_acct = B_TRUE ; smb_ads_get_new_comp_dn ( ah , dn , SMB_ADS_DN_MAX , container ) ; syslog ( LOG_INFO , "smb_ads_join: machine account not found." " Creating: %s" , dn ) ; if ( smb_ads_add_computer ( ah , dclevel , dn ) != 0 ) { smb_ads_close ( ah ) ; smb_ccache_remove ( SMB_CCACHE_PATH ) ; return ( SMB_ADJOIN_ERR_ADD_TRUST_ACCT ) ; } break ; default : syslog ( LOG_INFO , "smb_ads_find_computer, rc=%d" , qstat ) ; if ( qstat == SMB_ADS_STAT_DUP ) { rc = SMB_ADJOIN_ERR_DUP_TRUST_ACCT ; } else { rc = SMB_ADJOIN_ERR_TRUST_ACCT ; } smb_ads_close ( ah ) ; smb_ccache_remove ( SMB_CCACHE_PATH ) ; return ( rc ) ; } if ( smb_krb5_ctx_init ( & ctx ) != 0 ) { rc = SMB_ADJOIN_ERR_INIT_KRB_CTX ; adjoin_cleanup } if ( smb_krb5_get_pn_set ( & spns , SMB_PN_KEYTAB_ENTRY , ah -> domain ) == 0 ) { rc = SMB_ADJOIN_ERR_GET_SPNS ; adjoin_cleanup } if ( smb_krb5_get_kprincs ( ctx , spns . s_pns , spns . s_cnt , & krb5princs ) != 0 ) { smb_krb5_free_pn_set ( & spns ) ; rc = SMB_ADJOIN_ERR_GET_SPNS ; adjoin_cleanup } cnt = spns . s_cnt ; smb_krb5_free_pn_set ( & spns ) ; if ( smb_krb5_setpwd ( ctx , ah -> domain , machine_passwd ) != 0 ) { rc = SMB_ADJOIN_ERR_KSETPWD ; adjoin_cleanup } kvno = smb_ads_lookup_computer_attr_kvno ( ah , dn ) ; usrctl_flags = ( SMB_ADS_USER_ACCT_CTL_WKSTATION_TRUST_ACCT | SMB_ADS_USER_ACCT_CTL_TRUSTED_FOR_DELEGATION | SMB_ADS_USER_ACCT_CTL_DONT_EXPIRE_PASSWD ) ; set_ctl_again x = smb_ads_update_computer_cntrl_attr ( ah , usrctl_flags , dn ) ; if ( x != LDAP_SUCCESS && ( usrctl_flags & SMB_ADS_USER_ACCT_CTL_TRUSTED_FOR_DELEGATION ) != 0 ) { syslog ( LOG_NOTICE , "Unable to set the " "TRUSTED_FOR_DELEGATION userAccountControl flag on the " "machine account in Active Directory.  It may be necessary " "to set that via Active Directory administration." ) ; usrctl_flags &= ~ SMB_ADS_USER_ACCT_CTL_TRUSTED_FOR_DELEGATION ; set_ctl_again } if ( x != LDAP_SUCCESS ) { rc = SMB_ADJOIN_ERR_UPDATE_CNTRL_ATTR ; adjoin_cleanup } if ( mktemp ( tmpfile ) == NULL ) { rc = SMB_ADJOIN_ERR_WRITE_KEYTAB ; adjoin_cleanup } encptr = smb_ads_get_enctypes ( dclevel , & num ) ; if ( smb_krb5_kt_populate ( ctx , ah -> domain , krb5princs , cnt , tmpfile , kvno , machine_passwd , encptr , num ) != 0 ) { rc = SMB_ADJOIN_ERR_WRITE_KEYTAB ; adjoin_cleanup } delete = B_FALSE ; rc = SMB_ADS_SUCCESS ; adjoin_cleanup if ( new_acct && delete ) { smb_ads_del_computer ( ah , dn ) ; } if ( rc != SMB_ADJOIN_ERR_INIT_KRB_CTX ) { if ( rc != SMB_ADJOIN_ERR_GET_SPNS ) { smb_krb5_free_kprincs ( ctx , krb5princs , cnt ) ; } smb_krb5_ctx_fini ( ctx ) ; } if ( rc == SMB_ADS_SUCCESS ) { if ( rename ( tmpfile , SMBNS_KRB5_KEYTAB ) != 0 ) { ( void ) unlink ( tmpfile ) ; rc = SMB_ADJOIN_ERR_COMMIT_KEYTAB ; } } else { ( void ) unlink ( tmpfile ) ; } smb_ads_close ( ah ) ; smb_ccache_remove ( SMB_CCACHE_PATH ) ; return ( rc ) ; } 