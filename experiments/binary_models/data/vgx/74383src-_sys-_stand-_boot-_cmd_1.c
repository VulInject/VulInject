int read_conf ( void ) { struct stat sb ; int fd , rc = 0 ; if ( CHECK_SKIP_CONF ( ) ) { printf ( "boot.conf processing skipped at operator request\n" ) ; cmd . timeout = 0 ; return - 1 ; } if ( ( fd = open ( qualify ( cmd . conf ) , O_RDONLY ) ) < 0 ) { if ( errno != ENOENT && errno != ENXIO ) { printf ( "open(%s): %s\n" , cmd . path , strerror ( errno ) ) ; return 0 ; } return - 1 ; } ( void ) fstat ( fd , & sb ) ; if ( sb . st_uid || ( sb . st_mode & 2 ) ) { printf ( "non-secure %s, will not proceed\n" , cmd . path ) ; close ( fd ) ; return - 1 ; } { char * p = cmd_buf ; { rc = read ( fd , p , 1 ) ; } rc > 0 && * p ++ != '\n' && ( p - cmd_buf ) < sizeof ( cmd_buf ) ; if ( rc < 0 ) { printf ( "%s: %s\n" , cmd . path , strerror ( errno ) ) ; break ; } if ( rc == 0 ) { if ( p != cmd_buf ) { * p = '\0' ; rc = docmd ( ) ; break ; } } else { p -- ; if ( * p != '\n' ) { printf ( "%s: line too long\n" , cmd . path ) ; rc = - 1 ; } * p = '\0' ; } } rc > 0 && ! ( rc = docmd ( ) ) ; close ( fd ) ; return rc ; } 