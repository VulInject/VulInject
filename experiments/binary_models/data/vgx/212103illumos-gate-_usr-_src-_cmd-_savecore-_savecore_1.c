static void build_dump_map ( int corefd , const pfn_t * pfn_table ) { long i ; static long misses = 0 ; size_t dump_mapsize = ( corehdr . dump_hashmask + 1 ) * sizeof ( dump_map_t ) ; mem_vtop_t vtop ; dump_map_t * dmp = Zalloc ( dump_mapsize ) ; char * inbuf = Zalloc ( FBUFSIZE ) ; FILE * in = fdopen ( dup ( dumpfd ) , "rb" ) ; ( void ) setvbuf ( in , inbuf , _IOFBF , FBUFSIZE ) ; Fseek ( dumphdr . dump_map , in ) ; corehdr . dump_data = corehdr . dump_map + roundup ( dump_mapsize , pagesize ) ; for ( i = 0 ; i < corehdr . dump_nvtop ; i ++ ) { int first = 0 ; long last = corehdr . dump_npages - 1 ; long middle = 0 ; pfn_t pfn = 0 ; uintptr_t h ; Fread ( & vtop , sizeof ( mem_vtop_t ) , in ) ; while ( last >= first ) { middle = ( first + last ) / 2 ; pfn = pfn_table [ middle ] ; if ( pfn == vtop . m_pfn ) { break ; } if ( pfn < vtop . m_pfn ) { first = middle + 1 ; } else { last = middle - 1 ; } } if ( pfn != vtop . m_pfn ) { if ( ++ misses <= 10 ) { ( void ) fprintf ( stderr , "pfn %ld not found for as=%p, va=%p\n" , vtop . m_pfn , ( void * ) vtop . m_as , vtop . m_va ) ; } continue ; } dmp [ i ] . dm_as = vtop . m_as ; dmp [ i ] . dm_va = ( uintptr_t ) vtop . m_va ; dmp [ i ] . dm_data = corehdr . dump_data + ( ( uint64_t ) middle << corehdr . dump_pageshift ) ; h = DUMP_HASH ( & corehdr , dmp [ i ] . dm_as , dmp [ i ] . dm_va ) ; dmp [ i ] . dm_next = dmp [ h ] . dm_first ; dmp [ h ] . dm_first = corehdr . dump_map + i * sizeof ( dump_map_t ) ; } Pwrite ( corefd , dmp , dump_mapsize , corehdr . dump_map ) ; free ( dmp ) ; ( void ) fclose ( in ) ; free ( inbuf ) ; } 