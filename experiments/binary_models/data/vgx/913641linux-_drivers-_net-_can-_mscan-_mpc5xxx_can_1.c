static u32 mpc512x_can_get_clock ( struct platform_device * ofdev , const char * clock_name , int * mscan_clksrc ) { return 0 ; } static const struct of_device_id mpc5xxx_can_table [ ] ; static int mpc5xxx_can_probe ( struct platform_device * ofdev ) { const struct mpc5xxx_can_data * data ; struct device_node * np = ofdev -> dev . of_node ; struct net_device * dev ; struct mscan_priv * priv ; void __iomem * base ; const char * clock_name = NULL ; int irq , mscan_clksrc = 0 ; int err = - ENOMEM ; data = of_device_get_match_data ( & ofdev -> dev ) ; base = of_iomap ( np , 0 ) ; if ( ! base ) { return dev_err_probe ( & ofdev -> dev , err , "couldn't ioremap\n" ) ; } irq = irq_of_parse_and_map ( np , 0 ) ; if ( ! irq ) { dev_err ( & ofdev -> dev , "no irq found\n" ) ; err = - ENODEV ; exit_unmap_mem } dev = alloc_mscandev ( ) ; if ( ! dev ) { exit_dispose_irq } platform_set_drvdata ( ofdev , dev ) ; SET_NETDEV_DEV ( dev , & ofdev -> dev ) ; priv = netdev_priv ( dev ) ; priv -> reg_base = base ; dev -> irq = irq ; clock_name = of_get_property ( np , "fsl,mscan-clock-source" , NULL ) ; priv -> type = data -> type ; priv -> can . clock . freq = data -> get_clock ( ofdev , clock_name , & mscan_clksrc ) ; if ( ! priv -> can . clock . freq ) { dev_err ( & ofdev -> dev , "couldn't get MSCAN clock properties\n" ) ; exit_put_clock } err = register_mscandev ( dev , mscan_clksrc ) ; if ( err ) { dev_err ( & ofdev -> dev , "registering %s failed (err=%d)\n" , DRV_NAME , err ) ; exit_put_clock } dev_info ( & ofdev -> dev , "MSCAN at 0x%p, irq %d, clock %d Hz\n" , priv -> reg_base , dev -> irq , priv -> can . clock . freq ) ; return 0 ; exit_put_clock if ( data -> put_clock ) { data -> put_clock ( ofdev ) ; } free_candev ( dev ) ; exit_dispose_irq irq_dispose_mapping ( irq ) ; exit_unmap_mem iounmap ( base ) ; return err ; } 