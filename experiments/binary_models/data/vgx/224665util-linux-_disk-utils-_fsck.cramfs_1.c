static void do_directory ( char * path , struct cramfs_inode * i ) { int pathlen = strlen ( path ) ; int count = i -> size ; unsigned long offset = i -> offset << 2 ; char * newpath = xmalloc ( pathlen + 256 ) ; if ( offset == 0 && count != 0 ) { errx ( FSCK_EX_UNCORRECTED , _ ( "directory inode has zero offset and non-zero size: %s" ) , path ) ; } if ( offset != 0 && offset < start_dir ) { start_dir = offset ; } memcpy ( newpath , path , pathlen ) ; newpath [ pathlen ] = '/' ; pathlen ++ ; if ( opt_verbose ) { print_node ( 'd' , i , path ) ; } if ( * extract_dir != '\0' ) { if ( mkdir ( path , i -> mode ) < 0 ) { err ( FSCK_EX_ERROR , _ ( "mkdir failed: %s" ) , path ) ; } change_file_status ( path , i ) ; } while ( count > 0 ) { struct cramfs_inode * child = iget ( offset ) ; char * name ; int size ; int newlen = child -> namelen << 2 ; size = sizeof ( cramfs_inode ) + newlen ; count -= size ; offset += sizeof ( cramfs_inode ) ; name = romfs_read ( offset ) ; if ( memchr ( name , '/' , newlen ) != NULL ) { errx_path ( _ ( "illegal filename" ) , name , newlen ) ; } if ( * extract_dir != '\0' && is_dangerous_filename ( name , newlen ) ) { errx_path ( _ ( "dangerous filename" ) , name , newlen ) ; } memcpy ( newpath + pathlen , name , newlen ) ; newpath [ pathlen + newlen ] = 0 ; if ( newlen == 0 ) { errx ( FSCK_EX_UNCORRECTED , _ ( "filename length is zero" ) ) ; } if ( ( pathlen + newlen ) - strlen ( newpath ) > 3 ) { errx ( FSCK_EX_UNCORRECTED , _ ( "bad filename length" ) ) ; } expand_fs ( newpath , child ) ; offset += newlen ; if ( offset <= start_dir ) { errx ( FSCK_EX_UNCORRECTED , _ ( "bad inode offset" ) ) ; } if ( offset > end_dir ) { end_dir = offset ; } iput ( child ) ; } } 