static void nb8800_tx_done ( struct net_device * dev ) { struct nb8800_priv * priv = netdev_priv ( dev ) ; unsigned int limit = priv -> tx_next ; unsigned int done = priv -> tx_done ; int packets = 0 ; unsigned int len = 0 ; while ( done != limit ) { struct nb8800_tx_desc * txd = & priv -> tx_descs [ done ] ; struct nb8800_tx_buf * txb = & priv -> tx_bufs [ done ] ; struct sk_buff * skb ; if ( ! txd -> report ) { break ; } skb = txb -> skb ; len += skb -> len ; dma_unmap_single ( & dev -> dev , txb -> dma_addr , txb -> dma_len , DMA_TO_DEVICE ) ; if ( IS_TX_ERROR ( txd -> report ) ) { nb8800_tx_error ( dev , txd -> report ) ; kfree_skb ( skb ) ; } else { consume_skb ( skb ) ; } dev -> stats . tx_packets ++ ; dev -> stats . tx_bytes += TX_BYTES_TRANSFERRED ( txd -> report ) ; dev -> stats . collisions += TX_EARLY_COLLISIONS ( txd -> report ) ; txb -> skb = NULL ; txb -> ready = false ; txd -> report = 0 ; done = ( done + 1 ) % TX_DESC_COUNT ; packets ++ ; } if ( packets ) { smp_mb__before_atomic ( ) ; atomic_add ( packets , & priv -> tx_free ) ; netdev_completed_queue ( dev , packets , len ) ; netif_wake_queue ( dev ) ; priv -> tx_done = done ; } } 