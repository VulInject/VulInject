static int _sx_ssl_handshake ( sx_t s , _sx_ssl_conn_t sc ) { int ret , err ; char * errstring ; sx_error_t sxe ; while ( ! SSL_is_init_finished ( sc -> ssl ) ) { _sx_debug ( ZONE , "secure channel not established, handshake in progress" ) ; if ( sc -> last_state == SX_SSL_STATE_WANT_READ && BIO_pending ( sc -> rbio ) == 0 ) { return 0 ; } if ( s -> type == type_CLIENT ) { ret = SSL_connect ( sc -> ssl ) ; } else { ret = SSL_accept ( sc -> ssl ) ; } if ( ret == 1 ) { _sx_debug ( ZONE , "secure channel established" ) ; sc -> last_state = SX_SSL_STATE_NONE ; _sx_debug ( ZONE , "using cipher %s (%d bits)" , SSL_get_cipher_name ( sc -> ssl ) , s -> ssf ) ; _sx_ssl_get_external_id ( s , sc ) ; return 1 ; } if ( ret <= 0 ) { err = SSL_get_error ( sc -> ssl , ret ) ; if ( err == SSL_ERROR_WANT_READ ) { sc -> last_state = SX_SSL_STATE_WANT_READ ; } if ( err == SSL_ERROR_WANT_WRITE ) { sc -> last_state = SX_SSL_STATE_WANT_WRITE ; } else { sc -> last_state = SX_SSL_STATE_ERROR ; errstring = ERR_error_string ( ERR_get_error ( ) , NULL ) ; _sx_debug ( ZONE , "openssl error: %s" , errstring ) ; if ( ! ( s -> state < state_STREAM && s -> flags & SX_SSL_WRAPPER ) ) { _sx_gen_error ( sxe , SX_ERR_SSL , "SSL handshake error" , errstring ) ; _sx_event ( s , event_ERROR , ( void * ) & sxe ) ; sx_error ( s , stream_err_UNDEFINED_CONDITION , errstring ) ; } sx_close ( s ) ; return - 1 ; } } } return 1 ; } 