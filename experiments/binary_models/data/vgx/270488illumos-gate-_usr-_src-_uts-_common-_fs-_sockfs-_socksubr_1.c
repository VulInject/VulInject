ssize_t soreadfile ( file_t * fp , uchar_t * buf , u_offset_t fileoff , int * err , size_t size ) { struct uio auio ; struct iovec aiov [ 1 ] ; register vnode_t * vp ; int ioflag , rwflag ; int cnt ; int error = 0 ; int iovcnt = 0 ; short fflag ; vp = fp -> f_vnode ; fflag = fp -> f_flag ; rwflag = 0 ; aiov [ 0 ] . iov_base = ( caddr_t ) buf ; aiov [ 0 ] . iov_len = size ; iovcnt = 1 ; cnt = ( ssize_t ) size ; ( void ) VOP_RWLOCK ( vp , rwflag , NULL ) ; auio . uio_loffset = fileoff ; auio . uio_iov = aiov ; auio . uio_iovcnt = iovcnt ; auio . uio_resid = cnt ; auio . uio_segflg = UIO_SYSSPACE ; auio . uio_llimit = MAXOFFSET_T ; auio . uio_fmode = fflag ; auio . uio_extflg = UIO_COPY_CACHED ; ioflag = auio . uio_fmode & ( FAPPEND | FSYNC | FDSYNC | FRSYNC ) ; if ( ( ioflag & FRSYNC ) == 0 ) { ioflag &= ~ ( FSYNC | FDSYNC ) ; } error = VOP_READ ( vp , & auio , ioflag , fp -> f_cred , NULL ) ; cnt -= auio . uio_resid ; VOP_RWUNLOCK ( vp , rwflag , NULL ) ; if ( error == EINTR && cnt != 0 ) { error = 0 ; } out if ( error != 0 ) { * err = error ; return ( 0 ) ; } else { * err = 0 ; return ( cnt ) ; } } 