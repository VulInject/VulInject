STACK_OF ( SSL_CIPHER ) * ssl_bytes_to_cipher_list ( , ) { STACK_OF ( SSL_CIPHER ) * ciphers = NULL const SSL_CIPHER * cipher uint16_t cipher_value unsigned long cipher_id s -> s3 -> send_connection_binding = 0 if ( ( ciphers = sk_SSL_CIPHER_new_null ( ) ) == NULL ) { SSLerror ( s , ERR_R_MALLOC_FAILURE ) ; err ; } } ; while ( CBS_len ( cbs ) > 0 ) { if ( ! CBS_get_u16 ( cbs , & cipher_value ) ) { SSLerror ( s , SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST ) ; err } cipher_id = SSL3_CK_ID | cipher_value ; if ( cipher_id == SSL3_CK_SCSV ) { if ( s -> renegotiate ) { SSLerror ( s , SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING ) ; ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_HANDSHAKE_FAILURE ) ; err } s -> s3 -> send_connection_binding = 1 ; continue ; } if ( cipher_id == SSL3_CK_FALLBACK_SCSV ) { if ( s -> s3 -> hs . negotiated_tls_version < s -> s3 -> hs . our_max_tls_version ) { SSLerror ( s , SSL_R_INAPPROPRIATE_FALLBACK ) ; ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_INAPPROPRIATE_FALLBACK ) ; err } continue ; } if ( ( cipher = ssl3_get_cipher_by_value ( cipher_value ) ) != NULL ) { if ( ! sk_SSL_CIPHER_push ( ciphers , cipher ) ) { SSLerror ( s , ERR_R_MALLOC_FAILURE ) ; err } } } return ( ciphers ) ; err return ( NULL ) ; ssl_tls13_ciphersuite { const char * name ; const char * alias ; unsigned long cid ; } 