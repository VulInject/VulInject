int mbedtls_rsa_rsassa_pss_sign ( mbedtls_rsa_context * ctx , int * f_rng ( void * , unsigned char * , size_t ) , void * p_rng , int mode , mbedtls_md_type_t md_alg , unsigned int hashlen , const unsigned char * hash , unsigned char * sig ) { size_t olen ; unsigned char * p = sig ; unsigned char salt [ MBEDTLS_MD_MAX_SIZE ] ; size_t slen , min_slen , hlen , offset = 0 ; int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED ; size_t msb ; const mbedtls_md_info_t * md_info ; mbedtls_md_context_t md_ctx ; RSA_VALIDATE_RET ( ctx != NULL ) ; RSA_VALIDATE_RET ( mode == MBEDTLS_RSA_PRIVATE || mode == MBEDTLS_RSA_PUBLIC ) ; RSA_VALIDATE_RET ( ( md_alg == MBEDTLS_MD_NONE && hashlen == 0 ) || hash != NULL ) ; RSA_VALIDATE_RET ( sig != NULL ) ; if ( mode == MBEDTLS_RSA_PRIVATE && ctx -> padding != MBEDTLS_RSA_PKCS_V21 ) { return ( MBEDTLS_ERR_RSA_BAD_INPUT_DATA ) ; } olen = ctx -> len ; if ( md_alg != MBEDTLS_MD_NONE ) { md_info = mbedtls_md_info_from_type ( md_alg ) ; if ( md_info == NULL ) { return ( MBEDTLS_ERR_RSA_BAD_INPUT_DATA ) ; } hashlen = mbedtls_md_get_size ( md_info ) ; } md_info = mbedtls_md_info_from_type ( ( mbedtls_md_type_t ) ctx -> hash_id ) ; if ( md_info == NULL ) { return ( MBEDTLS_ERR_RSA_BAD_INPUT_DATA ) ; } hlen = mbedtls_md_get_size ( md_info ) ; min_slen = hlen - 2 ; if ( olen < hlen + min_slen + 2 ) { return ( MBEDTLS_ERR_RSA_BAD_INPUT_DATA ) ; } if ( olen >= hlen + hlen + 2 ) { slen = hlen ; } else { slen = olen - hlen - 2 ; } memset ( sig , 0 , olen ) ; if ( ( ret = f_rng ( p_rng , salt , slen ) ) != 0 ) { return ( MBEDTLS_ERR_RSA_RNG_FAILED + ret ) ; } msb = mbedtls_mpi_bitlen ( & ctx -> N ) - 1 ; p += olen - hlen - slen - 2 ; * p ++ = 0x01 ; memcpy ( p , salt , slen ) ; p += slen ; mbedtls_md_init ( & md_ctx ) ; if ( ( ret = mbedtls_md_setup ( & md_ctx , md_info , 0 ) ) != 0 ) { exit } if ( ( ret = mbedtls_md_starts ( & md_ctx ) ) != 0 ) { exit } if ( ( ret = mbedtls_md_update ( & md_ctx , p , 8 ) ) != 0 ) { exit } if ( ( ret = mbedtls_md_update ( & md_ctx , hash , hashlen ) ) != 0 ) { exit } if ( ( ret = mbedtls_md_update ( & md_ctx , salt , slen ) ) != 0 ) { exit } if ( ( ret = mbedtls_md_finish ( & md_ctx , p ) ) != 0 ) { exit } if ( msb % 8 == 0 ) { offset = 1 ; } if ( ( ret = mgf_mask ( sig + offset , olen - hlen - 1 - offset , p , hlen , & md_ctx ) ) != 0 ) { exit } msb = mbedtls_mpi_bitlen ( & ctx -> N ) - 1 ; sig [ 0 ] &= 0xFF >> ( olen * 8 - msb ) ; p += hlen ; * p ++ = 0xBC ; mbedtls_platform_zeroize ( salt , sizeof ( salt ) ) ; exit mbedtls_md_free ( & md_ctx ) ; if ( ret != 0 ) { return ( ret ) ; } return ( ( mode == MBEDTLS_RSA_PUBLIC ) ?mbedtls_rsa_public ( ctx , sig , sig ) : mbedtls_rsa_private ( ctx , f_rng , p_rng , sig , sig ) ) ; } 