static bool tls_process ( struct tls_multi * multi , struct tls_session * session , struct buffer * to_link , struct link_socket_actual * * to_link_addr , struct link_socket_info * to_link_socket_info , interval_t * wakeup ) { struct key_state * ks = & session -> key [ KS_PRIMARY ] ; struct key_state * ks_lame = & session -> key [ KS_LAME_DUCK ] ; ASSERT ( ks -> state != S_UNDEF ) ; ASSERT ( ks -> state != S_ERROR ) ; ASSERT ( session_id_defined ( & session -> session_id ) ) ; if ( ks -> state >= S_GENERATED_KEYS && ( ( session -> opt -> renegotiate_seconds && now >= ks -> established + session -> opt -> renegotiate_seconds ) || ( session -> opt -> renegotiate_bytes > 0 && ks -> n_bytes >= session -> opt -> renegotiate_bytes ) || ( session -> opt -> renegotiate_packets && ks -> n_packets >= session -> opt -> renegotiate_packets ) || ( packet_id_close_to_wrapping ( & ks -> crypto_options . packet_id . send ) ) ) ) { msg ( D_TLS_DEBUG_LOW , "TLS: soft reset sec=%d/%d bytes=" counter_format "/%d pkts=" counter_format "/%d" , ( int ) ( now - ks -> established ) , session -> opt -> renegotiate_seconds , ks -> n_bytes , session -> opt -> renegotiate_bytes , ks -> n_packets , session -> opt -> renegotiate_packets ) ; key_state_soft_reset ( session ) ; } if ( lame_duck_must_die ( session , wakeup ) ) { key_state_free ( ks_lame , true ) ; msg ( D_TLS_DEBUG_LOW , "TLS: tls_process: killed expiring key" ) ; } bool state_change = true ; while ( state_change ) { update_time ( ) ; dmsg ( D_TLS_DEBUG , "TLS: tls_process: chg=%d ks=%s lame=%s to_link->len=%d wakeup=%d" , state_change , state_name ( ks -> state ) , state_name ( ks_lame -> state ) , to_link -> len , * wakeup ) ; state_change = tls_process_state ( multi , session , to_link , to_link_addr , to_link_socket_info , wakeup ) ; if ( ks -> state == S_ERROR ) { return false ; } } update_time ( ) ; if ( ! to_link -> len && ! reliable_ack_empty ( ks -> rec_ack ) ) { if ( control_packet_needs_wkc ( ks ) ) { struct buffer * buf = reliable_get_buf_output_sequenced ( ks -> send_reliable ) ; reliable_mark_active_outgoing ( ks -> send_reliable , buf , P_CONTROL_WKC_V1 ) ; } else { struct buffer buf = ks -> ack_write_buf ; ASSERT ( buf_init ( & buf , multi -> opt . frame . buf . headroom ) ) ; write_control_auth ( session , ks , & buf , to_link_addr , P_ACK_V1 , RELIABLE_ACK_SIZE , false ) ; * to_link = buf ; dmsg ( D_TLS_DEBUG , "Dedicated ACK ->TCP/UDP" ) ; } } if ( ks -> state >= S_INITIAL ) { compute_earliest_wakeup ( wakeup , reliable_send_timeout ( ks -> send_reliable ) ) ; if ( ks -> must_negotiate ) { compute_earliest_wakeup ( wakeup , ks -> must_negotiate - now ) ; } } if ( ks -> established && session -> opt -> renegotiate_seconds ) { compute_earliest_wakeup ( wakeup , ks -> established + session -> opt -> renegotiate_seconds - now ) ; } dmsg ( D_TLS_DEBUG , "TLS: tls_process: timeout set to %d" , * wakeup ) ; if ( * wakeup <= 0 ) { * wakeup = 1 ; return true ; } if ( to_link -> len ) { return true ; } return false ; } 