int get_scsi_vhci_pathinfo ( char * dev_path , sv_iocdata_t * ioc , int * path_count ) { char * physical_path , * physical_path_s ; int retval ; int fd ; int initial_path_count ; int current_path_count ; int i ; char * delimiter ; int malloc_error = 0 ; int prop_buf_size ; int pathlist_retry_count = 0 ; if ( strncmp ( dev_path , SCSI_VHCI , strlen ( SCSI_VHCI ) ) != 0 ) { if ( ( physical_path = get_slash_devices_from_osDevName ( dev_path , STANDARD_DEVNAME_HANDLING ) ) == NULL ) { return ( L_INVALID_PATH ) ; } if ( strncmp ( physical_path , SCSI_VHCI , strlen ( SCSI_VHCI ) ) != 0 ) { return ( L_INVALID_PATH ) ; } } else { if ( ( physical_path = calloc ( 1 , MAXPATHLEN ) ) == NULL ) { return ( L_MALLOC_FAILED ) ; } ( void ) strcpy ( physical_path , dev_path ) ; } physical_path_s = physical_path ; physical_path += DEV_PREFIX_STRLEN - 1 ; delimiter = strrchr ( physical_path , ':' ) ; if ( delimiter != NULL ) { * delimiter = '\0' ; } ( void ) strcpy ( ioc -> client , physical_path ) ; ioc -> buf_elem = 1 ; ioc -> ret_elem = ( uint_t * ) & ( initial_path_count ) ; ioc -> ret_buf = NULL ; free ( physical_path_s ) ; if ( ( fd = open ( "/devices/scsi_vhci:devctl" , O_RDWR ) ) < 0 ) { return ( L_OPEN_PATH_FAIL ) ; } retval = ioctl ( fd , SCSI_VHCI_GET_CLIENT_MULTIPATH_INFO , ioc ) ; if ( retval != 0 ) { close ( fd ) ; return ( L_SCSI_VHCI_ERROR ) ; } prop_buf_size = SV_PROP_MAX_BUF_SIZE ; while ( pathlist_retry_count <= RETRY_PATHLIST ) { ioc -> buf_elem = initial_path_count ; ioc -> ret_elem = ( uint_t * ) & ( current_path_count ) ; ioc -> ret_buf = ( sv_path_info_t * ) calloc ( initial_path_count , sizeof ( sv_path_info_t ) ) ; if ( ioc -> ret_buf == NULL ) { close ( fd ) ; return ( L_MALLOC_FAILED ) ; } malloc_error = 0 ; for ( i = 0 ; i < initial_path_count ; i ++ ) { ioc -> ret_buf [ i ] . ret_prop . buf_size = prop_buf_size ; if ( ( ioc -> ret_buf [ i ] . ret_prop . buf = ( caddr_t ) malloc ( prop_buf_size ) ) == NULL ) { malloc_error = 1 ; break ; } if ( ( ioc -> ret_buf [ i ] . ret_prop . ret_buf_size = ( uint_t * ) malloc ( sizeof ( uint_t ) ) ) == NULL ) { malloc_error = 1 ; break ; } } if ( malloc_error == 1 ) { for ( i = 0 ; i < initial_path_count ; i ++ ) { free ( ioc -> ret_buf [ i ] . ret_prop . buf ) ; free ( ioc -> ret_buf [ i ] . ret_prop . ret_buf_size ) ; } free ( ioc -> ret_buf ) ; close ( fd ) ; return ( L_MALLOC_FAILED ) ; } retval = ioctl ( fd , SCSI_VHCI_GET_CLIENT_MULTIPATH_INFO , ioc ) ; if ( retval != 0 ) { for ( i = 0 ; i < initial_path_count ; i ++ ) { free ( ioc -> ret_buf [ i ] . ret_prop . buf ) ; free ( ioc -> ret_buf [ i ] . ret_prop . ret_buf_size ) ; } free ( ioc -> ret_buf ) ; close ( fd ) ; return ( L_SCSI_VHCI_ERROR ) ; } if ( initial_path_count < current_path_count ) { pathlist_retry_count ++ ; initial_path_count = current_path_count ; } else { break ; } } close ( fd ) ; if ( initial_path_count < current_path_count ) { * path_count = initial_path_count ; } else { * path_count = current_path_count ; } return ( 0 ) ; } 