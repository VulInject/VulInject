int smc_clc_send_decline ( struct smc_sock * smc , u32 peer_diag_info , u8 version ) { struct smc_clc_msg_decline * dclc_v1 ; struct smc_clc_msg_decline_v2 dclc ; struct msghdr msg ; int len , send_len ; struct kvec vec ; dclc_v1 = ( smc_clc_msg_decline * ) & dclc ; memcpy ( dclc . hdr . eyecatcher , SMC_EYECATCHER , sizeof ( SMC_EYECATCHER ) ) ; dclc . hdr . type = SMC_CLC_DECLINE ; dclc . hdr . version = version ; dclc . os_type = version == SMC_V1 ?0 : SMC_CLC_OS_LINUX ; dclc . hdr . typev2 = ( peer_diag_info == SMC_CLC_DECL_SYNCERR ) ?SMC_FIRST_CONTACT_MASK : 0 ; if ( ( ! smc_conn_lgr_valid ( & smc -> conn ) || ! smc -> conn . lgr -> is_smcd ) && smc_ib_is_valid_local_systemid ( ) ) { memcpy ( dclc . id_for_peer , local_systemid , sizeof ( local_systemid ) ) ; } dclc . peer_diagnosis = htonl ( peer_diag_info ) ; if ( version == SMC_V1 ) { memcpy ( dclc_v1 -> trl . eyecatcher , SMC_EYECATCHER , sizeof ( SMC_EYECATCHER ) ) ; send_len = sizeof ( * dclc_v1 ) ; } else { memcpy ( dclc . trl . eyecatcher , SMC_EYECATCHER , sizeof ( SMC_EYECATCHER ) ) ; send_len = sizeof ( dclc ) ; } dclc . hdr . length = htons ( send_len ) ; memset ( & msg , 0 , sizeof ( msg ) ) ; vec . iov_base = & dclc ; vec . iov_len = send_len ; len = kernel_sendmsg ( smc -> clcsock , & msg , & vec , 1 , send_len ) ; if ( len < 0 || len < send_len ) { len = - EPROTO ; } return len > 0 ?0 : len ; } 