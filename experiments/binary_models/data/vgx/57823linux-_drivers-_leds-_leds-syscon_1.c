static int syscon_led_probe ( struct platform_device * pdev ) { struct led_init_data init_data = { } ; struct device * dev = & pdev -> dev ; struct device_node * np = dev_of_node ( dev ) ; struct device * parent ; struct regmap * map ; struct syscon_led * sled ; enum led_default_state state ; u32 value ; int ret ; parent = dev -> parent ; if ( ! parent ) { dev_err ( dev , "no parent for syscon LED\n" ) ; return - ENODEV ; } map = syscon_node_to_regmap ( dev_of_node ( parent ) ) ; if ( IS_ERR ( map ) ) { dev_err ( dev , "no regmap for syscon LED parent\n" ) ; return PTR_ERR ( map ) ; } sled = devm_kzalloc ( dev , sizeof ( * sled ) , GFP_KERNEL ) ; sled -> map = map ; if ( of_property_read_u32 ( np , "offset" , & sled -> offset ) ) { return - EINVAL ; } if ( of_property_read_u32 ( np , "mask" , & sled -> mask ) ) { return - EINVAL ; } init_data . fwnode = of_fwnode_handle ( np ) ; state = led_init_default_state_get ( init_data . fwnode ) ; switch ( state ) { case LEDS_DEFSTATE_ON : ret = regmap_update_bits ( map , sled -> offset , sled -> mask , sled -> mask ) ; if ( ret < 0 ) { return ret ; } sled -> state = true ; break ; case LEDS_DEFSTATE_KEEP : ret = regmap_read ( map , sled -> offset , & value ) ; if ( ret < 0 ) { return ret ; } sled -> state = ! ! ( value & sled -> mask ) ; break ; default : ret = regmap_update_bits ( map , sled -> offset , sled -> mask , 0 ) ; if ( ret < 0 ) { return ret ; } sled -> state = false ; } sled -> cdev . brightness_set = syscon_led_set ; ret = devm_led_classdev_register_ext ( dev , & sled -> cdev , & init_data ) ; if ( ret < 0 ) { return ret ; } platform_set_drvdata ( pdev , sled ) ; dev_info ( dev , "registered LED %s\n" , sled -> cdev . name ) ; return 0 ; } 