int event_reinit ( struct event_base * base ) { const struct eventop * evsel ; int res = 0 ; int was_notifiable = 0 ; int had_signal_added = 0 ; EVBASE_ACQUIRE_LOCK ( base , th_base_lock ) ; evsel = base -> evsel ; if ( evsel -> need_reinit ) { base -> evsel = & nil_eventop ; } if ( base -> sig . ev_signal_added ) { event_del_nolock_ ( & base -> sig . ev_signal , EVENT_DEL_AUTOBLOCK ) ; event_debug_unassign ( & base -> sig . ev_signal ) ; if ( base -> sig . ev_signal_pair [ 0 ] != - 1 ) { EVUTIL_CLOSESOCKET ( base -> sig . ev_signal_pair [ 0 ] ) ; } if ( base -> sig . ev_signal_pair [ 1 ] != - 1 ) { EVUTIL_CLOSESOCKET ( base -> sig . ev_signal_pair [ 1 ] ) ; } had_signal_added = 1 ; base -> sig . ev_signal_added = 0 ; } if ( base -> th_notify_fn != NULL ) { was_notifiable = 1 ; base -> th_notify_fn = NULL ; } if ( base -> th_notify_fd [ 0 ] != - 1 ) { event_del_nolock_ ( & base -> th_notify , EVENT_DEL_AUTOBLOCK ) ; EVUTIL_CLOSESOCKET ( base -> th_notify_fd [ 0 ] ) ; if ( base -> th_notify_fd [ 1 ] != - 1 ) { EVUTIL_CLOSESOCKET ( base -> th_notify_fd [ 1 ] ) ; } base -> th_notify_fd [ 0 ] = - 1 ; base -> th_notify_fd [ 1 ] = - 1 ; event_debug_unassign ( & base -> th_notify ) ; } base -> evsel = evsel ; if ( evsel -> need_reinit ) { if ( base -> evsel -> dealloc != NULL ) { base -> evsel -> dealloc ( base ) ; } base -> evbase = evsel -> init ( base ) ; if ( base -> evbase == NULL ) { event_errx ( 1 , "%s: could not reinitialize event mechanism" , __func__ ) ; res = - 1 ; done } event_changelist_freemem_ ( & base -> changelist ) ; if ( evmap_reinit_ ( base ) < 0 ) { res = - 1 ; } } else { if ( had_signal_added ) { res = evsig_init_ ( base ) ; } } if ( was_notifiable && res == 0 ) { res = evthread_make_base_notifiable_nolock_ ( base ) ; } done EVBASE_RELEASE_LOCK ( base , th_base_lock ) ; return ( res ) ; } 