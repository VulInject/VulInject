int wilc_wlan_txq_add_net_pkt ( struct net_device * dev , struct tx_complete_data * tx_data , u8 * buffer , u32 buffer_size , void * tx_complete_fn ( void * , int ) ) { struct txq_entry_t * tqe ; struct wilc_vif * vif = netdev_priv ( dev ) ; struct wilc * wilc ; u8 q_num ; wilc = vif -> wilc ; if ( wilc -> quit ) { tx_complete_fn ( tx_data , 0 ) ; return 0 ; } if ( ! wilc -> initialized ) { tx_complete_fn ( tx_data , 0 ) ; return 0 ; } tqe = kmalloc ( sizeof ( * tqe ) , GFP_ATOMIC ) ; if ( ! tqe ) { tx_complete_fn ( tx_data , 0 ) ; return 0 ; } tqe -> type = WILC_NET_PKT ; tqe -> buffer = buffer ; tqe -> buffer_size = buffer_size ; tqe -> tx_complete_func = tx_complete_fn ; tqe -> priv = tx_data ; tqe -> vif = vif ; q_num = ac_classify ( wilc , tx_data -> skb ) ; tqe -> q_num = q_num ; if ( ac_change ( wilc , & q_num ) ) { tx_complete_fn ( tx_data , 0 ) ; return 0 ; } if ( is_ac_q_limit ( wilc , q_num ) ) { tqe -> ack_idx = NOT_TCP_ACK ; if ( vif -> ack_filter . enabled ) { tcp_process ( dev , tqe ) ; } wilc_wlan_txq_add_to_tail ( dev , q_num , tqe ) ; } else { tx_complete_fn ( tx_data , 0 ) ; kfree ( tqe ) ; } return wilc -> txq_entries ; } 