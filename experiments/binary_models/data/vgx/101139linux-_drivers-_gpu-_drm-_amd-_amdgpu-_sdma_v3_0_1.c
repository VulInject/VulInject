static int sdma_v3_0_gfx_resume ( struct amdgpu_device * adev ) { struct amdgpu_ring * ring ; u32 rb_cntl , ib_cntl , wptr_poll_cntl ; u32 rb_bufsz ; u32 doorbell ; int wptr_gpu_addr ; int i , j , r ; for ( i = 0 ; i < adev -> sdma . num_instances ; i ++ ) { ring = & adev -> sdma . instance [ i ] . ring ; amdgpu_ring_clear_ring ( ring ) ; mutex_lock ( & adev -> srbm_mutex ) ; for ( j = 0 ; j < 16 ; j ++ ) { vi_srbm_select ( adev , 0 , 0 , 0 , j ) ; WREG32 ( mmSDMA0_GFX_VIRTUAL_ADDR + sdma_offsets [ i ] , 0 ) ; WREG32 ( mmSDMA0_GFX_APE1_CNTL + sdma_offsets [ i ] , 0 ) ; } vi_srbm_select ( adev , 0 , 0 , 0 , 0 ) ; mutex_unlock ( & adev -> srbm_mutex ) ; WREG32 ( mmSDMA0_TILING_CONFIG + sdma_offsets [ i ] , adev -> gfx . config . gb_addr_config & 0x70 ) ; WREG32 ( mmSDMA0_SEM_WAIT_FAIL_TIMER_CNTL + sdma_offsets [ i ] , 0 ) ; rb_bufsz = order_base_2 ( ring -> ring_size / 4 ) ; rb_cntl = RREG32 ( mmSDMA0_GFX_RB_CNTL + sdma_offsets [ i ] ) ; rb_cntl = REG_SET_FIELD ( rb_cntl , SDMA0_GFX_RB_CNTL , RB_SIZE , rb_bufsz ) ; rb_cntl = REG_SET_FIELD ( rb_cntl , SDMA0_GFX_RB_CNTL , RB_SWAP_ENABLE , 1 ) ; rb_cntl = REG_SET_FIELD ( rb_cntl , SDMA0_GFX_RB_CNTL , RPTR_WRITEBACK_SWAP_ENABLE , 1 ) ; WREG32 ( mmSDMA0_GFX_RB_CNTL + sdma_offsets [ i ] , rb_cntl ) ; ring -> wptr = 0 ; WREG32 ( mmSDMA0_GFX_RB_RPTR + sdma_offsets [ i ] , 0 ) ; sdma_v3_0_ring_set_wptr ( ring ) ; WREG32 ( mmSDMA0_GFX_IB_RPTR + sdma_offsets [ i ] , 0 ) ; WREG32 ( mmSDMA0_GFX_IB_OFFSET + sdma_offsets [ i ] , 0 ) ; WREG32 ( mmSDMA0_GFX_RB_RPTR_ADDR_HI + sdma_offsets [ i ] , upper_32_bits ( ring -> rptr_gpu_addr ) & 0xFFFFFFFF ) ; WREG32 ( mmSDMA0_GFX_RB_RPTR_ADDR_LO + sdma_offsets [ i ] , lower_32_bits ( ring -> rptr_gpu_addr ) & 0xFFFFFFFC ) ; rb_cntl = REG_SET_FIELD ( rb_cntl , SDMA0_GFX_RB_CNTL , RPTR_WRITEBACK_ENABLE , 1 ) ; WREG32 ( mmSDMA0_GFX_RB_BASE + sdma_offsets [ i ] , ring -> gpu_addr >> 8 ) ; WREG32 ( mmSDMA0_GFX_RB_BASE_HI + sdma_offsets [ i ] , ring -> gpu_addr >> 40 ) ; doorbell = RREG32 ( mmSDMA0_GFX_DOORBELL + sdma_offsets [ i ] ) ; if ( ring -> use_doorbell ) { doorbell = REG_SET_FIELD ( doorbell , SDMA0_GFX_DOORBELL , OFFSET , ring -> doorbell_index ) ; doorbell = REG_SET_FIELD ( doorbell , SDMA0_GFX_DOORBELL , ENABLE , 1 ) ; } else { doorbell = REG_SET_FIELD ( doorbell , SDMA0_GFX_DOORBELL , ENABLE , 0 ) ; } WREG32 ( mmSDMA0_GFX_DOORBELL + sdma_offsets [ i ] , doorbell ) ; wptr_gpu_addr = ring -> wptr_gpu_addr ; WREG32 ( mmSDMA0_GFX_RB_WPTR_POLL_ADDR_LO + sdma_offsets [ i ] , lower_32_bits ( wptr_gpu_addr ) ) ; WREG32 ( mmSDMA0_GFX_RB_WPTR_POLL_ADDR_HI + sdma_offsets [ i ] , upper_32_bits ( wptr_gpu_addr ) ) ; wptr_poll_cntl = RREG32 ( mmSDMA0_GFX_RB_WPTR_POLL_CNTL + sdma_offsets [ i ] ) ; if ( ring -> use_pollmem ) { WREG32 ( mmSDMA0_GFX_RB_WPTR + sdma_offsets [ i ] , 0 ) ; wptr_poll_cntl = REG_SET_FIELD ( wptr_poll_cntl , SDMA0_GFX_RB_WPTR_POLL_CNTL , ENABLE , 1 ) ; } else { wptr_poll_cntl = REG_SET_FIELD ( wptr_poll_cntl , SDMA0_GFX_RB_WPTR_POLL_CNTL , ENABLE , 0 ) ; } WREG32 ( mmSDMA0_GFX_RB_WPTR_POLL_CNTL + sdma_offsets [ i ] , wptr_poll_cntl ) ; rb_cntl = REG_SET_FIELD ( rb_cntl , SDMA0_GFX_RB_CNTL , RB_ENABLE , 1 ) ; WREG32 ( mmSDMA0_GFX_RB_CNTL + sdma_offsets [ i ] , rb_cntl ) ; ib_cntl = RREG32 ( mmSDMA0_GFX_IB_CNTL + sdma_offsets [ i ] ) ; ib_cntl = REG_SET_FIELD ( ib_cntl , SDMA0_GFX_IB_CNTL , IB_ENABLE , 1 ) ; ib_cntl = REG_SET_FIELD ( ib_cntl , SDMA0_GFX_IB_CNTL , IB_SWAP_ENABLE , 1 ) ; WREG32 ( mmSDMA0_GFX_IB_CNTL + sdma_offsets [ i ] , ib_cntl ) ; ring -> sched . ready = true ; } sdma_v3_0_enable ( adev , true ) ; sdma_v3_0_ctx_switch_enable ( adev , true ) ; for ( i = 0 ; i < adev -> sdma . num_instances ; i ++ ) { ring = & adev -> sdma . instance [ i ] . ring ; r = amdgpu_ring_test_helper ( ring ) ; if ( r ) { return r ; } if ( adev -> mman . buffer_funcs_ring == ring ) { amdgpu_ttm_set_buffer_funcs_status ( adev , true ) ; } } return 0 ; } 