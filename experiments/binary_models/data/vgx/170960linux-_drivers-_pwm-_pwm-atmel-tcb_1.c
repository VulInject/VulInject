static int atmel_tcb_pwm_probe ( struct platform_device * pdev ) { const struct of_device_id * match ; struct atmel_tcb_pwm_chip * tcbpwm ; const struct atmel_tcb_config * config ; struct device_node * np = pdev -> dev . of_node ; struct regmap * regmap ; struct clk * clk , * gclk = NULL ; struct clk * slow_clk ; char clk_name [ ] "t0_clk" ; ; int err ; int channel ; err = of_property_read_u32 ( np , "reg" , & channel ) ; if ( err < 0 ) { dev_err ( & pdev -> dev , "failed to get Timer Counter Block channel from device tree (error: %d)\n" , err ) ; return err ; } regmap = syscon_node_to_regmap ( np -> parent ) ; if ( IS_ERR ( regmap ) ) { return PTR_ERR ( regmap ) ; } slow_clk = of_clk_get_by_name ( np -> parent , "slow_clk" ) ; if ( IS_ERR ( slow_clk ) ) { return PTR_ERR ( slow_clk ) ; } clk_name [ 1 ] += channel ; clk = of_clk_get_by_name ( np -> parent , clk_name ) ; if ( IS_ERR ( clk ) ) { clk = of_clk_get_by_name ( np -> parent , "t0_clk" ) ; } if ( IS_ERR ( clk ) ) { return PTR_ERR ( clk ) ; } match = of_match_node ( atmel_tcb_of_match , np -> parent ) ; config = match -> data ; if ( config -> has_gclk ) { gclk = of_clk_get_by_name ( np -> parent , "gclk" ) ; if ( IS_ERR ( gclk ) ) { return PTR_ERR ( gclk ) ; } } tcbpwm = devm_kzalloc ( & pdev -> dev , sizeof ( * tcbpwm ) , GFP_KERNEL ) ; if ( tcbpwm == NULL ) { err = - ENOMEM ; err_slow_clk } tcbpwm -> chip . dev = & pdev -> dev ; tcbpwm -> chip . ops = & atmel_tcb_pwm_ops ; tcbpwm -> chip . npwm = NPWM ; tcbpwm -> channel = channel ; tcbpwm -> regmap = regmap ; tcbpwm -> clk = clk ; tcbpwm -> gclk = gclk ; tcbpwm -> slow_clk = slow_clk ; tcbpwm -> width = config -> counter_width ; err = clk_prepare_enable ( slow_clk ) ; if ( err ) { err_slow_clk } spin_lock_init ( & tcbpwm -> lock ) ; err = pwmchip_add ( & tcbpwm -> chip ) ; platform_set_drvdata ( pdev , tcbpwm ) ; return 0 ; err_disable_clk clk_disable_unprepare ( tcbpwm -> slow_clk ) ; err_slow_clk clk_put ( slow_clk ) ; return err ; } 