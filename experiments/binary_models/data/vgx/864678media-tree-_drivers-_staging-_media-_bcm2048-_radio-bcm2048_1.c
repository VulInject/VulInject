static int bcm2048_i2c_driver_probe ( struct i2c_client * client , const struct i2c_device_id * id ) { struct bcm2048_device * bdev ; int err ; bdev = kzalloc ( sizeof ( * bdev ) , GFP_KERNEL ) ; if ( ! bdev ) { err = - ENOMEM ; exit } bdev -> client = client ; i2c_set_clientdata ( client , bdev ) ; init_completion ( & bdev -> compl ) ; INIT_WORK ( & bdev -> work , bcm2048_work ) ; if ( client -> irq ) { err = request_irq ( client -> irq , bcm2048_handler , IRQF_TRIGGER_FALLING , client -> name , bdev ) ; if ( err < 0 ) { dev_err ( & client -> dev , "Could not request IRQ\n" ) ; free_bdev } dev_dbg ( & client -> dev , "IRQ requested.\n" ) ; } else { dev_dbg ( & client -> dev , "IRQ not configured. Using timeouts.\n" ) ; } bdev -> videodev = bcm2048_viddev_template ; video_set_drvdata ( & bdev -> videodev , bdev ) ; if ( video_register_device ( & bdev -> videodev , VFL_TYPE_RADIO , radio_nr ) ) { dev_dbg ( & client -> dev , "Could not register video device.\n" ) ; err = - EIO ; free_irq } err = bcm2048_sysfs_register_properties ( bdev ) ; if ( err < 0 ) { dev_dbg ( & client -> dev , "Could not register sysfs interface.\n" ) ; free_registration } err = bcm2048_probe ( bdev ) ; if ( err < 0 ) { dev_dbg ( & client -> dev , "Failed to probe device information.\n" ) ; free_sysfs } return 0 ; free_sysfs bcm2048_sysfs_unregister_properties ( bdev , ARRAY_SIZE ( attrs ) ) ; free_registration video_unregister_device ( & bdev -> videodev ) ; free_irq if ( client -> irq ) { free_irq ( client -> irq , bdev ) ; } free_bdev i2c_set_clientdata ( client , NULL ) ; kfree ( bdev ) ; exit return err ; } 