static void ieee80211_set_disassoc ( struct ieee80211_sub_if_data * sdata , u16 stype , u16 reason , bool tx , u8 * frame_buf ) { struct ieee80211_if_managed * ifmgd = & sdata -> u . mgd ; struct ieee80211_local * local = sdata -> local ; unsigned int link_id ; u32 changed = 0 ; struct ieee80211_prep_tx_info info = { . subtype = stype } ; sdata_assert_lock ( sdata ) ; if ( WARN_ON_ONCE ( tx && ! frame_buf ) ) { return ; } if ( WARN_ON ( ! ifmgd -> associated ) ) { return ; } ieee80211_stop_poll ( sdata ) ; ifmgd -> associated = false ; sdata -> deflink . u . mgd . bss = NULL ; netif_carrier_off ( sdata -> dev ) ; if ( local -> hw . conf . flags & IEEE80211_CONF_PS ) { local -> hw . conf . flags &= ~ IEEE80211_CONF_PS ; ieee80211_hw_config ( local , IEEE80211_CONF_CHANGE_PS ) ; } local -> ps_sdata = NULL ; ieee80211_recalc_ps_vif ( sdata ) ; synchronize_net ( ) ; if ( tx ) { ieee80211_flush_queues ( local , sdata , true ) ; } if ( tx || frame_buf ) { if ( ieee80211_hw_check ( & local -> hw , DEAUTH_NEED_MGD_TX_PREP ) && ! sdata -> deflink . u . mgd . have_beacon ) { drv_mgd_prepare_tx ( sdata -> local , sdata , & info ) ; } ieee80211_send_deauth_disassoc ( sdata , sdata -> vif . cfg . ap_addr , sdata -> vif . cfg . ap_addr , stype , reason , tx , frame_buf ) ; } if ( tx ) { ieee80211_flush_queues ( local , sdata , false ) ; } drv_mgd_complete_tx ( sdata -> local , sdata , & info ) ; eth_zero_addr ( sdata -> deflink . u . mgd . bssid ) ; eth_zero_addr ( sdata -> vif . cfg . ap_addr ) ; sdata -> vif . cfg . ssid_len = 0 ; sta_info_flush ( sdata ) ; if ( ! sdata -> vif . valid_links ) { changed |= ieee80211_reset_erp_info ( sdata ) ; } ieee80211_led_assoc ( local , 0 ) ; changed |= BSS_CHANGED_ASSOC ; sdata -> vif . cfg . assoc = false ; sdata -> deflink . u . mgd . p2p_noa_index = - 1 ; memset ( & sdata -> vif . bss_conf . p2p_noa_attr , 0 , sizeof ( sdata -> vif . bss_conf . p2p_noa_attr ) ) ; memset ( & ifmgd -> ht_capa_mask , 0 , sizeof ( ifmgd -> ht_capa_mask ) ) ; memset ( & ifmgd -> vht_capa , 0 , sizeof ( ifmgd -> vht_capa ) ) ; memset ( & ifmgd -> vht_capa_mask , 0 , sizeof ( ifmgd -> vht_capa_mask ) ) ; memset ( sdata -> vif . bss_conf . mu_group . membership , 0 , sizeof ( sdata -> vif . bss_conf . mu_group . membership ) ) ; memset ( sdata -> vif . bss_conf . mu_group . position , 0 , sizeof ( sdata -> vif . bss_conf . mu_group . position ) ) ; if ( ! sdata -> vif . valid_links ) { changed |= BSS_CHANGED_MU_GROUPS ; } sdata -> vif . bss_conf . mu_mimo_owner = false ; sdata -> deflink . ap_power_level = IEEE80211_UNSET_POWER_LEVEL ; del_timer_sync ( & local -> dynamic_ps_timer ) ; cancel_work_sync ( & local -> dynamic_ps_enable_work ) ; if ( sdata -> vif . cfg . arp_addr_cnt ) { changed |= BSS_CHANGED_ARP_FILTER ; } sdata -> vif . bss_conf . qos = false ; if ( ! sdata -> vif . valid_links ) { changed |= BSS_CHANGED_QOS ; changed |= BSS_CHANGED_BSSID | BSS_CHANGED_HT ; ieee80211_bss_info_change_notify ( sdata , changed ) ; } else { ieee80211_vif_cfg_change_notify ( sdata , changed ) ; } ieee80211_set_wmm_default ( & sdata -> deflink , false , false ) ; del_timer_sync ( & sdata -> u . mgd . conn_mon_timer ) ; del_timer_sync ( & sdata -> u . mgd . bcn_mon_timer ) ; del_timer_sync ( & sdata -> u . mgd . timer ) ; del_timer_sync ( & sdata -> deflink . u . mgd . chswitch_timer ) ; sdata -> vif . bss_conf . dtim_period = 0 ; sdata -> vif . bss_conf . beacon_rate = NULL ; sdata -> deflink . u . mgd . have_beacon = false ; sdata -> deflink . u . mgd . tracking_signal_avg = false ; sdata -> deflink . u . mgd . disable_wmm_tracking = false ; ifmgd -> flags = 0 ; sdata -> deflink . u . mgd . conn_flags = 0 ; mutex_lock ( & local -> mtx ) ; for ( link_id = 0 ; link_id < ARRAY_SIZE ( sdata -> link ) ; link_id ++ ) { struct ieee80211_link_data * link ; link = sdata_dereference ( sdata -> link [ link_id ] , sdata ) ; if ( ! link ) { continue ; } ieee80211_link_release_channel ( link ) ; } sdata -> vif . bss_conf . csa_active = false ; sdata -> deflink . u . mgd . csa_waiting_bcn = false ; sdata -> deflink . u . mgd . csa_ignored_same_chan = false ; if ( sdata -> deflink . csa_block_tx ) { ieee80211_wake_vif_queues ( local , sdata , IEEE80211_QUEUE_STOP_REASON_CSA ) ; sdata -> deflink . csa_block_tx = false ; } mutex_unlock ( & local -> mtx ) ; memset ( ifmgd -> tx_tspec , 0 , sizeof ( ifmgd -> tx_tspec ) ) ; cancel_delayed_work_sync ( & ifmgd -> tx_tspec_wk ) ; sdata -> vif . bss_conf . pwr_reduction = 0 ; sdata -> vif . bss_conf . tx_pwr_env_num = 0 ; memset ( sdata -> vif . bss_conf . tx_pwr_env , 0 , sizeof ( sdata -> vif . bss_conf . tx_pwr_env ) ) ; ieee80211_vif_set_links ( sdata , 0 ) ; } 