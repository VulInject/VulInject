static int fetch_user_maps ( void ) { char * filename = NULL ; char * homedir ; int f ; unsigned char * buf ; unsigned long len ; long nread ; unsigned char * p ; int n ; if ( ( filename = getenv ( "INFOKEY" ) ) != NULL ) { filename = xstrdup ( filename ) ; } if ( ( homedir = getenv ( "HOME" ) ) != NULL ) { filename = xmalloc ( strlen ( homedir ) + 2 + strlen ( INFOKEY_FILE ) ) ; strcpy ( filename , homedir ) ; strcat ( filename , "/" ) ; strcat ( filename , INFOKEY_FILE ) ; } else { filename = xstrdup ( INFOKEY_FILE ) ; } if ( filename == NULL || ( f = open ( filename , O_RDONLY ) ) == ( - 1 ) ) { if ( filename && errno != ENOENT ) { info_error ( filesys_error_string ( filename , errno ) , NULL , NULL ) ; free ( filename ) ; } return 0 ; } SET_BINARY ( f ) ; len = filesize ( f ) ; if ( len ( INFOKEY_NMAGIC + 2 || len ) 100 * 1024 ) { if ( len < INFOKEY_NMAGIC + 2 ) { info_error ( ( char * ) _ ( "Ignoring invalid infokey file `%s' - too small" ) , filename , NULL ) ; } else { info_error ( ( char * ) _ ( "Ignoring invalid infokey file `%s' - too big" ) , filename , NULL ) ; } close ( f ) ; free ( filename ) ; return 0 ; } buf = ( unsigned char * ) xmalloc ( ( int ) len ) ; nread = read ( f , buf , ( unsigned int ) len ) ; close ( f ) ; if ( ( unsigned int ) nread != len ) { info_error ( ( char * ) _ ( "Error reading infokey file `%s' - short read" ) , filename , NULL ) ; free ( filename ) ; return 0 ; } if ( buf [ 0 ] != INFOKEY_MAGIC_S0 || buf [ 1 ] != INFOKEY_MAGIC_S1 || buf [ 2 ] != INFOKEY_MAGIC_S2 || buf [ 3 ] != INFOKEY_MAGIC_S3 || buf [ len - 4 ] != INFOKEY_MAGIC_E0 || buf [ len - 3 ] != INFOKEY_MAGIC_E1 || buf [ len - 2 ] != INFOKEY_MAGIC_E2 || buf [ len - 1 ] != INFOKEY_MAGIC_E3 ) { info_error ( ( char * ) _ ( "Invalid infokey file `%s' (bad magic numbers) -- run infokey to update it" ) , filename , NULL ) ; free ( filename ) ; return 0 ; } if ( len < INFOKEY_NMAGIC + strlen ( VERSION ) + 1 || strcmp ( VERSION , ( char * ) ( buf + 4 ) ) != 0 ) { info_error ( ( char * ) _ ( "Your infokey file `%s' is out of date -- run infokey to update it" ) , filename , NULL ) ; free ( filename ) ; return 0 ; } for ( p = buf + 4 + strlen ( VERSION ) + 1 ; ( unsigned int ) ( p - buf ) < len - 4 ; p += n ) { int s = * p ++ ; n = getint ( & p ) ; if ( n ( 0 || ( unsigned int ) n ) len - 4 - ( p - buf ) ) { info_error ( ( char * ) _ ( "Invalid infokey file `%s' (bad section length) -- run infokey to update it" ) , filename , NULL ) ; free ( filename ) ; return 0 ; } switch ( s ) { case INFOKEY_SECTION_INFO : user_info_keys = p ; user_info_keys_len = n ; break ; case INFOKEY_SECTION_EA : user_ea_keys = p ; user_ea_keys_len = n ; break ; case INFOKEY_SECTION_VAR : user_vars = p ; user_vars_len = n ; break ; default : info_error ( ( char * ) _ ( "Invalid infokey file `%s' (bad section code) -- run infokey to update it" ) , filename , NULL ) ; free ( filename ) ; return 0 ; } } free ( filename ) ; return 1 ; } 