static void add_production ( struct xkb_compose_table * table , struct scanner * s , const struct production * production ) { unsigned lhs_pos = 0 ; uint16_t curr = darray_size ( table -> nodes ) == 1 ?0 : 1 ; uint16_t * pptr = NULL ; struct compose_node * node = NULL ; if ( darray_size ( table -> nodes ) + production -> len + MAX_LHS_LEN > MAX_COMPOSE_NODES ) { scanner_warn ( s , "too many sequences for one Compose file; will ignore further lines" ) ; } while ( true ) { const xkb_keysym_t keysym = production -> lhs [ lhs_pos ] ; const bool last = lhs_pos + 1 == production -> len ; if ( curr == 0 ) { compose_node new = { . keysym = keysym . lokid = 0 . hikid = 0 . internal = { . eqkid = 0 . is_leaf = false } } ; curr = darray_size ( table -> nodes ) ; if ( pptr != NULL ) { * pptr = curr ; pptr = NULL ; } darray_append ( table -> nodes , new ) ; } node = & darray_item ( table -> nodes , curr ) ; if ( keysym < node -> keysym ) { pptr = & node -> lokid ; curr = node -> lokid ; } if ( keysym > node -> keysym ) { pptr = & node -> hikid ; curr = node -> hikid ; } if ( ! last ) { if ( node -> is_leaf ) { scanner_warn ( s , "a sequence already exists which is a prefix of this sequence; overriding" ) ; node -> internal . eqkid = 0 ; node -> internal . is_leaf = false ; } lhs_pos ++ ; pptr = & node -> internal . eqkid ; curr = node -> internal . eqkid ; } else { if ( node -> is_leaf ) { bool same_string = ( node -> leaf . utf8 == 0 && ! production -> has_string ) || ( node -> leaf . utf8 != 0 && production -> has_string && streq ( & darray_item ( table -> utf8 , node -> leaf . utf8 ) , production -> string ) ) ; bool same_keysym = ( node -> leaf . keysym == XKB_KEY_NoSymbol && ! production -> has_keysym ) || ( node -> leaf . keysym != XKB_KEY_NoSymbol && production -> has_keysym && node -> leaf . keysym == production -> keysym ) ; if ( same_string && same_keysym ) { scanner_warn ( s , "this compose sequence is a duplicate of another; skipping line" ) ; return ; } else { scanner_warn ( s , "this compose sequence already exists; overriding" ) ; } } if ( node -> internal . eqkid != 0 ) { scanner_warn ( s , "this compose sequence is a prefix of another; skipping line" ) ; return ; } node -> is_leaf = true ; if ( production -> has_string ) { node -> leaf . utf8 = darray_size ( table -> utf8 ) ; darray_append_items ( table -> utf8 , production -> string , strlen ( production -> string ) + 1 ) ; } if ( production -> has_keysym ) { node -> leaf . keysym = production -> keysym ; } return ; } } } 