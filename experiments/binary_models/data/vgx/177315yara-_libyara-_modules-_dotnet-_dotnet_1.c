static void parse_user_types ( const CLASS_CONTEXT * ctx ) { const uint8_t * str_heap = ctx -> str_heap ; uint32_t str_size = ctx -> str_size ; int out_idx = 0 ; for ( uint32_t idx = 0 ; idx < ctx -> tables -> typedef_ . RowCount ; ++ idx ) { YR_OBJECT * out_obj = ctx -> pe -> object ; const uint8_t * data = get_table_offset ( & ctx -> tables -> typedef_ , idx + 1 ) ; TYPEDEF_ROW row = { 0 } ; bool result = read_typedef ( ctx , data , & row ) ; if ( ! result ) { continue ; } const char * name = pe_get_dotnet_string ( ctx -> pe , str_heap , str_size , row . Name ) ; const char * type = get_typedef_type ( row . Flags ) ; if ( ! name || ! * name || ! type ) { continue ; } const char * end = strchr ( name , '`' ) ; if ( end == name || strcmp ( name , "<Module>" ) == 0 ) { continue ; } if ( end ) { yr_set_sized_string ( name , end - name , out_obj , "classes[%i].name" , out_idx ) ; } else { yr_set_string ( name , out_obj , "classes[%i].name" , out_idx ) ; } char * fullname = NULL ; char * ; pe_get_dotnet_string ctx -> pe , str_heap , str_size , row . Namespace } if ( is_nested ( row . Flags ) ) { char * nested_namespace = parse_enclosing_types ( ctx , idx + 1 , 1 ) ; create_full_name , nested_namespace } yr_set_string ( , , "classes[%i].namespace" , ) fullname = create_full_name ( , ) ; yr_free ( nested_namespace ) ; yr_free ( ) } else { yr_set_string ( , , "classes[%i].namespace" , ) fullname = create_full_name ( , ) ; } const char * visibility = get_type_visibility ( row . Flags ) ; uint32_t abstract = ( row . Flags & TYPE_ATTR_ABSTRACT ) != 0 ; uint32_t sealed = ( row . Flags & TYPE_ATTR_SEALED ) != 0 ; yr_set_string ( fullname , out_obj , "classes[%i].fullname" , out_idx ) ; yr_set_string ( visibility , out_obj , "classes[%i].visibility" , out_idx ) ; yr_set_string ( type , out_obj , "classes[%i].type" , out_idx ) ; yr_set_integer ( abstract , out_obj , "classes[%i].abstract" , out_idx ) ; yr_set_integer ( sealed , out_obj , "classes[%i].sealed" , out_idx ) ; yr_free ( fullname ) ; GENERIC_PARAMETERS gen_params = { 0 } ; parse_generic_params ( ctx , false , idx + 1 , & gen_params ) ; yr_set_integer ( gen_params . len , out_obj , "classes[%i].number_of_generic_parameters" , out_idx ) ; for ( uint32_t i = 0 ; i < gen_params . len ; ++ i ) { yr_set_string ( gen_params . names [ i ] , out_obj , "classes[%i].generic_parameters[%i]" , out_idx , i ) ; } parse_type_parents ( ctx , row . Extends , idx + 1 , out_idx , & gen_params ) ; uint32_t method_count = 0 ; if ( idx + 1 < ctx -> tables -> typedef_ . RowCount ) { const uint8_t * data = get_table_offset ( & ctx -> tables -> typedef_ , idx + 2 ) ; TYPEDEF_ROW next_row = { 0 } ; result = read_typedef ( ctx , data , & next_row ) ; if ( result && next_row . Method >= row . Method ) { method_count = next_row . Method - row . Method ; } } if ( ctx -> tables -> methoddef . RowCount >= row . Method ) { method_count = ctx -> tables -> methoddef . RowCount + 1 - row . Method ; } if ( method_count <= MAX_METHOD_COUNT ) { parse_methods ( ctx , row . Method , method_count , out_idx , & gen_params ) ; } yr_free ( gen_params . names ) ; out_idx ++ ; ( out_idx , ctx -> pe -> object , "number_of_classes" ) ; 