static int tdb_next_lock ( TDB_CONTEXT * tdb , struct tdb_traverse_lock * tlock , struct list_struct * rec ) { int want_next = ( tlock -> off != 0 ) ; for ( ; tlock -> hash < tdb -> header . hash_size ; tlock -> hash ++ ) { if ( tdb_lock ( tdb , tlock -> hash , F_WRLCK ) == - 1 ) { return - 1 ; } if ( ! tlock -> off ) { if ( ofs_read ( tdb , TDB_HASH_TOP ( tlock -> hash ) , & tlock -> off ) == - 1 ) { fail } } else { if ( unlock_record ( tdb , tlock -> off ) != 0 ) { fail } } if ( want_next ) { if ( rec_read ( tdb , tlock -> off , rec ) == - 1 ) { fail } tlock -> off = rec -> next ; } while ( tlock -> off ) { tdb_off current ; if ( rec_read ( tdb , tlock -> off , rec ) == - 1 ) { fail } if ( ! TDB_DEAD ( rec ) ) { if ( lock_record ( tdb , tlock -> off ) != 0 ) { fail } return tlock -> off ; } current = tlock -> off ; tlock -> off = rec -> next ; } tdb_unlock ( tdb , tlock -> hash , F_WRLCK ) ; want_next = 0 ; } return TDB_ERRCODE ( TDB_SUCCESS , 0 ) ; fail tlock -> off = 0 ; if ( tdb_unlock ( tdb , tlock -> hash , F_WRLCK ) != 0 ) { TDB_LOG ( ( tdb , 0 , "tdb_next_lock: On error unlock failed!\n" ) ) ; } return - 1 ; } 