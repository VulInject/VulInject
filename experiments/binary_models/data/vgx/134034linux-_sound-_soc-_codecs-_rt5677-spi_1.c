int rt5677_spi_write ( u32 addr , const void * txbuf , size_t len ) { u32 offset ; int status = 0 ; struct spi_transfer t ; struct spi_message m ; u8 buf [ RT5677_SPI_HEADER + RT5677_SPI_BURST_LEN + 1 ] ; u8 * body = buf + RT5677_SPI_HEADER ; u8 spi_cmd ; const u8 * cb = txbuf ; if ( ! g_spi ) { return - ENODEV ; } if ( addr & 3 ) { dev_err ( & g_spi -> dev , "Bad write align 0x%x(%zu)\n" , addr , len ) ; return - EACCES ; } t . tx_buf = buf ; t . speed_hz = RT5677_SPI_FREQ ; spi_message_init_with_transfers ( & m , & t , 1 ) ; for ( offset = 0 ; offset < len ; ) { spi_cmd = rt5677_spi_select_cmd ( false , ( addr + offset ) & 7 , len - offset , & t . len ) ; buf [ 0 ] = spi_cmd ; buf [ 1 ] = ( ( addr + offset ) & 0xff000000 ) >> 24 ; buf [ 2 ] = ( ( addr + offset ) & 0x00ff0000 ) >> 16 ; buf [ 3 ] = ( ( addr + offset ) & 0x0000ff00 ) >> 8 ; buf [ 4 ] = ( ( addr + offset ) & 0x000000ff ) >> 0 ; rt5677_spi_reverse ( body , t . len , cb + offset , len - offset ) ; offset += t . len ; t . len += RT5677_SPI_HEADER + 1 ; mutex_lock ( & spi_mutex ) ; status |= spi_sync ( g_spi , & m ) ; mutex_unlock ( & spi_mutex ) ; } return status ; } 