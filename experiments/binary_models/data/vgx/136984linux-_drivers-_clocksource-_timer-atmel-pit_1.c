static int __init at91sam926x_pit_dt_init ( struct device_node * node ) { unsigned long pit_rate ; unsigned bits ; int ret ; struct pit_data * data ; data = kmalloc ( sizeof ( * data ) , GFP_KERNEL ) ; if ( ! data ) { return - ENOMEM ; } data -> base = of_iomap ( node , 0 ) ; if ( ! data -> base ) { pr_err ( "Could not map PIT address\n" ) ; ret = - ENXIO ; exit } data -> mck = of_clk_get ( node , 0 ) ; if ( IS_ERR ( data -> mck ) ) { pr_err ( "Unable to get mck clk\n" ) ; ret = PTR_ERR ( data -> mck ) ; exit } ret = clk_prepare_enable ( data -> mck ) ; if ( ret ) { pr_err ( "Unable to enable mck\n" ) ; exit } data -> irq = irq_of_parse_and_map ( node , 0 ) ; if ( ! data -> irq ) { pr_err ( "Unable to get IRQ from DT\n" ) ; ret = - EINVAL ; exit } pit_rate = clk_get_rate ( data -> mck ) / 16 ; data -> cycle = DIV_ROUND_CLOSEST ( pit_rate , HZ ) ; WARN_ON ( ( ( data -> cycle - 1 ) & ~ AT91_PIT_PIV ) != 0 ) ; at91sam926x_pit_reset ( data ) ; bits = 12 + ilog2 ( data -> cycle ) ; data -> clksrc . mask = CLOCKSOURCE_MASK ( bits ) ; data -> clksrc . name = "pit" ; data -> clksrc . rating = 175 ; data -> clksrc . read = read_pit_clk ; data -> clksrc . flags = CLOCK_SOURCE_IS_CONTINUOUS ; ret = clocksource_register_hz ( & data -> clksrc , pit_rate ) ; if ( ret ) { pr_err ( "Failed to register clocksource\n" ) ; exit } ret = request_irq ( data -> irq , at91sam926x_pit_interrupt , IRQF_SHARED | IRQF_TIMER | IRQF_IRQPOLL , "at91_tick" , data ) ; if ( ret ) { pr_err ( "Unable to setup IRQ\n" ) ; clocksource_unregister ( & data -> clksrc ) ; exit } data -> clkevt . name = "pit" ; data -> clkevt . features = CLOCK_EVT_FEAT_PERIODIC ; data -> clkevt . shift = 32 ; data -> clkevt . mult = div_sc ( pit_rate , NSEC_PER_SEC , data -> clkevt . shift ) ; data -> clkevt . rating = 100 ; data -> clkevt . cpumask = cpumask_of ( 0 ) ; data -> clkevt . set_state_shutdown = pit_clkevt_shutdown ; data -> clkevt . set_state_periodic = pit_clkevt_set_periodic ; data -> clkevt . resume = at91sam926x_pit_resume ; data -> clkevt . suspend = at91sam926x_pit_suspend ; clockevents_register_device ( & data -> clkevt ) ; return 0 ; exit kfree ( data ) ; return ret ; } 