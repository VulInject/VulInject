void __init arm_dt_init_cpu_maps ( void ) { struct device_node * cpu , * cpus ; int found_method = 0 ; u32 i , j , cpuidx = 1 ; u32 mpidr = is_smp ( ) ?read_cpuid_mpidr ( ) & MPIDR_HWID_BITMASK : 0 ; u32 tmp_map [ NR_CPUS ] { [ 0 ... NR_CPUS - 1 ] = MPIDR_INVALID } ; ; bool bootcpu_valid = false ; cpus = of_find_node_by_path ( "/cpus" ) ; for_each_of_cpu_node ( ) { u32 hwid = of_get_cpu_hwid ( cpu , 0 ) ; pr_debug ( " * %pOF...\n" , cpu ) ; if ( hwid & ~ MPIDR_HWID_BITMASK ) { of_node_put ( cpu ) ; return ; } for ( j = 0 ; j < cpuidx ; j ++ ) { if ( WARN ( tmp_map [ j ] == hwid , "Duplicate /cpu reg properties in the DT\n" ) ) { of_node_put ( cpu ) ; return ; } } if ( hwid == mpidr ) { i = 0 ; bootcpu_valid = true ; } else { i = cpuidx ++ ; } if ( WARN ( cpuidx > nr_cpu_ids , "DT /cpu %u nodes greater than " "max cores %u, capping them\n" , cpuidx , nr_cpu_ids ) ) { cpuidx = nr_cpu_ids ; of_node_put ( cpu ) ; break ; } tmp_map [ i ] = hwid ; if ( ! found_method ) { found_method = set_smp_ops_by_method ( cpu ) ; } } if ( ! found_method ) { set_smp_ops_by_method ( cpus ) ; } if ( ! bootcpu_valid ) { pr_warn ( "DT missing boot CPU MPIDR[23:0], fall back to default cpu_logical_map\n" ) ; return ; } for ( i = 0 ; i < cpuidx ; i ++ ) { set_cpu_possible ( i , true ) ; cpu_logical_map ( i ) = tmp_map [ i ] ; pr_debug ( "cpu logical map 0x%x\n" , cpu_logical_map ( i ) ) ; } } 