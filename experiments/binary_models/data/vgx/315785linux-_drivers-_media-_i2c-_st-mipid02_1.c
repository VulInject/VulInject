static int mipid02_stream_enable ( struct mipid02_dev * bridge ) { struct i2c_client * client = bridge -> i2c_client ; int ret = - EINVAL ; if ( ! bridge -> s_subdev ) { error } ret = mipid02_configure_from_rx ( bridge ) ; if ( ret ) { error } ret = mipid02_configure_from_tx ( bridge ) ; if ( ret ) { error } ret = mipid02_configure_from_code ( bridge ) ; if ( ret ) { error } ret = mipid02_write_reg ( bridge , MIPID02_CLK_LANE_REG1 , bridge -> r . clk_lane_reg1 ) ; if ( ret ) { error } ret = mipid02_write_reg ( bridge , MIPID02_CLK_LANE_REG3 , CLK_MIPI_CSI ) ; if ( ret ) { error } ret = mipid02_write_reg ( bridge , MIPID02_DATA_LANE0_REG1 , bridge -> r . data_lane0_reg1 ) ; if ( ret ) { error } ret = mipid02_write_reg ( bridge , MIPID02_DATA_LANE0_REG2 , DATA_MIPI_CSI ) ; if ( ret ) { error } ret = mipid02_write_reg ( bridge , MIPID02_DATA_LANE1_REG1 , bridge -> r . data_lane1_reg1 ) ; if ( ret ) { error } ret = mipid02_write_reg ( bridge , MIPID02_DATA_LANE1_REG2 , DATA_MIPI_CSI ) ; if ( ret ) { error } ret = mipid02_write_reg ( bridge , MIPID02_MODE_REG1 , MODE_NO_BYPASS | bridge -> r . mode_reg1 ) ; if ( ret ) { error } ret = mipid02_write_reg ( bridge , MIPID02_MODE_REG2 , bridge -> r . mode_reg2 ) ; if ( ret ) { error } ret = mipid02_write_reg ( bridge , MIPID02_DATA_ID_RREG , bridge -> r . data_id_rreg ) ; if ( ret ) { error } ret = mipid02_write_reg ( bridge , MIPID02_DATA_SELECTION_CTRL , bridge -> r . data_selection_ctrl ) ; if ( ret ) { error } ret = mipid02_write_reg ( bridge , MIPID02_PIX_WIDTH_CTRL , bridge -> r . pix_width_ctrl ) ; if ( ret ) { error } ret = mipid02_write_reg ( bridge , MIPID02_PIX_WIDTH_CTRL_EMB , bridge -> r . pix_width_ctrl_emb ) ; if ( ret ) { error } return 0 ; error dev_err ( & client -> dev , "failed to stream on %d" , ret ) ; mipid02_stream_disable ( bridge ) ; return ret ; } 