ieee80211_rx_result ieee80211_crypto_aes_gmac_decrypt ( struct ieee80211_rx_data * rx ) { struct sk_buff * skb = rx -> skb ; struct ieee80211_rx_status * status = IEEE80211_SKB_RXCB ( skb ) ; struct ieee80211_key * key = rx -> key ; struct ieee80211_mmie_16 * mmie ; u8 aad [ GMAC_AAD_LEN ] , * mic , ipn [ 6 ] , nonce [ GMAC_NONCE_LEN ] ; struct ieee80211_hdr * hdr = ( ieee80211_hdr * ) skb -> data ; if ( ! ieee80211_is_mgmt ( hdr -> frame_control ) ) { return RX_CONTINUE ; } mmie = ( ieee80211_mmie_16 * ) ( skb -> data + skb -> len - sizeof ( * mmie ) ) ; if ( mmie -> element_id != WLAN_EID_MMIE || mmie -> length != sizeof ( * mmie ) - 2 ) { return RX_DROP_UNUSABLE ; } bip_ipn_swap ( ipn , mmie -> sequence_number ) ; if ( memcmp ( ipn , key -> u . aes_gmac . rx_pn , 6 ) <= 0 ) { key -> u . aes_gmac . replays ++ ; return RX_DROP_UNUSABLE ; } if ( ! ( status -> flag & RX_FLAG_DECRYPTED ) ) { bip_aad ( skb , aad ) ; memcpy ( nonce , hdr -> addr2 , ETH_ALEN ) ; memcpy ( nonce + ETH_ALEN , ipn , 6 ) ; mic = kmalloc ( GMAC_MIC_LEN , GFP_ATOMIC ) ; if ( ! mic ) { return RX_DROP_UNUSABLE ; } if ( ieee80211_aes_gmac ( key -> u . aes_gmac . tfm , aad , nonce , skb -> data + 24 , skb -> len - 24 , mic ) < 0 || crypto_memneq ( mic , mmie -> mic , sizeof ( mmie -> mic ) ) ) { key -> u . aes_gmac . icverrors ++ ; kfree ( mic ) ; return RX_DROP_UNUSABLE ; } kfree ( mic ) ; } memcpy ( key -> u . aes_gmac . rx_pn , ipn , 6 ) ; skb_trim ( skb , skb -> len - sizeof ( * mmie ) ) ; return RX_CONTINUE ; } 