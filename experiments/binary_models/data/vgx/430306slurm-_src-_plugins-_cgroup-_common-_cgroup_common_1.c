extern int common_cgroup_delete ( xcgroup_t * cg ) { int retries = 0 , npids = - 1 ; pid_t * pids = NULL ; if ( ! cg || ! cg -> path ) { error ( "invalid control group" ) ; return SLURM_SUCCESS ; } while ( ( rmdir ( cg -> path ) < 0 ) && ( errno != ENOENT ) ) { if ( errno == EBUSY ) { if ( ! _is_empty_dir ( cg -> path ) ) { log_flag ( CGROUP , "Cannot rmdir(%s), cgroup is not empty" , cg -> path ) ; return SLURM_ERROR ; } if ( npids == - 1 ) { if ( ( common_cgroup_get_pids ( cg , & pids , & npids ) != SLURM_SUCCESS ) ) { return SLURM_ERROR ; } if ( npids > 0 ) { debug3 ( "Not removing %s, found %d pids" , cg -> path , npids ) ; return SLURM_ERROR ; } } if ( retries < 5 ) { poll ( NULL , 0 , 1000 ) ; retries ++ ; continue ; } log_flag ( CGROUP , "Unable to rmdir(%s), did %d retries: %m" , cg -> path , retries ) ; } else { error ( "Unable to rmdir(%s), unexpected error: %m" , cg -> path ) ; } return SLURM_ERROR ; } if ( retries ) { log_flag ( CGROUP , "rmdir(%s): took %d retries, possible cgroup filesystem slowness" , cg -> path , retries ) ; } return SLURM_SUCCESS ; } 