void StreamTcpInitConfig ( bool quiet ) { intmax_t value = 0 ; uint16_t rdrange = 10 ; SCLogDebug ( "Initializing Stream" ) ; SC_ATOMIC_INIT ( stream_config . memcap ) ; SC_ATOMIC_INIT ( stream_config . reassembly_memcap ) ; if ( ( ConfGetInt ( "stream.max-sessions" , & value ) ) == 1 ) { SCLogWarning ( "max-sessions is obsolete. " "Number of concurrent sessions is now only limited by Flow and " "TCP stream engine memcaps." ) ; } if ( ( ConfGetInt ( "stream.prealloc-sessions" , & value ) ) == 1 ) { stream_config . prealloc_sessions = ( uint32_t ) value ; } else { if ( RunmodeIsUnittests ( ) ) { stream_config . prealloc_sessions = 128 ; } else { stream_config . prealloc_sessions = STREAMTCP_DEFAULT_PREALLOC ; if ( ConfGetNode ( "stream.prealloc-sessions" ) != NULL ) { WarnInvalidConfEntry ( "stream.prealloc_sessions" , "%" PRIu32 , stream_config . prealloc_sessions ) ; } } } if ( ! quiet ) { SCLogConfig ( "stream \"prealloc-sessions\": %" PRIu32 " (per thread)" , stream_config . prealloc_sessions ) ; } const char * temp_stream_memcap_str ; if ( ConfGet ( "stream.memcap" , & temp_stream_memcap_str ) == 1 ) { uint64_t stream_memcap_copy ; if ( ParseSizeStringU64 ( temp_stream_memcap_str , & stream_memcap_copy ) < 0 ) { SCLogError ( "Error parsing stream.memcap " "from conf file - %s.  Killing engine" , temp_stream_memcap_str ) ; exit ( EXIT_FAILURE ) ; } else { SC_ATOMIC_SET ( stream_config . memcap , stream_memcap_copy ) ; } } else { SC_ATOMIC_SET ( stream_config . memcap , STREAMTCP_DEFAULT_MEMCAP ) ; } if ( ! quiet ) { SCLogConfig ( "stream \"memcap\": %" PRIu64 , SC_ATOMIC_GET ( stream_config . memcap ) ) ; } int imidstream ; ( void ) ConfGetBool ( "stream.midstream" , & imidstream ) ; stream_config . midstream = imidstream != 0 ; if ( ! quiet ) { SCLogConfig ( "stream \"midstream\" session pickups: %s" , stream_config . midstream ?"enabled" : "disabled" ) ; } ( void ) ConfGetBool ( "stream.async-oneside" , & stream_config . async_oneside ) ; if ( ! quiet ) { SCLogConfig ( "stream \"async-oneside\": %s" , stream_config . async_oneside ?"enabled" : "disabled" ) ; } int csum = 0 ; if ( ( ConfGetBool ( "stream.checksum-validation" , & csum ) ) == 1 ) { if ( csum == 1 ) { stream_config . flags |= STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION ; } } else { stream_config . flags |= STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION ; } if ( ! quiet ) { SCLogConfig ( "stream \"checksum-validation\": %s" , stream_config . flags & STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION ?"enabled" : "disabled" ) ; } const char * temp_stream_inline_str ; if ( ConfGet ( "stream.inline" , & temp_stream_inline_str ) == 1 ) { int inl = 0 ; if ( strcmp ( temp_stream_inline_str , "auto" ) == 0 ) { if ( EngineModeIsIPS ( ) ) { stream_config . flags |= STREAMTCP_INIT_FLAG_INLINE ; } } if ( ConfGetBool ( "stream.inline" , & inl ) == 1 ) { if ( inl ) { stream_config . flags |= STREAMTCP_INIT_FLAG_INLINE ; } } } else { if ( EngineModeIsIPS ( ) ) { stream_config . flags |= STREAMTCP_INIT_FLAG_INLINE ; } } stream_config . ssn_memcap_policy = ExceptionPolicyParse ( "stream.memcap-policy" , true ) ; stream_config . reassembly_memcap_policy = ExceptionPolicyParse ( "stream.reassembly.memcap-policy" , true ) ; stream_config . midstream_policy = ExceptionPolicyParse ( "stream.midstream-policy" , true ) ; if ( stream_config . midstream && stream_config . midstream_policy != EXCEPTION_POLICY_NOT_SET ) { SCLogWarning ( "stream.midstream_policy setting conflicting with stream.midstream enabled. " "Ignoring stream.midstream_policy. Bug #5825." ) ; stream_config . midstream_policy = EXCEPTION_POLICY_NOT_SET ; } if ( ! quiet ) { SCLogConfig ( "stream.\"inline\": %s" , stream_config . flags & STREAMTCP_INIT_FLAG_INLINE ?"enabled" : "disabled" ) ; } int bypass = 0 ; if ( ( ConfGetBool ( "stream.bypass" , & bypass ) ) == 1 ) { if ( bypass == 1 ) { stream_config . flags |= STREAMTCP_INIT_FLAG_BYPASS ; } } if ( ! quiet ) { SCLogConfig ( "stream \"bypass\": %s" , ( stream_config . flags & STREAMTCP_INIT_FLAG_BYPASS ) ?"enabled" : "disabled" ) ; } int drop_invalid = 0 ; if ( ( ConfGetBool ( "stream.drop-invalid" , & drop_invalid ) ) == 1 ) { if ( drop_invalid == 1 ) { stream_config . flags |= STREAMTCP_INIT_FLAG_DROP_INVALID ; } } else { stream_config . flags |= STREAMTCP_INIT_FLAG_DROP_INVALID ; } if ( ( ConfGetInt ( "stream.max-synack-queued" , & value ) ) == 1 ) { if ( value >= 0 && value <= 255 ) { stream_config . max_synack_queued = ( uint8_t ) value ; } else { stream_config . max_synack_queued = ( uint8_t ) STREAMTCP_DEFAULT_MAX_SYNACK_QUEUED ; } } else { stream_config . max_synack_queued = ( uint8_t ) STREAMTCP_DEFAULT_MAX_SYNACK_QUEUED ; } if ( ! quiet ) { SCLogConfig ( "stream \"max-synack-queued\": %" PRIu8 , stream_config . max_synack_queued ) ; } const char * temp_stream_reassembly_memcap_str ; if ( ConfGet ( "stream.reassembly.memcap" , & temp_stream_reassembly_memcap_str ) == 1 ) { uint64_t stream_reassembly_memcap_copy ; if ( ParseSizeStringU64 ( temp_stream_reassembly_memcap_str , & stream_reassembly_memcap_copy ) < 0 ) { SCLogError ( "Error parsing " "stream.reassembly.memcap " "from conf file - %s.  Killing engine" , temp_stream_reassembly_memcap_str ) ; exit ( EXIT_FAILURE ) ; } else { SC_ATOMIC_SET ( stream_config . reassembly_memcap , stream_reassembly_memcap_copy ) ; } } else { SC_ATOMIC_SET ( stream_config . reassembly_memcap , STREAMTCP_DEFAULT_REASSEMBLY_MEMCAP ) ; } if ( ! quiet ) { SCLogConfig ( "stream.reassembly \"memcap\": %" PRIu64 "" , SC_ATOMIC_GET ( stream_config . reassembly_memcap ) ) ; } const char * temp_stream_reassembly_depth_str ; if ( ConfGet ( "stream.reassembly.depth" , & temp_stream_reassembly_depth_str ) == 1 ) { if ( ParseSizeStringU32 ( temp_stream_reassembly_depth_str , & stream_config . reassembly_depth ) < 0 ) { SCLogError ( "Error parsing " "stream.reassembly.depth " "from conf file - %s.  Killing engine" , temp_stream_reassembly_depth_str ) ; exit ( EXIT_FAILURE ) ; } } else { stream_config . reassembly_depth = 0 ; } if ( ! quiet ) { SCLogConfig ( "stream.reassembly \"depth\": %" PRIu32 "" , stream_config . reassembly_depth ) ; } int randomize = 0 ; if ( ( ConfGetBool ( "stream.reassembly.randomize-chunk-size" , & randomize ) ) == 0 ) { if ( ! ( RunmodeIsUnittests ( ) ) ) { randomize = 1 ; } } if ( randomize ) { const char * temp_rdrange ; if ( ConfGet ( "stream.reassembly.randomize-chunk-range" , & temp_rdrange ) == 1 ) { if ( ParseSizeStringU16 ( temp_rdrange , & rdrange ) < 0 ) { SCLogError ( "Error parsing " "stream.reassembly.randomize-chunk-range " "from conf file - %s.  Killing engine" , temp_rdrange ) ; exit ( EXIT_FAILURE ) ; } if ( rdrange >= 100 ) { FatalError ( "stream.reassembly.randomize-chunk-range " "must be lower than 100" ) ; } } } const char * temp_stream_reassembly_toserver_chunk_size_str ; if ( ConfGet ( "stream.reassembly.toserver-chunk-size" , & temp_stream_reassembly_toserver_chunk_size_str ) == 1 ) { if ( ParseSizeStringU16 ( temp_stream_reassembly_toserver_chunk_size_str , & stream_config . reassembly_toserver_chunk_size ) < 0 ) { SCLogError ( "Error parsing " "stream.reassembly.toserver-chunk-size " "from conf file - %s.  Killing engine" , temp_stream_reassembly_toserver_chunk_size_str ) ; exit ( EXIT_FAILURE ) ; } } else { stream_config . reassembly_toserver_chunk_size = STREAMTCP_DEFAULT_TOSERVER_CHUNK_SIZE ; } if ( randomize ) { long int r = RandomGetWrap ( ) ; stream_config . reassembly_toserver_chunk_size += ( int ) ( stream_config . reassembly_toserver_chunk_size * ( ( double ) r / RAND_MAX - 0.5 ) * rdrange / 100 ) ; } const char * temp_stream_reassembly_toclient_chunk_size_str ; if ( ConfGet ( "stream.reassembly.toclient-chunk-size" , & temp_stream_reassembly_toclient_chunk_size_str ) == 1 ) { if ( ParseSizeStringU16 ( temp_stream_reassembly_toclient_chunk_size_str , & stream_config . reassembly_toclient_chunk_size ) < 0 ) { SCLogError ( "Error parsing " "stream.reassembly.toclient-chunk-size " "from conf file - %s.  Killing engine" , temp_stream_reassembly_toclient_chunk_size_str ) ; exit ( EXIT_FAILURE ) ; } } else { stream_config . reassembly_toclient_chunk_size = STREAMTCP_DEFAULT_TOCLIENT_CHUNK_SIZE ; } if ( randomize ) { long int r = RandomGetWrap ( ) ; stream_config . reassembly_toclient_chunk_size += ( int ) ( stream_config . reassembly_toclient_chunk_size * ( ( double ) r / RAND_MAX - 0.5 ) * rdrange / 100 ) ; } if ( ! quiet ) { SCLogConfig ( "stream.reassembly \"toserver-chunk-size\": %" PRIu16 , stream_config . reassembly_toserver_chunk_size ) ; SCLogConfig ( "stream.reassembly \"toclient-chunk-size\": %" PRIu16 , stream_config . reassembly_toclient_chunk_size ) ; } int enable_raw = 1 ; if ( ConfGetBool ( "stream.reassembly.raw" , & enable_raw ) == 1 ) { if ( ! enable_raw ) { stream_config . stream_init_flags = STREAMTCP_STREAM_FLAG_DISABLE_RAW ; } } else { enable_raw = 1 ; } if ( ! quiet ) { SCLogConfig ( "stream.reassembly.raw: %s" , enable_raw ?"enabled" : "disabled" ) ; } StreamTcpInitMemuse ( ) ; StatsRegisterGlobalCounter ( "tcp.memuse" , StreamTcpMemuseCounter ) ; StreamTcpReassembleInit ( quiet ) ; FlowSetProtoFreeFunc ( IPPROTO_TCP , StreamTcpSessionClear ) ; if ( RunmodeIsUnittests ( ) ) { SCMutexLock ( & ssn_pool_mutex ) ; if ( ssn_pool == NULL ) { ssn_pool = PoolThreadInit ( 1 , 0 , stream_config . prealloc_sessions , sizeof ( TcpSession ) , StreamTcpSessionPoolAlloc , StreamTcpSessionPoolInit , NULL , StreamTcpSessionPoolCleanup , NULL ) ; } SCMutexUnlock ( & ssn_pool_mutex ) ; } } 