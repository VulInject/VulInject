SIGNATURE_CHECK ( mbsnrtowcs , size_t , ( wchar_t * , char const * * , size_t , size_t , mbstate_t * ) ) ; int main ( int argc , char * argv [ ] ) { mbstate_t state ; wchar_t wc ; size_t ret ; if ( setlocale ( LC_ALL , "" ) == NULL ) { return 1 ; } { const char * src ; src = "" ; ret = mbsnrtowcs ( NULL , & src , 1 , 0 , & state ) ; ASSERT ( ret == 0 ) ; ASSERT ( mbsinit ( & state ) ) ; src = "" ; ret = mbsnrtowcs ( NULL , & src , 1 , 1 , & state ) ; ASSERT ( ret == 0 ) ; ASSERT ( mbsinit ( & state ) ) ; wc = ( wchar_t ) 0xBADFACE ; src = "" ; ret = mbsnrtowcs ( & wc , & src , 1 , 0 , & state ) ; ASSERT ( ret == 0 ) ; ASSERT ( wc == ( wchar_t ) 0xBADFACE ) ; ASSERT ( mbsinit ( & state ) ) ; wc = ( wchar_t ) 0xBADFACE ; src = "" ; ret = mbsnrtowcs ( & wc , & src , 1 , 1 , & state ) ; ASSERT ( ret == 0 ) ; ASSERT ( wc == 0 ) ; ASSERT ( mbsinit ( & state ) ) ; } if ( argc > 1 ) { int unlimited ; for ( unlimited = 0 ; unlimited < 2 ; unlimited ++ ) { wchar_t buf [ BUFSIZE ] ; const char * src ; mbstate_t temp_state ; { size_t i ; for ( i = 0 ; i < BUFSIZE ; i ++ ) { buf [ i ] = ( wchar_t ) 0xBADFACE ; } } switch ( argv [ 1 ] [ 0 ] ) { case '1' : { char input [ ] "B\374\337er" ; ; memset ( & state , '\0' , sizeof ( mbstate_t ) ) ; wc = ( wchar_t ) 0xBADFACE ; ret = mbrtowc ( & wc , input , 1 , & state ) ; ASSERT ( ret == 1 ) ; ASSERT ( wc == 'B' ) ; ASSERT ( mbsinit ( & state ) ) ; input [ 0 ] = '\0' ; wc = ( wchar_t ) 0xBADFACE ; ret = mbrtowc ( & wc , input + 1 , 1 , & state ) ; ASSERT ( ret == 1 ) ; ASSERT ( wctob ( wc ) == ( unsigned char ) '\374' ) ; ASSERT ( mbsinit ( & state ) ) ; input [ 1 ] = '\0' ; src = input + 2 ; temp_state = state ; ret = mbsnrtowcs ( NULL , & src , 4 , unlimited ?BUFSIZE : 1 , & temp_state ) ; ASSERT ( ret == 3 ) ; ASSERT ( src == input + 2 ) ; ASSERT ( mbsinit ( & state ) ) ; src = input + 2 ; ret = mbsnrtowcs ( buf , & src , 4 , unlimited ?BUFSIZE : 1 , & state ) ; ASSERT ( ret == ( unlimited ?3 : 1 ) ) ; ASSERT ( src == ( unlimited ?NULL : input + 3 ) ) ; ASSERT ( wctob ( buf [ 0 ] ) == ( unsigned char ) '\337' ) ; if ( unlimited ) { ASSERT ( buf [ 1 ] == 'e' ) ; ASSERT ( buf [ 2 ] == 'r' ) ; ASSERT ( buf [ 3 ] == 0 ) ; ASSERT ( buf [ 4 ] == ( wchar_t ) 0xBADFACE ) ; } else { ASSERT ( buf [ 1 ] == ( wchar_t ) 0xBADFACE ) ; } ASSERT ( mbsinit ( & state ) ) ; } break ; case '2' : { char input [ ] "B\303\274\303\237er" ; ; memset ( & state , '\0' , sizeof ( mbstate_t ) ) ; wc = ( wchar_t ) 0xBADFACE ; ret = mbrtowc ( & wc , input , 1 , & state ) ; ASSERT ( ret == 1 ) ; ASSERT ( wc == 'B' ) ; ASSERT ( mbsinit ( & state ) ) ; input [ 0 ] = '\0' ; wc = ( wchar_t ) 0xBADFACE ; ret = mbrtowc ( & wc , input + 1 , 1 , & state ) ; ASSERT ( ret == ( size_t ) ( - 2 ) ) ; ASSERT ( wc == ( wchar_t ) 0xBADFACE ) ; ASSERT ( ! mbsinit ( & state ) ) ; input [ 1 ] = '\0' ; src = input + 2 ; temp_state = state ; ret = mbsnrtowcs ( NULL , & src , 6 , unlimited ?BUFSIZE : 2 , & temp_state ) ; ASSERT ( ret == 4 ) ; ASSERT ( src == input + 2 ) ; ASSERT ( ! mbsinit ( & state ) ) ; src = input + 2 ; ret = mbsnrtowcs ( buf , & src , 6 , unlimited ?BUFSIZE : 2 , & state ) ; ASSERT ( ret == ( unlimited ?4 : 2 ) ) ; ASSERT ( src == ( unlimited ?NULL : input + 5 ) ) ; ASSERT ( wctob ( buf [ 0 ] ) == EOF ) ; ASSERT ( wctob ( buf [ 1 ] ) == EOF ) ; if ( unlimited ) { ASSERT ( buf [ 2 ] == 'e' ) ; ASSERT ( buf [ 3 ] == 'r' ) ; ASSERT ( buf [ 4 ] == 0 ) ; ASSERT ( buf [ 5 ] == ( wchar_t ) 0xBADFACE ) ; } else { ASSERT ( buf [ 2 ] == ( wchar_t ) 0xBADFACE ) ; } ASSERT ( mbsinit ( & state ) ) ; } break ; case '3' : { char input [ ] "<\306\374\313\334\270\354>" ; ; memset ( & state , '\0' , sizeof ( mbstate_t ) ) ; wc = ( wchar_t ) 0xBADFACE ; ret = mbrtowc ( & wc , input , 1 , & state ) ; ASSERT ( ret == 1 ) ; ASSERT ( wc == '<' ) ; ASSERT ( mbsinit ( & state ) ) ; input [ 0 ] = '\0' ; wc = ( wchar_t ) 0xBADFACE ; ret = mbrtowc ( & wc , input + 1 , 2 , & state ) ; ASSERT ( ret == 2 ) ; ASSERT ( wctob ( wc ) == EOF ) ; ASSERT ( mbsinit ( & state ) ) ; input [ 1 ] = '\0' ; input [ 2 ] = '\0' ; wc = ( wchar_t ) 0xBADFACE ; ret = mbrtowc ( & wc , input + 3 , 1 , & state ) ; ASSERT ( ret == ( size_t ) ( - 2 ) ) ; ASSERT ( wc == ( wchar_t ) 0xBADFACE ) ; ASSERT ( ! mbsinit ( & state ) ) ; input [ 3 ] = '\0' ; src = input + 4 ; temp_state = state ; ret = mbsnrtowcs ( NULL , & src , 5 , unlimited ?BUFSIZE : 2 , & temp_state ) ; ASSERT ( ret == 3 ) ; ASSERT ( src == input + 4 ) ; ASSERT ( ! mbsinit ( & state ) ) ; src = input + 4 ; ret = mbsnrtowcs ( buf , & src , 5 , unlimited ?BUFSIZE : 2 , & state ) ; ASSERT ( ret == ( unlimited ?3 : 2 ) ) ; ASSERT ( src == ( unlimited ?NULL : input + 7 ) ) ; ASSERT ( wctob ( buf [ 0 ] ) == EOF ) ; ASSERT ( wctob ( buf [ 1 ] ) == EOF ) ; if ( unlimited ) { ASSERT ( buf [ 2 ] == '>' ) ; ASSERT ( buf [ 3 ] == 0 ) ; ASSERT ( buf [ 4 ] == ( wchar_t ) 0xBADFACE ) ; } else { ASSERT ( buf [ 2 ] == ( wchar_t ) 0xBADFACE ) ; } ASSERT ( mbsinit ( & state ) ) ; } break ; case '4' : { char input [ ] "B\250\271\201\060\211\070er" ; ; memset ( & state , '\0' , sizeof ( mbstate_t ) ) ; wc = ( wchar_t ) 0xBADFACE ; ret = mbrtowc ( & wc , input , 1 , & state ) ; ASSERT ( ret == 1 ) ; ASSERT ( wc == 'B' ) ; ASSERT ( mbsinit ( & state ) ) ; input [ 0 ] = '\0' ; wc = ( wchar_t ) 0xBADFACE ; ret = mbrtowc ( & wc , input + 1 , 1 , & state ) ; ASSERT ( ret == ( size_t ) ( - 2 ) ) ; ASSERT ( wc == ( wchar_t ) 0xBADFACE ) ; ASSERT ( ! mbsinit ( & state ) ) ; input [ 1 ] = '\0' ; src = input + 2 ; temp_state = state ; ret = mbsnrtowcs ( NULL , & src , 8 , unlimited ?BUFSIZE : 2 , & temp_state ) ; ASSERT ( ret == 4 ) ; ASSERT ( src == input + 2 ) ; ASSERT ( ! mbsinit ( & state ) ) ; src = input + 2 ; ret = mbsnrtowcs ( buf , & src , 8 , unlimited ?BUFSIZE : 2 , & state ) ; ASSERT ( ret == ( unlimited ?4 : 2 ) ) ; ASSERT ( src == ( unlimited ?NULL : input + 7 ) ) ; ASSERT ( wctob ( buf [ 0 ] ) == EOF ) ; ASSERT ( wctob ( buf [ 1 ] ) == EOF ) ; if ( unlimited ) { ASSERT ( buf [ 2 ] == 'e' ) ; ASSERT ( buf [ 3 ] == 'r' ) ; ASSERT ( buf [ 4 ] == 0 ) ; ASSERT ( buf [ 5 ] == ( wchar_t ) 0xBADFACE ) ; } else { ASSERT ( buf [ 2 ] == ( wchar_t ) 0xBADFACE ) ; } ASSERT ( mbsinit ( & state ) ) ; } break ; default : return 1 ; } } return 0 ; } return 1 ; } 