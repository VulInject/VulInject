static int threadfunc ( void * data ) { int i , step , err = 0 , insert_retries = 0 ; struct thread_data * tdata = data ; up ( & prestart_sem ) ; if ( down_interruptible ( & startup_sem ) ) { pr_err ( "  thread[%d]: down_interruptible failed\n" , tdata -> id ) ; } for ( i = 0 ; i < entries ; i ++ ) { tdata -> objs [ i ] . value = ( tdata -> id << 16 ) | i ; err = insert_retry ( & ht , & tdata -> objs [ i ] . node , test_rht_params ) ; if ( err > 0 ) { insert_retries += err ; } if ( err ) { pr_err ( "  thread[%d]: rhashtable_insert_fast failed\n" , tdata -> id ) ; out } } if ( insert_retries ) { pr_info ( "  thread[%d]: %u insertions retried due to memory pressure\n" , tdata -> id , insert_retries ) ; } err = thread_lookup_test ( tdata ) ; if ( err ) { pr_err ( "  thread[%d]: rhashtable_lookup_test failed\n" , tdata -> id ) ; out } for ( step = 10 ; step > 0 ; step -- ) { for ( i = 0 ; i < entries ; i += step ) { if ( tdata -> objs [ i ] . value == TEST_INSERT_FAIL ) { continue ; } err = rhashtable_remove_fast ( & ht , & tdata -> objs [ i ] . node , test_rht_params ) ; if ( err ) { pr_err ( "  thread[%d]: rhashtable_remove_fast failed\n" , tdata -> id ) ; out } tdata -> objs [ i ] . value = TEST_INSERT_FAIL ; cond_resched ( ) ; } err = thread_lookup_test ( tdata ) ; if ( err ) { pr_err ( "  thread[%d]: rhashtable_lookup_test (2) failed\n" , tdata -> id ) ; out } } out while ( ! kthread_should_stop ( ) ) { set_current_state ( TASK_INTERRUPTIBLE , NULL ) ; schedule ( ) ; } return err ; } 