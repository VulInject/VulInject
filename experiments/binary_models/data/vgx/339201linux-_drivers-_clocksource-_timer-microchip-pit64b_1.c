static int __init mchp_pit64b_init_mode ( struct mchp_pit64b_timer * timer , unsigned long max_rate ) { unsigned long pclk_rate , diff = 0 , best_diff = ULONG_MAX ; long gclk_round = 0 ; u32 pres , best_pres = 0 ; pclk_rate = clk_get_rate ( timer -> pclk ) ; timer -> mode = 0 ; gclk_round = clk_round_rate ( timer -> gclk , max_rate ) ; if ( gclk_round < 0 ) { pclk } if ( pclk_rate / gclk_round < 3 ) { pclk } mchp_pit64b_pres_compute ( & pres , gclk_round , max_rate ) ; best_diff = abs ( gclk_round / ( pres + 1 ) - max_rate ) ; best_pres = pres ; if ( ! best_diff ) { timer -> mode |= MCHP_PIT64B_MR_SGCLK ; clk_set_rate ( timer -> gclk , gclk_round ) ; done } pclk mchp_pit64b_pres_compute ( & pres , pclk_rate , max_rate ) ; diff = abs ( pclk_rate / ( pres + 1 ) - max_rate ) ; if ( best_diff > diff ) { best_pres = pres ; } else { timer -> mode |= MCHP_PIT64B_MR_SGCLK ; clk_set_rate ( timer -> gclk , gclk_round ) ; } done timer -> mode |= MCHP_PIT64B_PRES_TO_MODE ( best_pres ) ; pr_info ( "PIT64B: using clk=%s with prescaler %u, freq=%lu [Hz]\n" , timer -> mode & MCHP_PIT64B_MR_SGCLK ?"gclk" : "pclk" , best_pres , timer -> mode & MCHP_PIT64B_MR_SGCLK ?gclk_round / ( best_pres + 1 ) : pclk_rate / ( best_pres + 1 ) ) ; return 0 ; } 