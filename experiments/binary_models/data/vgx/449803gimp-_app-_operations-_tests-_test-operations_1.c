process_operations ( ) { GType * operations ; gboolean result = TRUE ; guint count ; gint i ; operations = g_type_children ( type , & count ) ; if ( ! operations ) { g_free ( operations ) ; return TRUE ; } for ( i = 0 ; i < count ; i ++ ) { GeglOperationClass * operation_class ; const gchar * image , * xml ; operation_class = g_type_class_ref ( operations [ i ] ) ; image = gegl_operation_class_get_key ( operation_class , "reference-image" ) ; xml = gegl_operation_class_get_key ( operation_class , "reference-composition" ) ; if ( image && xml ) { gchar * root = g_get_current_dir ( ) ; gchar * xml_root = g_build_path ( G_DIR_SEPARATOR_S , root , DATA_DIR , NULL ) ; gchar * image_path = g_build_path ( G_DIR_SEPARATOR_S , root , DATA_DIR , image , NULL ) ; gchar * output_path = g_build_path ( G_DIR_SEPARATOR_S , root , OUTPUT_DIR , image , NULL ) ; GeglNode * composition , * output ; g_printf ( "%s: " , gegl_operation_class_get_key ( operation_class , "name" ) ) ; composition = gegl_node_new_from_xml ( xml , xml_root ) ; if ( ! composition ) { g_printerr ( "\nComposition graph is flawed\n" ) ; result = FALSE ; } else { output = gegl_node_new_child ( composition , "operation" , "gegl:save" , "path" , output_path , NULL ) ; gegl_node_connect_to ( composition , "output" , output , "input" ) ; gegl_node_process ( output ) ; if ( image_compare ( output_path , image_path ) ) { g_printf ( "PASS\n" ) ; result = result && TRUE ; } else { g_printf ( "FAIL\n" ) ; result = result && FALSE ; } } g_object_unref ( composition ) ; g_free ( xml_root ) ; g_free ( image_path ) ; g_free ( output_path ) ; } result = result && process_operations ( operations [ i ] ) ; } g_free ( operations ) ; return result ; } 