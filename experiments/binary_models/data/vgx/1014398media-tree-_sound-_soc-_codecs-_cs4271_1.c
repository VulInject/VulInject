MODULE_DEVICE_TABLE ( of , cs4271_dt_ids ) ; EXPORT_SYMBOL_GPL ( cs4271_dt_ids ) ; static int cs4271_codec_probe ( struct snd_soc_codec * codec ) { struct cs4271_private * cs4271 = snd_soc_codec_get_drvdata ( codec ) ; struct cs4271_platform_data * cs4271plat = codec -> dev -> platform_data ; int ret ; bool amutec_eq_bmutec = false ; if ( of_match_device ( cs4271_dt_ids , codec -> dev ) ) { if ( of_get_property ( codec -> dev -> of_node , "cirrus,amutec-eq-bmutec" , NULL ) ) { amutec_eq_bmutec = true ; } if ( of_get_property ( codec -> dev -> of_node , "cirrus,enable-soft-reset" , NULL ) ) { cs4271 -> enable_soft_reset = true ; } } ret = regulator_bulk_enable ( ARRAY_SIZE ( cs4271 -> supplies ) , cs4271 -> supplies ) ; if ( ret < 0 ) { dev_err ( codec -> dev , "Failed to enable regulators: %d\n" , ret ) ; return ret ; } if ( cs4271plat ) { amutec_eq_bmutec = cs4271plat -> amutec_eq_bmutec ; cs4271 -> enable_soft_reset = cs4271plat -> enable_soft_reset ; } cs4271_reset ( codec ) ; ret = regcache_sync ( cs4271 -> regmap ) ; ret = regmap_update_bits ( cs4271 -> regmap , CS4271_MODE2 , CS4271_MODE2_PDN | CS4271_MODE2_CPEN , CS4271_MODE2_PDN | CS4271_MODE2_CPEN ) ; if ( ret < 0 ) { return ret ; } ret = regmap_update_bits ( cs4271 -> regmap , CS4271_MODE2 , CS4271_MODE2_PDN , 0 ) ; if ( ret < 0 ) { return ret ; } udelay ( 85 ) ; if ( amutec_eq_bmutec ) { regmap_update_bits ( cs4271 -> regmap , CS4271_MODE2 , CS4271_MODE2_MUTECAEQUB , CS4271_MODE2_MUTECAEQUB ) ; } return 0 ; } 