int set_mntpt ( entity_t * ep ) { static mnt { struct mnt * m_next ; char * m_mntpt ; ulong_t m_fsid ; } , * mnt_list = NULL struct mnt * mntp ; struct statvfs64 statvfsbuf ; char * original_name = ep -> e_name ; char path [ PATH_MAX ] ; if ( original_name == NULL ) { return ( 1 ) ; } if ( mnt_list == NULL ) { FILE * fp ; struct mnttab mnttab ; if ( ( fp = fopen ( MNTTAB , "r" ) ) == NULL ) { perror ( MNTTAB ) ; return ( 1 ) ; } resetmnttab ( fp ) ; while ( getmntent ( fp , & mnttab ) == 0 ) { if ( ( mntp = malloc ( sizeof ( * mntp ) ) ) == NULL ) { perror ( "malloc() mount list" ) ; return ( 1 ) ; } mntp -> m_mntpt = strdup ( mnttab . mnt_mountp ) ; mntp -> m_next = mnt_list ; mnt_list = mntp ; } ( void ) fclose ( fp ) ; } if ( realpath ( original_name , path ) == NULL ) { perror ( original_name ) ; return ( 1 ) ; } for ( mntp = mnt_list ; mntp ; mntp = mntp -> m_next ) { if ( strncmp ( path , mntp -> m_mntpt , strlen ( mntp -> m_mntpt ) ) == 0 ) { if ( mntp -> m_fsid == 0 ) { if ( statvfs64 ( mntp -> m_mntpt , & statvfsbuf ) ) { continue ; } else { mntp -> m_fsid = statvfsbuf . f_fsid ; } } if ( ep -> e_fsid != mntp -> m_fsid ) { continue ; } break ; } } if ( mntp == NULL ) { ( void ) fprintf ( stderr , gettext ( "Can't find mount point for %s\n" ) , path ) ; return ( 1 ) ; } ep -> e_name = strdup ( mntp -> m_mntpt ) ; return ( 0 ) ; } 