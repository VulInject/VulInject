struct VAR1 * FUN1 ( VAR2 * VAR3 , struct VAR1 * VAR4 ) static void FUN2 ( VAR2 * VAR3 , ptrdiff_t VAR5 , each_backtrace_func VAR6 , void * VAR7 ) { if ( VAR5 >= VAR3 -> VAR8 -> VAR9 - VAR3 -> VAR8 -> VAR10 ) { VAR5 = 10 ; } for ( ptrdiff_t VAR11 = VAR5 ; VAR11 >= 0 ; VAR11 -- ) { struct backtrace_location VAR12 ; VAR13 * VAR14 ; const VAR15 * VAR16 = 0 ; const VAR17 * VAR18 ; uint32_t VAR19 ; VAR14 = & VAR3 -> VAR8 -> VAR10 [ VAR11 ] ; if ( ! VAR14 -> VAR20 || FUN3 ( VAR14 -> VAR20 ) ) { if ( ! VAR14 -> VAR21 ) { continue ; } VAR12 . VAR22 = - 1 ; VAR19 = 0 ; } else { VAR16 = VAR14 -> VAR20 -> VAR23 . VAR16 ; if ( VAR3 -> VAR8 -> VAR10 [ VAR11 ] . VAR18 ) { VAR18 = & VAR3 -> VAR8 -> VAR10 [ VAR11 ] . VAR18 [ - 1 ] ; } else { continue ; } VAR19 = ( VAR24 ) ( VAR18 - VAR16 -> VAR25 ) ; FUN4 ( VAR3 , VAR16 , VAR19 , & VAR12 . VAR22 , & VAR12 . VAR26 ) ; } VAR12 . VAR27 = VAR14 -> VAR21 ; if ( VAR12 . VAR22 == - 1 ) { for ( ptrdiff_t VAR28 = VAR11 - 1 ; VAR28 >= 0 ; VAR28 -- ) { VAR14 = & VAR3 -> VAR8 -> VAR10 [ VAR28 ] ; if ( ! VAR14 -> VAR20 ) { continue ; } if ( FUN3 ( VAR14 -> VAR20 ) ) { continue ; } VAR16 = VAR14 -> VAR20 -> VAR23 . VAR16 ; if ( ! VAR16 ) { continue ; } if ( VAR3 -> VAR8 -> VAR10 [ VAR28 ] . VAR18 ) { VAR18 = & VAR3 -> VAR8 -> VAR10 [ VAR28 ] . VAR18 [ - 1 ] ; } else { continue ; } VAR19 = ( VAR24 ) ( VAR18 - VAR16 -> VAR25 ) ; if ( FUN4 ( VAR3 , VAR16 , VAR19 , & VAR12 . VAR22 , & VAR12 . VAR26 ) ) { break ; } } } if ( ! VAR12 . VAR26 ) { VAR12 . VAR26 = "" ; } FUN5 ( VAR3 , & VAR12 , VAR7 ) ; } }