static int fec_enet_mii_probe ( struct net_device * ndev ) { struct fec_enet_private * fep = netdev_priv ( ndev ) ; struct phy_device * phy_dev = NULL ; char mdio_bus_id [ MII_BUS_ID_SIZE ] ; char phy_name [ MII_BUS_ID_SIZE + 3 ] ; int phy_id ; int dev_id = fep -> dev_id ; if ( fep -> phy_node ) { phy_dev = of_phy_connect ( ndev , fep -> phy_node , & fec_enet_adjust_link , 0 , fep -> phy_interface ) ; if ( ! phy_dev ) { return - ENODEV ; } } else { for ( phy_id = 0 ; ( phy_id < PHY_MAX_ADDR ) ; phy_id ++ ) { if ( dev_id -- ) { continue ; } strlcpy ( mdio_bus_id , fep -> mii_bus -> id , MII_BUS_ID_SIZE ) ; break ; } if ( phy_id >= PHY_MAX_ADDR ) { netdev_info ( ndev , "no PHY, assuming direct connection to switch\n" ) ; strlcpy ( mdio_bus_id , "fixed-0" , MII_BUS_ID_SIZE ) ; phy_id = 0 ; } snprintf ( phy_name , sizeof ( phy_name ) , PHY_ID_FMT , mdio_bus_id , phy_id ) ; phy_dev = phy_connect ( ndev , phy_name , & fec_enet_adjust_link , fep -> phy_interface ) ; } if ( IS_ERR ( phy_dev ) ) { netdev_err ( ndev , "could not attach to PHY\n" ) ; return PTR_ERR ( phy_dev ) ; } if ( fep -> quirks & FEC_QUIRK_HAS_GBIT ) { phy_dev -> supported &= PHY_GBIT_FEATURES ; phy_dev -> supported &= ~ SUPPORTED_1000baseT_Half ; phy_dev -> supported |= SUPPORTED_Pause ; } else { phy_dev -> supported &= PHY_BASIC_FEATURES ; } phy_dev -> advertising = phy_dev -> supported ; fep -> link = 0 ; fep -> full_duplex = 0 ; phy_attached_info ( phy_dev ) ; return 0 ; } 