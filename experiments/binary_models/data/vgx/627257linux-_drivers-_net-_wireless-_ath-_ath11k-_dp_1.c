int ath11k_dp_srng_setup ( struct ath11k_base * ab , struct dp_srng * ring , enum hal_ring_type type , int ring_num , int mac_id , int num_entries ) { struct hal_srng_params params = { 0 } ; int entry_sz = ath11k_hal_srng_get_entrysize ( ab , type ) ; int max_entries = ath11k_hal_srng_get_max_entries ( ab , type ) ; int ret ; bool cached = false ; if ( max_entries < 0 || entry_sz < 0 ) { return - EINVAL ; } if ( num_entries > max_entries ) { num_entries = max_entries ; } ring -> size = ( num_entries * entry_sz ) + HAL_RING_BASE_ALIGN - 1 ; if ( ab -> hw_params . alloc_cacheable_memory ) { switch ( type ) { case HAL_REO_DST : case HAL_WBM2SW_RELEASE : cached = true ; break ; default : cached = false ; } if ( cached ) { ring -> vaddr_unaligned = kmalloc ( ring -> size , GFP_KERNEL ) ; ring -> paddr_unaligned = virt_to_phys ( ring -> vaddr_unaligned ) ; } } if ( ! cached ) { ring -> vaddr_unaligned = dma_alloc_coherent ( ab -> dev , ring -> size , & ring -> paddr_unaligned , GFP_KERNEL ) ; } if ( ! ring -> vaddr_unaligned ) { return - ENOMEM ; } ring -> vaddr = PTR_ALIGN ( ring -> vaddr_unaligned , HAL_RING_BASE_ALIGN ) ; ring -> paddr = ring -> paddr_unaligned + ( ( unsigned long ) ring -> vaddr - ( unsigned long ) ring -> vaddr_unaligned ) ; params . ring_base_vaddr = ring -> vaddr ; params . ring_base_paddr = ring -> paddr ; params . num_entries = num_entries ; ath11k_dp_srng_msi_setup ( ab , & params , type , ring_num + mac_id ) ; switch ( type ) { case HAL_REO_DST : params . intr_batch_cntr_thres_entries = HAL_SRNG_INT_BATCH_THRESHOLD_RX ; params . intr_timer_thres_us = HAL_SRNG_INT_TIMER_THRESHOLD_RX ; break ; case HAL_RXDMA_BUF : case HAL_RXDMA_MONITOR_BUF : case HAL_RXDMA_MONITOR_STATUS : params . low_threshold = num_entries >> 3 ; params . flags |= HAL_SRNG_FLAGS_LOW_THRESH_INTR_EN ; params . intr_batch_cntr_thres_entries = 0 ; params . intr_timer_thres_us = HAL_SRNG_INT_TIMER_THRESHOLD_RX ; break ; case HAL_WBM2SW_RELEASE : if ( ring_num < 3 ) { params . intr_batch_cntr_thres_entries = HAL_SRNG_INT_BATCH_THRESHOLD_TX ; params . intr_timer_thres_us = HAL_SRNG_INT_TIMER_THRESHOLD_TX ; break ; } fallthrough ; case HAL_REO_EXCEPTION : case HAL_REO_REINJECT : case HAL_REO_CMD : case HAL_REO_STATUS : case HAL_TCL_DATA : case HAL_TCL_CMD : case HAL_TCL_STATUS : case HAL_WBM_IDLE_LINK : case HAL_SW2WBM_RELEASE : case HAL_RXDMA_DST : case HAL_RXDMA_MONITOR_DST : case HAL_RXDMA_MONITOR_DESC : params . intr_batch_cntr_thres_entries = HAL_SRNG_INT_BATCH_THRESHOLD_OTHER ; params . intr_timer_thres_us = HAL_SRNG_INT_TIMER_THRESHOLD_OTHER ; break ; case HAL_RXDMA_DIR_BUF : break ; default : ath11k_warn ( ab , "Not a valid ring type in dp :%d\n" , type ) ; return - EINVAL ; } if ( cached ) { params . flags |= HAL_SRNG_FLAGS_CACHED ; ring -> cached = 1 ; } ret = ath11k_hal_srng_setup ( ab , type , ring_num , mac_id , & params ) ; if ( ret < 0 ) { ath11k_warn ( ab , "failed to setup srng: %d ring_id %d\n" , ret , ring_num ) ; return ret ; } ring -> ring_id = ret ; return 0 ; } 