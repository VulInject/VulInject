xmlNode * readCibXmlFile ( const char * dir , const char * file , gboolean discard_status ) { struct dirent * * namelist = NULL ; int lpc = 0 ; char * sigfile = NULL ; char * sigfilepath = NULL ; char * filename = NULL ; const char * name = NULL ; const char * value = NULL ; const char * validation = NULL ; const char * use_valgrind = getenv ( "PCMK_valgrind_enabled" ) ; xmlNode * root = NULL ; xmlNode * status = NULL ; sigfile = crm_strdup_printf ( "%s.sig" , file ) ; if ( pcmk__daemon_can_write ( dir , file ) == FALSE || pcmk__daemon_can_write ( dir , sigfile ) == FALSE ) { cib_status = - EACCES ; return NULL ; } filename = crm_strdup_printf ( "%s/%s" , dir , file ) ; sigfilepath = crm_strdup_printf ( "%s/%s" , dir , sigfile ) ; free ( sigfile ) ; cib_status = pcmk_ok ; root = retrieveCib ( filename , sigfilepath ) ; free ( sigfilepath ) ; if ( root == NULL ) { crm_warn ( "Primary configuration corrupt or unusable, trying backups in %s" , cib_root ) ; lpc = scandir ( cib_root , & namelist , cib_archive_filter , cib_archive_sort ) ; if ( lpc < 0 ) { crm_perror ( LOG_NOTICE , "scandir(%s) failed" , cib_root ) ; } } while ( root == NULL && lpc > 1 ) { crm_debug ( "Testing %d candidates" , lpc ) ; lpc -- ; filename = crm_strdup_printf ( "%s/%s" , cib_root , namelist [ lpc ] -> d_name ) ; sigfile = crm_strdup_printf ( "%s.sig" , filename ) ; crm_info ( "Reading cluster configuration file %s (digest: %s)" , filename , sigfile ) ; if ( cib_file_read_and_verify ( filename , sigfile , & root ) < 0 ) { crm_warn ( "Continuing but %s will NOT be used." , filename ) ; } else { crm_notice ( "Continuing with last valid configuration archive: %s" , filename ) ; } free ( namelist [ lpc ] ) ; free ( filename ) ; free ( sigfile ) ; } free ( namelist ) ; if ( root == NULL ) { root = createEmptyCib ( 0 ) ; crm_warn ( "Continuing with an empty configuration." ) ; } if ( cib_writes_enabled && use_valgrind && ( crm_is_true ( use_valgrind ) || strstr ( use_valgrind , "pacemaker-based" ) ) ) { cib_writes_enabled = FALSE ; crm_err ( "*** Disabling disk writes to avoid confusing Valgrind ***" ) ; } status = find_xml_node ( root , XML_CIB_TAG_STATUS , FALSE ) ; if ( discard_status && status != NULL ) { free_xml ( status ) ; status = NULL ; } if ( status == NULL ) { create_xml_node ( root , XML_CIB_TAG_STATUS ) ; } name = XML_ATTR_GENERATION_ADMIN ; value = crm_element_value ( root , name ) ; if ( value == NULL ) { crm_warn ( "No value for %s was specified in the configuration." , name ) ; crm_warn ( "The recommended course of action is to shutdown," " run crm_verify and fix any errors it reports." ) ; crm_warn ( "We will default to zero and continue but may get" " confused about which configuration to use if" " multiple nodes are powered up at the same time." ) ; crm_xml_add_int ( root , name , 0 ) ; } name = XML_ATTR_GENERATION ; value = crm_element_value ( root , name ) ; if ( value == NULL ) { crm_xml_add_int ( root , name , 0 ) ; } name = XML_ATTR_NUMUPDATES ; value = crm_element_value ( root , name ) ; if ( value == NULL ) { crm_xml_add_int ( root , name , 0 ) ; } xml_remove_prop ( root , XML_ATTR_DC_UUID ) ; if ( discard_status ) { crm_log_xml_trace ( root , "[on-disk]" ) ; } validation = crm_element_value ( root , XML_ATTR_VALIDATION ) ; if ( validate_xml ( root , NULL , TRUE ) == FALSE ) { crm_err ( "CIB does not validate with %s" , pcmk__s ( validation , "no schema specified" ) ) ; cib_status = - pcmk_err_schema_validation ; } if ( validation == NULL ) { int version = 0 ; update_validation ( & root , & version , 0 , FALSE , FALSE ) ; if ( version > 0 ) { crm_notice ( "Enabling %s validation on" " the existing (sane) configuration" , get_schema_name ( version ) ) ; } else { crm_err ( "CIB does not validate with any known schema" ) ; cib_status = - pcmk_err_schema_validation ; } } return root ; } 