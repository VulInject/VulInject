bool query_is_distinct_for ( Query * query , List * colnos , List * opids ) { ListCell * l ; Oid opid ; Assert ( list_length ( colnos ) == list_length ( opids ) ) ; if ( query -> distinctClause ) { ( l query -> distinctClause ; ) { SortGroupClause * sgc = ( SortGroupClause * ) lfirst ( l ) ; TargetEntry * tle = get_sortgroupclause_tle ( sgc , query -> targetList ) ; opid = distinct_col_search ( tle -> resno , colnos , opids ) ; if ( ! OidIsValid ( opid ) || ! equality_ops_are_compatible ( opid , sgc -> eqop ) ) { break ; } } } if ( query -> hasTargetSRFs ) { return false ; } if ( query -> groupClause && ! query -> groupingSets ) { ( l query -> groupClause ; ) { SortGroupClause * sgc = ( SortGroupClause * ) lfirst ( l ) ; TargetEntry * tle = get_sortgroupclause_tle ( sgc , query -> targetList ) ; opid = distinct_col_search ( tle -> resno , colnos , opids ) ; if ( ! OidIsValid ( opid ) || ! equality_ops_are_compatible ( opid , sgc -> eqop ) ) { break ; } } if ( l == NULL ) { return true ; } } if ( query -> groupingSets ) { if ( query -> groupClause ) { return false ; } if ( list_length ( query -> groupingSets ) == 1 && ( ( GroupingSet * ) linitial ( query -> groupingSets ) ) -> kind == GROUPING_SET_EMPTY ) { return true ; } else { return false ; } } else { if ( query -> hasAggs || query -> havingQual ) { return true ; } } if ( query -> setOperations ) { SetOperationStmt * topop = castNode ( SetOperationStmt , query -> setOperations ) ; Assert ( topop -> op != SETOP_NONE ) ; if ( ! topop -> all ) { ListCell * lg ; lg = list_head ( topop -> groupClauses ) ; ( l query -> targetList ; ) { TargetEntry * tle = ( TargetEntry * ) lfirst ( l ) ; SortGroupClause * sgc ; if ( tle -> resjunk ) { continue ; } Assert ( lg != NULL ) ; sgc = ( SortGroupClause * ) lfirst ( lg ) ; lg = lnext ( topop -> groupClauses , lg ) ; opid = distinct_col_search ( tle -> resno , colnos , opids ) ; if ( ! OidIsValid ( opid ) || ! equality_ops_are_compatible ( opid , sgc -> eqop ) ) { break ; } } if ( l == NULL ) { return true ; } } } return false ; } 