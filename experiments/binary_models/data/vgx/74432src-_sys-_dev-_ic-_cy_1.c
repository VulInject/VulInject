int cy_intr ( void * arg ) { struct cy_softc * sc = arg ; struct cy_port * cy ; int cy_chip , stat ; int int_serviced = - 1 ; for ( cy_chip = 0 ; cy_chip < sc -> sc_nr_cd1400s ; cy_chip ++ ) { stat = cd_read_reg_sc ( sc , cy_chip , CD1400_SVRR ) ; if ( ISSET ( stat , CD1400_SVRR_RXRDY ) ) { u_char save_car , save_rir , serv_type ; u_char line_stat , recv_data , n_chars ; u_char * buf_p ; save_rir = cd_read_reg_sc ( sc , cy_chip , CD1400_RIR ) ; save_car = cd_read_reg_sc ( sc , cy_chip , CD1400_CAR ) ; cd_write_reg_sc ( sc , cy_chip , CD1400_CAR , save_rir ) ; serv_type = cd_read_reg_sc ( sc , cy_chip , CD1400_RIVR ) ; cy = & sc -> sc_ports [ serv_type >> 3 ] ; cy -> cy_rx_int_count ++ ; buf_p = cy -> cy_ibuf_wr_ptr ; if ( ISSET ( serv_type , CD1400_RIVR_EXCEPTION ) ) { line_stat = cd_read_reg ( cy , CD1400_RDSR ) ; recv_data = cd_read_reg ( cy , CD1400_RDSR ) ; if ( cy -> cy_tty == NULL || ! ISSET ( cy -> cy_tty -> t_state , TS_ISOPEN ) ) { end_rx_serv } printf ( "%s port %d recv exception, " "line_stat 0x%x, char 0x%x\n" , sc -> sc_dev . dv_xname , cy -> cy_port_num , line_stat , recv_data ) ; if ( ISSET ( line_stat , CD1400_RDSR_OE ) ) { cy -> cy_fifo_overruns ++ ; } * buf_p ++ = line_stat ; * buf_p ++ = recv_data ; if ( buf_p == cy -> cy_ibuf_end ) { buf_p = cy -> cy_ibuf ; } if ( buf_p == cy -> cy_ibuf_rd_ptr ) { if ( buf_p == cy -> cy_ibuf ) { buf_p = cy -> cy_ibuf_end ; } buf_p -= 2 ; cy -> cy_ibuf_overruns ++ ; } sc -> sc_events = 1 ; } else { n_chars = cd_read_reg ( cy , CD1400_RDCR ) ; if ( cy -> cy_tty == NULL || ! ISSET ( cy -> cy_tty -> t_state , TS_ISOPEN ) ) { while ( n_chars -- ) { cd_read_reg ( cy , CD1400_RDSR ) ; } end_rx_serv } printf ( "%s port %d receive ok %d chars\n" , sc -> sc_dev . dv_xname , cy -> cy_port_num , n_chars ) ; while ( n_chars -- ) { * buf_p ++ = 0 ; * buf_p ++ = cd_read_reg ( cy , CD1400_RDSR ) ; if ( buf_p == cy -> cy_ibuf_end ) { buf_p = cy -> cy_ibuf ; } if ( buf_p == cy -> cy_ibuf_rd_ptr ) { if ( buf_p == cy -> cy_ibuf ) { buf_p = cy -> cy_ibuf_end ; } buf_p -= 2 ; cy -> cy_ibuf_overruns ++ ; break ; } } sc -> sc_events = 1 ; } cy -> cy_ibuf_wr_ptr = buf_p ; if ( ISSET ( cy -> cy_tty -> t_cflag , CRTSCTS ) ) { int bf ; bf = buf_p - cy -> cy_ibuf_rd_ptr ; if ( bf < 0 ) { bf += IBUF_SIZE ; } if ( bf > ( IBUF_SIZE / 2 ) ) { cd_write_reg ( cy , CD1400_MSVR1 , 0 ) ; } } end_rx_serv cd_write_reg ( cy , CD1400_RIR , save_rir & 0x3f ) ; cd_write_reg ( cy , CD1400_CAR , save_car ) ; int_serviced = 1 ; } if ( ISSET ( stat , CD1400_SVRR_MDMCH ) ) { u_char save_car , save_mir , serv_type , modem_stat ; save_mir = cd_read_reg_sc ( sc , cy_chip , CD1400_MIR ) ; save_car = cd_read_reg_sc ( sc , cy_chip , CD1400_CAR ) ; cd_write_reg_sc ( sc , cy_chip , CD1400_CAR , save_mir ) ; serv_type = cd_read_reg_sc ( sc , cy_chip , CD1400_MIVR ) ; cy = & sc -> sc_ports [ serv_type >> 3 ] ; cy -> cy_modem_int_count ++ ; modem_stat = cd_read_reg ( cy , CD1400_MSVR2 ) ; printf ( "%s port %d modem line change, new stat 0x%x\n" , sc -> sc_dev . dv_xname , cy -> cy_port_num , modem_stat ) ; if ( ISSET ( ( cy -> cy_carrier_stat ^ modem_stat ) , CD1400_MSVR2_CD ) ) { SET ( cy -> cy_flags , CYF_CARRIER_CHANGED ) ; sc -> sc_events = 1 ; } cy -> cy_carrier_stat = modem_stat ; cd_write_reg ( cy , CD1400_MIR , save_mir & 0x3f ) ; cd_write_reg ( cy , CD1400_CAR , save_car ) ; int_serviced = 1 ; } if ( ISSET ( stat , CD1400_SVRR_TXRDY ) ) { u_char save_car , save_tir , serv_type , count , ch ; struct tty * tp ; save_tir = cd_read_reg_sc ( sc , cy_chip , CD1400_TIR ) ; save_car = cd_read_reg_sc ( sc , cy_chip , CD1400_CAR ) ; cd_write_reg_sc ( sc , cy_chip , CD1400_CAR , save_tir ) ; serv_type = cd_read_reg_sc ( sc , cy_chip , CD1400_TIVR ) ; cy = & sc -> sc_ports [ serv_type >> 3 ] ; cy -> cy_tx_int_count ++ ; printf ( "%s port %d tx service\n" , sc -> sc_dev . dv_xname , cy -> cy_port_num ) ; tp = cy -> cy_tty ; if ( tp == NULL || ISSET ( cy -> cy_flags , CYF_STOP ) ) { txdone } count = 0 ; if ( ISSET ( cy -> cy_flags , CYF_SEND_NUL ) ) { cd_write_reg ( cy , CD1400_TDR , 0 ) ; cd_write_reg ( cy , CD1400_TDR , 0 ) ; count += 2 ; CLR ( cy -> cy_flags , CYF_SEND_NUL ) ; } if ( tp -> t_outq . c_cc > 0 ) { SET ( tp -> t_state , TS_BUSY ) ; while ( tp -> t_outq . c_cc > 0 && count < CD1400_TX_FIFO_SIZE ) { ch = getc ( & tp -> t_outq ) ; if ( ch == 0 ) { if ( count >= CD1400_TX_FIFO_SIZE - 2 ) { SET ( cy -> cy_flags , CYF_SEND_NUL ) ; break ; } cd_write_reg ( cy , CD1400_TDR , ch ) ; count ++ ; } cd_write_reg ( cy , CD1400_TDR , ch ) ; count ++ ; } } else { if ( ISSET ( cy -> cy_flags , CYF_START_BREAK ) ) { cd_write_reg ( cy , CD1400_TDR , 0 ) ; cd_write_reg ( cy , CD1400_TDR , 0x81 ) ; CLR ( cy -> cy_flags , CYF_START_BREAK ) ; } if ( ISSET ( cy -> cy_flags , CYF_END_BREAK ) ) { cd_write_reg ( cy , CD1400_TDR , 0 ) ; cd_write_reg ( cy , CD1400_TDR , 0x83 ) ; CLR ( cy -> cy_flags , CYF_END_BREAK ) ; } } if ( tp -> t_outq . c_cc == 0 ) { txdone cd_write_reg ( cy , CD1400_SRER , cd_read_reg ( cy , CD1400_SRER ) & ~ CD1400_SRER_TXRDY ) ; CLR ( cy -> cy_flags , CYF_STOP ) ; CLR ( tp -> t_state , TS_BUSY ) ; } if ( tp -> t_outq . c_cc <= tp -> t_lowat ) { SET ( cy -> cy_flags , CYF_START ) ; sc -> sc_events = 1 ; } cd_write_reg ( cy , CD1400_TIR , save_tir & 0x3f ) ; cd_write_reg ( cy , CD1400_CAR , save_car ) ; int_serviced = 1 ; } } bus_space_write_1 ( sc -> sc_memt , sc -> sc_memh , CY_CLEAR_INTR << sc -> sc_bustype , 0 ) ; return ( int_serviced ) ; } 