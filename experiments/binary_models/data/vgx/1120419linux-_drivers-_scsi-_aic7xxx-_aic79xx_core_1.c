static void ahd_loadseq ( struct ahd_softc * ahd ) { struct cs cs_table [ NUM_CRITICAL_SECTIONS ] ; u_int begin_set [ NUM_CRITICAL_SECTIONS ] ; u_int end_set [ NUM_CRITICAL_SECTIONS ] ; const struct patch * cur_patch ; u_int cs_count ; u_int cur_cs ; u_int i ; int downloaded ; u_int skip_addr ; u_int sg_prefetch_cnt ; u_int sg_prefetch_cnt_limit ; u_int sg_prefetch_align ; u_int sg_size ; u_int cacheline_mask ; uint8_t download_consts [ DOWNLOAD_CONST_COUNT ] ; if ( bootverbose ) { printk ( "%s: Downloading Sequencer Program..." , ahd_name ( ahd ) ) ; } cs_count = 0 ; cur_cs = 0 ; memset ( end_set , 0 , sizeof ( end_set ) ) ; sg_prefetch_align = ahd -> pci_cachesize ; if ( sg_prefetch_align == 0 ) { sg_prefetch_align = 8 ; } while ( powerof2 ( sg_prefetch_align ) == 0 ) { sg_prefetch_align -- ; } cacheline_mask = sg_prefetch_align - 1 ; if ( sg_prefetch_align > CCSGADDR_MAX / 2 ) { sg_prefetch_align = CCSGADDR_MAX / 2 ; } sg_prefetch_cnt = sg_prefetch_align ; sg_size = sizeof ( ahd_dma_seg ) ; if ( ( ahd -> flags & AHD_64BIT_ADDRESSING ) != 0 ) { sg_size = sizeof ( ahd_dma64_seg ) ; } while ( sg_prefetch_cnt < sg_size ) { sg_prefetch_cnt += sg_prefetch_align ; } if ( ( sg_prefetch_align % sg_size ) != 0 && ( sg_prefetch_cnt < CCSGADDR_MAX ) ) { sg_prefetch_cnt += sg_prefetch_align ; } sg_prefetch_cnt_limit = - ( sg_prefetch_cnt - sg_size + 1 ) ; download_consts [ SG_PREFETCH_CNT ] = sg_prefetch_cnt ; download_consts [ SG_PREFETCH_CNT_LIMIT ] = sg_prefetch_cnt_limit ; download_consts [ SG_PREFETCH_ALIGN_MASK ] = ~ ( sg_prefetch_align - 1 ) ; download_consts [ SG_PREFETCH_ADDR_MASK ] = ( sg_prefetch_align - 1 ) ; download_consts [ SG_SIZEOF ] = sg_size ; download_consts [ PKT_OVERRUN_BUFOFFSET ] = ( ahd -> overrun_buf - ( uint8_t * ) ahd -> qoutfifo ) / 256 ; download_consts [ SCB_TRANSFER_SIZE ] = SCB_TRANSFER_SIZE_1BYTE_LUN ; download_consts [ CACHELINE_MASK ] = cacheline_mask ; cur_patch = patches ; downloaded = 0 ; skip_addr = 0 ; ahd_outb ( ahd , SEQCTL0 , PERRORDIS | FAILDIS | FASTMODE | LOADRAM ) ; ahd_outw ( ahd , PRGMCNT , 0 ) ; for ( i = 0 ; i < sizeof ( seqprog ) / 4 ; i ++ ) { if ( ahd_check_patch ( ahd , & cur_patch , i , & skip_addr ) == 0 ) { continue ; } for ( ; cur_cs < NUM_CRITICAL_SECTIONS ; cur_cs ++ ) { if ( critical_sections [ cur_cs ] . end <= i ) { if ( begin_set [ cs_count ] == TRUE && end_set [ cs_count ] == FALSE ) { cs_table [ cs_count ] . end = downloaded ; end_set [ cs_count ] = TRUE ; cs_count ++ ; } continue ; } if ( critical_sections [ cur_cs ] . begin <= i && begin_set [ cs_count ] == FALSE ) { cs_table [ cs_count ] . begin = downloaded ; begin_set [ cs_count ] = TRUE ; } break ; } ahd_download_instr ( ahd , i , download_consts ) ; downloaded ++ ; } ahd -> num_critical_sections = cs_count ; if ( cs_count != 0 ) { cs_count *= sizeof ( cs ) ; ahd -> critical_sections = kmemdup ( cs_table , cs_count , GFP_ATOMIC ) ; if ( ahd -> critical_sections == NULL ) { panic ( "ahd_loadseq: Could not malloc" ) ; } } ahd_outb ( ahd , SEQCTL0 , PERRORDIS | FAILDIS | FASTMODE ) ; if ( bootverbose ) { printk ( " %d instructions downloaded\n" , downloaded ) ; printk ( "%s: Features 0x%x, Bugs 0x%x, Flags 0x%x\n" , ahd_name ( ahd ) , ahd -> features , ahd -> bugs , ahd -> flags ) ; } } 