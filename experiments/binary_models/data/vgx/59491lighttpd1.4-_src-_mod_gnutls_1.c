static int mod_gnutls_set_defaults_sockets ( server * srv , plugin_data * p ) { static const config_plugin_keys_t cpk [ ] { { CONST_STR_LEN ( "ssl.engine" ) T_CONFIG_BOOL T_CONFIG_SCOPE_SOCKET } { CONST_STR_LEN ( "ssl.cipher-list" ) T_CONFIG_STRING T_CONFIG_SCOPE_SOCKET } { CONST_STR_LEN ( "ssl.openssl.ssl-conf-cmd" ) T_CONFIG_ARRAY_KVSTRING T_CONFIG_SCOPE_SOCKET } { CONST_STR_LEN ( "ssl.pemfile" ) T_CONFIG_STRING T_CONFIG_SCOPE_CONNECTION } { CONST_STR_LEN ( "ssl.stek-file" ) T_CONFIG_STRING T_CONFIG_SCOPE_SERVER } { NULL 0 T_CONFIG_UNSET T_CONFIG_SCOPE_UNSET } } ; ; static const buffer default_ssl_cipher_list = { CONST_STR_LEN ( LIGHTTPD_DEFAULT_CIPHER_LIST ) 0 } ; p -> ssl_ctxs = ck_calloc ( srv -> config_context -> used , sizeof ( plugin_ssl_ctx ) ) ; int rc = HANDLER_GO_ON ; plugin_data_base srvplug ; plugin_data_base * const ps = & srvplug ; if ( ! config_plugin_values_init ( srv , ps , cpk , "mod_gnutls" ) ) { return HANDLER_ERROR ; } plugin_config_socket defaults ; memset ( & defaults , 0 , sizeof ( defaults ) ) ; defaults . ssl_session_ticket = 1 ; defaults . ssl_cipher_list = & default_ssl_cipher_list ; for ( int i = ! ps -> cvlist [ 0 ] . v . u2 [ 1 ] ; i < ps -> nconfig ; ++ i ) { config_cond_info cfginfo ; config_get_config_cond_info ( & cfginfo , ( uint32_t ) ps -> cvlist [ i ] . k_id ) ; int is_socket_scope = ( 0 == i || cfginfo . comp == COMP_SERVER_SOCKET ) ; int count_not_engine = 0 ; plugin_config_socket conf ; memcpy ( & conf , & defaults , sizeof ( conf ) ) ; config_plugin_value_t * cpv = ps -> cvlist + ps -> cvlist [ i ] . v . u2 [ 0 ] ; for ( ; - 1 != cpv -> k_id ; ++ cpv ) { if ( ! is_socket_scope && cpv -> k_id != 3 ) { log_error ( srv -> errh , __FILE__ , __LINE__ , "GnuTLS: %s is valid only in global scope or " "$SERVER[\"socket\"] condition" , cpk [ cpv -> k_id ] . k ) ; continue ; } ++ count_not_engine ; switch ( cpv -> k_id ) { case 0 : conf . ssl_enabled = ( 0 != cpv -> v . u ) ; -- count_not_engine ; break ; case 1 : if ( ! buffer_is_blank ( cpv -> v . b ) ) { conf . ssl_cipher_list = cpv -> v . b ; conf . ssl_honor_cipher_order = 1 ; log_error ( srv -> errh , __FILE__ , __LINE__ , "%s is deprecated.  " "Please prefer lighttpd secure TLS defaults, or use " "ssl.openssl.ssl-conf-cmd \"CipherString\" to set custom " "cipher list." , cpk [ cpv -> k_id ] . k ) ; } break ; case 2 : * ( const array * * ) & conf . ssl_conf_cmd = cpv -> v . a ; break ; case 3 : break ; case 4 : if ( ! buffer_is_blank ( cpv -> v . b ) ) { p -> ssl_stek_file = cpv -> v . b -> ptr ; } break ; default : break ; } } if ( HANDLER_GO_ON != rc ) { break ; } if ( 0 == i ) { memcpy ( & defaults , & conf , sizeof ( conf ) ) ; } if ( 0 != i && ! conf . ssl_enabled ) { continue ; } conf . ssl_verifyclient = p -> defaults . ssl_verifyclient ; conf . ssl_verifyclient_enforce = p -> defaults . ssl_verifyclient_enforce ; conf . ssl_verifyclient_depth = p -> defaults . ssl_verifyclient_depth ; int sidx = ps -> cvlist [ i ] . k_id ; for ( int j = ! p -> cvlist [ 0 ] . v . u2 [ 1 ] ; j < p -> nconfig ; ++ j ) { if ( p -> cvlist [ j ] . k_id != sidx ) { continue ; } /*(repeat to get ssl_pemfile,ssl_privkey)*/ cpv = p -> cvlist + p -> cvlist [ j ] . v . u2 [ 0 ] ; for ( ; - 1 != cpv -> k_id ; ++ cpv ) { ++ count_not_engine ; switch ( cpv -> k_id ) { case 0 : if ( cpv -> vtype == T_CONFIG_LOCAL ) { conf . pc = cpv -> v . v ; } break ; case 7 : conf . ssl_verifyclient = ( 0 != cpv -> v . u ) ; break ; case 8 : conf . ssl_verifyclient_enforce = ( 0 != cpv -> v . u ) ; break ; case 9 : conf . ssl_verifyclient_depth = ( unsigned char ) cpv -> v . shrt ; break ; default : break ; } } break ; } if ( NULL == conf . pc ) { if ( 0 == i && ! conf . ssl_enabled ) { continue ; } if ( 0 != i ) { if ( count_not_engine || ( conf . ssl_enabled && NULL == p -> ssl_ctxs [ 0 ] . priority_cache ) ) { log_error ( srv -> errh , __FILE__ , __LINE__ , "GnuTLS: ssl.pemfile has to be set in same " "$SERVER[\"socket\"] scope as other ssl.* directives, " "unless only ssl.engine is set, inheriting ssl.* from " "global scope" ) ; rc = HANDLER_ERROR ; continue ; } plugin_ssl_ctx * const s = p -> ssl_ctxs + sidx ; * s = * p -> ssl_ctxs ; continue ; } log_error ( srv -> errh , __FILE__ , __LINE__ , "GnuTLS: ssl.pemfile has to be set when ssl.engine = \"enable\"" ) ; rc = HANDLER_ERROR ; continue ; } if ( ! mod_gnutls_init_once_gnutls ( ) ) { rc = HANDLER_ERROR ; break ; } /*(filled by network_init_ssl() even on error)*/ if ( 0 == network_init_ssl ( srv , & conf , p ) ) { plugin_ssl_ctx * const s = p -> ssl_ctxs + sidx ; s -> ssl_session_ticket = conf . ssl_session_ticket ; s -> priority_cache = conf . priority_cache ; s -> dh_params = conf . dh_params ; } else { gnutls_priority_deinit ( conf . priority_cache ) ; gnutls_dh_params_deinit ( conf . dh_params ) ; rc = HANDLER_ERROR ; } free ( conf . priority_str . ptr ) ; } if ( rc == HANDLER_GO_ON && ssl_is_init ) { mod_gnutls_session_ticket_key_check ( srv , p , log_epoch_secs ) ; } free ( srvplug . cvlist ) ; return rc ; } 