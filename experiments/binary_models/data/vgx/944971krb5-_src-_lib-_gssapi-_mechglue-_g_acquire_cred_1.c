static OM_uint32 copy_mech_cred ( OM_uint32 * minor_status , gss_cred_id_t cred_in , gss_OID mech_oid , gss_cred_id_t * cred_out ) { OM_uint32 status , tmpmin ; gss_mechanism mech ; gss_buffer_desc buf ; gss_name_t name ; OM_uint32 life ; gss_cred_usage_t usage ; gss_OID_set_desc oidset ; mech = gssint_get_mechanism ( mech_oid ) ; if ( mech == NULL ) { return ( GSS_S_BAD_MECH ) ; } if ( mech -> gss_export_cred != NULL && mech -> gss_import_cred != NULL ) { status = mech -> gss_export_cred ( minor_status , cred_in , & buf ) ; status = mech -> gss_import_cred ( minor_status , & buf , cred_out ) ; ( void ) gss_release_buffer ( & tmpmin , & buf ) ; } if ( mech -> gss_inquire_cred != NULL && mech -> gss_acquire_cred != NULL ) { status = mech -> gss_inquire_cred ( minor_status , cred_in , & name , & life , & usage , NULL ) ; if ( status != GSS_S_COMPLETE ) { return ( status ) ; } oidset . count = 1 ; oidset . elements = gssint_get_public_oid ( mech_oid ) ; status = mech -> gss_acquire_cred ( minor_status , name , life , & oidset , usage , cred_out , NULL , NULL ) ; gss_release_name ( & tmpmin , & name ) ; } else { status = GSS_S_UNAVAILABLE ; } return ( status ) ; } 