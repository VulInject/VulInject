static int m_can_pci_probe ( struct pci_dev * pci , const struct pci_device_id * id ) { struct device * dev = & pci -> dev ; struct m_can_classdev * mcan_class ; struct m_can_pci_priv * priv ; void __iomem * base ; int ret ; ret = pcim_enable_device ( pci ) ; if ( ret ) { return ret ; } pci_set_master ( pci ) ; ret = pcim_iomap_regions ( pci , BIT ( M_CAN_PCI_MMIO_BAR ) , pci_name ( pci ) ) ; if ( ret ) { return ret ; } base = pcim_iomap_table ( pci ) [ M_CAN_PCI_MMIO_BAR ] ; if ( ! base ) { dev_err ( dev , "failed to map BARs\n" ) ; return - ENOMEM ; } mcan_class = m_can_class_allocate_dev ( & pci -> dev , sizeof ( m_can_pci_priv ) ) ; if ( ! mcan_class ) { return - ENOMEM ; } priv = cdev_to_priv ( mcan_class ) ; priv -> base = base ; ret = pci_alloc_irq_vectors ( pci , 1 , 1 , PCI_IRQ_ALL_TYPES ) ; if ( ret < 0 ) { err_free_dev } mcan_class -> dev = & pci -> dev ; mcan_class -> net -> irq = pci_irq_vector ( pci , 0 ) ; mcan_class -> pm_clock_support = 1 ; mcan_class -> can . clock . freq = id -> driver_data ; mcan_class -> ops = & m_can_pci_ops ; pci_set_drvdata ( pci , mcan_class ) ; ret = m_can_class_register ( mcan_class ) ; if ( ret ) { err_free_irq } writel ( 0x1 , base + CTL_CSR_INT_CTL_OFFSET ) ; pm_runtime_set_autosuspend_delay ( dev , 1000 ) ; pm_runtime_use_autosuspend ( dev ) ; pm_runtime_put_noidle ( dev , NULL ) ; pm_runtime_allow ( dev ) ; return 0 ; err_free_irq pci_free_irq_vectors ( pci ) ; err_free_dev m_can_class_free_dev ( mcan_class -> net ) ; return ret ; } 