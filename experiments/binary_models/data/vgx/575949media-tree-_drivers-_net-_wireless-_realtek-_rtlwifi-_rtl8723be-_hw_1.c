static void _rtl8723be_set_fw_clock_on ( struct ieee80211_hw * hw , u8 rpwm_val , bool b_need_turn_off_ckk ) { struct rtl_priv * rtlpriv = rtl_priv ( hw ) ; struct rtl_hal * rtlhal = rtl_hal ( rtl_priv ( hw ) ) ; bool b_support_remote_wake_up ; u32 count = 0 , isr_regaddr , content ; bool b_schedule_timer = b_need_turn_off_ckk ; rtlpriv -> cfg -> ops -> get_hw_reg ( hw , HAL_DEF_WOWLAN , ( u8 * ) ( & b_support_remote_wake_up ) ) ; if ( ! rtlpriv -> psc . fw_current_inpsmode ) { return ; } while ( 1 ) { spin_lock_bh ( & rtlpriv -> locks . fw_ps_lock ) ; if ( rtlhal -> fw_clk_change_in_progress ) { while ( rtlhal -> fw_clk_change_in_progress ) { spin_unlock_bh ( & rtlpriv -> locks . fw_ps_lock ) ; count ++ ; udelay ( 100 ) ; if ( count > 1000 ) { return ; } spin_lock_bh ( & rtlpriv -> locks . fw_ps_lock ) ; } spin_unlock_bh ( & rtlpriv -> locks . fw_ps_lock ) ; } else { rtlhal -> fw_clk_change_in_progress = false ; spin_unlock_bh ( & rtlpriv -> locks . fw_ps_lock ) ; break ; } } if ( IS_IN_LOW_POWER_STATE ( rtlhal -> fw_ps_state ) ) { rtlpriv -> cfg -> ops -> get_hw_reg ( hw , HW_VAR_SET_RPWM , ( u8 * ) ( & rpwm_val ) ) ; if ( FW_PS_IS_ACK ( rpwm_val ) ) { isr_regaddr = REG_HISR ; content = rtl_read_dword ( rtlpriv , isr_regaddr ) ; while ( ! ( content & IMR_CPWM ) && ( count < 500 ) ) { udelay ( 50 ) ; count ++ ; content = rtl_read_dword ( rtlpriv , isr_regaddr ) ; } if ( content & IMR_CPWM ) { rtl_write_word ( rtlpriv , isr_regaddr , 0x0100 ) ; rtlhal -> fw_ps_state = FW_PS_STATE_RF_ON ; RT_TRACE ( rtlpriv , COMP_POWER , DBG_LOUD , "Receive CPWM INT!!! Set pHalData->FwPSState = %X\n" , rtlhal -> fw_ps_state ) ; } } spin_lock_bh ( & rtlpriv -> locks . fw_ps_lock ) ; rtlhal -> fw_clk_change_in_progress = false ; spin_unlock_bh ( & rtlpriv -> locks . fw_ps_lock ) ; if ( b_schedule_timer ) { mod_timer ( & rtlpriv -> works . fw_clockoff_timer , jiffies + MSECS ( 10 ) ) ; } } else { spin_lock_bh ( & rtlpriv -> locks . fw_ps_lock ) ; rtlhal -> fw_clk_change_in_progress = false ; spin_unlock_bh ( & rtlpriv -> locks . fw_ps_lock ) ; } } 