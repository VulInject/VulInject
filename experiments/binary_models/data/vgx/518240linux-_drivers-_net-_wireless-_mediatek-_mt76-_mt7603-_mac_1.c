static bool mt7603_fill_txs ( struct mt7603_dev * dev , struct mt7603_sta * sta , struct ieee80211_tx_info * info , __le32 * txs_data ) { struct ieee80211_supported_band * sband ; struct mt7603_rate_set * rs ; int first_idx = 0 , last_idx ; u32 rate_set_tsf ; u32 final_rate ; u32 final_rate_flags ; bool rs_idx ; bool ack_timeout ; bool fixed_rate ; bool probe ; bool ampdu ; bool cck = false ; int count ; u32 txs ; int idx ; int i ; fixed_rate = info -> status . rates [ 0 ] . count ; probe = ! ! ( info -> flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE ) ; txs = le32_to_cpu ( txs_data [ 4 ] ) ; ampdu = ! fixed_rate && ( txs & MT_TXS4_AMPDU ) ; count = FIELD_GET ( MT_TXS4_TX_COUNT , txs ) ; last_idx = FIELD_GET ( MT_TXS4_LAST_TX_RATE , txs ) ; txs = le32_to_cpu ( txs_data [ 0 ] ) ; final_rate = FIELD_GET ( MT_TXS0_TX_RATE , txs ) ; ack_timeout = txs & MT_TXS0_ACK_TIMEOUT ; if ( txs & MT_TXS0_QUEUE_TIMEOUT ) { return false ; } if ( ! ack_timeout ) { info -> flags |= IEEE80211_TX_STAT_ACK ; } info -> status . ampdu_len = 1 ; info -> status . ampdu_ack_len = ! ! ( info -> flags & IEEE80211_TX_STAT_ACK ) ; if ( ampdu || ( info -> flags & IEEE80211_TX_CTL_AMPDU ) ) { info -> flags |= IEEE80211_TX_STAT_AMPDU | IEEE80211_TX_CTL_AMPDU ; } first_idx = max_t ( int , 0 , last_idx - ( count - 1 ) / MT7603_RATE_RETRY ) ; if ( fixed_rate && ! probe ) { info -> status . rates [ 0 ] . count = count ; i = 0 ; out } rate_set_tsf = READ_ONCE ( sta -> rate_set_tsf ) ; rs_idx = ! ( ( u32 ) ( le32_get_bits ( txs_data [ 1 ] , MT_TXS1_F0_TIMESTAMP ) - rate_set_tsf ) < 1000000 ) ; rs_idx ^= rate_set_tsf & BIT ( 0 ) ; rs = & sta -> rateset [ rs_idx ] ; if ( ! first_idx && rs -> probe_rate . idx >= 0 ) { info -> status . rates [ 0 ] = rs -> probe_rate ; spin_lock_bh ( & dev -> mt76 . lock ) ; if ( sta -> rate_probe ) { mt7603_wtbl_set_rates ( dev , sta , NULL , sta -> rates ) ; sta -> rate_probe = false ; } spin_unlock_bh ( & dev -> mt76 . lock ) ; } else { info -> status . rates [ 0 ] = rs -> rates [ first_idx / 2 ] ; } info -> status . rates [ 0 ] . count = 0 ; for ( i = 0 , idx = first_idx ; count && idx <= last_idx ; idx ++ ) { struct ieee80211_tx_rate * cur_rate ; int cur_count ; cur_rate = & rs -> rates [ idx / 2 ] ; cur_count = min_t ( int , MT7603_RATE_RETRY , count ) ; count -= cur_count ; if ( idx && ( cur_rate -> idx != info -> status . rates [ i ] . idx || cur_rate -> flags != info -> status . rates [ i ] . flags ) ) { i ++ ; if ( i == ARRAY_SIZE ( info -> status . rates ) ) { i -- ; break ; } info -> status . rates [ i ] = * cur_rate ; info -> status . rates [ i ] . count = 0 ; } info -> status . rates [ i ] . count += cur_count ; } out final_rate_flags = info -> status . rates [ i ] . flags ; switch ( FIELD_GET ( MT_TX_RATE_MODE , final_rate ) ) { case MT_PHY_TYPE_CCK : cck = true ; fallthrough ; case MT_PHY_TYPE_OFDM : if ( dev -> mphy . chandef . chan -> band == NL80211_BAND_5GHZ ) { sband = & dev -> mphy . sband_5g . sband ; } else { sband = & dev -> mphy . sband_2g . sband ; } final_rate &= GENMASK ( 5 , 0 ) ; final_rate = mt76_get_rate ( & dev -> mt76 , sband , final_rate , cck ) ; final_rate_flags = 0 ; break ; case MT_PHY_TYPE_HT_GF : case MT_PHY_TYPE_HT : final_rate_flags |= IEEE80211_TX_RC_MCS ; final_rate &= GENMASK ( 5 , 0 ) ; if ( final_rate > 15 ) { return false ; } break ; default : return false ; } info -> status . rates [ i ] . idx = final_rate ; info -> status . rates [ i ] . flags = final_rate_flags ; return true ; } 