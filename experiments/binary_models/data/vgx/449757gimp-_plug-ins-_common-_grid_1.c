grid ( , , ) { GeglBuffer * src_buffer ; GeglBuffer * dest_buffer ; const Babl * format ; gint bytes ; gint x_offset ; gint y_offset ; guchar * dest ; guchar * buffer = NULL ; gint x , y ; gboolean alpha ; gboolean blend ; guchar hcolor [ 4 ] ; guchar vcolor [ 4 ] ; guchar icolor [ 4 ] ; guchar * cmap ; gint ncolors ; gimp_rgba_get_uchar ( & grid_cfg . hcolor , hcolor , hcolor + 1 , hcolor + 2 , hcolor + 3 ) ; gimp_rgba_get_uchar ( & grid_cfg . vcolor , vcolor , vcolor + 1 , vcolor + 2 , vcolor + 3 ) ; gimp_rgba_get_uchar ( & grid_cfg . icolor , icolor , icolor + 1 , icolor + 2 , icolor + 3 ) ; alpha = gimp_drawable_has_alpha ( drawable ) ; switch ( gimp_image_get_base_type ( image ) ) { case GIMP_RGB : blend = TRUE ; if ( alpha ) { format = babl_format ( "R'G'B'A u8" ) ; } else { format = babl_format ( "R'G'B' u8" ) ; } break ; case GIMP_GRAY : hcolor [ 0 ] = gimp_rgb_luminance_uchar ( & grid_cfg . hcolor ) ; vcolor [ 0 ] = gimp_rgb_luminance_uchar ( & grid_cfg . vcolor ) ; icolor [ 0 ] = gimp_rgb_luminance_uchar ( & grid_cfg . icolor ) ; blend = TRUE ; if ( alpha ) { format = babl_format ( "Y'A u8" ) ; } else { format = babl_format ( "Y' u8" ) ; } break ; case GIMP_INDEXED : cmap = gimp_image_get_colormap ( image , & ncolors ) ; hcolor [ 0 ] = best_cmap_match ( cmap , ncolors , & grid_cfg . hcolor ) ; vcolor [ 0 ] = best_cmap_match ( cmap , ncolors , & grid_cfg . vcolor ) ; icolor [ 0 ] = best_cmap_match ( cmap , ncolors , & grid_cfg . icolor ) ; blend = FALSE ; format = gimp_drawable_get_format ( drawable ) ; break ; default : g_assert_not_reached ( ) ; blend = FALSE ; } bytes = babl_format_get_bytes_per_pixel ( format ) ; if ( preview ) { gimp_preview_get_position ( preview , & sx1 , & sy1 ) ; gimp_preview_get_size ( preview , & sx2 , & sy2 ) ; buffer = g_new ( guchar , bytes * sx2 * sy2 ) ; sx2 += sx1 ; sy2 += sy1 ; } else { gint w , h ; if ( ! gimp_drawable_mask_intersect ( drawable , & sx1 , & sy1 , & w , & h ) ) { return ; } sx2 = sx1 + w ; sy2 = sy1 + h ; dest_buffer = gimp_drawable_get_shadow_buffer ( drawable ) ; } src_buffer = gimp_drawable_get_buffer ( drawable ) ; dest = g_new ( guchar , ( sx2 - sx1 ) * bytes ) ; for ( y = sy1 ; y < sy2 ; y ++ ) { gegl_buffer_get ( src_buffer , GEGL_RECTANGLE ( sx1 , y , sx2 - sx1 , 1 ) , 1.0 , format , dest , GEGL_AUTO_ROWSTRIDE , GEGL_ABYSS_NONE ) ; y_offset = y - grid_cfg . hoffset ; while ( y_offset < 0 ) { y_offset += grid_cfg . hspace ; } if ( ( y_offset + ( grid_cfg . hwidth / 2 ) ) % grid_cfg . hspace < grid_cfg . hwidth ) { for ( x = sx1 ; x < sx2 ; x ++ ) { pix_composite ( & dest [ ( x - sx1 ) * bytes ] , hcolor , bytes , blend , alpha ) ; } } for ( x = sx1 ; x < sx2 ; x ++ ) { x_offset = grid_cfg . vspace + x - grid_cfg . voffset ; while ( x_offset < 0 ) { x_offset += grid_cfg . vspace ; } if ( ( x_offset + ( grid_cfg . vwidth / 2 ) ) % grid_cfg . vspace < grid_cfg . vwidth ) { pix_composite ( & dest [ ( x - sx1 ) * bytes ] , vcolor , bytes , blend , alpha ) ; } if ( ( x_offset + ( grid_cfg . iwidth / 2 ) ) % grid_cfg . vspace < grid_cfg . iwidth && ( ( y_offset % grid_cfg . hspace >= grid_cfg . ispace && y_offset % grid_cfg . hspace < grid_cfg . ioffset ) || ( grid_cfg . hspace - ( y_offset % grid_cfg . hspace ) >= grid_cfg . ispace && grid_cfg . hspace - ( y_offset % grid_cfg . hspace ) < grid_cfg . ioffset ) ) ) { pix_composite ( & dest [ ( x - sx1 ) * bytes ] , icolor , bytes , blend , alpha ) ; } } if ( ( y_offset + ( grid_cfg . iwidth / 2 ) ) % grid_cfg . hspace < grid_cfg . iwidth ) { for ( x = sx1 ; x < sx2 ; x ++ ) { x_offset = grid_cfg . vspace + x - grid_cfg . voffset ; while ( x_offset < 0 ) { x_offset += grid_cfg . vspace ; } if ( ( x_offset % grid_cfg . vspace >= grid_cfg . ispace && x_offset % grid_cfg . vspace < grid_cfg . ioffset ) || ( grid_cfg . vspace - ( x_offset % grid_cfg . vspace ) >= grid_cfg . ispace && grid_cfg . vspace - ( x_offset % grid_cfg . vspace ) < grid_cfg . ioffset ) ) { pix_composite ( & dest [ ( x - sx1 ) * bytes ] , icolor , bytes , blend , alpha ) ; } } } if ( preview ) { memcpy ( buffer + ( y - sy1 ) * ( sx2 - sx1 ) * bytes , dest , ( sx2 - sx1 ) * bytes ) ; } else { gegl_buffer_set ( dest_buffer , GEGL_RECTANGLE ( sx1 , y , sx2 - sx1 , 1 ) , 0 , format , dest , GEGL_AUTO_ROWSTRIDE ) ; if ( y % 16 == 0 ) { gimp_progress_update ( ( gdouble ) y / ( gdouble ) ( sy2 - sy1 ) ) ; } } } g_free ( dest ) ; g_object_unref ( src_buffer ) ; if ( preview ) { gimp_preview_draw_buffer ( preview , buffer , bytes * ( sx2 - sx1 ) ) ; g_free ( buffer ) ; } else { gimp_progress_update ( 1.0 ) ; g_object_unref ( dest_buffer ) ; gimp_drawable_merge_shadow ( drawable , TRUE ) ; gimp_drawable_update ( drawable , sx1 , sy1 , sx2 - sx1 , sy2 - sy1 ) ; } } 