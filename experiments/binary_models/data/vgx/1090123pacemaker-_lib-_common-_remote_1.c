xmlNode * pcmk__remote_message_xml ( pcmk__remote_t * remote ) { xmlNode * xml = NULL ; struct remote_header_v0 * header = localized_remote_header ( remote ) ; if ( header == NULL ) { return NULL ; } if ( header -> payload_compressed ) { int rc = 0 ; unsigned int size_u = 1 + header -> payload_uncompressed ; char * uncompressed = calloc ( 1 , header -> payload_offset + size_u ) ; crm_trace ( "Decompressing message data %d bytes into %d bytes" , header -> payload_compressed , size_u ) ; rc = BZ2_bzBuffToBuffDecompress ( uncompressed + header -> payload_offset , & size_u , remote -> buffer + header -> payload_offset , header -> payload_compressed , 1 , 0 ) ; if ( rc != BZ_OK && header -> version > REMOTE_MSG_VERSION ) { crm_warn ( "Couldn't decompress v%d message, we only understand v%d" , header -> version , REMOTE_MSG_VERSION ) ; return NULL ; } if ( rc != BZ_OK ) { crm_err ( "Decompression failed: %s " CRM_XS " bzerror=%d" , bz2_strerror ( rc ) , rc ) ; free ( uncompressed ) ; return NULL ; } CRM_ASSERT ( size_u == header -> payload_uncompressed ) ; memcpy ( uncompressed , remote -> buffer , header -> payload_offset ) ; remote -> buffer_size = header -> payload_offset + size_u ; free ( remote -> buffer ) ; remote -> buffer = uncompressed ; header = localized_remote_header ( remote ) ; } remote -> buffer_offset = 0 ; CRM_LOG_ASSERT ( remote -> buffer [ sizeof ( remote_header_v0 ) + header -> payload_uncompressed - 1 ] == 0 ) ; xml = string2xml ( remote -> buffer + header -> payload_offset ) ; if ( xml == NULL && header -> version > REMOTE_MSG_VERSION ) { crm_warn ( "Couldn't parse v%d message, we only understand v%d" , header -> version , REMOTE_MSG_VERSION ) ; } if ( xml == NULL ) { crm_err ( "Couldn't parse: '%.120s'" , remote -> buffer + header -> payload_offset ) ; } return xml ; } 