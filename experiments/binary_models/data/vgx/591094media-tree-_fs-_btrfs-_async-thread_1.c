BTRFS_WORK_HELPER ( endio_meta_write_helper ) ; BTRFS_WORK_HELPER ( endio_raid56_helper ) ; BTRFS_WORK_HELPER ( endio_repair_helper ) ; BTRFS_WORK_HELPER ( rmw_helper ) ; BTRFS_WORK_HELPER ( endio_write_helper ) ; BTRFS_WORK_HELPER ( freespace_write_helper ) ; BTRFS_WORK_HELPER ( delayed_meta_helper ) ; BTRFS_WORK_HELPER ( readahead_helper ) ; BTRFS_WORK_HELPER ( qgroup_rescan_helper ) ; BTRFS_WORK_HELPER ( extent_refs_helper ) ; BTRFS_WORK_HELPER ( scrub_helper ) ; BTRFS_WORK_HELPER ( scrubwrc_helper ) ; BTRFS_WORK_HELPER ( scrubnc_helper ) ; BTRFS_WORK_HELPER ( scrubparity_helper ) ; static struct __btrfs_workqueue * __btrfs_alloc_workqueue ( struct btrfs_fs_info * fs_info , const char * name , unsigned int flags , int limit_active , int thresh ) { struct __btrfs_workqueue * ret = kzalloc ( sizeof ( * ret ) , GFP_KERNEL ) ; if ( ! ret ) { return NULL ; } ret -> fs_info = fs_info ; ret -> limit_active = limit_active ; atomic_set ( & ret -> pending , 0 ) ; if ( thresh == 0 ) { thresh = DFT_THRESHOLD ; } if ( thresh < DFT_THRESHOLD ) { ret -> current_active = limit_active ; ret -> thresh = NO_THRESHOLD ; } else { ret -> current_active = 1 ; ret -> thresh = thresh ; } if ( flags & WQ_HIGHPRI ) { ret -> normal_wq = alloc_workqueue ( "%s-%s-high" , flags , ret -> current_active , "btrfs" , name ) ; } else { ret -> normal_wq = alloc_workqueue ( "%s-%s" , flags , ret -> current_active , "btrfs" , name ) ; } if ( ! ret -> normal_wq ) { return NULL ; } INIT_LIST_HEAD ( & ret -> ordered_list ) ; spin_lock_init ( & ret -> list_lock ) ; spin_lock_init ( & ret -> thres_lock ) ; trace_btrfs_workqueue_alloc ( ret , name , flags & WQ_HIGHPRI ) ; return ret ; } 