int fdmatch ( struct device * parent , void * match , void * aux ) { struct fdc_softc * fdc = ( void * ) parent ; bus_space_tag_t t = fdc -> sc_bustag ; bus_space_handle_t h = fdc -> sc_handle ; struct fdc_attach_args * fa = aux ; int drive = fa -> fa_drive ; int n , ok ; bus_space_write_1 ( t , h , FDREG77_DOR , drive | FDO_FRST | FDO_MOEN ( drive ) ) ; delay ( 250000 ) ; fdc -> sc_nstat = 0 ; fdc_wrfifo ( fdc , NE7CMD_RECAL ) ; fdc_wrfifo ( fdc , drive ) ; for ( n = 0 ; n < 10000 ; n ++ ) { u_int8_t v ; delay ( 1000 ) ; v = bus_space_read_1 ( t , h , FDREG77_MSR ) ; if ( ( v & ( NE7_RQM | NE7_DIO | NE7_CB ) ) == NE7_RQM ) { delay ( 100000 ) ; if ( fdc_wrfifo ( fdc , NE7CMD_SENSEI ) ) { break ; } if ( fdcresult ( fdc ) == 1 && fdc -> sc_status [ 0 ] == 0x80 ) { continue ; } break ; } } n = fdc -> sc_nstat ; if ( fdc_debug ) { int i ; printf ( "fdprobe: %d stati:" , n ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( " 0x%x" , fdc -> sc_status [ i ] ) ; } printf ( "\n" ) ; } ok = ( n == 2 && ( fdc -> sc_status [ 0 ] & 0xf8 ) == 0x20 ) ?1 : 0 ; bus_space_write_1 ( t , h , FDREG77_DOR , FDO_FRST | FDO_DS ) ; return ( ok ) ; } 