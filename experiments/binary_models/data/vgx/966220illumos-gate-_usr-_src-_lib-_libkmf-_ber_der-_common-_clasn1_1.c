static KMF_RETURN get_rdn ( BerElement * asn1 , KMF_X509_NAME * name ) { KMF_RETURN ret = KMF_OK ; ber_len_t size ; char * end ; int tag ; BerValue AttrOID ; char * AttrValue = NULL ; KMF_X509_TYPE_VALUE_PAIR * newpair = NULL ; KMF_X509_RDN newrdn ; name -> numberOfRDNs = 0 ; name -> RelativeDistinguishedName = NULL ; tag = kmfber_first_element ( asn1 , & size , & end ) ; if ( tag != BER_CONSTRUCTED_SET ) { cleanup } while ( ( tag = kmfber_next_element ( asn1 , & size , end ) ) == BER_CONSTRUCTED_SET ) { if ( kmfber_scanf ( asn1 , "T" , & tag ) == - 1 ) { ret = KMF_ERR_BAD_CERT_FORMAT ; break ; } if ( size == 0 ) { if ( ( ret = AddRDN ( name , NULL ) ) != KMF_OK ) { cleanup } continue ; } if ( kmfber_scanf ( asn1 , "{Dtl" , & AttrOID , & tag , & size ) == - 1 ) { ret = KMF_ERR_BAD_CERT_FORMAT ; break ; } if ( ! ( VALID_DIRECTORYSTRING_TAG ( tag ) ) ) { ret = KMF_ERR_BAD_CERT_FORMAT ; break ; } if ( kmfber_scanf ( asn1 , "a}]" , & AttrValue ) == - 1 ) { ret = KMF_ERR_BAD_CERT_FORMAT ; break ; } newpair = malloc ( sizeof ( KMF_X509_TYPE_VALUE_PAIR ) ) ; if ( newpair == NULL ) { ret = KMF_ERR_MEMORY ; break ; } newpair -> type . Data = ( uchar_t * ) AttrOID . bv_val ; newpair -> type . Length = AttrOID . bv_len ; newpair -> valueType = tag ; newpair -> value . Data = ( uchar_t * ) AttrValue ; newpair -> value . Length = strlen ( AttrValue ) ; ( void ) memset ( & newrdn , 0 , sizeof ( KMF_X509_RDN ) ) ; newrdn . numberOfPairs = 1 ; newrdn . AttributeTypeAndValue = newpair ; if ( ( ret = AddRDN ( name , & newrdn ) ) != KMF_OK ) { break ; } } cleanup if ( ret != KMF_OK ) { free_rdn_data ( name ) ; } return ( ret ) ; } 