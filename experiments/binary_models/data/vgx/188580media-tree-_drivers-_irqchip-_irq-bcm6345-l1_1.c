static int __init bcm6345_l1_of_init ( struct device_node * dn , struct device_node * parent ) { struct bcm6345_l1_chip * intc ; unsigned int idx ; int ret ; intc = kzalloc ( sizeof ( * intc ) , GFP_KERNEL ) ; if ( ! intc ) { return - ENOMEM ; } for_each_possible_cpu ( ) { ret = bcm6345_l1_init_one ( dn , idx , intc ) ; if ( ret ) { pr_err ( "failed to init intc L1 for cpu %d: %d\n" , idx , ret ) ; } else { cpumask_set_cpu ( idx , & intc -> cpumask ) ; } } if ( ! cpumask_weight ( & intc -> cpumask ) ) { ret = - ENODEV ; out_free } raw_spin_lock_init ( & intc -> lock ) ; intc -> domain = irq_domain_add_linear ( dn , IRQS_PER_WORD * intc -> n_words , & bcm6345_l1_domain_ops , intc ) ; if ( ! intc -> domain ) { ret = - ENOMEM ; out_unmap } pr_info ( "registered BCM6345 L1 intc (IRQs: %d)\n" , IRQS_PER_WORD * intc -> n_words ) ; for_each_cpu ( , ) { struct bcm6345_l1_cpu * cpu = intc -> cpus [ idx ] ; pr_info ( "  CPU%u at MMIO 0x%p (irq = %d)\n" , idx , cpu -> map_base , cpu -> parent_irq ) ; } return 0 ; out_unmap for_each_possible_cpu ( ) { struct bcm6345_l1_cpu * cpu = intc -> cpus [ idx ] ; if ( cpu ) { if ( cpu -> map_base ) { iounmap ( cpu -> map_base ) ; } } } out_free kfree ( intc ) ; return ret ; } 