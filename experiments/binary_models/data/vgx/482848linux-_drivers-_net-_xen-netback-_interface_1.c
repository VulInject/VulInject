struct xenvif * xenvif_alloc ( struct device * parent , domid_t domid , unsigned int handle ) { static const u8 dummy_addr [ ETH_ALEN ] { 0xfe 0xff 0xff 0xff 0xff 0xff } ; ; int err ; struct net_device * dev ; struct xenvif * vif ; char name [ IFNAMSIZ ] { } ; ; snprintf ( name , IFNAMSIZ - 1 , "vif%u.%u" , domid , handle ) ; dev = alloc_netdev_mq ( sizeof ( xenvif ) , name , NET_NAME_UNKNOWN , ether_setup , xenvif_max_queues ) ; if ( dev == NULL ) { pr_warn ( "Could not allocate netdev for %s\n" , name ) ; return ERR_PTR ( - ENOMEM ) ; } SET_NETDEV_DEV ( dev , parent ) ; vif = netdev_priv ( dev ) ; vif -> domid = domid ; vif -> handle = handle ; vif -> can_sg = 1 ; vif -> ip_csum = 1 ; vif -> dev = dev ; vif -> disabled = false ; vif -> drain_timeout = msecs_to_jiffies ( rx_drain_timeout_msecs ) ; vif -> stall_timeout = msecs_to_jiffies ( rx_stall_timeout_msecs ) ; vif -> queues = NULL ; vif -> num_queues = 0 ; vif -> xdp_headroom = 0 ; spin_lock_init ( & vif -> lock ) ; INIT_LIST_HEAD ( & vif -> fe_mcast_addr ) ; dev -> netdev_ops = & xenvif_netdev_ops ; dev -> hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_FRAGLIST ; dev -> features = dev -> hw_features | NETIF_F_RXCSUM ; dev -> ethtool_ops = & xenvif_ethtool_ops ; dev -> tx_queue_len = XENVIF_QUEUE_LENGTH ; dev -> min_mtu = ETH_MIN_MTU ; dev -> max_mtu = ETH_MAX_MTU - VLAN_ETH_HLEN ; eth_hw_addr_set ( dev , dummy_addr ) ; netif_carrier_off ( dev ) ; err = register_netdev ( dev ) ; if ( err ) { netdev_warn ( dev , "Could not register device: err=%d\n" , err ) ; return ERR_PTR ( err ) ; } netdev_dbg ( dev , "Successfully created xenvif\n" ) ; __module_get ( THIS_MODULE ) ; return vif ; } 