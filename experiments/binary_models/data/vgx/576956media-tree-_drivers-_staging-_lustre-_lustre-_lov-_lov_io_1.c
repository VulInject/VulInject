static int lov_io_commit_async ( const struct lu_env * env , const struct cl_io_slice * ios , struct cl_page_list * queue , int from , int to , cl_commit_cbt cb ) { struct cl_page_list * plist = & lov_env_info ( env ) -> lti_plist ; struct lov_io * lio = cl2lov_io ( env , ios ) ; struct lov_io_sub * sub ; struct cl_page * page ; int rc = 0 ; if ( lio -> lis_active_subios == 1 ) { int idx = lio -> lis_single_subio_index ; LASSERT ( idx < lio -> lis_nr_subios ) ; sub = lov_sub_get ( env , lio , idx ) ; LASSERT ( ! IS_ERR ( sub ) ) ; LASSERT ( sub -> sub_io == & lio -> lis_single_subio ) ; rc = cl_io_commit_async ( sub -> sub_env , sub -> sub_io , queue , from , to , cb ) ; lov_sub_put ( sub , NULL ) ; return rc ; } LASSERT ( lio -> lis_subs ) ; cl_page_list_init ( plist ) ; while ( queue -> pl_nr > 0 ) { int stripe_to = to ; int stripe ; LASSERT ( plist -> pl_nr == 0 ) ; page = cl_page_list_first ( queue ) ; cl_page_list_move ( plist , queue , page ) ; stripe = lov_page_stripe ( page ) ; while ( queue -> pl_nr > 0 ) { page = cl_page_list_first ( queue ) ; if ( stripe != lov_page_stripe ( page ) ) { break ; } cl_page_list_move ( plist , queue , page ) ; } if ( queue -> pl_nr > 0 ) { stripe_to = PAGE_SIZE ; } sub = lov_sub_get ( env , lio , stripe ) ; if ( ! IS_ERR ( sub ) ) { rc = cl_io_commit_async ( sub -> sub_env , sub -> sub_io , plist , from , stripe_to , cb ) ; lov_sub_put ( sub ) ; } else { rc = PTR_ERR ( sub ) ; break ; } if ( plist -> pl_nr > 0 ) { break ; } from = 0 ; } LASSERT ( ergo ( rc == 0 , plist -> pl_nr == 0 ) ) ; while ( plist -> pl_nr > 0 ) { page = cl_page_list_last ( plist ) ; cl_page_list_move_head ( queue , plist , page ) ; } return rc ; } 