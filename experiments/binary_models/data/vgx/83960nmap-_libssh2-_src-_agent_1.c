static int agent_transact_pageant ( LIBSSH2_AGENT * agent , agent_transaction_ctx_t transctx ) { HWND hwnd ; char mapname [ 23 ] ; HANDLE filemap ; unsigned char * p ; unsigned char * p2 ; int id ; COPYDATASTRUCT cds ; if ( ! transctx || 4 + transctx -> request_len > PAGEANT_MAX_MSGLEN ) { return _libssh2_error ( agent -> session , LIBSSH2_ERROR_INVAL , "illegal input" ) ; } hwnd = FindWindowA ( "Pageant" , "Pageant" ) ; if ( ! hwnd ) { return _libssh2_error ( agent -> session , LIBSSH2_ERROR_AGENT_PROTOCOL , "found no pageant" ) ; } sprintf ( mapname , "PageantRequest%08x%c" , ( unsigned ) GetCurrentThreadId ( ) , '\0' ) ; filemap = CreateFileMappingA ( INVALID_HANDLE_VALUE , NULL , PAGE_READWRITE , 0 , PAGEANT_MAX_MSGLEN , mapname ) ; if ( filemap == NULL || filemap == INVALID_HANDLE_VALUE ) { return _libssh2_error ( agent -> session , LIBSSH2_ERROR_AGENT_PROTOCOL , "failed setting up pageant filemap" ) ; } p2 = p = MapViewOfFile ( filemap , FILE_MAP_WRITE , 0 , 0 , 0 ) ; if ( p == NULL || p2 == NULL ) { CloseHandle ( filemap ) ; return _libssh2_error ( agent -> session , LIBSSH2_ERROR_AGENT_PROTOCOL , "failed to open pageant filemap for writing" ) ; } _libssh2_store_str ( & p2 , ( const char * ) transctx -> request , transctx -> request_len ) ; cds . dwData = PAGEANT_COPYDATA_ID ; cds . cbData = 1 + strlen ( mapname ) ; cds . lpData = mapname ; id = SendMessage ( hwnd , WM_COPYDATA , ( WPARAM ) NULL , ( LPARAM ) & cds ) ; if ( id > 0 ) { transctx -> response_len = _libssh2_ntohu32 ( p ) ; if ( transctx -> response_len > PAGEANT_MAX_MSGLEN ) { UnmapViewOfFile ( p ) ; CloseHandle ( filemap ) ; return _libssh2_error ( agent -> session , LIBSSH2_ERROR_AGENT_PROTOCOL , "agent setup fail" ) ; } transctx -> response = LIBSSH2_ALLOC ( agent -> session , transctx -> response_len ) ; if ( ! transctx -> response ) { UnmapViewOfFile ( p ) ; CloseHandle ( filemap ) ; return _libssh2_error ( agent -> session , LIBSSH2_ERROR_ALLOC , "agent malloc" ) ; } memcpy ( transctx -> response , p + 4 , transctx -> response_len ) ; } UnmapViewOfFile ( p ) ; CloseHandle ( filemap ) ; return 0 ; } 