static int update_info_file ( char * path , int * generate ( struct update_info_ctx * ) , int force ) { char * tmp = mkpathdup ( "%s_XXXXXX" , path ) ; int ret = - 1 ; int fd = - 1 ; FILE * to_close ; struct update_info_ctx uic = { . cur_fp = NULL . old_fp = NULL . cur_sb = STRBUF_INIT . old_sb = STRBUF_INIT } ; safe_create_leading_directories ( path ) ; fd = git_mkstemp_mode ( tmp , 0666 ) ; if ( fd < 0 ) { out } to_close = uic . cur_fp = fdopen ( fd , "w" ) ; if ( ! uic . cur_fp ) { out } fd = - 1 ; if ( ! force ) { uic . old_fp = fopen_or_warn ( path , "r" ) ; } ret = generate ( & uic ) ; if ( ret ) { out } if ( ! uic_is_stale ( & uic ) ) { struct stat st ; long new_len = ftell ( uic . cur_fp ) ; int old_fd = fileno ( uic . old_fp ) ; if ( new_len < 0 ) { ret = - 1 ; out } if ( fstat ( old_fd , & st ) || ( st . st_size != ( size_t ) new_len ) ) { uic_mark_stale ( & uic ) ; } } if ( fclose ( to_close ) ) { out } if ( uic_is_stale ( & uic ) ) { if ( adjust_shared_perm ( tmp ) < 0 ) { out } if ( rename ( tmp , path ) < 0 ) { out } } else { unlink ( tmp ) ; } ret = 0 ; out if ( ret ) { error_errno ( "unable to update %s" , path ) ; if ( uic . cur_fp ) { fclose ( uic . cur_fp ) ; } if ( fd >= 0 ) { close ( fd ) ; } unlink ( tmp ) ; } free ( tmp ) ; if ( uic . old_fp ) { fclose ( uic . old_fp ) ; } strbuf_release ( & uic . old_sb ) ; strbuf_release ( & uic . cur_sb ) ; return ret ; } 