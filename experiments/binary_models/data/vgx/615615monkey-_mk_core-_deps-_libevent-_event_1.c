void event_active_nolock_ ( struct event * ev , int res , short ncalls ) { struct event_base * base ; event_debug ( ( "event_active: %p (fd " EV_SOCK_FMT "), res %d, callback %p" , ev , EV_SOCK_ARG ( ev -> ev_fd ) , ( int ) res , ev -> ev_callback ) ) ; base = ev -> ev_base ; EVENT_BASE_ASSERT_LOCKED ( base ) ; if ( ev -> ev_flags & EVLIST_FINALIZING ) { return ; } switch ( ( ev -> ev_flags & ( EVLIST_ACTIVE | EVLIST_ACTIVE_LATER ) ) ) { default : case EVLIST_ACTIVE | EVLIST_ACTIVE_LATER : EVUTIL_ASSERT ( 0 ) ; break ; case EVLIST_ACTIVE : ev -> ev_res |= res ; return ; case EVLIST_ACTIVE_LATER : ev -> ev_res |= res ; break ; case 0 : ev -> ev_res = res ; break ; } if ( ev -> ev_pri < base -> event_running_priority ) { base -> event_continue = 1 ; } if ( ev -> ev_events & EV_SIGNAL ) { if ( base -> current_event == event_to_event_callback ( ev ) && ! EVBASE_IN_THREAD ( base ) ) { ++ base -> current_event_waiters ; EVTHREAD_COND_WAIT ( base -> current_event_cond , base -> th_base_lock ) ; } ev -> ev_ncalls = ncalls ; } event_callback_activate_nolock_ ( base , event_to_event_callback ( ev ) ) ; } 