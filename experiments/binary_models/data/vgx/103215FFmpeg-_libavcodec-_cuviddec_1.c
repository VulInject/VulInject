static av_cold int cuvid_decode_init ( AVCodecContext * avctx ) { CuvidContext * ctx = avctx -> priv_data ; AVCUDADeviceContext * device_hwctx ; AVHWDeviceContext * device_ctx ; AVHWFramesContext * hwframe_ctx ; CUVIDSOURCEDATAPACKET seq_pkt ; CUcontext cuda_ctx = NULL ; CUcontext dummy ; uint8_t * extradata ; int extradata_size ; int ret = 0 ; enum AVPixelFormat pix_fmts [ 3 ] { AV_PIX_FMT_CUDA AV_PIX_FMT_NV12 AV_PIX_FMT_NONE } ; ; int probed_width = avctx -> coded_width ?avctx -> coded_width : 1280 ; int probed_height = avctx -> coded_height ?avctx -> coded_height : 720 ; int probed_bit_depth = 8 ; const AVPixFmtDescriptor * probe_desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; if ( probe_desc && probe_desc -> nb_components ) { probed_bit_depth = probe_desc -> comp [ 0 ] . depth ; } ctx -> pkt = avctx -> internal -> in_pkt ; ret = ff_get_format ( avctx , pix_fmts ) ; if ( ret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "ff_get_format failed: %d\n" , ret ) ; return ret ; } avctx -> pix_fmt = ret ; if ( ctx -> resize_expr && sscanf ( ctx -> resize_expr , "%dx%d" , & ctx -> resize . width , & ctx -> resize . height ) != 2 ) { av_log ( avctx , AV_LOG_ERROR , "Invalid resize expressions\n" ) ; ret = AVERROR ( EINVAL ) ; error } if ( ctx -> crop_expr && sscanf ( ctx -> crop_expr , "%dx%dx%dx%d" , & ctx -> crop . top , & ctx -> crop . bottom , & ctx -> crop . left , & ctx -> crop . right ) != 4 ) { av_log ( avctx , AV_LOG_ERROR , "Invalid cropping expressions\n" ) ; ret = AVERROR ( EINVAL ) ; error } ret = cuvid_load_functions ( & ctx -> cvdl , avctx ) ; if ( ret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Failed loading nvcuvid.\n" ) ; error } ctx -> frame_queue = av_fifo_alloc2 ( ctx -> nb_surfaces , sizeof ( CuvidParsedFrame ) , 0 ) ; if ( ! ctx -> frame_queue ) { ret = AVERROR ( ENOMEM , NULL ) ; error } if ( avctx -> hw_frames_ctx ) { ctx -> hwframe = av_buffer_ref ( avctx -> hw_frames_ctx ) ; if ( ! ctx -> hwframe ) { ret = AVERROR ( ENOMEM ) ; error } hwframe_ctx = ( AVHWFramesContext * ) ctx -> hwframe -> data ; ctx -> hwdevice = av_buffer_ref ( hwframe_ctx -> device_ref ) ; if ( ! ctx -> hwdevice ) { ret = AVERROR ( ENOMEM ) ; error } } else { if ( avctx -> hw_device_ctx ) { ctx -> hwdevice = av_buffer_ref ( avctx -> hw_device_ctx ) ; if ( ! ctx -> hwdevice ) { ret = AVERROR ( ENOMEM ) ; error } } else { ret = av_hwdevice_ctx_create ( & ctx -> hwdevice , AV_HWDEVICE_TYPE_CUDA , ctx -> cu_gpu , NULL , 0 ) ; if ( ret < 0 ) { error } } ctx -> hwframe = av_hwframe_ctx_alloc ( ctx -> hwdevice ) ; if ( ! ctx -> hwframe ) { av_log ( avctx , AV_LOG_ERROR , "av_hwframe_ctx_alloc failed\n" ) ; ret = AVERROR ( ENOMEM ) ; error } hwframe_ctx = ( AVHWFramesContext * ) ctx -> hwframe -> data ; } device_ctx = hwframe_ctx -> device_ctx ; device_hwctx = device_ctx -> hwctx ; cuda_ctx = device_hwctx -> cuda_ctx ; ctx -> cudl = device_hwctx -> internal -> cuda_dl ; memset ( & ctx -> cuparseinfo , 0 , sizeof ( ctx -> cuparseinfo ) ) ; memset ( & seq_pkt , 0 , sizeof ( seq_pkt ) ) ; switch ( avctx -> codec -> id ) { case AV_CODEC_ID_H264 : ctx -> cuparseinfo . CodecType = cudaVideoCodec_H264 ; break ; case AV_CODEC_ID_HEVC : ctx -> cuparseinfo . CodecType = cudaVideoCodec_HEVC ; break ; case AV_CODEC_ID_MJPEG : ctx -> cuparseinfo . CodecType = cudaVideoCodec_JPEG ; break ; case AV_CODEC_ID_MPEG1VIDEO : ctx -> cuparseinfo . CodecType = cudaVideoCodec_MPEG1 ; break ; case AV_CODEC_ID_MPEG2VIDEO : ctx -> cuparseinfo . CodecType = cudaVideoCodec_MPEG2 ; break ; case AV_CODEC_ID_MPEG4 : ctx -> cuparseinfo . CodecType = cudaVideoCodec_MPEG4 ; break ; case AV_CODEC_ID_VP8 : ctx -> cuparseinfo . CodecType = cudaVideoCodec_VP8 ; break ; case AV_CODEC_ID_VP9 : ctx -> cuparseinfo . CodecType = cudaVideoCodec_VP9 ; break ; case AV_CODEC_ID_VC1 : ctx -> cuparseinfo . CodecType = cudaVideoCodec_VC1 ; break ; case AV_CODEC_ID_AV1 : ctx -> cuparseinfo . CodecType = cudaVideoCodec_AV1 ; break ; default : av_log ( avctx , AV_LOG_ERROR , "Invalid CUVID codec!\n" ) ; return AVERROR_BUG ; } if ( ffcodec ( avctx -> codec ) -> bsfs ) { const AVCodecParameters * par = avctx -> internal -> bsf -> par_out ; extradata = par -> extradata ; extradata_size = par -> extradata_size ; } else { extradata = avctx -> extradata ; extradata_size = avctx -> extradata_size ; } if ( avctx -> codec -> id == AV_CODEC_ID_AV1 && extradata_size > 4 && extradata [ 0 ] & 0x80 ) { extradata += 4 ; extradata_size -= 4 ; } ctx -> cuparse_ext = av_mallocz ( sizeof ( * ctx -> cuparse_ext ) + FFMAX ( extradata_size - ( int ) sizeof ( ctx -> cuparse_ext -> raw_seqhdr_data ) , 0 ) ) ; if ( ! ctx -> cuparse_ext ) { ret = AVERROR ( ENOMEM ) ; error } if ( extradata_size > 0 ) { memcpy ( ctx -> cuparse_ext -> raw_seqhdr_data , extradata , extradata_size ) ; } ctx -> cuparse_ext -> format . seqhdr_data_length = extradata_size ; ctx -> cuparseinfo . pExtVideoInfo = ctx -> cuparse_ext ; ctx -> key_frame = av_mallocz ( ctx -> nb_surfaces * sizeof ( int ) ) ; if ( ! ctx -> key_frame ) { ret = AVERROR ( ENOMEM ) ; error } ctx -> cuparseinfo . ulMaxNumDecodeSurfaces = ctx -> nb_surfaces ; ctx -> cuparseinfo . ulMaxDisplayDelay = ( avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) ?0 : 4 ; ctx -> cuparseinfo . pUserData = avctx ; ctx -> cuparseinfo . pfnSequenceCallback = cuvid_handle_video_sequence ; ctx -> cuparseinfo . pfnDecodePicture = cuvid_handle_picture_decode ; ctx -> cuparseinfo . pfnDisplayPicture = cuvid_handle_picture_display ; ret = CHECK_CU ( ctx -> cudl -> cuCtxPushCurrent ( cuda_ctx ) ) ; if ( ret < 0 ) { error } ret = cuvid_test_capabilities ( avctx , & ctx -> cuparseinfo , probed_width , probed_height , probed_bit_depth ) ; if ( ret < 0 ) { error } ret = CHECK_CU ( ctx -> cvdl -> cuvidCreateVideoParser ( & ctx -> cuparser , & ctx -> cuparseinfo ) ) ; if ( ret < 0 ) { error } seq_pkt . payload = ctx -> cuparse_ext -> raw_seqhdr_data ; seq_pkt . payload_size = ctx -> cuparse_ext -> format . seqhdr_data_length ; if ( seq_pkt . payload && seq_pkt . payload_size ) { ret = CHECK_CU ( ctx -> cvdl -> cuvidParseVideoData ( ctx -> cuparser , & seq_pkt ) ) ; if ( ret < 0 ) { error } } ret = CHECK_CU ( ctx -> cudl -> cuCtxPopCurrent ( & dummy ) ) ; if ( ret < 0 ) { error } ctx -> prev_pts = INT64_MIN ; if ( ! avctx -> pkt_timebase . num || ! avctx -> pkt_timebase . den ) { av_log ( avctx , AV_LOG_WARNING , "Invalid pkt_timebase, passing timestamps as-is.\n" ) ; } return 0 ; error cuvid_decode_end ( avctx ) ; return ret ; } 