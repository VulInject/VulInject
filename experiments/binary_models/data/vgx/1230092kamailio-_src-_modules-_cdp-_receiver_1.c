static int receive_fd ( int pipe_fd , int * fd , peer * * p ) { struct msghdr msg ; struct iovec iov [ 1 ] ; int new_fd ; int ret ; int * tmp = NULL ; struct cmsghdr * cmsg ; { struct cmsghdr cm ; char control [ CMSG_SPACE ( sizeof ( new_fd ) ) ] ; } , control_un msg . msg_control = control_un . control ; msg . msg_controllen = sizeof ( control_un . control ) ; msg . msg_accrights = ( caddr_t ) & new_fd ; msg . msg_accrightslen = sizeof ( int ) ; msg . msg_name = 0 ; msg . msg_namelen = 0 ; iov [ 0 ] . iov_base = p ; iov [ 0 ] . iov_len = sizeof ( peer * ) ; msg . msg_iov = iov ; msg . msg_iovlen = 1 ; again ret = recvmsg ( pipe_fd , & msg , MSG_DONTWAIT | MSG_WAITALL ) ; if ( ret < 0 ) { if ( errno == EINTR ) { again } if ( ( errno == EAGAIN ) || ( errno == EWOULDBLOCK ) ) { error } LM_CRIT ( "receive_fd: recvmsg on %d failed: %s\n" , pipe_fd , strerror ( errno ) ) ; error } if ( ret == 0 ) { LM_CRIT ( "receive_fd: EOF on %d\n" , pipe_fd ) ; error } if ( ret != sizeof ( peer * ) ) { LM_WARN ( "receive_fd: different number of bytes received than expected (%d from %ld)" "trying to fix...\n" , ret , ( long int ) sizeof ( peer * ) ) ; error } cmsg = CMSG_FIRSTHDR ( & msg ) ; if ( ( cmsg != 0 ) && ( cmsg -> cmsg_len == CMSG_LEN ( sizeof ( new_fd ) ) ) ) { if ( cmsg -> cmsg_type != SCM_RIGHTS ) { LM_ERR ( "receive_fd: msg control type != SCM_RIGHTS\n" ) ; error } if ( cmsg -> cmsg_level != SOL_SOCKET ) { LM_ERR ( "receive_fd: msg level != SOL_SOCKET\n" ) ; error } tmp = ( int * ) CMSG_DATA ( cmsg ) ; * fd = * tmp ; } else { if ( ! cmsg ) { LM_ERR ( "receive_fd: no descriptor passed, empty control message\n" ) ; } else { LM_ERR ( "receive_fd: no descriptor passed, cmsg=%p," "len=%d\n" , cmsg , ( unsigned ) cmsg -> cmsg_len ) ; } * fd = - 1 ; * p = 0 ; } if ( msg . msg_accrightslen == sizeof ( int ) ) { * fd = new_fd ; } else { LM_ERR ( "receive_fd: no descriptor passed," " accrightslen=%d\n" , msg . msg_accrightslen ) ; * fd = - 1 ; } return 1 ; error return 0 ; } 