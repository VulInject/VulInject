static RBuffer * create ( RBin * bin , const ut8 * code , int clen , const ut8 * data , int dlen , RBinArchOptions * opt ) { const bool use_pagezero = true ; const bool use_main = true ; const bool use_dylinker = true ; const bool use_libsystem = true ; const bool use_linkedit = true ; ut32 filesize , codeva , datava ; ut32 ncmds , cmdsize , magiclen ; ut32 p_codefsz = 0 , p_codeva = 0 , p_codesz = 0 , p_codepa = 0 ; ut32 p_datafsz = 0 , p_datava = 0 , p_datasz = 0 , p_datapa = 0 ; ut32 p_cmdsize = 0 , p_entry = 0 , p_tmp = 0 ; ut32 baddr = 0x1000 ; r_return_val_if_fail ( bin && opt , NULL ) ; bool is_arm = strstr ( opt -> arch , "arm" ) ; RBuffer * buf = r_buf_new ( ) ; if ( opt -> bits == 64 ) { R_LOG_TODO ( "Please use mach064 instead of mach0" ) ; return NULL ; } B ( "\xce\xfa\xed\xfe" , 4 ) ; if ( is_arm ) { D ( 12 ) ; D ( 3 ) ; } else { D ( 7 ) ; D ( 3 ) ; } D ( 2 ) ; if ( data && dlen > 0 ) { ncmds = 3 ; cmdsize = 0 ; } else { ncmds = 2 ; cmdsize = 0 ; } if ( use_pagezero ) { ncmds ++ ; } if ( use_dylinker ) { ncmds ++ ; if ( use_linkedit ) { ncmds += 3 ; } if ( use_libsystem ) { ncmds ++ ; } } D ( ncmds ) ; p_cmdsize = r_buf_size ( buf ) ; D ( - 1 ) ; D ( 0 ) ; magiclen = r_buf_size ( buf ) ; if ( use_pagezero ) { D ( 1 ) ; D ( 56 ) ; WZ ( 16 , "__PAGEZERO" ) ; D ( 0 ) ; D ( 0x00001000 ) ; D ( 0 ) ; D ( 0 ) ; D ( 0 ) ; D ( 0 ) ; D ( 0 ) ; D ( 0 ) ; } D ( 1 ) ; D ( 124 ) ; WZ ( 16 , "__TEXT" ) ; D ( baddr ) ; D ( 0x1000 ) ; D ( 0 ) ; p_codefsz = r_buf_size ( buf ) ; D ( - 1 ) ; D ( 7 ) ; D ( 5 ) ; D ( 1 ) ; D ( 0 ) ; WZ ( 16 , "__text" ) ; WZ ( 16 , "__TEXT" ) ; p_codeva = r_buf_size ( buf ) ; D ( - 1 ) ; p_codesz = r_buf_size ( buf ) ; D ( - 1 ) ; p_codepa = r_buf_size ( buf ) ; D ( - 1 ) ; D ( 0 ) ; D ( 0 ) ; D ( 0 ) ; D ( 0 ) ; D ( 0 ) ; D ( 0 ) ; if ( data && dlen > 0 ) { D ( 1 ) ; D ( 124 ) ; p_tmp = r_buf_size ( buf ) ; Z ( 16 ) ; W ( p_tmp , "__TEXT" , 6 ) ; D ( 0x2000 ) ; D ( 0x1000 ) ; D ( 0 ) ; p_datafsz = r_buf_size ( buf ) ; D ( - 1 ) ; D ( 6 ) ; D ( 6 ) ; D ( 1 ) ; D ( 0 ) ; WZ ( 16 , "__data" ) ; WZ ( 16 , "__DATA" ) ; p_datava = r_buf_size ( buf ) ; D ( - 1 ) ; p_datasz = r_buf_size ( buf ) ; D ( - 1 ) ; p_datapa = r_buf_size ( buf ) ; D ( - 1 ) ; D ( 2 ) ; D ( 0 ) ; D ( 0 ) ; D ( 0 ) ; D ( 0 ) ; D ( 0 ) ; } if ( use_dylinker ) { if ( use_linkedit ) { D ( 1 ) ; D ( 56 ) ; WZ ( 16 , "__LINKEDIT" ) ; D ( 0x3000 ) ; D ( 0x00001000 ) ; D ( 0x1000 ) ; D ( 0 ) ; D ( 7 ) ; D ( 1 ) ; D ( 0 ) ; D ( 0 ) ; D ( 2 ) ; D ( 24 ) ; D ( 0x1000 ) ; D ( 0 ) ; D ( 0x1000 ) ; D ( 0 ) ; D ( 0xb ) ; D ( 80 ) ; Z ( 18 * sizeof ( ut32 ) ) ; } const char * dyld = "/usr/lib/dyld" ; const int dyld_len = strlen ( dyld ) + 1 ; D ( 0xe ) ; D ( ( 4 * 3 ) + dyld_len ) ; D ( dyld_len - 2 ) ; WZ ( dyld_len , dyld ) ; if ( use_libsystem ) { const char * lib = "/usr/lib/libSystem.B.dylib" ; const int lib_len = strlen ( lib ) + 1 ; D ( 0xc ) ; D ( 24 + lib_len ) ; D ( 24 ) ; D ( 0x2 ) ; D ( 0x1 ) ; D ( 0x1 ) ; WZ ( lib_len , lib ) ; } } if ( use_main ) { D ( 0x80000028 ) ; D ( 24 ) ; D ( baddr ) ; D ( 0 ) ; D ( 0 ) ; D ( 0 ) ; } else { D ( 5 ) ; D ( 80 ) ; if ( is_arm ) { D ( 1 ) ; D ( 17 ) ; p_entry = r_buf_size ( buf ) + ( 16 * sizeof ( ut32 ) ) ; Z ( 17 * sizeof ( ut32 ) ) ; } else { D ( 1 ) ; D ( 16 ) ; p_entry = r_buf_size ( buf ) + ( 10 * sizeof ( ut32 ) ) ; Z ( 16 * sizeof ( ut32 ) ) ; } } WZ ( 4096 - r_buf_size ( buf ) , "" ) ; cmdsize = r_buf_size ( buf ) - magiclen ; codeva = r_buf_size ( buf ) + baddr ; datava = r_buf_size ( buf ) + clen + baddr ; if ( p_entry != 0 ) { W ( p_entry , & codeva , 4 ) ; } W ( p_cmdsize , & cmdsize , 4 ) ; filesize = magiclen + cmdsize + clen + dlen ; W ( p_codefsz , & filesize , 4 ) ; W ( p_codefsz - 8 , & filesize , 4 ) ; W ( p_codeva , & codeva , 4 ) ; W ( p_codesz , & clen , 4 ) ; p_tmp = codeva - baddr ; W ( p_codepa , & p_tmp , 4 ) ; B ( code , clen ) ; if ( data && dlen > 0 ) { W ( p_datafsz , & filesize , 4 ) ; W ( p_datava , & datava , 4 ) ; W ( p_datasz , & dlen , 4 ) ; p_tmp = datava - baddr ; W ( p_datapa , & p_tmp , 4 ) ; B ( data , dlen ) ; } return buf ; } 