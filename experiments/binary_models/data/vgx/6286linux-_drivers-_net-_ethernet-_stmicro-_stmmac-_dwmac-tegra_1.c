static int tegra_mgbe_probe ( struct platform_device * pdev ) { struct plat_stmmacenet_data * plat ; struct stmmac_resources res ; struct tegra_mgbe * mgbe ; int irq , err , i ; u32 value ; mgbe = devm_kzalloc ( & pdev -> dev , sizeof ( * mgbe ) , GFP_KERNEL ) ; if ( ! mgbe ) { return - ENOMEM ; } mgbe -> dev = & pdev -> dev ; irq = platform_get_irq ( pdev , 0 ) ; if ( irq < 0 ) { return irq ; } mgbe -> hv = devm_platform_ioremap_resource_byname ( pdev , "hypervisor" ) ; if ( IS_ERR ( mgbe -> hv ) ) { return PTR_ERR ( mgbe -> hv ) ; } mgbe -> regs = devm_platform_ioremap_resource_byname ( pdev , "mac" ) ; if ( IS_ERR ( mgbe -> regs ) ) { return PTR_ERR ( mgbe -> regs ) ; } mgbe -> xpcs = devm_platform_ioremap_resource_byname ( pdev , "xpcs" ) ; if ( IS_ERR ( mgbe -> xpcs ) ) { return PTR_ERR ( mgbe -> xpcs ) ; } res . addr = mgbe -> regs ; res . irq = irq ; mgbe -> clks = devm_kzalloc ( & pdev -> dev , sizeof ( * mgbe -> clks ) , GFP_KERNEL ) ; if ( ! mgbe -> clks ) { return - ENOMEM ; } for ( i = 0 ; i < ARRAY_SIZE ( mgbe_clks ) ; i ++ ) { mgbe -> clks [ i ] . id = mgbe_clks [ i ] ; } err = devm_clk_bulk_get ( mgbe -> dev , ARRAY_SIZE ( mgbe_clks ) , mgbe -> clks ) ; if ( err < 0 ) { return err ; } err = clk_bulk_prepare_enable ( ARRAY_SIZE ( mgbe_clks ) , mgbe -> clks ) ; if ( err < 0 ) { return err ; } mgbe -> rst_mac = devm_reset_control_get ( & pdev -> dev , "mac" ) ; if ( IS_ERR ( mgbe -> rst_mac ) ) { err = PTR_ERR ( mgbe -> rst_mac ) ; disable_clks } err = reset_control_assert ( mgbe -> rst_mac ) ; if ( err < 0 ) { disable_clks } usleep_range ( 2000 , 4000 ) ; err = reset_control_deassert ( mgbe -> rst_mac ) ; if ( err < 0 ) { disable_clks } mgbe -> rst_pcs = devm_reset_control_get ( & pdev -> dev , "pcs" ) ; if ( IS_ERR ( mgbe -> rst_pcs ) ) { err = PTR_ERR ( mgbe -> rst_pcs ) ; disable_clks } err = reset_control_assert ( mgbe -> rst_pcs ) ; if ( err < 0 ) { disable_clks } usleep_range ( 2000 , 4000 ) ; err = reset_control_deassert ( mgbe -> rst_pcs ) ; if ( err < 0 ) { disable_clks } plat = stmmac_probe_config_dt ( pdev , res . mac ) ; if ( IS_ERR ( plat ) ) { err = PTR_ERR ( plat ) ; disable_clks } plat -> has_xgmac = 1 ; plat -> tso_en = 1 ; plat -> pmt = 1 ; plat -> bsp_priv = mgbe ; if ( ! plat -> mdio_node ) { plat -> mdio_node = of_get_child_by_name ( pdev -> dev . of_node , "mdio" ) ; } if ( ! plat -> mdio_bus_data ) { plat -> mdio_bus_data = devm_kzalloc ( & pdev -> dev , sizeof ( * plat -> mdio_bus_data ) , GFP_KERNEL ) ; if ( ! plat -> mdio_bus_data ) { err = - ENOMEM ; remove } } plat -> mdio_bus_data -> needs_reset = true ; value = readl ( mgbe -> xpcs + XPCS_WRAP_UPHY_STATUS ) ; if ( ( value & XPCS_WRAP_UPHY_STATUS_TX_P_UP ) == 0 ) { value = readl ( mgbe -> xpcs + XPCS_WRAP_UPHY_HW_INIT_CTRL ) ; value |= XPCS_WRAP_UPHY_HW_INIT_CTRL_TX_EN ; writel ( value , mgbe -> xpcs + XPCS_WRAP_UPHY_HW_INIT_CTRL ) ; } err = readl_poll_timeout ( mgbe -> xpcs + XPCS_WRAP_UPHY_HW_INIT_CTRL , value , ( value & XPCS_WRAP_UPHY_HW_INIT_CTRL_TX_EN ) == 0 , 500 , 500 * 2000 ) ; if ( err < 0 ) { dev_err ( mgbe -> dev , "timeout waiting for TX lane to become enabled\n" ) ; remove } plat -> serdes_powerup = mgbe_uphy_lane_bringup_serdes_up ; plat -> serdes_powerdown = mgbe_uphy_lane_bringup_serdes_down ; plat -> tx_fifo_size = 131072 ; plat -> rx_fifo_size = 196608 ; writel ( MAC_SBD_INTR , mgbe -> regs + MGBE_WRAP_COMMON_INTR_ENABLE ) ; writel ( MGBE_SID , mgbe -> hv + MGBE_WRAP_AXI_ASID0_CTRL ) ; plat -> serdes_up_after_phy_linkup = 1 ; err = stmmac_dvr_probe ( & pdev -> dev , plat , & res ) ; if ( err < 0 ) { remove } return 0 ; remove stmmac_remove_config_dt ( pdev , plat ) ; disable_clks clk_bulk_disable_unprepare ( ARRAY_SIZE ( mgbe_clks ) , mgbe -> clks ) ; return err ; } 