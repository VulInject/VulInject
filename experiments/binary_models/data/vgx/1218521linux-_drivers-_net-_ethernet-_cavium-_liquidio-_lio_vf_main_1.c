static int liquidio_stop ( struct net_device * netdev ) { struct lio * lio = GET_LIO ( netdev ) ; struct octeon_device * oct = lio -> oct_dev ; struct octeon_device_priv * oct_priv = ( octeon_device_priv * ) oct -> priv ; struct napi_struct * napi , * n ; int ret = 0 ; ret = send_rx_ctrl_cmd ( lio , 0 ) ; netif_info ( lio , ifdown , lio -> netdev , "Stopping interface!\n" ) ; lio -> intf_open = 0 ; lio -> linfo . link . s . link_up = 0 ; netif_carrier_off ( netdev ) ; lio -> link_changes ++ ; ifstate_reset ( lio , LIO_IFSTATE_RUNNING ) ; stop_txqs ( netdev ) ; if ( lio_wait_for_clean_oq ( oct ) ) { netif_info ( lio , rx_err , lio -> netdev , "Proceeding with stop interface after partial RX desc processing\n" ) ; } if ( oct -> props [ lio -> ifidx ] . napi_enabled == 1 ) { list_for_each_entry_safe ( , , , ) napi_disable ( napi ) ; oct -> props [ lio -> ifidx ] . napi_enabled = 0 ; oct -> droq [ 0 ] -> ops . poll_mode = 0 ; tasklet_enable ( & oct_priv -> droq_tasklet ) ; } cancel_delayed_work_sync ( & lio -> stats_wk . work ) ; dev_info ( & oct -> pci_dev -> dev , "%s interface is stopped\n" , netdev -> name ) ; return ret ; } 