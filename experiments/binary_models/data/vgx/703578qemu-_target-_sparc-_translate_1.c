static void gen_op_addx_int ( DisasContext * dc , TCGv dst , TCGv src1 , TCGv src2 , int update_cc ) { TCGv_i32 carry_32 ; TCGv carry ; switch ( dc -> cc_op ) { case CC_OP_DIV : case CC_OP_LOGIC : if ( update_cc ) { gen_op_add_cc ( dst , src1 , src2 ) ; } else { tcg_gen_add_tl ( dst , src1 , src2 ) ; } return ; case CC_OP_ADD : case CC_OP_TADD : case CC_OP_TADDTV : if ( TARGET_LONG_BITS == 32 ) { carry = tcg_temp_new ( ) ; tcg_gen_add2_tl ( carry , dst , cpu_cc_src , src1 , cpu_cc_src2 , src2 ) ; add_done } carry_32 = gen_add32_carry32 ( ) ; break ; case CC_OP_SUB : case CC_OP_TSUB : case CC_OP_TSUBTV : carry_32 = gen_sub32_carry32 ( ) ; break ; default : carry_32 = tcg_temp_new_i32 ( ) ; gen_helper_compute_C_icc ( carry_32 , cpu_env ) ; break ; } carry = tcg_temp_new ( ) ; tcg_gen_extu_i32_i64 ( carry , carry_32 ) ; carry = carry_32 ; tcg_gen_add_tl ( dst , src1 , src2 ) ; tcg_gen_add_tl ( dst , dst , carry ) ; tcg_temp_free_i32 ( carry_32 ) ; tcg_temp_free ( carry ) ; add_done if ( update_cc ) { tcg_gen_mov_tl ( cpu_cc_src , src1 ) ; tcg_gen_mov_tl ( cpu_cc_src2 , src2 ) ; tcg_gen_mov_tl ( cpu_cc_dst , dst ) ; tcg_gen_movi_i32 ( cpu_cc_op , CC_OP_ADDX ) ; dc -> cc_op = CC_OP_ADDX ; } } 