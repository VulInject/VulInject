kadm5_ret_t kadm5_s_randkey_principal ( void * server_handle , krb5_principal princ , krb5_boolean keepold , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , krb5_keyblock * * new_keys , int * n_keys ) { kadm5_server_context * context = server_handle ; hdb_entry ent ; kadm5_ret_t ret ; size_t i ; if ( ! context -> keep_open ) { ret = context -> db -> hdb_open ( context -> context , context -> db , O_RDWR , 0 ) ; if ( ret ) { return ret ; } } ret = kadm5_log_init ( context ) ; if ( ret ) { out } ret = context -> db -> hdb_fetch_kvno ( context -> context , context -> db , princ , HDB_F_DECRYPT | HDB_F_GET_ANY | HDB_F_ADMIN_DATA , 0 , & ent ) ; if ( ret ) { out2 } ret = randkey_principal_hook ( context , KADM5_HOOK_STAGE_PRECOMMIT , 0 , princ ) ; if ( ret ) { out3 } if ( keepold ) { ret = hdb_add_current_keys_to_history ( context -> context , & ent ) ; if ( ret == 0 && keepold == 1 ) { ret = hdb_prune_keys_kvno ( context -> context , & ent , 0 ) ; } if ( ret ) { out3 } } else { ret = hdb_clear_extension ( context -> context , & ent , choice_HDB_extension_data_hist_keys ) ; if ( ret ) { out3 } } ret = _kadm5_set_keys_randomly ( context , & ent , n_ks_tuple , ks_tuple , new_keys , n_keys ) ; if ( ret ) { out3 } ent . kvno ++ ; ent . flags . require_pwchange = 0 ; ret = _kadm5_set_modifier ( context , & ent ) ; if ( ret ) { out4 } ret = _kadm5_bump_pw_expire ( context , & ent ) ; if ( ret ) { out4 } if ( keepold ) { ret = hdb_seal_keys ( context -> context , context -> db , & ent ) ; if ( ret ) { out4 } } else { HDB_extension ext ; memset ( & ext , 0 , sizeof ( ext ) ) ; ext . mandatory = FALSE ; ext . data . element = choice_HDB_extension_data_hist_keys ; ext . data . u . hist_keys . len = 0 ; ext . data . u . hist_keys . val = NULL ; hdb_replace_extension ( context -> context , & ent , & ext ) ; } ret = kadm5_log_modify ( context , & ent , KADM5_ATTRIBUTES | KADM5_PRINCIPAL | KADM5_MOD_NAME | KADM5_MOD_TIME | KADM5_KEY_DATA | KADM5_KVNO | KADM5_PW_EXPIRATION | KADM5_TL_DATA ) ; ( void ) randkey_principal_hook ( context , KADM5_HOOK_STAGE_POSTCOMMIT , ret , princ ) ; out4 if ( ret ) { for ( i = 0 ; i < * n_keys ; ++ i ) { krb5_free_keyblock_contents ( context -> context , & ( * new_keys ) [ i ] ) ; } free ( * new_keys ) ; * new_keys = NULL ; * n_keys = 0 ; } out3 hdb_free_entry ( context -> context , context -> db , & ent ) ; out2 ( void ) kadm5_log_end ( context ) ; out if ( ! context -> keep_open ) { kadm5_ret_t ret2 ; ret2 = context -> db -> hdb_close ( context -> context , context -> db ) ; if ( ret == 0 && ret2 != 0 ) { ret = ret2 ; } } return _kadm5_error_code ( ret ) ; } 