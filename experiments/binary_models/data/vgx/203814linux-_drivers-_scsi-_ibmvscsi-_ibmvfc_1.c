static int ibmvfc_bsg_plogi ( struct ibmvfc_host * vhost , unsigned int port_id ) { struct ibmvfc_port_login * plogi ; struct ibmvfc_target * tgt ; struct ibmvfc_event * evt ; union ibmvfc_iu rsp_iu ; unsigned long flags ; int rc = 0 , issue_login = 1 ; ENTER ; spin_lock_irqsave ( vhost -> host -> host_lock , flags ) ; list_for_each_entry ( , , ) { if ( tgt -> scsi_id == port_id ) { issue_login = 0 ; break ; } } if ( ! issue_login ) { unlock_out } if ( unlikely ( ( rc = ibmvfc_host_chkready ( vhost ) ) ) ) { unlock_out } evt = ibmvfc_get_event ( & vhost -> crq ) ; ibmvfc_init_event ( evt , ibmvfc_sync_completion , IBMVFC_MAD_FORMAT ) ; plogi = & evt -> iu . plogi ; plogi -> common . version = cpu_to_be32 ( 1 ) ; plogi -> common . opcode = cpu_to_be32 ( IBMVFC_PORT_LOGIN ) ; plogi -> common . length = cpu_to_be16 ( sizeof ( * plogi ) ) ; plogi -> scsi_id = cpu_to_be64 ( port_id ) ; evt -> sync_iu = & rsp_iu ; init_completion ( & evt -> comp ) ; rc = ibmvfc_send_event ( evt , vhost , default_timeout ) ; spin_unlock_irqrestore ( vhost -> host -> host_lock , flags ) ; if ( rc ) { return - EIO ; } wait_for_completion ( & evt -> comp ) ; if ( rsp_iu . plogi . common . status ) { rc = - EIO ; } spin_lock_irqsave ( vhost -> host -> host_lock , flags ) ; ibmvfc_free_event ( evt ) ; unlock_out spin_unlock_irqrestore ( vhost -> host -> host_lock , flags ) ; LEAVE ; return rc ; } 