static struct block * gen_gateway ( compiler_state_t * cstate , const u_char * eaddr , struct addrinfo * alist , int proto , int dir ) { struct block * b0 , * b1 , * tmp ; struct addrinfo * ai ; struct sockaddr_in * sin ; if ( dir != 0 ) { bpf_error ( cstate , "direction applied to 'gateway'" ) ; } switch ( proto ) { case Q_DEFAULT : case Q_IP : case Q_ARP : case Q_RARP : switch ( cstate -> linktype ) { case DLT_EN10MB : case DLT_NETANALYZER : case DLT_NETANALYZER_TRANSPARENT : b1 = gen_prevlinkhdr_check ( cstate ) ; b0 = gen_ehostop ( cstate , eaddr , Q_OR ) ; if ( b1 != NULL ) { gen_and ( b1 , b0 ) ; } break ; case DLT_FDDI : b0 = gen_fhostop ( cstate , eaddr , Q_OR ) ; break ; case DLT_IEEE802 : b0 = gen_thostop ( cstate , eaddr , Q_OR ) ; break ; case DLT_IEEE802_11 : case DLT_PRISM_HEADER : case DLT_IEEE802_11_RADIO_AVS : case DLT_IEEE802_11_RADIO : case DLT_PPI : b0 = gen_wlanhostop ( cstate , eaddr , Q_OR ) ; break ; case DLT_SUNATM : bpf_error ( cstate , "'gateway' supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel" ) ; break ; case DLT_IP_OVER_FC : b0 = gen_ipfchostop ( cstate , eaddr , Q_OR ) ; break ; default : bpf_error ( cstate , "'gateway' supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel" ) ; } b1 = NULL ; for ( ai = alist ; ai != NULL ; ai = ai -> ai_next ) { if ( ai -> ai_addr != NULL ) { if ( ai -> ai_addr -> sa_family == AF_INET ) { sin = ( sockaddr_in * ) ai -> ai_addr ; tmp = gen_host ( cstate , ntohl ( sin -> sin_addr . s_addr ) , 0xffffffff , proto , Q_OR , Q_HOST ) ; if ( b1 == NULL ) { b1 = tmp ; } else { gen_or ( b1 , tmp ) ; b1 = tmp ; } } } } gen_not ( b1 ) ; gen_and ( b0 , b1 ) ; return b1 ; } bpf_error ( cstate , "illegal modifier of 'gateway'" ) ; } 