static int MRD_OK ( GGadget * g , GEvent * e ) { if ( e -> type == et_controlevent && e -> u . control . subtype == et_buttonactivate ) { MassRenameDlg * mrd = GDrawGetUserData ( GGadgetGetWindow ( g ) ) ; int sel_cnt , enc , enc_max = mrd -> fv -> b . map -> enccount ; char * start_name , * suffix , * pt ; int enc_start ; SplineChar * sc , * sourcesc ; GTextInfo * subti ; struct lookup_subtable * sub ; PST * pst ; int themselves = GGadgetIsChecked ( GWidgetGetControl ( mrd -> gw , CID_Themselves ) ) ; int rplsuffix = GGadgetIsChecked ( GWidgetGetControl ( mrd -> gw , CID_ReplaceSuffix ) ) ; for ( enc = sel_cnt = 0 ; enc < enc_max ; ++ enc ) { if ( mrd -> fv -> b . selected [ enc ] ) { ++ sel_cnt ; } } if ( ! themselves ) { char * freeme = GGadgetGetTitle8 ( GWidgetGetControl ( mrd -> gw , CID_StartName ) ) ; start_name = GlyphNameListDeUnicode ( freeme ) ; enc_start = SFFindSlot ( mrd -> fv -> b . sf , mrd -> fv -> b . map , - 1 , start_name ) ; if ( enc_start == - 1 ) { ff_post_error ( _ ( "No Start Glyph" ) , _ ( "The encoding does not contain something named %.40s" ) , start_name ) ; free ( start_name ) ; return ( true ) ; } free ( start_name ) ; if ( enc_start + sel_cnt >= enc_max ) { ff_post_error ( _ ( "Not enough glyphs" ) , _ ( "There aren't enough glyphs in the encoding to name all the selected characters" ) ) ; return ( true ) ; } for ( enc = enc_start ; enc < enc_start + sel_cnt ; ++ enc ) { if ( mrd -> fv -> b . selected [ enc ] ) { ff_post_error ( _ ( "Bad selection" ) , _ ( "You may not rename any of the base glyphs, but your selection overlaps the set of base glyphs." ) ) ; return ( true ) ; } } } else { enc_start = 0 ; } sub = NULL ; subti = GGadgetGetListItemSelected ( GWidgetGetControl ( mrd -> gw , CID_SubTable ) ) ; if ( subti != NULL ) { sub = subti -> userdata ; } if ( sub == ( lookup_subtable * ) - 1 ) { sub = NULL ; } if ( sub != NULL && themselves ) { ff_post_error ( _ ( "Can't specify a subtable here" ) , _ ( "As the selected glyphs are also source glyphs, they will be renamed, so they can't act as source glyphs for a lookup." ) ) ; return ( true ) ; } suffix = GGadgetGetTitle8 ( GWidgetGetControl ( mrd -> gw , CID_Suffix ) ) ; if ( * suffix == '\0' || ( * suffix == '.' && suffix [ 1 ] == '\0' ) ) { ff_post_error ( _ ( "Missing suffix" ) , _ ( "If you don't specify a suffix, the glyphs don't get renamed." ) ) ; free ( suffix ) ; return ( true ) ; } if ( * suffix != '.' ) { char * old = suffix ; suffix = strconcat ( "." , suffix ) ; free ( old ) ; } for ( enc = sel_cnt = 0 ; enc < enc_max ; ++ enc ) { if ( mrd -> fv -> b . selected [ enc ] ) { char * oldname ; sourcesc = sc = SFMakeChar ( mrd -> fv -> b . sf , mrd -> fv -> b . map , enc ) ; if ( ! themselves ) { sourcesc = SFMakeChar ( mrd -> fv -> b . sf , mrd -> fv -> b . map , enc_start + sel_cnt ) ; } oldname = sc -> name ; if ( rplsuffix && ( pt = strchr ( sourcesc -> name , '.' ) ) != NULL ) { char * name = malloc ( pt - sourcesc -> name + strlen ( suffix ) + 2 ) ; strcpy ( name , sourcesc -> name ) ; strcpy ( name + ( pt - sourcesc -> name ) , suffix ) ; sc -> name = name ; } else { sc -> name = strconcat ( sourcesc -> name , suffix ) ; } free ( oldname ) ; sc -> unicodeenc = - 1 ; if ( sub != NULL ) { for ( pst = sourcesc -> possub ; pst != NULL && pst -> subtable != sub ; pst = pst -> next ) { } if ( pst == NULL ) { pst = chunkalloc ( sizeof ( PST ) ) ; pst -> next = sourcesc -> possub ; sourcesc -> possub = pst ; pst -> subtable = sub ; pst -> type = pst_substitution ; } free ( pst -> u . subs . variant ) ; pst -> u . subs . variant = copy ( sc -> name ) ; } ++ sel_cnt ; } } free ( suffix ) ; mrd -> done = true ; } return ( true ) ; } 