( of_regulator_match ) ; struct regulator_init_data * regulator_of_get_init_data ( struct device * dev , const struct regulator_desc * desc , struct regulator_config * config , struct device_node * * node ) { struct device_node * search , * child ; struct regulator_init_data * init_data = NULL ; const char * name ; if ( ! dev -> of_node || ! desc -> of_match ) { return in ; } if ( desc -> regulators_node ) { search = of_get_child_by_name ( dev -> of_node , desc -> regulators_node ) ; } else { search = dev -> of_node ; } if ( ! search ) { dev_dbg ( dev , "Failed to find regulator container node '%s'\n" , desc -> regulators_node ) ; return NULL ; } for_each_available_child_of_node ( , ) { name = of_get_property ( child , "regulator-compatible" , NULL ) ; if ( ! name ) { name = child -> name ; } if ( strcmp ( desc -> of_match , name ) ) { continue ; } init_data = of_get_regulator_init_data ( dev , child , desc ) ; if ( ! init_data ) { dev_err ( dev , "failed to parse DT for regulator %s\n" , child -> name ) ; break ; } if ( desc -> of_parse_cb ) { if ( desc -> of_parse_cb ( child , desc , config ) ) { dev_err ( dev , "driver callback failed to parse DT for regulator %s\n" , child -> name ) ; init_data = NULL ; break ; } } of_node_get ( child ) ; * node = child ; break ; } of_node_put ( search ) ; return init_data ; } 