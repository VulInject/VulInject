fontmap_parse_mapdef_dpm ( , , ) { const char * p = mapdef ; skip_blank ( & p , endptr ) ; if ( p < endptr && * p != '-' ) { mrec -> enc_name = parse_string_value ( & p , endptr ) ; skip_blank ( & p , endptr ) ; } if ( p < endptr && * p != '-' ) { mrec -> font_name = parse_string_value ( & p , endptr ) ; skip_blank ( & p , endptr ) ; } if ( mrec -> font_name ) { char * tmp ; tmp = strip_options ( mrec -> font_name , & mrec -> opt ) ; if ( tmp ) { RELEASE ( mrec -> font_name ) ; mrec -> font_name = tmp ; } } skip_blank ( & p , endptr ) ; while ( p + 1 < endptr && * p != '\r' && * p != '\n' && * p == '-' ) { char * q , mopt = p [ 1 ] ; int v ; p += 2 ; skip_blank ( & p , endptr ) ; switch ( mopt ) { case 's' : q = parse_float_decimal ( & p , endptr ) ; if ( ! q ) { WARN ( "Missing a number value for 's' option." ) ; return - 1 ; } mrec -> opt . slant = atof ( q ) ; RELEASE ( q ) ; break ; case 'e' : q = parse_float_decimal ( & p , endptr ) ; if ( ! q ) { WARN ( "Missing a number value for 'e' option." ) ; return - 1 ; } mrec -> opt . extend = atof ( q ) ; if ( mrec -> opt . extend <= 0.0 ) { WARN ( "Invalid value for 'e' option: %s" , q ) ; return - 1 ; } RELEASE ( q ) ; break ; case 'b' : q = parse_float_decimal ( & p , endptr ) ; if ( ! q ) { WARN ( "Missing a number value for 'b' option." ) ; return - 1 ; } mrec -> opt . bold = atof ( q , NULL ) ; if ( mrec -> opt . bold <= 0.0 ) { WARN ( "Invalid value for 'b' option: %s" , q ) ; return - 1 ; } RELEASE ( q ) ; break ; case 'r' : break ; case 'i' : q = parse_integer_value ( & p , endptr , 10 ) ; if ( ! q ) { WARN ( "Missing TTC index number..." ) ; return - 1 ; } mrec -> opt . index = strtoul ( q , NULL , 10 ) ; RELEASE ( q ) ; break ; case 'p' : q = parse_integer_value ( & p , endptr , 0 ) ; if ( ! q ) { WARN ( "Missing a number for 'p' option." ) ; return - 1 ; } v = strtol ( q , NULL , 0 ) ; if ( v ( 0 || v ) 16 ) { WARN ( "Invalid value for option 'p': %s" , q ) ; } else { mrec -> opt . mapc = v << 16 ; } RELEASE ( q ) ; break ; case 'u' : q = parse_string_value ( & p , endptr ) ; if ( q ) { mrec -> opt . tounicode = q ; } else { WARN ( "Missing string value for option 'u'." ) ; return - 1 ; } break ; case 'v' : q = parse_integer_value ( & p , endptr , 10 ) ; if ( ! q ) { WARN ( "Missing a number for 'v' option." ) ; return - 1 ; } mrec -> opt . stemv = strtol ( q , NULL , 0 ) ; RELEASE ( q ) ; break ; case 'l' : q = parse_string_value ( & p , endptr ) ; if ( q ) { mrec -> opt . otl_tags = q ; } else { WARN ( "Missing string value for option 'l'." ) ; return - 1 ; } break ; case 'm' : if ( p + 4 <= endptr && p [ 0 ] == '<' && p [ 3 ] == '>' ) { p ++ ; q = parse_integer_value ( & p , endptr , 16 ) ; if ( ! q ) { WARN ( "Invalid value for option 'm'." ) ; return - 1 ; } if ( p < endptr && * p != '>' ) { WARN ( "Invalid value for option 'm': %s" , q ) ; RELEASE ( q ) ; return - 1 ; } v = strtol ( q , NULL , 16 ) ; mrec -> opt . mapc = ( ( v << 8 ) & 0x0000ff00L ) ; RELEASE ( q ) ; p ++ ; } if ( p + 4 <= endptr && ! memcmp ( p , "sfd:" , strlen ( "sfd:" ) ) ) { char * r ; const char * rr ; p += 4 ; skip_blank ( & p , endptr ) ; q = parse_string_value ( & p , endptr ) ; if ( ! q ) { WARN ( "Missing value for option 'm'." ) ; return - 1 ; } r = strchr ( q , ',' ) ; if ( ! r ) { WARN ( "Invalid value for option 'm': %s" , q ) ; RELEASE ( q ) ; return - 1 ; } * r = 0 ; rr = ++ r ; skip_blank ( & rr , r + strlen ( r ) ) ; if ( * rr == '\0' ) { WARN ( "Invalid value for option 'm': %s," , q ) ; RELEASE ( q ) ; return - 1 ; } mrec -> charmap . sfd_name = mstrdup ( q ) ; mrec -> charmap . subfont_id = mstrdup ( rr ) ; RELEASE ( q ) ; } if ( p + 4 < endptr && ! memcmp ( p , "pad:" , strlen ( "pad:" ) ) ) { p += 4 ; skip_blank ( & p , endptr ) ; q = parse_integer_value ( & p , endptr , 16 ) ; if ( ! q ) { WARN ( "Invalid value for option 'm'." ) ; return - 1 ; } if ( p < endptr && ! isspace ( ( unsigned char ) * p ) ) { WARN ( "Invalid value for option 'm': %s" , q ) ; RELEASE ( q ) ; return - 1 ; } v = strtol ( q , NULL , 16 ) ; mrec -> opt . mapc = ( ( v << 8 ) & 0x0000ff00L ) ; RELEASE ( q ) ; } else { WARN ( "Invalid value for option 'm'." ) ; return - 1 ; } break ; case 'w' : if ( ! mrec -> enc_name || strcmp ( mrec -> enc_name , "unicode" ) ) { WARN ( "Fontmap option 'w' meaningless for encoding other than \"unicode\"." ) ; return - 1 ; } q = parse_integer_value ( & p , endptr , 10 ) ; if ( ! q ) { WARN ( "Missing wmode value..." ) ; return - 1 ; } if ( atoi ( q ) == 1 ) { mrec -> opt . flags |= FONTMAP_OPT_VERT ; } if ( atoi ( q ) == 0 ) { mrec -> opt . flags &= ~ FONTMAP_OPT_VERT ; } else { WARN ( "Invalid value for option 'w': %s" , q ) ; } RELEASE ( q ) ; break ; default : WARN ( "Unrecognized font map option: '%c'" , mopt ) ; return - 1 ; } skip_blank ( & p , endptr ) ; } if ( p < endptr && * p != '\r' && * p != '\n' ) { WARN ( "Invalid char in fontmap line: %c" , * p ) ; return - 1 ; } return 0 ; } 