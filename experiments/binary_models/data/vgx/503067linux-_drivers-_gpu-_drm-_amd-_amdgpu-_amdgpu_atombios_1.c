bool amdgpu_atombios_get_asic_ss_info ( struct amdgpu_device * adev , struct amdgpu_atom_ss * ss , int id , u32 clock ) { struct amdgpu_mode_info * mode_info = & adev -> mode_info ; int index = GetIndexIntoMasterTable ( DATA , ASIC_InternalSS_Info ) ; uint16_t data_offset , size ; union asic_ss_info * ss_info ; union asic_ss_assignment * ss_assign ; uint8_t frev , crev ; int i , num_indices ; if ( id == ASIC_INTERNAL_MEMORY_SS ) { if ( ! ( adev -> mode_info . firmware_flags & ATOM_BIOS_INFO_MEMORY_CLOCK_SS_SUPPORT ) ) { return false ; } } if ( id == ASIC_INTERNAL_ENGINE_SS ) { if ( ! ( adev -> mode_info . firmware_flags & ATOM_BIOS_INFO_ENGINE_CLOCK_SS_SUPPORT ) ) { return false ; } } if ( amdgpu_atom_parse_data_header ( mode_info -> atom_context , index , & size , & frev , & crev , & data_offset ) ) { ss_info = ( asic_ss_info * ) ( mode_info -> atom_context -> bios + data_offset ) ; switch ( frev ) { case 1 : num_indices = ( size - sizeof ( ATOM_COMMON_TABLE_HEADER ) ) / sizeof ( ATOM_ASIC_SS_ASSIGNMENT ) ; ss_assign = ( asic_ss_assignment * ) ( ( u8 * ) & ss_info -> info . asSpreadSpectrum [ 0 ] ) ; for ( i = 0 ; i < num_indices ; i ++ ) { if ( ( ss_assign -> v1 . ucClockIndication == id ) && ( clock <= le32_to_cpu ( ss_assign -> v1 . ulTargetClockRange ) ) ) { ss -> percentage = le16_to_cpu ( ss_assign -> v1 . usSpreadSpectrumPercentage ) ; ss -> type = ss_assign -> v1 . ucSpreadSpectrumMode ; ss -> rate = le16_to_cpu ( ss_assign -> v1 . usSpreadRateInKhz ) ; ss -> percentage_divider = 100 ; return true ; } ss_assign = ( asic_ss_assignment * ) ( ( u8 * ) ss_assign + sizeof ( ATOM_ASIC_SS_ASSIGNMENT ) ) ; } break ; case 2 : num_indices = ( size - sizeof ( ATOM_COMMON_TABLE_HEADER ) ) / sizeof ( ATOM_ASIC_SS_ASSIGNMENT_V2 ) ; ss_assign = ( asic_ss_assignment * ) ( ( u8 * ) & ss_info -> info_2 . asSpreadSpectrum [ 0 ] ) ; for ( i = 0 ; i < num_indices ; i ++ ) { if ( ( ss_assign -> v2 . ucClockIndication == id ) && ( clock <= le32_to_cpu ( ss_assign -> v2 . ulTargetClockRange ) ) ) { ss -> percentage = le16_to_cpu ( ss_assign -> v2 . usSpreadSpectrumPercentage ) ; ss -> type = ss_assign -> v2 . ucSpreadSpectrumMode ; ss -> rate = le16_to_cpu ( ss_assign -> v2 . usSpreadRateIn10Hz ) ; ss -> percentage_divider = 100 ; if ( ( crev == 2 ) && ( ( id == ASIC_INTERNAL_ENGINE_SS ) || ( id == ASIC_INTERNAL_MEMORY_SS ) ) ) { ss -> rate /= 100 ; } return true ; } ss_assign = ( asic_ss_assignment * ) ( ( u8 * ) ss_assign + sizeof ( ATOM_ASIC_SS_ASSIGNMENT_V2 ) ) ; } break ; case 3 : num_indices = ( size - sizeof ( ATOM_COMMON_TABLE_HEADER ) ) / sizeof ( ATOM_ASIC_SS_ASSIGNMENT_V3 ) ; ss_assign = ( asic_ss_assignment * ) ( ( u8 * ) & ss_info -> info_3 . asSpreadSpectrum [ 0 ] ) ; for ( i = 0 ; i < num_indices ; i ++ ) { if ( ( ss_assign -> v3 . ucClockIndication == id ) && ( clock <= le32_to_cpu ( ss_assign -> v3 . ulTargetClockRange ) ) ) { ss -> percentage = le16_to_cpu ( ss_assign -> v3 . usSpreadSpectrumPercentage ) ; ss -> type = ss_assign -> v3 . ucSpreadSpectrumMode ; ss -> rate = le16_to_cpu ( ss_assign -> v3 . usSpreadRateIn10Hz ) ; if ( ss_assign -> v3 . ucSpreadSpectrumMode & SS_MODE_V3_PERCENTAGE_DIV_BY_1000_MASK ) { ss -> percentage_divider = 1000 ; } else { ss -> percentage_divider = 100 ; } if ( ( id == ASIC_INTERNAL_ENGINE_SS ) || ( id == ASIC_INTERNAL_MEMORY_SS ) ) { ss -> rate /= 100 ; } if ( adev -> flags & AMD_IS_APU ) { amdgpu_atombios_get_igp_ss_overrides ( adev , ss , id ) ; } return true ; } ss_assign = ( asic_ss_assignment * ) ( ( u8 * ) ss_assign + sizeof ( ATOM_ASIC_SS_ASSIGNMENT_V3 ) ) ; } break ; default : DRM_ERROR ( "Unsupported ASIC_InternalSS_Info table: %d %d\n" , frev , crev ) ; break ; } } return false ; } 