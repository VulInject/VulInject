static int uhid_dev_create2 ( struct uhid_device * uhid , const struct uhid_event * ev ) { struct hid_device * hid ; size_t rd_size , len ; void * rd_data ; int ret ; if ( uhid -> hid ) { return - EALREADY ; } rd_size = ev -> u . create2 . rd_size ; rd_data = kmemdup ( ev -> u . create2 . rd_data , rd_size , GFP_KERNEL ) ; if ( ! rd_data ) { return - ENOMEM ; } uhid -> rd_size = rd_size ; uhid -> rd_data = rd_data ; hid = hid_allocate_device ( ) ; if ( IS_ERR ( hid ) ) { ret = PTR_ERR ( hid ) ; err_free } len = min ( sizeof ( hid -> name ) , sizeof ( ev -> u . create2 . name ) ) - 1 ; strncpy ( hid -> name , ev -> u . create2 . name , len ) ; len = min ( sizeof ( hid -> phys ) , sizeof ( ev -> u . create2 . phys ) ) - 1 ; strncpy ( hid -> phys , ev -> u . create2 . phys , len ) ; len = min ( sizeof ( hid -> uniq ) , sizeof ( ev -> u . create2 . uniq ) ) - 1 ; strncpy ( hid -> uniq , ev -> u . create2 . uniq , len ) ; hid -> ll_driver = & uhid_hid_driver ; hid -> bus = ev -> u . create2 . bus ; hid -> vendor = ev -> u . create2 . vendor ; hid -> product = ev -> u . create2 . product ; hid -> version = ev -> u . create2 . version ; hid -> country = ev -> u . create2 . country ; hid -> driver_data = uhid ; hid -> dev . parent = uhid_misc . this_device ; uhid -> hid = hid ; uhid -> running = true ; schedule_work ( & uhid -> worker ) ; return 0 ; err_free kfree ( uhid -> rd_data ) ; uhid -> rd_data = NULL ; uhid -> rd_size = 0 ; return ret ; } 