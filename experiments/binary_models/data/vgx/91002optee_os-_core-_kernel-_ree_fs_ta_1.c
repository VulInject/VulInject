* Authentication only * -- -- -- -- -- -- -- -- -- - * * Required security properties : * 1. Authentication and non - repudiation of a TA to Service Provider ( SP ) . * 2. Integrity of a TA . * * To satisfy ( 1 ) and ( 2 ) , SP needs to sign TA and OP - TEE core needs to verify * the signature SP public key with computed hash of the TA . * * Authentication along with Confidentiality * -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - * * Required security properties : * 1. Authentication and non - repudiation of a TA to Service Provider ( SP ) . * 2. Confidentiality of a TA . * 3. Integrity of an encrypted TA blob . * * To satisfy ( 1 ) , SP needs to sign plain TA and OP - TEE core needs to verify the * signature SP public key with computed hash of the TA . * * To satisfy ( 2 ) and ( 3 ) , SP needs to ; { authenticated encryption of TA and * OP - TEE core needs to ; } { authenticated decryption of TA to retrieve its * contents . Here encryption provides the confidentiality of TA and MAC tag * provides the integrity of encrypted TA blob . * / ree_fs_ta_handle { shdr * nw_ta size_t nw_ta_size mobj * mobj size_t offs shdr * shdr void * hash_ctx void * enc_ctx shdr_bootstrap_ta * bs_hdr shdr_encrypted_ta * ehdr } ; } { uint8_t uuid [ sizeof ( TEE_UUID ) ] ; uint32_t version ; } { uint32_t db_version ; uint32_t nb_entries ; } , , uint32_t version { struct ver_db_entry db_entry = { } ; const struct tee_file_operations * ops = NULL ; struct tee_file_handle * fh = NULL ; TEE_Result res = TEE_SUCCESS ; bool entry_found = false ; size_t len = 0 ; unsigned int i = 0 ; struct ver_db_hdr db_hdr = { } ; struct tee_pobj pobj = { . obj_id = ( void * ) db_name . obj_id_len = strlen ( db_name ) + 1 } ; ops = tee_svc_storage_file_ops ( TEE_STORAGE_PRIVATE ) ; mutex_lock ( & ver_db_mutex ) ; res = ops -> open ( & pobj , NULL , & fh ) ; if ( res != TEE_SUCCESS && res != TEE_ERROR_ITEM_NOT_FOUND ) { out } if ( res == TEE_ERROR_ITEM_NOT_FOUND ) { res = ops -> create ( & pobj , false , NULL , 0 , NULL , 0 , NULL , 0 , & fh ) ; if ( res != TEE_SUCCESS ) { out } res = ops -> write ( fh , 0 , & db_hdr , sizeof ( db_hdr ) ) ; if ( res != TEE_SUCCESS ) { out } } else { len = sizeof ( db_hdr ) ; res = ops -> read ( fh , 0 , & db_hdr , & len ) ; if ( res != TEE_SUCCESS ) { out } if ( len != sizeof ( db_hdr ) ) { res = TEE_ERROR_BAD_STATE ; out } } for ( i = 0 ; i < db_hdr . nb_entries ; i ++ ) { len = sizeof ( db_entry ) ; res = ops -> read ( fh , sizeof ( db_hdr ) + ( i * len ) , & db_entry , & len ) ; if ( res != TEE_SUCCESS ) { out } if ( len != sizeof ( db_entry ) ) { res = TEE_ERROR_BAD_STATE ; out } if ( ! memcmp ( uuid , db_entry . uuid , sizeof ( TEE_UUID ) ) ) { entry_found = true ; break ; } } if ( entry_found ) { if ( db_entry . version > version ) { res = TEE_ERROR_ACCESS_CONFLICT ; out } if ( db_entry . version < version ) { memcpy ( db_entry . uuid , uuid , sizeof ( TEE_UUID ) ) ; db_entry . version = version ; len = sizeof ( db_entry ) ; res = ops -> write ( fh , sizeof ( db_hdr ) + ( i * len ) , & db_entry , len ) ; if ( res != TEE_SUCCESS ) { out } } } else { memcpy ( db_entry . uuid , uuid , sizeof ( TEE_UUID ) ) ; db_entry . version = version ; len = sizeof ( db_entry ) ; res = ops -> write ( fh , sizeof ( db_hdr ) + ( db_hdr . nb_entries * len ) , & db_entry , len ) ; if ( res != TEE_SUCCESS ) { out } db_hdr . nb_entries ++ ; res = ops -> write ( fh , 0 , & db_hdr , sizeof ( db_hdr ) ) ; if ( res != TEE_SUCCESS ) { out } } out ops -> close ( & fh ) ; mutex_unlock ( & ver_db_mutex ) ; return res ; } ; 