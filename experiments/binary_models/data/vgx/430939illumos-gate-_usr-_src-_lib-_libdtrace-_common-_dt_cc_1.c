static void dt_stmt_append ( dtrace_stmtdesc_t * sdp , const dt_node_t * dnp ) { dtrace_ecbdesc_t * edp = sdp -> dtsd_ecbdesc ; dtrace_actdesc_t * ap , * tap ; int commit = 0 ; int speculate = 0 ; int datarec = 0 ; for ( ap = edp -> dted_action ; ap != NULL ; ap = ap -> dtad_next ) { if ( ap -> dtad_kind == DTRACEACT_COMMIT ) { if ( commit ) { dnerror ( dnp , D_COMM_COMM , "commit( ) may " "not follow commit( )\n" ) ; } if ( datarec ) { dnerror ( dnp , D_COMM_DREC , "commit( ) may " "not follow data-recording action(s)\n" ) ; } for ( tap = ap ; tap != NULL ; tap = tap -> dtad_next ) { dnerror ( dnp , D_AGG_COMM , "aggregating actions " "may not follow commit( )\n" ) ; } commit = 1 ; continue ; } if ( ap -> dtad_kind == DTRACEACT_SPECULATE ) { if ( speculate ) { dnerror ( dnp , D_SPEC_SPEC , "speculate( ) may " "not follow speculate( )\n" ) ; } if ( commit ) { dnerror ( dnp , D_SPEC_COMM , "speculate( ) may " "not follow commit( )\n" ) ; } if ( datarec ) { dnerror ( dnp , D_SPEC_DREC , "speculate( ) may " "not follow data-recording action(s)\n" ) ; } speculate = 1 ; continue ; } if ( DTRACEACT_ISAGG ( ap -> dtad_kind ) ) { if ( speculate ) { dnerror ( dnp , D_AGG_SPEC , "aggregating actions " "may not follow speculate( )\n" ) ; } datarec = 1 ; continue ; } if ( speculate ) { if ( dt_action_destructive ( ap ) ) { dnerror ( dnp , D_ACT_SPEC , "destructive actions " "may not follow speculate( )\n" ) ; } if ( ap -> dtad_kind == DTRACEACT_EXIT ) { dnerror ( dnp , D_EXIT_SPEC , "exit( ) may not " "follow speculate( )\n" ) ; } } if ( dt_action_destructive ( ap ) || ap -> dtad_kind == DTRACEACT_DISCARD ) { continue ; } if ( ap -> dtad_kind == DTRACEACT_DIFEXPR && ap -> dtad_difo -> dtdo_rtype . dtdt_kind == DIF_TYPE_CTF && ap -> dtad_difo -> dtdo_rtype . dtdt_size == 0 ) { continue ; } if ( commit ) { dnerror ( dnp , D_DREC_COMM , "data-recording actions " "may not follow commit( )\n" ) ; } if ( ! speculate ) { datarec = 1 ; } } if ( dtrace_stmt_add ( yypcb -> pcb_hdl , yypcb -> pcb_prog , sdp ) != 0 ) { longjmp ( yypcb -> pcb_jmpbuf , dtrace_errno ( yypcb -> pcb_hdl ) ) ; } if ( yypcb -> pcb_stmt == sdp ) { yypcb -> pcb_stmt = NULL ; } } 