int intel_pasid_alloc_table ( struct device * dev ) { struct device_domain_info * info ; struct pasid_table * pasid_table ; struct page * pages ; u32 max_pasid = 0 ; int order , size ; might_sleep ( ) ; info = dev_iommu_priv_get ( dev ) ; if ( WARN_ON ( ! info || ! dev_is_pci ( dev ) ) ) { return - ENODEV ; } if ( WARN_ON ( info -> pasid_table ) ) { return - EEXIST ; } pasid_table = kzalloc ( sizeof ( * pasid_table ) , GFP_KERNEL ) ; if ( info -> pasid_supported ) { max_pasid = min_t ( u32 , pci_max_pasids ( to_pci_dev ( dev ) ) , intel_pasid_max_id ) ; } size = max_pasid >> ( PASID_PDE_SHIFT - 3 ) ; order = size ?get_order ( size ) : 0 ; pages = alloc_pages_node ( info -> iommu -> node , GFP_KERNEL | __GFP_ZERO , order ) ; if ( ! pages ) { kfree ( pasid_table ) ; return - ENOMEM ; } pasid_table -> table = page_address ( pages ) ; pasid_table -> order = order ; pasid_table -> max_pasid = 1 << ( order + PAGE_SHIFT + 3 ) ; info -> pasid_table = pasid_table ; if ( ! ecap_coherent ( info -> iommu -> ecap ) ) { clflush_cache_range ( pasid_table -> table , size ) ; } return 0 ; } 