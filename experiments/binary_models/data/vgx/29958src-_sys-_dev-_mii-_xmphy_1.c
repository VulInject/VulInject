int xmphy_service ( struct mii_softc * sc , struct mii_data * mii , int cmd ) { struct ifmedia_entry * ife = mii -> mii_media . ifm_cur ; int reg ; if ( ( sc -> mii_dev . dv_flags & DVF_ACTIVE ) == 0 ) { return ( ENXIO ) ; } switch ( cmd ) { case MII_POLLSTAT : if ( IFM_INST ( ife -> ifm_media ) != sc -> mii_inst ) { return ( 0 ) ; } break ; case MII_MEDIACHG : if ( IFM_INST ( ife -> ifm_media ) != sc -> mii_inst ) { reg = PHY_READ ( sc , MII_BMCR ) ; PHY_WRITE ( sc , MII_BMCR , reg | BMCR_ISO ) ; return ( 0 ) ; } if ( ( mii -> mii_ifp -> if_flags & IFF_UP ) == 0 ) { break ; } switch ( IFM_SUBTYPE ( ife -> ifm_media ) ) { case IFM_AUTO : ( void ) xmphy_mii_phy_auto ( sc ) ; break ; case IFM_1000_SX : PHY_RESET ( sc ) ; if ( ( ife -> ifm_media & IFM_GMASK ) == IFM_FDX ) { PHY_WRITE ( sc , MII_ANAR , ANAR_10_FD ) ; PHY_WRITE ( sc , MII_BMCR , BMCR_FDX ) ; } else { PHY_WRITE ( sc , MII_ANAR , ANAR_10 ) ; PHY_WRITE ( sc , MII_BMCR , 0 ) ; } break ; default : return ( EINVAL ) ; } break ; case MII_TICK : if ( IFM_INST ( ife -> ifm_media ) != sc -> mii_inst ) { return ( 0 ) ; } if ( ( mii -> mii_ifp -> if_flags & IFF_UP ) == 0 ) { return ( 0 ) ; } if ( IFM_SUBTYPE ( ife -> ifm_media ) != IFM_AUTO ) { break ; } reg = PHY_READ ( sc , MII_BMSR ) | PHY_READ ( sc , MII_BMSR ) ; if ( reg & BMSR_LINK ) { sc -> mii_ticks = 0 ; break ; } if ( ++ sc -> mii_ticks <= sc -> mii_anegticks ) { break ; } sc -> mii_ticks = 0 ; PHY_RESET ( sc ) ; xmphy_mii_phy_auto ( sc ) ; break ; } mii_phy_status ( sc , NULL ) ; mii_phy_update ( sc , cmd ) ; return ( 0 ) ; } 