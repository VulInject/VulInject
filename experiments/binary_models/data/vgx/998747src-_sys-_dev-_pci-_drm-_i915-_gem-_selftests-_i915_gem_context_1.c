static int igt_vm_isolation ( void * arg ) { struct drm_i915_private * i915 = arg ; struct i915_gem_context * ctx_a , * ctx_b ; struct drm_i915_gem_object * obj_a , * obj_b ; unsigned long num_engines , count ; struct intel_engine_cs * engine ; struct igt_live_test t ; I915_RND_STATE ( prng ) ; struct file * file ; u64 vm_total ; u32 expected ; int err ; if ( GRAPHICS_VER ( i915 ) < 7 ) { return 0 ; } file = mock_file ( i915 ) ; if ( IS_ERR ( file ) ) { return PTR_ERR ( file ) ; } err = igt_live_test_begin ( & t , i915 , __func__ , "" ) ; if ( err ) { out_file } ctx_a = live_context ( i915 , file ) ; if ( IS_ERR ( ctx_a ) ) { err = PTR_ERR ( ctx_a ) ; out_file } ctx_b = live_context ( i915 , file ) ; if ( IS_ERR ( ctx_b ) ) { err = PTR_ERR ( ctx_b ) ; out_file } if ( ctx_a -> vm == ctx_b -> vm ) { out_file } err = check_scratch_page ( ctx_a , & expected ) ; if ( err ) { out_file } err = check_scratch_page ( ctx_b , & expected ) ; if ( err ) { out_file } vm_total = ctx_a -> vm -> total ; GEM_BUG_ON ( ctx_b -> vm -> total != vm_total ) ; obj_a = i915_gem_object_create_internal ( i915 , PAGE_SIZE ) ; if ( IS_ERR ( obj_a ) ) { err = PTR_ERR ( obj_a ) ; out_file } obj_b = i915_gem_object_create_internal ( i915 , PAGE_SIZE ) ; if ( IS_ERR ( obj_b ) ) { err = PTR_ERR ( obj_b ) ; put_a } count = 0 ; num_engines = 0 ; for_each_uabi_engine ( , ) { IGT_TIMEOUT ( end_time ) ; unsigned long this = 0 ; if ( GRAPHICS_VER ( i915 ) < 8 && engine -> class != RENDER_CLASS ) { continue ; } while ( ! __igt_timeout ( end_time , NULL ) ) { u32 value = 0xc5c5c5c5 ; u64 offset ; offset = igt_random_offset ( & prng , I915_GTT_PAGE_SIZE , vm_total , sizeof ( u32 ) , alignof_dword ) ; err = write_to_scratch ( ctx_a , engine , obj_a , offset , 0xdeadbeef ) ; if ( err == 0 ) { err = read_from_scratch ( ctx_b , engine , obj_b , offset , & value ) ; } if ( err ) { put_b } if ( value != expected ) { pr_err ( "%s: Read %08x from scratch (offset 0x%08x_%08x), after %lu reads!\n" , engine -> name , value , upper_32_bits ( offset ) , lower_32_bits ( offset ) , this ) ; err = - EINVAL ; put_b } this ++ ; } count += this ; num_engines ++ ; } pr_info ( "Checked %lu scratch offsets across %lu engines\n" , count , num_engines ) ; put_b i915_gem_object_put ( obj_b ) ; put_a i915_gem_object_put ( obj_a ) ; out_file if ( igt_live_test_end ( & t ) ) { err = - EIO ; } fput ( file ) ; return err ; } 