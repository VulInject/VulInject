int stmfGetLogicalUnitList ( stmfGuidList * * luList ) { int ret ; int fd ; int ioctlRet ; int cmd = STMF_IOCTL_LU_LIST ; int i ; stmf_iocdata_t stmfIoctl ; slist_lu_t * fLuList ; uint32_t fLuListSize ; uint32_t listCnt ; if ( luList == NULL ) { return ( STMF_ERROR_INVALID_ARG ) ; } ret = initializeConfig ( ) ; if ( ret != STMF_STATUS_SUCCESS ) { return ( ret ) ; } if ( ( ret = openStmf ( OPEN_STMF , & fd ) ) != STMF_STATUS_SUCCESS ) { return ( ret ) ; } fLuListSize = ALLOC_LU ; fLuListSize = fLuListSize * ( sizeof ( slist_lu_t ) ) ; fLuList = ( slist_lu_t * ) calloc ( 1 , fLuListSize ) ; if ( fLuList == NULL ) { ret = STMF_ERROR_NOMEM ; done } bzero ( & stmfIoctl , sizeof ( stmfIoctl ) ) ; stmfIoctl . stmf_version = STMF_VERSION_1 ; stmfIoctl . stmf_obuf_size = fLuListSize ; stmfIoctl . stmf_obuf = ( uint64_t ) ( unsigned long ) fLuList ; ioctlRet = ioctl ( fd , cmd , & stmfIoctl ) ; if ( ioctlRet != 0 ) { switch ( errno ) { case EBUSY : ret = STMF_ERROR_BUSY ; break ; case EPERM : case EACCES : ret = STMF_ERROR_PERM ; break ; default : syslog ( LOG_DEBUG , "stmfGetLogicalUnitList:ioctl errno(%d)" , errno ) ; ret = STMF_STATUS_ERROR ; break ; } done } if ( stmfIoctl . stmf_obuf_max_nentries > ALLOC_LU ) { fLuListSize = stmfIoctl . stmf_obuf_max_nentries * sizeof ( slist_lu_t ) ; fLuList = ( slist_lu_t * ) calloc ( 1 , fLuListSize ) ; if ( fLuList == NULL ) { ret = STMF_ERROR_NOMEM ; done } stmfIoctl . stmf_obuf_size = fLuListSize ; stmfIoctl . stmf_obuf = ( uint64_t ) ( unsigned long ) fLuList ; ioctlRet = ioctl ( fd , cmd , & stmfIoctl ) ; if ( ioctlRet != 0 ) { switch ( errno ) { case EBUSY : ret = STMF_ERROR_BUSY ; break ; case EPERM : case EACCES : ret = STMF_ERROR_PERM ; break ; default : syslog ( LOG_DEBUG , "stmfGetLogicalUnitList:" "ioctl errno(%d)" , errno ) ; ret = STMF_STATUS_ERROR ; break ; } done } } if ( ret != STMF_STATUS_SUCCESS ) { done } listCnt = stmfIoctl . stmf_obuf_nentries ; * luList = ( stmfGuidList * ) calloc ( 1 , sizeof ( stmfGuidList ) + listCnt * sizeof ( stmfGuid ) ) ; if ( * luList == NULL ) { ret = STMF_ERROR_NOMEM ; done } ( * luList ) -> cnt = listCnt ; for ( i = 0 ; i < listCnt ; i ++ ) { bcopy ( & fLuList [ i ] . lu_guid , ( * luList ) -> guid [ i ] . guid , sizeof ( stmfGuid ) ) ; } qsort ( ( void * ) & ( ( * luList ) -> guid [ 0 ] ) , ( * luList ) -> cnt , sizeof ( stmfGuid ) , guidCompare ) ; done ( void ) close ( fd ) ; free ( fLuList ) ; return ( ret ) ; } 