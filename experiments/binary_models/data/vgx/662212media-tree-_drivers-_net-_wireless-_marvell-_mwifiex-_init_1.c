void mwifiex_shutdown_drv ( struct mwifiex_adapter * adapter ) { struct mwifiex_private * priv ; s32 i ; unsigned long flags ; struct sk_buff * skb ; if ( adapter -> hw_status == MWIFIEX_HW_STATUS_NOT_READY ) { return ; } if ( adapter -> curr_cmd ) { mwifiex_dbg ( adapter , WARN , "curr_cmd is still in processing\n" ) ; del_timer_sync ( & adapter -> cmd_timer ) ; mwifiex_recycle_cmd_node ( adapter , adapter -> curr_cmd ) ; adapter -> curr_cmd = NULL ; } mwifiex_dbg ( adapter , MSG , "info: shutdown mwifiex...\n" ) ; for ( i = 0 ; i < adapter -> priv_num ; i ++ ) { if ( adapter -> priv [ i ] ) { priv = adapter -> priv [ i ] ; mwifiex_clean_auto_tdls ( priv ) ; mwifiex_abort_cac ( priv ) ; mwifiex_clean_txrx ( priv ) ; mwifiex_delete_bss_prio_tbl ( priv ) ; } } atomic_set ( & adapter -> tx_queued , 0 ) ; while ( ( skb = skb_dequeue ( & adapter -> tx_data_q ) ) ) { mwifiex_write_data_complete ( adapter , skb , 0 , 0 ) ; } spin_lock_irqsave ( & adapter -> rx_proc_lock , flags ) ; while ( ( skb = skb_dequeue ( & adapter -> rx_data_q ) ) ) { struct mwifiex_rxinfo * rx_info = MWIFIEX_SKB_RXCB ( skb ) ; atomic_dec ( & adapter -> rx_pending ) ; priv = adapter -> priv [ rx_info -> bss_num ] ; if ( priv ) { priv -> stats . rx_dropped ++ ; } } spin_unlock_irqrestore ( & adapter -> rx_proc_lock , flags ) ; spin_lock ( & adapter -> mwifiex_lock ) ; mwifiex_adapter_cleanup ( adapter ) ; spin_unlock ( & adapter -> mwifiex_lock ) ; adapter -> hw_status = MWIFIEX_HW_STATUS_NOT_READY ; } 