static void synproxy_send_client_synack ( struct net * net , const struct sk_buff * skb , const struct tcphdr * th , const struct synproxy_options * opts ) { struct sk_buff * nskb ; struct ipv6hdr * iph , * niph ; struct tcphdr * nth ; unsigned int tcp_hdr_size ; u16 mss = opts -> mss ; iph = ipv6_hdr ( skb ) ; tcp_hdr_size = sizeof ( * nth ) + synproxy_options_size ( opts ) ; nskb = alloc_skb ( sizeof ( * niph ) + tcp_hdr_size + MAX_TCP_HEADER , GFP_ATOMIC ) ; if ( nskb == NULL ) { return ; } skb_reserve ( nskb , MAX_TCP_HEADER ) ; niph = synproxy_build_ip ( net , nskb , & iph -> daddr , & iph -> saddr ) ; skb_reset_transport_header ( nskb ) ; nth = ( tcphdr * ) skb_put ( nskb , tcp_hdr_size ) ; nth -> source = th -> dest ; nth -> dest = th -> source ; nth -> seq = htonl ( __cookie_v6_init_sequence ( iph , th , & mss ) ) ; nth -> ack_seq = htonl ( ntohl ( th -> seq ) + 1 ) ; tcp_flag_word ( nth ) = TCP_FLAG_SYN | TCP_FLAG_ACK ; if ( opts -> options & XT_SYNPROXY_OPT_ECN ) { tcp_flag_word ( nth ) |= TCP_FLAG_ECE ; } nth -> doff = tcp_hdr_size / 4 ; nth -> window = 0 ; nth -> urg_ptr = 0 ; synproxy_build_options ( nth , opts ) ; synproxy_send_tcp ( net , skb , nskb , skb_nfct ( skb ) , IP_CT_ESTABLISHED_REPLY , niph , nth , tcp_hdr_size ) ; } 