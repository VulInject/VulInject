struct agp_amd_gatt * agp_amd_alloc_gatt ( bus_dma_tag_t dmat , bus_size_t apsize ) { bus_size_t entries = apsize >> AGP_PAGE_SHIFT ; struct agp_amd_gatt * gatt ; int i , npages ; caddr_t vdir ; gatt = malloc ( sizeof ( agp_amd_gatt ) , M_AGP , M_NOWAIT ) ; gatt -> ag_size = AGP_PAGE_SIZE + entries * sizeof ( u_int32_t ) ; if ( agp_alloc_dmamem ( dmat , gatt -> ag_size , & gatt -> ag_dmamap , & gatt -> ag_pdir , & gatt -> ag_dmaseg ) != 0 ) { printf ( "failed to allocate GATT\n" ) ; free ( gatt , M_AGP , sizeof gatt ) ; return ( NULL ) ; } if ( bus_dmamem_map ( dmat , & gatt -> ag_dmaseg , 1 , gatt -> ag_size , & vdir , BUS_DMA_NOWAIT ) != 0 ) { printf ( "failed to map GATT\n" ) ; agp_free_dmamem ( dmat , gatt -> ag_size , gatt -> ag_dmamap , & gatt -> ag_dmaseg ) ; free ( gatt , M_AGP , sizeof gatt ) ; return ( NULL ) ; } gatt -> ag_vdir = ( u_int32_t * ) vdir ; gatt -> ag_entries = entries ; gatt -> ag_virtual = ( u_int32_t * ) ( vdir + AGP_PAGE_SIZE ) ; gatt -> ag_physical = gatt -> ag_pdir + AGP_PAGE_SIZE ; npages = ( ( gatt -> ag_size - 1 ) >> AGP_PAGE_SHIFT ) ; for ( i = 0 ; i < npages ; i ++ ) { gatt -> ag_vdir [ i ] = ( gatt -> ag_physical + i * AGP_PAGE_SIZE ) | 1 ; } agp_flush_cache ( ) ; return ( gatt ) ; } 