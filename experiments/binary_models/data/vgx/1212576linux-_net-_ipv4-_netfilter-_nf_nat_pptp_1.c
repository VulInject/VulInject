static int pptp_inbound_pkt ( struct sk_buff * skb , struct nf_conn * ct , enum ip_conntrack_info ctinfo , unsigned int protoff , struct PptpControlHeader * ctlh , union pptp_ctrl_union * pptpReq ) { const struct nf_nat_pptp * nat_pptp_info ; struct nf_conn_nat * nat = nfct_nat ( ct ) ; u_int16_t msg ; __be16 new_pcid ; int pcid_off ; if ( WARN_ON_ONCE ( ! nat ) ) { return NF_DROP ; } nat_pptp_info = & nat -> help . nat_pptp_info ; new_pcid = nat_pptp_info -> pns_call_id ; switch ( msg = ntohs ( ctlh -> messageType ) ) { case PPTP_OUT_CALL_REPLY : pcid_off = offsetof ( pptp_ctrl_union , ocack . peersCallID ) ; break ; case PPTP_IN_CALL_CONNECT : pcid_off = offsetof ( pptp_ctrl_union , iccon . peersCallID ) ; break ; case PPTP_IN_CALL_REQUEST : return NF_ACCEPT ; case PPTP_WAN_ERROR_NOTIFY : pcid_off = offsetof ( pptp_ctrl_union , wanerr . peersCallID ) ; break ; case PPTP_CALL_DISCONNECT_NOTIFY : pcid_off = offsetof ( pptp_ctrl_union , disc . callID ) ; break ; case PPTP_SET_LINK_INFO : pcid_off = offsetof ( pptp_ctrl_union , setlink . peersCallID ) ; break ; default : pr_debug ( "unknown inbound packet %s\n" , pptp_msg_name ( msg ) ) ; fallthrough ; case PPTP_START_SESSION_REQUEST : case PPTP_START_SESSION_REPLY : case PPTP_STOP_SESSION_REQUEST : case PPTP_STOP_SESSION_REPLY : case PPTP_ECHO_REQUEST : case PPTP_ECHO_REPLY : return NF_ACCEPT ; } pr_debug ( "altering peer call id from 0x%04x to 0x%04x\n" , ntohs ( REQ_CID ( pptpReq , pcid_off ) ) , ntohs ( new_pcid ) ) ; if ( ! nf_nat_mangle_tcp_packet ( skb , ct , ctinfo , protoff , pcid_off + sizeof ( pptp_pkt_hdr ) + sizeof ( PptpControlHeader ) , sizeof ( new_pcid ) , ( char * ) & new_pcid , sizeof ( new_pcid ) ) ) { return NF_DROP ; } return NF_ACCEPT ; } 