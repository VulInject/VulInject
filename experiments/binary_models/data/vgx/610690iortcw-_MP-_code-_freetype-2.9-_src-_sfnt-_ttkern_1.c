FT_LOCAL_DEF ( ) tt_face_load_kern ( , ) { FT_Error error ; FT_ULong table_size ; FT_Byte * p ; FT_Byte * p_limit ; FT_UInt nn , num_tables ; FT_UInt32 avail = 0 , ordered = 0 ; error = face -> goto_table ( face , TTAG_kern , stream , & table_size ) ; if ( error ) { Exit } if ( table_size < 4 ) { FT_ERROR ( ( "tt_face_load_kern:" " kerning table is too small - ignored\n" ) ) ; error = FT_THROW ( Table_Missing ) ; Exit } if ( FT_FRAME_EXTRACT ( table_size , face -> kern_table ) ) { FT_ERROR ( ( "tt_face_load_kern:" " could not extract kerning table\n" ) ) ; Exit } face -> kern_table_size = table_size ; p = face -> kern_table ; p_limit = p + table_size ; p += 2 ; num_tables = FT_NEXT_USHORT ( p ) ; if ( num_tables > 32 ) { num_tables = 32 ; } for ( nn = 0 ; nn < num_tables ; nn ++ ) { FT_UInt num_pairs , length , coverage , format ; FT_Byte * p_next ; FT_UInt32 mask = ( FT_UInt32 ) 1UL << nn ; if ( p + 6 > p_limit ) { break ; } p_next = p ; p += 2 ; length = FT_NEXT_USHORT ( p ) ; coverage = FT_NEXT_USHORT ( p ) ; if ( length <= 6 + 8 ) { break ; } p_next += length ; if ( p_next > p_limit ) { p_next = p_limit ; } format = coverage >> 8 ; if ( format != 0 ) { NextTable } if ( ( coverage & 3U ) != 0x0001 || p + 8 > p_next ) { NextTable } num_pairs = FT_NEXT_USHORT ( p ) ; p += 6 ; if ( ( p_next - p ) < 6 * ( int ) num_pairs ) { num_pairs = ( FT_UInt ) ( ( p_next - p ) / 6 ) ; } avail |= mask ; if ( num_pairs > 0 ) { FT_ULong count ; FT_ULong old_pair ; old_pair = FT_NEXT_ULONG ( p , NULL ) ; p += 2 ; for ( count = num_pairs - 1 ; count > 0 ; count -- ) { FT_UInt32 cur_pair ; } } } } 