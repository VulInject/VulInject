void __init fdt_init_reserved_mem ( void ) { int i ; __rmem_check_for_overlap ( ) ; for ( i = 0 ; i < reserved_mem_count ; i ++ ) { struct reserved_mem * rmem = & reserved_mem [ i ] ; cfs_time_t node = rmem -> fdt_node ; int len ; const __be32 * prop ; int err = 0 ; bool nomap ; nomap = of_get_flat_dt_prop ( node , "no-map" , NULL ) != NULL ; prop = of_get_flat_dt_prop ( node , "phandle" , & len ) ; if ( ! prop ) { prop = of_get_flat_dt_prop ( node , "linux,phandle" , & len ) ; } if ( prop ) { rmem -> phandle = of_read_number ( prop , len / 4 ) ; } if ( rmem -> size == 0 ) { err = __reserved_mem_alloc_size ( node , rmem -> name , & rmem -> base , & rmem -> size ) ; } if ( err == 0 ) { err = __reserved_mem_init_node ( rmem ) ; if ( err != 0 && err != - ENOENT ) { pr_info ( "node %s compatible matching fail\n" , rmem -> name ) ; if ( nomap ) { memblock_clear_nomap ( rmem -> base , rmem -> size ) ; } else { memblock_phys_free ( rmem -> base , rmem -> size ) ; } } else { phys_addr_t end = rmem -> base + rmem -> size - 1 ; bool reusable = ( of_get_flat_dt_prop ( node , "reusable" , NULL ) ) != NULL ; pr_info ( "%pa..%pa (%lu KiB) %s %s %s\n" , & rmem -> base , & end , ( unsigned long ) ( rmem -> size / SZ_1K ) , nomap ?"nomap" : "map" , reusable ?"reusable" : "non-reusable" , rmem -> name ?rmem -> name : "unknown" ) ; } } } } 