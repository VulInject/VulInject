static int ip6_forward_proxy_check ( struct sk_buff * skb ) { struct ipv6hdr * hdr = ipv6_hdr ( skb ) ; u8 nexthdr = hdr -> nexthdr ; __be16 frag_off ; int offset ; if ( ipv6_ext_hdr ( nexthdr ) ) { offset = ipv6_skip_exthdr ( skb , sizeof ( * hdr ) , & nexthdr , & frag_off ) ; if ( offset < 0 ) { return 0 ; } } else { offset = sizeof ( ipv6hdr ) ; } if ( nexthdr == IPPROTO_ICMPV6 ) { struct icmp6hdr * icmp6 ; if ( ! pskb_may_pull ( skb , ( skb_network_header ( skb ) + offset + 1 - skb -> data ) ) ) { return 0 ; } icmp6 = ( icmp6hdr * ) ( skb_network_header ( skb ) + offset ) ; switch ( icmp6 -> icmp6_type ) { case NDISC_ROUTER_SOLICITATION : case NDISC_ROUTER_ADVERTISEMENT : case NDISC_NEIGHBOUR_SOLICITATION : case NDISC_NEIGHBOUR_ADVERTISEMENT : case NDISC_REDIRECT : return 1 ; default : break ; } } if ( ipv6_addr_type ( & hdr -> daddr ) & IPV6_ADDR_LINKLOCAL ) { dst_link_failure ( skb , NULL ) ; return - 1 ; } return 0 ; } 