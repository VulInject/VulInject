static int isp_video_get_selection ( struct file * file , void * fh , struct v4l2_selection * sel ) { struct isp_video * video = video_drvdata ( file ) ; struct v4l2_subdev_format format ; struct v4l2_subdev * subdev ; struct v4l2_subdev_selection sdsel = { . which = V4L2_SUBDEV_FORMAT_ACTIVE . target = sel -> target } ; u32 pad ; int ret ; switch ( sel -> target ) { case V4L2_SEL_TGT_CROP : case V4L2_SEL_TGT_CROP_BOUNDS : case V4L2_SEL_TGT_CROP_DEFAULT : break ; case V4L2_SEL_TGT_COMPOSE : case V4L2_SEL_TGT_COMPOSE_BOUNDS : case V4L2_SEL_TGT_COMPOSE_DEFAULT : if ( video -> type == V4L2_BUF_TYPE_VIDEO_CAPTURE ) { return - EINVAL ; } break ; default : return - EINVAL ; } subdev = isp_video_remote_subdev ( video , & pad ) ; if ( subdev == NULL ) { return - EINVAL ; } sdsel . pad = pad ; ret = v4l2_subdev_call ( subdev , pad , get_selection , NULL , & sdsel ) ; if ( ! ret ) { sel -> r = sdsel . r ; } if ( ret != - ENOIOCTLCMD ) { return ret ; } format . pad = pad ; format . which = V4L2_SUBDEV_FORMAT_ACTIVE ; ret = v4l2_subdev_call ( subdev , pad , get_fmt , NULL , & format ) ; if ( ret < 0 ) { return ret == - ENOIOCTLCMD ?- ENOTTY : ret ; } sel -> r . left = 0 ; sel -> r . top = 0 ; sel -> r . width = format . format . width ; sel -> r . height = format . format . height ; return 0 ; } 