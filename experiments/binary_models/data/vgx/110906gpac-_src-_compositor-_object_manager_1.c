void gf_odm_service_media_event_with_download ( GF_ObjectManager * odm , GF_EventType event_type , u64 loaded_size , u64 total_size , u32 bytes_per_sec , u32 buffer_level_plus_one , u32 min_buffer_time ) { u32 i , count , min_buffer , min_time ; GF_DOM_Event evt ; GF_Scene * scene ; if ( ! odm || ! odm -> scene_ns ) { return ; } if ( odm -> mo ) { count = gf_mo_event_target_count ( odm -> mo ) ; if ( odm -> parentscene && odm -> parentscene -> is_dynamic_scene && odm -> parentscene -> root_od -> mo && ( odm -> parentscene -> root_od -> scene_ns == odm -> scene_ns ) ) { odm = odm -> parentscene -> root_od ; count = gf_mo_event_target_count ( odm -> mo ) ; } if ( ! count ) { return ; } } else { count = 0 ; } evt . media_event . bufferValid = GF_FALSE ; evt . media_event . session_name = odm -> scene_ns -> url ; scene = odm -> subscene ?odm -> subscene : odm -> parentscene ; if ( ! scene ) { return ; } if ( ! buffer_level_plus_one ) { GF_ObjectManager * an_od ; min_time = min_buffer = ( u32 ) - 1 ; if ( ! scene -> is_dynamic_scene ) { gf_odm_collect_buffer_info ( odm -> scene_ns , scene -> root_od , & evt . media_event , & min_time , & min_buffer ) ; } i = 0 ; while ( ( an_od = ( GF_ObjectManager * ) gf_list_enum ( scene -> resources , & i ) ) ) { if ( odm -> scene_ns == an_od -> scene_ns ) { gf_odm_collect_buffer_info ( odm -> scene_ns , an_od , & evt . media_event , & min_time , & min_buffer ) ; } } } else { min_buffer = buffer_level_plus_one - 1 ; min_time = min_buffer_time ; evt . media_event . bufferValid = GF_TRUE ; } if ( min_buffer != ( u32 ) - 1 ) { evt . media_event . level = min_buffer ; } if ( min_time != ( u32 ) - 1 ) { evt . media_event . remaining_time = INT2FIX ( min_time ) / 60 ; } evt . media_event . status = 0 ; evt . media_event . loaded_size = loaded_size ; evt . media_event . total_size = total_size ; evt . type = event_type ; evt . bubbles = 0 ; for ( i = 0 ; i < count ; i ++ ) { GF_DOMEventTarget * target = ( GF_DOMEventTarget * ) gf_list_get ( odm -> mo -> evt_targets , i ) ; if ( target ) { gf_sc_queue_dom_event_on_target ( scene -> compositor , & evt , target , scene -> graph ) ; } } if ( ! count ) { GF_Node * root = gf_sg_get_root_node ( scene -> graph ) ; if ( root ) { gf_sc_queue_dom_event ( scene -> compositor , root , & evt ) ; } } } 