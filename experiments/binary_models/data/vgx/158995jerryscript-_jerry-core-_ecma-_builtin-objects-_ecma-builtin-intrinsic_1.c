ecma_builtin_intrinsic_dispatch_routine ( , , , ) { JERRY_UNUSED ( arguments_number , NULL ) ; switch ( builtin_routine_id ) { case ECMA_INTRINSIC_ARRAY_PROTOTYPE_VALUES : { return ecma_builtin_intrinsic_array_prototype_values ( this_arg ) ; } case ECMA_INTRINSIC_TYPEDARRAY_PROTOTYPE_VALUES : { if ( ! ecma_is_typedarray ( this_arg ) ) { return ecma_raise_type_error ( ECMA_ERR_MSG ( "Argument 'this' is not a TypedArray" ) ) ; } if ( ecma_arraybuffer_is_detached ( ecma_typedarray_get_arraybuffer ( ecma_get_object_from_value ( this_arg ) ) ) ) { return ecma_raise_type_error ( ECMA_ERR_MSG ( ecma_error_arraybuffer_is_detached ) ) ; } return ecma_typedarray_iterators_helper ( this_arg , ECMA_ITERATOR_VALUES ) ; } case ECMA_INTRINSIC_SET_PROTOTYPE_VALUES : { return ecma_builtin_intrinsic_set_prototype_values ( this_arg ) ; } case ECMA_INTRINSIC_MAP_PROTOTYPE_ENTRIES : { return ecma_builtin_intrinsic_map_prototype_entries ( this_arg ) ; } case ECMA_INTRINSIC_ARRAY_TO_STRING : { ecma_value_t this_obj = ecma_op_to_object ( this_arg ) ; if ( ECMA_IS_VALUE_ERROR ( this_obj ) ) { return this_obj ; } ecma_value_t result = ecma_array_object_to_string ( this_obj ) ; ecma_deref_object ( ecma_get_object_from_value ( this_obj ) ) ; return result ; } case ECMA_INTRINSIC_DATE_TO_UTC_STRING : { if ( ! ecma_is_value_object ( this_arg ) || ! ecma_object_class_is ( ecma_get_object_from_value ( this_arg ) , ECMA_OBJECT_CLASS_DATE ) ) { return ecma_raise_type_error ( ECMA_ERR_MSG ( "Argument 'this' is not a Date object" ) ) ; } ecma_number_t * date_value_p = & ( ( ecma_date_object_t * ) ecma_get_object_from_value ( this_arg ) ) -> date_value ; ecma_extended_object_t * arg_ext_object_p = ( ecma_extended_object_t * ) ecma_get_object_from_value ( argument ) ; ecma_number_t * date_value_p = ECMA_GET_INTERNAL_VALUE_POINTER ( ecma_number_t , arg_ext_object_p -> u . class_prop . u . date ) ; if ( ecma_number_is_nan ( * date_value_p ) ) { return ecma_make_magic_string_value ( LIT_MAGIC_STRING_INVALID_DATE_UL ) ; } return ecma_date_value_to_utc_string ( * date_value_p ) ; } case ECMA_INTRINSIC_STRING_TRIM_START : case ECMA_INTRINSIC_STRING_TRIM_END : { if ( ! ecma_op_require_object_coercible ( this_arg ) ) { return ECMA_VALUE_ERROR ; } ecma_string_t * to_str_p = ecma_op_to_string ( this_arg ) ; if ( to_str_p == NULL ) { return ECMA_VALUE_ERROR ; } ECMA_STRING_TO_UTF8_STRING ( to_str_p , start_p , input_start_size ) ; lit_utf8_size_t size ; const lit_utf8_byte_t * input_start_p = start_p ; const lit_utf8_byte_t * input_str_end_p = start_p + input_start_size ; ecma_string_t * ret_str_p ; if ( builtin_routine_id == ECMA_INTRINSIC_STRING_TRIM_START ) { const lit_utf8_byte_t * new_start_p = ecma_string_trim_front ( input_start_p , input_str_end_p ) ; size = ( lit_utf8_size_t ) ( input_str_end_p - new_start_p ) ; ret_str_p = ecma_new_ecma_string_from_utf8 ( new_start_p , size ) ; } else { const lit_utf8_byte_t * new_end_p = ecma_string_trim_back ( input_start_p , input_str_end_p ) ; size = ( lit_utf8_size_t ) ( new_end_p - input_start_p ) ; ret_str_p = ecma_new_ecma_string_from_utf8 ( input_start_p , size ) ; } ECMA_FINALIZE_UTF8_STRING ( start_p , input_start_size ) ; ecma_value_t result = ecma_make_string_value ( ret_str_p ) ; ecma_deref_ecma_string ( to_str_p ) ; return result ; } default : { JERRY_ASSERT ( builtin_routine_id == ECMA_INTRINSIC_PARSE_INT || builtin_routine_id == ECMA_INTRINSIC_PARSE_FLOAT ) ; ecma_string_t * str_p = ecma_op_to_string ( arguments_list_p [ 0 ] ) ; if ( JERRY_UNLIKELY ( str_p == NULL ) ) { return ECMA_VALUE_ERROR ; } ecma_value_t result ; ECMA_STRING_TO_UTF8_STRING ( str_p , string_buff , string_buff_size ) ; if ( builtin_routine_id == ECMA_INTRINSIC_PARSE_INT ) { result = ecma_number_parse_int ( string_buff , string_buff_size , arguments_list_p [ 1 ] ) ; } else { JERRY_ASSERT ( builtin_routine_id == ECMA_INTRINSIC_PARSE_FLOAT ) ; result = ecma_number_parse_float ( string_buff , string_buff_size ) ; } ECMA_FINALIZE_UTF8_STRING ( string_buff , string_buff_size ) ; ecma_deref_ecma_string ( str_p ) ; return result ; } } } 