u_int _bpf_filter ( const struct bpf_insn * pc , const struct bpf_ops * ops , const void * pkt , u_int wirelen ) { u_int32_t A = 0 , X = 0 ; u_int32_t k ; int32_t mem [ BPF_MEMWORDS ] ; int err ; if ( pc == NULL ) { return ( u_int ) - 1 ; } -- pc ; while ( 1 ) { ++ pc ; switch ( pc -> code ) { default : return 0 ; abort ( ) ; case BPF_RET | BPF_K : return ( u_int ) pc -> k ; case BPF_RET | BPF_A : return ( u_int ) A ; case BPF_LD | BPF_W | BPF_ABS : A = ops -> ldw ( pkt , pc -> k , & err ) ; if ( err != 0 ) { return 0 ; } continue ; case BPF_LD | BPF_H | BPF_ABS : A = ops -> ldh ( pkt , pc -> k , & err ) ; if ( err != 0 ) { return 0 ; } continue ; case BPF_LD | BPF_B | BPF_ABS : A = ops -> ldb ( pkt , pc -> k , & err ) ; if ( err != 0 ) { return 0 ; } continue ; case BPF_LD | BPF_W | BPF_LEN : A = wirelen ; continue ; case BPF_LDX | BPF_W | BPF_LEN : X = wirelen ; continue ; case BPF_LD | BPF_W | BPF_RND : A = arc4random ( ) ; continue ; case BPF_LD | BPF_W | BPF_IND : k = X + pc -> k ; A = ops -> ldw ( pkt , k , & err ) ; if ( err != 0 ) { return 0 ; } continue ; case BPF_LD | BPF_H | BPF_IND : k = X + pc -> k ; A = ops -> ldh ( pkt , k , & err ) ; if ( err != 0 ) { return 0 ; } continue ; case BPF_LD | BPF_B | BPF_IND : k = X + pc -> k ; A = ops -> ldb ( pkt , k , & err ) ; if ( err != 0 ) { return 0 ; } continue ; case BPF_LDX | BPF_MSH | BPF_B : X = ops -> ldb ( pkt , pc -> k , & err ) ; if ( err != 0 ) { return 0 ; } X &= 0xf ; X <<= 2 ; continue ; case BPF_LD | BPF_IMM : A = pc -> k ; continue ; case BPF_LDX | BPF_IMM : X = pc -> k ; continue ; case BPF_LD | BPF_MEM : A = mem [ pc -> k ] ; continue ; case BPF_LDX | BPF_MEM : X = mem [ pc -> k ] ; continue ; case BPF_ST : mem [ pc -> k ] = A ; continue ; case BPF_STX : mem [ pc -> k ] = X ; continue ; case BPF_JMP | BPF_JA : pc += pc -> k ; continue ; case BPF_JMP | BPF_JGT | BPF_K : pc += ( A > pc -> k ) ?pc -> jt : pc -> jf ; continue ; case BPF_JMP | BPF_JGE | BPF_K : pc += ( A >= pc -> k ) ?pc -> jt : pc -> jf ; continue ; case BPF_JMP | BPF_JEQ | BPF_K : pc += ( A == pc -> k ) ?pc -> jt : pc -> jf ; continue ; case BPF_JMP | BPF_JSET | BPF_K : pc += ( A & pc -> k ) ?pc -> jt : pc -> jf ; continue ; case BPF_JMP | BPF_JGT | BPF_X : pc += ( A > X ) ?pc -> jt : pc -> jf ; continue ; case BPF_JMP | BPF_JGE | BPF_X : pc += ( A >= X ) ?pc -> jt : pc -> jf ; continue ; case BPF_JMP | BPF_JEQ | BPF_X : pc += ( A == X ) ?pc -> jt : pc -> jf ; continue ; case BPF_JMP | BPF_JSET | BPF_X : pc += ( A & X ) ?pc -> jt : pc -> jf ; continue ; case BPF_ALU | BPF_ADD | BPF_X : A += X ; continue ; case BPF_ALU | BPF_SUB | BPF_X : A -= X ; continue ; case BPF_ALU | BPF_MUL | BPF_X : A *= X ; continue ; case BPF_ALU | BPF_DIV | BPF_X : if ( X == 0 ) { return 0 ; } A /= X ; continue ; case BPF_ALU | BPF_AND | BPF_X : A &= X ; continue ; case BPF_ALU | BPF_OR | BPF_X : A |= X ; continue ; case BPF_ALU | BPF_LSH | BPF_X : A <<= X ; continue ; case BPF_ALU | BPF_RSH | BPF_X : A >>= X ; continue ; case BPF_ALU | BPF_ADD | BPF_K : A += pc -> k ; continue ; case BPF_ALU | BPF_SUB | BPF_K : A -= pc -> k ; continue ; case BPF_ALU | BPF_MUL | BPF_K : A *= pc -> k ; continue ; case BPF_ALU | BPF_DIV | BPF_K : A /= pc -> k ; continue ; case BPF_ALU | BPF_AND | BPF_K : A &= pc -> k ; continue ; case BPF_ALU | BPF_OR | BPF_K : A |= pc -> k ; continue ; case BPF_ALU | BPF_LSH | BPF_K : A <<= pc -> k ; continue ; case BPF_ALU | BPF_RSH | BPF_K : A >>= pc -> k ; continue ; case BPF_ALU | BPF_NEG : A = - A ; continue ; case BPF_MISC | BPF_TAX : X = A ; continue ; case BPF_MISC | BPF_TXA : A = X ; continue ; } } } 