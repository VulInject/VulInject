int vio_destroy_mblks ( vio_mblk_pool_t * vmplp ) { uint64_t i ; uint64_t num_mblks ; vio_mblk_t * vmp ; int pool_cleanup_retries = 0 ; { if ( vmplp -> head == vmplp -> tail ) { break ; } drv_usecwait ( vio_pool_cleanup_delay ) ; } ++ pool_cleanup_retries < vio_pool_cleanup_retries ; if ( vmplp -> head != vmplp -> tail ) { return ( EBUSY ) ; } num_mblks = vmplp -> quelen ; vmplp -> flag |= VMPL_FLAG_DESTROYING ; for ( i = 0 ; i < num_mblks ; i ++ ) { vmp = & ( vmplp -> basep [ i ] ) ; if ( vmp -> mp != NULL ) { freeb ( vmp -> mp ) ; } } vmplp -> flag &= ~ ( VMPL_FLAG_DESTROYING ) ; kmem_free ( vmplp -> basep , num_mblks * sizeof ( vio_mblk_t ) ) ; if ( ( vmplp -> flag & VMPL_FLAG_CLIENT_DATA ) == 0 ) { kmem_free ( vmplp -> datap , num_mblks * vmplp -> mblk_size ) ; } kmem_free ( vmplp -> quep , num_mblks * sizeof ( vio_mblk_t * ) ) ; mutex_destroy ( & vmplp -> hlock ) ; mutex_destroy ( & vmplp -> tlock ) ; kmem_free ( vmplp , sizeof ( * vmplp ) ) ; return ( 0 ) ; } 