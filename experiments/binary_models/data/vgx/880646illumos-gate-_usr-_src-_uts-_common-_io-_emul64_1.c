int emul64_error_inject_req ( struct emul64 * emul64 , intptr_t arg ) { emul64_tgt_t * tgt ; struct emul64_error_inj_data error_inj_req ; if ( ddi_copyin ( ( void * ) arg , & error_inj_req , sizeof ( error_inj_req ) , 0 ) != 0 ) { cmn_err ( CE_WARN , "emul64: ioctl - inj copyin failed\n" ) ; return ( EFAULT ) ; } EMUL64_MUTEX_ENTER ( emul64 ) ; tgt = find_tgt ( emul64 , error_inj_req . eccd_target , error_inj_req . eccd_lun ) ; EMUL64_MUTEX_EXIT ( emul64 ) ; if ( tgt == NULL ) { return ( ENODEV ) ; } if ( tgt -> emul64_einj_sense_data != NULL ) { ASSERT ( tgt -> emul64_einj_sense_length != 0 ) ; kmem_free ( tgt -> emul64_einj_sense_data , tgt -> emul64_einj_sense_length ) ; tgt -> emul64_einj_sense_data = NULL ; tgt -> emul64_einj_sense_length = 0 ; } tgt -> emul64_einj_state = error_inj_req . eccd_inj_state ; tgt -> emul64_einj_sense_length = error_inj_req . eccd_sns_dlen ; tgt -> emul64_einj_pkt_state = error_inj_req . eccd_pkt_state ; tgt -> emul64_einj_pkt_reason = error_inj_req . eccd_pkt_reason ; tgt -> emul64_einj_scsi_status = error_inj_req . eccd_scsi_status ; switch ( error_inj_req . eccd_inj_state ) { case ERR_INJ_ENABLE : case ERR_INJ_ENABLE_NODATA : if ( error_inj_req . eccd_sns_dlen ) { tgt -> emul64_einj_sense_data = kmem_alloc ( error_inj_req . eccd_sns_dlen , KM_SLEEP ) ; if ( ddi_copyin ( ( void * ) ( arg + sizeof ( error_inj_req ) ) , tgt -> emul64_einj_sense_data , error_inj_req . eccd_sns_dlen , 0 ) != 0 ) { cmn_err ( CE_WARN , "emul64: sense data copy in failed\n" ) ; return ( EFAULT ) ; } } break ; case ERR_INJ_DISABLE : default : break ; } return ( 0 ) ; } 