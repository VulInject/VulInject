int strgrpmatch ( const char * b , const char * p , ssize_t * sub , int n , register int flags ) { register regex_t * re ; register ssize_t * end ; register int i ; register regflags_t reflags ; if ( ! p || ! b ) { if ( ! p && ! b ) { regcache ( NiL , 0 , NiL ) ; } return 0 ; } if ( ! * p ) { if ( sub && n > 0 ) { if ( flags & STR_INT ) { int * subi = ( int * ) sub ; subi [ 0 ] = subi [ 1 ] = 0 ; } else { sub [ 0 ] = sub [ 1 ] = 0 ; } } return * b == 0 ; } if ( flags & REG_ADVANCE ) { reflags = flags & ~ REG_ADVANCE ; } else { reflags = REG_SHELL | REG_AUGMENTED ; if ( ! ( flags & STR_MAXIMAL ) ) { reflags |= REG_MINIMAL ; } if ( flags & STR_GROUP ) { reflags |= REG_SHELL_GROUP ; } if ( flags & STR_LEFT ) { reflags |= REG_LEFT ; } if ( flags & STR_RIGHT ) { reflags |= REG_RIGHT ; } if ( flags & STR_ICASE ) { reflags |= REG_ICASE ; } } if ( ! sub || n <= 0 ) { reflags |= REG_NOSUB ; } if ( ! ( re = regcache ( p , reflags , NiL ) ) ) { return 0 ; } if ( n > matchstate . nmatch ) { if ( ! ( matchstate . match = newof ( matchstate . match , regmatch_t , n , 0 ) ) ) { return 0 ; } matchstate . nmatch = n ; } if ( regexec ( re , b , n , matchstate . match , reflags & ~ ( REG_MINIMAL | REG_SHELL_GROUP | REG_LEFT | REG_RIGHT | REG_ICASE ) ) ) { return 0 ; } i = re -> re_nsub ; if ( flags & STR_INT ) { int * subi = ( int * ) sub ; int * endi = subi + n * 2 ; for ( n = 0 ; subi < endi && n <= i ; n ++ ) { * subi ++ = matchstate . match [ n ] . rm_so ; * subi ++ = matchstate . match [ n ] . rm_eo ; } } else { end = sub + n * 2 ; for ( n = 0 ; sub < end && n <= i ; n ++ ) { * sub ++ = matchstate . match [ n ] . rm_so ; * sub ++ = matchstate . match [ n ] . rm_eo ; } } return i + 1 ; } 