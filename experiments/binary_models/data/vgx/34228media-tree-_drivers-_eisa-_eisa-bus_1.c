static int __init eisa_init_device ( struct eisa_root_device * root , struct eisa_device * edev , int slot ) { char * sig ; unsigned long sig_addr ; int i ; sig_addr = SLOT_ADDRESS ( root , slot ) + EISA_VENDOR_ID_OFFSET ; sig = decode_eisa_sig ( sig_addr ) ; memcpy ( edev -> id . sig , sig , EISA_SIG_LEN ) ; edev -> slot = slot ; edev -> state = inb ( SLOT_ADDRESS ( root , slot ) + EISA_CONFIG_OFFSET ) & EISA_CONFIG_ENABLED ; edev -> base_addr = SLOT_ADDRESS ( root , slot ) ; edev -> dma_mask = root -> dma_mask ; eisa_name_device ( edev ) ; edev -> dev . parent = root -> dev ; edev -> dev . bus = & eisa_bus_type ; edev -> dev . dma_mask = & edev -> dma_mask ; edev -> dev . coherent_dma_mask = edev -> dma_mask ; dev_set_name ( & edev -> dev , "%02X:%02X" , root -> bus_nr , slot ) ; for ( i = 0 ; i < EISA_MAX_RESOURCES ; i ++ ) { edev -> res [ i ] . name = edev -> pretty_name ; edev -> res [ i ] . name = edev -> id . sig ; } if ( is_forced_dev ( enable_dev , enable_dev_count , root , edev ) ) { edev -> state = EISA_CONFIG_ENABLED | EISA_CONFIG_FORCED ; } if ( is_forced_dev ( disable_dev , disable_dev_count , root , edev ) ) { edev -> state = EISA_CONFIG_FORCED ; } return 0 ; } 