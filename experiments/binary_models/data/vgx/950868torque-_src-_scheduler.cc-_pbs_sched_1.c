static int read_config ( char * file ) { static const char * id = "read_config" ; FILE * conf ; int i ; char line [ CONF_LINE_LEN ] ; char * token ; specialconfig { const char * name ; int * handler ( const char * name ) } , special [ ] { { "clienthost" addclient } { "restricted" restricted } { NULL NULL } } ; if ( chk_file_sec ( file , 0 , 0 , S_IWGRP | S_IWOTH , 1 , NULL ) ) { return ( - 1 ) ; } mask_num = 0 ; if ( ( conf = fopen ( file , "r" ) ) == NULL ) { log_err ( errno , id , ( char * ) "cannot open config file" ) ; return ( - 1 ) ; } while ( fgets ( line , CONF_LINE_LEN , conf ) ) { if ( ( line [ 0 ] == '#' ) || ( line [ 0 ] == '\n' ) ) { continue ; } if ( line [ 0 ] == '$' ) { if ( ( token = strtok ( line , " \t" ) ) == NULL ) { token = ( char * ) "" ; } for ( i = 0 ; special [ i ] . name ; i ++ ) { if ( strcmp ( token + 1 , special [ i ] . name ) == 0 ) { break ; } } if ( special [ i ] . name == NULL ) { sprintf ( log_buffer , "config name %s not known" , token ) ; log_record ( PBSEVENT_ERROR , PBS_EVENTCLASS_SERVER , msg_daemonname , log_buffer ) ; continue ; } token = strtok ( NULL , " \t" ) ; if ( * ( token + strlen ( token ) - 1 ) == '\n' ) { * ( token + strlen ( token ) - 1 ) = '\0' ; } if ( special [ i ] . handler ( token ) ) { fclose ( conf ) ; return ( - 1 ) ; } } else { log_record ( PBSEVENT_ERROR , PBS_EVENTCLASS_SERVER , msg_daemonname , "invalid line in config file" ) ; fclose ( conf ) ; return ( - 1 ) ; } } fclose ( conf ) ; return ( 0 ) ; } void restart ( int sig ) { const char * id = "restart" ; if ( sig ) { pthread_mutex_lock ( & log_mutex ) ; log_close ( 1 ) ; log_open ( logfile , path_log ) ; pthread_mutex_unlock ( & log_mutex ) ; sprintf ( log_buffer , "restart on signal %d" , sig ) ; } else { sprintf ( log_buffer , "restart command" ) ; } log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; if ( configfile ) { if ( read_config ( configfile ) != 0 ) { die ( 0 ) ; } } } void badconn ( const char * msg ) { static char id [ ] "badconn" ; ; struct in_addr addr ; char buf [ 5 * sizeof ( addr ) + 100 ] ; struct hostent * phe ; addr = saddr . sin_addr ; phe = gethostbyaddr ( ( void * ) & addr , sizeof ( addr ) , AF_INET ) ; if ( phe == NULL ) { char hold [ 6 ] ; int i ; { struct in_addr aa ; u_char bb [ sizeof ( addr ) ] ; } , uu uu . aa = addr ; sprintf ( buf , "%u" , uu . bb [ 0 ] ) ; for ( i = 1 ; i < ( int ) sizeof ( addr ) ; i ++ ) { sprintf ( hold , ".%u" , uu . bb [ i ] ) ; strcat ( buf , hold ) ; } } else { strncpy ( buf , phe -> h_name , sizeof ( buf ) ) ; buf [ sizeof ( buf ) - 1 ] = '\0' ; } sprintf ( log_buffer , "%s on port %u %s" , buf , ntohs ( saddr . sin_port ) , msg ) ; log_err ( - 1 , id , log_buffer ) ; return ; } int server_command ( int sock ) { const char * id = "server_command" ; int new_socket ; torque_socklen_t slen ; int i ; unsigned int cmd ; pbs_net_t addr ; slen = sizeof ( saddr ) ; new_socket = accept ( sock , ( sockaddr * ) & saddr , & slen ) ; if ( new_socket == - 1 ) { log_err ( errno , id , ( char * ) "accept" ) ; return ( SCH_ERROR ) ; } addr = ( pbs_net_t ) saddr . sin_addr . s_addr ; if ( ntohs ( saddr . sin_port ) >= IPPORT_RESERVED ) { for ( i = 0 ; i < mask_num ; i ++ ) { if ( addr == maskclient [ i ] ) { break ; } } if ( i == mask_num ) { badconn ( "non-reserved port" ) ; close ( new_socket ) ; return ( SCH_ERROR ) ; } } else { for ( i = 0 ; i < numclients ; i ++ ) { if ( addr == okclients [ i ] ) { break ; } } if ( i == numclients ) { badconn ( "unauthorized host" ) ; close ( new_socket ) ; return ( SCH_ERROR ) ; } } if ( get_4byte ( new_socket , & cmd ) != 1 ) { close ( new_socket ) ; log_err ( errno , id , ( char * ) "get4bytes" ) ; return ( SCH_ERROR ) ; } close ( new_socket ) ; return ( ( int ) cmd ) ; } static void lock_out ( int fds , int op ) { struct flock flock ; flock . l_type = op ; flock . l_whence = SEEK_SET ; flock . l_start = 0 ; flock . l_len = 0 ; if ( fcntl ( fds , F_SETLK , & flock ) < 0 ) { ( void ) strcpy ( log_buffer , "pbs_sched: another scheduler running\n" ) ; log_err ( errno , msg_daemonname , log_buffer ) ; fprintf ( stderr , "%s" , log_buffer ) ; exit ( 1 ) ; } } int main ( int argc , char * argv [ ] ) { const char * id = "main" ; struct hostent * hp ; int go , c , errflg = 0 ; int lockfds ; int t = 1 ; pid_t pid ; char host [ 100 ] ; const char * homedir = PBS_SERVER_HOME ; unsigned int port ; const char * dbfile = "sched_out" ; int server_sock ; struct sigaction act ; sigset_t oldsigs ; caddr_t curr_brk = 0 ; caddr_t next_brk ; extern char * optarg ; extern int opterr ; fd_set fdset ; int schedinit ( int argc , char * * argv ) ; int schedule ( int command ) ; glob_argv = argv ; alarm_time = 180 ; log_init ( NULL , NULL ) ; c = sysconf ( _SC_OPEN_MAX ) ; while ( -- c > 2 ) { ( void ) close ( c ) ; } port = get_svrport ( ( char * ) PBS_SCHEDULER_SERVICE_NAME , ( char * ) "tcp" , PBS_SCHEDULER_SERVICE_PORT ) ; pbs_rm_port = get_svrport ( ( char * ) PBS_MANAGER_SERVICE_NAME , ( char * ) "tcp" , PBS_MANAGER_SERVICE_PORT ) ; strcpy ( pbs_current_user , "Scheduler" ) ; msg_daemonname = strdup ( "pbs_sched" ) ; opterr = 0 ; while ( ( c = getopt ( argc , argv , "L:S:R:d:p:c:a:-:" ) ) != EOF ) { switch ( c ) { case '-' : if ( ( optarg == NULL ) || ( optarg [ 0 ] == '\0' ) ) { errflg = 1 ; } if ( ! strcmp ( optarg , "version" ) ) { fprintf ( stderr , "version: %s\n" , PACKAGE_VERSION ) ; exit ( 0 ) ; } else { errflg = 1 ; } break ; case 'L' : logfile = optarg ; break ; case 'S' : port = atoi ( optarg ) ; if ( port == 0 ) { fprintf ( stderr , "%s: illegal port\n" , optarg ) ; errflg = 1 ; } break ; case 'R' : if ( ( pbs_rm_port = atoi ( optarg ) ) == 0 ) { ( void ) fprintf ( stderr , "%s: bad -R %s\n" , argv [ 0 ] , optarg ) ; return 1 ; } break ; case 'd' : homedir = optarg ; break ; case 'p' : dbfile = optarg ; break ; case 'c' : configfile = optarg ; break ; case 'a' : alarm_time = atoi ( optarg ) ; if ( alarm_time == 0 ) { fprintf ( stderr , "%s: bad alarm time\n" , optarg ) ; errflg = 1 ; } break ; case '?' : errflg = 1 ; break ; } } if ( errflg ) { fprintf ( stderr , "usage: %s %s\n" , argv [ 0 ] , usage ) ; exit ( 1 ) ; } if ( IamRoot ( ) == 0 ) { return ( 1 ) ; } if ( ( oldpath = getcwd ( ( char * ) NULL , MAXPATHLEN ) ) == NULL ) { fprintf ( stderr , "cannot get current working directory\n" ) ; exit ( 1 ) ; } ( void ) sprintf ( log_buffer , "%s/sched_priv" , homedir ) ; c = chk_file_sec ( log_buffer , 1 , 0 , S_IWGRP | S_IWOTH , 1 , NULL ) ; c |= chk_file_sec ( PBS_ENVIRON , 0 , 0 , S_IWGRP | S_IWOTH , 0 , NULL ) ; if ( c != 0 ) { exit ( 1 ) ; } if ( chdir ( log_buffer ) == - 1 ) { perror ( "chdir" ) ; exit ( 1 ) ; } ( void ) sprintf ( path_log , "%s/sched_logs" , homedir ) ; ( void ) sprintf ( path_acct , "%s/%s" , log_buffer , PBS_ACCT ) ; umask ( 022 ) ; if ( setup_env ( PBS_ENVIRON ) == - 1 ) { exit ( 1 ) ; } c = getgid ( ) ; ( void ) setgroups ( 1 , ( gid_t * ) & c ) ; ( void ) limit ( C_JOB , 0 , L_CPROC , 0 ) ; ( void ) limit ( C_JOB , 0 , L_CPU , 0 ) ; ( void ) limit ( C_JOBPROCS , 0 , L_CPU , 0 ) ; ( void ) limit ( C_PROC , 0 , L_FD , 255 ) ; ( void ) limit ( C_JOB , 0 , L_FSBLK , 0 ) ; ( void ) limit ( C_JOBPROCS , 0 , L_FSBLK , 0 ) ; ( void ) limit ( C_JOB , 0 , L_MEM , 0 ) ; ( void ) limit ( C_JOBPROCS , 0 , L_MEM , 0 ) ; { struct rlimit rlimit ; rlimit . rlim_cur = RLIM_INFINITY ; rlimit . rlim_max = RLIM_INFINITY ; ( void ) setrlimit ( RLIMIT_CPU , & rlimit ) ; ( void ) setrlimit ( RLIMIT_FSIZE , & rlimit ) ; ( void ) setrlimit ( RLIMIT_DATA , & rlimit ) ; ( void ) setrlimit ( RLIMIT_STACK , & rlimit ) ; ( void ) setrlimit ( RLIMIT_RSS , & rlimit ) ; ( void ) setrlimit ( RLIMIT_VMEM , & rlimit ) ; } pthread_mutex_lock ( & log_mutex ) ; if ( log_open ( logfile , path_log ) == - 1 ) { pthread_mutex_unlock ( & log_mutex ) ; fprintf ( stderr , "%s: logfile could not be opened\n" , argv [ 0 ] ) ; exit ( 1 ) ; } pthread_mutex_unlock ( & log_mutex ) ; if ( gethostname ( host , sizeof ( host ) ) == - 1 ) { log_err ( errno , id , ( char * ) "gethostname" ) ; die ( 0 ) ; } if ( ( hp = gethostbyname ( host ) ) == NULL ) { log_err ( errno , id , ( char * ) "gethostbyname" ) ; die ( 0 ) ; } if ( ( server_sock = socket ( AF_INET , SOCK_STREAM , 0 ) ) < 0 ) { log_err ( errno , id , ( char * ) "socket" ) ; die ( 0 ) ; } if ( setsockopt ( server_sock , SOL_SOCKET , SO_REUSEADDR , ( char * ) & t , sizeof ( t ) ) == - 1 ) { log_err ( errno , id , ( char * ) "setsockopt" ) ; die ( 0 ) ; } saddr . sin_family = AF_INET ; saddr . sin_port = htons ( port ) ; memcpy ( & saddr . sin_addr , hp -> h_addr , hp -> h_length ) ; if ( bind ( server_sock , ( sockaddr * ) & saddr , sizeof ( saddr ) ) < 0 ) { log_err ( errno , id , ( char * ) "bind" ) ; die ( 0 ) ; } if ( listen ( server_sock , 5 ) < 0 ) { log_err ( errno , id , ( char * ) "listen" ) ; die ( 0 ) ; } okclients = ( pbs_net_t * ) calloc ( START_CLIENTS , sizeof ( pbs_net_t ) ) ; addclient ( "localhost" ) ; addclient ( host ) ; if ( configfile ) { if ( read_config ( configfile ) != 0 ) { } } } 