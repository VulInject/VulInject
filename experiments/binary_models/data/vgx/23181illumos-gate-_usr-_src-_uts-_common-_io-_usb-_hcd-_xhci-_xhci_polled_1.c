static int xhci_polled_event_process ( xhci_polled_t * xhci_polledp , uint_t * num_characters ) { xhci_t * xhcip = xhci_polledp -> xhci_polled_xhci ; xhci_ring_t * xrp = & xhcip -> xhci_event . xev_ring ; uint_t nevents ; int ret ; uint64_t addr ; VERIFY ( xhcip -> xhci_event . xev_segs != NULL ) ; XHCI_DMA_SYNC ( xrp -> xr_dma , DDI_DMA_SYNC_FORKERNEL ) ; ret = USB_SUCCESS ; for ( nevents = 0 ; nevents < xrp -> xr_ntrb ; nevents ++ ) { xhci_trb_t * trb ; xhci_endpoint_t * xep ; uint32_t type ; if ( ( trb = xhci_ring_event_advance ( xrp ) ) == NULL ) { break ; } xep = xhci_polled_get_endpoint ( xhcip , trb ) ; if ( xep == NULL ) { xhci_polled_set_persistent_error ( xhci_polledp , USB_HC_HARDWARE_ERROR ) ; return ( USB_HC_HARDWARE_ERROR ) ; } type = LE_32 ( trb -> trb_flags ) & XHCI_TRB_TYPE_MASK ; if ( xep != xhci_polledp -> xhci_polled_endpoint || type != XHCI_EVT_XFER ) { boolean_t processed ; mutex_exit ( & xhcip -> xhci_lock ) ; processed = xhci_event_process_trb ( xhcip , trb ) ; mutex_enter ( & xhcip -> xhci_lock ) ; if ( ! processed && xhcip -> xhci_state & XHCI_S_ERROR ) { return ( USB_HC_HARDWARE_ERROR ) ; } continue ; } ret = xhci_polled_endpoint_transfer ( xhci_polledp , xep , trb , num_characters ) ; if ( ret != USB_SUCCESS ) { xhci_polled_set_persistent_error ( xhci_polledp , ret ) ; break ; } } addr = xhci_dma_pa ( & xrp -> xr_dma ) + sizeof ( xhci_trb_t ) * xrp -> xr_tail ; addr |= XHCI_ERDP_BUSY ; xhci_put64 ( xhcip , XHCI_R_RUN , XHCI_ERDP ( 0 ) , addr ) ; return ( ret ) ; } 