static int read_f ( BlockBackend * blk , int argc , char * * argv ) { struct timespec t1 , t2 ; bool Cflag = false , qflag = false , vflag = false ; bool Pflag = false , sflag = false , lflag = false , bflag = false ; int c , cnt , ret ; char * buf ; int64_t offset ; int64_t count ; int64_t total = 0 ; int pattern = 0 ; int64_t pattern_offset = 0 , pattern_count = 0 ; while ( ( c = getopt ( argc , argv , "bCl:pP:qs:v" ) ) != - 1 ) { switch ( c ) { case 'b' : bflag = true ; break ; case 'C' : Cflag = true ; break ; case 'l' : lflag = true ; pattern_count = cvtnum ( optarg ) ; if ( pattern_count < 0 ) { print_cvtnum_err ( pattern_count , optarg ) ; return pattern_count ; } break ; case 'p' : break ; case 'P' : Pflag = true ; pattern = parse_pattern ( optarg , NULL ) ; if ( pattern < 0 ) { return - EINVAL ; } break ; case 'q' : qflag = true ; break ; case 's' : sflag = true ; pattern_offset = cvtnum ( optarg ) ; if ( pattern_offset < 0 ) { print_cvtnum_err ( pattern_offset , optarg ) ; return pattern_offset ; } break ; case 'v' : vflag = true ; break ; default : qemuio_command_usage ( & read_cmd ) ; return - EINVAL ; } } if ( optind != argc - 2 ) { qemuio_command_usage ( & read_cmd ) ; return - EINVAL ; } offset = cvtnum ( argv [ optind ] ) ; if ( offset < 0 ) { print_cvtnum_err ( offset , argv [ optind ] ) ; return offset ; } optind ++ ; count = cvtnum ( argv [ optind ] ) ; if ( count < 0 ) { print_cvtnum_err ( count , argv [ optind ] ) ; return count ; } if ( count > BDRV_REQUEST_MAX_BYTES ) { printf ( "length cannot exceed %" PRIu64 ", given %s\n" , ( uint64_t ) BDRV_REQUEST_MAX_BYTES , argv [ optind ] ) ; return - EINVAL ; } if ( ! Pflag && ( lflag || sflag ) ) { qemuio_command_usage ( & read_cmd ) ; return - EINVAL ; } if ( ! lflag ) { pattern_count = count - pattern_offset ; } if ( ( pattern_count < 0 ) || ( pattern_count + pattern_offset > count ) ) { printf ( "pattern verification range exceeds end of read data\n" ) ; return - EINVAL ; } if ( bflag ) { if ( ! QEMU_IS_ALIGNED ( offset , BDRV_SECTOR_SIZE ) ) { printf ( "%" PRId64 " is not a sector-aligned value for 'offset'\n" , offset ) ; return - EINVAL ; } if ( ! QEMU_IS_ALIGNED ( count , BDRV_SECTOR_SIZE ) ) { printf ( "%" PRId64 " is not a sector-aligned value for 'count'\n" , count ) ; return - EINVAL ; } } buf = qemu_io_alloc ( blk , count , 0xab ) ; clock_gettime ( CLOCK_MONOTONIC , & t1 ) ; if ( bflag ) { ret = do_load_vmstate ( blk , buf , offset , count , & total ) ; } else { ret = do_pread ( blk , buf , offset , count , & total ) ; } clock_gettime ( CLOCK_MONOTONIC , & t2 ) ; if ( ret < 0 ) { printf ( "read failed: %s\n" , strerror ( - ret ) ) ; out } cnt = ret ; ret = 0 ; if ( Pflag ) { void * cmp_buf = g_malloc ( pattern_count ) ; memset ( cmp_buf , pattern , pattern_count ) ; if ( memcmp ( buf + pattern_offset , cmp_buf , pattern_count ) ) { printf ( "Pattern verification failed at offset %" PRId64 ", %" PRId64 " bytes\n" , offset + pattern_offset , pattern_count ) ; ret = - EINVAL ; } g_free ( cmp_buf ) ; } if ( qflag ) { out } if ( vflag ) { dump_buffer ( buf , offset , count ) ; } t2 = tsub ( t2 , t1 ) ; print_report ( "read" , & t2 , offset , count , total , cnt , Cflag ) ; out qemu_io_free ( buf ) ; return ret ; } 