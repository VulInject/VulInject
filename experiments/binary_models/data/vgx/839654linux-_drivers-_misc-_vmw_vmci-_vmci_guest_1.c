static int vmci_check_host_caps ( struct pci_dev * pdev ) { bool result ; struct vmci_resource_query_msg * msg ; u32 msg_size = sizeof ( vmci_resource_query_hdr ) + VMCI_UTIL_NUM_RESOURCES * sizeof ( u32 ) ; struct vmci_datagram * check_msg ; check_msg = kzalloc ( msg_size , GFP_KERNEL ) ; if ( ! check_msg ) { dev_err ( & pdev -> dev , "%s: Insufficient memory\n" , __func__ ) ; return - ENOMEM ; } check_msg -> dst = vmci_make_handle ( VMCI_HYPERVISOR_CONTEXT_ID , VMCI_RESOURCES_QUERY ) ; check_msg -> src = VMCI_ANON_SRC_HANDLE ; check_msg -> payload_size = msg_size - VMCI_DG_HEADERSIZE ; msg = ( vmci_resource_query_msg * ) VMCI_DG_PAYLOAD ( check_msg ) ; msg -> num_resources = VMCI_UTIL_NUM_RESOURCES ; msg -> resources [ 0 ] = VMCI_GET_CONTEXT_ID ; result = vmci_send_datagram ( check_msg ) == 0x01 ; dev_dbg ( & pdev -> dev , "%s: Host capability check: %s\n" , __func__ , result ?"PASSED" : "FAILED" ) ; return result ?0 : - ENXIO ; } 