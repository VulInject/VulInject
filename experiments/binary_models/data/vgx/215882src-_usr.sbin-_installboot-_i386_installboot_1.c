static int getbootparams ( char * boot , int devfd , struct disklabel * dl ) { int fd ; struct stat dsb , fsb ; struct statfs fssb ; struct partition * pp ; struct fs * fs ; char * sblock , * buf ; u_int blk , * ap ; int ndb ; int mib [ 3 ] ; size_t size ; dev_t dev ; int incr ; sync ( ) ; sleep ( 1 ) ; if ( ( fd = open ( boot , O_RDONLY ) ) == - 1 ) { err ( 1 , "open: %s" , boot ) ; } if ( fstatfs ( fd , & fssb ) == - 1 ) { err ( 1 , "statfs: %s" , boot ) ; } if ( strncmp ( fssb . f_fstypename , "ffs" , MFSNAMELEN ) && strncmp ( fssb . f_fstypename , "ufs" , MFSNAMELEN ) ) { errx ( 1 , "%s: not on an FFS filesystem" , boot ) ; } if ( read ( fd , & eh , sizeof ( eh ) ) != sizeof ( eh ) ) { errx ( 1 , "read: %s" , boot ) ; } if ( ! IS_ELF ( eh ) ) { errx ( 1 , "%s: bad magic: 0x%02x%02x%02x%02x" , boot , eh . e_ident [ EI_MAG0 ] , eh . e_ident [ EI_MAG1 ] , eh . e_ident [ EI_MAG2 ] , eh . e_ident [ EI_MAG3 ] ) ; } if ( fsync ( fd ) != 0 ) { err ( 1 , "fsync: %s" , boot ) ; } if ( fstat ( fd , & fsb ) != 0 ) { err ( 1 , "fstat: %s" , boot ) ; } if ( fstat ( devfd , & dsb ) != 0 ) { err ( 1 , "fstat: %d" , devfd ) ; } mib [ 0 ] = CTL_MACHDEP ; mib [ 1 ] = CPU_CHR2BLK ; mib [ 2 ] = dsb . st_rdev ; size = sizeof ( dev ) ; if ( sysctl ( mib , 3 , & dev , & size , NULL , 0 ) >= 0 ) { if ( fsb . st_dev / MAXPARTITIONS != dev / MAXPARTITIONS ) { errx ( 1 , "cross-device install" ) ; } } pp = & dl -> d_partitions [ DISKPART ( fsb . st_dev ) ] ; close ( fd ) ; if ( ( sblock = malloc ( SBSIZE ) ) == NULL ) { err ( 1 , NULL ) ; } sbread ( devfd , DL_SECTOBLK ( dl , pp -> p_offset ) , & fs , sblock ) ; if ( ( buf = malloc ( fs -> fs_bsize ) ) == NULL ) { err ( 1 , NULL ) ; } blk = fsbtodb ( fs , ino_to_fsba ( fs , fsb . st_ino ) ) ; devread ( devfd , buf , DL_SECTOBLK ( dl , pp -> p_offset ) + blk , fs -> fs_bsize , "inode" ) ; if ( fs -> fs_magic == FS_UFS2_MAGIC ) { struct ufs2_dinode * ip2 = ( ufs2_dinode * ) ( buf ) + ino_to_fsbo ( fs , fsb . st_ino ) ; ndb = howmany ( ip2 -> di_size , fs -> fs_bsize ) ; ap = ( u_int * ) ip2 -> di_db ; incr = sizeof ( u_int32_t ) ; } else { struct ufs1_dinode * ip1 = ( ufs1_dinode * ) ( buf ) + ino_to_fsbo ( fs , fsb . st_ino ) ; ndb = howmany ( ip1 -> di_size , fs -> fs_bsize ) ; ap = ( u_int * ) ip1 -> di_db ; incr = 0 ; } if ( ndb <= 0 ) { errx ( 1 , "No blocks to load" ) ; } sym_set_value ( pbr_symbols , "_fs_bsize_p" , ( fs -> fs_bsize / 16 ) ) ; sym_set_value ( pbr_symbols , "_fs_bsize_s" , ( fs -> fs_bsize / dl -> d_secsize ) ) ; sym_set_value ( pbr_symbols , "_fsbtodb" , ffs ( fs -> fs_fsize / dl -> d_secsize ) - 1 ) ; sym_set_value ( pbr_symbols , "_p_offset" , pp -> p_offset ) ; sym_set_value ( pbr_symbols , "_inodeblk" , ino_to_fsba ( fs , fsb . st_ino ) ) ; sym_set_value ( pbr_symbols , "_inodedbl" , ( ( ( ( char * ) ap ) - buf ) + INODEOFF ) ) ; sym_set_value ( pbr_symbols , "_nblocks" , ndb ) ; sym_set_value ( pbr_symbols , "_blkincr" , incr ) ; if ( verbose ) { fprintf ( stderr , "%s is %d blocks x %d bytes\n" , boot , ndb , fs -> fs_bsize ) ; fprintf ( stderr , "fs block shift %u; part offset %u; " "inode block %lld, offset %u\n" , ffs ( fs -> fs_fsize / dl -> d_secsize ) - 1 , pp -> p_offset , ino_to_fsba ( fs , fsb . st_ino ) , ( unsigned int ) ( ( ( ( char * ) ap ) - buf ) + INODEOFF ) ) ; fprintf ( stderr , "expecting %d-bit fs blocks (incr %d)\n" , incr ?64 : 32 , incr ) ; } free ( sblock ) ; return 0 ; } 