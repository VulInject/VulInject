struct inode * nfs_fhget ( struct super_block * sb , struct nfs_fh * fh , struct nfs_fattr * fattr , struct nfs4_label * label ) { struct nfs_find_desc desc = { . fh = fh . fattr = fattr } ; struct inode * inode = ERR_PTR ( - ENOENT ) ; unsigned long hash ; nfs_attr_check_mountpoint ( sb , fattr ) ; if ( nfs_attr_use_mounted_on_fileid ( fattr ) ) { fattr -> fileid = fattr -> mounted_on_fileid ; } if ( ( fattr -> valid & NFS_ATTR_FATTR_FILEID ) == 0 ) { out_no_inode } if ( ( fattr -> valid & NFS_ATTR_FATTR_TYPE ) == 0 ) { out_no_inode } hash = nfs_fattr_to_ino_t ( fattr ) ; inode = iget5_locked ( sb , hash , nfs_find_actor , nfs_init_locked , & desc ) ; if ( inode == NULL ) { inode = ERR_PTR ( - ENOMEM ) ; out_no_inode } if ( inode -> i_state & I_NEW ) { struct nfs_inode * nfsi = NFS_I ( inode ) ; unsigned long now = jiffies ; inode -> i_ino = hash ; inode -> i_flags |= S_NOATIME | S_NOCMTIME ; inode -> i_mode = fattr -> mode ; if ( ( fattr -> valid & NFS_ATTR_FATTR_MODE ) == 0 && nfs_server_capable ( inode , NFS_CAP_MODE ) ) { nfs_set_cache_invalid ( inode , NFS_INO_INVALID_ATTR ) ; } inode -> i_op = NFS_SB ( sb ) -> nfs_client -> rpc_ops -> file_inode_ops ; if ( S_ISREG ( inode -> i_mode ) ) { inode -> i_fop = NFS_SB ( sb ) -> nfs_client -> rpc_ops -> file_ops ; inode -> i_data . a_ops = & nfs_file_aops ; } if ( S_ISDIR ( inode -> i_mode ) ) { inode -> i_op = NFS_SB ( sb ) -> nfs_client -> rpc_ops -> dir_inode_ops ; inode -> i_fop = & nfs_dir_operations ; inode -> i_data . a_ops = & nfs_dir_aops ; if ( fattr -> valid & NFS_ATTR_FATTR_MOUNTPOINT || fattr -> valid & NFS_ATTR_FATTR_V4_REFERRAL ) { if ( fattr -> valid & NFS_ATTR_FATTR_V4_REFERRAL ) { inode -> i_op = & nfs_referral_inode_operations ; } else { inode -> i_op = & nfs_mountpoint_inode_operations ; } inode -> i_fop = NULL ; inode -> i_flags |= S_AUTOMOUNT ; } } if ( S_ISLNK ( inode -> i_mode ) ) { inode -> i_op = & nfs_symlink_inode_operations ; inode_nohighmem ( inode ) ; } else { init_special_inode ( inode , inode -> i_mode , fattr -> rdev ) ; } memset ( & inode -> i_mtime , 0 , sizeof ( inode -> i_mtime ) ) ; memset ( & inode -> i_ctime , 0 , sizeof ( inode -> i_ctime ) ) ; inode -> i_version = 0 ; inode -> i_size = 0 ; clear_nlink ( inode ) ; inode -> i_uid = make_kuid ( & init_user_ns , - 2 ) ; inode -> i_gid = make_kgid ( & init_user_ns , - 2 ) ; inode -> i_blocks = 0 ; memset ( nfsi -> cookieverf , 0 , sizeof ( nfsi -> cookieverf ) ) ; nfsi -> write_io = 0 ; nfsi -> read_io = 0 ; nfsi -> read_cache_jiffies = fattr -> time_start ; nfsi -> attr_gencount = fattr -> gencount ; if ( fattr -> valid & NFS_ATTR_FATTR_ATIME ) { inode -> i_atime = fattr -> atime ; } if ( nfs_server_capable ( inode , NFS_CAP_ATIME ) ) { nfs_set_cache_invalid ( inode , NFS_INO_INVALID_ATTR ) ; } if ( fattr -> valid & NFS_ATTR_FATTR_MTIME ) { inode -> i_mtime = fattr -> mtime ; } if ( nfs_server_capable ( inode , NFS_CAP_MTIME ) ) { nfs_set_cache_invalid ( inode , NFS_INO_INVALID_ATTR ) ; } if ( fattr -> valid & NFS_ATTR_FATTR_CTIME ) { inode -> i_ctime = fattr -> ctime ; } if ( nfs_server_capable ( inode , NFS_CAP_CTIME ) ) { nfs_set_cache_invalid ( inode , NFS_INO_INVALID_ATTR ) ; } if ( fattr -> valid & NFS_ATTR_FATTR_CHANGE ) { inode -> i_version = fattr -> change_attr ; } else { nfs_set_cache_invalid ( inode , NFS_INO_INVALID_ATTR | NFS_INO_REVAL_PAGECACHE ) ; } if ( fattr -> valid & NFS_ATTR_FATTR_SIZE ) { inode -> i_size = nfs_size_to_loff_t ( fattr -> size ) ; } else { nfs_set_cache_invalid ( inode , NFS_INO_INVALID_ATTR | NFS_INO_REVAL_PAGECACHE ) ; } if ( fattr -> valid & NFS_ATTR_FATTR_NLINK ) { set_nlink ( inode , fattr -> nlink ) ; } if ( nfs_server_capable ( inode , NFS_CAP_NLINK ) ) { nfs_set_cache_invalid ( inode , NFS_INO_INVALID_ATTR ) ; } if ( fattr -> valid & NFS_ATTR_FATTR_OWNER ) { inode -> i_uid = fattr -> uid ; } if ( nfs_server_capable ( inode , NFS_CAP_OWNER ) ) { nfs_set_cache_invalid ( inode , NFS_INO_INVALID_ATTR ) ; } if ( fattr -> valid & NFS_ATTR_FATTR_GROUP ) { inode -> i_gid = fattr -> gid ; } if ( nfs_server_capable ( inode , NFS_CAP_OWNER_GROUP ) ) { nfs_set_cache_invalid ( inode , NFS_INO_INVALID_ATTR ) ; } if ( fattr -> valid & NFS_ATTR_FATTR_BLOCKS_USED ) { inode -> i_blocks = fattr -> du . nfs2 . blocks ; } if ( fattr -> valid & NFS_ATTR_FATTR_SPACE_USED ) { inode -> i_blocks = nfs_calc_block_size ( fattr -> du . nfs3 . used ) ; } nfs_setsecurity ( inode , fattr , label ) ; nfsi -> attrtimeo = NFS_MINATTRTIMEO ( inode ) ; nfsi -> attrtimeo_timestamp = now ; nfsi -> access_cache = RB_ROOT ; nfs_fscache_init_inode ( inode ) ; unlock_new_inode ( inode ) ; } else { nfs_refresh_inode ( inode , fattr ) ; } dprintk ( "NFS: nfs_fhget(%s/%Lu fh_crc=0x%08x ct=%d)\n" , inode -> i_sb -> s_id , ( unsigned long long ) NFS_FILEID ( inode ) , nfs_display_fhandle_hash ( fh ) , atomic_read ( & inode -> i_count ) ) ; out return inode ; out_no_inode dprintk ( "nfs_fhget: iget failed with error %ld\n" , PTR_ERR ( inode ) ) ; out } 