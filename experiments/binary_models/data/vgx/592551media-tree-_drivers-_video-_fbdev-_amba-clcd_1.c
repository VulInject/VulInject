static int clcdfb_probe ( struct amba_device * dev , const struct amba_id * id ) { struct clcd_board * board = dev_get_platdata ( & dev -> dev ) ; struct clcd_vendor_data * vendor = id -> data ; struct clcd_fb * fb ; int ret ; if ( ! board ) { board = clcdfb_of_get_board ( dev ) ; } if ( ! board ) { return - EINVAL ; } if ( vendor -> init_board ) { ret = vendor -> init_board ( dev , board ) ; if ( ret ) { return ret ; } } ret = dma_set_mask_and_coherent ( & dev -> dev , DMA_BIT_MASK ( 32 ) ) ; if ( ret ) { out } ret = amba_request_regions ( dev , NULL ) ; if ( ret ) { printk ( KERN_ERR "CLCD: unable to reserve regs region\n" ) ; out } fb = kzalloc ( sizeof ( clcd_fb ) , GFP_KERNEL ) ; if ( ! fb ) { printk ( KERN_INFO "CLCD: could not allocate new clcd_fb struct\n" ) ; ret = - ENOMEM ; free_region } fb -> dev = dev ; fb -> vendor = vendor ; fb -> board = board ; dev_info ( & fb -> dev -> dev , "PL%03x designer %02x rev%u at 0x%08llx\n" , amba_part ( dev ) , amba_manf ( dev ) , amba_rev ( dev ) , ( unsigned long long ) dev -> res . start ) ; ret = fb -> board -> setup ( fb ) ; if ( ret ) { free_fb } ret = clcdfb_register ( fb ) ; if ( ret == 0 ) { amba_set_drvdata ( dev , fb ) ; out } fb -> board -> remove ( fb ) ; free_fb free_region amba_release_regions ( dev ) ; out return ret ; } 