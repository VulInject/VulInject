TSK_FS_INFO * ext2fs_open ( TSK_IMG_INFO * img_info , TSK_OFF_T offset , TSK_FS_TYPE_ENUM ftype , uint8_t test ) { EXT2FS_INFO * ext2fs ; unsigned int len ; TSK_FS_INFO * fs ; ssize_t cnt ; tsk_error_reset ( ) ; if ( TSK_FS_TYPE_ISEXT ( ftype ) == 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_ARG ) ; tsk_error_set_errstr ( "Invalid FS Type in ext2fs_open" ) ; return NULL ; } if ( img_info -> sector_size == 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_ARG ) ; tsk_error_set_errstr ( "ext2fs_open: sector size is 0" ) ; return NULL ; } if ( ( ext2fs = ( EXT2FS_INFO * ) tsk_fs_malloc ( sizeof ( * ext2fs ) ) ) == NULL ) { return NULL ; } fs = & ( ext2fs -> fs_info ) ; fs -> ftype = ftype ; fs -> flags = 0 ; fs -> img_info = img_info ; fs -> offset = offset ; fs -> tag = TSK_FS_INFO_TAG ; len = sizeof ( ext2fs_sb ) ; if ( ( ext2fs -> fs = ( ext2fs_sb * ) tsk_malloc ( len ) ) == NULL ) { fs -> tag = 0 ; tsk_fs_free ( ( TSK_FS_INFO * ) ext2fs ) ; return NULL ; } cnt = tsk_fs_read ( fs , EXT2FS_SBOFF , ( char * ) ext2fs -> fs , len ) ; if ( cnt != len ) { if ( cnt >= 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_READ ) ; } tsk_error_set_errstr2 ( "ext2fs_open: superblock" ) ; fs -> tag = 0 ; tsk_fs_free ( ( TSK_FS_INFO * ) ext2fs ) ; return NULL ; } if ( tsk_fs_guessu16 ( fs , ext2fs -> fs -> s_magic , EXT2FS_FS_MAGIC ) ) { fs -> tag = 0 ; free ( ext2fs -> fs ) ; tsk_fs_free ( ( TSK_FS_INFO * ) ext2fs ) ; tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_MAGIC ) ; tsk_error_set_errstr ( "not an EXTxFS file system (magic)" ) ; if ( tsk_verbose ) { fprintf ( stderr , "ext2fs_open: invalid magic\n" ) ; } return NULL ; } if ( tsk_verbose ) { if ( tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_feature_ro_compat ) & EXT2FS_FEATURE_RO_COMPAT_SPARSE_SUPER ) { tsk_fprintf ( stderr , "File system has sparse super blocks\n" ) ; } tsk_fprintf ( stderr , "First data block is %" PRIu32 "\n" , tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_first_data_block ) ) ; } if ( ftype == TSK_FS_TYPE_EXT_DETECT ) { if ( tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_feature_incompat ) & EXT2FS_FEATURE_INCOMPAT_EXTENTS ) { fs -> ftype = TSK_FS_TYPE_EXT4 ; fs -> flags |= TSK_FS_INFO_FLAG_HAVE_NANOSEC ; } if ( tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_feature_compat ) & EXT2FS_FEATURE_COMPAT_HAS_JOURNAL ) { fs -> ftype = TSK_FS_TYPE_EXT3 ; } else { fs -> ftype = TSK_FS_TYPE_EXT2 ; } } fs -> duname = "Fragment" ; if ( tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_feature_incompat ) & EXT2FS_FEATURE_INCOMPAT_FILETYPE ) { ext2fs -> deentry_type = EXT2_DE_V2 ; } else { ext2fs -> deentry_type = EXT2_DE_V1 ; } fs -> inum_count = tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_inodes_count ) + 1 ; fs -> last_inum = fs -> inum_count ; fs -> first_inum = EXT2FS_FIRSTINO ; fs -> root_inum = EXT2FS_ROOTINO ; if ( fs -> inum_count < 10 ) { fs -> tag = 0 ; free ( ext2fs -> fs ) ; tsk_fs_free ( ( TSK_FS_INFO * ) ext2fs ) ; tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_MAGIC ) ; tsk_error_set_errstr ( "Not an EXTxFS file system (inum count)" ) ; if ( tsk_verbose ) { fprintf ( stderr , "ext2fs_open: two few inodes\n" ) ; } return NULL ; } ext2fs -> inode_size = tsk_getu16 ( fs -> endian , ext2fs -> fs -> s_inode_size ) ; if ( ext2fs -> inode_size < sizeof ( ext2fs_inode ) ) { if ( tsk_verbose ) { tsk_fprintf ( stderr , "SB inode size is small" ) ; } } fs -> dev_bsize = img_info -> sector_size ; if ( tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_feature_incompat ) & EXT2FS_FEATURE_INCOMPAT_64BIT ) { fs -> block_count = ext4_getu64 ( fs -> endian , ext2fs -> fs -> s_blocks_count_hi , ext2fs -> fs -> s_blocks_count ) ; } else { fs -> block_count = tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_blocks_count ) ; } fs -> first_block = 0 ; fs -> last_block_act = fs -> last_block = fs -> block_count - 1 ; ext2fs -> first_data_block = tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_first_data_block ) ; if ( tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_log_block_size ) != tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_log_frag_size ) ) { fs -> tag = 0 ; free ( ext2fs -> fs ) ; tsk_fs_free ( ( TSK_FS_INFO * ) ext2fs ) ; tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_UNSUPFUNC ) ; tsk_error_set_errstr ( "This file system has fragments that are a different size than blocks, which is not currently supported\nContact brian with details of the system that created this image" ) ; if ( tsk_verbose ) { fprintf ( stderr , "ext2fs_open: fragment size not equal to block size\n" ) ; } return NULL ; } if ( tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_log_block_size ) >= sizeof ( uint32_t ) * 8 ) { free ( ext2fs -> fs ) ; tsk_fs_free ( ( TSK_FS_INFO * ) ext2fs ) ; tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_CORRUPT ) ; tsk_error_set_errstr ( "Block size too large" ) ; if ( tsk_verbose ) { fprintf ( stderr , "ext2fs_open: block size too large\n" ) ; } return NULL ; } fs -> block_size = EXT2FS_MIN_BLOCK_SIZE << tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_log_block_size ) ; if ( ( fs -> block_size == 0 ) || ( fs -> block_size % 512 ) ) { fs -> tag = 0 ; free ( ext2fs -> fs ) ; tsk_fs_free ( ( TSK_FS_INFO * ) ext2fs ) ; tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_MAGIC ) ; tsk_error_set_errstr ( "Not an EXTxFS file system (block size)" ) ; if ( tsk_verbose ) { fprintf ( stderr , "ext2fs_open: invalid block size\n" ) ; } return NULL ; } if ( ( TSK_DADDR_T ) ( ( img_info -> size - offset ) / fs -> block_size ) < fs -> block_count ) { fs -> last_block_act = ( img_info -> size - offset ) / fs -> block_size - 1 ; } ext2fs -> groups_offset = roundup ( ( EXT2FS_SBOFF + sizeof ( ext2fs_sb ) ) , fs -> block_size ) ; if ( tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_blocks_per_group ) == 0 ) { fs -> tag = 0 ; free ( ext2fs -> fs ) ; tsk_fs_free ( ( TSK_FS_INFO * ) ext2fs ) ; tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_MAGIC ) ; tsk_error_set_errstr ( "Not an EXTxFS file system (blocks per group)" ) ; if ( tsk_verbose ) { fprintf ( stderr , "ext2fs_open: blocks per group is 0\n" ) ; } return NULL ; } if ( tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_inodes_per_group ) == 0 ) { fs -> tag = 0 ; free ( ext2fs -> fs ) ; tsk_fs_free ( ( TSK_FS_INFO * ) ext2fs ) ; tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_MAGIC ) ; tsk_error_set_errstr ( "Not an EXTxFS file system (inodes per group)" ) ; if ( tsk_verbose ) { fprintf ( stderr , "ext2fs_open: inodes per group is 0\n" ) ; } return NULL ; } if ( tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_feature_incompat ) & EXT2FS_FEATURE_INCOMPAT_64BIT ) { ext2fs -> groups_count = ( EXT2_GRPNUM_T ) ( ( ext4_getu64 ( fs -> endian , ext2fs -> fs -> s_blocks_count_hi , ext2fs -> fs -> s_blocks_count ) - ext2fs -> first_data_block + tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_blocks_per_group ) - 1 ) / tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_blocks_per_group ) ) ; } else { ext2fs -> groups_count = ( EXT2_GRPNUM_T ) ( ( tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_blocks_count ) - ext2fs -> first_data_block + tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_blocks_per_group ) - 1 ) / tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_blocks_per_group ) ) ; } for ( fs -> fs_id_used = 0 ; fs -> fs_id_used < 16 ; fs -> fs_id_used ++ ) { fs -> fs_id [ fs -> fs_id_used ] = ext2fs -> fs -> s_uuid [ fs -> fs_id_used ] ; } fs -> inode_walk = ext2fs_inode_walk ; fs -> block_walk = ext2fs_block_walk ; fs -> block_getflags = ext2fs_block_getflags ; fs -> get_default_attr_type = tsk_fs_unix_get_default_attr_type ; fs -> load_attrs = ext2fs_load_attrs ; fs -> file_add_meta = ext2fs_inode_lookup ; fs -> dir_open_meta = ext2fs_dir_open_meta ; fs -> fsstat = ext2fs_fsstat ; fs -> fscheck = ext2fs_fscheck ; fs -> istat = ext2fs_istat ; fs -> name_cmp = tsk_fs_unix_name_cmp ; fs -> close = ext2fs_close ; fs -> journ_inum = tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_journal_inum ) ; fs -> jblk_walk = ext2fs_jblk_walk ; fs -> jentry_walk = ext2fs_jentry_walk ; fs -> jopen = ext2fs_jopen ; ext2fs -> imap_buf = NULL ; ext2fs -> imap_grp_num = 0xffffffff ; ext2fs -> bmap_buf = NULL ; ext2fs -> bmap_grp_num = 0xffffffff ; ext2fs -> grp_buf = NULL ; ext2fs -> grp_num = 0xffffffff ; if ( tsk_verbose ) { tsk_fprintf ( stderr , "inodes %" PRIu32 " root ino %" PRIuINUM " blocks %" PRIu32 " blocks/group %" PRIu32 "\n" , tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_inodes_count ) , fs -> root_inum , tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_blocks_count ) , tsk_getu32 ( fs -> endian , ext2fs -> fs -> s_blocks_per_group ) ) ; } tsk_init_lock ( & ext2fs -> lock ) ; return fs ; } 