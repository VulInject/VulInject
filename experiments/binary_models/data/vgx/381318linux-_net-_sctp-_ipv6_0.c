static void FUN1(struct VAR1 *VAR2, union VAR3 *VAR4,
struct VAR5 *VAR6, struct VAR7 *VAR8)
{
struct VAR9 *VAR10 = VAR2->VAR10;
struct VAR11 *VAR12 = NULL;
struct flowi VAR13;
struct VAR14 *VAR15 = &VAR13.VAR16.VAR17;
struct VAR18 *VAR19;
struct VAR20 *VAR21 = FUN2(VAR8);
struct VAR22 *VAR23;
union VAR3 *VAR24 = &VAR2->VAR25;
union sctp_addr VAR26;
struct VAR27 *VAR28, final;
enum sctp_scope VAR29;
__u8 VAR30 = 0;

memset(&VAR13, 0, sizeof(VAR13));
VAR15->VAR24 = VAR24->VAR31.VAR32;
VAR15->VAR33 = VAR24->VAR31.VAR34;
VAR15->VAR35 = VAR36;
if (FUN3(&VAR24->VAR31.VAR32) & VAR37)
VAR15->VAR38 = VAR24->VAR31.VAR39;
else if (VAR10)
VAR15->VAR38 = VAR10->VAR40.VAR8->VAR41;
if (VAR2->VAR42 & VAR43)
VAR15->VAR42 = FUN4(VAR2->VAR42 & VAR44);

if (VAR21->VAR45 && (VAR15->VAR42 & VAR46)) {
struct VAR47 *VAR42;

VAR42 = FUN5(VAR8, VAR15->VAR42);
if (FUN6(VAR42))
goto VAR48;
FUN7(VAR42);
}

FUN8("", VAR49, &VAR15->VAR24);

if (VAR10)
VAR15->VAR50 = FUN9(VAR10->VAR40.VAR51.VAR52);

if (VAR4) {
VAR15->VAR4 = VAR4->VAR31.VAR32;
if (!VAR15->VAR50)
VAR15->VAR50 = VAR4->VAR31.VAR34;

FUN8("", &VAR15->VAR4);
}

FUN10();
VAR28 = FUN11(VAR15, FUN12(VAR21->VAR53), &final);
FUN13();

VAR12 = FUN14(FUN15(VAR8), VAR8, VAR15, VAR28);
if (!VAR10 || VAR4) {
VAR2->VAR12 = VAR12;
memcpy(VAR6, &VAR13, sizeof(VAR13));
goto VAR48;
}

VAR19 = &VAR10->VAR40.VAR51;
VAR29 = FUN16(VAR24);

if (!FUN6(VAR12)) {

FUN17(&VAR26, &VAR15->VAR4, FUN9(VAR19->VAR52));
FUN10();
FUN18(VAR23, &VAR19->VAR54, VAR55) {
if (!VAR23->VAR56 || VAR23->VAR57 == VAR58 ||
(VAR23->VAR57 != VAR59 &&
!VAR10->VAR60))
continue;


if ((VAR23->VAR61.VAR62.VAR63 == VAR64) &&
(FUN19(&VAR26, &VAR23->VAR61))) {
FUN13();
VAR2->VAR12 = VAR12;
memcpy(VAR6, &VAR13, sizeof(VAR13));
goto VAR48;
}
}
FUN13();

FUN20(VAR12);
VAR12 = NULL;
}


FUN10();
FUN18(VAR23, &VAR19->VAR54, VAR55) {
struct VAR11 *VAR65;
__u8 VAR66;

if (!VAR23->VAR56 ||
VAR23->VAR57 != VAR59 ||
VAR23->VAR61.VAR62.VAR63 != VAR64 ||
VAR29 > FUN16(&VAR23->VAR61))
continue;

VAR15->VAR4 = VAR23->VAR61.VAR31.VAR32;
VAR15->VAR50 = VAR23->VAR61.VAR31.VAR34;
VAR28 = FUN11(VAR15, FUN12(VAR21->VAR53), &final);
VAR65 = FUN14(FUN15(VAR8), VAR8, VAR15, VAR28);

if (FUN6(VAR65))
continue;

if (FUN21(FUN22(VAR65->VAR67),
&VAR23->VAR61.VAR31.VAR32, VAR65->VAR67, 1)) {
if (!FUN23(VAR12))
FUN20(VAR12);
VAR12 = VAR65;
VAR2->VAR12 = VAR12;
memcpy(VAR6, &VAR13, sizeof(VAR13));
break;
}

VAR66 = FUN24(VAR24, &VAR23->VAR61);
if (VAR30 > VAR66) {
FUN20(VAR65);
continue;
}

if (!FUN23(VAR12))
FUN20(VAR12);
VAR12 = VAR65;
VAR30 = VAR66;
VAR2->VAR12 = VAR12;
memcpy(VAR6, &VAR13, sizeof(VAR13));
}
FUN13();

VAR48:
if (!FUN23(VAR12)) {
struct VAR68 *VAR69;

VAR69 = (struct VAR68 *)VAR12;
VAR2->VAR70 = FUN25(VAR69);
FUN8("",
&VAR69->VAR71.VAR72, VAR69->VAR71.VAR73,
&VAR6->VAR16.VAR17.VAR4);
} else {
VAR2->VAR12 = NULL;
FUN8("");
}
}