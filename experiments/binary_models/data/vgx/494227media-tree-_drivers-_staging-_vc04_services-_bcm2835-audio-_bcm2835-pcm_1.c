static int snd_bcm2835_playback_open_generic ( struct snd_pcm_substream * substream , int spdif ) { struct bcm2835_chip * chip = snd_pcm_substream_chip ( substream ) ; struct snd_pcm_runtime * runtime = substream -> runtime ; struct bcm2835_alsa_stream * alsa_stream ; int idx ; int err ; if ( mutex_lock_interruptible ( & chip -> audio_mutex ) ) { audio_error ( "Interrupted whilst waiting for lock\n" ) ; return - EINTR ; } audio_info ( "Alsa open (%d)\n" , substream -> number ) ; idx = substream -> number ; if ( spdif && chip -> opened ) { err = - EBUSY ; out } if ( ! spdif && ( chip -> opened & ( 1 << idx ) ) ) { err = - EBUSY ; out } if ( idx >= MAX_SUBSTREAMS ) { audio_error ( "substream(%d) device doesn't exist max(%d) substreams allowed\n" , idx , MAX_SUBSTREAMS ) ; err = - ENODEV ; out } if ( ! ( chip -> avail_substreams & ( 1 << idx ) ) ) { audio_error ( "substream(%d) device is not ready yet\n" , idx ) ; err = - EAGAIN ; out } alsa_stream = kzalloc ( sizeof ( * alsa_stream ) , GFP_KERNEL ) ; if ( ! alsa_stream ) { err = - ENOMEM ; out } alsa_stream -> chip = chip ; alsa_stream -> substream = substream ; alsa_stream -> idx = idx ; spin_lock_init ( & alsa_stream -> lock ) ; err = bcm2835_audio_open ( alsa_stream ) ; if ( err ) { kfree ( alsa_stream ) ; out } runtime -> private_data = alsa_stream ; runtime -> private_free = snd_bcm2835_playback_free ; if ( spdif ) { runtime -> hw = snd_bcm2835_playback_spdif_hw ; } else { chip -> spdif_status = 0 ; runtime -> hw = snd_bcm2835_playback_hw ; } snd_pcm_hw_constraint_step ( runtime , 0 , SNDRV_PCM_HW_PARAM_PERIOD_BYTES , 16 ) ; chip -> alsa_stream [ idx ] = alsa_stream ; chip -> opened |= ( 1 << idx ) ; alsa_stream -> open = 1 ; alsa_stream -> draining = 1 ; out return err ; } 