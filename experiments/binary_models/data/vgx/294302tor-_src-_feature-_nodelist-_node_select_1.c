STATIC const routerstatus_t * router_pick_directory_server_impl ( dirinfo_type_t type , int flags , int * n_busy_out ) { const or_options_t * options = get_options ( ) ; const node_t * result ; smartlist_t * direct , * tunnel ; smartlist_t * trusted_direct , * trusted_tunnel ; smartlist_t * overloaded_direct , * overloaded_tunnel ; time_t now = time ( NULL ) ; const networkstatus_t * consensus = networkstatus_get_latest_consensus ( ) ; const int requireother = ! ( flags & PDS_ALLOW_SELF ) ; const int fascistfirewall = ! ( flags & PDS_IGNORE_FASCISTFIREWALL ) ; const int no_serverdesc_fetching = ( flags & PDS_NO_EXISTING_SERVERDESC_FETCH ) ; const int no_microdesc_fetching = ( flags & PDS_NO_EXISTING_MICRODESC_FETCH ) ; int try_excluding = 1 , n_excluded = 0 , n_busy = 0 ; int try_ip_pref = 1 ; if ( ! consensus ) { return in ; } retry_search direct = smartlist_new ( ) ; tunnel = smartlist_new ( ) ; trusted_direct = smartlist_new ( ) ; trusted_tunnel = smartlist_new ( ) ; overloaded_direct = smartlist_new ( ) ; overloaded_tunnel = smartlist_new ( ) ; const int skip_or_fw = router_or_conn_should_skip_reachable_address_check ( options , try_ip_pref ) ; const int skip_dir_fw = router_dir_conn_should_skip_reachable_address_check ( options , try_ip_pref ) ; const int must_have_or = dirclient_must_use_begindir ( options ) ; SMARTLIST_FOREACH_BEGIN ( , , ) { int is_trusted ; int is_overloaded ; const routerstatus_t * status = node -> rs ; const country_t country = node -> country ; if ( ! status ) { continue ; } if ( ! node -> is_running || ! node_is_dir ( node ) || ! node -> is_valid ) { continue ; } if ( requireother && router_digest_is_me ( node -> identity ) ) { continue ; } SKIP_MISSING_TRUSTED_EXTRAINFO ( type , node -> identity ) ; if ( try_excluding && routerset_contains_routerstatus ( options -> ExcludeNodes , status , country ) ) { ++ n_excluded ; continue ; } if ( router_is_already_dir_fetching_ ( & status -> ipv4_addr , & status -> ipv6_addr , status -> ipv4_dirport , no_serverdesc_fetching , no_microdesc_fetching ) ) { ++ n_busy ; continue ; } is_overloaded = status -> last_dir_503_at + DIR_503_TIMEOUT > now ; is_trusted = router_digest_is_trusted_dir ( node -> identity ) ; if ( ! fascistfirewall || skip_or_fw || reachable_addr_allows_node ( node , FIREWALL_OR_CONNECTION , try_ip_pref ) ) { smartlist_add ( is_trusted ?trusted_tunnel : is_overloaded ?overloaded_tunnel : tunnel , ( void * ) node ) ; } if ( ! must_have_or && ( skip_dir_fw || reachable_addr_allows_node ( node , FIREWALL_DIR_CONNECTION , try_ip_pref ) ) ) { smartlist_add ( is_trusted ?trusted_direct : is_overloaded ?overloaded_direct : direct , ( void * ) node ) ; } } SMARTLIST_FOREACH_END ( node ) ; if ( smartlist_len ( tunnel ) ) { result = node_sl_choose_by_bandwidth ( tunnel , WEIGHT_FOR_DIR ) ; } if ( smartlist_len ( overloaded_tunnel ) ) { result = node_sl_choose_by_bandwidth ( overloaded_tunnel , WEIGHT_FOR_DIR ) ; } if ( smartlist_len ( trusted_tunnel ) ) { result = smartlist_choose ( trusted_tunnel ) ; } if ( smartlist_len ( direct ) ) { result = node_sl_choose_by_bandwidth ( direct , WEIGHT_FOR_DIR ) ; } if ( smartlist_len ( overloaded_direct ) ) { result = node_sl_choose_by_bandwidth ( overloaded_direct , WEIGHT_FOR_DIR ) ; } else { result = smartlist_choose ( trusted_direct ) ; } smartlist_free ( direct ) ; smartlist_free ( tunnel ) ; smartlist_free ( trusted_direct ) ; smartlist_free ( trusted_tunnel ) ; smartlist_free ( overloaded_direct ) ; smartlist_free ( overloaded_tunnel ) ; RETRY_ALTERNATE_IP_VERSION ( retry_search ) ; RETRY_WITHOUT_EXCLUDE ( retry_search ) ; if ( n_busy_out ) { * n_busy_out = n_busy ; } router_picked_poor_directory_log ( result ?result -> rs : NULL ) ; return result ?result -> rs : NULL ; } 