static void hfi1_ipoib_ib_rcv ( struct hfi1_packet * packet ) { struct hfi1_ibport * ibp ; struct net_device * netdev ; struct hfi1_ctxtdata * rcd = packet -> rcd ; struct napi_struct * napi = rcd -> napi ; struct sk_buff * skb ; struct hfi1_netdev_rxq * rxq = container_of ( napi , hfi1_netdev_rxq , napi ) ; u32 extra_bytes ; u32 tlen , qpnum ; bool do_work , do_cnp ; trace_hfi1_rcvhdr ( packet ) ; hfi1_setup_ib_header ( packet ) ; packet -> ohdr = & ( ( ib_header * ) packet -> hdr ) -> u . oth ; packet -> grh = NULL ; if ( unlikely ( rhf_err_flags ( packet -> rhf ) ) ) { handle_eflags ( packet , NULL ) ; return ; } qpnum = ib_bth_get_qpn ( packet -> ohdr ) ; netdev = hfi1_netdev_get_data ( rcd -> dd , qpnum ) ; if ( ! netdev ) { drop_no_nd } trace_input_ibhdr ( rcd -> dd , packet , ! ! ( rhf_dc_info ( packet -> rhf ) ) ) ; trace_ctxt_rsm_hist ( rcd -> ctxt ) ; do_work = hfi1_may_ecn ( packet ) ; if ( unlikely ( do_work ) ) { do_cnp = ( packet -> opcode != IB_OPCODE_CNP ) ; ( void ) hfi1_process_ecn_slowpath ( hfi1_ipoib_priv ( netdev ) -> qp , packet , do_cnp ) ; } tlen = packet -> tlen ; extra_bytes = ib_bth_get_pad ( packet -> ohdr ) + ( SIZE_OF_CRC << 2 ) + packet -> hlen ; if ( unlikely ( tlen < extra_bytes ) ) { drop } tlen -= extra_bytes ; skb = hfi1_ipoib_prepare_skb ( rxq , tlen , packet -> ebuf ) ; if ( unlikely ( ! skb ) ) { drop } dev_sw_netstats_rx_add ( netdev , skb -> len ) ; skb -> dev = netdev ; skb -> pkt_type = PACKET_HOST ; netif_receive_skb ( skb ) ; return ; drop ++ netdev -> stats . rx_dropped ; drop_no_nd ibp = rcd_to_iport ( packet -> rcd ) ; ++ ibp -> rvp . n_pkt_drops ; } 