static void accept_v6_message ( dhcp_smach_t * dsmp , PKT_LIST * plp , const char * pname , uchar_t recv_type ) { const dhcpv6_option_t * d6o ; uint_t olen ; const char * estr , * msg ; uint_t msglen ; int status ; dsmp -> dsm_received ++ ; if ( recv_type == DHCPV6_MSG_RECONFIGURE ) { dhcpmsg ( MSG_VERBOSE , "accept_v6_message: ignored Reconfigure " "on %s" , dsmp -> dsm_name ) ; return ; } d6o = dhcpv6_pkt_option ( plp , NULL , DHCPV6_OPT_CLIENTID , & olen ) ; olen -= sizeof ( * d6o ) ; if ( d6o == NULL || olen != dsmp -> dsm_cidlen || memcmp ( d6o + 1 , dsmp -> dsm_cid , olen ) != 0 ) { dhcpmsg ( MSG_VERBOSE , "accept_v6_message: discarded %s on %s: %s Client ID" , pname , dsmp -> dsm_name , d6o == NULL ?"no" : "wrong" ) ; free_pkt_entry ( plp ) ; return ; } d6o = dhcpv6_pkt_option ( plp , NULL , DHCPV6_OPT_SERVERID , & olen ) ; if ( d6o == NULL ) { dhcpmsg ( MSG_DEBUG , "accept_v6_message: discarded %s on %s: no Server ID" , pname , dsmp -> dsm_name ) ; free_pkt_entry ( plp ) ; return ; } if ( recv_type == DHCPV6_MSG_REPLY && dsmp -> dsm_state != SELECTING && dsmp -> dsm_state != INIT_REBOOT && dsmp -> dsm_state != REBINDING && dsmp -> dsm_state != INFORM_SENT ) { olen -= sizeof ( * d6o ) ; if ( olen != dsmp -> dsm_serveridlen || memcmp ( d6o + 1 , dsmp -> dsm_serverid , olen ) != 0 ) { dhcpmsg ( MSG_DEBUG , "accept_v6_message: discarded %s on " "%s: wrong Server ID" , pname , dsmp -> dsm_name ) ; free_pkt_entry ( plp ) ; return ; } } switch ( dsmp -> dsm_state ) { case SELECTING : if ( recv_type == DHCPV6_MSG_REPLY ) { if ( dhcpv6_pkt_option ( plp , NULL , DHCPV6_OPT_RAPID_COMMIT , & olen ) == NULL ) { dhcpmsg ( MSG_DEBUG , "accept_v6_message: Reply " "on %s lacks Rapid-Commit; ignoring" , dsmp -> dsm_name ) ; break ; } dhcpmsg ( MSG_VERBOSE , "accept_v6_message: rapid-commit Reply on %s" , dsmp -> dsm_name ) ; cancel_offer_timer ( dsmp ) ; rapid_commit } if ( recv_type != DHCPV6_MSG_ADVERTISE ) { break ; } d6o = dhcpv6_pkt_option ( plp , NULL , DHCPV6_OPT_PREFERENCE , & olen ) ; if ( d6o != NULL && olen == sizeof ( * d6o ) + 1 && * ( const uchar_t * ) ( d6o + 1 ) == 255 ) { pkt_smach_enqueue ( dsmp , plp ) ; dhcpmsg ( MSG_DEBUG , "accept_v6_message: preference 255;" " immediate Request on %s" , dsmp -> dsm_name ) ; dhcp_requesting ( NULL , dsmp ) ; } else { pkt_smach_enqueue ( dsmp , plp ) ; } return ; case PRE_BOUND : case BOUND : break ; case REQUESTING : case INIT_REBOOT : case RENEWING : case REBINDING : case INFORM_SENT : if ( recv_type != DHCPV6_MSG_REPLY ) { break ; } dhcpmsg ( MSG_VERBOSE , "accept_v6_message: received Reply message on %s" , dsmp -> dsm_name ) ; rapid_commit d6o = dhcpv6_pkt_option ( plp , NULL , DHCPV6_OPT_STATUS_CODE , & olen ) ; status = dhcpv6_status_code ( d6o , olen , & estr , & msg , & msglen ) ; if ( status == DHCPV6_STAT_USEMCAST ) { if ( IN6_IS_ADDR_MULTICAST ( & dsmp -> dsm_send_dest . v6 . sin6_addr ) ) { break ; } else { free_pkt_entry ( plp ) ; dsmp -> dsm_send_dest . v6 . sin6_addr = ipv6_all_dhcp_relay_and_servers ; retransmit_now ( dsmp ) ; return ; } } print_server_msg ( dsmp , msg , msglen ) ; if ( status == DHCPV6_STAT_SUCCESS || status == DHCPV6_STAT_NOBINDING ) { if ( dhcp_bound ( dsmp , plp ) ) { server_unicast_option ( dsmp , plp ) ; } else { stop_pkt_retransmission ( dsmp ) ; dhcpmsg ( MSG_WARNING , "accept_v6_message: " "dhcp_bound failed for %s" , dsmp -> dsm_name ) ; ( void ) remove_hostconf ( dsmp -> dsm_name , dsmp -> dsm_isv6 ) ; dhcp_restart ( dsmp ) ; } } else { dhcpmsg ( MSG_WARNING , "accept_v6_message: Reply: %s" , estr ) ; stop_pkt_retransmission ( dsmp ) ; free_pkt_entry ( plp ) ; if ( dsmp -> dsm_state == INFORM_SENT ) { ( void ) set_smach_state ( dsmp , INIT ) ; ipc_action_finish ( dsmp , DHCP_IPC_E_SRVFAILED ) ; } else { ( void ) remove_hostconf ( dsmp -> dsm_name , dsmp -> dsm_isv6 ) ; request_failed ( dsmp ) ; } } return ; case DECLINING : if ( recv_type != DHCPV6_MSG_REPLY ) { break ; } stop_pkt_retransmission ( dsmp ) ; d6o = dhcpv6_pkt_option ( plp , NULL , DHCPV6_OPT_STATUS_CODE , & olen ) ; if ( dhcpv6_status_code ( d6o , olen , & estr , & msg , & msglen ) == DHCPV6_STAT_SUCCESS ) { print_server_msg ( dsmp , msg , msglen ) ; } else { dhcpmsg ( MSG_WARNING , "accept_v6_message: Reply: %s" , estr ) ; } free_pkt_entry ( plp ) ; if ( dsmp -> dsm_leases == NULL ) { dhcpmsg ( MSG_VERBOSE , "accept_v6_message: %s has no " "leases left" , dsmp -> dsm_name ) ; dhcp_restart ( dsmp ) ; } if ( dsmp -> dsm_lif_wait == 0 ) { ( void ) set_smach_state ( dsmp , BOUND ) ; } else { ( void ) set_smach_state ( dsmp , PRE_BOUND ) ; } return ; case RELEASING : if ( recv_type != DHCPV6_MSG_REPLY ) { break ; } stop_pkt_retransmission ( dsmp ) ; d6o = dhcpv6_pkt_option ( plp , NULL , DHCPV6_OPT_STATUS_CODE , & olen ) ; if ( dhcpv6_status_code ( d6o , olen , & estr , & msg , & msglen ) == DHCPV6_STAT_SUCCESS ) { print_server_msg ( dsmp , msg , msglen ) ; } else { dhcpmsg ( MSG_WARNING , "accept_v6_message: Reply: %s" , estr ) ; } free_pkt_entry ( plp ) ; finished_smach ( dsmp , DHCP_IPC_SUCCESS ) ; return ; } dhcpmsg ( MSG_VERBOSE , "accept_v6_message: discarded v6 %s on %s; state %s" , pname , dsmp -> dsm_name , dhcp_state_to_string ( dsmp -> dsm_state ) ) ; free_pkt_entry ( plp ) ; } 