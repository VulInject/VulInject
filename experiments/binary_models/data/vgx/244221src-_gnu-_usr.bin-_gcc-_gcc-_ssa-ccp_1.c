ssa_const_prop ( ) { unsigned int i ; edge curredge ; init_alias_analysis ( ) ; df_analyzer = df_init ( ) ; df_analyse ( df_analyzer , 0 , DF_RD_CHAIN | DF_RU_CHAIN | DF_REG_INFO | DF_HARD_REGS ) ; ssa_fast_dce ( df_analyzer ) ; edges = create_edge_list ( ) ; values = ( value * ) xmalloc ( VARRAY_SIZE ( ssa_definition ) * sizeof ( value ) ) ; for ( i = 0 ; i < VARRAY_SIZE ( ssa_definition ) ; i ++ ) { if ( i < FIRST_PSEUDO_REGISTER ) { values [ i ] . lattice_val = VARYING ; } else { values [ i ] . lattice_val = UNDEFINED ; } values [ i ] . const_value = NULL ; } ssa_edges = sbitmap_alloc ( VARRAY_SIZE ( ssa_definition ) ) ; sbitmap_zero ( ssa_edges ) ; executable_blocks = sbitmap_alloc ( last_basic_block ) ; sbitmap_zero ( executable_blocks ) ; executable_edges = sbitmap_alloc ( NUM_EDGES ( edges ) ) ; sbitmap_zero ( executable_edges , NULL ) ; edge_info = ( edge * ) xmalloc ( NUM_EDGES ( edges ) * sizeof ( edge ) ) ; flow_edges = ENTRY_BLOCK_PTR -> succ ; for ( curredge = ENTRY_BLOCK_PTR -> succ ; curredge ; curredge = curredge -> succ_next ) { int index = EIE ( curredge -> src , curredge -> dest ) ; SET_BIT ( executable_edges , index ) ; edge_info [ index ] = curredge -> succ_next ; } { examine_flow_edges ( ) ; follow_def_use_chains ( ) ; } flow_edges != NULL ; ssa_ccp_substitute_constants ( ) ; optimize_unexecutable_edges ( edges , executable_edges ) ; ssa_ccp_df_delete_unreachable_insns ( ) ; df_analyse ( df_analyzer , 0 , DF_RD_CHAIN | DF_RU_CHAIN | DF_REG_INFO | DF_HARD_REGS ) ; ssa_fast_dce ( df_analyzer ) ; free ( values ) ; values = NULL ; free ( edge_info ) ; edge_info = NULL ; sbitmap_free ( executable_blocks ) ; executable_blocks = NULL ; sbitmap_free ( ssa_edges ) ; ssa_edges = NULL ; free_edge_list ( edges ) ; edges = NULL ; sbitmap_free ( executable_edges ) ; executable_edges = NULL ; df_finish ( df_analyzer ) ; end_alias_analysis ( ) ; } 