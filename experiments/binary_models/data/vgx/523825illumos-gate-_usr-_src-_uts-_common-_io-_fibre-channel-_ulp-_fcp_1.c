static int fcp_setup_device_data_ioctl ( int cmd , struct fcp_ioctl * data , int mode , int * rval ) { struct fcp_port * pptr ; struct device_data * dev_data ; uint32_t link_cnt ; la_wwn_t * wwn_ptr = NULL ; struct fcp_tgt * ptgt = NULL ; struct fcp_lun * plun ; int i , error ; struct fcp_ioctl fioctl ; switch ( ddi_model_convert_from ( mode & FMODELS ) ) { case DDI_MODEL_ILP32 : { struct fcp32_ioctl f32_ioctl ; if ( ddi_copyin ( ( void * ) data , ( void * ) & f32_ioctl , sizeof ( fcp32_ioctl ) , mode ) ) { return ( EFAULT ) ; } fioctl . fp_minor = f32_ioctl . fp_minor ; fioctl . listlen = f32_ioctl . listlen ; fioctl . list = ( caddr_t ) ( long ) f32_ioctl . list ; break ; } case DDI_MODEL_NONE : if ( ddi_copyin ( ( void * ) data , ( void * ) & fioctl , sizeof ( fcp_ioctl ) , mode ) ) { return ( EFAULT ) ; } break ; } if ( ddi_copyin ( ( void * ) data , ( void * ) & fioctl , sizeof ( fcp_ioctl ) , mode ) ) { return ( EFAULT ) ; } mutex_enter ( & fcp_global_mutex ) ; pptr = fcp_port_head ; while ( pptr ) { if ( pptr -> port_instance == ( uint32_t ) fioctl . fp_minor ) { break ; } else { pptr = pptr -> port_next ; } } mutex_exit ( & fcp_global_mutex ) ; if ( pptr == NULL ) { return ( ENXIO ) ; } mutex_enter ( & pptr -> port_mutex ) ; if ( ( dev_data = kmem_zalloc ( ( sizeof ( device_data ) ) * fioctl . listlen , KM_NOSLEEP ) ) == NULL ) { mutex_exit ( & pptr -> port_mutex ) ; return ( ENOMEM ) ; } if ( ddi_copyin ( fioctl . list , dev_data , ( sizeof ( device_data ) ) * fioctl . listlen , mode ) ) { kmem_free ( dev_data , sizeof ( * dev_data ) * fioctl . listlen ) ; mutex_exit ( & pptr -> port_mutex ) ; return ( EFAULT ) ; } link_cnt = pptr -> port_link_cnt ; if ( cmd == FCP_TGT_INQUIRY ) { wwn_ptr = ( la_wwn_t * ) & ( dev_data [ 0 ] . dev_pwwn ) ; if ( bcmp ( wwn_ptr -> raw_wwn , pptr -> port_pwwn . raw_wwn , sizeof ( wwn_ptr -> raw_wwn ) ) == 0 ) { mutex_exit ( & pptr -> port_mutex ) ; dev_data [ 0 ] . dev0_type = DTYPE_UNKNOWN ; dev_data [ 0 ] . dev_status = 0 ; if ( ddi_copyout ( dev_data , fioctl . list , ( sizeof ( device_data ) ) * fioctl . listlen , mode ) ) { kmem_free ( dev_data , sizeof ( * dev_data ) * fioctl . listlen ) ; return ( EFAULT ) ; } kmem_free ( dev_data , sizeof ( * dev_data ) * fioctl . listlen ) ; switch ( ddi_model_convert_from ( mode & FMODELS ) ) { case DDI_MODEL_ILP32 : { struct fcp32_ioctl f32_ioctl ; f32_ioctl . fp_minor = fioctl . fp_minor ; f32_ioctl . listlen = fioctl . listlen ; f32_ioctl . list = ( caddr32_t ) ( long ) fioctl . list ; if ( ddi_copyout ( ( void * ) & f32_ioctl , ( void * ) data , sizeof ( fcp32_ioctl ) , mode ) ) { return ( EFAULT ) ; } break ; } case DDI_MODEL_NONE : if ( ddi_copyout ( ( void * ) & fioctl , ( void * ) data , sizeof ( fcp_ioctl ) , mode ) ) { return ( EFAULT ) ; } break ; } if ( ddi_copyout ( ( void * ) & fioctl , ( void * ) data , sizeof ( fcp_ioctl ) , mode ) ) { return ( EFAULT ) ; } return ( 0 ) ; } } if ( pptr -> port_state & ( FCP_STATE_INIT | FCP_STATE_OFFLINE ) ) { kmem_free ( dev_data , sizeof ( * dev_data ) * fioctl . listlen ) ; mutex_exit ( & pptr -> port_mutex ) ; return ( ENXIO ) ; } for ( i = 0 ; ( i < fioctl . listlen ) && ( link_cnt == pptr -> port_link_cnt ) ; i ++ ) { wwn_ptr = ( la_wwn_t * ) & ( dev_data [ i ] . dev_pwwn ) ; dev_data [ i ] . dev0_type = DTYPE_UNKNOWN ; dev_data [ i ] . dev_status = ENXIO ; if ( ( ptgt = fcp_lookup_target ( pptr , ( uchar_t * ) wwn_ptr ) ) == NULL ) { mutex_exit ( & pptr -> port_mutex ) ; if ( fc_ulp_get_remote_port ( pptr -> port_fp_handle , wwn_ptr , & error , 0 ) == NULL ) { dev_data [ i ] . dev_status = ENODEV ; mutex_enter ( & pptr -> port_mutex ) ; continue ; } else { dev_data [ i ] . dev_status = EAGAIN ; mutex_enter ( & pptr -> port_mutex ) ; continue ; } } else { mutex_enter ( & ptgt -> tgt_mutex ) ; if ( ptgt -> tgt_state & ( FCP_TGT_MARK | FCP_TGT_BUSY ) ) { dev_data [ i ] . dev_status = EAGAIN ; mutex_exit ( & ptgt -> tgt_mutex ) ; continue ; } if ( ptgt -> tgt_state & FCP_TGT_OFFLINE ) { if ( ptgt -> tgt_icap && ! ptgt -> tgt_tcap ) { dev_data [ i ] . dev_status = ENOTSUP ; } else { dev_data [ i ] . dev_status = ENXIO ; } mutex_exit ( & ptgt -> tgt_mutex ) ; continue ; } switch ( cmd ) { case FCP_TGT_INQUIRY : dev_data [ i ] . dev_lun_cnt = ptgt -> tgt_lun_cnt ; dev_data [ i ] . dev_status = 0 ; mutex_exit ( & ptgt -> tgt_mutex ) ; if ( ( plun = fcp_get_lun ( ptgt , 0 ) ) == NULL ) { dev_data [ i ] . dev0_type = DTYPE_UNKNOWN ; } else { dev_data [ i ] . dev0_type = plun -> lun_type ; } mutex_enter ( & ptgt -> tgt_mutex ) ; break ; case FCP_TGT_CREATE : mutex_exit ( & ptgt -> tgt_mutex ) ; mutex_exit ( & pptr -> port_mutex ) ; mutex_enter ( & fcp_global_mutex ) ; if ( fcp_oflag & FCP_BUSY ) { mutex_exit ( & fcp_global_mutex ) ; if ( dev_data ) { kmem_free ( dev_data , sizeof ( * dev_data ) * fioctl . listlen ) ; } return ( EBUSY ) ; } fcp_oflag |= FCP_BUSY ; mutex_exit ( & fcp_global_mutex ) ; dev_data [ i ] . dev_status = fcp_create_on_demand ( pptr , wwn_ptr -> raw_wwn ) ; if ( dev_data [ i ] . dev_status != 0 ) { char buf [ 25 ] ; for ( i = 0 ; i < FC_WWN_SIZE ; i ++ ) { ( void ) sprintf ( & buf [ i << 1 ] , "%02x" , wwn_ptr -> raw_wwn [ i ] ) ; } fcp_log ( CE_WARN , pptr -> port_dip , "!Failed to create nodes for" " pwwn=%s; error=%x" , buf , dev_data [ i ] . dev_status ) ; } mutex_enter ( & fcp_global_mutex ) ; fcp_oflag &= ~ FCP_BUSY ; mutex_exit ( & fcp_global_mutex ) ; mutex_enter ( & pptr -> port_mutex ) ; mutex_enter ( & ptgt -> tgt_mutex ) ; break ; case FCP_TGT_DELETE : break ; default : fcp_log ( CE_WARN , pptr -> port_dip , "!Invalid device data ioctl " "opcode = 0x%x" , cmd ) ; } mutex_exit ( & ptgt -> tgt_mutex ) ; } } mutex_exit ( & pptr -> port_mutex ) ; if ( ddi_copyout ( dev_data , fioctl . list , ( sizeof ( device_data ) ) * fioctl . listlen , mode ) ) { kmem_free ( dev_data , sizeof ( * dev_data ) * fioctl . listlen ) ; return ( EFAULT ) ; } kmem_free ( dev_data , sizeof ( * dev_data ) * fioctl . listlen ) ; switch ( ddi_model_convert_from ( mode & FMODELS ) ) { case DDI_MODEL_ILP32 : { struct fcp32_ioctl f32_ioctl ; f32_ioctl . fp_minor = fioctl . fp_minor ; f32_ioctl . listlen = fioctl . listlen ; f32_ioctl . list = ( caddr32_t ) ( long ) fioctl . list ; if ( ddi_copyout ( ( void * ) & f32_ioctl , ( void * ) data , sizeof ( fcp32_ioctl ) , mode ) ) { return ( EFAULT ) ; } break ; } case DDI_MODEL_NONE : if ( ddi_copyout ( ( void * ) & fioctl , ( void * ) data , sizeof ( fcp_ioctl ) , mode ) ) { return ( EFAULT ) ; } break ; } if ( ddi_copyout ( ( void * ) & fioctl , ( void * ) data , sizeof ( fcp_ioctl ) , mode ) ) { return ( EFAULT ) ; } return ( 0 ) ; } 