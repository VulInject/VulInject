static ssize_t fill_periodic_buffer ( struct debug_buffer * buf ) { struct usb_hcd * hcd ; struct fotg210_hcd * fotg210 ; cfs_time_t flags ; union fotg210_shadow p , * seen ; unsigned temp , size , seen_count ; char * next ; unsigned i ; __hc32 tag ; seen = kmalloc_array ( DBG_SCHED_LIMIT , sizeof ( * seen ) , GFP_ATOMIC ) ; if ( ! seen ) { return 0 ; } seen_count = 0 ; hcd = bus_to_hcd ( buf -> bus ) ; fotg210 = hcd_to_fotg210 ( hcd ) ; next = buf -> output_buf ; size = buf -> alloc_size ; temp = scnprintf ( next , size , "size = %d\n" , fotg210 -> periodic_size ) ; size -= temp ; next += temp ; spin_lock_irqsave ( & fotg210 -> lock , flags ) ; for ( i = 0 ; i < fotg210 -> periodic_size ; i ++ ) { p = fotg210 -> pshadow [ i ] ; if ( likely ( ! p . ptr ) ) { continue ; } tag = Q_NEXT_TYPE ( fotg210 , fotg210 -> periodic [ i ] ) ; temp = scnprintf ( next , size , "%4d: " , i ) ; size -= temp ; next += temp ; { struct fotg210_qh_hw * hw ; switch ( hc32_to_cpu ( fotg210 , tag ) ) { case Q_TYPE_QH : hw = p . qh -> hw ; temp = scnprintf ( next , size , " qh%d-%04x/%p" , p . qh -> period , hc32_to_cpup ( fotg210 , & hw -> hw_info2 ) & ( QH_CMASK | QH_SMASK ) , p . qh ) ; size -= temp ; next += temp ; for ( temp = 0 ; temp < seen_count ; temp ++ ) { if ( seen [ temp ] . ptr != p . ptr ) { continue ; } if ( p . qh -> qh_next . ptr ) { temp = scnprintf ( next , size , " ..." ) ; size -= temp ; next += temp ; } break ; } if ( temp == seen_count ) { temp = output_buf_tds_dir ( next , fotg210 , hw , p . qh , size ) ; if ( seen_count < DBG_SCHED_LIMIT ) { seen [ seen_count ++ ] . qh = p . qh ; } } else { temp = 0 ; } tag = Q_NEXT_TYPE ( fotg210 , hw -> hw_next ) ; p = p . qh -> qh_next ; break ; case Q_TYPE_FSTN : temp = scnprintf ( next , size , " fstn-%8x/%p" , p . fstn -> hw_prev , p . fstn ) ; tag = Q_NEXT_TYPE ( fotg210 , p . fstn -> hw_next ) ; p = p . fstn -> fstn_next ; break ; case Q_TYPE_ITD : temp = scnprintf ( next , size , " itd/%p" , p . itd ) ; tag = Q_NEXT_TYPE ( fotg210 , p . itd -> hw_next ) ; p = p . itd -> itd_next ; break ; } size -= temp ; next += temp ; } p . ptr ; temp = scnprintf ( next , size , "\n" ) ; size -= temp ; next += temp ; } spin_unlock_irqrestore ( & fotg210 -> lock , flags ) ; kfree ( seen ) ; return buf -> alloc_size - size ; } 