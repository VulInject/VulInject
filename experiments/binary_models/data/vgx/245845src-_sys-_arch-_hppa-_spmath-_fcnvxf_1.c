int sgl_to_sgl_fcnvxf ( srcptr , null , dstptr , status ) int * srcptr , * null ; sgl_floating_point * dstptr ; unsigned int * status ; { register int src , dst_exponent ; register unsigned int result = 0 ; src = * srcptr ; if ( src < 0 ) { Sgl_setone_sign ( result ) ; Int_negate ( src ) ; } else { Sgl_setzero_sign ( result , NULL ) ; if ( src == 0 ) { Sgl_setzero ( result ) ; * dstptr = result ; return ( NOEXCEPTION ) ; } } dst_exponent = 16 ; Find_ms_one_bit ( src , dst_exponent ) ; if ( dst_exponent >= 0 ) { src <<= dst_exponent ; } else { src = 1 << 30 ; } Sgl_set_mantissa ( result , src >> ( SGL_EXP_LENGTH - 1 ) ) ; Sgl_set_exponent ( result , 30 + SGL_BIAS - dst_exponent ) ; if ( Int_isinexact_to_sgl ( src ) ) { switch ( Rounding_mode ( ) ) { case ROUNDPLUS : if ( Sgl_iszero_sign ( result ) ) { Sgl_increment ( result ) ; } break ; case ROUNDMINUS : if ( Sgl_isone_sign ( result ) ) { Sgl_increment ( result ) ; } break ; case ROUNDNEAREST : Sgl_roundnearest_from_int ( src , result ) ; } if ( Is_inexacttrap_enabled ( ) ) { * dstptr = result ; return ( INEXACTEXCEPTION ) ; } else { Set_inexactflag ( ) ; } } * dstptr = result ; return ( NOEXCEPTION ) ; } 