static struct se_wwn * efct_lio_npiv_make_nport ( struct target_fabric_configfs * tf , struct config_group * group , const char * name ) { struct efct_lio_vport * lio_vport ; struct efct * efct ; int ret ; u64 p_wwpn , npiv_wwpn , npiv_wwnn ; char * p , * pbuf , tmp [ 128 ] ; struct efct_lio_vport_list_t * vport_list ; struct fc_vport * new_fc_vport ; struct fc_vport_identifiers vport_id ; unsigned long flags = 0 ; snprintf ( tmp , sizeof ( tmp ) , "%s" , name ) ; pbuf = & tmp [ 0 ] ; p = strsep ( & pbuf , "@" ) ; if ( ! p || ! pbuf ) { pr_err ( "Unable to find separator operator(@)\n" ) ; return ERR_PTR ( - EINVAL ) ; } ret = efct_lio_parse_wwn ( p , & p_wwpn , 0 ) ; if ( ret ) { return ERR_PTR ( ret ) ; } ret = efct_lio_parse_npiv_wwn ( pbuf , strlen ( pbuf ) , & npiv_wwpn , & npiv_wwnn ) ; if ( ret ) { return ERR_PTR ( ret ) ; } efct = efct_find_wwpn ( p_wwpn ) ; if ( ! efct ) { pr_err ( "cannot find EFCT for base wwpn %s\n" , name ) ; return ERR_PTR ( - ENXIO ) ; } lio_vport = kzalloc ( sizeof ( * lio_vport ) , GFP_KERNEL ) ; if ( ! lio_vport ) { return ERR_PTR ( - ENOMEM ) ; } lio_vport -> efct = efct ; lio_vport -> wwpn = p_wwpn ; lio_vport -> npiv_wwpn = npiv_wwpn ; lio_vport -> npiv_wwnn = npiv_wwnn ; efct_format_wwn ( lio_vport -> wwpn_str , sizeof ( lio_vport -> wwpn_str ) , "naa." , npiv_wwpn ) ; vport_list = kzalloc ( sizeof ( * vport_list ) , GFP_KERNEL ) ; if ( ! vport_list ) { return ERR_PTR ( - ENOMEM ) ; } vport_list -> lio_vport = lio_vport ; memset ( & vport_id , 0 , sizeof ( vport_id ) ) ; vport_id . port_name = npiv_wwpn ; vport_id . node_name = npiv_wwnn ; vport_id . roles = FC_PORT_ROLE_FCP_INITIATOR ; vport_id . vport_type = FC_PORTTYPE_NPIV ; vport_id . disable = false ; new_fc_vport = fc_vport_create ( efct -> shost , 0 , & vport_id ) ; if ( ! new_fc_vport ) { efc_log_err ( efct , "fc_vport_create failed\n" ) ; kfree ( lio_vport ) ; kfree ( vport_list ) ; return ERR_PTR ( - ENOMEM ) ; } lio_vport -> fc_vport = new_fc_vport ; spin_lock_irqsave ( & efct -> tgt_efct . efct_lio_lock , flags ) ; INIT_LIST_HEAD ( & vport_list -> list_entry ) ; list_add_tail ( & vport_list -> list_entry , & efct -> tgt_efct . vport_list ) ; spin_unlock_irqrestore ( & efct -> tgt_efct . efct_lio_lock , flags ) ; return & lio_vport -> vport_wwn ; } 