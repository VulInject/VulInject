int _cupsRasterExecPS ( cups_page_header2_t * h , int * preferred_bits , const char * code ) { int error = 0 ; _cups_ps_stack_t * st ; _cups_ps_obj_t * obj ; char * codecopy , * codeptr ; DEBUG_printf ( ( "_cupsRasterExecPS(h=%p, preferred_bits=%p, code=\"%s\")\n" , h , preferred_bits , code ) ) ; if ( ( codecopy = strdup ( code ) ) == NULL ) { _cupsRasterAddError ( "Unable to duplicate code string.\n" ) ; return ( - 1 ) ; } if ( ( st = new_stack ( ) ) == NULL ) { _cupsRasterAddError ( "Unable to create stack.\n" ) ; return ( - 1 ) ; } codeptr = codecopy ; while ( ( obj = scan_ps ( st , & codeptr ) ) != NULL ) { DEBUG_printf ( ( "_cupsRasterExecPS: Stack (%d objects)" , st -> num_objs ) ) ; DEBUG_object ( "_cupsRasterExecPS" , obj ) ; switch ( obj -> type ) { default : break ; case CUPS_PS_CLEARTOMARK : pop_stack ( st ) ; if ( cleartomark_stack ( st ) ) { _cupsRasterAddError ( "cleartomark: Stack underflow.\n" ) ; } DEBUG_puts ( "1_cupsRasterExecPS:    dup" ) ; DEBUG_stack ( "_cupsRasterExecPS" , st ) ; break ; case CUPS_PS_COPY : pop_stack ( st ) ; if ( ( obj = pop_stack ( st ) ) != NULL ) { copy_stack ( st , ( int ) obj -> value . number ) ; DEBUG_puts ( "_cupsRasterExecPS: copy" ) ; DEBUG_stack ( "_cupsRasterExecPS" , st ) ; } break ; case CUPS_PS_DUP : pop_stack ( st ) ; copy_stack ( st , 1 ) ; DEBUG_puts ( "_cupsRasterExecPS: dup" ) ; DEBUG_stack ( "_cupsRasterExecPS" , st ) ; break ; case CUPS_PS_INDEX : pop_stack ( st ) ; if ( ( obj = pop_stack ( st ) ) != NULL ) { index_stack ( st , ( int ) obj -> value . number ) ; DEBUG_puts ( "_cupsRasterExecPS: index" ) ; DEBUG_stack ( "_cupsRasterExecPS" , st ) ; } break ; case CUPS_PS_POP : pop_stack ( st ) ; pop_stack ( st ) ; DEBUG_puts ( "_cupsRasterExecPS: pop" ) ; DEBUG_stack ( "_cupsRasterExecPS" , st ) ; break ; case CUPS_PS_ROLL : pop_stack ( st ) ; if ( ( obj = pop_stack ( st ) ) != NULL ) { int c ; c = ( int ) obj -> value . number ; if ( ( obj = pop_stack ( st ) ) != NULL ) { roll_stack ( st , ( int ) obj -> value . number , c ) ; DEBUG_puts ( "_cupsRasterExecPS: roll" ) ; DEBUG_stack ( "_cupsRasterExecPS" , st ) ; } } break ; case CUPS_PS_SETPAGEDEVICE : pop_stack ( st ) ; setpagedevice ( st , h , preferred_bits ) ; DEBUG_puts ( "_cupsRasterExecPS: setpagedevice" ) ; DEBUG_stack ( "_cupsRasterExecPS" , st ) ; break ; case CUPS_PS_START_PROC : case CUPS_PS_END_PROC : case CUPS_PS_STOPPED : pop_stack ( st ) ; break ; case CUPS_PS_OTHER : _cupsRasterAddError ( "Unknown operator \"%s\".\n" , obj -> value . other ) ; error = 1 ; DEBUG_printf ( ( "_cupsRasterExecPS: Unknown operator \"%s\"." , obj -> value . other ) ) ; break ; } if ( error ) { break ; } } free ( codecopy ) ; if ( st -> num_objs > 0 ) { error_stack ( st , "Stack not empty:" ) ; DEBUG_puts ( "_cupsRasterExecPS: Stack not empty" ) ; DEBUG_stack ( "_cupsRasterExecPS" , st ) ; delete_stack ( st ) ; return ( - 1 ) ; } delete_stack ( st ) ; return ( 0 ) ; } 