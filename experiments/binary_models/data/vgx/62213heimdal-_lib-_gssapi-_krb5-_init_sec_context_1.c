OM_uint32 GSSAPI_CALLCONV _gsskrb5_init_sec_context ( OM_uint32 * minor_status , gss_const_cred_id_t cred_handle , gss_ctx_id_t * context_handle , gss_const_name_t target_name , const gss_OID mech_type , OM_uint32 req_flags , OM_uint32 time_req , const gss_channel_bindings_t input_chan_bindings , const gss_buffer_t input_token , gss_OID * actual_mech_type , gss_buffer_t output_token , OM_uint32 * ret_flags , OM_uint32 * time_rec ) { krb5_context context ; gsskrb5_cred cred = ( gsskrb5_cred ) cred_handle ; gsskrb5_ctx ctx ; OM_uint32 ret ; GSSAPI_KRB5_INIT ( & context ) ; output_token -> length = 0 ; if ( context_handle == NULL ) { * minor_status = 0 ; return GSS_S_FAILURE | GSS_S_CALL_BAD_STRUCTURE ; } if ( ret_flags ) { * ret_flags = 0 ; } if ( time_rec ) { * time_rec = 0 ; } if ( target_name == GSS_C_NO_NAME ) { if ( actual_mech_type ) { * actual_mech_type = GSS_C_NO_OID ; } * minor_status = 0 ; return GSS_S_BAD_NAME ; } if ( mech_type != GSS_C_NO_OID && ! gss_oid_equal ( mech_type , GSS_KRB5_MECHANISM ) ) { return GSS_S_BAD_MECH ; } if ( input_token == GSS_C_NO_BUFFER || input_token -> length == 0 ) { OM_uint32 ret1 ; if ( * context_handle != GSS_C_NO_CONTEXT ) { * minor_status = 0 ; return GSS_S_FAILURE | GSS_S_CALL_BAD_STRUCTURE ; } ret1 = _gsskrb5_create_ctx ( minor_status , context_handle , context , input_chan_bindings , INITIATOR_START ) ; if ( ret1 ) { return ret1 ; } } if ( * context_handle == GSS_C_NO_CONTEXT ) { * minor_status = 0 ; return GSS_S_FAILURE | GSS_S_CALL_BAD_STRUCTURE ; } ctx = ( gsskrb5_ctx ) * context_handle ; HEIMDAL_MUTEX_lock ( & ctx -> ctx_id_mutex ) ; again switch ( ctx -> state ) { case INITIATOR_START : ret = init_auth ( minor_status , cred , ctx , context , target_name , mech_type , req_flags , time_req , input_token , actual_mech_type , output_token , ret_flags , time_rec ) ; if ( ret != GSS_S_COMPLETE ) { break ; } HEIM_FALLTHROUGH ; case INITIATOR_RESTART : ret = init_auth_restart ( minor_status , cred , ctx , context , req_flags , input_chan_bindings , input_token , actual_mech_type , output_token , ret_flags , time_rec ) ; break ; case INITIATOR_WAIT_FOR_MUTUAL : ret = repl_mutual ( minor_status , ctx , context , mech_type , req_flags , time_req , input_chan_bindings , input_token , actual_mech_type , output_token , ret_flags , time_rec ) ; if ( ctx -> state == INITIATOR_RESTART ) { again } break ; case INITIATOR_READY : _gsskrb5_set_status ( EINVAL , "init_sec_context " "called one time too many" ) ; * minor_status = EINVAL ; ret = GSS_S_BAD_STATUS ; break ; default : _gsskrb5_set_status ( EINVAL , "init_sec_context " "invalid state %d for client" , ( int ) ctx -> state ) ; * minor_status = EINVAL ; ret = GSS_S_BAD_STATUS ; break ; } HEIMDAL_MUTEX_unlock ( & ctx -> ctx_id_mutex ) ; if ( GSS_ERROR ( ret ) ) { OM_uint32 min2 ; _gsskrb5_delete_sec_context ( & min2 , context_handle , GSS_C_NO_BUFFER ) ; } return ret ; } 