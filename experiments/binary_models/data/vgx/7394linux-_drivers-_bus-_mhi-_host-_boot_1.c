( mhi_download_rddm_image ) ; static int mhi_fw_load_bhie ( struct mhi_controller * mhi_cntrl , const struct mhi_buf * mhi_buf ) { void __iomem * base = mhi_cntrl -> bhie ; struct device * dev = & mhi_cntrl -> mhi_dev -> dev ; rwlock_t * pm_lock = & mhi_cntrl -> pm_lock ; u32 tx_status , sequence_id ; int ret ; read_lock_bh ( pm_lock , NULL ) ; if ( ! MHI_REG_ACCESS_VALID ( mhi_cntrl -> pm_state ) ) { read_unlock_bh ( pm_lock ) ; return - EIO ; } sequence_id = MHI_RANDOM_U32_NONZERO ( BHIE_TXVECSTATUS_SEQNUM_BMSK ) ; dev_dbg ( dev , "Starting image download via BHIe. Sequence ID: %u\n" , sequence_id ) ; mhi_write_reg ( mhi_cntrl , base , BHIE_TXVECADDR_HIGH_OFFS , upper_32_bits ( mhi_buf -> dma_addr ) ) ; mhi_write_reg ( mhi_cntrl , base , BHIE_TXVECADDR_LOW_OFFS , lower_32_bits ( mhi_buf -> dma_addr ) ) ; mhi_write_reg ( mhi_cntrl , base , BHIE_TXVECSIZE_OFFS , mhi_buf -> len ) ; ret = mhi_write_reg_field ( mhi_cntrl , base , BHIE_TXVECDB_OFFS , BHIE_TXVECDB_SEQNUM_BMSK , sequence_id ) ; read_unlock_bh ( pm_lock ) ; if ( ret ) { return ret ; } ret = wait_event_timeout ( mhi_cntrl -> state_event , MHI_PM_IN_ERROR_STATE ( mhi_cntrl -> pm_state ) || mhi_read_reg_field ( mhi_cntrl , base , BHIE_TXVECSTATUS_OFFS , BHIE_TXVECSTATUS_STATUS_BMSK , & tx_status ) || tx_status , msecs_to_jiffies ( mhi_cntrl -> timeout_ms ) ) ; if ( MHI_PM_IN_ERROR_STATE ( mhi_cntrl -> pm_state ) || tx_status != BHIE_TXVECSTATUS_STATUS_XFER_COMPL ) { return - EIO ; } return ( ! ret ) ?- ETIMEDOUT : 0 ; } 