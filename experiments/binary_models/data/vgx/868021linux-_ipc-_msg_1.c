static int msgctl_stat ( struct ipc_namespace * ns , int msqid , int cmd , struct msqid64_ds * p ) { struct msg_queue * msq ; int err ; rcu_read_lock ( ) ; if ( cmd == MSG_STAT || cmd == MSG_STAT_ANY ) { msq = msq_obtain_object ( ns , msqid ) ; if ( IS_ERR ( msq ) ) { err = PTR_ERR ( msq ) ; out_unlock } } else { msq = msq_obtain_object_check ( ns , msqid ) ; if ( IS_ERR ( msq ) ) { err = PTR_ERR ( msq ) ; out_unlock } } if ( cmd == MSG_STAT_ANY ) { audit_ipc_obj ( & msq -> q_perm ) ; } else { err = - EACCES ; if ( ipcperms ( ns , & msq -> q_perm , S_IRUGO ) ) { out_unlock } } err = security_msg_queue_msgctl ( & msq -> q_perm , cmd ) ; if ( err ) { out_unlock } ipc_lock_object ( & msq -> q_perm ) ; if ( ! ipc_valid_object ( & msq -> q_perm ) ) { ipc_unlock_object ( & msq -> q_perm ) ; err = - EIDRM ; out_unlock } kernel_to_ipc64_perm ( & msq -> q_perm , & p -> msg_perm ) ; p -> msg_stime = msq -> q_stime ; p -> msg_rtime = msq -> q_rtime ; p -> msg_ctime = msq -> q_ctime ; p -> msg_stime_high = msq -> q_stime >> 32 ; p -> msg_rtime_high = msq -> q_rtime >> 32 ; p -> msg_ctime_high = msq -> q_ctime >> 32 ; p -> msg_cbytes = msq -> q_cbytes ; p -> msg_qnum = msq -> q_qnum ; p -> msg_qbytes = msq -> q_qbytes ; p -> msg_lspid = pid_vnr ( msq -> q_lspid ) ; p -> msg_lrpid = pid_vnr ( msq -> q_lrpid ) ; if ( cmd == IPC_STAT ) { err = 0 ; } else { err = msq -> q_perm . id ; } ipc_unlock_object ( & msq -> q_perm ) ; out_unlock rcu_read_unlock ( ) ; return err ; } 