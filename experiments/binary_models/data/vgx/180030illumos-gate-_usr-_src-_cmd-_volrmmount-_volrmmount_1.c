int main ( int argc , char * * argv ) { const char * opts = "ied" ; int c ; boolean_t opt_insert = B_FALSE ; boolean_t opt_eject = B_FALSE ; boolean_t opt_default = B_FALSE ; action_t action ; LibHalContext * hal_ctx ; DBusError error ; rmm_error_t rmm_error ; LibHalDrive * d ; GSList * volumes ; const char * default_name ; int ret = 0 ; while ( ( c = getopt ( argc , argv , opts ) ) != EOF ) { switch ( c ) { case 'i' : opt_insert = B_TRUE ; action = REMOUNT ; break ; case 'e' : opt_eject = B_TRUE ; action = UNMOUNT ; break ; case 'd' : opt_default = B_TRUE ; break ; default : usage ( ) ; return ( 1 ) ; } } if ( ( opt_insert && opt_eject ) || ( ! opt_insert && ! opt_eject && ! opt_default ) ) { usage ( ) ; return ( 1 ) ; } if ( ( hal_ctx = rmm_hal_init ( 0 , 0 , 0 , 0 , & error , & rmm_error ) ) == NULL ) { ( void ) fprintf ( stderr , gettext ( "HAL initialization failed: %s\n" ) , rmm_strerror ( & error , rmm_error ) ) ; rmm_dbus_error_free ( & error ) ; return ( 1 ) ; } if ( opt_default ) { if ( ( d = rmm_hal_volume_find_default ( hal_ctx , & error , & default_name , & volumes ) ) == NULL ) { default_name = "nothing inserted" ; } else { rmm_volumes_free ( volumes ) ; libhal_drive_free ( d ) ; } ( void ) printf ( gettext ( "Default device is: %s\n" ) , default_name ) ; } if ( optind == argc ) { if ( ( d = rmm_hal_volume_find_default ( hal_ctx , & error , & default_name , & volumes ) ) == NULL ) { ( void ) fprintf ( stderr , gettext ( "No default media available\n" ) ) ; } else { rmm_volumes_free ( volumes ) ; libhal_drive_free ( d ) ; if ( ! rmm_action ( hal_ctx , default_name , action , 0 , 0 , 0 , 0 ) ) { ret = 1 ; } } } else { for ( ; optind < argc ; optind ++ ) { if ( rmm_action ( hal_ctx , argv [ optind ] , action , 0 , 0 , 0 , 0 ) != 0 ) { ret = 1 ; } } } rmm_hal_fini ( hal_ctx ) ; return ( ret ) ; } 