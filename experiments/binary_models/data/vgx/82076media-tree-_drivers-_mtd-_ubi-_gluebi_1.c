static int gluebi_create ( struct ubi_device_info * di , struct ubi_volume_info * vi ) { struct gluebi_device * gluebi , * g ; struct mtd_info * mtd ; gluebi = kzalloc ( sizeof ( gluebi_device ) , GFP_KERNEL ) ; if ( ! gluebi ) { return - ENOMEM ; } mtd = & gluebi -> mtd ; mtd -> name = kmemdup ( vi -> name , vi -> name_len + 1 , GFP_KERNEL ) ; if ( ! mtd -> name ) { return - ENOMEM ; } gluebi -> vol_id = vi -> vol_id ; gluebi -> ubi_num = vi -> ubi_num ; mtd -> type = MTD_UBIVOLUME ; if ( ! di -> ro_mode ) { mtd -> flags = MTD_WRITEABLE ; } mtd -> owner = THIS_MODULE ; mtd -> writesize = di -> min_io_size ; mtd -> erasesize = vi -> usable_leb_size ; mtd -> _read = gluebi_read ; mtd -> _write = gluebi_write ; mtd -> _erase = gluebi_erase ; mtd -> _get_device = gluebi_get_device ; mtd -> _put_device = gluebi_put_device ; if ( vi -> vol_type == UBI_DYNAMIC_VOLUME ) { mtd -> size = ( unsigned long long ) vi -> usable_leb_size * vi -> size ; } else { mtd -> size = vi -> used_bytes ; } mutex_lock ( & devices_mutex ) ; g = find_gluebi_nolock ( vi -> ubi_num , vi -> vol_id ) ; if ( g ) { err_msg ( "gluebi MTD device %d form UBI device %d volume %d already exists" , g -> mtd . index , vi -> ubi_num , vi -> vol_id ) ; } mutex_unlock ( & devices_mutex ) ; if ( mtd_device_register ( mtd , NULL , 0 ) ) { err_msg ( "cannot add MTD device" ) ; kfree ( mtd -> name ) ; kfree ( gluebi ) ; return - ENFILE ; } mutex_lock ( & devices_mutex ) ; list_add_tail ( & gluebi -> list , & gluebi_devices ) ; mutex_unlock ( & devices_mutex ) ; return 0 ; } 