static int unpack_item_prefix_sid ( uint16_t mtid , uint8_t len , struct stream * s , struct sbuf * log , void * dest , int indent ) { struct isis_subtlvs * subtlvs = dest ; struct isis_prefix_sid sid = { } ; sbuf_push ( log , indent , "Unpacking SR Prefix-SID...\n" ) ; if ( len < 5 ) { sbuf_push ( log , indent , "Not enough data left. (expected 5 or more bytes, got %hhu)\n" , len ) ; return 1 ; } sid . flags = stream_getc ( s ) ; if ( ! ! ( sid . flags & ISIS_PREFIX_SID_VALUE ) != ! ! ( sid . flags & ISIS_PREFIX_SID_LOCAL ) ) { sbuf_push ( log , indent , "Flags implausible: Local Flag needs to match Value Flag\n" ) ; return 1 ; } sid . algorithm = stream_getc ( s , NULL ) ; uint8_t expected_size = ( sid . flags & ISIS_PREFIX_SID_VALUE ) ?ISIS_SUBTLV_PREFIX_SID_SIZE : ISIS_SUBTLV_PREFIX_SID_SIZE + 1 ; if ( len != expected_size ) { sbuf_push ( log , indent , "TLV size differs from expected size. (expected %u but got %hhu)\n" , expected_size , len ) ; return 1 ; } if ( sid . flags & ISIS_PREFIX_SID_VALUE ) { sid . value = stream_get3 ( s ) ; if ( ! IS_MPLS_UNRESERVED_LABEL ( sid . value ) ) { sbuf_push ( log , indent , "Invalid absolute SID %u\n" , sid . value ) ; return 1 ; } } else { sid . value = stream_getl ( s ) ; } format_item_prefix_sid ( mtid , ( isis_item * ) & sid , log , NULL , indent + 2 ) ; append_item ( & subtlvs -> prefix_sids , copy_item_prefix_sid ( ( isis_item * ) & sid ) ) ; return 0 ; } 