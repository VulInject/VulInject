int qla4xxx_about_firmware ( struct scsi_qla_host * ha ) { struct about_fw_info * about_fw = NULL ; dma_addr_t about_fw_dma ; uint32_t mbox_cmd [ MBOX_REG_COUNT ] ; uint32_t mbox_sts [ MBOX_REG_COUNT ] ; int status = QLA_ERROR ; about_fw = dma_alloc_coherent ( & ha -> pdev -> dev , sizeof ( about_fw_info ) , & about_fw_dma , GFP_KERNEL ) ; if ( ! about_fw ) { DEBUG2 ( ql4_printk ( KERN_ERR , ha , "%s: Unable to alloc memory " "for about_fw\n" , __func__ ) ) ; return status ; } memset ( & mbox_sts , 0 , sizeof ( mbox_sts ) ) ; mbox_cmd [ 0 ] = MBOX_CMD_ABOUT_FW ; mbox_cmd [ 2 ] = LSDW ( about_fw_dma ) ; mbox_cmd [ 3 ] = MSDW ( about_fw_dma ) ; mbox_cmd [ 4 ] = sizeof ( about_fw_info ) ; status = qla4xxx_mailbox_command ( ha , MBOX_REG_COUNT , MBOX_REG_COUNT , & mbox_cmd [ 0 ] , & mbox_sts [ 0 ] ) ; if ( status != QLA_SUCCESS ) { DEBUG2 ( ql4_printk ( KERN_WARNING , ha , "%s: MBOX_CMD_ABOUT_FW " "failed w/ status %04X\n" , __func__ , mbox_sts [ 0 ] ) ) ; exit_about_fw } ha -> fw_info . fw_major = le16_to_cpu ( about_fw -> fw_major ) ; ha -> fw_info . fw_minor = le16_to_cpu ( about_fw -> fw_minor ) ; ha -> fw_info . fw_patch = le16_to_cpu ( about_fw -> fw_patch ) ; ha -> fw_info . fw_build = le16_to_cpu ( about_fw -> fw_build ) ; memcpy ( ha -> fw_info . fw_build_date , about_fw -> fw_build_date , sizeof ( about_fw -> fw_build_date ) ) ; memcpy ( ha -> fw_info . fw_build_time , about_fw -> fw_build_time , sizeof ( about_fw -> fw_build_time ) ) ; strcpy ( ( char * ) ha -> fw_info . fw_build_user , skip_spaces ( ( char * ) about_fw -> fw_build_user ) ) ; ha -> fw_info . fw_load_source = le16_to_cpu ( about_fw -> fw_load_source ) ; ha -> fw_info . iscsi_major = le16_to_cpu ( about_fw -> iscsi_major ) ; ha -> fw_info . iscsi_minor = le16_to_cpu ( about_fw -> iscsi_minor ) ; ha -> fw_info . bootload_major = le16_to_cpu ( about_fw -> bootload_major ) ; ha -> fw_info . bootload_minor = le16_to_cpu ( about_fw -> bootload_minor ) ; ha -> fw_info . bootload_patch = le16_to_cpu ( about_fw -> bootload_patch ) ; ha -> fw_info . bootload_build = le16_to_cpu ( about_fw -> bootload_build ) ; strcpy ( ( char * ) ha -> fw_info . extended_timestamp , skip_spaces ( ( char * ) about_fw -> extended_timestamp ) ) ; ha -> fw_uptime_secs = le32_to_cpu ( mbox_sts [ 5 ] ) ; ha -> fw_uptime_msecs = le32_to_cpu ( mbox_sts [ 6 ] ) ; status = QLA_SUCCESS ; exit_about_fw dma_free_coherent ( & ha -> pdev -> dev , sizeof ( about_fw_info ) , about_fw , about_fw_dma ) ; return status ; } 