int EVP_DecryptUpdate ( EVP_CIPHER_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) { int fix_len ; unsigned int b ; * outl = 0 ; if ( inl < 0 ) { return 0 ; } if ( ctx -> cipher -> flags & EVP_CIPH_FLAG_CUSTOM_CIPHER ) { fix_len = ctx -> cipher -> do_cipher ( ctx , out , in , inl ) ; if ( fix_len < 0 ) { * outl = 0 ; return 0 ; } else { * outl = fix_len ; } return 1 ; } if ( ctx -> flags & EVP_CIPH_NO_PADDING ) { return EVP_EncryptUpdate ( ctx , out , outl , in , inl ) ; } b = ctx -> cipher -> block_size ; if ( b > sizeof ctx -> final ) { EVPerror ( EVP_R_BAD_BLOCK_LENGTH ) ; return 0 ; } if ( ctx -> final_used ) { if ( ( inl & ~ ( b - 1 ) ) > INT_MAX - b ) { EVPerror ( EVP_R_TOO_LARGE ) ; return 0 ; } memcpy ( out , ctx -> final , b ) ; out += b ; fix_len = 1 ; } else { fix_len = 0 ; } if ( ! EVP_EncryptUpdate ( ctx , out , outl , in , inl ) ) { return 0 ; } if ( b > 1 && ! ctx -> buf_len ) { * outl -= b ; ctx -> final_used = 1 ; memcpy ( ctx -> final , & out [ * outl ] , b ) ; } else { ctx -> final_used = 0 ; } if ( fix_len ) { * outl += b ; } return 1 ; } 