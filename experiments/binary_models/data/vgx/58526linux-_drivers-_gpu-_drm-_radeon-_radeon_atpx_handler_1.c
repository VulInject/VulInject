static int radeon_atpx_validate ( struct radeon_atpx * atpx ) { u32 valid_bits = 0 ; if ( atpx -> functions . px_params ) { union acpi_object * info ; struct atpx_px_params output ; size_t size ; info = radeon_atpx_call ( atpx -> handle , ATPX_FUNCTION_GET_PX_PARAMETERS , NULL ) ; if ( ! info ) { return - EIO ; } memset ( & output , 0 , sizeof ( output ) ) ; size = * ( u16 * ) info -> buffer . pointer ; if ( size < 10 ) { printk ( "ATPX buffer is too small: %zu\n" , size ) ; return - EINVAL ; } size = min ( sizeof ( output ) , size ) ; memcpy ( & output , info -> buffer . pointer , size ) ; valid_bits = output . flags & output . valid_flags ; kfree ( info ) ; } if ( valid_bits & ATPX_SEPARATE_MUX_FOR_I2C ) { atpx -> functions . i2c_mux_cntl = true ; atpx -> functions . disp_mux_cntl = true ; } if ( valid_bits & ( ATPX_CRT1_RGB_SIGNAL_MUXED | ATPX_TV_SIGNAL_MUXED | ATPX_DFP_SIGNAL_MUXED ) ) { atpx -> functions . disp_mux_cntl = true ; } if ( valid_bits & ( ATPX_DYNAMIC_PX_SUPPORTED | ATPX_DYNAMIC_DGPU_POWER_OFF_SUPPORTED ) ) { atpx -> functions . power_cntl = true ; } atpx -> is_hybrid = false ; if ( valid_bits & ATPX_MS_HYBRID_GFX_SUPPORTED ) { printk ( "ATPX Hybrid Graphics\n" ) ; atpx -> functions . power_cntl = ! radeon_atpx_priv . bridge_pm_usable ; atpx -> is_hybrid = true ; } return 0 ; } 