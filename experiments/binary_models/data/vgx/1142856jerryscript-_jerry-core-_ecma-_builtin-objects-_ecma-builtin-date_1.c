ecma_builtin_date_parse_toString_formats ( , ) { const ecma_number_t nan = ecma_number_make_nan ( ) ; const bool is_toUTCString_format = ecma_date_parse_special_char ( & date_str_curr_p , date_str_end_p , LIT_CHAR_COMMA ) ; if ( ! ecma_date_parse_special_char ( & date_str_curr_p , date_str_end_p , LIT_CHAR_SP ) ) { return nan ; } ecma_number_t month = 0 ; ecma_number_t day = 0 ; if ( is_toUTCString_format ) { day = ecma_date_parse_date_chars ( & date_str_curr_p , date_str_end_p , 2 , ECMA_DATE_LIMIT ( 0 , 31 ) ) ; if ( ecma_number_is_nan ( day ) ) { return nan ; } if ( ! ecma_date_parse_special_char ( & date_str_curr_p , date_str_end_p , LIT_CHAR_SP ) ) { return nan ; } month = ecma_date_parse_month_name ( & date_str_curr_p , date_str_end_p ) ; if ( month == 0 ) { return ecma_number_make_nan ( ) ; } } else { month = ecma_date_parse_month_name ( & date_str_curr_p , date_str_end_p ) ; if ( month == 0 ) { return nan ; } if ( ! ecma_date_parse_special_char ( & date_str_curr_p , date_str_end_p , LIT_CHAR_SP ) ) { return nan ; } day = ecma_date_parse_date_chars ( & date_str_curr_p , date_str_end_p , 2 , ECMA_DATE_LIMIT ( 0 , 31 ) ) ; if ( ecma_number_is_nan ( day ) ) { return nan ; } } if ( ! ecma_date_parse_special_char ( & date_str_curr_p , date_str_end_p , LIT_CHAR_SP ) ) { return nan ; } ecma_number_t year = ecma_date_parse_year ( & date_str_curr_p , date_str_end_p ) ; if ( ecma_number_is_nan ( year ) ) { return nan ; } if ( ! ecma_date_parse_special_char ( & date_str_curr_p , date_str_end_p , LIT_CHAR_SP ) ) { return nan ; } ecma_number_t hours = ecma_date_parse_date_chars ( & date_str_curr_p , date_str_end_p , 2 , ECMA_DATE_LIMIT ( 0 , 24 ) ) ; if ( ecma_number_is_nan ( hours ) ) { return nan ; } if ( ! ecma_date_parse_special_char ( & date_str_curr_p , date_str_end_p , LIT_CHAR_COLON ) ) { return nan ; } ecma_number_t minutes = ecma_date_parse_date_chars ( & date_str_curr_p , date_str_end_p , 2 , ECMA_DATE_LIMIT ( 0 , 59 ) ) ; if ( ecma_number_is_nan ( minutes ) ) { return nan ; } if ( ! ecma_date_parse_special_char ( & date_str_curr_p , date_str_end_p , LIT_CHAR_COLON ) ) { return nan ; } ecma_number_t seconds = ecma_date_parse_date_chars ( & date_str_curr_p , date_str_end_p , 2 , ECMA_DATE_LIMIT ( 0 , 59 ) ) ; if ( ecma_number_is_nan ( seconds ) ) { return nan ; } if ( hours == 24 && ( minutes != 0 || seconds != 0 ) ) { return nan ; } const char gmt_p [ ] " GMT" ; ; if ( date_str_end_p - date_str_curr_p < 4 || memcmp ( date_str_curr_p , gmt_p , 4 ) != 0 ) { return nan ; } date_str_curr_p += 4 ; ecma_number_t time = ecma_date_make_time ( hours , minutes , seconds , 0 ) ; if ( ! is_toUTCString_format ) { if ( ! ecma_date_check_two_chars ( date_str_curr_p , date_str_end_p , LIT_CHAR_MINUS , LIT_CHAR_PLUS ) ) { return nan ; } bool is_timezone_sign_negative = ( * date_str_curr_p ++ == LIT_CHAR_MINUS ) ; hours = ecma_date_parse_date_chars ( & date_str_curr_p , date_str_end_p , 2 , ECMA_DATE_LIMIT ( 0 , 24 ) ) ; if ( ecma_number_is_nan ( hours ) ) { return nan ; } if ( hours == 24 ) { hours = ECMA_NUMBER_ZERO ; } minutes = ecma_date_parse_date_chars ( & date_str_curr_p , date_str_end_p , 2 , ECMA_DATE_LIMIT ( 0 , 59 ) ) ; if ( ecma_number_is_nan ( minutes ) ) { return nan ; } ecma_number_t timezone_offset = ecma_date_make_time ( hours , minutes , ECMA_NUMBER_ZERO , ECMA_NUMBER_ZERO ) ; time += is_timezone_sign_negative ?timezone_offset : - timezone_offset ; } if ( date_str_curr_p < date_str_end_p ) { return nan ; } ecma_number_t date = ecma_date_make_day ( year , month - 1 , day ) ; return ecma_date_make_date ( date , time ) ; } 