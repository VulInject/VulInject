static int textmod ( register Vi_t * vp , register int c , int mode ) { register int i ; register genchar * p = vp -> lastline ; register int trepeat = vp -> repeat ; genchar * savep ; if ( mode && ( fold ( vp -> lastmotion ) == 'F' || fold ( vp -> lastmotion ) == 'T' ) ) { vp -> lastmotion = ';' ; } if ( fold ( c ) == 'P' ) { p = yankbuf ; } addin switch ( c ) { case '\t' : if ( vp -> ed -> e_tabcount != 1 ) { return ( BAD ) ; } c = '=' ; case '*' : case '\\' : case '=' : save_v ( vp ) ; i = last_virt ; ++ last_virt ; mode = cur_virt - 1 ; virtual [ last_virt ] = 0 ; if ( ed_expand ( vp -> ed , ( char * ) virtual , & cur_virt , & last_virt , c , vp -> repeat_set ?vp -> repeat : - 1 ) < 0 ) { if ( vp -> ed -> e_tabcount ) { vp -> ed -> e_tabcount = 2 ; ed_ungetchar ( vp -> ed , '\t' ) ; -- last_virt ; return ( APPEND ) ; } last_virt = i ; ed_ringbell ( ) ; } if ( ( c == '=' || ( c == '\\' && virtual [ i ] == '/' ) ) && ! vp -> repeat_set ) { last_virt = i ; vp -> nonewline ++ ; ed_ungetchar ( vp -> ed , cntl ( 'L' ) ) ; return ( GOOD ) ; } else { -- cur_virt ; -- last_virt ; vp -> ocur_virt = MAXCHAR ; if ( c == '=' || ( mode < cur_virt && ( virtual [ cur_virt ] == ' ' || virtual [ cur_virt ] == '/' ) ) ) { vp -> ed -> e_tabcount = 0 ; } return ( APPEND ) ; } break ; case '@' : if ( mode ) { c = vp -> lastmacro ; } if ( ( c = getrchar ( vp ) ) == ESC ) { return ( GOOD ) ; } if ( ! inmacro ) { vp -> lastmacro = c ; } if ( ed_macro ( vp -> ed , c ) ) { save_v ( vp ) ; inmacro ++ ; return ( GOOD ) ; } ed_ringbell ( ) ; return ( BAD ) ; case '_' : save_v ( vp ) ; { genchar tmpbuf [ MAXLINE ] ; if ( vp -> repeat_set == 0 ) { vp -> repeat = - 1 ; } p = ( genchar * ) hist_word ( ( char * ) tmpbuf , MAXLINE , vp -> repeat ) ; if ( p == 0 ) { ed_ringbell ( ) ; break ; } ed_internal ( ( char * ) p , tmpbuf ) ; p = tmpbuf ; i = ' ' ; { append ( vp , i , APPEND ) ; } i = * p ++ ; return ( APPEND ) ; } case 'A' : cur_virt = last_virt ; sync_cursor ( vp ) ; case 'a' : if ( fold ( mode ) == 'A' ) { c = 'p' ; addin } save_v ( vp ) ; if ( cur_virt != INVALID ) { first_virt = cur_virt + 1 ; cursor ( vp , cur_phys + 1 ) ; ed_flush ( vp -> ed ) ; } return ( APPEND ) ; case 'I' : cur_virt = first_virt ; sync_cursor ( vp ) ; case 'i' : if ( fold ( mode ) == 'I' ) { c = 'P' ; addin } save_v ( vp ) ; if ( cur_virt != INVALID ) { vp -> o_v_char = virtual [ cur_virt ] ; first_virt = cur_virt -- ; } return ( INSERT ) ; case 'C' : c = '$' ; chgeol case 'c' : if ( mode ) { c = vp -> lastmotion ; } else { c = getcount ( vp , ed_getchar ( vp -> ed , - 1 ) ) ; } chgeol vp -> lastmotion = c ; if ( c == 'c' ) { del_line ( vp , GOOD ) ; return ( APPEND ) ; } if ( ! delmotion ( vp , c , 'c' ) ) { return ( BAD ) ; } if ( mode == 'c' ) { c = 'p' ; trepeat = 1 ; addin } first_virt = cur_virt + 1 ; return ( APPEND ) ; case 'D' : c = '$' ; deleol case 'd' : if ( mode ) { c = vp -> lastmotion ; } else { c = getcount ( vp , ed_getchar ( vp -> ed , - 1 ) ) ; } deleol vp -> lastmotion = c ; if ( c == 'd' ) { del_line ( vp , GOOD ) ; break ; } if ( ! delmotion ( vp , c , 'd' ) ) { return ( BAD ) ; } if ( cur_virt < last_virt ) { ++ cur_virt ; } break ; case 'P' : if ( p [ 0 ] == '\0' ) { return ( BAD ) ; } if ( cur_virt != INVALID ) { i = virtual [ cur_virt ] ; if ( ! is_print ( i ) ) { vp -> ocur_virt = INVALID ; } -- cur_virt ; } case 'p' : if ( p [ 0 ] == '\0' ) { return ( BAD ) ; } if ( mode != 's' && mode != 'c' ) { save_v ( vp ) ; if ( c == 'P' ) { ++ vp -> u_column ; } } if ( mode == 'R' ) { mode = REPLACE ; } else { mode = APPEND ; } savep = p ; for ( i = 0 ; i < trepeat ; ++ i ) { while ( c = * p ++ ) { append ( vp , c , mode ) ; } p = savep ; } break ; case 'R' : if ( mode == 'R' ) { c = 'P' ; addin } save_v ( vp ) ; if ( cur_virt != INVALID ) { first_virt = cur_virt ; } return ( REPLACE ) ; case 'r' : if ( mode ) { c = * p ; } if ( ( c = getrchar ( vp ) ) == ESC ) { return ( GOOD ) ; } * p = c ; save_v ( vp ) ; while ( trepeat -- ) { replace ( vp , c , trepeat != 0 ) ; } return ( GOOD ) ; case 'S' : c = 'c' ; chgeol case 's' : save_v ( vp ) ; cdelete ( vp , vp -> repeat , BAD ) ; if ( mode ) { c = 'p' ; trepeat = 1 ; addin } first_virt = cur_virt + 1 ; return ( APPEND ) ; case 'Y' : c = '$' ; yankeol case 'y' : if ( mode ) { c = vp -> lastmotion ; } else { c = getcount ( vp , ed_getchar ( vp -> ed , - 1 ) ) ; } yankeol vp -> lastmotion = c ; if ( c == 'y' ) { gencpy ( yankbuf , virtual ) ; } if ( ! delmotion ( vp , c , 'y' ) ) { return ( BAD ) ; } break ; case 'x' : c = 'l' ; deleol case 'X' : c = 'h' ; deleol case '~' : if ( cur_virt != INVALID ) { save_v ( vp ) ; i = INVALID ; while ( trepeat -- > 0 && i != cur_virt ) { i = cur_virt ; c = virtual [ cur_virt ] ; if ( ( c & ~ STRIP ) == 0 ) { if ( isupper ( c ) ) { c = tolower ( c ) ; } if ( islower ( c ) ) { c = toupper ( c ) ; } } replace ( vp , c , 1 ) ; } return ( GOOD ) ; } else { return ( BAD ) ; } default : return ( BAD ) ; } refresh ( vp , CONTROL ) ; return ( GOOD ) ; } 