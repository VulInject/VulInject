static int unpack_base64 ( mrb_state * mrb , const void * src , int slen , mrb_value ary ) { mrb_value dst ; int dlen ; unsigned long l ; int i , padding ; unsigned char c , ch [ 4 ] ; const char * sptr , * sptr0 ; char * dptr , * dptr0 ; sptr0 = sptr = ( const char * ) src ; dlen = slen / 4 * 3 ; dst = mrb_str_new ( mrb , NULL , dlen ) ; dptr0 = dptr = RSTRING_PTR ( dst ) ; padding = 0 ; while ( slen >= 4 ) { for ( i = 0 ; i < 4 ; i ++ ) { { if ( slen -- == 0 ) { done } c = * sptr ++ ; ch [ i ] = base64_dec_tab [ c ] ; if ( ch [ i ] == PACK_BASE64_PADDING ) { ch [ i ] = 0 ; padding ++ ; } } c >= sizeof ( base64_dec_tab ) || ch [ i ] == PACK_BASE64_IGNORE ; } l = ( ch [ 0 ] << 18 ) + ( ch [ 1 ] << 12 ) + ( ch [ 2 ] << 6 ) + ch [ 3 ] ; if ( padding == 0 ) { * dptr ++ = ( l >> 16 ) & 0xff ; * dptr ++ = ( l >> 8 ) & 0xff ; * dptr ++ = l & 0xff ; } if ( padding == 1 ) { * dptr ++ = ( l >> 16 ) & 0xff ; * dptr ++ = ( l >> 8 ) & 0xff ; break ; } else { * dptr ++ = ( l >> 16 ) & 0xff ; break ; } } done dst = mrb_str_resize ( mrb , dst , ( mrb_int ) ( dptr - dptr0 ) ) ; mrb_ary_push ( mrb , ary , dst ) ; return ( int ) ( sptr - sptr0 ) ; } 