int crypto_verify_init_prov ( crypto_provider_t provider , crypto_session_id_t sid , crypto_mechanism_t * mech , crypto_key_t * key , crypto_ctx_template_t tmpl , crypto_context_t * ctxp , crypto_call_req_t * crq ) { int rv ; crypto_ctx_t * ctx ; kcf_req_params_t params ; kcf_provider_desc_t * pd = provider ; kcf_provider_desc_t * real_provider = pd ; ASSERT ( KCF_PROV_REFHELD ( pd ) ) ; if ( pd -> pd_prov_type == CRYPTO_LOGICAL_PROVIDER ) { rv = kcf_get_hardware_provider ( mech -> cm_type , key , CRYPTO_MECH_INVALID , NULL , pd , & real_provider , CRYPTO_FG_VERIFY ) ; } if ( ( ctx = kcf_new_ctx ( crq , real_provider , sid ) ) == NULL ) { if ( pd -> pd_prov_type == CRYPTO_LOGICAL_PROVIDER ) { KCF_PROV_REFRELE ( real_provider ) ; } return ( CRYPTO_HOST_MEMORY ) ; } KCF_WRAP_VERIFY_OPS_PARAMS ( & params , KCF_OP_INIT , sid , mech , key , NULL , NULL , tmpl ) ; rv = kcf_submit_request ( real_provider , ctx , crq , & params , B_FALSE ) ; if ( pd -> pd_prov_type == CRYPTO_LOGICAL_PROVIDER ) { KCF_PROV_REFRELE ( real_provider ) ; } if ( ( rv == CRYPTO_SUCCESS ) || ( rv == CRYPTO_QUEUED ) ) { * ctxp = ( crypto_context_t ) ctx ; } else { KCF_CONTEXT_REFRELE ( ( kcf_context_t * ) ctx -> cc_framework_private ) ; } return ( rv ) ; } 