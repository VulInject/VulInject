void schd_print_fairaccess ( void ) { char * id = "print_fairacl" ; FairAccessList * FALptr ; AccessEntry * AEptr ; if ( schd_FairACL ) { sprintf ( log_buffer , "FAIR_ACCESS: ARCH Directives:" ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; sprintf ( log_buffer , "  %-17s %-8s %8s" , "Arch:GroupID" , "Max:CPUs" , "Memory" ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; for ( FALptr = schd_FairACL ; FALptr != NULL ; FALptr = FALptr -> next ) { for ( AEptr = FALptr -> entry ; AEptr != NULL ; AEptr = AEptr -> next ) { if ( AEptr -> name ) { sprintf ( log_buffer , "  %-17s %6.0d %s" , AEptr -> name , AEptr -> max_cpu , schd_byte2val ( AEptr -> max_mem ) ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , id , log_buffer ) ; } } } } } int job_exceeds_accesslimits ( Job * job , char * queue_arch , size_t arch_mem , int arch_cpu ) { FairAccessList * FALptr ; AccessEntry * AEptr ; int default_cpu = 0 , default_mem = 0 ; char search_name [ MAX_TXT ] ; if ( job -> arch ) { sprintf ( search_name , "%s:%s" , job -> arch , job -> group ) ; } else { if ( queue_arch ) { sprintf ( search_name , "%s:%s" , queue_arch , job -> group ) ; } else { return ( 1 ) ; } } for ( FALptr = schd_FairACL ; FALptr != NULL ; FALptr = FALptr -> next ) { for ( AEptr = FALptr -> entry ; AEptr != NULL ; AEptr = AEptr -> next ) { if ( AEptr -> name ) { if ( ! strcmp ( AEptr -> name , search_name ) ) { if ( arch_mem + job -> memory > AEptr -> max_mem ) { return ( 3 ) ; } else { return ( 0 ) ; } } } } } if ( job -> arch ) { sprintf ( search_name , "%s:default" , job -> arch ) ; } else { if ( queue_arch ) { sprintf ( search_name , "%s:default" , queue_arch ) ; } } for ( FALptr = schd_FairACL ; FALptr != NULL ; FALptr = FALptr -> next ) { for ( AEptr = FALptr -> entry ; AEptr != NULL ; AEptr = AEptr -> next ) { if ( AEptr -> name ) { if ( ! strcmp ( AEptr -> name , search_name ) ) { if ( arch_cpu + job -> ncpus > AEptr -> max_cpu ) { return ( 2 ) ; } if ( arch_mem + job -> memory > AEptr -> max_mem ) { return ( 3 ) ; } else { return ( 0 ) ; } } } } } return ( 1 ) ; } 