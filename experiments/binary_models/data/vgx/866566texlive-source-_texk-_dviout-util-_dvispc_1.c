put_num write_n ( a2i ( get_next ( base ) ) , sub_number ) ; break ; case XXX1 : s = get_next ( base , NULL ) ; num = a2i ( s ) ; s = get_next ( s ) + 1 ; if ( f_dtl & DTL_EXACT ) { len = StrLen ( s ) ; if ( num != len ) { fprintf ( stderr , "string length in %d:[%s]: %d ->%d\n" , line , tmp_buf , num , len ) ; } num0 = ( len < 0x100 ) ?1 : 2 ; if ( sub_number != num0 ) { fprintf ( stderr , "Code is changed at line %d: xxx%d ->xxx%d\n" , line , sub_number , num0 ) ; } sub_number = num0 ; } else { len = num ; } putc ( code + sub_number - 1 , fp_out ) ; write_n ( len , sub_number ) ; strout case EOFNC : putc ( code , fp_out ) ; sub_number = 1 ; put_num case W0 : case X0 : case Y0 : case Z0 : putc ( code + sub_number , fp_out ) ; if ( sub_number ) { put_num } break ; case SET_RULE : case PUT_RULE : putc ( code , fp_out ) ; s = get_next ( base ) ; write_n ( a2i ( s ) , 4 ) ; s = get_next ( s ) ; write_n ( a2i ( s ) , 4 ) ; break ; case POST : if ( f_in ) { fprintf ( stderr , "Need EOP before POST\n" ) ; err } if ( f_proc > 1 ) { fprintf ( stderr , "Multiple POST\n" ) ; err } f_proc = 2 ; pos0 = ftell ( fp_out ) ; putc ( code , fp_out ) ; s = get_next ( base ) ; if ( f_debug ) { num0 = a2i ( s ) ; if ( pos != num0 ) { fprintf ( stderr , "Address of BOP of the last page: %d ->%d\n" , num0 , pos ) ; } } write_n ( pos , 4 ) ; pos = pos0 ; s = get_next ( s ) ; for ( num = 5 ; num -- > 0 ; ) { write_n ( a2i ( s ) , 4 ) ; s = get_next ( s ) ; } num0 = a2i ( s ) ; if ( max_stack != num0 ) { fprintf ( stderr , "Max stack depth: %d ->%d\n" , num0 , max_stack ) ; } write_n ( max_stack , 2 ) ; s = get_next ( s ) ; num0 = a2i ( s ) ; if ( num0 != -- page ) { fprintf ( stderr , "The number of total pages: %d ->%d\n" , num0 , page ) ; } write_n ( page , 2 ) ; break ; case FNT_DEF_1 : s = get_next ( base ) ; num0 = a2i ( s ) ; if ( f_dtl & DTL_FNTDFN ) { if ( num0 >= 0 && num0 < MAX_FONT ) { if ( f_proc == 2 ) { if ( ! font_use [ num0 ] ) { fprintf ( stderr , "The definition of font %d is deleted\n" , num0 ) ; break ; } else { font_use [ num0 ] = 1 ; } } } } putc ( code + sub_number - 1 , fp_out ) ; write_n ( num0 , sub_number ) ; s = get_next ( s ) ; for ( num = 0 ; num < 3 ; num ++ ) { if ( ( f_dtl & DTL_FNTDEF ) && ! num && ( s [ 1 ] != 'x' && s [ 1 ] != 'X' ) ) { num0 = * ( s - 1 ) ; * ( s - 1 ) = '0' ; write_n ( a2i ( s - 1 ) , 4 ) ; * ( s - 1 ) = ( uchar ) num0 ; } else { write_n ( a2i ( s ) , 4 ) ; } s = get_next ( s ) ; } num = a2i ( s ) ; s = get_next ( s ) ; putc ( num , fp_out ) ; code = a2i ( s ) ; s = get_next ( s ) + 1 ; putc ( code , fp_out ) ; while ( num -- > 0 ) { putc ( * s ++ , fp_out ) ; } if ( ( * s == '\'' && s [ 1 ] <= ' ' ) || ( f_dtl & DTL_FNTNAME ) ) { s = get_next ( s ) + 1 ; } while ( code -- > 0 ) { putc ( * s ++ , fp_out ) ; } break ; case POST_POST : if ( f_proc ++ != 2 ) { fprintf ( stderr , "Need POST before POST_POST!\n" ) ; err } putc ( code , fp_out ) ; s = get_next ( base ) ; write_n ( pos , 4 ) ; if ( f_debug ) { num0 = a2i ( s ) ; if ( pos != num0 ) { fprintf ( stderr , "Address of POST: %d ->%d\n" , num0 , pos ) ; } } for ( num = 5 ; num -- > 0 ; ) { s = get_next ( s ) ; code = a2i ( s ) ; if ( num == 4 ) { if ( code != 2 && code != 3 ) { fprintf ( stderr , "Last id (%d) should be 2 or 3\n" , code ) ; err } } else { if ( code != END_DVI ) { fprintf ( stderr , "Last code: %d ->%d\n" , code , END_DVI ) ; } code = END_DVI ; } putc ( code , fp_out ) ; } num = ftell ( fp_out ) ; while ( num ++ & 3 ) { putc ( ( uchar ) END_DVI , fp_out ) ; } break ; case OPCODE : putc ( a2i ( get_next ( s ) ) , fp_out ) ; break ; case NOP : putc ( code , fp_out ) ; break ; default : err fprintf ( stderr , "Error(line %d, code %d): %s\n" , line , code , tmp_buf ) ; Exit ( 1 ) ; num = ftell ( fp_out ) ; fprintf ( stderr , "Write %d byte (%d page): %s\n" , num , page , ( fp_out == stdout ) ?"(stdout)" : outfile ) ; fclose ( fp_in ) ; fclose ( fp_out ) ; fp_in = fp_out = NULL ; 