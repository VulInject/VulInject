int ice_add_fdir_ethtool ( struct ice_vsi * vsi , struct ethtool_rxnfc * cmd ) { struct ice_rx_flow_userdef userdata ; struct ethtool_rx_flow_spec * fsp ; struct ice_fdir_fltr * input ; struct device * dev ; struct ice_pf * pf ; struct ice_hw * hw ; int fltrs_needed ; u16 tunnel_port ; int ret ; pf = vsi -> back ; hw = & pf -> hw ; dev = ice_pf_to_dev ( pf ) ; if ( ! test_bit ( ICE_FLAG_FD_ENA , pf -> flags ) ) { return - EOPNOTSUPP ; } if ( ice_is_reset_in_progress ( pf -> state ) ) { dev_err ( dev , "Device is resetting - adding Flow Director filters not supported during reset\n" ) ; return - EBUSY ; } fsp = ( ethtool_rx_flow_spec * ) & cmd -> fs ; if ( ice_parse_rx_flow_user_data ( fsp , & userdata ) ) { return - EINVAL ; } if ( fsp -> flow_type & FLOW_MAC_EXT ) { return - EINVAL ; } ret = ice_cfg_fdir_xtrct_seq ( pf , fsp , & userdata ) ; if ( ret ) { return ret ; } if ( fsp -> location >= ice_get_fdir_cnt_all ( hw ) ) { dev_err ( dev , "Failed to add filter.  The maximum number of flow director filters has been reached.\n" ) ; return - ENOSPC ; } fltrs_needed = ice_get_open_tunnel_port ( hw , & tunnel_port , TNL_ALL ) ?2 : 1 ; if ( ! ice_fdir_find_fltr_by_idx ( hw , fsp -> location ) && ice_fdir_num_avail_fltr ( hw , pf -> vsi [ vsi -> idx ] ) < fltrs_needed ) { dev_err ( dev , "Failed to add filter.  The maximum number of flow director filters has been reached.\n" ) ; return - ENOSPC ; } input = devm_kzalloc ( dev , sizeof ( * input ) , GFP_KERNEL ) ; if ( ! input ) { return - ENOMEM ; } ret = ice_set_fdir_input_set ( vsi , fsp , input ) ; if ( ret ) { free_input } mutex_lock ( & hw -> fdir_fltr_lock ) ; if ( ice_fdir_is_dup_fltr ( hw , input ) ) { ret = - EINVAL ; release_lock } if ( userdata . flex_fltr ) { input -> flex_fltr = true ; input -> flex_word = cpu_to_be16 ( userdata . flex_word ) ; input -> flex_offset = userdata . flex_offset ; } input -> cnt_ena = ICE_FXD_FLTR_QW0_STAT_ENA_PKTS ; input -> fdid_prio = ICE_FXD_FLTR_QW1_FDID_PRI_THREE ; input -> comp_report = ICE_FXD_FLTR_QW0_COMP_REPORT_SW_FAIL ; ice_fdir_update_list_entry ( pf , input , fsp -> location ) ; ret = ice_fdir_write_all_fltr ( pf , input , true ) ; if ( ret ) { remove_sw_rule } release_lock remove_sw_rule ice_fdir_update_cntrs ( hw , input -> flow_type , false ) ; ice_update_per_q_fltr ( vsi , input -> orig_q_index , false ) ; list_del ( & input -> fltr_node ) ; release_lock mutex_unlock ( & hw -> fdir_fltr_lock ) ; free_input if ( ret ) { devm_kfree ( dev , input ) ; } return ret ; } 