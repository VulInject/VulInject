static int write_vmem ( struct fbtft_par * par , size_t offset , size_t len ) { u8 * vmem8 = ( u8 * ) ( par -> info -> screen_buffer ) ; u8 * buf8 = par -> txbuf . buf ; u16 * buf16 = par -> txbuf . buf ; int line_length = par -> info -> fix . line_length ; int y_start = ( offset / line_length ) ; int y_end = ( offset + len - 1 ) / line_length ; int x , y , i ; int ret ; switch ( par -> pdata -> display . buswidth ) { case 8 : switch ( par -> info -> var . rotate ) { case 90 : case 270 : i = y_start * line_length ; for ( y = y_start ; y <= y_end ; y ++ ) { for ( x = 0 ; x < line_length ; x += 2 ) { * buf8 = vmem8 [ i ] >> 4 ; * buf8 |= vmem8 [ i + 1 ] & 0xF0 ; buf8 ++ ; i += 2 ; } } break ; default : y_start &= 0xFE ; i = y_start * line_length ; for ( y = y_start ; y <= y_end ; y += 2 ) { for ( x = 0 ; x < line_length ; x ++ ) { * buf8 = vmem8 [ i ] >> 4 ; * buf8 |= vmem8 [ i + line_length ] & 0xF0 ; buf8 ++ ; i ++ ; } i += line_length ; } break ; } gpio_set_value ( par -> gpio . dc , 1 ) ; ret = par -> fbtftops . write ( par , par -> txbuf . buf , len / 2 ) ; break ; case 9 : switch ( par -> info -> var . rotate ) { case 90 : case 270 : i = y_start * line_length ; for ( y = y_start ; y <= y_end ; y ++ ) { for ( x = 0 ; x < line_length ; x += 2 ) { * buf16 = 0x100 ; * buf16 |= vmem8 [ i ] >> 4 ; * buf16 |= vmem8 [ i + 1 ] & 0xF0 ; buf16 ++ ; i += 2 ; } } break ; default : y_start &= 0xFE ; i = y_start * line_length ; for ( y = y_start ; y <= y_end ; y += 2 ) { for ( x = 0 ; x < line_length ; x ++ ) { * buf16 = 0x100 ; * buf16 |= vmem8 [ i ] >> 4 ; * buf16 |= vmem8 [ i + line_length ] & 0xF0 ; buf16 ++ ; i ++ ; } i += line_length ; } break ; } ret = par -> fbtftops . write ( par , par -> txbuf . buf , len ) ; break ; default : dev_err ( par -> info -> device , "unsupported buswidth %d\n" , par -> pdata -> display . buswidth ) ; } if ( ret < 0 ) { dev_err ( par -> info -> device , "write failed and returned: %d\n" , ret ) ; } return ret ; } 