int iperf_sctp_bindx ( struct iperf_test * test , int s , int is_server ) { struct addrinfo hints ; char portstr [ 6 ] ; char * servname ; struct addrinfo * ai , * ai0 ; struct sockaddr * xaddrs ; struct xbind_entry * xbe , * xbe0 ; char * bp ; size_t xaddrlen ; int nxaddrs ; int retval ; int domain ; int saved_errno ; domain = test -> settings -> domain ; xbe0 = NULL ; retval = 0 ; memset ( & hints , 0 , sizeof ( hints ) ) ; hints . ai_family = ( domain == AF_UNSPEC ?AF_INET6 : domain ) ; hints . ai_socktype = SOCK_STREAM ; servname = NULL ; if ( is_server ) { hints . ai_flags |= AI_PASSIVE ; snprintf ( portstr , 6 , "%d" , test -> server_port ) ; servname = portstr ; } if ( ! is_server ) { struct sockaddr * sa ; struct sockaddr_in * sin ; struct sockaddr_in6 * sin6 ; int eport ; xbe0 = TAILQ_FIRST ( & test -> xbind_addrs ) ; TAILQ_REMOVE ( & test -> xbind_addrs , xbe0 , link ) ; if ( ( gerror = getaddrinfo ( xbe0 -> name , servname , & hints , & xbe0 -> ai ) ) != 0 ) { i_errno = IESETSCTPBINDX ; retval = - 1 ; out } ai = xbe0 -> ai ; if ( domain != AF_UNSPEC && domain != ai -> ai_family ) { i_errno = IESETSCTPBINDX ; retval = - 1 ; out } if ( bind ( s , ( sockaddr * ) ai -> ai_addr , ai -> ai_addrlen ) < 0 ) { i_errno = IESETSCTPBINDX ; retval = - 1 ; out } if ( TAILQ_EMPTY ( & test -> xbind_addrs ) ) { out } sa = ( sockaddr * ) ai -> ai_addr ; if ( sa -> sa_family == AF_INET ) { sin = ( sockaddr_in * ) ai -> ai_addr ; eport = sin -> sin_port ; } if ( sa -> sa_family == AF_INET6 ) { sin6 = ( sockaddr_in6 * ) ai -> ai_addr ; eport = sin6 -> sin6_port ; } else { i_errno = IESETSCTPBINDX ; retval = - 1 ; out } snprintf ( portstr , 6 , "%d" , ntohs ( eport ) ) ; servname = portstr ; } nxaddrs = 0 ; xaddrlen = 0 ; TAILQ_FOREACH ( , , ) { if ( xbe -> ai != NULL ) { freeaddrinfo ( xbe -> ai ) ; } if ( ( gerror = getaddrinfo ( xbe -> name , servname , & hints , & xbe -> ai ) ) != 0 ) { i_errno = IESETSCTPBINDX ; retval = - 1 ; out } ai0 = xbe -> ai ; for ( ai = ai0 ; ai ; ai = ai -> ai_next ) { if ( domain != AF_UNSPEC && domain != ai -> ai_family ) { continue ; } xaddrlen += ai -> ai_addrlen ; ++ nxaddrs ; } } xaddrs = ( sockaddr * ) malloc ( xaddrlen ) ; if ( ! xaddrs ) { i_errno = IESETSCTPBINDX ; retval = - 1 ; out } bp = ( char * ) xaddrs ; TAILQ_FOREACH ( , , ) { ai0 = xbe -> ai ; for ( ai = ai0 ; ai ; ai = ai -> ai_next ) { if ( domain != AF_UNSPEC && domain != ai -> ai_family ) { continue ; } memcpy ( bp , ai -> ai_addr , ai -> ai_addrlen ) ; bp += ai -> ai_addrlen ; } } if ( sctp_bindx ( s , xaddrs , nxaddrs , SCTP_BINDX_ADD_ADDR ) == - 1 ) { saved_errno = errno ; close ( s ) ; free ( xaddrs ) ; errno = saved_errno ; i_errno = IESETSCTPBINDX ; retval = - 1 ; out } free ( xaddrs ) ; retval = 0 ; out if ( ! is_server && xbe0 ) { TAILQ_INSERT_HEAD ( & test -> xbind_addrs , xbe0 , link ) ; } TAILQ_FOREACH ( , , ) { if ( xbe -> ai ) { freeaddrinfo ( xbe -> ai ) ; xbe -> ai = NULL ; } } return retval ; i_errno = IENOSCTP ; return - 1 ; } 