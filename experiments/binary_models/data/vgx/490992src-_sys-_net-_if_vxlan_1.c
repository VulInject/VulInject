static struct VAR1 * FUN1 ( void * VAR2 , struct VAR1 * VAR3 , struct VAR4 * VAR4 , struct VAR5 * VAR6 , void * VAR7 , int VAR8 ) { struct VAR9 * VAR10 = VAR2 ; union vxlan_addr VAR11 ; struct vxlan_peer VAR12 , * VAR13 ; struct VAR14 * VAR15 ; struct VAR16 * VAR17 ; struct VAR18 * VAR19 ; int VAR20 = VAR8 + sizeof ( * VAR17 ) ; struct VAR1 * VAR21 ; int VAR22 ; in_port_t VAR23 ; struct VAR24 * VAR25 = NULL ; struct VAR26 * VAR27 ; int VAR28 ; uint8_t VAR29 ; if ( VAR3 -> VAR30 . VAR31 < VAR20 ) { VAR32 } VAR15 = VAR7 ; VAR23 = VAR15 -> VAR33 ; if ( VAR4 != NULL ) { memset ( & VAR11 , 0 , sizeof ( VAR11 ) ) ; VAR11 . VAR34 = VAR4 -> VAR35 ; VAR29 = VAR4 -> VAR36 ; } else { VAR11 . VAR37 = VAR6 -> VAR38 ; VAR29 = FUN2 ( & VAR6 -> VAR39 ) >> 20 ; } if ( VAR3 -> VAR40 < VAR20 ) { VAR3 = FUN3 ( VAR3 , VAR20 ) ; } VAR17 = ( VAR16 * ) ( FUN4 ( VAR3 , VAR41 ) + VAR8 ) ; memset ( & VAR12 , 0 , sizeof ( VAR12 ) ) ; VAR12 . VAR42 = VAR11 ; VAR12 . VAR43 . VAR44 = VAR17 -> VAR44 & FUN5 ( VAR45 ) ; VAR12 . VAR43 . VAR46 = VAR17 -> VAR46 & FUN5 ( VAR47 ) ; FUN6 ( & VAR10 -> VAR48 ) ; VAR13 = FUN7 ( VAR49 , & VAR10 -> VAR50 , & VAR12 ) ; if ( VAR13 == NULL ) { memset ( & VAR12 . VAR42 , 0 , sizeof ( VAR12 . VAR42 ) ) ; VAR13 = FUN7 ( VAR49 , & VAR10 -> VAR50 , & VAR12 ) ; } if ( VAR13 != NULL ) { VAR25 = FUN8 ( VAR13 -> VAR51 ) ; } FUN9 ( & VAR10 -> VAR48 ) ; if ( VAR25 == NULL ) { VAR32 } VAR27 = & VAR25 -> VAR52 . VAR53 ; if ( FUN10 ( VAR27 -> VAR54 , VAR55 ) && VAR23 != VAR25 -> VAR56 ) { VAR57 } FUN11 ( VAR3 , VAR20 ) ; if ( VAR3 -> VAR30 . VAR31 < sizeof ( * VAR19 ) ) { VAR57 } if ( VAR3 -> VAR40 < sizeof ( * VAR19 ) ) { VAR3 = FUN3 ( VAR3 , sizeof ( * VAR19 ) ) ; if ( VAR3 == NULL ) { VAR58 } } VAR21 = FUN12 ( VAR3 , sizeof ( * VAR19 ) , & VAR22 ) ; if ( VAR21 == NULL ) { VAR57 } if ( ! FUN13 ( FUN4 ( VAR21 , VAR41 ) + VAR22 , VAR59 ) ) { VAR21 = FUN14 ( VAR3 , VAR60 , VAR61 ) ; FUN15 ( VAR3 ) ; if ( VAR21 == NULL ) { VAR58 } VAR3 = VAR21 ; } if ( VAR25 -> VAR62 == VAR63 ) { VAR19 = FUN4 ( VAR3 , VAR18 * ) ; FUN16 ( & VAR25 -> VAR64 , & VAR11 , ( VAR65 * ) VAR19 -> VAR66 ) ; } VAR28 = VAR25 -> VAR67 ; switch ( VAR28 ) { case VAR68 : break ; case VAR69 : VAR3 -> VAR30 . VAR70 . VAR71 = FUN17 ( VAR29 ) ; break ; default : VAR3 -> VAR30 . VAR70 . VAR71 = VAR28 ; break ; } FUN18 ( VAR27 , VAR3 ) ; rele FUN19 ( VAR25 ) ; return ( NULL ) ; rele_drop FUN19 ( VAR25 ) ; drop FUN15 ( VAR3 ) ; return ( NULL ) ; }