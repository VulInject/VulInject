boolean_t process_prop_set ( dladm_handle_t handle __unused , prop_db_state_t * lsp , char * buf , prop_db_info_t * listp , dladm_status_t * statusp ) { dladm_status_t status ; prop_db_info_t * lastp = NULL , * lip = listp , * nlip = NULL ; prop_val_t * * lvpp ; int i ; if ( lsp -> ls_propname == NULL ) { buf [ 0 ] = '\0' ; return ( B_FALSE ) ; } for ( ; lip != NULL ; lip = lip -> li_nextprop ) { if ( strcmp ( lip -> li_name , lsp -> ls_propname ) == 0 ) { break ; } lastp = lip ; } if ( lip == NULL ) { if ( ( nlip = malloc ( sizeof ( prop_db_info_t ) ) ) == NULL ) { status = DLADM_STATUS_NOMEM ; fail } if ( lastp != NULL ) { lastp -> li_nextprop = nlip ; } nlip -> li_name = lsp -> ls_propname ; nlip -> li_nextprop = NULL ; nlip -> li_val = NULL ; lvpp = & nlip -> li_val ; } else { prop_val_t * lvp , * lvp_next ; for ( lvp = lip -> li_val ; lvp != NULL ; lvp = lvp_next ) { lvp_next = lvp -> lv_nextval ; } lip -> li_val = NULL ; lvpp = & lip -> li_val ; } for ( i = 0 ; i < * lsp -> ls_valcntp ; i ++ ) { if ( ( * lvpp = malloc ( sizeof ( prop_val_t ) ) ) == NULL ) { status = DLADM_STATUS_NOMEM ; fail } ( * lvpp ) -> lv_name = lsp -> ls_propval [ i ] ; ( * lvpp ) -> lv_nextval = NULL ; lvpp = & ( * lvpp ) -> lv_nextval ; } if ( listp != NULL ) { generate_prop_line ( lsp -> ls_name , buf , listp , statusp ) ; } else { generate_prop_line ( lsp -> ls_name , buf , nlip , statusp ) ; free_props ( nlip ) ; } return ( B_FALSE ) ; fail * statusp = status ; if ( listp == NULL ) { free_props ( nlip ) ; } return ( B_FALSE ) ; } 