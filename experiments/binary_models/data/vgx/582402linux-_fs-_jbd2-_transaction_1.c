static int journal_unmap_buffer ( journal_t * journal , struct buffer_head * bh , int partial_page ) { transaction_t * transaction ; struct journal_head * jh ; int may_free = 1 ; BUFFER_TRACE ( bh , "entry" ) ; jh = jbd2_journal_grab_journal_head ( bh ) ; if ( ! jh ) { zap_buffer_unlocked } write_lock ( & journal -> j_state_lock ) ; spin_lock ( & jh -> b_state_lock ) ; spin_lock ( & journal -> j_list_lock ) ; transaction = jh -> b_transaction ; if ( transaction == NULL ) { if ( ! jh -> b_cp_transaction ) { JBUFFER_TRACE ( jh , "not on any transaction: zap" ) ; zap_buffer } if ( ! buffer_dirty ( bh ) ) { __jbd2_journal_remove_checkpoint ( jh ) ; zap_buffer } if ( journal -> j_running_transaction ) { JBUFFER_TRACE ( jh , "checkpointed: add to BJ_Forget" ) ; may_free = __dispose_buffer ( jh , journal -> j_running_transaction ) ; zap_buffer } else { if ( journal -> j_committing_transaction ) { JBUFFER_TRACE ( jh , "give to committing trans" ) ; may_free = __dispose_buffer ( jh , journal -> j_committing_transaction ) ; zap_buffer } else { clear_buffer_jbddirty ( bh ) ; __jbd2_journal_remove_checkpoint ( jh ) ; zap_buffer } } } if ( transaction == journal -> j_committing_transaction ) { JBUFFER_TRACE ( jh , "on committing transaction" ) ; if ( partial_page ) { spin_unlock ( & journal -> j_list_lock ) ; spin_unlock ( & jh -> b_state_lock ) ; write_unlock ( & journal -> j_state_lock ) ; jbd2_journal_put_journal_head ( jh , NULL ) ; return - EBUSY ; } set_buffer_freed ( bh ) ; if ( journal -> j_running_transaction && buffer_jbddirty ( bh ) ) { jh -> b_next_transaction = journal -> j_running_transaction ; } jh -> b_modified = 0 ; spin_unlock ( & journal -> j_list_lock ) ; spin_unlock ( & jh -> b_state_lock ) ; write_unlock ( & journal -> j_state_lock ) ; jbd2_journal_put_journal_head ( jh ) ; return 0 ; } else { J_ASSERT_JH ( jh , transaction == journal -> j_running_transaction ) ; JBUFFER_TRACE ( jh , "on running transaction" ) ; may_free = __dispose_buffer ( jh , transaction ) ; } zap_buffer jh -> b_modified = 0 ; spin_unlock ( & journal -> j_list_lock ) ; spin_unlock ( & jh -> b_state_lock ) ; write_unlock ( & journal -> j_state_lock ) ; jbd2_journal_put_journal_head ( jh ) ; zap_buffer_unlocked clear_buffer_dirty ( bh ) ; J_ASSERT_BH ( bh , ! buffer_jbddirty ( bh ) ) ; clear_buffer_mapped ( bh ) ; clear_buffer_req ( bh ) ; clear_buffer_new ( bh ) ; clear_buffer_delay ( bh ) ; clear_buffer_unwritten ( bh ) ; bh -> b_bdev = NULL ; return may_free ; } 