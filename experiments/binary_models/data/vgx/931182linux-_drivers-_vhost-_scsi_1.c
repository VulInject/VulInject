static int vhost_scsi_open ( struct inode * inode , struct file * f ) { struct vhost_scsi * vs ; struct vhost_virtqueue * * vqs ; int r = - ENOMEM , i , nvqs = vhost_scsi_max_io_vqs ; vs = kvzalloc ( sizeof ( * vs ) , GFP_KERNEL ) ; if ( ! vs ) { err_vs } if ( nvqs > VHOST_SCSI_MAX_IO_VQ ) { pr_err ( "Invalid max_io_vqs of %d. Using %d.\n" , nvqs , VHOST_SCSI_MAX_IO_VQ ) ; nvqs = VHOST_SCSI_MAX_IO_VQ ; } if ( nvqs == 0 ) { pr_err ( "Invalid max_io_vqs of %d. Using 1.\n" , nvqs ) ; nvqs = 1 ; } nvqs += VHOST_SCSI_VQ_IO ; vs -> compl_bitmap = bitmap_alloc ( nvqs , GFP_KERNEL ) ; if ( ! vs -> compl_bitmap ) { err_compl_bitmap } vs -> old_inflight = kmalloc_array ( nvqs , sizeof ( * vs -> old_inflight ) , GFP_KERNEL | __GFP_ZERO ) ; if ( ! vs -> old_inflight ) { err_inflight } vs -> vqs = kmalloc_array ( nvqs , sizeof ( * vs -> vqs ) , GFP_KERNEL | __GFP_ZERO ) ; if ( ! vs -> vqs ) { err_vqs } vqs = kmalloc_array ( nvqs , sizeof ( * vqs ) , GFP_KERNEL ) ; if ( ! vqs ) { err_local_vqs } vhost_work_init ( & vs -> vs_completion_work , vhost_scsi_complete_cmd_work ) ; vhost_work_init ( & vs -> vs_event_work , vhost_scsi_evt_work ) ; vs -> vs_events_nr = 0 ; vs -> vs_events_missed = false ; vqs [ VHOST_SCSI_VQ_CTL ] = & vs -> vqs [ VHOST_SCSI_VQ_CTL ] . vq ; vqs [ VHOST_SCSI_VQ_EVT ] = & vs -> vqs [ VHOST_SCSI_VQ_EVT ] . vq ; vs -> vqs [ VHOST_SCSI_VQ_CTL ] . vq . handle_kick = vhost_scsi_ctl_handle_kick ; vs -> vqs [ VHOST_SCSI_VQ_EVT ] . vq . handle_kick = vhost_scsi_evt_handle_kick ; for ( i = VHOST_SCSI_VQ_IO ; i < nvqs ; i ++ ) { vqs [ i ] = & vs -> vqs [ i ] . vq ; vs -> vqs [ i ] . vq . handle_kick = vhost_scsi_handle_kick ; } vhost_dev_init ( & vs -> dev , vqs , nvqs , UIO_MAXIOV , VHOST_SCSI_WEIGHT , 0 , true , NULL ) ; vhost_scsi_init_inflight ( vs , NULL ) ; f -> private_data = vs ; return 0 ; err_local_vqs kfree ( vs -> vqs ) ; err_vqs err_inflight bitmap_free ( vs -> compl_bitmap ) ; err_compl_bitmap kvfree ( vs ) ; err_vs return r ; } 