static void cuse_process_init_reply ( struct fuse_mount * fm , struct fuse_args * args , int error ) { struct fuse_conn * fc = fm -> fc ; struct cuse_init_args * ia = container_of ( args , typeof ( * ia ) , ap . args ) ; struct fuse_args_pages * ap = & ia -> ap ; struct cuse_conn * cc = fc_to_cc ( fc ) , * pos ; struct cuse_init_out * arg = & ia -> out ; struct page * page = ap -> pages [ 0 ] ; struct cuse_devinfo devinfo = { } ; struct device * dev ; struct cdev * cdev ; dev_t devt ; int rc , i ; if ( error || arg -> major != FUSE_KERNEL_VERSION || arg -> minor < 11 ) { err } fc -> minor = arg -> minor ; fc -> max_read = max_t ( unsigned , arg -> max_read , 4096 ) ; fc -> max_write = max_t ( unsigned , arg -> max_write , 4096 ) ; cc -> unrestricted_ioctl = arg -> flags & CUSE_UNRESTRICTED_IOCTL ; rc = cuse_parse_devinfo ( page_address ( page ) , ap -> args . out_args [ 1 ] . size , & devinfo ) ; if ( rc ) { err } devt = MKDEV ( arg -> dev_major , arg -> dev_minor ) ; if ( ! MAJOR ( devt ) ) { rc = alloc_chrdev_region ( & devt , MINOR ( devt ) , 1 , devinfo . name ) ; } else { rc = register_chrdev_region ( devt , 1 , devinfo . name ) ; } if ( rc ) { pr_err ( "failed to register chrdev region\n" ) ; err } rc = - ENOMEM ; dev = kmalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) { err_region } device_initialize ( dev ) ; dev_set_uevent_suppress ( dev , 1 ) ; dev -> class = cuse_class ; dev -> devt = devt ; dev -> release = cuse_gendev_release ; dev_set_drvdata ( dev , cc ) ; dev_set_name ( dev , "%s" , devinfo . name ) ; mutex_lock ( & cuse_lock ) ; for ( i = 0 ; i < CUSE_CONNTBL_LEN ; ++ i ) { list_for_each_entry ( , , ) if ( ! strcmp ( dev_name ( pos -> dev ) , dev_name ( dev ) ) ) { err_unlock } } rc = device_add ( dev ) ; if ( rc ) { err_unlock } rc = - ENOMEM ; cdev = cdev_alloc ( ) ; if ( ! cdev ) { err_unlock } cdev -> owner = THIS_MODULE ; cdev -> ops = & cuse_frontend_fops ; rc = cdev_add ( cdev , devt , 1 ) ; if ( rc ) { err_cdev } cc -> dev = dev ; cc -> cdev = cdev ; list_add ( & cc -> list , cuse_conntbl_head ( devt ) ) ; mutex_unlock ( & cuse_lock ) ; dev_set_uevent_suppress ( dev , 0 ) ; kobject_uevent ( & dev -> kobj , KOBJ_ADD ) ; out kfree ( ia ) ; __free_page ( page ) ; return ; err_cdev cdev_del ( cdev ) ; err_unlock mutex_unlock ( & cuse_lock ) ; put_device ( dev ) ; err_region unregister_chrdev_region ( devt , 1 ) ; err fuse_abort_conn ( fc ) ; out } 