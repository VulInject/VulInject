rpmRC rpmtsImportPubkey ( const rpmts ts , const unsigned char * pkt , size_t pktlen ) { Header h = NULL ; rpmRC rc = RPMRC_FAIL ; char * lints ; rpmPubkey pubkey = NULL ; rpmPubkey * subkeys = NULL ; int subkeysCount = 0 ; rpmVSFlags oflags = rpmtsVSFlags ( ts ) ; rpmKeyring keyring = NULL ; rpmtxn txn = rpmtxnBegin ( ts , RPMTXN_WRITE ) ; int krc , i ; if ( txn == NULL ) { return rc ; } krc = pgpPubKeyLint ( pkt , pktlen , & lints ) ; if ( lints ) { if ( krc != RPMRC_OK ) { rpmlog ( RPMLOG_ERR , "%s\n" , lints ) ; } else { if ( rpmIsNormal ( ) ) { rpmlog ( RPMLOG_WARNING , "%s\n" , lints ) ; } } free ( lints ) ; } if ( krc != RPMRC_OK ) { rc = krc ; exit } rpmtsSetVSFlags ( ts , ( oflags & ~ RPMVSF_MASK_NOSIGNATURES ) ) ; keyring = rpmtsGetKeyring ( ts , 1 ) ; rpmtsSetVSFlags ( ts , oflags ) ; if ( ( pubkey = rpmPubkeyNew ( pkt , pktlen ) ) == NULL ) { exit } if ( ( subkeys = rpmGetSubkeys ( pubkey , & subkeysCount ) ) == NULL ) { exit } krc = rpmKeyringAddKey ( keyring , pubkey ) ; if ( krc < 0 ) { exit } if ( krc == 0 ) { rpm_tid_t tid = rpmtsGetTid ( ts ) ; if ( makePubkeyHeader ( ts , pubkey , subkeys , subkeysCount , & h ) != 0 ) { exit } headerPutUint32 ( h , RPMTAG_INSTALLTIME , & tid , 1 ) ; headerPutUint32 ( h , RPMTAG_INSTALLTID , & tid , 1 ) ; if ( ! ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_TEST ) ) { if ( ts -> keyringtype == KEYRING_FS ) { rc = rpmtsImportFSKey ( txn , h , 0 ) ; } else { rc = rpmtsImportHeader ( txn , h , 0 ) ; } } } rc = RPMRC_OK ; exit headerFree ( h ) ; rpmPubkeyFree ( pubkey ) ; for ( i = 0 ; i < subkeysCount ; i ++ ) { rpmPubkeyFree ( subkeys [ i ] ) ; } free ( subkeys ) ; rpmKeyringFree ( keyring ) ; rpmtxnEnd ( txn ) ; return rc ; } 