static int qxl_update_area_ioctl ( struct drm_device * dev , void * data , struct drm_file * file ) { struct qxl_device * qdev = dev -> dev_private ; struct drm_qxl_update_area * update_area = data ; struct qxl_rect area = { . left = update_area -> left . top = update_area -> top . right = update_area -> right . bottom = update_area -> bottom } ; int ret ; struct drm_gem_object * gobj = NULL ; struct qxl_bo * qobj = NULL ; if ( update_area -> left >= update_area -> right || update_area -> top >= update_area -> bottom ) { return - EINVAL ; } gobj = drm_gem_object_lookup ( file , update_area -> handle ) ; if ( gobj == NULL ) { return - ENOENT ; } qobj = gem_to_qxl_bo ( gobj ) ; ret = qxl_bo_reserve ( qobj , false ) ; if ( ret ) { out } if ( ! qobj -> pin_count ) { qxl_ttm_placement_from_domain ( qobj , qobj -> type , false ) ; ret = ttm_bo_validate ( & qobj -> tbo , & qobj -> placement , true , false ) ; if ( unlikely ( ret ) ) { out } } ret = qxl_bo_check_id ( qdev , qobj ) ; if ( ret ) { out2 } if ( ! qobj -> surface_id ) { DRM_ERROR ( "got update area for surface with no id %d\n" , update_area -> handle ) ; } ret = qxl_io_update_area ( qdev , qobj , & area ) ; out2 qxl_bo_unreserve ( qobj , NULL ) ; out drm_gem_object_unreference_unlocked ( gobj ) ; return ret ; } 