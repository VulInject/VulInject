int octcrypto_authenc_hmac ( struct cryptop * crp , struct cryptodesc * crde , struct cryptodesc * crda , struct octcrypto_session * ses ) { int icb [ ndwords ( AESCTR_BLOCKSIZE ) ] ; uint64_t iv [ ndwords ( EALG_MAX_BLOCK_LEN ) ] ; uint64_t tag [ ndwords ( AALG_MAX_RESULT_LEN ) ] ; struct octcrypto_cpu * pcpu = & ses -> ses_sc -> sc_cpu [ cpu_number ( ) ] ; uint8_t * buf , * authbuf , * encbuf ; size_t authlen ; size_t buflen ; size_t len ; size_t skip ; off_t authskip = 0 ; off_t encskip = 0 ; int error = 0 ; int ivlen ; if ( crde != NULL && crda != NULL ) { skip = MIN ( crde -> crd_skip , crda -> crd_skip ) ; len = MAX ( crde -> crd_skip + crde -> crd_len , crda -> crd_skip + crda -> crd_len ) - skip ; if ( crda -> crd_skip < crde -> crd_skip ) { encskip = crde -> crd_skip - crda -> crd_skip ; } else { authskip = crda -> crd_skip - crde -> crd_skip ; } } if ( crde != NULL ) { skip = crde -> crd_skip ; len = crde -> crd_len ; } else { KASSERT ( crda != NULL ) ; skip = crda -> crd_skip ; len = crda -> crd_len ; } buflen = len ; if ( crda != NULL && ( crda -> crd_flags & CRD_F_ESN ) != 0 ) { buflen += 4 ; } buflen = roundup ( buflen , EALG_MAX_BLOCK_LEN ) ; if ( buflen > pcpu -> pcpu_buflen ) { if ( pcpu -> pcpu_buf != NULL ) { explicit_bzero ( pcpu -> pcpu_buf , pcpu -> pcpu_buflen ) ; free ( pcpu -> pcpu_buf , M_DEVBUF , pcpu -> pcpu_buflen ) ; } pcpu -> pcpu_buflen = 0 ; pcpu -> pcpu_buf = malloc ( buflen , M_DEVBUF , M_NOWAIT | M_ZERO ) ; if ( pcpu -> pcpu_buf == NULL ) { return ENOMEM ; } pcpu -> pcpu_buflen = buflen ; } buf = pcpu -> pcpu_buf ; authbuf = buf + authskip ; encbuf = buf + encskip ; if ( crde != NULL ) { ivlen = ( crde -> crd_alg == CRYPTO_AES_CBC ) ?16 : 8 ; if ( crde -> crd_flags & CRD_F_ENCRYPT ) { if ( crde -> crd_flags & CRD_F_IV_EXPLICIT ) { memcpy ( iv , crde -> crd_iv , ivlen ) ; } else { arc4random_buf ( iv , ivlen ) ; } if ( ( crde -> crd_flags & CRD_F_IV_PRESENT ) == 0 ) { if ( crp -> crp_flags & CRYPTO_F_IMBUF ) { if ( m_copyback ( ( mbuf * ) crp -> crp_buf , crde -> crd_inject , ivlen , iv , M_NOWAIT ) ) { error = ENOMEM ; out } } else { cuio_copyback ( ( uio * ) crp -> crp_buf , crde -> crd_inject , ivlen , iv ) ; } } } else { if ( crde -> crd_flags & CRD_F_IV_EXPLICIT ) { memcpy ( iv , crde -> crd_iv , ivlen ) ; } else { if ( crp -> crp_flags & CRYPTO_F_IMBUF ) { m_copydata ( ( mbuf * ) crp -> crp_buf , crde -> crd_inject , ivlen , iv ) ; } else { cuio_copydata ( ( uio * ) crp -> crp_buf , crde -> crd_inject , ivlen , ( uint8_t * ) iv ) ; } } } } if ( crp -> crp_flags & CRYPTO_F_IMBUF ) { m_copydata ( ( mbuf * ) crp -> crp_buf , skip , len , buf ) ; } else { cuio_copydata ( ( uio * ) crp -> crp_buf , skip , len , buf ) ; } if ( crda != NULL ) { authlen = crda -> crd_len ; if ( crda -> crd_flags & CRD_F_ESN ) { memcpy ( buf + len , crda -> crd_esn , 4 ) ; authlen += 4 ; } } if ( crde != NULL ) { if ( crda != NULL && ( crde -> crd_flags & CRD_F_ENCRYPT ) == 0 ) { octcrypto_hmac ( crda , authbuf , authlen , ses , tag ) ; } switch ( crde -> crd_alg ) { case CRYPTO_AES_CBC : cop2_enable ( ) ; octcrypto_aes_set_key ( ses -> ses_key , ses -> ses_klen ) ; if ( crde -> crd_flags & CRD_F_ENCRYPT ) { octcrypto_aes_cbc_enc ( encbuf , crde -> crd_len , iv ) ; } else { octcrypto_aes_cbc_dec ( encbuf , crde -> crd_len , iv ) ; } octcrypto_aes_clear ( ) ; cop2_disable ( ) ; break ; case CRYPTO_AES_CTR : memset ( icb , 0 , sizeof ( icb ) ) ; memcpy ( icb , ses -> ses_nonce , AESCTR_NONCESIZE ) ; memcpy ( ( uint8_t * ) icb + AESCTR_NONCESIZE , iv , AESCTR_IVSIZE ) ; cop2_enable ( ) ; octcrypto_aes_set_key ( ses -> ses_key , ses -> ses_klen ) ; octcrypto_aes_ctr_enc ( encbuf , crde -> crd_len , icb ) ; octcrypto_aes_clear ( ) ; cop2_disable ( ) ; explicit_bzero ( icb , sizeof ( icb ) ) ; break ; } if ( crp -> crp_flags & CRYPTO_F_IMBUF ) { if ( m_copyback ( ( mbuf * ) crp -> crp_buf , crde -> crd_skip , crde -> crd_len , encbuf , M_NOWAIT ) ) { error = ENOMEM ; out } } else { cuio_copyback ( ( uio * ) crp -> crp_buf , crde -> crd_skip , crde -> crd_len , encbuf ) ; } } if ( crda != NULL ) { if ( crde == NULL || ( crde -> crd_flags & CRD_F_ENCRYPT ) != 0 ) { octcrypto_hmac ( crda , authbuf , authlen , ses , tag ) ; } if ( crp -> crp_flags & CRYPTO_F_IMBUF ) { if ( m_copyback ( ( mbuf * ) crp -> crp_buf , crda -> crd_inject , ses -> ses_hmac -> taglen , tag , M_NOWAIT ) ) { error = ENOMEM ; out } } else { memcpy ( crp -> crp_mac , tag , ses -> ses_hmac -> taglen ) ; } explicit_bzero ( tag , sizeof ( tag ) ) ; } out explicit_bzero ( buf , len ) ; return error ; } 