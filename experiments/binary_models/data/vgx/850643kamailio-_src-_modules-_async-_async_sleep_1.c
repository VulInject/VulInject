void async_timer_exec ( unsigned int ticks , void * param ) { unsigned int idx ; unsigned int slot ; async_item_t * ai ; sr_kemi_eng_t * keng = NULL ; str cbname = STR_NULL ; str evname = str_init ( "async:timer-exec" ) ; idx = ticks % ASYNC_RING_SIZE ; if ( idx == _async_timer_exec_last_slot ) { return ; } if ( _async_timer_exec_last_slot < 0 ) { _async_timer_exec_last_slot = idx ; } slot = ( _async_timer_exec_last_slot + 1 ) % ASYNC_RING_SIZE ; if ( slot != idx ) { LM_DBG ( "need to catch up from slot %u to %u (slots: %u)\n" , slot , idx , ASYNC_RING_SIZE ) ; } { while ( 1 ) { lock_get ( & _async_list_head -> ring [ slot ] . lock ) ; ai = _async_list_head -> ring [ slot ] . lstart ; if ( ai != NULL ) { _async_list_head -> ring [ slot ] . lstart = ai -> next ; } lock_release ( & _async_list_head -> ring [ slot ] . lock ) ; if ( ai == NULL ) { break ; } if ( ai -> ract != NULL ) { tmb . t_continue ( ai -> tindex , ai -> tlabel , ai -> ract ) ; ksr_msg_env_reset ( ) ; } else { keng = sr_kemi_eng_get ( ) ; if ( keng != NULL && ai -> cbname_len > 0 ) { cbname . s = ai -> cbname ; cbname . len = ai -> cbname_len ; tmb . t_continue_cb ( ai -> tindex , ai -> tlabel , & cbname , & evname ) ; ksr_msg_env_reset ( ) ; } else { LM_WARN ( "no callback to be executed\n" ) ; } } shm_free ( ai ) ; } if ( slot == idx ) { break ; } slot = ( slot + 1 ) % ASYNC_RING_SIZE ; } 1 ; _async_timer_exec_last_slot = idx ; } 