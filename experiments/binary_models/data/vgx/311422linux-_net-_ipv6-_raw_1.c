static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions * opt_to_free = NULL ; struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( sockaddr_in6 * , sin6 , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct raw6_sock * rp = raw6_sk ( sk ) ; struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct raw6_frag_vec rfv ; struct flowi6 fl6 ; struct ipcm6_cookie ipc6 ; int addr_len = msg -> msg_namelen ; int hdrincl ; u16 proto ; int err ; if ( len > INT_MAX ) { return - EMSGSIZE ; } if ( msg -> msg_flags & MSG_OOB ) { return - EOPNOTSUPP ; } hdrincl = inet -> hdrincl ; hdrincl = READ_ONCE ( hdrincl ) ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . flowi6_uid = sk -> sk_uid ; ipcm6_init ( & ipc6 ) ; ipc6 . sockc . tsflags = sk -> sk_tsflags ; ipc6 . sockc . mark = sk -> sk_mark ; if ( sin6 ) { if ( addr_len < SIN6_LEN_RFC2133 ) { return - EINVAL ; } if ( sin6 -> sin6_family && sin6 -> sin6_family != AF_INET6 ) { return - EAFNOSUPPORT ; } proto = ntohs ( sin6 -> sin6_port ) ; if ( ! proto ) { proto = inet -> inet_num ; } if ( proto != inet -> inet_num ) { return - EINVAL ; } if ( proto > 255 ) { return - EINVAL ; } daddr = & sin6 -> sin6_addr ; if ( np -> sndflow ) { fl6 . flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( IS_ERR ( flowlabel ) ) { return - EINVAL ; } } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) { daddr = & sk -> sk_v6_daddr ; } if ( addr_len >= sizeof ( sockaddr_in6 ) && sin6 -> sin6_scope_id && __ipv6_addr_needs_scope_id ( __ipv6_addr_type ( daddr ) ) ) { fl6 . flowi6_oif = sin6 -> sin6_scope_id ; } } else { if ( sk -> sk_state != TCP_ESTABLISHED ) { return - EDESTADDRREQ ; } proto = inet -> inet_num ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; } if ( fl6 . flowi6_oif == 0 ) { fl6 . flowi6_oif = sk -> sk_bound_dev_if ; } if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( ipv6_txoptions ) ; ipc6 . opt = opt ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , & ipc6 ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( IS_ERR ( flowlabel ) ) { return - EINVAL ; } } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) { opt = NULL ; } } if ( ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } if ( flowlabel ) { opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; } opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = proto ; fl6 . flowi6_mark = ipc6 . sockc . mark ; if ( ! hdrincl ) { rfv . msg = msg ; rfv . hlen = 0 ; err = rawv6_probe_proto_opt ( & rfv , & fl6 ) ; if ( err ) { out } } if ( ! ipv6_addr_any ( daddr ) ) { fl6 . daddr = * daddr ; } else { fl6 . daddr . s6_addr [ 15 ] = 0x1 ; } if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) { fl6 . saddr = np -> saddr ; } final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) { fl6 . flowi6_oif = np -> mcast_oif ; } if ( ! fl6 . flowi6_oif ) { fl6 . flowi6_oif = np -> ucast_oif ; } security_sk_classify_flow ( sk , flowi6_to_flowi_common ( & fl6 ) ) ; if ( hdrincl ) { fl6 . flowi6_flags |= FLOWI_FLAG_KNOWN_NH ; } if ( ipc6 . tclass < 0 ) { ipc6 . tclass = np -> tclass ; } fl6 . flowlabel = ip6_make_flowinfo ( ipc6 . tclass , fl6 . flowlabel ) ; dst = ip6_dst_lookup_flow ( sock_net ( sk ) , sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; out } if ( ipc6 . hlimit < 0 ) { ipc6 . hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; } if ( ipc6 . dontfrag < 0 ) { ipc6 . dontfrag = np -> dontfrag ; } if ( msg -> msg_flags & MSG_CONFIRM ) { do_confirm } back_from_confirm if ( hdrincl ) { err = rawv6_send_hdrinc ( sk , msg , len , & fl6 , & dst , msg -> msg_flags , & ipc6 . sockc ) ; } else { ipc6 . opt = opt ; lock_sock ( sk ) ; err = ip6_append_data ( sk , raw6_getfrag , & rfv , len , 0 , & ipc6 , & fl6 , ( rt6_info * ) dst , msg -> msg_flags ) ; if ( err ) { ip6_flush_pending_frames ( sk ) ; } if ( ! ( msg -> msg_flags & MSG_MORE ) ) { err = rawv6_push_pending_frames ( sk , & fl6 , rp ) ; } release_sock ( sk ) ; } done dst_release ( dst ) ; out fl6_sock_release ( flowlabel ) ; txopt_put ( opt_to_free ) ; return err < 0 ?err : len ; do_confirm if ( msg -> msg_flags & MSG_PROBE ) { dst_confirm_neigh ( dst , & fl6 . daddr ) ; } if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) { back_from_confirm } err = 0 ; done } 