static int reset_mmc ( struct rtsx_chip * chip ) { struct sd_info * sd_card = & chip -> sd_card ; int retval , i = 0 , j = 0 , k = 0 ; bool switch_ddr = true ; u8 rsp [ 16 ] ; u8 spec_ver = 0 ; u32 temp ; if ( sd_card -> sd_lock_status & SD_UNLOCK_POW_ON ) { MMC_UNLOCK_ENTRY } switch_fail retval = sd_prepare_reset ( chip ) ; if ( retval != STATUS_SUCCESS ) { rtsx_trace ( chip , NULL ) ; return retval ; } SET_MMC ( sd_card ) ; RTY_MMC_RST retval = sd_send_cmd_get_rsp ( chip , GO_IDLE_STATE , 0 , SD_RSP_TYPE_R0 , NULL , 0 ) ; if ( retval != STATUS_SUCCESS ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } { if ( detect_card_cd ( chip , SD_CARD ) != STATUS_SUCCESS ) { sd_set_err_code ( chip , SD_NO_CARD ) ; rtsx_trace ( chip ) ; return STATUS_FAIL ; } retval = sd_send_cmd_get_rsp ( chip , SEND_OP_COND , ( SUPPORT_VOLTAGE | 0x40000000 ) , SD_RSP_TYPE_R3 , rsp , 5 ) ; if ( retval != STATUS_SUCCESS ) { if ( sd_check_err_code ( chip , SD_BUSY ) || sd_check_err_code ( chip , SD_TO_ERR ) ) { k ++ ; if ( k < 20 ) { sd_clr_err_code ( chip ) ; RTY_MMC_RST } else { rtsx_trace ( chip ) ; return STATUS_FAIL ; } } else { j ++ ; if ( j < 100 ) { sd_clr_err_code ( chip ) ; RTY_MMC_RST } else { rtsx_trace ( chip ) ; return STATUS_FAIL ; } } } wait_timeout ( 20 ) ; i ++ ; } ! ( rsp [ 1 ] & 0x80 ) && ( i < 255 ) ; if ( i == 255 ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } if ( ( rsp [ 1 ] & 0x60 ) == 0x40 ) { SET_MMC_SECTOR_MODE ( sd_card ) ; } else { CLR_MMC_SECTOR_MODE ( sd_card ) ; } retval = sd_send_cmd_get_rsp ( chip , ALL_SEND_CID , 0 , SD_RSP_TYPE_R2 , NULL , 0 ) ; if ( retval != STATUS_SUCCESS ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } sd_card -> sd_addr = 0x00100000 ; retval = sd_send_cmd_get_rsp ( chip , SET_RELATIVE_ADDR , sd_card -> sd_addr , SD_RSP_TYPE_R6 , rsp , 5 ) ; if ( retval != STATUS_SUCCESS ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } retval = sd_check_csd ( chip , 1 ) ; if ( retval != STATUS_SUCCESS ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } spec_ver = ( sd_card -> raw_csd [ 0 ] & 0x3C ) >> 2 ; retval = sd_select_card ( chip , 1 ) ; if ( retval != STATUS_SUCCESS ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } retval = sd_send_cmd_get_rsp ( chip , SET_BLOCKLEN , 0x200 , SD_RSP_TYPE_R1 , NULL , 0 ) ; if ( retval != STATUS_SUCCESS ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } MMC_UNLOCK_ENTRY retval = sd_update_lock_status ( chip ) ; if ( retval != STATUS_SUCCESS ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } retval = sd_set_clock_divider ( chip , SD_CLK_DIVIDE_0 ) ; if ( retval != STATUS_SUCCESS ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } chip -> card_bus_width [ chip -> card2lun [ SD_CARD ] ] = 1 ; if ( ! sd_card -> mmc_dont_switch_bus ) { if ( spec_ver == 4 ) { retval = mmc_switch_timing_bus ( chip , switch_ddr ) ; if ( retval != STATUS_SUCCESS ) { retval = sd_init_power ( chip ) ; if ( retval != STATUS_SUCCESS ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } sd_card -> mmc_dont_switch_bus = 1 ; rtsx_trace ( chip ) ; switch_fail } } if ( CHK_MMC_SECTOR_MODE ( sd_card ) && ( sd_card -> capacity == 0 ) ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } if ( switch_ddr && CHK_MMC_DDR52 ( sd_card ) ) { retval = sd_set_init_para ( chip ) ; if ( retval != STATUS_SUCCESS ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } retval = mmc_ddr_tuning ( chip ) ; if ( retval != STATUS_SUCCESS ) { retval = sd_init_power ( chip ) ; if ( retval != STATUS_SUCCESS ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } switch_ddr = false ; rtsx_trace ( chip ) ; switch_fail } retval = sd_wait_state_data_ready ( chip , 0x08 , 1 , 1000 ) ; if ( retval == STATUS_SUCCESS ) { retval = sd_read_lba0 ( chip ) ; if ( retval != STATUS_SUCCESS ) { retval = sd_init_power ( chip ) ; if ( retval != STATUS_SUCCESS ) { rtsx_trace ( chip ) ; return STATUS_FAIL ; } switch_ddr = false ; rtsx_trace ( chip ) ; switch_fail } } } } if ( sd_card -> sd_lock_status & SD_UNLOCK_POW_ON ) { retval = rtsx_write_register ( chip , REG_SD_BLOCK_CNT_H , 0xFF , 0x02 ) ; if ( retval ) { rtsx_trace ( chip ) ; return retval ; } retval = rtsx_write_register ( chip , REG_SD_BLOCK_CNT_L , 0xFF , 0x00 ) ; if ( retval ) { rtsx_trace ( chip ) ; return retval ; } } temp = rtsx_readl ( chip , RTSX_BIPR ) ; if ( temp & SD_WRITE_PROTECT ) { chip -> card_wp |= SD_CARD ; } return STATUS_SUCCESS ; } 