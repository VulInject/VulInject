int dib9000_i2c_enumeration ( struct i2c_adapter * i2c , int no_of_demods , u8 default_addr , u8 first_addr ) { int k = 0 , ret = 0 ; u8 new_addr = 0 ; struct i2c_device client = { . i2c_adap = i2c } ; client . i2c_write_buffer = kzalloc ( 4 * sizeof ( u8 ) , GFP_KERNEL ) ; if ( ! client . i2c_write_buffer ) { dprintk ( "%s: not enough memory\n" , __func__ ) ; return - ENOMEM ; } client . i2c_read_buffer = kzalloc ( 4 * sizeof ( u8 ) , GFP_KERNEL ) ; if ( ! client . i2c_read_buffer ) { dprintk ( "%s: not enough memory\n" , __func__ ) ; ret = - ENOMEM ; error_memory } client . i2c_addr = default_addr + 16 ; dib9000_i2c_write16 ( & client , 1796 , 0x0 ) ; for ( k = no_of_demods - 1 ; k >= 0 ; k -- ) { new_addr = first_addr + ( k << 1 ) ; client . i2c_addr = default_addr ; dib9000_i2c_write16 ( & client , 1817 , 3 ) ; dib9000_i2c_write16 ( & client , 1796 , 0 ) ; dib9000_i2c_write16 ( & client , 1227 , 1 ) ; dib9000_i2c_write16 ( & client , 1227 , 0 ) ; client . i2c_addr = new_addr ; dib9000_i2c_write16 ( & client , 1817 , 3 ) ; dib9000_i2c_write16 ( & client , 1796 , 0 ) ; dib9000_i2c_write16 ( & client , 1227 , 1 ) ; dib9000_i2c_write16 ( & client , 1227 , 0 ) ; if ( dib9000_identify ( & client ) == 0 ) { client . i2c_addr = default_addr ; if ( dib9000_identify ( & client ) == 0 ) { dprintk ( "DiB9000 #%d: not identified\n" , k ) ; ret = - EIO ; error } } dib9000_i2c_write16 ( & client , 1795 , ( 1 << 10 ) | ( 4 << 6 ) ) ; dib9000_i2c_write16 ( & client , 1794 , ( new_addr << 2 ) | 2 ) ; dprintk ( "IC %d initialized (to i2c_address 0x%x)\n" , k , new_addr ) ; } for ( k = 0 ; k < no_of_demods ; k ++ ) { new_addr = first_addr | ( k << 1 ) ; client . i2c_addr = new_addr ; dib9000_i2c_write16 ( & client , 1794 , ( new_addr << 2 ) ) ; dib9000_i2c_write16 ( & client , 1795 , 0 ) ; } error error_memory kfree ( client . i2c_write_buffer ) ; return ret ; } 