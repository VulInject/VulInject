PVIRTUALCHANNELENTRY freerdp_channels_load_static_addin_entry ( LPCSTR pszName , LPCSTR pszSubsystem , LPCSTR pszType , DWORD dwFlags ) { const STATIC_ADDIN_TABLE * table = CLIENT_STATIC_ADDIN_TABLE ; const char * type = NULL ; if ( ! pszName ) { return in ; } if ( dwFlags & FREERDP_ADDIN_CHANNEL_DYNAMIC ) { type = "DVCPluginEntry" ; } if ( dwFlags & FREERDP_ADDIN_CHANNEL_DEVICE ) { type = "DeviceServiceEntry" ; } if ( dwFlags & FREERDP_ADDIN_CHANNEL_STATIC ) { if ( dwFlags & FREERDP_ADDIN_CHANNEL_ENTRYEX ) { type = "VirtualChannelEntryEx" ; } else { type = "VirtualChannelEntry" ; } } for ( ; table -> name != NULL ; table ++ ) { if ( strncmp ( table -> name , pszName , MAX_PATH ) == 0 ) { if ( type && strncmp ( table -> type , type , MAX_PATH ) ) { continue ; } if ( pszSubsystem != NULL ) { const STATIC_SUBSYSTEM_ENTRY * subsystems = table -> table ; for ( ; subsystems -> name != NULL ; subsystems ++ ) { if ( ( strnlen ( pszSubsystem , 1 ) == 0 ) || ( strncmp ( subsystems -> name , pszSubsystem , MAX_PATH ) == 0 ) ) { if ( pszType ) { if ( strncmp ( subsystems -> type , pszType , MAX_PATH ) == 0 ) { return ( PVIRTUALCHANNELENTRY ) subsystems -> entry ; } } else { return ( PVIRTUALCHANNELENTRY ) subsystems -> entry ; } } } } else { if ( dwFlags & FREERDP_ADDIN_CHANNEL_ENTRYEX ) { if ( ! freerdp_channels_is_virtual_channel_entry_ex ( pszName ) ) { return NULL ; } } return ( PVIRTUALCHANNELENTRY ) table -> entry ; } } } return NULL ; } { wMessageQueue * queue ; wStream * data_in ; HANDLE thread ; char * channel_name ; rdpContext * ctx ; LPVOID userdata ; MsgHandler msg_handler ; } msg_proc_internals 