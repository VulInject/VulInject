void ax25_kick ( ax25_cb * ax25 ) { struct sk_buff * skb , * skbn ; int last = 1 ; unsigned short start , end , next ; if ( ax25 -> state != AX25_STATE_3 && ax25 -> state != AX25_STATE_4 ) { return ; } if ( ax25 -> condition & AX25_COND_PEER_RX_BUSY ) { return ; } if ( skb_peek ( & ax25 -> write_queue ) == NULL ) { return ; } start = ( skb_peek ( & ax25 -> ack_queue ) == NULL ) ?ax25 -> va : ax25 -> vs ; end = ( ax25 -> va + ax25 -> window ) % ax25 -> modulus ; skb = skb_dequeue ( & ax25 -> write_queue ) ; if ( ! skb ) { return ; } ax25 -> vs = start ; { if ( ( skbn = skb_clone ( skb , GFP_ATOMIC ) ) == NULL ) { skb_queue_head ( & ax25 -> write_queue , skb ) ; break ; } if ( skb -> sk != NULL ) { skb_set_owner_w ( skbn , skb -> sk ) ; } next = ( ax25 -> vs + 1 ) % ax25 -> modulus ; last = ( next == end ) ; switch ( ax25 -> ax25_dev -> values [ AX25_VALUES_PROTOCOL ] ) { case AX25_PROTO_STD_SIMPLEX : case AX25_PROTO_STD_DUPLEX : ax25_send_iframe ( ax25 , skbn , ( last ) ?AX25_POLLON : AX25_POLLOFF ) ; break ; case AX25_PROTO_DAMA_SLAVE : ax25_send_iframe ( ax25 , skbn , AX25_POLLOFF ) ; break ; } ax25 -> vs = next ; skb_queue_tail ( & ax25 -> ack_queue , skb ) ; } ! last && ( skb = skb_dequeue ( & ax25 -> write_queue ) ) != NULL ; ax25 -> condition &= ~ AX25_COND_ACK_PENDING ; if ( ! ax25_t1timer_running ( ax25 ) ) { ax25_stop_t3timer ( ax25 ) ; ax25_calculate_t1 ( ax25 ) ; ax25_start_t1timer ( ax25 ) ; } } 