int send_sms_as_sip_scan_no ( struct incame_sms * sms , char * to ) { str sip_from ; str sip_to ; str sip_body ; char * p ; sip_from . s = sms -> sender ; sip_from . len = strlen ( sms -> sender , NULL ) ; sip_to . len = strlen ( to ) ; sip_to . s = to ; sip_body . len = sms -> ascii + sms -> userdatalength - sms -> ascii ; sip_body . s = sms -> ascii ; while ( sip_body . len && sip_body . s && ( sip_body . s [ 0 ] == '\n' || sip_body . s [ 0 ] == '\r' ) ) { sip_body . s ++ ; sip_body . len -- ; } if ( sip_body . len == 0 ) { LM_WARN ( "SMS empty body for sms [%s]\n" , sms -> ascii ) ; error } if ( sms -> userdatalength + CRLF_LEN + 1 + DATE_LEN + 1 + TIME_LEN + 1 < sizeof ( sms -> ascii ) ) { p = sip_body . s + sip_body . len ; append_str ( p , CRLF , CRLF_LEN ) ; * ( p ++ ) = '(' ; append_str ( p , sms -> date , DATE_LEN ) ; * ( p ++ ) = ',' ; append_str ( p , sms -> time , TIME_LEN ) ; * ( p ++ ) = ')' ; sip_body . len += CRLF_LEN + DATE_LEN + TIME_LEN + 3 ; } LM_DBG ( "SMS from: [%.*s], to: [%.*s], body: [%.*s]\n" , sip_from . len , sip_from . s , sip_to . len , sip_to . s , sip_body . len , sip_body . s ) ; return send_sip_msg_request ( & sip_to , & sip_from , & sip_body ) ; error return - 1 ; } 