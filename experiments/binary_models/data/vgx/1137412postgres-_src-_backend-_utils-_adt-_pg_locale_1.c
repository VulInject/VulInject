pg_locale_t pg_newlocale_from_collation ( Oid collid ) { collation_cache_entry * cache_entry ; Assert ( OidIsValid ( collid ) ) ; if ( collid == DEFAULT_COLLATION_OID ) { if ( default_locale . provider == COLLPROVIDER_ICU ) { return & default_locale ; } else { return ( pg_locale_t ) 0 ; } } cache_entry = lookup_collation_cache ( collid , false ) ; if ( cache_entry -> locale == 0 ) { HeapTuple tp ; Form_pg_collation collform ; struct pg_locale_struct result ; pg_locale_t resultp ; Datum datum ; bool isnull ; tp = SearchSysCache1 ( COLLOID , ObjectIdGetDatum ( collid ) ) ; if ( ! HeapTupleIsValid ( tp ) ) { elog ( ERROR , "cache lookup failed for collation %u" , collid ) ; } collform = ( Form_pg_collation ) GETSTRUCT ( tp ) ; result . provider = collform -> collprovider ; result . deterministic = collform -> collisdeterministic ; if ( collform -> collprovider == COLLPROVIDER_LIBC ) { const char * collcollate ; const char * collctype pg_attribute_unused ( ) ; locale_t loc ; datum = SysCacheGetAttr ( COLLOID , tp , Anum_pg_collation_collcollate , & isnull ) ; Assert ( ! isnull ) ; collcollate = TextDatumGetCString ( datum ) ; datum = SysCacheGetAttr ( COLLOID , tp , Anum_pg_collation_collctype , & isnull ) ; Assert ( ! isnull ) ; collctype = TextDatumGetCString ( datum ) ; if ( strcmp ( collcollate , collctype ) == 0 ) { errno = 0 ; loc = newlocale ( LC_COLLATE_MASK | LC_CTYPE_MASK , collcollate , NULL ) ; loc = _create_locale ( LC_ALL , collcollate ) ; if ( ! loc ) { report_newlocale_failure ( collcollate ) ; } } else { locale_t loc1 ; errno = 0 ; loc1 = newlocale ( LC_COLLATE_MASK , collcollate , NULL ) ; if ( ! loc1 ) { report_newlocale_failure ( collcollate ) ; } errno = 0 ; loc = newlocale ( LC_CTYPE_MASK , collctype , loc1 ) ; if ( ! loc ) { report_newlocale_failure ( collctype ) ; } ereport ( ERROR , ( errcode ( ERRCODE_FEATURE_NOT_SUPPORTED ) , errmsg ( "collations with different collate and ctype values are not supported on this platform" ) ) ) ; } result . info . lt = loc ; ereport ( ERROR , ( errcode ( ERRCODE_FEATURE_NOT_SUPPORTED ) , errmsg ( "collation provider LIBC is not supported on this platform" ) ) ) ; } if ( collform -> collprovider == COLLPROVIDER_ICU ) { const char * iculocstr ; datum = SysCacheGetAttr ( COLLOID , tp , Anum_pg_collation_colliculocale , & isnull ) ; Assert ( ! isnull ) ; iculocstr = TextDatumGetCString ( datum ) ; make_icu_collator ( iculocstr , & result ) ; } datum = SysCacheGetAttr ( COLLOID , tp , Anum_pg_collation_collversion , & isnull ) ; if ( ! isnull ) { char * actual_versionstr ; char * collversionstr ; collversionstr = TextDatumGetCString ( datum ) ; datum = SysCacheGetAttr ( COLLOID , tp , collform -> collprovider == COLLPROVIDER_ICU ?Anum_pg_collation_colliculocale : Anum_pg_collation_collcollate , & isnull ) ; Assert ( ! isnull ) ; actual_versionstr = get_collation_actual_version ( collform -> collprovider , TextDatumGetCString ( datum ) ) ; if ( ! actual_versionstr ) { ereport ( ERROR , ( errmsg ( "collation \"%s\" has no actual version, but a version was recorded" , NameStr ( collform -> collname ) ) ) ) ; } if ( strcmp ( actual_versionstr , collversionstr ) != 0 ) { ereport ( WARNING , ( errmsg ( "collation \"%s\" has version mismatch" , NameStr ( collform -> collname ) ) , errdetail ( "The collation in the database was created using version %s, " "but the operating system provides version %s." , collversionstr , actual_versionstr ) , errhint ( "Rebuild all objects affected by this collation and run " "ALTER COLLATION %s REFRESH VERSION, " "or build PostgreSQL with the right library version." , quote_qualified_identifier ( get_namespace_name ( collform -> collnamespace ) , NameStr ( collform -> collname ) ) ) ) ) ; } } ReleaseSysCache ( tp ) ; resultp = MemoryContextAlloc ( TopMemoryContext , sizeof ( * resultp ) ) ; * resultp = result ; cache_entry -> locale = resultp ; } return cache_entry -> locale ; } 