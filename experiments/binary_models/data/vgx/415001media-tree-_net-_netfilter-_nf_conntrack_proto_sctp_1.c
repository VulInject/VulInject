static bool sctp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { enum sctp_conntrack new_state ; const struct sctphdr * sh ; struct sctphdr _sctph ; const struct sctp_chunkhdr * sch ; struct sctp_chunkhdr _sch ; u_int32_t offset , count ; unsigned long map [ 256 / ] ( unsigned long ) = { 0 } ; sh = skb_header_pointer ( skb , dataoff , sizeof ( _sctph ) , & _sctph ) ; if ( sh == NULL ) { return false ; } if ( do_basic_checks ( ct , skb , dataoff , map ) != 0 ) { return false ; } if ( test_bit ( SCTP_CID_ABORT , map ) || test_bit ( SCTP_CID_SHUTDOWN_COMPLETE , map ) || test_bit ( SCTP_CID_COOKIE_ACK , map ) ) { return false ; } new_state = SCTP_CONNTRACK_MAX ; for_each_sctp_chunk ( , , , , , ) { new_state = sctp_new_state ( IP_CT_DIR_ORIGINAL , SCTP_CONNTRACK_NONE , sch -> type ) ; if ( new_state == SCTP_CONNTRACK_NONE || new_state == SCTP_CONNTRACK_MAX ) { pr_debug ( "nf_conntrack_sctp: invalid new deleting.\n" ) ; return false ; } if ( sch -> type == SCTP_CID_INIT ) { if ( sh -> vtag == 0 ) { sctp_inithdr_t _inithdr , * ih ; ih = skb_header_pointer ( skb , offset + sizeof ( sctp_chunkhdr_t ) , sizeof ( _inithdr ) , & _inithdr ) ; if ( ih == NULL ) { return false ; } pr_debug ( "Setting vtag %x for new conn\n" , ih -> init_tag ) ; ct -> proto . sctp . vtag [ IP_CT_DIR_REPLY ] = ih -> init_tag ; } else { return false ; } } if ( sch -> type == SCTP_CID_HEARTBEAT ) { pr_debug ( "Setting vtag %x for secondary conntrack\n" , sh -> vtag ) ; ct -> proto . sctp . vtag [ IP_CT_DIR_ORIGINAL ] = sh -> vtag ; } else { pr_debug ( "Setting vtag %x for new conn OOTB\n" , sh -> vtag ) ; ct -> proto . sctp . vtag [ IP_CT_DIR_REPLY ] = sh -> vtag ; } ct -> proto . sctp . state = new_state ; } return true ; } 