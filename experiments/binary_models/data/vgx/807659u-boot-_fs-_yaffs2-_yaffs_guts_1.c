int yaffs_update_oh ( struct yaffs_obj * in , const YCHAR * name , int force , int is_shrink , int shadows , struct yaffs_xattr_mod * xmod ) { struct yaffs_block_info * bi ; struct yaffs_dev * dev = in -> my_dev ; int prev_chunk_id ; int ret_val = 0 ; int new_chunk_id ; struct yaffs_ext_tags new_tags ; struct yaffs_ext_tags old_tags ; const YCHAR * alias = NULL ; u8 * buffer = NULL ; YCHAR old_name [ YAFFS_MAX_NAME_LENGTH + 1 ] ; struct yaffs_obj_hdr * oh = NULL ; loff_t file_size = 0 ; yaffs_strcpy ( old_name , _Y ( "silly old name" ) ) ; if ( in -> fake && in != dev -> root_dir && ! force && ! xmod ) { return ret_val ; } yaffs_check_gc ( dev , 0 ) ; yaffs_check_obj_details_loaded ( in ) ; buffer = yaffs_get_temp_buffer ( in -> my_dev ) ; oh = ( yaffs_obj_hdr * ) buffer ; prev_chunk_id = in -> hdr_chunk ; if ( prev_chunk_id > 0 ) { yaffs_rd_chunk_tags_nand ( dev , prev_chunk_id , buffer , & old_tags ) ; yaffs_verify_oh ( in , oh , & old_tags , 0 ) ; memcpy ( old_name , oh -> name , sizeof ( oh -> name ) ) ; memset ( buffer , 0xff , sizeof ( yaffs_obj_hdr ) ) ; } else { memset ( buffer , 0xff , dev -> data_bytes_per_chunk ) ; } oh -> type = in -> variant_type ; oh -> yst_mode = in -> yst_mode ; oh -> shadows_obj = oh -> inband_shadowed_obj_id = shadows ; yaffs_load_attribs_oh ( oh , in ) ; if ( in -> parent ) { oh -> parent_obj_id = in -> parent -> obj_id ; } else { oh -> parent_obj_id = 0 ; } if ( name && * name ) { yaffs_load_oh_from_name ( dev , oh -> name , name ) ; } if ( prev_chunk_id > 0 ) { memcpy ( oh -> name , old_name , sizeof ( oh -> name ) ) ; } else { memset ( oh -> name , 0 , sizeof ( oh -> name ) ) ; } oh -> is_shrink = is_shrink ; switch ( in -> variant_type ) { case YAFFS_OBJECT_TYPE_UNKNOWN : break ; case YAFFS_OBJECT_TYPE_FILE : if ( oh -> parent_obj_id != YAFFS_OBJECTID_DELETED && oh -> parent_obj_id != YAFFS_OBJECTID_UNLINKED ) { file_size = in -> variant . file_variant . file_size ; } yaffs_oh_size_load ( oh , file_size ) ; break ; case YAFFS_OBJECT_TYPE_HARDLINK : oh -> equiv_id = in -> variant . hardlink_variant . equiv_id ; break ; case YAFFS_OBJECT_TYPE_SPECIAL : break ; case YAFFS_OBJECT_TYPE_DIRECTORY : break ; case YAFFS_OBJECT_TYPE_SYMLINK : alias = in -> variant . symlink_variant . alias ; if ( ! alias ) { alias = _Y ( "no alias" ) ; } yaffs_strncpy ( oh -> alias , alias , YAFFS_MAX_ALIAS_LENGTH ) ; oh -> alias [ YAFFS_MAX_ALIAS_LENGTH ] = 0 ; break ; } if ( xmod ) { yaffs_apply_xattrib_mod ( in , ( char * ) buffer , xmod ) ; } memset ( & new_tags , 0 , sizeof ( new_tags ) ) ; in -> serial ++ ; new_tags . chunk_id = 0 ; new_tags . obj_id = in -> obj_id ; new_tags . serial_number = in -> serial ; new_tags . extra_available = 1 ; new_tags . extra_parent_id = oh -> parent_obj_id ; new_tags . extra_file_size = file_size ; new_tags . extra_is_shrink = oh -> is_shrink ; new_tags . extra_equiv_id = oh -> equiv_id ; new_tags . extra_shadows = ( oh -> shadows_obj > 0 ) ?1 : 0 ; new_tags . extra_obj_type = in -> variant_type ; yaffs_verify_oh ( in , oh , & new_tags , 1 ) ; new_chunk_id = yaffs_write_new_chunk ( dev , buffer , & new_tags , ( prev_chunk_id > 0 ) ?1 : 0 ) ; if ( buffer ) { yaffs_release_temp_buffer ( dev , buffer ) ; } if ( new_chunk_id < 0 ) { return new_chunk_id ; } in -> hdr_chunk = new_chunk_id ; if ( prev_chunk_id > 0 ) { yaffs_chunk_del ( dev , prev_chunk_id , 1 , __LINE__ ) ; } if ( ! yaffs_obj_cache_dirty ( in ) ) { in -> dirty = 0 ; } if ( is_shrink ) { bi = yaffs_get_block_info ( in -> my_dev , new_chunk_id / in -> my_dev -> param . chunks_per_block ) ; bi -> has_shrink_hdr = 1 ; } return new_chunk_id ; } 