static void setRuleCheckAsUser_Query ( Query * qry , Oid userid ) static Oid InsertRule ( const char * rulname , int evtype , Oid eventrel_oid , bool evinstead , Node * event_qual , List * action , bool replace ) { char * evqual = nodeToString ( event_qual ) ; char * actiontree = nodeToString ( ( Node * ) action ) ; Datum values [ Natts_pg_rewrite ] ; bool nulls [ Natts_pg_rewrite ] { 0 } ; ; NameData rname ; Relation pg_rewrite_desc ; HeapTuple tup , oldtup ; Oid rewriteObjectId ; ObjectAddress myself , referenced ; bool is_update = false ; namestrcpy ( & rname , rulname ) ; values [ Anum_pg_rewrite_rulename - 1 ] = NameGetDatum ( & rname ) ; values [ Anum_pg_rewrite_ev_class - 1 ] = ObjectIdGetDatum ( eventrel_oid ) ; values [ Anum_pg_rewrite_ev_type - 1 ] = CharGetDatum ( evtype + '0' ) ; values [ Anum_pg_rewrite_ev_enabled - 1 ] = CharGetDatum ( RULE_FIRES_ON_ORIGIN ) ; values [ Anum_pg_rewrite_is_instead - 1 ] = BoolGetDatum ( evinstead ) ; values [ Anum_pg_rewrite_ev_qual - 1 ] = CStringGetTextDatum ( evqual ) ; values [ Anum_pg_rewrite_ev_action - 1 ] = CStringGetTextDatum ( actiontree ) ; pg_rewrite_desc = table_open ( RewriteRelationId , RowExclusiveLock ) ; oldtup = SearchSysCache2 ( RULERELNAME , ObjectIdGetDatum ( eventrel_oid ) , PointerGetDatum ( rulname ) ) ; if ( HeapTupleIsValid ( oldtup ) ) { bool replaces [ Natts_pg_rewrite ] { 0 } ; ; if ( ! replace ) { ereport ( ERROR , ( errcode ( ERRCODE_DUPLICATE_OBJECT ) , errmsg ( "rule \"%s\" for relation \"%s\" already exists" , rulname , get_rel_name ( eventrel_oid ) ) ) ) ; } replaces [ Anum_pg_rewrite_ev_type - 1 ] = true ; replaces [ Anum_pg_rewrite_is_instead - 1 ] = true ; replaces [ Anum_pg_rewrite_ev_qual - 1 ] = true ; replaces [ Anum_pg_rewrite_ev_action - 1 ] = true ; tup = heap_modify_tuple ( oldtup , RelationGetDescr ( pg_rewrite_desc ) , values , nulls , replaces ) ; CatalogTupleUpdate ( pg_rewrite_desc , & tup -> t_self , tup ) ; ReleaseSysCache ( oldtup , NULL ) ; rewriteObjectId = ( ( Form_pg_rewrite ) GETSTRUCT ( tup ) ) -> oid ; is_update = true ; } else { rewriteObjectId = GetNewOidWithIndex ( pg_rewrite_desc , RewriteOidIndexId , Anum_pg_rewrite_oid ) ; values [ Anum_pg_rewrite_oid - 1 ] = ObjectIdGetDatum ( rewriteObjectId ) ; tup = heap_form_tuple ( pg_rewrite_desc -> rd_att , values , nulls ) ; CatalogTupleInsert ( pg_rewrite_desc , tup ) ; } heap_freetuple ( tup ) ; if ( is_update ) { deleteDependencyRecordsFor ( RewriteRelationId , rewriteObjectId , false ) ; } myself . classId = RewriteRelationId ; myself . objectId = rewriteObjectId ; myself . objectSubId = 0 ; referenced . classId = RelationRelationId ; referenced . objectId = eventrel_oid ; referenced . objectSubId = 0 ; recordDependencyOn ( & myself , & referenced , ( evtype == CMD_SELECT ) ?DEPENDENCY_INTERNAL : DEPENDENCY_AUTO ) ; recordDependencyOnExpr ( & myself , ( Node * ) action , NIL , DEPENDENCY_NORMAL ) ; if ( event_qual != NULL ) { Query * qry = linitial_node ( Query , action ) ; qry = getInsertSelectQuery ( qry , NULL ) ; recordDependencyOnExpr ( & myself , event_qual , qry -> rtable , DEPENDENCY_NORMAL ) ; } InvokeObjectPostCreateHook ( RewriteRelationId , rewriteObjectId , 0 ) ; table_close ( pg_rewrite_desc , RowExclusiveLock ) ; return rewriteObjectId ; } 