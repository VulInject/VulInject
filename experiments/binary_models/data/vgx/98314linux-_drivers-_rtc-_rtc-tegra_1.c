static int tegra_rtc_probe ( struct platform_device * pdev ) { struct tegra_rtc_info * info ; int ret ; info = devm_kzalloc ( & pdev -> dev , sizeof ( * info ) , GFP_KERNEL ) ; info -> base = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( info -> base ) ) { return PTR_ERR ( info -> base ) ; } ret = platform_get_irq ( pdev , 0 ) ; if ( ret <= 0 ) { return ret ; } info -> irq = ret ; info -> rtc = devm_rtc_allocate_device ( & pdev -> dev ) ; if ( IS_ERR ( info -> rtc ) ) { return PTR_ERR ( info -> rtc ) ; } info -> rtc -> ops = & tegra_rtc_ops ; info -> rtc -> range_max = U32_MAX ; info -> clk = devm_clk_get ( & pdev -> dev , NULL ) ; if ( IS_ERR ( info -> clk ) ) { return PTR_ERR ( info -> clk ) ; } ret = clk_prepare_enable ( info -> clk ) ; if ( ret < 0 ) { return ret ; } info -> pdev = pdev ; spin_lock_init ( & info -> lock ) ; platform_set_drvdata ( pdev , info ) ; writel ( 0 , info -> base + TEGRA_RTC_REG_SECONDS_ALARM0 ) ; writel ( 0xffffffff , info -> base + TEGRA_RTC_REG_INTR_STATUS ) ; writel ( 0 , info -> base + TEGRA_RTC_REG_INTR_MASK ) ; device_init_wakeup ( & pdev -> dev , 1 ) ; ret = devm_request_irq ( & pdev -> dev , info -> irq , tegra_rtc_irq_handler , IRQF_TRIGGER_HIGH , dev_name ( & pdev -> dev ) , & pdev -> dev ) ; if ( ret ) { dev_err ( & pdev -> dev , "failed to request interrupt: %d\n" , ret ) ; disable_clk } ret = devm_rtc_register_device ( info -> rtc ) ; if ( ret ) { disable_clk } dev_notice ( & pdev -> dev , "Tegra internal Real Time Clock\n" ) ; return 0 ; disable_clk clk_disable_unprepare ( info -> clk ) ; return ret ; } 