int vidioc_try_fmt_vid_overlay ( struct file * file , void * priv , struct v4l2_format * f ) { struct vivid_dev * dev = video_drvdata ( file ) ; const struct v4l2_rect * compose = & dev -> compose_cap ; struct v4l2_window * win = & f -> fmt . win ; int i , j ; if ( dev -> multiplanar ) { return - ENOTTY ; } win -> w . left = clamp_t ( int , win -> w . left , - dev -> fb_cap . fmt . width , dev -> fb_cap . fmt . width ) ; win -> w . top = clamp_t ( int , win -> w . top , - dev -> fb_cap . fmt . height , dev -> fb_cap . fmt . height ) ; win -> w . width = compose -> width ; win -> w . height = compose -> height ; if ( win -> field != V4L2_FIELD_BOTTOM && win -> field != V4L2_FIELD_TOP ) { win -> field = V4L2_FIELD_ANY ; } win -> global_alpha = 0 ; if ( win -> clipcount && ! win -> clips ) { win -> clipcount = 0 ; } if ( win -> clipcount > MAX_CLIPS ) { win -> clipcount = MAX_CLIPS ; } if ( win -> clipcount ) { memcpy ( dev -> try_clips_cap , win -> clips , win -> clipcount * sizeof ( dev -> clips_cap [ 0 ] ) ) ; for ( i = 0 ; i < win -> clipcount ; i ++ ) { struct v4l2_rect * r = & dev -> try_clips_cap [ i ] . c ; r -> top = clamp_t ( s32 , r -> top , 0 , dev -> fb_cap . fmt . height - 1 ) ; r -> height = clamp_t ( s32 , r -> height , 1 , dev -> fb_cap . fmt . height - r -> top ) ; r -> left = clamp_t ( u32 , r -> left , 0 , dev -> fb_cap . fmt . width - 1 ) ; r -> width = clamp_t ( u32 , r -> width , 1 , dev -> fb_cap . fmt . width - r -> left ) ; } for ( i = 0 ; i < win -> clipcount - 1 ; i ++ ) { struct v4l2_rect * r1 = & dev -> try_clips_cap [ i ] . c ; for ( j = i + 1 ; j < win -> clipcount ; j ++ ) { struct v4l2_rect * r2 = & dev -> try_clips_cap [ j ] . c ; if ( v4l2_rect_overlap ( r1 , r2 ) ) { return - EINVAL ; } } } memcpy ( win -> clips , dev -> try_clips_cap , win -> clipcount * sizeof ( dev -> clips_cap [ 0 ] ) ) ; } return 0 ; } 