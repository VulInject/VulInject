loff_t __init nvram_create_partition ( const char * name , int sig , int req_size , int min_size ) { struct nvram_partition * part ; struct nvram_partition * new_part ; struct nvram_partition * free_part = NULL ; static char nv_init_vals [ 16 ] ; loff_t tmp_index ; long size = 0 ; int rc ; BUILD_BUG_ON ( NVRAM_BLOCK_LEN != 16 ) ; req_size = ALIGN ( req_size , NVRAM_BLOCK_LEN ) / NVRAM_BLOCK_LEN ; min_size = ALIGN ( min_size , NVRAM_BLOCK_LEN ) / NVRAM_BLOCK_LEN ; if ( min_size == 0 ) { min_size = req_size ; } req_size += 1 ; min_size += 1 ; list_for_each_entry ( , , ) { if ( part -> header . signature != NVRAM_SIG_FREE ) { continue ; } if ( part -> header . length >= req_size ) { size = req_size ; free_part = part ; break ; } if ( part -> header . length > size && part -> header . length >= min_size ) { size = part -> header . length ; free_part = part ; } } if ( ! size ) { return - ENOSPC ; } new_part = kzalloc ( sizeof ( * new_part ) , GFP_KERNEL ) ; if ( ! new_part ) { pr_err ( "%s: kmalloc failed\n" , __func__ ) ; return - ENOMEM ; } new_part -> index = free_part -> index ; new_part -> header . signature = sig ; new_part -> header . length = size ; memcpy ( new_part -> header . name , name , strnlen ( name , sizeof ( new_part -> header . name ) ) ) ; new_part -> header . checksum = nvram_checksum ( & new_part -> header ) ; rc = nvram_write_header ( new_part ) ; if ( rc <= 0 ) { pr_err ( "%s: nvram_write_header failed (%d)\n" , __func__ , rc ) ; kfree ( new_part ) ; return rc ; } list_add_tail ( & new_part -> partition , & free_part -> partition ) ; if ( free_part -> header . length > size ) { free_part -> index += size * NVRAM_BLOCK_LEN ; free_part -> header . length -= size ; free_part -> header . checksum = nvram_checksum ( & free_part -> header ) ; rc = nvram_write_header ( free_part ) ; if ( rc <= 0 ) { pr_err ( "%s: nvram_write_header failed (%d)\n" , __func__ , rc ) ; return rc ; } } else { list_del ( & free_part -> partition ) ; kfree ( free_part ) ; } for ( tmp_index = new_part -> index + NVRAM_HEADER_LEN ; tmp_index < ( ( size - 1 ) * NVRAM_BLOCK_LEN ) ; tmp_index += NVRAM_BLOCK_LEN ) { rc = ppc_md . nvram_write ( nv_init_vals , NVRAM_BLOCK_LEN , & tmp_index ) ; if ( rc <= 0 ) { pr_err ( "%s: nvram_write failed (%d)\n" , __func__ , rc ) ; return rc ; } } return new_part -> index + NVRAM_HEADER_LEN ; } 