static int be_copy_zones ( char * obe_name , char * obe_root_ds , char * nbe_root_ds ) { int i , num_retries ; int ret = BE_SUCCESS ; int iret = 0 ; char * zonename = NULL ; char * zonepath = NULL ; char * zone_be_name = NULL ; char * temp_mntpt ; char * new_zone_be_name = NULL ; char zoneroot [ MAXPATHLEN ] ; char zoneroot_ds [ MAXPATHLEN ] ; char zone_container_ds [ MAXPATHLEN ] ; char new_zoneroot_ds [ MAXPATHLEN ] ; char ss [ MAXPATHLEN ] ; uuid_t uu = { 0 } ; char uu_string [ UUID_PRINTABLE_STRING_LENGTH ] { 0 } ; ; be_transaction_data_t bt = { 0 } ; zfs_handle_t * obe_zhp = NULL ; zfs_handle_t * nbe_zhp = NULL ; zfs_handle_t * z_zhp = NULL ; zoneList_t zlist = NULL ; zoneBrandList_t * brands = NULL ; boolean_t mounted_here = B_FALSE ; char * snap_name = NULL ; if ( ! z_zones_are_implemented ( ) ) { return ( BE_SUCCESS ) ; } if ( ( brands = be_get_supported_brandlist ( ) ) == NULL ) { be_print_err ( gettext ( "be_copy_zones: " "no supported brands\n" ) ) ; return ( BE_SUCCESS ) ; } if ( ( obe_zhp = zfs_open ( g_zfs , obe_root_ds , ZFS_TYPE_FILESYSTEM ) ) == NULL ) { be_print_err ( gettext ( "be_copy_zones: failed to open " "the origin BE root dataset (%s) for zones processing: " "%s\n" ) , obe_root_ds , libzfs_error_description ( g_zfs ) ) ; return ( zfs_err_to_be_err ( g_zfs ) ) ; } if ( ( nbe_zhp = zfs_open ( g_zfs , nbe_root_ds , ZFS_TYPE_FILESYSTEM ) ) == NULL ) { be_print_err ( gettext ( "be_copy_zones: failed to open " "the new BE root dataset (%s): %s\n" ) , nbe_root_ds , libzfs_error_description ( g_zfs ) ) ; ZFS_CLOSE ( obe_zhp ) ; return ( zfs_err_to_be_err ( g_zfs ) ) ; } if ( be_get_uuid ( zfs_get_name ( nbe_zhp ) , & uu ) != BE_SUCCESS ) { be_print_err ( gettext ( "be_copy_zones: " "failed to get uuid for BE root " "dataset %s\n" ) , zfs_get_name ( nbe_zhp ) ) ; ZFS_CLOSE ( nbe_zhp ) ; done } ZFS_CLOSE ( nbe_zhp ) ; uuid_unparse ( uu , uu_string ) ; if ( ! zfs_is_mounted ( obe_zhp , & temp_mntpt ) ) { if ( ( ret = _be_mount ( obe_name , & temp_mntpt , BE_MOUNT_FLAG_NULL ) ) != BE_SUCCESS ) { be_print_err ( gettext ( "be_copy_zones: failed to " "mount the BE (%s) for zones procesing.\n" ) , obe_name ) ; done } mounted_here = B_TRUE ; } z_set_zone_root ( temp_mntpt ) ; if ( ( zlist = z_get_nonglobal_zone_list_by_brand ( brands ) ) == NULL ) { ret = BE_SUCCESS ; done } for ( i = 0 ; ( zonename = z_zlist_get_zonename ( zlist , i ) ) != NULL ; i ++ ) { be_fs_list_data_t fld = { 0 } ; char zonepath_ds [ MAXPATHLEN ] ; char * ds = NULL ; zonepath = z_zlist_get_zonepath ( zlist , i ) ; if ( z_zlist_get_current_state ( zlist , i ) < ZONE_STATE_INSTALLED ) { continue ; } if ( ( ds = be_get_ds_from_dir ( zonepath ) ) == NULL ) { continue ; } ( void ) strlcpy ( zonepath_ds , ds , sizeof ( zonepath_ds ) ) ; free ( ds ) ; ds = NULL ; be_make_zoneroot ( zonepath , zoneroot , sizeof ( zoneroot ) ) ; if ( ! be_zone_supported ( zonepath_ds ) ) { continue ; } if ( ( ret = be_find_active_zone_root ( obe_zhp , zonepath_ds , zoneroot_ds , sizeof ( zoneroot_ds ) ) ) != BE_SUCCESS ) { be_print_err ( gettext ( "be_copy_zones: " "failed to find active zone root for zone %s " "in BE %s\n" ) , zonename , obe_name ) ; done } if ( ( ret = be_make_container_ds ( zonepath_ds , zone_container_ds , sizeof ( zone_container_ds ) ) ) != BE_SUCCESS ) { be_print_err ( gettext ( "%s: failed to get BE container " "dataset for %s\n" ) , __func__ , zonepath_ds ) ; done } if ( ( z_zhp = zfs_open ( g_zfs , zoneroot_ds , ZFS_TYPE_FILESYSTEM ) ) == NULL ) { be_print_err ( gettext ( "be_copy_zones: " "failed to open zone root dataset (%s): %s\n" ) , zoneroot_ds , libzfs_error_description ( g_zfs ) ) ; ret = zfs_err_to_be_err ( g_zfs ) ; done } zone_be_name = be_get_zone_be_name ( zoneroot_ds , zone_container_ds ) ; if ( ( new_zone_be_name = be_auto_zone_be_name ( zone_container_ds , zone_be_name ) ) == NULL ) { be_print_err ( gettext ( "be_copy_zones: failed " "to generate auto name for zone BE.\n" ) ) ; ret = BE_ERR_AUTONAME ; done } if ( ( snap_name = be_auto_snap_name ( ) ) == NULL ) { be_print_err ( gettext ( "be_copy_zones: failed to " "generate snapshot name for zone BE.\n" ) ) ; ret = BE_ERR_AUTONAME ; done } ( void ) snprintf ( ss , sizeof ( ss ) , "%s@%s" , zoneroot_ds , snap_name ) ; if ( zfs_snapshot ( g_zfs , ss , B_TRUE , NULL ) != 0 ) { be_print_err ( gettext ( "be_copy_zones: " "failed to snapshot zone BE (%s): %s\n" ) , ss , libzfs_error_description ( g_zfs ) ) ; if ( libzfs_errno ( g_zfs ) == EZFS_EXISTS ) { ret = BE_ERR_ZONE_SS_EXISTS ; } else { ret = zfs_err_to_be_err ( g_zfs ) ; } done } ( void ) snprintf ( new_zoneroot_ds , sizeof ( new_zoneroot_ds ) , "%s/%s" , zone_container_ds , new_zone_be_name ) ; bt . obe_name = zone_be_name ; bt . obe_root_ds = zoneroot_ds ; bt . obe_snap_name = snap_name ; bt . obe_altroot = temp_mntpt ; bt . nbe_name = new_zone_be_name ; bt . nbe_root_ds = new_zoneroot_ds ; if ( nvlist_alloc ( & bt . nbe_zfs_props , NV_UNIQUE_NAME , 0 ) != 0 ) { be_print_err ( gettext ( "be_copy_zones: " "internal error: out of memory\n" ) ) ; ret = BE_ERR_NOMEM ; done } if ( ( iret = be_clone_fs_callback ( z_zhp , & bt ) ) != 0 ) { z_zhp = NULL ; if ( iret != BE_ERR_BE_EXISTS ) { be_print_err ( gettext ( "be_copy_zones: " "failed to create zone BE clone for new " "zone BE %s\n" ) , new_zone_be_name ) ; ret = iret ; nvlist_free ( bt . nbe_zfs_props ) ; done } for ( num_retries = 1 ; num_retries < BE_AUTO_NAME_MAX_TRY ; num_retries ++ ) { ( void ) sleep ( 1 ) ; free ( new_zone_be_name ) ; if ( ( new_zone_be_name = be_auto_zone_be_name ( zone_container_ds , zone_be_name ) ) == NULL ) { be_print_err ( gettext ( "be_copy_zones: " "failed to generate auto name " "for zone BE.\n" ) ) ; ret = BE_ERR_AUTONAME ; nvlist_free ( bt . nbe_zfs_props ) ; done } ( void ) snprintf ( new_zoneroot_ds , sizeof ( new_zoneroot_ds ) , "%s/%s" , zone_container_ds , new_zone_be_name ) ; bt . nbe_name = new_zone_be_name ; bt . nbe_root_ds = new_zoneroot_ds ; if ( ( z_zhp = zfs_open ( g_zfs , zoneroot_ds , ZFS_TYPE_FILESYSTEM ) ) == NULL ) { be_print_err ( gettext ( "be_copy_zones: " "failed to open zone root " "dataset (%s): %s\n" ) , zoneroot_ds , libzfs_error_description ( g_zfs ) ) ; ret = zfs_err_to_be_err ( g_zfs ) ; nvlist_free ( bt . nbe_zfs_props ) ; done } iret = be_clone_fs_callback ( z_zhp , & bt ) ; z_zhp = NULL ; if ( iret == 0 ) { break ; } if ( iret != BE_ERR_BE_EXISTS ) { be_print_err ( gettext ( "be_copy_zones: " "failed to create zone BE clone " "for new zone BE %s\n" ) , new_zone_be_name ) ; ret = iret ; nvlist_free ( bt . nbe_zfs_props ) ; done } } if ( num_retries == BE_AUTO_NAME_MAX_TRY ) { be_print_err ( gettext ( "be_copy_zones: failed " "to create a unique auto zone BE name\n" ) ) ; free ( bt . nbe_name ) ; bt . nbe_name = NULL ; ret = BE_ERR_AUTONAME ; nvlist_free ( bt . nbe_zfs_props ) ; done } } nvlist_free ( bt . nbe_zfs_props ) ; z_zhp = NULL ; if ( ( z_zhp = zfs_open ( g_zfs , new_zoneroot_ds , ZFS_TYPE_FILESYSTEM ) ) == NULL ) { be_print_err ( gettext ( "be_copy_zones: " "failed to open the new zone BE root dataset " "(%s): %s\n" ) , new_zoneroot_ds , libzfs_error_description ( g_zfs ) ) ; ret = zfs_err_to_be_err ( g_zfs ) ; done } if ( zfs_prop_set ( z_zhp , BE_ZONE_PARENTBE_PROPERTY , uu_string ) != 0 ) { be_print_err ( gettext ( "be_copy_zones: " "failed to set parentbe property\n" ) ) ; ZFS_CLOSE ( z_zhp ) ; ret = zfs_err_to_be_err ( g_zfs ) ; done } if ( zfs_prop_set ( z_zhp , BE_ZONE_ACTIVE_PROPERTY , "on" ) != 0 ) { be_print_err ( gettext ( "be_copy_zones: " "failed to set active property\n" ) ) ; ZFS_CLOSE ( z_zhp ) ; ret = zfs_err_to_be_err ( g_zfs ) ; done } if ( ( ret = be_get_legacy_fs ( obe_name , obe_root_ds , zoneroot_ds , zoneroot , & fld ) ) != BE_SUCCESS ) { be_print_err ( gettext ( "be_copy_zones: " "failed to get legacy mounted file system " "list for zone %s\n" ) , zonename ) ; ZFS_CLOSE ( z_zhp ) ; done } if ( ( ret = be_update_zone_vfstab ( z_zhp , bt . nbe_name , zonepath_ds , zonepath_ds , & fld ) ) != BE_SUCCESS ) { be_print_err ( gettext ( "be_copy_zones: " "failed to update new BE's vfstab (%s)\n" ) , bt . nbe_name ) ; ZFS_CLOSE ( z_zhp ) ; be_free_fs_list ( & fld ) ; done } be_free_fs_list ( & fld ) ; ZFS_CLOSE ( z_zhp ) ; } done free ( snap_name ) ; if ( brands != NULL ) { z_free_brand_list ( brands ) ; } if ( zlist != NULL ) { z_free_zone_list ( zlist ) ; } if ( mounted_here ) { ( void ) _be_unmount ( obe_name , 0 ) ; } ZFS_CLOSE ( obe_zhp ) ; return ( ret ) ; } 