* / BGD_DECLARE ( ) gdImageCreateFromPngCtx ( ) { png_byte sig [ 8 ] jmpbuf_wrapper jbw png_structp png_ptr png_infop info_ptr png_uint_32 width height rowbytes w h res_x res_y int bit_depth color_type interlace_type unit_type int num_palette = 0 num_trans png_colorp palette png_color_16p trans_gray_rgb png_color_16p trans_color_rgb png_bytep trans png_bytep image_data = NULL png_bytepp row_pointers = NULL gdImagePtr im = NULL int i j * open = NULL volatile int transparent = - 1 volatile int palette_allocated = FALSE memset ( sig , 0 , sizeof ( sig ) ) if ( gdGetBuf ( sig , 8 , infile ) < 8 ) { return NULL ; ; } } ; if ( png_sig_cmp ( sig , 0 , 8 ) != 0 ) { return NULL ; } png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , & jbw , gdPngErrorHandler , NULL ) ; png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , NULL , NULL , NULL ) ; if ( png_ptr == NULL ) { gd_error ( "gd-png error: cannot allocate libpng main struct\n" ) ; return NULL ; } info_ptr = png_create_info_struct ( png_ptr ) ; if ( info_ptr == NULL ) { gd_error ( "gd-png error: cannot allocate libpng info struct\n" ) ; png_destroy_read_struct ( & png_ptr , NULL , NULL ) ; return NULL ; } if ( setjmp ( jbw . jmpbuf ) ) { gd_error ( "gd-png error: setjmp returns error condition 1\n" ) ; png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return NULL ; } png_set_sig_bytes ( png_ptr , 8 ) ; png_set_read_fn ( png_ptr , ( void * ) infile , gdPngReadData ) ; png_read_info ( png_ptr , info_ptr ) ; png_get_IHDR ( png_ptr , info_ptr , & width , & height , & bit_depth , & color_type , & interlace_type , NULL , NULL ) ; if ( ( color_type == PNG_COLOR_TYPE_RGB ) || ( color_type == PNG_COLOR_TYPE_RGB_ALPHA ) || color_type == PNG_COLOR_TYPE_GRAY_ALPHA ) { im = gdImageCreateTrueColor ( ( int ) width , ( int ) height ) ; } else { im = gdImageCreate ( ( int ) width , ( int ) height ) ; } if ( im == NULL ) { gd_error ( "gd-png error: cannot allocate gdImage struct\n" ) ; error } if ( bit_depth == 16 ) { png_set_strip_16 ( png_ptr ) ; } if ( bit_depth < 8 ) { png_set_packing ( png_ptr ) ; } if ( setjmp ( jbw . jmpbuf ) ) { gd_error ( "gd-png error: setjmp returns error condition 2\n" ) ; error } if ( png_get_valid ( png_ptr , info_ptr , PNG_INFO_pHYs ) ) { if ( png_get_pHYs ( png_ptr , info_ptr , & res_x , & res_y , & unit_type ) ) { switch ( unit_type ) { case PNG_RESOLUTION_METER : im -> res_x = DPM2DPI ( res_x , NULL ) ; im -> res_y = DPM2DPI ( res_y ) ; break ; } } } switch ( color_type ) { case PNG_COLOR_TYPE_PALETTE : png_get_PLTE ( png_ptr , info_ptr , & palette , & num_palette ) ; gd_error ( "gd-png color_type is palette, colors: %d\n" , num_palette ) ; if ( png_get_valid ( png_ptr , info_ptr , PNG_INFO_tRNS ) ) { int firstZero = 1 ; png_get_tRNS ( png_ptr , info_ptr , & trans , & num_trans , NULL ) ; for ( i = 0 ; i < num_trans ; ++ i ) { im -> alpha [ i ] = gdAlphaMax - ( trans [ i ] >> 1 ) ; if ( ( trans [ i ] == 0 ) && ( firstZero ) ) { transparent = i ; firstZero = 0 ; } } } break ; case PNG_COLOR_TYPE_GRAY : if ( ( palette = ( png_colorp ) gdMalloc ( 256 * sizeof ( png_color ) ) ) == NULL ) { gd_error ( "gd-png error: cannot allocate gray palette\n" ) ; error } palette_allocated = TRUE ; if ( bit_depth < 8 ) { num_palette = 1 << bit_depth ; for ( i = 0 ; i < 256 ; ++ i ) { j = ( 255 * i ) / ( num_palette - 1 ) ; palette [ i ] . red = palette [ i ] . green = palette [ i ] . blue = j ; } } else { num_palette = 256 ; for ( i = 0 ; i < 256 ; ++ i ) { palette [ i ] . red = palette [ i ] . green = palette [ i ] . blue = i ; } } if ( png_get_valid ( png_ptr , info_ptr , PNG_INFO_tRNS ) ) { png_get_tRNS ( png_ptr , info_ptr , NULL , NULL , & trans_gray_rgb ) ; if ( bit_depth == 16 ) { transparent = trans_gray_rgb -> gray >> 8 ; } else { transparent = trans_gray_rgb -> gray ; } } break ; case PNG_COLOR_TYPE_GRAY_ALPHA : png_set_gray_to_rgb ( png_ptr ) ; case PNG_COLOR_TYPE_RGB : case PNG_COLOR_TYPE_RGB_ALPHA : if ( png_get_valid ( png_ptr , info_ptr , PNG_INFO_tRNS ) ) { png_get_tRNS ( png_ptr , info_ptr , NULL , NULL , & trans_color_rgb ) ; if ( bit_depth == 16 ) { transparent = gdTrueColor ( trans_color_rgb -> red >> 8 , trans_color_rgb -> green >> 8 , trans_color_rgb -> blue >> 8 ) ; } else { transparent = gdTrueColor ( trans_color_rgb -> red , trans_color_rgb -> green , trans_color_rgb -> blue ) ; } } break ; default : gd_error ( "gd-png color_type is unknown: %d\n" , color_type ) ; error } png_read_update_info ( png_ptr , info_ptr ) ; rowbytes = png_get_rowbytes ( png_ptr , info_ptr ) ; if ( overflow2 ( rowbytes , height ) ) { error } image_data = ( png_bytep ) gdMalloc ( rowbytes * height ) ; if ( ! image_data ) { gd_error ( "gd-png error: cannot allocate image data\n" ) ; error } if ( overflow2 ( height , sizeof ( png_bytep ) ) ) { error } row_pointers = ( png_bytepp ) gdMalloc ( height * sizeof ( png_bytep ) ) ; if ( ! row_pointers ) { gd_error ( "gd-png error: cannot allocate row pointers\n" ) ; error } if ( setjmp ( jbw . jmpbuf ) ) { gd_error ( "gd-png error: setjmp returns error condition 3\n" ) ; error } for ( h = 0 ; h < height ; ++ h ) { row_pointers [ h ] = image_data + h * rowbytes ; } png_read_image ( png_ptr , row_pointers ) ; png_read_end ( png_ptr , NULL ) ; if ( ! im -> trueColor ) { im -> colorsTotal = num_palette ; open = im -> open ; for ( i = 0 ; i < num_palette ; ++ i ) { im -> red [ i ] = palette [ i ] . red ; im -> green [ i ] = palette [ i ] . green ; im -> blue [ i ] = palette [ i ] . blue ; open [ i ] = 1 ; } for ( i = num_palette ; i < gdMaxColors ; ++ i ) { open [ i ] = 1 ; } } im -> transparent = transparent ; im -> interlace = ( interlace_type == PNG_INTERLACE_ADAM7 ) ; png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; switch ( color_type ) { case PNG_COLOR_TYPE_RGB : for ( h = 0 ; h < height ; h ++ ) { int boffset = 0 ; for ( w = 0 ; w < width ; w ++ ) { register png_byte r = row_pointers [ h ] [ boffset ++ ] ; register png_byte g = row_pointers [ h ] [ boffset ++ ] ; register png_byte b = row_pointers [ h ] [ boffset ++ ] ; im -> tpixels [ h ] [ w ] = gdTrueColor ( r , g , b ) ; } } break ; case PNG_COLOR_TYPE_GRAY_ALPHA : case PNG_COLOR_TYPE_RGB_ALPHA : for ( h = 0 ; h < height ; h ++ ) { int boffset = 0 ; for ( w = 0 ; w < width ; w ++ ) { register png_byte r = row_pointers [ h ] [ boffset ++ ] ; register png_byte g = row_pointers [ h ] [ boffset ++ ] ; register png_byte b = row_pointers [ h ] [ boffset ++ ] ; register png_byte a = gdAlphaMax - ( row_pointers [ h ] [ boffset ++ ] >> 1 ) ; im -> tpixels [ h ] [ w ] = gdTrueColorAlpha ( r , g , b , a ) ; } } break ; default : if ( ! im -> trueColor ) { for ( h = 0 ; h < height ; ++ h ) { for ( w = 0 ; w < width ; ++ w ) { register png_byte idx = row_pointers [ h ] [ w ] ; im -> pixels [ h ] [ w ] = idx ; open [ idx ] = 0 ; } } } } if ( ! im -> trueColor ) { for ( i = num_palette ; i < gdMaxColors ; ++ i ) { if ( ! open [ i ] ) { fprintf ( stderr , "gd-png warning: image data references out-of-range" " color index (%d)\n" , i ) ; } } } done if ( palette_allocated ) { gdFree ( palette ) ; } if ( image_data ) { gdFree ( image_data ) ; } if ( row_pointers ) { gdFree ( row_pointers ) ; } return im ; error png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; if ( im ) { gdImageDestroy ( im ) ; im = NULL ; } done 