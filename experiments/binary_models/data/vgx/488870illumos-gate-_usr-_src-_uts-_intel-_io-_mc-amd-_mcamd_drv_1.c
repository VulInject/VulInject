static int mc_attach ( dev_info_t * dip , ddi_attach_cmd_t cmd ) { mc_pcicfg_hdl_t cfghdl ; const mc_bind_map_t * bm ; const char * bindnm ; char * unitstr = NULL ; enum mc_funcnum func ; long unitaddr ; int chipid , rc ; mc_t * mc ; if ( cmd != DDI_ATTACH || mc_no_attach != 0 ) { return ( DDI_FAILURE ) ; } bindnm = ddi_binding_name ( dip ) ; for ( bm = mc_bind_map ; bm -> bm_bindnm != NULL ; bm ++ ) { if ( strcmp ( bindnm , bm -> bm_bindnm ) == 0 ) { func = bm -> bm_func ; break ; } } if ( bm -> bm_bindnm == NULL ) { return ( DDI_FAILURE ) ; } if ( ddi_prop_lookup_string ( DDI_DEV_T_ANY , dip , DDI_PROP_DONTPASS , "unit-address" , & unitstr ) != DDI_PROP_SUCCESS ) { cmn_err ( CE_WARN , "failed to find unit-address for %s" , bindnm ) ; return ( DDI_FAILURE ) ; } rc = ddi_strtol ( unitstr , NULL , 16 , & unitaddr ) ; ASSERT ( rc == 0 && unitaddr >= MC_AMD_DEV_OFFSET ) ; if ( rc != 0 || unitaddr < MC_AMD_DEV_OFFSET ) { cmn_err ( CE_WARN , "failed to parse unit address %s for %s\n" , unitstr , bindnm ) ; ddi_prop_free ( unitstr ) ; return ( DDI_FAILURE ) ; } ddi_prop_free ( unitstr ) ; chipid = unitaddr - MC_AMD_DEV_OFFSET ; rw_enter ( & mc_lock , RW_WRITER ) ; for ( mc = mc_list ; mc != NULL ; mc = mc -> mc_next ) { if ( mc -> mc_props . mcp_num == chipid ) { break ; } } if ( mc == NULL ) { mc = mc_create ( chipid , dip ) ; if ( mc == NULL ) { rw_exit ( & mc_lock ) ; return ( DDI_FAILURE ) ; } } else { mc_snapshot_destroy ( mc ) ; } mc_fm_init ( dip ) ; ASSERT ( mc -> mc_funcs [ func ] . mcf_devi == NULL ) ; mc -> mc_funcs [ func ] . mcf_devi = dip ; mc -> mc_funcs [ func ] . mcf_instance = ddi_get_instance ( dip ) ; mc -> mc_ref ++ ; ( void ) ddi_prop_update_string ( DDI_DEV_T_NONE , dip , "model" , ( char * ) bm -> bm_model ) ; ( void ) ddi_prop_update_int ( DDI_DEV_T_NONE , dip , "chip-id" , mc -> mc_props . mcp_num ) ; if ( bm -> bm_mkprops != NULL && mc_pcicfg_setup ( mc , bm -> bm_func , & cfghdl ) == DDI_SUCCESS ) { bm -> bm_mkprops ( cfghdl , mc ) ; mc_pcicfg_teardown ( cfghdl ) ; } if ( func == MC_FUNC_DEVIMAP ) { mc_props_t * mcp = & mc -> mc_props ; int dram_present = 0 ; if ( ddi_create_minor_node ( dip , "mc-amd" , S_IFCHR , mcp -> mcp_num , "ddi_mem_ctrl" , 0 ) != DDI_SUCCESS ) { cmn_err ( CE_WARN , "failed to create minor node for chip " "%d memory controller\n" , ( chipid_t ) mcp -> mcp_num ) ; } cmi_hdl_walk ( mc_attach_cb , ( void * ) mc , ( void * ) & mcp -> mcp_num , NULL ) ; if ( mcp -> mcp_lim != mcp -> mcp_base ) { mc_cs_t * mccs ; for ( mccs = mc -> mc_cslist ; mccs != NULL ; mccs = mccs -> mccs_next ) { if ( mccs -> mccs_props . csp_csbe ) { dram_present = 1 ; break ; } } } if ( dram_present && ! mc_ecc_enabled ( mc ) ) { rc = 1 ; } if ( ! dram_present ) { rc = 0 ; } else { rc = mc_scrubber_enable ( mc ) ; } if ( rc == CMI_SUCCESS && ! mc_sw_scrub_disabled ++ ) { cmi_mc_sw_memscrub_disable ( ) ; } mc_report_testfails ( mc ) ; } nvlist_free ( mc -> mc_nvl ) ; mc -> mc_nvl = mc_nvl_create ( mc ) ; rw_exit ( & mc_lock ) ; return ( DDI_SUCCESS ) ; } 