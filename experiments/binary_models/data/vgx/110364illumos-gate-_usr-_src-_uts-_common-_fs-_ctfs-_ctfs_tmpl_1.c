static int ctfs_tmpl_ioctl ( vnode_t * vp , int cmd , intptr_t arg , int flag , cred_t * cr , int * rvalp , caller_context_t * ct ) { ctfs_tmplnode_t * tmplnode = vp -> v_data ; ct_kparam_t kparam ; ct_param_t * param = & kparam . param ; ctid_t ctid ; int error ; switch ( cmd ) { case CT_TACTIVATE : ASSERT ( tmplnode -> ctfs_tmn_tmpl != NULL ) ; ctmpl_activate ( tmplnode -> ctfs_tmn_tmpl ) ; break ; case CT_TCLEAR : ASSERT ( tmplnode -> ctfs_tmn_tmpl != NULL ) ; ctmpl_clear ( tmplnode -> ctfs_tmn_tmpl ) ; break ; case CT_TCREATE : ASSERT ( tmplnode -> ctfs_tmn_tmpl != NULL ) ; error = ctmpl_create ( tmplnode -> ctfs_tmn_tmpl , & ctid ) ; * rvalp = ctid ; break ; case CT_TSET : error = ctparam_copyin ( ( void * ) arg , & kparam , flag , cmd ) ; if ( error != 0 ) { return ( error ) ; } error = ctmpl_set ( tmplnode -> ctfs_tmn_tmpl , & kparam , cr ) ; kmem_free ( kparam . ctpm_kbuf , param -> ctpm_size ) ; return ( error ) ; case CT_TGET : error = ctparam_copyin ( ( void * ) arg , & kparam , flag , cmd ) ; if ( error != 0 ) { return ( error ) ; } error = ctmpl_get ( tmplnode -> ctfs_tmn_tmpl , & kparam ) ; if ( error != 0 ) { kmem_free ( kparam . ctpm_kbuf , param -> ctpm_size ) ; } else { error = ctparam_copyout ( & kparam , ( void * ) arg , flag ) ; } return ( error ) ; default : return ( EINVAL ) ; } return ( 0 ) ; } 