query_segment_type ( ) { unsigned long dummy , vmrc ; int diag_cc , rc , i ; struct qout64 * qout ; struct qin64 * qin ; qin = kmalloc ( sizeof ( * qin ) , GFP_KERNEL | GFP_DMA ) ; qout = kmalloc ( sizeof ( * qout ) , GFP_KERNEL | GFP_DMA ) ; if ( ( qin == NULL ) || ( qout == NULL ) ) { rc = - ENOMEM ; out_free } qin -> qopcode = DCSS_FINDSEGA ; qin -> qoutptr = ( unsigned long ) qout ; qin -> qoutlen = sizeof ( qout64 ) ; memcpy ( qin -> qname , seg -> dcss_name , 8 ) ; diag_cc = dcss_diag ( & segext_scode , qin , & dummy , & vmrc ) ; if ( diag_cc < 0 ) { rc = diag_cc ; out_free } if ( diag_cc > 1 ) { pr_warn ( "Querying a DCSS type failed with rc=%ld\n" , vmrc ) ; rc = dcss_diag_translate_rc ( vmrc ) ; out_free } if ( qout -> segcnt > 6 ) { rc = - EOPNOTSUPP ; out_free } if ( qout -> segcnt == 1 ) { seg -> vm_segtype = qout -> range [ 0 ] . start & 0xff ; } else { unsigned long start = qout -> segstart >> PAGE_SHIFT ; for ( i = 0 ; i < qout -> segcnt ; i ++ ) { if ( ( ( qout -> range [ i ] . start & 0xff ) != SEG_TYPE_EW ) && ( ( qout -> range [ i ] . start & 0xff ) != SEG_TYPE_EN ) ) { rc = - EOPNOTSUPP ; out_free } if ( start != qout -> range [ i ] . start >> PAGE_SHIFT ) { rc = - EOPNOTSUPP ; out_free } start = ( qout -> range [ i ] . end >> PAGE_SHIFT ) + 1 ; } seg -> vm_segtype = SEG_TYPE_EWEN ; } seg -> start_addr = qout -> segstart ; seg -> end = qout -> segend ; memcpy ( seg -> range , qout -> range , 6 * sizeof ( qrange ) ) ; seg -> segcnt = qout -> segcnt ; rc = 0 ; out_free kfree ( qin ) ; return rc ; } 