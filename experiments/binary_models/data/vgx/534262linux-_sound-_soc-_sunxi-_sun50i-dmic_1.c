static int sun50i_dmic_probe ( struct platform_device * pdev ) { struct sun50i_dmic_dev * host ; struct resource * res ; int ret ; void __iomem * base ; host = devm_kzalloc ( & pdev -> dev , sizeof ( * host ) , GFP_KERNEL ) ; base = devm_platform_get_and_ioremap_resource ( pdev , 0 , & res ) ; if ( IS_ERR ( base ) ) { return dev_err_probe ( & pdev -> dev , PTR_ERR ( base ) , "get resource failed.\n" ) ; } host -> regmap = devm_regmap_init_mmio ( & pdev -> dev , base , & sun50i_dmic_regmap_config ) ; host -> bus_clk = devm_clk_get ( & pdev -> dev , "bus" ) ; if ( IS_ERR ( host -> bus_clk ) ) { return dev_err_probe ( & pdev -> dev , PTR_ERR ( host -> bus_clk ) , "failed to get bus clock.\n" ) ; } host -> dmic_clk = devm_clk_get ( & pdev -> dev , "mod" ) ; if ( IS_ERR ( host -> dmic_clk ) ) { return dev_err_probe ( & pdev -> dev , PTR_ERR ( host -> dmic_clk ) , "failed to get dmic clock.\n" ) ; } host -> dma_params_rx . addr = res -> start + SUN50I_DMIC_DATA ; host -> dma_params_rx . maxburst = 8 ; platform_set_drvdata ( pdev , host ) ; host -> rst = devm_reset_control_get_optional_exclusive ( & pdev -> dev , NULL ) ; if ( IS_ERR ( host -> rst ) ) { return dev_err_probe ( & pdev -> dev , PTR_ERR ( host -> rst ) , "Failed to get reset.\n" ) ; } reset_control_deassert ( host -> rst ) ; ret = devm_snd_soc_register_component ( & pdev -> dev , & sun50i_dmic_component , & sun50i_dmic_dai , 1 ) ; if ( ret ) { return dev_err_probe ( & pdev -> dev , ret , "failed to register component.\n" ) ; } pm_runtime_enable ( & pdev -> dev ) ; if ( ! pm_runtime_enabled ( & pdev -> dev ) ) { ret = sun50i_dmic_runtime_resume ( & pdev -> dev ) ; if ( ret ) { err_disable_runtime_pm } } ret = devm_snd_dmaengine_pcm_register ( & pdev -> dev , NULL , 0 ) ; if ( ret ) { err_suspend } return 0 ; err_suspend if ( ! pm_runtime_status_suspended ( & pdev -> dev ) ) { sun50i_dmic_runtime_suspend ( & pdev -> dev ) ; } err_disable_runtime_pm pm_runtime_disable ( & pdev -> dev ) ; return ret ; } 