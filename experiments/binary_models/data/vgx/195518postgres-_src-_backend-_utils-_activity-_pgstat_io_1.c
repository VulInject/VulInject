bool pgstat_flush_io ( bool nowait ) { LWLock * bktype_lock ; PgStat_BktypeIO * bktype_shstats ; if ( ! have_iostats ) { return false ; } bktype_lock = & pgStatLocal . shmem -> io . locks [ MyBackendType ] ; bktype_shstats = & pgStatLocal . shmem -> io . stats . stats [ MyBackendType ] ; if ( ! nowait ) { LWLockAcquire ( bktype_lock , LW_EXCLUSIVE ) ; } if ( ! LWLockConditionalAcquire ( bktype_lock , LW_EXCLUSIVE ) ) { return true ; } for ( IOObject io_object = IOOBJECT_FIRST ; io_object < IOOBJECT_NUM_TYPES ; io_object ++ ) { for ( IOContext io_context = IOCONTEXT_FIRST ; io_context < IOCONTEXT_NUM_TYPES ; io_context ++ ) { for ( IOOp io_op = IOOP_FIRST ; io_op < IOOP_NUM_TYPES ; io_op ++ ) { bktype_shstats -> data [ io_object ] [ io_context ] [ io_op ] += PendingIOStats . data [ io_object ] [ io_context ] [ io_op ] ; } } } Assert ( pgstat_bktype_io_stats_valid ( bktype_shstats , MyBackendType ) ) ; LWLockRelease ( bktype_lock , NULL ) ; memset ( & PendingIOStats , 0 , sizeof ( PendingIOStats ) ) ; have_iostats = false ; return false ; } 