static int madera_dai_set_sysclk ( struct snd_soc_dai * dai , int clk_id , unsigned int freq , int dir ) { struct snd_soc_component * component = dai -> component ; struct snd_soc_dapm_context * dapm = snd_soc_component_get_dapm ( component ) ; struct madera_priv * priv = snd_soc_component_get_drvdata ( component ) ; struct madera_dai_priv * dai_priv = & priv -> dai [ dai -> id - 1 ] ; struct snd_soc_dapm_route routes [ 2 ] ; int is_sync ; is_sync = madera_is_syncclk ( clk_id ) ; if ( is_sync < 0 ) { dev_err ( component -> dev , "Illegal DAI clock id %d\n" , clk_id ) ; return is_sync ; } if ( is_sync == madera_is_syncclk ( dai_priv -> clk ) ) { return 0 ; } if ( snd_soc_dai_active ( dai ) ) { dev_err ( component -> dev , "Can't change clock on active DAI %d\n" , dai -> id ) ; return - EBUSY ; } dev_dbg ( component -> dev , "Setting AIF%d to %s\n" , dai -> id , is_sync ?"SYSCLK" : "ASYNCCLK" ) ; routes [ 0 ] . sink = dai -> driver -> capture . stream_name ; routes [ 1 ] . sink = dai -> driver -> playback . stream_name ; routes [ 0 ] . source = "ASYNCCLK" ; routes [ 1 ] . source = "ASYNCCLK" ; if ( is_sync ) { snd_soc_dapm_del_routes ( dapm , routes , ARRAY_SIZE ( routes ) ) ; } else { snd_soc_dapm_add_routes ( dapm , routes , ARRAY_SIZE ( routes ) ) ; } dai_priv -> clk = clk_id ; return snd_soc_dapm_sync ( dapm ) ; } 