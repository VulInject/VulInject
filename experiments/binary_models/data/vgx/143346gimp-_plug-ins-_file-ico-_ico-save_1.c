ani_save_image ( , , , , , , , , , ) { FILE * fp ; gint32 i ; gchar * str ; GimpParasite * parasite = NULL ; gchar id [ 5 ] ; guint32 size ; guint8 padding = 0 ; gint32 offset , ofs_size_riff , ofs_size_list , ofs_size_icon ; gint32 ofs_size_info = 0 ; gint32 ofs_metadata = 0 ; IcoSaveInfo info ; if ( ! ico_save_init ( image , run_mode , & info , * n_hot_spot_x , * hot_spot_x , * n_hot_spot_y , * hot_spot_y , error ) ) { return GIMP_PDB_EXECUTION_ERROR ; } info . is_cursor = TRUE ; header -> bSizeOf = sizeof ( * header ) ; header -> frames = info . num_icons ; header -> steps = info . num_icons ; header -> x = 0 ; header -> y = 0 ; if ( info . depths [ 0 ] == 24 ) { header -> bpp = 4 ; header -> planes = 1 ; } else { header -> bpp = 0 ; header -> planes = 0 ; } header -> flags = 1 ; parasite = gimp_image_get_parasite ( image , "ani-header" ) ; if ( parasite ) { gchar * parasite_data ; guint32 parasite_size ; gint jif_rate ; parasite_data = ( gchar * ) gimp_parasite_get_data ( parasite , & parasite_size ) ; parasite_data = g_strndup ( parasite_data , parasite_size ) ; if ( sscanf ( parasite_data , "%i" , & jif_rate ) == 1 ) { header -> jif_rate = jif_rate ; } gimp_parasite_free ( parasite ) ; } parasite = gimp_image_get_parasite ( image , "ani-info-inam" ) ; if ( parasite ) { guint32 parasite_size ; gchar * inam = NULL ; inam = ( gchar * ) gimp_parasite_get_data ( parasite , & parasite_size ) ; ani_info -> inam = g_strndup ( inam , parasite_size ) ; gimp_parasite_free ( parasite ) ; } parasite = gimp_image_get_parasite ( image , "ani-info-iart" ) ; if ( parasite ) { guint32 parasite_size ; gchar * iart = NULL ; iart = ( gchar * ) gimp_parasite_get_data ( parasite , & parasite_size ) ; ani_info -> iart = g_strndup ( iart , parasite_size ) ; gimp_parasite_free ( parasite ) ; } if ( run_mode == GIMP_RUN_INTERACTIVE ) { if ( ! ico_save_dialog ( image , & info , header , ani_info ) ) { return GIMP_PDB_CANCEL ; } for ( i = 1 ; i < info . num_icons ; i ++ ) { info . depths [ i ] = info . depths [ 0 ] ; info . default_depths [ i ] = info . default_depths [ 0 ] ; info . compress [ i ] = info . compress [ 0 ] ; } } gimp_progress_init_printf ( _ ( "Exporting '%s'" ) , gimp_file_get_utf8_name ( file ) ) ; fp = g_fopen ( g_file_peek_path ( file ) , "wb" ) ; if ( ! fp ) { g_set_error ( error , G_FILE_ERROR , g_file_error_from_errno ( errno ) , _ ( "Could not open '%s' for writing: %s" ) , gimp_file_get_utf8_name ( file ) , g_strerror ( errno ) ) ; return GIMP_PDB_EXECUTION_ERROR ; } strcpy ( id , "RIFF" ) ; size = 0 ; fwrite ( id , 4 , 1 , fp ) ; ofs_size_riff = ftell ( fp ) ; fwrite ( & size , sizeof ( size ) , 1 , fp ) ; strcpy ( id , "ACON" ) ; fwrite ( id , 4 , 1 , fp ) ; if ( ( ani_info -> inam && strlen ( ani_info -> inam ) > 0 ) || ( ani_info -> iart && strlen ( ani_info -> iart ) > 0 ) ) { gint32 string_size ; strcpy ( id , "LIST" ) ; fwrite ( id , 4 , 1 , fp ) ; ofs_size_info = ftell ( fp ) ; fwrite ( & size , sizeof ( size ) , 1 , fp ) ; strcpy ( id , "INFO" ) ; fwrite ( id , 4 , 1 , fp ) ; if ( ani_info -> inam && strlen ( ani_info -> inam ) > 0 ) { strcpy ( id , "INAM" ) ; fwrite ( id , 4 , 1 , fp ) ; string_size = strlen ( ani_info -> inam ) + 1 ; fwrite ( & string_size , 4 , 1 , fp ) ; fwrite ( ani_info -> inam , string_size , 1 , fp ) ; ofs_metadata += 4 ; if ( string_size % 2 != 0 ) { fwrite ( & padding , sizeof ( padding ) , 1 , fp ) ; } } if ( ani_info -> iart && strlen ( ani_info -> iart ) > 0 ) { strcpy ( id , "IART" ) ; fwrite ( id , 4 , 1 , fp ) ; string_size = strlen ( ani_info -> iart ) + 1 ; fwrite ( & string_size , 4 , 1 , fp ) ; fwrite ( ani_info -> iart , string_size , 1 , fp ) ; ofs_metadata += 4 ; if ( string_size % 2 != 0 ) { fwrite ( & padding , sizeof ( padding ) , 1 , fp ) ; } } fseek ( fp , 0L , SEEK_END ) ; size = ftell ( fp ) - ofs_size_info - 4 ; fseek ( fp , ofs_size_info , SEEK_SET ) ; fwrite ( & size , sizeof ( size ) , 1 , fp ) ; fseek ( fp , 0L , SEEK_END ) ; } strcpy ( id , "anih" ) ; size = sizeof ( * header ) ; fwrite ( id , 4 , 1 , fp ) ; fwrite ( & size , sizeof ( size ) , 1 , fp ) ; fwrite ( header , sizeof ( * header ) , 1 , fp ) ; strcpy ( id , "LIST" ) ; fwrite ( id , 4 , 1 , fp ) ; ofs_size_list = ftell ( fp ) ; fwrite ( & size , sizeof ( size ) , 1 , fp ) ; strcpy ( id , "fram" ) ; fwrite ( id , 4 , 1 , fp ) ; strcpy ( id , "icon" ) ; for ( i = 0 ; i < info . num_icons ; i ++ ) { GimpPDBStatusType status ; fwrite ( id , 4 , 1 , fp ) ; ofs_size_icon = ftell ( fp ) ; fwrite ( & size , sizeof ( size ) , 1 , fp ) ; offset = ftell ( fp ) ; status = shared_save_image ( file , fp , image , run_mode , n_hot_spot_x , hot_spot_x , n_hot_spot_y , hot_spot_y , offset , i , error , & info ) ; if ( status != GIMP_PDB_SUCCESS ) { ico_save_info_free ( & info ) ; g_free ( ani_info -> inam ) ; g_free ( ani_info -> iart ) ; fclose ( fp ) ; return GIMP_PDB_EXECUTION_ERROR ; } fseek ( fp , 0L , SEEK_END ) ; size = ftell ( fp ) - offset ; fseek ( fp , ofs_size_icon , SEEK_SET ) ; fwrite ( & size , sizeof ( size ) , 1 , fp ) ; fseek ( fp , 0L , SEEK_END ) ; gimp_progress_update ( ( gdouble ) i / ( gdouble ) info . num_icons ) ; } ico_save_info_free ( & info ) ; fseek ( fp , 0L , SEEK_END ) ; size = ftell ( fp ) ; size -= ofs_metadata ; fseek ( fp , ofs_size_riff , SEEK_SET ) ; fwrite ( & size , sizeof ( size ) , 1 , fp ) ; size -= ofs_size_list ; size += ( ofs_metadata - 4 ) ; fseek ( fp , ofs_size_list , SEEK_SET ) ; fwrite ( & size , sizeof ( size ) , 1 , fp ) ; fclose ( fp ) ; str = g_strdup_printf ( "%d" , header -> jif_rate ) ; parasite = gimp_parasite_new ( "ani-header" , GIMP_PARASITE_PERSISTENT , strlen ( str ) + 1 , ( gpointer ) str ) ; g_free ( str ) ; gimp_image_attach_parasite ( image , parasite ) ; gimp_parasite_free ( parasite ) ; if ( ani_info -> inam && strlen ( ani_info -> inam ) > 0 ) { str = g_strdup_printf ( "%s" , ani_info -> inam ) ; parasite = gimp_parasite_new ( "ani-info-inam" , GIMP_PARASITE_PERSISTENT , strlen ( ani_info -> inam ) + 1 , ( gpointer ) str ) ; g_free ( str ) ; gimp_image_attach_parasite ( image , parasite ) ; gimp_parasite_free ( parasite ) ; } if ( ani_info -> iart && strlen ( ani_info -> iart ) > 0 ) { str = g_strdup_printf ( "%s" , ani_info -> iart ) ; parasite = gimp_parasite_new ( "ani-info-iart" , GIMP_PARASITE_PERSISTENT , strlen ( ani_info -> iart ) + 1 , ( gpointer ) str ) ; g_free ( str ) ; gimp_image_attach_parasite ( image , parasite ) ; gimp_parasite_free ( parasite ) ; } gimp_progress_update ( 1.0 ) ; return GIMP_PDB_SUCCESS ; } 