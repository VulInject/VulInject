extern void restorefs ( ) extern int processors ; extern int reproducible ; static int interrupted = 0 ; static pthread_t restore_thread ; void * restore_thrd ( void * arg ) { sigset_t sigmask , old_mask ; int i , sig ; sigemptyset ( & sigmask ) ; sigaddset ( & sigmask , SIGINT ) ; sigaddset ( & sigmask , SIGTERM ) ; sigaddset ( & sigmask , SIGUSR1 ) ; pthread_sigmask ( SIG_BLOCK , & sigmask , & old_mask ) ; while ( 1 ) { sigwait ( & sigmask , & sig ) ; if ( ( sig == SIGINT || sig == SIGTERM ) && ! interrupted ) { ERROR ( "Interrupting will restore original " "filesystem!\n" ) ; ERROR ( "Interrupt again to quit\n" ) ; interrupted = TRUE ; continue ; } set_progressbar_state ( FALSE ) ; disable_info ( ) ; pthread_cancel ( reader_thread ) ; pthread_join ( reader_thread , NULL ) ; queue_flush ( to_deflate ) ; for ( i = 0 ; i < processors ; i ++ ) { pthread_cancel ( deflator_thread [ i ] ) ; } for ( i = 0 ; i < processors ; i ++ ) { pthread_join ( deflator_thread [ i ] , NULL ) ; } queue_flush ( to_process_frag ) ; for ( i = 0 ; i < processors ; i ++ ) { pthread_cancel ( frag_thread [ i ] ) ; } for ( i = 0 ; i < processors ; i ++ ) { pthread_join ( frag_thread [ i ] , NULL ) ; } seq_queue_flush ( to_main ) ; pthread_cancel ( main_thread , NULL ) ; pthread_join ( main_thread , NULL ) ; queue_flush ( to_frag ) ; for ( i = 0 ; i < processors ; i ++ ) { pthread_cancel ( frag_deflator_thread [ i ] ) ; } for ( i = 0 ; i < processors ; i ++ ) { pthread_join ( frag_deflator_thread [ i ] , NULL ) ; } if ( reproducible ) { seq_queue_flush ( to_order ) ; pthread_cancel ( order_thread ) ; pthread_join ( order_thread , NULL ) ; } queue_flush ( to_writer ) ; pthread_cancel ( writer_thread ) ; pthread_join ( writer_thread , NULL ) ; TRACE ( "All threads cancelled\n" ) ; restorefs ( ) ; } } 