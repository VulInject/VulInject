int t_krcvudata ( TIUSER * tiptr , struct t_kunitdata * unitdata , int * type , int * uderr ) { int len ; int hdrsz ; union T_primitives * pptr ; struct file * fp ; mblk_t * bp ; mblk_t * nbp ; mblk_t * mp ; mblk_t * tmp ; int error ; int flag ; fp = tiptr -> fp ; if ( type == NULL || uderr == NULL ) { return ( EINVAL ) ; } error = 0 ; unitdata -> udata . buf = NULL ; if ( unitdata -> udata . udata_mp ) { KTLILOG ( 2 , "t_krcvudata: freeing existing message block\n" , 0 ) ; freemsg ( unitdata -> udata . udata_mp ) ; unitdata -> udata . udata_mp = NULL ; } mutex_enter ( & fp -> f_tlock ) ; flag = fp -> f_flag ; mutex_exit ( & fp -> f_tlock ) ; if ( ( error = tli_recv ( tiptr , & bp , flag ) ) != 0 ) { return ( error ) ; } switch ( bp -> b_datap -> db_type ) { case M_PROTO : pptr = ( T_primitives * ) bp -> b_rptr ; switch ( pptr -> type ) { case T_UNITDATA_IND : KTLILOG ( 2 , "t_krcvudata: Got T_UNITDATA_IND\n" , 0 ) ; hdrsz = MBLKL ( bp ) ; if ( hdrsz < TUNITDATAINDSZ || hdrsz < ( pptr -> unitdata_ind . OPT_length + pptr -> unitdata_ind . OPT_offset ) || hdrsz < ( pptr -> unitdata_ind . SRC_length + pptr -> unitdata_ind . SRC_offset ) ) { error = EPROTO ; freemsg ( bp ) ; break ; } len = MIN ( pptr -> unitdata_ind . SRC_length , unitdata -> addr . maxlen ) ; bcopy ( bp -> b_rptr + pptr -> unitdata_ind . SRC_offset , unitdata -> addr . buf , len ) ; unitdata -> addr . len = len ; len = MIN ( pptr -> unitdata_ind . OPT_length , unitdata -> opt . maxlen ) ; bcopy ( bp -> b_rptr + pptr -> unitdata_ind . OPT_offset , unitdata -> opt . buf , len ) ; unitdata -> opt . len = len ; bp -> b_rptr += hdrsz ; nbp = NULL ; mp = bp ; while ( mp ) { if ( bp -> b_wptr == bp -> b_rptr ) { KTLILOG ( 2 , "t_krcvudata: zero length block\n" , 0 ) ; tmp = mp -> b_cont ; if ( nbp ) { nbp -> b_cont = tmp ; } else { bp = tmp ; } freeb ( mp ) ; mp = tmp ; } else { nbp = mp ; mp = mp -> b_cont ; } } { mblk_t * tp ; tp = bp ; while ( tp ) { struct datab * dbp = tp -> b_datap ; frtn_t * frp = dbp -> db_frtnp ; KTLILOG ( 2 , "t_krcvudata: bp %x, " , tp ) ; KTLILOG ( 2 , "db_size %x, " , dbp -> db_lim - dbp -> db_base ) ; KTLILOG ( 2 , "db_ref %x" , dbp -> db_ref ) ; if ( frp != NULL ) { KTLILOG ( 2 , ", func: %x" , frp -> free_func ) ; } KTLILOG ( 2 , ", arg %x\n" , frp -> free_arg ) ; } else { KTLILOG ( 2 , "\n" , 0 ) ; } tp = tp -> b_cont ; } } } } 