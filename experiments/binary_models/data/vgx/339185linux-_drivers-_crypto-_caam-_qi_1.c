static int alloc_rsp_fq_cpu ( struct device * qidev , unsigned int cpu ) { struct qm_mcc_initfq opts ; struct qman_fq * fq ; int ret ; fq = kzalloc ( sizeof ( * fq ) , GFP_KERNEL ) ; if ( ! fq ) { return - ENOMEM ; } fq -> cb . dqrr = caam_rsp_fq_dqrr_cb ; ret = qman_create_fq ( 0 , QMAN_FQ_FLAG_NO_ENQUEUE | QMAN_FQ_FLAG_DYNAMIC_FQID , fq ) ; if ( ret ) { dev_err ( qidev , "Rsp FQ create failed\n" ) ; kfree ( fq ) ; return - ENODEV ; } opts . we_mask = cpu_to_be16 ( QM_INITFQ_WE_FQCTRL | QM_INITFQ_WE_DESTWQ | QM_INITFQ_WE_CONTEXTB | QM_INITFQ_WE_CONTEXTA | QM_INITFQ_WE_CGID ) ; opts . fqd . fq_ctrl = cpu_to_be16 ( QM_FQCTRL_CTXASTASHING | QM_FQCTRL_CPCSTASH | QM_FQCTRL_CGE ) ; qm_fqd_set_destwq ( & opts . fqd , qman_affine_channel ( cpu ) , 3 ) ; opts . fqd . cgid = qipriv . cgr . cgrid ; opts . fqd . context_a . stashing . exclusive = QM_STASHING_EXCL_CTX | QM_STASHING_EXCL_DATA ; qm_fqd_set_stashing ( & opts . fqd , 0 , 1 , 1 ) ; ret = qman_init_fq ( fq , QMAN_INITFQ_FLAG_SCHED , & opts ) ; if ( ret ) { dev_err ( qidev , "Rsp FQ init failed\n" ) ; kfree ( fq ) ; return - ENODEV ; } per_cpu ( pcpu_qipriv . rsp_fq , cpu ) = fq ; dev_dbg ( qidev , "Allocated response FQ %u for CPU %u" , fq -> fqid , cpu ) ; return 0 ; } 