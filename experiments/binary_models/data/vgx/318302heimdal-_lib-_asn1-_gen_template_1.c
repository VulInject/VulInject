static void generate_template_type ( const char * varname , const char * * dupname , const char * symname , const char * basetype , const char * name , Type * type , int optional , int isstruct , int need_offset ) { struct tlist * tl ; const char * d ; char * szt = NULL ; int have_ellipsis = 0 ; int implicit = 0 ; int n ; tl = tlist_new ( varname ) ; if ( type -> type == TTag && type -> tag . tagenv == TE_IMPLICIT ) { Type * t = type -> subtype ?type -> subtype : type -> symbol -> type ; while ( t -> type == TType && ( t -> subtype || t -> symbol -> type ) ) { t = t -> subtype ?t -> subtype : t -> symbol -> type ; } if ( t -> type != TChoice ) { implicit = ( type -> tag . tagenv == TE_IMPLICIT ) ; } } template_members ( , , , , , 0 , , , ) if ( type -> type == TSequence || type -> type == TSet ) { Member * m ; HEIM_TAILQ_FOREACH ( , , ) { if ( m -> ellipsis ) { have_ellipsis = 1 ; } } } if ( isstruct ) { if ( name ) { n = asprintf ( & szt , "struct %s_%s" , basetype , name ) ; } else { n = asprintf ( & szt , "struct %s" , basetype ) ; } } else { n = asprintf ( & szt , "%s" , basetype ) ; } if ( n < 0 || szt == NULL ) { errx ( 1 , "malloc" ) ; } if ( HEIM_TAILQ_EMPTY ( ) && compact_tag ( type ) -> type != TNull ) { errx ( 1 , "Tag %s...%s with no content ?" , basetype , name ?name : "" ) ; } fprintf ( get_code_file ( ) , "\n" , tl -> name ) ; tlist_header ( tl , "{ 0%s%s, sizeof(%s), ((void *)(uintptr_t)%lu) }" , ( symname && preserve_type ( symname ) ) ?"|A1_HF_PRESERVE" : "" , have_ellipsis ?"|A1_HF_ELLIPSIS" : "" , szt , tlist_count ( tl ) ) ; d = tlist_find_dup ( tl ) ; if ( d ) { if ( strcmp ( d , tl -> name ) == 0 ) { errx ( 1 , "found dup of ourself: %s" , d ) ; } * dupname = d ; } else { * dupname = tl -> name ; tlist_print ( tl ) ; tlist_add ( tl ) ; } } 