static int host1x_device_add ( struct host1x * host1x , struct host1x_driver * driver ) { struct host1x_client * client , * tmp ; struct host1x_subdev * subdev ; struct host1x_device * device ; int err ; device = kmalloc ( sizeof ( * device ) , GFP_KERNEL ) ; if ( ! device ) { return - ENOMEM ; } device_initialize ( & device -> dev ) ; mutex_init ( & device -> subdevs_lock ) ; INIT_LIST_HEAD ( & device -> subdevs ) ; INIT_LIST_HEAD ( & device -> active ) ; mutex_init ( & device -> clients_lock ) ; INIT_LIST_HEAD ( & device -> clients ) ; INIT_LIST_HEAD ( & device -> list ) ; device -> driver = driver ; device -> dev . coherent_dma_mask = host1x -> dev -> coherent_dma_mask ; device -> dev . dma_mask = & device -> dev . coherent_dma_mask ; dev_set_name ( & device -> dev , "%s" , driver -> driver . name ) ; device -> dev . release = host1x_device_release ; device -> dev . bus = & host1x_bus_type ; device -> dev . parent = host1x -> dev ; of_dma_configure ( & device -> dev , host1x -> dev -> of_node , true ) ; device -> dev . dma_parms = & device -> dma_parms ; dma_set_max_seg_size ( & device -> dev , UINT_MAX ) ; err = host1x_device_parse_dt ( device , driver ) ; if ( err < 0 ) { kfree ( device ) ; return err ; } list_add_tail ( & device -> list , & host1x -> devices ) ; mutex_lock ( & clients_lock ) ; list_for_each_entry_safe ( , , , ) { list_for_each_entry ( , , ) { if ( subdev -> np == client -> dev -> of_node ) { host1x_subdev_register ( device , subdev , client ) ; break ; } } } mutex_unlock ( & clients_lock ) ; return 0 ; } 