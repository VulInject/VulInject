int smc_clc_send_accept ( struct smc_sock * new_smc , int srv_first_contact ) { struct smc_connection * conn = & new_smc -> conn ; struct smc_clc_msg_accept_confirm aclc ; struct smc_link * link ; struct msghdr msg ; struct kvec vec ; int rc = 0 ; int len ; link = & conn -> lgr -> lnk [ SMC_SINGLE_LINK ] ; memcpy ( aclc . hdr . eyecatcher , SMC_EYECATCHER , sizeof ( SMC_EYECATCHER ) ) ; aclc . hdr . type = SMC_CLC_ACCEPT ; aclc . hdr . length = htons ( sizeof ( aclc ) ) ; aclc . hdr . version = SMC_CLC_V1 ; if ( srv_first_contact ) { aclc . hdr . flag = 1 ; } memcpy ( aclc . lcl . id_for_peer , local_systemid , sizeof ( local_systemid ) ) ; memcpy ( & aclc . lcl . gid , & link -> smcibdev -> gid [ link -> ibport - 1 ] , SMC_GID_SIZE ) ; memcpy ( & aclc . lcl . mac , link -> smcibdev -> mac [ link -> ibport - 1 ] , ETH_ALEN ) ; hton24 ( aclc . qpn , link -> roce_qp -> qp_num ) ; aclc . rmb_rkey = htonl ( conn -> rmb_desc -> mr_rx [ SMC_SINGLE_LINK ] -> rkey ) ; aclc . conn_idx = 1 ; aclc . rmbe_alert_token = htonl ( conn -> alert_token_local ) ; aclc . qp_mtu = link -> path_mtu ; aclc . rmbe_size = conn -> rmbe_size_short , aclc . rmb_dma_addr = cpu_to_be64 ( ( u64 ) conn -> rmb_desc -> dma_addr [ SMC_SINGLE_LINK ] ) ; hton24 ( aclc . psn , link -> psn_initial ) ; memcpy ( aclc . trl . eyecatcher , SMC_EYECATCHER , sizeof ( SMC_EYECATCHER ) ) ; memset ( & msg , 0 , sizeof ( msg ) ) ; vec . iov_base = & aclc ; vec . iov_len = sizeof ( aclc ) ; len = kernel_sendmsg ( new_smc -> clcsock , & msg , & vec , 1 , sizeof ( aclc ) ) ; if ( len < sizeof ( aclc ) ) { if ( len >= 0 ) { new_smc -> sk . sk_err = EPROTO ; } else { new_smc -> sk . sk_err = new_smc -> clcsock -> sk -> sk_err ; } rc = sock_error ( & new_smc -> sk ) ; } return rc ; } 