VAR1 [ 2 ] = ( VAR2 ) VAR1 ; VAR1 [ 3 ] = 0 ; VAR1 += 4 ; for ( ; ( VAR2 ) VAR1 < ( VAR2 ) VAR3 ; VAR1 += 4 ) { VAR1 [ 0 ] = ( VAR2 ) ( VAR1 - 2 ) ; VAR1 [ 1 ] = 0 ; VAR1 [ 2 ] = ( VAR2 ) VAR1 ; VAR1 [ 3 ] = 0 ; } return ( VAR4 ) ( VAR1 - 2 ) ; ptr_t FUN1 ( struct VAR5 * VAR6 , ptr_t VAR7 ) { VAR2 * VAR1 = ( VAR2 * ) ( VAR6 -> VAR8 ) ; VAR2 * VAR3 = ( VAR2 * ) ( VAR6 + 1 ) ; VAR1 [ 0 ] = ( VAR2 ) VAR7 ; VAR1 [ 1 ] = 0 ; VAR1 [ 2 ] = 0 ; VAR1 [ 3 ] = 0 ; VAR1 += 4 ; for ( ; ( VAR2 ) VAR1 < ( VAR2 ) VAR3 ; VAR1 += 4 ) { FUN2 ( ( VAR4 ) ( VAR1 + 64 ) ) ; VAR1 [ 0 ] = ( VAR2 ) ( VAR1 - 4 ) ; VAR1 [ 1 ] = 0 ; FUN3 ( VAR1 + 2 ) ; } return ( VAR4 ) ( VAR1 - 4 ) ; } STATIC ptr_t FUN4 ( struct VAR5 * VAR6 , ptr_t VAR7 ) { VAR2 * VAR1 = ( VAR2 * ) ( VAR6 -> VAR8 ) ; VAR2 * VAR3 = ( VAR2 * ) ( VAR6 + 1 ) ; VAR1 [ 0 ] = ( VAR2 ) VAR7 ; VAR1 [ 2 ] = ( VAR2 ) VAR1 ; VAR1 += 4 ; for ( ; ( VAR2 ) VAR1 < ( VAR2 ) VAR3 ; VAR1 += 4 ) { VAR1 [ 0 ] = ( VAR2 ) ( VAR1 - 2 ) ; VAR1 [ 2 ] = ( VAR2 ) VAR1 ; } return ( VAR4 ) ( VAR1 - 2 ) ; } STATIC ptr_t FUN5 ( struct VAR5 * VAR6 , ptr_t VAR7 ) { VAR2 * VAR1 = ( VAR2 * ) ( VAR6 -> VAR8 ) ; VAR2 * VAR3 = ( VAR2 * ) ( VAR6 + 1 ) ; VAR1 [ 0 ] = ( VAR2 ) VAR7 ; VAR1 [ 4 ] = ( VAR2 ) VAR1 ; VAR1 += 8 ; for ( ; ( VAR2 ) VAR1 < ( VAR2 ) VAR3 ; VAR1 += 8 ) { FUN2 ( ( VAR4 ) ( VAR1 + 64 ) ) ; VAR1 [ 0 ] = ( VAR2 ) ( VAR1 - 4 ) ; VAR1 [ 4 ] = ( VAR2 ) VAR1 ; } return ( VAR4 ) ( VAR1 - 4 ) ; } GC_INNER ptr_t FUN6 ( struct VAR5 * VAR6 , size_t VAR9 , GC_bool VAR10 , ptr_t VAR11 ) { VAR2 * VAR1 , * VAR12 ; VAR2 * VAR13 ; FUN2 ( ( VAR4 ) VAR6 ) ; FUN2 ( ( VAR4 ) VAR6 + 128 ) ; FUN2 ( ( VAR4 ) VAR6 + 256 ) ; FUN2 ( ( VAR4 ) VAR6 + 378 ) ; switch ( VAR9 ) { case 2 : if ( VAR10 ) { return FUN7 ( VAR6 , VAR11 ) ; } else { return FUN4 ( VAR6 , VAR11 ) ; } case 4 : if ( VAR10 ) { return FUN1 ( VAR6 , VAR11 ) ; } else { return FUN5 ( VAR6 , VAR11 ) ; } default : break ; } if ( VAR10 ) { FUN8 ( VAR6 , VAR14 ) ; } VAR1 = ( VAR2 * ) ( VAR6 -> VAR8 ) + VAR9 ; VAR12 = ( VAR2 * ) ( VAR6 -> VAR8 ) ; VAR13 = ( VAR2 * ) ( ( char * ) VAR6 + VAR14 ) ; VAR13 -= VAR9 ; while ( ( VAR2 ) VAR1 <= ( VAR2 ) VAR13 ) { FUN9 ( VAR1 ) = ( VAR4 ) VAR12 ; VAR12 = VAR1 ; VAR1 += VAR9 ; } VAR1 -= VAR9 ; * ( VAR4 * ) VAR6 = VAR11 ; return ( VAR4 ) VAR1 ; }