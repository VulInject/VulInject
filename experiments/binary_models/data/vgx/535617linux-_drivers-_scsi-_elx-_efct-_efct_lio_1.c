void efct_scsi_recv_cmd ( struct efct_io * io , uint64_t lun , u8 * cdb , u32 cdb_len , u32 flags ) { struct efct_scsi_tgt_io * ocp = & io -> tgt_io ; struct se_cmd * se_cmd = & io -> tgt_io . cmd ; struct efct * efct = io -> efct ; char * ddir ; struct efct_node * tgt_node ; struct se_session * se_sess ; int rc = 0 ; memset ( ocp , 0 , sizeof ( efct_scsi_tgt_io ) ) ; efct_set_lio_io_state ( io , EFCT_LIO_STATE_SCSI_RECV_CMD ) ; atomic_add_return ( 1 , & efct -> tgt_efct . ios_in_use ) ; io -> timeout = efct -> target_io_timer_sec ; if ( flags & EFCT_SCSI_CMD_SIMPLE ) { ocp -> task_attr = TCM_SIMPLE_TAG ; } if ( flags & EFCT_SCSI_CMD_HEAD_OF_QUEUE ) { ocp -> task_attr = TCM_HEAD_TAG ; } if ( flags & EFCT_SCSI_CMD_ORDERED ) { ocp -> task_attr = TCM_ORDERED_TAG ; } if ( flags & EFCT_SCSI_CMD_ACA ) { ocp -> task_attr = TCM_ACA_TAG ; } switch ( flags & ( EFCT_SCSI_CMD_DIR_IN | EFCT_SCSI_CMD_DIR_OUT ) ) { case EFCT_SCSI_CMD_DIR_IN : ddir = "FROM_INITIATOR" ; ocp -> ddir = DMA_TO_DEVICE ; break ; case EFCT_SCSI_CMD_DIR_OUT : ddir = "TO_INITIATOR" ; ocp -> ddir = DMA_FROM_DEVICE ; break ; case EFCT_SCSI_CMD_DIR_IN | EFCT_SCSI_CMD_DIR_OUT : ddir = "BIDIR" ; ocp -> ddir = DMA_BIDIRECTIONAL ; break ; default : ddir = "NONE" ; ocp -> ddir = DMA_NONE ; break ; } ocp -> lun = lun ; efct_lio_io_printf ( io , "new cmd=0x%x ddir=%s dl=%u\n" , cdb [ 0 ] , ddir , io -> exp_xfer_len ) ; tgt_node = io -> node ; se_sess = tgt_node -> session ; if ( ! se_sess ) { efc_log_err ( efct , "No session found to submit IO se_cmd: %p\n" , & ocp -> cmd ) ; return ; } efct_set_lio_io_state ( io , EFCT_LIO_STATE_TGT_SUBMIT_CMD ) ; rc = target_init_cmd ( se_cmd , se_sess , & io -> tgt_io . sense_buffer [ 0 ] , ocp -> lun , io -> exp_xfer_len , ocp -> task_attr , ocp -> ddir , TARGET_SCF_ACK_KREF ) ; if ( rc ) { efc_log_err ( efct , "failed to init cmd se_cmd: %p\n" , se_cmd ) ; efct_scsi_io_free ( io ) ; return ; } if ( target_submit_prep ( se_cmd , cdb , NULL , 0 , NULL , 0 , NULL , 0 , GFP_ATOMIC ) ) { return ; } target_submit ( se_cmd ) ; } 