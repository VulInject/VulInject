static zip_int64_t pkware_encrypt ( zip_source_t * src , void * ud , void * data , zip_uint64_t length , zip_source_cmd_t cmd ) { struct trad_pkware * ctx ; zip_int64_t n ; zip_uint64_t buffer_n ; ctx = ( trad_pkware * ) ud ; switch ( cmd ) { case ZIP_SOURCE_OPEN : ctx -> eof = false ; _zip_pkware_keys_reset ( & ctx -> keys ) ; _zip_pkware_encrypt ( & ctx -> keys , NULL , ( const zip_uint8_t * ) ctx -> password , strlen ( ctx -> password ) ) ; if ( encrypt_header ( src , ctx ) < 0 ) { return - 1 ; } return 0 ; case ZIP_SOURCE_READ : buffer_n = 0 ; if ( ctx -> buffer ) { buffer_n = _zip_buffer_read ( ctx -> buffer , data , length ) ; data = ( zip_uint8_t * ) data + buffer_n ; length -= buffer_n ; if ( _zip_buffer_eof ( ctx -> buffer ) ) { _zip_buffer_free ( ctx -> buffer ) ; } } if ( ctx -> eof ) { return ( zip_int64_t ) buffer_n ; } if ( ( n = zip_source_read ( src , data , length ) ) < 0 ) { _zip_error_set_from_source ( & ctx -> error , src ) ; return - 1 ; } _zip_pkware_encrypt ( & ctx -> keys , ( zip_uint8_t * ) data , ( zip_uint8_t * ) data , ( zip_uint64_t ) n ) ; if ( ( zip_uint64_t ) n < length ) { ctx -> eof = true ; } return ( zip_int64_t ) buffer_n + n ; case ZIP_SOURCE_CLOSE : _zip_buffer_free ( ctx -> buffer ) ; ctx -> buffer = NULL ; return 0 ; case ZIP_SOURCE_STAT : { zip_stat_t * st ; st = ( zip_stat_t * ) data ; st -> encryption_method = ZIP_EM_TRAD_PKWARE ; st -> valid |= ZIP_STAT_ENCRYPTION_METHOD ; if ( st -> valid & ZIP_STAT_COMP_SIZE ) { st -> comp_size += ZIP_CRYPTO_PKWARE_HEADERLEN ; } return 0 ; } case ZIP_SOURCE_GET_FILE_ATTRIBUTES : { zip_file_attributes_t * attributes = ( zip_file_attributes_t * ) data ; if ( length < sizeof ( * attributes ) ) { zip_error_set ( & ctx -> error , ZIP_ER_INVAL , 0 ) ; return - 1 ; } attributes -> valid |= ZIP_FILE_ATTRIBUTES_VERSION_NEEDED ; attributes -> version_needed = 20 ; return 0 ; } case ZIP_SOURCE_SUPPORTS : return zip_source_make_command_bitmap ( ZIP_SOURCE_OPEN , ZIP_SOURCE_READ , ZIP_SOURCE_CLOSE , ZIP_SOURCE_STAT , ZIP_SOURCE_ERROR , ZIP_SOURCE_FREE , ZIP_SOURCE_GET_FILE_ATTRIBUTES , - 1 ) ; case ZIP_SOURCE_ERROR : return zip_error_to_data ( & ctx -> error , data , length ) ; case ZIP_SOURCE_FREE : trad_pkware_free ( ctx ) ; return 0 ; default : zip_error_set ( & ctx -> error , ZIP_ER_INVAL , 0 ) ; return - 1 ; } } 