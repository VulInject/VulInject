static int32_t acquire_cred ( struct client * c , krb5_principal principal , krb5_get_init_creds_opt * opt , int32_t * handle ) { krb5_error_code ret ; krb5_creds cred ; krb5_ccache id ; gss_cred_id_t gcred ; OM_uint32 maj_stat , min_stat ; * handle = 0 ; krb5_get_init_creds_opt_set_forwardable ( opt , 1 ) ; krb5_get_init_creds_opt_set_renew_life ( opt , 3600 * 24 * 30 ) ; ret = krb5_get_init_creds_password ( context , & cred , principal , NULL , NULL , NULL , 0 , NULL , opt ) ; if ( ret ) { logmessage ( c , __FILE__ , __LINE__ , 0 , "krb5_get_init_creds failed: %d" , ret ) ; return convert_krb5_to_gsm ( ret ) ; } ret = krb5_cc_new_unique ( context , "MEMORY" , NULL , & id ) ; if ( ret ) { krb5_err ( context , 1 , ret , "krb5_cc_initialize" ) ; } ret = krb5_cc_initialize ( context , id , cred . client ) ; if ( ret ) { krb5_err ( context , 1 , ret , "krb5_cc_initialize" ) ; } ret = krb5_cc_store_cred ( context , id , & cred ) ; if ( ret ) { krb5_err ( context , 1 , ret , "krb5_cc_store_cred" ) ; } krb5_free_cred_contents ( context , & cred ) ; maj_stat = gss_krb5_import_cred ( & min_stat , id , NULL , NULL , & gcred ) ; krb5_cc_close ( context , id ) ; if ( maj_stat ) { logmessage ( c , __FILE__ , __LINE__ , 0 , "krb5 import creds failed with: %d" , maj_stat ) ; return convert_gss_to_gsm ( maj_stat ) ; } * handle = add_handle ( c , handle_cred , gcred ) ; return 0 ; } 