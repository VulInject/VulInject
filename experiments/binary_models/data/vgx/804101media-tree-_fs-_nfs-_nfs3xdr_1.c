int nfs3_decode_dirent ( struct xdr_stream * xdr , struct nfs_entry * entry , int plus ) { struct nfs_entry old = * entry ; __be32 * p ; int error ; p = xdr_inline_decode ( xdr , 4 ) ; if ( * p == xdr_zero ) { p = xdr_inline_decode ( xdr , 4 ) ; if ( unlikely ( p == NULL ) ) { out_overflow } if ( * p == xdr_zero ) { return - EAGAIN ; } entry -> eof = 1 ; return - EBADCOOKIE ; } error = decode_fileid3 ( xdr , & entry -> ino ) ; if ( unlikely ( error ) ) { return error ; } error = decode_inline_filename3 ( xdr , & entry -> name , & entry -> len ) ; if ( unlikely ( error ) ) { return error ; } entry -> prev_cookie = entry -> cookie ; error = decode_cookie3 ( xdr , & entry -> cookie ) ; if ( unlikely ( error ) ) { return error ; } entry -> d_type = DT_UNKNOWN ; if ( plus ) { entry -> fattr -> valid = 0 ; error = decode_post_op_attr ( xdr , entry -> fattr ) ; if ( unlikely ( error ) ) { return error ; } if ( entry -> fattr -> valid & NFS_ATTR_FATTR_V3 ) { entry -> d_type = nfs_umode_to_dtype ( entry -> fattr -> mode ) ; } if ( entry -> fattr -> fileid != entry -> ino ) { entry -> fattr -> mounted_on_fileid = entry -> ino ; entry -> fattr -> valid |= NFS_ATTR_FATTR_MOUNTED_ON_FILEID ; } p = xdr_inline_decode ( xdr , 4 ) ; if ( unlikely ( p == NULL ) ) { out_overflow } if ( * p != xdr_zero ) { error = decode_nfs_fh3 ( xdr , entry -> fh ) ; if ( unlikely ( error ) ) { if ( error == - E2BIG ) { out_truncated } return error ; } } else { zero_nfs_fh3 ( entry -> fh ) ; } } return 0 ; out_overflow print_overflow_msg ( __func__ , xdr ) ; return - EAGAIN ; out_truncated dprintk ( "NFS: directory entry contains invalid file handle\n" ) ; * entry = old ; return - EAGAIN ; } static int decode_dirlist3 ( struct xdr_stream * xdr ) { return xdr_read_pages ( xdr , xdr -> buf -> page_len ) ; } 