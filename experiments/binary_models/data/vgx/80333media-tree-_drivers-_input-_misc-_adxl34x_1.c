struct adxl34x * adxl34x_probe ( struct device * dev , int irq , bool fifo_delay_default , const struct adxl34x_bus_ops * bops ) { struct adxl34x * ac ; struct input_dev * input_dev ; const struct adxl34x_platform_data * pdata ; int err , range , i ; unsigned char revid ; if ( ! irq ) { dev_err ( dev , "no IRQ?\n" ) ; err = - ENODEV ; err_out } ac = kzalloc ( sizeof ( * ac ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! ac || ! input_dev ) { err = - ENOMEM ; err_free_mem } ac -> fifo_delay = fifo_delay_default ; pdata = dev_get_platdata ( dev ) ; if ( ! pdata ) { dev_dbg ( dev , "No platform data: Using default initialization\n" ) ; pdata = & adxl34x_default_init ; } ac -> pdata = * pdata ; pdata = & ac -> pdata ; ac -> input = input_dev ; ac -> dev = dev ; ac -> irq = irq ; ac -> bops = bops ; input_dev -> name = "ADXL34x accelerometer" ; revid = AC_READ ( ac , DEVID ) ; switch ( revid ) { case ID_ADXL345 : ac -> model = 345 ; break ; case ID_ADXL346 : ac -> model = 346 ; break ; default : dev_err ( dev , "Failed to probe %s\n" , input_dev -> name ) ; err = - ENODEV ; err_free_mem } snprintf ( ac -> phys , sizeof ( ac -> phys ) , "%s/input0" , dev_name ( dev ) ) ; input_dev -> phys = ac -> phys ; input_dev -> dev . parent = dev ; input_dev -> id . product = ac -> model ; input_dev -> id . bustype = bops -> bustype ; input_dev -> open = adxl34x_input_open ; input_dev -> close = adxl34x_input_close ; input_set_drvdata ( input_dev , ac ) ; __set_bit ( ac -> pdata . ev_type , input_dev -> evbit ) ; if ( ac -> pdata . ev_type == EV_REL ) { __set_bit ( REL_X , input_dev -> relbit ) ; __set_bit ( REL_Y , input_dev -> relbit ) ; __set_bit ( REL_Z , input_dev -> relbit ) ; } else { __set_bit ( ABS_X , input_dev -> absbit ) ; __set_bit ( ABS_Y , input_dev -> absbit ) ; __set_bit ( ABS_Z , input_dev -> absbit ) ; if ( pdata -> data_range & FULL_RES ) { range = ADXL_FULLRES_MAX_VAL ; } else { range = ADXL_FIXEDRES_MAX_VAL ; } input_set_abs_params ( input_dev , ABS_X , - range , range , 3 , 3 ) ; input_set_abs_params ( input_dev , ABS_Y , - range , range , 3 , 3 ) ; input_set_abs_params ( input_dev , ABS_Z , - range , range , 3 , 3 ) ; } __set_bit ( EV_KEY , input_dev -> evbit ) ; __set_bit ( pdata -> ev_code_tap [ ADXL_X_AXIS ] , input_dev -> keybit ) ; __set_bit ( pdata -> ev_code_tap [ ADXL_Y_AXIS ] , input_dev -> keybit ) ; __set_bit ( pdata -> ev_code_tap [ ADXL_Z_AXIS ] , input_dev -> keybit ) ; if ( pdata -> ev_code_ff ) { ac -> int_mask = FREE_FALL ; __set_bit ( pdata -> ev_code_ff , input_dev -> keybit ) ; } if ( pdata -> ev_code_act_inactivity ) { __set_bit ( pdata -> ev_code_act_inactivity , input_dev -> keybit ) ; } ac -> int_mask |= ACTIVITY | INACTIVITY ; if ( pdata -> watermark ) { ac -> int_mask |= WATERMARK ; if ( ! FIFO_MODE ( pdata -> fifo_mode ) ) { ac -> pdata . fifo_mode |= FIFO_STREAM ; } } else { ac -> int_mask |= DATA_READY ; } if ( pdata -> tap_axis_control & ( TAP_X_EN | TAP_Y_EN | TAP_Z_EN ) ) { ac -> int_mask |= SINGLE_TAP | DOUBLE_TAP ; } if ( FIFO_MODE ( pdata -> fifo_mode ) == FIFO_BYPASS ) { ac -> fifo_delay = false ; } AC_WRITE ( ac , POWER_CTL , 0 ) ; err = request_threaded_irq ( ac -> irq , NULL , adxl34x_irq , IRQF_TRIGGER_HIGH | IRQF_ONESHOT , dev_name ( dev ) , ac ) ; if ( err ) { dev_err ( dev , "irq %d busy?\n" , ac -> irq ) ; err_free_mem } err = sysfs_create_group ( & dev -> kobj , & adxl34x_attr_group ) ; if ( err ) { err_free_irq } err = input_register_device ( input_dev ) ; if ( err ) { err_remove_attr } AC_WRITE ( ac , OFSX , pdata -> x_axis_offset ) ; ac -> hwcal . x = pdata -> x_axis_offset ; AC_WRITE ( ac , OFSY , pdata -> y_axis_offset ) ; ac -> hwcal . y = pdata -> y_axis_offset ; AC_WRITE ( ac , OFSZ , pdata -> z_axis_offset ) ; ac -> hwcal . z = pdata -> z_axis_offset ; AC_WRITE ( ac , THRESH_TAP , pdata -> tap_threshold ) ; AC_WRITE ( ac , DUR , pdata -> tap_duration ) ; AC_WRITE ( ac , LATENT , pdata -> tap_latency ) ; AC_WRITE ( ac , WINDOW , pdata -> tap_window ) ; AC_WRITE ( ac , THRESH_ACT , pdata -> activity_threshold ) ; AC_WRITE ( ac , THRESH_INACT , pdata -> inactivity_threshold ) ; AC_WRITE ( ac , TIME_INACT , pdata -> inactivity_time ) ; AC_WRITE ( ac , THRESH_FF , pdata -> free_fall_threshold ) ; AC_WRITE ( ac , TIME_FF , pdata -> free_fall_time ) ; AC_WRITE ( ac , TAP_AXES , pdata -> tap_axis_control ) ; AC_WRITE ( ac , ACT_INACT_CTL , pdata -> act_axis_control ) ; AC_WRITE ( ac , BW_RATE , RATE ( ac -> pdata . data_rate ) | ( pdata -> low_power_mode ?LOW_POWER : 0 ) ) ; AC_WRITE ( ac , DATA_FORMAT , pdata -> data_range ) ; AC_WRITE ( ac , FIFO_CTL , FIFO_MODE ( pdata -> fifo_mode ) | SAMPLES ( pdata -> watermark ) ) ; if ( pdata -> use_int2 ) { AC_WRITE ( ac , INT_MAP , ac -> int_mask | OVERRUN ) ; } else { AC_WRITE ( ac , INT_MAP , 0 ) ; } if ( ac -> model == 346 && ac -> pdata . orientation_enable ) { AC_WRITE ( ac , ORIENT_CONF , ORIENT_DEADZONE ( ac -> pdata . deadzone_angle ) | ORIENT_DIVISOR ( ac -> pdata . divisor_length ) ) ; ac -> orient2d_saved = 1234 ; ac -> orient3d_saved = 1234 ; if ( pdata -> orientation_enable & ADXL_EN_ORIENTATION_3D ) { for ( i = 0 ; i < ARRAY_SIZE ( pdata -> ev_codes_orient_3d ) ; i ++ ) { __set_bit ( pdata -> ev_codes_orient_3d [ i ] , input_dev -> keybit ) ; } } if ( pdata -> orientation_enable & ADXL_EN_ORIENTATION_2D ) { for ( i = 0 ; i < ARRAY_SIZE ( pdata -> ev_codes_orient_2d ) ; i ++ ) { __set_bit ( pdata -> ev_codes_orient_2d [ i ] , input_dev -> keybit ) ; } } } else { ac -> pdata . orientation_enable = 0 ; } AC_WRITE ( ac , INT_ENABLE , ac -> int_mask | OVERRUN ) ; ac -> pdata . power_mode &= ( PCTL_AUTO_SLEEP | PCTL_LINK ) ; return ac ; err_remove_attr sysfs_remove_group ( & dev -> kobj , & adxl34x_attr_group ) ; err_free_irq free_irq ( ac -> irq , ac ) ; err_free_mem input_free_device ( input_dev ) ; kfree ( ac ) ; err_out return ERR_PTR ( err ) ; } 