static void hns_roce_v1_destroy_qp_work_fn ( struct work_struct * work ) { struct hns_roce_qp_work * qp_work_entry ; struct hns_roce_v1_priv * priv ; struct hns_roce_dev * hr_dev ; struct hns_roce_qp * hr_qp ; struct device * dev ; int ret ; qp_work_entry = container_of ( work , hns_roce_qp_work , work ) ; hr_dev = to_hr_dev ( qp_work_entry -> ib_dev ) ; dev = & hr_dev -> pdev -> dev ; priv = ( hns_roce_v1_priv * ) hr_dev -> hw -> priv ; hr_qp = qp_work_entry -> qp ; dev_dbg ( dev , "Schedule destroy QP(0x%lx) work.\n" , hr_qp -> qpn ) ; qp_work_entry -> sche_cnt ++ ; ret = check_qp_db_process_status ( hr_dev , hr_qp , qp_work_entry -> sdb_issue_ptr , & qp_work_entry -> sdb_inv_cnt , & qp_work_entry -> db_wait_stage ) ; if ( ret ) { dev_err ( dev , "Check QP(0x%lx) db process status failed!\n" , hr_qp -> qpn ) ; return ; } if ( qp_work_entry -> db_wait_stage != HNS_ROCE_V1_DB_WAIT_OK && priv -> des_qp . requeue_flag ) { queue_work ( priv -> des_qp . qp_wq , work ) ; return ; } ret = hns_roce_v1_modify_qp ( & hr_qp -> ibqp , NULL , 0 , hr_qp -> state , IB_QPS_RESET ) ; if ( ret ) { dev_err ( dev , "Modify QP(0x%lx) to RST failed!\n" , hr_qp -> qpn ) ; return ; } hns_roce_qp_remove ( hr_dev , hr_qp ) ; hns_roce_qp_free ( hr_dev , hr_qp ) ; if ( hr_qp -> ibqp . qp_type == IB_QPT_RC ) { hns_roce_release_range_qp ( hr_dev , hr_qp -> qpn , 1 ) ; } else { kfree ( hr_to_hr_sqp ( hr_qp ) ) ; } kfree ( qp_work_entry ) ; dev_dbg ( dev , "Accomplished destroy QP(0x%lx) work.\n" , hr_qp -> qpn ) ; } 