int rsautl_main ( int argc , char * * argv ) { BIO * in = NULL , * out = NULL ; X509 * x ; EVP_PKEY * pkey = NULL ; RSA * rsa = NULL ; unsigned char * rsa_in = NULL , * rsa_out = NULL ; char * passin = NULL ; int rsa_inlen , rsa_outlen = 0 ; int need_priv = 0 ; int keysize ; int ret = 1 ; if ( pledge ( "stdio cpath wpath rpath tty" , NULL ) == - 1 ) { perror ( "pledge" ) ; exit ( 1 ) ; } memset ( & rsautl_config , 0 , sizeof ( rsautl_config ) ) ; rsautl_config . keyform = FORMAT_PEM ; rsautl_config . key_type = KEY_PRIVKEY ; rsautl_config . pad = RSA_PKCS1_PADDING ; rsautl_config . rsa_mode = RSA_VERIFY ; if ( options_parse ( argc , argv , rsautl_options , NULL , NULL ) != 0 ) { rsautl_usage ( ) ; return ( 1 ) ; } if ( rsautl_config . rsa_mode == RSA_SIGN || rsautl_config . rsa_mode == RSA_DECRYPT ) { need_priv = 1 ; } if ( need_priv && rsautl_config . key_type != KEY_PRIVKEY ) { BIO_printf ( bio_err , "A private key is needed for this operation\n" ) ; end } if ( ! app_passwd ( bio_err , rsautl_config . passargin , NULL , & passin , NULL ) ) { BIO_printf ( bio_err , "Error getting password\n" ) ; end } switch ( rsautl_config . key_type ) { case KEY_PRIVKEY : pkey = load_key ( bio_err , rsautl_config . keyfile , rsautl_config . keyform , 0 , passin , "Private Key" ) ; break ; case KEY_PUBKEY : pkey = load_pubkey ( bio_err , rsautl_config . keyfile , rsautl_config . keyform , 0 , NULL , "Public Key" ) ; break ; case KEY_CERT : x = load_cert ( bio_err , rsautl_config . keyfile , rsautl_config . keyform , NULL , "Certificate" ) ; if ( x ) { pkey = X509_get_pubkey ( x ) ; X509_free ( x ) ; } break ; } if ( ! pkey ) { end } rsa = EVP_PKEY_get1_RSA ( pkey ) ; EVP_PKEY_free ( pkey ) ; if ( ! rsa ) { BIO_printf ( bio_err , "Error getting RSA key\n" ) ; ERR_print_errors ( bio_err ) ; end } if ( rsautl_config . infile ) { if ( ! ( in = BIO_new_file ( rsautl_config . infile , "rb" ) ) ) { BIO_printf ( bio_err , "Error Reading Input File\n" ) ; ERR_print_errors ( bio_err ) ; end } } else { in = BIO_new_fp ( stdin , BIO_NOCLOSE ) ; } if ( rsautl_config . outfile ) { if ( ! ( out = BIO_new_file ( rsautl_config . outfile , "wb" ) ) ) { BIO_printf ( bio_err , "Error Reading Output File\n" ) ; ERR_print_errors ( bio_err ) ; end } } else { out = BIO_new_fp ( stdout , BIO_NOCLOSE ) ; } keysize = RSA_size ( rsa ) ; rsa_in = reallocarray ( NULL , keysize , 2 ) ; if ( rsa_in == NULL ) { BIO_printf ( bio_err , "Error allocating memory for input data\n" ) ; exit ( 1 ) ; } rsa_out = malloc ( keysize ) ; if ( rsa_out == NULL ) { BIO_printf ( bio_err , "Error allocating memory for output data\n" ) ; exit ( 1 ) ; } rsa_inlen = BIO_read ( in , rsa_in , keysize * 2 ) ; if ( rsa_inlen <= 0 ) { BIO_printf ( bio_err , "Error reading input Data\n" ) ; exit ( 1 ) ; } if ( rsautl_config . rev ) { int i ; unsigned char ctmp ; for ( i = 0 ; i < rsa_inlen / 2 ; i ++ ) { ctmp = rsa_in [ i ] ; rsa_in [ i ] = rsa_in [ rsa_inlen - 1 - i ] ; rsa_in [ rsa_inlen - 1 - i ] = ctmp ; } } switch ( rsautl_config . rsa_mode ) { case RSA_VERIFY : rsa_outlen = RSA_public_decrypt ( rsa_inlen , rsa_in , rsa_out , rsa , rsautl_config . pad ) ; break ; case RSA_SIGN : rsa_outlen = RSA_private_encrypt ( rsa_inlen , rsa_in , rsa_out , rsa , rsautl_config . pad ) ; break ; case RSA_ENCRYPT : rsa_outlen = RSA_public_encrypt ( rsa_inlen , rsa_in , rsa_out , rsa , rsautl_config . pad ) ; break ; case RSA_DECRYPT : rsa_outlen = RSA_private_decrypt ( rsa_inlen , rsa_in , rsa_out , rsa , rsautl_config . pad ) ; break ; } if ( rsa_outlen <= 0 ) { BIO_printf ( bio_err , "RSA operation error\n" ) ; ERR_print_errors ( bio_err ) ; end } ret = 0 ; if ( rsautl_config . asn1parse ) { if ( ! ASN1_parse_dump ( out , rsa_out , rsa_outlen , 1 , - 1 ) ) { ERR_print_errors ( bio_err ) ; } } if ( rsautl_config . hexdump ) { BIO_dump ( out , ( char * ) rsa_out , rsa_outlen ) ; } else { BIO_write ( out , rsa_out , rsa_outlen ) ; } end RSA_free ( rsa ) ; BIO_free ( in ) ; BIO_free_all ( out ) ; free ( rsa_out ) ; free ( passin ) ; return ret ; } 