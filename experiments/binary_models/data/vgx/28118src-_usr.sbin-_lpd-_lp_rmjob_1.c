static void doremove ( int ofd , struct lp_printer * lp , const char * cfname ) { FILE * fp ; ssize_t len ; size_t linesz = 0 ; char * line ; fp = lp_fopen ( lp , cfname ) ; if ( fp == NULL ) { log_warn ( "cannot open %s" , cfname ) ; return ; } if ( lp -> lp_type == PRN_LPR ) { dprintf ( ofd , "%s: " , lpd_hostname ) ; } if ( lp_unlink ( lp , cfname ) == - 1 ) { log_warn ( "cannot unlink %s" , cfname ) ; dprintf ( ofd , "cannot dequeue %s\n" , cfname ) ; } else { log_info ( "removed job %s" , cfname ) ; dprintf ( ofd , "%s dequeued\n" , cfname ) ; } while ( ( len = getline ( & line , & linesz , fp ) ) != - 1 ) { if ( line [ len - 1 ] == '\n' ) { line [ len - 1 ] = '\0' ; } if ( line [ 0 ] != 'U' ) { continue ; } if ( strchr ( line + 1 , '/' ) || strncmp ( line + 1 , "df" , 2 ) ) { continue ; } if ( lp -> lp_type == PRN_LPR ) { dprintf ( ofd , "%s: " , lpd_hostname ) ; } if ( lp_unlink ( lp , line + 1 ) == - 1 ) { log_warn ( "cannot unlink %s" , line + 1 ) ; dprintf ( ofd , "cannot dequeue %s\n" , line + 1 ) ; } else { dprintf ( ofd , "%s dequeued\n" , line + 1 ) ; } } fclose ( fp ) ; } 