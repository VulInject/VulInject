int _adddgrptabrec ( char * dgrp , char * * members ) { struct dgrptabent * ent ; dgrptabent * new ; struct dgrptabent * p ; struct member * pm , * qm , * rm ; FILE * fd ; char * path ; int olderrno ; int noerr ; if ( ( new = mkdgrptabent ( dgrp , members ) ) == NULL ) { return ( FALSE ) ; } if ( ! lkdgrptab ( "a+" , F_WRLCK ) ) { _freedgrptabent ( new ) ; return ( FALSE ) ; } noerr = TRUE ; olderrno = errno ; if ( ent = _getdgrprec ( dgrp ) ) { if ( new -> membership ) { if ( ( pm = ent -> membership ) != NULL ) { while ( pm -> next ) { pm = pm -> next ; } pm -> next = new -> membership ; for ( pm = ent -> membership ; pm ; pm = pm -> next ) { qm = pm ; while ( ( rm = qm -> next ) != NULL ) { if ( strcmp ( pm -> name , rm -> name ) == 0 ) { qm -> next = rm -> next ; free ( rm -> name ) ; } else { qm = rm ; } } } } else { ent -> membership = new -> membership ; } new -> membership = NULL ; _setdgrptab ( ) ; if ( fd = opennewdgrptab ( & path ) ) { while ( ( ( p = _getdgrptabent ( ) ) != NULL ) && noerr ) { if ( ent -> entryno != p -> entryno ) { noerr = _putdgrptabrec ( fd , p ) != EOF ; } else { noerr = _putdgrptabrec ( fd , ent ) != EOF ; } _freedgrptabent ( p ) ; } if ( noerr ) { ( void ) fclose ( fd ) ; noerr = mknewdgrptab ( path ) ; } else { ( void ) fclose ( fd ) ; ( void ) rmnewdgrptab ( path ) ; } } } _freedgrptabent ( ent ) ; } if ( errno == EINVAL ) { errno = olderrno ; if ( fseek ( oam_dgroup , 0 , SEEK_END ) == 0 ) { noerr = ( _putdgrptabrec ( oam_dgroup , new ) != EOF ) ; } } else { noerr = FALSE ; } ( void ) unlkdgrptab ( ) ; _freedgrptabent ( new ) ; return ( noerr ) ; } 