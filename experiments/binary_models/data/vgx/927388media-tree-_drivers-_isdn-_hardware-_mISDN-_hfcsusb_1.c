static int open_dchannel ( struct hfcsusb * hw , struct mISDNchannel * ch , struct channel_req * rq ) { int err = 0 ; if ( debug & DEBUG_HW_OPEN ) { printk ( KERN_DEBUG "%s: %s: dev(%d) open addr(%i) from %p\n" , hw -> name , __func__ , hw -> dch . dev . id , rq -> adr . channel , __builtin_return_address ( 0 ) ) ; } test_and_clear_bit ( FLG_ACTIVE , & hw -> dch . Flags ) ; test_and_clear_bit ( FLG_ACTIVE , & hw -> ech . Flags ) ; hfcsusb_start_endpoint ( hw , HFC_CHAN_D ) ; if ( rq -> adr . channel == 1 ) { if ( hw -> fifos [ HFCUSB_PCM_RX ] . pipe ) { hfcsusb_start_endpoint ( hw , HFC_CHAN_E ) ; set_bit ( FLG_ACTIVE , & hw -> ech . Flags ) ; _queue_data ( & hw -> ech . dev . D , PH_ACTIVATE_IND , MISDN_ID_ANY , 0 , NULL , GFP_ATOMIC ) ; } else { return - EINVAL ; } } if ( ! hw -> initdone ) { hw -> protocol = rq -> protocol ; if ( rq -> protocol == ISDN_P_TE_S0 ) { err = create_l1 ( & hw -> dch , hfc_l1callback ) ; if ( err ) { return err ; } } setPortMode ( hw ) ; ch -> protocol = rq -> protocol ; hw -> initdone = 1 ; } else { if ( rq -> protocol != ch -> protocol ) { return - EPROTONOSUPPORT ; } } if ( ( ( ch -> protocol == ISDN_P_NT_S0 ) && ( hw -> dch . state == 3 ) ) || ( ( ch -> protocol == ISDN_P_TE_S0 ) && ( hw -> dch . state == 7 ) ) ) { _queue_data ( ch , PH_ACTIVATE_IND , MISDN_ID_ANY , 0 , NULL , GFP_KERNEL ) ; } rq -> ch = ch ; if ( ! try_module_get ( THIS_MODULE ) ) { printk ( KERN_WARNING "%s: %s: cannot get module\n" , hw -> name , __func__ ) ; } return 0 ; } 