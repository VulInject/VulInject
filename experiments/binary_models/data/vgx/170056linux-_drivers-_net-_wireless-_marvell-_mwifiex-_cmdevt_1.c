static int mwifiex_dnld_cmd_to_fw ( struct mwifiex_private * priv , struct cmd_ctrl_node * cmd_node ) { struct mwifiex_adapter * adapter = priv -> adapter ; int ret ; struct host_cmd_ds_command * host_cmd ; uint16_t cmd_code ; uint16_t cmd_size ; host_cmd = ( host_cmd_ds_command * ) ( cmd_node -> cmd_skb -> data ) ; if ( host_cmd -> size == 0 ) { mwifiex_dbg ( adapter , ERROR , "DNLD_CMD: host_cmd is null\t" "or cmd size is 0, not sending\n" ) ; if ( cmd_node -> wait_q_enabled ) { adapter -> cmd_wait_q . status = - 1 ; } mwifiex_recycle_cmd_node ( adapter , cmd_node ) ; return - 1 ; } cmd_code = le16_to_cpu ( host_cmd -> command ) ; cmd_node -> cmd_no = cmd_code ; cmd_size = le16_to_cpu ( host_cmd -> size ) ; if ( adapter -> hw_status == MWIFIEX_HW_STATUS_RESET && cmd_code != HostCmd_CMD_FUNC_SHUTDOWN && cmd_code != HostCmd_CMD_FUNC_INIT ) { mwifiex_dbg ( adapter , ERROR , "DNLD_CMD: FW in reset state, ignore cmd %#x\n" , cmd_code ) ; mwifiex_recycle_cmd_node ( adapter , cmd_node ) ; queue_work ( adapter -> workqueue , & adapter -> main_work ) ; return - 1 ; } adapter -> seq_num ++ ; host_cmd -> seq_num = cpu_to_le16 ( HostCmd_SET_SEQ_NO_BSS_INFO ( adapter -> seq_num , cmd_node -> priv -> bss_num , cmd_node -> priv -> bss_type ) ) ; spin_lock_bh ( & adapter -> mwifiex_cmd_lock ) ; adapter -> curr_cmd = cmd_node ; spin_unlock_bh ( & adapter -> mwifiex_cmd_lock ) ; if ( cmd_node -> cmd_skb -> len > cmd_size ) { skb_trim ( cmd_node -> cmd_skb , cmd_size ) ; } if ( cmd_node -> cmd_skb -> len < cmd_size ) { skb_put ( cmd_node -> cmd_skb , cmd_size - cmd_node -> cmd_skb -> len ) ; } mwifiex_dbg ( adapter , CMD , "cmd: DNLD_CMD: %#x, act %#x, len %d, seqno %#x\n" , cmd_code , get_unaligned_le16 ( ( u8 * ) host_cmd + S_DS_GEN ) , cmd_size , le16_to_cpu ( host_cmd -> seq_num ) ) ; mwifiex_dbg_dump ( adapter , CMD_D , "cmd buffer:" , host_cmd , cmd_size ) ; if ( adapter -> iface_type == MWIFIEX_USB ) { skb_push ( cmd_node -> cmd_skb , MWIFIEX_TYPE_LEN ) ; put_unaligned_le32 ( MWIFIEX_USB_TYPE_CMD , cmd_node -> cmd_skb -> data ) ; adapter -> cmd_sent = true ; ret = adapter -> if_ops . host_to_card ( adapter , MWIFIEX_USB_EP_CMD_EVENT , cmd_node -> cmd_skb , NULL ) ; skb_pull ( cmd_node -> cmd_skb , MWIFIEX_TYPE_LEN ) ; if ( ret == - EBUSY ) { cmd_node -> cmd_skb = NULL ; } } else { skb_push ( cmd_node -> cmd_skb , adapter -> intf_hdr_len ) ; ret = adapter -> if_ops . host_to_card ( adapter , MWIFIEX_TYPE_CMD , cmd_node -> cmd_skb , NULL ) ; skb_pull ( cmd_node -> cmd_skb , adapter -> intf_hdr_len ) ; } if ( ret == - 1 ) { mwifiex_dbg ( adapter , ERROR , "DNLD_CMD: host to card failed\n" ) ; if ( adapter -> iface_type == MWIFIEX_USB ) { adapter -> cmd_sent = false ; } if ( cmd_node -> wait_q_enabled ) { adapter -> cmd_wait_q . status = - 1 ; } mwifiex_recycle_cmd_node ( adapter , adapter -> curr_cmd ) ; spin_lock_bh ( & adapter -> mwifiex_cmd_lock ) ; adapter -> curr_cmd = NULL ; spin_unlock_bh ( & adapter -> mwifiex_cmd_lock ) ; adapter -> dbg . num_cmd_host_to_card_failure ++ ; return - 1 ; } adapter -> dbg . last_cmd_index = ( adapter -> dbg . last_cmd_index + 1 ) % DBG_CMD_NUM ; adapter -> dbg . last_cmd_id [ adapter -> dbg . last_cmd_index ] = cmd_code ; adapter -> dbg . last_cmd_act [ adapter -> dbg . last_cmd_index ] = get_unaligned_le16 ( ( u8 * ) host_cmd + S_DS_GEN ) ; if ( cmd_code != HostCmd_CMD_FW_DUMP_EVENT ) { mod_timer ( & adapter -> cmd_timer , jiffies + msecs_to_jiffies ( MWIFIEX_TIMER_10S ) ) ; } cmd_code &= HostCmd_CMD_ID_MASK ; return 0 ; } 