void ypmatch ( SVCXPRT * transp , struct svc_req * rqstp ) { struct ypreq_key req ; struct ypresp_val resp ; char * fun = "ypmatch" ; DBM * fdb ; memset ( & resp , 0 , sizeof ( resp ) ) ; resp . status = ( unsigned ) YP_NOKEY ; if ( ! svc_getargs ( transp , ( xdrproc_t ) xdr_ypreq_key , ( char * ) & req ) ) { svcerr_decode ( transp ) ; return ; } if ( ( fdb = ypset_current_map ( req . map , req . domain , & resp . status ) ) != NULL && yp_map_access ( transp , & resp . status , fdb ) ) { resp . valdat = dbm_fetch ( fdb , req . keydat ) ; if ( resp . valdat . dptr != NULL ) { resp . status = YP_TRUE ; if ( ! silent ) { printf ( "%s: dbm: %40.40s\n" , fun , resp . valdat . dptr ) ; } send_reply } if ( req . keydat . dsize == 0 || req . keydat . dptr == NULL || req . keydat . dptr [ 0 ] == '\0' || strncmp ( req . keydat . dptr , yp_secure , req . keydat . dsize ) == 0 || strncmp ( req . keydat . dptr , yp_interdomain , req . keydat . dsize ) == 0 ) { send_reply } if ( multiflag == TRUE && multihomed ( req , & resp , transp , fdb ) ) { send_reply } if ( multihomed ( req , & resp , transp , fdb ) ) { send_reply } if ( ! dnsforward && ! client_setup_failure ) { datum idkey , idval ; idkey . dptr = yp_interdomain ; idkey . dsize = yp_interdomain_sz ; idval = dbm_fetch ( fdb , idkey ) ; if ( idval . dptr ) { dnsforward = TRUE ; } } if ( dnsforward ) { if ( ! resolv_pid || ! resolv_client ) { setup_resolv ( & dnsforward , & resolv_pid , & resolv_client , resolv_tp , 0 ) ; if ( resolv_client == NULL ) { client_setup_failure = TRUE ; } } if ( resolv_req ( & dnsforward , & resolv_client , & resolv_pid , resolv_tp , rqstp -> rq_xprt , & req , req . map ) == TRUE ) { free_args } } } send_reply if ( ! svc_sendreply ( transp , ( xdrproc_t ) xdr_ypresp_val , ( caddr_t ) & resp ) ) { RESPOND_ERR ; } free_args if ( ! svc_freeargs ( transp , ( xdrproc_t ) xdr_ypreq_key , ( char * ) & req ) ) { FREE_ERR ; } } 