diag_t ttoaddresses_num ( shunk_t input , const char * delims , const struct ip_info * input_afi , ip_tokens * output ) { zero ( output ) ; dbg ( "%s() input: " PRI_SHUNK , __func__ , pri_shunk ( input ) ) ; for ( unsigned pass = 1 ; pass <= 2 ; pass ++ ) { shunk_t cursor = input ; unsigned nr_tokens = 0 ; while ( true ) { shunk_t token = shunk_token ( & cursor , NULL , delims ) ; if ( token . ptr == NULL ) { break ; } if ( token . len == 0 ) { continue ; } ip_token tmp_token ; err_t e = ttoaddress_num ( token , input_afi , & tmp_token ) ; const struct ip_info * afi = address_info ( tmp_token ) ; switch ( pass ) { case 1 : if ( e != NULL ) { return diag ( PRI_SHUNK " invalid, %s" , pri_shunk ( token ) , e ) ; } break ; case 2 : passert ( e == NULL ) ; output -> ip [ afi -> ip_index ] . list [ output -> ip [ afi -> ip_index ] . len ] = tmp_token ; break ; } output -> ip [ afi -> ip_index ] . len ++ ; nr_tokens ++ ; } if ( nr_tokens == 0 ) { return NULL ; } switch ( pass ) { case 1 : dbg ( "%s() nr tokens %u" , __func__ , nr_tokens ) ; output -> list = alloc_things ( ip_token , nr_tokens , "selectors" ) ; FOR_EACH_ELEMENT ( , ) { enum ip_index ip = afi -> ip_index ; output -> ip [ ip ] . list = output -> list + output -> len ; output -> len += output -> ip [ ip ] . len ; output -> ip [ ip ] . len = 0 ; } passert ( output -> len == nr_tokens ) ; break ; case 2 : passert ( nr_tokens == output -> len ) ; break ; } } return NULL ; } 