void ste_start ( struct ifnet * ifp ) { struct ste_softc * sc ; struct mbuf * m_head = NULL ; struct ste_chain * cur_tx ; int idx ; sc = ifp -> if_softc ; if ( ! sc -> ste_link ) { return ; } if ( ifq_is_oactive ( & ifp -> if_snd ) ) { return ; } idx = sc -> ste_cdata . ste_tx_prod ; while ( sc -> ste_cdata . ste_tx_chain [ idx ] . ste_mbuf == NULL ) { if ( STE_NEXT ( idx , STE_TX_LIST_CNT ) == sc -> ste_cdata . ste_tx_cons ) { ifq_set_oactive ( & ifp -> if_snd ) ; break ; } m_head = ifq_dequeue ( & ifp -> if_snd ) ; if ( m_head == NULL ) { break ; } cur_tx = & sc -> ste_cdata . ste_tx_chain [ idx ] ; if ( ste_encap ( sc , cur_tx , m_head ) != 0 ) { break ; } cur_tx -> ste_ptr -> ste_next = 0 ; if ( sc -> ste_tx_prev == NULL ) { cur_tx -> ste_ptr -> ste_ctl = STE_TXCTL_DMAINTR | 1 ; STE_SETBIT4 ( sc , STE_DMACTL , STE_DMACTL_TXDMA_STALL ) ; ste_wait ( sc , NULL ) ; CSR_WRITE_4 ( sc , STE_TX_DMALIST_PTR , vtophys ( ( vaddr_t ) & sc -> ste_ldata -> ste_tx_list [ 0 ] ) ) ; CSR_WRITE_1 ( sc , STE_TX_DMAPOLL_PERIOD , 64 ) ; STE_SETBIT4 ( sc , STE_DMACTL , STE_DMACTL_TXDMA_UNSTALL ) ; ste_wait ( sc ) ; } else { cur_tx -> ste_ptr -> ste_ctl = STE_TXCTL_DMAINTR | 1 ; sc -> ste_tx_prev -> ste_ptr -> ste_next = cur_tx -> ste_phys ; } sc -> ste_tx_prev = cur_tx ; if ( ifp -> if_bpf ) { bpf_mtap ( ifp -> if_bpf , cur_tx -> ste_mbuf , BPF_DIRECTION_OUT ) ; } STE_INC ( idx , STE_TX_LIST_CNT ) ; ifp -> if_timer = 5 ; } sc -> ste_cdata . ste_tx_prod = idx ; } 