static int radix_tree_extend ( struct radix_tree_root * root , gfp_t gfp , unsigned long index , unsigned int shift ) { void * entry ; unsigned int maxshift ; int tag ; maxshift = shift ; while ( index > shift_maxindex ( maxshift ) ) { maxshift += RADIX_TREE_MAP_SHIFT ; } entry = rcu_dereference_raw ( root -> rnode ) ; if ( ! entry && ( ! is_idr ( root ) || root_tag_get ( root , IDR_FREE ) ) ) { out } { struct radix_tree_node * node = radix_tree_node_alloc ( gfp , NULL , root , shift , 0 , 1 , 0 ) ; if ( is_idr ( root ) ) { all_tag_set ( node , IDR_FREE ) ; if ( ! root_tag_get ( root , IDR_FREE ) ) { tag_clear ( node , IDR_FREE , 0 ) ; root_tag_set ( root , IDR_FREE ) ; } } else { for ( tag = 0 ; tag < RADIX_TREE_MAX_TAGS ; tag ++ ) { if ( root_tag_get ( root , tag ) ) { tag_set ( node , tag , 0 ) ; } } } BUG_ON ( shift > BITS_PER_LONG ) ; if ( radix_tree_is_internal_node ( entry ) ) { entry_to_node ( entry ) -> parent = node ; } if ( radix_tree_exceptional_entry ( entry ) ) { node -> exceptional = 1 ; } node -> slots [ 0 ] = ( void __rcu * ) entry ; entry = node_to_entry ( node ) ; rcu_assign_pointer ( root -> rnode , entry ) ; shift += RADIX_TREE_MAP_SHIFT ; } shift <= maxshift ; out return maxshift + RADIX_TREE_MAP_SHIFT ; } 