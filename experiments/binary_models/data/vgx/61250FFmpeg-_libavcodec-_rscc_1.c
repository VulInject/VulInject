static av_cold int rscc_init ( AVCodecContext * avctx ) { RsccContext * ctx = avctx -> priv_data ; int ret = av_image_check_size ( avctx -> width , avctx -> height , 0 , avctx ) ; if ( ret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Invalid image size %dx%d.\n" , avctx -> width , avctx -> height ) ; return ret ; } ctx -> reference = av_frame_alloc ( ) ; if ( ! ctx -> reference ) { return AVERROR ( ENOMEM ) ; } if ( avctx -> codec_tag == MKTAG ( 'I' , 'S' , 'C' , 'C' ) ) { if ( avctx -> extradata && avctx -> extradata_size == 4 ) { if ( ( avctx -> extradata [ 0 ] >> 1 ) & 1 ) { avctx -> pix_fmt = AV_PIX_FMT_BGRA ; ctx -> component_size = 4 ; } else { avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; ctx -> component_size = 3 ; } } else { avctx -> pix_fmt = AV_PIX_FMT_BGRA ; ctx -> component_size = 4 ; } } if ( avctx -> codec_tag == MKTAG ( 'R' , 'S' , 'C' , 'C' ) ) { ctx -> component_size = avctx -> bits_per_coded_sample / 8 ; switch ( avctx -> bits_per_coded_sample ) { case 8 : avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; break ; case 16 : avctx -> pix_fmt = AV_PIX_FMT_RGB555LE ; break ; case 24 : avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; break ; case 32 : avctx -> pix_fmt = AV_PIX_FMT_BGR0 ; break ; default : av_log ( avctx , AV_LOG_ERROR , "Invalid bits per pixel value (%d)\n" , avctx -> bits_per_coded_sample ) ; return AVERROR_INVALIDDATA ; } } else { avctx -> pix_fmt = AV_PIX_FMT_BGR0 ; ctx -> component_size = 4 ; av_log ( avctx , AV_LOG_WARNING , "Invalid codec tag\n" ) ; } ctx -> inflated_size = avctx -> width * avctx -> height * ctx -> component_size ; ctx -> inflated_buf = av_malloc ( ctx -> inflated_size , NULL ) ; if ( ! ctx -> inflated_buf ) { return AVERROR ( ENOMEM ) ; } return 0 ; } 