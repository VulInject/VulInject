void nvkm_dp_train ( struct nvkm_output_dp * outp ) { struct nv50_disp * disp = nv50_disp ( outp -> base . disp ) ; const struct dp_rates * cfg = nvkm_dp_rates ; struct dp_state _dp = { . outp = outp } , * dp = & _dp ; u32 datarate = 0 ; u8 pwr ; int ret ; if ( ! outp -> base . info . location && disp -> func -> sor . magic ) { disp -> func -> sor . magic ( & outp -> base ) ; } if ( disp -> base . engine . subdev . device -> chipset < 0xd0 ) { outp -> dpcd [ 2 ] &= ~ DPCD_RC02_TPS3_SUPPORTED ; } if ( ( outp -> dpcd [ 2 ] & 0x1f ) > outp -> base . info . dpconf . link_nr ) { outp -> dpcd [ 2 ] &= ~ DPCD_RC02_MAX_LANE_COUNT ; outp -> dpcd [ 2 ] |= outp -> base . info . dpconf . link_nr ; } if ( outp -> dpcd [ 1 ] > outp -> base . info . dpconf . link_bw ) { outp -> dpcd [ 1 ] = outp -> base . info . dpconf . link_bw ; } dp -> pc2 = outp -> dpcd [ 2 ] & DPCD_RC02_TPS3_SUPPORTED ; if ( datarate ) { datarate = ( datarate / 8 ) * 10 ; while ( cfg [ 1 ] . rate >= datarate ) { cfg ++ ; } } cfg -- ; if ( ! nvkm_rdaux ( outp -> aux , DPCD_SC00 , & pwr , 1 ) ) { if ( ( pwr & DPCD_SC00_SET_POWER ) != DPCD_SC00_SET_POWER_D0 ) { pwr &= ~ DPCD_SC00_SET_POWER ; pwr |= DPCD_SC00_SET_POWER_D0 ; nvkm_wraux ( outp -> aux , DPCD_SC00 , & pwr , 1 ) ; } } dp_link_train_init ( dp , outp -> dpcd [ 3 ] & 0x01 ) ; while ( ret = - EIO , ( ++ cfg ) -> rate ) { while ( cfg -> nr > ( outp -> dpcd [ 2 ] & DPCD_RC02_MAX_LANE_COUNT ) || cfg -> bw > ( outp -> dpcd [ DPCD_RC01_MAX_LINK_RATE ] ) ) { cfg ++ ; } dp -> link_bw = cfg -> bw * 27000 ; dp -> link_nr = cfg -> nr ; ret = dp_set_link_config ( dp ) ; if ( ret == 0 ) { if ( ! dp_link_train_cr ( dp ) && ! dp_link_train_eq ( dp ) ) { break ; } } if ( ret ) { break ; } } dp_set_training_pattern ( dp , 0 ) ; if ( ret < 0 ) { OUTP_ERR ( & outp -> base , "link training failed" ) ; } dp_link_train_fini ( dp ) ; OUTP_DBG ( & outp -> base , "training complete" ) ; atomic_set ( & outp -> lt . done , 1 ) ; } 