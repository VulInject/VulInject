static void blkif_free_ring ( struct blkfront_ring_info * rinfo ) { struct grant * persistent_gnt , * n ; struct blkfront_info * info = rinfo -> dev_info ; int i , j , segs ; if ( ! list_empty ( & rinfo -> indirect_pages ) ) { struct page * indirect_page , * n ; BUG_ON ( info -> bounce ) ; list_for_each_entry_safe ( , , , ) { list_del ( & indirect_page -> lru ) ; __free_page ( indirect_page ) ; } } if ( ! list_empty ( & rinfo -> grants ) ) { list_for_each_entry_safe ( , , , ) { list_del ( & persistent_gnt -> node ) ; if ( persistent_gnt -> gref != INVALID_GRANT_REF ) { gnttab_end_foreign_access ( persistent_gnt -> gref , NULL ) ; rinfo -> persistent_gnts_c -- ; } if ( info -> bounce ) { __free_page ( persistent_gnt -> page ) ; } } } BUG_ON ( rinfo -> persistent_gnts_c != 0 ) ; for ( i = 0 ; i < BLK_RING_SIZE ( info ) ; i ++ ) { if ( ! rinfo -> shadow [ i ] . request ) { free_shadow } segs = rinfo -> shadow [ i ] . req . operation == BLKIF_OP_INDIRECT ?rinfo -> shadow [ i ] . req . u . indirect . nr_segments : rinfo -> shadow [ i ] . req . u . rw . nr_segments ; for ( j = 0 ; j < segs ; j ++ ) { persistent_gnt = rinfo -> shadow [ i ] . grants_used [ j ] ; gnttab_end_foreign_access ( persistent_gnt -> gref , NULL ) ; if ( info -> bounce ) { __free_page ( persistent_gnt -> page ) ; } kfree ( persistent_gnt ) ; } if ( rinfo -> shadow [ i ] . req . operation != BLKIF_OP_INDIRECT ) { free_shadow } for ( j = 0 ; j < INDIRECT_GREFS ( segs ) ; j ++ ) { persistent_gnt = rinfo -> shadow [ i ] . indirect_grants [ j ] ; gnttab_end_foreign_access ( persistent_gnt -> gref , NULL ) ; __free_page ( persistent_gnt -> page ) ; kfree ( persistent_gnt ) ; } free_shadow kvfree ( rinfo -> shadow [ i ] . grants_used ) ; rinfo -> shadow [ i ] . grants_used = NULL ; kvfree ( rinfo -> shadow [ i ] . indirect_grants ) ; rinfo -> shadow [ i ] . indirect_grants = NULL ; kvfree ( rinfo -> shadow [ i ] . sg ) ; rinfo -> shadow [ i ] . sg = NULL ; } gnttab_cancel_free_callback ( & rinfo -> callback ) ; flush_work ( & rinfo -> work ) ; xenbus_teardown_ring ( ( void * * ) & rinfo -> ring . sring , info -> nr_ring_pages , rinfo -> ring_ref ) ; if ( rinfo -> irq ) { unbind_from_irqhandler ( rinfo -> irq , rinfo ) ; } rinfo -> evtchn = rinfo -> irq = 0 ; } 