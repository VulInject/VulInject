static netdev_tx_t atl1c_xmit_frame ( struct sk_buff * skb , struct net_device * netdev ) { struct atl1c_adapter * adapter = netdev_priv ( netdev ) ; u16 tpd_req = 1 ; struct atl1c_tpd_desc * tpd ; enum atl1c_trans_queue type = atl1c_trans_normal ; if ( test_bit ( __AT_DOWN , & adapter -> flags ) ) { return NETDEV_TX_OK ; } tpd_req = atl1c_cal_tpd_req ( skb ) ; if ( atl1c_tpd_avail ( adapter , type ) < tpd_req ) { netif_stop_queue ( netdev ) ; return NETDEV_TX_BUSY ; } tpd = atl1c_get_tpd ( adapter , type ) ; if ( atl1c_tso_csum ( adapter , skb , & tpd , type ) != 0 ) { dev_kfree_skb_any ( skb ) ; return NETDEV_TX_OK ; } if ( unlikely ( skb_vlan_tag_present ( skb ) ) ) { u16 vlan = skb_vlan_tag_get ( skb ) ; __le16 tag ; vlan = cpu_to_le16 ( vlan ) ; AT_VLAN_TO_TAG ( vlan , tag ) ; tpd -> word1 |= 1 << TPD_INS_VTAG_SHIFT ; tpd -> vlan_tag = tag ; } if ( skb_network_offset ( skb ) != ETH_HLEN ) { tpd -> word1 |= 1 << TPD_ETH_TYPE_SHIFT ; } if ( atl1c_tx_map ( adapter , skb , tpd , type ) < 0 ) { netif_info ( adapter , tx_done , adapter -> netdev , "tx-skb droppted due to dma error\n" ) ; atl1c_tx_rollback ( adapter , tpd , type ) ; dev_kfree_skb_any ( skb ) ; } else { netdev_sent_queue ( adapter -> netdev , skb -> len ) ; atl1c_tx_queue ( adapter , skb , tpd , type ) ; } return NETDEV_TX_OK ; } 