void bpe_input ( struct ifnet * ifp0 , struct mbuf * m ) { struct bpe_softc * sc ; struct ifnet * ifp ; struct ether_header * beh , * ceh ; uint32_t * itagp , itag ; unsigned int hlen = sizeof ( * beh ) + sizeof ( * itagp ) + sizeof ( * ceh ) ; struct mbuf * n ; int off ; int prio ; if ( m -> m_len < hlen ) { m = m_pullup ( m , hlen ) ; } beh = mtod ( m , ether_header * ) ; itagp = ( uint32_t * ) ( beh + 1 ) ; itag = bemtoh32 ( itagp ) ; if ( itag & PBB_ITAG_RES2 ) { drop } sc = bpe_find ( ifp0 , itag & PBB_ITAG_ISID ) ; if ( sc == NULL ) { drop } ceh = ( ether_header * ) ( itagp + 1 ) ; etherbridge_map_ea ( & sc -> sc_eb , ceh -> ether_shost , ( ether_addr * ) beh -> ether_shost ) ; m_adj ( m , sizeof ( * beh ) + sizeof ( * itagp ) ) ; n = m_getptr ( m , sizeof ( * ceh ) , & off ) ; if ( n == NULL ) { drop } if ( ! ALIGNED_POINTER ( mtod ( n , caddr_t ) + off , uint32_t ) ) { n = m_dup_pkt ( m , ETHER_ALIGN , M_NOWAIT ) ; m_freem ( m ) ; if ( n == NULL ) { return ; } m = n ; } ifp = & sc -> sc_ac . ac_if ; prio = sc -> sc_rxhprio ; switch ( prio ) { case IF_HDRPRIO_PACKET : break ; case IF_HDRPRIO_OUTER : m -> m_pkthdr . pf . prio = ( itag & PBB_ITAG_PCP_MASK ) >> PBB_ITAG_PCP_SHIFT ; break ; default : m -> m_pkthdr . pf . prio = prio ; break ; } m -> m_flags &= ~ ( M_BCAST | M_MCAST ) ; m -> m_pkthdr . ph_ifidx = ifp -> if_index ; m -> m_pkthdr . ph_rtableid = ifp -> if_rdomain ; pf_pkt_addr_changed ( m ) ; if_vinput ( ifp , m ) ; return ; drop m_freem ( m ) ; } 