int vmw_user_dmabuf_alloc ( struct vmw_private * dev_priv , struct ttm_object_file * tfile , uint32_t size , bool shareable , uint32_t * handle , struct vmw_dma_buffer * * p_dma_buf , struct ttm_base_object * * p_base ) { struct vmw_user_dma_buffer * user_bo ; struct ttm_buffer_object * tmp ; int ret ; user_bo = kmalloc ( sizeof ( * user_bo ) , GFP_KERNEL ) ; if ( unlikely ( user_bo == NULL ) ) { DRM_ERROR ( "Failed to allocate a buffer.\n" ) ; return - ENOMEM ; } ret = vmw_dmabuf_init ( dev_priv , & user_bo -> dma , size , ( dev_priv -> has_mob ) ?& vmw_sys_placement : & vmw_vram_sys_placement , true , & vmw_user_dmabuf_destroy ) ; if ( unlikely ( ret != 0 ) ) { return ret ; } tmp = ttm_bo_reference ( & user_bo -> dma . base ) ; ret = ttm_prime_object_init ( tfile , size , & user_bo -> prime , shareable , ttm_buffer_type , & vmw_user_dmabuf_release , & vmw_user_dmabuf_ref_obj_release ) ; if ( unlikely ( ret != 0 ) ) { ttm_bo_unref ( & tmp ) ; out_no_base_object } * p_dma_buf = & user_bo -> dma ; if ( p_base ) { * p_base = & user_bo -> prime . base ; kref_get ( & ( * p_base ) -> refcount ) ; } * handle = user_bo -> prime . base . hash . key ; out_no_base_object return ret ; } 