void free_job_info ( job_info * jinfo ) { if ( jinfo -> name != NULL ) { free ( jinfo -> name ) ; } if ( jinfo -> comment != NULL ) { free ( jinfo -> comment ) ; } if ( jinfo -> account != NULL ) { free ( jinfo -> account ) ; } if ( jinfo -> group != NULL ) { free ( jinfo -> group ) ; } free_resource_req_list ( jinfo -> resreq ) ; free_resource_req_list ( jinfo -> resused ) ; free ( jinfo ) ; } void free_jobs ( job_info * * jarr ) { int i ; if ( jarr == NULL ) { return ; } for ( i = 0 ; jarr [ i ] != NULL ; i ++ ) { free_job_info ( jarr [ i ] ) ; } } resource_req * find_resource_req ( resource_req * reqlist , const char * name ) { resource_req * resreq ; resreq = reqlist ; while ( resreq != NULL && strcmp ( resreq -> name , name ) ) { resreq = resreq -> next ; } return resreq ; } void free_resource_req_list ( resource_req * list ) { resource_req * resreq , * tmp ; resreq = list ; while ( resreq != NULL ) { tmp = resreq ; resreq = resreq -> next ; if ( tmp -> name != NULL ) { free ( tmp -> name ) ; } if ( tmp -> res_str != NULL ) { free ( tmp -> res_str ) ; } free ( tmp ) ; } } void print_job_info ( job_info * jinfo , char brief ) { resource_req * resreq ; if ( jinfo == NULL ) { return ; } if ( jinfo -> name != NULL ) { printf ( "%sJob Name: %s\n" , brief ?"      " : "" , jinfo -> name ) ; } if ( ! brief ) { if ( jinfo -> comment != NULL ) { printf ( "comment: %s\n" , jinfo -> comment ) ; } if ( jinfo -> queue != NULL ) { printf ( "queue: %s\n" , jinfo -> queue -> name ) ; } if ( jinfo -> job_node ) { printf ( "node: %s\n" , jinfo -> job_node -> name ) ; } if ( jinfo -> account ) { printf ( "account: %s\n" , jinfo -> account ) ; } if ( jinfo -> group ) { printf ( "group: %s\n" , jinfo -> group ) ; } printf ( "priority: %d\n" , jinfo -> priority ) ; printf ( "sch_priority: %d\n" , jinfo -> sch_priority ) ; printf ( "qtime: %d: %s" , ( int ) jinfo -> qtime , ctime ( & ( jinfo -> qtime ) ) ) ; printf ( "is_queued: %s\n" , jinfo -> is_queued ?"TRUE" : "FALSE" ) ; printf ( "is_running: %s\n" , jinfo -> is_running ?"TRUE" : "FALSE" ) ; printf ( "is_held: %s\n" , jinfo -> is_held ?"TRUE" : "FALSE" ) ; printf ( "is_waiting: %s\n" , jinfo -> is_waiting ?"TRUE" : "FALSE" ) ; printf ( "is_transit: %s\n" , jinfo -> is_transit ?"TRUE" : "FALSE" ) ; printf ( "is_exiting: %s\n" , jinfo -> is_exiting ?"TRUE" : "FALSE" ) ; printf ( "is_completed: %s\n" , jinfo -> is_completed ?"TRUE" : "FALSE" ) ; printf ( "is_starving: %s\n" , jinfo -> is_starving ?"TRUE" : "FALSE" ) ; printf ( "can_not_run: %s\n" , jinfo -> can_not_run ?"TRUE" : "FALSE" ) ; printf ( "can_never_run: %s\n" , jinfo -> can_never_run ?"TRUE" : "FALSE" ) ; resreq = jinfo -> resreq ; while ( resreq != NULL ) { printf ( "resreq %s %ld\n" , resreq -> name , resreq -> amount ) ; resreq = resreq -> next ; } } } void set_state ( char * state , job_info * jinfo ) { switch ( state [ 0 ] ) { case 'Q' : jinfo -> is_queued = 1 ; break ; case 'R' : jinfo -> is_running = 1 ; break ; case 'T' : jinfo -> is_transit = 1 ; break ; case 'H' : jinfo -> is_held = 1 ; break ; case 'W' : jinfo -> is_waiting = 1 ; break ; case 'E' : jinfo -> is_exiting = 1 ; break ; case 'S' : jinfo -> is_suspended = 1 ; break ; case 'C' : jinfo -> is_completed = 1 ; break ; } } void update_job_on_run ( int pbs_sd , job_info * jinfo ) { jinfo -> is_queued = 0 ; jinfo -> is_running = 1 ; } int update_job_comment ( int pbs_sd , job_info * jinfo , const char * comment ) { struct attrl attr = { NULL ( char * ) ATTR_comment NULL NULL SET } ; int local_errno = 0 ; static char clone [ UDC_CLONEBUFSIZ ] ; if ( jinfo == NULL ) { return 1 ; } if ( jinfo -> comment == NULL || strcmp ( jinfo -> comment , comment ) ) { if ( jinfo -> comment != NULL ) { free ( jinfo -> comment ) ; } jinfo -> comment = string_dup ( ( char * ) comment ) ; strncpy ( clone , comment , ( size_t ) ( UDC_CLONEBUFSIZ - 1 ) ) ; clone [ UDC_CLONEBUFSIZ - 1 ] = '\0' ; attr . value = clone ; pbs_alterjob_err ( pbs_sd , jinfo -> name , & attr , NULL , & local_errno ) ; return 0 ; } return 1 ; } void update_jobs_cant_run ( int pbs_sd , job_info * * jinfo_arr , job_info * start , const char * comment , int start_where ) { int i = 0 ; if ( jinfo_arr != NULL ) { if ( start != NULL ) { for ( ; jinfo_arr [ i ] != NULL && jinfo_arr [ i ] != start ; i ++ ) { } } else { i = 0 ; } if ( jinfo_arr [ i ] != NULL ) { if ( start_where == START_BEFORE_JOB ) { i -- ; } if ( start_where == START_AFTER_JOB ) { i ++ ; } for ( ; jinfo_arr [ i ] != NULL ; i ++ ) { jinfo_arr [ i ] -> can_not_run = 1 ; update_job_comment ( pbs_sd , jinfo_arr [ i ] , comment ) ; } } } } job_info * * job_filter ( job_info * * jobs , int size , int * filter_func ( job_info * , void * ) , void * arg ) { job_info * * new_jobs = NULL ; job_info * * tmp = NULL ; int i , j = 0 ; if ( ( new_jobs = ( job_info * * ) malloc ( ( size + 1 ) * sizeof ( job_info * ) ) ) == NULL ) { perror ( "Memory allocation error" ) ; return NULL ; } for ( i = 0 ; i < size ; i ++ ) { if ( filter_func ( jobs [ i ] , arg ) ) { new_jobs [ j ] = jobs [ i ] ; j ++ ; } } if ( ( tmp = ( job_info * * ) realloc ( new_jobs , ( j + 1 ) * sizeof ( job_info * ) ) ) == NULL ) { free ( new_jobs ) ; perror ( "Memory Allocation Error" ) ; return NULL ; } new_jobs = tmp ; new_jobs [ j ] = NULL ; return new_jobs ; } int translate_job_fail_code ( int fail_code , char * comment_msg , char * log_msg ) { int rc = 1 ; if ( fail_code < num_res ) { strcpy ( comment_msg , res_to_check [ fail_code ] . comment_msg ) ; strcpy ( log_msg , res_to_check [ fail_code ] . debug_msg ) ; } else { switch ( fail_code ) { case QUEUE_JOB_LIMIT_REACHED : strcpy ( comment_msg , COMMENT_QUEUE_JOB_LIMIT ) ; strcpy ( log_msg , INFO_QUEUE_JOB_LIMIT ) ; break ; case SERVER_JOB_LIMIT_REACHED : strcpy ( comment_msg , COMMENT_SERVER_JOB_LIMIT ) ; strcpy ( log_msg , INFO_SERVER_JOB_LIMIT ) ; break ; case SERVER_USER_LIMIT_REACHED : strcpy ( comment_msg , COMMENT_SERVER_USER_LIMIT ) ; strcpy ( log_msg , INFO_SERVER_USER_LIMIT ) ; break ; case QUEUE_USER_LIMIT_REACHED : strcpy ( comment_msg , COMMENT_QUEUE_USER_LIMIT ) ; strcpy ( log_msg , INFO_QUEUE_USER_LIMIT ) ; break ; case QUEUE_GROUP_LIMIT_REACHED : strcpy ( comment_msg , COMMENT_QUEUE_GROUP_LIMIT ) ; strcpy ( log_msg , INFO_QUEUE_GROUP_LIMIT ) ; break ; case SERVER_GROUP_LIMIT_REACHED : strcpy ( comment_msg , COMMENT_SERVER_GROUP_LIMIT ) ; strcpy ( log_msg , INFO_SERVER_GROUP_LIMIT ) ; break ; case CROSS_DED_TIME_BOUNDRY : strcpy ( comment_msg , COMMENT_CROSS_DED_TIME ) ; strcpy ( log_msg , INFO_CROSS_DED_TIME ) ; break ; case NO_AVAILABLE_NODE : strcpy ( comment_msg , COMMENT_NO_AVAILABLE_NODE ) ; strcpy ( log_msg , INFO_NO_AVAILABLE_NODE ) ; break ; case NOT_QUEUED : log_msg [ 0 ] = '\0' ; comment_msg [ 0 ] = '\0' ; rc = 0 ; break ; case NOT_ENOUGH_NODES_AVAIL : strcpy ( comment_msg , COMMENT_NOT_ENOUGH_NODES_AVAIL ) ; strcpy ( log_msg , INFO_NOT_ENOUGH_NODES_AVAIL ) ; break ; case JOB_STARVING : strcpy ( comment_msg , COMMENT_JOB_STARVING ) ; sprintf ( log_msg , INFO_JOB_STARVING , cstat . starving_job -> name ) ; break ; case SCHD_ERROR : strcpy ( comment_msg , COMMENT_SCHD_ERROR ) ; strcpy ( log_msg , INFO_SCHD_ERROR ) ; break ; case SERVER_TOKEN_UTILIZATION : strcpy ( comment_msg , COMMENT_TOKEN_UTILIZATION ) ; sprintf ( log_msg , INFO_TOKEN_UTILIZATION ) ; break ; default : rc = 0 ; comment_msg [ 0 ] = '\0' ; log_msg [ 0 ] = '\0' ; } } return rc ; } int calc_assn_resource ( job_info * * jinfo_arr , char * resstr ) { resource_req * req ; int res_amm = 0 ; int i ; if ( resstr == NULL || jinfo_arr == NULL ) { return - 1 ; } for ( i = 0 ; jinfo_arr [ i ] != NULL ; i ++ ) { req = find_resource_req ( jinfo_arr [ i ] -> resreq , resstr ) ; if ( req != NULL ) { res_amm += req -> amount ; } } return res_amm ; } 