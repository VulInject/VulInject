void ahd_done ( struct ahd_softc * ahd , struct scb * scb ) { struct scsi_xfer * xs = scb -> xs ; TAILQ_REMOVE ( & ahd -> pending_scbs , scb , next ) ; timeout_del ( & xs -> stimeout ) ; if ( xs -> datalen ) { int op ; if ( ( xs -> flags & SCSI_DATA_IN ) != 0 ) { op = BUS_DMASYNC_POSTREAD ; } else { op = BUS_DMASYNC_POSTWRITE ; } bus_dmamap_sync ( ahd -> parent_dmat , scb -> dmamap , 0 , scb -> dmamap -> dm_mapsize , op ) ; bus_dmamap_unload ( ahd -> parent_dmat , scb -> dmamap ) ; } switch ( xs -> error ) { case CAM_SCSI_STATUS_ERROR : case CAM_REQ_INPROG : case CAM_REQ_CMP : switch ( xs -> status ) { case SCSI_TASKSET_FULL : case SCSI_BUSY : xs -> error = XS_BUSY ; break ; case SCSI_CHECK : case SCSI_TERMINATED : if ( ( scb -> flags & SCB_SENSE ) == 0 ) { xs -> error = XS_DRIVER_STUFFUP ; } else { xs -> error = XS_NOERROR ; } break ; default : xs -> error = XS_NOERROR ; break ; } break ; case CAM_BUSY : case CAM_REQUEUE_REQ : xs -> error = XS_BUSY ; break ; case CAM_CMD_TIMEOUT : xs -> error = XS_TIMEOUT ; break ; case CAM_BDR_SENT : case CAM_SCSI_BUS_RESET : xs -> error = XS_RESET ; break ; case CAM_SEL_TIMEOUT : xs -> error = XS_SELTIMEOUT ; break ; default : xs -> error = XS_DRIVER_STUFFUP ; break ; } if ( xs -> error != XS_NOERROR ) { } if ( ( scb -> flags & SCB_SENSE ) != 0 ) { memset ( & xs -> sense , 0 , sizeof ( scsi_sense_data ) ) ; memcpy ( & xs -> sense , ahd_get_sense_buf ( ahd , scb ) , sizeof ( scsi_sense_data ) ) ; xs -> error = XS_SENSE ; } if ( ( scb -> flags & SCB_PKT_SENSE ) != 0 ) { struct scsi_status_iu_header * siu ; u_int32_t len ; siu = ( scsi_status_iu_header * ) scb -> sense_data ; len = SIU_SENSE_LENGTH ( siu ) ; memcpy ( & xs -> sense , SIU_SENSE_DATA ( siu ) , ulmin ( len , sizeof ( xs -> sense ) ) ) ; xs -> error = XS_SENSE ; } scsi_done ( xs ) ; } 