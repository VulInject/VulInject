static efi_status_t preserve_pci_rom_image ( efi_pci_io_protocol_t * pci , struct pci_setup_rom * * __rom ) { struct pci_setup_rom * rom = NULL ; efi_status_t status ; unsigned long size ; uint64_t romsize ; void * romimage ; romimage = efi_table_attr ( pci , romimage ) ; romsize = efi_table_attr ( pci , romsize ) ; if ( ! romimage || ! romsize || romsize > SZ_16M ) { return EFI_INVALID_PARAMETER ; } size = romsize + sizeof ( * rom ) ; status = efi_bs_call ( allocate_pool , EFI_LOADER_DATA , size , ( void * * ) & rom ) ; if ( status != EFI_SUCCESS ) { efi_err ( "Failed to allocate memory for 'rom'\n" ) ; return status ; } rom -> data . type = SETUP_PCI ; rom -> data . len = size - sizeof ( setup_data ) ; rom -> data . next = 0 ; rom -> pcilen = pci -> romsize ; * __rom = rom ; status = efi_call_proto ( pci , pci . read , EfiPciIoWidthUint16 , PCI_VENDOR_ID , 1 , & rom -> vendor ) ; if ( status != EFI_SUCCESS ) { efi_err ( "Failed to read rom->vendor\n" ) ; free_struct } status = efi_call_proto ( pci , pci . read , EfiPciIoWidthUint16 , PCI_DEVICE_ID , 1 , & rom -> devid ) ; if ( status != EFI_SUCCESS ) { efi_err ( "Failed to read rom->devid\n" ) ; free_struct } status = efi_call_proto ( pci , get_location , & rom -> segment , & rom -> bus , & rom -> device , & rom -> function ) ; if ( status != EFI_SUCCESS ) { free_struct } memcpy ( rom -> romdata , romimage , romsize ) ; return status ; free_struct efi_bs_call ( free_pool , rom ) ; return status ; } 