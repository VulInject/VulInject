krb5_error_code kdc_fast_make_cookie ( krb5_context context , struct kdc_request_state * state , krb5_db_entry * local_tgt , krb5_keyblock * local_tgt_key , krb5_const_principal client_princ , krb5_pa_data * * cookie_out ) { krb5_error_code ret ; krb5_secure_cookie cookie ; krb5_pa_data * * contents = state -> out_cookie_padata , * pa ; krb5_keyblock * key = NULL ; krb5_timestamp now ; krb5_enc_data enc ; krb5_data * der_cookie = NULL ; size_t ctlen ; * cookie_out = NULL ; memset ( & enc , 0 , sizeof ( enc ) ) ; if ( contents == NULL || * contents == NULL || local_tgt_key == NULL ) { return make_padata ( KRB5_PADATA_FX_COOKIE , "MIT" , 3 , cookie_out ) ; } ret = derive_cookie_key ( context , local_tgt_key , client_princ , & key ) ; if ( ret ) { cleanup } ret = krb5_timeofday ( context , & now ) ; if ( ret ) { cleanup } cookie . time = ts2tt ( now ) ; cookie . data = contents ; ret = encode_krb5_secure_cookie ( & cookie , & der_cookie ) ; if ( ret ) { cleanup } ret = krb5_c_encrypt_length ( context , key -> enctype , der_cookie -> length , & ctlen ) ; if ( ret ) { cleanup } ret = alloc_data ( & enc . ciphertext , ctlen ) ; if ( ret ) { cleanup } ret = krb5_c_encrypt ( context , key , KRB5_KEYUSAGE_PA_FX_COOKIE , NULL , der_cookie , & enc ) ; if ( ret ) { cleanup } ret = k5_alloc_pa_data ( KRB5_PADATA_FX_COOKIE , 8 + enc . ciphertext . length , & pa ) ; memcpy ( pa -> contents , "MIT1" , 4 ) ; store_32_be ( current_kvno ( local_tgt ) , pa -> contents + 4 ) ; memcpy ( pa -> contents + 8 , enc . ciphertext . data , enc . ciphertext . length ) ; * cookie_out = pa ; cleanup krb5_free_keyblock ( context , key ) ; if ( der_cookie != NULL ) { zapfree ( der_cookie -> data , der_cookie -> length ) ; } krb5_free_data_contents ( context , & enc . ciphertext ) ; return ret ; } 