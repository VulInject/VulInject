static int tonemap_vaapi_build_filter_params ( AVFilterContext * avctx ) { VAAPIVPPContext * vpp_ctx = avctx -> priv ; HDRVAAPIContext * ctx = avctx -> priv ; VAStatus vas ; VAProcFilterParameterBufferHDRToneMapping hdrtm_param ; VAProcFilterCapHighDynamicRange hdr_cap [ VAProcHighDynamicRangeMetadataTypeCount ] ; int num_query_caps ; int i ; memset ( & ctx -> in_metadata , 0 , sizeof ( ctx -> in_metadata ) ) ; num_query_caps = VAProcHighDynamicRangeMetadataTypeCount ; vas = vaQueryVideoProcFilterCaps ( vpp_ctx -> hwctx -> display , vpp_ctx -> va_context , VAProcFilterHighDynamicRangeToneMapping , & hdr_cap , & num_query_caps ) ; if ( vas != VA_STATUS_SUCCESS ) { av_log ( avctx , AV_LOG_ERROR , "Failed to query HDR caps " "context: %d (%s).\n" , vas , vaErrorStr ( vas ) ) ; return AVERROR ( EIO ) ; } for ( i = 0 ; i < num_query_caps ; i ++ ) { if ( hdr_cap [ i ] . metadata_type != VAProcHighDynamicRangeMetadataNone ) { break ; } } if ( i >= num_query_caps ) { av_log ( avctx , AV_LOG_ERROR , "VAAPI driver doesn't support HDR\n" ) ; return AVERROR ( EINVAL ) ; } for ( i = 0 ; i < num_query_caps ; i ++ ) { if ( VA_TONE_MAPPING_HDR_TO_SDR & hdr_cap [ i ] . caps_flag ) { break ; } } if ( i >= num_query_caps ) { av_log ( avctx , AV_LOG_ERROR , "VAAPI driver doesn't support HDR to SDR\n" ) ; return AVERROR ( EINVAL ) ; } hdrtm_param . type = VAProcFilterHighDynamicRangeToneMapping ; hdrtm_param . data . metadata_type = VAProcHighDynamicRangeMetadataHDR10 ; hdrtm_param . data . metadata = & ctx -> in_metadata ; hdrtm_param . data . metadata_size = sizeof ( VAHdrMetaDataHDR10 ) ; return ff_vaapi_vpp_make_param_buffers ( avctx , VAProcFilterParameterBufferType , & hdrtm_param , sizeof ( hdrtm_param ) , 1 ) ; } 