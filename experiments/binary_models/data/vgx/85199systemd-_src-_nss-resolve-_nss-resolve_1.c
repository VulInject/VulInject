enum nss_status _nss_resolve_gethostbyaddr2_r ( const void * addr , socklen_t len , int af , struct hostent * result , char * buffer , size_t buflen , int * errnop , int * h_errnop , int32_t * ttlp ) { _cleanup_ ( ) Varlink * link = NULL ; _cleanup_ ( ) JsonVariant * cparams = NULL ; _cleanup_ ( ) ResolveAddressReply p = { } ; JsonVariant * rparams , * entry ; int r ; PROTECT_ERRNO ; NSS_ENTRYPOINT_BEGIN ; assert ( addr ) ; assert ( result ) ; assert ( buffer ) ; assert ( h_errnop ) ; if ( ! IN_SET ( af , AF_INET , AF_INET6 ) ) { UNPROTECT_ERRNO ; * errnop = EAFNOSUPPORT ; * h_errnop = NO_DATA ; return NSS_STATUS_UNAVAIL ; } if ( len != FAMILY_ADDRESS_SIZE ( af ) ) { r = - EINVAL ; fail } r = connect_to_resolved ( & link ) ; if ( r < 0 ) { fail } r = json_build ( & cparams , JSON_BUILD_OBJECT ( JSON_BUILD_PAIR ( "address" , JSON_BUILD_BYTE_ARRAY ( addr , len ) ) , JSON_BUILD_PAIR ( "family" , JSON_BUILD_INTEGER ( af ) ) , JSON_BUILD_PAIR ( "flags" , JSON_BUILD_UNSIGNED ( query_flags ( ) ) ) ) ) ; if ( r < 0 ) { fail } const char * error_id ; r = varlink_call ( link , "io.systemd.Resolve.ResolveAddress" , cparams , & rparams , & error_id , NULL ) ; if ( r < 0 ) { fail } if ( ! isempty ( error_id ) ) { if ( error_shall_try_again ( error_id ) ) { try_again } if ( error_shall_fallback ( error_id ) ) { fail } not_found } r = json_dispatch ( rparams , resolve_address_reply_dispatch_table , NULL , json_dispatch_flags , & p ) ; if ( r < 0 ) { fail } if ( json_variant_is_blank_object ( p . names ) ) { not_found } size_t ms = 0 , idx ; JSON_VARIANT_ARRAY_FOREACH ( , ) { _cleanup_ ( ) NameParameters q = { } ; r = json_dispatch ( entry , name_parameters_dispatch_table , NULL , json_dispatch_flags , & q ) ; if ( r < 0 ) { fail } ms += ALIGN ( strlen ( q . name ) + 1 ) ; } size_t n_names = json_variant_elements ( p . names ) ; ms += ALIGN ( len ) + 2 * sizeof ( char * ) + n_names * sizeof ( char * ) ; if ( buflen < ms ) { UNPROTECT_ERRNO ; * errnop = ERANGE ; * h_errnop = NETDB_INTERNAL ; return NSS_STATUS_TRYAGAIN ; } char * r_addr = buffer ; memcpy ( r_addr , addr , len ) ; idx = ALIGN ( len ) ; char * r_addr_list = buffer + idx ; ( ( char * * ) r_addr_list ) [ 0 ] = r_addr ; ( ( char * * ) r_addr_list ) [ 1 ] = NULL ; idx += sizeof ( char * ) * 2 ; char * r_aliases = buffer + idx ; idx += sizeof ( char * ) * n_names ; char * r_name = buffer + idx ; size_t i = 0 ; JSON_VARIANT_ARRAY_FOREACH ( , ) { _cleanup_ ( ) NameParameters q = { } ; r = json_dispatch ( entry , name_parameters_dispatch_table , NULL , json_dispatch_flags , & q ) ; if ( r < 0 ) { fail } size_t l = strlen ( q . name ) ; char * z = buffer + idx ; memcpy ( z , q . name , l + 1 ) ; if ( i > 0 ) { ( ( char * * ) r_aliases ) [ i - 1 ] = z ; } i ++ ; idx += ALIGN ( l + 1 ) ; } ( ( char * * ) r_aliases ) [ n_names - 1 ] = NULL ; assert ( idx == ms ) ; result -> h_name = r_name ; result -> h_aliases = ( char * * ) r_aliases ; result -> h_addrtype = af ; result -> h_length = len ; result -> h_addr_list = ( char * * ) r_addr_list ; if ( ttlp ) { * ttlp = 0 ; } * h_errnop = NETDB_SUCCESS ; h_errno = 0 ; return NSS_STATUS_SUCCESS ; fail UNPROTECT_ERRNO ; * errnop = - r ; * h_errnop = NO_RECOVERY ; return NSS_STATUS_UNAVAIL ; not_found * h_errnop = HOST_NOT_FOUND ; return NSS_STATUS_NOTFOUND ; try_again UNPROTECT_ERRNO ; * errnop = - r ; * h_errnop = TRY_AGAIN ; return NSS_STATUS_TRYAGAIN ; } 