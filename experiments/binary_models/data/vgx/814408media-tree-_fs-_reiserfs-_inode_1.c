static int convert_tail_for_hole ( struct inode * inode , struct buffer_head * bh_result , loff_t tail_offset ) { unsigned long index ; unsigned long tail_end ; unsigned long tail_start ; struct page * tail_page ; struct page * hole_page = bh_result -> b_page ; int retval = 0 ; if ( ( tail_offset & ( bh_result -> b_size - 1 ) ) != 1 ) { return - EIO ; } tail_start = tail_offset & ( PAGE_SIZE - 1 ) ; tail_end = ( tail_start | ( bh_result -> b_size - 1 ) ) + 1 ; index = tail_offset >> PAGE_SHIFT ; if ( ! hole_page || index != hole_page -> index ) { tail_page = grab_cache_page ( inode -> i_mapping , index ) ; retval = - ENOMEM ; if ( ! tail_page ) { out } } else { tail_page = hole_page ; } fix_tail_page_for_writing ( tail_page ) ; retval = __reiserfs_write_begin ( tail_page , tail_start , tail_end - tail_start ) ; if ( retval ) { unlock } flush_dcache_page ( tail_page ) ; retval = reiserfs_commit_write ( NULL , tail_page , tail_start , tail_end ) ; unlock if ( tail_page != hole_page ) { unlock_page ( tail_page , NULL ) ; put_page ( tail_page ) ; } out return retval ; } 