int l1_event ( struct layer1 * l1 , u_int event ) { int err = 0 ; if ( ! l1 ) { return - EINVAL ; } switch ( event ) { case HW_RESET_IND : mISDN_FsmEvent ( & l1 -> l1m , EV_RESET_IND , NULL ) ; break ; case HW_DEACT_IND : mISDN_FsmEvent ( & l1 -> l1m , EV_DEACT_IND , NULL ) ; break ; case HW_POWERUP_IND : mISDN_FsmEvent ( & l1 -> l1m , EV_POWER_UP , NULL ) ; break ; case HW_DEACT_CNF : mISDN_FsmEvent ( & l1 -> l1m , EV_DEACT_CNF , NULL ) ; break ; case ANYSIGNAL : mISDN_FsmEvent ( & l1 -> l1m , EV_ANYSIG_IND ) ; break ; case LOSTFRAMING : mISDN_FsmEvent ( & l1 -> l1m , EV_ANYSIG_IND , NULL ) ; break ; case INFO2 : mISDN_FsmEvent ( & l1 -> l1m , EV_INFO2_IND , NULL ) ; break ; case INFO4_P8 : mISDN_FsmEvent ( & l1 -> l1m , EV_INFO4_IND , NULL ) ; break ; case INFO4_P10 : mISDN_FsmEvent ( & l1 -> l1m , EV_INFO4_IND , NULL ) ; break ; case PH_ACTIVATE_REQ : if ( test_bit ( FLG_L1_ACTIVATED , & l1 -> Flags ) ) { l1 -> dcb ( l1 -> dch , PH_ACTIVATE_IND ) ; } else { test_and_set_bit ( FLG_L1_ACTIVATING , & l1 -> Flags ) ; mISDN_FsmEvent ( & l1 -> l1m , EV_PH_ACTIVATE , NULL ) ; } break ; case CLOSE_CHANNEL : release_l1 ( l1 ) ; break ; default : if ( ( event & ~ HW_TIMER3_VMASK ) == HW_TIMER3_VALUE ) { int val = event & HW_TIMER3_VMASK ; if ( val < 5 ) { val = 5 ; } if ( val > 30 ) { val = 30 ; } l1 -> t3_value = val ; break ; } if ( * debug & DEBUG_L1 ) { printk ( KERN_DEBUG "%s %x unhandled\n" , __func__ , event ) ; } err = - EINVAL ; } return err ; } 