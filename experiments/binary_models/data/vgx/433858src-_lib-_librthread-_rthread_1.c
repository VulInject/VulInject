int pthread_create ( pthread_t * threadp , const pthread_attr_t * attr , void * * start_routine ( void * ) , void * arg ) { extern int __isthreaded ; struct tib * tib ; pthread_t thread ; struct __tfork param ; int rc ; if ( ! _threads_ready ) { _rthread_init ( ) ; } _rthread_reaper ( ) ; tib = _dl_allocate_tib ( sizeof ( * thread ) ) ; thread = tib -> tib_thread ; memset ( thread , 0 , sizeof ( * thread ) ) ; thread -> tib = tib ; thread -> donesem . lock = _SPINLOCK_UNLOCKED ; thread -> flags_lock = _SPINLOCK_UNLOCKED ; thread -> fn = start_routine ; thread -> arg = arg ; tib -> tib_tid = - 1 ; thread -> attr = attr != NULL ?* ( * attr ) : _rthread_attr_default ; if ( thread -> attr . sched_inherit == PTHREAD_INHERIT_SCHED ) { pthread_t self = pthread_self ( ) ; thread -> attr . sched_policy = self -> attr . sched_policy ; thread -> attr . sched_param = self -> attr . sched_param ; } if ( thread -> attr . detach_state == PTHREAD_CREATE_DETACHED ) { thread -> flags |= THREAD_DETACHED ; } thread -> stack = _rthread_alloc_stack ( thread ) ; if ( ! thread -> stack ) { rc = errno ; fail1 } param . tf_tcb = TIB_TO_TCB ( tib ) ; param . tf_tid = & tib -> tib_tid ; param . tf_stack = thread -> stack -> sp ; _spinlock ( & _thread_lock ) ; LIST_INSERT_HEAD ( & _thread_list , thread , threads ) ; _spinunlock ( & _thread_lock ) ; __isthreaded = 1 ; rc = __tfork_thread ( & param , sizeof ( param ) , _rthread_start , thread ) ; if ( rc != - 1 ) { * threadp = thread ; return ( 0 ) ; } rc = errno ; _spinlock ( & _thread_lock ) ; LIST_REMOVE ( thread , threads ) ; _spinunlock ( & _thread_lock ) ; _rthread_free_stack ( thread -> stack ) ; fail1 _dl_free_tib ( tib , sizeof ( * thread ) ) ; return ( rc ) ; } 