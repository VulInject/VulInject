static int nt35950_probe ( struct mipi_dsi_device * dsi ) { struct device * dev = & dsi -> dev ; struct device_node * dsi_r ; struct mipi_dsi_host * dsi_r_host ; struct nt35950 * nt ; const struct mipi_dsi_device_info * info ; int i , num_dsis = 1 , ret ; nt = devm_kzalloc ( dev , sizeof ( * nt ) , GFP_KERNEL ) ; if ( ! nt ) { return - ENOMEM ; } ret = nt35950_sharp_init_vregs ( nt , dev ) ; if ( ret ) { return dev_err_probe ( dev , ret , "Regulator init failure.\n" ) ; } nt -> desc = of_device_get_match_data ( dev ) ; nt -> reset_gpio = devm_gpiod_get ( dev , "reset" , GPIOD_ASIS ) ; if ( IS_ERR ( nt -> reset_gpio ) ) { return dev_err_probe ( dev , PTR_ERR ( nt -> reset_gpio ) , "Failed to get reset gpio\n" ) ; } if ( nt -> desc -> is_dual_dsi ) { info = & nt -> desc -> dsi_info ; dsi_r = of_graph_get_remote_node ( dsi -> dev . of_node , 1 , - 1 ) ; if ( ! dsi_r ) { dev_err ( dev , "Cannot get secondary DSI node.\n" ) ; return - ENODEV ; } dsi_r_host = of_find_mipi_dsi_host_by_node ( dsi_r ) ; of_node_put ( dsi_r ) ; if ( ! dsi_r_host ) { dev_err ( dev , "Cannot get secondary DSI host\n" ) ; return - EPROBE_DEFER ; } nt -> dsi [ 1 ] = mipi_dsi_device_register_full ( dsi_r_host , info ) ; if ( ! nt -> dsi [ 1 ] ) { dev_err ( dev , "Cannot get secondary DSI node\n" ) ; return - ENODEV ; } num_dsis ++ ; } nt -> dsi [ 0 ] = dsi ; mipi_dsi_set_drvdata ( dsi , nt ) ; drm_panel_init ( & nt -> panel , dev , & nt35950_panel_funcs , DRM_MODE_CONNECTOR_DSI ) ; ret = drm_panel_of_backlight ( & nt -> panel ) ; if ( ret ) { return dev_err_probe ( dev , ret , "Failed to get backlight\n" ) ; } drm_panel_add ( & nt -> panel ) ; for ( i = 0 ; i < num_dsis ; i ++ ) { nt -> dsi [ i ] -> lanes = nt -> desc -> num_lanes ; nt -> dsi [ i ] -> format = MIPI_DSI_FMT_RGB888 ; nt -> dsi [ i ] -> mode_flags = MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM ; if ( nt -> desc -> mode_data [ 0 ] . is_video_mode ) { nt -> dsi [ i ] -> mode_flags |= MIPI_DSI_MODE_VIDEO ; } ret = mipi_dsi_attach ( nt -> dsi [ i ] ) ; if ( ret < 0 ) { return dev_err_probe ( dev , ret , "Cannot attach to DSI%d host.\n" , i ) ; } } gpiod_set_value_cansleep ( nt -> reset_gpio , 0 ) ; return 0 ; } 