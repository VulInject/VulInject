void r8712_set_ps_mode ( struct _adapter * padapter , uint ps_mode , uint smart_ps ) { struct pwrctrl_priv * pwrpriv = & padapter -> pwrctrlpriv ; if ( ps_mode == PS_MODE_ACTIVE ) { smart_ps = 0 ; } if ( ( pwrpriv -> pwr_mode != ps_mode ) || ( pwrpriv -> smart_ps != smart_ps ) ) { if ( pwrpriv -> pwr_mode == PS_MODE_ACTIVE ) { pwrpriv -> bSleep = true ; } else { pwrpriv -> bSleep = false ; } pwrpriv -> pwr_mode = ps_mode ; pwrpriv -> smart_ps = smart_ps ; schedule_work ( & pwrpriv -> SetPSModeWorkItem ) ; } } void r8712_cpwm_int_hdl ( struct _adapter * padapter , struct reportpwrstate_parm * preportpwrstate ) { struct pwrctrl_priv * pwrpriv = & ( padapter -> pwrctrlpriv ) ; struct cmd_priv * pcmdpriv = & ( padapter -> cmdpriv ) ; if ( pwrpriv -> cpwm_tog == ( ( preportpwrstate -> state ) & 0x80 ) ) { return ; } del_timer ( & padapter -> pwrctrlpriv . rpwm_check_timer ) ; mutex_lock ( & pwrpriv -> mutex_lock ) ; pwrpriv -> cpwm = ( preportpwrstate -> state ) & 0xf ; if ( pwrpriv -> cpwm >= PS_STATE_S2 ) { if ( pwrpriv -> alives & CMD_ALIVE ) { complete ( & ( pcmdpriv -> cmd_queue_comp ) ) ; } } pwrpriv -> cpwm_tog = ( preportpwrstate -> state ) & 0x80 ; mutex_unlock ( & pwrpriv -> mutex_lock ) ; } 