static int ov8865_probe ( struct i2c_client * client ) { struct device * dev = & client -> dev ; struct fwnode_handle * handle ; struct ov8865_sensor * sensor ; struct v4l2_subdev * subdev ; struct media_pad * pad ; unsigned int rate = 0 ; unsigned int i ; int ret ; sensor = devm_kzalloc ( dev , sizeof ( * sensor ) , GFP_KERNEL ) ; if ( ! sensor ) { return - ENOMEM ; } sensor -> dev = dev ; sensor -> i2c_client = client ; sensor -> dvdd = devm_regulator_get ( dev , "dvdd" ) ; if ( IS_ERR ( sensor -> dvdd ) ) { return dev_err_probe ( dev , PTR_ERR ( sensor -> dvdd ) , "cannot get DVDD regulator\n" ) ; } sensor -> dovdd = devm_regulator_get ( dev , "dovdd" ) ; if ( IS_ERR ( sensor -> dovdd ) ) { return dev_err_probe ( dev , PTR_ERR ( sensor -> dovdd ) , "cannot get DOVDD regulator\n" ) ; } sensor -> avdd = devm_regulator_get ( dev , "avdd" ) ; if ( IS_ERR ( sensor -> avdd ) ) { return dev_err_probe ( dev , PTR_ERR ( sensor -> avdd ) , "cannot get AVDD (analog) regulator\n" ) ; } handle = fwnode_graph_get_next_endpoint ( dev_fwnode ( dev ) , NULL ) ; if ( ! handle ) { return - EPROBE_DEFER ; } sensor -> endpoint . bus_type = V4L2_MBUS_CSI2_DPHY ; ret = v4l2_fwnode_endpoint_alloc_parse ( handle , & sensor -> endpoint ) ; fwnode_handle_put ( handle ) ; if ( ret ) { dev_err ( dev , "failed to parse endpoint node\n" ) ; return ret ; } sensor -> powerdown = devm_gpiod_get_optional ( dev , "powerdown" , GPIOD_OUT_HIGH ) ; if ( IS_ERR ( sensor -> powerdown ) ) { ret = PTR_ERR ( sensor -> powerdown ) ; error_endpoint } sensor -> reset = devm_gpiod_get_optional ( dev , "reset" , GPIOD_OUT_HIGH ) ; if ( IS_ERR ( sensor -> reset ) ) { ret = PTR_ERR ( sensor -> reset ) ; error_endpoint } sensor -> extclk = devm_clk_get ( dev , NULL ) ; if ( PTR_ERR ( sensor -> extclk ) == - ENOENT ) { dev_info ( dev , "no external clock found, continuing...\n" ) ; sensor -> extclk = NULL ; } if ( IS_ERR ( sensor -> extclk ) ) { dev_err ( dev , "failed to get external clock\n" ) ; ret = PTR_ERR ( sensor -> extclk , NULL ) ; error_endpoint } ret = fwnode_property_read_u32 ( dev_fwnode ( dev ) , "clock-frequency" , & rate ) ; if ( ! ret && sensor -> extclk ) { ret = clk_set_rate ( sensor -> extclk , rate ) ; if ( ret ) { dev_err_probe ( dev , ret , "failed to set clock rate\n" ) ; error_endpoint } } if ( ret && ! sensor -> extclk ) { dev_err_probe ( dev , ret , "invalid clock config\n" ) ; error_endpoint } sensor -> extclk_rate = rate ?rate : clk_get_rate ( sensor -> extclk ) ; for ( i = 0 ; i < ARRAY_SIZE ( supported_extclk_rates ) ; i ++ ) { if ( sensor -> extclk_rate == supported_extclk_rates [ i ] ) { break ; } } if ( i == ARRAY_SIZE ( supported_extclk_rates ) ) { dev_err ( dev , "clock rate %lu Hz is unsupported\n" , sensor -> extclk_rate ) ; ret = - EINVAL ; error_endpoint } sensor -> pll_configs = ov8865_pll_configs [ i ] ; subdev = & sensor -> subdev ; v4l2_i2c_subdev_init ( subdev , client , & ov8865_subdev_ops ) ; subdev -> flags |= V4L2_SUBDEV_FL_HAS_DEVNODE ; subdev -> entity . function = MEDIA_ENT_F_CAM_SENSOR ; pad = & sensor -> pad ; pad -> flags = MEDIA_PAD_FL_SOURCE ; ret = media_entity_pads_init ( & subdev -> entity , 1 , pad ) ; if ( ret ) { error_entity } mutex_init ( & sensor -> mutex ) ; ret = ov8865_ctrls_init ( sensor ) ; if ( ret ) { error_mutex } mutex_lock ( & sensor -> mutex ) ; ret = ov8865_state_init ( sensor ) ; mutex_unlock ( & sensor -> mutex ) ; if ( ret ) { error_ctrls } pm_runtime_set_suspended ( sensor -> dev ) ; pm_runtime_enable ( sensor -> dev ) ; ret = v4l2_async_register_subdev_sensor ( subdev ) ; if ( ret ) { error_pm } return 0 ; error_pm pm_runtime_disable ( sensor -> dev ) ; error_ctrls v4l2_ctrl_handler_free ( & sensor -> ctrls . handler ) ; error_mutex mutex_destroy ( & sensor -> mutex ) ; error_entity media_entity_cleanup ( & sensor -> subdev . entity ) ; error_endpoint v4l2_fwnode_endpoint_free ( & sensor -> endpoint ) ; return ret ; } 