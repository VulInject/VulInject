flatpak_builtin_uninstall ( , , , ) { g_autoptr ( ) context = NULL ; g_autoptr ( ) dirs = NULL ; char * * prefs = NULL ; int i , j , k , n_prefs ; const char * default_branch = NULL ; FlatpakKinds kinds ; g_autoptr ( ) uninstall_dirs = NULL ; context = g_option_context_new ( _ ( "[REFâ¦] - Uninstall applications or runtimes" ) ) ; g_option_context_set_translation_domain ( context , GETTEXT_PACKAGE ) ; if ( ! flatpak_option_context_parse ( context , options , & argc , & argv , FLATPAK_BUILTIN_FLAG_ALL_DIRS | FLATPAK_BUILTIN_FLAG_OPTIONAL_REPO , & dirs , cancellable , error ) ) { return FALSE ; } if ( argc < 2 && ! opt_all && ! opt_unused && ! opt_delete_data ) { return usage_error ( context , _ ( "Must specify at least one REF, --unused, --all or --delete-data" ) , error ) ; } if ( argc >= 2 && opt_all ) { return usage_error ( context , _ ( "Must not specify REFs when using --all" ) , error ) ; } if ( argc >= 2 && opt_unused ) { return usage_error ( context , _ ( "Must not specify REFs when using --unused" ) , error ) ; } if ( opt_noninteractive ) { opt_yes = TRUE ; } prefs = & argv [ 1 ] ; n_prefs = argc - 1 ; if ( argc == 3 && flatpak_is_valid_name ( argv [ 1 ] , - 1 , NULL ) && looks_like_branch ( argv [ 2 ] ) ) { default_branch = argv [ 2 ] ; n_prefs = 1 ; } kinds = flatpak_kinds_from_bools ( opt_app , opt_runtime ) ; uninstall_dirs = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , ( GDestroyNotify ) uninstall_dir_free ) ; if ( opt_all ) { for ( j = 0 ; j < dirs -> len ; j ++ ) { FlatpakDir * dir = g_ptr_array_index ( dirs , j ) ; UninstallDir * udir ; g_autoptr ( ) refs = NULL ; flatpak_dir_maybe_ensure_repo ( dir , NULL , NULL ) ; udir = uninstall_dir_ensure ( uninstall_dirs , dir ) ; refs = flatpak_dir_list_refs ( dir , FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME , cancellable , error ) ; if ( refs == NULL ) { return FALSE ; } for ( k = 0 ; k < refs -> len ; k ++ ) { FlatpakDecomposed * ref = g_ptr_array_index ( refs , k ) ; uninstall_dir_add_ref ( udir , ref ) ; } } } if ( opt_unused ) { gboolean found_something_to_uninstall = FALSE ; for ( j = 0 ; j < dirs -> len ; j ++ ) { FlatpakDir * dir = g_ptr_array_index ( dirs , j ) ; g_autoptr ( ) installation = NULL ; UninstallDir * udir ; g_auto ( ) unused = NULL ; g_autoptr ( ) pinned = NULL ; flatpak_dir_maybe_ensure_repo ( dir , NULL , NULL ) ; if ( flatpak_dir_get_repo ( dir ) == NULL ) { continue ; } installation = flatpak_installation_new_for_dir ( dir , NULL , NULL ) ; pinned = flatpak_installation_list_pinned_refs ( installation , opt_arch , cancellable , error ) ; if ( pinned == NULL ) { return FALSE ; } if ( pinned -> len > 0 ) { g_print ( _ ( "\nThese runtimes in installation '%s' are pinned and won't be removed; see flatpak-pin(1):\n" ) , flatpak_dir_get_name_cached ( dir ) ) ; for ( i = 0 ; i < pinned -> len ; i ++ ) { FlatpakInstalledRef * rref = g_ptr_array_index ( pinned , i ) ; const char * ref = flatpak_ref_format_ref_cached ( FLATPAK_REF ( rref ) ) ; g_print ( "  %s\n" , ref ) ; } } udir = uninstall_dir_ensure ( uninstall_dirs , dir ) ; unused = flatpak_dir_list_unused_refs ( dir , opt_arch , NULL , NULL , NULL , FALSE , cancellable , error ) ; if ( unused == NULL ) { return FALSE ; } for ( char * * iter = unused ; iter && * iter ; iter ++ ) { const char * ref = * iter ; g_autoptr ( ) d = flatpak_decomposed_new_from_ref ( ref , NULL ) ; if ( d ) { uninstall_dir_add_ref ( udir , d ) ; found_something_to_uninstall = TRUE ; } } if ( udir -> refs -> len > 0 ) { found_something_to_uninstall = TRUE ; } } if ( ! found_something_to_uninstall ) { g_print ( _ ( "Nothing unused to uninstall\n" ) ) ; return TRUE ; } } else { for ( j = 0 ; j < n_prefs ; j ++ ) { const char * pref = NULL ; FlatpakKinds matched_kinds ; g_autofree char * match_id = NULL ; g_autofree char * match_arch = NULL ; g_autofree char * match_branch = NULL ; g_autoptr ( ) local_error = NULL ; g_autoptr ( ) ref_dir_pairs = NULL ; UninstallDir * udir = NULL ; gboolean found_exact_name_match = FALSE ; g_autoptr ( ) chosen_pairs = NULL ; FindMatchingRefsFlags matching_refs_flags ; pref = prefs [ j ] ; if ( ! flatpak_allow_fuzzy_matching ( pref ) ) { matching_refs_flags = FIND_MATCHING_REFS_FLAGS_NONE ; } else { matching_refs_flags = FIND_MATCHING_REFS_FLAGS_FUZZY ; } if ( matching_refs_flags & FIND_MATCHING_REFS_FLAGS_FUZZY ) { flatpak_split_partial_ref_arg_novalidate ( pref , kinds , opt_arch , default_branch , & matched_kinds , & match_id , & match_arch , & match_branch ) ; if ( match_branch != NULL && ! flatpak_is_valid_branch ( match_branch , - 1 , & local_error ) ) { return flatpak_fail_error ( error , FLATPAK_ERROR_INVALID_REF , _ ( "Invalid branch %s: %s" ) , match_branch , local_error -> message ) ; } } if ( ! flatpak_split_partial_ref_arg ( pref , kinds , opt_arch , default_branch , & matched_kinds , & match_id , & match_arch , & match_branch , error ) ) { return FALSE ; } ref_dir_pairs = g_ptr_array_new_with_free_func ( ( GDestroyNotify ) ref_dir_pair_free ) ; for ( k = 0 ; k < dirs -> len ; k ++ ) { FlatpakDir * dir = g_ptr_array_index ( dirs , k ) ; g_autoptr ( ) refs = NULL ; refs = flatpak_dir_find_installed_refs ( dir , match_id , match_branch , match_arch , kinds , matching_refs_flags , error ) ; if ( refs == NULL ) { return FALSE ; } if ( refs -> len == 0 ) { continue ; } for ( int m = 0 ; m < refs -> len ; m ++ ) { FlatpakDecomposed * ref = g_ptr_array_index ( refs , m ) ; RefDirPair * pair ; if ( match_id != NULL && flatpak_decomposed_is_id ( ref , match_id ) ) { found_exact_name_match = TRUE ; } pair = ref_dir_pair_new ( ref , dir ) ; g_ptr_array_add ( ref_dir_pairs , pair ) ; } } if ( ref_dir_pairs -> len == 0 ) { if ( n_prefs == 1 ) { g_autoptr ( ) err_str = g_string_new ( "" ) ; g_string_append_printf ( err_str , _ ( "No installed refs found for â%sâ" ) , match_id ) ; if ( match_arch ) { g_string_append_printf ( err_str , _ ( " with arch â%sâ" ) , match_arch ) ; } if ( match_branch ) { g_string_append_printf ( err_str , _ ( " with branch â%sâ" ) , match_branch ) ; } g_set_error_literal ( error , FLATPAK_ERROR , FLATPAK_ERROR_NOT_INSTALLED , err_str -> str ) ; return FALSE ; } g_printerr ( _ ( "Warning: %s is not installed\n" ) , pref ) ; continue ; } if ( found_exact_name_match ) { for ( i = ref_dir_pairs -> len ; i > 0 ; i -- ) { RefDirPair * pair = g_ptr_array_index ( ref_dir_pairs , i - 1 ) ; if ( match_id != NULL && ! flatpak_decomposed_is_id ( pair -> ref , match_id ) ) { g_ptr_array_remove_index ( ref_dir_pairs , i - 1 ) ; } } } chosen_pairs = g_ptr_array_new ( ) ; if ( ! flatpak_resolve_matching_installed_refs ( opt_yes , FALSE , ref_dir_pairs , match_id , chosen_pairs , error ) ) { return FALSE ; } for ( i = 0 ; i < chosen_pairs -> len ; i ++ ) { RefDirPair * pair = g_ptr_array_index ( chosen_pairs , i ) ; udir = uninstall_dir_ensure ( uninstall_dirs , pair -> dir ) ; uninstall_dir_add_ref ( udir , pair -> ref ) ; } } } if ( n_prefs > 0 && g_hash_table_size ( uninstall_dirs ) == 0 ) { g_set_error ( error , FLATPAK_ERROR , FLATPAK_ERROR_NOT_INSTALLED , _ ( "None of the specified refs are installed" ) ) ; return FALSE ; } GLNX_HASH_TABLE_FOREACH_V ( , , ) { g_autoptr ( ) transaction = NULL ; if ( opt_noninteractive ) { transaction = flatpak_quiet_transaction_new ( udir -> dir , error ) ; } else { transaction = flatpak_cli_transaction_new ( udir -> dir , opt_yes , TRUE , opt_arch != NULL , error ) ; } if ( transaction == NULL ) { return FALSE ; } flatpak_transaction_set_disable_prune ( transaction , opt_keep_ref ) ; flatpak_transaction_set_force_uninstall ( transaction , opt_force_remove ) ; flatpak_transaction_set_disable_related ( transaction , opt_no_related ) ; flatpak_transaction_set_no_pull ( transaction , TRUE ) ; for ( i = udir -> refs -> len ; i > 0 ; i -- ) { FlatpakDecomposed * ref = g_ptr_array_index ( udir -> refs , i - 1 ) ; if ( ! opt_force_remove && ! confirm_runtime_removal ( opt_yes , udir , ref ) ) { uninstall_dir_remove_ref ( udir , ref ) ; continue ; } if ( ! flatpak_transaction_add_uninstall ( transaction , flatpak_decomposed_get_ref ( ref ) , error ) ) { return FALSE ; } } g_clear_pointer ( & udir -> runtime_app_map , g_hash_table_unref ) ; g_clear_pointer ( & udir -> extension_app_map , g_hash_table_unref ) ; if ( ! flatpak_transaction_run ( transaction , cancellable , error ) ) { if ( g_error_matches ( * error , FLATPAK_ERROR , FLATPAK_ERROR_ABORTED ) ) { g_clear_error ( error ) ; } return FALSE ; } if ( opt_delete_data ) { for ( i = 0 ; i < udir -> refs -> len ; i ++ ) { FlatpakDecomposed * ref = g_ptr_array_index ( udir -> refs , i ) ; g_autofree char * id = flatpak_decomposed_dup_id ( ref ) ; if ( ! flatpak_delete_data ( opt_yes , id , error ) ) { return FALSE ; } } } } if ( opt_delete_data && argc < 2 ) { g_autoptr ( ) enumerator = NULL ; g_autofree char * path = g_build_filename ( g_get_home_dir ( ) , ".var" , "app" , NULL ) ; g_autoptr ( ) app_dir = g_file_new_for_path ( path ) ; enumerator = g_file_enumerate_children ( app_dir , G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE , G_FILE_QUERY_INFO_NONE , cancellable , error ) ; if ( ! enumerator ) { return FALSE ; } while ( TRUE ) { GFileInfo * info ; GFile * file ; g_autoptr ( ) ref = NULL ; if ( ! g_file_enumerator_iterate ( enumerator , & info , & file , cancellable , error ) ) { return FALSE ; } if ( info == NULL ) { break ; } if ( g_file_info_get_file_type ( info ) != G_FILE_TYPE_DIRECTORY ) { continue ; } ref = flatpak_find_current_ref ( g_file_info_get_name ( info ) , cancellable , NULL ) ; if ( ref ) { continue ; } if ( ! flatpak_delete_data ( opt_yes , g_file_info_get_name ( info ) , error ) ) { return FALSE ; } } } return TRUE ; } 