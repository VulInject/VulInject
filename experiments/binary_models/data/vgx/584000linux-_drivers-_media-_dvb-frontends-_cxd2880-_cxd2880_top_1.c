static int cxd2880_get_frontend_t2 ( struct dvb_frontend * fe , struct dtv_frontend_properties * c ) { int ret ; struct cxd2880_priv * priv = NULL ; struct cxd2880_dvbt2_l1pre l1pre ; enum cxd2880_dvbt2_plp_code_rate coderate ; enum cxd2880_dvbt2_plp_constell qam ; enum cxd2880_tnrdmd_spectrum_sense sense ; int snr = 0 ; int strength = 0 ; if ( ! fe || ! c ) { pr_err ( "invalid arg.\n" ) ; return - EINVAL ; } priv = fe -> demodulator_priv ; mutex_lock ( priv -> spi_mutex ) ; ret = cxd2880_tnrdmd_dvbt2_mon_l1_pre ( & priv -> tnrdmd , & l1pre ) ; mutex_unlock ( priv -> spi_mutex ) ; if ( ! ret ) { switch ( l1pre . fft_mode ) { case CXD2880_DVBT2_M2K : c -> transmission_mode = TRANSMISSION_MODE_2K ; break ; case CXD2880_DVBT2_M8K : c -> transmission_mode = TRANSMISSION_MODE_8K ; break ; case CXD2880_DVBT2_M4K : c -> transmission_mode = TRANSMISSION_MODE_4K ; break ; case CXD2880_DVBT2_M1K : c -> transmission_mode = TRANSMISSION_MODE_1K ; break ; case CXD2880_DVBT2_M16K : c -> transmission_mode = TRANSMISSION_MODE_16K ; break ; case CXD2880_DVBT2_M32K : c -> transmission_mode = TRANSMISSION_MODE_32K ; break ; default : c -> transmission_mode = TRANSMISSION_MODE_2K ; pr_debug ( "L1Pre fft_mode is invalid %d\n" , l1pre . fft_mode ) ; break ; } switch ( l1pre . gi ) { case CXD2880_DVBT2_G1_32 : c -> guard_interval = GUARD_INTERVAL_1_32 ; break ; case CXD2880_DVBT2_G1_16 : c -> guard_interval = GUARD_INTERVAL_1_16 ; break ; case CXD2880_DVBT2_G1_8 : c -> guard_interval = GUARD_INTERVAL_1_8 ; break ; case CXD2880_DVBT2_G1_4 : c -> guard_interval = GUARD_INTERVAL_1_4 ; break ; case CXD2880_DVBT2_G1_128 : c -> guard_interval = GUARD_INTERVAL_1_128 ; break ; case CXD2880_DVBT2_G19_128 : c -> guard_interval = GUARD_INTERVAL_19_128 ; break ; case CXD2880_DVBT2_G19_256 : c -> guard_interval = GUARD_INTERVAL_19_256 ; break ; default : c -> guard_interval = GUARD_INTERVAL_1_32 ; pr_debug ( "L1Pre guard interval is invalid %d\n" , l1pre . gi ) ; break ; } } else { c -> transmission_mode = TRANSMISSION_MODE_2K ; c -> guard_interval = GUARD_INTERVAL_1_32 ; pr_debug ( "L1Pre err %d\n" , ret ) ; } mutex_lock ( priv -> spi_mutex ) ; ret = cxd2880_tnrdmd_dvbt2_mon_code_rate ( & priv -> tnrdmd , CXD2880_DVBT2_PLP_DATA , & coderate ) ; mutex_unlock ( priv -> spi_mutex ) ; if ( ! ret ) { switch ( coderate ) { case CXD2880_DVBT2_R1_2 : c -> fec_inner = FEC_1_2 ; break ; case CXD2880_DVBT2_R3_5 : c -> fec_inner = FEC_3_5 ; break ; case CXD2880_DVBT2_R2_3 : c -> fec_inner = FEC_2_3 ; break ; case CXD2880_DVBT2_R3_4 : c -> fec_inner = FEC_3_4 ; break ; case CXD2880_DVBT2_R4_5 : c -> fec_inner = FEC_4_5 ; break ; case CXD2880_DVBT2_R5_6 : c -> fec_inner = FEC_5_6 ; break ; default : c -> fec_inner = FEC_NONE ; pr_debug ( "CodeRate is invalid %d\n" , coderate ) ; break ; } } else { c -> fec_inner = FEC_NONE ; pr_debug ( "CodeRate %d\n" , ret ) ; } mutex_lock ( priv -> spi_mutex ) ; ret = cxd2880_tnrdmd_dvbt2_mon_qam ( & priv -> tnrdmd , CXD2880_DVBT2_PLP_DATA , & qam ) ; mutex_unlock ( priv -> spi_mutex ) ; if ( ! ret ) { switch ( qam ) { case CXD2880_DVBT2_QPSK : c -> modulation = QPSK ; break ; case CXD2880_DVBT2_QAM16 : c -> modulation = QAM_16 ; break ; case CXD2880_DVBT2_QAM64 : c -> modulation = QAM_64 ; break ; case CXD2880_DVBT2_QAM256 : c -> modulation = QAM_256 ; break ; default : c -> modulation = QPSK ; pr_debug ( "QAM is invalid %d\n" , qam ) ; break ; } } else { c -> modulation = QPSK ; pr_debug ( "QAM %d\n" , ret ) ; } mutex_lock ( priv -> spi_mutex ) ; ret = cxd2880_tnrdmd_dvbt2_mon_spectrum_sense ( & priv -> tnrdmd , & sense ) ; mutex_unlock ( priv -> spi_mutex ) ; if ( ! ret ) { switch ( sense ) { case CXD2880_TNRDMD_SPECTRUM_NORMAL : c -> inversion = INVERSION_OFF ; break ; case CXD2880_TNRDMD_SPECTRUM_INV : c -> inversion = INVERSION_ON ; break ; default : c -> inversion = INVERSION_OFF ; pr_debug ( "spectrum sense is invalid %d\n" , sense ) ; break ; } } else { c -> inversion = INVERSION_OFF ; pr_debug ( "SpectrumSense %d\n" , ret ) ; } mutex_lock ( priv -> spi_mutex ) ; ret = cxd2880_tnrdmd_mon_rf_lvl ( & priv -> tnrdmd , & strength ) ; mutex_unlock ( priv -> spi_mutex ) ; if ( ! ret ) { c -> strength . len = 1 ; c -> strength . stat [ 0 ] . scale = FE_SCALE_DECIBEL ; c -> strength . stat [ 0 ] . svalue = strength ; } else { c -> strength . len = 1 ; c -> strength . stat [ 0 ] . scale = FE_SCALE_NOT_AVAILABLE ; pr_debug ( "mon_rf_lvl %d\n" , ret ) ; } ret = cxd2880_read_snr ( fe , & snr ) ; if ( ! ret ) { c -> cnr . len = 1 ; c -> cnr . stat [ 0 ] . scale = FE_SCALE_DECIBEL ; c -> cnr . stat [ 0 ] . svalue = snr ; } else { c -> cnr . len = 1 ; c -> cnr . stat [ 0 ] . scale = FE_SCALE_NOT_AVAILABLE ; pr_debug ( "read_snr %d\n" , ret ) ; } return 0 ; } 