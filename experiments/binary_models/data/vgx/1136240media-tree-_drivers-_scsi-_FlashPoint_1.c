static int FlashPoint_ProbeHostAdapter ( struct sccb_mgr_info * pCardInfo ) { static unsigned char first_time = 1 ; unsigned char i , j , id , ScamFlg ; unsigned short temp , temp2 , temp3 , temp4 , temp5 , temp6 ; u32 ioport ; struct nvram_info * pCurrNvRam ; ioport = pCardInfo -> si_baseaddr ; if ( RD_HARPOON ( ioport + hp_vendor_id_0 ) != ORION_VEND_0 ) { return ( int ) FAILURE ; } if ( ( RD_HARPOON ( ioport + hp_vendor_id_1 ) != ORION_VEND_1 ) ) { return ( int ) FAILURE ; } if ( ( RD_HARPOON ( ioport + hp_device_id_1 ) != ORION_DEV_1 ) ) { return ( int ) FAILURE ; } if ( RD_HARPOON ( ioport + hp_rev_num ) != 0x0f ) { if ( RD_HARPOON ( ioport + hp_sub_device_id_0 ) & 0x0f ) { return ( int ) FAILURE ; } } if ( first_time ) { FPT_SccbMgrTableInitAll ( ) ; first_time = 0 ; FPT_mbCards = 0 ; } if ( FPT_RdStack ( ioport , 0 ) != 0x00 ) { if ( FPT_ChkIfChipInitialized ( ioport ) == 0 ) { pCurrNvRam = NULL ; WR_HARPOON ( ioport + hp_semaphore , 0x00 ) ; FPT_XbowInit ( ioport , 0 ) ; FPT_DiagEEPROM ( ioport ) ; } else { if ( FPT_mbCards < MAX_MB_CARDS ) { pCurrNvRam = & FPT_nvRamInfo [ FPT_mbCards ] ; FPT_mbCards ++ ; pCurrNvRam -> niBaseAddr = ioport ; FPT_RNVRamData ( pCurrNvRam ) ; } else { return ( int ) FAILURE ; } } } else { pCurrNvRam = NULL ; } WR_HARPOON ( ioport + hp_clkctrl_0 , CLKCTRL_DEFAULT ) ; WR_HARPOON ( ioport + hp_sys_ctrl , 0x00 ) ; if ( pCurrNvRam ) { pCardInfo -> si_id = pCurrNvRam -> niAdapId ; } else { pCardInfo -> si_id = ( unsigned char ) ( FPT_utilEERead ( ioport , ( ADAPTER_SCSI_ID / 2 ) ) & ( unsigned char ) 0x0FF ) ; } pCardInfo -> si_lun = 0x00 ; pCardInfo -> si_fw_revision = ORION_FW_REV ; temp2 = 0x0000 ; temp3 = 0x0000 ; temp4 = 0x0000 ; temp5 = 0x0000 ; temp6 = 0x0000 ; for ( id = 0 ; id < ( 16 / 2 ) ; id ++ ) { if ( pCurrNvRam ) { temp = ( unsigned short ) pCurrNvRam -> niSyncTbl [ id ] ; temp = ( ( temp & 0x03 ) + ( ( temp << 4 ) & 0xc0 ) ) + ( ( ( temp << 4 ) & 0x0300 ) + ( ( temp << 8 ) & 0xc000 ) ) ; } else { temp = FPT_utilEERead ( ioport , ( unsigned short ) ( ( SYNC_RATE_TBL / 2 ) + id ) ) ; } for ( i = 0 ; i < 2 ; temp >>= 8 , i ++ ) { temp2 >>= 1 ; temp3 >>= 1 ; temp4 >>= 1 ; temp5 >>= 1 ; temp6 >>= 1 ; switch ( temp & 0x3 ) { case AUTO_RATE_20 : temp6 |= 0x8000 ; case AUTO_RATE_10 : temp5 |= 0x8000 ; case AUTO_RATE_05 : temp2 |= 0x8000 ; case AUTO_RATE_00 : break ; } if ( temp & DISC_ENABLE_BIT ) { temp3 |= 0x8000 ; } if ( temp & WIDE_NEGO_BIT ) { temp4 |= 0x8000 ; } } } pCardInfo -> si_per_targ_init_sync = temp2 ; pCardInfo -> si_per_targ_no_disc = temp3 ; pCardInfo -> si_per_targ_wide_nego = temp4 ; pCardInfo -> si_per_targ_fast_nego = temp5 ; pCardInfo -> si_per_targ_ultra_nego = temp6 ; if ( pCurrNvRam ) { i = pCurrNvRam -> niSysConf ; } else { i = ( unsigned char ) ( FPT_utilEERead ( ioport , ( SYSTEM_CONFIG / 2 ) ) ) ; } if ( pCurrNvRam ) { ScamFlg = pCurrNvRam -> niScamConf ; } else { ScamFlg = ( unsigned char ) FPT_utilEERead ( ioport , SCAM_CONFIG / 2 ) ; } pCardInfo -> si_flags = 0x0000 ; if ( i & 0x01 ) { pCardInfo -> si_flags |= SCSI_PARITY_ENA ; } if ( ! ( i & 0x02 ) ) { pCardInfo -> si_flags |= SOFT_RESET ; } if ( i & 0x10 ) { pCardInfo -> si_flags |= EXTENDED_TRANSLATION ; } if ( ScamFlg & SCAM_ENABLED ) { pCardInfo -> si_flags |= FLAG_SCAM_ENABLED ; } if ( ScamFlg & SCAM_LEVEL2 ) { pCardInfo -> si_flags |= FLAG_SCAM_LEVEL2 ; } j = ( RD_HARPOON ( ioport + hp_bm_ctrl ) & ~ SCSI_TERM_ENA_L ) ; if ( i & 0x04 ) { j |= SCSI_TERM_ENA_L ; } WR_HARPOON ( ioport + hp_bm_ctrl , j ) ; j = ( RD_HARPOON ( ioport + hp_ee_ctrl ) & ~ SCSI_TERM_ENA_H ) ; if ( i & 0x08 ) { j |= SCSI_TERM_ENA_H ; } WR_HARPOON ( ioport + hp_ee_ctrl , j ) ; if ( ! ( RD_HARPOON ( ioport + hp_page_ctrl ) & NARROW_SCSI_CARD ) ) { pCardInfo -> si_flags |= SUPPORT_16TAR_32LUN ; } pCardInfo -> si_card_family = HARPOON_FAMILY ; pCardInfo -> si_bustype = BUSTYPE_PCI ; if ( pCurrNvRam ) { pCardInfo -> si_card_model [ 0 ] = '9' ; switch ( pCurrNvRam -> niModel & 0x0f ) { case MODEL_LT : pCardInfo -> si_card_model [ 1 ] = '3' ; pCardInfo -> si_card_model [ 2 ] = '0' ; break ; case MODEL_LW : pCardInfo -> si_card_model [ 1 ] = '5' ; pCardInfo -> si_card_model [ 2 ] = '0' ; break ; case MODEL_DL : pCardInfo -> si_card_model [ 1 ] = '3' ; pCardInfo -> si_card_model [ 2 ] = '2' ; break ; case MODEL_DW : pCardInfo -> si_card_model [ 1 ] = '5' ; pCardInfo -> si_card_model [ 2 ] = '2' ; break ; } } else { temp = FPT_utilEERead ( ioport , ( MODEL_NUMB_0 / 2 ) ) ; pCardInfo -> si_card_model [ 0 ] = ( unsigned char ) ( temp >> 8 ) ; temp = FPT_utilEERead ( ioport , ( MODEL_NUMB_2 / 2 ) ) ; pCardInfo -> si_card_model [ 1 ] = ( unsigned char ) ( temp & 0x00FF ) ; pCardInfo -> si_card_model [ 2 ] = ( unsigned char ) ( temp >> 8 ) ; } if ( pCardInfo -> si_card_model [ 1 ] == '3' ) { if ( RD_HARPOON ( ioport + hp_ee_ctrl ) & BIT ( 7 ) ) { pCardInfo -> si_flags |= LOW_BYTE_TERM ; } } if ( pCardInfo -> si_card_model [ 2 ] == '0' ) { temp = RD_HARPOON ( ioport + hp_xfer_pad ) ; WR_HARPOON ( ioport + hp_xfer_pad , ( temp & ~ BIT ( 4 ) ) ) ; if ( RD_HARPOON ( ioport + hp_ee_ctrl ) & BIT ( 7 ) ) { pCardInfo -> si_flags |= LOW_BYTE_TERM ; } WR_HARPOON ( ioport + hp_xfer_pad , ( temp | BIT ( 4 ) ) ) ; if ( RD_HARPOON ( ioport + hp_ee_ctrl ) & BIT ( 7 ) ) { pCardInfo -> si_flags |= HIGH_BYTE_TERM ; } WR_HARPOON ( ioport + hp_xfer_pad , temp ) ; } else { temp = RD_HARPOON ( ioport + hp_ee_ctrl ) ; temp2 = RD_HARPOON ( ioport + hp_xfer_pad ) ; WR_HARPOON ( ioport + hp_ee_ctrl , ( temp | SEE_CS ) ) ; WR_HARPOON ( ioport + hp_xfer_pad , ( temp2 | BIT ( 4 ) ) ) ; temp3 = 0 ; for ( i = 0 ; i < 8 ; i ++ ) { temp3 <<= 1 ; if ( ! ( RD_HARPOON ( ioport + hp_ee_ctrl ) & BIT ( 7 ) ) ) { temp3 |= 1 ; } WR_HARPOON ( ioport + hp_xfer_pad , ( temp2 & ~ BIT ( 4 ) ) ) ; WR_HARPOON ( ioport + hp_xfer_pad , ( temp2 | BIT ( 4 ) ) ) ; } WR_HARPOON ( ioport + hp_ee_ctrl , temp ) ; WR_HARPOON ( ioport + hp_xfer_pad , temp2 ) ; if ( ! ( temp3 & BIT ( 7 ) ) ) { pCardInfo -> si_flags |= LOW_BYTE_TERM ; } if ( ! ( temp3 & BIT ( 6 ) ) ) { pCardInfo -> si_flags |= HIGH_BYTE_TERM ; } } ARAM_ACCESS ( ioport ) ; for ( i = 0 ; i < 4 ; i ++ ) { pCardInfo -> si_XlatInfo [ i ] = RD_HARPOON ( ioport + hp_aramBase + BIOS_DATA_OFFSET + i ) ; } pCardInfo -> si_relative_cardnum = ( unsigned char ) ( RD_HARPOON ( ioport + hp_aramBase + BIOS_RELATIVE_CARD ) - 1 ) ; SGRAM_ACCESS ( ioport ) ; FPT_s_PhaseTbl [ 0 ] = FPT_phaseDataOut ; FPT_s_PhaseTbl [ 1 ] = FPT_phaseDataIn ; FPT_s_PhaseTbl [ 2 ] = FPT_phaseIllegal ; FPT_s_PhaseTbl [ 3 ] = FPT_phaseIllegal ; FPT_s_PhaseTbl [ 4 ] = FPT_phaseCommand ; FPT_s_PhaseTbl [ 5 ] = FPT_phaseStatus ; FPT_s_PhaseTbl [ 6 ] = FPT_phaseMsgOut ; FPT_s_PhaseTbl [ 7 ] = FPT_phaseMsgIn ; pCardInfo -> si_present = 0x01 ; return 0 ; } 