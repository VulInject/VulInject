static void sfmmu_leave_scd ( sfmmu_t * sfmmup , uchar_t r_type ) { sf_scd_t * scdp = sfmmup -> sfmmu_scdp ; sf_srd_t * srdp = sfmmup -> sfmmu_srdp ; hatlock_t * hatlockp = TSB_HASH ( sfmmup ) ; int i ; ASSERT ( scdp != NULL ) ; ASSERT ( srdp != NULL ) ; if ( sfmmup -> sfmmu_free ) { mutex_enter ( & scdp -> scd_mutex ) ; sfmmu_from_scd_list ( & scdp -> scd_sf_list , sfmmup ) ; mutex_exit ( & scdp -> scd_mutex ) ; for ( i = 0 ; i < mmu_page_sizes ; i ++ ) { ASSERT ( sfmmup -> sfmmu_scdrttecnt [ i ] == scdp -> scd_rttecnt [ i ] ) ; atomic_add_long ( & sfmmup -> sfmmu_ttecnt [ i ] , sfmmup -> sfmmu_scdrttecnt [ i ] ) ; sfmmup -> sfmmu_scdrttecnt [ i ] = 0 ; } sfmmup -> sfmmu_scdp = NULL ; SF_SCD_DECR_REF ( srdp , scdp ) ; return ; } ASSERT ( r_type != SFMMU_REGION_ISM || SFMMU_FLAGS_ISSET ( sfmmup , HAT_ISMBUSY ) ) ; ASSERT ( scdp -> scd_refcnt ) ; ASSERT ( ! sfmmup -> sfmmu_free ) ; ASSERT ( sfmmu_hat_lock_held ( sfmmup ) ) ; ASSERT ( AS_LOCK_HELD ( sfmmup -> sfmmu_as ) ) ; if ( r_type != SFMMU_REGION_ISM ) { while ( SFMMU_FLAGS_ISSET ( sfmmup , HAT_ISMBUSY ) && sfmmup -> sfmmu_scdp != NULL ) { cv_wait ( & sfmmup -> sfmmu_tsb_cv , HATLOCK_MUTEXP ( hatlockp ) ) ; } if ( sfmmup -> sfmmu_scdp == NULL ) { sfmmu_hat_exit ( hatlockp , NULL ) ; return ; } SFMMU_FLAGS_SET ( sfmmup , HAT_ISMBUSY ) ; } if ( SFMMU_FLAGS_ISSET ( sfmmup , HAT_JOIN_SCD ) ) { SFMMU_FLAGS_CLEAR ( sfmmup , HAT_JOIN_SCD ) ; } else { sfmmu_invalidate_ctx ( sfmmup ) ; } ASSERT ( SFMMU_FLAGS_ISSET ( sfmmup , HAT_ISMBUSY ) ) ; sfmmu_ism_hatflags ( sfmmup , 0 ) ; for ( i = 0 ; i < mmu_page_sizes ; i ++ ) { ASSERT ( sfmmup -> sfmmu_scdrttecnt [ i ] == scdp -> scd_rttecnt [ i ] ) ; atomic_add_long ( & sfmmup -> sfmmu_ttecnt [ i ] , sfmmup -> sfmmu_scdrttecnt [ i ] ) ; sfmmup -> sfmmu_scdrttecnt [ i ] = 0 ; sfmmup -> sfmmu_ismttecnt [ i ] += sfmmup -> sfmmu_scdismttecnt [ i ] ; sfmmup -> sfmmu_scdismttecnt [ i ] = 0 ; } sfmmup -> sfmmu_tsb0_4minflcnt += scdp -> scd_sfmmup -> sfmmu_tsb0_4minflcnt ; if ( r_type != SFMMU_REGION_ISM ) { SFMMU_FLAGS_CLEAR ( sfmmup , HAT_ISMBUSY ) ; } sfmmup -> sfmmu_scdp = NULL ; sfmmu_hat_exit ( hatlockp ) ; mutex_enter ( & scdp -> scd_mutex ) ; sfmmu_from_scd_list ( & scdp -> scd_sf_list , sfmmup ) ; mutex_exit ( & scdp -> scd_mutex ) ; SFMMU_STAT ( sf_leave_scd ) ; SF_SCD_DECR_REF ( srdp , scdp ) ; hatlockp = sfmmu_hat_enter ( sfmmup ) ; } 