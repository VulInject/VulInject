static void rtl8187_rx_cb ( struct urb * urb ) { struct sk_buff * skb = ( sk_buff * ) urb -> context ; struct rtl8187_rx_info * info = ( rtl8187_rx_info * ) skb -> cb ; struct ieee80211_hw * dev = info -> dev ; struct rtl8187_priv * priv = dev -> priv ; struct ieee80211_rx_status rx_status = { 0 } ; int rate , signal ; u32 flags ; unsigned long f ; spin_lock_irqsave ( & priv -> rx_queue . lock , f ) ; __skb_unlink ( skb , & priv -> rx_queue ) ; spin_unlock_irqrestore ( & priv -> rx_queue . lock , f ) ; skb_put ( skb , urb -> actual_length ) ; if ( unlikely ( urb -> status ) ) { return ; } if ( ! priv -> is_rtl8187b ) { struct rtl8187_rx_hdr * hdr = ( typeof ( hdr ) ) ( skb_tail_pointer ( skb ) - sizeof ( * hdr ) ) ; flags = le32_to_cpu ( hdr -> flags ) ; signal = - 4 - ( ( 27 * hdr -> agc ) >> 6 ) ; rx_status . antenna = ( hdr -> signal >> 7 ) & 1 ; rx_status . mactime = le64_to_cpu ( hdr -> mac_time ) ; } else { struct rtl8187b_rx_hdr * hdr = ( typeof ( hdr ) ) ( skb_tail_pointer ( skb ) - sizeof ( * hdr ) ) ; flags = le32_to_cpu ( hdr -> flags ) ; signal = 14 - hdr -> agc / 2 ; rx_status . antenna = ( hdr -> rssi >> 7 ) & 1 ; rx_status . mactime = le64_to_cpu ( hdr -> mac_time ) ; } rx_status . signal = signal ; priv -> signal = signal ; rate = ( flags >> 20 ) & 0xF ; skb_trim ( skb , flags & 0x0FFF ) ; rx_status . rate_idx = rate ; rx_status . freq = dev -> conf . chandef . chan -> center_freq ; rx_status . band = dev -> conf . chandef . chan -> band ; rx_status . flag |= RX_FLAG_MACTIME_START ; if ( flags & RTL818X_RX_DESC_FLAG_SPLCP ) { rx_status . enc_flags |= RX_ENC_FLAG_SHORTPRE ; } if ( flags & RTL818X_RX_DESC_FLAG_CRC32_ERR ) { rx_status . flag |= RX_FLAG_FAILED_FCS_CRC ; } memcpy ( IEEE80211_SKB_RXCB ( skb ) , & rx_status , sizeof ( rx_status ) ) ; ieee80211_rx_irqsafe ( dev , skb ) ; skb = dev_alloc_skb ( RTL8187_MAX_RX ) ; if ( unlikely ( ! skb ) ) { return ; } info = ( rtl8187_rx_info * ) skb -> cb ; info -> urb = urb ; info -> dev = dev ; urb -> transfer_buffer = skb_tail_pointer ( skb ) ; urb -> context = skb ; skb_queue_tail ( & priv -> rx_queue , skb ) ; usb_anchor_urb ( urb , & priv -> anchored ) ; if ( usb_submit_urb ( urb , GFP_ATOMIC ) ) { usb_unanchor_urb ( urb ) ; skb_unlink ( skb , & priv -> rx_queue ) ; dev_kfree_skb_irq ( skb ) ; } } 