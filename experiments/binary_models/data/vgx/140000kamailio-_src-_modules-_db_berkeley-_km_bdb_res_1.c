int bdb_convert_row ( db1_res_t * _res , char * bdb_result , int * _lres ) { int col , len , i , j ; char * * row_buf , * s ; db_row_t * row = NULL ; col = len = i = j = 0 ; if ( ! _res ) { LM_ERR ( "invalid parameter\n" ) ; return - 1 ; } len = sizeof ( db_row_t ) ; row = ( db_row_t * ) pkg_malloc ( len ) ; if ( ! row ) { LM_ERR ( "no private memory left\n" ) ; return - 1 ; } LM_DBG ( "allocate %d bytes for row %p\n" , len , row ) ; memset ( row , 0 , len ) ; RES_ROWS ( _res ) = row ; RES_ROW_N ( _res ) = 1 ; if ( db_allocate_row ( _res , row ) != 0 ) { LM_ERR ( "could not allocate row" ) ; return - 2 ; } len = sizeof ( char * ) * RES_COL_N ( _res ) ; row_buf = ( char * * ) pkg_malloc ( len ) ; if ( ! row_buf ) { LM_ERR ( "no private memory left\n" ) ; return - 1 ; } LM_DBG ( "allocate for %d columns %d bytes in row buffer at %p\n" , RES_COL_N ( _res ) , len , row_buf ) ; s = strtok ( bdb_result , DELIM ) ; while ( s != NULL ) { if ( _lres ) { for ( i = 0 ; i < ROW_N ( row ) ; i ++ ) { if ( col == _lres [ i ] ) { len = strlen ( s ) ; row_buf [ i ] = pkg_malloc ( len + 1 ) ; if ( ! row_buf [ i ] ) { LM_ERR ( "no private memory left\n" ) ; return - 1 ; } LM_DBG ( "allocated %d bytes for row_buf[%d] at %p\n" , len , i , row_buf [ i ] ) ; memset ( row_buf [ i ] , 0 , len + 1 ) ; strncpy ( row_buf [ i ] , s , len ) ; } } } else { len = strlen ( s ) ; row_buf [ col ] = pkg_malloc ( len + 1 ) ; if ( ! row_buf [ col ] ) { LM_ERR ( "no private memory left\n" ) ; return - 1 ; } LM_DBG ( "allocated %d bytes for row_buf[%d] at %p\n" , len , col , row_buf [ col ] ) ; memset ( row_buf [ col ] , 0 , len + 1 ) ; strncpy ( row_buf [ col ] , s , len ) ; } s = strtok ( NULL , DELIM ) ; col ++ ; } for ( col = 0 ; col < ROW_N ( row ) ; col ++ ) { if ( ! row_buf [ col ] ) { continue ; } if ( bdb_str2val ( RES_TYPES ( _res ) [ col ] , & ( ROW_VALUES ( row ) [ col ] ) , row_buf [ col ] , strlen ( row_buf [ col ] ) ) < 0 ) { LM_ERR ( "while converting value\n" ) ; LM_DBG ( "freeing row at %p\n" , row ) ; db_free_row ( row ) ; return - 3 ; } } for ( col = 0 ; col < RES_COL_N ( _res ) ; col ++ ) { switch ( RES_TYPES ( _res ) [ col ] ) { case DB1_STRING : case DB1_STR : break ; default : LM_DBG ( "col[%d] Col[%.*s]Type[%d] Freeing row_buf[%p]\n" , col , RES_NAMES ( _res ) [ col ] -> len , RES_NAMES ( _res ) [ col ] -> s , RES_TYPES ( _res ) [ col ] , row_buf [ col ] ) ; LM_DBG ( "freeing row_buf[%d] at %p\n" , col , row_buf [ col ] ) ; pkg_free ( row_buf [ col ] ) ; } row_buf [ col ] = ( char * ) NULL ; } LM_DBG ( "freeing row buffer at %p\n" , row_buf ) ; pkg_free ( row_buf ) ; row_buf = NULL ; return 0 ; } 