static int zap_shader_load_mdt ( struct msm_gpu * gpu , const char * fwname , u32 pasid ) { struct device * dev = & gpu -> pdev -> dev ; const struct firmware * fw ; const char * signed_fwname = NULL ; struct device_node * np , * mem_np ; struct resource r ; phys_addr_t mem_phys ; ssize_t mem_size ; void * mem_region = NULL ; int ret ; if ( ! IS_ENABLED ( CONFIG_ARCH_QCOM ) ) { zap_available = false ; return - EINVAL ; } np = of_get_child_by_name ( dev -> of_node , "zap-shader" ) ; if ( ! np ) { zap_available = false ; return - ENODEV ; } mem_np = of_parse_phandle ( np , "memory-region" , 0 ) ; of_node_put ( np ) ; if ( ! mem_np ) { zap_available = false ; return - EINVAL ; } ret = of_address_to_resource ( mem_np , 0 , & r ) ; of_node_put ( mem_np ) ; if ( ret ) { return ret ; } mem_phys = r . start ; of_property_read_string_index ( np , "firmware-name" , 0 , & signed_fwname ) ; if ( signed_fwname ) { fwname = signed_fwname ; ret = request_firmware_direct ( & fw , fwname , gpu -> dev -> dev ) ; if ( ret ) { fw = ERR_PTR ( ret ) ; } } if ( fwname ) { fw = adreno_request_fw ( to_adreno_gpu ( gpu ) , fwname ) ; } else { return - ENODEV ; } if ( IS_ERR ( fw ) ) { DRM_DEV_ERROR ( dev , "Unable to load %s\n" , fwname ) ; return PTR_ERR ( fw ) ; } mem_size = qcom_mdt_get_size ( fw ) ; if ( mem_size < 0 ) { ret = mem_size ; out } if ( mem_size > resource_size ( & r ) ) { DRM_DEV_ERROR ( dev , "memory region is too small to load the MDT\n" ) ; ret = - E2BIG ; out } mem_region = memremap ( mem_phys , mem_size , MEMREMAP_WC ) ; if ( ! mem_region ) { ret = - ENOMEM ; out } if ( signed_fwname || ( to_adreno_gpu ( gpu ) -> fwloc == FW_LOCATION_LEGACY ) ) { ret = qcom_mdt_load ( dev , fw , fwname , pasid , mem_region , mem_phys , mem_size , NULL ) ; } else { char * newname ; newname = kasprintf ( GFP_KERNEL , "qcom/%s" , fwname ) ; ret = qcom_mdt_load ( dev , fw , newname , pasid , mem_region , mem_phys , mem_size , NULL ) ; } if ( ret ) { out } ret = qcom_scm_pas_auth_and_reset ( pasid ) ; if ( ret == - EOPNOTSUPP ) { zap_available = false ; } if ( ret ) { DRM_DEV_ERROR ( dev , "Unable to authorize the image\n" ) ; } out if ( mem_region ) { memunmap ( mem_region ) ; } release_firmware ( fw ) ; return ret ; } 