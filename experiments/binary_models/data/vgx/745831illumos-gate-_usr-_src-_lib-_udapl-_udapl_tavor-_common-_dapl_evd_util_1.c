DAT_RETURN dapls_evd_internal_create ( DAPL_IA * ia_ptr , DAPL_CNO * cno_ptr , DAT_COUNT min_qlen , DAT_EVD_FLAGS evd_flags , DAPL_EVD * * evd_ptr_ptr ) { DAPL_EVD * evd_ptr ; DAT_COUNT cq_len ; DAT_RETURN dat_status ; dat_status = DAT_SUCCESS ; * evd_ptr_ptr = NULL ; cq_len = min_qlen ; evd_ptr = dapls_evd_alloc ( ia_ptr , cno_ptr , evd_flags , min_qlen ) ; if ( ! evd_ptr ) { dat_status = DAT_ERROR ( DAT_INSUFFICIENT_RESOURCES , DAT_RESOURCE_MEMORY ) ; bail } evd_ptr -> evd_producer_locking_needed = ( ( evd_flags & ~ ( DAT_EVD_DTO_FLAG | DAT_EVD_RMR_BIND_FLAG ) ) != 0 ) ; evd_ptr -> evd_state = DAPL_EVD_STATE_OPEN ; dat_status = dapls_ib_cq_alloc ( ia_ptr , evd_ptr , cno_ptr , & cq_len ) ; dat_status = dapls_ib_setup_async_callback ( ia_ptr , DAPL_ASYNC_CQ_COMPLETION , ( unsigned int * ) evd_ptr -> ib_cq_handle , ( ib_async_handler_t ) dapl_evd_dto_callback , evd_ptr ) ; if ( dat_status != DAT_SUCCESS ) { bail } dat_status = dapli_evd_event_alloc ( evd_ptr , cno_ptr , cq_len ) ; if ( dat_status != DAT_SUCCESS ) { bail } dapl_os_assert ( dat_status == DAT_SUCCESS ) ; dapl_ia_link_evd ( ia_ptr , evd_ptr ) ; * evd_ptr_ptr = evd_ptr ; bail if ( dat_status != DAT_SUCCESS ) { if ( evd_ptr ) { ( void ) dapls_evd_dealloc ( evd_ptr ) ; } } return ( dat_status ) ; } 