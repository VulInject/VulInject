NCURSES_EXPORT ( ) _nc_timed_wait ( , , , ) { int fd ; int count ; int result = 0 ; TimeType t0 ; int timeout_is_event = 0 ; int n ; struct pollfd fd_list [ MIN_FDS ] ; struct pollfd * fds = fd_list ; fd_set set ; long starttime , returntime ; TR ( TRACE_IEVENT , ( "start twait: %d milliseconds, mode: %d" , milliseconds , mode ) ) ; if ( mode & 4 ) { int event_delay = _nc_eventlist_timeout ( evl ) ; if ( event_delay >= 0 && ( milliseconds >= event_delay || milliseconds < 0 ) ) { milliseconds = event_delay ; timeout_is_event = 1 ; } } retry starttime = _nc_gettime ( & t0 , TRUE ) ; count = 0 ; if ( ( mode & 4 ) && evl ) { evl -> result_flags = 0 ; } if ( ( mode & 4 ) && evl ) { fds = typeMalloc ( pollfd , MIN_FDS + evl -> count ) ; } if ( mode & 1 ) { fds [ count ] . fd = sp -> _ifd ; fds [ count ] . events = POLLIN ; count ++ ; } if ( ( mode & 2 ) && ( fd = sp -> _mouse_fd ) >= 0 ) { fds [ count ] . fd = fd ; fds [ count ] . events = POLLIN ; count ++ ; } if ( ( mode & 4 ) && evl ) { for ( n = 0 ; n < evl -> count ; ++ n ) { _nc_event * ev = evl -> events [ n ] ; if ( ev -> type == _NC_EVENT_FILE && ( ev -> data . fev . flags & _NC_EVENT_FILE_READABLE ) ) { fds [ count ] . fd = ev -> data . fev . fd ; fds [ count ] . events = POLLIN ; count ++ ; } } } result = poll ( fds , ( unsigned ) count , milliseconds ) ; if ( ( mode & 4 ) && evl ) { int c ; if ( ! result ) { count = 0 ; } for ( n = 0 ; n < evl -> count ; ++ n ) { _nc_event * ev = evl -> events [ n ] ; if ( ev -> type == _NC_EVENT_FILE && ( ev -> data . fev . flags & _NC_EVENT_FILE_READABLE ) ) { ev -> data . fev . result = 0 ; for ( c = 0 ; c < count ; c ++ ) { if ( fds [ c ] . fd == ev -> data . fev . fd && fds [ c ] . revents & POLLIN ) { ev -> data . fev . result |= _NC_EVENT_FILE_READABLE ; evl -> result_flags |= _NC_EVENT_FILE_READABLE ; } } } if ( ev -> type == _NC_EVENT_TIMEOUT_MSEC && ! result && timeout_is_event ) { evl -> result_flags |= _NC_EVENT_TIMEOUT_MSEC ; } } } if ( fds != fd_list ) { free ( ( char * ) fds ) ; } result = 0 ; if ( mode & 1 ) { int step = ( milliseconds < 0 ) ?0 : 5000 ; bigtime_t d ; bigtime_t useconds = milliseconds * 1000 ; int n , howmany ; if ( useconds <= 0 ) { useconds = 1 ; } for ( d = 0 ; d < useconds ; d += step ) { n = 0 ; howmany = ioctl ( 0 , 'ichr' , & n ) ; if ( howmany >= 0 && n > 0 ) { result = 1 ; break ; } if ( useconds > 1 && step > 0 ) { snooze ( step ) ; milliseconds -= ( step / 1000 ) ; if ( milliseconds <= 0 ) { milliseconds = 0 ; break ; } } } } if ( milliseconds > 0 ) { snooze ( milliseconds * 1000 ) ; milliseconds = 0 ; } FD_ZERO ( & set ) ; if ( mode & 1 ) { FD_SET ( sp -> _ifd , & set ) ; count = sp -> _ifd + 1 ; } if ( ( mode & 2 ) && ( fd = sp -> _mouse_fd ) >= 0 ) { FD_SET ( fd , & set ) ; count = max ( fd , count ) + 1 ; } if ( ( mode & 4 ) && evl ) { for ( n = 0 ; n < evl -> count ; ++ n ) { _nc_event * ev = evl -> events [ n ] ; if ( ev -> type == _NC_EVENT_FILE && ( ev -> data . fev . flags & _NC_EVENT_FILE_READABLE ) ) { FD_SET ( ev -> data . fev . fd , & set ) ; count = max ( ev -> data . fev . fd + 1 , count ) ; } } } if ( milliseconds >= 0 ) { struct timeval ntimeout ; ntimeout . tv_sec = milliseconds / 1000 ; ntimeout . tv_usec = ( milliseconds % 1000 ) * 1000 ; result = select ( count , & set , NULL , NULL , & ntimeout ) ; } else { result = select ( count , & set , NULL , NULL , NULL ) ; } if ( ( mode & 4 ) && evl ) { evl -> result_flags = 0 ; for ( n = 0 ; n < evl -> count ; ++ n ) { _nc_event * ev = evl -> events [ n ] ; if ( ev -> type == _NC_EVENT_FILE && ( ev -> data . fev . flags & _NC_EVENT_FILE_READABLE ) ) { ev -> data . fev . result = 0 ; if ( FD_ISSET ( ev -> data . fev . fd , & set ) ) { ev -> data . fev . result |= _NC_EVENT_FILE_READABLE ; evl -> result_flags |= _NC_EVENT_FILE_READABLE ; } } if ( ev -> type == _NC_EVENT_TIMEOUT_MSEC && ! result && timeout_is_event ) { evl -> result_flags |= _NC_EVENT_TIMEOUT_MSEC ; } } } returntime = _nc_gettime ( & t0 , FALSE ) ; if ( milliseconds >= 0 ) { milliseconds -= ( returntime - starttime ) ; } if ( evl ) { evl -> result_flags = 0 ; for ( n = 0 ; n < evl -> count ; ++ n ) { _nc_event * ev = evl -> events [ n ] ; if ( ev -> type == _NC_EVENT_TIMEOUT_MSEC ) { long diff = ( returntime - starttime ) ; if ( ev -> data . timeout_msec <= diff ) { ev -> data . timeout_msec = 0 ; } else { ev -> data . timeout_msec -= diff ; } } } } if ( result == 0 && milliseconds > 100 ) { napms ( 100 ) ; milliseconds -= 100 ; retry } if ( timeleft ) { * timeleft = milliseconds ; } TR ( TRACE_IEVENT , ( "end twait: returned %d (%d), remaining time %d msec" , result , errno , milliseconds ) ) ; if ( result != 0 ) { if ( result > 0 ) { result = 0 ; for ( count = 0 ; count < MIN_FDS ; count ++ ) { if ( ( mode & ( 1 << count ) ) && ( fds [ count ] . revents & POLLIN ) ) { result |= ( 1 << count ) ; } } result = 1 ; if ( ( mode & 2 ) && ( fd = sp -> _mouse_fd ) >= 0 && FD_ISSET ( fd , & set ) ) { result |= 2 ; } if ( ( mode & 1 ) && FD_ISSET ( sp -> _ifd , & set ) ) { result |= 1 ; } } else { result = 0 ; } } if ( ( mode & 4 ) && evl && evl -> result_flags ) { result |= 4 ; } return ( result ) ; } 