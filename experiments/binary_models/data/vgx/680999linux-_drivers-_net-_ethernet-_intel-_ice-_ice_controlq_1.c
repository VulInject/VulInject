int ice_clean_rq_elem ( struct ice_hw * hw , struct ice_ctl_q_info * cq , struct ice_rq_event_info * e , u16 * pending ) { u16 ntc = cq -> rq . next_to_clean ; enum ice_aq_err rq_last_status ; struct ice_aq_desc * desc ; struct ice_dma_mem * bi ; int ret_code = 0 ; u16 desc_idx ; u16 datalen ; u16 flags ; u16 ntu ; mutex_lock ( & cq -> rq_lock ) ; if ( ! cq -> rq . count ) { ice_debug ( hw , ICE_DBG_AQ_MSG , "Control Receive queue not initialized.\n" ) ; ret_code = - EIO ; clean_rq_elem_err } ntu = ( u16 ) ( rd32 ( hw , cq -> rq . head ) & cq -> rq . head_mask ) ; if ( ntu == ntc ) { ret_code = - EALREADY ; clean_rq_elem_out } desc = ICE_CTL_Q_DESC ( cq -> rq , ntc ) ; desc_idx = ntc ; rq_last_status = ( ice_aq_err ) le16_to_cpu ( desc -> retval ) ; flags = le16_to_cpu ( desc -> flags ) ; if ( flags & ICE_AQ_FLAG_ERR ) { ret_code = - EIO ; ice_debug ( hw , ICE_DBG_AQ_MSG , "Control Receive Queue Event 0x%04X received with error 0x%X\n" , le16_to_cpu ( desc -> opcode ) , rq_last_status ) ; } memcpy ( & e -> desc , desc , sizeof ( e -> desc ) ) ; datalen = le16_to_cpu ( desc -> datalen ) ; e -> msg_len = min_t ( u16 , datalen , e -> buf_len ) ; if ( e -> msg_buf && e -> msg_len ) { memcpy ( e -> msg_buf , cq -> rq . r . rq_bi [ desc_idx ] . va , e -> msg_len ) ; } ice_debug ( hw , ICE_DBG_AQ_DESC , "ARQ: desc and buffer:\n" ) ; ice_debug_cq ( hw , ( void * ) desc , e -> msg_buf , cq -> rq_buf_size ) ; bi = & cq -> rq . r . rq_bi [ ntc ] ; memset ( desc , 0 , sizeof ( * desc ) ) ; desc -> flags = cpu_to_le16 ( ICE_AQ_FLAG_BUF ) ; if ( cq -> rq_buf_size > ICE_AQ_LG_BUF ) { desc -> flags |= cpu_to_le16 ( ICE_AQ_FLAG_LB ) ; } desc -> datalen = cpu_to_le16 ( bi -> size ) ; desc -> params . generic . addr_high = cpu_to_le32 ( upper_32_bits ( bi -> pa ) ) ; desc -> params . generic . addr_low = cpu_to_le32 ( lower_32_bits ( bi -> pa ) ) ; wr32 ( hw , cq -> rq . tail , ntc ) ; ntc ++ ; if ( ntc == cq -> num_rq_entries ) { ntc = 0 ; } cq -> rq . next_to_clean = ntc ; cq -> rq . next_to_use = ntu ; clean_rq_elem_out if ( pending ) { ntu = ( u16 ) ( rd32 ( hw , cq -> rq . head ) & cq -> rq . head_mask ) ; * pending = ( u16 ) ( ( ntc > ntu ?cq -> rq . count : 0 ) + ( ntu - ntc ) ) ; } clean_rq_elem_err mutex_unlock ( & cq -> rq_lock ) ; return ret_code ; } 