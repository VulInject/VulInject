void vntsd_get_config ( vntsd_t * vntsdp ) { int i ; int num_cons ; vcc_console_t * consp ; vntsd_group_t * groupp ; num_cons = 0 ; if ( vntsd_vcc_ioctl ( VCC_NUM_CONSOLE , 0 , ( void * ) & num_cons ) != VNTSD_SUCCESS ) { vntsd_log ( VNTSD_ERR_VCC_IOCTL , "VCC_NUM_CONSOLE failed\n" ) ; return ; } D3 ( stderr , "get_config:num_cons=%d" , num_cons ) ; consp = malloc ( num_cons * sizeof ( vcc_console_t ) ) ; if ( consp == NULL ) { vntsd_log ( VNTSD_ERR_NO_MEM , "for console table." ) ; return ; } if ( vntsd_vcc_ioctl ( VCC_CONS_TBL , 0 , ( void * ) consp ) != VNTSD_SUCCESS ) { vntsd_log ( VNTSD_ERR_VCC_IOCTL , " VCC_CONS_TBL " "for console table\n" ) ; return ; } for ( i = 0 ; i < num_cons ; i ++ ) { if ( alloc_cons_with_group ( vntsdp , & consp [ i ] , & groupp ) != VNTSD_SUCCESS ) { vntsd_log ( VNTSD_ERR_ADD_CONS_FAILED , "get_config" ) ; } } ( void ) mutex_lock ( & vntsdp -> lock ) ; for ( ; ; ) { groupp = vntsd_que_walk ( vntsdp -> grouppq , ( el_func_t ) create_listen_thread ) ; if ( groupp == NULL ) { break ; } vntsd_log ( VNTSD_ERR_CREATE_LISTEN_THR , "get config()" ) ; } ( void ) mutex_unlock ( & vntsdp -> lock ) ; } 