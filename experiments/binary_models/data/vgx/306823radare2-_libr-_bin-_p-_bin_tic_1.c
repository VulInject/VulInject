static RList * sections ( RBinFile * bf ) { RList * ret = NULL ; RBuffer * buf = bf -> o -> bin_obj ; if ( ! ( ret = r_list_newf ( ( RListFree ) r_bin_section_free ) ) ) { return NULL ; } ut64 sz = r_buf_size ( buf ) ; if ( sz <= 0xff || sz > ( 10 * 1024 * 1024 ) ) { return false ; } ut64 off = 0 ; for ( ; off < sz ; ) { ut8 hb ; if ( r_buf_read_at ( buf , off , & hb , 1 ) != 1 ) { break ; } off ++ ; int bank_number = ( hb >> 5 ) & 7 ; int chunk_type = hb & 0x1f ; ut16 chunk_length = 0 ; if ( r_buf_read_at ( buf , off , ( ut8 * ) & chunk_length , 2 ) != 2 ) { return false ; } off += 3 ; ut64 vaddr = off ; switch ( chunk_type ) { case CHUNK_TILES : vaddr = 0x4000 ; break ; case CHUNK_SPRITES : vaddr = 0x6000 ; break ; case CHUNK_MAP : vaddr = 0x8000 ; break ; case CHUNK_FLAGS : vaddr = 0x14404 ; break ; case CHUNK_SAMPLES : vaddr = 0x100e4 ; break ; case CHUNK_WAVEFORM : vaddr = 0xffea ; break ; case CHUNK_PALETTE : vaddr = 0x3fc0 ; break ; case CHUNK_MUSIC : vaddr = 0x13e64 ; break ; case CHUNK_PATTERNS : vaddr = 0x11164 ; break ; case CHUNK_SCREEN : break ; } switch ( chunk_type ) { case CHUNK_TILES : case CHUNK_SPRITES : case CHUNK_COVER_DEP : case CHUNK_MAP : case CHUNK_CODE : case CHUNK_FLAGS : case CHUNK_SAMPLES : case CHUNK_WAVEFORM : case CHUNK_PALETTE : case CHUNK_PATTERNS_DEP : case CHUNK_MUSIC : case CHUNK_PATTERNS : case CHUNK_CODE_ZIP : case CHUNK_DEFAULT : case CHUNK_SCREEN : { char * n = r_str_newf ( "%s.%d" , chunk_name ( chunk_type ) , bank_number ) ; add_section ( ret , n , off , chunk_length , vaddr ) ; } R_LOG_DEBUG ( "BANK %d CHUNK %2d (%s) LENGTH %d" , bank_number , chunk_type , chunk_name ( chunk_type ) , chunk_length ) ; break ; default : R_LOG_ERROR ( "Invalid chunk at offset 0x%" PFMT64x , off ) ; return false ; } off += chunk_length ; } return ret ; } 