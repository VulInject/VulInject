ON ANY THEORY OF LIABILITY , WHETHER IN CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE . * / int_fast64_t f128M_to_i64 ( , , ) { return f128_to_i64 ( * aPtr , roundingMode , exact ) ; } ; ; int_fast64_t f128M_to_i64 ( const float128_t * aPtr , uint_fast8_t roundingMode , bool exact ) { const uint32_t * aWPtr ; uint32_t uiA96 ; int exp ; bool sign ; uint32_t sig96 ; int32_t shiftCount ; uint32_t sig [ 4 ] ; aWPtr = ( const uint32_t * ) aPtr ; uiA96 = aWPtr [ indexWordHi ( 4 ) ] ; exp = expF128UI96 ( uiA96 ) ; sign = signF128UI96 ( uiA96 ) ; sig96 = fracF128UI96 ( uiA96 ) ; shiftCount = 0x404F - exp ; if ( shiftCount < 17 ) { softfloat_raiseFlags ( softfloat_flag_invalid ) ; return ! sign || ( ( exp == 0x7FFF ) && ( sig96 || ( aWPtr [ indexWord ( 4 , 2 ) ] | aWPtr [ indexWord ( 4 , 1 ) ] | aWPtr [ indexWord ( 4 , 0 ) ] ) ) ) ?INT64_C ( 0x7FFFFFFFFFFFFFFF ) : - INT64_C ( 0x7FFFFFFFFFFFFFFF ) - 1 ; } if ( exp ) { sig96 |= 0x00010000 ; } sig [ indexWord ( 4 , 3 ) ] = sig96 ; sig [ indexWord ( 4 , 2 ) ] = aWPtr [ indexWord ( 4 , 2 ) ] ; sig [ indexWord ( 4 , 1 ) ] = aWPtr [ indexWord ( 4 , 1 ) ] ; sig [ indexWord ( 4 , 0 ) ] = aWPtr [ indexWord ( 4 , 0 ) ] ; softfloat_shiftRightJam128M ( sig , shiftCount , sig ) ; return softfloat_roundPackMToI64 ( sign , sig + indexMultiwordLo ( 4 , 3 ) , roundingMode , exact ) ; } 