static int efx_ef10_probe ( struct efx_nic * efx ) { struct efx_ef10_nic_data * nic_data ; int i , rc ; efx -> max_channels = min_t ( , , ) ; efx -> max_tx_channels = efx -> max_channels ; nic_data = kzalloc ( sizeof ( * nic_data ) , GFP_KERNEL ) ; if ( ! nic_data ) { return - ENOMEM ; } efx -> nic_data = nic_data ; BUILD_BUG_ON ( MCDI_CTL_SDU_LEN_MAX_V2 % 4 ) ; rc = efx_nic_alloc_buffer ( efx , & nic_data -> mcdi_buf , 8 + MCDI_CTL_SDU_LEN_MAX_V2 , GFP_KERNEL ) ; if ( rc ) { fail1 } i = 0 ; for ( ; ; ) { rc = efx_ef10_get_warm_boot_count ( efx ) ; if ( rc >= 0 ) { break ; } if ( ++ i == 5 ) { fail2 } ssleep ( 1 ) ; } nic_data -> warm_boot_count = rc ; nic_data -> rx_rss_context = EFX_EF10_RSS_CONTEXT_INVALID ; nic_data -> vport_id = EVB_PORT_ID_ASSIGNED ; _efx_writed ( efx , cpu_to_le32 ( 1 ) , ER_DZ_MC_DB_HWRD ) ; rc = efx_mcdi_init ( efx ) ; if ( rc ) { fail2 } mutex_init ( & nic_data -> udp_tunnels_lock ) ; rc = efx_mcdi_reset ( efx , RESET_TYPE_ALL ) ; if ( rc ) { fail3 } rc = efx_mcdi_log_ctrl ( efx , true , false , 0 ) ; if ( rc ) { fail3 } rc = device_create_file ( & efx -> pci_dev -> dev , & dev_attr_link_control_flag ) ; if ( rc ) { fail3 } rc = device_create_file ( & efx -> pci_dev -> dev , & dev_attr_primary_flag ) ; if ( rc ) { fail4 } rc = efx_ef10_get_pf_index ( efx ) ; if ( rc ) { fail5 } rc = efx_ef10_init_datapath_caps ( efx ) ; if ( rc < 0 ) { fail5 } efx -> rx_packet_len_offset = ES_DZ_RX_PREFIX_PKTLEN_OFST - ES_DZ_RX_PREFIX_SIZE ; rc = efx_mcdi_port_get_number ( efx ) ; if ( rc < 0 ) { fail5 } efx -> port_num = rc ; rc = efx -> type -> get_mac_address ( efx , efx -> net_dev -> perm_addr ) ; if ( rc ) { fail5 } rc = efx_ef10_get_timer_config ( efx ) ; if ( rc < 0 ) { fail5 } rc = efx_mcdi_mon_probe ( efx ) ; if ( rc && rc != - EPERM ) { fail5 } efx_ptp_probe ( efx , NULL ) ; if ( ( efx -> pci_dev -> physfn ) && ( ! efx -> pci_dev -> is_physfn ) ) { struct pci_dev * pci_dev_pf = efx -> pci_dev -> physfn ; struct efx_nic * efx_pf = pci_get_drvdata ( pci_dev_pf ) ; efx_pf -> type -> get_mac_address ( efx_pf , nic_data -> port_id ) ; } else { ether_addr_copy ( nic_data -> port_id , efx -> net_dev -> perm_addr ) ; } INIT_LIST_HEAD ( & nic_data -> vlan_list ) ; mutex_init ( & nic_data -> vlan_lock ) ; rc = efx_ef10_add_vlan ( efx , EFX_FILTER_VID_UNSPEC ) ; if ( rc ) { fail_add_vid_unspec } rc = efx_ef10_add_vlan ( efx , 0 ) ; if ( rc ) { fail_add_vid_0 } return 0 ; fail_add_vid_0 efx_ef10_cleanup_vlans ( efx ) ; fail_add_vid_unspec mutex_destroy ( & nic_data -> vlan_lock ) ; efx_ptp_remove ( efx ) ; efx_mcdi_mon_remove ( efx ) ; fail5 device_remove_file ( & efx -> pci_dev -> dev , & dev_attr_primary_flag ) ; fail4 device_remove_file ( & efx -> pci_dev -> dev , & dev_attr_link_control_flag ) ; fail3 efx_mcdi_detach ( efx ) ; mutex_lock ( & nic_data -> udp_tunnels_lock ) ; memset ( nic_data -> udp_tunnels , 0 , sizeof ( nic_data -> udp_tunnels ) ) ; ( void ) efx_ef10_set_udp_tnl_ports ( efx , true ) ; mutex_unlock ( & nic_data -> udp_tunnels_lock ) ; mutex_destroy ( & nic_data -> udp_tunnels_lock ) ; efx_mcdi_fini ( efx ) ; fail2 efx_nic_free_buffer ( efx , & nic_data -> mcdi_buf ) ; fail1 kfree ( nic_data ) ; efx -> nic_data = NULL ; return rc ; } 