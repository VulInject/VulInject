static void cm_destroy_id ( struct ib_cm_id * cm_id , int err ) { struct cm_id_private * cm_id_priv ; struct cm_work * work ; cm_id_priv = container_of ( cm_id , cm_id_private , id ) ; spin_lock_irq ( & cm_id_priv -> lock ) ; retest switch ( cm_id -> state ) { case IB_CM_LISTEN : spin_lock ( & cm . lock ) ; if ( -- cm_id_priv -> listen_sharecount > 0 ) { WARN_ON ( refcount_read ( & cm_id_priv -> refcount ) == 1 ) ; spin_unlock ( & cm . lock ) ; spin_unlock_irq ( & cm_id_priv -> lock ) ; cm_deref_id ( cm_id_priv ) ; return ; } cm_id -> state = IB_CM_IDLE ; rb_erase ( & cm_id_priv -> service_node , & cm . listen_service_table ) ; RB_CLEAR_NODE ( & cm_id_priv -> service_node ) ; spin_unlock ( & cm . lock ) ; break ; case IB_CM_SIDR_REQ_SENT : cm_id -> state = IB_CM_IDLE ; ib_cancel_mad ( cm_id_priv -> msg ) ; break ; case IB_CM_SIDR_REQ_RCVD : cm_send_sidr_rep_locked ( cm_id_priv , & ( ib_cm_sidr_rep_param ) { . status = IB_SIDR_REJECT } ) ; cm_id -> state = IB_CM_IDLE ; break ; case IB_CM_REQ_SENT : case IB_CM_MRA_REQ_RCVD : ib_cancel_mad ( cm_id_priv -> msg ) ; cm_send_rej_locked ( cm_id_priv , IB_CM_REJ_TIMEOUT , & cm_id_priv -> id . device -> node_guid , sizeof ( cm_id_priv -> id . device -> node_guid ) , NULL , 0 ) ; break ; case IB_CM_REQ_RCVD : if ( err == - ENOMEM ) { cm_reset_to_idle ( cm_id_priv ) ; } else { cm_send_rej_locked ( cm_id_priv , IB_CM_REJ_CONSUMER_DEFINED , NULL , 0 , NULL , 0 ) ; } break ; case IB_CM_REP_SENT : case IB_CM_MRA_REP_RCVD : ib_cancel_mad ( cm_id_priv -> msg ) ; cm_send_rej_locked ( cm_id_priv , IB_CM_REJ_CONSUMER_DEFINED , NULL , 0 , NULL , 0 ) ; retest case IB_CM_MRA_REQ_SENT : case IB_CM_REP_RCVD : case IB_CM_MRA_REP_SENT : cm_send_rej_locked ( cm_id_priv , IB_CM_REJ_CONSUMER_DEFINED , NULL , 0 , NULL , 0 ) ; break ; case IB_CM_ESTABLISHED : if ( cm_id_priv -> qp_type == IB_QPT_XRC_TGT ) { cm_id -> state = IB_CM_IDLE ; break ; } cm_send_dreq_locked ( cm_id_priv , NULL , 0 ) ; retest case IB_CM_DREQ_SENT : ib_cancel_mad ( cm_id_priv -> msg ) ; cm_enter_timewait ( cm_id_priv ) ; retest case IB_CM_DREQ_RCVD : cm_send_drep_locked ( cm_id_priv , NULL , 0 ) ; WARN_ON ( cm_id -> state != IB_CM_TIMEWAIT ) ; retest case IB_CM_TIMEWAIT : cm_id -> state = IB_CM_IDLE ; break ; case IB_CM_IDLE : break ; } WARN_ON ( cm_id -> state != IB_CM_IDLE ) ; spin_lock ( & cm . lock ) ; if ( cm_id_priv -> timewait_info ) { cm_remove_remote ( cm_id_priv ) ; cm_id_priv -> timewait_info = NULL ; } WARN_ON ( cm_id_priv -> listen_sharecount ) ; WARN_ON ( ! RB_EMPTY_NODE ( & cm_id_priv -> service_node ) ) ; if ( ! RB_EMPTY_NODE ( & cm_id_priv -> sidr_id_node ) ) { rb_erase ( & cm_id_priv -> sidr_id_node , & cm . remote_sidr_table ) ; } spin_unlock ( & cm . lock ) ; spin_unlock_irq ( & cm_id_priv -> lock ) ; xa_erase ( & cm . local_id_table , cm_local_id ( cm_id -> local_id ) ) ; cm_deref_id ( cm_id_priv ) ; wait_for_completion ( & cm_id_priv -> comp ) ; while ( ( work = cm_dequeue_work ( cm_id_priv ) ) != NULL ) { cm_free_work ( work ) ; } cm_destroy_av ( & cm_id_priv -> av ) ; cm_destroy_av ( & cm_id_priv -> alt_av ) ; kfree ( cm_id_priv -> private_data ) ; kfree_rcu ( cm_id_priv , rcu ) ; } 