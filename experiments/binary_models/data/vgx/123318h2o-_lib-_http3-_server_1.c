static void handle_buffered_input ( struct st_h2o_http3_server_stream_t * stream , int in_generator ) { struct st_h2o_http3_server_conn_t * conn = get_conn ( stream ) ; { size_t bytes_available = quicly_recvstate_bytes_available ( & stream -> quic -> recvstate ) ; assert ( bytes_available <= stream -> recvbuf . buf -> size ) ; if ( bytes_available != 0 ) { const uint8_t * src = ( const uint8_t * ) stream -> recvbuf . buf -> bytes , * src_end = src + bytes_available ; { int err ; const char * err_desc = NULL ; if ( ( err = stream -> recvbuf . handle_input ( stream , & src , src_end , in_generator , & err_desc ) ) != 0 ) { if ( err == H2O_HTTP3_ERROR_INCOMPLETE ) { if ( ! quicly_recvstate_transfer_complete ( & stream -> quic -> recvstate ) ) { break ; } err = H2O_HTTP3_ERROR_GENERAL_PROTOCOL ; err_desc = "incomplete frame" ; } h2o_quic_close_connection ( & conn -> h3 . super , err , err_desc ) ; return ; } if ( stream -> state >= H2O_HTTP3_SERVER_STREAM_STATE_CLOSE_WAIT ) { return ; } } src != src_end ; size_t bytes_consumed = src - ( const uint8_t * ) stream -> recvbuf . buf -> bytes ; h2o_buffer_consume ( & stream -> recvbuf . buf , bytes_consumed ) ; quicly_stream_sync_recvbuf ( stream -> quic , bytes_consumed ) ; } } if ( quicly_recvstate_transfer_complete ( & stream -> quic -> recvstate ) ) { if ( stream -> recvbuf . buf -> size == 0 && ( stream -> recvbuf . handle_input == handle_input_expect_data || stream -> recvbuf . handle_input == handle_input_post_trailers ) ) { if ( stream -> req . content_length != SIZE_MAX && stream -> req . content_length != stream -> req . req_body_bytes_received ) { shutdown_stream ( stream , H2O_HTTP3_ERROR_NONE , stream -> req . req_body_bytes_received < stream -> req . content_length ?H2O_HTTP3_ERROR_REQUEST_INCOMPLETE : H2O_HTTP3_ERROR_GENERAL_PROTOCOL , in_generator ) ; } else { if ( stream -> req . write_req . cb != NULL ) { if ( ! h2o_linklist_is_linked ( & stream -> link ) ) { h2o_linklist_insert ( & conn -> delayed_streams . req_streaming , & stream -> link ) ; } request_run_delayed ( conn ) ; } if ( ! stream -> req . process_called && stream -> state < H2O_HTTP3_SERVER_STREAM_STATE_SEND_HEADERS ) { switch ( stream -> state ) { case H2O_HTTP3_SERVER_STREAM_STATE_RECV_HEADERS : case H2O_HTTP3_SERVER_STREAM_STATE_RECV_BODY_BEFORE_BLOCK : case H2O_HTTP3_SERVER_STREAM_STATE_RECV_BODY_UNBLOCKED : break ; default : assert ( ! "unexpected state" ) ; break ; } set_state ( stream , H2O_HTTP3_SERVER_STREAM_STATE_REQ_PENDING , in_generator ) ; h2o_linklist_insert ( & conn -> delayed_streams . pending , & stream -> link ) ; request_run_delayed ( conn ) ; } } } else { shutdown_stream ( stream , H2O_HTTP3_ERROR_NONE , H2O_HTTP3_ERROR_REQUEST_INCOMPLETE , in_generator ) ; } } else { if ( stream -> state == H2O_HTTP3_SERVER_STREAM_STATE_RECV_BODY_BEFORE_BLOCK && stream -> req_body != NULL && stream -> req_body -> size >= H2O_HTTP3_REQUEST_BODY_MIN_BYTES_TO_BLOCK ) { stream -> read_blocked = 1 ; h2o_linklist_insert ( & conn -> delayed_streams . recv_body_blocked , & stream -> link ) ; set_state ( stream , H2O_HTTP3_SERVER_STREAM_STATE_RECV_BODY_BLOCKED , in_generator ) ; check_run_blocked ( conn ) ; } if ( stream -> req . write_req . cb != NULL && stream -> req_body -> size != 0 ) { if ( ! h2o_linklist_is_linked ( & stream -> link ) ) { h2o_linklist_insert ( & conn -> delayed_streams . req_streaming , & stream -> link ) ; } request_run_delayed ( conn ) ; } } } 