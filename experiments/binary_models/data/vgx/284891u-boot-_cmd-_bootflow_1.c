static int do_bootflow_scan ( struct cmd_tbl * cmdtp , int flag , int argc , char * const argv [ ] ) { struct bootstd_priv * std ; struct bootflow_iter iter ; struct udevice * dev = NULL ; struct bootflow bflow ; bool all = false , boot = false , errors = false , no_global = false ; bool list = false , no_hunter = false ; int num_valid = 0 ; const char * label = NULL ; bool has_args ; int ret , i ; int flags ; ret = bootstd_get_priv ( & std ) ; has_args = argc > 1 && * argv [ 1 ] == '-' ; if ( IS_ENABLED ( CONFIG_CMD_BOOTFLOW_FULL ) ) { if ( has_args ) { all = strchr ( argv [ 1 ] , 'a' ) ; boot = strchr ( argv [ 1 ] , 'b' ) ; errors = strchr ( argv [ 1 ] , 'e' ) ; no_global = strchr ( argv [ 1 ] , 'G' ) ; list = strchr ( argv [ 1 ] , 'l' ) ; no_hunter = strchr ( argv [ 1 ] , 'H' ) ; argc -- ; argv ++ ; } if ( argc > 1 ) { label = argv [ 1 ] ; } if ( ! label ) { dev = std -> cur_bootdev ; } } else { if ( has_args ) { printf ( "Flags not supported: enable CONFIG_BOOTFLOW_FULL\n" ) ; return CMD_RET_USAGE ; } boot = true ; } std -> cur_bootflow = NULL ; flags = 0 ; if ( list ) { flags |= BOOTFLOWF_SHOW ; } if ( all ) { flags |= BOOTFLOWF_ALL ; } if ( no_global ) { flags |= BOOTFLOWF_SKIP_GLOBAL ; } if ( ! no_hunter ) { flags |= BOOTFLOWF_HUNT ; } if ( list ) { printf ( "Scanning for bootflows " ) ; if ( dev ) { printf ( "in bootdev '%s'\n" , dev -> name ) ; } if ( label ) { printf ( "with label '%s'\n" , label ) ; } else { printf ( "in all bootdevs\n" ) ; } show_header ( ) ; } if ( dev ) { bootdev_clear_bootflows ( dev ) ; } else { bootstd_clear_glob ( ) ; } for ( i = 0 , ret = bootflow_scan_first ( dev , label , & iter , flags , & bflow ) ; i < 1000 && ret != - ENODEV ; i ++ , ret = bootflow_scan_next ( & iter , & bflow ) ) { bflow . err = ret ; if ( ! ret ) { num_valid ++ ; } ret = bootdev_add_bootflow ( & bflow ) ; if ( ret ) { printf ( "Out of memory\n" ) ; return CMD_RET_FAILURE ; } if ( list ) { show_bootflow ( i , & bflow , errors ) ; } if ( boot && ! bflow . err ) { bootflow_run_boot ( & iter , & bflow ) ; } } bootflow_iter_uninit ( & iter ) ; if ( list ) { show_footer ( i , num_valid ) ; } return 0 ; } 