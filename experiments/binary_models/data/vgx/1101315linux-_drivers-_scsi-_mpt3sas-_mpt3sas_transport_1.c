void mpt3sas_transport_port_remove ( struct MPT3SAS_ADAPTER * ioc , u64 sas_address , u64 sas_address_parent , struct hba_port * port ) { int i ; unsigned long flags ; struct _sas_port * mpt3sas_port , * next ; struct _sas_node * sas_node ; u8 found = 0 ; struct _sas_phy * mpt3sas_phy , * next_phy ; struct hba_port * hba_port_next , * hba_port = NULL ; struct virtual_phy * vphy , * vphy_next = NULL ; spin_lock_irqsave ( & ioc -> sas_node_lock , flags ) ; sas_node = _transport_sas_node_find_by_sas_address ( ioc , sas_address_parent , port ) ; if ( ! sas_node ) { spin_unlock_irqrestore ( & ioc -> sas_node_lock , flags ) ; return ; } list_for_each_entry_safe ( , , , ) { if ( mpt3sas_port -> remote_identify . sas_address != sas_address ) { continue ; } if ( mpt3sas_port -> hba_port != port ) { continue ; } found = 1 ; list_del ( & mpt3sas_port -> port_list ) ; out } out if ( ! found ) { spin_unlock_irqrestore ( & ioc -> sas_node_lock , flags ) ; return ; } if ( sas_node -> handle <= ioc -> sas_hba . num_phys && ( ioc -> multipath_on_hba ) ) { if ( port -> vphys_mask ) { list_for_each_entry_safe ( , , , ) { if ( vphy -> sas_address != sas_address ) { continue ; } ioc_info ( ioc , "remove vphy entry: %p of port:%p,from %d port's vphys list\n" , vphy , port , port -> port_id ) ; port -> vphys_mask &= ~ vphy -> phy_mask ; list_del ( & vphy -> list ) ; kfree ( vphy ) ; } } list_for_each_entry_safe ( , , , ) { if ( hba_port != port ) { continue ; } if ( ( hba_port -> sas_address == sas_address || ! hba_port -> sas_address ) && ! hba_port -> vphys_mask ) { ioc_info ( ioc , "remove hba_port entry: %p port: %d from hba_port list\n" , hba_port , hba_port -> port_id ) ; list_del ( & hba_port -> list ) ; kfree ( hba_port ) ; } if ( hba_port -> sas_address == sas_address && hba_port -> vphys_mask ) { ioc_info ( ioc , "clearing sas_address from hba_port entry: %p port: %d from hba_port list\n" , hba_port , hba_port -> port_id ) ; port -> sas_address = 0 ; } break ; } } for ( i = 0 ; i < sas_node -> num_phys ; i ++ ) { if ( sas_node -> phy [ i ] . remote_identify . sas_address == sas_address ) { memset ( & sas_node -> phy [ i ] . remote_identify , 0 , sizeof ( sas_identify ) ) ; } } spin_unlock_irqrestore ( & ioc -> sas_node_lock , flags ) ; list_for_each_entry_safe ( , , , ) { if ( ( ioc -> logging_level & MPT_DEBUG_TRANSPORT ) ) { dev_printk ( KERN_INFO , & mpt3sas_port -> port -> dev , "remove: sas_addr(0x%016llx), phy(%d)\n" , ( unsigned long long ) mpt3sas_port -> remote_identify . sas_address , mpt3sas_phy -> phy_id ) ; } mpt3sas_phy -> phy_belongs_to_port = 0 ; if ( ! ioc -> remove_host ) { sas_port_delete_phy ( mpt3sas_port -> port , mpt3sas_phy -> phy ) ; } list_del ( & mpt3sas_phy -> port_siblings ) ; } if ( ! ioc -> remove_host ) { sas_port_delete ( mpt3sas_port -> port ) ; } ioc_info ( ioc , "%s: removed: sas_addr(0x%016llx)\n" , __func__ , ( unsigned long long ) sas_address ) ; kfree ( mpt3sas_port ) ; } 