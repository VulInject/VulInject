int main ( int argc , char * * argv ) { struct jpeg_decompress_struct srcinfo ; struct jpeg_decompress_struct dropinfo ; struct jpeg_error_mgr jdroperr ; FILE * drop_file ; struct jpeg_compress_struct dstinfo ; struct jpeg_error_mgr jsrcerr , jdsterr ; struct cdjpeg_progress_mgr src_progress , dst_progress ; jvirt_barray_ptr * src_coef_arrays ; jvirt_barray_ptr * dst_coef_arrays ; int file_index ; FILE * fp ; FILE * icc_file ; JOCTET * icc_profile = NULL ; long icc_len = 0 ; progname = argv [ 0 ] ; if ( progname == NULL || progname [ 0 ] == 0 ) { progname = "jpegtran" ; } srcinfo . err = jpeg_std_error ( & jsrcerr ) ; jpeg_create_decompress ( & srcinfo ) ; dstinfo . err = jpeg_std_error ( & jdsterr ) ; jpeg_create_compress ( & dstinfo ) ; file_index = parse_switches ( & dstinfo , argc , argv , 0 , FALSE ) ; jsrcerr . trace_level = jdsterr . trace_level ; srcinfo . mem -> max_memory_to_use = dstinfo . mem -> max_memory_to_use ; if ( strict ) { jsrcerr . emit_message = my_emit_message ; } if ( outfilename == NULL ) { if ( file_index != argc - 2 ) { fprintf ( stderr , "%s: must name one input and one output file\n" , progname ) ; usage ( ) ; } outfilename = argv [ file_index + 1 ] ; } else { if ( file_index != argc - 1 ) { fprintf ( stderr , "%s: must name one input and one output file\n" , progname ) ; usage ( ) ; } } if ( file_index < argc - 1 ) { fprintf ( stderr , "%s: only one input file\n" , progname ) ; usage ( ) ; } if ( file_index < argc ) { if ( ( fp = fopen ( argv [ file_index ] , READ_BINARY ) ) == NULL ) { fprintf ( stderr , "%s: can't open %s for reading\n" , progname , argv [ file_index ] ) ; exit ( EXIT_FAILURE ) ; } } else { fp = read_stdin ( ) ; } if ( icc_filename != NULL ) { if ( ( icc_file = fopen ( icc_filename , READ_BINARY ) ) == NULL ) { fprintf ( stderr , "%s: can't open %s\n" , progname , icc_filename ) ; exit ( EXIT_FAILURE ) ; } if ( fseek ( icc_file , 0 , SEEK_END ) < 0 || ( icc_len = ftell ( icc_file ) ) < 1 || fseek ( icc_file , 0 , SEEK_SET ) < 0 ) { fprintf ( stderr , "%s: can't determine size of %s\n" , progname , icc_filename ) ; exit ( EXIT_FAILURE ) ; } if ( ( icc_profile = ( JOCTET * ) malloc ( icc_len ) ) == NULL ) { fprintf ( stderr , "%s: can't allocate memory for ICC profile\n" , progname ) ; fclose ( icc_file , NULL ) ; exit ( EXIT_FAILURE ) ; } if ( fread ( icc_profile , icc_len , 1 , icc_file ) < 1 ) { fprintf ( stderr , "%s: can't read ICC profile from %s\n" , progname , icc_filename ) ; free ( icc_profile ) ; fclose ( icc_file ) ; exit ( EXIT_FAILURE ) ; } fclose ( icc_file ) ; if ( copyoption == JCOPYOPT_ALL ) { copyoption = JCOPYOPT_ALL_EXCEPT_ICC ; } if ( copyoption == JCOPYOPT_ICC ) { copyoption = JCOPYOPT_NONE ; } } if ( report ) { start_progress_monitor ( ( j_common_ptr ) & dstinfo , & dst_progress ) ; dst_progress . report = report ; } if ( report || max_scans != 0 ) { start_progress_monitor ( ( j_common_ptr ) & srcinfo , & src_progress ) ; src_progress . report = report ; src_progress . max_scans = max_scans ; } if ( dropfilename != NULL ) { if ( ( drop_file = fopen ( dropfilename , READ_BINARY ) ) == NULL ) { fprintf ( stderr , "%s: can't open %s for reading\n" , progname , dropfilename ) ; exit ( EXIT_FAILURE ) ; } dropinfo . err = jpeg_std_error ( & jdroperr ) ; jpeg_create_decompress ( & dropinfo ) ; jpeg_stdio_src ( & dropinfo , drop_file ) ; } else { drop_file = NULL ; } jpeg_stdio_src ( & srcinfo , fp ) ; jcopy_markers_setup ( & srcinfo , copyoption ) ; ( void ) jpeg_read_header ( & srcinfo , TRUE ) ; if ( dropfilename != NULL ) { ( void ) jpeg_read_header ( & dropinfo , TRUE ) ; transformoption . crop_width = dropinfo . image_width ; transformoption . crop_width_set = JCROP_POS ; transformoption . crop_height = dropinfo . image_height ; transformoption . crop_height_set = JCROP_POS ; transformoption . drop_ptr = & dropinfo ; } if ( ! jtransform_request_workspace ( & srcinfo , & transformoption ) ) { fprintf ( stderr , "%s: transformation is not perfect\n" , progname ) ; exit ( EXIT_FAILURE ) ; } src_coef_arrays = jpeg_read_coefficients ( & srcinfo ) ; if ( dropfilename != NULL ) { transformoption . drop_coef_arrays = jpeg_read_coefficients ( & dropinfo ) ; } jpeg_copy_critical_parameters ( & srcinfo , & dstinfo ) ; dst_coef_arrays = jtransform_adjust_parameters ( & srcinfo , & dstinfo , src_coef_arrays , & transformoption ) ; dst_coef_arrays = src_coef_arrays ; if ( fp != stdin ) { fclose ( fp ) ; } if ( outfilename != NULL ) { if ( ( fp = fopen ( outfilename , WRITE_BINARY ) ) == NULL ) { fprintf ( stderr , "%s: can't open %s for writing\n" , progname , outfilename ) ; exit ( EXIT_FAILURE ) ; } } else { fp = write_stdout ( ) ; } file_index = parse_switches ( & dstinfo , argc , argv , 0 , TRUE ) ; jpeg_stdio_dest ( & dstinfo , fp ) ; jpeg_write_coefficients ( & dstinfo , dst_coef_arrays ) ; jcopy_markers_execute ( & srcinfo , & dstinfo , copyoption ) ; if ( icc_profile != NULL ) { jpeg_write_icc_profile ( & dstinfo , icc_profile , ( unsigned int ) icc_len ) ; } jtransform_execute_transformation ( & srcinfo , & dstinfo , src_coef_arrays , & transformoption ) ; jpeg_finish_compress ( & dstinfo ) ; jpeg_destroy_compress ( & dstinfo ) ; if ( dropfilename != NULL ) { ( void ) jpeg_finish_decompress ( & dropinfo ) ; jpeg_destroy_decompress ( & dropinfo ) ; } ( void ) jpeg_finish_decompress ( & srcinfo ) ; jpeg_destroy_decompress ( & srcinfo ) ; if ( fp != stdout ) { fclose ( fp ) ; } if ( drop_file != NULL ) { fclose ( drop_file ) ; } if ( report ) { end_progress_monitor ( ( j_common_ptr ) & dstinfo ) ; } if ( report || max_scans != 0 ) { end_progress_monitor ( ( j_common_ptr ) & srcinfo ) ; } free ( icc_profile ) ; if ( dropfilename != NULL ) { exit ( jsrcerr . num_warnings + jdroperr . num_warnings + jdsterr . num_warnings ?EXIT_WARNING : EXIT_SUCCESS ) ; } exit ( jsrcerr . num_warnings + jdsterr . num_warnings ?EXIT_WARNING : EXIT_SUCCESS ) ; return 0 ; } 