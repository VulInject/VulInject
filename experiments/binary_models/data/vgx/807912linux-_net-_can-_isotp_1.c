static int isotp_rcv_ff ( struct sock * sk , struct canfd_frame * cf , int ae ) { struct isotp_sock * so = isotp_sk ( sk ) ; int i ; int off ; int ff_pci_sz ; hrtimer_cancel ( & so -> rxtimer ) ; so -> rx . state = ISOTP_IDLE ; so -> rx . ll_dl = padlen ( cf -> len ) ; so -> rx . len = ( cf -> data [ ae ] & 0x0F ) << 8 ; so -> rx . len += cf -> data [ ae + 1 ] ; if ( so -> rx . len ) { ff_pci_sz = FF_PCI_SZ12 ; } else { so -> rx . len = cf -> data [ ae + 2 ] << 24 ; so -> rx . len += cf -> data [ ae + 3 ] << 16 ; so -> rx . len += cf -> data [ ae + 4 ] << 8 ; so -> rx . len += cf -> data [ ae + 5 ] ; ff_pci_sz = FF_PCI_SZ32 ; } off = ( so -> rx . ll_dl > CAN_MAX_DLEN ) ?1 : 0 ; if ( so -> rx . len + ae + off + ff_pci_sz < so -> rx . ll_dl ) { return 1 ; } if ( so -> rx . len > MAX_MSG_LENGTH ) { isotp_send_fc ( sk , ae , ISOTP_FC_OVFLW ) ; return 1 ; } so -> rx . idx = 0 ; for ( i = ae + ff_pci_sz ; i < so -> rx . ll_dl ; i ++ ) { so -> rx . buf [ so -> rx . idx ++ ] = cf -> data [ i ] ; } so -> rx . sn = 1 ; so -> rx . state = ISOTP_WAIT_DATA ; if ( so -> opt . flags & CAN_ISOTP_LISTEN_MODE ) { return 0 ; } isotp_send_fc ( sk , ae , ISOTP_FC_CTS ) ; return 0 ; } 