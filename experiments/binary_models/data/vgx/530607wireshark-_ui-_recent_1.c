static gboolean capture_remote_combo_add_recent ( const gchar * s ) { GList * vals = prefs_get_string_list ( s ) ; GList * valp = vals ; capture_auth auth_type ; char * p ; struct remote_host * rh ; if ( valp == NULL ) { return FALSE ; } if ( remote_host_list == NULL ) { remote_host_list = g_hash_table_new ( g_str_hash , g_str_equal ) ; } rh = ( remote_host * ) g_malloc ( sizeof ( * rh ) ) ; rh -> r_host = ( gchar * ) g_strdup ( ( const gchar * ) valp -> data ) ; if ( strlen ( rh -> r_host ) == 0 ) { g_free ( rh ) ; return FALSE ; } rh -> auth_type = CAPTURE_AUTH_NULL ; valp = valp -> next ; if ( valp ) { if ( ! strcmp ( ( const char * ) valp -> data , "0" ) ) { rh -> remote_port = ( gchar * ) g_strdup ( "" ) ; } else { rh -> remote_port = ( gchar * ) g_strdup ( ( const gchar * ) valp -> data ) ; } valp = valp -> next ; } else { rh -> remote_port = g_strdup ( "" ) ; } if ( valp ) { auth_type = ( capture_auth ) strtol ( ( const gchar * ) valp -> data , & p , 0 ) ; if ( p != valp -> data && * p == '\0' ) { rh -> auth_type = auth_type ; } } rh -> auth_username = g_strdup ( "" ) ; rh -> auth_password = g_strdup ( "" ) ; prefs_clear_string_list ( vals ) ; g_hash_table_insert ( remote_host_list , g_strdup ( rh -> r_host ) , rh ) ; return TRUE ; } 