iq2000_elf_check_relocs ( , , , ) bfd * abfd ; struct bfd_link_info * info ; asection * sec ; const Elf_Internal_Rela * relocs ; { Elf_Internal_Shdr * symtab_hdr ; struct elf_link_hash_entry * * sym_hashes , * * sym_hashes_end ; const Elf_Internal_Rela * rel ; const Elf_Internal_Rela * rel_end ; bfd_boolean changed = FALSE ; if ( info -> relocatable ) { return TRUE ; } symtab_hdr = & elf_tdata ( abfd ) -> symtab_hdr ; sym_hashes = elf_sym_hashes ( abfd ) ; sym_hashes_end = sym_hashes + symtab_hdr -> sh_size / sizeof ( Elf32_External_Sym ) ; if ( ! elf_bad_symtab ( abfd ) ) { sym_hashes_end -= symtab_hdr -> sh_info ; } rel_end = relocs + sec -> reloc_count ; for ( rel = relocs ; rel < rel_end ; rel ++ ) { struct elf_link_hash_entry * h ; cfs_time_t r_symndx ; r_symndx = ELF32_R_SYM ( rel -> r_info ) ; if ( r_symndx < symtab_hdr -> sh_info ) { h = NULL ; } else { h = sym_hashes [ r_symndx - symtab_hdr -> sh_info ] ; } switch ( ELF32_R_TYPE ( rel -> r_info ) ) { case R_IQ2000_GNU_VTINHERIT : if ( ! bfd_elf_gc_record_vtinherit ( abfd , sec , h , rel -> r_offset ) ) { return FALSE ; } break ; case R_IQ2000_GNU_VTENTRY : if ( ! bfd_elf_gc_record_vtentry ( abfd , sec , h , rel -> r_addend ) ) { return FALSE ; } break ; case R_IQ2000_32 : if ( memcmp ( sec -> name , ".debug" , 6 ) == 0 || memcmp ( sec -> name , ".stab" , 5 ) == 0 || memcmp ( sec -> name , ".eh_frame" , 9 ) == 0 ) { ( ( Elf_Internal_Rela * ) rel ) -> r_info = ELF32_R_INFO ( ELF32_R_SYM ( rel -> r_info ) , R_IQ2000_32_DEBUG ) ; changed = TRUE ; } break ; } } if ( changed ) { ( const Elf_Internal_Rela * ) ( elf_section_data ( sec ) -> relocs ) = relocs ; } return TRUE ; } 