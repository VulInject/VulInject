{ 0xd57 , 0xd57 } , { 0xe31 , 0xe31 } , { 0xe34 , 0xe3a } , { 0xe47 , 0xe4e } , { 0xeb1 , 0xeb1 } , { 0xeb4 , 0xeb9 } , { 0xebb , 0xebc } , { 0xec8 , 0xecd } , { 0xf18 , 0xf19 } , { 0xf35 , 0xf35 } , { 0xf37 , 0xf37 } , { 0xf39 , 0xf39 } , { 0xf3e , 0xf3e } , { 0xf3f , 0xf3f } , { 0xf71 , 0xf84 } , { 0xf86 , 0xf8b } , { 0xf90 , 0xf95 } , { 0xf97 , 0xf97 } , { 0xf99 , 0xfad } , { 0xfb1 , 0xfb7 } , { 0xfb9 , 0xfb9 } , { 0x20d0 , 0x20dc } , { 0x20e1 , 0x20e1 } , { 0x302a , 0x302f } , { 0x3099 , 0x3099 } , { 0x309a , 0x309a } const xmlChRangeGroup xmlIsCombiningGroup = { 95 0 xmlIsCombining_srng ( xmlChLRangePtr ) 0 } ; static const xmlChSRange xmlIsDigit_srng [ ] { { 0x660 0x669 } { 0x6f0 0x6f9 } { 0x966 0x96f } { 0x9e6 0x9ef } { 0xa66 0xa6f } { 0xae6 0xaef } { 0xb66 0xb6f } { 0xbe7 0xbef } { 0xc66 0xc6f } { 0xce6 0xcef } { 0xd66 0xd6f } { 0xe50 0xe59 } { 0xed0 0xed9 } { 0xf20 0xf29 } } ; ; const xmlChRangeGroup xmlIsDigitGroup = { 14 0 xmlIsDigit_srng ( xmlChLRangePtr ) 0 } ; static const xmlChSRange xmlIsExtender_srng [ ] { { 0x2d0 0x2d0 } { 0x2d1 0x2d1 } { 0x387 0x387 } { 0x640 0x640 } { 0xe46 0xe46 } { 0xec6 0xec6 } { 0x3005 0x3005 } { 0x3031 0x3035 } { 0x309d 0x309e } { 0x30fc 0x30fe } } ; ; const xmlChRangeGroup xmlIsExtenderGroup = { 10 0 xmlIsExtender_srng ( xmlChLRangePtr ) 0 } ; static const xmlChSRange xmlIsIdeographic_srng [ ] { { 0x3007 0x3007 } { 0x3021 0x3029 } { 0x4e00 0x9fa5 } } ; ; const xmlChRangeGroup xmlIsIdeographicGroup = { 3 0 xmlIsIdeographic_srng ( xmlChLRangePtr ) 0 } ; int xmlCharInRange ( unsigned int val , const xmlChRangeGroup * rptr ) { int low , high , mid ; const xmlChSRange * sptr ; const xmlChLRange * lptr ; if ( rptr == NULL ) { return ( 0 ) ; } if ( val < 0x10000 ) { low = 0 ; high = rptr -> nbShortRange - 1 ; sptr = rptr -> shortRange ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( ( unsigned short ) val < sptr [ mid ] . low ) { high = mid - 1 ; } else { if ( ( unsigned short ) val > sptr [ mid ] . high ) { low = mid + 1 ; } else { return 1 ; } } } } else { if ( rptr -> nbLongRange == 0 ) { return 0 ; } low = 0 ; high = rptr -> nbLongRange - 1 ; lptr = rptr -> longRange ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( val < lptr [ mid ] . low ) { high = mid - 1 ; } else { if ( val > lptr [ mid ] . high ) { low = mid + 1 ; } else { return 1 ; } } } } return 0 ; } 