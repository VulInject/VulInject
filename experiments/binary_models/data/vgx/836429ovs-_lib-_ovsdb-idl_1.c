enum ovsdb_idl_txn_status FUN1 ( struct VAR1 * VAR2 ) { struct VAR3 * VAR4 = VAR2 -> VAR4 ; if ( VAR2 != VAR4 -> VAR2 ) { VAR5 } if ( ! FUN2 ( VAR4 -> VAR6 ) ) { VAR2 -> VAR7 = VAR8 ; VAR9 } if ( FUN3 ( VAR4 -> VAR6 ) && ! FUN4 ( VAR4 -> VAR6 ) ) { VAR2 -> VAR7 = VAR10 ; VAR9 } struct VAR11 * VAR12 = FUN5 ( FUN6 ( VAR4 -> VAR13 -> VAR14 ) ) ; struct VAR15 * VAR16 ; FUN7 ( , , ) { if ( VAR16 -> VAR17 ) { const struct VAR18 * class = VAR16 -> VAR19 -> VAR13 ; size_t VAR20 = class -> VAR20 ; struct VAR11 * VAR21 , * VAR22 , * VAR23 ; size_t VAR24 ; VAR21 = FUN8 ( ) ; FUN9 ( VAR12 , VAR21 ) ; FUN10 ( VAR21 , "" , "" ) ; FUN10 ( VAR21 , "" , class -> VAR25 ) ; FUN11 ( VAR21 , "" , FUN12 ( 0 ) ) ; FUN11 ( VAR21 , "" , FUN13 ( & VAR16 -> VAR26 ) ) ; FUN10 ( VAR21 , "" , "" ) ; VAR22 = FUN14 ( ) ; FUN11 ( VAR21 , "" , VAR22 ) ; VAR23 = FUN8 ( ) ; FUN11 ( VAR21 , "" , FUN5 ( VAR23 ) ) ; FUN15 ( , , ) { const struct VAR27 * VAR28 = & class -> VAR22 [ VAR24 ] ; FUN9 ( VAR22 , FUN6 ( VAR28 -> VAR25 ) ) ; FUN11 ( VAR23 , VAR28 -> VAR25 , FUN16 ( & VAR16 -> VAR29 [ VAR24 ] , & VAR28 -> VAR30 ) ) ; } } } bool VAR31 = false ; for ( size_t VAR32 = 0 ; VAR32 < VAR4 -> VAR13 -> VAR33 ; VAR32 ++ ) { struct VAR34 * VAR19 = & VAR4 -> VAR35 [ VAR32 ] ; if ( VAR19 -> VAR13 -> VAR36 ) { int VAR37 = 0 ; size_t VAR38 = 0 ; FUN7 ( , , ) { VAR37 += VAR16 -> VAR29 != NULL ; VAR38 += VAR16 -> VAR39 != NULL ; } if ( VAR37 == 0 && VAR38 == 1 ) { struct VAR11 * VAR21 = FUN8 ( ) ; FUN9 ( VAR12 , VAR21 ) ; FUN10 ( VAR21 , "" , "" ) ; FUN10 ( VAR21 , "" , VAR19 -> VAR13 -> VAR25 ) ; FUN11 ( VAR21 , "" , FUN14 ( ) ) ; FUN11 ( VAR21 , "" , FUN12 ( 0 ) ) ; FUN10 ( VAR21 , "" , "" ) ; FUN11 ( VAR21 , "" , FUN14 ( ) ) ; } } } FUN7 ( , , ) { const struct VAR18 * class = VAR16 -> VAR19 -> VAR13 ; if ( ! VAR16 -> VAR39 ) { if ( class -> VAR40 ) { struct VAR11 * VAR21 = FUN8 ( ) ; FUN10 ( VAR21 , "" , "" ) ; FUN10 ( VAR21 , "" , class -> VAR25 ) ; FUN11 ( VAR21 , "" , FUN13 ( & VAR16 -> VAR26 ) ) ; FUN9 ( VAR12 , VAR21 ) ; VAR31 = true ; } else { } } if ( VAR16 -> VAR29 != VAR16 -> VAR39 ) { struct VAR11 * VAR23 ; size_t VAR24 ; struct VAR11 * VAR21 = FUN8 ( ) ; FUN10 ( VAR21 , "" , VAR16 -> VAR29 ?"" : "" ) ; FUN10 ( VAR21 , "" , class -> VAR25 ) ; if ( VAR16 -> VAR29 ) { FUN11 ( VAR21 , "" , FUN13 ( & VAR16 -> VAR26 ) ) ; } else { struct VAR41 * VAR42 ; VAR31 = true ; char * VAR43 ; struct VAR11 * VAR44 ; if ( VAR16 -> VAR45 ) { VAR43 = "" ; VAR44 = FUN17 ( FUN18 ( VAR46 , FUN19 ( & VAR16 -> VAR26 ) ) ) ; } else { VAR43 = "" ; VAR44 = FUN17 ( FUN20 ( & VAR16 -> VAR26 ) ) ; } FUN11 ( VAR21 , VAR43 , VAR44 ) ; VAR42 = xmalloc ( sizeof VAR42 ) ; VAR42 -> VAR47 = VAR16 -> VAR26 ; VAR42 -> VAR48 = VAR12 -> VAR49 . VAR50 - 1 ; FUN21 ( & VAR42 -> VAR51 ) ; FUN22 ( & VAR2 -> VAR52 , & VAR42 -> VAR53 , FUN23 ( & VAR42 -> VAR47 ) ) ; } VAR23 = FUN8 ( ) ; FUN11 ( VAR21 , "" , VAR23 ) ; if ( VAR16 -> VAR54 ) { FUN15 ( , , ) { const struct VAR27 * VAR28 = & class -> VAR22 [ VAR24 ] ; if ( VAR16 -> VAR29 || ! FUN24 ( & VAR16 -> VAR39 [ VAR24 ] , & VAR28 -> VAR30 ) ) { struct VAR11 * VAR44 ; VAR44 = FUN16 ( & VAR16 -> VAR39 [ VAR24 ] , & VAR28 -> VAR30 ) ; FUN11 ( VAR23 , VAR28 -> VAR25 , FUN25 ( VAR44 , VAR2 ) ) ; if ( ! VAR31 && VAR16 -> VAR29 && ! FUN26 ( & VAR16 -> VAR29 [ VAR24 ] , & VAR16 -> VAR39 [ VAR24 ] , & VAR28 -> VAR30 ) ) { VAR31 = true ; } } } } if ( ! VAR16 -> VAR29 || ! FUN27 ( FUN28 ( VAR23 ) ) ) { FUN9 ( VAR12 , VAR21 ) ; } else { FUN29 ( VAR21 ) ; } } if ( VAR16 -> VAR55 || VAR16 -> VAR56 ) { struct VAR11 * VAR21 , * VAR57 ; bool VAR58 ; VAR21 = FUN8 ( ) ; FUN10 ( VAR21 , "" , "" ) ; FUN10 ( VAR21 , "" , class -> VAR25 ) ; FUN11 ( VAR21 , "" , FUN13 ( & VAR16 -> VAR26 ) ) ; VAR57 = FUN14 ( ) ; VAR58 = FUN30 ( VAR16 , VAR57 ) ; FUN11 ( VAR21 , "" , VAR57 ) ; if ( VAR58 ) { VAR21 = FUN25 ( VAR21 , VAR2 ) ; FUN9 ( VAR12 , VAR21 ) ; VAR31 = true ; } else { FUN29 ( VAR21 ) ; } } } if ( VAR2 -> VAR59 && ( VAR31 || VAR2 -> VAR60 ) ) { VAR31 = true ; VAR2 -> VAR61 = VAR12 -> VAR49 . VAR50 - 1 ; struct VAR11 * VAR21 = FUN8 ( ) ; FUN10 ( VAR21 , "" , "" ) ; FUN10 ( VAR21 , "" , VAR2 -> VAR59 ) ; FUN11 ( VAR21 , "" , FUN25 ( FUN13 ( & VAR2 -> VAR62 ) , VAR2 ) ) ; FUN11 ( VAR21 , "" , FUN5 ( FUN31 ( FUN6 ( VAR2 -> VAR63 ) , FUN6 ( "" ) , FUN12 ( 1 ) ) ) ) ; FUN9 ( VAR12 , VAR21 ) ; VAR21 = FUN8 ( ) ; FUN10 ( VAR21 , "" , "" ) ; FUN10 ( VAR21 , "" , VAR2 -> VAR59 ) ; FUN11 ( VAR21 , "" , FUN25 ( FUN13 ( & VAR2 -> VAR62 ) , VAR2 ) ) ; FUN11 ( VAR21 , "" , FUN5 ( FUN6 ( VAR2 -> VAR63 ) ) ) ; FUN9 ( VAR12 , VAR21 ) ; } if ( VAR2 -> VAR64 . VAR65 ) { struct VAR11 * VAR21 = FUN8 ( ) ; FUN10 ( VAR21 , "" , "" ) ; FUN10 ( VAR21 , "" , FUN32 ( & VAR2 -> VAR64 ) ) ; FUN9 ( VAR12 , VAR21 ) ; } if ( VAR2 -> VAR66 ) { struct VAR11 * VAR21 = FUN8 ( ) ; FUN10 ( VAR21 , "" , "" ) ; FUN9 ( VAR12 , VAR21 ) ; } if ( ! VAR31 ) { VAR2 -> VAR7 = VAR67 ; FUN29 ( VAR12 ) ; } else { VAR2 -> VAR68 = FUN33 ( VAR4 -> VAR6 , VAR12 ) ; if ( VAR2 -> VAR68 ) { FUN22 ( & VAR4 -> VAR69 , & VAR2 -> VAR53 , FUN34 ( VAR2 -> VAR68 , 0 ) ) ; VAR2 -> VAR7 = VAR70 ; } else { VAR2 -> VAR7 = VAR8 ; } } disassemble_out FUN35 ( VAR2 ) ; coverage_out switch ( VAR2 -> VAR7 ) { case VAR71 : FUN36 ( VAR72 ) ; break ; case VAR67 : FUN36 ( VAR73 ) ; break ; case VAR70 : FUN36 ( VAR74 ) ; break ; case VAR75 : FUN36 ( VAR76 ) ; break ; case VAR77 : FUN36 ( VAR78 ) ; break ; case VAR8 : FUN36 ( VAR79 ) ; break ; case VAR10 : FUN36 ( VAR80 ) ; break ; case VAR81 : FUN36 ( VAR82 ) ; break ; } return VAR2 -> VAR7 ; }