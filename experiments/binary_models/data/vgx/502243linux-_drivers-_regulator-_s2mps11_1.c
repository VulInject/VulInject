static int s2mps11_pmic_probe ( struct platform_device * pdev ) { struct sec_pmic_dev * iodev = dev_get_drvdata ( pdev -> dev . parent ) ; struct of_regulator_match * rdata = NULL ; struct regulator_config config = { } ; struct s2mps11_info * s2mps11 ; unsigned int rdev_num = 0 ; int i , ret = 0 ; const struct regulator_desc * regulators ; s2mps11 = devm_kzalloc ( & pdev -> dev , sizeof ( s2mps11_info ) , GFP_KERNEL ) ; s2mps11 -> dev_type = platform_get_device_id ( pdev ) -> driver_data ; switch ( s2mps11 -> dev_type ) { case S2MPS11X : rdev_num = ARRAY_SIZE ( s2mps11_regulators ) ; regulators = s2mps11_regulators ; BUILD_BUG_ON ( S2MPS_REGULATOR_MAX < ARRAY_SIZE ( s2mps11_regulators ) ) ; break ; case S2MPS13X : rdev_num = ARRAY_SIZE ( s2mps13_regulators ) ; regulators = s2mps13_regulators ; BUILD_BUG_ON ( S2MPS_REGULATOR_MAX < ARRAY_SIZE ( s2mps13_regulators ) ) ; break ; case S2MPS14X : rdev_num = ARRAY_SIZE ( s2mps14_regulators ) ; regulators = s2mps14_regulators ; BUILD_BUG_ON ( S2MPS_REGULATOR_MAX < ARRAY_SIZE ( s2mps14_regulators ) ) ; break ; case S2MPS15X : rdev_num = ARRAY_SIZE ( s2mps15_regulators ) ; regulators = s2mps15_regulators ; BUILD_BUG_ON ( S2MPS_REGULATOR_MAX < ARRAY_SIZE ( s2mps15_regulators ) ) ; break ; case S2MPU02 : rdev_num = ARRAY_SIZE ( s2mpu02_regulators ) ; regulators = s2mpu02_regulators ; BUILD_BUG_ON ( S2MPS_REGULATOR_MAX < ARRAY_SIZE ( s2mpu02_regulators ) ) ; break ; default : dev_err ( & pdev -> dev , "Invalid device type: %u\n" , s2mps11 -> dev_type ) ; return - EINVAL ; } s2mps11 -> ext_control_gpiod = devm_kcalloc ( & pdev -> dev , rdev_num , sizeof ( * s2mps11 -> ext_control_gpiod ) , GFP_KERNEL ) ; if ( ! s2mps11 -> ext_control_gpiod ) { return - ENOMEM ; } rdata = kcalloc ( rdev_num , sizeof ( * rdata ) , GFP_KERNEL ) ; if ( ! rdata ) { return - ENOMEM ; } for ( i = 0 ; i < rdev_num ; i ++ ) { rdata [ i ] . name = regulators [ i ] . name ; } ret = s2mps11_pmic_dt_parse ( pdev , rdata , s2mps11 , rdev_num ) ; if ( ret ) { out } platform_set_drvdata ( pdev , s2mps11 ) ; config . dev = & pdev -> dev ; config . regmap = iodev -> regmap_pmic ; config . driver_data = s2mps11 ; for ( i = 0 ; i < rdev_num ; i ++ ) { struct regulator_dev * regulator ; config . init_data = rdata [ i ] . init_data ; config . of_node = rdata [ i ] . of_node ; config . ena_gpiod = s2mps11 -> ext_control_gpiod [ i ] ; if ( config . ena_gpiod ) { devm_gpiod_unhinge ( & pdev -> dev , config . ena_gpiod ) ; } regulator = devm_regulator_register ( & pdev -> dev , & regulators [ i ] , & config ) ; if ( IS_ERR ( regulator ) ) { ret = PTR_ERR ( regulator ) ; dev_err ( & pdev -> dev , "regulator init failed for %d\n" , i ) ; out } if ( config . ena_gpiod ) { ret = s2mps14_pmic_enable_ext_control ( s2mps11 , regulator ) ; if ( ret < 0 ) { dev_err ( & pdev -> dev , "failed to enable GPIO control over %s: %d\n" , regulator -> desc -> name , ret ) ; out } } } out kfree ( rdata ) ; return ret ; } 