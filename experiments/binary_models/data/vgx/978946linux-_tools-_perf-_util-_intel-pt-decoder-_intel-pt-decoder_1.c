static int intel_pt_hop_trace ( struct intel_pt_decoder * decoder , bool * no_tip , int * err ) { * err = 0 ; if ( decoder -> leap && ! decoder -> in_psb && decoder -> packet . type != INTEL_PT_PSB ) { * err = intel_pt_scan_for_psb ( decoder ) ; } switch ( decoder -> packet . type ) { case INTEL_PT_TNT : return HOP_IGNORE ; case INTEL_PT_TIP_PGD : decoder -> pge = false ; if ( ! decoder -> packet . count ) { intel_pt_set_nr ( decoder ) ; return HOP_IGNORE ; } intel_pt_set_ip ( decoder ) ; decoder -> state . type |= INTEL_PT_TRACE_END ; decoder -> state . from_ip = 0 ; decoder -> state . to_ip = decoder -> ip ; intel_pt_update_nr ( decoder ) ; return HOP_RETURN ; case INTEL_PT_TIP : if ( ! decoder -> packet . count ) { intel_pt_set_nr ( decoder ) ; return HOP_IGNORE ; } intel_pt_set_ip ( decoder ) ; decoder -> state . type = INTEL_PT_INSTRUCTION ; decoder -> state . from_ip = decoder -> ip ; decoder -> state . to_ip = 0 ; intel_pt_update_nr ( decoder ) ; intel_pt_sample_iflag_chg ( decoder ) ; return HOP_RETURN ; case INTEL_PT_FUP : if ( ! decoder -> packet . count ) { return HOP_IGNORE ; } intel_pt_set_ip ( decoder ) ; if ( decoder -> set_fup_mwait || decoder -> set_fup_pwre ) { * no_tip = true ; } if ( ! decoder -> branch_enable || ! decoder -> pge ) { * no_tip = true ; } if ( * no_tip ) { decoder -> state . type = INTEL_PT_INSTRUCTION ; decoder -> state . from_ip = decoder -> ip ; decoder -> state . to_ip = 0 ; intel_pt_fup_event ( decoder , * no_tip ) ; return HOP_RETURN ; } intel_pt_fup_event ( decoder , * no_tip ) ; decoder -> state . type |= INTEL_PT_INSTRUCTION | INTEL_PT_BRANCH ; * err = intel_pt_walk_fup_tip ( decoder ) ; if ( ! * err && decoder -> state . to_ip ) { decoder -> pkt_state = INTEL_PT_STATE_RESAMPLE ; } return HOP_RETURN ; case INTEL_PT_PSB : decoder -> state . psb_offset = decoder -> pos ; decoder -> psb_ip = 0 ; decoder -> last_ip = 0 ; decoder -> have_last_ip = true ; * err = intel_pt_walk_psbend ( decoder ) ; if ( * err == - EAGAIN ) { return HOP_AGAIN ; } if ( * err ) { return HOP_RETURN ; } decoder -> state . type = INTEL_PT_PSB_EVT ; if ( decoder -> psb_ip ) { decoder -> state . type |= INTEL_PT_INSTRUCTION ; decoder -> ip = decoder -> psb_ip ; } decoder -> state . from_ip = decoder -> psb_ip ; decoder -> state . to_ip = 0 ; return HOP_RETURN ; case INTEL_PT_BAD : case INTEL_PT_PAD : case INTEL_PT_TIP_PGE : case INTEL_PT_TSC : case INTEL_PT_TMA : case INTEL_PT_MODE_EXEC : case INTEL_PT_MODE_TSX : case INTEL_PT_MTC : case INTEL_PT_CYC : case INTEL_PT_VMCS : case INTEL_PT_PSBEND : case INTEL_PT_CBR : case INTEL_PT_TRACESTOP : case INTEL_PT_PIP : case INTEL_PT_OVF : case INTEL_PT_MNT : case INTEL_PT_PTWRITE : case INTEL_PT_PTWRITE_IP : case INTEL_PT_EXSTOP : case INTEL_PT_EXSTOP_IP : case INTEL_PT_MWAIT : case INTEL_PT_PWRE : case INTEL_PT_PWRX : case INTEL_PT_BBP : case INTEL_PT_BIP : case INTEL_PT_BEP : case INTEL_PT_BEP_IP : case INTEL_PT_CFE : case INTEL_PT_CFE_IP : case INTEL_PT_EVD : default : return HOP_PROCESS ; } } intel_pt_psb_info { struct intel_pt_pkt fup_packet ; bool fup ; int after_psbend ; } 