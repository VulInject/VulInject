static void flush_stashed_error_work ( struct work_struct * work ) { struct ext4_sb_info * sbi = container_of ( work , ext4_sb_info , s_error_work ) ; journal_t * journal = sbi -> s_journal ; handle_t * handle ; if ( ! sb_rdonly ( sbi -> s_sb ) && journal ) { struct buffer_head * sbh = sbi -> s_sbh ; handle = jbd2_journal_start ( journal , 1 ) ; if ( IS_ERR ( handle ) ) { write_directly } if ( jbd2_journal_get_write_access ( handle , sbh ) ) { jbd2_journal_stop ( handle ) ; write_directly } ext4_update_super ( sbi -> s_sb ) ; if ( buffer_write_io_error ( sbh ) || ! buffer_uptodate ( sbh ) ) { ext4_msg ( sbi -> s_sb , KERN_ERR , "previous I/O error to " "superblock detected" ) ; clear_buffer_write_io_error ( sbh ) ; set_buffer_uptodate ( sbh ) ; } if ( jbd2_journal_dirty_metadata ( handle , sbh ) ) { jbd2_journal_stop ( handle ) ; write_directly } jbd2_journal_stop ( handle ) ; ext4_notify_error_sysfs ( sbi , NULL ) ; return ; } write_directly ext4_commit_super ( sbi -> s_sb ) ; ext4_notify_error_sysfs ( sbi ) ; } 