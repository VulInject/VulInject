struct dentry * cifs_lookup ( struct inode * parent_dir_inode , struct dentry * direntry , unsigned int flags ) { unsigned int xid ; int rc = 0 ; struct cifs_sb_info * cifs_sb ; struct tcon_link * tlink ; struct cifs_tcon * pTcon ; struct inode * newInode = NULL ; char * full_path = NULL ; xid = get_xid ( ) ; cifs_dbg ( FYI , "parent inode = 0x%p name is: %pd and dentry = 0x%p\n" , parent_dir_inode , direntry , direntry ) ; cifs_sb = CIFS_SB ( parent_dir_inode -> i_sb ) ; tlink = cifs_sb_tlink ( cifs_sb ) ; if ( IS_ERR ( tlink ) ) { free_xid ( xid ) ; return ( dentry * ) tlink ; } pTcon = tlink_tcon ( tlink ) ; rc = check_name ( direntry ) ; if ( rc ) { lookup_out } full_path = build_path_from_dentry ( direntry ) ; if ( full_path == NULL ) { rc = - ENOMEM ; lookup_out } if ( d_really_is_positive ( direntry ) ) { cifs_dbg ( FYI , "non-NULL inode in lookup\n" ) ; } else { cifs_dbg ( FYI , "NULL inode in lookup\n" ) ; } cifs_dbg ( FYI , "Full path: %s inode = 0x%p\n" , full_path , d_inode ( direntry ) ) ; if ( pTcon -> unix_ext ) { rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else { rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; } if ( ( rc == 0 ) && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; renew_parental_timestamps ( direntry ) ; } if ( rc == - ENOENT ) { rc = 0 ; cifs_set_time ( direntry , jiffies ) ; d_add ( direntry , NULL ) ; } if ( rc != - EACCES ) { cifs_dbg ( FYI , "Unexpected lookup error %d\n" , rc ) ; } lookup_out cifs_put_tlink ( tlink ) ; free_xid ( xid ) ; return ERR_PTR ( rc ) ; } 