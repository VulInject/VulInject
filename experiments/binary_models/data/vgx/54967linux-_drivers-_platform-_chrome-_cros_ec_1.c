int cros_ec_register ( struct cros_ec_device * ec_dev ) { struct device * dev = ec_dev -> dev ; int err = 0 ; BLOCKING_INIT_NOTIFIER_HEAD ( & ec_dev -> event_notifier ) ; BLOCKING_INIT_NOTIFIER_HEAD ( & ec_dev -> panic_notifier ) ; ec_dev -> max_request = sizeof ( ec_params_hello ) ; ec_dev -> max_response = sizeof ( ec_response_get_protocol_info ) ; ec_dev -> max_passthru = 0 ; ec_dev -> ec = NULL ; ec_dev -> pd = NULL ; ec_dev -> suspend_timeout_ms = EC_HOST_SLEEP_TIMEOUT_DEFAULT ; ec_dev -> din = devm_kzalloc ( dev , ec_dev -> din_size , GFP_KERNEL ) ; ec_dev -> dout = devm_kzalloc ( dev , ec_dev -> dout_size , GFP_KERNEL ) ; if ( ! ec_dev -> dout ) { return - ENOMEM ; } lockdep_register_key ( & ec_dev -> lockdep_key ) ; mutex_init ( & ec_dev -> lock ) ; lockdep_set_class ( & ec_dev -> lock , & ec_dev -> lockdep_key ) ; err = cros_ec_query_all ( ec_dev ) ; if ( err ) { dev_err ( dev , "Cannot identify the EC: error %d\n" , err ) ; destroy_mutex } if ( ec_dev -> irq > 0 ) { err = devm_request_threaded_irq ( dev , ec_dev -> irq , cros_ec_irq_handler , cros_ec_irq_thread , IRQF_TRIGGER_LOW | IRQF_ONESHOT , "chromeos-ec" , ec_dev ) ; if ( err ) { dev_err ( dev , "Failed to request IRQ %d: %d\n" , ec_dev -> irq , err ) ; destroy_mutex } } ec_dev -> ec = platform_device_register_data ( ec_dev -> dev , "cros-ec-dev" , PLATFORM_DEVID_AUTO , & ec_p , sizeof ( cros_ec_platform ) ) ; if ( IS_ERR ( ec_dev -> ec ) ) { dev_err ( ec_dev -> dev , "Failed to create CrOS EC platform device\n" ) ; err = PTR_ERR ( ec_dev -> ec ) ; destroy_mutex } if ( ec_dev -> max_passthru ) { ec_dev -> pd = platform_device_register_data ( ec_dev -> dev , "cros-ec-dev" , PLATFORM_DEVID_AUTO , & pd_p , sizeof ( cros_ec_platform ) ) ; if ( IS_ERR ( ec_dev -> pd ) ) { dev_err ( ec_dev -> dev , "Failed to create CrOS PD platform device\n" ) ; err = PTR_ERR ( ec_dev -> pd ) ; exit } } if ( IS_ENABLED ( CONFIG_OF ) && dev -> of_node ) { err = devm_of_platform_populate ( dev ) ; if ( err ) { dev_err ( dev , "Failed to register sub-devices\n" ) ; exit } } err = cros_ec_sleep_event ( ec_dev , 0 ) ; if ( err < 0 ) { dev_dbg ( ec_dev -> dev , "Error %d clearing sleep event to ec\n" , err ) ; } if ( ec_dev -> mkbp_event_supported ) { ec_dev -> notifier_ready . notifier_call = cros_ec_ready_event ; err = blocking_notifier_chain_register ( & ec_dev -> event_notifier , & ec_dev -> notifier_ready ) ; if ( err ) { exit } } dev_info ( dev , "Chrome EC device registered\n" ) ; if ( ec_dev -> mkbp_event_supported ) { cros_ec_irq_thread ( 0 , ec_dev ) ; } return 0 ; exit platform_device_unregister ( ec_dev -> ec ) ; platform_device_unregister ( ec_dev -> pd ) ; destroy_mutex mutex_destroy ( & ec_dev -> lock ) ; lockdep_unregister_key ( & ec_dev -> lockdep_key ) ; return err ; } 