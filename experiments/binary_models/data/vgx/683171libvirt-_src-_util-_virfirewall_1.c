void virFirewallFree ( virFirewall * firewall ) { size_t i ; if ( ! firewall ) { return ; } for ( i = 0 ; i < firewall -> ngroups ; i ++ ) { virFirewallGroupFree ( firewall -> groups [ i ] ) ; } g_free ( firewall -> groups ) ; } { if ( ! firewall || firewall -> err ) { return ; } } 0 ; { if ( ! firewall || firewall -> err || ! rule ) { return ; } } while ( 0 ) { { if ( ! firewall || firewall -> err ) { return NULL ; } } 0 ; { VIR_RESIZE_N ( rule -> args , rule -> argsAlloc , rule -> argsLen , 1 ) ; rule -> args [ rule -> argsLen ++ ] = g_strdup ( str ) ; } } while ( 0 ) { static virFirewallRule * virFirewallAddRuleFullV ( virFirewall * firewall , virFirewallLayer layer , bool ignoreErrors , virFirewallQueryCallback cb , void * opaque , va_list args ) { virFirewallGroup * group ; virFirewallRule * rule ; char * str ; VIR_FIREWALL_RETURN_NULL_IF_ERROR ( firewall ) ; if ( firewall -> ngroups == 0 ) { firewall -> err = EINVAL ; return NULL ; } group = firewall -> groups [ firewall -> currentGroup ] ; rule = g_new0 ( virFirewallRule , 1 ) ; rule -> layer = layer ; rule -> queryCB = cb ; rule -> queryOpaque = opaque ; rule -> ignoreErrors = ignoreErrors ; switch ( rule -> layer ) { case VIR_FIREWALL_LAYER_ETHERNET : ADD_ARG ( rule , "--concurrent" ) ; break ; case VIR_FIREWALL_LAYER_IPV4 : ADD_ARG ( rule , "-w" ) ; break ; case VIR_FIREWALL_LAYER_IPV6 : ADD_ARG ( rule , "-w" ) ; break ; case VIR_FIREWALL_LAYER_LAST : break ; } while ( ( str = va_arg ( args , char * ) ) != NULL ) { ADD_ARG ( rule , str ) ; } if ( group -> addingRollback ) { VIR_APPEND_ELEMENT_COPY ( group -> rollback , group -> nrollback , rule ) ; } else { VIR_APPEND_ELEMENT_COPY ( group -> action , group -> naction , rule ) ; } return rule ; } } 