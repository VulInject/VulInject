static void * extstore_maint_thread ( void * arg ) { store_maint_thread * me = ( store_maint_thread * ) arg ; store_engine * e = me -> e ; struct extstore_page_data * pd = calloc ( e -> page_count , sizeof ( extstore_page_data ) ) ; while ( 1 ) { int i ; bool do_evict = false ; unsigned int low_page = 0 ; uint64_t low_version = ULLONG_MAX ; pthread_cond_wait ( & me -> cond , & me -> mutex ) ; pthread_mutex_lock ( & e -> mutex ) ; if ( e -> page_free == 0 || e -> page_freelist == NULL ) { do_evict = true ; } pthread_mutex_unlock ( & e -> mutex ) ; memset ( pd , 0 , sizeof ( extstore_page_data ) * e -> page_count ) ; for ( i = 0 ; i < e -> page_count ; i ++ ) { store_page * p = & e -> pages [ i ] ; pthread_mutex_lock ( & p -> mutex ) ; pd [ p -> id ] . free_bucket = p -> free_bucket ; if ( p -> active || p -> free ) { pthread_mutex_unlock ( & p -> mutex ) ; continue ; } if ( p -> obj_count > 0 && ! p -> closed ) { pd [ p -> id ] . version = p -> version ; pd [ p -> id ] . bytes_used = p -> bytes_used ; pd [ p -> id ] . bucket = p -> bucket ; if ( p -> free_bucket == 0 && p -> version < low_version ) { low_version = p -> version ; low_page = i ; } } if ( ( p -> obj_count == 0 || p -> closed ) && p -> refcount == 0 ) { _free_page ( e , p ) ; do_evict = false ; } pthread_mutex_unlock ( & p -> mutex ) ; } if ( do_evict && low_version != ULLONG_MAX ) { store_page * p = & e -> pages [ low_page ] ; E_DEBUG ( "EXTSTORE: evicting page [%d] [v: %llu]\n" , p -> id , ( unsigned long long ) p -> version ) ; pthread_mutex_lock ( & p -> mutex ) ; if ( ! p -> closed ) { p -> closed = true ; STAT_L ( e ) ; e -> stats . page_evictions ++ ; e -> stats . objects_evicted += p -> obj_count ; e -> stats . bytes_evicted += p -> bytes_used ; STAT_UL ( e ) ; if ( p -> refcount == 0 ) { _free_page ( e , p ) ; } } pthread_mutex_unlock ( & p -> mutex ) ; } STAT_L ( e ) ; memcpy ( e -> stats . page_data , pd , sizeof ( extstore_page_data ) * e -> page_count ) ; STAT_UL ( e ) ; } return NULL ; } 