static int LZ4_compress_destSize_generic ( LZ4_stream_t_internal * const ctx , const char * const src , char * const dst , int * const srcSizePtr , const int targetDstSize , const tableType_t tableType ) { const BYTE * ip = ( const BYTE * ) src ; const BYTE * base = ( const BYTE * ) src ; const BYTE * lowLimit = ( const BYTE * ) src ; const BYTE * anchor = ip ; const BYTE * const iend = ip + * srcSizePtr ; const BYTE * const mflimit = iend - MFLIMIT ; const BYTE * const matchlimit = iend - LASTLITERALS ; BYTE * op = ( BYTE * ) dst ; BYTE * const oend = op + targetDstSize ; BYTE * const oMaxLit = op + targetDstSize - 2 - 8 - 1 ; BYTE * const oMaxMatch = op + targetDstSize - ( LASTLITERALS + 1 ) ; BYTE * const oMaxSeq = oMaxLit - 1 ; U32 forwardH ; if ( ( U32 ) * srcSizePtr > ( U32 ) LZ4_MAX_INPUT_SIZE ) { return 0 ; } if ( ( tableType == byU16 ) && ( * srcSizePtr >= LZ4_64Klimit ) ) { return 0 ; } if ( * srcSizePtr < LZ4_minLength ) { _last_literals } * srcSizePtr = 0 ; LZ4_putPosition ( ip , ctx -> hashTable , tableType , base ) ; ip ++ ; forwardH = LZ4_hashPosition ( ip , tableType ) ; for ( ; ; ) { const BYTE * match ; BYTE * token ; { const BYTE * forwardIp = ip ; unsigned step = 1 ; unsigned searchMatchNb = 1 << LZ4_skipTrigger ; { U32 h = forwardH ; ip = forwardIp ; forwardIp += step ; step = ( searchMatchNb ++ >> LZ4_skipTrigger ) ; if ( unlikely ( forwardIp > mflimit ) ) { _last_literals } match = LZ4_getPositionOnHash ( h , ctx -> hashTable , tableType , base ) ; forwardH = LZ4_hashPosition ( forwardIp , tableType ) ; LZ4_putPositionOnHash ( ip , h , ctx -> hashTable , tableType , base ) ; } ( ( tableType == byU16 ) ?0 : ( match + MAX_DISTANCE < ip ) ) || ( LZ4_read32 ( match ) != LZ4_read32 ( ip ) ) ; } while ( ( ip > anchor ) && ( match > lowLimit ) && ( unlikely ( ip [ - 1 ] == match [ - 1 ] ) ) ) { ip -- ; match -- ; } { unsigned litLength = ( unsigned ) ( ip - anchor ) ; token = op ++ ; if ( op + ( ( litLength + 240 ) / 255 ) + litLength > oMaxLit ) { op -- ; _last_literals } if ( litLength >= RUN_MASK ) { unsigned len = litLength - RUN_MASK ; * token = ( RUN_MASK << ML_BITS ) ; for ( ; len >= 255 ; len -= 255 ) { * op ++ = 255 ; } * op ++ = ( BYTE ) len ; } else { * token = ( BYTE ) ( litLength << ML_BITS ) ; } LZ4_wildCopy ( op , anchor , op + litLength ) ; op += litLength ; } _next_match LZ4_writeLE16 ( op , ( U16 ) ( ip - match ) ) ; op += 2 ; { size_t matchLength = LZ4_count ( ip + MINMATCH , match + MINMATCH , matchlimit ) ; if ( op + ( ( matchLength + 240 ) / 255 ) > oMaxMatch ) { matchLength = ( 15 - 1 ) + ( oMaxMatch - op ) * 255 ; } ip += MINMATCH + matchLength ; if ( matchLength >= ML_MASK ) { * token += ML_MASK ; matchLength -= ML_MASK ; while ( matchLength >= 255 ) { matchLength -= 255 ; * op ++ = 255 ; } * op ++ = ( BYTE ) matchLength ; } else { * token += ( BYTE ) ( matchLength ) ; } } anchor = ip ; if ( ip > mflimit ) { break ; } if ( op > oMaxSeq ) { break ; } LZ4_putPosition ( ip - 2 , ctx -> hashTable , tableType , base ) ; match = LZ4_getPosition ( ip , ctx -> hashTable , tableType , base ) ; LZ4_putPosition ( ip , ctx -> hashTable , tableType , base ) ; if ( ( match + MAX_DISTANCE >= ip ) && ( LZ4_read32 ( match ) == LZ4_read32 ( ip ) ) ) { token = op ++ ; * token = 0 ; _next_match } forwardH = LZ4_hashPosition ( ++ ip , tableType ) ; } _last_literals { size_t lastRunSize = ( size_t ) ( iend - anchor ) ; if ( op + 1 + ( ( lastRunSize + 240 ) / 255 ) + lastRunSize > oend ) { lastRunSize = ( oend - op ) - 1 ; lastRunSize -= ( lastRunSize + 240 ) / 255 ; } ip = anchor + lastRunSize ; if ( lastRunSize >= RUN_MASK ) { size_t accumulator = lastRunSize - RUN_MASK ; * op ++ = RUN_MASK << ML_BITS ; for ( ; accumulator >= 255 ; accumulator -= 255 ) { * op ++ = 255 ; } * op ++ = ( BYTE ) accumulator ; } else { * op ++ = ( BYTE ) ( lastRunSize << ML_BITS ) ; } memcpy ( op , anchor , lastRunSize ) ; op += lastRunSize ; } * srcSizePtr = ( int ) ( ( ( const char * ) ip ) - src ) ; return ( int ) ( ( ( char * ) op ) - dst ) ; } 