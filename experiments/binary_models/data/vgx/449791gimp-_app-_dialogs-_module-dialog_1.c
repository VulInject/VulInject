dialog_info_update ( , , ) { GtkTreeModel * model = GTK_TREE_MODEL ( private -> list ) ; const GimpModuleInfo * info ; GtkTreeIter iter ; const gchar * text [ N_INFOS ] { NULL } ; ; const gchar * location = NULL ; gboolean iter_valid ; gint i ; gboolean show_error ; for ( iter_valid = gtk_tree_model_get_iter_first ( model , & iter ) ; iter_valid ; iter_valid = gtk_tree_model_iter_next ( model , & iter ) ) { GimpModule * this ; gtk_tree_model_get ( model , & iter , COLUMN_MODULE , & this , - 1 ) ; if ( this ) { g_object_unref ( this ) ; } } if ( iter_valid ) { dialog_list_item_update ( private , & iter , module ) ; } if ( module != private -> selected ) { return ; } if ( ! module ) { for ( i = 0 ; i < N_INFOS ; i ++ ) { gtk_label_set_text ( GTK_LABEL ( private -> label [ i ] ) , NULL ) ; } gtk_label_set_text ( GTK_LABEL ( private -> error_label ) , NULL ) ; gtk_widget_hide ( private -> error_box ) ; return ; } if ( gimp_module_is_on_disk ( module ) ) { location = gimp_file_get_utf8_name ( gimp_module_get_file ( module ) ) ; } info = gimp_module_get_info ( module ) ; if ( info ) { text [ INFO_AUTHOR ] = info -> author ; text [ INFO_VERSION ] = info -> version ; text [ INFO_DATE ] = info -> date ; text [ INFO_COPYRIGHT ] = info -> copyright ; text [ INFO_LOCATION ] = gimp_module_is_on_disk ( module ) ?location : _ ( "Only in memory" ) ; } else { text [ INFO_LOCATION ] = gimp_module_is_on_disk ( module ) ?location : _ ( "No longer available" ) ; } for ( i = 0 ; i < N_INFOS ; i ++ ) { gtk_label_set_text ( GTK_LABEL ( private -> label [ i ] ) , text [ i ] ?text [ i ] : "--" ) ; } show_error = ( gimp_module_get_state ( module ) == GIMP_MODULE_STATE_ERROR && gimp_module_get_last_error ( module ) ) ; gtk_label_set_text ( GTK_LABEL ( private -> error_label ) , show_error ?gimp_module_get_last_error ( module ) : NULL ) ; gtk_widget_set_visible ( private -> error_box , show_error ) ; } 