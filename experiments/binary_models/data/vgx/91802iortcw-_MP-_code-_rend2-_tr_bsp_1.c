void R_LoadEnvironmentJson ( const char * baseName ) { char filename [ MAX_QPATH ] ; { char * c ; void * v ; } , buffer char * bufferEnd ; const char * cubemapArrayJson ; int filelen , i ; Com_sprintf ( filename , MAX_QPATH , "cubemaps/%s/env.json" , baseName ) ; filelen = ri . FS_ReadFile ( filename , & buffer . v ) ; if ( ! buffer . c ) { return ; } bufferEnd = buffer . c + filelen ; if ( JSON_ValueGetType ( buffer . c , bufferEnd ) != JSONTYPE_OBJECT ) { ri . Printf ( PRINT_ALL , "Bad %s: does not start with a object\n" , filename ) ; ri . FS_FreeFile ( buffer . v ) ; return ; } cubemapArrayJson = JSON_ObjectGetNamedValue ( buffer . c , bufferEnd , "Cubemaps" ) ; if ( ! cubemapArrayJson ) { ri . Printf ( PRINT_ALL , "Bad %s: no Cubemaps\n" , filename ) ; ri . FS_FreeFile ( buffer . v ) ; return ; } if ( JSON_ValueGetType ( cubemapArrayJson , bufferEnd ) != JSONTYPE_ARRAY ) { ri . Printf ( PRINT_ALL , "Bad %s: Cubemaps not an array\n" , filename ) ; ri . FS_FreeFile ( buffer . v ) ; return ; } tr . numCubemaps = JSON_ArrayGetIndex ( cubemapArrayJson , bufferEnd , NULL , 0 ) ; tr . cubemaps = ri . Hunk_Alloc ( tr . numCubemaps * sizeof ( * tr . cubemaps ) , h_low ) ; for ( i = 0 ; i < tr . numCubemaps ; i ++ ) { cubemap_t * cubemap = & tr . cubemaps [ i ] ; const char * cubemapJson , * keyValueJson , * indexes [ 3 ] ; int j ; cubemapJson = JSON_ArrayGetValue ( cubemapArrayJson , bufferEnd , i ) ; keyValueJson = JSON_ObjectGetNamedValue ( cubemapJson , bufferEnd , "Name" ) ; if ( ! JSON_ValueGetString ( keyValueJson , bufferEnd , cubemap -> name , MAX_QPATH ) ) { cubemap -> name [ 0 ] = '\0' ; } keyValueJson = JSON_ObjectGetNamedValue ( cubemapJson , bufferEnd , "Position" ) ; JSON_ArrayGetIndex ( keyValueJson , bufferEnd , indexes , 3 ) ; for ( j = 0 ; j < 3 ; j ++ ) { cubemap -> origin [ j ] = JSON_ValueGetFloat ( indexes [ j ] , bufferEnd ) ; } cubemap -> parallaxRadius = 1000.0f ; keyValueJson = JSON_ObjectGetNamedValue ( cubemapJson , bufferEnd , "Radius" ) ; if ( keyValueJson ) { cubemap -> parallaxRadius = JSON_ValueGetFloat ( keyValueJson , bufferEnd ) ; } } ri . FS_FreeFile ( buffer . v ) ; } 