int rvu_cgx_start_stop_io ( struct rvu * rvu , u16 pcifunc , bool start ) { struct rvu_pfvf * parent_pf , * pfvf ; int cgx_users , err ; if ( ! is_pf_cgxmapped ( rvu , rvu_get_pf ( pcifunc ) ) ) { return 0 ; } parent_pf = & rvu -> pf [ rvu_get_pf ( pcifunc ) ] ; pfvf = rvu_get_pfvf ( rvu , pcifunc ) ; mutex_lock ( & rvu -> cgx_cfg_lock ) ; if ( start && pfvf -> cgx_in_use ) { exit } if ( ! start && ! pfvf -> cgx_in_use ) { exit } if ( start ) { cgx_users = parent_pf -> cgx_users ; parent_pf -> cgx_users ++ ; } else { parent_pf -> cgx_users -- ; cgx_users = parent_pf -> cgx_users ; } if ( ! cgx_users ) { err = rvu_cgx_config_rxtx ( rvu , pcifunc & ~ RVU_PFVF_FUNC_MASK , start ) ; if ( err ) { dev_err ( rvu -> dev , "Unable to %s CGX\n" , start ?"start" : "stop" ) ; parent_pf -> cgx_users = start ?parent_pf -> cgx_users - 1 : parent_pf -> cgx_users + 1 ; exit } } pfvf -> cgx_in_use = start ; exit mutex_unlock ( & rvu -> cgx_cfg_lock ) ; return err ; } 