void AlterSystemSetConfigFile ( AlterSystemStmt * altersysstmt ) { char * name ; char * value ; bool resetall = false ; ConfigVariable * head = NULL ; ConfigVariable * tail ; volatile int Tmpfd ; char AutoConfFileName [ MAXPGPATH ] ; char AutoConfTmpFileName [ MAXPGPATH ] ; name = altersysstmt -> setstmt -> name ; switch ( altersysstmt -> setstmt -> kind ) { case VAR_SET_VALUE : value = ExtractSetVariableArgs ( altersysstmt -> setstmt ) ; break ; case VAR_SET_DEFAULT : case VAR_RESET : value = NULL ; break ; case VAR_RESET_ALL : value = NULL ; resetall = true ; break ; default : elog ( ERROR , "unrecognized alter system stmt type: %d" , altersysstmt -> setstmt -> kind ) ; break ; } if ( ! superuser ( ) ) { if ( resetall ) { ereport ( ERROR , ( errcode ( ERRCODE_INSUFFICIENT_PRIVILEGE ) , errmsg ( "permission denied to perform ALTER SYSTEM RESET ALL" ) ) ) ; } else { AclResult aclresult ; aclresult = pg_parameter_aclcheck ( name , GetUserId ( ) , ACL_ALTER_SYSTEM ) ; if ( aclresult != ACLCHECK_OK ) { ereport ( ERROR , ( errcode ( ERRCODE_INSUFFICIENT_PRIVILEGE ) , errmsg ( "permission denied to set parameter \"%s\"" , name ) ) ) ; } } } if ( ! resetall ) { struct config_generic * record ; record = find_option ( name , false , false , ERROR ) ; Assert ( record != NULL ) ; if ( ( record -> context == PGC_INTERNAL ) || ( record -> flags & GUC_DISALLOW_IN_FILE ) || ( record -> flags & GUC_DISALLOW_IN_AUTO_FILE ) ) { ereport ( ERROR , ( errcode ( ERRCODE_CANT_CHANGE_RUNTIME_PARAM ) , errmsg ( "parameter \"%s\" cannot be changed" , name ) ) ) ; } if ( value ) { union config_var_val newval ; void * newextra = NULL ; if ( ! parse_and_validate_value ( record , name , value , PGC_S_FILE , ERROR , & newval , & newextra ) ) { ereport ( ERROR , ( errcode ( ERRCODE_INVALID_PARAMETER_VALUE ) , errmsg ( "invalid value for parameter \"%s\": \"%s\"" , name , value ) ) ) ; } if ( record -> vartype == PGC_STRING && newval . stringval != NULL ) { guc_free ( newval . stringval ) ; } guc_free ( newextra ) ; if ( strchr ( value , '\n' ) ) { ereport ( ERROR , ( errcode ( ERRCODE_INVALID_PARAMETER_VALUE ) , errmsg ( "parameter value for ALTER SYSTEM must not contain a newline" ) ) ) ; } } } snprintf ( AutoConfFileName , sizeof ( AutoConfFileName ) , "%s" , PG_AUTOCONF_FILENAME ) ; snprintf ( AutoConfTmpFileName , sizeof ( AutoConfTmpFileName ) , "%s.%s" , AutoConfFileName , "tmp" ) ; LWLockAcquire ( AutoFileLock , LW_EXCLUSIVE ) ; if ( ! resetall ) { struct stat st ; if ( stat ( AutoConfFileName , & st ) == 0 ) { FILE * infile ; infile = AllocateFile ( AutoConfFileName , "r" ) ; if ( infile == NULL ) { ereport ( ERROR , ( errcode_for_file_access ( ) , errmsg ( "could not open file \"%s\": %m" , AutoConfFileName ) ) ) ; } if ( ! ParseConfigFp ( infile , AutoConfFileName , CONF_FILE_START_DEPTH , LOG , & head , & tail ) ) { ereport ( ERROR , ( errcode ( ERRCODE_CONFIG_FILE_ERROR ) , errmsg ( "could not parse contents of file \"%s\"" , AutoConfFileName ) ) ) ; } FreeFile ( infile ) ; } replace_auto_config_value ( & head , & tail , name , value ) ; } InvokeObjectPostAlterHookArgStr ( ParameterAclRelationId , name , ACL_ALTER_SYSTEM , altersysstmt -> setstmt -> kind , false ) ; Tmpfd = BasicOpenFile ( AutoConfTmpFileName , O_CREAT | O_RDWR | O_TRUNC ) ; if ( Tmpfd < 0 ) { ereport ( ERROR , ( errcode_for_file_access ( ) , errmsg ( "could not open file \"%s\": %m" , AutoConfTmpFileName ) ) ) ; } PG_TRY ( ) ; { write_auto_conf_file ( Tmpfd , AutoConfTmpFileName , head ) ; close ( Tmpfd ) ; Tmpfd = - 1 ; durable_rename ( AutoConfTmpFileName , AutoConfFileName , ERROR ) ; } PG_CATCH ( ) ; { if ( Tmpfd >= 0 ) { close ( Tmpfd ) ; } ( void ) unlink ( AutoConfTmpFileName ) ; PG_RE_THROW ( ) ; } PG_END_TRY ( ) ; FreeConfigVariables ( head ) ; LWLockRelease ( AutoFileLock ) ; } 