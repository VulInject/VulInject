static enum pkcs11_rc unwrap_rsa_aes_key ( struct active_processing * proc , void * data , uint32_t data_sz , void * * out_buf , uint32_t * out_sz ) { enum pkcs11_rc rc = PKCS11_CKR_OK ; int mbedtls_rc = 0 ; TEE_Result res = TEE_ERROR_GENERIC ; TEE_OperationInfo info = { } ; struct rsa_aes_key_wrap_processing_ctx * ctx = proc -> extra_ctx ; mbedtls_nist_kw_context kw_ctx = { } ; uint8_t aes_key_value [ 32 ] { } ; ; size_t aes_key_size = ctx -> aes_key_bits / 8 ; uint32_t wrapped_key_size = 0 ; int rsa_key_size = 0 ; size_t target_key_size = 0 ; if ( ctx -> aes_key_bits != 128 && ctx -> aes_key_bits != 192 && ctx -> aes_key_bits != 256 ) { return PKCS11_CKR_ARGUMENTS_BAD ; } TEE_GetOperationInfo ( proc -> tee_op_handle , & info ) ; rsa_key_size = info . keySize / 8 ; wrapped_key_size = data_sz - rsa_key_size ; target_key_size = wrapped_key_size - 8 ; * out_buf = TEE_Malloc ( target_key_size , TEE_MALLOC_FILL_ZERO ) ; if ( ! * out_buf ) { return PKCS11_CKR_DEVICE_MEMORY ; } mbedtls_nist_kw_init ( & kw_ctx ) ; res = TEE_AsymmetricDecrypt ( proc -> tee_op_handle , NULL , 0 , data , rsa_key_size , aes_key_value , & aes_key_size ) ; if ( res ) { rc = tee2pkcs_error ( res ) ; out } mbedtls_rc = mbedtls_nist_kw_setkey ( & kw_ctx , MBEDTLS_CIPHER_ID_AES , aes_key_value , ctx -> aes_key_bits , false ) ; if ( mbedtls_rc ) { rc = PKCS11_CKR_WRAPPED_KEY_INVALID ; out } mbedtls_rc = mbedtls_nist_kw_unwrap ( & kw_ctx , MBEDTLS_KW_MODE_KWP , ( uint8_t * ) data + rsa_key_size , wrapped_key_size , * out_buf , & target_key_size , target_key_size ) ; if ( mbedtls_rc ) { rc = PKCS11_CKR_WRAPPED_KEY_INVALID ; out } * out_sz = target_key_size ; out TEE_MemFill ( aes_key_value , 0 , aes_key_size ) ; mbedtls_nist_kw_free ( & kw_ctx ) ; return rc ; } 