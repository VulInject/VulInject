static irqreturn_t __imx_uart_rxint ( int irq , void * dev_id ) { struct imx_port * sport = dev_id ; struct tty_port * port = & sport -> port . state -> port ; u32 usr2 , rx ; usr2 = imx_uart_readl ( sport , USR2 ) ; if ( usr2 & USR2_RDR ) { imx_uart_check_flood ( sport , usr2 ) ; } while ( ( rx = imx_uart_readl ( sport , URXD0 ) ) & URXD_CHARRDY ) { int flg = TTY_NORMAL ; sport -> port . icount . rx ++ ; if ( unlikely ( rx & URXD_ERR ) ) { if ( rx & URXD_BRK ) { sport -> port . icount . brk ++ ; if ( uart_handle_break ( & sport -> port ) ) { continue ; } } if ( rx & URXD_PRERR ) { sport -> port . icount . parity ++ ; } if ( rx & URXD_FRMERR ) { sport -> port . icount . frame ++ ; } if ( rx & URXD_OVRRUN ) { sport -> port . icount . overrun ++ ; } if ( rx & sport -> port . ignore_status_mask ) { continue ; } rx &= ( sport -> port . read_status_mask | 0xFF ) ; if ( rx & URXD_BRK ) { flg = TTY_BREAK ; } if ( rx & URXD_PRERR ) { flg = TTY_PARITY ; } if ( rx & URXD_FRMERR ) { flg = TTY_FRAME ; } if ( rx & URXD_OVRRUN ) { flg = TTY_OVERRUN ; } sport -> port . sysrq = 0 ; } if ( uart_handle_sysrq_char ( & sport -> port , ( unsigned char ) rx ) ) { continue ; } if ( sport -> port . ignore_status_mask & URXD_DUMMY_READ ) { continue ; } if ( tty_insert_flip_char ( port , rx , flg ) == 0 ) { sport -> port . icount . buf_overrun ++ ; } } tty_flip_buffer_push ( port ) ; return IRQ_HANDLED ; } 