static data_for_each_cmd_t _populate_methods ( const char * key , const data_t * data , void * arg ) { populate_methods_t * args = arg ; populate_methods_t nargs = * args ; entry_method_t * method = args -> method ; const data_t * para ; int count = 0 ; entry_t * entry ; http_request_method_t method_type = get_http_method ( key ) ; if ( method_type == HTTP_REQUEST_INVALID ) { return DATA_FOR_EACH_CONT ; } method -> method = method_type ; if ( data_get_type ( data ) != DATA_TYPE_DICT ) { fatal ( "%s: unexpected data type %s instead of dictionary" , __func__ , data_type_to_string ( data_get_type ( data ) ) ) ; } for ( entry = args -> entries ; entry -> type ; entry ++ ) { count ++ ; } if ( ! method -> entries ) { method -> entries = xcalloc ( ( count + 1 ) , sizeof ( entry_t ) ) ; entry_t * dest = method -> entries ; for ( entry_t * src = args -> entries ; src -> type ; src ++ ) { dest -> entry = xstrdup ( src -> entry ) ; dest -> name = xstrdup ( src -> name , NULL ) ; dest -> type = src -> type ; dest -> parameter = src -> parameter ; dest ++ ; } } nargs . entries = method -> entries ; para = data_key_get_const ( data , "parameters" ) ; if ( ! para ) { args -> method ++ ; return DATA_FOR_EACH_CONT ; } if ( data_get_type ( para ) != DATA_TYPE_LIST ) { return DATA_FOR_EACH_FAIL ; } if ( data_list_for_each_const ( para , _populate_parameters , & nargs ) < 0 ) { return DATA_FOR_EACH_FAIL ; } args -> method ++ ; if ( get_log_level ( ) >= LOG_LEVEL_DEBUG5 ) { for ( entry = method -> entries ; entry -> type ; entry ++ ) { debug5 ( "%s: add method:%s for path tag:%d entry:%s name:%s parameter:%s entry_type:%s" , __func__ , key , args -> path -> tag , entry -> entry , entry -> name , openapi_type_to_string ( entry -> parameter ) , _get_entry_type_string ( entry -> type ) ) ; } } return DATA_FOR_EACH_CONT ; } 