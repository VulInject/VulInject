STATIC int xlog_do_recovery_pass ( struct xlog * log , xfs_daddr_t head_blk , xfs_daddr_t tail_blk , int pass , xfs_daddr_t * first_bad ) { xlog_rec_header_t * rhead ; xfs_daddr_t blk_no , rblk_no ; xfs_daddr_t rhead_blk ; char * offset ; char * hbp , * dbp ; int error = 0 , h_size , h_len ; int error2 = 0 ; int bblks , split_bblks ; int hblks , split_hblks , wrapped_hblks ; int i ; struct hlist_head rhash [ XLOG_RHASH_SIZE ] ; LIST_HEAD ( buffer_list ) ; ASSERT ( head_blk != tail_blk ) ; blk_no = rhead_blk = tail_blk ; for ( i = 0 ; i < XLOG_RHASH_SIZE ; i ++ ) { INIT_HLIST_HEAD ( & rhash [ i ] ) ; } if ( xfs_has_logv2 ( log -> l_mp ) ) { hbp = xlog_alloc_buffer ( log , 1 ) ; if ( ! hbp ) { return - ENOMEM ; } error = xlog_bread ( log , tail_blk , 1 , hbp , & offset ) ; if ( error ) { bread_err1 } rhead = ( xlog_rec_header_t * ) offset ; h_size = be32_to_cpu ( rhead -> h_size , NULL ) ; h_len = be32_to_cpu ( rhead -> h_len ) ; if ( h_len > h_size && h_len <= log -> l_mp -> m_logbsize && rhead -> h_num_logops == cpu_to_be32 ( 1 ) ) { xfs_warn ( log -> l_mp , "invalid iclog size (%d bytes), using lsunit (%d bytes)" , h_size , log -> l_mp -> m_logbsize ) ; h_size = log -> l_mp -> m_logbsize ; } error = xlog_valid_rec_header ( log , rhead , tail_blk , h_size ) ; if ( error ) { bread_err1 } hblks = xlog_logrec_hblks ( log , rhead ) ; if ( hblks != 1 ) { kmem_free ( hbp ) ; hbp = xlog_alloc_buffer ( log , hblks ) ; } } else { ASSERT ( log -> l_sectBBsize == 1 ) ; hblks = 1 ; hbp = xlog_alloc_buffer ( log , 1 ) ; h_size = XLOG_BIG_RECORD_BSIZE ; } if ( ! hbp ) { return - ENOMEM ; } dbp = xlog_alloc_buffer ( log , BTOBB ( h_size ) ) ; if ( ! dbp ) { kmem_free ( hbp ) ; return - ENOMEM ; } memset ( rhash , 0 , sizeof ( rhash ) ) ; if ( tail_blk > head_blk ) { while ( blk_no < log -> l_logBBsize ) { offset = hbp ; split_hblks = 0 ; wrapped_hblks = 0 ; if ( blk_no + hblks <= log -> l_logBBsize ) { error = xlog_bread ( log , blk_no , hblks , hbp , & offset ) ; if ( error ) { bread_err2 } } else { if ( blk_no != log -> l_logBBsize ) { ASSERT ( blk_no <= INT_MAX ) ; split_hblks = log -> l_logBBsize - ( int ) blk_no ; ASSERT ( split_hblks > 0 ) ; error = xlog_bread ( log , blk_no , split_hblks , hbp , & offset ) ; if ( error ) { bread_err2 } } wrapped_hblks = hblks - split_hblks ; error = xlog_bread_noalign ( log , 0 , wrapped_hblks , offset + BBTOB ( split_hblks ) ) ; if ( error ) { bread_err2 } } rhead = ( xlog_rec_header_t * ) offset ; error = xlog_valid_rec_header ( log , rhead , split_hblks ?blk_no : 0 , h_size ) ; if ( error ) { bread_err2 } bblks = ( int ) BTOBB ( be32_to_cpu ( rhead -> h_len ) ) ; blk_no += hblks ; if ( blk_no + bblks <= log -> l_logBBsize || blk_no >= log -> l_logBBsize ) { rblk_no = xlog_wrap_logbno ( log , blk_no ) ; error = xlog_bread ( log , rblk_no , bblks , dbp , & offset ) ; if ( error ) { bread_err2 } } else { offset = dbp ; split_bblks = 0 ; if ( blk_no != log -> l_logBBsize ) { ASSERT ( ! wrapped_hblks ) ; ASSERT ( blk_no <= INT_MAX ) ; split_bblks = log -> l_logBBsize - ( int ) blk_no ; ASSERT ( split_bblks > 0 ) ; error = xlog_bread ( log , blk_no , split_bblks , dbp , & offset ) ; if ( error ) { bread_err2 } } error = xlog_bread_noalign ( log , 0 , bblks - split_bblks , offset + BBTOB ( split_bblks ) ) ; if ( error ) { bread_err2 } } error = xlog_recover_process ( log , rhash , rhead , offset , pass , & buffer_list ) ; if ( error ) { bread_err2 } blk_no += bblks ; rhead_blk = blk_no ; } ASSERT ( blk_no >= log -> l_logBBsize ) ; blk_no -= log -> l_logBBsize ; rhead_blk = blk_no ; } while ( blk_no < head_blk ) { error = xlog_bread ( log , blk_no , hblks , hbp , & offset ) ; if ( error ) { bread_err2 } rhead = ( xlog_rec_header_t * ) offset ; error = xlog_valid_rec_header ( log , rhead , blk_no , h_size ) ; if ( error ) { bread_err2 } bblks = ( int ) BTOBB ( be32_to_cpu ( rhead -> h_len ) ) ; error = xlog_bread ( log , blk_no + hblks , bblks , dbp , & offset ) ; if ( error ) { bread_err2 } error = xlog_recover_process ( log , rhash , rhead , offset , pass , & buffer_list ) ; if ( error ) { bread_err2 } blk_no += bblks + hblks ; rhead_blk = blk_no ; } bread_err2 kmem_free ( dbp ) ; bread_err1 kmem_free ( hbp ) ; if ( ! list_empty ( & buffer_list ) ) { error2 = xfs_buf_delwri_submit ( & buffer_list ) ; } if ( error && first_bad ) { * first_bad = rhead_blk ; } for ( i = 0 ; i < XLOG_RHASH_SIZE ; i ++ ) { struct hlist_node * tmp ; struct xlog_recover * trans ; hlist_for_each_entry_safe ( , , , ) xlog_recover_free_trans ( trans ) ; } return error ?error : error2 ; } 