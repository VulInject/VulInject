int update_phtable ( presentity_t * presentity , str * pres_uri , str * body ) { char * sphere = NULL ; unsigned int hash_code ; pres_entry_t * p ; int ret ; str * xcap_doc = NULL ; sphere = extract_sphere ( body ) ; if ( sphere == NULL ) { LM_DBG ( "no sphere defined in new body\n" ) ; return 0 ; } hash_code = core_case_hash ( pres_uri , NULL , phtable_size ) ; lock_get ( & pres_htable [ hash_code ] . lock ) ; p = search_phtable ( pres_uri , presentity -> event -> evp -> type , hash_code ) ; if ( p == NULL ) { lock_release ( & pres_htable [ hash_code ] . lock ) ; done } if ( p -> sphere ) { if ( strcmp ( p -> sphere , sphere ) != 0 ) { shm_free ( p -> sphere ) ; } else { lock_release ( & pres_htable [ hash_code ] . lock ) ; pkg_free ( sphere ) ; return 0 ; } } p -> sphere = ( char * ) shm_malloc ( ( strlen ( sphere ) + 1 ) * sizeof ( char ) ) ; if ( p -> sphere == NULL ) { lock_release ( & pres_htable [ hash_code ] . lock ) ; ret = - 1 ; done } strcpy ( p -> sphere , sphere ) ; lock_release ( & pres_htable [ hash_code ] . lock ) ; if ( presentity -> event -> get_rules_doc ( & presentity -> user , & presentity -> domain , & xcap_doc ) < 0 ) { LM_ERR ( "failed to retrieve xcap document\n" ) ; ret = - 1 ; done } update_watchers_status ( pres_uri , presentity -> event , xcap_doc ) ; done if ( xcap_doc ) { if ( xcap_doc -> s ) { pkg_free ( xcap_doc -> s ) ; } pkg_free ( xcap_doc ) ; } if ( sphere ) { pkg_free ( sphere ) ; } return ret ; } 