static file_action_t decide_file_action ( file_entry_t * entry ) { const char * path = entry -> path ; if ( check_file_excluded ( path , true ) ) { if ( entry -> target_exists ) { return FILE_ACTION_REMOVE ; } else { return FILE_ACTION_NONE ; } } if ( ! entry -> target_exists && entry -> source_exists ) { switch ( entry -> source_type ) { case FILE_TYPE_DIRECTORY : case FILE_TYPE_SYMLINK : return FILE_ACTION_CREATE ; case FILE_TYPE_REGULAR : return FILE_ACTION_COPY ; case FILE_TYPE_UNDEFINED : pg_fatal ( "unknown file type for \"%s\"" , entry -> path ) ; break ; } } if ( entry -> target_exists && ! entry -> source_exists ) { return FILE_ACTION_REMOVE ; } if ( ! entry -> target_exists && ! entry -> source_exists ) { Assert ( false ) ; return FILE_ACTION_NONE ; } Assert ( entry -> target_exists && entry -> source_exists ) ; if ( entry -> source_type != entry -> target_type ) { pg_fatal ( "file \"%s\" is of different type in source and target" , entry -> path ) ; } if ( pg_str_endswith ( entry -> path , "PG_VERSION" ) ) { return FILE_ACTION_NONE ; } switch ( entry -> source_type ) { case FILE_TYPE_DIRECTORY : return FILE_ACTION_NONE ; case FILE_TYPE_SYMLINK : return FILE_ACTION_NONE ; case FILE_TYPE_REGULAR : if ( ! entry -> isrelfile ) { return FILE_ACTION_COPY ; } else { if ( entry -> target_size < entry -> source_size ) { return FILE_ACTION_COPY_TAIL ; } if ( entry -> target_size > entry -> source_size ) { return FILE_ACTION_TRUNCATE ; } else { return FILE_ACTION_NONE ; } } break ; case FILE_TYPE_UNDEFINED : pg_fatal ( "unknown file type for \"%s\"" , path ) ; break ; } pg_fatal ( "could not decide what to do with file \"%s\"" , path ) ; } 