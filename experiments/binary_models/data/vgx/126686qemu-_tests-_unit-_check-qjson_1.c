static void escaped_string ( void ) { { const char * json_in ; const char * utf8_out ; int skip ; } , test_cases [ ] { { "\\b\\f\\n\\r\\t\\\\\\\"" "\b\f\n\r\t\\\"" } { "\\/\\'" "/'" . skip = 1 } { "single byte utf-8 \\u0020" "single byte utf-8  " . skip = 1 } { "double byte utf-8 \\u00A2" "double byte utf-8 \xc2\xa2" } { "triple byte utf-8 \\u20AC" "triple byte utf-8 \xe2\x82\xac" } { "quadruple byte utf-8 \\uD834\\uDD1E" "quadruple byte utf-8 \xF0\x9D\x84\x9E" } { "\\" NULL } { "\\z" NULL } { "\\ux" NULL } { "\\u1x" NULL } { "\\u12x" NULL } { "\\u123x" NULL } { "\\u12345" "\341\210\2645" } { "\\u0000x" "\xC0\x80x" } { "unpaired leading surrogate \\uD800" NULL } { "unpaired leading surrogate \\uD800\\uCAFE" NULL } { "unpaired leading surrogate \\uD800\\uD801\\uDC02" NULL } { "unpaired trailing surrogate \\uDC00" NULL } { "backward surrogate pair \\uDC00\\uD800" NULL } { "noncharacter U+FDD0 \\uFDD0" NULL } { "noncharacter U+FDEF \\uFDEF" NULL } { "noncharacter U+1FFFE \\uD87F\\uDFFE" NULL } { "noncharacter U+10FFFF \\uDC3F\\uDFFF" NULL } { } } ; int i , j ; QString * cstr ; char * jstr ; for ( i = 0 ; test_cases [ i ] . json_in ; i ++ ) { for ( j = 0 ; j < 2 ; j ++ ) { if ( test_cases [ i ] . utf8_out ) { cstr = from_json_str ( test_cases [ i ] . json_in , j , & error_abort ) ; g_assert_cmpstr ( qstring_get_str ( cstr ) , == , test_cases [ i ] . utf8_out ) ; if ( ! test_cases [ i ] . skip ) { jstr = to_json_str ( cstr ) ; g_assert_cmpstr ( jstr , == , test_cases [ i ] . json_in ) ; } qobject_unref ( cstr ) ; } else { cstr = from_json_str ( test_cases [ i ] . json_in , j , NULL ) ; g_assert ( ! cstr ) ; } } } } 