static int tcf_pedit_init ( struct net * net , struct nlattr * nla , struct nlattr * est , struct tc_action * * a , int ovr , int bind ) { struct tc_action_net * tn = net_generic ( net , pedit_net_id ) ; struct nlattr * tb [ TCA_PEDIT_MAX + 1 ] ; struct nlattr * pattr ; struct tc_pedit * parm ; int ret = 0 , err ; struct tcf_pedit * p ; struct tc_pedit_key * keys = NULL ; struct tcf_pedit_key_ex * keys_ex ; int ksize ; if ( nla == NULL ) { return - EINVAL ; } err = nla_parse_nested ( tb , TCA_PEDIT_MAX , nla , pedit_policy , NULL ) ; if ( err < 0 ) { return err ; } pattr = tb [ TCA_PEDIT_PARMS ] ; if ( ! pattr ) { pattr = tb [ TCA_PEDIT_PARMS_EX ] ; } if ( ! pattr ) { return - EINVAL ; } parm = nla_data ( pattr ) ; ksize = parm -> nkeys * sizeof ( tc_pedit_key ) ; if ( nla_len ( pattr ) < sizeof ( * parm ) + ksize ) { return - EINVAL ; } keys_ex = tcf_pedit_keys_ex_parse ( tb [ TCA_PEDIT_KEYS_EX ] , parm -> nkeys ) ; if ( IS_ERR ( keys_ex ) ) { return PTR_ERR ( keys_ex ) ; } if ( ! tcf_hash_check ( tn , parm -> index , a , bind ) ) { if ( ! parm -> nkeys ) { return - EINVAL ; } ret = tcf_hash_create ( tn , parm -> index , est , a , & act_pedit_ops , bind , false ) ; if ( ret ) { return ret ; } p = to_pedit ( * a ) ; keys = kmalloc ( ksize , GFP_KERNEL ) ; if ( keys == NULL ) { tcf_hash_cleanup ( * a , est ) ; return - ENOMEM ; } ret = ACT_P_CREATED ; } else { if ( bind ) { return 0 ; } tcf_hash_release ( * a , bind ) ; if ( ! ovr ) { return - EEXIST ; } p = to_pedit ( * a ) ; if ( p -> tcfp_nkeys && p -> tcfp_nkeys != parm -> nkeys ) { keys = kmalloc ( ksize , GFP_KERNEL ) ; if ( ! keys ) { kfree ( keys_ex ) ; return - ENOMEM ; } } } spin_lock_bh ( & p -> tcf_lock ) ; p -> tcfp_flags = parm -> flags ; p -> tcf_action = parm -> action ; if ( keys ) { kfree ( p -> tcfp_keys ) ; p -> tcfp_keys = keys ; p -> tcfp_nkeys = parm -> nkeys ; } memcpy ( p -> tcfp_keys , parm -> keys , ksize ) ; kfree ( p -> tcfp_keys_ex ) ; p -> tcfp_keys_ex = keys_ex ; spin_unlock_bh ( & p -> tcf_lock ) ; if ( ret == ACT_P_CREATED ) { tcf_hash_insert ( tn , * a ) ; } return ret ; } 