int crypto_digest_key_prov ( crypto_context_t context , crypto_key_t * key , crypto_call_req_t * cr ) { crypto_ctx_t * ctx = ( crypto_ctx_t * ) context ; kcf_context_t * kcf_ctx ; kcf_provider_desc_t * pd ; int error ; kcf_req_params_t params ; if ( ( ctx == NULL ) || ( ( kcf_ctx = ( kcf_context_t * ) ctx -> cc_framework_private ) == NULL ) || ( ( pd = kcf_ctx -> kc_prov_desc ) == NULL ) ) { return ( CRYPTO_INVALID_CONTEXT ) ; } ASSERT ( pd -> pd_prov_type != CRYPTO_LOGICAL_PROVIDER ) ; if ( CHECK_FASTPATH ( cr , pd ) ) { error = KCF_PROV_DIGEST_KEY ( pd , ctx , key , NULL ) ; KCF_PROV_INCRSTATS ( pd , error ) ; } else { KCF_WRAP_DIGEST_OPS_PARAMS ( & params , KCF_OP_DIGEST_KEY , ctx -> cc_session , key , NULL , NULL ) ; error = kcf_submit_request ( pd , ctx , cr , & params , B_FALSE ) ; } return ( error ) ; } 