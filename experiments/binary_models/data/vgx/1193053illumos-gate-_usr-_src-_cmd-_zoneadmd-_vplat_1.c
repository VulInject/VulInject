static int add_net_for_linkid ( zlog_t * zlogp , zoneid_t zoneid , zone_addr_list_t * start ) { struct lifreq lifr ; char * * astr , * address ; dladm_status_t dlstatus ; char * ip_nospoof = "ip-nospoof" ; int nnet , naddr , err = 0 , j ; size_t zlen , cpleft ; zone_addr_list_t * ptr , * end ; char tmp [ INET6_ADDRSTRLEN ] , * maskstr ; char * zaddr , * cp ; struct in6_addr * routes = NULL ; boolean_t is_set ; datalink_id_t linkid ; assert ( start != NULL ) ; naddr = 0 ; nnet = 0 ; linkid = start -> za_linkid ; for ( ptr = start ; ptr != NULL && ptr -> za_linkid == linkid ; ptr = ptr -> za_next ) { nnet ++ ; } end = ptr ; zlen = nnet * ( INET6_ADDRSTRLEN + 1 ) ; astr = calloc ( 1 , nnet * sizeof ( uintptr_t ) ) ; zaddr = calloc ( 1 , zlen ) ; if ( astr == NULL || zaddr == NULL ) { err = ENOMEM ; done } cp = zaddr ; cpleft = zlen ; j = 0 ; for ( ptr = start ; ptr != end ; ptr = ptr -> za_next ) { address = ptr -> za_nwiftab . zone_nwif_allowed_address ; if ( address [ 0 ] == '\0' ) { continue ; } ( void ) snprintf ( tmp , sizeof ( tmp ) , "%s" , address ) ; if ( zonecfg_valid_net_address ( address , & lifr ) != Z_OK ) { zerror ( zlogp , B_FALSE , "invalid address [%s]\n" , address ) ; err = EINVAL ; done } if ( ! sockaddr_to_str ( lifr . lifr_addr . ss_family , ( const sockaddr * ) & lifr . lifr_addr , cp , cpleft ) ) { err = EINVAL ; done } astr [ j ] = strdup ( cp ) ; if ( astr [ j ] == NULL ) { err = ENOMEM ; done } j ++ ; if ( ( maskstr = strchr ( tmp , '/' ) ) == NULL ) { int prefixlen ; if ( lifr . lifr_addr . ss_family == AF_INET ) { prefixlen = ipv4_prefixlen ( SIN ( & lifr . lifr_addr ) ) ; } else { struct sockaddr_in6 * sin6 ; sin6 = SIN6 ( & lifr . lifr_addr ) ; if ( IN6_IS_ADDR_LINKLOCAL ( & sin6 -> sin6_addr ) ) { prefixlen = 10 ; } else { prefixlen = 64 ; } } ( void ) snprintf ( tmp , sizeof ( tmp ) , "%d" , prefixlen ) ; maskstr = tmp ; } else { maskstr ++ ; } ( void ) strlcat ( cp , "/" , cpleft ) ; ( void ) strlcat ( cp , maskstr , cpleft ) ; ( void ) strlcat ( cp , "," , cpleft ) ; cp += strnlen ( cp , zlen ) ; cpleft = & zaddr [ INET6_ADDRSTRLEN ] - cp ; } naddr = j ; assert ( naddr <= nnet ) ; if ( j == 0 ) { done } zaddr [ strnlen ( zaddr , zlen ) - 1 ] = '\0' ; dlstatus = dladm_linkprop_is_set ( dld_handle , linkid , DLADM_OPT_ACTIVE , "protection" , & is_set ) ; if ( dlstatus != DLADM_STATUS_OK ) { err = EINVAL ; zerror ( zlogp , B_FALSE , "unable to check if protection is set" ) ; done } if ( is_set ) { err = EINVAL ; zerror ( zlogp , B_FALSE , "Protection is already set" ) ; done } dlstatus = dladm_linkprop_is_set ( dld_handle , linkid , DLADM_OPT_ACTIVE , "allowed-ips" , & is_set ) ; if ( dlstatus != DLADM_STATUS_OK ) { err = EINVAL ; zerror ( zlogp , B_FALSE , "unable to check if allowed-ips is set" ) ; done } if ( is_set ) { zerror ( zlogp , B_FALSE , "allowed-ips is already set" ) ; err = EINVAL ; done } dlstatus = dladm_set_linkprop ( dld_handle , linkid , "protection" , & ip_nospoof , 1 , DLADM_OPT_ACTIVE ) ; if ( dlstatus != DLADM_STATUS_OK ) { zerror ( zlogp , B_FALSE , "could not set protection\n" ) ; err = EINVAL ; done } dlstatus = dladm_set_linkprop ( dld_handle , linkid , "allowed-ips" , astr , naddr , DLADM_OPT_ACTIVE ) ; if ( dlstatus != DLADM_STATUS_OK ) { zerror ( zlogp , B_FALSE , "could not set allowed-ips\n" ) ; err = EINVAL ; done } err = zone_setattr_network ( ZONE_NETWORK_ADDRESS , zoneid , linkid , zaddr , strnlen ( zaddr , zlen ) + 1 ) ; if ( err != 0 ) { done } routes = calloc ( 1 , nnet * sizeof ( * routes ) ) ; j = 0 ; for ( ptr = start ; ptr != end ; ptr = ptr -> za_next ) { address = ptr -> za_nwiftab . zone_nwif_defrouter ; if ( address [ 0 ] == '\0' ) { continue ; } if ( strchr ( address , '/' ) == NULL && strchr ( address , ':' ) != 0 ) { ( void ) snprintf ( tmp , sizeof ( tmp ) , "/%d" , V6_ADDR_LEN ) ; ( void ) strlcat ( address , tmp , INET6_ADDRSTRLEN ) ; } if ( zonecfg_valid_net_address ( address , & lifr ) != Z_OK ) { zerror ( zlogp , B_FALSE , "invalid router [%s]\n" , address ) ; err = EINVAL ; done } if ( lifr . lifr_addr . ss_family == AF_INET6 ) { routes [ j ] = SIN6 ( & lifr . lifr_addr ) -> sin6_addr ; } else { IN6_INADDR_TO_V4MAPPED ( & SIN ( & lifr . lifr_addr ) -> sin_addr , & routes [ j ] ) ; } j ++ ; } assert ( j <= nnet ) ; if ( j > 0 ) { err = zone_setattr_network ( ZONE_NETWORK_DEFROUTER , zoneid , linkid , routes , j * sizeof ( * routes ) ) ; } done for ( j = 0 ; j < naddr ; j ++ ) { free ( astr [ j ] ) ; } free ( astr ) ; free ( zaddr ) ; return ( err ) ; } 