static int efx_test_loopbacks ( struct efx_nic * efx , struct efx_self_tests * tests , unsigned int loopback_modes ) { enum efx_loopback_mode mode ; struct efx_loopback_state * state ; struct efx_channel * channel = efx_get_channel ( efx , efx -> tx_channel_offset ) ; struct efx_tx_queue * tx_queue ; int rc = 0 ; state = kzalloc ( sizeof ( * state ) , GFP_KERNEL ) ; if ( state == NULL ) { return - ENOMEM ; } BUG_ON ( efx -> loopback_selftest ) ; state -> flush = true ; efx -> loopback_selftest = state ; for ( mode = LOOPBACK_NONE ; mode <= LOOPBACK_TEST_MAX ; mode ++ ) { if ( ! ( loopback_modes & ( 1 << mode ) ) ) { continue ; } state -> flush = true ; mutex_lock ( & efx -> mac_lock ) ; efx -> loopback_mode = mode ; rc = __efx_reconfigure_port ( efx ) ; mutex_unlock ( & efx -> mac_lock ) ; if ( rc ) { netif_err ( efx , drv , efx -> net_dev , "unable to move into %s loopback\n" , LOOPBACK_MODE ( efx ) ) ; out } rc = efx_wait_for_link ( efx ) ; if ( rc ) { netif_err ( efx , drv , efx -> net_dev , "loopback %s never came up\n" , LOOPBACK_MODE ( efx ) ) ; out } efx_for_each_channel_tx_queue ( , ) { state -> offload_csum = ( tx_queue -> type & EFX_TXQ_TYPE_OUTER_CSUM ) ; rc = efx_test_loopback ( tx_queue , & tests -> loopback [ mode ] ) ; if ( rc ) { out } } } out state -> flush = true ; wmb ( ) ; kfree ( state ) ; if ( rc == - EPERM ) { rc = 0 ; } return rc ; } 