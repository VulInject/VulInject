static int process_upcall ( struct udpif * udpif , struct upcall * upcall , struct ofpbuf * odp_actions , struct flow_wildcards * wc ) { const struct dp_packet * packet = upcall -> packet ; const struct flow * flow = upcall -> flow ; size_t actions_len = 0 ; switch ( upcall -> type ) { case MISS_UPCALL : case SLOW_PATH_UPCALL : upcall_xlate ( udpif , upcall , odp_actions , wc ) ; return 0 ; case SFLOW_UPCALL : if ( upcall -> sflow ) { struct dpif_sflow_actions sflow_actions ; actions_len = dpif_read_actions ( udpif , upcall , flow , upcall -> type , & sflow_actions ) ; dpif_sflow_received ( upcall -> sflow , packet , flow , flow -> in_port . odp_port , & upcall -> cookie , actions_len > 0 ?& sflow_actions : NULL ) ; } break ; case IPFIX_UPCALL : case FLOW_SAMPLE_UPCALL : if ( upcall -> ipfix ) { struct flow_tnl output_tunnel_key ; struct dpif_ipfix_actions ipfix_actions ; memset ( & ipfix_actions , 0 , sizeof ipfix_actions ) ; if ( upcall -> out_tun_key ) { odp_tun_key_from_attr ( upcall -> out_tun_key , & output_tunnel_key , NULL ) ; } actions_len = dpif_read_actions ( udpif , upcall , flow , upcall -> type , & ipfix_actions ) ; if ( upcall -> type == IPFIX_UPCALL ) { dpif_ipfix_bridge_sample ( upcall -> ipfix , packet , flow , flow -> in_port . odp_port , upcall -> cookie . ipfix . output_odp_port , upcall -> out_tun_key ?& output_tunnel_key : NULL , actions_len > 0 ?& ipfix_actions : NULL ) ; } else { dpif_ipfix_flow_sample ( upcall -> ipfix , packet , flow , & upcall -> cookie , flow -> in_port . odp_port , upcall -> out_tun_key ?& output_tunnel_key : NULL , actions_len > 0 ?& ipfix_actions : NULL ) ; } } break ; case CONTROLLER_UPCALL : { struct user_action_cookie * cookie = & upcall -> cookie ; if ( cookie -> controller . dont_send ) { return 0 ; } uint32_t recirc_id = cookie -> controller . recirc_id ; if ( ! recirc_id ) { break ; } const struct recirc_id_node * recirc_node = recirc_id_node_find ( recirc_id ) ; if ( ! recirc_node ) { break ; } const struct frozen_state * state = & recirc_node -> state ; struct ofproto_async_msg * am = xmalloc ( sizeof am ) ; * am = ( ofproto_async_msg ) { . controller_id = cookie -> controller . controller_id . oam = OAM_PACKET_IN . pin = { . up = { . base = { . packet = xmemdup ( dp_packet_data ( packet ) , dp_packet_size ( packet ) ) . packet_len = dp_packet_size ( packet ) . reason = cookie -> controller . reason . table_id = state -> table_id . cookie = get_32aligned_be64 ( & cookie -> controller . rule_cookie ) . userdata = ( recirc_node -> state . userdata_len ? xmemdup ( recirc_node -> state . userdata , recirc_node -> state . userdata_len ) : NULL ) . userdata_len = recirc_node -> state . userdata_len } } . max_len = cookie -> controller . max_len } } ; if ( cookie -> controller . continuation ) { am -> pin . up . stack = ( state -> stack_size ?xmemdup ( state -> stack , state -> stack_size ) : NULL ) , am -> pin . up . stack_size = state -> stack_size , am -> pin . up . mirrors = state -> mirrors , am -> pin . up . conntracked = state -> conntracked , am -> pin . up . actions = ( state -> ofpacts_len ?xmemdup ( state -> ofpacts , state -> ofpacts_len ) : NULL ) , am -> pin . up . actions_len = state -> ofpacts_len , am -> pin . up . action_set = ( state -> action_set_len ?xmemdup ( state -> action_set , state -> action_set_len ) : NULL ) , am -> pin . up . action_set_len = state -> action_set_len , am -> pin . up . bridge = upcall -> ofproto -> uuid ; am -> pin . up . odp_port = upcall -> packet -> md . in_port . odp_port ; } struct flow frozen_flow ; frozen_flow = * flow ; if ( ! state -> conntracked ) { flow_clear_conntrack ( & frozen_flow ) ; } frozen_metadata_to_flow ( & upcall -> ofproto -> up , & state -> metadata , & frozen_flow ) ; flow_get_metadata ( & frozen_flow , & am -> pin . up . base . flow_metadata ) ; ofproto_dpif_send_async_msg ( upcall -> ofproto , am ) ; } break ; case BAD_UPCALL : break ; } return EAGAIN ; } 