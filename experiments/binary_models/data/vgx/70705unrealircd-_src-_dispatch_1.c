void fd_select ( time_t delay ) { struct timeval to ; int num , fd ; fd_set work_read_fds ; fd_set work_write_fds ; fd_set work_except_fds ; memcpy ( & work_read_fds , & read_fds , sizeof ( fd_set ) ) ; memcpy ( & work_write_fds , & write_fds , sizeof ( fd_set ) ) ; memcpy ( & work_except_fds , & write_fds , sizeof ( fd_set ) ) ; to . tv_sec = delay / 1000 ; to . tv_usec = ( delay % 1000 ) * 1000 ; num = select ( highest_fd + 1 , & work_read_fds , & work_write_fds , & work_except_fds , & to ) ; num = select ( highest_fd + 1 , & work_read_fds , & work_write_fds , NULL , & to ) ; if ( num < 0 ) { unreal_log ( ULOG_FATAL , "io" , "SELECT_ERROR" , NULL , "select() returned error ($socket_error) -- SERIOUS TROUBLE!" , log_data_socket_error ( - 1 ) ) ; memcpy ( & work_read_fds , & read_fds , sizeof ( fd_set ) ) ; memcpy ( & work_write_fds , & write_fds , sizeof ( fd_set ) ) ; fd_debug ( & work_read_fds , highest_fd + 1 , "read" ) ; fd_debug ( & work_write_fds , highest_fd + 1 , "write" ) ; Sleep ( 500 ) ; } if ( num <= 0 ) { return ; } for ( fd = 0 ; fd <= highest_fd && num > 0 ; fd ++ ) { FDEntry * fde ; IOCallbackFunc iocb ; int evflags = 0 ; fde = & fd_table [ fd ] ; if ( ! fde -> is_open ) { continue ; } if ( FD_ISSET ( fd , & work_read_fds ) ) { evflags |= FD_SELECT_READ ; } if ( FD_ISSET ( fd , & work_write_fds ) ) { evflags |= FD_SELECT_WRITE ; } if ( FD_ISSET ( fd , & work_except_fds ) ) { evflags |= FD_SELECT_WRITE ; } if ( ! evflags ) { continue ; } if ( evflags & FD_SELECT_READ ) { iocb = fde -> read_callback ; if ( iocb != NULL ) { iocb ( fd , evflags , fde -> data ) ; } } if ( evflags & FD_SELECT_WRITE ) { iocb = fde -> write_callback ; if ( iocb != NULL ) { iocb ( fd , evflags , fde -> data ) ; } } num -- ; } } 