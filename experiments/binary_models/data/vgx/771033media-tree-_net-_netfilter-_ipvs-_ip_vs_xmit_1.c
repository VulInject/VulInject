static struct sk_buff * ip_vs_prepare_tunneled_skb ( struct sk_buff * skb , int skb_af , unsigned int max_headroom , __u8 * next_protocol , __u32 * payload_len , __u8 * dsfield , __u8 * ttl , __be16 * df ) { struct sk_buff * new_skb = NULL ; struct iphdr * old_iph = NULL ; struct ipv6hdr * old_ipv6h = NULL ; ip_vs_drop_early_demux_sk ( skb ) ; if ( skb_headroom ( skb ) < max_headroom || skb_cloned ( skb ) ) { new_skb = skb_realloc_headroom ( skb , max_headroom ) ; if ( ! new_skb ) { error } if ( skb -> sk ) { skb_set_owner_w ( new_skb , skb -> sk ) ; } consume_skb ( skb ) ; skb = new_skb ; } if ( skb_af == AF_INET6 ) { old_ipv6h = ipv6_hdr ( skb ) ; * next_protocol = IPPROTO_IPV6 ; if ( payload_len ) { * payload_len = ntohs ( old_ipv6h -> payload_len ) + sizeof ( * old_ipv6h ) ; } * dsfield = ipv6_get_dsfield ( old_ipv6h ) ; * ttl = old_ipv6h -> hop_limit ; if ( df ) { * df = 0 ; } } else { old_iph = ip_hdr ( skb ) ; if ( df ) { * df = ( old_iph -> frag_off & htons ( IP_DF ) ) ; } * next_protocol = IPPROTO_IPIP ; ip_send_check ( old_iph ) ; * dsfield = ipv4_get_dsfield ( old_iph ) ; * ttl = old_iph -> ttl ; if ( payload_len ) { * payload_len = ntohs ( old_iph -> tot_len ) ; } } return skb ; error return ERR_PTR ( - ENOMEM ) ; } 