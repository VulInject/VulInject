static int imx290_probe ( struct i2c_client * client ) { struct device * dev = & client -> dev ; struct imx290 * imx290 ; int ret ; imx290 = devm_kzalloc ( dev , sizeof ( * imx290 ) , GFP_KERNEL ) ; imx290 -> dev = dev ; imx290 -> regmap = devm_regmap_init_i2c ( client , & imx290_regmap_config ) ; if ( IS_ERR ( imx290 -> regmap ) ) { dev_err ( dev , "Unable to initialize I2C\n" ) ; return - ENODEV ; } ret = imx290_parse_dt ( imx290 ) ; if ( ret ) { return ret ; } imx290 -> xclk = devm_clk_get ( dev , "xclk" ) ; if ( IS_ERR ( imx290 -> xclk ) ) { return dev_err_probe ( dev , PTR_ERR ( imx290 -> xclk ) , "Could not get xclk" ) ; } ret = imx290_get_regulators ( dev , imx290 ) ; if ( ret < 0 ) { return dev_err_probe ( dev , ret , "Cannot get regulators\n" ) ; } imx290 -> rst_gpio = devm_gpiod_get_optional ( dev , "reset" , GPIOD_OUT_HIGH ) ; if ( IS_ERR ( imx290 -> rst_gpio ) ) { return dev_err_probe ( dev , PTR_ERR ( imx290 -> rst_gpio ) , "Cannot get reset gpio\n" ) ; } ret = imx290_init_clk ( imx290 ) ; if ( ret ) { return ret ; } ret = imx290_power_on ( imx290 ) ; if ( ret < 0 ) { dev_err ( dev , "Could not power on the device\n" ) ; return ret ; } pm_runtime_set_active ( dev ) ; pm_runtime_get_noresume ( dev ) ; pm_runtime_enable ( dev ) ; pm_runtime_set_autosuspend_delay ( dev , 1000 ) ; pm_runtime_use_autosuspend ( dev ) ; ret = imx290_subdev_init ( imx290 ) ; if ( ret ) { err_pm } ret = v4l2_async_register_subdev ( & imx290 -> sd ) ; if ( ret < 0 ) { dev_err ( dev , "Could not register v4l2 device\n" ) ; err_subdev } pm_runtime_mark_last_busy ( dev ) ; pm_runtime_put_autosuspend ( dev ) ; return 0 ; err_subdev imx290_subdev_cleanup ( imx290 ) ; err_pm pm_runtime_disable ( dev ) ; pm_runtime_put_noidle ( dev ) ; imx290_power_off ( imx290 ) ; return ret ; } 