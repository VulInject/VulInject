static void zfs_process_add ( zpool_handle_t * zhp , nvlist_t * vdev , boolean_t labeled ) { char * path ; vdev_state_t newstate ; nvlist_t * nvroot , * newvd ; pendingdev_t * device ; uint64_t wholedisk = 0ULL ; uint64_t offline = 0ULL ; uint64_t guid = 0ULL ; char * physpath = NULL , * new_devid = NULL , * enc_sysfs_path = NULL ; char rawpath [ PATH_MAX ] , fullpath [ PATH_MAX ] ; char devpath [ PATH_MAX ] ; int ret ; int is_dm = 0 ; int is_sd = 0 ; uint_t c ; vdev_stat_t * vs ; if ( nvlist_lookup_string ( vdev , ZPOOL_CONFIG_PATH , & path ) != 0 ) { return ; } verify ( nvlist_lookup_uint64_array ( vdev , ZPOOL_CONFIG_VDEV_STATS , ( uint64_t * * ) & vs , & c ) == 0 ) ; if ( vs -> vs_state == VDEV_STATE_HEALTHY ) { zed_log_msg ( LOG_INFO , "%s: %s is already healthy, skip it." , __func__ , path ) ; return ; } ( void ) nvlist_lookup_string ( vdev , ZPOOL_CONFIG_PHYS_PATH , & physpath ) ; ( void ) nvlist_lookup_string ( vdev , ZPOOL_CONFIG_VDEV_ENC_SYSFS_PATH , & enc_sysfs_path ) ; ( void ) nvlist_lookup_uint64 ( vdev , ZPOOL_CONFIG_WHOLE_DISK , & wholedisk ) ; ( void ) nvlist_lookup_uint64 ( vdev , ZPOOL_CONFIG_OFFLINE , & offline ) ; ( void ) nvlist_lookup_uint64 ( vdev , ZPOOL_CONFIG_GUID , & guid ) ; if ( offline ) { return ; } is_dm = zfs_dev_is_dm ( path ) ; zed_log_msg ( LOG_INFO , "zfs_process_add: pool '%s' vdev '%s', phys '%s'" " wholedisk %d, dm %d (%llu)" , zpool_get_name ( zhp ) , path , physpath ?physpath : "NULL" , wholedisk , is_dm , ( long long unsigned int ) guid ) ; if ( guid != 0 ) { ( void ) snprintf ( fullpath , sizeof ( fullpath ) , "%llu" , ( long long unsigned int ) guid ) ; } else { ( void ) strlcpy ( fullpath , path , sizeof ( fullpath ) ) ; if ( wholedisk ) { char * spath = zfs_strip_partition ( fullpath ) ; if ( ! spath ) { zed_log_msg ( LOG_INFO , "%s: Can't alloc" , __func__ ) ; return ; } ( void ) strlcpy ( fullpath , spath , sizeof ( fullpath ) ) ; } } if ( zpool_vdev_online ( zhp , fullpath , ZFS_ONLINE_CHECKREMOVE | ZFS_ONLINE_UNSPARE , & newstate ) == 0 && ( newstate == VDEV_STATE_HEALTHY || newstate == VDEV_STATE_DEGRADED ) ) { zed_log_msg ( LOG_INFO , "  zpool_vdev_online: vdev %s is %s" , fullpath , ( newstate == VDEV_STATE_HEALTHY ) ?"HEALTHY" : "DEGRADED" ) ; return ; } if ( physpath != NULL && strcmp ( "scsidebug" , physpath ) == 0 ) { is_sd = 1 ; } if ( ! zpool_get_prop_int ( zhp , ZPOOL_PROP_AUTOREPLACE , NULL ) || ! ( wholedisk || is_dm ) || ( physpath == NULL ) ) { ( void ) zpool_vdev_online ( zhp , fullpath , ZFS_ONLINE_FORCEFAULT , & newstate ) ; zed_log_msg ( LOG_INFO , "Pool's autoreplace is not enabled or " "not a whole disk for '%s'" , fullpath ) ; return ; } ( void ) snprintf ( rawpath , sizeof ( rawpath ) , "%s%s" , is_sd ?DEV_BYVDEV_PATH : DEV_BYPATH_PATH , physpath ) ; if ( realpath ( rawpath , devpath ) == NULL && ! is_dm ) { zed_log_msg ( LOG_INFO , "  realpath: %s failed (%s)" , rawpath , strerror ( errno ) ) ; ( void ) zpool_vdev_online ( zhp , fullpath , ZFS_ONLINE_FORCEFAULT , & newstate ) ; zed_log_msg ( LOG_INFO , "  zpool_vdev_online: %s FORCEFAULT (%s)" , fullpath , libzfs_error_description ( g_zfshdl ) ) ; return ; } if ( ( vs -> vs_state != VDEV_STATE_DEGRADED ) && ( vs -> vs_state != VDEV_STATE_FAULTED ) && ( vs -> vs_state != VDEV_STATE_CANT_OPEN ) ) { return ; } nvlist_lookup_string ( vdev , "new_devid" , & new_devid ) ; if ( is_dm ) { } if ( ! labeled ) { char * leafname ; leafname = strrchr ( devpath , '/' ) + 1 ; if ( zpool_label_disk ( g_zfshdl , zhp , leafname ) != 0 ) { zed_log_msg ( LOG_INFO , "  zpool_label_disk: could not " "label '%s' (%s)" , leafname , libzfs_error_description ( g_zfshdl ) ) ; ( void ) zpool_vdev_online ( zhp , fullpath , ZFS_ONLINE_FORCEFAULT , & newstate ) ; return ; } device = malloc ( sizeof ( pendingdev_t ) ) ; ( void ) strlcpy ( device -> pd_physpath , physpath , sizeof ( device -> pd_physpath ) ) ; list_insert_tail ( & g_device_list , device ) ; zed_log_msg ( LOG_INFO , "  zpool_label_disk: async '%s' (%llu)" , leafname , ( u_longlong_t ) guid ) ; return ; } else { boolean_t found = B_FALSE ; for ( device = list_head ( & g_device_list ) ; device != NULL ; device = list_next ( & g_device_list , device ) ) { if ( strcmp ( physpath , device -> pd_physpath ) == 0 ) { list_remove ( & g_device_list , device ) ; free ( device ) ; found = B_TRUE ; break ; } zed_log_msg ( LOG_INFO , "zpool_label_disk: %s != %s" , physpath , device -> pd_physpath ) ; } if ( ! found ) { zed_log_msg ( LOG_INFO , "labeled disk %s unexpected here" , fullpath ) ; ( void ) zpool_vdev_online ( zhp , fullpath , ZFS_ONLINE_FORCEFAULT , & newstate ) ; return ; } zed_log_msg ( LOG_INFO , "  zpool_label_disk: resume '%s' (%llu)" , physpath , ( u_longlong_t ) guid ) ; ( void ) snprintf ( devpath , sizeof ( devpath ) , "%s%s" , DEV_BYID_PATH , new_devid ) ; } if ( nvlist_alloc ( & nvroot , NV_UNIQUE_NAME , 0 ) != 0 ) { zed_log_msg ( LOG_WARNING , "zfs_mod: nvlist_alloc out of memory" ) ; return ; } if ( nvlist_alloc ( & newvd , NV_UNIQUE_NAME , 0 ) != 0 ) { zed_log_msg ( LOG_WARNING , "zfs_mod: nvlist_alloc out of memory" ) ; nvlist_free ( nvroot ) ; return ; } if ( nvlist_add_string ( newvd , ZPOOL_CONFIG_TYPE , VDEV_TYPE_DISK ) != 0 || nvlist_add_string ( newvd , ZPOOL_CONFIG_PATH , path ) != 0 || nvlist_add_string ( newvd , ZPOOL_CONFIG_DEVID , new_devid ) != 0 || ( physpath != NULL && nvlist_add_string ( newvd , ZPOOL_CONFIG_PHYS_PATH , physpath ) != 0 ) || ( enc_sysfs_path != NULL && nvlist_add_string ( newvd , ZPOOL_CONFIG_VDEV_ENC_SYSFS_PATH , enc_sysfs_path ) != 0 ) || nvlist_add_uint64 ( newvd , ZPOOL_CONFIG_WHOLE_DISK , wholedisk ) != 0 || nvlist_add_string ( nvroot , ZPOOL_CONFIG_TYPE , VDEV_TYPE_ROOT ) != 0 || nvlist_add_nvlist_array ( nvroot , ZPOOL_CONFIG_CHILDREN , & newvd , 1 ) != 0 ) { zed_log_msg ( LOG_WARNING , "zfs_mod: unable to add nvlist pairs" ) ; nvlist_free ( newvd ) ; nvlist_free ( nvroot ) ; return ; } nvlist_free ( newvd ) ; ret = zpool_vdev_attach ( zhp , fullpath , path , nvroot , B_TRUE ) ; zed_log_msg ( LOG_INFO , "  zpool_vdev_replace: %s with %s (%s)" , fullpath , path , ( ret == 0 ) ?"no errors" : libzfs_error_description ( g_zfshdl ) ) ; nvlist_free ( nvroot ) ; } dev_data { const char * dd_compare ; const char * dd_prop ; zfs_process_func_t dd_func ; boolean_t dd_found ; boolean_t dd_islabeled ; uint64_t dd_pool_guid ; uint64_t dd_vdev_guid ; const char * dd_new_devid ; } dev_data_t 