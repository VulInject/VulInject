void cvs_commit_local ( struct cvs_file * cf ) { char * tag ; BUF * b , * d ; int onbranch , isnew , histtype , branchadded ; RCSNUM * nrev , * crev , * rrev , * brev ; int openflags , rcsflags ; char rbuf [ CVS_REV_BUFSZ ] , nbuf [ CVS_REV_BUFSZ ] ; CVSENTRIES * entlist ; char attic [ PATH_MAX ] , repo [ PATH_MAX ] , rcsfile [ PATH_MAX ] ; struct file_info * fi ; cvs_log ( LP_TRACE , "cvs_commit_local(%s)" , cf -> file_path ) ; cvs_file_classify ( cf , cvs_directory_tag ) ; if ( cvs_noexec == 1 ) { return ; } if ( cf -> file_type != CVS_FILE ) { fatal ( "cvs_commit_local: '%s' is not a file" , cf -> file_path ) ; } tag = cvs_directory_tag ; if ( cf -> file_ent != NULL && cf -> file_ent -> ce_tag != NULL ) { tag = cf -> file_ent -> ce_tag ; } branchadded = 0 ; switch ( cf -> file_status ) { case FILE_ADDED : if ( cf -> file_rcs == NULL && tag != NULL ) { branchadded = 1 ; cvs_add_tobranch ( cf , tag ) ; } break ; case FILE_MODIFIED : case FILE_REMOVED : if ( cf -> file_rcs == NULL ) { cvs_log ( LP_ERR , "RCS file for %s got lost" , cf -> file_path ) ; return ; } break ; default : cvs_log ( LP_ERR , "skipping bogus file `%s'" , cf -> file_path ) ; return ; } onbranch = 0 ; nrev = RCS_HEAD_REV ; crev = NULL ; rrev = NULL ; d = NULL ; if ( cf -> file_rcs != NULL && cf -> file_rcs -> rf_branch != NULL ) { free ( cf -> file_rcs -> rf_branch ) ; cf -> file_rcs -> rf_branch = NULL ; } if ( cf -> file_rcs != NULL ) { rrev = rcs_head_get ( cf -> file_rcs ) ; crev = rcs_head_get ( cf -> file_rcs ) ; if ( crev == NULL || rrev == NULL ) { fatal ( "no head revision in RCS file for %s" , cf -> file_path ) ; } if ( tag != NULL ) { free ( rrev ) ; brev = rcs_sym_getrev ( cf -> file_rcs , tag ) ; crev = rcs_translate_tag ( tag , cf -> file_rcs ) ; if ( brev == NULL || crev == NULL ) { fatal ( "failed to resolve existing tag: %s" , tag ) ; } rrev = rcsnum_alloc ( ) ; rcsnum_cpy ( brev , rrev , brev -> rn_len - 1 ) ; if ( RCSNUM_ISBRANCHREV ( crev ) && rcsnum_cmp ( crev , rrev , 0 ) ) { nrev = rcsnum_alloc ( ) ; rcsnum_cpy ( crev , nrev , 0 ) ; rcsnum_inc ( nrev ) ; } if ( ! RCSNUM_ISBRANCH ( crev ) ) { nrev = rcsnum_brtorev ( brev ) ; if ( nrev == NULL ) { fatal ( "failed to create branch rev" ) ; } } else { fatal ( "this isnt suppose to happen, honestly" ) ; } free ( brev ) ; free ( rrev ) ; rrev = rcsnum_branch_root ( nrev ) ; onbranch = 1 ; } rcsnum_tostr ( crev , rbuf , sizeof ( rbuf ) ) ; } else { strlcpy ( rbuf , "Non-existent" , sizeof ( rbuf ) ) ; } free ( rrev ) ; isnew = 0 ; if ( cf -> file_status == FILE_ADDED ) { isnew = 1 ; rcsflags = RCS_CREATE ; openflags = O_CREAT | O_RDONLY ; if ( cf -> file_rcs != NULL ) { if ( ! onbranch ) { if ( cf -> in_attic == 0 ) { cvs_log ( LP_ERR , "warning: expected %s " "to be in the Attic" , cf -> file_path ) ; } if ( cf -> file_rcs -> rf_dead == 0 ) { cvs_log ( LP_ERR , "warning: expected %s " "to be dead" , cf -> file_path ) ; } cvs_get_repository_path ( cf -> file_wd , repo , PATH_MAX ) ; ( void ) xsnprintf ( rcsfile , PATH_MAX , "%s/%s%s" , repo , cf -> file_name , RCS_FILE_EXT ) ; if ( rename ( cf -> file_rpath , rcsfile ) == - 1 ) { fatal ( "cvs_commit_local: failed to " "move %s outside the Attic: %s" , cf -> file_path , strerror ( errno ) ) ; } free ( cf -> file_rpath ) ; cf -> file_rpath = xstrdup ( rcsfile ) ; isnew = 0 ; } rcsflags = RCS_READ | RCS_PARSE_FULLY ; openflags = O_RDONLY ; rcs_close ( cf -> file_rcs ) ; } cf -> repo_fd = open ( cf -> file_rpath , openflags ) ; if ( cf -> repo_fd == - 1 ) { fatal ( "cvs_commit_local: %s" , strerror ( errno ) ) ; } cf -> file_rcs = rcs_open ( cf -> file_rpath , cf -> repo_fd , rcsflags , 0444 ) ; if ( cf -> file_rcs == NULL ) { fatal ( "cvs_commit_local: failed to create RCS file " "for %s" , cf -> file_path ) ; } commit_desc_set ( cf ) ; if ( branchadded ) { strlcpy ( rbuf , "Non-existent" , sizeof ( rbuf ) ) ; } } if ( verbosity > 1 ) { cvs_printf ( "Checking in %s:\n" , cf -> file_path ) ; cvs_printf ( "%s<- %s\n" , cf -> file_rpath , cf -> file_path ) ; cvs_printf ( "old revision: %s; " , rbuf ) ; } if ( isnew == 0 && cf -> file_rcs -> rf_head == NULL ) { fatal ( "no head revision in RCS file for %s" , cf -> file_path ) ; } if ( isnew == 0 && onbranch == 0 ) { d = commit_diff ( cf , cf -> file_rcs -> rf_head , 0 ) ; } if ( cf -> file_status == FILE_REMOVED ) { b = rcs_rev_getbuf ( cf -> file_rcs , crev , 0 ) ; } if ( onbranch == 1 ) { b = commit_diff ( cf , crev , 1 ) ; } else { b = buf_load_fd ( cf -> fd ) ; } if ( isnew == 0 && onbranch == 0 ) { if ( rcs_deltatext_set ( cf -> file_rcs , crev , d ) == - 1 ) { fatal ( "cvs_commit_local: failed to set delta" ) ; } } if ( rcs_rev_add ( cf -> file_rcs , nrev , logmsg , - 1 , NULL ) == - 1 ) { fatal ( "cvs_commit_local: failed to add new revision" ) ; } if ( nrev == RCS_HEAD_REV ) { nrev = cf -> file_rcs -> rf_head ; } if ( rcs_deltatext_set ( cf -> file_rcs , nrev , b ) == - 1 ) { fatal ( "cvs_commit_local: failed to set new HEAD delta" ) ; } if ( cf -> file_status == FILE_REMOVED ) { if ( rcs_state_set ( cf -> file_rcs , nrev , RCS_STATE_DEAD ) == - 1 ) { fatal ( "cvs_commit_local: failed to set state" ) ; } } if ( cf -> file_status == FILE_ADDED && cf -> file_ent -> ce_opts != NULL ) { int cf_kflag ; cf_kflag = rcs_kflag_get ( cf -> file_ent -> ce_opts + 2 ) ; rcs_kwexp_set ( cf -> file_rcs , cf_kflag ) ; } rcs_write ( cf -> file_rcs ) ; if ( cf -> file_status == FILE_REMOVED ) { strlcpy ( nbuf , "Removed" , sizeof ( nbuf ) ) ; } if ( cf -> file_status == FILE_ADDED ) { if ( cf -> file_rcs -> rf_dead == 1 ) { strlcpy ( nbuf , "Initial Revision" , sizeof ( nbuf ) ) ; } else { rcsnum_tostr ( nrev , nbuf , sizeof ( nbuf ) ) ; } } if ( cf -> file_status == FILE_MODIFIED ) { rcsnum_tostr ( nrev , nbuf , sizeof ( nbuf ) ) ; } if ( verbosity > 1 ) { cvs_printf ( "new revision: %s\n" , nbuf ) ; } ( void ) unlink ( cf -> file_path ) ; ( void ) close ( cf -> fd ) ; cf -> fd = - 1 ; if ( cf -> file_status != FILE_REMOVED ) { cvs_checkout_file ( cf , nrev , NULL , CO_COMMIT ) ; } else { entlist = cvs_ent_open ( cf -> file_wd ) ; cvs_ent_remove ( entlist , cf -> file_name ) ; cvs_get_repository_path ( cf -> file_wd , repo , PATH_MAX ) ; ( void ) xsnprintf ( attic , PATH_MAX , "%s/%s" , repo , CVS_PATH_ATTIC ) ; if ( mkdir ( attic , 0755 ) == - 1 && errno != EEXIST ) { fatal ( "cvs_commit_local: failed to create Attic" ) ; } ( void ) xsnprintf ( attic , PATH_MAX , "%s/%s/%s%s" , repo , CVS_PATH_ATTIC , cf -> file_name , RCS_FILE_EXT ) ; if ( rename ( cf -> file_rpath , attic ) == - 1 ) { fatal ( "cvs_commit_local: failed to move %s to Attic" , cf -> file_path ) ; } if ( cvs_server_active == 1 ) { cvs_server_update_entry ( "Remove-entry" , cf ) ; } } if ( verbosity > 1 ) { cvs_printf ( "done\n" ) ; } else { cvs_log ( LP_NOTICE , "checking in '%s'; revision %s ->%s" , cf -> file_path , rbuf , nbuf ) ; } if ( line_list != NULL ) { fi = xcalloc ( 1 , sizeof ( * fi ) ) ; fi -> file_path = xstrdup ( cf -> file_path ) ; fi -> crevstr = xstrdup ( rbuf ) ; fi -> nrevstr = xstrdup ( nbuf ) ; if ( tag != NULL ) { fi -> tag_new = xstrdup ( tag ) ; } TAILQ_INSERT_TAIL ( & files_info , fi , flist ) ; } switch ( cf -> file_status ) { case FILE_MODIFIED : histtype = CVS_HISTORY_COMMIT_MODIFIED ; break ; case FILE_ADDED : histtype = CVS_HISTORY_COMMIT_ADDED ; break ; case FILE_REMOVED : histtype = CVS_HISTORY_COMMIT_REMOVED ; break ; default : histtype = - 1 ; break ; } free ( crev ) ; if ( histtype != - 1 ) { cvs_history_add ( histtype , cf , NULL ) ; } else { cvs_log ( LP_NOTICE , "histtype was -1 for %s" , cf -> file_path ) ; } } 