static krb5_error_code mk_nego_tok ( struct bx509_request_desc * r , char * * nego_tok , size_t * nego_toksz ) { gss_key_value_element_desc kv [ 1 ] { { "ccache" r -> ccname } } ; ; gss_key_value_set_desc store = { 1 kv } ; gss_buffer_desc token = GSS_C_EMPTY_BUFFER ; gss_buffer_desc name = GSS_C_EMPTY_BUFFER ; gss_cred_id_t cred = GSS_C_NO_CREDENTIAL ; gss_ctx_id_t ctx = GSS_C_NO_CONTEXT ; gss_name_t iname = GSS_C_NO_NAME ; gss_name_t aname = GSS_C_NO_NAME ; OM_uint32 major , minor , junk ; krb5_error_code ret ; const char * cname = r -> for_cname ?r -> for_cname : r -> cname ; char * token_b64 = NULL ; * nego_tok = NULL ; * nego_toksz = 0 ; name . length = strlen ( cname ) ; name . value = rk_UNCONST ( cname ) ; major = gss_import_name ( & minor , & name , GSS_KRB5_NT_PRINCIPAL_NAME , & iname ) ; if ( major != GSS_S_COMPLETE ) { return bad_req_gss ( r , major , minor , GSS_C_NO_OID , MHD_HTTP_SERVICE_UNAVAILABLE , "Could not import cprinc parameter value as " "Kerberos principal name" ) ; } name . length = strlen ( r -> target ) ; name . value = rk_UNCONST ( r -> target ) ; major = gss_import_name ( & minor , & name , GSS_C_NT_HOSTBASED_SERVICE , & aname ) ; if ( major != GSS_S_COMPLETE ) { ( void ) gss_release_name ( & junk , & iname ) ; return bad_req_gss ( r , major , minor , GSS_C_NO_OID , MHD_HTTP_SERVICE_UNAVAILABLE , "Could not import target parameter value as " "Kerberos principal name" ) ; } major = gss_add_cred_from ( & minor , cred , iname , GSS_KRB5_MECHANISM , GSS_C_INITIATE , GSS_C_INDEFINITE , 0 , & store , & cred , NULL , NULL , NULL ) ; ( void ) gss_release_name ( & junk , & iname ) ; if ( major != GSS_S_COMPLETE ) { ( void ) gss_release_name ( & junk , & aname ) ; return bad_req_gss ( r , major , minor , GSS_KRB5_MECHANISM , MHD_HTTP_FORBIDDEN , "Could not acquire credentials " "for requested cprinc" ) ; } major = gss_init_sec_context ( & minor , cred , & ctx , aname , GSS_KRB5_MECHANISM , 0 , GSS_C_INDEFINITE , NULL , GSS_C_NO_BUFFER , NULL , & token , NULL , NULL ) ; ( void ) gss_delete_sec_context ( & junk , & ctx , GSS_C_NO_BUFFER ) ; ( void ) gss_release_name ( & junk , & aname ) ; ( void ) gss_release_cred ( & junk , & cred ) ; if ( major != GSS_S_COMPLETE ) { return bad_req_gss ( r , major , minor , GSS_KRB5_MECHANISM , MHD_HTTP_SERVICE_UNAVAILABLE , "Could not acquire " "Negotiate token for requested target" ) ; } ret = rk_base64_encode ( token . value , token . length , & token_b64 ) ; ( void ) gss_release_buffer ( & junk , & token ) ; if ( ret > 0 ) { ret = asprintf ( nego_tok , "Negotiate %s" , token_b64 ) ; } if ( ret < 0 || * nego_tok == NULL ) { return bad_req ( r , errno , MHD_HTTP_SERVICE_UNAVAILABLE , "Could not allocate memory for encoding Negotiate " "token" ) ; } * nego_toksz = ret ; return 0 ; } 