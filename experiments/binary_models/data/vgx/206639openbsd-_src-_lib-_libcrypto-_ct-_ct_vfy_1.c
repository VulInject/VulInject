int SCT_CTX_verify ( const SCT_CTX * sctx , const SCT * sct ) { EVP_MD_CTX * ctx = NULL ; int ret = 0 ; if ( ! SCT_is_complete ( sct ) || sctx -> pkey == NULL || sct -> entry_type == CT_LOG_ENTRY_TYPE_NOT_SET || ( sct -> entry_type == CT_LOG_ENTRY_TYPE_PRECERT && sctx -> ihash == NULL ) ) { CTerror ( CT_R_SCT_NOT_SET ) ; return 0 ; } if ( sct -> version != SCT_VERSION_V1 ) { CTerror ( CT_R_SCT_UNSUPPORTED_VERSION ) ; return 0 ; } if ( sct -> log_id_len != sctx -> pkeyhashlen || memcmp ( sct -> log_id , sctx -> pkeyhash , sctx -> pkeyhashlen ) != 0 ) { CTerror ( CT_R_SCT_LOG_ID_MISMATCH ) ; return 0 ; } if ( sct -> timestamp > sctx -> epoch_time_in_ms ) { CTerror ( CT_R_SCT_FUTURE_TIMESTAMP , NULL ) ; return 0 ; } if ( ( ctx = EVP_MD_CTX_new ( ) ) == NULL ) { end } if ( ! EVP_DigestVerifyInit ( ctx , NULL , EVP_sha256 ( ) , NULL , sctx -> pkey ) ) { end } if ( ! sct_ctx_update ( ctx , sctx , sct ) ) { end } if ( ( ret = EVP_DigestVerifyFinal ( ctx , sct -> sig , sct -> sig_len ) ) == 0 ) { CTerror ( CT_R_SCT_INVALID_SIGNATURE ) ; } end EVP_MD_CTX_free ( ctx ) ; return ret ; } 