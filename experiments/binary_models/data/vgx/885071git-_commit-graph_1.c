struct commit_graph * parse_commit_graph ( struct repo_settings * s , void * graph_map , size_t graph_size ) { const unsigned char * data ; struct commit_graph * graph ; uint32_t graph_signature ; unsigned char graph_version , hash_version ; struct chunkfile * cf = NULL ; if ( ! graph_map ) { return NULL ; } if ( graph_size < GRAPH_MIN_SIZE ) { return NULL ; } data = ( const unsigned char * ) graph_map ; graph_signature = get_be32 ( data ) ; if ( graph_signature != GRAPH_SIGNATURE ) { error ( _ ( "commit-graph signature %X does not match signature %X" ) , graph_signature , GRAPH_SIGNATURE ) ; return NULL ; } graph_version = * ( unsigned char * ) ( data + 4 ) ; if ( graph_version != GRAPH_VERSION ) { error ( _ ( "commit-graph version %X does not match version %X" ) , graph_version , GRAPH_VERSION ) ; return NULL ; } hash_version = * ( unsigned char * ) ( data + 5 ) ; if ( hash_version != oid_version ( the_hash_algo ) ) { error ( _ ( "commit-graph hash version %X does not match version %X" ) , hash_version , oid_version ( the_hash_algo ) ) ; return NULL ; } graph = alloc_commit_graph ( ) ; graph -> hash_len = the_hash_algo -> rawsz ; graph -> num_chunks = * ( unsigned char * ) ( data + 6 ) ; graph -> data = graph_map ; graph -> data_len = graph_size ; if ( graph_size < GRAPH_HEADER_SIZE + ( graph -> num_chunks + 1 ) * CHUNK_TOC_ENTRY_SIZE + GRAPH_FANOUT_SIZE + the_hash_algo -> rawsz ) { error ( _ ( "commit-graph file is too small to hold %u chunks" ) , graph -> num_chunks ) ; return NULL ; } cf = init_chunkfile ( NULL ) ; if ( read_table_of_contents ( cf , graph -> data , graph_size , GRAPH_HEADER_SIZE , graph -> num_chunks ) ) { free_and_return } pair_chunk ( cf , GRAPH_CHUNKID_OIDFANOUT , ( const unsigned char * * ) & graph -> chunk_oid_fanout ) ; read_chunk ( cf , GRAPH_CHUNKID_OIDLOOKUP , graph_read_oid_lookup , graph ) ; pair_chunk ( cf , GRAPH_CHUNKID_DATA , & graph -> chunk_commit_data ) ; pair_chunk ( cf , GRAPH_CHUNKID_EXTRAEDGES , & graph -> chunk_extra_edges ) ; pair_chunk ( cf , GRAPH_CHUNKID_BASE , & graph -> chunk_base_graphs ) ; if ( s -> commit_graph_generation_version >= 2 ) { pair_chunk ( cf , GRAPH_CHUNKID_GENERATION_DATA , & graph -> chunk_generation_data ) ; pair_chunk ( cf , GRAPH_CHUNKID_GENERATION_DATA_OVERFLOW , & graph -> chunk_generation_data_overflow ) ; if ( graph -> chunk_generation_data ) { graph -> read_generation_data = 1 ; } } if ( s -> commit_graph_read_changed_paths ) { pair_chunk ( cf , GRAPH_CHUNKID_BLOOMINDEXES , & graph -> chunk_bloom_indexes ) ; read_chunk ( cf , GRAPH_CHUNKID_BLOOMDATA , graph_read_bloom_data , graph ) ; } if ( graph -> chunk_bloom_indexes && graph -> chunk_bloom_data ) { init_bloom_filters ( ) ; } else { graph -> chunk_bloom_indexes = NULL ; graph -> chunk_bloom_data = NULL ; FREE_AND_NULL ( graph -> bloom_filter_settings ) ; } oidread ( & graph -> oid , graph -> data + graph -> data_len - graph -> hash_len ) ; if ( verify_commit_graph_lite ( graph ) ) { free_and_return } free_chunkfile ( cf ) ; return graph ; free_and_return free_chunkfile ( cf ) ; free ( graph -> bloom_filter_settings ) ; free ( graph ) ; return NULL ; } 