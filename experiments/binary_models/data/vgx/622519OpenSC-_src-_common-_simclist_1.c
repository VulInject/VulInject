int list_clear ( list_t * simclist_restrict l ) { struct list_entry_s * s ; if ( l -> iter_active ) { return - 1 ; } if ( l -> head_sentinel && l -> tail_sentinel ) { if ( l -> attrs . copy_data ) { for ( s = l -> head_sentinel -> next ; l -> spareelsnum < SIMCLIST_MAX_SPARE_ELEMS && s != l -> tail_sentinel ; s = s -> next ) { if ( s -> data != NULL ) { free ( s -> data ) ; } l -> spareels [ l -> spareelsnum ++ ] = s ; } while ( s != l -> tail_sentinel ) { if ( s -> data != NULL ) { free ( s -> data ) ; } s = s -> next ; } l -> head_sentinel -> next = l -> tail_sentinel ; l -> tail_sentinel -> prev = l -> head_sentinel ; } else { for ( s = l -> head_sentinel -> next ; l -> spareelsnum < SIMCLIST_MAX_SPARE_ELEMS && s != l -> tail_sentinel ; s = s -> next ) { l -> spareels [ l -> spareelsnum ++ ] = s ; } while ( s != l -> tail_sentinel ) { s = s -> next ; free ( s -> prev ) ; } l -> head_sentinel -> next = l -> tail_sentinel ; l -> tail_sentinel -> prev = l -> head_sentinel ; } } l -> numels = 0 ; l -> mid = NULL ; assert ( list_repOk ( l ) ) ; return 0 ; } 