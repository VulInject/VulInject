static int get_tpkt_data ( struct sk_buff * skb , unsigned int protoff , struct nf_conn * ct , enum ip_conntrack_info ctinfo , unsigned char * * data , int * datalen , int * dataoff ) { struct nf_ct_h323_master * info = nfct_help_data ( ct ) ; int dir = CTINFO2DIR ( ctinfo ) ; const struct tcphdr * th ; struct tcphdr _tcph ; int tcpdatalen ; int tcpdataoff ; unsigned char * tpkt ; int tpktlen ; int tpktoff ; th = skb_header_pointer ( skb , protoff , sizeof ( _tcph ) , & _tcph ) ; tcpdataoff = protoff + th -> doff * 4 ; tcpdatalen = skb -> len - tcpdataoff ; if ( tcpdatalen <= 0 ) { clear_out } if ( * data == NULL ) { tpkt = skb_header_pointer ( skb , tcpdataoff , tcpdatalen , h323_buffer ) ; BUG_ON ( tpkt == NULL ) ; if ( tcpdatalen < 4 || tpkt [ 0 ] != 0x03 || tpkt [ 1 ] != 0 ) { if ( info -> tpkt_len [ dir ] > 0 ) { pr_debug ( "nf_ct_h323: previous packet " "indicated separate TPKT data of %hu " "bytes\n" , info -> tpkt_len [ dir ] ) ; if ( info -> tpkt_len [ dir ] <= tcpdatalen ) { * data = tpkt ; * datalen = info -> tpkt_len [ dir ] ; * dataoff = 0 ; out } pr_debug ( "nf_ct_h323: fragmented TPKT\n" ) ; clear_out } return 0 ; } tpktoff = 0 ; } else { tpktoff = * dataoff + * datalen ; tcpdatalen -= tpktoff ; if ( tcpdatalen <= 4 ) { clear_out } tpkt = * data + * datalen ; if ( tpkt [ 0 ] != 0x03 || tpkt [ 1 ] != 0 ) { clear_out } } tpktlen = tpkt [ 2 ] * 256 + tpkt [ 3 ] ; if ( tpktlen < 4 ) { clear_out } if ( tpktlen > tcpdatalen ) { if ( tcpdatalen == 4 ) { pr_debug ( "nf_ct_h323: separate TPKT header indicates " "there will be TPKT data of %hu bytes\n" , tpktlen - 4 ) ; info -> tpkt_len [ dir ] = tpktlen - 4 ; return 0 ; } pr_debug ( "nf_ct_h323: incomplete TPKT (fragmented?)\n" ) ; clear_out } * data = tpkt + 4 ; * datalen = tpktlen - 4 ; * dataoff = tpktoff + 4 ; out info -> tpkt_len [ dir ] = 0 ; return 1 ; clear_out info -> tpkt_len [ dir ] = 0 ; return 0 ; } 