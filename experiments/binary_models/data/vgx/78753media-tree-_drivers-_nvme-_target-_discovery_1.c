u16 nvmet_parse_discovery_cmd ( struct nvmet_req * req ) { struct nvme_command * cmd = req -> cmd ; if ( unlikely ( ! ( req -> sq -> ctrl -> csts & NVME_CSTS_RDY ) ) ) { pr_err ( "got cmd %d while not ready\n" , cmd -> common . opcode ) ; return NVME_SC_INVALID_OPCODE | NVME_SC_DNR ; } switch ( cmd -> common . opcode ) { case nvme_admin_get_log_page : req -> data_len = nvmet_get_log_page_len ( cmd ) ; switch ( cmd -> get_log_page . lid ) { case NVME_LOG_DISC : req -> execute = nvmet_execute_get_disc_log_page ; return 0 ; default : pr_err ( "unsupported get_log_page lid %d\n" , cmd -> get_log_page . lid ) ; return NVME_SC_INVALID_OPCODE | NVME_SC_DNR ; } case nvme_admin_identify : req -> data_len = 4096 ; switch ( cmd -> identify . cns ) { case NVME_ID_CNS_CTRL : req -> execute = nvmet_execute_identify_disc_ctrl ; return 0 ; default : pr_err ( "unsupported identify cns %d\n" , cmd -> identify . cns ) ; return NVME_SC_INVALID_OPCODE | NVME_SC_DNR ; } default : pr_err ( "unsupported cmd %d\n" , cmd -> common . opcode ) ; return NVME_SC_INVALID_OPCODE | NVME_SC_DNR ; } pr_err ( "unhandled cmd %d\n" , cmd -> common . opcode ) ; return NVME_SC_INVALID_OPCODE | NVME_SC_DNR ; } 