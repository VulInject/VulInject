cvmx_pko_return_value_t cvmx_pko3_legacy_xmit ( unsigned int dq , cvmx_pko_command_word0_t pko_command , cvmx_buf_ptr_t packet , u64 addr , bool tag_sw ) { cvmx_pko_query_rtn_t pko_status ; cvmx_pko_send_hdr_t * hdr_s ; struct __cvmx_pko3_legacy_desc desc ; u8 * data_ptr ; unsigned int node , seg_cnt ; int res ; cvmx_buf_ptr_pki_t bptr ; seg_cnt = pko_command . s . segs ; desc . cmd_words = cvmx_pko3_cvmseg_addr ( ) ; node = cvmx_get_node_num ( ) ; desc . aura_node = node ; desc . port_node = dq >> 10 ; dq &= ( 1 << 10 ) - 1 ; desc . word_count = 1 ; desc . last_pool = - 1 ; if ( seg_cnt < 7 || OCTEON_IS_MODEL ( OCTEON_CN78XX_PASS1_X ) ) { desc . jump_buf_base_ptr = NULL ; } else { unsigned int pko_aura = __cvmx_pko3_aura_get ( desc . port_node ) ; cvmx_fpa3_gaura_t aura = __cvmx_fpa3_gaura ( pko_aura >> 10 , pko_aura & 0x3ff ) ; desc . jump_buf_base_ptr = cvmx_fpa3_alloc ( aura ) ; if ( ! desc . jump_buf_base_ptr ) { return - ENOMEM ; } desc . jump_buf_size = 0 ; } bptr . u64 = packet . u64 ; if ( seg_cnt == 1 && bptr . size == pko_command . s . total_bytes ) { debug ( "%s: WARNING: Native buffer-pointer\n" , __func__ ) ; } else { res = cvmx_pko3_legacy_bufptr_validate ( packet , pko_command . s . gather , pko_command . s . segs , pko_command . s . total_bytes ) ; if ( res < 0 ) { debug ( "%s: ERROR: Not a valid packet pointer<%d>\n" , __func__ , res ) ; return CVMX_PKO_CMD_QUEUE_INIT_ERROR ; } } ( void ) bptr ; hdr_s = ( void * ) & desc . cmd_words [ 0 ] ; hdr_s -> u64 = 0 ; hdr_s -> s . total = pko_command . s . total_bytes ; hdr_s -> s . le = pko_command . s . le ; if ( OCTEON_IS_MODEL ( OCTEON_CN78XX_PASS1_X ) ) { hdr_s -> s . n2 = 0 ; } else { hdr_s -> s . n2 = pko_command . s . n2 ; } hdr_s -> s . df = pko_command . s . dontfree ; hdr_s -> s . ii = pko_command . s . ignore_i ; if ( cvmx_unlikely ( pko_command . s . ipoffp1 > 0 ) ) { u8 ipoff , ip0 , l4_proto = 0 ; if ( pko_command . s . gather ) { cvmx_buf_ptr_t * p_ptr ; cvmx_buf_ptr_t blk ; p_ptr = cvmx_phys_to_ptr ( cvmx_pko3_legacy_paddr ( node , packet . s . addr ) ) ; blk = p_ptr [ 0 ] ; data_ptr = cvmx_phys_to_ptr ( cvmx_pko3_legacy_paddr ( node , blk . s . addr ) ) ; } else { data_ptr = cvmx_phys_to_ptr ( cvmx_pko3_legacy_paddr ( node , packet . s . addr ) ) ; } ipoff = pko_command . s . ipoffp1 - 1 ; hdr_s -> s . l3ptr = ipoff ; ip0 = data_ptr [ ipoff ] ; if ( ( ip0 >> 4 ) == 4 ) { hdr_s -> s . l4ptr = hdr_s -> s . l3ptr + ( ( ip0 & 0xf ) << 2 ) ; l4_proto = data_ptr [ ipoff + 9 ] ; hdr_s -> s . ckl3 = 1 ; } if ( ( ip0 >> 4 ) == 6 ) { hdr_s -> s . l4ptr = hdr_s -> s . l3ptr + 40 ; l4_proto = data_ptr [ ipoff + 6 ] ; } if ( l4_proto == 6 ) { hdr_s -> s . ckl4 = 2 ; } if ( l4_proto == 17 ) { hdr_s -> s . ckl4 = 1 ; } if ( l4_proto == 132 ) { hdr_s -> s . ckl4 = 3 ; } else { hdr_s -> s . ckl4 = 0 ; } } if ( pko_command . s . gather ) { cvmx_pko_buf_ptr_t gather_s ; cvmx_buf_ptr_t * p_ptr ; cvmx_buf_ptr_t blk ; unsigned int i ; p_ptr = cvmx_phys_to_ptr ( cvmx_pko3_legacy_paddr ( node , packet . s . addr ) ) ; blk = p_ptr [ 0 ] ; data_ptr = cvmx_phys_to_ptr ( cvmx_pko3_legacy_paddr ( node , blk . s . addr ) ) ; for ( i = 0 ; i < seg_cnt ; i ++ ) { if ( cvmx_unlikely ( cvmx_pko3_legacy_pool ( & desc , blk . s . pool ) < 0 ) ) { return CVMX_PKO_NO_MEMORY ; } gather_s . u64 = 0 ; gather_s . s . subdc3 = CVMX_PKO_SENDSUBDC_GATHER ; gather_s . s . size = blk . s . size ; gather_s . s . i = blk . s . i ; gather_s . s . addr = cvmx_pko3_legacy_paddr ( node , blk . s . addr ) ; res = __cvmx_pko3_cmd_subdc_add ( & desc , gather_s . u64 ) ; if ( res < 0 ) { return CVMX_PKO_NO_MEMORY ; } blk = p_ptr [ i + 1 ] ; } if ( ( pko_command . s . ignore_i && ! pko_command . s . dontfree ) || packet . s . i == pko_command . s . dontfree ) { cvmx_fpa_free_nosync ( p_ptr , packet . s . pool , ( i - 1 ) / 16 + 1 ) ; } } else { cvmx_pko_buf_ptr_t gather_s ; cvmx_buf_ptr_t blk ; void * vptr ; data_ptr = cvmx_phys_to_ptr ( cvmx_pko3_legacy_paddr ( node , packet . s . addr ) ) ; blk = packet ; { if ( cvmx_unlikely ( cvmx_pko3_legacy_pool ( & desc , blk . s . pool ) < 0 ) ) { return CVMX_PKO_NO_MEMORY ; } gather_s . u64 = 0 ; gather_s . s . subdc3 = CVMX_PKO_SENDSUBDC_GATHER ; gather_s . s . size = blk . s . size ; gather_s . s . i = blk . s . i ; gather_s . s . addr = cvmx_pko3_legacy_paddr ( node , blk . s . addr ) ; res = __cvmx_pko3_cmd_subdc_add ( & desc , gather_s . u64 ) ; if ( res < 0 ) { return CVMX_PKO_NO_MEMORY ; } vptr = cvmx_phys_to_ptr ( cvmx_pko3_legacy_paddr ( node , blk . s . addr ) ) ; memcpy ( & blk , vptr - sizeof ( blk ) , sizeof ( blk ) ) ; seg_cnt -- ; } seg_cnt > 0 ; } if ( cvmx_unlikely ( pko_command . s . rsp ) ) { if ( pko_command . s . wqp ) { cvmx_wqe_word1_t * wqe_p ; cvmx_pko_send_work_t work_s ; work_s . u64 = 0 ; work_s . s . subdc4 = CVMX_PKO_SENDSUBDC_WORK ; work_s . s . addr = addr ; wqe_p = cvmx_phys_to_ptr ( addr + sizeof ( u64 ) ) ; work_s . s . grp = wqe_p -> cn38xx . grp ; work_s . s . tt = wqe_p -> tag_type ; res = __cvmx_pko3_cmd_subdc_add ( & desc , work_s . u64 ) ; } else { cvmx_pko_send_mem_t mem_s ; if ( OCTEON_IS_MODEL ( OCTEON_CN78XX_PASS1_0 ) ) { debug ( "%s: ERROR: PKO byte-clear not supported\n" , __func__ ) ; } mem_s . u64 = 0 ; mem_s . s . subdc4 = CVMX_PKO_SENDSUBDC_MEM ; mem_s . s . addr = addr ; mem_s . s . dsz = MEMDSZ_B8 ; mem_s . s . alg = MEMALG_SET ; mem_s . s . offset = 0 ; res = __cvmx_pko3_cmd_subdc_add ( & desc , mem_s . u64 ) ; } if ( res < 0 ) { return CVMX_PKO_NO_MEMORY ; } } if ( pko_command . s . reg0 ) { cvmx_pko_send_mem_t mem_s ; debug ( "%s: Legacy FAU commands: reg0=%#x sz0=%#x\n" , __func__ , pko_command . s . reg0 , pko_command . s . size0 ) ; mem_s . u64 = 0 ; mem_s . s . subdc4 = CVMX_PKO_SENDSUBDC_MEM ; mem_s . s . addr = cvmx_ptr_to_phys ( CASTPTR ( void , __cvmx_fau_sw_addr ( pko_command . s . reg0 ) ) ) ; if ( cvmx_likely ( pko_command . s . size0 == CVMX_FAU_OP_SIZE_64 ) ) { mem_s . s . dsz = MEMDSZ_B64 ; } if ( pko_command . s . size0 == CVMX_FAU_OP_SIZE_32 ) { mem_s . s . dsz = MEMDSZ_B32 ; } if ( pko_command . s . size0 == CVMX_FAU_OP_SIZE_16 ) { mem_s . s . dsz = MEMDSZ_B16 ; } else { mem_s . s . dsz = MEMDSZ_B8 ; } if ( mem_s . s . dsz == MEMDSZ_B16 || mem_s . s . dsz == MEMDSZ_B8 ) { debug ( "%s: ERROR: 8/16 bit decrement unsupported" , __func__ ) ; } mem_s . s . offset = pko_command . s . subone0 ; if ( mem_s . s . offset ) { mem_s . s . alg = MEMALG_SUB ; } else { mem_s . s . alg = MEMALG_SUBLEN ; } res = __cvmx_pko3_cmd_subdc_add ( & desc , mem_s . u64 ) ; if ( res < 0 ) { return CVMX_PKO_NO_MEMORY ; } } if ( cvmx_unlikely ( pko_command . s . reg1 ) ) { cvmx_pko_send_mem_t mem_s ; debug ( "%s: Legacy FAU commands: reg1=%#x sz1=%#x\n" , __func__ , pko_command . s . reg1 , pko_command . s . size1 ) ; mem_s . u64 = 0 ; mem_s . s . subdc4 = CVMX_PKO_SENDSUBDC_MEM ; mem_s . s . addr = cvmx_ptr_to_phys ( CASTPTR ( void , __cvmx_fau_sw_addr ( pko_command . s . reg1 ) ) ) ; if ( cvmx_likely ( pko_command . s . size1 == CVMX_FAU_OP_SIZE_64 ) ) { mem_s . s . dsz = MEMDSZ_B64 ; } if ( pko_command . s . size1 == CVMX_FAU_OP_SIZE_32 ) { mem_s . s . dsz = MEMDSZ_B32 ; } if ( pko_command . s . size1 == CVMX_FAU_OP_SIZE_16 ) { mem_s . s . dsz = MEMDSZ_B16 ; } else { mem_s . s . dsz = MEMDSZ_B8 ; } if ( mem_s . s . dsz == MEMDSZ_B16 || mem_s . s . dsz == MEMDSZ_B8 ) { printf ( "%s: ERROR: 8/16 bit decrement unsupported" , __func__ ) ; } mem_s . s . offset = pko_command . s . subone1 ; if ( mem_s . s . offset ) { mem_s . s . alg = MEMALG_SUB ; } else { mem_s . s . alg = MEMALG_SUBLEN ; } res = __cvmx_pko3_cmd_subdc_add ( & desc , mem_s . u64 ) ; if ( res < 0 ) { return CVMX_PKO_NO_MEMORY ; } } res = __cvmx_pko3_cmd_done ( & desc ) ; if ( res < 0 ) { return CVMX_PKO_NO_MEMORY ; } pko_status = __cvmx_pko3_lmtdma ( desc . port_node , dq , desc . word_count , tag_sw ) ; if ( cvmx_likely ( pko_status . s . dqstatus == PKO_DQSTATUS_PASS ) ) { return CVMX_PKO_SUCCESS ; } debug ( "%s: ERROR: failed to enqueue: %s\n" , __func__ , pko_dqstatus_error ( pko_status . s . dqstatus ) ) ; if ( pko_status . s . dqstatus == PKO_DQSTATUS_ALREADY ) { return CVMX_PKO_PORT_ALREADY_SETUP ; } if ( pko_status . s . dqstatus == PKO_DQSTATUS_NOFPABUF || pko_status . s . dqstatus == PKO_DQSTATUS_NOPKOBUF ) { return CVMX_PKO_NO_MEMORY ; } if ( pko_status . s . dqstatus == PKO_DQSTATUS_NOTCREATED ) { return CVMX_PKO_INVALID_QUEUE ; } if ( pko_status . s . dqstatus == PKO_DQSTATUS_BADSTATE ) { return CVMX_PKO_CMD_QUEUE_INIT_ERROR ; } if ( pko_status . s . dqstatus == PKO_DQSTATUS_SENDPKTDROP ) { return CVMX_PKO_INVALID_PORT ; } return CVMX_PKO_INVALID_PORT ; } 