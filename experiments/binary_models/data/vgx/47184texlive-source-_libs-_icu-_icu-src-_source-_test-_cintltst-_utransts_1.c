static void TestDataVariantsCompounds ( ) { const TransIDSourceTarg * itemsPtr ; for ( itemsPtr = dataVarCompItems ; itemsPtr -> transID != NULL ; itemsPtr ++ ) { UErrorCode status = U_ZERO_ERROR ; UChar utrid [ kUBufMax ] ; int32_t utridlen = u_unescape ( itemsPtr -> transID , utrid , kUBufMax ) ; UTransliterator * utrans = utrans_openU ( utrid , utridlen , UTRANS_FORWARD , NULL , 0 , NULL , & status ) ; if ( U_FAILURE ( status ) ) { log_data_err ( "FAIL: utrans_openRules(%s) failed, error=%s (Are you missing data?)\n" , itemsPtr -> transID , u_errorName ( status ) ) ; continue ; } UChar text [ kUBufMax ] ; int32_t textLen = u_unescape ( itemsPtr -> sourceText , text , kUBufMax ) ; int32_t textLim = textLen ; utrans_transUChars ( utrans , text , & textLen , kUBufMax , 0 , & textLim , & status ) ; if ( U_FAILURE ( status ) ) { log_err ( "FAIL: utrans_transUChars(%s) failed, error=%s\n" , itemsPtr -> transID , u_errorName ( status ) ) ; } else { UChar expect [ kUBufMax ] ; int32_t expectLen = u_unescape ( itemsPtr -> targetText , expect , kUBufMax ) ; if ( textLen != expectLen || u_strncmp ( text , expect , textLen ) != 0 ) { char btext [ kBBufMax ] , bexpect [ kBBufMax ] ; u_austrncpy ( btext , text , textLen ) ; u_austrncpy ( bexpect , expect , expectLen ) ; log_err ( "FAIL: utrans_transUChars(%s),\n       expect %s\n       get    %s\n" , itemsPtr -> transID , bexpect , btext ) ; } } utrans_close ( utrans , NULL ) ; } } 