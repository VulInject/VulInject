static int dc_i2c_probe ( struct platform_device * pdev ) { struct device_node * np = pdev -> dev . of_node ; struct dc_i2c * i2c ; int ret = 0 , irq ; i2c = devm_kzalloc ( & pdev -> dev , sizeof ( dc_i2c ) , GFP_KERNEL ) ; if ( of_property_read_u32 ( pdev -> dev . of_node , "clock-frequency" , & i2c -> frequency ) ) { i2c -> frequency = I2C_MAX_STANDARD_MODE_FREQ ; } i2c -> dev = & pdev -> dev ; platform_set_drvdata ( pdev , i2c ) ; spin_lock_init ( & i2c -> lock ) ; init_completion ( & i2c -> done ) ; i2c -> clk = devm_clk_get ( & pdev -> dev , NULL ) ; if ( IS_ERR ( i2c -> clk ) ) { return PTR_ERR ( i2c -> clk ) ; } i2c -> regs = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( i2c -> regs ) ) { return PTR_ERR ( i2c -> regs ) ; } irq = platform_get_irq ( pdev , 0 ) ; if ( irq < 0 ) { return irq ; } ret = devm_request_irq ( & pdev -> dev , irq , dc_i2c_irq , 0 , dev_name ( & pdev -> dev ) , i2c ) ; if ( ret < 0 ) { return ret ; } strscpy ( i2c -> adap . name , "Conexant Digicolor I2C adapter" , sizeof ( i2c -> adap . name ) ) ; i2c -> adap . owner = THIS_MODULE ; i2c -> adap . algo = & dc_i2c_algorithm ; i2c -> adap . dev . parent = & pdev -> dev ; i2c -> adap . dev . of_node = np ; i2c -> adap . algo_data = i2c ; ret = dc_i2c_init_hw ( i2c ) ; if ( ret ) { return ret ; } ret = clk_prepare_enable ( i2c -> clk ) ; if ( ret < 0 ) { return ret ; } ret = i2c_add_adapter ( & i2c -> adap ) ; if ( ret < 0 ) { clk_disable_unprepare ( i2c -> clk ) ; return ret ; } return 0 ; } 