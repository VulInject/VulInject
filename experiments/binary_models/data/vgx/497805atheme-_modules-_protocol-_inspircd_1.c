static mowgli_node_t * inspircd_next_matching_ban ( struct channel * c , struct user * u , int type , mowgli_node_t * first ) { struct chanban * cb ; mowgli_node_t * n ; char hostbuf [ NICKLEN + 1 + USERLEN + 1 + HOSTLEN + 1 ] ; char realbuf [ NICKLEN + 1 + USERLEN + 1 + HOSTLEN + 1 ] ; char ipbuf [ NICKLEN + 1 + USERLEN + 1 + HOSTLEN + 1 ] ; char * p ; snprintf ( hostbuf , sizeof hostbuf , "%s!%s@%s" , u -> nick , u -> user , u -> vhost ) ; snprintf ( realbuf , sizeof realbuf , "%s!%s@%s" , u -> nick , u -> user , u -> host ) ; snprintf ( ipbuf , sizeof ipbuf , "%s!%s@%s" , u -> nick , u -> user , u -> ip ) ; bool check_realhost = ( config_options . masks_through_vhost || u -> host == u -> vhost ) ; MOWGLI_ITER_FOREACH ( , ) { struct channel * target_c ; cb = n -> data ; if ( cb -> type != type ) { continue ; } if ( ! match ( cb -> mask , hostbuf ) ) { return n ; } if ( check_realhost && ( ! match ( cb -> mask , realbuf ) || ! match ( cb -> mask , ipbuf ) || ! match_cidr ( cb -> mask , ipbuf ) ) ) { return n ; } if ( cb -> mask [ 1 ] == ':' && strchr ( "MRUjrm" , cb -> mask [ 0 ] ) ) { bool matched = false ; p = cb -> mask + 2 ; if ( * ( p - 1 ) != ':' ) { p = NULL ; } switch ( cb -> mask [ 0 ] ) { case 'M' : case 'R' : matched = u -> myuser != NULL && ! ( u -> myuser -> flags & MU_WAITAUTH ) && ( p == NULL || ! match ( p , entity ( u -> myuser ) -> name ) ) ; break ; case 'U' : matched = u -> myuser == NULL ; break ; case 'j' : target_c = channel_find ( p ) ; if ( target_c == NULL || ( target_c -> modes & ( CMODE_PRIV | CMODE_SEC ) ) ) { continue ; } matched = chanuser_find ( target_c , u ) != NULL ; break ; case 'r' : if ( p == NULL ) { continue ; } matched = ! match ( p , u -> gecos ) ; break ; case 'm' : matched = ! match ( p , hostbuf ) ; if ( check_realhost && ! matched ) { matched = ! match ( p , realbuf ) || ! match ( p , ipbuf ) || ! match_cidr ( p , ipbuf ) ; } break ; default : continue ; } if ( matched ) { return n ; } } } return NULL ; } 