static int fsi_master_aspeed_probe ( struct platform_device * pdev ) { struct fsi_master_aspeed * aspeed ; int rc , links , reg ; __be32 raw ; rc = tacoma_cabled_fsi_fixup ( & pdev -> dev ) ; if ( rc ) { dev_err ( & pdev -> dev , "Tacoma FSI cable fixup failed\n" ) ; return rc ; } aspeed = kzalloc ( sizeof ( * aspeed ) , GFP_KERNEL ) ; aspeed -> dev = & pdev -> dev ; aspeed -> base = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( aspeed -> base ) ) { rc = PTR_ERR ( aspeed -> base ) ; err_free_aspeed } aspeed -> clk = devm_clk_get ( aspeed -> dev , NULL ) ; if ( IS_ERR ( aspeed -> clk ) ) { dev_err ( aspeed -> dev , "couldn't get clock\n" ) ; rc = PTR_ERR ( aspeed -> clk ) ; err_free_aspeed } rc = clk_prepare_enable ( aspeed -> clk ) ; if ( rc ) { dev_err ( aspeed -> dev , "couldn't enable clock\n" ) ; err_free_aspeed } rc = setup_cfam_reset ( aspeed ) ; if ( rc ) { dev_err ( & pdev -> dev , "CFAM reset GPIO setup failed\n" ) ; } writel ( 0x1 , aspeed -> base + OPB_CLK_SYNC ) ; writel ( OPB1_XFER_ACK_EN | OPB0_XFER_ACK_EN , aspeed -> base + OPB_IRQ_MASK ) ; writel ( 0x10 , aspeed -> base + OPB_RETRY_COUNTER ) ; writel ( ctrl_base , aspeed -> base + OPB_CTRL_BASE ) ; writel ( fsi_base , aspeed -> base + OPB_FSI_BASE ) ; writel ( 0x00030b1b , aspeed -> base + OPB0_READ_ORDER1 ) ; writel ( 0x0011101b , aspeed -> base + OPB0_WRITE_ORDER1 ) ; writel ( 0x0c330f3f , aspeed -> base + OPB0_WRITE_ORDER2 ) ; writel ( 0x1 , aspeed -> base + OPB0_SELECT ) ; rc = opb_readl ( aspeed , ctrl_base + FSI_MVER , & raw ) ; if ( rc ) { dev_err ( & pdev -> dev , "failed to read hub version\n" ) ; err_release } reg = be32_to_cpu ( raw ) ; links = ( reg >> 8 ) & 0xff ; dev_info ( & pdev -> dev , "hub version %08x (%d links)\n" , reg , links ) ; aspeed -> master . dev . parent = & pdev -> dev ; aspeed -> master . dev . release = aspeed_master_release ; aspeed -> master . dev . of_node = of_node_get ( dev_of_node ( & pdev -> dev ) ) ; aspeed -> master . n_links = links ; aspeed -> master . read = aspeed_master_read ; aspeed -> master . write = aspeed_master_write ; aspeed -> master . send_break = aspeed_master_break ; aspeed -> master . term = aspeed_master_term ; aspeed -> master . link_enable = aspeed_master_link_enable ; dev_set_drvdata ( & pdev -> dev , aspeed ) ; mutex_init ( & aspeed -> lock ) ; aspeed_master_init ( aspeed ) ; rc = fsi_master_register ( & aspeed -> master ) ; if ( rc ) { err_release } get_device ( & aspeed -> master . dev ) ; return 0 ; err_release clk_disable_unprepare ( aspeed -> clk ) ; err_free_aspeed kfree ( aspeed ) ; return rc ; } 