void purge ( ) { register struct sactab * sp ; register struct sactab * savesp , * tsp ; sigset_t cset ; sigset_t tset ; debug ( "in purge" ) ; ( void ) sigprocmask ( SIG_SETMASK , NULL , & cset ) ; sp = savesp = Sactab ; while ( sp ) { if ( sp -> sc_valid ) { savesp = sp ; sp = sp -> sc_next ; continue ; } switch ( sp -> sc_sstate ) { case UNKNOWN : case ENABLED : case DISABLED : case STARTING : tset = cset ; ( void ) sigaddset ( & tset , SIGALRM ) ; ( void ) sigaddset ( & tset , SIGCLD ) ; ( void ) sigprocmask ( SIG_SETMASK , & tset , NULL ) ; if ( sendsig ( sp , SIGTERM ) ) { ( void ) sprintf ( Scratch , "could not send SIGTERM to<%s>" , sp -> sc_tag ) ; } else { ( void ) sprintf ( Scratch , "terminating<%s>" , sp -> sc_tag ) ; } log ( Scratch ) ; ( void ) sigdelset ( & tset , SIGALRM ) ; ( void ) sigprocmask ( SIG_SETMASK , & tset , NULL ) ; case STOPPING : ( void ) close ( sp -> sc_fd ) ; case NOTRUNNING : case FAILED : cleanutx ( sp ) ; tsp = sp ; if ( tsp == Sactab ) { Sactab = sp -> sc_next ; savesp = Sactab ; } else { savesp -> sc_next = sp -> sc_next ; } ( void ) sprintf ( Scratch , "purging<%s>" , sp -> sc_tag ) ; debug ( Scratch ) ; sp = sp -> sc_next ; free ( tsp -> sc_comment ) ; free ( tsp ) ; ( void ) sigprocmask ( SIG_SETMASK , & cset , NULL ) ; break ; } } } 