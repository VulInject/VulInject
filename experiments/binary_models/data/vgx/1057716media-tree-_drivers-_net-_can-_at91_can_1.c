static netdev_tx_t at91_start_xmit ( struct sk_buff * skb , struct net_device * dev ) { struct at91_priv * priv = netdev_priv ( dev ) ; struct net_device_stats * stats = & dev -> stats ; struct can_frame * cf = ( can_frame * ) skb -> data ; unsigned int mb , prio ; u32 reg_mid , reg_mcr ; if ( can_dropped_invalid_skb ( dev , skb ) ) { return NETDEV_TX_OK ; } mb = get_tx_next_mb ( priv ) ; prio = get_tx_next_prio ( priv ) ; if ( unlikely ( ! ( at91_read ( priv , AT91_MSR ( mb ) ) & AT91_MSR_MRDY ) ) ) { netif_stop_queue ( dev , NULL ) ; netdev_err ( dev , "BUG! TX buffer full when queue awake!\n" ) ; return NETDEV_TX_BUSY ; } reg_mid = at91_can_id_to_reg_mid ( cf -> can_id ) ; reg_mcr = ( ( cf -> can_id & CAN_RTR_FLAG ) ?AT91_MCR_MRTR : 0 ) | ( cf -> can_dlc << 16 ) | AT91_MCR_MTCR ; set_mb_mode ( priv , mb , AT91_MB_MODE_DISABLED ) ; at91_write ( priv , AT91_MID ( mb ) , reg_mid ) ; set_mb_mode_prio ( priv , mb , AT91_MB_MODE_TX , prio ) ; at91_write ( priv , AT91_MDL ( mb ) , * ( u32 * ) ( cf -> data + 0 ) ) ; at91_write ( priv , AT91_MDH ( mb ) , * ( u32 * ) ( cf -> data + 4 ) ) ; at91_write ( priv , AT91_MCR ( mb ) , reg_mcr ) ; stats -> tx_bytes += cf -> can_dlc ; can_put_echo_skb ( skb , dev , mb - get_mb_tx_first ( priv ) ) ; priv -> tx_next ++ ; if ( ! ( at91_read ( priv , AT91_MSR ( get_tx_next_mb ( priv ) ) ) & AT91_MSR_MRDY ) || ( priv -> tx_next & get_next_mask ( priv ) ) == 0 ) { netif_stop_queue ( dev ) ; } at91_write ( priv , AT91_IER , 1 << mb ) ; return NETDEV_TX_OK ; } 