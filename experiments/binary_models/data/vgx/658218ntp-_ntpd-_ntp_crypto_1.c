static int crypto_verify ( struct exten * ep , struct value * vp , struct peer * peer ) { EVP_PKEY * pkey ; EVP_MD_CTX ctx ; tstamp_t tstamp , tstamp1 = 0 ; tstamp_t fstamp , fstamp1 = 0 ; u_int vallen ; u_int siglen ; u_int opcode , len ; int i ; len = ntohl ( ep -> opcode ) & 0x0000ffff ; opcode = ntohl ( ep -> opcode ) & 0xffff0000 ; if ( opcode & CRYPTO_ERROR ) { return ( XEVNT_ERR ) ; } if ( len < VALUE_LEN ) { return ( XEVNT_LEN ) ; } if ( opcode == ( CRYPTO_AUTO | CRYPTO_RESP ) && ( peer -> pmode == MODE_BROADCAST || ( peer -> cast_flags & MDF_BCLNT ) ) ) { if ( ntohl ( ep -> associd ) != peer -> assoc ) { return ( XEVNT_ERR ) ; } } else { if ( ntohl ( ep -> associd ) != peer -> associd ) { return ( XEVNT_ERR ) ; } } vallen = ntohl ( ep -> vallen ) ; if ( vallen == 0 || vallen > MAX_VALLEN ) { return ( XEVNT_LEN ) ; } i = ( vallen + 3 ) / 4 ; siglen = ntohl ( ep -> pkt [ i ++ ] ) ; if ( siglen > MAX_VALLEN || len - VALUE_LEN < ( ( vallen + 3 ) / 4 ) * 4 || len - VALUE_LEN - ( ( vallen + 3 ) / 4 ) * 4 < ( ( siglen + 3 ) / 4 ) * 4 ) { return ( XEVNT_LEN ) ; } tstamp = ntohl ( ep -> tstamp , NULL ) ; fstamp = ntohl ( ep -> fstamp ) ; if ( tstamp == 0 ) { return ( XEVNT_TSP ) ; } if ( tstamp < fstamp ) { return ( XEVNT_TSP ) ; } if ( vp != NULL ) { tstamp1 = ntohl ( vp -> tstamp ) ; fstamp1 = ntohl ( vp -> fstamp ) ; if ( tstamp1 != 0 && fstamp1 != 0 ) { if ( tstamp < tstamp1 ) { return ( XEVNT_TSP ) ; } if ( ( tstamp < fstamp1 || fstamp < fstamp1 ) ) { return ( XEVNT_FSP ) ; } } } if ( opcode == ( CRYPTO_CERT | CRYPTO_RESP ) ) { return ( XEVNT_OK ) ; } if ( crypto_flags & peer -> crypto & CRYPTO_FLAG_PRIV ) { pkey = sign_pkey ; } else { pkey = peer -> pkey ; } if ( siglen == 0 || pkey == NULL || peer -> digest == NULL ) { return ( XEVNT_ERR ) ; } if ( siglen != ( u_int ) EVP_PKEY_size ( pkey ) ) { return ( XEVNT_SGL ) ; } EVP_VerifyInit ( & ctx , peer -> digest ) ; EVP_VerifyUpdate ( & ctx , ( u_char * ) & ep -> tstamp , vallen + 12 ) ; if ( EVP_VerifyFinal ( & ctx , ( u_char * ) & ep -> pkt [ i ] , siglen , pkey ) <= 0 ) { return ( XEVNT_SIG ) ; } if ( peer -> crypto & CRYPTO_FLAG_VRFY ) { peer -> crypto |= CRYPTO_FLAG_PROV ; } return ( XEVNT_OK ) ; } 