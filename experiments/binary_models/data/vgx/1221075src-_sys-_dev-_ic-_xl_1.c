void xl_init ( void * xsc ) { struct xl_softc * sc = xsc ; struct ifnet * ifp = & sc -> sc_arpcom . ac_if ; int s , i ; struct mii_data * mii = NULL ; s = splnet ( ) ; xl_stop ( sc ) ; xl_reset ( sc ) ; if ( sc -> xl_hasmii ) { mii = & sc -> sc_mii ; } if ( mii == NULL ) { CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_RX_RESET ) ; xl_wait ( sc ) ; } CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_TX_RESET ) ; xl_wait ( sc ) ; DELAY ( 10000 ) ; XL_SEL_WIN ( 2 ) ; for ( i = 0 ; i < ETHER_ADDR_LEN ; i ++ ) { CSR_WRITE_1 ( sc , XL_W2_STATION_ADDR_LO + i , sc -> sc_arpcom . ac_enaddr [ i ] ) ; } for ( i = 0 ; i < 3 ; i ++ ) { CSR_WRITE_2 ( sc , XL_W2_STATION_MASK_LO + ( i * 2 ) , 0 ) ; } CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_RX_RESET ) ; xl_wait ( sc ) ; CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_TX_RESET ) ; xl_wait ( sc ) ; if ( xl_list_rx_init ( sc ) == ENOBUFS ) { printf ( "%s: initialization failed: no " "memory for rx buffers\n" , sc -> sc_dev . dv_xname ) ; xl_stop ( sc ) ; splx ( s , NULL ) ; return ; } if ( sc -> xl_type == XL_TYPE_905B ) { xl_list_tx_init_90xB ( sc ) ; } else { xl_list_tx_init ( sc ) ; } CSR_WRITE_1 ( sc , XL_TX_FREETHRESH , XL_PACKET_SIZE >> 8 ) ; CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_TX_SET_START | sc -> xl_tx_thresh ) ; if ( sc -> xl_type == XL_TYPE_905B ) { CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_SET_TX_RECLAIM | ( XL_PACKET_SIZE >> 4 ) ) ; } xl_iff ( sc ) ; CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_UP_STALL ) ; xl_wait ( sc ) ; CSR_WRITE_4 ( sc , XL_UPLIST_PTR , sc -> sc_listmap -> dm_segs [ 0 ] . ds_addr + offsetof ( xl_list_data , xl_rx_list [ 0 ] ) ) ; CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_UP_UNSTALL ) ; xl_wait ( sc ) ; if ( sc -> xl_type == XL_TYPE_905B ) { CSR_WRITE_1 ( sc , XL_DOWN_POLL , 64 ) ; CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_DOWN_STALL ) ; xl_wait ( sc ) ; CSR_WRITE_4 ( sc , XL_DOWNLIST_PTR , sc -> sc_listmap -> dm_segs [ 0 ] . ds_addr + offsetof ( xl_list_data , xl_tx_list [ 0 ] ) ) ; CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_DOWN_UNSTALL ) ; xl_wait ( sc ) ; } XL_SEL_WIN ( 3 ) ; if ( sc -> xl_xcvr == XL_XCVR_COAX ) { CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_COAX_START ) ; } else { CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_COAX_STOP ) ; } if ( sc -> xl_type == XL_TYPE_905B ) { CSR_WRITE_2 ( sc , XL_W3_MAXPKTSIZE , XL_PACKET_SIZE ) ; } else { u_int8_t macctl ; macctl = CSR_READ_1 ( sc , XL_W3_MAC_CTRL ) ; macctl |= XL_MACCTRL_ALLOW_LARGE_PACK ; CSR_WRITE_1 ( sc , XL_W3_MAC_CTRL , macctl ) ; } CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_STATS_DISABLE ) ; sc -> xl_stats_no_timeout = 1 ; xl_stats_update ( sc ) ; sc -> xl_stats_no_timeout = 0 ; XL_SEL_WIN ( 4 ) ; CSR_WRITE_2 ( sc , XL_W4_NET_DIAG , XL_NETDIAG_UPPER_BYTES_ENABLE ) ; CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_STATS_ENABLE ) ; CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_INTR_ACK | 0xFF ) ; CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_STAT_ENB | XL_INTRS ) ; CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_INTR_ENB | XL_INTRS ) ; if ( sc -> intr_ack ) { * sc -> intr_ack ( sc ) ; } CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_RX_SET_THRESH | ( XL_PACKET_SIZE >> 2 ) ) ; CSR_WRITE_4 ( sc , XL_DMACTL , XL_DMACTL_UP_RX_EARLY ) ; CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_TX_ENABLE ) ; xl_wait ( sc ) ; CSR_WRITE_2 ( sc , XL_COMMAND , XL_CMD_RX_ENABLE ) ; xl_wait ( sc ) ; if ( mii != NULL ) { mii_mediachg ( mii ) ; } XL_SEL_WIN ( 7 ) ; ifp -> if_flags |= IFF_RUNNING ; ifq_clr_oactive ( & ifp -> if_snd ) ; splx ( s ) ; timeout_add_sec ( & sc -> xl_stsup_tmo , 1 ) ; } 