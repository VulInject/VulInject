static int musb_gadget_queue ( struct usb_ep * ep , struct usb_request * req , gfp_t gfp_flags ) { struct musb_ep * musb_ep ; struct musb_request * request ; struct musb * musb ; int status ; unsigned long lockflags ; if ( ! ep || ! req ) { return - EINVAL ; } if ( ! req -> buf ) { return - ENODATA ; } musb_ep = to_musb_ep ( ep ) ; musb = musb_ep -> musb ; request = to_musb_request ( req ) ; request -> musb = musb ; if ( request -> ep != musb_ep ) { return - EINVAL ; } status = pm_runtime_get ( musb -> controller ) ; if ( ( status != - EINPROGRESS ) && status < 0 ) { dev_err ( musb -> controller , "pm runtime get failed in %s\n" , __func__ ) ; pm_runtime_put_noidle ( musb -> controller ) ; return status ; } status = 0 ; trace_musb_req_enq ( request ) ; request -> request . actual = 0 ; request -> request . status = - EINPROGRESS ; request -> epnum = musb_ep -> current_epnum ; request -> tx = musb_ep -> is_in ; map_dma_buffer ( request , musb , musb_ep ) ; spin_lock_irqsave ( & musb -> lock , lockflags ) ; if ( ! musb_ep -> desc ) { musb_dbg ( musb , "req %p queued to %s while ep %s" , req , ep -> name , "disabled" ) ; status = - ESHUTDOWN ; unmap_dma_buffer ( request , musb ) ; unlock } list_add_tail ( & request -> list , & musb_ep -> req_list ) ; if ( ! musb_ep -> busy && & request -> list == musb_ep -> req_list . next ) { status = musb_queue_resume_work ( musb , musb_ep_restart_resume_work , request ) ; if ( status < 0 ) { dev_err ( musb -> controller , "%s resume work: %i\n" , __func__ , status ) ; list_del ( & request -> list ) ; } } unlock spin_unlock_irqrestore ( & musb -> lock , lockflags ) ; pm_runtime_mark_last_busy ( musb -> controller ) ; pm_runtime_put_autosuspend ( musb -> controller , NULL ) ; return status ; } 