static bool amt_send_membership_update ( struct amt_dev * amt , struct sk_buff * skb , bool v6 ) { struct amt_header_membership_update * amtmu ; struct socket * sock ; struct iphdr * iph ; struct flowi4 fl4 ; struct rtable * rt ; int err ; sock = rcu_dereference_bh ( amt -> sock ) ; if ( ! sock ) { return true ; } err = skb_cow_head ( skb , LL_RESERVED_SPACE ( amt -> dev ) + sizeof ( * amtmu ) + sizeof ( * iph ) + sizeof ( udphdr ) ) ; if ( err ) { return true ; } skb_reset_inner_headers ( skb ) ; fl4 . flowi4_oif = amt -> stream_dev -> ifindex ; fl4 . daddr = amt -> remote_ip ; fl4 . saddr = amt -> local_ip ; fl4 . flowi4_tos = AMT_TOS ; fl4 . flowi4_proto = IPPROTO_UDP ; rt = ip_route_output_key ( amt -> net , & fl4 ) ; if ( IS_ERR ( rt ) ) { netdev_dbg ( amt -> dev , "no route to %pI4\n" , & amt -> remote_ip ) ; return true ; } amtmu = skb_push ( skb , sizeof ( * amtmu ) ) ; amtmu -> version = 0 ; amtmu -> type = AMT_MSG_MEMBERSHIP_UPDATE ; amtmu -> reserved = 0 ; amtmu -> nonce = amt -> nonce ; amtmu -> response_mac = amt -> mac ; if ( ! v6 ) { skb_set_inner_protocol ( skb , htons ( ETH_P_IP ) ) ; } else { skb_set_inner_protocol ( skb , htons ( ETH_P_IPV6 ) ) ; } udp_tunnel_xmit_skb ( rt , sock -> sk , skb , fl4 . saddr , fl4 . daddr , AMT_TOS , ip4_dst_hoplimit ( & rt -> dst ) , 0 , amt -> gw_port , amt -> relay_port , false , false ) ; amt_update_gw_status ( amt , AMT_STATUS_SENT_UPDATE , true ) ; return false ; } 