int pvh_collect_headers ( struct sip_msg * msg ) { struct hdr_field * hf ; str name = STR_NULL ; str val = STR_NULL ; char hvals [ header_name_size ] [ header_value_size ] ; int idx = 0 , d_size = 0 ; str val_part = STR_NULL ; char * marker = NULL ; if ( pvh_hdrs_collected ( msg ) ) { LM_ERR ( "headers are already collected\n" ) ; return - 1 ; } if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) { LM_ERR ( "error parsing headers\n" ) ; return - 1 ; } for ( hf = msg -> headers ; hf ; hf = hf -> next ) { LM_DBG ( "collect header[%.*s]: %.*s\n" , hf -> name . len , hf -> name . s , hf -> body . len , hf -> body . s ) ; switch ( hf -> type ) { case HDR_FROM_T : name . len = _hdr_from . len ; name . s = _hdr_from . s ; LM_DBG ( "force [From] as key\n" ) ; break ; case HDR_TO_T : name . len = _hdr_to . len ; name . s = _hdr_to . s ; LM_DBG ( "force [To] as key\n" ) ; break ; default : name . len = hf -> name . len ; name . s = hf -> name . s ; } val . len = hf -> body . len ; val . s = hf -> body . s ; if ( ( marker = pvh_detect_split_char ( val . s ) ) != NULL && str_hash_case_get ( & split_headers , name . s , name . len ) ) { if ( pvh_split_values ( & val , hvals , & d_size , 1 , marker ) < 0 ) { LM_ERR ( "could not parse %.*s header comma separated " "value" , name . len , name . s ) ; return - 1 ; } for ( idx = 0 ; idx < d_size ; idx ++ ) { val_part . s = hvals [ idx ] ; val_part . len = strlen ( hvals [ idx ] ) ; if ( pvh_set_xavi ( msg , & xavi_name , & name , & val_part , SR_XTYPE_STR , 0 , 1 ) < 0 ) { return - 1 ; } } continue ; } if ( pvh_set_xavi ( msg , & xavi_name , & name , & val , SR_XTYPE_STR , 0 , 1 ) < 0 ) { return - 1 ; } } if ( pvh_set_xavi ( msg , & xavi_helper_xname , & xavi_helper_name , & xavi_name , SR_XTYPE_STR , 0 , 0 ) < 0 ) { return - 1 ; } pvh_hdrs_set_collected ( msg ) ; return 1 ; } 