static int __arm_lpae_map ( struct arm_lpae_io_pgtable * data , unsigned long iova , phys_addr_t paddr , size_t size , size_t pgcount , arm_lpae_iopte prot , int lvl , arm_lpae_iopte * ptep , gfp_t gfp , size_t * mapped ) { arm_lpae_iopte * cptep , pte ; size_t block_size = ARM_LPAE_BLOCK_SIZE ( lvl , data ) ; size_t tblsz = ARM_LPAE_GRANULE ( data ) ; struct io_pgtable_cfg * cfg = & data -> iop . cfg ; int ret = 0 , num_entries , max_entries , map_idx_start ; map_idx_start = ARM_LPAE_LVL_IDX ( iova , lvl , data ) ; ptep += map_idx_start ; if ( size == block_size ) { max_entries = ARM_LPAE_PTES_PER_TABLE ( data ) - map_idx_start ; num_entries = min_t ( int , pgcount , max_entries ) ; ret = arm_lpae_init_pte ( data , iova , paddr , prot , lvl , num_entries , ptep ) ; if ( ! ret ) { * mapped += num_entries * size ; } return ret ; } if ( WARN_ON ( lvl >= ARM_LPAE_MAX_LEVELS - 1 ) ) { return - EINVAL ; } pte = READ_ONCE ( * ptep ) ; if ( ! pte ) { cptep = __arm_lpae_alloc_pages ( tblsz , gfp , cfg ) ; pte = arm_lpae_install_table ( cptep , ptep , 0 , data ) ; if ( pte ) { __arm_lpae_free_pages ( cptep , tblsz , cfg ) ; } } if ( ! cfg -> coherent_walk && ! ( pte & ARM_LPAE_PTE_SW_SYNC ) ) { __arm_lpae_sync_pte ( ptep , 1 , cfg ) ; } if ( pte && ! iopte_leaf ( pte , lvl , data -> iop . fmt ) ) { cptep = iopte_deref ( pte , data ) ; } if ( pte ) { WARN_ON ( ! selftest_running ) ; return - EEXIST ; } return __arm_lpae_map ( data , iova , paddr , size , pgcount , prot , lvl + 1 , cptep , gfp , mapped ) ; } 