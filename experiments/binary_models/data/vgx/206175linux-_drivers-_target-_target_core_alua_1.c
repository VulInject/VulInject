sense_reason_t target_emulate_report_target_port_groups ( struct se_cmd * cmd ) { struct se_device * dev = cmd -> se_dev ; struct t10_alua_tg_pt_gp * tg_pt_gp ; struct se_lun * lun ; unsigned char * buf ; u32 rd_len = 0 , off ; int ext_hdr = ( cmd -> t_task_cdb [ 1 ] & 0x20 ) ; if ( ext_hdr != 0 ) { off = 8 ; } else { off = 4 ; } if ( cmd -> data_length < off ) { pr_warn ( "REPORT TARGET PORT GROUPS allocation length %u too" " small for %s header\n" , cmd -> data_length , ( ext_hdr ) ?"extended" : "normal" ) ; return TCM_INVALID_CDB_FIELD ; } buf = transport_kmap_data_sg ( cmd ) ; if ( ! buf ) { return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE ; } spin_lock ( & dev -> t10_alua . tg_pt_gps_lock ) ; list_for_each_entry ( , , ) { if ( ( off + 8 + ( tg_pt_gp -> tg_pt_gp_members * 4 ) ) > cmd -> data_length ) { rd_len += 8 + ( tg_pt_gp -> tg_pt_gp_members * 4 ) ; continue ; } if ( tg_pt_gp -> tg_pt_gp_pref ) { buf [ off ] = 0x80 ; } buf [ off ++ ] |= tg_pt_gp -> tg_pt_gp_alua_access_state & 0xff ; buf [ off ++ ] |= tg_pt_gp -> tg_pt_gp_alua_supported_states ; put_unaligned_be16 ( tg_pt_gp -> tg_pt_gp_id , & buf [ off ] ) ; off += 2 ; off ++ ; buf [ off ++ ] = ( tg_pt_gp -> tg_pt_gp_alua_access_status & 0xff ) ; buf [ off ++ ] = 0x00 ; buf [ off ++ ] = ( tg_pt_gp -> tg_pt_gp_members & 0xff ) ; rd_len += 8 ; spin_lock ( & tg_pt_gp -> tg_pt_gp_lock ) ; list_for_each_entry ( , , ) { off += 2 ; put_unaligned_be16 ( lun -> lun_rtpi , & buf [ off ] ) ; off += 2 ; rd_len += 4 ; } spin_unlock ( & tg_pt_gp -> tg_pt_gp_lock ) ; } spin_unlock ( & dev -> t10_alua . tg_pt_gps_lock ) ; put_unaligned_be32 ( rd_len , & buf [ 0 ] ) ; if ( ext_hdr != 0 ) { buf [ 4 ] = 0x10 ; rcu_read_lock ( ) ; tg_pt_gp = rcu_dereference ( cmd -> se_lun -> lun_tg_pt_gp ) ; if ( tg_pt_gp ) { buf [ 5 ] = tg_pt_gp -> tg_pt_gp_implicit_trans_secs ; } rcu_read_unlock ( ) ; } transport_kunmap_data_sg ( cmd ) ; target_complete_cmd_with_length ( cmd , SAM_STAT_GOOD , rd_len + 4 ) ; return 0 ; } 