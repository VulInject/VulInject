ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL roken_detach_prep ( int argc , char * * argv , char * special_arg ) { ssize_t bytes ; size_t i ; pid_t child ; char * * new_argv ; char buf [ 1 ] ; char fildes [ 21 ] ; int status ; pipefds [ 0 ] = - 1 ; pipefds [ 1 ] = - 1 ; if ( _pipe ( pipefds , 4 , _O_NOINHERIT | O_BINARY ) == - 1 ) { err ( 1 , "failed to setup to detach daemon (_pipe failed)" ) ; } if ( pipe ( pipefds ) == - 1 ) { err ( 1 , "failed to setup to detach daemon (pipe failed)" ) ; } new_argv = calloc ( argc + 3 , sizeof ( * new_argv ) ) ; if ( new_argv == NULL ) { err ( 1 , "Out of memory" ) ; } pipefds [ 1 ] = _dup ( pipefds [ 1 ] ) ; if ( pipefds [ 1 ] == - 1 ) { err ( 1 , "Out of memory" ) ; } ( void ) fcntl ( pipefds [ 1 ] , F_SETFD , fcntl ( pipefds [ 1 ] , F_GETFD & ~ ( O_CLOEXEC ) ) ) ; if ( snprintf ( fildes , sizeof ( fildes ) , "%d" , pipefds [ 1 ] ) >= sizeof ( fildes ) ) { err ( 1 , "failed to setup to detach daemon (fd number %d too large)" , pipefds [ 1 ] ) ; } new_argv [ 0 ] = argv [ 0 ] ; new_argv [ 1 ] = special_arg ; new_argv [ 2 ] = fildes ; for ( i = 1 ; argv [ i ] != NULL ; i ++ ) { new_argv [ i + 2 ] = argv [ i ] ; } new_argv [ argc + 2 ] = NULL ; fflush ( stdout ) ; child = fork ( ) ; { intptr_t child_handle ; _flushall ( ) ; child_handle = spawnvp ( _P_NOWAIT , argv [ 0 ] , new_argv ) ; if ( child_handle == - 1 ) { child = ( pid_t ) - 1 ; } else { child = GetProcessId ( ( HANDLE ) child_handle ) ; } } if ( child == ( pid_t ) - 1 ) { err ( 1 , "failed to setup to fork daemon (fork failed)" ) ; } if ( child == 0 ) { int fd ; ( void ) close ( pipefds [ 0 ] ) ; pipefds [ 0 ] = - 1 ; fd = open ( _PATH_DEVNULL , O_RDWR , 0 ) ; if ( fd == - 1 ) { err ( 1 , "failed to open /dev/null" ) ; } ( void ) dup2 ( fd , STDIN_FILENO ) ; if ( fd > STDERR_FILENO ) { ( void ) close ( fd ) ; } if ( getenv ( "ROKEN_DETACH_USE_EXEC" ) ) { ( void ) execvp ( argv [ 0 ] , new_argv ) ; err ( 1 , "failed to self-re-exec" ) ; } return pipefds [ 1 ] ; } free ( new_argv ) ; ( void ) close ( pipefds [ 1 ] ) ; pipefds [ 1 ] = - 1 ; { bytes = read ( pipefds [ 0 ] , buf , sizeof ( buf ) ) ; } bytes == - 1 && errno == EINTR ; ( void ) close ( pipefds [ 0 ] ) ; pipefds [ 0 ] = - 1 ; if ( bytes == - 1 ) { err ( 1 , "failed to setup daemon child (read from child pipe)" ) ; } if ( bytes == 0 ) { warnx ( "daemon child preparation failed, waiting for child" ) ; status = wait_for_process ( child ) ; if ( SE_IS_ERROR ( status ) || SE_PROCSTATUS ( status ) != 0 ) { errx ( SE_PROCSTATUS ( status ) , "daemon child preparation failed (child exited)" ) ; } } _exit ( 0 ) ; return - 1 ; } 