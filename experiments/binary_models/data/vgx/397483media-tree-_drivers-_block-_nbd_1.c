static int nbd_genl_connect ( struct sk_buff * skb , struct genl_info * info ) { struct nbd_device * nbd = NULL ; struct nbd_config * config ; int index = - 1 ; int ret ; bool put_dev = false ; if ( info -> attrs [ NBD_ATTR_INDEX ] ) { index = nla_get_u32 ( info -> attrs [ NBD_ATTR_INDEX ] ) ; } if ( ! info -> attrs [ NBD_ATTR_SOCKETS ] ) { printk ( KERN_ERR "nbd: must specify at least one socket\n" ) ; return - EINVAL ; } if ( ! info -> attrs [ NBD_ATTR_SIZE_BYTES ] ) { printk ( KERN_ERR "nbd: must specify a size in bytes for the device\n" ) ; return - EINVAL ; } again mutex_lock ( & nbd_index_mutex ) ; if ( index == - 1 ) { ret = idr_for_each ( & nbd_index_idr , & find_free_cb , & nbd ) ; if ( ret == 0 ) { int new_index ; new_index = nbd_dev_add ( - 1 ) ; if ( new_index < 0 ) { mutex_unlock ( & nbd_index_mutex ) ; printk ( KERN_ERR "nbd: failed to add new device\n" ) ; return ret ; } nbd = idr_find ( & nbd_index_idr , new_index ) ; } } else { nbd = idr_find ( & nbd_index_idr , index ) ; } if ( ! nbd ) { printk ( KERN_ERR "nbd: couldn't find device at index %d\n" , index ) ; mutex_unlock ( & nbd_index_mutex ) ; return - EINVAL ; } if ( ! refcount_inc_not_zero ( & nbd -> refs ) ) { mutex_unlock ( & nbd_index_mutex ) ; if ( index == - 1 ) { again } printk ( KERN_ERR "nbd: device at index %d is going down\n" , index ) ; return - EINVAL ; } mutex_unlock ( & nbd_index_mutex ) ; mutex_lock ( & nbd -> config_lock ) ; if ( refcount_read ( & nbd -> config_refs ) ) { mutex_unlock ( & nbd -> config_lock ) ; nbd_put ( nbd ) ; if ( index == - 1 ) { again } printk ( KERN_ERR "nbd: nbd%d already in use\n" , index ) ; return - EBUSY ; } if ( WARN_ON ( nbd -> config ) ) { mutex_unlock ( & nbd -> config_lock ) ; nbd_put ( nbd ) ; return - EINVAL ; } config = nbd -> config = nbd_alloc_config ( ) ; if ( ! nbd -> config ) { mutex_unlock ( & nbd -> config_lock ) ; nbd_put ( nbd ) ; printk ( KERN_ERR "nbd: couldn't allocate config\n" ) ; return - ENOMEM ; } refcount_set ( & nbd -> config_refs , 1 ) ; set_bit ( NBD_BOUND , & config -> runtime_flags ) ; if ( info -> attrs [ NBD_ATTR_SIZE_BYTES ] ) { u64 bytes = nla_get_u64 ( info -> attrs [ NBD_ATTR_SIZE_BYTES ] ) ; nbd_size_set ( nbd , config -> blksize , div64_u64 ( bytes , config -> blksize ) ) ; } if ( info -> attrs [ NBD_ATTR_BLOCK_SIZE_BYTES ] ) { u64 bsize = nla_get_u64 ( info -> attrs [ NBD_ATTR_BLOCK_SIZE_BYTES ] ) ; nbd_size_set ( nbd , bsize , div64_u64 ( config -> bytesize , bsize ) ) ; } if ( info -> attrs [ NBD_ATTR_TIMEOUT ] ) { u64 timeout = nla_get_u64 ( info -> attrs [ NBD_ATTR_TIMEOUT ] ) ; nbd -> tag_set . timeout = timeout * HZ ; blk_queue_rq_timeout ( nbd -> disk -> queue , timeout * HZ ) ; } if ( info -> attrs [ NBD_ATTR_DEAD_CONN_TIMEOUT ] ) { config -> dead_conn_timeout = nla_get_u64 ( info -> attrs [ NBD_ATTR_DEAD_CONN_TIMEOUT ] ) ; config -> dead_conn_timeout *= HZ ; } if ( info -> attrs [ NBD_ATTR_SERVER_FLAGS ] ) { config -> flags = nla_get_u64 ( info -> attrs [ NBD_ATTR_SERVER_FLAGS ] ) ; } if ( info -> attrs [ NBD_ATTR_CLIENT_FLAGS ] ) { u64 flags = nla_get_u64 ( info -> attrs [ NBD_ATTR_CLIENT_FLAGS ] ) ; if ( flags & NBD_CFLAG_DESTROY_ON_DISCONNECT ) { set_bit ( NBD_DESTROY_ON_DISCONNECT , & config -> runtime_flags ) ; put_dev = true ; } } if ( info -> attrs [ NBD_ATTR_SOCKETS ] ) { struct nlattr * attr ; int rem , fd ; nla_for_each_nested ( , , ) { struct nlattr * socks [ NBD_SOCK_MAX + 1 ] ; if ( nla_type ( attr ) != NBD_SOCK_ITEM ) { printk ( KERN_ERR "nbd: socks must be embedded in a SOCK_ITEM attr\n" ) ; ret = - EINVAL ; out } ret = nla_parse_nested ( socks , NBD_SOCK_MAX , attr , nbd_sock_policy , info -> extack ) ; if ( ret != 0 ) { printk ( KERN_ERR "nbd: error processing sock list\n" ) ; ret = - EINVAL ; out } if ( ! socks [ NBD_SOCK_FD ] ) { continue ; } fd = ( int ) nla_get_u32 ( socks [ NBD_SOCK_FD ] ) ; ret = nbd_add_socket ( nbd , fd , true ) ; if ( ret ) { out } } } ret = nbd_start_device ( nbd ) ; out mutex_unlock ( & nbd -> config_lock ) ; if ( ! ret ) { set_bit ( NBD_HAS_CONFIG_REF , & config -> runtime_flags ) ; refcount_inc ( & nbd -> config_refs ) ; nbd_connect_reply ( info , nbd -> index ) ; } nbd_config_put ( nbd ) ; if ( put_dev ) { nbd_put ( nbd ) ; } return ret ; } 