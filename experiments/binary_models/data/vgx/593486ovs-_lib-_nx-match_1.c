static enum ofperr nx_pull_raw ( const uint8_t * p , unsigned int match_len , bool strict , bool pipeline_fields_only , struct match * match , ovs_be64 * cookie , ovs_be64 * cookie_mask , const struct tun_table * tun_table , const struct vl_mff_map * vl_mff_map ) { ovs_assert ( ( cookie != NULL ) == ( cookie_mask != NULL ) ) ; match_init_catchall ( match ) ; match -> flow . tunnel . metadata . tab = tun_table ; if ( cookie ) { * cookie = * cookie_mask = htonll ( 0 ) ; } struct ofpbuf b = ofpbuf_const_initializer ( p , match_len ) ; while ( b . size ) { const uint8_t * pos = b . data ; const struct mf_field * field ; union mf_value value ; union mf_value mask ; enum ofperr error ; error = nx_pull_match_entry ( & b , cookie != NULL , vl_mff_map , & field , & value , & mask ) ; if ( error ) { if ( error == OFPERR_OFPBMC_BAD_FIELD && ! strict ) { continue ; } } if ( ! field ) { if ( ! cookie ) { error = OFPERR_OFPBMC_BAD_FIELD ; } if ( * cookie_mask ) { error = OFPERR_OFPBMC_DUP_FIELD ; } else { * cookie = value . be64 ; * cookie_mask = mask . be64 ; } } if ( strict && ! mf_are_match_prereqs_ok ( field , match ) ) { error = OFPERR_OFPBMC_BAD_PREREQ ; } if ( ! mf_is_all_wild ( field , & match -> wc ) ) { error = OFPERR_OFPBMC_DUP_FIELD ; } if ( pipeline_fields_only && ! mf_is_pipeline_field ( field ) ) { error = OFPERR_OFPBRC_PIPELINE_FIELDS_ONLY ; } else { char * err_str ; mf_set ( field , & value , & mask , match , & err_str ) ; if ( err_str ) { VLOG_DBG_RL ( & rl , "error parsing OXM at offset %" PRIdPTR " " "within match (%s)" , pos - p , err_str ) ; return OFPERR_OFPBMC_BAD_VALUE ; } match_add_ethernet_prereq ( match , field ) ; } if ( error ) { VLOG_DBG_RL ( & rl , "error parsing OXM at offset %" PRIdPTR " " "within match (%s)" , pos - p , ofperr_to_string ( error ) ) ; return error ; } } match -> flow . tunnel . metadata . tab = NULL ; return 0 ; } 