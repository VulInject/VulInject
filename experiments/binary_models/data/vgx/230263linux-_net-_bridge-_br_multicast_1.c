static struct sk_buff * br_ip4_multicast_alloc_query ( struct net_bridge_mcast * brmctx , struct net_bridge_mcast_port * pmctx , struct net_bridge_port_group * pg , __be32 ip_dst , __be32 group , bool with_srcs , bool over_lmqt , u8 sflag , u8 * igmp_type , bool * need_rexmit ) { struct net_bridge_port * p = pg ?pg -> key . port : NULL ; struct net_bridge_group_src * ent ; size_t pkt_size , igmp_hdr_size ; unsigned long now = jiffies ; struct igmpv3_query * ihv3 ; void * csum_start = NULL ; __sum16 * csum = NULL ; struct sk_buff * skb ; struct igmphdr * ih ; struct ethhdr * eth ; unsigned long lmqt ; struct iphdr * iph ; u16 lmqt_srcs = 0 ; igmp_hdr_size = sizeof ( * ih ) ; if ( brmctx -> multicast_igmp_version == 3 ) { igmp_hdr_size = sizeof ( * ihv3 ) ; if ( pg && with_srcs ) { lmqt = now + ( brmctx -> multicast_last_member_interval * brmctx -> multicast_last_member_count ) ; hlist_for_each_entry ( , , ) { if ( over_lmqt == time_after ( ent -> timer . expires , lmqt ) && ent -> src_query_rexmit_cnt > 0 ) { lmqt_srcs ++ ; } } if ( ! lmqt_srcs ) { return NULL ; } igmp_hdr_size += lmqt_srcs * sizeof ( __be32 ) ; } } pkt_size = sizeof ( * eth ) + sizeof ( * iph ) + 4 + igmp_hdr_size ; if ( ( p && pkt_size > p -> dev -> mtu ) || pkt_size > brmctx -> br -> dev -> mtu ) { return NULL ; } skb = netdev_alloc_skb_ip_align ( brmctx -> br -> dev , pkt_size ) ; if ( ! skb ) { out } __br_multicast_query_handle_vlan ( brmctx , pmctx , skb ) ; skb -> protocol = htons ( ETH_P_IP , NULL ) ; skb_reset_mac_header ( skb ) ; eth = eth_hdr ( skb ) ; ether_addr_copy ( eth -> h_source , brmctx -> br -> dev -> dev_addr ) ; ip_eth_mc_map ( ip_dst , eth -> h_dest ) ; eth -> h_proto = htons ( ETH_P_IP ) ; skb_put ( skb , sizeof ( * eth ) ) ; skb_set_network_header ( skb , skb -> len ) ; iph = ip_hdr ( skb ) ; iph -> tot_len = htons ( pkt_size - sizeof ( * eth ) ) ; iph -> version = 4 ; iph -> ihl = 6 ; iph -> tos = 0xc0 ; iph -> id = 0 ; iph -> frag_off = htons ( IP_DF ) ; iph -> ttl = 1 ; iph -> protocol = IPPROTO_IGMP ; iph -> saddr = br_opt_get ( brmctx -> br , BROPT_MULTICAST_QUERY_USE_IFADDR ) ?inet_select_addr ( brmctx -> br -> dev , 0 , RT_SCOPE_LINK ) : 0 ; iph -> daddr = ip_dst ; ( ( u8 * ) & iph [ 1 ] ) [ 0 ] = IPOPT_RA ; ( ( u8 * ) & iph [ 1 ] ) [ 1 ] = 4 ; ( ( u8 * ) & iph [ 1 ] ) [ 2 ] = 0 ; ( ( u8 * ) & iph [ 1 ] ) [ 3 ] = 0 ; ip_send_check ( iph ) ; skb_put ( skb , 24 ) ; skb_set_transport_header ( skb , skb -> len ) ; * igmp_type = IGMP_HOST_MEMBERSHIP_QUERY ; switch ( brmctx -> multicast_igmp_version ) { case 2 : ih = igmp_hdr ( skb ) ; ih -> type = IGMP_HOST_MEMBERSHIP_QUERY ; ih -> code = ( group ?brmctx -> multicast_last_member_interval : brmctx -> multicast_query_response_interval ) / ( HZ / IGMP_TIMER_SCALE ) ; ih -> group = group ; ih -> csum = 0 ; csum = & ih -> csum ; csum_start = ( void * ) ih ; break ; case 3 : ihv3 = igmpv3_query_hdr ( skb ) ; ihv3 -> type = IGMP_HOST_MEMBERSHIP_QUERY ; ihv3 -> code = ( group ?brmctx -> multicast_last_member_interval : brmctx -> multicast_query_response_interval ) / ( HZ / IGMP_TIMER_SCALE ) ; ihv3 -> group = group ; ihv3 -> qqic = brmctx -> multicast_query_interval / HZ ; ihv3 -> nsrcs = htons ( lmqt_srcs ) ; ihv3 -> resv = 0 ; ihv3 -> suppress = sflag ; ihv3 -> qrv = 2 ; ihv3 -> csum = 0 ; csum = & ihv3 -> csum ; csum_start = ( void * ) ihv3 ; if ( ! pg || ! with_srcs ) { break ; } lmqt_srcs = 0 ; hlist_for_each_entry ( , , ) { if ( over_lmqt == time_after ( ent -> timer . expires , lmqt ) && ent -> src_query_rexmit_cnt > 0 ) { ihv3 -> srcs [ lmqt_srcs ++ ] = ent -> addr . src . ip4 ; ent -> src_query_rexmit_cnt -- ; if ( need_rexmit && ent -> src_query_rexmit_cnt ) { * need_rexmit = true ; } } } if ( WARN_ON ( lmqt_srcs != ntohs ( ihv3 -> nsrcs ) ) ) { kfree_skb ( skb ) ; return NULL ; } break ; } if ( WARN_ON ( ! csum || ! csum_start ) ) { kfree_skb ( skb ) ; return NULL ; } * csum = ip_compute_csum ( csum_start , igmp_hdr_size ) ; skb_put ( skb , igmp_hdr_size ) ; __skb_pull ( skb , sizeof ( * eth ) ) ; out return skb ; } 