static struct vga_device * __vga_tryget ( struct vga_device * vgadev , unsigned int rsrc ) { struct device * dev = & vgadev -> pdev -> dev ; unsigned int wants , legacy_wants , match ; struct vga_device * conflict ; unsigned int pci_bits ; u32 flags = 0 ; if ( ( rsrc & VGA_RSRC_NORMAL_IO ) && ( vgadev -> decodes & VGA_RSRC_LEGACY_IO ) ) { rsrc |= VGA_RSRC_LEGACY_IO ; } if ( ( rsrc & VGA_RSRC_NORMAL_MEM ) && ( vgadev -> decodes & VGA_RSRC_LEGACY_MEM ) ) { rsrc |= VGA_RSRC_LEGACY_MEM ; } vgaarb_dbg ( dev , "%s: %d\n" , __func__ , rsrc ) ; vgaarb_dbg ( dev , "%s: owns: %d\n" , __func__ , vgadev -> owns ) ; wants = rsrc & ~ vgadev -> owns ; if ( wants == 0 ) { lock_them } legacy_wants = wants & VGA_RSRC_LEGACY_MASK ; if ( legacy_wants == 0 ) { enable_them } list_for_each_entry ( , , ) { unsigned int lwants = legacy_wants ; unsigned int change_bridge = 0 ; if ( vgadev == conflict ) { continue ; } if ( ! vga_conflicts ( vgadev -> pdev , conflict -> pdev ) ) { continue ; } if ( vgadev -> pdev -> bus != conflict -> pdev -> bus ) { change_bridge = 1 ; lwants = VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM ; } if ( conflict -> locks & lwants ) { return conflict ; } match = lwants & conflict -> owns ; flags = 0 ; pci_bits = 0 ; if ( ! conflict -> bridge_has_one_vga ) { if ( ( match & conflict -> decodes ) & VGA_RSRC_LEGACY_MEM ) { pci_bits |= PCI_COMMAND_MEMORY ; } if ( ( match & conflict -> decodes ) & VGA_RSRC_LEGACY_IO ) { pci_bits |= PCI_COMMAND_IO ; } if ( pci_bits ) { vga_irq_set_state ( conflict , false ) ; flags |= PCI_VGA_STATE_CHANGE_DECODES ; } } if ( change_bridge ) { flags |= PCI_VGA_STATE_CHANGE_BRIDGE ; } pci_set_vga_state ( conflict -> pdev , false , pci_bits , flags ) ; conflict -> owns &= ~ match ; if ( pci_bits & PCI_COMMAND_MEMORY ) { conflict -> owns &= ~ VGA_RSRC_NORMAL_MEM ; } if ( pci_bits & PCI_COMMAND_IO ) { conflict -> owns &= ~ VGA_RSRC_NORMAL_IO ; } } enable_them flags = 0 ; pci_bits = 0 ; if ( ! vgadev -> bridge_has_one_vga ) { flags |= PCI_VGA_STATE_CHANGE_DECODES ; if ( wants & ( VGA_RSRC_LEGACY_MEM | VGA_RSRC_NORMAL_MEM ) ) { pci_bits |= PCI_COMMAND_MEMORY ; } if ( wants & ( VGA_RSRC_LEGACY_IO | VGA_RSRC_NORMAL_IO ) ) { pci_bits |= PCI_COMMAND_IO ; } } if ( wants & VGA_RSRC_LEGACY_MASK ) { flags |= PCI_VGA_STATE_CHANGE_BRIDGE ; } pci_set_vga_state ( vgadev -> pdev , true , pci_bits , flags ) ; if ( ! vgadev -> bridge_has_one_vga ) { vga_irq_set_state ( vgadev , true ) ; } vgadev -> owns |= wants ; lock_them vgadev -> locks |= ( rsrc & VGA_RSRC_LEGACY_MASK ) ; if ( rsrc & VGA_RSRC_LEGACY_IO ) { vgadev -> io_lock_cnt ++ ; } if ( rsrc & VGA_RSRC_LEGACY_MEM ) { vgadev -> mem_lock_cnt ++ ; } if ( rsrc & VGA_RSRC_NORMAL_IO ) { vgadev -> io_norm_cnt ++ ; } if ( rsrc & VGA_RSRC_NORMAL_MEM ) { vgadev -> mem_norm_cnt ++ ; } return NULL ; } 