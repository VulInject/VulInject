static int br_mdb_fill_info ( struct sk_buff * skb , struct netlink_callback * cb , struct net_device * dev ) { int idx = 0 , s_idx = cb -> args [ 1 ] , err = 0 , pidx = 0 , s_pidx = cb -> args [ 2 ] ; struct net_bridge * br = netdev_priv ( dev ) ; struct net_bridge_mdb_entry * mp ; struct nlattr * nest , * nest2 ; if ( ! br_opt_get ( br , BROPT_MULTICAST_ENABLED ) ) { return 0 ; } nest = nla_nest_start_noflag ( skb , MDBA_MDB ) ; hlist_for_each_entry_rcu ( , , ) { struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; if ( idx < s_idx ) { skip } nest2 = nla_nest_start_noflag ( skb , MDBA_MDB_ENTRY ) ; if ( ! nest2 ) { err = - EMSGSIZE ; break ; } if ( ! s_pidx && mp -> host_joined ) { err = __mdb_fill_info ( skb , mp , NULL ) ; if ( err ) { nla_nest_cancel ( skb , nest2 ) ; break ; } } for ( pp = & mp -> ports ; ( p = rcu_dereference ( * pp ) ) != NULL ; pp = & p -> next ) { if ( ! p -> key . port ) { continue ; } if ( pidx < s_pidx ) { skip_pg } err = __mdb_fill_info ( skb , mp , p ) ; if ( err ) { nla_nest_end ( skb , nest2 ) ; out } skip_pg pidx ++ ; } pidx = 0 ; s_pidx = 0 ; nla_nest_end ( skb , nest2 ) ; skip idx ++ ; } out cb -> args [ 1 ] = idx ; cb -> args [ 2 ] = pidx ; nla_nest_end ( skb , nest ) ; return err ; } 