acpi_status acpi_ds_call_control_method ( struct acpi_thread_state * thread , struct acpi_walk_state * this_walk_state , union acpi_parse_object * op ) { acpi_status status ; struct acpi_namespace_node * method_node ; struct acpi_walk_state * next_walk_state = NULL ; union acpi_operand_object * obj_desc ; struct acpi_evaluate_info * info ; u32 i ; ACPI_FUNCTION_TRACE_PTR ( ds_call_control_method , this_walk_state ) ; ACPI_DEBUG_PRINT ( ( ACPI_DB_DISPATCH , "Calling method %p, currentstate=%p\n" , this_walk_state -> prev_op , this_walk_state ) ) ; method_node = this_walk_state -> method_call_node ; if ( ! method_node ) { return_ACPI_STATUS ( AE_NULL_ENTRY ) ; } obj_desc = acpi_ns_get_attached_object ( method_node ) ; if ( ! obj_desc ) { return_ACPI_STATUS ( AE_NULL_OBJECT ) ; } status = acpi_ds_begin_method_execution ( method_node , obj_desc , this_walk_state ) ; if ( ACPI_FAILURE ( status ) ) { return_ACPI_STATUS ( status ) ; } next_walk_state = acpi_ds_create_walk_state ( obj_desc -> method . owner_id , NULL , obj_desc , thread ) ; if ( ! next_walk_state ) { status = AE_NO_MEMORY ; cleanup } this_walk_state -> operands [ this_walk_state -> num_operands ] = NULL ; info = ACPI_ALLOCATE_ZEROED ( sizeof ( acpi_evaluate_info ) ) ; if ( ! info ) { status = AE_NO_MEMORY ; cleanup } info -> parameters = & this_walk_state -> operands [ 0 ] ; status = acpi_ds_init_aml_walk ( next_walk_state , NULL , method_node , obj_desc -> method . aml_start , obj_desc -> method . aml_length , info , ACPI_IMODE_EXECUTE ) ; ACPI_FREE ( info ) ; if ( ACPI_FAILURE ( status ) ) { cleanup } for ( i = 0 ; i < obj_desc -> method . param_count ; i ++ ) { acpi_ut_remove_reference ( this_walk_state -> operands [ i ] , NULL ) ; this_walk_state -> operands [ i ] = NULL ; } this_walk_state -> num_operands = 0 ; ACPI_DEBUG_PRINT ( ( ACPI_DB_DISPATCH , "**** Begin nested execution of [%4.4s] **** WalkState=%p\n" , method_node -> name . ascii , next_walk_state ) ) ; if ( obj_desc -> method . info_flags & ACPI_METHOD_INTERNAL_ONLY ) { status = obj_desc -> method . dispatch . implementation ( next_walk_state ) ; if ( status == AE_OK ) { status = AE_CTRL_TERMINATE ; } } return_ACPI_STATUS ( status ) ; cleanup acpi_ds_terminate_control_method ( obj_desc , next_walk_state ) ; acpi_ds_delete_walk_state ( next_walk_state ) ; return_ACPI_STATUS ( status ) ; } 