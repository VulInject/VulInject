static void handle_bar_write ( unsigned int index , struct mdev_state * mdev_state , u16 offset , u8 * buf , u32 count ) { u8 data = * buf ; switch ( offset ) { case UART_TX : if ( mdev_state -> s [ index ] . dlab ) { mdev_state -> s [ index ] . divisor |= data ; break ; } mutex_lock ( & mdev_state -> rxtx_lock ) ; if ( mdev_state -> s [ index ] . rxtx . count < mdev_state -> s [ index ] . max_fifo_size ) { mdev_state -> s [ index ] . rxtx . fifo [ mdev_state -> s [ index ] . rxtx . head ] = data ; mdev_state -> s [ index ] . rxtx . count ++ ; CIRCULAR_BUF_INC_IDX ( mdev_state -> s [ index ] . rxtx . head ) ; mdev_state -> s [ index ] . overrun = false ; if ( ( mdev_state -> s [ index ] . uart_reg [ UART_IER ] & UART_IER_RDI ) && ( mdev_state -> s [ index ] . rxtx . count == mdev_state -> s [ index ] . intr_trigger_level ) ) { pr_err ( "Serial port %d: Fifo level trigger\n" , index ) ; mtty_trigger_interrupt ( mdev_state , NULL ) ; } } else { pr_err ( "Serial port %d: Buffer Overflow\n" , index ) ; mdev_state -> s [ index ] . overrun = true ; if ( mdev_state -> s [ index ] . uart_reg [ UART_IER ] & UART_IER_RLSI ) { mtty_trigger_interrupt ( mdev_state ) ; } } mutex_unlock ( & mdev_state -> rxtx_lock ) ; break ; case UART_IER : if ( mdev_state -> s [ index ] . dlab ) { mdev_state -> s [ index ] . divisor |= ( u16 ) data << 8 ; } else { mdev_state -> s [ index ] . uart_reg [ offset ] = data ; mutex_lock ( & mdev_state -> rxtx_lock ) ; if ( ( data & UART_IER_THRI ) && ( mdev_state -> s [ index ] . rxtx . head == mdev_state -> s [ index ] . rxtx . tail ) ) { pr_err ( "Serial port %d: IER_THRI write\n" , index ) ; mtty_trigger_interrupt ( mdev_state ) ; } mutex_unlock ( & mdev_state -> rxtx_lock ) ; } break ; case UART_FCR : mdev_state -> s [ index ] . fcr = data ; mutex_lock ( & mdev_state -> rxtx_lock ) ; if ( data & ( UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT ) ) { mdev_state -> s [ index ] . rxtx . count = 0 ; mdev_state -> s [ index ] . rxtx . head = 0 ; mdev_state -> s [ index ] . rxtx . tail = 0 ; } mutex_unlock ( & mdev_state -> rxtx_lock ) ; switch ( data & UART_FCR_TRIGGER_MASK ) { case UART_FCR_TRIGGER_1 : mdev_state -> s [ index ] . intr_trigger_level = 1 ; break ; case UART_FCR_TRIGGER_4 : mdev_state -> s [ index ] . intr_trigger_level = 4 ; break ; case UART_FCR_TRIGGER_8 : mdev_state -> s [ index ] . intr_trigger_level = 8 ; break ; case UART_FCR_TRIGGER_14 : mdev_state -> s [ index ] . intr_trigger_level = 14 ; break ; } mdev_state -> s [ index ] . intr_trigger_level = 1 ; if ( data & UART_FCR_ENABLE_FIFO ) { mdev_state -> s [ index ] . max_fifo_size = MAX_FIFO_SIZE ; } else { mdev_state -> s [ index ] . max_fifo_size = 1 ; mdev_state -> s [ index ] . intr_trigger_level = 1 ; } break ; case UART_LCR : if ( data & UART_LCR_DLAB ) { mdev_state -> s [ index ] . dlab = true ; mdev_state -> s [ index ] . divisor = 0 ; } else { mdev_state -> s [ index ] . dlab = false ; } mdev_state -> s [ index ] . uart_reg [ offset ] = data ; break ; case UART_MCR : mdev_state -> s [ index ] . uart_reg [ offset ] = data ; if ( ( mdev_state -> s [ index ] . uart_reg [ UART_IER ] & UART_IER_MSI ) && ( data & UART_MCR_OUT2 ) ) { pr_err ( "Serial port %d: MCR_OUT2 write\n" , index ) ; mtty_trigger_interrupt ( mdev_state ) ; } if ( ( mdev_state -> s [ index ] . uart_reg [ UART_IER ] & UART_IER_MSI ) && ( data & ( UART_MCR_RTS | UART_MCR_DTR ) ) ) { pr_err ( "Serial port %d: MCR RTS/DTR write\n" , index ) ; mtty_trigger_interrupt ( mdev_state ) ; } break ; case UART_LSR : case UART_MSR : break ; case UART_SCR : mdev_state -> s [ index ] . uart_reg [ offset ] = data ; break ; default : break ; } } 