abr_rle_decode ( , , , , ) { gint i , j ; gshort * cscanline_len = NULL ; gchar * cdata = NULL ; gchar * data = buffer ; cscanline_len = gegl_scratch_new ( gshort , height ) ; for ( i = 0 ; i < height ; i ++ ) { cscanline_len [ i ] = abr_read_short ( input , error ) ; if ( ( error && * error ) || cscanline_len [ i ] <= 0 ) { err } } for ( i = 0 ; i < height ; i ++ ) { gint len ; gsize bytes_read ; len = cscanline_len [ i ] ; cdata = gegl_scratch_alloc ( len ) ; if ( ! g_input_stream_read_all ( G_INPUT_STREAM ( input ) , cdata , len , & bytes_read , NULL , error ) || bytes_read != len ) { err } for ( j = 0 ; j < len ; ) { gint32 n = cdata [ j ++ ] ; if ( n >= 128 ) { n -= 256 ; } if ( n < 0 ) { n = - n + 1 ; if ( j + 1 > len || ( data - buffer ) + n > buffer_size ) { err } memset ( data , cdata [ j ] , n ) ; j += 1 ; data += n ; } else { n = n + 1 ; if ( j + n > len || ( data - buffer ) + n > buffer_size ) { err } memcpy ( data , & cdata [ j ] , n ) ; j += n ; data += n ; } } g_clear_pointer ( & cdata , gegl_scratch_free ) ; } g_clear_pointer ( & cscanline_len , gegl_scratch_free ) ; return TRUE ; err g_clear_pointer ( & cdata , gegl_scratch_free ) ; g_clear_pointer ( & cscanline_len , gegl_scratch_free ) ; if ( error && ! * error ) { g_set_error ( error , GIMP_DATA_ERROR , GIMP_DATA_ERROR_READ , _ ( "Fatal parse error in brush file: " "RLE compressed brush data corrupt." ) ) ; } return FALSE ; } 