int rsa_sha1_dec ( char * sencedsha , int iencedshalen , char * ssha , int sshasize , int * ishalen , X509 * pcertx509 ) { EVP_PKEY * pkey ; RSA * hpubkey ; unsigned long lerr ; char serr [ 160 ] ; pkey = X509_get_pubkey ( pcertx509 ) ; if ( pkey == NULL ) { lerr = ERR_get_error ( ) ; ERR_error_string_n ( lerr , serr , sizeof ( serr ) ) ; LOG ( L_ERR , "AUTH_IDENTITY:decrypt_identity: Pubkey %s\n" , serr ) ; return - 1 ; } X509_free ( pcertx509 ) ; hpubkey = EVP_PKEY_get1_RSA ( pkey ) ; EVP_PKEY_free ( pkey ) ; if ( hpubkey == NULL ) { LOG ( L_ERR , "AUTH_IDENTITY:decrypt_identity: Error getting RSA key\n" ) ; return - 2 ; } if ( RSA_verify ( NID_sha1 , ( unsigned char * ) ssha , sshasize , ( unsigned char * ) sencedsha , iencedshalen , hpubkey ) != 1 ) { LOG ( L_INFO , "AUTH_IDENTITY VERIFIER: RSA verify returned: '%s'\n" , ERR_error_string ( ERR_get_error ( ) , NULL ) ) ; LOG ( L_INFO , "AUTH_IDENTITY VERIFIER: RSA verify failed ->Invalid Identity Header\n" ) ; return - 5 ; } if ( RSA_size ( hpubkey ) > sshasize ) { LOG ( L_ERR , "AUTH_IDENTITY:decrypt_identity: Unexpected Identity hash length (%d>%d)\n" , RSA_size ( hpubkey ) , sshasize ) ; RSA_free ( hpubkey ) ; return - 3 ; } * ishalen = RSA_public_decrypt ( iencedshalen , ( unsigned char * ) sencedsha , ( unsigned char * ) ssha , hpubkey , RSA_PKCS1_PADDING ) ; if ( * ishalen <= 0 ) { lerr = ERR_get_error ( ) ; ERR_error_string_n ( lerr , serr , sizeof ( serr ) ) ; LOG ( L_ERR , "AUTH_IDENTITY:decrypt_identity: RSA operation error %s\n" , serr ) ; RSA_free ( hpubkey ) ; return - 4 ; } RSA_free ( hpubkey ) ; return 0 ; } 