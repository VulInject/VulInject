static int tilcdc_plane_atomic_check ( struct drm_plane * plane , struct drm_plane_state * state ) { struct drm_crtc_state * crtc_state ; struct drm_plane_state * old_state = plane -> state ; int pitch ; if ( ! state -> crtc ) { return 0 ; } if ( WARN_ON ( ! state -> fb ) ) { return - EINVAL ; } if ( state -> crtc_x || state -> crtc_y ) { dev_err ( plane -> dev -> dev , "%s: crtc position must be zero." , __func__ ) ; return - EINVAL ; } crtc_state = drm_atomic_get_existing_crtc_state ( state -> state , state -> crtc ) ; if ( WARN_ON ( ! crtc_state ) ) { return 0 ; } if ( crtc_state -> mode . hdisplay != state -> crtc_w || crtc_state -> mode . vdisplay != state -> crtc_h ) { dev_err ( plane -> dev -> dev , "%s: Size must match mode (%dx%d == %dx%d)" , __func__ , crtc_state -> mode . hdisplay , crtc_state -> mode . vdisplay , state -> crtc_w , state -> crtc_h ) ; return - EINVAL ; } pitch = crtc_state -> mode . hdisplay * state -> fb -> format -> cpp [ 0 ] ; if ( state -> fb -> pitches [ 0 ] != pitch ) { dev_err ( plane -> dev -> dev , "Invalid pitch: fb and crtc widths must be the same" ) ; return - EINVAL ; } if ( state -> fb && old_state -> fb && state -> fb -> format != old_state -> fb -> format ) { dev_dbg ( plane -> dev -> dev , "%s(): pixel format change requires mode_change\n" , __func__ ) ; crtc_state -> mode_changed = true ; } return 0 ; } 