void irlap_send_discovery_xid_frame ( struct irlap_cb * self , int S , __u8 s , __u8 command , discovery_t * discovery ) { struct sk_buff * tx_skb = NULL ; struct xid_frame * frame ; __u32 bcast = BROADCAST ; __u8 * info ; pr_debug ( "%s(), s=%d, S=%d, command=%d\n" , __func__ , s , S , command ) ; IRDA_ASSERT ( , ) IRDA_ASSERT ( , ) IRDA_ASSERT ( , ) tx_skb = alloc_skb ( sizeof ( xid_frame ) + IRLAP_DISCOVERY_INFO_LEN , GFP_ATOMIC ) ; skb_put ( tx_skb , 14 ) ; frame = ( xid_frame * ) tx_skb -> data ; if ( command ) { frame -> caddr = CBROADCAST | CMD_FRAME ; frame -> control = XID_CMD | PF_BIT ; } else { frame -> caddr = CBROADCAST ; frame -> control = XID_RSP | PF_BIT ; } frame -> ident = XID_FORMAT ; frame -> saddr = cpu_to_le32 ( self -> saddr ) ; if ( command ) { frame -> daddr = cpu_to_le32 ( bcast ) ; } else { frame -> daddr = cpu_to_le32 ( discovery -> data . daddr ) ; } switch ( S ) { case 1 : frame -> flags = 0x00 ; break ; case 6 : frame -> flags = 0x01 ; break ; case 8 : frame -> flags = 0x02 ; break ; case 16 : frame -> flags = 0x03 ; break ; default : frame -> flags = 0x02 ; break ; } frame -> slotnr = s ; frame -> version = 0x00 ; if ( ! command || ( frame -> slotnr == 0xff ) ) { int len ; if ( discovery -> data . hints [ 0 ] & HINT_EXTENSION ) { info = skb_put ( tx_skb , 2 ) ; info [ 0 ] = discovery -> data . hints [ 0 ] ; info [ 1 ] = discovery -> data . hints [ 1 ] ; } else { info = skb_put ( tx_skb , 1 ) ; info [ 0 ] = discovery -> data . hints [ 0 ] ; } info = skb_put ( tx_skb , 1 ) ; info [ 0 ] = discovery -> data . charset ; len = IRDA_MIN ( discovery -> name_len , skb_tailroom ( tx_skb ) ) ; info = skb_put ( tx_skb , len ) ; memcpy ( info , discovery -> data . info , len ) ; } irlap_queue_xmit ( self , tx_skb ) ; } 