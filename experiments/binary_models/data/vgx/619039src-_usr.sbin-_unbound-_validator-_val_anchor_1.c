int anchors_apply_cfg ( struct val_anchors * anchors , struct config_file * cfg ) { struct config_strlist * f ; const char * * zstr ; char * nm ; sldns_buffer * parsebuf = sldns_buffer_new ( 65535 ) ; if ( ! parsebuf ) { log_err ( "malloc error in anchors_apply_cfg." ) ; return 0 ; } if ( cfg -> insecure_lan_zones ) { for ( zstr = as112_zones ; * zstr ; zstr ++ ) { if ( ! anchor_insert_insecure ( anchors , * zstr ) ) { log_err ( "error in insecure-lan-zones: %s" , * zstr ) ; return 0 ; } } } for ( f = cfg -> domain_insecure ; f ; f = f -> next ) { if ( ! f -> str || f -> str [ 0 ] == 0 ) { continue ; } if ( ! anchor_insert_insecure ( anchors , f -> str ) ) { log_err ( "error in domain-insecure: %s" , f -> str ) ; sldns_buffer_free ( parsebuf ) ; return 0 ; } } for ( f = cfg -> trust_anchor_file_list ; f ; f = f -> next ) { if ( ! f -> str || f -> str [ 0 ] == 0 ) { continue ; } nm = f -> str ; if ( cfg -> chrootdir && cfg -> chrootdir [ 0 ] && strncmp ( nm , cfg -> chrootdir , strlen ( cfg -> chrootdir ) ) == 0 ) { nm += strlen ( cfg -> chrootdir ) ; } if ( ! anchor_read_file ( anchors , parsebuf , nm , 0 ) ) { log_err ( "error reading trust-anchor-file: %s" , f -> str ) ; sldns_buffer_free ( parsebuf ) ; return 0 ; } } for ( f = cfg -> trusted_keys_file_list ; f ; f = f -> next ) { if ( ! f -> str || f -> str [ 0 ] == 0 ) { continue ; } nm = f -> str ; if ( cfg -> chrootdir && cfg -> chrootdir [ 0 ] && strncmp ( nm , cfg -> chrootdir , strlen ( cfg -> chrootdir ) ) == 0 ) { nm += strlen ( cfg -> chrootdir ) ; } if ( ! anchor_read_bind_file_wild ( anchors , parsebuf , nm ) ) { log_err ( "error reading trusted-keys-file: %s" , f -> str ) ; sldns_buffer_free ( parsebuf ) ; return 0 ; } } for ( f = cfg -> trust_anchor_list ; f ; f = f -> next ) { if ( ! f -> str || f -> str [ 0 ] == 0 ) { continue ; } if ( ! anchor_store_str ( anchors , parsebuf , f -> str ) ) { log_err ( "error in trust-anchor: \"%s\"" , f -> str ) ; sldns_buffer_free ( parsebuf ) ; return 0 ; } } for ( f = cfg -> auto_trust_anchor_file_list ; f ; f = f -> next ) { if ( ! f -> str || f -> str [ 0 ] == 0 ) { continue ; } nm = f -> str ; if ( cfg -> chrootdir && cfg -> chrootdir [ 0 ] && strncmp ( nm , cfg -> chrootdir , strlen ( cfg -> chrootdir ) ) == 0 ) { nm += strlen ( cfg -> chrootdir ) ; } if ( ! autr_read_file ( anchors , nm ) ) { log_err ( "error reading auto-trust-anchor-file: %s" , f -> str ) ; sldns_buffer_free ( parsebuf ) ; return 0 ; } } anchors_assemble_rrsets ( anchors ) ; init_parents ( anchors ) ; sldns_buffer_free ( parsebuf ) ; if ( verbosity >= VERB_ALGO ) { autr_debug_print ( anchors ) ; } return 1 ; } 