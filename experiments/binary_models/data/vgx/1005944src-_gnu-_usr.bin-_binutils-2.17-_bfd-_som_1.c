som_finish_writing ( ) { int num_spaces = som_count_spaces ( abfd ) ; asymbol * * syms = bfd_get_outsymbols ( abfd ) ; int i , num_syms ; int subspace_index = 0 ; file_ptr location ; asection * section ; cfs_time_t current_offset ; unsigned int strings_size , total_reloc_size ; bfd_size_type amt ; if ( obj_som_exec_data ( abfd ) && obj_som_exec_data ( abfd ) -> version_id ) { obj_som_file_hdr ( abfd ) -> version_id = obj_som_exec_data ( abfd ) -> version_id ; } else { obj_som_file_hdr ( abfd ) -> version_id = NEW_VERSION_ID ; } current_offset = obj_som_file_hdr ( abfd ) -> som_length ; if ( current_offset % 4 ) { current_offset += ( 4 - ( current_offset % 4 ) ) ; } num_syms = bfd_get_symcount ( abfd ) ; obj_som_file_hdr ( abfd ) -> symbol_location = current_offset ; obj_som_file_hdr ( abfd ) -> symbol_total = num_syms ; current_offset += num_syms * sizeof ( symbol_dictionary_record ) ; if ( current_offset % 4 ) { current_offset += ( 4 - ( current_offset % 4 ) ) ; } obj_som_file_hdr ( abfd ) -> symbol_strings_location = current_offset ; if ( ! som_write_symbol_strings ( abfd , current_offset , syms , num_syms , & strings_size , obj_som_compilation_unit ( abfd ) ) ) { return FALSE ; } obj_som_file_hdr ( abfd ) -> symbol_strings_size = strings_size ; current_offset += strings_size ; som_prep_for_fixups ( abfd , bfd_get_outsymbols ( abfd ) , bfd_get_symcount ( abfd ) ) ; if ( current_offset % 4 ) { current_offset += ( 4 - ( current_offset % 4 ) ) ; } obj_som_file_hdr ( abfd ) -> fixup_request_location = current_offset ; if ( ! som_write_fixups ( abfd , current_offset , & total_reloc_size ) ) { return FALSE ; } obj_som_file_hdr ( abfd ) -> fixup_request_total = total_reloc_size ; obj_som_file_hdr ( abfd ) -> som_length = current_offset + total_reloc_size ; if ( ! som_build_and_write_symbol_table ( abfd ) ) { return FALSE ; } location = obj_som_file_hdr ( abfd ) -> subspace_location ; if ( bfd_seek ( abfd , location , SEEK_SET ) != 0 ) { return FALSE ; } section = abfd -> sections ; for ( i = 0 ; i < num_spaces ; i ++ ) { asection * subsection ; while ( ! som_is_space ( section ) ) { section = section -> next ; } for ( subsection = abfd -> sections ; subsection != NULL ; subsection = subsection -> next ) { if ( ! som_is_subspace ( subsection ) || ! som_is_container ( section , subsection ) || ( subsection -> flags & SEC_ALLOC ) == 0 ) { continue ; } if ( som_section_data ( section ) -> space_dict -> subspace_quantity == 0 ) { som_section_data ( section ) -> space_dict -> is_loadable = 1 ; som_section_data ( section ) -> space_dict -> subspace_index = subspace_index ; } subspace_index ++ ; som_section_data ( section ) -> space_dict -> subspace_quantity ++ ; som_section_data ( subsection ) -> subspace_dict -> space_index = i ; amt = sizeof ( som_subspace_dictionary_record ) ; if ( bfd_bwrite ( ( void * ) som_section_data ( subsection ) -> subspace_dict , amt , abfd ) != amt ) { return FALSE ; } } section = section -> next ; } section = abfd -> sections ; for ( i = 0 ; i < num_spaces ; i ++ ) { asection * subsection ; while ( ! som_is_space ( section ) ) { section = section -> next ; } for ( subsection = abfd -> sections ; subsection != NULL ; subsection = subsection -> next ) { if ( ! som_is_subspace ( subsection ) || ! som_is_container ( section , subsection ) || ( subsection -> flags & SEC_ALLOC ) != 0 ) { continue ; } if ( som_section_data ( section ) -> space_dict -> subspace_quantity == 0 ) { som_section_data ( section ) -> space_dict -> is_loadable = 0 ; som_section_data ( section ) -> space_dict -> subspace_index = subspace_index ; } som_section_data ( section ) -> space_dict -> subspace_quantity ++ ; subspace_index ++ ; som_section_data ( subsection ) -> subspace_dict -> space_index = i ; amt = sizeof ( som_subspace_dictionary_record ) ; if ( bfd_bwrite ( ( void * ) som_section_data ( subsection ) -> subspace_dict , amt , abfd ) != amt ) { return FALSE ; } } section = section -> next ; } location = obj_som_file_hdr ( abfd ) -> space_location ; if ( bfd_seek ( abfd , location , SEEK_SET ) != 0 ) { return FALSE ; } section = abfd -> sections ; for ( i = 0 ; i < num_spaces ; i ++ ) { while ( ! som_is_space ( section ) ) { section = section -> next ; } amt = sizeof ( space_dictionary_record ) ; if ( bfd_bwrite ( ( void * ) som_section_data ( section ) -> space_dict , amt , abfd ) != amt ) { return FALSE ; } section = section -> next ; } if ( obj_som_compilation_unit ( abfd ) ) { location = obj_som_file_hdr ( abfd ) -> compiler_location ; if ( bfd_seek ( abfd , location , SEEK_SET ) != 0 ) { return FALSE ; } amt = COMPUNITSZ ; if ( bfd_bwrite ( ( void * ) obj_som_compilation_unit ( abfd ) , amt , abfd ) != amt ) { return FALSE ; } } if ( abfd -> flags & ( EXEC_P | DYNAMIC ) ) { obj_som_file_hdr ( abfd ) -> system_id = obj_som_exec_data ( abfd ) -> system_id ; } if ( bfd_get_mach ( abfd ) == pa20 ) { obj_som_file_hdr ( abfd ) -> system_id = CPU_PA_RISC2_0 ; } if ( bfd_get_mach ( abfd ) == pa11 ) { obj_som_file_hdr ( abfd ) -> system_id = CPU_PA_RISC1_1 ; } else { obj_som_file_hdr ( abfd ) -> system_id = CPU_PA_RISC1_0 ; } obj_som_file_hdr ( abfd ) -> checksum = som_compute_checksum ( abfd ) ; if ( bfd_seek ( abfd , ( file_ptr ) 0 , SEEK_SET ) != 0 ) { return FALSE ; } amt = sizeof ( header ) ; if ( bfd_bwrite ( ( void * ) obj_som_file_hdr ( abfd ) , amt , abfd ) != amt ) { return FALSE ; } if ( abfd -> flags & ( EXEC_P | DYNAMIC ) ) { long tmp , som_length ; struct som_exec_auxhdr * exec_header ; exec_header = obj_som_exec_hdr ( abfd ) ; exec_header -> exec_entry = bfd_get_start_address ( abfd ) ; exec_header -> exec_flags = obj_som_exec_data ( abfd ) -> exec_flags ; tmp = exec_header -> exec_dsize ; tmp = SOM_ALIGN ( tmp , PA_PAGESIZE ) ; exec_header -> exec_bsize -= ( tmp - exec_header -> exec_dsize ) ; if ( exec_header -> exec_bsize < 0 ) { exec_header -> exec_bsize = 0 ; } exec_header -> exec_dsize = tmp ; som_length = obj_som_file_hdr ( abfd ) -> som_length ; if ( exec_header -> exec_tfile + exec_header -> exec_tsize > som_length || exec_header -> exec_dfile + exec_header -> exec_dsize > som_length ) { bfd_set_error ( bfd_error_bad_value ) ; return FALSE ; } if ( bfd_seek ( abfd , obj_som_file_hdr ( abfd ) -> aux_header_location , SEEK_SET ) != 0 ) { return FALSE ; } amt = AUX_HDR_SIZE ; if ( bfd_bwrite ( ( void * ) exec_header , amt , abfd ) != amt ) { return FALSE ; } } return TRUE ; } 