static long srp_build_response ( struct scsi_info * vscsi , struct ibmvscsis_cmd * cmd , uint * len_p ) { struct iu_entry * iue = cmd -> iue ; struct se_cmd * se_cmd = & cmd -> se_cmd ; struct srp_rsp * rsp ; uint len ; u32 rsp_code ; char * data ; u32 * tsk_status ; long rc = ADAPT_SUCCESS ; spin_lock_bh ( & vscsi -> intr_lock ) ; rsp = & vio_iu ( iue ) -> srp . rsp ; len = sizeof ( * rsp ) ; data = rsp -> data ; rsp -> opcode = SRP_RSP ; rsp -> req_lim_delta = cpu_to_be32 ( 1 + vscsi -> credit ) ; rsp -> tag = cmd -> rsp . tag ; rsp -> flags = 0 ; if ( cmd -> type == SCSI_CDB ) { rsp -> status = ibmvscsis_fast_fail ( vscsi , cmd ) ; if ( rsp -> status ) { dev_dbg ( & vscsi -> dev , "build_resp: cmd %p, scsi status %d\n" , cmd , ( int ) rsp -> status ) ; ibmvscsis_determine_resid ( se_cmd , rsp ) ; if ( se_cmd -> scsi_sense_length && se_cmd -> sense_buffer ) { rsp -> sense_data_len = cpu_to_be32 ( se_cmd -> scsi_sense_length ) ; rsp -> flags |= SRP_RSP_FLAG_SNSVALID ; len += se_cmd -> scsi_sense_length ; memcpy ( data , se_cmd -> sense_buffer , se_cmd -> scsi_sense_length ) ; } rsp -> sol_not = ( cmd -> rsp . sol_not & UCSOLNT ) >> UCSOLNT_RESP_SHIFT ; } if ( cmd -> flags & CMD_FAST_FAIL ) { dev_dbg ( & vscsi -> dev , "build_resp: cmd %p, fast fail\n" , cmd ) ; rsp -> sol_not = ( cmd -> rsp . sol_not & UCSOLNT ) >> UCSOLNT_RESP_SHIFT ; } else { rsp -> sol_not = ( cmd -> rsp . sol_not & SCSOLNT ) >> SCSOLNT_RESP_SHIFT ; } } else { rsp -> status = 0 ; rsp -> resp_data_len = cpu_to_be32 ( 4 ) ; rsp -> flags |= SRP_RSP_FLAG_RSPVALID ; switch ( se_cmd -> se_tmr_req -> response ) { case TMR_FUNCTION_COMPLETE : case TMR_TASK_DOES_NOT_EXIST : rsp_code = SRP_TASK_MANAGEMENT_FUNCTION_COMPLETE ; rsp -> sol_not = ( cmd -> rsp . sol_not & SCSOLNT ) >> SCSOLNT_RESP_SHIFT ; break ; case TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED : case TMR_LUN_DOES_NOT_EXIST : rsp_code = SRP_TASK_MANAGEMENT_FUNCTION_NOT_SUPPORTED ; rsp -> sol_not = ( cmd -> rsp . sol_not & UCSOLNT ) >> UCSOLNT_RESP_SHIFT ; break ; case TMR_FUNCTION_FAILED : case TMR_FUNCTION_REJECTED : default : rsp_code = SRP_TASK_MANAGEMENT_FUNCTION_FAILED ; rsp -> sol_not = ( cmd -> rsp . sol_not & UCSOLNT ) >> UCSOLNT_RESP_SHIFT ; break ; } tsk_status = ( u32 * ) data ; * tsk_status = cpu_to_be32 ( rsp_code ) ; data = ( char * ) ( tsk_status + 1 ) ; len += 4 ; } dma_wmb ( ) ; rc = h_copy_rdma ( len , vscsi -> dds . window [ LOCAL ] . liobn , iue -> sbuf -> dma , vscsi -> dds . window [ REMOTE ] . liobn , be64_to_cpu ( iue -> remote_token ) ) ; switch ( rc ) { case H_SUCCESS : vscsi -> credit = 0 ; * len_p = len ; break ; case H_PERMISSION : if ( connection_broken ( vscsi ) ) { vscsi -> flags |= RESPONSE_Q_DOWN | CLIENT_FAILED ; } dev_err ( & vscsi -> dev , "build_response: error copying to client, rc %ld, flags 0x%x, state 0x%hx\n" , rc , vscsi -> flags , vscsi -> state ) ; break ; case H_SOURCE_PARM : case H_DEST_PARM : default : dev_err ( & vscsi -> dev , "build_response: error copying to client, rc %ld\n" , rc ) ; break ; } spin_unlock_bh ( & vscsi -> intr_lock ) ; return rc ; } 