CK_RV get_master_attributes_by_duplication ( generic_attr_t * src_attrs , size_t num_src_attrs , generic_attr_t * * dst_attrs , size_t * num_dst_attrs ) { CK_RV rv = CKR_OK ; generic_attr_t * new_attrs , * src , * dst ; size_t i ; new_attrs = malloc ( sizeof ( generic_attr_t ) * num_src_attrs ) ; for ( i = 0 ; i < num_src_attrs ; i ++ ) { src = src_attrs + i ; dst = new_attrs + i ; * dst = * src ; if ( src -> isMalloced ) { dst -> attribute . pValue = malloc ( src -> attribute . ulValueLen ) ; if ( dst -> attribute . pValue == NULL ) { dst -> attribute . ulValueLen = 0 ; rv = CKR_HOST_MEMORY ; continue ; } } if ( src -> attribute . pValue == & src -> generic_bbool ) { dst -> attribute . pValue = & dst -> generic_bbool ; } if ( src -> attribute . pValue == & src -> generic_ulong ) { dst -> attribute . pValue = & dst -> generic_ulong ; } if ( src -> attribute . pValue == & src -> generic_data ) { dst -> attribute . pValue = & dst -> generic_data ; } else { dst -> attribute . pValue = NULL ; dst -> attribute . ulValueLen = 0 ; rv = CKR_GENERAL_ERROR ; num_src_attrs = i + 1 ; break ; } ( void ) memcpy ( dst -> attribute . pValue , src -> attribute . pValue , src -> attribute . ulValueLen ) ; } if ( rv != CKR_OK ) { dealloc_attributes ( new_attrs , num_src_attrs ) ; } else { * dst_attrs = new_attrs ; * num_dst_attrs = num_src_attrs ; } return ( rv ) ; } 