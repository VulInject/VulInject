static int nsp_gpio_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct nsp_gpio * chip ; struct gpio_chip * gc ; u32 val ; int irq , ret ; if ( of_property_read_u32 ( pdev -> dev . of_node , "ngpios" , & val ) ) { dev_err ( & pdev -> dev , "Missing ngpios OF property\n" ) ; return - ENODEV ; } chip = devm_kzalloc ( dev , sizeof ( * chip ) , GFP_KERNEL ) ; chip -> dev = dev ; platform_set_drvdata ( pdev , chip ) ; chip -> base = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( chip -> base ) ) { dev_err ( dev , "unable to map I/O memory\n" ) ; return PTR_ERR ( chip -> base ) ; } chip -> io_ctrl = devm_platform_ioremap_resource ( pdev , 1 ) ; if ( IS_ERR ( chip -> io_ctrl ) ) { dev_err ( dev , "unable to map I/O memory\n" ) ; return PTR_ERR ( chip -> io_ctrl ) ; } raw_spin_lock_init ( & chip -> lock ) ; gc = & chip -> gc ; gc -> base = - 1 ; gc -> can_sleep = false ; gc -> ngpio = val ; gc -> label = dev_name ( dev ) ; gc -> parent = dev ; gc -> request = gpiochip_generic_request ; gc -> free = gpiochip_generic_free ; gc -> direction_input = nsp_gpio_direction_input ; gc -> direction_output = nsp_gpio_direction_output ; gc -> get_direction = nsp_gpio_get_direction ; gc -> set = nsp_gpio_set ; gc -> get = nsp_gpio_get ; irq = platform_get_irq ( pdev , 0 ) ; if ( irq > 0 ) { struct gpio_irq_chip * girq ; struct irq_chip * irqc ; irqc = & chip -> irqchip ; irqc -> name = "gpio-a" ; irqc -> irq_ack = nsp_gpio_irq_ack ; irqc -> irq_mask = nsp_gpio_irq_mask ; irqc -> irq_unmask = nsp_gpio_irq_unmask ; irqc -> irq_set_type = nsp_gpio_irq_set_type ; val = readl ( chip -> base + NSP_CHIP_A_INT_MASK ) ; val = val | NSP_CHIP_A_GPIO_INT_BIT ; writel ( val , ( chip -> base + NSP_CHIP_A_INT_MASK ) ) ; ret = devm_request_irq ( dev , irq , nsp_gpio_irq_handler , IRQF_SHARED , "gpio-a" , & chip -> gc ) ; if ( ret ) { dev_err ( & pdev -> dev , "Unable to request IRQ%d: %d\n" , irq , ret ) ; return ret ; } girq = & chip -> gc . irq ; girq -> chip = irqc ; girq -> parent_handler = NULL ; girq -> num_parents = 0 ; girq -> parents = NULL ; girq -> default_type = IRQ_TYPE_NONE ; girq -> handler = handle_bad_irq ; } ret = devm_gpiochip_add_data ( dev , gc , chip ) ; if ( ret < 0 ) { dev_err ( dev , "unable to add GPIO chip\n" ) ; return ret ; } ret = nsp_gpio_register_pinconf ( chip ) ; if ( ret ) { dev_err ( dev , "unable to register pinconf\n" ) ; return ret ; } return 0 ; } 