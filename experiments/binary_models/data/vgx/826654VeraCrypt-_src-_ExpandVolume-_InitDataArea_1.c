BOOL WriteSector ( void * dev , char * sector , char * write_buf , int * write_buf_cnt , __int64 * nSecNo , PCRYPTO_INFO cryptoInfo ) { static __int32 updateTime = 0 ; ( * nSecNo ) ++ ; memcpy ( write_buf + * write_buf_cnt , sector , FormatSectorSize ) ; ( * write_buf_cnt ) += FormatSectorSize ; if ( * write_buf_cnt == FormatWriteBufferSize && ! FlushFormatWriteBuffer ( dev , write_buf , write_buf_cnt , nSecNo , cryptoInfo ) ) { return FALSE ; } if ( GetTickCount ( ) - updateTime > 25 ) { if ( UpdateProgressBar ( * nSecNo * FormatSectorSize ) ) { return FALSE ; } updateTime = GetTickCount ( ) ; } return TRUE ; } static volatile BOOL WriteThreadRunning ; static volatile BOOL WriteThreadExitRequested ; static HANDLE WriteThreadHandle ; static byte * WriteThreadBuffer ; static HANDLE WriteBufferEmptyEvent ; static HANDLE WriteBufferFullEvent ; static volatile HANDLE WriteRequestHandle ; static volatile int WriteRequestSize ; static volatile DWORD WriteRequestResult ; static void __cdecl FormatWriteThreadProc ( void * arg ) { DWORD bytesWritten ; SetThreadPriority ( GetCurrentThread ( ) , THREAD_PRIORITY_HIGHEST ) ; while ( ! WriteThreadExitRequested ) { if ( WaitForSingleObject ( WriteBufferFullEvent , INFINITE ) == WAIT_FAILED ) { handleWin32Error ( SRC_POS ) ; break ; } if ( WriteThreadExitRequested ) { break ; } if ( ! WriteFile ( WriteRequestHandle , WriteThreadBuffer , WriteRequestSize , & bytesWritten , NULL ) ) { WriteRequestResult = GetLastError ( ) ; } else { WriteRequestResult = ERROR_SUCCESS ; } if ( ! SetEvent ( WriteBufferEmptyEvent ) ) { handleWin32Error ( NULL , SRC_POS ) ; break ; } } WriteThreadRunning = FALSE ; _endthread ( ) ; } 