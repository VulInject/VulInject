static int bfin_crypto_crc_handle_queue ( struct bfin_crypto_crc * crc , struct ahash_request * req ) { struct crypto_async_request * async_req , * backlog ; struct bfin_crypto_crc_reqctx * ctx ; struct scatterlist * sg ; int ret = 0 ; int nsg , i , j ; unsigned int nextlen ; unsigned long flags ; u32 reg ; spin_lock_irqsave ( & crc -> lock , flags ) ; if ( req ) { ret = ahash_enqueue_request ( & crc -> queue , req ) ; } if ( crc -> busy ) { spin_unlock_irqrestore ( & crc -> lock , flags ) ; return ret ; } backlog = crypto_get_backlog ( & crc -> queue ) ; async_req = crypto_dequeue_request ( & crc -> queue ) ; if ( async_req ) { crc -> busy = 1 ; } spin_unlock_irqrestore ( & crc -> lock , flags ) ; if ( ! async_req ) { return ret ; } if ( backlog ) { backlog -> complete ( backlog , - EINPROGRESS ) ; } req = ahash_request_cast ( async_req ) ; crc -> req = req ; ctx = ahash_request_ctx ( req ) ; ctx -> sg = NULL ; ctx -> sg_buflen = 0 ; ctx -> sg_nents = 0 ; dev_dbg ( crc -> dev , "handling new req, flag=%u, nbytes: %d\n" , ctx -> flag , req -> nbytes ) ; if ( ctx -> flag == CRC_CRYPTO_STATE_FINISH ) { if ( ctx -> bufnext_len == 0 ) { crc -> busy = 0 ; return 0 ; } memset ( ctx -> bufnext + ctx -> bufnext_len , 0 , CHKSUM_DIGEST_SIZE - ctx -> bufnext_len ) ; } else { if ( ctx -> bufnext_len + req -> nbytes < CHKSUM_DIGEST_SIZE ) { memcpy ( ctx -> bufnext + ctx -> bufnext_len , sg_virt ( req -> src ) , req -> nbytes ) ; ctx -> bufnext_len += req -> nbytes ; if ( ctx -> flag == CRC_CRYPTO_STATE_FINALUPDATE && ctx -> bufnext_len ) { finish_update } else { crc -> busy = 0 ; return 0 ; } } if ( ctx -> bufnext_len ) { ctx -> buflast_len = ctx -> bufnext_len ; memcpy ( ctx -> buflast , ctx -> bufnext , ctx -> buflast_len ) ; nsg = ctx -> sg_buflen ?2 : 1 ; sg_init_table ( ctx -> bufsl , nsg ) ; sg_set_buf ( ctx -> bufsl , ctx -> buflast , ctx -> buflast_len ) ; if ( nsg > 1 ) { sg_chain ( ctx -> bufsl , nsg , req -> src ) ; } ctx -> sg = ctx -> bufsl ; } else { ctx -> sg = req -> src ; } nsg = sg_nents ( ctx -> sg ) ; ctx -> sg_nents = nsg ; ctx -> sg_buflen = ctx -> buflast_len + req -> nbytes ; ctx -> bufnext_len = ctx -> sg_buflen % 4 ; ctx -> sg_buflen &= ~ 0x3 ; if ( ctx -> bufnext_len ) { nextlen = ctx -> bufnext_len ; for ( i = nsg - 1 ; i >= 0 ; i -- ) { sg = sg_get ( ctx -> sg , nsg , i ) ; j = min ( nextlen , sg_dma_len ( sg ) ) ; memcpy ( ctx -> bufnext + nextlen - j , sg_virt ( sg ) + sg_dma_len ( sg ) - j , j ) ; if ( j == sg_dma_len ( sg ) ) { ctx -> sg_nents -- ; } nextlen -= j ; if ( nextlen == 0 ) { break ; } } } } finish_update if ( ctx -> bufnext_len && ( ctx -> flag == CRC_CRYPTO_STATE_FINALUPDATE || ctx -> flag == CRC_CRYPTO_STATE_FINISH ) ) { ctx -> sg_buflen += CHKSUM_DIGEST_SIZE ; } writel ( ctx -> sg_buflen >> 2 , & crc -> regs -> datacnt ) ; bfin_crypto_crc_config_dma ( crc ) ; reg = readl ( & crc -> regs -> control ) ; writel ( reg | BLKEN , & crc -> regs -> control ) ; return - EINPROGRESS ; } 