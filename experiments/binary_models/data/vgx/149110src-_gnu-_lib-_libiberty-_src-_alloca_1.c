C_alloca ( ) { auto char probe ; register char * depth = ADDRESS_FUNCTION ( probe ) ; if ( STACK_DIR == 0 ) { find_stack_direction ( ) ; } { register header * hp ; for ( hp = last_alloca_header ; hp != NULL ; ) { if ( ( STACK_DIR > 0 && hp -> h . deep > depth ) || ( STACK_DIR < 0 && hp -> h . deep < depth ) ) { register header * np = hp -> h . next ; free ( ( PTR ) hp ) ; hp = np ; } else { break ; } } last_alloca_header = hp ; } if ( size == 0 ) { return NULL ; } { register void * new_storage = XNEWVEC ( char , sizeof ( header ) + size ) ; if ( new_storage == 0 ) { abort ( ) ; } ( ( header * ) new_storage ) -> h . next = last_alloca_header ; ( ( header * ) new_storage ) -> h . deep = depth ; last_alloca_header = ( header * ) new_storage ; return ( PTR ) ( ( char * ) new_storage + sizeof ( header ) ) ; } } stack_control_header { long shgrow 32 ; long shaseg 32 ; long shhwm 32 ; long shsize 32 ; } stack_segment_linkage { long ss [ 0200 ] ; long sssize 32 ; long ssbase 32 ; long 32 ; long sspseg 32 ; long 32 ; long sstcpt 32 ; long sscsnm ; long ssusr1 ; long ssusr2 ; long sstpid ; long ssgvup ; long sscray [ 7 ] ; long ssa0 ; long ssa1 ; long ssa2 ; long ssa3 ; int ssa4 ; long ssa5 ; long ssa6 ; long ssa7 ; long sss0 ; long sss1 ; long sss2 ; long sss3 ; long sss4 ; long sss5 ; long sss6 ; long sss7 ; } stk_stat { long now ; long maxc ; long high_water ; long overflows ; long hits ; long extends ; long stko_mallocs ; long underflows ; long stko_free ; long stkm_free ; long segments ; long maxs ; long pad_size ; long current_address ; long current_size ; long initial_address ; long initial_size ; } stk_trailer { long this_address ; long this_size ; long unknown2 ; long unknown3 ; long link ; long unknown5 ; long unknown6 ; long unknown7 ; long unknown8 ; long unknown9 ; long unknown10 ; long unknown11 ; long unknown12 ; long unknown13 ; long unknown14 ; } static long i00afunc ( long * address ) { struct stk_stat status ; struct stk_trailer * trailer ; long * block , size ; long result = 0 ; STKSTAT ( & status ) ; trailer = ( stk_trailer * ) ( status . current_address + status . current_size - 15 ) ; if ( trailer == 0 ) { abort ( ) ; } while ( trailer != 0 ) { block = ( long * ) trailer -> this_address ; size = trailer -> this_size ; if ( block == 0 || size == 0 ) { abort ( ) ; } trailer = ( stk_trailer * ) trailer -> link ; if ( ( block <= address ) && ( address < ( block + size ) ) ) { break ; } } result = address - block ; if ( trailer == 0 ) { return result ; } { if ( trailer -> this_size <= 0 ) { abort ( ) ; } result += trailer -> this_size ; trailer = ( stk_trailer * ) trailer -> link ; } trailer != 0 ; return ( result ) ; } 