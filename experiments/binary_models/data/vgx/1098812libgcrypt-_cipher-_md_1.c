md_copy ( , ) { gcry_err_code_t err = 0 ; struct gcry_md_context * a = ahd -> ctx ; struct gcry_md_context * b ; GcryDigestEntry * ar , * br ; gcry_md_hd_t bhd ; size_t n ; if ( ahd -> bufpos ) { md_write ( ahd , NULL , 0 ) ; } n = ( char * ) ahd -> ctx - ( char * ) ahd ; if ( a -> flags . secure ) { bhd = xtrymalloc_secure ( n + sizeof ( gcry_md_context ) ) ; } else { bhd = xtrymalloc ( n + sizeof ( gcry_md_context ) ) ; } if ( ! bhd ) { err = gpg_err_code_from_syserror ( ) ; leave } bhd -> ctx = b = ( void * ) ( ( char * ) bhd + n ) ; gcry_assert ( ahd -> bufsize == ( n - sizeof ( gcry_md_handle ) + 1 ) ) ; bhd -> bufsize = ahd -> bufsize ; bhd -> bufpos = 0 ; gcry_assert ( ! ahd -> bufpos ) ; memcpy ( b , a , sizeof a ) ; b -> list = NULL ; b -> debug = NULL ; for ( ar = a -> list ; ar ; ar = ar -> next ) { if ( a -> flags . secure ) { br = xtrymalloc_secure ( ar -> actual_struct_size ) ; } else { br = xtrymalloc ( ar -> actual_struct_size ) ; } if ( ! br ) { err = gpg_err_code_from_syserror ( ) ; md_close ( bhd , NULL ) ; leave } memcpy ( br , ar , ar -> actual_struct_size ) ; br -> next = b -> list ; b -> list = br ; } if ( a -> debug ) { md_start_debug ( bhd , "unknown" ) ; } * b_hd = bhd ; leave return err ; } 