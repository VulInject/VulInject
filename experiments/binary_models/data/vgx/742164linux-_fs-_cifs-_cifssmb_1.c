int CIFSFindFirst ( const unsigned int xid , struct cifs_tcon * tcon , const char * searchName , struct cifs_sb_info * cifs_sb , __u16 * pnetfid , __u16 search_flags , struct cifs_search_info * psrch_inf , bool msearch ) { TRANSACTION2_FFIRST_REQ * pSMB = NULL ; TRANSACTION2_FFIRST_RSP * pSMBr = NULL ; T2_FFIRST_RSP_PARMS * parms ; int rc = 0 ; int bytes_returned = 0 ; int name_len , remap ; __u16 params , byte_count ; struct nls_table * nls_codepage ; cifs_dbg ( FYI , "In FindFirst for %s\n" , searchName ) ; findFirstRetry rc = smb_init ( SMB_COM_TRANSACTION2 , 15 , tcon , ( void * * ) & pSMB , ( void * * ) & pSMBr ) ; if ( rc ) { return rc ; } nls_codepage = cifs_sb -> local_nls ; remap = cifs_remap ( cifs_sb ) ; if ( pSMB -> hdr . Flags2 & SMBFLG2_UNICODE ) { name_len = cifsConvertToUTF16 ( ( __le16 * ) pSMB -> FileName , searchName , PATH_MAX , nls_codepage , remap ) ; name_len *= 2 ; if ( msearch ) { pSMB -> FileName [ name_len ] = CIFS_DIR_SEP ( cifs_sb ) ; pSMB -> FileName [ name_len + 1 ] = 0 ; pSMB -> FileName [ name_len + 2 ] = '*' ; pSMB -> FileName [ name_len + 3 ] = 0 ; name_len += 4 ; pSMB -> FileName [ name_len ] = 0 ; pSMB -> FileName [ name_len + 1 ] = 0 ; name_len += 2 ; } } else { name_len = copy_path_name ( pSMB -> FileName , searchName ) ; if ( msearch ) { if ( WARN_ON_ONCE ( name_len > PATH_MAX - 2 ) ) { name_len = PATH_MAX - 2 ; } pSMB -> FileName [ name_len - 1 ] = CIFS_DIR_SEP ( cifs_sb ) ; pSMB -> FileName [ name_len ] = '*' ; pSMB -> FileName [ name_len + 1 ] = 0 ; name_len += 2 ; } } params = 12 + name_len ; pSMB -> MaxParameterCount = cpu_to_le16 ( 10 ) ; pSMB -> MaxDataCount = cpu_to_le16 ( CIFSMaxBufSize & 0xFFFFFF00 ) ; pSMB -> MaxSetupCount = 0 ; pSMB -> Reserved = 0 ; pSMB -> Flags = 0 ; pSMB -> Timeout = 0 ; pSMB -> Reserved2 = 0 ; byte_count = params + 1 ; pSMB -> TotalParameterCount = cpu_to_le16 ( params ) ; pSMB -> ParameterCount = pSMB -> TotalParameterCount ; pSMB -> ParameterOffset = cpu_to_le16 ( offsetof ( smb_com_transaction2_ffirst_req , SearchAttributes ) - 4 ) ; pSMB -> DataCount = 0 ; pSMB -> DataOffset = 0 ; pSMB -> SetupCount = 1 ; pSMB -> Reserved3 = 0 ; pSMB -> SubCommand = cpu_to_le16 ( TRANS2_FIND_FIRST ) ; pSMB -> SearchAttributes = cpu_to_le16 ( ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY ) ; pSMB -> SearchCount = cpu_to_le16 ( CIFSMaxBufSize / sizeof ( FILE_UNIX_INFO ) ) ; pSMB -> SearchFlags = cpu_to_le16 ( search_flags ) ; pSMB -> InformationLevel = cpu_to_le16 ( psrch_inf -> info_level ) ; pSMB -> SearchStorageType = 0 ; inc_rfc1001_len ( pSMB , byte_count ) ; pSMB -> ByteCount = cpu_to_le16 ( byte_count ) ; rc = SendReceive ( xid , tcon -> ses , ( smb_hdr * ) pSMB , ( smb_hdr * ) pSMBr , & bytes_returned , 0 ) ; cifs_stats_inc ( & tcon -> stats . cifs_stats . num_ffirst ) ; if ( rc ) { cifs_dbg ( FYI , "Error in FindFirst = %d\n" , rc ) ; cifs_buf_release ( pSMB ) ; if ( rc == - EAGAIN ) { findFirstRetry } } else { rc = validate_t2 ( ( smb_t2_rsp * ) pSMBr ) ; if ( rc == 0 ) { unsigned int lnoff ; if ( pSMBr -> hdr . Flags2 & SMBFLG2_UNICODE ) { psrch_inf -> unicode = true ; } else { psrch_inf -> unicode = false ; } psrch_inf -> ntwrk_buf_start = ( char * ) pSMBr ; psrch_inf -> smallBuf = false ; psrch_inf -> srch_entries_start = ( char * ) & pSMBr -> hdr . Protocol + le16_to_cpu ( pSMBr -> t2 . DataOffset ) ; parms = ( T2_FFIRST_RSP_PARMS * ) ( ( char * ) & pSMBr -> hdr . Protocol + le16_to_cpu ( pSMBr -> t2 . ParameterOffset ) ) ; if ( parms -> EndofSearch ) { psrch_inf -> endOfSearch = true ; } else { psrch_inf -> endOfSearch = false ; } psrch_inf -> entries_in_buffer = le16_to_cpu ( parms -> SearchCount ) ; psrch_inf -> index_of_last_entry = 2 + psrch_inf -> entries_in_buffer ; lnoff = le16_to_cpu ( parms -> LastNameOffset ) ; if ( CIFSMaxBufSize < lnoff ) { cifs_dbg ( VFS , "ignoring corrupt resume name\n" ) ; psrch_inf -> last_entry = NULL ; return rc ; } psrch_inf -> last_entry = psrch_inf -> srch_entries_start + lnoff ; if ( pnetfid ) { * pnetfid = parms -> SearchHandle ; } } else { cifs_buf_release ( pSMB ) ; } } return rc ; } 