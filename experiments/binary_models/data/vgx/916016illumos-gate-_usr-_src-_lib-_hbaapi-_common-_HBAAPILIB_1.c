HBA_RegisterForAdapterAddEvents ( , , ) { HBA_ALLADAPTERSCALLBACK_ELEM * cbp ; HBA_VENDORCALLBACK_ELEM * vcbp ; HBA_VENDORCALLBACK_ELEM * vendorhandlelist ; HBARegisterForAdapterAddEventsFunc registeredfunc ; HBA_STATUS status = HBA_STATUS_OK ; HBA_STATUS failure = HBA_STATUS_OK ; HBA_LIBRARY_INFO * lib_infop ; int registered_cnt = 0 ; int vendor_cnt = 0 ; int not_supported_cnt = 0 ; int status_OK_bar_cnt = 0 ; int status_OK_cnt = 0 ; DEBUG ( 2 , "HBA_RegisterForAdapterAddEvents" , 0 , 0 , 0 ) ; if ( callbackHandle == NULL ) { return ( HBA_STATUS_ERROR_ARG ) ; } ARE_WE_INITED ( ) ; cbp = ( HBA_ALLADAPTERSCALLBACK_ELEM * ) calloc ( 1 , sizeof ( HBA_ALLADAPTERSCALLBACK_ELEM ) ) ; * callbackHandle = ( HBA_CALLBACKHANDLE ) cbp ; if ( cbp == NULL ) { fprintf ( stderr , "HBA_RegisterForAdapterAddEvents: calloc failed for %d bytes\n" , sizeof ( HBA_ALLADAPTERSCALLBACK_ELEM ) ) ; return HBA_STATUS_ERROR ; } GRAB_MUTEX ( & _hbaapi_LL_mutex ) ; GRAB_MUTEX ( & _hbaapi_AAE_mutex ) ; cbp -> callback = callback ; cbp -> next = _hbaapi_adapteraddevents_callback_list ; _hbaapi_adapteraddevents_callback_list = cbp ; RELEASE_MUTEX ( & _hbaapi_AAE_mutex ) ; vendorhandlelist = NULL ; for ( lib_infop = _hbaapi_librarylist ; lib_infop != NULL ; lib_infop = lib_infop -> next ) { vendor_cnt ++ ; registeredfunc = lib_infop -> functionTable . RegisterForAdapterAddEventsHandler ; if ( registeredfunc == NULL ) { continue ; } vcbp = ( HBA_VENDORCALLBACK_ELEM * ) calloc ( 1 , sizeof ( HBA_VENDORCALLBACK_ELEM ) ) ; if ( vcbp == NULL ) { fprintf ( stderr , "HBA_RegisterForAdapterAddEvents: " "calloc failed for %d bytes\n" , sizeof ( HBA_VENDORCALLBACK_ELEM ) ) ; freevendorhandlelist ( vendorhandlelist ) ; status = HBA_STATUS_ERROR ; break ; } registered_cnt ++ ; status = ( registeredfunc ) ( adapteraddevents_callback , userData , & vcbp -> vendorcbhandle ) ; if ( status == HBA_STATUS_ERROR_NOT_SUPPORTED ) { not_supported_cnt ++ ; continue ; } if ( status != HBA_STATUS_OK ) { status_OK_bar_cnt ++ ; DEBUG ( 0 , "HBA_RegisterForAdapterAddEvents: Library->%s, Error->%d" , lib_infop -> LibraryPath , status , 0 ) ; fprintf ( stderr , "HBA_RegisterForAdapterAddEvents: Library->%s, Error->%d" , lib_infop -> LibraryPath , status ) ; failure = status ; free ( vcbp ) ; continue ; } else { status_OK_cnt ++ ; } vcbp -> lib_info = lib_infop ; vcbp -> next = vendorhandlelist ; vendorhandlelist = vcbp ; } if ( registered_cnt == 0 ) { status = HBA_STATUS_ERROR_NOT_SUPPORTED ; freevendorhandlelist ( vendorhandlelist ) ; local_remove_callback ( ( HBA_CALLBACKHANDLE ) cbp ) ; } if ( status_OK_cnt == 0 && not_supported_cnt != 0 ) { status = HBA_STATUS_ERROR_NOT_SUPPORTED ; } if ( status_OK_cnt == 0 ) { local_remove_callback ( ( HBA_CALLBACKHANDLE ) cbp ) ; status = failure ; } else { GRAB_MUTEX ( & _hbaapi_AAE_mutex ) ; for ( cbp = _hbaapi_adapteraddevents_callback_list ; cbp != NULL ; cbp = cbp -> next ) { if ( ( HBA_CALLBACKHANDLE ) cbp == * callbackHandle ) { cbp -> vendorhandlelist = vendorhandlelist ; vendorhandlelist = NULL ; break ; } } RELEASE_MUTEX ( & _hbaapi_AAE_mutex ) ; if ( vendorhandlelist != NULL ) { freevendorhandlelist ( vendorhandlelist ) ; DEBUG ( 0 , "HBA_RegisterForAdapterAddEvents: HBA_RemoveCallback was " "called for a handle before registration was finished." , 0 , 0 , 0 ) ; status = HBA_STATUS_ERROR ; } else { status = HBA_STATUS_OK ; } } RELEASE_MUTEX_RETURN ( & _hbaapi_LL_mutex , status ) ; } 