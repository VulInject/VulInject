static int zsa_open ( queue_t * rq , dev_t * dev , int flag , int sflag , cred_t * cr ) { struct zscom * zs ; struct asyncline * za ; int speed , unit ; struct termios * termiosp ; int len ; int allocbcount = zsa_rstandby ; boolean_t set_zsoptinit = B_FALSE ; unit = UNIT ( * dev ) ; if ( unit >= nzs ) { return ( ENXIO ) ; } zs = & zscom [ unit ] ; if ( zs -> zs_ops == NULL ) { return ( ENXIO ) ; } mutex_enter ( zs -> zs_ocexcl ) ; again if ( ( zs -> zs_ops != & zsops_null ) && ( zs -> zs_ops != & zsops_async ) ) { mutex_exit ( zs -> zs_excl ) ; mutex_exit ( zs -> zs_ocexcl ) ; return ( EBUSY ) ; } za = ( asyncline * ) & zs -> zs_priv_str ; if ( zs -> zs_suspended ) { mutex_exit ( zs -> zs_excl ) ; mutex_exit ( zs -> zs_ocexcl ) ; ( void ) ddi_dev_is_needed ( zs -> zs_dip , 0 , 1 ) ; mutex_enter ( zs -> zs_ocexcl ) ; mutex_enter ( zs -> zs_excl ) ; } ( void ) pm_busy_component ( zs -> zs_dip , unit % 2 + 1 ) ; if ( zs -> zs_ops == & zsops_null ) { bzero ( za , sizeof ( zs -> zs_priv_str ) ) ; za -> za_common = zs ; if ( zssoftCAR [ zs -> zs_unit ] ) { za -> za_ttycommon . t_flags |= TS_SOFTCAR ; } zsopinit ( zs , & zsops_async ) ; set_zsoptinit = B_TRUE ; za -> za_rdone_wptr = 0 ; za -> za_rdone_rptr = 0 ; } zs -> zs_priv = ( caddr_t ) za ; mutex_enter ( zs -> zs_excl_hi ) ; if ( ! ( za -> za_flags & ZAS_ISOPEN ) ) { mutex_exit ( zs -> zs_excl_hi ) ; if ( ddi_getlongprop ( DDI_DEV_T_ANY , ddi_root_node ( ) , 0 , "ttymodes" , ( caddr_t ) & termiosp , & len ) == DDI_PROP_SUCCESS && len == sizeof ( termios ) ) { za -> za_ttycommon . t_cflag = termiosp -> c_cflag ; kmem_free ( termiosp , len ) ; } else { cmn_err ( CE_WARN , "zs: Couldn't get ttymodes property!" ) ; } mutex_enter ( zs -> zs_excl_hi ) ; if ( ( * dev == rconsdev ) || ( * dev == kbddev ) || ( * dev == stdindev ) ) { speed = zsgetspeed ( * dev ) ; za -> za_ttycommon . t_cflag &= ~ ( CBAUD ) ; if ( speed > CBAUD ) { za -> za_ttycommon . t_cflag |= CBAUDEXT ; za -> za_ttycommon . t_cflag |= ( ( speed - CBAUD - 1 ) & CBAUD ) ; } else { za -> za_ttycommon . t_cflag &= ~ CBAUDEXT ; za -> za_ttycommon . t_cflag |= ( speed & CBAUD ) ; } } za -> za_overrun = 0 ; za -> za_ttycommon . t_iflag = 0 ; za -> za_ttycommon . t_iocpending = NULL ; za -> za_ttycommon . t_size . ws_row = 0 ; za -> za_ttycommon . t_size . ws_col = 0 ; za -> za_ttycommon . t_size . ws_xpixel = 0 ; za -> za_ttycommon . t_size . ws_ypixel = 0 ; za -> za_dev = * dev ; za -> za_wbufcid = 0 ; zsa_program ( za , za -> za_ttycommon . t_cflag & ( CIBAUDEXT | CIBAUD ) ) ; zsa_set_za_rcv_flags_mask ( za ) ; } if ( ( za -> za_ttycommon . t_flags & TS_XCLUDE ) && secpolicy_excl_open ( cr ) != 0 ) { mutex_exit ( zs -> zs_excl_hi ) ; if ( set_zsoptinit && ! ( za -> za_flags & ISOPEN ) ) { zsopinit ( zs , & zsops_null ) ; } mutex_exit ( zs -> zs_excl ) ; mutex_exit ( zs -> zs_ocexcl ) ; return ( EBUSY ) ; } if ( ( * dev & OUTLINE ) && ! ( za -> za_flags & ZAS_OUT ) ) { mutex_exit ( zs -> zs_excl_hi ) ; if ( set_zsoptinit && ! ( za -> za_flags & ISOPEN ) ) { zsopinit ( zs , & zsops_null ) ; } mutex_exit ( zs -> zs_excl ) ; mutex_exit ( zs -> zs_ocexcl ) ; return ( EBUSY ) ; } if ( * dev & OUTLINE ) { za -> za_flags |= ZAS_OUT ; } ( void ) zsmctl ( zs , ZS_ON , DMSET ) ; if ( ( za -> za_ttycommon . t_flags & TS_SOFTCAR ) || ( zsmctl ( zs , 0 , DMGET ) & ZSRR0_CD ) ) { za -> za_flags |= ZAS_CARR_ON ; } mutex_exit ( zs -> zs_excl_hi ) ; if ( ! ( flag & ( FNDELAY | FNONBLOCK ) ) && ! ( za -> za_ttycommon . t_cflag & CLOCAL ) ) { if ( ! ( za -> za_flags & ( ZAS_CARR_ON | ZAS_OUT ) ) || ( ( za -> za_flags & ZAS_OUT ) && ! ( * dev & OUTLINE ) ) ) { za -> za_flags |= ZAS_WOPEN ; mutex_exit ( zs -> zs_excl ) ; if ( cv_wait_sig ( & zs -> zs_flags_cv , zs -> zs_ocexcl ) == 0 ) { mutex_enter ( zs -> zs_excl ) ; if ( zs -> zs_suspended ) { mutex_exit ( zs -> zs_excl ) ; mutex_exit ( zs -> zs_ocexcl ) ; ( void ) ddi_dev_is_needed ( zs -> zs_dip , 0 , 1 ) ; mutex_enter ( zs -> zs_ocexcl ) ; mutex_enter ( zs -> zs_excl ) ; } za -> za_flags &= ~ ZAS_WOPEN ; if ( set_zsoptinit && ! ( za -> za_flags & ISOPEN ) ) { zsopinit ( zs , & zsops_null ) ; } mutex_exit ( zs -> zs_excl ) ; mutex_exit ( zs -> zs_ocexcl ) ; return ( EINTR ) ; } mutex_enter ( zs -> zs_excl ) ; za -> za_flags &= ~ ZAS_WOPEN ; if ( ( zs -> zs_ops == & zsops_null ) || ( zs -> zs_ops == & zsops_async ) ) { again } else { if ( set_zsoptinit && ! ( za -> za_flags & ISOPEN ) ) { zsopinit ( zs , & zsops_null ) ; } mutex_exit ( zs -> zs_excl ) ; mutex_exit ( zs -> zs_ocexcl ) ; return ( EBUSY ) ; } } } if ( ( za -> za_flags & ZAS_OUT ) && ! ( * dev & OUTLINE ) ) { if ( set_zsoptinit && ! ( za -> za_flags & ISOPEN ) ) { zsopinit ( zs , & zsops_null ) ; } mutex_exit ( zs -> zs_excl ) ; mutex_exit ( zs -> zs_ocexcl ) ; return ( EBUSY ) ; } za -> za_ttycommon . t_readq = rq ; za -> za_ttycommon . t_writeq = WR ( rq ) ; rq -> q_ptr = WR ( rq ) -> q_ptr = ( caddr_t ) za ; za -> za_flags |= ZAS_ISOPEN ; ZSA_GETBLOCK ( zs , allocbcount ) ; qprocson ( rq ) ; mutex_exit ( zs -> zs_excl ) ; mutex_exit ( zs -> zs_ocexcl ) ; return ( 0 ) ; } 