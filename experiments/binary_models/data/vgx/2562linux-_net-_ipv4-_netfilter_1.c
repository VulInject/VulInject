int ip_route_me_harder ( struct net * net , struct sock * sk , struct sk_buff * skb , unsigned int addr_type ) { const struct iphdr * iph = ip_hdr ( skb ) ; struct rtable * rt ; struct flowi4 fl4 = { } ; __be32 saddr = iph -> saddr ; __u8 flags ; struct net_device * dev = skb_dst ( skb ) -> dev ; struct flow_keys flkeys ; unsigned int hh_len ; sk = sk_to_full_sk ( sk ) ; flags = sk ?inet_sk_flowi_flags ( sk ) : 0 ; if ( addr_type == RTN_UNSPEC ) { addr_type = inet_addr_type_dev_table ( net , dev , saddr ) ; } if ( addr_type == RTN_LOCAL || addr_type == RTN_UNICAST ) { flags |= FLOWI_FLAG_ANYSRC ; } else { saddr = 0 ; } fl4 . daddr = iph -> daddr ; fl4 . saddr = saddr ; fl4 . flowi4_tos = RT_TOS ( iph -> tos ) ; fl4 . flowi4_oif = sk ?sk -> sk_bound_dev_if : 0 ; fl4 . flowi4_l3mdev = l3mdev_master_ifindex ( dev ) ; fl4 . flowi4_mark = skb -> mark ; fl4 . flowi4_flags = flags ; fib4_rules_early_flow_dissect ( net , skb , & fl4 , & flkeys ) ; rt = ip_route_output_key ( net , & fl4 ) ; if ( IS_ERR ( rt ) ) { return PTR_ERR ( rt ) ; } skb_dst_drop ( skb ) ; skb_dst_set ( skb , & rt -> dst ) ; if ( skb_dst ( skb ) -> error ) { return skb_dst ( skb ) -> error ; } if ( ! ( IPCB ( skb ) -> flags & IPSKB_XFRM_TRANSFORMED ) && xfrm_decode_session ( skb , flowi4_to_flowi ( & fl4 ) , AF_INET ) == 0 ) { struct dst_entry * dst = skb_dst ( skb ) ; skb_dst_set ( skb ) ; dst = xfrm_lookup ( net , dst , flowi4_to_flowi ( & fl4 ) , sk , 0 ) ; if ( IS_ERR ( dst ) ) { return PTR_ERR ( dst ) ; } skb_dst_set ( skb , dst ) ; } hh_len = skb_dst ( skb ) -> dev -> hard_header_len ; if ( skb_headroom ( skb ) < hh_len && pskb_expand_head ( skb , HH_DATA_ALIGN ( hh_len - skb_headroom ( skb ) ) , 0 , GFP_ATOMIC ) ) { return - ENOMEM ; } return 0 ; } 