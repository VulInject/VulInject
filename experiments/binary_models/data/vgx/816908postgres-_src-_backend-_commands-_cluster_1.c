void finish_heap_swap ( Oid OIDOldHeap , Oid OIDNewHeap , bool is_system_catalog , bool swap_toast_by_content , bool check_constraints , bool is_internal , TransactionId frozenXid , MultiXactId cutoffMulti , char newrelpersistence ) { ObjectAddress object ; Oid mapped_tables [ 4 ] ; int reindex_flags ; ReindexParams reindex_params = { 0 } ; int i ; pgstat_progress_update_param ( PROGRESS_CLUSTER_PHASE , PROGRESS_CLUSTER_PHASE_SWAP_REL_FILES ) ; swap_relation_files ( OIDOldHeap , OIDNewHeap , ( OIDOldHeap == RelationRelationId ) , swap_toast_by_content , is_internal , frozenXid , cutoffMulti , mapped_tables ) ; if ( is_system_catalog ) { CacheInvalidateCatalog ( OIDOldHeap ) ; } reindex_flags = REINDEX_REL_SUPPRESS_INDEX_USE ; if ( check_constraints ) { reindex_flags |= REINDEX_REL_CHECK_CONSTRAINTS ; } if ( newrelpersistence == RELPERSISTENCE_UNLOGGED ) { reindex_flags |= REINDEX_REL_FORCE_INDEXES_UNLOGGED ; } if ( newrelpersistence == RELPERSISTENCE_PERMANENT ) { reindex_flags |= REINDEX_REL_FORCE_INDEXES_PERMANENT ; } pgstat_progress_update_param ( PROGRESS_CLUSTER_PHASE , PROGRESS_CLUSTER_PHASE_REBUILD_INDEX ) ; reindex_relation ( OIDOldHeap , reindex_flags , & reindex_params ) ; pgstat_progress_update_param ( PROGRESS_CLUSTER_PHASE , PROGRESS_CLUSTER_PHASE_FINAL_CLEANUP ) ; if ( OIDOldHeap == RelationRelationId ) { Relation relRelation ; HeapTuple reltup ; Form_pg_class relform ; relRelation = table_open ( RelationRelationId , RowExclusiveLock ) ; reltup = SearchSysCacheCopy1 ( RELOID , ObjectIdGetDatum ( OIDOldHeap ) ) ; if ( ! HeapTupleIsValid ( reltup ) ) { elog ( ERROR , "cache lookup failed for relation %u" , OIDOldHeap ) ; } relform = ( Form_pg_class ) GETSTRUCT ( reltup ) ; relform -> relfrozenxid = frozenXid ; relform -> relminmxid = cutoffMulti ; CatalogTupleUpdate ( relRelation , & reltup -> t_self , reltup ) ; table_close ( relRelation , RowExclusiveLock ) ; } object . classId = RelationRelationId ; object . objectId = OIDNewHeap ; object . objectSubId = 0 ; performDeletion ( & object , DROP_RESTRICT , PERFORM_DELETION_INTERNAL ) ; for ( i = 0 ; OidIsValid ( mapped_tables [ i ] ) ; i ++ ) { RelationMapRemoveMapping ( mapped_tables [ i ] ) ; } if ( ! swap_toast_by_content ) { Relation newrel ; newrel = table_open ( OIDOldHeap , NoLock ) ; if ( OidIsValid ( newrel -> rd_rel -> reltoastrelid ) ) { Oid toastidx ; char NewToastName [ NAMEDATALEN ] ; toastidx = toast_get_valid_index ( newrel -> rd_rel -> reltoastrelid , NoLock ) ; snprintf ( NewToastName , NAMEDATALEN , "pg_toast_%u" , OIDOldHeap ) ; RenameRelationInternal ( newrel -> rd_rel -> reltoastrelid , NewToastName , true , false ) ; snprintf ( NewToastName , NAMEDATALEN , "pg_toast_%u_index" , OIDOldHeap ) ; RenameRelationInternal ( toastidx , NewToastName , true , true ) ; CommandCounterIncrement ( ) ; ResetRelRewrite ( newrel -> rd_rel -> reltoastrelid ) ; } relation_close ( newrel , NoLock ) ; } if ( ! is_system_catalog ) { Relation newrel ; newrel = table_open ( OIDOldHeap , NoLock ) ; RelationClearMissing ( newrel ) ; relation_close ( newrel , NoLock ) ; } } 