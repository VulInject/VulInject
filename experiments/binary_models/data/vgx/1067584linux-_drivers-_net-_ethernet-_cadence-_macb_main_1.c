static int macb_pad_and_fcs ( struct sk_buff * * skb , struct net_device * ndev ) { bool cloned = skb_cloned ( * skb ) || skb_header_cloned ( * skb ) || skb_is_nonlinear ( * skb ) ; int padlen = ETH_ZLEN - ( * skb ) -> len ; int tailroom = skb_tailroom ( * skb ) ; struct sk_buff * nskb ; u32 fcs ; if ( ! ( ndev -> features & NETIF_F_HW_CSUM ) || ! ( ( * skb ) -> ip_summed != CHECKSUM_PARTIAL ) || skb_shinfo ( * skb ) -> gso_size || ptp_one_step_sync ( * skb ) ) { return 0 ; } if ( padlen <= 0 ) { if ( tailroom >= ETH_FCS_LEN ) { add_fcs } else { padlen = ETH_FCS_LEN ; } } else { padlen += ETH_FCS_LEN ; } if ( cloned || tailroom < padlen ) { nskb = skb_copy_expand ( * skb , 0 , padlen , GFP_ATOMIC ) ; dev_consume_skb_any ( * skb ) ; * skb = nskb ; } if ( padlen > ETH_FCS_LEN ) { skb_put_zero ( * skb , padlen - ETH_FCS_LEN ) ; } add_fcs fcs = crc32_le ( ~ 0 , ( * skb ) -> data , ( * skb ) -> len ) ; fcs = ~ fcs ; skb_put_u8 ( * skb , fcs & 0xff ) ; skb_put_u8 ( * skb , ( fcs >> 8 ) & 0xff ) ; skb_put_u8 ( * skb , ( fcs >> 16 ) & 0xff ) ; skb_put_u8 ( * skb , ( fcs >> 24 ) & 0xff ) ; return 0 ; } 