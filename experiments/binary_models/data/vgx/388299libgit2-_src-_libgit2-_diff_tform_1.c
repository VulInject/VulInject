int git_diff_find_similar ( git_diff * diff , const git_diff_find_options * given_opts ) { size_t s , t ; int error = 0 , result ; uint16_t similarity ; git_diff_delta * src , * tgt ; git_diff_find_options opts = GIT_DIFF_FIND_OPTIONS_INIT ; size_t num_deltas , num_srcs = 0 , num_tgts = 0 ; size_t tried_srcs = 0 , tried_tgts = 0 ; size_t num_rewrites = 0 , num_updates = 0 , num_bumped = 0 ; size_t sigcache_size ; void * * sigcache = NULL ; diff_find_match * tgt2src = NULL ; diff_find_match * src2tgt = NULL ; diff_find_match * tgt2src_copy = NULL ; diff_find_match * best_match ; git_diff_file swap ; GIT_ASSERT_ARG ( diff ) ; if ( ( error = normalize_find_opts ( diff , & opts , given_opts ) ) < 0 ) { return error ; } num_deltas = diff -> deltas . length ; if ( ! num_deltas || ! git__is_uint32 ( num_deltas ) ) { cleanup } if ( ( opts . flags & GIT_DIFF_FIND_ALL ) == 0 ) { cleanup } GIT_ERROR_CHECK_ALLOC_MULTIPLY ( & sigcache_size , num_deltas , 2 ) ; sigcache = git__calloc ( sigcache_size , sizeof ( void * ) ) ; GIT_ERROR_CHECK_ALLOC ( sigcache ) ; git_vector_foreach ( , , ) { if ( is_rename_source ( diff , & opts , t , sigcache ) ) { ++ num_srcs ; } if ( is_rename_target ( diff , & opts , t , sigcache ) ) { ++ num_tgts ; } if ( ( tgt -> flags & GIT_DIFF_FLAG__TO_SPLIT ) != 0 ) { num_rewrites ++ ; } } if ( ! num_srcs || ! num_tgts ) { cleanup } src2tgt = git__calloc ( num_deltas , sizeof ( diff_find_match ) ) ; GIT_ERROR_CHECK_ALLOC ( src2tgt , NULL ) ; tgt2src = git__calloc ( num_deltas , sizeof ( diff_find_match ) ) ; GIT_ERROR_CHECK_ALLOC ( tgt2src ) ; if ( FLAG_SET ( & opts , GIT_DIFF_FIND_COPIES ) ) { tgt2src_copy = git__calloc ( num_deltas , sizeof ( diff_find_match ) ) ; GIT_ERROR_CHECK_ALLOC ( tgt2src_copy ) ; } find_best_matches tried_tgts = num_bumped = 0 ; git_vector_foreach ( , , ) { if ( ( tgt -> flags & GIT_DIFF_FLAG__IS_RENAME_TARGET ) == 0 ) { continue ; } tried_srcs = 0 ; git_vector_foreach ( , , ) { if ( ( src -> flags & GIT_DIFF_FLAG__IS_RENAME_SOURCE ) == 0 ) { continue ; } if ( s == t ) { result = - 1 ; } if ( ( error = similarity_measure ( & result , diff , & opts , sigcache , 2 * s , 2 * t + 1 ) ) < 0 ) { cleanup } if ( result < 0 ) { continue ; } similarity = ( uint16_t ) result ; if ( tgt2src [ t ] . similarity < similarity && src2tgt [ s ] . similarity < similarity ) { if ( src2tgt [ s ] . similarity > 0 ) { tgt2src [ src2tgt [ s ] . idx ] . similarity = 0 ; num_bumped ++ ; } if ( tgt2src [ t ] . similarity > 0 ) { src2tgt [ tgt2src [ t ] . idx ] . similarity = 0 ; num_bumped ++ ; } tgt2src [ t ] . idx = s ; tgt2src [ t ] . similarity = similarity ; src2tgt [ s ] . idx = t ; src2tgt [ s ] . similarity = similarity ; } if ( tgt2src_copy != NULL && tgt2src_copy [ t ] . similarity < similarity ) { tgt2src_copy [ t ] . idx = s ; tgt2src_copy [ t ] . similarity = similarity ; } if ( ++ tried_srcs >= num_srcs ) { break ; } if ( tried_srcs > opts . rename_limit ) { break ; } } if ( ++ tried_tgts >= num_tgts ) { break ; } } if ( num_bumped > 0 ) { find_best_matches } git_vector_foreach ( , , ) { if ( ( tgt -> flags & GIT_DIFF_FLAG__IS_RENAME_TARGET ) == 0 ) { continue ; } if ( tgt2src [ t ] . similarity ) { best_match = & tgt2src [ t ] ; } if ( tgt2src_copy && tgt2src_copy [ t ] . similarity ) { best_match = & tgt2src_copy [ t ] ; } else { continue ; } s = best_match -> idx ; src = GIT_VECTOR_GET ( & diff -> deltas , s ) ; if ( src -> status == GIT_DELTA_DELETED ) { if ( delta_is_new_only ( tgt ) ) { if ( best_match -> similarity < opts . rename_threshold ) { continue ; } delta_make_rename ( tgt , src , best_match -> similarity ) ; src -> flags |= GIT_DIFF_FLAG__TO_DELETE ; num_rewrites ++ ; } else { GIT_ASSERT ( delta_is_split ( tgt ) ) ; if ( best_match -> similarity < opts . rename_from_rewrite_threshold ) { continue ; } memcpy ( & swap , & tgt -> old_file , sizeof ( swap ) ) ; delta_make_rename ( tgt , src , best_match -> similarity ) ; num_rewrites -- ; GIT_ASSERT ( src -> status == GIT_DELTA_DELETED ) ; memcpy ( & src -> old_file , & swap , sizeof ( src -> old_file ) ) ; memset ( & src -> new_file , 0 , sizeof ( src -> new_file ) ) ; src -> new_file . path = src -> old_file . path ; src -> new_file . flags |= GIT_DIFF_FLAG_VALID_ID ; git_oid_clear ( & src -> new_file . id , GIT_OID_SHA1 ) ; num_updates ++ ; if ( src2tgt [ t ] . similarity > 0 && src2tgt [ t ] . idx > t ) { tgt2src [ src2tgt [ t ] . idx ] . idx = s ; } } } if ( delta_is_split ( src ) ) { if ( delta_is_new_only ( tgt ) ) { if ( best_match -> similarity < opts . rename_threshold ) { continue ; } delta_make_rename ( tgt , src , best_match -> similarity ) ; src -> status = ( diff -> new_src == GIT_ITERATOR_WORKDIR ) ?GIT_DELTA_UNTRACKED : GIT_DELTA_ADDED ; src -> nfiles = 1 ; memset ( & src -> old_file , 0 , sizeof ( src -> old_file ) ) ; src -> old_file . path = src -> new_file . path ; src -> old_file . flags |= GIT_DIFF_FLAG_VALID_ID ; git_oid_clear ( & src -> old_file . id , GIT_OID_SHA1 ) ; src -> flags &= ~ GIT_DIFF_FLAG__TO_SPLIT ; num_rewrites -- ; num_updates ++ ; } else { GIT_ASSERT ( delta_is_split ( src ) ) ; if ( best_match -> similarity < opts . rename_from_rewrite_threshold ) { continue ; } memcpy ( & swap , & tgt -> old_file , sizeof ( swap ) ) ; delta_make_rename ( tgt , src , best_match -> similarity ) ; num_rewrites -- ; num_updates ++ ; memcpy ( & src -> old_file , & swap , sizeof ( src -> old_file ) ) ; if ( tgt2src [ s ] . idx == t && tgt2src [ s ] . similarity > opts . rename_from_rewrite_threshold ) { src -> status = GIT_DELTA_RENAMED ; src -> similarity = tgt2src [ s ] . similarity ; tgt2src [ s ] . similarity = 0 ; src -> flags &= ~ ( GIT_DIFF_FLAG__TO_SPLIT | GIT_DIFF_FLAG__IS_RENAME_TARGET ) ; num_rewrites -- ; } if ( src2tgt [ t ] . similarity > 0 && src2tgt [ t ] . idx > t ) { tgt2src [ src2tgt [ t ] . idx ] . idx = s ; } num_updates ++ ; } } if ( FLAG_SET ( & opts , GIT_DIFF_FIND_COPIES ) ) { if ( tgt2src_copy [ t ] . similarity < opts . copy_threshold ) { continue ; } best_match = & tgt2src_copy [ t ] ; src = GIT_VECTOR_GET ( & diff -> deltas , best_match -> idx ) ; if ( delta_is_split ( tgt ) ) { error = insert_delete_side_of_split ( diff , & diff -> deltas , tgt ) ; if ( error < 0 ) { cleanup } num_rewrites -- ; } if ( ! delta_is_split ( tgt ) && ! delta_is_new_only ( tgt ) ) { continue ; } tgt -> status = GIT_DELTA_COPIED ; tgt -> similarity = best_match -> similarity ; tgt -> nfiles = 2 ; memcpy ( & tgt -> old_file , & src -> old_file , sizeof ( tgt -> old_file ) ) ; tgt -> flags &= ~ GIT_DIFF_FLAG__TO_SPLIT ; num_updates ++ ; } } if ( num_rewrites > 0 || num_updates > 0 ) { error = apply_splits_and_deletes ( diff , diff -> deltas . length - num_rewrites , FLAG_SET ( & opts , GIT_DIFF_BREAK_REWRITES ) && ! FLAG_SET ( & opts , GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY ) ) ; } cleanup git__free ( tgt2src ) ; git__free ( src2tgt ) ; git__free ( tgt2src_copy ) ; if ( sigcache ) { for ( t = 0 ; t < num_deltas * 2 ; ++ t ) { if ( sigcache [ t ] != NULL ) { opts . metric -> free_signature ( sigcache [ t ] , opts . metric -> payload ) ; } } git__free ( sigcache ) ; } if ( ! given_opts || ! given_opts -> metric ) { git__free ( opts . metric ) ; } return error ; } 