static int pcan_usb_fd_decode_canmsg ( struct pcan_usb_fd_if * usb_if , struct pucan_msg * rx_msg ) { struct pucan_rx_msg * rm = ( pucan_rx_msg * ) rx_msg ; struct peak_usb_device * dev ; struct net_device * netdev ; struct canfd_frame * cfd ; struct sk_buff * skb ; const u16 rx_msg_flags = le16_to_cpu ( rm -> flags ) ; if ( pucan_msg_get_channel ( rm ) >= ARRAY_SIZE ( usb_if -> dev ) ) { return - ENOMEM ; } dev = usb_if -> dev [ pucan_msg_get_channel ( rm ) ] ; netdev = dev -> netdev ; if ( rx_msg_flags & PUCAN_MSG_EXT_DATA_LEN ) { skb = alloc_canfd_skb ( netdev , & cfd ) ; if ( rx_msg_flags & PUCAN_MSG_BITRATE_SWITCH ) { cfd -> flags |= CANFD_BRS ; } if ( rx_msg_flags & PUCAN_MSG_ERROR_STATE_IND ) { cfd -> flags |= CANFD_ESI ; } cfd -> len = can_fd_dlc2len ( pucan_msg_get_dlc ( rm ) ) ; } else { skb = alloc_can_skb ( netdev , ( can_frame * * ) & cfd ) ; if ( ! skb ) { return - ENOMEM ; } can_frame_set_cc_len ( ( can_frame * ) cfd , pucan_msg_get_dlc ( rm ) , dev -> can . ctrlmode ) ; } cfd -> can_id = le32_to_cpu ( rm -> can_id ) ; if ( rx_msg_flags & PUCAN_MSG_EXT_ID ) { cfd -> can_id |= CAN_EFF_FLAG ; } if ( rx_msg_flags & PUCAN_MSG_RTR ) { cfd -> can_id |= CAN_RTR_FLAG ; } else { memcpy ( cfd -> data , rm -> d , cfd -> len ) ; netdev -> stats . rx_bytes += cfd -> len ; } netdev -> stats . rx_packets ++ ; peak_usb_netif_rx_64 ( skb , le32_to_cpu ( rm -> ts_low ) , le32_to_cpu ( rm -> ts_high ) ) ; return 0 ; } 