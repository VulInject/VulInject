static enum matcher_rv command_match_r ( struct graph_node * start , vector vline , unsigned int n , struct graph_node * * stack , struct list * * currbest ) { assert ( n < vector_active ( vline ) ) ; enum matcher_rv status = MATCHER_NO_MATCH ; struct cmd_token * copy , * token = start -> data ; enum match_type minmatch = min_match_level ( token -> type ) ; if ( ! token -> allowrepeat ) { for ( size_t s = 0 ; s < n ; s ++ ) { if ( stack [ s ] == start ) { return MATCHER_NO_MATCH ; } } } char * input_token = vector_slot ( vline , n ) ; fprintf ( stdout , "\"%-20s\" matches \"%-30s\" ? " , input_token , token -> text ) ; enum match_type mt = match_token ( token , input_token ) ; fprintf ( stdout , "type: %d " , token -> type ) ; fprintf ( stdout , "min: %d - " , minmatch ) ; switch ( mt ) { case trivial_match : fprintf ( stdout , "trivial_match " ) ; break ; case no_match : fprintf ( stdout , "no_match " ) ; break ; case partly_match : fprintf ( stdout , "partly_match " ) ; break ; case exact_match : fprintf ( stdout , "exact_match " ) ; break ; } if ( mt >= minmatch ) { fprintf ( stdout , " MATCH" ) ; } fprintf ( stdout , "\n" ) ; if ( match_token ( token , input_token ) < minmatch ) { return MATCHER_NO_MATCH ; } stack [ n ] = start ; struct listnode * ln ; struct graph_node * gn ; struct list * next = list_new ( ) ; add_nexthops ( next , start , NULL , 0 , is_neg ( vline , 1 ) ) ; for ( ALL_LIST_ELEMENTS_RO ( next , ln , gn ) ; ) { if ( n + 1 == vector_active ( vline ) ) { struct cmd_token * tok = gn -> data ; if ( tok -> type == END_TKN ) { if ( * currbest ) { status = MATCHER_AMBIGUOUS ; break ; } else { status = MATCHER_OK ; } * currbest = list_new ( ) ; struct graph_node * leaf = vector_slot ( gn -> to , 0 ) ; struct cmd_element * el = leaf -> data ; listnode_add ( * currbest , el ) ; ( * currbest ) -> del = ( void ( * ) ( void * ) ) & cmd_token_del ; } continue ; } struct list * result = NULL ; enum matcher_rv rstat = command_match_r ( gn , vline , n + 1 , stack , & result ) ; if ( result && * currbest ) { struct list * newbest = disambiguate ( * currbest , result , vline , n + 1 ) ; if ( ! newbest ) { status = MATCHER_AMBIGUOUS ; } if ( newbest == * currbest && status == MATCHER_AMBIGUOUS ) { status = MATCHER_AMBIGUOUS ; } if ( newbest == result && rstat == MATCHER_AMBIGUOUS ) { status = MATCHER_AMBIGUOUS ; } else { status = MATCHER_OK ; } struct list * todelete = ( ( newbest && newbest == result ) ?* currbest : result ) ; del_arglist ( todelete ) ; * currbest = newbest ?newbest : * currbest ; } if ( result ) { status = rstat ; * currbest = result ; } if ( ! * currbest ) { status = MAX ( rstat , status ) ; } } if ( * currbest ) { token = start -> data ; copy = cmd_token_dup ( token ) ; copy -> arg = XSTRDUP ( MTYPE_CMD_ARG , input_token ) ; listnode_add_before ( * currbest , ( * currbest ) -> head , copy ) ; } if ( n + 1 == vector_active ( vline ) && status == MATCHER_NO_MATCH ) { status = MATCHER_INCOMPLETE ; } list_delete ( & next ) ; return status ; } 