efi_status_t __maybe_unused efi_var_collect ( struct efi_var_file * * bufp , loff_t * lenp , u32 check_attr_mask ) { size_t len = EFI_VAR_BUF_SIZE ; struct efi_var_file * buf ; struct efi_var_entry * var , * old_var ; size_t old_var_name_length = 2 ; * bufp = NULL ; buf = calloc ( 1 , len ) ; var = buf -> var ; old_var = var ; for ( ; ; ) { efi_uintn_t data_length , var_name_length ; u8 * data ; efi_status_t ret ; if ( ( uintptr_t ) buf + len <= ( uintptr_t ) var -> name + old_var_name_length ) { return EFI_BUFFER_TOO_SMALL ; } var_name_length = ( uintptr_t ) buf + len - ( uintptr_t ) var -> name ; memcpy ( var -> name , old_var -> name , old_var_name_length ) ; guidcpy ( & var -> guid , & old_var -> guid ) ; ret = efi_get_next_variable_name_int ( & var_name_length , var -> name , & var -> guid ) ; if ( ret == EFI_NOT_FOUND ) { break ; } if ( ret != EFI_SUCCESS ) { free ( buf ) ; return ret ; } old_var_name_length = var_name_length ; old_var = var ; data = ( u8 * ) var -> name + old_var_name_length ; data_length = ( uintptr_t ) buf + len - ( uintptr_t ) data ; ret = efi_get_variable_int ( var -> name , & var -> guid , & var -> attr , & data_length , data , & var -> time ) ; if ( ret != EFI_SUCCESS ) { free ( buf ) ; return ret ; } if ( ( var -> attr & check_attr_mask ) == check_attr_mask ) { var -> length = data_length ; var = ( efi_var_entry * ) ALIGN ( ( uintptr_t ) data + data_length , 8 ) ; } } buf -> reserved = 0 ; buf -> magic = EFI_VAR_FILE_MAGIC ; len = ( uintptr_t ) var - ( uintptr_t ) buf ; buf -> crc32 = crc32 ( 0 , ( u8 * ) buf -> var , len - sizeof ( efi_var_file ) ) ; buf -> length = len ; * bufp = buf ; * lenp = len ; return EFI_SUCCESS ; } 