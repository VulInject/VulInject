static void sitd_link_urb ( struct ehci_hcd * ehci , struct urb * urb , unsigned mod , struct ehci_iso_stream * stream ) { int packet ; int next_uframe ; struct ehci_iso_sched * sched = urb -> hcpriv ; struct ehci_sitd * sitd ; next_uframe = stream -> next_uframe ; if ( list_empty ( & stream -> td_list ) ) { ehci_to_hcd ( ehci ) -> self . bandwidth_allocated += stream -> bandwidth ; } if ( ehci_to_hcd ( ehci ) -> self . bandwidth_isoc_reqs == 0 ) { if ( ehci -> amd_pll_fix == 1 ) { usb_amd_quirk_pll_disable ( ) ; } } ehci_to_hcd ( ehci ) -> self . bandwidth_isoc_reqs ++ ; for ( packet = sched -> first_packet , sitd = NULL ; packet < urb -> number_of_packets ; packet ++ ) { BUG_ON ( list_empty ( & sched -> td_list ) ) ; sitd = list_entry ( sched -> td_list . next , ehci_sitd , sitd_list ) ; list_move_tail ( & sitd -> sitd_list , & stream -> td_list ) ; sitd -> stream = stream ; sitd -> urb = urb ; sitd_patch ( ehci , stream , sitd , sched , packet ) ; sitd_link ( ehci , ( next_uframe >> 3 ) & ( ehci -> periodic_size - 1 ) , sitd ) ; next_uframe += stream -> uperiod ; } stream -> next_uframe = next_uframe & ( mod - 1 ) ; iso_sched_free ( stream , sched ) ; urb -> hcpriv = stream ; ++ ehci -> isoc_count ; enable_periodic ( ehci ) ; } 