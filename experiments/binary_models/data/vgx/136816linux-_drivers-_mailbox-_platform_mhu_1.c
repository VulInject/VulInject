static int platform_mhu_probe ( struct platform_device * pdev ) { int i , err ; struct platform_mhu * mhu ; struct device * dev = & pdev -> dev ; int platform_mhu_reg [ MHU_CHANS ] { MHU_SEC_OFFSET MHU_LP_OFFSET MHU_HP_OFFSET } ; ; mhu = devm_kzalloc ( dev , sizeof ( * mhu ) , GFP_KERNEL ) ; if ( ! mhu ) { return - ENOMEM ; } mhu -> base = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( mhu -> base ) ) { dev_err ( dev , "ioremap failed\n" ) ; return PTR_ERR ( mhu -> base ) ; } for ( i = 0 ; i < MHU_CHANS ; i ++ ) { mhu -> chan [ i ] . con_priv = & mhu -> mlink [ i ] ; mhu -> mlink [ i ] . irq = platform_get_irq ( pdev , i ) ; if ( mhu -> mlink [ i ] . irq < 0 ) { dev_err ( dev , "failed to get irq%d\n" , i ) ; return mhu -> mlink [ i ] . irq ; } mhu -> mlink [ i ] . rx_reg = mhu -> base + platform_mhu_reg [ i ] ; mhu -> mlink [ i ] . tx_reg = mhu -> mlink [ i ] . rx_reg + TX_REG_OFFSET ; } mhu -> mbox . dev = dev ; mhu -> mbox . chans = & mhu -> chan [ 0 ] ; mhu -> mbox . num_chans = MHU_CHANS ; mhu -> mbox . ops = & platform_mhu_ops ; mhu -> mbox . txdone_irq = false ; mhu -> mbox . txdone_poll = true ; platform_set_drvdata ( pdev , mhu ) ; err = devm_mbox_controller_register ( dev , & mhu -> mbox ) ; if ( err ) { dev_err ( dev , "Failed to register mailboxes %d\n" , err ) ; return err ; } dev_info ( dev , "Platform MHU Mailbox registered\n" ) ; return 0 ; } 