static BOOL shadow_client_send_surface_update ( rdpShadowClient * client , SHADOW_GFX_STATUS * pStatus ) { BOOL ret = TRUE ; INT64 nXSrc , nYSrc ; INT64 nWidth , nHeight ; rdpContext * context = ( rdpContext * ) client ; rdpSettings * settings ; rdpShadowServer * server ; rdpShadowSurface * surface ; REGION16 invalidRegion ; RECTANGLE_16 surfaceRect ; const RECTANGLE_16 * extents ; BYTE * pSrcData ; UINT32 nSrcStep , SrcFormat ; UINT32 index ; int numRects = 0 ; const RECTANGLE_16 * rects ; if ( ! context || ! pStatus ) { return FALSE ; } settings = context -> settings ; server = client -> server ; if ( ! settings || ! server ) { return FALSE ; } surface = client -> inLobby ?server -> lobby : server -> surface ; if ( ! surface ) { return FALSE ; } EnterCriticalSection ( & ( client -> lock ) ) ; region16_init ( & invalidRegion ) ; region16_copy ( & invalidRegion , & ( client -> invalidRegion ) ) ; region16_clear ( & ( client -> invalidRegion ) ) ; LeaveCriticalSection ( & ( client -> lock ) ) ; EnterCriticalSection ( & surface -> lock ) ; rects = region16_rects ( & ( surface -> invalidRegion ) , & numRects ) ; for ( index = 0 ; index < numRects ; index ++ ) { region16_union_rect ( & invalidRegion , & invalidRegion , & rects [ index ] ) ; } surfaceRect . left = 0 ; surfaceRect . top = 0 ; WINPR_ASSERT ( surface -> width <= UINT16_MAX ) ; WINPR_ASSERT ( surface -> height <= UINT16_MAX ) ; surfaceRect . right = ( UINT16 ) surface -> width ; surfaceRect . bottom = ( UINT16 ) surface -> height ; region16_intersect_rect ( & invalidRegion , & invalidRegion , & surfaceRect ) ; if ( server -> shareSubRect ) { region16_intersect_rect ( & invalidRegion , & invalidRegion , & ( server -> subRect ) ) ; } if ( region16_is_empty ( & invalidRegion ) ) { out } extents = region16_extents ( & invalidRegion ) ; nXSrc = extents -> left ; nYSrc = extents -> top ; nWidth = extents -> right - extents -> left ; nHeight = extents -> bottom - extents -> top ; pSrcData = surface -> data ; nSrcStep = surface -> scanline ; SrcFormat = surface -> format ; if ( server -> shareSubRect ) { INT32 subX , subY ; subX = server -> subRect . left ; subY = server -> subRect . top ; nXSrc -= subX ; nYSrc -= subY ; WINPR_ASSERT ( nXSrc >= 0 ) ; WINPR_ASSERT ( nXSrc <= UINT16_MAX ) ; WINPR_ASSERT ( nYSrc >= 0 ) ; WINPR_ASSERT ( nYSrc <= UINT16_MAX ) ; pSrcData = & pSrcData [ ( ( UINT16 ) subY * nSrcStep ) + ( ( UINT16 ) subX * 4U ) ] ; } if ( settings -> SupportGraphicsPipeline && pStatus -> gfxOpened ) { nWidth = settings -> DesktopWidth ; nHeight = settings -> DesktopHeight ; if ( ! pStatus -> gfxSurfaceCreated ) { if ( ! ( ret = shadow_client_rdpgfx_reset_graphic ( client ) ) ) { out } if ( ! ( ret = shadow_client_rdpgfx_new_surface ( client ) ) ) { out } pStatus -> gfxSurfaceCreated = TRUE ; } WINPR_ASSERT ( nWidth >= 0 ) ; WINPR_ASSERT ( nWidth <= UINT16_MAX ) ; WINPR_ASSERT ( nHeight >= 0 ) ; WINPR_ASSERT ( nHeight <= UINT16_MAX ) ; ret = shadow_client_send_surface_gfx ( client , pSrcData , nSrcStep , SrcFormat , 0 , 0 , ( UINT16 ) nWidth , ( UINT16 ) nHeight ) ; } if ( settings -> RemoteFxCodec || freerdp_settings_get_bool ( settings , FreeRDP_NSCodec ) ) { WINPR_ASSERT ( nXSrc >= 0 ) ; WINPR_ASSERT ( nXSrc <= UINT16_MAX ) ; WINPR_ASSERT ( nYSrc >= 0 ) ; WINPR_ASSERT ( nYSrc <= UINT16_MAX ) ; WINPR_ASSERT ( nWidth >= 0 ) ; WINPR_ASSERT ( nWidth <= UINT16_MAX ) ; WINPR_ASSERT ( nHeight >= 0 ) ; WINPR_ASSERT ( nHeight <= UINT16_MAX ) ; ret = shadow_client_send_surface_bits ( client , pSrcData , nSrcStep , ( UINT16 ) nXSrc , ( UINT16 ) nYSrc , ( UINT16 ) nWidth , ( UINT16 ) nHeight ) ; } else { WINPR_ASSERT ( nXSrc >= 0 ) ; WINPR_ASSERT ( nXSrc <= UINT16_MAX ) ; WINPR_ASSERT ( nYSrc >= 0 ) ; WINPR_ASSERT ( nYSrc <= UINT16_MAX ) ; WINPR_ASSERT ( nWidth >= 0 ) ; WINPR_ASSERT ( nWidth <= UINT16_MAX ) ; WINPR_ASSERT ( nHeight >= 0 ) ; WINPR_ASSERT ( nHeight <= UINT16_MAX ) ; ret = shadow_client_send_bitmap_update ( client , pSrcData , nSrcStep , ( UINT16 ) nXSrc , ( UINT16 ) nYSrc , ( UINT16 ) nWidth , ( UINT16 ) nHeight ) ; } out LeaveCriticalSection ( & surface -> lock ) ; region16_uninit ( & invalidRegion ) ; return ret ; } 