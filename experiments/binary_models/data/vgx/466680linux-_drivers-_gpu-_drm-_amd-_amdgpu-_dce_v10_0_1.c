static int dce_v10_0_crtc_do_set_base ( struct drm_crtc * crtc , struct drm_framebuffer * fb , int x , int y , int atomic ) { struct amdgpu_crtc * amdgpu_crtc = to_amdgpu_crtc ( crtc ) ; struct drm_device * dev = crtc -> dev ; struct amdgpu_device * adev = drm_to_adev ( dev ) ; struct drm_framebuffer * target_fb ; struct drm_gem_object * obj ; struct amdgpu_bo * abo ; uint64_t fb_location , tiling_flags ; uint32_t fb_format , fb_pitch_pixels ; u32 fb_swap = REG_SET_FIELD ( 0 , GRPH_SWAP_CNTL , GRPH_ENDIAN_SWAP , ENDIAN_NONE ) ; u32 pipe_config ; u32 tmp , viewport_w , viewport_h ; int r ; bool bypass_lut = false ; if ( ! atomic && ! crtc -> primary -> fb ) { DRM_DEBUG_KMS ( "No FB bound\n" ) ; return 0 ; } if ( atomic ) { target_fb = fb ; } else { target_fb = crtc -> primary -> fb ; } obj = target_fb -> obj [ 0 ] ; abo = gem_to_amdgpu_bo ( obj ) ; r = amdgpu_bo_reserve ( abo , false ) ; if ( unlikely ( r != 0 ) ) { return r ; } if ( ! atomic ) { r = amdgpu_bo_pin ( abo , AMDGPU_GEM_DOMAIN_VRAM ) ; if ( unlikely ( r != 0 ) ) { amdgpu_bo_unreserve ( abo , NULL ) ; return - EINVAL ; } } fb_location = amdgpu_bo_gpu_offset ( abo ) ; amdgpu_bo_get_tiling_flags ( abo , & tiling_flags ) ; amdgpu_bo_unreserve ( abo ) ; pipe_config = AMDGPU_TILING_GET ( tiling_flags , PIPE_CONFIG ) ; switch ( target_fb -> format -> format ) { case DRM_FORMAT_C8 : fb_format = REG_SET_FIELD ( 0 , GRPH_CONTROL , GRPH_DEPTH , 0 ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_FORMAT , 0 ) ; break ; case DRM_FORMAT_XRGB4444 : case DRM_FORMAT_ARGB4444 : fb_format = REG_SET_FIELD ( 0 , GRPH_CONTROL , GRPH_DEPTH , 1 ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_FORMAT , 2 ) ; fb_swap = REG_SET_FIELD ( fb_swap , GRPH_SWAP_CNTL , GRPH_ENDIAN_SWAP , ENDIAN_8IN16 ) ; break ; case DRM_FORMAT_XRGB1555 : case DRM_FORMAT_ARGB1555 : fb_format = REG_SET_FIELD ( 0 , GRPH_CONTROL , GRPH_DEPTH , 1 ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_FORMAT , 0 ) ; fb_swap = REG_SET_FIELD ( fb_swap , GRPH_SWAP_CNTL , GRPH_ENDIAN_SWAP , ENDIAN_8IN16 ) ; break ; case DRM_FORMAT_BGRX5551 : case DRM_FORMAT_BGRA5551 : fb_format = REG_SET_FIELD ( 0 , GRPH_CONTROL , GRPH_DEPTH , 1 ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_FORMAT , 5 ) ; fb_swap = REG_SET_FIELD ( fb_swap , GRPH_SWAP_CNTL , GRPH_ENDIAN_SWAP , ENDIAN_8IN16 ) ; break ; case DRM_FORMAT_RGB565 : fb_format = REG_SET_FIELD ( 0 , GRPH_CONTROL , GRPH_DEPTH , 1 ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_FORMAT , 1 ) ; fb_swap = REG_SET_FIELD ( fb_swap , GRPH_SWAP_CNTL , GRPH_ENDIAN_SWAP , ENDIAN_8IN16 ) ; break ; case DRM_FORMAT_XRGB8888 : case DRM_FORMAT_ARGB8888 : fb_format = REG_SET_FIELD ( 0 , GRPH_CONTROL , GRPH_DEPTH , 2 ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_FORMAT , 0 ) ; fb_swap = REG_SET_FIELD ( fb_swap , GRPH_SWAP_CNTL , GRPH_ENDIAN_SWAP , ENDIAN_8IN32 ) ; break ; case DRM_FORMAT_XRGB2101010 : case DRM_FORMAT_ARGB2101010 : fb_format = REG_SET_FIELD ( 0 , GRPH_CONTROL , GRPH_DEPTH , 2 ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_FORMAT , 1 ) ; fb_swap = REG_SET_FIELD ( fb_swap , GRPH_SWAP_CNTL , GRPH_ENDIAN_SWAP , ENDIAN_8IN32 ) ; bypass_lut = true ; break ; case DRM_FORMAT_BGRX1010102 : case DRM_FORMAT_BGRA1010102 : fb_format = REG_SET_FIELD ( 0 , GRPH_CONTROL , GRPH_DEPTH , 2 ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_FORMAT , 4 ) ; fb_swap = REG_SET_FIELD ( fb_swap , GRPH_SWAP_CNTL , GRPH_ENDIAN_SWAP , ENDIAN_8IN32 ) ; bypass_lut = true ; break ; case DRM_FORMAT_XBGR8888 : case DRM_FORMAT_ABGR8888 : fb_format = REG_SET_FIELD ( 0 , GRPH_CONTROL , GRPH_DEPTH , 2 ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_FORMAT , 0 ) ; fb_swap = REG_SET_FIELD ( fb_swap , GRPH_SWAP_CNTL , GRPH_RED_CROSSBAR , 2 ) ; fb_swap = REG_SET_FIELD ( fb_swap , GRPH_SWAP_CNTL , GRPH_BLUE_CROSSBAR , 2 ) ; fb_swap = REG_SET_FIELD ( fb_swap , GRPH_SWAP_CNTL , GRPH_ENDIAN_SWAP , ENDIAN_8IN32 ) ; break ; default : DRM_ERROR ( "Unsupported screen format %p4cc\n" , & target_fb -> format -> format ) ; return - EINVAL ; } if ( AMDGPU_TILING_GET ( tiling_flags , ARRAY_MODE ) == ARRAY_2D_TILED_THIN1 ) { unsigned bankw , bankh , mtaspect , tile_split , num_banks ; bankw = AMDGPU_TILING_GET ( tiling_flags , BANK_WIDTH ) ; bankh = AMDGPU_TILING_GET ( tiling_flags , BANK_HEIGHT ) ; mtaspect = AMDGPU_TILING_GET ( tiling_flags , MACRO_TILE_ASPECT ) ; tile_split = AMDGPU_TILING_GET ( tiling_flags , TILE_SPLIT ) ; num_banks = AMDGPU_TILING_GET ( tiling_flags , NUM_BANKS ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_NUM_BANKS , num_banks ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_ARRAY_MODE , ARRAY_2D_TILED_THIN1 ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_TILE_SPLIT , tile_split ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_BANK_WIDTH , bankw ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_BANK_HEIGHT , bankh ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_MACRO_TILE_ASPECT , mtaspect ) ; fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_MICRO_TILE_MODE , ADDR_SURF_MICRO_TILING_DISPLAY ) ; } if ( AMDGPU_TILING_GET ( tiling_flags , ARRAY_MODE ) == ARRAY_1D_TILED_THIN1 ) { fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_ARRAY_MODE , ARRAY_1D_TILED_THIN1 ) ; } fb_format = REG_SET_FIELD ( fb_format , GRPH_CONTROL , GRPH_PIPE_CONFIG , pipe_config ) ; dce_v10_0_vga_enable ( crtc , false ) ; tmp = RREG32 ( mmGRPH_FLIP_CONTROL + amdgpu_crtc -> crtc_offset ) ; tmp = REG_SET_FIELD ( tmp , GRPH_FLIP_CONTROL , GRPH_SURFACE_UPDATE_H_RETRACE_EN , 0 ) ; WREG32 ( mmGRPH_FLIP_CONTROL + amdgpu_crtc -> crtc_offset , tmp ) ; WREG32 ( mmGRPH_PRIMARY_SURFACE_ADDRESS_HIGH + amdgpu_crtc -> crtc_offset , upper_32_bits ( fb_location ) ) ; WREG32 ( mmGRPH_SECONDARY_SURFACE_ADDRESS_HIGH + amdgpu_crtc -> crtc_offset , upper_32_bits ( fb_location ) ) ; WREG32 ( mmGRPH_PRIMARY_SURFACE_ADDRESS + amdgpu_crtc -> crtc_offset , ( u32 ) fb_location & GRPH_PRIMARY_SURFACE_ADDRESS__GRPH_PRIMARY_SURFACE_ADDRESS_MASK ) ; WREG32 ( mmGRPH_SECONDARY_SURFACE_ADDRESS + amdgpu_crtc -> crtc_offset , ( u32 ) fb_location & GRPH_SECONDARY_SURFACE_ADDRESS__GRPH_SECONDARY_SURFACE_ADDRESS_MASK ) ; WREG32 ( mmGRPH_CONTROL + amdgpu_crtc -> crtc_offset , fb_format ) ; WREG32 ( mmGRPH_SWAP_CNTL + amdgpu_crtc -> crtc_offset , fb_swap ) ; tmp = RREG32 ( mmGRPH_LUT_10BIT_BYPASS + amdgpu_crtc -> crtc_offset ) ; if ( bypass_lut ) { tmp = REG_SET_FIELD ( tmp , GRPH_LUT_10BIT_BYPASS , GRPH_LUT_10BIT_BYPASS_EN , 1 ) ; } else { tmp = REG_SET_FIELD ( tmp , GRPH_LUT_10BIT_BYPASS , GRPH_LUT_10BIT_BYPASS_EN , 0 ) ; } WREG32 ( mmGRPH_LUT_10BIT_BYPASS + amdgpu_crtc -> crtc_offset , tmp ) ; if ( bypass_lut ) { DRM_DEBUG_KMS ( "Bypassing hardware LUT due to 10 bit fb scanout.\n" ) ; } WREG32 ( mmGRPH_SURFACE_OFFSET_X + amdgpu_crtc -> crtc_offset , 0 ) ; WREG32 ( mmGRPH_SURFACE_OFFSET_Y + amdgpu_crtc -> crtc_offset , 0 ) ; WREG32 ( mmGRPH_X_START + amdgpu_crtc -> crtc_offset , 0 ) ; WREG32 ( mmGRPH_Y_START + amdgpu_crtc -> crtc_offset , 0 ) ; WREG32 ( mmGRPH_X_END + amdgpu_crtc -> crtc_offset , target_fb -> width ) ; WREG32 ( mmGRPH_Y_END + amdgpu_crtc -> crtc_offset , target_fb -> height ) ; fb_pitch_pixels = target_fb -> pitches [ 0 ] / target_fb -> format -> cpp [ 0 ] ; WREG32 ( mmGRPH_PITCH + amdgpu_crtc -> crtc_offset , fb_pitch_pixels ) ; dce_v10_0_grph_enable ( crtc , true ) ; WREG32 ( mmLB_DESKTOP_HEIGHT + amdgpu_crtc -> crtc_offset , target_fb -> height ) ; x &= ~ 3 ; y &= ~ 1 ; WREG32 ( mmVIEWPORT_START + amdgpu_crtc -> crtc_offset , ( x << 16 ) | y ) ; viewport_w = crtc -> mode . hdisplay ; viewport_h = ( crtc -> mode . vdisplay + 1 ) & ~ 1 ; WREG32 ( mmVIEWPORT_SIZE + amdgpu_crtc -> crtc_offset , ( viewport_w << 16 ) | viewport_h ) ; WREG32 ( mmMASTER_UPDATE_MODE + amdgpu_crtc -> crtc_offset , 0 ) ; if ( ! atomic && fb && fb != crtc -> primary -> fb ) { abo = gem_to_amdgpu_bo ( fb -> obj [ 0 ] ) ; r = amdgpu_bo_reserve ( abo , true ) ; if ( unlikely ( r != 0 ) ) { return r ; } amdgpu_bo_unpin ( abo ) ; amdgpu_bo_unreserve ( abo ) ; } dce_v10_0_bandwidth_update ( adev ) ; return 0 ; } 