static bool update ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 ) { if ( ! VAR2 -> VAR6 ) { FUN1 ( "" ) ; return false ; } struct aes_state VAR7 ; const int VAR8 = ( VAR9 - ( VAR5 % VAR9 ) ) % VAR9 ; const int VAR10 = VAR5 + VAR8 ; const int VAR11 = VAR10 / VAR9 ; VAR3 * const VAR12 = calloc ( 1 , VAR10 ) ; if ( ! VAR12 ) { return false ; } VAR3 * const VAR13 = calloc ( 1 , VAR10 ) ; if ( ! VAR13 ) { return false ; } memset ( VAR13 , 0 , VAR10 ) ; memcpy ( VAR13 , VAR4 , VAR5 ) ; if ( VAR8 ) { VAR13 [ VAR5 ] = 8 ; } VAR7 . VAR14 = VAR2 -> VAR15 ; VAR7 . VAR16 = 6 + ( int ) ( VAR7 . VAR14 / 4 ) ; VAR7 . VAR17 = ( int ) ( VAR7 . VAR14 / 4 ) ; memcpy ( VAR7 . VAR18 , VAR2 -> VAR18 , VAR7 . VAR14 ) ; int VAR19 , VAR20 ; if ( VAR2 -> VAR21 == 0 ) { for ( VAR19 = 0 ; VAR19 < VAR11 ; VAR19 ++ ) { for ( VAR20 = 0 ; VAR20 < VAR9 ; VAR20 ++ ) { VAR13 [ VAR19 * VAR9 + VAR20 ] ^= VAR2 -> VAR6 [ VAR20 ] ; } FUN2 ( & VAR7 , VAR13 + VAR9 * VAR19 , VAR12 + VAR9 * VAR19 ) ; memcpy ( VAR2 -> VAR6 , VAR12 + VAR9 * VAR19 , VAR9 ) ; } } if ( VAR2 -> VAR21 == 1 ) { for ( VAR19 = 0 ; VAR19 < VAR11 ; VAR19 ++ ) { FUN3 ( & VAR7 , VAR13 + VAR9 * VAR19 , VAR12 + VAR9 * VAR19 ) ; for ( VAR20 = 0 ; VAR20 < VAR9 ; VAR20 ++ ) { VAR12 [ VAR19 * VAR9 + VAR20 ] ^= VAR2 -> VAR6 [ VAR20 ] ; } memcpy ( VAR2 -> VAR6 , VAR4 + VAR9 * VAR19 , VAR9 ) ; } } FUN4 ( VAR2 , VAR12 , VAR10 ) ; free ( VAR12 ) ; free ( VAR13 ) ; return true ; }