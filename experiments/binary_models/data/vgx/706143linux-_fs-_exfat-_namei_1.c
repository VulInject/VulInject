static int exfat_find ( struct inode * dir , struct qstr * qname , struct exfat_dir_entry * info ) { int ret , dentry , count ; struct exfat_chain cdir ; struct exfat_uni_name uni_name ; struct super_block * sb = dir -> i_sb ; struct exfat_sb_info * sbi = EXFAT_SB ( sb ) ; struct exfat_inode_info * ei = EXFAT_I ( dir ) ; struct exfat_dentry * ep , * ep2 ; struct exfat_entry_set_cache es ; struct exfat_hint hint_opt ; if ( qname -> len == 0 ) { return - ENOENT ; } ret = exfat_resolve_path_for_lookup ( dir , qname -> name , & cdir , & uni_name ) ; if ( ei -> version != ( inode_peek_iversion_raw ( dir ) & 0xffffffff ) ) { ei -> hint_stat . clu = cdir . dir ; ei -> hint_stat . eidx = 0 ; ei -> version = ( inode_peek_iversion_raw ( dir ) & 0xffffffff ) ; ei -> hint_femp . eidx = EXFAT_HINT_NONE ; } dentry = exfat_find_dir_entry ( sb , ei , & cdir , & uni_name , & hint_opt ) ; if ( dentry < 0 ) { return dentry ; } info -> dir = cdir ; info -> entry = dentry ; info -> num_subdirs = 0 ; cdir . dir = hint_opt . clu ; if ( cdir . flags & ALLOC_NO_FAT_CHAIN ) { cdir . size -= dentry / sbi -> dentries_per_clu ; } dentry = hint_opt . eidx ; if ( exfat_get_dentry_set ( & es , sb , & cdir , dentry , ES_2_ENTRIES ) ) { return - EIO ; } ep = exfat_get_dentry_cached ( & es , ES_IDX_FILE ) ; ep2 = exfat_get_dentry_cached ( & es , ES_IDX_STREAM ) ; info -> type = exfat_get_entry_type ( ep ) ; info -> attr = le16_to_cpu ( ep -> dentry . file . attr ) ; info -> size = le64_to_cpu ( ep2 -> dentry . stream . valid_size ) ; if ( ( info -> type == TYPE_FILE ) && ( info -> size == 0 ) ) { info -> flags = ALLOC_NO_FAT_CHAIN ; info -> start_clu = EXFAT_EOF_CLUSTER ; } else { info -> flags = ep2 -> dentry . stream . flags ; info -> start_clu = le32_to_cpu ( ep2 -> dentry . stream . start_clu ) ; } exfat_get_entry_time ( sbi , & info -> crtime , ep -> dentry . file . create_tz , ep -> dentry . file . create_time , ep -> dentry . file . create_date , ep -> dentry . file . create_time_cs ) ; exfat_get_entry_time ( sbi , & info -> mtime , ep -> dentry . file . modify_tz , ep -> dentry . file . modify_time , ep -> dentry . file . modify_date , ep -> dentry . file . modify_time_cs ) ; exfat_get_entry_time ( sbi , & info -> atime , ep -> dentry . file . access_tz , ep -> dentry . file . access_time , ep -> dentry . file . access_date , 0 ) ; exfat_put_dentry_set ( & es , false ) ; if ( ei -> start_clu == EXFAT_FREE_CLUSTER ) { exfat_fs_error ( sb , "non-zero size file starts with zero cluster (size : %llu, p_dir : %u, entry : 0x%08x)" , i_size_read ( dir ) , ei -> dir . dir , ei -> entry ) ; return - EIO ; } if ( info -> type == TYPE_DIR ) { exfat_chain_set ( & cdir , info -> start_clu , EXFAT_B_TO_CLU ( info -> size , sbi ) , info -> flags ) ; count = exfat_count_dir_entries ( sb , & cdir ) ; if ( count < 0 ) { return - EIO ; } info -> num_subdirs = count + EXFAT_MIN_SUBDIR ; } return 0 ; } 