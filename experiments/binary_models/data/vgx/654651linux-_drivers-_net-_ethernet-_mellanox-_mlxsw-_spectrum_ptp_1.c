struct mlxsw_sp_ptp_clock * mlxsw_sp1_ptp_clock_init ( struct mlxsw_sp * mlxsw_sp , struct device * dev ) { u64 overflow_cycles , nsec , frac = 0 ; struct mlxsw_sp1_ptp_clock * clock ; int err ; clock = kzalloc ( sizeof ( * clock ) , GFP_KERNEL ) ; if ( ! clock ) { return ERR_PTR ( - ENOMEM ) ; } spin_lock_init ( & clock -> lock ) ; clock -> cycles . read = mlxsw_sp1_ptp_read_frc ; clock -> cycles . shift = MLXSW_SP1_PTP_CLOCK_CYCLES_SHIFT ; clock -> cycles . mult = clocksource_khz2mult ( MLXSW_SP1_PTP_CLOCK_FREQ_KHZ , clock -> cycles . shift ) ; clock -> nominal_c_mult = clock -> cycles . mult ; clock -> cycles . mask = CLOCKSOURCE_MASK ( MLXSW_SP1_PTP_CLOCK_MASK ) ; clock -> common . core = mlxsw_sp -> core ; timecounter_init ( & clock -> tc , & clock -> cycles , 0 ) ; overflow_cycles = div64_u64 ( ~ 0ULL >> 1 , clock -> cycles . mult ) ; overflow_cycles = min ( overflow_cycles , div_u64 ( clock -> cycles . mask , 3 ) ) ; nsec = cyclecounter_cyc2ns ( & clock -> cycles , overflow_cycles , 0 , & frac ) ; clock -> overflow_period = nsecs_to_jiffies ( nsec ) ; INIT_DELAYED_WORK ( & clock -> overflow_work , mlxsw_sp1_ptp_clock_overflow ) ; mlxsw_core_schedule_dw ( & clock -> overflow_work , 0 ) ; clock -> common . ptp_info = mlxsw_sp1_ptp_clock_info ; clock -> common . ptp = ptp_clock_register ( & clock -> common . ptp_info , dev ) ; if ( IS_ERR ( clock -> common . ptp ) ) { err = PTR_ERR ( clock -> common . ptp ) ; dev_err ( dev , "ptp_clock_register failed %d\n" , err ) ; err_ptp_clock_register } return & clock -> common ; err_ptp_clock_register cancel_delayed_work_sync ( & clock -> overflow_work ) ; return ERR_PTR ( err ) ; } 