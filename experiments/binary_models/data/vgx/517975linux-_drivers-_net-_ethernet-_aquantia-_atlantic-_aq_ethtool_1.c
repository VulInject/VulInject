static void aq_ethtool_get_strings ( struct net_device * ndev , u32 stringset , u8 * data ) { struct aq_nic_s * nic = netdev_priv ( ndev ) ; struct aq_nic_cfg_s * cfg ; u8 * p = data ; int i , si ; int sa ; cfg = aq_nic_get_cfg ( nic ) ; switch ( stringset ) { case ETH_SS_STATS : { const int rx_stat_cnt = ARRAY_SIZE ( aq_ethtool_queue_rx_stat_names ) ; const int tx_stat_cnt = ARRAY_SIZE ( aq_ethtool_queue_tx_stat_names ) ; char tc_string [ 8 ] ; int tc ; memset ( tc_string , 0 , sizeof ( tc_string ) ) ; memcpy ( p , aq_ethtool_stat_names , sizeof ( aq_ethtool_stat_names ) ) ; p = p + sizeof ( aq_ethtool_stat_names ) ; for ( tc = 0 ; tc < cfg -> tcs ; tc ++ ) { if ( cfg -> is_qos ) { snprintf ( tc_string , 8 , "TC%d " , tc ) ; } for ( i = 0 ; i < cfg -> vecs ; i ++ ) { for ( si = 0 ; si < rx_stat_cnt ; si ++ ) { snprintf ( p , ETH_GSTRING_LEN , aq_ethtool_queue_rx_stat_names [ si ] , tc_string , AQ_NIC_CFG_TCVEC2RING ( cfg , tc , i ) ) ; p += ETH_GSTRING_LEN ; } for ( si = 0 ; si < tx_stat_cnt ; si ++ ) { snprintf ( p , ETH_GSTRING_LEN , aq_ethtool_queue_tx_stat_names [ si ] , tc_string , AQ_NIC_CFG_TCVEC2RING ( cfg , tc , i ) ) ; p += ETH_GSTRING_LEN ; } } } if ( nic -> aq_ptp ) { const int rx_ring_cnt = aq_ptp_get_ring_cnt ( nic , ATL_RING_RX ) ; const int tx_ring_cnt = aq_ptp_get_ring_cnt ( nic , ATL_RING_TX ) ; unsigned int ptp_ring_idx = aq_ptp_ring_idx ( nic -> aq_nic_cfg . tc_mode ) ; snprintf ( tc_string , 8 , "PTP " ) ; for ( i = 0 ; i < max ( rx_ring_cnt , tx_ring_cnt ) ; i ++ ) { for ( si = 0 ; si < rx_stat_cnt ; si ++ ) { snprintf ( p , ETH_GSTRING_LEN , aq_ethtool_queue_rx_stat_names [ si ] , tc_string , i ?PTP_HWST_RING_IDX : ptp_ring_idx ) ; p += ETH_GSTRING_LEN ; } if ( i >= tx_ring_cnt ) { continue ; } for ( si = 0 ; si < tx_stat_cnt ; si ++ ) { snprintf ( p , ETH_GSTRING_LEN , aq_ethtool_queue_tx_stat_names [ si ] , tc_string , i ?PTP_HWST_RING_IDX : ptp_ring_idx ) ; p += ETH_GSTRING_LEN ; } } } memcpy ( p , aq_macsec_stat_names , sizeof ( aq_macsec_stat_names ) ) ; p = p + sizeof ( aq_macsec_stat_names ) ; for ( i = 0 ; i < AQ_MACSEC_MAX_SC ; i ++ ) { struct aq_macsec_txsc * aq_txsc ; if ( ! ( test_bit ( i , & nic -> macsec_cfg -> txsc_idx_busy ) ) ) { continue ; } for ( si = 0 ; si < ARRAY_SIZE ( aq_macsec_txsc_stat_names ) ; si ++ ) { snprintf ( p , ETH_GSTRING_LEN , aq_macsec_txsc_stat_names [ si ] , i ) ; p += ETH_GSTRING_LEN ; } aq_txsc = & nic -> macsec_cfg -> aq_txsc [ i ] ; for ( sa = 0 ; sa < MACSEC_NUM_AN ; sa ++ ) { if ( ! ( test_bit ( sa , & aq_txsc -> tx_sa_idx_busy ) ) ) { continue ; } for ( si = 0 ; si < ARRAY_SIZE ( aq_macsec_txsa_stat_names ) ; si ++ ) { snprintf ( p , ETH_GSTRING_LEN , aq_macsec_txsa_stat_names [ si ] , i , sa ) ; p += ETH_GSTRING_LEN ; } } } for ( i = 0 ; i < AQ_MACSEC_MAX_SC ; i ++ ) { struct aq_macsec_rxsc * aq_rxsc ; if ( ! ( test_bit ( i , & nic -> macsec_cfg -> rxsc_idx_busy ) ) ) { continue ; } aq_rxsc = & nic -> macsec_cfg -> aq_rxsc [ i ] ; for ( sa = 0 ; sa < MACSEC_NUM_AN ; sa ++ ) { if ( ! ( test_bit ( sa , & aq_rxsc -> rx_sa_idx_busy ) ) ) { continue ; } for ( si = 0 ; si < ARRAY_SIZE ( aq_macsec_rxsa_stat_names ) ; si ++ ) { snprintf ( p , ETH_GSTRING_LEN , aq_macsec_rxsa_stat_names [ si ] , i , sa ) ; p += ETH_GSTRING_LEN ; } } } break ; } case ETH_SS_PRIV_FLAGS : memcpy ( p , aq_ethtool_priv_flag_names , sizeof ( aq_ethtool_priv_flag_names ) ) ; break ; } } 