static int _nfs4_do_setattr ( struct inode * inode , struct nfs_setattrargs * arg , struct nfs_setattrres * res , struct rpc_cred * cred , struct nfs_open_context * ctx ) { struct nfs_server * server = NFS_SERVER ( inode ) ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_SETATTR ] . rpc_argp = arg . rpc_resp = res . rpc_cred = cred } ; struct rpc_cred * delegation_cred = NULL ; unsigned long timestamp = jiffies ; fmode_t fmode ; bool truncate ; int status ; nfs_fattr_init ( res -> fattr ) ; truncate = ( arg -> iap -> ia_valid & ATTR_SIZE ) ?true : false ; fmode = truncate ?FMODE_WRITE : FMODE_READ ; if ( nfs4_copy_delegation_stateid ( inode , fmode , & arg -> stateid , & delegation_cred ) ) { } if ( truncate && ctx != NULL ) { struct nfs_lock_context * l_ctx ; l_ctx = nfs_get_lock_context ( ctx ) ; if ( IS_ERR ( l_ctx ) ) { return PTR_ERR ( l_ctx ) ; } status = nfs4_select_rw_stateid ( ctx -> state , FMODE_WRITE , l_ctx , & arg -> stateid , & delegation_cred ) ; nfs_put_lock_context ( l_ctx ) ; if ( status == - EIO ) { return - EBADF ; } } else { nfs4_stateid_copy ( & arg -> stateid , & zero_stateid ) ; } if ( delegation_cred ) { msg . rpc_cred = delegation_cred ; } status = nfs4_call_sync ( server -> client , server , & msg , & arg -> seq_args , & res -> seq_res , 1 ) ; put_rpccred ( delegation_cred ) ; if ( status == 0 && ctx != NULL ) { renew_lease ( server , timestamp ) ; } trace_nfs4_setattr ( inode , & arg -> stateid , status ) ; return status ; } 