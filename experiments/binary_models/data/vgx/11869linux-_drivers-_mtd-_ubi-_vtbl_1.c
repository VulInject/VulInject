static int init_volumes ( struct ubi_device * ubi , const struct ubi_attach_info * ai , const struct ubi_vtbl_record * vtbl ) { int i , err , reserved_pebs = 0 ; struct ubi_ainf_volume * av ; struct ubi_volume * vol ; for ( i = 0 ; i < ubi -> vtbl_slots ; i ++ ) { cond_resched ( ) ; if ( be32_to_cpu ( vtbl [ i ] . reserved_pebs ) == 0 ) { continue ; } vol = kzalloc ( sizeof ( ubi_volume ) , GFP_KERNEL ) ; vol -> reserved_pebs = be32_to_cpu ( vtbl [ i ] . reserved_pebs ) ; vol -> alignment = be32_to_cpu ( vtbl [ i ] . alignment ) ; vol -> data_pad = be32_to_cpu ( vtbl [ i ] . data_pad ) ; vol -> upd_marker = vtbl [ i ] . upd_marker ; vol -> vol_type = vtbl [ i ] . vol_type == UBI_VID_DYNAMIC ?UBI_DYNAMIC_VOLUME : UBI_STATIC_VOLUME ; vol -> name_len = be16_to_cpu ( vtbl [ i ] . name_len ) ; vol -> usable_leb_size = ubi -> leb_size - vol -> data_pad ; memcpy ( vol -> name , vtbl [ i ] . name , vol -> name_len ) ; vol -> name [ vol -> name_len ] = '\0' ; vol -> vol_id = i ; if ( vtbl [ i ] . flags & UBI_VTBL_SKIP_CRC_CHECK_FLG ) { vol -> skip_check = 1 ; } if ( vtbl [ i ] . flags & UBI_VTBL_AUTORESIZE_FLG ) { if ( ubi -> autoresize_vol_id != - 1 ) { ubi_err ( ubi , "more than one auto-resize volume (%d and %d)" , ubi -> autoresize_vol_id , i ) ; kfree ( vol ) ; return - EINVAL ; } ubi -> autoresize_vol_id = i ; } ubi_assert ( ! ubi -> volumes [ i ] ) ; ubi -> volumes [ i ] = vol ; ubi -> vol_count += 1 ; vol -> ubi = ubi ; reserved_pebs += vol -> reserved_pebs ; err = ubi_fastmap_init_checkmap ( vol , ubi -> peb_count ) ; if ( err ) { return err ; } if ( vol -> vol_type == UBI_DYNAMIC_VOLUME ) { vol -> used_ebs = vol -> reserved_pebs ; vol -> last_eb_bytes = vol -> usable_leb_size ; vol -> used_bytes = ( long long ) vol -> used_ebs * vol -> usable_leb_size ; continue ; } av = ubi_find_av ( ai , i ) ; if ( ! av || ! av -> leb_count ) { continue ; } if ( av -> leb_count != av -> used_ebs ) { ubi_warn ( ubi , "static volume %d misses %d LEBs - corrupted" , av -> vol_id , av -> used_ebs - av -> leb_count ) ; vol -> corrupted = 1 ; continue ; } vol -> used_ebs = av -> used_ebs ; vol -> used_bytes = ( long long ) ( vol -> used_ebs - 1 ) * vol -> usable_leb_size ; vol -> used_bytes += av -> last_data_size ; vol -> last_eb_bytes = av -> last_data_size ; } vol = kzalloc ( sizeof ( ubi_volume ) , GFP_KERNEL ) ; if ( ! vol ) { return - ENOMEM ; } vol -> reserved_pebs = UBI_LAYOUT_VOLUME_EBS ; vol -> alignment = UBI_LAYOUT_VOLUME_ALIGN ; vol -> vol_type = UBI_DYNAMIC_VOLUME ; vol -> name_len = sizeof ( UBI_LAYOUT_VOLUME_NAME ) - 1 ; memcpy ( vol -> name , UBI_LAYOUT_VOLUME_NAME , vol -> name_len + 1 ) ; vol -> usable_leb_size = ubi -> leb_size ; vol -> used_ebs = vol -> reserved_pebs ; vol -> last_eb_bytes = vol -> reserved_pebs ; vol -> used_bytes = ( long long ) vol -> used_ebs * ( ubi -> leb_size - vol -> data_pad ) ; vol -> vol_id = UBI_LAYOUT_VOLUME_ID ; vol -> ref_count = 1 ; ubi_assert ( ! ubi -> volumes [ i ] ) ; ubi -> volumes [ vol_id2idx ( ubi , vol -> vol_id ) ] = vol ; reserved_pebs += vol -> reserved_pebs ; ubi -> vol_count += 1 ; vol -> ubi = ubi ; err = ubi_fastmap_init_checkmap ( vol , UBI_LAYOUT_VOLUME_EBS ) ; if ( err ) { return err ; } if ( reserved_pebs > ubi -> avail_pebs ) { ubi_err ( ubi , "not enough PEBs, required %d, available %d" , reserved_pebs , ubi -> avail_pebs ) ; if ( ubi -> corr_peb_count ) { ubi_err ( ubi , "%d PEBs are corrupted and not used" , ubi -> corr_peb_count ) ; } return - ENOSPC ; } ubi -> rsvd_pebs += reserved_pebs ; ubi -> avail_pebs -= reserved_pebs ; return 0 ; } 