static void sun4i_usb_phy0_id_vbus_det_scan ( struct work_struct * work ) { struct sun4i_usb_phy_data * data = container_of ( work , sun4i_usb_phy_data , detect . work ) ; struct phy * phy0 = data -> phys [ 0 ] . phy ; struct sun4i_usb_phy * phy ; bool force_session_end , id_notify = false , vbus_notify = false ; int id_det , vbus_det ; if ( ! phy0 ) { return ; } phy = phy_get_drvdata ( phy0 ) ; id_det = sun4i_usb_phy0_get_id_det ( data ) ; vbus_det = sun4i_usb_phy0_get_vbus_det ( data ) ; mutex_lock ( & phy0 -> mutex ) ; if ( ! data -> phy0_init ) { mutex_unlock ( & phy0 -> mutex ) ; return ; } force_session_end = data -> force_session_end ; data -> force_session_end = false ; if ( id_det != data -> id_det ) { if ( data -> dr_mode == USB_DR_MODE_OTG && ! sun4i_usb_phy0_have_vbus_det ( data ) ) { force_session_end = true ; } if ( force_session_end && id_det == 0 ) { sun4i_usb_phy0_set_vbus_detect ( phy0 , 0 ) ; msleep ( 200 ) ; sun4i_usb_phy0_set_vbus_detect ( phy0 , 1 ) ; } sun4i_usb_phy0_set_id_detect ( phy0 , id_det ) ; data -> id_det = id_det ; id_notify = true ; } if ( vbus_det != data -> vbus_det ) { sun4i_usb_phy0_set_vbus_detect ( phy0 , vbus_det ) ; vbus_notify = true ; } mutex_unlock ( & phy0 -> mutex ) ; if ( id_notify ) { extcon_set_state_sync ( data -> extcon , EXTCON_USB_HOST , ! id_det ) ; if ( force_session_end && id_det == 1 ) { mutex_lock ( & phy0 -> mutex ) ; sun4i_usb_phy0_set_vbus_detect ( phy0 , 0 ) ; msleep ( 1000 ) ; sun4i_usb_phy0_set_vbus_detect ( phy0 , 1 ) ; mutex_unlock ( & phy0 -> mutex ) ; } sun4i_usb_phy_passby ( phy , ! id_det ) ; if ( data -> cfg -> phy0_dual_route ) { sun4i_usb_phy0_reroute ( data , id_det ) ; } } if ( vbus_notify ) { extcon_set_state_sync ( data -> extcon , EXTCON_USB , vbus_det ) ; } if ( sun4i_usb_phy0_poll ( data ) ) { queue_delayed_work ( system_wq , & data -> detect , POLL_TIME ) ; } } 