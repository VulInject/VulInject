int slhc_compress ( struct slcompress * comp , unsigned char * icp , int isize , unsigned char * ocp , unsigned char * * cpp , int compress_cid ) { register struct cstate * ocs = & ( comp -> tstate [ comp -> xmit_oldest ] ) ; register struct cstate * lcs = ocs ; register struct cstate * cs = lcs -> next ; register unsigned long deltaS , deltaA ; register short changes = 0 ; int hlen ; unsigned char new_seq [ 16 ] ; register unsigned char * cp = new_seq ; struct iphdr * ip ; struct tcphdr * th , * oth ; __sum16 csum ; ip = ( iphdr * ) icp ; if ( ip -> protocol != IPPROTO_TCP || ( ntohs ( ip -> frag_off ) & 0x3fff ) ) { if ( ip -> protocol != IPPROTO_TCP ) { comp -> sls_o_nontcp ++ ; } else { comp -> sls_o_tcp ++ ; } return isize ; } th = ( tcphdr * ) ( ( ( unsigned char * ) ip ) + ip -> ihl * 4 ) ; hlen = ip -> ihl * 4 + th -> doff * 4 ; if ( hlen > isize || th -> syn || th -> fin || th -> rst || ! ( th -> ack ) ) { comp -> sls_o_tcp ++ ; return isize ; } for ( ; ; ) { if ( ip -> saddr == cs -> cs_ip . saddr && ip -> daddr == cs -> cs_ip . daddr && th -> source == cs -> cs_tcp . source && th -> dest == cs -> cs_tcp . dest ) { found } if ( cs == ocs ) { break ; } lcs = cs ; cs = cs -> next ; comp -> sls_o_searches ++ ; } comp -> sls_o_misses ++ ; comp -> xmit_oldest = lcs -> cs_this ; uncompressed found if ( lcs == ocs ) { } if ( cs == ocs ) { comp -> xmit_oldest = lcs -> cs_this ; } else { lcs -> next = cs -> next ; cs -> next = ocs -> next ; ocs -> next = cs ; } oth = & cs -> cs_tcp ; if ( ip -> version != cs -> cs_ip . version || ip -> ihl != cs -> cs_ip . ihl || ip -> tos != cs -> cs_ip . tos || ( ip -> frag_off & htons ( 0x4000 ) ) != ( cs -> cs_ip . frag_off & htons ( 0x4000 ) ) || ip -> ttl != cs -> cs_ip . ttl || th -> doff != cs -> cs_tcp . doff || ( ip -> ihl > 5 && memcmp ( ip + 1 , cs -> cs_ipopt , ( ( ip -> ihl ) - 5 ) * 4 ) != 0 ) || ( th -> doff > 5 && memcmp ( th + 1 , cs -> cs_tcpopt , ( ( th -> doff ) - 5 ) * 4 ) != 0 ) ) { uncompressed } if ( th -> urg ) { deltaS = ntohs ( th -> urg_ptr ) ; cp = encode ( cp , deltaS ) ; changes |= NEW_U ; } if ( th -> urg_ptr != oth -> urg_ptr ) { uncompressed } if ( ( deltaS = ntohs ( th -> window ) - ntohs ( oth -> window ) ) != 0 ) { cp = encode ( cp , deltaS ) ; changes |= NEW_W ; } if ( ( deltaA = ntohl ( th -> ack_seq ) - ntohl ( oth -> ack_seq ) ) != 0L ) { if ( deltaA > 0x0000ffff ) { uncompressed } cp = encode ( cp , deltaA ) ; changes |= NEW_A ; } if ( ( deltaS = ntohl ( th -> seq ) - ntohl ( oth -> seq ) ) != 0L ) { if ( deltaS > 0x0000ffff ) { uncompressed } cp = encode ( cp , deltaS ) ; changes |= NEW_S ; } switch ( changes ) { case 0 : if ( ip -> tot_len != cs -> cs_ip . tot_len && ntohs ( cs -> cs_ip . tot_len ) == hlen ) { break ; } uncompressed case SPECIAL_I : case SPECIAL_D : uncompressed case NEW_S | NEW_A : if ( deltaS == deltaA && deltaS == ntohs ( cs -> cs_ip . tot_len ) - hlen ) { changes = SPECIAL_I ; cp = new_seq ; } break ; case NEW_S : if ( deltaS == ntohs ( cs -> cs_ip . tot_len ) - hlen ) { changes = SPECIAL_D ; cp = new_seq ; } break ; } deltaS = ntohs ( ip -> id ) - ntohs ( cs -> cs_ip . id ) ; if ( deltaS != 1 ) { cp = encode ( cp , deltaS ) ; changes |= NEW_I ; } if ( th -> psh ) { changes |= TCP_PUSH_BIT ; } csum = th -> check ; memcpy ( & cs -> cs_ip , ip , 20 ) ; memcpy ( & cs -> cs_tcp , th , 20 ) ; deltaS = cp - new_seq ; if ( compress_cid == 0 || comp -> xmit_current != cs -> cs_this ) { cp = ocp ; * cpp = ocp ; * cp ++ = changes | NEW_C ; * cp ++ = cs -> cs_this ; comp -> xmit_current = cs -> cs_this ; } else { cp = ocp ; * cpp = ocp ; * cp ++ = changes ; } * ( __sum16 * ) cp = csum ; cp += 2 ; memcpy ( cp , new_seq , deltaS ) ; memcpy ( cp + deltaS , icp + hlen , isize - hlen ) ; comp -> sls_o_compressed ++ ; ocp [ 0 ] |= SL_TYPE_COMPRESSED_TCP ; return isize - hlen + deltaS + ( cp - ocp ) ; uncompressed memcpy ( & cs -> cs_ip , ip , 20 ) ; memcpy ( & cs -> cs_tcp , th , 20 ) ; if ( ip -> ihl > 5 ) { memcpy ( cs -> cs_ipopt , ip + 1 , ( ( ip -> ihl ) - 5 ) * 4 ) ; } if ( th -> doff > 5 ) { memcpy ( cs -> cs_tcpopt , th + 1 , ( ( th -> doff ) - 5 ) * 4 ) ; } comp -> xmit_current = cs -> cs_this ; comp -> sls_o_uncompressed ++ ; memcpy ( ocp , icp , isize ) ; * cpp = ocp ; ocp [ 9 ] = cs -> cs_this ; ocp [ 0 ] |= SL_TYPE_UNCOMPRESSED_TCP ; return isize ; } 