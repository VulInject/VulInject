void lsa_merge ( struct rde_nbr * nbr , struct lsa * lsa , struct vertex * v ) { struct timeval tv ; struct timespec tp ; time_t now ; u_int16_t len ; if ( v == NULL ) { if ( lsa_add ( nbr , lsa ) ) { return ; } rde_imsg_compose_ospfe ( IMSG_LS_FLOOD , nbr -> peerid , 0 , lsa , ntohs ( lsa -> hdr . len ) ) ; return ; } lsa -> hdr . seq_num = v -> lsa -> hdr . seq_num ; len = ntohs ( lsa -> hdr . len ) ; lsa -> hdr . ls_chksum = 0 ; lsa -> hdr . ls_chksum = htons ( iso_cksum ( lsa , len , LS_CKSUM_OFFSET ) ) ; if ( lsa_equal ( lsa , v -> lsa ) ) { return ; } free ( v -> lsa ) ; v -> lsa = lsa ; start_spf_timer ( ) ; if ( v -> type != LSA_TYPE_EXTERNAL && v -> type != LSA_TYPE_AS_OPAQ ) { nbr -> area -> dirty = 1 ; } clock_gettime ( CLOCK_MONOTONIC , & tp ) ; now = tp . tv_sec ; timerclear ( & tv ) ; if ( v -> changed + MIN_LS_INTERVAL >= now ) { tv . tv_sec = MIN_LS_INTERVAL ; } if ( evtimer_add ( & v -> ev , & tv ) == - 1 ) { fatal ( "lsa_merge" ) ; } } 