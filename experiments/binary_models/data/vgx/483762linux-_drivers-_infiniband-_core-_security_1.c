static struct ib_ports_pkeys * get_new_pps ( const struct ib_qp * qp , const struct ib_qp_attr * qp_attr , int qp_attr_mask ) { struct ib_ports_pkeys * new_pps ; struct ib_ports_pkeys * qp_pps = qp -> qp_sec -> ports_pkeys ; new_pps = kmalloc ( sizeof ( * new_pps ) , GFP_KERNEL ) ; if ( ! new_pps ) { return NULL ; } if ( qp_attr_mask & IB_QP_PORT ) { new_pps -> main . port_num = qp_attr -> port_num ; } if ( qp_pps ) { new_pps -> main . port_num = qp_pps -> main . port_num ; } if ( qp_attr_mask & IB_QP_PKEY_INDEX ) { new_pps -> main . pkey_index = qp_attr -> pkey_index ; } if ( qp_pps ) { new_pps -> main . pkey_index = qp_pps -> main . pkey_index ; } if ( ( ( qp_attr_mask & IB_QP_PKEY_INDEX ) && ( qp_attr_mask & IB_QP_PORT ) ) || ( qp_pps && qp_pps -> main . state != IB_PORT_PKEY_NOT_VALID ) ) { new_pps -> main . state = IB_PORT_PKEY_VALID ; } if ( qp_attr_mask & IB_QP_ALT_PATH ) { new_pps -> alt . port_num = qp_attr -> alt_port_num ; new_pps -> alt . pkey_index = qp_attr -> alt_pkey_index ; new_pps -> alt . state = IB_PORT_PKEY_VALID ; } if ( qp_pps ) { new_pps -> alt . port_num = qp_pps -> alt . port_num ; new_pps -> alt . pkey_index = qp_pps -> alt . pkey_index ; if ( qp_pps -> alt . state != IB_PORT_PKEY_NOT_VALID ) { new_pps -> alt . state = IB_PORT_PKEY_VALID ; } } new_pps -> main . sec = qp -> qp_sec ; new_pps -> alt . sec = qp -> qp_sec ; return new_pps ; } 