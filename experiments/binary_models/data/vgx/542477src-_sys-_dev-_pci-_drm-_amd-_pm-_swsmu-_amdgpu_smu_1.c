static int smu_read_sensor ( void * handle , int sensor , void * data , int * size_arg ) { struct smu_context * smu = handle ; struct smu_umd_pstate_table * pstate_table = & smu -> pstate_table ; int ret = 0 ; uint32_t * size , size_val ; if ( ! smu -> pm_enabled || ! smu -> adev -> pm . dpm_enabled ) { return - EOPNOTSUPP ; } size_val = * size_arg ; size = & size_val ; if ( smu -> ppt_funcs -> read_sensor ) { if ( ! smu -> ppt_funcs -> read_sensor ( smu , sensor , data , size ) ) { unlock } } switch ( sensor ) { case AMDGPU_PP_SENSOR_STABLE_PSTATE_SCLK : * ( ( uint32_t * ) data ) = pstate_table -> gfxclk_pstate . standard * 100 ; * size = 4 ; break ; case AMDGPU_PP_SENSOR_STABLE_PSTATE_MCLK : * ( ( uint32_t * ) data ) = pstate_table -> uclk_pstate . standard * 100 ; * size = 4 ; break ; case AMDGPU_PP_SENSOR_ENABLED_SMC_FEATURES_MASK : ret = smu_feature_get_enabled_mask ( smu , ( uint64_t * ) data ) ; * size = 8 ; break ; case AMDGPU_PP_SENSOR_UVD_POWER : * ( uint32_t * ) data = smu_feature_is_enabled ( smu , SMU_FEATURE_DPM_UVD_BIT ) ?1 : 0 ; * size = 4 ; break ; case AMDGPU_PP_SENSOR_VCE_POWER : * ( uint32_t * ) data = smu_feature_is_enabled ( smu , SMU_FEATURE_DPM_VCE_BIT ) ?1 : 0 ; * size = 4 ; break ; case AMDGPU_PP_SENSOR_VCN_POWER_STATE : * ( uint32_t * ) data = atomic_read ( & smu -> smu_power . power_gate . vcn_gated ) ?0 : 1 ; * size = 4 ; break ; case AMDGPU_PP_SENSOR_MIN_FAN_RPM : * ( uint32_t * ) data = 0 ; * size = 4 ; break ; default : * size = 0 ; ret = - EOPNOTSUPP ; break ; } unlock * size_arg = size_val ; return ret ; } 