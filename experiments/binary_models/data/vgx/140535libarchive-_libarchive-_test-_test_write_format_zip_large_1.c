DEFINE_TEST ( ) { int i ; char namebuff [ 64 ] ; struct fileblocks * fileblocks = fileblocks_new ( ) ; struct archive_entry * ae ; struct archive * a ; const char * p ; const char * cd_start , * zip64_eocd , * zip64_locator , * eocd ; int64_t cd_size ; char * buff ; int64_t filesize ; size_t writesize , buffsize , s ; nullsize = ( size_t ) ( 1 * MB ) ; nulldata = malloc ( nullsize ) ; memset ( nulldata , 0xAA , nullsize ) ; a = archive_write_new ( ) ; archive_write_set_format_zip ( a ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_set_options ( a , "zip:compression=store" ) ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_set_options ( a , "zip:fakecrc32" ) ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_set_bytes_per_block ( a , 0 ) ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_open ( a , fileblocks , NULL , memory_write , NULL ) ) ; for ( i = 0 ; test_sizes [ i ] != 0 ; i ++ ) { assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; snprintf ( namebuff , sizeof ( namebuff ) , "file_%d" , i ) ; archive_entry_copy_pathname ( ae , namebuff ) ; archive_entry_set_mode ( ae , S_IFREG | 0755 ) ; filesize = test_sizes [ i ] ; archive_entry_set_size ( ae , filesize ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; while ( filesize > 0 ) { writesize = nullsize ; if ( ( int64_t ) writesize > filesize ) { writesize = ( size_t ) filesize ; } assertEqualIntA ( a , ( int ) writesize , ( int ) archive_write_data ( a , nulldata , writesize ) ) ; filesize -= writesize ; } } assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , "lastfile" ) ; archive_entry_set_mode ( ae , S_IFREG | 0755 ) ; assertA ( 0 == archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_close ( a ) ) ; assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ; a = archive_read_new ( ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_read_support_format_zip_seekable ( a ) ) ; verify_large_zip ( a , fileblocks ) ; assertEqualInt ( ARCHIVE_OK , archive_read_free ( a ) ) ; a = archive_read_new ( ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_read_support_format_zip_streamable ( a ) ) ; verify_large_zip ( a , fileblocks ) ; assertEqualInt ( ARCHIVE_OK , archive_read_free ( a ) ) ; buff = malloc ( FINAL_SIZE ) ; buffsize = 0 ; memory_read_open ( NULL , fileblocks ) ; memory_read_seek ( NULL , fileblocks , - FINAL_SIZE , SEEK_END ) ; while ( ( s = memory_read ( NULL , fileblocks , ( const void * * ) & p ) ) > 0 ) { memcpy ( buff + buffsize , p , s ) ; buffsize += s ; } assertEqualInt ( buffsize , FINAL_SIZE ) ; p = buff + buffsize ; eocd = p - 22 ; assertEqualMem ( eocd , "PK\005\006\0\0\0\0" , 8 ) ; assertEqualMem ( eocd + 8 , "\021\0\021\0" , 4 ) ; cd_size = le32 ( eocd + 12 ) ; assertEqualMem ( eocd + 16 , "\xff\xff\xff\xff" , 4 ) ; assertEqualMem ( eocd + 20 , "\0\0" , 2 ) ; zip64_locator = p - 42 ; assertEqualMem ( zip64_locator , "PK\006\007\0\0\0\0" , 8 ) ; zip64_eocd = p - ( fileblocks -> filesize - le64 ( zip64_locator + 8 ) ) ; assertEqualMem ( zip64_locator + 16 , "\001\0\0\0" , 4 ) ; assert ( zip64_eocd == p - 98 ) ; assertEqualMem ( zip64_eocd , "PK\006\006" , 4 ) ; assertEqualInt ( 44 , le64 ( zip64_eocd + 4 ) ) ; assertEqualMem ( zip64_eocd + 12 , "\055\0" , 2 ) ; assertEqualMem ( zip64_eocd + 14 , "\055\0" , 2 ) ; assertEqualMem ( zip64_eocd + 16 , "\0\0\0\0" , 4 ) ; assertEqualMem ( zip64_eocd + 20 , "\0\0\0\0" , 4 ) ; assertEqualInt ( 17 , le64 ( zip64_eocd + 24 ) ) ; assertEqualInt ( 17 , le64 ( zip64_eocd + 32 ) ) ; cd_size = le64 ( zip64_eocd + 40 ) ; cd_start = p - ( fileblocks -> filesize - le64 ( zip64_eocd + 48 ) ) ; assert ( cd_start + cd_size == zip64_eocd ) ; assertEqualInt ( le64 ( zip64_eocd + 48 ) + cd_size + 56 + 20 + 22 , fileblocks -> filesize ) ; assertEqualMem ( cd_start , "PK\001\002" , 4 ) ; fileblocks_free ( fileblocks ) ; free ( nulldata ) ; } 