void lnet_return_rx_credits_locked ( struct lnet_msg * msg ) { struct lnet_peer * rxpeer = msg -> msg_rxpeer ; struct lnet_msg * msg2 ; if ( msg -> msg_rtrcredit ) { struct lnet_rtrbuf * rb ; struct lnet_rtrbufpool * rbp ; LASSERT ( msg -> msg_kiov ) ; rb = list_entry ( msg -> msg_kiov , lnet_rtrbuf , rb_kiov [ 0 ] ) ; rbp = rb -> rb_pool ; msg -> msg_rtrcredit = 0 ; LASSERT ( rbp == lnet_msg2bufpool ( msg ) ) ; LASSERT ( ( rbp -> rbp_credits > 0 ) == ! list_empty ( & rbp -> rbp_bufs ) ) ; if ( ! the_lnet . ln_routing ) { lnet_destroy_rtrbuf ( rb , rbp -> rbp_npages ) ; routing_off } if ( unlikely ( rbp -> rbp_credits >= rbp -> rbp_req_nbuffers ) ) { lnet_destroy_rtrbuf ( rb , rbp -> rbp_npages ) ; rbp -> rbp_nbuffers -- ; } else { list_add ( & rb -> rb_list , & rbp -> rbp_bufs ) ; rbp -> rbp_credits ++ ; if ( rbp -> rbp_credits <= 0 ) { lnet_schedule_blocked_locked ( rbp ) ; } } } routing_off if ( msg -> msg_peerrtrcredit ) { msg -> msg_peerrtrcredit = 0 ; LASSERT ( ( rxpeer -> lp_rtrcredits < 0 ) == ! list_empty ( & rxpeer -> lp_rtrq ) ) ; rxpeer -> lp_rtrcredits ++ ; if ( ! the_lnet . ln_routing ) { lnet_drop_routed_msgs_locked ( & rxpeer -> lp_rtrq , msg -> msg_rx_cpt ) ; } if ( rxpeer -> lp_rtrcredits <= 0 ) { msg2 = list_entry ( rxpeer -> lp_rtrq . next , lnet_msg , msg_list ) ; list_del ( & msg2 -> msg_list ) ; ( void ) lnet_post_routed_recv_locked ( msg2 , 1 ) ; } } if ( rxpeer ) { msg -> msg_rxpeer = NULL ; lnet_peer_decref_locked ( rxpeer ) ; } } 