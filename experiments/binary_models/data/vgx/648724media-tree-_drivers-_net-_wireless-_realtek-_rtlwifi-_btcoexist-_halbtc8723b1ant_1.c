static void halbtc8723b1ant_init_hw_config ( struct btc_coexist * btcoexist , bool backup ) { struct rtl_priv * rtlpriv = btcoexist -> adapter ; u32 u32tmp = 0 ; int u8tmp = 0 ; u32 cnt_bt_cal_chk = 0 ; RT_TRACE ( rtlpriv , COMP_BT_COEXIST , DBG_LOUD , "[BTCoex], 1Ant Init HW Config!!\n" ) ; if ( backup ) { coex_dm -> backup_arfr_cnt1 = btcoexist -> btc_read_4byte ( btcoexist , 0x430 ) ; coex_dm -> backup_arfr_cnt2 = btcoexist -> btc_read_4byte ( btcoexist , 0x434 ) ; coex_dm -> backup_retry_limit = btcoexist -> btc_read_2byte ( btcoexist , 0x42a ) ; coex_dm -> backup_ampdu_max_time = btcoexist -> btc_read_1byte ( btcoexist , 0x456 ) ; } btcoexist -> btc_set_rf_reg ( btcoexist , BTC_RF_A , 0x1 , 0xfffff , 0x780 ) ; btcoexist -> btc_set_rf_reg ( btcoexist , BTC_RF_A , 0x2 , 0xfffff , 0x500 ) ; btcoexist -> btc_write_1byte ( btcoexist , 0x974 , 0xff ) ; btcoexist -> btc_write_1byte_bitmask ( btcoexist , 0x944 , 0x3 , 0x3 ) ; btcoexist -> btc_write_1byte ( btcoexist , 0x930 , 0x77 ) ; while ( cnt_bt_cal_chk <= 20 ) { u32tmp = btcoexist -> btc_read_4byte ( btcoexist , 0x49d ) ; cnt_bt_cal_chk ++ ; if ( u32tmp & BIT0 ) { RT_TRACE ( rtlpriv , COMP_BT_COEXIST , DBG_LOUD , "[BTCoex], ########### BT calibration(cnt=%d) ###########\n" , cnt_bt_cal_chk ) ; mdelay ( 50 ) ; } else { RT_TRACE ( rtlpriv , COMP_BT_COEXIST , DBG_LOUD , "[BTCoex], ********** BT NOT calibration (cnt=%d)**********\n" , cnt_bt_cal_chk ) ; break ; } } u8tmp = btcoexist -> btc_read_1byte ( btcoexist , 0x790 ) ; u8tmp &= 0xc0 ; u8tmp |= 0x5 ; btcoexist -> btc_write_1byte ( btcoexist , 0x790 , u8tmp ) ; btcoexist -> btc_write_1byte ( btcoexist , 0x76e , 0xc ) ; btcoexist -> btc_write_1byte ( btcoexist , 0x778 , 0x1 ) ; btcoexist -> btc_write_1byte_bitmask ( btcoexist , 0x40 , 0x20 , 0x1 ) ; halbtc8723b1ant_set_ant_path ( btcoexist , BTC_ANT_PATH_PTA , true , false ) ; halbtc8723b1ant_coex_table_with_type ( btcoexist , FORCE_EXEC , 0 ) ; } 