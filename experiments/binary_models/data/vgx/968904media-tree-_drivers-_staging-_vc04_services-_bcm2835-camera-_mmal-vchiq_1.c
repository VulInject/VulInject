static int bulk_receive ( struct vchiq_mmal_instance * instance , struct mmal_msg * msg , struct mmal_msg_context * msg_context ) { unsigned long rd_len ; unsigned long flags = 0 ; int ret ; ret = mutex_lock_interruptible ( & instance -> bulk_mutex ) ; if ( ret != 0 ) { return ret ; } rd_len = msg -> u . buffer_from_host . buffer_header . length ; spin_lock_irqsave ( & msg_context -> u . bulk . port -> slock , flags ) ; if ( list_empty ( & msg_context -> u . bulk . port -> buffers ) ) { spin_unlock_irqrestore ( & msg_context -> u . bulk . port -> slock , flags ) ; pr_err ( "buffer list empty trying to submit bulk receive\n" ) ; return - EINVAL ; } msg_context -> u . bulk . buffer = list_entry ( msg_context -> u . bulk . port -> buffers . next , mmal_buffer , list ) ; list_del ( & msg_context -> u . bulk . buffer -> list ) ; spin_unlock_irqrestore ( & msg_context -> u . bulk . port -> slock , flags ) ; if ( rd_len > msg_context -> u . bulk . buffer -> buffer_size ) { rd_len = msg_context -> u . bulk . buffer -> buffer_size ; pr_warn ( "short read as not enough receive buffer space\n" ) ; } msg_context -> u . bulk . buffer_used = rd_len ; msg_context -> u . bulk . mmal_flags = msg -> u . buffer_from_host . buffer_header . flags ; msg_context -> u . bulk . dts = msg -> u . buffer_from_host . buffer_header . dts ; msg_context -> u . bulk . pts = msg -> u . buffer_from_host . buffer_header . pts ; vchi_service_use ( instance -> handle ) ; ret = vchi_bulk_queue_receive ( instance -> handle , msg_context -> u . bulk . buffer -> buffer , ( rd_len + 3 ) & ~ 3 , VCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE | VCHI_FLAGS_BLOCK_UNTIL_QUEUED , msg_context ) ; vchi_service_release ( instance -> handle ) ; if ( ret != 0 ) { mutex_unlock ( & instance -> bulk_mutex ) ; } return ret ; } 