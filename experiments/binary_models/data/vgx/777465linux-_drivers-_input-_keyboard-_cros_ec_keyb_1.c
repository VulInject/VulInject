static int cros_ec_keyb_probe ( struct platform_device * pdev ) { struct cros_ec_device * ec ; struct device * dev = & pdev -> dev ; struct cros_ec_keyb * ckdev ; bool buttons_switches_only = device_get_match_data ( dev ) ; int err ; ec = dev_get_drvdata ( pdev -> dev . parent ) ; if ( ! ec ) { return - EPROBE_DEFER ; } ckdev = devm_kzalloc ( dev , sizeof ( * ckdev ) , GFP_KERNEL ) ; ckdev -> ec = ec ; ckdev -> dev = dev ; dev_set_drvdata ( dev , ckdev ) ; if ( ! buttons_switches_only ) { err = cros_ec_keyb_register_matrix ( ckdev ) ; if ( err ) { dev_err ( dev , "cannot register matrix inputs: %d\n" , err ) ; return err ; } } err = cros_ec_keyb_register_bs ( ckdev , buttons_switches_only ) ; if ( err ) { dev_err ( dev , "cannot register non-matrix inputs: %d\n" , err ) ; return err ; } err = devm_device_add_group ( dev , & cros_ec_keyb_attr_group ) ; if ( err ) { dev_err ( dev , "failed to create attributes: %d\n" , err ) ; return err ; } ckdev -> notifier . notifier_call = cros_ec_keyb_work ; err = blocking_notifier_chain_register ( & ckdev -> ec -> event_notifier , & ckdev -> notifier ) ; if ( err ) { dev_err ( dev , "cannot register notifier: %d\n" , err ) ; return err ; } device_init_wakeup ( ckdev -> dev , true ) ; return 0 ; } 