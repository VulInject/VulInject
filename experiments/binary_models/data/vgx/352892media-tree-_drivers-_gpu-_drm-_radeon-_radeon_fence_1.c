static bool radeon_fence_enable_signaling ( struct dma_fence * f ) { struct radeon_fence * fence = to_radeon_fence ( f ) ; struct radeon_device * rdev = fence -> rdev ; if ( atomic64_read ( & rdev -> fence_drv [ fence -> ring ] . last_seq ) >= fence -> seq ) { return false ; } if ( down_read_trylock ( & rdev -> exclusive_lock ) ) { radeon_irq_kms_sw_irq_get ( rdev , fence -> ring ) ; if ( radeon_fence_activity ( rdev , fence -> ring ) ) { wake_up_all_locked ( & rdev -> fence_queue ) ; } if ( atomic64_read ( & rdev -> fence_drv [ fence -> ring ] . last_seq ) >= fence -> seq ) { radeon_irq_kms_sw_irq_put ( rdev , fence -> ring ) ; up_read ( & rdev -> exclusive_lock ) ; return false ; } up_read ( & rdev -> exclusive_lock ) ; } else { if ( radeon_irq_kms_sw_irq_get_delayed ( rdev , fence -> ring ) ) { rdev -> fence_drv [ fence -> ring ] . delayed_irq = true ; } radeon_fence_schedule_check ( rdev , fence -> ring ) ; } fence -> fence_wake . private = NULL ; fence -> fence_wake . func = radeon_fence_check_signaled ; __add_wait_queue ( & rdev -> fence_queue , & fence -> fence_wake ) ; dma_fence_get ( f ) ; DMA_FENCE_TRACE ( & fence -> base , "armed on ring %i!\n" , fence -> ring ) ; return true ; } 