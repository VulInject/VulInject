SVCXPRT * svc_raw_create ( void ) { struct svc_raw_private * srp ; ( void ) mutex_lock ( & svcraw_lock ) ; srp = svc_raw_private ; if ( srp != NULL ) { ( void ) mutex_unlock ( & svcraw_lock ) ; return ( srp -> server ) ; } srp = calloc ( 1 , sizeof ( * srp ) ) ; if ( srp == NULL ) { syslog ( LOG_ERR , "svc_raw_create: out of memory" ) ; ( void ) mutex_unlock ( & svcraw_lock ) ; return ( NULL ) ; } srp -> raw_netbuf = & _rawcomnetbuf ; srp -> raw_netbuf -> buf = malloc ( UDPMSGSIZE ) ; if ( srp -> raw_netbuf -> buf == NULL ) { syslog ( LOG_ERR , "svc_raw_create: out of memory" ) ; ( void ) mutex_unlock ( & svcraw_lock ) ; return ( NULL ) ; } srp -> raw_netbuf -> maxlen = UDPMSGSIZE ; srp -> raw_netbuf -> len = 0 ; if ( ( srp -> server = svc_xprt_alloc ( ) ) == NULL ) { free ( srp -> raw_netbuf -> buf ) ; srp -> raw_netbuf -> buf = NULL ; srp -> raw_netbuf -> maxlen = 0 ; free ( srp ) ; ( void ) mutex_unlock ( & svcraw_lock ) ; return ( NULL ) ; } srp -> server -> xp_fd = FD_SETSIZE ; srp -> server -> xp_port = 0 ; srp -> server -> xp_ops = svc_raw_ops ( ) ; srp -> server -> xp_verf . oa_base = srp -> verf_body ; xprt_register ( srp -> server ) ; svc_raw_private = srp ; ( void ) mutex_unlock ( & svcraw_lock ) ; return ( srp -> server ) ; } 