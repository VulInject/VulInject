void pass4 ( void ) { fsck_ino_t inumber ; struct dinode * dp ; struct inodesc idesc ; int n , was_dir ; int need_rescan ; int scan_pass = 0 ; { if ( debug ) { ( void ) printf ( "pass4 scan %d\n" , scan_pass ++ ) ; } for ( inumber = UFSROOTINO ; inumber <= lastino ; inumber ++ ) { init_inodesc ( & idesc ) ; idesc . id_type = ADDR ; idesc . id_func = pass4check ; idesc . id_number = inumber ; was_dir = ( statemap [ inumber ] & DSTATE ) == DSTATE ; switch ( statemap [ inumber ] & ~ ( INORPHAN | INDELAYD | INZLINK ) ) { case FZLINK : case DZLINK : if ( lncntp [ inumber ] == 0 ) { clri ( & idesc , "UNREF" , CLRI_VERBOSE , CLRI_NOP_OK ) ; if ( was_dir && ( statemap [ inumber ] == USTATE ) ) { need_rescan = 1 ; } break ; } case FSTATE : case DFOUND : case SSTATE : n = lncntp [ inumber ] ; if ( n || ( statemap [ inumber ] & ( INDELAYD | INZLINK ) ) ) { adjust ( & idesc , n ) ; if ( was_dir && ( statemap [ inumber ] == USTATE ) ) { need_rescan = 1 ; } else { TRACK_LNCNTP ( inumber , lncntp [ inumber ] = 0 ) ; } } break ; case DSTATE : clri ( & idesc , "UNREF" , CLRI_VERBOSE , CLRI_NOP_OK ) ; if ( was_dir && ( statemap [ inumber ] == USTATE ) ) { need_rescan = 1 ; } break ; case DCLEAR : dp = ginode ( inumber ) ; if ( dp -> di_size == 0 ) { clri ( & idesc , "ZERO LENGTH" , CLRI_VERBOSE , CLRI_NOP_CORRUPT ) ; break ; } case FCLEAR : clri ( & idesc , "BAD/DUP" , CLRI_VERBOSE , CLRI_NOP_CORRUPT ) ; break ; case SCLEAR : clri ( & idesc , "BAD" , CLRI_VERBOSE , CLRI_NOP_CORRUPT ) ; break ; case USTATE : break ; default : errexit ( "BAD STATE 0x%x FOR INODE I=%d" , ( int ) statemap [ inumber ] , inumber ) ; } } } need_rescan ; } 