int _dl_md_reloc ( elf_object_t * object , int rel , int relsz ) { long i ; long numrel ; long relrel ; int fails = 0 ; Elf_Addr loff ; Elf_Addr prev_value = 0 ; const Elf_Sym * prev_sym = NULL ; Elf_Rel * rels ; loff = object -> obj_base ; numrel = object -> Dyn . info [ relsz ] / sizeof ( Elf_Rel ) ; relrel = rel == DT_REL ?object -> relcount : 0 ; rels = ( Elf_Rel * ) ( object -> Dyn . info [ rel ] ) ; if ( relrel > numrel ) { _dl_die ( "relcount>numrel: %ld>%ld" , relrel , numrel ) ; } for ( i = 0 ; i < relrel ; i ++ , rels ++ ) { Elf_Addr * where ; where = ( Elf_Addr * ) ( rels -> r_offset + loff ) ; * where += loff ; } for ( ; i < numrel ; i ++ , rels ++ ) { Elf_Addr * where , value , mask ; Elf_Word type ; const Elf_Sym * sym ; const char * symn ; type = ELF_R_TYPE ( rels -> r_info ) ; if ( reloc_target_flags [ type ] & _RF_E ) { _dl_die ( "bad relocation %ld %d" , i , type ) ; } if ( type == R_TYPE ( NONE ) ) { continue ; } if ( type == R_TYPE ( JUMP_SLOT ) && rel != DT_JMPREL ) { continue ; } where = ( Elf_Addr * ) ( rels -> r_offset + loff ) ; if ( RELOC_USE_ADDEND ( type ) ) { value = rels -> r_addend ; } value = * where & RELOC_VALUE_BITMASK ( type ) ; else { value = 0 ; } sym = NULL ; symn = NULL ; if ( RELOC_RESOLVE_SYMBOL ( type ) ) { sym = object -> dyn . symtab ; sym += ELF_R_SYM ( rels -> r_info ) ; symn = object -> dyn . strtab + sym -> st_name ; if ( sym -> st_shndx != SHN_UNDEF && ELF_ST_BIND ( sym -> st_info ) == STB_LOCAL ) { value += loff ; } if ( sym == prev_sym ) { value += prev_value ; } else { struct sym_res sr ; sr = _dl_find_symbol ( symn , SYM_SEARCH_ALL | SYM_WARNNOTFOUND | ( ( type == R_TYPE ( JUMP_SLOT ) ) ?SYM_PLT : SYM_NOTPLT ) , sym , object ) ; if ( sr . sym == NULL ) { resolve_failed if ( ELF_ST_BIND ( sym -> st_info ) != STB_WEAK ) { fails ++ ; } continue ; } prev_sym = sym ; prev_value = ( Elf_Addr ) ( sr . obj -> obj_base + sr . sym -> st_value ) ; value += prev_value ; } } if ( type == R_TYPE ( JUMP_SLOT ) ) { * where = value ; continue ; } if ( type == R_TYPE ( COPY ) ) { void * dstaddr = where ; const void * srcaddr ; const Elf_Sym * dstsym = sym ; struct sym_res sr ; sr = _dl_find_symbol ( symn , SYM_SEARCH_OTHER | SYM_WARNNOTFOUND | SYM_NOTPLT , dstsym , object ) ; if ( sr . sym == NULL ) { resolve_failed } srcaddr = ( void * ) ( sr . obj -> obj_base + sr . sym -> st_value ) ; _dl_bcopy ( srcaddr , dstaddr , dstsym -> st_size ) ; continue ; } if ( RELOC_PC_RELATIVE ( type ) ) { value -= ( Elf_Addr ) where ; } if ( RELOC_BASE_RELATIVE ( type ) ) { value += loff ; } mask = RELOC_VALUE_BITMASK ( type ) ; value >>= RELOC_VALUE_RIGHTSHIFT ( type ) ; value &= mask ; * where &= ~ mask ; * where |= value ; } return fails ; } 