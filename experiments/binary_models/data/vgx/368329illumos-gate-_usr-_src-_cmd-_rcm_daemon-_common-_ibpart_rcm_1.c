static int ibpart_update ( dladm_handle_t handle , datalink_id_t ibpartid , void * arg ) { ibpart_update_arg_t * ibpart_update_argp = arg ; rcm_handle_t * hd = ibpart_update_argp -> hd ; link_cache_t * node ; dl_ibpart_t * ibpart ; char * rsrc ; dladm_ib_attr_t ibpart_attr ; dladm_status_t status ; char errmsg [ DLADM_STRSIZE ] ; boolean_t newnode = B_FALSE ; int ret = - 1 ; rcm_log_message ( RCM_TRACE2 , "IBPART: ibpart_update(%u)\n" , ibpartid ) ; assert ( MUTEX_HELD ( & cache_lock ) ) ; status = dladm_part_info ( handle , ibpartid , & ibpart_attr , DLADM_OPT_ACTIVE ) ; if ( status != DLADM_STATUS_OK ) { rcm_log_message ( RCM_TRACE1 , "IBPART: ibpart_update() cannot get ibpart information for " "%u(%s)\n" , ibpartid , dladm_status2str ( status , errmsg ) ) ; return ( DLADM_WALK_CONTINUE ) ; } if ( ibpart_attr . dia_physlinkid == DATALINK_INVALID_LINKID ) { rcm_log_message ( RCM_TRACE1 , "IBPART: ibpart_update(): skip the PORT nodes %u\n" , ibpartid ) ; return ( DLADM_WALK_CONTINUE ) ; } rsrc = malloc ( RCM_LINK_RESOURCE_MAX ) ; if ( rsrc == NULL ) { rcm_log_message ( RCM_ERROR , _ ( "IBPART: malloc error(%s): %u\n" ) , strerror ( errno ) , ibpartid ) ; done } ( void ) snprintf ( rsrc , RCM_LINK_RESOURCE_MAX , "%s/%u" , RCM_LINK_PREFIX , ibpart_attr . dia_physlinkid ) ; node = cache_lookup ( hd , rsrc , CACHE_NO_REFRESH ) ; if ( node != NULL ) { rcm_log_message ( RCM_DEBUG , "IBPART: %s already registered (ibpartid:%d)\n" , rsrc , ibpart_attr . dia_partlinkid ) ; } else { rcm_log_message ( RCM_DEBUG , "IBPART: %s is a new resource (ibpartid:%d)\n" , rsrc , ibpart_attr . dia_partlinkid ) ; if ( ( node = calloc ( 1 , sizeof ( link_cache_t ) ) ) == NULL ) { free ( rsrc ) ; rcm_log_message ( RCM_ERROR , _ ( "IBPART: calloc: %s\n" ) , strerror ( errno ) ) ; done } node -> pc_resource = rsrc ; node -> pc_ibpart = NULL ; node -> pc_linkid = ibpart_attr . dia_physlinkid ; node -> pc_state |= CACHE_NODE_NEW ; newnode = B_TRUE ; } for ( ibpart = node -> pc_ibpart ; ibpart != NULL ; ibpart = ibpart -> dlib_next ) { if ( ibpart -> dlib_ibpart_id == ibpartid ) { ibpart -> dlib_flags &= ~ IBPART_STALE ; break ; } } if ( ibpart == NULL ) { if ( ( ibpart = calloc ( 1 , sizeof ( dl_ibpart_t ) ) ) == NULL ) { rcm_log_message ( RCM_ERROR , _ ( "IBPART: malloc: %s\n" ) , strerror ( errno ) ) ; if ( newnode ) { free ( rsrc ) ; free ( node ) ; } done } ibpart -> dlib_ibpart_id = ibpartid ; ibpart -> dlib_next = node -> pc_ibpart ; ibpart -> dlib_prev = NULL ; if ( node -> pc_ibpart != NULL ) { node -> pc_ibpart -> dlib_prev = ibpart ; } node -> pc_ibpart = ibpart ; } node -> pc_state &= ~ CACHE_NODE_STALE ; if ( newnode ) { cache_insert ( node ) ; } rcm_log_message ( RCM_TRACE3 , "IBPART: ibpart_update: succeeded(%u)\n" , ibpartid ) ; ret = 0 ; done ibpart_update_argp -> retval = ret ; return ( ret == 0 ?DLADM_WALK_CONTINUE : DLADM_WALK_TERMINATE ) ; } 