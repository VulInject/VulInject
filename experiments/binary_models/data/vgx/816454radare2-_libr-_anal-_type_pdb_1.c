static void parse_structure ( const RAnal * anal , SType * type , RList * types ) { r_return_if_fail ( anal && type && types ) ; STypeInfo * type_info = & type -> type_data ; r_return_if_fail ( type_info -> get_members && type_info -> is_fwdref && type_info -> get_name && type_info -> get_val ) ; RAnalBaseType * base_type = r_anal_base_type_new ( R_ANAL_BASE_TYPE_KIND_STRUCT ) ; char * name = NULL ; type_info -> get_name ( type_info , & name ) ; bool to_free_name = false ; if ( ! name ) { name = create_type_name_from_offset ( type -> tpi_idx ) ; to_free_name = true ; } int size ; type_info -> get_val ( type_info , & size ) ; RList * members ; type_info -> get_members ( type_info , & members ) ; RListIter * it = r_list_iterator ( members ) ; while ( r_list_iter_next ( it ) ) { STypeInfo * member_info = r_list_iter_get ( it ) ; RAnalStructMember * struct_member = parse_member ( member_info , types ) ; if ( ! struct_member ) { continue ; } void * element = r_vector_push ( & base_type -> struct_data . members , struct_member ) ; if ( ! element ) { cleanup } } if ( type_info -> leaf_type == eLF_STRUCTURE || type_info -> leaf_type == eLF_CLASS ) { base_type -> kind = R_ANAL_BASE_TYPE_KIND_STRUCT ; } else { base_type -> kind = R_ANAL_BASE_TYPE_KIND_UNION ; } char * sname = r_str_sanitize_sdb_key ( name ) ; base_type -> name = sname ; base_type -> size = size ; r_anal_save_base_type ( anal , base_type ) ; cleanup if ( to_free_name ) { R_FREE ( name ) ; } r_anal_base_type_free ( base_type ) ; return ; } 