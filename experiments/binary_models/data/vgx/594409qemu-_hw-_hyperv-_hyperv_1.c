uint16_t hyperv_hcall_post_message ( uint64_t param , bool fast ) { uint16_t ret ; hwaddr len ; struct hyperv_post_message_input * msg ; MsgHandler * mh ; if ( param & ( __alignof__ ( * msg ) - 1 ) ) { return HV_STATUS_INVALID_ALIGNMENT ; } len = sizeof ( * msg ) ; msg = cpu_physical_memory_map ( param , & len , 0 ) ; if ( len < sizeof ( * msg ) ) { ret = HV_STATUS_INSUFFICIENT_MEMORY ; unmap } if ( msg -> payload_size > sizeof ( msg -> payload ) ) { ret = HV_STATUS_INVALID_HYPERCALL_INPUT ; unmap } ret = HV_STATUS_INVALID_CONNECTION_ID ; WITH_RCU_READ_LOCK_GUARD ( ) { QLIST_FOREACH_RCU ( , , ) { if ( mh -> conn_id == ( msg -> connection_id & HV_CONNECTION_ID_MASK ) ) { ret = mh -> handler ( msg , mh -> data ) ; break ; } } } unmap cpu_physical_memory_unmap ( msg , len , 0 , 0 ) ; return ret ; } 