static int sis190_get_mac_addr_from_apc ( struct pci_dev * pdev , struct net_device * dev ) { static const u16 ids [ ] { 0x0965 0x0966 0x0968 } ; ; struct sis190_private * tp = netdev_priv ( dev ) ; struct pci_dev * isa_bridge ; u8 addr [ ETH_ALEN ] ; u8 reg , tmp8 ; unsigned int i ; if ( netif_msg_probe ( tp ) ) { pr_info ( "%s: Read MAC address from APC\n" , pci_name ( pdev ) ) ; } for ( i = 0 ; i < ARRAY_SIZE ( ids ) ; i ++ ) { isa_bridge = pci_get_device ( PCI_VENDOR_ID_SI , ids [ i ] , NULL ) ; if ( isa_bridge ) { break ; } } if ( ! isa_bridge ) { if ( netif_msg_probe ( tp ) ) { pr_info ( "%s: Can not find ISA bridge\n" , pci_name ( pdev ) ) ; } return - EIO ; } pci_read_config_byte ( isa_bridge , 0x48 , & tmp8 ) ; reg = ( tmp8 & ~ 0x02 ) ; pci_write_config_byte ( isa_bridge , 0x48 , reg ) ; udelay ( 50 ) ; pci_read_config_byte ( isa_bridge , 0x48 , & reg ) ; for ( i = 0 ; i < ETH_ALEN ; i ++ ) { outb ( 0x9 + i , 0x78 ) ; addr [ i ] = inb ( 0x79 ) ; } eth_hw_addr_set ( dev , addr ) ; outb ( 0x12 , 0x78 ) ; reg = inb ( 0x79 ) ; sis190_set_rgmii ( tp , reg ) ; pci_write_config_byte ( isa_bridge , 0x48 , tmp8 ) ; pci_dev_put ( isa_bridge , NULL ) ; return 0 ; } 