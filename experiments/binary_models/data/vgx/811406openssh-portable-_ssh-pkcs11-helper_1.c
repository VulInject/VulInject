static void process_sign ( void ) { u_char * blob , * data , * signature = NULL ; size_t blen , dlen , slen = 0 ; int r , ok = - 1 ; struct sshkey * key , * found ; struct sshbuf * msg ; if ( ( r = sshbuf_get_string ( iqueue , & blob , & blen ) ) != 0 || ( r = sshbuf_get_string ( iqueue , & data , & dlen ) ) != 0 || ( r = sshbuf_get_u32 ( iqueue , NULL ) ) != 0 ) { fatal_fr ( r , "parse" ) ; } if ( ( r = sshkey_from_blob ( blob , blen , & key ) ) != 0 ) { fatal_fr ( r , "decode key" ) ; } else { if ( ( found = lookup_key ( key ) ) != NULL ) { int ret ; if ( key -> type == KEY_RSA ) { slen = RSA_size ( key -> rsa ) ; signature = xmalloc ( slen ) ; ret = RSA_private_encrypt ( dlen , data , signature , found -> rsa , RSA_PKCS1_PADDING ) ; if ( ret != - 1 ) { slen = ret ; ok = 0 ; } } if ( key -> type == KEY_ECDSA ) { u_int xslen = ECDSA_size ( key -> ecdsa ) ; signature = xmalloc ( xslen ) ; ret = ECDSA_sign ( - 1 , data , dlen , signature , & xslen , found -> ecdsa ) ; if ( ret != 0 ) { ok = 0 ; } else { error_f ( "ECDSA_sign returned %d" , ret ) ; } slen = xslen ; } else { error_f ( "don't know how to sign with key " "type %d" , ( int ) key -> type ) ; } } sshkey_free ( key ) ; } if ( ( msg = sshbuf_new ( ) ) == NULL ) { fatal_f ( "sshbuf_new failed" ) ; } if ( ok == 0 ) { if ( ( r = sshbuf_put_u8 ( msg , SSH2_AGENT_SIGN_RESPONSE ) ) != 0 || ( r = sshbuf_put_string ( msg , signature , slen ) ) != 0 ) { fatal_fr ( r , "compose response" ) ; } } else { if ( ( r = sshbuf_put_u8 ( msg , SSH2_AGENT_FAILURE ) ) != 0 ) { fatal_fr ( r , "compose failure response" ) ; } } free ( data ) ; free ( signature ) ; send_msg ( msg ) ; sshbuf_free ( msg ) ; } 