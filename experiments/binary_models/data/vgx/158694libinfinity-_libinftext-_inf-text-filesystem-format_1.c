gboolean inf_text_filesystem_format_write ( InfdFilesystemStorage * storage , const gchar * path , InfUserTable * user_table , InfTextBuffer * buffer , GError * * error ) { InfTextBufferIter * iter ; xmlNodePtr buffer_node ; xmlNodePtr segment_node ; guint author ; gchar * content ; gsize bytes ; gchar * converted ; gsize converted_bytes ; FILE * stream ; xmlDocPtr doc ; xmlErrorPtr xmlerror ; gboolean is_utf8 ; InfTextFilesystemFormatWriteData data ; g_return_val_if_fail ( INFD_IS_FILESYSTEM_STORAGE ( storage ) , FALSE ) ; g_return_val_if_fail ( path != NULL , FALSE ) ; g_return_val_if_fail ( INF_IS_USER_TABLE ( user_table ) , FALSE ) ; g_return_val_if_fail ( INF_TEXT_IS_BUFFER ( buffer ) , FALSE ) ; g_return_val_if_fail ( error == NULL || * error == NULL , FALSE ) ; is_utf8 = TRUE ; if ( strcmp ( inf_text_buffer_get_encoding ( buffer ) , "UTF-8" ) != 0 ) { is_utf8 = FALSE ; } stream = infd_filesystem_storage_open ( INFD_FILESYSTEM_STORAGE ( storage ) , "InfText" , path , "w" , NULL , error ) ; if ( stream == NULL ) { return FALSE ; } data . root = xmlNewNode ( NULL , ( const xmlChar * ) "inf-text-session" ) ; data . encountered_authors = g_hash_table_new ( NULL , NULL ) ; buffer_node = xmlNewNode ( NULL , ( const xmlChar * ) "buffer" ) ; iter = inf_text_buffer_create_begin_iter ( buffer ) ; if ( iter != NULL ) { { author = inf_text_buffer_iter_get_author ( buffer , iter ) ; content = inf_text_buffer_iter_get_text ( buffer , iter ) ; bytes = inf_text_buffer_iter_get_bytes ( buffer , iter ) ; g_hash_table_insert ( data . encountered_authors , GUINT_TO_POINTER ( author ) , GUINT_TO_POINTER ( author ) ) ; segment_node = xmlNewChild ( buffer_node , NULL , ( const xmlChar * ) "segment" , NULL ) ; inf_xml_util_set_attribute_uint ( segment_node , "author" , author ) ; if ( is_utf8 ) { inf_xml_util_add_child_text ( segment_node , content , bytes ) ; g_free ( content ) ; } else { converted = g_convert ( content , bytes , "UTF-8" , inf_text_buffer_get_encoding ( buffer ) , NULL , & converted_bytes , error ) ; g_free ( content ) ; if ( converted == NULL ) { xmlFreeNode ( buffer_node ) ; xmlFreeNode ( data . root ) ; g_hash_table_destroy ( data . encountered_authors ) ; infd_filesystem_storage_stream_close ( stream ) ; return FALSE ; } inf_xml_util_add_child_text ( segment_node , converted , converted_bytes ) ; } } inf_text_buffer_iter_next ( buffer , iter ) ; inf_text_buffer_destroy_iter ( buffer , iter ) ; } inf_user_table_foreach_user ( user_table , inf_text_filesystem_format_write_foreach_user_func , & data ) ; g_hash_table_destroy ( data . encountered_authors ) ; xmlAddChild ( data . root , buffer_node ) ; doc = xmlNewDoc ( ( const xmlChar * ) "1.0" ) ; xmlDocSetRootElement ( doc , data . root ) ; if ( xmlDocFormatDump ( stream , doc , 1 ) == - 1 ) { xmlerror = xmlGetLastError ( ) ; infd_filesystem_storage_stream_close ( stream ) ; xmlFreeDoc ( doc ) ; g_set_error_literal ( error , g_quark_from_static_string ( "LIBXML2_OUTPUT_ERROR" ) , xmlerror -> code , xmlerror -> message ) ; return FALSE ; } infd_filesystem_storage_stream_close ( stream ) ; xmlFreeDoc ( doc ) ; return TRUE ; } 