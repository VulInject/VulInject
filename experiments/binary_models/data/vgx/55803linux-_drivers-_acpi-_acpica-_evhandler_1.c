acpi_status acpi_ev_install_space_handler ( struct acpi_namespace_node * node , acpi_adr_space_type space_id , acpi_adr_space_handler handler , acpi_adr_space_setup setup , void * context ) { union acpi_operand_object * obj_desc ; union acpi_operand_object * handler_obj ; acpi_status status = AE_OK ; acpi_object_type type ; u8 flags = 0 ; ACPI_FUNCTION_TRACE ( ev_install_space_handler ) ; if ( ( node -> type != ACPI_TYPE_DEVICE ) && ( node -> type != ACPI_TYPE_PROCESSOR ) && ( node -> type != ACPI_TYPE_THERMAL ) && ( node != acpi_gbl_root_node ) ) { status = AE_BAD_PARAMETER ; unlock_and_exit } if ( handler == ACPI_DEFAULT_HANDLER ) { flags = ACPI_ADDR_HANDLER_DEFAULT_INSTALLED ; switch ( space_id ) { case ACPI_ADR_SPACE_SYSTEM_MEMORY : handler = acpi_ex_system_memory_space_handler ; setup = acpi_ev_system_memory_region_setup ; break ; case ACPI_ADR_SPACE_SYSTEM_IO : handler = acpi_ex_system_io_space_handler ; setup = acpi_ev_io_space_region_setup ; break ; case ACPI_ADR_SPACE_PCI_CONFIG : handler = acpi_ex_pci_config_space_handler ; setup = acpi_ev_pci_config_region_setup ; break ; case ACPI_ADR_SPACE_CMOS : handler = acpi_ex_cmos_space_handler ; setup = acpi_ev_cmos_region_setup ; break ; case ACPI_ADR_SPACE_PCI_BAR_TARGET : handler = acpi_ex_pci_bar_space_handler ; setup = acpi_ev_pci_bar_region_setup ; break ; case ACPI_ADR_SPACE_DATA_TABLE : handler = acpi_ex_data_table_space_handler ; setup = acpi_ev_data_table_region_setup ; break ; default : status = AE_BAD_PARAMETER ; unlock_and_exit } } if ( ! setup ) { setup = acpi_ev_default_region_setup ; } obj_desc = acpi_ns_get_attached_object ( node ) ; if ( obj_desc ) { handler_obj = acpi_ev_find_region_handler ( space_id , obj_desc -> common_notify . handler ) ; if ( handler_obj ) { if ( handler_obj -> address_space . handler == handler ) { status = AE_SAME_HANDLER ; unlock_and_exit } else { status = AE_ALREADY_EXISTS ; } unlock_and_exit } } else { ACPI_DEBUG_PRINT ( ( ACPI_DB_OPREGION , "Creating object on Device %p while installing handler\n" , node ) ) ; if ( node -> type == ACPI_TYPE_ANY ) { type = ACPI_TYPE_DEVICE ; } else { type = node -> type ; } obj_desc = acpi_ut_create_internal_object ( type ) ; if ( ! obj_desc ) { status = AE_NO_MEMORY ; unlock_and_exit } obj_desc -> common . type = ( u8 ) type ; status = acpi_ns_attach_object ( node , obj_desc , type ) ; acpi_ut_remove_reference ( obj_desc ) ; if ( ACPI_FAILURE ( status ) ) { unlock_and_exit } } ACPI_DEBUG_PRINT ( ( ACPI_DB_OPREGION , "Installing address handler for region %s(%X) " "on Device %4.4s %p(%p)\n" , acpi_ut_get_region_name ( space_id ) , space_id , acpi_ut_get_node_name ( node ) , node , obj_desc ) ) ; handler_obj = acpi_ut_create_internal_object ( ACPI_TYPE_LOCAL_ADDRESS_HANDLER ) ; if ( ! handler_obj ) { status = AE_NO_MEMORY ; unlock_and_exit } status = acpi_os_create_mutex ( & handler_obj -> address_space . context_mutex ) ; if ( ACPI_FAILURE ( status ) ) { acpi_ut_remove_reference ( handler_obj , NULL ) ; unlock_and_exit } handler_obj -> address_space . space_id = ( u8 ) space_id ; handler_obj -> address_space . handler_flags = flags ; handler_obj -> address_space . region_list = NULL ; handler_obj -> address_space . node = node ; handler_obj -> address_space . handler = handler ; handler_obj -> address_space . context = context ; handler_obj -> address_space . setup = setup ; handler_obj -> address_space . next = obj_desc -> common_notify . handler ; obj_desc -> common_notify . handler = handler_obj ; status = acpi_ns_walk_namespace ( ACPI_TYPE_ANY , node , ACPI_UINT32_MAX , ACPI_NS_WALK_UNLOCK , acpi_ev_install_handler , NULL , handler_obj , NULL ) ; unlock_and_exit return_ACPI_STATUS ( status ) ; } 