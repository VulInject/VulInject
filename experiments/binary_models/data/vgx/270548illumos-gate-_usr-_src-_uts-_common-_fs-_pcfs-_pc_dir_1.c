static int pc_makedirentry ( struct pcnode * dp , struct pcdir * direntries , int ndirentries , struct vattr * vap , offset_t offset ) { struct vnode * vp = PCTOV ( dp ) ; struct pcfs * fsp = VFSTOPCFS ( vp -> v_vfsp ) ; int error ; struct pcdir * ep ; int boff ; int i ; struct buf * bp = NULL ; timestruc_t now ; if ( vap != NULL && vap -> va_mask & ( AT_ATIME | AT_MTIME ) ) { return ( EOPNOTSUPP ) ; } ep = & direntries [ ndirentries - 1 ] ; gethrestime ( & now ) ; if ( error = pc_tvtopct ( & now , & ep -> pcd_mtime ) ) { return ( error ) ; } ep -> pcd_crtime = ep -> pcd_mtime ; ep -> pcd_ladate = ep -> pcd_mtime . pct_date ; ep -> pcd_crtime_msec = 0 ; ep -> pcd_size = 0 ; ep -> pcd_attr = 0 ; ep -> pcd_ntattr = 0 ; if ( ! IS_FAT32 ( fsp ) ) { ep -> un . pcd_eattr = 0 ; } if ( vap && ( ( vap -> va_mode & 0222 ) == 0 ) ) { ep -> pcd_attr |= PCA_RDONLY ; } if ( vap && ( vap -> va_type == VDIR ) ) { pc_cluster32_t cn ; ep -> pcd_attr |= PCA_DIR ; cn = pc_alloccluster ( fsp , 0 ) ; switch ( cn ) { case PCF_FREECLUSTER : return ( ENOSPC ) ; case PCF_ERRORCLUSTER : return ( EIO ) ; } bp = ngeteblk ( fsp -> pcfs_clsize ) ; bp -> b_edev = fsp -> pcfs_xdev ; bp -> b_dev = cmpdev ( bp -> b_edev ) ; bp -> b_blkno = pc_cldaddr ( fsp , cn ) ; clrbuf ( bp ) ; pc_setstartcluster ( fsp , ep , cn ) ; pc_setstartcluster ( fsp , & dirtemplate . t_dot , cn ) ; cn = pc_getstartcluster ( fsp , & dp -> pc_entry ) ; pc_setstartcluster ( fsp , & dirtemplate . t_dotdot , cn ) ; dirtemplate . t_dot . pcd_mtime = dirtemplate . t_dotdot . pcd_mtime = ep -> pcd_mtime ; dirtemplate . t_dot . pcd_crtime = dirtemplate . t_dotdot . pcd_crtime = ep -> pcd_crtime ; dirtemplate . t_dot . pcd_ladate = dirtemplate . t_dotdot . pcd_ladate = ep -> pcd_ladate ; dirtemplate . t_dot . pcd_crtime_msec = dirtemplate . t_dotdot . pcd_crtime_msec = 0 ; bcopy ( & dirtemplate , bp -> b_un . b_addr , sizeof ( dirtemplate ) ) ; bwrite2 ( bp , NULL ) ; error = geterror ( bp ) ; brelse ( bp ) ; if ( error ) { PC_DPRINTF0 ( 1 , "pc_makedirentry error" ) ; pc_mark_irrecov ( fsp ) ; return ( EIO ) ; } } else { pc_setstartcluster ( fsp , ep , 0 ) ; } bp = NULL ; for ( i = 0 , ep = NULL ; i < ndirentries ; i ++ , ep ++ ) { boff = pc_blkoff ( fsp , offset ) ; if ( boff == 0 || bp == NULL || boff >= bp -> b_bcount ) { if ( bp != NULL ) { bwrite2 ( bp ) ; error = geterror ( bp ) ; brelse ( bp ) ; if ( error ) { return ( error ) ; } bp = NULL ; } error = pc_blkatoff ( dp , offset , & bp , & ep ) ; if ( error ) { return ( error ) ; } } * ep = direntries [ i ] ; offset += sizeof ( pcdir ) ; } if ( bp != NULL ) { bwrite2 ( bp ) ; error = geterror ( bp ) ; brelse ( bp ) ; if ( error ) { return ( error ) ; } } return ( 0 ) ; } 