static gboolean aethra_read ( wtap * wth , wtap_rec * rec , Buffer * buf , int * err , gchar * * err_info , gint64 * data_offset ) static gboolean aethra_seek_read ( wtap * wth , gint64 seek_off , wtap_rec * rec , Buffer * buf , int * err , gchar * * err_info ) static gboolean aethra_read_rec_header ( wtap * wth , FILE_T fh , struct aethrarec_hdr * hdr , wtap_rec * rec , int * err , gchar * * err_info ) static int aethra_file_type_subtype = - 1 ; void register_aethra ( void ) wtap_open_return_val aethra_open ( wtap * wth , int * err , gchar * * err_info ) { struct aethra_hdr hdr ; struct tm tm ; aethra_t * aethra ; if ( ! wtap_read_bytes ( wth -> fh , hdr . magic , sizeof hdr . magic , err , err_info ) ) { if ( * err != WTAP_ERR_SHORT_READ ) { return WTAP_OPEN_ERROR ; } return WTAP_OPEN_NOT_MINE ; } if ( memcmp ( hdr . magic , aethra_magic , sizeof aethra_magic ) != 0 ) { return WTAP_OPEN_NOT_MINE ; } if ( ! wtap_read_bytes ( wth -> fh , ( char * ) & hdr + sizeof hdr . magic , sizeof hdr - sizeof hdr . magic , err , err_info ) ) { return WTAP_OPEN_ERROR ; } wth -> file_type_subtype = aethra_file_type_subtype ; aethra = g_new ( aethra_t , 1 ) ; wth -> priv = ( void * ) aethra ; wth -> subtype_read = aethra_read ; wth -> subtype_seek_read = aethra_seek_read ; tm . tm_year = pletoh16 ( & hdr . start_year ) - 1900 ; tm . tm_mon = pletoh16 ( & hdr . start_month ) - 1 ; tm . tm_mday = pletoh16 ( & hdr . start_day ) ; tm . tm_hour = hdr . start_hour ; tm . tm_min = hdr . start_min ; tm . tm_sec = hdr . start_sec ; tm . tm_isdst = - 1 ; aethra -> start = mktime ( & tm ) ; wth -> file_encap = WTAP_ENCAP_ISDN ; wth -> file_tsprec = WTAP_TSPREC_MSEC ; wtap_add_generated_idb ( wth ) ; return WTAP_OPEN_MINE ; } 