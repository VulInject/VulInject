static int uas_slave_configure ( struct scsi_device * sdev ) { struct uas_dev_info * devinfo = sdev -> hostdata ; if ( devinfo -> flags & US_FL_NO_REPORT_OPCODES ) { sdev -> no_report_opcodes = 1 ; } if ( devinfo -> flags & US_FL_BROKEN_FUA ) { sdev -> broken_fua = 1 ; } if ( devinfo -> flags & US_FL_ALWAYS_SYNC ) { sdev -> skip_ms_page_3f = 1 ; sdev -> skip_ms_page_8 = 1 ; } if ( devinfo -> flags & US_FL_NO_READ_CAPACITY_16 ) { sdev -> no_read_capacity_16 = 1 ; } if ( devinfo -> flags & US_FL_NO_SAME ) { sdev -> no_write_same = 1 ; } if ( devinfo -> flags & US_FL_FIX_CAPACITY ) { sdev -> fix_capacity = 1 ; } if ( devinfo -> flags & US_FL_CAPACITY_HEURISTICS ) { sdev -> guess_capacity = 1 ; } if ( devinfo -> flags & US_FL_NO_WP_DETECT ) { sdev -> skip_ms_page_3f = 1 ; } scsi_change_queue_depth ( sdev , devinfo -> qdepth - 2 ) ; return 0 ; } static struct scsi_host_template uas_host_template = { . module = THIS_MODULE . name = "uas" . queuecommand = uas_queuecommand . target_alloc = uas_target_alloc . slave_alloc = uas_slave_alloc . slave_configure = uas_slave_configure . eh_abort_handler = uas_eh_abort_handler . eh_device_reset_handler = uas_eh_device_reset_handler . this_id = - 1 . skip_settle_delay = 1 . dma_boundary = PAGE_SIZE - 1 . cmd_size = sizeof ( uas_cmd_info ) } ; 