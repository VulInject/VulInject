static struct tm * timesub ( const time_t * timep , long offset , const struct state * sp , struct tm * tmp ) { const struct lsinfo * lp ; time_t tdays ; int idays ; long rem ; int y ; const int * ip ; long corr ; int hit ; int i ; long seconds ; corr = 0 ; hit = 0 ; i = ( sp == NULL ) ?0 : sp -> leapcnt ; while ( -- i >= 0 ) { lp = & sp -> lsis [ i ] ; if ( * timep >= lp -> ls_trans ) { if ( * timep == lp -> ls_trans ) { hit = ( ( i == 0 && lp -> ls_corr > 0 ) || lp -> ls_corr > sp -> lsis [ i - 1 ] . ls_corr ) ; if ( hit ) { while ( i > 0 && sp -> lsis [ i ] . ls_trans == sp -> lsis [ i - 1 ] . ls_trans + 1 && sp -> lsis [ i ] . ls_corr == sp -> lsis [ i - 1 ] . ls_corr + 1 ) { ++ hit ; -- i ; } } } corr = lp -> ls_corr ; break ; } } y = EPOCH_YEAR ; tdays = * timep / SECSPERDAY ; rem = * timep - tdays * SECSPERDAY ; while ( tdays < 0 || tdays >= year_lengths [ isleap ( y ) ] ) { int newy ; time_t tdelta ; int idelta ; int leapdays ; tdelta = tdays / DAYSPERLYEAR ; idelta = tdelta ; if ( tdelta - idelta >= 1 || idelta - tdelta >= 1 ) { return in ; } if ( idelta == 0 ) { idelta = ( tdays < 0 ) ?- 1 : 1 ; } newy = y ; if ( increment_overflow ( & newy , idelta ) ) { return NULL ; } leapdays = leaps_thru_end_of ( newy - 1 ) - leaps_thru_end_of ( y - 1 ) ; tdays -= ( ( time_t ) newy - y ) * DAYSPERNYEAR ; tdays -= leapdays ; y = newy ; } seconds = tdays * SECSPERDAY + 0.5 ; tdays = seconds / SECSPERDAY ; rem += seconds - tdays * SECSPERDAY ; idays = tdays ; rem += offset - corr ; while ( rem < 0 ) { rem += SECSPERDAY ; -- idays ; } while ( rem >= SECSPERDAY ) { rem -= SECSPERDAY ; ++ idays ; } while ( idays < 0 ) { if ( increment_overflow ( & y , - 1 ) ) { return NULL ; } idays += year_lengths [ isleap ( y ) ] ; } while ( idays >= year_lengths [ isleap ( y ) ] ) { idays -= year_lengths [ isleap ( y ) ] ; if ( increment_overflow ( & y , 1 ) ) { return NULL ; } } tmp -> tm_year = y ; if ( increment_overflow ( & tmp -> tm_year , - TM_YEAR_BASE ) ) { return NULL ; } tmp -> tm_yday = idays ; tmp -> tm_wday = EPOCH_WDAY + ( ( y - EPOCH_YEAR ) % DAYSPERWEEK ) * ( DAYSPERNYEAR % DAYSPERWEEK ) + leaps_thru_end_of ( y - 1 ) - leaps_thru_end_of ( EPOCH_YEAR - 1 ) + idays ; tmp -> tm_wday %= DAYSPERWEEK ; if ( tmp -> tm_wday < 0 ) { tmp -> tm_wday += DAYSPERWEEK ; } tmp -> tm_hour = ( int ) ( rem / SECSPERHOUR ) ; rem %= SECSPERHOUR ; tmp -> tm_min = ( int ) ( rem / SECSPERMIN ) ; tmp -> tm_sec = ( int ) ( rem % SECSPERMIN ) + hit ; ip = mon_lengths [ isleap ( y ) ] ; for ( tmp -> tm_mon = 0 ; idays >= ip [ tmp -> tm_mon ] ; ++ ( tmp -> tm_mon ) ) { idays -= ip [ tmp -> tm_mon ] ; } tmp -> tm_mday = ( int ) ( idays + 1 ) ; tmp -> tm_isdst = 0 ; tmp -> tm_gmtoff = offset ; return tmp ; } 