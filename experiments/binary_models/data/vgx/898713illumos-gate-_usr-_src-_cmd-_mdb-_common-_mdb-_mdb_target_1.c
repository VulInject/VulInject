int mdb_tgt_sespec_activate_one ( mdb_tgt_t * t , mdb_sespec_t * sep ) { mdb_vespec_t * vep = mdb_list_next ( & sep -> se_velist ) ; mdb_vespec_t * nvep ; mdb_sespec_t * dup ; ASSERT ( sep -> se_state == MDB_TGT_SPEC_IDLE ) ; ASSERT ( vep != NULL ) ; for ( dup = mdb_list_next ( & t -> t_active ) ; dup ; dup = mdb_list_next ( dup ) ) { if ( dup -> se_ops == sep -> se_ops && dup -> se_ops -> se_secmp ( t , dup , vep -> ve_args ) ) { ASSERT ( dup != sep ) ; break ; } } if ( dup != NULL ) { for ( vep = mdb_list_next ( & sep -> se_velist ) ; vep ; vep = nvep ) { mdb_dprintf ( MDB_DBG_TGT , "merge [ %d ] to sespec %p\n" , vep -> ve_id , ( void * ) dup ) ; if ( dup -> se_matched != NULL ) { vep -> ve_flags |= MDB_TGT_SPEC_MATCHED ; } nvep = mdb_list_next ( vep ) ; vep -> ve_hits = 0 ; mdb_list_delete ( & sep -> se_velist , vep ) ; mdb_tgt_sespec_rele ( t , sep ) ; mdb_list_append ( & dup -> se_velist , vep ) ; mdb_tgt_sespec_hold ( t , dup ) ; vep -> ve_se = dup ; } mdb_dprintf ( MDB_DBG_TGT , "merged idle sespec %p with %p\n" , ( void * ) sep , ( void * ) dup ) ; return ( 0 ) ; } if ( sep -> se_ops -> se_ctor ( t , sep , vep -> ve_args ) < 0 ) { sep -> se_errno = errno ; sep -> se_data = NULL ; return ( - 1 ) ; } for ( vep = mdb_list_next ( & sep -> se_velist ) ; vep ; vep = nvep ) { nvep = mdb_list_next ( vep ) ; vep -> ve_hits = 0 ; } mdb_list_delete ( & t -> t_idle , sep ) ; mdb_list_append ( & t -> t_active , sep ) ; sep -> se_state = MDB_TGT_SPEC_ACTIVE ; sep -> se_errno = 0 ; return ( 0 ) ; } 