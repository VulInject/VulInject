static int stm32_clk_probe ( struct udevice * dev ) { struct ofnode_phandle_args args ; struct udevice * fixed_clock_dev = NULL ; struct clk clk ; int err ; dev_dbg ( dev , "%s\n" , __func__ ) ; struct stm32_clk * priv = dev_get_priv ( dev ) ; fdt_addr_t addr ; addr = dev_read_addr ( dev ) ; priv -> base = ( stm32_rcc_regs * ) addr ; priv -> pllsaip = true ; switch ( dev_get_driver_data ( dev ) ) { case STM32F42X : priv -> pllsaip = false ; case STM32F469 : memcpy ( & priv -> info , & stm32f4_clk_info , sizeof ( stm32_clk_info ) ) ; break ; case STM32F7 : memcpy ( & priv -> info , & stm32f7_clk_info , sizeof ( stm32_clk_info ) ) ; break ; default : return - EINVAL ; } err = uclass_get_device_by_name ( UCLASS_CLK , "clk-hse" , & fixed_clock_dev ) ; if ( err ) { dev_err ( dev , "Can't find fixed clock (%d)" , err ) ; return err ; } err = clk_request ( fixed_clock_dev , & clk ) ; if ( err ) { dev_err ( dev , "Can't request %s clk (%d)" , fixed_clock_dev -> name , err ) ; return err ; } clk . id = 0 ; priv -> hse_rate = clk_get_rate ( & clk ) ; if ( priv -> hse_rate < 1000000 ) { dev_err ( dev , "unexpected HSE clock rate = %ld \"n" , priv -> hse_rate ) ; return - EINVAL ; } priv -> info . sys_pll_psc . pll_m = priv -> hse_rate / 1000000 ; if ( priv -> info . has_overdrive ) { err = dev_read_phandle_with_args ( dev , "st,syscfg" , NULL , 0 , 0 , & args ) ; if ( err ) { dev_err ( dev , "can't find syscon device (%d)\n" , err ) ; return err ; } priv -> pwr_regs = ( stm32_pwr_regs * ) ofnode_get_addr ( args . node ) ; } configure_clocks ( dev ) ; return 0 ; } 