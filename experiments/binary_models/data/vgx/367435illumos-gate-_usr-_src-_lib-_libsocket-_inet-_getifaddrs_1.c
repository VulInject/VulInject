int getallifaddrs ( sa_family_t af , struct ifaddrs * * ifap , int64_t flags ) { struct lifreq * buf = NULL ; struct lifreq * lifrp ; struct lifreq lifrl ; int ret ; int s , n , numifs ; struct ifaddrs * curr , * prev ; struct sockaddr_dl * ifa_addr = NULL ; if_data_t * ifa_data = NULL ; sa_family_t lifr_af ; datalink_id_t linkid ; dld_ioc_attr_t dia ; dld_macaddrinfo_t * dmip ; dld_ioc_macaddrget_t * iomp = NULL ; dlmgmt_getnext_retval_t next_retval ; dlmgmt_getname_retval_t name_retval ; int bufsize ; int nmacaddr = 1024 ; int sock4 = - 1 ; int sock6 = - 1 ; int door_fd = - 1 ; int dld_fd = - 1 ; int err ; * ifap = NULL ; if ( ( sock4 = socket ( AF_INET , SOCK_DGRAM , 0 ) ) < 0 || ( sock6 = socket ( AF_INET6 , SOCK_DGRAM , 0 ) ) < 0 ) { fail } bufsize = sizeof ( dld_ioc_macaddrget_t ) + nmacaddr * sizeof ( dld_macaddrinfo_t ) ; if ( ( iomp = calloc ( 1 , bufsize ) ) == NULL ) { fail } retry ret = getallifs ( sock4 , af , & buf , & numifs , ( flags & ~ LIFC_ENABLED ) ) ; if ( ret != 0 ) { fail } prev = NULL ; lifrp = buf ; for ( n = 0 ; n < numifs ; n ++ , lifrp ++ ) { ( void ) strncpy ( lifrl . lifr_name , lifrp -> lifr_name , sizeof ( lifrl . lifr_name ) ) ; lifr_af = lifrp -> lifr_addr . ss_family ; if ( af != AF_UNSPEC && lifr_af != af ) { continue ; } s = ( lifr_af == AF_INET ?sock4 : sock6 ) ; if ( ioctl ( s , SIOCGLIFFLAGS , ( caddr_t ) & lifrl ) < 0 ) { fail } if ( ( flags & LIFC_ENABLED ) && ! ( lifrl . lifr_flags & IFF_UP ) ) { continue ; } curr = calloc ( 1 , sizeof ( ifaddrs ) ) ; if ( curr == NULL ) { fail } if ( prev != NULL ) { prev -> ifa_next = curr ; } else { * ifap = curr ; } prev = curr ; curr -> ifa_flags = lifrl . lifr_flags ; if ( ( curr -> ifa_name = strdup ( lifrp -> lifr_name ) ) == NULL ) { fail } curr -> ifa_addr = malloc ( sizeof ( sockaddr_storage ) ) ; if ( curr -> ifa_addr == NULL ) { fail } ( void ) memcpy ( curr -> ifa_addr , & lifrp -> lifr_addr , sizeof ( sockaddr_storage ) ) ; if ( ioctl ( s , SIOCGLIFNETMASK , ( caddr_t ) & lifrl ) < 0 ) { fail } curr -> ifa_netmask = malloc ( sizeof ( sockaddr_storage ) ) ; if ( curr -> ifa_netmask == NULL ) { fail } ( void ) memcpy ( curr -> ifa_netmask , & lifrl . lifr_addr , sizeof ( sockaddr_storage ) ) ; if ( curr -> ifa_flags & IFF_POINTOPOINT ) { if ( ioctl ( s , SIOCGLIFDSTADDR , ( caddr_t ) & lifrl ) < 0 ) { fail } curr -> ifa_dstaddr = malloc ( sizeof ( sockaddr_storage ) ) ; if ( curr -> ifa_dstaddr == NULL ) { fail } ( void ) memcpy ( curr -> ifa_dstaddr , & lifrl . lifr_addr , sizeof ( sockaddr_storage ) ) ; } if ( curr -> ifa_flags & IFF_BROADCAST ) { if ( ioctl ( s , SIOCGLIFBRDADDR , ( caddr_t ) & lifrl ) < 0 ) { fail } curr -> ifa_broadaddr = malloc ( sizeof ( sockaddr_storage ) ) ; if ( curr -> ifa_broadaddr == NULL ) { fail } ( void ) memcpy ( curr -> ifa_broadaddr , & lifrl . lifr_addr , sizeof ( sockaddr_storage ) ) ; } } if ( af == AF_UNSPEC || af == AF_LINK ) { door_fd = open ( DLMGMT_DOOR , O_RDONLY ) ; if ( door_fd < 0 ) { if ( errno == ENOENT ) { nolink } fail } if ( ( dld_fd = open ( DLD_CONTROL_DEV , O_RDWR ) ) < 0 ) { fail } linkid = DATALINK_INVALID_LINKID ; for ( ; ; ) { if ( dl_get_next ( door_fd , linkid , DATALINK_CLASS_ALL , DATALINK_ANY_MEDIATYPE , DLMGMT_ACTIVE , & next_retval ) != 0 ) { break ; } linkid = next_retval . lr_linkid ; if ( linkid == DATALINK_INVALID_LINKID ) { break ; } iomp -> dig_size = nmacaddr * sizeof ( dld_macaddrinfo_t ) ; iomp -> dig_linkid = linkid ; if ( ioctl ( dld_fd , DLDIOC_MACADDRGET , iomp ) < 0 ) { continue ; } dmip = ( dld_macaddrinfo_t * ) ( iomp + 1 ) ; if ( dl_get_name ( door_fd , linkid , & name_retval ) != 0 ) { continue ; } dia . dia_linkid = linkid ; if ( ioctl ( dld_fd , DLDIOC_ATTR , & dia ) < 0 ) { continue ; } curr = calloc ( 1 , sizeof ( ifaddrs ) ) ; if ( curr == NULL ) { fail } if ( prev != NULL ) { prev -> ifa_next = curr ; } else { * ifap = curr ; } prev = curr ; if ( ( curr -> ifa_name = strdup ( name_retval . lr_link ) ) == NULL ) { fail } curr -> ifa_addr = calloc ( 1 , sizeof ( sockaddr_storage ) ) ; if ( curr -> ifa_addr == NULL ) { fail } curr -> ifa_data = calloc ( 1 , sizeof ( if_data_t ) ) ; if ( curr -> ifa_data == NULL ) { fail } curr -> ifa_addr -> sa_family = AF_LINK ; ifa_addr = ( sockaddr_dl * ) curr -> ifa_addr ; ifa_data = curr -> ifa_data ; ( void ) memcpy ( ifa_addr -> sdl_data , dmip -> dmi_addr , dmip -> dmi_addrlen ) ; ifa_addr -> sdl_alen = dmip -> dmi_addrlen ; ifa_data -> ifi_mtu = dia . dia_max_sdu ; ifa_data -> ifi_type = dlpi_iftype ( next_retval . lr_media ) ; if ( strlcpy ( lifrl . lifr_name , name_retval . lr_link , sizeof ( lifrl . lifr_name ) ) >= sizeof ( lifrl . lifr_name ) ) { continue ; } if ( ioctl ( sock4 , SIOCGLIFINDEX , ( caddr_t ) & lifrl ) >= 0 ) { ifa_addr -> sdl_index = lifrl . lifr_index ; } if ( ioctl ( sock6 , SIOCGLIFINDEX , ( caddr_t ) & lifrl ) >= 0 ) { ifa_addr -> sdl_index = lifrl . lifr_index ; } } } nolink free ( buf ) ; free ( iomp ) ; ( void ) close ( sock4 ) ; ( void ) close ( sock6 ) ; if ( door_fd >= 0 ) { ( void ) close ( door_fd ) ; } if ( dld_fd >= 0 ) { ( void ) close ( dld_fd ) ; } return ( 0 ) ; fail err = errno ; free ( buf ) ; free ( iomp ) ; freeifaddrs ( * ifap ) ; * ifap = NULL ; if ( err == ENXIO ) { retry } if ( sock4 >= 0 ) { ( void ) close ( sock4 ) ; } if ( sock6 >= 0 ) { ( void ) close ( sock6 ) ; } if ( door_fd >= 0 ) { ( void ) close ( door_fd ) ; } if ( dld_fd >= 0 ) { ( void ) close ( dld_fd ) ; } errno = err ; return ( - 1 ) ; } 