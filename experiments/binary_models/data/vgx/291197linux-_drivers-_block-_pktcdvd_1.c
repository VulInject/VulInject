static int pkt_new_dev ( struct pktcdvd_device * pd , dev_t dev ) { int i ; struct block_device * bdev ; struct scsi_device * sdev ; if ( pd -> pkt_dev == dev ) { pkt_err ( pd , "recursive setup not allowed\n" ) ; return - EBUSY ; } for ( i = 0 ; i < MAX_WRITERS ; i ++ ) { struct pktcdvd_device * pd2 = pkt_devs [ i ] ; if ( pd2 -> bdev -> bd_dev == dev ) { pkt_err ( pd , "%pg already setup\n" , pd2 -> bdev ) ; return - EBUSY ; } if ( pd2 -> pkt_dev == dev ) { pkt_err ( pd , "can't chain pktcdvd devices\n" ) ; return - EBUSY ; } } bdev = blkdev_get_by_dev ( dev , FMODE_READ | FMODE_NDELAY , NULL ) ; if ( IS_ERR ( bdev ) ) { return PTR_ERR ( bdev ) ; } sdev = scsi_device_from_queue ( bdev -> bd_disk -> queue ) ; if ( ! sdev ) { blkdev_put ( bdev , FMODE_READ | FMODE_NDELAY ) ; return - EINVAL ; } put_device ( & sdev -> sdev_gendev ) ; __module_get ( THIS_MODULE ) ; pd -> bdev = bdev ; set_blocksize ( bdev , CD_FRAMESIZE ) ; pkt_init_queue ( pd ) ; atomic_set ( & pd -> cdrw . pending_bios , 0 ) ; pd -> cdrw . thread = kthread_run ( kcdrwd , pd , "%s" , pd -> name ) ; if ( IS_ERR ( pd -> cdrw . thread ) ) { pkt_err ( pd , "can't start kernel thread\n" ) ; out_mem } proc_create_single_data ( pd -> name , 0 , pkt_proc , pkt_seq_show , pd ) ; pkt_dbg ( 1 , pd , "writer mapped to %pg\n" , bdev ) ; return 0 ; out_mem blkdev_put ( bdev , FMODE_READ | FMODE_NDELAY ) ; module_put ( THIS_MODULE ) ; return - ENOMEM ; } 