prepare_spawn ( , ) { size_t argc ; const char * * new_argv ; size_t i ; for ( argc = 0 ; argv [ argc ] != NULL ; argc ++ ) { } new_argv = ( const char * * ) malloc ( ( 1 + argc + 1 ) * sizeof ( const char * ) ) ; new_argv [ 0 ] = "sh.exe" ; int needed_size = 0 ; for ( i = 0 ; i < argc ; i ++ ) { const char * string = argv [ i ] ; size_t length ; if ( string [ 0 ] == '\0' ) { length = strlen ( "\"\"" ) ; } if ( strpbrk ( string , SHELL_SPECIAL_CHARS ) != NULL ) { length = quoted_arg_length ( string ) ; } else { length = strlen ( string ) ; } needed_size += length + 1 ; } char * mem ; if ( needed_size == 0 ) { mem = NULL ; } else { mem = ( char * ) malloc ( needed_size ) ; if ( mem == NULL ) { free ( new_argv ) ; errno = ENOMEM ; return NULL ; } } * mem_to_free = mem ; for ( i = 0 ; i < argc ; i ++ ) { const char * string = argv [ i ] ; new_argv [ 1 + i ] = mem ; if ( string [ 0 ] == '\0' ) { size_t length = strlen ( "\"\"" ) ; memcpy ( mem , "\"\"" , length + 1 ) ; mem += length + 1 ; } if ( strpbrk ( string , SHELL_SPECIAL_CHARS ) != NULL ) { mem = quoted_arg_string ( string , mem ) ; } else { size_t length = strlen ( string ) ; memcpy ( mem , string , length + 1 ) ; mem += length + 1 ; } } new_argv [ 1 + argc ] = NULL ; return new_argv ; } 