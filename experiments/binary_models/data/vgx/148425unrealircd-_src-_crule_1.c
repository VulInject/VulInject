int crule_parsearglist ( crule_treeptr argrootp , int * next_tokp , char * * ruleptr ) { int errcode = CR_NOERR ; char * argelemp = NULL ; char currarg [ CR_MAXARGLEN ] ; int arglen = 0 ; char word [ CR_MAXARGLEN ] ; int wordlen = 0 ; argrootp -> numargs = 0 ; currarg [ 0 ] = '\0' ; while ( errcode == CR_NOERR ) { switch ( * next_tokp ) { case CR_WORD : crule_getword ( word , & wordlen , CR_MAXARGLEN , ruleptr ) ; if ( currarg [ 0 ] != '\0' ) { if ( ( arglen + wordlen ) < ( CR_MAXARGLEN - 1 ) ) { strlcat ( currarg , " " , sizeof currarg ) ; strlcat ( currarg , word , sizeof currarg ) ; arglen += wordlen + 1 ; } } else { strlcpy ( currarg , word , sizeof currarg ) ; arglen = wordlen ; } errcode = crule_gettoken ( next_tokp , ruleptr ) ; break ; default : collapse ( currarg ) ; if ( * currarg ) { safe_strdup ( argelemp , currarg ) ; argrootp -> arg [ argrootp -> numargs ++ ] = ( void * ) argelemp ; } currarg [ 0 ] = '\0' ; errcode = crule_gettoken ( next_tokp , ruleptr ) ; break ; } } return ( errcode ) ; } 