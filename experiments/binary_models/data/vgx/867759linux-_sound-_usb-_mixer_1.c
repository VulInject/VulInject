static int snd_usb_mixer_controls ( struct usb_mixer_interface * mixer ) { struct mixer_build state ; int err ; const struct usbmix_ctl_map * map ; void * p ; state . chip = mixer -> chip ; state . mixer = mixer ; state . buffer = mixer -> hostif -> extra ; state . buflen = mixer -> hostif -> extralen ; for ( map = usbmix_ctl_maps ; map -> id ; map ++ ) { if ( map -> id == state . chip -> usb_id ) { state . map = map -> map ; state . selector_map = map -> selector_map ; mixer -> connector_map = map -> connector_map ; break ; } } p = NULL ; while ( ( p = snd_usb_find_csint_desc ( mixer -> hostif -> extra , mixer -> hostif -> extralen , p , UAC_OUTPUT_TERMINAL ) ) != NULL ) { if ( ! snd_usb_validate_audio_desc ( p , mixer -> protocol ) ) { continue ; } if ( mixer -> protocol == UAC_VERSION_1 ) { struct uac1_output_terminal_descriptor * desc = p ; set_bit ( desc -> bTerminalID , state . unitbitmap ) ; state . oterm . id = desc -> bTerminalID ; state . oterm . type = le16_to_cpu ( desc -> wTerminalType ) ; state . oterm . name = desc -> iTerminal ; err = parse_audio_unit ( & state , desc -> bSourceID ) ; if ( err < 0 && err != - EINVAL ) { return err ; } } if ( mixer -> protocol == UAC_VERSION_2 ) { struct uac2_output_terminal_descriptor * desc = p ; set_bit ( desc -> bTerminalID , state . unitbitmap ) ; state . oterm . id = desc -> bTerminalID ; state . oterm . type = le16_to_cpu ( desc -> wTerminalType ) ; state . oterm . name = desc -> iTerminal ; err = parse_audio_unit ( & state , desc -> bSourceID ) ; if ( err < 0 && err != - EINVAL ) { return err ; } err = parse_audio_unit ( & state , desc -> bCSourceID ) ; if ( err < 0 && err != - EINVAL ) { return err ; } if ( ( state . oterm . type & 0xff00 ) != 0x0100 && uac_v2v3_control_is_readable ( le16_to_cpu ( desc -> bmControls ) , UAC2_TE_CONNECTOR ) ) { build_connector_control ( state . mixer , state . map , & state . oterm , false ) ; } } else { struct uac3_output_terminal_descriptor * desc = p ; set_bit ( desc -> bTerminalID , state . unitbitmap ) ; state . oterm . id = desc -> bTerminalID ; state . oterm . type = le16_to_cpu ( desc -> wTerminalType ) ; state . oterm . name = le16_to_cpu ( desc -> wTerminalDescrStr ) ; err = parse_audio_unit ( & state , desc -> bSourceID ) ; if ( err < 0 && err != - EINVAL ) { return err ; } err = parse_audio_unit ( & state , desc -> bCSourceID ) ; if ( err < 0 && err != - EINVAL ) { return err ; } if ( ( state . oterm . type & 0xff00 ) != 0x0100 && uac_v2v3_control_is_readable ( le32_to_cpu ( desc -> bmControls ) , UAC3_TE_INSERTION ) ) { build_connector_control ( state . mixer , state . map , & state . oterm , false ) ; } } } return 0 ; } 