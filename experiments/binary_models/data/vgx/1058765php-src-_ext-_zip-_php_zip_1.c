static int php_zip_extract_file ( struct zip * za , char * dest , char * file , size_t file_len ) { php_stream_statbuf ssb ; struct zip_file * zf ; struct zip_stat sb ; char b [ 8192 ] ; int n , ret ; php_stream * stream ; char * fullpath ; char * file_dirname_fullpath ; char file_dirname [ MAXPATHLEN ] ; size_t dir_len , len ; int is_dir_only = 0 ; char * path_cleaned ; size_t path_cleaned_len ; cwd_state new_state ; zend_string * file_basename ; new_state . cwd = CWD_STATE_ALLOC ( 1 ) ; new_state . cwd [ 0 ] = '\0' ; new_state . cwd_length = 0 ; virtual_file_ex ( & new_state , file , NULL , CWD_EXPAND ) ; path_cleaned = php_zip_make_relative_path ( new_state . cwd , new_state . cwd_length ) ; if ( ! path_cleaned ) { CWD_STATE_FREE ( new_state . cwd ) ; return 0 ; } path_cleaned_len = strlen ( path_cleaned ) ; if ( path_cleaned_len >= MAXPATHLEN || zip_stat ( za , file , 0 , & sb ) != 0 ) { CWD_STATE_FREE ( new_state . cwd ) ; return 0 ; } if ( path_cleaned_len > 1 && IS_SLASH ( path_cleaned [ path_cleaned_len - 1 ] ) ) { len = spprintf ( & file_dirname_fullpath , 0 , "%s/%s" , dest , path_cleaned ) ; is_dir_only = 1 ; } else { memcpy ( file_dirname , path_cleaned , path_cleaned_len ) ; dir_len = php_dirname ( file_dirname , path_cleaned_len ) ; if ( ! dir_len || ( dir_len == 1 && file_dirname [ 0 ] == '.' ) ) { len = spprintf ( & file_dirname_fullpath , 0 , "%s" , dest ) ; } else { len = spprintf ( & file_dirname_fullpath , 0 , "%s/%s" , dest , file_dirname ) ; } file_basename = php_basename ( path_cleaned , path_cleaned_len , NULL , 0 ) ; if ( ZIP_OPENBASEDIR_CHECKPATH ( file_dirname_fullpath ) ) { efree ( file_dirname_fullpath ) ; zend_string_release_ex ( file_basename , 0 ) ; CWD_STATE_FREE ( new_state . cwd ) ; return 0 ; } } if ( php_stream_stat_path_ex ( file_dirname_fullpath , PHP_STREAM_URL_STAT_QUIET , & ssb , NULL ) < 0 ) { ret = php_stream_mkdir ( file_dirname_fullpath , 0777 , PHP_STREAM_MKDIR_RECURSIVE | REPORT_ERRORS , NULL ) ; if ( ! ret ) { efree ( file_dirname_fullpath ) ; if ( ! is_dir_only ) { zend_string_release_ex ( file_basename , 0 ) ; } CWD_STATE_FREE ( new_state . cwd ) ; return 0 ; } } if ( is_dir_only ) { efree ( file_dirname_fullpath ) ; CWD_STATE_FREE ( new_state . cwd ) ; return 1 ; } len = spprintf ( & fullpath , 0 , "%s/%s" , file_dirname_fullpath , ZSTR_VAL ( file_basename ) ) ; if ( ! len ) { efree ( file_dirname_fullpath ) ; zend_string_release_ex ( file_basename , 0 ) ; CWD_STATE_FREE ( new_state . cwd ) ; return 0 ; } if ( len > MAXPATHLEN ) { php_error_docref ( NULL , E_WARNING , "Full extraction path exceed MAXPATHLEN (%i)" , MAXPATHLEN ) ; efree ( file_dirname_fullpath ) ; zend_string_release_ex ( file_basename , 0 ) ; CWD_STATE_FREE ( new_state . cwd ) ; return 0 ; } if ( ZIP_OPENBASEDIR_CHECKPATH ( fullpath ) ) { efree ( file_dirname_fullpath ) ; zend_string_release_ex ( file_basename , 0 ) ; CWD_STATE_FREE ( new_state . cwd ) ; return 0 ; } zf = zip_fopen ( za , file , 0 ) ; if ( zf == NULL ) { n = - 1 ; done } stream = php_stream_open_wrapper ( fullpath , "w+b" , REPORT_ERRORS , NULL ) ; if ( stream == NULL ) { n = - 1 ; zip_fclose ( zf ) ; done } n = 0 ; while ( ( n = zip_fread ( zf , b , sizeof ( b ) ) ) > 0 ) { php_stream_write ( stream , b , n ) ; } if ( stream -> wrapper -> wops -> stream_metadata ) { struct utimbuf ut ; ut . modtime = ut . actime = sb . mtime ; stream -> wrapper -> wops -> stream_metadata ( stream -> wrapper , fullpath , PHP_STREAM_META_TOUCH , & ut , NULL ) ; } php_stream_close ( stream ) ; n = zip_fclose ( zf ) ; done efree ( fullpath ) ; zend_string_release_ex ( file_basename , 0 ) ; efree ( file_dirname_fullpath ) ; CWD_STATE_FREE ( new_state . cwd ) ; if ( n < 0 ) { return 0 ; } else { return 1 ; } } 