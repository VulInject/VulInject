DISAS_INSN ( ) { int opsize ; int op ; TCGv src1 ; TCGv src2 ; TCGv tmp ; TCGv addr ; TCGv dest ; if ( ( insn & 0x38 ) != 0 ) { opsize = OS_BYTE ; } else { opsize = OS_LONG ; } op = ( insn >> 6 ) & 3 ; SRC_EA ( env , src1 , opsize , 0 , op ?& addr : NULL ) ; gen_flush_flags ( s ) ; src2 = tcg_temp_new ( ) ; if ( opsize == OS_BYTE ) { tcg_gen_andi_i32 ( src2 , DREG ( insn , 9 ) , 7 ) ; } else { tcg_gen_andi_i32 ( src2 , DREG ( insn , 9 ) , 31 ) ; } tmp = tcg_const_i32 ( 1 ) ; tcg_gen_shl_i32 ( tmp , tmp , src2 ) ; tcg_gen_and_i32 ( QREG_CC_Z , src1 , tmp ) ; dest = tcg_temp_new ( ) ; switch ( op ) { case 1 : tcg_gen_xor_i32 ( dest , src1 , tmp ) ; break ; case 2 : tcg_gen_andc_i32 ( dest , src1 , tmp ) ; break ; case 3 : tcg_gen_or_i32 ( dest , src1 , tmp ) ; break ; default : break ; } tcg_temp_free ( tmp ) ; if ( op ) { DEST_EA ( env , insn , opsize , dest , & addr ) ; } tcg_temp_free ( dest ) ; } 