static int crypto_authenc_create ( struct crypto_template * tmpl , struct rtattr * * tb ) { struct crypto_attr_type * algt ; struct aead_instance * inst ; struct hash_alg_common * auth ; struct crypto_alg * auth_base ; struct skcipher_alg * enc ; struct authenc_instance_ctx * ctx ; const char * enc_name ; int err ; algt = crypto_get_attr_type ( tb ) ; if ( IS_ERR ( algt ) ) { return PTR_ERR ( algt ) ; } if ( ( algt -> type ^ CRYPTO_ALG_TYPE_AEAD ) & algt -> mask ) { return - EINVAL ; } auth = ahash_attr_alg ( tb [ 1 ] , CRYPTO_ALG_TYPE_HASH , CRYPTO_ALG_TYPE_AHASH_MASK | crypto_requires_sync ( algt -> type , algt -> mask ) ) ; if ( IS_ERR ( auth ) ) { return PTR_ERR ( auth ) ; } auth_base = & auth -> base ; enc_name = crypto_attr_alg_name ( tb [ 2 ] ) ; err = PTR_ERR ( enc_name ) ; if ( IS_ERR ( enc_name ) ) { out_put_auth } inst = kmalloc ( sizeof ( * inst ) + sizeof ( * ctx ) , GFP_KERNEL ) ; err = - ENOMEM ; if ( ! inst ) { out_put_auth } ctx = aead_instance_ctx ( inst ) ; err = crypto_init_ahash_spawn ( & ctx -> auth , auth , aead_crypto_instance ( inst ) ) ; if ( err ) { err_free_inst } crypto_set_skcipher_spawn ( & ctx -> enc , aead_crypto_instance ( inst ) ) ; err = crypto_grab_skcipher ( & ctx -> enc , enc_name , 0 , crypto_requires_sync ( algt -> type , algt -> mask ) ) ; if ( err ) { err_drop_auth } enc = crypto_spawn_skcipher_alg ( & ctx -> enc ) ; ctx -> reqoff = ALIGN ( 2 * auth -> digestsize + auth_base -> cra_alignmask , auth_base -> cra_alignmask + 1 ) ; err = - ENAMETOOLONG ; if ( snprintf ( inst -> alg . base . cra_name , CRYPTO_MAX_ALG_NAME , "authenc(%s,%s)" , auth_base -> cra_name , enc -> base . cra_name ) >= CRYPTO_MAX_ALG_NAME ) { err_drop_enc } if ( snprintf ( inst -> alg . base . cra_driver_name , CRYPTO_MAX_ALG_NAME , "authenc(%s,%s)" , auth_base -> cra_driver_name , enc -> base . cra_driver_name ) >= CRYPTO_MAX_ALG_NAME ) { err_drop_enc } inst -> alg . base . cra_flags = ( auth_base -> cra_flags | enc -> base . cra_flags ) & CRYPTO_ALG_ASYNC ; inst -> alg . base . cra_priority = enc -> base . cra_priority * 10 + auth_base -> cra_priority ; inst -> alg . base . cra_blocksize = enc -> base . cra_blocksize ; inst -> alg . base . cra_alignmask = auth_base -> cra_alignmask | enc -> base . cra_alignmask ; inst -> alg . base . cra_ctxsize = sizeof ( crypto_authenc_ctx ) ; inst -> alg . ivsize = crypto_skcipher_alg_ivsize ( enc ) ; inst -> alg . chunksize = crypto_skcipher_alg_chunksize ( enc ) ; inst -> alg . maxauthsize = auth -> digestsize ; inst -> alg . init = crypto_authenc_init_tfm ; inst -> alg . exit = crypto_authenc_exit_tfm ; inst -> alg . setkey = crypto_authenc_setkey ; inst -> alg . encrypt = crypto_authenc_encrypt ; inst -> alg . decrypt = crypto_authenc_decrypt ; inst -> free = crypto_authenc_free ; err = aead_register_instance ( tmpl , inst ) ; if ( err ) { err_drop_enc } out crypto_mod_put ( auth_base ) ; return err ; err_drop_enc crypto_drop_skcipher ( & ctx -> enc ) ; err_drop_auth crypto_drop_ahash ( & ctx -> auth ) ; err_free_inst kfree ( inst ) ; out_put_auth out } 