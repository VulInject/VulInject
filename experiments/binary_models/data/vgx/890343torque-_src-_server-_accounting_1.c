int acct_job ( job * pjob , std :: string & ds ) { int resc_access_perm = READ_ONLY ; char local_buf [ MAXLINE * 4 ] ; pbs_queue * pque ; tlist_head attrlist ; svrattrl * pal ; CLEAR_HEAD ( attrlist ) ; if ( LOGLEVEL >= 10 ) { log_event ( PBSEVENT_DEBUG , PBS_EVENTCLASS_JOB , __func__ , pjob -> ji_qs . ji_jobid ) ; } sprintf ( local_buf , "user=%s " , pjob -> ji_wattr [ JOB_ATR_euser ] . at_val . at_str ) ; ds += local_buf ; sprintf ( local_buf , "group=%s " , pjob -> ji_wattr [ JOB_ATR_egroup ] . at_val . at_str ) ; ds += local_buf ; if ( pjob -> ji_wattr [ JOB_ATR_account ] . at_flags & ATR_VFLAG_SET ) { sprintf ( local_buf , "account=%s " , pjob -> ji_wattr [ JOB_ATR_account ] . at_val . at_str ) ; ds += local_buf ; } sprintf ( local_buf , "jobname=%s " , pjob -> ji_wattr [ JOB_ATR_jobname ] . at_val . at_str ) ; ds += local_buf ; if ( ( pque = get_jobs_queue ( & pjob ) ) != NULL ) { sprintf ( local_buf , "queue=%s " , pque -> qu_qs . qu_name ) ; unlock_queue ( pque , __func__ , NULL , LOGLEVEL ) ; ds += local_buf ; } if ( pjob == NULL ) { log_err ( PBSE_JOBNOTFOUND , __func__ , "Job lost while acquiring queue 1" ) ; return ( PBSE_JOBNOTFOUND ) ; } sprintf ( local_buf , "ctime=%ld " , pjob -> ji_wattr [ JOB_ATR_ctime ] . at_val . at_long ) ; ds += local_buf ; sprintf ( local_buf , "qtime=%ld " , pjob -> ji_wattr [ JOB_ATR_qtime ] . at_val . at_long ) ; ds += local_buf ; sprintf ( local_buf , "etime=%ld " , pjob -> ji_wattr [ JOB_ATR_etime ] . at_val . at_long ) ; ds += local_buf ; sprintf ( local_buf , "start=%ld " , ( long ) pjob -> ji_qs . ji_stime ) ; ds += local_buf ; sprintf ( local_buf , "owner=%s " , pjob -> ji_wattr [ JOB_ATR_job_owner ] . at_val . at_str ) ; ds += local_buf ; if ( pjob -> ji_wattr [ JOB_ATR_exec_host ] . at_val . at_str != NULL ) { ds += "exec_host=" ; ds += pjob -> ji_wattr [ JOB_ATR_exec_host ] . at_val . at_str ; ds += " " ; } if ( ( cray_enabled == true ) && ( pjob -> ji_wattr [ JOB_ATR_login_node_id ] . at_flags & ATR_VFLAG_SET ) ) { ds += "login_node=" ; ds += pjob -> ji_wattr [ JOB_ATR_login_node_id ] . at_val . at_str ; ds += " " ; } job_attr_def [ JOB_ATR_resource ] . at_encode ( & pjob -> ji_wattr [ JOB_ATR_resource ] , & attrlist , job_attr_def [ JOB_ATR_resource ] . at_name , NULL , ATR_ENCODE_CLIENT , resc_access_perm ) ; while ( ( pal = ( svrattrl * ) GET_NEXT ( attrlist ) ) != NULL ) { ds += pal -> al_name ; if ( pal -> al_resc != NULL ) { ds += "." ; ds += pal -> al_resc ; } ds += "=" ; ds += pal -> al_value ; ds += " " ; delete_link ( & pal -> al_link ) ; free ( pal ) ; } if ( pjob -> ji_wattr [ JOB_SITE_ATR_x ] . at_flags & ATR_VFLAG_SET ) { sprintf ( local_buf , "x=%s " , pjob -> ji_wattr [ JOB_SITE_ATR_x ] . at_val . at_str ) ; ds += local_buf ; } return ( PBSE_NONE ) ; } int acct_open ( char * filename , bool acct_mutex_locked ) { char filen [ _POSIX_PATH_MAX ] ; char logmsg [ _POSIX_PATH_MAX + 80 ] ; FILE * newacct ; time_t now ; struct tm * ptm ; struct tm tmpPtm ; if ( filename == NULL ) { now = time ( 0 ) ; ptm = localtime_r ( & now , & tmpPtm ) ; sprintf ( filen , "%s%04d%02d%02d" , path_acct , ptm -> tm_year + 1900 , ptm -> tm_mon + 1 , ptm -> tm_mday ) ; filename = filen ; acct_auto_switch = 1 ; acct_opened_day = ptm -> tm_yday ; } if ( * filename == '\0' ) { return ( 0 ) ; } if ( * filename != '/' ) { return ( - 1 ) ; } if ( ( newacct = fopen ( filename , "a" ) ) == NULL ) { log_err ( errno , __func__ , filename ) ; return ( - 1 ) ; } setbuf ( newacct , NULL ) ; if ( acct_mutex_locked == false ) { pthread_mutex_lock ( acctfile_mutex ) ; } if ( acct_opened > 0 ) { fclose ( acctfile ) ; } acctfile = newacct ; acct_opened = 1 ; if ( acct_mutex_locked == false ) { pthread_mutex_unlock ( acctfile_mutex ) ; } sprintf ( logmsg , "Account file %s opened" , filename ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_SERVER , "Act" , logmsg ) ; return ( 0 ) ; } void acct_close ( bool acct_mutex_locked ) { if ( acct_mutex_locked == false ) { pthread_mutex_lock ( acctfile_mutex ) ; } if ( acct_opened == 1 ) { fclose ( acctfile ) ; acct_opened = 0 ; } if ( acct_mutex_locked == false ) { pthread_mutex_unlock ( acctfile_mutex ) ; } return ; } void account_record ( int acctype , job * pjob , const char * text ) { time_t time_now = time ( NULL ) ; struct tm * ptm ; struct tm tmpPtm ; pthread_mutex_lock ( acctfile_mutex ) ; if ( acct_opened == 0 ) { acct_open ( acct_file , true ) ; } ptm = localtime_r ( & time_now , & tmpPtm ) ; if ( ( acct_auto_switch != 0 ) && ( acct_opened_day != ptm -> tm_yday ) ) { acct_close ( true ) ; acct_open ( NULL , true ) ; } if ( text == NULL ) { text = ( char * ) "" ; } fprintf ( acctfile , "%02d/%02d/%04d %02d:%02d:%02d;%c;%s;%s\n" , ptm -> tm_mon + 1 , ptm -> tm_mday , ptm -> tm_year + 1900 , ptm -> tm_hour , ptm -> tm_min , ptm -> tm_sec , ( char ) acctype , pjob -> ji_qs . ji_jobid , text ) ; pthread_mutex_unlock ( acctfile_mutex ) ; return ; } 