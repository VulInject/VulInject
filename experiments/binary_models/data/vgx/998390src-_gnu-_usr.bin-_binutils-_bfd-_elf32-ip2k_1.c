ip2k_relax_switch_table_128 ( , , , , ) bfd * abfd ATTRIBUTE_UNUSED ; asection * sec ; Elf_Internal_Rela * irel ; bfd_boolean * again ; struct misc * misc ; { Elf_Internal_Rela * irelend = misc -> irelbase + sec -> reloc_count ; Elf_Internal_Rela * ireltest = irel ; bfd_byte code [ 4 ] ; bfd_vma addr ; addr = irel -> r_offset ; while ( 1 ) { if ( addr + 4 > sec -> _cooked_size ) { break ; } ip2k_get_mem ( abfd , misc -> contents + addr , 4 , code ) ; if ( ( ! IS_PAGE_OPCODE ( code + 0 ) ) || ( ! IS_JMP_OPCODE ( code + 2 ) ) ) { break ; } if ( ireltest >= irelend ) { _bfd_error_handler ( _ ( "ip2k relaxer: switch table without complete matching relocation information." ) ) ; return FALSE ; } if ( ireltest -> r_offset != addr ) { _bfd_error_handler ( _ ( "ip2k relaxer: switch table without complete matching relocation information." ) ) ; return FALSE ; } addr += 4 ; ireltest += 2 ; } ip2k_get_mem ( abfd , misc -> contents + irel -> r_offset - 4 , 4 , code ) ; if ( ( ! IS_ADD_W_WREG_OPCODE ( code + 0 ) ) || ( ! IS_ADD_PCL_W_OPCODE ( code + 2 ) ) ) { _bfd_error_handler ( _ ( "ip2k relaxer: switch table header corrupt." ) ) ; return FALSE ; } if ( ! ip2k_elf_relax_delete_bytes ( abfd , sec , irel -> r_offset - 4 , 2 ) ) { return FALSE ; } * again = TRUE ; while ( irel < ireltest ) { if ( ! ip2k_delete_page_insn ( abfd , sec , irel , again , misc ) ) { return FALSE ; } irel += 2 ; } return TRUE ; } 