static int ucan_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { int ret ; int i ; u32 protocol_version ; struct usb_device * udev ; struct net_device * netdev ; struct usb_host_interface * iface_desc ; struct ucan_priv * up ; struct usb_endpoint_descriptor * ep ; u16 in_ep_size ; u16 out_ep_size ; u8 in_ep_addr ; u8 out_ep_addr ; union ucan_ctl_payload * ctl_msg_buffer ; char firmware_str [ sizeof ( ucan_ctl_payload ) + 1 ] ; udev = interface_to_usbdev ( intf ) ; iface_desc = intf -> cur_altsetting ; dev_info ( & udev -> dev , "%s: probing device on interface #%d\n" , UCAN_DRIVER_NAME , iface_desc -> desc . bInterfaceNumber ) ; if ( iface_desc -> desc . bNumEndpoints != 2 ) { dev_err ( & udev -> dev , "%s: invalid EP count (%d)" , UCAN_DRIVER_NAME , iface_desc -> desc . bNumEndpoints ) ; err_firmware_needs_update } in_ep_addr = 0 ; out_ep_addr = 0 ; in_ep_size = 0 ; out_ep_size = 0 ; for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; i ++ ) { ep = & iface_desc -> endpoint [ i ] . desc ; if ( ( ( ep -> bEndpointAddress & USB_ENDPOINT_DIR_MASK ) != 0 ) && ( ( ep -> bmAttributes & USB_ENDPOINT_XFERTYPE_MASK ) == USB_ENDPOINT_XFER_BULK ) ) { in_ep_addr = ep -> bEndpointAddress ; in_ep_addr &= USB_ENDPOINT_NUMBER_MASK ; in_ep_size = le16_to_cpu ( ep -> wMaxPacketSize ) ; } if ( ( ( ep -> bEndpointAddress & USB_ENDPOINT_DIR_MASK ) == 0 ) && ( ( ep -> bmAttributes & USB_ENDPOINT_XFERTYPE_MASK ) == USB_ENDPOINT_XFER_BULK ) ) { out_ep_addr = ep -> bEndpointAddress ; out_ep_addr &= USB_ENDPOINT_NUMBER_MASK ; out_ep_size = le16_to_cpu ( ep -> wMaxPacketSize ) ; } } if ( ! in_ep_addr || ! out_ep_addr ) { dev_err ( & udev -> dev , "%s: invalid endpoint configuration\n" , UCAN_DRIVER_NAME ) ; err_firmware_needs_update } if ( in_ep_size < sizeof ( ucan_message_in ) ) { dev_err ( & udev -> dev , "%s: invalid in_ep MaxPacketSize\n" , UCAN_DRIVER_NAME ) ; err_firmware_needs_update } if ( out_ep_size < sizeof ( ucan_message_out ) ) { dev_err ( & udev -> dev , "%s: invalid out_ep MaxPacketSize\n" , UCAN_DRIVER_NAME ) ; err_firmware_needs_update } ctl_msg_buffer = devm_kzalloc ( & udev -> dev , sizeof ( ucan_ctl_payload ) , GFP_KERNEL ) ; if ( ! ctl_msg_buffer ) { dev_err ( & udev -> dev , "%s: failed to allocate control pipe memory\n" , UCAN_DRIVER_NAME ) ; return - ENOMEM ; } ret = usb_control_msg ( udev , usb_rcvctrlpipe ( udev , 0 ) , UCAN_COMMAND_GET , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , UCAN_COMMAND_GET_PROTOCOL_VERSION , iface_desc -> desc . bInterfaceNumber , ctl_msg_buffer , sizeof ( ucan_ctl_payload ) , UCAN_USB_CTL_PIPE_TIMEOUT ) ; if ( ret != 4 ) { dev_err ( & udev -> dev , "%s: could not read protocol version, ret=%d\n" , UCAN_DRIVER_NAME , ret ) ; if ( ret >= 0 ) { ret = - EINVAL ; } err_firmware_needs_update } protocol_version = le32_to_cpu ( ctl_msg_buffer -> cmd_get_protocol_version . version ) ; if ( protocol_version ( UCAN_PROTOCOL_VERSION_MIN || protocol_version ) UCAN_PROTOCOL_VERSION_MAX ) { dev_err ( & udev -> dev , "%s: device protocol version %d is not supported\n" , UCAN_DRIVER_NAME , protocol_version ) ; err_firmware_needs_update } ret = usb_control_msg ( udev , usb_rcvctrlpipe ( udev , 0 ) , UCAN_COMMAND_GET , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , UCAN_COMMAND_GET_INFO , iface_desc -> desc . bInterfaceNumber , ctl_msg_buffer , sizeof ( ctl_msg_buffer -> cmd_get_device_info ) , UCAN_USB_CTL_PIPE_TIMEOUT ) ; if ( ret < 0 ) { dev_err ( & udev -> dev , "%s: failed to retrieve device info\n" , UCAN_DRIVER_NAME ) ; err_firmware_needs_update } if ( ret < sizeof ( ctl_msg_buffer -> cmd_get_device_info ) ) { dev_err ( & udev -> dev , "%s: device reported invalid device info\n" , UCAN_DRIVER_NAME ) ; err_firmware_needs_update } if ( ctl_msg_buffer -> cmd_get_device_info . tx_fifo == 0 ) { dev_err ( & udev -> dev , "%s: device reported invalid tx-fifo size\n" , UCAN_DRIVER_NAME ) ; err_firmware_needs_update } netdev = alloc_candev ( sizeof ( ucan_priv ) , ctl_msg_buffer -> cmd_get_device_info . tx_fifo ) ; if ( ! netdev ) { dev_err ( & udev -> dev , "%s: cannot allocate candev\n" , UCAN_DRIVER_NAME ) ; return - ENOMEM ; } up = netdev_priv ( netdev ) ; up -> udev = udev ; up -> netdev = netdev ; up -> intf_index = iface_desc -> desc . bInterfaceNumber ; up -> in_ep_addr = in_ep_addr ; up -> out_ep_addr = out_ep_addr ; up -> in_ep_size = in_ep_size ; up -> ctl_msg_buffer = ctl_msg_buffer ; up -> context_array = NULL ; up -> available_tx_urbs = 0 ; up -> can . state = CAN_STATE_STOPPED ; up -> can . bittiming_const = & up -> device_info . bittiming_const ; up -> can . do_set_bittiming = ucan_set_bittiming ; up -> can . do_set_mode = & ucan_set_mode ; spin_lock_init ( & up -> context_lock ) ; spin_lock_init ( & up -> echo_skb_lock ) ; netdev -> netdev_ops = & ucan_netdev_ops ; netdev -> ethtool_ops = & ucan_ethtool_ops ; usb_set_intfdata ( intf , up ) ; SET_NETDEV_DEV ( netdev , & intf -> dev ) ; ucan_parse_device_info ( up , & ctl_msg_buffer -> cmd_get_device_info ) ; ret = ucan_device_request_in ( up , UCAN_DEVICE_GET_FW_STRING , 0 , sizeof ( ucan_ctl_payload ) ) ; if ( ret > 0 ) { strscpy ( firmware_str , up -> ctl_msg_buffer -> raw , sizeof ( ucan_ctl_payload ) + 1 ) ; } else { strcpy ( firmware_str , "unknown" ) ; } ret = ucan_ctrl_command_out ( up , UCAN_COMMAND_RESET , 0 , 0 ) ; if ( ret < 0 ) { err_free_candev } init_usb_anchor ( & up -> rx_urbs ) ; init_usb_anchor ( & up -> tx_urbs ) ; up -> can . state = CAN_STATE_STOPPED ; ret = register_candev ( netdev ) ; if ( ret ) { err_free_candev } netdev_info ( up -> netdev , "registered device\n" ) ; netdev_info ( up -> netdev , "firmware string: %s\n" , firmware_str ) ; return 0 ; err_free_candev free_candev ( netdev ) ; return ret ; err_firmware_needs_update dev_err ( & udev -> dev , "%s: probe failed; try to update the device firmware\n" , UCAN_DRIVER_NAME ) ; return - ENODEV ; } 