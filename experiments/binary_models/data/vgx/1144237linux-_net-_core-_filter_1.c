BPF_CALL_3 ( , , , , , , ) { const struct ip_tunnel_info * info = skb_tunnel_info ( skb ) ; int err ; if ( unlikely ( ! info || ! ( info -> key . tun_flags & TUNNEL_OPTIONS_PRESENT ) ) ) { err = - ENOENT ; err_clear } if ( unlikely ( size < info -> options_len ) ) { err = - ENOMEM ; err_clear } ip_tunnel_info_opts_get ( to , info ) ; if ( size > info -> options_len ) { memset ( to + info -> options_len , 0 , size - info -> options_len ) ; } return info -> options_len ; err_clear memset ( to , 0 , size ) ; return err ; } static const struct bpf_func_proto bpf_skb_get_tunnel_opt_proto = { . func = bpf_skb_get_tunnel_opt . gpl_only = false . ret_type = RET_INTEGER . arg1_type = ARG_PTR_TO_CTX . arg2_type = ARG_PTR_TO_UNINIT_MEM . arg3_type = ARG_CONST_SIZE } ; static struct metadata_dst __percpu * md_dst ; BPF_CALL_4 ( , , , , , , , , ) { struct metadata_dst * md = this_cpu_ptr ( md_dst ) ; u8 compat [ sizeof ( bpf_tunnel_key ) ] ; struct ip_tunnel_info * info ; if ( unlikely ( flags & ~ ( BPF_F_TUNINFO_IPV6 | BPF_F_ZERO_CSUM_TX | BPF_F_DONT_FRAGMENT | BPF_F_SEQ_NUMBER | BPF_F_NO_TUNNEL_KEY ) ) ) { return - EINVAL ; } if ( unlikely ( size != sizeof ( bpf_tunnel_key ) ) ) { switch ( size ) { case offsetof ( bpf_tunnel_key , local_ipv6 [ 0 ] ) : case offsetof ( bpf_tunnel_key , tunnel_label ) : case offsetof ( bpf_tunnel_key , tunnel_ext ) : case offsetof ( bpf_tunnel_key , remote_ipv6 [ 1 ] ) : memcpy ( compat , from , size ) ; memset ( compat + size , 0 , sizeof ( compat ) - size ) ; from = ( const bpf_tunnel_key * ) compat ; break ; default : return - EINVAL ; } } if ( unlikely ( ( ! ( flags & BPF_F_TUNINFO_IPV6 ) && from -> tunnel_label ) || from -> tunnel_ext ) ) { return - EINVAL ; } skb_dst_drop ( skb , NULL ) ; dst_hold ( ( dst_entry * ) md ) ; skb_dst_set ( skb , ( dst_entry * ) md ) ; info = & md -> u . tun_info ; memset ( info , 0 , sizeof ( * info ) ) ; info -> mode = IP_TUNNEL_INFO_TX ; info -> key . tun_flags = TUNNEL_KEY | TUNNEL_CSUM | TUNNEL_NOCACHE ; if ( flags & BPF_F_DONT_FRAGMENT ) { info -> key . tun_flags |= TUNNEL_DONT_FRAGMENT ; } if ( flags & BPF_F_ZERO_CSUM_TX ) { info -> key . tun_flags &= ~ TUNNEL_CSUM ; } if ( flags & BPF_F_SEQ_NUMBER ) { info -> key . tun_flags |= TUNNEL_SEQ ; } if ( flags & BPF_F_NO_TUNNEL_KEY ) { info -> key . tun_flags &= ~ TUNNEL_KEY ; } info -> key . tun_id = cpu_to_be64 ( from -> tunnel_id ) ; info -> key . tos = from -> tunnel_tos ; info -> key . ttl = from -> tunnel_ttl ; if ( flags & BPF_F_TUNINFO_IPV6 ) { info -> mode |= IP_TUNNEL_INFO_IPV6 ; memcpy ( & info -> key . u . ipv6 . dst , from -> remote_ipv6 , sizeof ( from -> remote_ipv6 ) ) ; memcpy ( & info -> key . u . ipv6 . src , from -> local_ipv6 , sizeof ( from -> local_ipv6 ) ) ; info -> key . label = cpu_to_be32 ( from -> tunnel_label ) & IPV6_FLOWLABEL_MASK ; } else { info -> key . u . ipv4 . dst = cpu_to_be32 ( from -> remote_ipv4 ) ; info -> key . u . ipv4 . src = cpu_to_be32 ( from -> local_ipv4 ) ; info -> key . flow_flags = FLOWI_FLAG_ANYSRC ; } return 0 ; } 