static void * zend_ffi_create_callback ( zend_ffi_type * type , zval * value ) { zend_fcall_info_cache fcc ; char * error = NULL ; uint32_t arg_count ; void * code ; void * callback ; zend_ffi_callback_data * callback_data ; if ( type -> attr & ZEND_FFI_ATTR_VARIADIC ) { zend_throw_error ( zend_ffi_exception_ce , "Variadic function closures are not supported" ) ; return NULL ; } if ( ! zend_is_callable_ex ( value , NULL , 0 , NULL , & fcc , & error ) ) { zend_throw_error ( zend_ffi_exception_ce , "Attempt to assign an invalid callback, %s" , error ) ; return NULL ; } arg_count = type -> func . args ?zend_hash_num_elements ( type -> func . args ) : 0 ; if ( arg_count < fcc . function_handler -> common . required_num_args ) { zend_throw_error ( zend_ffi_exception_ce , "Attempt to assign an invalid callback, insufficient number of arguments" ) ; return NULL ; } callback = ffi_closure_alloc ( sizeof ( ffi_closure ) , & code ) ; if ( ! callback ) { zend_throw_error ( zend_ffi_exception_ce , "Cannot allocate callback" ) ; return NULL ; } callback_data = emalloc ( sizeof ( zend_ffi_callback_data ) + sizeof ( ffi_type * ) * arg_count ) ; memcpy ( & callback_data -> fcc , & fcc , sizeof ( zend_fcall_info_cache ) ) ; callback_data -> type = type ; callback_data -> callback = callback ; callback_data -> code = code ; callback_data -> arg_count = arg_count ; if ( type -> func . args ) { int n = 0 ; zend_ffi_type * arg_type ; ZEND_HASH_PACKED_FOREACH_PTR ( , ) { arg_type = ZEND_FFI_TYPE ( arg_type ) ; callback_data -> arg_types [ n ] = zend_ffi_get_type ( arg_type ) ; if ( ! callback_data -> arg_types [ n ] ) { zend_ffi_pass_unsupported ( arg_type ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( callback_data -> arg_types [ i ] -> type == FFI_TYPE_STRUCT ) { efree ( callback_data -> arg_types [ i ] ) ; } } ffi_closure_free ( callback ) ; return NULL ; } n ++ ; } ZEND_HASH_FOREACH_END ( ) ; } callback_data -> ret_type = zend_ffi_get_type ( ZEND_FFI_TYPE ( type -> func . ret_type ) ) ; if ( ! callback_data -> ret_type ) { zend_ffi_return_unsupported ( type -> func . ret_type ) ; for ( int i = 0 ; i < callback_data -> arg_count ; ++ i ) { if ( callback_data -> arg_types [ i ] -> type == FFI_TYPE_STRUCT ) { efree ( callback_data -> arg_types [ i ] ) ; } } efree ( callback_data ) ; ffi_closure_free ( callback ) ; return NULL ; } if ( ffi_prep_cif ( & callback_data -> cif , type -> func . abi , callback_data -> arg_count , callback_data -> ret_type , callback_data -> arg_types ) != FFI_OK ) { zend_throw_error ( zend_ffi_exception_ce , "Cannot prepare callback CIF" ) ; free_on_failure } if ( ffi_prep_closure_loc ( callback , & callback_data -> cif , zend_ffi_callback_trampoline , callback_data , code ) != FFI_OK ) { zend_throw_error ( zend_ffi_exception_ce , "Cannot prepare callback" ) ; free_on_failure for ( int i = 0 ; i < callback_data -> arg_count ; ++ i ) { if ( callback_data -> arg_types [ i ] -> type == FFI_TYPE_STRUCT ) { efree ( callback_data -> arg_types [ i ] ) ; } } if ( callback_data -> ret_type -> type == FFI_TYPE_STRUCT ) { efree ( callback_data -> ret_type ) ; } efree ( callback_data ) ; ffi_closure_free ( callback ) ; return NULL ; } if ( ! FFI_G ( callbacks ) ) { FFI_G ( callbacks ) = emalloc ( sizeof ( HashTable ) ) ; zend_hash_init ( FFI_G ( callbacks ) , 0 , NULL , zend_ffi_callback_hash_dtor , 0 ) ; } zend_hash_next_index_insert_ptr ( FFI_G ( callbacks ) , callback_data ) ; if ( fcc . function_handler -> common . fn_flags & ZEND_ACC_CLOSURE ) { GC_ADDREF ( ZEND_CLOSURE_OBJECT ( fcc . function_handler ) ) ; } return code ; } 