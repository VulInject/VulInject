static krb5_error_code get_credentials ( context , cred , server , now , endtime , out_creds ) krb5_context context ; krb5_gss_cred_id_t cred ; krb5_gss_name_t server ; krb5_timestamp now ; krb5_timestamp endtime ; krb5_creds * * out_creds ; { krb5_error_code code ; krb5_creds in_creds , evidence_creds , mcreds , * result_creds = NULL ; krb5_flags flags = 0 ; krb5_principal_data server_data ; * out_creds = NULL ; k5_mutex_assert_locked ( & cred -> lock ) ; memset ( & evidence_creds , 0 , sizeof ( krb5_creds ) ) ; in_creds . client = in_creds . server = NULL ; assert ( cred -> name != NULL ) ; server_data = * server -> princ ; if ( cred -> impersonator != NULL && server_data . type == KRB5_NT_SRV_HST ) { server_data . realm = empty_data ( ) ; } in_creds . server = & server_data ; in_creds . client = cred -> name -> princ ; in_creds . times . endtime = endtime ; in_creds . authdata = NULL ; in_creds . keyblock . enctype = 0 ; if ( cred -> name -> ad_context != NULL ) { code = krb5_authdata_export_authdata ( context , cred -> name -> ad_context , AD_USAGE_TGS_REQ , & in_creds . authdata ) ; if ( code != 0 ) { cleanup } } if ( cred -> impersonator != NULL ) { if ( krb5_principal_compare ( context , cred -> impersonator , server -> princ ) ) { flags |= KRB5_GC_CACHED ; } else { memset ( & mcreds , 0 , sizeof ( mcreds ) ) ; mcreds . magic = KV5M_CREDS ; mcreds . server = cred -> impersonator ; mcreds . client = cred -> name -> princ ; code = krb5_cc_retrieve_cred ( context , cred -> ccache , KRB5_TC_MATCH_AUTHDATA , & mcreds , & evidence_creds ) ; if ( code ) { cleanup } in_creds . client = cred -> impersonator ; in_creds . second_ticket = evidence_creds . ticket ; flags = KRB5_GC_CANONICALIZE | KRB5_GC_CONSTRAINED_DELEGATION ; } } if ( cred -> iakerb_mech ) { flags |= KRB5_GC_CACHED ; } code = krb5_get_credentials ( context , flags , cred -> ccache , & in_creds , & result_creds ) ; if ( code ) { cleanup } if ( flags & KRB5_GC_CONSTRAINED_DELEGATION ) { if ( ! krb5_principal_compare ( context , cred -> name -> princ , result_creds -> client ) ) { code = KRB5_KDCREP_MODIFIED ; cleanup } } if ( ! krb5_gss_dbg_client_expcreds && ts_after ( now , result_creds -> times . endtime ) ) { code = KRB5KRB_AP_ERR_TKT_EXPIRED ; cleanup } * out_creds = result_creds ; result_creds = NULL ; cleanup krb5_free_authdata ( context , in_creds . authdata ) ; krb5_free_cred_contents ( context , & evidence_creds ) ; krb5_free_creds ( context , result_creds ) ; return code ; } 