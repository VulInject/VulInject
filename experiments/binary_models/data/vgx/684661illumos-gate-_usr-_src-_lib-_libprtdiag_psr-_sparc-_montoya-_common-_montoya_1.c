static int montoya_hw_rev_callback ( picl_nodehdl_t pcih , void * args ) { int err = PICL_SUCCESS ; char path [ MAXSTRLEN ] "" ; ; char device_path [ MAXSTRLEN ] ; char NAC [ MAXSTRLEN ] ; char * compatible ; int32_t revision ; int device_found ; err = picl_get_propval_by_name ( pcih , PICL_PROP_DEVFS_PATH , path , sizeof ( path ) ) ; if ( err != PICL_SUCCESS ) { return ( err ) ; } if ( ( strncmp ( path , NETWORK_0_PATH , strlen ( NETWORK_0_PATH ) ) == 0 ) || ( strncmp ( path , NETWORK_1_PATH , strlen ( NETWORK_1_PATH ) ) == 0 ) ) { device_found = 1 ; ( void ) snprintf ( NAC , sizeof ( NAC ) , "%s/%s%d" , MOTHERBOARD , OPHIR , 0 ) ; revision = montoya_get_int_propval ( pcih , OBP_PROP_REVISION_ID , & err ) ; } if ( ( strncmp ( path , NETWORK_2_PATH , strlen ( NETWORK_2_PATH ) ) == 0 ) || ( strncmp ( path , NETWORK_3_PATH , strlen ( NETWORK_3_PATH ) ) == 0 ) ) { device_found = 1 ; ( void ) snprintf ( NAC , sizeof ( NAC ) , "%s/%s%d" , MOTHERBOARD , OPHIR , 1 ) ; revision = montoya_get_int_propval ( pcih , OBP_PROP_REVISION_ID , & err ) ; } if ( ( strcmp ( path , FIRE_PATHB ) == 0 ) || ( strcmp ( path , FIRE_PATHA ) == 0 ) ) { device_found = 1 ; ( void ) snprintf ( NAC , sizeof ( NAC ) , "%s/%s" , MOTHERBOARD , PCI_BRIDGE ) ; revision = montoya_get_int_propval ( pcih , OBP_PROP_VERSION_NUM , & err ) ; } if ( strcmp ( path , SWITCH_PATH ) == 0 ) { device_found = 1 ; ( void ) snprintf ( NAC , sizeof ( NAC ) , "%s/%s" , MOTHERBOARD , SWITCH_A ) ; revision = montoya_get_int_propval ( pcih , OBP_PROP_REVISION_ID , & err ) ; } if ( strcmp ( path , SATA_DISK_PATH ) == 0 ) { device_found = 1 ; ( void ) snprintf ( NAC , sizeof ( NAC ) , "%s/%s" , RTM , SATA_HBA ) ; revision = montoya_get_int_propval ( pcih , OBP_PROP_REVISION_ID , & err ) ; } if ( strcmp ( path , RTM_PCI_PATH ) == 0 ) { device_found = 1 ; ( void ) snprintf ( NAC , sizeof ( NAC ) , "%s/%s" , RTM , AMC ) ; revision = montoya_get_int_propval ( pcih , OBP_PROP_REVISION_ID , & err ) ; } if ( device_found == 1 ) { ( void ) strcpy ( device_path , path ) ; err = montoya_get_first_compatible_value ( pcih , & compatible ) ; log_printf ( "%-20s" , NAC ) ; if ( strlen ( device_path ) > 38 ) { log_printf ( "%38.37s+" , device_path ) ; } else { log_printf ( "%39s" , device_path ) ; } if ( err == PICL_SUCCESS ) { log_printf ( "%31s" , compatible ) ; free ( compatible ) ; } else { log_printf ( "%31s" , " " ) ; } log_printf ( "%6d" , revision ) ; log_printf ( "\n" ) ; } return ( PICL_WALK_CONTINUE ) ; } 