static ssize_t M_str_fmt_add_bytes ( M_str_fmt_t * data , const unsigned char * b , size_t len ) { size_t tlen ; size_t wrote_len ; tlen = len ; switch ( data -> endpoint ) { case M_STR_FMT_ENDPOINT_STREAM : if ( fwrite ( b , 1 , tlen , data -> o . stream ) != tlen ) { return - 1 ; } break ; case M_STR_FMT_ENDPOINT_MFD : if ( M_fs_file_write ( data -> o . mfd , b , len , & wrote_len , M_FS_FILE_RW_FULLBUF ) != M_FS_ERROR_SUCCESS || wrote_len != len ) { return - 1 ; } break ; case M_STR_FMT_ENDPOINT_FD : if ( data -> o . file . len + tlen >= M_STR_FMT_WRITE_BUF_LEN ) { if ( write ( data -> o . file . fd , data -> o . file . write_buf , data -> o . file . len ) != ( ssize_t ) data -> o . file . len ) { return - 1 ; } data -> o . file . len = 0 ; while ( tlen > M_STR_FMT_WRITE_BUF_LEN ) { if ( write ( data -> o . file . fd , b , M_STR_FMT_WRITE_BUF_LEN ) != M_STR_FMT_WRITE_BUF_LEN ) { return - 1 ; } b += M_STR_FMT_WRITE_BUF_LEN ; tlen -= M_STR_FMT_WRITE_BUF_LEN ; } } if ( tlen > 0 ) { M_mem_copy ( data -> o . file . write_buf + data -> o . file . len , b , tlen ) ; data -> o . file . len += tlen ; } break ; case M_STR_FMT_ENDPOINT_SBUF : if ( data -> o . sbuf . buf == NULL || data -> o . sbuf . len == 0 ) { break ; } if ( tlen > data -> o . sbuf . len - data -> o . sbuf . pos - 1 ) { tlen = data -> o . sbuf . len - data -> o . sbuf . pos - 1 ; } if ( tlen != 0 ) { M_mem_copy ( data -> o . sbuf . buf + data -> o . sbuf . pos , b , tlen ) ; data -> o . sbuf . pos += tlen ; } break ; case M_STR_FMT_ENDPOINT_MBUF : if ( data -> o . mbuf == NULL ) { break ; } M_buf_add_bytes ( data -> o . mbuf , b , tlen ) ; break ; } return ( ssize_t ) len ; } 