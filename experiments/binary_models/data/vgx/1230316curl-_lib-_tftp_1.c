static CURLcode tftp_connect ( struct Curl_easy * data , bool * done ) { struct tftp_state_data * state ; int blksize ; int need_blksize ; struct connectdata * conn = data -> conn ; blksize = TFTP_BLKSIZE_DEFAULT ; state = conn -> proto . tftpc = calloc ( 1 , sizeof ( tftp_state_data ) ) ; if ( ! state ) { return CURLE_OUT_OF_MEMORY ; } if ( data -> set . tftp_blksize ) { blksize = ( int ) data -> set . tftp_blksize ; } need_blksize = blksize ; if ( need_blksize < TFTP_BLKSIZE_DEFAULT ) { need_blksize = TFTP_BLKSIZE_DEFAULT ; } if ( ! state -> rpacket . data ) { state -> rpacket . data = calloc ( 1 , need_blksize + 2 + 2 ) ; if ( ! state -> rpacket . data ) { return CURLE_OUT_OF_MEMORY ; } } if ( ! state -> spacket . data ) { state -> spacket . data = calloc ( 1 , need_blksize + 2 + 2 ) ; if ( ! state -> spacket . data ) { return CURLE_OUT_OF_MEMORY ; } } connclose ( conn , "TFTP" ) ; state -> data = data ; state -> sockfd = conn -> sock [ FIRSTSOCKET ] ; state -> state = TFTP_STATE_START ; state -> error = TFTP_ERR_NONE ; state -> blksize = TFTP_BLKSIZE_DEFAULT ; state -> requested_blksize = blksize ; ( ( sockaddr * ) & state -> local_addr ) -> sa_family = ( CURL_SA_FAMILY_T ) ( conn -> remote_addr -> family ) ; tftp_set_timeouts ( state ) ; if ( ! conn -> bits . bound ) { int rc = bind ( state -> sockfd , ( sockaddr * ) & state -> local_addr , conn -> remote_addr -> addrlen ) ; if ( rc ) { char buffer [ STRERROR_LEN ] ; failf ( data , "bind() failed; %s" , Curl_strerror ( SOCKERRNO , buffer , sizeof ( buffer ) ) ) ; return CURLE_COULDNT_CONNECT ; } conn -> bits . bound = TRUE ; } Curl_pgrsStartNow ( data ) ; * done = TRUE ; return CURLE_OK ; } 