R_API char * r_punycode_encode ( const ut8 * src , int srclen , int * dstlen ) { ut32 m , n ; ut32 b , h ; ut32 si , di ; ut32 delta , bias ; ut32 * actualsrc = NULL ; ut32 len = 0 ; char * dst = NULL ; * dstlen = 0 ; if ( ! src || srclen < 1 ) { return NULL ; } actualsrc = utf8toutf32 ( src ) ; if ( ! actualsrc ) { return NULL ; } len = utf32len ( actualsrc ) ; dst = calloc ( 2 * len + 10 , 1 ) ; if ( ! dst ) { return NULL ; } for ( si = 0 , di = 0 ; si < len ; si ++ ) { if ( actualsrc [ si ] < 128 ) { dst [ di ++ ] = actualsrc [ si ] ; } } b = h = di ; if ( di > 0 ) { dst [ di ++ ] = '-' ; } n = INITIAL_N ; bias = INITIAL_BIAS ; for ( delta = 0 ; h < len ; n ++ , delta ++ ) { for ( m = UT32_MAX , si = 0 ; si < len ; si ++ ) { if ( actualsrc [ si ] >= n && actualsrc [ si ] < m ) { m = actualsrc [ si ] ; } } if ( ( m - n ) > ( UT32_MAX - delta ) / ( h + 1 ) ) { free ( actualsrc ) ; free ( dst ) ; return NULL ; } delta += ( m - n ) * ( h + 1 ) ; n = m ; for ( si = 0 ; si < len ; si ++ ) { if ( actualsrc [ si ] < n ) { if ( ++ delta == 0 ) { free ( actualsrc ) ; free ( dst ) ; return NULL ; } } if ( actualsrc [ si ] == n ) { di += encode_var_int ( bias , delta , & dst [ di ] ) ; bias = adapt_bias ( delta , h + 1 , h == b ) ; delta = 0 ; h ++ ; } } } * dstlen = di ; free ( actualsrc ) ; return dst ; } 