JUDYLCODE ( ) JUDYLCODE ( ) switch ( JU_JPTYPE ( Pjp ) ) { case cJU_JPLEAF_B1 : { Pjlb_t Pjlb = P_JLB ( Pjp -> jp_Addr ) ; Word_t Digit ; JUDYLCODE ( ) Pop1 = JU_JPBRANCH_POP0 ( Pjp , 1 ) + 1 ; for ( Digit = 0 ; Digit < cJU_BRANCHUNUMJPS ; ++ Digit ) { if ( JU_BITMAPTESTL ( Pjlb , Digit ) ) { * PLeaf2 ++ = MSByte | Digit ; } } for ( SubExp = 0 ; SubExp < cJU_NUMSUBEXPL ; ++ SubExp ) { Word_t SubExpPop1 ; Pjv1Raw = JL_JLB_PVALUE ( Pjlb , SubExp ) ; if ( Pjv1Raw == ( Pjv_t ) NULL ) { continue ; } Pjv1 = P_JV ( Pjv1Raw ) ; SubExpPop1 = j__udyCountBitsL ( JU_JLB_BITMAP ( Pjlb , SubExp ) ) ; assert ( SubExpPop1 ) ; JU_COPYMEM ( Pjv2 , Pjv1 , SubExpPop1 ) ; j__udyLFreeJV ( Pjv1Raw , SubExpPop1 , Pjpm ) ; Pjv2 += SubExpPop1 ; } j__udyFreeJLB1 ( ( Pjlb_t ) ( Pjp -> jp_Addr ) , Pjpm ) ; return ( Pop1 ) ; } case cJU_JPLEAF1 : { uint8_t * PLeaf1 = ( uint8_t * ) P_JLL ( Pjp -> jp_Addr ) ; Pop1 = JU_JPBRANCH_POP0 ( Pjp , 1 ) + 1 ; assert ( Pop1 ) ; JUDYLCODE ( ) for ( Offset = 0 ; Offset < Pop1 ; ++ Offset ) { PLeaf2 [ Offset ] = MSByte | PLeaf1 [ Offset ] ; JUDYLCODE ( ) } j__udyFreeJLL1 ( ( Pjll_t ) ( Pjp -> jp_Addr ) , Pop1 , Pjpm ) ; return ( Pop1 ) ; } case cJU_JPIMMED_1_01 : { PLeaf2 [ 0 ] = JU_JPDCDPOP0 ( Pjp ) ; JUDYLCODE ( 0 ) return ( 1 ) ; } case cJU_JPIMMED_1_02 : case cJU_JPIMMED_1_03 : case cJU_JPIMMED_1_04 : case cJU_JPIMMED_1_05 : case cJU_JPIMMED_1_06 : case cJU_JPIMMED_1_07 : case cJ1_JPIMMED_1_08 : case cJ1_JPIMMED_1_09 : case cJ1_JPIMMED_1_10 : case cJ1_JPIMMED_1_11 : case cJ1_JPIMMED_1_12 : case cJ1_JPIMMED_1_13 : case cJ1_JPIMMED_1_14 : case cJ1_JPIMMED_1_15 : { Pop1 = JU_JPTYPE ( Pjp ) - cJU_JPIMMED_1_02 + 2 ; assert ( Pop1 ) ; JUDYLCODE ( ) JUDYLCODE ( ) for ( Offset = 0 ; Offset < Pop1 ; ++ Offset ) { PLeaf2 [ Offset ] = MSByte | Pjp -> jp_1Index [ Offset ] ; PLeaf2 [ Offset ] = MSByte | Pjp -> jp_LIndex [ Offset ] ; Pjv2 [ Offset ] = Pjv1 [ Offset ] ; } JUDYLCODE ( ) return ( Pop1 ) ; } default : assert ( FALSE ) ; break ; } return ( 0 ) ; 