ppc_elf_tls_optimize ( , ) { bfd * ibfd ; asection * sec ; struct ppc_elf_link_hash_table * htab ; if ( info -> relocatable || info -> shared ) { return TRUE ; } htab = ppc_elf_hash_table ( info ) ; for ( ibfd = info -> input_bfds ; ibfd != NULL ; ibfd = ibfd -> link_next ) { Elf_Internal_Sym * locsyms = NULL ; Elf_Internal_Shdr * symtab_hdr = & elf_tdata ( ibfd ) -> symtab_hdr ; for ( sec = ibfd -> sections ; sec != NULL ; sec = sec -> next ) { if ( sec -> has_tls_reloc && ! bfd_is_abs_section ( sec -> output_section ) ) { Elf_Internal_Rela * relstart , * rel , * relend ; int expecting_tls_get_addr ; relstart = _bfd_elf_link_read_relocs ( ibfd , sec , NULL , NULL , info -> keep_memory ) ; if ( relstart == NULL ) { return FALSE ; } expecting_tls_get_addr = 0 ; relend = relstart + sec -> reloc_count ; for ( rel = relstart ; rel < relend ; rel ++ ) { enum elf_ppc_reloc_type r_type ; cfs_time_t r_symndx ; struct elf_link_hash_entry * h = NULL ; char * tls_mask ; char tls_set , tls_clear ; bfd_boolean is_local ; r_symndx = ELF32_R_SYM ( rel -> r_info ) ; if ( r_symndx >= symtab_hdr -> sh_info ) { struct elf_link_hash_entry * * sym_hashes ; sym_hashes = elf_sym_hashes ( ibfd ) ; h = sym_hashes [ r_symndx - symtab_hdr -> sh_info ] ; while ( h -> root . type == bfd_link_hash_indirect || h -> root . type == bfd_link_hash_warning ) { h = ( elf_link_hash_entry * ) h -> root . u . i . link ; } } is_local = FALSE ; if ( h == NULL || ! ( h -> elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC ) ) { is_local = TRUE ; } r_type = ELF32_R_TYPE ( rel -> r_info ) ; switch ( r_type ) { case R_PPC_GOT_TLSLD16 : case R_PPC_GOT_TLSLD16_LO : case R_PPC_GOT_TLSLD16_HI : case R_PPC_GOT_TLSLD16_HA : expecting_tls_get_addr = 0 ; htab -> tlsld_got . refcount -= 1 ; if ( ! is_local ) { continue ; } tls_set = 0 ; tls_clear = TLS_LD ; expecting_tls_get_addr = 1 ; break ; case R_PPC_GOT_TLSGD16 : case R_PPC_GOT_TLSGD16_LO : case R_PPC_GOT_TLSGD16_HI : case R_PPC_GOT_TLSGD16_HA : if ( is_local ) { tls_set = 0 ; } else { tls_set = TLS_TLS | TLS_TPRELGD ; } tls_clear = TLS_GD ; expecting_tls_get_addr = 1 ; break ; case R_PPC_GOT_TPREL16 : case R_PPC_GOT_TPREL16_LO : case R_PPC_GOT_TPREL16_HI : case R_PPC_GOT_TPREL16_HA : expecting_tls_get_addr = 0 ; if ( is_local ) { tls_set = 0 ; tls_clear = TLS_TPREL ; break ; } else { continue ; } case R_PPC_REL14 : case R_PPC_REL14_BRTAKEN : case R_PPC_REL14_BRNTAKEN : case R_PPC_REL24 : if ( expecting_tls_get_addr && h != NULL && h == htab -> tls_get_addr ) { if ( h -> plt . refcount > 0 ) { h -> plt . refcount -= 1 ; } } expecting_tls_get_addr = 0 ; continue ; default : expecting_tls_get_addr = 0 ; continue ; } if ( h != NULL ) { if ( tls_set == 0 ) { if ( h -> got . refcount > 0 ) { h -> got . refcount -= 1 ; } } tls_mask = & ppc_elf_hash_entry ( h ) -> tls_mask ; } else { Elf_Internal_Sym * sym ; bfd_signed_vma * lgot_refs ; char * lgot_masks ; if ( locsyms == NULL ) { locsyms = ( Elf_Internal_Sym * ) symtab_hdr -> contents ; if ( locsyms == NULL ) { locsyms = bfd_elf_get_elf_syms ( ibfd , symtab_hdr , symtab_hdr -> sh_info , 0 , NULL , NULL , NULL ) ; } if ( locsyms == NULL ) { if ( elf_section_data ( sec ) -> relocs != relstart ) { free ( relstart ) ; } return FALSE ; } } sym = locsyms + r_symndx ; lgot_refs = elf_local_got_refcounts ( ibfd ) ; if ( lgot_refs == NULL ) { abort ( ) ; } if ( tls_set == 0 ) { if ( lgot_refs [ r_symndx ] > 0 ) { lgot_refs [ r_symndx ] -= 1 ; } } lgot_masks = ( char * ) ( lgot_refs + symtab_hdr -> sh_info ) ; tls_mask = & lgot_masks [ r_symndx ] ; } * tls_mask |= tls_set ; * tls_mask &= ~ tls_clear ; } if ( elf_section_data ( sec ) -> relocs != relstart ) { free ( relstart ) ; } } } if ( locsyms != NULL && ( symtab_hdr -> contents != ( unsigned char * ) locsyms ) ) { if ( ! info -> keep_memory ) { free ( locsyms ) ; } else { symtab_hdr -> contents = ( unsigned char * ) locsyms ; } } } return TRUE ; } 