LockRowsState * ExecInitLockRows ( LockRows * node , EState * estate , int eflags ) { LockRowsState * lrstate ; Plan * outerPlan = outerPlan ( node ) ; List * epq_arowmarks ; ListCell * lc ; Assert ( ! ( eflags & EXEC_FLAG_MARK ) ) ; lrstate = makeNode ( LockRowsState ) ; lrstate -> ps . plan = ( Plan * ) node ; lrstate -> ps . state = estate ; lrstate -> ps . ExecProcNode = ExecLockRows ; ExecInitResultTypeTL ( & lrstate -> ps ) ; outerPlanState ( lrstate ) = ExecInitNode ( outerPlan , estate , eflags ) ; lrstate -> ps . resultopsset = true ; lrstate -> ps . resultops = ExecGetResultSlotOps ( outerPlanState ( lrstate ) , & lrstate -> ps . resultopsfixed ) ; lrstate -> lr_arowMarks = NIL ; epq_arowmarks = NIL ; ( lc node -> rowMarks ; ) { PlanRowMark * rc = lfirst_node ( PlanRowMark , lc ) ; ExecRowMark * erm ; ExecAuxRowMark * aerm ; if ( rc -> isParent ) { continue ; } erm = ExecFindRowMark ( estate , rc -> rti , false ) ; aerm = ExecBuildAuxRowMark ( erm , outerPlan -> targetlist ) ; if ( RowMarkRequiresRowShareLock ( erm -> markType ) ) { lrstate -> lr_arowMarks = lappend ( lrstate -> lr_arowMarks , aerm ) ; } else { epq_arowmarks = lappend ( epq_arowmarks , aerm ) ; } } EvalPlanQualInit ( & lrstate -> lr_epqstate , estate , outerPlan , epq_arowmarks , node -> epqParam ) ; return lrstate ; } 