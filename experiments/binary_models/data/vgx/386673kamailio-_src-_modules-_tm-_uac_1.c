int ack_local_uac ( struct cell * trans , str * hdrs , str * body ) { struct retr_buf * local_ack , * old_lack ; int ret ; struct tmcb_params onsend_params ; if ( ! trans ) { LM_BUG ( "no transaction to ACK.\n" ) ; abort ( ) ; } ret = - 2 ; fin is_local trans } { LM_ERR ( "trying to ACK non local transaction (T@%p).\n" , trans ) ; RET_INVALID ; } if ( ! is_invite ( trans ) ) { LM_ERR ( "trying to ACK non INVITE local transaction (T@%p).\n" , trans ) ; RET_INVALID ; } if ( ! trans -> uac [ 0 ] . reply ) { LM_ERR ( "trying to ACK un-completed INVITE transaction (T@%p).\n" , trans ) ; RET_INVALID ; } if ( ! ( trans -> flags & T_NO_AUTO_ACK ) ) { LM_ERR ( "trying to ACK an auto-ACK transaction (T@%p).\n" , trans ) ; RET_INVALID ; } if ( trans -> uac [ 0 ] . local_ack ) { LM_ERR ( "trying to rebuild ACK retransmission buffer (T@%p).\n" , trans ) ; RET_INVALID ; } if ( ! ( local_ack = local_ack_rb ( trans -> uac [ 0 ] . reply , trans , 0 , hdrs , body ) ) ) { LM_ERR ( "failed to build ACK retransmission buffer\n" ) ; RET_INVALID ; } else { if ( ( old_lack = ( retr_buf * ) atomic_cmpxchg_long ( ( void * ) & trans -> uac [ 0 ] . local_ack , 0 , ( long ) local_ack ) ) ) { LM_ERR ( "concurrent ACKing for local INVITE detected (T@%p).\n" , trans ) ; free_local_ack ( local_ack ) ; RET_INVALID ; } } if ( msg_send ( & local_ack -> dst , local_ack -> buffer , local_ack -> buffer_len ) < 0 ) { LM_ERR ( "failed to send local ACK (T@%p).\n" , trans ) ; ret = - 1 ; fin } else { INIT_TMCB_ONSEND_PARAMS ( onsend_params , 0 , 0 , & trans -> uac [ 0 ] . request , & local_ack -> dst , local_ack -> buffer , local_ack -> buffer_len , TMCB_LOCAL_F , 0 , TYPE_LOCAL_ACK ) ; run_trans_callbacks_off_params ( TMCB_REQUEST_SENT , trans , & onsend_params ) ; } fin UNREF ( trans ) ; return ret ; 