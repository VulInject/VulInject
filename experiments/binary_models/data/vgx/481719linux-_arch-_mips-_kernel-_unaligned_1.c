asmlinkage void do_ade ( struct pt_regs * regs ) { enum ctx_state prev_state ; unsigned int * pc ; prev_state = exception_enter ( ) ; perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , regs -> cp0_badvaddr ) ; if ( ( regs -> cp0_badvaddr >= ( 1UL << cpu_vmbits ) ) && ( regs -> cp0_badvaddr < XKSSEG ) ) { if ( fixup_exception ( regs ) ) { current -> thread . cp0_baduaddr = regs -> cp0_badvaddr ; return ; } sigbus } if ( regs -> cp0_badvaddr == regs -> cp0_epc ) { sigbus } if ( user_mode ( regs ) && ! test_thread_flag ( TIF_FIXADE ) ) { sigbus } if ( unaligned_action == UNALIGNED_ACTION_SIGNAL ) { sigbus } if ( get_isa16_mode ( regs -> cp0_epc ) ) { if ( regs -> cp0_badvaddr == msk_isa16_mode ( regs -> cp0_epc ) ) { sigbus } if ( unaligned_action == UNALIGNED_ACTION_SHOW ) { show_registers ( regs ) ; } if ( cpu_has_mmips ) { emulate_load_store_microMIPS ( regs , ( void __user * ) regs -> cp0_badvaddr ) ; return ; } if ( cpu_has_mips16 ) { emulate_load_store_MIPS16e ( regs , ( void __user * ) regs -> cp0_badvaddr ) ; return ; } sigbus } if ( unaligned_action == UNALIGNED_ACTION_SHOW ) { show_registers ( regs ) ; } pc = ( unsigned int * ) exception_epc ( regs ) ; emulate_load_store_insn ( regs , ( void __user * ) regs -> cp0_badvaddr , pc ) ; return ; sigbus die_if_kernel ( "Kernel unaligned instruction access" , regs ) ; force_sig ( SIGBUS ) ; exception_exit ( prev_state ) ; } 