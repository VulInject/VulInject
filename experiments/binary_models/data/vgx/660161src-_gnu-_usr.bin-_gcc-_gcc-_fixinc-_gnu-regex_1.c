re_compile_fastmap ( ) struct re_pattern_buffer * bufp ; { int j , k ; fail_stack_type fail_stack ; char * destination ; register char * fastmap = bufp -> fastmap ; unsigned char * pattern = bufp -> buffer ; unsigned char * p = pattern ; register unsigned char * pend = pattern + bufp -> used ; fail_stack_elt_t * failure_stack_ptr ; boolean path_can_be_null = true ; boolean succeed_n_p = false ; assert ( fastmap != NULL && p != NULL ) ; INIT_FAIL_STACK ( ) ; bzero ( fastmap , 1 << BYTEWIDTH ) ; bufp -> can_be_null = 0 ; while ( 1 ) { if ( p == pend || * p == succeed ) { if ( ! FAIL_STACK_EMPTY ( ) ) { bufp -> can_be_null |= path_can_be_null ; path_can_be_null = true ; p = fail_stack . stack [ -- fail_stack . avail ] . pointer ; continue ; } else { break ; } } assert ( p < pend ) ; switch ( SWITCH_ENUM_CAST ( ( re_opcode_t ) * p ++ ) ) { case duplicate : bufp -> can_be_null = 1 ; done case exactn : fastmap [ p [ 1 ] ] = 1 ; break ; case charset : for ( j = * p ++ * BYTEWIDTH - 1 ; j >= 0 ; j -- ) { if ( p [ j / BYTEWIDTH ] & ( 1 << ( j % BYTEWIDTH ) ) ) { fastmap [ j ] = 1 ; } } break ; case charset_not : for ( j = * p * BYTEWIDTH ; j < ( 1 << BYTEWIDTH ) ; j ++ ) { fastmap [ j ] = 1 ; } for ( j = * p ++ * BYTEWIDTH - 1 ; j >= 0 ; j -- ) { if ( ! ( p [ j / BYTEWIDTH ] & ( 1 << ( j % BYTEWIDTH ) ) ) ) { fastmap [ j ] = 1 ; } } break ; case wordchar : for ( j = 0 ; j < ( 1 << BYTEWIDTH ) ; j ++ ) { if ( SYNTAX ( j ) == Sword ) { fastmap [ j ] = 1 ; } } break ; case notwordchar : for ( j = 0 ; j < ( 1 << BYTEWIDTH ) ; j ++ ) { if ( SYNTAX ( j ) != Sword ) { fastmap [ j ] = 1 ; } } break ; case anychar : { int fastmap_newline = fastmap [ '\n' ] ; for ( j = 0 ; j < ( 1 << BYTEWIDTH ) ; j ++ ) { fastmap [ j ] = 1 ; } if ( ! ( bufp -> syntax & RE_DOT_NEWLINE ) ) { fastmap [ '\n' ] = fastmap_newline ; } if ( bufp -> can_be_null ) { done } break ; } case syntaxspec : k = * p ++ ; for ( j = 0 ; j < ( 1 << BYTEWIDTH ) ; j ++ ) { if ( SYNTAX ( j ) == ( syntaxcode ) k ) { fastmap [ j ] = 1 ; } } break ; case notsyntaxspec : k = * p ++ ; for ( j = 0 ; j < ( 1 << BYTEWIDTH ) ; j ++ ) { if ( SYNTAX ( j ) != ( syntaxcode ) k ) { fastmap [ j ] = 1 ; } } break ; case before_dot : case at_dot : case after_dot : continue ; case no_op : case begline : case endline : case begbuf : case endbuf : case wordbound : case notwordbound : case wordbeg : case wordend : case push_dummy_failure : continue ; case jump_n : case pop_failure_jump : case maybe_pop_jump : case jump : case jump_past_alt : case dummy_failure_jump : EXTRACT_NUMBER_AND_INCR ( j , p ) ; p += j ; if ( j > 0 ) { continue ; } if ( ( re_opcode_t ) * p != on_failure_jump && ( re_opcode_t ) * p != succeed_n ) { continue ; } p ++ ; EXTRACT_NUMBER_AND_INCR ( j , p ) ; p += j ; if ( ! FAIL_STACK_EMPTY ( ) && fail_stack . stack [ fail_stack . avail - 1 ] . pointer == p ) { fail_stack . avail -- ; } continue ; case on_failure_jump : case on_failure_keep_string_jump : handle_on_failure_jump EXTRACT_NUMBER_AND_INCR ( j , p ) ; if ( p + j < pend ) { if ( ! PUSH_PATTERN_OP ( p + j , fail_stack ) ) { RESET_FAIL_STACK ( ) ; return - 2 ; } } else { bufp -> can_be_null = 1 ; } if ( succeed_n_p ) { EXTRACT_NUMBER_AND_INCR ( k , p ) ; succeed_n_p = false ; } continue ; case succeed_n : p += 2 ; EXTRACT_NUMBER_AND_INCR ( k , p ) ; if ( k == 0 ) { p -= 4 ; succeed_n_p = true ; handle_on_failure_jump } continue ; case set_number_at : p += 4 ; continue ; case start_memory : case stop_memory : p += 2 ; continue ; default : abort ( ) ; } path_can_be_null = false ; p = pend ; } bufp -> can_be_null |= path_can_be_null ; done RESET_FAIL_STACK ( ) ; return 0 ; } 