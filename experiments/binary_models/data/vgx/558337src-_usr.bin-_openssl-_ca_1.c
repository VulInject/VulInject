static int certify_cert ( X509 * * xret , char * infile , EVP_PKEY * pkey , X509 * x509 , const EVP_MD * dgst , STACK_OF ( OPENSSL_STRING ) * sigopts , STACK_OF ( CONF_VALUE ) * policy , CA_DB * db , BIGNUM * serial , char * subj , unsigned long chtype , int multirdn , int email_dn , char * startdate , char * enddate , long days , int batch , char * ext_sect , CONF * lconf , int verbose , unsigned long certopt , unsigned long nameopt , int default_op , int ext_copy ) ( X509 * req = NULL , X509_REQ * rreq = NULL , EVP_PKEY * pktmp = NULL , int ok = - 1 , i , ( ( req = load_cert ( bio_err , infile , FORMAT_PEM , NULL , infile ) ) == NULL ) err ) ; if ( verbose ) { if ( ! X509_print ( bio_err , req ) ) { err } } BIO_printf ( bio_err , "Check that the request matches the signature\n" ) ; if ( ( pktmp = X509_get0_pubkey ( req ) ) == NULL ) { BIO_printf ( bio_err , "error unpacking public key\n" ) ; err } i = X509_verify ( req , pktmp ) ; if ( i < 0 ) { ok = 0 ; BIO_printf ( bio_err , "Signature verification problems....\n" ) ; err } if ( i == 0 ) { ok = 0 ; BIO_printf ( bio_err , "Signature did not match the certificate\n" ) ; err } else { BIO_printf ( bio_err , "Signature ok\n" ) ; } if ( ( rreq = X509_to_X509_REQ ( req , NULL , EVP_md5 ( ) ) ) == NULL ) { err } ok = do_body ( xret , pkey , x509 , dgst , sigopts , policy , db , serial , subj , chtype , multirdn , email_dn , startdate , enddate , days , batch , verbose , rreq , ext_sect , lconf , certopt , nameopt , default_op , ext_copy , 0 ) ; err X509_free ( req ) ; return ( ok ) ; 