static int FUN1 ( struct VAR1 * VAR2 , struct VAR3 * VAR4 , unsigned long * VAR5 ) { FUN2 ( VAR6 , VAR7 ) ; struct VAR8 * VAR9 ; struct VAR8 * VAR10 ; struct VAR11 * VAR12 ; u16 VAR13 ; u16 VAR14 ; u8 VAR15 ; u8 VAR16 = 0 ; int VAR17 ; FUN3 ( VAR6 , VAR7 ) ; VAR13 = FUN4 ( VAR2 , VAR5 , VAR6 ) ; FUN5 ( VAR2 , VAR18 , "" , VAR13 , VAR4 -> VAR19 ) ; if ( VAR4 -> VAR19 > 1 ) { if ( VAR4 -> VAR19 > VAR13 ) { return - VAR20 ; } VAR4 -> VAR19 ++ ; } VAR9 = FUN6 ( VAR21 , sizeof ( * VAR9 ) , VAR22 ) ; if ( ! VAR9 ) { return - VAR23 ; } VAR10 = FUN7 ( FUN8 ( VAR2 ) , VAR4 -> VAR19 , sizeof ( * VAR10 ) , VAR22 ) ; if ( ! VAR10 ) { VAR17 = - VAR23 ; VAR24 } FUN3 ( VAR4 -> VAR25 , VAR21 ) ; VAR14 = VAR21 ; VAR17 = FUN9 ( VAR2 , VAR9 , & VAR14 , VAR26 , NULL ) ; if ( VAR17 || VAR14 == 0 ) { VAR27 } VAR15 = FUN10 ( VAR6 , VAR7 ) ; FUN11 ( , , ) { u8 VAR28 ; VAR17 = FUN12 ( VAR2 , & VAR12 -> VAR29 ) ; if ( VAR17 ) { VAR27 } VAR9 [ 0 ] . VAR30 . VAR31 = 0 ; VAR10 [ VAR16 ] = VAR9 [ 0 ] ; VAR10 [ VAR16 ] . VAR32 = ( VAR33 ) VAR12 -> VAR29 ; VAR10 [ VAR16 ] . VAR30 . VAR29 = 0 ; memset ( & VAR10 [ VAR16 ] . VAR30 . VAR34 , 0 , sizeof ( VAR10 [ VAR16 ] . VAR30 . VAR34 ) ) ; VAR10 [ VAR16 ] . VAR30 . VAR34 [ 0 ] = VAR35 ; VAR10 [ VAR16 ] . VAR30 . VAR36 [ 0 ] = FUN13 ( VAR37 ) ; for ( VAR28 = 1 ; VAR28 <= VAR38 ; VAR28 ++ ) { VAR10 [ VAR16 ] . VAR30 . VAR34 [ VAR28 ] = 0x80 ; VAR10 [ VAR16 ] . VAR30 . VAR36 [ VAR28 ] = 0 ; } for ( VAR28 = 0 ; VAR28 < VAR12 -> VAR39 . VAR40 ; VAR28 ++ ) { VAR10 [ VAR16 ] . VAR30 . VAR34 [ VAR28 + 1 ] = VAR12 -> VAR41 [ VAR28 ] ; VAR10 [ VAR16 ] . VAR30 . VAR36 [ VAR28 + 1 ] = FUN13 ( VAR12 -> VAR42 [ VAR28 ] ) ; } if ( VAR4 -> VAR19 > 1 ) { if ( VAR15 >= VAR7 ) { FUN5 ( VAR2 , VAR18 , "" ) ; VAR17 = - VAR20 ; VAR27 } VAR12 -> VAR15 = VAR15 ; VAR10 [ VAR16 ] . VAR30 . VAR31 = VAR43 | ( ( VAR15 << VAR44 ) & VAR45 ) ; FUN14 ( VAR15 , VAR6 ) ; VAR15 = FUN10 ( VAR6 , VAR7 ) ; } FUN3 ( ( unsigned long * ) VAR10 [ VAR16 ] . VAR46 , VAR21 ) ; FUN15 ( VAR10 [ VAR16 ] . VAR32 , ( unsigned long * ) VAR10 [ VAR16 ] . VAR46 ) ; VAR10 [ VAR16 ] . VAR30 . VAR47 = VAR4 -> VAR48 ; VAR16 ++ ; } if ( VAR4 -> VAR19 == 1 ) { VAR4 -> VAR49 = VAR10 [ 0 ] . VAR32 ; FUN15 ( VAR10 [ 0 ] . VAR32 , VAR4 -> VAR25 ) ; VAR10 [ 0 ] . VAR30 . VAR29 = VAR4 -> VAR49 | VAR50 ; if ( sizeof ( VAR10 [ 0 ] . VAR46 ) >= sizeof ( VAR4 -> VAR25 ) ) { memcpy ( VAR10 [ 0 ] . VAR46 , VAR4 -> VAR25 , sizeof ( VAR10 [ 0 ] . VAR46 ) ) ; } else { VAR17 = - VAR51 ; VAR27 } VAR10 [ 0 ] . VAR30 . VAR47 = VAR4 -> VAR48 ; } else { struct VAR11 * VAR52 ; u16 VAR29 , VAR28 ; VAR17 = FUN12 ( VAR2 , & VAR29 ) ; if ( VAR17 ) { VAR27 } VAR10 [ VAR16 ] . VAR32 = ( VAR33 ) VAR29 ; VAR10 [ VAR16 ] . VAR30 . VAR29 = ( VAR33 ) VAR29 ; VAR10 [ VAR16 ] . VAR30 . VAR29 |= VAR50 ; VAR52 = FUN16 ( FUN8 ( VAR2 ) , sizeof ( * VAR52 ) , VAR22 ) ; if ( ! VAR52 ) { VAR17 = - VAR23 ; VAR27 } VAR52 -> VAR29 = VAR29 ; memset ( & VAR10 [ VAR16 ] . VAR30 . VAR34 , 0 , sizeof ( VAR10 [ VAR16 ] . VAR30 . VAR34 ) ) ; VAR10 [ VAR16 ] . VAR30 . VAR34 [ 0 ] = VAR35 ; VAR10 [ VAR16 ] . VAR30 . VAR36 [ 0 ] = FUN13 ( VAR37 ) ; for ( VAR28 = 1 ; VAR28 <= VAR38 ; VAR28 ++ ) { VAR10 [ VAR16 ] . VAR30 . VAR34 [ VAR28 ] = VAR53 ; VAR10 [ VAR16 ] . VAR30 . VAR36 [ VAR28 ] = 0 ; } VAR28 = 1 ; FUN15 ( VAR29 , VAR4 -> VAR25 ) ; VAR52 -> VAR15 = VAR54 ; FUN11 ( , , ) { VAR52 -> VAR41 [ VAR28 ] = VAR12 -> VAR15 ; VAR10 [ VAR16 ] . VAR30 . VAR34 [ VAR28 ] = VAR12 -> VAR15 ; VAR10 [ VAR16 ] . VAR30 . VAR36 [ VAR28 ++ ] = FUN13 ( 0xFFFF ) ; FUN15 ( VAR12 -> VAR29 , VAR4 -> VAR25 ) ; } FUN17 ( & VAR52 -> VAR55 , & VAR4 -> VAR56 ) ; if ( sizeof ( VAR10 [ VAR16 ] . VAR46 ) >= sizeof ( VAR4 -> VAR25 ) ) { memcpy ( VAR10 [ VAR16 ] . VAR46 , VAR4 -> VAR25 , sizeof ( VAR10 [ VAR16 ] . VAR46 ) ) ; } else { VAR17 = - VAR51 ; VAR27 } VAR10 [ VAR16 ] . VAR30 . VAR47 = VAR4 -> VAR48 ; VAR16 ++ ; VAR4 -> VAR49 = ( VAR33 ) VAR29 ; } VAR17 = FUN18 ( VAR2 , VAR57 ) ; if ( VAR17 ) { VAR27 } VAR17 = FUN19 ( VAR2 , VAR10 , VAR4 -> VAR19 , NULL ) ; FUN20 ( VAR2 ) ; if ( VAR17 ) { VAR27 } FUN11 ( , , ) { struct VAR58 * VAR59 = VAR2 -> VAR60 ; bool VAR61 , VAR62 = false ; struct VAR3 * VAR63 ; u16 VAR64 , VAR65 = 0 ; for ( VAR64 = 0 ; VAR64 < VAR4 -> VAR19 ; VAR64 ++ ) { if ( VAR10 [ VAR64 ] . VAR32 == VAR12 -> VAR29 ) { VAR65 = VAR64 ; VAR62 = true ; } } if ( ! VAR62 ) { VAR17 = - VAR66 ; VAR27 } VAR63 = & VAR59 -> VAR67 [ VAR12 -> VAR29 ] ; VAR61 = ( VAR4 -> VAR49 == VAR12 -> VAR29 ) ; VAR63 -> VAR61 = VAR61 ; VAR63 -> VAR49 = VAR12 -> VAR29 ; VAR63 -> VAR68 = ( VAR61 && VAR4 -> VAR19 > 1 ) ; memcpy ( & VAR63 -> VAR69 , VAR12 -> VAR39 . VAR70 , VAR12 -> VAR39 . VAR40 * sizeof ( VAR71 ) ) ; memcpy ( VAR63 -> VAR25 , VAR10 [ VAR65 ] . VAR46 , sizeof ( VAR63 -> VAR25 ) ) ; FUN21 ( & VAR10 [ VAR65 ] , VAR63 ) ; if ( ! VAR61 ) { FUN21 ( & VAR10 [ VAR65 ] , & VAR59 -> VAR67 [ VAR4 -> VAR49 ] ) ; } VAR63 -> VAR72 = VAR12 -> VAR39 . VAR40 ; VAR63 -> VAR15 = VAR12 -> VAR15 ; VAR63 -> VAR48 = VAR10 [ VAR65 ] . VAR30 . VAR47 ; VAR63 -> VAR19 = VAR4 -> VAR19 ; VAR63 -> VAR73 = VAR4 -> VAR73 ; VAR63 -> VAR74 = true ; } VAR4 -> VAR75 = VAR10 ; FUN22 ( VAR9 ) ; return VAR17 ; err_unroll err_mem FUN22 ( VAR9 ) ; FUN23 ( FUN8 ( VAR2 ) , VAR10 ) ; return VAR17 ; }