explicit_encryption_setup ( ) { ee_fixture * eef = ( ee_fixture * ) bson_malloc0 ( sizeof ( ee_fixture ) ) ; bson_t * encryptedFields = get_bson_from_json_file ( "./src/libmongoc/tests/client_side_encryption_prose/explicit_encryption/" "encryptedFields.json" ) ; bson_t * key1Document = get_bson_from_json_file ( "./src/libmongoc/tests/client_side_encryption_prose/explicit_encryption/" "key1-document.json" ) ; mongoc_client_t * setupClient = test_framework_new_default_client ( ) ; { bson_iter_t iter ; const bson_value_t * value ; ASSERT ( bson_iter_init_find ( & iter , key1Document , "_id" ) ) ; value = bson_iter_value ( & iter ) ; bson_value_copy ( value , & eef -> key1ID ) ; } { mongoc_database_t * db = mongoc_client_get_database ( setupClient , "db" ) ; mongoc_collection_t * coll = mongoc_database_get_collection ( db , "explicit_encryption" ) ; bson_error_t error ; bson_t * opts ; opts = BCON_NEW ( "encryptedFields" , BCON_DOCUMENT ( encryptedFields ) ) ; if ( ! mongoc_collection_drop_with_opts ( coll , opts , & error ) ) { if ( error . code != MONGOC_SERVER_ERR_NS_NOT_FOUND ) { test_error ( "unexpected error in drop: %s" , error . message ) ; } } coll = mongoc_database_create_collection ( db , "explicit_encryption" , opts , & error ) ; ASSERT_OR_PRINT ( coll , error ) ; mongoc_collection_destroy ( coll ) ; bson_destroy ( opts ) ; mongoc_database_destroy ( db ) ; } { mongoc_database_t * db = mongoc_client_get_database ( setupClient , "keyvault" ) ; mongoc_collection_t * coll = mongoc_database_get_collection ( db , "datakeys" ) ; bson_error_t error ; bson_t iopts = BSON_INITIALIZER ; mongoc_write_concern_t * wc ; if ( ! mongoc_collection_drop ( coll , & error ) ) { if ( error . code != MONGOC_SERVER_ERR_NS_NOT_FOUND ) { test_error ( "unexpected error in drop: %s" , error . message ) ; } } mongoc_collection_destroy ( coll ) ; coll = mongoc_database_create_collection ( db , "datakeys" , NULL , & error ) ; ASSERT_OR_PRINT ( coll , error ) ; wc = mongoc_write_concern_new ( ) ; mongoc_write_concern_set_w ( wc , MONGOC_WRITE_CONCERN_W_MAJORITY ) ; ASSERT ( mongoc_write_concern_append ( wc , & iopts ) ) ; ASSERT_OR_PRINT ( mongoc_collection_insert_one ( coll , key1Document , & iopts , NULL , & error ) , error ) ; mongoc_write_concern_destroy ( wc ) ; bson_destroy ( & iopts ) ; mongoc_collection_destroy ( coll ) ; mongoc_database_destroy ( db ) ; } eef -> keyVaultClient = test_framework_new_default_client ( ) ; { mongoc_client_encryption_opts_t * ceOpts = mongoc_client_encryption_opts_new ( ) ; bson_t * kms_providers = _make_local_kms_provider ( NULL ) ; bson_error_t error ; mongoc_client_encryption_opts_set_keyvault_client ( ceOpts , eef -> keyVaultClient ) ; mongoc_client_encryption_opts_set_keyvault_namespace ( ceOpts , "keyvault" , "datakeys" ) ; mongoc_client_encryption_opts_set_kms_providers ( ceOpts , kms_providers ) ; eef -> clientEncryption = mongoc_client_encryption_new ( ceOpts , & error ) ; ASSERT_OR_PRINT ( eef -> clientEncryption , error ) ; bson_destroy ( kms_providers ) ; mongoc_client_encryption_opts_destroy ( ceOpts ) ; } { mongoc_auto_encryption_opts_t * aeOpts = mongoc_auto_encryption_opts_new ( ) ; bson_t * kms_providers = _make_local_kms_provider ( NULL ) ; bson_error_t error ; mongoc_auto_encryption_opts_set_keyvault_namespace ( aeOpts , "keyvault" , "datakeys" ) ; mongoc_auto_encryption_opts_set_kms_providers ( aeOpts , kms_providers ) ; mongoc_auto_encryption_opts_set_bypass_query_analysis ( aeOpts , true ) ; eef -> encryptedClient = test_framework_new_default_client ( ) ; ASSERT_OR_PRINT ( mongoc_client_enable_auto_encryption ( eef -> encryptedClient , aeOpts , & error ) , error ) ; bson_destroy ( kms_providers ) ; mongoc_auto_encryption_opts_destroy ( aeOpts ) ; eef -> encryptedColl = mongoc_client_get_collection ( eef -> encryptedClient , "db" , "explicit_encryption" ) ; } mongoc_client_destroy ( setupClient ) ; bson_destroy ( key1Document ) ; bson_destroy ( encryptedFields ) ; return eef ; } 