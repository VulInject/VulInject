static int machine_matches ( p_fixd ) tFixDesc * p_fixd ; { tSCC case_fmt [ ] "case %s in\n" ; ; tSCC esac_fmt [ ] " )\n    echo %s ;;\n* ) echo %s ;;\nesac" ; ; tSCC skip [ ] "skip" ; ; tSCC run [ ] "run" ; ; const char * * papz_machs = p_fixd -> papz_machs ; char * pz ; const char * pz_sep = "" ; tCC * pz_if_true ; tCC * pz_if_false ; char cmd_buf [ MACH_LIST_SIZE_LIMIT ] ; sprintf ( cmd_buf , case_fmt , pz_machine ) ; pz = cmd_buf + strlen ( cmd_buf ) ; if ( p_fixd -> fd_flags & FD_MACH_IFNOT ) { pz_if_true = skip ; pz_if_false = run ; } else { pz_if_true = run ; pz_if_false = skip ; } for ( ; ; ) { const char * pz_mach = * ( papz_machs ++ ) ; if ( pz_mach == ( const char * ) NULL ) { break ; } sprintf ( pz , "%s%s" , pz_sep , pz_mach ) ; pz += strlen ( pz ) ; pz_sep = " | \\\n" ; } sprintf ( pz , esac_fmt , pz_if_true , pz_if_false ) ; { int skip ; pz = run_shell ( cmd_buf , NULL ) ; skip = ( * pz == 's' ) ; free ( ( void * ) pz ) ; if ( skip ) { p_fixd -> fd_flags |= FD_SKIP_TEST ; return BOOL_FALSE ; } } return BOOL_TRUE ; const char * * papz_machs = p_fixd -> papz_machs ; int invert = ( p_fixd -> fd_flags & FD_MACH_IFNOT ) != 0 ; for ( ; ; ) { const char * pz_mach = * ( papz_machs ++ ) ; if ( pz_mach == ( const char * ) NULL ) { break ; } if ( strstr ( pz_mach , "dos" ) != NULL && ! invert ) { return BOOL_TRUE ; } } p_fixd -> fd_flags |= FD_SKIP_TEST ; return BOOL_FALSE ; } 