static void answer_lookup_zone ( struct nsd * nsd , struct query * q , answer_type * answer , size_t domain_number , int exact , domain_type * closest_match , domain_type * closest_encloser , const dname_type * qname ) { zone_type * origzone = q -> zone ; q -> zone = domain_find_zone ( nsd -> db , closest_encloser ) ; if ( ! q -> zone ) { if ( q -> cname_count == 0 ) { RCODE_SET ( q -> packet , RCODE_REFUSE ) ; q -> edns . ede = EDE_NOT_AUTHORITATIVE ; } return ; } assert ( closest_encloser ) ; if ( q -> zone -> opts && q -> zone -> opts -> pattern && q -> zone -> opts -> pattern -> allow_query ) { struct acl_options * why = NULL ; if ( acl_check_incoming ( q -> zone -> opts -> pattern -> allow_query , q , & why ) != - 1 ) { assert ( why ) ; DEBUG ( DEBUG_QUERY , 1 , ( LOG_INFO , "query %s passed acl %s %s" , dname_to_string ( q -> qname , NULL ) , why -> ip_address_spec , why -> nokey ?"NOKEY" : ( why -> blocked ?"BLOCKED" : why -> key_name ) ) ) ; } else { if ( verbosity >= 2 ) { int address [ 128 ] ; addr2str ( & q -> addr , address , sizeof ( address ) ) ; VERBOSITY ( 2 , ( LOG_INFO , "query %s from %s refused, %s %s" , dname_to_string ( q -> qname , NULL ) , address , why ?( why -> nokey ?"NOKEY" : why -> blocked ?"BLOCKED" : why -> key_name ) else "no acl matches" , why ?why -> ip_address_spec : "." ) ) ; } if ( q -> cname_count == 0 ) { RCODE_SET ( q -> packet , RCODE_REFUSE ) ; q -> edns . ede = EDE_PROHIBITED ; } return ; } } if ( ! q -> zone -> apex || ! q -> zone -> soa_rrset ) { if ( q -> cname_count == 0 ) { RCODE_SET ( q -> packet , RCODE_SERVFAIL ) ; q -> edns . ede = EDE_NOT_READY ; ASSIGN_EDE_CODE_AND_STRING_LITERAL ( q -> edns . ede , EDE_NOT_READY , "Zone is configured but not loaded" ) ; } return ; } if ( nsd -> options -> confine_to_zone && ( origzone != NULL && dname_compare ( domain_dname ( origzone -> apex ) , domain_dname ( q -> zone -> apex ) ) != 0 ) ) { return ; } if ( closest_encloser && ! closest_encloser -> is_existing ) { exact = 0 ; while ( closest_encloser != NULL && ! closest_encloser -> is_existing ) { closest_encloser = closest_encloser -> parent ; } } if ( exact && q -> qtype == TYPE_DS && closest_encloser == q -> zone -> apex ) { zone_type * zone = domain_find_parent_zone ( nsd -> db , q -> zone ) ; if ( zone ) { q -> zone = zone ; if ( ! q -> zone -> apex || ! q -> zone -> soa_rrset ) { if ( q -> cname_count == 0 ) { RCODE_SET ( q -> packet , RCODE_SERVFAIL ) ; ASSIGN_EDE_CODE_AND_STRING_LITERAL ( q -> edns . ede , EDE_NOT_READY , "Zone is configured but not loaded" ) ; } return ; } } } if ( q -> zone && q -> zone -> opts && q -> zone -> opts -> pattern && q -> zone -> opts -> pattern -> request_xfr != 0 && ! q -> zone -> is_ok ) { if ( q -> cname_count == 0 ) { RCODE_SET ( q -> packet , RCODE_SERVFAIL ) ; ASSIGN_EDE_CODE_AND_STRING_LITERAL ( q -> edns . ede , EDE_INVALID_DATA , "Zone has expired" ) ; } return ; } if ( exact && q -> qtype == TYPE_DS && closest_encloser == q -> zone -> apex ) { if ( q -> qclass == CLASS_ANY ) { AA_CLR ( q -> packet ) ; } else { AA_SET ( q -> packet ) ; } answer_nodata ( q , answer , closest_encloser ) ; } else { q -> delegation_domain = domain_find_ns_rrsets ( closest_encloser , q -> zone , & q -> delegation_rrset ) ; if ( q -> delegation_domain && find_dname_above ( q -> delegation_domain , q -> zone ) ) { q -> delegation_domain = NULL ; } if ( ! q -> delegation_domain || ! q -> delegation_rrset || ( exact && q -> qtype == TYPE_DS && closest_encloser == q -> delegation_domain ) ) { if ( q -> qclass == CLASS_ANY ) { AA_CLR ( q -> packet ) ; } else { AA_SET ( q -> packet ) ; } answer_authoritative ( nsd , q , answer , domain_number , exact , closest_match , closest_encloser , qname ) ; } else { answer_delegation ( q , answer ) ; } } } 