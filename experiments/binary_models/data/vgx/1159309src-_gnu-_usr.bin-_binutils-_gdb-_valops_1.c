find_oload_champ_namespace_loop ( , , , , , , , ) { int next_namespace_len = namespace_len ; int searched_deeper = 0 ; int num_fns = 0 ; struct cleanup * old_cleanups ; int new_oload_champ ; struct symbol * * new_oload_syms ; struct badness_vector * new_oload_champ_bv ; char * new_namespace ; if ( next_namespace_len != 0 ) { gdb_assert ( qualified_name [ next_namespace_len ] == ':' ) ; next_namespace_len += 2 ; } next_namespace_len += cp_find_first_component ( qualified_name + next_namespace_len ) ; * oload_syms = NULL ; * oload_champ_bv = NULL ; if ( qualified_name [ next_namespace_len ] == ':' ) { searched_deeper = 1 ; if ( find_oload_champ_namespace_loop ( arg_types , nargs , func_name , qualified_name , next_namespace_len , oload_syms , oload_champ_bv , oload_champ ) ) { return 1 ; } } old_cleanups = make_cleanup ( xfree , * oload_syms ) ; old_cleanups = make_cleanup ( xfree , * oload_champ_bv ) ; new_namespace = alloca ( namespace_len + 1 ) ; strncpy ( new_namespace , qualified_name , namespace_len ) ; new_namespace [ namespace_len ] = '\0' ; new_oload_syms = make_symbol_overload_list ( func_name , new_namespace ) ; while ( new_oload_syms [ num_fns ] ) { ++ num_fns ; } new_oload_champ = find_oload_champ ( arg_types , nargs , 0 , num_fns , NULL , new_oload_syms , & new_oload_champ_bv ) ; if ( new_oload_champ != - 1 && classify_oload_match ( new_oload_champ_bv , nargs , 0 ) == STANDARD ) { * oload_syms = new_oload_syms ; * oload_champ = new_oload_champ ; * oload_champ_bv = new_oload_champ_bv ; do_cleanups ( old_cleanups , NULL ) ; return 1 ; } if ( searched_deeper ) { xfree ( new_oload_syms ) ; xfree ( new_oload_champ_bv ) ; discard_cleanups ( old_cleanups ) ; return 0 ; } else { gdb_assert ( new_oload_champ != - 1 ) ; * oload_syms = new_oload_syms ; * oload_champ = new_oload_champ ; * oload_champ_bv = new_oload_champ_bv ; discard_cleanups ( old_cleanups ) ; return 0 ; } } 