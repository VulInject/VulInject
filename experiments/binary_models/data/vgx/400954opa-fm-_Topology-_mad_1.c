FSTATUS SmaGetBufferControlTable ( struct omgt_port * port , STL_LID dlid , STL_LID slid , uint8_t * path , uint8_t startPort , uint8_t endPort , STL_BUFFER_CONTROL_TABLE pBCT [ ] ) { FSTATUS fstatus = FERROR ; uint8_t maxCount = path == NULL ?STL_NUM_BFRCTLTAB_BLOCKS_PER_LID_SMP : STL_NUM_BFRCTLTAB_BLOCKS_PER_DRSMP ; uint8_t block ; char attributeName [ 64 ] ; const size_t bufferLength = STL_BFRCTRLTAB_PAD_SIZE * maxCount ; uint8_t buffer [ bufferLength ] ; memset ( buffer , 0 , bufferLength ) ; sprintf ( attributeName , "Get(BufferControlTable %u %u)" , startPort , endPort ) ; debugLogSmaRequest ( attributeName , path , dlid , slid ) ; for ( block = startPort ; block <= endPort ; block += maxCount ) { uint8_t numPorts = MIN ( maxCount , ( endPort - block ) + 1 ) ; uint32_t amod = ( numPorts << 24 ) | block ; fstatus = stl_sma_send_recv_mad ( port , dlid , slid , path , MMTHD_GET , STL_MCLASS_ATTRIB_ID_BUFFER_CONTROL_TABLE , amod , buffer , bufferLength ) ; if ( fstatus == FSUCCESS ) { int i ; STL_BUFFER_CONTROL_TABLE * table = ( STL_BUFFER_CONTROL_TABLE * ) buffer ; for ( i = 0 ; i < numPorts ; i ++ ) { BSWAP_STL_BUFFER_CONTROL_TABLE ( table ) ; pBCT [ block - startPort + i ] = * table ; table = ( STL_BUFFER_CONTROL_TABLE * ) ( ( uint8_t * ) table + STL_BFRCTRLTAB_PAD_SIZE ) ; } } } return fstatus ; } 