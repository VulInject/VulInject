static int sata_dwc_probe ( struct platform_device * ofdev ) { struct sata_dwc_device * hsdev ; u32 idr , versionr ; char * ver = ( char * ) & versionr ; void __iomem * base ; int err = 0 ; int irq ; struct ata_host * host ; struct ata_port_info pi = sata_dwc_port_info [ 0 ] ; const struct ata_port_info * ppi [ ] { & pi NULL } ; ; struct device_node * np = ofdev -> dev . of_node ; struct resource * res ; host = ata_host_alloc_pinfo ( & ofdev -> dev , ppi , SATA_DWC_MAX_PORTS ) ; hsdev = devm_kzalloc ( & ofdev -> dev , sizeof ( * hsdev ) , GFP_KERNEL ) ; if ( ! host || ! hsdev ) { return - ENOMEM ; } host -> private_data = hsdev ; res = platform_get_resource ( ofdev , IORESOURCE_MEM , 0 ) ; base = devm_ioremap_resource ( & ofdev -> dev , res ) ; if ( IS_ERR ( base ) ) { return PTR_ERR ( base ) ; } dev_dbg ( & ofdev -> dev , "ioremap done for SATA register address\n" ) ; hsdev -> sata_dwc_regs = base + SATA_DWC_REG_OFFSET ; hsdev -> dmadr = res -> start + SATA_DWC_REG_OFFSET + offsetof ( sata_dwc_regs , dmadr ) ; host -> ports [ 0 ] -> ioaddr . cmd_addr = base ; host -> ports [ 0 ] -> ioaddr . scr_addr = base + SATA_DWC_SCR_OFFSET ; sata_dwc_setup_port ( & host -> ports [ 0 ] -> ioaddr , base ) ; idr = sata_dwc_readl ( & hsdev -> sata_dwc_regs -> idr ) ; versionr = sata_dwc_readl ( & hsdev -> sata_dwc_regs -> versionr ) ; dev_notice ( & ofdev -> dev , "id %d, controller version %c.%c%c\n" , idr , ver [ 0 ] , ver [ 1 ] , ver [ 2 ] ) ; hsdev -> dev = & ofdev -> dev ; sata_dwc_enable_interrupts ( hsdev ) ; irq = irq_of_parse_and_map ( np , 0 ) ; if ( irq == NO_IRQ ) { dev_err ( & ofdev -> dev , "no SATA DMA irq\n" ) ; err = - ENODEV ; error_out } if ( ! of_find_property ( np , "dmas" , NULL ) ) { err = sata_dwc_dma_init_old ( ofdev , hsdev ) ; if ( err ) { error_out } } hsdev -> phy = devm_phy_optional_get ( hsdev -> dev , "sata-phy" ) ; if ( IS_ERR ( hsdev -> phy ) ) { err = PTR_ERR ( hsdev -> phy ) ; error_out } err = phy_init ( hsdev -> phy ) ; if ( err ) { error_out } err = ata_host_activate ( host , irq , sata_dwc_isr , 0 , & sata_dwc_sht ) ; if ( err ) { dev_err ( & ofdev -> dev , "failed to activate host" ) ; } dev_set_drvdata ( & ofdev -> dev , host ) ; return 0 ; error_out phy_exit ( hsdev -> phy ) ; return err ; } 