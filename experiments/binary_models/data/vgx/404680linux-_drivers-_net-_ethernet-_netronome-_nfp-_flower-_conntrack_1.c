static int FUN1 ( struct VAR1 * * VAR2 , struct VAR3 * VAR4 , struct VAR5 * VAR6 , struct VAR7 * VAR8 ) { enum flow_action_hw_stats VAR9 = VAR10 ; struct VAR11 * VAR12 ; int VAR13 , VAR14 , VAR15 , VAR16 ; struct VAR1 * VAR17 ; int VAR18 = 0 , VAR19 = 0 ; VAR15 = VAR2 [ VAR20 ] -> VAR21 . VAR22 + VAR2 [ VAR23 ] -> VAR21 . VAR22 + VAR2 [ VAR24 ] -> VAR21 . VAR22 ; VAR17 = FUN2 ( VAR15 + 1 ) ; if ( ! VAR17 ) { return - VAR25 ; } VAR17 -> VAR26 = VAR2 [ VAR20 ] -> VAR26 ; if ( VAR2 [ VAR24 ] -> VAR21 . VAR22 != 0 ) { VAR9 = VAR2 [ VAR24 ] -> VAR21 . VAR27 [ 0 ] . VAR28 ; } for ( VAR14 = 0 ; VAR14 < VAR29 ; VAR14 ++ ) { u32 VAR30 = 0 ; u8 VAR31 = 0 ; if ( FUN3 ( VAR2 [ VAR14 ] , VAR32 ) ) { struct flow_match_basic VAR26 ; FUN4 ( VAR2 [ VAR14 ] , & VAR26 ) ; if ( VAR26 . VAR33 -> VAR31 ) { VAR17 -> VAR26 = VAR2 [ VAR14 ] -> VAR26 ; VAR31 = VAR26 . VAR34 -> VAR31 ; } } for ( VAR13 = 0 ; VAR13 < VAR2 [ VAR14 ] -> VAR21 . VAR22 ; VAR13 ++ ) { VAR12 = & VAR2 [ VAR14 ] -> VAR21 . VAR27 [ VAR13 ] ; VAR16 = VAR12 -> VAR16 ; switch ( VAR16 ) { case VAR35 : case VAR36 : case VAR37 : continue ; default : if ( VAR14 == VAR23 ) { if ( VAR12 -> VAR28 == VAR10 ) { VAR12 -> VAR28 = VAR9 ; } FUN5 ( VAR12 , VAR31 , & VAR30 ) ; } memcpy ( & VAR17 -> VAR21 . VAR27 [ VAR19 ++ ] , VAR12 , sizeof ( VAR11 ) ) ; break ; } } if ( VAR30 ) { struct VAR11 * VAR38 ; VAR38 = & VAR17 -> VAR21 . VAR27 [ VAR19 ++ ] ; VAR38 -> VAR16 = VAR39 ; VAR38 -> VAR40 = VAR30 ; VAR38 -> VAR28 = VAR9 ; } } VAR17 -> VAR21 . VAR22 = VAR19 ; VAR18 = FUN6 ( VAR4 -> VAR41 , VAR17 , VAR6 , VAR8 , NULL ) ; return VAR18 ; }