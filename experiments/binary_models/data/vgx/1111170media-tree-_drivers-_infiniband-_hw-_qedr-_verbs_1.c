struct ib_cq * qedr_create_cq ( struct ib_device * ibdev , const struct ib_cq_init_attr * attr , struct ib_ucontext * ib_ctx , struct ib_udata * udata ) { struct qedr_ucontext * ctx = get_qedr_ucontext ( ib_ctx ) ; struct qed_rdma_destroy_cq_out_params destroy_oparams ; struct qed_rdma_destroy_cq_in_params destroy_iparams ; struct qedr_dev * dev = get_qedr_dev ( ibdev ) ; struct qed_rdma_create_cq_in_params params ; struct qedr_create_cq_ureq ureq ; int vector = attr -> comp_vector ; int entries = attr -> cqe ; struct qedr_cq * cq ; int chain_entries ; int page_cnt ; u64 pbl_ptr ; u16 icid ; int rc ; DP_DEBUG ( dev , QEDR_MSG_INIT , "create_cq: called from %s. entries=%d, vector=%d\n" , udata ?"User Lib" : "Kernel" , entries , vector ) ; if ( entries > QEDR_MAX_CQES ) { DP_ERR ( dev , "create cq: the number of entries %d is too high. Must be equal or below %d.\n" , entries , QEDR_MAX_CQES ) ; return ERR_PTR ( - EINVAL ) ; } chain_entries = qedr_align_cq_entries ( entries ) ; chain_entries = min_t ( int , chain_entries , QEDR_MAX_CQES ) ; cq = kzalloc ( sizeof ( * cq ) , GFP_KERNEL ) ; if ( ! cq ) { return ERR_PTR ( - ENOMEM ) ; } if ( udata ) { if ( ib_copy_from_udata ( & ureq , udata , sizeof ( ureq ) ) ) { DP_ERR ( dev , "create cq: problem copying data from user space\n" ) ; err0 } if ( ! ureq . len ) { DP_ERR ( dev , "create cq: cannot create a cq with 0 entries\n" ) ; err0 } cq -> cq_type = QEDR_CQ_TYPE_USER ; rc = qedr_init_user_queue ( ib_ctx , dev , & cq -> q , ureq . addr , ureq . len , IB_ACCESS_LOCAL_WRITE , 1 ) ; if ( rc ) { err0 } pbl_ptr = cq -> q . pbl_tbl -> pa ; page_cnt = cq -> q . pbl_info . num_pbes ; cq -> ibcq . cqe = chain_entries ; } else { cq -> cq_type = QEDR_CQ_TYPE_KERNEL ; rc = dev -> ops -> common -> chain_alloc ( dev -> cdev , QED_CHAIN_USE_TO_CONSUME , QED_CHAIN_MODE_PBL , QED_CHAIN_CNT_TYPE_U32 , chain_entries , sizeof ( rdma_cqe ) , & cq -> pbl ) ; if ( rc ) { err1 } page_cnt = qed_chain_get_page_cnt ( & cq -> pbl ) ; pbl_ptr = qed_chain_get_pbl_phys ( & cq -> pbl ) ; cq -> ibcq . cqe = cq -> pbl . capacity ; } qedr_init_cq_params ( cq , ctx , dev , vector , chain_entries , page_cnt , pbl_ptr , & params ) ; rc = dev -> ops -> rdma_create_cq ( dev -> rdma_ctx , & params , & icid ) ; if ( rc ) { err2 } cq -> icid = icid ; cq -> sig = QEDR_CQ_MAGIC_NUMBER ; spin_lock_init ( & cq -> cq_lock ) ; if ( ib_ctx ) { rc = qedr_copy_cq_uresp ( dev , cq , udata ) ; if ( rc ) { err3 } } else { cq -> db_addr = dev -> db_addr + DB_ADDR_SHIFT ( DQ_PWM_OFFSET_UCM_RDMA_CQ_CONS_32BIT ) ; cq -> db . data . icid = cq -> icid ; cq -> db . data . params = DB_AGG_CMD_SET << RDMA_PWM_VAL32_DATA_AGG_CMD_SHIFT ; cq -> toggle_cqe = qed_chain_get_last_elem ( & cq -> pbl ) ; cq -> pbl_toggle = RDMA_CQE_REQUESTER_TOGGLE_BIT_MASK ; cq -> latest_cqe = NULL ; consume_cqe ( cq ) ; cq -> cq_cons = qed_chain_get_cons_idx_u32 ( & cq -> pbl ) ; } DP_DEBUG ( dev , QEDR_MSG_CQ , "create cq: icid=0x%0x, addr=%p, size(entries)=0x%0x\n" , cq -> icid , cq , params . cq_size ) ; return & cq -> ibcq ; err3 destroy_iparams . icid = cq -> icid ; dev -> ops -> rdma_destroy_cq ( dev -> rdma_ctx , & destroy_iparams , & destroy_oparams ) ; err2 if ( udata ) { qedr_free_pbl ( dev , & cq -> q . pbl_info , cq -> q . pbl_tbl ) ; } else { dev -> ops -> common -> chain_free ( dev -> cdev , & cq -> pbl ) ; } err1 if ( udata ) { ib_umem_release ( cq -> q . umem ) ; } err0 kfree ( cq ) ; return ERR_PTR ( - EINVAL ) ; } 