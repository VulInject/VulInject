static int sha2_mac_atomic ( crypto_provider_handle_t provider , crypto_session_id_t session_id , crypto_mechanism_t * mechanism , crypto_key_t * key , crypto_data_t * data , crypto_data_t * mac , crypto_spi_ctx_template_t ctx_template , crypto_req_handle_t req ) { int ret = CRYPTO_SUCCESS ; uchar_t digest [ SHA512_DIGEST_LENGTH ] ; sha2_hmac_ctx_t sha2_hmac_ctx ; uint32_t sha_digest_len , digest_len , sha_hmac_block_size ; uint_t keylen_in_bytes = CRYPTO_BITS2BYTES ( key -> ck_length ) ; switch ( mechanism -> cm_type ) { case SHA256_HMAC_MECH_INFO_TYPE : case SHA256_HMAC_GEN_MECH_INFO_TYPE : sha_digest_len = digest_len = SHA256_DIGEST_LENGTH ; sha_hmac_block_size = SHA256_HMAC_BLOCK_SIZE ; break ; case SHA384_HMAC_MECH_INFO_TYPE : case SHA384_HMAC_GEN_MECH_INFO_TYPE : case SHA512_HMAC_MECH_INFO_TYPE : case SHA512_HMAC_GEN_MECH_INFO_TYPE : sha_digest_len = digest_len = SHA512_DIGEST_LENGTH ; sha_hmac_block_size = SHA512_HMAC_BLOCK_SIZE ; break ; default : return ( CRYPTO_MECHANISM_INVALID ) ; } if ( ctx_template != NULL ) { bcopy ( ctx_template , & sha2_hmac_ctx , sizeof ( sha2_hmac_ctx_t ) ) ; } else { sha2_hmac_ctx . hc_mech_type = mechanism -> cm_type ; if ( keylen_in_bytes > sha_hmac_block_size ) { PROV_SHA2_DIGEST_KEY ( mechanism -> cm_type / 3 , & sha2_hmac_ctx . hc_icontext , key -> ck_data , keylen_in_bytes , digest ) ; sha2_mac_init_ctx ( & sha2_hmac_ctx , digest , sha_digest_len ) ; } else { sha2_mac_init_ctx ( & sha2_hmac_ctx , key -> ck_data , keylen_in_bytes ) ; } } if ( ( mechanism -> cm_type % 3 ) == 2 ) { if ( mechanism -> cm_param == NULL || mechanism -> cm_param_len != sizeof ( ulong_t ) ) { ret = CRYPTO_MECHANISM_PARAM_INVALID ; bail } PROV_SHA2_GET_DIGEST_LEN ( mechanism , digest_len ) ; if ( digest_len > sha_digest_len ) { ret = CRYPTO_MECHANISM_PARAM_INVALID ; bail } } SHA2_MAC_UPDATE ( data , sha2_hmac_ctx , ret ) ; if ( ret != CRYPTO_SUCCESS ) { bail } SHA2Final ( digest , & sha2_hmac_ctx . hc_icontext ) ; if ( mechanism -> cm_type == SHA384_HMAC_MECH_INFO_TYPE || mechanism -> cm_type == SHA384_HMAC_GEN_MECH_INFO_TYPE ) { SHA2Update ( & sha2_hmac_ctx . hc_ocontext , digest , SHA384_DIGEST_LENGTH ) ; } else { SHA2Update ( & sha2_hmac_ctx . hc_ocontext , digest , sha_digest_len ) ; } switch ( mac -> cd_format ) { case CRYPTO_DATA_RAW : if ( digest_len != sha_digest_len ) { SHA2Final ( digest , & sha2_hmac_ctx . hc_ocontext ) ; bcopy ( digest , ( unsigned char * ) mac -> cd_raw . iov_base + mac -> cd_offset , digest_len ) ; } else { SHA2Final ( ( unsigned char * ) mac -> cd_raw . iov_base + mac -> cd_offset , & sha2_hmac_ctx . hc_ocontext ) ; } break ; case CRYPTO_DATA_UIO : ret = sha2_digest_final_uio ( & sha2_hmac_ctx . hc_ocontext , mac , digest_len , digest ) ; break ; default : ret = CRYPTO_ARGUMENTS_BAD ; } if ( ret == CRYPTO_SUCCESS ) { mac -> cd_length = digest_len ; return ( CRYPTO_SUCCESS ) ; } bail bzero ( & sha2_hmac_ctx , sizeof ( sha2_hmac_ctx_t ) ) ; mac -> cd_length = 0 ; return ( ret ) ; } 