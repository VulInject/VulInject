static int vdev_raidz_read ( vdev_t * vd , const blkptr_t * bp , void * data , off_t offset , size_t bytes ) { vdev_t * tvd = vd -> v_top ; vdev_t * cvd ; raidz_map_t * rm ; raidz_col_t * rc ; int c , error ; int unexpected_errors ; int parity_errors ; int parity_untried ; int data_errors ; int total_errors ; int n ; int tgts [ VDEV_RAIDZ_MAXPARITY ] ; int code ; rc = NULL ; error = 0 ; rm = vdev_raidz_map_alloc ( data , offset , bytes , tvd -> v_ashift , vd -> v_nchildren , vd -> v_nparity ) ; for ( c = rm -> rm_cols - 1 ; c >= 0 ; c -- ) { rc = & rm -> rm_col [ c ] ; cvd = vdev_child ( vd , rc -> rc_devidx ) ; if ( cvd == NULL || cvd -> v_state != VDEV_STATE_HEALTHY ) { if ( c >= rm -> rm_firstdatacol ) { rm -> rm_missingdata ++ ; } else { rm -> rm_missingparity ++ ; } rc -> rc_error = ENXIO ; rc -> rc_tried = 1 ; rc -> rc_skipped = 1 ; continue ; } if ( vdev_dtl_contains ( cvd , DTL_MISSING , zio -> io_txg , 1 ) ) { if ( c >= rm -> rm_firstdatacol ) { rm -> rm_missingdata ++ ; } else { rm -> rm_missingparity ++ ; } rc -> rc_error = ESTALE ; rc -> rc_skipped = 1 ; continue ; } if ( c >= rm -> rm_firstdatacol || rm -> rm_missingdata > 0 ) { rc -> rc_error = cvd -> v_read ( cvd , NULL , rc -> rc_data , rc -> rc_offset , rc -> rc_size ) ; rc -> rc_tried = 1 ; rc -> rc_skipped = 0 ; } } reconstruct unexpected_errors = 0 ; parity_errors = 0 ; parity_untried = 0 ; data_errors = 0 ; total_errors = 0 ; ASSERT ( rm -> rm_missingparity <= rm -> rm_firstdatacol ) ; ASSERT ( rm -> rm_missingdata <= rm -> rm_cols - rm -> rm_firstdatacol ) ; for ( c = 0 ; c < rm -> rm_cols ; c ++ ) { rc = & rm -> rm_col [ c ] ; if ( rc -> rc_error ) { ASSERT ( rc -> rc_error != ECKSUM ) ; if ( c < rm -> rm_firstdatacol ) { parity_errors ++ ; } else { data_errors ++ ; } if ( ! rc -> rc_skipped ) { unexpected_errors ++ ; } total_errors ++ ; } if ( c < rm -> rm_firstdatacol && ! rc -> rc_tried ) { parity_untried ++ ; } } if ( total_errors <= rm -> rm_firstdatacol - parity_untried ) { int rv ; if ( data_errors == 0 ) { rv = raidz_checksum_verify ( vd -> v_spa , bp , data , bytes ) ; if ( rv == 0 ) { if ( parity_errors + parity_untried < rm -> rm_firstdatacol ) { n = raidz_parity_verify ( rm ) ; unexpected_errors += n ; ASSERT ( parity_errors + n <= rm -> rm_firstdatacol ) ; } done } } else { ASSERT ( parity_untried == 0 ) ; ASSERT ( parity_errors < rm -> rm_firstdatacol ) ; n = 0 ; for ( c = rm -> rm_firstdatacol ; c < rm -> rm_cols ; c ++ ) { rc = & rm -> rm_col [ c ] ; if ( rc -> rc_error != 0 ) { ASSERT ( n < VDEV_RAIDZ_MAXPARITY ) ; tgts [ n ++ ] = c ; } } ASSERT ( rm -> rm_firstdatacol >= n ) ; code = vdev_raidz_reconstruct ( rm , tgts , n ) ; rv = raidz_checksum_verify ( vd -> v_spa , bp , data , bytes ) ; if ( rv == 0 ) { if ( parity_errors < rm -> rm_firstdatacol - n ) { n = raidz_parity_verify ( rm ) ; unexpected_errors += n ; ASSERT ( parity_errors + n <= rm -> rm_firstdatacol ) ; } done } } } unexpected_errors = 1 ; rm -> rm_missingdata = 0 ; rm -> rm_missingparity = 0 ; n = 0 ; for ( c = 0 ; c < rm -> rm_cols ; c ++ ) { rc = & rm -> rm_col [ c ] ; if ( rc -> rc_tried ) { continue ; } cvd = vdev_child ( vd , rc -> rc_devidx ) ; ASSERT ( cvd != NULL ) ; rc -> rc_error = cvd -> v_read ( cvd , NULL , rc -> rc_data , rc -> rc_offset , rc -> rc_size ) ; if ( rc -> rc_error == 0 ) { n ++ ; } rc -> rc_tried = 1 ; rc -> rc_skipped = 0 ; } if ( n > 0 ) { reconstruct } if ( total_errors > rm -> rm_firstdatacol ) { error = EIO ; } if ( total_errors < rm -> rm_firstdatacol && ( code = vdev_raidz_combrec ( vd -> v_spa , rm , bp , data , offset , bytes , total_errors , data_errors ) ) != 0 ) { if ( code != ( 1 << rm -> rm_firstdatacol ) - 1 ) { ( void ) raidz_parity_verify ( rm ) ; } } else { error = ECKSUM ; } done vdev_raidz_map_free ( rm ) ; return ( error ) ; } 