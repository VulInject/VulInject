pid_t path_spawn ( Shell_t * shp , const char * opath , register char * * argv , char * * envp , Pathcomp_t * libpath , int spawn ) { register char * path ; char * * xp = 0 , * xval , * libenv = ( libpath ?libpath -> lib : 0 ) ; Namval_t * np ; char * s , * v ; int r , n , pidsize ; pid_t pid = - 1 ; envp -- ; stakseek ( PATH_OFFSET ) ; pidsize = sfprintf ( stkstd , "*%d*" , spawn ?getpid ( ) : getppid ( ) ) ; stakputs ( opath ) ; opath = stakfreeze ( 1 ) + PATH_OFFSET + pidsize ; np = nv_search ( argv [ 0 ] , shp -> track_tree , 0 ) ; while ( libpath && ! libpath -> lib ) { libpath = libpath -> next ; } if ( libpath && ( ! np || nv_size ( np ) > 0 ) ) { char buff [ PATH_MAX + 1 ] ; char save [ PATH_MAX + 1 ] ; stakseek ( PATH_OFFSET ) ; stakputs ( opath ) ; path = stakptr ( PATH_OFFSET ) ; while ( ( n = readlink ( path , buff , PATH_MAX ) ) > 0 ) { buff [ n ] = 0 ; n = PATH_OFFSET ; r = 0 ; if ( ( v = strrchr ( path , '/' ) ) && * buff != '/' ) { if ( buff [ 0 ] == '.' && buff [ 1 ] == '.' && ( r = strlen ( path ) + 1 ) <= PATH_MAX ) { memcpy ( save , path , r ) ; } else { r = 0 ; } n += ( v + 1 - path ) ; } stakseek ( n ) ; stakputs ( buff ) ; stakputc ( 0 ) ; path = stakptr ( PATH_OFFSET ) ; if ( v && buff [ 0 ] == '.' && buff [ 1 ] == '.' ) { pathcanon ( path , 0 ) ; if ( r && access ( path , X_OK ) ) { memcpy ( path , save , r ) ; break ; } } if ( libenv = path_lib ( shp , libpath , path ) ) { break ; } } stakseek ( 0 ) ; } if ( libenv && ( v = strchr ( libenv , '=' ) ) ) { n = v - libenv ; * v = 0 ; np = nv_open ( libenv , shp -> var_tree , 0 ) ; * v = '=' ; s = nv_getval ( np ) ; stakputs ( libenv ) ; if ( s ) { stakputc ( ':' ) ; stakputs ( s , NULL ) ; } v = stakfreeze ( 1 ) ; r = 1 ; xp = envp + 1 ; while ( s = * xp ++ ) { if ( strneq ( s , v , n ) && s [ n ] == '=' ) { xval = * -- xp ; * xp = v ; r = 0 ; break ; } } if ( r ) { * envp -- = v ; xp = 0 ; } } if ( ! opath ) { opath = stakptr ( PATH_OFFSET ) ; } envp [ 0 ] = ( char * ) opath - ( PATH_OFFSET + pidsize ) ; envp [ 0 ] [ 0 ] = '_' ; envp [ 0 ] [ 1 ] = '=' ; sfsync ( sfstderr ) ; sh_sigcheck ( shp ) ; path = path_relative ( shp , opath ) ; if ( * path != '/' && path != opath ) { char * sp = ( char * ) malloc ( strlen ( path ) + 3 ) ; sp [ 0 ] = '.' ; sp [ 1 ] = '/' ; strcpy ( sp + 2 , path ) ; path = sp ; } if ( spawn && ! sh_isoption ( SH_PFSH ) ) { pid = _spawnveg ( shp , opath , & argv [ 0 ] , envp , spawn >> 1 ) ; } else { pid = path_pfexecve ( shp , opath , & argv [ 0 ] , envp , spawn ) ; } if ( xp ) { * xp = xval ; } if ( * path == '.' && path != opath ) { free ( path ) ; path = path_relative ( shp , opath ) ; } if ( pid > 0 ) { return ( pid ) ; } retry switch ( shp -> path_err = errno ) { case EACCES : case ENOEXEC : case EPERM : errno = ENOEXEC ; if ( spawn ) { if ( shp -> subshell ) { return ( - 1 ) ; } { if ( ( pid = fork ( ) ) > 0 ) { return ( pid ) ; } } _sh_fork ( shp , pid , 0 , ( int * ) 0 ) < 0 ; ( ( checkpt * ) shp -> jmplist ) -> mode = SH_JMPEXIT ; return ( - 1 ) ; } exscript ( shp , path , argv , envp ) ; case EACCES : { struct stat statb ; if ( stat ( path , & statb ) >= 0 ) { if ( S_ISDIR ( statb . st_mode ) ) { errno = EISDIR ; } if ( S_ISSOCK ( statb . st_mode ) ) { exscript ( shp , path , argv , envp ) ; } } } case ENAMETOOLONG : case EPERM : shp -> path_err = errno ; return ( - 1 ) ; case ENOTDIR : case ENOENT : case EINTR : case EMLINK : return ( - 1 ) ; case E2BIG : if ( shp -> xargmin ) { pid = path_xargs ( shp , opath , & argv [ 0 ] , envp , spawn ) ; if ( pid < 0 ) { retry } return ( pid ) ; } default : errormsg ( SH_DICT , ERROR_system ( ERROR_NOEXEC ) , e_exec , path ) ; } return 0 ; } 