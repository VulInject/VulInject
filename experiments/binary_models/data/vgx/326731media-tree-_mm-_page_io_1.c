int __swap_writepage ( struct page * page , struct writeback_control * wbc , bio_end_io_t end_write_func ) { struct bio * bio ; int ret ; struct swap_info_struct * sis = page_swap_info ( page ) ; VM_BUG_ON_PAGE ( ! PageSwapCache ( page ) , page ) ; if ( sis -> flags & SWP_FILE ) { struct kiocb kiocb ; struct file * swap_file = sis -> swap_file ; struct address_space * mapping = swap_file -> f_mapping ; struct bio_vec bv = { . bv_page = page . bv_len = PAGE_SIZE . bv_offset = 0 } ; struct iov_iter from ; iov_iter_bvec ( & from , ITER_BVEC | WRITE , & bv , 1 , PAGE_SIZE ) ; init_sync_kiocb ( & kiocb , swap_file ) ; kiocb . ki_pos = page_file_offset ( page ) ; set_page_writeback ( page ) ; unlock_page ( page ) ; ret = mapping -> a_ops -> direct_IO ( & kiocb , & from ) ; if ( ret == PAGE_SIZE ) { count_vm_event ( PSWPOUT , NULL ) ; ret = 0 ; } else { set_page_dirty ( page ) ; ClearPageReclaim ( page ) ; pr_err_ratelimited ( "Write error on dio swapfile (%llu)\n" , page_file_offset ( page ) ) ; } end_page_writeback ( page ) ; return ret ; } ret = bdev_write_page ( sis -> bdev , swap_page_sector ( page ) , page , wbc ) ; if ( ! ret ) { count_vm_event ( PSWPOUT ) ; return 0 ; } ret = 0 ; bio = get_swap_bio ( GFP_NOIO , page , end_write_func ) ; if ( bio == NULL ) { set_page_dirty ( page ) ; unlock_page ( page ) ; ret = - ENOMEM ; out } bio -> bi_opf = REQ_OP_WRITE | wbc_to_write_flags ( wbc ) ; count_vm_event ( PSWPOUT ) ; set_page_writeback ( page ) ; unlock_page ( page ) ; submit_bio ( bio ) ; out return ret ; } 