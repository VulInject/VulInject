struct pbsnode * create_alps_subnode ( struct pbsnode * parent , const char * node_id ) { pbsnode * subnode ; svrattrl * plist = NULL ; int bad ; int rc = PBSE_NONE ; subnode = new pbsnode ( node_id , NULL , false ) ; if ( subnode -> get_error ( ) != PBSE_NONE ) { delete subnode ; log_err ( ENOMEM , __func__ , "" ) ; return ( NULL ) ; } add_execution_slot ( subnode ) ; svr_clnodes ++ ; subnode -> nd_addrs = parent -> nd_addrs ; rc = mgr_set_node_attr ( subnode , node_attr_def , ND_ATR_LAST , plist , ATR_DFLAG_MGRD | ATR_DFLAG_MGWR , & bad , ( void * ) subnode , ATR_ACTION_ALTER , false ) ; if ( rc != PBSE_NONE ) { free ( subnode ) ; log_err ( rc , __func__ , "Couldn't set node attributes" ) ; return ( NULL ) ; } subnode -> nd_ntype = NTYPE_CLUSTER ; subnode -> parent = parent ; subnode -> nd_state &= ~ INUSE_NOHIERARCHY ; parent -> copy_properties ( subnode ) ; subnode -> lock_node ( __func__ , NULL , LOGLEVEL ) ; insert_node ( parent -> alps_subnodes , subnode ) ; return ( subnode ) ; } void * check_if_orphaned ( void * vp ) { char * node_name = ( char * ) vp ; char * rsv_id = NULL ; std :: string job_id ; batch_request * preq ; int handle = - 1 ; int retries = 0 ; struct pbsnode * pnode ; char log_buf [ LOCAL_LOG_BUF_SIZE ] ; if ( ( rsv_id = strchr ( node_name , ':' ) ) != NULL ) { * rsv_id = '\0' ; rsv_id ++ ; } else { return ( NULL ) ; } if ( alps_reservations . is_orphaned ( rsv_id , job_id ) == true ) { if ( ( pnode = find_nodebyname ( node_name ) ) != NULL ) { if ( ( pnode -> nd_state & ( INUSE_BUSY | INUSE_DOWN ) ) == 0 ) { snprintf ( log_buf , sizeof ( log_buf ) , "Node %s has an orphan but wasn't marked as busy. Marking as busy now." , node_name ) ; log_err ( - 1 , __func__ , log_buf ) ; update_node_state ( pnode , INUSE_BUSY ) ; } pnode -> unlock_node ( __func__ , NULL , LOGLEVEL ) ; } if ( ( preq = alloc_br ( PBS_BATCH_DeleteReservation ) ) == NULL ) { free ( node_name ) ; alps_reservations . remove_from_orphaned_list ( rsv_id ) ; return ( NULL ) ; } preq -> rq_extend = strdup ( rsv_id ) ; if ( ( pnode = get_next_login_node ( NULL ) ) != NULL ) { struct in_addr hostaddr ; int local_errno ; pbs_net_t momaddr ; memcpy ( & hostaddr , & pnode -> nd_sock_addr . sin_addr , sizeof ( hostaddr ) ) ; momaddr = ntohl ( hostaddr . s_addr ) ; snprintf ( log_buf , sizeof ( log_buf ) , "Found orphan ALPS reservation ID %s for job %s; asking %s to remove it" , rsv_id , job_id . c_str ( ) , pnode -> get_name ( ) ) ; log_record ( PBSEVENT_DEBUG , PBS_EVENTCLASS_SERVER , __func__ , log_buf ) ; while ( ( handle < 0 ) && ( retries < 3 ) ) { handle = svr_connect ( momaddr , pnode -> nd_mom_port , & local_errno , pnode , NULL ) ; retries ++ ; } pnode -> unlock_node ( __func__ , NULL , LOGLEVEL ) ; if ( handle >= 0 ) { issue_Drequest ( handle , preq , true ) ; } free_br ( preq ) ; } alps_reservations . remove_from_orphaned_list ( rsv_id ) ; } free ( node_name ) ; return ( NULL ) ; } struct pbsnode * determine_node_from_str ( const char * str , struct pbsnode * parent , struct pbsnode * current ) { struct pbsnode * next = NULL ; const char * node_id = str + strlen ( "node=" ) ; if ( ( current == NULL ) || ( strcmp ( node_id , current -> get_name ( ) ) ) ) { if ( current != NULL ) { current -> unlock_node ( __func__ , NULL , LOGLEVEL ) ; } if ( ( next = find_alpsnode_by_name ( parent , node_id ) ) == NULL ) { next = create_alps_subnode ( parent , node_id ) ; } } else { next = current ; } if ( next != NULL ) { next -> nd_lastupdate = time ( NULL ) ; } return ( next ) ; } int set_ncpus ( struct pbsnode * current , struct pbsnode * parent , int ncpus ) { int difference ; int i ; int orig_svr_clnodes ; if ( current == NULL ) { return ( PBSE_BAD_PARAMETER ) ; } difference = ncpus - current -> nd_slots . get_total_execution_slots ( ) ; orig_svr_clnodes = svr_clnodes ; for ( i = 0 ; i < abs ( difference ) ; i ++ ) { if ( difference > 0 ) { add_execution_slot ( current ) ; svr_clnodes ++ ; } if ( difference < 0 ) { delete_a_subnode ( current ) ; svr_clnodes -- ; } } if ( difference < 0 ) { snprintf ( log_buffer , sizeof ( log_buffer ) , "ncpus was reduced from %d to %d" , orig_svr_clnodes , svr_clnodes ) ; log_record ( PBSEVENT_SYSTEM , PBS_EVENTCLASS_NODE , __func__ , log_buffer ) ; } if ( current -> nd_slots . get_total_execution_slots ( ) > parent -> max_subnode_nppn ) { parent -> max_subnode_nppn = current -> nd_slots . get_total_execution_slots ( ) ; } return ( PBSE_NONE ) ; } int set_state ( struct pbsnode * pnode , const char * str ) { const char * state_str = str + strlen ( "state=" ) ; if ( pnode == NULL ) { return ( PBSE_BAD_PARAMETER ) ; } if ( ! strcmp ( state_str , "UP" ) ) { update_node_state ( pnode , INUSE_FREE ) ; } if ( ! strcmp ( state_str , "DOWN" ) ) { update_node_state ( pnode , INUSE_DOWN ) ; } if ( ! strcmp ( state_str , "BUSY" ) ) { update_node_state ( pnode , INUSE_BUSY ) ; } return ( PBSE_NONE ) ; } void finish_gpu_status ( unsigned int & i , std :: vector ( std :: string ) & status_info ) { while ( i < status_info . size ( ) ) { if ( ! strcmp ( status_info [ i ] . c_str ( ) , CRAY_GPU_STATUS_END ) ) { break ; } i ++ ; } } int set_ngpus ( struct pbsnode * pnode , int gpu_count ) { int difference = gpu_count - pnode -> nd_ngpus ; int i ; for ( i = 0 ; i < difference ; i ++ ) { if ( create_a_gpusubnode ( pnode ) != PBSE_NONE ) { log_err ( ENOMEM , __func__ , "" ) ; return ( PBSE_SYSTEM ) ; } } return ( PBSE_NONE ) ; } int process_gpu_status ( struct pbsnode * pnode , unsigned int & i , std :: vector ( std :: string ) & status_info ) { pbs_attribute temp ; int gpu_count = 0 ; int rc = PBSE_NONE ; char buf [ MAXLINE * 2 ] ; std :: string gpu_info = "" ; } 