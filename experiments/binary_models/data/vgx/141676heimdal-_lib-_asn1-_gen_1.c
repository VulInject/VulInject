define_asn1 ( , ) { switch ( t -> type ) { case TType : if ( ! t -> symbol && t -> typeref . iosclass ) { fprintf ( headerfile , "%s.&%s" , t -> typeref . iosclass -> symbol -> name , t -> typeref . field -> name ) ; } if ( t -> symbol ) { fprintf ( headerfile , "%s" , t -> symbol -> name ) ; } else { abort ( ) ; } break ; case TInteger : if ( t -> members == NULL ) { fprintf ( headerfile , "INTEGER" ) ; if ( t -> range ) { fprintf ( headerfile , " (%lld..%lld)" , ( long long ) t -> range -> min , ( long long ) t -> range -> max ) ; } } else { Member * m ; fprintf ( headerfile , "INTEGER {\n" ) ; HEIM_TAILQ_FOREACH ( , , ) { space ( level + 1 ) ; fprintf ( headerfile , "%s(%lld)%s\n" , m -> gen_name , ( long long ) m -> val , last_member_p ( m ) ) ; } space ( level ) ; fprintf ( headerfile , "}" ) ; } break ; case TBoolean : fprintf ( headerfile , "BOOLEAN" ) ; break ; case TOctetString : fprintf ( headerfile , "OCTET STRING" ) ; break ; case TEnumerated : case TBitString : { Member * m ; space ( level ) ; if ( t -> type == TBitString ) { fprintf ( headerfile , "BIT STRING {\n" ) ; } else { fprintf ( headerfile , "ENUMERATED {\n" ) ; } HEIM_TAILQ_FOREACH ( , , ) { space ( level + 1 ) ; fprintf ( headerfile , "%s(%lld)%s\n" , m -> name , ( long long ) m -> val , last_member_p ( m ) ) ; } space ( level ) ; fprintf ( headerfile , "}" ) ; break ; } case TChoice : case TSet : case TSequence : { Member * m ; int max_width = 0 ; if ( t -> type == TChoice ) { fprintf ( headerfile , "CHOICE {\n" ) ; } if ( t -> type == TSet ) { fprintf ( headerfile , "SET {\n" ) ; } else { fprintf ( headerfile , "SEQUENCE {\n" ) ; } HEIM_TAILQ_FOREACH ( , , ) { if ( strlen ( m -> name ) > max_width ) { max_width = strlen ( m -> name ) ; } } max_width += 3 ; if ( max_width < 16 ) { max_width = 16 ; } HEIM_TAILQ_FOREACH ( , , ) { size_t width = max_width ; space ( level + 1 ) ; if ( m -> ellipsis ) { fprintf ( headerfile , "..." ) ; } else { width -= fprintf ( headerfile , "%s" , m -> name ) ; fprintf ( headerfile , "%*s" , ( int ) width , "" ) ; define_asn1 ( level + 1 , m -> type ) ; if ( m -> optional ) { fprintf ( headerfile , " OPTIONAL" ) ; } } if ( last_member_p ( m ) ) { fprintf ( headerfile , "," ) ; } fprintf ( headerfile , "\n" ) ; } space ( level ) ; fprintf ( headerfile , "}" ) ; break ; } case TSequenceOf : fprintf ( headerfile , "SEQUENCE OF " ) ; define_asn1 ( 0 , t -> subtype ) ; break ; case TSetOf : fprintf ( headerfile , "SET OF " ) ; define_asn1 ( 0 , t -> subtype ) ; break ; case TGeneralizedTime : fprintf ( headerfile , "GeneralizedTime" ) ; break ; case TGeneralString : fprintf ( headerfile , "GeneralString" ) ; break ; case TTeletexString : fprintf ( headerfile , "TeletexString" ) ; break ; case TTag : { const char * classnames [ ] { "UNIVERSAL " "APPLICATION " "" "PRIVATE " } ; ; if ( t -> tag . tagclass != ASN1_C_UNIV ) { fprintf ( headerfile , "[%s%d] " , classnames [ t -> tag . tagclass ] , t -> tag . tagvalue ) ; } if ( t -> tag . tagenv == TE_IMPLICIT ) { fprintf ( headerfile , "IMPLICIT " ) ; } define_asn1 ( level , t -> subtype ) ; break ; } case TUTCTime : fprintf ( headerfile , "UTCTime" ) ; break ; case TUTF8String : space ( level ) ; fprintf ( headerfile , "UTF8String" ) ; break ; case TPrintableString : space ( level ) ; fprintf ( headerfile , "PrintableString" ) ; break ; case TIA5String : space ( level ) ; fprintf ( headerfile , "IA5String" ) ; break ; case TBMPString : space ( level ) ; fprintf ( headerfile , "BMPString" ) ; break ; case TUniversalString : space ( level ) ; fprintf ( headerfile , "UniversalString" ) ; break ; case TVisibleString : space ( level ) ; fprintf ( headerfile , "VisibleString" ) ; break ; case TOID : space ( level ) ; fprintf ( headerfile , "OBJECT IDENTIFIER" ) ; break ; case TNull : space ( level ) ; fprintf ( headerfile , "NULL" ) ; break ; default : abort ( ) ; } } 