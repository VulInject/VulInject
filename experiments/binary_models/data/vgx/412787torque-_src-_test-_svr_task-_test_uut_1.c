START_TEST ( ) { work_task ptask1 ; work_task ptask2 ; work_task ptask3 ; work_task * wt ; int rc ; ptask1 . wt_mutex = ( pthread_mutex_t * ) calloc ( 1 , sizeof ( pthread_mutex_t ) ) ; pthread_mutex_init ( ptask1 . wt_mutex , NULL ) ; memset ( & ptask2 , 0 , sizeof ( ptask2 ) ) ; ptask2 . wt_mutex = ( pthread_mutex_t * ) calloc ( 1 , sizeof ( pthread_mutex_t ) ) ; pthread_mutex_init ( ptask2 . wt_mutex , NULL ) ; memset ( & ptask3 , 0 , sizeof ( ptask3 ) ) ; ptask3 . wt_mutex = ( pthread_mutex_t * ) calloc ( 1 , sizeof ( pthread_mutex_t ) ) ; pthread_mutex_init ( ptask3 . wt_mutex , NULL ) ; if ( task_list_timed == NULL ) { task_list_timed = new std :: list ( timed_task ) ( ) ; } ptask1 . wt_event = 100 ; ptask2 . wt_event = 200 ; ptask3 . wt_event = 300 ; insert_timed_task ( & ptask1 ) ; insert_timed_task ( & ptask2 ) ; insert_timed_task ( & ptask3 ) ; fail_unless ( pop_timed_task ( 0 ) == NULL ) ; fail_unless ( pop_timed_task ( 99 ) == NULL ) ; wt = pop_timed_task ( 150 ) ; fail_unless ( wt != NULL ) ; rc = pthread_mutex_trylock ( wt -> wt_mutex ) ; fail_unless ( rc == EBUSY ) ; fail_unless ( wt -> wt_event == 100 ) ; fail_unless ( pop_timed_task ( 150 ) == NULL ) ; wt = pop_timed_task ( 350 ) ; fail_unless ( wt != NULL ) ; fail_unless ( wt -> wt_event == 200 ) ; wt = pop_timed_task ( 350 ) ; fail_unless ( wt != NULL ) ; fail_unless ( wt -> wt_event == 300 ) ; wt = pop_timed_task ( 350 ) ; fail_unless ( wt == NULL ) ; } END_TEST START_TEST ( test_one ) { int rc ; task_list_event . tasks . clear ( ) ; initialize_task_recycler ( ) ; if ( task_list_timed == NULL ) { task_list_timed = new std :: list ( timed_task ) ( ) ; } rc = initialize_threadpool ( & request_pool , 5 , 50 , 60 ) ; fail_unless ( rc == PBSE_NONE , "initalize_threadpool failed" , rc ) ; struct work_task * pWorkTask = set_task ( WORK_Timed , 357 , check_nodes , NULL , 0 ) ; fail_unless ( pWorkTask != NULL ) ; struct work_task * pWorkTask2 = set_task ( WORK_Timed , 356 , check_nodes , NULL , 0 ) ; fail_unless ( pWorkTask2 != NULL ) ; struct work_task * pWorkTask3 = set_task ( WORK_Timed , 358 , check_nodes , NULL , 0 ) ; fail_unless ( pWorkTask3 != NULL ) ; rc = dispatch_task ( pWorkTask ) ; fail_unless ( rc == PBSE_NONE , "dispatch_task failed" , rc ) ; delete_task ( pWorkTask ) ; std :: vector ( work_task * ) :: iterator iter = tr . tasks . tasks . end ( ) ; struct work_task * pRecycled = next_task_from_recycler ( & tr . tasks , iter ) ; fprintf ( stderr , "%p %p\n" , ( void * ) pWorkTask , ( void * ) pRecycled ) ; fail_unless ( pRecycled == pWorkTask ) ; fail_unless ( task_is_in_threadpool ( pWorkTask2 ) ) ; } END_TEST Suite * svr_task_suite ( void ) { Suite * s = suite_create ( "svr_task_suite methods" ) ; TCase * tc_core = tcase_create ( "test_one" ) ; tcase_add_test ( tc_core , test_one ) ; suite_add_tcase ( s , tc_core ) ; tc_core = tcase_create ( "can_dispatch_task_test" ) ; tcase_add_test ( tc_core , can_dispatch_task_test ) ; tcase_add_test ( tc_core , manage_timed_task_test ) ; tcase_add_test ( tc_core , dispatch_timed_task_test ) ; suite_add_tcase ( s , tc_core ) ; return s ; } void rundebug ( ) { } int main ( void ) { int number_failed = 0 ; SRunner * sr = NULL ; rundebug ( ) ; sr = srunner_create ( svr_task_suite ( ) ) ; srunner_set_log ( sr , "svr_task_suite.log" ) ; srunner_run_all ( sr , CK_NORMAL ) ; number_failed = srunner_ntests_failed ( sr ) ; srunner_free ( sr ) ; return number_failed ; } 