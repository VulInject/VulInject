static int __init omap_hsmmc_pdata_init ( struct omap2_hsmmc_info * c , struct omap_hsmmc_platform_data * mmc ) { char * hc_name ; hc_name = kzalloc ( sizeof ( char ) * ( HSMMC_NAME_LEN + 1 ) , GFP_KERNEL ) ; if ( ! hc_name ) { pr_err ( "Cannot allocate memory for controller slot name\n" ) ; kfree ( hc_name ) ; return - ENOMEM ; } if ( c -> name ) { strncpy ( hc_name , c -> name , HSMMC_NAME_LEN ) ; } else { snprintf ( hc_name , ( HSMMC_NAME_LEN + 1 ) , "mmc%islot%i" , c -> mmc , 1 ) ; } mmc -> name = hc_name ; mmc -> caps = c -> caps ; mmc -> internal_clock = ! c -> ext_clock ; mmc -> reg_offset = 0 ; if ( c -> cover_only ) { mmc -> gpio_cd = - EINVAL ; mmc -> gpio_cod = c -> gpio_cd ; } else { mmc -> gpio_cd = c -> gpio_cd ; mmc -> gpio_cod = - EINVAL ; } mmc -> gpio_wp = c -> gpio_wp ; mmc -> remux = c -> remux ; mmc -> init_card = c -> init_card ; if ( c -> nonremovable ) { mmc -> nonremovable = 1 ; } if ( soc_is_am35xx ( ) ) { mmc -> ocr_mask = MMC_VDD_165_195 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 ; } else { mmc -> ocr_mask = c -> ocr_mask ; } if ( ! soc_is_am35xx ( ) ) { mmc -> features |= HSMMC_HAS_PBIAS ; } switch ( c -> mmc ) { case 1 : if ( mmc -> features & HSMMC_HAS_PBIAS ) { mmc -> before_set_reg = omap_hsmmc1_before_set_reg ; mmc -> after_set_reg = omap_hsmmc1_after_set_reg ; } if ( soc_is_am35xx ( ) ) { mmc -> set_power = nop_mmc_set_power ; } if ( cpu_is_omap3630 ( ) && ( c -> caps & MMC_CAP_8_BIT_DATA ) ) { c -> caps &= ~ MMC_CAP_8_BIT_DATA ; c -> caps |= MMC_CAP_4_BIT_DATA ; mmc -> caps = c -> caps ; } break ; case 2 : if ( soc_is_am35xx ( ) ) { mmc -> set_power = am35x_hsmmc2_set_power ; } if ( c -> ext_clock ) { c -> transceiver = 1 ; } if ( c -> transceiver && ( c -> caps & MMC_CAP_8_BIT_DATA ) ) { c -> caps &= ~ MMC_CAP_8_BIT_DATA ; c -> caps |= MMC_CAP_4_BIT_DATA ; } if ( mmc -> features & HSMMC_HAS_PBIAS ) { mmc -> before_set_reg = hsmmc2_before_set_reg ; } break ; case 3 : case 4 : case 5 : mmc -> before_set_reg = NULL ; mmc -> after_set_reg = NULL ; break ; default : pr_err ( "MMC%d configuration not supported!\n" , c -> mmc ) ; kfree ( hc_name ) ; return - ENODEV ; } return 0 ; } 