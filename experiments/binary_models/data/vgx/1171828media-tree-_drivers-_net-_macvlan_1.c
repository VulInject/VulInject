static int macvlan_changelink ( struct net_device * dev , struct nlattr * tb [ ] , struct nlattr * data [ ] ) { struct macvlan_dev * vlan = netdev_priv ( dev ) ; enum macvlan_mode mode ; bool set_mode = false ; enum macvlan_macaddr_mode macmode ; int ret ; if ( data && data [ IFLA_MACVLAN_MODE ] ) { set_mode = true ; mode = nla_get_u32 ( data [ IFLA_MACVLAN_MODE ] ) ; if ( ( mode == MACVLAN_MODE_PASSTHRU ) != ( vlan -> mode == MACVLAN_MODE_PASSTHRU ) ) { return - EINVAL ; } if ( vlan -> mode == MACVLAN_MODE_SOURCE && vlan -> mode != mode ) { macvlan_flush_sources ( vlan -> port , vlan ) ; } } if ( data && data [ IFLA_MACVLAN_FLAGS ] ) { __u16 flags = nla_get_u16 ( data [ IFLA_MACVLAN_FLAGS ] ) ; bool promisc = ( flags ^ vlan -> flags ) & MACVLAN_FLAG_NOPROMISC ; if ( vlan -> port -> passthru && promisc ) { int err ; if ( flags & MACVLAN_FLAG_NOPROMISC ) { err = dev_set_promiscuity ( vlan -> lowerdev , - 1 ) ; } else { err = dev_set_promiscuity ( vlan -> lowerdev , 1 ) ; } if ( err < 0 ) { return err ; } } vlan -> flags = flags ; } if ( set_mode ) { vlan -> mode = mode ; } if ( data && data [ IFLA_MACVLAN_MACADDR_MODE ] ) { macmode = nla_get_u32 ( data [ IFLA_MACVLAN_MACADDR_MODE ] ) ; ret = macvlan_changelink_sources ( vlan , macmode , data ) ; if ( ret ) { return ret ; } } return 0 ; } 