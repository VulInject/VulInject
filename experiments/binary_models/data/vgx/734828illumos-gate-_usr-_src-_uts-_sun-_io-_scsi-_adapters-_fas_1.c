static int fas_do_scsi_abort ( struct scsi_address * ap , struct scsi_pkt * pkt ) { struct fas * fas = ADDR2FAS ( ap ) ; struct fas_cmd * sp ; int rval = FALSE ; short slot ; struct fas_cmd * cur_sp = fas -> f_current_sp ; void ( * cur_savec ) ( ) ( * sp_savec ) ( ) ; int sp_tagged_flag , abort_msg ; if ( pkt ) { sp = PKT2CMD ( pkt ) ; slot = sp -> cmd_slot ; ASSERT ( slot == ( ( ap -> a_target * NLUNS_PER_TARGET ) | ap -> a_lun ) ) ; } else { sp = NULL ; slot = ( ap -> a_target * NLUNS_PER_TARGET ) | ap -> a_lun ; } fas_move_waitQ_to_readyQ ( fas ) ; ASSERT ( mutex_owned ( FAS_MUTEX ( fas ) ) ) ; IPRINTF4 ( "fas_scsi_abort for slot %x, " "sp=0x%p, pkt_flags=%x, cur_sp=0x%p\n" , slot , ( void * ) sp , ( sp ?sp -> cmd_pkt_flags : 0 ) , ( void * ) cur_sp ) ; if ( sp ) { IPRINTF3 ( "aborting one command 0x%p for %d.%d\n" , ( void * ) sp , ap -> a_target , ap -> a_lun ) ; rval = fas_remove_from_readyQ ( fas , sp , slot ) ; if ( rval ) { IPRINTF ( "aborted one ready cmd\n" ) ; fas_set_pkt_reason ( fas , sp , CMD_ABORTED , STAT_ABORTED ) ; fas_decrement_ncmds ( fas , sp ) ; fas_call_pkt_comp ( fas , sp ) ; exit } if ( ( sp != fas -> f_active [ slot ] -> f_slot [ sp -> cmd_tag [ 1 ] ] ) ) { IPRINTF ( "cmd doesn't exist here\n" ) ; rval = TRUE ; exit } } fas_set_throttles ( fas , slot , 1 , HOLD_THROTTLE ) ; if ( cur_sp ) { cur_savec = cur_sp -> cmd_pkt -> pkt_comp ; } if ( sp ) { sp_tagged_flag = ( sp -> cmd_pkt_flags & FLAG_TAGMASK ) ; abort_msg = ( sp_tagged_flag ?MSG_ABORT_TAG : MSG_ABORT ) ; sp_savec = sp -> cmd_pkt -> pkt_comp ; sp -> cmd_pkt -> pkt_comp = NULL ; if ( ( sp == cur_sp ) && ( fas -> f_state != STATE_FREE ) && ( sp -> cmd_pkt -> pkt_state ) ) { rval = fas_abort_connected_cmd ( fas , sp , abort_msg ) ; } if ( ( rval == 0 ) && ( sp -> cmd_flags & CFLAG_CMDDISC ) && ( ( sp -> cmd_flags & CFLAG_COMPLETED ) == 0 ) ) { rval = fas_abort_disconnected_cmd ( fas , ap , sp , abort_msg , slot ) ; } if ( rval ) { sp -> cmd_flags |= CFLAG_COMPLETED ; fas_set_pkt_reason ( fas , sp , CMD_ABORTED , STAT_ABORTED ) ; } sp -> cmd_pkt -> pkt_comp = sp_savec ; } else { IPRINTF2 ( "aborting all commands for %d.%d\n" , ap -> a_target , ap -> a_lun ) ; abort_msg = MSG_ABORT ; if ( cur_sp && ( fas -> f_state != STATE_FREE ) && ( cur_sp -> cmd_slot == slot ) && cur_sp -> cmd_pkt -> pkt_state ) { rval = fas_abort_connected_cmd ( fas , cur_sp , abort_msg ) ; } if ( rval == 0 ) { rval = fas_abort_disconnected_cmd ( fas , ap , NULL , abort_msg , slot ) ; } } done if ( cur_sp ) { cur_sp -> cmd_pkt -> pkt_comp = cur_savec ; if ( cur_sp -> cmd_flags & CFLAG_COMPLETED ) { fas_remove_cmd ( fas , cur_sp , NEW_TIMEOUT ) ; cur_sp -> cmd_flags &= ~ CFLAG_COMPLETED ; fas_decrement_ncmds ( fas , cur_sp ) ; fas_call_pkt_comp ( fas , cur_sp ) ; } } if ( sp && ( sp != cur_sp ) && ( sp -> cmd_flags & CFLAG_COMPLETED ) ) { sp -> cmd_flags &= ~ CFLAG_COMPLETED ; fas_remove_cmd ( fas , sp , NEW_TIMEOUT ) ; fas_decrement_ncmds ( fas , sp ) ; fas_call_pkt_comp ( fas , sp ) ; } if ( rval && ( abort_msg == MSG_ABORT ) ) { fas_mark_packets ( fas , slot , CMD_ABORTED , STAT_ABORTED ) ; fas_flush_tagQ ( fas , slot ) ; fas_flush_readyQ ( fas , slot ) ; } fas_set_throttles ( fas , slot , 1 , MAX_THROTTLE ) ; exit if ( fas -> f_state == STATE_FREE ) { ( void ) fas_ustart ( fas ) ; } ASSERT ( mutex_owned ( FAS_MUTEX ( fas ) ) ) ; if ( rval && fas_test_stop ) { debug_enter ( "abort succeeded" ) ; } return ( rval ) ; } 