static void limit_caldata ( icalcomponent * ical , struct icalperiodtype * limit ) { icaltime_span limitspan ; icaltimetype dtstart , dtend , recurid ; struct icaldurationtype dtduration = icaldurationtype_null_duration ( ) ; icalcomponent * comp , * nextcomp ; icalcomponent_kind kind ; limitspan . start = icaltime_as_timet_with_zone ( limit -> start , utc_zone ) ; limitspan . end = icaltime_as_timet_with_zone ( limit -> end , utc_zone ) ; comp = icalcomponent_get_first_real_component ( ical ) ; kind = icalcomponent_isa ( comp ) ; for ( ; comp ; comp = icalcomponent_get_next_component ( ical , kind ) ) { recurid = icalcomponent_get_recurrenceid_with_zone ( comp ) ; if ( icaltime_is_null_time ( recurid ) ) { dtstart = icalcomponent_get_dtstart ( comp ) ; dtend = icalcomponent_get_dtend ( comp ) ; dtduration = icaltime_subtract ( dtend , dtstart ) ; break ; } } for ( comp = icalcomponent_get_first_component ( ical , kind ) ; comp ; comp = nextcomp ) { icaltime_span recurspan ; nextcomp = icalcomponent_get_next_component ( ical , kind ) ; recurid = icalcomponent_get_recurrenceid_with_zone ( comp ) ; dtstart = icalcomponent_get_dtstart ( comp ) ; dtend = icalcomponent_get_dtend ( comp ) ; recurspan = icaltime_span_new ( dtstart , dtend , 1 ) ; if ( icaltime_span_overlaps ( & recurspan , & limitspan ) ) { continue ; } dtstart = recurid ; dtend = icaltime_add ( dtstart , dtduration ) ; recurspan = icaltime_span_new ( dtstart , dtend , 1 ) ; if ( icaltime_span_overlaps ( & recurspan , & limitspan ) ) { continue ; } icalcomponent_remove_component ( ical , comp ) ; icalcomponent_free ( comp ) ; } } 