static int __event__synthesize_thread ( union perf_event * comm_event , union perf_event * mmap_event , union perf_event * fork_event , union perf_event * namespaces_event , pid_t pid , int full , perf_event__handler_t process , struct perf_tool * tool , struct machine * machine , bool mmap_data , unsigned int proc_map_timeout ) { int filename [ PATH_MAX ] ; DIR * tasks ; struct dirent * dirent ; pid_t tgid , ppid ; int rc = 0 ; if ( ! full ) { tgid = perf_event__synthesize_comm ( tool , comm_event , pid , process , machine ) ; if ( tgid == - 1 ) { return - 1 ; } if ( perf_event__synthesize_namespaces ( tool , namespaces_event , pid , tgid , process , machine ) < 0 ) { return - 1 ; } return perf_event__synthesize_mmap_events ( tool , mmap_event , pid , tgid , process , machine , mmap_data , proc_map_timeout ) ; } if ( machine__is_default_guest ( machine ) ) { return 0 ; } snprintf ( filename , sizeof ( filename ) , "%s/proc/%d/task" , machine -> root_dir , pid ) ; tasks = opendir ( filename ) ; if ( tasks == NULL ) { pr_debug ( "couldn't open %s\n" , filename ) ; return 0 ; } while ( ( dirent = readdir ( tasks ) ) != NULL ) { char * end ; pid_t _pid ; _pid = strtol ( dirent -> d_name , & end , 10 ) ; if ( * end ) { continue ; } rc = - 1 ; if ( perf_event__prepare_comm ( comm_event , _pid , machine , & tgid , & ppid ) != 0 ) { break ; } if ( perf_event__synthesize_fork ( tool , fork_event , _pid , tgid , ppid , process , machine ) < 0 ) { break ; } if ( perf_event__synthesize_namespaces ( tool , namespaces_event , _pid , tgid , process , machine ) < 0 ) { break ; } if ( perf_tool__process_synth_event ( tool , comm_event , machine , process ) != 0 ) { break ; } rc = 0 ; if ( _pid == pid ) { rc = perf_event__synthesize_mmap_events ( tool , mmap_event , pid , tgid , process , machine , mmap_data , proc_map_timeout ) ; if ( rc ) { break ; } } } closedir ( tasks ) ; return rc ; } 