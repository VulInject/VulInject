int ixgbe_disable_sriov ( struct ixgbe_adapter * adapter ) { unsigned int num_vfs = adapter -> num_vfs , vf ; struct ixgbe_hw * hw = & adapter -> hw ; u32 gpie ; u32 vmdctl ; int rss ; adapter -> num_vfs = 0 ; for ( vf = 0 ; vf < num_vfs ; ++ vf ) { struct pci_dev * vfdev = adapter -> vfinfo [ vf ] . vfdev ; if ( ! vfdev ) { continue ; } adapter -> vfinfo [ vf ] . vfdev = NULL ; pci_dev_put ( vfdev ) ; } kfree ( adapter -> vfinfo ) ; adapter -> vfinfo = NULL ; adapter -> mv_list = NULL ; if ( ! ( adapter -> flags & IXGBE_FLAG_SRIOV_ENABLED ) ) { return 0 ; } if ( pci_vfs_assigned ( adapter -> pdev ) ) { e_dev_warn ( "Unloading driver while VFs are assigned - VFs will not be deallocated\n" ) ; return - EPERM ; } pci_disable_sriov ( adapter -> pdev ) ; IXGBE_WRITE_REG ( hw , IXGBE_GCR_EXT , 0 ) ; gpie = IXGBE_READ_REG ( hw , IXGBE_GPIE ) ; gpie &= ~ IXGBE_GPIE_VTMODE_MASK ; IXGBE_WRITE_REG ( hw , IXGBE_GPIE , gpie ) ; vmdctl = IXGBE_READ_REG ( hw , IXGBE_VT_CTL ) ; vmdctl &= ~ IXGBE_VT_CTL_POOL_MASK ; IXGBE_WRITE_REG ( hw , IXGBE_VT_CTL , vmdctl ) ; IXGBE_WRITE_FLUSH ( hw ) ; if ( adapter -> ring_feature [ RING_F_VMDQ ] . limit == 1 ) { adapter -> flags &= ~ IXGBE_FLAG_VMDQ_ENABLED ; adapter -> flags &= ~ IXGBE_FLAG_SRIOV_ENABLED ; rss = min_t ( int , ixgbe_max_rss_indices ( adapter ) , num_online_cpus ( ) ) ; } else { rss = min_t ( int , IXGBE_MAX_L2A_QUEUES , num_online_cpus ( ) ) ; } adapter -> ring_feature [ RING_F_VMDQ ] . offset = 0 ; adapter -> ring_feature [ RING_F_RSS ] . limit = rss ; msleep ( 100 ) ; return 0 ; } 