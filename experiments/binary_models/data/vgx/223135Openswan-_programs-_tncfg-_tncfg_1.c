int main ( int argc , char * argv [ ] ) { struct ifreq ifr ; struct ipsectunnelconf shc ; int s ; int c ; int argcount = argc ; int createdelete = 0 ; char virtname [ 64 ] ; struct stat sts ; memset ( & ifr , 0 , sizeof ( ifr ) ) ; virtname [ 0 ] = '\0' ; progname = argv [ 0 ] ; tool_init_log ( ) ; while ( ( c = getopt_long_only ( argc , argv , "" , longopts , 0 ) ) != EOF ) { switch ( c ) { case 'g' : debug = 1 ; argcount -- ; break ; case 'a' : check_conflict ( shc . cf_cmd , createdelete ) ; shc . cf_cmd = IPSEC_SET_DEV ; break ; case 'd' : check_conflict ( shc . cf_cmd , createdelete ) ; shc . cf_cmd = IPSEC_DEL_DEV ; break ; case 'c' : check_conflict ( shc . cf_cmd , createdelete ) ; shc . cf_cmd = IPSEC_CLR_DEV ; break ; case 'h' : usage ( progname ) ; break ; case 'v' : if ( optarg ) { fprintf ( stderr , "%s: warning; '-v' and '--version' options don't expect arguments, arg '%s' found, perhaps unintended.\n" , progname , optarg ) ; } fprintf ( stdout , "%s, use ipsec --version instead\n" , progname ) ; exit ( 1 ) ; break ; case 'C' : check_conflict ( shc . cf_cmd , createdelete ) ; createdelete = SADB_X_PLUMBIF ; strncat ( virtname , optarg , sizeof ( virtname ) - 1 ) ; break ; case 'D' : check_conflict ( shc . cf_cmd , createdelete ) ; createdelete = SADB_X_UNPLUMBIF ; strncat ( virtname , optarg , sizeof ( virtname ) - 1 ) ; break ; case 'V' : strncpy ( ifr . ifr_name , optarg , sizeof ( ifr . ifr_name ) - 1 ) ; break ; case 'P' : strncpy ( shc . cf_name , optarg , sizeof ( shc . cf_name ) - 1 ) ; break ; case 'l' : { char * toolname = malloc ( strlen ( argv [ 0 ] ) + 10 + strlen ( optarg ) ) ; sprintf ( toolname , "%s --label %s" , argv [ 0 ] , optarg ) ; progname = toolname ; } argcount -= 2 ; break ; case '+' : optionsfrom ( optarg , & argc , & argv , optind , stderr ) ; break ; default : usage ( progname ) ; break ; } } if ( ( ( stat ( "/proc/net/pfkey" , & sts ) ) == 0 ) ) { fprintf ( stderr , "%s: NETKEY does not support virtual interfaces.\n" , progname ) ; exit ( 1 ) ; } if ( argcount == 1 ) { int ret = 1 ; if ( ( stat ( "/proc/net/ipsec_tncfg" , & sts ) ) != 0 ) { fprintf ( stderr , "%s: No tncfg - no IPsec support in kernel (are the modules loaded?)\n" , progname ) ; } else { ret = system ( "cat /proc/net/ipsec_tncfg" ) ; ret = ret != - 1 && WIFEXITED ( ret ) ?WEXITSTATUS ( ret ) : 1 ; } exit ( ret ) ; } if ( sizeof ( ifr . ifr_ifru ) < sizeof ( shc ) ) { fprintf ( stderr , "%s: Internal error: struct ipsectunnelconf won't fit inside struct ifreq\n" , progname ) ; exit ( 1 ) ; } memcpy ( & ifr . ifr_ifru . ifru_newname , & shc , sizeof ( shc ) ) ; if ( createdelete ) { exit ( createdelete_virtual ( createdelete , virtname ) ) ; } switch ( shc . cf_cmd ) { case IPSEC_SET_DEV : if ( ! shc . cf_name [ 0 ] ) { fprintf ( stderr , "%s: physical I/F parameter missing.\n" , progname ) ; exit ( 1 ) ; } case IPSEC_DEL_DEV : if ( ! ifr . ifr_name [ 0 ] ) { fprintf ( stderr , "%s: virtual I/F parameter missing.\n" , progname ) ; exit ( 1 ) ; } break ; case IPSEC_CLR_DEV : strncpy ( ifr . ifr_name , "ipsec0" , sizeof ( ifr . ifr_name ) ) ; break ; default : fprintf ( stderr , "%s: exactly one of '--attach', '--detach' or '--clear' options must be specified.\n" "Try %s --help' for usage information.\n" , progname , progname ) ; exit ( 1 ) ; } s = safe_socket ( AF_INET , SOCK_DGRAM , 0 ) ; if ( s == - 1 ) { fprintf ( stderr , "%s: Socket creation failed -- " , progname ) ; switch ( errno ) { case EACCES : if ( getuid ( ) == 0 ) { fprintf ( stderr , "Root denied permission!?!\n" ) ; } else { fprintf ( stderr , "Run as root user.\n" ) ; } break ; case EPROTONOSUPPORT : fprintf ( stderr , "Internet Protocol not enabled" ) ; break ; case EMFILE : case ENFILE : case ENOBUFS : fprintf ( stderr , "Insufficient system resources.\n" ) ; break ; case ENODEV : fprintf ( stderr , "No such device.  Is the virtual device valid?  Is the ipsec module linked into the kernel or loaded as a module?\n" ) ; break ; default : fprintf ( stderr , "Unknown socket error %d.\n" , errno ) ; } exit ( 1 ) ; } if ( ioctl ( s , shc . cf_cmd , & ifr ) == - 1 ) { switch ( shc . cf_cmd ) { case IPSEC_SET_DEV : fprintf ( stderr , "%s: Socket ioctl failed on attach -- " , progname ) ; switch ( errno ) { case EINVAL : fprintf ( stderr , "Invalid argument, check kernel log messages for specifics.\n" ) ; break ; case ENODEV : fprintf ( stderr , "No such device.  Is the virtual device valid?  Is the ipsec module linked into the kernel or loaded as a module?\n" ) ; break ; case ENXIO : fprintf ( stderr , "No such device.  Is the physical device valid?\n" ) ; break ; case EBUSY : fprintf ( stderr , "Device busy.  Virtual device %s is already attached to a physical device -- Use detach first.\n" , ifr . ifr_name ) ; break ; default : fprintf ( stderr , "Unknown socket error %d.\n" , errno ) ; } exit ( 1 ) ; case IPSEC_DEL_DEV : fprintf ( stderr , "%s: Socket ioctl failed on detach -- " , progname ) ; switch ( errno ) { case EINVAL : fprintf ( stderr , "Invalid argument, check kernel log messages for specifics.\n" ) ; break ; case ENODEV : fprintf ( stderr , "No such device.  Is the virtual device valid?  The ipsec module may not be linked into the kernel or loaded as a module.\n" ) ; break ; case ENXIO : fprintf ( stderr , "Device requested is not linked to any physical device.\n" ) ; break ; default : fprintf ( stderr , "Unknown socket error %d.\n" , errno ) ; } exit ( 1 ) ; case IPSEC_CLR_DEV : fprintf ( stderr , "%s: Socket ioctl failed on clear -- " , progname ) ; switch ( errno ) { case EINVAL : fprintf ( stderr , "Invalid argument, check kernel log messages for specifics.\n" ) ; break ; case ENODEV : fprintf ( stderr , "Failed.  Is the ipsec module linked into the kernel or loaded as a module?.\n" ) ; break ; default : fprintf ( stderr , "Unknown socket error %d.\n" , errno ) ; } exit ( 1 ) ; default : fprintf ( stderr , "%s: Socket ioctl failed on unknown operation %u -- %s" , progname , ( unsigned ) shc . cf_cmd , strerror ( errno ) ) ; exit ( 1 ) ; } } exit ( 0 ) ; } 