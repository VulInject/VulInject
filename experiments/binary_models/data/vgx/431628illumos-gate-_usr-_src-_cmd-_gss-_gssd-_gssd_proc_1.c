bool_t gss_inquire_cred_1_svc ( argp , res , rqstp ) gss_inquire_cred_arg * argp ; gss_inquire_cred_res * res ; struct svc_req * rqstp ; { uid_t uid ; OM_uint32 minor_status ; gss_cred_id_t cred_handle ; gss_buffer_desc external_name ; gss_OID name_type ; gss_name_t internal_name ; gss_OID_set mechanisms ; int i , j ; memset ( res , 0 , sizeof ( * res ) ) ; if ( gssd_debug ) { fprintf ( stderr , gettext ( "gss_inquire_cred\n" ) ) ; } if ( argp -> gssd_cred_verifier != gssd_time_verf ) { res -> name . GSS_BUFFER_T_val = NULL ; res -> name_type . GSS_OID_val = NULL ; res -> mechanisms . GSS_OID_SET_val = NULL ; res -> status = ( OM_uint32 ) GSS_S_DEFECTIVE_CREDENTIAL ; res -> minor_status = 0 ; return ( TRUE ) ; } if ( checkfrom ( rqstp , & uid ) == 0 ) { res -> name . GSS_BUFFER_T_val = NULL ; res -> name_type . GSS_OID_val = NULL ; res -> mechanisms . GSS_OID_SET_val = NULL ; return ( FALSE ) ; } uid = argp -> uid ; set_gssd_uid ( uid ) ; cred_handle = ( argp -> cred_handle . GSS_CRED_ID_T_len == 0 ?GSS_C_NO_CREDENTIAL : * ( ( gss_cred_id_t * ) argp -> cred_handle . GSS_CRED_ID_T_val ) ) ; res -> status = ( OM_uint32 ) gss_inquire_cred ( & res -> minor_status , cred_handle , & internal_name , & res -> lifetime , & res -> cred_usage , & mechanisms ) ; if ( res -> status != GSS_S_COMPLETE ) { syslog_gss_error ( res -> status , res -> minor_status , "inquire_cred" ) ; return ( TRUE ) ; } if ( gss_display_name ( & minor_status , internal_name , & external_name , & name_type ) != GSS_S_COMPLETE ) { res -> status = ( OM_uint32 ) GSS_S_FAILURE ; res -> minor_status = minor_status ; gss_release_name ( & minor_status , & internal_name ) ; if ( mechanisms != GSS_C_NULL_OID_SET ) { for ( i = 0 ; i < mechanisms -> count ; i ++ ) { free ( mechanisms -> elements [ i ] . elements ) ; } free ( mechanisms -> elements ) ; } return ( TRUE ) ; } res -> name . GSS_BUFFER_T_len = ( uint_t ) external_name . length ; res -> name . GSS_BUFFER_T_val = ( void * ) external_name . value ; res -> name_type . GSS_OID_len = ( uint_t ) name_type -> length ; res -> name_type . GSS_OID_val = ( void * ) malloc ( name_type -> length ) ; if ( ! res -> name_type . GSS_OID_val ) { return ( GSS_S_FAILURE ) ; } memcpy ( res -> name_type . GSS_OID_val , name_type -> elements , name_type -> length ) ; if ( mechanisms != GSS_C_NULL_OID_SET ) { res -> mechanisms . GSS_OID_SET_len = ( uint_t ) mechanisms -> count ; res -> mechanisms . GSS_OID_SET_val = ( GSS_OID * ) malloc ( sizeof ( GSS_OID ) * mechanisms -> count ) ; if ( ! res -> mechanisms . GSS_OID_SET_val ) { free ( res -> name_type . GSS_OID_val ) ; return ( GSS_S_FAILURE ) ; } for ( i = 0 ; i < mechanisms -> count ; i ++ ) { res -> mechanisms . GSS_OID_SET_val [ i ] . GSS_OID_len = ( uint_t ) mechanisms -> elements [ i ] . length ; res -> mechanisms . GSS_OID_SET_val [ i ] . GSS_OID_val = ( char * ) malloc ( mechanisms -> elements [ i ] . length ) ; if ( ! res -> mechanisms . GSS_OID_SET_val [ i ] . GSS_OID_val ) { free ( res -> name_type . GSS_OID_val ) ; for ( j = 0 ; j < i ; j ++ ) { free ( res -> mechanisms . GSS_OID_SET_val [ i ] . GSS_OID_val ) ; } free ( res -> mechanisms . GSS_OID_SET_val ) ; return ( GSS_S_FAILURE ) ; } memcpy ( res -> mechanisms . GSS_OID_SET_val [ i ] . GSS_OID_val , mechanisms -> elements [ i ] . elements , mechanisms -> elements [ i ] . length ) ; } } else { res -> mechanisms . GSS_OID_SET_len = 0 ; } gss_release_name ( & minor_status , & internal_name ) ; if ( mechanisms != GSS_C_NULL_OID_SET ) { for ( i = 0 ; i < mechanisms -> count ; i ++ ) { free ( mechanisms -> elements [ i ] . elements ) ; } free ( mechanisms -> elements ) ; free ( mechanisms ) ; } return ( TRUE ) ; } 