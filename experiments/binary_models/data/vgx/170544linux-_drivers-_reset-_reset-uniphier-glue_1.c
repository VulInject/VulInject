static int uniphier_glue_reset_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct uniphier_glue_reset_priv * priv ; struct resource * res ; int i , ret ; priv = devm_kzalloc ( dev , sizeof ( * priv ) , GFP_KERNEL ) ; priv -> data = of_device_get_match_data ( dev ) ; if ( WARN_ON ( ! priv -> data || priv -> data -> nclks > MAX_CLKS || priv -> data -> nrsts > MAX_RSTS ) ) { return - EINVAL ; } res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; priv -> rdata . membase = devm_ioremap_resource ( dev , res ) ; if ( IS_ERR ( priv -> rdata . membase ) ) { return PTR_ERR ( priv -> rdata . membase ) ; } for ( i = 0 ; i < priv -> data -> nclks ; i ++ ) { priv -> clk [ i ] . id = priv -> data -> clock_names [ i ] ; } ret = devm_clk_bulk_get ( dev , priv -> data -> nclks , priv -> clk ) ; if ( ret ) { return ret ; } for ( i = 0 ; i < priv -> data -> nrsts ; i ++ ) { priv -> rst [ i ] . id = priv -> data -> reset_names [ i ] ; } ret = devm_reset_control_bulk_get_shared ( dev , priv -> data -> nrsts , priv -> rst ) ; if ( ret ) { return ret ; } ret = clk_bulk_prepare_enable ( priv -> data -> nclks , priv -> clk ) ; if ( ret ) { return ret ; } ret = devm_add_action_or_reset ( dev , uniphier_clk_disable , priv ) ; if ( ret ) { return ret ; } ret = reset_control_bulk_deassert ( priv -> data -> nrsts , priv -> rst ) ; if ( ret ) { return ret ; } ret = devm_add_action_or_reset ( dev , uniphier_rst_assert , priv ) ; if ( ret ) { return ret ; } spin_lock_init ( & priv -> rdata . lock ) ; priv -> rdata . rcdev . owner = THIS_MODULE ; priv -> rdata . rcdev . nr_resets = resource_size ( res ) * BITS_PER_BYTE ; priv -> rdata . rcdev . ops = & reset_simple_ops ; priv -> rdata . rcdev . of_node = dev -> of_node ; priv -> rdata . active_low = true ; platform_set_drvdata ( pdev , priv ) ; return devm_reset_controller_register ( dev , & priv -> rdata . rcdev ) ; } 