void __init efi_free_boot_services ( void ) { struct efi_memory_map_data data = { 0 } ; efi_memory_desc_t * md ; int num_entries = 0 ; void * new , * new_md ; if ( efi_enabled ( EFI_DBG ) ) { return ; } for_each_efi_memory_desc ( ) { unsigned long long start = md -> phys_addr ; unsigned long long size = md -> num_pages << EFI_PAGE_SHIFT ; size_t rm_size ; if ( md -> type != EFI_BOOT_SERVICES_CODE && md -> type != EFI_BOOT_SERVICES_DATA ) { num_entries ++ ; continue ; } if ( md -> attribute & EFI_MEMORY_RUNTIME ) { num_entries ++ ; continue ; } efi_unmap_pages ( md ) ; rm_size = real_mode_size_needed ( ) ; if ( rm_size && ( start + rm_size ) < ( 1 << 20 ) && size >= rm_size ) { set_real_mode_mem ( start ) ; start += rm_size ; size -= rm_size ; } if ( start + size < SZ_1M ) { continue ; } if ( start < SZ_1M ) { size -= ( SZ_1M - start ) ; start = SZ_1M ; } memblock_free_late ( start , size ) ; } if ( efi_memmap_alloc ( num_entries , & data ) != 0 ) { pr_err ( "Failed to allocate new EFI memmap\n" ) ; return ; } new = memremap ( data . phys_map , data . size , MEMREMAP_WB ) ; if ( ! new ) { pr_err ( "Failed to map new EFI memmap\n" ) ; return ; } new_md = new ; for_each_efi_memory_desc ( ) { if ( ! ( md -> attribute & EFI_MEMORY_RUNTIME ) && ( md -> type == EFI_BOOT_SERVICES_CODE || md -> type == EFI_BOOT_SERVICES_DATA ) ) { continue ; } memcpy ( new_md , md , efi . memmap . desc_size ) ; new_md += efi . memmap . desc_size ; } memunmap ( new ) ; if ( efi_memmap_install ( & data ) != 0 ) { pr_err ( "Could not install new EFI memmap\n" ) ; return ; } } 