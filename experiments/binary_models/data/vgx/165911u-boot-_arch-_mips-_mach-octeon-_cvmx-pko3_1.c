int cvmx_pko3_hw_init_global ( int node , uint16_t aura ) { cvmx_pko_dpfi_flush_t pko_flush ; cvmx_pko_dpfi_fpa_aura_t pko_aura ; cvmx_pko_dpfi_ena_t dpfi_enable ; cvmx_pko_ptf_iobp_cfg_t ptf_iobp_cfg ; cvmx_pko_pdm_cfg_t pko_pdm_cfg ; cvmx_pko_enable_t pko_enable ; cvmx_pko_dpfi_status_t dpfi_status ; cvmx_pko_status_t pko_status ; cvmx_pko_shaper_cfg_t shaper_cfg ; u64 cycles ; const unsigned int timeout = 100 ; if ( node != ( aura >> 10 ) ) { cvmx_printf ( "WARNING: AURA vs PKO node mismatch\n" ) ; } pko_enable . u64 = csr_rd_node ( node , CVMX_PKO_ENABLE ) ; if ( pko_enable . s . enable ) { cvmx_printf ( "WARNING: %s: PKO already enabled on node %u\n" , __func__ , node ) ; return 0 ; } shaper_cfg . u64 = csr_rd_node ( node , CVMX_PKO_SHAPER_CFG ) ; shaper_cfg . s . color_aware = 1 ; csr_wr_node ( node , CVMX_PKO_SHAPER_CFG , shaper_cfg . u64 ) ; pko_flush . u64 = 0 ; pko_flush . s . flush_en = 0 ; csr_wr_node ( node , CVMX_PKO_DPFI_FLUSH , pko_flush . u64 ) ; pko_aura . u64 = 0 ; pko_aura . s . node = aura >> 10 ; pko_aura . s . laura = aura ; csr_wr_node ( node , CVMX_PKO_DPFI_FPA_AURA , pko_aura . u64 ) ; CVMX_DUMP_REGX ( CVMX_PKO_DPFI_FPA_AURA ) ; dpfi_enable . u64 = 0 ; dpfi_enable . s . enable = 1 ; csr_wr_node ( node , CVMX_PKO_DPFI_ENA , dpfi_enable . u64 ) ; cycles = get_timer ( 0 ) ; { pko_status . u64 = csr_rd_node ( node , CVMX_PKO_STATUS ) ; if ( get_timer ( cycles ) > timeout ) { break ; } } ! pko_status . s . pko_rdy ; if ( ! pko_status . s . pko_rdy ) { dpfi_status . u64 = csr_rd_node ( node , CVMX_PKO_DPFI_STATUS ) ; cvmx_printf ( "ERROR: %s: PKO DFPI failed, PKO_STATUS=%#llx DPFI_STATUS=%#llx\n" , __func__ , ( unsigned long long ) pko_status . u64 , ( unsigned long long ) dpfi_status . u64 ) ; return - 1 ; } ptf_iobp_cfg . u64 = csr_rd_node ( node , CVMX_PKO_PTF_IOBP_CFG ) ; if ( OCTEON_IS_MODEL ( OCTEON_CN78XX ) ) { ptf_iobp_cfg . s . max_read_size = 0x10 ; } else { ptf_iobp_cfg . s . max_read_size = 3 ; } csr_wr_node ( node , CVMX_PKO_PTF_IOBP_CFG , ptf_iobp_cfg . u64 ) ; pko_pdm_cfg . u64 = 0 ; pko_pdm_cfg . s . pko_pad_minlen = 0x3c ; csr_wr_node ( node , CVMX_PKO_PDM_CFG , pko_pdm_cfg . u64 ) ; cvmx_pko_setup_macs ( node , NULL ) ; pko_enable . u64 = 0 ; pko_enable . s . enable = 1 ; csr_wr_node ( node , CVMX_PKO_ENABLE , pko_enable . u64 ) ; pko_status . u64 = csr_rd_node ( node , CVMX_PKO_STATUS ) ; if ( pko_status . s . pko_rdy ) { return 0 ; } cvmx_printf ( "ERROR: %s: failed, PKO_STATUS=%#llx\n" , __func__ , ( unsigned long long ) pko_status . u64 ) ; return - 1 ; } 