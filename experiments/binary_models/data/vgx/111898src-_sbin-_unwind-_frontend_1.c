void frontend_dispatch_main ( int fd , short event , void * bula ) { static struct uw_conf * nconf ; struct imsg imsg ; struct imsgev * iev = bula ; struct imsgbuf * ibuf = & iev -> ibuf ; int n , shut ; if ( event & EV_READ ) { if ( ( n = imsg_read ( ibuf ) ) == - 1 && errno != EAGAIN ) { fatal ( "imsg_read error" ) ; } if ( n == 0 ) { shut = 1 ; } } if ( event & EV_WRITE ) { if ( ( n = msgbuf_write ( & ibuf -> w ) ) == - 1 && errno != EAGAIN ) { fatal ( "msgbuf_write" ) ; } if ( n == 0 ) { shut = 1 ; } } for ( ; ; ) { if ( ( n = imsg_get ( ibuf , & imsg ) ) == - 1 ) { fatal ( "%s: imsg_get error" , __func__ ) ; } if ( n == 0 ) { break ; } switch ( imsg . hdr . type ) { case IMSG_SOCKET_IPC_RESOLVER : if ( iev_resolver ) { fatalx ( "%s: received unexpected imsg fd " "to frontend" , __func__ ) ; break ; } if ( ( fd = imsg . fd ) == - 1 ) { fatalx ( "%s: expected to receive imsg fd to " "frontend but didn't receive any" , __func__ ) ; break ; } if ( iev_resolver != NULL ) { fatal ( "iev_resolver" ) ; } iev_resolver = malloc ( sizeof ( imsgev ) ) ; if ( iev_resolver == NULL ) { fatal ( NULL ) ; } imsg_init ( & iev_resolver -> ibuf , fd ) ; iev_resolver -> handler = frontend_dispatch_resolver ; iev_resolver -> events = EV_READ ; event_set ( & iev_resolver -> ev , iev_resolver -> ibuf . fd , iev_resolver -> events , iev_resolver -> handler , iev_resolver ) ; event_add ( & iev_resolver -> ev , NULL ) ; break ; case IMSG_RECONF_CONF : case IMSG_RECONF_BLOCKLIST_FILE : case IMSG_RECONF_FORWARDER : case IMSG_RECONF_DOT_FORWARDER : case IMSG_RECONF_FORCE : imsg_receive_config ( & imsg , & nconf ) ; break ; case IMSG_RECONF_END : if ( nconf == NULL ) { fatalx ( "%s: IMSG_RECONF_END without " "IMSG_RECONF_CONF" , __func__ ) ; } merge_config ( frontend_conf , nconf ) ; if ( frontend_conf -> blocklist_file == NULL ) { free_bl ( ) ; } nconf = NULL ; break ; case IMSG_UDP6SOCK : if ( udp6sock != - 1 ) { fatalx ( "%s: received unexpected udp6sock" , __func__ ) ; } if ( ( udp6sock = imsg . fd ) == - 1 ) { fatalx ( "%s: expected to receive imsg " "UDP6 fd but didn't receive any" , __func__ ) ; } event_set ( & udp6ev . ev , udp6sock , EV_READ | EV_PERSIST , udp_receive , & udp6ev ) ; event_add ( & udp6ev . ev , NULL ) ; break ; case IMSG_UDP4SOCK : if ( udp4sock != - 1 ) { fatalx ( "%s: received unexpected udp4sock" , __func__ ) ; } if ( ( udp4sock = imsg . fd ) == - 1 ) { fatalx ( "%s: expected to receive imsg " "UDP4 fd but didn't receive any" , __func__ ) ; } event_set ( & udp4ev . ev , udp4sock , EV_READ | EV_PERSIST , udp_receive , & udp4ev ) ; event_add ( & udp4ev . ev , NULL ) ; break ; case IMSG_TCP4SOCK : if ( tcp4sock != - 1 ) { fatalx ( "%s: received unexpected tcp4sock" , __func__ ) ; } if ( ( tcp4sock = imsg . fd ) == - 1 ) { fatalx ( "%s: expected to receive imsg " "TCP4 fd but didn't receive any" , __func__ ) ; } event_set ( & tcp4ev . ev , tcp4sock , EV_READ | EV_PERSIST , tcp_accept , & tcp4ev ) ; event_add ( & tcp4ev . ev , NULL ) ; evtimer_set ( & tcp4ev . pause , accept_paused , & tcp4ev ) ; break ; case IMSG_TCP6SOCK : if ( tcp6sock != - 1 ) { fatalx ( "%s: received unexpected tcp6sock" , __func__ ) ; } if ( ( tcp6sock = imsg . fd ) == - 1 ) { fatalx ( "%s: expected to receive imsg " "TCP6 fd but didn't receive any" , __func__ ) ; } event_set ( & tcp6ev . ev , tcp6sock , EV_READ | EV_PERSIST , tcp_accept , & tcp6ev ) ; event_add ( & tcp6ev . ev , NULL ) ; evtimer_set ( & tcp6ev . pause , accept_paused , & tcp6ev ) ; break ; case IMSG_ROUTESOCK : { static int routesock = - 1 ; if ( routesock != - 1 ) { fatalx ( "%s: received unexpected routesock" , __func__ ) ; } if ( ( fd = imsg . fd ) == - 1 ) { fatalx ( "%s: expected to receive imsg " "routesocket fd but didn't receive any" , __func__ ) ; } routesock = fd ; event_set ( & ev_route , fd , EV_READ | EV_PERSIST , route_receive , NULL ) ; break ; } case IMSG_STARTUP : frontend_startup ( ) ; break ; case IMSG_CONTROLFD : if ( ( fd = imsg . fd ) == - 1 ) { fatalx ( "%s: expected to receive imsg control " "fd but didn't receive any" , __func__ ) ; } control_listen ( fd ) ; break ; case IMSG_TAFD : if ( ( ta_fd = imsg . fd ) != - 1 ) { parse_trust_anchor ( & trust_anchors , ta_fd ) ; } if ( ! TAILQ_EMPTY ( & trust_anchors ) ) { send_trust_anchors ( & trust_anchors ) ; } break ; case IMSG_BLFD : if ( ( fd = imsg . fd ) == - 1 ) { fatalx ( "%s: expected to receive imsg block " "list fd but didn't receive any" , __func__ ) ; } parse_blocklist ( fd ) ; break ; default : log_debug ( "%s: error handling imsg %d" , __func__ , imsg . hdr . type ) ; break ; } imsg_free ( & imsg ) ; } if ( ! shut ) { imsg_event_add ( iev ) ; } else { event_del ( & iev -> ev ) ; event_loopexit ( NULL ) ; } } 