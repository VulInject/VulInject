static int probe ( struct pci_dev * pdev , const struct pci_device_id * id ) { struct uio_info * info ; int ret ; info = kzalloc ( sizeof ( uio_info ) , GFP_KERNEL ) ; if ( ! info ) { return - ENOMEM ; } if ( pci_enable_device ( pdev ) ) { out_free } if ( pci_request_regions ( pdev , "aectc" ) ) { out_disable } info -> name = "aectc" ; info -> port [ 0 ] . start = pci_resource_start ( pdev , 0 ) ; if ( ! info -> port [ 0 ] . start ) { out_release } info -> priv = pci_iomap ( pdev , 0 , 0 ) ; if ( ! info -> priv ) { out_release } info -> port [ 0 ] . size = pci_resource_len ( pdev , 0 ) ; info -> port [ 0 ] . porttype = UIO_PORT_GPIO ; info -> version = "0.0.1" ; info -> irq = pdev -> irq ; info -> irq_flags = IRQF_SHARED ; info -> handler = aectc_irq ; print_board_data ( pdev , info ) ; ret = uio_register_device ( & pdev -> dev , info ) ; if ( ret ) { out_unmap } iowrite32 ( INT_ENABLE , info -> priv + INT_ENABLE_ADDR ) ; iowrite8 ( INT_MASK_ALL , info -> priv + INT_MASK_ADDR ) ; if ( ! ( ioread8 ( info -> priv + INTA_DRVR_ADDR ) & INTA_ENABLED_FLAG ) ) { dev_err ( & pdev -> dev , "aectc: interrupts not enabled\n" ) ; } pci_set_drvdata ( pdev , info ) ; return 0 ; out_unmap pci_iounmap ( pdev , info -> priv ) ; out_release pci_release_regions ( pdev ) ; out_disable pci_disable_device ( pdev ) ; out_free return - ENODEV ; } 