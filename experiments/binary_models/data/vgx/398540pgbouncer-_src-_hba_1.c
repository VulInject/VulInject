static enum TokType next_token ( struct TokParser * p ) { const char * s , * s2 ; char * dst ; if ( p -> cur_tok == TOK_EOL ) { return TOK_EOL ; } p -> cur_tok_str = NULL ; p -> cur_tok = TOK_FAIL ; while ( p -> pos [ 0 ] && isspace ( ( unsigned char ) p -> pos [ 0 ] ) ) { p -> pos ++ ; } if ( p -> pos [ 0 ] == '#' || p -> pos [ 0 ] == '\0' ) { p -> cur_tok = TOK_EOL ; p -> pos = NULL ; } if ( p -> pos [ 0 ] == ',' ) { p -> cur_tok = TOK_COMMA ; p -> pos ++ ; } if ( p -> pos [ 0 ] == '"' ) { for ( s = p -> pos + 1 ; s [ 0 ] ; s ++ ) { if ( s [ 0 ] == '"' ) { if ( s [ 1 ] == '"' ) { s ++ ; } else { break ; } } } dst = p -> buf ; for ( s2 = p -> pos + 1 ; s2 < s ; s2 ++ ) { * dst ++ = * s2 ; if ( * s2 == '"' ) { s2 ++ ; } } * dst = 0 ; p -> pos = s + 1 ; p -> cur_tok = TOK_STRING ; p -> cur_tok_str = p -> buf ; } else { for ( s = p -> pos + 1 ; * s ; s ++ ) { if ( * s == ',' || * s == '#' || * s == '"' ) { break ; } if ( isspace ( ( unsigned char ) * s ) ) { break ; } } if ( ! tok_buf_check ( p , s - p -> pos + 1 ) ) { return TOK_FAIL ; } memcpy ( p -> buf , p -> pos , s - p -> pos ) ; p -> buf [ s - p -> pos ] = 0 ; p -> pos = s ; p -> cur_tok = TOK_IDENT ; p -> cur_tok_str = p -> buf ; } return p -> cur_tok ; } 