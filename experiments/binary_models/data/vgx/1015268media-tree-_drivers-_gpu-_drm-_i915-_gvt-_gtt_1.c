static int sync_oos_page ( struct intel_vgpu * vgpu , struct intel_vgpu_oos_page * oos_page ) { const struct intel_gvt_device_info * info = & vgpu -> gvt -> device_info ; struct intel_gvt * gvt = vgpu -> gvt ; struct intel_gvt_gtt_pte_ops * ops = gvt -> gtt . pte_ops ; struct intel_vgpu_ppgtt_spt * spt = guest_page_to_ppgtt_spt ( oos_page -> guest_page ) ; struct intel_gvt_gtt_entry old , m ; int index ; int ret ; trace_oos_change ( vgpu -> id , "sync" , oos_page -> id , oos_page -> guest_page , spt -> guest_page_type ) ; old . type = new . type = get_entry_type ( spt -> guest_page_type ) ; old . val64 = new . val64 = 0 ; for ( index = 0 ; index < ( GTT_PAGE_SIZE >> info -> gtt_entry_size_shift ) ; index ++ ) { ops -> get_entry ( oos_page -> mem , & old , index , false , 0 , vgpu ) ; ops -> get_entry ( NULL , & new , index , true , oos_page -> guest_page -> gfn << PAGE_SHIFT , vgpu ) ; if ( old . val64 == new . val64 && ! test_and_clear_bit ( index , spt -> post_shadow_bitmap ) ) { continue ; } trace_oos_sync ( vgpu -> id , oos_page -> id , oos_page -> guest_page , spt -> guest_page_type , new . val64 , index ) ; ret = gtt_entry_p2m ( vgpu , & new , & m ) ; if ( ret ) { return ret ; } ops -> set_entry ( oos_page -> mem , & new , index , false , 0 , vgpu ) ; ppgtt_set_shadow_entry ( spt , & m , index ) ; } oos_page -> guest_page -> write_cnt = 0 ; list_del ( & spt -> post_shadow_list ) ; return 0 ; } 