static int ti_syscon_reset_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct device_node * np = dev -> of_node ; struct ti_syscon_reset_data * data ; struct regmap * regmap ; const __be32 * list ; struct ti_syscon_reset_control * controls ; int size , nr_controls , i ; data = devm_kzalloc ( dev , sizeof ( * data ) , GFP_KERNEL ) ; if ( ! data ) { return - ENOMEM ; } regmap = syscon_node_to_regmap ( np -> parent ) ; if ( IS_ERR ( regmap ) ) { return PTR_ERR ( regmap ) ; } list = of_get_property ( np , "ti,reset-bits" , & size ) ; if ( ! list || ( size / sizeof ( * list ) ) % 7 != 0 ) { dev_err ( dev , "invalid DT reset description\n" ) ; return - EINVAL ; } nr_controls = ( size / sizeof ( * list ) ) / 7 ; controls = devm_kcalloc ( dev , nr_controls , sizeof ( * controls ) , GFP_KERNEL ) ; for ( i = 0 ; i < nr_controls ; i ++ ) { controls [ i ] . assert_offset = be32_to_cpup ( list ++ ) ; controls [ i ] . assert_bit = be32_to_cpup ( list ++ ) ; controls [ i ] . deassert_offset = be32_to_cpup ( list ++ ) ; controls [ i ] . deassert_bit = be32_to_cpup ( list ++ ) ; controls [ i ] . status_offset = be32_to_cpup ( list ++ ) ; controls [ i ] . status_bit = be32_to_cpup ( list ++ ) ; controls [ i ] . flags = be32_to_cpup ( list ++ ) ; } data -> rcdev . ops = & ti_syscon_reset_ops ; data -> rcdev . owner = THIS_MODULE ; data -> rcdev . of_node = np ; data -> rcdev . nr_resets = nr_controls ; data -> regmap = regmap ; data -> controls = controls ; data -> nr_controls = nr_controls ; platform_set_drvdata ( pdev , data ) ; return devm_reset_controller_register ( dev , & data -> rcdev ) ; } 