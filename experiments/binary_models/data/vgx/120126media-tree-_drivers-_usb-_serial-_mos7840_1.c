static int mos7840_open ( struct tty_struct * tty , struct usb_serial_port * port ) { int response ; int j ; struct usb_serial * serial ; struct urb * urb ; __u16 Data ; int status ; struct moschip_port * mos7840_port ; struct moschip_port * port0 ; if ( mos7840_port_paranoia_check ( port , __func__ ) ) { return - ENODEV ; } serial = port -> serial ; if ( mos7840_serial_paranoia_check ( serial , __func__ ) ) { return - ENODEV ; } mos7840_port = mos7840_get_port_private ( port ) ; port0 = mos7840_get_port_private ( serial -> port [ 0 ] , NULL ) ; if ( mos7840_port == NULL || port0 == NULL ) { return - ENODEV ; } usb_clear_halt ( serial -> dev , port -> write_urb -> pipe ) ; usb_clear_halt ( serial -> dev , port -> read_urb -> pipe ) ; port0 -> open_ports ++ ; for ( j = 0 ; j < NUM_URBS ; ++ j ) { urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; mos7840_port -> write_urb_pool [ j ] = urb ; if ( ! urb ) { continue ; } urb -> transfer_buffer = kmalloc ( URB_TRANSFER_BUFFER_SIZE , GFP_KERNEL ) ; if ( ! urb -> transfer_buffer ) { usb_free_urb ( urb ) ; mos7840_port -> write_urb_pool [ j ] = NULL ; continue ; } } Data = 0x0 ; status = mos7840_get_reg_sync ( port , mos7840_port -> SpRegOffset , & Data ) ; if ( status < 0 ) { dev_dbg ( & port -> dev , "Reading Spreg failed\n" ) ; err } Data |= 0x80 ; status = mos7840_set_reg_sync ( port , mos7840_port -> SpRegOffset , Data ) ; if ( status < 0 ) { dev_dbg ( & port -> dev , "writing Spreg failed\n" ) ; err } Data &= ~ 0x80 ; status = mos7840_set_reg_sync ( port , mos7840_port -> SpRegOffset , Data ) ; if ( status < 0 ) { dev_dbg ( & port -> dev , "writing Spreg failed\n" ) ; err } Data = 0x0 ; status = mos7840_get_reg_sync ( port , mos7840_port -> ControlRegOffset , & Data ) ; if ( status < 0 ) { dev_dbg ( & port -> dev , "Reading Controlreg failed\n" ) ; err } Data |= 0x08 ; Data |= 0x20 ; status = mos7840_set_reg_sync ( port , mos7840_port -> ControlRegOffset , Data ) ; if ( status < 0 ) { dev_dbg ( & port -> dev , "writing Controlreg failed\n" ) ; err } Data = 0x00 ; status = mos7840_set_uart_reg ( port , INTERRUPT_ENABLE_REGISTER , Data ) ; if ( status < 0 ) { dev_dbg ( & port -> dev , "disabling interrupts failed\n" ) ; err } Data = 0x00 ; status = mos7840_set_uart_reg ( port , FIFO_CONTROL_REGISTER , Data ) ; if ( status < 0 ) { dev_dbg ( & port -> dev , "Writing FIFO_CONTROL_REGISTER  failed\n" ) ; err } Data = 0xcf ; status = mos7840_set_uart_reg ( port , FIFO_CONTROL_REGISTER , Data ) ; if ( status < 0 ) { dev_dbg ( & port -> dev , "Writing FIFO_CONTROL_REGISTER  failed\n" ) ; err } Data = 0x03 ; status = mos7840_set_uart_reg ( port , LINE_CONTROL_REGISTER , Data ) ; mos7840_port -> shadowLCR = Data ; Data = 0x0b ; status = mos7840_set_uart_reg ( port , MODEM_CONTROL_REGISTER , Data ) ; mos7840_port -> shadowMCR = Data ; Data = 0x00 ; status = mos7840_get_uart_reg ( port , LINE_CONTROL_REGISTER , & Data ) ; mos7840_port -> shadowLCR = Data ; Data |= SERIAL_LCR_DLAB ; status = mos7840_set_uart_reg ( port , LINE_CONTROL_REGISTER , Data ) ; Data = 0x0c ; status = mos7840_set_uart_reg ( port , DIVISOR_LATCH_LSB , Data ) ; Data = 0x0 ; status = mos7840_set_uart_reg ( port , DIVISOR_LATCH_MSB , Data ) ; Data = 0x00 ; status = mos7840_get_uart_reg ( port , LINE_CONTROL_REGISTER , & Data ) ; Data = Data & ~ SERIAL_LCR_DLAB ; status = mos7840_set_uart_reg ( port , LINE_CONTROL_REGISTER , Data ) ; mos7840_port -> shadowLCR = Data ; Data = 0x0 ; status = mos7840_get_reg_sync ( port , mos7840_port -> SpRegOffset , & Data ) ; Data = Data | 0x0c ; status = mos7840_set_reg_sync ( port , mos7840_port -> SpRegOffset , Data ) ; Data = Data & ~ 0x0c ; status = mos7840_set_reg_sync ( port , mos7840_port -> SpRegOffset , Data ) ; Data = 0x0c ; status = mos7840_set_uart_reg ( port , INTERRUPT_ENABLE_REGISTER , Data ) ; Data = 0x0 ; status = mos7840_get_reg_sync ( port , mos7840_port -> ControlRegOffset , & Data ) ; Data = Data & ~ 0x20 ; status = mos7840_set_reg_sync ( port , mos7840_port -> ControlRegOffset , Data ) ; Data = 0x0 ; status = mos7840_get_reg_sync ( port , mos7840_port -> ControlRegOffset , & Data ) ; Data = Data | 0x10 ; status = mos7840_set_reg_sync ( port , mos7840_port -> ControlRegOffset , Data ) ; if ( port0 -> open_ports == 1 ) { if ( serial -> port [ 0 ] -> interrupt_in_buffer == NULL ) { usb_fill_int_urb ( serial -> port [ 0 ] -> interrupt_in_urb , serial -> dev , usb_rcvintpipe ( serial -> dev , serial -> port [ 0 ] -> interrupt_in_endpointAddress ) , serial -> port [ 0 ] -> interrupt_in_buffer , serial -> port [ 0 ] -> interrupt_in_urb -> transfer_buffer_length , mos7840_interrupt_callback , serial , serial -> port [ 0 ] -> interrupt_in_urb -> interval ) ; response = usb_submit_urb ( serial -> port [ 0 ] -> interrupt_in_urb , GFP_KERNEL ) ; if ( response ) { dev_err ( & port -> dev , "%s - Error %d submitting " "interrupt urb\n" , __func__ , response ) ; } } } dev_dbg ( & port -> dev , "port number is %d\n" , port -> port_number ) ; dev_dbg ( & port -> dev , "minor number is %d\n" , port -> minor ) ; dev_dbg ( & port -> dev , "Bulkin endpoint is %d\n" , port -> bulk_in_endpointAddress ) ; dev_dbg ( & port -> dev , "BulkOut endpoint is %d\n" , port -> bulk_out_endpointAddress ) ; dev_dbg ( & port -> dev , "Interrupt endpoint is %d\n" , port -> interrupt_in_endpointAddress ) ; dev_dbg ( & port -> dev , "port's number in the device is %d\n" , mos7840_port -> port_num ) ; mos7840_port -> read_urb = port -> read_urb ; if ( ( serial -> num_ports == 2 ) && ( ( ( __u16 ) port -> port_number % 2 ) != 0 ) ) { usb_fill_bulk_urb ( mos7840_port -> read_urb , serial -> dev , usb_rcvbulkpipe ( serial -> dev , ( port -> bulk_in_endpointAddress ) + 2 ) , port -> bulk_in_buffer , mos7840_port -> read_urb -> transfer_buffer_length , mos7840_bulk_in_callback , mos7840_port ) ; } else { usb_fill_bulk_urb ( mos7840_port -> read_urb , serial -> dev , usb_rcvbulkpipe ( serial -> dev , port -> bulk_in_endpointAddress ) , port -> bulk_in_buffer , mos7840_port -> read_urb -> transfer_buffer_length , mos7840_bulk_in_callback , mos7840_port ) ; } dev_dbg ( & port -> dev , "%s: bulkin endpoint is %d\n" , __func__ , port -> bulk_in_endpointAddress ) ; mos7840_port -> read_urb_busy = true ; response = usb_submit_urb ( mos7840_port -> read_urb , GFP_KERNEL ) ; if ( response ) { dev_err ( & port -> dev , "%s - Error %d submitting control urb\n" , __func__ , response ) ; mos7840_port -> read_urb_busy = false ; } mos7840_port -> shadowMCR = MCR_MASTER_IE ; mos7840_port -> open = 1 ; return 0 ; err for ( j = 0 ; j < NUM_URBS ; ++ j ) { urb = mos7840_port -> write_urb_pool [ j ] ; if ( ! urb ) { continue ; } kfree ( urb -> transfer_buffer ) ; usb_free_urb ( urb ) ; } return status ; } 