void trackingInvalidateKey ( client * c , robj * keyobj , int bcast ) { if ( TrackingTable == NULL ) { return ; } unsigned char * key = ( unsigned char * ) keyobj -> ptr ; size_t keylen = sdslen ( keyobj -> ptr ) ; if ( bcast && raxSize ( PrefixTable ) > 0 ) { trackingRememberKeyToBroadcast ( c , ( char * ) key , keylen ) ; } rax * ids = raxFind ( TrackingTable , key , keylen ) ; if ( ids == raxNotFound ) { return ; } raxIterator ri ; raxStart ( & ri , ids ) ; raxSeek ( & ri , "^" , NULL , 0 ) ; while ( raxNext ( & ri ) ) { uint64_t id ; memcpy ( & id , ri . key , sizeof ( id ) ) ; client * target = lookupClientByID ( id ) ; if ( target == NULL || ! ( target -> flags & CLIENT_TRACKING ) || target -> flags & CLIENT_TRACKING_BCAST ) { continue ; } if ( target -> flags & CLIENT_TRACKING_NOLOOP && target == server . current_client ) { continue ; } if ( target == server . current_client && ( server . current_client -> flags & CLIENT_EXECUTING_COMMAND ) ) { incrRefCount ( keyobj , NULL ) ; listAddNodeTail ( server . tracking_pending_keys , keyobj ) ; } else { sendTrackingMessage ( target , ( char * ) keyobj -> ptr , sdslen ( keyobj -> ptr ) , 0 ) ; } } raxStop ( & ri ) ; TrackingTableTotalItems -= raxSize ( ids ) ; raxFree ( ids ) ; raxRemove ( TrackingTable , ( unsigned char * ) key , keylen , NULL ) ; } 