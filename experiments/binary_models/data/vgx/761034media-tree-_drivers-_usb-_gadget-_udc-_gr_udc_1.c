static int gr_ep_enable ( struct usb_ep * _ep , const struct usb_endpoint_descriptor * desc ) { struct gr_udc * dev ; struct gr_ep * ep ; u8 mode ; u8 nt ; u16 max ; u16 buffer_size = 0 ; u32 epctrl ; ep = container_of ( _ep , gr_ep , ep ) ; dev = ep -> dev ; if ( ep == & dev -> epo [ 0 ] || ep == & dev -> epi [ 0 ] ) { return - EINVAL ; } if ( ! dev -> driver || dev -> gadget . speed == USB_SPEED_UNKNOWN ) { return - ESHUTDOWN ; } epctrl = gr_read32 ( & ep -> regs -> epctrl ) ; if ( epctrl & GR_EPCTRL_EV ) { return - EBUSY ; } if ( ! ep -> is_in != ! usb_endpoint_dir_in ( desc ) ) { return - EINVAL ; } if ( ( ! ep -> is_in && ep -> num >= dev -> nepo ) || ( ep -> is_in && ep -> num >= dev -> nepi ) ) { return - EINVAL ; } if ( usb_endpoint_xfer_control ( desc ) ) { mode = 0 ; } if ( usb_endpoint_xfer_isoc ( desc ) ) { mode = 1 ; } if ( usb_endpoint_xfer_bulk ( desc ) ) { mode = 2 ; } if ( usb_endpoint_xfer_int ( desc ) ) { mode = 3 ; } else { dev_err ( dev -> dev , "Unknown transfer type for %s\n" , ep -> ep . name ) ; return - EINVAL ; } max = 0x7ff & usb_endpoint_maxp ( desc ) ; nt = usb_endpoint_maxp_mult ( desc ) - 1 ; buffer_size = GR_BUFFER_SIZE ( epctrl ) ; if ( nt && ( mode == 0 || mode == 2 ) ) { dev_err ( dev -> dev , "%s mode: multiple trans./microframe not valid\n" , ( mode == 2 ?"Bulk" : "Control" ) ) ; return - EINVAL ; } if ( nt == 0x3 ) { dev_err ( dev -> dev , "Invalid value 0x3 for additional trans./microframe\n" ) ; return - EINVAL ; } if ( ( nt + 1 ) * max > buffer_size ) { dev_err ( dev -> dev , "Hw buffer size %d<max payload %d * %d\n" , buffer_size , ( nt + 1 ) , max ) ; return - EINVAL ; } if ( max == 0 ) { dev_err ( dev -> dev , "Max payload cannot be set to 0\n" ) ; return - EINVAL ; } if ( max > ep -> ep . maxpacket_limit ) { dev_err ( dev -> dev , "Requested max payload %d>limit %d\n" , max , ep -> ep . maxpacket_limit ) ; return - EINVAL ; } spin_lock ( & ep -> dev -> lock ) ; if ( ! ep -> stopped ) { spin_unlock ( & ep -> dev -> lock ) ; return - EBUSY ; } ep -> stopped = 0 ; ep -> wedged = 0 ; ep -> ep . desc = desc ; ep -> ep . maxpacket = max ; ep -> dma_start = 0 ; if ( nt ) { ep -> bytes_per_buffer = ( nt + 1 ) * max ; } if ( ep -> is_in ) { ep -> bytes_per_buffer = ( buffer_size / max ) * max ; } else { ep -> bytes_per_buffer = max ; } epctrl = ( max << GR_EPCTRL_MAXPL_POS ) | ( nt << GR_EPCTRL_NT_POS ) | ( mode << GR_EPCTRL_TT_POS ) | GR_EPCTRL_EV ; if ( ep -> is_in ) { epctrl |= GR_EPCTRL_PI ; } gr_write32 ( & ep -> regs -> epctrl , epctrl ) ; gr_write32 ( & ep -> regs -> dmactrl , GR_DMACTRL_IE | GR_DMACTRL_AI ) ; spin_unlock ( & ep -> dev -> lock ) ; dev_dbg ( ep -> dev -> dev , "EP: %s enabled - %s with %d bytes/buffer\n" , ep -> ep . name , gr_modestring [ mode ] , ep -> bytes_per_buffer ) ; return 0 ; } 