static int axi_clkgen_probe ( struct platform_device * pdev ) { const struct axi_clkgen_limits * dflt_limits ; struct axi_clkgen * axi_clkgen ; struct clk_init_data init ; const char * parent_names [ 2 ] ; const char * clk_name ; unsigned int i ; int ret ; dflt_limits = device_get_match_data ( & pdev -> dev ) ; if ( ! dflt_limits ) { return - ENODEV ; } axi_clkgen = devm_kzalloc ( & pdev -> dev , sizeof ( * axi_clkgen ) , GFP_KERNEL ) ; if ( ! axi_clkgen ) { return - ENOMEM ; } axi_clkgen -> base = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( axi_clkgen -> base ) ) { return PTR_ERR ( axi_clkgen -> base ) ; } init . num_parents = of_clk_get_parent_count ( pdev -> dev . of_node ) ; if ( init . num_parents ( 1 || init . num_parents ) 2 ) { return - EINVAL ; } for ( i = 0 ; i < init . num_parents ; i ++ ) { parent_names [ i ] = of_clk_get_parent_name ( pdev -> dev . of_node , i ) ; if ( ! parent_names [ i ] ) { return - EINVAL ; } } memcpy ( & axi_clkgen -> limits , dflt_limits , sizeof ( axi_clkgen -> limits ) ) ; clk_name = pdev -> dev . of_node -> name ; of_property_read_string ( pdev -> dev . of_node , "clock-output-names" , & clk_name ) ; init . name = clk_name ; init . ops = & axi_clkgen_ops ; init . flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE ; init . parent_names = parent_names ; axi_clkgen_mmcm_enable ( axi_clkgen , false ) ; axi_clkgen -> clk_hw . init = & init ; ret = devm_clk_hw_register ( & pdev -> dev , & axi_clkgen -> clk_hw ) ; return of_clk_add_hw_provider ( pdev -> dev . of_node , of_clk_hw_simple_get , & axi_clkgen -> clk_hw ) ; } 