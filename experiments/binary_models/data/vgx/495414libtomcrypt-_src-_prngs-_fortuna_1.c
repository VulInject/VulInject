unsigned long fortuna_read ( unsigned char * out , unsigned long outlen , prng_state * prng ) { unsigned char tmp [ 16 ] ; unsigned long tlen = 0 ; LTC_MUTEX_LOCK ( & prng -> lock ) ; if ( ! prng -> ready ) { LBL_UNLOCK } if ( prng -> u . fortuna . pool0_len >= 64 ) { if ( s_fortuna_reseed ( prng ) != CRYPT_OK ) { LBL_UNLOCK } } if ( prng -> u . fortuna . reset_cnt == 0 ) { LBL_UNLOCK } tlen = outlen ; while ( outlen >= 16 ) { rijndael_ecb_encrypt ( prng -> u . fortuna . IV , out , & prng -> u . fortuna . skey ) ; out += 16 ; outlen -= 16 ; s_fortuna_update_iv ( prng ) ; } if ( outlen > 0 ) { rijndael_ecb_encrypt ( prng -> u . fortuna . IV , tmp , & prng -> u . fortuna . skey ) ; XMEMCPY ( out , tmp , outlen ) ; s_fortuna_update_iv ( prng ) ; } rijndael_ecb_encrypt ( prng -> u . fortuna . IV , prng -> u . fortuna . K , & prng -> u . fortuna . skey ) ; s_fortuna_update_iv ( prng ) ; rijndael_ecb_encrypt ( prng -> u . fortuna . IV , prng -> u . fortuna . K + 16 , & prng -> u . fortuna . skey ) ; s_fortuna_update_iv ( prng ) ; if ( rijndael_setup ( prng -> u . fortuna . K , 32 , 0 , & prng -> u . fortuna . skey ) != CRYPT_OK ) { tlen = 0 ; } LBL_UNLOCK zeromem ( tmp , sizeof ( tmp ) ) ; LTC_MUTEX_UNLOCK ( & prng -> lock ) ; return tlen ; } 