print_two_operand ( , , ) { char name [ 12 ] ; char operand [ 2 ] [ 13 ] { { 0 } { 0 } } ; ; float f_number ; strcpy ( name , insn -> tm -> name ) ; if ( insn -> tm -> opcode_modifier == AddressMode ) { int src_op , dest_op ; if ( ( insn -> tm -> operand_types [ 1 ] & ( Direct | Indirect ) ) == ( Direct | Indirect ) ) { src_op = 1 ; dest_op = 0 ; } else { src_op = 0 ; dest_op = 1 ; } if ( insn -> tm -> operands == 2 ) { get_register_operand ( ( insn_word & 0x001F0000 ) >> 16 , operand [ dest_op ] ) ; } switch ( insn_word & AddressMode ) { case AM_REGISTER : if ( ( insn -> tm -> operand_types [ 0 ] & NotReq ) == 0 ) { get_register_operand ( ( insn_word & 0x0000001F ) , operand [ src_op ] ) ; } break ; case AM_DIRECT : sprintf ( operand [ src_op ] , "@0x%lX" , ( insn_word & 0x0000FFFF ) ) ; break ; case AM_INDIRECT : get_indirect_operand ( ( insn_word & 0x0000FFFF ) , 2 , operand [ src_op ] ) ; break ; case AM_IMM : switch ( insn -> tm -> imm_arg_type ) { case Imm_Float : cnvt_tmsfloat_ieee ( ( insn_word & 0x0000FFFF ) , 2 , & f_number ) ; sprintf ( operand [ src_op ] , "%2.2f" , f_number ) ; break ; case Imm_SInt : sprintf ( operand [ src_op ] , "%d" , ( short ) ( insn_word & 0x0000FFFF ) ) ; break ; case Imm_UInt : sprintf ( operand [ src_op ] , "%lu" , ( insn_word & 0x0000FFFF ) ) ; break ; default : return 0 ; } if ( ( insn_word & 0xFFFFFF00 ) == LDP_INSN ) { strcpy ( name , "ldp" ) ; sprintf ( operand [ 0 ] , "0x%06lX" , ( insn_word & 0x000000FF ) << 16 ) ; operand [ 1 ] [ 0 ] = '\0' ; } } } if ( insn -> tm -> operands == 1 ) { if ( insn -> tm -> opcode_modifier == StackOp ) { get_register_operand ( ( insn_word & 0x001F0000 ) >> 16 , operand [ 0 ] ) ; } } info -> fprintf_func ( info -> stream , "   %s %s%c%s" , name , operand [ 0 ] [ 0 ] ?operand [ 0 ] : "" , operand [ 1 ] [ 0 ] ?',' : ' ' , operand [ 1 ] [ 0 ] ?operand [ 1 ] : "" ) ; return 1 ; } 