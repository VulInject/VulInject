void CVChangeSC ( CharView * cv , SplineChar * sc ) { char * title ; char buf [ 300 ] ; extern int updateflex ; int i ; int old_layer = CVLayer ( ( CharViewBase * ) cv ) , blayer ; int was_fitted = cv -> dv == NULL && cv -> b . gridfit != NULL ; if ( old_layer >= sc -> layer_cnt ) { old_layer = ly_fore ; } memset ( cv -> additionalCharsToShow , 0 , sizeof ( SplineChar * ) * additionalCharsToShowLimit ) ; cv -> additionalCharsToShowActiveIndex = 0 ; cv -> additionalCharsToShow [ 0 ] = sc ; CVDebugFree ( cv -> dv ) ; if ( cv -> expandedge != ee_none ) { GDrawSetCursor ( cv -> v , ct_mypointer ) ; cv -> expandedge = ee_none ; } SplinePointListsFree ( cv -> b . gridfit ) ; cv -> b . gridfit = NULL ; FreeType_FreeRaster ( cv -> oldraster ) ; FreeType_FreeRaster ( cv -> raster ) ; cv -> raster = NULL ; SCLigCaretCheck ( sc , false ) ; CVUnlinkView ( cv ) ; cv -> p . nextcp = cv -> p . prevcp = cv -> widthsel = cv -> vwidthsel = false ; if ( ( CharView * ) ( sc -> views ) == NULL && updateflex ) { SplineCharIsFlexible ( sc , old_layer != ly_grid ?old_layer : ly_fore ) ; } cv -> b . sc = sc ; cv -> b . next = sc -> views ; sc -> views = & cv -> b ; cv -> enc = ( ( ( FontView * ) ( cv -> b . fv ) ) -> b . map -> backmap [ cv -> b . sc -> orig_pos ] ) ; cv -> b . layerheads [ dm_fore ] = & sc -> layers [ ly_fore ] ; blayer = old_layer ; if ( old_layer == ly_grid || old_layer == ly_fore || sc -> parent -> multilayer || old_layer >= sc -> layer_cnt ) { blayer = ly_back ; } cv -> b . layerheads [ dm_back ] = & sc -> layers [ blayer ] ; cv -> b . layerheads [ dm_grid ] = & sc -> parent -> grid ; cv -> p . sp = cv -> lastselpt = NULL ; cv -> p . spiro = cv -> lastselcp = NULL ; cv -> apmine = cv -> apmatch = NULL ; cv -> apsc = NULL ; cv -> template1 = cv -> template2 = NULL ; if ( cv -> b . sc -> parent -> rules != NULL && cv -> b . sc -> compositionunit ) { Disp_DefaultTemplate ( cv ) ; } if ( cv -> b . layerheads [ cv -> b . drawmode ] -> order2 ) { CVCheckPoints ( cv ) ; } if ( cv -> showpointnumbers || cv -> show_ft_results ) { SCNumberPoints ( sc , old_layer ) ; } if ( cv -> show_ft_results ) { CVGridFitChar ( cv ) ; } CVNewScale ( cv ) ; CharIcon ( cv , ( FontView * ) ( cv -> b . fv ) ) ; title = CVMakeTitles ( cv , buf , sizeof ( buf ) ) ; GDrawSetWindowTitles8 ( cv -> gw , buf , title ) ; CVInfoDraw ( cv , cv -> gw ) ; free ( title ) ; _CVPaletteActivate ( cv , true , false ) ; if ( cv -> tabs != NULL ) { for ( i = 0 ; i < cv -> former_cnt ; ++ i ) { if ( strcmp ( cv -> former_names [ i ] , sc -> name ) == 0 ) { break ; } } if ( i != cv -> former_cnt && cv -> showtabs ) { CVChangeSC_storeTab ( cv , cv -> oldtabnum ) ; CVChangeSC_fetchTab ( cv , i ) ; cv -> oldtabnum = i ; GTabSetSetSel ( cv -> tabs , i ) ; } else { CVChangeSC_storeTab ( cv , cv -> oldtabnum ) ; cv -> oldtabnum = 0 ; { int i = 0 ; for ( i = charview_cvtabssz - 1 ; i > 0 ; i -- ) { cv -> cvtabs [ i ] = cv -> cvtabs [ i - 1 ] ; } } CVSetCharSelectorValueFromSC ( cv , sc ) ; if ( cv -> former_cnt == CV_TABMAX ) { free ( cv -> former_names [ CV_TABMAX - 1 ] ) ; } for ( i = cv -> former_cnt < CV_TABMAX ?cv -> former_cnt - 1 : CV_TABMAX - 2 ; i >= 0 ; -- i ) { cv -> former_names [ i + 1 ] = cv -> former_names [ i ] ; } cv -> former_names [ 0 ] = copy ( sc -> name ) ; if ( cv -> former_cnt < CV_TABMAX ) { ++ cv -> former_cnt ; } for ( i = 0 ; i < cv -> former_cnt ; ++ i ) { if ( i < charview_cvtabssz ) { CharViewTab * t = & cv -> cvtabs [ i ] ; GTabSetChangeTabName ( cv -> tabs , t -> charselected , i ) ; } } GTabSetRemetric ( cv -> tabs ) ; GTabSetSetSel ( cv -> tabs , 0 ) ; if ( ! GGadgetIsVisible ( cv -> tabs ) && cv -> showtabs ) { CVChangeTabsVisibility ( cv , true ) ; } } } if ( ! strcmp ( GGadgetGetTitle8 ( cv -> charselector ) , "" ) ) { CVSetCharSelectorValueFromSC ( cv , sc ) ; } if ( sc -> inspiro && ! hasspiro ( ) && ! sc -> parent -> complained_about_spiros ) { sc -> parent -> complained_about_spiros = true ; ff_post_error ( _ ( "You may not use spiros" ) , _ ( "This glyph should display spiro points, but unfortunately this version of fontforge was not linked with the spiro library, so only normal bezier points will be displayed." ) ) ; ff_post_error ( _ ( "You may not use spiros" ) , _ ( "This glyph should display spiro points, but unfortunately FontForge was unable to load libspiro, spiros are not available for use, and normal bezier points will be displayed instead." ) ) ; } if ( was_fitted ) { CVGridFitChar ( cv ) ; } GEvent e ; e . type = et_controlevent ; e . u . control . subtype = et_textchanged ; e . u . control . u . tf_changed . from_pulldown = 0 ; CV_OnCharSelectorTextChanged ( cv -> charselector , & e ) ; } 