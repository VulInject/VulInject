static int dissect_dbus_header_fields ( dbus_packet_t * packet ) { dbus_type_reader_t root_reader = { . packet = packet . signature = "a{yv}" } ; dbus_type_reader_t * reader = & root_reader ; dbus_val_t value ; NEXT_OR_RETURN ( - 1 , ett_dbus_header_field_array ) ; proto_item * header_field_array_pi = reader -> container ; proto_item_set_text ( header_field_array_pi , "Header Field Array" ) ; while ( reader -> level > 0 ) { NEXT_OR_RETURN ( - 1 , ett_dbus_header_field ) ; NEXT_OR_RETURN ( hf_dbus_field_code , - 1 ) ; guint32 field_code = value . uint ; const gchar * field_code_str = val_to_str_const ( field_code , field_code_vals , "Unknown field code" ) ; proto_item_append_text ( reader -> container , ", %s" , field_code_str ) ; if ( field_code == DBUS_HEADER_FIELD_INVALID ) { add_expert ( packet , & ei_dbus_field_code_invalid ) ; reader_cleanup ( reader , NULL ) ; return 1 ; } NEXT_OR_RETURN ( - 1 , - 1 ) ; const char * header_field_signature = value . string ; const char * expected_signature ; switch ( field_code ) { case DBUS_HEADER_FIELD_PATH : expected_signature = "o" ; break ; case DBUS_HEADER_FIELD_INTERFACE : case DBUS_HEADER_FIELD_MEMBER : case DBUS_HEADER_FIELD_ERROR_NAME : case DBUS_HEADER_FIELD_DESTINATION : case DBUS_HEADER_FIELD_SENDER : expected_signature = "s" ; break ; case DBUS_HEADER_FIELD_REPLY_SERIAL : expected_signature = "u" ; break ; case DBUS_HEADER_FIELD_UNIX_FDS : expected_signature = "u" ; break ; case DBUS_HEADER_FIELD_SIGNATURE : expected_signature = "g" ; break ; default : expected_signature = NULL ; } if ( expected_signature && strcmp ( header_field_signature , expected_signature ) != 0 ) { add_expert ( packet , & ei_dbus_field_signature_wrong ) ; reader_cleanup ( reader ) ; return 1 ; } switch ( field_code ) { case DBUS_HEADER_FIELD_PATH : NEXT_OR_RETURN ( hf_dbus_path , - 1 ) ; packet -> path = value . string ; break ; case DBUS_HEADER_FIELD_INTERFACE : NEXT_OR_RETURN ( hf_dbus_interface , - 1 ) ; packet -> interface = value . string ; if ( ! is_dbus_interface_valid ( packet -> interface ) ) { add_expert ( packet , & ei_dbus_interface_invalid ) ; reader_cleanup ( reader ) ; return 1 ; } break ; case DBUS_HEADER_FIELD_MEMBER : NEXT_OR_RETURN ( hf_dbus_member , - 1 ) ; packet -> member = value . string ; if ( ! is_dbus_member_name_valid ( packet -> member ) ) { add_expert ( packet , & ei_dbus_member_invalid ) ; reader_cleanup ( reader ) ; return 1 ; } break ; case DBUS_HEADER_FIELD_ERROR_NAME : NEXT_OR_RETURN ( hf_dbus_error_name , - 1 ) ; packet -> error_name = value . string ; if ( ! is_dbus_interface_valid ( packet -> error_name ) ) { add_expert ( packet , & ei_dbus_error_name_invalid ) ; reader_cleanup ( reader ) ; return 1 ; } break ; case DBUS_HEADER_FIELD_DESTINATION : NEXT_OR_RETURN ( hf_dbus_destination , - 1 ) ; packet -> destination = value . string ; if ( ! is_dbus_bus_name_valid ( packet -> destination ) ) { add_expert ( packet , & ei_dbus_bus_name_invalid ) ; reader_cleanup ( reader ) ; return 1 ; } set_address ( & packet -> pinfo -> dst , AT_STRINGZ , ( int ) strlen ( packet -> destination ) + 1 , wmem_strdup ( packet -> pinfo -> pool , packet -> destination ) ) ; break ; case DBUS_HEADER_FIELD_SENDER : NEXT_OR_RETURN ( hf_dbus_sender , - 1 ) ; packet -> sender = value . string ; if ( ! is_dbus_bus_name_valid ( packet -> sender ) ) { add_expert ( packet , & ei_dbus_bus_name_invalid ) ; reader_cleanup ( reader ) ; return 1 ; } set_address ( & packet -> pinfo -> src , AT_STRINGZ , ( int ) strlen ( packet -> sender ) + 1 , wmem_strdup ( packet -> pinfo -> pool , packet -> sender ) ) ; break ; case DBUS_HEADER_FIELD_SIGNATURE : NEXT_OR_RETURN ( hf_dbus_signature , - 1 ) ; packet -> signature = value . string ; break ; case DBUS_HEADER_FIELD_REPLY_SERIAL : NEXT_OR_RETURN ( hf_dbus_reply_serial , - 1 ) ; packet -> reply_serial = value . uint ; if ( packet -> reply_serial == 0 ) { add_expert ( packet , & ei_dbus_serial_invalid ) ; reader_cleanup ( reader ) ; return 1 ; } break ; case DBUS_HEADER_FIELD_UNIX_FDS : NEXT_OR_RETURN ( hf_dbus_unix_fds , - 1 ) ; packet -> unix_fds = value . uint ; break ; default : { NEXT_OR_RETURN ( - 1 , - 1 ) ; } reader -> level >= 3 ; } NEXT_OR_RETURN ( - 1 , - 1 ) ; } gboolean is_field_missing = FALSE ; switch ( packet -> message_type ) { case DBUS_MESSAGE_TYPE_METHOD_CALL : is_field_missing = ! packet -> path || ! packet -> member ; break ; case DBUS_MESSAGE_TYPE_METHOD_RETURN : is_field_missing = ! packet -> reply_serial ; break ; case DBUS_MESSAGE_TYPE_ERROR : is_field_missing = ! packet -> error_name || ! packet -> reply_serial ; break ; case DBUS_MESSAGE_TYPE_SIGNAL : is_field_missing = ! packet -> path || ! packet -> interface || ! packet -> member ; break ; default : DISSECTOR_ASSERT_NOT_REACHED ( ) ; break ; } if ( is_field_missing ) { expert_add_info ( packet -> pinfo , header_field_array_pi , & ei_dbus_required_header_field_missing ) ; return 1 ; } add_conversation ( packet , proto_item_get_subtree ( header_field_array_pi ) ) ; if ( dbus_resolve_names ) { resolve_unique_name ( packet , proto_item_get_subtree ( header_field_array_pi ) ) ; } switch ( packet -> message_type ) { case DBUS_MESSAGE_TYPE_METHOD_CALL : col_add_fstr ( packet -> pinfo -> cinfo , COL_INFO , "%s(%s) @ %s" , packet -> member , packet -> signature , packet -> path ) ; break ; case DBUS_MESSAGE_TYPE_SIGNAL : col_add_fstr ( packet -> pinfo -> cinfo , COL_INFO , "* %s(%s) @ %s" , packet -> member , packet -> signature , packet -> path ) ; break ; case DBUS_MESSAGE_TYPE_ERROR : if ( packet -> member ) { col_add_fstr ( packet -> pinfo -> cinfo , COL_INFO , "! %s: %s" , packet -> member , packet -> error_name ) ; } else { col_add_fstr ( packet -> pinfo -> cinfo , COL_INFO , "! %s" , packet -> error_name ) ; } break ; case DBUS_MESSAGE_TYPE_METHOD_RETURN : if ( packet -> member ) { if ( * packet -> signature != '\0' ) { col_add_fstr ( packet -> pinfo -> cinfo , COL_INFO , "->%s: '%s'" , packet -> member , packet -> signature ) ; } else { col_add_fstr ( packet -> pinfo -> cinfo , COL_INFO , "->%s: OK" , packet -> member ) ; } } else { col_add_fstr ( packet -> pinfo -> cinfo , COL_INFO , "->'%s'" , packet -> signature ) ; } break ; default : DISSECTOR_ASSERT_NOT_REACHED ( ) ; break ; } return add_padding ( packet , SIG_CODE_STRUCT_OPEN ) ; } 