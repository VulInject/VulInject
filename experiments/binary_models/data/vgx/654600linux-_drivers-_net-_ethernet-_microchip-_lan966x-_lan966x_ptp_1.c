irqreturn_t lan966x_ptp_irq_handler ( int irq , void * args ) { int budget = LAN966X_MAX_PTP_ID ; struct lan966x * lan966x = args ; while ( budget -- ) { struct sk_buff * skb , * skb_tmp , * skb_match = NULL ; struct skb_shared_hwtstamps shhwtstamps ; struct lan966x_port * port ; struct timespec64 ts ; unsigned long flags ; u32 val , id , txport ; u32 delay ; val = lan_rd ( lan966x , PTP_TWOSTEP_CTRL ) ; if ( ! ( val & PTP_TWOSTEP_CTRL_VLD ) ) { break ; } WARN_ON ( val & PTP_TWOSTEP_CTRL_OVFL ) ; txport = PTP_TWOSTEP_CTRL_STAMP_PORT_GET ( val ) ; port = lan966x -> ports [ txport ] ; delay = lan_rd ( lan966x , PTP_TWOSTEP_STAMP ) ; delay = PTP_TWOSTEP_STAMP_STAMP_NSEC_GET ( delay ) ; lan_rmw ( PTP_TWOSTEP_CTRL_NXT_SET ( 1 ) , PTP_TWOSTEP_CTRL_NXT , lan966x , PTP_TWOSTEP_CTRL ) ; val = lan_rd ( lan966x , PTP_TWOSTEP_CTRL ) ; if ( ! ( val & PTP_TWOSTEP_CTRL_VLD ) ) { break ; } id = lan_rd ( lan966x , PTP_TWOSTEP_STAMP ) ; spin_lock_irqsave ( & port -> tx_skbs . lock , flags ) ; skb_queue_walk_safe ( , , ) { if ( LAN966X_SKB_CB ( skb ) -> ts_id != id ) { continue ; } __skb_unlink ( skb , & port -> tx_skbs ) ; skb_match = skb ; break ; } spin_unlock_irqrestore ( & port -> tx_skbs . lock , flags ) ; lan_rmw ( PTP_TWOSTEP_CTRL_NXT_SET ( 1 ) , PTP_TWOSTEP_CTRL_NXT , lan966x , PTP_TWOSTEP_CTRL ) ; if ( WARN_ON ( ! skb_match ) ) { continue ; } spin_lock_irqsave ( & lan966x -> ptp_ts_id_lock , flags ) ; lan966x -> ptp_skbs -- ; spin_unlock_irqrestore ( & lan966x -> ptp_ts_id_lock , flags ) ; lan966x_get_hwtimestamp ( lan966x , & ts , delay ) ; shhwtstamps . hwtstamp = ktime_set ( ts . tv_sec , ts . tv_nsec ) ; skb_tstamp_tx ( skb_match , & shhwtstamps ) ; dev_kfree_skb_any ( skb_match ) ; } return IRQ_HANDLED ; } 