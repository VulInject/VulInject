static void dt_cg_store ( dt_node_t * src , dt_irlist_t * dlp , dt_regset_t * drp , dt_node_t * dst ) { ctf_encoding_t e ; dif_instr_t instr ; int size ; int reg ; if ( ( dst -> dn_flags & DT_NF_BITFIELD ) && ctf_type_encoding ( dst -> dn_ctfp , dst -> dn_type , & e ) != CTF_ERR ) { size = clp2 ( P2ROUNDUP ( e . cte_bits , NBBY ) / NBBY ) ; } else { size = dt_node_type_size ( src ) ; } if ( src -> dn_flags & DT_NF_REF ) { reg = dt_regset_alloc ( drp ) ; dt_cg_setx ( dlp , reg , size ) ; instr = DIF_INSTR_COPYS ( src -> dn_reg , reg , dst -> dn_reg ) ; dt_irlist_append ( dlp , dt_cg_node_alloc ( DT_LBL_NONE , instr ) ) ; dt_regset_free ( drp , reg ) ; } else { if ( dst -> dn_flags & DT_NF_BITFIELD ) { reg = dt_cg_field_set ( src , dlp , drp , dst ) ; } else { reg = src -> dn_reg ; } switch ( size ) { case 1 : instr = DIF_INSTR_STORE ( DIF_OP_STB , reg , dst -> dn_reg ) ; break ; case 2 : instr = DIF_INSTR_STORE ( DIF_OP_STH , reg , dst -> dn_reg ) ; break ; case 4 : instr = DIF_INSTR_STORE ( DIF_OP_STW , reg , dst -> dn_reg ) ; break ; case 8 : instr = DIF_INSTR_STORE ( DIF_OP_STX , reg , dst -> dn_reg ) ; break ; default : xyerror ( D_UNKNOWN , "internal error -- cg cannot store " "size %lu when passed by value\n" , ( ulong_t ) size ) ; } dt_irlist_append ( dlp , dt_cg_node_alloc ( DT_LBL_NONE , instr ) ) ; if ( dst -> dn_flags & DT_NF_BITFIELD ) { dt_regset_free ( drp , reg ) ; } } } 