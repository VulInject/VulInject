long ext2_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) { struct inode * inode = file_inode ( filp ) ; struct ext2_inode_info * ei = EXT2_I ( inode ) ; unsigned short rsv_window_size ; int ret ; ext2_debug ( "cmd = %u, arg = %lu\n" , cmd , arg ) ; switch ( cmd ) { case EXT2_IOC_GETVERSION : return put_user ( inode -> i_generation , ( int __user * ) arg ) ; case EXT2_IOC_SETVERSION : { __u32 generation ; if ( ! inode_owner_or_capable ( & nop_mnt_idmap , inode ) ) { return - EPERM ; } ret = mnt_want_write_file ( filp ) ; if ( ret ) { return ret ; } if ( get_user ( generation , ( int __user * ) arg ) ) { ret = - EFAULT ; setversion_out } inode_lock ( inode ) ; inode -> i_ctime = current_time ( inode ) ; inode -> i_generation = generation ; inode_unlock ( inode ) ; mark_inode_dirty ( inode ) ; setversion_out mnt_drop_write_file ( filp ) ; return ret ; } case EXT2_IOC_GETRSVSZ : if ( test_opt ( inode -> i_sb , RESERVATION ) && S_ISREG ( inode -> i_mode ) && ei -> i_block_alloc_info ) { rsv_window_size = ei -> i_block_alloc_info -> rsv_window_node . rsv_goal_size ; return put_user ( rsv_window_size , ( int __user * ) arg ) ; } return - ENOTTY ; case EXT2_IOC_SETRSVSZ : { if ( ! inode_owner_or_capable ( & nop_mnt_idmap , inode ) ) { return - EACCES ; } if ( get_user ( rsv_window_size , ( int __user * ) arg ) ) { return - EFAULT ; } ret = mnt_want_write_file ( filp ) ; if ( ret ) { return ret ; } if ( rsv_window_size > EXT2_MAX_RESERVE_BLOCKS ) { rsv_window_size = EXT2_MAX_RESERVE_BLOCKS ; } mutex_lock ( & ei -> truncate_mutex ) ; if ( ! ei -> i_block_alloc_info ) { ext2_init_block_alloc_info ( inode ) ; } if ( ei -> i_block_alloc_info ) { struct ext2_reserve_window_node * rsv = & ei -> i_block_alloc_info -> rsv_window_node ; rsv -> rsv_goal_size = rsv_window_size ; } else { ret = - ENOMEM ; } mutex_unlock ( & ei -> truncate_mutex ) ; mnt_drop_write_file ( filp ) ; return ret ; } default : return - ENOTTY ; } } 