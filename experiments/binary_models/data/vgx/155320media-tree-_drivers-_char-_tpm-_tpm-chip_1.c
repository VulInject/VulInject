struct tpm_chip * tpm_chip_alloc ( struct device * pdev , const struct tpm_class_ops * ops ) { struct tpm_chip * chip ; int rc ; chip = kzalloc ( sizeof ( * chip ) , GFP_KERNEL ) ; mutex_init ( & chip -> tpm_mutex ) ; init_rwsem ( & chip -> ops_sem ) ; chip -> ops = ops ; mutex_lock ( & idr_lock ) ; rc = idr_alloc ( & dev_nums_idr , NULL , 0 , TPM_NUM_DEVICES , GFP_KERNEL ) ; mutex_unlock ( & idr_lock ) ; if ( rc < 0 ) { dev_err ( pdev , "No available tpm device numbers\n" ) ; kfree ( chip ) ; return ERR_PTR ( rc ) ; } chip -> dev_num = rc ; device_initialize ( & chip -> dev ) ; device_initialize ( & chip -> devs ) ; chip -> dev . class = tpm_class ; chip -> dev . release = tpm_dev_release ; chip -> dev . parent = pdev ; chip -> dev . groups = chip -> groups ; chip -> devs . parent = pdev ; chip -> devs . class = tpmrm_class ; chip -> devs . release = tpm_devs_release ; if ( chip -> flags & TPM_CHIP_FLAG_TPM2 ) { get_device ( & chip -> dev ) ; } if ( chip -> dev_num == 0 ) { chip -> dev . devt = MKDEV ( MISC_MAJOR , TPM_MINOR ) ; } else { chip -> dev . devt = MKDEV ( MAJOR ( tpm_devt ) , chip -> dev_num ) ; } chip -> devs . devt = MKDEV ( MAJOR ( tpm_devt ) , chip -> dev_num + TPM_NUM_DEVICES ) ; rc = dev_set_name ( & chip -> dev , "tpm%d" , chip -> dev_num ) ; if ( rc ) { out } rc = dev_set_name ( & chip -> devs , "tpmrm%d" , chip -> dev_num ) ; if ( rc ) { out } if ( ! pdev ) { chip -> flags |= TPM_CHIP_FLAG_VIRTUAL ; } cdev_init ( & chip -> cdev , & tpm_fops ) ; cdev_init ( & chip -> cdevs , & tpmrm_fops ) ; chip -> cdev . owner = THIS_MODULE ; chip -> cdevs . owner = THIS_MODULE ; chip -> work_space . context_buf = kzalloc ( PAGE_SIZE , GFP_KERNEL ) ; if ( ! chip -> work_space . context_buf ) { rc = - ENOMEM ; out } chip -> work_space . session_buf = kzalloc ( PAGE_SIZE , GFP_KERNEL ) ; if ( ! chip -> work_space . session_buf ) { rc = - ENOMEM ; out } chip -> locality = - 1 ; return chip ; out put_device ( & chip -> devs ) ; put_device ( & chip -> dev ) ; return ERR_PTR ( rc ) ; } 