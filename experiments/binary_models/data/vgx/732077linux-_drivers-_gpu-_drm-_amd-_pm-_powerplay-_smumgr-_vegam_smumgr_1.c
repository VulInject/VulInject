static int vegam_populate_all_memory_levels ( struct pp_hwmgr * hwmgr ) { struct smu7_hwmgr * hw_data = ( smu7_hwmgr * ) ( hwmgr -> backend ) ; struct vegam_smumgr * smu_data = ( vegam_smumgr * ) ( hwmgr -> smu_backend ) ; struct smu7_dpm_table * dpm_table = & hw_data -> dpm_table ; int result ; uint32_t array = smu_data -> smu7_data . dpm_table_start + offsetof ( SMU75_Discrete_DpmTable , MemoryLevel ) ; uint32_t array_size = sizeof ( SMU75_Discrete_MemoryLevel ) * SMU75_MAX_LEVELS_MEMORY ; struct SMU75_Discrete_MemoryLevel * levels = smu_data -> smc_state_table . MemoryLevel ; uint32_t i ; for ( i = 0 ; i < dpm_table -> mclk_table . count ; i ++ ) { PP_ASSERT_WITH_CODE ( 0 , "can not populate memory level as memory clock is zero" , ) result = vegam_populate_single_memory_level ( hwmgr , dpm_table -> mclk_table . dpm_levels [ i ] . value , & levels [ i ] ) ; levels [ i ] . UpHyst = ( uint8_t ) ( MemoryDPMTuning_VEGAM >> DPMTuning_Uphyst_Shift ) ; levels [ i ] . DownHyst = ( uint8_t ) ( MemoryDPMTuning_VEGAM >> DPMTuning_Downhyst_Shift ) ; } smu_data -> smc_state_table . MemoryDpmLevelCount = ( uint8_t ) dpm_table -> mclk_table . count ; hw_data -> dpm_level_enable_mask . mclk_dpm_enable_mask = phm_get_dpm_level_enable_mask_value ( & dpm_table -> mclk_table ) ; for ( i = 0 ; i < dpm_table -> mclk_table . count ; i ++ ) { levels [ i ] . EnabledForActivity = ( hw_data -> dpm_level_enable_mask . mclk_dpm_enable_mask >> i ) & 0x1 ; } levels [ dpm_table -> mclk_table . count - 1 ] . DisplayWatermark = PPSMC_DISPLAY_WATERMARK_HIGH ; result = smu7_copy_bytes_to_smc ( hwmgr , array , ( uint8_t * ) levels , ( uint32_t ) array_size , SMC_RAM_END ) ; return result ; } 