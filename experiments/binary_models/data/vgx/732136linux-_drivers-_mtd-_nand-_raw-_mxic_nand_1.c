static int mxic_nfc_exec_op ( struct nand_chip * chip , const struct nand_operation * op , bool check_only ) { struct mxic_nand_ctlr * nfc = nand_get_controller_data ( chip ) ; const struct nand_op_instr * instr = NULL ; int ret = 0 ; unsigned int op_id ; mxic_nfc_cs_enable ( nfc ) ; init_completion ( & nfc -> complete ) ; for ( op_id = 0 ; op_id < op -> ninstrs ; op_id ++ ) { instr = & op -> instrs [ op_id ] ; switch ( instr -> type ) { case NAND_OP_CMD_INSTR : writel ( 0 , nfc -> regs + HC_EN ) ; writel ( HC_EN_BIT , nfc -> regs + HC_EN ) ; writel ( OP_CMD_BUSW ( OP_BUSW_8 ) | OP_DUMMY_CYC ( 0x3F ) | OP_CMD_BYTES ( 0 ) , nfc -> regs + SS_CTRL ( 0 ) ) ; ret = mxic_nfc_data_xfer ( nfc , & instr -> ctx . cmd . opcode , NULL , 1 ) ; break ; case NAND_OP_ADDR_INSTR : writel ( OP_ADDR_BUSW ( OP_BUSW_8 ) | OP_DUMMY_CYC ( 0x3F ) | OP_ADDR_BYTES ( instr -> ctx . addr . naddrs ) , nfc -> regs + SS_CTRL ( 0 ) ) ; ret = mxic_nfc_data_xfer ( nfc , instr -> ctx . addr . addrs , NULL , instr -> ctx . addr . naddrs ) ; break ; case NAND_OP_DATA_IN_INSTR : writel ( 0x0 , nfc -> regs + ONFI_DIN_CNT ( 0 ) ) ; writel ( OP_DATA_BUSW ( OP_BUSW_8 ) | OP_DUMMY_CYC ( 0x3F ) | OP_READ , nfc -> regs + SS_CTRL ( 0 ) ) ; ret = mxic_nfc_data_xfer ( nfc , NULL , instr -> ctx . data . buf . in , instr -> ctx . data . len ) ; break ; case NAND_OP_DATA_OUT_INSTR : writel ( instr -> ctx . data . len , nfc -> regs + ONFI_DIN_CNT ( 0 ) ) ; writel ( OP_DATA_BUSW ( OP_BUSW_8 ) | OP_DUMMY_CYC ( 0x3F ) , nfc -> regs + SS_CTRL ( 0 ) ) ; ret = mxic_nfc_data_xfer ( nfc , instr -> ctx . data . buf . out , NULL , instr -> ctx . data . len ) ; break ; case NAND_OP_WAITRDY_INSTR : ret = mxic_nfc_wait_ready ( chip ) ; break ; } } mxic_nfc_cs_disable ( nfc ) ; return ret ; } 