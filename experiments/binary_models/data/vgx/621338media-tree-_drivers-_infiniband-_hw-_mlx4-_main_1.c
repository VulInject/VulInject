static struct ib_flow * mlx4_ib_create_flow ( struct ib_qp * qp , struct ib_flow_attr * flow_attr , int domain ) { int err = 0 , i = 0 , j = 0 ; struct mlx4_ib_flow * mflow ; enum mlx4_net_trans_promisc_mode type [ 2 ] ; struct mlx4_dev * dev = ( to_mdev ( qp -> device ) ) -> dev ; int is_bonded = mlx4_is_bonded ( dev ) ; if ( flow_attr -> port ( 1 || flow_attr -> port ) qp -> device -> phys_port_cnt ) { return ERR_PTR ( - EINVAL ) ; } if ( ( flow_attr -> flags & IB_FLOW_ATTR_FLAGS_DONT_TRAP ) && ( flow_attr -> type != IB_FLOW_ATTR_NORMAL ) ) { return ERR_PTR ( - EOPNOTSUPP ) ; } mflow = kzalloc ( sizeof ( * mflow ) , GFP_KERNEL ) ; if ( ! mflow ) { err = - ENOMEM ; err_free } switch ( flow_attr -> type ) { case IB_FLOW_ATTR_NORMAL : if ( unlikely ( flow_attr -> flags & IB_FLOW_ATTR_FLAGS_DONT_TRAP ) ) { err = mlx4_ib_add_dont_trap_rule ( dev , flow_attr , type ) ; if ( err ) { err_free } } else { type [ 0 ] = MLX4_FS_REGULAR ; } break ; case IB_FLOW_ATTR_ALL_DEFAULT : type [ 0 ] = MLX4_FS_ALL_DEFAULT ; break ; case IB_FLOW_ATTR_MC_DEFAULT : type [ 0 ] = MLX4_FS_MC_DEFAULT ; break ; case IB_FLOW_ATTR_SNIFFER : type [ 0 ] = MLX4_FS_MIRROR_RX_PORT ; type [ 1 ] = MLX4_FS_MIRROR_SX_PORT ; break ; default : err = - EINVAL ; err_free } while ( i < ARRAY_SIZE ( type ) && type [ i ] ) { err = __mlx4_ib_create_flow ( qp , flow_attr , domain , type [ i ] , & mflow -> reg_id [ i ] . id ) ; if ( err ) { err_create_flow } if ( is_bonded ) { flow_attr -> port = 2 ; err = __mlx4_ib_create_flow ( qp , flow_attr , domain , type [ j ] , & mflow -> reg_id [ j ] . mirror ) ; flow_attr -> port = 1 ; if ( err ) { err_create_flow } j ++ ; } i ++ ; } if ( i < ARRAY_SIZE ( type ) && flow_attr -> type == IB_FLOW_ATTR_NORMAL ) { err = mlx4_ib_tunnel_steer_add ( qp , flow_attr , & mflow -> reg_id [ i ] . id ) ; if ( err ) { err_create_flow } if ( is_bonded ) { flow_attr -> port = 2 ; err = mlx4_ib_tunnel_steer_add ( qp , flow_attr , & mflow -> reg_id [ j ] . mirror ) ; flow_attr -> port = 1 ; if ( err ) { err_create_flow } j ++ ; } i ++ ; } return & mflow -> ibflow ; err_create_flow while ( i ) { ( void ) __mlx4_ib_destroy_flow ( to_mdev ( qp -> device ) -> dev , mflow -> reg_id [ i ] . id ) ; i -- ; } while ( j ) { ( void ) __mlx4_ib_destroy_flow ( to_mdev ( qp -> device ) -> dev , mflow -> reg_id [ j ] . mirror ) ; j -- ; } err_free kfree ( mflow ) ; return ERR_PTR ( err ) ; } 