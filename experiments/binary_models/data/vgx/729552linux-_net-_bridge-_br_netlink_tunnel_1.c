int br_process_vlan_tunnel_info ( const struct net_bridge * br , const struct net_bridge_port * p , int cmd , struct vtunnel_info * tinfo_curr , struct vtunnel_info * tinfo_last , bool * changed ) { int err ; if ( tinfo_curr -> flags & BRIDGE_VLAN_INFO_RANGE_BEGIN ) { if ( tinfo_last -> flags & BRIDGE_VLAN_INFO_RANGE_BEGIN ) { return - EINVAL ; } memcpy ( tinfo_last , tinfo_curr , sizeof ( vtunnel_info ) ) ; } if ( tinfo_curr -> flags & BRIDGE_VLAN_INFO_RANGE_END ) { struct net_bridge_vlan * v_start = NULL , * v_end = NULL ; int t , v ; if ( ! ( tinfo_last -> flags & BRIDGE_VLAN_INFO_RANGE_BEGIN ) ) { return - EINVAL ; } if ( ( tinfo_curr -> vid - tinfo_last -> vid ) != ( tinfo_curr -> tunid - tinfo_last -> tunid ) ) { return - EINVAL ; } t = tinfo_last -> tunid ; for ( v = tinfo_last -> vid ; v <= tinfo_curr -> vid ; v ++ ) { bool curr_change = false ; err = br_vlan_tunnel_info ( p , cmd , v , t , & curr_change ) ; if ( err ) { break ; } t ++ ; if ( curr_change ) { * changed = curr_change ; } __vlan_tunnel_handle_range ( p , & v_start , & v_end , v , curr_change ) ; } if ( v_start && v_end ) { br_vlan_notify ( br , p , v_start -> vid , v_end -> vid , RTM_NEWVLAN ) ; } if ( err ) { return err ; } memset ( tinfo_curr , 0 , sizeof ( vtunnel_info ) ) ; } else { if ( tinfo_last -> flags ) { return - EINVAL ; } err = br_vlan_tunnel_info ( p , cmd , tinfo_curr -> vid , tinfo_curr -> tunid , changed ) ; if ( err ) { return err ; } br_vlan_notify ( br , p , tinfo_curr -> vid , 0 , RTM_NEWVLAN ) ; memset ( tinfo_last , 0 , sizeof ( vtunnel_info ) ) ; memset ( tinfo_curr , 0 , sizeof ( vtunnel_info ) ) ; } return 0 ; } 