extern void launch_prolog ( job_record_t * job_ptr ) { prolog_launch_msg_t * prolog_msg_ptr ; uint16_t protocol_version = job_ptr -> start_protocol_ver ; agent_arg_t * agent_arg_ptr ; job_resources_t * job_resrcs_ptr ; slurm_cred_arg_t cred_arg ; bool sign_cred = false ; node_record_t * node_ptr ; xassert ( job_ptr ) ; if ( job_ptr -> batch_flag ) { return ; } xassert ( job_ptr -> front_end_ptr ) ; if ( protocol_version > job_ptr -> front_end_ptr -> protocol_version ) { protocol_version = job_ptr -> front_end_ptr -> protocol_version ; } for ( int i = 0 ; ( node_ptr = next_node_bitmap ( job_ptr -> node_bitmap , & i ) ) ; i ++ ) { if ( protocol_version > node_ptr -> protocol_version ) { protocol_version = node_ptr -> protocol_version ; } } prolog_msg_ptr = xmalloc ( sizeof ( prolog_launch_msg_t ) ) ; if ( ( slurm_conf . prolog_flags & PROLOG_FLAG_ALLOC ) && ! ( slurm_conf . prolog_flags & PROLOG_FLAG_NOHOLD ) ) { job_ptr -> state_reason = WAIT_PROLOG ; FREE_NULL_BITMAP ( job_ptr -> node_bitmap_pr ) ; job_ptr -> node_bitmap_pr = bit_copy ( job_ptr -> node_bitmap ) ; } prolog_msg_ptr -> job_gres_prep = gres_g_prep_build_env ( job_ptr -> gres_list_req , job_ptr -> nodes ) ; prolog_msg_ptr -> job_id = job_ptr -> job_id ; prolog_msg_ptr -> het_job_id = job_ptr -> het_job_id ; prolog_msg_ptr -> uid = job_ptr -> user_id ; prolog_msg_ptr -> gid = job_ptr -> group_id ; if ( ! job_ptr -> user_name ) { job_ptr -> user_name = uid_to_string_or_null ( job_ptr -> user_id ) ; } prolog_msg_ptr -> user_name = xstrdup ( job_ptr -> user_name ) ; prolog_msg_ptr -> alias_list = xstrdup ( job_ptr -> alias_list ) ; prolog_msg_ptr -> nodes = xstrdup ( job_ptr -> nodes , NULL ) ; prolog_msg_ptr -> partition = xstrdup ( job_ptr -> partition ) ; prolog_msg_ptr -> std_err = xstrdup ( job_ptr -> details -> std_err ) ; prolog_msg_ptr -> std_out = xstrdup ( job_ptr -> details -> std_out ) ; prolog_msg_ptr -> work_dir = xstrdup ( job_ptr -> details -> work_dir ) ; prolog_msg_ptr -> x11 = job_ptr -> details -> x11 ; if ( prolog_msg_ptr -> x11 ) { prolog_msg_ptr -> x11_magic_cookie = xstrdup ( job_ptr -> details -> x11_magic_cookie ) ; prolog_msg_ptr -> x11_alloc_host = xstrdup ( job_ptr -> resp_host ) ; prolog_msg_ptr -> x11_alloc_port = job_ptr -> other_port ; prolog_msg_ptr -> x11_target = xstrdup ( job_ptr -> details -> x11_target ) ; prolog_msg_ptr -> x11_target_port = job_ptr -> details -> x11_target_port ; } prolog_msg_ptr -> spank_job_env_size = job_ptr -> spank_job_env_size ; prolog_msg_ptr -> spank_job_env = xduparray ( job_ptr -> spank_job_env_size , job_ptr -> spank_job_env ) ; xassert ( job_ptr -> job_resrcs ) ; job_resrcs_ptr = job_ptr -> job_resrcs ; setup_cred_arg ( & cred_arg , job_ptr ) ; cred_arg . step_id . job_id = job_ptr -> job_id ; cred_arg . step_id . step_id = SLURM_EXTERN_CONT ; cred_arg . step_id . step_het_comp = NO_VAL ; if ( job_resrcs_ptr -> memory_allocated ) { slurm_array64_to_value_reps ( job_resrcs_ptr -> memory_allocated , job_resrcs_ptr -> nhosts , & cred_arg . job_mem_alloc , & cred_arg . job_mem_alloc_rep_count , & cred_arg . job_mem_alloc_size ) ; } cred_arg . step_core_bitmap = job_resrcs_ptr -> core_bitmap ; xassert ( job_ptr -> batch_host ) ; cred_arg . job_hostlist = job_ptr -> batch_host ; cred_arg . step_hostlist = job_ptr -> batch_host ; cred_arg . step_hostlist = job_ptr -> job_resrcs -> nodes ; if ( protocol_version >= SLURM_22_05_PROTOCOL_VERSION ) { sign_cred = false ; } else { sign_cred = true ; } prolog_msg_ptr -> cred = slurm_cred_create ( slurmctld_config . cred_ctx , & cred_arg , sign_cred , protocol_version ) ; xfree ( cred_arg . job_mem_alloc ) ; xfree ( cred_arg . job_mem_alloc_rep_count ) ; if ( ! prolog_msg_ptr -> cred ) { error ( "%s: slurm_cred_create failure for %pJ" , __func__ , job_ptr ) ; slurm_free_prolog_launch_msg ( prolog_msg_ptr ) ; job_ptr -> details -> begin_time = time ( NULL ) + 120 ; job_complete ( job_ptr -> job_id , slurm_conf . slurm_user_id , true , false , 0 ) ; return ; } agent_arg_ptr = xmalloc ( sizeof ( agent_arg_t ) ) ; agent_arg_ptr -> retry = 0 ; agent_arg_ptr -> protocol_version = protocol_version ; xassert ( job_ptr -> front_end_ptr -> name ) ; agent_arg_ptr -> hostlist = hostlist_create ( job_ptr -> front_end_ptr -> name ) ; agent_arg_ptr -> node_count = 1 ; agent_arg_ptr -> hostlist = hostlist_create ( job_ptr -> nodes ) ; agent_arg_ptr -> node_count = job_ptr -> node_cnt ; agent_arg_ptr -> msg_type = REQUEST_LAUNCH_PROLOG ; agent_arg_ptr -> msg_args = ( void * ) prolog_msg_ptr ; if ( slurm_conf . prolog_flags & PROLOG_FLAG_CONTAIN ) { step_record_t * step_ptr = build_extern_step ( job_ptr ) ; if ( step_ptr ) { select_g_step_start ( step_ptr ) ; } else { error ( "%s: build_extern_step failure for %pJ" , __func__ , job_ptr ) ; } } set_agent_arg_r_uid ( agent_arg_ptr , SLURM_AUTH_UID_ANY ) ; agent_queue_request ( agent_arg_ptr ) ; } 