static void test_circuit_choose_ip_ap_for_extend ( void * arg ) { ( void ) arg ; tor_addr_port_t ipv4_ap ; tor_addr_port_t ipv6_ap ; tor_addr_parse ( & ipv4_ap . addr , PUBLIC_IPV4 ) ; ipv4_ap . port = VALID_PORT ; tor_addr_parse ( & ipv6_ap . addr , PUBLIC_IPV6 ) ; ipv6_ap . port = VALID_PORT ; or_options_t * fake_options = options_new ( ) ; MOCK ( get_options , mock_get_options ) ; mocked_options = fake_options ; MOCK ( router_can_extend_over_ipv6 , mock_router_can_extend_over_ipv6 ) ; can_extend_over_ipv6_result = true ; mock_router_can_extend_over_ipv6_calls = 0 ; can_extend_over_ipv6_result = true ; mock_router_can_extend_over_ipv6_calls = 0 ; tt_ptr_op ( circuit_choose_ip_ap_for_extend ( NULL , NULL ) , OP_EQ , NULL ) ; tt_int_op ( mock_router_can_extend_over_ipv6_calls , OP_EQ , 1 ) ; can_extend_over_ipv6_result = false ; mock_router_can_extend_over_ipv6_calls = 0 ; tt_ptr_op ( circuit_choose_ip_ap_for_extend ( NULL , NULL ) , OP_EQ , NULL ) ; tt_int_op ( mock_router_can_extend_over_ipv6_calls , OP_EQ , 1 ) ; can_extend_over_ipv6_result = true ; mock_router_can_extend_over_ipv6_calls = 0 ; tt_ptr_op ( circuit_choose_ip_ap_for_extend ( & ipv4_ap , NULL ) , OP_EQ , & ipv4_ap ) ; tt_int_op ( mock_router_can_extend_over_ipv6_calls , OP_EQ , 1 ) ; can_extend_over_ipv6_result = false ; mock_router_can_extend_over_ipv6_calls = 0 ; tt_ptr_op ( circuit_choose_ip_ap_for_extend ( & ipv4_ap , NULL ) , OP_EQ , & ipv4_ap ) ; tt_int_op ( mock_router_can_extend_over_ipv6_calls , OP_EQ , 1 ) ; can_extend_over_ipv6_result = true ; mock_router_can_extend_over_ipv6_calls = 0 ; tt_ptr_op ( circuit_choose_ip_ap_for_extend ( NULL , & ipv6_ap ) , OP_EQ , & ipv6_ap ) ; tt_int_op ( mock_router_can_extend_over_ipv6_calls , OP_EQ , 1 ) ; can_extend_over_ipv6_result = false ; mock_router_can_extend_over_ipv6_calls = 0 ; tt_ptr_op ( circuit_choose_ip_ap_for_extend ( NULL , & ipv6_ap ) , OP_EQ , NULL ) ; tt_int_op ( mock_router_can_extend_over_ipv6_calls , OP_EQ , 1 ) ; const tor_addr_port_t * chosen_addr = NULL ; can_extend_over_ipv6_result = true ; mock_router_can_extend_over_ipv6_calls = 0 ; chosen_addr = circuit_choose_ip_ap_for_extend ( & ipv4_ap , & ipv6_ap ) ; tt_assert ( chosen_addr == & ipv4_ap || chosen_addr == & ipv6_ap ) ; tt_int_op ( mock_router_can_extend_over_ipv6_calls , OP_EQ , 1 ) ; can_extend_over_ipv6_result = false ; mock_router_can_extend_over_ipv6_calls = 0 ; tt_ptr_op ( circuit_choose_ip_ap_for_extend ( & ipv4_ap , & ipv6_ap ) , OP_EQ , & ipv4_ap ) ; tt_int_op ( mock_router_can_extend_over_ipv6_calls , OP_EQ , 1 ) ; done UNMOCK ( get_options ) ; or_options_free ( fake_options ) ; mocked_options = NULL ; UNMOCK ( router_can_extend_over_ipv6 ) ; } 