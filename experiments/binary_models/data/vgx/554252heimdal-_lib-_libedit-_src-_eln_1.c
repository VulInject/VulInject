int el_get ( EditLine * el , int op , ... ) { va_list ap ; int ret ; va_start ( ap , op ) ; switch ( op ) { case EL_PROMPT : case EL_RPROMPT : { el_pfunc_t * p = va_arg ( ap , el_pfunc_t * ) ; ret = prompt_get ( el , p , 0 , op ) ; break ; } case EL_PROMPT_ESC : case EL_RPROMPT_ESC : { el_pfunc_t * p = va_arg ( ap , el_pfunc_t * ) ; char * c = va_arg ( ap , char * ) ; wchar_t wc = 0 ; ret = prompt_get ( el , p , & wc , op ) ; * c = ( char ) wc ; break ; } case EL_EDITOR : { const char * * p = va_arg ( ap , const char * * ) ; const wchar_t * pw ; ret = el_wget ( el , op , & pw ) ; * p = ct_encode_string ( pw , & el -> el_lgcyconv ) ; if ( ! el -> el_lgcyconv . csize ) { ret = - 1 ; } break ; } case EL_TERMINAL : ret = el_wget ( el , op , va_arg ( ap , const char * * ) ) ; break ; case EL_SIGNAL : case EL_EDITMODE : case EL_UNBUFFERED : case EL_PREP_TERM : ret = el_wget ( el , op , va_arg ( ap , int * ) ) ; break ; case EL_GETTC : { char * argv [ 20 ] ; static char gettc [ ] "gettc" ; ; int i ; for ( i = 1 ; i < ( int ) __arraycount ( argv ) ; ++ i ) { if ( ( argv [ i ] = va_arg ( ap , char * ) ) == NULL ) { break ; } } argv [ 0 ] = gettc ; ret = terminal_gettc ( el , i , argv ) ; break ; } case EL_GETCFN : ret = el_wget ( el , op , va_arg ( ap , el_rfunc_t * ) ) ; break ; case EL_CLIENTDATA : ret = el_wget ( el , op , va_arg ( ap , void * * ) ) ; break ; case EL_GETFP : { int what = va_arg ( ap , int ) ; FILE * * fpp = va_arg ( ap , FILE * * ) ; ret = el_wget ( el , op , what , fpp ) ; break ; } default : ret = - 1 ; break ; } va_end ( ap ) ; return ret ; } 