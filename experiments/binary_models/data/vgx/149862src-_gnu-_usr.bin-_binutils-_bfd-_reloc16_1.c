bfd_coff_reloc16_get_relocated_section_contents ( , , , , , ) bfd * in_abfd ; struct bfd_link_info * link_info ; struct bfd_link_order * link_order ; bfd_byte * data ; bfd_boolean relocatable ; asymbol * * symbols ; { bfd * input_bfd = link_order -> u . indirect . section -> owner ; asection * input_section = link_order -> u . indirect . section ; long reloc_size = bfd_get_reloc_upper_bound ( input_bfd , input_section ) ; arelent * * reloc_vector ; long reloc_count ; if ( reloc_size < 0 ) { return NULL ; } if ( relocatable ) { return bfd_generic_get_relocated_section_contents ( in_abfd , link_info , link_order , data , relocatable , symbols ) ; } if ( ! bfd_get_section_contents ( input_bfd , input_section , data , ( bfd_vma ) 0 , input_section -> _raw_size ) ) { return NULL ; } reloc_vector = ( arelent * * ) bfd_malloc ( ( bfd_size_type ) reloc_size ) ; if ( ! reloc_vector && reloc_size != 0 ) { return NULL ; } reloc_count = bfd_canonicalize_reloc ( input_bfd , input_section , reloc_vector , symbols ) ; if ( reloc_count < 0 ) { return NULL ; } if ( reloc_count > 0 ) { arelent * * parent = reloc_vector ; arelent * reloc ; unsigned int dst_address = 0 ; unsigned int src_address = 0 ; unsigned int run ; unsigned int idx ; while ( dst_address < link_order -> size ) { reloc = * parent ; if ( reloc ) { run = reloc -> address - src_address ; parent ++ ; } else { run = link_order -> size - dst_address ; } for ( idx = 0 ; idx < run ; idx ++ ) { data [ dst_address ++ ] = data [ src_address ++ ] ; } if ( reloc ) { bfd_coff_reloc16_extra_cases ( input_bfd , link_info , link_order , reloc , data , & src_address , & dst_address ) ; } } } free ( ( char * ) reloc_vector ) ; return data ; } 