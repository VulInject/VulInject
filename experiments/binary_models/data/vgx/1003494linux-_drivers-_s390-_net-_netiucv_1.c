static int netiucv_transmit_skb ( struct iucv_connection * conn , struct sk_buff * skb ) { struct iucv_message msg ; unsigned long saveflags ; struct ll_header header ; int rc ; if ( fsm_getstate ( conn -> fsm ) != CONN_STATE_IDLE ) { int l = skb -> len + NETIUCV_HDRLEN ; spin_lock_irqsave ( & conn -> collect_lock , saveflags ) ; if ( conn -> collect_len + l > ( conn -> max_buffsize - NETIUCV_HDRLEN ) ) { rc = - EBUSY ; IUCV_DBF_TEXT ( data , 2 , "EBUSY from netiucv_transmit_skb\n" ) ; } else { atomic_inc ( & skb -> users ) ; skb_queue_tail ( & conn -> collect_queue , skb ) ; conn -> collect_len += l ; rc = 0 ; } spin_unlock_irqrestore ( & conn -> collect_lock , saveflags ) ; } else { struct sk_buff * nskb = skb ; unsigned long hi = ( ( unsigned long ) ( skb_tail_pointer ( skb ) + NETIUCV_HDRLEN ) ) >> 31 ; int copied = 0 ; if ( hi || ( skb_tailroom ( skb ) < 2 ) ) { nskb = alloc_skb ( skb -> len + NETIUCV_HDRLEN + NETIUCV_HDRLEN , GFP_ATOMIC | GFP_DMA ) ; if ( ! nskb ) { IUCV_DBF_TEXT ( data , 2 , "alloc_skb failed\n" ) ; rc = - ENOMEM ; return rc ; } else { skb_reserve ( nskb , NETIUCV_HDRLEN ) ; skb_put_data ( nskb , skb -> data , skb -> len ) ; } copied = 1 ; } header . next = nskb -> len + NETIUCV_HDRLEN ; memcpy ( skb_push ( nskb , NETIUCV_HDRLEN ) , & header , NETIUCV_HDRLEN ) ; header . next = 0 ; skb_put_data ( nskb , & header , NETIUCV_HDRLEN ) ; fsm_newstate ( conn -> fsm , CONN_STATE_TX ) ; conn -> prof . send_stamp = jiffies ; msg . tag = 1 ; msg . class = 0 ; rc = iucv_message_send ( conn -> path , & msg , 0 , 0 , nskb -> data , nskb -> len ) ; conn -> prof . doios_single ++ ; conn -> prof . txlen += skb -> len ; conn -> prof . tx_pending ++ ; if ( conn -> prof . tx_pending > conn -> prof . tx_max_pending ) { conn -> prof . tx_max_pending = conn -> prof . tx_pending ; } if ( rc ) { struct netiucv_priv * privptr ; fsm_newstate ( conn -> fsm , CONN_STATE_IDLE ) ; conn -> prof . tx_pending -- ; privptr = netdev_priv ( conn -> netdev ) ; if ( privptr ) { privptr -> stats . tx_errors ++ ; } if ( copied ) { dev_kfree_skb ( nskb ) ; } else { skb_pull ( skb , NETIUCV_HDRLEN ) ; skb_trim ( skb , skb -> len - NETIUCV_HDRLEN ) ; } IUCV_DBF_TEXT_ ( data , 2 , "rc %d from iucv_send\n" , rc ) ; } else { if ( copied ) { dev_kfree_skb ( skb ) ; } refcount_inc ( & nskb -> users ) ; skb_queue_tail ( & conn -> commit_queue , nskb ) ; } } return rc ; } 