int CreateVolumeHeaderInMemory ( HWND hwndDlg , BOOL bBoot , char * header , int ea , int mode , Password * password , int pkcs5_prf , int pim , char * masterKeydata , PCRYPTO_INFO * retInfo , unsigned __int64 volumeSize , unsigned __int64 hiddenVolumeSize , unsigned __int64 encryptedAreaStart , unsigned __int64 encryptedAreaLength , uint16 requiredProgramVersion , uint32 headerFlags , uint32 sectorSize , BOOL bWipeMode ) { unsigned char * p = ( unsigned char * ) header ; static CRYPTOPP_ALIGN_DATA ( 16 ) KEY_INFO keyInfo ; int nUserKeyLen = password ?password -> Length : 0 ; PCRYPTO_INFO cryptoInfo = crypto_open ( ) ; static char dk [ MASTER_KEYDATA_SIZE ] ; int x ; int retVal = 0 ; int primaryKeyOffset ; if ( cryptoInfo == NULL ) { return ERR_OUTOFMEMORY ; } if ( pim < 0 ) { pim = 0 ; } VirtualLock ( & keyInfo , sizeof ( keyInfo ) ) ; VirtualLock ( & dk , sizeof ( dk ) ) ; if ( masterKeydata == NULL ) { int bytesNeeded ; switch ( mode ) { default : bytesNeeded = EAGetKeySize ( ea ) * 2 ; } if ( ! RandgetBytes ( hwndDlg , keyInfo . master_keydata , bytesNeeded , TRUE ) ) { if ( ! RandgetBytes ( keyInfo . master_keydata , bytesNeeded , TRUE ) ) { crypto_close ( cryptoInfo ) ; retVal = ERR_CIPHER_INIT_WEAK_KEY ; err } } } else { memcpy ( keyInfo . master_keydata , masterKeydata , MASTER_KEYDATA_SIZE ) ; } if ( password ) { memcpy ( keyInfo . userKey , password -> Text , nUserKeyLen ) ; keyInfo . keyLength = nUserKeyLen ; keyInfo . noIterations = get_pkcs5_iteration_count ( pkcs5_prf , pim , FALSE , bBoot ) ; } else { keyInfo . keyLength = 0 ; keyInfo . noIterations = 0 ; } cryptoInfo -> ea = ea ; cryptoInfo -> pkcs5 = pkcs5_prf ; cryptoInfo -> bTrueCryptMode = FALSE ; cryptoInfo -> noIterations = keyInfo . noIterations ; cryptoInfo -> volumePim = pim ; cryptoInfo -> mode = mode ; if ( ! RandgetBytes ( hwndDlg , keyInfo . salt , PKCS5_SALT_SIZE , ! bWipeMode ) ) { if ( ! RandgetBytes ( keyInfo . salt , PKCS5_SALT_SIZE , ! bWipeMode ) ) { crypto_close ( cryptoInfo ) ; retVal = ERR_CIPHER_INIT_WEAK_KEY ; err } } if ( password ) { switch ( pkcs5_prf ) { case SHA512 : derive_key_sha512 ( keyInfo . userKey , keyInfo . keyLength , keyInfo . salt , PKCS5_SALT_SIZE , keyInfo . noIterations , dk , GetMaxPkcs5OutSize ( ) ) ; break ; case SHA256 : derive_key_sha256 ( keyInfo . userKey , keyInfo . keyLength , keyInfo . salt , PKCS5_SALT_SIZE , keyInfo . noIterations , dk , GetMaxPkcs5OutSize ( ) ) ; break ; case BLAKE2S : derive_key_blake2s ( keyInfo . userKey , keyInfo . keyLength , keyInfo . salt , PKCS5_SALT_SIZE , keyInfo . noIterations , dk , GetMaxPkcs5OutSize ( ) ) ; break ; case WHIRLPOOL : derive_key_whirlpool ( keyInfo . userKey , keyInfo . keyLength , keyInfo . salt , PKCS5_SALT_SIZE , keyInfo . noIterations , dk , GetMaxPkcs5OutSize ( ) ) ; break ; case STREEBOG : derive_key_streebog ( keyInfo . userKey , keyInfo . keyLength , keyInfo . salt , PKCS5_SALT_SIZE , keyInfo . noIterations , dk , GetMaxPkcs5OutSize ( ) ) ; break ; default : crypto_close ( cryptoInfo ) ; TC_THROW_FATAL_EXCEPTION ; } } else { if ( ! RandgetBytes ( hwndDlg , dk , GetMaxPkcs5OutSize ( ) , ! bWipeMode ) ) { if ( ! RandgetBytes ( dk , GetMaxPkcs5OutSize ( ) , ! bWipeMode ) ) { crypto_close ( cryptoInfo ) ; retVal = ERR_CIPHER_INIT_WEAK_KEY ; err } } } mputBytes ( p , keyInfo . salt , PKCS5_SALT_SIZE ) ; mputLong ( p , 0x56455241 ) ; mputWord ( p , VOLUME_HEADER_VERSION ) ; cryptoInfo -> HeaderVersion = VOLUME_HEADER_VERSION ; mputWord ( p , requiredProgramVersion != 0 ?requiredProgramVersion : TC_VOLUME_MIN_REQUIRED_PROGRAM_VERSION ) ; x = GetCrc32 ( keyInfo . master_keydata , MASTER_KEYDATA_SIZE ) ; mputLong ( p , x ) ; p += 2 * 8 ; cryptoInfo -> hiddenVolumeSize = hiddenVolumeSize ; mputInt64 ( p , cryptoInfo -> hiddenVolumeSize ) ; cryptoInfo -> hiddenVolume = cryptoInfo -> hiddenVolumeSize != 0 ; cryptoInfo -> VolumeSize . Value = volumeSize ; mputInt64 ( p , volumeSize ) ; cryptoInfo -> EncryptedAreaStart . Value = encryptedAreaStart ; mputInt64 ( p , encryptedAreaStart ) ; cryptoInfo -> EncryptedAreaLength . Value = encryptedAreaLength ; mputInt64 ( p , encryptedAreaLength ) ; cryptoInfo -> HeaderFlags = headerFlags ; mputLong ( p , headerFlags ) ; if ( sectorSize ( TC_MIN_VOLUME_SECTOR_SIZE || sectorSize ) TC_MAX_VOLUME_SECTOR_SIZE || sectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0 ) { crypto_close ( cryptoInfo ) ; TC_THROW_FATAL_EXCEPTION ; } cryptoInfo -> SectorSize = sectorSize ; mputLong ( p , sectorSize ) ; x = GetCrc32 ( header + TC_HEADER_OFFSET_MAGIC , TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC ) ; p = header + TC_HEADER_OFFSET_HEADER_CRC ; mputLong ( p , x ) ; memcpy ( header + HEADER_MASTER_KEYDATA_OFFSET , keyInfo . master_keydata , MASTER_KEYDATA_SIZE ) ; memcpy ( cryptoInfo -> k2 , dk + EAGetKeySize ( cryptoInfo -> ea ) , EAGetKeySize ( cryptoInfo -> ea ) ) ; primaryKeyOffset = 0 ; retVal = EAInit ( cryptoInfo -> ea , dk + primaryKeyOffset , cryptoInfo -> ks ) ; if ( retVal != ERR_SUCCESS ) { crypto_close ( cryptoInfo ) ; err } if ( ! EAInitMode ( cryptoInfo , dk + EAGetKeySize ( cryptoInfo -> ea ) ) ) { crypto_close ( cryptoInfo ) ; retVal = ERR_OUTOFMEMORY ; err } EncryptBuffer ( header + HEADER_ENCRYPTED_DATA_OFFSET , HEADER_ENCRYPTED_DATA_SIZE , cryptoInfo ) ; retVal = EAInit ( cryptoInfo -> ea , keyInfo . master_keydata + primaryKeyOffset , cryptoInfo -> ks ) ; if ( retVal != ERR_SUCCESS ) { crypto_close ( cryptoInfo ) ; err } memcpy ( cryptoInfo -> master_keydata , keyInfo . master_keydata , MASTER_KEYDATA_SIZE ) ; memcpy ( cryptoInfo -> k2 , keyInfo . master_keydata + EAGetKeySize ( cryptoInfo -> ea ) , EAGetKeySize ( cryptoInfo -> ea ) ) ; if ( ! EAInitMode ( cryptoInfo , keyInfo . master_keydata + EAGetKeySize ( cryptoInfo -> ea ) ) ) { crypto_close ( cryptoInfo ) ; retVal = ERR_OUTOFMEMORY ; err } if ( ! bInPlaceEncNonSys && ( showKeys || ( bBoot && ! masterKeydata ) ) ) { BOOL dots3 = FALSE ; int i , j ; j = EAGetKeySize ( ea ) ; if ( j > NBR_KEY_BYTES_TO_DISPLAY ) { dots3 = TRUE ; j = NBR_KEY_BYTES_TO_DISPLAY ; } MasterKeyGUIView [ 0 ] = 0 ; for ( i = 0 ; i < j ; i ++ ) { wchar_t tmp2 [ 8 ] { 0 } ; ; StringCchPrintfW ( tmp2 , ARRAYSIZE ( tmp2 ) , L"%02X" , ( int ) ( unsigned char ) keyInfo . master_keydata [ i + primaryKeyOffset ] ) ; StringCchCatW ( MasterKeyGUIView , ARRAYSIZE ( MasterKeyGUIView ) , tmp2 ) ; } HeaderKeyGUIView [ 0 ] = 0 ; for ( i = 0 ; i < NBR_KEY_BYTES_TO_DISPLAY ; i ++ ) { wchar_t tmp2 [ 8 ] ; StringCchPrintfW ( tmp2 , ARRAYSIZE ( tmp2 ) , L"%02X" , ( int ) ( unsigned char ) dk [ primaryKeyOffset + i ] ) ; StringCchCatW ( HeaderKeyGUIView , ARRAYSIZE ( HeaderKeyGUIView ) , tmp2 ) ; } if ( dots3 ) { DisplayPortionsOfKeys ( hHeaderKey , hMasterKey , HeaderKeyGUIView , MasterKeyGUIView , ! showKeys ) ; } else { SendMessage ( hMasterKey , WM_SETTEXT , 0 , ( LPARAM ) MasterKeyGUIView ) ; SendMessage ( hHeaderKey , WM_SETTEXT , 0 , ( LPARAM ) HeaderKeyGUIView ) ; } } * retInfo = cryptoInfo ; err burn ( dk , sizeof ( dk ) ) ; burn ( & keyInfo , sizeof ( keyInfo ) ) ; VirtualUnlock ( & keyInfo , sizeof ( keyInfo ) ) ; VirtualUnlock ( & dk , sizeof ( dk ) ) ; return 0 ; } 