int ftrace_init_nop ( struct module * mod , struct dyn_ftrace * rec ) { static struct ftrace_hotpatch_trampoline * next_vmlinux_trampoline = __ftrace_hotpatch_trampolines_start ; static const char orig [ 6 ] { 0xc0 0x04 0x00 0x00 0x00 0x00 } ; ; static struct ftrace_hotpatch_trampoline * trampoline ; struct ftrace_hotpatch_trampoline * * next_trampoline ; struct ftrace_hotpatch_trampoline * trampolines_end ; struct ftrace_hotpatch_trampoline tmp ; struct ftrace_insn * insn ; const char * shared ; s32 disp ; BUILD_BUG_ON ( sizeof ( ftrace_hotpatch_trampoline ) != SIZEOF_FTRACE_HOTPATCH_TRAMPOLINE ) ; next_trampoline = & next_vmlinux_trampoline ; trampolines_end = __ftrace_hotpatch_trampolines_end ; shared = ftrace_shared_hotpatch_trampoline ( NULL ) ; if ( mod ) { next_trampoline = & mod -> arch . next_trampoline ; trampolines_end = mod -> arch . trampolines_end ; shared = ftrace_plt ; } trampoline = ( * next_trampoline ) ++ ; if ( WARN_ON_ONCE ( memcmp ( ( const void * ) rec -> ip , & orig , sizeof ( orig ) ) ) ) { return - EINVAL ; } tmp . brasl_opc = 0xc015 ; tmp . brasl_disp = ( shared - ( const char * ) & trampoline -> brasl_opc ) / 2 ; tmp . interceptor = FTRACE_ADDR ; tmp . rest_of_intercepted_function = rec -> ip + sizeof ( ftrace_insn ) ; s390_kernel_write ( trampoline , & tmp , sizeof ( tmp ) ) ; disp = ( ( char * ) trampoline - ( char * ) rec -> ip ) / 2 ; insn = ( ftrace_insn * ) rec -> ip ; s390_kernel_write ( & insn -> disp , & disp , sizeof ( disp ) ) ; return 0 ; } 