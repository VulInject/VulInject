static int upnpc_receive_and_parse_ssdp ( upnpc_t * p ) { int n ; char bufr [ 1024 ] ; n = recv ( p -> ssdp_socket , bufr , sizeof ( bufr ) , 0 ) ; if ( n < 0 ) { PRINT_SOCKET_ERROR ( "recv" ) ; } if ( n == 0 ) { debug_printf ( "empty packet received\n" ) ; } else { const char * location = NULL ; unsigned int locationsize ; const char * st = NULL ; unsigned int stsize ; debug_printf ( "%.*s" , n , bufr ) ; parse_msearch_reply ( bufr , n , & location , & locationsize , & st , & stsize ) ; debug_printf ( "location = '%.*s'\n" , locationsize , location ) ; debug_printf ( "st = '%.*s'\n" , stsize , st ) ; if ( location != NULL ) { upnpc_device_t * dev = p -> device_list ; while ( dev != NULL ) { if ( dev -> root_desc_location != NULL && strlen ( dev -> root_desc_location ) == locationsize && memcmp ( dev -> root_desc_location , location , locationsize ) == 0 ) { debug_printf ( "device already in list (location='%s')\n" , dev -> root_desc_location ) ; return - 1 ; } dev = dev -> next ; } dev = calloc ( 1 , sizeof ( upnpc_device_t ) ) ; if ( dev == NULL ) { p -> state = EUPnPError ; return - 1 ; } if ( upnpc_set_root_desc_location ( dev , location , locationsize ) < 0 ) { p -> state = EUPnPError ; return - 1 ; } dev -> next = p -> device_list ; p -> device_list = dev ; dev -> state = EDevGetDescConnect ; upnpc_connect ( dev , dev -> root_desc_location ) ; } else { p -> state = EUPnPError ; } } return 0 ; } 