bool littlefury_detect_one ( const char * devpath ) { int fd , chips ; uint8_t buf [ 255 ] ; uint16_t bufsz ; struct cgpu_info dummy ; char * devname = NULL ; fd = serial_open ( devpath , 0 , 10 , true ) ; applog ( LOG_DEBUG , "%s: %s %s" , littlefury_drv . dname , ( ( fd == - 1 ) ?"Failed to open" : "Successfully opened" ) , devpath ) ; if ( unlikely ( fd == - 1 ) ) { err } bufsz = sizeof ( buf ) ; if ( ! bitfury_do_packet ( LOG_DEBUG , littlefury_drv . dname , fd , buf , & bufsz , LFOP_VERSION , NULL , 0 ) ) { err } if ( bufsz < 4 ) { applog ( LOG_DEBUG , "%s: Incomplete version response" , littlefury_drv . dname ) ; err } devname = malloc ( bufsz - 3 ) ; memcpy ( devname , ( char * ) & buf [ 4 ] , bufsz - 4 ) ; devname [ bufsz - 4 ] = '\0' ; applog ( LOG_DEBUG , "%s: Identified %s %d.%d.%d (features %02x)" , littlefury_drv . dname , devname , buf [ 0 ] , buf [ 1 ] , buf [ 2 ] , buf [ 3 ] ) ; if ( ! littlefury_set_power ( LOG_DEBUG , littlefury_drv . dname , fd , true ) ) { applog ( LOG_WARNING , "%s: Unable to power on chip(s) for %s" , littlefury_drv . dname , devpath ) ; } dummy . device = & dummy ; dummy . device_fd = fd ; chips = littlefury_chip_count ( & dummy ) ; if ( ! chips ) { applog ( LOG_WARNING , "%s: No Bitfury chips detected on %s" , littlefury_drv . dname , devpath ) ; err } else { applog ( LOG_DEBUG , "%s: %d chips detected" , littlefury_drv . dname , chips ) ; } littlefury_set_power ( LOG_DEBUG , littlefury_drv . dname , fd , false ) ; if ( serial_claim_v ( devpath , & littlefury_drv ) ) { err } serial_close ( fd ) ; struct cgpu_info * cgpu ; cgpu = malloc ( sizeof ( * cgpu ) ) ; * cgpu = ( cgpu_info ) { . drv = & littlefury_drv . set_device_funcs = bitfury_set_device_funcs . device_path = strdup ( devpath ) . deven = DEV_ENABLED . procs = chips . threads = 1 . name = devname . cutofftemp = 85 } ; cgpu -> device_fd = - 1 ; return add_cgpu ( cgpu ) ; err if ( fd != - 1 ) { serial_close ( fd ) ; } return false ; } 