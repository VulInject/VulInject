STATIC void deallocate_dependencies ( struct buf * bp , struct inodedep * inodedep ) { struct worklist * wk ; struct indirdep * indirdep ; struct allocindir * aip ; struct pagedep * pagedep ; struct dirrem * dirrem ; struct diradd * dap ; int i ; while ( ( wk = LIST_FIRST ( & bp -> b_dep ) ) != NULL ) { switch ( wk -> wk_type ) { case D_INDIRDEP : indirdep = WK_INDIRDEP ( wk ) ; if ( indirdep -> ir_state & GOINGAWAY ) { FREE_LOCK ( & lk ) ; panic ( "deallocate_dependencies: already gone" ) ; } indirdep -> ir_state |= GOINGAWAY ; while ( ( aip = LIST_FIRST ( & indirdep -> ir_deplisthd ) ) ) { free_allocindir ( aip , inodedep ) ; } if ( bp -> b_lblkno >= 0 || bp -> b_blkno != indirdep -> ir_savebp -> b_lblkno ) { FREE_LOCK ( & lk ) ; panic ( "deallocate_dependencies: not indir" ) ; } memcpy ( indirdep -> ir_savebp -> b_data , bp -> b_data , bp -> b_bcount ) ; WORKLIST_REMOVE ( wk , NULL ) ; WORKLIST_INSERT ( & indirdep -> ir_savebp -> b_dep , wk ) ; continue ; case D_PAGEDEP : pagedep = WK_PAGEDEP ( wk ) ; for ( i = 0 ; i < DAHASHSZ ; i ++ ) { while ( ( dap = LIST_FIRST ( & pagedep -> pd_diraddhd [ i ] ) ) ) { free_diradd ( dap ) ; } } while ( ( dap = LIST_FIRST ( & pagedep -> pd_pendinghd ) ) ) { free_diradd ( dap ) ; } while ( ( dirrem = LIST_FIRST ( & pagedep -> pd_dirremhd ) ) ) { LIST_REMOVE ( dirrem , dm_next ) ; dirrem -> dm_dirinum = pagedep -> pd_ino ; if ( inodedep == NULL || ( inodedep -> id_state & ALLCOMPLETE ) == ALLCOMPLETE ) { add_to_worklist ( & dirrem -> dm_list ) ; } else { WORKLIST_INSERT ( & inodedep -> id_bufwait , & dirrem -> dm_list ) ; } } if ( ( pagedep -> pd_state & NEWBLOCK ) != 0 ) { LIST_FOREACH ( , , ) if ( wk -> wk_type == D_NEWDIRBLK && WK_NEWDIRBLK ( wk ) -> db_pagedep == pagedep ) { break ; } if ( wk != NULL ) { WORKLIST_REMOVE ( wk ) ; free_newdirblk ( WK_NEWDIRBLK ( wk ) ) ; } else { FREE_LOCK ( & lk ) ; panic ( "deallocate_dependencies: " "lost pagedep" ) ; } } WORKLIST_REMOVE ( & pagedep -> pd_list ) ; LIST_REMOVE ( pagedep , pd_hash ) ; WORKITEM_FREE ( pagedep , D_PAGEDEP ) ; continue ; case D_ALLOCINDIR : free_allocindir ( WK_ALLOCINDIR ( wk ) , inodedep ) ; continue ; case D_ALLOCDIRECT : case D_INODEDEP : FREE_LOCK ( & lk ) ; panic ( "deallocate_dependencies: Unexpected type %s" , TYPENAME ( wk -> wk_type ) ) ; default : FREE_LOCK ( & lk ) ; panic ( "deallocate_dependencies: Unknown type %s" , TYPENAME ( wk -> wk_type ) ) ; } } } 