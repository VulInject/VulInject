void xenvif_set_skb_hash ( struct xenvif * vif , struct sk_buff * skb ) { struct flow_keys flow ; u32 hash = 0 ; enum pkt_hash_types type = PKT_HASH_TYPE_NONE ; u32 flags = vif -> hash . flags ; bool has_tcp_hdr ; switch ( skb -> protocol ) { case htons ( ETH_P_IP ) : if ( flags & ( XEN_NETIF_CTRL_HASH_TYPE_IPV4_TCP | XEN_NETIF_CTRL_HASH_TYPE_IPV4 ) ) { break ; } done case htons ( ETH_P_IPV6 ) : if ( flags & ( XEN_NETIF_CTRL_HASH_TYPE_IPV6_TCP | XEN_NETIF_CTRL_HASH_TYPE_IPV6 ) ) { break ; } done default : done } if ( ! skb_flow_dissect_flow_keys ( skb , & flow , 0 ) ) { done } has_tcp_hdr = ( flow . basic . ip_proto == IPPROTO_TCP ) && ! ( flow . control . flags & FLOW_DIS_IS_FRAGMENT ) ; switch ( skb -> protocol ) { case htons ( ETH_P_IP ) : if ( has_tcp_hdr && ( flags & XEN_NETIF_CTRL_HASH_TYPE_IPV4_TCP ) ) { u8 data [ 12 ] ; memcpy ( & data [ 0 ] , & flow . addrs . v4addrs . src , 4 ) ; memcpy ( & data [ 4 ] , & flow . addrs . v4addrs . dst , 4 ) ; memcpy ( & data [ 8 ] , & flow . ports . src , 2 ) ; memcpy ( & data [ 10 ] , & flow . ports . dst , 2 ) ; hash = xenvif_find_hash ( vif , data , sizeof ( data ) ) ; type = PKT_HASH_TYPE_L4 ; } if ( flags & XEN_NETIF_CTRL_HASH_TYPE_IPV4 ) { u8 data [ 8 ] ; memcpy ( & data [ 0 ] , & flow . addrs . v4addrs . src , 4 ) ; memcpy ( & data [ 4 ] , & flow . addrs . v4addrs . dst , 4 ) ; hash = xenvif_find_hash ( vif , data , sizeof ( data ) ) ; type = PKT_HASH_TYPE_L3 ; } break ; case htons ( ETH_P_IPV6 ) : if ( has_tcp_hdr && ( flags & XEN_NETIF_CTRL_HASH_TYPE_IPV6_TCP ) ) { u8 data [ 36 ] ; memcpy ( & data [ 0 ] , & flow . addrs . v6addrs . src , 16 ) ; memcpy ( & data [ 16 ] , & flow . addrs . v6addrs . dst , 16 ) ; memcpy ( & data [ 32 ] , & flow . ports . src , 2 ) ; memcpy ( & data [ 34 ] , & flow . ports . dst , 2 ) ; hash = xenvif_find_hash ( vif , data , sizeof ( data ) ) ; type = PKT_HASH_TYPE_L4 ; } if ( flags & XEN_NETIF_CTRL_HASH_TYPE_IPV6 ) { u8 data [ 32 ] ; memcpy ( & data [ 0 ] , & flow . addrs . v6addrs . src , 16 ) ; memcpy ( & data [ 16 ] , & flow . addrs . v6addrs . dst , 16 ) ; hash = xenvif_find_hash ( vif , data , sizeof ( data ) ) ; type = PKT_HASH_TYPE_L3 ; } break ; } done if ( type == PKT_HASH_TYPE_NONE ) { skb_clear_hash ( skb ) ; } else { __skb_set_sw_hash ( skb , hash , type == PKT_HASH_TYPE_L4 ) ; } } 