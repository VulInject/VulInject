void terminate_all_calls ( credit_data_t * credit_data ) { call_t * call = NULL , * tmp = NULL ; struct str_hash_entry * cd_entry = NULL ; hash_tables_t * hts = NULL ; int pending = 0 ; switch ( credit_data -> type ) { case CREDIT_MONEY : hts = & _data . money ; break ; case CREDIT_TIME : hts = & _data . time ; break ; case CREDIT_CHANNEL : hts = & _data . channel ; break ; default : LM_ERR ( "BUG: Something went terribly wrong\n" ) ; return ; } cd_entry = str_hash_get ( hts -> credit_data_by_client , credit_data -> call_list -> client_id . s , credit_data -> call_list -> client_id . len ) ; if ( cd_entry == NULL ) { LM_WARN ( "credit data item not found\n" ) ; return ; } credit_data -> deallocating = 1 ; clist_foreach_safe ( , , , ) { if ( call -> sip_data . callid . s != NULL ) { if ( call -> confirmed ) { LM_DBG ( "Killing call with CID [%.*s]\n" , call -> sip_data . callid . len , call -> sip_data . callid . s ) ; _data . stats -> dropped ++ ; terminate_call ( call ) ; } else { LM_DBG ( "Non confirmed call with CID[%.*s], setting " "max_amount:%f to 0\n" , call -> sip_data . callid . len , call -> sip_data . callid . s , call -> max_amount ) ; call -> max_amount = 0 ; pending = 1 ; } } else { LM_WARN ( "invalid call structure %p\n" , call ) ; } } credit_data -> deallocating = 0 ; if ( ! pending ) { __free_credit_data ( credit_data , hts , cd_entry ) ; } else { LM_DBG ( "credit data item left\n" ) ; cnxcc_unlock ( credit_data -> lock ) ; } } 