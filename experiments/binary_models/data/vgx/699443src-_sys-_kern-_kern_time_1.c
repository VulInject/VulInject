int sys_clock_getres ( struct proc * p , void * v , register_t * retval ) { struct sys_clock_getres_args * uap = v ; clockid_t clock_id ; struct bintime bt ; struct timespec ts ; struct proc * q ; u_int64_t scale ; int error = 0 ; clock_id = SCARG ( uap , clock_id ) ; switch ( clock_id ) { case CLOCK_REALTIME : case CLOCK_MONOTONIC : case CLOCK_BOOTTIME : case CLOCK_UPTIME : memset ( & bt , 0 , sizeof ( bt ) ) ; rw_enter_read ( & tc_lock ) ; scale = ( ( 1ULL << 63 ) / tc_getfrequency ( ) ) * 2 ; bt . frac = tc_getprecision ( ) * scale ; rw_exit_read ( & tc_lock ) ; BINTIME_TO_TIMESPEC ( & bt , & ts ) ; break ; case CLOCK_PROCESS_CPUTIME_ID : case CLOCK_THREAD_CPUTIME_ID : ts . tv_nsec = 1000000000 / stathz ; break ; default : if ( __CLOCK_TYPE ( clock_id ) == CLOCK_THREAD_CPUTIME_ID ) { KERNEL_LOCK ( ) ; q = tfind_user ( __CLOCK_PTID ( clock_id ) , p -> p_p ) ; if ( q == NULL ) { error = ESRCH ; } else { ts . tv_nsec = 1000000000 / stathz ; } KERNEL_UNLOCK ( ) ; } else { error = EINVAL ; } break ; } if ( error == 0 && SCARG ( uap , tp ) ) { ts . tv_nsec = MAX ( ts . tv_nsec , 1 ) ; error = copyout ( & ts , SCARG ( uap , tp ) , sizeof ( ts ) ) ; if ( error == 0 && KTRPOINT ( p , KTR_STRUCT ) ) { ktrreltimespec ( p , & ts ) ; } } return error ; } 