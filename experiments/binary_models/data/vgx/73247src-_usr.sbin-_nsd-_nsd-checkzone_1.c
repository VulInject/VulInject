static void check_zone ( struct nsd * nsd , const char * name , const char * fname , FILE * out , const char * oldzone , uint32_t ixfr_number , uint64_t ixfr_size ) { const dname_type * dname ; zone_options_type * zo ; zone_type * zone ; unsigned errors ; struct ixfr_create * ixfrcr = NULL ; nsd -> db = namedb_open ( "" , nsd -> options ) ; dname = dname_parse ( nsd -> options -> region , name ) ; if ( ! dname ) { error ( "cannot parse zone name '%s'" , name ) ; } zo = zone_options_create ( nsd -> options -> region ) ; zo -> node . key = dname ; zo -> name = name ; zone = namedb_zone_create ( nsd -> db , dname , zo ) ; if ( oldzone ) { errors = zonec_read ( name , oldzone , zone ) ; if ( errors > 0 ) { printf ( "zone %s file %s has %u errors\n" , name , oldzone , errors ) ; exit ( 1 ) ; } ixfrcr = ixfr_create_start ( zone , fname , ixfr_size , 1 ) ; if ( ! ixfrcr ) { error ( "out of memory" ) ; } delete_zone_rrs ( nsd -> db , zone ) ; } errors = zonec_read ( name , fname , zone ) ; if ( errors > 0 ) { printf ( "zone %s file %s has %u errors\n" , name , fname , errors ) ; ixfr_create_cancel ( ixfrcr ) ; namedb_close ( nsd -> db ) ; region_destroy ( nsd -> options -> region ) ; exit ( 1 ) ; } if ( ixfrcr ) { if ( ! ixfr_create_perform ( ixfrcr , zone , 0 , nsd , fname , ixfr_number ) ) { namedb_close ( nsd -> db ) ; region_destroy ( nsd -> options -> region ) ; ixfr_create_free ( ixfrcr ) ; error ( "could not create IXFR" ) ; } printf ( "zone %s created IXFR %s.ixfr\n" , name , fname ) ; ixfr_create_free ( ixfrcr ) ; } if ( out ) { print_rrs ( out , zone ) ; printf ( "; " ) ; } printf ( "zone %s is ok\n" , name ) ; namedb_close ( nsd -> db ) ; } 