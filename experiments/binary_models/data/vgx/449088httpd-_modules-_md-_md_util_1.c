static apr_status_t match_and_do ( md_util_fwalk_t * ctx , const char * path , int depth , apr_pool_t * p , apr_pool_t * ptemp ) { apr_status_t rv = APR_SUCCESS ; const char * pattern , * npath ; apr_dir_t * d ; apr_finfo_t finfo ; int ndepth = depth + 1 ; apr_int32_t wanted = ( APR_FINFO_TYPE ) ; if ( depth >= ctx -> patterns -> nelts ) { return APR_SUCCESS ; } pattern = APR_ARRAY_IDX ( ctx -> patterns , depth , const char * ) ; md_log_perror ( MD_LOG_MARK , MD_LOG_TRACE4 , 0 , ptemp , "match_and_do " "path=%s depth=%d pattern=%s" , path , depth , pattern ) ; rv = apr_dir_open ( & d , path , ptemp ) ; while ( APR_SUCCESS == ( rv = apr_dir_read ( & finfo , wanted , d ) ) ) { md_log_perror ( MD_LOG_MARK , MD_LOG_TRACE4 , 0 , ptemp , "match_and_do " "candidate=%s" , finfo . name ) ; if ( ! strcmp ( "." , finfo . name ) || ! strcmp ( ".." , finfo . name ) ) { continue ; } if ( APR_SUCCESS == apr_fnmatch ( pattern , finfo . name , 0 ) ) { md_log_perror ( MD_LOG_MARK , MD_LOG_TRACE4 , 0 , ptemp , "match_and_do " "candidate=%s matches pattern" , finfo . name ) ; if ( ndepth < ctx -> patterns -> nelts ) { md_log_perror ( MD_LOG_MARK , MD_LOG_TRACE4 , 0 , ptemp , "match_and_do " "need to go deeper" ) ; if ( APR_DIR == finfo . filetype ) { rv = md_util_path_merge ( & npath , ptemp , path , finfo . name , NULL ) ; if ( APR_SUCCESS == rv ) { rv = match_and_do ( ctx , npath , ndepth , p , ptemp ) ; } } } else { md_log_perror ( MD_LOG_MARK , MD_LOG_TRACE4 , 0 , ptemp , "match_and_do " "invoking inspector on name=%s" , finfo . name ) ; rv = ctx -> cb ( ctx -> baton , p , ptemp , path , finfo . name , finfo . filetype ) ; } } if ( APR_SUCCESS != rv ) { break ; } } if ( APR_STATUS_IS_ENOENT ( rv ) ) { rv = APR_SUCCESS ; } apr_dir_close ( d ) ; return rv ; } 