int netproc ( int kfd , int afd , int Cfd , int cfd , int dfd , int rfd , int revocate , struct authority_c * authority , const char * const * alts , size_t altsz ) { int rc = 0 ; size_t i ; char * cert = NULL , * thumb = NULL , * url = NULL , * error = NULL ; struct conn c ; struct capaths paths ; struct order order ; struct chng * chngs = NULL ; long lval ; memset ( & paths , 0 , sizeof ( capaths ) ) ; memset ( & c , 0 , sizeof ( conn ) ) ; if ( unveil ( tls_default_ca_cert_file ( ) , "r" ) == - 1 ) { warn ( "unveil %s" , tls_default_ca_cert_file ( ) ) ; out } if ( pledge ( "stdio inet rpath" , NULL ) == - 1 ) { warn ( "pledge" ) ; out } if ( http_init ( ) == - 1 ) { warn ( "http_init" ) ; out } if ( pledge ( "stdio inet" , NULL ) == - 1 ) { warn ( "pledge" ) ; out } if ( ( lval = readop ( afd , COMM_ACCT_STAT ) ) == 0 ) { rc = 1 ; out } if ( lval != ACCT_READY ) { warnx ( "unknown operation from acctproc" ) ; out } if ( ( lval = readop ( kfd , COMM_KEY_STAT ) ) == 0 ) { rc = 1 ; out } if ( lval != KEY_READY ) { warnx ( "unknown operation from keyproc" ) ; out } if ( ( lval = readop ( rfd , COMM_REVOKE_RESP ) ) == 0 ) { rc = 1 ; out } if ( lval != REVOKE_EXP && lval != REVOKE_OK ) { warnx ( "unknown operation from revokeproc" ) ; out } if ( lval == REVOKE_OK ) { rc = 1 ; out } c . dfd = dfd ; c . fd = afd ; if ( ! dodirs ( & c , authority -> api , & paths ) ) { out } c . newnonce = paths . newnonce ; if ( ! dochkacc ( & c , & paths , authority -> contact ) ) { out } if ( revocate ) { if ( ( cert = readstr ( rfd , COMM_CSR ) ) == NULL ) { out } if ( ! dorevoke ( & c , paths . revokecert , cert ) ) { out } if ( writeop ( cfd , COMM_CSR_OP , CERT_REVOKE ) > 0 ) { rc = 1 ; } out } if ( ! doneworder ( & c , alts , altsz , & order , & paths ) ) { out } chngs = calloc ( order . authsz , sizeof ( chng ) ) ; if ( chngs == NULL ) { warn ( "calloc" ) ; out } if ( writeop ( afd , COMM_ACCT , ACCT_THUMBPRINT ) <= 0 ) { out } if ( ( thumb = readstr ( afd , COMM_THUMB ) ) == NULL ) { out } while ( order . status != ORDER_VALID && order . status != ORDER_INVALID ) { switch ( order . status ) { case ORDER_INVALID : warnx ( "order invalid" ) ; out case ORDER_VALID : rc = 1 ; continue ; case ORDER_PENDING : if ( order . authsz < 1 ) { warnx ( "order is in state pending but no " "authorizations know" ) ; out } for ( i = 0 ; i < order . authsz ; i ++ ) { if ( ! dochngreq ( & c , order . auths [ i ] , & chngs [ i ] ) ) { out } dodbg ( "challenge, token: %s, uri: %s, status: " "%d" , chngs [ i ] . token , chngs [ i ] . uri , chngs [ i ] . status ) ; if ( chngs [ i ] . status == CHNG_VALID || chngs [ i ] . status == CHNG_INVALID ) { continue ; } if ( chngs [ i ] . retry ++ >= RETRY_MAX ) { warnx ( "%s: too many tries" , chngs [ i ] . uri ) ; out } if ( writeop ( Cfd , COMM_CHNG_OP , CHNG_SYN ) <= 0 ) { out } if ( writestr ( Cfd , COMM_THUMB , thumb ) <= 0 ) { out } if ( writestr ( Cfd , COMM_TOK , chngs [ i ] . token ) <= 0 ) { out } if ( readop ( Cfd , COMM_CHNG_ACK ) != CHNG_ACK ) { out } } for ( i = 0 ; i < order . authsz ; i ++ ) { if ( chngs [ i ] . status == CHNG_VALID || chngs [ i ] . status == CHNG_INVALID ) { continue ; } if ( ! dochngresp ( & c , & chngs [ i ] ) ) { out } } break ; case ORDER_READY : if ( writeop ( Cfd , COMM_CHNG_OP , CHNG_STOP ) <= 0 ) { out } if ( ( cert = readstr ( kfd , COMM_CERT ) ) == NULL ) { out } if ( ! docert ( & c , order . finalize , cert ) ) { out } break ; default : warnx ( "unhandled status: %d" , order . status ) ; out } if ( ! doupdorder ( & c , & order ) ) { out } dodbg ( "order.status %d" , order . status ) ; if ( order . status == ORDER_PENDING ) { sleep ( RETRY_DELAY ) ; } } if ( order . status != ORDER_VALID ) { for ( i = 0 ; i < order . authsz ; i ++ ) { dochngreq ( & c , order . auths [ i ] , & chngs [ i ] ) ; if ( chngs [ i ] . error != NULL ) { if ( stravis ( & error , chngs [ i ] . error , VIS_SAFE ) != - 1 ) { warnx ( "%s" , error ) ; free ( error ) ; error = NULL ; } } } out } if ( order . certificate == NULL ) { warnx ( "no certificate url received" ) ; out } if ( ! dogetcert ( & c , order . certificate ) ) { out } if ( writeop ( cfd , COMM_CSR_OP , CERT_UPDATE ) <= 0 ) { out } if ( writebuf ( cfd , COMM_CSR , c . buf . buf , c . buf . sz ) <= 0 ) { out } rc = 1 ; out close ( cfd ) ; close ( kfd ) ; close ( afd ) ; close ( Cfd ) ; close ( dfd ) ; close ( rfd ) ; free ( cert ) ; free ( url ) ; free ( thumb ) ; free ( c . kid ) ; free ( c . buf . buf ) ; if ( chngs != NULL ) { for ( i = 0 ; i < order . authsz ; i ++ ) { json_free_challenge ( & chngs [ i ] ) ; } } free ( chngs ) ; json_free_capaths ( & paths ) ; return rc ; } 