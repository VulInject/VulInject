bool dc_link_decide_edp_link_settings ( struct dc_link * link , struct dc_link_settings * link_setting , uint32_t req_bw ) { struct dc_link_settings initial_link_setting ; struct dc_link_settings current_link_setting ; uint32_t link_bw ; if ( link -> dpcd_caps . dpcd_rev . raw < DPCD_REV_13 || link -> dpcd_caps . edp_supported_link_rates_count == 0 ) { * link_setting = link -> verified_link_cap ; return true ; } initial_link_setting . lane_count = LANE_COUNT_ONE ; initial_link_setting . link_rate = link -> dpcd_caps . edp_supported_link_rates [ 0 ] ; initial_link_setting . link_spread = LINK_SPREAD_DISABLED ; initial_link_setting . use_link_rate_set = true ; initial_link_setting . link_rate_set = 0 ; current_link_setting = initial_link_setting ; while ( current_link_setting . link_rate <= link -> verified_link_cap . link_rate ) { link_bw = dc_link_bandwidth_kbps ( link , & current_link_setting ) ; if ( req_bw <= link_bw ) { * link_setting = current_link_setting ; return true ; } if ( current_link_setting . lane_count < link -> verified_link_cap . lane_count ) { current_link_setting . lane_count = increase_lane_count ( current_link_setting . lane_count ) ; } else { if ( current_link_setting . link_rate_set < link -> dpcd_caps . edp_supported_link_rates_count ) { current_link_setting . link_rate_set ++ ; current_link_setting . link_rate = link -> dpcd_caps . edp_supported_link_rates [ current_link_setting . link_rate_set ] ; current_link_setting . lane_count = initial_link_setting . lane_count ; } else { break ; } } } return false ; } 