static int qce_skcipher_register_one ( const struct qce_skcipher_def * def , struct qce_device * qce ) { struct qce_alg_template * tmpl ; struct skcipher_alg * alg ; int ret ; tmpl = kzalloc ( sizeof ( * tmpl ) , GFP_KERNEL ) ; if ( ! tmpl ) { return - ENOMEM ; } alg = & tmpl -> alg . skcipher ; snprintf ( alg -> base . cra_name , CRYPTO_MAX_ALG_NAME , "%s" , def -> name ) ; snprintf ( alg -> base . cra_driver_name , CRYPTO_MAX_ALG_NAME , "%s" , def -> drv_name ) ; alg -> base . cra_blocksize = def -> blocksize ; alg -> chunksize = def -> chunksize ; alg -> ivsize = def -> ivsize ; alg -> min_keysize = def -> min_keysize ; alg -> max_keysize = def -> max_keysize ; alg -> setkey = IS_3DES ( def -> flags ) ?qce_des3_setkey : IS_DES ( def -> flags ) ?qce_des_setkey : qce_skcipher_setkey ; alg -> encrypt = qce_skcipher_encrypt ; alg -> decrypt = qce_skcipher_decrypt ; alg -> base . cra_priority = 300 ; alg -> base . cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY | CRYPTO_ALG_KERN_DRIVER_ONLY ; alg -> base . cra_ctxsize = sizeof ( qce_cipher_ctx ) ; alg -> base . cra_alignmask = 0 ; alg -> base . cra_module = THIS_MODULE ; if ( IS_AES ( def -> flags ) ) { alg -> base . cra_flags |= CRYPTO_ALG_NEED_FALLBACK ; alg -> init = qce_skcipher_init_fallback ; alg -> exit = qce_skcipher_exit ; } else { alg -> init = qce_skcipher_init ; } INIT_LIST_HEAD ( & tmpl -> entry ) ; tmpl -> crypto_alg_type = CRYPTO_ALG_TYPE_SKCIPHER ; tmpl -> alg_flags = def -> flags ; tmpl -> qce = qce ; ret = crypto_register_skcipher ( alg ) ; if ( ret ) { dev_err ( qce -> dev , "%s registration failed\n" , alg -> base . cra_name ) ; return ret ; } list_add_tail ( & tmpl -> entry , & skcipher_algs ) ; dev_dbg ( qce -> dev , "%s is registered\n" , alg -> base . cra_name ) ; return 0 ; } 