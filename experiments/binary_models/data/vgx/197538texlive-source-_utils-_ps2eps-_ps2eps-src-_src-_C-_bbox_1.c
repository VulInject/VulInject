void readppm_and_calcbb ( const char * name , const unsigned int resolution , const unsigned char tight ) { FILE * inputfile ; char inputline [ inputlinelength ] ; unsigned char magic_found = 0 ; int x , y , byte_x , i ; const double pt_dpi_dbl = 72.0 ; unsigned int x_min , x_max , y_min , y_max ; unsigned int llx , lly , urx , ury ; double hllx , hlly , hurx , hury ; unsigned char * image_row , * tmpcolumnbytep ; unsigned int width , height ; unsigned int byte_width ; unsigned char colormax = 0 ; unsigned int ui_colormax = 0 ; if ( name == NULL ) { inputfile = stdin ; name = "- STDIN -" ; } else { inputfile = fopen ( name , "r" ) ; if ( inputfile == NULL ) { fprintf ( stderr , "%s: ERROR -- could not open file %s\n" , prgname , name ) ; exit ( 1 ) ; } } { if ( fgets ( inputline , inputlinelength , inputfile ) == NULL ) { fprintf ( stderr , "%s: ERROR -- unexpected end of file %s\n" , prgname , name ) ; fclose ( inputfile , NULL ) ; exit ( 1 ) ; } fprintf ( stderr , "read:[%s]\n" , inputline ) ; if ( strcmp ( inputline , "P4\n" ) == 0 ) { magic_found = 4 ; } if ( strcmp ( inputline , "P6\n" ) == 0 ) { magic_found = 6 ; } } ! feof ( inputfile ) && ! magic_found ; if ( ! magic_found ) { fprintf ( stderr , "%s: ERROR -- %s is not in ppmraw or pbmraw format\n" , prgname , name ) ; fclose ( inputfile ) ; exit ( 1 ) ; } { if ( fgets ( inputline , inputlinelength , inputfile ) == NULL ) { fprintf ( stderr , "%s: ERROR -- unexpected end of file %s\n" , prgname , name ) ; fclose ( inputfile ) ; exit ( 1 ) ; } fprintf ( stderr , "read:[%s]\n" , inputline ) ; if ( * inputline == '#' ) { continue ; } else { break ; } } ! feof ( inputfile ) ; sscanf ( inputline , "%u %u" , & width , & height ) ; if ( magic_found == 6 ) { if ( fgets ( inputline , inputlinelength , inputfile ) == NULL ) { fprintf ( stderr , "%s: ERROR -- unexpected end of file %s\n" , prgname , name ) ; fclose ( inputfile ) ; exit ( 1 ) ; } sscanf ( inputline , "%u" , & ui_colormax ) ; colormax = ( unsigned char ) ui_colormax ; } fprintf ( stderr , "\nreading picture: %s size X: %u Y: %u\n" , name , width , height ) ; x = 0 ; x_min = width > 0 ?width - 1 : 0 ; x_max = 0 ; y_min = height > 0 ?height - 1 : 0 ; y_max = 0 ; if ( magic_found == 4 ) { byte_width = width / 8 ; if ( width % 8 != 0 ) { byte_width ++ ; } } else { byte_width = width * 3 ; } image_row = malloc ( byte_width ) ; if ( image_row ) { i = _setmode ( _fileno ( stdin ) , _O_BINARY ) ; if ( i == - 1 ) { fprintf ( stderr , "%s: ERROR - Cannot set binary mode for STDIN\n" , prgname ) ; } i = _setmode ( _fileno ( stdout ) , _O_BINARY ) ; if ( i == - 1 ) { fprintf ( stderr , "%s: ERROR - Cannot set binary mode for STDOUT\n" , prgname ) ; } for ( y = 0 ; y < height ; y ++ ) { if ( fread ( image_row , byte_width , 1 , inputfile ) != 1 ) { fprintf ( stderr , "%s: WARNING -- fread incomplete - file %s seems to be corrupt\n" , prgname , name ) ; break ; } tmpcolumnbytep = image_row ; for ( byte_x = 0 ; byte_x < byte_width ; byte_x ++ , tmpcolumnbytep ++ ) { if ( * tmpcolumnbytep != colormax ) { if ( magic_found == 4 ) { for ( i = 0 ; i < 8 ; i ++ ) { if ( * tmpcolumnbytep & bitval [ i ] ) { x = byte_x * 8 + i ; if ( x >= width ) { break ; } printf ( "(row %04d, %04d):<not white>\n" , y , x ) ; } } } else { x = byte_x / 3 ; printf ( "(row %04d, col %04d) byte %04d:<not %d>\n" , y , x , byte_x , colormax ) ; } if ( x < x_min ) { x_min = x ; } if ( x > x_max ) { x_max = x ; } if ( y < y_min ) { y_min = y ; } if ( y > y_max ) { y_max = y ; } printf ( "ymin,height:(%04d,%04d) xmin,width:(%04d,%04d)\n" , y_min , y_max , x_min , x_max ) ; break ; } } if ( byte_x != byte_width ) { tmpcolumnbytep = image_row + byte_width - 1 ; for ( byte_x = byte_width - 1 ; byte_x >= 0 ; byte_x -- , tmpcolumnbytep -- ) { if ( * tmpcolumnbytep != colormax ) { if ( magic_found == 4 ) { for ( i = 0 ; i < 8 ; i ++ ) { if ( * tmpcolumnbytep & bitval [ i ] ) { x = byte_x * 8 + i ; if ( x >= width ) { break ; } printf ( "(%04d,%04d):<not white>\n" , y , x ) ; } } } else { x = byte_x / 3 ; } if ( x < x_min ) { x_min = x ; } if ( x > x_max ) { x_max = x ; } if ( y < y_min ) { y_min = y ; } if ( y > y_max ) { y_max = y ; } printf ( "ymin,height:(%04d,%04d) xmin,width:(%04d,%04d)\n" , y_min , y_max , x_min , x_max ) ; break ; } } } } fprintf ( stderr , "(%04d,%04d), (%04d,%04d)\n" , x_min , height - y_max , x_max , height - y_min ) ; hllx = ( x_min * pt_dpi_dbl ) / resolution ; hlly = ( ( minus_one ( height ) - y_max ) * pt_dpi_dbl ) / resolution ; hurx = ( plus_one ( x_max ) * pt_dpi_dbl ) / resolution ; hury = ( ( height - y_min ) * pt_dpi_dbl ) / resolution ; if ( ! tight ) { llx = minus_one ( ( unsigned int ) ( ( unsigned long ) x_min * 72UL ) / resolution ) ; lly = minus_one ( ( unsigned int ) ( ( unsigned long ) ( minus_one ( height ) - y_max ) * 72UL ) / resolution ) ; urx = plus_one ( ( unsigned int ) ( ( unsigned long ) plus_one ( x_max ) * 72UL ) / resolution ) ; ury = plus_one ( ( unsigned int ) ( ( unsigned long ) ( height - y_min ) * 72UL ) / resolution ) ; if ( hllx - round_precision >= 0.0 ) { hllx -= round_precision ; } if ( hlly - round_precision >= 0.0 ) { hlly -= round_precision ; } hurx += round_precision ; hury += round_precision ; } else { llx = ( unsigned int ) ( ( unsigned long ) x_min * 72UL ) / resolution ; lly = ( unsigned int ) ( ( unsigned long ) ( minus_one ( height ) - y_max ) * 72UL ) / resolution ; urx = ( unsigned int ) ( ( unsigned long ) plus_one ( x_max ) * 72UL ) / resolution ; if ( ( ( ( unsigned long ) plus_one ( x_max ) * 72UL ) % resolution ) != 0 ) { urx = plus_one ( urx ) ; } ury = ( unsigned int ) ( ( unsigned long ) ( height - y_min ) * 72UL ) / resolution ; if ( ( ( ( unsigned long ) ( height - y_min ) * 72UL ) % resolution ) != 0 ) { ury = plus_one ( ury ) ; } } while ( ! feof ( inputfile ) ) { fgets ( inputline , inputlinelength , inputfile ) ; } printf ( "%%%%BoundingBox: %d %d %d %d\n" , llx , lly , urx , ury ) ; printf ( "%%%%HiResBoundingBox: %f %f %f %f\n" , hllx , hlly , hurx , hury ) ; } else { fprintf ( stderr , "%s: ERROR -- not enough memory to read in one row of the picture\n" , prgname ) ; } fclose ( inputfile ) ; free ( image_row ) ; } 