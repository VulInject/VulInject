static int __live_active_context ( struct intel_engine_cs * engine ) { unsigned long saved_heartbeat ; struct intel_context * ce ; int pass ; int err ; if ( intel_engine_uses_guc ( engine ) ) { return 0 ; } if ( intel_engine_pm_is_awake ( engine ) ) { pr_err ( "%s is awake before starting %s!\n" , engine -> name , __func__ ) ; return - EINVAL ; } ce = intel_context_create ( engine ) ; if ( IS_ERR ( ce ) ) { return PTR_ERR ( ce ) ; } saved_heartbeat = engine -> props . heartbeat_interval_ms ; engine -> props . heartbeat_interval_ms = 0 ; for ( pass = 0 ; pass <= 2 ; pass ++ ) { struct i915_request * rq ; intel_engine_pm_get ( engine , NULL ) ; rq = intel_context_create_request ( ce ) ; if ( IS_ERR ( rq ) ) { err = PTR_ERR ( rq ) ; out_engine } err = request_sync ( rq ) ; if ( err ) { out_engine } if ( i915_active_is_idle ( & ce -> active ) ) { pr_err ( "context is not active; expected idle-barrier (%s pass %d)\n" , engine -> name , pass ) ; err = - EINVAL ; out_engine } if ( ! intel_engine_pm_is_awake ( engine ) ) { pr_err ( "%s is asleep before idle-barrier\n" , engine -> name ) ; err = - EINVAL ; out_engine } out_engine intel_engine_pm_put ( engine ) ; if ( err ) { err } } err = intel_engine_flush_barriers ( engine ) ; if ( err ) { err } err = context_sync ( engine -> kernel_context ) ; if ( err ) { err } if ( ! i915_active_is_idle ( & ce -> active ) ) { pr_err ( "context is still active!" ) ; err = - EINVAL ; } intel_engine_pm_flush ( engine ) ; if ( intel_engine_pm_is_awake ( engine ) ) { struct drm_printer p = drm_debug_printer ( __func__ ) ; intel_engine_dump ( engine , & p , "%s is still awake:%d after idle-barriers\n" , engine -> name , atomic_read ( & engine -> wakeref . count ) ) ; GEM_TRACE_DUMP ( ) ; err = - EINVAL ; err } err engine -> props . heartbeat_interval_ms = saved_heartbeat ; intel_context_put ( ce ) ; return err ; } 