int scf_tmpl_iter_props ( scf_pg_tmpl_t * t , scf_prop_tmpl_t * pt , int flags ) { scf_prop_tmpl_t * prop_tmpl ; char * pg_pat ; char * pg_name = NULL ; int err ; int ret ; ssize_t size = scf_limit ( SCF_LIMIT_MAX_NAME_LENGTH ) + 1 ; uint8_t required ; scf_handle_t * h ; scf_propertygroup_t * pg = NULL ; scf_iter_t * iter = NULL ; assert ( size != 0 ) ; if ( t == NULL || pt == NULL ) { ( void ) scf_set_error ( SCF_ERROR_INVALID_ARGUMENT ) ; return ( - 1 ) ; } assert ( t -> pt_inst == NULL || t -> pt_svc == NULL ) ; assert ( t -> pt_inst != NULL || t -> pt_svc != NULL ) ; if ( ( pg_name = malloc ( size ) ) == NULL ) { ( void ) scf_set_error ( SCF_ERROR_NO_MEMORY ) ; return ( - 1 ) ; } if ( pt -> prt_populated == 0 ) { if ( ( h = scf_pg_handle ( t -> pt_pg ) ) == NULL ) { fail_non_populated } if ( ( pg = scf_pg_create ( h ) ) == NULL || ( iter = scf_iter_create ( h ) ) == NULL ) { fail_non_populated } if ( t -> pt_inst != NULL ) { err = scf_iter_instance_pgs_typed_composed ( iter , t -> pt_inst , t -> pt_snap , SCF_GROUP_TEMPLATE_PROP_PATTERN ) ; } if ( t -> pt_svc != NULL ) { err = scf_iter_service_pgs_typed ( iter , t -> pt_svc , SCF_GROUP_TEMPLATE_PROP_PATTERN ) ; } if ( err != 0 ) { if ( ismember ( scf_error ( ) , errors_server ) ) { fail_non_populated } else { switch ( scf_error ( ) ) { case SCF_ERROR_INVALID_ARGUMENT : fail_non_populated case SCF_ERROR_NOT_SET : case SCF_ERROR_HANDLE_MISMATCH : default : assert ( 0 ) ; abort ( ) ; } } } prop_tmpl = pt ; prop_tmpl -> prt_t = t ; prop_tmpl -> prt_populated = 1 ; prop_tmpl -> prt_pg = pg ; prop_tmpl -> prt_iter = iter ; } else { prop_tmpl = pt ; } while ( ( err = scf_iter_next_pg ( prop_tmpl -> prt_iter , prop_tmpl -> prt_pg ) ) > 0 ) { pg_pat = _scf_read_single_astring_from_pg ( prop_tmpl -> prt_pg , SCF_PROPERTY_TM_PG_PATTERN ) ; if ( pg_pat == NULL ) { if ( ismember ( scf_error ( ) , errors_server ) ) { return ( - 1 ) ; } else { switch ( scf_error ( ) ) { case SCF_ERROR_NOT_FOUND : continue ; case SCF_ERROR_CONSTRAINT_VIOLATED : case SCF_ERROR_TYPE_MISMATCH : ( void ) scf_set_error ( SCF_ERROR_TEMPLATE_INVALID ) ; free ( pg_name ) ; return ( - 1 ) ; case SCF_ERROR_INVALID_ARGUMENT : case SCF_ERROR_NOT_SET : default : assert ( 0 ) ; abort ( ) ; } } } if ( ( ret = scf_pg_get_name ( t -> pt_pg , pg_name , size ) ) <= 0 ) { free ( pg_pat ) ; if ( ret == 0 ) { continue ; } if ( ismember ( scf_error ( ) , errors_server ) ) { free ( pg_name ) ; return ( - 1 ) ; } else { assert ( 0 ) ; abort ( ) ; } } if ( strcmp ( pg_pat , pg_name ) != 0 ) { free ( pg_pat ) ; continue ; } free ( pg_pat ) ; if ( flags & SCF_PROP_TMPL_FLAG_REQUIRED ) { if ( scf_tmpl_prop_required ( prop_tmpl , & required ) == 0 ) { if ( required == 0 ) { continue ; } } else { free ( pg_name ) ; return ( - 1 ) ; } } free ( pg_name ) ; return ( 0 ) ; } if ( err == - 1 ) { if ( ismember ( scf_error ( ) , errors_server ) ) { free ( pg_name ) ; return ( - 1 ) ; } else { assert ( 0 ) ; abort ( ) ; } } if ( err == 0 ) { scf_iter_destroy ( prop_tmpl -> prt_iter ) ; prop_tmpl -> prt_iter = NULL ; prop_tmpl -> prt_populated = 0 ; } free ( pg_name ) ; return ( 1 ) ; fail_non_populated free ( pg_name ) ; scf_pg_destroy ( pg ) ; scf_iter_destroy ( iter ) ; return ( - 1 ) ; } 