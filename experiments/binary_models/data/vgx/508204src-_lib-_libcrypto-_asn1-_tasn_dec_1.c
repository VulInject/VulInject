static int asn1_item_d2i_choice ( ASN1_VALUE * * pval , CBS * cbs , const ASN1_ITEM * it , int tag_number , int tag_class , int optional , int depth ) { const ASN1_TEMPLATE * at , * errat = NULL ; const ASN1_AUX * aux ; ASN1_aux_cb * asn1_cb = NULL ; ASN1_VALUE * achoice = NULL ; ASN1_VALUE * * pchptr ; int i , ret ; if ( ( aux = it -> funcs ) != NULL ) { asn1_cb = aux -> asn1_cb ; } if ( it -> itype != ASN1_ITYPE_CHOICE ) { err } if ( tag_number != - 1 ) { ASN1error ( ASN1_R_BAD_TEMPLATE ) ; err } if ( * pval != NULL ) { ASN1_item_ex_free ( pval , it ) ; * pval = NULL ; } if ( ! ASN1_item_ex_new ( & achoice , it ) ) { ASN1error ( ERR_R_NESTED_ASN1_ERROR ) ; err } if ( asn1_cb != NULL && ! asn1_cb ( ASN1_OP_D2I_PRE , & achoice , it , NULL ) ) { ASN1error ( ASN1_R_AUX_ERROR ) ; err } for ( i = 0 ; i < it -> tcount ; i ++ ) { at = & it -> templates [ i ] ; pchptr = asn1_get_field_ptr ( & achoice , at ) ; ret = asn1_template_d2i ( pchptr , cbs , at , 1 , depth ) ; if ( ret == - 1 ) { continue ; } if ( ret != 1 ) { ASN1error ( ERR_R_NESTED_ASN1_ERROR ) ; errat = at ; err } asn1_set_choice_selector ( & achoice , i , it ) ; break ; } if ( i == it -> tcount ) { if ( optional ) { ASN1_item_ex_free ( & achoice , it ) ; return - 1 ; } ASN1error ( ASN1_R_NO_MATCHING_CHOICE_TYPE , NULL ) ; err } if ( asn1_cb != NULL && ! asn1_cb ( ASN1_OP_D2I_POST , & achoice , it , NULL ) ) { ASN1error ( ASN1_R_AUX_ERROR ) ; err } * pval = achoice ; achoice = NULL ; return 1 ; err ASN1_item_ex_free ( & achoice , it ) ; if ( errat != NULL ) { ERR_asprintf_error_data ( "Field=%s, Type=%s" , errat -> field_name , it -> sname ) ; } else { ERR_asprintf_error_data ( "Type=%s" , it -> sname ) ; } return 0 ; } 