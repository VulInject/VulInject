static int set_kdebugflag ( int level ) static int ppp_registered ( void ) static int make_ppp_unit ( void ) static int setifstate ( int u , int state ) extern u_char inpacket_buf [ ] ; extern int dfl_route_metric ; memset ( ( char * ) & ( addr ) , '\0' , sizeof ( addr ) ) ; addr . sa_family = ( family ) ; static int rtnetlink_msg ( const char * desc , int * shared_fd , void * nlreq , size_t nlreq_len , void * nlresp_data , size_t * nlresp_size , unsigned nlresp_type ) { nlresp_hdr { struct nlmsghdr nlh ; struct nlmsgerr nlerr ; } , nlresp_hdr struct sockaddr_nl nladdr ; struct iovec iov [ 2 ] ; struct msghdr msg ; ssize_t nlresp_len ; int one ; int fd ; if ( shared_fd && * shared_fd >= 0 ) { fd = * shared_fd ; } else { fd = socket ( AF_NETLINK , SOCK_RAW , NETLINK_ROUTE ) ; if ( fd < 0 ) { error ( "rtnetlink_msg: socket(NETLINK_ROUTE): %m (line %d)" , __LINE__ ) ; return 1 ; } one = 1 ; setsockopt ( fd , SOL_NETLINK , NETLINK_CAP_ACK , & one , sizeof ( one ) ) ; memset ( & nladdr , 0 , sizeof ( nladdr ) ) ; nladdr . nl_family = AF_NETLINK ; if ( bind ( fd , ( sockaddr * ) & nladdr , sizeof ( nladdr ) ) < 0 ) { error ( "rtnetlink_msg: bind(AF_NETLINK): %m (line %d)" , __LINE__ ) ; close ( fd ) ; return 1 ; } if ( shared_fd ) { * shared_fd = fd ; } } memset ( & nladdr , 0 , sizeof ( nladdr ) ) ; nladdr . nl_family = AF_NETLINK ; iov [ 0 ] . iov_base = nlreq ; iov [ 0 ] . iov_len = nlreq_len ; memset ( & msg , 0 , sizeof ( msg ) ) ; msg . msg_name = & nladdr ; msg . msg_namelen = sizeof ( nladdr ) ; msg . msg_iov = & iov [ 0 ] ; msg . msg_iovlen = 1 ; if ( sendmsg ( fd , & msg , 0 ) < 0 ) { error ( "rtnetlink_msg: sendmsg(%s): %m (line %d)" , desc , __LINE__ ) ; if ( ! shared_fd ) { close ( fd ) ; } return 1 ; } memset ( iov , 0 , sizeof ( iov ) ) ; iov [ 0 ] . iov_base = & nlresp_hdr ; if ( nlresp_size && * nlresp_size > sizeof ( nlresp_hdr ) ) { iov [ 0 ] . iov_len = offsetof ( nlresp_hdr , nlerr ) ; iov [ 1 ] . iov_base = nlresp_data ; iov [ 1 ] . iov_len = * nlresp_size ; } else { iov [ 0 ] . iov_len = sizeof ( nlresp_hdr ) ; } memset ( & msg , 0 , sizeof ( msg ) ) ; msg . msg_name = & nladdr ; msg . msg_namelen = sizeof ( nladdr ) ; msg . msg_iov = iov ; msg . msg_iovlen = ( nlresp_size && * nlresp_size > sizeof ( nlresp_hdr ) ) ?2 : 1 ; nlresp_len = recvmsg ( fd , & msg , 0 ) ; if ( ! shared_fd ) { close ( fd ) ; } if ( nlresp_len < 0 ) { error ( "rtnetlink_msg: recvmsg(%s): %m (line %d)" , desc , __LINE__ ) ; return 1 ; } if ( nladdr . nl_family != AF_NETLINK ) { error ( "rtnetlink_msg: recvmsg(%s): Not a netlink packet (line %d)" , desc , __LINE__ ) ; return 1 ; } if ( ! nlresp_size ) { if ( ( size_t ) nlresp_len < sizeof ( nlresp_hdr ) || nlresp_hdr . nlh . nlmsg_len < sizeof ( nlresp_hdr ) ) { error ( "rtnetlink_msg: recvmsg(%s): Acknowledgment netlink packet too short (line %d)" , desc , __LINE__ ) ; return 1 ; } if ( nlresp_hdr . nlh . nlmsg_type != NLMSG_ERROR ) { error ( "rtnetlink_msg: recvmsg(%s): Not an acknowledgment netlink packet (line %d)" , desc , __LINE__ ) ; return 1 ; } } if ( nlresp_size ) { if ( * nlresp_size > sizeof ( nlresp_hdr ) ) { memcpy ( ( unsigned char * ) & nlresp_hdr + offsetof ( nlresp_hdr , nlerr ) , nlresp_data , sizeof ( nlresp_hdr . nlerr ) ) ; } else { memcpy ( nlresp_data , ( unsigned char * ) & nlresp_hdr + offsetof ( nlresp_hdr , nlerr ) , * nlresp_size ) ; } } if ( nlresp_hdr . nlh . nlmsg_type == NLMSG_ERROR && nlresp_hdr . nlerr . error ) { return nlresp_hdr . nlerr . error ; } if ( nlresp_size ) { if ( nlresp_hdr . nlh . nlmsg_type != nlresp_type ) { error ( "rtnetlink_msg: recvmsg(%s): Not a netlink packet of type 0x%x (line %d)" , desc , nlresp_type , __LINE__ ) ; return 1 ; } * nlresp_size = nlresp_len - offsetof ( nlresp_hdr , nlerr ) ; } return 0 ; } 