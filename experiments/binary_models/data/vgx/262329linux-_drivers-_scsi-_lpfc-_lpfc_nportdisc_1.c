static int lpfc_rcv_plogi ( struct lpfc_vport * vport , struct lpfc_nodelist * ndlp , struct lpfc_iocbq * cmdiocb ) { struct lpfc_hba * phba = vport -> phba ; struct lpfc_dmabuf * pcmd ; uint64_t nlp_portwwn = 0 ; uint32_t * lp ; union lpfc_wqe128 * wqe ; IOCB_t * icmd ; struct serv_parm * sp ; uint32_t ed_tov ; LPFC_MBOXQ_t * link_mbox ; LPFC_MBOXQ_t * login_mbox ; struct lpfc_iocbq * save_iocb ; struct ls_rjt stat ; uint32_t vid , flag ; int rc ; u32 remote_did ; pcmd = cmdiocb -> cmd_dmabuf ; lp = ( uint32_t * ) pcmd -> virt ; sp = ( serv_parm * ) ( ( uint8_t * ) lp + sizeof ( uint32_t ) ) ; if ( wwn_to_u64 ( sp -> portName . u . wwn ) == 0 ) { lpfc_printf_vlog ( vport , KERN_ERR , LOG_TRACE_EVENT , "0140 PLOGI Reject: invalid pname\n" ) ; stat . un . b . lsRjtRsnCode = LSRJT_UNABLE_TPC ; stat . un . b . lsRjtRsnCodeExp = LSEXP_INVALID_PNAME ; lpfc_els_rsp_reject ( vport , stat . un . lsRjtError , cmdiocb , ndlp , NULL ) ; return 0 ; } if ( wwn_to_u64 ( sp -> nodeName . u . wwn ) == 0 ) { lpfc_printf_vlog ( vport , KERN_ERR , LOG_TRACE_EVENT , "0141 PLOGI Reject: invalid nname\n" ) ; stat . un . b . lsRjtRsnCode = LSRJT_UNABLE_TPC ; stat . un . b . lsRjtRsnCodeExp = LSEXP_INVALID_NNAME ; lpfc_els_rsp_reject ( vport , stat . un . lsRjtError , cmdiocb , ndlp , NULL ) ; return 0 ; } nlp_portwwn = wwn_to_u64 ( ndlp -> nlp_portname . u . wwn ) ; if ( ( lpfc_check_sparm ( vport , ndlp , sp , CLASS3 , 0 ) == 0 ) ) { stat . un . b . lsRjtRsnCode = LSRJT_UNABLE_TPC ; stat . un . b . lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS ; lpfc_els_rsp_reject ( vport , stat . un . lsRjtError , cmdiocb , ndlp , NULL ) ; return 0 ; } if ( phba -> sli_rev == LPFC_SLI_REV4 ) { wqe = & cmdiocb -> wqe ; } else { icmd = & cmdiocb -> iocb ; } lpfc_printf_vlog ( vport , KERN_INFO , LOG_ELS , "0114 PLOGI chkparm OK Data: x%x x%x x%x " "x%x x%x x%x\n" , ndlp -> nlp_DID , ndlp -> nlp_state , ndlp -> nlp_flag , ndlp -> nlp_rpi , vport -> port_state , vport -> fc_flag ) ; if ( vport -> cfg_fcp_class == 2 && sp -> cls2 . classValid ) { ndlp -> nlp_fcp_info |= CLASS2 ; } else { ndlp -> nlp_fcp_info |= CLASS3 ; } ndlp -> nlp_class_sup = 0 ; if ( sp -> cls1 . classValid ) { ndlp -> nlp_class_sup |= FC_COS_CLASS1 ; } if ( sp -> cls2 . classValid ) { ndlp -> nlp_class_sup |= FC_COS_CLASS2 ; } if ( sp -> cls3 . classValid ) { ndlp -> nlp_class_sup |= FC_COS_CLASS3 ; } if ( sp -> cls4 . classValid ) { ndlp -> nlp_class_sup |= FC_COS_CLASS4 ; } ndlp -> nlp_maxframe = ( ( sp -> cmn . bbRcvSizeMsb & 0x0F ) << 8 ) | sp -> cmn . bbRcvSizeLsb ; switch ( ndlp -> nlp_state ) { case NLP_STE_NPR_NODE : if ( ! ( ndlp -> nlp_flag & NLP_NPR_ADISC ) ) { break ; } fallthrough ; case NLP_STE_REG_LOGIN_ISSUE : case NLP_STE_PRLI_ISSUE : case NLP_STE_UNMAPPED_NODE : case NLP_STE_MAPPED_NODE : if ( ! ( ndlp -> nlp_type & NLP_FABRIC ) && ! ( phba -> nvmet_support ) ) { ndlp -> nlp_type &= ~ ( NLP_FCP_TARGET | NLP_FCP_INITIATOR ) ; ndlp -> nlp_type &= ~ ( NLP_NVME_TARGET | NLP_NVME_INITIATOR ) ; ndlp -> nlp_fcp_info &= ~ NLP_FCP_2_DEVICE ; ndlp -> nlp_nvme_info &= ~ NLP_NVME_NSLER ; ndlp -> nlp_flag &= ~ NLP_FIRSTBURST ; lpfc_els_rsp_acc ( vport , ELS_CMD_PLOGI , cmdiocb , ndlp , NULL ) ; return 1 ; } if ( nlp_portwwn != 0 && nlp_portwwn != wwn_to_u64 ( sp -> portName . u . wwn ) ) { lpfc_printf_vlog ( vport , KERN_ERR , LOG_TRACE_EVENT , "0143 PLOGI recv'd from DID: x%x " "WWPN changed: old %llx new %llx\n" , ndlp -> nlp_DID , ( unsigned long long ) nlp_portwwn , ( unsigned long long ) wwn_to_u64 ( sp -> portName . u . wwn ) ) ; } if ( phba -> nvmet_support && ndlp -> nlp_state == NLP_STE_UNMAPPED_NODE ) { lpfc_nvmet_invalidate_host ( phba , ndlp ) ; } ndlp -> nlp_prev_state = ndlp -> nlp_state ; lpfc_nlp_set_state ( vport , ndlp , NLP_STE_NPR_NODE ) ; break ; } ndlp -> nlp_type &= ~ ( NLP_FCP_TARGET | NLP_FCP_INITIATOR ) ; ndlp -> nlp_type &= ~ ( NLP_NVME_TARGET | NLP_NVME_INITIATOR ) ; ndlp -> nlp_fcp_info &= ~ NLP_FCP_2_DEVICE ; ndlp -> nlp_nvme_info &= ~ NLP_NVME_NSLER ; ndlp -> nlp_flag &= ~ NLP_FIRSTBURST ; login_mbox = NULL ; link_mbox = NULL ; save_iocb = NULL ; if ( ( vport -> fc_flag & FC_PT2PT ) && ! ( vport -> fc_flag & FC_PT2PT_PLOGI ) ) { if ( phba -> sli_rev == LPFC_SLI_REV4 ) { vport -> fc_myDID = bf_get ( els_rsp64_sid , & cmdiocb -> wqe . xmit_els_rsp ) ; } else { vport -> fc_myDID = icmd -> un . rcvels . parmRo ; } if ( phba -> hba_flag & HBA_FLOGI_OUTSTANDING ) { lpfc_els_abort_flogi ( phba ) ; } ed_tov = be32_to_cpu ( sp -> cmn . e_d_tov ) ; if ( sp -> cmn . edtovResolution ) { ed_tov = ( phba -> fc_edtov + 999999 ) / 1000000 ; } if ( ed_tov > phba -> fc_edtov ) { phba -> fc_edtov = ed_tov ; } phba -> fc_ratov = ( 2 * phba -> fc_edtov ) / 1000 ; memcpy ( & phba -> fc_fabparam , sp , sizeof ( serv_parm ) ) ; if ( phba -> sli_rev == LPFC_SLI_REV4 ) { lpfc_issue_reg_vfi ( vport ) ; } else { link_mbox = mempool_alloc ( phba -> mbox_mem_pool , GFP_KERNEL ) ; if ( ! link_mbox ) { out } lpfc_config_link ( phba , link_mbox ) ; link_mbox -> mbox_cmpl = lpfc_sli_def_mbox_cmpl ; link_mbox -> vport = vport ; link_mbox -> ctx_ndlp = ndlp ; rc = lpfc_sli_issue_mbox ( phba , link_mbox , MBX_NOWAIT ) ; if ( rc == MBX_NOT_FINISHED ) { mempool_free ( link_mbox , phba -> mbox_mem_pool ) ; out } } lpfc_can_disctmo ( vport ) ; } ndlp -> nlp_flag &= ~ NLP_SUPPRESS_RSP ; if ( ( phba -> sli . sli_flag & LPFC_SLI_SUPPRESS_RSP ) && sp -> cmn . valid_vendor_ver_level ) { vid = be32_to_cpu ( sp -> un . vv . vid ) ; flag = be32_to_cpu ( sp -> un . vv . flags ) ; if ( ( vid == LPFC_VV_EMLX_ID ) && ( flag & LPFC_VV_SUPPRESS_RSP ) ) { ndlp -> nlp_flag |= NLP_SUPPRESS_RSP ; } } login_mbox = mempool_alloc ( phba -> mbox_mem_pool , GFP_KERNEL ) ; if ( ! login_mbox ) { out } save_iocb = kzalloc ( sizeof ( * save_iocb ) , GFP_KERNEL ) ; if ( ! save_iocb ) { out } memcpy ( ( uint8_t * ) save_iocb , ( uint8_t * ) cmdiocb , sizeof ( lpfc_iocbq ) ) ; if ( phba -> sli_rev == LPFC_SLI_REV4 ) { lpfc_unreg_rpi ( vport , ndlp ) ; } if ( phba -> sli_rev == LPFC_SLI_REV4 ) { remote_did = bf_get ( wqe_els_did , & wqe -> xmit_els_rsp . wqe_dest ) ; } else { remote_did = icmd -> un . rcvels . remoteID ; } rc = lpfc_reg_rpi ( phba , vport -> vpi , remote_did , ( uint8_t * ) sp , login_mbox , ndlp -> nlp_rpi ) ; if ( rc ) { out } login_mbox -> mbox_cmpl = lpfc_mbx_cmpl_reg_login ; login_mbox -> vport = vport ; if ( ( ndlp -> nlp_state == NLP_STE_PLOGI_ISSUE ) && ( vport -> fc_flag & FC_FABRIC ) ) { lpfc_els_abort ( phba , ndlp ) ; } if ( ( vport -> port_type == LPFC_NPIV_PORT && vport -> cfg_restrict_login ) ) { kfree ( save_iocb ) ; if ( phba -> sli_rev == LPFC_SLI_REV4 ) { lpfc_mbox_rsrc_cleanup ( phba , login_mbox , MBOX_THD_UNLOCKED ) ; login_mbox = NULL ; } else { spin_lock_irq ( & ndlp -> lock ) ; ndlp -> nlp_flag |= ( NLP_RM_DFLT_RPI | NLP_ACC_REGLOGIN | NLP_RCV_PLOGI ) ; spin_unlock_irq ( & ndlp -> lock ) ; } stat . un . b . lsRjtRsnCode = LSRJT_INVALID_CMD ; stat . un . b . lsRjtRsnCodeExp = LSEXP_NOTHING_MORE ; rc = lpfc_els_rsp_reject ( vport , stat . un . lsRjtError , cmdiocb , ndlp , login_mbox ) ; if ( rc && login_mbox ) { lpfc_mbox_rsrc_cleanup ( phba , login_mbox , MBOX_THD_UNLOCKED ) ; } return 1 ; } login_mbox -> mbox_cmpl = lpfc_defer_plogi_acc ; login_mbox -> ctx_ndlp = lpfc_nlp_get ( ndlp ) ; if ( ! login_mbox -> ctx_ndlp ) { out } login_mbox -> context3 = save_iocb ; spin_lock_irq ( & ndlp -> lock ) ; ndlp -> nlp_flag |= ( NLP_ACC_REGLOGIN | NLP_RCV_PLOGI ) ; spin_unlock_irq ( & ndlp -> lock ) ; rc = lpfc_sli_issue_mbox ( phba , login_mbox , MBX_NOWAIT ) ; if ( rc == MBX_NOT_FINISHED ) { lpfc_nlp_put ( ndlp ) ; out } lpfc_nlp_set_state ( vport , ndlp , NLP_STE_REG_LOGIN_ISSUE ) ; return 1 ; out kfree ( save_iocb ) ; if ( login_mbox ) { mempool_free ( login_mbox , phba -> mbox_mem_pool ) ; } stat . un . b . lsRjtRsnCode = LSRJT_UNABLE_TPC ; stat . un . b . lsRjtRsnCodeExp = LSEXP_OUT_OF_RESOURCE ; lpfc_els_rsp_reject ( vport , stat . un . lsRjtError , cmdiocb , ndlp , NULL ) ; return 0 ; } 