static int ah6_init_state ( struct xfrm_state * x ) { struct ah_data * ahp = NULL ; struct xfrm_algo_desc * aalg_desc ; struct crypto_ahash * ahash ; if ( ! x -> aalg ) { error } if ( x -> encap ) { error } ahp = kzalloc ( sizeof ( * ahp ) , GFP_KERNEL ) ; ahash = crypto_alloc_ahash ( x -> aalg -> alg_name , 0 , 0 ) ; if ( IS_ERR ( ahash ) ) { error } ahp -> ahash = ahash ; if ( crypto_ahash_setkey ( ahash , x -> aalg -> alg_key , ( x -> aalg -> alg_key_len + 7 ) / 8 ) ) { error } aalg_desc = xfrm_aalg_get_byname ( x -> aalg -> alg_name , 0 ) ; BUG_ON ( ! aalg_desc ) ; if ( aalg_desc -> uinfo . auth . icv_fullbits / 8 != crypto_ahash_digestsize ( ahash ) ) { pr_info ( "AH: %s digestsize %u != %hu\n" , x -> aalg -> alg_name , crypto_ahash_digestsize ( ahash ) , aalg_desc -> uinfo . auth . icv_fullbits / 8 ) ; error } ahp -> icv_full_len = aalg_desc -> uinfo . auth . icv_fullbits / 8 ; ahp -> icv_trunc_len = x -> aalg -> alg_trunc_len / 8 ; x -> props . header_len = XFRM_ALIGN8 ( sizeof ( ip_auth_hdr ) + ahp -> icv_trunc_len ) ; switch ( x -> props . mode ) { case XFRM_MODE_BEET : case XFRM_MODE_TRANSPORT : break ; case XFRM_MODE_TUNNEL : x -> props . header_len += sizeof ( ipv6hdr ) ; break ; default : error } x -> data = ahp ; return 0 ; error if ( ahp ) { crypto_free_ahash ( ahp -> ahash ) ; kfree ( ahp ) ; } return - EINVAL ; } 