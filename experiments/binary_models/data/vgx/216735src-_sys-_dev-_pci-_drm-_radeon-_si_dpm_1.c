static int si_populate_smc_initial_state ( struct radeon_device * rdev , struct radeon_ps * radeon_initial_state , SISLANDS_SMC_STATETABLE * table ) { struct ni_ps * initial_state = ni_get_ps ( radeon_initial_state ) ; struct rv7xx_power_info * pi = rv770_get_pi ( rdev ) ; struct evergreen_power_info * eg_pi = evergreen_get_pi ( rdev ) ; struct si_power_info * si_pi = si_get_pi ( rdev ) ; int reg ; int ret ; table -> initialState . level . mclk . vDLL_CNTL = cpu_to_be32 ( si_pi -> clock_registers . dll_cntl ) ; table -> initialState . level . mclk . vMCLK_PWRMGT_CNTL = cpu_to_be32 ( si_pi -> clock_registers . mclk_pwrmgt_cntl ) ; table -> initialState . level . mclk . vMPLL_AD_FUNC_CNTL = cpu_to_be32 ( si_pi -> clock_registers . mpll_ad_func_cntl ) ; table -> initialState . level . mclk . vMPLL_DQ_FUNC_CNTL = cpu_to_be32 ( si_pi -> clock_registers . mpll_dq_func_cntl ) ; table -> initialState . level . mclk . vMPLL_FUNC_CNTL = cpu_to_be32 ( si_pi -> clock_registers . mpll_func_cntl ) ; table -> initialState . level . mclk . vMPLL_FUNC_CNTL_1 = cpu_to_be32 ( si_pi -> clock_registers . mpll_func_cntl_1 ) ; table -> initialState . level . mclk . vMPLL_FUNC_CNTL_2 = cpu_to_be32 ( si_pi -> clock_registers . mpll_func_cntl_2 ) ; table -> initialState . level . mclk . vMPLL_SS = cpu_to_be32 ( si_pi -> clock_registers . mpll_ss1 ) ; table -> initialState . level . mclk . vMPLL_SS2 = cpu_to_be32 ( si_pi -> clock_registers . mpll_ss2 ) ; table -> initialState . level . mclk . mclk_value = cpu_to_be32 ( initial_state -> performance_levels [ 0 ] . mclk ) ; table -> initialState . level . sclk . vCG_SPLL_FUNC_CNTL = cpu_to_be32 ( si_pi -> clock_registers . cg_spll_func_cntl ) ; table -> initialState . level . sclk . vCG_SPLL_FUNC_CNTL_2 = cpu_to_be32 ( si_pi -> clock_registers . cg_spll_func_cntl_2 ) ; table -> initialState . level . sclk . vCG_SPLL_FUNC_CNTL_3 = cpu_to_be32 ( si_pi -> clock_registers . cg_spll_func_cntl_3 ) ; table -> initialState . level . sclk . vCG_SPLL_FUNC_CNTL_4 = cpu_to_be32 ( si_pi -> clock_registers . cg_spll_func_cntl_4 ) ; table -> initialState . level . sclk . vCG_SPLL_SPREAD_SPECTRUM = cpu_to_be32 ( si_pi -> clock_registers . cg_spll_spread_spectrum ) ; table -> initialState . level . sclk . vCG_SPLL_SPREAD_SPECTRUM_2 = cpu_to_be32 ( si_pi -> clock_registers . cg_spll_spread_spectrum_2 ) ; table -> initialState . level . sclk . sclk_value = cpu_to_be32 ( initial_state -> performance_levels [ 0 ] . sclk ) ; table -> initialState . level . arbRefreshState = SISLANDS_INITIAL_STATE_ARB_INDEX ; table -> initialState . level . ACIndex = 0 ; ret = si_populate_voltage_value ( rdev , & eg_pi -> vddc_voltage_table , initial_state -> performance_levels [ 0 ] . vddc , & table -> initialState . level . vddc ) ; if ( ! ret ) { u16 std_vddc ; ret = si_get_std_voltage_value ( rdev , & table -> initialState . level . vddc , & std_vddc ) ; if ( ! ret ) { si_populate_std_voltage_value ( rdev , std_vddc , table -> initialState . level . vddc . index , & table -> initialState . level . std_vddc ) ; } } if ( eg_pi -> vddci_control ) { si_populate_voltage_value ( rdev , & eg_pi -> vddci_voltage_table , initial_state -> performance_levels [ 0 ] . vddci , & table -> initialState . level . vddci ) ; } if ( si_pi -> vddc_phase_shed_control ) { si_populate_phase_shedding_value ( rdev , & rdev -> pm . dpm . dyn_state . phase_shedding_limits_table , initial_state -> performance_levels [ 0 ] . vddc , initial_state -> performance_levels [ 0 ] . sclk , initial_state -> performance_levels [ 0 ] . mclk , & table -> initialState . level . vddc ) ; } si_populate_initial_mvdd_value ( rdev , & table -> initialState . level . mvdd ) ; reg = CG_R ( 0xffff ) | CG_L ( 0 ) ; table -> initialState . level . aT = cpu_to_be32 ( reg ) ; table -> initialState . level . bSP = cpu_to_be32 ( pi -> dsp ) ; table -> initialState . level . gen2PCIE = ( u8 ) si_pi -> boot_pcie_gen ; if ( pi -> mem_gddr5 ) { table -> initialState . level . strobeMode = si_get_strobe_mode_settings ( rdev , initial_state -> performance_levels [ 0 ] . mclk ) ; if ( initial_state -> performance_levels [ 0 ] . mclk > pi -> mclk_edc_enable_threshold ) { table -> initialState . level . mcFlags = SISLANDS_SMC_MC_EDC_RD_FLAG | SISLANDS_SMC_MC_EDC_WR_FLAG ; } else { table -> initialState . level . mcFlags = 0 ; } } table -> initialState . levelCount = 1 ; table -> initialState . flags |= PPSMC_SWSTATE_FLAG_DC ; table -> initialState . level . dpm2 . MaxPS = 0 ; table -> initialState . level . dpm2 . NearTDPDec = 0 ; table -> initialState . level . dpm2 . AboveSafeInc = 0 ; table -> initialState . level . dpm2 . BelowSafeInc = 0 ; table -> initialState . level . dpm2 . PwrEfficiencyRatio = 0 ; reg = MIN_POWER_MASK | MAX_POWER_MASK ; table -> initialState . level . SQPowerThrottle = cpu_to_be32 ( reg ) ; reg = MAX_POWER_DELTA_MASK | STI_SIZE_MASK | LTI_RATIO_MASK ; table -> initialState . level . SQPowerThrottle_2 = cpu_to_be32 ( reg ) ; return 0 ; } 