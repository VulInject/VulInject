void eqn4_f32 ( float * Out , libxsmm_blasint m , libxsmm_blasint n , libxsmm_blasint ld , float * A , libxsmm_blasint m_A , libxsmm_blasint n_A , libxsmm_blasint lda , float * B , libxsmm_blasint m_B , libxsmm_blasint n_B , libxsmm_blasint ldb , libxsmm_blasint brgemm_count , float * C , libxsmm_blasint m_C , libxsmm_blasint n_C , libxsmm_blasint ldc , libxsmm_blasint stride_a , float * D , libxsmm_blasint m_D , libxsmm_blasint n_D , libxsmm_blasint ldd , libxsmm_blasint stride_b , float * colbias , int relu_sigmoid_fusion_mode , float * tmp ) { libxsmm_blasint i , j ; LIBXSMM_UNUSED ( m_A , NULL ) ; LIBXSMM_UNUSED ( m_B ) ; LIBXSMM_UNUSED ( m_D ) ; LIBXSMM_UNUSED ( n_A ) ; LIBXSMM_UNUSED ( n_B ) ; LIBXSMM_UNUSED ( lda ) ; LIBXSMM_UNUSED ( ldb ) ; LIBXSMM_UNUSED ( A ) ; LIBXSMM_UNUSED ( B ) ; gemm_fp32 ( C , D , tmp , 0 , m_C , n_D , n_C , ldc , ldd , m_C , brgemm_count , stride_a , stride_b ) ; if ( relu_sigmoid_fusion_mode == 0 ) { for ( j = 0 ; j < n ; j ++ ) { for ( i = 0 ; i < m ; i ++ ) { Out [ i + j * ld ] = tmp [ j * m_C + i ] + colbias [ i ] + 1.f ; } } } if ( relu_sigmoid_fusion_mode == 1 ) { for ( j = 0 ; j < n ; j ++ ) { for ( i = 0 ; i < m ; i ++ ) { Out [ i + j * ld ] = LIBXSMM_MAX ( 0.f , tmp [ j * m_C + i ] + colbias [ i ] + 1.f ) ; } } } if ( relu_sigmoid_fusion_mode == 2 ) { for ( j = 0 ; j < n ; j ++ ) { for ( i = 0 ; i < m ; i ++ ) { Out [ i + j * ld ] = fsigmoid ( tmp [ j * m_C + i ] + colbias [ i ] + 1.f ) ; } } } } 