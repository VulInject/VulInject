static int stateless_connect ( const char * service_name ) { struct discovery * discover ; struct rpc_state rpc = RPC_STATE_INIT ; struct strbuf buf = STRBUF_INIT ; const char * accept_language ; discover = discover_refs ( service_name , 0 ) ; if ( discover -> version != protocol_v2 ) { printf ( "fallback\n" ) ; fflush ( stdout ) ; return - 1 ; } else { printf ( "\n" ) ; fflush ( stdout ) ; } accept_language = http_get_accept_language_header ( ) ; if ( accept_language ) { rpc . hdr_accept_language = xstrfmt ( "%s" , accept_language ) ; } rpc . service_name = service_name ; rpc . service_url = xstrfmt ( "%s%s" , url . buf , rpc . service_name ) ; rpc . hdr_content_type = xstrfmt ( "Content-Type: application/x-%s-request" , rpc . service_name ) ; rpc . hdr_accept = xstrfmt ( "Accept: application/x-%s-result" , rpc . service_name ) ; if ( get_protocol_http_header ( discover -> version , & buf ) ) { rpc . protocol_header = strbuf_detach ( & buf , NULL ) ; } else { rpc . protocol_header = NULL ; strbuf_release ( & buf ) ; } rpc . buf = xmalloc ( http_post_buffer ) ; rpc . alloc = http_post_buffer ; rpc . len = 0 ; rpc . pos = 0 ; rpc . in = 1 ; rpc . out = 0 ; rpc . any_written = 0 ; rpc . gzip_request = 1 ; rpc . initial_buffer = 0 ; rpc . write_line_lengths = 1 ; rpc . flush_read_but_not_sent = 0 ; write_or_die ( rpc . in , discover -> buf , discover -> len ) ; while ( 1 ) { size_t avail ; enum packet_read_status status ; if ( ! rpc_read_from_out ( & rpc , PACKET_READ_GENTLE_ON_EOF , & avail , & status ) ) { BUG ( "The entire rpc->buf should be larger than LARGE_PACKET_MAX" ) ; } if ( status == PACKET_READ_EOF ) { break ; } if ( post_rpc ( & rpc , 1 , status == PACKET_READ_FLUSH ) ) { break ; } rpc . len = 0 ; } free ( rpc . service_url ) ; free ( rpc . hdr_accept ) ; free ( rpc . hdr_accept_language ) ; free ( rpc . protocol_header ) ; free ( rpc . buf ) ; strbuf_release ( & buf ) ; return 0 ; } 