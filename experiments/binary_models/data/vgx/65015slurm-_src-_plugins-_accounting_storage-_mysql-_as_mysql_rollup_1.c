if ( ( rc = _setup_resv_usage ( mysql_conn , cluster_name , curr_start , curr_end , resv_usage_list , dims ) ) != SLURM_SUCCESS ) { end_it } c_usage = _setup_cluster_usage ( mysql_conn , cluster_name , curr_start , curr_end , resv_usage_list , cluster_down_list , dims ) ; if ( c_usage ) { xassert ( c_usage -> loc_tres ) ; } query = xstrdup_printf ( "select %s from \"%s_%s\" as job " "where (job.time_eligible&&" "job.time_eligible<%ld&&" "(job.time_end>= %ld || " "job.time_end = 0)) " "group by job.job_db_inx " "order by job.id_assoc, " "job.time_eligible" , job_str , cluster_name , job_table , curr_end , curr_start ) ; DB_DEBUG ( DB_USAGE , mysql_conn -> conn , "query\n%s" , query ) ; if ( ! ( result = mysql_db_query_ret ( mysql_conn , query , 0 ) ) ) { rc = SLURM_ERROR ; end_it } while ( ( row = mysql_fetch_row ( result ) ) ) { uint32_t assoc_id = slurm_atoul ( row [ JOB_REQ_ASSOCID ] ) ; uint32_t wckey_id = slurm_atoul ( row [ JOB_REQ_WCKEYID ] ) ; uint32_t array_pending = slurm_atoul ( row [ JOB_REQ_ARRAY_PENDING ] ) ; uint32_t resv_id = slurm_atoul ( row [ JOB_REQ_RESVID ] ) ; time_t row_eligible = slurm_atoul ( row [ JOB_REQ_ELG ] ) ; time_t row_start = slurm_atoul ( row [ JOB_REQ_START ] ) ; time_t row_end = slurm_atoul ( row [ JOB_REQ_END ] ) ; uint32_t row_rcpu = slurm_atoul ( row [ JOB_REQ_RCPU ] ) ; List loc_tres = NULL ; int loc_seconds = 0 ; int seconds = 0 , suspend_seconds = 0 ; if ( row_start && ( row_start < curr_start ) ) { row_start = curr_start ; } if ( ! row_start && row_end ) { row_start = row_end ; } if ( ! row_end || row_end > curr_end ) { row_end = curr_end ; } if ( ! row_start || ( ( row_end - row_start ) < 1 ) ) { calc_cluster } seconds = ( row_end - row_start ) ; if ( slurm_atoul ( row [ JOB_REQ_SUSPENDED ] ) ) { MYSQL_RES * result2 = NULL ; MYSQL_ROW row2 ; query = xstrdup_printf ( "select %s from \"%s_%s\" where " "(time_start<%ld&&(time_end>= %ld " "|| time_end = 0))&&job_db_inx=%s " "order by time_start" , suspend_str , cluster_name , suspend_table , curr_end , curr_start , row [ JOB_REQ_DB_INX ] ) ; debug4 ( "%d(%s:%d) query\n%s" , mysql_conn -> conn , THIS_FILE , __LINE__ , query ) ; if ( ! ( result2 = mysql_db_query_ret ( mysql_conn , query , 0 ) ) ) { rc = SLURM_ERROR ; mysql_free_result ( result ) ; end_it } xfree ( query ) ; while ( ( row2 = mysql_fetch_row ( result2 ) ) ) { int tot_time = 0 ; time_t local_start = slurm_atoul ( row2 [ SUSPEND_REQ_START ] ) ; time_t local_end = slurm_atoul ( row2 [ SUSPEND_REQ_END ] ) ; if ( ! local_start ) { continue ; } if ( row_start > local_start ) { local_start = row_start ; } if ( ! local_end || row_end < local_end ) { local_end = row_end ; } tot_time = ( local_end - local_start ) ; if ( tot_time > 0 ) { suspend_seconds += tot_time ; } } mysql_free_result ( result2 ) ; } if ( last_id != assoc_id ) { a_usage = xmalloc ( sizeof ( local_id_usage_t ) ) ; a_usage -> id = assoc_id ; list_append ( assoc_usage_list , a_usage ) ; last_id = assoc_id ; } if ( ! track_wckey ) { last_wckeyid = wckey_id ; } if ( last_wckeyid != wckey_id ) { list_iterator_reset ( w_itr ) ; while ( ( w_usage = list_next ( w_itr ) ) ) { if ( w_usage -> id == wckey_id ) { break ; } } if ( ! w_usage ) { w_usage = xmalloc ( sizeof ( local_id_usage_t ) ) ; w_usage -> id = wckey_id ; list_append ( wckey_usage_list , w_usage ) ; w_usage -> loc_tres = list_create ( _destroy_local_tres_usage ) ; } last_wckeyid = wckey_id ; } calc_cluster loc_tres = list_create ( _destroy_local_tres_usage ) ; _add_tres_time_2_list ( loc_tres , row [ JOB_REQ_TRES ] , TIME_ALLOC , seconds , suspend_seconds , 0 ) ; if ( w_usage ) { _add_tres_time_2_list ( w_usage -> loc_tres , row [ JOB_REQ_TRES ] , TIME_ALLOC , seconds , suspend_seconds , 0 ) ; } list_iterator_reset ( c_itr ) ; while ( ( loc_c_usage = list_next ( c_itr ) ) ) { int temp_end = row_end ; int temp_start = row_start ; if ( loc_c_usage -> start > temp_start ) { temp_start = loc_c_usage -> start ; } if ( loc_c_usage -> end < temp_end ) { temp_end = loc_c_usage -> end ; } loc_seconds = ( temp_end - temp_start ) ; if ( loc_seconds < 1 ) { continue ; } _remove_job_tres_time_from_cluster ( loc_c_usage -> loc_tres , loc_tres , loc_seconds ) ; } if ( resv_id ) { list_iterator_reset ( r_itr ) ; while ( ( r_usage = list_next ( r_itr ) ) ) { int temp_end , temp_start ; if ( r_usage -> id != resv_id ) { continue ; } if ( r_usage -> flags & RESERVE_FLAG_IGN_JOBS ) { _add_planned_time ( c_usage , MIN ( row_start , r_usage -> end ) , MAX ( row_eligible , r_usage -> start ) , array_pending , row_rcpu ) ; } temp_end = row_end ; temp_start = row_start ; if ( r_usage -> start > temp_start ) { temp_start = r_usage -> start ; } if ( r_usage -> end < temp_end ) { temp_end = r_usage -> end ; } loc_seconds = ( temp_end - temp_start ) ; if ( loc_seconds <= 0 ) { continue ; } if ( c_usage && ( r_usage -> flags & RESERVE_FLAG_IGN_JOBS ) ) { _add_tres_time_2_list ( c_usage -> loc_tres , row [ JOB_REQ_TRES ] , TIME_ALLOC , loc_seconds , 0 , 0 ) ; } _add_time_tres_list ( r_usage -> loc_tres , loc_tres , TIME_ALLOC , loc_seconds , 1 ) ; if ( ( rc = _update_unused_wall ( r_usage , loc_tres , loc_seconds ) ) != SLURM_SUCCESS ) { end_it } } _transfer_loc_tres ( & loc_tres , a_usage ) ; continue ; } if ( c_usage && row_start && ( seconds > 0 ) ) { _add_job_alloc_time_to_cluster ( c_usage -> loc_tres , loc_tres ) ; } _transfer_loc_tres ( & loc_tres , a_usage ) ; _add_planned_time ( c_usage , row_start , row_eligible , array_pending , row_rcpu ) ; } mysql_free_result ( result ) ; query = NULL ; list_iterator_reset ( r_itr ) ; while ( ( r_usage = list_next ( r_itr ) ) ) { ListIterator t_itr ; local_tres_usage_t * loc_tres ; xstrfmtcat ( query , "update \"%s_%s\" set unused_wall=%f where id_resv=%u and time_start=%ld;" , cluster_name , resv_table , r_usage -> unused_wall , r_usage -> id , r_usage -> orig_start ) ; if ( ! r_usage -> loc_tres || ! list_count ( r_usage -> loc_tres ) ) { continue ; } t_itr = list_iterator_create ( r_usage -> loc_tres ) ; while ( ( loc_tres = list_next ( t_itr ) ) ) { int64_t idle = loc_tres -> total_time - loc_tres -> time_alloc ; char * assoc = NULL ; ListIterator tmp_itr = NULL ; int assoc_cnt , resv_unused_secs ; if ( idle <= 0 ) { break ; } resv_unused_secs = idle ; assoc_cnt = list_count ( r_usage -> local_assocs ) ; if ( assoc_cnt ) { resv_unused_secs /= assoc_cnt ; } tmp_itr = list_iterator_create ( r_usage -> local_assocs ) ; while ( ( assoc = list_next ( tmp_itr ) ) ) { uint32_t associd = slurm_atoul ( assoc ) ; if ( ( last_id != associd ) && ! ( a_usage = list_find_first ( assoc_usage_list , _find_id_usage , & associd ) ) ) { a_usage = xmalloc ( sizeof ( local_id_usage_t ) ) ; a_usage -> id = associd ; list_append ( assoc_usage_list , a_usage ) ; a_usage -> loc_tres = list_create ( _destroy_local_tres_usage ) ; } last_id = associd ; _add_time_tres ( a_usage -> loc_tres , TIME_ALLOC , loc_tres -> id , resv_unused_secs , 0 ) ; } list_iterator_destroy ( tmp_itr ) ; } list_iterator_destroy ( t_itr ) ; } if ( query ) { DB_DEBUG ( DB_USAGE , mysql_conn -> conn , "query\n%s" , query ) ; rc = mysql_db_query ( mysql_conn , query ) ; xfree ( query ) ; if ( rc != SLURM_SUCCESS ) { error ( "couldn't update reservations with unused time" ) ; end_it } } if ( c_usage ) { list_iterator_reset ( c_itr ) ; while ( ( loc_c_usage = list_next ( c_itr ) ) ) { local_tres_usage_t * loc_tres ; ListIterator tmp_itr = list_iterator_create ( loc_c_usage -> loc_tres ) ; while ( ( loc_tres = list_next ( tmp_itr ) ) ) { _add_time_tres ( c_usage -> loc_tres , TIME_DOWN , loc_tres -> id , loc_tres -> total_time , 0 ) ; } list_iterator_destroy ( tmp_itr ) ; } if ( ( rc = _process_cluster_usage ( mysql_conn , cluster_name , curr_start , curr_end , now , c_usage ) ) != SLURM_SUCCESS ) { end_it } } list_iterator_reset ( a_itr ) ; while ( ( a_usage = list_next ( a_itr ) ) ) { _create_id_usage_insert ( cluster_name , ASSOC_TABLES , curr_start , now , a_usage , & query ) ; } if ( query ) { DB_DEBUG ( DB_USAGE , mysql_conn -> conn , "query\n%s" , query ) ; rc = mysql_db_query ( mysql_conn , query ) ; xfree ( query ) ; if ( rc != SLURM_SUCCESS ) { error ( "Couldn't add assoc hour rollup" ) ; end_it } } if ( ! track_wckey ) { end_loop } list_iterator_reset ( w_itr ) ; while ( ( w_usage = list_next ( w_itr ) ) ) { _create_id_usage_insert ( cluster_name , WCKEY_TABLES , curr_start , now , w_usage , & query ) ; } if ( query ) { DB_DEBUG ( DB_USAGE , mysql_conn -> conn , "query\n%s" , query ) ; rc = mysql_db_query ( mysql_conn , query ) ; xfree ( query ) ; if ( rc != SLURM_SUCCESS ) { error ( "Couldn't add wckey hour rollup" ) ; end_it } } end_loop _destroy_local_cluster_usage ( c_usage ) ; c_usage = NULL ; r_usage = NULL ; a_usage = NULL ; w_usage = NULL ; list_flush ( assoc_usage_list ) ; list_flush ( cluster_down_list ) ; list_flush ( wckey_usage_list ) ; list_flush ( resv_usage_list ) ; curr_start = curr_end ; curr_end = curr_start + add_sec ; xfree ( query ) ; xfree ( suspend_str ) ; xfree ( job_str ) ; _destroy_local_cluster_usage ( c_usage ) ; if ( a_itr ) { list_iterator_destroy ( a_itr ) ; } if ( c_itr ) { list_iterator_destroy ( c_itr ) ; } if ( w_itr ) { list_iterator_destroy ( w_itr ) ; } if ( r_itr ) { list_iterator_destroy ( r_itr ) ; } FREE_NULL_LIST ( assoc_usage_list ) ; FREE_NULL_LIST ( cluster_down_list ) ; FREE_NULL_LIST ( wckey_usage_list ) ; FREE_NULL_LIST ( resv_usage_list ) ; if ( rc == SLURM_SUCCESS ) { if ( mysql_db_commit ( mysql_conn ) ) { char start [ 25 ] , end [ 25 ] ; error ( "Couldn't commit cluster (%s) " "hour rollup for %s - %s" , cluster_name , slurm_ctime2_r ( & curr_start , start ) , slurm_ctime2_r ( & curr_end , end ) ) ; rc = SLURM_ERROR ; } else { rc = _process_purge ( mysql_conn , cluster_name , archive_data , SLURMDB_PURGE_HOURS ) ; } } return rc ; 