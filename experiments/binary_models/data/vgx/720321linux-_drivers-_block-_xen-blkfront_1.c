static int blkfront_probe ( struct xenbus_device * dev , const struct xenbus_device_id * id ) { int err , vdevice ; struct blkfront_info * info ; err = xenbus_scanf ( XBT_NIL , dev -> nodename , "virtual-device" , "%i" , & vdevice ) ; if ( err != 1 ) { err = xenbus_scanf ( XBT_NIL , dev -> nodename , "virtual-device-ext" , "%i" , & vdevice ) ; if ( err != 1 ) { xenbus_dev_fatal ( dev , err , "reading virtual-device" ) ; return err ; } } if ( xen_hvm_domain ( ) ) { char * type ; int len ; if ( xen_has_pv_and_legacy_disk_devices ( ) ) { int major ; if ( ! VDEV_IS_EXTENDED ( vdevice ) ) { major = BLKIF_MAJOR ( vdevice ) ; } else { major = XENVBD_MAJOR ; } if ( major != XENVBD_MAJOR ) { printk ( KERN_INFO "%s: HVM does not support vbd %d as xen block device\n" , __func__ , vdevice ) ; return - ENODEV ; } } type = xenbus_read ( XBT_NIL , dev -> nodename , "device-type" , & len ) ; if ( IS_ERR ( type ) ) { return - ENODEV ; } if ( strncmp ( type , "cdrom" , 5 ) == 0 ) { kfree ( type ) ; return - ENODEV ; } kfree ( type ) ; } info = kzalloc ( sizeof ( * info ) , GFP_KERNEL ) ; if ( ! info ) { xenbus_dev_fatal ( dev , - ENOMEM , "allocating info structure" ) ; return - ENOMEM ; } info -> xbdev = dev ; info -> vdevice = vdevice ; info -> connected = BLKIF_STATE_DISCONNECTED ; info -> handle = simple_strtoul ( strrchr ( dev -> nodename , '/' ) + 1 , NULL , 0 ) ; dev_set_drvdata ( & dev -> dev , info ) ; mutex_lock ( & blkfront_mutex ) ; list_add ( & info -> info_list , & info_list ) ; mutex_unlock ( & blkfront_mutex ) ; return 0 ; } 