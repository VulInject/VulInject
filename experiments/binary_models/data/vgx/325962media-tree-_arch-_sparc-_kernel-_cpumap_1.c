static struct cpuinfo_tree * build_cpuinfo_tree ( void ) { struct cpuinfo_tree * new_tree ; struct cpuinfo_node * node ; struct cpuinfo_level tmp_level [ CPUINFO_LVL_MAX ] ; int num_cpus [ CPUINFO_LVL_MAX ] ; int level_rover [ CPUINFO_LVL_MAX ] ; int prev_id [ CPUINFO_LVL_MAX ] ; int n , id , cpu , prev_cpu , last_cpu , level ; n = enumerate_cpuinfo_nodes ( tmp_level ) ; new_tree = kzalloc ( sizeof ( cpuinfo_tree ) + ( sizeof ( cpuinfo_node ) * n ) , GFP_ATOMIC ) ; if ( ! new_tree ) { return NULL ; } new_tree -> total_nodes = n ; memcpy ( & new_tree -> level , tmp_level , sizeof ( tmp_level ) ) ; prev_cpu = cpu = cpumask_first ( cpu_online_mask ) ; for ( level = CPUINFO_LVL_PROC ; level >= CPUINFO_LVL_ROOT ; level -- ) { n = new_tree -> level [ level ] . start_index ; level_rover [ level ] = n ; node = & new_tree -> nodes [ n ] ; id = cpuinfo_id ( cpu , level ) ; if ( unlikely ( id < 0 ) ) { return NULL ; } node -> id = id ; node -> level = level ; node -> num_cpus = 1 ; node -> parent_index = ( level > CPUINFO_LVL_ROOT ) ?new_tree -> level [ level - 1 ] . start_index : - 1 ; node -> child_start = node -> child_end = node -> rover = ( level == CPUINFO_LVL_PROC ) ?cpu : new_tree -> level [ level + 1 ] . start_index ; prev_id [ level ] = node -> id ; num_cpus [ level ] = 1 ; } for ( last_cpu = ( num_possible_cpus ( ) - 1 ) ; last_cpu >= 0 ; last_cpu -- ) { if ( cpu_online ( last_cpu ) ) { break ; } } while ( ++ cpu <= last_cpu ) { if ( ! cpu_online ( cpu ) ) { continue ; } for ( level = CPUINFO_LVL_PROC ; level >= CPUINFO_LVL_ROOT ; level -- ) { id = cpuinfo_id ( cpu , level ) ; if ( unlikely ( id < 0 ) ) { kfree ( new_tree ) ; return NULL ; } if ( ( id != prev_id [ level ] ) || ( cpu == last_cpu ) ) { prev_id [ level ] = id ; node = & new_tree -> nodes [ level_rover [ level ] ] ; node -> num_cpus = num_cpus [ level ] ; num_cpus [ level ] = 1 ; if ( cpu == last_cpu ) { node -> num_cpus ++ ; } if ( level == CPUINFO_LVL_ROOT ) { node -> parent_index = - 1 ; } else { node -> parent_index = level_rover [ level - 1 ] ; } if ( level == CPUINFO_LVL_PROC ) { node -> child_end = ( cpu == last_cpu ) ?cpu : prev_cpu ; } else { node -> child_end = level_rover [ level + 1 ] - 1 ; } n = ++ level_rover [ level ] ; if ( n <= new_tree -> level [ level ] . end_index ) { node = & new_tree -> nodes [ n ] ; node -> id = id ; node -> level = level ; node -> child_start = node -> child_end = node -> rover = ( level == CPUINFO_LVL_PROC ) ?cpu : level_rover [ level + 1 ] ; } } else { num_cpus [ level ] ++ ; } } prev_cpu = cpu ; } return new_tree ; } 