strip_main ( , ) { char * input_target ; char * output_target = NULL ; bfd_boolean show_version = FALSE ; bfd_boolean formats_info = FALSE ; int c ; int i ; struct section_list * p ; char * output_file = NULL ; while ( ( c = getopt_long ( argc , argv , "I:O:F:K:N:R:o:sSpdgxXHhVvw" , strip_options , ( int * ) 0 ) ) != EOF ) { switch ( c ) { case 'I' : input_target = optarg ; break ; case 'O' : output_target = optarg ; break ; case 'F' : input_target = output_target = optarg ; break ; case 'R' : p = find_section_list ( optarg , TRUE ) ; p -> remove = TRUE ; sections_removed = TRUE ; break ; case 's' : strip_symbols = STRIP_ALL ; break ; case 'S' : case 'g' : case 'd' : strip_symbols = STRIP_DEBUG ; break ; case OPTION_STRIP_UNNEEDED : strip_symbols = STRIP_UNNEEDED ; break ; case 'K' : add_specific_symbol ( optarg , & keep_specific_list ) ; break ; case 'N' : add_specific_symbol ( optarg , & strip_specific_list ) ; break ; case 'o' : output_file = optarg ; break ; case 'p' : preserve_dates = TRUE ; break ; case 'x' : discard_locals = LOCALS_ALL ; break ; case 'X' : discard_locals = LOCALS_START_L ; break ; case 'v' : verbose = TRUE ; break ; case 'V' : show_version = TRUE ; break ; case OPTION_FORMATS_INFO : formats_info = TRUE ; break ; case OPTION_ONLY_KEEP_DEBUG : strip_symbols = STRIP_NONDEBUG ; break ; case OPTION_KEEP_FILE_SYMBOLS : keep_file_symbols = 1 ; break ; case 0 : break ; case 'w' : wildcard = TRUE ; break ; case 'H' : case 'h' : strip_usage ( stdout , 0 ) ; default : strip_usage ( stderr , 1 ) ; } } if ( formats_info ) { display_info ( ) ; return 0 ; } if ( show_version ) { print_version ( "strip" ) ; } if ( strip_symbols == STRIP_UNDEF && discard_locals == LOCALS_UNDEF && strip_specific_list == NULL ) { strip_symbols = STRIP_ALL ; } if ( output_target == NULL ) { output_target = input_target ; } i = optind ; if ( i == argc || ( output_file != NULL && ( i + 1 ) < argc ) ) { strip_usage ( stderr , 1 ) ; } for ( ; i < argc ; i ++ ) { int hold_status = status ; struct stat statbuf ; char * tmpname ; if ( get_file_size ( argv [ i ] ) < 1 ) { status = 1 ; continue ; } if ( preserve_dates ) { stat ( argv [ i ] , & statbuf ) ; } if ( output_file != NULL ) { tmpname = output_file ; } else { tmpname = make_tempname ( argv [ i ] , 0 ) ; } status = 0 ; copy_file ( argv [ i ] , tmpname , input_target , output_target ) ; if ( status == 0 ) { if ( preserve_dates ) { set_times ( tmpname , & statbuf ) ; } if ( output_file == NULL ) { int ret = smart_rename ( tmpname , argv [ i ] , preserve_dates ) ; if ( ret != 0 ) { hold_status = ret ; } } status = hold_status ; } else { unlink_if_ordinary ( tmpname ) ; } if ( output_file == NULL ) { free ( tmpname ) ; } } return 0 ; } 