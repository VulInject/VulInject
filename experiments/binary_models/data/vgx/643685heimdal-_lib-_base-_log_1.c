static void audit_trail_iterator ( heim_object_t key , heim_object_t value , void * arg ) { struct heim_audit_kv_buf * kvb = arg ; char num [ 32 ] ; const char * k = heim_string_get_utf8 ( key ) , * v = NULL ; char * b64 = NULL ; if ( k == NULL || * k == '#' ) { return ; } switch ( heim_get_tid ( value ) ) { case HEIM_TID_STRING : v = heim_string_get_utf8 ( value ) ; break ; case HEIM_TID_NUMBER : sprintf ( num , "%lld" , ( long long ) heim_number_get_long ( value ) ) ; v = num ; break ; case HEIM_TID_NULL : v = "null" ; break ; case HEIM_TID_BOOL : v = heim_bool_val ( value ) ?"true" : "false" ; break ; case HEIM_TID_ARRAY : if ( kvb -> iter ) { break ; } kvb -> iter = key ; heim_array_iterate_f ( value , kvb , audit_trail_iterator_array ) ; kvb -> iter = NULL ; break ; case HEIM_TID_DATA : { const heim_octet_string * data = heim_data_get_data ( value ) ; if ( rk_base64_encode ( data -> data , data -> length , & b64 ) >= 0 ) { v = b64 ; } break ; } default : break ; } if ( v == NULL ) { return ; } if ( kvb -> pos < sizeof ( kvb -> buf ) - 1 ) { kvb -> buf [ kvb -> pos ++ ] = ' ' ; } for ( ; * k && kvb -> pos < sizeof ( kvb -> buf ) - 1 ; kvb -> pos ++ ) { kvb -> buf [ kvb -> pos ] = * k ++ ; } if ( kvb -> pos < sizeof ( kvb -> buf ) - 1 ) { kvb -> buf [ kvb -> pos ++ ] = '=' ; } for ( ; * v && kvb -> pos < sizeof ( kvb -> buf ) - 1 ; kvb -> pos ++ ) { kvb -> buf [ kvb -> pos ] = * v ++ ; } free ( b64 ) ; } 