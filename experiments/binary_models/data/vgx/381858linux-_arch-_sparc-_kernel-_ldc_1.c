int ldc_bind ( struct ldc_channel * lp ) { unsigned long hv_err , flags ; int err = - EINVAL ; if ( lp -> state != LDC_STATE_INIT ) { return - EINVAL ; } spin_lock_irqsave ( & lp -> lock , flags ) ; enable_irq ( lp -> cfg . rx_irq , NULL ) ; enable_irq ( lp -> cfg . tx_irq ) ; lp -> flags |= LDC_FLAG_REGISTERED_IRQS ; err = - ENODEV ; hv_err = sun4v_ldc_tx_qconf ( lp -> id , 0 , 0 ) ; if ( hv_err ) { out_free_irqs } hv_err = sun4v_ldc_tx_qconf ( lp -> id , lp -> tx_ra , lp -> tx_num_entries ) ; if ( hv_err ) { out_free_irqs } hv_err = sun4v_ldc_rx_qconf ( lp -> id , 0 , 0 ) ; if ( hv_err ) { out_unmap_tx } hv_err = sun4v_ldc_rx_qconf ( lp -> id , lp -> rx_ra , lp -> rx_num_entries ) ; if ( hv_err ) { out_unmap_tx } lp -> flags |= LDC_FLAG_REGISTERED_QUEUES ; hv_err = sun4v_ldc_tx_get_state ( lp -> id , & lp -> tx_head , & lp -> tx_tail , & lp -> chan_state ) ; err = - EBUSY ; if ( hv_err ) { out_unmap_rx } lp -> tx_acked = lp -> tx_head ; lp -> hs_state = LDC_HS_OPEN ; ldc_set_state ( lp , LDC_STATE_BOUND ) ; if ( lp -> cfg . mode == LDC_MODE_RAW ) { lp -> hs_state = LDC_HS_COMPLETE ; } spin_unlock_irqrestore ( & lp -> lock , flags ) ; return 0 ; out_unmap_rx lp -> flags &= ~ LDC_FLAG_REGISTERED_QUEUES ; sun4v_ldc_rx_qconf ( lp -> id , 0 , 0 ) ; out_unmap_tx sun4v_ldc_tx_qconf ( lp -> id , 0 , 0 ) ; out_free_irqs lp -> flags &= ~ LDC_FLAG_REGISTERED_IRQS ; free_irq ( lp -> cfg . tx_irq , lp ) ; free_irq ( lp -> cfg . rx_irq , lp ) ; spin_unlock_irqrestore ( & lp -> lock , flags ) ; return err ; } 