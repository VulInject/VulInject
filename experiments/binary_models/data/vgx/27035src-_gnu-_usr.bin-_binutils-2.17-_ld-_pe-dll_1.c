process_def_file ( , ) { int i , j ; struct bfd_link_hash_entry * blhe ; bfd * b ; struct bfd_section * s ; def_file_export * e = 0 ; if ( ! pe_def_file ) { pe_def_file = def_file_empty ( ) ; } for ( b = info -> input_bfds ; b ; b = b -> link_next ) { s = bfd_get_section_by_name ( b , ".drectve" ) ; if ( s ) { long size = s -> size ; char * buf = xmalloc ( size ) ; bfd_get_section_contents ( b , s , buf , 0 , size ) ; def_file_add_directive ( pe_def_file , buf , size ) ; free ( buf ) ; } } if ( ! pe_dll_export_everything && pe_def_file -> num_exports == 0 && info -> executable ) { return ; } if ( pe_dll_export_everything || pe_def_file -> num_exports == 0 ) { for ( b = info -> input_bfds ; b ; b = b -> link_next ) { asymbol * * symbols ; int nsyms , symsize ; symsize = bfd_get_symtab_upper_bound ( b , NULL ) ; symbols = xmalloc ( symsize ) ; nsyms = bfd_canonicalize_symtab ( b , symbols ) ; for ( j = 0 ; j < nsyms ; j ++ ) { if ( symbols [ j ] -> section != & bfd_und_section && ( ( symbols [ j ] -> flags & BSF_GLOBAL ) || ( symbols [ j ] -> flags == BFD_FORT_COMM_DEFAULT_VALUE ) ) ) { const char * sn = symbols [ j ] -> name ; { char * name = xmalloc ( strlen ( sn ) + 2 + 6 ) ; sprintf ( name , "%s%s" , U ( "_imp_" ) , sn ) ; blhe = bfd_link_hash_lookup ( info -> hash , name , FALSE , FALSE , FALSE ) ; free ( name ) ; if ( blhe && blhe -> type == bfd_link_hash_defined ) { continue ; } } if ( * sn == '_' ) { sn ++ ; } if ( auto_export ( b , pe_def_file , sn ) ) { def_file_export * p ; p = def_file_add_export ( pe_def_file , sn , 0 , - 1 ) ; p -> flag_data = ! ( symbols [ j ] -> flags & BSF_FUNCTION ) ; } } } } } if ( pe_dll_kill_ats ) { for ( i = 0 ; i < NE ; i ++ ) { if ( strchr ( pe_def_file -> exports [ i ] . name , '@' ) ) { int lead_at = ( * pe_def_file -> exports [ i ] . name == '@' ) ; char * tmp = xstrdup ( pe_def_file -> exports [ i ] . name + lead_at ) ; char * tmp_at = strchr ( tmp , '@' ) ; if ( tmp_at ) { * tmp_at = 0 ; } else { einfo ( _ ( "%XCannot export %s: invalid export name\n" ) , pe_def_file -> exports [ i ] . name ) ; } pe_def_file -> exports [ i ] . name = tmp ; } } } if ( pe_dll_stdcall_aliases ) { for ( i = 0 ; i < NE ; i ++ ) { if ( strchr ( pe_def_file -> exports [ i ] . name , '@' ) ) { int lead_at = ( * pe_def_file -> exports [ i ] . name == '@' ) ; char * tmp = xstrdup ( pe_def_file -> exports [ i ] . name + lead_at ) ; * ( strchr ( tmp , '@' ) ) = 0 ; if ( auto_export ( NULL , pe_def_file , tmp ) ) { def_file_add_export ( pe_def_file , tmp , pe_def_file -> exports [ i ] . internal_name , - 1 ) ; } else { free ( tmp ) ; } } } } e = pe_def_file -> exports ; exported_symbol_offsets = xmalloc ( NE * sizeof ( bfd_vma ) ) ; exported_symbol_sections = xmalloc ( NE * sizeof ( bfd_section * ) ) ; memset ( exported_symbol_sections , 0 , NE * sizeof ( bfd_section * ) ) ; max_ordinal = 0 ; min_ordinal = 65536 ; count_exported = 0 ; count_exported_byname = 0 ; count_with_ordinals = 0 ; qsort ( pe_def_file -> exports , NE , sizeof ( pe_def_file -> exports [ 0 ] ) , pe_export_sort ) ; for ( i = 0 , j = 0 ; i < NE ; i ++ ) { if ( i > 0 && strcmp ( e [ i ] . name , e [ i - 1 ] . name ) == 0 ) { if ( e [ j - 1 ] . ordinal != - 1 && e [ i ] . ordinal != - 1 && e [ j - 1 ] . ordinal != e [ i ] . ordinal ) { if ( pe_dll_warn_dup_exports ) { einfo ( _ ( "%XError, duplicate EXPORT with ordinals: %s (%d vs %d)\n" ) , e [ j - 1 ] . name , e [ j - 1 ] . ordinal , e [ i ] . ordinal ) ; } } else { if ( pe_dll_warn_dup_exports ) { einfo ( _ ( "Warning, duplicate EXPORT: %s\n" ) , e [ j - 1 ] . name ) ; } } if ( e [ i ] . ordinal != - 1 ) { e [ j - 1 ] . ordinal = e [ i ] . ordinal ; } e [ j - 1 ] . flag_private |= e [ i ] . flag_private ; e [ j - 1 ] . flag_constant |= e [ i ] . flag_constant ; e [ j - 1 ] . flag_noname |= e [ i ] . flag_noname ; e [ j - 1 ] . flag_data |= e [ i ] . flag_data ; } else { if ( i != j ) { e [ j ] = e [ i ] ; } j ++ ; } } pe_def_file -> num_exports = j ; for ( i = 0 ; i < NE ; i ++ ) { char * name ; if ( strchr ( pe_def_file -> exports [ i ] . internal_name , '.' ) ) { count_exported ++ ; if ( ! pe_def_file -> exports [ i ] . flag_noname ) { count_exported_byname ++ ; } pe_def_file -> exports [ i ] . flag_forward = 1 ; if ( pe_def_file -> exports [ i ] . ordinal != - 1 ) { if ( max_ordinal < pe_def_file -> exports [ i ] . ordinal ) { max_ordinal = pe_def_file -> exports [ i ] . ordinal ; } if ( min_ordinal > pe_def_file -> exports [ i ] . ordinal ) { min_ordinal = pe_def_file -> exports [ i ] . ordinal ; } count_with_ordinals ++ ; } continue ; } name = xmalloc ( strlen ( pe_def_file -> exports [ i ] . internal_name ) + 2 ) ; if ( pe_details -> underscored && ( * pe_def_file -> exports [ i ] . internal_name != '@' ) ) { * name = '_' ; strcpy ( name + 1 , pe_def_file -> exports [ i ] . internal_name ) ; } else { strcpy ( name , pe_def_file -> exports [ i ] . internal_name ) ; } blhe = bfd_link_hash_lookup ( info -> hash , name , FALSE , FALSE , TRUE ) ; if ( blhe && ( blhe -> type == bfd_link_hash_defined || ( blhe -> type == bfd_link_hash_common ) ) ) { count_exported ++ ; if ( ! pe_def_file -> exports [ i ] . flag_noname ) { count_exported_byname ++ ; } if ( blhe -> type == bfd_link_hash_defined ) { exported_symbol_sections [ i ] = blhe -> u . def . section ; } else { exported_symbol_sections [ i ] = blhe -> u . c . p -> section ; } if ( pe_def_file -> exports [ i ] . ordinal != - 1 ) { if ( max_ordinal < pe_def_file -> exports [ i ] . ordinal ) { max_ordinal = pe_def_file -> exports [ i ] . ordinal ; } if ( min_ordinal > pe_def_file -> exports [ i ] . ordinal ) { min_ordinal = pe_def_file -> exports [ i ] . ordinal ; } count_with_ordinals ++ ; } } if ( blhe && blhe -> type == bfd_link_hash_undefined ) { einfo ( _ ( "%XCannot export %s: symbol not defined\n" ) , pe_def_file -> exports [ i ] . internal_name ) ; } if ( blhe ) { einfo ( _ ( "%XCannot export %s: symbol wrong type (%d vs %d)\n" ) , pe_def_file -> exports [ i ] . internal_name , blhe -> type , bfd_link_hash_defined ) ; } else { einfo ( _ ( "%XCannot export %s: symbol not found\n" ) , pe_def_file -> exports [ i ] . internal_name ) ; } free ( name ) ; } } 