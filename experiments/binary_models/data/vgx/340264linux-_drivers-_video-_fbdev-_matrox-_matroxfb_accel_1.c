static void matroxfb_fillrect ( struct fb_info * info , const struct fb_fillrect * rect ) static void matroxfb_imageblit ( struct fb_info * info , const struct fb_image * image ) static void matroxfb_cfb4_fillrect ( struct fb_info * info , const struct fb_fillrect * rect ) static void matroxfb_cfb4_copyarea ( struct fb_info * info , const struct fb_copyarea * area ) void matrox_cfbX_init ( struct matrox_fb_info * minfo ) { u_int32_t maccess ; u_int32_t mpitch ; u_int32_t mopmode ; int accel ; DBG ( ) mpitch = minfo -> fbcon . var . xres_virtual ; minfo -> fbops . fb_copyarea = cfb_copyarea ; minfo -> fbops . fb_fillrect = cfb_fillrect ; minfo -> fbops . fb_imageblit = cfb_imageblit ; accel = ( minfo -> fbcon . var . accel_flags & FB_ACCELF_TEXT ) == FB_ACCELF_TEXT ; switch ( minfo -> fbcon . var . bits_per_pixel ) { case 4 : maccess = 0x00000000 ; mpitch = ( mpitch >> 1 ) | 0x8000 ; mopmode = M_OPMODE_4BPP ; matrox_cfb4_pal ( minfo -> cmap ) ; if ( accel && ! ( mpitch & 1 ) ) { minfo -> fbops . fb_copyarea = matroxfb_cfb4_copyarea ; minfo -> fbops . fb_fillrect = matroxfb_cfb4_fillrect ; } break ; case 8 : maccess = 0x00000000 ; mopmode = M_OPMODE_8BPP ; matrox_cfb8_pal ( minfo -> cmap ) ; if ( accel ) { minfo -> fbops . fb_copyarea = matroxfb_copyarea ; minfo -> fbops . fb_fillrect = matroxfb_fillrect ; minfo -> fbops . fb_imageblit = matroxfb_imageblit ; } break ; case 16 : if ( minfo -> fbcon . var . green . length == 5 ) { maccess = 0xC0000001 ; } else { maccess = 0x40000001 ; } mopmode = M_OPMODE_16BPP ; if ( accel ) { minfo -> fbops . fb_copyarea = matroxfb_copyarea ; minfo -> fbops . fb_fillrect = matroxfb_fillrect ; minfo -> fbops . fb_imageblit = matroxfb_imageblit ; } break ; case 24 : maccess = 0x00000003 ; mopmode = M_OPMODE_24BPP ; if ( accel ) { minfo -> fbops . fb_copyarea = matroxfb_copyarea ; minfo -> fbops . fb_fillrect = matroxfb_fillrect ; minfo -> fbops . fb_imageblit = matroxfb_imageblit ; } break ; case 32 : maccess = 0x00000002 ; mopmode = M_OPMODE_32BPP ; if ( accel ) { minfo -> fbops . fb_copyarea = matroxfb_copyarea ; minfo -> fbops . fb_fillrect = matroxfb_fillrect ; minfo -> fbops . fb_imageblit = matroxfb_imageblit ; } break ; default : maccess = 0x00000000 ; mopmode = 0x00000000 ; break ; } mga_fifo ( 8 ) ; mga_outl ( M_PITCH , mpitch ) ; mga_outl ( M_YDSTORG , curr_ydstorg ( minfo ) ) ; if ( minfo -> capable . plnwt ) { mga_outl ( M_PLNWT , - 1 ) ; } if ( minfo -> capable . srcorg ) { mga_outl ( M_SRCORG , 0 ) ; mga_outl ( M_DSTORG , 0 ) ; } mga_outl ( M_OPMODE , mopmode ) ; mga_outl ( M_CXBNDRY , 0xFFFF0000 ) ; mga_outl ( M_YTOP , 0 ) ; mga_outl ( M_YBOT , 0x01FFFFFF ) ; mga_outl ( M_MACCESS , maccess ) ; minfo -> accel . m_dwg_rect = M_DWG_TRAP | M_DWG_SOLID | M_DWG_ARZERO | M_DWG_SGNZERO | M_DWG_SHIFTZERO ; if ( isMilleniumII ( minfo ) ) { minfo -> accel . m_dwg_rect |= M_DWG_TRANSC ; } minfo -> accel . m_opmode = mopmode ; minfo -> accel . m_access = maccess ; minfo -> accel . m_pitch = mpitch ; } 