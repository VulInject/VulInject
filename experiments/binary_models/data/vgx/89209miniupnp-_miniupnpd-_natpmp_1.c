void SendNATPMPPublicAddressChangeNotification ( int * sockets , int n_sockets ) { struct sockaddr_in sockname ; unsigned char notif [ 12 ] ; int j , n ; notif [ 0 ] = 0 ; notif [ 1 ] = 128 ; notif [ 2 ] = 0 ; notif [ 3 ] = 0 ; if ( epoch_origin == 0 ) { epoch_origin = startup_time ; } WRITENU32 ( notif + 4 , upnp_time ( ) - epoch_origin ) ; FillPublicAddressResponse ( notif , 0 ) ; if ( notif [ 3 ] ) { syslog ( LOG_WARNING , "%s: cannot get public IP address, stopping" , "SendNATPMPPublicAddressChangeNotification" ) ; return ; } memset ( & sockname , 0 , sizeof ( sockaddr_in ) ) ; sockname . sin_family = AF_INET ; sockname . sin_addr . s_addr = inet_addr ( NATPMP_NOTIF_ADDR , NULL ) ; for ( j = 0 ; j < n_sockets ; j ++ ) { if ( sockets [ j ] < 0 ) { continue ; } { struct lan_addr_s * lan_addr = lan_addrs . lh_first ; int i ; for ( i = 0 ; i < j ; i ++ ) { lan_addr = lan_addr -> list . le_next ; } FillPublicAddressResponse ( notif , lan_addr -> addr . s_addr ) ; } sockname . sin_port = htons ( NATPMP_PORT ) ; n = sendto_or_schedule ( sockets [ j ] , notif , 12 , 0 , ( sockaddr * ) & sockname , sizeof ( sockaddr_in ) ) ; if ( n < 0 ) { syslog ( LOG_ERR , "%s: sendto(s_udp=%d, port=%d): %m" , "SendNATPMPPublicAddressChangeNotification" , sockets [ j ] , NATPMP_PORT ) ; return ; } sockname . sin_port = htons ( NATPMP_NOTIF_PORT ) ; n = sendto_or_schedule ( sockets [ j ] , notif , 12 , 0 , ( sockaddr * ) & sockname , sizeof ( sockaddr_in ) ) ; if ( n < 0 ) { syslog ( LOG_ERR , "%s: sendto(s_udp=%d, port=%d): %m" , "SendNATPMPPublicAddressChangeNotification" , sockets [ j ] , NATPMP_NOTIF_PORT ) ; return ; } } } 