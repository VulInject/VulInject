void report_untranslatable_char ( int src_encoding , int dest_encoding , const char * mbstr , int len ) { int l = pg_encoding_mblen ( src_encoding , mbstr ) ; char buf [ 8 * 5 + 1 ] ; char * p = buf ; int j , jlimit ; jlimit = Min ( l , len ) ; jlimit = Min ( jlimit , 8 ) ; for ( j = 0 ; j < jlimit ; j ++ ) { p += sprintf ( p , "0x%02x" , ( unsigned char ) mbstr [ j ] ) ; if ( j < jlimit - 1 ) { p += sprintf ( p , " " ) ; } } ereport ( ERROR , ( errcode ( ERRCODE_UNTRANSLATABLE_CHARACTER ) , errmsg ( "character with byte sequence %s in encoding \"%s\" has no equivalent in encoding \"%s\"" , buf , pg_enc2name_tbl [ src_encoding ] . name , pg_enc2name_tbl [ dest_encoding ] . name ) ) ) ; } WCHAR * pgwin32_message_to_UTF16 ( const char * str , int len , int * utf16len ) { int msgenc = GetMessageEncoding ( ) ; WCHAR * utf16 ; int dstlen ; UINT codepage ; if ( msgenc == PG_SQL_ASCII ) { return NULL ; } codepage = pg_enc2name_tbl [ msgenc ] . codepage ; if ( codepage != 0 ) { utf16 = ( WCHAR * ) palloc ( sizeof ( WCHAR ) * ( len + 1 ) ) ; dstlen = MultiByteToWideChar ( codepage , 0 , str , len , utf16 , len ) ; utf16 [ dstlen ] = ( WCHAR ) 0 ; } else { char * utf8 ; if ( IsTransactionState ( ) ) { utf8 = ( char * ) pg_do_encoding_conversion ( ( unsigned char * ) str , len , msgenc , PG_UTF8 ) ; if ( utf8 != str ) { len = strlen ( utf8 ) ; } } else { utf8 = ( char * ) str ; } utf16 = ( WCHAR * ) palloc ( sizeof ( WCHAR ) * ( len + 1 ) ) ; dstlen = MultiByteToWideChar ( CP_UTF8 , 0 , utf8 , len , utf16 , len ) ; utf16 [ dstlen ] = ( WCHAR ) 0 ; if ( utf8 != str ) { pfree ( utf8 ) ; } } if ( dstlen == 0 && len > 0 ) { return NULL ; } if ( utf16len ) { * utf16len = dstlen ; } return utf16 ; } 