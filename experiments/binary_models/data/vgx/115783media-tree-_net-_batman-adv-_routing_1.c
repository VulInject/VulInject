int batadv_recv_bcast_packet ( struct sk_buff * skb , struct batadv_hard_iface * recv_if ) { struct batadv_priv * bat_priv = netdev_priv ( recv_if -> soft_iface ) ; struct batadv_orig_node * orig_node = NULL ; struct batadv_bcast_packet * bcast_packet ; struct ethhdr * ethhdr ; int hdr_size = sizeof ( * bcast_packet ) ; int ret = NET_RX_DROP ; s32 seq_diff ; u32 seqno ; ethhdr = eth_hdr ( skb ) ; if ( ! is_broadcast_ether_addr ( ethhdr -> h_dest ) ) { free_skb } if ( is_multicast_ether_addr ( ethhdr -> h_source ) ) { free_skb } if ( batadv_is_my_mac ( bat_priv , ethhdr -> h_source ) ) { free_skb } bcast_packet = ( batadv_bcast_packet * ) skb -> data ; if ( batadv_is_my_mac ( bat_priv , bcast_packet -> orig ) ) { free_skb } if ( bcast_packet -> ttl < 2 ) { free_skb } orig_node = batadv_orig_hash_find ( bat_priv , bcast_packet -> orig ) ; if ( ! orig_node ) { free_skb } spin_lock_bh ( & orig_node -> bcast_seqno_lock ) ; seqno = ntohl ( bcast_packet -> seqno ) ; if ( batadv_test_bit ( orig_node -> bcast_bits , orig_node -> last_bcast_seqno , seqno ) ) { spin_unlock } seq_diff = seqno - orig_node -> last_bcast_seqno ; if ( batadv_window_protected ( bat_priv , seq_diff , BATADV_BCAST_MAX_AGE , & orig_node -> bcast_seqno_reset , NULL ) ) { spin_unlock } if ( batadv_bit_get_packet ( bat_priv , orig_node -> bcast_bits , seq_diff , 1 ) ) { orig_node -> last_bcast_seqno = seqno ; } spin_unlock_bh ( & orig_node -> bcast_seqno_lock ) ; if ( batadv_bla_check_bcast_duplist ( bat_priv , skb ) ) { free_skb } batadv_skb_set_priority ( skb , sizeof ( batadv_bcast_packet ) ) ; batadv_add_bcast_packet_to_list ( bat_priv , skb , 1 , false ) ; if ( batadv_bla_is_backbone_gw ( skb , orig_node , hdr_size ) ) { free_skb } if ( batadv_dat_snoop_incoming_arp_request ( bat_priv , skb , hdr_size ) ) { rx_success } if ( batadv_dat_snoop_incoming_arp_reply ( bat_priv , skb , hdr_size ) ) { rx_success } batadv_interface_rx ( recv_if -> soft_iface , skb , hdr_size , orig_node ) ; rx_success ret = NET_RX_SUCCESS ; out spin_unlock spin_unlock_bh ( & orig_node -> bcast_seqno_lock ) ; free_skb kfree_skb ( skb ) ; out if ( orig_node ) { batadv_orig_node_put ( orig_node ) ; } return ret ; } 