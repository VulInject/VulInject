static void * worker_thread ( void * __tdata ) { struct thread_data * td = __tdata ; struct timeval start0 , start , stop , diff ; int process_nr = td -> process_nr ; int thread_nr = td -> thread_nr ; unsigned long last_perturbance ; int task_nr = td -> task_nr ; int details = g -> p . show_details ; int first_task , last_task ; double convergence = 0 ; u64 val = td -> val ; double runtime_ns_max ; u8 * global_data ; u8 * process_data ; u8 * thread_data ; u64 bytes_done ; long work_done ; u32 l ; struct rusage rusage ; bind_to_cpumask ( td -> bind_cpumask ) ; bind_to_memnode ( td -> bind_node ) ; set_taskname ( "thread %d/%d" , process_nr , thread_nr ) ; global_data = g -> data ; process_data = td -> process_data ; thread_data = setup_private_data ( g -> p . bytes_thread ) ; bytes_done = 0 ; last_task = 0 ; if ( process_nr == g -> p . nr_proc - 1 && thread_nr == g -> p . nr_threads - 1 ) { last_task = 1 ; } first_task = 0 ; if ( process_nr == 0 && thread_nr == 0 ) { first_task = 1 ; } if ( details >= 2 ) { printf ( "#  thread %2d / %2d global mem: %p, process mem: %p, thread mem: %p\n" , process_nr , thread_nr , global_data , process_data , thread_data ) ; } if ( g -> p . serialize_startup ) { pthread_mutex_lock ( & g -> startup_mutex ) ; g -> nr_tasks_started ++ ; pthread_mutex_unlock ( & g -> startup_mutex ) ; pthread_mutex_lock ( & g -> start_work_mutex ) ; g -> nr_tasks_working ++ ; if ( g -> nr_tasks_working == g -> p . nr_tasks ) { pthread_mutex_unlock ( & g -> startup_done_mutex ) ; } pthread_mutex_unlock ( & g -> start_work_mutex ) ; } gettimeofday ( & start0 , NULL ) ; start = stop = start0 ; last_perturbance = start . tv_sec ; for ( l = 0 ; l < g -> p . nr_loops ; l ++ ) { start = stop ; if ( g -> stop_work ) { break ; } val += do_work ( global_data , g -> p . bytes_global , process_nr , g -> p . nr_proc , l , val ) ; val += do_work ( process_data , g -> p . bytes_process , thread_nr , g -> p . nr_threads , l , val ) ; val += do_work ( thread_data , g -> p . bytes_thread , 0 , 1 , l , val ) ; if ( g -> p . sleep_usecs ) { usleep ( g -> p . sleep_usecs ) ; pthread_mutex_unlock ( td -> process_lock ) ; } if ( g -> p . bytes_process_locked ) { pthread_mutex_lock ( td -> process_lock ) ; val += do_work ( process_data , g -> p . bytes_process_locked , thread_nr , g -> p . nr_threads , l , val ) ; pthread_mutex_unlock ( td -> process_lock ) ; } work_done = g -> p . bytes_global + g -> p . bytes_process + g -> p . bytes_process_locked + g -> p . bytes_thread ; update_curr_cpu ( task_nr , work_done ) ; bytes_done += work_done ; if ( details < 0 && ! g -> p . perturb_secs && ! g -> p . measure_convergence && ! g -> p . nr_secs ) { continue ; } td -> loops_done = l ; gettimeofday ( & stop , NULL ) ; if ( g -> p . nr_secs ) { timersub ( & stop , & start0 , & diff ) ; if ( ( u32 ) diff . tv_sec >= g -> p . nr_secs ) { g -> stop_work = true ; break ; } } if ( start . tv_sec == stop . tv_sec ) { continue ; } if ( first_task && g -> p . perturb_secs && ( int ) ( stop . tv_sec - last_perturbance ) >= g -> p . perturb_secs ) { cpu_set_t orig_mask ; int target_cpu ; int this_cpu ; last_perturbance = stop . tv_sec ; this_cpu = g -> threads [ task_nr ] . curr_cpu ; if ( this_cpu < g -> p . nr_cpus / 2 ) { target_cpu = g -> p . nr_cpus - 1 ; } else { target_cpu = 0 ; } orig_mask = bind_to_cpu ( target_cpu ) ; if ( details >= 1 ) { printf ( " (injecting perturbalance, moved to CPU#%d)\n" , target_cpu ) ; } bind_to_cpumask ( orig_mask ) ; } if ( details >= 3 ) { timersub ( & stop , & start , & diff ) ; runtime_ns_max = diff . tv_sec * NSEC_PER_SEC ; runtime_ns_max += diff . tv_usec * NSEC_PER_USEC ; if ( details >= 0 ) { printf ( " #%2d / %2d: %14.2lf nsecs/op [val: %016" PRIx64 "]\n" , process_nr , thread_nr , runtime_ns_max / bytes_done , val ) ; } fflush ( stdout ) ; } if ( ! last_task ) { continue ; } timersub ( & stop , & start0 , & diff ) ; runtime_ns_max = diff . tv_sec * NSEC_PER_SEC ; runtime_ns_max += diff . tv_usec * NSEC_PER_USEC ; show_summary ( runtime_ns_max , l , & convergence ) ; } gettimeofday ( & stop , NULL ) ; timersub ( & stop , & start0 , & diff ) ; td -> runtime_ns = diff . tv_sec * NSEC_PER_SEC ; td -> runtime_ns += diff . tv_usec * NSEC_PER_USEC ; td -> speed_gbs = bytes_done / ( td -> runtime_ns / NSEC_PER_SEC ) / 1e9 ; getrusage ( RUSAGE_THREAD , & rusage ) ; td -> system_time_ns = rusage . ru_stime . tv_sec * NSEC_PER_SEC ; td -> system_time_ns += rusage . ru_stime . tv_usec * NSEC_PER_USEC ; td -> user_time_ns = rusage . ru_utime . tv_sec * NSEC_PER_SEC ; td -> user_time_ns += rusage . ru_utime . tv_usec * NSEC_PER_USEC ; free_data ( thread_data , g -> p . bytes_thread ) ; pthread_mutex_lock ( & g -> stop_work_mutex ) ; g -> bytes_done += bytes_done ; pthread_mutex_unlock ( & g -> stop_work_mutex ) ; return NULL ; } 