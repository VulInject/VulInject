static int ql_set_nvram_adapter_defaults ( ql_adapter_state_t * ha ) { int rval ; uint32_t count ; uint32_t start_addr ; QL_PRINT_9 ( CE_CONT , "(%d): started\n" , ha -> instance ) ; rval = ql_lock_nvram ( ha , & start_addr , LNF_NVRAM_DATA ) ; if ( rval != QL_SUCCESS ) { EL ( ha , "failed, ql_lock_nvram=%xh\n" , rval ) ; return ( EIO ) ; } rval = 0 ; if ( CFG_IST ( ha , CFG_CTRL_24258081 ) ) { nvram_24xx_t * nv ; uint32_t * longptr ; int csum = 0 ; nv = kmem_zalloc ( sizeof ( * nv ) , KM_SLEEP ) ; if ( nv == NULL ) { EL ( ha , "failed, kmem_zalloc\n" ) ; return ( ENOMEM ) ; } nv -> nvram_version [ 0 ] = LSB ( ICB_24XX_VERSION ) ; nv -> nvram_version [ 1 ] = MSB ( ICB_24XX_VERSION ) ; nv -> version [ 0 ] = 1 ; nv -> max_frame_length [ 1 ] = 8 ; nv -> execution_throttle [ 0 ] = 16 ; nv -> login_retry_count [ 0 ] = 8 ; nv -> firmware_options_1 [ 0 ] = BIT_2 | BIT_1 ; nv -> firmware_options_1 [ 1 ] = BIT_5 ; nv -> firmware_options_2 [ 0 ] = BIT_5 ; nv -> firmware_options_2 [ 1 ] = BIT_4 ; nv -> firmware_options_3 [ 1 ] = BIT_6 ; nv -> host_p [ 0 ] = BIT_4 | BIT_1 ; nv -> host_p [ 1 ] = BIT_3 | BIT_2 ; nv -> reset_delay = 5 ; nv -> max_luns_per_target [ 0 ] = 128 ; nv -> port_down_retry_count [ 0 ] = 30 ; nv -> link_down_timeout [ 0 ] = 30 ; longptr = ( uint32_t * ) nv ; csum = 0 ; for ( count = 0 ; count < ( sizeof ( nvram_24xx_t ) / 4 ) - 1 ; count ++ ) { csum += * longptr ; longptr ++ ; } csum = ( uint32_t ) ( ~ csum + 1 ) ; LITTLE_ENDIAN_32 ( ( long ) csum ) ; * longptr = csum ; longptr = ( uint32_t * ) nv ; for ( count = 0 ; count < sizeof ( nvram_24xx_t ) / 4 ; count ++ ) { ( void ) ql_24xx_load_nvram ( ha , ( uint32_t ) ( count + start_addr ) , * longptr ++ ) ; } csum = 0 ; longptr = ( uint32_t * ) nv ; for ( count = 0 ; count < sizeof ( nvram_24xx_t ) / 4 ; count ++ ) { rval = ql_24xx_read_flash ( ha , count + start_addr , longptr ) ; if ( rval != QL_SUCCESS ) { EL ( ha , "24xx_read_flash failed=%xh\n" , rval ) ; break ; } csum += * longptr ; } if ( csum ) { rval = EINVAL ; } kmem_free ( nv , sizeof ( nvram_24xx_t ) ) ; } else { nvram_t * nv ; uint16_t * wptr ; uint8_t * bptr ; uint8_t csum ; nv = kmem_zalloc ( sizeof ( * nv ) , KM_SLEEP ) ; if ( nv == NULL ) { EL ( ha , "failed, kmem_zalloc\n" ) ; return ( ENOMEM ) ; } nv -> parameter_block_version = ICB_VERSION ; nv -> firmware_options [ 0 ] = BIT_4 | BIT_3 | BIT_2 | BIT_1 ; nv -> firmware_options [ 1 ] = BIT_7 | BIT_5 | BIT_2 ; nv -> max_frame_length [ 1 ] = 4 ; nv -> max_iocb_allocation [ 1 ] = 1 ; nv -> execution_throttle [ 0 ] = 16 ; nv -> login_retry_count = 8 ; nv -> port_name [ 0 ] = 33 ; nv -> port_name [ 3 ] = 224 ; nv -> port_name [ 4 ] = 139 ; nv -> login_timeout = 4 ; nv -> host_p [ 0 ] = BIT_1 ; nv -> host_p [ 1 ] = BIT_2 ; nv -> reset_delay = 5 ; nv -> port_down_retry_count = 8 ; nv -> maximum_luns_per_target [ 0 ] = 8 ; bptr = ( uint8_t * ) nv ; csum = 0 ; for ( count = 0 ; count < sizeof ( nvram_t ) - 1 ; count ++ ) { csum = ( uint8_t ) ( csum + * bptr ++ ) ; } csum = ( uint8_t ) ( ~ csum + 1 ) ; nv -> checksum = csum ; wptr = ( uint16_t * ) nv ; for ( count = 0 ; count < sizeof ( nvram_t ) / 2 ; count ++ ) { ql_load_nvram ( ha , ( uint8_t ) ( count + start_addr ) , * wptr ++ ) ; } wptr = ( uint16_t * ) nv ; csum = 0 ; for ( count = 0 ; count < sizeof ( nvram_t ) / 2 ; count ++ ) { if ( ql_get_nvram_word ( ha , count + start_addr ) != * wptr ) { rval = EIO ; break ; } csum = ( uint8_t ) ( csum + ( uint8_t ) * wptr ) ; csum = ( uint8_t ) ( csum + ( uint8_t ) ( * wptr >> 8 ) ) ; wptr ++ ; } if ( csum ) { rval = EINVAL ; } kmem_free ( nv , sizeof ( * nv ) ) ; } ql_release_nvram ( ha ) ; QL_PRINT_9 ( CE_CONT , "(%d): done\n" , ha -> instance ) ; return ( rval ) ; } 