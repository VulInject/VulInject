static int64_t icarus_scanhash ( struct thr_info * thr , struct work * work , __maybe_unused int64_t max_nonce ) { struct cgpu_info * icarus ; int fd ; int ret ; struct ICARUS_INFO * info ; struct work * nonce_work ; int64_t hash_count ; struct timeval tv_start = { . tv_sec = 0 } , elapsed ; struct timeval tv_history_start , tv_history_finish ; struct timeval tv_now , tv_timeout ; double Ti , Xi ; int i ; bool was_hw_error = false ; bool was_first_run ; struct ICARUS_HISTORY * history0 , * history ; int count ; double Hs , W , fullnonce ; int read_timeout_ms ; bool limited ; uint32_t values ; int64_t hash_count_range ; elapsed . tv_sec = elapsed . tv_usec = 0 ; icarus = thr -> cgpu ; struct icarus_state * state = thr -> cgpu_data ; was_first_run = state -> firstrun ; icarus -> drv -> job_prepare ( thr , work , max_nonce ) ; fd = icarus -> device_fd ; info = icarus -> device_data ; unsigned char nonce_bin [ info -> read_size ] ; uint32_t nonce ; if ( unlikely ( fd == - 1 ) && ! icarus_reopen ( icarus , state , & fd ) ) { return - 1 ; } if ( ! state -> firstrun ) { if ( state -> changework ) { state -> changework = false ; ret = ICA_GETS_RESTART ; } else { read_timeout_ms = info -> read_timeout_ms ; keepwaiting timer_set_now ( & tv_now ) ; timer_set_delay ( & tv_timeout , & tv_now , read_timeout_ms * 1000 ) ; ret = icarus_read ( icarus -> dev_repr , nonce_bin , fd , & state -> tv_workfinish , thr , & tv_timeout , & tv_now , info -> read_size ) ; switch ( ret ) { case ICA_GETS_RESTART : state -> changework = true ; return 0 ; case ICA_GETS_ERROR : do_icarus_close ( thr ) ; applog ( LOG_ERR , "%s: Comms error (rerr)" , icarus -> dev_repr ) ; dev_error ( icarus , REASON_DEV_COMMS_ERROR ) ; if ( ! icarus_reopen ( icarus , state , & fd ) ) { return - 1 ; } break ; case ICA_GETS_TIMEOUT : if ( info -> reopen_mode == IRM_TIMEOUT && ! icarus_reopen ( icarus , state , & fd ) ) { return - 1 ; } case ICA_GETS_OK : break ; } } tv_start = state -> tv_workstart ; timersub ( & state -> tv_workfinish , & tv_start , & elapsed ) ; } else { if ( fd == - 1 && ! icarus_reopen ( icarus , state , & fd ) ) { return - 1 ; } ret = ICA_GETS_ERROR ; } tcflush ( fd , TCOFLUSH ) ; if ( ret == ICA_GETS_OK ) { memcpy ( & nonce , nonce_bin , sizeof ( nonce ) ) ; nonce_work = icarus_process_worknonce ( info , state , & nonce ) ; if ( likely ( nonce_work ) ) { if ( nonce_work == state -> last2_work ) { submit_nonce ( icarus_proc_for_nonce ( icarus , nonce ) -> thr [ 0 ] , nonce_work , nonce ) ; keepwaiting } if ( info -> continue_search ) { read_timeout_ms = info -> read_timeout_ms - ( ( timer_elapsed_us ( & state -> tv_workstart , NULL ) / 1000 ) + 1 ) ; if ( read_timeout_ms ) { submit_nonce ( icarus_proc_for_nonce ( icarus , nonce ) -> thr [ 0 ] , nonce_work , nonce ) ; keepwaiting } } } else { was_hw_error = true ; } } if ( info -> dclk . freqM && likely ( ret == ICA_GETS_OK || ret == ICA_GETS_TIMEOUT ) ) { int qsec = ( ( 4 * elapsed . tv_sec ) + ( elapsed . tv_usec / 250000 ) ) ?: 1 ; for ( int n = qsec ; n ; -- n ) { dclk_gotNonces ( & info -> dclk ) ; } if ( was_hw_error ) { dclk_errorCount ( & info -> dclk , qsec ) ; } } if ( was_hw_error || info -> reopen_now ) { info -> reopen_now = false ; if ( info -> reopen_mode == IRM_CYCLE ) { } if ( ! icarus_reopen ( icarus , state , & fd ) ) { state -> firstrun = true ; } } if ( unlikely ( state -> identify ) ) { } if ( unlikely ( icarus -> deven != DEV_ENABLED || ! info -> job_start_func ( thr ) ) ) { state -> firstrun = true ; } if ( info -> reopen_mode == IRM_CYCLE && ! icarus_reopen ( icarus , state , & fd ) ) { state -> firstrun = true ; } work -> blk . nonce = 0xffffffff ; if ( ret == ICA_GETS_ERROR ) { state -> firstrun = false ; icarus_transition_work ( state , work ) ; hash_count = 0 ; out } if ( ret == ICA_GETS_OK && ! was_hw_error ) { const struct cgpu_info * const proc = icarus_proc_for_nonce ( icarus , nonce ) ; submit_nonce ( proc -> thr [ 0 ] , nonce_work , nonce ) ; icarus_transition_work ( state , work ) ; hash_count = ( nonce & info -> nonce_mask ) ; hash_count ++ ; hash_count *= info -> fpga_count ; if ( opt_debug ) { const uint64_t elapsed_fs = ( elapsed . tv_sec * 1000000000000000LL ) + ( elapsed . tv_usec * 1000000000LL ) ; const uint64_t est_Hs_fs = elapsed_fs / hash_count ; applog ( LOG_DEBUG , "%" PRIpreprv " nonce = 0x%08x = 0x%08" PRIx64 " hashes (%" PRId64 ".%06lus; %" PRIu64 ".%06luns/hash)" , proc -> proc_repr , nonce , ( uint64_t ) hash_count , ( int64_t ) elapsed . tv_sec , ( unsigned long ) elapsed . tv_usec , ( uint64_t ) ( est_Hs_fs / 1000000LL ) , ( unsigned long ) ( est_Hs_fs % 1000000LL ) ) ; } } else { double estimate_hashes = elapsed . tv_sec ; estimate_hashes += ( ( double ) elapsed . tv_usec ) / 1000000. ; const char * repr = icarus -> dev_repr ; if ( ret == ICA_GETS_OK ) { const struct cgpu_info * const proc = icarus_proc_for_nonce ( icarus , nonce ) ; repr = proc -> proc_repr ; inc_hw_errors ( proc -> thr [ 0 ] , state -> last_work , nonce ) ; estimate_hashes -= ICARUS_READ_TIME ( info -> baud , info -> read_size ) ; } icarus_transition_work ( state , work ) ; estimate_hashes /= info -> Hs ; if ( unlikely ( estimate_hashes > 0xffffffff ) ) { estimate_hashes = 0xffffffff ; } if ( unlikely ( estimate_hashes < 0 ) ) { estimate_hashes = 0 ; } applog ( LOG_DEBUG , "%s %s nonce = 0x%08" PRIx64 " hashes (%" PRId64 ".%06lus)" , repr , ( ret == ICA_GETS_OK ) ?"bad" : "no" , ( uint64_t ) estimate_hashes , ( int64_t ) elapsed . tv_sec , ( unsigned long ) elapsed . tv_usec ) ; hash_count = estimate_hashes ; if ( ret != ICA_GETS_OK ) { out } } if ( info -> do_default_detection && elapsed . tv_sec >= DEFAULT_DETECT_THRESHOLD ) { int MHs = ( double ) hash_count / ( ( double ) elapsed . tv_sec * 1e6 + ( double ) elapsed . tv_usec ) ; -- info -> do_default_detection ; applog ( LOG_DEBUG , "%s: Autodetect device speed: %d MH/s" , icarus -> dev_repr , MHs ) ; if ( MHs <= 370 || MHs > 420 ) { applog ( LOG_WARNING , "%s: Seems too %s to be an Icarus; calibrating with short timing" , icarus -> dev_repr , MHs > 380 ?"fast" : "slow" ) ; info -> timing_mode = MODE_SHORT ; info -> do_icarus_timing = true ; info -> do_default_detection = 0 ; } if ( MHs <= 380 ) { if ( ! info -> do_default_detection ) { applog ( LOG_DEBUG , "%s: Seems to be a real Icarus" , icarus -> dev_repr ) ; info -> read_timeout_ms = info -> fullnonce * 1000 ; if ( info -> read_timeout_ms > 0 ) { -- info -> read_timeout_ms ; } } } if ( MHs <= 420 ) { size_t old_repr_len = strlen ( icarus -> dev_repr ) ; char old_repr [ old_repr_len + 1 ] ; strcpy ( old_repr , icarus -> dev_repr ) ; convert_icarus_to_cairnsmore ( icarus ) ; info -> do_default_detection = 0 ; applog ( LOG_WARNING , "%s: Detected Cairnsmore1 device, upgrading driver to %s" , old_repr , icarus -> dev_repr ) ; } } if ( info -> do_icarus_timing && ! was_hw_error && ( ( nonce & info -> nonce_mask ) > END_CONDITION ) && ( ( nonce & info -> nonce_mask ) < ( info -> nonce_mask & ~ END_CONDITION ) ) ) { cgtime ( & tv_history_start ) ; history0 = & ( info -> history [ 0 ] ) ; if ( history0 -> values == 0 ) { timeradd ( & tv_start , & history_sec , & ( history0 -> finish ) ) ; } Ti = ( double ) ( elapsed . tv_sec ) + ( ( double ) ( elapsed . tv_usec ) ) / ( ( double ) 1000000 ) - ( ( double ) ICARUS_READ_TIME ( info -> baud , info -> read_size ) ) ; Xi = ( double ) hash_count ; history0 -> sumXiTi += Xi * Ti ; history0 -> sumXi += Xi ; history0 -> sumTi += Ti ; history0 -> sumXi2 += Xi * Xi ; history0 -> values ++ ; if ( history0 -> hash_count_max < hash_count ) { history0 -> hash_count_max = hash_count ; } if ( history0 -> hash_count_min > hash_count || history0 -> hash_count_min == 0 ) { history0 -> hash_count_min = hash_count ; } if ( history0 -> values >= info -> min_data_count && timercmp ( & tv_start , & ( history0 -> finish ) , > ) ) { for ( i = INFO_HISTORY ; i > 0 ; i -- ) { memcpy ( & ( info -> history [ i ] ) , & ( info -> history [ i - 1 ] ) , sizeof ( ICARUS_HISTORY ) ) ; } memset ( history0 , 0 , sizeof ( ICARUS_HISTORY ) ) ; count = 0 ; for ( i = 1 ; i <= INFO_HISTORY ; i ++ ) { history = & ( info -> history [ i ] ) ; if ( history -> values >= MIN_DATA_COUNT ) { count ++ ; history0 -> sumXiTi += history -> sumXiTi ; history0 -> sumXi += history -> sumXi ; history0 -> sumTi += history -> sumTi ; history0 -> sumXi2 += history -> sumXi2 ; history0 -> values += history -> values ; if ( history0 -> hash_count_max < history -> hash_count_max ) { history0 -> hash_count_max = history -> hash_count_max ; } if ( history0 -> hash_count_min > history -> hash_count_min || history0 -> hash_count_min == 0 ) { history0 -> hash_count_min = history -> hash_count_min ; } } } Hs = ( history0 -> values * history0 -> sumXiTi - history0 -> sumXi * history0 -> sumTi ) / ( history0 -> values * history0 -> sumXi2 - history0 -> sumXi * history0 -> sumXi ) ; W = history0 -> sumTi / history0 -> values - Hs * history0 -> sumXi / history0 -> values ; hash_count_range = history0 -> hash_count_max - history0 -> hash_count_min ; values = history0 -> values ; memset ( history0 , 0 , sizeof ( ICARUS_HISTORY ) ) ; fullnonce = W + Hs * ( ( ( double ) 0xffffffff ) + 1 ) ; read_timeout_ms = fullnonce * 1000 ; if ( read_timeout_ms > 0 ) { -- read_timeout_ms ; } if ( info -> read_count_limit > 0 && read_timeout_ms > info -> read_count_limit * 100 ) { read_timeout_ms = info -> read_count_limit * 100 ; limited = true ; } else { limited = false ; } info -> Hs = Hs ; info -> read_timeout_ms = read_timeout_ms ; info -> fullnonce = fullnonce ; info -> count = count ; info -> W = W ; info -> values = values ; info -> hash_count_range = hash_count_range ; if ( info -> min_data_count < MAX_MIN_DATA_COUNT ) { info -> min_data_count *= 2 ; } if ( info -> timing_mode == MODE_SHORT ) { info -> do_icarus_timing = false ; } applog ( LOG_DEBUG , "%s Re-estimate: Hs=%e W=%e read_timeout_ms=%u%s fullnonce=%.3fs" , icarus -> dev_repr , Hs , W , read_timeout_ms , limited ?" (limited)" : "" , fullnonce ) ; } info -> history_count ++ ; cgtime ( & tv_history_finish ) ; timersub ( & tv_history_finish , & tv_history_start , & tv_history_finish ) ; timeradd ( & tv_history_finish , & ( info -> history_time ) , & ( info -> history_time ) ) ; } out if ( unlikely ( state -> identify ) ) { handle_identify ( thr , ret , was_first_run ) ; } int hash_count_per_proc = hash_count / icarus -> procs ; if ( hash_count_per_proc > 0 ) { for_each_managed_proc ( , ) { struct thr_info * const proc_thr = proc -> thr [ 0 ] ; hashes_done2 ( proc_thr , hash_count_per_proc , NULL ) ; hash_count -= hash_count_per_proc ; } } return hash_count ; } 