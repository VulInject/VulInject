static int acpi_video_bus_get_one_device ( struct acpi_device * device , void * arg ) { struct acpi_video_bus * video = arg ; struct acpi_video_device_attrib * attribute ; struct acpi_video_device * data ; unsigned long long device_id ; acpi_status status ; int device_type ; status = acpi_evaluate_integer ( device -> handle , "_ADR" , NULL , & device_id ) ; if ( ACPI_FAILURE ( status ) ) { exit } data = kzalloc ( sizeof ( acpi_video_device ) , GFP_KERNEL ) ; if ( ! data ) { dev_dbg ( & device -> dev , "Cannot attach\n" ) ; return - ENOMEM ; } strcpy ( acpi_device_name ( device ) , ACPI_VIDEO_DEVICE_NAME ) ; strcpy ( acpi_device_class ( device ) , ACPI_VIDEO_CLASS ) ; device -> driver_data = data ; data -> device_id = device_id ; data -> dev = device ; INIT_DELAYED_WORK ( & data -> switch_brightness_work , acpi_video_switch_brightness ) ; attribute = acpi_video_get_device_attr ( video , device_id ) ; if ( attribute && ( attribute -> device_id_scheme || device_id_scheme ) ) { switch ( attribute -> display_type ) { case ACPI_VIDEO_DISPLAY_CRT : data -> flags . crt = 1 ; break ; case ACPI_VIDEO_DISPLAY_TV : data -> flags . tvout = 1 ; break ; case ACPI_VIDEO_DISPLAY_DVI : data -> flags . dvi = 1 ; break ; case ACPI_VIDEO_DISPLAY_LCD : data -> flags . lcd = 1 ; break ; default : data -> flags . unknown = 1 ; break ; } if ( attribute -> bios_can_detect ) { data -> flags . bios = 1 ; } } else { device_type = acpi_video_get_device_type ( video , device_id ) ; switch ( device_type & 0xffe2ffff ) { case ACPI_VIDEO_DISPLAY_LEGACY_MONITOR : data -> flags . crt = 1 ; break ; case ACPI_VIDEO_DISPLAY_LEGACY_PANEL : data -> flags . lcd = 1 ; break ; case ACPI_VIDEO_DISPLAY_LEGACY_TV : data -> flags . tvout = 1 ; break ; default : data -> flags . unknown = 1 ; } } acpi_video_device_bind ( video , data ) ; acpi_video_device_find_cap ( data ) ; if ( data -> cap . _BCM && data -> cap . _BCL ) { may_report_brightness_keys = true ; } mutex_lock ( & video -> device_list_lock ) ; list_add_tail ( & data -> entry , & video -> video_device_list ) ; mutex_unlock ( & video -> device_list_lock ) ; exit video -> child_count ++ ; return 0 ; } 