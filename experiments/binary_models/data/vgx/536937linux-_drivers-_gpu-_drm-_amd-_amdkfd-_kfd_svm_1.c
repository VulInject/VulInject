int svm_range_vram_node_new ( struct amdgpu_device * adev , struct svm_range * prange , bool clear ) { struct amdgpu_bo_param bp ; struct svm_range_bo * svm_bo ; struct amdgpu_bo_user * ubo ; struct amdgpu_bo * bo ; struct kfd_process * p ; struct mm_struct * mm ; int r ; p = container_of ( prange -> svms , kfd_process , svms ) ; pr_debug ( "pasid: %x svms 0x%p [0x%lx 0x%lx]\n" , p -> pasid , prange -> svms , prange -> start , prange -> last ) ; if ( svm_range_validate_svm_bo ( adev , prange ) ) { return 0 ; } svm_bo = svm_range_bo_new ( ) ; if ( ! svm_bo ) { pr_debug ( "failed to alloc svm bo\n" ) ; return - ENOMEM ; } mm = get_task_mm ( p -> lead_thread ) ; if ( ! mm ) { pr_debug ( "failed to get mm\n" ) ; return - ESRCH ; } svm_bo -> eviction_fence = amdgpu_amdkfd_fence_create ( dma_fence_context_alloc ( 1 ) , mm , svm_bo ) ; mmput ( mm ) ; INIT_WORK ( & svm_bo -> eviction_work , svm_range_evict_svm_bo_worker ) ; svm_bo -> evicting = 0 ; memset ( & bp , 0 , sizeof ( bp ) ) ; bp . size = prange -> npages * PAGE_SIZE ; bp . byte_align = PAGE_SIZE ; bp . domain = AMDGPU_GEM_DOMAIN_VRAM ; bp . flags = AMDGPU_GEM_CREATE_NO_CPU_ACCESS ; bp . flags |= clear ?AMDGPU_GEM_CREATE_VRAM_CLEARED : 0 ; bp . flags |= AMDGPU_GEM_CREATE_DISCARDABLE ; bp . type = ttm_bo_type_device ; bp . resv = NULL ; r = amdgpu_bo_create_user ( adev , & bp , & ubo ) ; if ( r ) { pr_debug ( "failed %d to create bo\n" , r ) ; create_bo_failed } bo = & ubo -> bo ; r = amdgpu_bo_reserve ( bo , true ) ; if ( r ) { pr_debug ( "failed %d to reserve bo\n" , r ) ; reserve_bo_failed } if ( clear ) { r = amdgpu_bo_sync_wait ( bo , AMDGPU_FENCE_OWNER_KFD , false ) ; if ( r ) { pr_debug ( "failed %d to sync bo\n" , r ) ; amdgpu_bo_unreserve ( bo ) ; reserve_bo_failed } } r = dma_resv_reserve_fences ( bo -> tbo . base . resv , 1 ) ; if ( r ) { pr_debug ( "failed %d to reserve bo\n" , r ) ; amdgpu_bo_unreserve ( bo ) ; reserve_bo_failed } amdgpu_bo_fence ( bo , & svm_bo -> eviction_fence -> base , true ) ; amdgpu_bo_unreserve ( bo ) ; svm_bo -> bo = bo ; prange -> svm_bo = svm_bo ; prange -> ttm_res = bo -> tbo . resource ; prange -> offset = 0 ; spin_lock ( & svm_bo -> list_lock ) ; list_add ( & prange -> svm_bo_list , & svm_bo -> range_list ) ; spin_unlock ( & svm_bo -> list_lock ) ; return 0 ; reserve_bo_failed amdgpu_bo_unref ( & bo ) ; create_bo_failed dma_fence_put ( & svm_bo -> eviction_fence -> base ) ; kfree ( svm_bo ) ; prange -> ttm_res = NULL ; return r ; } 