void ourWriteOut ( struct OperationConfig * config , struct per_transfer * per , CURLcode per_result ) { FILE * stream = stdout ; const char * writeinfo = config -> writeout ; const char * ptr = writeinfo ; bool done = FALSE ; struct curl_certinfo * certinfo ; CURLcode res = curl_easy_getinfo ( per -> curl , CURLINFO_CERTINFO , & certinfo ) ; if ( ! res && certinfo ) { per -> certinfo = certinfo ; } while ( ptr && * ptr && ! done ) { if ( '%' == * ptr && ptr [ 1 ] ) { if ( '%' == ptr [ 1 ] ) { fputc ( '%' , stream ) ; ptr += 2 ; } else { char * end ; size_t vlen ; if ( '{' == ptr [ 1 ] ) { int i ; bool match = FALSE ; end = strchr ( ptr , '}' ) ; ptr += 2 ; if ( ! end ) { fputs ( "%{" , stream ) ; continue ; } vlen = end - ptr ; for ( i = 0 ; variables [ i ] . name ; i ++ ) { if ( ( strlen ( variables [ i ] . name ) == vlen ) && curl_strnequal ( ptr , variables [ i ] . name , vlen ) ) { match = TRUE ; switch ( variables [ i ] . id ) { case VAR_ONERROR : if ( per_result == CURLE_OK ) { done = TRUE ; } break ; case VAR_STDOUT : stream = stdout ; break ; case VAR_STDERR : stream = config -> global -> errors ; break ; case VAR_JSON : ourWriteOutJSON ( stream , variables , per , per_result ) ; break ; case VAR_HEADER_JSON : headerJSON ( stream , per ) ; break ; default : ( void ) variables [ i ] . writefunc ( stream , & variables [ i ] , per , per_result , false ) ; break ; } break ; } } if ( ! match ) { fprintf ( stderr , "curl: unknown --write-out variable: '%.*s'\n" , ( int ) vlen , ptr ) ; } ptr = end + 1 ; } if ( ! strncmp ( "header{" , & ptr [ 1 ] , 7 ) ) { ptr += 8 ; end = strchr ( ptr , '}' ) ; if ( end ) { char hname [ 256 ] ; struct curl_header * header ; vlen = end - ptr ; if ( vlen < sizeof ( hname ) ) { memcpy ( hname , ptr , vlen ) ; hname [ vlen ] = 0 ; if ( CURLHE_OK == curl_easy_header ( per -> curl , hname , 0 , CURLH_HEADER , - 1 , & header ) ) { fputs ( header -> value , stream ) ; } } ptr = end + 1 ; } else { fputs ( "%header{" , stream ) ; } } else { fputc ( '%' , stream ) ; fputc ( ptr [ 1 ] , stream ) ; ptr += 2 ; } } } if ( '\\' == * ptr && ptr [ 1 ] ) { switch ( ptr [ 1 ] ) { case 'r' : fputc ( '\r' , stream ) ; break ; case 'n' : fputc ( '\n' , stream ) ; break ; case 't' : fputc ( '\t' , stream ) ; break ; default : fputc ( * ptr , stream ) ; fputc ( ptr [ 1 ] , stream ) ; break ; } ptr += 2 ; } else { fputc ( * ptr , stream ) ; ptr ++ ; } } } 