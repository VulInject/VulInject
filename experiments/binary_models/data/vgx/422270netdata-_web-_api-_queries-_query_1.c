static bool query_plan ( QUERY_ENGINE_OPS * ops , time_t after_wanted , time_t before_wanted , size_t points_wanted ) { QUERY_METRIC * qm = ops -> qm ; size_t selected_tier ; if ( ops -> r -> view . options & RRDR_OPTION_SELECTED_TIER && ops -> r -> internal . qt -> window . tier < storage_tiers && query_metric_is_valid_tier ( qm , ops -> r -> internal . qt -> window . tier ) ) { selected_tier = ops -> r -> internal . qt -> window . tier ; } else { selected_tier = query_metric_best_tier_for_timeframe ( qm , after_wanted , before_wanted , points_wanted ) ; if ( ops -> r -> view . options & RRDR_OPTION_SELECTED_TIER ) { ops -> r -> view . options &= ~ RRDR_OPTION_SELECTED_TIER ; } if ( qm -> tiers [ selected_tier ] . db_first_time_s > before_wanted || qm -> tiers [ selected_tier ] . db_last_time_s < after_wanted ) { return false ; } } qm -> plan . used = 1 ; qm -> plan . array [ 0 ] . tier = selected_tier ; qm -> plan . array [ 0 ] . after = ( qm -> tiers [ selected_tier ] . db_first_time_s < after_wanted ) ?after_wanted : qm -> tiers [ selected_tier ] . db_first_time_s ; qm -> plan . array [ 0 ] . before = ( qm -> tiers [ selected_tier ] . db_last_time_s > before_wanted ) ?before_wanted : qm -> tiers [ selected_tier ] . db_last_time_s ; if ( ! ( ops -> r -> view . options & RRDR_OPTION_SELECTED_TIER ) ) { time_t selected_tier_first_time_s = qm -> plan . array [ 0 ] . after ; time_t selected_tier_last_time_s = qm -> plan . array [ 0 ] . before ; if ( selected_tier_first_time_s > after_wanted ) { for ( size_t tr = ( int ) selected_tier + 1 ; tr < storage_tiers ; tr ++ ) { if ( ! query_metric_is_valid_tier ( qm , tr ) ) { continue ; } time_t tier_first_time_s = qm -> tiers [ tr ] . db_first_time_s ; if ( tier_first_time_s < selected_tier_first_time_s ) { QUERY_PLAN_ENTRY t = { . tier = tr . after = ( tier_first_time_s < after_wanted ) ? after_wanted : tier_first_time_s . before = selected_tier_first_time_s . initialized = false . finalized = false } ; qm -> plan . array [ qm -> plan . used ++ ] = t ; internal_fatal ( ! t . after || ! t . before , "QUERY: invalid plan selected" ) ; selected_tier_first_time_s = t . after ; if ( t . after <= after_wanted ) { break ; } } } } if ( selected_tier_last_time_s < before_wanted ) { for ( int tr = ( int ) selected_tier - 1 ; tr >= 0 ; tr -- ) { if ( ! query_metric_is_valid_tier ( qm , tr ) ) { continue ; } time_t tier_last_time_s = qm -> tiers [ tr ] . db_last_time_s ; if ( tier_last_time_s > selected_tier_last_time_s ) { QUERY_PLAN_ENTRY t = { . tier = tr . after = selected_tier_last_time_s . before = ( tier_last_time_s > before_wanted ) ? before_wanted : tier_last_time_s . initialized = false . finalized = false } ; qm -> plan . array [ qm -> plan . used ++ ] = t ; selected_tier_last_time_s = t . before ; internal_fatal ( ! t . after || ! t . before , "QUERY: invalid plan selected" ) ; if ( t . before >= before_wanted ) { break ; } } } } } if ( qm -> plan . used > 1 ) { qsort ( & qm -> plan . array , qm -> plan . used , sizeof ( QUERY_PLAN_ENTRY ) , compare_query_plan_entries_on_start_time ) ; } if ( ! query_metric_is_valid_tier ( qm , qm -> plan . array [ 0 ] . tier ) ) { return false ; } for ( size_t p = 0 ; p < qm -> plan . used ; p ++ ) { internal_fatal ( qm -> plan . array [ p ] . after > qm -> plan . array [ p ] . before , "QUERY: flipped after/before" ) ; internal_fatal ( qm -> plan . array [ p ] . after < after_wanted , "QUERY: too small plan first time" ) ; internal_fatal ( qm -> plan . array [ p ] . before > before_wanted , "QUERY: too big plan last time" ) ; } query_planer_initialize_plans ( ops ) ; query_planer_activate_plan ( ops , 0 , 0 ) ; return true ; } 