static int mrfld_extcon_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct intel_soc_pmic * pmic = dev_get_drvdata ( dev -> parent ) ; struct regmap * regmap = pmic -> regmap ; struct mrfld_extcon_data * data ; unsigned int status ; unsigned int id ; int irq , ret ; irq = platform_get_irq ( pdev , 0 ) ; if ( irq < 0 ) { return irq ; } data = devm_kzalloc ( dev , sizeof ( * data ) , GFP_KERNEL ) ; data -> dev = dev ; data -> regmap = regmap ; data -> edev = devm_extcon_dev_allocate ( dev , mrfld_extcon_cable ) ; if ( IS_ERR ( data -> edev ) ) { return - ENOMEM ; } ret = devm_extcon_dev_register ( dev , data -> edev ) ; if ( ret < 0 ) { dev_err ( dev , "can't register extcon device: %d\n" , ret ) ; return ret ; } ret = devm_request_threaded_irq ( dev , irq , NULL , mrfld_extcon_interrupt , IRQF_ONESHOT | IRQF_SHARED , pdev -> name , data ) ; if ( ret ) { dev_err ( dev , "can't register IRQ handler: %d\n" , ret ) ; return ret ; } ret = regmap_read ( regmap , BCOVE_ID , & id ) ; if ( ret ) { dev_err ( dev , "can't read PMIC ID: %d\n" , ret ) ; return ret ; } data -> id = id ; ret = mrfld_extcon_sw_control ( data , true ) ; if ( ret ) { return ret ; } mrfld_extcon_role_detect ( data ) ; regmap_read ( regmap , BCOVE_SCHGRIRQ1 , & status ) ; data -> status = status ; mrfld_extcon_clear ( data , BCOVE_MIRQLVL1 , BCOVE_LVL1_CHGR ) ; mrfld_extcon_clear ( data , BCOVE_MCHGRIRQ1 , BCOVE_CHGRIRQ_ALL ) ; mrfld_extcon_set ( data , BCOVE_USBIDCTRL , BCOVE_USBIDCTRL_ALL ) ; platform_set_drvdata ( pdev , data ) ; return 0 ; } 