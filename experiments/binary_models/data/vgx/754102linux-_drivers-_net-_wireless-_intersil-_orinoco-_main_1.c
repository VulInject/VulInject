void __orinoco_ev_info ( struct net_device * dev , struct hermes * hw ) { struct orinoco_private * priv = ndev_priv ( dev ) ; u16 infofid ; { __le16 len ; __le16 type ; } , __packed info int len , type ; int err ; infofid = hermes_read_regn ( hw , INFOFID ) ; err = hw -> ops -> bap_pread ( hw , IRQ_BAP , & info , sizeof ( info ) , infofid , 0 ) ; if ( err ) { printk ( KERN_ERR "%s: error %d reading info frame. " "Frame dropped.\n" , dev -> name , err ) ; return ; } len = HERMES_RECLEN_TO_BYTES ( le16_to_cpu ( info . len ) ) ; type = le16_to_cpu ( info . type ) ; switch ( type ) { case HERMES_INQ_TALLIES : { struct hermes_tallies_frame tallies ; struct iw_statistics * wstats = & priv -> wstats ; if ( len > sizeof ( tallies ) ) { printk ( KERN_WARNING "%s: Tallies frame too long (%d bytes)\n" , dev -> name , len ) ; len = sizeof ( tallies ) ; } err = hw -> ops -> bap_pread ( hw , IRQ_BAP , & tallies , len , infofid , sizeof ( info ) ) ; if ( err ) { break ; } wstats -> discard . code += le16_to_cpu ( tallies . RxWEPUndecryptable ) ; if ( len == sizeof ( tallies ) ) { wstats -> discard . code += le16_to_cpu ( tallies . RxDiscards_WEPICVError ) + le16_to_cpu ( tallies . RxDiscards_WEPExcluded ) ; } wstats -> discard . misc += le16_to_cpu ( tallies . TxDiscardsWrongSA ) ; wstats -> discard . fragment += le16_to_cpu ( tallies . RxMsgInBadMsgFragments ) ; wstats -> discard . retries += le16_to_cpu ( tallies . TxRetryLimitExceeded ) ; } break ; case HERMES_INQ_LINKSTATUS : { struct hermes_linkstatus linkstatus ; u16 newstatus ; int connected ; if ( priv -> iw_mode == NL80211_IFTYPE_MONITOR ) { break ; } if ( len != sizeof ( linkstatus ) ) { printk ( KERN_WARNING "%s: Unexpected size for linkstatus frame (%d bytes)\n" , dev -> name , len ) ; break ; } err = hw -> ops -> bap_pread ( hw , IRQ_BAP , & linkstatus , len , infofid , sizeof ( info ) ) ; if ( err ) { break ; } newstatus = le16_to_cpu ( linkstatus . linkstatus ) ; if ( newstatus == HERMES_LINKSTATUS_AP_OUT_OF_RANGE && priv -> firmware_type == FIRMWARE_TYPE_SYMBOL && priv -> has_hostscan && priv -> scan_request ) { hermes_inquire ( hw , HERMES_INQ_HOSTSCAN_SYMBOL ) ; break ; } connected = ( newstatus == HERMES_LINKSTATUS_CONNECTED ) || ( newstatus == HERMES_LINKSTATUS_AP_CHANGE ) || ( newstatus == HERMES_LINKSTATUS_AP_IN_RANGE ) ; if ( connected ) { netif_carrier_on ( dev ) ; } if ( ! ignore_disconnect ) { netif_carrier_off ( dev ) ; } if ( newstatus != priv -> last_linkstatus ) { priv -> last_linkstatus = newstatus ; print_linkstatus ( dev , newstatus ) ; schedule_work ( & priv -> wevent_work ) ; } } break ; case HERMES_INQ_SCAN : if ( ! priv -> scan_request && priv -> bssid_fixed && priv -> firmware_type == FIRMWARE_TYPE_INTERSIL ) { schedule_work ( & priv -> join_work ) ; break ; } fallthrough ; case HERMES_INQ_HOSTSCAN : case HERMES_INQ_HOSTSCAN_SYMBOL : { unsigned char * buf ; if ( len > 4096 ) { printk ( KERN_WARNING "%s: Scan results too large (%d bytes)\n" , dev -> name , len ) ; qabort_scan ( priv ) ; break ; } buf = kmalloc ( len , GFP_ATOMIC ) ; if ( buf == NULL ) { qabort_scan ( priv ) ; break ; } err = hw -> ops -> bap_pread ( hw , IRQ_BAP , ( void * ) buf , len , infofid , sizeof ( info ) ) ; if ( err ) { qabort_scan ( priv ) ; break ; } { int i ; printk ( KERN_DEBUG "Scan result [%02X" , buf [ 0 ] ) ; for ( i = 1 ; i < ( len * 2 ) ; i ++ ) { printk ( ":%02X" , buf [ i ] ) ; } printk ( "]\n" ) ; } qbuf_scan ( priv , buf , len , type ) ; } break ; case HERMES_INQ_CHANNELINFO : { struct agere_ext_scan_info * bss ; if ( ! priv -> scan_request ) { printk ( KERN_DEBUG "%s: Got chaninfo without scan, " "len=%d\n" , dev -> name , len ) ; break ; } if ( len == 0 ) { qbuf_scan ( priv , NULL , len , type ) ; break ; } if ( len < ( offsetof ( agere_ext_scan_info , data ) + 2 ) ) { printk ( KERN_WARNING "%s: Ext scan results too short (%d bytes)\n" , dev -> name , len ) ; break ; } bss = kmalloc ( len , GFP_ATOMIC ) ; if ( bss == NULL ) { break ; } err = hw -> ops -> bap_pread ( hw , IRQ_BAP , ( void * ) bss , len , infofid , sizeof ( info ) ) ; if ( err ) { kfree ( bss ) ; } else { qbuf_scan ( priv , bss , len , type ) ; } break ; } case HERMES_INQ_SEC_STAT_AGERE : if ( priv -> firmware_type == FIRMWARE_TYPE_AGERE ) { break ; } fallthrough ; default : printk ( KERN_DEBUG "%s: Unknown information frame received: " "type 0x%04x, length %d\n" , dev -> name , type , len ) ; break ; } } 