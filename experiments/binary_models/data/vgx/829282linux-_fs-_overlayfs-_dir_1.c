static char * ovl_get_redirect ( struct dentry * dentry , bool abs_redirect ) { char * buf , * ret ; struct dentry * d , * tmp ; int buflen = ovl_redirect_max + 1 ; if ( ! abs_redirect ) { ret = kstrndup ( dentry -> d_name . name , dentry -> d_name . len , GFP_KERNEL ) ; out } buf = ret = kmalloc ( buflen , GFP_KERNEL ) ; if ( ! buf ) { out } buflen -- ; buf [ buflen ] = '\0' ; for ( d = dget ( dentry ) ; ! IS_ROOT ( d ) ; ) { const char * name ; int thislen ; spin_lock ( & d -> d_lock ) ; name = ovl_dentry_get_redirect ( d ) ; if ( name ) { thislen = strlen ( name ) ; } else { name = d -> d_name . name ; thislen = d -> d_name . len ; } if ( thislen + ( name [ 0 ] != '/' ) > buflen ) { ret = ERR_PTR ( - EXDEV ) ; spin_unlock ( & d -> d_lock ) ; out_put } buflen -= thislen ; memcpy ( & buf [ buflen ] , name , thislen ) ; spin_unlock ( & d -> d_lock ) ; tmp = dget_parent ( d ) ; dput ( d ) ; d = tmp ; if ( buf [ buflen ] == '/' ) { break ; } buflen -- ; buf [ buflen ] = '/' ; } ret = kstrdup ( & buf [ buflen ] , GFP_KERNEL ) ; out_put dput ( d ) ; out return ret ?ret : ERR_PTR ( - ENOMEM ) ; } 