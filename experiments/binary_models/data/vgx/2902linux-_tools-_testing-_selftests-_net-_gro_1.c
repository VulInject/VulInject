static void gro_receiver ( void ) { static int correct_payload [ NUM_PACKETS ] ; int rxfd = - 1 ; rxfd = socket ( PF_PACKET , SOCK_RAW , htons ( ETH_P_NONE ) ) ; if ( rxfd < 0 ) { error ( 1 , 0 , "socket creation" ) ; } setup_sock_filter ( rxfd ) ; set_timeout ( rxfd , NULL ) ; bind_packetsocket ( rxfd ) ; memset ( correct_payload , 0 , sizeof ( correct_payload ) ) ; if ( strcmp ( testname , "data" ) == 0 ) { printf ( "pure data packet of same size: " ) ; correct_payload [ 0 ] = PAYLOAD_LEN * 2 ; check_recv_pkts ( rxfd , correct_payload , 1 ) ; printf ( "large data packets followed by a smaller one: " ) ; correct_payload [ 0 ] = PAYLOAD_LEN * 1.5 ; check_recv_pkts ( rxfd , correct_payload , 1 ) ; printf ( "small data packets followed by a larger one: " ) ; correct_payload [ 0 ] = PAYLOAD_LEN / 2 ; correct_payload [ 1 ] = PAYLOAD_LEN ; check_recv_pkts ( rxfd , correct_payload , 2 ) ; } if ( strcmp ( testname , "ack" ) == 0 ) { printf ( "duplicate ack and pure ack: " ) ; check_recv_pkts ( rxfd , correct_payload , 3 ) ; } if ( strcmp ( testname , "flags" ) == 0 ) { correct_payload [ 0 ] = PAYLOAD_LEN * 3 ; correct_payload [ 1 ] = PAYLOAD_LEN * 2 ; printf ( "psh flag ends coalescing: " ) ; check_recv_pkts ( rxfd , correct_payload , 2 ) ; correct_payload [ 0 ] = PAYLOAD_LEN * 2 ; correct_payload [ 1 ] = 0 ; correct_payload [ 2 ] = PAYLOAD_LEN * 2 ; printf ( "syn flag ends coalescing: " ) ; check_recv_pkts ( rxfd , correct_payload , 3 ) ; printf ( "rst flag ends coalescing: " ) ; check_recv_pkts ( rxfd , correct_payload , 3 ) ; printf ( "urg flag ends coalescing: " ) ; check_recv_pkts ( rxfd , correct_payload , 3 ) ; } if ( strcmp ( testname , "tcp" ) == 0 ) { correct_payload [ 0 ] = PAYLOAD_LEN ; correct_payload [ 1 ] = PAYLOAD_LEN ; correct_payload [ 2 ] = PAYLOAD_LEN ; correct_payload [ 3 ] = PAYLOAD_LEN ; printf ( "changed checksum does not coalesce: " ) ; check_recv_pkts ( rxfd , correct_payload , 2 ) ; printf ( "Wrong Seq number doesn't coalesce: " ) ; check_recv_pkts ( rxfd , correct_payload , 2 ) ; printf ( "Different timestamp doesn't coalesce: " ) ; correct_payload [ 0 ] = PAYLOAD_LEN * 2 ; check_recv_pkts ( rxfd , correct_payload , 4 ) ; printf ( "Different options doesn't coalesce: " ) ; correct_payload [ 0 ] = PAYLOAD_LEN * 2 ; check_recv_pkts ( rxfd , correct_payload , 2 ) ; } if ( strcmp ( testname , "ip" ) == 0 ) { correct_payload [ 0 ] = PAYLOAD_LEN ; correct_payload [ 1 ] = PAYLOAD_LEN ; printf ( "different ECN doesn't coalesce: " ) ; check_recv_pkts ( rxfd , correct_payload , 2 ) ; printf ( "different tos doesn't coalesce: " ) ; check_recv_pkts ( rxfd , correct_payload , 2 ) ; if ( proto == PF_INET ) { printf ( "different ttl doesn't coalesce: " ) ; check_recv_pkts ( rxfd , correct_payload , 2 ) ; printf ( "ip options doesn't coalesce: " ) ; correct_payload [ 2 ] = PAYLOAD_LEN ; check_recv_pkts ( rxfd , correct_payload , 3 ) ; printf ( "fragmented ip4 doesn't coalesce: " ) ; check_recv_pkts ( rxfd , correct_payload , 2 ) ; } if ( proto == PF_INET6 ) { printf ( "fragmented ip6 doesn't coalesce: " ) ; correct_payload [ 0 ] = PAYLOAD_LEN * 2 ; check_recv_pkts ( rxfd , correct_payload , 2 ) ; } } if ( strcmp ( testname , "large" ) == 0 ) { int offset = proto == PF_INET ?20 : 0 ; int remainder = ( MAX_PAYLOAD + offset ) % MSS ; correct_payload [ 0 ] = ( MAX_PAYLOAD + offset ) ; correct_payload [ 1 ] = remainder ; printf ( "Shouldn't coalesce if exceed IP max pkt size: " ) ; check_recv_pkts ( rxfd , correct_payload , 2 ) ; correct_payload [ 0 ] = correct_payload [ 0 ] - remainder ; correct_payload [ 1 ] = remainder + 1 ; correct_payload [ 2 ] = remainder + 1 ; check_recv_pkts ( rxfd , correct_payload , 3 ) ; } else { error ( 1 , 0 , "Test case error, should never trigger" ) ; } if ( close ( rxfd ) ) { error ( 1 , 0 , "socket close" ) ; } } 