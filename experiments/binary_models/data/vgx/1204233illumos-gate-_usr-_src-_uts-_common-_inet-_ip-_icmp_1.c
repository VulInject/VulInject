mblk_t * icmp_prepend_hdr ( conn_t * connp , ip_xmit_attr_t * ixa , const ip_pkt_t * ipp , const in6_addr_t * v6src , const in6_addr_t * v6dst , uint32_t flowinfo , mblk_t * data_mp , int * errorp ) { mblk_t * mp ; icmp_stack_t * is = connp -> conn_netstack -> netstack_icmp ; uint_t data_len ; uint32_t cksum ; data_len = msgdsize ( data_mp ) ; mp = conn_prepend_hdr ( ixa , ipp , v6src , v6dst , connp -> conn_proto , flowinfo , 0 , data_mp , data_len , is -> is_wroff_extra , & cksum , errorp ) ; if ( mp == NULL ) { ASSERT ( * errorp != 0 ) ; return ( NULL ) ; } ixa -> ixa_pktlen = data_len + ixa -> ixa_ip_hdr_length ; cksum += data_len ; cksum = ( cksum >> 16 ) + ( cksum & 0xFFFF ) ; ASSERT ( cksum < 0x10000 ) ; if ( ixa -> ixa_flags & IXAF_IS_IPV4 ) { ipha_t * ipha = ( ipha_t * ) mp -> b_rptr ; ASSERT ( ntohs ( ipha -> ipha_length ) == ixa -> ixa_pktlen ) ; } else { ip6_t * ip6h = ( ip6_t * ) mp -> b_rptr ; uint_t cksum_offset = 0 ; ASSERT ( ntohs ( ip6h -> ip6_plen ) + IPV6_HDR_LEN == ixa -> ixa_pktlen ) ; if ( ixa -> ixa_flags & IXAF_SET_ULP_CKSUM ) { if ( connp -> conn_proto == IPPROTO_ICMPV6 ) { cksum_offset = ixa -> ixa_ip_hdr_length + offsetof ( icmp6_t , icmp6_cksum ) ; } if ( ixa -> ixa_flags & IXAF_SET_RAW_CKSUM ) { cksum_offset = ixa -> ixa_ip_hdr_length + ixa -> ixa_raw_cksum_offset ; } } if ( cksum_offset != 0 ) { uint16_t * ptr ; if ( cksum_offset + sizeof ( short ) > MBLKL ( mp ) ) { mblk_t * mp1 ; mp1 = msgpullup ( mp , cksum_offset + sizeof ( short ) ) ; if ( mp1 == NULL ) { * errorp = ENOMEM ; return ( NULL ) ; } mp = mp1 ; ip6h = ( ip6_t * ) mp -> b_rptr ; } ptr = ( uint16_t * ) ( mp -> b_rptr + cksum_offset ) ; * ptr = htons ( cksum ) ; } } return ( mp ) ; } 