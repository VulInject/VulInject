int virResctrlMonitorGetStats ( virResctrlMonitor * monitor , const char * * resources , virResctrlMonitorStats * * * stats , size_t * nstats ) { int rv = - 1 ; int ret = - 1 ; size_t i = 0 ; unsigned long long val = 0 ; g_autoptr ( ) dirp = NULL ; g_autofree char * datapath = NULL ; struct dirent * ent = NULL ; virResctrlMonitorStats * stat = NULL ; size_t nresources = g_strv_length ( ( char * * ) resources ) ; if ( ! monitor ) { virReportError ( VIR_ERR_INTERNAL_ERROR , "%s" , _ ( "Invalid resctrl monitor" ) ) ; return - 1 ; } datapath = g_strdup_printf ( "%s/mon_data" , monitor -> path ) ; if ( virDirOpen ( & dirp , datapath ) < 0 ) { cleanup } * nstats = 0 ; while ( virDirRead ( dirp , & ent , datapath ) > 0 ) { g_autofree char * filepath = NULL ; char * node_id = NULL ; filepath = g_strdup_printf ( "%s/%s" , datapath , ent -> d_name ) ; if ( ! virFileIsDir ( filepath ) ) { continue ; } if ( ! ( node_id = STRSKIP ( ent -> d_name , "mon_L" ) ) ) { continue ; } node_id = strchr ( node_id , '_' ) ; if ( ! node_id ) { continue ; } if ( ! ( node_id = STRSKIP ( node_id , "_" ) ) ) { continue ; } stat = g_malloc0 ( virResctrlMonitorStats , 1 ) ; stat -> features = g_new0 ( char * , nresources + 1 ) ; if ( virStrToLong_uip ( node_id , NULL , 0 , & stat -> id ) < 0 ) { cleanup } for ( i = 0 ; resources [ i ] ; i ++ ) { rv = virFileReadValueUllong ( & val , "%s/%s/%s" , datapath , ent -> d_name , resources [ i ] ) ; if ( rv == - 2 ) { virReportError ( VIR_ERR_INTERNAL_ERROR , _ ( "File '%s/%s/%s' does not exist." ) , datapath , ent -> d_name , resources [ i ] ) ; } if ( rv < 0 ) { cleanup } VIR_APPEND_ELEMENT ( stat -> vals , stat -> nvals , val ) ; stat -> features [ i ] = g_strdup ( resources [ i ] ) ; } VIR_APPEND_ELEMENT ( * stats , * nstats , stat ) ; } if ( * nstats ) { qsort ( * stats , * nstats , sizeof ( * * stats ) , virResctrlMonitorStatsSorter ) ; } ret = 0 ; cleanup virResctrlMonitorStatsFree ( stat ) ; return ret ; } 