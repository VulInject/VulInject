gdk_pixbuf__png_image_load ( , ) { GdkPixbuf * volatile pixbuf = NULL ; png_structp png_ptr ; png_infop info_ptr ; png_textp text_ptr ; gint i , ctype ; png_uint_32 w , h ; png_bytepp volatile rows = NULL ; gint num_texts ; gchar * key ; gchar * value ; gchar * icc_profile_base64 ; const gchar * icc_profile_title ; const gchar * icc_profile ; png_uint_32 icc_profile_size ; png_uint_32 x_resolution ; png_uint_32 y_resolution ; int unit_type ; gchar * density_str ; guint32 retval ; gint compression_type ; gpointer ptr ; png_ptr = png_create_read_struct_2 ( PNG_LIBPNG_VER_STRING , error , png_simple_error_callback , png_simple_warning_callback , NULL , png_malloc_callback , png_free_callback ) ; png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , error , png_simple_error_callback , png_simple_warning_callback ) ; if ( ! png_ptr ) { return NULL ; } info_ptr = png_create_info_struct ( png_ptr ) ; if ( ! info_ptr ) { png_destroy_read_struct ( & png_ptr , NULL , NULL ) ; return NULL ; } if ( setjmp ( png_jmpbuf ( png_ptr ) ) ) { if ( pixbuf ) { g_object_unref ( pixbuf ) ; } png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return NULL ; } png_init_io ( png_ptr , f ) ; png_read_info ( png_ptr , info_ptr ) ; if ( ! setup_png_transformations ( png_ptr , info_ptr , error , & w , & h , & ctype ) ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return NULL ; } pixbuf = gdk_pixbuf_new ( GDK_COLORSPACE_RGB , ctype & PNG_COLOR_MASK_ALPHA , 8 , w , h ) ; if ( ! pixbuf ) { g_set_error_literal ( error , GDK_PIXBUF_ERROR , GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY , _ ( "Insufficient memory to load PNG file" ) ) ; png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return NULL ; } gdk_pixbuf_fill ( pixbuf , DEFAULT_FILL_COLOR ) ; rows = g_new ( png_bytep , h ) ; for ( i = 0 , ptr = pixbuf -> pixels ; i < h ; i ++ , ptr = ( guchar * ) ptr + pixbuf -> rowstride ) { rows [ i ] = ptr ; } png_read_image ( png_ptr , rows ) ; png_read_end ( png_ptr , info_ptr ) ; if ( png_get_text ( png_ptr , info_ptr , & text_ptr , & num_texts ) ) { for ( i = 0 ; i < num_texts ; i ++ ) { png_text_to_pixbuf_option ( text_ptr [ i ] , & key , & value ) ; gdk_pixbuf_set_option ( pixbuf , key , value ) ; g_free ( key ) ; g_free ( value ) ; } } retval = png_get_iCCP ( png_ptr , info_ptr , ( png_charpp ) & icc_profile_title , & compression_type , ( png_bytepp ) & icc_profile , ( png_uint_32 * ) & icc_profile_size ) ; if ( retval != 0 ) { icc_profile_base64 = g_base64_encode ( ( const guchar * ) icc_profile , ( gsize ) icc_profile_size ) ; gdk_pixbuf_set_option ( pixbuf , "icc-profile" , icc_profile_base64 ) ; g_free ( icc_profile_base64 ) ; } retval = png_get_pHYs ( png_ptr , info_ptr , & x_resolution , & y_resolution , & unit_type ) ; if ( retval != 0 && unit_type == PNG_RESOLUTION_METER ) { density_str = g_strdup_printf ( "%d" , DPM_TO_DPI ( x_resolution ) ) ; gdk_pixbuf_set_option ( pixbuf , "x-dpi" , density_str ) ; g_free ( density_str ) ; density_str = g_strdup_printf ( "%d" , DPM_TO_DPI ( y_resolution ) ) ; gdk_pixbuf_set_option ( pixbuf , "y-dpi" , density_str ) ; g_free ( density_str ) ; } g_free ( rows ) ; png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return pixbuf ; } 