static int debug_open ( struct inode * inode , struct file * file ) { debug_info_t * debug_info , * debug_info_snapshot ; file_private_info_t * p_info ; int i , rc = 0 ; mutex_lock ( & debug_mutex ) ; debug_info = file_inode ( file ) -> i_private ; for ( i = 0 ; i < DEBUG_MAX_VIEWS ; i ++ ) { if ( ! debug_info -> views [ i ] ) { continue ; } if ( debug_info -> debugfs_entries [ i ] == file -> f_path . dentry ) { found } } rc = - EINVAL ; out found if ( ! debug_info -> views [ i ] -> format_proc && ! debug_info -> views [ i ] -> header_proc ) { debug_info_snapshot = debug_info_copy ( debug_info , NO_AREAS ) ; } else { debug_info_snapshot = debug_info_copy ( debug_info , ALL_AREAS ) ; } if ( ! debug_info_snapshot ) { rc = - ENOMEM ; out } p_info = kmalloc ( sizeof ( file_private_info_t ) , GFP_KERNEL ) ; if ( ! p_info ) { rc = - ENOMEM ; out } p_info -> offset = 0 ; p_info -> debug_info_snap = debug_info_snapshot ; p_info -> debug_info_org = debug_info ; p_info -> view = debug_info -> views [ i ] ; p_info -> act_area = 0 ; p_info -> act_page = 0 ; p_info -> act_entry = DEBUG_PROLOG_ENTRY ; p_info -> act_entry_offset = 0 ; file -> private_data = p_info ; debug_info_get ( debug_info ) ; nonseekable_open ( inode , file ) ; out mutex_unlock ( & debug_mutex ) ; return rc ; } 