static int mpc52xx_gpt_probe ( struct platform_device * ofdev ) { struct mpc52xx_gpt_priv * gpt ; gpt = devm_kzalloc ( & ofdev -> dev , sizeof gpt , GFP_KERNEL ) ; raw_spin_lock_init ( & gpt -> lock ) ; gpt -> dev = & ofdev -> dev ; gpt -> ipb_freq = mpc5xxx_get_bus_frequency ( & ofdev -> dev ) ; gpt -> regs = of_iomap ( ofdev -> dev . of_node , 0 ) ; if ( ! gpt -> regs ) { return - ENOMEM ; } dev_set_drvdata ( & ofdev -> dev , gpt ) ; mpc52xx_gpt_gpio_setup ( gpt ) ; mpc52xx_gpt_irq_setup ( gpt , ofdev -> dev . of_node ) ; mutex_lock ( & mpc52xx_gpt_list_mutex ) ; list_add ( & gpt -> list , & mpc52xx_gpt_list ) ; mutex_unlock ( & mpc52xx_gpt_list_mutex ) ; if ( of_get_property ( ofdev -> dev . of_node , "fsl,has-wdt" , NULL ) || of_get_property ( ofdev -> dev . of_node , "has-wdt" , NULL ) ) { const u32 * on_boot_wdt ; gpt -> wdt_mode = MPC52xx_GPT_CAN_WDT ; on_boot_wdt = of_get_property ( ofdev -> dev . of_node , "fsl,wdt-on-boot" , NULL ) ; if ( on_boot_wdt ) { dev_info ( gpt -> dev , "used as watchdog\n" ) ; gpt -> wdt_mode |= MPC52xx_GPT_IS_WDT ; } else { dev_info ( gpt -> dev , "can function as watchdog\n" ) ; } mpc52xx_gpt_wdt_setup ( gpt , on_boot_wdt ) ; } return 0 ; } 