static irqreturn_t dc_i2c_irq ( int irq , void * dev_id ) { struct dc_i2c * i2c = dev_id ; int cmd_status = dc_i2c_cmd_status ( i2c ) ; unsigned long flags ; int addr_cmd ; writeb_relaxed ( 1 , i2c -> regs + II_INTFLAG_CLEAR ) ; spin_lock_irqsave ( & i2c -> lock , flags ) ; if ( cmd_status == II_CMD_STATUS_ACK_BAD || cmd_status == II_CMD_STATUS_ABORT ) { i2c -> error = - EIO ; complete ( & i2c -> done ) ; out } switch ( i2c -> state ) { case STATE_START : addr_cmd = dc_i2c_addr_cmd ( i2c -> msg ) ; dc_i2c_write_byte ( i2c , addr_cmd ) ; i2c -> state = STATE_ADDR ; break ; case STATE_ADDR : if ( i2c -> msg -> flags & I2C_M_RD ) { dc_i2c_next_read ( i2c ) ; i2c -> state = STATE_READ ; break ; } i2c -> state = STATE_WRITE ; case STATE_WRITE : if ( i2c -> msgbuf_ptr < i2c -> msg -> len ) { dc_i2c_write_buf ( i2c ) ; } else { dc_i2c_stop ( i2c ) ; } break ; case STATE_READ : if ( i2c -> msgbuf_ptr < i2c -> msg -> len ) { dc_i2c_read_buf ( i2c ) ; } else { dc_i2c_stop ( i2c ) ; } break ; case STATE_STOP : i2c -> state = STATE_IDLE ; complete ( & i2c -> done ) ; break ; } out spin_unlock_irqrestore ( & i2c -> lock , flags ) ; return IRQ_HANDLED ; } 