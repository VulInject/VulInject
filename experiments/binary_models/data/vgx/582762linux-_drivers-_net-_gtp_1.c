static int gtp0_send_echo_resp ( struct gtp_dev * gtp , struct sk_buff * skb ) { struct gtp0_packet * gtp_pkt ; struct gtp0_header * gtp0 ; struct rtable * rt ; struct flowi4 fl4 ; struct iphdr * iph ; __be16 seq ; gtp0 = ( gtp0_header * ) ( skb -> data + sizeof ( udphdr ) ) ; if ( ! gtp0_validate_echo_hdr ( gtp0 ) ) { return - 1 ; } seq = gtp0 -> seq ; skb_pull_data ( skb , sizeof ( gtp0_header ) + sizeof ( udphdr ) ) ; gtp_pkt = skb_push ( skb , sizeof ( gtp0_packet ) ) ; gtp0_build_echo_msg ( & gtp_pkt -> gtp0_h , GTP_ECHO_RSP ) ; gtp_pkt -> gtp0_h . seq = seq ; gtp_pkt -> ie . tag = GTPIE_RECOVERY ; gtp_pkt -> ie . val = gtp -> restart_count ; iph = ip_hdr ( skb ) ; rt = ip4_route_output_gtp ( & fl4 , gtp -> sk0 , iph -> saddr , iph -> daddr ) ; if ( IS_ERR ( rt ) ) { netdev_dbg ( gtp -> dev , "no route for echo response from %pI4\n" , & iph -> saddr ) ; return - 1 ; } udp_tunnel_xmit_skb ( rt , gtp -> sk0 , skb , fl4 . saddr , fl4 . daddr , iph -> tos , ip4_dst_hoplimit ( & rt -> dst ) , 0 , htons ( GTP0_PORT ) , htons ( GTP0_PORT ) , ! net_eq ( sock_net ( gtp -> sk1u ) , dev_net ( gtp -> dev ) ) , false ) ; return 0 ; } 