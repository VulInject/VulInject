int ehci_hub_control ( struct usb_hcd * hcd , u16 typeReq , u16 wValue , u16 wIndex , char * buf , u16 wLength ) { struct ehci_hcd * ehci = hcd_to_ehci ( hcd ) ; int ports = HCS_N_PORTS ( ehci -> hcs_params ) ; u32 __iomem * status_reg , * hostpc_reg ; u32 temp , temp1 , status ; unsigned long flags ; int retval = 0 ; unsigned selector ; temp = wIndex & 0xff ; temp -= ( temp > 0 ) ; status_reg = & ehci -> regs -> port_status [ temp ] ; hostpc_reg = & ehci -> regs -> hostpc [ temp ] ; spin_lock_irqsave ( & ehci -> lock , flags ) ; switch ( typeReq ) { case ClearHubFeature : switch ( wValue ) { case C_HUB_LOCAL_POWER : case C_HUB_OVER_CURRENT : break ; default : error } break ; case ClearPortFeature : wIndex -- ; temp = ehci_readl ( ehci , status_reg ) ; temp &= ~ PORT_RWC_BITS ; switch ( wValue ) { case USB_PORT_FEAT_ENABLE : ehci_writel ( ehci , temp & ~ PORT_PE , status_reg ) ; break ; case USB_PORT_FEAT_C_ENABLE : ehci_writel ( ehci , temp | PORT_PEC , status_reg ) ; break ; case USB_PORT_FEAT_SUSPEND : if ( temp & PORT_RESET ) { error } if ( ehci -> no_selective_suspend ) { break ; } if ( ( hcd -> self . otg_port == ( wIndex + 1 ) ) && hcd -> self . b_hnp_enable ) { otg_start_hnp ( hcd -> usb_phy -> otg ) ; break ; } if ( ! ( temp & PORT_SUSPEND ) ) { break ; } if ( ( temp & PORT_PE ) == 0 ) { error } if ( ehci -> has_tdi_phy_lpm ) { temp1 = ehci_readl ( ehci , hostpc_reg ) ; ehci_writel ( ehci , temp1 & ~ HOSTPC_PHCD , hostpc_reg ) ; spin_unlock_irqrestore ( & ehci -> lock , flags ) ; msleep ( 5 ) ; spin_lock_irqsave ( & ehci -> lock , flags ) ; } temp &= ~ PORT_WAKE_BITS ; ehci_writel ( ehci , temp | PORT_RESUME , status_reg ) ; ehci -> reset_done [ wIndex ] = jiffies + msecs_to_jiffies ( USB_RESUME_TIMEOUT ) ; set_bit ( wIndex , & ehci -> resuming_ports ) ; usb_hcd_start_port_resume ( & hcd -> self , wIndex ) ; break ; case USB_PORT_FEAT_C_SUSPEND : clear_bit ( wIndex , & ehci -> port_c_suspend ) ; break ; case USB_PORT_FEAT_POWER : if ( HCS_PPC ( ehci -> hcs_params ) ) { spin_unlock_irqrestore ( & ehci -> lock , flags ) ; ehci_port_power ( ehci , wIndex , false ) ; spin_lock_irqsave ( & ehci -> lock , flags ) ; } break ; case USB_PORT_FEAT_C_CONNECTION : ehci_writel ( ehci , temp | PORT_CSC , status_reg ) ; break ; case USB_PORT_FEAT_C_OVER_CURRENT : ehci_writel ( ehci , temp | PORT_OCC , status_reg ) ; break ; case USB_PORT_FEAT_C_RESET : break ; default : error } ehci_readl ( ehci , & ehci -> regs -> command ) ; break ; case GetHubDescriptor : ehci_hub_descriptor ( ehci , ( usb_hub_descriptor * ) buf ) ; break ; case GetHubStatus : memset ( buf , 0 , 4 ) ; break ; case GetPortStatus : if ( ! wIndex || wIndex > ports ) { error } wIndex -- ; status = 0 ; temp = ehci_readl ( ehci , status_reg ) ; if ( temp & PORT_CSC ) { status |= USB_PORT_STAT_C_CONNECTION << 16 ; } if ( temp & PORT_PEC ) { status |= USB_PORT_STAT_C_ENABLE << 16 ; } if ( ( temp & PORT_OCC ) && ! ignore_oc ) { status |= USB_PORT_STAT_C_OVERCURRENT << 16 ; if ( ( ( temp & PORT_OC ) || ( ehci -> need_oc_pp_cycle ) ) && HCS_PPC ( ehci -> hcs_params ) ) { spin_unlock_irqrestore ( & ehci -> lock , flags ) ; ehci_port_power ( ehci , wIndex , false ) ; spin_lock_irqsave ( & ehci -> lock , flags ) ; temp = ehci_readl ( ehci , status_reg ) ; } } if ( ! ehci -> reset_done [ wIndex ] ) { if ( temp & PORT_RESUME ) { ehci -> reset_done [ wIndex ] = jiffies + msecs_to_jiffies ( 20 ) ; usb_hcd_start_port_resume ( & hcd -> self , wIndex ) ; set_bit ( wIndex , & ehci -> resuming_ports ) ; mod_timer ( & ehci_to_hcd ( ehci ) -> rh_timer , ehci -> reset_done [ wIndex ] ) ; } } if ( ! time_after_eq ( jiffies , ehci -> reset_done [ wIndex ] ) ) { } if ( test_bit ( wIndex , & ehci -> resuming_ports ) ) { clear_bit ( wIndex , & ehci -> suspended_ports ) ; set_bit ( wIndex , & ehci -> port_c_suspend ) ; ehci -> reset_done [ wIndex ] = 0 ; usb_hcd_end_port_resume ( & hcd -> self , wIndex ) ; temp &= ~ ( PORT_RWC_BITS | PORT_SUSPEND | PORT_RESUME ) ; ehci_writel ( ehci , temp , status_reg ) ; clear_bit ( wIndex , & ehci -> resuming_ports ) ; retval = ehci_handshake ( ehci , status_reg , PORT_RESUME , 0 , 2000 ) ; if ( retval != 0 ) { ehci_err ( ehci , "port %d resume error %d\n" , wIndex + 1 , retval ) ; error } temp = ehci_readl ( ehci , status_reg ) ; } else { status |= USB_PORT_STAT_C_RESET << 16 ; ehci -> reset_done [ wIndex ] = 0 ; ehci_writel ( ehci , temp & ~ ( PORT_RWC_BITS | PORT_RESET ) , status_reg ) ; retval = ehci_handshake ( ehci , status_reg , PORT_RESET , 0 , 1000 ) ; if ( retval != 0 ) { ehci_err ( ehci , "port %d reset error %d\n" , wIndex + 1 , retval ) ; error } temp = check_reset_complete ( ehci , wIndex , status_reg , ehci_readl ( ehci , status_reg ) ) ; } if ( ( temp & PORT_CONNECT ) && test_bit ( wIndex , & ehci -> companion_ports ) ) { temp &= ~ PORT_RWC_BITS ; temp |= PORT_OWNER ; ehci_writel ( ehci , temp , status_reg ) ; ehci_dbg ( ehci , "port %d -->companion\n" , wIndex + 1 ) ; temp = ehci_readl ( ehci , status_reg ) ; } if ( temp & PORT_CONNECT ) { status |= USB_PORT_STAT_CONNECTION ; if ( ehci -> has_hostpc ) { temp1 = ehci_readl ( ehci , hostpc_reg ) ; status |= ehci_port_speed ( ehci , temp1 ) ; } else { status |= ehci_port_speed ( ehci , temp ) ; } } if ( temp & PORT_PE ) { status |= USB_PORT_STAT_ENABLE ; } if ( temp & ( PORT_SUSPEND | PORT_RESUME ) ) { status |= USB_PORT_STAT_SUSPEND ; } if ( test_bit ( wIndex , & ehci -> suspended_ports ) ) { clear_bit ( wIndex , & ehci -> suspended_ports ) ; clear_bit ( wIndex , & ehci -> resuming_ports ) ; ehci -> reset_done [ wIndex ] = 0 ; if ( temp & PORT_PE ) { set_bit ( wIndex , & ehci -> port_c_suspend ) ; } usb_hcd_end_port_resume ( & hcd -> self , wIndex ) ; } if ( temp & PORT_OC ) { status |= USB_PORT_STAT_OVERCURRENT ; } if ( temp & PORT_RESET ) { status |= USB_PORT_STAT_RESET ; } if ( temp & PORT_POWER ) { status |= USB_PORT_STAT_POWER ; } if ( test_bit ( wIndex , & ehci -> port_c_suspend ) ) { status |= USB_PORT_STAT_C_SUSPEND << 16 ; } if ( status & ~ 0xffff ) { dbg_port ( ehci , "GetStatus" , wIndex + 1 , temp ) ; } put_unaligned_le32 ( status , buf ) ; break ; case SetHubFeature : switch ( wValue ) { case C_HUB_LOCAL_POWER : case C_HUB_OVER_CURRENT : break ; default : error } break ; case SetPortFeature : selector = wIndex >> 8 ; wIndex &= 0xff ; if ( unlikely ( ehci -> debug ) ) { if ( wIndex == HCS_DEBUG_PORT ( ehci -> hcs_params ) && ( readl ( & ehci -> debug -> control ) & DBGP_ENABLED ) ) { retval = - ENODEV ; error_exit } } if ( ! wIndex || wIndex > ports ) { error } wIndex -- ; temp = ehci_readl ( ehci , status_reg ) ; if ( temp & PORT_OWNER ) { break ; } temp &= ~ PORT_RWC_BITS ; switch ( wValue ) { case USB_PORT_FEAT_SUSPEND : if ( ehci -> no_selective_suspend ) { break ; } if ( ( temp & PORT_PE ) == 0 || ( temp & PORT_RESET ) != 0 ) { error } temp &= ~ PORT_WKCONN_E ; temp |= PORT_WKDISC_E | PORT_WKOC_E ; ehci_writel ( ehci , temp | PORT_SUSPEND , status_reg ) ; if ( ehci -> has_tdi_phy_lpm ) { spin_unlock_irqrestore ( & ehci -> lock , flags ) ; msleep ( 5 ) ; spin_lock_irqsave ( & ehci -> lock , flags ) ; temp1 = ehci_readl ( ehci , hostpc_reg ) ; ehci_writel ( ehci , temp1 | HOSTPC_PHCD , hostpc_reg ) ; temp1 = ehci_readl ( ehci , hostpc_reg ) ; ehci_dbg ( ehci , "Port%d phy low pwr mode %s\n" , wIndex , ( temp1 & HOSTPC_PHCD ) ?"succeeded" : "failed" ) ; } if ( ehci_has_fsl_susp_errata ( ehci ) ) { spin_unlock_irqrestore ( & ehci -> lock , flags ) ; usleep_range ( 10000 , 20000 ) ; spin_lock_irqsave ( & ehci -> lock , flags ) ; } set_bit ( wIndex , & ehci -> suspended_ports ) ; break ; case USB_PORT_FEAT_POWER : if ( HCS_PPC ( ehci -> hcs_params ) ) { spin_unlock_irqrestore ( & ehci -> lock , flags ) ; ehci_port_power ( ehci , wIndex , true ) ; spin_lock_irqsave ( & ehci -> lock , flags ) ; } break ; case USB_PORT_FEAT_RESET : if ( temp & ( PORT_SUSPEND | PORT_RESUME ) ) { error } if ( ( temp & ( PORT_PE | PORT_CONNECT ) ) == PORT_CONNECT && ! ehci_is_TDI ( ehci ) && PORT_USB11 ( temp ) ) { ehci_dbg ( ehci , "port %d low speed -->companion\n" , wIndex + 1 ) ; temp |= PORT_OWNER ; } else { temp |= PORT_RESET ; temp &= ~ PORT_PE ; ehci -> reset_done [ wIndex ] = jiffies + msecs_to_jiffies ( 50 ) ; if ( ehci_has_fsl_hs_errata ( ehci ) ) { temp |= ( 1 << PORTSC_FSL_PFSC ) ; } } ehci_writel ( ehci , temp , status_reg ) ; break ; case USB_PORT_FEAT_TEST : if ( selector == EHSET_TEST_SINGLE_STEP_SET_FEATURE ) { spin_unlock_irqrestore ( & ehci -> lock , flags ) ; retval = ehset_single_step_set_feature ( hcd , wIndex + 1 ) ; spin_lock_irqsave ( & ehci -> lock , flags ) ; break ; } if ( ! selector || selector > 5 ) { error } spin_unlock_irqrestore ( & ehci -> lock , flags ) ; ehci_quiesce ( ehci ) ; spin_lock_irqsave ( & ehci -> lock , flags ) ; while ( ports -- ) { u32 __iomem * sreg = & ehci -> regs -> port_status [ ports ] ; temp = ehci_readl ( ehci , sreg ) & ~ PORT_RWC_BITS ; if ( temp & PORT_PE ) { ehci_writel ( ehci , temp | PORT_SUSPEND , sreg ) ; } } spin_unlock_irqrestore ( & ehci -> lock , flags ) ; ehci_halt ( ehci ) ; spin_lock_irqsave ( & ehci -> lock , flags ) ; temp = ehci_readl ( ehci , status_reg ) ; temp |= selector << 16 ; ehci_writel ( ehci , temp , status_reg ) ; break ; default : error } ehci_readl ( ehci , & ehci -> regs -> command ) ; break ; default : error retval = - EPIPE ; } error_exit spin_unlock_irqrestore ( & ehci -> lock , flags ) ; return retval ; } 