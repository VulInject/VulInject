static int verb_components ( int argc , char * * argv , void * userdata ) { _cleanup_ ( ) LoopDevice * loop_device = NULL ; _cleanup_ ( ) char * mounted_dir = NULL ; _cleanup_ ( ) Set * names = NULL ; _cleanup_free_ char * * z = NULL ; char * * l = CONF_PATHS_STRV ( "" ) ; bool has_default_component = false ; int r ; assert ( argc <= 1 ) ; r = process_image ( false , & mounted_dir , & loop_device ) ; if ( r < 0 ) { return r ; } STRV_FOREACH ( , ) { _cleanup_closedir_ DIR * d = NULL ; _cleanup_free_ char * p = NULL ; r = chase_symlinks_and_opendir ( * i , arg_root , CHASE_PREFIX_ROOT , & p , & d ) ; if ( r == - ENOENT ) { continue ; } if ( r < 0 ) { return log_error_errno ( r , "Failed to open directory '%s': %m" , * i ) ; } for ( ; ; ) { _cleanup_free_ char * n = NULL ; struct dirent * de ; const char * e , * a ; de = readdir_ensure_type ( d ) ; if ( ! de ) { if ( errno != 0 ) { return log_error_errno ( errno , "Failed to enumerate directory '%s': %m" , p ) ; } break ; } if ( de -> d_type != DT_DIR ) { continue ; } if ( dot_or_dot_dot ( de -> d_name ) ) { continue ; } if ( streq ( de -> d_name , "sysupdate.d" ) ) { has_default_component = true ; continue ; } e = startswith ( de -> d_name , "sysupdate." ) ; a = endswith ( e , ".d" ) ; if ( ! a ) { continue ; } n = strndup ( e , a - e ) ; if ( ! n ) { return log_oom ( ) ; } r = component_name_valid ( n ) ; if ( r < 0 ) { return log_error_errno ( r , "Unable to validate component name: %m" ) ; } if ( r == 0 ) { continue ; } r = set_ensure_consume ( & names , & string_hash_ops_free , TAKE_PTR ( n ) ) ; if ( r < 0 && r != - EEXIST ) { return log_error_errno ( r , "Failed to add component to set: %m" ) ; } } } if ( ! has_default_component && set_isempty ( names ) ) { log_info ( "No components defined." ) ; return 0 ; } z = set_get_strv ( names ) ; if ( ! z ) { return log_oom ( ) ; } strv_sort ( z ) ; if ( has_default_component ) { printf ( "%s<default>%s\n" , ansi_highlight ( ) , ansi_normal ( ) ) ; } STRV_FOREACH ( , ) puts ( * i ) ; return 0 ; } 