int ni_write_inode ( struct inode * inode , int sync , const char * hint ) { int err = 0 , err2 ; struct ntfs_inode * ni = ntfs_i ( inode ) ; struct super_block * sb = inode -> i_sb ; struct ntfs_sb_info * sbi = sb -> s_fs_info ; bool re_dirty = false ; struct ATTR_STD_INFO * std ; struct rb_node * node , * next ; struct NTFS_DUP_INFO dup ; if ( is_bad_inode ( inode ) || sb_rdonly ( sb ) ) { return 0 ; } if ( ! ni_trylock ( ni ) ) { mark_inode_dirty_sync ( inode , NULL ) ; return 0 ; } if ( is_rec_inuse ( ni -> mi . mrec ) && ! ( sbi -> flags & NTFS_FLAGS_LOG_REPLAYING ) && inode -> i_nlink ) { bool modified = false ; std = ni_std ( ni ) ; if ( ! std ) { err = - EINVAL ; out } dup . m_time = kernel2nt ( & inode -> i_mtime ) ; if ( std -> m_time != dup . m_time ) { std -> m_time = dup . m_time ; modified = true ; } dup . c_time = kernel2nt ( & inode -> i_ctime ) ; if ( std -> c_time != dup . c_time ) { std -> c_time = dup . c_time ; modified = true ; } dup . a_time = kernel2nt ( & inode -> i_atime ) ; if ( std -> a_time != dup . a_time ) { std -> a_time = dup . a_time ; modified = true ; } dup . fa = ni -> std_fa ; if ( std -> fa != dup . fa ) { std -> fa = dup . fa ; modified = true ; } if ( modified ) { ni -> mi . dirty = true ; } if ( ! ntfs_is_meta_file ( sbi , inode -> i_ino ) && ( modified || ( ni -> ni_flags & NI_FLAG_UPDATE_PARENT ) ) && ( sb -> s_flags & SB_ACTIVE ) ) { dup . cr_time = std -> cr_time ; re_dirty = ni_update_parent ( ni , & dup , sync ) ; if ( re_dirty ) { ni -> ni_flags |= NI_FLAG_UPDATE_PARENT ; } else { ni -> ni_flags &= ~ NI_FLAG_UPDATE_PARENT ; } } if ( ni -> attr_list . size && ni -> attr_list . dirty ) { if ( inode -> i_ino != MFT_REC_MFT || sync ) { err = ni_try_remove_attr_list ( ni ) ; if ( err ) { out } } err = al_update ( ni , sync ) ; if ( err ) { out } } } for ( node = rb_first ( & ni -> mi_tree ) ; node ; node = next ) { struct mft_inode * mi = rb_entry ( node , mft_inode , node ) ; bool is_empty ; next = rb_next ( node ) ; if ( ! mi -> dirty ) { continue ; } is_empty = ! mi_enum_attr ( mi , NULL ) ; if ( is_empty ) { clear_rec_inuse ( mi -> mrec ) ; } err2 = mi_write ( mi , sync ) ; if ( ! err && err2 ) { err = err2 ; } if ( is_empty ) { ntfs_mark_rec_free ( sbi , mi -> rno , false ) ; rb_erase ( node , & ni -> mi_tree ) ; mi_put ( mi ) ; } } if ( ni -> mi . dirty ) { err2 = mi_write ( & ni -> mi , sync ) ; if ( ! err && err2 ) { err = err2 ; } } out ni_unlock ( ni ) ; if ( err ) { ntfs_err ( sb , "%s r=%lx failed, %d." , hint , inode -> i_ino , err ) ; ntfs_set_state ( sbi , NTFS_DIRTY_ERROR ) ; return err ; } if ( re_dirty ) { mark_inode_dirty_sync ( inode ) ; } return 0 ; } 