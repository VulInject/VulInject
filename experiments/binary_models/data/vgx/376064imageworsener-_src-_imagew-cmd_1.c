static int iwcmd_run ( struct params_struct * p ) { int retval = 0 ; struct iw_context * ctx = NULL ; struct iw_iodescr readdescr ; struct iw_iodescr writedescr ; char errmsg [ 200 ] ; struct iw_init_params init_params ; const char * s ; unsigned int profile ; int i ; int k ; int tmpflag ; memset ( & readdescr , 0 , sizeof ( iw_iodescr ) ) ; memset ( & writedescr , 0 , sizeof ( iw_iodescr ) ) ; if ( ! p -> noinfo ) { iwcmd_message ( p , "%s \xe2\x86\x92 %s\n" , p -> input_uri . filename , p -> output_uri . filename ) ; } init_params . api_version = IW_VERSION_INT ; init_params . userdata = ( void * ) p ; init_params . mallocfn = my_mallocfn ; init_params . freefn = my_freefn ; ctx = iw_create_context ( & init_params ) ; if ( ! ctx ) { done } iw_set_warning_fn ( ctx , my_warning_handler ) ; if ( p -> outfmt == IW_FORMAT_UNKNOWN ) { if ( p -> output_uri . scheme == IWCMD_SCHEME_FILE ) { p -> outfmt = iw_detect_fmt_from_filename ( p -> output_uri . filename ) ; } if ( p -> output_uri . scheme == IWCMD_SCHEME_CLIPBOARD ) { p -> outfmt = IW_FORMAT_BMP ; } } if ( p -> outfmt == IW_FORMAT_UNKNOWN ) { iw_set_error ( ctx , "Unknown output format; use -outfmt." ) ; done } if ( ! iw_is_output_fmt_supported ( p -> outfmt ) ) { s = iw_get_fmt_name ( p -> outfmt ) ; if ( ! s ) { s = "(unknown)" ; } iw_set_errorf ( ctx , "Writing %s files is not supported." , s ) ; done } if ( p -> output_uri . scheme == IWCMD_SCHEME_CLIPBOARD ) { if ( p -> outfmt != IW_FORMAT_BMP ) { iw_set_error ( ctx , "Only BMP images can be copied to the clipboard" ) ; done } } for ( i = 0 ; i < p -> options_count ; i ++ ) { iw_set_option ( ctx , p -> options [ i ] . name , p -> options [ i ] . val ) ; if ( ! strcmp ( p -> options [ i ] . name , "bmp:version" ) ) { if ( ! strcmp ( p -> options [ i ] . val , "auto" ) ) { p -> bmp_version = 5 ; } else { p -> bmp_version = iw_parse_int ( p -> options [ i ] . val ) ; } } } if ( p -> random_seed != 0 || p -> randomize ) { iw_set_random_seed ( ctx , p -> randomize , p -> random_seed ) ; } if ( p -> sample_type >= 0 ) { iw_set_value ( ctx , IW_VAL_OUTPUT_SAMPLE_TYPE , p -> sample_type ) ; } if ( p -> no_gamma ) { iw_set_value ( ctx , IW_VAL_DISABLE_GAMMA , 1 ) ; } if ( p -> intclamp ) { iw_set_value ( ctx , IW_VAL_INT_CLAMP , 1 ) ; } if ( p -> no_cslabel ) { iw_set_value ( ctx , IW_VAL_NO_CSLABEL , 1 ) ; } if ( p -> noopt_grayscale ) { iw_set_allow_opt ( ctx , IW_OPT_GRAYSCALE , 0 ) ; } if ( p -> noopt_palette ) { iw_set_allow_opt ( ctx , IW_OPT_PALETTE , 0 ) ; } if ( p -> noopt_reduceto8 ) { iw_set_allow_opt ( ctx , IW_OPT_16_TO_8 , 0 ) ; } if ( p -> noopt_stripalpha ) { iw_set_allow_opt ( ctx , IW_OPT_STRIP_ALPHA , 0 ) ; } if ( p -> noopt_binarytrns ) { iw_set_allow_opt ( ctx , IW_OPT_BINARY_TRNS , 0 ) ; } if ( p -> edge_policy_x >= 0 ) { iw_set_value ( ctx , IW_VAL_EDGE_POLICY_X , p -> edge_policy_x ) ; } if ( p -> edge_policy_y >= 0 ) { iw_set_value ( ctx , IW_VAL_EDGE_POLICY_Y , p -> edge_policy_y ) ; } if ( p -> grayscale_formula >= 0 ) { iw_set_value ( ctx , IW_VAL_GRAYSCALE_FORMULA , p -> grayscale_formula ) ; if ( p -> grayscale_formula == IW_GSF_WEIGHTED || p -> grayscale_formula == IW_GSF_ORDERBYVALUE ) { iw_set_grayscale_weights ( ctx , p -> grayscale_weight [ 0 ] , p -> grayscale_weight [ 1 ] , p -> grayscale_weight [ 2 ] ) ; } } if ( p -> page_to_read > 0 ) { iw_set_value ( ctx , IW_VAL_PAGE_TO_READ , p -> page_to_read ) ; } if ( p -> include_screen >= 0 ) { iw_set_value ( ctx , IW_VAL_INCLUDE_SCREEN , p -> include_screen ) ; } if ( p -> negate ) { iw_set_value ( ctx , IW_VAL_NEGATE_TARGET , 1 ) ; } if ( p -> input_uri . scheme == IWCMD_SCHEME_FILE ) { readdescr . read_fn = my_readfn ; readdescr . getfilesize_fn = my_getfilesizefn ; readdescr . fp = ( void * ) iwcmd_fopen ( p -> input_uri . filename , "rb" , errmsg , sizeof ( errmsg ) ) ; if ( ! readdescr . fp ) { iw_set_errorf ( ctx , "Failed to open %s for reading: %s" , p -> input_uri . filename , errmsg ) ; done } } if ( p -> input_uri . scheme == IWCMD_SCHEME_STDIN ) { ( void ) _setmode ( _fileno ( stdin ) , _O_BINARY ) ; readdescr . read_fn = my_readfn ; readdescr . fp = ( void * ) stdin ; } if ( p -> input_uri . scheme == IWCMD_SCHEME_CLIPBOARD ) { if ( ! iwcmd_open_clipboard_for_read ( p , ctx ) ) { done } readdescr . read_fn = my_clipboard_readfn ; readdescr . getfilesize_fn = my_clipboard_getfilesizefn ; readdescr . fp = NULL ; } else { iw_set_error ( ctx , "Unsupported input scheme" ) ; done } if ( p -> infmt == IW_FORMAT_UNKNOWN ) { switch ( p -> input_uri . scheme ) { case IWCMD_SCHEME_FILE : case IWCMD_SCHEME_STDIN : p -> infmt = detect_fmt_of_file ( p , ( FILE * ) readdescr . fp ) ; break ; case IWCMD_SCHEME_CLIPBOARD : p -> infmt = IW_FORMAT_BMP ; } } if ( p -> infmt == IW_FORMAT_UNKNOWN ) { iw_set_error ( ctx , "Unknown input file format." ) ; done } if ( p -> input_uri . scheme == IWCMD_SCHEME_CLIPBOARD && p -> infmt == IW_FORMAT_BMP ) { iw_set_value ( ctx , IW_VAL_BMP_NO_FILEHEADER , 1 ) ; } if ( ! iw_read_file_by_fmt ( ctx , & readdescr , p -> infmt ) ) { done } if ( p -> input_uri . scheme == IWCMD_SCHEME_FILE ) { fclose ( ( FILE * ) readdescr . fp ) ; } readdescr . fp = NULL ; if ( p -> reorient ) { iw_reorient_image ( ctx , p -> reorient ) ; } profile = iw_get_profile_by_fmt ( p -> outfmt ) ; if ( p -> bmp_trns && p -> outfmt == IW_FORMAT_BMP ) { profile |= IW_PROFILE_PALETTETRNS | IW_PROFILE_TRANSPARENCY | IW_PROFILE_RGB8_BKGD ; } if ( p -> outfmt == IW_FORMAT_BMP && p -> bmp_version >= 5 ) { profile |= IW_PROFILE_TRANSPARENCY ; } if ( p -> outfmt == IW_FORMAT_BMP ) { profile |= IW_PROFILE_16BPS ; } iw_set_output_profile ( ctx , profile ) ; iwcmd_set_bitdepth ( p , ctx ) ; if ( p -> cs_in_set ) { iw_set_input_colorspace ( ctx , & p -> cs_in ) ; } if ( p -> cs_out_set ) { iw_set_output_colorspace ( ctx , & p -> cs_out ) ; } if ( p -> rendering_intent != IW_INTENT_UNKNOWN ) { iw_set_value ( ctx , IW_VAL_INTENT , p -> rendering_intent ) ; } if ( p -> dither_all . family >= 0 ) { iw_set_dither_type ( ctx , IW_CHANNELTYPE_ALL , p -> dither_all . family , p -> dither_all . subtype ) ; } if ( p -> dither_nonalpha . family >= 0 ) { iw_set_dither_type ( ctx , IW_CHANNELTYPE_NONALPHA , p -> dither_nonalpha . family , p -> dither_nonalpha . subtype ) ; } for ( k = 0 ; k < 5 ; k ++ ) { if ( p -> dither [ k ] . family >= 0 ) { iw_set_dither_type ( ctx , k , p -> dither [ k ] . family , p -> dither [ k ] . subtype ) ; } } if ( p -> outfmt == IW_FORMAT_PBM ) { p -> color_count_all = 2 ; } if ( p -> color_count_all ) { iw_set_color_count ( ctx , IW_CHANNELTYPE_ALL , p -> color_count_all ) ; } if ( p -> color_count_nonalpha ) { iw_set_color_count ( ctx , IW_CHANNELTYPE_NONALPHA , p -> color_count_nonalpha ) ; } for ( k = 0 ; k < 5 ; k ++ ) { if ( p -> color_count [ k ] ) { iw_set_color_count ( ctx , k , p -> color_count [ k ] ) ; } } if ( p -> outfmt == IW_FORMAT_PGM || p -> outfmt == IW_FORMAT_PBM ) { p -> grayscale = 1 ; p -> condgrayscale = 0 ; } if ( p -> condgrayscale ) { if ( iw_get_value ( ctx , IW_VAL_INPUT_NATIVE_GRAYSCALE ) ) { iw_set_value ( ctx , IW_VAL_CVT_TO_GRAYSCALE , 1 ) ; } } if ( p -> grayscale ) { iw_set_value ( ctx , IW_VAL_CVT_TO_GRAYSCALE , 1 ) ; } for ( k = 0 ; k < 3 ; k ++ ) { if ( p -> offset_h [ k ] != 0.0 ) { iw_set_channel_offset ( ctx , k , IW_DIMENSION_H , p -> offset_h [ k ] ) ; } if ( p -> offset_v [ k ] != 0.0 ) { iw_set_channel_offset ( ctx , k , IW_DIMENSION_V , p -> offset_v [ k ] ) ; } } if ( p -> apply_bkgd ) { if ( ! p -> no_gamma ) { struct iw_csdescr cs_srgb ; iw_make_srgb_csdescr_2 ( & cs_srgb ) ; for ( k = 0 ; k < 3 ; k ++ ) { p -> bkgd . c [ k ] = iw_convert_sample_to_linear ( p -> bkgd . c [ k ] , & cs_srgb ) ; if ( p -> bkgd_checkerboard ) { p -> bkgd2 . c [ k ] = iw_convert_sample_to_linear ( p -> bkgd2 . c [ k ] , & cs_srgb ) ; } } } iw_set_apply_bkgd_2 ( ctx , & p -> bkgd ) ; if ( p -> bkgd_checkerboard ) { iw_set_bkgd_checkerboard_2 ( ctx , p -> bkgd_check_size , & p -> bkgd2 ) ; iw_set_bkgd_checkerboard_origin ( ctx , p -> bkgd_check_origin_x , p -> bkgd_check_origin_y ) ; } } if ( p -> use_bkgd_label ) { iw_set_value ( ctx , IW_VAL_USE_BKGD_LABEL , 1 ) ; } if ( p -> no_bkgd_label ) { if ( p -> no_bkgd_label ) { iw_set_value ( ctx , IW_VAL_NO_BKGD_LABEL , 1 ) ; } } if ( p -> bkgd_label_set ) { iw_set_output_bkgd_label_2 ( ctx , & p -> bkgd_label ) ; } p -> src_width = iw_get_value ( ctx , IW_VAL_INPUT_WIDTH ) ; p -> src_height = iw_get_value ( ctx , IW_VAL_INPUT_HEIGHT ) ; if ( p -> use_crop ) { if ( p -> crop_x < 0 ) { p -> crop_x = 0 ; } if ( p -> crop_y < 0 ) { p -> crop_y = 0 ; } if ( p -> crop_x > p -> src_width - 1 ) { p -> crop_x = p -> src_width - 1 ; } if ( p -> crop_y > p -> src_height - 1 ) { p -> crop_y = p -> src_height - 1 ; } if ( p -> crop_w ( 0 || p -> crop_w ) p -> src_width - p -> crop_x ) { p -> crop_w = p -> src_width - p -> crop_x ; } if ( p -> crop_h ( 0 || p -> crop_h ) p -> src_height - p -> crop_y ) { p -> crop_h = p -> src_height - p -> crop_y ; } if ( p -> crop_w < 1 ) { p -> crop_w = 1 ; } if ( p -> crop_h < 1 ) { p -> crop_h = 1 ; } p -> src_width = p -> crop_w ; p -> src_height = p -> crop_h ; } figure_out_size_and_density ( p , ctx ) ; if ( ( p -> edge_policy_x != IW_EDGE_POLICY_REPLICATE && p -> edge_policy_x != IW_EDGE_POLICY_TRANSPARENT ) || ( p -> edge_policy_y != IW_EDGE_POLICY_REPLICATE && p -> edge_policy_y != IW_EDGE_POLICY_TRANSPARENT ) ) { if ( p -> imagesize_set ) { iw_warning ( ctx , "\xe2\x80\x9c-edge t\xe2\x80\x9d is recommended when using -imagesize" ) ; } if ( p -> translate_set ) { iw_warning ( ctx , "\xe2\x80\x9c-edge t\xe2\x80\x9d is recommended when using -translate" ) ; } } if ( p -> translate_set ) { if ( p -> translate_src_flag ) { if ( p -> translate_x != 0.0 ) { p -> translate_x *= ( ( double ) p -> dst_width ) / p -> src_width ; } if ( p -> translate_y != 0.0 ) { p -> translate_y *= ( ( double ) p -> dst_height ) / p -> src_height ; } } iw_set_value_dbl ( ctx , IW_VAL_TRANSLATE_X , p -> translate_x ) ; iw_set_value_dbl ( ctx , IW_VAL_TRANSLATE_Y , p -> translate_y ) ; } tmpflag = 0 ; if ( p -> resize_blur_x . is_set && ! p -> resize_alg_x . family ) { if ( ! p -> nowarn ) { iwcmd_warning ( p , "Notice: Selecting gaussian filter for blurring\n" ) ; tmpflag = 1 ; } p -> resize_alg_x . family = IW_RESIZETYPE_GAUSSIAN ; } if ( p -> resize_blur_y . is_set && ! p -> resize_alg_y . family ) { if ( ! p -> nowarn && ! tmpflag ) { iwcmd_warning ( p , "Notice: Selecting gaussian filter for blurring\n" ) ; } p -> resize_alg_y . family = IW_RESIZETYPE_GAUSSIAN ; } if ( p -> resize_alg_x . family ) { if ( p -> resize_blur_x . interpolate && p -> dst_width < p -> src_width ) { p -> resize_blur_x . blur *= ( ( double ) p -> dst_width ) / p -> src_width ; } iwcmd_set_resize ( ctx , IW_DIMENSION_H , & p -> resize_alg_x , & p -> resize_blur_x ) ; } if ( p -> resize_alg_y . family ) { if ( p -> resize_blur_y . interpolate && p -> dst_height < p -> src_height ) { p -> resize_blur_y . blur *= ( ( double ) p -> dst_height ) / p -> src_height ; } iwcmd_set_resize ( ctx , IW_DIMENSION_V , & p -> resize_alg_y , & p -> resize_blur_y ) ; } if ( p -> noinfo ) { } if ( p -> dst_width == p -> src_width && p -> dst_height == p -> src_height ) { iwcmd_message ( p , "Processing: %d\xc3\x97%d\n" , p -> dst_width , p -> dst_height ) ; } else { iwcmd_message ( p , "Resizing: %d\xc3\x97%d \xe2\x86\x92 %d\xc3\x97%d\n" , p -> src_width , p -> src_height , p -> dst_width , p -> dst_height ) ; } iw_set_output_canvas_size ( ctx , p -> dst_width , p -> dst_height ) ; if ( p -> imagesize_set ) { iw_set_output_image_size ( ctx , p -> imagesize_x , p -> imagesize_y ) ; } if ( p -> use_crop ) { iw_set_input_crop ( ctx , p -> crop_x , p -> crop_y , p -> crop_w , p -> crop_h ) ; } if ( ! iw_process_image ( ctx ) ) { done } if ( p -> compression > 0 ) { iw_set_value ( ctx , IW_VAL_COMPRESSION , p -> compression ) ; } if ( p -> interlace ) { iw_set_value ( ctx , IW_VAL_OUTPUT_INTERLACED , 1 ) ; } if ( p -> output_uri . scheme == IWCMD_SCHEME_FILE ) { writedescr . write_fn = my_writefn ; writedescr . seek_fn = my_seekfn ; writedescr . fp = ( void * ) iwcmd_fopen ( p -> output_uri . filename , "wb" , errmsg , sizeof ( errmsg ) ) ; if ( ! writedescr . fp ) { iw_set_errorf ( ctx , "Failed to open %s for writing: %s" , p -> output_uri . filename , errmsg ) ; done } } if ( p -> output_uri . scheme == IWCMD_SCHEME_STDOUT ) { ( void ) _setmode ( _fileno ( stdout ) , _O_BINARY ) ; writedescr . write_fn = my_writefn ; writedescr . fp = ( void * ) stdout ; } if ( p -> output_uri . scheme == IWCMD_SCHEME_CLIPBOARD ) { writedescr . write_fn = my_clipboard_writefn ; writedescr . seek_fn = my_clipboard_w_seekfn ; } else { iw_set_error ( ctx , "Unsupported output scheme" ) ; done } if ( ! iw_write_file_by_fmt ( ctx , & writedescr , p -> outfmt ) ) { done } if ( p -> output_uri . scheme == IWCMD_SCHEME_FILE ) { fclose ( ( FILE * ) writedescr . fp ) ; } if ( p -> output_uri . scheme == IWCMD_SCHEME_CLIPBOARD ) { finish_clipboard_write ( p , ctx ) ; } writedescr . fp = NULL ; retval = 1 ; done iwcmd_close_clipboard_r ( p , ctx ) ; if ( readdescr . fp ) { fclose ( ( FILE * ) readdescr . fp ) ; } if ( writedescr . fp ) { fclose ( ( FILE * ) writedescr . fp ) ; } if ( ctx ) { if ( iw_get_errorflag ( ctx ) ) { iwcmd_error ( p , "imagew error: %s\n" , iw_get_errormsg ( ctx , errmsg , sizeof ( errmsg ) ) ) ; } } iw_destroy_context ( ctx ) ; for ( i = 0 ; i < p -> options_count ; i ++ ) { free ( p -> options [ i ] . name ) ; free ( p -> options [ i ] . val ) ; } p -> options_count = 0 ; return retval ; } 