static int mhi_fw_load_bhi ( struct mhi_controller * mhi_cntrl , dma_addr_t dma_addr , size_t size ) { u32 tx_status , val , session_id ; int i , ret ; void __iomem * base = mhi_cntrl -> bhi ; rwlock_t * pm_lock = & mhi_cntrl -> pm_lock ; struct device * dev = & mhi_cntrl -> mhi_dev -> dev ; { char * name ; u32 offset ; } , error_reg [ ] { { "ERROR_CODE" BHI_ERRCODE } { "ERROR_DBG1" BHI_ERRDBG1 } { "ERROR_DBG2" BHI_ERRDBG2 } { "ERROR_DBG3" BHI_ERRDBG3 } { NULL } } ; read_lock_bh ( pm_lock , NULL ) ; if ( ! MHI_REG_ACCESS_VALID ( mhi_cntrl -> pm_state ) ) { read_unlock_bh ( pm_lock ) ; invalid_pm_state } session_id = MHI_RANDOM_U32_NONZERO ( BHI_TXDB_SEQNUM_BMSK ) ; dev_dbg ( dev , "Starting image download via BHI. Session ID: %u\n" , session_id ) ; mhi_write_reg ( mhi_cntrl , base , BHI_STATUS , 0 ) ; mhi_write_reg ( mhi_cntrl , base , BHI_IMGADDR_HIGH , upper_32_bits ( dma_addr ) ) ; mhi_write_reg ( mhi_cntrl , base , BHI_IMGADDR_LOW , lower_32_bits ( dma_addr ) ) ; mhi_write_reg ( mhi_cntrl , base , BHI_IMGSIZE , size ) ; mhi_write_reg ( mhi_cntrl , base , BHI_IMGTXDB , session_id ) ; read_unlock_bh ( pm_lock ) ; ret = wait_event_timeout ( mhi_cntrl -> state_event , MHI_PM_IN_ERROR_STATE ( mhi_cntrl -> pm_state ) || mhi_read_reg_field ( mhi_cntrl , base , BHI_STATUS , BHI_STATUS_MASK , & tx_status ) || tx_status , msecs_to_jiffies ( mhi_cntrl -> timeout_ms ) ) ; if ( MHI_PM_IN_ERROR_STATE ( mhi_cntrl -> pm_state ) ) { invalid_pm_state } if ( tx_status == BHI_STATUS_ERROR ) { dev_err ( dev , "Image transfer failed\n" ) ; read_lock_bh ( pm_lock ) ; if ( MHI_REG_ACCESS_VALID ( mhi_cntrl -> pm_state ) ) { for ( i = 0 ; error_reg [ i ] . name ; i ++ ) { ret = mhi_read_reg ( mhi_cntrl , base , error_reg [ i ] . offset , & val ) ; if ( ret ) { break ; } dev_err ( dev , "Reg: %s value: 0x%x\n" , error_reg [ i ] . name , val ) ; } } read_unlock_bh ( pm_lock ) ; invalid_pm_state } return ( ! ret ) ?- ETIMEDOUT : 0 ; invalid_pm_state return - EIO ; } 