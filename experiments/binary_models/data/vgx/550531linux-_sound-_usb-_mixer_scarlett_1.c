int snd_scarlett_controls_create ( struct usb_mixer_interface * mixer ) { int err , i , o ; char mx [ SNDRV_CTL_ELEM_ID_NAME_MAXLEN ] ; const struct scarlett_device_info * info ; struct usb_mixer_elem_info * elem ; static char sample_rate_buffer [ 4 ] { '\x80' '\xbb' '\x00' '\x00' } ; ; switch ( mixer -> chip -> usb_id ) { case USB_ID ( 0x1235 , 0x8012 ) : info = & s6i6_info ; break ; case USB_ID ( 0x1235 , 0x8002 ) : info = & s8i6_info ; break ; case USB_ID ( 0x1235 , 0x8004 ) : info = & s18i6_info ; break ; case USB_ID ( 0x1235 , 0x8014 ) : info = & s18i8_info ; break ; case USB_ID ( 0x1235 , 0x800c ) : info = & s18i20_info ; break ; default : return - EINVAL ; } err = scarlett_controls_create_generic ( mixer , info ) ; if ( err < 0 ) { return err ; } for ( i = 0 ; i < info -> matrix_in ; i ++ ) { snprintf ( mx , sizeof ( mx ) , "Matrix %02d Input Playback Route" , i + 1 ) ; err = add_new_ctl ( mixer , & usb_scarlett_ctl_dynamic_enum , scarlett_ctl_enum_resume , 0x32 , 0x06 , i , USB_MIXER_S16 , 1 , mx , & info -> opt_matrix , & elem ) ; if ( err < 0 ) { return err ; } for ( o = 0 ; o < info -> matrix_out ; o ++ ) { sprintf ( mx , "Matrix %02d Mix %c Playback Volume" , i + 1 , o + 'A' ) ; err = add_new_ctl ( mixer , & usb_scarlett_ctl , scarlett_ctl_resume , 0x3c , 0x00 , ( i << 3 ) + ( o & 0x07 ) , USB_MIXER_S16 , 1 , mx , NULL , & elem ) ; if ( err < 0 ) { return err ; } } } for ( i = 0 ; i < info -> input_len ; i ++ ) { snprintf ( mx , sizeof ( mx ) , "Input Source %02d Capture Route" , i + 1 ) ; err = add_new_ctl ( mixer , & usb_scarlett_ctl_dynamic_enum , scarlett_ctl_enum_resume , 0x34 , 0x00 , i , USB_MIXER_S16 , 1 , mx , & info -> opt_master , & elem ) ; if ( err < 0 ) { return err ; } } err = add_new_ctl ( mixer , & usb_scarlett_ctl_enum , scarlett_ctl_enum_resume , 0x28 , 0x01 , 0 , USB_MIXER_U8 , 1 , "Sample Clock Source" , & opt_clock , & elem ) ; if ( err < 0 ) { return err ; } err = add_new_ctl ( mixer , & usb_scarlett_ctl_sync , NULL , 0x3c , 0x00 , 2 , USB_MIXER_U8 , 1 , "Sample Clock Sync Status" , & opt_sync , & elem ) ; if ( err < 0 ) { return err ; } err = snd_usb_ctl_msg ( mixer -> chip -> dev , usb_sndctrlpipe ( mixer -> chip -> dev , 0 ) , UAC2_CS_CUR , USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT , 0x0100 , snd_usb_ctrl_intf ( mixer -> chip ) | ( 0x29 << 8 ) , sample_rate_buffer , 4 ) ; if ( err < 0 ) { return err ; } return err ; } 