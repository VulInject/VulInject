static void _rpc_prolog ( slurm_msg_t * msg ) { int rc = SLURM_SUCCESS , alt_rc = SLURM_ERROR , node_id = 0 ; prolog_launch_msg_t * req = ( prolog_launch_msg_t * ) msg -> data ; job_env_t job_env ; bool first_job_run ; uint32_t jobid ; if ( req == NULL ) { return ; } if ( ! _slurm_authorized_user ( msg -> auth_uid ) ) { error ( "REQUEST_LAUNCH_PROLOG request from uid %u" , msg -> auth_uid ) ; return ; } if ( ! req -> user_name ) { req -> user_name = uid_to_string ( req -> uid ) ; } if ( slurm_send_rc_msg ( msg , rc ) < 0 ) { error ( "%s: Error talking to slurmctld: %m" , __func__ ) ; } slurm_cred_handle_reissue ( conf -> vctx , req -> cred , false ) ; slurm_mutex_lock ( & prolog_mutex ) ; first_job_run = ! slurm_cred_jobid_cached ( conf -> vctx , req -> job_id ) ; if ( first_job_run ) { node_id = nodelist_find ( req -> nodes , conf -> node_name ) ; if ( slurm_conf . prolog_flags & PROLOG_FLAG_CONTAIN && ( ( rc = _make_prolog_mem_container ( msg ) ) != SLURM_SUCCESS ) ) { error ( "%s: aborting prolog due to _make_prolog_mem_container failure: %s. Consider increasing cred_expire window if job prologs take large amount of time." , __func__ , slurm_strerror ( rc ) ) ; slurm_mutex_unlock ( & prolog_mutex ) ; notify_result } slurm_cred_insert_jobid ( conf -> vctx , req -> job_id ) ; _add_job_running_prolog ( req -> job_id ) ; slurm_cond_broadcast ( & conf -> prolog_running_cond ) ; slurm_mutex_unlock ( & prolog_mutex ) ; gres_g_prep_set_env ( & job_env . gres_job_env , req -> job_gres_prep , node_id ) ; job_env . jobid = req -> job_id ; job_env . step_id = 0 ; job_env . node_aliases = req -> alias_list ; job_env . node_list = req -> nodes ; job_env . het_job_id = req -> het_job_id ; job_env . partition = req -> partition ; job_env . spank_job_env = req -> spank_job_env ; job_env . spank_job_env_size = req -> spank_job_env_size ; job_env . work_dir = req -> work_dir ; job_env . uid = req -> uid ; job_env . gid = req -> gid ; job_env . user_name = req -> user_name ; if ( req -> het_job_id && ( req -> het_job_id != NO_VAL ) ) { jobid = req -> het_job_id ; } else { jobid = req -> job_id ; } jobid = req -> job_id ; if ( ( rc = container_g_create ( jobid , req -> uid ) ) ) { error ( "container_g_create(%u): %m" , req -> job_id ) ; } else { rc = _run_prolog ( & job_env , req -> cred , false ) ; } _free_job_env ( & job_env ) ; if ( rc ) { int term_sig = 0 , exit_status = 0 ; if ( WIFSIGNALED ( rc ) ) { term_sig = WTERMSIG ( rc ) ; } if ( WIFEXITED ( rc ) ) { exit_status = WEXITSTATUS ( rc ) ; } error ( "[job %u] prolog failed status=%d:%d" , req -> job_id , exit_status , term_sig ) ; rc = ESLURMD_PROLOG_FAILED ; } if ( ( rc == SLURM_SUCCESS ) && ( slurm_conf . prolog_flags & PROLOG_FLAG_CONTAIN ) ) { rc = _spawn_prolog_stepd ( msg ) ; } if ( rc ) { slurm_cred_revoke ( conf -> vctx , req -> job_id , time ( NULL ) , time ( NULL ) ) ; } _remove_job_running_prolog ( req -> job_id ) ; } else { slurm_mutex_unlock ( & prolog_mutex ) ; } notify_result if ( req -> het_job_id && ( req -> het_job_id != NO_VAL ) ) { jobid = req -> het_job_id ; } else { jobid = req -> job_id ; } while ( alt_rc != SLURM_SUCCESS ) { if ( ! ( slurm_conf . prolog_flags & PROLOG_FLAG_NOHOLD ) ) { alt_rc = _notify_slurmctld_prolog_fini ( req -> job_id , rc ) ; } else { alt_rc = SLURM_SUCCESS ; } if ( rc != SLURM_SUCCESS ) { alt_rc = _launch_job_fail ( jobid , rc ) ; send_registration_msg ( rc ) ; } if ( alt_rc != SLURM_SUCCESS ) { info ( "%s: Retrying prolog complete RPC for JobId=%u [sleeping %us]" , __func__ , req -> job_id , RETRY_DELAY ) ; sleep ( RETRY_DELAY ) ; } } } 