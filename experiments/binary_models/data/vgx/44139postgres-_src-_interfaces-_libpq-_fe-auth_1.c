static int pg_password_sendauth ( PGconn * conn , const char * password , AuthRequest areq ) { int ret ; char * crypt_pwd = NULL ; const char * pwd_to_send ; char md5Salt [ 4 ] ; if ( areq == AUTH_REQ_MD5 ) { if ( pqGetnchar ( md5Salt , 4 , conn ) ) { return STATUS_ERROR ; } } switch ( areq ) { case AUTH_REQ_MD5 : { char * crypt_pwd2 ; const char * errstr = NULL ; crypt_pwd = malloc ( 2 * ( MD5_PASSWD_LEN + 1 ) ) ; if ( ! crypt_pwd ) { libpq_append_conn_error ( conn , "out of memory" ) ; return STATUS_ERROR ; } crypt_pwd2 = crypt_pwd + MD5_PASSWD_LEN + 1 ; if ( ! pg_md5_encrypt ( password , conn -> pguser , strlen ( conn -> pguser ) , crypt_pwd2 , & errstr ) ) { libpq_append_conn_error ( conn , "could not encrypt password: %s" , errstr ) ; return STATUS_ERROR ; } if ( ! pg_md5_encrypt ( crypt_pwd2 + strlen ( "md5" ) , md5Salt , 4 , crypt_pwd , & errstr ) ) { libpq_append_conn_error ( conn , "could not encrypt password: %s" , errstr ) ; free ( crypt_pwd ) ; return STATUS_ERROR ; } pwd_to_send = crypt_pwd ; break ; } case AUTH_REQ_PASSWORD : pwd_to_send = password ; break ; default : return STATUS_ERROR ; } ret = pqPacketSend ( conn , 'p' , pwd_to_send , strlen ( pwd_to_send ) + 1 ) ; free ( crypt_pwd ) ; return ret ; } 