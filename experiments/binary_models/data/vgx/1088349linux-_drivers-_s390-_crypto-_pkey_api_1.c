static int pkey_nonccatok2pkey ( const u8 * key , u32 keylen , struct pkey_protkey * protkey ) { int rc = - EINVAL ; u8 * tmpbuf = NULL ; struct keytoken_header * hdr = ( keytoken_header * ) key ; switch ( hdr -> version ) { case TOKVER_PROTECTED_KEY : { struct protaeskeytoken * t ; if ( keylen != sizeof ( protaeskeytoken ) ) { out } t = ( protaeskeytoken * ) key ; protkey -> len = t -> len ; protkey -> type = t -> keytype ; memcpy ( protkey -> protkey , t -> protkey , sizeof ( protkey -> protkey ) ) ; rc = pkey_verifyprotkey ( protkey ) ; break ; } case TOKVER_CLEAR_KEY : { struct clearaeskeytoken * t ; struct pkey_clrkey ckey ; u_tmpbuf { u8 skey [ SECKEYBLOBSIZE ] ; u8 ep11key [ MAXEP11AESKEYBLOBSIZE ] ; } size_t tmpbuflen = sizeof ( u_tmpbuf ) ; if ( keylen < sizeof ( clearaeskeytoken ) ) { out } t = ( clearaeskeytoken * ) key ; if ( keylen != sizeof ( * t ) + t -> len ) { out } if ( ( t -> keytype == PKEY_KEYTYPE_AES_128 && t -> len == 16 ) || ( t -> keytype == PKEY_KEYTYPE_AES_192 && t -> len == 24 ) || ( t -> keytype == PKEY_KEYTYPE_AES_256 && t -> len == 32 ) ) { memcpy ( ckey . clrkey , t -> clearkey , t -> len ) ; } else { out } tmpbuf = kmalloc ( tmpbuflen , GFP_ATOMIC ) ; if ( ! tmpbuf ) { rc = - ENOMEM ; out } rc = pkey_clr2protkey ( t -> keytype , & ckey , protkey ) ; if ( rc == 0 ) { break ; } zcrypt_wait_api_operational ( ) ; rc = cca_clr2seckey ( 0xFFFF , 0xFFFF , t -> keytype , ckey . clrkey , tmpbuf ) ; if ( rc == 0 ) { rc = pkey_skey2pkey ( tmpbuf , protkey ) ; } if ( rc == 0 ) { break ; } rc = pkey_clr2ep11key ( ckey . clrkey , t -> len , tmpbuf , & tmpbuflen ) ; if ( rc == 0 ) { rc = pkey_ep11key2pkey ( tmpbuf , protkey ) ; } DEBUG_ERR ( "%s unable to build protected key from clear" , __func__ ) ; break ; } case TOKVER_EP11_AES : { rc = ep11_check_aes_key ( debug_info , 3 , key , keylen , 1 ) ; if ( rc ) { out } rc = pkey_ep11key2pkey ( key , protkey ) ; break ; } case TOKVER_EP11_AES_WITH_HEADER : rc = ep11_check_aes_key_with_hdr ( debug_info , 3 , key , keylen , 1 ) ; if ( rc ) { out } rc = pkey_ep11key2pkey ( key + sizeof ( ep11kblob_header ) , protkey ) ; break ; default : DEBUG_ERR ( "%s unknown/unsupported non-CCA token version %d\n" , __func__ , hdr -> version ) ; rc = - EINVAL ; } out return rc ; } 