int evbuffer_launch_read_ ( struct evbuffer * buf , size_t at_most , struct event_overlapped * ol ) { struct evbuffer_overlapped * buf_o = upcast_evbuffer ( buf ) ; int r = - 1 , i ; int nvecs ; int npin = 0 ; struct evbuffer_chain * chain = NULL , * * chainp ; DWORD bytesRead ; DWORD flags = 0 ; struct evbuffer_iovec vecs [ MAX_WSABUFS ] ; if ( ! buf_o ) { return - 1 ; } EVBUFFER_LOCK ( buf ) ; EVUTIL_ASSERT ( ! buf_o -> write_in_progress ) ; if ( buf -> freeze_end || buf_o -> read_in_progress ) { done } buf_o -> first_pinned = NULL ; buf_o -> n_buffers = 0 ; memset ( buf_o -> buffers , 0 , sizeof ( buf_o -> buffers ) ) ; if ( evbuffer_expand_fast_ ( buf , at_most , MAX_WSABUFS ) == - 1 ) { done } evbuffer_freeze ( buf , 0 ) ; nvecs = evbuffer_read_setup_vecs_ ( buf , at_most , vecs , MAX_WSABUFS , & chainp , 1 ) ; for ( i = 0 ; i < nvecs ; ++ i ) { WSABUF_FROM_EVBUFFER_IOV ( & buf_o -> buffers [ i ] , & vecs [ i ] ) ; } buf_o -> n_buffers = nvecs ; buf_o -> first_pinned = chain = * chainp ; npin = 0 ; for ( ; chain ; chain = chain -> next ) { evbuffer_chain_pin_ ( chain , EVBUFFER_MEM_PINNED_R ) ; ++ npin ; } EVUTIL_ASSERT ( npin == nvecs ) ; evbuffer_incref_ ( buf ) ; if ( WSARecv ( buf_o -> fd , buf_o -> buffers , nvecs , & bytesRead , & flags , & ol -> overlapped , NULL ) ) { int error = WSAGetLastError ( ) ; if ( error != WSA_IO_PENDING ) { pin_release ( buf_o , EVBUFFER_MEM_PINNED_R ) ; evbuffer_unfreeze ( buf , 0 ) ; evbuffer_free ( buf ) ; done } } r = 0 ; done EVBUFFER_UNLOCK ( buf ) ; return r ; } 