static int mv_u3d_ep_queue ( struct usb_ep * _ep , struct usb_request * _req , gfp_t gfp_flags ) { struct mv_u3d_ep * ep ; struct mv_u3d_req * req ; struct mv_u3d * u3d ; unsigned long flags ; int is_first_req = 0 ; ep = container_of ( _ep , mv_u3d_ep , ep ) ; u3d = ep -> u3d ; req = container_of ( _req , mv_u3d_req , req ) ; if ( ! ep -> ep_num && u3d -> ep0_state == MV_U3D_STATUS_STAGE && ! _req -> length ) { dev_dbg ( u3d -> dev , "ep0 status stage\n" ) ; u3d -> ep0_state = MV_U3D_WAIT_FOR_SETUP ; return 0 ; } dev_dbg ( u3d -> dev , "%s: %s, req: 0x%p\n" , __func__ , _ep -> name , req ) ; if ( ! req -> req . complete || ! req -> req . buf || ! list_empty ( & req -> queue ) ) { dev_err ( u3d -> dev , "%s, bad params, _req: 0x%p," "req->req.complete: 0x%p, req->req.buf: 0x%p," "list_empty: 0x%x\n" , __func__ , _req , req -> req . complete , req -> req . buf , list_empty ( & req -> queue ) ) ; return - EINVAL ; } if ( unlikely ( ! ep -> ep . desc ) ) { dev_err ( u3d -> dev , "%s, bad ep\n" , __func__ ) ; return - EINVAL ; } if ( ep -> ep . desc -> bmAttributes == USB_ENDPOINT_XFER_ISOC ) { if ( req -> req . length > ep -> ep . maxpacket ) { return - EMSGSIZE ; } } if ( ! u3d -> driver || u3d -> gadget . speed == USB_SPEED_UNKNOWN ) { dev_err ( u3d -> dev , "bad params of driver/speed\n" ) ; return - ESHUTDOWN ; } req -> ep = ep ; spin_lock_irqsave ( & ep -> req_lock , flags ) ; is_first_req = list_empty ( & ep -> req_list ) ; list_add_tail ( & req -> list , & ep -> req_list ) ; spin_unlock_irqrestore ( & ep -> req_lock , flags ) ; if ( ! is_first_req ) { dev_dbg ( u3d -> dev , "list is not empty\n" ) ; return 0 ; } dev_dbg ( u3d -> dev , "call mv_u3d_start_queue from usb_ep_queue\n" ) ; spin_lock_irqsave ( & u3d -> lock , flags ) ; mv_u3d_start_queue ( ep ) ; spin_unlock_irqrestore ( & u3d -> lock , flags ) ; return 0 ; } 