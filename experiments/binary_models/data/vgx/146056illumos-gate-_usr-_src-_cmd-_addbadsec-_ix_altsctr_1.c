static void get_badsec ( void ) { int cnt ; struct badsec_lst * blc_p ; blkaddr_t curbad ; blkaddr_t maxsec = ( blkaddr_t ) dkg . dkg_nhead * dkg . dkg_ncyl * dkg . dkg_nsect ; struct alts_ent * growbadp ; int i ; cnt = count_badsec ( ) ; if ( ! cnt ) { ap -> ap_gbadp = NULL ; ap -> ap_gbadcnt = 0 ; } else { ap -> ap_gbadp = ( alts_ent * ) malloc ( cnt * ALTS_ENT_SIZE ) ; for ( growbadp = ap -> ap_gbadp , cnt = 0 , blc_p = badsl_chain ; blc_p ; blc_p = blc_p -> bl_nxt ) { for ( i = 0 ; i < blc_p -> bl_cnt ; i ++ ) { curbad = blc_p -> bl_sec [ i ] ; if ( curbad < ( blkaddr_t ) dkg . dkg_nsect ) { ( void ) fprintf ( stderr , "Ignoring bad sector %ld which is in first" " track of the drive.\n" , curbad ) ; continue ; } if ( curbad >= maxsec ) { ( void ) fprintf ( stderr , "Ignoring bad sector %ld which is past" " the end of the drive.\n" , curbad ) ; continue ; } growbadp [ cnt ] . bad_start = curbad ; growbadp [ cnt ] . bad_end = curbad ; cnt ++ ; } } } ap -> ap_gbadcnt = cnt ; } 