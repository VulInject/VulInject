static krb5_error_code make_external_lucid_ctx_v1 ( krb5_gss_ctx_id_rec * gctx , int version , void * * out_ptr ) { gss_krb5_lucid_context_v1_t * lctx = NULL ; unsigned int bufsize = sizeof ( gss_krb5_lucid_context_v1_t ) ; krb5_error_code retval ; if ( ( lctx = xmalloc ( bufsize ) ) == NULL ) { retval = ENOMEM ; error_out } memset ( lctx , 0 , bufsize ) ; lctx -> version = 1 ; lctx -> initiate = gctx -> initiate ?1 : 0 ; lctx -> endtime = gctx -> krb_times . endtime ; lctx -> send_seq = gctx -> seq_send ; lctx -> recv_seq = gctx -> seq_recv ; lctx -> protocol = gctx -> proto ; if ( gctx -> proto == 0 ) { lctx -> rfc1964_kd . sign_alg = gctx -> signalg ; lctx -> rfc1964_kd . seal_alg = gctx -> sealalg ; if ( ( retval = copy_keyblock_to_lucid_key ( & gctx -> seq -> keyblock , & lctx -> rfc1964_kd . ctx_key ) ) ) { error_out } } if ( gctx -> proto == 1 ) { if ( ( retval = copy_keyblock_to_lucid_key ( & gctx -> subkey -> keyblock , & lctx -> cfx_kd . ctx_key ) ) ) { error_out } if ( gctx -> have_acceptor_subkey ) { if ( ( retval = copy_keyblock_to_lucid_key ( & gctx -> acceptor_subkey -> keyblock , & lctx -> cfx_kd . acceptor_subkey ) ) ) { error_out } lctx -> cfx_kd . have_acceptor_subkey = 1 ; } } else { return EINVAL ; } * out_ptr = lctx ; return 0 ; error_out if ( lctx ) { free_external_lucid_ctx_v1 ( lctx ) ; } return retval ; } 