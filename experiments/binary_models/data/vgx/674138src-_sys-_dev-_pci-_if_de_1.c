int tulip_tx_intr ( tulip_softc_t * const sc ) { TULIP_PERFSTART ( ) tulip_ringinfo_t * const ri = & sc -> tulip_txinfo ; struct mbuf * m ; int xmits = 0 ; int descs = 0 ; while ( ri -> ri_free < ri -> ri_max ) { u_int32_t d_flag ; TULIP_TXDESC_POSTSYNC ( sc , ri -> ri_nextin , sizeof ( * ri -> ri_nextin ) ) ; if ( ( ( volatile tulip_desc_t * ) ri -> ri_nextin ) -> d_status & TULIP_DSTS_OWNER ) { break ; } ri -> ri_free ++ ; descs ++ ; d_flag = ri -> ri_nextin -> d_flag ; if ( d_flag & TULIP_DFLAG_TxLASTSEG ) { if ( d_flag & TULIP_DFLAG_TxSETUPPKT ) { TULIP_TXMAP_POSTSYNC ( sc , sc -> tulip_setupmap ) ; sc -> tulip_flags &= ~ ( TULIP_DOINGSETUP | TULIP_HASHONLY ) ; if ( ri -> ri_nextin -> d_flag & TULIP_DFLAG_TxINVRSFILT ) { sc -> tulip_flags |= TULIP_HASHONLY ; } if ( ( sc -> tulip_flags & ( TULIP_WANTSETUP | TULIP_TXPROBE_ACTIVE ) ) == 0 ) { tulip_rx_intr ( sc , NULL ) ; sc -> tulip_cmdmode |= TULIP_CMD_RXRUN ; sc -> tulip_intrmask |= TULIP_STS_RXSTOPPED ; TULIP_CSR_WRITE ( sc , csr_status , TULIP_STS_RXSTOPPED ) ; TULIP_CSR_WRITE ( sc , csr_intr , sc -> tulip_intrmask ) ; TULIP_CSR_WRITE ( sc , csr_command , sc -> tulip_cmdmode ) ; } } else { const u_int32_t d_status = ri -> ri_nextin -> d_status ; m = ml_dequeue ( & sc -> tulip_txq ) ; if ( m != NULL ) { bus_dmamap_t map = TULIP_GETCTX ( m , bus_dmamap_t ) ; TULIP_TXMAP_POSTSYNC ( sc , map ) ; tulip_free_txmap ( sc , map ) ; if ( sc -> tulip_bpf != NULL ) { bpf_mtap ( sc -> tulip_if . if_bpf , m , BPF_DIRECTION_OUT ) ; } m_freem ( m ) ; } if ( sc -> tulip_flags & TULIP_TXPROBE_ACTIVE ) { tulip_mediapoll_event_t event = TULIP_MEDIAPOLL_TXPROBE_OK ; if ( d_status & ( TULIP_DSTS_TxNOCARR | TULIP_DSTS_TxEXCCOLL ) ) { if ( d_status & TULIP_DSTS_TxNOCARR ) { sc -> tulip_dbg . dbg_txprobe_nocarr ++ ; } if ( d_status & TULIP_DSTS_TxEXCCOLL ) { sc -> tulip_dbg . dbg_txprobe_exccoll ++ ; } event = TULIP_MEDIAPOLL_TXPROBE_FAILED ; } * sc -> tulip_boardsw -> bd_media_poll ( sc , event ) ; break ; } else { xmits ++ ; if ( d_status & TULIP_DSTS_ERRSUM ) { sc -> tulip_if . if_oerrors ++ ; if ( d_status & TULIP_DSTS_TxEXCCOLL ) { sc -> tulip_dot3stats . dot3StatsExcessiveCollisions ++ ; } if ( d_status & TULIP_DSTS_TxLATECOLL ) { sc -> tulip_dot3stats . dot3StatsLateCollisions ++ ; } if ( d_status & ( TULIP_DSTS_TxNOCARR | TULIP_DSTS_TxCARRLOSS ) ) { sc -> tulip_dot3stats . dot3StatsCarrierSenseErrors ++ ; } if ( d_status & ( TULIP_DSTS_TxUNDERFLOW | TULIP_DSTS_TxBABBLE ) ) { sc -> tulip_dot3stats . dot3StatsInternalMacTransmitErrors ++ ; } if ( d_status & TULIP_DSTS_TxUNDERFLOW ) { sc -> tulip_dot3stats . dot3StatsInternalTransmitUnderflows ++ ; } if ( d_status & TULIP_DSTS_TxBABBLE ) { sc -> tulip_dot3stats . dot3StatsInternalTransmitBabbles ++ ; } } else { u_int32_t collisions = ( d_status & TULIP_DSTS_TxCOLLMASK ) >> TULIP_DSTS_V_TxCOLLCNT ; sc -> tulip_if . if_collisions += collisions ; if ( collisions == 1 ) { sc -> tulip_dot3stats . dot3StatsSingleCollisionFrames ++ ; } if ( collisions > 1 ) { sc -> tulip_dot3stats . dot3StatsMultipleCollisionFrames ++ ; } if ( d_status & TULIP_DSTS_TxDEFERRED ) { sc -> tulip_dot3stats . dot3StatsDeferredTransmissions ++ ; } if ( d_status & TULIP_DSTS_TxNOHRTBT & sc -> tulip_flags ) { sc -> tulip_dot3stats . dot3StatsSQETestErrors ++ ; } } } } } if ( ++ ri -> ri_nextin == ri -> ri_last ) { ri -> ri_nextin = ri -> ri_first ; } if ( ( sc -> tulip_flags & TULIP_TXPROBE_ACTIVE ) == 0 ) { ifq_clr_oactive ( & sc -> tulip_if . if_snd ) ; } } if ( ri -> ri_free == ri -> ri_max || ( sc -> tulip_flags & TULIP_TXPROBE_ACTIVE ) ) { sc -> tulip_txtimer = 0 ; } if ( xmits > 0 ) { sc -> tulip_txtimer = TULIP_TXTIMER ; } TULIP_PERFEND ( txintr ) ; return ( descs ) ; } 