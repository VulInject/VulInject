static struct dentry * orangefs_lookup ( struct inode * dir , struct dentry * dentry , unsigned int flags ) { struct orangefs_inode_s * parent = ORANGEFS_I ( dir ) ; struct orangefs_kernel_op_s * new_op ; struct inode * inode ; int ret = - EINVAL ; gossip_debug ( GOSSIP_NAME_DEBUG , "%s called on %pd\n" , __func__ , dentry ) ; if ( dentry -> d_name . len > ( ORANGEFS_NAME_MAX - 1 ) ) { return ERR_PTR ( - ENAMETOOLONG ) ; } new_op = op_alloc ( ORANGEFS_VFS_OP_LOOKUP ) ; if ( ! new_op ) { return ERR_PTR ( - ENOMEM ) ; } new_op -> upcall . req . lookup . sym_follow = ORANGEFS_LOOKUP_LINK_NO_FOLLOW ; gossip_debug ( GOSSIP_NAME_DEBUG , "%s:%s:%d using parent %pU\n" , __FILE__ , __func__ , __LINE__ , & parent -> refn . khandle ) ; new_op -> upcall . req . lookup . parent_refn = parent -> refn ; strncpy ( new_op -> upcall . req . lookup . d_name , dentry -> d_name . name , ORANGEFS_NAME_MAX - 1 ) ; gossip_debug ( GOSSIP_NAME_DEBUG , "%s: doing lookup on %s under %pU,%d\n" , __func__ , new_op -> upcall . req . lookup . d_name , & new_op -> upcall . req . lookup . parent_refn . khandle , new_op -> upcall . req . lookup . parent_refn . fs_id ) ; ret = service_operation ( new_op , __func__ , get_interruptible_flag ( dir ) ) ; gossip_debug ( GOSSIP_NAME_DEBUG , "Lookup Got %pU, fsid %d (ret=%d)\n" , & new_op -> downcall . resp . lookup . refn . khandle , new_op -> downcall . resp . lookup . refn . fs_id , ret ) ; if ( ret == 0 ) { orangefs_set_timeout ( dentry ) ; inode = orangefs_iget ( dir -> i_sb , & new_op -> downcall . resp . lookup . refn ) ; } if ( ret == - ENOENT ) { inode = NULL ; } else { inode = ERR_PTR ( ret ) ; } return d_splice_alias ( inode , dentry ) ; } 