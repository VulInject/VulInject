struct cx88_core * cx88_core_create ( struct pci_dev * pci , int nr ) { struct cx88_core * core ; int i ; core = kzalloc ( sizeof ( * core ) , GFP_KERNEL ) ; if ( ! core ) { return NULL ; } refcount_set ( & core -> refcount , 1 ) ; core -> pci_bus = pci -> bus -> number ; core -> pci_slot = PCI_SLOT ( pci -> devfn ) ; core -> pci_irqmask = PCI_INT_RISC_RD_BERRINT | PCI_INT_RISC_WR_BERRINT | PCI_INT_BRDG_BERRINT | PCI_INT_SRC_DMA_BERRINT | PCI_INT_DST_DMA_BERRINT | PCI_INT_IPB_DMA_BERRINT ; mutex_init ( & core -> lock ) ; core -> nr = nr ; sprintf ( core -> name , "cx88[%d]" , core -> nr ) ; core -> tvnorm = 0 ; core -> width = 320 ; core -> height = 240 ; core -> field = V4L2_FIELD_INTERLACED ; strscpy ( core -> v4l2_dev . name , core -> name , sizeof ( core -> v4l2_dev . name ) ) ; if ( v4l2_device_register ( NULL , & core -> v4l2_dev ) ) { return NULL ; } if ( v4l2_ctrl_handler_init ( & core -> video_hdl , 13 ) ) { v4l2_device_unregister ( & core -> v4l2_dev ) ; kfree ( core ) ; return NULL ; } if ( v4l2_ctrl_handler_init ( & core -> audio_hdl , 13 ) ) { v4l2_ctrl_handler_free ( & core -> video_hdl ) ; v4l2_device_unregister ( & core -> v4l2_dev ) ; kfree ( core ) ; return NULL ; } if ( cx88_get_resources ( core , pci ) != 0 ) { v4l2_ctrl_handler_free ( & core -> video_hdl ) ; v4l2_ctrl_handler_free ( & core -> audio_hdl ) ; v4l2_device_unregister ( & core -> v4l2_dev ) ; kfree ( core ) ; return NULL ; } cx88_pci_quirks ( core -> name , pci ) ; core -> lmmio = ioremap ( pci_resource_start ( pci , 0 ) , pci_resource_len ( pci , 0 ) ) ; core -> bmmio = ( u8 __iomem * ) core -> lmmio ; if ( ! core -> lmmio ) { release_mem_region ( pci_resource_start ( pci , 0 ) , pci_resource_len ( pci , 0 ) ) ; v4l2_ctrl_handler_free ( & core -> video_hdl ) ; v4l2_ctrl_handler_free ( & core -> audio_hdl ) ; v4l2_device_unregister ( & core -> v4l2_dev ) ; kfree ( core ) ; return NULL ; } core -> boardnr = UNSET ; if ( card [ core -> nr ] < ARRAY_SIZE ( cx88_boards ) ) { core -> boardnr = card [ core -> nr ] ; } for ( i = 0 ; core -> boardnr == UNSET && i < ARRAY_SIZE ( cx88_subids ) ; i ++ ) { if ( pci -> subsystem_vendor == cx88_subids [ i ] . subvendor && pci -> subsystem_device == cx88_subids [ i ] . subdevice ) { core -> boardnr = cx88_subids [ i ] . card ; } } if ( core -> boardnr == UNSET ) { core -> boardnr = CX88_BOARD_UNKNOWN ; cx88_card_list ( core , pci ) ; } core -> board = cx88_boards [ core -> boardnr ] ; if ( ! core -> board . num_frontends && ( core -> board . mpeg & CX88_MPEG_DVB ) ) { core -> board . num_frontends = 1 ; } pr_info ( "subsystem: %04x:%04x, board: %s [card=%d,%s], frontend(s): %d\n" , pci -> subsystem_vendor , pci -> subsystem_device , core -> board . name , core -> boardnr , card [ core -> nr ] == core -> boardnr ?"insmod option" : "autodetected" , core -> board . num_frontends ) ; if ( tuner [ core -> nr ] != UNSET ) { core -> board . tuner_type = tuner [ core -> nr ] ; } if ( radio [ core -> nr ] != UNSET ) { core -> board . radio_type = radio [ core -> nr ] ; } dprintk ( 1 , "TV tuner type %d, Radio tuner type %d\n" , core -> board . tuner_type , core -> board . radio_type ) ; cx88_reset ( core ) ; cx88_card_setup_pre_i2c ( core ) ; cx88_i2c_init ( core , pci ) ; if ( core -> board . tuner_type != UNSET ) { static const unsigned short tv_addrs [ ] { 0x42 0x43 0x4a 0x4b 0x60 0x61 0x62 0x63 0x64 0x65 0x66 0x67 0x68 0x69 0x6a 0x6c 0x6d 0x6e I2C_CLIENT_END } ; ; int has_demod = ( core -> board . tda9887_conf & TDA9887_PRESENT ) ; v4l2_i2c_new_subdev ( & core -> v4l2_dev , & core -> i2c_adap , "tuner" , 0 , v4l2_i2c_tuner_addrs ( ADDRS_RADIO ) ) ; if ( has_demod ) { v4l2_i2c_new_subdev ( & core -> v4l2_dev , & core -> i2c_adap , "tuner" , 0 , v4l2_i2c_tuner_addrs ( ADDRS_DEMOD ) ) ; } if ( core -> board . tuner_addr == ADDR_UNSET ) { v4l2_i2c_new_subdev ( & core -> v4l2_dev , & core -> i2c_adap , "tuner" , 0 , has_demod ?tv_addrs + 4 : tv_addrs ) ; } else { v4l2_i2c_new_subdev ( & core -> v4l2_dev , & core -> i2c_adap , "tuner" , core -> board . tuner_addr , NULL ) ; } } cx88_card_setup ( core ) ; if ( ! disable_ir ) { cx88_i2c_init_ir ( core ) ; cx88_ir_init ( core , pci ) ; } return core ; } 