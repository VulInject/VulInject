MODULE_DEVICE_TABLE ( of , stm32_adfsdm_of_match ) ; static int stm32_adfsdm_probe ( struct platform_device * pdev ) { struct stm32_adfsdm_priv * priv ; struct snd_soc_component * component ; int ret ; priv = devm_kzalloc ( & pdev -> dev , sizeof ( * priv ) , GFP_KERNEL ) ; priv -> dev = & pdev -> dev ; priv -> dai_drv = stm32_adfsdm_dai ; mutex_init ( & priv -> lock ) ; dev_set_drvdata ( & pdev -> dev , priv ) ; ret = devm_snd_soc_register_component ( & pdev -> dev , & stm32_adfsdm_dai_component , & priv -> dai_drv , 1 ) ; if ( ret < 0 ) { return ret ; } priv -> iio_ch = devm_iio_channel_get_all ( & pdev -> dev ) ; if ( IS_ERR ( priv -> iio_ch ) ) { return PTR_ERR ( priv -> iio_ch ) ; } priv -> iio_cb = iio_channel_get_all_cb ( & pdev -> dev , & stm32_adfsdm_dummy_cb , NULL ) ; if ( IS_ERR ( priv -> iio_cb ) ) { return PTR_ERR ( priv -> iio_cb ) ; } ret = devm_add_action_or_reset ( & pdev -> dev , stm32_adfsdm_cleanup , priv -> iio_cb ) ; if ( ret < 0 ) { dev_err ( & pdev -> dev , "Unable to add action\n" ) ; return ret ; } component = devm_kzalloc ( & pdev -> dev , sizeof ( * component ) , GFP_KERNEL ) ; if ( ! component ) { return - ENOMEM ; } ret = snd_soc_component_initialize ( component , & stm32_adfsdm_soc_platform , & pdev -> dev ) ; if ( ret < 0 ) { return ret ; } component -> debugfs_prefix = "pcm" ; ret = snd_soc_add_component ( component , NULL , 0 ) ; if ( ret < 0 ) { dev_err ( & pdev -> dev , "%s: Failed to register PCM platform\n" , __func__ ) ; return ret ; } pm_runtime_enable ( & pdev -> dev ) ; return ret ; } 