int lpfc_issue_els_plogi ( struct lpfc_vport * vport , uint32_t did , uint8_t retry ) { struct lpfc_hba * phba = vport -> phba ; struct serv_parm * sp ; struct lpfc_nodelist * ndlp ; struct lpfc_iocbq * elsiocb ; uint8_t * pcmd ; uint16_t cmdsize ; int ret ; ndlp = lpfc_findnode_did ( vport , did ) ; if ( ( ndlp -> nlp_flag & NLP_UNREG_INP ) && ( ( ndlp -> nlp_DID & Fabric_DID_MASK ) != Fabric_DID_MASK ) && ! ( vport -> fc_flag & FC_OFFLINE_MODE ) ) { lpfc_printf_vlog ( vport , KERN_INFO , LOG_DISCOVERY , "4110 Issue PLOGI x%x deferred " "on NPort x%x rpi x%x Data: x%px\n" , ndlp -> nlp_defer_did , ndlp -> nlp_DID , ndlp -> nlp_rpi , ndlp ) ; if ( ndlp -> nlp_defer_did == NLP_EVT_NOTHING_PENDING ) { ndlp -> nlp_defer_did = did ; } return 0 ; } cmdsize = ( sizeof ( uint32_t ) + sizeof ( serv_parm ) ) ; elsiocb = lpfc_prep_els_iocb ( vport , 1 , cmdsize , retry , ndlp , did , ELS_CMD_PLOGI ) ; if ( ! elsiocb ) { return 1 ; } pcmd = ( uint8_t * ) elsiocb -> cmd_dmabuf -> virt ; * ( ( uint32_t * ) ( pcmd ) ) = ELS_CMD_PLOGI ; pcmd += sizeof ( uint32_t ) ; memcpy ( pcmd , & vport -> fc_sparam , sizeof ( serv_parm ) ) ; sp = ( serv_parm * ) pcmd ; if ( ( vport -> fc_flag & FC_FABRIC ) && ! ( vport -> fc_flag & FC_PUBLIC_LOOP ) ) { sp -> cmn . altBbCredit = 1 ; } if ( sp -> cmn . fcphLow < FC_PH_4_3 ) { sp -> cmn . fcphLow = FC_PH_4_3 ; } if ( sp -> cmn . fcphHigh < FC_PH3 ) { sp -> cmn . fcphHigh = FC_PH3 ; } sp -> cmn . valid_vendor_ver_level = 0 ; memset ( sp -> un . vendorVersion , 0 , sizeof ( sp -> un . vendorVersion ) ) ; sp -> cmn . bbRcvSizeMsb &= 0xF ; ndlp -> vmid_support = 0 ; if ( vport -> vmid_priority_tagging ) { sp -> cmn . priority_tagging = 1 ; } if ( phba -> cfg_vmid_app_header && bf_get ( lpfc_ftr_ashdr , & phba -> sli4_hba . sli4_flags ) ) { sp -> cmn . app_hdr_support = 1 ; } lpfc_debugfs_disc_trc ( vport , LPFC_DISC_TRC_ELS_CMD , "Issue PLOGI:     did:x%x" , did , 0 , 0 ) ; if ( phba -> sli . sli_flag & LPFC_SLI_SUPPRESS_RSP ) { sp -> cmn . valid_vendor_ver_level = 1 ; sp -> un . vv . vid = cpu_to_be32 ( LPFC_VV_EMLX_ID ) ; sp -> un . vv . flags = cpu_to_be32 ( LPFC_VV_SUPPRESS_RSP ) ; } phba -> fc_stat . elsXmitPLOGI ++ ; elsiocb -> cmd_cmpl = lpfc_cmpl_els_plogi ; lpfc_debugfs_disc_trc ( vport , LPFC_DISC_TRC_ELS_CMD , "Issue PLOGI:     did:x%x refcnt %d" , did , kref_read ( & ndlp -> kref ) , 0 ) ; elsiocb -> ndlp = lpfc_nlp_get ( ndlp ) ; if ( ! elsiocb -> ndlp ) { lpfc_els_free_iocb ( phba , elsiocb ) ; return 1 ; } ret = lpfc_sli_issue_iocb ( phba , LPFC_ELS_RING , elsiocb , 0 ) ; if ( ret ) { lpfc_els_free_iocb ( phba , elsiocb ) ; lpfc_nlp_put ( ndlp ) ; return 1 ; } return 0 ; } 