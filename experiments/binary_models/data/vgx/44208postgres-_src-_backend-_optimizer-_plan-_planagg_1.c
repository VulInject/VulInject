void preprocess_minmax_aggregates ( PlannerInfo * root ) { Query * parse = root -> parse ; FromExpr * jtnode ; RangeTblRef * rtr ; RangeTblEntry * rte ; List * aggs_list ; RelOptInfo * grouped_rel ; ListCell * lc ; Assert ( root -> minmax_aggs == NIL ) ; Assert ( ! parse -> setOperations ) ; Assert ( parse -> rowMarks == NIL ) ; if ( parse -> groupClause || list_length ( parse -> groupingSets ) > 1 || parse -> hasWindowFuncs ) { return ; } if ( parse -> cteList ) { return ; } jtnode = parse -> jointree ; while ( IsA ( jtnode , FromExpr ) ) { if ( list_length ( jtnode -> fromlist ) != 1 ) { return ; } jtnode = linitial ( jtnode -> fromlist ) ; } if ( ! IsA ( jtnode , RangeTblRef ) ) { return ; } rtr = ( RangeTblRef * ) jtnode ; rte = planner_rt_fetch ( rtr -> rtindex , root ) ; if ( rte -> rtekind == RTE_RELATION ) { } if ( rte -> rtekind == RTE_SUBQUERY && rte -> inh ) { } else { return ; } aggs_list = NIL ; if ( ! can_minmax_aggs ( root , & aggs_list ) ) { return ; } ( lc aggs_list ; ) { MinMaxAggInfo * mminfo = ( MinMaxAggInfo * ) lfirst ( lc ) ; Oid eqop ; bool reverse ; eqop = get_equality_op_for_ordering_op ( mminfo -> aggsortop , & reverse ) ; if ( ! OidIsValid ( eqop ) ) { elog ( ERROR , "could not find equality operator for ordering operator %u" , mminfo -> aggsortop ) ; } if ( build_minmax_path ( root , mminfo , eqop , mminfo -> aggsortop , reverse ) ) { continue ; } if ( build_minmax_path ( root , mminfo , eqop , mminfo -> aggsortop , ! reverse ) ) { continue ; } return ; } ( lc aggs_list ; ) { MinMaxAggInfo * mminfo = ( MinMaxAggInfo * ) lfirst ( lc ) ; mminfo -> param = SS_make_initplan_output_param ( root , exprType ( ( Node * ) mminfo -> target ) , - 1 , exprCollation ( ( Node * ) mminfo -> target ) ) ; } grouped_rel = fetch_upper_rel ( root , UPPERREL_GROUP_AGG , NULL ) ; add_path ( grouped_rel , ( Path * ) create_minmaxagg_path ( root , grouped_rel , create_pathtarget ( root , root -> processed_tlist ) , aggs_list , ( List * ) parse -> havingQual ) ) ; } 