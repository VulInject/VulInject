static int lib80211_ccmp_encrypt ( struct sk_buff * skb , int hdr_len , void * priv ) { struct lib80211_ccmp_data * key = priv ; struct ieee80211_hdr * hdr ; struct aead_request * req ; struct scatterlist sg [ 2 ] ; u8 * aad = key -> tx_aad ; u8 iv [ AES_BLOCK_LEN ] ; int len , data_len , aad_len ; int ret ; if ( skb_tailroom ( skb ) < CCMP_MIC_LEN || skb -> len < hdr_len ) { return - 1 ; } data_len = skb -> len - hdr_len ; len = lib80211_ccmp_hdr ( skb , hdr_len , NULL , 0 , priv ) ; if ( len < 0 ) { return - 1 ; } req = aead_request_alloc ( key -> tfm , GFP_ATOMIC ) ; hdr = ( ieee80211_hdr * ) skb -> data ; aad_len = ccmp_init_iv_and_aad ( hdr , key -> tx_pn , iv , aad ) ; skb_put ( skb , CCMP_MIC_LEN ) ; sg_init_table ( sg , 2 ) ; sg_set_buf ( & sg [ 0 ] , aad , aad_len ) ; sg_set_buf ( & sg [ 1 ] , skb -> data + hdr_len + CCMP_HDR_LEN , data_len + CCMP_MIC_LEN ) ; aead_request_set_callback ( req , 0 , NULL , NULL ) ; aead_request_set_ad ( req , aad_len ) ; aead_request_set_crypt ( req , sg , sg , data_len , iv ) ; ret = crypto_aead_encrypt ( req ) ; aead_request_free ( req ) ; return ret ; } 