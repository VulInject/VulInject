CK_RV emulate_init ( kernel_session_t * session_p , CK_MECHANISM_PTR pMechanism , crypto_key_t * keyp , int opflag ) { CK_RV rv ; crypto_active_op_t * opp ; opp = ( opflag & OP_SIGN ) ?& ( session_p -> sign ) : & ( session_p -> verify ) ; opflag |= OP_INIT ; rv = do_soft_hmac_init ( get_spp ( opp ) , pMechanism , keyp -> ck_data , keyp -> ck_length >> 3 , opflag ) ; return ( rv ) ; } if ( ( opflag ) & OP_DIGEST ) { rv = do_soft_digest ( get_spp ( opp ) , NULL , pPart , ulPartLen , NULL , NULL , opflag ) ; } else { rv = do_soft_hmac_update ( get_spp ( opp ) , pPart , ulPartLen , opflag ) ; } CK_RV emulate_update ( kernel_session_t * session_p , CK_BYTE_PTR pPart , CK_ULONG ulPartLen , int opflag ) { CK_RV rv ; int maxlen ; digest_buf_t * bufp ; boolean_t use_soft = B_FALSE ; crypto_active_op_t * opp ; if ( opflag & OP_DIGEST ) { opp = & ( session_p -> digest ) ; if ( ! SLOT_HAS_LIMITED_HASH ( session_p ) ) { return ( CKR_ARGUMENTS_BAD ) ; } maxlen = SLOT_HASH_MAX_INDATA_LEN ( session_p ) ; } if ( opflag & ( OP_SIGN | OP_VERIFY ) ) { opp = ( opflag & OP_SIGN ) ?& ( session_p -> sign ) : & ( session_p -> verify ) ; if ( ! SLOT_HAS_LIMITED_HMAC ( session_p ) ) { return ( CKR_ARGUMENTS_BAD ) ; } maxlen = SLOT_HMAC_MAX_INDATA_LEN ( session_p ) ; } else { return ( CKR_ARGUMENTS_BAD ) ; } if ( opp -> flags & CRYPTO_EMULATE_USING_SW ) { opflag |= OP_UPDATE ; DO_SOFT_UPDATE ( opp , pPart , ulPartLen , opflag ) ; opp -> flags |= CRYPTO_EMULATE_UPDATE_DONE ; return ( rv ) ; } bufp = opp -> context ; if ( bufp == NULL ) { return ( CKR_FUNCTION_FAILED ) ; } if ( bufp -> indata_len + ulPartLen > maxlen ) { use_soft = B_TRUE ; } if ( ulPartLen > ( bufp -> buf_len - bufp -> indata_len ) ) { int siz = ulPartLen < bufp -> buf_len ?bufp -> buf_len * 2 : bufp -> buf_len + ulPartLen ; uint8_t * old = bufp -> buf ; bufp -> buf = realloc ( bufp -> buf , siz ) ; if ( bufp -> buf == NULL ) { bufp -> buf = old ; use_soft = B_TRUE ; } else { bufp -> buf_len = siz ; } } if ( use_soft ) { opp -> flags |= CRYPTO_EMULATE_USING_SW ; if ( opflag & OP_DIGEST ) { CK_MECHANISM_PTR pMechanism ; pMechanism = & ( opp -> mech ) ; rv = do_soft_digest ( get_spp ( opp ) , pMechanism , NULL , 0 , NULL , NULL , OP_INIT ) ; if ( rv != CKR_OK ) { return ( rv ) ; } } opflag |= OP_UPDATE ; DO_SOFT_UPDATE ( opp , bufp -> buf , bufp -> indata_len , opflag ) ; opp -> flags |= CRYPTO_EMULATE_UPDATE_DONE ; if ( rv == CKR_OK ) { DO_SOFT_UPDATE ( opp , pPart , ulPartLen , opflag ) ; } return ( rv ) ; } bcopy ( pPart , bufp -> buf + bufp -> indata_len , ulPartLen ) ; bufp -> indata_len += ulPartLen ; return ( CKR_OK ) ; } 