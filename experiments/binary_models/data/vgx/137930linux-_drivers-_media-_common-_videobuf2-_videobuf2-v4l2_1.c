static void __fill_v4l2_buffer ( struct vb2_buffer * vb , void * pb ) { struct v4l2_buffer * b = pb ; struct vb2_v4l2_buffer * vbuf = to_vb2_v4l2_buffer ( vb ) ; struct vb2_queue * q = vb -> vb2_queue ; unsigned int plane ; b -> index = vb -> index ; b -> type = vb -> type ; b -> memory = vb -> memory ; b -> bytesused = 0 ; b -> flags = vbuf -> flags ; b -> field = vbuf -> field ; v4l2_buffer_set_timestamp ( b , vb -> timestamp ) ; b -> timecode = vbuf -> timecode ; b -> sequence = vbuf -> sequence ; b -> reserved2 = 0 ; b -> request_fd = 0 ; if ( q -> is_multiplanar ) { b -> length = vb -> num_planes ; for ( plane = 0 ; plane < vb -> num_planes ; ++ plane ) { struct v4l2_plane * pdst = & b -> m . planes [ plane ] ; struct vb2_plane * psrc = & vb -> planes [ plane ] ; pdst -> bytesused = psrc -> bytesused ; pdst -> length = psrc -> length ; if ( q -> memory == VB2_MEMORY_MMAP ) { pdst -> m . mem_offset = psrc -> m . offset ; } if ( q -> memory == VB2_MEMORY_USERPTR ) { pdst -> m . userptr = psrc -> m . userptr ; } if ( q -> memory == VB2_MEMORY_DMABUF ) { pdst -> m . fd = psrc -> m . fd ; } pdst -> data_offset = psrc -> data_offset ; } } else { b -> length = vb -> planes [ 0 ] . length ; b -> bytesused = vb -> planes [ 0 ] . bytesused ; if ( q -> memory == VB2_MEMORY_MMAP ) { b -> m . offset = vb -> planes [ 0 ] . m . offset ; } if ( q -> memory == VB2_MEMORY_USERPTR ) { b -> m . userptr = vb -> planes [ 0 ] . m . userptr ; } if ( q -> memory == VB2_MEMORY_DMABUF ) { b -> m . fd = vb -> planes [ 0 ] . m . fd ; } } b -> flags &= ~ V4L2_BUFFER_MASK_FLAGS ; b -> flags |= q -> timestamp_flags & V4L2_BUF_FLAG_TIMESTAMP_MASK ; if ( ! q -> copy_timestamp ) { b -> flags &= ~ V4L2_BUF_FLAG_TSTAMP_SRC_MASK ; b -> flags |= q -> timestamp_flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK ; } switch ( vb -> state ) { case VB2_BUF_STATE_QUEUED : case VB2_BUF_STATE_ACTIVE : b -> flags |= V4L2_BUF_FLAG_QUEUED ; break ; case VB2_BUF_STATE_IN_REQUEST : b -> flags |= V4L2_BUF_FLAG_IN_REQUEST ; break ; case VB2_BUF_STATE_ERROR : b -> flags |= V4L2_BUF_FLAG_ERROR ; fallthrough ; case VB2_BUF_STATE_DONE : b -> flags |= V4L2_BUF_FLAG_DONE ; break ; case VB2_BUF_STATE_PREPARING : case VB2_BUF_STATE_DEQUEUED : break ; } if ( ( vb -> state == VB2_BUF_STATE_DEQUEUED || vb -> state == VB2_BUF_STATE_IN_REQUEST ) && vb -> synced && vb -> prepared ) { b -> flags |= V4L2_BUF_FLAG_PREPARED ; } if ( vb2_buffer_in_use ( q , vb ) ) { b -> flags |= V4L2_BUF_FLAG_MAPPED ; } if ( vbuf -> request_fd >= 0 ) { b -> flags |= V4L2_BUF_FLAG_REQUEST_FD ; b -> request_fd = vbuf -> request_fd ; } } 