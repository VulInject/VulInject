elf_symfile_read ( , ) { bfd * abfd = objfile -> obfd ; struct elfinfo ei ; struct cleanup * back_to ; CORE_ADDR offset ; init_minimal_symbol_collection ( ) ; back_to = make_cleanup_discard_minimal_symbols ( ) ; objfile -> sym_stab_info = ( dbx_symfile_info * ) xmalloc ( sizeof ( dbx_symfile_info ) ) ; memset ( ( char * ) objfile -> sym_stab_info , 0 , sizeof ( dbx_symfile_info ) ) ; make_cleanup ( free_elfinfo , ( void * ) objfile ) ; elf_symtab_read ( objfile , 0 ) ; elf_symtab_read ( objfile , 1 ) ; install_minimal_symbols ( objfile ) ; do_cleanups ( back_to ) ; if ( mainline ) { init_psymbol_list ( objfile , 0 ) ; mainline = 0 ; } bfd_map_over_sections ( abfd , elf_locate_sections , ( void * ) & ei ) ; if ( ei . mdebugsect ) { const struct ecoff_debug_swap * swap ; swap = get_elf_backend_data ( abfd ) -> elf_backend_ecoff_debug_swap ; if ( swap ) { elfmdebug_build_psymtabs ( objfile , swap , ei . mdebugsect ) ; } } if ( ei . stabsect ) { asection * str_sect ; str_sect = bfd_get_section_by_name ( abfd , ".stabstr" ) ; if ( str_sect ) { elfstab_build_psymtabs ( objfile , mainline , ei . stabsect , str_sect -> filepos , bfd_section_size ( abfd , str_sect ) ) ; } } if ( dwarf2_has_info ( objfile ) ) { dwarf2_build_psymtabs ( objfile , mainline ) ; } if ( ei . dboffset && ei . lnoffset ) { dwarf_build_psymtabs ( objfile , mainline , ei . dboffset , ei . dbsize , ei . lnoffset , ei . lnsize ) ; } dwarf2_build_frame_info ( objfile ) ; } 