static inline struct z3fold_header * __z3fold_alloc ( struct z3fold_pool * pool , size_t size , bool can_sleep ) { struct z3fold_header * zhdr = NULL ; struct page * page ; struct list_head * unbuddied ; int chunks = size_to_chunks ( size ) , i ; lookup migrate_disable ( ) ; unbuddied = this_cpu_ptr ( pool -> unbuddied ) ; for_each_unbuddied_list ( , ) { struct list_head * l = & unbuddied [ i ] ; zhdr = list_first_entry_or_null ( READ_ONCE ( l ) , z3fold_header , buddy ) ; spin_lock ( & pool -> lock ) ; if ( unlikely ( zhdr != list_first_entry ( READ_ONCE ( l ) , z3fold_header , buddy ) ) || ! z3fold_page_trylock ( zhdr ) ) { spin_unlock ( & pool -> lock ) ; zhdr = NULL ; migrate_enable ( ) ; if ( can_sleep ) { cond_resched ( ) ; } lookup } list_del_init ( & zhdr -> buddy ) ; zhdr -> cpu = - 1 ; spin_unlock ( & pool -> lock ) ; page = virt_to_page ( zhdr ) ; if ( test_bit ( NEEDS_COMPACTING , & page -> private ) || test_bit ( PAGE_CLAIMED , & page -> private ) ) { z3fold_page_unlock ( zhdr ) ; zhdr = NULL ; migrate_enable ( ) ; if ( can_sleep ) { cond_resched ( ) ; } lookup } kref_get ( & zhdr -> refcount ) ; break ; } migrate_enable ( ) ; if ( ! zhdr ) { int cpu ; for_each_online_cpu ( ) { struct list_head * l ; unbuddied = per_cpu_ptr ( pool -> unbuddied , cpu ) ; spin_lock ( & pool -> lock ) ; l = & unbuddied [ chunks ] ; zhdr = list_first_entry_or_null ( READ_ONCE ( l ) , z3fold_header , buddy ) ; if ( ! zhdr || ! z3fold_page_trylock ( zhdr ) ) { spin_unlock ( & pool -> lock ) ; zhdr = NULL ; continue ; } list_del_init ( & zhdr -> buddy ) ; zhdr -> cpu = - 1 ; spin_unlock ( & pool -> lock ) ; page = virt_to_page ( zhdr ) ; if ( test_bit ( NEEDS_COMPACTING , & page -> private ) || test_bit ( PAGE_CLAIMED , & page -> private ) ) { z3fold_page_unlock ( zhdr ) ; zhdr = NULL ; if ( can_sleep ) { cond_resched ( ) ; } continue ; } kref_get ( & zhdr -> refcount ) ; break ; } } if ( zhdr && ! zhdr -> slots ) { zhdr -> slots = alloc_slots ( pool , GFP_ATOMIC ) ; if ( ! zhdr -> slots ) { out_fail } } return zhdr ; out_fail if ( ! kref_put ( & zhdr -> refcount , release_z3fold_page_locked ) ) { add_to_unbuddied ( pool , zhdr ) ; z3fold_page_unlock ( zhdr ) ; } return NULL ; } 