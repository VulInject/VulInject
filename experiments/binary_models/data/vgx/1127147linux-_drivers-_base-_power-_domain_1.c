int pm_genpd_remove_subdomain ( struct generic_pm_domain * genpd , struct generic_pm_domain * subdomain ) { struct gpd_link * l , * link ; int ret = - EINVAL ; if ( IS_ERR_OR_NULL ( genpd ) || IS_ERR_OR_NULL ( subdomain ) ) { return - EINVAL ; } genpd_lock ( subdomain ) ; genpd_lock_nested ( genpd , SINGLE_DEPTH_NESTING ) ; if ( ! list_empty ( & subdomain -> parent_links ) || subdomain -> device_count ) { pr_warn ( "%s: unable to remove subdomain %s\n" , genpd -> name , subdomain -> name ) ; ret = - EBUSY ; out } list_for_each_entry_safe ( , , , ) { if ( link -> child != subdomain ) { continue ; } list_del ( & link -> parent_node ) ; list_del ( & link -> child_node ) ; if ( genpd_status_on ( subdomain ) ) { genpd_sd_counter_dec ( genpd ) ; } ret = 0 ; break ; } out genpd_unlock ( genpd ) ; genpd_unlock ( subdomain ) ; return ret ; } 