int btrfs_create_free_space_tree ( struct btrfs_fs_info * fs_info ) { struct btrfs_trans_handle * trans ; struct btrfs_root * tree_root = fs_info -> tree_root ; struct btrfs_root * free_space_root ; struct btrfs_block_group_cache * block_group ; struct rb_node * node ; int ret ; trans = btrfs_start_transaction ( tree_root , 0 ) ; if ( IS_ERR ( trans ) ) { return PTR_ERR ( trans ) ; } set_bit ( BTRFS_FS_CREATING_FREE_SPACE_TREE , & fs_info -> flags ) ; free_space_root = btrfs_create_tree ( trans , fs_info , BTRFS_FREE_SPACE_TREE_OBJECTID ) ; if ( IS_ERR ( free_space_root ) ) { ret = PTR_ERR ( free_space_root ) ; abort } fs_info -> free_space_root = free_space_root ; node = rb_first ( & fs_info -> block_group_cache_tree ) ; while ( node ) { block_group = rb_entry ( node , btrfs_block_group_cache , cache_node ) ; ret = populate_free_space_tree ( trans , fs_info , block_group ) ; if ( ret ) { abort } node = rb_next ( node ) ; } btrfs_set_fs_compat_ro ( fs_info , FREE_SPACE_TREE ) ; btrfs_set_fs_compat_ro ( fs_info , FREE_SPACE_TREE_VALID ) ; clear_bit ( BTRFS_FS_CREATING_FREE_SPACE_TREE , & fs_info -> flags ) ; ret = btrfs_commit_transaction ( trans ) ; return 0 ; abort clear_bit ( BTRFS_FS_CREATING_FREE_SPACE_TREE , & fs_info -> flags ) ; btrfs_abort_transaction ( trans , ret ) ; btrfs_end_transaction ( trans ) ; return ret ; } 