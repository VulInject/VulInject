bool FUN1 ( struct VAR1 * VAR2 , pim_addr VAR3 , struct VAR4 * VAR5 , pim_addr VAR6 ) { struct VAR7 * VAR8 = NULL ; struct pim_nexthop_cache VAR9 ; struct VAR10 * VAR11 = NULL ; struct VAR12 * VAR13 ; struct VAR4 * VAR14 ; VAR9 . VAR15 . VAR16 = VAR3 ; VAR8 = FUN2 ( VAR2 -> VAR17 , & VAR9 ) ; if ( ! VAR8 || ! FUN3 ( VAR8 -> VAR18 , VAR19 ) ) { struct pim_zlookup_nexthop VAR20 [ VAR21 -> VAR22 ] ; ifindex_t VAR23 ; struct VAR4 * VAR14 = NULL ; int VAR24 ; VAR24 = FUN4 ( VAR2 , VAR20 , VAR21 -> VAR22 , VAR3 , VAR25 ) ; if ( VAR24 <= 0 ) { return false ; } for ( VAR23 = 0 ; VAR23 < VAR24 ; VAR23 ++ ) { struct VAR26 * VAR27 = & VAR20 [ VAR23 ] ; VAR14 = FUN5 ( VAR27 -> VAR28 , VAR2 -> VAR29 -> VAR30 ) ; if ( ! VAR14 || ! VAR14 -> VAR31 ) { continue ; } if ( FUN6 ( VAR14 ) && FUN6 ( VAR5 ) ) { return true ; } VAR11 = FUN7 ( VAR14 , VAR27 -> VAR32 ) ; if ( ! VAR11 ) { continue ; } return VAR27 -> VAR28 == VAR5 -> VAR28 && ( ! FUN8 ( VAR27 -> VAR32 , VAR6 ) ) ; } return false ; } if ( ! FUN3 ( VAR8 -> VAR18 , VAR33 ) ) { return false ; } for ( VAR13 = VAR8 -> VAR12 ; VAR13 ; VAR13 = VAR13 -> VAR34 ) { pim_addr VAR35 ; switch ( VAR13 -> VAR36 ) { case VAR37 : if ( VAR13 -> VAR28 == VAR38 ) { continue ; } case VAR39 : VAR35 = VAR13 -> VAR40 . VAR41 ; break ; case VAR42 : case VAR43 : continue ; case VAR42 : if ( VAR13 -> VAR28 == VAR38 ) { continue ; } case VAR43 : VAR35 = VAR13 -> VAR40 . VAR44 ; break ; case VAR37 : case VAR39 : continue ; case VAR45 : VAR35 = VAR3 ; break ; case VAR46 : continue ; } VAR14 = FUN5 ( VAR13 -> VAR28 , VAR2 -> VAR29 -> VAR30 ) ; if ( ! VAR14 || ! VAR14 -> VAR31 ) { continue ; } if ( FUN6 ( VAR14 ) && FUN6 ( VAR5 ) ) { return true ; } VAR11 = FUN7 ( VAR14 , VAR35 ) ; if ( ! VAR11 ) { continue ; } return VAR13 -> VAR28 == VAR5 -> VAR28 && ( ! FUN8 ( VAR35 , VAR6 ) ) ; } return false ; }