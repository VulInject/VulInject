static int bnx2x_init_one ( struct pci_dev * pdev , const struct pci_device_id * ent ) { struct net_device * dev = NULL ; struct bnx2x * bp ; int rc , max_non_def_sbs ; int rx_count , tx_count , rss_count , doorbell_size ; int max_cos_est ; bool is_vf ; int cnic_cnt ; if ( is_kdump_kernel ( ) ) { ktime_t now = ktime_get_boottime ( ) ; ktime_t fw_ready_time = ktime_set ( 5 , 0 ) ; if ( ktime_before ( now , fw_ready_time ) ) { msleep ( ktime_ms_delta ( fw_ready_time , now ) ) ; } } max_cos_est = set_max_cos_est ( ent -> driver_data ) ; if ( max_cos_est < 0 ) { return max_cos_est ; } is_vf = set_is_vf ( ent -> driver_data ) ; cnic_cnt = is_vf ?0 : 1 ; max_non_def_sbs = bnx2x_get_num_non_def_sbs ( pdev , cnic_cnt ) ; max_non_def_sbs += is_vf ?1 : 0 ; rss_count = max_non_def_sbs - cnic_cnt ; if ( rss_count < 1 ) { return - EINVAL ; } rx_count = rss_count + cnic_cnt ; tx_count = rss_count * max_cos_est + cnic_cnt ; dev = alloc_etherdev_mqs ( sizeof ( * bp ) , tx_count , rx_count ) ; if ( ! dev ) { return - ENOMEM ; } bp = netdev_priv ( dev ) ; bp -> flags = 0 ; if ( is_vf ) { bp -> flags |= IS_VF_FLAG ; } bp -> igu_sb_cnt = max_non_def_sbs ; bp -> igu_base_addr = IS_VF ( bp ) ?PXP_VF_ADDR_IGU_START : BAR_IGU_INTMEM ; bp -> msg_enable = debug ; bp -> cnic_support = cnic_cnt ; bp -> cnic_probe = bnx2x_cnic_probe ; pci_set_drvdata ( pdev , dev ) ; rc = bnx2x_init_dev ( bp , pdev , dev , ent -> driver_data ) ; if ( rc < 0 ) { return rc ; } BNX2X_DEV_INFO ( "This is a %s function\n" , IS_PF ( bp ) ?"physical" : "virtual" ) ; BNX2X_DEV_INFO ( "Cnic support is %s\n" , CNIC_SUPPORT ( bp ) ?"on" : "off" ) ; BNX2X_DEV_INFO ( "Max num of status blocks %d\n" , max_non_def_sbs ) ; BNX2X_DEV_INFO ( "Allocated netdev with %d tx and %d rx queues\n" , tx_count , rx_count ) ; rc = bnx2x_init_bp ( bp ) ; if ( rc ) { init_one_exit } if ( IS_VF ( bp ) ) { bp -> doorbells = bnx2x_vf_doorbells ( bp ) ; rc = bnx2x_vf_pci_alloc ( bp ) ; if ( rc ) { init_one_freemem } } else { doorbell_size = BNX2X_L2_MAX_CID ( bp ) * ( 1 << BNX2X_DB_SHIFT ) ; if ( doorbell_size > pci_resource_len ( pdev , 2 ) ) { dev_err ( & bp -> pdev -> dev , "Cannot map doorbells, bar size too small, aborting\n" ) ; rc = - ENOMEM ; init_one_freemem } bp -> doorbells = ioremap ( pci_resource_start ( pdev , 2 ) , doorbell_size ) ; } if ( ! bp -> doorbells ) { dev_err ( & bp -> pdev -> dev , "Cannot map doorbell space, aborting\n" ) ; rc = - ENOMEM ; init_one_freemem } if ( IS_VF ( bp ) ) { rc = bnx2x_vfpf_acquire ( bp , tx_count , rx_count ) ; if ( rc ) { init_one_freemem } if ( bp -> acquire_resp . pfdev_info . pf_cap & PFVF_CAP_VLAN_FILTER ) { dev -> hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER ; dev -> features |= NETIF_F_HW_VLAN_CTAG_FILTER ; } } rc = bnx2x_iov_init_one ( bp , int_mode , BNX2X_MAX_NUM_OF_VFS ) ; if ( rc ) { init_one_freemem } bp -> qm_cid_count = bnx2x_set_qm_cid_count ( bp ) ; BNX2X_DEV_INFO ( "qm_cid_count %d\n" , bp -> qm_cid_count ) ; if ( CHIP_IS_E1x ( bp ) ) { bp -> flags |= NO_FCOE_FLAG ; } bnx2x_set_num_queues ( bp ) ; rc = bnx2x_set_int_mode ( bp ) ; if ( rc ) { dev_err ( & pdev -> dev , "Cannot set interrupts\n" ) ; init_one_freemem } BNX2X_DEV_INFO ( "set interrupts successfully\n" ) ; rc = register_netdev ( dev ) ; if ( rc ) { dev_err ( & pdev -> dev , "Cannot register net device\n" ) ; init_one_freemem } BNX2X_DEV_INFO ( "device name after netdev register %s\n" , dev -> name ) ; if ( ! NO_FCOE ( bp ) ) { rtnl_lock ( ) ; dev_addr_add ( bp -> dev , bp -> fip_mac , NETDEV_HW_ADDR_T_SAN ) ; rtnl_unlock ( ) ; } BNX2X_DEV_INFO ( "%s (%c%d) PCI-E found at mem %lx, IRQ %d, node addr %pM\n" , board_info [ ent -> driver_data ] . name , ( CHIP_REV ( bp ) >> 12 ) + 'A' , ( CHIP_METAL ( bp ) >> 4 ) , dev -> base_addr , bp -> pdev -> irq , dev -> dev_addr ) ; pcie_print_link_status ( bp -> pdev ) ; if ( ! IS_MF_SD_STORAGE_PERSONALITY_ONLY ( bp ) ) { bnx2x_set_os_driver_state ( bp , OS_DRIVER_STATE_DISABLED ) ; } return 0 ; init_one_freemem bnx2x_free_mem_bp ( bp ) ; init_one_exit bnx2x_disable_pcie_error_reporting ( bp ) ; if ( bp -> regview ) { iounmap ( bp -> regview ) ; } if ( IS_PF ( bp ) && bp -> doorbells ) { iounmap ( bp -> doorbells ) ; } free_netdev ( dev ) ; if ( atomic_read ( & pdev -> enable_cnt ) == 1 ) { pci_release_regions ( pdev ) ; } pci_disable_device ( pdev ) ; return rc ; } 