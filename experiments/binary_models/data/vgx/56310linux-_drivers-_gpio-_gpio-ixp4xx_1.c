static int ixp4xx_gpio_probe ( struct platform_device * pdev ) { unsigned long flags ; struct device * dev = & pdev -> dev ; struct device_node * np = dev -> of_node ; struct irq_domain * parent ; struct resource * res ; struct ixp4xx_gpio * g ; struct gpio_irq_chip * girq ; struct device_node * irq_parent ; int ret ; g = devm_kzalloc ( dev , sizeof ( * g ) , GFP_KERNEL ) ; g -> dev = dev ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; g -> base = devm_ioremap_resource ( dev , res ) ; if ( IS_ERR ( g -> base ) ) { return PTR_ERR ( g -> base ) ; } irq_parent = of_irq_find_parent ( np ) ; if ( ! irq_parent ) { dev_err ( dev , "no IRQ parent node\n" ) ; return - ENODEV ; } parent = irq_find_host ( irq_parent ) ; if ( ! parent ) { dev_err ( dev , "no IRQ parent domain\n" ) ; return - ENODEV ; } g -> fwnode = of_node_to_fwnode ( np ) ; if ( of_machine_is_compatible ( "dlink,dsm-g600-a" ) || of_machine_is_compatible ( "iom,nas-100d" ) ) { __raw_writel ( 0x0 , g -> base + IXP4XX_REG_GPCLK ) ; } flags = BGPIOF_BIG_ENDIAN_BYTE_ORDER ; flags = 0 ; ret = bgpio_init ( & g -> gc , dev , 4 , g -> base + IXP4XX_REG_GPIN , g -> base + IXP4XX_REG_GPOUT , NULL , NULL , g -> base + IXP4XX_REG_GPOE , flags ) ; if ( ret ) { dev_err ( dev , "unable to init generic GPIO\n" ) ; return ret ; } g -> gc . ngpio = 16 ; g -> gc . label = "IXP4XX_GPIO_CHIP" ; g -> gc . base = 0 ; g -> gc . parent = & pdev -> dev ; g -> gc . owner = THIS_MODULE ; girq = & g -> gc . irq ; gpio_irq_chip_set_chip ( girq , & ixp4xx_gpio_irqchip ) ; girq -> fwnode = g -> fwnode ; girq -> parent_domain = parent ; girq -> child_to_parent_hwirq = ixp4xx_gpio_child_to_parent_hwirq ; girq -> handler = handle_bad_irq ; girq -> default_type = IRQ_TYPE_NONE ; ret = devm_gpiochip_add_data ( dev , & g -> gc , g ) ; if ( ret ) { dev_err ( dev , "failed to add SoC gpiochip\n" ) ; return ret ; } platform_set_drvdata ( pdev , g ) ; dev_info ( dev , "IXP4 GPIO registered\n" ) ; return 0 ; } 