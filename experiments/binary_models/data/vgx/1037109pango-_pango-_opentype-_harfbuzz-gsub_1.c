static HB_Error Lookup_SingleSubst ( HB_GSUBHeader * gsub , HB_GSUB_SubTable * st , HB_Buffer buffer , HB_UShort flags , HB_UShort context_length , int nesting_level ) { HB_UShort index , value , property ; HB_Error error ; HB_SingleSubst * ss = & st -> single ; HB_GDEFHeader * gdef = gsub -> gdef ; HB_UNUSED ( nesting_level , NULL ) ; if ( context_length != 0xFFFF && context_length < 1 ) { return HB_Err_Not_Covered ; } if ( CHECK_Property ( gdef , IN_CURITEM ( ) , flags , & property ) ) { return error ; } error = _HB_OPEN_Coverage_Index ( & ss -> Coverage , IN_CURGLYPH ( ) , & index ) ; if ( error ) { return error ; } switch ( ss -> SubstFormat ) { case 1 : value = ( IN_CURGLYPH ( ) + ss -> ssf . ssf1 . DeltaGlyphID ) & 0xFFFF ; if ( REPLACE_Glyph ( buffer , value , nesting_level ) ) { return error ; } break ; case 2 : if ( index >= ss -> ssf . ssf2 . GlyphCount ) { return ERR ( HB_Err_Invalid_SubTable ) ; } value = ss -> ssf . ssf2 . Substitute [ index ] ; if ( REPLACE_Glyph ( buffer , value , nesting_level ) ) { return error ; } break ; default : return ERR ( HB_Err_Invalid_SubTable ) ; } if ( gdef && gdef -> NewGlyphClasses ) { error = _HB_GDEF_Add_Glyph_Property ( gdef , value , property ) ; if ( error && error != HB_Err_Not_Covered ) { return error ; } } return HB_Err_Ok ; } 