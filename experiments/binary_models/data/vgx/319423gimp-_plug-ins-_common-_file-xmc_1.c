xmc_save ( , , , , , , , ) { GimpProcedureConfig * config ; GimpPDBStatusType status = GIMP_PDB_SUCCESS ; GimpExportReturn export = GIMP_EXPORT_CANCEL ; GimpImage * orig_image ; GeglRectangle * hotspot_range ; gint hot_spot_x ; gint hot_spot_y ; GError * error = NULL ; gegl_init ( NULL , NULL ) ; orig_image = image ; hotspot_range = get_intersection_of_frames ( image ) ; if ( ! hotspot_range ) { g_set_error ( & error , 0 , 0 , _ ( "Cannot set the hot spot!\n" "You must arrange layers so that all of them have " "an intersection." ) ) ; return gimp_procedure_new_return_values ( procedure , GIMP_PDB_EXECUTION_ERROR , error ) ; } config = gimp_procedure_create_config ( procedure ) ; gimp_procedure_config_begin_export ( config , image , run_mode , args , NULL ) ; switch ( run_mode ) { case GIMP_RUN_INTERACTIVE : case GIMP_RUN_WITH_LAST_VALS : gimp_ui_init ( PLUG_IN_BINARY ) ; export = gimp_export_image ( & image , & n_drawables , & drawables , "XMC" , GIMP_EXPORT_CAN_HANDLE_RGB | GIMP_EXPORT_CAN_HANDLE_ALPHA | GIMP_EXPORT_CAN_HANDLE_LAYERS | GIMP_EXPORT_NEEDS_ALPHA ) ; if ( export == GIMP_EXPORT_CANCEL ) { return gimp_procedure_new_return_values ( procedure , GIMP_PDB_CANCEL , NULL ) ; } break ; default : break ; } switch ( run_mode ) { case GIMP_RUN_INTERACTIVE : load_default_hotspot ( image , hotspot_range , G_OBJECT ( config ) ) ; if ( ! save_dialog ( procedure , G_OBJECT ( config ) , image , hotspot_range ) ) { return gimp_procedure_new_return_values ( procedure , GIMP_PDB_CANCEL , NULL ) ; } break ; case GIMP_RUN_NONINTERACTIVE : g_object_get ( config , "hot-spot-x" , & hot_spot_x , "hot-spot-y" , & hot_spot_y , NULL ) ; if ( ! pix_in_region ( hot_spot_x , hot_spot_y , hotspot_range ) ) { load_default_hotspot ( image , hotspot_range , G_OBJECT ( config ) ) ; } break ; case GIMP_RUN_WITH_LAST_VALS : load_default_hotspot ( image , hotspot_range , G_OBJECT ( config ) ) ; break ; default : break ; } if ( ! save_image ( file , image , n_drawables , drawables , orig_image , G_OBJECT ( config ) , & error ) ) { status = GIMP_PDB_EXECUTION_ERROR ; } if ( export == GIMP_EXPORT_EXPORT ) { gimp_image_delete ( image ) ; g_free ( drawables ) ; } gimp_procedure_config_end_export ( config , image , file , status ) ; g_object_unref ( config ) ; return gimp_procedure_new_return_values ( procedure , status , error ) ; } 