static int verify_parent_transid ( struct extent_io_tree * io_tree , struct extent_buffer * eb , u64 parent_transid , int atomic ) { struct extent_state * cached_state = NULL ; int ret ; bool need_lock = ( current -> journal_info == BTRFS_SEND_TRANS_STUB ) ; if ( ! parent_transid || btrfs_header_generation ( eb ) == parent_transid ) { return 0 ; } if ( atomic ) { return - EAGAIN ; } if ( need_lock ) { btrfs_tree_read_lock ( eb ) ; btrfs_set_lock_blocking_rw ( eb , BTRFS_READ_LOCK ) ; } lock_extent_bits ( io_tree , eb -> start , eb -> start + eb -> len - 1 , & cached_state ) ; if ( extent_buffer_uptodate ( eb ) && btrfs_header_generation ( eb ) == parent_transid ) { ret = 0 ; out } btrfs_err_rl ( eb -> fs_info , "parent transid verify failed on %llu wanted %llu found %llu" , eb -> start , parent_transid , btrfs_header_generation ( eb ) ) ; ret = 1 ; if ( ! extent_buffer_under_io ( eb ) ) { clear_extent_buffer_uptodate ( eb ) ; } out unlock_extent_cached ( io_tree , eb -> start , eb -> start + eb -> len - 1 , & cached_state , GFP_NOFS ) ; if ( need_lock ) { btrfs_tree_read_unlock_blocking ( eb ) ; } return ret ; } 