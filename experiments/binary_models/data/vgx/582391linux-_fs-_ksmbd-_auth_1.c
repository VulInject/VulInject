unsigned int ksmbd_build_ntlmssp_challenge_blob ( struct challenge_message * chgblob , struct ksmbd_conn * conn ) { struct target_info * tinfo ; wchar_t * name ; __u8 * target_name ; unsigned int flags , blob_off , blob_len , type , target_info_len = 0 ; int len , uni_len , conv_len ; int cflags = conn -> ntlmssp . client_flags ; memcpy ( chgblob -> Signature , NTLMSSP_SIGNATURE , 8 ) ; chgblob -> MessageType = NtLmChallenge ; flags = NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_TARGET_TYPE_SERVER | NTLMSSP_NEGOTIATE_TARGET_INFO ; if ( cflags & NTLMSSP_NEGOTIATE_SIGN ) { flags |= NTLMSSP_NEGOTIATE_SIGN ; flags |= cflags & ( NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_56 ) ; } if ( cflags & NTLMSSP_NEGOTIATE_SEAL && smb3_encryption_negotiated ( conn ) ) { flags |= NTLMSSP_NEGOTIATE_SEAL ; } if ( cflags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN ) { flags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN ; } if ( cflags & NTLMSSP_REQUEST_TARGET ) { flags |= NTLMSSP_REQUEST_TARGET ; } if ( conn -> use_spnego && ( cflags & NTLMSSP_NEGOTIATE_EXTENDED_SEC ) ) { flags |= NTLMSSP_NEGOTIATE_EXTENDED_SEC ; } if ( cflags & NTLMSSP_NEGOTIATE_KEY_XCH ) { flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; } chgblob -> NegotiateFlags = cpu_to_le32 ( flags ) ; len = strlen ( ksmbd_netbios_name ( ) ) ; name = kmalloc ( 2 + UNICODE_LEN ( len ) , GFP_KERNEL ) ; if ( ! name ) { return - ENOMEM ; } conv_len = smb_strtoUTF16 ( ( __le16 * ) name , ksmbd_netbios_name ( ) , len , conn -> local_nls ) ; if ( conv_len ( 0 || conv_len ) len ) { return - EINVAL ; } uni_len = UNICODE_LEN ( conv_len ) ; blob_off = sizeof ( challenge_message ) ; blob_len = blob_off + uni_len ; chgblob -> TargetName . Length = cpu_to_le16 ( uni_len ) ; chgblob -> TargetName . MaximumLength = cpu_to_le16 ( uni_len ) ; chgblob -> TargetName . BufferOffset = cpu_to_le32 ( blob_off ) ; get_random_bytes ( conn -> ntlmssp . cryptkey , sizeof ( __u64 ) ) ; memcpy ( chgblob -> Challenge , conn -> ntlmssp . cryptkey , CIFS_CRYPTO_KEY_SIZE ) ; chgblob -> TargetInfoArray . BufferOffset = cpu_to_le32 ( blob_len ) ; target_name = ( __u8 * ) chgblob + blob_off ; memcpy ( target_name , name , uni_len ) ; tinfo = ( target_info * ) ( target_name + uni_len ) ; chgblob -> TargetInfoArray . Length = 0 ; for ( type = NTLMSSP_AV_NB_COMPUTER_NAME ; type <= NTLMSSP_AV_DNS_DOMAIN_NAME ; type ++ ) { tinfo -> Type = cpu_to_le16 ( type ) ; tinfo -> Length = cpu_to_le16 ( uni_len ) ; memcpy ( tinfo -> Content , name , uni_len ) ; tinfo = ( target_info * ) ( ( char * ) tinfo + 4 + uni_len ) ; target_info_len += 4 + uni_len ; } tinfo -> Type = 0 ; tinfo -> Length = 0 ; target_info_len += 4 ; chgblob -> TargetInfoArray . Length = cpu_to_le16 ( target_info_len ) ; chgblob -> TargetInfoArray . MaximumLength = cpu_to_le16 ( target_info_len ) ; blob_len += target_info_len ; kfree ( name ) ; ksmbd_debug ( AUTH , "NTLMSSP SecurityBufferLength %d\n" , blob_len ) ; return blob_len ; } 