static uint find_free_dqentry ( struct qtree_mem_dqinfo * info , struct dquot * dquot , int * err ) { uint blk , i ; struct qt_disk_dqdbheader * dh ; char * buf = getdqbuf ( info -> dqi_usable_bs ) ; char * ddquot ; * err = 0 ; if ( ! buf ) { * err = - ENOMEM ; return 0 ; } dh = ( qt_disk_dqdbheader * ) buf ; if ( info -> dqi_free_entry ) { blk = info -> dqi_free_entry ; * err = read_blk ( info , blk , buf ) ; if ( * err < 0 ) { out_buf } } else { blk = get_free_dqblk ( info ) ; if ( ( int ) blk < 0 ) { * err = blk ; kfree ( buf ) ; return 0 ; } info -> dqi_free_entry = blk ; mark_info_dirty ( dquot -> dq_sb , dquot -> dq_id . type ) ; } if ( le16_to_cpu ( dh -> dqdh_entries ) + 1 >= qtree_dqstr_in_blk ( info ) ) { * err = remove_free_dqentry ( info , buf , blk ) ; if ( * err < 0 ) { quota_error ( dquot -> dq_sb , "Can't remove block (%u) " "from entry free list" , blk ) ; out_buf } } le16_add_cpu ( & dh -> dqdh_entries , 1 ) ; ddquot = buf + sizeof ( qt_disk_dqdbheader ) ; for ( i = 0 ; i < qtree_dqstr_in_blk ( info ) ; i ++ ) { if ( qtree_entry_unused ( info , ddquot ) ) { break ; } ddquot += info -> dqi_entry_size ; } if ( i == qtree_dqstr_in_blk ( info ) ) { quota_error ( dquot -> dq_sb , "Data block full but it shouldn't" ) ; * err = - EIO ; out_buf } * err = write_blk ( info , blk , buf ) ; if ( * err < 0 ) { quota_error ( dquot -> dq_sb , "Can't write quota data block %u" , blk ) ; out_buf } dquot -> dq_off = ( blk << info -> dqi_blocksize_bits ) + sizeof ( qt_disk_dqdbheader ) + i * info -> dqi_entry_size ; kfree ( buf ) ; return blk ; out_buf kfree ( buf ) ; return 0 ; } 