elf_frob_file ( ) { struct group_list list ; unsigned int i ; bfd_map_over_sections ( stdoutput , adjust_stab_sections , NULL ) ; list . num_group = 0 ; list . elt_count = NULL ; bfd_map_over_sections ( stdoutput , build_group_lists , & list ) ; for ( i = 0 ; i < list . num_group ; i ++ ) { const char * group_name = elf_group_name ( list . head [ i ] ) ; const char * sec_name ; asection * s ; flagword flags ; struct symbol * sy ; int has_sym ; bfd_size_type size ; flags = SEC_READONLY | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_GROUP ; for ( s = list . head [ i ] ; s != NULL ; s = elf_next_in_group ( s ) ) { if ( ( s -> flags ^ flags ) & SEC_LINK_ONCE ) { flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD ; if ( s != list . head [ i ] ) { as_warn ( _ ( "assuming all members of group `%s' are COMDAT" ) , group_name ) ; break ; } } } sec_name = group_name ; sy = symbol_find_exact ( group_name ) ; has_sym = 0 ; if ( sy != NULL && ( sy == symbol_lastP || ( sy -> sy_next != NULL && sy -> sy_next -> sy_previous == sy ) ) ) { has_sym = 1 ; sec_name = ".group" ; } s = subseg_force_new ( sec_name , 0 ) ; if ( s == NULL || ! bfd_set_section_flags ( stdoutput , s , flags ) || ! bfd_set_section_alignment ( stdoutput , s , 2 ) ) { as_fatal ( _ ( "can't create group: %s" ) , bfd_errmsg ( bfd_get_error ( ) ) ) ; } elf_section_type ( s ) = SHT_GROUP ; elf_next_in_group ( s ) = list . head [ i ] ; if ( has_sym ) { elf_group_id ( s ) = sy -> bsym ; } size = 4 * ( list . elt_count [ i ] + 1 ) ; bfd_set_section_size ( stdoutput , s , size ) ; s -> contents = ( unsigned char * ) frag_more ( size ) ; frag_now -> fr_fix = frag_now_fix_octets ( ) ; } elf_tc_final_processing ( ) ; } 