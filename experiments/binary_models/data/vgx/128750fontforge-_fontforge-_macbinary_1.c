static SplineFont * SearchTtfResources ( FILE * f , long rlistpos , int subcnt , long rdata_pos , long name_list , char * filename , int flags , enum openflags openflags ) { long here , start = ftell ( f ) ; long roff ; int ch1 , ch2 ; int len , i , rlen , ilen ; char * buffer = NULL ; int max = 0 ; FILE * ttf ; SplineFont * sf ; int which = 0 ; char * * names ; char * pt , * lparen ; char * find = NULL , * chosenname = NULL ; fseek ( f , rlistpos , SEEK_SET ) ; if ( subcnt > 1 || ( flags & ttf_onlynames ) ) { names = calloc ( subcnt + 1 , sizeof ( char * ) ) ; for ( i = 0 ; i < subcnt ; ++ i ) { getushort ( f ) ; getushort ( f ) ; getc ( f ) ; ch1 = getc ( f ) ; ch2 = getc ( f ) ; roff = rdata_pos + ( ( ch1 << 16 ) | ( ch2 << 8 ) | getc ( f ) ) ; getlong ( f ) ; here = ftell ( f ) ; names [ i ] = TTFGetFontName ( f , roff + 4 , roff + 4 ) ; if ( names [ i ] == NULL ) { char buffer [ 32 ] ; sprintf ( buffer , "Nameless%d" , i ) ; names [ i ] = copy ( buffer ) ; } fseek ( f , here , SEEK_SET ) ; } if ( flags & ttf_onlynames ) { return ( ( SplineFont * ) names ) ; } if ( ( pt = strrchr ( filename , '/' ) ) == NULL ) { pt = filename ; } if ( ( lparen = SFSubfontnameStart ( pt ) ) ) { find = copy ( lparen + 1 ) ; find [ strlen ( find ) - 1 ] = '\0' ; for ( which = subcnt - 1 ; which >= 0 ; -- which ) { if ( strcmp ( names [ which ] , find ) == 0 ) { break ; } } if ( which == - 1 ) { char * end ; which = strtol ( find , & end , 10 ) ; if ( * end != '\0' ) { which = - 1 ; } } if ( which == - 1 ) { char * fn = copy ( filename ) ; fn [ lparen - filename ] = '\0' ; ff_post_error ( _ ( "Not in Collection" ) , _ ( "%s is not in %.100s" ) , find , fn ) ; } free ( find ) ; } if ( no_windowing_ui ) { which = 0 ; } else { which = ff_choose ( _ ( "Pick a font, any font..." ) , ( const char * * ) names , subcnt , 0 , _ ( "There are multiple fonts in this file, pick one" ) ) ; } if ( lparen == NULL && which != - 1 ) { chosenname = copy ( names [ which ] ) ; } for ( i = 0 ; i < subcnt ; ++ i ) { free ( names [ i ] ) ; } free ( names ) ; fseek ( f , rlistpos , SEEK_SET ) ; } for ( i = 0 ; i < subcnt ; ++ i ) { getushort ( f ) ; getushort ( f ) ; getc ( f ) ; ch1 = getc ( f ) ; ch2 = getc ( f ) ; roff = rdata_pos + ( ( ch1 << 16 ) | ( ch2 << 8 ) | getc ( f ) ) ; getlong ( f ) ; if ( i != which ) { continue ; } here = ftell ( f ) ; ttf = GFileTmpfile ( ) ; if ( ttf == NULL ) { LogError ( _ ( "Can't open temporary file for truetype output.\n" ) ) ; continue ; } fseek ( f , roff , SEEK_SET ) ; ilen = rlen = getlong ( f ) ; if ( rlen > 16 * 1024 ) { ilen = 16 * 1024 ; } if ( ilen > max ) { free ( buffer ) ; max = ilen ; if ( max < 0x800 ) { max = 0x800 ; } buffer = malloc ( max ) ; } for ( len = 0 ; len < rlen ; ) { int temp = ilen ; if ( rlen - len < ilen ) { temp = rlen - len ; } temp = fread ( buffer , 1 , temp , f ) ; if ( temp == EOF ) { break ; } fwrite ( buffer , 1 , temp , ttf ) ; len += temp ; } rewind ( ttf ) ; sf = _SFReadTTF ( ttf , flags , openflags , NULL , NULL , NULL ) ; fclose ( ttf ) ; if ( sf != NULL ) { free ( buffer ) ; fseek ( f , start , SEEK_SET ) ; if ( sf -> chosenname == NULL ) { sf -> chosenname = chosenname ; } return ( sf ) ; } fseek ( f , here , SEEK_SET ) ; } free ( chosenname ) ; free ( buffer ) ; fseek ( f , start , SEEK_SET ) ; return ( NULL ) ; } 