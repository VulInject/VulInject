static int testdoor ( char * path ) { int dir ; int fd ; struct door_info di ; int res ; dir = open ( path , O_RDONLY ) ; if ( dir == - 1 ) { return ( - 1 ) ; } fd = openat ( dir , PKGDOOR , O_RDWR ) ; ( void ) close ( dir ) ; if ( fd == - 1 ) { return ( - 1 ) ; } res = door_info ( fd , & di ) ; ( void ) close ( fd ) ; return ( res ) ; } static void pkgfindrealsadmdir ( char fullpath [ PATH_MAX ] , const char * root , const char * * sadmdir ) { struct stat buf ; struct extmnttab xmnt ; FILE * mnttab = NULL ; int temp [ PATH_MAX ] ; struct extmnttab saved = { NULL NULL NULL NULL NULL 0 0 } ; if ( snprintf ( temp , PATH_MAX , "%s%s" , root == NULL ?"" : root , * sadmdir == NULL ?SADM_DIR : * sadmdir ) >= PATH_MAX ) { progerr ( gettext ( ERR_PATH_TOO_BIG ) ) ; exit ( 99 ) ; } if ( stat ( temp , & buf ) != 0 ) { progerr ( gettext ( ERR_FIND_SADM ) ) ; exit ( 99 ) ; } for ( ; ; ) { size_t max = 0 ; if ( realpath ( temp , fullpath ) == NULL ) { progerr ( gettext ( ERR_FIND_SADM ) ) ; exit ( 99 ) ; } if ( strcmp ( fullpath , SADM_DIR ) == 0 ) { break ; } if ( testdoor ( fullpath ) == 0 ) { break ; } if ( mnttab == NULL ) { mnttab = fopen ( MNTTAB , "r" ) ; } else { resetmnttab ( mnttab ) ; } while ( getextmntent ( mnttab , & xmnt , 0 ) == 0 ) { size_t len ; if ( major ( buf . st_dev ) != xmnt . mnt_major || minor ( buf . st_dev ) != xmnt . mnt_minor ) { continue ; } len = strlen ( xmnt . mnt_mountp ) ; if ( len < max ) { continue ; } if ( strncmp ( xmnt . mnt_mountp , fullpath , len ) == 0 && ( len == 1 || fullpath [ len ] == '/' || fullpath [ len ] == '\0' ) ) { max = len ; copy_xmnt ( & xmnt , & saved ) ; } } if ( strcmp ( saved . mnt_fstype , "lofs" ) != 0 || strcmp ( saved . mnt_mountp , saved . mnt_special ) == 0 ) { break ; } if ( snprintf ( temp , PATH_MAX , "%s%s" , saved . mnt_special , & fullpath [ max ] ) >= PATH_MAX ) { progerr ( gettext ( ERR_PATH_TOO_BIG ) ) ; exit ( 99 ) ; } } if ( mnttab != NULL ) { free_xmnt ( & saved ) ; ( void ) fclose ( mnttab ) ; } * sadmdir = fullpath ; } 