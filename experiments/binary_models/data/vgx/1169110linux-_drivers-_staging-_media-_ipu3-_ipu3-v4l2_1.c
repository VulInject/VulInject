static int imgu_vb2_start_streaming ( struct vb2_queue * vq , unsigned int count ) { struct imgu_media_pipe * imgu_pipe ; struct imgu_device * imgu = vb2_get_drv_priv ( vq ) ; struct device * dev = & imgu -> pci_dev -> dev ; struct imgu_video_device * node = container_of ( vq , imgu_video_device , vbq ) ; int r ; unsigned int pipe ; dev_dbg ( dev , "%s node name %s pipe %u id %u" , __func__ , node -> name , node -> pipe , node -> id ) ; mutex_lock ( & imgu -> streaming_lock ) ; if ( imgu -> streaming ) { r = - EBUSY ; mutex_unlock ( & imgu -> streaming_lock ) ; fail_return_bufs } mutex_unlock ( & imgu -> streaming_lock ) ; if ( ! node -> enabled ) { dev_err ( dev , "IMGU node is not enabled" ) ; r = - EINVAL ; fail_return_bufs } pipe = node -> pipe ; imgu_pipe = & imgu -> imgu_pipe [ pipe ] ; atomic_set ( & node -> sequence , 0 ) ; r = video_device_pipeline_start ( & node -> vdev , & imgu_pipe -> pipeline ) ; if ( r < 0 ) { fail_return_bufs } for_each_set_bit ( , , ) { r = v4l2_subdev_call ( & imgu -> imgu_pipe [ pipe ] . imgu_sd . subdev , video , s_stream , 1 ) ; if ( r < 0 ) { fail_stop_pipeline } } dev_dbg ( dev , "IMGU streaming is ready to start" ) ; mutex_lock ( & imgu -> streaming_lock ) ; r = imgu_s_stream ( imgu , true ) ; if ( ! r ) { imgu -> streaming = true ; } mutex_unlock ( & imgu -> streaming_lock ) ; return 0 ; fail_stop_pipeline video_device_pipeline_stop ( & node -> vdev ) ; fail_return_bufs imgu_return_all_buffers ( imgu , node , VB2_BUF_STATE_QUEUED ) ; return r ; } 