static void tunnel_on_udp_sock_read ( h2o_socket_t * sock , const char * err ) { uint8_t buf [ 1500 ] ; struct iovec vec ; struct msghdr mess = { } ; ssize_t rret ; { vec . iov_base = buf ; vec . iov_len = sizeof ( buf ) ; mess . msg_name = & udp_sock_remote_addr ; mess . msg_namelen = sizeof ( udp_sock_remote_addr ) ; mess . msg_iov = & vec ; mess . msg_iovlen = 1 ; } ( rret = recvmsg ( h2o_socket_get_fd ( sock ) , & mess , 0 ) ) == - 1 && errno == EINTR ; if ( rret == - 1 ) { return ; } h2o_httpclient_t * client = std_in . sock -> data ; if ( udp_write != NULL ) { h2o_iovec_t datagram = h2o_iovec_init ( buf , rret ) ; udp_write ( client , & datagram , 1 ) ; } else { uint8_t header [ 3 ] { 0 } ; , * header_end = quicly_encodev ( header + 1 , ( uint64_t ) rret ) ; h2o_buffer_append ( & std_in . sock -> input , header , header_end - header ) ; h2o_buffer_append ( & std_in . sock -> input , buf , rret ) ; stdin_on_read ( std_in . sock , NULL ) ; } } 