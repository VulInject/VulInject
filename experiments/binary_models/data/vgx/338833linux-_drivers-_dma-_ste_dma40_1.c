static irqreturn_t d40_handle_interrupt ( int irq , void * data ) { int i ; u32 idx ; u32 row ; long chan = - 1 ; struct d40_chan * d40c ; struct d40_base * base = data ; u32 * regs = base -> regs_interrupt ; struct d40_interrupt_lookup * il = base -> gen_dmac . il ; u32 il_size = base -> gen_dmac . il_size ; spin_lock ( & base -> interrupt_lock ) ; for ( i = 0 ; i < il_size ; i ++ ) { regs [ i ] = readl ( base -> virtbase + il [ i ] . src ) ; } for ( ; ; ) { chan = find_next_bit ( ( unsigned long * ) regs , BITS_PER_LONG * il_size , chan + 1 ) ; if ( chan == BITS_PER_LONG * il_size ) { break ; } row = chan / BITS_PER_LONG ; idx = chan & ( BITS_PER_LONG - 1 ) ; if ( il [ row ] . offset == D40_PHY_CHAN ) { d40c = base -> lookup_phy_chans [ idx ] ; } else { d40c = base -> lookup_log_chans [ il [ row ] . offset + idx ] ; } writel ( BIT ( idx ) , base -> virtbase + il [ row ] . clr ) ; spin_lock ( & d40c -> lock ) ; if ( ! il [ row ] . is_error ) { dma_tc_handle ( d40c ) ; } else { d40_err ( base -> dev , "IRQ chan: %ld offset %d idx %d\n" , chan , il [ row ] . offset , idx ) ; } spin_unlock ( & d40c -> lock ) ; } spin_unlock ( & base -> interrupt_lock ) ; return IRQ_HANDLED ; } 