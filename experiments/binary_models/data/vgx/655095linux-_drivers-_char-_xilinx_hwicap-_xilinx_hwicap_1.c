static ssize_t hwicap_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct hwicap_drvdata * drvdata = file -> private_data ; ssize_t bytes_to_read = 0 ; u32 * kbuf ; u32 words ; u32 bytes_remaining ; int status ; status = mutex_lock_interruptible ( & drvdata -> sem ) ; if ( status ) { return status ; } if ( drvdata -> read_buffer_in_use ) { bytes_to_read = ( count < drvdata -> read_buffer_in_use ) ?count : drvdata -> read_buffer_in_use ; if ( copy_to_user ( buf , drvdata -> read_buffer , bytes_to_read ) ) { status = - EFAULT ; error } drvdata -> read_buffer_in_use -= bytes_to_read ; memmove ( drvdata -> read_buffer , drvdata -> read_buffer + bytes_to_read , 4 - bytes_to_read ) ; } else { kbuf = ( u32 * ) get_zeroed_page ( GFP_KERNEL ) ; if ( ! kbuf ) { status = - ENOMEM ; error } words = ( ( count + 3 ) >> 2 ) ; bytes_to_read = words << 2 ; if ( bytes_to_read > PAGE_SIZE ) { bytes_to_read = PAGE_SIZE ; } bytes_remaining = bytes_to_read & 3 ; bytes_to_read &= ~ 3 ; words = bytes_to_read >> 2 ; status = drvdata -> config -> get_configuration ( drvdata , kbuf , words ) ; if ( status ) { free_page ( ( unsigned long ) kbuf ) ; error } if ( copy_to_user ( buf , kbuf , bytes_to_read ) ) { free_page ( ( unsigned long ) kbuf ) ; status = - EFAULT ; error } memcpy ( drvdata -> read_buffer , kbuf , bytes_remaining ) ; drvdata -> read_buffer_in_use = bytes_remaining ; free_page ( ( unsigned long ) kbuf ) ; } status = bytes_to_read ; error return status ; } 