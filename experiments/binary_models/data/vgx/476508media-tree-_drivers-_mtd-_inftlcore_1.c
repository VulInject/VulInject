static inline u16 INFTL_findwriteunit ( struct INFTLrecord * inftl , unsigned block ) { unsigned int thisVUC = block / ( inftl -> EraseSize / SECTORSIZE ) ; unsigned int thisEUN , writeEUN , prev_block , status ; unsigned long blockofs = ( block * SECTORSIZE ) & ( inftl -> EraseSize - 1 ) ; struct mtd_info * mtd = inftl -> mbd . mtd ; struct inftl_oob oob ; struct inftl_bci bci ; unsigned char anac , nacs , parity ; size_t retlen ; int silly , silly2 = 3 ; pr_debug ( "INFTL: INFTL_findwriteunit(inftl=%p,block=%d)\n" , inftl , block ) ; { writeEUN = BLOCK_NIL ; thisEUN = inftl -> VUtable [ thisVUC ] ; silly = MAX_LOOPS ; while ( thisEUN <= inftl -> lastEUN ) { inftl_read_oob ( mtd , ( thisEUN * inftl -> EraseSize ) + blockofs , 8 , & retlen , ( char * ) & bci ) ; status = bci . Status | bci . Status1 ; pr_debug ( "INFTL: status of block %d in EUN %d is %x\n" , block , writeEUN , status ) ; switch ( status ) { case SECTOR_FREE : writeEUN = thisEUN ; break ; case SECTOR_DELETED : case SECTOR_USED : hitused case SECTOR_IGNORE : break ; default : break ; } if ( ! silly -- ) { printk ( KERN_WARNING "INFTL: infinite loop in " "Virtual Unit Chain 0x%x\n" , thisVUC ) ; return BLOCK_NIL ; } thisEUN = inftl -> PUtable [ thisEUN ] ; } hitused writeEUN = INFTL_findfreeblock ( inftl , 0 ) ; if ( writeEUN == BLOCK_NIL ) { thisEUN = INFTL_makefreeblock ( inftl , block ) ; pr_debug ( "INFTL: using desperate==1 to find free EUN " "to accommodate write to VUC %d\n" , thisVUC ) ; writeEUN = INFTL_findfreeblock ( inftl , 1 ) ; if ( writeEUN == BLOCK_NIL ) { printk ( KERN_WARNING "INFTL: cannot make free " "space.\n" ) ; INFTL_dumptables ( inftl ) ; INFTL_dumpVUchains ( inftl ) ; return BLOCK_NIL ; } } anac = 0 ; nacs = 0 ; thisEUN = inftl -> VUtable [ thisVUC ] ; if ( thisEUN != BLOCK_NIL ) { inftl_read_oob ( mtd , thisEUN * inftl -> EraseSize + 8 , 8 , & retlen , ( char * ) & oob . u ) ; anac = oob . u . a . ANAC + 1 ; nacs = oob . u . a . NACs + 1 ; } prev_block = inftl -> VUtable [ thisVUC ] ; if ( prev_block < inftl -> nb_blocks ) { prev_block -= inftl -> firstEUN ; } parity = ( nrbits ( thisVUC , 16 ) & 0x1 ) ?0x1 : 0 ; parity |= ( nrbits ( prev_block , 16 ) & 0x1 ) ?0x2 : 0 ; parity |= ( nrbits ( anac , 8 ) & 0x1 ) ?0x4 : 0 ; parity |= ( nrbits ( nacs , 8 ) & 0x1 ) ?0x8 : 0 ; oob . u . a . virtualUnitNo = cpu_to_le16 ( thisVUC ) ; oob . u . a . prevUnitNo = cpu_to_le16 ( prev_block ) ; oob . u . a . ANAC = anac ; oob . u . a . NACs = nacs ; oob . u . a . parityPerField = parity ; oob . u . a . discarded = 0xaa ; inftl_write_oob ( mtd , writeEUN * inftl -> EraseSize + 8 , 8 , & retlen , ( char * ) & oob . u ) ; oob . u . b . virtualUnitNo = cpu_to_le16 ( thisVUC ) ; oob . u . b . prevUnitNo = cpu_to_le16 ( prev_block ) ; oob . u . b . ANAC = anac ; oob . u . b . NACs = nacs ; oob . u . b . parityPerField = parity ; oob . u . b . discarded = 0xaa ; inftl_write_oob ( mtd , writeEUN * inftl -> EraseSize + SECTORSIZE * 4 + 8 , 8 , & retlen , ( char * ) & oob . u ) ; inftl -> PUtable [ writeEUN ] = inftl -> VUtable [ thisVUC ] ; inftl -> VUtable [ thisVUC ] = writeEUN ; inftl -> numfreeEUNs -- ; return writeEUN ; } silly2 -- ; printk ( KERN_WARNING "INFTL: error folding to make room for Virtual " "Unit Chain 0x%x\n" , thisVUC ) ; return BLOCK_NIL ; } 