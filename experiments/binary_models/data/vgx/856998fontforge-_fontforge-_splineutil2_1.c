void SplinePointListSimplify ( SplineChar * sc , SplinePointList * spl , struct simplifyinfo * smpl ) { SplinePoint * first , * next , * sp , * nsp ; BasePoint suv , nuv ; bigreal lenmax2 = smpl -> linelenmax * smpl -> linelenmax ; RemoveZeroLengthSplines ( spl , false , 0.1 ) ; RemoveStupidControlPoints ( spl ) ; SSRemoveBacktracks ( spl ) ; if ( smpl -> flags != sf_cleanup && ( smpl -> flags & sf_setstart2extremum ) ) { SPLStartToExtremum ( sc , spl ) ; } if ( spl -> first -> next != NULL && spl -> first -> next -> to == spl -> first && spl -> first -> nonextcp && spl -> first -> noprevcp ) { return ; } if ( smpl -> flags != sf_cleanup && ( smpl -> flags & sf_forcelines ) ) { SPLNearlyHvLines ( sc , spl , smpl -> linefixup ) ; SPLForceLines ( sc , spl , smpl -> linefixup ) ; } if ( smpl -> flags != sf_cleanup && spl -> first -> prev != NULL && spl -> first -> prev != spl -> first -> next ) { for ( sp = spl -> first ; ; ) { if ( sp -> next == NULL ) { break ; } if ( SPisExtremum ( sp ) ) { GetNextUnitVector ( sp , & suv ) ; for ( nsp = sp -> next -> to ; nsp != sp ; nsp = nsp -> next -> to ) { if ( nsp -> next == NULL ) { break ; } if ( nsp -> prev -> knownlinear && ( nsp -> me . x - nsp -> prev -> from -> me . x ) * ( nsp -> me . x - nsp -> prev -> from -> me . x ) + ( nsp -> me . y - nsp -> prev -> from -> me . y ) * ( nsp -> me . y - nsp -> prev -> from -> me . y ) >= lenmax2 ) { nogood } GetNextUnitVector ( nsp , & nuv ) ; if ( suv . x * nuv . x + suv . y * nuv . y < 0 ) { if ( suv . x * nuv . x + suv . y * nuv . y > - .1 ) { break ; } nogood } if ( SPisExtremum ( nsp ) || nsp == spl -> first ) { break ; } } if ( nsp == sp ) { break ; } if ( sp -> next -> to == nsp ) { nogood } if ( SplinesRemoveBetweenMaybe ( sc , sp , nsp , smpl -> flags , smpl -> err ) ) { if ( spl -> last == spl -> first ) { spl -> last = spl -> first = sp ; spl -> start_offset = 0 ; } } nogood sp = nsp ; } else { sp = sp -> next -> to ; } if ( sp == spl -> first ) { break ; } } while ( 1 ) { first = spl -> first -> prev -> from ; if ( first -> prev == first -> next ) { return ; } if ( ! SplinesRemoveMidMaybe ( sc , spl -> first , smpl -> flags , smpl -> err , lenmax2 ) ) { break ; } if ( spl -> first == spl -> last ) { spl -> last = first ; } spl -> first = first ; spl -> start_offset = 0 ; } } if ( spl -> first -> next == NULL ) { return ; } for ( sp = spl -> first -> next -> to ; sp -> next != NULL ; sp = next ) { SplineIsLinearMake ( sp -> prev ) ; next = sp -> next -> to ; if ( sp -> prev == sp -> next || ( sp -> next != NULL && sp -> next -> to -> next != NULL && sp -> next -> to -> next -> to == sp ) ) { return ; } if ( smpl -> flags != sf_cleanup ) { if ( SplinesRemoveMidMaybe ( sc , sp , smpl -> flags , smpl -> err , lenmax2 ) ) { if ( spl -> first == sp ) { spl -> first = next ; spl -> start_offset = 0 ; } if ( spl -> last == sp ) { spl -> last = next ; } continue ; } } else { while ( sp -> me . x == next -> me . x && sp -> me . y == next -> me . y && sp -> nextcp . x > sp -> me . x - 1 && sp -> nextcp . x ( sp -> me . x + 1 && sp -> nextcp . y ) sp -> me . y - 1 && sp -> nextcp . y ( sp -> me . y + 1 && next -> prevcp . x ) next -> me . x - 1 && next -> prevcp . x ( next -> me . x + 1 && next -> prevcp . y ) next -> me . y - 1 && next -> prevcp . y < next -> me . y + 1 ) { SplineFree ( sp -> next ) ; sp -> next = next -> next ; if ( sp -> next != NULL ) { sp -> next -> from = sp ; } sp -> nextcp = next -> nextcp ; sp -> nextcpdef = next -> nextcpdef ; SplinePointMDFree ( sc , next ) ; if ( sp -> next != NULL ) { SplineRefigure ( sp -> next ) ; next = sp -> next -> to ; } else { next = NULL ; break ; } } if ( next == NULL ) { break ; } } if ( next -> prev != NULL && next -> prev -> from == spl -> last ) { break ; } } if ( smpl -> flags != sf_cleanup && ( smpl -> flags & sf_smoothcurves ) ) { SPLSmoothControlPoints ( spl , smpl -> tan_bounds , smpl -> flags & sf_choosehv ) ; } } 