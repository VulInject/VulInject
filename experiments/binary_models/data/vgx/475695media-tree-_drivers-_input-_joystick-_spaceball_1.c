static int spaceball_connect ( struct serio * serio , struct serio_driver * drv ) { struct spaceball * spaceball ; struct input_dev * input_dev ; int err = - ENOMEM ; int i , id ; if ( ( id = serio -> id . id ) > SPACEBALL_MAX_ID ) { return - ENODEV ; } spaceball = kmalloc ( sizeof ( spaceball ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! spaceball || ! input_dev ) { fail1 } spaceball -> dev = input_dev ; sprintf ( spaceball -> phys , "%s/input0" , serio -> phys ) ; input_dev -> name = spaceball_names [ id ] ; input_dev -> phys = spaceball -> phys ; input_dev -> id . bustype = BUS_RS232 ; input_dev -> id . vendor = SERIO_SPACEBALL ; input_dev -> id . product = id ; input_dev -> id . version = 0x0100 ; input_dev -> dev . parent = & serio -> dev ; input_dev -> evbit [ 0 ] = BIT_MASK ( EV_KEY ) | BIT_MASK ( EV_ABS ) ; switch ( id ) { case SPACEBALL_4000FLX : case SPACEBALL_4000FLX_L : input_dev -> keybit [ BIT_WORD ( BTN_0 ) ] |= BIT_MASK ( BTN_9 ) ; input_dev -> keybit [ BIT_WORD ( BTN_A ) ] |= BIT_MASK ( BTN_A ) | BIT_MASK ( BTN_B ) | BIT_MASK ( BTN_C ) | BIT_MASK ( BTN_MODE ) ; default : input_dev -> keybit [ BIT_WORD ( BTN_0 ) ] |= BIT_MASK ( BTN_2 ) | BIT_MASK ( BTN_3 ) | BIT_MASK ( BTN_4 ) | BIT_MASK ( BTN_5 ) | BIT_MASK ( BTN_6 ) | BIT_MASK ( BTN_7 ) | BIT_MASK ( BTN_8 ) ; case SPACEBALL_3003C : input_dev -> keybit [ BIT_WORD ( BTN_0 ) ] |= BIT_MASK ( BTN_1 ) | BIT_MASK ( BTN_8 ) ; } for ( i = 0 ; i < 3 ; i ++ ) { input_set_abs_params ( input_dev , ABS_X + i , - 8000 , 8000 , 8 , 40 ) ; input_set_abs_params ( input_dev , ABS_RX + i , - 1600 , 1600 , 2 , 8 ) ; } serio_set_drvdata ( serio , spaceball ) ; err = serio_open ( serio , drv ) ; if ( err ) { fail2 } err = input_register_device ( spaceball -> dev ) ; if ( err ) { fail3 } return 0 ; fail3 serio_close ( serio ) ; fail2 serio_set_drvdata ( serio , NULL ) ; fail1 input_free_device ( input_dev ) ; kfree ( spaceball ) ; return err ; } 