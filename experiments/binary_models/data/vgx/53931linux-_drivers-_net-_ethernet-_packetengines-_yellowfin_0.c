static int FUN1(struct VAR1 *VAR2)
{
struct VAR3 *VAR4 = FUN2(VAR2);
int VAR5, VAR6;

VAR4->VAR7 = 0;
VAR4->VAR8 = VAR4->VAR9 = 0;
VAR4->VAR10 = 0;

VAR4->VAR11 = (VAR2->VAR12 <= 1500 ? VAR13 : VAR2->VAR12 + 32);

for (VAR5 = 0; VAR5 < VAR14; VAR5++) {
VAR4->VAR15[VAR5].VAR16 =
FUN3(VAR17 | VAR18 | VAR4->VAR11);
VAR4->VAR15[VAR5].VAR19 = FUN3(VAR4->VAR20 +
((VAR5+1)%VAR14)*sizeof(struct VAR21));
}

for (VAR5 = 0; VAR5 < VAR14; VAR5++) {
struct VAR22 *VAR23 = FUN4(VAR2, VAR4->VAR11 + 2);
VAR4->VAR24[VAR5] = VAR23;
if (VAR23 == NULL)
break;
FUN5(VAR23, 2);	
VAR4->VAR15[VAR5].VAR25 = FUN3(FUN6(&VAR4->VAR26->VAR2,
VAR23->VAR27,
VAR4->VAR11,
VAR28));
}
if (VAR5 != VAR14) {
for (VAR6 = 0; VAR6 < VAR5; VAR6++)
FUN7(VAR4->VAR24[VAR6]);
return -VAR29;
}
VAR4->VAR15[VAR5-1].VAR16 = FUN3(VAR30);
VAR4->VAR31 = (unsigned int)(VAR5 - VAR14);


for (VAR5 = 0; VAR5 < VAR32; VAR5++) {
VAR4->VAR33[VAR5] = NULL;
VAR4->VAR34[VAR5].VAR16 = FUN3(VAR30);
VAR4->VAR34[VAR5].VAR19 = FUN3(VAR4->VAR35 +
((VAR5+1)%VAR32)*sizeof(struct VAR21));
}

VAR4->VAR34[--VAR5].VAR16 = FUN3(VAR30 | VAR36);
{

for (VAR5 = 0; VAR5 < VAR32; VAR5++) {
VAR6 = 2*VAR5;
VAR4->VAR33[VAR5] = 0;

VAR4->VAR34[VAR6].VAR16 = FUN3(VAR30);
VAR4->VAR34[VAR6].VAR19 = FUN3(VAR4->VAR35 +
(VAR6+1)*sizeof(struct VAR21));
VAR6++;
if (VAR4->VAR37 & VAR38) {
VAR4->VAR34[VAR6].VAR16 =
FUN3(VAR39 | sizeof(*VAR4->VAR40));
VAR4->VAR34[VAR6].VAR41 = sizeof(*VAR4->VAR40);
VAR4->VAR34[VAR6].VAR25 = FUN3(VAR4->VAR42 +
VAR5*sizeof(struct VAR43));
} else {

VAR4->VAR34[VAR6].VAR16 =
FUN3(VAR39 | VAR18 | 2);
VAR4->VAR34[VAR6].VAR41 = 2;

VAR4->VAR34[VAR6].VAR25 = FUN3(VAR4->VAR42 +
VAR5*sizeof(struct VAR43) +
&(VAR4->VAR40[0].VAR44) -
&(VAR4->VAR40[0]));
}
VAR4->VAR34[VAR6].VAR19 = FUN3(VAR4->VAR35 +
((VAR6+1)%(2*VAR32))*sizeof(struct VAR21));
}

VAR4->VAR34[++VAR6].VAR16 |= FUN3(VAR36 | VAR18);
}