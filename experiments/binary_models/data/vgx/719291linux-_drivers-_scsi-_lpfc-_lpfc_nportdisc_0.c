static VAR1
FUN1(struct VAR2 *VAR3,
struct VAR4 *VAR5,
void *VAR6,
uint32_t VAR7)
{
struct VAR8    *VAR9 = VAR3->VAR9;
struct VAR10  *VAR11, *VAR12;
struct VAR13 *VAR14, *VAR15;
VAR1 *VAR16;
uint32_t VAR17, VAR18;
struct VAR19 *VAR20;
uint32_t VAR21;
VAR22 *VAR23;
int VAR24;
u32 VAR25;
u32 VAR26;

VAR11 = (struct VAR10 *) VAR6;
VAR12 = VAR11->VAR27;

VAR25 = FUN2(VAR9, VAR12);

if (VAR5->VAR28 & VAR29) {

return VAR5->VAR30;
}

if (VAR25)
goto VAR31;

VAR14 = VAR11->VAR32;

VAR15 = FUN3(&VAR14->VAR33, struct VAR13, VAR33);
if (!VAR15)
goto VAR31;

VAR16 = (VAR1 *) VAR15->VAR34;
VAR20 = (struct VAR19 *) ((VAR35 *) VAR16 + sizeof (VAR1));


if ((VAR5->VAR36 != VAR37) &&
(FUN4(VAR20->VAR38.VAR39.VAR40) == 0 ||
FUN4(VAR20->VAR41.VAR39.VAR40) == 0)) {
FUN5(VAR3, VAR42, VAR43,
"");
goto VAR31;
}
if (!FUN6(VAR3, VAR5, VAR20, VAR44, 0))
goto VAR31;

FUN5(VAR3, VAR45, VAR46,
"",
VAR5->VAR36, VAR5->VAR30,
VAR5->VAR28, VAR5->VAR47);
if (VAR3->VAR48 == 2 && (VAR20->VAR49.VAR50))
VAR5->VAR51 |= VAR52;
else
VAR5->VAR51 |= VAR44;

VAR5->VAR53 = 0;
if (VAR20->VAR54.VAR50)
VAR5->VAR53 |= VAR55;
if (VAR20->VAR49.VAR50)
VAR5->VAR53 |= VAR56;
if (VAR20->VAR57.VAR50)
VAR5->VAR53 |= VAR58;
if (VAR20->VAR59.VAR50)
VAR5->VAR53 |= VAR60;
VAR5->VAR61 =
((VAR20->VAR62.VAR63 & 0x0F) << 8) | VAR20->VAR62.VAR64;

if ((VAR3->VAR65 & VAR66) &&
(VAR3->VAR65 & VAR67)) {
VAR21 = FUN7(VAR20->VAR62.VAR68);
if (VAR20->VAR62.VAR69) {

VAR21 = (VAR9->VAR70 + 999999) / 1000000;
}

VAR5->VAR28 &= ~VAR71;
if ((VAR9->VAR72.VAR73 & VAR74) &&
VAR20->VAR62.VAR75) {
VAR17 = FUN7(VAR20->VAR76.VAR77.VAR17);
VAR18 = FUN7(VAR20->VAR76.VAR77.VAR78);
if ((VAR17 == VAR79) &&
(VAR18 & VAR80))
VAR5->VAR28 |= VAR71;
}


if (VAR21 > VAR9->VAR70)
VAR9->VAR70 = VAR21;
VAR9->VAR81 = (2 * VAR9->VAR70) / 1000;

memcpy(&VAR9->VAR82, VAR20, sizeof(struct VAR19));


if (VAR9->VAR83 == VAR84) {
FUN8(VAR3);
} else {
VAR23 = FUN9(VAR9->VAR85, VAR86);
if (!VAR23) {
FUN5(VAR3, VAR42,
VAR43,
""
""
"",
VAR5->VAR36, VAR5->VAR30,
VAR5->VAR28, VAR5->VAR47);
goto VAR31;
}

FUN10(VAR9, VAR23);

VAR23->VAR87 = VAR88;
VAR23->VAR3 = VAR3;
VAR24 = FUN11(VAR9, VAR23, VAR89);
if (VAR24 == VAR90) {
FUN12(VAR23, VAR9->VAR85);
goto VAR31;
}
}
}

FUN13(VAR3, VAR5);

VAR23 = FUN9(VAR9->VAR85, VAR86);
if (!VAR23) {
FUN5(VAR3, VAR42, VAR43,
""
"",
VAR5->VAR36, VAR5->VAR30,
VAR5->VAR28, VAR5->VAR47);
goto VAR31;
}

VAR26 = FUN14(VAR9, VAR11);

if (FUN15(VAR9, VAR3->VAR91, VAR26,
(VAR35 *) VAR20, VAR23, VAR5->VAR47) == 0) {
switch (VAR5->VAR36) {
case VAR92:
VAR23->VAR87 = VAR93;

memcpy(&VAR5->VAR94, VAR20, sizeof(struct VAR19));
break;
case VAR37:
VAR23->VAR87 = VAR95;
break;
default:
VAR5->VAR28 |= VAR96;
VAR23->VAR87 = VAR97;
}

VAR23->VAR98 = FUN16(VAR5);
if (!VAR23->VAR98)
goto VAR31;

VAR23->VAR3 = VAR3;
if (FUN11(VAR9, VAR23, VAR89)
!= VAR90) {
FUN17(VAR3, VAR5,
VAR99);
return VAR5->VAR30;
}
if (VAR5->VAR28 & VAR96)
VAR5->VAR28 &= ~VAR96;

FUN18(VAR5);
FUN19(VAR9, VAR23, VAR100);
FUN5(VAR3, VAR42, VAR43,
""
"",
VAR5->VAR36, VAR5->VAR30,
VAR5->VAR28, VAR5->VAR47);
} else {
FUN12(VAR23, VAR9->VAR85);

FUN5(VAR3, VAR42, VAR43,
""
"",
VAR5->VAR36, VAR5->VAR30,
VAR5->VAR28, VAR5->VAR47);
}


VAR31:
if (VAR5->VAR36 == VAR92) {
FUN20(VAR3, VAR101);
FUN5(VAR3, VAR42, VAR43,
"");
}



VAR5->VAR102 = VAR5->VAR30;
FUN17(VAR3, VAR5, VAR103);
return VAR104;
}