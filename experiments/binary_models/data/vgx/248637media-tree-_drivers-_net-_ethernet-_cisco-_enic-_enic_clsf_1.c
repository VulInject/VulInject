void enic_flow_may_expire ( unsigned long data ) { struct enic * enic = ( enic * ) data ; bool res ; int j ; spin_lock_bh ( & enic -> rfs_h . lock ) ; for ( j = 0 ; j < ENIC_CLSF_EXPIRE_COUNT ; j ++ ) { struct hlist_head * hhead ; struct hlist_node * tmp ; struct enic_rfs_fltr_node * n ; hhead = & enic -> rfs_h . ht_head [ enic -> rfs_h . toclean ++ ] ; hlist_for_each_entry_safe ( , , , ) { res = rps_may_expire_flow ( enic -> netdev , n -> rq_id , n -> flow_id , n -> fltr_id ) ; if ( res ) { res = enic_delfltr ( enic , n -> fltr_id ) ; if ( unlikely ( res ) ) { continue ; } hlist_del ( & n -> node ) ; enic -> rfs_h . free ++ ; } } } spin_unlock_bh ( & enic -> rfs_h . lock ) ; mod_timer ( & enic -> rfs_h . rfs_may_expire , jiffies + HZ / 4 ) ; } 