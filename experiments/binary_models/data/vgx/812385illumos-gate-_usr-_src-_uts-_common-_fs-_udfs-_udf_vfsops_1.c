static int32_t ud_mountfs ( struct vfs * vfsp , enum whymountroot why , dev_t dev , char * name , struct cred * cr , int32_t isroot ) { struct vnode * devvp ; int32_t error = 0 ; int32_t needclose = 0 ; struct udf_vfs * udf_vfsp = NULL ; struct log_vol_int_desc * lvid ; struct ud_inode * rip = NULL ; struct vnode * rvp = NULL ; int32_t i , lbsize ; uint32_t avd_loc ; struct ud_map * map ; int32_t desc_len ; ud_printf ( "ud_mountfs\n" ) ; if ( why == ROOT_INIT ) { devvp = makespecvp ( dev , VBLK ) ; error = VOP_OPEN ( & devvp , ( vfsp -> vfs_flag & VFS_RDONLY ) ?FREAD : FREAD | FWRITE , cr , NULL ) ; if ( error ) { out } needclose = 1 ; if ( IS_SWAPVP ( devvp ) ) { error = EBUSY ; out } } if ( vfsp -> vfs_flag & VFS_REMOUNT ) { struct tag * ttag ; int32_t index , count ; struct buf * tpt = 0 ; caddr_t addr ; if ( vfsp -> vfs_flag & VFS_RDONLY ) { return ( EINVAL ) ; } if ( vfsp -> vfs_dev != dev ) { return ( EINVAL ) ; } udf_vfsp = ( udf_vfs * ) vfsp -> vfs_data ; devvp = udf_vfsp -> udf_devvp ; if ( udf_vfsp -> udf_flags & UDF_FL_RDONLY ) { ( void ) dnlc_purge_vfsp ( vfsp , 0 ) ; ( void ) VOP_PUTPAGE ( devvp , ( offset_t ) 0 , ( uint_t ) 0 , B_INVAL , CRED ( ) , NULL ) ; ( void ) ud_iflush ( vfsp ) ; bflush ( dev ) ; binval ( dev ) ; } if ( ( udf_vfsp -> udf_miread > UDF_150 ) || ( udf_vfsp -> udf_miwrite > UDF_150 ) ) { error = EINVAL ; remountout } if ( udf_vfsp -> udf_flags & UDF_FL_RW ) { remountout } if ( udf_vfsp -> udf_mtype != UDF_MT_OW ) { error = EINVAL ; remountout } tpt = ud_bread ( vfsp -> vfs_dev , udf_vfsp -> udf_iseq_loc << udf_vfsp -> udf_l2d_shift , udf_vfsp -> udf_iseq_len ) ; if ( tpt -> b_flags & B_ERROR ) { error = EIO ; remountout } count = udf_vfsp -> udf_iseq_len / DEV_BSIZE ; addr = tpt -> b_un . b_addr ; for ( index = 0 ; index < count ; index ++ ) { ttag = ( tag * ) ( addr + index * DEV_BSIZE ) ; desc_len = udf_vfsp -> udf_iseq_len - ( index * DEV_BSIZE ) ; if ( ud_verify_tag_and_desc ( ttag , UD_LOG_VOL_INT , udf_vfsp -> udf_iseq_loc + ( index >> udf_vfsp -> udf_l2d_shift ) , 1 , desc_len ) == 0 ) { struct log_vol_int_desc * lvid ; lvid = ( log_vol_int_desc * ) ttag ; if ( SWAP_32 ( lvid -> lvid_int_type ) != LOG_VOL_CLOSE_INT ) { error = EINVAL ; remountout } bcopy ( udf_vfsp -> udf_iseq -> b_un . b_addr , tpt -> b_un . b_addr , udf_vfsp -> udf_iseq_len ) ; break ; } } udf_vfsp -> udf_flags = UDF_FL_RW ; mutex_enter ( & udf_vfsp -> udf_lock ) ; ud_sbwrite ( udf_vfsp ) ; mutex_exit ( & udf_vfsp -> udf_lock ) ; remountout if ( tpt != NULL ) { tpt -> b_flags = B_AGE | B_STALE ; brelse ( tpt ) ; } return ( error ) ; } ASSERT ( devvp != 0 ) ; ( void ) VOP_PUTPAGE ( common_specvp ( devvp ) , ( offset_t ) 0 , ( uint32_t ) 0 , B_INVAL , cr , NULL ) ; _NOTE ( NO_COMPETING_THREADS_NOW ) ; if ( ( lbsize = ud_get_lbsize ( dev , & avd_loc ) ) == 0 ) { error = EINVAL ; out } udf_vfsp = ud_validate_and_fill_superblock ( dev , lbsize , avd_loc ) ; if ( udf_vfsp == NULL ) { error = EINVAL ; out } vfsp -> vfs_fstype = udf_fstype ; vfs_make_fsid ( & vfsp -> vfs_fsid , dev , udf_fstype ) ; vfsp -> vfs_data = ( caddr_t ) udf_vfsp ; vfsp -> vfs_dev = dev ; vfsp -> vfs_flag |= VFS_NOTRUNC ; udf_vfsp -> udf_devvp = devvp ; udf_vfsp -> udf_fsmnt = kmem_zalloc ( strlen ( name ) + 1 , KM_SLEEP ) ; ( void ) strcpy ( udf_vfsp -> udf_fsmnt , name ) ; udf_vfsp -> udf_vfs = vfsp ; udf_vfsp -> udf_rdclustsz = udf_vfsp -> udf_wrclustsz = maxphys ; udf_vfsp -> udf_mod = 0 ; lvid = udf_vfsp -> udf_lvid ; if ( vfsp -> vfs_flag & VFS_RDONLY ) { if ( udf_vfsp -> udf_miread > UDF_150 ) { error = EINVAL ; out } udf_vfsp -> udf_flags = UDF_FL_RDONLY ; if ( SWAP_32 ( lvid -> lvid_int_type ) == LOG_VOL_CLOSE_INT ) { udf_vfsp -> udf_clean = UDF_CLEAN ; } else { map = udf_vfsp -> udf_maps ; for ( i = 0 ; i < udf_vfsp -> udf_nmaps ; i ++ ) { if ( map -> udm_flags & UDM_MAP_VPM ) { break ; } map ++ ; } if ( i == udf_vfsp -> udf_nmaps ) { error = ENOSPC ; out } udf_vfsp -> udf_clean = UDF_CLEAN ; } } else { if ( ( udf_vfsp -> udf_miread > UDF_150 ) || ( udf_vfsp -> udf_miwrite > UDF_150 ) ) { error = EINVAL ; out } if ( udf_vfsp -> udf_mtype != UDF_MT_OW ) { error = EACCES ; out } map = udf_vfsp -> udf_maps ; ASSERT ( map != NULL ) ; for ( i = 0 ; i < udf_vfsp -> udf_nmaps ; i ++ ) { if ( map -> udm_flags & UDM_MAP_VPM ) { error = EACCES ; out } map ++ ; } if ( udf_vfsp -> udf_lvd -> lvd_dom_id . reg_ids [ 2 ] & 0x3 ) { error = EACCES ; out } udf_vfsp -> udf_flags = UDF_FL_RW ; if ( SWAP_32 ( lvid -> lvid_int_type ) == LOG_VOL_CLOSE_INT ) { udf_vfsp -> udf_clean = UDF_CLEAN ; } else { if ( isroot ) { udf_vfsp -> udf_clean = UDF_DIRTY ; } else { error = ENOSPC ; out } } } mutex_init ( & udf_vfsp -> udf_lock , NULL , MUTEX_DEFAULT , NULL ) ; mutex_init ( & udf_vfsp -> udf_rename_lck , NULL , MUTEX_DEFAULT , NULL ) ; _NOTE ( COMPETING_THREADS_NOW ) ; if ( error = ud_iget ( vfsp , udf_vfsp -> udf_ricb_prn , udf_vfsp -> udf_ricb_loc , & rip , NULL , cr ) ) { mutex_destroy ( & udf_vfsp -> udf_lock ) ; out } rvp = ITOV ( rip ) ; mutex_enter ( & rvp -> v_lock ) ; rvp -> v_flag |= VROOT ; mutex_exit ( & rvp -> v_lock ) ; udf_vfsp -> udf_root = rvp ; if ( why == ROOT_INIT && isroot ) { rootvp = devvp ; } ud_vfs_add ( udf_vfsp ) ; if ( udf_vfsp -> udf_flags == UDF_FL_RW ) { udf_vfsp -> udf_clean = UDF_DIRTY ; ud_update_superblock ( vfsp ) ; } return ( 0 ) ; out ud_destroy_fsp ( udf_vfsp ) ; if ( needclose ) { ( void ) VOP_CLOSE ( devvp , ( vfsp -> vfs_flag & VFS_RDONLY ) ?FREAD : FREAD | FWRITE , 1 , ( offset_t ) 0 , cr , NULL ) ; bflush ( dev ) ; binval ( dev ) ; } VN_RELE ( devvp ) ; return ( error ) ; } 