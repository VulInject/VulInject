static virDomainPCIConnectFlags qemuDomainDeviceCalculatePCIConnectFlags ( virDomainDeviceDef * dev , virDomainPCIConnectFlags pcieFlags , virDomainPCIConnectFlags virtioFlags ) { virDomainPCIConnectFlags pciFlags = ( VIR_PCI_CONNECT_TYPE_PCI_DEVICE | VIR_PCI_CONNECT_AUTOASSIGN ) ; switch ( ( virDomainDeviceType ) dev -> type ) { case VIR_DOMAIN_DEVICE_CONTROLLER : { virDomainControllerDef * cont = dev -> data . controller ; switch ( ( virDomainControllerType ) cont -> type ) { case VIR_DOMAIN_CONTROLLER_TYPE_PCI : return virDomainPCIControllerModelToConnectType ( cont -> model ) ; case VIR_DOMAIN_CONTROLLER_TYPE_SATA : return pciFlags ; case VIR_DOMAIN_CONTROLLER_TYPE_USB : switch ( ( virDomainControllerModelUSB ) cont -> model ) { case VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT : return pciFlags ; case VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI : case VIR_DOMAIN_CONTROLLER_MODEL_USB_QEMU_XHCI : return pcieFlags ; case VIR_DOMAIN_CONTROLLER_MODEL_USB_EHCI : case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1 : case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1 : case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2 : case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3 : case VIR_DOMAIN_CONTROLLER_MODEL_USB_VT82C686B_UHCI : case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI : case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX4_UHCI : case VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI : return pciFlags ; case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1 : case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2 : case VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE : case VIR_DOMAIN_CONTROLLER_MODEL_USB_LAST : return 0 ; } break ; case VIR_DOMAIN_CONTROLLER_TYPE_IDE : return pciFlags ; case VIR_DOMAIN_CONTROLLER_TYPE_SCSI : switch ( ( virDomainControllerModelSCSI ) cont -> model ) { case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT : case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_NCR53C90 : return 0 ; case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI : case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_NON_TRANSITIONAL : return virtioFlags ; case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_TRANSITIONAL : case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO : case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC : case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC : case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068 : case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI : case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI : case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1078 : case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DC390 : case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AM53C974 : return pciFlags ; case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LAST : return 0 ; } break ; case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL : switch ( ( virDomainControllerModelVirtioSerial ) cont -> model ) { case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_TRANSITIONAL : return pciFlags ; case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO : case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_NON_TRANSITIONAL : case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_DEFAULT : return virtioFlags ; case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_LAST : return 0 ; } break ; case VIR_DOMAIN_CONTROLLER_TYPE_FDC : case VIR_DOMAIN_CONTROLLER_TYPE_CCID : case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS : case VIR_DOMAIN_CONTROLLER_TYPE_ISA : case VIR_DOMAIN_CONTROLLER_TYPE_LAST : return 0 ; } } break ; case VIR_DOMAIN_DEVICE_FS : switch ( ( virDomainFSDriverType ) dev -> data . fs -> fsdriver ) { case VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT : case VIR_DOMAIN_FS_DRIVER_TYPE_PATH : case VIR_DOMAIN_FS_DRIVER_TYPE_HANDLE : switch ( dev -> data . fs -> model ) { case VIR_DOMAIN_FS_MODEL_VIRTIO_TRANSITIONAL : return pciFlags ; case VIR_DOMAIN_FS_MODEL_VIRTIO : case VIR_DOMAIN_FS_MODEL_VIRTIO_NON_TRANSITIONAL : case VIR_DOMAIN_FS_MODEL_DEFAULT : return virtioFlags ; case VIR_DOMAIN_FS_MODEL_LAST : break ; } break ; case VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS : return virtioFlags ; case VIR_DOMAIN_FS_DRIVER_TYPE_LOOP : case VIR_DOMAIN_FS_DRIVER_TYPE_NBD : case VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP : case VIR_DOMAIN_FS_DRIVER_TYPE_LAST : return 0 ; } return 0 ; case VIR_DOMAIN_DEVICE_NET : { virDomainNetDef * net = dev -> data . net ; if ( net -> type == VIR_DOMAIN_NET_TYPE_HOSTDEV || net -> model == VIR_DOMAIN_NET_MODEL_USB_NET ) { return 0 ; } if ( net -> model == VIR_DOMAIN_NET_MODEL_VIRTIO || net -> model == VIR_DOMAIN_NET_MODEL_VIRTIO_NON_TRANSITIONAL ) { return virtioFlags ; } if ( net -> model == VIR_DOMAIN_NET_MODEL_E1000E ) { return pcieFlags ; } if ( net -> model == VIR_DOMAIN_NET_MODEL_UNKNOWN ) { return pcieFlags ; } return pciFlags ; } case VIR_DOMAIN_DEVICE_SOUND : switch ( dev -> data . sound -> model ) { case VIR_DOMAIN_SOUND_MODEL_ES1370 : case VIR_DOMAIN_SOUND_MODEL_AC97 : case VIR_DOMAIN_SOUND_MODEL_ICH6 : case VIR_DOMAIN_SOUND_MODEL_ICH9 : return pciFlags ; case VIR_DOMAIN_SOUND_MODEL_SB16 : case VIR_DOMAIN_SOUND_MODEL_PCSPK : case VIR_DOMAIN_SOUND_MODEL_USB : case VIR_DOMAIN_SOUND_MODEL_ICH7 : case VIR_DOMAIN_SOUND_MODEL_LAST : return 0 ; } break ; case VIR_DOMAIN_DEVICE_DISK : switch ( ( virDomainDiskBus ) dev -> data . disk -> bus ) { case VIR_DOMAIN_DISK_BUS_VIRTIO : switch ( ( virDomainDiskModel ) dev -> data . disk -> model ) { case VIR_DOMAIN_DISK_MODEL_VIRTIO_TRANSITIONAL : return pciFlags ; case VIR_DOMAIN_DISK_MODEL_VIRTIO : case VIR_DOMAIN_DISK_MODEL_VIRTIO_NON_TRANSITIONAL : case VIR_DOMAIN_DISK_MODEL_DEFAULT : return virtioFlags ; case VIR_DOMAIN_DISK_MODEL_LAST : break ; } return 0 ; case VIR_DOMAIN_DISK_BUS_IDE : case VIR_DOMAIN_DISK_BUS_FDC : case VIR_DOMAIN_DISK_BUS_SCSI : case VIR_DOMAIN_DISK_BUS_XEN : case VIR_DOMAIN_DISK_BUS_USB : case VIR_DOMAIN_DISK_BUS_UML : case VIR_DOMAIN_DISK_BUS_SATA : case VIR_DOMAIN_DISK_BUS_SD : case VIR_DOMAIN_DISK_BUS_NONE : case VIR_DOMAIN_DISK_BUS_LAST : return 0 ; } break ; case VIR_DOMAIN_DEVICE_HOSTDEV : { virDomainHostdevDef * hostdev = dev -> data . hostdev ; g_autoptr ( ) pciDev = NULL ; virPCIDeviceAddress * hostAddr = & hostdev -> source . subsys . u . pci . addr ; if ( ! virHostdevIsMdevDevice ( hostdev ) && ( hostdev -> mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS || ( hostdev -> source . subsys . type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI && hostdev -> source . subsys . type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST ) ) ) { return 0 ; } if ( pciFlags == pcieFlags ) { return pciFlags ; } if ( virDeviceInfoPCIAddressIsPresent ( hostdev -> info ) ) { return pcieFlags ; } if ( hostdev -> source . subsys . type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV ) { return pcieFlags ; } if ( hostdev -> source . subsys . type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST ) { switch ( ( virDomainHostdevSubsysSCSIVHostModelType ) hostdev -> source . subsys . u . scsi_host . model ) { case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_TRANSITIONAL : return pciFlags ; case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO : case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_NON_TRANSITIONAL : case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_DEFAULT : return virtioFlags ; case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_LAST : break ; } return 0 ; } if ( ! ( pciDev = virPCIDeviceNew ( hostAddr ) ) ) { return pcieFlags ; } if ( virPCIDeviceIsPCIExpress ( pciDev ) ) { return pcieFlags ; } return pciFlags ; } case VIR_DOMAIN_DEVICE_MEMBALLOON : switch ( dev -> data . memballoon -> model ) { case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_TRANSITIONAL : return pciFlags ; case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO : case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_NON_TRANSITIONAL : return virtioFlags ; case VIR_DOMAIN_MEMBALLOON_MODEL_XEN : case VIR_DOMAIN_MEMBALLOON_MODEL_NONE : case VIR_DOMAIN_MEMBALLOON_MODEL_LAST : return 0 ; } break ; case VIR_DOMAIN_DEVICE_RNG : switch ( ( virDomainRNGModel ) dev -> data . rng -> model ) { case VIR_DOMAIN_RNG_MODEL_VIRTIO_TRANSITIONAL : return pciFlags ; case VIR_DOMAIN_RNG_MODEL_VIRTIO : case VIR_DOMAIN_RNG_MODEL_VIRTIO_NON_TRANSITIONAL : return virtioFlags ; case VIR_DOMAIN_RNG_MODEL_LAST : return 0 ; } break ; case VIR_DOMAIN_DEVICE_WATCHDOG : switch ( ( virDomainWatchdogModel ) dev -> data . watchdog -> model ) { case VIR_DOMAIN_WATCHDOG_MODEL_I6300ESB : return pciFlags ; case VIR_DOMAIN_WATCHDOG_MODEL_IB700 : case VIR_DOMAIN_WATCHDOG_MODEL_DIAG288 : case VIR_DOMAIN_WATCHDOG_MODEL_ITCO : case VIR_DOMAIN_WATCHDOG_MODEL_LAST : return 0 ; } break ; case VIR_DOMAIN_DEVICE_VIDEO : switch ( ( virDomainVideoType ) dev -> data . video -> type ) { case VIR_DOMAIN_VIDEO_TYPE_VIRTIO : return virtioFlags ; case VIR_DOMAIN_VIDEO_TYPE_VGA : case VIR_DOMAIN_VIDEO_TYPE_CIRRUS : case VIR_DOMAIN_VIDEO_TYPE_VMVGA : case VIR_DOMAIN_VIDEO_TYPE_XEN : case VIR_DOMAIN_VIDEO_TYPE_VBOX : case VIR_DOMAIN_VIDEO_TYPE_QXL : case VIR_DOMAIN_VIDEO_TYPE_PARALLELS : return pciFlags ; case VIR_DOMAIN_VIDEO_TYPE_BOCHS : return pcieFlags ; case VIR_DOMAIN_VIDEO_TYPE_DEFAULT : case VIR_DOMAIN_VIDEO_TYPE_GOP : case VIR_DOMAIN_VIDEO_TYPE_NONE : case VIR_DOMAIN_VIDEO_TYPE_RAMFB : case VIR_DOMAIN_VIDEO_TYPE_LAST : return 0 ; } break ; case VIR_DOMAIN_DEVICE_SHMEM : return pciFlags ; case VIR_DOMAIN_DEVICE_INPUT : switch ( ( virDomainInputBus ) dev -> data . input -> bus ) { case VIR_DOMAIN_INPUT_BUS_VIRTIO : switch ( ( virDomainInputModel ) dev -> data . input -> model ) { case VIR_DOMAIN_INPUT_MODEL_VIRTIO_TRANSITIONAL : return pciFlags ; case VIR_DOMAIN_INPUT_MODEL_VIRTIO : case VIR_DOMAIN_INPUT_MODEL_VIRTIO_NON_TRANSITIONAL : case VIR_DOMAIN_INPUT_MODEL_DEFAULT : return virtioFlags ; case VIR_DOMAIN_INPUT_MODEL_LAST : break ; } return 0 ; case VIR_DOMAIN_INPUT_BUS_PS2 : case VIR_DOMAIN_INPUT_BUS_USB : case VIR_DOMAIN_INPUT_BUS_XEN : case VIR_DOMAIN_INPUT_BUS_PARALLELS : case VIR_DOMAIN_INPUT_BUS_NONE : case VIR_DOMAIN_INPUT_BUS_LAST : return 0 ; } break ; case VIR_DOMAIN_DEVICE_CHR : switch ( ( virDomainChrSerialTargetType ) dev -> data . chr -> targetType ) { case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_PCI : return pciFlags ; case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_ISA : case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_USB : case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SPAPR_VIO : case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SYSTEM : case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SCLP : case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_ISA_DEBUG : case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_NONE : case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_LAST : return 0 ; } break ; case VIR_DOMAIN_DEVICE_IOMMU : switch ( dev -> data . iommu -> model ) { case VIR_DOMAIN_IOMMU_MODEL_VIRTIO : return virtioFlags | VIR_PCI_CONNECT_INTEGRATED ; case VIR_DOMAIN_IOMMU_MODEL_INTEL : case VIR_DOMAIN_IOMMU_MODEL_SMMUV3 : case VIR_DOMAIN_IOMMU_MODEL_LAST : return 0 ; } break ; case VIR_DOMAIN_DEVICE_VSOCK : switch ( ( virDomainVsockModel ) dev -> data . vsock -> model ) { case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_TRANSITIONAL : return pciFlags ; case VIR_DOMAIN_VSOCK_MODEL_VIRTIO : case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_NON_TRANSITIONAL : return virtioFlags ; case VIR_DOMAIN_VSOCK_MODEL_DEFAULT : case VIR_DOMAIN_VSOCK_MODEL_LAST : return 0 ; } break ; case VIR_DOMAIN_DEVICE_MEMORY : switch ( dev -> data . memory -> model ) { case VIR_DOMAIN_MEMORY_MODEL_VIRTIO_PMEM : case VIR_DOMAIN_MEMORY_MODEL_VIRTIO_MEM : return virtioFlags ; case VIR_DOMAIN_MEMORY_MODEL_NONE : case VIR_DOMAIN_MEMORY_MODEL_DIMM : case VIR_DOMAIN_MEMORY_MODEL_NVDIMM : case VIR_DOMAIN_MEMORY_MODEL_SGX_EPC : case VIR_DOMAIN_MEMORY_MODEL_LAST : return 0 ; } break ; case VIR_DOMAIN_DEVICE_CRYPTO : switch ( dev -> data . crypto -> model ) { case VIR_DOMAIN_CRYPTO_MODEL_VIRTIO : return pciFlags ; case VIR_DOMAIN_CRYPTO_MODEL_LAST : return 0 ; } break ; case VIR_DOMAIN_DEVICE_PANIC : switch ( ( virDomainPanicModel ) dev -> data . panic -> model ) { case VIR_DOMAIN_PANIC_MODEL_PVPANIC : return pciFlags | VIR_PCI_CONNECT_INTEGRATED ; case VIR_DOMAIN_PANIC_MODEL_DEFAULT : case VIR_DOMAIN_PANIC_MODEL_ISA : case VIR_DOMAIN_PANIC_MODEL_PSERIES : case VIR_DOMAIN_PANIC_MODEL_HYPERV : case VIR_DOMAIN_PANIC_MODEL_S390 : case VIR_DOMAIN_PANIC_MODEL_LAST : return 0 ; } break ; case VIR_DOMAIN_DEVICE_NVRAM : case VIR_DOMAIN_DEVICE_TPM : case VIR_DOMAIN_DEVICE_HUB : case VIR_DOMAIN_DEVICE_REDIRDEV : case VIR_DOMAIN_DEVICE_SMARTCARD : case VIR_DOMAIN_DEVICE_LEASE : case VIR_DOMAIN_DEVICE_GRAPHICS : case VIR_DOMAIN_DEVICE_AUDIO : case VIR_DOMAIN_DEVICE_LAST : case VIR_DOMAIN_DEVICE_NONE : return 0 ; } return 0 ; } 