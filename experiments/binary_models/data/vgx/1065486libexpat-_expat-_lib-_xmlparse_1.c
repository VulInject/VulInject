static enum XML_Error appendAttributeValue ( XML_Parser parser , const ENCODING * enc , XML_Bool isCdata , const char * ptr , const char * end , STRING_POOL * pool , enum XML_Account account ) { DTD * const dtd = parser -> m_dtd ; UNUSED_P ( account ) ; for ( ; ; ) { const char * next = ptr ; int tok = XmlAttributeValueTok ( enc , ptr , end , & next ) ; if ( ! accountingDiffTolerated ( parser , tok , ptr , next , __LINE__ , account ) ) { accountingOnAbort ( parser , NULL ) ; return XML_ERROR_AMPLIFICATION_LIMIT_BREACH ; } switch ( tok ) { case XML_TOK_NONE : return XML_ERROR_NONE ; case XML_TOK_INVALID : if ( enc == parser -> m_encoding ) { parser -> m_eventPtr = next ; } return XML_ERROR_INVALID_TOKEN ; case XML_TOK_PARTIAL : if ( enc == parser -> m_encoding ) { parser -> m_eventPtr = ptr ; } return XML_ERROR_INVALID_TOKEN ; case XML_TOK_CHAR_REF : { XML_Char buf [ XML_ENCODE_MAX ] ; int i ; int n = XmlCharRefNumber ( enc , ptr ) ; if ( n < 0 ) { if ( enc == parser -> m_encoding ) { parser -> m_eventPtr = ptr ; } return XML_ERROR_BAD_CHAR_REF ; } if ( ! isCdata && n == 0x20 && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) ) { break ; } n = XmlEncode ( n , ( ICHAR * ) buf ) ; for ( i = 0 ; i < n ; i ++ ) { if ( ! poolAppendChar ( pool , buf [ i ] ) ) { return XML_ERROR_NO_MEMORY ; } } } break ; case XML_TOK_DATA_CHARS : if ( ! poolAppend ( pool , enc , ptr , next ) ) { return XML_ERROR_NO_MEMORY ; } break ; case XML_TOK_TRAILING_CR : next = ptr + enc -> minBytesPerChar ; case XML_TOK_ATTRIBUTE_VALUE_S : case XML_TOK_DATA_NEWLINE : if ( ! isCdata && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) ) { break ; } if ( ! poolAppendChar ( pool , 0x20 ) ) { return XML_ERROR_NO_MEMORY ; } break ; case XML_TOK_ENTITY_REF : { const XML_Char * name ; ENTITY * entity ; char checkEntityDecl ; XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ; if ( ch ) { accountingDiffTolerated ( parser , tok , ( char * ) & ch , ( ( char * ) & ch ) + sizeof ( XML_Char ) , __LINE__ , XML_ACCOUNT_ENTITY_EXPANSION ) ; if ( ! poolAppendChar ( pool , ch ) ) { return XML_ERROR_NO_MEMORY ; } break ; } name = poolStoreString ( & parser -> m_temp2Pool , enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ; if ( ! name ) { return XML_ERROR_NO_MEMORY ; } entity = ( ENTITY * ) lookup ( parser , & dtd -> generalEntities , name , 0 ) ; poolDiscard ( & parser -> m_temp2Pool ) ; if ( pool == & dtd -> pool ) { checkEntityDecl = parser -> m_prologState . documentEntity && ( dtd -> standalone ?! parser -> m_openInternalEntities : ! dtd -> hasParamEntityRefs ) ; } else { checkEntityDecl = ! dtd -> hasParamEntityRefs || dtd -> standalone ; } if ( checkEntityDecl ) { if ( ! entity ) { return XML_ERROR_UNDEFINED_ENTITY ; } if ( ! entity -> is_internal ) { return XML_ERROR_ENTITY_DECLARED_IN_PE ; } } if ( ! entity ) { break ; } if ( entity -> open ) { if ( enc == parser -> m_encoding ) { parser -> m_eventPtr = ptr ; } return XML_ERROR_RECURSIVE_ENTITY_REF ; } if ( entity -> notation ) { if ( enc == parser -> m_encoding ) { parser -> m_eventPtr = ptr ; } return XML_ERROR_BINARY_ENTITY_REF ; } if ( ! entity -> textPtr ) { if ( enc == parser -> m_encoding ) { parser -> m_eventPtr = ptr ; } return XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF ; } else { enum XML_Error result ; const XML_Char * textEnd = entity -> textPtr + entity -> textLen ; entity -> open = XML_TRUE ; entityTrackingOnOpen ( parser , entity , __LINE__ ) ; result = appendAttributeValue ( parser , parser -> m_internalEncoding , isCdata , ( const char * ) entity -> textPtr , ( const char * ) textEnd , pool , XML_ACCOUNT_ENTITY_EXPANSION ) ; entityTrackingOnClose ( parser , entity , __LINE__ ) ; entity -> open = XML_FALSE ; if ( result ) { return result ; } } } break ; default : if ( enc == parser -> m_encoding ) { parser -> m_eventPtr = ptr ; } return XML_ERROR_UNEXPECTED_STATE ; } ptr = next ; } } 