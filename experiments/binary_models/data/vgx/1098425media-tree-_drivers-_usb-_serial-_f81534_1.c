static void f81534_process_per_serial_block ( struct usb_serial_port * port , u8 * data ) { struct f81534_port_private * port_priv = usb_get_serial_port_data ( port ) ; int phy_num = data [ 0 ] ; int read_size = 0 ; size_t i ; char tty_flag ; int status ; u8 lsr ; switch ( data [ 1 ] ) { case F81534_TOKEN_TX_EMPTY : set_bit ( F81534_TX_EMPTY_BIT , & port_priv -> tx_empty ) ; status = f81534_submit_writer ( port , GFP_ATOMIC ) ; if ( status ) { dev_err ( & port -> dev , "%s: submit failed\n" , __func__ ) ; } return ; case F81534_TOKEN_MSR_CHANGE : f81534_msr_changed ( port , data [ 3 ] ) ; return ; case F81534_TOKEN_RECEIVE : read_size = data [ 2 ] ; if ( read_size > F81534_MAX_RX_SIZE ) { dev_err ( & port -> dev , "%s: phy: %d read_size: %zu larger than: %d\n" , __func__ , phy_num , read_size , F81534_MAX_RX_SIZE ) ; return ; } break ; default : dev_warn ( & port -> dev , "%s: unknown token: %02x\n" , __func__ , data [ 1 ] ) ; return ; } for ( i = 4 ; i < 4 + read_size ; i += 2 ) { tty_flag = TTY_NORMAL ; lsr = data [ i + 1 ] ; if ( lsr & UART_LSR_BRK_ERROR_BITS ) { if ( lsr & UART_LSR_BI ) { tty_flag = TTY_BREAK ; port -> icount . brk ++ ; usb_serial_handle_break ( port ) ; } if ( lsr & UART_LSR_PE ) { tty_flag = TTY_PARITY ; port -> icount . parity ++ ; } if ( lsr & UART_LSR_FE ) { tty_flag = TTY_FRAME ; port -> icount . frame ++ ; } if ( lsr & UART_LSR_OE ) { port -> icount . overrun ++ ; tty_insert_flip_char ( & port -> port , 0 , TTY_OVERRUN ) ; } } if ( port -> port . console && port -> sysrq ) { if ( usb_serial_handle_sysrq_char ( port , data [ i ] ) ) { continue ; } } tty_insert_flip_char ( & port -> port , data [ i ] , tty_flag ) ; } tty_flip_buffer_push ( & port -> port ) ; } 