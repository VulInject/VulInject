static int acct_load ( char * pn , int wr ) { struct acct ac ; struct cmdinfo ci ; ssize_t rv ; int fd , i ; fd = open ( pn , wr ?O_RDWR : O_RDONLY ) ; if ( fd == - 1 ) { warn ( "open %s %s" , pn , wr ?"for read/write" : "read-only" ) ; return ( - 1 ) ; } while ( 1 ) { rv = read ( fd , & ac , sizeof ( acct ) ) ; if ( rv == - 1 ) { warn ( "error reading %s" , pn ) ; } if ( rv > 0 && rv < sizeof ( acct ) ) { warnx ( "short read of accounting data in %s" , pn ) ; } if ( rv != sizeof ( acct ) ) { break ; } ci . ci_calls = 1 ; for ( i = 0 ; i < sizeof ( ac . ac_comm ) && ac . ac_comm [ i ] != '\0' ; i ++ ) { int c = ac . ac_comm [ i ] ; if ( ! isascii ( c ) || iscntrl ( c ) ) { ci . ci_comm [ i ] = '?' ; ci . ci_flags |= CI_UNPRINTABLE ; } else { ci . ci_comm [ i ] = c ; } } if ( ac . ac_flag & AFORK ) { ci . ci_comm [ i ++ ] = '*' ; } ci . ci_comm [ i ++ ] = '\0' ; ci . ci_etime = decode_comp_t ( ac . ac_etime ) ; ci . ci_utime = decode_comp_t ( ac . ac_utime ) ; ci . ci_stime = decode_comp_t ( ac . ac_stime ) ; ci . ci_uid = ac . ac_uid ; ci . ci_mem = ac . ac_mem ; ci . ci_io = decode_comp_t ( ac . ac_io ) / AHZ ; ci . ci_pid = ac . ac_pid ; if ( ! uflag ) { if ( sflag || ( ! mflag && ! qflag ) ) { pacct_add ( & ci ) ; } if ( sflag || ( mflag && ! qflag ) ) { usracct_add ( & ci ) ; } } if ( ! qflag ) { printf ( "%6u %12.2f cpu %12lluk mem %12llu io pid %u %s\n" , ci . ci_uid , ( ci . ci_utime + ci . ci_stime ) / ( double ) AHZ , ci . ci_mem , ci . ci_io , ci . ci_pid , ci . ci_comm ) ; } } return ( fd ) ; } 