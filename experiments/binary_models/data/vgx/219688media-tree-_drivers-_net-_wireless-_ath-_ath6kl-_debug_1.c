void ath6kl_debug_fwlog_event ( struct ath6kl * ar , const void * buf , size_t len ) { struct ath6kl_fwlog_slot * slot ; struct sk_buff * skb ; size_t slot_len ; if ( WARN_ON ( len > ATH6KL_FWLOG_PAYLOAD_SIZE ) ) { return ; } slot_len = sizeof ( * slot ) + ATH6KL_FWLOG_PAYLOAD_SIZE ; skb = alloc_skb ( slot_len , GFP_KERNEL ) ; slot = ( ath6kl_fwlog_slot * ) skb_put ( skb , slot_len ) ; slot -> timestamp = cpu_to_le32 ( jiffies ) ; slot -> length = cpu_to_le32 ( len ) ; memcpy ( slot -> payload , buf , len ) ; memset ( slot -> payload + len , 0 , ATH6KL_FWLOG_PAYLOAD_SIZE - len ) ; spin_lock ( & ar -> debug . fwlog_queue . lock ) ; __skb_queue_tail ( & ar -> debug . fwlog_queue , skb ) ; complete ( & ar -> debug . fwlog_completion ) ; while ( skb_queue_len ( & ar -> debug . fwlog_queue ) > ATH6KL_FWLOG_MAX_ENTRIES ) { skb = __skb_dequeue ( & ar -> debug . fwlog_queue ) ; kfree_skb ( skb ) ; } spin_unlock ( & ar -> debug . fwlog_queue . lock ) ; return ; } 