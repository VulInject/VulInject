static int onenand_block_test ( u32 start , u32 size ) { struct onenand_chip * this = mtd -> priv ; struct erase_info instr = { } ; int blocks ; loff_t ofs ; int blocksize = 1 << this -> erase_shift ; int start_block , end_block ; size_t retlen ; u_char * buf ; u_char * verify_buf ; int ret ; buf = malloc ( blocksize ) ; if ( ! buf ) { printf ( "Not enough malloc space available!\n" ) ; return - 1 ; } verify_buf = malloc ( blocksize ) ; if ( ! verify_buf ) { printf ( "Not enough malloc space available!\n" ) ; return - 1 ; } start_block = start >> this -> erase_shift ; end_block = ( start + size ) >> this -> erase_shift ; if ( start_block < 2 ) { start_block = 2 ; } if ( end_block > ( mtd -> size >> this -> erase_shift ) ) { end_block = mtd -> size >> this -> erase_shift ; } blocks = start_block ; ofs = start ; while ( blocks < end_block ) { printf ( "\rTesting block %d at 0x%x" , ( u32 ) ( ofs >> this -> erase_shift ) , ( u32 ) ofs ) ; ret = mtd_block_isbad ( mtd , ofs ) ; if ( ret ) { printf ( "Skip erase bad block %d at 0x%x\n" , ( u32 ) ( ofs >> this -> erase_shift ) , ( u32 ) ofs ) ; next } instr . addr = ofs ; instr . len = blocksize ; ret = mtd_erase ( mtd , & instr ) ; if ( ret ) { printk ( "Erase failed 0x%x, %d\n" , ( u32 ) ofs , ret ) ; next } ret = mtd_write ( mtd , ofs , blocksize , & retlen , buf ) ; if ( ret ) { printk ( "Write failed 0x%x, %d\n" , ( u32 ) ofs , ret ) ; next } ret = mtd_read ( mtd , ofs , blocksize , & retlen , verify_buf ) ; if ( ret ) { printk ( "Read failed 0x%x, %d\n" , ( u32 ) ofs , ret ) ; next } if ( memcmp ( buf , verify_buf , blocksize ) ) { printk ( "\nRead/Write test failed at 0x%x\n" , ( u32 ) ofs ) ; } next ofs += blocksize ; blocks ++ ; } printf ( "...Done\n" ) ; free ( verify_buf ) ; return 0 ; } 