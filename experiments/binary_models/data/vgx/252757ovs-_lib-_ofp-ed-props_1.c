enum ofperr encode_ed_prop ( const struct ofpact_ed_prop * * prop , struct ofpbuf * out OVS_UNUSED ) { size_t prop_len ; switch ( ( * prop ) -> prop_class ) { case OFPPPC_NSH : { switch ( ( * prop ) -> type ) { case OFPPPT_PROP_NSH_MDTYPE : { struct ofpact_ed_prop_nsh_md_type * pnmt = ALIGNED_CAST ( ofpact_ed_prop_nsh_md_type * , * prop ) ; struct ofp_ed_prop_nsh_md_type * opnmt = ofpbuf_put_uninit ( out , sizeof ( * opnmt ) ) ; opnmt -> header . prop_class = htons ( ( * prop ) -> prop_class ) ; opnmt -> header . type = ( * prop ) -> type ; opnmt -> header . len = offsetof ( ofp_ed_prop_nsh_md_type , pad ) ; opnmt -> md_type = pnmt -> md_type ; prop_len = sizeof ( * pnmt ) ; break ; } case OFPPPT_PROP_NSH_TLV : { struct ofpact_ed_prop_nsh_tlv * pnt = ALIGNED_CAST ( ofpact_ed_prop_nsh_tlv * , * prop ) ; struct ofp_ed_prop_nsh_tlv * opnt ; size_t tlv_pad_len = ROUND_UP ( pnt -> tlv_len , 8 ) ; size_t len = sizeof ( * opnt ) + tlv_pad_len ; opnt = ofpbuf_put_uninit ( out , len ) ; opnt -> header . prop_class = htons ( ( * prop ) -> prop_class ) ; opnt -> header . type = ( * prop ) -> type ; opnt -> header . len = len ; opnt -> tlv_class = pnt -> tlv_class ; opnt -> tlv_type = pnt -> tlv_type ; opnt -> tlv_len = pnt -> tlv_len ; memcpy ( opnt -> data , pnt -> data , tlv_pad_len ) ; prop_len = sizeof ( * pnt ) + tlv_pad_len ; break ; } default : return OFPERR_OFPBAC_BAD_ARGUMENT ; } break ; } default : return OFPERR_OFPBAC_BAD_ARGUMENT ; } * prop = ALIGNED_CAST ( const ofpact_ed_prop * , ( ( char * ) ( * prop ) + prop_len ) ) ; return 0 ; } 