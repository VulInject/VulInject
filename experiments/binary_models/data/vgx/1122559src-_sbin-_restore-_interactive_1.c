static void getcmd ( char * curdir , char * cmd , size_t cmdlen , char * name , size_t namelen , struct arglist * ap ) { char * cp ; static char input [ BUFSIZ ] ; char output [ BUFSIZ ] ; int globretval ; if ( ap -> argcnt > 0 ) { retnext } if ( nextarg != NULL ) { getnext } { ( void ) fprintf ( stderr , "%s>" , __progname ) ; ( void ) fflush ( stderr ) ; if ( fgets ( input , sizeof input , terminal ) == NULL ) { ( void ) strlcpy ( cmd , "quit" , cmdlen ) ; return ; } } input [ 0 ] == '\n' || input [ 0 ] == '\0' ; for ( cp = & input [ strlen ( input ) - 1 ] ; cp >= input && ( * cp == ' ' || * cp == '\t' || * cp == '\n' ) ; cp -- ) { } * ++ cp = '\0' ; cp = copynext ( input , cmd ) ; ap -> cmd = cmd ; if ( * cp == '\0' ) { ( void ) strlcpy ( name , curdir , PATH_MAX ) ; return ; } nextarg = cp ; getnext cp = copynext ( nextarg , rawname ) ; if ( * cp == '\0' ) { nextarg = NULL ; } else { nextarg = cp ; } if ( rawname [ 0 ] == '/' ) { canon ( rawname , name , namelen ) ; } else { sprintf ( output , "%s/%s" , curdir , rawname ) ; canon ( output , name , namelen ) ; } if ( ( globretval = glob ( name , GLOB_ALTDIRFUNC | GLOB_NOESCAPE , NULL , & ap -> glob ) ) < 0 ) { fprintf ( stderr , "%s: %s: " , ap -> cmd , name ) ; switch ( globretval ) { case GLOB_NOSPACE : fprintf ( stderr , "out of memory\n" ) ; break ; case GLOB_NOMATCH : fprintf ( stderr , "no filename match.\n" ) ; break ; case GLOB_ABORTED : fprintf ( stderr , "glob() aborted.\n" ) ; break ; default : fprintf ( stderr , "unknown error!\n" ) ; break ; } } if ( ap -> glob . gl_pathc == 0 ) { return ; } ap -> freeglob = 1 ; ap -> argcnt = ap -> glob . gl_pathc ; retnext strlcpy ( name , ap -> glob . gl_pathv [ ap -> glob . gl_pathc - ap -> argcnt ] , PATH_MAX ) ; if ( -- ap -> argcnt == 0 ) { ap -> freeglob = 0 ; globfree ( & ap -> glob ) ; } } 