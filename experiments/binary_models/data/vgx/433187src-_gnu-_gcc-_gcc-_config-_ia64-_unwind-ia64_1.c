uw_frame_state_for ( , ) { struct unw_table_entry * ent ; unsigned long * unw , header , length ; unsigned char * insn , * insn_end ; unsigned long segment_base ; struct unw_reg_info * r ; for ( r = fs -> curr . reg ; r < fs -> curr . reg + UNW_NUM_REGS ; ++ r ) { r -> when = UNW_WHEN_NEVER ; } context -> lsda = 0 ; ent = _Unwind_FindTableEntry ( ( void * ) context -> rp , & segment_base , & context -> gp ) ; if ( ent == NULL ) { if ( MD_FALLBACK_FRAME_STATE_FOR ( context , fs ) == _URC_NO_REASON ) { return _URC_NO_REASON ; } if ( context -> br_loc [ 0 ] && * context -> br_loc [ 0 ] != context -> rp && context -> rp != 0 ) { fs -> curr . reg [ UNW_REG_RP ] . where = UNW_WHERE_BR ; fs -> curr . reg [ UNW_REG_RP ] . when = - 1 ; fs -> curr . reg [ UNW_REG_RP ] . val = 0 ; return _URC_NO_REASON ; } return _URC_END_OF_STACK ; } context -> region_start = ent -> start_offset + segment_base ; fs -> when_target = ( ( context -> rp & - 16 ) - context -> region_start ) / 16 * 3 + ( context -> rp & 15 ) ; unw = ( unsigned long * ) ( ent -> info_offset + segment_base ) ; header = * unw ; length = UNW_LENGTH ( header ) ; if ( UNW_FLAG_EHANDLER ( header ) | UNW_FLAG_UHANDLER ( header ) ) { fs -> personality = * ( _Unwind_Personality_Fn * ) ( unw [ length + 1 ] + context -> gp ) ; context -> lsda = unw + length + 2 ; } insn = ( unsigned char * ) ( unw + 1 ) ; insn_end = ( unsigned char * ) ( unw + 1 + length ) ; while ( ! fs -> done && insn < insn_end ) { insn = unw_decode ( insn , fs -> in_body , fs ) ; } free_label_states ( fs -> labeled_states ) ; free_state_stack ( & fs -> curr ) ; if ( reg_state_alloced || labeled_state_alloced ) { abort ( ) ; } if ( fs -> when_target > fs -> epilogue_start ) { struct unw_reg_info * r ; fs -> curr . reg [ UNW_REG_PSP ] . where = UNW_WHERE_NONE ; fs -> curr . reg [ UNW_REG_PSP ] . val = 0 ; for ( r = fs -> curr . reg ; r < fs -> curr . reg + UNW_NUM_REGS ; ++ r ) { if ( ( r -> where == UNW_WHERE_PSPREL && r -> val <= 0x10 ) || r -> where == UNW_WHERE_SPREL ) { r -> where = UNW_WHERE_NONE ; } } } if ( fs -> curr . reg [ UNW_REG_RP ] . when >= fs -> when_target ) { fs -> curr . reg [ UNW_REG_RP ] . where = UNW_WHERE_BR ; fs -> curr . reg [ UNW_REG_RP ] . when = - 1 ; fs -> curr . reg [ UNW_REG_RP ] . val = fs -> return_link_reg ; } return _URC_NO_REASON ; } 