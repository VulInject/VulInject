int rfs4_dispatch ( struct rpcdisp * disp , struct svc_req * req , SVCXPRT * xprt , char * ap ) { COMPOUND4res res_buf ; COMPOUND4res * rbp ; COMPOUND4args * cap ; cred_t * cr = NULL ; int error = 0 ; int dis_flags = 0 ; int dr_stat = NFS4_NOT_DUP ; rfs4_dupreq_t * drp = NULL ; int rv ; nfs4_srv_t * nsrv4 = nfs4_get_srv ( ) ; rfs4_drc_t * nfs4_drc = nsrv4 -> nfs4_drc ; ASSERT ( disp ) ; if ( disp -> dis_proc == rpc_null ) { DTRACE_NFSV4_1 ( null__start , svc_req * , req ) ; if ( ! svc_sendreply ( xprt , xdr_void , NULL ) ) { DTRACE_NFSV4_1 ( null__done , svc_req * , req ) ; svcerr_systemerr ( xprt ) ; return ( 1 ) ; } DTRACE_NFSV4_1 ( null__done , svc_req * , req ) ; return ( 0 ) ; } rbp = & res_buf ; cap = ( COMPOUND4args * ) ap ; rfs4_compound_flagproc ( cap , & dis_flags ) ; if ( ! ( dis_flags & RPC_IDEMPOTENT ) ) { dr_stat = rfs4_find_dr ( req , nfs4_drc , & drp ) ; switch ( dr_stat ) { case NFS4_DUP_ERROR : rfs4_resource_err ( req , cap ) ; return ( 1 ) ; case NFS4_DUP_PENDING : return ( 1 ) ; case NFS4_DUP_NEW : curthread -> t_flag |= T_DONTPEND ; rfs4_compound ( cap , rbp , NULL , req , cr , & rv ) ; curthread -> t_flag &= ~ T_DONTPEND ; drp -> dr_res = res_buf ; if ( curthread -> t_flag & T_WOULDBLOCK ) { curthread -> t_flag &= ~ T_WOULDBLOCK ; mutex_enter ( & drp -> drc -> lock ) ; rfs4_dr_chstate ( drp , NFS4_DUP_FREE ) ; list_insert_tail ( & ( drp -> drc -> dr_cache ) , drp ) ; mutex_exit ( & drp -> drc -> lock ) ; return ( 1 ) ; } break ; case NFS4_DUP_REPLAY : rbp = & ( drp -> dr_res ) ; break ; } } else { curthread -> t_flag |= T_DONTPEND ; rfs4_compound ( cap , rbp , NULL , req , cr , & rv ) ; curthread -> t_flag &= ~ T_DONTPEND ; if ( rv ) { return ( rv ) ; } if ( curthread -> t_flag & T_WOULDBLOCK ) { curthread -> t_flag &= ~ T_WOULDBLOCK ; return ( 1 ) ; } } if ( ! svc_sendreply ( xprt , xdr_COMPOUND4res_srv , ( char * ) rbp ) ) { DTRACE_PROBE2 ( nfss__e__dispatch_sendfail , svc_req * , xprt , char * , rbp ) ; svcerr_systemerr ( xprt ) ; error ++ ; } if ( dr_stat == NFS4_DUP_NEW || dr_stat == NFS4_DUP_REPLAY ) { mutex_enter ( & drp -> drc -> lock ) ; rfs4_dr_chstate ( drp , NFS4_DUP_REPLAY ) ; mutex_exit ( & drp -> drc -> lock ) ; } if ( dr_stat == NFS4_NOT_DUP ) { rfs4_compound_free ( rbp ) ; } return ( error ) ; } 