FUN1 (VAR1 *VAR2, VAR1 *VAR3, struct VAR4 *VAR5)
{
unsigned int VAR6;
VAR7 *VAR8, **VAR9;
int VAR10 = 0;
struct VAR11 *VAR12 = FUN2 (VAR5);


bfd_size_type VAR13 = sizeof (VAR7 *) * VAR12->VAR14;
VAR9 = FUN3 (VAR13);
VAR12->VAR9 = VAR9;
if (VAR9 == NULL)
return -1;


for (VAR6 = 0;
VAR3 != NULL;
VAR3 = VAR3->VAR15, VAR6++)
{
VAR16 *VAR17;


VAR17 = &FUN4 (VAR3)->VAR17;
if (VAR17->VAR18 == 0)
continue;


VAR8 = (VAR7 *) VAR17->VAR19;
if (VAR8 == NULL)
{
VAR8 = FUN5 (VAR3, VAR17,
VAR17->VAR18, 0,
NULL, NULL, NULL);

VAR17->VAR19 = (unsigned char *) VAR8;
}
if (VAR8 == NULL)
return -1;

VAR9[VAR6] = VAR8;

if (VAR5->VAR20 && VAR12->VAR21)
{
struct VAR22 **VAR23;
struct VAR22 **VAR24;
unsigned int VAR25;

VAR25 = (VAR17->VAR26 / sizeof (VAR27)
- VAR17->VAR18);
VAR23 = (struct VAR22 **) FUN6 (VAR3);
VAR24 = (struct VAR22 **) (VAR23 + VAR25);


for (; VAR23 < VAR24; VAR23++)
{
struct VAR28 *VAR29;

VAR29 = FUN7 (*VAR23);

while (VAR29->VAR30.VAR31.VAR32 == VAR33
|| VAR29->VAR30.VAR31.VAR32 == VAR34)
VAR29 = FUN7 (VAR29->VAR30.VAR31.VAR35.VAR36.VAR37);


if ((VAR29->VAR30.VAR31.VAR32 == VAR38
|| VAR29->VAR30.VAR31.VAR32 == VAR39)
&& VAR29->VAR30.VAR32 == VAR40
&& VAR29->VAR30.VAR31.VAR35.VAR41.VAR42->VAR43 != NULL
&& (VAR29->VAR30.VAR31.VAR35.VAR41.VAR42->VAR43->VAR44
== VAR2)
&& VAR29->VAR30.VAR31.VAR35.VAR41.VAR42->VAR44 == VAR3
&& VAR29->VAR30.VAR45
&& !VAR29->VAR30.VAR46
&& FUN8 (VAR29->VAR30.VAR47) == VAR48)
{
VAR49 *VAR50;
const char *VAR51;
struct VAR52 *VAR53;

VAR50 = VAR29->VAR30.VAR31.VAR35.VAR41.VAR42;
VAR51 = VAR29->VAR30.VAR31.VAR31.VAR54;
VAR53 = FUN9 (&VAR12->VAR55,
VAR51,
VAR56, VAR56);
if (VAR53 == NULL)
{
VAR53 = FUN10 (VAR51, VAR50, VAR12);
if (!VAR53)
return -1;

VAR53->VAR57 = VAR29->VAR30.VAR31.VAR35.VAR41.VAR58;
VAR53->VAR59 = VAR29->VAR30.VAR31.VAR35.VAR41.VAR42;
VAR53->VAR60 = VAR61;
VAR53->VAR29 = VAR29;
VAR10 = 1;
}
else
{
(*VAR62) (FUN11(""),
VAR3,
VAR51);
}
}
}
}
}

return VAR10;
}



VAR63
VAR64
(VAR1 *VAR2, VAR1 *VAR65, struct VAR4 *VAR5,
bfd_boolean VAR21, bfd_signed_vma VAR66,
VAR49 * (*VAR67) (const char *, VAR49 *),
void (*VAR68) (void))
{
bfd_size_type VAR69;
bfd_boolean VAR70;
bfd_boolean VAR10;
struct VAR11 *VAR12 = FUN2 (VAR5);


VAR12->VAR65 = VAR65;
VAR12->VAR21 = VAR21;
VAR12->VAR67 = VAR67;
VAR12->VAR68 = VAR68;
VAR70 = VAR66 < 0;
if (VAR66 < 0)
VAR69 = -VAR66;
else
VAR69 = VAR66;
if (VAR69 == 1)
{

if (VAR70)
{
VAR69 = 7680000;
if (VAR12->VAR71 || VAR12->VAR21)
VAR69 = 240000;
if (VAR12->VAR72)
VAR69 = 7500;
}
else
{
VAR69 = 6971392;
if (VAR12->VAR71 || VAR12->VAR21)
VAR69 = 217856;
if (VAR12->VAR72)
VAR69 = 6808;
}
}

FUN12 (VAR12, VAR69, VAR70);

switch (FUN1 (VAR2, VAR5->VAR73, VAR5))
{
default:
if (VAR12->VAR9)
goto VAR74;
return VAR56;

case 0:
VAR10 = VAR56;
break;

case 1:
VAR10 = VAR75;
break;
}

while (1)
{
VAR1 *VAR3;
unsigned int VAR6;
VAR49 *VAR76;

for (VAR3 = VAR5->VAR73, VAR6 = 0;
VAR3 != NULL;
VAR3 = VAR3->VAR15, VAR6++)
{
VAR16 *VAR17;
VAR49 *VAR42;
VAR7 *VAR8;


VAR17 = &FUN4 (VAR3)->VAR17;
if (VAR17->VAR18 == 0)
continue;

VAR8 = VAR12->VAR9[VAR6];


for (VAR42 = VAR3->VAR77;
VAR42 != NULL;
VAR42 = VAR42->VAR78)
{
VAR79 *VAR80, *VAR81, *VAR82;


if ((VAR42->VAR83 & VAR84) == 0
|| VAR42->VAR85 == 0)
continue;


if (VAR42->VAR43 == NULL
|| VAR42->VAR43->VAR44 != VAR2)
continue;


VAR80
= FUN13 (VAR3, VAR42, NULL, NULL,
VAR5->VAR86);
if (VAR80 == NULL)
goto VAR74;


VAR82 = VAR80;
VAR81 = VAR82 + VAR42->VAR85;
for (; VAR82 < VAR81; VAR82++)
{
unsigned int VAR87, VAR88;
enum elf32_hppa_stub_type VAR60;
struct VAR52 *VAR53;
VAR49 *VAR89;
bfd_vma VAR90;
bfd_vma VAR91;
struct VAR28 *VAR29;
char *VAR51;
const VAR49 *VAR92;

VAR87 = FUN14 (VAR82->VAR93);
VAR88 = FUN15 (VAR82->VAR93);

if (VAR87 >= (unsigned int) VAR94)
{
FUN16 (VAR95);
VAR96:
if (FUN17 (VAR42)->VAR97 == NULL)
free (VAR80);
goto VAR74;
}


if (VAR87 != (unsigned int) VAR98
&& VAR87 != (unsigned int) VAR99
&& VAR87 != (unsigned int) VAR100)
continue;


VAR89 = NULL;
VAR90 = 0;
VAR91 = 0;
VAR29 = NULL;
if (VAR88 < VAR17->VAR18)
{

VAR7 *VAR101;
VAR16 *VAR102;

VAR101 = VAR8 + VAR88;
VAR102 = FUN18 (VAR3)[VAR101->VAR103];
VAR89 = VAR102->VAR104;
if (FUN19 (VAR101->VAR105) != VAR106)
VAR90 = VAR101->VAR107;
VAR91 = (VAR90 + VAR82->VAR108
+ VAR89->VAR109
+ VAR89->VAR43->VAR110);
}
else
{

int VAR111;

VAR111 = VAR88 - VAR17->VAR18;
VAR29 = FUN7 (FUN6 (VAR3)[VAR111]);

while (VAR29->VAR30.VAR31.VAR32 == VAR33
|| VAR29->VAR30.VAR31.VAR32 == VAR34)
VAR29 = FUN7 (VAR29->VAR30.VAR31.VAR35.VAR36.VAR37);

if (VAR29->VAR30.VAR31.VAR32 == VAR38
|| VAR29->VAR30.VAR31.VAR32 == VAR39)
{
VAR89 = VAR29->VAR30.VAR31.VAR35.VAR41.VAR42;
VAR90 = VAR29->VAR30.VAR31.VAR35.VAR41.VAR58;
if (VAR89->VAR43 != NULL)
VAR91 = (VAR90 + VAR82->VAR108
+ VAR89->VAR109
+ VAR89->VAR43->VAR110);
}
else if (VAR29->VAR30.VAR31.VAR32 == VAR112)
{
if (! VAR5->VAR20)
continue;
}
else if (VAR29->VAR30.VAR31.VAR32 == VAR113)
{
if (! (VAR5->VAR114 == VAR115
&& (FUN8 (VAR29->VAR30.VAR47)
== VAR48)
&& VAR29->VAR30.VAR32 != VAR116))
continue;
}
else
{
FUN16 (VAR95);
goto VAR96;
}
}


VAR60 = FUN20 (VAR42, VAR82, VAR29,
VAR91, VAR5);
if (VAR60 == VAR117)
continue;


VAR92 = VAR12->VAR118[VAR42->VAR119].VAR120;


VAR51 = FUN21 (VAR92, VAR89, VAR29, VAR82);
if (!VAR51)
goto VAR96;

VAR53 = FUN9 (&VAR12->VAR55,
VAR51,
VAR56, VAR56);
if (VAR53 != NULL)
{

free (VAR51);
continue;
}

VAR53 = FUN10 (VAR51, VAR42, VAR12);
if (VAR53 == NULL)
{
free (VAR51);
goto VAR96;
}

VAR53->VAR57 = VAR90;
VAR53->VAR59 = VAR89;
VAR53->VAR60 = VAR60;
if (VAR5->VAR20)
{
if (VAR60 == VAR121)
VAR53->VAR60 = VAR122;
else if (VAR60 == VAR123)
VAR53->VAR60 = VAR124;
}
VAR53->VAR29 = VAR29;
VAR10 = VAR75;
}


if (FUN17 (VAR42)->VAR97 == NULL)
free (VAR80);
}
}

if (!VAR10)
break;


for (VAR76 = VAR12->VAR65->VAR77;
VAR76 != NULL;
VAR76 = VAR76->VAR78)
VAR76->VAR125 = 0;

FUN22 (&VAR12->VAR55, VAR126, VAR12);


(*VAR12->VAR68) ();
VAR10 = VAR56;
}

free (VAR12->VAR9);
return VAR75;

VAR74:
free (VAR12->VAR9);
return VAR56;
}