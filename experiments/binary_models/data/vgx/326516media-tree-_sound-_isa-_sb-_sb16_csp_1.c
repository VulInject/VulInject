static int snd_sb_csp_ioctl ( struct snd_hwdep * hw , struct file * file , unsigned int cmd , unsigned long arg ) { struct snd_sb_csp * p = hw -> private_data ; struct snd_sb_csp_info info ; struct snd_sb_csp_start start_info ; int err ; if ( snd_BUG_ON ( ! p ) ) { return - EINVAL ; } if ( snd_sb_csp_check_version ( p ) ) { return - ENODEV ; } switch ( cmd ) { case SNDRV_SB_CSP_IOCTL_INFO : * info . codec_name = * p -> codec_name ; info . func_nr = p -> func_nr ; info . acc_format = p -> acc_format ; info . acc_channels = p -> acc_channels ; info . acc_width = p -> acc_width ; info . acc_rates = p -> acc_rates ; info . csp_mode = p -> mode ; info . run_channels = p -> run_channels ; info . run_width = p -> run_width ; info . version = p -> version ; info . state = p -> running ; if ( copy_to_user ( ( void __user * ) arg , & info , sizeof ( info ) ) ) { err = - EFAULT ; } else { err = 0 ; } break ; case SNDRV_SB_CSP_IOCTL_LOAD_CODE : err = ( p -> running & SNDRV_SB_CSP_ST_RUNNING ?- EBUSY : snd_sb_csp_riff_load ( p , ( snd_sb_csp_microcode __user * ) arg ) ) ; break ; case SNDRV_SB_CSP_IOCTL_UNLOAD_CODE : err = ( p -> running & SNDRV_SB_CSP_ST_RUNNING ?- EBUSY : snd_sb_csp_unload ( p ) ) ; break ; case SNDRV_SB_CSP_IOCTL_START : if ( copy_from_user ( & start_info , ( void __user * ) arg , sizeof ( start_info ) ) ) { err = - EFAULT ; } else { err = snd_sb_csp_start ( p , start_info . sample_width , start_info . channels ) ; } break ; case SNDRV_SB_CSP_IOCTL_STOP : err = snd_sb_csp_stop ( p ) ; break ; case SNDRV_SB_CSP_IOCTL_PAUSE : err = snd_sb_csp_pause ( p ) ; break ; case SNDRV_SB_CSP_IOCTL_RESTART : err = snd_sb_csp_restart ( p ) ; break ; default : err = - ENOTTY ; break ; } return err ; } 