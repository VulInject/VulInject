static int i40e_check_fdir_input_set ( struct i40e_vsi * vsi , struct ethtool_rx_flow_spec * fsp , struct i40e_rx_flow_userdef * userdef ) { struct i40e_pf * pf = vsi -> back ; struct ethtool_tcpip4_spec * tcp_ip4_spec ; struct ethtool_usrip4_spec * usr_ip4_spec ; u64 current_mask , new_mask ; bool new_flex_offset = false ; bool flex_l3 = false ; u16 * fdir_filter_count ; u16 index , src_offset = 0 ; u8 pit_index = 0 ; int err ; switch ( fsp -> flow_type & ~ FLOW_EXT ) { case SCTP_V4_FLOW : index = I40E_FILTER_PCTYPE_NONF_IPV4_SCTP ; fdir_filter_count = & pf -> fd_sctp4_filter_cnt ; break ; case TCP_V4_FLOW : index = I40E_FILTER_PCTYPE_NONF_IPV4_TCP ; fdir_filter_count = & pf -> fd_tcp4_filter_cnt ; break ; case UDP_V4_FLOW : index = I40E_FILTER_PCTYPE_NONF_IPV4_UDP ; fdir_filter_count = & pf -> fd_udp4_filter_cnt ; break ; case IP_USER_FLOW : index = I40E_FILTER_PCTYPE_NONF_IPV4_OTHER ; fdir_filter_count = & pf -> fd_ip4_filter_cnt ; flex_l3 = true ; break ; default : return - EOPNOTSUPP ; } current_mask = i40e_read_fd_input_set ( pf , index ) ; new_mask = current_mask ; switch ( fsp -> flow_type & ~ FLOW_EXT ) { case SCTP_V4_FLOW : new_mask &= ~ I40E_VERIFY_TAG_MASK ; case TCP_V4_FLOW : case UDP_V4_FLOW : tcp_ip4_spec = & fsp -> m_u . tcp_ip4_spec ; if ( tcp_ip4_spec -> ip4src == htonl ( 0xFFFFFFFF ) ) { new_mask |= I40E_L3_SRC_MASK ; } if ( ! tcp_ip4_spec -> ip4src ) { new_mask &= ~ I40E_L3_SRC_MASK ; } else { return - EOPNOTSUPP ; } if ( tcp_ip4_spec -> ip4dst == htonl ( 0xFFFFFFFF ) ) { new_mask |= I40E_L3_DST_MASK ; } if ( ! tcp_ip4_spec -> ip4dst ) { new_mask &= ~ I40E_L3_DST_MASK ; } else { return - EOPNOTSUPP ; } if ( tcp_ip4_spec -> psrc == htons ( 0xFFFF ) ) { new_mask |= I40E_L4_SRC_MASK ; } if ( ! tcp_ip4_spec -> psrc ) { new_mask &= ~ I40E_L4_SRC_MASK ; } else { return - EOPNOTSUPP ; } if ( tcp_ip4_spec -> pdst == htons ( 0xFFFF ) ) { new_mask |= I40E_L4_DST_MASK ; } if ( ! tcp_ip4_spec -> pdst ) { new_mask &= ~ I40E_L4_DST_MASK ; } else { return - EOPNOTSUPP ; } break ; case IP_USER_FLOW : usr_ip4_spec = & fsp -> m_u . usr_ip4_spec ; if ( usr_ip4_spec -> ip4src == htonl ( 0xFFFFFFFF ) ) { new_mask |= I40E_L3_SRC_MASK ; } if ( ! usr_ip4_spec -> ip4src ) { new_mask &= ~ I40E_L3_SRC_MASK ; } else { return - EOPNOTSUPP ; } if ( usr_ip4_spec -> ip4dst == htonl ( 0xFFFFFFFF ) ) { new_mask |= I40E_L3_DST_MASK ; } if ( ! usr_ip4_spec -> ip4dst ) { new_mask &= ~ I40E_L3_DST_MASK ; } else { return - EOPNOTSUPP ; } if ( usr_ip4_spec -> l4_4_bytes == htonl ( 0xFFFFFFFF ) ) { new_mask |= I40E_L4_SRC_MASK | I40E_L4_DST_MASK ; } if ( ! usr_ip4_spec -> l4_4_bytes ) { new_mask &= ~ ( I40E_L4_SRC_MASK | I40E_L4_DST_MASK ) ; } else { return - EOPNOTSUPP ; } if ( usr_ip4_spec -> tos ) { return - EOPNOTSUPP ; } if ( usr_ip4_spec -> ip_ver ) { return - EINVAL ; } if ( usr_ip4_spec -> proto ) { return - EINVAL ; } break ; default : return - EOPNOTSUPP ; } new_mask &= ~ I40E_FLEX_INPUT_MASK ; if ( userdef -> flex_filter ) { struct i40e_flex_pit * l3_flex_pit = NULL , * flex_pit = NULL ; if ( userdef -> flex_offset & 0x1 ) { dev_warn ( & pf -> pdev -> dev , "Flexible data offset must be 2-byte aligned\n" ) ; return - EINVAL ; } src_offset = userdef -> flex_offset >> 1 ; if ( src_offset > I40E_MAX_FLEX_SRC_OFFSET ) { dev_warn ( & pf -> pdev -> dev , "Flexible data must reside within first 64 bytes of the packet payload\n" ) ; return - EINVAL ; } flex_pit = i40e_find_flex_offset ( & pf -> l4_flex_pit_list , src_offset ) ; if ( IS_ERR ( flex_pit ) ) { return PTR_ERR ( flex_pit ) ; } if ( flex_l3 ) { l3_flex_pit = i40e_find_flex_offset ( & pf -> l3_flex_pit_list , src_offset ) ; if ( IS_ERR ( l3_flex_pit ) ) { return PTR_ERR ( l3_flex_pit ) ; } if ( flex_pit ) { if ( l3_flex_pit ) { if ( l3_flex_pit -> pit_index != flex_pit -> pit_index ) { return - EINVAL ; } } else { new_flex_offset = true ; } } else { flex_pit = l3_flex_pit ; } } if ( ! flex_pit ) { new_flex_offset = true ; pit_index = i40e_unused_pit_index ( pf ) ; } else { pit_index = flex_pit -> pit_index ; } new_mask |= i40e_pit_index_to_mask ( pit_index ) ; } if ( new_mask == current_mask && ! new_flex_offset ) { return 0 ; } netif_info ( pf , drv , vsi -> netdev , "Input set change requested for %s flows:\n" , i40e_flow_str ( fsp ) ) ; i40e_print_input_set ( vsi , current_mask , new_mask ) ; if ( new_flex_offset ) { netif_info ( pf , drv , vsi -> netdev , "FLEX index %d: Offset ->%d" , pit_index , src_offset ) ; } if ( pf -> flags & I40E_FLAG_MFP_ENABLED ) { netif_err ( pf , drv , vsi -> netdev , "Cannot change Flow Director input sets while MFP is enabled\n" ) ; return - EOPNOTSUPP ; } if ( * fdir_filter_count ) { netif_err ( pf , drv , vsi -> netdev , "Cannot change input set for %s flows until %d preexisting filters are removed\n" , i40e_flow_str ( fsp ) , * fdir_filter_count ) ; return - EOPNOTSUPP ; } i40e_write_fd_input_set ( pf , index , new_mask ) ; if ( new_flex_offset ) { err = i40e_add_flex_offset ( & pf -> l4_flex_pit_list , src_offset , pit_index ) ; if ( err ) { return err ; } if ( flex_l3 ) { err = i40e_add_flex_offset ( & pf -> l3_flex_pit_list , src_offset , pit_index ) ; if ( err ) { return err ; } } i40e_reprogram_flex_pit ( pf ) ; } return 0 ; } 