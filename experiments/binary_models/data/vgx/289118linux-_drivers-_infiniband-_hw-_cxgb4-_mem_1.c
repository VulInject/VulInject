static int write_tpt_entry ( struct c4iw_rdev * rdev , u32 reset_tpt_entry , u32 * stag , u8 stag_state , u32 pdid , enum fw_ri_stag_type type , enum fw_ri_mem_perms perm , int bind_enabled , u32 zbva , u64 to , u64 len , u8 page_size , u32 pbl_size , u32 pbl_addr , struct sk_buff * skb , struct c4iw_wr_wait * wr_waitp ) { int err ; struct fw_ri_tpte * tpt ; u32 stag_idx ; static atomic_t key ; if ( c4iw_fatal_error ( rdev ) ) { return - EIO ; } tpt = kmalloc ( sizeof ( * tpt ) , GFP_KERNEL ) ; if ( ! tpt ) { return - ENOMEM ; } stag_state = stag_state > 0 ; stag_idx = ( * stag ) >> 8 ; if ( ( ! reset_tpt_entry ) && ( * stag == T4_STAG_UNSET ) ) { stag_idx = c4iw_get_resource ( & rdev -> resource . tpt_table ) ; if ( ! stag_idx ) { mutex_lock ( & rdev -> stats . lock ) ; rdev -> stats . stag . fail ++ ; mutex_unlock ( & rdev -> stats . lock ) ; return - ENOMEM ; } mutex_lock ( & rdev -> stats . lock ) ; rdev -> stats . stag . cur += 32 ; if ( rdev -> stats . stag . cur > rdev -> stats . stag . max ) { rdev -> stats . stag . max = rdev -> stats . stag . cur ; } mutex_unlock ( & rdev -> stats . lock ) ; * stag = ( stag_idx << 8 ) | ( atomic_inc_return ( & key ) & 0xff ) ; } pr_debug ( "stag_state 0x%0x type 0x%0x pdid 0x%0x, stag_idx 0x%x\n" , stag_state , type , pdid , stag_idx ) ; if ( reset_tpt_entry ) { memset ( tpt , 0 , sizeof ( * tpt ) ) ; } else { tpt -> valid_to_pdid = cpu_to_be32 ( FW_RI_TPTE_VALID_F | FW_RI_TPTE_STAGKEY_V ( ( * stag & FW_RI_TPTE_STAGKEY_M ) ) | FW_RI_TPTE_STAGSTATE_V ( stag_state ) | FW_RI_TPTE_STAGTYPE_V ( type ) | FW_RI_TPTE_PDID_V ( pdid ) ) ; tpt -> locread_to_qpid = cpu_to_be32 ( FW_RI_TPTE_PERM_V ( perm ) | ( bind_enabled ?FW_RI_TPTE_MWBINDEN_F : 0 ) | FW_RI_TPTE_ADDRTYPE_V ( ( zbva ?FW_RI_ZERO_BASED_TO : FW_RI_VA_BASED_TO ) ) | FW_RI_TPTE_PS_V ( page_size ) ) ; tpt -> nosnoop_pbladdr = ! pbl_size ?0 : cpu_to_be32 ( FW_RI_TPTE_PBLADDR_V ( PBL_OFF ( rdev , pbl_addr ) >> 3 ) ) ; tpt -> len_lo = cpu_to_be32 ( ( u32 ) ( len & 0xffffffffUL ) ) ; tpt -> va_hi = cpu_to_be32 ( ( u32 ) ( to >> 32 ) ) ; tpt -> va_lo_fbo = cpu_to_be32 ( ( u32 ) ( to & 0xffffffffUL ) ) ; tpt -> dca_mwbcnt_pstag = cpu_to_be32 ( 0 ) ; tpt -> len_hi = cpu_to_be32 ( ( u32 ) ( len >> 32 ) ) ; } err = write_adapter_mem ( rdev , stag_idx + ( rdev -> lldi . vr -> stag . start >> 5 ) , sizeof ( * tpt ) , tpt , skb , wr_waitp ) ; if ( reset_tpt_entry ) { c4iw_put_resource ( & rdev -> resource . tpt_table , stag_idx ) ; mutex_lock ( & rdev -> stats . lock ) ; rdev -> stats . stag . cur -= 32 ; mutex_unlock ( & rdev -> stats . lock ) ; } kfree ( tpt ) ; return err ; } 