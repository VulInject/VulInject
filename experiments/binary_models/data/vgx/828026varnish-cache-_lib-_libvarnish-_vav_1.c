char * VAV_BackSlashDecode ( const char * s , const char * e ) { const char * q ; char * p , * r ; int i ; if ( e == NULL ) { e = strchr ( s , '\0' ) ; } assert ( e != NULL ) ; p = calloc ( 1 , ( e - s ) + 1L ) ; if ( p == NULL ) { return ( p ) ; } for ( r = p , q = s ; q < e ; ) { if ( * q != '\\' ) { * r ++ = * q ++ ; continue ; } i = vav_backslash_txt ( q , e , r ) ; if ( i == 0 ) { errno = EINVAL ; return ( NULL ) ; } q += i ; r ++ ; } * r = '\0' ; return ( p ) ; } static char err_invalid_backslash [ ] "Invalid backslash sequence" ; ; static char err_invalid_quote [ ] "Invalid '\"'" ; ; static char err_missing_quote [ ] "Missing '\"'" ; ; static char err_missing_separator [ ] "Missing separator between arguments" ; ; char * * VAV_ParseTxt ( const char * b , const char * e , int * argc , int flag ) { char * * argv ; const char * p , * sep ; int nargv , largv ; int i , quote ; AN ( b ) ; if ( e == NULL ) { e = strchr ( b , '\0' ) ; } sep = NULL ; quote = 0 ; nargv = 1 ; largv = 16 ; argv = calloc ( largv , sizeof argv ) ; if ( argv == NULL ) { return ( NULL ) ; } while ( b < e ) { if ( isspace ( * b ) ) { b ++ ; continue ; } if ( sep != NULL && isspace ( * sep ) && * b == ',' && ( flag & ARGV_COMMA ) ) { sep = NULL ; b ++ ; continue ; } if ( sep != NULL && * sep == '"' && * b == '"' ) { argv [ 0 ] = err_missing_separator ; return ( argv ) ; } sep = NULL ; if ( ( flag & ARGV_COMMENT ) && * b == '#' ) { break ; } if ( * b == '"' && ! ( flag & ARGV_NOESC ) ) { p = ++ b ; quote = 1 ; } else { p = b ; quote = 0 ; } while ( b < e ) { if ( * b == '\\' && ! ( flag & ARGV_NOESC ) ) { i = vav_backslash_txt ( b , e , NULL ) ; if ( i == 0 ) { argv [ 0 ] = err_invalid_backslash ; return ( argv ) ; } b += i ; continue ; } if ( ! quote ) { if ( isspace ( * b ) ) { sep = b ; break ; } if ( ( flag & ARGV_COMMA ) && * b == ',' ) { sep = b ; break ; } if ( ! ( flag & ARGV_NOESC ) && * b == '"' ) { argv [ 0 ] = err_invalid_quote ; return ( argv ) ; } b ++ ; continue ; } if ( * b == '"' && ! ( flag & ARGV_NOESC ) ) { sep = b ; quote = 0 ; break ; } b ++ ; } if ( sep == NULL && quote ) { argv [ 0 ] = err_missing_quote ; return ( argv ) ; } if ( nargv + 2 >= largv ) { argv = realloc ( argv , sizeof ( * argv ) * ( largv += largv ) ) ; assert ( argv != NULL ) ; } if ( flag & ARGV_NOESC ) { argv [ nargv ] = malloc ( 1L + ( b - p ) ) ; assert ( argv [ nargv ] != NULL ) ; memcpy ( argv [ nargv ] , p , b - p ) ; argv [ nargv ] [ b - p ] = '\0' ; } else { argv [ nargv ] = VAV_BackSlashDecode ( p , b ) ; assert ( argv [ nargv ] != NULL ) ; } nargv ++ ; if ( b < e ) { b ++ ; } } if ( sep != NULL && * sep == ',' ) { argv [ nargv ] = strdup ( "" ) ; assert ( argv [ nargv ] != NULL ) ; nargv ++ ; } argv [ nargv ] = NULL ; if ( argc != NULL ) { * argc = nargv ; } return ( argv ) ; } 