static int tcm_qla2xxx_handle_cmd ( scsi_qla_host_t * vha , struct qla_tgt_cmd * cmd , unsigned char * cdb , uint32_t data_length , int fcp_task_attr , int data_dir , int bidi ) { struct se_cmd * se_cmd = & cmd -> se_cmd ; struct se_session * se_sess ; struct fc_port * sess ; struct se_portal_group * se_tpg ; struct tcm_qla2xxx_tpg * tpg ; int rc , target_flags = TARGET_SCF_ACK_KREF ; unsigned long flags ; if ( bidi ) { target_flags |= TARGET_SCF_BIDI_OP ; } if ( se_cmd -> cpuid != WORK_CPU_UNBOUND ) { target_flags |= TARGET_SCF_USE_CPUID ; } sess = cmd -> sess ; if ( ! sess ) { pr_err ( "Unable to locate struct fc_port from qla_tgt_cmd\n" ) ; return - EINVAL ; } se_sess = sess -> se_sess ; if ( ! se_sess ) { pr_err ( "Unable to locate active struct se_session\n" ) ; return - EINVAL ; } se_tpg = se_sess -> se_tpg ; tpg = container_of ( se_tpg , tcm_qla2xxx_tpg , se_tpg ) ; if ( unlikely ( tpg -> tpg_attrib . jam_host ) ) { return 0 ; } cmd -> qpair -> tgt_counters . qla_core_sbt_cmd ++ ; spin_lock_irqsave ( & sess -> sess_cmd_lock , flags ) ; list_add_tail ( & cmd -> sess_cmd_list , & sess -> sess_cmd_list ) ; spin_unlock_irqrestore ( & sess -> sess_cmd_lock , flags ) ; rc = target_init_cmd ( se_cmd , se_sess , & cmd -> sense_buffer [ 0 ] , cmd -> unpacked_lun , data_length , fcp_task_attr , data_dir , target_flags ) ; if ( rc ) { return rc ; } if ( target_submit_prep ( se_cmd , cdb , NULL , 0 , NULL , 0 , NULL , 0 , GFP_KERNEL ) ) { return 0 ; } target_submit ( se_cmd , NULL ) ; return 0 ; } 