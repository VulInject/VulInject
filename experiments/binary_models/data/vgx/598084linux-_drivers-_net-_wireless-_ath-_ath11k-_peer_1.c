static int ath11k_peer_rhash_id_tbl_init ( struct ath11k_base * ab ) { struct rhashtable_params * param ; struct rhashtable * rhash_id_tbl ; int ret ; size_t size ; lockdep_assert_held ( & ab -> tbl_mtx_lock ) ; if ( ab -> rhead_peer_id ) { return 0 ; } size = sizeof ( * ab -> rhead_peer_id ) ; rhash_id_tbl = kmalloc ( size , GFP_KERNEL ) ; if ( ! rhash_id_tbl ) { ath11k_warn ( ab , "failed to init rhash id table due to no mem (size %zu)\n" , size ) ; return - ENOMEM ; } param = & ab -> rhash_peer_id_param ; param -> key_offset = offsetof ( ath11k_peer , peer_id ) ; param -> head_offset = offsetof ( ath11k_peer , rhash_id ) ; param -> key_len = sizeof_field ( ath11k_peer , peer_id ) ; param -> automatic_shrinking = true ; param -> nelem_hint = ab -> num_radios * TARGET_NUM_PEERS_PDEV ( ab ) ; ret = rhashtable_init ( rhash_id_tbl , param ) ; if ( ret ) { ath11k_warn ( ab , "failed to init peer id rhash table %d\n" , ret ) ; err_free } spin_lock_bh ( & ab -> base_lock ) ; if ( ! ab -> rhead_peer_id ) { ab -> rhead_peer_id = rhash_id_tbl ; } else { spin_unlock_bh ( & ab -> base_lock ) ; cleanup_tbl } spin_unlock_bh ( & ab -> base_lock ) ; return 0 ; cleanup_tbl rhashtable_destroy ( rhash_id_tbl ) ; err_free kfree ( rhash_id_tbl ) ; return ret ; } 