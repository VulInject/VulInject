int ide_timing_compute ( ide_drive_t * drive , u8 speed , struct ide_timing * t , int T , int UT ) { u16 * id = drive -> id ; struct ide_timing * s , p ; s = ide_timing_find_mode ( speed ) ; if ( s == NULL ) { return - EINVAL ; } * t = * s ; if ( id [ ATA_ID_FIELD_VALID ] & 2 ) { if ( speed >= XFER_PIO_0 && speed < XFER_SW_DMA_0 ) { if ( speed <= XFER_PIO_2 ) { p . cycle = p . cyc8b = id [ ATA_ID_EIDE_PIO ] ; } if ( ( speed <= XFER_PIO_4 ) || ( speed == XFER_PIO_5 && ! ata_id_is_cfa ( id ) ) ) { p . cycle = p . cyc8b = id [ ATA_ID_EIDE_PIO_IORDY ] ; } } if ( speed >= XFER_MW_DMA_0 && speed <= XFER_MW_DMA_2 ) { p . cycle = id [ ATA_ID_EIDE_DMA_MIN ] ; } ide_timing_merge ( & p , t , t , IDE_TIMING_CYCLE | IDE_TIMING_CYC8B ) ; } ide_timing_quantize ( t , t , T , UT ) ; if ( speed >= XFER_SW_DMA_0 ) { ide_timing_compute ( drive , drive -> pio_mode , & p , T , UT ) ; ide_timing_merge ( & p , t , t , IDE_TIMING_ALL ) ; } if ( t -> act8b + t -> rec8b < t -> cyc8b ) { t -> act8b += ( t -> cyc8b - ( t -> act8b + t -> rec8b ) ) / 2 ; t -> rec8b = t -> cyc8b - t -> act8b ; } if ( t -> active + t -> recover < t -> cycle ) { t -> active += ( t -> cycle - ( t -> active + t -> recover ) ) / 2 ; t -> recover = t -> cycle - t -> active ; } return 0 ; } 