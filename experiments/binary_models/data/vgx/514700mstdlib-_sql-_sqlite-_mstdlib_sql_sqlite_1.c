static M_sql_error_t sqlite_cb_execute ( M_sql_conn_t * conn , M_sql_stmt_t * stmt , size_t * rows_executed , char * error , size_t error_size ) { int real_rc ; int rc ; M_sql_error_t err ; int retry_cnt = 0 ; M_sql_driver_stmt_t * driver_stmt = M_sql_driver_stmt_get_stmt ( stmt ) ; M_sql_driver_conn_t * driver_conn = M_sql_driver_conn_get_conn ( conn ) ; * rows_executed = sqlite_num_process_rows ( driver_conn , M_sql_driver_stmt_bind_cnt ( stmt ) , M_sql_driver_stmt_bind_rows ( stmt ) ) ; while ( 1 ) { real_rc = sqlite3_step ( driver_stmt -> stmt ) ; rc = real_rc & 0xFF ; err = sqlite_rc_to_error ( real_rc ) ; if ( err == M_SQL_ERROR_SUCCESS || err == M_SQL_ERROR_SUCCESS_ROW ) { sqlite_fetch_result_metadata ( driver_conn , driver_stmt , stmt ) ; break ; } if ( rc == SQLITE_BUSY && driver_stmt -> is_commit ) { } if ( rc == SQLITE_LOCKED ) { char temp [ 256 ] ; M_snprintf ( temp , sizeof ( temp ) , "sqlite3_step (execute) returned locked, retry (%zu)." , retry_cnt ) ; M_sql_driver_trace_message ( M_FALSE , NULL , conn , M_SQL_ERROR_UNSET , temp ) ; if ( retry_cnt >= 10 ) { M_snprintf ( error , error_size , "Rollback (%d), max retry count: %s" , real_rc , sqlite3_errmsg ( driver_conn -> conn ) ) ; break ; } } else { M_snprintf ( error , error_size , "Query Failed (%d): %s" , real_rc , sqlite3_errmsg ( driver_conn -> conn ) ) ; break ; } sqlite3_reset ( driver_stmt -> stmt ) ; M_thread_sleep ( M_sql_rollback_delay_ms ( M_sql_driver_conn_get_pool ( conn ) ) * 1000 ) ; retry_cnt ++ ; } return err ; } 