IPV4Hdr * icmp4_ip4h = ( IPV4Hdr * ) partial_packet ; if ( IPV4_GET_RAW_VER ( icmp4_ip4h ) != 4 ) { SCLogDebug ( "DecodePartialIPV4: ICMPv4 contains Unknown IPV4 version " "ICMPV4_IPV4_UNKNOWN_VER" ) ; ENGINE_SET_INVALID_EVENT ( p , ICMPV4_IPV4_UNKNOWN_VER ) ; return - 1 ; } p -> icmpv4vars . emb_ipv4h = icmp4_ip4h ; p -> icmpv4vars . emb_ip4_src = IPV4_GET_RAW_IPSRC ( icmp4_ip4h ) ; p -> icmpv4vars . emb_ip4_dst = IPV4_GET_RAW_IPDST ( icmp4_ip4h ) ; p -> icmpv4vars . emb_ip4_hlen = ( uint8_t ) ( IPV4_GET_RAW_HLEN ( icmp4_ip4h ) << 2 ) ; switch ( IPV4_GET_RAW_IPPROTO ( icmp4_ip4h ) ) { case IPPROTO_TCP : if ( len >= IPV4_HEADER_LEN + TCP_HEADER_LEN ) { p -> icmpv4vars . emb_tcph = ( TCPHdr * ) ( partial_packet + IPV4_HEADER_LEN ) ; p -> icmpv4vars . emb_sport = SCNtohs ( p -> icmpv4vars . emb_tcph -> th_sport ) ; p -> icmpv4vars . emb_dport = SCNtohs ( p -> icmpv4vars . emb_tcph -> th_dport ) ; p -> icmpv4vars . emb_ip4_proto = IPPROTO_TCP ; SCLogDebug ( "DecodePartialIPV4: ICMPV4->IPV4->TCP header sport: " "%" PRIu16 " dport %" PRIu16 "" , p -> icmpv4vars . emb_sport , p -> icmpv4vars . emb_dport ) ; } if ( len >= IPV4_HEADER_LEN + 4 ) { TCPHdr * emb_tcph = ( TCPHdr * ) ( partial_packet + IPV4_HEADER_LEN ) ; p -> icmpv4vars . emb_tcph = NULL ; p -> icmpv4vars . emb_sport = SCNtohs ( emb_tcph -> th_sport ) ; p -> icmpv4vars . emb_dport = SCNtohs ( emb_tcph -> th_dport ) ; p -> icmpv4vars . emb_ip4_proto = IPPROTO_TCP ; SCLogDebug ( "DecodePartialIPV4: ICMPV4->IPV4->TCP partial header sport: " "%" PRIu16 " dport %" PRIu16 "" , p -> icmpv4vars . emb_sport , p -> icmpv4vars . emb_dport ) ; } else { SCLogDebug ( "DecodePartialIPV4: Warning, ICMPV4->IPV4->TCP " "header Didn't fit in the packet!" ) ; p -> icmpv4vars . emb_dport = 0 ; } break ; case IPPROTO_UDP : if ( len >= IPV4_HEADER_LEN + UDP_HEADER_LEN ) { p -> icmpv4vars . emb_udph = ( UDPHdr * ) ( partial_packet + IPV4_HEADER_LEN ) ; p -> icmpv4vars . emb_sport = SCNtohs ( p -> icmpv4vars . emb_udph -> uh_sport ) ; p -> icmpv4vars . emb_dport = SCNtohs ( p -> icmpv4vars . emb_udph -> uh_dport ) ; p -> icmpv4vars . emb_ip4_proto = IPPROTO_UDP ; SCLogDebug ( "DecodePartialIPV4: ICMPV4->IPV4->UDP header sport: " "%" PRIu16 " dport %" PRIu16 "" , p -> icmpv4vars . emb_sport , p -> icmpv4vars . emb_dport ) ; } else { SCLogDebug ( "DecodePartialIPV4: Warning, ICMPV4->IPV4->UDP " "header Didn't fit in the packet!" ) ; p -> icmpv4vars . emb_sport = 0 ; p -> icmpv4vars . emb_dport = 0 ; } break ; case IPPROTO_ICMP : if ( len >= IPV4_HEADER_LEN + ICMPV4_HEADER_LEN ) { p -> icmpv4vars . emb_icmpv4h = ( ICMPV4Hdr * ) ( partial_packet + IPV4_HEADER_LEN ) ; p -> icmpv4vars . emb_sport = 0 ; p -> icmpv4vars . emb_dport = 0 ; p -> icmpv4vars . emb_ip4_proto = IPPROTO_ICMP ; SCLogDebug ( "DecodePartialIPV4: ICMPV4->IPV4->ICMP header" ) ; } break ; } char s [ 16 ] , d [ 16 ] ; PrintInet ( AF_INET , & ( p -> icmpv4vars . emb_ip4_src ) , s , sizeof ( s ) ) ; PrintInet ( AF_INET , & ( p -> icmpv4vars . emb_ip4_dst ) , d , sizeof ( d ) ) ; SCLogDebug ( "ICMPv4 embedding IPV4 %s->%s - PROTO: %" PRIu32 " ID: %" PRIu32 "" , s , d , IPV4_GET_RAW_IPPROTO ( icmp4_ip4h ) , IPV4_GET_RAW_IPID ( icmp4_ip4h ) ) ; return 0 ; 