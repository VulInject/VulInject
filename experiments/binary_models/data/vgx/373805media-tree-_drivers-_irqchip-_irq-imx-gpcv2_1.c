static int __init imx_gpcv2_irqchip_init ( struct device_node * node , struct device_node * parent ) { struct irq_domain * parent_domain , * domain ; struct gpcv2_irqchip_data * cd ; int i ; if ( ! parent ) { pr_err ( "%s: no parent, giving up\n" , node -> full_name ) ; return - ENODEV ; } parent_domain = irq_find_host ( parent ) ; if ( ! parent_domain ) { pr_err ( "%s: unable to get parent domain\n" , node -> full_name ) ; return - ENXIO ; } cd = kzalloc ( sizeof ( gpcv2_irqchip_data ) , GFP_KERNEL ) ; if ( ! cd ) { pr_err ( "kzalloc failed!\n" ) ; return - ENOMEM ; } raw_spin_lock_init ( & cd -> rlock ) ; cd -> gpc_base = of_iomap ( node , 0 ) ; if ( ! cd -> gpc_base ) { pr_err ( "fsl-gpcv2: unable to map gpc registers\n" ) ; return - ENOMEM ; } domain = irq_domain_add_hierarchy ( parent_domain , 0 , GPC_MAX_IRQS , node , & gpcv2_irqchip_data_domain_ops , cd ) ; if ( ! domain ) { iounmap ( cd -> gpc_base ) ; kfree ( cd ) ; return - ENOMEM ; } irq_set_default_host ( domain ) ; for ( i = 0 ; i < IMR_NUM ; i ++ ) { writel_relaxed ( ~ 0 , cd -> gpc_base + GPC_IMR1_CORE0 + i * 4 ) ; writel_relaxed ( ~ 0 , cd -> gpc_base + GPC_IMR1_CORE1 + i * 4 ) ; cd -> wakeup_sources [ i ] = ~ 0 ; } cd -> cpu2wakeup = GPC_IMR1_CORE0 ; writel_relaxed ( ~ 0x1 , cd -> gpc_base + cd -> cpu2wakeup ) ; imx_gpcv2_instance = cd ; register_syscore_ops ( & imx_gpcv2_syscore_ops ) ; of_node_clear_flag ( node , OF_POPULATED ) ; return 0 ; } 