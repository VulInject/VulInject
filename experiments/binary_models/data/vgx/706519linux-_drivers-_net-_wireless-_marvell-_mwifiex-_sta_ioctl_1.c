static int mwifiex_sec_ioctl_set_wpa_key ( struct mwifiex_private * priv , struct mwifiex_ds_encrypt_key * encrypt_key ) { int ret ; u8 remove_key = false ; struct host_cmd_ds_802_11_key_material * ibss_key ; if ( encrypt_key -> key_len > WLAN_MAX_KEY_LEN ) { mwifiex_dbg ( priv -> adapter , ERROR , "key length too long\n" ) ; return - 1 ; } if ( priv -> bss_mode == NL80211_IFTYPE_ADHOC ) { encrypt_key -> key_index = MWIFIEX_KEY_INDEX_UNICAST ; ret = mwifiex_send_cmd ( priv , HostCmd_CMD_802_11_KEY_MATERIAL , HostCmd_ACT_GEN_SET , KEY_INFO_ENABLED , encrypt_key , false ) ; if ( ret ) { return ret ; } ibss_key = & priv -> aes_key ; memcpy ( ibss_key -> key_param_set . key , encrypt_key -> key_material , encrypt_key -> key_len ) ; memcpy ( & ibss_key -> key_param_set . key_len , & encrypt_key -> key_len , sizeof ( ibss_key -> key_param_set . key_len ) ) ; ibss_key -> key_param_set . key_type_id = cpu_to_le16 ( KEY_TYPE_ID_TKIP ) ; ibss_key -> key_param_set . key_info = cpu_to_le16 ( KEY_ENABLED ) ; encrypt_key -> key_index = ~ MWIFIEX_KEY_INDEX_UNICAST ; } if ( ! encrypt_key -> key_index ) { encrypt_key -> key_index = MWIFIEX_KEY_INDEX_UNICAST ; } if ( remove_key ) { ret = mwifiex_send_cmd ( priv , HostCmd_CMD_802_11_KEY_MATERIAL , HostCmd_ACT_GEN_SET , ! KEY_INFO_ENABLED , encrypt_key , true ) ; } else { ret = mwifiex_send_cmd ( priv , HostCmd_CMD_802_11_KEY_MATERIAL , HostCmd_ACT_GEN_SET , KEY_INFO_ENABLED , encrypt_key , true ) ; } return ret ; } 