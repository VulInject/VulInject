BOOLEAN OvsNatTranslateCtEntry ( OVS_CT_ENTRY * entry ) { const uint16_t MIN_NAT_EPHEMERAL_PORT = 1024 ; const uint16_t MAX_NAT_EPHEMERAL_PORT = 65535 ; uint16_t minPort ; uint16_t maxPort ; uint16_t firstPort ; uint32_t addrDelta = 0 ; uint32_t addrIndex ; struct ct_addr ctAddr , maxCtAddr ; uint16_t port ; BOOLEAN allPortsTried ; BOOLEAN originalPortsTried ; struct ct_addr firstAddr ; uint32_t hash = OvsNatHashRange ( entry , 0 ) ; if ( ( entry -> natInfo . natAction & NAT_ACTION_SRC ) && ( ! ( entry -> natInfo . natAction & NAT_ACTION_SRC_PORT ) ) ) { firstPort = minPort = maxPort = ntohs ( entry -> key . src . port ) ; } if ( ( entry -> natInfo . natAction & NAT_ACTION_DST ) && ( ! ( entry -> natInfo . natAction & NAT_ACTION_DST_PORT ) ) ) { firstPort = minPort = maxPort = ntohs ( entry -> key . dst . port ) ; } else { uint16_t portDelta = entry -> natInfo . maxPort - entry -> natInfo . minPort ; uint16_t portIndex = ( uint16_t ) hash % ( portDelta + 1 ) ; firstPort = entry -> natInfo . minPort + portIndex ; minPort = entry -> natInfo . minPort ; maxPort = entry -> natInfo . maxPort ; } memset ( & maxCtAddr , 0 , sizeof maxCtAddr ) ; maxCtAddr = entry -> natInfo . maxAddr ; if ( entry -> key . dl_type == htons ( ETH_TYPE_IPV4 ) ) { addrDelta = ntohl ( entry -> natInfo . maxAddr . ipv4_aligned ) - ntohl ( entry -> natInfo . minAddr . ipv4_aligned ) ; addrIndex = hash % ( addrDelta + 1 ) ; ctAddr . ipv4_aligned = htonl ( ntohl ( entry -> natInfo . minAddr . ipv4_aligned ) + addrIndex ) ; } else { ctAddr . ipv6_aligned = entry -> natInfo . minAddr . ipv6_aligned ; } port = firstPort ; allPortsTried = FALSE ; originalPortsTried = FALSE ; firstAddr = ctAddr ; for ( ; ; ) { if ( entry -> natInfo . natAction & NAT_ACTION_SRC ) { entry -> rev_key . dst . addr = ctAddr ; if ( entry -> rev_key . nw_proto != IPPROTO_ICMP ) { entry -> rev_key . dst . port = htons ( port ) ; } } else { entry -> rev_key . src . addr = ctAddr ; if ( entry -> rev_key . nw_proto != IPPROTO_ICMP ) { entry -> rev_key . src . port = htons ( port ) ; } } OVS_NAT_ENTRY * natEntry = OvsNatLookup ( & entry -> rev_key , TRUE ) ; if ( ! natEntry ) { natEntry = OvsAllocateMemoryWithTag ( sizeof ( * natEntry ) , OVS_CT_POOL_TAG ) ; if ( ! natEntry ) { return FALSE ; } memcpy ( & natEntry -> key , & entry -> key , sizeof natEntry -> key ) ; memcpy ( & natEntry -> value , & entry -> rev_key , sizeof natEntry -> value ) ; natEntry -> ctEntry = entry ; OvsNatAddEntry ( natEntry ) ; return TRUE ; } if ( ! allPortsTried ) { if ( minPort == maxPort ) { allPortsTried = TRUE ; } if ( port == maxPort ) { port = minPort ; } else { port ++ ; } if ( port == firstPort ) { allPortsTried = TRUE ; } } else { if ( memcmp ( & ctAddr , & maxCtAddr , sizeof ctAddr ) ) { if ( entry -> key . dl_type == htons ( ETH_TYPE_IPV4 ) ) { ctAddr . ipv4_aligned = htonl ( ntohl ( ctAddr . ipv4_aligned ) + 1 ) ; } else { uint32_t addr [ 8 ] { 0 } ; ; uint16_t * tmpAddr = ( uint16_t * ) & ( ctAddr . ipv6_aligned ) ; for ( int m = 0 ; m < 8 ; m ++ ) { addr [ m ] = tmpAddr [ m ] ; } uint16_t carry = 1 , i = 8 ; while ( carry && i ) { addr [ i - 1 ] += carry ; if ( addr [ i - 1 ] > 0xffff || ! addr [ i - 1 ] ) { carry = 1 ; addr [ i - 1 ] &= 0xffff ; } else { carry = 0 ; } i -- ; } if ( carry ) { OVS_LOG_INFO ( "Ipv6 address incremented overflow." ) ; return FALSE ; } for ( int m = 0 ; m < 8 ; m ++ ) { tmpAddr [ m ] = ( uint16_t ) addr [ m ] ; } } } else { ctAddr = entry -> natInfo . minAddr ; } if ( ! memcmp ( & ctAddr , & firstAddr , sizeof ctAddr ) ) { if ( ! originalPortsTried ) { originalPortsTried = TRUE ; ctAddr = entry -> natInfo . minAddr ; minPort = MIN_NAT_EPHEMERAL_PORT ; maxPort = MAX_NAT_EPHEMERAL_PORT ; } else { break ; } } firstPort = minPort ; port = firstPort ; allPortsTried = FALSE ; } } return FALSE ; } 