int main ( int argc , char * argv [ ] ) { struct node * node ; int ismkfifo ; int n = 0 ; int mode = DEFFILEMODE ; int mflag = 0 ; void * set ; int ch ; if ( pledge ( "stdio dpath" , NULL ) == - 1 ) { err ( 1 , "pledge" ) ; } node = reallocarray ( NULL , sizeof ( node ) , argc ) ; if ( ! node ) { err ( 1 , NULL ) ; } ismkfifo = strcmp ( __progname , "mkfifo" ) == 0 ; while ( argc > 1 ) { while ( ( ch = getopt ( argc , argv , "m:" ) ) != - 1 ) { switch ( ch ) { case 'm' : if ( ! ( set = setmode ( optarg ) ) ) { errx ( 1 , "invalid file mode '%s'" , optarg ) ; } mode = getmode ( set , DEFFILEMODE ) ; if ( ( mode & ACCESSPERMS ) != mode ) { errx ( 1 , "forbidden mode: %o" , mode ) ; } mflag = 1 ; break ; default : usage ( ismkfifo ) ; } } argc -= optind ; argv += optind ; if ( ismkfifo ) { while ( * argv ) { node [ n ] . mode = mode | S_IFIFO ; node [ n ] . mflag = mflag ; node [ n ] . name = * argv ; node [ n ] . dev = 0 ; n ++ ; argv ++ ; } break ; } else { if ( argc < 2 ) { usage ( ismkfifo ) ; } node [ n ] . mode = mode ; node [ n ] . mflag = mflag ; node [ n ] . name = argv [ 0 ] ; if ( strlen ( argv [ 1 ] ) != 1 ) { errx ( 1 , "invalid device type '%s'" , argv [ 1 ] ) ; } switch ( argv [ 1 ] [ 0 ] ) { case 'p' : node [ n ] . mode |= S_IFIFO ; node [ n ] . dev = 0 ; argv ++ ; argc -- ; break ; case 'b' : node [ n ] . mode |= S_IFBLK ; common case 'c' : node [ n ] . mode |= S_IFCHR ; common node [ n ] . dev = compute_device ( argc , argv ) ; argv += 3 ; argc -= 3 ; break ; default : errx ( 1 , "invalid device type '%s'" , argv [ 1 ] ) ; } n ++ ; } optind = 1 ; optreset = 1 ; } if ( n == 0 ) { usage ( ismkfifo ) ; } return ( domakenodes ( node , n ) ) ; } 