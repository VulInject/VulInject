JABBER_MAIN ( "jabberd2router" , "Jabber 2 Router" , "Jabber Open Source Server: Router" , ) { router_t r ; char * config_file ; int optchar ; rate_t rt ; component_t comp ; union xhashv xhv ; int close_wait_max ; const char * cli_id = 0 ; time_t pool_time = 0 ; umask ( ( mode_t ) 0027 ) ; srand ( time ( NULL ) ) ; { WORD wVersionRequested ; WSADATA wsaData ; int err ; wVersionRequested = MAKEWORD ( 2 , 2 ) ; err = WSAStartup ( wVersionRequested , & wsaData ) ; if ( err != 0 ) { return 0 ; } } jabber_signal ( SIGINT , router_signal ) ; jabber_signal ( SIGTERM , router_signal ) ; jabber_signal ( SIGHUP , router_signal_hup ) ; jabber_signal ( SIGPIPE , SIG_IGN ) ; jabber_signal ( SIGUSR1 , router_signal_usr1 ) ; jabber_signal ( SIGUSR2 , router_signal_usr2 ) ; r = ( router_t ) calloc ( 1 , sizeof ( router_st ) ) ; r -> config = config_new ( ) ; config_file = CONFIG_DIR "/router.xml" ; while ( ( optchar = getopt ( argc , argv , "Dc:hi:?" ) ) >= 0 ) { switch ( optchar ) { case 'c' : config_file = optarg ; break ; case 'D' : set_debug_flag ( 1 ) ; printf ( "WARN: Debugging not enabled.  Ignoring -D.\n" ) ; break ; case 'i' : cli_id = optarg ; break ; case 'h' : case '?' : default : fputs ( "router - jabberd router (" VERSION ")\n" "Usage: router<options>\n" "Options are:\n" "   -c<config>config file to use [default: " CONFIG_DIR "/router.xml]\n" "   -i id           Override<id>config element\n" "   -D              Show debug output\n" , stdout ) ; config_free ( r -> config ) ; return 1 ; } } if ( config_load_with_id ( r -> config , config_file , cli_id ) != 0 ) { fputs ( "router: couldn't load config, aborting\n" , stderr ) ; config_free ( r -> config ) ; free ( r ) ; return 2 ; } _router_config_expand ( r ) ; r -> log = log_new ( r -> log_type , r -> log_ident , r -> log_facility ) ; log_write ( r -> log , LOG_NOTICE , "starting up" ) ; _router_pidfile ( r ) ; user_table_load ( r ) ; r -> aci = aci_load ( r ) ; if ( filter_load ( r ) ) { exit ( 1 ) ; } r -> conn_rates = xhash_new ( 101 ) ; r -> components = xhash_new ( 101 ) ; r -> routes = xhash_new ( 101 ) ; r -> log_sinks = xhash_new ( 101 ) ; r -> dead = jqueue_new ( ) ; r -> closefd = jqueue_new ( ) ; r -> deadroutes = jqueue_new ( ) ; r -> sx_env = sx_env_new ( ) ; if ( r -> local_pemfile != NULL ) { r -> sx_ssl = sx_env_plugin ( r -> sx_env , sx_ssl_init , NULL , r -> local_pemfile , NULL , NULL , r -> local_private_key_password , r -> local_ciphers ) ; if ( r -> sx_ssl == NULL ) { log_write ( r -> log , LOG_ERR , "failed to load SSL pemfile, SSL disabled" ) ; } } r -> sx_sasl = sx_env_plugin ( r -> sx_env , sx_sasl_init , "jabberd-router" , _router_sx_sasl_callback , ( void * ) r ) ; if ( r -> sx_sasl == NULL ) { log_write ( r -> log , LOG_ERR , "failed to initialise SASL context, aborting" ) ; exit ( 1 ) ; } r -> mio = mio_new ( r -> io_max_fds ) ; r -> fd = mio_listen ( r -> mio , r -> local_port , r -> local_ip , router_mio_callback , ( void * ) r ) ; if ( r -> fd == NULL ) { log_write ( r -> log , LOG_ERR , "[%s, port=%d] unable to listen (%s)" , r -> local_ip , r -> local_port , MIO_STRERROR ( MIO_ERROR ) ) ; exit ( 1 ) ; } log_write ( r -> log , LOG_NOTICE , "[%s, port=%d] listening for incoming connections" , r -> local_ip , r -> local_port , MIO_STRERROR ( MIO_ERROR ) ) ; while ( ! router_shutdown ) { mio_run ( r -> mio , 5 ) ; if ( router_logrotate ) { set_debug_log_from_config ( r -> config ) ; log_write ( r -> log , LOG_NOTICE , "reopening log ..." ) ; log_free ( r -> log ) ; r -> log = log_new ( r -> log_type , r -> log_ident , r -> log_facility ) ; log_write ( r -> log , LOG_NOTICE , "log started" ) ; log_write ( r -> log , LOG_NOTICE , "reloading filter ..." ) ; filter_unload ( r ) ; filter_load ( r ) ; log_write ( r -> log , LOG_NOTICE , "reloading users ..." ) ; user_table_unload ( r ) ; user_table_load ( r ) ; router_logrotate = 0 ; } while ( jqueue_size ( r -> dead ) > 0 ) { sx_free ( ( sx_t ) jqueue_pull ( r -> dead ) ) ; } while ( jqueue_size ( r -> closefd ) > 0 ) { mio_close ( r -> mio , ( mio_fd_t ) jqueue_pull ( r -> closefd ) ) ; } while ( jqueue_size ( r -> deadroutes ) > 0 ) { routes_free ( ( routes_t ) jqueue_pull ( r -> deadroutes ) ) ; } if ( r -> check_interval > 0 && time ( NULL ) >= r -> next_check ) { log_debug ( ZONE , "running time checks" ) ; _router_time_checks ( r ) ; r -> next_check = time ( NULL ) + r -> check_interval ; log_debug ( ZONE , "next time check at %d" , r -> next_check ) ; } if ( time ( NULL ) > pool_time + 60 ) { pool_stat ( 1 ) ; pool_time = time ( NULL ) ; } } log_write ( r -> log , LOG_NOTICE , "shutting down" ) ; if ( r -> fd ) { mio_app ( r -> mio , r -> fd , NULL , NULL ) ; mio_close ( r -> mio , r -> fd ) ; } close_wait_max = 30 ; xhv . comp_val = & comp ; if ( xhash_iter_first ( r -> components ) ) { { xhash_iter_get ( r -> components , NULL , NULL , xhv . val ) ; log_debug ( ZONE , "close component %p" , comp ) ; if ( comp ) { sx_close ( comp -> s ) ; } mio_run ( r -> mio , 5000 ) ; if ( 1 > close_wait_max -- ) { break ; } sleep ( 1 ) ; while ( jqueue_size ( r -> closefd ) > 0 ) { mio_close ( r -> mio , ( mio_fd_t ) jqueue_pull ( r -> closefd ) ) ; } } xhash_iter_next ( r -> components ) ; } xhash_free ( r -> components ) ; while ( jqueue_size ( r -> dead ) > 0 ) { sx_free ( ( sx_t ) jqueue_pull ( r -> dead ) ) ; } jqueue_free ( r -> dead ) ; while ( jqueue_size ( r -> closefd ) > 0 ) { mio_close ( r -> mio , ( mio_fd_t ) jqueue_pull ( r -> closefd ) ) ; } jqueue_free ( r -> closefd ) ; while ( jqueue_size ( r -> deadroutes ) > 0 ) { routes_free ( ( routes_t ) jqueue_pull ( r -> deadroutes ) ) ; } jqueue_free ( r -> deadroutes ) ; xhv . rt_val = & rt ; if ( xhash_iter_first ( r -> conn_rates ) ) { { xhash_iter_get ( r -> conn_rates , NULL , NULL , xhv . val ) ; rate_free ( rt ) ; } xhash_iter_next ( r -> conn_rates ) ; } xhash_free ( r -> conn_rates ) ; xhash_free ( r -> log_sinks ) ; if ( xhash_iter_first ( r -> routes ) ) { { routes_t p ; xhash_iter_get ( r -> routes , NULL , NULL , ( void * ) & p ) ; routes_free ( p ) ; } xhash_iter_next ( r -> routes ) ; } xhash_free ( r -> routes ) ; user_table_unload ( r ) ; aci_unload ( r -> aci ) ; filter_unload ( r ) ; sx_env_free ( r -> sx_env ) ; mio_free ( r -> mio ) ; access_free ( r -> access ) ; log_free ( r -> log ) ; config_free ( r -> config ) ; free ( r ) ; pool_stat ( 1 ) ; WSACleanup ( ) ; return 0 ; } 