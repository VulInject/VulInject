int sec_svc_getcred ( struct svc_req * req , cred_t * cr , caddr_t * principal , int * secmod ) { struct authunix_parms * aup ; struct authdes_cred * adc ; int flavor , stat ; rpc_gss_rawcred_t * rcred ; rpc_gss_ucred_t * ucred ; void * cookie ; flavor = req -> rq_cred . oa_flavor ; * principal = NULL ; switch ( flavor ) { case AUTH_UNIX : * secmod = AUTH_UNIX ; aup = ( authunix_parms * ) req -> rq_clntcred ; if ( crsetugid ( cr , aup -> aup_uid , aup -> aup_gid ) != 0 ) { ( void ) crsetugid ( cr , UID_NOBODY , GID_NOBODY ) ; } if ( crsetgroups ( cr , aup -> aup_len , aup -> aup_gids ) != 0 ) { ( void ) crsetgroups ( cr , 0 , NULL ) ; } break ; case AUTH_NONE : * secmod = AUTH_NONE ; break ; case AUTH_DES : * secmod = AUTH_DES ; adc = ( authdes_cred * ) req -> rq_clntcred ; stat = kauthdes_getucred ( adc , cr ) ; * principal = adc -> adc_fullname . name ; break ; case RPCSEC_GSS : stat = rpc_gss_getcred ( req , & rcred , & ucred , & cookie ) ; * secmod = ( int ) ( uintptr_t ) cookie ; if ( ucred != NULL ) { if ( crsetugid ( cr , ucred -> uid , ucred -> gid ) != 0 || crsetgroups ( cr , ucred -> gidlen , ucred -> gidlist ) != 0 ) { stat = 0 ; } } else { ( void ) crsetugid ( cr , UID_NOBODY , GID_NOBODY ) ; ( void ) crsetgroups ( cr , 0 , NULL ) ; } * principal = ( caddr_t ) rcred -> client_principal ; break ; default : stat = 0 ; break ; } return ( stat ) ; } 