static int ll_write_begin ( struct file * file , struct address_space * mapping , loff_t pos , unsigned int len , unsigned int flags , struct page * * pagep , void * * fsdata ) { struct ll_cl_context * lcc ; const struct lu_env * env = NULL ; struct cl_io * io ; struct cl_page * page = NULL ; struct cl_object * clob = ll_i2info ( mapping -> host ) -> lli_clob ; pgoff_t index = pos >> PAGE_SHIFT ; struct page * vmpage = NULL ; unsigned int from = pos & ( PAGE_SIZE - 1 ) ; unsigned int to = from + len ; int result = 0 ; CDEBUG ( D_VFSTRACE , "Writing %lu of %d to %d bytes\n" , index , from , len ) ; lcc = ll_cl_find ( file ) ; if ( ! lcc ) { io = NULL ; result = - EIO ; out } env = lcc -> lcc_env ; io = lcc -> lcc_io ; vmpage = grab_cache_page_nowait ( mapping , index ) ; if ( unlikely ( ! vmpage || PageDirty ( vmpage ) || PageWriteback ( vmpage ) ) ) { struct vvp_io * vio = vvp_env_io ( env ) ; struct cl_page_list * plist = & vio -> u . write . vui_queue ; if ( vmpage && plist -> pl_nr > 0 ) { unlock_page ( vmpage ) ; put_page ( vmpage , NULL ) ; vmpage = NULL ; } result = vvp_io_write_commit ( env , io ) ; if ( result < 0 ) { out } if ( ! vmpage ) { vmpage = grab_cache_page_write_begin ( mapping , index , flags ) ; if ( ! vmpage ) { result = - ENOMEM ; out } } } page = cl_page_find ( env , clob , vmpage -> index , vmpage , CPT_CACHEABLE ) ; if ( IS_ERR ( page ) ) { result = PTR_ERR ( page ) ; out } lcc -> lcc_page = page ; lu_ref_add ( & page -> cp_reference , "cl_io" , io ) ; cl_page_assume ( env , io , page ) ; if ( ! PageUptodate ( vmpage ) ) { if ( from == 0 && to == PAGE_SIZE ) { CL_PAGE_HEADER ( D_PAGE , env , page , "full page write\n" ) ; POISON_PAGE ( vmpage , 0x11 ) ; } else { result = ll_prepare_partial_page ( env , io , page ) ; if ( result == 0 ) { SetPageUptodate ( vmpage ) ; } } } if ( result < 0 ) { cl_page_unassume ( env , io , page ) ; } out if ( result < 0 ) { if ( vmpage ) { unlock_page ( vmpage ) ; put_page ( vmpage ) ; } if ( ! IS_ERR_OR_NULL ( page ) ) { lu_ref_del ( & page -> cp_reference , "cl_io" , io ) ; cl_page_put ( env , page ) ; } if ( io ) { io -> ci_result = result ; } } else { * pagep = vmpage ; * fsdata = lcc ; } return result ; } 