static int ab8500_btemp_probe ( struct platform_device * pdev ) { struct device_node * np = pdev -> dev . of_node ; struct abx500_bm_data * plat = pdev -> dev . platform_data ; struct power_supply_config psy_cfg = { } ; struct ab8500_btemp * di ; int irq , i , ret = 0 ; u8 val ; di = devm_kzalloc ( & pdev -> dev , sizeof ( * di ) , GFP_KERNEL ) ; if ( ! di ) { dev_err ( & pdev -> dev , "%s no mem for ab8500_btemp\n" , __func__ ) ; return - ENOMEM ; } if ( ! plat ) { dev_err ( & pdev -> dev , "no battery management data supplied\n" ) ; return - EINVAL ; } di -> bm = plat ; if ( np ) { ret = ab8500_bm_of_probe ( & pdev -> dev , np , di -> bm ) ; if ( ret ) { dev_err ( & pdev -> dev , "failed to get battery information\n" ) ; return ret ; } } di -> dev = & pdev -> dev ; di -> parent = dev_get_drvdata ( pdev -> dev . parent ) ; di -> gpadc = ab8500_gpadc_get ( "ab8500-gpadc.0" ) ; di -> initialized = false ; psy_cfg . supplied_to = supply_interface ; psy_cfg . num_supplicants = ARRAY_SIZE ( supply_interface ) ; psy_cfg . drv_data = di ; di -> btemp_wq = alloc_workqueue ( "ab8500_btemp_wq" , WQ_MEM_RECLAIM , 0 ) ; if ( di -> btemp_wq == NULL ) { dev_err ( di -> dev , "failed to create work queue\n" ) ; return - ENOMEM ; } INIT_DEFERRABLE_WORK ( & di -> btemp_periodic_work , ab8500_btemp_periodic_work ) ; di -> btemp_ranges . btemp_low_limit = BTEMP_THERMAL_LOW_LIMIT ; di -> btemp_ranges . btemp_med_limit = BTEMP_THERMAL_MED_LIMIT ; ret = abx500_get_register_interruptible ( di -> dev , AB8500_CHARGER , AB8500_BTEMP_HIGH_TH , & val ) ; if ( ret < 0 ) { dev_err ( di -> dev , "%s ab8500 read failed\n" , __func__ ) ; free_btemp_wq } switch ( val ) { case BTEMP_HIGH_TH_57_0 : case BTEMP_HIGH_TH_57_1 : di -> btemp_ranges . btemp_high_limit = BTEMP_THERMAL_HIGH_LIMIT_57 ; break ; case BTEMP_HIGH_TH_52 : di -> btemp_ranges . btemp_high_limit = BTEMP_THERMAL_HIGH_LIMIT_52 ; break ; case BTEMP_HIGH_TH_62 : di -> btemp_ranges . btemp_high_limit = BTEMP_THERMAL_HIGH_LIMIT_62 ; break ; } di -> btemp_psy = power_supply_register ( di -> dev , & ab8500_btemp_desc , & psy_cfg ) ; if ( IS_ERR ( di -> btemp_psy ) ) { dev_err ( di -> dev , "failed to register BTEMP psy\n" ) ; ret = PTR_ERR ( di -> btemp_psy , NULL ) ; free_btemp_wq } for ( i = 0 ; i < ARRAY_SIZE ( ab8500_btemp_irq ) ; i ++ ) { irq = platform_get_irq_byname ( pdev , ab8500_btemp_irq [ i ] . name ) ; ret = request_threaded_irq ( irq , NULL , ab8500_btemp_irq [ i ] . isr , IRQF_SHARED | IRQF_NO_SUSPEND , ab8500_btemp_irq [ i ] . name , di ) ; if ( ret ) { dev_err ( di -> dev , "failed to request %s IRQ %d: %d\n" , ab8500_btemp_irq [ i ] . name , irq , ret ) ; free_irq } dev_dbg ( di -> dev , "Requested %s IRQ %d: %d\n" , ab8500_btemp_irq [ i ] . name , irq , ret ) ; } platform_set_drvdata ( pdev , di ) ; ab8500_btemp_periodic ( di , true ) ; list_add_tail ( & di -> node , & ab8500_btemp_list ) ; return ret ; free_irq power_supply_unregister ( di -> btemp_psy ) ; for ( i = i - 1 ; i >= 0 ; i -- ) { irq = platform_get_irq_byname ( pdev , ab8500_btemp_irq [ i ] . name ) ; free_irq ( irq , di ) ; } free_btemp_wq destroy_workqueue ( di -> btemp_wq ) ; return ret ; } 