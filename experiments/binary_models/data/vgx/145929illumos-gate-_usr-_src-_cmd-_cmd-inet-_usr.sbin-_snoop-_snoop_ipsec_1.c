int interpret_ah ( int flags , uint8_t * hdr , int iplen , int fraglen ) { ah_t * ah = ( ah_t * ) hdr ; ah_t * aligned_ah ; ah_t storage ; char * line , * buff ; uint_t ahlen , auth_data_len ; uint8_t * auth_data , * data ; int new_iplen ; uint8_t proto ; if ( fraglen < sizeof ( ah_t ) ) { return ( fraglen ) ; } if ( ! IS_P2ALIGNED ( hdr , 4 ) ) { aligned_ah = ( ah_t * ) & storage ; bcopy ( hdr , & storage , sizeof ( ah_t ) ) ; } else { aligned_ah = ah ; } ahlen = ( aligned_ah -> ah_length << 2 ) + 8 ; fraglen -= ahlen ; if ( fraglen < 0 ) { return ( fraglen + ahlen ) ; } auth_data_len = ahlen - sizeof ( ah_t ) ; auth_data = ( uint8_t * ) ( ah + 1 ) ; data = auth_data + auth_data_len ; if ( flags & F_SUM ) { line = ( char * ) get_sum_line ( ) ; ( void ) sprintf ( line , "AH SPI=0x%x Replay=%u" , ntohl ( aligned_ah -> ah_spi ) , ntohl ( aligned_ah -> ah_replay ) ) ; line += strlen ( line ) ; } if ( flags & F_DTAIL ) { show_header ( "AH:  " , "Authentication Header" , ahlen ) ; show_space ( ) ; ( void ) sprintf ( get_line ( ( char * ) & ah -> ah_nexthdr - dlc_header , 1 ) , "Next header = %d (%s)" , aligned_ah -> ah_nexthdr , getproto ( aligned_ah -> ah_nexthdr ) ) ; ( void ) sprintf ( get_line ( ( char * ) & ah -> ah_length - dlc_header , 1 ) , "AH length = %d (%d bytes)" , aligned_ah -> ah_length , ahlen ) ; ( void ) sprintf ( get_line ( ( char * ) & ah -> ah_reserved - dlc_header , 2 ) , "<Reserved field = 0x%x>" , ntohs ( aligned_ah -> ah_reserved ) ) ; ( void ) sprintf ( get_line ( ( char * ) & ah -> ah_spi - dlc_header , 4 ) , "SPI = 0x%x" , ntohl ( aligned_ah -> ah_spi ) ) ; ( void ) sprintf ( get_line ( ( char * ) & ah -> ah_replay - dlc_header , 4 ) , "Replay = %u" , ntohl ( aligned_ah -> ah_replay ) ) ; buff = malloc ( auth_data_len * 2 + 1 ) ; if ( buff != NULL ) { int i ; for ( i = 0 ; i < auth_data_len ; i ++ ) { sprintf ( buff + i * 2 , "%02x" , auth_data [ i ] ) ; } } ( void ) sprintf ( get_line ( ( char * ) auth_data - dlc_header , auth_data_len ) , "ICV = %s" , ( buff == NULL ) ?"<out of memory>" : buff ) ; show_space ( ) ; } new_iplen = iplen - ahlen ; proto = aligned_ah -> ah_nexthdr ; if ( proto == IPPROTO_HOPOPTS || proto == IPPROTO_DSTOPTS || proto == IPPROTO_ROUTING || proto == IPPROTO_FRAGMENT ) { ( void ) print_ipv6_extensions ( flags , & data , & proto , & iplen , & fraglen ) ; } if ( fraglen > 0 ) { switch ( proto ) { case IPPROTO_ENCAP : ( void ) interpret_ip ( flags , ( ip * ) data , new_iplen ) ; break ; case IPPROTO_IPV6 : ( void ) interpret_ipv6 ( flags , ( ip6_t * ) data , new_iplen ) ; break ; case IPPROTO_ICMP : ( void ) interpret_icmp ( flags , ( icmp * ) data , new_iplen , fraglen ) ; break ; case IPPROTO_ICMPV6 : ( void ) interpret_icmpv6 ( flags , ( icmp6_t * ) data , new_iplen , fraglen ) ; break ; case IPPROTO_TCP : ( void ) interpret_tcp ( flags , ( tcphdr * ) data , new_iplen , fraglen ) ; break ; case IPPROTO_ESP : ( void ) interpret_esp ( flags , data , new_iplen , fraglen ) ; break ; case IPPROTO_AH : ( void ) interpret_ah ( flags , data , new_iplen , fraglen ) ; break ; case IPPROTO_UDP : ( void ) interpret_udp ( flags , ( udphdr * ) data , new_iplen , fraglen ) ; break ; } } return ( ahlen ) ; } 