u32 cxgbit_send_tx_flowc_wr ( struct cxgbit_sock * csk ) { struct cxgbit_device * cdev = csk -> com . cdev ; struct fw_flowc_wr * flowc ; u32 nparams , flowclen16 , flowclen ; struct sk_buff * skb ; u8 index ; u16 vlan = ( ( l2t_entry * ) csk -> l2t ) -> vlan ; flowclen16 = cxgbit_tx_flowc_wr_credits ( csk , & nparams , & flowclen ) ; skb = __skb_dequeue ( & csk -> skbq ) ; flowc = ( fw_flowc_wr * ) __skb_put ( skb , flowclen ) ; flowc -> op_to_nparams = cpu_to_be32 ( FW_WR_OP_V ( FW_FLOWC_WR ) | FW_FLOWC_WR_NPARAMS_V ( nparams ) ) ; flowc -> flowid_len16 = cpu_to_be32 ( FW_WR_LEN16_V ( flowclen16 ) | FW_WR_FLOWID_V ( csk -> tid ) ) ; flowc -> mnemval [ 0 ] . mnemonic = FW_FLOWC_MNEM_PFNVFN ; flowc -> mnemval [ 0 ] . val = cpu_to_be32 ( FW_PFVF_CMD_PFN_V ( csk -> com . cdev -> lldi . pf ) ) ; flowc -> mnemval [ 1 ] . mnemonic = FW_FLOWC_MNEM_CH ; flowc -> mnemval [ 1 ] . val = cpu_to_be32 ( csk -> tx_chan ) ; flowc -> mnemval [ 2 ] . mnemonic = FW_FLOWC_MNEM_PORT ; flowc -> mnemval [ 2 ] . val = cpu_to_be32 ( csk -> tx_chan ) ; flowc -> mnemval [ 3 ] . mnemonic = FW_FLOWC_MNEM_IQID ; flowc -> mnemval [ 3 ] . val = cpu_to_be32 ( csk -> rss_qid ) ; flowc -> mnemval [ 4 ] . mnemonic = FW_FLOWC_MNEM_SNDNXT ; flowc -> mnemval [ 4 ] . val = cpu_to_be32 ( csk -> snd_nxt ) ; flowc -> mnemval [ 5 ] . mnemonic = FW_FLOWC_MNEM_RCVNXT ; flowc -> mnemval [ 5 ] . val = cpu_to_be32 ( csk -> rcv_nxt ) ; flowc -> mnemval [ 6 ] . mnemonic = FW_FLOWC_MNEM_SNDBUF ; flowc -> mnemval [ 6 ] . val = cpu_to_be32 ( csk -> snd_win ) ; flowc -> mnemval [ 7 ] . mnemonic = FW_FLOWC_MNEM_MSS ; flowc -> mnemval [ 7 ] . val = cpu_to_be32 ( csk -> emss ) ; flowc -> mnemval [ 8 ] . mnemonic = FW_FLOWC_MNEM_TXDATAPLEN_MAX ; if ( test_bit ( CDEV_ISO_ENABLE , & cdev -> flags ) ) { flowc -> mnemval [ 8 ] . val = cpu_to_be32 ( CXGBIT_MAX_ISO_PAYLOAD ) ; } else { flowc -> mnemval [ 8 ] . val = cpu_to_be32 ( 16384 ) ; } index = 9 ; if ( csk -> snd_wscale ) { flowc -> mnemval [ index ] . mnemonic = FW_FLOWC_MNEM_RCV_SCALE ; flowc -> mnemval [ index ] . val = cpu_to_be32 ( csk -> snd_wscale ) ; index ++ ; } flowc -> mnemval [ index ] . mnemonic = FW_FLOWC_MNEM_DCBPRIO ; if ( vlan == VLAN_NONE ) { pr_warn ( "csk %u without VLAN Tag on DCB Link\n" , csk -> tid ) ; flowc -> mnemval [ index ] . val = cpu_to_be32 ( 0 ) ; } else { flowc -> mnemval [ index ] . val = cpu_to_be32 ( ( vlan & VLAN_PRIO_MASK ) >> VLAN_PRIO_SHIFT ) ; } pr_debug ( "%s: csk %p; tx_chan = %u; rss_qid = %u; snd_seq = %u;" " rcv_seq = %u; snd_win = %u; emss = %u\n" , __func__ , csk , csk -> tx_chan , csk -> rss_qid , csk -> snd_nxt , csk -> rcv_nxt , csk -> snd_win , csk -> emss ) ; set_wr_txq ( skb , CPL_PRIORITY_DATA , csk -> txq_idx ) ; cxgbit_ofld_send ( csk -> com . cdev , skb ) ; return flowclen16 ; } 