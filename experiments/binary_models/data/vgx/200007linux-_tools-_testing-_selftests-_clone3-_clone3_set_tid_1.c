int main ( int argc , char * argv [ ] ) { FILE * f ; char buf ; char * line ; int status ; int ret = - 1 ; size_t len = 0 ; int pid_max = 0 ; uid_t uid = getuid ( ) ; char proc_path [ 100 ] { 0 } ; ; pid_t pid , ns1 , ns2 , ns3 , ns_pid ; pid_t set_tid [ MAX_PID_NS_LEVEL * 2 ] ; ksft_print_header ( ) ; ksft_set_plan ( 29 ) ; test_clone3_supported ( ) ; if ( pipe ( pipe_1 ) < 0 || pipe ( pipe_2 ) < 0 ) { ksft_exit_fail_msg ( "pipe() failed\n" ) ; } f = fopen ( "/proc/sys/kernel/pid_max" , "r" ) ; if ( f == NULL ) { ksft_exit_fail_msg ( "%s - Could not open /proc/sys/kernel/pid_max\n" , strerror ( errno ) ) ; } fscanf ( f , "%d" , & pid_max ) ; fclose ( f ) ; ksft_print_msg ( "/proc/sys/kernel/pid_max %d\n" , pid_max ) ; test_clone3_set_tid ( set_tid , MAX_PID_NS_LEVEL + 1 , 0 , - EINVAL , 0 , 0 ) ; test_clone3_set_tid ( set_tid , MAX_PID_NS_LEVEL * 2 , 0 , - EINVAL , 0 , 0 ) ; test_clone3_set_tid ( set_tid , MAX_PID_NS_LEVEL * 2 + 1 , 0 , - EINVAL , 0 , 0 ) ; test_clone3_set_tid ( set_tid , MAX_PID_NS_LEVEL * 42 , 0 , - EINVAL , 0 , 0 ) ; test_clone3_set_tid ( set_tid , MAX_PID_NS_LEVEL - 1 , 0 , - EINVAL , 0 , 0 ) ; memset ( & set_tid , 0xff , sizeof ( set_tid ) ) ; test_clone3_set_tid ( set_tid , MAX_PID_NS_LEVEL + 1 , 0 , - EINVAL , 0 , 0 ) ; test_clone3_set_tid ( set_tid , MAX_PID_NS_LEVEL * 2 , 0 , - EINVAL , 0 , 0 ) ; test_clone3_set_tid ( set_tid , MAX_PID_NS_LEVEL * 2 + 1 , 0 , - EINVAL , 0 , 0 ) ; test_clone3_set_tid ( set_tid , MAX_PID_NS_LEVEL * 42 , 0 , - EINVAL , 0 , 0 ) ; test_clone3_set_tid ( set_tid , MAX_PID_NS_LEVEL - 1 , 0 , - EINVAL , 0 , 0 ) ; memset ( & set_tid , 0 , sizeof ( set_tid ) ) ; set_tid [ 0 ] = 0 ; test_clone3_set_tid ( set_tid , 1 , 0 , - EINVAL , 0 , 0 ) ; set_tid [ 0 ] = - 1 ; test_clone3_set_tid ( set_tid , 1 , 0 , - EINVAL , 0 , 0 ) ; test_clone3_set_tid ( set_tid , 2 , 0 , - EINVAL , 0 , 0 ) ; if ( uid == 0 ) { test_clone3_set_tid ( set_tid , 1 , CLONE_NEWPID , - EINVAL , 0 , 0 ) ; } else { ksft_test_result_skip ( "Clone3() with set_tid requires root\n" ) ; } set_tid [ 0 ] = 1 ; if ( uid == 0 ) { test_clone3_set_tid ( set_tid , 1 , 0 , - EEXIST , 0 , 0 ) ; } else { ksft_test_result_skip ( "Clone3() with set_tid requires root\n" ) ; } if ( uid == 0 ) { test_clone3_set_tid ( set_tid , 1 , CLONE_NEWPID , 0 , 0 , 0 ) ; } else { ksft_test_result_skip ( "Clone3() with set_tid requires root\n" ) ; } set_tid [ 0 ] = pid_max ; test_clone3_set_tid ( set_tid , 1 , 0 , - EINVAL , 0 , 0 ) ; if ( uid == 0 ) { test_clone3_set_tid ( set_tid , 1 , CLONE_NEWPID , - EINVAL , 0 , 0 ) ; } else { ksft_test_result_skip ( "Clone3() with set_tid requires root\n" ) ; } if ( uid != 0 ) { ksft_cnt . ksft_xskip += ksft_plan - ksft_test_num ( ) ; out } pid = fork ( ) ; if ( pid == 0 ) { ksft_print_msg ( "Child has PID %d\n" , getpid ( ) ) ; child_exit ( EXIT_SUCCESS ) ; } if ( waitpid ( pid , & status , 0 ) < 0 ) { ksft_exit_fail_msg ( "Waiting for child %d failed" , pid ) ; } set_tid [ 0 ] = pid ; test_clone3_set_tid ( set_tid , 1 , 0 , 0 , 0 , 0 ) ; test_clone3_set_tid ( set_tid , 1 , CLONE_NEWPID , - EINVAL , 0 , 0 ) ; set_tid [ 0 ] = 1 ; set_tid [ 1 ] = pid ; test_clone3_set_tid ( set_tid , 2 , CLONE_NEWPID , 0 , pid , 0 ) ; ksft_print_msg ( "unshare PID namespace\n" ) ; if ( unshare ( CLONE_NEWPID ) == - 1 ) { ksft_exit_fail_msg ( "unshare(CLONE_NEWPID) failed: %s\n" , strerror ( errno ) ) ; } set_tid [ 0 ] = pid ; test_clone3_set_tid ( set_tid , 1 , 0 , - EINVAL , 0 , 0 ) ; ns_pid = fork ( ) ; if ( ns_pid == 0 ) { set_tid [ 0 ] = 43 ; set_tid [ 1 ] = - 1 ; test_clone3_set_tid ( set_tid , 2 , 0 , - EINVAL , 0 , 0 ) ; set_tid [ 0 ] = 43 ; set_tid [ 1 ] = pid ; test_clone3_set_tid ( set_tid , 2 , 0 , 0 , 43 , 0 ) ; ksft_print_msg ( "Child in PID namespace has PID %d\n" , getpid ( ) ) ; set_tid [ 0 ] = 2 ; test_clone3_set_tid ( set_tid , 1 , 0 , 0 , 2 , 0 ) ; set_tid [ 0 ] = 1 ; set_tid [ 1 ] = - 1 ; set_tid [ 2 ] = pid ; test_clone3_set_tid ( set_tid , 3 , CLONE_NEWPID , - EINVAL , 0 , 0 ) ; set_tid [ 0 ] = 1 ; set_tid [ 1 ] = 42 ; set_tid [ 2 ] = pid ; test_clone3_set_tid ( set_tid , 4 , CLONE_NEWPID , - EINVAL , 0 , 0 ) ; test_clone3_set_tid ( set_tid , 3 , CLONE_NEWPID , 0 , 42 , true ) ; child_exit ( ksft_cnt . ksft_fail ) ; } close ( pipe_1 [ 1 ] ) ; close ( pipe_2 [ 0 ] ) ; while ( read ( pipe_1 [ 0 ] , & buf , 1 ) > 0 ) { ksft_print_msg ( "[%d] Child is ready and waiting\n" , getpid ( ) ) ; break ; } snprintf ( proc_path , sizeof ( proc_path ) , "/proc/%d/status" , pid ) ; f = fopen ( proc_path , "r" ) ; if ( f == NULL ) { ksft_exit_fail_msg ( "%s - Could not open %s\n" , strerror ( errno ) , proc_path ) ; } while ( getline ( & line , & len , f ) != - 1 ) { if ( strstr ( line , "NSpid" ) ) { int i ; i = sscanf ( line , "NSpid:\t%d\t%d\t%d" , & ns3 , & ns2 , & ns1 ) ; if ( i != 3 ) { ksft_print_msg ( "Unexpected 'NSPid:' entry: %s" , line ) ; ns1 = ns2 = ns3 = 0 ; } break ; } } fclose ( f ) ; free ( line ) ; close ( pipe_2 [ 0 ] ) ; write ( pipe_2 [ 1 ] , & buf , 1 ) ; close ( pipe_2 [ 1 ] ) ; if ( waitpid ( ns_pid , & status , 0 ) < 0 ) { ksft_print_msg ( "Child returned %s\n" , strerror ( errno ) ) ; ret = - errno ; out } if ( ! WIFEXITED ( status ) ) { ksft_test_result_fail ( "Child error\n" ) ; } ksft_cnt . ksft_pass += 6 - ( ksft_cnt . ksft_fail - WEXITSTATUS ( status ) ) ; ksft_cnt . ksft_fail = WEXITSTATUS ( status ) ; if ( ns3 == pid && ns2 == 42 && ns1 == 1 ) { ksft_test_result_pass ( "PIDs in all namespaces as expected (%d,%d,%d)\n" , ns3 , ns2 , ns1 ) ; } else { ksft_test_result_fail ( "PIDs in all namespaces not as expected (%d,%d,%d)\n" , ns3 , ns2 , ns1 ) ; } out ret = 0 ; return ! ret ?ksft_exit_pass ( ) : ksft_exit_fail ( ) ; } 