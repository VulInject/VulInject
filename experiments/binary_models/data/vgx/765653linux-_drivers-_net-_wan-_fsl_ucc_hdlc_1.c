static int uhdlc_resume ( struct device * dev ) { struct ucc_hdlc_private * priv = dev_get_drvdata ( dev ) ; struct ucc_tdm * utdm ; struct ucc_tdm_info * ut_info ; struct ucc_fast __iomem * uf_regs ; struct ucc_fast_private * uccf ; struct ucc_fast_info * uf_info ; int i ; u32 cecr_subblock ; u16 bd_status ; if ( ! priv ) { return - EINVAL ; } if ( ! netif_running ( priv -> ndev ) ) { return 0 ; } utdm = priv -> utdm ; ut_info = priv -> ut_info ; uf_info = & ut_info -> uf_info ; uf_regs = priv -> uf_regs ; uccf = priv -> uccf ; iowrite8 ( priv -> guemr , & uf_regs -> guemr ) ; iowrite32be ( priv -> gumr , & uf_regs -> gumr ) ; iowrite16be ( uf_info -> urfs , & uf_regs -> urfs ) ; iowrite16be ( uf_info -> urfet , & uf_regs -> urfet ) ; iowrite16be ( uf_info -> urfset , & uf_regs -> urfset ) ; iowrite16be ( uf_info -> utfs , & uf_regs -> utfs ) ; iowrite16be ( uf_info -> utfet , & uf_regs -> utfet ) ; iowrite16be ( uf_info -> utftt , & uf_regs -> utftt ) ; iowrite32be ( uccf -> ucc_fast_tx_virtual_fifo_base_offset , & uf_regs -> utfb ) ; iowrite32be ( uccf -> ucc_fast_rx_virtual_fifo_base_offset , & uf_regs -> urfb ) ; resume_clk_config ( priv ) ; iowrite32be ( uf_info -> uccm_mask , & uf_regs -> uccm ) ; iowrite32be ( 0xffffffff , & uf_regs -> ucce ) ; ucc_fast_disable ( priv -> uccf , COMM_DIR_RX | COMM_DIR_TX ) ; if ( priv -> tsa ) { ucc_tdm_init ( priv -> utdm , priv -> ut_info ) ; } cecr_subblock = ucc_fast_get_qe_cr_subblock ( uf_info -> ucc_num ) ; qe_issue_cmd ( QE_STOP_TX , cecr_subblock , ( u8 ) QE_CR_PROTOCOL_UNSPECIFIED , 0 ) ; iowrite32be ( 0 , & uf_regs -> upsmr ) ; cecr_subblock = ucc_fast_get_qe_cr_subblock ( uf_info -> ucc_num ) ; qe_issue_cmd ( QE_ASSIGN_PAGE_TO_DEVICE , cecr_subblock , QE_CR_PROTOCOL_UNSPECIFIED , priv -> ucc_pram_offset ) ; priv -> ucc_pram = ( ucc_hdlc_param __iomem * ) qe_muram_addr ( priv -> ucc_pram_offset ) ; memcpy_toio ( priv -> ucc_pram , priv -> ucc_pram_bak , sizeof ( ucc_hdlc_param ) ) ; for ( i = 0 ; i < RX_BD_RING_LEN ; i ++ ) { if ( i < ( RX_BD_RING_LEN - 1 ) ) { bd_status = R_E_S | R_I_S ; } else { bd_status = R_E_S | R_I_S | R_W_S ; } priv -> rx_bd_base [ i ] . status = cpu_to_be16 ( bd_status ) ; priv -> rx_bd_base [ i ] . buf = cpu_to_be32 ( priv -> dma_rx_addr + i * MAX_RX_BUF_LENGTH ) ; } for ( i = 0 ; i < TX_BD_RING_LEN ; i ++ ) { if ( i < ( TX_BD_RING_LEN - 1 ) ) { bd_status = T_I_S | T_TC_S ; } else { bd_status = T_I_S | T_TC_S | T_W_S ; } priv -> tx_bd_base [ i ] . status = cpu_to_be16 ( bd_status ) ; priv -> tx_bd_base [ i ] . buf = cpu_to_be32 ( priv -> dma_tx_addr + i * MAX_RX_BUF_LENGTH ) ; } dma_wmb ( ) ; if ( priv -> hdlc_busy == 1 ) { cecr_subblock = ucc_fast_get_qe_cr_subblock ( priv -> ut_info -> uf_info . ucc_num ) ; qe_issue_cmd ( QE_INIT_TX_RX , cecr_subblock , ( u8 ) QE_CR_PROTOCOL_UNSPECIFIED , 0 ) ; ucc_fast_enable ( priv -> uccf , COMM_DIR_RX | COMM_DIR_TX ) ; if ( priv -> tsa ) { qe_setbits_8 ( & utdm -> si_regs -> siglmr1_h , 0x1 << utdm -> tdm_port ) ; } } napi_enable ( & priv -> napi ) ; netif_device_attach ( priv -> ndev ) ; return 0 ; } 