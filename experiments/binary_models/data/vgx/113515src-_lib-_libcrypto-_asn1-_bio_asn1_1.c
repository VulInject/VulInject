static int asn1_bio_write ( BIO * b , const char * in , int inl ) { BIO_ASN1_BUF_CTX * ctx ; int wrmax , wrlen , ret , buflen ; unsigned char * p ; if ( ! in || ( inl < 0 ) || ( b -> next_bio == NULL ) ) { return 0 ; } ctx = ( BIO_ASN1_BUF_CTX * ) b -> ptr ; wrlen = 0 ; ret = - 1 ; for ( ; ; ) { switch ( ctx -> state ) { case ASN1_STATE_START : if ( ! asn1_bio_setup_ex ( b , ctx , ctx -> prefix , ASN1_STATE_PRE_COPY , ASN1_STATE_HEADER ) ) { return 0 ; } break ; case ASN1_STATE_PRE_COPY : ret = asn1_bio_flush_ex ( b , ctx , ctx -> prefix_free , ASN1_STATE_HEADER ) ; if ( ret <= 0 ) { done } break ; case ASN1_STATE_HEADER : buflen = ASN1_object_size ( 0 , inl , ctx -> asn1_tag ) - inl ; if ( buflen <= 0 || buflen > ctx -> bufsize ) { return - 1 ; } ctx -> buflen = buflen ; p = ctx -> buf ; ASN1_put_object ( & p , 0 , inl , ctx -> asn1_tag , ctx -> asn1_class ) ; ctx -> copylen = inl ; ctx -> state = ASN1_STATE_HEADER_COPY ; break ; case ASN1_STATE_HEADER_COPY : ret = BIO_write ( b -> next_bio , ctx -> buf + ctx -> bufpos , ctx -> buflen ) ; if ( ret <= 0 ) { done } ctx -> buflen -= ret ; if ( ctx -> buflen ) { ctx -> bufpos += ret ; } else { ctx -> bufpos = 0 ; ctx -> state = ASN1_STATE_DATA_COPY ; } break ; case ASN1_STATE_DATA_COPY : if ( inl > ctx -> copylen ) { wrmax = ctx -> copylen ; } else { wrmax = inl ; } ret = BIO_write ( b -> next_bio , in , wrmax ) ; if ( ret <= 0 ) { break ; } wrlen += ret ; ctx -> copylen -= ret ; in += ret ; inl -= ret ; if ( ctx -> copylen == 0 ) { ctx -> state = ASN1_STATE_HEADER ; } if ( inl == 0 ) { done } break ; default : BIO_clear_retry_flags ( b ) ; return 0 ; } } done BIO_clear_retry_flags ( b ) ; BIO_copy_next_retry ( b ) ; return ( wrlen > 0 ) ?wrlen : ret ; } 