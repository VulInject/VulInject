static RAnalBaseType * get_union_type ( RAnal * anal , const char * sname ) { r_return_val_if_fail ( anal && sname , NULL ) ; RAnalBaseType * base_type = r_anal_base_type_new ( R_ANAL_BASE_TYPE_KIND_UNION ) ; if ( ! base_type ) { return in ; } char * sdb_members = get_type_data ( anal -> sdb_types , "union" , sname ) ; if ( ! sdb_members ) { error } RVector * members = & base_type -> union_data . members ; if ( ! r_vector_reserve ( members , ( size_t ) sdb_alen ( sdb_members ) ) ) { error } char * cur ; sdb_aforeach ( , ) { char * type_key = r_str_newf ( "union.%s.%s" , sname , cur ) ; if ( ! type_key ) { error } char * values = sdb_get ( anal -> sdb_types , type_key , NULL ) ; free ( type_key ) ; if ( ! values ) { error } char * value = sdb_anext ( values , NULL ) ; RAnalUnionMember cas = { . name = strdup ( cur ) . type = strdup ( ) } ; free ( values ) ; void * element = r_vector_push ( members , & cas ) ; if ( ! element ) { error } sdb_aforeach_next ( cur ) ; } free ( sdb_members ) ; return base_type ; error r_anal_base_type_free ( base_type ) ; free ( sdb_members ) ; return NULL ; } 