int get_vfs_caps_from_disk ( struct mnt_idmap * idmap , const struct dentry * dentry , struct cpu_vfs_cap_data * cpu_caps ) { struct inode * inode = d_backing_inode ( dentry ) ; __u32 magic_etc ; unsigned tocopy , i ; int size ; struct vfs_ns_cap_data data , * nscaps = & data ; struct vfs_cap_data * caps = ( vfs_cap_data * ) & data ; kuid_t rootkuid ; vfsuid_t rootvfsuid ; struct user_namespace * fs_ns ; if ( ! inode ) { return - ENODATA ; } fs_ns = inode -> i_sb -> s_user_ns ; size = __vfs_getxattr ( ( dentry * ) dentry , inode , XATTR_NAME_CAPS , & data , XATTR_CAPS_SZ ) ; if ( size == - ENODATA || size == - EOPNOTSUPP ) { return - ENODATA ; } if ( size < 0 ) { return size ; } if ( size < sizeof ( magic_etc ) ) { return - EINVAL ; } cpu_caps -> magic_etc = magic_etc = le32_to_cpu ( caps -> magic_etc ) ; rootkuid = make_kuid ( fs_ns , 0 ) ; switch ( magic_etc & VFS_CAP_REVISION_MASK ) { case VFS_CAP_REVISION_1 : if ( size != XATTR_CAPS_SZ_1 ) { return - EINVAL ; } tocopy = VFS_CAP_U32_1 ; break ; case VFS_CAP_REVISION_2 : if ( size != XATTR_CAPS_SZ_2 ) { return - EINVAL ; } tocopy = VFS_CAP_U32_2 ; break ; case VFS_CAP_REVISION_3 : if ( size != XATTR_CAPS_SZ_3 ) { return - EINVAL ; } tocopy = VFS_CAP_U32_3 ; rootkuid = make_kuid ( fs_ns , le32_to_cpu ( nscaps -> rootid ) ) ; break ; default : return - EINVAL ; } rootvfsuid = make_vfsuid ( idmap , fs_ns , rootkuid ) ; if ( ! vfsuid_valid ( rootvfsuid ) ) { return - ENODATA ; } if ( ! rootid_owns_currentns ( rootvfsuid ) ) { return - ENODATA ; } CAP_FOR_EACH_U32 ( ) { if ( i >= tocopy ) { break ; } cpu_caps -> permitted . cap [ i ] = le32_to_cpu ( caps -> data [ i ] . permitted ) ; cpu_caps -> inheritable . cap [ i ] = le32_to_cpu ( caps -> data [ i ] . inheritable ) ; } cpu_caps -> permitted . cap [ CAP_LAST_U32 ] &= CAP_LAST_U32_VALID_MASK ; cpu_caps -> inheritable . cap [ CAP_LAST_U32 ] &= CAP_LAST_U32_VALID_MASK ; cpu_caps -> rootid = vfsuid_into_kuid ( rootvfsuid ) ; return 0 ; } 