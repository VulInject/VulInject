int mwifiex_set_hs_params ( struct mwifiex_private * priv , u16 action , int cmd_type , struct mwifiex_ds_hs_cfg * hs_cfg ) { struct mwifiex_adapter * adapter = priv -> adapter ; int status = 0 ; u32 prev_cond = 0 ; switch ( action ) { case HostCmd_ACT_GEN_SET : if ( adapter -> pps_uapsd_mode ) { mwifiex_dbg ( adapter , INFO , "info: Host Sleep IOCTL\t" "is blocked in UAPSD/PPS mode\n" ) ; status = - 1 ; break ; } if ( hs_cfg -> is_invoke_hostcmd ) { if ( hs_cfg -> conditions == HS_CFG_CANCEL ) { if ( ! test_bit ( MWIFIEX_IS_HS_CONFIGURED , & adapter -> work_flags ) ) { break ; } prev_cond = le32_to_cpu ( adapter -> hs_cfg . conditions ) ; adapter -> hs_cfg . conditions = cpu_to_le32 ( hs_cfg -> conditions ) ; } if ( hs_cfg -> conditions ) { adapter -> hs_cfg . conditions = cpu_to_le32 ( hs_cfg -> conditions ) ; adapter -> hs_cfg . gpio = ( u8 ) hs_cfg -> gpio ; if ( hs_cfg -> gap ) { adapter -> hs_cfg . gap = ( u8 ) hs_cfg -> gap ; } } if ( adapter -> hs_cfg . conditions == cpu_to_le32 ( HS_CFG_CANCEL ) ) { status = - 1 ; break ; } status = mwifiex_send_cmd ( priv , HostCmd_CMD_802_11_HS_CFG_ENH , HostCmd_ACT_GEN_SET , 0 , & adapter -> hs_cfg , cmd_type == MWIFIEX_SYNC_CMD ) ; if ( hs_cfg -> conditions == HS_CFG_CANCEL ) { adapter -> hs_cfg . conditions = cpu_to_le32 ( prev_cond ) ; } } else { adapter -> hs_cfg . conditions = cpu_to_le32 ( hs_cfg -> conditions ) ; adapter -> hs_cfg . gpio = ( u8 ) hs_cfg -> gpio ; adapter -> hs_cfg . gap = ( u8 ) hs_cfg -> gap ; } break ; case HostCmd_ACT_GEN_GET : hs_cfg -> conditions = le32_to_cpu ( adapter -> hs_cfg . conditions ) ; hs_cfg -> gpio = adapter -> hs_cfg . gpio ; hs_cfg -> gap = adapter -> hs_cfg . gap ; break ; default : status = - 1 ; break ; } return status ; } 