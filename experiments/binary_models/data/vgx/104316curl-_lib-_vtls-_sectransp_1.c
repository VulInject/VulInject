static CURLcode pkp_pin_peer_pubkey ( struct Curl_easy * data , SSLContextRef ctx , const char * pinnedpubkey ) { size_t pubkeylen , realpubkeylen , spkiHeaderLength = 24 ; unsigned char * pubkey = NULL , * realpubkey = NULL ; const unsigned char * spkiHeader = NULL ; CFDataRef publicKeyBits = NULL ; CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH ; if ( ! ctx ) { return result ; } { SecTrustRef trust ; OSStatus ret ; SecKeyRef keyRef ; OSStatus success ; ret = SSLCopyPeerTrust ( ctx , & trust ) ; if ( ret != noErr || ! trust ) { break ; } keyRef = SecTrustCopyPublicKey ( trust ) ; CFRelease ( trust ) ; if ( ! keyRef ) { break ; } publicKeyBits = SecKeyCopyExternalRepresentation ( keyRef , NULL ) ; CFRelease ( keyRef ) ; if ( ! publicKeyBits ) { break ; } success = SecItemExport ( keyRef , kSecFormatOpenSSL , 0 , NULL , & publicKeyBits ) ; CFRelease ( keyRef ) ; if ( success != errSecSuccess || ! publicKeyBits ) { break ; } pubkeylen = CFDataGetLength ( publicKeyBits ) ; pubkey = ( unsigned char * ) CFDataGetBytePtr ( publicKeyBits ) ; switch ( pubkeylen ) { case 526 : spkiHeader = rsa4096SpkiHeader ; break ; case 270 : spkiHeader = rsa2048SpkiHeader ; break ; case 65 : spkiHeader = ecDsaSecp256r1SpkiHeader ; spkiHeaderLength = 26 ; break ; case 97 : spkiHeader = ecDsaSecp384r1SpkiHeader ; spkiHeaderLength = 23 ; break ; default : infof ( data , "SSL: unhandled public key length: %d" , pubkeylen ) ; default : result = Curl_pin_peer_pubkey ( data , pinnedpubkey , pubkey , pubkeylen ) ; continue ; } realpubkeylen = pubkeylen + spkiHeaderLength ; realpubkey = malloc ( realpubkeylen ) ; if ( ! realpubkey ) { break ; } memcpy ( realpubkey , spkiHeader , spkiHeaderLength ) ; memcpy ( realpubkey + spkiHeaderLength , pubkey , pubkeylen ) ; result = Curl_pin_peer_pubkey ( data , pinnedpubkey , realpubkey , realpubkeylen ) ; } 0 ; Curl_safefree ( realpubkey ) ; if ( publicKeyBits ) { CFRelease ( publicKeyBits ) ; } return result ; } 