static int cmd_changestate ( int argc , char * argv [ ] , const char * usage_str ) { hp_node_t root ; hp_node_t results = NULL ; char * path = NULL ; char * connection = NULL ; int state = - 1 ; int flags = 0 ; int opt , rv ; parse_common ( argc , argv , usage_str ) ; while ( ( opt = getopt_clip ( argc , argv , "fqs:" , changestate_opts , NULL ) ) != - 1 ) { switch ( opt ) { case 'f' : flags |= HPFORCE ; break ; case 'q' : flags |= HPQUERY ; break ; case 's' : if ( ( state = state_atoi ( optarg ) ) == - 1 ) { ( void ) printf ( "ERROR: invalid target state\n" ) ; return ( EINVAL ) ; } break ; default : bad_option ( opt , optopt , usage_str ) ; break ; } } parse_target ( argc , argv , & path , & connection , usage_str ) ; if ( ( state == - 1 ) || ( path == NULL ) || ( connection == NULL ) ) { ( void ) fprintf ( stderr , gettext ( "ERROR: too few arguments.\n" ) ) ; usage ( usage_str ) ; return ( EINVAL ) ; } if ( valid_target ( state ) == 0 ) { ( void ) fprintf ( stderr , gettext ( "ERROR: invalid target state\n" ) ) ; return ( EINVAL ) ; } if ( ( root = hp_init ( path , connection , 0 ) ) == NULL ) { print_error ( errno , NULL ) ; return ( errno ) ; } rv = hp_set_state ( root , flags , state , & results ) ; print_error ( rv ) ; if ( results ) { ( void ) hp_traverse ( results , NULL , error_cb ) ; hp_fini ( results ) ; } hp_fini ( root ) ; return ( rv ) ; } 