static int intbufs_set_buffer ( struct venus_inst * inst , u32 type ) { struct venus_core * core = inst -> core ; struct device * dev = core -> dev ; struct hfi_buffer_requirements bufreq ; struct hfi_buffer_desc bd ; struct intbuf * buf ; unsigned int i ; int ret ; ret = venus_helper_get_bufreq ( inst , type , & bufreq ) ; if ( ret ) { return 0 ; } if ( ! bufreq . size ) { return 0 ; } for ( i = 0 ; i < bufreq . count_actual ; i ++ ) { buf = kzalloc ( sizeof ( * buf ) , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; fail } buf -> type = bufreq . type ; buf -> size = bufreq . size ; buf -> attrs = DMA_ATTR_WRITE_COMBINE | DMA_ATTR_NO_KERNEL_MAPPING ; buf -> va = dma_alloc_attrs ( dev , buf -> size , & buf -> da , GFP_KERNEL , buf -> attrs ) ; if ( ! buf -> va ) { ret = - ENOMEM ; fail } bd . buffer_size = buf -> size ; bd . buffer_type = buf -> type ; bd . num_buffers = 1 ; bd . device_addr = buf -> da ; ret = hfi_session_set_buffers ( inst , & bd ) ; if ( ret ) { dev_err ( dev , "set session buffers failed\n" ) ; dma_free } list_add_tail ( & buf -> list , & inst -> internalbufs ) ; } return 0 ; dma_free dma_free_attrs ( dev , buf -> size , buf -> va , buf -> da , buf -> attrs ) ; fail kfree ( buf ) ; return ret ; } 