static int pic32_pinconf_set ( struct pinctrl_dev * pctldev , unsigned pin , unsigned long * configs , unsigned num_configs ) { struct pic32_pinctrl * pctl = pinctrl_dev_get_drvdata ( pctldev ) ; struct pic32_gpio_bank * bank = pctl_to_bank ( pctl , pin ) ; unsigned param ; u32 arg ; int i ; u32 offset = pin - bank -> gpio_chip . base ; u32 mask = BIT ( offset ) ; dev_dbg ( pctl -> dev , "setting pin %d bank %d mask 0x%x\n" , pin , bank -> gpio_chip . base , mask ) ; for ( i = 0 ; i < num_configs ; i ++ ) { param = pinconf_to_config_param ( configs [ i ] ) ; arg = pinconf_to_config_argument ( configs [ i ] ) ; switch ( param ) { case PIN_CONFIG_BIAS_PULL_UP : dev_dbg ( pctl -> dev , "   pullup\n" ) ; writel ( mask , bank -> reg_base + PIC32_SET ( CNPU_REG ) ) ; break ; case PIN_CONFIG_BIAS_PULL_DOWN : dev_dbg ( pctl -> dev , "   pulldown\n" ) ; writel ( mask , bank -> reg_base + PIC32_SET ( CNPD_REG ) ) ; break ; case PIN_CONFIG_MICROCHIP_DIGITAL : dev_dbg ( pctl -> dev , "   digital\n" ) ; writel ( mask , bank -> reg_base + PIC32_CLR ( ANSEL_REG ) ) ; break ; case PIN_CONFIG_MICROCHIP_ANALOG : dev_dbg ( pctl -> dev , "   analog\n" ) ; writel ( mask , bank -> reg_base + PIC32_SET ( ANSEL_REG ) ) ; break ; case PIN_CONFIG_DRIVE_OPEN_DRAIN : dev_dbg ( pctl -> dev , "   opendrain\n" ) ; writel ( mask , bank -> reg_base + PIC32_SET ( ODCU_REG ) ) ; break ; case PIN_CONFIG_INPUT_ENABLE : pic32_gpio_direction_input ( & bank -> gpio_chip , offset ) ; break ; case PIN_CONFIG_OUTPUT : pic32_gpio_direction_output ( & bank -> gpio_chip , offset , arg ) ; break ; default : dev_err ( pctl -> dev , "Property %u not supported\n" , param ) ; return - ENOTSUPP ; } } return 0 ; } 