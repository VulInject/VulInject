static void inf_xmpp_connection_process_features ( InfXmppConnection * xmpp , xmlNodePtr xml ) { InfXmppConnectionPrivate * priv ; xmlNodePtr child ; xmlNodePtr req ; xmlNodePtr starttls ; const char * suggestion ; GError * error ; priv = INF_XMPP_CONNECTION_PRIVATE ( xmpp ) ; g_assert ( priv -> site == INF_XMPP_CONNECTION_CLIENT ) ; g_assert ( priv -> status == INF_XMPP_CONNECTION_AWAITING_FEATURES || priv -> status == INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES ) ; if ( strcmp ( ( const gchar * ) xml -> name , "stream:features" ) != 0 ) { return ; } if ( priv -> status == INF_XMPP_CONNECTION_AWAITING_FEATURES && priv -> session == NULL ) { for ( child = xml -> children ; child != NULL ; child = child -> next ) { if ( strcmp ( ( const gchar * ) child -> name , "starttls" ) == 0 ) { break ; } } if ( child == NULL && priv -> security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_TLS ) { error = g_error_new_literal ( inf_xmpp_connection_error_quark ( ) , INF_XMPP_CONNECTION_ERROR_TLS_UNSUPPORTED , _ ( "The server does not support transport layer security (TLS)" ) ) ; inf_xml_connection_error ( INF_XML_CONNECTION ( xmpp ) , error ) ; g_error_free ( error ) ; inf_xmpp_connection_deinitiate ( xmpp ) ; } if ( child != NULL ) { for ( req = child -> children ; req != NULL ; req = req -> next ) { if ( strcmp ( ( const gchar * ) req -> name , "required" ) == 0 ) { break ; } } if ( req != NULL && priv -> security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED ) { g_set_error_literal ( & error , inf_xmpp_connection_error_quark ( ) , INF_XMPP_CONNECTION_ERROR_TLS_REQUIRED , _ ( "The server requires transport layer security (TLS)" ) ) ; inf_xml_connection_error ( INF_XML_CONNECTION ( xmpp ) , error ) ; g_error_free ( error ) ; inf_xmpp_connection_deinitiate ( xmpp ) ; } if ( req != NULL || inf_xmpp_connection_prefers_tls ( xmpp ) ) { starttls = inf_xmpp_connection_node_new_tls ( "starttls" ) ; inf_xmpp_connection_send_xml ( xmpp , starttls ) ; xmlFreeNode ( starttls ) ; priv -> status = INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED ; } } } if ( priv -> status == INF_XMPP_CONNECTION_AWAITING_FEATURES ) { for ( child = xml -> children ; child != NULL ; child = child -> next ) { if ( strcmp ( ( const gchar * ) child -> name , "mechanisms" ) == 0 ) { break ; } } if ( child == NULL ) { error = g_error_new_literal ( inf_xmpp_connection_error_quark ( ) , INF_XMPP_CONNECTION_ERROR_AUTHENTICATION_UNSUPPORTED , _ ( "The server does not provide any authentication mechanism" ) ) ; inf_xml_connection_error ( INF_XML_CONNECTION ( xmpp ) , error ) ; g_error_free ( error ) ; inf_xmpp_connection_deinitiate ( xmpp ) ; } if ( inf_xmpp_connection_sasl_ensure ( xmpp ) == TRUE ) { inf_xmpp_connection_load_sasl_remote_mechanisms ( xmpp , child ) ; error = NULL ; suggestion = inf_xmpp_connection_sasl_suggest_mechanism ( xmpp , & error ) ; if ( ! suggestion ) { inf_xml_connection_error ( INF_XML_CONNECTION ( xmpp ) , error ) ; g_error_free ( error ) ; if ( priv -> status == INF_XMPP_CONNECTION_AWAITING_FEATURES ) { inf_xmpp_connection_deinitiate ( xmpp ) ; } } else { inf_xmpp_connection_sasl_init ( xmpp , suggestion ) ; } } } if ( priv -> status == INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES ) { priv -> status = INF_XMPP_CONNECTION_READY ; g_object_notify ( G_OBJECT ( xmpp ) , "status" ) ; } } 