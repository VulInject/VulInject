static void __init setup_real_mode ( void ) { u16 real_mode_seg ; const u32 * rel ; u32 count ; unsigned char * base ; unsigned long phys_base ; struct trampoline_header * trampoline_header ; size_t size = PAGE_ALIGN ( real_mode_blob_end - real_mode_blob ) ; u64 * trampoline_pgd ; u64 efer ; int i ; base = ( unsigned char * ) real_mode_header ; if ( cc_platform_has ( CC_ATTR_HOST_MEM_ENCRYPT ) ) { set_memory_decrypted ( ( unsigned long ) base , size >> PAGE_SHIFT ) ; } memcpy ( base , real_mode_blob , size ) ; phys_base = __pa ( base ) ; real_mode_seg = phys_base >> 4 ; rel = ( u32 * ) real_mode_relocs ; count = * rel ++ ; while ( count -- ) { u16 * seg = ( u16 * ) ( base + * rel ++ ) ; * seg = real_mode_seg ; } count = * rel ++ ; while ( count -- ) { u32 * ptr = ( u32 * ) ( base + * rel ++ ) ; * ptr += phys_base ; } trampoline_header = ( trampoline_header * ) __va ( real_mode_header -> trampoline_header ) ; trampoline_header -> start = __pa_symbol ( startup_32_smp ) ; trampoline_header -> gdt_limit = __BOOT_DS + 7 ; trampoline_header -> gdt_base = __pa_symbol ( boot_gdt ) ; rdmsrl ( MSR_EFER , efer ) ; trampoline_header -> efer = efer & ~ EFER_LMA ; trampoline_header -> start = ( u64 ) secondary_startup_64 ; trampoline_cr4_features = & trampoline_header -> cr4 ; * trampoline_cr4_features = mmu_cr4_features ; trampoline_header -> flags = 0 ; trampoline_pgd = ( u64 * ) __va ( real_mode_header -> trampoline_pgd ) ; trampoline_pgd [ 0 ] = trampoline_pgd_entry . pgd ; for ( i = pgd_index ( __PAGE_OFFSET ) ; i < PTRS_PER_PGD ; i ++ ) { trampoline_pgd [ i ] = init_top_pgt [ i ] . pgd ; } sme_sev_setup_real_mode ( trampoline_header , NULL ) ; } 