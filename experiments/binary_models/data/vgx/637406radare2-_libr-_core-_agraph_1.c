static int agraph_refresh ( struct agraph_refresh_data * grd ) { if ( ! grd ) { return 0 ; } r_cons_singleton ( ) -> event_data = grd ; RCore * core = grd -> core ; RAGraph * g = grd -> g ; RAnalFunction * f = NULL ; RAnalFunction * * fcn = grd -> fcn ; if ( ! fcn ) { return agraph_print ( g , grd -> fs , core , NULL ) ; } if ( g -> is_instep && r_config_get_b ( core -> config , "cfg.debug" ) ) { const char * pc = r_reg_get_name ( core -> dbg -> reg , R_REG_NAME_PC ) ; ut64 addr = r_reg_getv ( core -> dbg -> reg , pc ) ; RANode * acur = get_anode ( g -> curnode ) ; addr = r_anal_get_bbaddr ( core -> anal , addr ) ; char * title = get_title ( addr ) ; if ( ! acur || strcmp ( acur -> title , title ) ) { r_core_cmd0 ( core , "sr PC" ) ; } g -> is_instep = false ; } if ( grd -> follow_offset ) { if ( r_io_is_valid_offset ( core -> io , core -> offset , 0 ) ) { f = r_anal_get_fcn_in ( core -> anal , core -> offset , 0 ) ; if ( ! f ) { if ( ! g -> is_dis ) { if ( ! r_cons_yesno ( 'y' , "\rNo function at 0x%08" PFMT64x ". Define it here (Y/n)? " , core -> offset ) ) { return 0 ; } r_core_cmd0 ( core , "af" ) ; } f = r_anal_get_fcn_in ( core -> anal , core -> offset , 0 ) ; g -> need_reload_nodes = true ; } if ( f && fcn && f != * fcn ) { * fcn = f ; check_function_modified ( core , * fcn ) ; g -> need_reload_nodes = true ; g -> force_update_seek = true ; } } else { r_cons_message ( "This is not a valid offset\n" ) ; r_cons_flush ( ) ; } } int res = agraph_print ( g , grd -> fs , core , * fcn ) ; if ( r_config_get_b ( core -> config , "scr.scrollbar" ) ) { r_core_print_scrollbar ( core ) ; } return res ; } 