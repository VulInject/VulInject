static struct resolve_request * resolve_find_or_new__ ( const char * name ) OVS_REQUIRES ( dns_mutex__ ) ; static bool resolve_check_expire__ ( resolve_request * req ) OVS_REQUIRES ( dns_mutex__ ) ; static bool resolve_check_valid__ ( resolve_request * req ) OVS_REQUIRES ( dns_mutex__ ) ; static bool resolve_async__ ( resolve_request * req , int qtype ) OVS_REQUIRES ( dns_mutex__ ) ; static void resolve_callback__ ( void * req , int err , ub_result * ) OVS_REQUIRES ( dns_mutex__ ) ; static bool resolve_result_to_addr__ ( struct ub_result * result , char * * addr ) static bool dns_resolve_sync__ ( const char * name , char * * addr ) void dns_resolve_init ( bool is_daemon ) { ub_ctx__ = ub_ctx_create ( ) ; if ( ub_ctx__ == NULL ) { VLOG_ERR_RL ( & rl , "Failed to create libunbound context, " "so asynchronous DNS resolving is disabled." ) ; return ; } const char * ub_conf_filename = getenv ( "OVS_UNBOUND_CONF" ) ; if ( ub_conf_filename != NULL ) { int retval = ub_ctx_config ( ub_ctx__ , ub_conf_filename ) ; if ( retval != 0 ) { VLOG_WARN_RL ( & rl , "Failed to set libunbound context config: %s" , ub_strerror ( retval ) ) ; ub_ctx_delete ( ub_ctx__ , NULL ) ; ub_ctx__ = NULL ; return ; } } const char * filename = getenv ( "OVS_RESOLV_CONF" ) ; if ( ! filename ) { filename = "/etc/resolv.conf" ; } struct stat s ; if ( ! filename || ! stat ( filename , & s ) || errno != ENOENT ) { int retval = ub_ctx_resolvconf ( ub_ctx__ , filename ) ; if ( retval != 0 ) { VLOG_WARN_RL ( & rl , "Failed to read %s: %s" , filename ?filename : "system default nameserver" , ub_strerror ( retval ) ) ; ub_ctx_delete ( ub_ctx__ ) ; ub_ctx__ = NULL ; return ; } } else { VLOG_WARN_RL ( & rl , "Failed to read %s: %s" , filename , ovs_strerror ( errno ) ) ; ub_ctx_delete ( ub_ctx__ ) ; ub_ctx__ = NULL ; return ; } int retval = ub_ctx_hosts ( ub_ctx__ , NULL ) ; if ( retval != 0 ) { VLOG_WARN_RL ( & rl , "Failed to read etc/hosts: %s" , ub_strerror ( retval ) ) ; } ub_ctx_async ( ub_ctx__ , true ) ; hmap_init ( & all_reqs__ ) ; thread_is_daemon = is_daemon ; } 