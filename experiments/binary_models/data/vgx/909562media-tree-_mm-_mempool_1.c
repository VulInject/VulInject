( mempool_create_node ) ; int mempool_resize ( mempool_t * pool , int new_min_nr ) { void * element ; void * * new_elements ; unsigned long flags ; BUG_ON ( new_min_nr <= 0 ) ; might_sleep ( ) ; spin_lock_irqsave ( & pool -> lock , flags ) ; if ( new_min_nr <= pool -> min_nr ) { while ( new_min_nr < pool -> curr_nr ) { element = remove_element ( pool , GFP_KERNEL ) ; spin_unlock_irqrestore ( & pool -> lock , flags ) ; pool -> free ( element , pool -> pool_data ) ; spin_lock_irqsave ( & pool -> lock , flags ) ; } pool -> min_nr = new_min_nr ; out_unlock } spin_unlock_irqrestore ( & pool -> lock , flags ) ; new_elements = kmalloc_array ( new_min_nr , sizeof ( * new_elements ) , GFP_KERNEL ) ; if ( ! new_elements ) { return - ENOMEM ; } spin_lock_irqsave ( & pool -> lock , flags ) ; if ( unlikely ( new_min_nr <= pool -> min_nr ) ) { spin_unlock_irqrestore ( & pool -> lock , flags ) ; out } memcpy ( new_elements , pool -> elements , pool -> curr_nr * sizeof ( * new_elements ) ) ; kfree ( pool -> elements ) ; pool -> elements = new_elements ; pool -> min_nr = new_min_nr ; while ( pool -> curr_nr < pool -> min_nr ) { spin_unlock_irqrestore ( & pool -> lock , flags ) ; element = pool -> alloc ( GFP_KERNEL , pool -> pool_data ) ; if ( ! element ) { out } spin_lock_irqsave ( & pool -> lock , flags ) ; if ( pool -> curr_nr < pool -> min_nr ) { add_element ( pool , element ) ; } else { spin_unlock_irqrestore ( & pool -> lock , flags ) ; pool -> free ( element , pool -> pool_data ) ; out } } out_unlock spin_unlock_irqrestore ( & pool -> lock , flags ) ; out return 0 ; } 