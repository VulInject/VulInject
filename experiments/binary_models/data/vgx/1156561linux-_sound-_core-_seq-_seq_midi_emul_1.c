static void nrpn ( const struct snd_midi_op * ops , void * drv , struct snd_midi_channel * chan , struct snd_midi_channel_set * chset ) static void sysex ( const struct snd_midi_op * ops , void * private , unsigned char * sysex , int len , struct snd_midi_channel_set * chset ) static void all_sounds_off ( const struct snd_midi_op * ops , void * private , struct snd_midi_channel * chan ) static void all_notes_off ( const struct snd_midi_op * ops , void * private , struct snd_midi_channel * chan ) static void snd_midi_reset_controllers ( struct snd_midi_channel * chan ) static void reset_all_channels ( struct snd_midi_channel_set * chset ) void snd_midi_process_event ( const struct snd_midi_op * ops , struct snd_seq_event * ev , struct snd_midi_channel_set * chanset ) { struct snd_midi_channel * chan ; void * drv ; int dest_channel = 0 ; if ( ev == NULL || chanset == NULL ) { pr_debug ( "ALSA: seq_midi_emul: ev or chanbase NULL (snd_midi_process_event)\n" ) ; return ; } if ( snd_seq_ev_is_channel_type ( ev ) ) { dest_channel = ev -> data . note . channel ; if ( dest_channel >= chanset -> max_channels ) { pr_debug ( "ALSA: seq_midi_emul: dest channel is %d, max is %d\n" , dest_channel , chanset -> max_channels ) ; return ; } } chan = chanset -> channels + dest_channel ; drv = chanset -> private_data ; if ( ev -> type == SNDRV_SEQ_EVENT_NOTE ) { return ; } if ( ev -> type == SNDRV_SEQ_EVENT_NOTEON && ev -> data . note . velocity == 0 ) { ev -> type = SNDRV_SEQ_EVENT_NOTEOFF ; } if ( ev -> type == SNDRV_SEQ_EVENT_NOTEON || ev -> type == SNDRV_SEQ_EVENT_NOTEOFF || ev -> type == SNDRV_SEQ_EVENT_KEYPRESS ) { if ( ev -> data . note . note >= 128 ) { return ; } } switch ( ev -> type ) { case SNDRV_SEQ_EVENT_NOTEON : if ( chan -> note [ ev -> data . note . note ] & SNDRV_MIDI_NOTE_ON ) { if ( ops -> note_off ) { ops -> note_off ( drv , ev -> data . note . note , 0 , chan ) ; } } chan -> note [ ev -> data . note . note ] = SNDRV_MIDI_NOTE_ON ; if ( ops -> note_on ) { ops -> note_on ( drv , ev -> data . note . note , ev -> data . note . velocity , chan ) ; } break ; case SNDRV_SEQ_EVENT_NOTEOFF : if ( ! ( chan -> note [ ev -> data . note . note ] & SNDRV_MIDI_NOTE_ON ) ) { break ; } if ( ops -> note_off ) { note_off ( ops , drv , chan , ev -> data . note . note , ev -> data . note . velocity ) ; } break ; case SNDRV_SEQ_EVENT_KEYPRESS : if ( ops -> key_press ) { ops -> key_press ( drv , ev -> data . note . note , ev -> data . note . velocity , chan ) ; } break ; case SNDRV_SEQ_EVENT_CONTROLLER : do_control ( ops , drv , chanset , chan , ev -> data . control . param , ev -> data . control . value ) ; break ; case SNDRV_SEQ_EVENT_PGMCHANGE : chan -> midi_program = ev -> data . control . value ; break ; case SNDRV_SEQ_EVENT_PITCHBEND : chan -> midi_pitchbend = ev -> data . control . value ; if ( ops -> control ) { ops -> control ( drv , MIDI_CTL_PITCHBEND , chan ) ; } break ; case SNDRV_SEQ_EVENT_CHANPRESS : chan -> midi_pressure = ev -> data . control . value ; if ( ops -> control ) { ops -> control ( drv , MIDI_CTL_CHAN_PRESSURE , chan ) ; } break ; case SNDRV_SEQ_EVENT_CONTROL14 : if ( ev -> data . control . param < 32 ) { chan -> control [ ev -> data . control . param + 32 ] = ev -> data . control . value & 0x7f ; do_control ( ops , drv , chanset , chan , ev -> data . control . param , ( ( ev -> data . control . value >> 7 ) & 0x7f ) ) ; } else { do_control ( ops , drv , chanset , chan , ev -> data . control . param , ev -> data . control . value ) ; } break ; case SNDRV_SEQ_EVENT_NONREGPARAM : chan -> param_type = SNDRV_MIDI_PARAM_TYPE_NONREGISTERED ; chan -> control [ MIDI_CTL_MSB_DATA_ENTRY ] = ( ev -> data . control . value >> 7 ) & 0x7f ; chan -> control [ MIDI_CTL_LSB_DATA_ENTRY ] = ev -> data . control . value & 0x7f ; chan -> control [ MIDI_CTL_NONREG_PARM_NUM_MSB ] = ( ev -> data . control . param >> 7 ) & 0x7f ; chan -> control [ MIDI_CTL_NONREG_PARM_NUM_LSB ] = ev -> data . control . param & 0x7f ; nrpn ( ops , drv , chan , chanset ) ; break ; case SNDRV_SEQ_EVENT_REGPARAM : chan -> param_type = SNDRV_MIDI_PARAM_TYPE_REGISTERED ; chan -> control [ MIDI_CTL_MSB_DATA_ENTRY ] = ( ev -> data . control . value >> 7 ) & 0x7f ; chan -> control [ MIDI_CTL_LSB_DATA_ENTRY ] = ev -> data . control . value & 0x7f ; chan -> control [ MIDI_CTL_REGIST_PARM_NUM_MSB ] = ( ev -> data . control . param >> 7 ) & 0x7f ; chan -> control [ MIDI_CTL_REGIST_PARM_NUM_LSB ] = ev -> data . control . param & 0x7f ; rpn ( ops , drv , chan , chanset ) ; break ; case SNDRV_SEQ_EVENT_SYSEX : if ( ( ev -> flags & SNDRV_SEQ_EVENT_LENGTH_MASK ) == SNDRV_SEQ_EVENT_LENGTH_VARIABLE ) { unsigned char sysexbuf [ 64 ] ; int len ; len = snd_seq_expand_var_event ( ev , sizeof ( sysexbuf ) , sysexbuf , 1 , 0 ) ; if ( len > 0 ) { sysex ( ops , drv , sysexbuf , len , chanset ) ; } } break ; case SNDRV_SEQ_EVENT_SONGPOS : case SNDRV_SEQ_EVENT_SONGSEL : case SNDRV_SEQ_EVENT_CLOCK : case SNDRV_SEQ_EVENT_START : case SNDRV_SEQ_EVENT_CONTINUE : case SNDRV_SEQ_EVENT_STOP : case SNDRV_SEQ_EVENT_QFRAME : case SNDRV_SEQ_EVENT_TEMPO : case SNDRV_SEQ_EVENT_TIMESIGN : case SNDRV_SEQ_EVENT_KEYSIGN : not_yet case SNDRV_SEQ_EVENT_SENSING : break ; case SNDRV_SEQ_EVENT_CLIENT_START : case SNDRV_SEQ_EVENT_CLIENT_EXIT : case SNDRV_SEQ_EVENT_CLIENT_CHANGE : case SNDRV_SEQ_EVENT_PORT_START : case SNDRV_SEQ_EVENT_PORT_EXIT : case SNDRV_SEQ_EVENT_PORT_CHANGE : case SNDRV_SEQ_EVENT_ECHO : not_yet default : break ; } } 