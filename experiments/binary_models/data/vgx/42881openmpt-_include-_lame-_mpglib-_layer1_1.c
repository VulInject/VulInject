static void I_step_two ( PMPSTR mp , sideinfo_layer_I * si , real fraction [ 2 ] [ SBLIMIT ] ) { double r0 , r1 ; struct frame * fr = & ( mp -> fr ) ; int ds_limit = fr -> down_sample_sblimit ; int i ; assert ( fr -> stereo == 1 || fr -> stereo == 2 ) ; if ( fr -> stereo == 2 ) { int jsbound = ( fr -> mode == MPG_MD_JOINT_STEREO ) ?( fr -> mode_ext << 2 ) + 4 : 32 ; for ( i = 0 ; i < jsbound ; i ++ ) { int i0 = si -> scalefactor [ i ] [ 0 ] ; unsigned char i1 = si -> scalefactor [ i ] [ 1 ] ; unsigned char n0 = si -> allocation [ i ] [ 0 ] ; unsigned char n1 = si -> allocation [ i ] [ 1 ] ; assert ( i0 < 64 ) ; assert ( i1 < 64 ) ; assert ( n0 < 16 ) ; assert ( n1 < 16 ) ; if ( n0 > 0 ) { unsigned short v = get_leq_16_bits ( mp , n0 + 1 ) ; r0 = ( ( ( - 1 ) << n0 ) + v + 1 ) * muls [ n0 + 1 ] [ i0 ] ; } else { r0 = 0 ; } if ( n1 > 0 ) { unsigned short v = get_leq_16_bits ( mp , n1 + 1 ) ; r1 = ( ( ( - 1 ) << n1 ) + v + 1 ) * muls [ n1 + 1 ] [ i1 ] ; } else { r1 = 0 ; } fraction [ 0 ] [ i ] = ( real ) r0 ; fraction [ 1 ] [ i ] = ( real ) r1 ; } for ( i = jsbound ; i < SBLIMIT ; i ++ ) { unsigned char i0 = si -> scalefactor [ i ] [ 0 ] ; unsigned char i1 = si -> scalefactor [ i ] [ 1 ] ; unsigned char n = si -> allocation [ i ] [ 0 ] ; assert ( i0 < 64 ) ; assert ( i1 < 64 ) ; assert ( n < 16 ) ; if ( n > 0 ) { unsigned short v = get_leq_16_bits ( mp , n + 1 ) ; unsigned int w = ( ( ( - 1 ) << n ) + v + 1 ) ; r0 = w * muls [ n + 1 ] [ i0 ] ; r1 = w * muls [ n + 1 ] [ i1 ] ; } else { r0 = r1 = 0 ; } fraction [ 0 ] [ i ] = ( real ) r0 ; fraction [ 1 ] [ i ] = ( real ) r1 ; } for ( i = ds_limit ; i < SBLIMIT ; i ++ ) { fraction [ 0 ] [ i ] = 0.0 ; fraction [ 1 ] [ i ] = 0.0 ; } } else { for ( i = 0 ; i < SBLIMIT ; i ++ ) { unsigned char n = si -> allocation [ i ] [ 0 ] ; unsigned char j = si -> scalefactor [ i ] [ 0 ] ; assert ( j < 64 ) ; assert ( n < 16 ) ; if ( n > 0 ) { unsigned short v = get_leq_16_bits ( mp , n + 1 ) ; r0 = ( ( ( - 1 ) << n ) + v + 1 ) * muls [ n + 1 ] [ j ] ; } else { r0 = 0 ; } fraction [ 0 ] [ i ] = ( real ) r0 ; } for ( i = ds_limit ; i < SBLIMIT ; i ++ ) { fraction [ 0 ] [ i ] = 0.0 ; } } } 