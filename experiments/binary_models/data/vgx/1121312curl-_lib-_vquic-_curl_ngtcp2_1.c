static CURLcode cf_connect_start ( struct Curl_cfilter * cf , struct Curl_easy * data ) { struct cf_ngtcp2_ctx * ctx = cf -> ctx ; int rc ; int rv ; CURLcode result ; const struct Curl_sockaddr_ex * sockaddr ; int qfd ; ctx -> version = NGTCP2_PROTO_VER_MAX ; result = quic_ssl_ctx ( & ctx -> sslctx , cf , data ) ; result = quic_set_client_cert ( cf , data ) ; if ( result ) { return result ; } result = quic_ssl_ctx ( & ctx -> sslctx , cf , data ) ; if ( result ) { return result ; } result = quic_init_ssl ( cf , data ) ; if ( result ) { return result ; } ctx -> dcid . datalen = NGTCP2_MAX_CIDLEN ; result = Curl_rand ( data , ctx -> dcid . data , NGTCP2_MAX_CIDLEN ) ; if ( result ) { return result ; } ctx -> scid . datalen = NGTCP2_MAX_CIDLEN ; result = Curl_rand ( data , ctx -> scid . data , NGTCP2_MAX_CIDLEN ) ; if ( result ) { return result ; } ( void ) Curl_qlogdir ( data , ctx -> scid . data , NGTCP2_MAX_CIDLEN , & qfd ) ; ctx -> qlogfd = qfd ; quic_settings ( ctx , data ) ; result = vquic_ctx_init ( & ctx -> q , NGTCP2_MAX_PMTUD_UDP_PAYLOAD_SIZE * MAX_PKT_BURST ) ; if ( result ) { return result ; } Curl_cf_socket_peek ( cf -> next , data , & ctx -> q . sockfd , & sockaddr , NULL , NULL , NULL , NULL ) ; ctx -> q . local_addrlen = sizeof ( ctx -> q . local_addr ) ; rv = getsockname ( ctx -> q . sockfd , ( sockaddr * ) & ctx -> q . local_addr , & ctx -> q . local_addrlen ) ; if ( rv == - 1 ) { return CURLE_QUIC_CONNECT_ERROR ; } ngtcp2_addr_init ( & ctx -> connected_path . local , ( sockaddr * ) & ctx -> q . local_addr , ctx -> q . local_addrlen ) ; ngtcp2_addr_init ( & ctx -> connected_path . remote , & sockaddr -> sa_addr , sockaddr -> addrlen ) ; rc = ngtcp2_conn_client_new ( & ctx -> qconn , & ctx -> dcid , & ctx -> scid , & ctx -> connected_path , NGTCP2_PROTO_VER_V1 , & ng_callbacks , & ctx -> settings , & ctx -> transport_params , NULL , cf ) ; if ( rc ) { return CURLE_QUIC_CONNECT_ERROR ; } ngtcp2_conn_set_tls_native_handle ( ctx -> qconn , ctx -> gtls -> session ) ; ngtcp2_conn_set_tls_native_handle ( ctx -> qconn , ctx -> ssl ) ; ngtcp2_connection_close_error_default ( & ctx -> last_error ) ; ctx -> conn_ref . get_conn = get_conn ; ctx -> conn_ref . user_data = cf ; return CURLE_OK ; } 