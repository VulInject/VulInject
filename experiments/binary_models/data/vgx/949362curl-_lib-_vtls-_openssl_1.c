static CURLcode ossl_verifyhost ( struct Curl_easy * data , struct connectdata * conn , X509 * server_cert , const char * hostname , const char * dispname ) { bool matched = FALSE ; int target = GEN_DNS ; size_t addrlen = 0 ; STACK_OF ( GENERAL_NAME ) * altnames ; struct in6_addr addr ; struct in_addr addr ; CURLcode result = CURLE_OK ; bool dNSName = FALSE ; bool iPAddress = FALSE ; size_t hostlen ; ( void ) conn ; hostlen = strlen ( hostname ) ; ( void ) conn ; if ( conn -> bits . ipv6_ip && Curl_inet_pton ( AF_INET6 , hostname , & addr ) ) { target = GEN_IPADD ; addrlen = sizeof ( in6_addr ) ; } if ( Curl_inet_pton ( AF_INET , hostname , & addr ) ) { target = GEN_IPADD ; addrlen = sizeof ( in_addr ) ; } altnames = X509_get_ext_d2i ( server_cert , NID_subject_alt_name , NULL , NULL ) ; if ( altnames ) { size_t numalts ; int i ; int numalts ; int i ; bool dnsmatched = FALSE ; bool ipmatched = FALSE ; numalts = sk_GENERAL_NAME_num ( altnames ) ; for ( i = 0 ; ( i < numalts ) && ! dnsmatched ; i ++ ) { const GENERAL_NAME * check = sk_GENERAL_NAME_value ( altnames , i ) ; if ( check -> type == GEN_DNS ) { dNSName = TRUE ; } if ( check -> type == GEN_IPADD ) { iPAddress = TRUE ; } if ( check -> type == target ) { const char * altptr = ( char * ) ASN1_STRING_get0_data ( check -> d . ia5 ) ; size_t altlen = ( size_t ) ASN1_STRING_length ( check -> d . ia5 ) ; switch ( target ) { case GEN_DNS : if ( ( altlen == strlen ( altptr ) ) && subj_alt_hostcheck ( data , altptr , altlen , hostname , hostlen , dispname ) ) { dnsmatched = TRUE ; } break ; case GEN_IPADD : if ( ( altlen == addrlen ) && ! memcmp ( altptr , & addr , altlen ) ) { ipmatched = TRUE ; infof ( data , " subjectAltName: host \"%s\" matched cert's IP address!" , dispname ) ; } break ; } } } GENERAL_NAMES_free ( altnames ) ; if ( dnsmatched || ipmatched ) { matched = TRUE ; } } if ( matched ) { } if ( dNSName || iPAddress ) { infof ( data , " subjectAltName does not match %s" , dispname ) ; failf ( data , "SSL: no alternative certificate subject name matches " "target host name '%s'" , dispname ) ; result = CURLE_PEER_FAILED_VERIFICATION ; } else { int i = - 1 ; unsigned char * peer_CN = NULL ; int peerlen = 0 ; X509_NAME * name = X509_get_subject_name ( server_cert ) ; if ( name ) { int j ; while ( ( j = X509_NAME_get_index_by_NID ( name , NID_commonName , i ) ) >= 0 ) { i = j ; } } if ( i >= 0 ) { ASN1_STRING * tmp = X509_NAME_ENTRY_get_data ( X509_NAME_get_entry ( name , i ) ) ; if ( tmp ) { if ( ASN1_STRING_type ( tmp ) == V_ASN1_UTF8STRING ) { peerlen = ASN1_STRING_length ( tmp ) ; if ( peerlen >= 0 ) { peer_CN = OPENSSL_malloc ( peerlen + 1 ) ; if ( peer_CN ) { memcpy ( peer_CN , ASN1_STRING_get0_data ( tmp ) , peerlen ) ; peer_CN [ peerlen ] = '\0' ; } else { result = CURLE_OUT_OF_MEMORY ; } } } else { peerlen = ASN1_STRING_to_UTF8 ( & peer_CN , tmp ) ; } if ( peer_CN && ( curlx_uztosi ( strlen ( ( char * ) peer_CN ) ) != peerlen ) ) { failf ( data , "SSL: illegal cert name field" ) ; result = CURLE_PEER_FAILED_VERIFICATION ; } } } if ( result ) { } if ( ! peer_CN ) { failf ( data , "SSL: unable to obtain common name from peer certificate" ) ; result = CURLE_PEER_FAILED_VERIFICATION ; } if ( ! Curl_cert_hostcheck ( ( const char * ) peer_CN , peerlen , hostname , hostlen ) ) { failf ( data , "SSL: certificate subject name '%s' does not match " "target host name '%s'" , peer_CN , dispname ) ; result = CURLE_PEER_FAILED_VERIFICATION ; } else { infof ( data , " common name: %s (matched)" , peer_CN ) ; } if ( peer_CN ) { OPENSSL_free ( peer_CN ) ; } } return result ; } 