static VAR1
FUN1(struct VAR2 **VAR3, k5_transport VAR4,
krb5_boolean VAR5, struct VAR6 *VAR7, size_t VAR8,
const VAR9 *VAR10, const char *VAR11,
const char *VAR12, const char *VAR13, char **VAR14)
{
struct VAR2 *VAR15, **VAR16;

VAR15 = calloc(1, sizeof(*VAR15));
if (VAR15 == NULL)
return VAR17;
VAR15->VAR15 = VAR18;
VAR15->VAR19.VAR20 = VAR15->VAR19.VAR21;
VAR15->VAR22.VAR4 = VAR4;
VAR15->VAR22.VAR23 = VAR7->VAR24;
VAR15->VAR22.VAR25 = VAR7->VAR26;
memcpy(&VAR15->VAR22.VAR27, VAR7->VAR28, VAR7->VAR26);
VAR15->VAR5 = VAR5;
VAR15->VAR29 = VAR30;
VAR15->VAR8 = VAR8;
FUN2(&VAR15->VAR19.VAR21[1], NULL, 0);
if (VAR4 == VAR31) {
VAR15->VAR32 = VAR33;
VAR15->VAR34 = VAR35;
VAR15->VAR36 = VAR37;
} else if (VAR4 == VAR38) {
assert(VAR11 != NULL && VAR12 != NULL);
VAR15->VAR32 = VAR33;
VAR15->VAR34 = VAR39;
VAR15->VAR36 = VAR40;
VAR15->VAR41.VAR13 = VAR13;
VAR15->VAR41.VAR42 = VAR11;
FUN3(VAR15->VAR41.VAR12, VAR12, VAR43);
} else {
VAR15->VAR32 = NULL;
VAR15->VAR34 = NULL;
VAR15->VAR36 = VAR44;

if (*VAR14 == NULL) {
*VAR14 = malloc(VAR45);
if (*VAR14 == NULL) {
free(VAR15);
return VAR17;
}
}
VAR15->VAR46.VAR47 = *VAR14;
VAR15->VAR46.VAR48 = VAR45;
}


for (VAR16 = VAR3; *VAR16 != NULL; VAR16 = &(*VAR16)->VAR49);
*VAR16 = VAR15;

return 0;
}