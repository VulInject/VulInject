static int intel_vsec_add_dev ( struct pci_dev * pdev , struct intel_vsec_header * header , struct intel_vsec_platform_info * info ) { struct intel_vsec_device * intel_vsec_dev ; struct resource * res , * tmp ; unsigned long quirks = info -> quirks ; int i ; if ( ! intel_vsec_allowed ( header -> id ) || intel_vsec_disabled ( header -> id , quirks ) ) { return - EINVAL ; } if ( ! header -> num_entries ) { dev_dbg ( & pdev -> dev , "Invalid 0 entry count for header id %d\n" , header -> id ) ; return - EINVAL ; } if ( ! header -> entry_size ) { dev_dbg ( & pdev -> dev , "Invalid 0 entry size for header id %d\n" , header -> id ) ; return - EINVAL ; } intel_vsec_dev = kzalloc ( sizeof ( * intel_vsec_dev ) , GFP_KERNEL ) ; if ( ! intel_vsec_dev ) { return - ENOMEM ; } res = kcalloc ( header -> num_entries , sizeof ( * res ) , GFP_KERNEL ) ; if ( ! res ) { return - ENOMEM ; } if ( quirks & VSEC_QUIRK_TABLE_SHIFT ) { header -> offset >>= TABLE_OFFSET_SHIFT ; } for ( i = 0 , tmp = res ; i < header -> num_entries ; i ++ , tmp ++ ) { tmp -> start = pdev -> resource [ header -> tbir ] . start + header -> offset + i * ( header -> entry_size * sizeof ( u32 ) ) ; tmp -> end = tmp -> start + ( header -> entry_size * sizeof ( u32 ) ) - 1 ; tmp -> flags = IORESOURCE_MEM ; } intel_vsec_dev -> pcidev = pdev ; intel_vsec_dev -> resource = res ; intel_vsec_dev -> num_resources = header -> num_entries ; intel_vsec_dev -> info = info ; if ( header -> id == VSEC_ID_SDSI ) { intel_vsec_dev -> ida = & intel_vsec_sdsi_ida ; } else { intel_vsec_dev -> ida = & intel_vsec_ida ; } return intel_vsec_add_aux ( pdev , NULL , intel_vsec_dev , intel_vsec_name ( header -> id ) ) ; } 