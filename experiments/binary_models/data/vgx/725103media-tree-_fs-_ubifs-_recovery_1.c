static int get_cs_sqnum ( struct ubifs_info * c , int lnum , int offs , unsigned long long * cs_sqnum ) { struct ubifs_cs_node * cs_node = NULL ; int err , ret ; dbg_rcvry ( "at %d:%d" , lnum , offs ) ; cs_node = kmalloc ( UBIFS_CS_NODE_SZ , GFP_KERNEL ) ; if ( ! cs_node ) { return - ENOMEM ; } if ( c -> leb_size - offs < UBIFS_CS_NODE_SZ ) { out_err } err = ubifs_leb_read ( c , lnum , ( void * ) cs_node , offs , UBIFS_CS_NODE_SZ , 0 ) ; if ( err && err != - EBADMSG ) { out_free } ret = ubifs_scan_a_node ( c , cs_node , UBIFS_CS_NODE_SZ , lnum , offs , 0 ) ; if ( ret != SCANNED_A_NODE ) { ubifs_err ( c , "Not a valid node" ) ; out_err } if ( cs_node -> ch . node_type != UBIFS_CS_NODE ) { ubifs_err ( c , "Node a CS node, type is %d" , cs_node -> ch . node_type ) ; out_err } if ( le64_to_cpu ( cs_node -> cmt_no ) != c -> cmt_no ) { ubifs_err ( c , "CS node cmt_no %llu != current cmt_no %llu" , ( unsigned long long ) le64_to_cpu ( cs_node -> cmt_no ) , c -> cmt_no ) ; out_err } * cs_sqnum = le64_to_cpu ( cs_node -> ch . sqnum ) ; dbg_rcvry ( "commit start sqnum %llu" , * cs_sqnum ) ; return 0 ; out_err err = - EINVAL ; out_free ubifs_err ( c , "failed to get CS sqnum" ) ; kfree ( cs_node ) ; return err ; } 