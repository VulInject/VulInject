static ssize_t smk_write_rules_list ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , struct list_head * rule_list , struct mutex * rule_lock , int format ) { struct smack_parsed_rule rule ; char * data ; int rc ; int trunc = 0 ; int tokens ; int cnt = 0 ; if ( * ppos != 0 ) { return - EINVAL ; } if ( format == SMK_FIXED24_FMT ) { if ( count ( SMK_OLOADLEN || count ) SMK_LOADLEN ) { return - EINVAL ; } } else { if ( count >= PAGE_SIZE ) { count = PAGE_SIZE - 1 ; trunc = 1 ; } } data = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( data ) ) { return PTR_ERR ( data ) ; } if ( trunc ) { while ( count > 0 && ( data [ count - 1 ] != '\n' ) ) { -- count ; } if ( count == 0 ) { rc = - EINVAL ; out } } data [ count ] = '\0' ; tokens = ( format == SMK_CHANGE_FMT ?4 : 3 ) ; while ( cnt < count ) { if ( format == SMK_FIXED24_FMT ) { rc = smk_parse_rule ( data , & rule , 1 ) ; if ( rc < 0 ) { out } cnt = count ; } else { rc = smk_parse_long_rule ( data + cnt , & rule , 1 , tokens ) ; if ( rc < 0 ) { out } if ( rc == 0 ) { rc = - EINVAL ; out } cnt += rc ; } if ( rule_list == NULL ) { rc = smk_set_access ( & rule , & rule . smk_subject -> smk_rules , & rule . smk_subject -> smk_rules_lock ) ; } else { rc = smk_set_access ( & rule , rule_list , rule_lock ) ; } if ( rc ) { out } } rc = cnt ; out kfree ( data ) ; return rc ; } 