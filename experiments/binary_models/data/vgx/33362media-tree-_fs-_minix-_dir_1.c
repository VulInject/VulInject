int minix_add_link ( struct dentry * dentry , struct inode * inode ) { struct inode * dir = d_inode ( dentry -> d_parent ) ; const char * name = dentry -> d_name . name ; int namelen = dentry -> d_name . len ; struct super_block * sb = dir -> i_sb ; struct minix_sb_info * sbi = minix_sb ( sb ) ; struct page * page = NULL ; unsigned long npages = dir_pages ( dir ) ; unsigned long n ; char * kaddr , * p ; minix_dirent * de ; minix3_dirent * de3 ; loff_t pos ; int err ; char * namx = NULL ; __u32 inumber ; for ( n = 0 ; n <= npages ; n ++ ) { char * limit , * dir_end ; page = dir_get_page ( dir , n ) ; err = PTR_ERR ( page ) ; if ( IS_ERR ( page ) ) { out } lock_page ( page ) ; kaddr = ( char * ) page_address ( page ) ; dir_end = kaddr + minix_last_byte ( dir , n ) ; limit = kaddr + PAGE_SIZE - sbi -> s_dirsize ; for ( p = kaddr ; p <= limit ; p = minix_next_entry ( p , sbi ) ) { de = ( minix_dirent * ) p ; de3 = ( minix3_dirent * ) p ; if ( sbi -> s_version == MINIX_V3 ) { namx = de3 -> name ; inumber = de3 -> inode ; } else { namx = de -> name ; inumber = de -> inode ; } if ( p == dir_end ) { if ( sbi -> s_version == MINIX_V3 ) { de3 -> inode = 0 ; } else { de -> inode = 0 ; } got_it } if ( ! inumber ) { got_it } err = - EEXIST ; if ( namecompare ( namelen , sbi -> s_namelen , name , namx ) ) { out_unlock } } unlock_page ( page ) ; dir_put_page ( page ) ; } BUG ( ) ; return - EINVAL ; got_it pos = page_offset ( page ) + p - ( char * ) page_address ( page ) ; err = minix_prepare_chunk ( page , pos , sbi -> s_dirsize ) ; if ( err ) { out_unlock } memcpy ( namx , name , namelen ) ; if ( sbi -> s_version == MINIX_V3 ) { de3 -> inode = inode -> i_ino ; } else { memset ( namx + namelen , 0 , sbi -> s_dirsize - namelen - 2 ) ; de -> inode = inode -> i_ino ; } err = dir_commit_chunk ( page , pos , sbi -> s_dirsize ) ; dir -> i_mtime = dir -> i_ctime = current_time ( dir ) ; mark_inode_dirty ( dir ) ; out_put dir_put_page ( page ) ; out return err ; out_unlock unlock_page ( page ) ; out_put } 