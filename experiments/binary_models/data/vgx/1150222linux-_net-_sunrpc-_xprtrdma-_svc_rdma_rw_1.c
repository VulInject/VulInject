int svc_rdma_process_read_list ( struct svcxprt_rdma * rdma , struct svc_rqst * rqstp , struct svc_rdma_recv_ctxt * head ) { struct svc_rdma_read_info * info ; struct svc_rdma_chunk_ctxt * cc ; int ret ; info = svc_rdma_read_info_alloc ( rdma ) ; cc = & info -> ri_cc ; info -> ri_rqst = rqstp ; info -> ri_readctxt = head ; info -> ri_pageno = 0 ; info -> ri_pageoff = 0 ; info -> ri_totalbytes = 0 ; if ( pcl_is_empty ( & head -> rc_call_pcl ) ) { if ( head -> rc_read_pcl . cl_count == 1 ) { ret = svc_rdma_read_data_item ( info ) ; } else { ret = svc_rdma_read_multiple_chunks ( info ) ; } } else { ret = svc_rdma_read_special ( info ) ; } if ( ret < 0 ) { out_err } trace_svcrdma_post_read_chunk ( & cc -> cc_cid , cc -> cc_sqecount ) ; init_completion ( & cc -> cc_done ) ; ret = svc_rdma_post_chunk_ctxt ( cc ) ; if ( ret < 0 ) { out_err } ret = 1 ; wait_for_completion ( & cc -> cc_done ) ; if ( cc -> cc_status != IB_WC_SUCCESS ) { ret = - EIO ; } rqstp -> rq_respages = & rqstp -> rq_pages [ head -> rc_page_count ] ; rqstp -> rq_next_page = rqstp -> rq_respages + 1 ; head -> rc_page_count = 0 ; out_err svc_rdma_read_info_free ( info ) ; return ret ; } 