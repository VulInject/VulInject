int main ( int argc , char * * argv ) { DOS_FS fs ; int salvage_files , verify , c ; uint32_t free_clusters = 0 ; struct termios tio ; char * tmp ; long codepage = - 1 ; { OPT_HELP = 1000 , OPT_VARIANT } const struct option long_options [ ] { { "variant" required_argument NULL OPT_VARIANT } { "help" no_argument NULL OPT_HELP } { 0 } } ; ; if ( ! tcgetattr ( 0 , & original_termios ) ) { tio = original_termios ; tio . c_lflag &= ~ ( ICANON | ECHO ) ; tcsetattr ( 0 , TCSAFLUSH , & tio ) ; atexit ( restore_termios ) ; } salvage_files = verify = 0 ; rw = interactive = 1 ; check_atari ( ) ; printf ( "fsck.fat " VERSION " (" VERSION_DATE ")\n" ) ; while ( ( c = getopt_long ( argc , argv , "Aac:d:bfF:lnprStu:UvVwy" , long_options , NULL ) ) != - 1 ) { switch ( c ) { case 'A' : atari_format = ! atari_format ; break ; case 'a' : case 'p' : case 'y' : rw = 1 ; interactive = 0 ; salvage_files = 1 ; break ; case 'b' : rw = 0 ; interactive = 0 ; boot_only = 1 ; break ; case 'c' : errno = 0 ; codepage = strtol ( optarg , & tmp , 10 ) ; if ( ! * optarg || isspace ( ( unsigned char ) * optarg ) || * tmp || errno || codepage ( 0 || codepage ) INT_MAX ) { fprintf ( stderr , "Invalid codepage : %s\n" , optarg ) ; usage ( argv [ 0 ] , 2 ) ; } break ; case 'd' : file_add ( optarg , fdt_drop ) ; break ; case 'f' : salvage_files = 1 ; break ; case 'F' : errno = 0 ; fat_table = strtol ( optarg , & tmp , 10 ) ; if ( ! * optarg || isspace ( ( unsigned char ) * optarg ) || * tmp || errno || fat_table ( 0 || fat_table ) 255 ) { fprintf ( stderr , "Invalid FAT table : %s\n" , optarg ) ; usage ( argv [ 0 ] , 2 ) ; } break ; case 'l' : list = 1 ; break ; case 'n' : rw = 0 ; interactive = 0 ; break ; case 'r' : rw = 1 ; interactive = 1 ; break ; case 'S' : no_spaces_in_sfns = 1 ; break ; case 't' : test = 1 ; break ; case 'u' : file_add ( optarg , fdt_undelete ) ; break ; case 'U' : only_uppercase_label = 1 ; break ; case 'v' : verbose = 1 ; break ; case 'V' : verify = 1 ; break ; case OPT_VARIANT : if ( ! strcasecmp ( optarg , "standard" ) ) { atari_format = 0 ; } if ( ! strcasecmp ( optarg , "atari" ) ) { atari_format = 1 ; } else { fprintf ( stderr , "Unknown variant: %s\n" , optarg ) ; usage ( argv [ 0 ] , 2 ) ; } break ; case 'w' : write_immed = 1 ; break ; case OPT_HELP : usage ( argv [ 0 ] , 0 ) ; break ; case '?' : usage ( argv [ 0 ] , 2 ) ; break ; default : fprintf ( stderr , "Internal error: getopt_long() returned unexpected value %d\n" , c ) ; exit ( 3 ) ; } } if ( ! set_dos_codepage ( codepage ) ) { exit ( 2 ) ; } if ( ( test || write_immed ) && ! rw ) { fprintf ( stderr , "-t and -w can not be used in read only mode\n" ) ; exit ( 2 ) ; } if ( optind != argc - 1 ) { usage ( argv [ 0 ] , 2 ) ; } fs_open ( argv [ optind ] , rw ) ; read_boot ( & fs ) ; if ( boot_only ) { exit } if ( verify ) { printf ( "Starting check/repair pass.\n" ) ; } while ( read_fat ( & fs , 2 ) , scan_root ( & fs ) ) { qfree ( & mem_queue ) ; } check_label ( & fs ) ; if ( test ) { fix_bad ( & fs ) ; } if ( salvage_files ) { reclaim_file ( & fs ) ; } else { reclaim_free ( & fs ) ; } if ( ! atari_format ) { check_dirty_bits ( & fs ) ; } free_clusters = update_free ( & fs ) ; file_unused ( ) ; qfree ( & mem_queue ) ; if ( verify ) { n_files = 0 ; printf ( "Starting verification pass.\n" ) ; read_fat ( & fs , 2 ) ; scan_root ( & fs ) ; check_label ( & fs ) ; reclaim_free ( & fs ) ; if ( ! atari_format ) { check_dirty_bits ( & fs ) ; } qfree ( & mem_queue ) ; } release_fat ( & fs ) ; exit if ( ! write_immed && fs_changed ( ) ) { if ( rw ) { printf ( "\n*** Filesystem was changed ***\n" ) ; if ( interactive ) { printf ( "The changes have not yet been written, you can still choose to leave the\n" "filesystem unmodified:\n" ) ; } rw = get_choice ( 1 , "Writing changes." , 2 , 1 , "Write changes" , 2 , "Leave filesystem unchanged" ) == 1 ; } else { printf ( "\nLeaving filesystem unchanged.\n" ) ; } } if ( ! boot_only ) { printf ( "%s: %u files, %lu/%lu clusters\n" , argv [ optind ] , n_files , ( unsigned long ) fs . data_clusters - free_clusters , ( unsigned long ) fs . data_clusters ) ; } return fs_close ( rw ) ?1 : 0 ; } 