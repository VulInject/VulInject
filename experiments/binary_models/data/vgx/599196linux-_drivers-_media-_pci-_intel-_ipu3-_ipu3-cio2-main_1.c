static int cio2_pci_probe ( struct pci_dev * pci_dev , const struct pci_device_id * id ) { struct device * dev = & pci_dev -> dev ; struct fwnode_handle * fwnode = dev_fwnode ( dev ) ; struct cio2_device * cio2 ; int r ; r = cio2_check_fwnode_graph ( fwnode ) ; if ( r ) { if ( fwnode && ! IS_ERR_OR_NULL ( fwnode -> secondary ) ) { dev_err ( dev , "fwnode graph has no endpoints connected\n" ) ; return - EINVAL ; } r = cio2_bridge_init ( pci_dev ) ; if ( r ) { return r ; } } cio2 = devm_kzalloc ( dev , sizeof ( * cio2 ) , GFP_KERNEL ) ; if ( ! cio2 ) { return - ENOMEM ; } cio2 -> pci_dev = pci_dev ; r = pcim_enable_device ( pci_dev ) ; if ( r ) { dev_err ( dev , "failed to enable device (%d)\n" , r ) ; return r ; } dev_info ( dev , "device 0x%x (rev: 0x%x)\n" , pci_dev -> device , pci_dev -> revision ) ; r = pcim_iomap_regions ( pci_dev , 1 << CIO2_PCI_BAR , pci_name ( pci_dev ) ) ; if ( r ) { dev_err ( dev , "failed to remap I/O memory (%d)\n" , r ) ; return - ENODEV ; } cio2 -> base = pcim_iomap_table ( pci_dev ) [ CIO2_PCI_BAR ] ; pci_set_drvdata ( pci_dev , cio2 ) ; pci_set_master ( pci_dev ) ; r = dma_set_mask ( & pci_dev -> dev , CIO2_DMA_MASK ) ; if ( r ) { dev_err ( dev , "failed to set DMA mask (%d)\n" , r ) ; return - ENODEV ; } r = pci_enable_msi ( pci_dev ) ; if ( r ) { dev_err ( dev , "failed to enable MSI (%d)\n" , r ) ; return r ; } r = cio2_fbpt_init_dummy ( cio2 ) ; if ( r ) { return r ; } mutex_init ( & cio2 -> lock ) ; cio2 -> media_dev . dev = dev ; strscpy ( cio2 -> media_dev . model , CIO2_DEVICE_NAME , sizeof ( cio2 -> media_dev . model ) ) ; cio2 -> media_dev . hw_revision = 0 ; media_device_init ( & cio2 -> media_dev ) ; r = media_device_register ( & cio2 -> media_dev ) ; if ( r < 0 ) { fail_mutex_destroy } cio2 -> v4l2_dev . mdev = & cio2 -> media_dev ; r = v4l2_device_register ( dev , & cio2 -> v4l2_dev ) ; if ( r ) { dev_err ( dev , "failed to register V4L2 device (%d)\n" , r ) ; fail_media_device_unregister } r = cio2_queues_init ( cio2 ) ; if ( r ) { fail_v4l2_device_unregister } v4l2_async_nf_init ( & cio2 -> notifier ) ; r = cio2_parse_firmware ( cio2 ) ; if ( r ) { fail_clean_notifier } r = devm_request_irq ( dev , pci_dev -> irq , cio2_irq , IRQF_SHARED , CIO2_NAME , cio2 ) ; if ( r ) { dev_err ( dev , "failed to request IRQ (%d)\n" , r ) ; fail_clean_notifier } pm_runtime_put_noidle ( dev ) ; pm_runtime_allow ( dev , NULL ) ; return 0 ; fail_clean_notifier v4l2_async_nf_unregister ( & cio2 -> notifier ) ; v4l2_async_nf_cleanup ( & cio2 -> notifier ) ; cio2_queues_exit ( cio2 ) ; fail_v4l2_device_unregister v4l2_device_unregister ( & cio2 -> v4l2_dev ) ; fail_media_device_unregister media_device_unregister ( & cio2 -> media_dev ) ; media_device_cleanup ( & cio2 -> media_dev ) ; fail_mutex_destroy mutex_destroy ( & cio2 -> lock ) ; cio2_fbpt_exit_dummy ( cio2 ) ; return r ; } 