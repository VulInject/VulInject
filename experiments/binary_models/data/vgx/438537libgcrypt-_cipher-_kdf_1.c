openpgp_s2k ( , , , , , , , , ) { gpg_err_code_t ec ; gcry_md_hd_t md ; char * key = keybuffer ; int pass , i ; int used = 0 ; int secmode ; if ( ( algo == GCRY_KDF_SALTED_S2K || algo == GCRY_KDF_ITERSALTED_S2K ) && ( ! salt || saltlen != 8 ) ) { return GPG_ERR_INV_VALUE ; } secmode = _gcry_is_secure ( passphrase ) || _gcry_is_secure ( keybuffer ) ; ec = _gcry_md_open ( & md , hashalgo , secmode ?GCRY_MD_FLAG_SECURE : 0 ) ; if ( ec ) { return ec ; } for ( pass = 0 ; used < keysize ; pass ++ ) { if ( pass ) { _gcry_md_reset ( md ) ; for ( i = 0 ; i < pass ; i ++ ) { _gcry_md_putc ( md , 0 ) ; } } if ( algo == GCRY_KDF_SALTED_S2K || algo == GCRY_KDF_ITERSALTED_S2K ) { int len2 = passphraselen + 8 ; cfs_time_t count = len2 ; if ( algo == GCRY_KDF_ITERSALTED_S2K ) { count = iterations ; if ( count < len2 ) { count = len2 ; } } while ( count > len2 ) { _gcry_md_write ( md , salt , saltlen ) ; _gcry_md_write ( md , passphrase , passphraselen ) ; count -= len2 ; } if ( count < saltlen ) { _gcry_md_write ( md , salt , count ) ; } else { _gcry_md_write ( md , salt , saltlen ) ; count -= saltlen ; _gcry_md_write ( md , passphrase , count ) ; } } else { _gcry_md_write ( md , passphrase , passphraselen ) ; } _gcry_md_final ( md ) ; i = _gcry_md_get_algo_dlen ( hashalgo ) ; if ( i > keysize - used ) { i = keysize - used ; } memcpy ( key + used , _gcry_md_read ( md , hashalgo ) , i ) ; used += i ; } _gcry_md_close ( md ) ; return 0 ; } 