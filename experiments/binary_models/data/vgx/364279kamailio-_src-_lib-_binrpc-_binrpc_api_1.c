int binrpc_send_command ( struct binrpc_handle * handle , char * method , char * * args , int arg_count , struct binrpc_response_handle * resp_handle ) { struct binrpc_pkt req_pkt ; struct binrpc_val v ; int i , size , res = FATAL_ERROR , ret = 0 ; unsigned char * req_buf = NULL ; if ( ! method || strlen ( method ) == 0 ) { snprintf ( binrpc_last_errs , sizeof ( binrpc_last_errs ) - 1 , "send_command: method name not specified" ) ; fail } size = BINRPC_MIN_RECORD_SIZE + 8 + strlen ( method ) + 1 ; for ( i = 0 ; i < arg_count ; i ++ ) { if ( parse_arg ( & v , args [ i ] ) < 0 ) { fail } switch ( v . type ) { case BINRPC_T_STR : size += v . u . strval . len + 1 ; break ; case BINRPC_T_INT : case BINRPC_T_DOUBLE : size += sizeof ( int ) ; break ; default : snprintf ( binrpc_last_errs , sizeof ( binrpc_last_errs ) - 1 , "BUG: send_command: unexpected value type" ) ; fail } size += BINRPC_MIN_RECORD_SIZE + 8 ; } req_buf = binrpc_malloc ( size ) ; if ( ! req_buf ) { snprintf ( binrpc_last_errs , sizeof ( binrpc_last_errs ) - 1 , "send_command: not enough memory to allocate buffer. Needed %d bytes" , size ) ; fail } if ( ( ret = binrpc_init_pkt ( & req_pkt , req_buf , size ) ) < 0 ) { fail2 } if ( ( ret = binrpc_addstr ( & req_pkt , method , strlen ( method ) ) ) < 0 ) { fail2 } for ( i = 0 ; i < arg_count ; i ++ ) { if ( parse_arg ( & v , args [ i ] ) < 0 ) { fail } switch ( v . type ) { case BINRPC_T_STR : if ( ( ret = binrpc_addstr ( & req_pkt , v . u . strval . s , v . u . strval . len ) ) < 0 ) { fail2 } break ; case BINRPC_T_INT : if ( ( ret = binrpc_addint ( & req_pkt , v . u . intval ) ) < 0 ) { fail2 } break ; case BINRPC_T_DOUBLE : if ( ( ret = binrpc_adddouble ( & req_pkt , v . u . fval ) ) < 0 ) { fail2 } break ; default : break ; } } if ( binrpc_send_command_ex ( handle , & req_pkt , resp_handle ) < 0 ) { fail } res = 0 ; fail if ( req_buf ) { binrpc_free ( req_buf ) ; } return res ; fail2 snprintf ( binrpc_last_errs , sizeof ( binrpc_last_errs ) - 1 , "send_command: error when preparing params: %s" , binrpc_error ( ret ) ) ; fail } 