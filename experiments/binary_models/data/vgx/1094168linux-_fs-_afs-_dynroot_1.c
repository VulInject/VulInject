int afs_dynroot_mkdir ( struct afs_net * net , struct afs_cell * cell ) { struct super_block * sb = net -> dynroot_sb ; struct dentry * root , * subdir ; int ret ; if ( ! sb || atomic_read ( & sb -> s_active ) == 0 ) { return 0 ; } root = sb -> s_root ; inode_lock ( root -> d_inode , NULL ) ; subdir = lookup_one_len ( cell -> name , root , cell -> name_len ) ; if ( IS_ERR ( subdir ) ) { ret = PTR_ERR ( subdir ) ; unlock } subdir -> d_fsdata = ( void * ) 1UL ; ret = 0 ; unlock inode_unlock ( root -> d_inode ) ; return ret ; } 