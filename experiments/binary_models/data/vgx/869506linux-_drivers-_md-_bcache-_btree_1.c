static unsigned long bch_mca_scan ( struct shrinker * shrink , struct shrink_control * sc ) { struct cache_set * c = container_of ( shrink , cache_set , shrink ) ; struct btree * b , * t ; unsigned long i , nr = sc -> nr_to_scan ; unsigned long freed = 0 ; unsigned int btree_cache_used ; if ( c -> shrinker_disabled ) { return SHRINK_STOP ; } if ( c -> btree_cache_alloc_lock ) { return SHRINK_STOP ; } if ( sc -> gfp_mask & __GFP_IO ) { mutex_lock ( & c -> bucket_lock ) ; } if ( ! mutex_trylock ( & c -> bucket_lock ) ) { return - 1 ; } nr /= c -> btree_pages ; if ( nr == 0 ) { nr = 1 ; } nr = min_t ( , , ) ; i = 0 ; btree_cache_used = c -> btree_cache_used ; list_for_each_entry_safe_reverse ( , , , ) { if ( nr <= 0 ) { out } if ( ! mca_reap ( b , 0 , false ) ) { rw_unlock ( true , b ) ; freed ++ ; } nr -- ; i ++ ; } list_for_each_entry_safe_reverse ( , , , ) { if ( nr <= 0 || i >= btree_cache_used ) { out } if ( ! mca_reap ( b , 0 , false ) ) { mca_bucket_free ( b ) ; mca_data_free ( b ) ; rw_unlock ( true , b ) ; freed ++ ; } nr -- ; i ++ ; } out mutex_unlock ( & c -> bucket_lock ) ; return freed * c -> btree_pages ; } 