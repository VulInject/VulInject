int rls_handle_subscribe ( struct sip_msg * msg , str watcher_user , str watcher_domain ) { subs_t subs ; pres_ev_t * event = NULL ; int err_ret = - 1 ; int ret = to_presence_code ; xmlDocPtr doc = NULL ; xmlNodePtr service_node = NULL ; unsigned int hash_code = 0 ; int to_tag_gen = 0 ; event_t * parsed_event ; param_t * ev_param = NULL ; str reason ; int rt ; str rlsubs_did = { 0 0 } ; if ( parse_headers ( msg , HDR_EOH_F , 0 ) < - 1 ) { LM_ERR ( "failed parsing all headers\n" ) ; if ( slb . freply ( msg , 400 , & pu_400_rpl ) < 0 ) { LM_ERR ( "while sending 400 reply\n" ) ; return - 1 ; } return 0 ; } if ( parse_to_uri ( msg ) == NULL || parse_from_uri ( msg ) == NULL ) { LM_ERR ( "failed to find To or From headers\n" ) ; if ( slb . freply ( msg , 400 , & pu_400_rpl ) < 0 ) { LM_ERR ( "while sending 400 reply\n" ) ; return - 1 ; } return 0 ; } if ( get_from ( msg ) -> tag_value . s == NULL || get_from ( msg ) -> tag_value . len == 0 ) { LM_ERR ( "no from tag value present\n" ) ; return - 1 ; } if ( msg -> callid == NULL || msg -> callid -> body . s == NULL ) { LM_ERR ( "cannot find callid header\n" ) ; return - 1 ; } if ( parse_sip_msg_uri ( msg ) < 0 ) { LM_ERR ( "failed parsing Request URI\n" ) ; return - 1 ; } if ( msg -> supported == NULL ) { LM_DBG ( "supported header not found - not for rls\n" ) ; forpresence } if ( parse_supported ( msg ) < 0 ) { LM_ERR ( "failed to parse supported headers\n" ) ; return - 1 ; } if ( ! ( get_supported ( msg ) & F_OPTION_TAG_EVENTLIST ) ) { LM_DBG ( "No support for 'eventlist' - not for rls\n" ) ; forpresence } if ( msg -> event && msg -> event -> body . len > 0 ) { if ( ! msg -> event -> parsed && ( parse_event ( msg -> event ) < 0 ) ) { LM_ERR ( "cannot parse Event header\n" ) ; error } if ( ! ( ( ( event_t * ) msg -> event -> parsed ) -> type & rls_events ) ) { forpresence } } else { bad_event } parsed_event = ( event_t * ) msg -> event -> parsed ; event = pres_search_event ( parsed_event ) ; if ( event == NULL ) { bad_event } subs . event = event ; ev_param = parsed_event -> params . list ; while ( ev_param ) { if ( ev_param -> name . len == 2 && strncmp ( ev_param -> name . s , "id" , 2 ) == 0 ) { subs . event_id = ev_param -> body ; break ; } ev_param = ev_param -> next ; } if ( pres_extract_sdialog_info ( & subs , msg , rls_max_expires , & to_tag_gen , rls_server_address , watcher_user , watcher_domain ) < 0 ) { LM_ERR ( "bad subscribe request\n" ) ; error } hash_code = core_hash ( & subs . callid , & subs . to_tag , hash_size ) ; if ( CONSTR_RLSUBS_DID ( & subs , & rlsubs_did ) < 0 ) { LM_ERR ( "cannot build rls subs did\n" ) ; error } subs . updated = core_hash ( & rlsubs_did , NULL , 0 ) % ( waitn_time * rls_notifier_poll_rate * rls_notifier_processes ) ; if ( get_to ( msg ) -> tag_value . s == NULL || get_to ( msg ) -> tag_value . len == 0 ) { if ( uandd_to_uri ( msg -> parsed_uri . user , msg -> parsed_uri . host , & subs . pres_uri ) < 0 ) { LM_ERR ( "while constructing uri from user and domain\n" ) ; error } if ( rls_get_service_list ( & subs . pres_uri , & subs . watcher_user , & subs . watcher_domain , & service_node , & doc ) < 0 ) { LM_ERR ( "while attepmting to get a resource list\n" ) ; error } if ( doc == NULL ) { LM_DBG ( "list not found - searched for uri<%.*s>\n" , subs . pres_uri . len , subs . pres_uri . s ) ; forpresence } if ( reply_200 ( msg , & subs . local_contact , subs . expires ) < 0 ) { error } subs . local_cseq = 0 ; if ( subs . expires != 0 ) { subs . version = 1 ; if ( dbmode == RLS_DB_ONLY ) { rt = insert_rlsdb ( & subs ) ; } else { rt = pres_insert_shtable ( rls_table , hash_code , & subs ) ; } if ( rt < 0 ) { LM_ERR ( "while adding new subscription\n" ) ; error } } } else { if ( dbmode == RLS_DB_ONLY ) { if ( rls_dbf . start_transaction ) { if ( rls_dbf . start_transaction ( rls_db , DB_LOCKING_WRITE ) < 0 ) { LM_ERR ( "in start_transaction\n" ) ; error } } rt = get_dialog_subscribe_rlsdb ( & subs ) ; if ( rt <= 0 ) { LM_DBG ( "subscription dialog not found for<%.*s@%.*s>\n" , subs . watcher_user . len , subs . watcher_user . s , subs . watcher_domain . len , subs . watcher_domain . s ) ; if ( rls_dbf . end_transaction ) { if ( rls_dbf . end_transaction ( rls_db ) < 0 ) { LM_ERR ( "in end_transaction\n" ) ; error } } forpresence } if ( rt >= 400 ) { reason = ( rt == 400 ) ?pu_400_rpl : stale_cseq_rpl ; if ( slb . freply ( msg , 400 , & reason ) < 0 ) { LM_ERR ( "while sending reply\n" ) ; error } if ( rls_dbf . end_transaction ) { if ( rls_dbf . end_transaction ( rls_db ) < 0 ) { LM_ERR ( "in end_transaction\n" ) ; error } } ret = 0 ; stop } if ( reply_200 ( msg , & subs . local_contact , subs . expires ) < 0 ) { error } if ( update_dialog_subscribe_rlsdb ( & subs ) < 0 ) { LM_ERR ( "while updating resource list subscription\n" ) ; error } if ( rls_dbf . end_transaction ) { if ( rls_dbf . end_transaction ( rls_db ) < 0 ) { LM_ERR ( "in end_transaction\n" ) ; error } } } else { lock_get ( & rls_table [ hash_code ] . lock ) ; if ( pres_search_shtable ( rls_table , subs . callid , subs . to_tag , subs . from_tag , hash_code ) == NULL ) { lock_release ( & rls_table [ hash_code ] . lock ) ; LM_DBG ( "subscription dialog not found for<%.*s@%.*s>\n" , subs . watcher_user . len , subs . watcher_user . s , subs . watcher_domain . len , subs . watcher_domain . s ) ; forpresence } lock_release ( & rls_table [ hash_code ] . lock ) ; if ( reply_200 ( msg , & subs . local_contact , subs . expires ) < 0 ) { error } rt = update_rlsubs ( & subs , hash_code ) ; if ( rt < 0 ) { LM_ERR ( "while updating resource list subscription\n" ) ; error } if ( rt >= 400 ) { reason = ( rt == 400 ) ?pu_400_rpl : stale_cseq_rpl ; if ( slb . freply ( msg , 400 , & reason ) < 0 ) { LM_ERR ( "while sending reply\n" ) ; error } ret = 0 ; stop } } if ( rls_get_service_list ( & subs . pres_uri , & subs . watcher_user , & subs . watcher_domain , & service_node , & doc ) < 0 ) { LM_ERR ( "failed getting resource list\n" ) ; error } if ( doc == NULL ) { LM_WARN ( "no document returned for uri<%.*s>\n" , subs . pres_uri . len , subs . pres_uri . s ) ; done } } if ( get_to ( msg ) -> tag_value . s == NULL || get_to ( msg ) -> tag_value . len == 0 ) { if ( send_full_notify ( & subs , service_node , & subs . pres_uri , hash_code ) < 0 ) { LM_ERR ( "failed sending full state notify\n" ) ; error } } if ( resource_subscriptions ( & subs , service_node ) < 0 ) { LM_ERR ( "failed sending subscribe requests to resources in list\n" ) ; error } if ( dbmode != RLS_DB_ONLY ) { remove_expired_rlsubs ( & subs , hash_code ) ; } done ret = 1 ; stop forpresence if ( subs . pres_uri . s != NULL ) { pkg_free ( subs . pres_uri . s ) ; } if ( subs . record_route . s != NULL ) { pkg_free ( subs . record_route . s ) ; } if ( doc != NULL ) { xmlFreeDoc ( doc ) ; } if ( rlsubs_did . s != NULL ) { pkg_free ( rlsubs_did . s ) ; } return ret ; bad_event err_ret = 0 ; if ( reply_489 ( msg ) < 0 ) { LM_ERR ( "failed sending 489 reply\n" ) ; err_ret = - 1 ; } error LM_ERR ( "occurred in rls_handle_subscribe\n" ) ; if ( subs . pres_uri . s != NULL ) { pkg_free ( subs . pres_uri . s ) ; } if ( subs . record_route . s != NULL ) { pkg_free ( subs . record_route . s ) ; } if ( doc != NULL ) { xmlFreeDoc ( doc ) ; } if ( rlsubs_did . s != NULL ) { pkg_free ( rlsubs_did . s ) ; } if ( rls_dbf . abort_transaction ) { if ( rls_dbf . abort_transaction ( rls_db ) < 0 ) { LM_ERR ( "in abort_transaction\n" ) ; } } return err_ret ; } 