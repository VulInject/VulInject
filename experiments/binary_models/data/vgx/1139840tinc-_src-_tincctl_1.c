static int cmd_start ( int argc , char * argv [ ] ) { if ( connect_tincd ( false ) ) { if ( netname ) { fprintf ( stderr , "A tincd is already running for net `%s' with pid %d.\n" , netname , pid ) ; } else { fprintf ( stderr , "A tincd is already running with pid %d.\n" , pid ) ; } return 0 ; } char * c ; char * slash = strrchr ( program_name , '/' ) ; if ( ( c = strrchr ( program_name , '\\' ) ) > slash ) { slash = c ; } if ( slash ++ ) { xasprintf ( & c , "%.*stincd" , ( int ) ( slash - program_name ) , program_name ) ; } else { c = xstrdup ( "tincd" ) ; } int nargc = 0 ; char * * nargv = xzalloc ( ( optind + argc ) * sizeof ( * nargv ) ) ; char * arg0 = c ; xasprintf ( & arg0 , "\"%s\"" , arg0 ) ; nargv [ nargc ++ ] = arg0 ; for ( int i = 1 ; i < optind ; i ++ ) { nargv [ nargc ++ ] = orig_argv [ i ] ; } for ( int i = 1 ; i < argc ; i ++ ) { nargv [ nargc ++ ] = argv [ i ] ; } int status = spawnvp ( _P_WAIT , c , nargv ) ; free ( c ) ; if ( status == - 1 ) { fprintf ( stderr , "Error starting %s: %s\n" , c , strerror ( errno ) ) ; return 1 ; } return status ; int pfd [ 2 ] { - 1 - 1 } ; ; if ( socketpair ( AF_UNIX , SOCK_STREAM , 0 , pfd ) ) { fprintf ( stderr , "Could not create umbilical socket: %s\n" , strerror ( errno ) ) ; free ( nargv ) ; free ( c ) ; return 1 ; } pid_t pid = fork ( ) ; if ( pid == - 1 ) { fprintf ( stderr , "Could not fork: %s\n" , strerror ( errno ) ) ; free ( nargv ) ; free ( c ) ; return 1 ; } if ( ! pid ) { close ( pfd [ 0 ] ) ; char buf [ 100 ] ; snprintf ( buf , sizeof ( buf ) , "%d %d" , pfd [ 1 ] , use_ansi_escapes ( stderr ) ) ; setenv ( "TINC_UMBILICAL" , buf , true ) ; exit ( execvp ( c , nargv ) ) ; } else { close ( pfd [ 1 ] ) ; } free ( nargv ) ; signal ( SIGINT , SIG_IGN ) ; bool failure = true ; uint8_t buf [ 1024 ] ; ssize_t len ; while ( ( len = read ( pfd [ 0 ] , buf , sizeof ( buf ) ) ) > 0 ) { failure = buf [ len - 1 ] ; if ( ! failure ) { len -- ; } if ( write ( 2 , buf , len ) != len ) { } } if ( len ) { failure = true ; } close ( pfd [ 0 ] ) ; int status = - 1 ; pid_t result = waitpid ( pid , & status , 0 ) ; signal ( SIGINT , SIG_DFL ) ; bool failed = failure || result != pid || ! WIFEXITED ( status ) || WEXITSTATUS ( status ) ; if ( failed ) { fprintf ( stderr , "Error starting %s\n" , c ) ; } free ( c ) ; return failed ?EXIT_FAILURE : EXIT_SUCCESS ; } 