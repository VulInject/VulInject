MODULE_DEVICE_TABLE ( of , stm32_iwdg_of_match ) ; static int stm32_iwdg_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct watchdog_device * wdd ; struct stm32_iwdg * wdt ; int ret ; wdt = devm_kzalloc ( dev , sizeof ( * wdt ) , GFP_KERNEL ) ; wdt -> data = of_device_get_match_data ( & pdev -> dev ) ; if ( ! wdt -> data ) { return - ENODEV ; } wdt -> regs = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( wdt -> regs ) ) { return PTR_ERR ( wdt -> regs ) ; } ret = stm32_iwdg_clk_init ( pdev , wdt ) ; if ( ret ) { return ret ; } wdd = & wdt -> wdd ; wdd -> parent = dev ; wdd -> info = & stm32_iwdg_info ; wdd -> ops = & stm32_iwdg_ops ; wdd -> min_timeout = DIV_ROUND_UP ( ( RLR_MIN + 1 ) * PR_MIN , wdt -> rate ) ; wdd -> max_hw_heartbeat_ms = ( ( RLR_MAX + 1 ) * wdt -> data -> max_prescaler * 1000 ) / wdt -> rate ; watchdog_set_drvdata ( wdd , wdt ) ; watchdog_set_nowayout ( wdd , WATCHDOG_NOWAYOUT ) ; watchdog_init_timeout ( wdd , 0 , dev ) ; if ( IS_ENABLED ( CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED ) ) { ret = stm32_iwdg_start ( wdd ) ; if ( ret ) { return ret ; } set_bit ( WDOG_HW_RUNNING , & wdd -> status ) ; } ret = devm_watchdog_register_device ( dev , wdd ) ; if ( ret ) { return ret ; } platform_set_drvdata ( pdev , wdt ) ; return 0 ; } 