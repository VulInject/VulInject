int main ( int argc , char * * argv ) { const char * server = DEFAULT_SERVER ; uint16_t port = DEFAULT_PORT ; size_t compression = DEFAULT_COMPRESS ; int text_mode = 0 ; while ( 1 ) { int n ; int c = getopt ( argc , argv , "s:p:c:dtqvh" ) ; if ( c == - 1 ) { break ; } switch ( c ) { case 's' : server = optarg ; break ; case 'p' : n = atoi ( optarg ) ; if ( n <= 0 || n > 65535 ) { fprintf ( stderr , "Invalid TCP port.\n" ) ; return 1 ; } port = ( uint16_t ) n ; break ; case 'c' : n = atoi ( optarg ) ; if ( n <= 0 ) { fprintf ( stderr , "Invalid compression thoreshold.\n" ) ; return 1 ; } compression = ( size_t ) n ; break ; case 'd' : debug = 1 ; break ; case 't' : text_mode = 1 ; break ; case 'q' : quiet = 1 ; break ; case 'v' : version ( ) ; return 0 ; case 'h' : usage ( ) ; return 0 ; default : return 1 ; } } if ( optind == argc ) { usage ( ) ; return 0 ; } const char * cmd = argv [ optind ] ; argc -= optind + 1 ; argv += optind + 1 ; yrmcds s [ 1 ] ; yrmcds_error e = yrmcds_connect ( s , server , port ) ; CHECK_ERROR ( e ) ; if ( text_mode ) { e = yrmcds_text_mode ( s ) ; CHECK_ERROR ( e ) ; } e = yrmcds_set_compression ( s , compression ) ; if ( e != 0 && e != YRMCDS_NOT_IMPLEMENTED ) { yrmcds_close ( s ) ; CHECK_ERROR ( e ) ; } int ret = 1 ; if ( strcmp ( cmd , # name ) == 0 ) { ret = cmd_ # # name ( argc , argv , s ) ; OUT } do_cmd ( noop ) ; do_cmd ( get ) ; do_cmd ( getk ) ; do_cmd ( gat ) ; do_cmd ( gatk ) ; do_cmd ( lag ) ; do_cmd ( lagk ) ; do_cmd ( touch ) ; do_cmd ( set ) ; do_cmd ( replace ) ; do_cmd ( add ) ; do_cmd ( rau ) ; do_cmd ( incr ) ; do_cmd ( decr ) ; do_cmd ( append ) ; do_cmd ( prepend ) ; do_cmd ( delete ) ; do_cmd ( lock , NULL ) ; do_cmd ( unlock ) ; do_cmd ( unlockall ) ; do_cmd ( flush ) ; do_cmd ( stat ) ; do_cmd ( keys ) ; do_cmd ( version ) ; do_cmd ( quit ) ; fprintf ( stderr , "No such command: %s\n" , cmd ) ; OUT yrmcds_close ( s ) ; return ret ; } 