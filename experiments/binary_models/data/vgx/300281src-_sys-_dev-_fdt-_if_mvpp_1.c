int mvpp2_prs_double_vlan_add ( struct mvpp2_softc * sc , uint16_t tpid1 , uint16_t tpid2 , uint32_t port_map ) { struct mvpp2_prs_entry * pe ; int tid_aux , tid , ai , ret = 0 ; uint32_t ri_bits ; pe = mvpp2_prs_double_vlan_find ( sc , tpid1 , tpid2 ) ; if ( pe == NULL ) { tid = mvpp2_prs_tcam_first_free ( sc , MVPP2_PE_FIRST_FREE_TID , MVPP2_PE_LAST_FREE_TID ) ; if ( tid < 0 ) { return tid ; } pe = malloc ( sizeof ( * pe ) , M_TEMP , M_NOWAIT ) ; if ( pe == NULL ) { return ENOMEM ; } ai = mvpp2_prs_double_vlan_ai_free_get ( sc ) ; if ( ai < 0 ) { ret = ai ; error } for ( tid_aux = MVPP2_PE_FIRST_FREE_TID ; tid_aux <= MVPP2_PE_LAST_FREE_TID ; tid_aux ++ ) { if ( ! sc -> sc_prs_shadow [ tid_aux ] . valid || sc -> sc_prs_shadow [ tid_aux ] . lu != MVPP2_PRS_LU_VLAN ) { continue ; } mvpp2_prs_hw_read ( sc , pe , tid_aux ) ; ri_bits = mvpp2_prs_sram_ri_get ( pe ) ; ri_bits &= MVPP2_PRS_RI_VLAN_MASK ; if ( ri_bits == MVPP2_PRS_RI_VLAN_SINGLE || ri_bits == MVPP2_PRS_RI_VLAN_TRIPLE ) { break ; } } if ( tid >= tid_aux ) { ret = ERANGE ; error } mvpp2_prs_tcam_lu_set ( pe , MVPP2_PRS_LU_VLAN ) ; pe -> index = tid ; sc -> sc_prs_double_vlans [ ai ] = 1 ; mvpp2_prs_match_etype ( pe , 0 , tpid1 ) ; mvpp2_prs_match_etype ( pe , 4 , tpid2 ) ; mvpp2_prs_sram_next_lu_set ( pe , MVPP2_PRS_LU_VLAN ) ; mvpp2_prs_sram_shift_set ( pe , 2 * MVPP2_VLAN_TAG_LEN , MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD ) ; mvpp2_prs_sram_ri_update ( pe , MVPP2_PRS_RI_VLAN_DOUBLE , MVPP2_PRS_RI_VLAN_MASK ) ; mvpp2_prs_sram_ai_update ( pe , ai | MVPP2_PRS_DBL_VLAN_AI_BIT , MVPP2_PRS_SRAM_AI_MASK ) ; mvpp2_prs_shadow_set ( sc , pe -> index , MVPP2_PRS_LU_VLAN ) ; } mvpp2_prs_tcam_port_map_set ( pe , port_map ) ; mvpp2_prs_hw_write ( sc , pe ) ; error free ( pe , M_TEMP , sizeof ( * pe ) ) ; return ret ; } 