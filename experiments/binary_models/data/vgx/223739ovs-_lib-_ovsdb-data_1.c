static struct ovsdb_error * ovsdb_datum_from_json__ ( struct ovsdb_datum * datum , const struct ovsdb_type * type , const struct json * json , struct ovsdb_symbol_table * symtab ) { struct ovsdb_error * error ; if ( ovsdb_type_is_map ( type ) || ( json -> type == JSON_ARRAY && json -> array . n > 0 && json -> array . elems [ 0 ] -> type == JSON_STRING && ! strcmp ( json -> array . elems [ 0 ] -> string , "set" ) ) ) { bool is_map = ovsdb_type_is_map ( type ) ; const char * class = is_map ?"map" : "set" ; const struct json * inner ; unsigned int i ; size_t n ; error = unwrap_json ( json , class , JSON_ARRAY , & inner ) ; n = inner -> array . n ; if ( n ( type -> n_min || n ) type -> n_max ) { if ( type -> n_min == 1 && type -> n_max == 1 ) { return ovsdb_syntax_error ( json , NULL , "%s must have exactly " "one member but %" PRIuSIZE " " "are present" , class , n ) ; } else { return ovsdb_syntax_error ( json , NULL , "%s must have %u to " "%u members but %" PRIuSIZE " are " "present" , class , type -> n_min , type -> n_max , n ) ; } } datum -> n = 0 ; datum -> keys = xmalloc ( n * sizeof datum -> keys ) ; datum -> values = is_map ?xmalloc ( n * sizeof datum -> values ) : NULL ; datum -> refcnt = NULL ; for ( i = 0 ; i < n ; i ++ ) { const struct json * element = inner -> array . elems [ i ] ; const struct json * key = NULL ; const struct json * value = NULL ; if ( ! is_map ) { key = element ; } else { error = parse_json_pair ( element , & key , & value ) ; if ( error ) { error } } error = ovsdb_atom_from_json ( & datum -> keys [ i ] , & type -> key , key , symtab ) ; if ( error ) { error } if ( is_map ) { error = ovsdb_atom_from_json ( & datum -> values [ i ] , & type -> value , value , symtab ) ; if ( error ) { ovsdb_atom_destroy ( & datum -> keys [ i ] , type -> key . type ) ; error } } datum -> n ++ ; } return NULL ; error ovsdb_datum_destroy ( datum , type ) ; return error ; } else { datum -> n = 1 ; datum -> keys = xmalloc ( sizeof datum -> keys ) ; datum -> values = NULL ; datum -> refcnt = NULL ; error = ovsdb_atom_from_json ( & datum -> keys [ 0 ] , & type -> key , json , symtab ) ; if ( error ) { free ( datum -> keys ) ; } return error ; } } 