static inline int fls4 ( int num ) { if ( num & 0x8 ) { return 4 ; } if ( num & 0x4 ) { return 3 ; } if ( num & 0x2 ) { return 2 ; } if ( num & 0x1 ) { return 1 ; } else { return 0 ; } } static struct image_cfg_element * image_cfg ; static int cfgn ; static int verbose_mode ; boot_mode { int id ; const char * name ; } hash_v1 { uint8_t hash [ 32 ] ; } struct boot_mode boot_modes [ ] { { IBR_HDR_I2C_ID "i2c" } { IBR_HDR_SPI_ID "spi" } { IBR_HDR_NAND_ID "nand" } { IBR_HDR_SATA_ID "sata" } { IBR_HDR_PEX_ID "pex" } { IBR_HDR_UART_ID "uart" } { IBR_HDR_SDIO_ID "sdio" } { } } ; ; nand_ecc_mode { unsigned int id ; const char * name ; } struct nand_ecc_mode nand_ecc_modes [ ] { { IBR_HDR_ECC_DEFAULT "default" } { IBR_HDR_ECC_FORCED_HAMMING "hamming" } { IBR_HDR_ECC_FORCED_RS "rs" } { IBR_HDR_ECC_DISABLED "disabled" } { } } ; ; image_cfg_type { IMAGE_CFG_VERSION = 0x1 , IMAGE_CFG_BOOT_FROM , IMAGE_CFG_DEST_ADDR , IMAGE_CFG_EXEC_ADDR , IMAGE_CFG_NAND_BLKSZ , IMAGE_CFG_NAND_BADBLK_LOCATION , IMAGE_CFG_NAND_ECC_MODE , IMAGE_CFG_NAND_PAGESZ , IMAGE_CFG_CPU , IMAGE_CFG_BINARY , IMAGE_CFG_DATA , IMAGE_CFG_DATA_DELAY , IMAGE_CFG_BAUDRATE , IMAGE_CFG_UART_PORT , IMAGE_CFG_UART_MPP , IMAGE_CFG_DEBUG , IMAGE_CFG_KAK , IMAGE_CFG_CSK , IMAGE_CFG_CSK_INDEX , IMAGE_CFG_JTAG_DELAY , IMAGE_CFG_BOX_ID , IMAGE_CFG_FLASH_ID , IMAGE_CFG_SEC_COMMON_IMG , IMAGE_CFG_SEC_SPECIALIZED_IMG , IMAGE_CFG_SEC_BOOT_DEV , IMAGE_CFG_SEC_FUSE_DUMP , IMAGE_CFG_COUNT } , type static const char * const id_strs [ ] { [ IMAGE_CFG_VERSION ] = "VERSION" [ IMAGE_CFG_BOOT_FROM ] = "BOOT_FROM" [ IMAGE_CFG_DEST_ADDR ] = "DEST_ADDR" [ IMAGE_CFG_EXEC_ADDR ] = "EXEC_ADDR" [ IMAGE_CFG_NAND_BLKSZ ] = "NAND_BLKSZ" [ IMAGE_CFG_NAND_BADBLK_LOCATION ] = "NAND_BADBLK_LOCATION" [ IMAGE_CFG_NAND_ECC_MODE ] = "NAND_ECC_MODE" [ IMAGE_CFG_NAND_PAGESZ ] = "NAND_PAGE_SIZE" [ IMAGE_CFG_CPU ] = "CPU" [ IMAGE_CFG_BINARY ] = "BINARY" [ IMAGE_CFG_DATA ] = "DATA" [ IMAGE_CFG_DATA_DELAY ] = "DATA_DELAY" [ IMAGE_CFG_BAUDRATE ] = "BAUDRATE" [ IMAGE_CFG_UART_PORT ] = "UART_PORT" [ IMAGE_CFG_UART_MPP ] = "UART_MPP" [ IMAGE_CFG_DEBUG ] = "DEBUG" [ IMAGE_CFG_KAK ] = "KAK" [ IMAGE_CFG_CSK ] = "CSK" [ IMAGE_CFG_CSK_INDEX ] = "CSK_INDEX" [ IMAGE_CFG_JTAG_DELAY ] = "JTAG_DELAY" [ IMAGE_CFG_BOX_ID ] = "BOX_ID" [ IMAGE_CFG_FLASH_ID ] = "FLASH_ID" [ IMAGE_CFG_SEC_COMMON_IMG ] = "SEC_COMMON_IMG" [ IMAGE_CFG_SEC_SPECIALIZED_IMG ] = "SEC_SPECIALIZED_IMG" [ IMAGE_CFG_SEC_BOOT_DEV ] = "SEC_BOOT_DEV" [ IMAGE_CFG_SEC_FUSE_DUMP ] = "SEC_FUSE_DUMP" } ; ; image_cfg_element { enum image_cfg_type type ; { unsigned int version ; unsigned int cpu_sheeva ; unsigned int bootfrom ; { const char * file ; unsigned int loadaddr ; unsigned int args [ BINARY_MAX_ARGS ] ; unsigned int nargs ; } , binary unsigned int dstaddr ; unsigned int execaddr ; unsigned int nandblksz ; unsigned int nandbadblklocation ; unsigned int nandeccmode ; unsigned int nandpagesz ; struct ext_hdr_v0_reg regdata ; unsigned int regdata_delay ; unsigned int baudrate ; unsigned int uart_port ; unsigned int uart_mpp ; unsigned int debug ; const char * key_name ; int csk_idx ; uint8_t jtag_delay ; uint32_t boxid ; uint32_t flashid ; bool sec_specialized_img ; unsigned int sec_boot_dev ; const char * name ; } } 