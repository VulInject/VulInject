wtap_open_return_val json_open ( wtap * wth , int * err , gchar * * err_info ) { guint8 * filebuf ; int bytes_read ; filebuf = ( guint8 * ) g_malloc0 ( MAX_FILE_SIZE ) ; if ( ! filebuf ) { return WTAP_OPEN_ERROR ; } bytes_read = file_read ( filebuf , MAX_FILE_SIZE , wth -> fh ) ; if ( bytes_read < 0 ) { * err = file_error ( wth -> fh , err_info ) ; return WTAP_OPEN_ERROR ; } if ( bytes_read == 0 ) { g_free ( filebuf ) ; return WTAP_OPEN_NOT_MINE ; } if ( json_validate ( filebuf , bytes_read ) == FALSE ) { g_free ( filebuf ) ; return WTAP_OPEN_NOT_MINE ; } if ( file_seek ( wth -> fh , 0 , SEEK_SET , err ) == - 1 ) { g_free ( filebuf ) ; return WTAP_OPEN_ERROR ; } wth -> file_type_subtype = json_file_type_subtype ; wth -> file_encap = WTAP_ENCAP_JSON ; wth -> file_tsprec = WTAP_TSPREC_SEC ; wth -> subtype_read = wtap_full_file_read ; wth -> subtype_seek_read = wtap_full_file_seek_read ; wth -> snapshot_length = 0 ; g_free ( filebuf ) ; return WTAP_OPEN_MINE ; } 