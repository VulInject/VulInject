static void DestructTCPInstanceData ( wrkrInstanceData_t * pWrkrData ) { doZipFinish ( pWrkrData ) ; if ( pWrkrData -> pNetstrm != NULL ) { netstrm . Destruct ( & pWrkrData -> pNetstrm ) ; } if ( pWrkrData -> pNS != NULL ) { netstrms . Destruct ( & pWrkrData -> pNS ) ; } } BEGINbeginCnfLoad CODESTARTbeginCnfLoad loadModConf = pModConf ; pModConf -> pConf = pConf ; pModConf -> tplName = NULL ; ENDbeginCnfLoad BEGINsetModCnf int i ; CODESTARTsetModCnf const cnfparamvals * const __restrict__ pvals = nvlstGetParams ( lst , & modpblk , NULL ) ; if ( pvals == NULL ) { ABORT_FINALIZE ( RS_RET_MISSING_CNFPARAMS ) ; } if ( Debug ) { dbgprintf ( "module (global) param blk for omfwd:\n" ) ; cnfparamsPrint ( & modpblk , pvals ) ; } for ( i = 0 ; i < modpblk . nParams ; ++ i ) { if ( ! pvals [ i ] . bUsed ) { continue ; } if ( ! strcmp ( modpblk . descr [ i ] . name , "template" ) ) { loadModConf -> tplName = ( uchar * ) es_str2cstr ( pvals [ i ] . val . d . estr , NULL ) ; if ( cs . pszTplName != NULL ) { LogError ( 0 , RS_RET_DUP_PARAM , "omfwd: warning: default template " "was already set via legacy directive - may lead to inconsistent " "results." ) ; } } else { dbgprintf ( "omfwd: program error, non-handled " "param '%s' in beginCnfLoad\n" , modpblk . descr [ i ] . name ) ; } } finalize_it if ( pvals != NULL ) { cnfparamvalsDestruct ( pvals , & modpblk ) ; } ENDsetModCnf BEGINendCnfLoad CODESTARTendCnfLoad loadModConf = NULL ; free ( cs . pszTplName ) ; cs . pszTplName = NULL ; ENDendCnfLoad BEGINcheckCnf CODESTARTcheckCnf ENDcheckCnf BEGINactivateCnf CODESTARTactivateCnf runModConf = pModConf ; ENDactivateCnf BEGINfreeCnf CODESTARTfreeCnf free ( pModConf -> tplName ) ENDfreeCnf BEGINcreateInstance CODESTARTcreateInstance ( cs . pszStrmDrvr != NULL ) CHKmalloc ( pData -> pszStrmDrvr = ( uchar * ) strdup ( ( char * ) cs . pszStrmDrvr ) ) ; if ( cs . pszStrmDrvrAuthMode != NULL ) { CHKmalloc ( pData -> pszStrmDrvrAuthMode = ( uchar * ) strdup ( ( char * ) cs . pszStrmDrvrAuthMode ) ) ; } finalize_it ENDcreateInstance BEGINcreateWrkrInstance CODESTARTcreateWrkrInstance dbgprintf ( "DDDD: createWrkrInstance: pWrkrData %p\n" , pWrkrData ) ; pWrkrData -> offsSndBuf = 0 ; iRet = initTCP ( pWrkrData ) ; ENDcreateWrkrInstance BEGINisCompatibleWithFeature CODESTARTisCompatibleWithFeature ( eFeat == sFEATURERepeatedMsgReduction ) iRet = RS_RET_OK ; ENDisCompatibleWithFeature BEGINfreeInstance CODESTARTfreeInstance ( pData -> stats != NULL ) statsobj . Destruct ( & ( pData -> stats ) ) ; free ( pData -> pszStrmDrvrAuthMode ) ; free ( pData -> pszStrmDrvrPermitExpiredCerts ) ; free ( pData -> gnutlsPriorityString ) ; free ( pData -> port ) ; free ( pData -> networkNamespace ) ; free ( pData -> target ) ; free ( pData -> address ) ; free ( pData -> device ) ; free ( ( void * ) pData -> pszStrmDrvrCAFile ) ; free ( ( void * ) pData -> pszStrmDrvrKeyFile ) ; free ( ( void * ) pData -> pszStrmDrvrCertFile ) ; net . DestructPermittedPeers ( & pData -> pPermPeers ) ; if ( pData -> ratelimiter != NULL ) { ratelimitDestruct ( pData -> ratelimiter ) ; pData -> ratelimiter = NULL ; } ENDfreeInstance BEGINfreeWrkrInstance CODESTARTfreeWrkrInstance DestructTCPInstanceData ( pWrkrData ) closeUDPSockets ( pWrkrData ) ; if ( pWrkrData -> pData -> protocol == FORW_TCP ) { tcpclt . Destruct ( & pWrkrData -> pTCPClt ) ; } ENDfreeWrkrInstance BEGINdbgPrintInstInfo CODESTARTdbgPrintInstInfo dbgprintf ( "omfwd\n" ) ; dbgprintf ( "\ttarget='%s'\n" , pData -> target ) ; dbgprintf ( "\tratelimit.interval='%u'\n" , pData -> ratelimitInterval ) ; dbgprintf ( "\tratelimit.burst='%u'\n" , pData -> ratelimitBurst ) ; ENDdbgPrintInstInfo static rsRetVal UDPSend ( wrkrInstanceData_t * __restrict__ const pWrkrData , uchar * __restrict__ const msg , size_t len ) { DEFiRet ; struct addrinfo * r ; int i ; ssize_t lsent = 0 ; sbool bSendSuccess ; sbool reInit = RSFALSE ; int lasterrno = ENOENT ; int lasterr_sock = - 1 ; if ( pWrkrData -> pData -> iRebindInterval && ( pWrkrData -> nXmit ++ % pWrkrData -> pData -> iRebindInterval == 0 ) ) { dbgprintf ( "omfwd dropping UDP 'connection' (as configured)\n" ) ; pWrkrData -> nXmit = 1 ; CHKiRet ( closeUDPSockets ( pWrkrData ) ) ; } if ( pWrkrData -> pSockArray == NULL ) { CHKiRet ( doTryResume ( pWrkrData ) ) ; } if ( pWrkrData -> pSockArray == NULL ) { FINALIZE ; } if ( len > UDP_MAX_MSGSIZE ) { LogError ( 0 , RS_RET_UDP_MSGSIZE_TOO_LARGE , "omfwd/udp: message is %u " "bytes long, but UDP can send at most %d bytes (by RFC limit) " "- truncating message" , ( unsigned ) len , UDP_MAX_MSGSIZE ) ; len = UDP_MAX_MSGSIZE ; } bSendSuccess = RSFALSE ; for ( r = pWrkrData -> f_addr ; r ; r = r -> ai_next ) { int runSockArrayLoop = 1 ; for ( i = 0 ; runSockArrayLoop && ( i < * pWrkrData -> pSockArray ) ; i ++ ) { int try_send = 1 ; size_t lenThisTry = len ; while ( try_send ) { lsent = sendto ( pWrkrData -> pSockArray [ i + 1 ] , msg , lenThisTry , 0 , r -> ai_addr , r -> ai_addrlen ) ; if ( lsent == ( ssize_t ) lenThisTry ) { bSendSuccess = RSTRUE ; ATOMIC_ADD_uint64 ( & pWrkrData -> pData -> sentBytes , & pWrkrData -> pData -> mut_sentBytes , lenThisTry ) ; try_send = 0 ; runSockArrayLoop = 0 ; } if ( errno == EMSGSIZE ) { const size_t newlen = ( lenThisTry > 1024 ) ?lenThisTry - 1024 : 512 ; LogError ( 0 , RS_RET_UDP_MSGSIZE_TOO_LARGE , "omfwd/udp: send failed due to message being too " "large for this system. Message size was %u bytes. " "Truncating to %u bytes and retrying." , ( unsigned ) lenThisTry , ( unsigned ) newlen ) ; lenThisTry = newlen ; } else { reInit = RSTRUE ; lasterrno = errno ; lasterr_sock = pWrkrData -> pSockArray [ i + 1 ] ; LogError ( lasterrno , RS_RET_ERR_UDPSEND , "omfwd/udp: socket %d: sendto() error" , lasterr_sock ) ; try_send = 0 ; } } } if ( lsent == ( ssize_t ) len && ! pWrkrData -> pData -> bSendToAll ) { break ; } } if ( reInit == RSTRUE ) { CHKiRet ( closeUDPSockets ( pWrkrData ) ) ; } if ( bSendSuccess == RSTRUE ) { if ( pWrkrData -> pData -> iUDPSendDelay > 0 ) { srSleep ( pWrkrData -> pData -> iUDPSendDelay / 1000000 , pWrkrData -> pData -> iUDPSendDelay % 1000000 ) ; } } else { LogError ( lasterrno , RS_RET_ERR_UDPSEND , "omfwd: socket %d: error %d sending via udp" , lasterr_sock , lasterrno ) ; iRet = RS_RET_SUSPENDED ; } finalize_it RETiRet ; } 