static int ti_qspi_xfer ( struct udevice * dev , unsigned int bitlen , const void * dout , void * din , unsigned long flags ) { struct dm_spi_slave_plat * slave = dev_get_parent_plat ( dev ) ; struct ti_qspi_priv * priv ; struct udevice * bus ; uint words = bitlen >> 3 ; const uchar * txp = dout ; uchar * rxp = din ; uint status ; int timeout ; unsigned int cs = slave -> cs ; bus = dev -> parent ; priv = dev_get_priv ( bus ) ; if ( cs > priv -> num_cs ) { debug ( "invalid qspi chip select\n" ) ; return - EINVAL ; } if ( bitlen % 8 ) { debug ( "spi_xfer: Non byte aligned SPI transfer\n" ) ; return - 1 ; } priv -> cmd = 0 ; priv -> cmd |= QSPI_WLEN ( 8 ) ; priv -> cmd |= QSPI_EN_CS ( cs ) ; if ( priv -> mode & SPI_3WIRE ) { priv -> cmd |= QSPI_3_PIN ; } priv -> cmd |= 0xfff ; while ( words ) { u8 xfer_len = 0 ; if ( txp ) { u32 cmd = priv -> cmd ; if ( words >= QSPI_WLEN_MAX_BYTES ) { u32 * txbuf = ( u32 * ) txp ; u32 data ; data = cpu_to_be32 ( * txbuf ++ ) ; writel ( data , & priv -> base -> data3 ) ; data = cpu_to_be32 ( * txbuf ++ ) ; writel ( data , & priv -> base -> data2 ) ; data = cpu_to_be32 ( * txbuf ++ ) ; writel ( data , & priv -> base -> data1 ) ; data = cpu_to_be32 ( * txbuf ++ ) ; writel ( data , & priv -> base -> data ) ; cmd &= ~ QSPI_WLEN_MASK ; cmd |= QSPI_WLEN ( QSPI_WLEN_MAX_BITS ) ; xfer_len = QSPI_WLEN_MAX_BYTES ; } else { writeb ( * txp , & priv -> base -> data ) ; xfer_len = 1 ; } debug ( "tx cmd %08x dc %08x\n" , cmd | QSPI_WR_SNGL , priv -> dc ) ; writel ( cmd | QSPI_WR_SNGL , & priv -> base -> cmd ) ; status = readl ( & priv -> base -> status ) ; timeout = QSPI_TIMEOUT ; while ( ( status & QSPI_WC_BUSY ) != QSPI_XFER_DONE ) { if ( -- timeout < 0 ) { printf ( "spi_xfer: TX timeout!\n" ) ; return - 1 ; } status = readl ( & priv -> base -> status ) ; } txp += xfer_len ; debug ( "tx done, status %08x\n" , status ) ; } if ( rxp ) { debug ( "rx cmd %08x dc %08x\n" , ( ( u32 ) ( priv -> cmd | QSPI_RD_SNGL ) ) , priv -> dc ) ; writel ( priv -> cmd | QSPI_RD_SNGL , & priv -> base -> cmd ) ; status = readl ( & priv -> base -> status ) ; timeout = QSPI_TIMEOUT ; while ( ( status & QSPI_WC_BUSY ) != QSPI_XFER_DONE ) { if ( -- timeout < 0 ) { printf ( "spi_xfer: RX timeout!\n" ) ; return - 1 ; } status = readl ( & priv -> base -> status ) ; } * rxp ++ = readl ( & priv -> base -> data ) ; xfer_len = 1 ; debug ( "rx done, status %08x, read %02x\n" , status , * ( rxp - 1 ) ) ; } words -= xfer_len ; } if ( flags & SPI_XFER_END ) { ti_qspi_cs_deactivate ( priv ) ; } return 0 ; } 