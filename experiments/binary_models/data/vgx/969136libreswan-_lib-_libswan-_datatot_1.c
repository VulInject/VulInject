int format , char * dst , size_t dstlen { size_t inblocksize ; size_t outblocksize ; size_t breakevery ; size_t sincebreak ; char breakchar ; unsigned char inblock [ 10 ] ; char outblock [ 10 ] ; char fake [ 1 ] ; size_t needed ; char * stop ; size_t ntodo ; size_t nreal ; char * out ; char * prefix ; breakevery = 0 ; breakchar = '_' ; switch ( format ) { case 0 : case 'h' : breakevery = 8 ; inblocksize = 1 ; outblocksize = 2 ; prefix = "0x" ; format = 'x' ; break ; case 'x' : inblocksize = 1 ; outblocksize = 2 ; prefix = "0x" ; break ; case ':' : breakevery = 2 ; breakchar = ':' ; inblocksize = 1 ; outblocksize = 2 ; prefix = "" ; format = 'x' ; break ; case 16 : inblocksize = 1 ; outblocksize = 2 ; prefix = "" ; format = 'x' ; break ; case 's' : inblocksize = 3 ; outblocksize = 4 ; prefix = "0s" ; break ; case 64 : inblocksize = 3 ; outblocksize = 4 ; prefix = "" ; format = 's' ; break ; default : return 0 ; } passert ( inblocksize < sizeof ( inblock ) ) ; passert ( outblocksize < sizeof ( outblock ) ) ; passert ( breakevery % outblocksize == 0 ) ; if ( srclen == 0 ) { return 0 ; } ntodo = srclen ; if ( dstlen == 0 ) { dst = fake ; dstlen = 1 ; } stop = dst + dstlen - 1 ; nreal = strlen ( prefix ) ; needed = nreal ; if ( dstlen <= nreal ) { strncpy ( dst , prefix , dstlen - 1 ) ; dst [ dstlen - 1 ] = '\0' ; dst += dstlen - 1 ; } else { strcpy ( dst , prefix ) ; dst += nreal ; } passert ( dst <= stop ) ; sincebreak = 0 ; while ( ntodo > 0 ) { if ( ntodo < inblocksize ) { memcpy ( inblock , src , ntodo ) ; src = inblock ; nreal = ntodo ; ntodo = inblocksize ; } else { nreal = inblocksize ; } out = ( ( ptrdiff_t ) outblocksize > stop - dst ) ?outblock : dst ; convert ( ( const char * ) src , nreal , format , out ) ; needed += outblocksize ; sincebreak += outblocksize ; if ( dst < stop ) { if ( out != dst ) { passert ( ( ptrdiff_t ) outblocksize > stop - dst ) ; memcpy ( dst , out , stop - dst ) ; dst = stop ; } else { dst += outblocksize ; } } src += inblocksize ; ntodo -= inblocksize ; if ( breakevery != 0 && sincebreak >= breakevery && ntodo > 0 ) { if ( dst < stop ) { * dst ++ = breakchar ; } needed ++ ; sincebreak = 0 ; } } passert ( dst <= stop ) ; * dst ++ = '\0' ; needed ++ ; return needed ; } ; 