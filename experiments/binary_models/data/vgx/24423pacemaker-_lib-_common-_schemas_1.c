void crm_schema_init ( void ) { int lpc , max ; char * base = pcmk__xml_artefact_root ( pcmk__xml_artefact_ns_legacy_rng ) ; struct dirent * * namelist = NULL ; const schema_version_t zero = SCHEMA_ZERO ; wrap_libxslt ( false ) ; max = scandir ( base , & namelist , schema_filter , schema_sort ) ; if ( max < 0 ) { crm_notice ( "scandir(%s) failed: %s (%d)" , base , strerror ( errno ) , errno ) ; free ( base ) ; } else { free ( base ) ; for ( lpc = 0 ; lpc < max ; lpc ++ ) { bool transform_expected = FALSE ; int next = 0 ; schema_version_t version = SCHEMA_ZERO ; if ( ! version_from_filename ( namelist [ lpc ] -> d_name , & version ) ) { crm_err ( "Skipping schema '%s': could not parse version" , namelist [ lpc ] -> d_name ) ; continue ; } if ( ( lpc + 1 ) < max ) { schema_version_t next_version = SCHEMA_ZERO ; if ( version_from_filename ( namelist [ lpc + 1 ] -> d_name , & next_version ) && ( version . v [ 0 ] < next_version . v [ 0 ] ) ) { transform_expected = TRUE ; } } else { next = - 1 ; } if ( add_schema_by_version ( & version , next , transform_expected ) == ENOENT ) { break ; } } for ( lpc = 0 ; lpc < max ; lpc ++ ) { free ( namelist [ lpc ] ) ; } } add_schema ( schema_validator_rng , & zero , "pacemaker-next" , NULL , NULL , FALSE , - 1 ) ; add_schema ( schema_validator_none , & zero , PCMK__VALUE_NONE , NULL , NULL , FALSE , - 1 ) ; } 