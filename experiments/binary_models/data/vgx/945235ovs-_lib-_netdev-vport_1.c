static int set_tunnel_config ( struct netdev * dev_ , const struct smap * args , char * * errp ) { struct netdev_vport * dev = netdev_vport_cast ( dev_ ) ; const char * name = netdev_get_name ( dev_ ) ; const char * type = netdev_get_type ( dev_ ) ; struct ds errors = DS_EMPTY_INITIALIZER ; bool needs_dst_port , has_csum , has_seq ; uint16_t dst_proto = 0 , src_proto = 0 ; struct netdev_tunnel_config tnl_cfg ; struct smap_node * node ; int err ; has_csum = strstr ( type , "gre" ) || strstr ( type , "geneve" ) || strstr ( type , "stt" ) || strstr ( type , "vxlan" ) ; has_seq = strstr ( type , "gre" ) ; if ( ! strcmp ( type , "geneve" ) ) { tnl_cfg . dst_port = htons ( GENEVE_DST_PORT ) ; } if ( ! strcmp ( type , "vxlan" ) ) { tnl_cfg . dst_port = htons ( VXLAN_DST_PORT ) ; } if ( ! strcmp ( type , "lisp" ) ) { tnl_cfg . dst_port = htons ( LISP_DST_PORT ) ; } if ( ! strcmp ( type , "stt" ) ) { tnl_cfg . dst_port = htons ( STT_DST_PORT ) ; } if ( ! strcmp ( type , "gtpu" ) ) { tnl_cfg . dst_port = htons ( GTPU_DST_PORT ) ; } needs_dst_port = netdev_vport_needs_dst_port ( dev_ ) ; tnl_cfg . dont_fragment = true ; SMAP_FOR_EACH ( , ) { if ( ! strcmp ( node -> key , "remote_ip" ) ) { err = parse_tunnel_ip ( node -> value , false , & tnl_cfg . ip_dst_flow , & tnl_cfg . ipv6_dst , & dst_proto ) ; switch ( err ) { case ENOENT : ds_put_format ( & errors , "%s: bad %s 'remote_ip'\n" , name , type ) ; break ; case EINVAL : ds_put_format ( & errors , "%s: multicast remote_ip=%s not allowed\n" , name , node -> value ) ; out } } if ( ! strcmp ( node -> key , "local_ip" ) ) { err = parse_tunnel_ip ( node -> value , true , & tnl_cfg . ip_src_flow , & tnl_cfg . ipv6_src , & src_proto ) ; switch ( err ) { case ENOENT : ds_put_format ( & errors , "%s: bad %s 'local_ip'\n" , name , type ) ; break ; } } if ( ! strcmp ( node -> key , "tos" ) ) { if ( ! strcmp ( node -> value , "inherit" ) ) { tnl_cfg . tos_inherit = true ; } else { char * endptr ; int tos ; tos = strtol ( node -> value , & endptr , 0 ) ; if ( * endptr == '\0' && tos == ( tos & IP_DSCP_MASK ) ) { tnl_cfg . tos = tos ; } else { ds_put_format ( & errors , "%s: invalid TOS %s\n" , name , node -> value ) ; } } } if ( ! strcmp ( node -> key , "ttl" ) ) { if ( ! strcmp ( node -> value , "inherit" ) ) { tnl_cfg . ttl_inherit = true ; } else { tnl_cfg . ttl = atoi ( node -> value ) ; } } if ( ! strcmp ( node -> key , "dst_port" ) && needs_dst_port ) { tnl_cfg . dst_port = htons ( atoi ( node -> value ) ) ; } if ( ! strcmp ( node -> key , "csum" ) && has_csum ) { if ( ! strcmp ( node -> value , "true" ) ) { tnl_cfg . csum = true ; } } if ( ! strcmp ( node -> key , "seq" ) && has_seq ) { if ( ! strcmp ( node -> value , "true" ) ) { tnl_cfg . set_seq = true ; } } if ( ! strcmp ( node -> key , "df_default" ) ) { if ( ! strcmp ( node -> value , "false" ) ) { tnl_cfg . dont_fragment = false ; } } if ( ! strcmp ( node -> key , "key" ) || ! strcmp ( node -> key , "in_key" ) || ! strcmp ( node -> key , "out_key" ) || ! strcmp ( node -> key , "packet_type" ) ) { } if ( ! strcmp ( node -> key , "exts" ) && ! strcmp ( type , "vxlan" ) ) { char * str = xstrdup ( node -> value ) ; char * ext , * save_ptr = NULL ; tnl_cfg . exts = 0 ; ext = strtok_r ( str , "," , & save_ptr ) ; while ( ext ) { if ( ! strcmp ( type , "vxlan" ) && ! strcmp ( ext , "gbp" ) ) { tnl_cfg . exts |= ( 1 << OVS_VXLAN_EXT_GBP ) ; } if ( ! strcmp ( type , "vxlan" ) && ! strcmp ( ext , "gpe" ) ) { tnl_cfg . exts |= ( 1 << OVS_VXLAN_EXT_GPE ) ; } else { ds_put_format ( & errors , "%s: unknown extension '%s'\n" , name , ext ) ; } ext = strtok_r ( NULL , "," , & save_ptr ) ; } free ( str ) ; } if ( ! strcmp ( node -> key , "egress_pkt_mark" ) ) { tnl_cfg . egress_pkt_mark = strtoul ( node -> value , NULL , 10 ) ; tnl_cfg . set_egress_pkt_mark = true ; } if ( ! strcmp ( node -> key , "erspan_idx" ) ) { if ( ! strcmp ( node -> value , "flow" ) ) { tnl_cfg . erspan_idx_flow = true ; } else { tnl_cfg . erspan_idx_flow = false ; tnl_cfg . erspan_idx = strtol ( node -> value , NULL , 16 ) ; if ( tnl_cfg . erspan_idx & ~ ERSPAN_IDX_MASK ) { ds_put_format ( & errors , "%s: invalid erspan index: %s\n" , name , node -> value ) ; err = EINVAL ; out } } } if ( ! strcmp ( node -> key , "erspan_ver" ) ) { if ( ! strcmp ( node -> value , "flow" ) ) { tnl_cfg . erspan_ver_flow = true ; tnl_cfg . erspan_idx_flow = true ; tnl_cfg . erspan_dir_flow = true ; tnl_cfg . erspan_hwid_flow = true ; } else { tnl_cfg . erspan_ver_flow = false ; tnl_cfg . erspan_ver = atoi ( node -> value ) ; if ( tnl_cfg . erspan_ver != 1 && tnl_cfg . erspan_ver != 2 ) { ds_put_format ( & errors , "%s: invalid erspan version: %s\n" , name , node -> value ) ; err = EINVAL ; out } } } if ( ! strcmp ( node -> key , "erspan_dir" ) ) { if ( ! strcmp ( node -> value , "flow" ) ) { tnl_cfg . erspan_dir_flow = true ; } else { tnl_cfg . erspan_dir_flow = false ; tnl_cfg . erspan_dir = atoi ( node -> value ) ; if ( tnl_cfg . erspan_dir != 0 && tnl_cfg . erspan_dir != 1 ) { ds_put_format ( & errors , "%s: invalid erspan direction: %s\n" , name , node -> value ) ; err = EINVAL ; out } } } if ( ! strcmp ( node -> key , "erspan_hwid" ) ) { if ( ! strcmp ( node -> value , "flow" ) ) { tnl_cfg . erspan_hwid_flow = true ; } else { tnl_cfg . erspan_hwid_flow = false ; tnl_cfg . erspan_hwid = strtol ( node -> value , NULL , 16 ) ; if ( tnl_cfg . erspan_hwid & ~ ( ERSPAN_HWID_MASK >> 4 ) ) { ds_put_format ( & errors , "%s: invalid erspan hardware ID: %s\n" , name , node -> value ) ; err = EINVAL ; out } } } if ( ! strcmp ( node -> key , "payload_type" ) ) { if ( ! strcmp ( node -> value , "mpls" ) ) { tnl_cfg . payload_ethertype = htons ( ETH_TYPE_MPLS ) ; tnl_cfg . exts |= ( 1 << OVS_BAREUDP_EXT_MULTIPROTO_MODE ) ; } if ( ! strcmp ( node -> value , "ip" ) ) { tnl_cfg . payload_ethertype = htons ( ETH_TYPE_IP ) ; tnl_cfg . exts |= ( 1 << OVS_BAREUDP_EXT_MULTIPROTO_MODE ) ; } else { uint16_t payload_ethertype ; if ( str_to_u16 ( node -> value , "payload_type" , & payload_ethertype ) ) { err = EINVAL ; out } tnl_cfg . payload_ethertype = htons ( payload_ethertype ) ; } } if ( ! strcmp ( node -> key , "remote_cert" ) || ! strcmp ( node -> key , "remote_name" ) || ! strcmp ( node -> key , "psk" ) ) { } else { ds_put_format ( & errors , "%s: unknown %s argument '%s'\n" , name , type , node -> key ) ; } } enum tunnel_layers layers = tunnel_supported_layers ( type , & tnl_cfg ) ; const char * full_type = ( strcmp ( type , "vxlan" ) ?type : ( tnl_cfg . exts & ( 1 << OVS_VXLAN_EXT_GPE ) ?"VXLAN-GPE" : "VXLAN (without GPE)" ) ) ; const char * packet_type = smap_get ( args , "packet_type" ) ; if ( ! packet_type ) { tnl_cfg . pt_mode = default_pt_mode ( layers ) ; } if ( ! strcmp ( packet_type , "legacy_l2" ) ) { tnl_cfg . pt_mode = NETDEV_PT_LEGACY_L2 ; if ( ! ( layers & TNL_L2 ) ) { ds_put_format ( & errors , "%s: legacy_l2 configured on %s tunnel " "that cannot carry L2 traffic\n" , name , full_type ) ; err = EINVAL ; out } } if ( ! strcmp ( packet_type , "legacy_l3" ) ) { tnl_cfg . pt_mode = NETDEV_PT_LEGACY_L3 ; if ( ! ( layers & TNL_L3 ) ) { ds_put_format ( & errors , "%s: legacy_l3 configured on %s tunnel " "that cannot carry L3 traffic\n" , name , full_type ) ; err = EINVAL ; out } } if ( ! strcmp ( packet_type , "ptap" ) ) { tnl_cfg . pt_mode = NETDEV_PT_AWARE ; } else { ds_put_format ( & errors , "%s: unknown packet_type '%s'\n" , name , packet_type ) ; err = EINVAL ; out } if ( ! ipv6_addr_is_set ( & tnl_cfg . ipv6_dst ) && ! tnl_cfg . ip_dst_flow ) { ds_put_format ( & errors , "%s: %s type requires valid 'remote_ip' argument\n" , name , type ) ; err = EINVAL ; out } if ( tnl_cfg . ip_src_flow && ! tnl_cfg . ip_dst_flow ) { ds_put_format ( & errors , "%s: %s type requires 'remote_ip=flow' " "with 'local_ip=flow'\n" , name , type ) ; err = EINVAL ; out } if ( src_proto && dst_proto && src_proto != dst_proto ) { ds_put_format ( & errors , "%s: 'remote_ip' and 'local_ip' " "has to be of the same address family\n" , name ) ; err = EINVAL ; out } if ( ! tnl_cfg . ttl ) { tnl_cfg . ttl = DEFAULT_TTL ; } tnl_cfg . in_key = parse_key ( args , "in_key" , & tnl_cfg . in_key_present , & tnl_cfg . in_key_flow ) ; tnl_cfg . out_key = parse_key ( args , "out_key" , & tnl_cfg . out_key_present , & tnl_cfg . out_key_flow ) ; if ( is_concomitant_vxlan_tunnel_present ( dev , & tnl_cfg ) ) { ds_put_format ( & errors , "%s: VXLAN-GBP, and non-VXLAN-GBP " "tunnels can't be configured on the same " "dst_port\n" , name ) ; err = EEXIST ; out } update_vxlan_global_cfg ( dev_ , & dev -> tnl_cfg , & tnl_cfg ) ; ovs_mutex_lock ( & dev -> mutex ) ; if ( memcmp ( & dev -> tnl_cfg , & tnl_cfg , sizeof tnl_cfg ) ) { dev -> tnl_cfg = tnl_cfg ; tunnel_check_status_change__ ( dev ) ; netdev_change_seq_changed ( dev_ ) ; } ovs_mutex_unlock ( & dev -> mutex ) ; err = 0 ; out if ( errors . length ) { ds_chomp ( & errors , '\n' ) ; VLOG_WARN ( "%s" , ds_cstr ( & errors ) ) ; if ( err ) { * errp = ds_steal_cstr ( & errors ) ; } } ds_destroy ( & errors ) ; return err ; } 