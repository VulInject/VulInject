Elf * _libelf_open_object ( int fd , Elf_Cmd c , int reporterror ) { Elf * e ; void * m ; mode_t mode ; size_t fsize ; struct stat sb ; unsigned int flags ; assert ( c == ELF_C_READ || c == ELF_C_RDWR || c == ELF_C_WRITE ) ; if ( fstat ( fd , & sb ) < 0 ) { LIBELF_SET_ERROR ( IO , errno ) ; return ( NULL ) ; } mode = sb . st_mode ; fsize = ( size_t ) sb . st_size ; if ( ! S_ISREG ( mode ) && ! S_ISCHR ( mode ) && ! S_ISFIFO ( mode ) && ! S_ISSOCK ( mode ) ) { LIBELF_SET_ERROR ( ARGUMENT , 0 ) ; return ( NULL ) ; } if ( c == ELF_C_WRITE ) { if ( ( e = _libelf_allocate_elf ( ) ) != NULL ) { _libelf_init_elf ( e , ELF_K_ELF ) ; e -> e_byteorder = LIBELF_PRIVATE ( byteorder ) ; e -> e_fd = fd ; e -> e_cmd = c ; if ( ! S_ISREG ( mode ) ) { e -> e_flags |= LIBELF_F_SPECIAL_FILE ; } } return ( e ) ; } m = NULL ; flags = 0 ; if ( S_ISREG ( mode ) ) { if ( fsize == 0 ) { LIBELF_SET_ERROR ( ARGUMENT , 0 ) ; return ( NULL ) ; } m = mmap ( NULL , fsize , PROT_READ , MAP_PRIVATE , fd , ( off_t ) 0 ) ; if ( m == MAP_FAILED ) { m = NULL ; } else { flags = LIBELF_F_RAWFILE_MMAP ; } if ( m == NULL ) { if ( ( m = malloc ( fsize ) ) == NULL ) { LIBELF_SET_ERROR ( RESOURCE , 0 ) ; return ( NULL ) ; } if ( read ( fd , m , fsize ) != ( ssize_t ) fsize ) { LIBELF_SET_ERROR ( IO , errno ) ; return ( NULL ) ; } flags = LIBELF_F_RAWFILE_MALLOC ; } } if ( ( m = _libelf_read_special_file ( fd , & fsize ) ) != NULL ) { flags = LIBELF_F_RAWFILE_MALLOC | LIBELF_F_SPECIAL_FILE ; } else { return ( NULL ) ; } if ( ( e = _libelf_memory ( m , fsize , reporterror ) ) == NULL ) { assert ( ( flags & LIBELF_F_RAWFILE_MALLOC ) || ( flags & LIBELF_F_RAWFILE_MMAP ) ) ; if ( flags & LIBELF_F_RAWFILE_MALLOC ) { free ( m ) ; } else { ( void ) munmap ( m , fsize ) ; } return ( NULL ) ; } if ( c == ELF_C_RDWR && e -> e_kind == ELF_K_AR ) { ( void ) elf_end ( e ) ; LIBELF_SET_ERROR ( ARGUMENT , 0 ) ; return ( NULL ) ; } e -> e_flags |= flags ; e -> e_fd = fd ; e -> e_cmd = c ; return ( e ) ; } 