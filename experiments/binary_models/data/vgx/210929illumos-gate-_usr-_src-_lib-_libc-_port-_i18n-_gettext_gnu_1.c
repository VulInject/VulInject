static uint32_t * do_conv ( iconv_t fd , const char * src , uint32_t srclen ) { uint32_t tolen ; uint32_t * ptr , * optr ; size_t oleft , ileft , bufsize , memincr ; char * to , * tptr ; gprintf ( 0 , "*************** do_conv(" "0x%p, \"%s\", %d)\n" , ( void * ) fd , src ?src : "(null)" , srclen ) ; memincr = srclen * 2 ; bufsize = memincr ; ileft = srclen ; oleft = bufsize ; ptr = malloc ( bufsize + sizeof ( uint32_t ) ) ; if ( ptr == NULL ) { return ( NULL ) ; } to = ( char * ) ( ptr + 1 ) ; for ( ; ; ) { tptr = to ; errno = 0 ; gprintf ( 0 , "******* calling iconv()\n" ) ; if ( iconv ( fd , & src , & ileft , & tptr , & oleft ) == ( size_t ) - 1 ) { if ( errno == E2BIG ) { gprintf ( 0 , "******* iconv detected E2BIG\n" ) ; gprintf ( 0 , "old bufsize: %u\n" , bufsize ) ; optr = realloc ( ptr , bufsize + memincr + sizeof ( uint32_t ) ) ; if ( optr == NULL ) { return ( NULL ) ; } ptr = optr ; to = ( char * ) ( optr + 1 ) ; to += bufsize - oleft ; oleft += memincr ; bufsize += memincr ; gprintf ( 0 , "new bufsize: %u\n" , bufsize ) ; continue ; } else { tolen = ( uint32_t ) ( bufsize - oleft ) ; break ; } } tolen = ( uint32_t ) ( bufsize - oleft ) ; break ; } if ( tolen < bufsize ) { optr = realloc ( ptr , tolen + sizeof ( uint32_t ) ) ; if ( optr == NULL ) { free ( ptr ) ; return ( NULL ) ; } ptr = optr ; } * ptr = tolen ; gprintf ( 0 , "******* exiting do_conv()\n" ) ; gprintf ( 0 , "tolen: %u\n" , * ptr ) ; gprintf ( 0 , "return: 0x%p\n" , ptr ) ; return ( ptr ) ; } 