JNIEXPORT jintArray JNICALL Java_com_sun_solaris_service_locality_LocalityGroup_jl_1cpus ( JNIEnv * env , jobject obj ) { jclass clazz ; jfieldID fid ; lgrp_cookie_t cookie ; jlong id ; jsize ncpus0 , ncpus ; jintArray cpus ; int i ; processorid_t * native_cpus ; jint * java_cpus ; jobject domain ; clazz = ( * env ) -> GetObjectClass ( env , obj ) ; fid = ( * env ) -> GetFieldID ( env , clazz , "domain" , "Lcom/sun/solaris/service/locality/LocalityDomain;" ) ; domain = ( * env ) -> GetObjectField ( env , obj , fid ) ; cookie = getCookie ( env , ( * env ) -> GetObjectClass ( env , domain ) , domain ) ; fid = ( * env ) -> GetFieldID ( env , clazz , "id" , "J" ) ; id = ( * env ) -> GetLongField ( env , obj , fid ) ; retry ncpus0 = ( jsize ) lgrp_cpus ( ( lgrp_cookie_t ) cookie , ( lgrp_id_t ) id , NULL , 0 , LGRP_CONTENT_DIRECT ) ; cpus = ( * env ) -> NewIntArray ( env , ncpus0 ) ; if ( ( native_cpus = calloc ( ncpus0 , sizeof ( processorid_t ) ) ) == NULL ) { throwException ( env , "java/lang/Exception" , "Could not allocate memory for native_cpus array" ) ; return ( NULL ) ; } ncpus = ( jsize ) lgrp_cpus ( ( lgrp_cookie_t ) cookie , ( lgrp_id_t ) id , native_cpus , ncpus0 , LGRP_CONTENT_DIRECT ) ; if ( ncpus != ncpus0 ) { retry } if ( ( java_cpus = calloc ( ncpus , sizeof ( jint ) ) ) == NULL ) { free ( native_cpus ) ; throwException ( env , "java/lang/Exception" , "Could not allocate memory for java_cpus array" ) ; return ( NULL ) ; } for ( i = 0 ; i < ncpus ; i ++ ) { java_cpus [ i ] = ( jint ) native_cpus [ i ] ; } ( * env ) -> SetIntArrayRegion ( env , cpus , 0 , ncpus , java_cpus ) ; free ( native_cpus ) ; free ( java_cpus ) ; return ( cpus ) ; } 