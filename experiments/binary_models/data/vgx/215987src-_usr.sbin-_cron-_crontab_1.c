static void edit_cmd ( void ) { char n [ PATH_MAX ] , q [ MAX_TEMPSTR ] ; FILE * f ; int t ; struct stat statbuf , xstatbuf ; struct timespec ts [ 2 ] ; syslog ( LOG_INFO , "(%s) BEGIN EDIT (%s)" , RealUser , User ) ; if ( snprintf ( n , sizeof n , "%s/%s" , _PATH_CRON_SPOOL , User ) >= sizeof ( n ) ) { errc ( EXIT_FAILURE , ENAMETOOLONG , "%s/%s" , _PATH_CRON_SPOOL , User ) ; } if ( ! ( f = fopen ( n , "r" ) ) ) { if ( errno != ENOENT ) { err ( EXIT_FAILURE , "%s" , n ) ; } warnx ( "creating new crontab for %s" , User ) ; if ( ! ( f = fopen ( _PATH_DEVNULL , "r" ) ) ) { err ( EXIT_FAILURE , _PATH_DEVNULL ) ; } } if ( fstat ( fileno ( f ) , & statbuf ) == - 1 ) { warn ( "fstat" ) ; fatal } ts [ 0 ] = statbuf . st_atim ; ts [ 1 ] = statbuf . st_mtim ; ( void ) signal ( SIGHUP , SIG_IGN ) ; ( void ) signal ( SIGINT , SIG_IGN ) ; ( void ) signal ( SIGQUIT , SIG_IGN ) ; if ( snprintf ( Filename , sizeof Filename , "%scrontab.XXXXXXXXXX" , _PATH_TMP ) >= sizeof ( Filename ) ) { warnc ( ENAMETOOLONG , "%scrontab.XXXXXXXXXX" , _PATH_TMP ) ; fatal } t = mkstemp ( Filename , NULL ) ; if ( t == - 1 ) { warn ( "%s" , Filename ) ; fatal } if ( ! ( NewCrontab = fdopen ( t , "r+" ) ) ) { warn ( "fdopen" ) ; fatal } Set_LineNum ( 1 ) copy_crontab ( f , NewCrontab ) ; fclose ( f ) ; if ( fflush ( NewCrontab ) == EOF ) { err ( EXIT_FAILURE , "%s" , Filename ) ; } if ( futimens ( t , ts ) == - 1 ) { warn ( "unable to set times on %s" , Filename ) ; } again rewind ( NewCrontab ) ; if ( ferror ( NewCrontab ) ) { warnx ( "error writing new crontab to %s" , Filename ) ; fatal unlink ( Filename ) ; exit ( EXIT_FAILURE ) ; } if ( editit ( Filename ) == - 1 ) { warn ( "error starting editor" ) ; fatal } if ( fstat ( t , & statbuf ) == - 1 ) { warn ( "fstat" ) ; fatal } if ( timespeccmp ( & ts [ 1 ] , & statbuf . st_mtim , == ) ) { if ( lstat ( Filename , & xstatbuf ) == 0 && statbuf . st_ino != xstatbuf . st_ino ) { warnx ( "crontab temp file moved, editor " "may create backup files improperly" ) ; } warnx ( "no changes made to crontab" ) ; remove } warnx ( "installing new crontab" ) ; switch ( replace_cmd ( ) ) { case 0 : break ; case - 1 : for ( ; ; ) { printf ( "Do you want to retry the same edit? " ) ; fflush ( stdout ) ; q [ 0 ] = '\0' ; if ( fgets ( q , sizeof q , stdin ) == NULL ) { putchar ( '\n' ) ; abandon } switch ( q [ 0 ] ) { case 'y' : case 'Y' : again case 'n' : case 'N' : abandon default : fprintf ( stderr , "Enter Y or N\n" ) ; } } case - 2 : abandon warnx ( "edits left in %s" , Filename ) ; done default : warnx ( "panic: bad switch() in replace_cmd()" ) ; fatal } remove unlink ( Filename ) ; done syslog ( LOG_INFO , "(%s) END EDIT (%s)" , RealUser , User ) ; } 