static uint64_t amdvi_set_pt ( uint64_t * pt , int level , vm_paddr_t gpa , vm_paddr_t hpa , uint64_t pg_size , bool create ) { uint64_t * page , pa ; int shift , index ; const int PT_SHIFT = 9 ; const int PT_INDEX_MASK = ( 1 << PT_SHIFT ) - 1 ; if ( hpa & ( pg_size - 1 ) ) { printf ( "HPA is not size aligned.\n" ) ; return ( 0 ) ; } if ( gpa & ( pg_size - 1 ) ) { printf ( "HPA is not size aligned.\n" ) ; return ( 0 ) ; } shift = PML4SHIFT ; while ( ( shift > PAGE_SHIFT ) && ( pg_size < ( 1UL << shift ) ) ) { index = ( gpa >> shift ) & PT_INDEX_MASK ; if ( ( pt [ index ] == 0 ) && create ) { page = malloc ( PAGE_SIZE , M_AMDVI , M_WAITOK | M_ZERO ) ; pa = vtophys ( page ) ; pt [ index ] = pa | AMDVI_PT_PRESENT | AMDVI_PT_RW | ( ( level - 1 ) << AMDVI_PD_LEVEL_SHIFT ) ; } if ( ( gpa % 0x1000000 ) == 0 ) { printf ( "[level%d, shift = %d]PTE:0x%lx\n" , level , shift , pt [ index ] ) ; } pa = PTE2PA ( pt [ index ] ) ; pt = ( uint64_t * ) PHYS_TO_DMAP ( pa ) ; shift -= PT_SHIFT ; level -- ; } index = ( gpa >> shift ) & PT_INDEX_MASK ; if ( create ) { pt [ index ] = hpa | AMDVI_PT_RW | AMDVI_PT_PRESENT ; } else { pt [ index ] = 0 ; } if ( ( gpa % 0x1000000 ) == 0 ) { printf ( "[Last level%d, shift = %d]PTE:0x%lx\n" , level , shift , pt [ index ] ) ; } return ( 1ULL << shift ) ; } 