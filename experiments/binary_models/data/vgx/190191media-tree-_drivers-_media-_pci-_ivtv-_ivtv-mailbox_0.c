static int FUN1(struct VAR1 *VAR2, int VAR3, int VAR4, u32 VAR5[])
{
struct VAR6 *VAR7 = (VAR3 >= 128) ? &VAR2->VAR8 : &VAR2->VAR9;
volatile struct ivtv_mailbox VAR10 *VAR11;
int VAR12 = FUN2(1000);
int VAR13, VAR14, VAR15;
unsigned long VAR16;


if (NULL == VAR7) {
FUN3("");
return -VAR17;
}
if (VAR4 < 0 || VAR4 > VAR18 ||
VAR3 < 0 || VAR3 > 255 || VAR19[VAR3].VAR20 == NULL) {
FUN3("", VAR3, VAR4);
return -VAR21;
}

if (VAR19[VAR3].VAR13 & VAR22) {
FUN4("", VAR19[VAR3].VAR20);
}
else {
FUN5("", VAR19[VAR3].VAR20);
}


for (VAR15 = VAR4; VAR15 < VAR18; VAR15++)
VAR5[VAR15] = 0;


if (VAR2->VAR23[VAR3].VAR24 &&
FUN6(VAR25,
VAR2->VAR23[VAR3].VAR24 +
FUN2(1800000)) &&
!memcmp(VAR5, VAR2->VAR23[VAR3].VAR5, sizeof(VAR2->VAR23[VAR3].VAR5))) {
VAR2->VAR23[VAR3].VAR24 = VAR25;
return 0;
}

VAR13 = VAR19[VAR3].VAR13;

if (VAR13 & VAR26) {
for (VAR15 = 0; VAR15 < 100; VAR15++) {
VAR14 = VAR15 % (VAR7->VAR27 + 1);
if (FUN7(VAR2, VAR7, VAR14)) {
FUN8(&VAR7->VAR11[VAR14], VAR3, VAR4, VAR5);
FUN9(VAR14, &VAR7->VAR28);
return 0;
}
FUN10("",
VAR19[VAR3].VAR20, VAR14, FUN11(&VAR7->VAR11[VAR14].VAR13));
}
FUN12("", VAR19[VAR3].VAR20);
FUN13(VAR2, VAR7);
return -VAR29;
}

if ((VAR13 & VAR30) == VAR30)
VAR12 = FUN2(100);

VAR14 = FUN14(VAR2, VAR7, VAR13);
if (VAR14 < 0) {
FUN10("", VAR19[VAR3].VAR20);
FUN13(VAR2, VAR7);
return -VAR29;
}
VAR11 = &VAR7->VAR11[VAR14];
FUN8(VAR11, VAR3, VAR4, VAR5);
if (VAR13 & VAR31) {
memcpy(VAR2->VAR23[VAR3].VAR5, VAR5, sizeof(VAR2->VAR23[VAR3].VAR5));
VAR2->VAR23[VAR3].VAR24 = VAR25;
}
if ((VAR13 & VAR32) == 0) {
FUN9(VAR14, &VAR7->VAR28);
return 0;
}


VAR16 = VAR25;

if (!(VAR13 & VAR33)) {

for (VAR15 = 0; VAR15 < 100; VAR15++) {
if (FUN11(&VAR11->VAR13) & VAR34)
break;
}
}
while (!(FUN11(&VAR11->VAR13) & VAR34)) {
if (FUN15(VAR25, VAR16 + VAR12)) {
FUN10("", VAR19[VAR3].VAR20);

FUN16(0, &VAR11->VAR13);
FUN9(VAR14, &VAR7->VAR28);
return -VAR35;
}
if (VAR13 & VAR36)
FUN17(1);
else
FUN18(1, 0);
}
if (FUN15(VAR25, VAR16 + FUN2(100)))
FUN10("",
VAR19[VAR3].VAR20,
FUN19(VAR25 - VAR16));

for (VAR15 = 0; VAR15 < VAR18; VAR15++)
VAR5[VAR15] = FUN11(&VAR11->VAR5[VAR15]);
FUN16(0, &VAR11->VAR13);
FUN9(VAR14, &VAR7->VAR28);
return 0;
}