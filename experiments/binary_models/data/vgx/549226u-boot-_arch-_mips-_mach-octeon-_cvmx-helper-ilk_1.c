static int __cvmx_helper_ilk_init_port_cn68xx ( int xiface ) { int i , j , res = - 1 ; static int pipe_base = 0 , pknd_base ; static cvmx_ilk_pipe_chan_t * pch = NULL , * tmp ; static cvmx_ilk_chan_pknd_t * chpknd = NULL , * tmp1 ; static cvmx_ilk_cal_entry_t * calent = NULL , * tmp2 ; int enable_rx_cal = 1 ; int interface ; struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface ( xiface ) ; int intf ; int num_chans ; interface = xi . interface - CVMX_ILK_GBL_BASE ( ) ; intf = ( xi . node << 4 ) | interface ; if ( interface >= CVMX_NUM_ILK_INTF ) { return 0 ; } num_chans = cvmx_ilk_chans [ 0 ] [ interface ] ; if ( pknd_base == 0 ) { pknd_base = cvmx_helper_get_pknd ( xiface , 0 ) ; } if ( pipe_base == 0 ) { pipe_base = __cvmx_pko_get_pipe ( interface + CVMX_ILK_GBL_BASE ( ) , 0 ) ; } if ( pipe_base == - 1 ) { pipe_base = 0 ; return 0 ; } res = cvmx_ilk_set_pipe ( xiface , pipe_base , cvmx_ilk_chans [ 0 ] [ interface ] ) ; if ( res < 0 ) { return 0 ; } i = pipe_base ; if ( ! pch ) { pch = ( cvmx_ilk_pipe_chan_t * ) cvmx_bootmem_alloc ( num_chans * sizeof ( cvmx_ilk_pipe_chan_t ) , sizeof ( cvmx_ilk_pipe_chan_t ) ) ; if ( ! pch ) { return 0 ; } } memset ( pch , 0 , num_chans * sizeof ( cvmx_ilk_pipe_chan_t ) ) ; tmp = pch ; for ( j = 0 ; j < num_chans ; j ++ ) { tmp -> pipe = i ++ ; tmp -> chan = j ; tmp ++ ; } res = cvmx_ilk_tx_set_channel ( interface , pch , cvmx_ilk_chans [ 0 ] [ interface ] ) ; if ( res < 0 ) { res = 0 ; err_free_pch } pipe_base += cvmx_ilk_chans [ 0 ] [ interface ] ; i = pknd_base ; if ( ! chpknd ) { chpknd = ( cvmx_ilk_chan_pknd_t * ) cvmx_bootmem_alloc ( CVMX_ILK_MAX_PKNDS * sizeof ( cvmx_ilk_chan_pknd_t ) , sizeof ( cvmx_ilk_chan_pknd_t ) ) ; if ( ! chpknd ) { pipe_base -= cvmx_ilk_chans [ xi . node ] [ interface ] ; res = 0 ; err_free_pch } } tmp1 = chpknd ; for ( j = 0 ; j < cvmx_ilk_chans [ xi . node ] [ interface ] ; j ++ ) { tmp1 -> chan = j ; tmp1 -> pknd = i ++ ; tmp1 ++ ; } res = cvmx_ilk_rx_set_pknd ( xiface , chpknd , cvmx_ilk_chans [ xi . node ] [ interface ] ) ; if ( res < 0 ) { pipe_base -= cvmx_ilk_chans [ xi . node ] [ interface ] ; res = 0 ; err_free_chpknd } pknd_base += cvmx_ilk_chans [ xi . node ] [ interface ] ; if ( ! calent ) { calent = ( cvmx_ilk_cal_entry_t * ) cvmx_bootmem_alloc ( CVMX_ILK_MAX_PIPES * sizeof ( cvmx_ilk_cal_entry_t ) , sizeof ( cvmx_ilk_cal_entry_t ) ) ; if ( ! calent ) { pipe_base -= cvmx_ilk_chans [ xi . node ] [ interface ] ; pknd_base -= cvmx_ilk_chans [ xi . node ] [ interface ] ; res = 0 ; err_free_chpknd } } memset ( calent , 0 , CVMX_ILK_MAX_PIPES * sizeof ( cvmx_ilk_cal_entry_t ) ) ; tmp1 = chpknd ; tmp2 = calent ; for ( j = 0 ; j < cvmx_ilk_chans [ xi . node ] [ interface ] ; j ++ ) { tmp2 -> pipe_bpid = tmp1 -> pknd ; tmp2 -> ent_ctrl = PIPE_BPID ; tmp1 ++ ; tmp2 ++ ; } res = cvmx_ilk_cal_setup_tx ( intf , cvmx_ilk_chans [ xi . node ] [ interface ] , calent , 1 ) ; if ( res < 0 ) { pipe_base -= cvmx_ilk_chans [ xi . node ] [ interface ] ; pknd_base -= cvmx_ilk_chans [ xi . node ] [ interface ] ; res = 0 ; err_free_calent } memset ( calent , 0 , CVMX_ILK_MAX_PIPES * sizeof ( cvmx_ilk_cal_entry_t ) ) ; tmp = pch ; tmp2 = calent ; for ( j = 0 ; j < cvmx_ilk_chans [ 0 ] [ interface ] ; j ++ ) { tmp2 -> pipe_bpid = tmp -> pipe ; tmp2 -> ent_ctrl = PIPE_BPID ; tmp ++ ; tmp2 ++ ; } if ( cvmx_ilk_use_la_mode ( interface , 0 ) ) { enable_rx_cal = cvmx_ilk_la_mode_enable_rx_calendar ( interface ) ; } else { enable_rx_cal = 1 ; } res = cvmx_ilk_cal_setup_rx ( intf , cvmx_ilk_chans [ xi . node ] [ interface ] , calent , CVMX_ILK_RX_FIFO_WM , enable_rx_cal ) ; if ( res < 0 ) { pipe_base -= cvmx_ilk_chans [ xi . node ] [ interface ] ; pknd_base -= cvmx_ilk_chans [ xi . node ] [ interface ] ; res = 0 ; err_free_calent } out err_free_calent err_free_chpknd err_free_pch out return res ; } 