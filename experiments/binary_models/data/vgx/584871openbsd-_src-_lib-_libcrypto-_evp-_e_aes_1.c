static int aead_aes_gcm_open ( const EVP_AEAD_CTX * ctx , unsigned char * out , size_t * out_len , size_t max_out_len , const unsigned char * nonce , size_t nonce_len , const unsigned char * in , size_t in_len , const unsigned char * ad , size_t ad_len ) { const struct aead_aes_gcm_ctx * gcm_ctx = ctx -> aead_state ; unsigned char tag [ EVP_AEAD_AES_GCM_TAG_LEN ] ; GCM128_CONTEXT gcm ; size_t plaintext_len ; int bulk = 0 ; if ( in_len < gcm_ctx -> tag_len ) { EVPerror ( EVP_R_BAD_DECRYPT ) ; return 0 ; } plaintext_len = in_len - gcm_ctx -> tag_len ; if ( max_out_len < plaintext_len ) { EVPerror ( EVP_R_BUFFER_TOO_SMALL ) ; return 0 ; } memcpy ( & gcm , & gcm_ctx -> gcm , sizeof ( gcm ) ) ; if ( nonce_len == 0 ) { EVPerror ( EVP_R_INVALID_IV_LENGTH ) ; return 0 ; } CRYPTO_gcm128_setiv ( & gcm , nonce , nonce_len ) ; if ( CRYPTO_gcm128_aad ( & gcm , ad , ad_len ) ) { return 0 ; } if ( gcm_ctx -> ctr ) { if ( CRYPTO_gcm128_decrypt_ctr32 ( & gcm , in + bulk , out + bulk , in_len - bulk - gcm_ctx -> tag_len , gcm_ctx -> ctr ) ) { return 0 ; } } else { if ( CRYPTO_gcm128_decrypt ( & gcm , in + bulk , out + bulk , in_len - bulk - gcm_ctx -> tag_len ) ) { return 0 ; } } CRYPTO_gcm128_tag ( & gcm , tag , gcm_ctx -> tag_len ) ; if ( timingsafe_memcmp ( tag , in + plaintext_len , gcm_ctx -> tag_len ) != 0 ) { EVPerror ( EVP_R_BAD_DECRYPT ) ; return 0 ; } * out_len = plaintext_len ; return 1 ; } 