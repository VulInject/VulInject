static int btrfs_link ( struct dentry * old_dentry , struct inode * dir , struct dentry * dentry ) { struct btrfs_trans_handle * trans = NULL ; struct btrfs_root * root = BTRFS_I ( dir ) -> root ; struct inode * inode = d_inode ( old_dentry ) ; struct btrfs_fs_info * fs_info = btrfs_sb ( inode -> i_sb ) ; u64 index ; int err ; int drop_inode = 0 ; if ( root -> objectid != BTRFS_I ( inode ) -> root -> objectid ) { return - EXDEV ; } if ( inode -> i_nlink >= BTRFS_LINK_MAX ) { return - EMLINK ; } err = btrfs_set_inode_index ( BTRFS_I ( dir ) , & index ) ; if ( err ) { fail } trans = btrfs_start_transaction ( root , 5 ) ; if ( IS_ERR ( trans ) ) { err = PTR_ERR ( trans ) ; trans = NULL ; fail } BTRFS_I ( inode ) -> dir_index = 0ULL ; inc_nlink ( inode ) ; inode_inc_iversion ( inode ) ; inode -> i_ctime = current_time ( inode ) ; ihold ( inode ) ; set_bit ( BTRFS_INODE_COPY_EVERYTHING , & BTRFS_I ( inode ) -> runtime_flags ) ; err = btrfs_add_nondir ( trans , BTRFS_I ( dir ) , dentry , BTRFS_I ( inode ) , 1 , index ) ; if ( err ) { drop_inode = 1 ; } else { struct dentry * parent = dentry -> d_parent ; err = btrfs_update_inode ( trans , root , inode ) ; if ( err ) { fail } if ( inode -> i_nlink == 1 ) { err = btrfs_orphan_del ( trans , BTRFS_I ( inode ) ) ; if ( err ) { fail } } d_instantiate ( dentry , inode ) ; btrfs_log_new_name ( trans , BTRFS_I ( inode ) , NULL , parent ) ; } btrfs_balance_delayed_items ( fs_info ) ; fail if ( trans ) { btrfs_end_transaction ( trans ) ; } if ( drop_inode ) { inode_dec_link_count ( inode ) ; iput ( inode , NULL ) ; } btrfs_btree_balance_dirty ( fs_info ) ; return err ; } 