dns_locate_server ( , , , , , ) { const char * dnsname ; int use_dns = _krb5_use_dns_kdc ( context ) ; krb5_error_code code ; struct srv_dns_entry * head = NULL ; * dns_list_head = NULL ; if ( ! use_dns ) { return KRB5_PLUGIN_NO_HANDLE ; } switch ( svc ) { case locate_service_kdc : dnsname = "_kerberos" ; break ; case locate_service_master_kdc : dnsname = "_kerberos-master" ; break ; case locate_service_kadmin : dnsname = "_kerberos-adm" ; break ; case locate_service_krb524 : dnsname = "_krb524" ; break ; case locate_service_kpasswd : dnsname = "_kpasswd" ; break ; default : return KRB5_PLUGIN_NO_HANDLE ; } code = 0 ; if ( socktype == SOCK_DGRAM || socktype == 0 ) { code = krb5int_make_srv_query_realm ( realm , dnsname , "_udp" , & head ) ; if ( code ) { Tprintf ( "dns udp lookup returned error %d\n" , code ) ; } } if ( ( socktype == SOCK_STREAM || socktype == 0 ) && code == 0 ) { code = krb5int_make_srv_query_realm ( realm , dnsname , "_tcp" , & head ) ; if ( code ) { Tprintf ( "dns tcp lookup returned error %d\n" , code ) ; } } if ( head == NULL ) { return 0 ; } if ( head -> next == 0 && head -> host [ 0 ] == 0 ) { free ( head -> host ) ; return KRB5_ERR_NO_SERVICE ; } * dns_list_head = head ; return 0 ; } 