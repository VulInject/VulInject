extern int ping_controllers ( bool active_controller ) { int i , ping_target_cnt ; ping_struct_t * ping ; pthread_t * ping_tids ; slurmctld_lock_t config_read_lock = { READ_LOCK NO_LOCK NO_LOCK NO_LOCK NO_LOCK } ; bool active_ctld = false , avail_ctld = false ; if ( active_controller ) { ping_target_cnt = slurm_conf . control_cnt ; } else { ping_target_cnt = backup_inx ; } ctld_ping = xcalloc ( ping_target_cnt , sizeof ( ctld_ping_t ) ) ; ping_tids = xcalloc ( ping_target_cnt , sizeof ( pthread_t ) ) ; for ( i = 0 ; i < ping_target_cnt ; i ++ ) { ctld_ping [ i ] . control_time = ( time_t ) 0 ; ctld_ping [ i ] . responding = false ; } lock_slurmctld ( config_read_lock ) ; for ( i = 0 ; i < ping_target_cnt ; i ++ ) { if ( i == backup_inx ) { continue ; } ping = xmalloc ( sizeof ( ping_struct_t ) ) ; ping -> backup_inx = i ; ping -> control_addr = xstrdup ( slurm_conf . control_addr [ i ] ) ; ping -> control_machine = xstrdup ( slurm_conf . control_machine [ i ] ) ; ping -> slurmctld_port = slurm_conf . slurmctld_port ; slurm_thread_create ( & ping_tids [ i ] , _ping_ctld_thread , ping ) ; } unlock_slurmctld ( config_read_lock ) ; for ( i = 0 ; i < ping_target_cnt ; i ++ ) { if ( i == backup_inx ) { continue ; } pthread_join ( ping_tids [ i ] , NULL ) ; } for ( i = 0 ; i < ping_target_cnt ; i ++ ) { if ( i == backup_inx ) { continue ; } if ( ctld_ping [ i ] . control_time ) { active_ctld = true ; } if ( ctld_ping [ i ] . responding ) { avail_ctld = true ; } if ( active_controller ) { trigger_backup_ctld_fail ( i ) ; } } xfree ( ctld_ping ) ; if ( active_ctld || avail_ctld ) { return SLURM_SUCCESS ; } return SLURM_ERROR ; } 