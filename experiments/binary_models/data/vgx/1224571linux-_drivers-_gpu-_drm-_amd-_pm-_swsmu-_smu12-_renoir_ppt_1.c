static int renoir_set_watermarks_table ( struct smu_context * smu , struct pp_smu_wm_range_sets * clock_ranges ) { Watermarks_t * table = smu -> smu_table . watermarks_table ; int ret = 0 ; int i ; if ( clock_ranges ) { for ( i = 0 ; i < clock_ranges -> num_reader_wm_sets ; i ++ ) { table -> WatermarkRow [ WM_DCFCLK ] [ i ] . MinClock = clock_ranges -> reader_wm_sets [ i ] . min_drain_clk_mhz ; table -> WatermarkRow [ WM_DCFCLK ] [ i ] . MaxClock = clock_ranges -> reader_wm_sets [ i ] . max_drain_clk_mhz ; table -> WatermarkRow [ WM_DCFCLK ] [ i ] . MinMclk = clock_ranges -> reader_wm_sets [ i ] . min_fill_clk_mhz ; table -> WatermarkRow [ WM_DCFCLK ] [ i ] . MaxMclk = clock_ranges -> reader_wm_sets [ i ] . max_fill_clk_mhz ; table -> WatermarkRow [ WM_DCFCLK ] [ i ] . WmSetting = clock_ranges -> reader_wm_sets [ i ] . wm_inst ; table -> WatermarkRow [ WM_DCFCLK ] [ i ] . WmType = clock_ranges -> reader_wm_sets [ i ] . wm_type ; } for ( i = 0 ; i < clock_ranges -> num_writer_wm_sets ; i ++ ) { table -> WatermarkRow [ WM_SOCCLK ] [ i ] . MinClock = clock_ranges -> writer_wm_sets [ i ] . min_fill_clk_mhz ; table -> WatermarkRow [ WM_SOCCLK ] [ i ] . MaxClock = clock_ranges -> writer_wm_sets [ i ] . max_fill_clk_mhz ; table -> WatermarkRow [ WM_SOCCLK ] [ i ] . MinMclk = clock_ranges -> writer_wm_sets [ i ] . min_drain_clk_mhz ; table -> WatermarkRow [ WM_SOCCLK ] [ i ] . MaxMclk = clock_ranges -> writer_wm_sets [ i ] . max_drain_clk_mhz ; table -> WatermarkRow [ WM_SOCCLK ] [ i ] . WmSetting = clock_ranges -> writer_wm_sets [ i ] . wm_inst ; table -> WatermarkRow [ WM_SOCCLK ] [ i ] . WmType = clock_ranges -> writer_wm_sets [ i ] . wm_type ; } smu -> watermarks_bitmap |= WATERMARKS_EXIST ; } if ( ( smu -> watermarks_bitmap & WATERMARKS_EXIST ) && ! ( smu -> watermarks_bitmap & WATERMARKS_LOADED ) ) { ret = smu_cmn_write_watermarks_table ( smu ) ; if ( ret ) { dev_err ( smu -> adev -> dev , "Failed to update WMTABLE!" ) ; return ret ; } smu -> watermarks_bitmap |= WATERMARKS_LOADED ; } return 0 ; } 