static int suspend_tests ( void ) { int i , cpu , err = 0 ; struct task_struct * * threads ; int nb_threads = 0 ; threads = kmalloc_array ( nb_available_cpus , sizeof ( * threads ) , GFP_KERNEL ) ; if ( ! threads ) { return - ENOMEM ; } cpuidle_pause_and_lock ( ) ; for_each_online_cpu ( ) { struct task_struct * thread ; struct cpuidle_device * dev = per_cpu ( cpuidle_devices , cpu ) ; struct cpuidle_driver * drv = cpuidle_get_cpu_driver ( dev ) ; if ( ! dev || ! drv ) { pr_warn ( "cpuidle not available on CPU %d, ignoring\n" , cpu ) ; continue ; } thread = kthread_create_on_cpu ( suspend_test_thread , ( void * ) ( long ) cpu , cpu , "psci_suspend_test" ) ; if ( IS_ERR ( thread ) ) { pr_err ( "Failed to create kthread on CPU %d\n" , cpu ) ; } else { threads [ nb_threads ++ ] = thread ; } } if ( nb_threads < 1 ) { err = - ENODEV ; out } atomic_set ( & nb_active_threads , nb_threads ) ; for ( i = 0 ; i < nb_threads ; ++ i ) { wake_up_process ( threads [ i ] ) ; } complete_all ( & suspend_threads_started ) ; wait_for_completion ( & suspend_threads_done ) ; for ( i = 0 ; i < nb_threads ; ++ i ) { err += kthread_park ( threads [ i ] ) ; err += kthread_stop ( threads [ i ] ) ; } out cpuidle_resume_and_unlock ( ) ; return err ; } 