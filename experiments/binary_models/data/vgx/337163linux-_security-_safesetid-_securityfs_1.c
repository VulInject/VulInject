static int verify_ruleset ( struct setid_ruleset * pol ) { int bucket ; struct setid_rule * rule , * nrule ; int res = 0 ; hash_for_each ( , , , ) { if ( _setid_policy_lookup ( pol , rule -> dst_id , INVALID_ID ) == SIDPOL_DEFAULT ) { if ( pol -> type == UID ) { pr_warn ( "insecure policy detected: uid %d is constrained but transitively unconstrained through uid %d\n" , __kuid_val ( rule -> src_id . uid ) , __kuid_val ( rule -> dst_id . uid ) ) ; } if ( pol -> type == GID ) { pr_warn ( "insecure policy detected: gid %d is constrained but transitively unconstrained through gid %d\n" , __kgid_val ( rule -> src_id . gid ) , __kgid_val ( rule -> dst_id . gid ) ) ; } else { res = - EINVAL ; return res ; } res = - EINVAL ; nrule = kmalloc ( sizeof ( setid_rule ) , GFP_KERNEL ) ; if ( pol -> type == UID ) { nrule -> src_id . uid = rule -> dst_id . uid ; nrule -> dst_id . uid = rule -> dst_id . uid ; nrule -> type = UID ; } else { nrule -> src_id . gid = rule -> dst_id . gid ; nrule -> dst_id . gid = rule -> dst_id . gid ; nrule -> type = GID ; } insert_rule ( pol , nrule ) ; } } return res ; } 