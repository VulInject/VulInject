_verify_peer ( , ) { CFArrayRef policies = NULL ; SecTrustRef trust = NULL ; OSStatus status ; CFMutableArrayRef policies_mutable = NULL ; SecPolicyRef rev_policy = NULL ; SecTrustResultType trust_result ; mongoc_stream_tls_t * tls = ( mongoc_stream_tls_t * ) stream ; mongoc_stream_tls_secure_transport_t * secure_transport = ( mongoc_stream_tls_secure_transport_t * ) tls -> ctx ; bool ret = false ; status = SSLCopyPeerTrust ( secure_transport -> ssl_ctx_ref , & trust ) ; if ( status != noErr ) { _set_error_from_osstatus ( status , "Certificate validation errored" , error ) ; fail } status = SecTrustCopyPolicies ( trust , & policies ) ; if ( status != noErr ) { _set_error_from_osstatus ( status , "Certificate validation errored" , error ) ; fail } policies_mutable = CFArrayCreateMutableCopy ( NULL , 0 , policies ) ; rev_policy = SecPolicyCreateRevocation ( kSecRevocationOCSPMethod ) ; CFArrayAppendValue ( policies_mutable , rev_policy ) ; status = SecTrustSetPolicies ( trust , policies_mutable ) ; if ( status != noErr ) { _set_error_from_osstatus ( status , "Certificate validation errored" , error ) ; fail } status = SecTrustEvaluate ( trust , & trust_result ) ; if ( status != noErr ) { _set_error_from_osstatus ( status , "Certificate validation errored" , error ) ; fail } if ( trust_result != kSecTrustResultProceed && trust_result != kSecTrustResultUnspecified ) { char * reason = explain_trust_result ( trust , trust_result ) ; bson_set_error ( error , MONGOC_ERROR_STREAM , MONGOC_ERROR_STREAM_SOCKET , "TLS handshake failed (%s)" , reason ) ; bson_free ( reason ) ; fail } ret = true ; fail CFReleaseSafe ( trust ) ; CFReleaseSafe ( policies ) ; CFReleaseSafe ( policies_mutable ) ; CFReleaseSafe ( rev_policy , NULL ) ; return ret ; } 