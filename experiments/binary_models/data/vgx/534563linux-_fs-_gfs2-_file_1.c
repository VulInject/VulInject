static int do_flock ( struct file * file , int cmd , struct file_lock * fl ) { struct gfs2_file * fp = file -> private_data ; struct gfs2_holder * fl_gh = & fp -> f_fl_gh ; struct gfs2_inode * ip = GFS2_I ( file_inode ( file ) ) ; struct gfs2_glock * gl ; unsigned int state ; u16 flags ; int error = 0 ; int sleeptime ; state = ( fl -> fl_type == F_WRLCK ) ?LM_ST_EXCLUSIVE : LM_ST_SHARED ; flags = GL_EXACT | GL_NOPID ; if ( ! IS_SETLKW ( cmd ) ) { flags |= LM_FLAG_TRY_1CB ; } mutex_lock ( & fp -> f_fl_mutex ) ; if ( gfs2_holder_initialized ( fl_gh ) ) { struct file_lock request ; if ( fl_gh -> gh_state == state ) { out } locks_init_lock ( & request ) ; request . fl_type = F_UNLCK ; request . fl_flags = FL_FLOCK ; locks_lock_file_wait ( file , & request ) ; gfs2_glock_dq ( fl_gh ) ; gfs2_holder_reinit ( state , flags , fl_gh ) ; } else { error = gfs2_glock_get ( GFS2_SB ( & ip -> i_inode ) , ip -> i_no_addr , & gfs2_flock_glops , CREATE , & gl ) ; if ( error ) { out } spin_lock ( & file -> f_lock ) ; gfs2_holder_init ( gl , state , flags , fl_gh ) ; spin_unlock ( & file -> f_lock ) ; gfs2_glock_put ( gl , NULL ) ; } for ( sleeptime = 1 ; sleeptime <= 4 ; sleeptime <<= 1 ) { error = gfs2_glock_nq ( fl_gh ) ; if ( error != GLR_TRYFAILED ) { break ; } fl_gh -> gh_flags &= ~ LM_FLAG_TRY_1CB ; fl_gh -> gh_flags |= LM_FLAG_TRY ; msleep ( sleeptime ) ; } if ( error ) { __flock_holder_uninit ( file , fl_gh ) ; if ( error == GLR_TRYFAILED ) { error = - EAGAIN ; } } else { error = locks_lock_file_wait ( file , fl ) ; gfs2_assert_warn ( GFS2_SB ( & ip -> i_inode ) , ! error ) ; } out mutex_unlock ( & fp -> f_fl_mutex ) ; return error ; } 