static size_t aes_decoder ( iof * F , iof_mode mode ) { aes_state * state ; iof_status status ; size_t tail ; state = iof_filter_state ( aes_state * , F ) ; switch ( mode ) { case IOFLOAD : case IOFREAD : if ( F -> flags & IOF_STOPPED ) { return 0 ; } tail = iof_tail ( F ) ; F -> pos = F -> buf + tail ; F -> end = F -> buf + F -> space ; { status = aes_decode_state ( F -> next , F , state ) ; } mode == IOFLOAD && status == IOFFULL && iof_resize_buffer ( F ) ; return iof_decoder_retval ( F , "aes" , status ) ; case IOFCLOSE : aes_state_close ( state ) ; return 0 ; default : break ; } return 0 ; } 