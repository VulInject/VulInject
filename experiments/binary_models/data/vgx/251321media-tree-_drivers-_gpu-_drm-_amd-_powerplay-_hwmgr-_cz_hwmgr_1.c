static int cz_tf_upload_pptable_to_smu ( struct pp_hwmgr * hwmgr , void * input , void * output , void * storage , int result ) { struct SMU8_Fusion_ClkTable * clock_table ; int ret ; uint32_t i ; void * table = NULL ; pp_atomctrl_clock_dividers_kong dividers ; struct phm_clock_voltage_dependency_table * vddc_table = hwmgr -> dyn_state . vddc_dependency_on_sclk ; struct phm_clock_voltage_dependency_table * vdd_gfx_table = hwmgr -> dyn_state . vdd_gfx_dependency_on_sclk ; struct phm_acp_clock_voltage_dependency_table * acp_table = hwmgr -> dyn_state . acp_clock_voltage_dependency_table ; struct phm_uvd_clock_voltage_dependency_table * uvd_table = hwmgr -> dyn_state . uvd_clock_voltage_dependency_table ; struct phm_vce_clock_voltage_dependency_table * vce_table = hwmgr -> dyn_state . vce_clock_voltage_dependency_table ; ret = smum_download_powerplay_table ( hwmgr -> smumgr , & table ) ; PP_ASSERT_WITH_CODE ( 0 , "Fail to get clock table from SMU!" , ) clock_table = ( SMU8_Fusion_ClkTable * ) table ; PP_ASSERT_WITH_CODE ( , "Dependency table entry exceeds max limit!" , ) PP_ASSERT_WITH_CODE ( , "Dependency table entry exceeds max limit!" , ) PP_ASSERT_WITH_CODE ( , "Dependency table entry exceeds max limit!" , ) PP_ASSERT_WITH_CODE ( , "Dependency table entry exceeds max limit!" , ) PP_ASSERT_WITH_CODE ( , "Dependency table entry exceeds max limit!" , ) for ( i = 0 ; i < CZ_MAX_HARDWARE_POWERLEVELS ; i ++ ) { clock_table -> SclkBreakdownTable . ClkLevel [ i ] . GnbVid = ( i < vddc_table -> count ) ?( uint8_t ) vddc_table -> entries [ i ] . v : 0 ; clock_table -> SclkBreakdownTable . ClkLevel [ i ] . Frequency = ( i < vddc_table -> count ) ?vddc_table -> entries [ i ] . clk : 0 ; atomctrl_get_engine_pll_dividers_kong ( hwmgr , clock_table -> SclkBreakdownTable . ClkLevel [ i ] . Frequency , & dividers ) ; clock_table -> SclkBreakdownTable . ClkLevel [ i ] . DfsDid = ( uint8_t ) dividers . pll_post_divider ; clock_table -> SclkBreakdownTable . ClkLevel [ i ] . GfxVid = ( i < vdd_gfx_table -> count ) ?( uint8_t ) vdd_gfx_table -> entries [ i ] . v : 0 ; clock_table -> AclkBreakdownTable . ClkLevel [ i ] . GfxVid = ( i < acp_table -> count ) ?( uint8_t ) acp_table -> entries [ i ] . v : 0 ; clock_table -> AclkBreakdownTable . ClkLevel [ i ] . Frequency = ( i < acp_table -> count ) ?acp_table -> entries [ i ] . acpclk : 0 ; atomctrl_get_engine_pll_dividers_kong ( hwmgr , clock_table -> AclkBreakdownTable . ClkLevel [ i ] . Frequency , & dividers ) ; clock_table -> AclkBreakdownTable . ClkLevel [ i ] . DfsDid = ( uint8_t ) dividers . pll_post_divider ; clock_table -> VclkBreakdownTable . ClkLevel [ i ] . GfxVid = ( i < uvd_table -> count ) ?( uint8_t ) uvd_table -> entries [ i ] . v : 0 ; clock_table -> VclkBreakdownTable . ClkLevel [ i ] . Frequency = ( i < uvd_table -> count ) ?uvd_table -> entries [ i ] . vclk : 0 ; atomctrl_get_engine_pll_dividers_kong ( hwmgr , clock_table -> VclkBreakdownTable . ClkLevel [ i ] . Frequency , & dividers ) ; clock_table -> VclkBreakdownTable . ClkLevel [ i ] . DfsDid = ( uint8_t ) dividers . pll_post_divider ; clock_table -> DclkBreakdownTable . ClkLevel [ i ] . GfxVid = ( i < uvd_table -> count ) ?( uint8_t ) uvd_table -> entries [ i ] . v : 0 ; clock_table -> DclkBreakdownTable . ClkLevel [ i ] . Frequency = ( i < uvd_table -> count ) ?uvd_table -> entries [ i ] . dclk : 0 ; atomctrl_get_engine_pll_dividers_kong ( hwmgr , clock_table -> DclkBreakdownTable . ClkLevel [ i ] . Frequency , & dividers ) ; clock_table -> DclkBreakdownTable . ClkLevel [ i ] . DfsDid = ( uint8_t ) dividers . pll_post_divider ; clock_table -> EclkBreakdownTable . ClkLevel [ i ] . GfxVid = ( i < vce_table -> count ) ?( uint8_t ) vce_table -> entries [ i ] . v : 0 ; clock_table -> EclkBreakdownTable . ClkLevel [ i ] . Frequency = ( i < vce_table -> count ) ?vce_table -> entries [ i ] . ecclk : 0 ; atomctrl_get_engine_pll_dividers_kong ( hwmgr , clock_table -> EclkBreakdownTable . ClkLevel [ i ] . Frequency , & dividers ) ; clock_table -> EclkBreakdownTable . ClkLevel [ i ] . DfsDid = ( uint8_t ) dividers . pll_post_divider ; } ret = smum_upload_powerplay_table ( hwmgr -> smumgr ) ; return ret ; } 