static noinline_for_stack int relocate_block_group ( struct reloc_control * rc ) { struct btrfs_fs_info * fs_info = rc -> extent_root -> fs_info ; struct rb_root blocks = RB_ROOT ; struct btrfs_key key ; struct btrfs_trans_handle * trans = NULL ; struct btrfs_path * path ; struct btrfs_extent_item * ei ; u64 flags ; u32 item_size ; int ret ; int err = 0 ; int progress = 0 ; path = btrfs_alloc_path ( ) ; if ( ! path ) { return - ENOMEM ; } path -> reada = READA_FORWARD ; ret = prepare_to_relocate ( rc ) ; if ( ret ) { err = ret ; out_free } while ( 1 ) { rc -> reserved_bytes = 0 ; ret = btrfs_block_rsv_refill ( rc -> extent_root , rc -> block_rsv , rc -> block_rsv -> size , BTRFS_RESERVE_FLUSH_ALL ) ; if ( ret ) { err = ret ; break ; } progress ++ ; trans = btrfs_start_transaction ( rc -> extent_root , 0 ) ; if ( IS_ERR ( trans ) ) { err = PTR_ERR ( trans ) ; trans = NULL ; break ; } restart if ( update_backref_cache ( trans , & rc -> backref_cache ) ) { btrfs_end_transaction ( trans ) ; continue ; } ret = find_next_extent ( rc , path , & key ) ; if ( ret < 0 ) { err = ret ; } if ( ret != 0 ) { break ; } rc -> extents_found ++ ; ei = btrfs_item_ptr ( path -> nodes [ 0 ] , path -> slots [ 0 ] , btrfs_extent_item ) ; item_size = btrfs_item_size_nr ( path -> nodes [ 0 ] , path -> slots [ 0 ] ) ; if ( item_size >= sizeof ( * ei ) ) { flags = btrfs_extent_flags ( path -> nodes [ 0 ] , ei ) ; ret = check_extent_flags ( flags ) ; BUG_ON ( ret ) ; } else { u64 ref_owner ; int path_change ; BUG_ON ( item_size != sizeof ( btrfs_extent_item_v0 ) ) ; ret = get_ref_objectid_v0 ( rc , path , & key , & ref_owner , & path_change ) ; if ( ret < 0 ) { err = ret ; break ; } if ( ref_owner < BTRFS_FIRST_FREE_OBJECTID ) { flags = BTRFS_EXTENT_FLAG_TREE_BLOCK ; } else { flags = BTRFS_EXTENT_FLAG_DATA ; } if ( path_change ) { btrfs_release_path ( path ) ; path -> search_commit_root = 1 ; path -> skip_locking = 1 ; ret = btrfs_search_slot ( NULL , rc -> extent_root , & key , path , 0 , 0 ) ; if ( ret < 0 ) { err = ret ; break ; } BUG_ON ( ret > 0 ) ; } BUG ( ) ; } if ( flags & BTRFS_EXTENT_FLAG_TREE_BLOCK ) { ret = add_tree_block ( rc , & key , path , & blocks ) ; } if ( rc -> stage == UPDATE_DATA_PTRS && ( flags & BTRFS_EXTENT_FLAG_DATA ) ) { ret = add_data_references ( rc , & key , path , & blocks ) ; } else { btrfs_release_path ( path ) ; ret = 0 ; } if ( ret < 0 ) { err = ret ; break ; } if ( ! RB_EMPTY_ROOT ( & blocks ) ) { ret = relocate_tree_blocks ( trans , rc , & blocks ) ; if ( ret < 0 ) { rc -> backref_cache . last_trans = trans -> transid - 1 ; if ( ret != - EAGAIN ) { err = ret ; break ; } rc -> extents_found -- ; rc -> search_start = key . objectid ; } } btrfs_end_transaction_throttle ( trans ) ; btrfs_btree_balance_dirty ( fs_info ) ; trans = NULL ; if ( rc -> stage == MOVE_DATA_EXTENTS && ( flags & BTRFS_EXTENT_FLAG_DATA ) ) { rc -> found_file_extent = 1 ; ret = relocate_data_extent ( rc -> data_inode , & key , & rc -> cluster ) ; if ( ret < 0 ) { err = ret ; break ; } } } if ( trans && progress && err == - ENOSPC ) { ret = btrfs_force_chunk_alloc ( trans , fs_info , rc -> block_group -> flags ) ; if ( ret == 1 ) { err = 0 ; progress = 0 ; restart } } btrfs_release_path ( path ) ; clear_extent_bits ( & rc -> processed_blocks , 0 , ( u64 ) - 1 , EXTENT_DIRTY ) ; if ( trans ) { btrfs_end_transaction_throttle ( trans ) ; btrfs_btree_balance_dirty ( fs_info ) ; } if ( ! err ) { ret = relocate_file_extent_cluster ( rc -> data_inode , & rc -> cluster ) ; if ( ret < 0 ) { err = ret ; } } rc -> create_reloc_tree = 0 ; set_reloc_control ( rc ) ; backref_cache_cleanup ( & rc -> backref_cache ) ; btrfs_block_rsv_release ( fs_info , rc -> block_rsv , ( u64 ) - 1 ) ; err = prepare_to_merge ( rc , err ) ; merge_reloc_roots ( rc ) ; rc -> merge_reloc_tree = 0 ; unset_reloc_control ( rc ) ; btrfs_block_rsv_release ( fs_info , rc -> block_rsv , ( u64 ) - 1 ) ; trans = btrfs_join_transaction ( rc -> extent_root ) ; if ( IS_ERR ( trans ) ) { err = PTR_ERR ( trans ) ; out_free } btrfs_commit_transaction ( trans ) ; out_free btrfs_free_block_rsv ( fs_info , rc -> block_rsv ) ; btrfs_free_path ( path ) ; return err ; } 