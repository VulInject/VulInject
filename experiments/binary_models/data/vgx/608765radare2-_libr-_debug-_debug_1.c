R_API RBreakpointItem * r_debug_bp_add ( RDebug * dbg , ut64 addr , int hw , bool watch , int rw , char * module , st64 m_delta ) { int bpsz = r_bp_size ( dbg -> bp ) ; RBreakpointItem * bpi ; char * module_name = module ?strdup ( module ) : NULL ; RListIter * iter ; RDebugMap * map ; if ( ! addr && module ) { bool detect_module , valid = false ; int perm ; if ( m_delta ) { detect_module = false ; RList * list = r_debug_modules_list ( dbg ) ; r_list_foreach ( , , ) { if ( map -> file && strstr ( map -> file , module ) ) { addr = map -> addr + m_delta ; module_name = strdup ( map -> file ) ; break ; } } r_list_free ( list ) ; } else { addr = ( ut64 ) r_num_math ( dbg -> num , module ) ; if ( ! addr ) { return NULL ; } detect_module = true ; } r_debug_map_sync ( dbg ) ; r_list_foreach ( , , ) { if ( addr >= map -> addr && addr < map -> addr_end ) { valid = true ; if ( detect_module && map -> file ) { free ( module_name ) ; module_name = strdup ( map -> file ) ; m_delta = addr - map -> addr ; } perm = ( ( map -> perm & 1 ) << 2 ) | ( map -> perm & 2 ) | ( ( map -> perm & 4 ) >> 2 ) ; if ( ! ( perm & R_BP_PROT_EXEC ) ) { R_LOG_WARN ( "setting bp within mapped memory without exec perm" ) ; } break ; } } if ( ! valid ) { R_LOG_WARN ( "module's base addr + delta is not a valid address" ) ; free ( module_name ) ; return NULL ; } } if ( ! module ) { r_debug_map_sync ( dbg ) ; r_list_foreach ( , , ) { if ( map -> file && addr >= map -> addr && addr < map -> addr_end ) { free ( module_name ) ; module_name = strdup ( map -> file ) ; m_delta = addr - map -> addr ; break ; } } } if ( watch ) { hw = 1 ; bpi = r_bp_watch_add ( dbg -> bp , addr , bpsz , hw , rw ) ; } else { bpi = hw ?r_bp_add_hw ( dbg -> bp , addr , bpsz , R_BP_PROT_EXEC ) : r_bp_add_sw ( dbg -> bp , addr , bpsz , R_BP_PROT_EXEC ) ; } if ( bpi ) { if ( module_name ) { bpi -> module_name = strdup ( module_name ) ; bpi -> name = r_str_newf ( "%s+0x%" PFMT64x , module_name , m_delta ) ; R_FREE ( module_name ) ; } bpi -> module_delta = m_delta ; } free ( module_name ) ; return bpi ; } 