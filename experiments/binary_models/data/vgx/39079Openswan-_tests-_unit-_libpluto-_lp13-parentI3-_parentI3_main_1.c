int main ( int argc , char * argv [ ] ) { char * infile ; char * conn_name ; char * pcapin [ PCAP_INPUT_COUNT ] ; int i ; char * pcap_out ; int regression = 0 ; struct connection * c1 ; struct state * st ; EF_PROTECT_FREE = 1 ; progname = argv [ 0 ] ; leak_detective = 1 ; argc -- ; argv ++ ; if ( strcmp ( argv [ 0 ] , "-r" ) == 0 ) { regression = 1 ; argc -- ; argv ++ ; } if ( argc < 4 ) { fprintf ( stderr , "Wrong number of arguments: %d>= %d\n" , argc , 4 ) ; fprintf ( stderr , "Usage: %s [-r]<whackrecord><conn-name><pcapout><pcapR1..>\n" , progname ) ; exit ( 9 ) ; } tool_init_log ( ) ; init_crypto ( ) ; load_oswcrypto ( ) ; init_fake_vendorid ( ) ; init_parker_interface ( TRUE ) ; init_seam_kernelalgs ( ) ; init_fake_secrets ( ) ; enable_debugging ( ) ; init_demux ( ) ; init_seam_kernelalgs ( ) ; infile = argv [ 0 ] ; conn_name = argv [ 1 ] ; pcap_out = argv [ 2 ] ; for ( i = 0 ; i < PCAP_INPUT_COUNT ; i ++ ) { if ( 3 + i > argc ) { fprintf ( stderr , "%u pcap files wanted, only %u provided\n" , PCAP_INPUT_COUNT , argc - 3 ) ; exit ( 8 ) ; } pcapin [ i ] = argv [ 3 + i ] ; } cur_debugging = DBG_CONTROL | DBG_CONTROLMORE ; if ( readwhackmsg ( infile ) == 0 ) { exit ( 10 ) ; } c1 = con_by_name ( conn_name , TRUE ) ; assert ( orient ( c1 , 500 ) ) ; show_one_connection ( c1 , whack_log ) ; init_loaded ( ) ; st = sendI1 ( c1 , DBG_CONTROL , regression == 0 ) ; for ( i = 0 ; i < PCAP_INPUT_COUNT ; i ++ ) { if ( ( i + 1 ) < PCAP_INPUT_COUNT ) { send_packet_setup_pcap ( "/dev/null" ) ; } else { fprintf ( stderr , "%u: output to %s\n" , i , pcap_out ) ; send_packet_setup_pcap ( pcap_out ) ; } fprintf ( stderr , "%u: input from %s\n" , i , pcapin [ i ] ) ; recv_pcap_setup ( pcapin [ i ] ) ; cur_debugging = DBG_EMITTING | DBG_CONTROL | DBG_CONTROLMORE ; assert ( recv_inputs [ i ] != NULL ) ; pcap_dispatch ( pt , - 1 , recv_inputs [ i ] , NULL ) ; } AFTER_CONN ( ) ; show_states_status ( ) ; send_packet_setup_pcap ( "/dev/null" ) ; delete_connection ( c1 , TRUE , FALSE ) ; st = state_with_serialno ( 1 ) ; if ( st != NULL ) { free_state ( st ) ; } report_leaks ( ) ; tool_close_log ( ) ; exit ( 0 ) ; } 