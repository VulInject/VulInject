static int write_commit_graph_file ( struct write_commit_graph_context * ctx ) { uint32_t i ; int fd ; struct hashfile * f ; struct lock_file lk = LOCK_INIT ; const unsigned hashsz = the_hash_algo -> rawsz ; struct strbuf progress_title = STRBUF_INIT ; struct chunkfile * cf ; unsigned char file_hash [ GIT_MAX_RAWSZ ] ; if ( ctx -> split ) { struct strbuf tmp_file = STRBUF_INIT ; strbuf_addf ( & tmp_file , "%s/info/commit-graphs/tmp_graph_XXXXXX" , ctx -> odb -> path ) ; ctx -> graph_name = strbuf_detach ( & tmp_file , NULL ) ; } else { ctx -> graph_name = get_commit_graph_filename ( ctx -> odb ) ; } if ( safe_create_leading_directories ( ctx -> graph_name ) ) { UNLEAK ( ctx -> graph_name ) ; error ( _ ( "unable to create leading directories of %s" ) , ctx -> graph_name ) ; return - 1 ; } if ( ctx -> split ) { char * lock_name = get_commit_graph_chain_filename ( ctx -> odb ) ; hold_lock_file_for_update_mode ( & lk , lock_name , LOCK_DIE_ON_ERROR , 0444 ) ; fd = git_mkstemp_mode ( ctx -> graph_name , 0444 ) ; if ( fd < 0 ) { error ( _ ( "unable to create temporary graph layer" ) ) ; return - 1 ; } if ( adjust_shared_perm ( ctx -> graph_name ) ) { error ( _ ( "unable to adjust shared permissions for '%s'" ) , ctx -> graph_name ) ; return - 1 ; } f = hashfd ( fd , ctx -> graph_name ) ; } else { hold_lock_file_for_update_mode ( & lk , ctx -> graph_name , LOCK_DIE_ON_ERROR , 0444 ) ; fd = get_lock_file_fd ( & lk ) ; f = hashfd ( fd , get_lock_file_path ( & lk ) ) ; } cf = init_chunkfile ( f ) ; add_chunk ( cf , GRAPH_CHUNKID_OIDFANOUT , GRAPH_FANOUT_SIZE , write_graph_chunk_fanout ) ; add_chunk ( cf , GRAPH_CHUNKID_OIDLOOKUP , hashsz * ctx -> commits . nr , write_graph_chunk_oids ) ; add_chunk ( cf , GRAPH_CHUNKID_DATA , ( hashsz + 16 ) * ctx -> commits . nr , write_graph_chunk_data ) ; if ( ctx -> write_generation_data ) { add_chunk ( cf , GRAPH_CHUNKID_GENERATION_DATA , sizeof ( uint32_t ) * ctx -> commits . nr , write_graph_chunk_generation_data ) ; } if ( ctx -> num_generation_data_overflows ) { add_chunk ( cf , GRAPH_CHUNKID_GENERATION_DATA_OVERFLOW , sizeof ( timestamp_t ) * ctx -> num_generation_data_overflows , write_graph_chunk_generation_data_overflow ) ; } if ( ctx -> num_extra_edges ) { add_chunk ( cf , GRAPH_CHUNKID_EXTRAEDGES , 4 * ctx -> num_extra_edges , write_graph_chunk_extra_edges ) ; } if ( ctx -> changed_paths ) { add_chunk ( cf , GRAPH_CHUNKID_BLOOMINDEXES , sizeof ( uint32_t ) * ctx -> commits . nr , write_graph_chunk_bloom_indexes ) ; add_chunk ( cf , GRAPH_CHUNKID_BLOOMDATA , sizeof ( uint32_t ) * 3 + ctx -> total_bloom_filter_data_size , write_graph_chunk_bloom_data ) ; } if ( ctx -> num_commit_graphs_after > 1 ) { add_chunk ( cf , GRAPH_CHUNKID_BASE , hashsz * ( ctx -> num_commit_graphs_after - 1 ) , write_graph_chunk_base ) ; } hashwrite_be32 ( f , GRAPH_SIGNATURE ) ; hashwrite_u8 ( f , GRAPH_VERSION ) ; hashwrite_u8 ( f , oid_version ( the_hash_algo ) ) ; hashwrite_u8 ( f , get_num_chunks ( cf ) ) ; hashwrite_u8 ( f , ctx -> num_commit_graphs_after - 1 ) ; if ( ctx -> report_progress ) { strbuf_addf ( & progress_title , Q_ ( "Writing out commit graph in %d pass" , "Writing out commit graph in %d passes" , get_num_chunks ( cf ) ) , get_num_chunks ( cf ) ) ; ctx -> progress = start_delayed_progress ( progress_title . buf , get_num_chunks ( cf ) * ctx -> commits . nr ) ; } write_chunkfile ( cf , ctx ) ; stop_progress ( & ctx -> progress ) ; strbuf_release ( & progress_title ) ; if ( ctx -> split && ctx -> base_graph_name && ctx -> num_commit_graphs_after > 1 ) { char * new_base_hash = xstrdup ( oid_to_hex ( & ctx -> new_base_graph -> oid ) ) ; char * new_base_name = get_split_graph_filename ( ctx -> new_base_graph -> odb , new_base_hash ) ; free ( ctx -> commit_graph_filenames_after [ ctx -> num_commit_graphs_after - 2 ] ) ; free ( ctx -> commit_graph_hash_after [ ctx -> num_commit_graphs_after - 2 ] ) ; ctx -> commit_graph_filenames_after [ ctx -> num_commit_graphs_after - 2 ] = new_base_name ; ctx -> commit_graph_hash_after [ ctx -> num_commit_graphs_after - 2 ] = new_base_hash ; } close_commit_graph ( ctx -> r -> objects ) ; finalize_hashfile ( f , file_hash , FSYNC_COMPONENT_COMMIT_GRAPH , CSUM_HASH_IN_STREAM | CSUM_FSYNC ) ; free_chunkfile ( cf ) ; if ( ctx -> split ) { FILE * chainf = fdopen_lock_file ( & lk , "w" ) ; char * final_graph_name ; int result ; close ( fd ) ; if ( ! chainf ) { error ( _ ( "unable to open commit-graph chain file" ) ) ; return - 1 ; } if ( ctx -> base_graph_name ) { const char * dest ; int idx = ctx -> num_commit_graphs_after - 1 ; if ( ctx -> num_commit_graphs_after > 1 ) { idx -- ; } dest = ctx -> commit_graph_filenames_after [ idx ] ; if ( strcmp ( ctx -> base_graph_name , dest ) ) { result = rename ( ctx -> base_graph_name , dest ) ; if ( result ) { error ( _ ( "failed to rename base commit-graph file" ) ) ; return - 1 ; } } } else { char * graph_name = get_commit_graph_filename ( ctx -> odb ) ; unlink ( graph_name ) ; free ( graph_name ) ; } ctx -> commit_graph_hash_after [ ctx -> num_commit_graphs_after - 1 ] = xstrdup ( hash_to_hex ( file_hash ) ) ; final_graph_name = get_split_graph_filename ( ctx -> odb , ctx -> commit_graph_hash_after [ ctx -> num_commit_graphs_after - 1 ] ) ; ctx -> commit_graph_filenames_after [ ctx -> num_commit_graphs_after - 1 ] = final_graph_name ; result = rename ( ctx -> graph_name , final_graph_name ) ; for ( i = 0 ; i < ctx -> num_commit_graphs_after ; i ++ ) { fprintf ( get_lock_file_fp ( & lk ) , "%s\n" , ctx -> commit_graph_hash_after [ i ] ) ; } if ( result ) { error ( _ ( "failed to rename temporary commit-graph file" ) ) ; return - 1 ; } } commit_lock_file ( & lk ) ; return 0 ; } 