size_t streamReplyWithRange ( client * c , stream * s , streamID * start , streamID * end , size_t count , int rev , streamCG * group , streamConsumer * consumer , int flags , streamPropInfo * spi ) { void * arraylen_ptr = NULL ; size_t arraylen = 0 ; streamIterator si ; int64_t numfields ; streamID id ; int propagate_last_id = 0 ; int noack = flags & STREAM_RWR_NOACK ; if ( group && ( flags & STREAM_RWR_HISTORY ) ) { return streamReplyWithRangeFromConsumerPEL ( c , s , start , end , count , consumer ) ; } if ( ! ( flags & STREAM_RWR_RAWENTRIES ) ) { arraylen_ptr = addReplyDeferredLen ( c ) ; } streamIteratorStart ( & si , s , start , end , rev ) ; while ( streamIteratorGetID ( & si , & id , & numfields ) ) { if ( group && streamCompareID ( & id , & group -> last_id ) > 0 ) { if ( group -> entries_read != SCG_INVALID_ENTRIES_READ && ! streamRangeHasTombstones ( s , & id , NULL ) ) { group -> entries_read ++ ; } if ( s -> entries_added ) { group -> entries_read = streamEstimateDistanceFromFirstEverEntry ( s , & id ) ; } group -> last_id = id ; if ( noack ) { propagate_last_id = 1 ; } } addReplyArrayLen ( c , 2 ) ; addReplyStreamID ( c , & id ) ; addReplyArrayLen ( c , numfields * 2 ) ; while ( numfields -- ) { unsigned char * key , * value ; int64_t key_len , value_len ; streamIteratorGetField ( & si , & key , & value , & key_len , & value_len ) ; addReplyBulkCBuffer ( c , key , key_len ) ; addReplyBulkCBuffer ( c , value , value_len ) ; } if ( group && ! noack ) { unsigned char buf [ sizeof ( streamID ) ] ; streamEncodeID ( buf , & id ) ; streamNACK * nack = streamCreateNACK ( consumer ) ; int group_inserted = raxTryInsert ( group -> pel , buf , sizeof ( buf ) , nack , NULL ) ; int consumer_inserted = raxTryInsert ( consumer -> pel , buf , sizeof ( buf ) , nack , NULL ) ; if ( group_inserted == 0 ) { nack = raxFind ( group -> pel , buf , sizeof ( buf ) ) ; serverAssert ( nack != raxNotFound ) ; raxRemove ( nack -> consumer -> pel , buf , sizeof ( buf ) , NULL ) ; nack -> consumer = consumer ; nack -> delivery_time = commandTimeSnapshot ( ) ; nack -> delivery_count = 1 ; raxInsert ( consumer -> pel , buf , sizeof ( buf ) , nack , NULL ) ; } if ( group_inserted == 1 && consumer_inserted == 0 ) { serverPanic ( "NACK half-created. Should not be possible." ) ; } consumer -> active_time = commandTimeSnapshot ( ) ; if ( spi ) { robj * idarg = createObjectFromStreamID ( & id ) ; streamPropagateXCLAIM ( c , spi -> keyname , group , spi -> groupname , idarg , nack ) ; decrRefCount ( idarg ) ; } } arraylen ++ ; if ( count && count == arraylen ) { break ; } } if ( spi && propagate_last_id ) { streamPropagateGroupID ( c , spi -> keyname , group , spi -> groupname ) ; } streamIteratorStop ( & si ) ; if ( arraylen_ptr ) { setDeferredArrayLen ( c , arraylen_ptr , arraylen ) ; } return arraylen ; } 