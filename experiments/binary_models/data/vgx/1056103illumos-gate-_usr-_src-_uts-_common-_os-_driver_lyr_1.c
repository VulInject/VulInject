int ldi_vp_from_name ( char * path , vnode_t * * vpp ) { vnode_t * vp = NULL ; int ret ; if ( ( path == NULL ) || ( vpp == NULL ) ) { return ( EINVAL ) ; } if ( modrootloaded ) { cred_t * saved_cred = curthread -> t_cred ; curthread -> t_cred = kcred ; ASSERT ( * path == '/' ) ; ret = lookupnameat ( path + 1 , UIO_SYSSPACE , FOLLOW , NULLVPP , & vp , rootdir ) ; curthread -> t_cred = saved_cred ; if ( ret == 0 ) { if ( ! vn_matchops ( vp , spec_getvnodeops ( ) ) || ! VTYP_VALID ( vp -> v_type ) ) { VN_RELE ( vp , NULL ) ; return ( ENXIO ) ; } } } if ( vp == NULL ) { dev_info_t * dip ; dev_t dev ; int spec_type ; if ( strncmp ( path , "/devices/" , 9 ) == 0 ) { path += strlen ( "/devices" ) ; } ret = resolve_pathname ( path , & dip , & dev , & spec_type ) ; if ( ret != 0 ) { return ( ENODEV ) ; } ASSERT ( STYP_VALID ( spec_type ) ) ; vp = makespecvp ( dev , STYP_TO_VTYP ( spec_type ) ) ; spec_assoc_vp_with_devi ( vp , dip ) ; ddi_release_devi ( dip ) ; } * vpp = vp ; return ( 0 ) ; } 