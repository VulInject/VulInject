static int cifs_partialpagewrite ( struct page * page , unsigned from , unsigned to ) { struct address_space * mapping = page -> mapping ; loff_t offset = ( loff_t ) page -> index << PAGE_SHIFT ; char * write_data ; int rc = - EFAULT ; int bytes_written ; struct inode * inode ; struct cifsFileInfo * open_file ; if ( ! mapping || ! mapping -> host ) { return - EFAULT ; } inode = page -> mapping -> host ; offset += ( loff_t ) from ; write_data = kmap ( page ) ; write_data += from ; if ( ( to > PAGE_SIZE ) || ( from > to ) ) { kunmap ( page ) ; return - EIO ; } if ( offset > mapping -> host -> i_size ) { kunmap ( page ) ; return 0 ; } if ( mapping -> host -> i_size - offset < ( loff_t ) to ) { to = ( unsigned ) ( mapping -> host -> i_size - offset ) ; } open_file = find_writable_file ( CIFS_I ( mapping -> host ) , false ) ; if ( open_file ) { bytes_written = cifs_write ( open_file , open_file -> pid , write_data , to - from , & offset ) ; cifsFileInfo_put ( open_file ) ; inode -> i_atime = inode -> i_mtime = current_time ( inode ) ; if ( ( bytes_written > 0 ) && ( offset ) ) { rc = 0 ; } if ( bytes_written < 0 ) { rc = bytes_written ; } } else { cifs_dbg ( FYI , "No writeable filehandles for inode\n" ) ; rc = - EIO ; } kunmap ( page ) ; return rc ; } 