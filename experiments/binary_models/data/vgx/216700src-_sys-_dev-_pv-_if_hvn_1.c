int hvn_nvs_attach ( struct hvn_softc * sc ) { const uint32_t protos [ ] { HVN_NVS_PROTO_VERSION_5 HVN_NVS_PROTO_VERSION_4 HVN_NVS_PROTO_VERSION_2 HVN_NVS_PROTO_VERSION_1 } ; ; struct hvn_nvs_init cmd ; struct hvn_nvs_init_resp * rsp ; struct hvn_nvs_ndis_init ncmd ; struct hvn_nvs_ndis_conf ccmd ; uint32_t ndisver , ringsize ; uint64_t tid ; int i ; sc -> sc_nvsbuf = malloc ( HVN_NVS_BUFSIZE , M_DEVBUF , M_ZERO | ( cold ?M_NOWAIT : M_WAITOK ) ) ; if ( sc -> sc_nvsbuf == NULL ) { DPRINTF ( "%s: failed to allocate channel data buffer\n" , sc -> sc_dev . dv_xname ) ; return ( - 1 ) ; } ringsize = HVN_RNDIS_CTLREQS * ( sizeof ( hvn_nvs_rndis ) + sizeof ( vmbus_gpa ) ) + HVN_TX_DESC * ( sizeof ( hvn_nvs_rndis ) + ( HVN_TX_FRAGS + 1 ) * sizeof ( vmbus_gpa ) ) ; sc -> sc_chan -> ch_flags &= ~ CHF_BATCHED ; if ( hv_channel_open ( sc -> sc_chan , ringsize , NULL , 0 , hvn_nvs_intr , sc ) ) { DPRINTF ( "%s: failed to open channel\n" , sc -> sc_dev . dv_xname ) ; free ( sc -> sc_nvsbuf , M_DEVBUF , HVN_NVS_BUFSIZE ) ; return ( - 1 ) ; } hv_evcount_attach ( sc -> sc_chan , sc -> sc_dev . dv_xname ) ; cmd . nvs_type = HVN_NVS_TYPE_INIT ; for ( i = 0 ; i < nitems ( protos ) ; i ++ ) { cmd . nvs_ver_min = cmd . nvs_ver_max = protos [ i ] ; tid = atomic_inc_int_nv ( & sc -> sc_nvstid ) ; if ( hvn_nvs_cmd ( sc , & cmd , sizeof ( cmd ) , tid , 100 ) ) { return ( - 1 ) ; } rsp = ( hvn_nvs_init_resp * ) & sc -> sc_nvsrsp ; if ( rsp -> nvs_status == HVN_NVS_STATUS_OK ) { sc -> sc_proto = protos [ i ] ; break ; } } if ( ! sc -> sc_proto ) { DPRINTF ( "%s: failed to negotiate NVSP version\n" , sc -> sc_dev . dv_xname ) ; return ( - 1 ) ; } if ( sc -> sc_proto >= HVN_NVS_PROTO_VERSION_2 ) { memset ( & ccmd , 0 , sizeof ( ccmd ) ) ; ccmd . nvs_type = HVN_NVS_TYPE_NDIS_CONF ; ccmd . nvs_mtu = HVN_MAXMTU ; ccmd . nvs_caps = HVN_NVS_NDIS_CONF_VLAN ; tid = atomic_inc_int_nv ( & sc -> sc_nvstid ) ; if ( hvn_nvs_cmd ( sc , & ccmd , sizeof ( ccmd ) , tid , 100 ) ) { return ( - 1 ) ; } } memset ( & ncmd , 0 , sizeof ( ncmd ) ) ; ncmd . nvs_type = HVN_NVS_TYPE_NDIS_INIT ; if ( sc -> sc_proto <= HVN_NVS_PROTO_VERSION_4 ) { ndisver = NDIS_VERSION_6_1 ; } else { ndisver = NDIS_VERSION_6_30 ; } ncmd . nvs_ndis_major = ( ndisver & 0xffff0000 ) >> 16 ; ncmd . nvs_ndis_minor = ( ndisver & 0x0000ffff ) ; tid = atomic_inc_int_nv ( & sc -> sc_nvstid ) ; if ( hvn_nvs_cmd ( sc , & ncmd , sizeof ( ncmd ) , tid , 100 ) ) { return ( - 1 ) ; } sc -> sc_ndisver = ndisver ; return ( 0 ) ; } 