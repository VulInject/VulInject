static int super_90_validate ( struct mddev * mddev , struct md_rdev * rdev ) { mdp_disk_t * desc ; mdp_super_t * sb = page_address ( rdev -> sb_page ) ; __u64 ev1 = md_event ( sb ) ; rdev -> raid_disk = - 1 ; clear_bit ( Faulty , & rdev -> flags ) ; clear_bit ( In_sync , & rdev -> flags ) ; clear_bit ( Bitmap_sync , & rdev -> flags ) ; clear_bit ( WriteMostly , & rdev -> flags ) ; if ( mddev -> raid_disks == 0 ) { mddev -> major_version = 0 ; mddev -> minor_version = sb -> minor_version ; mddev -> patch_version = sb -> patch_version ; mddev -> external = 0 ; mddev -> chunk_sectors = sb -> chunk_size >> 9 ; mddev -> ctime = sb -> ctime ; mddev -> utime = sb -> utime ; mddev -> level = sb -> level ; mddev -> clevel [ 0 ] = 0 ; mddev -> layout = sb -> layout ; mddev -> raid_disks = sb -> raid_disks ; mddev -> dev_sectors = ( ( sector_t ) sb -> size ) * 2 ; mddev -> events = ev1 ; mddev -> bitmap_info . offset = 0 ; mddev -> bitmap_info . space = 0 ; mddev -> bitmap_info . default_offset = MD_SB_BYTES >> 9 ; mddev -> bitmap_info . default_space = 64 * 2 - ( MD_SB_BYTES >> 9 ) ; if ( mddev -> minor_version >= 91 ) { mddev -> reshape_position = sb -> reshape_position ; mddev -> delta_disks = sb -> delta_disks ; mddev -> new_level = sb -> new_level ; mddev -> new_layout = sb -> new_layout ; mddev -> new_chunk_sectors = sb -> new_chunk >> 9 ; if ( mddev -> delta_disks < 0 ) { mddev -> reshape_backwards = 1 ; } } else { mddev -> reshape_position = MaxSector ; mddev -> delta_disks = 0 ; mddev -> new_level = mddev -> level ; mddev -> new_layout = mddev -> layout ; mddev -> new_chunk_sectors = mddev -> chunk_sectors ; } if ( sb -> state & ( 1 << MD_SB_CLEAN ) ) { mddev -> recovery_cp = MaxSector ; } else { if ( sb -> events_hi == sb -> cp_events_hi && sb -> events_lo == sb -> cp_events_lo ) { mddev -> recovery_cp = sb -> recovery_cp ; } else { mddev -> recovery_cp = 0 ; } } memcpy ( mddev -> uuid + 0 , & sb -> set_uuid0 , 4 ) ; memcpy ( mddev -> uuid + 4 , & sb -> set_uuid1 , 4 ) ; memcpy ( mddev -> uuid + 8 , & sb -> set_uuid2 , 4 ) ; memcpy ( mddev -> uuid + 12 , & sb -> set_uuid3 , 4 ) ; mddev -> max_disks = MD_SB_DISKS ; if ( sb -> state & ( 1 << MD_SB_BITMAP_PRESENT ) && mddev -> bitmap_info . file == NULL ) { mddev -> bitmap_info . offset = mddev -> bitmap_info . default_offset ; mddev -> bitmap_info . space = mddev -> bitmap_info . default_space ; } } if ( mddev -> pers == NULL ) { ++ ev1 ; if ( sb -> disks [ rdev -> desc_nr ] . state & ( ( 1 << MD_DISK_SYNC ) | ( 1 << MD_DISK_ACTIVE ) ) ) { if ( ev1 < mddev -> events ) { return - EINVAL ; } } } if ( mddev -> bitmap ) { if ( ev1 < mddev -> bitmap -> events_cleared ) { return 0 ; } if ( ev1 < mddev -> events ) { set_bit ( Bitmap_sync , & rdev -> flags ) ; } } else { if ( ev1 < mddev -> events ) { return 0 ; } } if ( mddev -> level != LEVEL_MULTIPATH ) { desc = sb -> disks + rdev -> desc_nr ; if ( desc -> state & ( 1 << MD_DISK_FAULTY ) ) { set_bit ( Faulty , & rdev -> flags ) ; } if ( desc -> state & ( 1 << MD_DISK_SYNC ) ) { set_bit ( In_sync , & rdev -> flags ) ; rdev -> raid_disk = desc -> raid_disk ; rdev -> saved_raid_disk = desc -> raid_disk ; } if ( desc -> state & ( 1 << MD_DISK_ACTIVE ) ) { if ( mddev -> minor_version >= 91 ) { rdev -> recovery_offset = 0 ; rdev -> raid_disk = desc -> raid_disk ; } } if ( desc -> state & ( 1 << MD_DISK_WRITEMOSTLY ) ) { set_bit ( WriteMostly , & rdev -> flags ) ; } if ( desc -> state & ( 1 << MD_DISK_FAILFAST ) ) { set_bit ( FailFast , & rdev -> flags ) ; } } else { set_bit ( In_sync , & rdev -> flags ) ; } return 0 ; } 