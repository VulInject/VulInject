static enum VAR1 FUN1(struct VAR2 *VAR3, struct VAR4 *VAR5)
{
u32 VAR6 = FUN2(VAR5) & (VAR7 - 1);
struct VAR8 *VAR8 = &VAR3->VAR9[VAR6];
struct VAR10 *VAR11 = &VAR12;
struct VAR13 *VAR14;
__be16 VAR15 = VAR5->VAR16;
struct VAR4 *VAR17 = NULL;
enum gro_result VAR18;
int VAR19;
int VAR20;

if (FUN3(VAR5->VAR21))
goto VAR22;

FUN4(&VAR8->VAR23, VAR5);

FUN5();
FUN6(VAR14, VAR11, VAR23) {
if (VAR14->VAR15 == VAR15 && VAR14->VAR24.VAR25)
goto VAR26;
}
FUN7();
goto VAR22;

VAR26:
FUN8(VAR5, FUN9(VAR5));
FUN10(VAR5);
FUN11(FUN12(struct VAR27, VAR28) != sizeof(VAR29));
FUN11(!FUN13(FUN14(struct VAR27, VAR28),
sizeof(VAR29))); 
*(VAR29 *)&FUN15(VAR5)->VAR28 = 0;
FUN15(VAR5)->VAR30 = FUN16(VAR5);
FUN15(VAR5)->VAR31 = 1;
FUN15(VAR5)->VAR32 = 1;
if (FUN17(FUN18(VAR5))) {
FUN15(VAR5)->VAR32 = FUN19(VAR5)->VAR33;

if (!FUN20(VAR5) ||
(FUN19(VAR5)->VAR34 & VAR35))
FUN15(VAR5)->VAR30 = 1;
}


switch (VAR5->VAR36) {
case VAR37:
FUN15(VAR5)->VAR38 = VAR5->VAR38;
FUN15(VAR5)->VAR39 = 1;
break;
case VAR40:
FUN15(VAR5)->VAR41 = VAR5->VAR42 + 1;
break;
}

VAR17 = FUN21(VAR14->VAR24.VAR25,
VAR43, VAR44,
&VAR8->VAR23, VAR5);

FUN7();

if (FUN22(VAR17) == -VAR45) {
VAR18 = VAR46;
goto VAR47;
}

VAR19 = FUN15(VAR5)->VAR19;
VAR18 = FUN15(VAR5)->free ? VAR48 : VAR49;

if (VAR17) {
FUN23(VAR17);
FUN24(VAR3, VAR17);
VAR8->VAR32--;
}

if (VAR19)
goto VAR47;

if (FUN15(VAR5)->VAR30)
goto VAR22;

if (FUN17(VAR8->VAR32 >= VAR50))
FUN25(VAR3, &VAR8->VAR23);
else
VAR8->VAR32++;

FUN15(VAR5)->VAR51 = VAR52;
FUN15(VAR5)->VAR53 = VAR5;
if (!FUN18(VAR5))
FUN19(VAR5)->VAR54 = FUN26(VAR5);
FUN27(&VAR5->VAR23, &VAR8->VAR23);
VAR18 = VAR55;

VAR56:
VAR20 = FUN9(VAR5) - FUN28(VAR5);
if (VAR20 > 0)
FUN29(VAR5, VAR20);
VAR47:
if (VAR8->VAR32) {
if (!FUN30(VAR6, &VAR3->VAR57))
FUN31(VAR6, &VAR3->VAR57);
} else if (FUN30(VAR6, &VAR3->VAR57)) {
FUN32(VAR6, &VAR3->VAR57);
}

return VAR18;

VAR22:
VAR18 = VAR58;
goto VAR56;
}