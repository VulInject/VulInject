struct msm_dsi_pll * msm_dsi_pll_28nm_init ( struct platform_device * pdev , enum msm_dsi_phy_type type , int id ) { struct dsi_pll_28nm * pll_28nm ; struct msm_dsi_pll * pll ; int ret ; if ( ! pdev ) { return ERR_PTR ( - ENODEV ) ; } pll_28nm = devm_kzalloc ( & pdev -> dev , sizeof ( * pll_28nm ) , GFP_KERNEL ) ; pll_28nm -> pdev = pdev ; pll_28nm -> id = id ; pll_28nm -> mmio = msm_ioremap ( pdev , "dsi_pll" , "DSI_PLL" ) ; if ( IS_ERR_OR_NULL ( pll_28nm -> mmio ) ) { dev_err ( & pdev -> dev , "%s: failed to map pll base\n" , __func__ ) ; return ERR_PTR ( - ENOMEM ) ; } pll = & pll_28nm -> base ; pll -> min_rate = VCO_MIN_RATE ; pll -> max_rate = VCO_MAX_RATE ; pll -> get_provider = dsi_pll_28nm_get_provider ; pll -> destroy = dsi_pll_28nm_destroy ; pll -> disable_seq = dsi_pll_28nm_disable_seq ; pll -> save_state = dsi_pll_28nm_save_state ; pll -> restore_state = dsi_pll_28nm_restore_state ; if ( type == MSM_DSI_PHY_28NM_HPM ) { pll_28nm -> vco_delay = 1 ; pll -> en_seq_cnt = 3 ; pll -> enable_seqs [ 0 ] = dsi_pll_28nm_enable_seq_hpm ; pll -> enable_seqs [ 1 ] = dsi_pll_28nm_enable_seq_hpm ; pll -> enable_seqs [ 2 ] = dsi_pll_28nm_enable_seq_hpm ; } if ( type == MSM_DSI_PHY_28NM_LP ) { pll_28nm -> vco_delay = 1000 ; pll -> en_seq_cnt = 1 ; pll -> enable_seqs [ 0 ] = dsi_pll_28nm_enable_seq_lp ; } else { dev_err ( & pdev -> dev , "phy type (%d) is not 28nm\n" , type ) ; return ERR_PTR ( - EINVAL ) ; } ret = pll_28nm_register ( pll_28nm ) ; if ( ret ) { dev_err ( & pdev -> dev , "failed to register PLL: %d\n" , ret ) ; return ERR_PTR ( ret ) ; } return pll ; } 