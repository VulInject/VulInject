int nouveau_display_create ( struct drm_device * dev ) { struct nouveau_drm * drm = nouveau_drm ( dev ) ; struct nouveau_display * disp ; int ret ; disp = drm -> display = kzalloc ( sizeof ( * disp ) , GFP_KERNEL ) ; drm_mode_config_init ( dev ) ; drm_mode_create_scaling_mode_property ( dev ) ; drm_mode_create_dvi_i_properties ( dev ) ; dev -> mode_config . funcs = & nouveau_mode_config_funcs ; dev -> mode_config . min_width = 0 ; dev -> mode_config . min_height = 0 ; if ( drm -> client . device . info . family < NV_DEVICE_INFO_V0_CELSIUS ) { dev -> mode_config . max_width = 2048 ; dev -> mode_config . max_height = 2048 ; } if ( drm -> client . device . info . family < NV_DEVICE_INFO_V0_TESLA ) { dev -> mode_config . max_width = 4096 ; dev -> mode_config . max_height = 4096 ; } if ( drm -> client . device . info . family < NV_DEVICE_INFO_V0_FERMI ) { dev -> mode_config . max_width = 8192 ; dev -> mode_config . max_height = 8192 ; } else { dev -> mode_config . max_width = 16384 ; dev -> mode_config . max_height = 16384 ; } dev -> mode_config . preferred_depth = 24 ; dev -> mode_config . prefer_shadow = 1 ; if ( drm -> client . device . info . chipset < 0x11 ) { dev -> mode_config . async_page_flip = false ; } else { dev -> mode_config . async_page_flip = true ; } drm_kms_helper_poll_init ( dev ) ; drm_kms_helper_poll_disable ( dev ) ; if ( nouveau_modeset != 2 && drm -> vbios . dcb . entries ) { ret = nvif_disp_ctor ( & drm -> client . device , "kmsDisp" , 0 , & disp -> disp ) ; if ( ret == 0 ) { nouveau_display_create_properties ( dev ) ; if ( disp -> disp . object . oclass < NV50_DISP ) { dev -> mode_config . fb_modifiers_not_supported = true ; ret = nv04_display_create ( dev ) ; } else { ret = nv50_display_create ( dev ) ; } } } else { ret = 0 ; } if ( ret ) { disp_create_err } drm_mode_config_reset ( dev ) ; if ( dev -> mode_config . num_crtc ) { ret = drm_vblank_init ( dev , dev -> mode_config . num_crtc ) ; if ( ret ) { vblank_err } if ( disp -> disp . object . oclass >= NV50_DISP ) { nv50_crc_init ( dev ) ; } } INIT_WORK ( & drm -> hpd_work , nouveau_display_hpd_work ) ; spin_lock_init ( & drm -> hpd_lock ) ; drm -> acpi_nb . notifier_call = nouveau_display_acpi_ntfy ; register_acpi_notifier ( & drm -> acpi_nb ) ; return 0 ; vblank_err disp -> dtor ( dev ) ; disp_create_err drm_kms_helper_poll_fini ( dev ) ; drm_mode_config_cleanup ( dev ) ; return ret ; } 