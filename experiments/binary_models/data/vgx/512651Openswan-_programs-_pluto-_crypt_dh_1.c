static void calc_skeyseed_v2 ( struct pcr_skeyid_q * skq , chunk_t shared , const size_t keysize , chunk_t * skeyseed , chunk_t * SK_d , chunk_t * SK_ai , chunk_t * SK_ar , chunk_t * SK_ei , chunk_t * SK_er , chunk_t * SK_pi , chunk_t * SK_pr ) { struct v2prf_stuff vpss ; size_t total_keysize ; memset ( & vpss , 0 , sizeof ( vpss ) ) ; chunk_t hmac_opad , hmac_ipad , hmac_pad_prf , counter ; CK_OBJECT_HANDLE keyhandle ; SECItem param , param1 ; DBG ( DBG_CRYPT , DBG_log ( "NSS: Started key computation\n" ) ) ; PK11SymKey * skeyseed_k , * SK_d_k , * SK_ai_k , * SK_ar_k , * SK_ei_k , * SK_er_k , * SK_pi_k , * SK_pr_k ; setchunk_fromwire ( vpss . ni , & skq -> ni , skq ) ; setchunk_fromwire ( vpss . nr , & skq -> nr , skq ) ; setchunk_fromwire ( vpss . spii , & skq -> icookie , skq ) ; setchunk_fromwire ( vpss . spir , & skq -> rcookie , skq ) ; DBG ( DBG_CONTROLMORE , DBG_log ( "calculating skeyseed using prf=%s integ=%s cipherkey=%lu" , enum_name ( & ikev2_prf_names , skq -> v2_prf ) , enum_name ( ikev2_integ_names . official_names , skq -> v2_integ ) , ( long unsigned ) keysize ) ) ; const struct ike_integ_desc * hasher = ike_alg_get_prf ( skq -> v2_prf ) ; passert ( hasher ) ; const struct ike_encr_desc * encrypter = skq -> encrypter ; passert ( encrypter ) ; hmac_opad = hmac_pads ( HMAC_OPAD , HMAC_BUFSIZE ) ; hmac_ipad = hmac_pads ( HMAC_IPAD , HMAC_BUFSIZE ) ; hmac_pad_prf = hmac_pads ( 0x00 , HMAC_BUFSIZE - hasher -> hash_digest_len ) ; { skeyid_digisig ( vpss . ni , vpss . nr , shared , hasher , skeyseed ) ; memcpy ( & skeyseed_k , skeyseed -> ptr , skeyseed -> len ) ; } vpss . prf_hasher = ike_alg_get_prf ( skq -> v2_prf ) ; passert ( vpss . prf_hasher ) ; { struct hmac_ctx ctx ; unsigned int keybytes ; unsigned char * kb ; if ( vpss . prf_hasher -> hash_key_size == 0 ) { keybytes = vpss . ni . len + vpss . nr . len ; } else { keybytes = vpss . prf_hasher -> hash_key_size ; } kb = alloc_bytes ( keybytes , "skeyseed prf key" ) ; memset ( kb , 0 , keybytes ) ; memcpy ( kb , vpss . ni . ptr , vpss . ni . len ) ; memcpy ( kb + vpss . ni . len , vpss . nr . ptr , vpss . nr . len ) ; DBG ( DBG_CRYPT , DBG_dump ( "Input to SKEYSEED: " , kb , keybytes ) ) ; hmac_init ( & ctx , vpss . prf_hasher , kb , keybytes ) ; hmac_update_chunk ( & ctx , shared ) ; hmac_final_chunk ( * skeyseed , "skeyseed base" , & ctx ) ; vpss . skeyseed = skeyseed ; pfree ( kb ) ; } { const struct ike_integ_desc * integ_hasher = ike_alg_get_integ ( skq -> v2_integ ) ; int skd_bytes = hasher -> hash_key_size ; int skp_bytes = hasher -> hash_key_size ; int skd_bytes = vpss . prf_hasher -> hash_key_size ; int skp_bytes = vpss . prf_hasher -> hash_key_size ; int ska_bytes = integ_hasher -> hash_key_size ; int ske_bytes = keysize ; vpss . counter [ 0 ] = 0x01 ; vpss . t . len = 0 ; total_keysize = skd_bytes + ( 2 * ( ska_bytes + ske_bytes + skp_bytes ) ) ; DBG ( , "PRF+ input" "Ni" "Nr" "SPIi" "SPIr" "Total keysize needed %d" ) counter . ptr = & vpss . counter [ 0 ] ; counter . len = 1 ; PK11SymKey * finalkey = NULL ; PK11SymKey * tkey1 = pk11_derive_wrapper_osw ( skeyseed_k , CKM_CONCATENATE_BASE_AND_DATA , hmac_pad_prf , CKM_XOR_BASE_AND_DATA , CKA_DERIVE , HMAC_BUFSIZE ) ; PR_ASSERT ( tkey1 != NULL ) ; for ( ; ; ) { PK11SymKey * tkey11 , * tkey3 ; tkey11 = NULL ; if ( vpss . counter [ 0 ] == 0x01 ) { PK11SymKey * tkey2 = pk11_derive_wrapper_osw ( tkey1 , CKM_XOR_BASE_AND_DATA , hmac_ipad , CKM_CONCATENATE_BASE_AND_DATA , CKA_DERIVE , 0 ) ; PR_ASSERT ( tkey2 != NULL ) ; tkey3 = pk11_derive_wrapper_osw ( tkey2 , CKM_CONCATENATE_BASE_AND_DATA , vpss . ni , CKM_CONCATENATE_BASE_AND_DATA , CKA_DERIVE , 0 ) ; PK11_FreeSymKey ( tkey2 ) ; } else { PK11SymKey * tkey2 = pk11_derive_wrapper_osw ( tkey1 , CKM_XOR_BASE_AND_DATA , hmac_ipad , CKM_CONCATENATE_BASE_AND_KEY , CKA_DERIVE , 0 ) ; PR_ASSERT ( tkey2 != NULL ) ; keyhandle = PK11_GetSymKeyHandle ( tkey2 ) ; param . data = ( unsigned char * ) & keyhandle ; param . len = sizeof ( keyhandle ) ; PK11SymKey * tkey12 = PK11_Derive_osw ( tkey2 , CKM_CONCATENATE_BASE_AND_KEY , & param , CKM_CONCATENATE_BASE_AND_DATA , CKA_DERIVE , 0 ) ; PR_ASSERT ( tkey12 != NULL ) ; tkey3 = pk11_derive_wrapper_osw ( tkey12 , CKM_CONCATENATE_BASE_AND_DATA , vpss . ni , CKM_CONCATENATE_BASE_AND_DATA , CKA_DERIVE , 0 ) ; PK11_FreeSymKey ( tkey2 ) ; PK11_FreeSymKey ( tkey12 ) ; } PR_ASSERT ( tkey3 != NULL ) ; PK11SymKey * tkey4 = pk11_derive_wrapper_osw ( tkey3 , CKM_CONCATENATE_BASE_AND_DATA , vpss . nr , CKM_CONCATENATE_BASE_AND_DATA , CKA_DERIVE , 0 ) ; PR_ASSERT ( tkey4 != NULL ) ; PK11SymKey * tkey5 = pk11_derive_wrapper_osw ( tkey4 , CKM_CONCATENATE_BASE_AND_DATA , vpss . spii , CKM_CONCATENATE_BASE_AND_DATA , CKA_DERIVE , 0 ) ; PR_ASSERT ( tkey5 != NULL ) ; PK11SymKey * tkey6 = pk11_derive_wrapper_osw ( tkey5 , CKM_CONCATENATE_BASE_AND_DATA , vpss . spir , CKM_CONCATENATE_BASE_AND_DATA , CKA_DERIVE , 0 ) ; PR_ASSERT ( tkey6 != NULL ) ; PK11SymKey * tkey7 = pk11_derive_wrapper_osw ( tkey6 , CKM_CONCATENATE_BASE_AND_DATA , counter , nss_key_derivation_mech ( hasher ) , CKA_DERIVE , 0 ) ; PR_ASSERT ( tkey7 != NULL ) ; PK11SymKey * tkey8 = PK11_Derive_osw ( tkey7 , nss_key_derivation_mech ( hasher ) , NULL , CKM_CONCATENATE_BASE_AND_DATA , CKA_DERIVE , 0 ) ; PR_ASSERT ( tkey8 != NULL ) ; PK11SymKey * tkey9 = pk11_derive_wrapper_osw ( tkey1 , CKM_XOR_BASE_AND_DATA , hmac_opad , CKM_CONCATENATE_BASE_AND_KEY , CKA_DERIVE , 0 ) ; PR_ASSERT ( tkey9 != NULL ) ; keyhandle = PK11_GetSymKeyHandle ( tkey8 ) ; param . data = ( unsigned char * ) & keyhandle ; param . len = sizeof ( keyhandle ) ; PK11SymKey * tkey10 = PK11_Derive_osw ( tkey9 , CKM_CONCATENATE_BASE_AND_KEY , & param , nss_key_derivation_mech ( hasher ) , CKA_DERIVE , 0 ) ; PR_ASSERT ( tkey10 != NULL ) ; if ( vpss . counter [ 0 ] == 0x01 ) { finalkey = PK11_Derive_osw ( tkey10 , nss_key_derivation_mech ( hasher ) , NULL , CKM_CONCATENATE_BASE_AND_KEY , CKA_DERIVE , 0 ) ; PR_ASSERT ( finalkey != NULL ) ; tkey11 = PK11_Derive_osw ( tkey10 , nss_key_derivation_mech ( hasher ) , NULL , CKM_CONCATENATE_BASE_AND_KEY , CKA_DERIVE , 0 ) ; PR_ASSERT ( tkey11 != NULL ) ; } else { tkey11 = PK11_Derive_osw ( tkey10 , nss_key_derivation_mech ( hasher ) , NULL , CKM_EXTRACT_KEY_FROM_KEY , CKA_DERIVE , 0 ) ; PR_ASSERT ( tkey11 != NULL ) ; keyhandle = PK11_GetSymKeyHandle ( tkey11 ) ; param . data = ( unsigned char * ) & keyhandle ; param . len = sizeof ( keyhandle ) ; if ( total_keysize <= ( PK11_GetKeyLength ( finalkey ) + PK11_GetKeyLength ( tkey11 ) ) ) { finalkey = PK11_Derive_osw ( finalkey , CKM_CONCATENATE_BASE_AND_KEY , & param , CKM_EXTRACT_KEY_FROM_KEY , CKA_DERIVE , 0 ) ; PR_ASSERT ( finalkey != NULL ) ; } else { finalkey = PK11_Derive_osw ( finalkey , CKM_CONCATENATE_BASE_AND_KEY , & param , CKM_CONCATENATE_BASE_AND_KEY , CKA_DERIVE , 0 ) ; PR_ASSERT ( finalkey != NULL ) ; } } PK11_FreeSymKey ( tkey3 ) ; PK11_FreeSymKey ( tkey4 ) ; PK11_FreeSymKey ( tkey5 ) ; PK11_FreeSymKey ( tkey6 ) ; PK11_FreeSymKey ( tkey7 ) ; PK11_FreeSymKey ( tkey8 ) ; PK11_FreeSymKey ( tkey9 ) ; PK11_FreeSymKey ( tkey10 ) ; if ( total_keysize <= PK11_GetKeyLength ( finalkey ) ) { PK11_FreeSymKey ( tkey1 ) ; PK11_FreeSymKey ( tkey11 ) ; break ; } vpss . counter [ 0 ] ++ ; } DBG ( DBG_CRYPT , DBG_log ( "NSS ikev2: finished computing key material for IKEv2 SA\n" ) ) ; CK_EXTRACT_PARAMS bs = 0 ; SK_d_k = pk11_extract_derive_wrapper_osw ( finalkey , bs , CKM_CONCATENATE_BASE_AND_DATA , CKA_DERIVE , skd_bytes ) ; bs = skd_bytes * BITS_PER_BYTE ; SK_ai_k = pk11_extract_derive_wrapper_osw ( finalkey , bs , CKM_CONCATENATE_BASE_AND_DATA , CKA_DERIVE , ska_bytes ) ; bs = ( skd_bytes + ska_bytes ) * BITS_PER_BYTE ; SK_ar_k = pk11_extract_derive_wrapper_osw ( finalkey , bs , CKM_CONCATENATE_BASE_AND_DATA , CKA_DERIVE , ska_bytes ) ; bs = ( skd_bytes + ( 2 * ska_bytes ) ) * BITS_PER_BYTE ; param1 . data = ( unsigned char * ) & bs ; param1 . len = sizeof ( bs ) ; SK_ei_k = PK11_DeriveWithFlags ( finalkey , CKM_EXTRACT_KEY_FROM_KEY , & param1 , nss_encryption_mech ( encrypter ) , CKA_FLAGS_ONLY , ske_bytes , CKF_ENCRYPT | CKF_DECRYPT ) ; bs = ( skd_bytes + ( 2 * ska_bytes ) + ske_bytes ) * BITS_PER_BYTE ; param1 . data = ( unsigned char * ) & bs ; param1 . len = sizeof ( bs ) ; SK_er_k = PK11_DeriveWithFlags ( finalkey , CKM_EXTRACT_KEY_FROM_KEY , & param1 , nss_encryption_mech ( encrypter ) , CKA_FLAGS_ONLY , ske_bytes , CKF_ENCRYPT | CKF_DECRYPT ) ; bs = ( skd_bytes + ( 2 * ska_bytes ) + ( 2 * ske_bytes ) ) * BITS_PER_BYTE ; SK_pi_k = pk11_extract_derive_wrapper_osw ( finalkey , bs , CKM_CONCATENATE_BASE_AND_DATA , CKA_DERIVE , skp_bytes ) ; bs = ( skd_bytes + ( 2 * ska_bytes ) + ( 2 * ske_bytes ) + skp_bytes ) * BITS_PER_BYTE ; SK_pr_k = pk11_extract_derive_wrapper_osw ( finalkey , bs , CKM_CONCATENATE_BASE_AND_DATA , CKA_DERIVE , skp_bytes ) ; DBG ( DBG_CRYPT , DBG_log ( "NSS ikev2: finished computing individual keys for IKEv2 SA\n" ) ) ; PK11_FreeSymKey ( finalkey ) ; SK_d -> len = sizeof ( PK11SymKey * ) ; SK_d -> ptr = alloc_bytes ( SK_d -> len , "SK_d" ) ; memcpy ( SK_d -> ptr , & SK_d_k , SK_d -> len ) ; SK_ai -> len = sizeof ( PK11SymKey * ) ; SK_ai -> ptr = alloc_bytes ( SK_ai -> len , "SK_ai" ) ; memcpy ( SK_ai -> ptr , & SK_ai_k , SK_ai -> len ) ; SK_ar -> len = sizeof ( PK11SymKey * ) ; SK_ar -> ptr = alloc_bytes ( SK_ar -> len , "SK_ar" ) ; memcpy ( SK_ar -> ptr , & SK_ar_k , SK_ar -> len ) ; SK_ei -> len = sizeof ( PK11SymKey * ) ; SK_ei -> ptr = alloc_bytes ( SK_ei -> len , "SK_ei" ) ; memcpy ( SK_ei -> ptr , & SK_ei_k , SK_ei -> len ) ; SK_er -> len = sizeof ( PK11SymKey * ) ; SK_er -> ptr = alloc_bytes ( SK_er -> len , "SK_er" ) ; memcpy ( SK_er -> ptr , & SK_er_k , SK_er -> len ) ; SK_pi -> len = sizeof ( PK11SymKey * ) ; SK_pi -> ptr = alloc_bytes ( SK_pi -> len , "SK_pi" ) ; memcpy ( SK_pi -> ptr , & SK_pi_k , SK_pi -> len ) ; SK_pr -> len = sizeof ( PK11SymKey * ) ; SK_pr -> ptr = alloc_bytes ( SK_pr -> len , "SK_pr" ) ; memcpy ( SK_pr -> ptr , & SK_pr_k , SK_pr -> len ) ; freeanychunk ( hmac_opad ) ; freeanychunk ( hmac_ipad ) ; freeanychunk ( hmac_pad_prf ) ; v2genbytes ( SK_d , skd_bytes , "SK_d" , & vpss ) ; v2genbytes ( SK_ai , ska_bytes , "SK_ai" , & vpss ) ; v2genbytes ( SK_ar , ska_bytes , "SK_ar" , & vpss ) ; v2genbytes ( SK_ei , ske_bytes , "SK_ei" , & vpss ) ; v2genbytes ( SK_er , ske_bytes , "SK_er" , & vpss ) ; v2genbytes ( SK_pi , skp_bytes , "SK_ei" , & vpss ) ; v2genbytes ( SK_pr , skp_bytes , "SK_er" , & vpss ) ; } DBG ( , "shared:  " "skeyseed:" "SK_d:" "SK_ai:" "SK_ar:" "SK_ei:" "SK_er:" "SK_pi:" "SK_pr:" ) } 