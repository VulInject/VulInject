void MarkBufferDirtyHint ( Buffer buffer , bool buffer_std ) { BufferDesc * bufHdr ; Page page = BufferGetPage ( buffer ) ; if ( ! BufferIsValid ( buffer ) ) { elog ( ERROR , "bad buffer ID: %d" , buffer ) ; } if ( BufferIsLocal ( buffer ) ) { return ; } bufHdr = GetBufferDescriptor ( buffer - 1 ) ; Assert ( GetPrivateRefCount ( buffer ) > 0 ) ; Assert ( LWLockHeldByMe ( BufferDescriptorGetContentLock ( bufHdr ) ) ) ; if ( ( pg_atomic_read_u32 ( & bufHdr -> state ) & ( BM_DIRTY | BM_JUST_DIRTIED ) ) != ( BM_DIRTY | BM_JUST_DIRTIED ) ) { XLogRecPtr lsn = InvalidXLogRecPtr ; bool dirtied = false ; bool delayChkptFlags = false ; uint32 buf_state ; if ( XLogHintBitIsNeeded ( ) && ( pg_atomic_read_u32 ( & bufHdr -> state ) & BM_PERMANENT ) ) { if ( RecoveryInProgress ( ) || RelFileLocatorSkippingWAL ( BufTagGetRelFileLocator ( & bufHdr -> tag ) ) ) { return ; } Assert ( ( MyProc -> delayChkptFlags & DELAY_CHKPT_START ) == 0 ) ; MyProc -> delayChkptFlags |= DELAY_CHKPT_START ; delayChkptFlags = true ; lsn = XLogSaveBufferForHint ( buffer , buffer_std ) ; } buf_state = LockBufHdr ( bufHdr ) ; Assert ( BUF_STATE_GET_REFCOUNT ( buf_state ) > 0 ) ; if ( ! ( buf_state & BM_DIRTY ) ) { dirtied = true ; if ( ! XLogRecPtrIsInvalid ( lsn ) ) { PageSetLSN ( page , lsn ) ; } } buf_state |= BM_DIRTY | BM_JUST_DIRTIED ; UnlockBufHdr ( bufHdr , buf_state ) ; if ( delayChkptFlags ) { MyProc -> delayChkptFlags &= ~ DELAY_CHKPT_START ; } if ( dirtied ) { VacuumPageDirty ++ ; pgBufferUsage . shared_blks_dirtied ++ ; if ( VacuumCostActive ) { VacuumCostBalance += VacuumCostPageDirty ; } } } } 