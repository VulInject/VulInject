void radeon_add_atom_connector ( struct drm_device * dev , uint32_t connector_id , uint32_t supported_device , int connector_type , struct radeon_i2c_bus_rec * i2c_bus , uint32_t igp_lane_info , uint16_t connector_object_id , struct radeon_hpd * hpd , struct radeon_router * router ) { struct radeon_device * rdev = dev -> dev_private ; struct drm_connector * connector ; struct radeon_connector * radeon_connector ; struct radeon_connector_atom_dig * radeon_dig_connector ; struct drm_encoder * encoder ; struct radeon_encoder * radeon_encoder ; struct i2c_adapter * ddc = NULL ; uint32_t subpixel_order = SubPixelNone ; bool shared_ddc = false ; bool is_dp_bridge = false ; bool has_aux = false ; if ( connector_type == DRM_MODE_CONNECTOR_Unknown ) { return ; } if ( ( ( connector_type == DRM_MODE_CONNECTOR_SVIDEO ) || ( connector_type == DRM_MODE_CONNECTOR_Composite ) || ( connector_type == DRM_MODE_CONNECTOR_9PinDIN ) ) && ( radeon_tv == 0 ) ) { return ; } list_for_each_entry ( , , ) { radeon_connector = to_radeon_connector ( connector ) ; if ( radeon_connector -> connector_id == connector_id ) { radeon_connector -> devices |= supported_device ; return ; } if ( radeon_connector -> ddc_bus && i2c_bus -> valid ) { if ( radeon_connector -> ddc_bus -> rec . i2c_id == i2c_bus -> i2c_id ) { radeon_connector -> shared_ddc = true ; shared_ddc = true ; } if ( radeon_connector -> router_bus && router -> ddc_valid && ( radeon_connector -> router . router_id == router -> router_id ) ) { radeon_connector -> shared_ddc = false ; shared_ddc = false ; } } } list_for_each_entry ( , , ) { radeon_encoder = to_radeon_encoder ( encoder ) ; if ( radeon_encoder -> devices & supported_device ) { switch ( radeon_encoder -> encoder_id ) { case ENCODER_OBJECT_ID_TRAVIS : case ENCODER_OBJECT_ID_NUTMEG : is_dp_bridge = true ; break ; default : break ; } } } radeon_connector = kzalloc ( sizeof ( radeon_connector ) , GFP_KERNEL ) ; connector = & radeon_connector -> base ; radeon_connector -> connector_id = connector_id ; radeon_connector -> devices = supported_device ; radeon_connector -> shared_ddc = shared_ddc ; radeon_connector -> connector_object_id = connector_object_id ; radeon_connector -> hpd = * hpd ; radeon_connector -> router = * router ; if ( router -> ddc_valid || router -> cd_valid ) { radeon_connector -> router_bus = radeon_i2c_lookup ( rdev , & router -> i2c_info ) ; if ( ! radeon_connector -> router_bus ) { DRM_ERROR ( "Failed to assign router i2c bus! Check dmesg for i2c errors.\n" ) ; } } if ( is_dp_bridge ) { radeon_dig_connector = kzalloc ( sizeof ( radeon_connector_atom_dig ) , GFP_KERNEL ) ; if ( ! radeon_dig_connector ) { failed } radeon_dig_connector -> igp_lane_info = igp_lane_info ; radeon_connector -> con_priv = radeon_dig_connector ; if ( i2c_bus -> valid ) { radeon_connector -> ddc_bus = radeon_i2c_lookup ( rdev , i2c_bus ) ; if ( radeon_connector -> ddc_bus ) { has_aux = true ; ddc = & radeon_connector -> ddc_bus -> adapter ; } else { DRM_ERROR ( "DP: Failed to assign ddc bus! Check dmesg for i2c errors.\n" ) ; } } switch ( connector_type ) { case DRM_MODE_CONNECTOR_VGA : case DRM_MODE_CONNECTOR_DVIA : default : drm_connector_init_with_ddc ( dev , & radeon_connector -> base , & radeon_dp_connector_funcs , connector_type , ddc ) ; drm_connector_helper_add ( & radeon_connector -> base , & radeon_dp_connector_helper_funcs ) ; connector -> interlace_allowed = true ; connector -> doublescan_allowed = true ; radeon_connector -> dac_load_detect = true ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . load_detect_property , 1 ) ; drm_object_attach_property ( & radeon_connector -> base . base , dev -> mode_config . scaling_mode_property , DRM_MODE_SCALE_NONE ) ; if ( ASIC_IS_DCE5 ( rdev ) ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . output_csc_property , RADEON_OUTPUT_CSC_BYPASS ) ; } break ; case DRM_MODE_CONNECTOR_DVII : case DRM_MODE_CONNECTOR_DVID : case DRM_MODE_CONNECTOR_HDMIA : case DRM_MODE_CONNECTOR_HDMIB : case DRM_MODE_CONNECTOR_DisplayPort : drm_connector_init_with_ddc ( dev , & radeon_connector -> base , & radeon_dp_connector_funcs , connector_type , ddc ) ; drm_connector_helper_add ( & radeon_connector -> base , & radeon_dp_connector_helper_funcs ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . underscan_property , UNDERSCAN_OFF ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . underscan_hborder_property , 0 ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . underscan_vborder_property , 0 ) ; drm_object_attach_property ( & radeon_connector -> base . base , dev -> mode_config . scaling_mode_property , DRM_MODE_SCALE_NONE ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . dither_property , RADEON_FMT_DITHER_DISABLE ) ; if ( radeon_audio != 0 ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . audio_property , RADEON_AUDIO_AUTO ) ; radeon_connector -> audio = RADEON_AUDIO_AUTO ; } if ( ASIC_IS_DCE5 ( rdev ) ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . output_csc_property , RADEON_OUTPUT_CSC_BYPASS ) ; } subpixel_order = SubPixelHorizontalRGB ; connector -> interlace_allowed = true ; if ( connector_type == DRM_MODE_CONNECTOR_HDMIB ) { connector -> doublescan_allowed = true ; } else { connector -> doublescan_allowed = false ; } if ( connector_type == DRM_MODE_CONNECTOR_DVII ) { radeon_connector -> dac_load_detect = true ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . load_detect_property , 1 ) ; } break ; case DRM_MODE_CONNECTOR_LVDS : case DRM_MODE_CONNECTOR_eDP : drm_connector_init_with_ddc ( dev , & radeon_connector -> base , & radeon_lvds_bridge_connector_funcs , connector_type , ddc ) ; drm_connector_helper_add ( & radeon_connector -> base , & radeon_dp_connector_helper_funcs ) ; drm_object_attach_property ( & radeon_connector -> base . base , dev -> mode_config . scaling_mode_property , DRM_MODE_SCALE_FULLSCREEN ) ; subpixel_order = SubPixelHorizontalRGB ; connector -> interlace_allowed = false ; connector -> doublescan_allowed = false ; break ; } } else { switch ( connector_type ) { case DRM_MODE_CONNECTOR_VGA : if ( i2c_bus -> valid ) { radeon_connector -> ddc_bus = radeon_i2c_lookup ( rdev , i2c_bus ) ; if ( ! radeon_connector -> ddc_bus ) { DRM_ERROR ( "VGA: Failed to assign ddc bus! Check dmesg for i2c errors.\n" ) ; } else { ddc = & radeon_connector -> ddc_bus -> adapter ; } } drm_connector_init_with_ddc ( dev , & radeon_connector -> base , & radeon_vga_connector_funcs , connector_type , ddc ) ; drm_connector_helper_add ( & radeon_connector -> base , & radeon_vga_connector_helper_funcs ) ; radeon_connector -> dac_load_detect = true ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . load_detect_property , 1 ) ; if ( ASIC_IS_AVIVO ( rdev ) ) { drm_object_attach_property ( & radeon_connector -> base . base , dev -> mode_config . scaling_mode_property , DRM_MODE_SCALE_NONE ) ; } if ( ASIC_IS_DCE5 ( rdev ) ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . output_csc_property , RADEON_OUTPUT_CSC_BYPASS ) ; } radeon_connector -> hpd . hpd = RADEON_HPD_NONE ; connector -> interlace_allowed = true ; connector -> doublescan_allowed = true ; break ; case DRM_MODE_CONNECTOR_DVIA : if ( i2c_bus -> valid ) { radeon_connector -> ddc_bus = radeon_i2c_lookup ( rdev , i2c_bus ) ; if ( ! radeon_connector -> ddc_bus ) { DRM_ERROR ( "DVIA: Failed to assign ddc bus! Check dmesg for i2c errors.\n" ) ; } else { ddc = & radeon_connector -> ddc_bus -> adapter ; } } drm_connector_init_with_ddc ( dev , & radeon_connector -> base , & radeon_vga_connector_funcs , connector_type , ddc ) ; drm_connector_helper_add ( & radeon_connector -> base , & radeon_vga_connector_helper_funcs ) ; radeon_connector -> dac_load_detect = true ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . load_detect_property , 1 ) ; if ( ASIC_IS_AVIVO ( rdev ) ) { drm_object_attach_property ( & radeon_connector -> base . base , dev -> mode_config . scaling_mode_property , DRM_MODE_SCALE_NONE ) ; } if ( ASIC_IS_DCE5 ( rdev ) ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . output_csc_property , RADEON_OUTPUT_CSC_BYPASS ) ; } radeon_connector -> hpd . hpd = RADEON_HPD_NONE ; connector -> interlace_allowed = true ; connector -> doublescan_allowed = true ; break ; case DRM_MODE_CONNECTOR_DVII : case DRM_MODE_CONNECTOR_DVID : radeon_dig_connector = kzalloc ( sizeof ( radeon_connector_atom_dig ) , GFP_KERNEL ) ; if ( ! radeon_dig_connector ) { failed } radeon_dig_connector -> igp_lane_info = igp_lane_info ; radeon_connector -> con_priv = radeon_dig_connector ; if ( i2c_bus -> valid ) { radeon_connector -> ddc_bus = radeon_i2c_lookup ( rdev , i2c_bus ) ; if ( ! radeon_connector -> ddc_bus ) { DRM_ERROR ( "DVI: Failed to assign ddc bus! Check dmesg for i2c errors.\n" ) ; } else { ddc = & radeon_connector -> ddc_bus -> adapter ; } } drm_connector_init_with_ddc ( dev , & radeon_connector -> base , & radeon_dvi_connector_funcs , connector_type , ddc ) ; drm_connector_helper_add ( & radeon_connector -> base , & radeon_dvi_connector_helper_funcs ) ; subpixel_order = SubPixelHorizontalRGB ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . coherent_mode_property , 1 ) ; if ( ASIC_IS_AVIVO ( rdev ) ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . underscan_property , UNDERSCAN_OFF ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . underscan_hborder_property , 0 ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . underscan_vborder_property , 0 ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . dither_property , RADEON_FMT_DITHER_DISABLE ) ; drm_object_attach_property ( & radeon_connector -> base . base , dev -> mode_config . scaling_mode_property , DRM_MODE_SCALE_NONE ) ; } if ( ASIC_IS_DCE2 ( rdev ) && ( radeon_audio != 0 ) ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . audio_property , RADEON_AUDIO_AUTO ) ; radeon_connector -> audio = RADEON_AUDIO_AUTO ; } if ( connector_type == DRM_MODE_CONNECTOR_DVII ) { radeon_connector -> dac_load_detect = true ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . load_detect_property , 1 ) ; } if ( ASIC_IS_DCE5 ( rdev ) ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . output_csc_property , RADEON_OUTPUT_CSC_BYPASS ) ; } connector -> interlace_allowed = true ; if ( connector_type == DRM_MODE_CONNECTOR_DVII ) { connector -> doublescan_allowed = true ; } else { connector -> doublescan_allowed = false ; } break ; case DRM_MODE_CONNECTOR_HDMIA : case DRM_MODE_CONNECTOR_HDMIB : radeon_dig_connector = kzalloc ( sizeof ( radeon_connector_atom_dig ) , GFP_KERNEL ) ; if ( ! radeon_dig_connector ) { failed } radeon_dig_connector -> igp_lane_info = igp_lane_info ; radeon_connector -> con_priv = radeon_dig_connector ; if ( i2c_bus -> valid ) { radeon_connector -> ddc_bus = radeon_i2c_lookup ( rdev , i2c_bus ) ; if ( ! radeon_connector -> ddc_bus ) { DRM_ERROR ( "HDMI: Failed to assign ddc bus! Check dmesg for i2c errors.\n" ) ; } else { ddc = & radeon_connector -> ddc_bus -> adapter ; } } drm_connector_init_with_ddc ( dev , & radeon_connector -> base , & radeon_dvi_connector_funcs , connector_type , ddc ) ; drm_connector_helper_add ( & radeon_connector -> base , & radeon_dvi_connector_helper_funcs ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . coherent_mode_property , 1 ) ; if ( ASIC_IS_AVIVO ( rdev ) ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . underscan_property , UNDERSCAN_OFF ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . underscan_hborder_property , 0 ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . underscan_vborder_property , 0 ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . dither_property , RADEON_FMT_DITHER_DISABLE ) ; drm_object_attach_property ( & radeon_connector -> base . base , dev -> mode_config . scaling_mode_property , DRM_MODE_SCALE_NONE ) ; } if ( ASIC_IS_DCE2 ( rdev ) && ( radeon_audio != 0 ) ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . audio_property , RADEON_AUDIO_AUTO ) ; radeon_connector -> audio = RADEON_AUDIO_AUTO ; } if ( ASIC_IS_DCE5 ( rdev ) ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . output_csc_property , RADEON_OUTPUT_CSC_BYPASS ) ; } subpixel_order = SubPixelHorizontalRGB ; connector -> interlace_allowed = true ; if ( connector_type == DRM_MODE_CONNECTOR_HDMIB ) { connector -> doublescan_allowed = true ; } else { connector -> doublescan_allowed = false ; } break ; case DRM_MODE_CONNECTOR_DisplayPort : radeon_dig_connector = kzalloc ( sizeof ( radeon_connector_atom_dig ) , GFP_KERNEL ) ; if ( ! radeon_dig_connector ) { failed } radeon_dig_connector -> igp_lane_info = igp_lane_info ; radeon_connector -> con_priv = radeon_dig_connector ; if ( i2c_bus -> valid ) { radeon_connector -> ddc_bus = radeon_i2c_lookup ( rdev , i2c_bus ) ; if ( radeon_connector -> ddc_bus ) { has_aux = true ; ddc = & radeon_connector -> ddc_bus -> adapter ; } else { DRM_ERROR ( "DP: Failed to assign ddc bus! Check dmesg for i2c errors.\n" ) ; } } drm_connector_init_with_ddc ( dev , & radeon_connector -> base , & radeon_dp_connector_funcs , connector_type , ddc ) ; drm_connector_helper_add ( & radeon_connector -> base , & radeon_dp_connector_helper_funcs ) ; subpixel_order = SubPixelHorizontalRGB ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . coherent_mode_property , 1 ) ; if ( ASIC_IS_AVIVO ( rdev ) ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . underscan_property , UNDERSCAN_OFF ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . underscan_hborder_property , 0 ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . underscan_vborder_property , 0 ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . dither_property , RADEON_FMT_DITHER_DISABLE ) ; drm_object_attach_property ( & radeon_connector -> base . base , dev -> mode_config . scaling_mode_property , DRM_MODE_SCALE_NONE ) ; } if ( ASIC_IS_DCE2 ( rdev ) && ( radeon_audio != 0 ) ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . audio_property , RADEON_AUDIO_AUTO ) ; radeon_connector -> audio = RADEON_AUDIO_AUTO ; } if ( ASIC_IS_DCE5 ( rdev ) ) { drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . output_csc_property , RADEON_OUTPUT_CSC_BYPASS ) ; } connector -> interlace_allowed = true ; connector -> doublescan_allowed = false ; break ; case DRM_MODE_CONNECTOR_eDP : radeon_dig_connector = kzalloc ( sizeof ( radeon_connector_atom_dig ) , GFP_KERNEL ) ; if ( ! radeon_dig_connector ) { failed } radeon_dig_connector -> igp_lane_info = igp_lane_info ; radeon_connector -> con_priv = radeon_dig_connector ; if ( i2c_bus -> valid ) { radeon_connector -> ddc_bus = radeon_i2c_lookup ( rdev , i2c_bus ) ; if ( radeon_connector -> ddc_bus ) { has_aux = true ; ddc = & radeon_connector -> ddc_bus -> adapter ; } else { DRM_ERROR ( "DP: Failed to assign ddc bus! Check dmesg for i2c errors.\n" ) ; } } drm_connector_init_with_ddc ( dev , & radeon_connector -> base , & radeon_edp_connector_funcs , connector_type , ddc ) ; drm_connector_helper_add ( & radeon_connector -> base , & radeon_dp_connector_helper_funcs ) ; drm_object_attach_property ( & radeon_connector -> base . base , dev -> mode_config . scaling_mode_property , DRM_MODE_SCALE_FULLSCREEN ) ; subpixel_order = SubPixelHorizontalRGB ; connector -> interlace_allowed = false ; connector -> doublescan_allowed = false ; break ; case DRM_MODE_CONNECTOR_SVIDEO : case DRM_MODE_CONNECTOR_Composite : case DRM_MODE_CONNECTOR_9PinDIN : drm_connector_init_with_ddc ( dev , & radeon_connector -> base , & radeon_tv_connector_funcs , connector_type , ddc ) ; drm_connector_helper_add ( & radeon_connector -> base , & radeon_tv_connector_helper_funcs ) ; radeon_connector -> dac_load_detect = true ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . load_detect_property , 1 ) ; drm_object_attach_property ( & radeon_connector -> base . base , rdev -> mode_info . tv_std_property , radeon_atombios_get_tv_info ( rdev ) ) ; radeon_connector -> hpd . hpd = RADEON_HPD_NONE ; connector -> interlace_allowed = false ; connector -> doublescan_allowed = false ; break ; case DRM_MODE_CONNECTOR_LVDS : radeon_dig_connector = kzalloc ( sizeof ( radeon_connector_atom_dig ) , GFP_KERNEL ) ; if ( ! radeon_dig_connector ) { failed } radeon_dig_connector -> igp_lane_info = igp_lane_info ; radeon_connector -> con_priv = radeon_dig_connector ; if ( i2c_bus -> valid ) { radeon_connector -> ddc_bus = radeon_i2c_lookup ( rdev , i2c_bus ) ; if ( ! radeon_connector -> ddc_bus ) { DRM_ERROR ( "LVDS: Failed to assign ddc bus! Check dmesg for i2c errors.\n" ) ; } else { ddc = & radeon_connector -> ddc_bus -> adapter ; } } drm_connector_init_with_ddc ( dev , & radeon_connector -> base , & radeon_lvds_connector_funcs , connector_type , ddc ) ; drm_connector_helper_add ( & radeon_connector -> base , & radeon_lvds_connector_helper_funcs ) ; drm_object_attach_property ( & radeon_connector -> base . base , dev -> mode_config . scaling_mode_property , DRM_MODE_SCALE_FULLSCREEN ) ; subpixel_order = SubPixelHorizontalRGB ; connector -> interlace_allowed = false ; connector -> doublescan_allowed = false ; break ; } } if ( radeon_connector -> hpd . hpd == RADEON_HPD_NONE ) { if ( i2c_bus -> valid ) { connector -> polled = DRM_CONNECTOR_POLL_CONNECT | DRM_CONNECTOR_POLL_DISCONNECT ; } } else { connector -> polled = DRM_CONNECTOR_POLL_HPD ; } connector -> display_info . subpixel_order = subpixel_order ; drm_connector_register ( connector ) ; if ( has_aux ) { radeon_dp_aux_init ( radeon_connector ) ; } return ; failed drm_connector_cleanup ( connector ) ; kfree ( connector ) ; } 