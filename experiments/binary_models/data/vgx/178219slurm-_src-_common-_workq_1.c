extern void quiesce_workq ( workq_t * workq ) { if ( ! workq ) { return ; } _check_magic_workq ( workq ) ; slurm_mutex_lock ( & workq -> mutex ) ; log_flag ( WORKQ , "%s: shutting down with %u queued jobs" , __func__ , list_count ( workq -> work ) ) ; workq -> shutdown = true ; slurm_cond_broadcast ( & workq -> cond ) ; slurm_mutex_unlock ( & workq -> mutex ) ; while ( true ) { int count ; pthread_t tid ; workq_worker_t * worker ; slurm_mutex_lock ( & workq -> mutex ) ; if ( ( count = list_count ( workq -> workers ) ) == 0 ) { slurm_mutex_unlock ( & workq -> mutex ) ; log_flag ( WORKQ , "%s: all workers are done" , __func__ ) ; break ; } worker = list_peek ( workq -> workers ) ; tid = worker -> tid ; slurm_mutex_unlock ( & workq -> mutex ) ; log_flag ( WORKQ , "%s: waiting on %d workers" , __func__ , count ) ; pthread_join ( tid ) ; } xassert ( list_count ( workq -> workers ) == 0 ) ; xassert ( list_count ( workq -> work ) == 0 ) ; } 