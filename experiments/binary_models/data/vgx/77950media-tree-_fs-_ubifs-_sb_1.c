static int fixup_free_space ( struct ubifs_info * c ) { int lnum , err = 0 ; struct ubifs_lprops * lprops ; ubifs_get_lprops ( c , NULL ) ; for ( lnum = UBIFS_MST_LNUM ; lnum < UBIFS_LOG_LNUM ; lnum ++ ) { err = fixup_leb ( c , lnum , c -> mst_offs + c -> mst_node_alsz ) ; if ( err ) { out } } lnum = ubifs_next_log_lnum ( c , c -> lhead_lnum ) ; while ( lnum != c -> ltail_lnum ) { err = fixup_leb ( c , lnum , 0 ) ; if ( err ) { out } lnum = ubifs_next_log_lnum ( c , lnum ) ; } err = fixup_leb ( c , c -> lhead_lnum , ALIGN ( UBIFS_CS_NODE_SZ , c -> min_io_size ) ) ; if ( err ) { out } for ( lnum = c -> lpt_first ; lnum <= c -> lpt_last ; lnum ++ ) { int free = c -> ltab [ lnum - c -> lpt_first ] . free ; if ( free > 0 ) { err = fixup_leb ( c , lnum , c -> leb_size - free ) ; if ( err ) { out } } } for ( lnum = c -> orph_first ; lnum <= c -> orph_last ; lnum ++ ) { err = fixup_leb ( c , lnum , 0 ) ; if ( err ) { out } } for ( lnum = c -> main_first ; lnum < c -> leb_cnt ; lnum ++ ) { lprops = ubifs_lpt_lookup ( c , lnum ) ; if ( IS_ERR ( lprops ) ) { err = PTR_ERR ( lprops ) ; out } if ( lprops -> free > 0 ) { err = fixup_leb ( c , lnum , c -> leb_size - lprops -> free ) ; if ( err ) { out } } } out ubifs_release_lprops ( c ) ; return err ; } 