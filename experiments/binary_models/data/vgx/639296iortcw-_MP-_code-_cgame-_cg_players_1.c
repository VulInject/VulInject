static qboolean CG_PlayerShadow ( centity_t * cent , float * shadowPlane ) { vec3_t end ; trace_t trace ; float alpha , dist , distfade ; int tagIndex , subIndex ; vec3_t origin , angles , axis [ 3 ] ; shadowPart_t shadowParts [ ] { { "tag_footleft" 10 4 1.0 0 } { "tag_footright" 10 4 1.0 0 } { "tag_torso" 18 96 0.8 0 } { NULL 0 } } ; ; shadowParts [ 0 ] . shader = cgs . media . shadowFootShader ; shadowParts [ 1 ] . shader = cgs . media . shadowFootShader ; shadowParts [ 2 ] . shader = cgs . media . shadowTorsoShader ; * shadowPlane = 0 ; if ( cg_shadows . integer == 0 ) { return qfalse ; } VectorCopy ( cent -> lerpOrigin , end ) ; end [ 2 ] -= SHADOW_DISTANCE ; trap_CM_BoxTrace ( & trace , cent -> lerpOrigin , end , NULL , NULL , 0 , MASK_PLAYERSOLID ) ; if ( trace . fraction == 1.0 || trace . fraction == 0.0f ) { return qfalse ; } * shadowPlane = trace . endpos [ 2 ] + 1 ; if ( cg_shadows . integer != 1 ) { return qtrue ; } if ( cent -> currentState . eFlags & EF_DEAD ) { return qfalse ; } alpha = 1.0 - trace . fraction ; dist = VectorDistance ( cent -> lerpOrigin , cg . snap -> ps . origin ) ; if ( ! ( cent -> currentState . eFlags & EF_ZOOMING ) && ( dist > SHADOW_MIN_DIST ) ) { if ( dist < SHADOW_MAX_DIST ) { distfade = ( dist - SHADOW_MIN_DIST ) / ( SHADOW_MAX_DIST - SHADOW_MIN_DIST ) ; } else { if ( dist > SHADOW_MAX_DIST * 2 ) { return qfalse ; } else { distfade = 1.0 - ( ( dist - SHADOW_MAX_DIST ) / SHADOW_MAX_DIST ) ; } } alpha *= distfade ; CG_ImpactMark ( cgs . media . shadowTorsoShader , trace . endpos , trace . plane . normal , 0 , alpha , alpha , alpha , 1 , qfalse , 16 , qtrue , - 1 ) ; } else { distfade = 0.0 ; } if ( dist < SHADOW_MAX_DIST ) { for ( tagIndex = 0 ; shadowParts [ tagIndex ] . tagname ; tagIndex ++ ) { for ( subIndex = 0 ; ( subIndex = CG_GetOriginForTag ( cent , & cent -> pe . legsRefEnt , shadowParts [ tagIndex ] . tagname , subIndex , origin , axis ) ) >= 0 ; subIndex ++ ) { if ( origin [ 2 ] < * shadowPlane ) { origin [ 2 ] = * shadowPlane ; } alpha = 1.0 - ( ( origin [ 2 ] - ( * shadowPlane + ZOFS ) ) / shadowParts [ tagIndex ] . maxdist ) ; if ( alpha < 0 ) { continue ; } if ( alpha > shadowParts [ tagIndex ] . maxalpha ) { alpha = shadowParts [ tagIndex ] . maxalpha ; } alpha *= ( 1.0 - distfade ) ; origin [ 2 ] = * shadowPlane ; AxisToAngles ( axis , angles ) ; CG_ImpactMark ( shadowParts [ tagIndex ] . shader , origin , trace . plane . normal , angles [ YAW ] , alpha , alpha , alpha , 1 , qfalse , shadowParts [ tagIndex ] . size , qtrue , - 1 ) ; } } } return qtrue ; } 