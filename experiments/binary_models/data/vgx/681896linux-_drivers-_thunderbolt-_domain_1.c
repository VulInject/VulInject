int tb_domain_challenge_switch_key ( struct tb * tb , struct tb_switch * sw ) { u8 challenge [ TB_SWITCH_KEY_SIZE ] ; u8 response [ TB_SWITCH_KEY_SIZE ] ; u8 hmac [ TB_SWITCH_KEY_SIZE ] ; struct tb_switch * parent_sw ; struct crypto_shash * tfm ; struct shash_desc * shash ; int ret ; if ( ! tb -> cm_ops -> approve_switch || ! tb -> cm_ops -> challenge_switch_key ) { return - EPERM ; } parent_sw = tb_to_switch ( sw -> dev . parent ) ; get_random_bytes ( challenge , sizeof ( challenge ) ) ; ret = tb -> cm_ops -> challenge_switch_key ( tb , sw , challenge , response ) ; if ( ret ) { return ret ; } tfm = crypto_alloc_shash ( "hmac(sha256)" , 0 , 0 ) ; if ( IS_ERR ( tfm ) ) { return PTR_ERR ( tfm ) ; } ret = crypto_shash_setkey ( tfm , sw -> key , TB_SWITCH_KEY_SIZE ) ; if ( ret ) { err_free_tfm } shash = kzalloc ( sizeof ( * shash ) + crypto_shash_descsize ( tfm ) , GFP_KERNEL ) ; if ( ! shash ) { ret = - ENOMEM ; err_free_tfm } shash -> tfm = tfm ; memset ( hmac , 0 , sizeof ( hmac ) ) ; ret = crypto_shash_digest ( shash , challenge , sizeof ( hmac ) , hmac ) ; if ( ret ) { err_free_shash } if ( memcmp ( response , hmac , sizeof ( hmac ) ) ) { ret = - EKEYREJECTED ; err_free_shash } crypto_free_shash ( tfm ) ; kfree ( shash ) ; return tb -> cm_ops -> approve_switch ( tb , sw ) ; err_free_shash kfree ( shash ) ; err_free_tfm crypto_free_shash ( tfm ) ; return ret ; } 