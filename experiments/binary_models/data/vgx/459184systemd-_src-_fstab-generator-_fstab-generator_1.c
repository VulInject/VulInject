static int add_swap ( const char * source , const char * what , struct mntent * me , MountPointFlags flags ) { _cleanup_free_ char * name = NULL ; _cleanup_fclose_ FILE * f = NULL ; int r ; assert ( what ) ; assert ( me ) ; if ( ! arg_swap_enabled ) { log_info ( "Swap unit generation disabled on kernel command line, ignoring fstab swap entry for %s." , what ) ; return 0 ; } if ( access ( "/proc/swaps" , F_OK ) < 0 ) { log_info ( "Swap not supported, ignoring fstab swap entry for %s." , what ) ; return 0 ; } if ( detect_container ( ) > 0 ) { log_info ( "Running in a container, ignoring fstab swap entry for %s." , what ) ; return 0 ; } if ( arg_sysroot_check ) { log_info ( "%s should be enabled in the initrd, will request daemon-reload." , what ) ; return true ; } r = unit_name_from_path ( what , ".swap" , & name ) ; if ( r < 0 ) { return log_error_errno ( r , "Failed to generate unit name: %m" ) ; } r = generator_open_unit_file ( arg_dest , source , name , & f ) ; if ( r < 0 ) { return r ; } fprintf ( f , "[Unit]\n" "Documentation=man:fstab(5) man:systemd-fstab-generator(8)\n" "SourcePath=%s\n" , source ) ; r = generator_write_blockdev_dependency ( f , what ) ; if ( r < 0 ) { return r ; } fprintf ( f , "\n" "[Swap]\n" ) ; r = write_what ( f , what ) ; if ( r < 0 ) { return r ; } r = write_options ( f , me -> mnt_opts ) ; if ( r < 0 ) { return r ; } r = fflush_and_check ( f , NULL ) ; if ( r < 0 ) { return log_error_errno ( r , "Failed to write unit file %s: %m" , name ) ; } r = generator_write_timeouts ( arg_dest , what , what , me -> mnt_opts , NULL ) ; if ( r < 0 ) { return r ; } if ( flags & MOUNT_MAKEFS ) { r = generator_hook_up_mkswap ( arg_dest , what ) ; if ( r < 0 ) { return r ; } } if ( flags & MOUNT_GROWFS ) { log_warning ( "%s: growing swap devices is currently unsupported." , what ) ; } if ( flags & MOUNT_PCRFS ) { log_warning ( "%s: measuring swap devices is currently unsupported." , what ) ; } if ( ! ( flags & MOUNT_NOAUTO ) ) { r = generator_add_symlink ( arg_dest , SPECIAL_SWAP_TARGET , ( flags & MOUNT_NOFAIL ) ?"wants" : "requires" , name ) ; if ( r < 0 ) { return r ; } } return true ; } 