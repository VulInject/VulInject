alsa_play ( , ) { static float buffer [ BUFFER_LEN ] ; SNDFILE * sndfile ; SF_INFO sfinfo ; snd_pcm_t * alsa_dev ; int k , readcount , subformat ; for ( k = 1 ; k < argc ; k ++ ) { printf ( "Playing %s\n" , argv [ k ] ) ; if ( ! ( sndfile = sf_open ( argv [ k ] , SFM_READ , & sfinfo ) ) ) { puts ( sf_strerror ( NULL ) ) ; continue ; } if ( sfinfo . channels ( 1 || sfinfo . channels ) 2 ) { printf ( "Error : channels = %d.\n" , sfinfo . channels ) ; continue ; } if ( ( alsa_dev = alsa_open ( sfinfo . channels , ( unsigned ) sfinfo . samplerate , SF_FALSE ) ) == NULL ) { continue ; } subformat = sfinfo . format & SF_FORMAT_SUBMASK ; if ( subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE ) { double scale ; int m ; sf_command ( sndfile , SFC_CALC_SIGNAL_MAX , & scale , sizeof ( scale ) ) ; if ( scale > 1.0 ) { scale = 1.0 / scale ; } else { scale = 1.0 ; } while ( ( readcount = sf_read_float ( sndfile , buffer , BUFFER_LEN ) ) ) { for ( m = 0 ; m < readcount ; m ++ ) { buffer [ m ] *= scale ; } alsa_write_float ( alsa_dev , buffer , BUFFER_LEN / sfinfo . channels , sfinfo . channels ) ; } } else { while ( ( readcount = sf_read_float ( sndfile , buffer , BUFFER_LEN ) ) ) { alsa_write_float ( alsa_dev , buffer , BUFFER_LEN / sfinfo . channels , sfinfo . channels ) ; } } snd_pcm_drain ( alsa_dev ) ; snd_pcm_close ( alsa_dev ) ; sf_close ( sndfile ) ; } return ; } 