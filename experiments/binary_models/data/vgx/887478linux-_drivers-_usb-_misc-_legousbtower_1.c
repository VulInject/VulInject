static ssize_t tower_read ( struct file * file , char __user * buffer , size_t count , loff_t * ppos ) { struct lego_usb_tower * dev ; size_t bytes_to_read ; int i ; int retval = 0 ; unsigned long timeout = 0 ; dev = file -> private_data ; if ( mutex_lock_interruptible ( & dev -> lock ) ) { retval = - ERESTARTSYS ; exit } if ( dev -> disconnected ) { retval = - ENODEV ; unlock_exit } if ( count == 0 ) { dev_dbg ( & dev -> udev -> dev , "read request of 0 bytes\n" ) ; unlock_exit } if ( read_timeout ) { timeout = jiffies + msecs_to_jiffies ( read_timeout ) ; } tower_check_for_read_packet ( dev ) ; while ( dev -> read_packet_length == 0 ) { if ( file -> f_flags & O_NONBLOCK ) { retval = - EAGAIN ; unlock_exit } retval = wait_event_interruptible_timeout ( dev -> read_wait , dev -> interrupt_in_done , dev -> packet_timeout_jiffies ) ; if ( retval < 0 ) { unlock_exit } if ( read_timeout && ( dev -> read_buffer_length || dev -> interrupt_out_busy ) ) { timeout = jiffies + msecs_to_jiffies ( read_timeout ) ; } if ( read_timeout && time_after ( jiffies , timeout ) ) { retval = - ETIMEDOUT ; unlock_exit } tower_check_for_read_packet ( dev ) ; } bytes_to_read = min ( count , dev -> read_packet_length ) ; if ( copy_to_user ( buffer , dev -> read_buffer , bytes_to_read ) ) { retval = - EFAULT ; unlock_exit } spin_lock_irq ( & dev -> read_buffer_lock ) ; dev -> read_buffer_length -= bytes_to_read ; dev -> read_packet_length -= bytes_to_read ; for ( i = 0 ; i < dev -> read_buffer_length ; i ++ ) { dev -> read_buffer [ i ] = dev -> read_buffer [ i + bytes_to_read ] ; } spin_unlock_irq ( & dev -> read_buffer_lock ) ; retval = bytes_to_read ; unlock_exit exit return retval ; } 