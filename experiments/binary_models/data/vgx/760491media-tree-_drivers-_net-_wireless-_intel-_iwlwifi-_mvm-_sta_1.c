int iwl_mvm_add_sta ( struct iwl_mvm * mvm , struct ieee80211_vif * vif , struct ieee80211_sta * sta ) { struct iwl_mvm_vif * mvmvif = iwl_mvm_vif_from_mac80211 ( vif ) ; struct iwl_mvm_sta * mvm_sta = iwl_mvm_sta_from_mac80211 ( sta ) ; struct iwl_mvm_rxq_dup_data * dup_data ; int i , ret , sta_id ; lockdep_assert_held ( & mvm -> mutex ) ; if ( ! test_bit ( IWL_MVM_STATUS_IN_HW_RESTART , & mvm -> status ) ) { sta_id = iwl_mvm_find_free_sta_id ( mvm , ieee80211_vif_type_p2p ( vif ) ) ; } else { sta_id = mvm_sta -> sta_id ; } if ( sta_id == IWL_MVM_INVALID_STA ) { return - ENOSPC ; } spin_lock_init ( & mvm_sta -> lock ) ; if ( iwl_mvm_is_dqa_supported ( mvm ) && test_bit ( IWL_MVM_STATUS_IN_HW_RESTART , & mvm -> status ) ) { iwl_mvm_realloc_queues_after_restart ( mvm , mvm_sta ) ; update_fw } mvm_sta -> sta_id = sta_id ; mvm_sta -> mac_id_n_color = FW_CMD_ID_AND_COLOR ( mvmvif -> id , mvmvif -> color ) ; mvm_sta -> vif = vif ; mvm_sta -> max_agg_bufsize = LINK_QUAL_AGG_FRAME_LIMIT_DEF ; mvm_sta -> tx_protection = 0 ; mvm_sta -> tt_tx_protection = false ; mvm_sta -> sta_type = sta -> tdls ?IWL_STA_TDLS_LINK : IWL_STA_LINK ; atomic_set ( & mvm -> pending_frames [ sta_id ] , 0 ) ; mvm_sta -> tid_disable_agg = 0xffff ; mvm_sta -> tfd_queue_msk = 0 ; if ( ! iwl_mvm_is_dqa_supported ( mvm ) && sta -> tdls ) { ret = iwl_mvm_tdls_sta_init ( mvm , sta ) ; if ( ret ) { return ret ; } } if ( ! iwl_mvm_is_dqa_supported ( mvm ) ) { for ( i = 0 ; i < IEEE80211_NUM_ACS ; i ++ ) { if ( vif -> hw_queue [ i ] != IEEE80211_INVAL_HW_QUEUE ) { mvm_sta -> tfd_queue_msk |= BIT ( vif -> hw_queue [ i ] ) ; } } } for ( i = 0 ; i <= IWL_MAX_TID_COUNT ; i ++ ) { u16 seq = mvm_sta -> tid_data [ i ] . seq_number ; mvm_sta -> tid_data [ i ] . seq_number = seq ; if ( ! iwl_mvm_is_dqa_supported ( mvm ) ) { continue ; } mvm_sta -> tid_data [ i ] . txq_id = IWL_MVM_INVALID_QUEUE ; skb_queue_head_init ( & mvm_sta -> tid_data [ i ] . deferred_tx_frames ) ; } mvm_sta -> deferred_traffic_tid_map = 0 ; mvm_sta -> agg_tids = 0 ; if ( iwl_mvm_has_new_rx_api ( mvm ) && ! test_bit ( IWL_MVM_STATUS_IN_HW_RESTART , & mvm -> status ) ) { dup_data = kcalloc ( mvm -> trans -> num_rx_queues , sizeof ( * dup_data ) , GFP_KERNEL ) ; if ( ! dup_data ) { return - ENOMEM ; } mvm_sta -> dup_data = dup_data ; } if ( iwl_mvm_is_dqa_supported ( mvm ) && ! iwl_mvm_has_new_tx_api ( mvm ) ) { ret = iwl_mvm_reserve_sta_stream ( mvm , sta , ieee80211_vif_type_p2p ( vif ) ) ; if ( ret ) { err } } update_fw ret = iwl_mvm_sta_send_to_fw ( mvm , sta , false , 0 ) ; if ( ret ) { err } if ( vif -> type == NL80211_IFTYPE_STATION ) { if ( ! sta -> tdls ) { WARN_ON ( mvmvif -> ap_sta_id != IWL_MVM_INVALID_STA ) ; mvmvif -> ap_sta_id = sta_id ; } else { WARN_ON ( mvmvif -> ap_sta_id == IWL_MVM_INVALID_STA ) ; } } rcu_assign_pointer ( mvm -> fw_id_to_mac_id [ sta_id ] , sta ) ; return 0 ; err if ( ! iwl_mvm_is_dqa_supported ( mvm ) && sta -> tdls ) { iwl_mvm_tdls_sta_deinit ( mvm , sta ) ; } return ret ; } 