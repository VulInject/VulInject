static int chcr_ktls_cpl_act_open_rpl ( struct adapter * adap , unsigned char * input ) { const struct cpl_act_open_rpl * p = ( void * ) input ; struct chcr_ktls_info * tx_info = NULL ; struct chcr_ktls_ofld_ctx_tx * tx_ctx ; struct chcr_ktls_uld_ctx * u_ctx ; unsigned int atid , tid , status ; struct tls_context * tls_ctx ; struct tid_info * t ; int ret = 0 ; tid = GET_TID ( p ) ; status = AOPEN_STATUS_G ( ntohl ( p -> atid_status ) ) ; atid = TID_TID_G ( AOPEN_ATID_G ( ntohl ( p -> atid_status ) ) ) ; t = & adap -> tids ; tx_info = lookup_atid ( t , atid ) ; if ( ! tx_info || tx_info -> atid != atid ) { pr_err ( "%s: incorrect tx_info or atid\n" , __func__ ) ; return - 1 ; } cxgb4_free_atid ( t , atid ) ; tx_info -> atid = - 1 ; spin_lock ( & tx_info -> lock ) ; if ( tx_info -> pending_close ) { spin_unlock ( & tx_info -> lock ) ; if ( ! status ) { cxgb4_remove_tid ( & tx_info -> adap -> tids , tx_info -> tx_chan , tid , tx_info -> ip_family ) ; } return 0 ; } if ( ! status ) { tx_info -> tid = tid ; cxgb4_insert_tid ( t , tx_info , tx_info -> tid , tx_info -> ip_family ) ; tls_ctx = tls_get_ctx ( tx_info -> sk ) ; tx_ctx = chcr_get_ktls_tx_context ( tls_ctx ) ; u_ctx = adap -> uld [ CXGB4_ULD_KTLS ] . handle ; if ( u_ctx ) { ret = xa_insert_bh ( & u_ctx -> tid_list , tid , tx_ctx , GFP_NOWAIT ) ; if ( ret < 0 ) { pr_err ( "%s: Failed to allocate tid XA entry = %d\n" , __func__ , tx_info -> tid ) ; tx_info -> open_state = CH_KTLS_OPEN_FAILURE ; out } } tx_info -> open_state = CH_KTLS_OPEN_SUCCESS ; } else { tx_info -> open_state = CH_KTLS_OPEN_FAILURE ; } out spin_unlock ( & tx_info -> lock ) ; complete ( & tx_info -> completion ) ; return ret ; } 