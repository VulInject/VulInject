static void run_core_reloc_tests ( bool use_btfgen ) { const size_t mmap_sz = roundup_page ( sizeof ( data ) ) ; DECLARE_LIBBPF_OPTS ( bpf_object_open_opts , open_opts ) ; struct core_reloc_test_case * test_case , test_case_copy ; const char * tp_name , * probe_name ; int err , i , equal , fd ; struct bpf_link * link = NULL ; struct bpf_map * data_map ; struct bpf_program * prog ; struct bpf_object * obj ; uint64_t my_pid_tgid ; struct data * data ; void * mmap_data = NULL ; my_pid_tgid = getpid ( ) | ( ( uint64_t ) syscall ( SYS_gettid ) << 32 ) ; for ( i = 0 ; i < ARRAY_SIZE ( test_cases ) ; i ++ ) { char btf_file [ ] "/tmp/core_reloc.btf.XXXXXX" ; ; test_case_copy = test_cases [ i ] ; test_case = & test_case_copy ; if ( ! test__start_subtest ( test_case -> case_name ) ) { continue ; } if ( test_case -> needs_testmod && ! env . has_testmod ) { test__skip ( ) ; continue ; } if ( use_btfgen ) { if ( ! test_case -> btf_src_file || test_case -> run_btfgen_fails ) { test__skip ( ) ; continue ; } fd = mkstemp ( btf_file ) ; if ( ! ASSERT_GE ( fd , 0 , "btf_tmp" ) ) { continue ; } close ( fd ) ; err = run_btfgen ( test_case -> btf_src_file , btf_file , test_case -> bpf_obj_file ) ; if ( ! ASSERT_OK ( err , "run_btfgen" ) ) { continue ; } test_case -> btf_src_file = btf_file ; } if ( test_case -> setup ) { err = test_case -> setup ( test_case ) ; if ( CHECK ( err , "test_setup" , "test #%d setup failed: %d\n" , i , err ) ) { continue ; } } if ( test_case -> btf_src_file ) { err = access ( test_case -> btf_src_file , R_OK ) ; if ( ! ASSERT_OK ( err , "btf_src_file" ) ) { continue ; } } open_opts . btf_custom_path = test_case -> btf_src_file ; obj = bpf_object__open_file ( test_case -> bpf_obj_file , & open_opts ) ; if ( ! ASSERT_OK_PTR ( obj , "obj_open" ) ) { cleanup } probe_name = test_case -> prog_name ; tp_name = test_case -> raw_tp_name ; prog = bpf_object__find_program_by_name ( obj , probe_name ) ; if ( CHECK ( ! prog , "find_probe" , "prog '%s' not found\n" , probe_name ) ) { cleanup } err = bpf_object__load ( obj ) ; if ( err ) { if ( ! test_case -> fails ) { ASSERT_OK ( err , "obj_load" ) ; } cleanup } data_map = bpf_object__find_map_by_name ( obj , ".bss" ) ; if ( CHECK ( ! data_map , "find_data_map" , "data map not found\n" ) ) { cleanup } mmap_data = mmap ( NULL , mmap_sz , PROT_READ | PROT_WRITE , MAP_SHARED , bpf_map__fd ( data_map ) , 0 ) ; if ( CHECK ( mmap_data == MAP_FAILED , "mmap" , ".bss mmap failed: %d" , errno ) ) { mmap_data = NULL ; cleanup } data = mmap_data ; if ( test_case -> input_len ) { memcpy ( data -> in , test_case -> input , test_case -> input_len ) ; } data -> my_pid_tgid = my_pid_tgid ; link = bpf_program__attach_raw_tracepoint ( prog , tp_name ) ; if ( ! ASSERT_OK_PTR ( link , "attach_raw_tp" ) ) { cleanup } if ( test_case -> trigger ) { if ( ! ASSERT_OK ( test_case -> trigger ( test_case ) , "test_trigger" ) ) { cleanup } } else { usleep ( 1 ) ; } if ( data -> skip ) { test__skip ( ) ; cleanup } if ( ! ASSERT_FALSE ( test_case -> fails , "obj_load_should_fail" ) ) { cleanup } equal = memcmp ( data -> out , test_case -> output , test_case -> output_len ) == 0 ; if ( CHECK ( ! equal , "check_result" , "input/output data don't match\n" ) ) { int j ; for ( j = 0 ; j < test_case -> input_len ; j ++ ) { printf ( "input byte #%d: 0x%02hhx\n" , j , test_case -> input [ j ] ) ; } for ( j = 0 ; j < test_case -> output_len ; j ++ ) { printf ( "output byte #%d: EXP 0x%02hhx GOT 0x%02hhx\n" , j , test_case -> output [ j ] , data -> out [ j ] ) ; } cleanup } cleanup if ( mmap_data ) { CHECK_FAIL ( munmap ( mmap_data , mmap_sz ) ) ; mmap_data = NULL ; } if ( use_btfgen ) { remove ( test_case -> btf_src_file ) ; } bpf_link__destroy ( link ) ; link = NULL ; bpf_object__close ( obj ) ; } } 