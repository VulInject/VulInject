static void hda_generic_machine_select ( struct snd_sof_dev * sdev , struct snd_soc_acpi_mach * * mach ) { struct hdac_bus * bus = sof_to_bus ( sdev ) ; struct snd_soc_acpi_mach_params * mach_params ; struct snd_soc_acpi_mach * hda_mach ; struct snd_sof_pdata * pdata = sdev -> pdata ; const char * tplg_filename ; const char * idisp_str ; int dmic_num ; int codec_num = 0 ; int ret ; int i ; if ( ! bus -> codec_mask ) { dev_info ( bus -> dev , "no hda codecs found!\n" ) ; } else { dev_info ( bus -> dev , "hda codecs found, mask %lx\n" , bus -> codec_mask ) ; for ( i = 0 ; i < HDA_MAX_CODECS ; i ++ ) { if ( bus -> codec_mask & ( 1 << i ) ) { codec_num ++ ; } } if ( ! * mach && codec_num <= 2 ) { bool tplg_fixup ; hda_mach = snd_soc_acpi_intel_hda_machines ; dev_info ( bus -> dev , "using HDA machine driver %s now\n" , hda_mach -> drv_name ) ; if ( codec_num == 1 && HDA_IDISP_CODEC ( bus -> codec_mask ) ) { idisp_str = "-idisp" ; } else { idisp_str = "" ; } if ( pdata -> tplg_filename ) { tplg_fixup = false ; tplg_filename = pdata -> tplg_filename ; } else { tplg_fixup = true ; tplg_filename = hda_mach -> sof_tplg_filename ; } ret = dmic_detect_topology_fixup ( sdev , & tplg_filename , idisp_str , & dmic_num , tplg_fixup ) ; if ( ret < 0 ) { return ; } hda_mach -> mach_params . dmic_num = dmic_num ; pdata -> tplg_filename = tplg_filename ; if ( codec_num == 2 ) { hda_mach -> mach_params . link_mask = 0 ; } * mach = hda_mach ; } } if ( * mach ) { mach_params = & ( * mach ) -> mach_params ; mach_params -> codec_mask = bus -> codec_mask ; mach_params -> common_hdmi_codec_drv = true ; } } 