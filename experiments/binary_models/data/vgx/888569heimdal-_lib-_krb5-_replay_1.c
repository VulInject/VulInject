KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_rc_store ( krb5_context context , krb5_rcache id , krb5_donot_replay * rep ) { struct rc_entry ent , tmp ; time_t t ; FILE * f ; int ret ; size_t count ; ent . stamp = time ( NULL ) ; checksum_authenticator ( rep , ent . data ) ; f = fopen ( id -> name , "r" ) ; if ( f == NULL ) { char buf [ 128 ] ; ret = errno ; rk_strerror_r ( ret , buf , sizeof ( buf ) ) ; krb5_set_error_message ( context , ret , "open(%s): %s" , id -> name , buf ) ; return ret ; } rk_cloexec_file ( f ) ; count = fread ( & tmp , sizeof ( ent ) , 1 , f ) ; if ( count != 1 ) { fclose ( f ) ; return KRB5_RC_IO_UNKNOWN ; } t = ent . stamp - tmp . stamp ; while ( fread ( & tmp , sizeof ( ent ) , 1 , f ) ) { if ( tmp . stamp < t ) { continue ; } if ( memcmp ( tmp . data , ent . data , sizeof ( ent . data ) ) == 0 ) { fclose ( f ) ; return KRB5_RC_REPLAY ; } } if ( ferror ( f ) ) { char buf [ 128 ] ; ret = errno ; fclose ( f ) ; rk_strerror_r ( ret , buf , sizeof ( buf ) ) ; krb5_set_error_message ( context , ret , "%s: %s" , id -> name , buf ) ; return ret ; } fclose ( f ) ; f = fopen ( id -> name , "a" ) ; if ( f == NULL ) { char buf [ 128 ] ; rk_strerror_r ( errno , buf , sizeof ( buf ) ) ; krb5_set_error_message ( context , KRB5_RC_IO_UNKNOWN , "open(%s): %s" , id -> name , buf ) ; return KRB5_RC_IO_UNKNOWN ; } fwrite ( & ent , 1 , sizeof ( ent ) , f ) ; fclose ( f ) ; return 0 ; } 