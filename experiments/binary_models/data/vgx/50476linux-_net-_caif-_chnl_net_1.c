static int chnl_recv_cb ( struct cflayer * layr , struct cfpkt * pkt ) { struct sk_buff * skb ; struct chnl_net * priv ; int pktlen ; const u8 * ip_version ; u8 buf ; priv = container_of ( layr , chnl_net , chnl ) ; skb = ( sk_buff * ) cfpkt_tonative ( pkt ) ; pktlen = skb -> len ; skb -> dev = priv -> netdev ; ip_version = skb_header_pointer ( skb , 0 , 1 , & buf ) ; if ( ! ip_version ) { return - EINVAL ; } switch ( * ip_version >> 4 ) { case 4 : skb -> protocol = htons ( ETH_P_IP ) ; break ; case 6 : skb -> protocol = htons ( ETH_P_IPV6 ) ; break ; default : kfree_skb ( skb ) ; priv -> netdev -> stats . rx_errors ++ ; return - EINVAL ; } if ( priv -> conn_req . protocol == CAIFPROTO_DATAGRAM_LOOP ) { skb -> ip_summed = CHECKSUM_UNNECESSARY ; } else { skb -> ip_summed = CHECKSUM_NONE ; } netif_rx ( skb ) ; priv -> netdev -> stats . rx_packets ++ ; priv -> netdev -> stats . rx_bytes += pktlen ; return 0 ; } 