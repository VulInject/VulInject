parse_unsigned_bitbase ( , , , , , ) { const char * errmsg = 0 ; unsigned long bit ; unsigned long base ; const char * newp = * strp ; unsigned long long bitbase ; long have_zero = 0 ; errmsg = cgen_parse_unsigned_integer ( cd , & newp , opindex , & bit ) ; if ( * newp != ',' ) { return "Missing base for bit,base:8" ; } ++ newp ; if ( strncmp ( newp , "0x0" , 3 ) == 0 || ( newp [ 0 ] == '0' && newp [ 1 ] != 'x' ) ) { have_zero = 1 ; } errmsg = cgen_parse_unsigned_integer ( cd , & newp , opindex , & base ) ; if ( errmsg ) { return errmsg ; } bitbase = ( unsigned long long ) bit + ( ( unsigned long long ) base * 8 ) ; if ( bitbase >= ( 1ull << bits ) ) { return _ ( "bit,base is out of range" ) ; } if ( ! have_zero && base == 0 ) { switch ( allow_syms ) { case 0 : return _ ( "bit,base out of range for symbol" ) ; case 1 : break ; case 2 : if ( strncmp ( newp , "[sb]" , 4 ) != 0 ) { return _ ( "bit,base out of range for symbol" ) ; } break ; } } * valuep = bitbase ; * strp = newp ; return 0 ; } 