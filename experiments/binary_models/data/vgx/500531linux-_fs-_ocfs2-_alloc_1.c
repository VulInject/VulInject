int ocfs2_add_clusters_in_btree ( handle_t * handle , struct ocfs2_extent_tree * et , u32 * logical_offset , u32 clusters_to_add , int mark_unwritten , struct ocfs2_alloc_context * data_ac , struct ocfs2_alloc_context * meta_ac , enum ocfs2_alloc_restarted * reason_ret ) { int status = 0 , err = 0 ; int need_free = 0 ; int free_extents ; enum ocfs2_alloc_restarted reason = RESTART_NONE ; u32 bit_off , num_bits ; u64 block ; int flags = 0 ; struct ocfs2_super * osb = OCFS2_SB ( ocfs2_metadata_cache_get_super ( et -> et_ci ) ) ; BUG_ON ( ! clusters_to_add ) ; if ( mark_unwritten ) { flags = OCFS2_EXT_UNWRITTEN ; } free_extents = ocfs2_num_free_extents ( et ) ; if ( free_extents < 0 ) { status = free_extents ; mlog_errno ( status ) ; leave } if ( ! free_extents && ! meta_ac ) { err = - 1 ; status = - EAGAIN ; reason = RESTART_META ; leave } if ( ( ! free_extents ) && ( ocfs2_alloc_context_bits_left ( meta_ac ) < ocfs2_extend_meta_needed ( et -> et_root_el ) ) ) { err = - 2 ; status = - EAGAIN ; reason = RESTART_META ; leave } status = __ocfs2_claim_clusters ( handle , data_ac , 1 , clusters_to_add , & bit_off , & num_bits ) ; if ( status < 0 ) { if ( status != - ENOSPC ) { mlog_errno ( status ) ; } leave } BUG_ON ( num_bits > clusters_to_add ) ; status = ocfs2_et_root_journal_access ( handle , et , OCFS2_JOURNAL_ACCESS_WRITE ) ; if ( status < 0 ) { mlog_errno ( status ) ; need_free = 1 ; bail } block = ocfs2_clusters_to_blocks ( osb -> sb , bit_off ) ; trace_ocfs2_add_clusters_in_btree ( ( unsigned long long ) ocfs2_metadata_cache_owner ( et -> et_ci ) , bit_off , num_bits ) ; status = ocfs2_insert_extent ( handle , et , * logical_offset , block , num_bits , flags , meta_ac ) ; if ( status < 0 ) { mlog_errno ( status ) ; need_free = 1 ; bail } ocfs2_journal_dirty ( handle , et -> et_root_bh ) ; clusters_to_add -= num_bits ; * logical_offset += num_bits ; if ( clusters_to_add ) { err = clusters_to_add ; status = - EAGAIN ; reason = RESTART_TRANS ; } bail if ( need_free ) { if ( data_ac -> ac_which == OCFS2_AC_USE_LOCAL ) { ocfs2_free_local_alloc_bits ( osb , handle , data_ac , bit_off , num_bits ) ; } else { ocfs2_free_clusters ( handle , data_ac -> ac_inode , data_ac -> ac_bh , ocfs2_clusters_to_blocks ( osb -> sb , bit_off ) , num_bits ) ; } } leave if ( reason_ret ) { * reason_ret = reason ; } trace_ocfs2_add_clusters_in_btree_ret ( status , reason , err ) ; return status ; } 