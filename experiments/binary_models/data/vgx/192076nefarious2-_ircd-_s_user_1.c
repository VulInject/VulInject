int register_user ( struct Client * cptr , struct Client * sptr ) { char * parv [ 4 ] ; char * tmpstr ; char * join [ 3 ] ; char chan [ CHANNELLEN - 1 ] ; struct ConnectionClass * connclass = NULL ; struct ConfItem * cliconf = NULL ; struct User * user = cli_user ( sptr ) ; char ip_base64 [ 25 ] ; struct Shun * ashun = NULL ; int res = 0 ; struct SHostConf * sconf = NULL ; struct Channel * chptr ; user -> last = CurrentTime ; parv [ 0 ] = cli_name ( sptr ) ; parv [ 1 ] = parv [ 2 ] = NULL ; if ( MyConnect ( sptr ) ) { assert ( cptr == sptr ) ; Count_unknownbecomesclient ( sptr , UserStats ) ; cli_lag_min ( sptr ) = - 2 ; cli_lag_factor ( sptr ) = - 2 ; tmpstr = ( char * ) client_get_default_umode ( sptr ) ; if ( tmpstr ) { char * umodev [ ] { NULL NULL NULL NULL } ; ; umodev [ 2 ] = tmpstr ; set_user_mode ( cptr , sptr , 3 , umodev , ALLOWMODES_ANY ) ; } SetUser ( sptr ) ; cli_handler ( sptr ) = CLIENT_HANDLER ; SetLocalNumNick ( sptr ) ; if ( ( ashun = shun_lookup ( sptr , 0 ) ) ) { sendto_opmask_butone_global ( & me , SNO_GLINE , "Shun active for %s%s" , IsUnknown ( sptr ) ?"Unregistered Client " : "" , get_client_name ( sptr , SHOW_IP ) ) ; if ( ! feature_bool ( FEAT_HIS_SHUN_REASON ) ) { sendcmdto_one ( & me , CMD_NOTICE , sptr , "%C :You are shunned: %s" , sptr , ashun -> sh_reason ) ; } } if ( feature_bool ( FEAT_CTCP_VERSIONING ) ) { if ( feature_str ( FEAT_CTCP_VERSIONING_NOTICE ) ) { char strver [ BUFSIZE ] "" ; ; ircd_snprintf ( 0 , strver , strlen ( feature_str ( FEAT_CTCP_VERSIONING_NOTICE ) ) + 16 , "NOTICE * :%s\r\n" , feature_str ( FEAT_CTCP_VERSIONING_NOTICE ) ) ; sendheader ( sptr , strver , strlen ( strver ) ) ; } if ( ! EmptyString ( feature_str ( FEAT_CTCP_VERSIONING_NICK ) ) ) { sendrawto_one ( sptr , ":%s PRIVMSG %C :\001VERSION\001" , feature_str ( FEAT_CTCP_VERSIONING_NICK ) , sptr ) ; } else { sendrawto_one ( sptr , ":%s PRIVMSG %C :\001VERSION\001" , cli_name ( & me ) , sptr ) ; } } sconf = find_shost_conf ( sptr , NULL , NULL , & res ) ; if ( ( res == 0 ) && ( sconf != 0 ) ) { if ( strchr ( sconf -> spoofhost , '@' ) != NULL ) { ircd_strncpy ( cli_user ( sptr ) -> sethost , sconf -> spoofhost , USERLEN + HOSTLEN + 1 ) ; } else { ircd_snprintf ( 0 , cli_user ( sptr ) -> sethost , USERLEN + HOSTLEN + 1 , "%s@%s" , cli_user ( sptr ) -> username , sconf -> spoofhost ) ; } SetSetHost ( sptr , NULL ) ; SetHiddenHost ( sptr ) ; } send_reply ( sptr , RPL_WELCOME , feature_str ( FEAT_NETWORK ) , feature_str ( FEAT_PROVIDER ) ?" via " : "" , feature_str ( FEAT_PROVIDER ) ?feature_str ( FEAT_PROVIDER ) : "" , cli_name ( sptr ) ) ; send_reply ( sptr , RPL_YOURHOST , cli_name ( & me ) , version ) ; send_reply ( sptr , RPL_CREATED , creation ) ; send_reply ( sptr , RPL_MYINFO , cli_name ( & me ) , version , infousermodes , infochanmodes , infochanmodeswithparams ) ; send_supported ( sptr ) ; if ( IsSSL ( sptr ) ) { sendcmdto_one ( & me , CMD_NOTICE , sptr , "%C :You are connected to %s with %s" , sptr , cli_name ( & me ) , ssl_get_cipher ( cli_socket ( sptr ) . ssl ) ) ; if ( ! EmptyString ( cli_sslclifp ( sptr ) ) ) { sendcmdto_one ( & me , CMD_NOTICE , sptr , "%C :Client certificate status: %s" , sptr , ssl_get_verify_result ( cli_socket ( sptr ) . ssl ) ) ; } } m_lusers ( sptr , sptr , 1 , parv ) ; update_load ( ) ; motd_signon ( sptr ) ; if ( cli_snomask ( sptr ) & SNO_NOISY ) { set_snomask ( sptr , cli_snomask ( sptr ) & SNO_NOISY , SNO_ADD ) ; } if ( feature_bool ( FEAT_CONNEXIT_NOTICES ) ) { sendto_opmask_butone_global ( & me , SNO_CONNEXIT , "Client connecting: %s (%s@%s) [%s] {%s} [%s]<%s%s>" , cli_name ( sptr ) , user -> username , user -> realhost , cli_sock_ip ( sptr ) , get_client_class ( sptr ) , cli_info ( sptr ) , NumNick ( cptr ) ) ; } if ( IsIPChecked ( sptr ) ) { IPcheck_connect_succeeded ( sptr ) ; } } else { struct Client * acptr = user -> server ; if ( cli_from ( acptr ) != cli_from ( sptr ) ) { sendcmdto_one ( & me , CMD_KILL , cptr , "%C :%s (%s != %s[%s])" , sptr , cli_name ( & me ) , cli_name ( user -> server ) , cli_name ( cli_from ( acptr ) ) , cli_sockhost ( cli_from ( acptr ) ) ) ; SetFlag ( sptr , FLAG_KILLED ) ; return exit_client ( cptr , sptr , & me , "NICK server wrong direction" ) ; } if ( HasFlag ( acptr , FLAG_TS8 ) ) { SetFlag ( sptr , FLAG_TS8 ) ; } for ( ; acptr != & me ; acptr = cli_serv ( acptr ) -> up ) { if ( IsBurst ( acptr ) || Protocol ( acptr ) < 10 ) { break ; } } if ( IsIPChecked ( sptr ) && ! IPcheck_remote_connect ( sptr , ( acptr != & me ) ) ) { sendcmdto_one ( & me , CMD_KILL , sptr , "%C :%s (Too many connections from your host -- Ghost)" , sptr , cli_name ( & me ) ) ; return exit_client ( cptr , sptr , & me , "Too many connections from your host -- throttled" ) ; } SetUser ( sptr ) ; } user_setcloaked ( sptr ) ; if ( IsHiddenHost ( sptr ) ) { hide_hostmask ( sptr ) ; } if ( IsInvisible ( sptr ) ) { ++ UserStats . inv_clients ; } if ( IsOper ( sptr ) && ! IsHideOper ( sptr ) && ! IsChannelService ( sptr ) && ! IsBot ( sptr ) ) { ++ UserStats . opers ; } tmpstr = umode_str ( sptr ) ; sendcmdto_flag_serv_butone ( user -> server , CMD_NICK , cptr , FLAG_IPV6 , FLAG_LAST_FLAG , "%s %d %Tu %s %s %s%s%s%s %s%s :%s" , cli_name ( sptr ) , cli_hopcount ( sptr ) + 1 , cli_lastnick ( sptr ) , user -> username , user -> realhost , * tmpstr ?"+" : "" , tmpstr , * tmpstr ?" " : "" , iptobase64 ( ip_base64 , & cli_ip ( sptr ) , sizeof ( ip_base64 ) , 1 ) , NumNick ( sptr ) , cli_info ( sptr ) ) ; sendcmdto_flag_serv_butone ( user -> server , CMD_NICK , cptr , FLAG_LAST_FLAG , FLAG_IPV6 , "%s %d %Tu %s %s %s%s%s%s %s%s :%s" , cli_name ( sptr ) , cli_hopcount ( sptr ) + 1 , cli_lastnick ( sptr ) , user -> username , user -> realhost , * tmpstr ?"+" : "" , tmpstr , * tmpstr ?" " : "" , iptobase64 ( ip_base64 , & cli_ip ( sptr ) , sizeof ( ip_base64 ) , 0 ) , NumNick ( sptr ) , cli_info ( sptr ) ) ; clear_privs ( sptr ) ; if ( MyUser ( sptr ) ) { static struct Flags flags ; struct SLink * lp ; if ( cli_webirc ( sptr ) && ! EmptyString ( cli_webirc ( sptr ) ) ) { sendcmdto_serv_butone ( & me , CMD_MARK , cptr , "%s %s :%s" , cli_name ( cptr ) , MARK_WEBIRC , cli_webirc ( sptr ) ) ; } for ( lp = cli_marks ( cptr ) ; lp ; lp = lp -> next ) { sendcmdto_serv_butone ( & me , CMD_MARK , cptr , "%s %s :%s" , cli_name ( cptr ) , MARK_MARK , lp -> value . cp ) ; } if ( cli_sslclifp ( sptr ) && ! EmptyString ( cli_sslclifp ( sptr ) ) ) { sendcmdto_serv_butone ( & me , CMD_MARK , cptr , "%s %s :%s" , cli_name ( cptr ) , MARK_SSLCLIFP , cli_sslclifp ( sptr ) ) ; } if ( cli_version ( sptr ) && ! EmptyString ( cli_version ( sptr ) ) ) { sendcmdto_serv_butone ( & me , CMD_MARK , cptr , "%s %s :%s" , cli_name ( cptr ) , MARK_CVERSION , cli_version ( sptr ) ) ; SetCVersionSent ( sptr ) ; if ( feature_bool ( FEAT_CTCP_VERSIONING_CHAN ) ) { if ( ( chptr = FindChannel ( feature_str ( FEAT_CTCP_VERSIONING_CHANNAME ) ) ) ) { if ( feature_bool ( FEAT_CTCP_VERSIONING_USEMSG ) ) { sendcmdto_channel_butone ( & me , CMD_PRIVATE , chptr , & me , SKIP_DEAF | SKIP_BURST , '\0' , "%H :%s has version \002%s\002" , chptr , cli_name ( sptr ) , cli_version ( sptr ) ) ; } else { sendcmdto_channel_butone ( & me , CMD_NOTICE , chptr , & me , SKIP_DEAF | SKIP_BURST , '\0' , "%H :%s has version \002%s\002" , chptr , cli_name ( sptr ) , cli_version ( sptr ) ) ; } } } } if ( cli_killmark ( sptr ) && ! EmptyString ( cli_killmark ( sptr ) ) ) { sendcmdto_serv_butone ( & me , CMD_MARK , cptr , "%s %s :%s" , cli_name ( cptr ) , MARK_KILL , cli_killmark ( sptr ) ) ; } if ( IsGeoIP ( sptr ) ) { if ( cli_countrycode ( sptr ) && ! EmptyString ( cli_countrycode ( sptr ) ) && cli_continentcode ( sptr ) && ! EmptyString ( cli_continentcode ( sptr ) ) ) { sendcmdto_serv_butone ( & me , CMD_MARK , cptr , "%s %s %s %s :%s" , cli_name ( sptr ) , MARK_GEOIP , cli_countrycode ( sptr ) , cli_continentcode ( sptr ) , cli_countryname ( sptr ) ) ; } } if ( IsAccount ( cptr ) ) { FlagSet ( & flags , FLAG_ACCOUNT ) ; } else { FlagClr ( & flags , FLAG_ACCOUNT ) ; } if ( IsCloakHost ( cptr ) ) { FlagSet ( & flags , FLAG_CLOAKHOST ) ; } else { FlagClr ( & flags , FLAG_CLOAKHOST ) ; } if ( IsCloakIP ( cptr ) ) { FlagSet ( & flags , FLAG_CLOAKIP ) ; } else { FlagClr ( & flags , FLAG_CLOAKIP ) ; } if ( IsFakeHost ( cptr ) ) { FlagSet ( & flags , FLAG_FAKEHOST ) ; } else { FlagClr ( & flags , FLAG_FAKEHOST ) ; } if ( IsSetHost ( cptr ) ) { FlagSet ( & flags , FLAG_SETHOST ) ; } else { FlagClr ( & flags , FLAG_SETHOST ) ; } client_set_privs ( sptr , NULL ) ; send_umode ( cptr , sptr , & flags , ALL_UMODES ) ; if ( ( cli_snomask ( sptr ) != feature_int ( FEAT_SNOMASK_DEFAULT ) ) && HasFlag ( sptr , FLAG_SERVNOTICE ) ) { send_reply ( sptr , RPL_SNOMASK , cli_snomask ( sptr ) , cli_snomask ( sptr ) ) ; } if ( ( connclass = get_client_class_conf ( sptr ) ) != NULL ) { if ( ! EmptyString ( connclass -> autojoinchan ) ) { if ( ! EmptyString ( connclass -> autojoinnotice ) ) { sendcmdto_one ( & me , CMD_NOTICE , sptr , "%C :%s" , sptr , connclass -> autojoinnotice ) ; } ircd_strncpy ( chan , connclass -> autojoinchan , CHANNELLEN - 1 ) ; join [ 0 ] = cli_name ( sptr ) ; join [ 1 ] = chan ; join [ 2 ] = NULL ; m_join ( sptr , sptr , 2 , join ) ; } } if ( ( cliconf = get_client_conf ( sptr ) ) != NULL ) { if ( ! EmptyString ( cliconf -> autojoinchan ) ) { if ( ! EmptyString ( cliconf -> autojoinnotice ) ) { sendcmdto_one ( & me , CMD_NOTICE , sptr , "%C :%s" , sptr , cliconf -> autojoinnotice ) ; } ircd_strncpy ( chan , cliconf -> autojoinchan , CHANNELLEN - 1 ) ; join [ 0 ] = cli_name ( sptr ) ; join [ 1 ] = chan ; join [ 2 ] = NULL ; m_join ( sptr , sptr , 2 , join ) ; } } if ( connclass != NULL ) { if ( FlagHas ( & connclass -> restrictflags , CRFLAG_JOIN ) ) { SetRestrictJoin ( sptr ) ; } if ( FlagHas ( & connclass -> restrictflags , CRFLAG_PRIVMSG ) ) { SetRestrictPrivMsg ( sptr ) ; } if ( FlagHas ( & connclass -> restrictflags , CRFLAG_UMODE ) ) { SetRestrictUMode ( sptr ) ; } } } check_status_watch ( sptr , RPL_LOGON ) ; return 0 ; } 