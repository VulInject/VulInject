int aclk_send_otp_response ( const char * agent_id , const unsigned char * response , int response_bytes , url_t * target , struct auth_data * mqtt_auth ) { int len ; int rc = 1 ; https_req_t req = HTTPS_REQ_T_INITIALIZER ; https_req_response_t resp = HTTPS_REQ_RESPONSE_T_INITIALIZER ; req . host = target -> host ; req . port = target -> port ; req . request_type = HTTP_REQ_POST ; int base64 [ CHALLENGE_LEN_BASE64 + 1 ] ; memset ( base64 , 0 , CHALLENGE_LEN_BASE64 + 1 ) ; base64_encode_helper ( base64 , & len , response , response_bytes ) ; BUFFER * url = buffer_create ( strlen ( OTP_URL_PREFIX ) + UUID_STR_LEN + 20 , & netdata_buffers_statistics . buffers_aclk ) ; BUFFER * resp_json = buffer_create ( strlen ( OTP_URL_PREFIX ) + UUID_STR_LEN + 20 , & netdata_buffers_statistics . buffers_aclk ) ; buffer_sprintf ( url , "%s/node/%s/password" , target -> path , agent_id ) ; buffer_sprintf ( resp_json , "{\"response\":\"%s\"}" , base64 ) ; req . url = ( char * ) buffer_tostring ( url ) ; req . payload = ( char * ) buffer_tostring ( resp_json ) ; req . payload_size = strlen ( req . payload ) ; if ( aclk_https_request ( & req , & resp ) ) { error ( "ACLK_OTP Password error trying to post result to password" ) ; cleanup_buffers } if ( resp . http_code != 201 ) { error ( "ACLK_OTP Password HTTP code not 201 Created (got %d)" , resp . http_code ) ; if ( resp . payload_size ) { aclk_parse_otp_error ( resp . payload ) ; } cleanup_response } info ( "ACLK_OTP Got Password from Cloud" ) ; if ( parse_passwd_response ( resp . payload , mqtt_auth ) ) { error ( "Error parsing response of password endpoint" ) ; cleanup_response } rc = 0 ; cleanup_response https_req_response_free ( & resp ) ; cleanup_buffers buffer_free ( resp_json ) ; buffer_free ( url ) ; return rc ; } 