int check_irq_vectors_for_cpu_disable ( void ) { unsigned int this_cpu , vector , this_count , count ; struct irq_desc * desc ; struct irq_data * data ; int cpu ; this_cpu = smp_processor_id ( ) ; cpumask_copy ( & online_new , cpu_online_mask ) ; cpumask_clear_cpu ( this_cpu , & online_new ) ; this_count = 0 ; for ( vector = FIRST_EXTERNAL_VECTOR ; vector < NR_VECTORS ; vector ++ ) { desc = __this_cpu_read ( vector_irq [ vector ] ) ; if ( IS_ERR_OR_NULL ( desc ) ) { continue ; } raw_spin_lock ( & desc -> lock ) ; data = irq_desc_get_irq_data ( desc , NULL ) ; cpumask_copy ( & affinity_new , irq_data_get_affinity_mask ( data ) ) ; cpumask_clear_cpu ( this_cpu , & affinity_new ) ; if ( ! irq_desc_has_action ( desc ) || irqd_is_per_cpu ( data ) ) { raw_spin_unlock ( & desc -> lock ) ; continue ; } raw_spin_unlock ( & desc -> lock ) ; if ( cpumask_empty ( & affinity_new ) || ! cpumask_subset ( & affinity_new , & online_new ) ) { this_count ++ ; } } if ( ! this_count ) { return 0 ; } count = 0 ; for_each_online_cpu ( ) { if ( cpu == this_cpu ) { continue ; } for ( vector = FIRST_EXTERNAL_VECTOR ; vector < first_system_vector ; vector ++ ) { if ( ! test_bit ( vector , used_vectors ) && IS_ERR_OR_NULL ( per_cpu ( vector_irq , cpu ) [ vector ] ) ) { if ( ++ count == this_count ) { return 0 ; } } } } if ( count < this_count ) { pr_warn ( "CPU %d disable failed: CPU has %u vectors assigned and there are only %u available.\n" , this_cpu , this_count , count ) ; return - ERANGE ; } return 0 ; } 