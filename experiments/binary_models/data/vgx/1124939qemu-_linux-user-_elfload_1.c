int load_elf_binary ( struct linux_binprm * bprm , struct image_info * info ) { struct image_info interp_info ; struct elfhdr elf_ex ; char * elf_interpreter = NULL ; char * scratch ; memset ( & interp_info , 0 , sizeof ( interp_info ) ) ; interp_info . fp_abi = MIPS_ABI_FP_UNKNOWN ; info -> start_mmap = ( abi_ulong ) ELF_START_MMAP ; load_elf_image ( bprm -> filename , bprm -> fd , info , & elf_interpreter , bprm -> buf ) ; elf_ex = * ( elfhdr * ) bprm -> buf ; bprm -> p = setup_arg_pages ( bprm , info ) ; scratch = g_new0 ( char , TARGET_PAGE_SIZE ) ; if ( STACK_GROWS_DOWN ) { bprm -> p = copy_elf_strings ( 1 , & bprm -> filename , scratch , bprm -> p , info -> stack_limit ) ; info -> file_string = bprm -> p ; bprm -> p = copy_elf_strings ( bprm -> envc , bprm -> envp , scratch , bprm -> p , info -> stack_limit ) ; info -> env_strings = bprm -> p ; bprm -> p = copy_elf_strings ( bprm -> argc , bprm -> argv , scratch , bprm -> p , info -> stack_limit ) ; info -> arg_strings = bprm -> p ; } else { info -> arg_strings = bprm -> p ; bprm -> p = copy_elf_strings ( bprm -> argc , bprm -> argv , scratch , bprm -> p , info -> stack_limit ) ; info -> env_strings = bprm -> p ; bprm -> p = copy_elf_strings ( bprm -> envc , bprm -> envp , scratch , bprm -> p , info -> stack_limit ) ; info -> file_string = bprm -> p ; bprm -> p = copy_elf_strings ( 1 , & bprm -> filename , scratch , bprm -> p , info -> stack_limit ) ; } if ( ! bprm -> p ) { fprintf ( stderr , "%s: %s\n" , bprm -> filename , strerror ( E2BIG ) ) ; exit ( - 1 ) ; } if ( elf_interpreter ) { load_elf_interp ( elf_interpreter , & interp_info , bprm -> buf ) ; if ( strcmp ( elf_interpreter , "/usr/lib/libc.so.1" ) == 0 || strcmp ( elf_interpreter , "/usr/lib/ld.so.1" ) == 0 ) { info -> personality = PER_SVR4 ; target_mmap ( 0 , qemu_host_page_size , PROT_READ | PROT_EXEC , MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS , - 1 , 0 ) ; } info -> interp_fp_abi = interp_info . fp_abi ; } if ( TARGET_ARCH_HAS_SIGTRAMP_PAGE ) { abi_long tramp_page = target_mmap ( 0 , TARGET_PAGE_SIZE , PROT_READ | PROT_WRITE , MAP_PRIVATE | MAP_ANON , - 1 , 0 ) ; if ( tramp_page == - 1 ) { return - errno ; } setup_sigtramp ( tramp_page ) ; target_mprotect ( tramp_page , TARGET_PAGE_SIZE , PROT_READ | PROT_EXEC ) ; } bprm -> p = create_elf_tables ( bprm -> p , bprm -> argc , bprm -> envc , & elf_ex , info , ( elf_interpreter ?& interp_info : NULL ) ) ; info -> start_stack = bprm -> p ; if ( elf_interpreter ) { info -> load_bias = interp_info . load_bias ; info -> entry = interp_info . entry ; g_free ( elf_interpreter ) ; } bprm -> core_dump = & elf_core_dump ; if ( info -> reserve_brk ) { abi_ulong start_brk = HOST_PAGE_ALIGN ( info -> brk ) ; abi_ulong end_brk = HOST_PAGE_ALIGN ( info -> brk + info -> reserve_brk ) ; target_munmap ( start_brk , end_brk - start_brk ) ; } return 0 ; } memelfnote { const char * name ; size_t namesz ; size_t namesz_rounded ; int type ; size_t datasz ; size_t datasz_rounded ; void * data ; size_t notesz ; } target_elf_siginfo { abi_int si_signo ; abi_int si_code ; abi_int si_errno ; } target_elf_prstatus { struct target_elf_siginfo pr_info ; abi_short pr_cursig ; abi_ulong pr_sigpend ; abi_ulong pr_sighold ; target_pid_t pr_pid ; target_pid_t pr_ppid ; target_pid_t pr_pgrp ; target_pid_t pr_sid ; struct target_timeval pr_utime ; struct target_timeval pr_stime ; struct target_timeval pr_cutime ; struct target_timeval pr_cstime ; target_elf_gregset_t pr_reg ; abi_int pr_fpvalid ; } 