int traverse_level ( struct fs_traverse * ftp ) { char path [ PATH_MAX + 1 ] ; char nm [ NAME_MAX + 1 ] ; char * lp ; int next_dir , rv ; int pl , el ; cstack_t * sp ; fs_fhandle_t pfh , efh ; struct stat64 pst , est ; traverse_state_t * tsp ; struct fst_node pn , en ; dent_arg_t darg ; if ( ! ftp || ! ftp -> ft_path || ! * ftp -> ft_path || ! ftp -> ft_callbk ) { NDMP_LOG ( LOG_DEBUG , "Invalid argument" ) ; errno = EINVAL ; return ( - 1 ) ; } if ( ! ftp -> ft_logfp ) { ftp -> ft_logfp = ( ft_log_t ) syslog ; NDMP_LOG ( LOG_DEBUG , "Log to system log \"%s\"" , ftp -> ft_path ) ; } if ( ! ftp -> ft_lpath ) { NDMP_LOG ( LOG_DEBUG , "report the same paths \"%s\"" , ftp -> ft_path ) ; ftp -> ft_lpath = ftp -> ft_path ; } pl = strlen ( ftp -> ft_lpath ) ; if ( pl + 1 > PATH_MAX ) { NDMP_LOG ( LOG_DEBUG , "lpath too long \"%s\"" , ftp -> ft_path ) ; errno = ENAMETOOLONG ; return ( - 1 ) ; } ( void ) strcpy ( path , ftp -> ft_lpath ) ; ( void ) memset ( & pfh , 0 , sizeof ( pfh ) ) ; rv = fs_getstat ( ftp -> ft_lpath , & pfh , & pst ) ; if ( rv != 0 ) { NDMP_LOG ( LOG_DEBUG , "Error %d on fs_getstat(%s)" , rv , ftp -> ft_path ) ; return ( - 1 ) ; } en . tn_path = NULL ; en . tn_fh = NULL ; en . tn_st = NULL ; if ( ! S_ISDIR ( pst . st_mode ) ) { pn . tn_path = ftp -> ft_lpath ; pn . tn_fh = & pfh ; pn . tn_st = & pst ; rv = CALLBACK ( & pn , & en ) ; if ( VERBOSE ( ftp ) ) { NDMP_LOG ( LOG_DEBUG , "CALLBACK(%s): %d" , pn . tn_path , rv ) ; } return ( rv ) ; } sp = cstack_new ( ) ; if ( ! sp ) { free ( pfh . fh_fpath ) ; errno = ENOMEM ; return ( - 1 ) ; } tsp = new_tsp ( path ) ; if ( ! tsp ) { cstack_delete ( sp ) ; free ( pfh . fh_fpath ) ; errno = ENOMEM ; return ( - 1 ) ; } darg . da_buf = ndmp_malloc ( MAX_DENT_BUF_SIZE ) ; if ( ! darg . da_buf ) { cstack_delete ( sp ) ; free ( pfh . fh_fpath ) ; free ( tsp ) ; errno = ENOMEM ; return ( - 1 ) ; } darg . da_size = MAX_DENT_BUF_SIZE ; tsp -> ts_ent = tsp -> ts_end ; tsp -> ts_fh = pfh ; tsp -> ts_st = pst ; pn . tn_path = path ; pn . tn_fh = & tsp -> ts_fh ; pn . tn_st = & tsp -> ts_st ; traverse_stats . fss_dir_calls ++ ; rv = CALLBACK ( & pn , & en ) ; if ( rv < 0 ) { free ( tsp ) ; end } if ( rv == FST_SKIP ) { traverse_stats . fss_dir_skipped ++ ; free ( tsp ) ; rv = 0 ; end } rv = 0 ; next_dir = 1 ; { if ( next_dir ) { traverse_stats . fss_newdirs ++ ; * tsp -> ts_end = '\0' ; if ( VERBOSE ( ftp ) ) { NDMP_LOG ( LOG_DEBUG , "pl %d \"%s\"" , pl , path ) ; } rv = traverse_level_nondir ( ftp , tsp , & pn , & darg ) ; if ( rv < 0 ) { NEGATE ( rv ) ; free ( tsp -> ts_fh . fh_fpath ) ; free ( tsp ) ; break ; } if ( rv == FST_SKIP || rv == SKIP_ENTRY ) { next_dir = 0 ; rv = 0 ; skip_dir } tsp -> ts_dpos = 0 ; } next_dir = 0 ; { el = NAME_MAX ; rv = fs_readdir ( & tsp -> ts_fh , pn . tn_path , & tsp -> ts_dpos , nm , & el , & efh , & est ) ; if ( rv != 0 ) { traverse_stats . fss_readdir_err ++ ; NDMP_LOG ( LOG_DEBUG , "Error %d on readdir(%s) pos %d" , rv , path , tsp -> ts_dpos ) ; if ( STOP_ONERR ( ftp ) ) { break ; } rv = SKIP_ENTRY ; continue ; } if ( el == 0 ) { break ; } nm [ el ] = '\0' ; if ( rootfs_dot_or_dotdot ( nm ) ) { free ( efh . fh_fpath ) ; continue ; } if ( VERBOSE ( ftp ) ) { NDMP_LOG ( LOG_DEBUG , "%u dname: \"%s\"" , tsp -> ts_dpos , nm ) ; } if ( pl + 1 + el > PATH_MAX ) { NDMP_LOG ( LOG_ERR , "Path %s/%s is too long." , path , nm ) ; if ( STOP_ONLONG ( ftp ) ) { rv = ENAMETOOLONG ; } free ( efh . fh_fpath ) ; continue ; } if ( ! S_ISDIR ( est . st_mode ) ) { continue ; } traverse_stats . fss_dir_calls ++ ; en . tn_path = nm ; en . tn_fh = & efh ; en . tn_st = & est ; rv = CALLBACK ( & pn , & en ) ; if ( rv < 0 ) { NEGATE ( rv ) ; free ( efh . fh_fpath ) ; break ; } if ( rv == FST_SKIP ) { traverse_stats . fss_dir_skipped ++ ; free ( efh . fh_fpath ) ; rv = 0 ; continue ; } if ( cstack_push ( sp , tsp , 0 ) ) { rv = ENOMEM ; } else { traverse_stats . fss_pushes ++ ; lp = tsp -> ts_end ; * tsp -> ts_end = '/' ; ( void ) strcpy ( tsp -> ts_end + 1 , nm ) ; tsp = new_tsp ( path ) ; if ( ! tsp ) { rv = ENOMEM ; } else { next_dir = 1 ; pl += el + 1 ; tsp -> ts_fh = efh ; tsp -> ts_st = est ; tsp -> ts_ent = lp ; pn . tn_fh = & tsp -> ts_fh ; pn . tn_st = & tsp -> ts_st ; } } break ; } rv == 0 ; if ( next_dir ) { continue ; } skip_dir if ( tsp ) { free ( tsp -> ts_fh . fh_fpath ) ; free ( tsp ) ; } if ( rv == SKIP_ENTRY ) { rv = 0 ; } if ( rv == 0 ) { if ( cstack_pop ( sp , ( void * * ) & tsp , ( int * ) NULL ) ) { break ; } traverse_stats . fss_pops ++ ; if ( VERBOSE ( ftp ) ) { NDMP_LOG ( LOG_DEBUG , "Poped pl %d \"%s\"" , pl , path ) ; } * tsp -> ts_end = '\0' ; pl = tsp -> ts_end - path ; pn . tn_fh = & tsp -> ts_fh ; pn . tn_st = & tsp -> ts_st ; } } rv == 0 ; while ( ! cstack_pop ( sp , ( void * * ) & tsp , ( int * ) NULL ) ) { traverse_stats . fss_stack_residue ++ ; free ( tsp -> ts_fh . fh_fpath ) ; free ( tsp ) ; } end free ( darg . da_buf ) ; cstack_delete ( sp ) ; return ( rv ) ; } 