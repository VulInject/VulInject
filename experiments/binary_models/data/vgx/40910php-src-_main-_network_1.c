php_socket_t php_network_bind_socket_to_local_addr ( const char * host , unsigned port , int socktype , long sockopts , zend_string * * error_string , int * error_code ) { int num_addrs , n , err = 0 ; php_socket_t sock ; struct sockaddr * * sal , * * psal , * sa ; socklen_t socklen ; int sockoptval = 1 ; num_addrs = php_network_getaddresses ( host , socktype , & psal , error_string ) ; for ( sal = psal ; * sal != NULL ; sal ++ ) { sa = * sal ; switch ( sa -> sa_family ) { case AF_INET6 : ( ( sockaddr_in6 * ) sa ) -> sin6_port = htons ( port ) ; socklen = sizeof ( sockaddr_in6 ) ; break ; case AF_INET : ( ( sockaddr_in * ) sa ) -> sin_port = htons ( port ) ; socklen = sizeof ( sockaddr_in ) ; break ; default : continue ; } sock = socket ( sa -> sa_family , socktype , 0 ) ; if ( sock == SOCK_ERR ) { continue ; } setsockopt ( sock , SOL_SOCKET , SO_REUSEADDR , ( char * ) & sockoptval , sizeof ( sockoptval ) ) ; if ( sockopts & STREAM_SOCKOP_IPV6_V6ONLY ) { int ipv6_val = ! ! ( sockopts & STREAM_SOCKOP_IPV6_V6ONLY_ENABLED ) ; setsockopt ( sock , IPPROTO_IPV6 , IPV6_V6ONLY , ( char * ) & ipv6_val , sizeof ( sockoptval ) ) ; } if ( sockopts & STREAM_SOCKOP_SO_REUSEPORT ) { setsockopt ( sock , SOL_SOCKET , SO_REUSEPORT , ( char * ) & sockoptval , sizeof ( sockoptval ) ) ; } if ( sockopts & STREAM_SOCKOP_SO_BROADCAST ) { setsockopt ( sock , SOL_SOCKET , SO_BROADCAST , ( char * ) & sockoptval , sizeof ( sockoptval ) ) ; } if ( sockopts & STREAM_SOCKOP_TCP_NODELAY ) { setsockopt ( sock , IPPROTO_TCP , TCP_NODELAY , ( char * ) & sockoptval , sizeof ( sockoptval ) ) ; } n = bind ( sock , sa , socklen ) ; if ( n != SOCK_CONN_ERR ) { bound } err = php_socket_errno ( ) ; closesocket ( sock ) ; } sock = - 1 ; if ( error_code ) { * error_code = err ; } if ( error_string ) { * error_string = php_socket_error_str ( err ) ; } bound php_network_freeaddresses ( psal ) ; return sock ; } 