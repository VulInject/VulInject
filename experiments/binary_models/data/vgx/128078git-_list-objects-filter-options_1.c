int gently_parse_list_objects_filter ( struct list_objects_filter_options * filter_options , const char * arg , struct strbuf * errbuf ) { const char * v0 ; if ( ! arg ) { return 0 ; } if ( filter_options -> choice ) { BUG ( "filter_options already populated" ) ; } if ( ! strcmp ( arg , "blob:none" ) ) { filter_options -> choice = LOFC_BLOB_NONE ; return 0 ; } if ( skip_prefix ( arg , "blob:limit=" , & v0 ) ) { if ( git_parse_ulong ( v0 , & filter_options -> blob_limit_value ) ) { filter_options -> choice = LOFC_BLOB_LIMIT ; return 0 ; } } if ( skip_prefix ( arg , "tree:" , & v0 ) ) { if ( ! git_parse_ulong ( v0 , & filter_options -> tree_exclude_depth ) ) { strbuf_addstr ( errbuf , _ ( "expected 'tree:<depth>'" ) ) ; return 1 ; } filter_options -> choice = LOFC_TREE_DEPTH ; return 0 ; } if ( skip_prefix ( arg , "sparse:oid=" , & v0 ) ) { filter_options -> sparse_oid_name = xstrdup ( v0 ) ; filter_options -> choice = LOFC_SPARSE_OID ; return 0 ; } if ( skip_prefix ( arg , "sparse:path=" , & v0 ) ) { if ( errbuf ) { strbuf_addstr ( errbuf , _ ( "sparse:path filters support has been dropped" ) ) ; } return 1 ; } if ( skip_prefix ( arg , "object:type=" , & v0 ) ) { int type = type_from_string_gently ( v0 , strlen ( v0 ) , 1 ) ; if ( type < 0 ) { strbuf_addf ( errbuf , _ ( "'%s' for 'object:type=<type>' is " "not a valid object type" ) , v0 ) ; return 1 ; } filter_options -> object_type = type ; filter_options -> choice = LOFC_OBJECT_TYPE ; return 0 ; } if ( skip_prefix ( arg , "combine:" , & v0 ) ) { return parse_combine_filter ( filter_options , v0 , errbuf ) ; } strbuf_addf ( errbuf , _ ( "invalid filter-spec '%s'" ) , arg ) ; list_objects_filter_init ( filter_options , NULL ) ; return 1 ; } 