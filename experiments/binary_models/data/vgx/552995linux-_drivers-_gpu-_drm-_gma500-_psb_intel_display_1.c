struct drm_display_mode * psb_intel_crtc_mode_get ( struct drm_device * dev , struct drm_crtc * crtc ) { struct gma_crtc * gma_crtc = to_gma_crtc ( crtc ) ; int pipe = gma_crtc -> pipe ; struct drm_display_mode * mode ; int htot ; int hsync ; int vtot ; int vsync ; struct drm_psb_private * dev_priv = to_drm_psb_private ( dev ) ; struct psb_pipe * p = & dev_priv -> regs . pipe [ pipe ] ; const struct psb_offset * map = & dev_priv -> regmap [ pipe ] ; if ( gma_power_begin ( dev , false ) ) { htot = REG_READ ( map -> htotal ) ; hsync = REG_READ ( map -> hsync ) ; vtot = REG_READ ( map -> vtotal ) ; vsync = REG_READ ( map -> vsync ) ; gma_power_end ( dev ) ; } else { htot = p -> htotal ; hsync = p -> hsync ; vtot = p -> vtotal ; vsync = p -> vsync ; } mode = kmalloc ( sizeof ( * mode ) , GFP_KERNEL ) ; if ( ! mode ) { return NULL ; } mode -> clock = psb_intel_crtc_clock_get ( dev , crtc ) ; mode -> hdisplay = ( htot & 0xffff ) + 1 ; mode -> htotal = ( ( htot & 0xffff0000 ) >> 16 ) + 1 ; mode -> hsync_start = ( hsync & 0xffff ) + 1 ; mode -> hsync_end = ( ( hsync & 0xffff0000 ) >> 16 ) + 1 ; mode -> vdisplay = ( vtot & 0xffff ) + 1 ; mode -> vtotal = ( ( vtot & 0xffff0000 ) >> 16 ) + 1 ; mode -> vsync_start = ( vsync & 0xffff ) + 1 ; mode -> vsync_end = ( ( vsync & 0xffff0000 ) >> 16 ) + 1 ; drm_mode_set_name ( mode ) ; drm_mode_set_crtcinfo ( mode , 0 ) ; return mode ; } 