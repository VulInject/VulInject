static const char * _set_resv_msg ( resv_desc_msg_t * resv_msg , const char * new_text , int column ) { char * type = "" ; char * err_msg = NULL ; uint32_t res_free_flags = 0 ; int temp_int = 0 ; uint64_t f ; global_edit_error = 0 ; if ( ! resv_msg ) { return NULL ; } switch ( column ) { case SORTID_ACCOUNTS : resv_msg -> accounts = xstrdup ( new_text ) ; type = "accounts" ; break ; case SORTID_ACTION : xfree ( got_edit_signal ) ; if ( ! xstrcasecmp ( new_text , "None" ) ) { got_edit_signal = NULL ; } else { got_edit_signal = xstrdup ( new_text ) ; } break ; case SORTID_BURST_BUFFER : resv_msg -> burst_buffer = xstrdup ( new_text ) ; type = "burst_buffer" ; break ; case SORTID_CORE_CNT : type = "Core Count" ; if ( state_control_corecnt_supported ( ) != SLURM_SUCCESS ) { if ( global_edit_error_msg ) { g_free ( global_edit_error_msg ) ; } global_edit_error_msg = g_strdup ( "CoreCnt or CPUCnt is only supported when SelectType includes select/cons_res or SelectTypeParameters includes OTHER_CONS_RES on a Cray." ) ; return_error } if ( state_control_parse_resv_corecnt ( resv_msg , ( char * ) new_text , & res_free_flags , false , & err_msg ) == SLURM_ERROR ) { if ( global_edit_error_msg ) { g_free ( global_edit_error_msg ) ; } global_edit_error_msg = g_strdup ( err_msg ) ; return_error } break ; case SORTID_DURATION : type = "duration" ; temp_int = time_str2mins ( ( char * ) new_text ) ; if ( temp_int <= 0 ) { return_error } resv_msg -> duration = temp_int ; break ; case SORTID_TIME_END : resv_msg -> end_time = parse_time ( ( char * ) new_text , 0 ) ; type = "end time" ; break ; case SORTID_FEATURES : resv_msg -> features = xstrdup ( new_text ) ; type = "features" ; break ; case SORTID_FLAGS : f = parse_resv_flags ( new_text , __func__ , resv_msg ) ; type = "flags" ; if ( f == INFINITE64 ) { return_error } break ; case SORTID_GROUPS : resv_msg -> groups = xstrdup ( new_text ) ; type = "groups" ; break ; case SORTID_LICENSES : resv_msg -> licenses = xstrdup ( new_text ) ; type = "licenses" ; break ; case SORTID_MSD : type = "MaxStartDelay" ; temp_int = time_str2secs ( ( char * ) new_text ) ; if ( temp_int < 0 ) { return_error } resv_msg -> max_start_delay = temp_int ; break ; case SORTID_NAME : resv_msg -> name = xstrdup ( new_text ) ; type = "name" ; break ; case SORTID_NODE_CNT : type = "Node Count" ; if ( parse_resv_nodecnt ( resv_msg , ( char * ) new_text , & res_free_flags , false , & err_msg ) == SLURM_ERROR ) { if ( global_edit_error_msg ) { g_free ( global_edit_error_msg ) ; } global_edit_error_msg = g_strdup ( err_msg ) ; xfree ( err_msg ) ; return_error } break ; case SORTID_NODELIST : resv_msg -> node_list = xstrdup ( new_text ) ; type = "Node List" ; break ; case SORTID_PARTITION : resv_msg -> partition = xstrdup ( new_text ) ; type = "partition" ; break ; case SORTID_TIME_START : resv_msg -> start_time = parse_time ( ( char * ) new_text , 0 ) ; type = "start time" ; break ; case SORTID_USERS : resv_msg -> users = xstrdup ( new_text ) ; type = "users" ; break ; case SORTID_TRES : type = "TRES" ; if ( state_control_parse_resv_tres ( ( char * ) new_text , resv_msg , & res_free_flags , & err_msg ) == SLURM_ERROR ) { if ( global_edit_error_msg ) { g_free ( global_edit_error_msg ) ; } global_edit_error_msg = g_strdup ( err_msg ) ; xfree ( err_msg ) ; return_error } break ; case SORTID_WATTS : if ( state_control_parse_resv_watts ( ( char * ) new_text , resv_msg , & err_msg ) == SLURM_ERROR ) { if ( global_edit_error_msg ) { g_free ( global_edit_error_msg ) ; } global_edit_error_msg = g_strdup ( err_msg ) ; xfree ( err_msg ) ; return_error } type = "watts" ; break ; default : type = "unknown" ; break ; } if ( xstrcmp ( type , "unknown" ) ) { global_send_update_msg = 1 ; } slurm_free_resv_desc_msg_part ( resv_msg , res_free_flags ) ; return type ; return_error slurm_free_resv_desc_msg_part ( resv_msg , res_free_flags ) ; global_edit_error = 1 ; return type ; } 