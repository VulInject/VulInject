void ceph_handle_quota ( struct ceph_mds_client * mdsc , struct ceph_mds_session * session , struct ceph_msg * msg ) { struct super_block * sb = mdsc -> fsc -> sb ; struct ceph_mds_quota * h = msg -> front . iov_base ; struct ceph_vino vino ; struct inode * inode ; struct ceph_inode_info * ci ; if ( msg -> front . iov_len < sizeof ( * h ) ) { pr_err ( "%s corrupt message mds%d len %d\n" , __func__ , session -> s_mds , ( int ) msg -> front . iov_len ) ; ceph_msg_dump ( msg ) ; return ; } mutex_lock ( & session -> s_mutex ) ; inc_session_sequence ( session ) ; mutex_unlock ( & session -> s_mutex ) ; vino . ino = le64_to_cpu ( h -> ino ) ; vino . snap = CEPH_NOSNAP ; inode = ceph_find_inode ( sb , vino ) ; if ( ! inode ) { pr_warn ( "Failed to find inode %llu\n" , vino . ino ) ; return ; } ci = ceph_inode ( inode ) ; spin_lock ( & ci -> i_ceph_lock ) ; ci -> i_rbytes = le64_to_cpu ( h -> rbytes ) ; ci -> i_rfiles = le64_to_cpu ( h -> rfiles ) ; ci -> i_rsubdirs = le64_to_cpu ( h -> rsubdirs ) ; __ceph_update_quota ( ci , le64_to_cpu ( h -> max_bytes ) , le64_to_cpu ( h -> max_files ) ) ; spin_unlock ( & ci -> i_ceph_lock ) ; iput ( inode , NULL ) ; } 