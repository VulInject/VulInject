static int stusb160x_probe ( struct i2c_client * client ) { struct stusb160x * chip ; const struct of_device_id * match ; struct regmap_config * regmap_config ; struct fwnode_handle * fwnode ; int ret ; chip = devm_kzalloc ( & client -> dev , sizeof ( stusb160x ) , GFP_KERNEL ) ; i2c_set_clientdata ( client , chip ) ; match = i2c_of_match_device ( stusb160x_of_match , client ) ; regmap_config = ( regmap_config * ) match -> data ; chip -> regmap = devm_regmap_init_i2c ( client , regmap_config ) ; if ( IS_ERR ( chip -> regmap ) ) { ret = PTR_ERR ( chip -> regmap ) ; dev_err ( & client -> dev , "Failed to allocate register map:%d\n" , ret ) ; return ret ; } chip -> dev = & client -> dev ; chip -> vsys_supply = devm_regulator_get_optional ( chip -> dev , "vsys" ) ; if ( IS_ERR ( chip -> vsys_supply ) ) { ret = PTR_ERR ( chip -> vsys_supply ) ; if ( ret != - ENODEV ) { return ret ; } chip -> vsys_supply = NULL ; } chip -> vdd_supply = devm_regulator_get_optional ( chip -> dev , "vdd" ) ; if ( IS_ERR ( chip -> vdd_supply ) ) { ret = PTR_ERR ( chip -> vdd_supply ) ; if ( ret != - ENODEV ) { return ret ; } chip -> vdd_supply = NULL ; } chip -> vconn_supply = devm_regulator_get_optional ( chip -> dev , "vconn" ) ; if ( IS_ERR ( chip -> vconn_supply ) ) { ret = PTR_ERR ( chip -> vconn_supply ) ; if ( ret != - ENODEV ) { return ret ; } chip -> vconn_supply = NULL ; } fwnode = device_get_named_child_node ( chip -> dev , "connector" ) ; if ( ! fwnode ) { return - ENODEV ; } fw_devlink_purge_absent_suppliers ( fwnode ) ; if ( chip -> vdd_supply && ( ! chip -> vsys_supply || ( regulator_get_voltage ( chip -> vsys_supply ) <= 3100000 ) ) ) { chip -> main_supply = chip -> vdd_supply ; } else { chip -> main_supply = chip -> vsys_supply ; } if ( chip -> main_supply ) { ret = regulator_enable ( chip -> main_supply ) ; if ( ret ) { dev_err ( chip -> dev , "Failed to enable main supply: %d\n" , ret ) ; fwnode_put } } ret = stusb160x_get_caps ( chip ) ; if ( ret ) { dev_err ( chip -> dev , "Failed to get port caps: %d\n" , ret ) ; main_reg_disable } ret = stusb160x_get_fw_caps ( chip , fwnode ) ; if ( ret ) { dev_err ( chip -> dev , "Failed to get connector caps: %d\n" , ret ) ; main_reg_disable } ret = stusb160x_chip_init ( chip ) ; if ( ret ) { dev_err ( chip -> dev , "Failed to init port: %d\n" , ret ) ; main_reg_disable } chip -> port = typec_register_port ( chip -> dev , & chip -> capability ) ; if ( IS_ERR ( chip -> port ) ) { ret = PTR_ERR ( chip -> port ) ; all_reg_disable } typec_set_pwr_opmode ( chip -> port , chip -> pwr_opmode ) ; if ( client -> irq ) { chip -> role_sw = fwnode_usb_role_switch_get ( fwnode ) ; if ( IS_ERR ( chip -> role_sw ) ) { ret = dev_err_probe ( chip -> dev , PTR_ERR ( chip -> role_sw ) , "Failed to get usb role switch\n" ) ; port_unregister } ret = stusb160x_irq_init ( chip , client -> irq ) ; if ( ret ) { role_sw_put } } else { if ( chip -> port_type != TYPEC_PORT_SNK && chip -> vdd_supply ) { ret = regulator_enable ( chip -> vdd_supply ) ; if ( ret ) { dev_err ( chip -> dev , "Failed to enable VDD supply: %d\n" , ret ) ; port_unregister } chip -> vbus_on = true ; } } fwnode_handle_put ( fwnode ) ; return 0 ; role_sw_put if ( chip -> role_sw ) { usb_role_switch_put ( chip -> role_sw ) ; } port_unregister typec_unregister_port ( chip -> port ) ; all_reg_disable if ( stusb160x_get_vconn ( chip ) ) { stusb160x_set_vconn ( chip , false ) ; } main_reg_disable if ( chip -> main_supply ) { regulator_disable ( chip -> main_supply ) ; } fwnode_put fwnode_handle_put ( fwnode ) ; return ret ; } 