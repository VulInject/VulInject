static size_t __sh_eth_get_regs ( struct net_device * ndev , u32 * buf ) { struct sh_eth_private * mdp = netdev_priv ( ndev ) ; struct sh_eth_cpu_data * cd = mdp -> cd ; u32 * valid_map ; size_t len ; BUILD_BUG_ON ( SH_ETH_MAX_REGISTER_OFFSET > SH_ETH_REG_DUMP_MAX_REGS ) ; len = DIV_ROUND_UP ( SH_ETH_REG_DUMP_MAX_REGS , 32 ) ; if ( buf ) { valid_map = buf ; buf += len ; } else { valid_map = NULL ; } if ( mdp -> reg_offset [ reg ] != SH_ETH_OFFSET_INVALID ) { if ( buf ) { mark_reg_valid ( reg ) ; * buf ++ = read_expr ; } ++ len ; } } while ( 0 ) { add_reg ( EDSR ) ; } add_reg ( EDMR ) ; add_reg ( EDTRR ) ; add_reg ( EDRRR ) ; add_reg ( EESR ) ; add_reg ( EESIPR ) ; add_reg ( TDLAR ) ; add_reg ( TDFAR ) ; add_reg ( TDFXR ) ; add_reg ( TDFFR ) ; add_reg ( RDLAR ) ; add_reg ( RDFAR ) ; add_reg ( RDFXR ) ; add_reg ( RDFFR ) ; add_reg ( TRSCER ) ; add_reg ( RMFCR ) ; add_reg ( TFTR ) ; add_reg ( FDR ) ; add_reg ( RMCR ) ; add_reg ( TFUCR ) ; add_reg ( RFOCR ) ; if ( cd -> rmiimode ) { add_reg ( RMIIMODE ) ; } add_reg ( FCFTR ) ; if ( cd -> rpadir ) { add_reg ( RPADIR ) ; } if ( ! cd -> no_trimd ) { add_reg ( TRIMD ) ; } add_reg ( ECMR ) ; add_reg ( ECSR ) ; add_reg ( ECSIPR ) ; add_reg ( PIR ) ; if ( ! cd -> no_psr ) { add_reg ( PSR ) ; } add_reg ( RDMLR ) ; add_reg ( RFLR ) ; add_reg ( IPGR ) ; if ( cd -> apr ) { add_reg ( APR ) ; } if ( cd -> mpr ) { add_reg ( MPR ) ; } add_reg ( RFCR ) ; add_reg ( RFCF ) ; if ( cd -> tpauser ) { add_reg ( TPAUSER ) ; } add_reg ( TPAUSECR ) ; add_reg ( GECMR ) ; if ( cd -> bculr ) { add_reg ( BCULR ) ; } add_reg ( MAHR ) ; add_reg ( MALR ) ; add_reg ( TROCR ) ; add_reg ( CDCR ) ; add_reg ( LCCR ) ; add_reg ( CNDCR ) ; add_reg ( CEFCR ) ; add_reg ( FRECR ) ; add_reg ( TSFRCR ) ; add_reg ( TLFRCR ) ; add_reg ( CERCR ) ; add_reg ( CEECR ) ; add_reg ( MAFCR ) ; if ( cd -> rtrate ) { add_reg ( RTRATE ) ; } if ( cd -> hw_checksum ) { add_reg ( CSMR ) ; } if ( cd -> select_mii ) { add_reg ( RMII_MII ) ; } add_reg ( ARSTR ) ; if ( cd -> tsu ) { add_tsu_reg ( TSU_CTRST ) ; add_tsu_reg ( TSU_FWEN0 , NULL ) ; add_tsu_reg ( TSU_FWEN1 ) ; add_tsu_reg ( TSU_FCM ) ; add_tsu_reg ( TSU_BSYSL0 ) ; add_tsu_reg ( TSU_BSYSL1 ) ; add_tsu_reg ( TSU_PRISL0 ) ; add_tsu_reg ( TSU_PRISL1 ) ; add_tsu_reg ( TSU_FWSL0 ) ; add_tsu_reg ( TSU_FWSL1 ) ; add_tsu_reg ( TSU_FWSLC ) ; add_tsu_reg ( TSU_QTAG0 ) ; add_tsu_reg ( TSU_QTAG1 ) ; add_tsu_reg ( TSU_QTAGM0 ) ; add_tsu_reg ( TSU_QTAGM1 ) ; add_tsu_reg ( TSU_FWSR ) ; add_tsu_reg ( TSU_FWINMK ) ; add_tsu_reg ( TSU_ADQT0 ) ; add_tsu_reg ( TSU_ADQT1 ) ; add_tsu_reg ( TSU_VTAG0 ) ; add_tsu_reg ( TSU_VTAG1 ) ; add_tsu_reg ( TSU_ADSBSY ) ; add_tsu_reg ( TSU_TEN ) ; add_tsu_reg ( TSU_POST1 ) ; add_tsu_reg ( TSU_POST2 ) ; add_tsu_reg ( TSU_POST3 ) ; add_tsu_reg ( TSU_POST4 ) ; if ( mdp -> reg_offset [ TSU_ADRH0 ] != SH_ETH_OFFSET_INVALID ) { if ( buf ) { unsigned int i ; mark_reg_valid ( TSU_ADRH0 ) ; for ( i = 0 ; i < SH_ETH_TSU_CAM_ENTRIES * 2 ; i ++ ) { * buf ++ = ioread32 ( mdp -> tsu_addr + mdp -> reg_offset [ TSU_ADRH0 ] + i * 4 ) ; } } len += SH_ETH_TSU_CAM_ENTRIES * 2 ; } } return len * 4 ; 