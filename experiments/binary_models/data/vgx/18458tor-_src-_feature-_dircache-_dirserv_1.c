static spooled_resource_flush_status_t spooled_resource_flush_some ( spooled_resource_t * spooled , dir_connection_t * conn ) { if ( spooled -> spool_eagerly ) { const uint8_t * body = NULL ; int bodylen = 0 ; int r = spooled_resource_lookup_body ( spooled , connection_dir_is_encrypted ( conn ) , & body , & bodylen , NULL ) ; if ( r == - 1 || body == NULL || bodylen == 0 ) { return SRFS_DONE ; } connection_dir_buf_add ( ( const char * ) body , bodylen , conn , 0 ) ; return SRFS_DONE ; } else { cached_dir_t * cached = spooled -> cached_dir_ref ; consensus_cache_entry_t * cce = spooled -> consensus_cache_entry ; if ( cached == NULL && cce == NULL ) { cached = spooled -> cached_dir_ref = spooled_resource_lookup_cached_dir ( spooled , NULL ) ; if ( ! cached ) { return SRFS_DONE ; } ++ cached -> refcnt ; tor_assert_nonfatal ( spooled -> cached_dir_offset == 0 ) ; } if ( BUG ( ! cached && ! cce ) ) { return SRFS_DONE ; } int64_t total_len ; const char * ptr ; if ( cached ) { total_len = cached -> dir_compressed_len ; ptr = cached -> dir_compressed ; } else { total_len = spooled -> cce_len ; ptr = ( const char * ) spooled -> cce_body ; } int64_t remaining ; remaining = total_len - spooled -> cached_dir_offset ; if ( BUG ( remaining < 0 ) ) { return SRFS_ERR ; } ssize_t bytes = ( ssize_t ) MIN ( DIRSERV_CACHED_DIR_CHUNK_SIZE , remaining ) ; connection_dir_buf_add ( ptr + spooled -> cached_dir_offset , bytes , conn , 0 ) ; spooled -> cached_dir_offset += bytes ; if ( spooled -> cached_dir_offset >= ( off_t ) total_len ) { return SRFS_DONE ; } else { return SRFS_MORE ; } } } 