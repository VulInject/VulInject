static int sbdp_prep_mc_idle_one ( sbdp_bd_t * bp , sbdp_rename_script_t phys_banks [ ] , int * b_idx , sbdp_mc_idle_script_t mc_idle_regs [ ] , int * r_idx ) { int i , j ; pnode_t * memnodes ; mc_regs_t regs ; uint64_t addr ; uint_t asi ; sbd_cond_t sibling_cpu_cond ; int impl = - 1 ; memnodes = bp -> nodes ; for ( i = 0 ; i < SBDP_MAX_MEM_NODES_PER_BOARD ; i ++ ) { sibling_cpu_cond = mc_check_sibling_cpu ( memnodes [ i ] ) ; if ( sibling_cpu_cond == SBD_COND_FAILED || sibling_cpu_cond == SBD_COND_UNUSABLE ) { SBDP_DBG_MEM ( "sbdp: skipping MC with failed cpu: " "board=%d, mem node=%d, condition=%d" , bp -> bd , i , sibling_cpu_cond ) ; continue ; } if ( impl == - 1 ) { impl = mc_get_sibling_cpu_impl ( memnodes [ i ] ) ; if ( impl == - 1 ) { SBDP_DBG_MEM ( "sbdp: failed to get cpu impl " "for MC dnode=0x%x\n" , memnodes [ i ] ) ; return ( - 1 ) ; } } switch ( impl ) { case CHEETAH_IMPL : case CHEETAH_PLUS_IMPL : case JAGUAR_IMPL : if ( mc_read_regs ( memnodes [ i ] , & regs ) ) { SBDP_DBG_MEM ( "sbdp: failed to read source " "Decode Regs of board %d" , bp -> bd ) ; return ( - 1 ) ; } for ( j = 0 ; j < SBDP_MAX_MCS_PER_NODE ; j ++ ) { uint64_t mc_decode = regs . mc_decode [ j ] ; if ( ( mc_decode & SG_DECODE_VALID ) != SG_DECODE_VALID ) { continue ; } addr = ( MC_BASE ( mc_decode ) << PHYS2UM_SHIFT ) | ( MC_LM ( mc_decode ) << MC_LM_SHIFT ) ; phys_banks [ * b_idx ] . masr_addr = addr ; phys_banks [ * b_idx ] . masr = 0 ; phys_banks [ * b_idx ] . asi = ASI_MEM ; ( * b_idx ) ++ ; } break ; case PANTHER_IMPL : if ( mc_get_idle_reg ( memnodes [ i ] , & addr , & asi ) ) { return ( - 1 ) ; } mc_idle_regs [ * r_idx ] . addr = addr ; mc_idle_regs [ * r_idx ] . asi = asi ; mc_idle_regs [ * r_idx ] . node = memnodes [ i ] ; mc_idle_regs [ * r_idx ] . bd_id = bp -> bd ; ( * r_idx ) ++ ; break ; default : cmn_err ( CE_WARN , "Unknown cpu implementation=0x%x" , impl ) ; ASSERT ( 0 ) ; return ( - 1 ) ; } } return ( 0 ) ; } 