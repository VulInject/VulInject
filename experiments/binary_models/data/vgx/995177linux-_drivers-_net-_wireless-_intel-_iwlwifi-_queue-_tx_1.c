int iwl_txq_alloc ( struct iwl_trans * trans , struct iwl_txq * txq , int slots_num , bool cmd_queue ) { size_t tfd_sz = trans -> txqs . tfd . size * trans -> trans_cfg -> base_params -> max_tfd_queue_size ; size_t tb0_buf_sz ; int i ; if ( WARN_ON ( txq -> entries || txq -> tfds ) ) { return - EINVAL ; } if ( trans -> trans_cfg -> use_tfh ) { tfd_sz = trans -> txqs . tfd . size * slots_num ; } timer_setup ( & txq -> stuck_timer , iwl_txq_stuck_timer , 0 ) ; txq -> trans = trans ; txq -> n_window = slots_num ; txq -> entries = kcalloc ( slots_num , sizeof ( iwl_pcie_txq_entry ) , GFP_KERNEL ) ; if ( ! txq -> entries ) { error } if ( cmd_queue ) { for ( i = 0 ; i < slots_num ; i ++ ) { txq -> entries [ i ] . cmd = kmalloc ( sizeof ( iwl_device_cmd ) , GFP_KERNEL ) ; if ( ! txq -> entries [ i ] . cmd ) { error } } } txq -> tfds = dma_alloc_coherent ( trans -> dev , tfd_sz , & txq -> dma_addr , GFP_KERNEL ) ; if ( ! txq -> tfds ) { error } BUILD_BUG_ON ( sizeof ( * txq -> first_tb_bufs ) != IWL_FIRST_TB_SIZE_ALIGN ) ; tb0_buf_sz = sizeof ( * txq -> first_tb_bufs ) * slots_num ; txq -> first_tb_bufs = dma_alloc_coherent ( trans -> dev , tb0_buf_sz , & txq -> first_tb_dma , GFP_KERNEL ) ; if ( ! txq -> first_tb_bufs ) { err_free_tfds } return 0 ; err_free_tfds dma_free_coherent ( trans -> dev , tfd_sz , txq -> tfds , txq -> dma_addr ) ; txq -> tfds = NULL ; error if ( txq -> entries && cmd_queue ) { for ( i = 0 ; i < slots_num ; i ++ ) { kfree ( txq -> entries [ i ] . cmd ) ; } } txq -> entries = NULL ; return - ENOMEM ; } 