int bgp_flowspec_ip_address ( enum bgp_flowspec_util_nlri_t type , uint8_t * nlri_ptr , uint32_t max_len , void * result , int * error , afi_t afi , uint8_t * ipv6_offset ) { char * display = ( char * ) result ; struct prefix * prefix = ( prefix * ) result ; uint32_t offset = 0 ; struct prefix prefix_local ; int psize ; uint8_t prefix_offset = 0 ; * error = 0 ; prefix_local . prefixlen = nlri_ptr [ offset ] ; psize = PSIZE ( prefix_local . prefixlen ) ; offset ++ ; prefix_local . family = afi2family ( afi ) ; if ( prefix_local . family == AF_INET6 ) { prefix_offset = nlri_ptr [ offset ] ; if ( ipv6_offset ) { * ipv6_offset = prefix_offset ; } offset ++ ; } if ( prefix_local . prefixlen > prefix_blen ( & prefix_local ) * 8 ) { * error = - 1 ; } if ( psize + offset > max_len ) { * error = - 1 ; } if ( psize > ( ssize_t ) sizeof ( prefix_local . u ) ) { * error = - 1 ; } memcpy ( & prefix_local . u . prefix , & nlri_ptr [ offset ] , psize ) ; offset += psize ; switch ( type ) { case BGP_FLOWSPEC_RETURN_STRING : if ( prefix_local . family == AF_INET6 ) { int ret ; ret = snprintfrr ( display , BGP_FLOWSPEC_STRING_DISPLAY_MAX , "%pFX/off %u" , & prefix_local , prefix_offset ) ; if ( ret < 0 ) { * error = - 1 ; break ; } } else { prefix2str ( & prefix_local , display , BGP_FLOWSPEC_STRING_DISPLAY_MAX ) ; } break ; case BGP_FLOWSPEC_CONVERT_TO_NON_OPAQUE : if ( prefix ) { prefix_copy ( prefix , & prefix_local ) ; } break ; case BGP_FLOWSPEC_VALIDATE_ONLY : case BGP_FLOWSPEC_RETURN_JSON : break ; } return offset ; } 