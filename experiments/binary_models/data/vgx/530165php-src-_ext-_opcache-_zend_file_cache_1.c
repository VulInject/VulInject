int zend_file_cache_script_store ( zend_persistent_script * script , bool in_shm ) { int fd ; char * filename ; zend_file_cache_metainfo info ; void * mem , * buf ; if ( JIT_G ( on ) ) { return FAILURE ; } filename = zend_file_cache_get_bin_file_path ( script -> script . filename ) ; if ( zend_file_cache_mkdir ( filename , strlen ( ZCG ( accel_directives ) . file_cache ) ) != SUCCESS ) { zend_accel_error ( ACCEL_LOG_WARNING , "opcache cannot create directory for file '%s', %s\n" , filename , strerror ( errno ) ) ; return FAILURE ; } fd = zend_file_cache_open ( filename , O_CREAT | O_EXCL | O_RDWR | O_BINARY , S_IRUSR | S_IWUSR ) ; if ( fd < 0 ) { if ( errno != EEXIST ) { zend_accel_error ( ACCEL_LOG_WARNING , "opcache cannot create file '%s', %s\n" , filename , strerror ( errno ) ) ; } efree ( filename ) ; return FAILURE ; } if ( zend_file_cache_flock ( fd , LOCK_EX ) != 0 ) { close ( fd ) ; efree ( filename ) ; return FAILURE ; } mem = emalloc ( script -> size + 64 ) ; buf = ( void * ) ( ( ( uintptr_t ) mem + 63L ) & ~ 63L ) ; mem = buf = emalloc ( script -> size ) ; ZCG ( mem ) = zend_string_alloc ( 4096 - ( _ZSTR_HEADER_SIZE + 1 ) , 0 ) ; zend_shared_alloc_init_xlat_table ( ) ; if ( ! in_shm ) { script -> corrupted = true ; } zend_file_cache_serialize ( script , & info , buf ) ; if ( ! in_shm ) { script -> corrupted = false ; } zend_shared_alloc_destroy_xlat_table ( ) ; zend_string * const s = ( zend_string * ) ZCG ( mem ) ; info . checksum = zend_adler32 ( ADLER32_INIT , buf , script -> size ) ; info . checksum = zend_adler32 ( info . checksum , ( unsigned char * ) ZSTR_VAL ( s ) , info . str_size ) ; __msan_unpoison ( & info , sizeof ( info ) ) ; __msan_unpoison ( buf , script -> size ) ; if ( ! zend_file_cache_script_write ( fd , script , & info , buf , s ) ) { zend_accel_error ( ACCEL_LOG_WARNING , "opcache cannot write to file '%s': %s\n" , filename , strerror ( errno ) ) ; zend_string_release_ex ( s , 0 ) ; close ( fd ) ; efree ( mem ) ; zend_file_cache_unlink ( filename ) ; efree ( filename ) ; return FAILURE ; } zend_string_release_ex ( s , 0 ) ; efree ( mem ) ; if ( zend_file_cache_flock ( fd , LOCK_UN ) != 0 ) { zend_accel_error ( ACCEL_LOG_WARNING , "opcache cannot unlock file '%s': %s\n" , filename , strerror ( errno ) ) ; } close ( fd ) ; efree ( filename ) ; return SUCCESS ; } 