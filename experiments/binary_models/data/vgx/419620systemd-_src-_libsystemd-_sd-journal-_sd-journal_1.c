_public_ int sd_journal_add_match ( sd_journal * j , const void * data , size_t size ) { Match * add_here = NULL , * m = NULL ; uint64_t hash ; assert_return ( j , - EINVAL ) ; assert_return ( ! journal_pid_changed ( j ) , - ECHILD ) ; assert_return ( data , - EINVAL ) ; if ( size == 0 ) { size = strlen ( data ) ; } assert_return ( match_is_valid ( data , size ) , - EINVAL ) ; if ( ! j -> level0 ) { j -> level0 = match_new ( NULL , MATCH_AND_TERM ) ; if ( ! j -> level0 ) { return - ENOMEM ; } } if ( ! j -> level1 ) { j -> level1 = match_new ( j -> level0 , MATCH_OR_TERM ) ; if ( ! j -> level1 ) { return - ENOMEM ; } } if ( ! j -> level2 ) { j -> level2 = match_new ( j -> level1 , MATCH_AND_TERM ) ; if ( ! j -> level2 ) { return - ENOMEM ; } } assert ( j -> level0 -> type == MATCH_AND_TERM ) ; assert ( j -> level1 -> type == MATCH_OR_TERM ) ; assert ( j -> level2 -> type == MATCH_AND_TERM ) ; hash = jenkins_hash64 ( data , size ) ; LIST_FOREACH ( , , ) { assert ( l3 -> type == MATCH_OR_TERM ) ; LIST_FOREACH ( , , ) { assert ( l4 -> type == MATCH_DISCRETE ) ; if ( l4 -> hash == hash && l4 -> size == size && memcmp ( l4 -> data , data , size ) == 0 ) { return 0 ; } if ( same_field ( data , size , l4 -> data , l4 -> size ) ) { add_here = l3 ; break ; } } if ( add_here ) { break ; } } if ( ! add_here ) { add_here = match_new ( j -> level2 , MATCH_OR_TERM ) ; if ( ! add_here ) { fail } } m = match_new ( add_here , MATCH_DISCRETE ) ; if ( ! m ) { fail } m -> hash = hash ; m -> size = size ; m -> data = memdup ( data , size ) ; if ( ! m -> data ) { fail } detach_location ( j ) ; return 0 ; fail match_free ( m ) ; j -> level2 = match_free_if_empty ( j -> level2 ) ; j -> level1 = match_free_if_empty ( j -> level1 ) ; j -> level0 = match_free_if_empty ( j -> level0 ) ; return - ENOMEM ; } 