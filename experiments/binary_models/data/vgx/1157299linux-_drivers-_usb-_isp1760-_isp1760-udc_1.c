static int isp1760_ep_enable ( struct usb_ep * ep , const struct usb_endpoint_descriptor * desc ) { struct isp1760_ep * uep = ep_to_udc_ep ( ep ) ; struct isp1760_udc * udc = uep -> udc ; cfs_time_t flags ; unsigned int type ; dev_dbg ( uep -> udc -> isp -> dev , "%s\n" , __func__ ) ; if ( desc -> bDescriptorType != USB_DT_ENDPOINT || desc -> bEndpointAddress == 0 || desc -> bEndpointAddress != uep -> addr || le16_to_cpu ( desc -> wMaxPacketSize ) > ep -> maxpacket ) { dev_dbg ( udc -> isp -> dev , "%s: invalid descriptor type %u addr %02x ep addr %02x max packet size %u/%u\n" , __func__ , desc -> bDescriptorType , desc -> bEndpointAddress , uep -> addr , le16_to_cpu ( desc -> wMaxPacketSize ) , ep -> maxpacket ) ; return - EINVAL ; } switch ( usb_endpoint_type ( desc ) ) { case USB_ENDPOINT_XFER_ISOC : type = ISP176x_DC_ENDPTYP_ISOC ; break ; case USB_ENDPOINT_XFER_BULK : type = ISP176x_DC_ENDPTYP_BULK ; break ; case USB_ENDPOINT_XFER_INT : type = ISP176x_DC_ENDPTYP_INTERRUPT ; break ; case USB_ENDPOINT_XFER_CONTROL : default : dev_dbg ( udc -> isp -> dev , "%s: control endpoints unsupported\n" , __func__ ) ; return - EINVAL ; } spin_lock_irqsave ( & udc -> lock , flags ) ; uep -> desc = desc ; uep -> maxpacket = le16_to_cpu ( desc -> wMaxPacketSize ) ; uep -> rx_pending = false ; uep -> halted = false ; uep -> wedged = false ; isp1760_udc_select_ep ( udc , uep ) ; isp1760_udc_write ( udc , DC_FFOSZ , uep -> maxpacket ) ; isp1760_udc_write ( udc , DC_BUFLEN , uep -> maxpacket ) ; isp1760_udc_write ( udc , DC_ENDPTYP , type ) ; isp1760_udc_set ( udc , DC_EPENABLE ) ; spin_unlock_irqrestore ( & udc -> lock , flags ) ; return 0 ; } 