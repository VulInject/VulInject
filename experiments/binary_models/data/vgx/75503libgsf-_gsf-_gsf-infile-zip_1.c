gsf_infile_zip_read ( , , ) { GsfInfileZip * zip = GSF_INFILE_ZIP ( input ) ; GsfZipVDir * vdir = zip -> vdir ; gsf_off_t pos ; if ( zip -> restlen < ( gsf_off_t ) num_bytes ) { return in ; } switch ( vdir -> dirent -> compr_method ) { case GSF_ZIP_STORED : zip -> restlen -= num_bytes ; pos = zip -> vdir -> dirent -> data_offset + input -> cur_offset ; if ( gsf_input_seek ( zip -> source , pos , G_SEEK_SET ) ) { return NULL ; } return gsf_input_read ( zip -> source , num_bytes , buffer ) ; case GSF_ZIP_DEFLATED : if ( buffer == NULL ) { if ( zip -> buf_size < num_bytes ) { zip -> buf_size = MAX ( num_bytes , 256 ) ; g_free ( zip -> buf ) ; zip -> buf = g_new ( guint8 , zip -> buf_size ) ; } buffer = zip -> buf ; } zip -> stream -> avail_out = num_bytes ; zip -> stream -> next_out = ( unsigned char * ) buffer ; { int err ; gsf_off_t startlen ; if ( zip -> crestlen > 0 && zip -> stream -> avail_in == 0 ) { if ( ! zip_update_stream_in ( zip ) ) { break ; } } startlen = zip -> stream -> total_out ; err = inflate ( zip -> stream , Z_NO_FLUSH ) ; if ( err == Z_STREAM_END ) { zip -> restlen = 0 ; } if ( err == Z_OK ) { zip -> restlen -= ( zip -> stream -> total_out - startlen ) ; } else { return NULL ; } } zip -> restlen && zip -> stream -> avail_out ; return buffer ; default : break ; } return NULL ; } 