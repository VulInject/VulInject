static CURLcode bearssl_run_until ( struct Curl_cfilter * cf , struct Curl_easy * data , unsigned target ) { struct ssl_connect_data * connssl = cf -> ctx ; struct ssl_backend_data * backend = connssl -> backend ; unsigned state ; unsigned char * buf ; size_t len ; ssize_t ret ; CURLcode result ; int err ; DEBUGASSERT ( backend ) ; for ( ; ; ) { state = br_ssl_engine_current_state ( & backend -> ctx . eng ) ; if ( state & BR_SSL_CLOSED ) { err = br_ssl_engine_last_error ( & backend -> ctx . eng ) ; switch ( err ) { case BR_ERR_OK : if ( connssl -> state != ssl_connection_complete ) { failf ( data , "SSL: connection closed during handshake" ) ; return CURLE_SSL_CONNECT_ERROR ; } return CURLE_OK ; case BR_ERR_X509_EXPIRED : failf ( data , "SSL: X.509 verification: " "certificate is expired or not yet valid" ) ; return CURLE_PEER_FAILED_VERIFICATION ; case BR_ERR_X509_BAD_SERVER_NAME : failf ( data , "SSL: X.509 verification: " "expected server name was not found in the chain" ) ; return CURLE_PEER_FAILED_VERIFICATION ; case BR_ERR_X509_NOT_TRUSTED : failf ( data , "SSL: X.509 verification: " "chain could not be linked to a trust anchor" ) ; return CURLE_PEER_FAILED_VERIFICATION ; } if ( err >= 32 && err < 64 ) { return CURLE_PEER_FAILED_VERIFICATION ; } return CURLE_SSL_CONNECT_ERROR ; } if ( state & target ) { return CURLE_OK ; } if ( state & BR_SSL_SENDREC ) { buf = br_ssl_engine_sendrec_buf ( & backend -> ctx . eng , & len ) ; ret = Curl_conn_cf_send ( cf -> next , data , ( char * ) buf , len , & result ) ; br_ssl_engine_sendrec_ack ( & backend -> ctx . eng , ret ) ; } if ( state & BR_SSL_RECVREC ) { buf = br_ssl_engine_recvrec_buf ( & backend -> ctx . eng , & len ) ; ret = Curl_conn_cf_recv ( cf -> next , data , ( char * ) buf , len , & result ) ; if ( ret == 0 ) { failf ( data , "SSL: EOF without close notify" ) ; return CURLE_READ_ERROR ; } if ( ret <= 0 ) { return result ; } br_ssl_engine_recvrec_ack ( & backend -> ctx . eng , ret ) ; } } } 