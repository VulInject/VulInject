int add_redirect_rule2 ( const char * ifname , const char * rhost , unsigned short eport , const char * iaddr , unsigned short iport , int proto , const char * desc , unsigned int timestamp ) { int r ; struct pfioc_rule pcr ; struct pfioc_pooladdr pp ; struct pf_pooladdr * a ; if ( dev < 0 ) { syslog ( LOG_ERR , "pf device is not open" ) ; return - 1 ; } r = 0 ; memset ( & pcr , 0 , sizeof ( pcr ) ) ; strlcpy ( pcr . anchor , anchor_name , MAXPATHLEN ) ; strlcpy ( pp . anchor , anchor_name , MAXPATHLEN ) ; if ( ioctl ( dev , DIOCBEGINADDRS , & pp ) < 0 ) { syslog ( LOG_ERR , "ioctl(dev, DIOCBEGINADDRS, ...): %m" ) ; r = - 1 ; } else { pcr . pool_ticket = pp . ticket ; if ( 1 ) { pcr . rule . direction = PF_IN ; pcr . rule . nat . addr . type = PF_ADDR_NONE ; pcr . rule . rdr . addr . type = PF_ADDR_ADDRMASK ; pcr . rule . src . addr . type = PF_ADDR_ADDRMASK ; pcr . rule . dst . addr . type = PF_ADDR_ADDRMASK ; pcr . rule . dst . xport . range . op = PF_OP_EQ ; pcr . rule . dst . xport . range . port [ 0 ] = htons ( eport ) ; pcr . rule . dst . xport . range . port [ 1 ] = htons ( eport ) ; pcr . rule . dst . port_op = PF_OP_EQ ; pcr . rule . dst . port [ 0 ] = htons ( eport ) ; pcr . rule . dst . port [ 1 ] = htons ( eport ) ; pcr . rule . action = PF_RDR ; pcr . rule . natpass = 1 ; pcr . rule . natpass = 0 ; pcr . rule . action = PF_PASS ; pcr . rule . action = PF_MATCH ; pcr . rule . af = AF_INET ; if ( ifname ) { strlcpy ( pcr . rule . ifname , ifname , IFNAMSIZ ) ; } pcr . rule . proto = proto ; pcr . rule . log = ( GETFLAG ( LOGPACKETSMASK ) ) ?1 : 0 ; pcr . rule . rtableid = - 1 ; pcr . rule . onrdomain = - 1 ; pcr . rule . quick = 1 ; pcr . rule . keep_state = PF_STATE_NORMAL ; if ( tag ) { strlcpy ( pcr . rule . tagname , tag , PF_TAG_NAME_SIZE ) ; } strlcpy ( pcr . rule . label , desc , PF_RULE_LABEL_SIZE ) ; if ( rhost && rhost [ 0 ] != '\0' && rhost [ 0 ] != '*' ) { inet_pton ( AF_INET , rhost , & pcr . rule . src . addr . v . a . addr . v4addr . s_addr ) ; pcr . rule . src . addr . v . a . mask . v4addr . s_addr = htonl ( INADDR_NONE ) ; inet_pton ( AF_INET , rhost , & pcr . rule . src . addr . v . a . addr . v4 . s_addr ) ; pcr . rule . src . addr . v . a . mask . v4 . s_addr = htonl ( INADDR_NONE ) ; } if ( use_ext_ip_addr && use_ext_ip_addr [ 0 ] != '\0' ) { inet_pton ( AF_INET , use_ext_ip_addr , & pcr . rule . dst . addr . v . a . addr . v4addr . s_addr ) ; pcr . rule . dst . addr . v . a . mask . v4addr . s_addr = htonl ( INADDR_NONE ) ; inet_pton ( AF_INET , use_ext_ip_addr , & pcr . rule . dst . addr . v . a . addr . v4 . s_addr ) ; pcr . rule . dst . addr . v . a . mask . v4 . s_addr = htonl ( INADDR_NONE ) ; } pcr . rule . rpool . proxy_port [ 0 ] = iport ; pcr . rule . rpool . proxy_port [ 1 ] = iport ; TAILQ_INIT ( & pcr . rule . rpool . list ) ; a = calloc ( 1 , sizeof ( pf_pooladdr ) ) ; inet_pton ( AF_INET , iaddr , & a -> addr . v . a . addr . v4addr . s_addr ) ; a -> addr . v . a . mask . v4addr . s_addr = htonl ( INADDR_NONE ) ; inet_pton ( AF_INET , iaddr , & a -> addr . v . a . addr . v4 . s_addr ) ; a -> addr . v . a . mask . v4 . s_addr = htonl ( INADDR_NONE ) ; TAILQ_INSERT_TAIL ( & pcr . rule . rpool . list , a , entries ) ; memcpy ( & pp . addr , a , sizeof ( pf_pooladdr ) ) ; if ( ioctl ( dev , DIOCADDADDR , & pp ) < 0 ) { syslog ( LOG_ERR , "ioctl(dev, DIOCADDADDR, ...): %m" ) ; r = - 1 ; } else { pcr . rule . rdr . proxy_port [ 0 ] = iport ; pcr . rule . rdr . proxy_port [ 1 ] = iport ; inet_pton ( AF_INET , iaddr , & pcr . rule . rdr . addr . v . a . addr . v4 . s_addr ) ; pcr . rule . rdr . addr . v . a . mask . v4 . s_addr = htonl ( INADDR_NONE ) ; if ( 1 ) { pcr . action = PF_CHANGE_GET_TICKET ; if ( ioctl ( dev , DIOCCHANGERULE , & pcr ) < 0 ) { syslog ( LOG_ERR , "ioctl(dev, DIOCCHANGERULE, ...) PF_CHANGE_GET_TICKET: %m" ) ; r = - 1 ; } else { pcr . action = PF_CHANGE_ADD_TAIL ; if ( ioctl ( dev , DIOCCHANGERULE , & pcr ) < 0 ) { syslog ( LOG_ERR , "ioctl(dev, DIOCCHANGERULE, ...) PF_CHANGE_ADD_TAIL: %m" ) ; r = - 1 ; } } } free ( a ) ; } if ( r == 0 && timestamp > 0 ) { add_timestamp_entry ( eport , proto , timestamp ) ; } if ( r == 0 && proto == IPPROTO_UDP ) { add_nat_rule ( ifname , rhost , eport , iaddr , iport , proto , desc ) ; } return r ; } } } 