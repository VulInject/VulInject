static int sc_parse_ef_atr_content ( struct sc_card * card , unsigned char * buf , size_t buflen ) { struct sc_context * ctx = card -> ctx ; const unsigned char * tag = NULL ; size_t taglen ; struct sc_ef_atr ef_atr ; LOG_FUNC_CALLED ( ctx ) ; tag = sc_asn1_find_tag ( ctx , buf , buflen , ISO7816_TAG_II_CARD_SERVICE , & taglen ) ; if ( tag && taglen >= 1 ) { ef_atr . card_service = * tag ; sc_log ( ctx , "EF.ATR: card service 0x%X" , ef_atr . card_service ) ; } tag = sc_asn1_find_tag ( ctx , buf , buflen , ISO7816_TAG_II_PRE_ISSUING , & taglen ) ; if ( tag ) { size_t len = taglen > sizeof ( ef_atr . pre_issuing ) ?sizeof ( ef_atr . pre_issuing ) : taglen ; memcpy ( ef_atr . pre_issuing , tag , len ) ; ef_atr . pre_issuing_len = len ; sc_log ( ctx , "EF.ATR: Pre-Issuing data '%s'" , sc_dump_hex ( ef_atr . pre_issuing , ef_atr . pre_issuing_len ) ) ; } tag = sc_asn1_find_tag ( ctx , buf , buflen , ISO7816_TAG_II_CARD_CAPABILITIES , & taglen ) ; if ( tag && taglen >= 3 ) { ef_atr . df_selection = * ( tag + 0 ) ; ef_atr . unit_size = * ( tag + 1 ) ; ef_atr . card_capabilities = * ( tag + 2 ) ; sc_log ( ctx , "EF.ATR: DF selection %X, unit_size %" SC_FORMAT_LEN_SIZE_T "X, card caps %X" , ef_atr . df_selection , ef_atr . unit_size , ef_atr . card_capabilities ) ; } if ( ef_atr . card_capabilities & ISO7816_CAP_EXTENDED_LENGTH_INFO ) { tag = sc_asn1_find_tag ( ctx , buf , buflen , ISO7816_TAG_II_EXTENDED_LENGTH , & taglen ) ; if ( tag && taglen >= 8 ) { ef_atr . max_command_apdu = bebytes2ushort ( tag + 2 ) ; ef_atr . max_response_apdu = bebytes2ushort ( tag + 6 ) ; sc_log ( ctx , "EF.ATR: Biggest command APDU %" SC_FORMAT_LEN_SIZE_T "u bytes, response APDU %" SC_FORMAT_LEN_SIZE_T "u" , ef_atr . max_command_apdu , ef_atr . max_response_apdu ) ; } } tag = sc_asn1_find_tag ( ctx , buf , buflen , ISO7816_TAG_II_AID , & taglen ) ; if ( tag ) { if ( taglen > sizeof ( ef_atr . aid . value ) ) { LOG_TEST_RET ( ctx , SC_ERROR_INVALID_DATA , "Invalid MF AID size" ) ; } memcpy ( ef_atr . aid . value , tag , taglen ) ; ef_atr . aid . len = taglen ; sc_log ( ctx , "EF.ATR: AID '%s'" , sc_dump_hex ( ef_atr . aid . value , ef_atr . aid . len ) ) ; } tag = sc_asn1_find_tag ( ctx , buf , buflen , IASECC_TAG_II_IO_BUFFER_SIZES , & taglen ) ; if ( tag ) { size_t len = taglen > sizeof ( ef_atr . issuer_data ) ?sizeof ( ef_atr . issuer_data ) : taglen ; memcpy ( ef_atr . issuer_data , tag , len ) ; ef_atr . issuer_data_len = len ; sc_log ( ctx , "EF.ATR: Issuer data '%s'" , sc_dump_hex ( ef_atr . issuer_data , ef_atr . issuer_data_len ) ) ; } tag = sc_asn1_find_tag ( ctx , buf , buflen , ISO7816_TAG_II_ALLOCATION_SCHEME , & taglen ) ; if ( tag ) { sc_log ( ctx , "EF.ATR: DER encoded OID %s" , sc_dump_hex ( tag , taglen ) ) ; tag = sc_asn1_find_tag ( ctx , tag , taglen , SC_ASN1_TAG_OBJECT , & taglen ) ; if ( tag ) { sc_log ( ctx , "EF.ATR: OID %s" , sc_dump_hex ( tag , taglen ) ) ; if ( sc_asn1_decode_object_id ( tag , taglen , & ef_atr . allocation_oid ) ) { LOG_FUNC_RETURN ( ctx , SC_ERROR_INVALID_ASN1_OBJECT ) ; } } } tag = sc_asn1_find_tag ( ctx , buf , buflen , ISO7816_TAG_II_STATUS_SW , & taglen ) ; if ( tag && taglen == 2 ) { ef_atr . status = * ( tag + 0 ) * 0x100 + * ( tag + 1 ) ; sc_log ( ctx , "EF.ATR: status word 0x%X" , ef_atr . status ) ; } if ( ! card -> ef_atr ) { card -> ef_atr = calloc ( 1 , sizeof ( sc_ef_atr ) ) ; } if ( ! card -> ef_atr ) { LOG_FUNC_RETURN ( ctx , SC_ERROR_OUT_OF_MEMORY ) ; } memcpy ( card -> ef_atr , & ef_atr , sizeof ( sc_ef_atr ) ) ; LOG_FUNC_RETURN ( ctx , SC_SUCCESS ) ; } 