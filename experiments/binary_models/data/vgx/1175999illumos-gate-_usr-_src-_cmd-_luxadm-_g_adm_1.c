size_t serial_len = sizeof ( inq80 . inq_serial ) ; if ( ( envdb = getenv ( "_LUX_T_DEBUG" ) ) != NULL ) { start_time = gethrtime ( ) ; } if ( err = g_get_inquiry ( phys_path , & inq ) ) { fprintf ( stderr , "\n" ) ; print_errString ( err , phys_path ) ; fprintf ( stderr , "\n" ) ; exit ( 1 ) ; } if ( err = g_get_serial_number ( phys_path , inq80 . inq_serial , & serial_len ) ) { fprintf ( stderr , "\n" ) ; print_errString ( err , phys_path ) ; fprintf ( stderr , "\n" ) ; exit ( 1 ) ; } peripheral_qual = inq . inq_dtype & ~ DTYPE_MASK ; if ( peripheral_qual != DPQ_POSSIBLE ) { fprintf ( stderr , MSGSTR ( 2254 , "\n Error: Logical Unit " "(%s) is not available.\n" ) , phys_path ) ; exit ( 1 ) ; } fprintf ( stdout , "  " ) ; fprintf ( stdout , MSGSTR ( 3 , "Vendor:" ) ) ; fprintf ( stdout , "\t\t" ) ; print_chars ( inq . inq_vid , sizeof ( inq . inq_vid ) , 0 ) ; fprintf ( stdout , MSGSTR ( 2115 , "\n  Product ID:\t\t" ) ) ; print_chars ( inq . inq_pid , sizeof ( inq . inq_pid ) , 0 ) ; fprintf ( stdout , "\n  " ) ; fprintf ( stdout , MSGSTR ( 2119 , "Revision:" ) ) ; fprintf ( stdout , "\t\t" ) ; print_chars ( inq . inq_revision , sizeof ( inq . inq_revision ) , 0 ) ; fprintf ( stdout , "\n  " ) ; fprintf ( stdout , MSGSTR ( 17 , "Serial Num:" ) ) ; fprintf ( stdout , "\t\t" ) ; print_chars ( inq80 . inq_serial , serial_len , 0 ) ; if ( ( inq . inq_dtype & DTYPE_MASK ) == DTYPE_DIRECT ) { if ( ( err = get_lun_capacity ( phys_path , & cap_data ) ) != 0 ) { print_errString ( err , phys_path ) ; exit ( 1 ) ; } if ( cap_data . sc_capacity > 0 && cap_data . sc_lbasize > 0 ) { lunMbytes = cap_data . sc_capacity + 1 ; lunMbytes *= cap_data . sc_lbasize ; lunMbytes /= ( float ) ( 1024 * 1024 ) ; fprintf ( stdout , "\n  " ) ; fprintf ( stdout , MSGSTR ( 60 , "Unformatted capacity:\t%6.3f MBytes" ) , lunMbytes ) ; } } fprintf ( stdout , "\n" ) ; if ( ( mode_data_avail ) && ( pg_hdr -> code == MODEPAGE_CACHING ) ) { pg8_buf = ( my_mode_caching * ) ( void * ) pg_hdr ; if ( pg8_buf -> wce ) { fprintf ( stdout , MSGSTR ( 2122 , "  Write Cache:\t\t" "Enabled\n" ) ) ; } if ( pg8_buf -> rcd == 0 ) { fprintf ( stdout , MSGSTR ( 2123 , "  Read Cache:\t\t" "Enabled\n" ) ) ; fprintf ( stdout , MSGSTR ( 2124 , "    Minimum prefetch:" "\t0x%x\n    Maximum prefetch:\t0x%x\n" ) , pg8_buf -> min_prefetch , pg8_buf -> max_prefetch ) ; } } fprintf ( stdout , "  %s\t\t%s\n" , MSGSTR ( 35 , "Device Type:" ) , dtype [ inq . inq_dtype & DTYPE_MASK ] ) ; fprintf ( stdout , MSGSTR ( 2128 , "  Path(s):\n" ) ) ; fprintf ( stdout , "\n" ) ; if ( ( mlist = l_disk_state . g_disk_state . multipath_list ) == NULL ) { fprintf ( stderr , MSGSTR ( 2323 , "Error: No paths found (%s)" ) , path_struct -> argv ) ; exit ( 1 ) ; } if ( strstr ( mlist -> dev_path , SCSI_VHCI ) != NULL ) { fprintf ( stdout , "  %s\n  %s\n" , mlist -> logical_path , mlist -> dev_path ) ; adm_print_pathlist ( mlist -> dev_path ) ; } else { for ( mlist = l_disk_state . g_disk_state . multipath_list ; mlist != NULL ; mlist = mlist -> next ) { if ( ( strcmp ( mlist -> dev_path , path_struct -> p_physical_path ) ) == 0 ) { display_path_info ( mlist -> dev_path , mlist -> logical_path , wwn_list ) ; break ; } } for ( mlist = l_disk_state . g_disk_state . multipath_list ; mlist != NULL ; mlist = mlist -> next ) { if ( ( strcmp ( mlist -> dev_path , path_struct -> p_physical_path ) ) == 0 ) { continue ; } if ( err = g_get_inquiry ( mlist -> dev_path , & inq ) ) { fprintf ( stderr , "\n" ) ; print_errString ( err , mlist -> dev_path ) ; fprintf ( stderr , "\n" ) ; exit ( 1 ) ; } display_path_info ( mlist -> dev_path , mlist -> logical_path , wwn_list ) ; } } fprintf ( stdout , "\n" ) ; if ( envdb != NULL ) { end_time = gethrtime ( ) ; fprintf ( stdout , "      display_lun_info: " "\t\tTime = %lld millisec\n" , ( end_time - start_time ) / 1000000 ) ; } 