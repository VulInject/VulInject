CK_RV object_create ( CK_ATTRIBUTE * pTemplate , CK_ULONG ulCount , OBJECT * * obj ) { OBJECT * o = NULL ; CK_ATTRIBUTE * attr = NULL ; CK_ATTRIBUTE * sensitive = NULL ; CK_ATTRIBUTE * extractable = NULL ; CK_ATTRIBUTE * local = NULL ; CK_BBOOL class_given = FALSE ; CK_BBOOL subclass_given = FALSE ; CK_BBOOL flag ; CK_ULONG class , subclass = 0xFFFFFFFF ; CK_RV rc ; unsigned int i ; attr = pTemplate ; for ( i = 0 ; i < ulCount ; i ++ , attr ++ ) { if ( attr -> type == CKA_CLASS ) { class = * ( CK_OBJECT_CLASS * ) attr -> pValue ; class_given = TRUE ; } if ( attr -> type == CKA_CERTIFICATE_TYPE ) { subclass = * ( CK_CERTIFICATE_TYPE * ) attr -> pValue ; subclass_given = TRUE ; } if ( attr -> type == CKA_KEY_TYPE ) { subclass = * ( CK_KEY_TYPE * ) attr -> pValue ; subclass_given = TRUE ; } if ( attr -> type == CKA_HW_FEATURE_TYPE ) { subclass = * ( CK_HW_FEATURE_TYPE * ) attr -> pValue ; subclass_given = TRUE ; } } if ( class_given == FALSE ) { return ( CKR_TEMPLATE_INCOMPLETE ) ; } if ( class != CKO_DATA && subclass_given != TRUE ) { return ( CKR_TEMPLATE_INCOMPLETE ) ; } rc = object_create_skel ( pTemplate , ulCount , MODE_CREATE , class , subclass , & o ) ; if ( rc != CKR_OK ) { return ( rc ) ; } if ( class == CKO_PRIVATE_KEY || class == CKO_SECRET_KEY ) { rc = template_attribute_find ( , , ) ; if ( rc == FALSE ) { rc = CKR_FUNCTION_FAILED ; error } flag = * ( CK_BBOOL * ) attr -> pValue ; rc = build_attribute ( CKA_ALWAYS_SENSITIVE , & flag , sizeof ( CK_BYTE ) , & sensitive ) ; if ( rc != CKR_OK ) { error } rc = template_attribute_find ( , , ) ; if ( rc == FALSE ) { rc = CKR_FUNCTION_FAILED ; error } flag = * ( CK_BBOOL * ) attr -> pValue ; flag = ( ~ flag ) & 0x1 ; rc = build_attribute ( CKA_NEVER_EXTRACTABLE , & flag , sizeof ( CK_BYTE ) , & extractable ) ; if ( rc != CKR_OK ) { error } ( void ) template_update_attribute ( , ) ; ( void ) template_update_attribute ( , ) ; } * obj = o ; return ( CKR_OK ) ; error if ( sensitive ) { free ( sensitive ) ; } if ( extractable ) { free ( extractable ) ; } if ( local ) { free ( local ) ; } ( void ) object_free ( o ) ; return ( rc ) ; } 