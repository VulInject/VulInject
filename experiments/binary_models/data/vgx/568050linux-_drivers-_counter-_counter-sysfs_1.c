static ssize_t counter_comp_u32_show ( struct device * dev , struct device_attribute * attr , char * buf ) { const struct counter_attribute * const a = to_counter_attribute ( attr ) ; struct counter_device * const counter = counter_from_dev ( dev ) ; const struct counter_available * const avail = a -> comp . priv ; int err ; u32 data = 0 ; switch ( a -> scope ) { case COUNTER_SCOPE_DEVICE : err = a -> comp . device_u32_read ( counter , & data ) ; break ; case COUNTER_SCOPE_SIGNAL : err = a -> comp . signal_u32_read ( counter , a -> parent , & data ) ; break ; case COUNTER_SCOPE_COUNT : if ( a -> comp . type == COUNTER_COMP_SYNAPSE_ACTION ) { err = a -> comp . action_read ( counter , a -> parent , a -> comp . priv , & data ) ; } else { err = a -> comp . count_u32_read ( counter , a -> parent , & data ) ; } break ; default : return - EINVAL ; } switch ( a -> comp . type ) { case COUNTER_COMP_FUNCTION : return sysfs_emit ( buf , "%s\n" , counter_function_str [ data ] ) ; case COUNTER_COMP_SIGNAL_LEVEL : return sysfs_emit ( buf , "%s\n" , counter_signal_value_str [ data ] ) ; case COUNTER_COMP_SYNAPSE_ACTION : return sysfs_emit ( buf , "%s\n" , counter_synapse_action_str [ data ] ) ; case COUNTER_COMP_ENUM : return sysfs_emit ( buf , "%s\n" , avail -> strs [ data ] ) ; case COUNTER_COMP_COUNT_DIRECTION : return sysfs_emit ( buf , "%s\n" , counter_count_direction_str [ data ] ) ; case COUNTER_COMP_COUNT_MODE : return sysfs_emit ( buf , "%s\n" , counter_count_mode_str [ data ] ) ; case COUNTER_COMP_SIGNAL_POLARITY : return sysfs_emit ( buf , "%s\n" , counter_signal_polarity_str [ data ] ) ; default : return sysfs_emit ( buf , "%u\n" , ( unsigned int ) data ) ; } } 