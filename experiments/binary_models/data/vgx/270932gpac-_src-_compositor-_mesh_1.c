void mesh_new_elevation_grid ( GF_Mesh * mesh , GF_Node * node ) { u32 i , j , face_count , pt_count , zDimension , xDimension , cur_face , idx , pt_idx ; Bool has_normal , has_txcoord , has_color , smooth_normals ; GF_Mesh * * faces ; GF_Vertex vx ; SFVec3f v1 , v2 , n ; struct face_info * faces_info ; struct pt_info * pts_info ; M_ElevationGrid * eg = ( M_ElevationGrid * ) node ; M_Normal * norm = ( M_Normal * ) eg -> normal ; M_Color * colorRGB = ( M_Color * ) eg -> color ; X_ColorRGBA * colorRGBA = ( X_ColorRGBA * ) eg -> color ; SFColorRGBA rgba ; M_TextureCoordinate * txc = ( M_TextureCoordinate * ) eg -> texCoord ; mesh_reset ( mesh ) ; if ( ! eg -> height . count || ( eg -> xDimension < 2 ) || ( eg -> zDimension < 2 ) ) { return ; } memset ( & rgba , 0 , sizeof ( SFColorRGBA ) ) ; has_txcoord = txc ?txc -> point . count : 0 ; has_normal = norm ?norm -> vector . count : 0 ; has_color = 0 ; if ( eg -> color ) { if ( gf_node_get_tag ( eg -> color ) == TAG_X3D_ColorRGBA ) { colorRGB = NULL ; has_color = colorRGBA -> color . count ?1 : 0 ; } else { colorRGBA = NULL ; has_color = colorRGB -> color . count ?1 : 0 ; } } face_count = ( eg -> xDimension - 1 ) * ( eg -> zDimension - 1 ) ; pt_count = eg -> xDimension * eg -> zDimension ; if ( pt_count > eg -> height . count ) { return ; } smooth_normals = ( ! has_normal && ( eg -> creaseAngle > FIX_EPSILON ) ) ?1 : 0 ; faces = NULL ; faces_info = NULL ; pts_info = NULL ; zDimension = ( u32 ) eg -> zDimension ; xDimension = ( u32 ) eg -> xDimension ; cur_face = 0 ; pt_idx = 0 ; if ( ! smooth_normals && ! has_color && ! has_normal && ! has_txcoord ) { for ( j = 0 ; j < zDimension ; j ++ ) { for ( i = 0 ; i < xDimension ; i ++ ) { vx . pos . z = eg -> zSpacing * j ; vx . pos . y = eg -> height . vals [ i + j * xDimension ] ; vx . pos . x = eg -> xSpacing * i ; vx . texcoords . x = INT2FIX ( i ) / ( xDimension - 1 ) ; vx . texcoords . y = INT2FIX ( j ) / ( zDimension - 1 ) ; mesh_set_vertex_vx ( mesh , & vx ) ; } } for ( j = 0 ; j < zDimension - 1 ; j ++ ) { u32 z0 = ( j ) * xDimension ; u32 z1 = ( j + 1 ) * xDimension ; for ( i = 0 ; i < xDimension - 1 ; i ++ ) { mesh_set_triangle ( mesh , i + z0 , i + z1 , i + z1 + 1 ) ; mesh_set_triangle ( mesh , i + z0 , i + z1 + 1 , i + z0 + 1 ) ; gf_vec_diff ( v1 , mesh -> vertices [ i + z0 ] . pos , mesh -> vertices [ i + z0 + 1 ] . pos ) ; gf_vec_diff ( v2 , mesh -> vertices [ i + z1 + 1 ] . pos , mesh -> vertices [ i + z0 + 1 ] . pos ) ; n = gf_vec_cross ( v1 , v2 ) ; gf_vec_norm ( & n ) ; MESH_SET_NORMAL ( mesh -> vertices [ i + z0 ] , n ) ; MESH_SET_NORMAL ( mesh -> vertices [ i + z0 + 1 ] , n ) ; MESH_SET_NORMAL ( mesh -> vertices [ i + z1 ] , n ) ; MESH_SET_NORMAL ( mesh -> vertices [ i + z1 + 1 ] , n ) ; } } mesh -> mesh_type = MESH_TRIANGLES ; mesh_update_bounds ( mesh ) ; if ( ! eg -> ccw ) { mesh -> flags |= MESH_IS_CW ; } if ( eg -> solid ) { mesh -> flags |= MESH_IS_SOLID ; } gf_mesh_build_aabbtree ( mesh ) ; return ; } if ( smooth_normals ) { faces = ( GF_Mesh * * ) gf_malloc ( sizeof ( GF_Mesh * ) * face_count ) ; if ( ! faces ) { return ; } faces_info = ( face_info * ) gf_malloc ( sizeof ( face_info ) * face_count ) ; if ( ! faces_info ) { return ; } memset ( faces_info , 0 , sizeof ( face_info ) * face_count ) ; pts_info = ( pt_info * ) gf_malloc ( sizeof ( pt_info ) * pt_count ) ; if ( ! pts_info ) { return ; } memset ( pts_info , 0 , sizeof ( pt_info ) * pt_count ) ; faces [ cur_face ] = new_mesh ( ) ; if ( ! faces [ cur_face ] ) { return ; } } for ( j = 0 ; j < zDimension - 1 ; j ++ ) { for ( i = 0 ; i < xDimension - 1 ; i ++ ) { u32 k , l ; if ( has_color && ! eg -> colorPerVertex ) { idx = i + j * ( xDimension - 1 ) ; MESH_GET_COL ( rgba , idx ) ; vx . color = MESH_MAKE_COL ( rgba ) ; } if ( has_normal && ! eg -> normalPerVertex ) { idx = i + j * ( xDimension - 1 ) ; if ( idx < norm -> vector . count ) { n = norm -> vector . vals [ idx ] ; gf_vec_norm ( & n ) ; MESH_SET_NORMAL ( vx , n ) ; } } for ( k = 0 ; k < 2 ; k ++ ) { vx . pos . z = eg -> zSpacing * ( j + k ) ; for ( l = 0 ; l < 2 ; l ++ ) { vx . pos . y = eg -> height . vals [ ( i + l ) + ( j + k ) * xDimension ] ; vx . pos . x = eg -> xSpacing * ( i + l ) ; if ( has_color && eg -> colorPerVertex ) { idx = i + l + ( j + k ) * xDimension ; MESH_GET_COL ( rgba , idx ) ; vx . color = MESH_MAKE_COL ( rgba ) ; } if ( ! has_txcoord ) { vx . texcoords . x = INT2FIX ( i + l ) / ( xDimension - 1 ) ; vx . texcoords . y = INT2FIX ( j + k ) / ( zDimension - 1 ) ; } else { idx = ( i + l ) + ( j + k ) * xDimension ; if ( idx < txc -> point . count ) { vx . texcoords = txc -> point . vals [ idx ] ; } } if ( has_normal && eg -> normalPerVertex ) { idx = ( i + l ) + ( j + k ) * xDimension ; if ( idx < norm -> vector . count ) { n = norm -> vector . vals [ idx ] ; gf_vec_norm ( & n ) ; MESH_SET_NORMAL ( vx , n ) ; } } if ( smooth_normals ) { mesh_set_vertex_vx ( faces [ cur_face ] , & vx ) ; register_point_in_face ( & faces_info [ cur_face ] , ( i + l ) + ( j + k ) * xDimension ) ; register_face_in_point ( & pts_info [ ( i + l ) + ( j + k ) * xDimension ] , cur_face ) ; } else { mesh_set_vertex_vx ( mesh , & vx ) ; } } } if ( smooth_normals ) { mesh_set_triangle ( faces [ cur_face ] , 0 , 2 , 3 ) ; mesh_set_triangle ( faces [ cur_face ] , 0 , 3 , 1 ) ; gf_vec_diff ( v1 , faces [ cur_face ] -> vertices [ 0 ] . pos , faces [ cur_face ] -> vertices [ 1 ] . pos ) ; gf_vec_diff ( v2 , faces [ cur_face ] -> vertices [ 3 ] . pos , faces [ cur_face ] -> vertices [ 1 ] . pos ) ; faces_info [ cur_face ] . nor = gf_vec_cross ( v1 , v2 ) ; gf_vec_norm ( & faces_info [ cur_face ] . nor ) ; cur_face ++ ; if ( cur_face < face_count ) { faces [ cur_face ] = new_mesh ( ) ; if ( ! faces [ cur_face ] ) { return ; } } } else { mesh_set_triangle ( mesh , pt_idx + 0 , pt_idx + 2 , pt_idx + 3 ) ; mesh_set_triangle ( mesh , pt_idx + 0 , pt_idx + 3 , pt_idx + 1 ) ; if ( ! has_normal ) { gf_vec_diff ( v1 , mesh -> vertices [ pt_idx + 0 ] . pos , mesh -> vertices [ pt_idx + 1 ] . pos ) ; gf_vec_diff ( v2 , mesh -> vertices [ pt_idx + 3 ] . pos , mesh -> vertices [ pt_idx + 1 ] . pos ) ; n = gf_vec_cross ( v1 , v2 ) ; gf_vec_norm ( & n ) ; MESH_SET_NORMAL ( mesh -> vertices [ pt_idx + 0 ] , n ) ; MESH_SET_NORMAL ( mesh -> vertices [ pt_idx + 1 ] , n ) ; MESH_SET_NORMAL ( mesh -> vertices [ pt_idx + 2 ] , n ) ; MESH_SET_NORMAL ( mesh -> vertices [ pt_idx + 3 ] , n ) ; } pt_idx += 4 ; } } } if ( smooth_normals ) { Fixed cosCrease ; if ( eg -> creaseAngle > GF_PI ) { cosCrease = - FIX_ONE ; } else { cosCrease = gf_cos ( eg -> creaseAngle ) ; } for ( i = 0 ; i < face_count ; i ++ ) { for ( j = 0 ; j < faces [ i ] -> v_count ; j ++ ) { n = smooth_face_normals ( pts_info , pt_count , faces_info , face_count , j , i , cosCrease ) ; MESH_SET_NORMAL ( faces [ i ] -> vertices [ j ] , n ) ; } } if ( faces_info ) { for ( i = 0 ; i < face_count ; i ++ ) { if ( faces_info [ i ] . idx ) { gf_free ( faces_info [ i ] . idx ) ; } } gf_free ( faces_info ) ; } if ( pts_info ) { for ( i = 0 ; i < pt_count ; i ++ ) { if ( pts_info [ i ] . faces ) { gf_free ( pts_info [ i ] . faces ) ; } } gf_free ( pts_info ) ; } mesh -> flags |= MESH_IS_SMOOTHED ; for ( i = 0 ; i < face_count ; i ++ ) { if ( faces [ i ] -> v_count ) { u32 init_idx ; GF_Mesh * face = faces [ i ] ; init_idx = mesh -> v_count ; mesh_set_vertex_vx ( mesh , & face -> vertices [ 0 ] ) ; mesh_set_vertex_vx ( mesh , & face -> vertices [ 1 ] ) ; mesh_set_vertex_vx ( mesh , & face -> vertices [ 2 ] ) ; mesh_set_vertex_vx ( mesh , & face -> vertices [ 3 ] ) ; mesh_set_triangle ( mesh , init_idx , init_idx + 2 , init_idx + 3 ) ; mesh_set_triangle ( mesh , init_idx , init_idx + 3 , init_idx + 1 ) ; } mesh_free ( faces [ i ] ) ; } gf_free ( faces ) ; } mesh -> mesh_type = MESH_TRIANGLES ; if ( has_color ) { mesh -> flags |= MESH_HAS_COLOR ; } mesh_update_bounds ( mesh ) ; if ( ! eg -> ccw ) { mesh -> flags |= MESH_IS_CW ; } if ( eg -> solid ) { mesh -> flags |= MESH_IS_SOLID ; } if ( colorRGBA ) { mesh -> flags |= MESH_HAS_ALPHA ; } gf_mesh_build_aabbtree ( mesh ) ; } 