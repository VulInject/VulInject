cfga_err_t cfga_change_state ( cfga_cmd_t state_change_cmd , const char * ap_id , const char * options , struct cfga_confirm * confp , struct cfga_msg * msgp , char * * errstring , cfga_flags_t flags ) { int rv , state , new_state ; uint_t hpflags = 0 ; hp_node_t node ; hp_node_t results = NULL ; if ( ( rv = check_options ( options ) ) != CFGA_OK ) { return ( rv ) ; } if ( errstring != NULL ) { * errstring = NULL ; } rv = CFGA_OK ; DBG ( 1 , ( "cfga_change_state:(%s)\n" , ap_id ) ) ; rv = physpath2node ( ap_id , errstring , & node ) ; if ( flags & CFGA_FLAG_FORCE ) { hpflags |= HPFORCE ; } state = hp_state ( node ) ; if ( ( state_change_cmd != CFGA_CMD_LOAD ) && ( state_change_cmd != CFGA_CMD_UNLOAD ) ) { if ( cfga_target_state ( state_change_cmd , & new_state ) != CFGA_OK ) { hp_fini ( node ) ; return ( CFGA_ERROR ) ; } } DBG ( 1 , ( "cfga_change_state: state is %d\n" , state ) ) ; switch ( state_change_cmd ) { case CFGA_CMD_CONNECT : DBG ( 1 , ( "connect\n" ) ) ; if ( state == DDI_HP_CN_STATE_EMPTY ) { cfga_err ( errstring , ERR_AP_ERR , 0 ) ; rv = CFGA_INVAL ; } if ( state == DDI_HP_CN_STATE_PRESENT ) { if ( hp_set_state ( node , 0 , new_state , & results ) != 0 ) { rv = CFGA_ERROR ; cfga_err ( errstring , CMD_SLOT_CONNECT , 0 ) ; } } break ; case CFGA_CMD_DISCONNECT : DBG ( 1 , ( "disconnect\n" ) ) ; if ( state == DDI_HP_CN_STATE_EMPTY ) { cfga_err ( errstring , ERR_AP_ERR , 0 ) ; rv = CFGA_INVAL ; } if ( state > DDI_HP_CN_STATE_PRESENT ) { rv = hp_set_state ( node , hpflags , new_state , & results ) ; if ( rv != 0 ) { if ( rv == EBUSY ) { rv = CFGA_BUSY ; } else { rv = CFGA_ERROR ; } if ( results ) { pci_rcm_info_table ( results , errstring ) ; hp_fini ( results ) ; } else { cfga_err ( errstring , CMD_SLOT_DISCONNECT , 0 ) ; } } } break ; case CFGA_CMD_CONFIGURE : DBG ( 1 , ( "configure\n" ) ) ; if ( state == DDI_HP_CN_STATE_EMPTY ) { cfga_err ( errstring , ERR_AP_ERR , 0 ) ; rv = CFGA_INVAL ; } if ( hp_set_state ( node , 0 , new_state , & results ) != 0 ) { rv = CFGA_ERROR ; cfga_err ( errstring , CMD_SLOT_CONFIGURE , 0 ) ; } break ; case CFGA_CMD_UNCONFIGURE : DBG ( 1 , ( "unconfigure\n" ) ) ; if ( state == DDI_HP_CN_STATE_EMPTY ) { cfga_err ( errstring , ERR_AP_ERR , 0 ) ; rv = CFGA_INVAL ; } if ( state >= DDI_HP_CN_STATE_ENABLED ) { rv = hp_set_state ( node , hpflags , new_state , & results ) ; if ( rv != 0 ) { if ( rv == EBUSY ) { rv = CFGA_BUSY ; } else { rv = CFGA_ERROR ; } if ( results ) { pci_rcm_info_table ( results , errstring ) ; hp_fini ( results ) ; } else { cfga_err ( errstring , CMD_SLOT_UNCONFIGURE , 0 ) ; } } } DBG ( 1 , ( "unconfigure rv:(%i)\n" , rv ) ) ; break ; case CFGA_CMD_LOAD : if ( state < DDI_HP_CN_STATE_POWERED ) { rv = CFGA_ERROR ; cfga_err ( errstring , CMD_SLOT_INSERT , 0 ) ; } else { cfga_err ( errstring , ERR_AP_ERR , 0 ) ; rv = CFGA_INVAL ; } break ; case CFGA_CMD_UNLOAD : if ( state < DDI_HP_CN_STATE_POWERED ) { rv = CFGA_ERROR ; cfga_err ( errstring , CMD_SLOT_REMOVE , 0 ) ; } else { cfga_err ( errstring , ERR_AP_ERR , 0 ) ; rv = CFGA_INVAL ; } break ; default : rv = CFGA_OPNOTSUPP ; break ; } hp_fini ( node ) ; return ( rv ) ; } 