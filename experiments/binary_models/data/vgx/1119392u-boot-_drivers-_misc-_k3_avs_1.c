static int k3_avs_probe ( struct udevice * dev ) { int opp_id ; u32 volt ; struct opp * opp ; struct k3_avs_privdata * priv ; struct vd_data * vd ; int ret ; priv = dev_get_priv ( dev ) ; k3_avs_priv = priv ; ret = k3_avs_configure ( dev , priv ) ; if ( ret ) { return ret ; } priv -> base = dev_read_addr_ptr ( dev ) ; if ( ! priv -> base ) { return - ENODEV ; } for ( vd = priv -> vd_config -> vds ; vd -> id >= 0 ; vd ++ ) { if ( ! ( readl ( AM6_VTM_DEVINFO ( vd -> id ) ) & AM6_VTM_AVS0_SUPPORTED ) ) { dev_warn ( dev , "AVS-class 0 not supported for VD%d\n" , vd -> id ) ; continue ; } for ( opp_id = 0 ; opp_id < NUM_OPPS ; opp_id ++ ) { opp = & vd -> opps [ opp_id ] ; volt = priv -> vd_config -> efuse_xlate ( priv , vd -> id , opp_id ) ; if ( volt ) { opp -> volt = volt ; } } } for ( vd = priv -> vd_config -> vds ; vd -> id >= 0 ; vd ++ ) { if ( vd -> flags & VD_FLAG_INIT_DONE ) { continue ; } k3_avs_program_voltage ( priv , vd , vd -> opp ) ; } return 0 ; } static struct vd_data am654_vd_data [ ] { { . id = AM6_VDD_CORE . dev_id = 82 . clk_id = 0 . opp = AM6_OPP_NOM . opps = { [ AM6_OPP_NOM ] = { . volt = 1000000 . freq = 250000000 } } } { . id = AM6_VDD_MPU0 . dev_id = 202 . clk_id = 0 . opp = AM6_OPP_NOM . opps = { [ AM6_OPP_NOM ] = { . volt = 1100000 . freq = 800000000 } [ AM6_OPP_OD ] = { . volt = 1200000 . freq = 1000000000 } [ AM6_OPP_TURBO ] = { . volt = 1240000 . freq = 1100000000 } } } { . id = AM6_VDD_MPU1 . opp = AM6_OPP_NOM . dev_id = 204 . clk_id = 0 . opps = { [ AM6_OPP_NOM ] = { . volt = 1100000 . freq = 800000000 } [ AM6_OPP_OD ] = { . volt = 1200000 . freq = 1000000000 } [ AM6_OPP_TURBO ] = { . volt = 1240000 . freq = 1100000000 } } } { . id = - 1 } } ; ; 