static int nfp_abm_spawn_repr ( struct nfp_app * app , struct nfp_abm_link * alink , enum nfp_port_type ptype ) { struct net_device * netdev ; enum nfp_repr_type rtype ; struct nfp_reprs * reprs ; struct nfp_repr * repr ; struct nfp_port * port ; unsigned int txqs ; int err ; if ( ptype == NFP_PORT_PHYS_PORT ) { rtype = NFP_REPR_TYPE_PHYS_PORT ; txqs = 1 ; } else { rtype = NFP_REPR_TYPE_PF ; txqs = alink -> vnic -> max_rx_rings ; } netdev = nfp_repr_alloc_mqs ( app , txqs , 1 ) ; repr = netdev_priv ( netdev ) ; repr -> app_priv = alink ; port = nfp_port_alloc ( app , ptype , netdev ) ; if ( IS_ERR ( port ) ) { err = PTR_ERR ( port ) ; err_free_repr } if ( ptype == NFP_PORT_PHYS_PORT ) { port -> eth_forced = true ; err = nfp_port_init_phy_port ( app -> pf , app , port , alink -> id ) ; if ( err ) { err_free_port } } else { port -> pf_id = alink -> abm -> pf_id ; port -> pf_split = app -> pf -> max_data_vnics > 1 ; port -> pf_split_id = alink -> id ; port -> vnic = alink -> vnic -> dp . ctrl_bar ; } SET_NETDEV_DEV ( netdev , & alink -> vnic -> pdev -> dev ) ; eth_hw_addr_random ( netdev ) ; err = nfp_repr_init ( app , netdev , nfp_abm_portid ( rtype , alink -> id ) , port , alink -> vnic -> dp . netdev ) ; if ( err ) { err_free_port } reprs = nfp_reprs_get_locked ( app , rtype ) ; WARN ( nfp_repr_get_locked ( app , reprs , alink -> id ) , "duplicate repr" ) ; rtnl_lock ( ) ; rcu_assign_pointer ( reprs -> reprs [ alink -> id ] , netdev ) ; rtnl_unlock ( ) ; nfp_info ( app -> cpp , "%s Port %d Representor(%s) created\n" , ptype == NFP_PORT_PF_PORT ?"PCIe" : "Phys" , alink -> id , netdev -> name ) ; return 0 ; err_free_port nfp_port_free ( port ) ; err_free_repr nfp_repr_free ( netdev ) ; return err ; } 