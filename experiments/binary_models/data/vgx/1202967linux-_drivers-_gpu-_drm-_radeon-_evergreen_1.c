static u32 evergreen_latency_watermark ( struct evergreen_wm_params * wm ) { u32 mc_latency = 2000 ; u32 available_bandwidth = evergreen_available_bandwidth ( wm ) ; u32 worst_chunk_return_time = ( 512 * 8 * 1000 ) / available_bandwidth ; u32 cursor_line_pair_return_time = ( 128 * 4 * 1000 ) / available_bandwidth ; u32 dc_latency = 40000000 / wm -> disp_clk ; u32 other_heads_data_return_time = ( ( wm -> num_heads + 1 ) * worst_chunk_return_time ) + ( wm -> num_heads * cursor_line_pair_return_time ) ; u32 latency = mc_latency + other_heads_data_return_time + dc_latency ; u32 max_src_lines_per_dst_line , lb_fill_bw , line_fill_time ; fixed20_12 a , b , c ; a . full = dfixed_const ( 2 ) ; b . full = dfixed_const ( 1 ) ; if ( ( wm -> vsc . full > a . full ) || ( ( wm -> vsc . full > b . full ) && ( wm -> vtaps >= 3 ) ) || ( wm -> vtaps >= 5 ) || ( ( wm -> vsc . full >= a . full ) && wm -> interlaced ) ) { max_src_lines_per_dst_line = 4 ; } else { max_src_lines_per_dst_line = 2 ; } a . full = dfixed_const ( available_bandwidth ) ; b . full = dfixed_const ( wm -> num_heads ) ; a . full = dfixed_div ( a , b ) ; lb_fill_bw = min ( dfixed_trunc ( a ) , wm -> disp_clk * wm -> bytes_per_pixel / 1000 ) ; a . full = dfixed_const ( max_src_lines_per_dst_line * wm -> src_width * wm -> bytes_per_pixel ) ; b . full = dfixed_const ( 1000 ) ; c . full = dfixed_const ( lb_fill_bw ) ; b . full = dfixed_div ( c , b ) ; a . full = dfixed_div ( a , b ) ; line_fill_time = dfixed_trunc ( a ) ; if ( line_fill_time < wm -> active_time ) { return latency ; } else { return latency + ( line_fill_time - wm -> active_time ) ; } } 