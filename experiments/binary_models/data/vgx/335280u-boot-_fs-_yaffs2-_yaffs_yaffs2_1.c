int yaffs2_handle_hole ( struct yaffs_obj * obj , loff_t new_size ) { loff_t old_file_size ; loff_t increase ; int small_hole ; int result = YAFFS_OK ; struct yaffs_dev * dev = NULL ; u8 * local_buffer = NULL ; int small_increase_ok = 0 ; if ( ! obj ) { return YAFFS_FAIL ; } if ( obj -> variant_type != YAFFS_OBJECT_TYPE_FILE ) { return YAFFS_FAIL ; } dev = obj -> my_dev ; if ( ! dev -> param . is_yaffs2 ) { return YAFFS_OK ; } old_file_size = obj -> variant . file_variant . file_size ; if ( new_size <= old_file_size ) { return YAFFS_OK ; } increase = new_size - old_file_size ; if ( increase < YAFFS_SMALL_HOLE_THRESHOLD * dev -> data_bytes_per_chunk && yaffs_check_alloc_available ( dev , YAFFS_SMALL_HOLE_THRESHOLD + 1 ) ) { small_hole = 1 ; } else { small_hole = 0 ; } if ( small_hole ) { local_buffer = yaffs_get_temp_buffer ( dev ) ; } if ( local_buffer ) { loff_t pos = old_file_size ; int this_write ; int written ; small_increase_ok = 1 ; while ( increase > 0 && small_increase_ok ) { this_write = increase ; if ( this_write > dev -> data_bytes_per_chunk ) { this_write = dev -> data_bytes_per_chunk ; } written = yaffs_do_file_wr ( obj , local_buffer , pos , this_write , 0 ) ; if ( written == this_write ) { pos += this_write ; increase -= this_write ; } else { small_increase_ok = 0 ; } } yaffs_release_temp_buffer ( dev , local_buffer ) ; if ( ! small_increase_ok ) { yaffs_resize_file_down ( obj , old_file_size ) ; } } if ( ! small_increase_ok && obj -> parent && obj -> parent -> obj_id != YAFFS_OBJECTID_UNLINKED && obj -> parent -> obj_id != YAFFS_OBJECTID_DELETED ) { yaffs_update_oh ( obj , NULL , 0 , 1 , 0 , NULL ) ; } return result ; } yaffs_block_index { int seq ; int block ; } 