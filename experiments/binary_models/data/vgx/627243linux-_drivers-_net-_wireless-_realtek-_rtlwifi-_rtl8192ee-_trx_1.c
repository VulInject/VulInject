void rtl92ee_tx_fill_desc ( struct ieee80211_hw * hw , struct ieee80211_hdr * hdr , u8 * pdesc8 , u8 * pbd_desc_tx , struct ieee80211_tx_info * info , struct ieee80211_sta * sta , struct sk_buff * skb , u8 hw_queue , struct rtl_tcb_desc * ptcb_desc ) { struct rtl_priv * rtlpriv = rtl_priv ( hw ) ; struct rtl_mac * mac = rtl_mac ( rtl_priv ( hw ) ) ; struct rtl_pci * rtlpci = rtl_pcidev ( rtl_pcipriv ( hw ) ) ; struct rtl_hal * rtlhal = rtl_hal ( rtlpriv ) ; struct rtlwifi_tx_info * tx_info = rtl_tx_skb_cb_info ( skb ) ; u16 seq_number ; __le16 fc = hdr -> frame_control ; u8 fw_qsel = _rtl92ee_map_hwqueue_to_fwqueue ( skb , hw_queue ) ; bool firstseg = ( ( hdr -> seq_ctrl & cpu_to_le16 ( IEEE80211_SCTL_FRAG ) ) == 0 ) ; bool lastseg = ( ( hdr -> frame_control & cpu_to_le16 ( IEEE80211_FCTL_MOREFRAGS ) ) == 0 ) ; dma_addr_t mapping ; u8 bw_40 = 0 ; __le32 * pdesc = ( __le32 * ) pdesc8 ; if ( mac -> opmode == NL80211_IFTYPE_STATION ) { bw_40 = mac -> bw_40 ; } if ( mac -> opmode == NL80211_IFTYPE_AP || mac -> opmode == NL80211_IFTYPE_ADHOC ) { if ( sta ) { bw_40 = sta -> deflink . ht_cap . cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ; } } seq_number = ( le16_to_cpu ( hdr -> seq_ctrl ) & IEEE80211_SCTL_SEQ ) >> 4 ; rtl_get_tcb_desc ( hw , info , sta , skb , ptcb_desc ) ; if ( rtlhal -> earlymode_enable ) { skb_push ( skb , EM_HDR_LEN ) ; } mapping = dma_map_single ( & rtlpci -> pdev -> dev , skb -> data , skb -> len , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( & rtlpci -> pdev -> dev , mapping ) ) { rtl_dbg ( rtlpriv , COMP_SEND , DBG_TRACE , "DMA mapping error\n" ) ; return ; } if ( pbd_desc_tx != NULL ) { rtl92ee_pre_fill_tx_bd_desc ( hw , pbd_desc_tx , pdesc8 , hw_queue , skb , mapping ) ; } if ( ieee80211_is_nullfunc ( fc ) || ieee80211_is_ctl ( fc ) ) { firstseg = true ; lastseg = true ; } if ( firstseg ) { if ( rtlhal -> earlymode_enable ) { set_tx_desc_pkt_offset ( pdesc , 1 ) ; set_tx_desc_offset ( pdesc , USB_HWDESC_HEADER_LEN + EM_HDR_LEN ) ; if ( ptcb_desc -> empkt_num ) { rtl_dbg ( rtlpriv , COMP_SEND , DBG_TRACE , "Insert 8 byte.pTcb->EMPktNum:%d\n" , ptcb_desc -> empkt_num ) ; _rtl92ee_insert_emcontent ( ptcb_desc , ( u8 * ) ( skb -> data ) ) ; } } else { set_tx_desc_offset ( pdesc , USB_HWDESC_HEADER_LEN ) ; } set_tx_desc_tx_rate ( pdesc , ptcb_desc -> hw_rate ) ; if ( ieee80211_is_mgmt ( fc ) ) { ptcb_desc -> use_driver_rate = true ; } else { if ( rtlpriv -> ra . is_special_data ) { ptcb_desc -> use_driver_rate = true ; set_tx_desc_tx_rate ( pdesc , DESC_RATE11M ) ; } else { ptcb_desc -> use_driver_rate = false ; } } if ( info -> flags & IEEE80211_TX_CTL_AMPDU ) { set_tx_desc_agg_enable ( pdesc , 1 ) ; set_tx_desc_max_agg_num ( pdesc , 0x14 ) ; } set_tx_desc_seq ( pdesc , seq_number ) ; set_tx_desc_rts_enable ( pdesc , ( ( ptcb_desc -> rts_enable && ! ptcb_desc -> cts_enable ) ?1 : 0 ) ) ; set_tx_desc_hw_rts_enable ( pdesc , 0 ) ; set_tx_desc_cts2self ( pdesc , ( ( ptcb_desc -> cts_enable ) ?1 : 0 ) ) ; set_tx_desc_rts_rate ( pdesc , ptcb_desc -> rts_rate ) ; set_tx_desc_rts_sc ( pdesc , ptcb_desc -> rts_sc ) ; set_tx_desc_rts_short ( pdesc , ( ( ptcb_desc -> rts_rate <= DESC_RATE54M ) ?( ptcb_desc -> rts_use_shortpreamble ?1 : 0 ) else ( ptcb_desc -> rts_use_shortgi ?1 : 0 ) ) ) ; if ( ptcb_desc -> tx_enable_sw_calc_duration ) { set_tx_desc_nav_use_hdr ( pdesc , 1 ) ; } if ( bw_40 ) { if ( ptcb_desc -> packet_bw == HT_CHANNEL_WIDTH_20_40 ) { set_tx_desc_data_bw ( pdesc , 1 ) ; set_tx_desc_tx_sub_carrier ( pdesc , 3 ) ; } else { set_tx_desc_data_bw ( pdesc , 0 ) ; set_tx_desc_tx_sub_carrier ( pdesc , mac -> cur_40_prime_sc ) ; } } else { set_tx_desc_data_bw ( pdesc , 0 ) ; set_tx_desc_tx_sub_carrier ( pdesc , 0 ) ; } set_tx_desc_linip ( pdesc , 0 ) ; if ( sta ) { u8 ampdu_density = sta -> deflink . ht_cap . ampdu_density ; set_tx_desc_ampdu_density ( pdesc , ampdu_density ) ; } if ( info -> control . hw_key ) { struct ieee80211_key_conf * key = info -> control . hw_key ; switch ( key -> cipher ) { case WLAN_CIPHER_SUITE_WEP40 : case WLAN_CIPHER_SUITE_WEP104 : case WLAN_CIPHER_SUITE_TKIP : set_tx_desc_sec_type ( pdesc , 0x1 ) ; break ; case WLAN_CIPHER_SUITE_CCMP : set_tx_desc_sec_type ( pdesc , 0x3 ) ; break ; default : set_tx_desc_sec_type ( pdesc , 0x0 ) ; break ; } } set_tx_desc_queue_sel ( pdesc , fw_qsel ) ; set_tx_desc_data_rate_fb_limit ( pdesc , 0x1F ) ; set_tx_desc_rts_rate_fb_limit ( pdesc , 0xF ) ; set_tx_desc_disable_fb ( pdesc , ptcb_desc -> disable_ratefallback ?1 : 0 ) ; set_tx_desc_use_rate ( pdesc , ptcb_desc -> use_driver_rate ?1 : 0 ) ; if ( ! ptcb_desc -> use_driver_rate ) { } if ( ieee80211_is_data_qos ( fc ) ) { if ( mac -> rdg_en ) { rtl_dbg ( rtlpriv , COMP_SEND , DBG_TRACE , "Enable RDG function.\n" ) ; set_tx_desc_rdg_enable ( pdesc , 1 ) ; set_tx_desc_htc ( pdesc , 1 ) ; } } rtl_set_tx_report ( ptcb_desc , pdesc8 , hw , tx_info ) ; } set_tx_desc_first_seg ( pdesc , ( firstseg ?1 : 0 ) ) ; set_tx_desc_last_seg ( pdesc , ( lastseg ?1 : 0 ) ) ; set_tx_desc_tx_buffer_address ( pdesc , mapping ) ; if ( rtlpriv -> dm . useramask ) { set_tx_desc_rate_id ( pdesc , ptcb_desc -> ratr_index ) ; set_tx_desc_macid ( pdesc , ptcb_desc -> mac_id ) ; } else { set_tx_desc_rate_id ( pdesc , 0xC + ptcb_desc -> ratr_index ) ; set_tx_desc_macid ( pdesc , ptcb_desc -> ratr_index ) ; } set_tx_desc_more_frag ( pdesc , ( lastseg ?0 : 1 ) ) ; if ( is_multicast_ether_addr ( ieee80211_get_DA ( hdr ) ) || is_broadcast_ether_addr ( ieee80211_get_DA ( hdr ) ) ) { set_tx_desc_bmc ( pdesc , 1 ) ; } rtl_dbg ( rtlpriv , COMP_SEND , DBG_TRACE , "\n" ) ; } 