int maildir_message_add_uid ( struct maildir * md , const char * message , size_t size , char * uid , size_t max_uid_len ) { char path_new [ PATH_MAX ] ; char tmpname [ PATH_MAX ] ; int fd ; int r ; char * mapping ; char * delivery_tmp_name ; char * delivery_tmp_basename ; char delivery_new_name [ PATH_MAX ] ; char * delivery_new_basename ; int res ; struct stat stat_info ; r = maildir_update ( md ) ; if ( r != MAILDIR_NO_ERROR ) { res = r ; err } snprintf ( tmpname , sizeof ( tmpname ) , "%s/tmp/etpan-maildir-XXXXXX" , md -> mdir_path ) ; fd = mkstemp ( tmpname ) ; if ( fd < 0 ) { res = MAILDIR_ERROR_FILE ; err } r = ftruncate ( fd , size ) ; if ( r < 0 ) { res = MAILDIR_ERROR_FILE ; close } mapping = mmap ( NULL , size , PROT_READ | PROT_WRITE , MAP_SHARED , fd , 0 ) ; if ( mapping == ( char * ) MAP_FAILED ) { res = MAILDIR_ERROR_FILE ; close } memcpy ( mapping , message , size ) ; msync ( mapping , size , MS_SYNC ) ; munmap ( mapping , size ) ; close ( fd ) ; delivery_tmp_name = maildir_get_new_message_filename ( md , tmpname ) ; if ( delivery_tmp_name == NULL ) { res = MAILDIR_ERROR_FILE ; unlink } strncpy ( tmpname , delivery_tmp_name , sizeof ( tmpname ) ) ; tmpname [ sizeof ( tmpname ) - 1 ] = '\0' ; delivery_tmp_basename = libetpan_basename ( tmpname ) ; snprintf ( delivery_new_name , sizeof ( delivery_new_name ) , "%s/new/%s" , md -> mdir_path , delivery_tmp_basename ) ; r = link ( delivery_tmp_name , delivery_new_name ) ; if ( r == 0 ) { unlink ( delivery_tmp_name ) ; } if ( errno == EXDEV ) { res = MAILDIR_ERROR_FOLDER ; unlink_tmp } if ( errno == EPERM ) { r = rename ( delivery_tmp_name , delivery_new_name ) ; if ( r < 0 ) { res = MAILDIR_ERROR_FILE ; unlink_tmp } } snprintf ( path_new , sizeof ( path_new ) , "%s/new" , md -> mdir_path ) ; r = stat ( path_new , & stat_info ) ; if ( r < 0 ) { unlink ( delivery_new_name ) ; res = MAILDIR_ERROR_FILE ; unlink_tmp } md -> mdir_mtime_new = stat_info . st_mtime ; delivery_new_basename = libetpan_basename ( delivery_new_name ) ; r = add_message ( md , delivery_new_basename , 1 ) ; if ( r != MAILDIR_NO_ERROR ) { unlink ( delivery_new_name ) ; res = MAILDIR_ERROR_FILE ; unlink_tmp } if ( uid != NULL ) { strncpy ( uid , delivery_new_basename , max_uid_len ) ; } return MAILDIR_NO_ERROR ; unlink_tmp unlink ( delivery_tmp_name ) ; free ( delivery_tmp_name ) ; err close close ( fd ) ; unlink unlink ( tmpname ) ; err return res ; } 