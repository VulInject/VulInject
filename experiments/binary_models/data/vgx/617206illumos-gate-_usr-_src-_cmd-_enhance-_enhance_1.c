static int pty_open_manager ( const char * prog , int * cntrl , char * subsid_name ) { char manager_name [ PTY_MAX_NAME ] ; DIR * dir ; struct dirent * file ; * cntrl = - 1 ; * cntrl = open ( "/dev/ptmx" , O_RDWR ) ; if ( * cntrl >= 0 ) { char * name = ptsname ( * cntrl ) ; if ( name ) { if ( strlen ( name ) + 1 > PTY_MAX_NAME ) { fprintf ( stderr , "%s: Subsidiary pty filename too long.\n" , prog ) ; return 1 ; } strlcpy ( subsid_name , name , PTY_MAX_NAME ) ; } else { close ( * cntrl ) ; * cntrl = - 1 ; } } else { dir = opendir ( PTY_DEV_DIR ) ; if ( ! dir ) { fprintf ( stderr , "%s: Couldn't open %s (%s)\n" , prog , PTY_DEV_DIR , strerror ( errno ) ) ; return 1 ; } while ( * cntrl < 0 && ( file = readdir ( dir ) ) ) { if ( strncmp ( file -> d_name , PTY_CNTRL , sizeof ( PTY_CNTRL ) - 1 ) == 0 ) { const char * ext = file -> d_name + sizeof ( PTY_CNTRL ) - 1 ; if ( strlen ( ext ) > PTY_MAX_SUFFIX ) { continue ; } strlcpy ( manager_name , PTY_DEV_DIR , sizeof ( manager_name ) ) ; strlcat ( manager_name , PTY_CNTRL , sizeof ( manager_name ) ) ; strlcat ( manager_name , ext , sizeof ( manager_name ) ) ; * cntrl = open ( manager_name , O_RDWR ) ; if ( * cntrl < 0 ) { continue ; } strlcpy ( subsid_name , PTY_DEV_DIR , PTY_MAX_NAME ) ; strlcat ( subsid_name , PTY_SUBSID , PTY_MAX_NAME ) ; strlcat ( subsid_name , ext , PTY_MAX_NAME ) ; } } closedir ( dir , NULL ) ; } if ( * cntrl < 0 ) { fprintf ( stderr , "%s: Unable to find a free pseudo-terminal.\n" , prog ) ; return 1 ; } if ( grantpt ( * cntrl ) < 0 || unlockpt ( * cntrl ) < 0 ) { fprintf ( stderr , "%s: Unable to unlock terminal (%s).\n" , prog , strerror ( errno ) ) ; return 1 ; } return 0 ; } 