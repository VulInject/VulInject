void * rw_lock_delay ( uint_t ) NULL ; void rw_enter_sleep ( rwlock_impl_t * lp , krw_t rw ) { uintptr_t old , lock_value , lock_busy , lock_wait ; hrtime_t sleep_time ; turnstile_t * ts ; uint_t backoff = 0 ; int loop_count = 0 ; if ( rw == RW_READER ) { lock_value = RW_READ_LOCK ; lock_busy = RW_WRITE_CLAIMED ; lock_wait = RW_HAS_WAITERS ; } if ( rw == RW_READER_STARVEWRITER ) { lock_value = RW_READ_LOCK ; lock_busy = RW_WRITE_LOCKED ; lock_wait = RW_HAS_WAITERS ; } else { lock_value = RW_WRITE_LOCK ( curthread ) ; lock_busy = ( uintptr_t ) RW_LOCKED ; lock_wait = RW_HAS_WAITERS | RW_WRITE_WANTED ; } for ( ; ; ) { if ( ( ( old = lp -> rw_wwwh ) & lock_busy ) == 0 ) { if ( casip ( & lp -> rw_wwwh , old , old + lock_value ) != old ) { if ( rw_lock_delay != NULL ) { backoff = rw_lock_backoff ( backoff ) ; rw_lock_delay ( backoff , NULL ) ; if ( ++ loop_count == ncpus_online ) { backoff = 0 ; loop_count = 0 ; } } continue ; } break ; } if ( panicstr ) { return ; } if ( ( old & RW_DOUBLE_LOCK ) == RW_DOUBLE_LOCK ) { rw_panic ( "rw_enter: bad rwlock" , lp ) ; return ; } if ( ( old & RW_OWNER ) == ( uintptr_t ) curthread ) { rw_panic ( "recursive rw_enter" , lp ) ; return ; } ts = turnstile_lookup ( lp ) ; { if ( ( ( old = lp -> rw_wwwh ) & lock_busy ) == 0 ) { break ; } new = old | lock_wait ; } old != new && casip ( & lp -> rw_wwwh , old , new ) != old ; if ( ( old & lock_busy ) == 0 ) { turnstile_exit ( lp ) ; continue ; } ASSERT ( lp -> rw_wwwh & lock_wait ) ; ASSERT ( lp -> rw_wwwh & RW_LOCKED ) ; sleep_time = - gethrtime ( ) ; if ( rw != RW_WRITER ) { CPU_STATS_ADDQ ( CPU , sys , rw_rdfails , 1 ) ; ( void ) turnstile_block ( ts , TS_READER_Q , lp , & rw_sobj_ops , NULL , NULL ) ; } else { CPU_STATS_ADDQ ( CPU , sys , rw_wrfails , 1 ) ; ( void ) turnstile_block ( ts , TS_WRITER_Q , lp , & rw_sobj_ops , NULL , NULL ) ; } sleep_time += gethrtime ( ) ; LOCKSTAT_RECORD4 ( LS_RW_ENTER_BLOCK , lp , sleep_time , rw , ( old & RW_WRITE_LOCKED ) ?1 : 0 , old >> RW_HOLD_COUNT_SHIFT ) ; break ; } ASSERT ( rw_locked ( lp , rw ) ) ; membar_enter ( ) ; LOCKSTAT_RECORD ( LS_RW_ENTER_ACQUIRE , lp , rw ) ; } 