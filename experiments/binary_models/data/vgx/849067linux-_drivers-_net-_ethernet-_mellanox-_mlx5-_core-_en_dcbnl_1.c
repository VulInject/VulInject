static int mlx5e_dcbnl_ieee_getets ( struct net_device * netdev , struct ieee_ets * ets ) { struct mlx5e_priv * priv = netdev_priv ( netdev ) ; struct mlx5_core_dev * mdev = priv -> mdev ; u8 tc_group [ IEEE_8021QAZ_MAX_TCS ] ; bool is_tc_group_6_exist = false ; bool is_zero_bw_ets_tc = false ; int err = 0 ; int i ; if ( ! MLX5_CAP_GEN ( priv -> mdev , ets ) ) { return - EOPNOTSUPP ; } ets -> ets_cap = mlx5_max_tc ( priv -> mdev ) + 1 ; for ( i = 0 ; i < ets -> ets_cap ; i ++ ) { err = mlx5_query_port_prio_tc ( mdev , i , & ets -> prio_tc [ i ] ) ; err = mlx5_query_port_tc_group ( mdev , i , & tc_group [ i ] ) ; if ( err ) { return err ; } err = mlx5_query_port_tc_bw_alloc ( mdev , i , & ets -> tc_tx_bw [ i ] ) ; if ( err ) { return err ; } if ( ets -> tc_tx_bw [ i ] < MLX5E_MAX_BW_ALLOC && tc_group [ i ] == ( MLX5E_LOWEST_PRIO_GROUP + 1 ) ) { is_zero_bw_ets_tc = true ; } if ( tc_group [ i ] == ( MLX5E_VENDOR_TC_GROUP_NUM - 1 ) ) { is_tc_group_6_exist = true ; } } if ( is_zero_bw_ets_tc ) { for ( i = 0 ; i < ets -> ets_cap ; i ++ ) { if ( tc_group [ i ] == MLX5E_LOWEST_PRIO_GROUP ) { ets -> tc_tx_bw [ i ] = 0 ; } } } for ( i = 0 ; i < ets -> ets_cap ; i ++ ) { if ( ets -> tc_tx_bw [ i ] < MLX5E_MAX_BW_ALLOC ) { priv -> dcbx . tc_tsa [ i ] = IEEE_8021QAZ_TSA_ETS ; } if ( tc_group [ i ] == MLX5E_VENDOR_TC_GROUP_NUM && ! is_tc_group_6_exist ) { priv -> dcbx . tc_tsa [ i ] = IEEE_8021QAZ_TSA_VENDOR ; } } memcpy ( ets -> tc_tsa , priv -> dcbx . tc_tsa , sizeof ( ets -> tc_tsa ) ) ; return err ; } 