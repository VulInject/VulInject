assemble_two_insns ( , , ) char * str ; char * str2 ; int parallel_p ; { char * str3 ; m32r_insn first ; m32r_insn second ; char * errmsg ; char save_str2 = * str2 ; * str2 = 0 ; fill_insn ( 0 ) ; first . debug_sym_link = debug_sym_link ; debug_sym_link = ( sym_linkS * ) 0 ; if ( ! ( first . insn = m32r_cgen_assemble_insn ( gas_cgen_cpu_desc , str , & first . fields , first . buffer , & errmsg ) ) ) { as_bad ( errmsg , NULL ) ; return ; } if ( CGEN_FIELDS_BITSIZE ( & first . fields ) != 16 ) { as_bad ( _ ( "not a 16 bit instruction '%s'" ) , str ) ; return ; } if ( ( enable_m32rx == 1 ) && ( ( CGEN_INSN_ATTR_VALUE ( first . insn , CGEN_INSN_MACH ) & ( 1 << MACH_M32R2 ) ) && ! ( ( CGEN_INSN_ATTR_VALUE ( first . insn , CGEN_INSN_MACH ) & ( 1 << MACH_M32RX ) ) ) ) ) { as_bad ( _ ( "instruction '%s' is for the M32R2 only" ) , str ) ; return ; } if ( ( ! enable_special && CGEN_INSN_ATTR_VALUE ( first . insn , CGEN_INSN_SPECIAL ) ) || ( ! enable_special_m32r && CGEN_INSN_ATTR_VALUE ( first . insn , CGEN_INSN_SPECIAL_M32R ) ) ) { if ( ! enable_special && CGEN_INSN_ATTR_VALUE ( first . insn , CGEN_INSN_SPECIAL ) ) { as_bad ( _ ( "unknown instruction '%s'" ) , str ) ; return ; } if ( ! enable_m32rx && ( CGEN_INSN_ATTR_VALUE ( first . insn , CGEN_INSN_MACH ) == ( 1 << MACH_M32RX ) ) ) { as_bad ( _ ( "instruction '%s' is for the M32RX only" ) , str ) ; return ; } } if ( parallel_p && CGEN_INSN_ATTR_VALUE ( first . insn , CGEN_INSN_PIPE ) == PIPE_NONE ) { as_bad ( _ ( "instruction '%s' cannot be executed in parallel." ) , str ) ; return ; } * str2 = save_str2 ; str3 = str ; str = str2 + 2 ; str2 = str3 ; { char * s2 = str ; while ( ISSPACE ( * s2 ++ ) ) { continue ; } -- s2 ; while ( ISALNUM ( * s2 ) ) { * s2 = TOLOWER ( * s2 ) ; s2 ++ ; } } gas_cgen_save_fixups ( 0 ) ; first . orig_insn = first . insn ; { CGEN_FIELDS tmp_fields ; first . insn = cgen_lookup_get_insn_operands ( gas_cgen_cpu_desc , NULL , INSN_VALUE ( first . buffer ) , NULL , 16 , first . indices , & tmp_fields ) ; } if ( first . insn == NULL ) { as_fatal ( _ ( "internal error: lookup/get operands failed" ) ) ; } second . debug_sym_link = NULL ; if ( ! ( second . insn = m32r_cgen_assemble_insn ( gas_cgen_cpu_desc , str , & second . fields , second . buffer , & errmsg ) ) ) { as_bad ( errmsg ) ; return ; } if ( CGEN_FIELDS_BITSIZE ( & second . fields ) != 16 ) { as_bad ( _ ( "not a 16 bit instruction '%s'" ) , str ) ; return ; } if ( ( enable_m32rx == 1 ) && ( ( CGEN_INSN_ATTR_VALUE ( first . insn , CGEN_INSN_MACH ) & ( 1 << MACH_M32R2 ) ) && ! ( ( CGEN_INSN_ATTR_VALUE ( first . insn , CGEN_INSN_MACH ) & ( 1 << MACH_M32RX ) ) ) ) ) { as_bad ( _ ( "instruction '%s' is for the M32R2 only" ) , str ) ; return ; } if ( ( ! enable_special && CGEN_INSN_ATTR_VALUE ( second . insn , CGEN_INSN_SPECIAL ) ) || ( ! enable_special_m32r && CGEN_INSN_ATTR_VALUE ( second . insn , CGEN_INSN_SPECIAL_M32R ) ) ) { if ( ! enable_special && CGEN_INSN_ATTR_VALUE ( second . insn , CGEN_INSN_SPECIAL ) ) { as_bad ( _ ( "unknown instruction '%s'" ) , str ) ; return ; } if ( ! enable_m32rx && CGEN_INSN_ATTR_VALUE ( second . insn , CGEN_INSN_MACH ) == ( 1 << MACH_M32RX ) ) { as_bad ( _ ( "instruction '%s' is for the M32RX only" ) , str ) ; return ; } } if ( parallel_p && CGEN_INSN_ATTR_VALUE ( second . insn , CGEN_INSN_PIPE ) == PIPE_NONE ) { as_bad ( _ ( "instruction '%s' cannot be executed in parallel." ) , str ) ; return ; } if ( parallel_p && ! enable_m32rx ) { if ( CGEN_INSN_NUM ( first . insn ) != M32R_INSN_NOP && CGEN_INSN_NUM ( second . insn ) != M32R_INSN_NOP ) { as_bad ( _ ( "'%s': only the NOP instruction can be issued in parallel on the m32r" ) , str2 ) ; return ; } } second . orig_insn = second . insn ; { CGEN_FIELDS tmp_fields ; second . insn = cgen_lookup_get_insn_operands ( gas_cgen_cpu_desc , NULL , INSN_VALUE ( second . buffer ) , NULL , 16 , second . indices , & tmp_fields ) ; } if ( second . insn == NULL ) { as_fatal ( _ ( "internal error: lookup/get operands failed" ) ) ; } if ( parallel_p && warn_explicit_parallel_conflicts ) { if ( first_writes_to_seconds_operands ( & first , & second , FALSE ) ) { as_warn ( _ ( "%s: output of 1st instruction is the same as an input to 2nd instruction - is this intentional ?" ) , str2 ) ; } if ( first_writes_to_seconds_operands ( & second , & first , FALSE ) ) { as_warn ( _ ( "%s: output of 2nd instruction is the same as an input to 1st instruction - is this intentional ?" ) , str2 ) ; } } if ( ! parallel_p || ( errmsg = ( char * ) can_make_parallel ( & first , & second ) ) == NULL ) { gas_cgen_swap_fixups ( 0 ) ; expand_debug_syms ( first . debug_sym_link , 1 ) ; gas_cgen_finish_insn ( first . orig_insn , first . buffer , CGEN_FIELDS_BITSIZE ( & first . fields ) , 0 , NULL ) ; if ( parallel_p ) { make_parallel ( second . buffer ) ; } gas_cgen_restore_fixups ( 0 ) ; expand_debug_syms ( second . debug_sym_link , 1 ) ; gas_cgen_finish_insn ( second . orig_insn , second . buffer , CGEN_FIELDS_BITSIZE ( & second . fields ) , 0 , NULL ) ; } if ( can_make_parallel ( & second , & first ) == NULL ) { expand_debug_syms ( second . debug_sym_link , 1 ) ; gas_cgen_finish_insn ( second . orig_insn , second . buffer , CGEN_FIELDS_BITSIZE ( & second . fields ) , 0 , NULL ) ; make_parallel ( first . buffer ) ; gas_cgen_restore_fixups ( 0 ) ; expand_debug_syms ( first . debug_sym_link , 1 ) ; gas_cgen_finish_insn ( first . orig_insn , first . buffer , CGEN_FIELDS_BITSIZE ( & first . fields ) , 0 , NULL ) ; } else { as_bad ( "'%s': %s" , str2 , errmsg ) ; return ; } if ( CGEN_INSN_ATTR_VALUE ( first . insn , CGEN_INSN_SPECIAL ) || CGEN_INSN_ATTR_VALUE ( second . insn , CGEN_INSN_SPECIAL ) ) { m32r_flags |= E_M32R_HAS_HIDDEN_INST ; } if ( CGEN_INSN_ATTR_VALUE ( first . insn , CGEN_INSN_SPECIAL_M32R ) || CGEN_INSN_ATTR_VALUE ( second . insn , CGEN_INSN_SPECIAL_M32R ) ) { m32r_flags |= E_M32R_HAS_BIT_INST ; } if ( CGEN_INSN_ATTR_VALUE ( first . insn , CGEN_INSN_SPECIAL_FLOAT ) || CGEN_INSN_ATTR_VALUE ( second . insn , CGEN_INSN_SPECIAL_FLOAT ) ) { m32r_flags |= E_M32R_HAS_FLOAT_INST ; } prev_seg = now_seg ; prev_subseg = now_subseg ; } 