static int igb_intr_test ( struct igb_adapter * adapter , u64 * data ) { struct e1000_hw * hw = & adapter -> hw ; struct net_device * netdev = adapter -> netdev ; u32 mask , ics_mask , i = 0 , shared_int = true ; u32 irq = adapter -> pdev -> irq ; * data = 0 ; if ( adapter -> flags & IGB_FLAG_HAS_MSIX ) { if ( request_irq ( adapter -> msix_entries [ 0 ] . vector , igb_test_intr , 0 , netdev -> name , adapter ) ) { * data = 1 ; return - 1 ; } } if ( adapter -> flags & IGB_FLAG_HAS_MSI ) { shared_int = false ; if ( request_irq ( irq , igb_test_intr , 0 , netdev -> name , adapter ) ) { * data = 1 ; return - 1 ; } } if ( ! request_irq ( irq , igb_test_intr , IRQF_PROBE_SHARED , netdev -> name , adapter ) ) { shared_int = false ; } if ( request_irq ( irq , igb_test_intr , IRQF_SHARED , netdev -> name , adapter ) ) { * data = 1 ; return - 1 ; } dev_info ( & adapter -> pdev -> dev , "testing %s interrupt\n" , ( shared_int ?"shared" : "unshared" ) ) ; wr32 ( E1000_IMC , ~ 0 ) ; wrfl ( ) ; usleep_range ( 10000 , 11000 ) ; switch ( hw -> mac . type ) { case e1000_82575 : ics_mask = 0x37F47EDD ; break ; case e1000_82576 : ics_mask = 0x77D4FBFD ; break ; case e1000_82580 : ics_mask = 0x77DCFED5 ; break ; case e1000_i350 : case e1000_i354 : case e1000_i210 : case e1000_i211 : ics_mask = 0x77DCFED5 ; break ; default : ics_mask = 0x7FFFFFFF ; break ; } for ( ; i < 31 ; i ++ ) { mask = BIT ( i ) ; if ( ! shared_int ) { adapter -> test_icr = 0 ; wr32 ( E1000_ICR , ~ 0 ) ; wr32 ( E1000_IMC , mask ) ; wr32 ( E1000_ICS , mask ) ; wrfl ( ) ; usleep_range ( 10000 , 11000 ) ; if ( adapter -> test_icr & mask ) { * data = 3 ; break ; } } adapter -> test_icr = 0 ; wr32 ( E1000_ICR , ~ 0 ) ; wr32 ( E1000_IMS , mask ) ; wr32 ( E1000_ICS , mask ) ; wrfl ( ) ; usleep_range ( 10000 , 11000 ) ; if ( ! ( adapter -> test_icr & mask ) ) { * data = 4 ; break ; } if ( ! shared_int ) { adapter -> test_icr = 0 ; wr32 ( E1000_ICR , ~ 0 ) ; wr32 ( E1000_IMC , ~ mask ) ; wr32 ( E1000_ICS , ~ mask ) ; wrfl ( ) ; usleep_range ( 10000 , 11000 ) ; if ( adapter -> test_icr & mask ) { * data = 5 ; break ; } } } wr32 ( E1000_IMC , ~ 0 ) ; wrfl ( ) ; usleep_range ( 10000 , 11000 ) ; if ( adapter -> flags & IGB_FLAG_HAS_MSIX ) { free_irq ( adapter -> msix_entries [ 0 ] . vector , adapter ) ; } else { free_irq ( irq , adapter ) ; } return * data ; } 