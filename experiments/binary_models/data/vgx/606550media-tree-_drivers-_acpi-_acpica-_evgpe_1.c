u32 acpi_ev_gpe_detect ( struct acpi_gpe_xrupt_info * gpe_xrupt_list ) { acpi_status status ; struct acpi_gpe_block_info * gpe_block ; struct acpi_namespace_node * gpe_device ; struct acpi_gpe_register_info * gpe_register_info ; struct acpi_gpe_event_info * gpe_event_info ; u32 gpe_number ; struct acpi_gpe_handler_info * gpe_handler_info ; u32 int_status = ACPI_INTERRUPT_NOT_HANDLED ; u8 enabled_status_byte ; u32 status_reg ; u32 enable_reg ; acpi_cpu_flags flags ; u32 i ; u32 j ; ACPI_FUNCTION_NAME ( ev_gpe_detect ) ; if ( ! gpe_xrupt_list ) { return ( int_status ) ; } flags = acpi_os_acquire_lock ( acpi_gbl_gpe_lock ) ; gpe_block = gpe_xrupt_list -> gpe_block_list_head ; while ( gpe_block ) { gpe_device = gpe_block -> node ; for ( i = 0 ; i < gpe_block -> register_count ; i ++ ) { gpe_register_info = & gpe_block -> register_info [ i ] ; if ( ! ( gpe_register_info -> enable_for_run | gpe_register_info -> enable_for_wake ) ) { ACPI_DEBUG_PRINT ( ( ACPI_DB_INTERRUPTS , "Ignore disabled registers for GPE %02X-%02X: " "RunEnable=%02X, WakeEnable=%02X\n" , gpe_register_info -> base_gpe_number , gpe_register_info -> base_gpe_number + ( ACPI_GPE_REGISTER_WIDTH - 1 ) , gpe_register_info -> enable_for_run , gpe_register_info -> enable_for_wake ) ) ; continue ; } status = acpi_hw_read ( & status_reg , & gpe_register_info -> status_address ) ; if ( ACPI_FAILURE ( status ) ) { unlock_and_exit } status = acpi_hw_read ( & enable_reg , & gpe_register_info -> enable_address ) ; if ( ACPI_FAILURE ( status ) ) { unlock_and_exit } ACPI_DEBUG_PRINT ( ( ACPI_DB_INTERRUPTS , "Read registers for GPE %02X-%02X: Status=%02X, Enable=%02X, " "RunEnable=%02X, WakeEnable=%02X\n" , gpe_register_info -> base_gpe_number , gpe_register_info -> base_gpe_number + ( ACPI_GPE_REGISTER_WIDTH - 1 ) , status_reg , enable_reg , gpe_register_info -> enable_for_run , gpe_register_info -> enable_for_wake ) ) ; enabled_status_byte = ( u8 ) ( status_reg & enable_reg ) ; for ( j = 0 ; j < ACPI_GPE_REGISTER_WIDTH ; j ++ ) { gpe_event_info = & gpe_block -> event_info [ ( ( acpi_size ) i * ACPI_GPE_REGISTER_WIDTH ) + j ] ; gpe_number = j + gpe_register_info -> base_gpe_number ; if ( enabled_status_byte & ( 1 << j ) ) { acpi_gpe_count ++ ; if ( acpi_gbl_global_event_handler ) { acpi_gbl_global_event_handler ( ACPI_EVENT_TYPE_GPE , gpe_device , gpe_number , acpi_gbl_global_event_handler_context ) ; } if ( ACPI_GPE_DISPATCH_TYPE ( gpe_event_info -> flags ) == ACPI_GPE_DISPATCH_RAW_HANDLER ) { gpe_handler_info = gpe_event_info -> dispatch . handler ; acpi_os_release_lock ( acpi_gbl_gpe_lock , flags ) ; int_status |= gpe_handler_info -> address ( gpe_device , gpe_number , gpe_handler_info -> context ) ; flags = acpi_os_acquire_lock ( acpi_gbl_gpe_lock ) ; } else { int_status |= acpi_ev_gpe_dispatch ( gpe_device , gpe_event_info , gpe_number ) ; } } } } gpe_block = gpe_block -> next ; } unlock_and_exit acpi_os_release_lock ( acpi_gbl_gpe_lock , flags ) ; return ( int_status ) ; } 