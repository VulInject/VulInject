static bool dmub_psr_copy_settings ( struct dmub_psr * dmub , struct dc_link * link , struct psr_context * psr_context , uint8_t panel_inst ) { union dmub_rb_cmd cmd ; struct dc_context * dc = dmub -> ctx ; struct dmub_cmd_psr_copy_settings_data * copy_settings_data = & cmd . psr_copy_settings . psr_copy_settings_data ; struct pipe_ctx * pipe_ctx = NULL ; struct resource_context * res_ctx = & link -> ctx -> dc -> current_state -> res_ctx ; int i = 0 ; for ( i = 0 ; i < MAX_PIPES ; i ++ ) { if ( res_ctx -> pipe_ctx [ i ] . stream && res_ctx -> pipe_ctx [ i ] . stream -> link == link && res_ctx -> pipe_ctx [ i ] . stream -> link -> connector_signal == SIGNAL_TYPE_EDP ) { pipe_ctx = & res_ctx -> pipe_ctx [ i ] ; break ; } } if ( ! pipe_ctx ) { return false ; } if ( ! dmub_psr_set_version ( dmub , pipe_ctx -> stream , panel_inst ) ) { return false ; } link -> link_enc -> funcs -> psr_program_dp_dphy_fast_training ( link -> link_enc , psr_context -> psrExitLinkTrainingRequired ) ; link -> link_enc -> funcs -> psr_program_secondary_packet ( link -> link_enc , psr_context -> sdpTransmitLineNumDeadline ) ; cmd . psr_copy_settings . header . type = DMUB_CMD__PSR ; cmd . psr_copy_settings . header . sub_type = DMUB_CMD__PSR_COPY_SETTINGS ; cmd . psr_copy_settings . header . payload_bytes = sizeof ( dmub_cmd_psr_copy_settings_data ) ; copy_settings_data -> dpphy_inst = psr_context -> transmitterId ; copy_settings_data -> aux_inst = psr_context -> channel ; copy_settings_data -> digfe_inst = psr_context -> engineId ; copy_settings_data -> digbe_inst = psr_context -> transmitterId ; copy_settings_data -> mpcc_inst = pipe_ctx -> plane_res . mpcc_inst ; if ( pipe_ctx -> plane_res . dpp ) { copy_settings_data -> dpp_inst = pipe_ctx -> plane_res . dpp -> inst ; } else { copy_settings_data -> dpp_inst = 0 ; } if ( pipe_ctx -> stream_res . opp ) { copy_settings_data -> opp_inst = pipe_ctx -> stream_res . opp -> inst ; } else { copy_settings_data -> opp_inst = 0 ; } if ( pipe_ctx -> stream_res . tg ) { copy_settings_data -> otg_inst = pipe_ctx -> stream_res . tg -> inst ; } else { copy_settings_data -> otg_inst = 0 ; } copy_settings_data -> use_phy_fsm = link -> ctx -> dc -> debug . psr_power_use_phy_fsm ; copy_settings_data -> psr_level = psr_context -> psr_level . u32all ; copy_settings_data -> smu_optimizations_en = psr_context -> allow_smu_optimizations ; copy_settings_data -> multi_disp_optimizations_en = psr_context -> allow_multi_disp_optimizations ; copy_settings_data -> frame_delay = psr_context -> frame_delay ; copy_settings_data -> frame_cap_ind = psr_context -> psrFrameCaptureIndicationReq ; copy_settings_data -> init_sdp_deadline = psr_context -> sdpTransmitLineNumDeadline ; copy_settings_data -> debug . u32All = 0 ; copy_settings_data -> debug . bitfields . visual_confirm = dc -> dc -> debug . visual_confirm == VISUAL_CONFIRM_PSR ; copy_settings_data -> debug . bitfields . use_hw_lock_mgr = 1 ; copy_settings_data -> debug . bitfields . force_full_frame_update = 0 ; if ( psr_context -> su_granularity_required == 0 ) { copy_settings_data -> su_y_granularity = 0 ; } else { copy_settings_data -> su_y_granularity = psr_context -> su_y_granularity ; } copy_settings_data -> line_capture_indication = 0 ; copy_settings_data -> line_time_in_us = psr_context -> line_time_in_us ; copy_settings_data -> rate_control_caps = psr_context -> rate_control_caps ; copy_settings_data -> fec_enable_status = ( link -> fec_state == dc_link_fec_enabled ) ; copy_settings_data -> fec_enable_delay_in100us = link -> dc -> debug . fec_enable_delay_in100us ; copy_settings_data -> cmd_version = DMUB_CMD_PSR_CONTROL_VERSION_1 ; copy_settings_data -> panel_inst = panel_inst ; copy_settings_data -> dsc_enable_status = ( pipe_ctx -> stream -> timing . flags . DSC == 1 ) ; if ( copy_settings_data -> dsc_enable_status && link -> dpcd_caps . sink_dev_id == DP_DEVICE_ID_38EC11 && ! memcmp ( link -> dpcd_caps . sink_dev_id_str , DP_SINK_DEVICE_STR_ID_1 , sizeof ( DP_SINK_DEVICE_STR_ID_1 ) ) ) { link -> psr_settings . force_ffu_mode = 1 ; } else { link -> psr_settings . force_ffu_mode = 0 ; } copy_settings_data -> force_ffu_mode = link -> psr_settings . force_ffu_mode ; if ( link -> fec_state == dc_link_fec_enabled && link -> dpcd_caps . sink_dev_id == DP_DEVICE_ID_38EC11 && ( ! memcmp ( link -> dpcd_caps . sink_dev_id_str , DP_SINK_DEVICE_STR_ID_1 , sizeof ( DP_SINK_DEVICE_STR_ID_1 ) ) || ! memcmp ( link -> dpcd_caps . sink_dev_id_str , DP_SINK_DEVICE_STR_ID_2 , sizeof ( DP_SINK_DEVICE_STR_ID_2 ) ) ) ) { copy_settings_data -> debug . bitfields . force_wakeup_by_tps3 = 1 ; } else { copy_settings_data -> debug . bitfields . force_wakeup_by_tps3 = 0 ; } dc_dmub_srv_cmd_queue ( dc -> dmub_srv , & cmd ) ; dc_dmub_srv_cmd_execute ( dc -> dmub_srv ) ; dc_dmub_srv_wait_idle ( dc -> dmub_srv ) ; return true ; } 