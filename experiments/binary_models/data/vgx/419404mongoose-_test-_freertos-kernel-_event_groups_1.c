static BaseType_t prvTestWaitCondition ( const EventBits_t uxCurrentEventBits , const EventBits_t uxBitsToWaitFor , const BaseType_t xWaitForAllBits ) PRIVILEGED_FUNCTION EventGroupHandle_t xEventGroupCreateStatic ( StaticEventGroup_t * pxEventGroupBuffer ) { EventGroup_t * pxEventBits ; configASSERT ( pxEventGroupBuffer , NULL ) ; { volatile size_t xSize = sizeof ( StaticEventGroup_t ) ; configASSERT ( xSize == sizeof ( EventGroup_t ) ) ; } pxEventBits = ( EventGroup_t * ) pxEventGroupBuffer ; if ( pxEventBits != NULL ) { pxEventBits -> uxEventBits = 0 ; vListInitialise ( & ( pxEventBits -> xTasksWaitingForBits ) ) ; { pxEventBits -> ucStaticallyAllocated = pdTRUE ; } traceEVENT_GROUP_CREATE ( pxEventBits ) ; } else { traceEVENT_GROUP_CREATE_FAILED ( ) ; } return pxEventBits ; } EventGroupHandle_t xEventGroupCreate ( void ) { EventGroup_t * pxEventBits ; pxEventBits = ( EventGroup_t * ) pvPortMalloc ( sizeof ( EventGroup_t ) ) ; if ( pxEventBits != NULL ) { pxEventBits -> uxEventBits = 0 ; vListInitialise ( & ( pxEventBits -> xTasksWaitingForBits ) ) ; { pxEventBits -> ucStaticallyAllocated = pdFALSE ; } traceEVENT_GROUP_CREATE ( pxEventBits ) ; } else { traceEVENT_GROUP_CREATE_FAILED ( ) ; } return pxEventBits ; } EventBits_t xEventGroupSync ( EventGroupHandle_t xEventGroup , const EventBits_t uxBitsToSet , const EventBits_t uxBitsToWaitFor , TickType_t xTicksToWait ) { EventBits_t uxOriginalBitValue , uxReturn ; EventGroup_t * pxEventBits = xEventGroup ; BaseType_t xAlreadyYielded ; BaseType_t xTimeoutOccurred = pdFALSE ; configASSERT ( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 ) ; configASSERT ( uxBitsToWaitFor != 0 ) ; { configASSERT ( ! ( ( xTaskGetSchedulerState ( ) == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) ) ; } vTaskSuspendAll ( ) ; { uxOriginalBitValue = pxEventBits -> uxEventBits ; ( void ) xEventGroupSetBits ( xEventGroup , uxBitsToSet ) ; if ( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor ) { uxReturn = ( uxOriginalBitValue | uxBitsToSet ) ; pxEventBits -> uxEventBits &= ~ uxBitsToWaitFor ; xTicksToWait = 0 ; } else { if ( xTicksToWait != ( TickType_t ) 0 ) { traceEVENT_GROUP_SYNC_BLOCK ( xEventGroup , uxBitsToSet , uxBitsToWaitFor ) ; vTaskPlaceOnUnorderedEventList ( & ( pxEventBits -> xTasksWaitingForBits ) , ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ) , xTicksToWait ) ; uxReturn = 0 ; } else { uxReturn = pxEventBits -> uxEventBits ; xTimeoutOccurred = pdTRUE ; } } } xAlreadyYielded = xTaskResumeAll ( ) ; if ( xTicksToWait != ( TickType_t ) 0 ) { if ( xAlreadyYielded == pdFALSE ) { portYIELD_WITHIN_API ( ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } uxReturn = uxTaskResetEventItemValue ( ) ; if ( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 ) { taskENTER_CRITICAL ( ) ; { uxReturn = pxEventBits -> uxEventBits ; if ( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor ) { pxEventBits -> uxEventBits &= ~ uxBitsToWaitFor ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } taskEXIT_CRITICAL ( ) ; xTimeoutOccurred = pdTRUE ; } else { } uxReturn &= ~ eventEVENT_BITS_CONTROL_BYTES ; } traceEVENT_GROUP_SYNC_END ( xEventGroup , uxBitsToSet , uxBitsToWaitFor , xTimeoutOccurred ) ; ( void ) xTimeoutOccurred ; return uxReturn ; } 