static void sh_funct ( Shell_t * shp , Namval_t * np , int argn , char * argv [ ] , struct argnod * envlist , int execflg ) { struct funenv fun ; char * fname = nv_getval ( SH_FUNNAMENOD ) ; struct Level * lp = ( Level * ) ( SH_LEVELNOD -> nvfun ) ; int level , pipepid = shp -> pipepid , comsub = shp -> comsub ; shp -> comsub = 0 ; shp -> pipepid = 0 ; sh_stats ( STAT_FUNCT ) ; if ( ! lp -> hdr . disc ) { lp = init_level ( shp , 0 ) ; } if ( ( sh_scoped * ) shp -> topscope != shp -> st . self ) { sh_setscope ( shp -> topscope ) ; } level = lp -> maxlevel = shp -> dot_depth + shp -> fn_depth + 1 ; SH_LEVELNOD -> nvalue . s = lp -> maxlevel ; shp -> st . lineno = error_info . line ; np -> nvalue . rp -> running += 2 ; if ( nv_isattr ( np , NV_FPOSIX ) ) { char * save ; int loopcnt = shp -> st . loopcnt ; shp -> posix_fun = np ; save = argv [ - 1 ] ; argv [ - 1 ] = 0 ; shp -> st . funname = nv_name ( np ) ; shp -> last_root = nv_dict ( DOTSHNOD ) ; nv_putval ( SH_FUNNAMENOD , nv_name ( np ) , NV_NOFREE ) ; opt_info . index = opt_info . offset = 0 ; error_info . errors = 0 ; shp -> st . loopcnt = 0 ; b_dot_cmd ( argn + 1 , argv - 1 , & shp -> bltindata ) ; shp -> st . loopcnt = loopcnt ; argv [ - 1 ] = save ; } else { fun . env = envlist ; fun . node = np ; fun . nref = 0 ; sh_funscope ( argn , argv , 0 , & fun , execflg ) ; } if ( level -- != nv_getnum ( SH_LEVELNOD ) ) { Shscope_t * sp = sh_getscope ( 0 , SEEK_END ) ; sh_setscope ( sp , NULL ) ; } lp -> maxlevel = level ; SH_LEVELNOD -> nvalue . s = lp -> maxlevel ; shp -> last_root = nv_dict ( DOTSHNOD ) ; shp -> comsub = comsub ; nv_putval ( SH_FUNNAMENOD , shp -> st . funname , NV_NOFREE ) ; nv_putval ( SH_FUNNAMENOD , fname , NV_NOFREE ) ; nv_putval ( SH_PATHNAMENOD , shp -> st . filename , NV_NOFREE ) ; shp -> pipepid = pipepid ; np -> nvalue . rp -> running -= 2 ; } 