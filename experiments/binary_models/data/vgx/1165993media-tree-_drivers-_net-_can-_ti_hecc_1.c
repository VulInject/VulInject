static int ti_hecc_rx_pkt ( struct ti_hecc_priv * priv , int mbxno ) { struct net_device_stats * stats = & priv -> ndev -> stats ; struct can_frame * cf ; struct sk_buff * skb ; u32 data , mbx_mask ; cfs_time_t flags ; skb = alloc_can_skb ( priv -> ndev , & cf ) ; if ( ! skb ) { if ( printk_ratelimit ( ) ) { netdev_err ( priv -> ndev , "ti_hecc_rx_pkt: alloc_can_skb() failed\n" ) ; } return - ENOMEM ; } mbx_mask = BIT ( mbxno ) ; data = hecc_read_mbx ( priv , mbxno , HECC_CANMID ) ; if ( data & HECC_CANMID_IDE ) { cf -> can_id = ( data & CAN_EFF_MASK ) | CAN_EFF_FLAG ; } else { cf -> can_id = ( data >> 18 ) & CAN_SFF_MASK ; } data = hecc_read_mbx ( priv , mbxno , HECC_CANMCF ) ; if ( data & HECC_CANMCF_RTR ) { cf -> can_id |= CAN_RTR_FLAG ; } cf -> can_dlc = get_can_dlc ( data & 0xF ) ; data = hecc_read_mbx ( priv , mbxno , HECC_CANMDL ) ; * ( __be32 * ) ( cf -> data ) = cpu_to_be32 ( data ) ; if ( cf -> can_dlc > 4 ) { data = hecc_read_mbx ( priv , mbxno , HECC_CANMDH ) ; * ( __be32 * ) ( cf -> data + 4 ) = cpu_to_be32 ( data ) ; } spin_lock_irqsave ( & priv -> mbx_lock , flags ) ; hecc_clear_bit ( priv , HECC_CANME , mbx_mask ) ; hecc_write ( priv , HECC_CANRMP , mbx_mask ) ; if ( priv -> rx_next < HECC_RX_BUFFER_MBOX ) { hecc_set_bit ( priv , HECC_CANME , mbx_mask ) ; } spin_unlock_irqrestore ( & priv -> mbx_lock , flags ) ; stats -> rx_bytes += cf -> can_dlc ; can_led_event ( priv -> ndev , CAN_LED_EVENT_RX ) ; netif_receive_skb ( skb ) ; stats -> rx_packets ++ ; return 0 ; } 