static sense_reason_t iblock_execute_rw ( struct se_cmd * cmd , struct scatterlist * sgl , u32 sgl_nents , enum dma_data_direction data_direction ) { struct se_device * dev = cmd -> se_dev ; sector_t block_lba = target_to_linux_sector ( dev , cmd -> t_task_lba ) ; struct iblock_req * ibr ; struct bio * bio , * bio_start ; struct bio_list list ; struct scatterlist * sg ; u32 sg_num = sgl_nents ; unsigned bio_cnt ; int i , op , op_flags = 0 ; if ( data_direction == DMA_TO_DEVICE ) { struct iblock_dev * ib_dev = IBLOCK_DEV ( dev ) ; struct request_queue * q = bdev_get_queue ( ib_dev -> ibd_bd ) ; op = REQ_OP_WRITE ; if ( test_bit ( QUEUE_FLAG_FUA , & q -> queue_flags ) ) { if ( cmd -> se_cmd_flags & SCF_FUA ) { op_flags = REQ_FUA ; } if ( ! test_bit ( QUEUE_FLAG_WC , & q -> queue_flags ) ) { op_flags = REQ_FUA ; } } } else { op = REQ_OP_READ ; } ibr = kzalloc ( sizeof ( iblock_req ) , GFP_KERNEL ) ; if ( ! ibr ) { fail } cmd -> priv = ibr ; if ( ! sgl_nents ) { refcount_set ( & ibr -> pending , 1 ) ; iblock_complete_cmd ( cmd ) ; return 0 ; } bio = iblock_get_bio ( cmd , block_lba , sgl_nents , op , op_flags ) ; if ( ! bio ) { fail_free_ibr } bio_start = bio ; bio_list_init ( & list ) ; bio_list_add ( & list , bio ) ; refcount_set ( & ibr -> pending , 2 ) ; bio_cnt = 1 ; for_each_sg ( , , , ) { while ( bio_add_page ( bio , sg_page ( sg ) , sg -> length , sg -> offset ) != sg -> length ) { if ( bio_cnt >= IBLOCK_MAX_BIO_PER_TASK ) { iblock_submit_bios ( & list ) ; bio_cnt = 0 ; } bio = iblock_get_bio ( cmd , block_lba , sg_num , op , op_flags ) ; if ( ! bio ) { fail_put_bios } refcount_inc ( & ibr -> pending ) ; bio_list_add ( & list , bio ) ; bio_cnt ++ ; } block_lba += sg -> length >> IBLOCK_LBA_SHIFT ; sg_num -- ; } if ( cmd -> prot_type && dev -> dev_attrib . pi_prot_type ) { int rc = iblock_alloc_bip ( cmd , bio_start ) ; if ( rc ) { fail_put_bios } } iblock_submit_bios ( & list ) ; iblock_complete_cmd ( cmd ) ; return 0 ; fail_put_bios while ( ( bio = bio_list_pop ( & list ) ) ) { bio_put ( bio ) ; } fail_free_ibr fail return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE ; } 