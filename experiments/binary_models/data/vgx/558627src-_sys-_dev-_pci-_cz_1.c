int cz_intr ( void * arg ) { int rval = 0 ; u_int command , channel , param ; struct cz_softc * cz = arg ; struct cztty_softc * sc ; struct tty * tp ; while ( ( command = ( CZ_PLX_READ ( cz , PLX_LOCAL_PCI_DOORBELL ) & 0xff ) ) ) { rval = 1 ; channel = CZ_FWCTL_READ ( cz , BRDCTL_FWCMD_CHANNEL ) ; param = CZ_FWCTL_READ ( cz , BRDCTL_FWCMD_PARAM ) ; CZ_PLX_WRITE ( cz , PLX_LOCAL_PCI_DOORBELL , command ) ; if ( cz -> cz_ports == NULL ) { printf ( "%s: interrupt on channel %d, but no channels\n" , cz -> cz_dev . dv_xname , channel ) ; continue ; } sc = & cz -> cz_ports [ channel ] ; tp = sc -> sc_tty ; switch ( command ) { case C_CM_TXFEMPTY : case C_CM_TXBEMPTY : case C_CM_TXLOWWM : case C_CM_INTBACK : if ( ! ISSET ( tp -> t_state , TS_ISOPEN ) ) { printf ( "%s: tx intr on closed channel %d\n" , cz -> cz_dev . dv_xname , channel ) ; break ; } if ( cztty_transmit ( sc , tp ) ) { ttwakeup ( tp ) ; wakeup ( tp ) ; } break ; case C_CM_RXNNDT : case C_CM_RXHIWM : case C_CM_INTBACK2 : case C_CM_ICHAR : if ( ! ISSET ( tp -> t_state , TS_ISOPEN ) ) { CZTTY_BUF_WRITE ( sc , BUFCTL_RX_GET , CZTTY_BUF_READ ( sc , BUFCTL_RX_PUT ) ) ; break ; } if ( cztty_receive ( sc , tp ) ) { ttwakeup ( tp ) ; wakeup ( tp ) ; } break ; case C_CM_MDCD : if ( ! ISSET ( tp -> t_state , TS_ISOPEN ) ) { break ; } ( void ) ( * linesw [ tp -> t_line ] . l_modem ) ( tp , ISSET ( C_RS_DCD , CZTTY_CHAN_READ ( sc , CHNCTL_RS_STATUS ) ) ) ; break ; case C_CM_MDSR : case C_CM_MRI : case C_CM_MCTS : case C_CM_MRTS : break ; case C_CM_IOCTLW : break ; case C_CM_PR_ERROR : sc -> sc_parity_errors ++ ; error_common case C_CM_FR_ERROR : sc -> sc_framing_errors ++ ; error_common case C_CM_OVR_ERROR : sc -> sc_overflows ++ ; error_common if ( sc -> sc_errors ++ == 0 ) { timeout_add_sec ( & sc -> sc_diag_to , 60 ) ; } break ; case C_CM_RXBRK : if ( ! ISSET ( tp -> t_state , TS_ISOPEN ) ) { break ; } ( * linesw [ tp -> t_line ] . l_rint ) ( TTY_FE , tp ) ; ttwakeup ( tp ) ; wakeup ( tp ) ; break ; default : printf ( "%s: channel %d: Unknown interrupt 0x%x\n" , cz -> cz_dev . dv_xname , sc -> sc_channel , command ) ; break ; } } return ( rval ) ; } 