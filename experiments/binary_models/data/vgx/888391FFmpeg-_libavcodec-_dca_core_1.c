static int filter_frame_float ( DCACoreDecoder * s , AVFrame * frame ) { AVCodecContext * avctx = s -> avctx ; int x96_nchannels = 0 , x96_synth = 0 ; int i , n , ch , ret , spkr , nsamples , nchannels ; float * output_samples [ DCA_SPEAKER_COUNT ] { NULL } ; , * ptr ; const float * filter_coeff ; if ( s -> ext_audio_mask & ( DCA_CSS_X96 | DCA_EXSS_X96 ) ) { x96_nchannels = s -> x96_nchannels ; x96_synth = 1 ; } avctx -> sample_rate = s -> sample_rate << x96_synth ; avctx -> sample_fmt = AV_SAMPLE_FMT_FLTP ; avctx -> bits_per_raw_sample = 0 ; frame -> nb_samples = nsamples = ( s -> npcmblocks * DCA_PCMBLOCK_SAMPLES ) << x96_synth ; if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) { return ret ; } for ( i = 0 ; i < avctx -> ch_layout . nb_channels ; i ++ ) { output_samples [ s -> ch_remap [ i ] ] = ( float * ) frame -> extended_data [ i ] ; } nchannels = av_popcount ( s -> ch_mask ) - avctx -> ch_layout . nb_channels ; if ( nchannels > 0 ) { av_fast_malloc ( & s -> output_buffer , & s -> output_size , nsamples * nchannels * sizeof ( float ) ) ; if ( ! s -> output_buffer ) { return AVERROR ( ENOMEM ) ; } ptr = ( float * ) s -> output_buffer ; for ( spkr = 0 ; spkr < DCA_SPEAKER_COUNT ; spkr ++ ) { if ( output_samples [ spkr ] ) { continue ; } output_samples [ spkr ] = ptr ; ptr += nsamples ; } } set_filter_mode ( s , x96_synth ) ; if ( x96_synth ) { filter_coeff = ff_dca_fir_64bands ; } if ( s -> filter_perfect ) { filter_coeff = ff_dca_fir_32bands_perfect ; } else { filter_coeff = ff_dca_fir_32bands_nonperfect ; } for ( ch = 0 ; ch < s -> nchannels ; ch ++ ) { spkr = map_prm_ch_to_spkr ( s , ch ) ; if ( spkr < 0 ) { return AVERROR ( EINVAL ) ; } s -> dcadsp -> sub_qmf_float [ x96_synth ] ( & s -> synth , s -> imdct [ x96_synth ] , s -> imdct_fn [ x96_synth ] , output_samples [ spkr ] , s -> subband_samples [ ch ] , ch < x96_nchannels ?s -> x96_subband_samples [ ch ] : NULL , s -> dcadsp_data [ ch ] . u . flt . hist1 , & s -> dcadsp_data [ ch ] . offset , s -> dcadsp_data [ ch ] . u . flt . hist2 , filter_coeff , s -> npcmblocks , 1.0f / ( 1 << ( 17 - x96_synth ) ) ) ; } if ( s -> lfe_present ) { int dec_select = ( s -> lfe_present == DCA_LFE_FLAG_128 ) ; float * samples = output_samples [ DCA_SPEAKER_LFE1 ] ; int nlfesamples = s -> npcmblocks >> ( dec_select + 1 ) ; if ( x96_synth ) { samples += nsamples / 2 ; } if ( dec_select ) { filter_coeff = ff_dca_lfe_fir_128 ; } else { filter_coeff = ff_dca_lfe_fir_64 ; } s -> dcadsp -> lfe_fir_float [ dec_select ] ( samples , s -> lfe_samples + DCA_LFE_HISTORY , filter_coeff , s -> npcmblocks ) ; if ( x96_synth ) { s -> dcadsp -> lfe_x96_float ( output_samples [ DCA_SPEAKER_LFE1 ] , samples , & s -> output_history_lfe_float , nsamples / 2 ) ; } for ( n = DCA_LFE_HISTORY - 1 ; n >= 0 ; n -- ) { s -> lfe_samples [ n ] = s -> lfe_samples [ nlfesamples + n ] ; } } if ( s -> es_format && ( s -> ext_audio_mask & DCA_CSS_XCH ) && s -> audio_mode >= DCA_AMODE_2F2R ) { s -> float_dsp -> vector_fmac_scalar ( output_samples [ DCA_SPEAKER_Ls ] , output_samples [ DCA_SPEAKER_Cs ] , - M_SQRT1_2 , nsamples ) ; s -> float_dsp -> vector_fmac_scalar ( output_samples [ DCA_SPEAKER_Rs ] , output_samples [ DCA_SPEAKER_Cs ] , - M_SQRT1_2 , nsamples ) ; } if ( ( s -> ext_audio_mask & ( DCA_CSS_XXCH | DCA_EXSS_XXCH ) ) && s -> xxch_dmix_embedded ) { float scale_inv = s -> xxch_dmix_scale_inv * ( 1.0f / ( 1 << 16 ) ) ; int * coeff_ptr = s -> xxch_dmix_coeff ; int xch_base = ff_dca_channels [ s -> audio_mode ] ; av_assert1 ( s -> nchannels - xch_base <= DCA_XXCH_CHANNELS_MAX ) ; for ( ch = xch_base ; ch < s -> nchannels ; ch ++ ) { int src_spkr = map_prm_ch_to_spkr ( s , ch ) ; if ( src_spkr < 0 ) { return AVERROR ( EINVAL ) ; } for ( spkr = 0 ; spkr < s -> xxch_mask_nbits ; spkr ++ ) { if ( s -> xxch_dmix_mask [ ch - xch_base ] & ( 1U << spkr ) ) { int coeff = * coeff_ptr ++ ; if ( coeff ) { s -> float_dsp -> vector_fmac_scalar ( output_samples [ spkr ] , output_samples [ src_spkr ] , coeff * ( - 1.0f / ( 1 << 15 ) ) , nsamples ) ; } } } } for ( spkr = 0 ; spkr < s -> xxch_mask_nbits ; spkr ++ ) { if ( s -> xxch_core_mask & ( 1U << spkr ) ) { s -> float_dsp -> vector_fmul_scalar ( output_samples [ spkr ] , output_samples [ spkr ] , scale_inv , nsamples ) ; } } } if ( ! ( s -> ext_audio_mask & ( DCA_CSS_XXCH | DCA_CSS_XCH | DCA_EXSS_XXCH ) ) ) { if ( ( s -> sumdiff_front && s -> audio_mode > DCA_AMODE_MONO ) || s -> audio_mode == DCA_AMODE_STEREO_SUMDIFF ) { s -> float_dsp -> butterflies_float ( output_samples [ DCA_SPEAKER_L ] , output_samples [ DCA_SPEAKER_R ] , nsamples ) ; } if ( s -> sumdiff_surround && s -> audio_mode >= DCA_AMODE_2F2R ) { s -> float_dsp -> butterflies_float ( output_samples [ DCA_SPEAKER_Ls ] , output_samples [ DCA_SPEAKER_Rs ] , nsamples ) ; } } if ( s -> request_mask != s -> ch_mask ) { ff_dca_downmix_to_stereo_float ( s -> float_dsp , output_samples , s -> prim_dmix_coeff , nsamples , s -> ch_mask ) ; } return 0 ; } 