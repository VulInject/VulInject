static int gw_proc_sockaddr_init ( gw_host * const host , gw_proc * const proc , log_error_st * const errh ) { sock_addr addr ; socklen_t addrlen ; if ( proc -> unixsocket ) { if ( 1 != sock_addr_from_str_hints ( & addr , & addrlen , proc -> unixsocket -> ptr , AF_UNIX , 0 , errh ) ) { errno = EINVAL ; return - 1 ; } buffer_clear ( proc -> connection_name ) ; buffer_append_str2 ( proc -> connection_name , CONST_STR_LEN ( "unix:" ) , BUF_PTR_LEN ( proc -> unixsocket ) ) ; } else { force_assert ( host -> host ) ; if ( 1 != sock_addr_from_str_hints ( & addr , & addrlen , host -> host -> ptr , 0 , proc -> port , errh ) ) { errno = EINVAL ; return - 1 ; } if ( host -> host -> size ) { buffer * h ; * ( const buffer * * ) & h = host -> host ; sock_addr_inet_ntop_copy_buffer ( h , & addr ) ; host -> family = sock_addr_get_family ( & addr ) ; } buffer_clear ( proc -> connection_name ) ; buffer_append_str3 ( proc -> connection_name , CONST_STR_LEN ( "tcp:" ) , BUF_PTR_LEN ( host -> host ) , CONST_STR_LEN ( ":" ) ) ; buffer_append_int ( proc -> connection_name , proc -> port ) ; } if ( NULL != proc -> saddr && proc -> saddrlen < addrlen ) { proc -> saddr = NULL ; } if ( NULL == proc -> saddr ) { proc -> saddr = ( sockaddr * ) ck_malloc ( addrlen ) ; } proc -> saddrlen = addrlen ; memcpy ( proc -> saddr , & addr , addrlen ) ; return 0 ; } 