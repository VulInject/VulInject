static int pidlist_array_load ( struct cgroup * cgrp , enum cgroup_filetype type , struct cgroup_pidlist * * lp ) { pid_t * array ; int length ; int pid , n = 0 ; struct css_task_iter it ; struct task_struct * tsk ; struct cgroup_pidlist * l ; lockdep_assert_held ( & cgrp -> pidlist_mutex ) ; length = cgroup_task_count ( cgrp , NULL ) ; array = kvmalloc_array ( length , sizeof ( pid_t ) , GFP_KERNEL ) ; if ( ! array ) { return - ENOMEM ; } css_task_iter_start ( & cgrp -> self , 0 , & it ) ; while ( ( tsk = css_task_iter_next ( & it ) ) ) { if ( unlikely ( n == length ) ) { break ; } if ( type == CGROUP_FILE_PROCS ) { pid = task_tgid_vnr ( tsk ) ; } else { pid = task_pid_vnr ( tsk ) ; } if ( pid > 0 ) { array [ n ++ ] = pid ; } } css_task_iter_end ( & it ) ; length = n ; sort ( array , length , sizeof ( pid_t ) , cmppid , NULL ) ; if ( type == CGROUP_FILE_PROCS ) { length = pidlist_uniq ( array , length ) ; } l = cgroup_pidlist_find_create ( cgrp , type ) ; if ( ! l ) { kvfree ( array ) ; return - ENOMEM ; } kvfree ( l -> list ) ; l -> list = array ; l -> length = length ; * lp = l ; return 0 ; } 