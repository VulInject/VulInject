static int fun_probe ( struct platform_device * ofdev ) { struct fsl_upm_nand * fun ; struct resource io_res ; const __be32 * prop ; int rnb_gpio ; int ret ; int size ; int i ; fun = kzalloc ( sizeof ( * fun ) , GFP_KERNEL ) ; ret = of_address_to_resource ( ofdev -> dev . of_node , 0 , & io_res ) ; if ( ret ) { dev_err ( & ofdev -> dev , "can't get IO base\n" ) ; err1 } ret = fsl_upm_find ( io_res . start , & fun -> upm ) ; if ( ret ) { dev_err ( & ofdev -> dev , "can't find UPM\n" ) ; err1 } prop = of_get_property ( ofdev -> dev . of_node , "fsl,upm-addr-offset" , & size ) ; if ( ! prop || size != sizeof ( uint32_t ) ) { dev_err ( & ofdev -> dev , "can't get UPM address offset\n" ) ; ret = - EINVAL ; err1 } fun -> upm_addr_offset = * prop ; prop = of_get_property ( ofdev -> dev . of_node , "fsl,upm-cmd-offset" , & size ) ; if ( ! prop || size != sizeof ( uint32_t ) ) { dev_err ( & ofdev -> dev , "can't get UPM command offset\n" ) ; ret = - EINVAL ; err1 } fun -> upm_cmd_offset = * prop ; prop = of_get_property ( ofdev -> dev . of_node , "fsl,upm-addr-line-cs-offsets" , & size ) ; if ( prop && ( size / sizeof ( uint32_t ) ) > 0 ) { fun -> mchip_count = size / sizeof ( uint32_t ) ; if ( fun -> mchip_count >= NAND_MAX_CHIPS ) { dev_err ( & ofdev -> dev , "too much multiple chips\n" ) ; err1 } for ( i = 0 ; i < fun -> mchip_count ; i ++ ) { fun -> mchip_offsets [ i ] = be32_to_cpu ( prop [ i ] ) ; } } else { fun -> mchip_count = 1 ; } for ( i = 0 ; i < fun -> mchip_count ; i ++ ) { fun -> rnb_gpio [ i ] = - 1 ; rnb_gpio = of_get_gpio ( ofdev -> dev . of_node , i ) ; if ( rnb_gpio >= 0 ) { ret = gpio_request ( rnb_gpio , dev_name ( & ofdev -> dev ) ) ; if ( ret ) { dev_err ( & ofdev -> dev , "can't request RNB gpio #%d\n" , i ) ; err2 } gpio_direction_input ( rnb_gpio ) ; fun -> rnb_gpio [ i ] = rnb_gpio ; } if ( rnb_gpio == - EINVAL ) { dev_err ( & ofdev -> dev , "RNB gpio #%d is invalid\n" , i ) ; err2 } } prop = of_get_property ( ofdev -> dev . of_node , "chip-delay" , NULL ) ; if ( prop ) { fun -> chip_delay = be32_to_cpup ( prop ) ; } else { fun -> chip_delay = 50 ; } prop = of_get_property ( ofdev -> dev . of_node , "fsl,upm-wait-flags" , & size ) ; if ( prop && size == sizeof ( uint32_t ) ) { fun -> wait_flags = be32_to_cpup ( prop ) ; } else { fun -> wait_flags = FSL_UPM_WAIT_RUN_PATTERN | FSL_UPM_WAIT_WRITE_BYTE ; } fun -> io_base = devm_ioremap_nocache ( & ofdev -> dev , io_res . start , resource_size ( & io_res ) ) ; if ( ! fun -> io_base ) { ret = - ENOMEM ; err2 } fun -> dev = & ofdev -> dev ; fun -> last_ctrl = NAND_CLE ; ret = fun_chip_init ( fun , ofdev -> dev . of_node , & io_res ) ; if ( ret ) { err2 } dev_set_drvdata ( & ofdev -> dev , fun ) ; return 0 ; err2 for ( i = 0 ; i < fun -> mchip_count ; i ++ ) { if ( fun -> rnb_gpio [ i ] < 0 ) { break ; } gpio_free ( fun -> rnb_gpio [ i ] ) ; } err1 kfree ( fun ) ; return ret ; } 