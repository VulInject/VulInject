static int dcmi_start_dma ( struct stm32_dcmi * dcmi , struct dcmi_buf * buf ) { struct dma_async_tx_descriptor * desc = NULL ; struct dma_slave_config config ; int ret ; config . src_addr = ( dma_addr_t ) dcmi -> res -> start + DCMI_DR ; config . src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES ; config . dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES ; config . dst_maxburst = 4 ; ret = dmaengine_slave_config ( dcmi -> dma_chan , & config ) ; if ( ret < 0 ) { dev_err ( dcmi -> dev , "%s: DMA channel config failed (%d)\n" , __func__ , ret ) ; return ret ; } mutex_lock ( & dcmi -> dma_lock ) ; desc = dmaengine_prep_slave_sg ( dcmi -> dma_chan , buf -> sgt . sgl , buf -> sgt . nents , DMA_DEV_TO_MEM , DMA_PREP_INTERRUPT ) ; if ( ! desc ) { dev_err ( dcmi -> dev , "%s: DMA dmaengine_prep_slave_sg failed\n" , __func__ ) ; mutex_unlock ( & dcmi -> dma_lock ) ; return - EINVAL ; } desc -> callback = dcmi_dma_callback ; desc -> callback_param = dcmi ; dcmi -> dma_cookie = dmaengine_submit ( desc ) ; if ( dma_submit_error ( dcmi -> dma_cookie ) ) { dev_err ( dcmi -> dev , "%s: DMA submission failed\n" , __func__ ) ; mutex_unlock ( & dcmi -> dma_lock ) ; return - ENXIO ; } mutex_unlock ( & dcmi -> dma_lock ) ; dma_async_issue_pending ( dcmi -> dma_chan ) ; return 0 ; } 