M_bool M_bitlist_tohash ( M_hash_stru64_t * * hash_toint , M_hash_u64str_t * * hash_tostr , M_bitlist_flags_t flags , const M_bitlist_t * list , char * error , size_t error_len ) { M_bool rv = M_FALSE ; M_hash_stru64_t * toint = M_hash_stru64_create ( 16 , 75 , ( flags & M_BITLIST_FLAG_CASE_SENSITIVE ) ?M_HASH_STRU64_NONE : M_HASH_STRU64_CASECMP ) ; M_hash_u64str_t * tostr = M_hash_u64str_create ( 16 , 75 , M_HASH_STRU64_NONE ) ; size_t i ; if ( hash_toint == NULL || hash_tostr == NULL || list == NULL ) { M_snprintf ( error , error_len , "invalid use" ) ; done } * hash_toint = NULL ; * hash_tostr = NULL ; for ( i = 0 ; list [ i ] . name != NULL ; i ++ ) { M_bool is_duplicate = M_FALSE ; if ( M_hash_stru64_get ( toint , list [ i ] . name , NULL ) ) { M_snprintf ( error , error_len , "duplicate key name %s" , list [ i ] . name ) ; done } if ( M_hash_u64str_get ( tostr , list [ i ] . id , NULL ) ) { if ( flags & M_BITLIST_FLAG_IGNORE_DUPLICATE_ID ) { is_duplicate = M_TRUE ; } else { M_snprintf ( error , error_len , "duplicate key id %lld" , list [ i ] . id ) ; done } } if ( list [ i ] . id != 0 && ! ( flags & M_BITLIST_FLAG_DONT_REQUIRE_POWEROF2 ) && ! M_uint64_is_power_of_two ( list [ i ] . id ) ) { M_snprintf ( error , error_len , "'%s' is not a power of 2" , list [ i ] . name ) ; done } M_hash_stru64_insert ( toint , list [ i ] . name , list [ i ] . id ) ; if ( ! is_duplicate ) { M_hash_u64str_insert ( tostr , list [ i ] . id , list [ i ] . name ) ; } } * hash_toint = toint ; * hash_tostr = tostr ; toint = NULL ; tostr = NULL ; rv = M_TRUE ; done M_hash_u64str_destroy ( tostr ) ; return rv ; } 