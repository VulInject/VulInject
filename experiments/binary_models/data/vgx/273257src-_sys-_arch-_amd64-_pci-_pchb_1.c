void pchbattach ( struct device * parent , struct device * self , void * aux ) { struct pchb_softc * sc = ( pchb_softc * ) self ; struct pci_attach_args * pa = aux ; struct pcibus_attach_args pba ; pcireg_t bcreg , bir ; u_char pbnum ; pcitag_t tag ; int i , r ; int doattach = 0 ; switch ( PCI_VENDOR ( pa -> pa_id ) ) { case PCI_VENDOR_AMD : printf ( "\n" ) ; switch ( PCI_PRODUCT ( pa -> pa_id ) ) { case PCI_PRODUCT_AMD_0F_HT : case PCI_PRODUCT_AMD_10_HT : for ( i = 0 ; i < AMD64HT_NUM_LDT ; i ++ ) { pchb_amd64ht_attach ( self , pa , i ) ; } break ; } break ; case PCI_VENDOR_INTEL : switch ( PCI_PRODUCT ( pa -> pa_id ) ) { case PCI_PRODUCT_INTEL_82915G_HB : case PCI_PRODUCT_INTEL_82945G_HB : case PCI_PRODUCT_INTEL_82925X_HB : case PCI_PRODUCT_INTEL_82955X_HB : sc -> sc_bt = pa -> pa_memt ; if ( bus_space_map ( sc -> sc_bt , I82802_IOBASE , I82802_IOSIZE , 0 , & sc -> sc_bh ) ) { break ; } if ( ! ( bus_space_read_1 ( sc -> sc_bt , sc -> sc_bh , I82802_RNG_HWST ) & I82802_RNG_HWST_PRESENT ) ) { break ; } bus_space_write_1 ( sc -> sc_bt , sc -> sc_bh , I82802_RNG_HWST , bus_space_read_1 ( sc -> sc_bt , sc -> sc_bh , I82802_RNG_HWST ) | I82802_RNG_HWST_ENABLE ) ; for ( i = 1000 ; i -- && ! ( bus_space_read_1 ( sc -> sc_bt , sc -> sc_bh , I82802_RNG_RNGST ) & I82802_RNG_RNGST_DATAV ) ; ) { DELAY ( 10 ) ; } if ( ! ( bus_space_read_1 ( sc -> sc_bt , sc -> sc_bh , I82802_RNG_RNGST ) & I82802_RNG_RNGST_DATAV ) ) { break ; } r = bus_space_read_1 ( sc -> sc_bt , sc -> sc_bh , I82802_RNG_DATA ) ; timeout_set ( & sc -> sc_rng_to , pchb_rnd , sc ) ; sc -> sc_rng_i = 4 ; pchb_rnd ( sc ) ; break ; } printf ( "\n" ) ; break ; case PCI_VENDOR_VIATECH : switch ( PCI_PRODUCT ( pa -> pa_id ) ) { case PCI_PRODUCT_VIATECH_VT8251_PCIE_0 : tag = pci_make_tag ( pa -> pa_pc , 0 , 17 , 7 ) ; bcreg = pci_conf_read ( pa -> pa_pc , tag , 0xfc ) ; bcreg &= ~ 0x00000004 ; pci_conf_write ( pa -> pa_pc , tag , 0xfc , bcreg ) ; bir = pci_conf_read ( pa -> pa_pc , pa -> pa_tag , PPB_REG_BUSINFO ) ; pbnum = PPB_BUSINFO_PRIMARY ( bir ) ; if ( pbnum > 0 ) { doattach = 1 ; } bcreg |= 0x00000004 ; pci_conf_write ( pa -> pa_pc , tag , 0xfc , bcreg ) ; break ; } printf ( "\n" ) ; break ; default : printf ( "\n" ) ; break ; } if ( pci_get_capability ( pa -> pa_pc , pa -> pa_tag , PCI_CAP_AGP , NULL , NULL ) != 0 ) { struct agp_attach_args aa ; aa . aa_busname = "agp" ; aa . aa_pa = pa ; config_found ( self , & aa , agpdev_print ) ; } if ( doattach == 0 ) { return ; } bzero ( & pba , sizeof ( pba ) ) ; pba . pba_busname = "pci" ; pba . pba_iot = pa -> pa_iot ; pba . pba_memt = pa -> pa_memt ; pba . pba_dmat = pa -> pa_dmat ; pba . pba_busex = pa -> pa_busex ; pba . pba_domain = pa -> pa_domain ; pba . pba_bus = pbnum ; pba . pba_pc = pa -> pa_pc ; config_found ( self , & pba , pchb_print ) ; } 