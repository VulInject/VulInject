static void trace_drop_common ( struct sk_buff * skb , void * location ) { struct net_dm_alert_msg * msg ; struct net_dm_drop_point * point ; struct nlmsghdr * nlh ; struct nlattr * nla ; int i ; struct sk_buff * dskb ; struct per_cpu_dm_data * data ; unsigned long flags ; local_irq_save ( flags ) ; data = this_cpu_ptr ( & dm_cpu_data ) ; spin_lock ( & data -> lock ) ; dskb = data -> skb ; if ( ! dskb ) { out } nlh = ( nlmsghdr * ) dskb -> data ; nla = genlmsg_data ( nlmsg_data ( nlh ) ) ; msg = nla_data ( nla ) ; point = msg -> points ; for ( i = 0 ; i < msg -> entries ; i ++ ) { if ( ! memcmp ( & location , & point -> pc , sizeof ( void * ) ) ) { point -> count ++ ; out } point ++ ; } __nla_reserve_nohdr ( dskb , sizeof ( net_dm_drop_point ) ) ; nla -> nla_len += NLA_ALIGN ( sizeof ( net_dm_drop_point ) ) ; memcpy ( point -> pc , & location , sizeof ( void * ) ) ; point -> count = 1 ; msg -> entries ++ ; if ( ! timer_pending ( & data -> send_timer ) ) { data -> send_timer . expires = jiffies + dm_delay * HZ ; add_timer ( & data -> send_timer ) ; } out spin_unlock_irqrestore ( & data -> lock , flags ) ; } 