static int nft_lookup_init ( const struct nft_ctx * ctx , const struct nft_expr * expr , const struct nlattr * const tb [ ] ) { struct nft_lookup * priv = nft_expr_priv ( expr ) ; u8 genmask = nft_genmask_next ( ctx -> net ) ; struct nft_set * set ; u32 flags ; int err ; if ( tb [ NFTA_LOOKUP_SET ] == NULL || tb [ NFTA_LOOKUP_SREG ] == NULL ) { return - EINVAL ; } set = nft_set_lookup_global ( ctx -> net , ctx -> table , tb [ NFTA_LOOKUP_SET ] , tb [ NFTA_LOOKUP_SET_ID ] , genmask ) ; if ( IS_ERR ( set ) ) { return PTR_ERR ( set ) ; } err = nft_parse_register_load ( tb [ NFTA_LOOKUP_SREG ] , & priv -> sreg , set -> klen ) ; if ( err < 0 ) { return err ; } if ( tb [ NFTA_LOOKUP_FLAGS ] ) { flags = ntohl ( nla_get_be32 ( tb [ NFTA_LOOKUP_FLAGS ] ) ) ; if ( flags & ~ NFT_LOOKUP_F_INV ) { return - EINVAL ; } if ( flags & NFT_LOOKUP_F_INV ) { priv -> invert = true ; } } if ( tb [ NFTA_LOOKUP_DREG ] != NULL ) { if ( priv -> invert ) { return - EINVAL ; } if ( ! ( set -> flags & NFT_SET_MAP ) ) { return - EINVAL ; } err = nft_parse_register_store ( ctx , tb [ NFTA_LOOKUP_DREG ] , & priv -> dreg , NULL , set -> dtype , set -> dlen ) ; if ( err < 0 ) { return err ; } } if ( set -> flags & NFT_SET_MAP ) { return - EINVAL ; } priv -> binding . flags = set -> flags & NFT_SET_MAP ; err = nf_tables_bind_set ( ctx , set , & priv -> binding ) ; if ( err < 0 ) { return err ; } priv -> set = set ; return 0 ; } 