static int omap_hwspinlock_probe ( struct platform_device * pdev ) { struct device_node * node = pdev -> dev . of_node ; struct hwspinlock_device * bank ; struct hwspinlock * hwlock ; void __iomem * io_base ; int num_locks , i , ret ; int base_id = 0 ; io_base = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( io_base ) ) { return PTR_ERR ( io_base ) ; } pm_runtime_enable ( & pdev -> dev ) ; ret = pm_runtime_resume_and_get ( & pdev -> dev ) ; if ( ret < 0 ) { runtime_err } i = readl ( io_base + SYSSTATUS_OFFSET ) ; i >>= SPINLOCK_NUMLOCKS_BIT_OFFSET ; ret = pm_runtime_put ( & pdev -> dev ) ; if ( ret < 0 ) { runtime_err } if ( hweight_long ( i & 0xf ) != 1 || i > 8 ) { ret = - EINVAL ; runtime_err } num_locks = i * 32 ; bank = devm_kzalloc ( & pdev -> dev , struct_size ( bank , lock , num_locks ) , GFP_KERNEL ) ; if ( ! bank ) { ret = - ENOMEM ; runtime_err } platform_set_drvdata ( pdev , bank ) ; for ( i = 0 , hwlock = & bank -> lock [ 0 ] ; i < num_locks ; i ++ , hwlock ++ ) { hwlock -> priv = io_base + LOCK_BASE_OFFSET + sizeof ( u32 ) * i ; } ret = hwspin_lock_register ( bank , & pdev -> dev , & omap_hwspinlock_ops , base_id , num_locks ) ; if ( ret ) { runtime_err } dev_dbg ( & pdev -> dev , "Registered %d locks with HwSpinlock core\n" , num_locks ) ; return 0 ; runtime_err pm_runtime_disable ( & pdev -> dev ) ; return ret ; } 