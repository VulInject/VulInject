struct ctl_table_header * __register_sysctl_table ( struct ctl_table_set * set , const char * path , struct ctl_table * table ) { struct ctl_table_root * root = set -> dir . header . root ; struct ctl_table_header * header ; const char * name , * nextname ; struct ctl_dir * dir ; struct ctl_table * entry ; struct ctl_node * node ; int nr_entries = 0 ; list_for_each_table_entry ( , ) nr_entries ++ ; header = kzalloc ( sizeof ( ctl_table_header ) + sizeof ( ctl_node ) * nr_entries , GFP_KERNEL_ACCOUNT ) ; if ( ! header ) { return NULL ; } node = ( ctl_node * ) ( header + 1 ) ; init_header ( header , root , set , node , table ) ; if ( sysctl_check_table ( path , table ) ) { fail } spin_lock ( & sysctl_lock ) ; dir = & set -> dir ; dir -> header . nreg ++ ; spin_unlock ( & sysctl_lock ) ; for ( name = path ; name ; name = nextname ) { int namelen ; nextname = strchr ( name , '/' ) ; if ( nextname ) { namelen = nextname - name ; nextname ++ ; } else { namelen = strlen ( name ) ; } if ( namelen == 0 ) { continue ; } dir = get_subdir ( dir , name , namelen ) ; if ( IS_ERR ( dir ) ) { fail } } spin_lock ( & sysctl_lock ) ; if ( insert_header ( dir , header ) ) { fail_put_dir_locked } drop_sysctl_table ( & dir -> header ) ; spin_unlock ( & sysctl_lock ) ; return header ; fail_put_dir_locked drop_sysctl_table ( & dir -> header ) ; spin_unlock ( & sysctl_lock ) ; fail dump_stack ( ) ; return NULL ; } 