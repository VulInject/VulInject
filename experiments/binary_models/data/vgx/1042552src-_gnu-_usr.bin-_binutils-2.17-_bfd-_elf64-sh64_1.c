sh64_elf64_finish_dynamic_sections ( , ) { bfd * dynobj ; asection * sgot ; asection * sdyn ; dynobj = elf_hash_table ( info ) -> dynobj ; sgot = bfd_get_section_by_name ( dynobj , ".got.plt" ) ; sdyn = bfd_get_section_by_name ( dynobj , ".dynamic" ) ; if ( elf_hash_table ( info ) -> dynamic_sections_created ) { asection * splt ; Elf64_External_Dyn * dyncon , * dynconend ; BFD_ASSERT ( sdyn != NULL ) ; dyncon = ( Elf64_External_Dyn * ) sdyn -> contents ; dynconend = ( Elf64_External_Dyn * ) ( sdyn -> contents + sdyn -> size ) ; for ( ; dyncon < dynconend ; dyncon ++ ) { Elf_Internal_Dyn dyn ; const char * name ; asection * s ; struct elf_link_hash_entry * h ; bfd_elf64_swap_dyn_in ( dynobj , dyncon , & dyn ) ; switch ( dyn . d_tag ) { default : break ; case DT_INIT : name = info -> init_function ; get_sym case DT_FINI : name = info -> fini_function ; get_sym if ( dyn . d_un . d_val != 0 ) { h = elf_link_hash_lookup ( elf_hash_table ( info ) , name , FALSE , FALSE , TRUE ) ; if ( h != NULL && ( h -> other & STO_SH5_ISA32 ) ) { dyn . d_un . d_val |= 1 ; bfd_elf64_swap_dyn_out ( output_bfd , & dyn , dyncon ) ; } } break ; case DT_PLTGOT : name = ".got" ; get_vma case DT_JMPREL : name = ".rela.plt" ; get_vma s = bfd_get_section_by_name ( output_bfd , name ) ; BFD_ASSERT ( s != NULL ) ; dyn . d_un . d_ptr = s -> vma ; bfd_elf64_swap_dyn_out ( output_bfd , & dyn , dyncon ) ; break ; case DT_PLTRELSZ : s = bfd_get_section_by_name ( output_bfd , ".rela.plt" ) ; BFD_ASSERT ( s != NULL ) ; dyn . d_un . d_val = s -> size ; bfd_elf64_swap_dyn_out ( output_bfd , & dyn , dyncon ) ; break ; case DT_RELASZ : s = bfd_get_section_by_name ( output_bfd , ".rela.plt" ) ; if ( s != NULL ) { dyn . d_un . d_val -= s -> size ; } bfd_elf64_swap_dyn_out ( output_bfd , & dyn , dyncon ) ; break ; } } splt = bfd_get_section_by_name ( dynobj , ".plt" ) ; if ( splt && splt -> size > 0 ) { if ( info -> shared ) { if ( elf_sh64_pic_plt_entry == NULL ) { elf_sh64_pic_plt_entry = ( bfd_big_endian ( output_bfd ) ?elf_sh64_pic_plt_entry_be : elf_sh64_pic_plt_entry_le ) ; } memcpy ( splt -> contents , elf_sh64_pic_plt_entry , elf_sh64_sizeof_plt ( info ) ) ; } else { if ( elf_sh64_plt0_entry == NULL ) { elf_sh64_plt0_entry = ( bfd_big_endian ( output_bfd ) ?elf_sh64_plt0_entry_be : elf_sh64_plt0_entry_le ) ; } memcpy ( splt -> contents , elf_sh64_plt0_entry , PLT_ENTRY_SIZE ) ; movi_3shori_putval ( output_bfd , sgot -> output_section -> vma + sgot -> output_offset , splt -> contents + elf_sh64_plt0_gotplt_offset ( info ) ) ; } elf_section_data ( splt -> output_section ) -> this_hdr . sh_entsize = 8 ; } } if ( sgot -> size > 0 ) { if ( sdyn == NULL ) { bfd_put_64 ( output_bfd , ( bfd_vma ) 0 , sgot -> contents ) ; } else { bfd_put_64 ( output_bfd , sdyn -> output_section -> vma + sdyn -> output_offset , sgot -> contents ) ; } bfd_put_64 ( output_bfd , ( bfd_vma ) 0 , sgot -> contents + 8 ) ; bfd_put_64 ( output_bfd , ( bfd_vma ) 0 , sgot -> contents + 16 ) ; } elf_section_data ( sgot -> output_section ) -> this_hdr . sh_entsize = 8 ; return TRUE ; } 