static struct bgp_path_info * bgp4PathAttrLookup ( struct variable * v , oid name [ ] , size_t * length , struct bgp * bgp , struct prefix_ipv4 * addr , int exact ) { oid * offset ; int offsetlen ; struct bgp_path_info * path ; struct bgp_path_info * min ; struct bgp_dest * dest ; union sockunion su ; unsigned int len ; struct in_addr paddr ; sockunion_init ( & su ) ; if ( exact ) { if ( * length - v -> namelen != BGP_PATHATTR_ENTRY_OFFSET ) { return NULL ; } offset = name + v -> namelen ; oid2in_addr ( offset , IN_ADDR_SIZE , & addr -> prefix ) ; offset += IN_ADDR_SIZE ; addr -> prefixlen = * offset ; offset ++ ; su . sin . sin_family = AF_INET ; oid2in_addr ( offset , IN_ADDR_SIZE , & su . sin . sin_addr ) ; dest = bgp_node_lookup ( bgp -> rib [ AFI_IP ] [ SAFI_UNICAST ] , ( prefix * ) addr ) ; if ( dest ) { for ( path = bgp_dest_get_bgp_path_info ( dest ) ; path ; path = path -> next ) { if ( sockunion_same ( & path -> peer -> su , & su ) ) { return path ; } } bgp_dest_unlock_node ( dest ) ; } } else { offset = name + v -> namelen ; offsetlen = * length - v -> namelen ; len = offsetlen ; if ( offsetlen == 0 ) { dest = bgp_table_top ( bgp -> rib [ AFI_IP ] [ SAFI_UNICAST ] ) ; } else { if ( len > IN_ADDR_SIZE ) { len = IN_ADDR_SIZE ; } oid2in_addr ( offset , len , & addr -> prefix ) ; offset += IN_ADDR_SIZE ; offsetlen -= IN_ADDR_SIZE ; if ( offsetlen > 0 ) { addr -> prefixlen = * offset ; } else { addr -> prefixlen = len * 8 ; } dest = bgp_node_get ( bgp -> rib [ AFI_IP ] [ SAFI_UNICAST ] , ( prefix * ) addr ) ; offset ++ ; offsetlen -- ; } if ( offsetlen > 0 ) { len = offsetlen ; if ( len > IN_ADDR_SIZE ) { len = IN_ADDR_SIZE ; } oid2in_addr ( offset , len , & paddr ) ; } else { paddr . s_addr = INADDR_ANY ; } if ( ! dest ) { return in ; } { min = NULL ; for ( path = bgp_dest_get_bgp_path_info ( dest ) ; path ; path = path -> next ) { if ( path -> peer -> su . sin . sin_family == AF_INET && ntohl ( paddr . s_addr ) < ntohl ( path -> peer -> su . sin . sin_addr . s_addr ) ) { if ( min ) { if ( ntohl ( path -> peer -> su . sin . sin_addr . s_addr ) < ntohl ( min -> peer -> su . sin . sin_addr . s_addr ) ) { min = path ; } } else { min = path ; } } } if ( min ) { const struct prefix * rn_p = bgp_dest_get_prefix ( dest ) ; * length = v -> namelen + BGP_PATHATTR_ENTRY_OFFSET ; offset = name + v -> namelen ; oid_copy_in_addr ( offset , & rn_p -> u . prefix4 ) ; offset += IN_ADDR_SIZE ; * offset = rn_p -> prefixlen ; offset ++ ; oid_copy_in_addr ( offset , & min -> peer -> su . sin . sin_addr ) ; addr -> prefix = rn_p -> u . prefix4 ; addr -> prefixlen = rn_p -> prefixlen ; bgp_dest_unlock_node ( dest ) ; return min ; } paddr . s_addr = INADDR_ANY ; } ( dest = bgp_route_next ( dest ) ) != NULL ; } return NULL ; } 