ucontact_t * new_ucontact ( str * _dom , str * _aor , str * _contact , ucontact_info_t * _ci ) { ucontact_t * c ; if ( unlikely ( _ci -> ruid . len <= 0 ) ) { LM_ERR ( "no ruid for aor: %.*s\n" , _aor -> len , ZSW ( _aor -> s ) ) ; return 0 ; } c = ( ucontact_t * ) shm_malloc ( sizeof ( ucontact_t ) ) ; if ( ! c ) { SHM_MEM_ERROR ; return 0 ; } if ( shm_str_dup ( & c -> c , _contact ) < 0 ) { error } if ( shm_str_dup ( & c -> callid , _ci -> callid ) < 0 ) { error } if ( shm_str_dup ( & c -> user_agent , _ci -> user_agent ) < 0 ) { error } if ( _ci -> received . s && _ci -> received . len ) { if ( shm_str_dup ( & c -> received , & _ci -> received ) < 0 ) { error } } if ( _ci -> path && _ci -> path -> len ) { if ( shm_str_dup ( & c -> path , _ci -> path ) < 0 ) { error } } if ( _ci -> ruid . s && _ci -> ruid . len ) { if ( shm_str_dup ( & c -> ruid , & _ci -> ruid ) < 0 ) { error } } if ( _ci -> instance . s && _ci -> instance . len ) { if ( shm_str_dup ( & c -> instance , & _ci -> instance ) < 0 ) { error } } c -> domain = _dom ; c -> aor = _aor ; c -> expires = _ci -> expires ; c -> q = _ci -> q ; c -> sock = _ci -> sock ; c -> cseq = _ci -> cseq ; c -> state = CS_NEW ; c -> flags = _ci -> flags ; c -> cflags = _ci -> cflags ; c -> methods = _ci -> methods ; c -> reg_id = _ci -> reg_id ; c -> last_modified = _ci -> last_modified ; c -> last_keepalive = time ( NULL ) ; c -> tcpconn_id = _ci -> tcpconn_id ; c -> server_id = _ci -> server_id ; c -> keepalive = ( _ci -> cflags & ul_nat_bflag ) ?1 : 0 ; ucontact_xavp_store ( c ) ; return c ; error SHM_MEM_ERROR ; if ( c -> path . s ) { shm_free ( c -> path . s ) ; } if ( c -> received . s ) { shm_free ( c -> received . s ) ; } if ( c -> user_agent . s ) { shm_free ( c -> user_agent . s ) ; } if ( c -> callid . s ) { shm_free ( c -> callid . s ) ; } if ( c -> c . s ) { shm_free ( c -> c . s ) ; } if ( c -> ruid . s ) { shm_free ( c -> ruid . s ) ; } if ( c -> instance . s ) { shm_free ( c -> instance . s ) ; } if ( c -> xavp ) { xavp_destroy_list ( & c -> xavp ) ; } shm_free ( c ) ; return 0 ; } 