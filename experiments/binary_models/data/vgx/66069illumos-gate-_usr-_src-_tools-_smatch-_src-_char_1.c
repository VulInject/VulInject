struct token * get_string_constant ( struct token * token , struct expression * expr ) { struct string * string = token -> string ; struct token * next = token -> next , * done = NULL ; int stringtype = token_type ( token ) ; int is_wide = stringtype == TOKEN_WIDE_STRING ; static char buffer [ MAX_STRING ] ; int len = 0 ; int bits ; int esc_count = 0 ; while ( ! done ) { switch ( token_type ( next ) ) { case TOKEN_WIDE_STRING : is_wide = 1 ; case TOKEN_STRING : next = next -> next ; break ; default : done = next ; } } bits = is_wide ?wchar_ctype -> bit_size : bits_in_char ; while ( token != done ) { int v ; const char * p = token -> string -> data ; const char * end = p + token -> string -> length - 1 ; while ( p < end ) { if ( * p == '\\' ) { esc_count ++ ; } p = parse_escape ( p , & v , end , bits , token -> pos ) ; if ( len < MAX_STRING ) { buffer [ len ] = v ; } len ++ ; } token = token -> next ; } if ( len > MAX_STRING ) { warning ( token -> pos , "trying to concatenate %d-character string (%d bytes max)" , len , MAX_STRING ) ; len = MAX_STRING ; } if ( esc_count || len >= string -> length ) { if ( string -> immutable || len >= string -> length ) { string = __alloc_string ( len + 1 ) ; } string -> length = len + 1 ; memcpy ( string -> data , buffer , len ) ; string -> data [ len ] = '\0' ; } expr -> string = string ; expr -> wide = is_wide ; return token ; } 