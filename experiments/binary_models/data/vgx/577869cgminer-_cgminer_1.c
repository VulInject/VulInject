static void * longpoll_thread ( void * userdata ) { struct pool * cp = ( pool * ) userdata ; struct timeval start , reply , end ; struct pool * pool = NULL ; char threadname [ 16 ] ; CURL * curl = NULL ; int failures = 0 ; char lpreq [ 1024 ] ; char * lp_url ; int rolltime ; sprintf ( threadname , "%d/Longpoll" , cp -> pool_no ) ; RenameThread ( threadname ) ; retry_pool pool = select_longpoll_pool ( cp ) ; if ( ! pool ) { applog ( LOG_WARNING , "No suitable long-poll found for %s" , cp -> rpc_url ) ; while ( ! pool ) { cgsleep_ms ( 60000 ) ; pool = select_longpoll_pool ( cp ) ; } } if ( pool -> has_stratum ) { applog ( LOG_WARNING , "Block change for %s detection via %s stratum" , cp -> rpc_url , pool -> rpc_url ) ; out } if ( pool -> gbt_solo ) { applog ( LOG_WARNING , "Block change for %s detection via getblockcount polling" , cp -> rpc_url ) ; while ( 42 ) { json_t * val , * res_val = NULL ; if ( unlikely ( pool -> removed ) ) { return NULL ; } cgtime ( & start ) ; wait_lpcurrent ( cp ) ; sprintf ( lpreq , "{\"id\": 0, \"method\": \"getblockcount\"}\n" ) ; get_gbt_curl ( pool , 500 ) ; curl_easy_setopt ( pool -> gbt_curl , CURLOPT_FORBID_REUSE , 0 ) ; val = json_rpc_call ( pool -> gbt_curl , pool -> rpc_url , pool -> rpc_userpass , lpreq , true , false , & rolltime , pool , false ) ; release_gbt_curl ( pool ) ; if ( likely ( val ) ) { res_val = json_object_get ( val , "result" ) ; } if ( likely ( res_val ) ) { int height = json_integer_value ( res_val ) ; const char * prev_hash ; failures = 0 ; json_decref ( val ) ; if ( height >= cp -> height ) { applog ( LOG_WARNING , "Block height change to %d detected on pool %d" , height , cp -> pool_no ) ; update_gbt_solo ( pool ) ; continue ; } sprintf ( lpreq , "{\"id\": 0, \"method\": \"getblockhash\", \"params\": [%d]}\n" , height ) ; get_gbt_curl ( pool , 500 ) ; curl_easy_setopt ( pool -> gbt_curl , CURLOPT_FORBID_REUSE , 1 ) ; val = json_rpc_call ( pool -> gbt_curl , pool -> rpc_url , pool -> rpc_userpass , lpreq , true , false , & rolltime , pool , false ) ; release_gbt_curl ( pool ) ; if ( val ) { prev_hash = json_string_value ( json_object_get ( val , "result" ) ) ; if ( unlikely ( prev_hash && strncasecmp ( prev_hash + 56 , pool -> prev_hash , 8 ) ) ) { applog ( LOG_WARNING , "Mining on orphan branch detected, switching!" ) ; update_gbt_solo ( pool ) ; } json_decref ( val ) ; } cgsleep_ms ( 500 ) ; } else { if ( val ) { json_decref ( val ) ; } cgtime ( & end ) ; if ( end . tv_sec - start . tv_sec > 30 ) { continue ; } if ( failures == 1 ) { applog ( LOG_WARNING , "longpoll failed for %s, retrying every 30s" , lp_url ) ; } cgsleep_ms ( 30000 ) ; } } } curl = curl_easy_init ( ) ; if ( unlikely ( ! curl ) ) { quit ( 1 , "Longpoll CURL initialisation failed" ) ; } have_longpoll = true ; wait_lpcurrent ( cp ) ; lp_url = pool -> rpc_url ; applog ( LOG_WARNING , "GBT longpoll ID activated for %s" , lp_url ) ; while ( 42 ) { json_t * val , * soval ; wait_lpcurrent ( cp ) ; cgtime ( & start ) ; if ( pool -> has_gbt ) { cg_rlock ( & pool -> gbt_lock ) ; snprintf ( lpreq , sizeof ( lpreq ) , "{\"id\": 0, \"method\": \"getblocktemplate\", \"params\": " "[{\"capabilities\": [\"coinbasetxn\", \"workid\", \"coinbase/append\"], " "\"longpollid\": \"%s\"}]}\n" , pool -> longpollid ) ; cg_runlock ( & pool -> gbt_lock ) ; } curl_easy_setopt ( curl , CURLOPT_FRESH_CONNECT , 1 ) ; val = json_rpc_call ( curl , lp_url , pool -> rpc_userpass , lpreq , false , true , & rolltime , pool , false ) ; cgtime ( & reply ) ; if ( likely ( val ) ) { soval = json_object_get ( json_object_get ( val , "result" ) , "submitold" ) ; if ( soval ) { pool -> submit_old = json_is_true ( soval ) ; } else { pool -> submit_old = false ; } convert_to_work ( val , rolltime , pool , & start , & reply ) ; failures = 0 ; json_decref ( val ) ; } else { cgtime ( & end ) ; if ( end . tv_sec - start . tv_sec > 30 ) { continue ; } if ( failures == 1 ) { applog ( LOG_WARNING , "longpoll failed for %s, retrying every 30s" , lp_url ) ; } cgsleep_ms ( 30000 ) ; } if ( pool != cp ) { pool = select_longpoll_pool ( cp ) ; if ( pool -> has_stratum ) { applog ( LOG_WARNING , "Block change for %s detection via %s stratum" , cp -> rpc_url , pool -> rpc_url ) ; break ; } if ( unlikely ( ! pool ) ) { retry_pool } } if ( unlikely ( pool -> removed ) ) { break ; } } out curl_easy_cleanup ( curl ) ; return NULL ; } 