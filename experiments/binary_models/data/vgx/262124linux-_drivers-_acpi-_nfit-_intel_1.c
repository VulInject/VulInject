static int __maybe_unused intel_security_unlock ( struct nvdimm * nvdimm , const struct nvdimm_key_data * key_data ) { struct nfit_mem * nfit_mem = nvdimm_provider_data ( nvdimm ) ; { int pkg ; struct nd_intel_unlock_unit cmd ; } , nd_cmd = { . pkg = { . nd_command = NVDIMM_INTEL_UNLOCK_UNIT . nd_family = NVDIMM_FAMILY_INTEL . nd_size_in = ND_INTEL_PASSPHRASE_SIZE . nd_size_out = ND_INTEL_STATUS_SIZE . nd_fw_size = ND_INTEL_STATUS_SIZE } } int rc ; if ( ! test_bit ( NVDIMM_INTEL_UNLOCK_UNIT , & nfit_mem -> dsm_mask ) ) { return - ENOTTY ; } memcpy ( nd_cmd . cmd . passphrase , key_data -> data , sizeof ( nd_cmd . cmd . passphrase ) ) ; rc = nvdimm_ctl ( nvdimm , ND_CMD_CALL , & nd_cmd , sizeof ( nd_cmd ) , NULL ) ; if ( rc < 0 ) { return rc ; } switch ( nd_cmd . cmd . status ) { case 0 : break ; case ND_INTEL_STATUS_INVALID_PASS : return - EINVAL ; default : return - EIO ; } return 0 ; } 