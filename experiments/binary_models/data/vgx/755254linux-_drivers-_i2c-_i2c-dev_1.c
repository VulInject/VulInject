static long i2cdev_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct i2c_client * client = file -> private_data ; unsigned long funcs ; dev_dbg ( & client -> adapter -> dev , "ioctl, cmd=0x%02x, arg=0x%02lx\n" , cmd , arg ) ; switch ( cmd ) { case I2C_SLAVE : case I2C_SLAVE_FORCE : if ( ( arg > 0x3ff ) || ( ( ( client -> flags & I2C_M_TEN ) == 0 ) && arg > 0x7f ) ) { return - EINVAL ; } if ( cmd == I2C_SLAVE && i2cdev_check_addr ( client -> adapter , arg ) ) { return - EBUSY ; } client -> addr = arg ; return 0 ; case I2C_TENBIT : if ( arg ) { client -> flags |= I2C_M_TEN ; } else { client -> flags &= ~ I2C_M_TEN ; } return 0 ; case I2C_PEC : if ( arg ) { client -> flags |= I2C_CLIENT_PEC ; } else { client -> flags &= ~ I2C_CLIENT_PEC ; } return 0 ; case I2C_FUNCS : funcs = i2c_get_functionality ( client -> adapter ) ; return put_user ( funcs , ( unsigned long __user * ) arg ) ; case I2C_RDWR : { struct i2c_rdwr_ioctl_data rdwr_arg ; struct i2c_msg * rdwr_pa ; if ( copy_from_user ( & rdwr_arg , ( i2c_rdwr_ioctl_data __user * ) arg , sizeof ( rdwr_arg ) ) ) { return - EFAULT ; } if ( ! rdwr_arg . msgs || rdwr_arg . nmsgs == 0 ) { return - EINVAL ; } if ( rdwr_arg . nmsgs > I2C_RDWR_IOCTL_MAX_MSGS ) { return - EINVAL ; } rdwr_pa = memdup_user ( rdwr_arg . msgs , rdwr_arg . nmsgs * sizeof ( i2c_msg ) ) ; if ( IS_ERR ( rdwr_pa ) ) { return PTR_ERR ( rdwr_pa ) ; } return i2cdev_ioctl_rdwr ( client , rdwr_arg . nmsgs , rdwr_pa ) ; } case I2C_SMBUS : { struct i2c_smbus_ioctl_data data_arg ; if ( copy_from_user ( & data_arg , ( i2c_smbus_ioctl_data __user * ) arg , sizeof ( i2c_smbus_ioctl_data ) ) ) { return - EFAULT ; } return i2cdev_ioctl_smbus ( client , data_arg . read_write , data_arg . command , data_arg . size , data_arg . data ) ; } case I2C_RETRIES : client -> adapter -> retries = arg ; break ; case I2C_TIMEOUT : if ( arg > INT_MAX ) { return - EINVAL ; } client -> adapter -> timeout = msecs_to_jiffies ( arg * 10 ) ; break ; default : return - ENOTTY ; } return 0 ; } 