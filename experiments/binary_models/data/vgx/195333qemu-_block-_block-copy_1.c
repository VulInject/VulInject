static int coroutine_fn block_copy_dirty_clusters ( BlockCopyCallState * call_state ) { BlockCopyState * s = call_state -> s ; int64_t offset = call_state -> offset ; int64_t bytes = call_state -> bytes ; int ret = 0 ; bool found_dirty = false ; int64_t end = offset + bytes ; AioTaskPool * aio = NULL ; assert ( bdrv_get_aio_context ( s -> source -> bs ) == bdrv_get_aio_context ( s -> target -> bs ) ) ; assert ( QEMU_IS_ALIGNED ( offset , s -> cluster_size ) ) ; assert ( QEMU_IS_ALIGNED ( bytes , s -> cluster_size ) ) ; while ( bytes && aio_task_pool_status ( aio ) == 0 && ! qatomic_read ( & call_state -> cancelled ) ) { BlockCopyTask * task ; int64_t status_bytes ; task = block_copy_task_create ( s , call_state , offset , bytes ) ; if ( ! task ) { trace_block_copy_skip_range ( s , offset , bytes ) ; break ; } if ( task -> offset > offset ) { trace_block_copy_skip_range ( s , offset , task -> offset - offset ) ; } found_dirty = true ; ret = block_copy_block_status ( s , task -> offset , task -> bytes , & status_bytes ) ; assert ( ret >= 0 ) ; if ( status_bytes < task -> bytes ) { block_copy_task_shrink ( task , status_bytes ) ; } if ( qatomic_read ( & s -> skip_unallocated ) && ! ( ret & BDRV_BLOCK_ALLOCATED ) ) { block_copy_task_end ( task , 0 ) ; trace_block_copy_skip_range ( s , task -> offset , task -> bytes ) ; offset = task_end ( task ) ; bytes = end - offset ; continue ; } if ( ret & BDRV_BLOCK_ZERO ) { task -> method = COPY_WRITE_ZEROES ; } if ( ! call_state -> ignore_ratelimit ) { uint64_t ns = ratelimit_calculate_delay ( & s -> rate_limit , 0 ) ; if ( ns > 0 ) { block_copy_task_end ( task , - EAGAIN ) ; g_free ( task ) ; qemu_co_sleep_ns_wakeable ( & call_state -> sleep , QEMU_CLOCK_REALTIME , ns ) ; continue ; } } ratelimit_calculate_delay ( & s -> rate_limit , task -> bytes ) ; trace_block_copy_process ( s , task -> offset ) ; co_get_from_shres ( s -> mem , task -> bytes ) ; offset = task_end ( task ) ; bytes = end - offset ; if ( ! aio && bytes ) { aio = aio_task_pool_new ( call_state -> max_workers ) ; } ret = block_copy_task_run ( aio , task ) ; if ( ret < 0 ) { out } } out if ( aio ) { aio_task_pool_wait_all ( aio ) ; assert ( ret >= 0 || aio_task_pool_status ( aio ) < 0 ) ; ret = aio_task_pool_status ( aio ) ; aio_task_pool_free ( aio ) ; } return ret < 0 ?ret : found_dirty ; } 