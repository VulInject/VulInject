pointer_diff ( , ) tree op0 , op1 ; { tree result , folded ; tree restype = ptrdiff_type_node ; tree target_type = TREE_TYPE ( TREE_TYPE ( op0 ) ) ; tree con0 , con1 , lit0 , lit1 ; tree orig_op1 = op1 ; if ( pedantic || warn_pointer_arith ) { if ( TREE_CODE ( target_type ) == VOID_TYPE ) { pedwarn ( "pointer of type `void *' used in subtraction" ) ; } if ( TREE_CODE ( target_type ) == FUNCTION_TYPE ) { pedwarn ( "pointer to a function used in subtraction" ) ; } } con0 = TREE_CODE ( op0 ) == NOP_EXPR ?TREE_OPERAND ( op0 , 0 ) : op0 ; con1 = TREE_CODE ( op1 ) == NOP_EXPR ?TREE_OPERAND ( op1 , 0 ) : op1 ; if ( TREE_CODE ( con0 ) == PLUS_EXPR ) { lit0 = TREE_OPERAND ( con0 , 1 ) ; con0 = TREE_OPERAND ( con0 , 0 ) ; } else { lit0 = integer_zero_node ; } if ( TREE_CODE ( con1 ) == PLUS_EXPR ) { lit1 = TREE_OPERAND ( con1 , 1 ) ; con1 = TREE_OPERAND ( con1 , 0 ) ; } else { lit1 = integer_zero_node ; } if ( operand_equal_p ( con0 , con1 , 0 ) ) { op0 = lit0 ; op1 = lit1 ; } op0 = build_binary_op ( MINUS_EXPR , convert ( restype , op0 ) , convert ( restype , op1 ) , 0 ) ; if ( ! COMPLETE_OR_VOID_TYPE_P ( TREE_TYPE ( TREE_TYPE ( orig_op1 ) ) ) ) { error ( "arithmetic on pointer to an incomplete type" ) ; } op1 = c_size_in_bytes ( target_type , NULL ) ; result = build ( EXACT_DIV_EXPR , restype , op0 , convert ( restype , op1 ) ) ; folded = fold ( result ) ; if ( folded == result ) { TREE_CONSTANT ( folded ) = TREE_CONSTANT ( op0 ) & TREE_CONSTANT ( op1 ) ; } return folded ; } 