bool unbound_resolve ( char * src , const struct ip_info * afi , ip_address * ipaddr , struct logger * logger ) { const int qtype = ( afi == & ipv6_info ) ?28 : 1 ; passert ( dns_ctx != NULL ) ; if ( strlen ( src ) == 0 ) { return diag ( "empty hostname in host lookup" ) ; } struct ub_result * result ; int ugh = ub_resolve ( dns_ctx , src , qtype , 1 , & result ) ; if ( ugh != 0 ) { llog ( RC_LOG , logger , "unbound error: %s" , ub_strerror ( ugh ) ) ; return false ; } if ( result -> bogus ) { llog_error ( logger , 0 , "%s failed DNSSEC validation" , result -> qname ) ; ub_resolve_free ( result ) ; return false ; } if ( ! result -> havedata ) { if ( result -> secure ) { dbg ( "validated reply proves '%s' does not exist" , src ) ; } else { dbg ( "failed to resolve '%s' (%s)" , src , result -> bogus ?"BOGUS" : "insecure" ) ; } ub_resolve_free ( result ) ; return false ; } if ( ! result -> secure ) { dbg ( "warning: %s lookup was not protected by DNSSEC!" , result -> qname ) ; } if ( DBGP ( DBG_TMI ) ) { int i = 0 ; DBG_log ( "The result has:" ) ; DBG_log ( "qname: %s" , result -> qname ) ; DBG_log ( "qtype: %d" , result -> qtype ) ; DBG_log ( "qclass: %d" , result -> qclass ) ; if ( result -> canonname ) { DBG_log ( "canonical name: %s" , result -> canonname ) ; } DBG_log ( "DNS rcode: %d" , result -> rcode ) ; for ( i = 0 ; result -> data [ i ] != NULL ; i ++ ) { DBG_log ( "result data element %d has length %d" , i , result -> len [ i ] ) ; } DBG_log ( "result has %d data element(s)" , i ) ; } passert ( result -> data != NULL ) ; passert ( result -> data [ 0 ] != NULL ) ; passert ( result -> len != NULL ) ; if ( ( size_t ) result -> len [ 0 ] != afi -> ip_size ) { llog_pexpect ( logger , HERE , "dns record is %u bytes, expecting %zu" , result -> len [ 0 ] , afi -> ip_size ) ; ub_resolve_free ( result ) ; return false ; } struct ip_bytes bytes = unset_ip_bytes ; memcpy ( bytes . byte , result -> data [ 0 ] , afi -> ip_size ) ; * ipaddr = address_from_raw ( HERE , afi -> ip_version , bytes ) ; dbg ( "success for %s lookup" , afi -> ip_name ) ; return true ; } 