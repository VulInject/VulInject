static ucode_errno_t ucode_locate_amd ( cpu_t * cp , cpu_ucode_info_t * uinfop , ucode_file_t * ufp ) { char name [ MAXPATHLEN ] ; intptr_t fd ; int count , rc ; ucode_file_amd_t * ucodefp = ufp -> amd ; uint16_t eq_sig = 0 ; if ( ( rc = ucode_equiv_cpu_amd ( cp , & eq_sig ) ) != EM_OK ) { return ( rc ) ; } if ( ucodefp == NULL ) { ucodefp = ucode_zalloc ( cp -> cpu_id , sizeof ( * ucodefp ) ) ; } if ( ucode_match_amd ( eq_sig , uinfop , ucodefp , sizeof ( * ucodefp ) ) == EM_OK ) { return ( EM_OK ) ; } ufp -> amd = ucodefp ; for ( uint_t i = 0 ; i < 0xff ; i ++ ) { ( void ) snprintf ( name , MAXPATHLEN , "/%s/%s/%04X-%02X" , UCODE_INSTALL_PATH , cpuid_getvendorstr ( cp ) , eq_sig , i ) ; if ( ( fd = kobj_open ( name ) ) == - 1 ) { return ( EM_NOMATCH ) ; } count = kobj_read ( fd , ( char * ) ucodefp , sizeof ( * ucodefp ) , 0 ) ; ( void ) kobj_close ( fd ) ; if ( ucode_match_amd ( eq_sig , uinfop , ucodefp , count ) == EM_OK ) { return ( EM_OK ) ; } } return ( EM_NOMATCH ) ; int size = 0 ; char c ; if ( cp -> cpu_id != 0 ) { return ( EM_INVALIDARG ) ; } ( void ) snprintf ( name , MAXPATHLEN , "/%s/%s/container" , UCODE_INSTALL_PATH , cpuid_getvendorstr ( cp ) ) ; if ( ( fd = kobj_open ( name ) ) == - 1 ) { return ( EM_OPENFILE ) ; } { count = kobj_read ( fd , & c , 1 , size ) ; size += count ; } count ; ucodefp = ucode_zalloc ( cp -> cpu_id , sizeof ( * ucodefp ) ) ; ASSERT ( ucodefp ) ; ufp -> amd = ucodefp ; ucodefp -> usize = size ; ucodefp -> ucodep = ucode_zalloc ( cp -> cpu_id , size ) ; ASSERT ( ucodefp -> ucodep ) ; count = kobj_read ( fd , ( char * ) ucodefp -> ucodep , size , 0 ) ; ( void ) kobj_close ( fd ) ; if ( count != size ) { return ( EM_FILESIZE ) ; } rc = ucode -> validate ( ucodefp -> ucodep , ucodefp -> usize ) ; if ( rc != EM_OK ) { return ( rc ) ; } ucode_chipset_amd ( ucodefp -> ucodep , ucodefp -> usize ) ; return ( EM_OK ) ; } 