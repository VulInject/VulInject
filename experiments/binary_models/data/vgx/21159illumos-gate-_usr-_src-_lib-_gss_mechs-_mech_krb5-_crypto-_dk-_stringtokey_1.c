krb5_error_code krb5int_dk_string_to_key ( krb5_context context , const struct krb5_enc_provider * enc , const krb5_data * string , const krb5_data * salt , const krb5_data * parms , krb5_keyblock * key ) { krb5_error_code ret ; size_t keybytes , keylength , concatlen ; unsigned char * concat , * foldstring , * foldkeydata ; krb5_data indata ; krb5_keyblock foldkey ; keybytes = enc -> keybytes ; keylength = enc -> keylength ; concatlen = string -> length + ( salt ?salt -> length : 0 ) ; if ( ( concat = ( unsigned char * ) malloc ( concatlen ) ) == NULL ) { return ( ENOMEM ) ; } if ( ( foldstring = ( unsigned char * ) malloc ( keybytes ) ) == NULL ) { free ( concat ) ; return ( ENOMEM ) ; } if ( ( foldkeydata = ( unsigned char * ) malloc ( keylength ) ) == NULL ) { free ( concat ) ; return ( ENOMEM ) ; } memcpy ( concat , string -> data , string -> length ) ; if ( salt ) { memcpy ( concat + string -> length , salt -> data , salt -> length ) ; } krb5_nfold ( concatlen * 8 , concat , keybytes * 8 , foldstring ) ; indata . length = keybytes ; indata . data = ( char * ) foldstring ; memset ( & foldkey , 0 , sizeof ( krb5_keyblock ) ) ; foldkey . enctype = key -> enctype ; foldkey . length = keylength ; foldkey . contents = foldkeydata ; ( * ( enc -> make_key ) ) ( context , & indata , & foldkey ) ; indata . length = kerberos_len ; indata . data = ( char * ) kerberos ; if ( ( ret = krb5_derive_key ( context , enc , & foldkey , key , & indata ) ) ) { ( void ) memset ( key -> contents , 0 , key -> length ) ; } memset ( concat , 0 , concatlen ) ; memset ( foldstring , 0 , keybytes ) ; memset ( foldkeydata , 0 , keylength ) ; free ( foldkeydata ) ; free ( foldstring ) ; free ( concat ) ; return ( ret ) ; } 