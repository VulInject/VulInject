gimp_brush_load_abr_brush_v12 ( , , , , ) { GimpBrush * brush = NULL ; AbrBrushHeader abr_brush_hdr ; abr_brush_hdr . type = abr_read_short ( input , error ) ; if ( error && * error ) { return NULL ; } abr_brush_hdr . size = abr_read_long ( input , error ) ; if ( error && * error ) { return NULL ; } if ( abr_brush_hdr . size < 0 ) { g_set_error ( error , GIMP_DATA_ERROR , GIMP_DATA_ERROR_READ , _ ( "Fatal parse error in brush file: " "Brush size value corrupt." ) ) ; return NULL ; } switch ( abr_brush_hdr . type ) { case 1 : g_printerr ( "WARNING: computed brush unsupported, skipping.\n" ) ; g_seekable_seek ( G_SEEKABLE ( input ) , abr_brush_hdr . size , G_SEEK_CUR , NULL , NULL ) ; break ; case 2 : { AbrSampledBrushHeader abr_sampled_brush_hdr ; gint width , height ; gint bytes ; gint size ; guchar * mask ; gint i ; gchar * name ; gchar * sample_name = NULL ; gchar * tmp ; gshort compress ; abr_sampled_brush_hdr . misc = abr_read_long ( input , error ) ; if ( error && * error ) { break ; } abr_sampled_brush_hdr . spacing = abr_read_short ( input , error ) ; if ( error && * error ) { break ; } if ( abr_hdr -> version == 2 ) { sample_name = abr_read_ucs2_text ( input , error ) ; if ( error && * error ) { break ; } } abr_sampled_brush_hdr . antialiasing = abr_read_char ( input , error ) ; if ( error && * error ) { break ; } for ( i = 0 ; i < 4 ; i ++ ) { abr_sampled_brush_hdr . bounds [ i ] = abr_read_short ( input , error ) ; if ( error && * error ) { break ; } } for ( i = 0 ; i < 4 ; i ++ ) { abr_sampled_brush_hdr . bounds_long [ i ] = abr_read_long ( input , error ) ; if ( error && * error ) { break ; } } abr_sampled_brush_hdr . depth = abr_read_short ( input , error ) ; if ( error && * error ) { break ; } height = ( abr_sampled_brush_hdr . bounds_long [ 2 ] - abr_sampled_brush_hdr . bounds_long [ 0 ] ) ; width = ( abr_sampled_brush_hdr . bounds_long [ 3 ] - abr_sampled_brush_hdr . bounds_long [ 1 ] ) ; bytes = abr_sampled_brush_hdr . depth >> 3 ; if ( width ( 1 || width ) 10000 || height ( 1 || height ) 10000 || bytes ( 1 || bytes ) 1 || G_MAXSIZE / width / height / bytes < 1 ) { g_set_error ( error , GIMP_DATA_ERROR , GIMP_DATA_ERROR_READ , _ ( "Fatal parse error in brush file: " "Brush dimensions out of range." ) ) ; break ; } abr_sampled_brush_hdr . wide = height > 16384 ; if ( abr_sampled_brush_hdr . wide ) { g_set_error ( error , GIMP_DATA_ERROR , GIMP_DATA_ERROR_READ , _ ( "Fatal parse error in brush file: " "Wide brushes are not supported." ) ) ; break ; } tmp = g_path_get_basename ( gimp_file_get_utf8_name ( file ) ) ; if ( ! sample_name ) { name = g_strdup_printf ( "%s-%03d" , tmp , index ) ; } else { name = g_strdup_printf ( "%s-%s" , tmp , sample_name ) ; } g_free ( tmp ) ; brush = g_object_new ( GIMP_TYPE_BRUSH , "name" , name , "mime-type" , "application/x-photoshop-abr" , NULL ) ; g_free ( name ) ; brush -> priv -> spacing = abr_sampled_brush_hdr . spacing ; brush -> priv -> x_axis . x = width / 2.0 ; brush -> priv -> x_axis . y = 0.0 ; brush -> priv -> y_axis . x = 0.0 ; brush -> priv -> y_axis . y = height / 2.0 ; brush -> priv -> mask = gimp_temp_buf_new ( width , height , babl_format ( "Y u8" ) ) ; mask = gimp_temp_buf_get_data ( brush -> priv -> mask ) ; size = width * height * bytes ; compress = abr_read_char ( input , error ) ; if ( error && * error ) { g_object_unref ( brush ) ; brush = NULL ; break ; } if ( ! compress ) { gsize bytes_read ; if ( ! g_input_stream_read_all ( G_INPUT_STREAM ( input ) , mask , size , & bytes_read , NULL , error ) || bytes_read != size ) { g_object_unref ( brush ) ; brush = NULL ; break ; } } else { if ( ! abr_rle_decode ( input , ( gchar * ) mask , size , height , error ) ) { g_object_unref ( brush ) ; brush = NULL ; break ; } } } break ; default : g_printerr ( "WARNING: unknown brush type, skipping.\n" ) ; g_seekable_seek ( G_SEEKABLE ( input ) , abr_brush_hdr . size , G_SEEK_CUR , NULL , NULL ) ; break ; } return brush ; } 