int rtl88e_init_sw_vars ( struct ieee80211_hw * hw ) { int err = 0 ; struct rtl_priv * rtlpriv = rtl_priv ( hw ) ; struct rtl_pci * rtlpci = rtl_pcidev ( rtl_pcipriv ( hw ) ) ; u8 tid ; char * fw_name ; rtl8188ee_bt_reg_init ( hw ) ; rtlpriv -> dm . dm_flag = 0 ; rtlpriv -> dm . disable_framebursting = 0 ; rtlpriv -> dm . thermalvalue = 0 ; rtlpci -> transmit_config = CFENDFORM | BIT ( 15 ) ; rtlpriv -> rtlhal . current_bandtype = BAND_ON_2_4G ; rtlpriv -> rtlhal . bandset = BAND_ON_2_4G ; rtlpriv -> rtlhal . macphymode = SINGLEMAC_SINGLEPHY ; rtlpci -> receive_config = ( RCR_APPFCS | RCR_APP_MIC | RCR_APP_ICV | RCR_APP_PHYST_RXFF | RCR_HTC_LOC_CTRL | RCR_AMF | RCR_ACF | RCR_ADF | RCR_AICV | RCR_ACRC32 | RCR_AB | RCR_AM | RCR_APM | 0 ) ; rtlpci -> irq_mask [ 0 ] = ( u32 ) ( IMR_PSTIMEOUT | IMR_HSISR_IND_ON_INT | IMR_C2HCMD | IMR_HIGHDOK | IMR_MGNTDOK | IMR_BKDOK | IMR_BEDOK | IMR_VIDOK | IMR_VODOK | IMR_RDU | IMR_ROK | 0 ) ; rtlpci -> irq_mask [ 1 ] = ( u32 ) ( IMR_RXFOVW | 0 ) ; rtlpci -> sys_irq_mask = ( u32 ) ( HSIMR_PDN_INT_EN | HSIMR_RON_INT_EN ) ; rtlpriv -> psc . inactiveps = rtlpriv -> cfg -> mod_params -> inactiveps ; rtlpriv -> psc . swctrl_lps = rtlpriv -> cfg -> mod_params -> swctrl_lps ; rtlpriv -> psc . fwctrl_lps = rtlpriv -> cfg -> mod_params -> fwctrl_lps ; rtlpci -> msi_support = rtlpriv -> cfg -> mod_params -> msi_support ; rtlpriv -> cfg -> mod_params -> sw_crypto = rtlpriv -> cfg -> mod_params -> sw_crypto ; rtlpriv -> cfg -> mod_params -> disable_watchdog = rtlpriv -> cfg -> mod_params -> disable_watchdog ; if ( rtlpriv -> cfg -> mod_params -> disable_watchdog ) { pr_info ( "watchdog disabled\n" ) ; } if ( ! rtlpriv -> psc . inactiveps ) { pr_info ( "rtl8188ee: Power Save off (module option)\n" ) ; } if ( ! rtlpriv -> psc . fwctrl_lps ) { pr_info ( "rtl8188ee: FW Power Save off (module option)\n" ) ; } rtlpriv -> psc . reg_fwctrl_lps = 3 ; rtlpriv -> psc . reg_max_lps_awakeintvl = 5 ; rtl88e_init_aspm_vars ( hw ) ; if ( rtlpriv -> psc . reg_fwctrl_lps == 1 ) { rtlpriv -> psc . fwctrl_psmode = FW_PS_MIN_MODE ; } if ( rtlpriv -> psc . reg_fwctrl_lps == 2 ) { rtlpriv -> psc . fwctrl_psmode = FW_PS_MAX_MODE ; } if ( rtlpriv -> psc . reg_fwctrl_lps == 3 ) { rtlpriv -> psc . fwctrl_psmode = FW_PS_DTIM_MODE ; } rtlpriv -> rtlhal . pfirmware = vzalloc ( 0x8000 ) ; if ( ! rtlpriv -> rtlhal . pfirmware ) { pr_info ( "Can't alloc buffer for fw.\n" ) ; return 1 ; } fw_name = "rtlwifi/rtl8188efw.bin" ; rtlpriv -> max_fw_size = 0x8000 ; pr_info ( "Using firmware %s\n" , fw_name ) ; err = request_firmware_nowait ( THIS_MODULE , 1 , fw_name , rtlpriv -> io . dev , GFP_KERNEL , hw , rtl_fw_cb ) ; if ( err ) { pr_info ( "Failed to request firmware!\n" ) ; return 1 ; } rtlpriv -> rtlhal . earlymode_enable = false ; rtlpriv -> rtlhal . max_earlymode_num = 10 ; for ( tid = 0 ; tid < 8 ; tid ++ ) { skb_queue_head_init ( & rtlpriv -> mac80211 . skb_waitq [ tid ] ) ; } rtlpriv -> psc . low_power_enable = false ; if ( rtlpriv -> psc . low_power_enable ) { init_timer ( & rtlpriv -> works . fw_clockoff_timer ) ; setup_timer ( & rtlpriv -> works . fw_clockoff_timer , rtl88ee_fw_clk_off_timer_callback , ( unsigned long ) hw ) ; } init_timer ( & rtlpriv -> works . fast_antenna_training_timer ) ; setup_timer ( & rtlpriv -> works . fast_antenna_training_timer , rtl88e_dm_fast_antenna_training_callback , ( unsigned long ) hw ) ; return err ; } 