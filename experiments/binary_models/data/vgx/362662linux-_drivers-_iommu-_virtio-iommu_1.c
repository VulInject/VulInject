static int viommu_probe_endpoint ( struct viommu_dev * viommu , struct device * dev ) { int ret ; u16 type , len ; size_t cur = 0 ; size_t probe_len ; struct virtio_iommu_req_probe * probe ; struct virtio_iommu_probe_property * prop ; struct iommu_fwspec * fwspec = dev_iommu_fwspec_get ( dev ) ; struct viommu_endpoint * vdev = dev_iommu_priv_get ( dev ) ; if ( ! fwspec -> num_ids ) { return - EINVAL ; } probe_len = sizeof ( * probe ) + viommu -> probe_size + sizeof ( virtio_iommu_req_tail ) ; probe = kzalloc ( probe_len , GFP_KERNEL ) ; if ( ! probe ) { return - ENOMEM ; } probe -> head . type = VIRTIO_IOMMU_T_PROBE ; probe -> endpoint = cpu_to_le32 ( fwspec -> ids [ 0 ] ) ; ret = viommu_send_req_sync ( viommu , probe , probe_len ) ; if ( ret ) { out_free } prop = ( void * ) probe -> properties ; type = le16_to_cpu ( prop -> type ) & VIRTIO_IOMMU_PROBE_T_MASK ; while ( type != VIRTIO_IOMMU_PROBE_T_NONE && cur < viommu -> probe_size ) { len = le16_to_cpu ( prop -> length ) + sizeof ( * prop ) ; switch ( type ) { case VIRTIO_IOMMU_PROBE_T_RESV_MEM : ret = viommu_add_resv_mem ( vdev , ( void * ) prop , len ) ; break ; default : dev_err ( dev , "unknown viommu prop 0x%x\n" , type ) ; } if ( ret ) { dev_err ( dev , "failed to parse viommu prop 0x%x\n" , type ) ; } cur += len ; if ( cur >= viommu -> probe_size ) { break ; } prop = ( void * ) probe -> properties + cur ; type = le16_to_cpu ( prop -> type ) & VIRTIO_IOMMU_PROBE_T_MASK ; } out_free return ret ; } 