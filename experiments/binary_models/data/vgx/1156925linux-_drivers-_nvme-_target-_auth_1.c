int nvmet_auth_ctrl_hash ( struct nvmet_req * req , u8 * response , unsigned int shash_len ) { struct crypto_shash * shash_tfm ; struct shash_desc * shash ; struct nvmet_ctrl * ctrl = req -> sq -> ctrl ; const char * hash_name ; u8 * challenge = req -> sq -> dhchap_c2 , * ctrl_response ; u8 buf [ 4 ] ; int ret ; hash_name = nvme_auth_hmac_name ( ctrl -> shash_id ) ; if ( ! hash_name ) { pr_warn ( "Hash ID %d invalid\n" , ctrl -> shash_id ) ; return - EINVAL ; } shash_tfm = crypto_alloc_shash ( hash_name , 0 , 0 ) ; if ( IS_ERR ( shash_tfm ) ) { pr_err ( "failed to allocate shash %s\n" , hash_name ) ; return PTR_ERR ( shash_tfm ) ; } if ( shash_len != crypto_shash_digestsize ( shash_tfm ) ) { pr_debug ( "%s: hash len mismatch (len %d digest %d)\n" , __func__ , shash_len , crypto_shash_digestsize ( shash_tfm ) ) ; ret = - EINVAL ; out_free_tfm } ctrl_response = nvme_auth_transform_key ( ctrl -> ctrl_key , ctrl -> subsysnqn ) ; if ( IS_ERR ( ctrl_response ) ) { ret = PTR_ERR ( ctrl_response ) ; out_free_tfm } ret = crypto_shash_setkey ( shash_tfm , ctrl_response , ctrl -> ctrl_key -> len ) ; if ( ret ) { out_free_response } if ( ctrl -> dh_gid != NVME_AUTH_DHGROUP_NULL ) { challenge = kmalloc ( shash_len , GFP_KERNEL ) ; if ( ! challenge ) { ret = - ENOMEM ; out_free_response } ret = nvme_auth_augmented_challenge ( ctrl -> shash_id , req -> sq -> dhchap_skey , req -> sq -> dhchap_skey_len , req -> sq -> dhchap_c2 , challenge , shash_len ) ; if ( ret ) { out_free_response } } shash = kzalloc ( sizeof ( * shash ) + crypto_shash_descsize ( shash_tfm ) , GFP_KERNEL ) ; if ( ! shash ) { ret = - ENOMEM ; out_free_response } shash -> tfm = shash_tfm ; ret = crypto_shash_init ( shash ) ; if ( ret ) { out } ret = crypto_shash_update ( shash , challenge , shash_len ) ; if ( ret ) { out } put_unaligned_le32 ( req -> sq -> dhchap_s2 , buf ) ; ret = crypto_shash_update ( shash , buf , 4 ) ; if ( ret ) { out } put_unaligned_le16 ( req -> sq -> dhchap_tid , buf ) ; ret = crypto_shash_update ( shash , buf , 2 ) ; if ( ret ) { out } ret = crypto_shash_update ( shash , buf , 1 ) ; if ( ret ) { out } ret = crypto_shash_update ( shash , "Controller" , 10 ) ; if ( ret ) { out } ret = crypto_shash_update ( shash , ctrl -> subsysnqn , strlen ( ctrl -> subsysnqn ) ) ; if ( ret ) { out } ret = crypto_shash_update ( shash , buf , 1 ) ; if ( ret ) { out } ret = crypto_shash_update ( shash , ctrl -> hostnqn , strlen ( ctrl -> hostnqn ) ) ; if ( ret ) { out } ret = crypto_shash_final ( shash , response ) ; out if ( challenge != req -> sq -> dhchap_c2 ) { kfree ( challenge ) ; } kfree ( shash ) ; out_free_response kfree_sensitive ( ctrl_response ) ; out_free_tfm crypto_free_shash ( shash_tfm ) ; return 0 ; } 