lm_status_t lm_mcp_cmd_send ( struct _lm_device_t * pdev , lm_mcp_mb_type mb_type , u32_t drv_msg , u32_t param ) { u16_t * p_seq = NULL ; u32_t offset = 0 ; u32_t drv_mask = 0 ; const u8_t func_mb_id = pdev -> params . pfunc_mb_id ; DbgMessage ( pdev , INFORMi , "### mcp_cmd_send mb_type=0x%x drv_msg=0x%x param=0x%x\n" , mb_type , drv_msg , param ) ; if ( 0 != GET_FLAGS ( pdev -> params . test_mode , TEST_MODE_NO_MCP ) ) { return LM_STATUS_SUCCESS ; } switch ( mb_type ) { case lm_mcp_mb_header : p_seq = & pdev -> vars . fw_wr_seq ; drv_mask = DRV_MSG_SEQ_NUMBER_MASK ; offset = OFFSETOF ( shmem_region_t , func_mb [ func_mb_id ] . drv_mb_header ) ; if ( p_seq ) { LM_SHMEM_WRITE ( pdev , OFFSETOF ( shmem_region_t , func_mb [ func_mb_id ] . drv_mb_param ) , param ) ; } break ; case lm_mcp_mb_pulse : p_seq = & pdev -> vars . drv_pulse_wr_seq ; drv_mask = DRV_PULSE_SEQ_MASK ; offset = OFFSETOF ( shmem_region_t , func_mb [ func_mb_id ] . mcp_pulse_mb ) ; break ; case lm_mcp_mb_param : default : break ; } ++ ( * p_seq ) ; drv_msg |= ( ( * p_seq ) & drv_mask ) ; LM_SHMEM_WRITE ( pdev , offset , drv_msg ) ; DbgMessage ( pdev , INFORMi , "mcp_cmd_send: Sent driver load cmd to MCP at 0x%x\n" , drv_msg ) ; return LM_STATUS_SUCCESS ; } 