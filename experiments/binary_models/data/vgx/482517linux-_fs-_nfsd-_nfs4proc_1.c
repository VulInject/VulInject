static __be32 nfsd4_ssc_setup_dul ( struct nfsd_net * nn , char * ipaddr , struct nfsd4_ssc_umount_item * * nsui ) { struct nfsd4_ssc_umount_item * ni = NULL ; struct nfsd4_ssc_umount_item * work = NULL ; struct nfsd4_ssc_umount_item * tmp ; DEFINE_WAIT ( wait ) ; __be32 status = 0 ; * nsui = NULL ; work = kzalloc ( sizeof ( * work ) , GFP_KERNEL ) ; try_again spin_lock ( & nn -> nfsd_ssc_lock ) ; list_for_each_entry_safe ( , , , ) { if ( strncmp ( ni -> nsui_ipaddr , ipaddr , sizeof ( ni -> nsui_ipaddr ) ) ) { continue ; } if ( ni -> nsui_busy ) { prepare_to_wait ( & nn -> nfsd_ssc_waitq , & wait , TASK_INTERRUPTIBLE ) ; spin_unlock ( & nn -> nfsd_ssc_lock ) ; if ( signal_pending ( current ) || ( schedule_timeout ( 20 * HZ ) == 0 ) ) { finish_wait ( & nn -> nfsd_ssc_waitq , & wait ) ; return nfserr_eagain ; } finish_wait ( & nn -> nfsd_ssc_waitq , & wait ) ; try_again } * nsui = ni ; refcount_inc ( & ni -> nsui_refcnt ) ; spin_unlock ( & nn -> nfsd_ssc_lock ) ; kfree ( work ) ; return 0 ; } if ( work ) { strscpy ( work -> nsui_ipaddr , ipaddr , sizeof ( work -> nsui_ipaddr ) - 1 ) ; refcount_set ( & work -> nsui_refcnt , 2 ) ; work -> nsui_busy = true ; list_add_tail ( & work -> nsui_list , & nn -> nfsd_ssc_mount_list ) ; * nsui = work ; } else { status = nfserr_resource ; } spin_unlock ( & nn -> nfsd_ssc_lock ) ; return status ; } 