struct client_lease * apply_defaults ( struct client_lease * lease ) { struct option_data emptyopt = { 0 NULL } ; struct client_lease * newlease ; char * fmt ; int i ; newlease = clone_lease ( lease ) ; if ( newlease == NULL ) { fatalx ( "unable to clone lease" ) ; } if ( config -> filename != NULL ) { free ( newlease -> filename ) ; newlease -> filename = strdup ( config -> filename ) ; if ( newlease -> filename == NULL ) { fatal ( "strdup(config->filename)" ) ; } } if ( config -> server_name != NULL ) { newlease -> server_name = strdup ( config -> server_name ) ; if ( newlease -> server_name == NULL ) { fatal ( "strdup(config->server_name)" ) ; } } if ( config -> address . s_addr != INADDR_ANY ) { newlease -> address . s_addr = config -> address . s_addr ; } if ( config -> next_server . s_addr != INADDR_ANY ) { newlease -> next_server . s_addr = config -> next_server . s_addr ; } for ( i = 0 ; i < DHO_COUNT ; i ++ ) { fmt = code_to_format ( i ) ; switch ( config -> default_actions [ i ] ) { case ACTION_IGNORE : merge_option_data ( fmt , & emptyopt , & emptyopt , & newlease -> options [ i ] ) ; break ; case ACTION_SUPERSEDE : merge_option_data ( fmt , & config -> defaults [ i ] , & emptyopt , & newlease -> options [ i ] ) ; break ; case ACTION_PREPEND : merge_option_data ( fmt , & config -> defaults [ i ] , & lease -> options [ i ] , & newlease -> options [ i ] ) ; break ; case ACTION_APPEND : merge_option_data ( fmt , & lease -> options [ i ] , & config -> defaults [ i ] , & newlease -> options [ i ] ) ; break ; case ACTION_DEFAULT : if ( newlease -> options [ i ] . len == 0 ) { merge_option_data ( fmt , & config -> defaults [ i ] , & emptyopt , & newlease -> options [ i ] ) ; } break ; default : break ; } } if ( newlease -> options [ DHO_STATIC_ROUTES ] . len != 0 ) { log_debug ( "%s: DHO_STATIC_ROUTES (option 33) not supported" , log_procname ) ; free ( newlease -> options [ DHO_STATIC_ROUTES ] . data ) ; newlease -> options [ DHO_STATIC_ROUTES ] . data = NULL ; newlease -> options [ DHO_STATIC_ROUTES ] . len = 0 ; } if ( ( newlease -> options [ DHO_CLASSLESS_MS_STATIC_ROUTES ] . len != 0 ) || ( newlease -> options [ DHO_CLASSLESS_STATIC_ROUTES ] . len != 0 ) ) { free ( newlease -> options [ DHO_ROUTERS ] . data ) ; newlease -> options [ DHO_ROUTERS ] . data = NULL ; newlease -> options [ DHO_ROUTERS ] . len = 0 ; } return newlease ; } 