xmlNode * pcmk__expand_tags_in_sets ( xmlNode * xml_obj , const pe_working_set_t * data_set ) { xmlNode * new_xml = NULL ; bool any_refs = false ; if ( first_named_child ( xml_obj , XML_CONS_TAG_RSC_SET ) == NULL ) { return NULL ; } new_xml = copy_xml ( xml_obj ) ; for ( xmlNode * set = first_named_child ( new_xml , XML_CONS_TAG_RSC_SET ) ; set != NULL ; set = crm_next_same_xml ( set ) ) { GList * tag_refs = NULL ; GList * gIter = NULL ; for ( xmlNode * xml_rsc = first_named_child ( set , XML_TAG_RESOURCE_REF ) ; xml_rsc != NULL ; xml_rsc = crm_next_same_xml ( xml_rsc ) ) { pe_resource_t * rsc = NULL ; pe_tag_t * tag = NULL ; if ( ! pcmk__valid_resource_or_tag ( data_set , ID ( xml_rsc ) , & rsc , & tag ) ) { pcmk__config_err ( "Ignoring resource sets for constraint '%s' " "because '%s' is not a valid resource or tag" , ID ( xml_obj ) , ID ( xml_rsc ) ) ; return NULL ; } if ( rsc ) { continue ; } if ( tag ) { xmlNode * last_ref = xml_rsc ; for ( gIter = tag -> refs ; gIter != NULL ; gIter = gIter -> next ) { const char * obj_ref = ( const char * ) gIter -> data ; xmlNode * new_rsc_ref = NULL ; new_rsc_ref = xmlNewDocRawNode ( getDocPtr ( set ) , NULL , ( pcmkXmlStr ) XML_TAG_RESOURCE_REF , NULL ) ; crm_xml_add ( new_rsc_ref , XML_ATTR_ID , obj_ref ) ; xmlAddNextSibling ( last_ref , new_rsc_ref ) ; last_ref = new_rsc_ref ; } any_refs = true ; tag_refs = g_list_append ( tag_refs , xml_rsc ) ; } } for ( gIter = tag_refs ; gIter != NULL ; gIter = gIter -> next ) { xmlNode * tag_ref = gIter -> data ; free_xml ( tag_ref ) ; } g_list_free ( tag_refs ) ; } if ( ! any_refs ) { free_xml ( new_xml ) ; new_xml = NULL ; } return new_xml ; } 