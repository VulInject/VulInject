static void do_hcall ( struct lg_cpu * cpu , struct hcall_args * args ) { switch ( args -> arg0 ) { case LHCALL_FLUSH_ASYNC : break ; case LHCALL_SEND_INTERRUPTS : break ; case LHCALL_LGUEST_INIT : kill_guest ( cpu , "already have lguest_data" ) ; break ; case LHCALL_SHUTDOWN : { int msg [ 128 ] ; __lgread ( cpu , msg , args -> arg1 , sizeof ( msg ) ) ; msg [ sizeof ( msg ) - 1 ] = '\0' ; kill_guest ( cpu , "CRASH: %s" , msg ) ; if ( args -> arg2 == LGUEST_SHUTDOWN_RESTART ) { cpu -> lg -> dead = ERR_PTR ( - ERESTART ) ; } break ; } case LHCALL_FLUSH_TLB : if ( args -> arg1 ) { guest_pagetable_clear_all ( cpu ) ; } else { guest_pagetable_flush_user ( cpu ) ; } break ; case LHCALL_NEW_PGTABLE : guest_new_pagetable ( cpu , args -> arg1 ) ; break ; case LHCALL_SET_STACK : guest_set_stack ( cpu , args -> arg1 , args -> arg2 , args -> arg3 ) ; break ; case LHCALL_SET_PTE : guest_set_pte ( cpu , args -> arg1 , args -> arg2 , __pte ( args -> arg3 | ( u64 ) args -> arg4 << 32 ) ) ; guest_set_pte ( cpu , args -> arg1 , args -> arg2 , __pte ( args -> arg3 ) ) ; break ; case LHCALL_SET_PGD : guest_set_pgd ( cpu -> lg , args -> arg1 , args -> arg2 ) ; break ; case LHCALL_SET_PMD : guest_set_pmd ( cpu -> lg , args -> arg1 , args -> arg2 ) ; break ; case LHCALL_SET_CLOCKEVENT : guest_set_clockevent ( cpu , args -> arg1 ) ; break ; case LHCALL_HALT : cpu -> halted = 1 ; break ; default : if ( lguest_arch_do_hcall ( cpu , args ) ) { kill_guest ( cpu , "Bad hypercall %li\n" , args -> arg0 ) ; } } } 