int main ( int argc , char * * argv ) { pid_t pid = 0 ; int c , adj = 0 , has_adj = 0 ; struct path_cxt * pc = NULL ; static const struct option longopts [ ] { { "adjust" required_argument NULL 'n' } { "pid" required_argument NULL 'p' } { "help" no_argument NULL 'h' } { "version" no_argument NULL 'V' } { NULL 0 NULL 0 } } ; ; setlocale ( LC_ALL , "" ) ; bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ; close_stdout_atexit ( ) ; while ( ( c = getopt_long ( argc , argv , "hn:p:V" , longopts , NULL ) ) != - 1 ) { switch ( c ) { case 'p' : pid = strtos32_or_err ( optarg , _ ( "invalid PID argument" ) ) ; break ; case 'n' : adj = strtos32_or_err ( optarg , _ ( "invalid adjust argument" ) ) ; has_adj = 1 ; break ; case 'V' : print_version ( EXIT_SUCCESS ) ; case 'h' : usage ( ) ; default : errtryhelp ( EXIT_FAILURE ) ; } } if ( optind < argc && pid ) { warnx ( _ ( "invalid argument: %s" ) , argv [ optind ] ) ; errtryhelp ( EXIT_FAILURE ) ; } if ( ! pid && argc - optind < 1 ) { warnx ( _ ( "no PID or COMMAND specified" ) ) ; errtryhelp ( EXIT_FAILURE ) ; } if ( optind < argc && ! has_adj ) { warnx ( _ ( "no OOM score adjust value specified" ) ) ; errtryhelp ( EXIT_FAILURE ) ; } pc = ul_new_path ( "/proc/%d" , ( int ) ( pid ?pid : getpid ( ) ) ) ; if ( ! has_adj ) { printf ( _ ( "pid %d's current OOM score: %d\n" ) , pid , get_score ( pc ) ) ; printf ( _ ( "pid %d's current OOM score adjust value: %d\n" ) , pid , get_score_adj ( pc ) ) ; } if ( pid ) { int old = get_score_adj ( pc ) ; if ( set_score_adj ( pc , adj ) ) { err ( EXIT_FAILURE , _ ( "failed to set score adjust value" ) ) ; } printf ( _ ( "pid %d's OOM score adjust value changed from %d to %d\n" ) , pid , old , adj ) ; } else { if ( set_score_adj ( pc , adj ) ) { err ( EXIT_FAILURE , _ ( "failed to set score adjust value" ) ) ; } argv += optind ; execvp ( argv [ 0 ] , argv ) ; errexec ( argv [ 0 ] ) ; } ul_unref_path ( pc ) ; return EXIT_SUCCESS ; } 