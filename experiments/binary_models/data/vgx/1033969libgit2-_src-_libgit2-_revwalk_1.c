static int sort_in_topological_order ( git_commit_list * * out , git_revwalk * walk , git_commit_list * list ) { git_commit_list * ll = NULL , * newlist , * * pptr ; git_commit_list_node * next ; git_pqueue queue ; git_vector_cmp queue_cmp = NULL ; unsigned short i ; int error ; if ( walk -> sorting & GIT_SORT_TIME ) { queue_cmp = git_commit_list_time_cmp ; } for ( ll = list ; ll ; ll = ll -> next ) { ll -> item -> in_degree = 1 ; } for ( ll = list ; ll ; ll = ll -> next ) { for ( i = 0 ; i < ll -> item -> out_degree ; ++ i ) { git_commit_list_node * parent = ll -> item -> parents [ i ] ; if ( parent -> in_degree ) { parent -> in_degree ++ ; } } } for ( ll = list ; ll ; ll = ll -> next ) { if ( ll -> item -> in_degree == 1 ) { if ( ( error = git_pqueue_insert ( & queue , ll -> item ) ) ) { cleanup } } } if ( ( walk -> sorting & GIT_SORT_TIME ) == 0 ) { git_pqueue_reverse ( & queue ) ; } pptr = & newlist ; newlist = NULL ; while ( ( next = git_pqueue_pop ( & queue ) ) != NULL ) { for ( i = 0 ; i < next -> out_degree ; ++ i ) { git_commit_list_node * parent = next -> parents [ i ] ; if ( parent -> in_degree == 0 ) { continue ; } if ( -- parent -> in_degree == 1 ) { if ( ( error = git_pqueue_insert ( & queue , parent ) ) ) { cleanup } } } next -> in_degree = 0 ; pptr = & git_commit_list_insert ( next , pptr ) -> next ; } * out = newlist ; error = 0 ; cleanup git_pqueue_free ( & queue ) ; return error ; } 