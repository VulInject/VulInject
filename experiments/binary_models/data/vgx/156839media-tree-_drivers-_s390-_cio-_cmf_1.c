static int set_schib_wait ( struct ccw_device * cdev , u32 mme , int mbfc , unsigned long address ) { struct set_schib_struct * set_data ; int ret ; spin_lock_irq ( cdev -> ccwlock ) ; if ( ! cdev -> private -> cmb ) { ret = - ENODEV ; out } set_data = kmalloc ( sizeof ( set_schib_struct ) , GFP_ATOMIC ) ; if ( ! set_data ) { ret = - ENOMEM ; out } init_waitqueue_head ( & set_data -> wait ) ; kref_init ( & set_data -> kref ) ; set_data -> mme = mme ; set_data -> mbfc = mbfc ; set_data -> address = address ; ret = set_schib ( cdev , mme , mbfc , address ) ; if ( ret != - EBUSY ) { out_put } if ( cdev -> private -> state != DEV_STATE_ONLINE ) { ret = - EBUSY ; out_put } cdev -> private -> state = DEV_STATE_CMFCHANGE ; set_data -> ret = CMF_PENDING ; cdev -> private -> cmb_wait = set_data ; spin_unlock_irq ( cdev -> ccwlock ) ; if ( wait_event_interruptible ( set_data -> wait , set_data -> ret != CMF_PENDING ) ) { spin_lock_irq ( cdev -> ccwlock ) ; if ( set_data -> ret == CMF_PENDING ) { set_data -> ret = - ERESTARTSYS ; if ( cdev -> private -> state == DEV_STATE_CMFCHANGE ) { cdev -> private -> state = DEV_STATE_ONLINE ; } } spin_unlock_irq ( cdev -> ccwlock ) ; } spin_lock_irq ( cdev -> ccwlock ) ; cdev -> private -> cmb_wait = NULL ; ret = set_data -> ret ; out_put kref_put ( & set_data -> kref , cmf_set_schib_release ) ; out spin_unlock_irq ( cdev -> ccwlock ) ; return ret ; } 