local int gz_look ( state ) gz_statep state ; { z_streamp strm = & ( state -> strm ) ; if ( state -> size == 0 ) { state -> in = ( unsigned char * ) malloc ( state -> want ) ; state -> out = ( unsigned char * ) malloc ( state -> want << 1 ) ; if ( state -> in == NULL || state -> out == NULL ) { free ( state -> out ) ; free ( state -> in ) ; gz_error ( state , Z_MEM_ERROR , "out of memory" ) ; return - 1 ; } state -> size = state -> want ; state -> strm . zalloc = Z_NULL ; state -> strm . zfree = Z_NULL ; state -> strm . opaque = Z_NULL ; state -> strm . avail_in = 0 ; state -> strm . next_in = Z_NULL ; if ( inflateInit2 ( & ( state -> strm ) , 15 + 16 ) != Z_OK ) { free ( state -> out ) ; free ( state -> in ) ; state -> size = 0 ; gz_error ( state , Z_MEM_ERROR , "out of memory" ) ; return - 1 ; } } if ( strm -> avail_in < 2 ) { if ( gz_avail ( state ) == - 1 ) { return - 1 ; } if ( strm -> avail_in == 0 ) { return 0 ; } } if ( strm -> avail_in > 1 && strm -> next_in [ 0 ] == 31 && strm -> next_in [ 1 ] == 139 ) { inflateReset ( strm ) ; state -> how = GZIP ; return 0 ; } if ( state -> direct == 0 ) { strm -> avail_in = 0 ; state -> eof = 1 ; state -> x . have = 0 ; return 0 ; } state -> x . next = state -> out ; if ( strm -> avail_in ) { memcpy ( state -> x . next , strm -> next_in , strm -> avail_in ) ; state -> x . have = strm -> avail_in ; strm -> avail_in = 0 ; } state -> how = COPY ; state -> direct = 1 ; return 0 ; } 