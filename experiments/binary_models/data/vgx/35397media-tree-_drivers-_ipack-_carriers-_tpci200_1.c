static int tpci200_pci_probe ( struct pci_dev * pdev , const struct pci_device_id * id ) { int ret , i ; struct tpci200_board * tpci200 ; u32 reg32 ; tpci200 = kzalloc ( sizeof ( tpci200_board ) , GFP_KERNEL ) ; if ( ! tpci200 ) { return - ENOMEM ; } tpci200 -> info = kzalloc ( sizeof ( tpci200_infos ) , GFP_KERNEL ) ; if ( ! tpci200 -> info ) { ret = - ENOMEM ; out_err_info } pci_dev_get ( pdev ) ; ret = pci_request_region ( pdev , TPCI200_CFG_MEM_BAR , KBUILD_MODNAME " Configuration Memory" ) ; if ( ret ) { dev_err ( & pdev -> dev , "Failed to allocate PCI Configuration Memory" ) ; ret = - EBUSY ; out_err_pci_request } tpci200 -> info -> cfg_regs = ioremap_nocache ( pci_resource_start ( pdev , TPCI200_CFG_MEM_BAR ) , pci_resource_len ( pdev , TPCI200_CFG_MEM_BAR ) ) ; if ( ! tpci200 -> info -> cfg_regs ) { dev_err ( & pdev -> dev , "Failed to map PCI Configuration Memory" ) ; ret = - EFAULT ; out_err_ioremap } reg32 = ioread32 ( tpci200 -> info -> cfg_regs + LAS1_DESC ) ; reg32 |= 1 << LAS_BIT_BIGENDIAN ; iowrite32 ( reg32 , tpci200 -> info -> cfg_regs + LAS1_DESC ) ; reg32 = ioread32 ( tpci200 -> info -> cfg_regs + LAS2_DESC ) ; reg32 |= 1 << LAS_BIT_BIGENDIAN ; iowrite32 ( reg32 , tpci200 -> info -> cfg_regs + LAS2_DESC ) ; tpci200 -> info -> pdev = pdev ; tpci200 -> info -> id_table = ( pci_device_id * ) id ; ret = tpci200_install ( tpci200 ) ; if ( ret ) { dev_err ( & pdev -> dev , "error during tpci200 install\n" ) ; ret = - ENODEV ; out_err_install } tpci200 -> info -> ipack_bus = ipack_bus_register ( & pdev -> dev , TPCI200_NB_SLOT , & tpci200_bus_ops , THIS_MODULE ) ; if ( ! tpci200 -> info -> ipack_bus ) { dev_err ( & pdev -> dev , "error registering the carrier on ipack driver\n" ) ; ret = - EFAULT ; out_err_bus_register } tpci200 -> number = tpci200 -> info -> ipack_bus -> bus_nr ; dev_set_drvdata ( & pdev -> dev , tpci200 ) ; for ( i = 0 ; i < TPCI200_NB_SLOT ; i ++ ) { tpci200_create_device ( tpci200 , i ) ; } return 0 ; out_err_bus_register tpci200_uninstall ( tpci200 ) ; out_err_install iounmap ( tpci200 -> info -> cfg_regs ) ; out_err_ioremap pci_release_region ( pdev , TPCI200_CFG_MEM_BAR ) ; out_err_pci_request pci_dev_put ( pdev ) ; out_err_info kfree ( tpci200 ) ; return ret ; } 