static int mlxsw_sp_dpipe_table_erif_entries_dump ( void * priv , bool counters_enabled , struct devlink_dpipe_dump_ctx * dump_ctx ) { struct devlink_dpipe_value match_value , action_value ; struct devlink_dpipe_action action = { 0 } ; struct devlink_dpipe_match match = { 0 } ; struct devlink_dpipe_entry entry = { 0 } ; struct mlxsw_sp * mlxsw_sp = priv ; unsigned int rif_count ; int i , j ; int err ; memset ( & action_value , 0 , sizeof ( action_value ) ) ; mlxsw_sp_erif_match_action_prepare ( & match , & action ) ; err = mlxsw_sp_erif_entry_prepare ( & entry , & match_value , & match , & action_value , & action ) ; if ( err ) { return err ; } rif_count = MLXSW_CORE_RES_GET ( mlxsw_sp -> core , MAX_RIFS ) ; mutex_lock ( & mlxsw_sp -> router -> lock ) ; i = 0 ; start_again err = devlink_dpipe_entry_ctx_prepare ( dump_ctx ) ; if ( err ) { err_ctx_prepare } j = 0 ; for ( ; i < rif_count ; i ++ ) { struct mlxsw_sp_rif * rif = mlxsw_sp_rif_by_index ( mlxsw_sp , i ) ; if ( ! rif || ! mlxsw_sp_rif_dev ( rif ) ) { continue ; } err = mlxsw_sp_erif_entry_get ( mlxsw_sp , & entry , rif , counters_enabled ) ; if ( err ) { err_entry_get } err = devlink_dpipe_entry_ctx_append ( dump_ctx , & entry ) ; if ( err ) { if ( err == - EMSGSIZE ) { if ( ! j ) { err_entry_append } break ; } err_entry_append } j ++ ; } devlink_dpipe_entry_ctx_close ( dump_ctx ) ; if ( i != rif_count ) { start_again } mutex_unlock ( & mlxsw_sp -> router -> lock ) ; devlink_dpipe_entry_clear ( & entry ) ; return 0 ; err_entry_append err_entry_get err_ctx_prepare mutex_unlock ( & mlxsw_sp -> router -> lock ) ; devlink_dpipe_entry_clear ( & entry ) ; return err ; } 