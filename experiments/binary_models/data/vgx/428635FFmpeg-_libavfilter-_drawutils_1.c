void ff_draw_color ( FFDrawContext * draw , FFDrawColor * color , const uint8_t rgba [ 4 ] ) { unsigned i ; double yuvad [ 4 ] ; double rgbad [ 4 ] ; const AVPixFmtDescriptor * desc = draw -> desc ; if ( rgba != color -> rgba ) { memcpy ( color -> rgba , rgba , sizeof ( color -> rgba ) ) ; } for ( int i = 0 ; i < 4 ; i ++ ) { rgbad [ i ] = color -> rgba [ i ] / 255. ; } if ( draw -> desc -> flags & AV_PIX_FMT_FLAG_RGB ) { memcpy ( yuvad , rgbad , sizeof ( double ) * 3 ) ; } else { ff_matrix_mul_3x3_vec ( yuvad , rgbad , draw -> rgb2yuv ) ; } yuvad [ 3 ] = rgbad [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { int chroma = ( ! ( draw -> desc -> flags & AV_PIX_FMT_FLAG_RGB ) && i > 0 ) ; if ( draw -> range == AVCOL_RANGE_MPEG ) { yuvad [ i ] *= ( chroma ?224. : 219. ) / 255. ; yuvad [ i ] += ( chroma ?128. : 16. ) / 255. ; } if ( chroma ) { yuvad [ i ] += 0.5 ; } } if ( desc -> nb_components <= 2 ) { yuvad [ 1 ] = yuvad [ 3 ] ; } for ( i = 0 ; i < desc -> nb_components ; i ++ ) { unsigned val = yuvad [ i ] * ( ( 1 << ( draw -> desc -> comp [ i ] . depth + draw -> desc -> comp [ i ] . shift ) ) - 1 ) + 0.5 ; if ( desc -> comp [ i ] . depth > 8 ) { color -> comp [ desc -> comp [ i ] . plane ] . u16 [ desc -> comp [ i ] . offset / 2 ] = val ; } else { color -> comp [ desc -> comp [ i ] . plane ] . u8 [ desc -> comp [ i ] . offset ] = val ; } } } 