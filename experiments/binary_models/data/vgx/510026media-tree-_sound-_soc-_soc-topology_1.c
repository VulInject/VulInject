static int soc_tplg_dbytes_create ( struct soc_tplg * tplg , unsigned int count , size_t size ) { struct snd_soc_tplg_bytes_control * be ; struct soc_bytes_ext * sbe ; struct snd_kcontrol_new kc ; int i , err ; if ( soc_tplg_check_elem_count ( tplg , sizeof ( snd_soc_tplg_bytes_control ) , count , size , "mixer bytes" ) ) { dev_err ( tplg -> dev , "ASoC: Invalid count %d for byte control\n" , count ) ; return - EINVAL ; } for ( i = 0 ; i < count ; i ++ ) { be = ( snd_soc_tplg_bytes_control * ) tplg -> pos ; if ( strnlen ( be -> hdr . name , SNDRV_CTL_ELEM_ID_NAME_MAXLEN ) == SNDRV_CTL_ELEM_ID_NAME_MAXLEN ) { return - EINVAL ; } sbe = kzalloc ( sizeof ( * sbe ) , GFP_KERNEL ) ; if ( sbe == NULL ) { return - ENOMEM ; } tplg -> pos += ( sizeof ( snd_soc_tplg_bytes_control ) + be -> priv . size ) ; dev_dbg ( tplg -> dev , "ASoC: adding bytes kcontrol %s with access 0x%x\n" , be -> hdr . name , be -> hdr . access ) ; memset ( & kc , 0 , sizeof ( kc ) ) ; kc . name = be -> hdr . name ; kc . private_value = ( long ) sbe ; kc . iface = SNDRV_CTL_ELEM_IFACE_MIXER ; kc . access = be -> hdr . access ; sbe -> max = be -> max ; sbe -> dobj . type = SND_SOC_DOBJ_BYTES ; sbe -> dobj . ops = tplg -> ops ; INIT_LIST_HEAD ( & sbe -> dobj . list ) ; err = soc_tplg_kcontrol_bind_io ( & be -> hdr , & kc , tplg ) ; if ( err ) { soc_control_err ( tplg , & be -> hdr , be -> hdr . name ) ; continue ; } err = soc_tplg_init_kcontrol ( tplg , & kc , ( snd_soc_tplg_ctl_hdr * ) be ) ; if ( err < 0 ) { dev_err ( tplg -> dev , "ASoC: failed to init %s\n" , be -> hdr . name ) ; kfree ( sbe ) ; continue ; } err = soc_tplg_add_kcontrol ( tplg , & kc , & sbe -> dobj . control . kcontrol ) ; if ( err < 0 ) { dev_err ( tplg -> dev , "ASoC: failed to add %s\n" , be -> hdr . name ) ; kfree ( sbe ) ; continue ; } list_add ( & sbe -> dobj . list , & tplg -> comp -> dobj_list ) ; } return 0 ; } 