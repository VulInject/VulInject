int ip_etherip_output ( struct ifnet * ifp , struct mbuf * m ) { struct etherip_softc * sc = ( etherip_softc * ) ifp -> if_softc ; struct m_tag * mtag ; struct etherip_header * eip ; struct ip * ip ; M_PREPEND ( m , sizeof ( * ip ) + sizeof ( * eip ) , M_DONTWAIT ) ; if ( m == NULL ) { etheripstat_inc ( etherips_adrops ) ; return ENOBUFS ; } ip = mtod ( m , ip * ) ; memset ( ip , 0 , sizeof ( ip ) ) ; ip -> ip_v = IPVERSION ; ip -> ip_hl = sizeof ( * ip ) >> 2 ; ip -> ip_tos = IFQ_PRIO2TOS ( sc -> sc_txhprio == IF_HDRPRIO_PACKET ?m -> m_pkthdr . pf . prio : sc -> sc_txhprio ) ; ip -> ip_len = htons ( m -> m_pkthdr . len ) ; ip -> ip_id = htons ( ip_randomid ( ) ) ; ip -> ip_off = sc -> sc_df ; ip -> ip_ttl = sc -> sc_ttl ; ip -> ip_p = IPPROTO_ETHERIP ; ip -> ip_src = sc -> sc_tunnel . t_src4 ; ip -> ip_dst = sc -> sc_tunnel . t_dst4 ; eip = ( etherip_header * ) ( ip + 1 ) ; eip -> eip_ver = ETHERIP_VERSION ; eip -> eip_res = 0 ; eip -> eip_pad = 0 ; mtag = m_tag_get ( PACKET_TAG_GRE , sizeof ( ifp -> if_index ) , M_NOWAIT ) ; if ( mtag == NULL ) { return ( ENOMEM ) ; } * ( int * ) ( mtag + 1 ) = ifp -> if_index ; m_tag_prepend ( m , mtag ) ; m -> m_flags &= ~ ( M_BCAST | M_MCAST ) ; m -> m_pkthdr . ph_rtableid = sc -> sc_tunnel . t_rtableid ; pf_pkt_addr_changed ( m ) ; etheripstat_pkt ( etherips_opackets , etherips_obytes , m -> m_pkthdr . len - ( sizeof ( ip ) + sizeof ( etherip_header ) ) ) ; ip_send ( m ) ; return ( 0 ) ; } 