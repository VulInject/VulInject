static int getgroups_cb ( void * rock , struct carddav_data * cdata ) { struct cards_rock * crock = ( cards_rock * ) rock ; struct index_record record ; jmap_req_t * req = crock -> req ; json_t * obj = NULL ; mbentry_t * mbentry = NULL ; char * xhref ; int r = 0 ; mbentry = jmap_mbentry_from_dav ( req , & cdata -> dav ) ; if ( ! mbentry || ! jmap_hasrights_mbentry ( req , mbentry , JACL_READITEMS ) ) { mboxlist_entry_free ( & mbentry ) ; return 0 ; } if ( cdata -> jmapversion == JMAPCACHE_CONTACTVERSION ) { json_error_t jerr ; obj = json_loads ( cdata -> jmapdata , 0 , & jerr ) ; if ( obj ) { gotvalue } } if ( ! crock -> mailbox || strcmp ( mailbox_uniqueid ( crock -> mailbox ) , cdata -> dav . mailbox ) ) { mailbox_close ( & crock -> mailbox ) ; r = mailbox_open_irl ( mbentry -> name , & crock -> mailbox ) ; } if ( r ) { done } r = mailbox_find_index_record ( crock -> mailbox , cdata -> dav . imap_uid , & record ) ; if ( r ) { done } struct vparse_card * vcard = record_to_vcard ( crock -> mailbox , & record ) ; if ( ! vcard || ! vcard -> objects ) { syslog ( LOG_ERR , "record_to_vcard failed for record %u:%s" , cdata -> dav . imap_uid , mailbox_name ( crock -> mailbox ) ) ; vparse_free_card ( vcard ) ; r = IMAP_INTERNAL ; done } obj = jmap_group_from_vcard ( vcard -> objects ) ; vparse_free_card ( vcard ) ; hashu64_insert ( cdata -> dav . rowid , json_dumps ( obj , 0 ) , & crock -> jmapcache ) ; gotvalue json_object_set_new ( obj , "id" , json_string ( cdata -> vcard_uid ) ) ; json_object_set_new ( obj , "uid" , json_string ( cdata -> vcard_uid ) ) ; json_object_set_new ( obj , "addressbookId" , json_string ( strrchr ( mbentry -> name , '.' ) + 1 ) ) ; xhref = jmap_xhref ( mbentry -> name , cdata -> dav . resource ) ; json_object_set_new ( obj , "x-href" , json_string ( xhref ) ) ; json_array_append_new ( crock -> get -> list , obj ) ; crock -> rows ++ ; done mboxlist_entry_free ( & mbentry ) ; return r ; } 