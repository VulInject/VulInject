static struct api_data * avalon2_api_stats ( struct cgpu_info * cgpu ) { struct api_data * root ; struct avalon2_info * info = cgpu -> device_data ; int i , j , a , b ; char buf [ 24 ] ; double hwp ; int minerindex , minercount ; for ( i = 0 ; i < AVA2_DEFAULT_MODULARS ; i ++ ) { if ( info -> dev_type [ i ] == AVA2_ID_AVAX ) { continue ; } sprintf ( buf , "ID%d MM Version" , i + 1 ) ; root = api_add_string ( root , buf , ( char * ) & ( info -> mm_version [ i ] ) , false ) ; } minerindex = 0 ; minercount = 0 ; for ( i = 0 ; i < AVA2_DEFAULT_MODULARS ; i ++ ) { if ( info -> dev_type [ i ] == AVA2_ID_AVAX ) { minerindex += AVA2_DEFAULT_MINERS ; continue ; } if ( info -> dev_type [ i ] == AVA2_ID_AVA2 ) { minercount = AVA2_DEFAULT_MINERS ; } if ( info -> dev_type [ i ] == AVA2_ID_AVA3 ) { minercount = AVA2_AVA3_MINERS ; } for ( j = minerindex ; j < ( minerindex + minercount ) ; j ++ ) { sprintf ( buf , "Match work count%02d" , j + 1 ) ; root = api_add_int ( root , buf , & ( info -> matching_work [ j ] ) , false ) ; } minerindex += AVA2_DEFAULT_MINERS ; } for ( i = 0 ; i < AVA2_DEFAULT_MODULARS ; i ++ ) { if ( info -> dev_type [ i ] == AVA2_ID_AVAX ) { continue ; } sprintf ( buf , "Local works%d" , i + 1 ) ; root = api_add_int ( root , buf , & ( info -> local_works [ i ] ) , false ) ; } for ( i = 0 ; i < AVA2_DEFAULT_MODULARS ; i ++ ) { if ( info -> dev_type [ i ] == AVA2_ID_AVAX ) { continue ; } sprintf ( buf , "Hardware error works%d" , i + 1 ) ; root = api_add_int ( root , buf , & ( info -> hw_works [ i ] ) , false ) ; } for ( i = 0 ; i < AVA2_DEFAULT_MODULARS ; i ++ ) { if ( info -> dev_type [ i ] == AVA2_ID_AVAX ) { continue ; } a = info -> hw_works [ i ] ; b = info -> local_works [ i ] ; hwp = b ?( ( double ) a / ( double ) b ) : 0 ; sprintf ( buf , "Device hardware error%d%%" , i + 1 ) ; root = api_add_percent ( root , buf , & hwp , true ) ; } for ( i = 0 ; i < 2 * AVA2_DEFAULT_MODULARS ; i ++ ) { if ( info -> dev_type [ i / 2 ] == AVA2_ID_AVAX ) { continue ; } sprintf ( buf , "Temperature%d" , i + 1 ) ; root = api_add_int ( root , buf , & ( info -> temp [ i ] ) , false ) ; } for ( i = 0 ; i < 2 * AVA2_DEFAULT_MODULARS ; i ++ ) { if ( info -> dev_type [ i / 2 ] == AVA2_ID_AVAX ) { continue ; } sprintf ( buf , "Fan%d" , i + 1 ) ; root = api_add_int ( root , buf , & ( info -> fan [ i ] ) , false ) ; } for ( i = 0 ; i < AVA2_DEFAULT_MODULARS ; i ++ ) { if ( info -> dev_type [ i ] == AVA2_ID_AVAX ) { continue ; } sprintf ( buf , "Voltage%d" , i + 1 ) ; root = api_add_int ( root , buf , & ( info -> get_voltage [ i ] ) , false ) ; } for ( i = 0 ; i < AVA2_DEFAULT_MODULARS ; i ++ ) { if ( info -> dev_type [ i ] == AVA2_ID_AVAX ) { continue ; } sprintf ( buf , "Frequency%d" , i + 1 ) ; root = api_add_int ( root , buf , & ( info -> get_frequency [ i ] ) , false ) ; } for ( i = 0 ; i < AVA2_DEFAULT_MODULARS ; i ++ ) { if ( info -> dev_type [ i ] == AVA2_ID_AVAX ) { continue ; } sprintf ( buf , "Power good %02x" , i + 1 ) ; root = api_add_int ( root , buf , & ( info -> power_good [ i ] ) , false ) ; } for ( i = 0 ; i < AVA2_DEFAULT_MODULARS ; i ++ ) { if ( info -> dev_type [ i ] == AVA2_ID_AVAX ) { continue ; } sprintf ( buf , "Led %02x" , i + 1 ) ; root = api_add_int ( root , buf , & ( info -> led_red [ i ] ) , false ) ; } return root ; } 