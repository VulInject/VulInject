static int imx6ul_adc_init ( struct imx6ul_tsc * tsc ) { u32 adc_hc = 0 ; u32 adc_gc ; u32 adc_gs ; u32 adc_cfg ; cfs_time_t timeout ; reinit_completion ( & tsc -> completion ) ; adc_cfg = readl ( tsc -> adc_regs + REG_ADC_CFG ) ; adc_cfg &= ~ ( ADC_CONV_MODE_MASK | ADC_INPUT_CLK_MASK ) ; adc_cfg |= ADC_12BIT_MODE | ADC_IPG_CLK ; adc_cfg &= ~ ( ADC_CLK_DIV_MASK | ADC_SAMPLE_MODE_MASK ) ; adc_cfg |= ADC_CLK_DIV_8 | ADC_SHORT_SAMPLE_MODE ; if ( tsc -> average_enable ) { adc_cfg &= ~ ADC_AVGS_MASK ; adc_cfg |= ( tsc -> average_select ) << ADC_AVGS_SHIFT ; } adc_cfg &= ~ ADC_HARDWARE_TRIGGER ; writel ( adc_cfg , tsc -> adc_regs + REG_ADC_CFG ) ; adc_hc |= ADC_AIEN ; adc_hc |= ADC_CONV_DISABLE ; writel ( adc_hc , tsc -> adc_regs + REG_ADC_HC0 ) ; adc_gc = readl ( tsc -> adc_regs + REG_ADC_GC ) ; adc_gc |= ADC_CAL ; if ( tsc -> average_enable ) { adc_gc |= ADC_AVGE ; } writel ( adc_gc , tsc -> adc_regs + REG_ADC_GC ) ; timeout = wait_for_completion_timeout ( & tsc -> completion , ADC_TIMEOUT ) ; if ( timeout == 0 ) { dev_err ( tsc -> dev , "Timeout for adc calibration\n" ) ; return - ETIMEDOUT ; } adc_gs = readl ( tsc -> adc_regs + REG_ADC_GS ) ; if ( adc_gs & ADC_CALF ) { dev_err ( tsc -> dev , "ADC calibration failed\n" ) ; return - EINVAL ; } adc_cfg = readl ( tsc -> adc_regs + REG_ADC_CFG ) ; adc_cfg |= ADC_HARDWARE_TRIGGER ; writel ( adc_cfg , tsc -> adc_regs + REG_ADC_CFG ) ; return 0 ; } 