static int __igt_mmap ( struct drm_i915_private * i915 , struct drm_i915_gem_object * obj , enum i915_mmap_type type ) { struct vm_area_struct * area ; unsigned long addr ; int err , i ; u64 offset ; if ( ! can_mmap ( obj , type ) ) { return 0 ; } err = wc_set ( obj ) ; if ( err == - ENXIO ) { err = gtt_set ( obj ) ; } err = __assign_mmap_offset ( obj , type , & offset , NULL ) ; if ( err ) { return err ; } addr = igt_mmap_offset ( i915 , offset , obj -> base . size , PROT_WRITE , MAP_SHARED ) ; if ( IS_ERR_VALUE ( addr ) ) { return addr ; } pr_debug ( "igt_mmap(%s, %d) @ %lx\n" , obj -> mm . region -> name , type , addr ) ; mmap_read_lock ( current -> mm ) ; area = vma_lookup ( current -> mm , addr ) ; mmap_read_unlock ( current -> mm ) ; if ( ! area ) { pr_err ( "%s: Did not create a vm_area_struct for the mmap\n" , obj -> mm . region -> name ) ; err = - EINVAL ; out_unmap } for ( i = 0 ; i < obj -> base . size / sizeof ( u32 ) ; i ++ ) { u32 __user * ux = u64_to_user_ptr ( ( u64 ) ( addr + i * sizeof ( * ux ) ) ) ; u32 x ; if ( get_user ( x , ux ) ) { pr_err ( "%s: Unable to read from mmap, offset:%zd\n" , obj -> mm . region -> name , i * sizeof ( x ) ) ; err = - EFAULT ; out_unmap } if ( x != expand32 ( POISON_INUSE ) ) { pr_err ( "%s: Read incorrect value from mmap, offset:%zd, found:%x, expected:%x\n" , obj -> mm . region -> name , i * sizeof ( x ) , x , expand32 ( POISON_INUSE ) ) ; err = - EINVAL ; out_unmap } x = expand32 ( POISON_FREE ) ; if ( put_user ( x , ux ) ) { pr_err ( "%s: Unable to write to mmap, offset:%zd\n" , obj -> mm . region -> name , i * sizeof ( x ) ) ; err = - EFAULT ; out_unmap } } if ( type == I915_MMAP_TYPE_GTT ) { intel_gt_flush_ggtt_writes ( to_gt ( i915 ) ) ; } err = wc_check ( obj ) ; if ( err == - ENXIO ) { err = gtt_check ( obj ) ; } out_unmap vm_munmap ( addr , obj -> base . size ) ; return err ; } 