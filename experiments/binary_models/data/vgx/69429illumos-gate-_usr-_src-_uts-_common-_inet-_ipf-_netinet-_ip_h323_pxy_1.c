int ippr_h323_in ( fin , aps , nat , private ) fr_info_t * fin ; ap_session_t * aps ; nat_t * nat ; void * private ; { int ipaddr , off , datlen ; unsigned short port ; caddr_t data ; tcphdr_t * tcp ; ip_t * ip ; ipf_stack_t * ifs = fin -> fin_ifs ; ip = fin -> fin_ip ; tcp = ( tcphdr_t * ) fin -> fin_dp ; ipaddr = ip -> ip_src . s_addr ; data = ( caddr_t ) tcp + ( TCP_OFF ( tcp ) << 2 ) ; datlen = fin -> fin_dlen - ( TCP_OFF ( tcp ) << 2 ) ; if ( find_port ( ipaddr , data , datlen , & off , & port ) == 0 ) { ipnat_t * ipn ; char * newarray ; KMALLOCS ( newarray , char * , aps -> aps_psiz + sizeof ( * ipn ) ) ; ipn = ( ipnat_t * ) & newarray [ aps -> aps_psiz ] ; bcopy ( ( caddr_t ) nat -> nat_ptr , ( caddr_t ) ipn , sizeof ( ipnat_t ) ) ; ( void ) strncpy ( ipn -> in_plabel , "h245" , APR_LABELLEN ) ; ipn -> in_inip = nat -> nat_inip . s_addr ; ipn -> in_inmsk = 0xffffffff ; ipn -> in_dport = htons ( port ) ; RWLOCK_EXIT ( & ifs -> ifs_ipf_nat ) ; if ( fr_nat_ioctl ( ( caddr_t ) ipn , SIOCADNAT , NAT_SYSSPACE | FWRITE , 0 , NULL , ifs ) == - 1 ) { READ_ENTER ( & ifs -> ifs_ipf_nat ) ; return - 1 ; } READ_ENTER ( & ifs -> ifs_ipf_nat ) ; if ( aps -> aps_data != NULL && aps -> aps_psiz > 0 ) { bcopy ( aps -> aps_data , newarray , aps -> aps_psiz ) ; KFREES ( aps -> aps_data , aps -> aps_psiz ) ; } aps -> aps_data = newarray ; aps -> aps_psiz += sizeof ( * ipn ) ; } return 0 ; } 