* if_nameindex ( ) . * * # include < net / ; if ( if_nameindex * ptr ) { } * * The argument to this function must be a pointer that was returned by * if_nameindex ( ) . * / if_nameindex * if_nameindex ( ) { if_nameindex_msg * ifnm = NULL if_nameindex * ifni = NULL * ifni2 char * cp size_t needed unsigned int ni i int mib [ 6 ] mib [ 0 ] = CTL_NET mib [ 1 ] = PF_ROUTE mib [ 2 ] = 0 mib [ 3 ] = 0 mib [ 4 ] = NET_RT_IFNAMES mib [ 5 ] = 0 while ( 1 ) { struct if_nameindex_msg * buf NULL ; ; if ( sysctl ( mib , 6 , NULL , & needed , NULL , 0 ) == - 1 ) { out } if ( needed == 0 ) { break ; } if ( ( buf = realloc ( ifnm , needed ) ) == NULL ) { out } ifnm = buf ; if ( sysctl ( mib , 6 , ifnm , & needed , NULL , 0 ) == - 1 ) { if ( errno == ENOMEM ) { continue ; } out ; } } } ; break ; = needed / sizeof ( * ifnm ) ; ifni = calloc ( ni + 1 , sizeof ( if_nameindex ) + IF_NAMESIZE ) ; if ( ifni == NULL ) { out } cp = ( char * ) ( ifni + ( ni + 1 ) ) ; ifni2 = ifni ; for ( i = 0 ; i < ni ; i ++ ) { ifni2 -> if_index = ifnm [ i ] . if_index ; strlcpy ( cp , ifnm [ i ] . if_name , IF_NAMESIZE ) ; ifni2 -> if_name = cp ; ifni2 ++ ; cp += IF_NAMESIZE ; } ifni2 -> if_index = 0 ; ifni2 -> if_name = NULL ; out return ifni ; 