static int ccp_register_sha_alg ( struct list_head * head , const struct ccp_sha_def * def ) { struct ccp_crypto_ahash_alg * ccp_alg ; struct ahash_alg * alg ; struct hash_alg_common * halg ; struct crypto_alg * base ; int ret ; ccp_alg = kzalloc ( sizeof ( * ccp_alg ) , GFP_KERNEL ) ; if ( ! ccp_alg ) { return - ENOMEM ; } INIT_LIST_HEAD ( & ccp_alg -> entry ) ; ccp_alg -> type = def -> type ; alg = & ccp_alg -> alg ; alg -> init = ccp_sha_init ; alg -> update = ccp_sha_update ; alg -> final = ccp_sha_final ; alg -> finup = ccp_sha_finup ; alg -> digest = ccp_sha_digest ; alg -> export = ccp_sha_export ; alg -> import = ccp_sha_import ; halg = & alg -> halg ; halg -> digestsize = def -> digest_size ; halg -> statesize = sizeof ( ccp_sha_exp_ctx ) ; base = & halg -> base ; snprintf ( base -> cra_name , CRYPTO_MAX_ALG_NAME , "%s" , def -> name ) ; snprintf ( base -> cra_driver_name , CRYPTO_MAX_ALG_NAME , "%s" , def -> drv_name ) ; base -> cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY | CRYPTO_ALG_KERN_DRIVER_ONLY | CRYPTO_ALG_NEED_FALLBACK ; base -> cra_blocksize = def -> block_size ; base -> cra_ctxsize = sizeof ( ccp_ctx ) + crypto_dma_padding ( ) ; base -> cra_priority = CCP_CRA_PRIORITY ; base -> cra_init = ccp_sha_cra_init ; base -> cra_exit = ccp_sha_cra_exit ; base -> cra_module = THIS_MODULE ; ret = crypto_register_ahash ( alg ) ; if ( ret ) { pr_err ( "%s ahash algorithm registration error (%d)\n" , base -> cra_name , ret ) ; return ret ; } list_add ( & ccp_alg -> entry , head ) ; ret = ccp_register_hmac_alg ( head , def , ccp_alg ) ; return ret ; } 