static int nf_ct_resolve_clash ( struct net * net , struct sk_buff * skb , enum ip_conntrack_info ctinfo , struct nf_conntrack_tuple_hash * h ) { struct nf_conn * ct = nf_ct_tuplehash_to_ctrack ( h ) ; struct nf_conntrack_l4proto * l4proto ; l4proto = __nf_ct_l4proto_find ( nf_ct_l3num ( ct ) , nf_ct_protonum ( ct ) ) ; if ( l4proto -> allow_clash && ( ( ct -> status & IPS_NAT_DONE_MASK ) == 0 ) && ! nf_ct_is_dying ( ct ) && atomic_inc_not_zero ( & ct -> ct_general . use ) ) { enum ip_conntrack_info oldinfo ; struct nf_conn * loser_ct = nf_ct_get ( skb , & oldinfo ) ; nf_ct_acct_merge ( ct , ctinfo , loser_ct ) ; nf_conntrack_put ( & loser_ct -> ct_general ) ; nf_ct_set ( skb , ct , oldinfo ) ; return NF_ACCEPT ; } NF_CT_STAT_INC ( net , drop ) ; return NF_DROP ; } int __nf_conntrack_confirm ( struct sk_buff * skb ) { const struct nf_conntrack_zone * zone ; unsigned int hash , reply_hash ; struct nf_conntrack_tuple_hash * h ; struct nf_conn * ct ; struct nf_conn_help * help ; struct nf_conn_tstamp * tstamp ; struct hlist_nulls_node * n ; enum ip_conntrack_info ctinfo ; struct net * net ; unsigned int sequence ; int ret = NF_DROP ; ct = nf_ct_get ( skb , & ctinfo ) ; net = nf_ct_net ( ct ) ; zone = nf_ct_zone ( ct ) ; local_bh_disable ( ) ; { sequence = read_seqcount_begin ( & nf_conntrack_generation ) ; hash = * ( unsigned long * ) & ct -> tuplehash [ IP_CT_DIR_REPLY ] . hnnode . pprev ; hash = scale_hash ( hash ) ; reply_hash = hash_conntrack ( net , & ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple ) ; } nf_conntrack_double_lock ( net , hash , reply_hash , sequence ) ; NF_CT_ASSERT ( ! nf_ct_is_confirmed ( ct ) ) ; pr_debug ( "Confirming conntrack %p\n" , ct ) ; nf_ct_del_from_dying_or_unconfirmed_list ( ct ) ; if ( unlikely ( nf_ct_is_dying ( ct ) ) ) { nf_ct_add_to_dying_list ( ct ) ; dying } hlist_nulls_for_each_entry ( , , , ) if ( nf_ct_key_equal ( h , & ct -> tuplehash [ IP_CT_DIR_ORIGINAL ] . tuple , zone , net ) ) { out } hlist_nulls_for_each_entry ( , , , ) if ( nf_ct_key_equal ( h , & ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple , zone , net ) ) { out } ct -> timeout += nfct_time_stamp ; atomic_inc ( & ct -> ct_general . use ) ; ct -> status |= IPS_CONFIRMED ; tstamp = nf_conn_tstamp_find ( ct ) ; if ( tstamp ) { if ( skb -> tstamp == 0 ) { __net_timestamp ( skb ) ; } tstamp -> start = ktime_to_ns ( skb -> tstamp ) ; } __nf_conntrack_hash_insert ( ct , hash , reply_hash ) ; nf_conntrack_double_unlock ( hash , reply_hash ) ; local_bh_enable ( ) ; help = nfct_help ( ct ) ; if ( help && help -> helper ) { nf_conntrack_event_cache ( IPCT_HELPER , ct ) ; } nf_conntrack_event_cache ( master_ct ( ct ) ?IPCT_RELATED : IPCT_NEW , ct ) ; return NF_ACCEPT ; out nf_ct_add_to_dying_list ( ct ) ; ret = nf_ct_resolve_clash ( net , skb , ctinfo , h ) ; dying nf_conntrack_double_unlock ( hash , reply_hash ) ; NF_CT_STAT_INC ( net , insert_failed ) ; local_bh_enable ( ) ; return ret ; } 