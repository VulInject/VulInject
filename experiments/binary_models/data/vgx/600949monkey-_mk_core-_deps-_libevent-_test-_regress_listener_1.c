static void regress_listener_error_unlock ( void * arg ) { struct basic_test_data * data = arg ; struct event_base * base = data -> base ; struct evconnlistener * listener ; unsigned int flags = LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE | LEV_OPT_THREADSAFE ; tt_int_op ( send ( data -> pair [ 1 ] , "hello" , 5 , 0 ) , > , 0 ) ; listener = evconnlistener_new ( base , acceptcb , NULL , flags , 0 , data -> pair [ 0 ] ) ; tt_assert ( listener ) ; { struct rlimit rl ; rl . rlim_cur = rl . rlim_max = data -> pair [ 1 ] ; if ( setrlimit ( RLIMIT_NOFILE , & rl ) == - 1 ) { TT_DIE ( ( "Can't change RLIMIT_NOFILE" ) ) ; } } event_base_loop ( base , EVLOOP_ONCE ) ; end if ( listener ) { evconnlistener_free ( listener ) ; } } struct testcase_t listener_testcases [ ] { { "randport" regress_pick_a_port TT_FORK | TT_NEED_BASE & basic_setup NULL } { "randport_ts" regress_pick_a_port TT_FORK | TT_NEED_BASE & basic_setup ( char * ) "ts" } { "error_unlock" regress_listener_error_unlock TT_FORK | TT_NEED_BASE | TT_NEED_SOCKETPAIR & basic_setup NULL } { "error" regress_listener_error TT_FORK | TT_NEED_BASE | TT_NEED_SOCKETPAIR & basic_setup NULL } { "error_ts" regress_listener_error TT_FORK | TT_NEED_BASE | TT_NEED_SOCKETPAIR & basic_setup ( char * ) "ts" } END_OF_TESTCASES } ; ; 