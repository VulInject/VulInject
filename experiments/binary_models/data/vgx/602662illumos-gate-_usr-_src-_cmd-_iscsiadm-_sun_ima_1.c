IMA_STATUS SUN_IMA_RetrieveISNSServerTargets ( IMA_TARGET_ADDRESS serverAddress , SUN_IMA_DISC_ADDRESS_KEY_PROPERTIES * * ppList ) { int fd ; int ctr ; int server_pg_list_sz ; int status ; isns_server_portal_group_list_t * server_pg_list = NULL ; isns_portal_group_list_t * pg_list = NULL ; IMA_BOOL retry = IMA_TRUE ; entry_t entry ; server_pg_list_sz = sizeof ( * server_pg_list ) + ( ( ISNS_SERVER_DEFAULT_NUM_TARGETS - 1 ) * sizeof ( isns_portal_group_t ) ) ; server_pg_list = ( isns_server_portal_group_list_t * ) calloc ( 1 , server_pg_list_sz ) ; if ( server_pg_list == NULL ) { return ( IMA_ERROR_INSUFFICIENT_MEMORY ) ; } server_pg_list -> addr_port_list . pg_in_cnt = ISNS_SERVER_DEFAULT_NUM_TARGETS ; if ( ( prepare_discovery_entry_IMA ( serverAddress , & entry ) != DISC_ADDR_OK ) ) { return ( IMA_ERROR_INVALID_PARAMETER ) ; } server_pg_list -> addr . a_port = entry . e_port ; server_pg_list -> addr . a_addr . i_insize = entry . e_insize ; if ( entry . e_insize == sizeof ( in_addr ) ) { server_pg_list -> addr . a_addr . i_addr . in4 . s_addr = ( entry . e_u . u_in4 . s_addr ) ; } if ( entry . e_insize == sizeof ( in6_addr ) ) { bcopy ( & entry . e_u . u_in6 . s6_addr , server_pg_list -> addr . a_addr . i_addr . in6 . s6_addr , 16 ) ; } if ( ( status = open_driver ( & fd ) ) ) { free ( server_pg_list ) ; return ( SUN_IMA_ERROR_SYSTEM_ERROR | status ) ; } retry_isns if ( ioctl ( fd , ISCSI_ISNS_SERVER_GET , server_pg_list ) != 0 ) { int tmp_errno = errno ; IMA_STATUS return_status ; syslog ( LOG_USER | LOG_DEBUG , "ISCSI_ISNS_SERVER_GET ioctl failed, errno: %d" , tmp_errno ) ; if ( tmp_errno == EACCES ) { return_status = IMA_ERROR_OBJECT_NOT_FOUND ; } else { return_status = IMA_ERROR_UNEXPECTED_OS_ERROR ; } ( void ) close ( fd ) ; free ( server_pg_list ) ; return ( return_status ) ; } pg_list = & server_pg_list -> addr_port_list ; if ( pg_list -> pg_in_cnt < pg_list -> pg_out_cnt ) { if ( retry == IMA_TRUE ) { server_pg_list_sz = sizeof ( * server_pg_list ) + ( ( pg_list -> pg_out_cnt - 1 ) * sizeof ( isns_server_portal_group_list_t ) ) ; server_pg_list = ( isns_server_portal_group_list_t * ) realloc ( server_pg_list , server_pg_list_sz ) ; if ( server_pg_list == NULL ) { ( void ) close ( fd ) ; return ( IMA_ERROR_INSUFFICIENT_MEMORY ) ; } pg_list = & server_pg_list -> addr_port_list ; pg_list -> pg_in_cnt = pg_list -> pg_out_cnt ; retry = IMA_FALSE ; retry_isns } else { syslog ( LOG_USER | LOG_DEBUG , "ISCSI_SENDTGTS_GET overflow: " "failed to obtain all targets" ) ; pg_list -> pg_out_cnt = pg_list -> pg_in_cnt ; } } ( void ) close ( fd ) ; * ppList = ( SUN_IMA_DISC_ADDRESS_KEY_PROPERTIES * ) calloc ( 1 , sizeof ( SUN_IMA_DISC_ADDRESS_KEY_PROPERTIES ) + pg_list -> pg_out_cnt * sizeof ( SUN_IMA_DISC_ADDRESS_KEY ) ) ; if ( * ppList == NULL ) { free ( server_pg_list ) ; return ( IMA_ERROR_INSUFFICIENT_MEMORY ) ; } ( * ppList ) -> keyCount = pg_list -> pg_out_cnt ; for ( ctr = 0 ; ctr < pg_list -> pg_out_cnt ; ctr ++ ) { ( void ) mbstowcs ( ( * ppList ) -> keys [ ctr ] . name , ( char * ) pg_list -> pg_list [ ctr ] . pg_iscsi_name , IMA_NODE_NAME_LEN ) ; ( * ppList ) -> keys [ ctr ] . tpgt = pg_list -> pg_list [ ctr ] . pg_tag ; ( * ppList ) -> keys [ ctr ] . address . portNumber = pg_list -> pg_list [ ctr ] . pg_port ; if ( pg_list -> pg_list [ ctr ] . insize == sizeof ( in_addr ) ) { ( * ppList ) -> keys [ ctr ] . address . ipAddress . ipv4Address = IMA_TRUE ; } if ( pg_list -> pg_list [ ctr ] . insize == sizeof ( in6_addr ) ) { ( * ppList ) -> keys [ ctr ] . address . ipAddress . ipv4Address = IMA_FALSE ; } else { free ( pg_list ) ; return ( IMA_ERROR_UNEXPECTED_OS_ERROR ) ; } ( void ) memcpy ( & ( * ppList ) -> keys [ ctr ] . address . ipAddress . ipAddress , & ( pg_list -> pg_list [ ctr ] . pg_ip_addr ) , pg_list -> pg_list [ ctr ] . insize ) ; } free ( server_pg_list ) ; return ( IMA_STATUS_SUCCESS ) ; } 