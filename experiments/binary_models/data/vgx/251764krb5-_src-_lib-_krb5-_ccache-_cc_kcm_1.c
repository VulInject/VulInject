static krb5_error_code KRB5_CALLCONV kcm_retrieve ( krb5_context context , krb5_ccache cache , krb5_flags flags , krb5_creds * mcred , krb5_creds * cred_out ) { krb5_error_code ret ; struct kcmreq req = EMPTY_KCMREQ ; krb5_creds cred ; krb5_enctype * enctypes = NULL ; kcmreq_init ( & req , KCM_OP_RETRIEVE , cache ) ; k5_buf_add_uint32_be ( & req . reqbuf , map_tcflags ( flags ) | KCM_GC_CACHED ) ; k5_marshal_mcred ( & req . reqbuf , mcred ) ; ret = cache_call ( context , cache , & req ) ; if ( unsupported_op_error ( ret ) ) { ret = k5_cc_retrieve_cred_default ( context , cache , flags , mcred , cred_out ) ; cleanup } if ( ret ) { cleanup } ret = k5_unmarshal_cred ( req . reply . ptr , req . reply . len , 4 , & cred ) ; if ( ret ) { cleanup } if ( flags & KRB5_TC_SUPPORTED_KTYPES ) { ret = krb5_get_tgs_ktypes ( context , cred . server , & enctypes ) ; if ( ret ) { cleanup } if ( ! k5_etypes_contains ( enctypes , cred . keyblock . enctype ) ) { ret = k5_cc_retrieve_cred_default ( context , cache , flags , mcred , cred_out ) ; cleanup } } * cred_out = cred ; memset ( & cred , 0 , sizeof ( cred ) ) ; cleanup kcmreq_free ( & req ) ; krb5_free_cred_contents ( context , & cred ) ; free ( enctypes ) ; return ( ret == KRB5_CC_END ) ?KRB5_CC_NOTFOUND : map_invalid ( ret ) ; } 