int * compar_fn_t ( const void * , const void * ) static void * known_values ; ( { void * value = tfind ( Str , & known_values , ( compar_fn_t ) strcmp ) value != NULL ?* ( char * * ) value : NULL } ) tsearch ( , , ) static char * * last_environ ; int __add_to_environ ( const char * name , const char * value , const char * combined , int replace ) { char * * ep ; size_t size ; const size_t namelen = strlen ( name ) ; const size_t vallen = value != NULL ?strlen ( value ) + 1 : 0 ; LOCK ; ep = __environ ; size = 0 ; if ( ep != NULL ) { for ( ; * ep != NULL ; ++ ep ) { if ( ! strncmp ( * ep , name , namelen ) && ( * ep ) [ namelen ] == '=' ) { break ; } else { ++ size ; } } } if ( ep == NULL || * ep == NULL ) { char * * new_environ ; char * new_value ; new_environ = ( char * * ) ( last_environ == NULL ?malloc ( ( size + 2 ) * sizeof ( char * ) ) : realloc ( last_environ , ( size + 2 ) * sizeof ( char * ) ) ) ; if ( new_environ == NULL ) { __set_errno ( ENOMEM ) ; UNLOCK ; return - 1 ; } if ( combined != NULL ) { new_environ [ size ] = ( char * ) combined ; } else { new_value = ( char * ) alloca ( namelen + 1 + vallen ) ; __mempcpy ( __mempcpy ( __mempcpy ( new_value , name , namelen ) , "=" , 1 ) , value , vallen ) ; new_value = ( char * ) malloca ( namelen + 1 + vallen ) ; if ( new_value == NULL ) { __set_errno ( ENOMEM ) ; UNLOCK ; return - 1 ; } memcpy ( new_value , name , namelen ) ; new_value [ namelen ] = '=' ; memcpy ( & new_value [ namelen + 1 ] , value , vallen ) ; new_environ [ size ] = KNOWN_VALUE ( new_value ) ; if ( new_environ [ size ] == NULL ) { new_environ [ size ] = ( char * ) malloc ( namelen + 1 + vallen ) ; if ( new_environ [ size ] == NULL ) { __set_errno ( ENOMEM ) ; UNLOCK ; return - 1 ; } memcpy ( new_environ [ size ] , new_value , namelen + 1 + vallen ) ; memcpy ( new_environ [ size ] , name , namelen ) ; new_environ [ size ] [ namelen ] = '=' ; memcpy ( & new_environ [ size ] [ namelen + 1 ] , value , vallen ) ; STORE_VALUE ( new_environ [ size ] ) ; } freea ( new_value ) ; } if ( __environ != last_environ ) { memcpy ( ( char * ) new_environ , ( char * ) __environ , size * sizeof ( char * ) ) ; } new_environ [ size + 1 ] = NULL ; last_environ = __environ = new_environ ; } if ( replace ) { char * np ; if ( combined != NULL ) { np = ( char * ) combined ; } else { char * new_value ; new_value = alloca ( namelen + 1 + vallen ) ; __mempcpy ( __mempcpy ( __mempcpy ( new_value , name , namelen ) , "=" , 1 ) , value , vallen ) ; new_value = malloca ( namelen + 1 + vallen ) ; if ( new_value == NULL ) { __set_errno ( ENOMEM ) ; UNLOCK ; return - 1 ; } memcpy ( new_value , name , namelen ) ; new_value [ namelen ] = '=' ; memcpy ( & new_value [ namelen + 1 ] , value , vallen ) ; np = KNOWN_VALUE ( new_value ) ; if ( np == NULL ) { np = ( char * ) malloc ( namelen + 1 + vallen ) ; if ( np == NULL ) { freea ( new_value ) ; __set_errno ( ENOMEM ) ; UNLOCK ; return - 1 ; } memcpy ( np , new_value , namelen + 1 + vallen ) ; memcpy ( np , name , namelen ) ; np [ namelen ] = '=' ; memcpy ( & np [ namelen + 1 ] , value , vallen ) ; STORE_VALUE ( np ) ; } freea ( new_value ) ; } * ep = np ; } UNLOCK ; return 0 ; } 