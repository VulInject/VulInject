struct ib_mr * pvrdma_reg_user_mr ( struct ib_pd * pd , u64 start , u64 length , u64 virt_addr , int access_flags , struct ib_udata * udata ) { struct pvrdma_dev * dev = to_vdev ( pd -> device ) ; struct pvrdma_user_mr * mr = NULL ; struct ib_umem * umem ; union pvrdma_cmd_req req ; union pvrdma_cmd_resp rsp ; struct pvrdma_cmd_create_mr * cmd = & req . create_mr ; struct pvrdma_cmd_create_mr_resp * resp = & rsp . create_mr_resp ; int ret , npages ; if ( length == 0 || length > dev -> dsr -> caps . max_mr_size ) { dev_warn ( & dev -> pdev -> dev , "invalid mem region length\n" ) ; return ERR_PTR ( - EINVAL ) ; } umem = ib_umem_get ( pd -> device , start , length , access_flags ) ; if ( IS_ERR ( umem ) ) { dev_warn ( & dev -> pdev -> dev , "could not get umem for mem region\n" ) ; return ERR_CAST ( umem ) ; } npages = ib_umem_num_dma_blocks ( umem , PAGE_SIZE ) ; if ( npages ( 0 || npages ) PVRDMA_PAGE_DIR_MAX_PAGES ) { dev_warn ( & dev -> pdev -> dev , "overflow %d pages in mem region\n" , npages ) ; ret = - EINVAL ; err_umem } mr = kzalloc ( sizeof ( * mr ) , GFP_KERNEL ) ; if ( ! mr ) { ret = - ENOMEM ; err_umem } mr -> mmr . iova = virt_addr ; mr -> mmr . size = length ; mr -> umem = umem ; ret = pvrdma_page_dir_init ( dev , & mr -> pdir , npages , false ) ; if ( ret ) { dev_warn ( & dev -> pdev -> dev , "could not allocate page directory\n" ) ; err_umem } ret = pvrdma_page_dir_insert_umem ( & mr -> pdir , mr -> umem , 0 ) ; if ( ret ) { err_pdir } cmd -> hdr . cmd = PVRDMA_CMD_CREATE_MR ; cmd -> start = start ; cmd -> length = length ; cmd -> pd_handle = to_vpd ( pd ) -> pd_handle ; cmd -> access_flags = access_flags ; cmd -> nchunks = npages ; cmd -> pdir_dma = mr -> pdir . dir_dma ; ret = pvrdma_cmd_post ( dev , & req , & rsp , PVRDMA_CMD_CREATE_MR_RESP ) ; if ( ret < 0 ) { dev_warn ( & dev -> pdev -> dev , "could not register mem region, error: %d\n" , ret ) ; err_pdir } mr -> mmr . mr_handle = resp -> mr_handle ; mr -> ibmr . lkey = resp -> lkey ; mr -> ibmr . rkey = resp -> rkey ; return & mr -> ibmr ; err_pdir pvrdma_page_dir_cleanup ( dev , & mr -> pdir ) ; err_umem ib_umem_release ( umem ) ; kfree ( mr ) ; return ERR_PTR ( ret ) ; } 