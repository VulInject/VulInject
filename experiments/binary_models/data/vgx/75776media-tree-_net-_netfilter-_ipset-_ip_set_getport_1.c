static bool get_port ( const struct sk_buff * skb , int protocol , unsigned int protooff , bool src , __be16 * port , u8 * proto ) { switch ( protocol ) { case IPPROTO_TCP : { struct tcphdr _tcph ; const struct tcphdr * th ; th = skb_header_pointer ( skb , protooff , sizeof ( _tcph ) , & _tcph ) ; * port = src ?th -> source : th -> dest ; break ; } case IPPROTO_SCTP : { sctp_sctphdr_t _sh ; const sctp_sctphdr_t * sh ; sh = skb_header_pointer ( skb , protooff , sizeof ( _sh ) , & _sh ) ; if ( ! sh ) { return false ; } * port = src ?sh -> source : sh -> dest ; break ; } case IPPROTO_UDP : case IPPROTO_UDPLITE : { struct udphdr _udph ; const struct udphdr * uh ; uh = skb_header_pointer ( skb , protooff , sizeof ( _udph ) , & _udph ) ; if ( ! uh ) { return false ; } * port = src ?uh -> source : uh -> dest ; break ; } case IPPROTO_ICMP : { struct icmphdr _ich ; const struct icmphdr * ic ; ic = skb_header_pointer ( skb , protooff , sizeof ( _ich ) , & _ich ) ; if ( ! ic ) { return false ; } * port = ( __force __be16 ) htons ( ( ic -> type << 8 ) | ic -> code ) ; break ; } case IPPROTO_ICMPV6 : { struct icmp6hdr _ich ; const struct icmp6hdr * ic ; ic = skb_header_pointer ( skb , protooff , sizeof ( _ich ) , & _ich ) ; if ( ! ic ) { return false ; } * port = ( __force __be16 ) htons ( ( ic -> icmp6_type << 8 ) | ic -> icmp6_code ) ; break ; } default : break ; } * proto = protocol ; return true ; } 