int sk_newbuf ( struct sk_if_softc * sc_if ) { struct mbuf * m ; struct sk_chain * c ; struct sk_rx_desc * r ; bus_dmamap_t dmamap ; u_int prod ; int error ; uint64_t dva ; m = MCLGETL ( NULL , M_DONTWAIT , SK_JLEN ) ; if ( m == NULL ) { return ( ENOBUFS ) ; } m -> m_len = m -> m_pkthdr . len = SK_JLEN ; m_adj ( m , ETHER_ALIGN ) ; prod = sc_if -> sk_cdata . sk_rx_prod ; dmamap = sc_if -> sk_cdata . sk_rx_map [ prod ] ; error = bus_dmamap_load_mbuf ( sc_if -> sk_softc -> sc_dmatag , dmamap , m , BUS_DMA_READ | BUS_DMA_NOWAIT ) ; if ( error ) { return ( ENOBUFS ) ; } bus_dmamap_sync ( sc_if -> sk_softc -> sc_dmatag , dmamap , 0 , dmamap -> dm_mapsize , BUS_DMASYNC_PREREAD ) ; c = & sc_if -> sk_cdata . sk_rx_chain [ prod ] ; c -> sk_mbuf = m ; r = c -> sk_desc ; dva = dmamap -> dm_segs [ 0 ] . ds_addr ; htolem32 ( & r -> sk_data_lo , dva ) ; htolem32 ( & r -> sk_data_hi , dva >> 32 ) ; htolem32 ( & r -> sk_ctl , dmamap -> dm_segs [ 0 ] . ds_len | SK_RXSTAT ) ; SK_CDRXSYNC ( sc_if , prod , BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD ) ; SK_INC ( prod , SK_RX_RING_CNT ) ; sc_if -> sk_cdata . sk_rx_prod = prod ; return ( 0 ) ; } 