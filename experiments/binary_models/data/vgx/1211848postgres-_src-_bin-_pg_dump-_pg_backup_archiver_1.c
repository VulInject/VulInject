static void restore_toc_entries_prefork ( ArchiveHandle * AH , TocEntry * pending_list ) { bool skipped_some ; TocEntry * next_work_item ; pg_log_debug ( "entering restore_toc_entries_prefork" ) ; fix_dependencies ( AH ) ; AH -> restorePass = RESTORE_PASS_MAIN ; skipped_some = false ; for ( next_work_item = AH -> toc -> next ; next_work_item != AH -> toc ; next_work_item = next_work_item -> next ) { bool do_now = true ; if ( next_work_item -> section != SECTION_PRE_DATA ) { if ( next_work_item -> section == SECTION_DATA || next_work_item -> section == SECTION_POST_DATA ) { do_now = false ; skipped_some = true ; } else { if ( skipped_some ) { do_now = false ; } } } if ( _tocEntryRestorePass ( next_work_item ) != RESTORE_PASS_MAIN ) { do_now = false ; } if ( do_now ) { pg_log_info ( "processing item %d %s %s" , next_work_item -> dumpId , next_work_item -> desc , next_work_item -> tag ) ; ( void ) restore_toc_entry ( AH , next_work_item , false ) ; reduce_dependencies ( AH , next_work_item , NULL ) ; } else { pending_list_append ( pending_list , next_work_item ) ; } } DisconnectDatabase ( & AH -> public ) ; AH -> currUser = NULL ; free ( AH -> currSchema ) ; AH -> currSchema = NULL ; free ( AH -> currTablespace ) ; AH -> currTablespace = NULL ; free ( AH -> currTableAm ) ; AH -> currTableAm = NULL ; } static void restore_toc_entries_parallel ( ArchiveHandle * AH , ParallelState * pstate , TocEntry * pending_list ) { ParallelReadyList ready_list ; TocEntry * next_work_item ; pg_log_debug ( "entering restore_toc_entries_parallel" ) ; ready_list_init ( & ready_list , AH -> tocCount ) ; AH -> restorePass = RESTORE_PASS_MAIN ; move_to_ready_list ( pending_list , & ready_list , AH -> restorePass ) ; pg_log_info ( "entering main parallel loop" ) ; for ( ; ; ) { next_work_item = pop_next_work_item ( & ready_list , pstate ) ; if ( next_work_item != NULL ) { if ( ( next_work_item -> reqs & ( REQ_SCHEMA | REQ_DATA ) ) == 0 ) { pg_log_info ( "skipping item %d %s %s" , next_work_item -> dumpId , next_work_item -> desc , next_work_item -> tag ) ; reduce_dependencies ( AH , next_work_item , & ready_list ) ; continue ; } pg_log_info ( "launching item %d %s %s" , next_work_item -> dumpId , next_work_item -> desc , next_work_item -> tag ) ; DispatchJobForTocEntry ( AH , pstate , next_work_item , ACT_RESTORE , mark_restore_job_done , & ready_list ) ; } if ( IsEveryWorkerIdle ( pstate ) ) { if ( AH -> restorePass == RESTORE_PASS_LAST ) { break ; } AH -> restorePass ++ ; move_to_ready_list ( pending_list , & ready_list , AH -> restorePass ) ; continue ; } else { } WaitForWorkers ( AH , pstate , next_work_item ?WFW_ONE_IDLE : WFW_GOT_STATUS ) ; } Assert ( ready_list . first_te > ready_list . last_te ) ; ready_list_free ( & ready_list ) ; pg_log_info ( "finished main parallel loop" ) ; } 