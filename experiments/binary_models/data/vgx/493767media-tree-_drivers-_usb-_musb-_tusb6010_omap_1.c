struct dma_controller * tusb_dma_controller_create ( struct musb * musb , void __iomem * base ) { void __iomem * tbase = musb -> ctrl_base ; struct tusb_omap_dma * tusb_dma ; int i ; musb_writel ( musb -> ctrl_base , TUSB_DMA_INT_MASK , 0x7fffffff ) ; musb_writel ( musb -> ctrl_base , TUSB_DMA_EP_MAP , 0 ) ; musb_writel ( tbase , TUSB_DMA_REQ_CONF , TUSB_DMA_REQ_CONF_BURST_SIZE ( 2 ) | TUSB_DMA_REQ_CONF_DMA_REQ_EN ( 0x3f ) | TUSB_DMA_REQ_CONF_DMA_REQ_ASSER ( 2 ) ) ; tusb_dma = kzalloc ( sizeof ( tusb_omap_dma ) , GFP_KERNEL ) ; tusb_dma -> controller . musb = musb ; tusb_dma -> tbase = musb -> ctrl_base ; tusb_dma -> ch = - 1 ; tusb_dma -> dmareq = - 1 ; tusb_dma -> sync_dev = - 1 ; tusb_dma -> controller . channel_alloc = tusb_omap_dma_allocate ; tusb_dma -> controller . channel_release = tusb_omap_dma_release ; tusb_dma -> controller . channel_program = tusb_omap_dma_program ; tusb_dma -> controller . channel_abort = tusb_omap_dma_abort ; if ( musb -> tusb_revision >= TUSB_REV_30 ) { tusb_dma -> multichannel = 1 ; } for ( i = 0 ; i < MAX_DMAREQ ; i ++ ) { struct dma_channel * ch ; struct tusb_omap_dma_ch * chdat ; ch = kzalloc ( sizeof ( dma_channel ) , GFP_KERNEL ) ; if ( ! ch ) { cleanup } dma_channel_pool [ i ] = ch ; chdat = kzalloc ( sizeof ( tusb_omap_dma_ch ) , GFP_KERNEL ) ; if ( ! chdat ) { cleanup } ch -> status = MUSB_DMA_STATUS_UNKNOWN ; ch -> private_data = chdat ; } return & tusb_dma -> controller ; cleanup musb_dma_controller_destroy ( & tusb_dma -> controller ) ; out return NULL ; } 