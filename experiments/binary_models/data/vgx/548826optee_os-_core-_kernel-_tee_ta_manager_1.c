static TEE_Result tee_ta_init_session ( TEE_ErrorOrigin * err , struct tee_ta_session_head * open_sessions , const TEE_UUID * uuid , struct tee_ta_session * * sess ) { TEE_Result res ; struct tee_ta_session * s = calloc ( 1 , sizeof ( tee_ta_session ) ) ; * err = TEE_ORIGIN_TEE ; s -> cancel_mask = true ; condvar_init ( & s -> refc_cv ) ; condvar_init ( & s -> lock_cv ) ; s -> lock_thread = THREAD_ID_INVALID ; s -> ref_count = 1 ; mutex_lock ( & tee_ta_mutex ) ; s -> id = new_session_id ( open_sessions ) ; if ( ! s -> id ) { res = TEE_ERROR_OVERFLOW ; err_mutex_unlock } TAILQ_INSERT_TAIL ( open_sessions , s , link ) ; res = tee_ta_init_session_with_context ( s , uuid ) ; mutex_unlock ( & tee_ta_mutex ) ; if ( res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND ) { out } res = stmm_init_session ( uuid , s ) ; if ( res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND ) { out } res = tee_ta_init_pseudo_ta_session ( uuid , s ) ; if ( res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND ) { out } res = tee_ta_init_user_ta_session ( uuid , s ) ; out if ( ! res ) { * sess = s ; return TEE_SUCCESS ; } mutex_lock ( & tee_ta_mutex ) ; TAILQ_REMOVE ( open_sessions , s , link ) ; err_mutex_unlock mutex_unlock ( & tee_ta_mutex ) ; free ( s ) ; return res ; } 