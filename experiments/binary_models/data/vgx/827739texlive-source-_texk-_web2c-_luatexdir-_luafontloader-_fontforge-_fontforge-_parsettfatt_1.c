static void g___ContextSubTable2 ( FILE * ttf , int stoffset , struct ttfinfo * info , struct lookup * l , struct lookup_subtable * subtable , int justinuse , struct lookup * alllooks , int gpos ) { int i , j , k , rcnt , cnt ; uint16 coverage ; uint16 classoff ; subrule { uint32 offset ; int ccnt ; int scnt ; uint16 * classindeces ; struct seqlookup * sl ; } rule { uint32 offsets ; int scnt ; struct subrule * subrules ; } , * rules FPST * fpst ; struct fpst_rule * rule ; uint16 * glyphs , * class ; int warned2 = false ; ( void ) l ; coverage = getushort ( ttf ) ; classoff = getushort ( ttf ) ; rcnt = getushort ( ttf ) ; /* == number of top level rules */ rules = gcalloc ( rcnt , sizeof ( rule ) ) ; for ( i = 0 ; i < rcnt ; ++ i ) { rules [ i ] . offsets = getushort ( ttf ) + stoffset ; } cnt = 0 ; for ( i = 0 ; i < rcnt ; ++ i ) { if ( rules [ i ] . offsets != ( unsigned ) stoffset ) { fseek ( ttf , rules [ i ] . offsets , SEEK_SET ) ; rules [ i ] . scnt = getushort ( ttf ) ; if ( rules [ i ] . scnt < 0 ) { LogError ( _ ( "Bad count in context chaining sub-table.\n" ) ) ; info -> bad_ot = true ; return ; } cnt += rules [ i ] . scnt ; rules [ i ] . subrules = galloc ( rules [ i ] . scnt * sizeof ( subrule ) ) ; for ( j = 0 ; j < rules [ i ] . scnt ; ++ j ) { rules [ i ] . subrules [ j ] . offset = getushort ( ttf ) + rules [ i ] . offsets ; } for ( j = 0 ; j < rules [ i ] . scnt ; ++ j ) { fseek ( ttf , rules [ i ] . subrules [ j ] . offset , SEEK_SET ) ; rules [ i ] . subrules [ j ] . ccnt = getushort ( ttf ) ; rules [ i ] . subrules [ j ] . scnt = getushort ( ttf ) ; if ( rules [ i ] . subrules [ j ] . ccnt < 0 ) { LogError ( _ ( "Bad class count in contextual chaining sub-table.\n" ) ) ; info -> bad_ot = true ; return ; } rules [ i ] . subrules [ j ] . classindeces = galloc ( rules [ i ] . subrules [ j ] . ccnt * sizeof ( uint16 ) ) ; rules [ i ] . subrules [ j ] . classindeces [ 0 ] = i ; for ( k = 1 ; k < rules [ i ] . subrules [ j ] . ccnt ; ++ k ) { rules [ i ] . subrules [ j ] . classindeces [ k ] = getushort ( ttf ) ; } if ( rules [ i ] . subrules [ j ] . scnt < 0 ) { LogError ( _ ( "Bad count in contextual chaining sub-table.\n" ) ) ; info -> bad_ot = true ; free ( rules ) ; return ; } rules [ i ] . subrules [ j ] . sl = galloc ( rules [ i ] . subrules [ j ] . scnt * sizeof ( seqlookup ) ) ; for ( k = 0 ; k < rules [ i ] . subrules [ j ] . scnt ; ++ k ) { rules [ i ] . subrules [ j ] . sl [ k ] . seq = getushort ( ttf ) ; if ( rules [ i ] . subrules [ j ] . sl [ k ] . seq >= rules [ i ] . subrules [ j ] . ccnt ) { if ( ! warned2 ) { LogError ( _ ( "Attempt to apply a lookup to a location out of the range of this contextual\n lookup seq=%d max=%d\n" ) , rules [ i ] . subrules [ j ] . sl [ k ] . seq , rules [ i ] . subrules [ j ] . ccnt - 1 ) ; info -> bad_ot = true ; warned2 = true ; } } rules [ i ] . subrules [ j ] . sl [ k ] . lookup = ( void * ) ( intpt ) getushort ( ttf ) ; } } } } if ( justinuse == git_justinuse ) { } else { fpst = chunkalloc ( sizeof ( FPST ) ) ; fpst -> type = gpos ?pst_contextpos : pst_contextsub ; fpst -> format = pst_class ; fpst -> subtable = subtable ; subtable -> fpst = fpst ; fpst -> next = info -> possub ; info -> possub = fpst ; fpst -> rules = rule = gcalloc ( cnt , sizeof ( fpst_rule ) ) ; fpst -> rule_cnt = cnt ; class = getClassDefTable ( ttf , stoffset + classoff , info ) ; fpst -> nccnt = ClassFindCnt ( class , info -> glyph_cnt ) ; fpst -> nclass = ClassToNames ( info , fpst -> nccnt , class , info -> glyph_cnt ) ; glyphs = getCoverageTable ( ttf , stoffset + coverage , info ) ; fpst -> nclass [ 0 ] = CoverageMinusClasses ( glyphs , class , info ) ; free ( glyphs ) ; free ( class ) ; class = NULL ; cnt = 0 ; for ( i = 0 ; i < rcnt ; ++ i ) { for ( j = 0 ; j < rules [ i ] . scnt ; ++ j ) { rule [ cnt ] . u . class . nclasses = rules [ i ] . subrules [ j ] . classindeces ; rule [ cnt ] . u . class . ncnt = rules [ i ] . subrules [ j ] . ccnt ; rules [ i ] . subrules [ j ] . classindeces = NULL ; rule [ cnt ] . lookup_cnt = rules [ i ] . subrules [ j ] . scnt ; rule [ cnt ] . lookups = rules [ i ] . subrules [ j ] . sl ; rules [ i ] . subrules [ j ] . sl = NULL ; for ( k = 0 ; k < rule [ cnt ] . lookup_cnt ; ++ k ) { ProcessSubLookups ( ttf , info , gpos , alllooks , & rule [ cnt ] . lookups [ k ] ) ; } ++ cnt ; } } } for ( i = 0 ; i < rcnt ; ++ i ) { for ( j = 0 ; j < rules [ i ] . scnt ; ++ j ) { free ( rules [ i ] . subrules [ j ] . classindeces ) ; free ( rules [ i ] . subrules [ j ] . sl ) ; } free ( rules [ i ] . subrules ) ; } free ( rules ) ; } 