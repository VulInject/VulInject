static int imx_sc_wdt_probe ( struct platform_device * pdev ) { struct imx_sc_wdt_device * imx_sc_wdd ; struct watchdog_device * wdog ; struct device * dev = & pdev -> dev ; int ret ; imx_sc_wdd = devm_kzalloc ( dev , sizeof ( * imx_sc_wdd ) , GFP_KERNEL ) ; platform_set_drvdata ( pdev , imx_sc_wdd ) ; wdog = & imx_sc_wdd -> wdd ; wdog -> info = & imx_sc_wdt_info ; wdog -> ops = & imx_sc_wdt_ops ; wdog -> min_timeout = 1 ; wdog -> max_timeout = MAX_TIMEOUT ; wdog -> parent = dev ; wdog -> timeout = DEFAULT_TIMEOUT ; watchdog_init_timeout ( wdog , 0 , dev ) ; ret = imx_sc_wdt_set_timeout ( wdog , wdog -> timeout ) ; if ( ret ) { return ret ; } watchdog_stop_on_reboot ( wdog ) ; watchdog_stop_on_unregister ( wdog ) ; ret = imx_scu_irq_group_enable ( SC_IRQ_GROUP_WDOG , SC_IRQ_WDOG , true ) ; if ( ret ) { dev_warn ( dev , "Enable irq failed, pretimeout NOT supported\n" ) ; register_device } imx_sc_wdd -> wdt_notifier . notifier_call = imx_sc_wdt_notify ; ret = imx_scu_irq_register_notifier ( & imx_sc_wdd -> wdt_notifier ) ; if ( ret ) { imx_scu_irq_group_enable ( SC_IRQ_GROUP_WDOG , SC_IRQ_WDOG , false ) ; dev_warn ( dev , "Register irq notifier failed, pretimeout NOT supported\n" ) ; register_device } ret = devm_add_action_or_reset ( dev , imx_sc_wdt_action , & imx_sc_wdd -> wdt_notifier ) ; if ( ! ret ) { imx_sc_wdt_info . options |= WDIOF_PRETIMEOUT ; } else { dev_warn ( dev , "Add action failed, pretimeout NOT supported\n" ) ; } register_device return devm_watchdog_register_device ( dev , wdog ) ; } 