static int atmel_captouch_probe ( struct i2c_client * client ) { struct atmel_captouch_device * capdev ; struct device * dev = & client -> dev ; struct device_node * node ; int i ; int err ; if ( ! i2c_check_functionality ( client -> adapter , I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_I2C_BLOCK ) ) { dev_err ( dev , "needed i2c functionality is not supported\n" ) ; return - EINVAL ; } capdev = devm_kzalloc ( dev , sizeof ( * capdev ) , GFP_KERNEL ) ; capdev -> client = client ; err = atmel_read ( capdev , REG_KEY_STATE , & capdev -> prev_btn , sizeof ( capdev -> prev_btn ) ) ; if ( err ) { dev_err ( dev , "failed to read initial button state: %d\n" , err ) ; return err ; } capdev -> input = devm_input_allocate_device ( dev ) ; if ( ! capdev -> input ) { dev_err ( dev , "failed to allocate input device\n" ) ; return - ENOMEM ; } capdev -> input -> id . bustype = BUS_I2C ; capdev -> input -> id . product = 0x880A ; capdev -> input -> id . version = 0 ; capdev -> input -> name = "ATMegaXX Capacitive Button Controller" ; __set_bit ( EV_KEY , capdev -> input -> evbit ) ; node = dev -> of_node ; if ( ! node ) { dev_err ( dev , "failed to find matching node in device tree\n" ) ; return - EINVAL ; } if ( of_property_read_bool ( node , "autorepeat" ) ) { __set_bit ( EV_REP , capdev -> input -> evbit ) ; } capdev -> num_btn = of_property_count_u32_elems ( node , "linux,keymap" ) ; if ( capdev -> num_btn > MAX_NUM_OF_BUTTONS ) { capdev -> num_btn = MAX_NUM_OF_BUTTONS ; } err = of_property_read_u32_array ( node , "linux,keycodes" , capdev -> keycodes , capdev -> num_btn ) ; if ( err ) { dev_err ( dev , "failed to read linux,keycode property: %d\n" , err ) ; return err ; } for ( i = 0 ; i < capdev -> num_btn ; i ++ ) { __set_bit ( capdev -> keycodes [ i ] , capdev -> input -> keybit ) ; } capdev -> input -> keycode = capdev -> keycodes ; capdev -> input -> keycodesize = sizeof ( capdev -> keycodes [ 0 ] ) ; capdev -> input -> keycodemax = capdev -> num_btn ; err = input_register_device ( capdev -> input ) ; if ( err ) { return err ; } err = devm_request_threaded_irq ( dev , client -> irq , NULL , atmel_captouch_isr , IRQF_ONESHOT , "atmel_captouch" , capdev ) ; if ( err ) { dev_err ( dev , "failed to request irq %d: %d\n" , client -> irq , err ) ; return err ; } return 0 ; } static const struct of_device_id atmel_captouch_of_id [ ] { { . compatible = "atmel,captouch" } { } } ; ; 