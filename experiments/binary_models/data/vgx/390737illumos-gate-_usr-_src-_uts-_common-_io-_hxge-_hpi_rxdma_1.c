static hpi_status_t hpi_rxdma_cfg_rdc_ctl ( hpi_handle_t handle , uint8_t rdc , uint8_t op ) { rdc_rx_cfg1_t cfg ; uint32_t count = RXDMA_RESET_TRY_COUNT ; uint32_t delay_time = RXDMA_RESET_DELAY ; uint32_t error = HPI_RXDMA_ERROR_ENCODE ( HPI_RXDMA_RESET_ERR , rdc ) ; if ( ! RXDMA_CHANNEL_VALID ( rdc ) ) { HPI_ERROR_MSG ( ( handle . function , HPI_ERR_CTL , "hpi_rxdma_cfg_rdc_ctl Illegal RDC number %d \n" , rdc ) ) ; return ( HPI_RXDMA_RDC_INVALID ) ; } switch ( op ) { case RXDMA_OP_ENABLE : RXDMA_REG_READ64 ( handle , RDC_RX_CFG1 , rdc , & cfg . value ) ; cfg . bits . enable = 1 ; RXDMA_REG_WRITE64 ( handle , RDC_RX_CFG1 , rdc , cfg . value ) ; HXGE_DELAY ( delay_time ) ; RXDMA_REG_READ64 ( handle , RDC_RX_CFG1 , rdc , & cfg . value ) ; while ( ( count -- ) && ( cfg . bits . qst == 1 ) ) { HXGE_DELAY ( delay_time ) ; RXDMA_REG_READ64 ( handle , RDC_RX_CFG1 , rdc , & cfg . value ) ; } if ( cfg . bits . qst == 1 ) { return ( HPI_FAILURE ) ; } break ; case RXDMA_OP_DISABLE : RXDMA_REG_READ64 ( handle , RDC_RX_CFG1 , rdc , & cfg . value ) ; cfg . bits . enable = 0 ; RXDMA_REG_WRITE64 ( handle , RDC_RX_CFG1 , rdc , cfg . value ) ; HXGE_DELAY ( delay_time ) ; if ( hpi_rxdma_cfg_rdc_wait_for_qst ( handle , rdc ) != HPI_SUCCESS ) { HPI_ERROR_MSG ( ( handle . function , HPI_ERR_CTL , " hpi_rxdma_cfg_rdc_ctl" " RXDMA_OP_DISABLE Failed for RDC %d \n" , rdc ) ) ; return ( error ) ; } break ; case RXDMA_OP_RESET : cfg . bits . reset = 1 ; RXDMA_REG_WRITE64 ( handle , RDC_RX_CFG1 , rdc , cfg . value ) ; HXGE_DELAY ( delay_time ) ; RXDMA_REG_READ64 ( handle , RDC_RX_CFG1 , rdc , & cfg . value ) ; while ( ( count -- ) && ( cfg . bits . qst == 0 ) ) { HXGE_DELAY ( delay_time ) ; RXDMA_REG_READ64 ( handle , RDC_RX_CFG1 , rdc , & cfg . value ) ; } if ( count == 0 ) { HPI_ERROR_MSG ( ( handle . function , HPI_ERR_CTL , " hpi_rxdma_cfg_rdc_ctl" " Reset Failed for RDC %d \n" , rdc ) ) ; return ( error ) ; } break ; default : return ( HPI_RXDMA_SW_PARAM_ERROR ) ; } return ( HPI_SUCCESS ) ; } 