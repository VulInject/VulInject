static __be32 nlm4svc_retrieve_args ( struct svc_rqst * rqstp , struct nlm_args * argp , struct nlm_host * * hostp , struct nlm_file * * filp ) { struct nlm_host * host = NULL ; struct nlm_file * file = NULL ; struct nlm_lock * lock = & argp -> lock ; __be32 error = 0 ; if ( ! nlmsvc_ops ) { return nlm_lck_denied_nolocks ; } if ( lock -> lock_start > OFFSET_MAX || ( lock -> lock_len && ( ( lock -> lock_len - 1 ) > ( OFFSET_MAX - lock -> lock_start ) ) ) ) { return nlm4_fbig ; } if ( ! ( host = nlmsvc_lookup_host ( rqstp , lock -> caller , lock -> len ) ) || ( argp -> monitor && nsm_monitor ( host ) < 0 ) ) { no_locks } * hostp = host ; if ( filp != NULL ) { int mode = lock_to_openmode ( & lock -> fl ) ; error = nlm_lookup_file ( rqstp , & file , lock ) ; if ( error ) { no_locks } * filp = file ; lock -> fl . fl_flags = FL_POSIX ; lock -> fl . fl_file = file -> f_file [ mode ] ; lock -> fl . fl_pid = current -> tgid ; lock -> fl . fl_start = ( loff_t ) lock -> lock_start ; lock -> fl . fl_end = lock -> lock_len ?( loff_t ) ( lock -> lock_start + lock -> lock_len - 1 ) : OFFSET_MAX ; lock -> fl . fl_lmops = & nlmsvc_lock_operations ; nlmsvc_locks_init_private ( & lock -> fl , host , ( pid_t ) lock -> svid ) ; if ( ! lock -> fl . fl_owner ) { return nlm_lck_denied_nolocks ; } } return 0 ; no_locks nlmsvc_release_host ( host ) ; if ( error ) { return error ; } return nlm_lck_denied_nolocks ; } 