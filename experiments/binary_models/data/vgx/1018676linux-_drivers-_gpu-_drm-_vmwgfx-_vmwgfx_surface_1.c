static int vmw_surface_dirty_sync ( struct vmw_resource * res ) { struct vmw_private * dev_priv = res -> dev_priv ; u32 i , num_dirty ; struct vmw_surface_dirty * dirty = ( vmw_surface_dirty * ) res -> dirty ; size_t alloc_size ; const struct vmw_surface_cache * cache = & dirty -> cache ; { SVGA3dCmdHeader header ; SVGA3dCmdDXUpdateSubResource body ; } , * cmd1 { SVGA3dCmdHeader header ; SVGA3dCmdUpdateGBImage body ; } , * cmd2 void * cmd ; num_dirty = 0 ; for ( i = 0 ; i < dirty -> num_subres ; ++ i ) { const SVGA3dBox * box = & dirty -> boxes [ i ] ; if ( box -> d ) { num_dirty ++ ; } } if ( ! num_dirty ) { out } alloc_size = num_dirty * ( ( has_sm4_context ( dev_priv ) ) ?sizeof ( * cmd1 ) : sizeof ( * cmd2 ) ) ; cmd = VMW_CMD_RESERVE ( dev_priv , alloc_size ) ; cmd1 = cmd ; cmd2 = cmd ; for ( i = 0 ; i < dirty -> num_subres ; ++ i ) { const SVGA3dBox * box = & dirty -> boxes [ i ] ; if ( ! box -> d ) { continue ; } if ( has_sm4_context ( dev_priv ) ) { cmd1 -> header . id = SVGA_3D_CMD_DX_UPDATE_SUBRESOURCE ; cmd1 -> header . size = sizeof ( cmd1 -> body ) ; cmd1 -> body . sid = res -> id ; cmd1 -> body . subResource = i ; cmd1 -> body . box = * box ; cmd1 ++ ; } else { cmd2 -> header . id = SVGA_3D_CMD_UPDATE_GB_IMAGE ; cmd2 -> header . size = sizeof ( cmd2 -> body ) ; cmd2 -> body . image . sid = res -> id ; cmd2 -> body . image . face = i / cache -> num_mip_levels ; cmd2 -> body . image . mipmap = i - ( cache -> num_mip_levels * cmd2 -> body . image . face ) ; cmd2 -> body . box = * box ; cmd2 ++ ; } } vmw_cmd_commit ( dev_priv , alloc_size ) ; out memset ( & dirty -> boxes [ 0 ] , 0 , sizeof ( dirty -> boxes [ 0 ] ) * dirty -> num_subres ) ; return 0 ; } 