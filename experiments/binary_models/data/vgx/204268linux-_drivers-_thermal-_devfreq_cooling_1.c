struct thermal_cooling_device * of_devfreq_cooling_register_power ( struct device_node * np , struct devfreq * df , struct devfreq_cooling_power * dfc_power ) { struct thermal_cooling_device * cdev ; struct device * dev = df -> dev . parent ; struct devfreq_cooling_device * dfc ; struct em_perf_domain * em ; struct thermal_cooling_device_ops * ops ; char * name ; int err , num_opps ; dfc = kmalloc ( sizeof ( * dfc ) , GFP_KERNEL ) ; if ( ! dfc ) { return ERR_PTR ( - ENOMEM ) ; } dfc -> devfreq = df ; ops = & dfc -> cooling_ops ; ops -> get_max_state = devfreq_cooling_get_max_state ; ops -> get_cur_state = devfreq_cooling_get_cur_state ; ops -> set_cur_state = devfreq_cooling_set_cur_state ; em = em_pd_get ( dev ) ; if ( em && ! em_is_artificial ( em ) ) { dfc -> em_pd = em ; ops -> get_requested_power = devfreq_cooling_get_requested_power ; ops -> state2power = devfreq_cooling_state2power ; ops -> power2state = devfreq_cooling_power2state ; dfc -> power_ops = dfc_power ; num_opps = em_pd_nr_perf_states ( dfc -> em_pd ) ; } else { dev_dbg ( dev , "missing proper EM for cooling device\n" ) ; num_opps = dev_pm_opp_get_opp_count ( dev ) ; err = devfreq_cooling_gen_tables ( dfc , num_opps ) ; if ( err ) { free_dfc } } if ( num_opps <= 0 ) { err = - EINVAL ; free_dfc } dfc -> max_state = num_opps - 1 ; err = dev_pm_qos_add_request ( dev , & dfc -> req_max_freq , DEV_PM_QOS_MAX_FREQUENCY , PM_QOS_MAX_FREQUENCY_DEFAULT_VALUE ) ; if ( err < 0 ) { free_table } err = - ENOMEM ; name = kasprintf ( GFP_KERNEL , "devfreq-%s" , dev_name ( dev ) ) ; if ( ! name ) { remove_qos_req } cdev = thermal_of_cooling_device_register ( np , name , dfc , ops ) ; kfree ( name ) ; if ( IS_ERR ( cdev ) ) { err = PTR_ERR ( cdev ) ; dev_err ( dev , "Failed to register devfreq cooling device (%d)\n" , err ) ; remove_qos_req } dfc -> cdev = cdev ; return cdev ; remove_qos_req dev_pm_qos_remove_request ( & dfc -> req_max_freq ) ; free_table kfree ( dfc -> freq_table ) ; free_dfc kfree ( dfc ) ; return ERR_PTR ( err ) ; } 