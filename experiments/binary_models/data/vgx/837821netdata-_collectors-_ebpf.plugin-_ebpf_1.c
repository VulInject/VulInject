static void read_local_addresses ( ) { struct ifaddrs * ifaddr , * ifa ; if ( getifaddrs ( & ifaddr ) == - 1 ) { error ( "Cannot get the local IP addresses, it is no possible to do separation between inbound and outbound connections" ) ; return ; } char * notext = { "No text representation" } ; for ( ifa = ifaddr ; ifa != NULL ; ifa = ifa -> ifa_next ) { if ( ( ifa -> ifa_addr -> sa_family != AF_INET ) && ( ifa -> ifa_addr -> sa_family != AF_INET6 ) ) { continue ; } ebpf_network_viewer_ip_list_t * w = callocz ( 1 , sizeof ( ebpf_network_viewer_ip_list_t ) ) ; int family = ifa -> ifa_addr -> sa_family ; w -> ver = ( uint8_t ) family ; char text [ INET6_ADDRSTRLEN ] ; if ( family == AF_INET ) { struct sockaddr_in * in = ( sockaddr_in * ) ifa -> ifa_addr ; w -> first . addr32 [ 0 ] = in -> sin_addr . s_addr ; w -> last . addr32 [ 0 ] = in -> sin_addr . s_addr ; if ( inet_ntop ( AF_INET , w -> first . addr8 , text , INET_ADDRSTRLEN ) ) { w -> value = strdupz ( text ) ; w -> hash = simple_hash ( text ) ; } else { w -> value = strdupz ( notext ) ; w -> hash = simple_hash ( notext ) ; } } else { struct sockaddr_in6 * in6 = ( sockaddr_in6 * ) ifa -> ifa_addr ; memcpy ( w -> first . addr8 , ( void * ) & in6 -> sin6_addr , sizeof ( in6_addr ) ) ; memcpy ( w -> last . addr8 , ( void * ) & in6 -> sin6_addr , sizeof ( in6_addr ) ) ; if ( inet_ntop ( AF_INET6 , w -> first . addr8 , text , INET_ADDRSTRLEN ) ) { w -> value = strdupz ( text ) ; w -> hash = simple_hash ( text ) ; } else { w -> value = strdupz ( notext ) ; w -> hash = simple_hash ( notext ) ; } } ebpf_fill_ip_list ( ( family == AF_INET ) ?& network_viewer_opt . ipv4_local_ip : & network_viewer_opt . ipv6_local_ip , w , "selector" ) ; } freeifaddrs ( ifaddr ) ; } 