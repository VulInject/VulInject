static void raw_diag_dump ( struct sk_buff * skb , struct netlink_callback * cb , const struct inet_diag_req_v2 * r ) { bool net_admin = netlink_net_capable ( cb -> skb , CAP_NET_ADMIN ) ; struct raw_hashinfo * hashinfo = raw_get_hashinfo ( r ) ; struct net * net = sock_net ( skb -> sk ) ; struct inet_diag_dump_data * cb_data ; struct hlist_nulls_head * hlist ; struct hlist_nulls_node * hnode ; int num , s_num , slot , s_slot ; struct sock * sk = NULL ; struct nlattr * bc ; cb_data = cb -> data ; bc = cb_data -> inet_diag_nla_bc ; s_slot = cb -> args [ 0 ] ; num = s_num = cb -> args [ 1 ] ; rcu_read_lock ( ) ; for ( slot = s_slot ; slot < RAW_HTABLE_SIZE ; s_num = 0 , slot ++ ) { num = 0 ; hlist = & hashinfo -> ht [ slot ] ; sk_nulls_for_each ( , , ) { struct inet_sock * inet = inet_sk ( sk ) ; if ( ! net_eq ( sock_net ( sk ) , net ) ) { continue ; } if ( num < s_num ) { next } if ( sk -> sk_family != r -> sdiag_family ) { next } if ( r -> id . idiag_sport != inet -> inet_sport && r -> id . idiag_sport ) { next } if ( r -> id . idiag_dport != inet -> inet_dport && r -> id . idiag_dport ) { next } if ( sk_diag_dump ( sk , skb , cb , r , bc , net_admin ) < 0 ) { out_unlock } next num ++ ; } } out_unlock rcu_read_unlock ( ) ; cb -> args [ 0 ] = slot ; cb -> args [ 1 ] = num ; } 