static bool check_digital_port_conflicts ( struct intel_atomic_state * state ) { struct drm_device * dev = state -> base . dev ; struct drm_connector * connector ; struct drm_connector_list_iter conn_iter ; unsigned int used_ports = 0 ; unsigned int used_mst_ports = 0 ; bool ret = true ; drm_modeset_lock_assert_held ( & dev -> mode_config . connection_mutex ) ; drm_connector_list_iter_begin ( dev , & conn_iter ) ; drm_for_each_connector_iter ( , ) { struct drm_connector_state * connector_state ; struct intel_encoder * encoder ; connector_state = drm_atomic_get_new_connector_state ( & state -> base , connector ) ; if ( ! connector_state ) { connector_state = connector -> state ; } encoder = to_intel_encoder ( connector_state -> best_encoder ) ; drm_WARN_ON ( dev , ! connector_state -> crtc ) ; switch ( encoder -> type ) { case INTEL_OUTPUT_DDI : if ( drm_WARN_ON ( dev , ! HAS_DDI ( to_i915 ( dev ) ) ) ) { break ; } fallthrough ; case INTEL_OUTPUT_DP : case INTEL_OUTPUT_HDMI : case INTEL_OUTPUT_EDP : if ( used_ports & BIT ( encoder -> port ) ) { ret = false ; } used_ports |= BIT ( encoder -> port ) ; break ; case INTEL_OUTPUT_DP_MST : used_mst_ports |= 1 << encoder -> port ; break ; default : break ; } } drm_connector_list_iter_end ( & conn_iter ) ; if ( used_ports & used_mst_ports ) { return false ; } return ret ; } 