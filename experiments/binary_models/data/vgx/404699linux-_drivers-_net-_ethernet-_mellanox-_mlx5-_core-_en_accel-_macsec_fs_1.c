static union mlx5e_macsec_rule * macsec_fs_rx_add_rule ( struct mlx5e_macsec_fs * macsec_fs , const struct macsec_context * macsec_ctx , struct mlx5_macsec_rule_attrs * attrs , u32 fs_id ) { u8 action [ MLX5_UN_SZ_BYTES ( set_add_copy_action_in_auto ) ] { } ; ; struct mlx5e_macsec_rx * rx_fs = macsec_fs -> rx_fs ; struct net_device * netdev = macsec_fs -> netdev ; union mlx5e_macsec_rule * macsec_rule = NULL ; struct mlx5_modify_hdr * modify_hdr = NULL ; struct mlx5_flow_destination dest = { } ; struct mlx5e_macsec_tables * rx_tables ; struct mlx5e_macsec_rx_rule * rx_rule ; struct mlx5_flow_act flow_act = { } ; struct mlx5e_flow_table * ft_crypto ; struct mlx5_flow_handle * rule ; struct mlx5_flow_spec * spec ; int err = 0 ; spec = kvzalloc ( sizeof ( * spec ) , GFP_KERNEL ) ; if ( ! spec ) { return NULL ; } err = macsec_fs_rx_ft_get ( macsec_fs ) ; if ( err ) { out_spec } macsec_rule = kzalloc ( sizeof ( * macsec_rule ) , GFP_KERNEL ) ; if ( ! macsec_rule ) { macsec_fs_rx_ft_put ( macsec_fs ) ; out_spec } rx_rule = & macsec_rule -> rx_rule ; rx_tables = & rx_fs -> tables ; ft_crypto = & rx_tables -> ft_crypto ; MLX5_SET ( set_action_in , action , action_type , MLX5_ACTION_TYPE_SET ) ; MLX5_SET ( set_action_in , action , field , MLX5_ACTION_IN_FIELD_METADATA_REG_B ) ; MLX5_SET ( set_action_in , action , data , MLX5_MACSEC_RX_METADAT_HANDLE ( fs_id ) | BIT ( 30 ) ) ; MLX5_SET ( set_action_in , action , offset , 0 ) ; MLX5_SET ( set_action_in , action , length , 32 ) ; modify_hdr = mlx5_modify_header_alloc ( macsec_fs -> mdev , MLX5_FLOW_NAMESPACE_KERNEL_RX_MACSEC , 1 , action ) ; if ( IS_ERR ( modify_hdr ) ) { err = PTR_ERR ( modify_hdr ) ; netdev_err ( netdev , "fail to alloc MACsec set modify_header_id err=%d\n" , err ) ; modify_hdr = NULL ; err } rx_rule -> meta_modhdr = modify_hdr ; macsec_fs_rx_setup_fte ( spec , & flow_act , attrs , true ) ; flow_act . modify_hdr = modify_hdr ; flow_act . action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST | MLX5_FLOW_CONTEXT_ACTION_CRYPTO_DECRYPT | MLX5_FLOW_CONTEXT_ACTION_MOD_HDR ; dest . type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE ; dest . ft = rx_tables -> ft_check ; rule = mlx5_add_flow_rules ( ft_crypto -> t , spec , & flow_act , & dest , 1 ) ; if ( IS_ERR ( rule ) ) { err = PTR_ERR ( rule ) ; netdev_err ( netdev , "Failed to add SA with SCI rule to Rx crypto rule, err=%d\n" , err ) ; err } rx_rule -> rule [ 0 ] = rule ; if ( ( cpu_to_be64 ( ( __force u64 ) attrs -> sci ) & 0xFFFF ) == ntohs ( MACSEC_PORT_ES ) ) { memset ( spec , 0 , sizeof ( mlx5_flow_spec ) ) ; memset ( & dest , 0 , sizeof ( mlx5_flow_destination ) ) ; macsec_fs_rx_setup_fte ( spec , & flow_act , attrs , false ) ; flow_act . modify_hdr = modify_hdr ; flow_act . action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST | MLX5_FLOW_CONTEXT_ACTION_CRYPTO_DECRYPT | MLX5_FLOW_CONTEXT_ACTION_MOD_HDR ; dest . type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE ; dest . ft = rx_tables -> ft_check ; rule = mlx5_add_flow_rules ( ft_crypto -> t , spec , & flow_act , & dest , 1 ) ; if ( IS_ERR ( rule ) ) { err = PTR_ERR ( rule ) ; netdev_err ( netdev , "Failed to add SA without SCI rule to Rx crypto rule, err=%d\n" , err ) ; err } rx_rule -> rule [ 1 ] = rule ; } kvfree ( spec ) ; return macsec_rule ; err macsec_fs_rx_del_rule ( macsec_fs , rx_rule ) ; macsec_rule = NULL ; out_spec kvfree ( spec ) ; return macsec_rule ; } 