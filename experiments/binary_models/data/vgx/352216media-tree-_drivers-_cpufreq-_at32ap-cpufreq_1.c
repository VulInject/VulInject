static int at32_cpufreq_driver_init ( struct cpufreq_policy * policy ) { unsigned int frequency , rate , min_freq ; struct clk * cpuclk ; int retval , steps , i ; if ( policy -> cpu != 0 ) { return - EINVAL ; } cpuclk = clk_get ( NULL , "cpu" ) ; if ( IS_ERR ( cpuclk ) ) { pr_debug ( "cpufreq: could not get CPU clk\n" ) ; retval = PTR_ERR ( cpuclk ) ; out_err } min_freq = ( clk_round_rate ( cpuclk , 1 ) + 500 ) / 1000 ; frequency = ( clk_round_rate ( cpuclk , ~ 0UL ) + 500 ) / 1000 ; policy -> cpuinfo . transition_latency = 0 ; steps = fls ( frequency / min_freq ) + 1 ; freq_table = kzalloc ( steps * sizeof ( cpufreq_frequency_table ) , GFP_KERNEL ) ; if ( ! freq_table ) { retval = - ENOMEM ; out_err_put_clk } for ( i = 0 ; i < ( steps - 1 ) ; i ++ ) { rate = clk_round_rate ( cpuclk , frequency * 1000 ) / 1000 ; if ( rate != frequency ) { freq_table [ i ] . frequency = CPUFREQ_ENTRY_INVALID ; } else { freq_table [ i ] . frequency = frequency ; } frequency /= 2 ; } policy -> clk = cpuclk ; freq_table [ steps - 1 ] . frequency = CPUFREQ_TABLE_END ; retval = cpufreq_table_validate_and_show ( policy , freq_table ) ; if ( ! retval ) { printk ( "cpufreq: AT32AP CPU frequency driver\n" ) ; return 0 ; } out_err_put_clk clk_put ( cpuclk ) ; out_err return retval ; } 