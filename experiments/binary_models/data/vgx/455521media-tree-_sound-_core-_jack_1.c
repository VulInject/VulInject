int snd_jack_new ( struct snd_card * card , const char * id , int type , struct snd_jack * * jjack , bool initial_kctl , bool phantom_jack ) { struct snd_jack * jack ; struct snd_jack_kctl * jack_kctl = NULL ; int err ; static struct snd_device_ops ops = { . dev_free = snd_jack_dev_free . dev_register = snd_jack_dev_register . dev_disconnect = snd_jack_dev_disconnect } ; if ( initial_kctl ) { jack_kctl = snd_jack_kctl_new ( card , id , type ) ; if ( ! jack_kctl ) { return - ENOMEM ; } } jack = kzalloc ( sizeof ( snd_jack ) , GFP_KERNEL ) ; if ( jack == NULL ) { return - ENOMEM ; } jack -> id = kstrdup ( id , GFP_KERNEL ) ; if ( ! phantom_jack ) { int i ; jack -> input_dev = input_allocate_device ( ) ; if ( jack -> input_dev == NULL ) { err = - ENOMEM ; fail_input } jack -> input_dev -> phys = "ALSA" ; jack -> type = type ; for ( i = 0 ; i < SND_JACK_SWITCH_TYPES ; i ++ ) { if ( type & ( 1 << i ) ) { input_set_capability ( jack -> input_dev , EV_SW , jack_switch_types [ i ] ) ; } } } err = snd_device_new ( card , SNDRV_DEV_JACK , jack , & ops ) ; if ( err < 0 ) { fail_input } jack -> card = card ; INIT_LIST_HEAD ( & jack -> kctl_list ) ; if ( initial_kctl ) { snd_jack_kctl_add ( jack , jack_kctl ) ; } * jjack = jack ; return 0 ; fail_input input_free_device ( jack -> input_dev ) ; kfree ( jack -> id ) ; return err ; } 