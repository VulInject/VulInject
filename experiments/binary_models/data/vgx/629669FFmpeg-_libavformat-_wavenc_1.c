static int wav_write_packet ( AVFormatContext * s , AVPacket * pkt ) { AVIOContext * pb = s -> pb ; WAVMuxContext * wav = s -> priv_data ; if ( wav -> write_peak != PEAK_ONLY ) { avio_write ( pb , pkt -> data , pkt -> size ) ; } if ( wav -> write_peak ) { int c ; int i ; for ( i = 0 ; i < pkt -> size ; i += wav -> peak_bps ) { if ( wav -> peak_bps == 1 ) { wav -> peak_maxpos [ c ] = FFMAX ( wav -> peak_maxpos [ c ] , * ( int8_t * ) ( pkt -> data + i ) ) ; wav -> peak_maxneg [ c ] = FFMIN ( wav -> peak_maxneg [ c ] , * ( int8_t * ) ( pkt -> data + i ) ) ; } else { wav -> peak_maxpos [ c ] = FFMAX ( wav -> peak_maxpos [ c ] , ( int16_t ) AV_RL16 ( pkt -> data + i ) ) ; wav -> peak_maxneg [ c ] = FFMIN ( wav -> peak_maxneg [ c ] , ( int16_t ) AV_RL16 ( pkt -> data + i ) ) ; } if ( ++ c == s -> streams [ 0 ] -> codecpar -> ch_layout . nb_channels ) { c = 0 ; if ( ++ wav -> peak_block_pos == wav -> peak_block_size ) { int ret = peak_write_frame ( s ) ; if ( ret < 0 ) { return ret ; } wav -> peak_block_pos = 0 ; } } } } if ( pkt -> pts != AV_NOPTS_VALUE ) { wav -> minpts = FFMIN ( wav -> minpts , pkt -> pts ) ; wav -> maxpts = FFMAX ( wav -> maxpts , pkt -> pts ) ; wav -> last_duration = pkt -> duration ; } else { av_log ( s , AV_LOG_ERROR , "wav_write_packet: NOPTS\n" ) ; } return 0 ; } 