static void iscsi_cmd_state_free ( iscsi_cmd_t * icmdp , iscsi_cmd_event_t event , void * arg ) static void iscsi_cmd_state_pending ( iscsi_cmd_t * icmdp , iscsi_cmd_event_t event , void * arg ) static void iscsi_cmd_state_active ( iscsi_cmd_t * icmdp , iscsi_cmd_event_t event , void * arg ) static void iscsi_cmd_state_aborting ( iscsi_cmd_t * icmdp , iscsi_cmd_event_t event , void * arg ) static void iscsi_cmd_state_idm_aborting ( iscsi_cmd_t * icmdp , iscsi_cmd_event_t event , void * arg ) static void iscsi_cmd_state_completed ( iscsi_cmd_t * icmdp , iscsi_cmd_event_t event , void * arg ) static char * iscsi_cmd_state_str ( iscsi_cmd_state_t state ) static char * iscsi_cmd_event_str ( iscsi_cmd_event_t event ) static char * iscsi_cmd_type_str ( iscsi_cmd_type_t type ) icmdp -> cmd_completed = B_TRUE ; icmdp -> cmd_result = status ; cv_broadcast ( & icmdp -> cmd_completion ) ; icmdp -> cmd_un . scsi . pkt -> pkt_reason = reason ; icmdp -> cmd_un . scsi . pkt -> pkt_statistics = stat ; int iscsi_cmd_timeout_factor = 1 ; void iscsi_cmd_state_machine ( iscsi_cmd_t * icmdp , iscsi_cmd_event_t event , void * arg ) { boolean_t release_lock = B_TRUE ; ASSERT ( icmdp != NULL ) ; ASSERT ( arg != NULL ) ; DTRACE_PROBE3 ( event , iscsi_cmd_t * , icmdp , char * , iscsi_cmd_state_str ( icmdp -> cmd_state ) , char * , iscsi_cmd_event_str ( event ) ) ; mutex_enter ( & icmdp -> cmd_mutex ) ; idm_sm_audit_event ( & icmdp -> cmd_state_audit , SAS_ISCSI_CMD , icmdp -> cmd_state , event , ( uintptr_t ) arg ) ; icmdp -> cmd_prev_state = icmdp -> cmd_state ; switch ( icmdp -> cmd_state ) { case ISCSI_CMD_STATE_FREE : iscsi_cmd_state_free ( icmdp , event , arg ) ; break ; case ISCSI_CMD_STATE_PENDING : iscsi_cmd_state_pending ( icmdp , event , arg ) ; break ; case ISCSI_CMD_STATE_ACTIVE : iscsi_cmd_state_active ( icmdp , event , arg ) ; break ; case ISCSI_CMD_STATE_ABORTING : iscsi_cmd_state_aborting ( icmdp , event , arg ) ; break ; case ISCSI_CMD_STATE_IDM_ABORTING : iscsi_cmd_state_idm_aborting ( icmdp , event , arg ) ; break ; case ISCSI_CMD_STATE_COMPLETED : iscsi_cmd_state_completed ( icmdp , event , arg ) ; release_lock = B_FALSE ; break ; default : ASSERT ( FALSE , NULL ) ; } if ( release_lock == B_TRUE ) { idm_sm_audit_state_change ( & icmdp -> cmd_state_audit , SAS_ISCSI_CMD , icmdp -> cmd_prev_state , icmdp -> cmd_state ) ; if ( ! ( icmdp -> cmd_misc_flags & ISCSI_CMD_MISCFLAG_FREE ) || ! ( icmdp -> cmd_misc_flags & ISCSI_CMD_MISCFLAG_INTERNAL ) ) { mutex_exit ( & icmdp -> cmd_mutex ) ; return ; } mutex_exit ( & icmdp -> cmd_mutex ) ; iscsi_cmd_free ( icmdp ) ; } } 