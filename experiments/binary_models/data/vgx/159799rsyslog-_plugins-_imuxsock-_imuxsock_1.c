static void std_checkRuleset_genErrMsg ( __attribute__ ( ) modConfData_t * modConf , instanceConf_t * inst ) ( LogError ( 0 , NO_ERRCODE , "imuxsock: ruleset '%s' for socket %s not found - " "using default ruleset instead" , inst -> pszBindRuleset , inst -> sockName ) ) BEGINcheckCnf instanceConf_t * inst ; CODESTARTcheckCnf for ( inst = pModConf -> root ; inst != NULL ; inst = inst -> next ) { std_checkRuleset ( pModConf , inst ) ; } ENDcheckCnf BEGINactivateCnfPrePrivDrop instanceConf_t * inst ; int nLstn ; int i ; CODESTARTactivateCnfPrePrivDrop runModConf = pModConf ; startIndexUxLocalSockets = 1 ; startIndexUxLocalSockets = runModConf -> bOmitLocalLogging ?1 : 0 ; nLstn = 0 ; for ( inst = runModConf -> root ; inst != NULL ; inst = inst -> next ) { ++ nLstn ; } if ( nLstn > 0 || startIndexUxLocalSockets == 0 ) { DBGPRINTF ( "imuxsock: allocating memory for %d listeners\n" , nLstn ) ; lstn_t * const listeners_new = realloc ( listeners , ( 1 + nLstn ) * sizeof ( lstn_t ) ) ; CHKmalloc ( listeners_new ) ; listeners = listeners_new ; for ( i = 1 ; i < nLstn ; ++ i ) { listeners [ i ] . sockName = NULL ; listeners [ i ] . fd = - 1 ; } for ( inst = runModConf -> root ; inst != NULL ; inst = inst -> next ) { addListner ( inst ) ; } CHKiRet ( activateListeners ( ) ) ; } finalize_it ENDactivateCnfPrePrivDrop BEGINactivateCnf CODESTARTactivateCnf ENDactivateCnf BEGINfreeCnf instanceConf_t * inst , * del ; CODESTARTfreeCnf free ( pModConf -> pLogSockName ) for ( inst = pModConf -> root ; inst != NULL ; ) { free ( inst -> sockName ) ; free ( inst -> pszBindRuleset ) ; del = inst ; inst = inst -> next ; free ( del ) ; } ENDfreeCnf BEGINrunInput int nfds ; int i ; CODESTARTrunInput struct pollfd * const pollfds = calloc ( nfd , sizeof ( pollfd ) ) ; CHKmalloc ( pollfds ) ; if ( startIndexUxLocalSockets == 1 && nfd == 1 ) { ABORT_FINALIZE ( RS_RET_OK ) ; } if ( startIndexUxLocalSockets == 1 ) { pollfds [ 0 ] . fd = - 1 ; } for ( i = startIndexUxLocalSockets ; i < nfd ; i ++ ) { pollfds [ i ] . fd = listeners [ i ] . fd ; pollfds [ i ] . events = POLLIN ; } while ( 1 ) { DBGPRINTF ( "--------imuxsock calling poll() on %d fds\n" , nfd ) ; nfds = poll ( pollfds , nfd , - 1 ) ; if ( glbl . GetGlobalInputTermState ( ) == 1 ) { break ; } if ( nfds < 0 ) { if ( errno == EINTR ) { DBGPRINTF ( "imuxsock: EINTR occurred\n" ) ; } else { LogMsg ( errno , RS_RET_POLL_ERR , LOG_WARNING , "imuxsock: poll " "system call failed, may cause further troubles" ) ; } nfds = 0 ; } for ( i = startIndexUxLocalSockets ; i ( nfd && nfds ) 0 ; i ++ ) { if ( glbl . GetGlobalInputTermState ( ) == 1 ) { ABORT_FINALIZE ( RS_RET_FORCE_TERM ) ; } if ( pollfds [ i ] . revents & POLLIN ) { readSocket ( & ( listeners [ i ] ) ) ; -- nfds ; } } } finalize_it free ( pollfds ) ; ENDrunInput BEGINwillRun CODESTARTwillRun ENDwillRun BEGINafterRun int i ; CODESTARTafterRun if ( startIndexUxLocalSockets == 1 && nfd == 1 ) { return RS_RET_OK ; } for ( i = 0 ; i < nfd ; i ++ ) { if ( listeners [ i ] . fd != - 1 ) { close ( listeners [ i ] . fd ) ; } } for ( i = startIndexUxLocalSockets ; i < nfd ; i ++ ) { if ( listeners [ i ] . sockName && listeners [ i ] . fd != - 1 ) { if ( sd_fds > 0 && listeners [ i ] . fd >= SD_LISTEN_FDS_START && listeners [ i ] . fd < SD_LISTEN_FDS_START + sd_fds ) { continue ; } if ( listeners [ i ] . bUnlink ) { DBGPRINTF ( "imuxsock: unlinking unix socket file[%d] %s\n" , i , listeners [ i ] . sockName ) ; unlink ( ( char * ) listeners [ i ] . sockName ) ; } } } discardLogSockets ( ) ; nfd = 1 ; ENDafterRun BEGINmodExit CODESTARTmodExit free ( listeners ) if ( pInputName != NULL ) { prop . Destruct ( & pInputName ) ; } statsobj . Destruct ( & modStats ) ; objRelease ( parser , CORE_COMPONENT ) ; objRelease ( glbl , CORE_COMPONENT ) ; objRelease ( prop , CORE_COMPONENT ) ; objRelease ( statsobj , CORE_COMPONENT ) ; objRelease ( datetime , CORE_COMPONENT ) ; objRelease ( ruleset , CORE_COMPONENT ) ; ENDmodExit BEGINisCompatibleWithFeature CODESTARTisCompatibleWithFeature ( eFeat == sFEATURENonCancelInputTermination ) iRet = RS_RET_OK ; ENDisCompatibleWithFeature BEGINqueryEtryPt CODESTARTqueryEtryPt CODEqueryEtryPt_STD_IMOD_QUERIES CODEqueryEtryPt_STD_CONF2_QUERIES CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES ENDqueryEtryPt static rsRetVal resetConfigVariables ( uchar __attribute__ ( ( unused ) ) * pp , void __attribute__ ( ( unused ) ) * pVal ) ( free ( cs . pLogSockName ) , cs . pLogSockName = NULL , free ( cs . pLogHostName ) , cs . bOmitLocalLogging = 0 , cs . pLogHostName = NULL , cs . bIgnoreTimestamp = 1 , cs . bIgnoreTimestampSysSock = 1 , cs . bUseFlowCtl = 0 , cs . bUseFlowCtlSysSock = 0 , cs . bUseSysTimeStamp = 1 , cs . bUseSysTimeStampSysSock = 1 , cs . bWritePid = 0 , cs . bWritePidSysSock = 0 , cs . bAnnotate = 0 , cs . bAnnotateSysSock = 0 , cs . bParseTrusted = 0 , cs . bCreatePath = DFLT_bCreatePath , cs . ratelimitInterval = DFLT_ratelimitInterval , cs . ratelimitIntervalSysSock = DFLT_ratelimitInterval , cs . ratelimitBurst = DFLT_ratelimitBurst , cs . ratelimitBurstSysSock = DFLT_ratelimitBurst , cs . ratelimitSeverity = DFLT_ratelimitSeverity , cs . ratelimitSeveritySysSock = DFLT_ratelimitSeverity , RS_RET_OK ) ; 