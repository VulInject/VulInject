static int dcon_probe ( struct i2c_client * client ) { struct dcon_priv * dcon ; int rc , i , j ; if ( ! pdata ) { return - ENXIO ; } dcon = kzalloc ( sizeof ( * dcon ) , GFP_KERNEL ) ; if ( ! dcon ) { return - ENOMEM ; } dcon -> client = client ; init_waitqueue_head ( & dcon -> waitq ) ; INIT_WORK ( & dcon -> switch_source , dcon_source_switch ) ; dcon -> reboot_nb . notifier_call = dcon_reboot_notify ; dcon -> reboot_nb . priority = - 1 ; i2c_set_clientdata ( client , dcon ) ; if ( num_registered_fb < 1 ) { dev_err ( & client -> dev , "DCON driver requires a registered fb\n" ) ; rc = - EIO ; einit } dcon -> fbinfo = registered_fb [ 0 ] ; rc = dcon_hw_init ( dcon , 1 ) ; if ( rc ) { einit } dcon_device = platform_device_alloc ( "dcon" , - 1 ) ; if ( ! dcon_device ) { pr_err ( "Unable to create the DCON device\n" ) ; rc = - ENOMEM ; eirq } rc = platform_device_add ( dcon_device ) ; platform_set_drvdata ( dcon_device , dcon ) ; if ( rc ) { pr_err ( "Unable to add the DCON device\n" ) ; edev } for ( i = 0 ; i < ARRAY_SIZE ( dcon_device_files ) ; i ++ ) { rc = device_create_file ( & dcon_device -> dev , & dcon_device_files [ i ] ) ; if ( rc ) { dev_err ( & dcon_device -> dev , "Cannot create sysfs file\n" ) ; ecreate } } dcon -> bl_val = dcon_read ( dcon , DCON_REG_BRIGHT ) & 0x0F ; dcon_bl_props . brightness = dcon -> bl_val ; dcon -> bl_dev = backlight_device_register ( "dcon-bl" , & dcon_device -> dev , dcon , & dcon_bl_ops , & dcon_bl_props ) ; if ( IS_ERR ( dcon -> bl_dev ) ) { dev_err ( & client -> dev , "cannot register backlight dev (%ld)\n" , PTR_ERR ( dcon -> bl_dev ) ) ; dcon -> bl_dev = NULL ; } register_reboot_notifier ( & dcon -> reboot_nb ) ; atomic_notifier_chain_register ( & panic_notifier_list , & dcon_panic_nb ) ; return 0 ; ecreate for ( j = 0 ; j < i ; j ++ ) { device_remove_file ( & dcon_device -> dev , & dcon_device_files [ j ] ) ; } platform_device_del ( dcon_device ) ; edev platform_device_put ( dcon_device ) ; dcon_device = NULL ; eirq free_irq ( DCON_IRQ , dcon ) ; einit return rc ; } 