static bool ip6_parse_tlv ( bool hopbyhop , struct sk_buff * skb , int max_count ) { int len = ( skb_transport_header ( skb ) [ 1 ] + 1 ) << 3 ; const unsigned char * nh = skb_network_header ( skb ) ; int off = skb_network_header_len ( skb ) ; bool disallow_unknowns = false ; int tlv_count = 0 ; int padlen = 0 ; if ( unlikely ( max_count < 0 ) ) { disallow_unknowns = true ; max_count = - max_count ; } if ( skb_transport_offset ( skb ) + len > skb_headlen ( skb ) ) { bad } off += 2 ; len -= 2 ; while ( len > 0 ) { int optlen , i ; if ( nh [ off ] == IPV6_TLV_PAD1 ) { padlen ++ ; if ( padlen > 7 ) { bad } off ++ ; len -- ; continue ; } if ( len < 2 ) { bad } optlen = nh [ off + 1 ] + 2 ; if ( optlen > len ) { bad } if ( nh [ off ] == IPV6_TLV_PADN ) { padlen += optlen ; if ( padlen > 7 ) { bad } for ( i = 2 ; i < optlen ; i ++ ) { if ( nh [ off + i ] != 0 ) { bad } } } else { tlv_count ++ ; if ( tlv_count > max_count ) { bad } if ( hopbyhop ) { switch ( nh [ off ] ) { case IPV6_TLV_ROUTERALERT : break ; case IPV6_TLV_IOAM : if ( ! ipv6_hop_ioam ( skb , off ) ) { return false ; } break ; case IPV6_TLV_JUMBO : if ( ! ipv6_hop_jumbo ( skb , off ) ) { return false ; } break ; case IPV6_TLV_CALIPSO : if ( ! ipv6_hop_calipso ( skb , off ) ) { return false ; } break ; default : if ( ! ip6_tlvopt_unknown ( skb , off , disallow_unknowns ) ) { return false ; } break ; } } else { switch ( nh [ off ] ) { case IPV6_TLV_HAO : if ( ! ipv6_dest_hao ( skb , off ) ) { return false ; } break ; default : if ( ! ip6_tlvopt_unknown ( skb , off , disallow_unknowns ) ) { return false ; } break ; } } padlen = 0 ; } off += optlen ; len -= optlen ; } if ( len == 0 ) { return true ; } bad kfree_skb_reason ( skb , SKB_DROP_REASON_IP_INHDR ) ; return false ; } 