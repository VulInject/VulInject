void * bnxt_qplib_rcfw_send_message ( struct bnxt_qplib_rcfw * rcfw , struct cmdq_base * req , void * * crsbe , u8 is_block ) { struct bnxt_qplib_crsq * crsq = & rcfw -> crsq ; struct bnxt_qplib_cmdqe * cmdqe , * * cmdq_ptr ; struct bnxt_qplib_hwq * cmdq = & rcfw -> cmdq ; struct bnxt_qplib_hwq * crsb = & rcfw -> crsb ; struct bnxt_qplib_crsqe * crsqe = NULL ; struct bnxt_qplib_crsbe * * crsb_ptr ; u32 sw_prod , cmdq_prod ; u8 retry_cnt = 0xFF ; dma_addr_t dma_addr ; unsigned long flags ; u32 size , opcode ; u16 cookie , cbit ; int pg , idx ; u8 * preq ; retry opcode = req -> opcode ; if ( ! test_bit ( FIRMWARE_INITIALIZED_FLAG , & rcfw -> flags ) && ( opcode != CMDQ_BASE_OPCODE_QUERY_FUNC && opcode != CMDQ_BASE_OPCODE_INITIALIZE_FW ) ) { dev_err ( & rcfw -> pdev -> dev , "QPLIB: RCFW not initialized, reject opcode 0x%x" , opcode ) ; return NULL ; } if ( test_bit ( FIRMWARE_INITIALIZED_FLAG , & rcfw -> flags ) && opcode == CMDQ_BASE_OPCODE_INITIALIZE_FW ) { dev_err ( & rcfw -> pdev -> dev , "QPLIB: RCFW already initialized!" ) ; return NULL ; } spin_lock_irqsave ( & cmdq -> lock , flags ) ; if ( req -> cmd_size > cmdq -> max_elements - ( ( HWQ_CMP ( cmdq -> prod , cmdq ) - HWQ_CMP ( cmdq -> cons , cmdq ) ) & ( cmdq -> max_elements - 1 ) ) ) { dev_err ( & rcfw -> pdev -> dev , "QPLIB: RCFW: CMDQ is full!" ) ; spin_unlock_irqrestore ( & cmdq -> lock , flags ) ; if ( ! retry_cnt -- ) { return in ; } retry } retry_cnt = 0xFF ; cookie = atomic_inc_return ( & rcfw -> seq_num ) & RCFW_MAX_COOKIE_VALUE ; cbit = cookie % RCFW_MAX_OUTSTANDING_CMD ; if ( is_block ) { cookie |= RCFW_CMD_IS_BLOCKING ; } req -> cookie = cpu_to_le16 ( cookie ) ; if ( test_and_set_bit ( cbit , rcfw -> cmdq_bitmap ) ) { dev_err ( & rcfw -> pdev -> dev , "QPLIB: RCFW MAX outstanding cmd reached!" ) ; atomic_dec ( & rcfw -> seq_num ) ; spin_unlock_irqrestore ( & cmdq -> lock , flags ) ; if ( ! retry_cnt -- ) { return NULL ; } retry } if ( req -> resp_size && crsbe ) { spin_lock ( & crsb -> lock ) ; sw_prod = HWQ_CMP ( crsb -> prod , crsb ) ; crsb_ptr = ( bnxt_qplib_crsbe * * ) crsb -> pbl_ptr ; * crsbe = ( void * ) & crsb_ptr [ get_crsb_pg ( sw_prod ) ] [ get_crsb_idx ( sw_prod ) ] ; bnxt_qplib_crsb_dma_next ( crsb -> pbl_dma_ptr , sw_prod , & dma_addr ) ; req -> resp_addr = cpu_to_le64 ( dma_addr ) ; crsb -> prod ++ ; spin_unlock ( & crsb -> lock ) ; req -> resp_size = ( sizeof ( bnxt_qplib_crsbe ) + BNXT_QPLIB_CMDQE_UNITS - 1 ) / BNXT_QPLIB_CMDQE_UNITS ; } cmdq_ptr = ( bnxt_qplib_cmdqe * * ) cmdq -> pbl_ptr ; preq = ( u8 * ) req ; size = req -> cmd_size * BNXT_QPLIB_CMDQE_UNITS ; { pg = 0 ; idx = 0 ; sw_prod = HWQ_CMP ( cmdq -> prod , cmdq ) ; cmdqe = & cmdq_ptr [ get_cmdq_pg ( sw_prod ) ] [ get_cmdq_idx ( sw_prod ) ] ; if ( ! cmdqe ) { dev_err ( & rcfw -> pdev -> dev , "QPLIB: RCFW request failed with no cmdqe!" ) ; done } memset ( cmdqe , 0 , sizeof ( * cmdqe ) ) ; memcpy ( cmdqe , preq , min_t ( u32 , size , sizeof ( * cmdqe ) ) ) ; preq += min_t ( u32 , size , sizeof ( * cmdqe ) ) ; size -= min_t ( u32 , size , sizeof ( * cmdqe ) ) ; cmdq -> prod ++ ; } size > 0 ; cmdq_prod = cmdq -> prod ; if ( rcfw -> flags & FIRMWARE_FIRST_FLAG ) { cmdq_prod |= FIRMWARE_FIRST_FLAG ; rcfw -> flags &= ~ FIRMWARE_FIRST_FLAG ; } sw_prod = HWQ_CMP ( crsq -> prod , crsq ) ; crsqe = & crsq -> crsq [ sw_prod ] ; memset ( crsqe , 0 , sizeof ( * crsqe ) ) ; crsq -> prod ++ ; crsqe -> req_size = req -> cmd_size ; writel ( cmdq_prod , rcfw -> cmdq_bar_reg_iomem + rcfw -> cmdq_bar_reg_prod_off ) ; writel ( RCFW_CMDQ_TRIG_VAL , rcfw -> cmdq_bar_reg_iomem + rcfw -> cmdq_bar_reg_trig_off ) ; done spin_unlock_irqrestore ( & cmdq -> lock , flags ) ; return crsqe ?& crsqe -> qp_event : NULL ; } 