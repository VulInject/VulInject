static void nlm_gc ( struct nlm_globals * g ) { struct nlm_host * hostp ; clock_t now , idle_period ; idle_period = SEC_TO_TICK ( g -> cn_idle_tmo ) ; mutex_enter ( & g -> lock ) ; for ( ; ; ) { ( void ) cv_timedwait ( & g -> nlm_gc_sched_cv , & g -> lock , ddi_get_lbolt ( ) + idle_period ) ; now = ddi_get_lbolt ( ) ; DTRACE_PROBE2 ( gc__start , nlm_globals * , g , clock_t , now ) ; for ( hostp = avl_first ( & g -> nlm_hosts_tree ) ; hostp != NULL ; hostp = AVL_NEXT ( & g -> nlm_hosts_tree , hostp ) ) { struct nlm_vhold * nvp ; mutex_enter ( & hostp -> nh_lock ) ; nvp = TAILQ_FIRST ( & hostp -> nh_vholds_list ) ; while ( nvp != NULL ) { struct nlm_vhold * new_nvp ; new_nvp = TAILQ_NEXT ( nvp , nv_link ) ; if ( nvp -> nv_refcnt == 0 && nvp -> nv_vp -> v_filocks == NULL && nvp -> nv_vp -> v_shrlocks == NULL ) { nlm_vhold_destroy ( hostp , nvp ) ; } nvp = new_nvp ; } mutex_exit ( & hostp -> nh_lock ) ; } while ( ( hostp = TAILQ_FIRST ( & g -> nlm_idle_hosts ) ) != NULL ) { bool_t has_locks ; if ( hostp -> nh_idle_timeout > now ) { break ; } mutex_exit ( & g -> lock ) ; mutex_enter ( & hostp -> nh_lock ) ; nlm_host_gc_vholds ( hostp ) ; has_locks = nlm_host_has_locks ( hostp ) ; mutex_exit ( & hostp -> nh_lock ) ; mutex_enter ( & g -> lock ) ; if ( ( hostp -> nh_flags & NLM_NH_INIDLE ) == 0 || hostp -> nh_idle_timeout > now ) { continue ; } if ( has_locks ) { TAILQ_REMOVE ( & g -> nlm_idle_hosts , hostp , nh_link ) ; hostp -> nh_idle_timeout = now + idle_period ; TAILQ_INSERT_TAIL ( & g -> nlm_idle_hosts , hostp , nh_link ) ; continue ; } nlm_host_unregister ( g , hostp ) ; mutex_exit ( & g -> lock ) ; nlm_host_unmonitor ( g , hostp ) ; nlm_host_destroy ( hostp ) ; mutex_enter ( & g -> lock ) ; if ( g -> run_status == NLM_ST_STOPPING ) { break ; } } DTRACE_PROBE ( gc__end ) ; } DTRACE_PROBE1 ( gc__exit , nlm_globals * , g ) ; g -> nlm_gc_thread = NULL ; mutex_exit ( & g -> lock ) ; cv_broadcast ( & g -> nlm_gc_finish_cv ) ; zthread_exit ( ) ; } 