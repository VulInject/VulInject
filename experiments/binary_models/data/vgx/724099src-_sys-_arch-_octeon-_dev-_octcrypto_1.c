int octcrypto_process ( struct cryptop * crp ) { struct cryptodesc * crd , * crd2 ; struct octcrypto_softc * sc = octcrypto_sc ; struct octcrypto_session * ses = NULL ; int alg , alg2 ; int error = 0 ; int i ; KASSERT ( crp -> crp_ndesc >= 1 ) ; smr_read_enter ( ) ; ses = octcrypto_get ( sc , ( uint32_t ) crp -> crp_sid ) ; if ( ses == NULL ) { error = EINVAL ; out } if ( crp -> crp_ndesc == 2 ) { crd = & crp -> crp_desc [ 0 ] ; crd2 = & crp -> crp_desc [ 1 ] ; alg = alg_class ( crd -> crd_alg , NULL ) ; alg2 = alg_class ( crd2 -> crd_alg ) ; if ( ( alg == ALG_AES ) && ( alg2 == ALG_HMAC ) ) { error = octcrypto_authenc_hmac ( crp , crd , crd2 , ses ) ; out } if ( ( alg2 == ALG_AES ) && ( alg == ALG_HMAC ) ) { error = octcrypto_authenc_hmac ( crp , crd2 , crd , ses ) ; out } if ( ( alg == ALG_AES_GHASH ) && ( alg2 == ALG_GMAC ) ) { error = octcrypto_authenc_gmac ( crp , crd , crd2 , ses ) ; out } if ( ( alg2 == ALG_AES_GHASH ) && ( alg == ALG_GMAC ) ) { error = octcrypto_authenc_gmac ( crp , crd2 , crd , ses ) ; out } } for ( i = 0 ; i < crp -> crp_ndesc ; i ++ ) { crd = & crp -> crp_desc [ i ] ; switch ( crd -> crd_alg ) { case CRYPTO_AES_CBC : case CRYPTO_AES_CTR : error = octcrypto_authenc_hmac ( crp , crd , NULL , ses ) ; break ; case CRYPTO_MD5_HMAC : case CRYPTO_SHA1_HMAC : case CRYPTO_SHA2_256_HMAC : case CRYPTO_SHA2_384_HMAC : case CRYPTO_SHA2_512_HMAC : error = octcrypto_authenc_hmac ( crp , NULL , crd , ses ) ; break ; case CRYPTO_RIPEMD160_HMAC : error = octcrypto_swauth ( crp , crd , ses -> ses_swd , crp -> crp_buf ) ; break ; default : error = EINVAL ; break ; } } out smr_read_leave ( ) ; return error ; } 