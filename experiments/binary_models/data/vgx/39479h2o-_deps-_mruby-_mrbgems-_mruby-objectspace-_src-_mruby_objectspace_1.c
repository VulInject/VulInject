static mrb_value os_count_objects ( mrb_state * mrb , mrb_value self ) { struct os_count_struct obj_count = { 0 } ; mrb_int i ; mrb_value hash ; if ( mrb_get_args ( mrb , "|H" , & hash ) == 0 ) { hash = mrb_hash_new ( mrb ) ; } if ( ! mrb_hash_empty_p ( mrb , hash ) ) { mrb_hash_clear ( mrb , hash ) ; } mrb_objspace_each_objects ( mrb , os_count_object_type , & obj_count ) ; mrb_hash_set ( mrb , hash , mrb_symbol_value ( MRB_SYM ( TOTAL ) ) , mrb_fixnum_value ( obj_count . total ) ) ; mrb_hash_set ( mrb , hash , mrb_symbol_value ( MRB_SYM ( FREE ) ) , mrb_fixnum_value ( obj_count . freed ) ) ; for ( i = MRB_TT_FALSE ; i < MRB_TT_MAXDEFINE ; i ++ ) { mrb_value type ; switch ( i ) { COUNT_TYPE ( T_INTEGER ) ; COUNT_TYPE ( T_FLOAT ) ; COUNT_TYPE ( T_CPTR ) ; COUNT_TYPE ( T_OBJECT ) ; COUNT_TYPE ( T_CLASS ) ; COUNT_TYPE ( T_MODULE ) ; COUNT_TYPE ( T_ICLASS ) ; COUNT_TYPE ( T_SCLASS ) ; COUNT_TYPE ( T_PROC ) ; COUNT_TYPE ( T_ARRAY ) ; COUNT_TYPE ( T_HASH ) ; COUNT_TYPE ( T_STRING ) ; COUNT_TYPE ( T_RANGE ) ; COUNT_TYPE ( T_EXCEPTION ) ; COUNT_TYPE ( T_ENV ) ; COUNT_TYPE ( T_DATA ) ; COUNT_TYPE ( T_FIBER ) ; COUNT_TYPE ( T_ISTRUCT , NULL ) ; COUNT_TYPE ( T_COMPLEX ) ; COUNT_TYPE ( T_RATIONAL ) ; default : type = mrb_fixnum_value ( i ) ; break ; } if ( obj_count . counts [ i ] ) { mrb_hash_set ( mrb , hash , type , mrb_fixnum_value ( obj_count . counts [ i ] ) ) ; } } return hash ; } os_each_object_data { struct RClass * target_module ; mrb_int count ; mrb_value block ; } 