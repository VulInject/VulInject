static void nsec3_add_nonexist_proof ( struct query * query , struct answer * answer , struct domain * encloser , const dname_type * qname ) { uint8_t hash [ NSEC3_HASH_LEN ] ; const dname_type * to_prove ; domain_type * cover = 0 ; to_prove = dname_partial_copy ( query -> region , qname , dname_label_match_count ( qname , domain_dname ( encloser ) ) + 1 ) ; nsec3_hash_and_store ( query -> zone , to_prove , hash ) ; if ( nsec3_find_cover ( query -> zone , hash , sizeof ( hash ) , & cover ) ) { domain_type * walk ; char hashbuf [ 512 ] ; char reversebuf [ 512 ] ; ( void ) b32_ntop ( hash , sizeof ( hash ) , hashbuf , sizeof ( hashbuf ) ) ; snprintf ( reversebuf , sizeof ( reversebuf ) , "(no name in the zone hashes to this nsec3 record)" ) ; walk = query -> zone -> apex ; while ( walk ) { if ( walk -> nsec3 && walk -> nsec3 -> nsec3_cover == cover ) { snprintf ( reversebuf , sizeof ( reversebuf ) , "%s %s" , domain_to_string ( walk ) , walk -> nsec3 -> nsec3_is_exact ?"exact" : "no_exact_hash_match" ) ; if ( walk -> nsec3 -> nsec3_is_exact ) { break ; } } if ( walk -> nsec3 && walk -> nsec3 -> nsec3_ds_parent_cover == cover ) { snprintf ( reversebuf , sizeof ( reversebuf ) , "%s %s" , domain_to_string ( walk ) , walk -> nsec3 -> nsec3_ds_parent_is_exact ?"exact" : "no_exact_hash_match" ) ; if ( walk -> nsec3 -> nsec3_ds_parent_is_exact ) { break ; } } walk = domain_next ( walk ) ; } VERBOSITY ( 3 , ( LOG_ERR , "nsec3 hash collision for name=%s hash=%s reverse=%s" , dname_to_string ( to_prove , NULL ) , hashbuf , reversebuf ) ) ; RCODE_SET ( query -> packet , RCODE_SERVFAIL ) ; ASSIGN_EDE_CODE_AND_STRING_LITERAL ( query -> edns . ede , EDE_OTHER , "NSEC3 hash collision" ) ; return ; } else { nsec3_add_rrset ( query , answer , AUTHORITY_SECTION , cover ) ; } } 