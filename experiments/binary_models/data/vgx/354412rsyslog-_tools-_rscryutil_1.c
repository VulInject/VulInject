int main ( int argc , char * argv [ ] ) { int i ; int opt ; int temp ; char * newKeyFile = NULL ; while ( 1 ) { opt = getopt_long ( argc , argv , "a:dfk:K:m:p:r:vVW:" , long_options , NULL ) ; if ( opt == - 1 ) { break ; } switch ( opt ) { case 'd' : mode = MD_DECRYPT ; break ; case 'W' : mode = MD_WRITE_KEYFILE ; newKeyFile = optarg ; break ; case 'k' : keyfile = optarg ; break ; case 'p' : keyprog = optarg ; break ; case 'f' : optionForce = 1 ; break ; case 'r' : randomKeyLen = atoi ( optarg ) ; if ( randomKeyLen > 64 * 1024 ) { fprintf ( stderr , "ERROR: keys larger than 64KiB are " "not supported\n" ) ; exit ( 1 ) ; } break ; case 'K' : fprintf ( stderr , "WARNING: specifying the actual key " "via the command line is highly insecure\n" "Do NOT use this for PRODUCTION use.\n" ) ; cry_key = optarg ; cry_keylen = strlen ( cry_key ) ; break ; case 'a' : temp = rsgcryAlgoname2Algo ( optarg ) ; if ( temp == GCRY_CIPHER_NONE ) { fprintf ( stderr , "ERROR: algorithm \"%s\" is not " "kown/supported\n" , optarg ) ; exit ( 1 ) ; } cry_algo = temp ; break ; case 'm' : temp = rsgcryModename2Mode ( optarg ) ; if ( temp == GCRY_CIPHER_MODE_NONE ) { fprintf ( stderr , "ERROR: cipher mode \"%s\" is not " "kown/supported\n" , optarg ) ; exit ( 1 ) ; } cry_mode = temp ; break ; case 'v' : verbose = 1 ; break ; case 'V' : fprintf ( stderr , "rsgtutil " VERSION "\n" ) ; exit ( 0 ) ; break ; case '?' : break ; default : fprintf ( stderr , "getopt_long() returns unknown value %d\n" , opt ) ; return 1 ; } } setKey ( ) ; assert ( cry_key != NULL ) ; if ( mode == MD_WRITE_KEYFILE ) { if ( optind != argc ) { fprintf ( stderr , "ERROR: no file parameters permitted in " "--write-keyfile mode\n" ) ; exit ( 1 ) ; } write_keyfile ( newKeyFile ) ; } else { if ( optind == argc ) { decrypt ( "-" ) ; } else { for ( i = optind ; i < argc ; ++ i ) { decrypt ( argv [ i ] ) ; } } } assert ( cry_key != NULL ) ; cry_keylen = 0 ; return 0 ; } 