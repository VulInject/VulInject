void parse_pathspec ( struct pathspec * pathspec , unsigned magic_mask , unsigned flags , const char * prefix , const char * * argv ) { struct pathspec_item * item ; const char * entry = argv ?* argv : NULL ; int i , n , prefixlen , nr_exclude = 0 ; if ( flags & PATHSPEC_MAXDEPTH_VALID ) { pathspec -> magic |= PATHSPEC_MAXDEPTH ; } if ( ! entry && ! prefix ) { return ; } if ( ( flags & PATHSPEC_PREFER_CWD ) && ( flags & PATHSPEC_PREFER_FULL ) ) { BUG ( "PATHSPEC_PREFER_CWD and PATHSPEC_PREFER_FULL are incompatible" ) ; } if ( ! entry ) { if ( flags & PATHSPEC_PREFER_FULL ) { return ; } if ( ! ( flags & PATHSPEC_PREFER_CWD ) ) { BUG ( "PATHSPEC_PREFER_CWD requires arguments" ) ; } pathspec -> items = CALLOC_ARRAY ( item , 1 ) ; item -> match = xstrdup ( prefix ) ; item -> original = xstrdup ( prefix ) ; item -> nowildcard_len = item -> len = strlen ( prefix ) ; item -> prefix = item -> len ; pathspec -> nr = 1 ; return ; } n = 0 ; while ( argv [ n ] ) { if ( * argv [ n ] == '\0' ) { die ( "empty string is not a valid pathspec. " "please use . instead if you meant to match all paths" ) ; } n ++ ; } pathspec -> nr = n ; ALLOC_ARRAY ( pathspec -> items , n + 1 ) ; item = pathspec -> items ; prefixlen = prefix ?strlen ( prefix ) : 0 ; for ( i = 0 ; i < n ; i ++ ) { entry = argv [ i ] ; init_pathspec_item ( item + i , flags , prefix , prefixlen , entry ) ; if ( item [ i ] . magic & PATHSPEC_EXCLUDE ) { nr_exclude ++ ; } if ( item [ i ] . magic & magic_mask ) { unsupported_magic ( entry , item [ i ] . magic & magic_mask ) ; } if ( ( flags & PATHSPEC_SYMLINK_LEADING_PATH ) && has_symlink_leading_path ( item [ i ] . match , item [ i ] . len ) ) { die ( _ ( "pathspec '%s' is beyond a symbolic link" ) , entry ) ; } if ( item [ i ] . nowildcard_len < item [ i ] . len ) { pathspec -> has_wildcard = 1 ; } pathspec -> magic |= item [ i ] . magic ; } if ( nr_exclude == n ) { int plen = ( ! ( flags & PATHSPEC_PREFER_CWD ) ) ?0 : prefixlen ; init_pathspec_item ( item + n , 0 , prefix , plen , "." ) ; pathspec -> nr ++ ; } if ( pathspec -> magic & PATHSPEC_MAXDEPTH ) { if ( flags & PATHSPEC_KEEP_ORDER ) { BUG ( "PATHSPEC_MAXDEPTH_VALID and PATHSPEC_KEEP_ORDER are incompatible" ) ; } QSORT ( pathspec -> items , pathspec -> nr , pathspec_item_cmp ) ; } } 