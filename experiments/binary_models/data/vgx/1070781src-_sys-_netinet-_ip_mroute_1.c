int ip_mdq ( struct mbuf * m , struct ifnet * ifp0 , struct rtentry * rt ) { struct ip * ip = mtod ( m , ip * ) ; struct mfc * mfc = ( mfc * ) rt -> rt_llinfo ; struct vif * v = ( vif * ) ifp0 -> if_mcast ; struct ifnet * ifp ; struct mbuf * mc ; struct ip_moptions imo ; if ( v == NULL || mfc == NULL ) { rtfree ( rt ) ; return ( EHOSTUNREACH ) ; } if ( mfc -> mfc_parent != v -> v_id ) { ++ mrtstat . mrts_wrong_if ; mfc -> mfc_wrong_if ++ ; rtfree ( rt ) ; return ( 0 ) ; } if ( in_hosteq ( ip -> ip_src , v -> v_lcl_addr ) ) { v -> v_pkt_out ++ ; v -> v_bytes_out += m -> m_pkthdr . len ; } else { v -> v_pkt_in ++ ; v -> v_bytes_in += m -> m_pkthdr . len ; } { if ( ISSET ( rt -> rt_flags , RTF_HOST | RTF_MULTICAST ) != ( RTF_HOST | RTF_MULTICAST ) ) { continue ; } mfc = ( mfc * ) rt -> rt_llinfo ; if ( mfc == NULL ) { continue ; } mfc -> mfc_pkt_cnt ++ ; mfc -> mfc_byte_cnt += m -> m_pkthdr . len ; mfc -> mfc_expire = 0 ; if ( ip -> ip_ttl <= mfc -> mfc_ttl ) { continue ; } if ( ( ifp = if_get ( rt -> rt_ifidx ) ) == NULL ) { continue ; } if ( ( v = ( vif * ) ifp -> if_mcast ) == NULL ) { if_put ( ifp , NULL ) ; continue ; } if ( mfc -> mfc_parent == v -> v_id ) { if_put ( ifp ) ; continue ; } v -> v_pkt_out ++ ; v -> v_bytes_out += m -> m_pkthdr . len ; mc = m_dup_pkt ( m , max_linkhdr , M_NOWAIT ) ; if ( mc == NULL ) { if_put ( ifp ) ; rtfree ( rt ) ; return ( ENOBUFS ) ; } imo . imo_ifidx = rt -> rt_ifidx ; imo . imo_ttl = ip -> ip_ttl - IPTTLDEC ; imo . imo_loop = 1 ; ip_output ( mc , NULL , NULL , IP_FORWARDING , & imo , NULL , 0 ) ; if_put ( ifp ) ; } ( rt = rtable_iterate ( rt ) ) != NULL ; return ( 0 ) ; } 