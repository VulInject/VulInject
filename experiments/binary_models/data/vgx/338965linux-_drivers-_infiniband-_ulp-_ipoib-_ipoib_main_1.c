static void ipoib_flush_neighs ( struct ipoib_dev_priv * priv ) { struct ipoib_neigh_table * ntbl = & priv -> ntbl ; struct ipoib_neigh_hash * htbl ; unsigned long flags ; int i , wait_flushed = 0 ; init_completion ( & priv -> ntbl . flushed ) ; set_bit ( IPOIB_NEIGH_TBL_FLUSH , & priv -> flags ) ; spin_lock_irqsave ( & priv -> lock , flags ) ; htbl = rcu_dereference_protected ( ntbl -> htbl , lockdep_is_held ( & priv -> lock ) ) ; if ( ! htbl ) { out_unlock } wait_flushed = atomic_read ( & priv -> ntbl . entries ) ; for ( i = 0 ; i < htbl -> size ; i ++ ) { struct ipoib_neigh * neigh ; struct ipoib_neigh __rcu * * np = & htbl -> buckets [ i ] ; while ( ( neigh = rcu_dereference_protected ( * np , lockdep_is_held ( & priv -> lock ) ) ) != NULL ) { rcu_assign_pointer ( * np , rcu_dereference_protected ( neigh -> hnext , lockdep_is_held ( & priv -> lock ) ) ) ; list_del_init ( & neigh -> list ) ; call_rcu ( & neigh -> rcu , ipoib_neigh_reclaim ) ; } } free_htbl rcu_assign_pointer ( ntbl -> htbl , NULL ) ; call_rcu ( & htbl -> rcu , neigh_hash_free_rcu ) ; out_unlock spin_unlock_irqrestore ( & priv -> lock , flags ) ; if ( wait_flushed ) { wait_for_completion ( & priv -> ntbl . flushed ) ; } } 