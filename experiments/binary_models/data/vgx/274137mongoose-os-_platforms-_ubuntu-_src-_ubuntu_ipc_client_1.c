int ubuntu_ipc_open ( const char * pathname , int flags ) { ssize_t len ; struct msghdr msg ; struct iovec iov [ 1 ] ; struct ubuntu_pipe_message iovec_payload ; static { struct cmsghdr cm ; char control [ CMSG_SPACE ( sizeof ( int ) ) ] ; } , control_un struct cmsghdr * cmptr ; int fd = - 1 ; if ( ! pathname ) { exit } if ( strlen ( pathname ) > 250 ) { exit } memset ( & iovec_payload , 0 , sizeof ( ubuntu_pipe_message ) ) ; iovec_payload . cmd = UBUNTU_CMD_OPEN ; iovec_payload . len = strlen ( pathname ) + 1 + sizeof ( int ) ; memcpy ( & iovec_payload . data , pathname , strlen ( pathname ) ) ; memcpy ( & iovec_payload . data [ strlen ( pathname ) + 1 ] , & flags , sizeof ( int ) ) ; iov [ 0 ] . iov_base = ( void * ) & iovec_payload ; iov [ 0 ] . iov_len = iovec_payload . len + 2 ; msg . msg_iov = iov ; msg . msg_iovlen = 1 ; mgos_rlock ( s_pipe . lock ) ; len = sendmsg ( s_pipe . mongoose_fd , & msg , 0 ) ; if ( len < 2 ) { LOG ( LL_ERROR , ( "Cannot write message %d" , ( int ) len ) ) ; exit } memset ( & iovec_payload , 0 , sizeof ( ubuntu_pipe_message ) ) ; iov [ 0 ] . iov_base = ( void * ) & iovec_payload ; iov [ 0 ] . iov_len = sizeof ( ubuntu_pipe_message ) ; msg . msg_iov = iov ; msg . msg_iovlen = 1 ; msg . msg_control = control_un . control ; msg . msg_controllen = sizeof ( control_un . control ) ; len = recvmsg ( s_pipe . mongoose_fd , & msg , 0 ) ; if ( len < 2 ) { LOG ( LL_ERROR , ( "Cannot read message" ) ) ; exit } if ( ( cmptr = CMSG_FIRSTHDR ( & msg ) ) != NULL && cmptr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) && cmptr -> cmsg_level == SOL_SOCKET && cmptr -> cmsg_type == SCM_RIGHTS ) { fd = * ( ( int * ) CMSG_DATA ( cmptr ) ) ; } exit mgos_runlock ( s_pipe . lock ) ; return fd ; ( void ) flags ; } 