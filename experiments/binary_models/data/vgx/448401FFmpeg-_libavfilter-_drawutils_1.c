int ff_fill_rgba_map ( uint8_t * rgba_map , enum AVPixelFormat pix_fmt ) { const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pix_fmt ) ; if ( ! ( desc -> flags & AV_PIX_FMT_FLAG_RGB ) ) { return AVERROR ( EINVAL ) ; } if ( desc -> flags & AV_PIX_FMT_FLAG_BITSTREAM ) { return AVERROR ( EINVAL ) ; } av_assert0 ( desc -> nb_components == 3 + ! ! ( desc -> flags & AV_PIX_FMT_FLAG_ALPHA ) ) ; if ( desc -> flags & AV_PIX_FMT_FLAG_PLANAR ) { rgba_map [ RED ] = desc -> comp [ 0 ] . plane ; rgba_map [ GREEN ] = desc -> comp [ 1 ] . plane ; rgba_map [ BLUE ] = desc -> comp [ 2 ] . plane ; rgba_map [ ALPHA ] = ( desc -> flags & AV_PIX_FMT_FLAG_ALPHA ) ?desc -> comp [ 3 ] . plane : 3 ; } else { int had0 = 0 ; int depthb = 0 ; unsigned i ; for ( i = 0 ; i < desc -> nb_components ; i ++ ) { unsigned db = ( desc -> comp [ i ] . depth + 7 ) / 8 ; unsigned pos = desc -> comp [ i ] . offset / db ; if ( depthb && ( depthb != db ) ) { return AVERROR ( ENOSYS ) ; } if ( desc -> comp [ i ] . offset % db ) { return AVERROR ( ENOSYS ) ; } had0 |= pos == 0 ; rgba_map [ i ] = pos ; } if ( desc -> nb_components == 3 ) { rgba_map [ ALPHA ] = had0 ?3 : 0 ; } } av_assert0 ( rgba_map [ RED ] != rgba_map [ GREEN ] ) ; av_assert0 ( rgba_map [ GREEN ] != rgba_map [ BLUE ] ) ; av_assert0 ( rgba_map [ BLUE ] != rgba_map [ RED ] ) ; av_assert0 ( rgba_map [ RED ] != rgba_map [ ALPHA ] ) ; av_assert0 ( rgba_map [ GREEN ] != rgba_map [ ALPHA ] ) ; av_assert0 ( rgba_map [ BLUE ] != rgba_map [ ALPHA ] ) ; return 0 ; } 