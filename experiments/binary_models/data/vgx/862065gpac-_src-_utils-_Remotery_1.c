static rmtError Remotery_Constructor ( Remotery * rmt ) { rmtError error ; assert ( rmt != NULL ) ; rmt -> server = NULL ; rmt -> thread_sampler_tls_handle = TLS_INVALID_HANDLE ; rmt -> first_thread_sampler = NULL ; rmt -> mq_to_rmt_thread = NULL ; rmt -> thread = NULL ; rmt -> map_message_queue_fn = NULL ; rmt -> map_message_queue_data = NULL ; rmt -> sampling_disabled = 0 ; rmt -> cuda . CtxSetCurrent = NULL ; rmt -> cuda . EventCreate = NULL ; rmt -> cuda . EventDestroy = NULL ; rmt -> cuda . EventElapsedTime = NULL ; rmt -> cuda . EventQuery = NULL ; rmt -> cuda . EventRecord = NULL ; rmt -> metal = NULL ; usTimer_Init ( & rmt -> timer ) ; error = tlsAlloc ( & rmt -> thread_sampler_tls_handle ) ; if ( error != RMT_ERROR_NONE ) { return error ; } New_3 ( Server , rmt -> server , g_Settings . port , g_Settings . reuse_open_port , g_Settings . limit_connections_to_localhost ) ; if ( error != RMT_ERROR_NONE ) { return error ; } rmt -> server -> receive_handler = Remotery_ReceiveMessage ; rmt -> server -> receive_handler_context = rmt ; New_1 ( rmtMessageQueue , rmt -> mq_to_rmt_thread , g_Settings . messageQueueSizeInBytes ) ; if ( error != RMT_ERROR_NONE ) { return error ; } error = OpenGL_Create ( & rmt -> opengl ) ; if ( error != RMT_ERROR_NONE ) { return error ; } error = Metal_Create ( & rmt -> metal ) ; if ( error != RMT_ERROR_NONE ) { return error ; } assert ( g_Remotery == NULL ) ; g_Remotery = rmt ; g_RemoteryCreated = RMT_TRUE ; CompilerWriteFence ( ) ; New_2 ( rmtThread , rmt -> thread , Remotery_ThreadMain , rmt ) ; return error ; } 