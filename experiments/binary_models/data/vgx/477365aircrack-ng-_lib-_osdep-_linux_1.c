static int do_linux_open ( struct wif * wi , char * iface ) { int kver ; struct utsname checklinuxversion ; struct priv_linux * dev = wi_priv ( wi ) ; char strbuf [ 512 ] ; FILE * f ; char athXraw [ ] "athXraw" ; ; pid_t pid ; int n ; DIR * net_ifaces ; struct dirent * this_iface ; FILE * acpi = NULL ; char buf [ 128 ] ; char * r_file = NULL ; struct ifreq ifr ; int iface_malloced = 0 ; size_t iface_len = 0 ; if ( iface == NULL || strlen ( iface ) >= IFNAMSIZ ) { return ( 1 ) ; } dev -> inject_wlanng = 1 ; dev -> rate = 2 ; if ( ( dev -> fd_in = socket ( PF_PACKET , SOCK_RAW , htons ( ETH_P_ALL ) ) ) < 0 ) { perror ( "socket(PF_PACKET) failed" ) ; if ( getuid ( ) != 0 ) { fprintf ( stderr , "This program requires root privileges.\n" ) ; } return ( 1 ) ; } if ( ( dev -> fd_main = socket ( PF_PACKET , SOCK_RAW , htons ( ETH_P_ALL ) ) ) < 0 ) { perror ( "socket(PF_PACKET) failed" ) ; if ( getuid ( ) != 0 ) { fprintf ( stderr , "This program requires root privileges.\n" ) ; } return ( 1 ) ; } dev -> iwpriv = wiToolsPath ( "iwpriv" ) ; dev -> iwconfig = wiToolsPath ( "iwconfig" ) ; dev -> ifconfig = wiToolsPath ( "ifconfig" ) ; if ( ! ( dev -> iwpriv ) ) { fprintf ( stderr , "Required wireless tools when compiled without libnl " "could not be found, exiting.\n" ) ; close_in } if ( is_ndiswrapper ( iface , dev -> iwpriv ) ) { fprintf ( stderr , "Ndiswrapper doesn't support monitor mode.\n" ) ; close_in } if ( ( dev -> fd_out = socket ( PF_PACKET , SOCK_RAW , htons ( ETH_P_ALL ) ) ) < 0 ) { perror ( "socket(PF_PACKET) failed" ) ; close_in } snprintf ( strbuf , sizeof ( strbuf ) - 1 , "ls /sys/class/net/%s/phy80211/subsystem>/dev/null 2>/dev/null" , iface ) ; if ( system ( strbuf ) == 0 ) { dev -> drivertype = DT_MAC80211_RT ; } memset ( strbuf , 0 , sizeof ( strbuf ) ) ; snprintf ( strbuf , sizeof ( strbuf ) - 1 , "ls /sys/class/net/%s/device/inject>/dev/null 2>/dev/null" , iface ) ; if ( system ( strbuf ) == 0 ) { dev -> drivertype = DT_IPW2200 ; } memset ( strbuf , 0 , sizeof ( strbuf ) ) ; snprintf ( strbuf , sizeof ( strbuf ) - 1 , "ls /sys/class/net/%s/device/inject_nofcs>/dev/null 2>/dev/null" , iface ) ; if ( system ( strbuf ) == 0 ) { dev -> drivertype = DT_BCM43XX ; } if ( strlen ( iface ) == 5 && memcmp ( iface , "wlan" , 4 ) == 0 ) { memset ( strbuf , 0 , sizeof ( strbuf ) ) ; snprintf ( strbuf , sizeof ( strbuf ) - 1 , "wlancfg show %s 2>/dev/null | " "grep p2CnfWEPFlags>/dev/null" , iface ) ; if ( system ( strbuf ) == 0 ) { if ( uname ( & checklinuxversion ) >= 0 ) { if ( strncmp ( checklinuxversion . release , "2.6." , 4 ) == 0 && strncasecmp ( checklinuxversion . sysname , "linux" , 5 ) == 0 ) { kver = atoi ( checklinuxversion . release + 4 ) ; if ( kver > 11 ) { dev -> inject_wlanng = 0 ; } } } dev -> drivertype = DT_WLANNG ; dev -> wlanctlng = wiToolsPath ( "wlanctl-ng" ) ; } memset ( strbuf , 0 , sizeof ( strbuf ) ) ; snprintf ( strbuf , sizeof ( strbuf ) - 1 , "iwpriv %s 2>/dev/null | " "grep antsel_rx>/dev/null" , iface ) ; if ( system ( strbuf ) == 0 ) { dev -> drivertype = DT_HOSTAP ; } memset ( strbuf , 0 , sizeof ( strbuf ) ) ; snprintf ( strbuf , sizeof ( strbuf ) - 1 , "iwpriv %s 2>/dev/null | " "grep  GetAcx111Info>/dev/null" , iface ) ; if ( system ( strbuf ) == 0 ) { dev -> drivertype = DT_ACX ; } } if ( strcmp ( iface , "ra0" ) == 0 || strcmp ( iface , "ra1" ) == 0 || strcmp ( iface , "rausb0" ) == 0 || strcmp ( iface , "rausb1" ) == 0 ) { memset ( strbuf , 0 , sizeof ( strbuf ) ) ; snprintf ( strbuf , sizeof ( strbuf ) - 1 , "iwpriv %s rfmontx 1>/dev/null 2>/dev/null" , iface ) ; IGNORE_NZ ( system ( strbuf ) ) ; } if ( ( strlen ( iface ) >= 4 && strlen ( iface ) <= 6 ) && memcmp ( iface , "ath" , 3 ) == 0 ) { dev -> drivertype = DT_MADWIFI ; memset ( strbuf , 0 , sizeof ( strbuf ) ) ; snprintf ( strbuf , sizeof ( strbuf ) - 1 , "/proc/sys/net/%s/%%parent" , iface ) ; f = fopen ( strbuf , "r" ) ; if ( f != NULL ) { dev -> drivertype = DT_MADWIFING ; fclose ( f ) ; sprintf ( ( char * ) strbuf , "/proc/sys/net/%s/dev_type" , iface ) ; f = fopen ( ( char * ) strbuf , "w" ) ; if ( f != NULL ) { fprintf ( f , "802\n" ) ; fclose ( f ) ; } } else { memset ( strbuf , 0 , sizeof ( strbuf ) ) ; snprintf ( strbuf , sizeof ( strbuf ) - 1 , "sysctl -w dev.%s.rawdev=1>/dev/null 2>/dev/null" , iface ) ; if ( system ( strbuf ) == 0 ) { athXraw [ 3 ] = iface [ 3 ] ; memset ( strbuf , 0 , sizeof ( strbuf ) ) ; snprintf ( strbuf , sizeof ( strbuf ) - 1 , "ifconfig %s up" , athXraw ) ; IGNORE_NZ ( system ( strbuf ) ) ; memset ( strbuf , 0 , sizeof ( strbuf ) ) ; snprintf ( strbuf , sizeof ( strbuf ) - 1 , "sysctl -w dev.%s.rawdev_type=1>/dev/null 2>/dev/null" , iface ) ; IGNORE_NZ ( system ( strbuf ) ) ; iface = athXraw ; } } } if ( memcmp ( iface , "eth" , 3 ) == 0 ) { if ( ( pid = fork ( ) ) == 0 ) { close ( 0 ) ; close ( 1 ) ; close ( 2 ) ; IGNORE_NZ ( chdir ( "/" ) ) ; execlp ( "iwpriv" , "iwpriv" , iface , "get_port3" , NULL ) ; exit ( 1 ) ; } waitpid ( pid , & n , 0 ) ; if ( WIFEXITED ( n ) && WEXITSTATUS ( n ) == 0 ) { dev -> drivertype = DT_ORINOCO ; } memset ( strbuf , 0 , sizeof ( strbuf ) ) ; snprintf ( strbuf , sizeof ( strbuf ) - 1 , "iwpriv %s 2>/dev/null | " "grep get_scan_times>/dev/null" , iface ) ; if ( system ( strbuf ) == 0 ) { dev -> drivertype = DT_AT76USB ; } if ( ( pid = fork ( ) ) == 0 ) { close ( 0 ) ; close ( 1 ) ; close ( 2 ) ; IGNORE_NZ ( chdir ( "/" ) ) ; execlp ( "iwpriv" , "iwpriv" , iface , "get_regdomain" , NULL ) ; exit ( 1 ) ; } waitpid ( pid , & n , 0 ) ; if ( WIFEXITED ( n ) && WEXITSTATUS ( n ) == 0 ) { dev -> drivertype = DT_ZD1211RW ; } } if ( dev -> drivertype == DT_IPW2200 ) { r_file = ( char * ) calloc ( 33 + strlen ( iface ) + 1 , sizeof ( char ) ) ; if ( ! r_file ) { close_out } snprintf ( r_file , 33 + strlen ( iface ) + 1 , "/sys/class/net/%s/device/rtap_iface" , iface ) ; if ( ( acpi = fopen ( r_file , "r" ) ) == NULL ) { close_out } memset ( buf , 0 , 128 ) ; IGNORE_ZERO ( fgets ( buf , 128 , acpi ) ) ; buf [ 127 ] = '\x00' ; if ( strncmp ( buf , "-1" , 2 ) == 0 ) { fclose ( acpi ) ; if ( ( acpi = fopen ( r_file , "w" ) ) == NULL ) { close_out } fputs ( "1" , acpi ) ; fclose ( acpi ) ; if ( ( acpi = fopen ( r_file , "r" ) ) == NULL ) { close_out } IGNORE_ZERO ( fgets ( buf , 128 , acpi ) ) ; } fclose ( acpi ) ; acpi = NULL ; iface_len = strlen ( iface ) + 1 ; dev -> main_if = ( char * ) malloc ( iface_len ) ; if ( dev -> main_if == NULL ) { close_out } memset ( dev -> main_if , 0 , iface_len ) ; memcpy ( dev -> main_if , iface , iface_len ) ; iface_len = strlen ( buf ) + 1 ; iface = ( char * ) malloc ( iface_len ) ; if ( iface == NULL ) { close_out } iface_malloced = 1 ; memset ( iface , 0 , iface_len ) ; memcpy ( iface , buf , iface_len ) ; } if ( memcmp ( iface , "rtap" , 4 ) == 0 && dev -> main_if == NULL ) { memset ( & ifr , 0 , sizeof ( ifr ) ) ; strncpy ( ifr . ifr_name , iface , sizeof ( ifr . ifr_name ) - 1 ) ; n = 0 ; if ( ioctl ( dev -> fd_out , SIOCGIFINDEX , & ifr ) < 0 ) { n = 1 ; } net_ifaces = opendir ( "/sys/class/net" ) ; while ( net_ifaces != NULL && ( this_iface = readdir ( net_ifaces ) ) != NULL ) { if ( this_iface -> d_name [ 0 ] == '.' ) { continue ; } char * new_r_file = ( char * ) realloc ( r_file , ( 33 + strlen ( this_iface -> d_name ) + 1 ) * sizeof ( char ) ) ; if ( ! new_r_file ) { continue ; } r_file = new_r_file ; snprintf ( r_file , 33 + strlen ( this_iface -> d_name ) + 1 , "/sys/class/net/%s/device/rtap_iface" , this_iface -> d_name ) ; if ( ( acpi = fopen ( r_file , "r" ) ) == NULL ) { continue ; } dev -> drivertype = DT_IPW2200 ; memset ( buf , 0 , 128 ) ; IGNORE_ZERO ( fgets ( buf , 128 , acpi ) ) ; if ( n == 0 ) { if ( strncmp ( buf , iface , 5 ) == 0 ) { fclose ( acpi ) ; acpi = NULL ; closedir ( net_ifaces ) ; net_ifaces = NULL ; dev -> main_if = ( char * ) malloc ( strlen ( this_iface -> d_name ) + 1 ) ; if ( dev -> main_if == NULL ) { continue ; } strcpy ( dev -> main_if , this_iface -> d_name ) ; break ; } } else { if ( strncmp ( buf , "-1" , 2 ) == 0 ) { fclose ( acpi ) ; if ( ( acpi = fopen ( r_file , "w" ) ) == NULL ) { continue ; } fputs ( "1" , acpi ) ; fclose ( acpi ) ; if ( ( acpi = fopen ( r_file , "r" ) ) == NULL ) { continue ; } IGNORE_ZERO ( fgets ( buf , 128 , acpi ) ) ; if ( strncmp ( buf , iface , 5 ) == 0 ) { closedir ( net_ifaces ) ; net_ifaces = NULL ; dev -> main_if = ( char * ) malloc ( strlen ( this_iface -> d_name ) + 1 ) ; if ( dev -> main_if == NULL ) { continue ; } strcpy ( dev -> main_if , this_iface -> d_name ) ; fclose ( acpi ) ; acpi = NULL ; break ; } } } fclose ( acpi ) ; acpi = NULL ; } if ( net_ifaces != NULL ) { closedir ( net_ifaces ) ; } } if ( openraw ( dev , iface , dev -> fd_out , & dev -> arptype_out , dev -> pl_mac ) != 0 ) { close_out } if ( ! ( dev -> drivertype == DT_BCM43XX ) && ! ( dev -> drivertype == DT_IPW2200 ) ) { close ( dev -> fd_in ) ; dev -> fd_in = dev -> fd_out ; } else { n = dev -> fd_out ; dev -> fd_out = dev -> fd_in ; dev -> fd_in = n ; } dev -> arptype_in = dev -> arptype_out ; if ( iface_malloced ) { free ( iface ) ; } if ( r_file ) { free ( r_file ) ; } return 0 ; close_out close ( dev -> fd_out ) ; if ( r_file ) { free ( r_file ) ; } close_in close ( dev -> fd_in ) ; if ( acpi ) { fclose ( acpi ) ; } if ( iface_malloced ) { free ( iface ) ; } return 1 ; } 