static int mlxsw_sp_fid_reiv_handle ( struct mlxsw_sp_fid * fid , u16 rif_index , bool valid , u8 port_page ) { u16 local_port_end = ( port_page + 1 ) * MLXSW_REG_REIV_REC_MAX_COUNT - 1 ; u16 local_port_start = port_page * MLXSW_REG_REIV_REC_MAX_COUNT ; struct mlxsw_sp * mlxsw_sp = fid -> fid_family -> mlxsw_sp ; struct mlxsw_sp_fid_port_vid * port_vid ; u8 rec_num , entries_num = 0 ; char * reiv_pl ; int err ; reiv_pl = kmalloc ( MLXSW_REG_REIV_LEN , GFP_KERNEL ) ; if ( ! reiv_pl ) { return - ENOMEM ; } mlxsw_reg_reiv_pack ( reiv_pl , port_page , rif_index ) ; list_for_each_entry ( , , ) { if ( port_vid -> local_port > local_port_end ) { break ; } rec_num = port_vid -> local_port % MLXSW_REG_REIV_REC_MAX_COUNT ; mlxsw_reg_reiv_rec_update_set ( reiv_pl , rec_num , true ) ; mlxsw_reg_reiv_rec_evid_set ( reiv_pl , rec_num , valid ?port_vid -> vid : 0 ) ; entries_num ++ ; } if ( ! entries_num ) { kfree ( reiv_pl ) ; return 0 ; } err = mlxsw_reg_write ( mlxsw_sp -> core , MLXSW_REG ( reiv ) , reiv_pl ) ; if ( err ) { err_reg_write } kfree ( reiv_pl ) ; return 0 ; err_reg_write kfree ( reiv_pl ) ; return err ; } 