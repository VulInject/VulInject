static int blk_revalidate_zone_cb ( struct blk_zone * zone , unsigned int idx , void * data ) { struct blk_revalidate_zone_args * args = data ; struct gendisk * disk = args -> disk ; struct request_queue * q = disk -> queue ; sector_t capacity = get_capacity ( disk ) ; if ( zone -> start == 0 ) { if ( zone -> len == 0 || ! is_power_of_2 ( zone -> len ) ) { pr_warn ( "%s: Invalid zoned device with non power of two zone size (%llu)\n" , disk -> disk_name , zone -> len ) ; return - ENODEV ; } args -> zone_sectors = zone -> len ; args -> nr_zones = ( capacity + zone -> len - 1 ) >> ilog2 ( zone -> len ) ; } if ( zone -> start + args -> zone_sectors < capacity ) { if ( zone -> len != args -> zone_sectors ) { pr_warn ( "%s: Invalid zoned device with non constant zone size\n" , disk -> disk_name ) ; return - ENODEV ; } } else { if ( zone -> len > args -> zone_sectors ) { pr_warn ( "%s: Invalid zoned device with larger last zone size\n" , disk -> disk_name ) ; return - ENODEV ; } } if ( zone -> start != args -> sector ) { pr_warn ( "%s: Zone gap at sectors %llu..%llu\n" , disk -> disk_name , args -> sector , zone -> start ) ; return - ENODEV ; } switch ( zone -> type ) { case BLK_ZONE_TYPE_CONVENTIONAL : if ( ! args -> conv_zones_bitmap ) { args -> conv_zones_bitmap = blk_alloc_zone_bitmap ( q -> node , args -> nr_zones ) ; } set_bit ( idx , args -> conv_zones_bitmap ) ; break ; case BLK_ZONE_TYPE_SEQWRITE_REQ : case BLK_ZONE_TYPE_SEQWRITE_PREF : if ( ! args -> seq_zones_wlock ) { args -> seq_zones_wlock = blk_alloc_zone_bitmap ( q -> node , args -> nr_zones ) ; if ( ! args -> seq_zones_wlock ) { return - ENOMEM ; } } break ; default : pr_warn ( "%s: Invalid zone type 0x%x at sectors %llu\n" , disk -> disk_name , ( int ) zone -> type , zone -> start ) ; return - ENODEV ; } args -> sector += zone -> len ; return 0 ; } 