static int pr_read_lpsinfo ( prnode_t * pnp , uio_t * uiop , cred_t * cr ) { proc_t * p ; kthread_t * t ; lwpdir_t * ldp ; lwpent_t * lep ; size_t size ; prheader_t * php ; lwpsinfo_t * sp ; int error ; int nlwp ; int i ; ASSERT ( pnp -> pr_type == PR_LPSINFO ) ; p = pr_p_lock ( pnp ) ; mutex_exit ( & pr_pidlock ) ; if ( p == NULL ) { return ( ENOENT ) ; } ASSERT ( p == pnp -> pr_common -> prc_proc ) ; if ( ( nlwp = p -> p_lwpcnt + p -> p_zombcnt ) == 0 ) { prunlock ( pnp ) ; return ( ENOENT ) ; } size = sizeof ( prheader_t ) + nlwp * LSPAN ( lwpsinfo_t ) ; mutex_exit ( & p -> p_lock ) ; php = kmem_zalloc ( size , KM_SLEEP ) ; mutex_enter ( & p -> p_lock ) ; ASSERT ( nlwp == p -> p_lwpcnt + p -> p_zombcnt ) ; php -> pr_nent = nlwp ; php -> pr_entsize = LSPAN ( lwpsinfo_t ) ; sp = ( lwpsinfo_t * ) ( php + 1 ) ; for ( ldp = p -> p_lwpdir , i = 0 ; i < p -> p_lwpdir_sz ; i ++ , ldp ++ ) { if ( ( lep = ldp -> ld_entry ) == NULL ) { continue ; } if ( ( t = lep -> le_thread ) != NULL ) { prgetlwpsinfo ( t , sp ) ; } else { bzero ( sp , sizeof ( * sp ) ) ; sp -> pr_lwpid = lep -> le_lwpid ; sp -> pr_state = SZOMB ; sp -> pr_sname = 'Z' ; sp -> pr_start . tv_sec = lep -> le_start ; sp -> pr_bindpset = PS_NONE ; } sp = ( lwpsinfo_t * ) ( ( caddr_t ) sp + LSPAN ( lwpsinfo_t ) ) ; } prunlock ( pnp ) ; error = pr_uioread ( php , size , uiop ) ; kmem_free ( php , size ) ; return ( error ) ; } 