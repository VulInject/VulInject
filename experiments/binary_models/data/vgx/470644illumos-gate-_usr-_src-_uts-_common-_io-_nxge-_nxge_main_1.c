static boolean_t nxge_m_getcapab ( void * arg , mac_capab_t cap , void * cap_data ) { nxge_t * nxgep = arg ; uint32_t * txflags = cap_data ; switch ( cap ) { case MAC_CAPAB_HCKSUM : NXGE_DEBUG_MSG ( ( nxgep , NXGE_CTL , "==>nxge_m_getcapab: checksum %d" , nxge_cksum_offload ) ) ; if ( nxge_cksum_offload <= 1 ) { * txflags = HCKSUM_INET_PARTIAL ; } break ; case MAC_CAPAB_MULTIFACTADDR : { mac_capab_multifactaddr_t * mfacp = cap_data ; if ( ! isLDOMguest ( nxgep ) ) { mutex_enter ( nxgep -> genlock ) ; mfacp -> mcm_naddr = nxgep -> nxge_mmac_info . num_factory_mmac ; mfacp -> mcm_getaddr = nxge_m_getfactaddr ; mutex_exit ( nxgep -> genlock ) ; } break ; } case MAC_CAPAB_LSO : { mac_capab_lso_t * cap_lso = cap_data ; if ( nxgep -> soft_lso_enable ) { if ( nxge_cksum_offload <= 1 ) { cap_lso -> lso_flags = LSO_TX_BASIC_TCP_IPV4 ; if ( nxge_lso_max > NXGE_LSO_MAXLEN ) { nxge_lso_max = NXGE_LSO_MAXLEN ; } cap_lso -> lso_basic_tcp_ipv4 . lso_max = nxge_lso_max ; } break ; } else { return ( B_FALSE ) ; } } case MAC_CAPAB_RINGS : { mac_capab_rings_t * cap_rings = cap_data ; p_nxge_hw_pt_cfg_t p_cfgp = & nxgep -> pt_config . hw_config ; mutex_enter ( nxgep -> genlock ) ; if ( cap_rings -> mr_type == MAC_RING_TYPE_RX ) { if ( isLDOMguest ( nxgep ) ) { cap_rings -> mr_group_type = MAC_GROUP_TYPE_STATIC ; cap_rings -> mr_rnum = NXGE_HIO_SHARE_MAX_CHANNELS ; cap_rings -> mr_rget = nxge_fill_ring ; cap_rings -> mr_gnum = 1 ; cap_rings -> mr_gget = nxge_hio_group_get ; cap_rings -> mr_gremring = NULL ; } else { cap_rings -> mr_group_type = MAC_GROUP_TYPE_DYNAMIC ; cap_rings -> mr_rnum = p_cfgp -> max_rdcs ; cap_rings -> mr_rget = nxge_fill_ring ; cap_rings -> mr_gnum = p_cfgp -> max_rdc_grpids ; cap_rings -> mr_gget = nxge_hio_group_get ; cap_rings -> mr_gaddring = nxge_group_add_ring ; cap_rings -> mr_gremring = nxge_group_rem_ring ; } NXGE_DEBUG_MSG ( ( nxgep , RX_CTL , "==>nxge_m_getcapab: rx nrings[%d] ngroups[%d]" , p_cfgp -> max_rdcs , p_cfgp -> max_rdc_grpids ) ) ; } else { if ( isLDOMguest ( nxgep ) ) { cap_rings -> mr_group_type = MAC_GROUP_TYPE_STATIC ; cap_rings -> mr_rnum = NXGE_HIO_SHARE_MAX_CHANNELS ; cap_rings -> mr_rget = nxge_fill_ring ; cap_rings -> mr_gnum = 0 ; cap_rings -> mr_gget = NULL ; cap_rings -> mr_gaddring = NULL ; cap_rings -> mr_gremring = NULL ; } else { cap_rings -> mr_group_type = MAC_GROUP_TYPE_DYNAMIC ; cap_rings -> mr_rnum = p_cfgp -> tdc . count ; cap_rings -> mr_rget = nxge_fill_ring ; cap_rings -> mr_gnum = NXGE_MAX_TDC_GROUPS / nxgep -> nports - 1 ; cap_rings -> mr_gget = nxge_hio_group_get ; cap_rings -> mr_gaddring = nxge_group_add_ring ; cap_rings -> mr_gremring = nxge_group_rem_ring ; } NXGE_DEBUG_MSG ( ( nxgep , TX_CTL , "==>nxge_m_getcapab: tx rings # of rings %d" , p_cfgp -> tdc . count ) ) ; } mutex_exit ( nxgep -> genlock ) ; break ; } case MAC_CAPAB_SHARES : { mac_capab_share_t * mshares = ( mac_capab_share_t * ) cap_data ; mutex_enter ( nxgep -> genlock ) ; if ( isLDOMservice ( nxgep ) ) { mshares -> ms_snum = 3 ; mshares -> ms_handle = ( void * ) nxgep ; mshares -> ms_salloc = nxge_hio_share_alloc ; mshares -> ms_sfree = nxge_hio_share_free ; mshares -> ms_sadd = nxge_hio_share_add_group ; mshares -> ms_sremove = nxge_hio_share_rem_group ; mshares -> ms_squery = nxge_hio_share_query ; mshares -> ms_sbind = nxge_hio_share_bind ; mshares -> ms_sunbind = nxge_hio_share_unbind ; mutex_exit ( nxgep -> genlock ) ; } else { mutex_exit ( nxgep -> genlock ) ; return ( B_FALSE ) ; } break ; } default : return ( B_FALSE ) ; } return ( B_TRUE ) ; } 