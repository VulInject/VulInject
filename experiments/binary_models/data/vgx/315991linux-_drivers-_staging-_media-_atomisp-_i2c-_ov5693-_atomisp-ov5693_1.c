static int ov5693_set_fmt ( struct v4l2_subdev * sd , struct v4l2_subdev_state * sd_state , struct v4l2_subdev_format * format ) { struct v4l2_mbus_framefmt * fmt = & format -> format ; struct ov5693_device * dev = to_ov5693_sensor ( sd ) ; struct i2c_client * client = v4l2_get_subdevdata ( sd ) ; struct camera_mipi_info * ov5693_info ; int ret = 0 ; int idx ; if ( format -> pad ) { return - EINVAL ; } if ( ! fmt ) { return - EINVAL ; } ov5693_info = v4l2_get_subdev_hostdata ( sd ) ; if ( ! ov5693_info ) { return - EINVAL ; } mutex_lock ( & dev -> input_lock ) ; idx = nearest_resolution_index ( fmt -> width , fmt -> height ) ; if ( idx == - 1 ) { fmt -> width = ov5693_res [ N_RES - 1 ] . width ; fmt -> height = ov5693_res [ N_RES - 1 ] . height ; } else { fmt -> width = ov5693_res [ idx ] . width ; fmt -> height = ov5693_res [ idx ] . height ; } fmt -> code = MEDIA_BUS_FMT_SBGGR10_1X10 ; if ( format -> which == V4L2_SUBDEV_FORMAT_TRY ) { sd_state -> pads -> try_fmt = * fmt ; mutex_unlock ( & dev -> input_lock ) ; return 0 ; } dev -> fmt_idx = get_resolution_index ( fmt -> width , fmt -> height ) ; if ( dev -> fmt_idx == - 1 ) { dev_err ( & client -> dev , "get resolution fail\n" ) ; mutex_unlock ( & dev -> input_lock ) ; return - EINVAL ; } ret = startup ( sd ) ; if ( ret ) { int i = 0 ; dev_err ( & client -> dev , "ov5693 startup err, retry to power up\n" ) ; for ( i = 0 ; i < OV5693_POWER_UP_RETRY_NUM ; i ++ ) { dev_err ( & client -> dev , "ov5693 retry to power up %d/%d times, result: " , i + 1 , OV5693_POWER_UP_RETRY_NUM ) ; power_down ( sd ) ; ret = power_up ( sd ) ; if ( ! ret ) { mutex_unlock ( & dev -> input_lock ) ; ov5693_init ( sd ) ; mutex_lock ( & dev -> input_lock ) ; } else { dev_err ( & client -> dev , "power up failed, continue\n" ) ; continue ; } ret = startup ( sd ) ; if ( ret ) { dev_err ( & client -> dev , " startup FAILED!\n" ) ; } else { dev_err ( & client -> dev , " startup SUCCESS!\n" ) ; break ; } } } ret = ov5693_write_reg ( client , OV5693_8BIT , OV5693_SW_STREAM , OV5693_STOP_STREAMING ) ; if ( ret ) { dev_warn ( & client -> dev , "ov5693 stream off err\n" ) ; } ov5693_info -> metadata_width = fmt -> width * 10 / 8 ; ov5693_info -> metadata_height = 1 ; ov5693_info -> metadata_effective_width = & ov5693_embedded_effective_size ; mutex_unlock ( & dev -> input_lock ) ; return ret ; } 