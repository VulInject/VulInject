static int smc_nl_handle_smcr_dev ( struct smc_ib_device * smcibdev , struct sk_buff * skb , struct netlink_callback * cb ) { char smc_ibname [ IB_DEVICE_NAME_MAX ] ; struct smc_pci_dev smc_pci_dev ; struct pci_dev * pci_dev ; unsigned char is_crit ; struct nlattr * attrs ; void * nlh ; int i ; nlh = genlmsg_put ( skb , NETLINK_CB ( cb -> skb ) . portid , cb -> nlh -> nlmsg_seq , & smc_gen_nl_family , NLM_F_MULTI , SMC_NETLINK_GET_DEV_SMCR ) ; if ( ! nlh ) { errmsg } attrs = nla_nest_start ( skb , SMC_GEN_DEV_SMCR ) ; if ( ! attrs ) { errout } is_crit = smcr_diag_is_dev_critical ( & smc_lgr_list , smcibdev ) ; if ( nla_put_u8 ( skb , SMC_NLA_DEV_IS_CRIT , is_crit ) ) { errattr } if ( smcibdev -> ibdev -> dev . parent ) { pci_dev = to_pci_dev ( smcibdev -> ibdev -> dev . parent ) ; smc_set_pci_values ( pci_dev , & smc_pci_dev ) ; if ( ! smc_nl_handle_pci_values ( & smc_pci_dev , skb ) ) { errattr } } snprintf ( smc_ibname , sizeof ( smc_ibname ) , "%s" , smcibdev -> ibdev -> name ) ; if ( nla_put_string ( skb , SMC_NLA_DEV_IB_NAME , smc_ibname ) ) { errattr } for ( i = 1 ; i <= SMC_MAX_PORTS ; i ++ ) { if ( ! rdma_is_port_valid ( smcibdev -> ibdev , i ) ) { continue ; } if ( smc_nl_handle_dev_port ( skb , smcibdev -> ibdev , smcibdev , i - 1 ) ) { errattr } } nla_nest_end ( skb , attrs ) ; genlmsg_end ( skb , nlh ) ; return 0 ; errattr nla_nest_cancel ( skb , attrs ) ; errout genlmsg_cancel ( skb , nlh ) ; errmsg return - EMSGSIZE ; } 