int rckrunlevel ( void ) { struct utmpx utmpx ; struct utmpx * putmpx ; char ans [ MAX_INPUT ] ; char * pt ; char * rstates ; int n ; char * uxstate ; if ( ADM ( runlevel , "nocheck" ) ) { return ( 0 ) ; } pt = getenv ( "RSTATES" ) ; if ( pt == NULL ) { return ( 0 ) ; } utmpx . ut_type = RUN_LVL ; putmpx = getutxid ( & utmpx ) ; if ( putmpx == NULL ) { progerr ( ERR_RUNSTATE ) ; return ( 99 ) ; } uxstate = strtok ( & putmpx -> ut_line [ 10 ] , " \t\n" ) ; rstates = qstrdup ( pt ) ; if ( ( pt = strtok ( pt , " \t\n, " ) ) == NULL ) { return ( 0 ) ; } { if ( strcmp ( pt , uxstate ) == 0 ) { return ( 0 ) ; } } pt = strtok ( NULL , " \t\n, " ) ; if ( preremoveCheck == B_FALSE ) { msgtext = MSG_PKGREMOVE_RUNLEVEL ; ptext ( stderr , msgtext , uxstate ) ; } else { ( void ) fprintf ( stdout , "runlevel=%s" , uxstate ) ; } pt = strtok ( rstates , " \t\n, " ) ; { if ( preremoveCheck == B_FALSE ) { ptext ( stderr , "\\t%s" , pt ) ; } else { ( void ) fprintf ( stdout , ":%s" , pt ) ; } } pt = strtok ( NULL , " \t\n, " ) ; if ( preremoveCheck == B_TRUE ) { ( void ) fprintf ( stdout , "\n" ) ; } free ( rstates ) ; if ( ADM ( runlevel , "quit" ) ) { return ( 4 ) ; } if ( echoGetFlag ( ) == B_FALSE ) { return ( 5 ) ; } msgtext = NULL ; n = ckyorn ( ans , NULL , NULL , HLP_PKGREMOVE_RUNLEVEL , ASK_PKGREMOVE_CONTINUE ) ; if ( n != 0 ) { return ( n ) ; } if ( strchr ( "yY" , * ans ) == NULL ) { return ( 3 ) ; } return ( 0 ) ; } 