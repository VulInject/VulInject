void mutt_edit_headers ( const char * editor , const char * body , struct Email * e , struct Buffer * fcc ) { struct Buffer * path = mutt_buffer_pool_get ( ) ; mutt_buffer_mktemp ( path ) ; FILE * fp_out = mutt_file_fopen ( mutt_buffer_string ( path ) , "w" ) ; if ( ! fp_out ) { mutt_perror ( mutt_buffer_string ( path ) ) ; cleanup } mutt_env_to_local ( e -> env , NULL ) ; mutt_rfc822_write_header ( fp_out , e -> env , NULL , MUTT_WRITE_HEADER_EDITHDRS , false , false , NeoMutt -> sub ) ; fputc ( '\n' , fp_out ) ; FILE * fp_in = fopen ( body , "r" ) ; if ( ! fp_in ) { mutt_perror ( body ) ; mutt_file_fclose ( & fp_out ) ; cleanup } mutt_file_copy_stream ( fp_in , fp_out ) ; mutt_file_fclose ( & fp_in ) ; mutt_file_fclose ( & fp_out ) ; struct stat st = { 0 } ; if ( stat ( mutt_buffer_string ( path ) , & st ) == - 1 ) { mutt_perror ( mutt_buffer_string ( path ) ) ; cleanup } time_t mtime = mutt_file_decrease_mtime ( mutt_buffer_string ( path ) , & st ) ; if ( mtime == ( time_t ) - 1 ) { mutt_perror ( mutt_buffer_string ( path ) ) ; cleanup } mutt_edit_file ( editor , mutt_buffer_string ( path ) ) ; if ( ( stat ( mutt_buffer_string ( path ) , & st ) != 0 ) || ( mtime == st . st_mtime ) ) { mutt_debug ( LL_DEBUG1 , "temp file was not modified\n" ) ; mutt_file_unlink ( mutt_buffer_string ( path ) ) ; cleanup } mutt_file_unlink ( body ) ; mutt_list_free ( & e -> env -> userhdrs ) ; fp_in = fopen ( mutt_buffer_string ( path ) , "r" ) ; if ( ! fp_in ) { mutt_perror ( mutt_buffer_string ( path ) ) ; cleanup } fp_out = mutt_file_fopen ( body , "w" ) ; if ( ! fp_out ) { mutt_file_fclose ( & fp_in ) ; mutt_perror ( body ) ; cleanup } struct Envelope * env_new = NULL ; char buf [ 1024 ] { 0 } ; ; env_new = mutt_rfc822_read_header ( fp_in , NULL , true , false ) ; int bytes_read ; while ( ( bytes_read = fread ( buf , 1 , sizeof ( buf ) , fp_in ) ) > 0 ) { fwrite ( buf , 1 , bytes_read , fp_out ) ; } mutt_file_fclose ( & fp_out ) ; mutt_file_fclose ( & fp_in ) ; mutt_file_unlink ( mutt_buffer_string ( path ) ) ; if ( ! OptNewsSend ) { if ( ! STAILQ_EMPTY ( & e -> env -> in_reply_to ) && ( STAILQ_EMPTY ( & env_new -> in_reply_to ) || ! mutt_str_equal ( STAILQ_FIRST ( & env_new -> in_reply_to ) -> data , STAILQ_FIRST ( & e -> env -> in_reply_to ) -> data ) ) ) { mutt_list_free ( & e -> env -> references ) ; } } mutt_list_free ( & env_new -> references ) ; STAILQ_SWAP ( & env_new -> references , & e -> env -> references , ListNode ) ; mutt_env_free ( & e -> env ) ; e -> env = env_new ; env_new = NULL ; mutt_expand_aliases_env ( e -> env ) ; struct ListNode * np = NULL , * tmp = NULL ; STAILQ_FOREACH_SAFE ( , , , ) { bool keep = true ; size_t plen = 0 ; if ( fcc && ( ( plen = mutt_istr_startswith ( np -> data , "X-Mutt-Fcc:" ) ) || ( plen = mutt_istr_startswith ( np -> data , "Mutt-Fcc:" ) ) || ( plen = mutt_istr_startswith ( np -> data , "fcc:" ) ) ) ) { const char * p = mutt_str_skip_email_wsp ( np -> data + plen ) ; if ( * p ) { mutt_buffer_strcpy ( fcc , p ) ; mutt_buffer_pretty_mailbox ( fcc ) ; } keep = false ; } if ( ( plen = mutt_istr_startswith ( np -> data , "X-Mutt-Attach:" ) ) || ( plen = mutt_istr_startswith ( np -> data , "Mutt-Attach:" ) ) || ( plen = mutt_istr_startswith ( np -> data , "attach:" ) ) ) { struct Body * body2 = NULL ; struct Body * parts = NULL ; const char * p = mutt_str_skip_email_wsp ( np -> data + plen ) ; if ( * p ) { mutt_buffer_reset ( path ) ; for ( ; ( p [ 0 ] != '\0' ) && ( p [ 0 ] != ' ' ) && ( p [ 0 ] != '\t' ) ; p ++ ) { if ( p [ 0 ] == '\\' ) { if ( p [ 1 ] == '\0' ) { break ; } p ++ ; } mutt_buffer_addch ( path , * p ) ; } p = mutt_str_skip_email_wsp ( p ) ; mutt_buffer_expand_path ( path ) ; body2 = mutt_make_file_attach ( mutt_buffer_string ( path ) , NeoMutt -> sub ) ; if ( body2 ) { body2 -> description = mutt_str_dup ( p ) ; for ( parts = e -> body ; parts -> next ; parts = parts -> next ) { } parts -> next = body2 ; } else { mutt_buffer_pretty_mailbox ( path ) ; mutt_error ( _ ( "%s: unable to attach file" ) , mutt_buffer_string ( path ) ) ; } } keep = false ; } if ( ( ( WithCrypto & APPLICATION_PGP ) != 0 ) && ( ( plen = mutt_istr_startswith ( np -> data , "X-Mutt-PGP:" ) ) || ( plen = mutt_istr_startswith ( np -> data , "Mutt-PGP:" ) ) || ( plen = mutt_istr_startswith ( np -> data , "pgp:" ) ) ) ) { SecurityFlags sec = mutt_parse_crypt_hdr ( np -> data + plen , false , APPLICATION_PGP ) ; if ( sec != SEC_NO_FLAGS ) { sec |= APPLICATION_PGP ; } if ( sec != e -> security ) { e -> security = sec ; notify_send ( e -> notify , NT_EMAIL , NT_EMAIL_CHANGE , NULL ) ; } keep = false ; } if ( ( ( WithCrypto & APPLICATION_SMIME ) != 0 ) && ( ( plen = mutt_istr_startswith ( np -> data , "X-Mutt-SMIME:" ) ) || ( plen = mutt_istr_startswith ( np -> data , "Mutt-SMIME:" ) ) || ( plen = mutt_istr_startswith ( np -> data , "smime:" ) ) ) ) { SecurityFlags sec = mutt_parse_crypt_hdr ( np -> data + plen , false , APPLICATION_SMIME ) ; if ( sec != SEC_NO_FLAGS ) { sec |= APPLICATION_SMIME ; } if ( sec != e -> security ) { e -> security = sec ; notify_send ( e -> notify , NT_EMAIL , NT_EMAIL_CHANGE , NULL ) ; } keep = false ; } if ( ( plen = mutt_istr_startswith ( np -> data , "X-Mutt-Mix:" ) ) || ( plen = mutt_istr_startswith ( np -> data , "Mutt-Mix:" ) ) ) { mutt_list_free ( & e -> chain ) ; char * t = strtok ( np -> data + plen , ", \t\n" ) ; while ( t ) { mutt_list_insert_tail ( & e -> chain , mutt_str_dup ( t ) ) ; t = strtok ( NULL , ", \t\n" ) ; } keep = false ; } if ( ! keep ) { STAILQ_REMOVE ( & e -> env -> userhdrs , np , ListNode , entries ) ; FREE ( & np -> data ) ; FREE ( & np ) ; } } cleanup mutt_buffer_pool_release ( & path ) ; } 