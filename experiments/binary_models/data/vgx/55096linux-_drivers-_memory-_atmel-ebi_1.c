static int atmel_ebi_xslate_smc_timings ( struct atmel_ebi_dev * ebid , struct device_node * np , struct atmel_smc_cs_conf * smcconf ) { int clk_rate = clk_get_rate ( ebid -> ebi -> clk ) ; unsigned int clk_period_ns = NSEC_PER_SEC / clk_rate ; bool required = false ; unsigned int ncycles ; int ret , i ; u32 val ; ret = of_property_read_u32 ( np , "atmel,smc-tdf-ns" , & val ) ; if ( ! ret ) { required = true ; ncycles = DIV_ROUND_UP ( val , clk_period_ns ) ; if ( ncycles > ATMEL_SMC_MODE_TDF_MAX ) { ret = - EINVAL ; out } if ( ncycles < ATMEL_SMC_MODE_TDF_MIN ) { ncycles = ATMEL_SMC_MODE_TDF_MIN ; } smcconf -> mode |= ATMEL_SMC_MODE_TDF ( ncycles ) ; } for ( i = 0 ; i < ARRAY_SIZE ( timings_xlate_table ) ; i ++ ) { const struct atmel_smc_timing_xlate * xlate ; xlate = & timings_xlate_table [ i ] ; ret = of_property_read_u32 ( np , xlate -> name , & val ) ; if ( ret ) { if ( ! required ) { continue ; } else { break ; } } if ( ! required ) { ret = - EINVAL ; break ; } ncycles = DIV_ROUND_UP ( val , clk_period_ns ) ; ret = xlate -> converter ( smcconf , xlate -> shift , ncycles ) ; if ( ret ) { out } } out if ( ret ) { dev_err ( ebid -> ebi -> dev , "missing or invalid timings definition in %pOF" , np ) ; return ret ; } return required ; } 