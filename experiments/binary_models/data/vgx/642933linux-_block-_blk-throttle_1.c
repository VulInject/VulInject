void blk_throtl_bio_endio ( struct bio * bio ) { struct blkcg_gq * blkg ; struct throtl_grp * tg ; u64 finish_time_ns ; unsigned long finish_time ; unsigned long start_time ; unsigned long lat ; int rw = bio_data_dir ( bio ) ; blkg = bio -> bi_blkg ; tg = blkg_to_tg ( blkg ) ; if ( ! tg -> td -> limit_valid [ LIMIT_LOW ] ) { return ; } finish_time_ns = ktime_get_ns ( ) ; tg -> last_finish_time = finish_time_ns >> 10 ; start_time = bio_issue_time ( & bio -> bi_issue ) >> 10 ; finish_time = __bio_issue_time ( finish_time_ns ) >> 10 ; if ( ! start_time || finish_time <= start_time ) { return ; } lat = finish_time - start_time ; if ( ! ( bio -> bi_issue . value & BIO_ISSUE_THROTL_SKIP_LATENCY ) ) { throtl_track_latency ( tg -> td , bio_issue_size ( & bio -> bi_issue ) , bio_op ( bio ) , lat ) ; } if ( tg -> latency_target && lat >= tg -> td -> filtered_latency ) { int bucket ; unsigned int threshold ; bucket = request_bucket_index ( bio_issue_size ( & bio -> bi_issue ) ) ; threshold = tg -> td -> avg_buckets [ rw ] [ bucket ] . latency + tg -> latency_target ; if ( lat > threshold ) { tg -> bad_bio_cnt ++ ; } tg -> bio_cnt ++ ; } if ( time_after ( jiffies , tg -> bio_cnt_reset_time ) || tg -> bio_cnt > 1024 ) { tg -> bio_cnt_reset_time = tg -> td -> throtl_slice + jiffies ; tg -> bio_cnt /= 2 ; tg -> bad_bio_cnt /= 2 ; } } 