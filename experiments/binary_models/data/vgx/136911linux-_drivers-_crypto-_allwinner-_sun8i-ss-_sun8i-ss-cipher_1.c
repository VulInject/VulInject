static int sun8i_ss_cipher ( struct skcipher_request * areq ) { struct crypto_skcipher * tfm = crypto_skcipher_reqtfm ( areq ) ; struct sun8i_cipher_tfm_ctx * op = crypto_skcipher_ctx ( tfm ) ; struct sun8i_ss_dev * ss = op -> ss ; struct sun8i_cipher_req_ctx * rctx = skcipher_request_ctx ( areq ) ; struct skcipher_alg * alg = crypto_skcipher_alg ( tfm ) ; struct sun8i_ss_alg_template * algt ; struct sun8i_ss_flow * sf = & ss -> flows [ rctx -> flow ] ; struct scatterlist * sg ; unsigned int todo , len , offset , ivsize ; int nr_sgs = 0 ; int nr_sgd = 0 ; int err = 0 ; int nsgs = sg_nents_for_len ( areq -> src , areq -> cryptlen ) ; int nsgd = sg_nents_for_len ( areq -> dst , areq -> cryptlen ) ; int i ; algt = container_of ( alg , sun8i_ss_alg_template , alg . skcipher ) ; dev_dbg ( ss -> dev , "%s %s %u %x IV(%p %u) key=%u\n" , __func__ , crypto_tfm_alg_name ( areq -> base . tfm ) , areq -> cryptlen , rctx -> op_dir , areq -> iv , crypto_skcipher_ivsize ( tfm ) , op -> keylen ) ; algt -> stat_req ++ ; rctx -> op_mode = ss -> variant -> op_mode [ algt -> ss_blockmode ] ; rctx -> method = ss -> variant -> alg_cipher [ algt -> ss_algo_id ] ; rctx -> keylen = op -> keylen ; rctx -> p_key = dma_map_single ( ss -> dev , op -> key , op -> keylen , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( ss -> dev , rctx -> p_key ) ) { dev_err ( ss -> dev , "Cannot DMA MAP KEY\n" ) ; err = - EFAULT ; theend } ivsize = crypto_skcipher_ivsize ( tfm ) ; if ( areq -> iv && crypto_skcipher_ivsize ( tfm ) > 0 ) { err = sun8i_ss_setup_ivs ( areq , NULL ) ; if ( err ) { theend_key } } if ( areq -> src == areq -> dst ) { nr_sgs = dma_map_sg ( ss -> dev , areq -> src , nsgs , DMA_BIDIRECTIONAL ) ; if ( nr_sgs <= 0 || nr_sgs > 8 ) { dev_err ( ss -> dev , "Invalid sg number %d\n" , nr_sgs ) ; err = - EINVAL ; theend_iv } nr_sgd = nr_sgs ; } else { nr_sgs = dma_map_sg ( ss -> dev , areq -> src , nsgs , DMA_TO_DEVICE ) ; if ( nr_sgs <= 0 || nr_sgs > 8 ) { dev_err ( ss -> dev , "Invalid sg number %d\n" , nr_sgs ) ; err = - EINVAL ; theend_iv } nr_sgd = dma_map_sg ( ss -> dev , areq -> dst , nsgd , DMA_FROM_DEVICE ) ; if ( nr_sgd <= 0 || nr_sgd > 8 ) { dev_err ( ss -> dev , "Invalid sg number %d\n" , nr_sgd ) ; err = - EINVAL ; theend_sgs } } len = areq -> cryptlen ; i = 0 ; sg = areq -> src ; while ( i < nr_sgs && sg && len ) { if ( sg_dma_len ( sg ) == 0 ) { sgs_next } rctx -> t_src [ i ] . addr = sg_dma_address ( sg ) ; todo = min ( len , sg_dma_len ( sg ) ) ; rctx -> t_src [ i ] . len = todo / 4 ; dev_dbg ( ss -> dev , "%s total=%u SGS(%d %u off=%d) todo=%u\n" , __func__ , areq -> cryptlen , i , rctx -> t_src [ i ] . len , sg -> offset , todo ) ; len -= todo ; i ++ ; sgs_next sg = sg_next ( sg ) ; } if ( len > 0 ) { dev_err ( ss -> dev , "remaining len %d\n" , len ) ; err = - EINVAL ; theend_sgs } len = areq -> cryptlen ; i = 0 ; sg = areq -> dst ; while ( i < nr_sgd && sg && len ) { if ( sg_dma_len ( sg ) == 0 ) { sgd_next } rctx -> t_dst [ i ] . addr = sg_dma_address ( sg ) ; todo = min ( len , sg_dma_len ( sg ) ) ; rctx -> t_dst [ i ] . len = todo / 4 ; dev_dbg ( ss -> dev , "%s total=%u SGD(%d %u off=%d) todo=%u\n" , __func__ , areq -> cryptlen , i , rctx -> t_dst [ i ] . len , sg -> offset , todo ) ; len -= todo ; i ++ ; sgd_next sg = sg_next ( sg ) ; } if ( len > 0 ) { dev_err ( ss -> dev , "remaining len %d\n" , len ) ; err = - EINVAL ; theend_sgs } err = sun8i_ss_run_task ( ss , rctx , crypto_tfm_alg_name ( areq -> base . tfm ) ) ; theend_sgs if ( areq -> src == areq -> dst ) { dma_unmap_sg ( ss -> dev , areq -> src , nsgs , DMA_BIDIRECTIONAL ) ; } else { dma_unmap_sg ( ss -> dev , areq -> src , nsgs , DMA_TO_DEVICE ) ; dma_unmap_sg ( ss -> dev , areq -> dst , nsgd , DMA_FROM_DEVICE ) ; } theend_iv if ( areq -> iv && ivsize > 0 ) { for ( i = 0 ; i < rctx -> niv ; i ++ ) { dma_unmap_single ( ss -> dev , rctx -> p_iv [ i ] , ivsize , DMA_TO_DEVICE ) ; memzero_explicit ( sf -> iv [ i ] , ivsize ) ; } offset = areq -> cryptlen - ivsize ; if ( rctx -> op_dir & SS_DECRYPTION ) { memcpy ( areq -> iv , sf -> biv , ivsize ) ; memzero_explicit ( sf -> biv , ivsize ) ; } else { scatterwalk_map_and_copy ( areq -> iv , areq -> dst , offset , ivsize , 0 ) ; } } theend_key dma_unmap_single ( ss -> dev , rctx -> p_key , op -> keylen , DMA_TO_DEVICE ) ; theend return err ; } 