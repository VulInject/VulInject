static int netfilter_send_config_msg ( const pcap_t * handle , uint16_t msg_type , int ack , u_int8_t family , u_int16_t res_id , const struct my_nfattr * mynfa ) { char buf [ 1024 ] __attribute__ ( ( aligned ) ) ; struct nlmsghdr * nlh = ( nlmsghdr * ) buf ; struct nfgenmsg * nfg = ( nfgenmsg * ) ( buf + sizeof ( nlmsghdr ) ) ; struct sockaddr_nl snl ; static unsigned int seq_id ; if ( ! seq_id ) { seq_id = time ( NULL ) ; } ++ seq_id ; nlh -> nlmsg_len = NLMSG_LENGTH ( sizeof ( nfgenmsg ) ) ; nlh -> nlmsg_type = msg_type ; nlh -> nlmsg_flags = NLM_F_REQUEST | ( ack ?NLM_F_ACK : 0 ) ; nlh -> nlmsg_pid = 0 ; nlh -> nlmsg_seq = seq_id ; nfg -> nfgen_family = family ; nfg -> version = NFNETLINK_V0 ; nfg -> res_id = htons ( res_id ) ; if ( mynfa ) { struct nfattr * nfa = ( nfattr * ) ( buf + NLMSG_ALIGN ( nlh -> nlmsg_len ) ) ; nfa -> nfa_type = mynfa -> nfa_type ; nfa -> nfa_len = NFA_LENGTH ( mynfa -> nfa_len ) ; memcpy ( NFA_DATA ( nfa ) , mynfa -> data , mynfa -> nfa_len ) ; nlh -> nlmsg_len = NLMSG_ALIGN ( nlh -> nlmsg_len ) + NFA_ALIGN ( nfa -> nfa_len ) ; } memset ( & snl , 0 , sizeof ( snl ) ) ; snl . nl_family = AF_NETLINK ; if ( sendto ( handle -> fd , nlh , nlh -> nlmsg_len , 0 , ( sockaddr * ) & snl , sizeof ( snl ) ) == - 1 ) { return - 1 ; } if ( ! ack ) { return 0 ; } { socklen_t addrlen = sizeof ( snl ) ; int len ; { len = ( int ) recvfrom ( handle -> fd , buf , sizeof ( buf ) , 0 , ( sockaddr * ) & snl , & addrlen ) ; } ( len == - 1 ) && ( errno == EINTR ) ; if ( len <= 0 ) { return len ; } if ( addrlen != sizeof ( snl ) || snl . nl_family != AF_NETLINK ) { errno = EINVAL ; return - 1 ; } nlh = ( nlmsghdr * ) buf ; if ( snl . nl_pid != 0 || seq_id != nlh -> nlmsg_seq ) { continue ; } while ( ( u_int ) len >= NLMSG_SPACE ( 0 ) && NLMSG_OK ( nlh , ( u_int ) len ) ) { if ( nlh -> nlmsg_type == NLMSG_ERROR || ( nlh -> nlmsg_type == NLMSG_DONE && nlh -> nlmsg_flags & NLM_F_MULTI ) ) { if ( nlh -> nlmsg_len < NLMSG_ALIGN ( sizeof ( nlmsgerr ) ) ) { errno = EBADMSG ; return - 1 ; } errno = - ( * ( ( int * ) NLMSG_DATA ( nlh ) ) ) ; return ( errno == 0 ) ?0 : - 1 ; } nlh = NLMSG_NEXT ( nlh , len ) ; } } 1 ; return - 1 ; } 