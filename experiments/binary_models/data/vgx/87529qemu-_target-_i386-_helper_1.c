static void do_inject_x86_mce ( CPUState * cs , run_on_cpu_data data ) { MCEInjectionParams * params = data . host_ptr ; X86CPU * cpu = X86_CPU ( cs ) ; CPUX86State * cenv = & cpu -> env ; uint64_t * banks = cenv -> mce_banks + 4 * params -> bank ; g_autofree char * msg = NULL ; bool need_reset = false ; bool recursive ; bool ar = ! ! ( params -> status & MCI_STATUS_AR ) ; cpu_synchronize_state ( cs ) ; recursive = ! ! ( cenv -> mcg_status & MCG_STATUS_MCIP ) ; if ( ! ( params -> flags & MCE_INJECT_UNCOND_AO ) && ! ar && recursive ) { emit_guest_memory_failure ( MEMORY_FAILURE_ACTION_IGNORE , ar , recursive ) ; return ; } if ( params -> status & MCI_STATUS_UC ) { if ( ( cenv -> mcg_cap & MCG_CTL_P ) && cenv -> mcg_ctl != ~ ( uint64_t ) 0 ) { monitor_printf ( params -> mon , "CPU %d: Uncorrected error reporting disabled\n" , cs -> cpu_index ) ; return ; } if ( banks [ 0 ] != ~ ( uint64_t ) 0 ) { monitor_printf ( params -> mon , "CPU %d: Uncorrected error reporting disabled for" " bank %d\n" , cs -> cpu_index , params -> bank ) ; return ; } if ( ! ( cenv -> cr [ 4 ] & CR4_MCE_MASK ) ) { need_reset = true ; msg = g_strdup_printf ( "CPU %d: MCE capability is not enabled, " "raising triple fault" , cs -> cpu_index ) ; } if ( recursive ) { need_reset = true ; msg = g_strdup_printf ( "CPU %d: Previous MCE still in progress, " "raising triple fault" , cs -> cpu_index ) ; } if ( need_reset ) { emit_guest_memory_failure ( MEMORY_FAILURE_ACTION_RESET , ar , recursive ) ; monitor_printf ( params -> mon , "%s" , msg ) ; qemu_log_mask ( CPU_LOG_RESET , "%s\n" , msg ) ; qemu_system_reset_request ( SHUTDOWN_CAUSE_GUEST_RESET , NULL ) ; return ; } if ( banks [ 1 ] & MCI_STATUS_VAL ) { params -> status |= MCI_STATUS_OVER ; } banks [ 2 ] = params -> addr ; banks [ 3 ] = params -> misc ; cenv -> mcg_status = params -> mcg_status ; banks [ 1 ] = params -> status ; cpu_interrupt ( cs , CPU_INTERRUPT_MCE ) ; } if ( ! ( banks [ 1 ] & MCI_STATUS_VAL ) || ! ( banks [ 1 ] & MCI_STATUS_UC ) ) { if ( banks [ 1 ] & MCI_STATUS_VAL ) { params -> status |= MCI_STATUS_OVER ; } banks [ 2 ] = params -> addr ; banks [ 3 ] = params -> misc ; banks [ 1 ] = params -> status ; } else { banks [ 1 ] |= MCI_STATUS_OVER ; } emit_guest_memory_failure ( MEMORY_FAILURE_ACTION_INJECT , ar , recursive ) ; } 