static krb5_error_code digest_request ( krb5_context context , krb5_realm realm , krb5_ccache ccache , krb5_key_usage usage , const DigestReqInner * ireq , DigestRepInner * irep ) { DigestREQ req ; DigestREP rep ; krb5_error_code ret ; krb5_data data , data2 ; size_t size = 0 ; krb5_crypto crypto = NULL ; krb5_auth_context ac = NULL ; krb5_principal principal = NULL ; krb5_ccache id = NULL ; krb5_realm r = NULL ; krb5_data_zero ( & data ) ; krb5_data_zero ( & data2 ) ; memset ( & rep , 0 , sizeof ( rep ) ) ; if ( ccache == NULL ) { ret = krb5_cc_default ( context , & id ) ; if ( ret ) { out } } else { id = ccache ; } if ( realm == NULL ) { ret = krb5_get_default_realm ( context , & r ) ; if ( ret ) { out } } else { r = realm ; } ret = krb5_make_principal ( context , & principal , r , KRB5_DIGEST_NAME , r , NULL ) ; if ( ret ) { out } ASN1_MALLOC_ENCODE ( DigestReqInner , data . data , data . length , ireq , & size , ret ) ; if ( ret ) { krb5_set_error_message ( context , ret , N_ ( "Failed to encode digest inner request" , "" ) ) ; out } if ( size != data . length ) { krb5_abortx ( context , "ASN.1 internal encoder error" ) ; } ret = krb5_mk_req_exact ( context , & ac , AP_OPTS_USE_SUBKEY | AP_OPTS_MUTUAL_REQUIRED , principal , NULL , id , & req . apReq ) ; if ( ret ) { out } { krb5_keyblock * key ; ret = krb5_auth_con_getlocalsubkey ( context , ac , & key ) ; if ( ret ) { out } if ( key == NULL ) { ret = EINVAL ; krb5_set_error_message ( context , ret , N_ ( "Digest failed to get local subkey" , "" ) ) ; out } ret = krb5_crypto_init ( context , key , 0 , & crypto ) ; krb5_free_keyblock ( context , key ) ; if ( ret ) { out } } ret = krb5_encrypt_EncryptedData ( context , crypto , usage , data . data , data . length , 0 , & req . innerReq ) ; if ( ret ) { out } krb5_data_free ( & data ) ; ASN1_MALLOC_ENCODE ( DigestREQ , data . data , data . length , & req , & size , ret ) ; if ( ret ) { krb5_set_error_message ( context , ret , N_ ( "Failed to encode DigestREQest" , "" ) ) ; out } if ( size != data . length ) { krb5_abortx ( context , "ASN.1 internal encoder error" ) ; } ret = krb5_sendto_kdc ( context , & data , & r , & data2 ) ; if ( ret ) { out } ret = decode_DigestREP ( data2 . data , data2 . length , & rep , NULL ) ; if ( ret ) { krb5_set_error_message ( context , ret , N_ ( "Failed to parse digest response" , "" ) ) ; out } { krb5_ap_rep_enc_part * repl ; ret = krb5_rd_rep ( context , ac , & rep . apRep , & repl ) ; if ( ret ) { out } krb5_free_ap_rep_enc_part ( context , repl ) ; } { krb5_keyblock * key ; ret = krb5_auth_con_getremotesubkey ( context , ac , & key ) ; if ( ret ) { out } if ( key == NULL ) { ret = EINVAL ; krb5_set_error_message ( context , ret , N_ ( "Digest reply have no remote subkey" , "" ) ) ; out } krb5_crypto_destroy ( context , crypto ) ; ret = krb5_crypto_init ( context , key , 0 , & crypto ) ; krb5_free_keyblock ( context , key ) ; if ( ret ) { out } } krb5_data_free ( & data ) ; ret = krb5_decrypt_EncryptedData ( context , crypto , usage , & rep . innerRep , & data ) ; if ( ret ) { out } ret = decode_DigestRepInner ( data . data , data . length , irep , NULL ) ; if ( ret ) { krb5_set_error_message ( context , ret , N_ ( "Failed to decode digest inner reply" , "" ) ) ; out } out if ( ccache == NULL && id ) { krb5_cc_close ( context , id ) ; } if ( realm == NULL && r ) { free ( r ) ; } if ( crypto ) { krb5_crypto_destroy ( context , crypto ) ; } if ( ac ) { krb5_auth_con_free ( context , ac ) ; } if ( principal ) { krb5_free_principal ( context , principal ) ; } krb5_data_free ( & data ) ; krb5_data_free ( & data2 ) ; free_DigestREQ ( & req ) ; free_DigestREP ( & rep ) ; return ret ; } 