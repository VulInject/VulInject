static int spear_smi_setup_banks ( struct platform_device * pdev , u32 bank , struct device_node * np ) { struct spear_smi * dev = platform_get_drvdata ( pdev ) ; struct spear_smi_flash_info * flash_info ; struct spear_smi_plat_data * pdata ; struct spear_snor_flash * flash ; struct mtd_partition * parts = NULL ; int count = 0 ; int flash_index ; int ret = 0 ; pdata = dev_get_platdata ( & pdev -> dev ) ; flash_info = & pdata -> board_flash_info [ bank ] ; if ( ! flash_info ) { return - ENODEV ; } flash = devm_kzalloc ( & pdev -> dev , sizeof ( * flash ) , GFP_ATOMIC ) ; if ( ! flash ) { return - ENOMEM ; } flash -> bank = bank ; flash -> fast_mode = flash_info -> fast_mode ?1 : 0 ; mutex_init ( & flash -> lock ) ; flash_index = spear_smi_probe_flash ( dev , bank ) ; if ( flash_index < 0 ) { dev_info ( & dev -> pdev -> dev , "smi-nor%d not found\n" , bank ) ; return flash_index ; } flash -> base_addr = devm_ioremap ( & pdev -> dev , flash_info -> mem_base , flash_info -> size ) ; if ( ! flash -> base_addr ) { return - EIO ; } dev -> flash [ bank ] = flash ; flash -> mtd . priv = dev ; if ( flash_info -> name ) { flash -> mtd . name = flash_info -> name ; } else { flash -> mtd . name = flash_devices [ flash_index ] . name ; } flash -> mtd . dev . parent = & pdev -> dev ; mtd_set_of_node ( & flash -> mtd , np ) ; flash -> mtd . type = MTD_NORFLASH ; flash -> mtd . writesize = 1 ; flash -> mtd . flags = MTD_CAP_NORFLASH ; flash -> mtd . size = flash_info -> size ; flash -> mtd . erasesize = flash_devices [ flash_index ] . sectorsize ; flash -> page_size = flash_devices [ flash_index ] . pagesize ; flash -> mtd . writebufsize = flash -> page_size ; flash -> erase_cmd = flash_devices [ flash_index ] . erase_cmd ; flash -> mtd . _erase = spear_mtd_erase ; flash -> mtd . _read = spear_mtd_read ; flash -> mtd . _write = spear_mtd_write ; flash -> dev_id = flash_devices [ flash_index ] . device_id ; dev_info ( & dev -> pdev -> dev , "mtd .name=%s .size=%llx(%lluM)\n" , flash -> mtd . name , flash -> mtd . size , flash -> mtd . size / ( 1024 * 1024 ) ) ; dev_info ( & dev -> pdev -> dev , ".erasesize = 0x%x(%uK)\n" , flash -> mtd . erasesize , flash -> mtd . erasesize / 1024 ) ; if ( flash_info -> partitions ) { parts = flash_info -> partitions ; count = flash_info -> nr_partitions ; } ret = mtd_device_register ( & flash -> mtd , parts , count ) ; if ( ret ) { dev_err ( & dev -> pdev -> dev , "Err MTD partition=%d\n" , ret ) ; return ret ; } return 0 ; } 