static void fill_rtp_es_ifce ( GF_ESInterface * ifce , GF_SDPMedia * media , GF_SDPInfo * sdp , M2TSSource * source ) { u32 i ; GF_Err e ; GF_X_Attribute * att ; GF_ESIRTP * rtp ; GF_RTPMap * map ; GF_SDPConnection * conn ; GF_RTSPTransport trans ; conn = sdp -> c_connection ; if ( ! conn ) { conn = ( GF_SDPConnection * ) gf_list_get ( media -> Connections , 0 ) ; } map = ( GF_RTPMap * ) gf_list_get ( media -> RTPMaps , 0 ) ; GF_SAFEALLOC ( rtp , GF_ESIRTP ) ; if ( ! rtp ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_APP , ( "Failed to allocate RTP input handler\n" ) ) ; return ; } rtp -> rtp_ch = gf_rtp_new ( ) ; i = 0 ; while ( ( att = ( GF_X_Attribute * ) gf_list_enum ( media -> Attributes , & i ) ) ) { if ( ! stricmp ( att -> Name , "mpeg4-esid" ) && att -> Value ) { ifce -> stream_id = atoi ( att -> Value ) ; } } memset ( & trans , 0 , sizeof ( GF_RTSPTransport ) ) ; trans . Profile = media -> Profile ; trans . source = conn ?conn -> host : sdp -> o_address ; trans . IsUnicast = gf_sk_is_multicast_address ( trans . source ) ?GF_FALSE : GF_TRUE ; if ( ! trans . IsUnicast ) { trans . port_first = media -> PortNumber ; trans . port_last = media -> PortNumber + 1 ; trans . TTL = conn ?conn -> TTL : 0 ; } else { trans . client_port_first = media -> PortNumber ; trans . client_port_last = media -> PortNumber + 1 ; } if ( gf_rtp_setup_transport ( rtp -> rtp_ch , & trans , NULL ) != GF_OK ) { gf_rtp_del ( rtp -> rtp_ch ) ; fprintf ( stderr , "Cannot initialize RTP transport\n" ) ; return ; } rtp -> depacketizer = gf_rtp_depacketizer_new ( media , rtp_sl_packet_cbk , rtp ) ; if ( ! rtp -> depacketizer ) { gf_rtp_del ( rtp -> rtp_ch ) ; fprintf ( stderr , "Cannot create RTP depacketizer\n" ) ; return ; } gf_rtp_setup_payload ( rtp -> rtp_ch , map -> PayloadType , map -> ClockRate ) ; ifce -> input_udta = rtp ; ifce -> input_ctrl = rtp_input_ctrl ; rtp -> ifce = ifce ; rtp -> source = source ; ifce -> object_type_indication = rtp -> depacketizer -> sl_map . CodecID ; ifce -> stream_type = rtp -> depacketizer -> sl_map . StreamType ; ifce -> timescale = gf_rtp_get_clockrate ( rtp -> rtp_ch ) ; if ( rtp -> depacketizer -> sl_map . config ) { switch ( ifce -> object_type_indication ) { case GF_CODECID_MPEG4_PART2 : rtp -> cat_dsi = GF_TRUE ; break ; case GF_CODECID_AVC : case GF_CODECID_SVC : case GF_CODECID_MVC : rtp -> is_264 = GF_TRUE ; rtp -> depacketizer -> flags |= GF_RTP_AVC_USE_ANNEX_B ; { GF_AVCConfig * avccfg = gf_odf_avc_cfg_read ( rtp -> depacketizer -> sl_map . config , rtp -> depacketizer -> sl_map . configSize ) ; if ( avccfg ) { GF_AVCConfigSlot * slc ; u32 i ; GF_BitStream * bs ; bs = gf_bs_new ( NULL , 0 , GF_BITSTREAM_WRITE ) ; for ( i = 0 ; i < gf_list_count ( avccfg -> sequenceParameterSets ) ; i ++ ) { slc = ( GF_AVCConfigSlot * ) gf_list_get ( avccfg -> sequenceParameterSets , i ) ; gf_bs_write_u32 ( bs , 1 ) ; gf_bs_write_data ( bs , slc -> data , slc -> size ) ; } for ( i = 0 ; i < gf_list_count ( avccfg -> pictureParameterSets ) ; i ++ ) { slc = ( GF_AVCConfigSlot * ) gf_list_get ( avccfg -> pictureParameterSets , i ) ; gf_bs_write_u32 ( bs , 1 ) ; gf_bs_write_data ( bs , slc -> data , slc -> size ) ; } gf_bs_get_content ( bs , ( char * * ) & rtp -> dsi_and_rap , & rtp -> avc_dsi_size ) ; gf_bs_del ( bs ) ; } gf_odf_avc_cfg_del ( avccfg ) ; } break ; case GF_CODECID_AAC_MPEG4 : ifce -> decoder_config = ( char * ) gf_malloc ( sizeof ( char ) * rtp -> depacketizer -> sl_map . configSize ) ; ifce -> decoder_config_size = rtp -> depacketizer -> sl_map . configSize ; memcpy ( ifce -> decoder_config , rtp -> depacketizer -> sl_map . config , rtp -> depacketizer -> sl_map . configSize ) ; break ; } } if ( rtp -> depacketizer -> sl_map . StreamStateIndication ) { rtp -> use_carousel = GF_TRUE ; rtp -> au_sn = 0 ; } gf_rtp_depacketizer_reset ( rtp -> depacketizer , GF_TRUE ) ; e = gf_rtp_initialize ( rtp -> rtp_ch , 0x100000ul , GF_FALSE , 0 , 10 , 200 , NULL ) ; if ( e != GF_OK ) { gf_rtp_del ( rtp -> rtp_ch ) ; fprintf ( stderr , "Cannot initialize RTP channel: %s\n" , gf_error_to_string ( e ) ) ; return ; } fprintf ( stderr , "RTP interface initialized\n" ) ; } 