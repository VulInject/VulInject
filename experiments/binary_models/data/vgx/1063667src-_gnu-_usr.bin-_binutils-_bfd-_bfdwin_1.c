bfd_free_window ( ) { bfd_window_internal * i = windowp -> i ; windowp -> i = 0 ; windowp -> data = 0 ; if ( i == 0 ) { return ; } i -> refcount -- ; if ( debug_windows ) { fprintf ( stderr , "freeing window @%p<%p,%lx,%p>\n" , windowp , windowp -> data , windowp -> size , windowp -> i ) ; } if ( i -> refcount != 0 ) { return ; } if ( i -> mapped ) { munmap ( i -> data , i -> size ) ; no_free abort ( ) ; } mprotect ( i -> data , i -> size , PROT_READ | PROT_WRITE ) ; free ( i -> data ) ; no_free i -> data = 0 ; } static int ok_to_map = 1 ; bfd_boolean bfd_get_file_window ( bfd * abfd , file_ptr offset , bfd_size_type size , bfd_window * windowp , bfd_boolean writable ) { static size_t pagesize ; bfd_window_internal * i = windowp -> i ; bfd_size_type size_to_alloc = size ; if ( debug_windows ) { fprintf ( stderr , "bfd_get_file_window (%p, %6ld, %6ld, %p<%p,%lx,%p>, %d)" , abfd , ( long ) offset , ( long ) size , windowp , windowp -> data , ( unsigned long ) windowp -> size , windowp -> i , writable ) ; } if ( pagesize == 0 ) { pagesize = getpagesize ( ) ; } if ( pagesize == 0 ) { abort ( ) ; } if ( i == 0 ) { i = bfd_zmalloc ( sizeof ( bfd_window_internal ) ) ; windowp -> i = i ; if ( i == 0 ) { return FALSE ; } i -> data = 0 ; } if ( ok_to_map && ( i -> data == 0 || i -> mapped == 1 ) && ( abfd -> flags & BFD_IN_MEMORY ) == 0 ) { file_ptr file_offset , offset2 ; size_t real_size ; int fd ; FILE * f ; while ( abfd -> my_archive != NULL ) { offset += abfd -> origin ; abfd = abfd -> my_archive ; } f = bfd_cache_lookup ( abfd ) ; fd = fileno ( f ) ; offset2 = offset % pagesize ; if ( offset2 < 0 ) { abort ( ) ; } file_offset = offset - offset2 ; real_size = offset + size - file_offset ; real_size = real_size + pagesize - 1 ; real_size -= real_size % pagesize ; if ( i -> data && i -> size < size ) { munmap ( i -> data , i -> size ) ; i -> data = 0 ; } i -> data = mmap ( i -> data , real_size , writable ?PROT_WRITE | PROT_READ : PROT_READ , ( writable ?MAP_FILE | MAP_PRIVATE : MAP_FILE | MAP_SHARED ) , fd , file_offset ) ; if ( i -> data == ( void * ) - 1 ) { bfd_set_error ( bfd_error_system_call ) ; i -> data = 0 ; windowp -> data = 0 ; if ( debug_windows ) { fprintf ( stderr , "\t\tmmap failed!\n" ) ; } return FALSE ; } if ( debug_windows ) { fprintf ( stderr , "\n\tmapped %ld at %p, offset is %ld\n" , ( long ) real_size , i -> data , ( long ) offset2 ) ; } i -> size = real_size ; windowp -> data = ( bfd_byte * ) i -> data + offset2 ; windowp -> size = size ; i -> mapped = 1 ; return TRUE ; } if ( debug_windows ) { if ( ok_to_map ) { fprintf ( stderr , _ ( "not mapping: data=%lx mapped=%d\n" ) , ( unsigned long ) i -> data , ( int ) i -> mapped ) ; } else { fprintf ( stderr , _ ( "not mapping: env var not set\n" ) ) ; } } ok_to_map = 0 ; if ( ! writable ) { size_to_alloc += pagesize - 1 ; size_to_alloc -= size_to_alloc % pagesize ; } if ( debug_windows ) { fprintf ( stderr , "\n\t%s(%6ld)" , i -> data ?"realloc" : " malloc" , ( long ) size_to_alloc ) ; } i -> data = bfd_realloc ( i -> data , size_to_alloc ) ; if ( debug_windows ) { fprintf ( stderr , "\t->%p\n" , i -> data ) ; } i -> refcount = 1 ; if ( i -> data == NULL ) { if ( size_to_alloc == 0 ) { return TRUE ; } return FALSE ; } if ( bfd_seek ( abfd , offset , SEEK_SET ) != 0 ) { return FALSE ; } i -> size = bfd_bread ( i -> data , size , abfd ) ; if ( i -> size != size ) { return FALSE ; } i -> mapped = 0 ; if ( ! writable ) { if ( debug_windows ) { fprintf ( stderr , "\tmprotect (%p, %ld, PROT_READ)\n" , i -> data , ( long ) i -> size ) ; } mprotect ( i -> data , i -> size , PROT_READ ) ; } windowp -> data = i -> data ; windowp -> size = i -> size ; return TRUE ; } 