static int ptlrpcd_check ( struct lu_env * env , struct ptlrpcd_ctl * pc ) { struct list_head * tmp , * pos ; struct ptlrpc_request * req ; struct ptlrpc_request_set * set = pc -> pc_set ; int rc = 0 ; int rc2 ; if ( atomic_read ( & set -> set_new_count ) ) { spin_lock ( & set -> set_new_req_lock ) ; if ( likely ( ! list_empty ( & set -> set_new_requests ) ) ) { list_splice_init ( & set -> set_new_requests , & set -> set_requests ) ; atomic_add ( atomic_read ( & set -> set_new_count ) , & set -> set_remaining ) ; atomic_set ( & set -> set_new_count , 0 ) ; rc = 1 ; } spin_unlock ( & set -> set_new_req_lock ) ; } rc2 = lu_env_refill ( env ) ; if ( rc2 != 0 ) { CERROR ( "Failure to refill session: %d\n" , rc2 ) ; return rc ; } if ( atomic_read ( & set -> set_remaining ) ) { rc |= ptlrpc_check_set ( env , set ) ; } list_for_each_safe ( , , ) { req = list_entry ( pos , ptlrpc_request , rq_set_chain ) ; if ( req -> rq_phase != RQ_PHASE_COMPLETE ) { break ; } list_del ( & req -> rq_set_chain ) ; req -> rq_set = NULL ; ptlrpc_req_finished ( req ) ; } if ( rc == 0 ) { rc = atomic_read ( & set -> set_new_count ) ; if ( rc == 0 && pc -> pc_npartners > 0 ) { struct ptlrpcd_ctl * partner ; struct ptlrpc_request_set * ps ; int first = pc -> pc_cursor ; { partner = pc -> pc_partners [ pc -> pc_cursor ++ ] ; if ( pc -> pc_cursor >= pc -> pc_npartners ) { pc -> pc_cursor = 0 ; } if ( ! partner ) { continue ; } spin_lock ( & partner -> pc_lock ) ; ps = partner -> pc_set ; if ( ! ps ) { spin_unlock ( & partner -> pc_lock ) ; continue ; } ptlrpc_reqset_get ( ps ) ; spin_unlock ( & partner -> pc_lock ) ; if ( atomic_read ( & ps -> set_new_count ) ) { rc = ptlrpcd_steal_rqset ( set , ps ) ; if ( rc > 0 ) { CDEBUG ( D_RPCTRACE , "transfer %d async RPCs [%d->%d]\n" , rc , partner -> pc_index , pc -> pc_index ) ; } } ptlrpc_reqset_put ( ps ) ; } rc == 0 && pc -> pc_cursor != first ; } } return rc ; } 