p [ 1 ] = ( seq_number >> 8 ) & 0xFF ; p [ 2 ] = ( seq_number >> 16 ) & 0xFF ; p [ 3 ] = ( seq_number >> 24 ) & 0xFF ; memset ( p + 4 , ( ctx -> more_flags & LOCAL ) ?0 : 0xFF , 4 ) ; EVP_CIPHER_CTX_init ( & des_ctx ) ; EVP_CipherInit_ex ( & des_ctx , EVP_des_cbc ( ) , NULL , key -> keyvalue . data , p + 8 , 1 ) ; EVP_Cipher ( & des_ctx , p , p , 8 ) ; EVP_CIPHER_CTX_cleanup ( & des_ctx ) ; krb5_auth_con_setlocalseqnumber ( context , ctx -> auth_context , ++ seq_number ) ; HEIMDAL_MUTEX_unlock ( & ctx -> ctx_id_mutex ) ; memset_s ( deskey , sizeof ( deskey ) , 0 , sizeof ( deskey ) ) ; memset_s ( & schedule , sizeof ( schedule ) , 0 , sizeof ( schedule ) ) ; * minor_status = 0 ; return GSS_S_COMPLETE ; OM_uint32 mic_des3 ( OM_uint32 * minor_status , const gsskrb5_ctx ctx , krb5_context context , gss_qop_t qop_req , const gss_buffer_t message_buffer , gss_buffer_t message_token , krb5_keyblock * key ) { u_char * p ; Checksum cksum ; u_char seq [ 8 ] ; int32_t seq_number ; size_t len , total_len ; krb5_crypto crypto ; krb5_error_code kret ; krb5_data encdata ; char * tmp ; char ivec [ 8 ] ; _gsskrb5_encap_length ( 36 , & len , & total_len , GSS_KRB5_MECHANISM ) ; message_token -> length = total_len ; message_token -> value = malloc ( total_len ) ; if ( message_token -> value == NULL ) { message_token -> length = 0 ; * minor_status = ENOMEM ; return GSS_S_FAILURE ; } p = _gsskrb5_make_header ( message_token -> value , len , "\x01\x01" , GSS_KRB5_MECHANISM ) ; memcpy ( p , "\x04\x00" , 2 ) ; p += 2 ; memcpy ( p , "\xff\xff\xff\xff" , 4 ) ; p += 4 ; tmp = malloc ( message_buffer -> length + 8 ) ; if ( tmp == NULL ) { message_token -> value = NULL ; message_token -> length = 0 ; * minor_status = ENOMEM ; return GSS_S_FAILURE ; } memcpy ( tmp , p - 8 , 8 ) ; memcpy ( tmp + 8 , message_buffer -> value , message_buffer -> length ) ; kret = krb5_crypto_init ( context , key , 0 , & crypto ) ; if ( kret ) { free ( message_token -> value ) ; message_token -> value = NULL ; message_token -> length = 0 ; free ( tmp ) ; * minor_status = kret ; return GSS_S_FAILURE ; } kret = krb5_create_checksum ( context , crypto , KRB5_KU_USAGE_SIGN , 0 , tmp , message_buffer -> length + 8 , & cksum ) ; free ( tmp ) ; krb5_crypto_destroy ( context , crypto ) ; if ( kret ) { free ( message_token -> value ) ; message_token -> value = NULL ; message_token -> length = 0 ; * minor_status = kret ; return GSS_S_FAILURE ; } memcpy ( p + 8 , cksum . checksum . data , cksum . checksum . length ) ; HEIMDAL_MUTEX_lock ( & ctx -> ctx_id_mutex ) ; krb5_auth_con_getlocalseqnumber ( context , ctx -> auth_context , & seq_number ) ; seq [ 0 ] = ( seq_number >> 0 ) & 0xFF ; seq [ 1 ] = ( seq_number >> 8 ) & 0xFF ; seq [ 2 ] = ( seq_number >> 16 ) & 0xFF ; seq [ 3 ] = ( seq_number >> 24 ) & 0xFF ; memset ( seq + 4 , ( ctx -> more_flags & LOCAL ) ?0 : 0xFF , 4 ) ; kret = krb5_crypto_init ( context , key , ETYPE_DES3_CBC_NONE , & crypto ) ; if ( kret ) { free ( message_token -> value ) ; message_token -> value = NULL ; message_token -> length = 0 ; * minor_status = kret ; return GSS_S_FAILURE ; } if ( ctx -> more_flags & COMPAT_OLD_DES3 ) { memset ( ivec , 0 , 8 ) ; } else { memcpy ( ivec , p + 8 , 8 ) ; } kret = krb5_encrypt_ivec ( context , crypto , KRB5_KU_USAGE_SEQ , seq , 8 , & encdata , ivec ) ; krb5_crypto_destroy ( context , crypto ) ; if ( kret ) { free ( message_token -> value ) ; message_token -> value = NULL ; message_token -> length = 0 ; * minor_status = kret ; return GSS_S_FAILURE ; } assert ( encdata . length == 8 ) ; memcpy ( p , encdata . data , encdata . length ) ; krb5_data_free ( & encdata ) ; krb5_auth_con_setlocalseqnumber ( context , ctx -> auth_context , ++ seq_number ) ; HEIMDAL_MUTEX_unlock ( & ctx -> ctx_id_mutex ) ; free_Checksum ( & cksum ) ; * minor_status = 0 ; return GSS_S_COMPLETE ; } 