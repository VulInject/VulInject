static int recent_mt_check ( const struct xt_mtchk_param * par , const struct xt_recent_mtinfo_v1 * info ) { struct recent_net * recent_net = recent_pernet ( par -> net ) ; struct recent_table * t ; struct proc_dir_entry * pde ; kuid_t uid ; kgid_t gid ; unsigned int nstamp_mask ; int i ; int ret = - EINVAL ; size_t sz ; net_get_random_once ( & hash_rnd , sizeof ( hash_rnd ) ) ; if ( info -> check_set & ~ XT_RECENT_VALID_FLAGS ) { pr_info ( "Unsupported user space flags (%08x)\n" , info -> check_set ) ; return - EINVAL ; } if ( hweight8 ( info -> check_set & ( XT_RECENT_SET | XT_RECENT_REMOVE | XT_RECENT_CHECK | XT_RECENT_UPDATE ) ) != 1 ) { return - EINVAL ; } if ( ( info -> check_set & ( XT_RECENT_SET | XT_RECENT_REMOVE ) ) && ( info -> seconds || info -> hit_count || ( info -> check_set & XT_RECENT_MODIFIERS ) ) ) { return - EINVAL ; } if ( ( info -> check_set & XT_RECENT_REAP ) && ! info -> seconds ) { return - EINVAL ; } if ( info -> hit_count >= XT_RECENT_MAX_NSTAMPS ) { pr_info ( "hitcount (%u) is larger than allowed maximum (%u)\n" , info -> hit_count , XT_RECENT_MAX_NSTAMPS - 1 ) ; return - EINVAL ; } if ( info -> name [ 0 ] == '\0' || strnlen ( info -> name , XT_RECENT_NAME_LEN ) == XT_RECENT_NAME_LEN ) { return - EINVAL ; } if ( ip_pkt_list_tot && info -> hit_count < ip_pkt_list_tot ) { nstamp_mask = roundup_pow_of_two ( ip_pkt_list_tot ) - 1 ; } if ( info -> hit_count ) { nstamp_mask = roundup_pow_of_two ( info -> hit_count ) - 1 ; } else { nstamp_mask = 32 - 1 ; } mutex_lock ( & recent_mutex ) ; t = recent_table_lookup ( recent_net , info -> name ) ; if ( t != NULL ) { if ( nstamp_mask > t -> nstamps_max_mask ) { spin_lock_bh ( & recent_lock ) ; recent_table_flush ( t ) ; t -> nstamps_max_mask = nstamp_mask ; spin_unlock_bh ( & recent_lock ) ; } t -> refcnt ++ ; ret = 0 ; out } sz = sizeof ( * t ) + sizeof ( t -> iphash [ 0 ] ) * ip_list_hash_size ; t = kvzalloc ( sz , GFP_KERNEL ) ; if ( t == NULL ) { ret = - ENOMEM ; out } t -> refcnt = 1 ; t -> nstamps_max_mask = nstamp_mask ; memcpy ( & t -> mask , & info -> mask , sizeof ( t -> mask ) ) ; strcpy ( t -> name , info -> name ) ; INIT_LIST_HEAD ( & t -> lru_list ) ; for ( i = 0 ; i < ip_list_hash_size ; i ++ ) { INIT_LIST_HEAD ( & t -> iphash [ i ] ) ; } uid = make_kuid ( & init_user_ns , ip_list_uid ) ; gid = make_kgid ( & init_user_ns , ip_list_gid ) ; if ( ! uid_valid ( uid ) || ! gid_valid ( gid ) ) { recent_table_free ( t ) ; ret = - EINVAL ; out } pde = proc_create_data ( t -> name , ip_list_perms , recent_net -> xt_recent , & recent_mt_fops , t ) ; if ( pde == NULL ) { recent_table_free ( t ) ; ret = - ENOMEM ; out } proc_set_user ( pde , uid , gid ) ; spin_lock_bh ( & recent_lock ) ; list_add_tail ( & t -> list , & recent_net -> tables ) ; spin_unlock_bh ( & recent_lock ) ; ret = 0 ; out mutex_unlock ( & recent_mutex ) ; return ret ; } 