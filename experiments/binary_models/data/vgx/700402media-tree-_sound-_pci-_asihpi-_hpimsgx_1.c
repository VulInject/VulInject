static void HPIMSGX__cleanup ( u16 adapter_index , void * h_owner ) hpi_subsys_response { struct hpi_response_header h ; struct hpi_subsys_res s ; } hpi_adapter_response { struct hpi_response_header h ; struct hpi_adapter_res a ; } hpi_mixer_response { struct hpi_response_header h ; struct hpi_mixer_res m ; } hpi_stream_response { struct hpi_response_header h ; struct hpi_stream_res d ; } adapter_info { u16 type ; u16 num_instreams ; u16 num_outstreams ; } asi_open_state { int open_flag ; void * h_owner ; } static struct hpi_adapter_response rESP_HPI_ADAPTER_OPEN [ HPI_MAX_ADAPTERS ] ; static struct hpi_stream_response rESP_HPI_OSTREAM_OPEN [ HPI_MAX_ADAPTERS ] [ HPI_MAX_STREAMS ] ; static struct hpi_stream_response rESP_HPI_ISTREAM_OPEN [ HPI_MAX_ADAPTERS ] [ HPI_MAX_STREAMS ] ; static struct hpi_mixer_response rESP_HPI_MIXER_OPEN [ HPI_MAX_ADAPTERS ] ; static struct adapter_info aDAPTER_INFO [ HPI_MAX_ADAPTERS ] ; static struct asi_open_state outstream_user_open [ HPI_MAX_ADAPTERS ] [ HPI_MAX_STREAMS ] ; static struct asi_open_state instream_user_open [ HPI_MAX_ADAPTERS ] [ HPI_MAX_STREAMS ] ; static void subsys_message ( struct hpi_message * phm , struct hpi_response * phr , void * h_owner ) { if ( phm -> adapter_index != HPI_ADAPTER_INDEX_INVALID ) { HPI_DEBUG_LOG ( WARNING , "suspicious adapter index %d in subsys message 0x%x.\n" , phm -> adapter_index , phm -> function ) ; } switch ( phm -> function ) { case HPI_SUBSYS_GET_VERSION : hpi_init_response ( phr , HPI_OBJ_SUBSYSTEM , HPI_SUBSYS_GET_VERSION , 0 ) ; phr -> u . s . version = HPI_VER >> 8 ; phr -> u . s . data = HPI_VER ; break ; case HPI_SUBSYS_OPEN : hpi_init_response ( phr , HPI_OBJ_SUBSYSTEM , HPI_SUBSYS_OPEN , 0 ) ; break ; case HPI_SUBSYS_CLOSE : hpi_init_response ( phr , HPI_OBJ_SUBSYSTEM , HPI_SUBSYS_CLOSE , 0 ) ; HPIMSGX__cleanup ( HPIMSGX_ALLADAPTERS , h_owner ) ; break ; case HPI_SUBSYS_DRIVER_LOAD : hpios_msgxlock_init ( & msgx_lock ) ; HPIMSGX__reset ( HPIMSGX_ALLADAPTERS ) ; hpi_init_response ( phr , HPI_OBJ_SUBSYSTEM , HPI_SUBSYS_DRIVER_LOAD , 0 ) ; HPI_COMMON ( phm , phr ) ; break ; case HPI_SUBSYS_DRIVER_UNLOAD : HPI_COMMON ( phm , phr ) ; HPIMSGX__cleanup ( HPIMSGX_ALLADAPTERS , h_owner ) ; hpi_init_response ( phr , HPI_OBJ_SUBSYSTEM , HPI_SUBSYS_DRIVER_UNLOAD , 0 ) ; return ; case HPI_SUBSYS_GET_NUM_ADAPTERS : case HPI_SUBSYS_GET_ADAPTER : HPI_COMMON ( phm , phr ) ; break ; case HPI_SUBSYS_CREATE_ADAPTER : HPIMSGX__init ( phm , phr ) ; break ; default : hpi_init_response ( phr , HPI_OBJ_SUBSYSTEM , phm -> function , HPI_ERROR_INVALID_FUNC ) ; break ; } } 