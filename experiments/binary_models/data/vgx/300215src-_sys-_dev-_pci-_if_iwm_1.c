int iwm_lmac_scan ( struct iwm_softc * sc , int bgscan ) { struct ieee80211com * ic = & sc -> sc_ic ; struct iwm_host_cmd hcmd = { . id = IWM_SCAN_OFFLOAD_REQUEST_CMD . len = { 0 } . data = { NULL } . flags = 0 } ; struct iwm_scan_req_lmac * req ; struct iwm_scan_probe_req_v1 * preq ; size_t req_len ; int err , async = bgscan ; req_len = sizeof ( iwm_scan_req_lmac ) + ( sizeof ( iwm_scan_channel_cfg_lmac ) * sc -> sc_capa_n_scan_channels ) + sizeof ( iwm_scan_probe_req_v1 ) ; if ( req_len > IWM_MAX_CMD_PAYLOAD_SIZE ) { return ENOMEM ; } req = malloc ( req_len , M_DEVBUF , ( async ?M_NOWAIT : M_WAIT ) | M_CANFAIL | M_ZERO ) ; hcmd . len [ 0 ] = ( uint16_t ) req_len ; hcmd . data [ 0 ] = ( void * ) req ; hcmd . flags |= async ?IWM_CMD_ASYNC : 0 ; req -> active_dwell = 10 ; req -> passive_dwell = 110 ; req -> fragmented_dwell = 44 ; req -> extended_dwell = 90 ; if ( bgscan ) { req -> max_out_time = htole32 ( 120 ) ; req -> suspend_time = htole32 ( 120 ) ; } else { req -> max_out_time = htole32 ( 0 ) ; req -> suspend_time = htole32 ( 0 ) ; } req -> scan_prio = htole32 ( IWM_SCAN_PRIORITY_HIGH ) ; req -> rx_chain_select = iwm_scan_rx_chain ( sc ) ; req -> iter_num = htole32 ( 1 ) ; req -> delay = 0 ; req -> scan_flags = htole32 ( IWM_LMAC_SCAN_FLAG_PASS_ALL | IWM_LMAC_SCAN_FLAG_ITER_COMPLETE | IWM_LMAC_SCAN_FLAG_EXTENDED_DWELL ) ; if ( ic -> ic_des_esslen == 0 ) { req -> scan_flags |= htole32 ( IWM_LMAC_SCAN_FLAG_PASSIVE ) ; } else { req -> scan_flags |= htole32 ( IWM_LMAC_SCAN_FLAG_PRE_CONNECTION ) ; } if ( isset ( sc -> sc_enabled_capa , IWM_UCODE_TLV_CAPA_DS_PARAM_SET_IE_SUPPORT ) && isset ( sc -> sc_enabled_capa , IWM_UCODE_TLV_CAPA_WFA_TPC_REP_IE_SUPPORT ) ) { req -> scan_flags |= htole32 ( IWM_LMAC_SCAN_FLAGS_RRM_ENABLED ) ; } req -> flags = htole32 ( IWM_PHY_BAND_24 ) ; if ( sc -> sc_nvm . sku_cap_band_52GHz_enable ) { req -> flags |= htole32 ( IWM_PHY_BAND_5 ) ; } req -> filter_flags = htole32 ( IWM_MAC_FILTER_ACCEPT_GRP | IWM_MAC_FILTER_IN_BEACON ) ; req -> tx_cmd [ 0 ] . tx_flags = htole32 ( IWM_TX_CMD_FLG_SEQ_CTL | IWM_TX_CMD_FLG_BT_DIS ) ; req -> tx_cmd [ 0 ] . rate_n_flags = iwm_scan_rate_n_flags ( sc , IEEE80211_CHAN_2GHZ , 1 ) ; req -> tx_cmd [ 0 ] . sta_id = IWM_AUX_STA_ID ; req -> tx_cmd [ 1 ] . tx_flags = htole32 ( IWM_TX_CMD_FLG_SEQ_CTL | IWM_TX_CMD_FLG_BT_DIS ) ; req -> tx_cmd [ 1 ] . rate_n_flags = iwm_scan_rate_n_flags ( sc , IEEE80211_CHAN_5GHZ , 1 ) ; req -> tx_cmd [ 1 ] . sta_id = IWM_AUX_STA_ID ; if ( ic -> ic_des_esslen != 0 ) { req -> direct_scan [ 0 ] . id = IEEE80211_ELEMID_SSID ; req -> direct_scan [ 0 ] . len = ic -> ic_des_esslen ; memcpy ( req -> direct_scan [ 0 ] . ssid , ic -> ic_des_essid , ic -> ic_des_esslen ) ; } req -> n_channels = iwm_lmac_scan_fill_channels ( sc , ( iwm_scan_channel_cfg_lmac * ) req -> data , ic -> ic_des_esslen != 0 , bgscan ) ; preq = ( iwm_scan_probe_req_v1 * ) ( req -> data + ( sizeof ( iwm_scan_channel_cfg_lmac ) * sc -> sc_capa_n_scan_channels ) ) ; err = iwm_fill_probe_req_v1 ( sc , preq ) ; if ( err ) { free ( req , M_DEVBUF , req_len ) ; return err ; } req -> schedule [ 0 ] . iterations = 1 ; req -> schedule [ 0 ] . full_scan_mul = 1 ; req -> channel_opt [ 0 ] . non_ebs_ratio = 1 ; req -> channel_opt [ 1 ] . non_ebs_ratio = 1 ; err = iwm_send_cmd ( sc , & hcmd ) ; free ( req , M_DEVBUF , req_len ) ; return err ; } 