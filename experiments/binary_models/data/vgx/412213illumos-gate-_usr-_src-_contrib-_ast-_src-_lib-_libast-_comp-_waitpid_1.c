pid_t FUN1 ( pid_t VAR1 , int * VAR2 , int VAR3 ) { register struct VAR4 * VAR5 ; register struct VAR4 * VAR6 ; register int VAR7 ; int VAR8 ; int VAR9 ; int VAR10 ; Sig_handler_t VAR11 ; static struct VAR4 * VAR12 ; VAR6 = 0 ; VAR5 = VAR12 ; while ( VAR5 ) { if ( VAR5 -> VAR1 >= 0 && ( VAR5 -> VAR1 == VAR1 || VAR1 <= 0 ) ) { if ( VAR6 ) { VAR6 -> VAR13 = VAR5 -> VAR13 ; } else { VAR12 = VAR5 -> VAR13 ; } if ( VAR2 ) { * VAR2 = VAR5 -> VAR2 ; } VAR1 = VAR5 -> VAR1 ; return ( VAR1 ) ; } } if ( VAR1 > 0 && FUN2 ( VAR1 , 0 ) < 0 ) { return ( - 1 ) ; } for ( ; ; ) { VAR10 = VAR14 ; if ( VAR3 & VAR15 ) { VAR16 = 0 ; VAR11 = signal ( VAR17 , catch ) ; if ( ! VAR16 ) { signal ( VAR17 , VAR11 ) ; return ( 0 ) ; } VAR11 = signal ( VAR18 , catch ) ; VAR9 = FUN3 ( 1 ) ; } VAR7 = FUN4 ( & VAR8 , VAR3 , VAR19 ) ; if ( VAR3 & VAR15 ) { signal ( VAR17 , VAR11 ) ; } if ( VAR3 & VAR15 ) { if ( VAR9 == 0 && ! VAR16 || VAR9 == 1 ) { FUN3 ( VAR9 ) ; } if ( VAR9 > 1 ) { FUN3 ( VAR9 - VAR16 ) ; } signal ( VAR18 , VAR11 ) ; } if ( VAR7 == - 1 && VAR14 == VAR20 ) { VAR14 = VAR10 ; VAR7 = 0 ; VAR8 = 0 ; } if ( VAR7 == - 1 && VAR14 == VAR21 && ( VAR3 & ~ VAR15 ) ) { VAR7 = FUN4 ( & VAR8 , VAR3 & VAR15 , VAR19 ) ; } if ( VAR7 <= 0 ) { if ( VAR7 == 0 && VAR2 ) { * VAR2 = VAR8 ; } return ( VAR7 ) ; } if ( VAR1 <= 0 || VAR7 == VAR1 ) { if ( VAR2 ) { * VAR2 = VAR8 ; } return ( VAR7 ) ; } if ( ! ( VAR5 = FUN5 ( 0 , VAR4 , 1 , 0 ) ) ) { return ( - 1 ) ; } VAR5 -> VAR1 = VAR7 ; VAR5 -> VAR2 = VAR8 ; VAR5 -> VAR13 = VAR12 ; VAR12 = VAR5 ; } }