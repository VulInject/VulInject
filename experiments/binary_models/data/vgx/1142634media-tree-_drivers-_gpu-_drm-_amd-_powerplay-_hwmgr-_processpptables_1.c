static int get_cac_leakage_table ( struct pp_hwmgr * hwmgr , struct phm_cac_leakage_table * * ptable , const ATOM_PPLIB_CAC_Leakage_Table * table ) { struct phm_cac_leakage_table * cac_leakage_table ; unsigned long table_size , i ; if ( hwmgr == NULL || table == NULL || ptable == NULL ) { return - EINVAL ; } table_size = sizeof ( ULONG ) + ( sizeof ( phm_cac_leakage_table ) * table -> ucNumEntries ) ; cac_leakage_table = kmalloc ( table_size , GFP_KERNEL ) ; if ( cac_leakage_table == NULL ) { return - ENOMEM ; } cac_leakage_table -> count = ( ULONG ) table -> ucNumEntries ; for ( i = 0 ; i < cac_leakage_table -> count ; i ++ ) { if ( phm_cap_enabled ( hwmgr -> platform_descriptor . platformCaps , PHM_PlatformCaps_EVV ) ) { cac_leakage_table -> entries [ i ] . Vddc1 = le16_to_cpu ( table -> entries [ i ] . usVddc1 ) ; cac_leakage_table -> entries [ i ] . Vddc2 = le16_to_cpu ( table -> entries [ i ] . usVddc2 ) ; cac_leakage_table -> entries [ i ] . Vddc3 = le16_to_cpu ( table -> entries [ i ] . usVddc3 ) ; } else { cac_leakage_table -> entries [ i ] . Vddc = le16_to_cpu ( table -> entries [ i ] . usVddc ) ; cac_leakage_table -> entries [ i ] . Leakage = le32_to_cpu ( table -> entries [ i ] . ulLeakageValue ) ; } } * ptable = cac_leakage_table ; return 0 ; } 