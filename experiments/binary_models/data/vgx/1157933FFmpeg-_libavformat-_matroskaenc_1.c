static int mkv_write_chapters ( AVFormatContext * s ) { MatroskaMuxContext * mkv = s -> priv_data ; AVIOContext * dyn_cp = NULL , * dyn_tags = NULL , * * tags , * pb = s -> pb ; ebml_master editionentry ; AVRational scale = { 1 1E9 } ; int ret , create_new_ids ; ret = start_ebml_master_crc32 ( & dyn_cp , mkv ) ; if ( ret < 0 ) { return ret ; } editionentry = start_ebml_master ( dyn_cp , MATROSKA_ID_EDITIONENTRY , 0 ) ; if ( ! IS_WEBM ( mkv ) ) { put_ebml_uint ( dyn_cp , MATROSKA_ID_EDITIONFLAGDEFAULT , 1 ) ; tags = mkv -> wrote_tags ?& dyn_tags : & mkv -> tags . bc ; } else { tags = NULL ; } create_new_ids = mkv_new_chapter_ids_needed ( s ) ; for ( unsigned i = 0 ; i < s -> nb_chapters ; i ++ ) { AVChapter * const c = s -> chapters [ i ] ; int64_t chapterstart = av_rescale_q ( c -> start , c -> time_base , scale ) ; int64_t chapterend = av_rescale_q ( c -> end , c -> time_base , scale ) ; const AVDictionaryEntry * t ; uint64_t uid = create_new_ids ?i + 1ULL : c -> id ; EBML_WRITER ( 7 ) ; if ( chapterstart ( 0 || chapterstart ) chapterend || chapterend < 0 ) { av_log ( s , AV_LOG_ERROR , "Invalid chapter start (%" PRId64 ") or end (%" PRId64 ").\n" , chapterstart , chapterend ) ; ret = AVERROR_INVALIDDATA ; fail } ebml_writer_open_master ( & writer , MATROSKA_ID_CHAPTERATOM ) ; ebml_writer_add_uint ( & writer , MATROSKA_ID_CHAPTERUID , uid ) ; ebml_writer_add_uint ( & writer , MATROSKA_ID_CHAPTERTIMESTART , chapterstart ) ; ebml_writer_add_uint ( & writer , MATROSKA_ID_CHAPTERTIMEEND , chapterend ) ; if ( ( t = av_dict_get ( c -> metadata , "title" , NULL , 0 ) ) ) { ebml_writer_open_master ( & writer , MATROSKA_ID_CHAPTERDISPLAY ) ; ebml_writer_add_string ( & writer , MATROSKA_ID_CHAPSTRING , t -> value ) ; ebml_writer_add_string ( & writer , MATROSKA_ID_CHAPLANG , "und" ) ; } ret = ebml_writer_write ( & writer , dyn_cp ) ; if ( ret < 0 ) { fail } if ( tags ) { ff_metadata_conv ( & c -> metadata , ff_mkv_metadata_conv , NULL ) ; ret = mkv_write_tag ( mkv , c -> metadata , tags , 0 , MATROSKA_ID_TAGTARGETS_CHAPTERUID , uid ) ; if ( ret < 0 ) { fail } } } end_ebml_master ( dyn_cp , editionentry ) ; mkv -> wrote_chapters = 1 ; ret = end_ebml_master_crc32 ( pb , & dyn_cp , mkv , MATROSKA_ID_CHAPTERS , 0 , 0 , 1 ) ; if ( ret < 0 ) { fail } if ( dyn_tags ) { return end_ebml_master_crc32 ( pb , & dyn_tags , mkv , MATROSKA_ID_TAGS , 0 , 0 , 1 ) ; } return 0 ; fail if ( tags ) { ffio_free_dyn_buf ( tags ) ; } ffio_free_dyn_buf ( & dyn_cp ) ; return ret ; } 