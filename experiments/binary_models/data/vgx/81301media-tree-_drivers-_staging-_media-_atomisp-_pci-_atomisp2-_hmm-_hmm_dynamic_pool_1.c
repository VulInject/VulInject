static unsigned int get_pages_from_dynamic_pool ( void * pool , struct hmm_page_object * page_obj , unsigned int size , bool cached ) { struct hmm_page * hmm_page ; cfs_time_t flags ; unsigned int i = 0 ; struct hmm_dynamic_pool_info * dypool_info = pool ; if ( ! dypool_info ) { return 0 ; } spin_lock_irqsave ( & dypool_info -> list_lock , flags ) ; if ( dypool_info -> initialized ) { while ( ! list_empty ( & dypool_info -> pages_list ) ) { hmm_page = list_entry ( dypool_info -> pages_list . next , hmm_page , list ) ; list_del ( & hmm_page -> list ) ; dypool_info -> pgnr -- ; spin_unlock_irqrestore ( & dypool_info -> list_lock , flags ) ; page_obj [ i ] . page = hmm_page -> page ; page_obj [ i ++ ] . type = HMM_PAGE_TYPE_DYNAMIC ; kmem_cache_free ( dypool_info -> pgptr_cache , hmm_page ) ; if ( i == size ) { return i ; } spin_lock_irqsave ( & dypool_info -> list_lock , flags ) ; } } spin_unlock_irqrestore ( & dypool_info -> list_lock , flags ) ; return i ; } 