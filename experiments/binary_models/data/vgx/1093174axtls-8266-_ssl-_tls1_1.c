int send_packet ( SSL * ssl , uint8_t protocol , const uint8_t * in , int length ) { int ret , msg_length = 0 ; if ( ssl -> hs_status == SSL_ERROR_DEAD ) { return SSL_ERROR_CONN_LOST ; } if ( IS_SET_SSL_FLAG ( SSL_SENT_CLOSE_NOTIFY ) ) { return SSL_CLOSE_NOTIFY ; } if ( in ) { memcpy ( ssl -> bm_data , in , length ) ; } msg_length += length ; if ( IS_SET_SSL_FLAG ( SSL_TX_ENCRYPTED ) ) { int mode = IS_SET_SSL_FLAG ( SSL_IS_CLIENT ) ?SSL_CLIENT_WRITE : SSL_SERVER_WRITE ; uint8_t hmac_header [ SSL_RECORD_SIZE ] { protocol 0x03 ssl -> version & 0x0f msg_length >> 8 msg_length & 0xff } ; ; if ( protocol == PT_HANDSHAKE_PROTOCOL ) { DISPLAY_STATE ( ssl , 1 , ssl -> bm_data [ 0 ] , 0 ) ; if ( ssl -> bm_data [ 0 ] != HS_HELLO_REQUEST ) { add_packet ( ssl , ssl -> bm_data , msg_length ) ; } } add_hmac_digest ( ssl , mode , hmac_header , ssl -> bm_data , msg_length , & ssl -> bm_data [ msg_length ] ) ; msg_length += ssl -> cipher_info -> digest_size ; { int last_blk_size = msg_length % ssl -> cipher_info -> padding_size ; int pad_bytes = ssl -> cipher_info -> padding_size - last_blk_size ; if ( pad_bytes == 0 ) { pad_bytes += ssl -> cipher_info -> padding_size ; } memset ( & ssl -> bm_data [ msg_length ] , pad_bytes - 1 , pad_bytes ) ; msg_length += pad_bytes ; } DISPLAY_BYTES ( ssl , PSTR ( "unencrypted write" ) , ssl -> bm_data , msg_length ) ; increment_write_sequence ( ssl ) ; if ( ssl -> version >= SSL_PROTOCOL_VERSION_TLS1_1 ) { uint8_t iv_size = ssl -> cipher_info -> iv_size ; uint8_t * t_buf = malloc ( msg_length + iv_size ) ; memcpy ( t_buf + iv_size , ssl -> bm_data , msg_length ) ; if ( get_random ( iv_size , t_buf ) < 0 ) { return SSL_NOT_OK ; } msg_length += iv_size ; memcpy ( ssl -> bm_data , t_buf , msg_length ) ; } ssl -> cipher_info -> encrypt ( ssl -> encrypt_ctx , ssl -> bm_data , ssl -> bm_data , msg_length ) ; } if ( protocol == PT_HANDSHAKE_PROTOCOL ) { DISPLAY_STATE ( ssl , 1 , ssl -> bm_data [ 0 ] , 0 ) ; if ( ssl -> bm_data [ 0 ] != HS_HELLO_REQUEST ) { add_packet ( ssl , ssl -> bm_data , length ) ; } } ssl -> bm_index = msg_length ; if ( ( ret = send_raw_packet ( ssl , protocol ) ) <= 0 ) { return ret ; } return length ; } 