int mbedtls_ctr_drbg_random_with_add ( void * p_rng , unsigned char * output , size_t output_len , const unsigned char * additional , size_t add_len ) { int ret = 0 ; mbedtls_ctr_drbg_context * ctx = ( mbedtls_ctr_drbg_context * ) p_rng ; unsigned char add_input [ MBEDTLS_CTR_DRBG_SEEDLEN ] ; unsigned char * p = output ; unsigned char tmp [ MBEDTLS_CTR_DRBG_BLOCKSIZE ] ; int i ; size_t use_len ; if ( add_len > MBEDTLS_CTR_DRBG_MAX_INPUT ) { return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG ; } memset ( add_input , 0 , MBEDTLS_CTR_DRBG_SEEDLEN ) ; if ( ctx -> reseed_counter > ctx -> reseed_interval || ctx -> prediction_resistance ) { if ( ( ret = mbedtls_ctr_drbg_reseed ( ctx , additional , add_len ) ) != 0 ) { return ret ; } add_len = 0 ; } if ( add_len > 0 ) { if ( ( ret = block_cipher_df ( add_input , additional , add_len ) ) != 0 ) { exit } if ( ( ret = ctr_drbg_update_internal ( ctx , add_input ) ) != 0 ) { exit } } while ( output_len > 0 ) { for ( i = MBEDTLS_CTR_DRBG_BLOCKSIZE ; i > 0 ; i -- ) { if ( ++ ctx -> counter [ i - 1 ] != 0 ) { break ; } } if ( ( ret = mbedtls_aes_crypt_ecb ( & ctx -> aes_ctx , MBEDTLS_AES_ENCRYPT , ctx -> counter , tmp ) ) != 0 ) { exit } use_len = ( output_len > MBEDTLS_CTR_DRBG_BLOCKSIZE ) ?MBEDTLS_CTR_DRBG_BLOCKSIZE : output_len ; memcpy ( p , tmp , use_len ) ; p += use_len ; output_len -= use_len ; } if ( ( ret = ctr_drbg_update_internal ( ctx , add_input ) ) != 0 ) { exit } ctx -> reseed_counter ++ ; exit mbedtls_platform_zeroize ( add_input , sizeof ( add_input ) ) ; mbedtls_platform_zeroize ( tmp , sizeof ( tmp ) ) ; return ret ; } 