static skiplistnode * skiplist_new_node ( skiplist * list , int node_levels ) { skiplistnode * newnode = NULL ; register int x = 0 ; if ( node_levels ( 0 || node_levels ) list -> max_levels ) { return NULL ; } if ( ( newnode = ( skiplistnode * ) malloc ( sizeof ( skiplistnode ) + ( node_levels * sizeof ( skiplistnode * ) ) ) ) ) { for ( x = 0 ; x < node_levels ; x ++ ) { newnode -> forward [ x ] = NULL ; } newnode -> data = NULL ; } return newnode ; } skiplist * skiplist_new ( int max_levels , float level_probability , int allow_duplicates , int append_duplicates , int * compare_function ( void * , void * ) ) { skiplist * newlist = NULL ; if ( ( newlist = ( skiplist * ) malloc ( sizeof ( skiplist ) ) ) ) { newlist -> current_level = 0 ; newlist -> max_levels = max_levels ; newlist -> level_probability = level_probability ; newlist -> allow_duplicates = allow_duplicates ; newlist -> append_duplicates = append_duplicates ; newlist -> items = 0 ; newlist -> compare_function = compare_function ; newlist -> head = skiplist_new_node ( newlist , max_levels ) ; } return newlist ; } static int skiplist_random_level ( skiplist * list ) { int level = 0 ; float r = 0.0 ; if ( list == NULL ) { return - 1 ; } for ( level = 0 ; level < list -> max_levels ; level ++ ) { r = ( ( float ) rand ( ) / ( float ) RAND_MAX ) ; if ( r > list -> level_probability ) { break ; } } return ( level >= list -> max_levels ) ?list -> max_levels - 1 : level ; } int skiplist_insert ( skiplist * list , void * data ) { skiplistnode * * update = NULL ; skiplistnode * thisnode = NULL ; skiplistnode * nextnode = NULL ; skiplistnode * newnode = NULL ; int level = 0 ; int x = 0 ; if ( list == NULL || data == NULL ) { return SKIPLIST_ERROR_ARGS ; } if ( list -> allow_duplicates == FALSE ) { if ( skiplist_find_first ( list , data , NULL ) ) { return SKIPLIST_ERROR_DUPLICATE ; } } if ( ( update = ( skiplistnode * * ) malloc ( sizeof ( skiplistnode * ) * list -> max_levels ) ) == NULL ) { return SKIPLIST_ERROR_MEMORY ; } for ( x = 0 ; x < list -> max_levels ; x ++ ) { update [ x ] = NULL ; } thisnode = list -> head ; for ( level = list -> current_level ; level >= 0 ; level -- ) { while ( ( nextnode = thisnode -> forward [ level ] ) ) { if ( list -> append_duplicates == TRUE ) { if ( list -> compare_function ( nextnode -> data , data ) > 0 ) { break ; } } else { if ( list -> compare_function ( nextnode -> data , data ) >= 0 ) { break ; } } thisnode = nextnode ; } update [ level ] = thisnode ; } level = skiplist_random_level ( list ) ; if ( level > list -> current_level ) { list -> current_level ++ ; level = list -> current_level ; update [ level ] = list -> head ; } if ( ( newnode = skiplist_new_node ( list , level ) ) == NULL ) { free ( update ) ; return SKIPLIST_ERROR_MEMORY ; } newnode -> data = data ; { thisnode = update [ level ] ; newnode -> forward [ level ] = thisnode -> forward [ level ] ; thisnode -> forward [ level ] = newnode ; } -- level >= 0 ; list -> items ++ ; free ( update ) ; return SKIPLIST_OK ; } int skiplist_empty ( skiplist * list ) { skiplistnode * this = NULL ; skiplistnode * next = NULL ; int level = 0 ; if ( list == NULL ) { return ERROR ; } for ( this = list -> head -> forward [ 0 ] ; this != NULL ; this = next ) { next = this -> forward [ 0 ] ; free ( this ) ; } for ( level = list -> current_level ; level >= 0 ; level -- ) { list -> head -> forward [ level ] = NULL ; } list -> current_level = 0 ; list -> items = 0 ; return OK ; } int skiplist_free ( skiplist * * list ) { skiplistnode * this = NULL ; skiplistnode * next = NULL ; if ( list == NULL ) { return ERROR ; } if ( * list == NULL ) { return OK ; } for ( this = ( * list ) -> head ; this != NULL ; this = next ) { next = this -> forward [ 0 ] ; free ( this ) ; } free ( * list ) ; * list = NULL ; return OK ; } void * skiplist_peek ( skiplist * list ) { if ( list == NULL ) { return NULL ; } return list -> head -> forward [ 0 ] -> data ; } void * skiplist_pop ( skiplist * list ) { skiplistnode * thisnode = NULL ; void * data = NULL ; int level = 0 ; if ( list == NULL ) { return NULL ; } thisnode = list -> head -> forward [ 0 ] ; if ( thisnode == NULL ) { return NULL ; } data = thisnode -> data ; for ( level = 0 ; level <= list -> current_level ; level ++ ) { if ( list -> head -> forward [ level ] == thisnode ) { list -> head -> forward [ level ] = thisnode -> forward [ level ] ; } } free ( thisnode ) ; list -> items -- ; return data ; } void * skiplist_get_first ( skiplist * list , void * * node_ptr ) { skiplistnode * thisnode = NULL ; if ( list == NULL ) { return NULL ; } thisnode = list -> head -> forward [ 0 ] ; if ( node_ptr ) { * node_ptr = ( void * ) thisnode ; } if ( thisnode ) { return thisnode -> data ; } else { return NULL ; } } void * skiplist_get_next ( void * * node_ptr ) { skiplistnode * thisnode = NULL ; skiplistnode * nextnode = NULL ; if ( node_ptr == NULL || * node_ptr == NULL ) { return NULL ; } thisnode = ( skiplistnode * ) ( * node_ptr ) ; nextnode = thisnode -> forward [ 0 ] ; * node_ptr = ( void * ) nextnode ; if ( nextnode ) { return nextnode -> data ; } else { return NULL ; } } void * skiplist_find_first ( skiplist * list , void * data , void * * node_ptr ) { skiplistnode * thisnode = NULL ; skiplistnode * nextnode = NULL ; int level = 0 ; if ( list == NULL || data == NULL ) { return NULL ; } thisnode = list -> head ; for ( level = list -> current_level ; level >= 0 ; level -- ) { while ( ( nextnode = thisnode -> forward [ level ] ) ) { if ( list -> compare_function ( nextnode -> data , data ) >= 0 ) { break ; } thisnode = nextnode ; } } if ( nextnode && list -> compare_function ( nextnode -> data , data ) == 0 ) { if ( node_ptr ) { * node_ptr = ( void * ) nextnode ; } return nextnode -> data ; } else { if ( node_ptr ) { * node_ptr = NULL ; } } return NULL ; } void * skiplist_find_next ( skiplist * list , void * data , void * * node_ptr ) { skiplistnode * thisnode = NULL ; skiplistnode * nextnode = NULL ; if ( list == NULL || data == NULL || node_ptr == NULL ) { return NULL ; } if ( * node_ptr == NULL ) { return NULL ; } thisnode = ( skiplistnode * ) ( * node_ptr ) ; nextnode = thisnode -> forward [ 0 ] ; if ( nextnode ) { if ( list -> compare_function ( nextnode -> data , data ) == 0 ) { * node_ptr = ( void * ) nextnode ; return nextnode -> data ; } } * node_ptr = NULL ; return NULL ; } int skiplist_delete_first ( skiplist * list , void * data ) { skiplistnode * * update = NULL ; skiplistnode * thisnode = NULL ; skiplistnode * nextnode = NULL ; int level = 0 ; int top_level = 0 ; int deleted = FALSE ; int x = 0 ; if ( list == NULL || data == NULL ) { return ERROR ; } if ( ( update = ( skiplistnode * * ) malloc ( sizeof ( skiplistnode * ) * list -> max_levels ) ) == NULL ) { return ERROR ; } for ( x = 0 ; x < list -> max_levels ; x ++ ) { update [ x ] = NULL ; } thisnode = list -> head ; for ( top_level = level = list -> current_level ; level >= 0 ; level -- ) { while ( ( nextnode = thisnode -> forward [ level ] ) ) { if ( list -> compare_function ( nextnode -> data , data ) >= 0 ) { break ; } thisnode = nextnode ; } update [ level ] = thisnode ; } if ( list -> compare_function ( nextnode -> data , data ) == 0 ) { for ( level = 0 ; level <= top_level ; level ++ ) { thisnode = update [ level ] ; if ( thisnode -> forward [ level ] != nextnode ) { break ; } thisnode -> forward [ level ] = nextnode -> forward [ level ] ; } free ( nextnode ) ; while ( list -> head -> forward [ top_level ] == NULL && top_level > 0 ) { top_level -- ; } list -> current_level = top_level ; list -> items -- ; deleted = TRUE ; } free ( update ) ; return deleted ; } int skiplist_delete ( skiplist * list , void * data ) { int deleted = 0 ; int total_deleted = 0 ; while ( ( deleted = skiplist_delete_first ( list , data ) ) == 1 ) { total_deleted ++ ; } return total_deleted ; } int skiplist_delete_node ( skiplist * list , void * node_ptr ) { void * data = NULL ; skiplistnode * * update = NULL ; skiplistnode * thenode = NULL ; skiplistnode * thisnode = NULL ; skiplistnode * nextnode = NULL ; int level = 0 ; int top_level = 0 ; int deleted = FALSE ; int x = 0 ; if ( list == NULL || node_ptr == NULL ) { return ERROR ; } thenode = ( skiplistnode * ) node_ptr ; data = thenode -> data ; if ( ( update = ( skiplistnode * * ) malloc ( sizeof ( skiplistnode * ) * list -> max_levels ) ) == NULL ) { return ERROR ; } for ( x = 0 ; x < list -> max_levels ; x ++ ) { update [ x ] = NULL ; } thisnode = list -> head ; for ( top_level = level = list -> current_level ; level >= 0 ; level -- ) { while ( ( nextnode = thisnode -> forward [ level ] ) ) { if ( list -> compare_function ( nextnode -> data , data ) > 0 ) { break ; } if ( list -> compare_function ( nextnode -> data , data ) == 0 && nextnode == thenode ) { break ; } thisnode = nextnode ; } update [ level ] = thisnode ; } if ( nextnode && list -> compare_function ( nextnode -> data , data ) == 0 && nextnode == thenode ) { for ( level = 0 ; level <= top_level ; level ++ ) { thisnode = update [ level ] ; if ( thisnode -> forward [ level ] != nextnode ) { break ; } thisnode -> forward [ level ] = nextnode -> forward [ level ] ; } free ( nextnode ) ; while ( list -> head -> forward [ top_level ] == NULL && top_level > 0 ) { top_level -- ; } list -> current_level = top_level ; list -> items -- ; deleted = TRUE ; } free ( update ) ; return deleted ; } 