ogg_uint32_t * _make_words ( char * l , long n , long sparsecount ) { long i , j , count = 0 ; ogg_uint32_t marker [ 33 ] ; ogg_uint32_t * r = _ogg_malloc ( ( sparsecount ?sparsecount : n ) * sizeof ( * r ) ) ; for ( i = 0 ; i < n ; i ++ ) { long length = l [ i ] ; if ( length > 0 ) { ogg_uint32_t entry = marker [ length ] ; if ( length < 32 && ( entry >> length ) ) { _ogg_free ( r ) ; return ( NULL ) ; } r [ count ++ ] = entry ; { for ( j = length ; j > 0 ; j -- ) { if ( marker [ j ] & 1 ) { if ( j == 1 ) { marker [ 1 ] ++ ; } else { marker [ j ] = marker [ j - 1 ] << 1 ; } break ; } marker [ j ] ++ ; } } for ( j = length + 1 ; j < 33 ; j ++ ) { if ( ( marker [ j ] >> 1 ) == entry ) { entry = marker [ j ] ; marker [ j ] = marker [ j - 1 ] << 1 ; } else { break ; } } } if ( sparsecount == 0 ) { count ++ ; } } if ( ! ( count == 1 && marker [ 2 ] == 2 ) ) { for ( i = 1 ; i < 33 ; i ++ ) { if ( marker [ i ] & ( 0xffffffffUL >> ( 32 - i ) ) ) { _ogg_free ( r ) ; return ( NULL ) ; } } } for ( i = 0 , count = 0 ; i < n ; i ++ ) { ogg_uint32_t temp = 0 ; for ( j = 0 ; j < l [ i ] ; j ++ ) { temp <<= 1 ; temp |= ( r [ count ] >> j ) & 1 ; } if ( sparsecount ) { if ( l [ i ] ) { r [ count ++ ] = temp ; } } else { r [ count ++ ] = temp ; } } return ( r ) ; } 