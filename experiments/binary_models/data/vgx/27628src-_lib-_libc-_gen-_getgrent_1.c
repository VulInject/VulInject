static int grscan ( int search , gid_t gid , const char * name , struct group * p_gr , struct group_storage * gs , int * foundyp ) { char * cp , * * m ; char * bp , * endp ; u_long ul ; char * key , * data ; int keylen , datalen ; int r ; char * * members ; char * line ; int saved_errno ; if ( gs == NULL ) { return 0 ; } members = gs -> members ; line = gs -> line ; saved_errno = errno ; for ( ; ; ) { if ( __ypmode ) { if ( __ypcurrent ) { r = yp_next ( __ypdomain , "group.byname" , __ypcurrent , __ypcurrentlen , & key , & keylen , & data , & datalen ) ; __ypcurrent = key ; __ypcurrentlen = keylen ; } else { r = yp_first ( __ypdomain , "group.byname" , & __ypcurrent , & __ypcurrentlen , & data , & datalen ) ; } if ( r ) { __ypmode = 0 ; __ypcurrent = NULL ; if ( r == YPERR_NOMORE ) { continue ; } else { return 0 ; } } bcopy ( data , line , datalen ) ; free ( data ) ; line [ datalen ] = '\0' ; bp = line ; parse } if ( ! fgets ( line , sizeof ( gs -> line ) , _gr_fp ) ) { if ( feof ( _gr_fp ) && ! ferror ( _gr_fp ) ) { errno = saved_errno ; } return 0 ; } bp = line ; if ( ! strchr ( line , '\n' ) ) { int ch ; while ( ( ch = getc_unlocked ( _gr_fp ) ) != '\n' && ch != EOF ) { } continue ; } if ( line [ 0 ] == '+' || line [ 0 ] == '-' ) { if ( ! __ypdomain ) { yp_get_default_domain ( & __ypdomain ) ; } } if ( line [ 0 ] == '+' ) { switch ( line [ 1 ] ) { case ':' : case '\0' : case '\n' : if ( foundyp ) { * foundyp = 1 ; errno = saved_errno ; return 0 ; } if ( ! search ) { __ypmode = 1 ; continue ; } if ( name ) { r = yp_match ( __ypdomain , "group.byname" , name , strlen ( name ) , & data , & datalen ) ; } else { char buf [ 20 ] ; snprintf ( buf , sizeof buf , "%u" , gid ) ; r = yp_match ( __ypdomain , "group.bygid" , buf , strlen ( buf ) , & data , & datalen ) ; } switch ( r ) { case 0 : break ; case YPERR_KEY : continue ; default : return 0 ; } bcopy ( data , line , datalen ) ; free ( data ) ; line [ datalen ] = '\0' ; bp = line ; p_gr -> gr_name = strsep ( & bp , ":\n" ) ; if ( __ypexclude_is ( & __ypexhead , p_gr -> gr_name ) ) { continue ; } p_gr -> gr_passwd = strsep ( & bp , ":\n" ) ; if ( ! ( cp = strsep ( & bp , ":\n" ) ) ) { continue ; } if ( name ) { ul = strtoul ( cp , & endp , 10 ) ; if ( * endp != '\0' || endp == cp || ul >= GID_MAX ) { continue ; } p_gr -> gr_gid = ul ; } else { p_gr -> gr_gid = gid ; } found_it default : bp = strsep ( & bp , ":\n" ) + 1 ; if ( ( search && name && strcmp ( bp , name ) ) || __ypexclude_is ( & __ypexhead , bp ) ) { continue ; } r = yp_match ( __ypdomain , "group.byname" , bp , strlen ( bp ) , & data , & datalen ) ; switch ( r ) { case 0 : break ; case YPERR_KEY : continue ; default : return 0 ; } bcopy ( data , line , datalen ) ; free ( data ) ; line [ datalen ] = '\0' ; bp = line ; } } if ( line [ 0 ] == '-' ) { if ( __ypexclude_add ( & __ypexhead , strsep ( & line , ":\n" ) + 1 ) ) { return 0 ; } if ( foundyp ) { * foundyp = - 1 ; errno = saved_errno ; return 0 ; } continue ; } parse p_gr -> gr_name = strsep ( & bp , ":\n" ) ; if ( search && name && strcmp ( p_gr -> gr_name , name ) ) { continue ; } if ( __ypmode && __ypexclude_is ( & __ypexhead , p_gr -> gr_name ) ) { continue ; } p_gr -> gr_passwd = strsep ( & bp , ":\n" ) ; if ( ! ( cp = strsep ( & bp , ":\n" ) ) ) { continue ; } ul = strtoul ( cp , & endp , 10 ) ; if ( endp == cp || * endp != '\0' || ul >= GID_MAX ) { continue ; } p_gr -> gr_gid = ul ; if ( search && name == NULL && p_gr -> gr_gid != gid ) { continue ; } found_it cp = NULL ; if ( bp == NULL ) { continue ; } for ( m = p_gr -> gr_mem = members ; ; bp ++ ) { if ( m == & members [ MAXGRP - 1 ] ) { break ; } if ( * bp == ',' ) { if ( cp ) { * bp = '\0' ; * m ++ = cp ; cp = NULL ; } } if ( * bp == '\0' || * bp == '\n' || * bp == ' ' ) { if ( cp ) { * bp = '\0' ; * m ++ = cp ; } break ; } if ( cp == NULL ) { cp = bp ; } } * m = NULL ; errno = saved_errno ; return 1 ; } } 