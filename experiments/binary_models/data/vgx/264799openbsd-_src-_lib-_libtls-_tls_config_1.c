int tls_config_parse_protocols ( uint32_t * protocols , const char * protostr ) { uint32_t proto , protos = 0 ; char * s , * p , * q ; int negate ; if ( protostr == NULL ) { * protocols = TLS_PROTOCOLS_DEFAULT ; return ( 0 ) ; } if ( ( s = strdup ( protostr ) ) == NULL ) { return ( - 1 ) ; } q = s ; while ( ( p = strsep ( & q , ",:" ) ) != NULL ) { while ( * p == ' ' || * p == '\t' ) { p ++ ; } negate = 0 ; if ( * p == '!' ) { negate = 1 ; p ++ ; } if ( negate && protos == 0 ) { protos = TLS_PROTOCOLS_ALL ; } proto = 0 ; if ( strcasecmp ( p , "all" ) == 0 || strcasecmp ( p , "legacy" ) == 0 ) { proto = TLS_PROTOCOLS_ALL ; } if ( strcasecmp ( p , "default" ) == 0 || strcasecmp ( p , "secure" ) == 0 ) { proto = TLS_PROTOCOLS_DEFAULT ; } if ( strcasecmp ( p , "tlsv1" ) == 0 ) { proto = TLS_PROTOCOL_TLSv1 ; } if ( strcasecmp ( p , "tlsv1.0" ) == 0 ) { proto = TLS_PROTOCOL_TLSv1_0 ; } if ( strcasecmp ( p , "tlsv1.1" ) == 0 ) { proto = TLS_PROTOCOL_TLSv1_1 ; } if ( strcasecmp ( p , "tlsv1.2" ) == 0 ) { proto = TLS_PROTOCOL_TLSv1_2 ; } if ( strcasecmp ( p , "tlsv1.3" ) == 0 ) { proto = TLS_PROTOCOL_TLSv1_3 ; } if ( proto == 0 ) { return ( - 1 ) ; } if ( negate ) { protos &= ~ proto ; } else { protos |= proto ; } } * protocols = protos ; free ( s ) ; return ( 0 ) ; } 