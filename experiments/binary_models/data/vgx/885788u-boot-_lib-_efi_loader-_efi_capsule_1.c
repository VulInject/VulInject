static efi_status_t efi_capsule_read_file ( const u16 * filename , struct efi_capsule_header * * capsule ) { struct efi_file_handle * dirh , * fh ; struct efi_file_info * file_info = NULL ; struct efi_capsule_header * buf = NULL ; efi_uintn_t size ; efi_status_t ret ; ret = EFI_CALL ( * bootdev_root -> open ( bootdev_root , & dirh , EFI_CAPSULE_DIR , EFI_FILE_MODE_READ , 0 ) ) ; if ( ret != EFI_SUCCESS ) { return ret ; } ret = EFI_CALL ( * dirh -> open ( dirh , & fh , ( u16 * ) filename , EFI_FILE_MODE_READ , 0 ) ) ; EFI_CALL ( * dirh -> close ( dirh ) ) ; if ( ret != EFI_SUCCESS ) { return ret ; } size = 0 ; ret = EFI_CALL ( * fh -> getinfo ( fh , & efi_file_info_guid , & size , file_info ) ) ; if ( ret == EFI_BUFFER_TOO_SMALL ) { file_info = malloc ( size ) ; if ( ! file_info ) { ret = EFI_OUT_OF_RESOURCES ; err } ret = EFI_CALL ( * fh -> getinfo ( fh , & efi_file_info_guid , & size , file_info ) ) ; } if ( ret != EFI_SUCCESS ) { err } size = file_info -> file_size ; free ( file_info ) ; buf = malloc ( size ) ; if ( ! buf ) { ret = EFI_OUT_OF_RESOURCES ; err } ret = EFI_CALL ( * fh -> read ( fh , & size , buf ) ) ; if ( ret == EFI_SUCCESS ) { if ( size >= buf -> capsule_image_size ) { * capsule = buf ; } else { ret = EFI_INVALID_PARAMETER ; } } else { free ( buf ) ; } err EFI_CALL ( * fh -> close ( fh ) ) ; return ret ; } 