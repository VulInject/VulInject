void gf_scene_select_object ( GF_Scene * scene , GF_ObjectManager * odm ) { char * url ; if ( ! scene -> is_dynamic_scene || ! scene -> graph_attached || ! odm ) { return ; } if ( ! odm -> ID ) { if ( ! odm -> addon ) { return ; } } if ( odm -> ServiceID && scene -> selected_service_id && ( scene -> selected_service_id != odm -> ServiceID ) ) { gf_scene_set_service_id ( scene , odm -> ServiceID ) ; return ; } Bool pre_selected = GF_FALSE ; if ( check_odm_deactivate ( & scene -> audio_url , odm , gf_sg_find_node_by_name ( scene -> graph , "DYN_AUDIO1" ) ) ) { pre_selected = GF_TRUE ; } if ( check_odm_deactivate ( & scene -> visual_url , odm , gf_sg_find_node_by_name ( scene -> graph , "DYN_VIDEO1" ) ) ) { pre_selected = GF_TRUE ; } if ( check_odm_deactivate ( & scene -> text_url , odm , gf_sg_find_node_by_name ( scene -> graph , "DYN_TEXT" ) ) ) { pre_selected = GF_TRUE ; } if ( check_odm_deactivate ( & scene -> subs_url , odm , gf_sg_find_node_by_name ( scene -> graph , "DYN_SUBT_IMG" ) ) ) { pre_selected = GF_TRUE ; } if ( pre_selected ) { if ( odm -> state ) { gf_odm_stop ( odm , GF_FALSE ) ; } else { gf_odm_play ( odm ) ; } return ; } if ( ! odm -> ID && odm -> subscene ) { M_Inline * dscene = ( M_Inline * ) gf_sg_find_node_by_name ( scene -> graph , "ADDON_SCENE" ) ; if ( ! dscene ) { return ; } if ( odm -> addon && odm -> addon -> addon_type == GF_ADDON_TYPE_MAIN ) { return ; } gf_sg_vrml_field_copy ( & dscene -> url , & odm -> mo -> URLs , GF_SG_VRML_MFURL ) ; gf_node_changed ( ( GF_Node * ) dscene , NULL ) ; return ; } if ( odm -> type == GF_STREAM_AUDIO ) { M_AudioClip * ac = ( M_AudioClip * ) gf_sg_find_node_by_name ( scene -> graph , "DYN_AUDIO1" ) ; if ( ! ac ) { return ; } if ( scene -> audio_url . url ) { gf_free ( scene -> audio_url . url ) ; } scene -> audio_url . OD_ID = odm -> ID ; if ( ! ac -> url . count ) { gf_sg_vrml_mf_alloc ( & ac -> url , GF_SG_VRML_MFURL , 1 ) ; } ac -> url . vals [ 0 ] . OD_ID = odm -> ID ; if ( ac -> url . vals [ 0 ] . url ) { gf_free ( ac -> url . vals [ 0 ] . url ) ; ac -> url . vals [ 0 ] . url = NULL ; } url = odm -> mo -> URLs . count ?odm -> mo -> URLs . vals [ 0 ] . url : NULL ; if ( url ) { scene -> audio_url . url = gf_strdup ( url ) ; ac -> url . vals [ 0 ] . url = gf_strdup ( url ) ; } ac -> startTime = gf_scene_get_time ( scene ) ; gf_node_changed ( ( GF_Node * ) ac , NULL ) ; return ; } if ( odm -> type == GF_STREAM_VISUAL ) { M_MovieTexture * mt = ( M_MovieTexture * ) gf_sg_find_node_by_name ( scene -> graph , "DYN_VIDEO1" ) ; if ( ! mt ) { return ; } if ( scene -> visual_url . url ) { gf_free ( scene -> visual_url . url ) ; } scene -> visual_url . url = NULL ; scene -> visual_url . OD_ID = odm -> ID ; if ( ! mt -> url . count ) { gf_sg_vrml_mf_alloc ( & mt -> url , GF_SG_VRML_MFURL , 1 ) ; } mt -> url . vals [ 0 ] . OD_ID = odm -> ID ; if ( mt -> url . vals [ 0 ] . url ) { gf_free ( mt -> url . vals [ 0 ] . url ) ; } url = odm -> mo -> URLs . count ?odm -> mo -> URLs . vals [ 0 ] . url : NULL ; if ( url ) { scene -> visual_url . url = gf_strdup ( url ) ; mt -> url . vals [ 0 ] . url = gf_strdup ( url ) ; } mt -> startTime = gf_scene_get_time ( scene ) ; gf_node_changed ( ( GF_Node * ) mt , NULL ) ; if ( odm -> mo ) { gf_scene_force_size_to_video ( scene , odm -> mo ) ; } scene -> selected_service_id = odm -> ServiceID ; return ; } if ( odm -> type == GF_STREAM_TEXT ) { M_AnimationStream * as = ( M_AnimationStream * ) gf_sg_find_node_by_name ( scene -> graph , "DYN_TEXT" ) ; if ( ! as ) { return ; } if ( scene -> text_url . url ) { gf_free ( scene -> text_url . url ) ; } scene -> text_url . url = NULL ; scene -> text_url . OD_ID = odm -> ID ; if ( ! as -> url . count ) { gf_sg_vrml_mf_alloc ( & as -> url , GF_SG_VRML_MFURL , 1 ) ; } as -> url . vals [ 0 ] . OD_ID = odm -> ID ; if ( as -> url . vals [ 0 ] . url ) { gf_free ( as -> url . vals [ 0 ] . url ) ; } url = odm -> mo -> URLs . count ?odm -> mo -> URLs . vals [ 0 ] . url : NULL ; if ( url ) { scene -> text_url . url = gf_strdup ( url ) ; as -> url . vals [ 0 ] . url = gf_strdup ( url ) ; } as -> startTime = gf_scene_get_time ( scene ) ; gf_node_changed ( ( GF_Node * ) as , NULL ) ; return ; } } 