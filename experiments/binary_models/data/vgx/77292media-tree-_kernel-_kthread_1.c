static int kthread ( void * _create ) { struct kthread_create_info * create = _create ; int * threadfn ( void * data ) create -> threadfn ; void * data = create -> data ; struct completion * done ; struct kthread * self ; int ret ; self = kmalloc ( sizeof ( * self ) , GFP_KERNEL ) ; set_kthread_struct ( self ) ; done = xchg ( & create -> done , NULL ) ; if ( ! done ) { kfree ( create ) ; do_exit ( - EINTR ) ; } if ( ! self ) { create -> result = ERR_PTR ( - ENOMEM ) ; complete ( done ) ; do_exit ( - ENOMEM ) ; } self -> flags = 0 ; self -> data = data ; init_completion ( & self -> exited ) ; init_completion ( & self -> parked ) ; current -> vfork_done = & self -> exited ; __set_current_state ( TASK_UNINTERRUPTIBLE ) ; create -> result = current ; complete ( done ) ; schedule ( ) ; ret = - EINTR ; if ( ! test_bit ( KTHREAD_SHOULD_STOP , & self -> flags ) ) { cgroup_kthread_ready ( ) ; __kthread_parkme ( self , NULL ) ; ret = threadfn ( data ) ; } do_exit ( ret ) ; } 