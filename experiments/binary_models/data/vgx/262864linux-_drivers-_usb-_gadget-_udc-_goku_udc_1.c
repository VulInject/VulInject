static int udc_proc_read ( struct seq_file * m , void * v ) { struct goku_udc * dev = m -> private ; struct goku_udc_regs __iomem * regs = dev -> regs ; cfs_time_t flags ; int i , is_usb_connected ; u32 tmp ; local_irq_save ( flags ) ; tmp = readl ( & regs -> power_detect ) ; is_usb_connected = tmp & PW_DETECT ; seq_printf ( m , "%s - %s\n" "%s version: %s %s\n" "Gadget driver: %s\n" "Host %s, %s\n" "\n" , pci_name ( dev -> pdev ) , driver_desc , driver_name , DRIVER_VERSION , dmastr ( ) , dev -> driver ?dev -> driver -> driver . name : "(none)" , is_usb_connected ?( ( tmp & PW_PULLUP ) ?"full speed" : "powered" ) else "disconnected" , udc_ep_state ( dev -> ep0state ) ) ; dump_intmask ( m , "int_status" , readl ( & regs -> int_status ) ) ; dump_intmask ( m , "int_enable" , readl ( & regs -> int_enable ) ) ; if ( ! is_usb_connected || ! dev -> driver || ( tmp & PW_PULLUP ) == 0 ) { done } seq_printf ( m , "\nirqs %lu\ndataset %02x single.bcs %02x.%02x state %x addr %u\n" , dev -> irqs , readl ( & regs -> DataSet ) , readl ( & regs -> EPxSingle ) , readl ( & regs -> EPxBCS ) , readl ( & regs -> UsbState ) , readl ( & regs -> address ) ) ; if ( seq_has_overflowed ( m ) ) { done } tmp = readl ( & regs -> dma_master ) ; seq_printf ( m , "dma %03X =" EIGHTBITS "%s %s\n" , tmp , ( tmp & MST_EOPB_DIS ) ?" eopb-" : "" , ( tmp & MST_EOPB_ENA ) ?" eopb+" : "" , ( tmp & MST_TIMEOUT_DIS ) ?" tmo-" : "" , ( tmp & MST_TIMEOUT_ENA ) ?" tmo+" : "" , ( tmp & MST_RD_EOPB ) ?" eopb" : "" , ( tmp & MST_RD_RESET ) ?" in_reset" : "" , ( tmp & MST_WR_RESET ) ?" out_reset" : "" , ( tmp & MST_RD_ENA ) ?" IN" : "" , ( tmp & MST_WR_ENA ) ?" OUT" : "" , ( tmp & MST_CONNECTION ) ?"ep1in/ep2out" : "ep1out/ep2in" ) ; if ( seq_has_overflowed ( m ) ) { done } for ( i = 0 ; i < 4 ; i ++ ) { struct goku_ep * ep = & dev -> ep [ i ] ; struct goku_request * req ; if ( i && ! ep -> ep . desc ) { continue ; } tmp = readl ( ep -> reg_status ) ; seq_printf ( m , "%s %s max %u %s, irqs %lu, status %02x (%s) " FOURBITS "\n" , ep -> ep . name , ep -> is_in ?"in" : "out" , ep -> ep . maxpacket , ep -> dma ?"dma" : "pio" , ep -> irqs , tmp , udc_ep_status ( tmp ) , ( tmp & EPxSTATUS_TOGGLE ) ?"data1" : "data0" , ( tmp & EPxSTATUS_SUSPEND ) ?" suspend" : "" , ( tmp & EPxSTATUS_FIFO_DISABLE ) ?" disable" : "" , ( tmp & EPxSTATUS_STAGE_ERROR ) ?" ep0stat" : "" ) ; if ( seq_has_overflowed ( m ) ) { done } if ( list_empty ( & ep -> queue ) ) { seq_puts ( m , "\t(nothing queued)\n" ) ; if ( seq_has_overflowed ( m ) ) { done } continue ; } list_for_each_entry ( , , ) { if ( ep -> dma && req -> queue . prev == & ep -> queue ) { if ( i == UDC_MSTRD_ENDPOINT ) { tmp = readl ( & regs -> in_dma_current ) ; } else { tmp = readl ( & regs -> out_dma_current ) ; } tmp -= req -> req . dma ; tmp ++ ; } else { tmp = req -> req . actual ; } seq_printf ( m , "\treq %p len %u/%u buf %p\n" , & req -> req , tmp , req -> req . length , req -> req . buf ) ; if ( seq_has_overflowed ( m ) ) { done } } } done local_irq_restore ( flags ) ; return 0 ; } 