static int cpumsf_pmu_add ( struct perf_event * event , int flags ) { struct cpu_hw_sf * cpuhw = this_cpu_ptr ( & cpu_hw_sf ) ; int err ; if ( cpuhw -> flags & PMU_F_IN_USE ) { return - EAGAIN ; } if ( ! cpuhw -> sfb . sdbt ) { return - EINVAL ; } err = 0 ; perf_pmu_disable ( event -> pmu ) ; event -> hw . state = PERF_HES_UPTODATE | PERF_HES_STOPPED ; cpuhw -> lsctl . s = 0 ; cpuhw -> lsctl . tear = ( unsigned long ) cpuhw -> sfb . sdbt ; cpuhw -> lsctl . dear = * ( unsigned long * ) cpuhw -> sfb . sdbt ; cpuhw -> lsctl . interval = SAMPL_RATE ( & event -> hw ) ; hw_reset_registers ( & event -> hw , cpuhw -> sfb . sdbt ) ; if ( WARN_ON_ONCE ( cpuhw -> lsctl . es == 1 || cpuhw -> lsctl . ed == 1 ) ) { err = - EAGAIN ; out } cpuhw -> lsctl . es = 1 ; if ( SAMPL_DIAG_MODE ( & event -> hw ) ) { cpuhw -> lsctl . ed = 1 ; } cpuhw -> event = event ; cpuhw -> flags |= PMU_F_IN_USE ; if ( flags & PERF_EF_START ) { cpumsf_pmu_start ( event , PERF_EF_RELOAD ) ; } out perf_event_update_userpage ( event ) ; perf_pmu_enable ( event -> pmu ) ; return err ; } 