int main ( int argc , char * * argv ) { const char * sopt = "hVk:f:dT:u:g:vq" ; struct option lopt [ ] { { "help" no_argument NULL 'h' } { "version" no_argument NULL 'V' } { "socket" required_argument NULL 'k' } { "pidfile" required_argument NULL 'f' } { "daemon" no_argument NULL 'd' } { "trace" required_argument NULL 'T' } { "user" required_argument NULL 'u' } { "group" required_argument NULL 'g' } { "verbose" no_argument NULL 'v' } { "quiet" no_argument NULL 'q' } { NULL 0 NULL 0 } } ; ; int opt_ind = 0 ; int loglevel = 1 ; int quiet = 0 ; int ch ; Error * local_err = NULL ; bool daemonize = false ; bool pidfile_specified = false ; bool socket_path_specified = false ; unsigned socket_activation ; struct sigaction sa_sigterm ; memset ( & sa_sigterm , 0 , sizeof ( sa_sigterm ) ) ; sa_sigterm . sa_handler = termsig_handler ; sigaction ( SIGTERM , & sa_sigterm , NULL ) ; sigaction ( SIGINT , & sa_sigterm , NULL ) ; sigaction ( SIGHUP , & sa_sigterm , NULL ) ; signal ( SIGPIPE , SIG_IGN ) ; error_init ( argv [ 0 ] ) ; module_call_init ( MODULE_INIT_TRACE ) ; module_call_init ( MODULE_INIT_QOM ) ; qemu_add_opts ( & qemu_trace_opts ) ; qemu_init_exec_dir ( argv [ 0 ] ) ; compute_default_paths ( ) ; while ( ( ch = getopt_long ( argc , argv , sopt , lopt , & opt_ind ) ) != - 1 ) { switch ( ch ) { case 'k' : g_free ( socket_path ) ; socket_path = g_strdup ( optarg ) ; socket_path_specified = true ; if ( socket_path [ 0 ] != '/' ) { error_report ( "socket path must be absolute" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'f' : g_free ( pidfile ) ; pidfile = g_strdup ( optarg ) ; pidfile_specified = true ; break ; case 'u' : { cfs_time_t res ; struct passwd * userinfo = getpwnam ( optarg ) ; if ( userinfo ) { uid = userinfo -> pw_uid ; } if ( qemu_strtoul ( optarg , NULL , 10 , & res ) == 0 && ( uid_t ) res == res ) { uid = res ; } else { error_report ( "invalid user '%s'" , optarg ) ; exit ( EXIT_FAILURE ) ; } break ; } case 'g' : { unsigned long res ; struct group * groupinfo = getgrnam ( optarg ) ; if ( groupinfo ) { gid = groupinfo -> gr_gid ; } if ( qemu_strtoul ( optarg , NULL , 10 , & res ) == 0 && ( gid_t ) res == res ) { gid = res ; } else { error_report ( "invalid group '%s'" , optarg ) ; exit ( EXIT_FAILURE ) ; } break ; } case 'u' : case 'g' : error_report ( "-%c not supported by this %s" , ch , argv [ 0 ] ) ; exit ( 1 ) ; case 'd' : daemonize = true ; break ; case 'q' : quiet = 1 ; break ; case 'v' : ++ loglevel ; break ; case 'T' : trace_opt_parse ( optarg ) ; break ; case 'V' : version ( argv [ 0 ] ) ; exit ( EXIT_SUCCESS ) ; break ; case 'h' : usage ( argv [ 0 ] ) ; exit ( EXIT_SUCCESS ) ; break ; case '?' : error_report ( "Try `%s --help' for more information." , argv [ 0 ] ) ; exit ( EXIT_FAILURE ) ; } } noisy = ! quiet && ( loglevel >= 3 ) ; verbose = quiet ?0 : MIN ( loglevel , 3 ) ; if ( ! trace_init_backends ( ) ) { exit ( EXIT_FAILURE ) ; } trace_init_file ( ) ; qemu_set_log ( LOG_TRACE ) ; dm_init ( ) ; multipath_pr_init ( ) ; socket_activation = check_socket_activation ( ) ; if ( socket_activation == 0 ) { SocketAddress saddr ; saddr = ( SocketAddress ) { . type = SOCKET_ADDRESS_TYPE_UNIX . u . q_unix . path = socket_path } ; server_ioc = qio_channel_socket_new ( ) ; if ( qio_channel_socket_listen_sync ( server_ioc , & saddr , 1 , & local_err ) < 0 ) { object_unref ( OBJECT ( server_ioc ) ) ; error_report_err ( local_err ) ; return 1 ; } } else { if ( socket_path_specified ) { error_report ( "Unix socket can't be set when using socket activation" ) ; exit ( EXIT_FAILURE ) ; } if ( socket_activation > 1 ) { error_report ( "%s does not support socket activation with LISTEN_FDS>1" , argv [ 0 ] ) ; exit ( EXIT_FAILURE ) ; } server_ioc = qio_channel_socket_new_fd ( FIRST_SOCKET_ACTIVATION_FD , & local_err ) ; if ( server_ioc == NULL ) { error_reportf_err ( local_err , "Failed to use socket activation: " ) ; exit ( EXIT_FAILURE ) ; } } qemu_init_main_loop ( & error_fatal ) ; server_watch = qio_channel_add_watch ( QIO_CHANNEL ( server_ioc ) , G_IO_IN , accept_client , NULL , NULL ) ; if ( daemonize ) { if ( daemon ( 0 , 0 ) < 0 ) { error_report ( "Failed to daemonize: %s" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } } if ( daemonize || pidfile_specified ) { qemu_write_pidfile ( pidfile , & error_fatal ) ; } if ( drop_privileges ( ) < 0 ) { error_report ( "Failed to drop privileges: %s" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } state = RUNNING ; { main_loop_wait ( false ) ; if ( state == TERMINATE ) { state = TERMINATING ; close_server_socket ( ) ; } } num_active_sockets > 0 ; exit ( EXIT_SUCCESS ) ; } 