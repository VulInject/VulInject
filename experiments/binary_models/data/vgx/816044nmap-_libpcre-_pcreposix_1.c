if ( nmatch > 0 ) { if ( nmatch <= POSIX_MALLOC_THRESHOLD ) { ovector = & ( small_ovector [ 0 ] ) ; } else { if ( nmatch > INT_MAX / ( sizeof ( int ) * 3 ) ) { return REG_ESPACE ; } ovector = ( int * ) malloc ( sizeof ( int ) * nmatch * 3 ) ; if ( ovector == NULL ) { return REG_ESPACE ; } allocated_ovector = TRUE ; } } rc = pcre_exec ( ( const pcre * ) preg -> re_pcre , NULL , string , ( int ) strlen ( string ) , 0 , options , ovector , nmatch * 3 ) ; if ( rc == 0 ) { rc = nmatch ; } if ( rc >= 0 ) { int i ; if ( ! nosub ) { for ( i = 0 ; i < ( size_t ) rc ; i ++ ) { pmatch [ i ] . rm_so = ovector [ i * 2 ] ; pmatch [ i ] . rm_eo = ovector [ i * 2 + 1 ] ; } if ( allocated_ovector ) { free ( ovector ) ; } for ( ; i < nmatch ; i ++ ) { pmatch [ i ] . rm_so = pmatch [ i ] . rm_eo = - 1 ; } } return 0 ; } else { if ( allocated_ovector ) { free ( ovector ) ; } switch ( rc ) { case PCRE_ERROR_NOMATCH : return REG_NOMATCH ; case PCRE_ERROR_NULL : return REG_INVARG ; case PCRE_ERROR_BADOPTION : return REG_INVARG ; case PCRE_ERROR_BADMAGIC : return REG_INVARG ; case PCRE_ERROR_UNKNOWN_NODE : return REG_ASSERT ; case PCRE_ERROR_NOMEMORY : return REG_ESPACE ; case PCRE_ERROR_MATCHLIMIT : return REG_ESPACE ; case PCRE_ERROR_BADUTF8 : return REG_INVARG ; case PCRE_ERROR_BADUTF8_OFFSET : return REG_INVARG ; default : return REG_ASSERT ; } } 