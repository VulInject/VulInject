static void sync_mode ( struct slgt_info * info ) { unsigned short val ; slgt_irq_off ( info , IRQ_ALL | IRQ_MASTER ) ; tx_stop ( info , NULL ) ; rx_stop ( info ) ; val = BIT2 ; switch ( info -> params . mode ) { case MGSL_MODE_XSYNC : val |= BIT15 + BIT13 ; break ; case MGSL_MODE_MONOSYNC : val |= BIT14 + BIT13 ; break ; case MGSL_MODE_BISYNC : val |= BIT15 ; break ; case MGSL_MODE_RAW : val |= BIT13 ; break ; } if ( info -> if_mode & MGSL_INTERFACE_RTS_EN ) { val |= BIT7 ; } switch ( info -> params . encoding ) { case HDLC_ENCODING_NRZB : val |= BIT10 ; break ; case HDLC_ENCODING_NRZI_MARK : val |= BIT11 ; break ; case HDLC_ENCODING_NRZI : val |= BIT11 + BIT10 ; break ; case HDLC_ENCODING_BIPHASE_MARK : val |= BIT12 ; break ; case HDLC_ENCODING_BIPHASE_SPACE : val |= BIT12 + BIT10 ; break ; case HDLC_ENCODING_BIPHASE_LEVEL : val |= BIT12 + BIT11 ; break ; case HDLC_ENCODING_DIFF_BIPHASE_LEVEL : val |= BIT12 + BIT11 + BIT10 ; break ; } switch ( info -> params . crc_type & HDLC_CRC_MASK ) { case HDLC_CRC_16_CCITT : val |= BIT9 ; break ; case HDLC_CRC_32_CCITT : val |= BIT9 + BIT8 ; break ; } if ( info -> params . preamble != HDLC_PREAMBLE_PATTERN_NONE ) { val |= BIT6 ; } switch ( info -> params . preamble_length ) { case HDLC_PREAMBLE_LENGTH_16BITS : val |= BIT5 ; break ; case HDLC_PREAMBLE_LENGTH_32BITS : val |= BIT4 ; break ; case HDLC_PREAMBLE_LENGTH_64BITS : val |= BIT5 + BIT4 ; break ; } if ( info -> params . flags & HDLC_FLAG_AUTO_CTS ) { val |= BIT0 ; } wr_reg16 ( info , TCR , val ) ; switch ( info -> params . preamble ) { case HDLC_PREAMBLE_PATTERN_FLAGS : val = 0x7e ; break ; case HDLC_PREAMBLE_PATTERN_ONES : val = 0xff ; break ; case HDLC_PREAMBLE_PATTERN_ZEROS : val = 0x00 ; break ; case HDLC_PREAMBLE_PATTERN_10 : val = 0x55 ; break ; case HDLC_PREAMBLE_PATTERN_01 : val = 0xaa ; break ; default : val = 0x7e ; break ; } wr_reg8 ( info , TPR , ( unsigned char ) val ) ; val = 0 ; switch ( info -> params . mode ) { case MGSL_MODE_XSYNC : val |= BIT15 + BIT13 ; break ; case MGSL_MODE_MONOSYNC : val |= BIT14 + BIT13 ; break ; case MGSL_MODE_BISYNC : val |= BIT15 ; break ; case MGSL_MODE_RAW : val |= BIT13 ; break ; } switch ( info -> params . encoding ) { case HDLC_ENCODING_NRZB : val |= BIT10 ; break ; case HDLC_ENCODING_NRZI_MARK : val |= BIT11 ; break ; case HDLC_ENCODING_NRZI : val |= BIT11 + BIT10 ; break ; case HDLC_ENCODING_BIPHASE_MARK : val |= BIT12 ; break ; case HDLC_ENCODING_BIPHASE_SPACE : val |= BIT12 + BIT10 ; break ; case HDLC_ENCODING_BIPHASE_LEVEL : val |= BIT12 + BIT11 ; break ; case HDLC_ENCODING_DIFF_BIPHASE_LEVEL : val |= BIT12 + BIT11 + BIT10 ; break ; } switch ( info -> params . crc_type & HDLC_CRC_MASK ) { case HDLC_CRC_16_CCITT : val |= BIT9 ; break ; case HDLC_CRC_32_CCITT : val |= BIT9 + BIT8 ; break ; } if ( info -> params . flags & HDLC_FLAG_AUTO_DCD ) { val |= BIT0 ; } wr_reg16 ( info , RCR , val ) ; val = 0 ; if ( info -> params . flags & HDLC_FLAG_TXC_BRG ) { if ( info -> params . flags & HDLC_FLAG_RXC_DPLL ) { val |= BIT6 + BIT5 ; } else { val |= BIT6 ; } } if ( info -> params . flags & HDLC_FLAG_TXC_DPLL ) { val |= BIT7 ; } if ( info -> params . flags & HDLC_FLAG_TXC_RXCPIN ) { val |= BIT5 ; } if ( info -> params . flags & HDLC_FLAG_RXC_BRG ) { val |= BIT3 ; } if ( info -> params . flags & HDLC_FLAG_RXC_DPLL ) { val |= BIT4 ; } if ( info -> params . flags & HDLC_FLAG_RXC_TXCPIN ) { val |= BIT2 ; } if ( info -> params . clock_speed ) { val |= BIT1 + BIT0 ; } wr_reg8 ( info , CCR , ( unsigned char ) val ) ; if ( info -> params . flags & ( HDLC_FLAG_TXC_DPLL + HDLC_FLAG_RXC_DPLL ) ) { switch ( info -> params . encoding ) { case HDLC_ENCODING_BIPHASE_MARK : case HDLC_ENCODING_BIPHASE_SPACE : val = BIT7 ; break ; case HDLC_ENCODING_BIPHASE_LEVEL : case HDLC_ENCODING_DIFF_BIPHASE_LEVEL : val = BIT7 + BIT6 ; break ; default : val = BIT6 ; } wr_reg16 ( info , RCR , ( unsigned short ) ( rd_reg16 ( info , RCR ) | val ) ) ; set_rate ( info , info -> params . clock_speed * 16 ) ; } else { set_rate ( info , info -> params . clock_speed ) ; } tx_set_idle ( info ) ; msc_set_vcr ( info ) ; wr_reg16 ( info , SCR , BIT15 + BIT14 + BIT0 ) ; if ( info -> params . loopback ) { enable_loopback ( info ) ; } } 