static void xhci_handle_cmd_stop_ep ( struct xhci_hcd * xhci , int slot_id , union xhci_trb * trb , u32 comp_code ) { unsigned int ep_index ; struct xhci_virt_ep * ep ; struct xhci_ep_ctx * ep_ctx ; struct xhci_td * td = NULL ; enum xhci_ep_reset_type reset_type ; struct xhci_command * command ; int err ; if ( unlikely ( TRB_TO_SUSPEND_PORT ( le32_to_cpu ( trb -> generic . field [ 3 ] ) ) ) ) { if ( ! xhci -> devs [ slot_id ] ) { xhci_warn ( xhci , "Stop endpoint command completion for disabled slot %u\n" , slot_id ) ; } return ; } ep_index = TRB_TO_EP_INDEX ( le32_to_cpu ( trb -> generic . field [ 3 ] ) ) ; ep = xhci_get_virt_ep ( xhci , slot_id , ep_index ) ; if ( ! ep ) { return ; } ep_ctx = xhci_get_ep_ctx ( xhci , ep -> vdev -> out_ctx , ep_index ) ; trace_xhci_handle_cmd_stop_ep ( ep_ctx ) ; if ( comp_code == COMP_CONTEXT_STATE_ERROR ) { switch ( GET_EP_CTX_STATE ( ep_ctx ) ) { case EP_STATE_HALTED : xhci_dbg ( xhci , "Stop ep completion raced with stall, reset ep\n" ) ; if ( ep -> ep_state & EP_HAS_STREAMS ) { reset_type = EP_SOFT_RESET ; } else { reset_type = EP_HARD_RESET ; td = find_halted_td ( ep ) ; if ( td ) { td -> status = - EPROTO ; } } err = xhci_handle_halted_endpoint ( xhci , ep , td , reset_type ) ; if ( err ) { break ; } ep -> ep_state &= ~ EP_STOP_CMD_PENDING ; return ; case EP_STATE_RUNNING : xhci_dbg ( xhci , "Stop ep completion ctx error, ep is running\n" ) ; command = xhci_alloc_command ( xhci , false , GFP_ATOMIC ) ; if ( ! command ) { ep -> ep_state &= ~ EP_STOP_CMD_PENDING ; return ; } xhci_queue_stop_endpoint ( xhci , command , slot_id , ep_index , 0 ) ; xhci_ring_cmd_db ( xhci , NULL ) ; return ; default : break ; } } xhci_invalidate_cancelled_tds ( ep ) ; ep -> ep_state &= ~ EP_STOP_CMD_PENDING ; xhci_giveback_invalidated_tds ( ep ) ; ring_doorbell_for_active_rings ( xhci , slot_id , ep_index ) ; } 