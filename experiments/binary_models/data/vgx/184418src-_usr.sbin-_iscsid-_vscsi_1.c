void vscsi_callback ( struct connection * c , void * arg , struct pdu * p ) { struct scsi_task * t = arg ; struct iscsi_pdu_scsi_response * sresp ; struct iscsi_pdu_rt2 * r2t ; int status = VSCSI_STAT_DONE ; u_char * buf = NULL ; size_t size , off , n ; int tag ; sresp = pdu_getbuf ( p , NULL , PDU_HEADER ) ; switch ( ISCSI_PDU_OPCODE ( sresp -> opcode ) ) { case ISCSI_OP_SCSI_RESPONSE : conn_task_cleanup ( c , & t -> task ) ; tag = t -> tag ; if ( ! ( sresp -> flags & 0x80 ) || ( sresp -> flags & 0x06 ) == 0x06 || ( sresp -> flags & 0x18 ) == 0x18 ) { log_debug ( "vscsi_callback: bad scsi response" ) ; conn_fail ( c ) ; break ; } size = 0 ; if ( sresp -> response ) { status = VSCSI_STAT_ERR ; send_status } switch ( sresp -> status ) { case ISCSI_SCSI_STAT_GOOD : break ; case ISCSI_SCSI_STAT_CHCK_COND : status = VSCSI_STAT_SENSE ; buf = pdu_getbuf ( p , & n , PDU_DATA ) ; if ( buf ) { size = buf [ 0 ] << 8 | buf [ 1 ] ; buf += 2 ; } break ; default : status = VSCSI_STAT_ERR ; break ; } send_status vscsi_status ( tag , status , buf , size ) ; break ; case ISCSI_OP_DATA_IN : buf = pdu_getbuf ( p , & n , PDU_DATA ) ; size = sresp -> datalen [ 0 ] << 16 | sresp -> datalen [ 1 ] << 8 | sresp -> datalen [ 2 ] ; if ( size > n ) { fatal ( "This does not work as it should" ) ; } vscsi_data ( VSCSI_DATA_READ , t -> tag , buf , size ) ; if ( sresp -> flags & 1 ) { conn_task_cleanup ( c , & t -> task ) ; vscsi_status ( t -> tag , status , NULL , 0 ) ; free ( t ) ; } break ; case ISCSI_OP_R2T : conn_task_cleanup ( c , & t -> task ) ; r2t = ( iscsi_pdu_rt2 * ) sresp ; off = ntohl ( r2t -> buffer_offs ) ; size = ntohl ( r2t -> desired_datalen ) ; vscsi_dataout ( c , t , r2t -> ttt , size , off ) ; break ; default : log_debug ( "scsi task: tag %d, target %d lun %d" , t -> tag , t -> target , t -> lun ) ; log_pdu ( p , 1 ) ; } pdu_free ( p ) ; } 