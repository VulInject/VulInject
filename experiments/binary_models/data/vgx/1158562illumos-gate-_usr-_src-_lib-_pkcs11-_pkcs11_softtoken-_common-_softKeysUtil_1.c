CK_RV soft_unwrapkey ( soft_session_t * session_p , CK_MECHANISM_PTR pMechanism , soft_object_t * unwrappingkey_p , CK_BYTE_PTR pWrappedKey , CK_ULONG ulWrappedKeyLen , CK_ATTRIBUTE_PTR pTemplate , CK_ULONG ulAttributeCount , CK_OBJECT_HANDLE_PTR phKey ) { CK_RV rv = CKR_OK ; CK_OBJECT_CLASS new_obj_class = ~ 0UL ; int i = 0 ; soft_object_t * new_objp = NULL ; boolean_t persistent = B_FALSE ; CK_BYTE_PTR plain_data = NULL ; CK_ULONG plain_len = 0 ; secret_key_obj_t * sck = NULL ; if ( pTemplate != NULL && ulAttributeCount != 0 ) { for ( i = 0 ; i < ulAttributeCount ; i ++ ) { if ( pTemplate [ i ] . type == CKA_CLASS ) { new_obj_class = * ( ( CK_OBJECT_CLASS * ) pTemplate [ i ] . pValue ) ; break ; } } if ( new_obj_class == ~ 0UL ) { return ( CKR_TEMPLATE_INCOMPLETE ) ; } } switch ( pMechanism -> mechanism ) { case CKM_RSA_PKCS : case CKM_RSA_X_509 : case CKM_DES_ECB : case CKM_DES3_ECB : case CKM_AES_ECB : case CKM_DES_CBC : case CKM_DES3_CBC : case CKM_AES_CBC : case CKM_BLOWFISH_CBC : if ( new_obj_class != CKO_SECRET_KEY ) { return ( CKR_MECHANISM_INVALID ) ; } break ; case CKM_DES_CBC_PAD : case CKM_DES3_CBC_PAD : case CKM_AES_CBC_PAD : if ( new_obj_class != CKO_SECRET_KEY && new_obj_class != CKO_PRIVATE_KEY ) { return ( CKR_MECHANISM_INVALID ) ; } break ; default : return ( CKR_MECHANISM_INVALID ) ; } rv = soft_gen_keyobject ( pTemplate , ulAttributeCount , & new_objp , session_p , ( CK_OBJECT_CLASS ) ~ 0UL , ( CK_KEY_TYPE ) ~ 0UL , 0 , SOFT_UNWRAP_KEY , B_FALSE ) ; if ( ( new_objp -> bool_attr_mask & NEVER_EXTRACTABLE_BOOL_ON ) || ( new_objp -> bool_attr_mask & ALWAYS_SENSITIVE_BOOL_ON ) ) { rv = CKR_TEMPLATE_INCONSISTENT ; cleanup_unwrap } rv = soft_decrypt_init ( session_p , pMechanism , unwrappingkey_p ) ; if ( rv != CKR_OK ) { cleanup_unwrap } rv = soft_decrypt ( session_p , pWrappedKey , ulWrappedKeyLen , NULL , & plain_len ) ; if ( rv != CKR_OK ) { cleanup_unwrap } if ( ( plain_data = malloc ( plain_len ) ) == NULL ) { rv = CKR_HOST_MEMORY ; cleanup_unwrap } ( void ) memset ( plain_data , 0x0 , plain_len ) ; rv = soft_decrypt ( session_p , pWrappedKey , ulWrappedKeyLen , plain_data , & plain_len ) ; if ( rv != CKR_OK ) { cleanup_unwrap } if ( new_objp -> class == CKO_SECRET_KEY ) { rv = soft_unwrap_secret_len_check ( new_objp -> key_type , pMechanism -> mechanism , pTemplate , ulAttributeCount ) ; if ( rv != CKR_OK ) { cleanup_unwrap } if ( OBJ_SEC ( new_objp ) == NULL ) { if ( ( sck = calloc ( 1 , sizeof ( secret_key_obj_t ) ) ) == NULL ) { rv = CKR_HOST_MEMORY ; cleanup_unwrap } OBJ_SEC ( new_objp ) = sck ; } switch ( new_objp -> key_type ) { case CKK_DES : OBJ_SEC_VALUE_LEN ( new_objp ) = DES_KEYSIZE ; break ; case CKK_DES2 : OBJ_SEC_VALUE_LEN ( new_objp ) = DES2_KEYSIZE ; break ; case CKK_DES3 : OBJ_SEC_VALUE_LEN ( new_objp ) = DES3_KEYSIZE ; break ; case CKK_GENERIC_SECRET : case CKK_RC4 : case CKK_AES : case CKK_BLOWFISH : break ; default : rv = CKR_WRAPPED_KEY_INVALID ; cleanup_unwrap } if ( OBJ_SEC_VALUE_LEN ( new_objp ) == 0 ) { OBJ_SEC_VALUE_LEN ( new_objp ) = plain_len ; OBJ_SEC_VALUE ( new_objp ) = plain_data ; } if ( OBJ_SEC_VALUE_LEN ( new_objp ) == plain_len ) { OBJ_SEC_VALUE ( new_objp ) = plain_data ; } if ( OBJ_SEC_VALUE_LEN ( new_objp ) > plain_len ) { rv = CKR_WRAPPED_KEY_LEN_RANGE ; cleanup_unwrap } else { OBJ_SEC_VALUE ( new_objp ) = realloc ( plain_data , OBJ_SEC_VALUE_LEN ( new_objp ) ) ; if ( OBJ_SEC_VALUE ( new_objp ) == NULL ) { rv = CKR_HOST_MEMORY ; cleanup_unwrap } } } else { rv = soft_asn1_to_object ( new_objp , plain_data , plain_len ) ; if ( rv != CKR_OK ) { cleanup_unwrap } } if ( IS_TOKEN_OBJECT ( new_objp ) ) { persistent = B_TRUE ; rv = soft_put_object_to_keystore ( new_objp ) ; if ( rv != CKR_OK ) { cleanup_unwrap } } if ( new_objp -> class != CKO_SECRET_KEY ) { freezero ( plain_data , plain_len ) ; } * phKey = ( CK_OBJECT_HANDLE ) new_objp ; return ( CKR_OK ) ; cleanup_unwrap if ( ( new_objp -> class != CKO_SECRET_KEY ) && ( plain_data != NULL ) ) { freezero ( plain_data , plain_len ) ; } if ( IS_TOKEN_OBJECT ( new_objp ) ) { soft_delete_token_object ( new_objp , persistent , B_FALSE ) ; } else { soft_delete_object ( session_p , new_objp , B_FALSE , B_FALSE ) ; } return ( rv ) ; } 