static int adp5589_gpio_add ( struct adp5589_kpad * kpad ) { struct device * dev = & kpad -> client -> dev ; const struct adp5589_kpad_platform_data * pdata = dev_get_platdata ( dev ) ; const struct adp5589_gpio_platform_data * gpio_data = pdata -> gpio_data ; int i , error ; kpad -> gc . parent = dev ; kpad -> gc . ngpio = adp5589_build_gpiomap ( kpad , pdata ) ; if ( kpad -> gc . ngpio == 0 ) { dev_info ( dev , "No unused gpios left to export\n" ) ; return 0 ; } kpad -> gc . direction_input = adp5589_gpio_direction_input ; kpad -> gc . direction_output = adp5589_gpio_direction_output ; kpad -> gc . get = adp5589_gpio_get_value ; kpad -> gc . set = adp5589_gpio_set_value ; kpad -> gc . can_sleep = 1 ; kpad -> gc . base = gpio_data -> gpio_start ; kpad -> gc . label = kpad -> client -> name ; kpad -> gc . owner = THIS_MODULE ; mutex_init ( & kpad -> gpio_lock ) ; error = devm_gpiochip_add_data ( dev , & kpad -> gc , kpad ) ; if ( error ) { return error ; } for ( i = 0 ; i <= kpad -> var -> bank ( kpad -> var -> maxgpio ) ; i ++ ) { kpad -> dat_out [ i ] = adp5589_read ( kpad -> client , kpad -> var -> reg ( ADP5589_GPO_DATA_OUT_A ) + i ) ; kpad -> dir [ i ] = adp5589_read ( kpad -> client , kpad -> var -> reg ( ADP5589_GPIO_DIRECTION_A ) + i ) ; } return 0 ; } 