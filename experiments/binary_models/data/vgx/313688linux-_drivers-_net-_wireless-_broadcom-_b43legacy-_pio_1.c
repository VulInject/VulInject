struct b43legacy_pioqueue * b43legacy_setup_pioqueue ( struct b43legacy_wldev * dev , u16 pio_mmio_base ) { struct b43legacy_pioqueue * queue ; u32 value ; u16 qsize ; queue = kzalloc ( sizeof ( * queue ) , GFP_KERNEL ) ; if ( ! queue ) { out } queue -> dev = dev ; queue -> mmio_base = pio_mmio_base ; queue -> need_workarounds = ( dev -> dev -> id . revision < 3 ) ; INIT_LIST_HEAD ( & queue -> txfree ) ; INIT_LIST_HEAD ( & queue -> txqueue ) ; INIT_LIST_HEAD ( & queue -> txrunning ) ; tasklet_setup ( & queue -> txtask , tx_tasklet ) ; value = b43legacy_read32 ( dev , B43legacy_MMIO_MACCTL ) ; value &= ~ B43legacy_MACCTL_BE ; b43legacy_write32 ( dev , B43legacy_MMIO_MACCTL , value ) ; qsize = b43legacy_read16 ( dev , queue -> mmio_base + B43legacy_PIO_TXQBUFSIZE ) ; if ( qsize == 0 ) { b43legacyerr ( dev -> wl , "This card does not support PIO " "operation mode. Please use DMA mode " "(module parameter pio=0).\n" ) ; err_freequeue } if ( qsize <= B43legacy_PIO_TXQADJUST ) { b43legacyerr ( dev -> wl , "PIO tx device-queue too small (%u)\n" , qsize ) ; err_freequeue } qsize -= B43legacy_PIO_TXQADJUST ; queue -> tx_devq_size = qsize ; setup_txqueues ( queue ) ; out return queue ; err_freequeue queue = NULL ; out } 