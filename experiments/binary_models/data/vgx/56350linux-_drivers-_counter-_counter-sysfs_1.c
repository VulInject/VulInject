static ssize_t counter_comp_u32_store ( struct device * dev , struct device_attribute * attr , const char * buf , size_t len ) { const struct counter_attribute * const a = to_counter_attribute ( attr ) ; struct counter_device * const counter = counter_from_dev ( dev ) ; struct counter_count * const count = a -> parent ; struct counter_synapse * const synapse = a -> comp . priv ; const struct counter_available * const avail = a -> comp . priv ; int err ; u32 data = 0 ; switch ( a -> comp . type ) { case COUNTER_COMP_FUNCTION : err = counter_find_enum ( & data , count -> functions_list , count -> num_functions , buf , counter_function_str ) ; break ; case COUNTER_COMP_SYNAPSE_ACTION : err = counter_find_enum ( & data , synapse -> actions_list , synapse -> num_actions , buf , counter_synapse_action_str ) ; break ; case COUNTER_COMP_ENUM : err = __sysfs_match_string ( avail -> strs , avail -> num_items , buf ) ; data = err ; break ; case COUNTER_COMP_COUNT_MODE : err = counter_find_enum ( & data , avail -> enums , avail -> num_items , buf , counter_count_mode_str ) ; break ; case COUNTER_COMP_SIGNAL_POLARITY : err = counter_find_enum ( & data , avail -> enums , avail -> num_items , buf , counter_signal_polarity_str ) ; break ; default : err = kstrtou32 ( buf , 0 , & data ) ; break ; } switch ( a -> scope ) { case COUNTER_SCOPE_DEVICE : err = a -> comp . device_u32_write ( counter , data ) ; break ; case COUNTER_SCOPE_SIGNAL : err = a -> comp . signal_u32_write ( counter , a -> parent , data ) ; break ; case COUNTER_SCOPE_COUNT : if ( a -> comp . type == COUNTER_COMP_SYNAPSE_ACTION ) { err = a -> comp . action_write ( counter , count , synapse , data ) ; } else { err = a -> comp . count_u32_write ( counter , count , data ) ; } break ; default : return - EINVAL ; } if ( err < 0 ) { return err ; } return len ; } 