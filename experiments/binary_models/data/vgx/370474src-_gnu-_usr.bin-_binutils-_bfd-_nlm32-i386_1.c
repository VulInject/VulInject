nlm_i386_read_import ( , ) bfd * abfd ; nlmNAME ( symbol_type ) * sym ; { struct nlm_relent * nlm_relocs ; bfd_size_type rcount ; bfd_byte temp [ NLM_TARGET_LONG_SIZE ] ; unsigned char symlength ; char * name ; if ( bfd_bread ( ( PTR ) & symlength , ( bfd_size_type ) sizeof ( symlength ) , abfd ) != sizeof ( symlength ) ) { return FALSE ; } sym -> symbol . the_bfd = abfd ; name = bfd_alloc ( abfd , ( bfd_size_type ) symlength + 1 ) ; if ( bfd_bread ( name , ( bfd_size_type ) symlength , abfd ) != symlength ) { return FALSE ; } name [ symlength ] = '\0' ; sym -> symbol . name = name ; sym -> symbol . flags = 0 ; sym -> symbol . value = 0 ; sym -> symbol . section = bfd_und_section_ptr ; if ( bfd_bread ( ( PTR ) temp , ( bfd_size_type ) sizeof ( temp ) , abfd ) != sizeof ( temp ) ) { return FALSE ; } rcount = H_GET_32 ( abfd , temp ) ; nlm_relocs = ( ( nlm_relent * ) bfd_alloc ( abfd , rcount * sizeof ( nlm_relent ) ) ) ; if ( ! nlm_relocs ) { return FALSE ; } sym -> relocs = nlm_relocs ; sym -> rcnt = 0 ; while ( sym -> rcnt < rcount ) { asection * section ; if ( ! nlm_i386_read_reloc ( abfd , sym , & section , & nlm_relocs -> reloc ) ) { return FALSE ; } nlm_relocs -> section = section ; nlm_relocs ++ ; sym -> rcnt ++ ; } return TRUE ; } 