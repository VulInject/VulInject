static int snd_asihpi_probe ( struct pci_dev * pci_dev , const struct pci_device_id * pci_id ) { int err ; struct hpi_adapter * hpi ; struct snd_card * card ; struct snd_card_asihpi * asihpi ; u32 h_control ; u32 h_stream ; u32 adapter_index ; static int dev ; if ( dev >= SNDRV_CARDS ) { return - ENODEV ; } if ( ! enable [ dev ] ) { dev ++ ; return - ENOENT ; } err = asihpi_adapter_probe ( pci_dev , pci_id ) ; if ( err < 0 ) { return err ; } hpi = pci_get_drvdata ( pci_dev ) ; adapter_index = hpi -> adapter -> index ; err = snd_card_new ( & pci_dev -> dev , adapter_index , id [ adapter_index ] , THIS_MODULE , sizeof ( snd_card_asihpi ) , & card ) ; if ( err < 0 ) { err = snd_card_new ( & pci_dev -> dev , index [ dev ] , id [ dev ] , THIS_MODULE , sizeof ( snd_card_asihpi ) , & card ) ; if ( err < 0 ) { return err ; } dev_warn ( & pci_dev -> dev , "Adapter index %d->ALSA index %d\n" , adapter_index , card -> number ) ; } asihpi = card -> private_data ; asihpi -> card = card ; asihpi -> pci = pci_dev ; asihpi -> hpi = hpi ; hpi -> snd_card = card ; err = hpi_adapter_get_property ( adapter_index , HPI_ADAPTER_PROPERTY_CAPS1 , NULL , & asihpi -> support_grouping ) ; if ( err ) { asihpi -> support_grouping = 0 ; } err = hpi_adapter_get_property ( adapter_index , HPI_ADAPTER_PROPERTY_CAPS2 , & asihpi -> support_mrx , NULL ) ; if ( err ) { asihpi -> support_mrx = 0 ; } err = hpi_adapter_get_property ( adapter_index , HPI_ADAPTER_PROPERTY_INTERVAL , NULL , & asihpi -> update_interval_frames ) ; if ( err ) { asihpi -> update_interval_frames = 512 ; } if ( hpi -> interrupt_mode ) { asihpi -> pcm_start = snd_card_asihpi_pcm_int_start ; asihpi -> pcm_stop = snd_card_asihpi_pcm_int_stop ; hpi -> interrupt_callback = snd_card_asihpi_isr ; } else { asihpi -> pcm_start = snd_card_asihpi_pcm_timer_start ; asihpi -> pcm_stop = snd_card_asihpi_pcm_timer_stop ; } hpi_handle_error ( hpi_instream_open ( adapter_index , 0 , & h_stream ) ) ; err = hpi_instream_host_buffer_free ( h_stream ) ; asihpi -> can_dma = ( ! err ) ; hpi_handle_error ( hpi_instream_close ( h_stream ) ) ; if ( ! asihpi -> can_dma ) { asihpi -> update_interval_frames *= 2 ; } err = hpi_adapter_get_property ( adapter_index , HPI_ADAPTER_PROPERTY_CURCHANNELS , & asihpi -> in_max_chans , & asihpi -> out_max_chans ) ; if ( err ) { asihpi -> in_max_chans = 2 ; asihpi -> out_max_chans = 2 ; } if ( asihpi -> out_max_chans > 2 ) { asihpi -> out_min_chans = asihpi -> out_max_chans ; asihpi -> in_min_chans = asihpi -> in_max_chans ; asihpi -> support_grouping = 0 ; } else { asihpi -> in_min_chans = 1 ; } dev_info ( & pci_dev -> dev , "Has dma:%d, grouping:%d, mrx:%d, uif:%d\n" , asihpi -> can_dma , asihpi -> support_grouping , asihpi -> support_mrx , asihpi -> update_interval_frames ) ; err = snd_card_asihpi_pcm_new ( asihpi , 0 ) ; if ( err < 0 ) { dev_err ( & pci_dev -> dev , "pcm_new failed\n" ) ; __nodev } err = snd_card_asihpi_mixer_new ( asihpi ) ; if ( err < 0 ) { dev_err ( & pci_dev -> dev , "mixer_new failed\n" ) ; __nodev } err = hpi_mixer_get_control ( asihpi -> h_mixer , HPI_SOURCENODE_CLOCK_SOURCE , 0 , 0 , 0 , HPI_CONTROL_SAMPLECLOCK , & h_control ) ; if ( ! err ) { err = hpi_sample_clock_set_local_rate ( h_control , adapter_fs ) ; } snd_asihpi_proc_init ( asihpi ) ; snd_asihpi_hpi_new ( asihpi , 0 ) ; strcpy ( card -> driver , "ASIHPI" ) ; sprintf ( card -> shortname , "AudioScience ASI%4X" , asihpi -> hpi -> adapter -> type ) ; sprintf ( card -> longname , "%s %i" , card -> shortname , adapter_index ) ; err = snd_card_register ( card ) ; if ( ! err ) { dev ++ ; return 0 ; } __nodev snd_card_free ( card ) ; dev_err ( & pci_dev -> dev , "snd_asihpi_probe error %d\n" , err ) ; return err ; } 