int wc_AesGcmDecryptFinal ( Aes * aes , const byte * authTag , word32 authTagSz ) { int ret ; if ( ( aes == NULL ) || ( authTag == NULL ) || ( authTagSz > AES_BLOCK_SIZE ) || ( authTagSz == 0 ) ) { ret = BAD_FUNC_ARG ; } if ( ( ret == 0 ) && ( ! aes -> gcmKeySet ) ) { ret = MISSING_KEY ; } if ( ( ret == 0 ) && ( ! aes -> nonceSet ) ) { ret = MISSING_IV ; } if ( ret == 0 ) { if ( haveAESNI || IS_INTEL_AVX2 ( intel_flags ) || IS_INTEL_AVX1 ( intel_flags ) ) { ret = AesGcmDecryptFinal_aesni ( aes , authTag , authTagSz ) ; } else { ALIGN32 byte calcTag [ AES_BLOCK_SIZE ] ; ret = AesGcmFinal_C ( aes , calcTag , authTagSz ) ; if ( ret == 0 ) { if ( ConstantCompare ( authTag , calcTag , authTagSz ) != 0 ) { ret = AES_GCM_AUTH_E ; } } } } if ( ret == 0 ) { wc_AesFree ( aes ) ; } return ret ; } 