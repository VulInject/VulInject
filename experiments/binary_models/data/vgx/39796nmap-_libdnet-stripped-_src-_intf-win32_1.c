static IP_ADAPTER_ADDRESSES * _update_tables_for_npcap_loopback ( IP_ADAPTER_ADDRESSES * p ) { IP_ADAPTER_ADDRESSES * a_prev = NULL ; IP_ADAPTER_ADDRESSES * a ; IP_ADAPTER_ADDRESSES * a_original_loopback_prev = NULL ; IP_ADAPTER_ADDRESSES * a_original_loopback = NULL ; IP_ADAPTER_ADDRESSES * a_npcap_loopback = NULL ; static char npcap_loopback_name [ 1024 ] { 0 } ; ; if ( npcap_loopback_name [ 0 ] == '\0' ) { g_has_npcap_loopback = intf_get_loopback_name ( npcap_loopback_name , 1024 ) ; } if ( g_has_npcap_loopback == 0 ) { return p ; } for ( a = p ; a != NULL ; a = a -> Next ) { if ( a -> IfType == IF_TYPE_SOFTWARE_LOOPBACK ) { a_original_loopback = a ; a_original_loopback_prev = a_prev ; } if ( strcmp ( a -> AdapterName , npcap_loopback_name + strlen ( _DEVICE_PREFIX ) - 1 ) == 0 ) { a_npcap_loopback = a ; } a_prev = a ; } if ( ! a_original_loopback ) { return p ; } g_has_npcap_loopback = 1 ; if ( ! a_npcap_loopback ) { strlcpy ( npcap_loopback_name , _DEVICE_PREFIX "NPF_Loopback" , 1024 ) ; a_original_loopback -> AdapterName = npcap_loopback_name + sizeof ( _DEVICE_PREFIX ) - 1 ; return p ; } else { a_npcap_loopback -> IfType = a_original_loopback -> IfType ; a_npcap_loopback -> FirstUnicastAddress = a_original_loopback -> FirstUnicastAddress ; a_npcap_loopback -> FirstPrefix = a_original_loopback -> FirstPrefix ; memset ( a_npcap_loopback -> PhysicalAddress , 0 , ETH_ADDR_LEN ) ; if ( a_original_loopback_prev ) { a_original_loopback_prev -> Next = a_original_loopback_prev -> Next -> Next ; return p ; } if ( a_original_loopback == p ) { return a_original_loopback -> Next ; } else { return p ; } } } 