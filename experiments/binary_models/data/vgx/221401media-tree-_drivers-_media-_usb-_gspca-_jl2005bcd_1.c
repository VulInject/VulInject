static void jl2005c_dostream ( struct work_struct * work ) { struct sd * dev = container_of ( work , sd , work_struct ) ; struct gspca_dev * gspca_dev = & dev -> gspca_dev ; int bytes_left = 0 ; int data_len ; int header_read = 0 ; unsigned char header_sig [ 2 ] { 0x4a 0x4c } ; ; int act_len ; int packet_type ; int ret ; u8 * buffer ; buffer = kmalloc ( JL2005C_MAX_TRANSFER , GFP_KERNEL | GFP_DMA ) ; if ( ! buffer ) { pr_err ( "Couldn't allocate USB buffer\n" ) ; quit_stream } while ( gspca_dev -> present && gspca_dev -> streaming ) { if ( gspca_dev -> frozen ) { break ; } if ( ! header_read ) { mutex_lock ( & gspca_dev -> usb_lock ) ; ret = jl2005c_start_new_frame ( gspca_dev ) ; mutex_unlock ( & gspca_dev -> usb_lock ) ; if ( ret < 0 ) { quit_stream } ret = usb_bulk_msg ( gspca_dev -> dev , usb_rcvbulkpipe ( gspca_dev -> dev , 0x82 ) , buffer , JL2005C_MAX_TRANSFER , & act_len , JL2005C_DATA_TIMEOUT ) ; PDEBUG ( D_PACK , "Got %d bytes out of %d for header" , act_len , JL2005C_MAX_TRANSFER ) ; if ( ret < 0 || act_len < JL2005C_MAX_TRANSFER ) { quit_stream } if ( memcmp ( header_sig , buffer , 2 ) != 0 ) { pr_err ( "First block is not the first block\n" ) ; quit_stream } bytes_left = buffer [ 0x07 ] * dev -> block_size - act_len ; PDEBUG ( D_PACK , "bytes_left = 0x%x" , bytes_left ) ; packet_type = FIRST_PACKET ; gspca_frame_add ( gspca_dev , packet_type , buffer , act_len ) ; header_read = 1 ; } while ( bytes_left > 0 && gspca_dev -> present ) { data_len = bytes_left > JL2005C_MAX_TRANSFER ?JL2005C_MAX_TRANSFER : bytes_left ; ret = usb_bulk_msg ( gspca_dev -> dev , usb_rcvbulkpipe ( gspca_dev -> dev , 0x82 ) , buffer , data_len , & act_len , JL2005C_DATA_TIMEOUT ) ; if ( ret < 0 || act_len < data_len ) { quit_stream } PDEBUG ( D_PACK , "Got %d bytes out of %d for frame" , data_len , bytes_left ) ; bytes_left -= data_len ; if ( bytes_left == 0 ) { packet_type = LAST_PACKET ; header_read = 0 ; } else { packet_type = INTER_PACKET ; } gspca_frame_add ( gspca_dev , packet_type , buffer , data_len ) ; } } quit_stream if ( gspca_dev -> present ) { mutex_lock ( & gspca_dev -> usb_lock ) ; jl2005c_stop ( gspca_dev ) ; mutex_unlock ( & gspca_dev -> usb_lock ) ; } } 