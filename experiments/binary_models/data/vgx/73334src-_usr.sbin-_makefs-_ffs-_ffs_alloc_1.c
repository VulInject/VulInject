static daddr_t ffs_alloccg ( struct inode * ip , int cg , daddr_t bpref , int size ) { struct cg * cgp ; struct mkfsbuf * bp ; daddr_t bno , blkno ; int error , frags , allocsiz , i ; struct fs * fs = ip -> i_fs ; if ( fs -> fs_cs ( fs , cg ) . cs_nbfree == 0 && size == fs -> fs_bsize ) { return ( 0 ) ; } error = bread ( ip -> i_devvp , fsbtodb ( fs , cgtod ( fs , cg ) ) , ( int ) fs -> fs_cgsize , 0 , & bp ) ; cgp = ( cg * ) bp -> b_data ; if ( ! cg_chkmagic ( cgp ) || ( cgp -> cg_cs . cs_nbfree == 0 && size == fs -> fs_bsize ) ) { brelse ( bp , 0 ) ; return ( 0 ) ; } if ( size == fs -> fs_bsize ) { bno = ffs_alloccgblk ( ip , bp , bpref ) ; bwrite ( bp ) ; return ( bno ) ; } frags = numfrags ( fs , size ) ; for ( allocsiz = frags ; allocsiz < fs -> fs_frag ; allocsiz ++ ) { if ( cgp -> cg_frsum [ allocsiz ] != 0 ) { break ; } } if ( allocsiz == fs -> fs_frag ) { if ( cgp -> cg_cs . cs_nbfree == 0 ) { brelse ( bp , 0 ) ; return ( 0 ) ; } bno = ffs_alloccgblk ( ip , bp , bpref ) ; bpref = dtogd ( fs , bno ) ; for ( i = frags ; i < fs -> fs_frag ; i ++ ) { setbit ( cg_blksfree ( cgp ) , bpref + i ) ; } i = fs -> fs_frag - frags ; cgp -> cg_cs . cs_nffree += i ; fs -> fs_cstotal . cs_nffree += i ; fs -> fs_cs ( fs , cg ) . cs_nffree += i ; fs -> fs_fmod = 1 ; cgp -> cg_frsum [ i ] += 1 ; bdwrite ( bp ) ; return ( bno ) ; } bno = ffs_mapsearch ( fs , cgp , bpref , allocsiz ) ; for ( i = 0 ; i < frags ; i ++ ) { clrbit ( cg_blksfree ( cgp ) , bno + i ) ; } cgp -> cg_cs . cs_nffree -= frags ; fs -> fs_cstotal . cs_nffree -= frags ; fs -> fs_cs ( fs , cg ) . cs_nffree -= frags ; fs -> fs_fmod = 1 ; cgp -> cg_frsum [ allocsiz ] -= 1 ; if ( frags != allocsiz ) { cgp -> cg_frsum [ allocsiz - frags ] += 1 ; } blkno = cg * fs -> fs_fpg + bno ; bdwrite ( bp ) ; return blkno ; } 