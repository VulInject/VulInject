void * qcgpio_fdt_intr_establish ( void * cookie , int * cells , int ipl , struct cpu_info * ci , int * func ( void * ) , void * arg , char * name ) { struct qcgpio_softc * sc = cookie ; uint32_t reg ; int pin = cells [ 0 ] ; int level = cells [ 1 ] ; if ( pin < 0 || pin >= sc -> sc_npins ) { return in ; } sc -> sc_pin_ih [ pin ] . ih_func = func ; sc -> sc_pin_ih [ pin ] . ih_arg = arg ; sc -> sc_pin_ih [ pin ] . ih_pin = pin ; sc -> sc_pin_ih [ pin ] . ih_sc = sc ; reg = HREAD4 ( sc , TLMM_GPIO_INTR_CFG ( pin ) ) ; reg &= ~ TLMM_GPIO_INTR_CFG_INTR_DECT_CTL_MASK ; reg &= ~ TLMM_GPIO_INTR_CFG_INTR_POL_CTL ; switch ( level ) { case 1 : reg |= TLMM_GPIO_INTR_CFG_INTR_DECT_CTL_EDGE_POS | TLMM_GPIO_INTR_CFG_INTR_POL_CTL ; break ; case 2 : reg |= TLMM_GPIO_INTR_CFG_INTR_DECT_CTL_EDGE_NEG | TLMM_GPIO_INTR_CFG_INTR_POL_CTL ; break ; case 3 : reg |= TLMM_GPIO_INTR_CFG_INTR_DECT_CTL_EDGE_BOTH ; break ; case 4 : reg |= TLMM_GPIO_INTR_CFG_INTR_DECT_CTL_LEVEL | TLMM_GPIO_INTR_CFG_INTR_POL_CTL ; break ; case 8 : reg |= TLMM_GPIO_INTR_CFG_INTR_DECT_CTL_LEVEL ; break ; default : printf ( "%s: unsupported interrupt mode/polarity\n" , sc -> sc_dev . dv_xname ) ; break ; } reg &= ~ TLMM_GPIO_INTR_CFG_TARGET_PROC_MASK ; reg |= TLMM_GPIO_INTR_CFG_TARGET_PROC_RPM ; reg |= TLMM_GPIO_INTR_CFG_INTR_RAW_STATUS_EN ; reg |= TLMM_GPIO_INTR_CFG_INTR_ENABLE ; HWRITE4 ( sc , TLMM_GPIO_INTR_CFG ( pin ) , reg ) ; return & sc -> sc_pin_ih [ pin ] ; } 