void relu_bf8_bf8_gold ( libxsmm_blasint M , libxsmm_blasint N , libxsmm_blasint ldi , libxsmm_blasint ldo , libxsmm_blasint ldo_mask , libxsmm_bfloat8 * in , libxsmm_bfloat8 * out , float alpha , unsigned char * out_mask , unsigned char type , libxsmm_blasint use_bitmask ) { libxsmm_blasint i , j ; if ( ( type != 2 ) && ( use_bitmask > 0 ) ) { for ( j = 0 ; j < N ; ++ j ) { for ( i = 0 ; i < M ; ++ i ) { out_mask [ ( j * ldo_mask ) + i / 8 ] |= ( unsigned char ) ( ( ( ( in [ ( j * ldi ) + i ] & 0x80 ) == 0x80 ) || ( in [ ( j * ldi ) + i ] == 0x00 ) ) ?0x0 : ( 1 << ( i % 8 ) ) ) ; } } } for ( j = 0 ; j < N ; ++ j ) { for ( i = 0 ; i < M ; ++ i ) { if ( type == 0 ) { out [ ( j * ldo ) + i ] = ( ( ( in [ ( j * ldi ) + i ] & 0x80 ) == 0x80 ) || ( in [ ( j * ldi ) + i ] == 0x00 ) ) ?0 : in [ ( j * ldi ) + i ] ; } if ( type == 1 ) { union libxsmm_bfloat8_f16 bf8_hp ; float in_f = 0.0f ; float res = 0.0f ; bf8_hp . i [ 0 ] = 0 ; bf8_hp . i [ 1 ] = in [ ( j * ldi ) + i ] ; in_f = libxsmm_convert_f16_to_f32 ( bf8_hp . hf ) ; res = ( ( ( in [ ( j * ldi ) + i ] & 0x80 ) == 0x80 ) || ( in [ ( j * ldi ) + i ] == 0x00 ) ) ?alpha * in_f : in_f ; libxsmm_rne_convert_fp32_bf8 ( & res , & ( out [ ( j * ldo ) + i ] ) , 1 ) ; } if ( type == 2 ) { union libxsmm_bfloat8_f16 bf8_hp ; float in_f = 0.0f ; libxsmm_bfloat8 res = 0 ; bf8_hp . i [ 1 ] = in [ ( j * ldi ) + i ] ; bf8_hp . i [ 0 ] = 0 ; in_f = libxsmm_convert_f16_to_f32 ( bf8_hp . hf ) ; in_f = alpha * ( LIBXSMM_EXPF ( in_f ) - 1.0f ) ; libxsmm_rne_convert_fp32_bf8 ( & in_f , & res , 1 ) ; out [ ( j * ldo ) + i ] = ( ( ( in [ ( j * ldi ) + i ] & 0x80 ) == 0x80 ) || ( in [ ( j * ldi ) + i ] == 0x00 ) ) ?res : in [ ( j * ldi ) + i ] ; } } } } 