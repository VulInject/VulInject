static MagickBooleanType WriteMipmaps ( Image * image , const ImageInfo * image_info , const size_t pixelFormat , const size_t compression , const size_t mipmaps , const MagickBooleanType fromlist , const MagickBooleanType clusterFit , const MagickBooleanType weightByAlpha , ExceptionInfo * exception ) { const char * option ; Image * mipmap_image , * resize_image ; MagickBooleanType fast_mipmaps , status ; ssize_t i ; size_t columns , rows ; columns = DIV2 ( image -> columns ) ; rows = DIV2 ( image -> rows ) ; option = GetImageOption ( image_info , "dds:fast-mipmaps" ) ; fast_mipmaps = IsStringTrue ( option ) ; mipmap_image = image ; resize_image = image ; status = MagickTrue ; for ( i = 0 ; i < ( ssize_t ) mipmaps ; i ++ ) { if ( fromlist == MagickFalse ) { mipmap_image = ResizeImage ( resize_image , columns , rows , TriangleFilter , exception ) ; if ( mipmap_image == ( Image * ) NULL ) { status = MagickFalse ; break ; } } else { mipmap_image = mipmap_image -> next ; if ( ( mipmap_image -> columns != columns ) || ( mipmap_image -> rows != rows ) ) { ThrowBinaryException ( CoderError , "ImageColumnOrRowSizeIsNotSupported" , image -> filename ) ; } } DestroyBlob ( mipmap_image ) ; mipmap_image -> blob = ReferenceBlob ( image -> blob , NULL ) ; WriteImageData ( mipmap_image , pixelFormat , compression , weightByAlpha , clusterFit , exception ) ; if ( fromlist == MagickFalse ) { if ( fast_mipmaps == MagickFalse ) { mipmap_image = DestroyImage ( mipmap_image ) ; } else { if ( resize_image != image ) { resize_image = DestroyImage ( resize_image ) ; } resize_image = mipmap_image ; } } columns = DIV2 ( columns ) ; rows = DIV2 ( rows ) ; } if ( resize_image != image ) { resize_image = DestroyImage ( resize_image ) ; } return ( status ) ; } 