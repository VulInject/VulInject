static int sonic_send_packet ( struct sk_buff * skb , struct net_device * dev ) { struct sonic_local * lp = netdev_priv ( dev ) ; dma_addr_t laddr ; int length ; int entry ; unsigned long flags ; netif_dbg ( lp , tx_queued , dev , "%s: skb=%p\n" , __func__ , skb ) ; length = skb -> len ; if ( length < ETH_ZLEN ) { if ( skb_padto ( skb , ETH_ZLEN ) ) { return NETDEV_TX_OK ; } length = ETH_ZLEN ; } laddr = dma_map_single ( lp -> device , skb -> data , length , DMA_TO_DEVICE ) ; if ( ! laddr ) { pr_err_ratelimited ( "%s: failed to map tx DMA buffer.\n" , dev -> name ) ; return NETDEV_TX_OK ; } spin_lock_irqsave ( & lp -> lock , flags ) ; entry = ( lp -> eol_tx + 1 ) & SONIC_TDS_MASK ; sonic_tda_put ( dev , entry , SONIC_TD_STATUS , 0 ) ; sonic_tda_put ( dev , entry , SONIC_TD_FRAG_COUNT , 1 ) ; sonic_tda_put ( dev , entry , SONIC_TD_PKTSIZE , length ) ; sonic_tda_put ( dev , entry , SONIC_TD_FRAG_PTR_L , laddr & 0xffff ) ; sonic_tda_put ( dev , entry , SONIC_TD_FRAG_PTR_H , laddr >> 16 ) ; sonic_tda_put ( dev , entry , SONIC_TD_FRAG_SIZE , length ) ; sonic_tda_put ( dev , entry , SONIC_TD_LINK , sonic_tda_get ( dev , entry , SONIC_TD_LINK ) | SONIC_EOL ) ; sonic_tda_put ( dev , lp -> eol_tx , SONIC_TD_LINK , ~ SONIC_EOL & sonic_tda_get ( dev , lp -> eol_tx , SONIC_TD_LINK ) ) ; netif_dbg ( lp , tx_queued , dev , "%s: issuing Tx command\n" , __func__ ) ; SONIC_WRITE ( SONIC_CMD , SONIC_CR_TXP ) ; lp -> tx_len [ entry ] = length ; lp -> tx_laddr [ entry ] = laddr ; lp -> tx_skb [ entry ] = skb ; lp -> eol_tx = entry ; entry = ( entry + 1 ) & SONIC_TDS_MASK ; if ( lp -> tx_skb [ entry ] ) { netif_dbg ( lp , tx_queued , dev , "%s: stopping queue\n" , __func__ ) ; netif_stop_queue ( dev ) ; } spin_unlock_irqrestore ( & lp -> lock , flags ) ; return NETDEV_TX_OK ; } 