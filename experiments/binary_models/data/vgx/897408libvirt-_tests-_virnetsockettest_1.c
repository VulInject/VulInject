static int checkProtocols ( bool * hasIPv4 , bool * hasIPv6 , int * freePort ) { struct sockaddr_in in4 ; struct sockaddr_in6 in6 ; size_t i ; * freePort = 0 ; if ( virNetSocketCheckProtocols ( hasIPv4 , hasIPv6 ) < 0 ) { return - 1 ; } for ( i = 0 ; i < 50 ; i ++ ) { VIR_AUTOCLOSE s4 = - 1 ; VIR_AUTOCLOSE s6 = - 1 ; if ( * hasIPv4 ) { if ( ( s4 = socket ( AF_INET , SOCK_STREAM , 0 ) ) < 0 ) { return - 1 ; } } if ( * hasIPv6 ) { int only = 1 ; if ( ( s6 = socket ( AF_INET6 , SOCK_STREAM , 0 ) ) < 0 ) { return - 1 ; } if ( setsockopt ( s6 , IPPROTO_IPV6 , IPV6_V6ONLY , & only , sizeof ( only ) ) < 0 ) { return - 1 ; } } memset ( & in6 , 0 , sizeof ( in6 ) ) ; in4 . sin_family = AF_INET ; in4 . sin_port = htons ( BASE_PORT + i ) ; in4 . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ; in6 . sin6_family = AF_INET6 ; in6 . sin6_port = htons ( BASE_PORT + i ) ; in6 . sin6_addr = in6addr_loopback ; if ( * hasIPv4 ) { if ( bind ( s4 , ( sockaddr * ) & in4 , sizeof ( in4 ) ) < 0 ) { if ( errno == EADDRINUSE ) { continue ; } return - 1 ; } } if ( * hasIPv6 ) { if ( bind ( s6 , ( sockaddr * ) & in6 , sizeof ( in6 ) ) < 0 ) { if ( errno == EADDRINUSE ) { continue ; } return - 1 ; } } * freePort = BASE_PORT + i ; break ; } VIR_DEBUG ( "Choose port %d" , * freePort ) ; return 0 ; } testClientData { const char * path ; const char * cnode ; const char * portstr ; } 