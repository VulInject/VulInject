struct nvkm_runl * nvkm_runl_new ( struct nvkm_fifo * fifo , int runi , u32 addr , int id_nr ) { struct nvkm_subdev * subdev = & fifo -> engine . subdev ; struct nvkm_runl * runl ; int ret ; if ( ! ( runl = kzalloc ( sizeof ( * runl ) , GFP_KERNEL ) ) ) { return NULL ; } runl -> func = fifo -> func -> runl ; runl -> fifo = fifo ; runl -> id = runi ; runl -> addr = addr ; INIT_LIST_HEAD ( & runl -> engns ) ; INIT_LIST_HEAD ( & runl -> cgrps ) ; atomic_set ( & runl -> changed , 0 ) ; INIT_WORK ( & runl -> work , nvkm_runl_work ) ; atomic_set ( & runl -> rc_triggered , 0 ) ; atomic_set ( & runl -> rc_pending , 0 ) ; list_add_tail ( & runl -> head , & fifo -> runls ) ; if ( ! fifo -> chid ) { if ( ( ret = nvkm_chid_new ( & nvkm_chan_event , subdev , id_nr , 0 , id_nr , & runl -> cgid ) ) || ( ret = nvkm_chid_new ( & nvkm_chan_event , subdev , id_nr , 0 , id_nr , & runl -> chid ) ) ) { RUNL_ERROR ( runl , "cgid/chid: %d" , ret ) ; nvkm_runl_del ( runl ) ; return NULL ; } } else { runl -> cgid = nvkm_chid_ref ( fifo -> cgid ) ; runl -> chid = nvkm_chid_ref ( fifo -> chid ) ; } return runl ; } 