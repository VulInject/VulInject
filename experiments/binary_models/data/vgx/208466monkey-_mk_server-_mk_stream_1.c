int mk_channel_stream_write ( struct mk_stream * stream , size_t * count ) { ssize_t bytes = 0 ; struct mk_iov * iov ; struct mk_list * tmp ; struct mk_list * head ; struct mk_channel * channel ; struct mk_stream_input * input ; channel = stream -> channel ; if ( channel -> status != MK_CHANNEL_OK ) { return - MK_CHANNEL_ERROR ; } mk_list_foreach_safe ( , , ) { input = mk_list_entry ( head , mk_stream_input , _head ) ; if ( input -> type == MK_STREAM_FILE ) { bytes = channel_write_in_file ( channel , input ) ; } if ( input -> type == MK_STREAM_IOV ) { iov = input -> buffer ; if ( ! iov ) { return MK_CHANNEL_EMPTY ; } bytes = mk_sched_conn_writev ( channel , iov ) ; MK_TRACE ( "[CH %i] STREAM_IOV, wrote %d bytes" , channel -> fd , bytes ) ; if ( bytes > 0 ) { mk_iov_consume ( iov , bytes ) ; } } if ( input -> type == MK_STREAM_RAW ) { bytes = mk_sched_conn_write ( channel , input -> buffer , input -> bytes_total ) ; MK_TRACE ( "[CH %i] STREAM_RAW, bytes=%lu/%lu\n" , channel -> fd , bytes , input -> bytes_total ) ; } if ( bytes > 0 ) { * count = bytes ; mk_stream_input_consume ( input , bytes ) ; if ( stream -> cb_bytes_consumed ) { stream -> cb_bytes_consumed ( stream , bytes ) ; } if ( input -> cb_consumed ) { input -> cb_consumed ( input , bytes ) ; } if ( input -> bytes_total == 0 ) { MK_TRACE ( "Input done, unlinking (channel=%p)" , channel ) ; } MK_TRACE ( "[CH %i] CHANNEL_FLUSH" , channel -> fd ) ; } if ( bytes < 0 ) { mk_stream_in_release ( input ) ; return - MK_CHANNEL_ERROR ; } if ( bytes == 0 ) { mk_stream_in_release ( input ) ; return - MK_CHANNEL_ERROR ; } } return bytes ; } 