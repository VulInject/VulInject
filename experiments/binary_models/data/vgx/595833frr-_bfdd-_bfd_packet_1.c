void bfd_recv_cb ( struct thread * t ) { int sd = THREAD_FD ( t ) ; struct bfd_session * bfd ; struct bfd_pkt * cp ; bool is_mhop ; ssize_t mlen = 0 ; uint8_t ttl = 0 ; vrf_id_t vrfid ; ifindex_t ifindex = IFINDEX_INTERNAL ; struct sockaddr_any local , peer ; uint8_t msgbuf [ 1516 ] ; struct interface * ifp = NULL ; struct bfd_vrf_global * bvrf = THREAD_ARG ( t ) ; bfd_sd_reschedule ( bvrf , sd ) ; if ( sd == bvrf -> bg_echo || sd == bvrf -> bg_echov6 ) { ptm_bfd_process_echo_pkt ( bvrf , sd ) ; return ; } memset ( & peer , 0 , sizeof ( peer ) ) ; is_mhop = false ; if ( sd == bvrf -> bg_shop || sd == bvrf -> bg_mhop ) { is_mhop = sd == bvrf -> bg_mhop ; mlen = bfd_recv_ipv4 ( sd , msgbuf , sizeof ( msgbuf ) , & ttl , & ifindex , & local , & peer ) ; } if ( sd == bvrf -> bg_shop6 || sd == bvrf -> bg_mhop6 ) { is_mhop = sd == bvrf -> bg_mhop6 ; mlen = bfd_recv_ipv6 ( sd , msgbuf , sizeof ( msgbuf ) , & ttl , & ifindex , & local , & peer ) ; } vrfid = bvrf -> vrf -> vrf_id ; if ( ifindex ) { ifp = if_lookup_by_index ( ifindex , vrfid ) ; if ( ifp ) { vrfid = ifp -> vrf -> vrf_id ; } } if ( mlen < BFD_PKT_LEN ) { cp_debug ( is_mhop , & peer , & local , ifindex , vrfid , "too small (%zd bytes)" , mlen ) ; return ; } if ( ( ! is_mhop ) && ( ttl != BFD_TTL_VAL ) ) { cp_debug ( is_mhop , & peer , & local , ifindex , vrfid , "invalid TTL: %d expected %d" , ttl , BFD_TTL_VAL ) ; return ; } cp = ( bfd_pkt * ) ( msgbuf ) ; if ( BFD_GETVER ( cp -> diag ) != BFD_VERSION ) { cp_debug ( is_mhop , & peer , & local , ifindex , vrfid , "bad version %d" , BFD_GETVER ( cp -> diag ) ) ; return ; } if ( cp -> detect_mult == 0 ) { cp_debug ( is_mhop , & peer , & local , ifindex , vrfid , "detect multiplier set to zero" ) ; return ; } if ( ( cp -> len < BFD_PKT_LEN ) || ( cp -> len > mlen ) ) { cp_debug ( is_mhop , & peer , & local , ifindex , vrfid , "too small" ) ; return ; } if ( cp -> discrs . my_discr == 0 ) { cp_debug ( is_mhop , & peer , & local , ifindex , vrfid , "'my discriminator' is zero" ) ; return ; } bfd = ptm_bfd_sess_find ( cp , & peer , & local , ifp , vrfid , is_mhop ) ; if ( bfd == NULL ) { cp_debug ( is_mhop , & peer , & local , ifindex , vrfid , "no session found" ) ; return ; } if ( bfd && bfd -> vrf && bfd -> vrf != bvrf -> vrf ) { cp_debug ( is_mhop , & peer , & local , ifindex , vrfid , "wrong vrfid." ) ; return ; } if ( ! cp -> discrs . remote_discr && bfd -> ses_state != PTM_BFD_DOWN && bfd -> ses_state != PTM_BFD_ADM_DOWN ) { cp_debug ( is_mhop , & peer , & local , ifindex , vrfid , "'remote discriminator' is zero, not overridden" ) ; return ; } if ( is_mhop ) { if ( ttl < bfd -> mh_ttl ) { cp_debug ( is_mhop , & peer , & local , ifindex , vrfid , "exceeded max hop count (expected %d, got %d)" , bfd -> mh_ttl , ttl ) ; return ; } } else { if ( bfd -> local_address . sa_sin . sin_family == AF_UNSPEC ) { bfd -> local_address = local ; } if ( ifp ) { bfd_peer_mac_set ( sd , bfd , & peer , ifp ) ; } } bfd -> stats . rx_ctrl_pkt ++ ; if ( ! is_mhop && bfd -> ifp == NULL ) { bfd -> ifp = ifp ; } if ( ( bfd -> discrs . remote_discr != 0 ) && ( bfd -> discrs . remote_discr != ntohl ( cp -> discrs . my_discr ) ) ) { cp_debug ( is_mhop , & peer , & local , ifindex , vrfid , "remote discriminator mismatch (expected %u, got %u)" , bfd -> discrs . remote_discr , ntohl ( cp -> discrs . my_discr ) ) ; } bfd -> discrs . remote_discr = ntohl ( cp -> discrs . my_discr ) ; bfd -> remote_diag = cp -> diag & BFD_DIAGMASK ; bfd -> remote_timers . desired_min_tx = ntohl ( cp -> timers . desired_min_tx ) ; bfd -> remote_timers . required_min_rx = ntohl ( cp -> timers . required_min_rx ) ; bfd -> remote_timers . required_min_echo = ntohl ( cp -> timers . required_min_echo ) ; bfd -> remote_detect_mult = cp -> detect_mult ; if ( BFD_GETCBIT ( cp -> flags ) ) { bfd -> remote_cbit = 1 ; } else { bfd -> remote_cbit = 0 ; } bs_state_handler ( bfd , BFD_GETSTATE ( cp -> flags ) ) ; if ( bfd -> polling && BFD_GETFBIT ( cp -> flags ) ) { bfd -> polling = 0 ; bs_final_handler ( bfd ) ; } if ( bfd -> cur_timers . required_min_rx > bfd -> remote_timers . desired_min_tx ) { bfd -> detect_TO = bfd -> remote_detect_mult * bfd -> cur_timers . required_min_rx ; } else { bfd -> detect_TO = bfd -> remote_detect_mult * bfd -> remote_timers . desired_min_tx ; } bfd_recvtimer_update ( bfd ) ; bs_echo_timer_handler ( bfd ) ; if ( BFD_GETPBIT ( cp -> flags ) ) { bs_final_handler ( bfd ) ; ptm_bfd_snd ( bfd , 1 ) ; } } 