static int tegra_fuse_probe ( struct platform_device * pdev ) { void __iomem * base = fuse -> base ; struct nvmem_config nvmem ; struct resource * res ; int err ; err = devm_add_action ( & pdev -> dev , tegra_fuse_restore , ( void __force * ) base ) ; if ( err ) { return err ; } res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; fuse -> phys = res -> start ; fuse -> base = devm_ioremap_resource ( & pdev -> dev , res ) ; if ( IS_ERR ( fuse -> base ) ) { err = PTR_ERR ( fuse -> base ) ; return err ; } fuse -> clk = devm_clk_get ( & pdev -> dev , "fuse" ) ; if ( IS_ERR ( fuse -> clk ) ) { if ( PTR_ERR ( fuse -> clk ) != - EPROBE_DEFER ) { dev_err ( & pdev -> dev , "failed to get FUSE clock: %ld" , PTR_ERR ( fuse -> clk ) ) ; } return PTR_ERR ( fuse -> clk ) ; } platform_set_drvdata ( pdev , fuse ) ; fuse -> dev = & pdev -> dev ; err = devm_pm_runtime_enable ( & pdev -> dev ) ; if ( err ) { return err ; } if ( fuse -> soc -> probe ) { err = fuse -> soc -> probe ( fuse ) ; if ( err < 0 ) { return err ; } } nvmem . dev = & pdev -> dev ; nvmem . name = "fuse" ; nvmem . id = - 1 ; nvmem . owner = THIS_MODULE ; nvmem . cells = fuse -> soc -> cells ; nvmem . ncells = fuse -> soc -> num_cells ; nvmem . keepout = fuse -> soc -> keepouts ; nvmem . nkeepout = fuse -> soc -> num_keepouts ; nvmem . type = NVMEM_TYPE_OTP ; nvmem . read_only = true ; nvmem . root_only = true ; nvmem . reg_read = tegra_fuse_read ; nvmem . size = fuse -> soc -> info -> size ; nvmem . word_size = 4 ; nvmem . stride = 4 ; nvmem . priv = fuse ; fuse -> nvmem = devm_nvmem_register ( & pdev -> dev , & nvmem ) ; if ( IS_ERR ( fuse -> nvmem ) ) { err = PTR_ERR ( fuse -> nvmem ) ; dev_err ( & pdev -> dev , "failed to register NVMEM device: %d\n" , err ) ; return err ; } fuse -> rst = devm_reset_control_get_optional ( & pdev -> dev , "fuse" ) ; if ( IS_ERR ( fuse -> rst ) ) { err = PTR_ERR ( fuse -> rst ) ; dev_err ( & pdev -> dev , "failed to get FUSE reset: %pe\n" , fuse -> rst ) ; return err ; } err = pm_runtime_resume_and_get ( & pdev -> dev ) ; if ( err ) { return err ; } err = reset_control_reset ( fuse -> rst ) ; pm_runtime_put ( & pdev -> dev ) ; if ( err < 0 ) { dev_err ( & pdev -> dev , "failed to reset FUSE: %d\n" , err ) ; return err ; } iounmap ( base ) ; return 0 ; } 