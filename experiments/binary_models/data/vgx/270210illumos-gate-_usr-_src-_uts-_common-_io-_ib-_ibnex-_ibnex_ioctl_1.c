static int ibnex_get_snapshot ( char * * buf , size_t * sz , int allow_probe ) { int i , j , k , l , hca_count ; nvlist_t * nvl ; ib_pkey_t pkey ; boolean_t found ; ibdm_ioc_info_t * ioc_listp ; ibdm_ioc_info_t * iocp ; ibdm_hca_list_t * hca_list , * hcap ; ibdm_port_attr_t * port_attr ; ibnex_node_data_t * nodep ; ASSERT ( mutex_owned ( & ibnex . ibnex_mutex ) ) ; * buf = NULL ; * sz = 0 ; if ( ! ibnex . ibnex_pseudo_inited ) { mutex_exit ( & ibnex . ibnex_mutex ) ; ibnex_pseudo_initnodes ( ) ; mutex_enter ( & ibnex . ibnex_mutex ) ; ibnex . ibnex_pseudo_inited = 1 ; } mutex_exit ( & ibnex . ibnex_mutex ) ; ibdm_ibnex_get_hca_list ( & hca_list , & hca_count ) ; mutex_enter ( & ibnex . ibnex_mutex ) ; ( void ) nvlist_alloc ( & nvl , 0 , KM_SLEEP ) ; for ( hcap = hca_list , i = 0 ; i < hca_count ; hca_list = hca_list -> hl_next , i ++ ) { IBTF_DPRINTF_L4 ( "ibnex" , "ibnex_get_snapshot: " "fill in  COMM service HCA_SVC nodes" ) ; port_attr = hca_list -> hl_hca_port_attr ; for ( j = 0 ; j < ibnex . ibnex_nhcasvc_comm_svcs ; j ++ ) { if ( ibnex_get_commsvcnode_snapshot ( & nvl , port_attr -> pa_hca_guid , port_attr -> pa_hca_guid , j , ( ib_pkey_t ) 0 , IBNEX_HCASVC_COMMSVC_NODE ) != 0 ) { IBTF_DPRINTF_L2 ( "ibnex" , "ibnex_get_snapshot: failed to fill" " HCA_SVC device (%x %x)" , i , j ) ; ibdm_ibnex_free_hca_list ( hcap ) ; return ( - 1 ) ; } } for ( j = 0 ; j < hca_list -> hl_nports ; j ++ ) { port_attr = & hca_list -> hl_port_attr [ j ] ; IBTF_DPRINTF_L4 ( "ibnex" , "ibnex_get_snapshot: " "fill in  COMM service Port nodes" ) ; for ( k = 0 ; k < ibnex . ibnex_num_comm_svcs ; k ++ ) { if ( ibnex_get_commsvcnode_snapshot ( & nvl , port_attr -> pa_hca_guid , port_attr -> pa_port_guid , k , ( ib_pkey_t ) 0 , IBNEX_PORT_COMMSVC_NODE ) != 0 ) { IBTF_DPRINTF_L2 ( "ibnex" , "ibnex_get_snapshot: failed to fill" " Port device (%x %x %x)" , i , j , k ) ; ibdm_ibnex_free_hca_list ( hcap ) ; nvlist_free ( nvl ) ; return ( - 1 ) ; } } IBTF_DPRINTF_L4 ( "ibnex" , "ibnex_get_snapshot: " "fill in  VPPA service port nodes" ) ; for ( l = 0 ; l < port_attr -> pa_npkeys ; l ++ ) { pkey = port_attr -> pa_pkey_tbl [ l ] . pt_pkey ; if ( IBNEX_INVALID_PKEY ( pkey ) ) { continue ; } for ( k = 0 ; k < ibnex . ibnex_nvppa_comm_svcs ; k ++ ) { if ( ibnex_get_commsvcnode_snapshot ( & nvl , port_attr -> pa_hca_guid , port_attr -> pa_port_guid , k , pkey , IBNEX_VPPA_COMMSVC_NODE ) != 0 ) { IBTF_DPRINTF_L2 ( "ibnex" , "ibnex_get_snapshot: " "failed to fill VPPA " "device (%x %x %x % x)" , i , j , k , l ) ; ibdm_ibnex_free_hca_list ( hcap ) ; nvlist_free ( nvl ) ; return ( - 1 ) ; } } } } } if ( hcap ) { ibdm_ibnex_free_hca_list ( hcap ) ; } mutex_exit ( & ibnex . ibnex_mutex ) ; iocp = ioc_listp = ibdm_ibnex_get_ioc_list ( allow_probe ) ; mutex_enter ( & ibnex . ibnex_mutex ) ; for ( ; ioc_listp != NULL ; ioc_listp = ioc_listp -> ioc_next ) { if ( ibnex . ibnex_ioc_node_head == NULL ) { if ( ibnex_fill_ioc_tmp ( & nvl , ioc_listp ) != 0 ) { IBTF_DPRINTF_L2 ( "ibnex" , "ibnex_get_snapshot: " "filling NVL data failed" ) ; ibdm_ibnex_free_ioc_list ( iocp ) ; nvlist_free ( nvl ) ; return ( - 1 ) ; } continue ; } else { found = B_FALSE ; for ( nodep = ibnex . ibnex_ioc_node_head ; nodep != NULL ; nodep = nodep -> node_next ) { if ( ioc_listp -> ioc_profile . ioc_guid == nodep -> node_data . ioc_node . ioc_guid ) { found = B_TRUE ; break ; } } if ( found == B_TRUE ) { if ( ibnex_fill_nodeinfo ( & nvl , nodep , & ioc_listp -> ioc_profile ) != 0 ) { IBTF_DPRINTF_L2 ( "ibnex" , "ibnex_get_snapshot: filling NVL " "for IOC node %p failed" , nodep ) ; ibdm_ibnex_free_ioc_list ( iocp ) ; nvlist_free ( nvl ) ; return ( - 1 ) ; } } else { if ( ibnex_fill_ioc_tmp ( & nvl , ioc_listp ) != 0 ) { IBTF_DPRINTF_L2 ( "ibnex" , "ibnex_get_snapshot: filling NVL " "tmp for IOC node %p failed" , ioc_listp ) ; ibdm_ibnex_free_ioc_list ( iocp ) ; nvlist_free ( nvl ) ; return ( - 1 ) ; } } } } ibdm_ibnex_free_ioc_list ( iocp ) ; for ( nodep = ibnex . ibnex_ioc_node_head ; nodep != NULL ; nodep = nodep -> node_next ) { if ( nodep -> node_data . ioc_node . ioc_ngids == 0 && nodep -> node_data . ioc_node . ioc_profile != NULL && nodep -> node_state != IBNEX_CFGADM_UNCONFIGURED ) { if ( ibnex_fill_nodeinfo ( & nvl , nodep , nodep -> node_data . ioc_node . ioc_profile ) != 0 ) { IBTF_DPRINTF_L2 ( "ibnex" , "ibnex_get_snapshot: filling NVL " "for disconnected IOC node %p " "failed" , nodep ) ; nvlist_free ( nvl ) ; return ( - 1 ) ; } } } for ( nodep = ibnex . ibnex_pseudo_node_head ; nodep ; nodep = nodep -> node_next ) { if ( nodep -> node_data . pseudo_node . pseudo_merge_node == 1 ) { continue ; } if ( ibnex_fill_nodeinfo ( & nvl , nodep , NULL ) != 0 ) { IBTF_DPRINTF_L2 ( "ibnex" , "ibnex_get_snapshot: " "filling NVL data for Pseudo %p failed" , nodep ) ; nvlist_free ( nvl ) ; return ( - 1 ) ; } } if ( nvlist_pack ( nvl , buf , sz , NV_ENCODE_NATIVE , KM_SLEEP ) ) { IBTF_DPRINTF_L2 ( "ibnex" , "ibnex_get_snapshot: nvlist_pack failed" ) ; nvlist_free ( nvl ) ; return ( - 1 ) ; } IBTF_DPRINTF_L4 ( "ibnex" , "ibnex_get_snapshot: size = 0x%x" , * sz ) ; nvlist_free ( nvl ) ; return ( 0 ) ; } 