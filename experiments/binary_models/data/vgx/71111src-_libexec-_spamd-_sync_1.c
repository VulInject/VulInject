void sync_update ( time_t now , char * helo , char * ip , char * from , char * to ) { struct iovec iov [ 7 ] ; struct spam_synchdr hdr ; struct spam_synctlv_grey sg ; struct spam_synctlv_hdr end ; u_int16_t sglen , fromlen , tolen , helolen , padlen ; char pad [ SPAM_ALIGNBYTES ] ; int i = 0 ; HMAC_CTX * ctx ; u_int hmac_len ; if ( debug ) { fprintf ( stderr , "sync grey update helo %s ip %s from %s to %s\n" , helo , ip , from , to ) ; } memset ( & hdr , 0 , sizeof ( hdr ) ) ; memset ( & sg , 0 , sizeof ( sg ) ) ; fromlen = strlen ( from ) + 1 ; tolen = strlen ( to ) + 1 ; helolen = strlen ( helo ) + 1 ; if ( ( ctx = HMAC_CTX_new ( ) ) == NULL ) { bad } if ( ! HMAC_Init_ex ( ctx , sync_key , strlen ( sync_key ) , EVP_sha1 ( ) , NULL ) ) { bad } sglen = sizeof ( sg ) + fromlen + tolen + helolen ; padlen = SPAM_ALIGN ( sglen ) - sglen ; hdr . sh_version = SPAM_SYNC_VERSION ; hdr . sh_af = AF_INET ; hdr . sh_counter = htonl ( sync_counter ++ ) ; hdr . sh_length = htons ( sizeof ( hdr ) + sglen + padlen + sizeof ( end ) ) ; iov [ i ] . iov_base = & hdr ; iov [ i ] . iov_len = sizeof ( hdr ) ; if ( ! HMAC_Update ( ctx , iov [ i ] . iov_base , iov [ i ] . iov_len ) ) { bad } i ++ ; sg . sg_type = htons ( SPAM_SYNC_GREY ) ; sg . sg_length = htons ( sglen + padlen ) ; sg . sg_timestamp = htonl ( now ) ; sg . sg_ip = inet_addr ( ip ) ; sg . sg_from_length = htons ( fromlen ) ; sg . sg_to_length = htons ( tolen ) ; sg . sg_helo_length = htons ( helolen ) ; iov [ i ] . iov_base = & sg ; iov [ i ] . iov_len = sizeof ( sg ) ; if ( ! HMAC_Update ( ctx , iov [ i ] . iov_base , iov [ i ] . iov_len ) ) { bad } i ++ ; iov [ i ] . iov_base = from ; iov [ i ] . iov_len = fromlen ; if ( ! HMAC_Update ( ctx , iov [ i ] . iov_base , iov [ i ] . iov_len ) ) { bad } i ++ ; iov [ i ] . iov_base = to ; iov [ i ] . iov_len = tolen ; if ( ! HMAC_Update ( ctx , iov [ i ] . iov_base , iov [ i ] . iov_len ) ) { bad } i ++ ; iov [ i ] . iov_base = helo ; iov [ i ] . iov_len = helolen ; if ( ! HMAC_Update ( ctx , iov [ i ] . iov_base , iov [ i ] . iov_len ) ) { bad } i ++ ; iov [ i ] . iov_base = pad ; iov [ i ] . iov_len = padlen ; if ( ! HMAC_Update ( ctx , iov [ i ] . iov_base , iov [ i ] . iov_len ) ) { bad } i ++ ; end . st_type = htons ( SPAM_SYNC_END ) ; end . st_length = htons ( sizeof ( end ) ) ; iov [ i ] . iov_base = & end ; iov [ i ] . iov_len = sizeof ( end ) ; if ( ! HMAC_Update ( ctx , iov [ i ] . iov_base , iov [ i ] . iov_len ) ) { bad } i ++ ; if ( ! HMAC_Final ( ctx , hdr . sh_hmac , & hmac_len ) ) { bad } sync_send ( iov , i ) ; bad HMAC_CTX_free ( ctx ) ; } 