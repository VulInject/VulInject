static int test_ratelimiting ( void ) { struct event_base * base ; struct sockaddr_in sin ; struct evconnlistener * listener ; struct sockaddr_storage ss ; ev_socklen_t slen ; int i ; struct timeval tv ; ev_uint64_t total_received ; double total_sq_persec , total_persec ; double variance ; double expected_total_persec = - 1.0 , expected_avg_persec = - 1.0 ; int ok = 1 ; struct event_config * base_cfg ; struct event * periodic_level_check ; struct event * group_drain_event = NULL ; memset ( & sin , 0 , sizeof ( sin ) ) ; sin . sin_family = AF_INET ; sin . sin_addr . s_addr = htonl ( 0x7f000001 ) ; sin . sin_port = 0 ; if ( 0 ) { event_enable_debug_mode ( ) ; } base_cfg = event_config_new ( ) ; if ( cfg_enable_iocp ) { evthread_use_windows_threads ( ) ; event_config_set_flag ( base_cfg , EVENT_BASE_FLAG_STARTUP_IOCP ) ; } base = event_base_new_with_config ( base_cfg , NULL ) ; event_config_free ( base_cfg ) ; if ( ! base ) { fprintf ( stderr , "Couldn't create event_base" ) ; return 1 ; } listener = evconnlistener_new_bind ( base , echo_listenercb , base , LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE , - 1 , ( sockaddr * ) & sin , sizeof ( sin ) ) ; if ( ! listener ) { fprintf ( stderr , "Couldn't create listener" ) ; return 1 ; } slen = sizeof ( ss ) ; if ( getsockname ( evconnlistener_get_fd ( listener ) , ( sockaddr * ) & ss , & slen ) < 0 ) { perror ( "getsockname" ) ; return 1 ; } if ( cfg_connlimit > 0 ) { conn_bucket_cfg = ev_token_bucket_cfg_new ( cfg_connlimit , cfg_connlimit * 4 , cfg_connlimit , cfg_connlimit * 4 , & cfg_tick ) ; assert ( conn_bucket_cfg ) ; } if ( cfg_grouplimit > 0 ) { group_bucket_cfg = ev_token_bucket_cfg_new ( cfg_grouplimit , cfg_grouplimit * 4 , cfg_grouplimit , cfg_grouplimit * 4 , & cfg_tick ) ; group = ratelim_group = bufferevent_rate_limit_group_new ( base , group_bucket_cfg ) ; expected_total_persec = cfg_grouplimit - ( cfg_group_drain / seconds_per_tick ) ; expected_avg_persec = cfg_grouplimit / cfg_n_connections ; if ( cfg_connlimit > 0 && expected_avg_persec > cfg_connlimit ) { expected_avg_persec = cfg_connlimit ; } if ( cfg_min_share >= 0 ) { bufferevent_rate_limit_group_set_min_share ( ratelim_group , cfg_min_share ) ; } } if ( expected_avg_persec ( 0 && cfg_connlimit ) 0 ) { expected_avg_persec = cfg_connlimit ; } if ( expected_avg_persec > 0 ) { expected_avg_persec /= seconds_per_tick ; } if ( expected_total_persec > 0 ) { expected_total_persec /= seconds_per_tick ; } bevs = calloc ( cfg_n_connections , sizeof ( bufferevent * ) ) ; states = calloc ( cfg_n_connections , sizeof ( client_state ) ) ; for ( i = 0 ; i < cfg_n_connections ; ++ i ) { bevs [ i ] = bufferevent_socket_new ( base , - 1 , BEV_OPT_CLOSE_ON_FREE | BEV_OPT_THREADSAFE ) ; assert ( bevs [ i ] ) ; bufferevent_setcb ( bevs [ i ] , discard_readcb , loud_writecb , write_on_connectedcb , & states [ i ] ) ; bufferevent_enable ( bevs [ i ] , EV_READ | EV_WRITE ) ; bufferevent_socket_connect ( bevs [ i ] , ( sockaddr * ) & ss , slen ) ; } tv . tv_sec = cfg_duration - 1 ; tv . tv_usec = 995000 ; event_base_loopexit ( base , & tv ) ; tv . tv_sec = 0 ; tv . tv_usec = 100 * 1000 ; ms100_common = event_base_init_common_timeout ( base , & tv ) ; periodic_level_check = event_new ( base , - 1 , EV_PERSIST , check_group_bucket_levels_cb , NULL ) ; event_add ( periodic_level_check , ms100_common ) ; if ( cfg_group_drain && ratelim_group ) { group_drain_event = event_new ( base , - 1 , EV_PERSIST , group_drain_cb , NULL ) ; event_add ( group_drain_event , & cfg_tick ) ; } event_base_dispatch ( base ) ; ratelim_group = NULL ; event_free ( periodic_level_check ) ; if ( group_drain_event ) { event_del ( group_drain_event ) ; } for ( i = 0 ; i < cfg_n_connections ; ++ i ) { bufferevent_free ( bevs [ i ] ) ; } evconnlistener_free ( listener ) ; ratelim_group = NULL ; while ( n_echo_conns_open ) { printf ( "waiting for %d conns\n" , n_echo_conns_open ) ; tv . tv_sec = 0 ; tv . tv_usec = 300000 ; event_base_loopexit ( base , & tv ) ; event_base_dispatch ( base ) ; } if ( group ) { bufferevent_rate_limit_group_free ( group ) ; } if ( total_n_bev_checks ) { printf ( "Average read bucket level: %f\n" , ( double ) total_rbucket_level / total_n_bev_checks ) ; printf ( "Average write bucket level: %f\n" , ( double ) total_wbucket_level / total_n_bev_checks ) ; printf ( "Highest read bucket level: %f\n" , ( double ) max_bucket_level ) ; printf ( "Highest write bucket level: %f\n" , ( double ) min_bucket_level ) ; printf ( "Average max-to-read: %f\n" , ( ( double ) total_max_to_read ) / total_n_bev_checks ) ; printf ( "Average max-to-write: %f\n" , ( ( double ) total_max_to_write ) / total_n_bev_checks ) ; } if ( total_n_group_bev_checks ) { printf ( "Average group read bucket level: %f\n" , ( ( double ) total_group_rbucket_level ) / total_n_group_bev_checks ) ; printf ( "Average group write bucket level: %f\n" , ( ( double ) total_group_wbucket_level ) / total_n_group_bev_checks ) ; } total_received = 0 ; total_persec = 0.0 ; total_sq_persec = 0.0 ; for ( i = 0 ; i < cfg_n_connections ; ++ i ) { double persec = states [ i ] . received ; persec /= cfg_duration ; total_received += states [ i ] . received ; total_persec += persec ; total_sq_persec += persec * persec ; printf ( "%d: %f per second\n" , i + 1 , persec ) ; } printf ( "   total: %f per second\n" , ( ( double ) total_received ) / cfg_duration ) ; if ( expected_total_persec > 0 ) { double diff = expected_total_persec - ( ( double ) total_received / cfg_duration ) ; printf ( "  [Off by %lf]\n" , diff ) ; if ( cfg_grouplimit_tolerance > 0 && fabs ( diff ) > cfg_grouplimit_tolerance ) { fprintf ( stderr , "Group bandwidth out of bounds\n" ) ; ok = 0 ; } } printf ( " average: %f per second\n" , ( ( ( double ) total_received ) / cfg_duration ) / cfg_n_connections ) ; if ( expected_avg_persec > 0 ) { double diff = expected_avg_persec - ( ( ( double ) total_received ) / cfg_duration ) / cfg_n_connections ; printf ( "  [Off by %lf]\n" , diff ) ; if ( cfg_connlimit_tolerance > 0 && fabs ( diff ) > cfg_connlimit_tolerance ) { fprintf ( stderr , "Connection bandwidth out of bounds\n" ) ; ok = 0 ; } } variance = total_sq_persec / cfg_n_connections - total_persec * total_persec / ( cfg_n_connections * cfg_n_connections ) ; printf ( "  stddev: %f per second\n" , sqrt ( variance ) ) ; if ( cfg_stddev_tolerance > 0 && sqrt ( variance ) > cfg_stddev_tolerance ) { fprintf ( stderr , "Connection variance out of bounds\n" ) ; ok = 0 ; } event_base_free ( base ) ; free ( bevs ) ; free ( states ) ; return ok ?0 : 1 ; } 