static int clk_generated_determine_rate ( struct clk_hw * hw , struct clk_rate_request * req ) { struct clk_generated * gck = to_clk_generated ( hw ) ; struct clk_hw * parent = NULL ; long best_rate = - EINVAL ; unsigned long tmp_rate , min_rate ; int best_diff = - 1 ; int tmp_diff ; int i ; for ( i = 0 ; i < clk_hw_get_num_parents ( hw ) ; i ++ ) { u32 div ; unsigned long parent_rate ; parent = clk_hw_get_parent_by_index ( hw , i ) ; parent_rate = clk_hw_get_rate ( parent ) ; min_rate = DIV_ROUND_CLOSEST ( parent_rate , GENERATED_MAX_DIV + 1 ) ; if ( ! parent_rate || ( gck -> range . max && min_rate > gck -> range . max ) ) { continue ; } for ( div = 1 ; div < GENERATED_MAX_DIV + 2 ; div ++ ) { tmp_rate = DIV_ROUND_CLOSEST ( parent_rate , div ) ; tmp_diff = abs ( req -> rate - tmp_rate ) ; if ( best_diff ( 0 || best_diff ) tmp_diff ) { best_rate = tmp_rate ; best_diff = tmp_diff ; req -> best_parent_rate = parent_rate ; req -> best_parent_hw = parent ; } if ( ! best_diff || tmp_rate < req -> rate ) { break ; } } if ( ! best_diff ) { break ; } } pr_debug ( "GCLK: %s, best_rate = %ld, parent clk: %s @ %ld\n" , __func__ , best_rate , __clk_get_name ( ( req -> best_parent_hw ) -> clk ) , req -> best_parent_rate ) ; if ( best_rate < 0 ) { return best_rate ; } req -> rate = best_rate ; return 0 ; } 