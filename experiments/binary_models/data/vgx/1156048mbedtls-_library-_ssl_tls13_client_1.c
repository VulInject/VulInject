static int ssl_tls13_parse_certificate_request ( mbedtls_ssl_context * ssl , const unsigned char * buf , const unsigned char * end ) { int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED ; const unsigned char * p = buf ; size_t certificate_request_context_len = 0 ; size_t extensions_len = 0 ; const unsigned char * extensions_end ; mbedtls_ssl_handshake_params * handshake = ssl -> handshake ; MBEDTLS_SSL_CHK_BUF_READ_PTR ( p , end , 1 ) ; certificate_request_context_len = ( size_t ) p [ 0 ] ; p += 1 ; if ( certificate_request_context_len > 0 ) { MBEDTLS_SSL_CHK_BUF_READ_PTR ( p , end , certificate_request_context_len ) ; MBEDTLS_SSL_DEBUG_BUF ( 3 , "Certificate Request Context" , p , certificate_request_context_len ) ; handshake -> certificate_request_context = mbedtls_calloc ( 1 , certificate_request_context_len ) ; if ( handshake -> certificate_request_context == NULL ) { MBEDTLS_SSL_DEBUG_MSG ( 1 , ( "buffer too small" ) ) ; return MBEDTLS_ERR_SSL_ALLOC_FAILED ; } memcpy ( handshake -> certificate_request_context , p , certificate_request_context_len ) ; p += certificate_request_context_len ; } MBEDTLS_SSL_CHK_BUF_READ_PTR ( p , end , 2 ) ; extensions_len = MBEDTLS_GET_UINT16_BE ( p , 0 ) ; p += 2 ; MBEDTLS_SSL_CHK_BUF_READ_PTR ( p , end , extensions_len ) ; extensions_end = p + extensions_len ; handshake -> received_extensions = MBEDTLS_SSL_EXT_MASK_NONE ; while ( p < extensions_end ) { unsigned int extension_type ; size_t extension_data_len ; MBEDTLS_SSL_CHK_BUF_READ_PTR ( p , extensions_end , 4 ) ; extension_type = MBEDTLS_GET_UINT16_BE ( p , 0 ) ; extension_data_len = MBEDTLS_GET_UINT16_BE ( p , 2 ) ; p += 4 ; MBEDTLS_SSL_CHK_BUF_READ_PTR ( p , extensions_end , extension_data_len ) ; ret = mbedtls_ssl_tls13_check_received_extension ( ssl , MBEDTLS_SSL_HS_CERTIFICATE_REQUEST , extension_type , MBEDTLS_SSL_TLS1_3_ALLOWED_EXTS_OF_CR ) ; if ( ret != 0 ) { return ret ; } switch ( extension_type ) { case MBEDTLS_TLS_EXT_SIG_ALG : MBEDTLS_SSL_DEBUG_MSG ( 3 , ( "found signature algorithms extension" ) ) ; ret = mbedtls_ssl_parse_sig_alg_ext ( ssl , p , p + extension_data_len ) ; if ( ret != 0 ) { return ret ; } break ; default : MBEDTLS_SSL_PRINT_EXT ( 3 , MBEDTLS_SSL_HS_CERTIFICATE_REQUEST , extension_type , "( ignored )" ) ; break ; } p += extension_data_len ; } MBEDTLS_SSL_PRINT_EXTS ( 3 , MBEDTLS_SSL_HS_CERTIFICATE_REQUEST , handshake -> received_extensions ) ; if ( p != end ) { MBEDTLS_SSL_DEBUG_MSG ( 1 , ( "CertificateRequest misaligned" ) ) ; decode_error } if ( ( handshake -> received_extensions & MBEDTLS_SSL_EXT_MASK ( SIG_ALG ) ) == 0 ) { MBEDTLS_SSL_DEBUG_MSG ( 3 , ( "no signature algorithms extension found" ) ) ; decode_error } return 0 ; decode_error MBEDTLS_SSL_PEND_FATAL_ALERT ( MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR , MBEDTLS_ERR_SSL_DECODE_ERROR ) ; return MBEDTLS_ERR_SSL_DECODE_ERROR ; } 