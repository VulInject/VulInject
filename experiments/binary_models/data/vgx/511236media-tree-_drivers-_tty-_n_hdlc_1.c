static ssize_t n_hdlc_tty_read ( struct tty_struct * tty , struct file * file , __u8 __user * buf , size_t nr ) { struct n_hdlc * n_hdlc = tty2n_hdlc ( tty ) ; int ret = 0 ; struct n_hdlc_buf * rbuf ; DECLARE_WAITQUEUE ( wait , current ) ; if ( debuglevel >= DEBUG_LEVEL_INFO ) { printk ( "%s(%d)n_hdlc_tty_read() called\n" , __FILE__ , __LINE__ ) ; } if ( ! n_hdlc ) { return - EIO ; } if ( ! access_ok ( VERIFY_WRITE , buf , nr ) ) { printk ( KERN_WARNING "%s(%d) n_hdlc_tty_read() can't verify user " "buffer\n" , __FILE__ , __LINE__ ) ; return - EFAULT ; } add_wait_queue ( & tty -> read_wait , & wait ) ; for ( ; ; ) { if ( test_bit ( TTY_OTHER_CLOSED , & tty -> flags ) ) { ret = - EIO ; break ; } if ( tty_hung_up_p ( file ) ) { break ; } set_current_state ( TASK_INTERRUPTIBLE ) ; rbuf = n_hdlc_buf_get ( & n_hdlc -> rx_buf_list ) ; if ( rbuf ) { if ( rbuf -> count > nr ) { ret = - EOVERFLOW ; } else { if ( copy_to_user ( buf , rbuf -> buf , rbuf -> count ) ) { ret = - EFAULT ; } else { ret = rbuf -> count ; } } if ( n_hdlc -> rx_free_buf_list . count > DEFAULT_RX_BUF_COUNT ) { kfree ( rbuf ) ; } else { n_hdlc_buf_put ( & n_hdlc -> rx_free_buf_list , rbuf ) ; } break ; } if ( file -> f_flags & O_NONBLOCK ) { ret = - EAGAIN ; break ; } schedule ( ) ; if ( signal_pending ( current ) ) { ret = - EINTR ; break ; } } remove_wait_queue ( & tty -> read_wait , & wait ) ; __set_current_state ( TASK_RUNNING , NULL ) ; return ret ; } 