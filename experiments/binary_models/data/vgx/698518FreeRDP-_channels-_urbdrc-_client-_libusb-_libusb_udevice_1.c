static IUDEVICE * udev_init ( URBDRC_PLUGIN * urbdrc , libusb_context * context , LIBUSB_DEVICE * device , BYTE bus_number , BYTE dev_number ) { UDEVICE * pdev ; int status = LIBUSB_ERROR_OTHER ; LIBUSB_DEVICE_DESCRIPTOR * devDescriptor ; LIBUSB_CONFIG_DESCRIPTOR * config_temp ; LIBUSB_INTERFACE_DESCRIPTOR interface_temp ; WINPR_ASSERT ( urbdrc ) ; pdev = ( PUDEVICE ) calloc ( 1 , sizeof ( UDEVICE ) ) ; if ( ! pdev ) { return in ; } pdev -> urbdrc = urbdrc ; udev_load_interface ( pdev ) ; if ( device ) { pdev -> libusb_dev = device ; } else { pdev -> libusb_dev = udev_get_libusb_dev ( context , bus_number , dev_number ) ; } if ( pdev -> libusb_dev == NULL ) { fail } if ( urbdrc -> listener_callback ) { udev_set_channelManager ( & pdev -> iface , urbdrc -> listener_callback -> channel_mgr ) ; } status = udev_get_device_handle ( urbdrc , context , pdev , bus_number , dev_number ) ; if ( status != LIBUSB_SUCCESS ) { struct libusb_device_descriptor desc ; const uint8_t port = libusb_get_port_number ( pdev -> libusb_dev ) ; libusb_get_device_descriptor ( pdev -> libusb_dev , & desc ) ; log_libusb_result ( urbdrc -> log , WLOG_ERROR , "libusb_open [b=0x%02X,p=0x%02X,a=0x%02X,VID=0x%04X,PID=0x%04X]" , status , bus_number , port , dev_number , desc . idVendor , desc . idProduct ) ; fail } status = udev_get_hub_handle ( urbdrc , context , pdev , bus_number , dev_number ) ; if ( status < 0 ) { pdev -> hub_handle = NULL ; } pdev -> devDescriptor = udev_new_descript ( urbdrc , pdev -> libusb_dev ) ; if ( ! pdev -> devDescriptor ) { fail } status = libusb_get_active_config_descriptor ( pdev -> libusb_dev , & pdev -> LibusbConfig ) ; if ( status == LIBUSB_ERROR_NOT_FOUND ) { status = libusb_get_config_descriptor ( pdev -> libusb_dev , 0 , & pdev -> LibusbConfig ) ; } if ( status < 0 ) { fail } config_temp = pdev -> LibusbConfig ; interface_temp = config_temp -> interface [ 0 ] . altsetting [ 0 ] ; WLog_Print ( urbdrc -> log , WLOG_DEBUG , "Registered Device: Vid: 0x%04" PRIX16 " Pid: 0x%04" PRIX16 "" " InterfaceClass = %s" , pdev -> devDescriptor -> idVendor , pdev -> devDescriptor -> idProduct , usb_interface_class_to_string ( interface_temp . bInterfaceClass ) ) ; devDescriptor = pdev -> devDescriptor ; if ( ( devDescriptor -> bNumConfigurations == 1 ) && ( config_temp -> bNumInterfaces > 1 ) && ( devDescriptor -> bDeviceClass == LIBUSB_CLASS_PER_INTERFACE ) ) { pdev -> isCompositeDevice = 1 ; } if ( ( devDescriptor -> bDeviceClass == 0xef ) && ( devDescriptor -> bDeviceSubClass == LIBUSB_CLASS_COMM ) && ( devDescriptor -> bDeviceProtocol == 0x01 ) ) { pdev -> isCompositeDevice = 1 ; } else { pdev -> isCompositeDevice = 0 ; } devDescriptor -> bDeviceClass = interface_temp . bInterfaceClass ; devDescriptor -> bDeviceSubClass = interface_temp . bInterfaceSubClass ; devDescriptor -> bDeviceProtocol = interface_temp . bInterfaceProtocol ; pdev -> bus_number = bus_number ; pdev -> dev_number = dev_number ; pdev -> request_queue = ArrayList_New ( TRUE ) ; if ( ! pdev -> request_queue ) { fail } ArrayList_Object ( pdev -> request_queue ) -> fnObjectFree = request_free ; pdev -> MsConfig = msusb_msconfig_new ( ) ; if ( ! pdev -> MsConfig ) { fail } return & pdev -> iface ; fail pdev -> iface . free ( & pdev -> iface ) ; return NULL ; } 