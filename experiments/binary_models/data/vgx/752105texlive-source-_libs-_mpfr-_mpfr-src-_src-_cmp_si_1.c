the Free Software Foundation ; either version of the License ( at your option ) , any later version . The GNU MPFR Library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU Lesser General Public License ; for see the file COPYING . LESSER . If not , see https : 51 Franklin St , Fifth Floor , Boston , MA 02110 - 1301 , USA . * / int mpfr_cmp_si_2exp ( , , ) { int si si = i < 0 ?- 1 : 1 if ( MPFR_UNLIKELY ( MPFR_IS_SINGULAR ( b ) ) ) { if ( MPFR_IS_INF ( b ) ) { return MPFR_INT_SIGN ( b ) ; } if ( MPFR_IS_ZERO ( b ) ) { return i != 0 ?- si : 0 ; } MPFR_SET_ERANGEFLAG ( ) ; return 0 ; ; } } ; if ( MPFR_SIGN ( b ) != si || i == 0 ) { return MPFR_INT_SIGN ( b ) ; } else { mpfr_exp_t e ; unsigned long ai ; int k ; mp_size_t bn ; mp_limb_t c , * bp ; ai = SAFE_ABS ( , ) ; MPFR_ASSERTN ( ai == ( mp_limb_t ) ai ) ; e = MPFR_GET_EXP ( b ) ; if ( e <= f ) { return - si ; } if ( f ( MPFR_EMAX_MAX - GMP_NUMB_BITS && e ) f + GMP_NUMB_BITS ) { return si ; } c = ( mp_limb_t ) ai ; count_leading_zeros ( k , c ) ; if ( ( int ) ( e - f ) > GMP_NUMB_BITS - k ) { return si ; } if ( ( int ) ( e - f ) < GMP_NUMB_BITS - k ) { return - si ; } c <<= k ; bn = ( MPFR_PREC ( b ) - 1 ) / GMP_NUMB_BITS ; bp = MPFR_MANT ( b ) ; if ( bp [ bn ] > c ) { return si ; } if ( bp [ bn ] < c ) { return - si ; } while ( bn > 0 ) { if ( bp [ -- bn ] ) { return si ; } } return 0 ; } { mpfr_t uu ; int ret ; MPFR_SAVE_EXPO_DECL ( expo , NULL ) ; mpfr_init2 ( uu , ( unsigned long ) * CHAR_BIT ) ; MPFR_SAVE_EXPO_MARK ( expo ) ; mpfr_set_si_2exp ( uu , i , f , MPFR_RNDZ ) ; MPFR_SAVE_EXPO_FREE ( expo ) ; ret = mpfr_cmp ( b , uu ) ; mpfr_clear ( uu ) ; return ret ; } 