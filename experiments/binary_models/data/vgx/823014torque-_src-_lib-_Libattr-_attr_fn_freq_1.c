int decode_frequency ( pbs_attribute * patr , const char * UNUSED ( name ) , const char * UNUSED ( rescn ) , const char * val , int UNUSED ( perm ) ) { patr -> at_val . at_frequency . frequency_type = Invalid ; patr -> at_val . at_frequency . mhz = 0 ; if ( ( val != NULL ) && ( val [ 0 ] != '\0' ) ) { if ( to_frequency ( val , & patr -> at_val . at_frequency ) != 0 ) { return ( PBSE_BADATVAL ) ; } patr -> at_flags |= ATR_VFLAG_SET | ATR_VFLAG_MODIFY ; } else { patr -> at_flags = ( patr -> at_flags & ~ ATR_VFLAG_SET ) | ATR_VFLAG_MODIFY ; } return ( 0 ) ; } int encode_frequency ( pbs_attribute * attr , tlist_head * phead , const char * atname , const char * rsname , int UNUSED ( mode ) , int UNUSED ( perm ) ) { size_t ct ; char cvnbuf [ ENCODE_FREQUENCY_SIZE ] ; svrattrl * pal ; if ( ! ( attr -> at_flags & ATR_VFLAG_SET ) ) { return ( 0 ) ; } from_frequency ( & attr -> at_val . at_frequency , cvnbuf ) ; ct = strlen ( cvnbuf ) ; pal = attrlist_create ( atname , rsname , ct + 1 ) ; if ( pal == NULL ) { return ( - 1 ) ; } memcpy ( pal -> al_value , cvnbuf , ct ) ; pal -> al_flags = attr -> at_flags ; append_link ( phead , & pal -> al_link , pal ) ; return ( 1 ) ; } int set_frequency ( pbs_attribute * attr , pbs_attribute * new_attr , enum batch_op op ) { assert ( attr && new_attr && ( new_attr -> at_flags & ATR_VFLAG_SET ) ) ; switch ( op ) { case SET : attr -> at_val . at_frequency . frequency_type = new_attr -> at_val . at_frequency . frequency_type ; attr -> at_val . at_frequency . mhz = new_attr -> at_val . at_frequency . mhz ; break ; case INCR : case DECR : default : return ( PBSE_INTERNAL ) ; } attr -> at_flags |= ATR_VFLAG_SET | ATR_VFLAG_MODIFY ; return ( 0 ) ; } int comp_frequency ( pbs_attribute * attr , pbs_attribute * with ) { if ( attr -> at_val . at_frequency . frequency_type != with -> at_val . at_frequency . frequency_type ) { return 1 ; } if ( attr -> at_val . at_frequency . frequency_type != AbsoluteFrequency ) { return 0 ; } if ( attr -> at_val . at_frequency . mhz == with -> at_val . at_frequency . mhz ) { return 0 ; } if ( attr -> at_val . at_frequency . mhz > with -> at_val . at_frequency . mhz ) { return 1 ; } return - 1 ; } int to_frequency ( const char * val , struct cpu_frequency_value * pfreq ) { if ( ( * val >= '0' ) && ( * val <= '9' ) ) { const char * pVal = val ; unsigned long iVal = 0l ; bool hasMhz = FALSE ; while ( * pVal ) { if ( ( * pVal < '0' ) || ( * pVal > '9' ) ) { if ( ( * pVal == 'M' ) || ( * pVal == 'm' ) ) { pVal ++ ; if ( ( * pVal == 'H' ) || ( * pVal == 'h' ) ) { pVal ++ ; if ( ( * pVal == 'Z' ) || ( * pVal == 'z' ) ) { pVal ++ ; if ( * pVal == '\0' ) { hasMhz = TRUE ; break ; } } } } return PBSE_BADATVAL ; } iVal = ( ( iVal * 10 ) + ( unsigned long ) ( * pVal - '0' ) ) ; pVal ++ ; } if ( iVal <= 15 ) { if ( hasMhz ) { return PBSE_BADATVAL ; } pfreq -> frequency_type = iVal ; pfreq -> mhz = 0 ; return 0 ; } pfreq -> frequency_type = AbsoluteFrequency ; pfreq -> mhz = iVal ; return 0 ; } if ( ( ( * val == 'p' ) || ( * val == 'P' ) ) && ( * ( val + 1 ) >= '0' ) && ( * ( val + 1 ) <= '9' ) ) { const char * pVal = val + 1 ; unsigned long iVal = 0l ; while ( * pVal ) { if ( ( * pVal < '0' ) || ( * pVal > '9' ) ) { return PBSE_BADATVAL ; } iVal = ( ( iVal * 10 ) + ( unsigned long ) ( * pVal - '0' ) ) ; pVal ++ ; } if ( iVal > 15 ) { return PBSE_BADATVAL ; } pfreq -> frequency_type = iVal ; pfreq -> mhz = 0 ; return 0 ; } pfreq -> mhz = 0 ; if ( ! strcasecmp ( val , "Performance" ) ) { pfreq -> frequency_type = Performance ; return 0 ; } if ( ! strcasecmp ( val , "PowerSave" ) ) { pfreq -> frequency_type = PowerSave ; return 0 ; } if ( ! strcasecmp ( val , "OnDemand" ) ) { pfreq -> frequency_type = OnDemand ; return 0 ; } if ( ! strcasecmp ( val , "Conservative" ) ) { pfreq -> frequency_type = Conservative ; return 0 ; } return ( PBSE_BADATVAL ) ; } void from_frequency ( struct cpu_frequency_value * pfreq , char * cvnbuf ) { switch ( pfreq -> frequency_type ) { case P0 : case P1 : case P2 : case P3 : case P4 : case P5 : case P6 : case P7 : case P8 : case P9 : case P10 : case P11 : case P12 : case P13 : case P14 : case P15 : sprintf ( cvnbuf , "P%u" , pfreq -> frequency_type ) ; break ; case Performance : strcpy ( cvnbuf , "Performance" ) ; break ; case PowerSave : strcpy ( cvnbuf , "PowerSave" ) ; break ; case OnDemand : strcpy ( cvnbuf , "OnDemand" ) ; break ; case Conservative : strcpy ( cvnbuf , "Conservative" ) ; break ; case UserSpace : strcpy ( cvnbuf , "UserSpace" ) ; break ; case AbsoluteFrequency : sprintf ( cvnbuf , "%luMHz" , pfreq -> mhz ) ; break ; default : cvnbuf [ 0 ] = '\0' ; break ; } } 