int c4iw_fill_res_cm_id_entry ( struct sk_buff * msg , struct rdma_cm_id * cm_id ) { struct nlattr * table_attr ; struct c4iw_ep_common * epcp ; struct c4iw_listen_ep * listen_ep = NULL ; struct c4iw_ep * ep = NULL ; struct iw_cm_id * iw_cm_id ; union union_ep * uep ; iw_cm_id = rdma_iw_cm_id ( cm_id ) ; if ( ! iw_cm_id ) { return 0 ; } epcp = ( c4iw_ep_common * ) iw_cm_id -> provider_data ; if ( ! epcp ) { return 0 ; } uep = kzalloc ( sizeof ( * uep ) , GFP_KERNEL ) ; if ( ! uep ) { return 0 ; } table_attr = nla_nest_start_noflag ( msg , RDMA_NLDEV_ATTR_DRIVER ) ; if ( ! table_attr ) { err_free_uep } mutex_lock ( & epcp -> mutex ) ; if ( epcp -> state == LISTEN ) { uep -> lep = * ( c4iw_listen_ep * ) epcp ; mutex_unlock ( & epcp -> mutex ) ; listen_ep = & uep -> lep ; epcp = & listen_ep -> com ; } else { uep -> ep = * ( c4iw_ep * ) epcp ; mutex_unlock ( & epcp -> mutex ) ; ep = & uep -> ep ; epcp = & ep -> com ; } if ( rdma_nl_put_driver_u32 ( msg , "state" , epcp -> state ) ) { err_cancel_table } if ( rdma_nl_put_driver_u64_hex ( msg , "flags" , epcp -> flags ) ) { err_cancel_table } if ( rdma_nl_put_driver_u64_hex ( msg , "history" , epcp -> history ) ) { err_cancel_table } if ( listen_ep ) { if ( rdma_nl_put_driver_u32 ( msg , "stid" , listen_ep -> stid ) ) { err_cancel_table } if ( rdma_nl_put_driver_u32 ( msg , "backlog" , listen_ep -> backlog ) ) { err_cancel_table } } else { if ( rdma_nl_put_driver_u32 ( msg , "hwtid" , ep -> hwtid ) ) { err_cancel_table } if ( rdma_nl_put_driver_u32 ( msg , "ord" , ep -> ord ) ) { err_cancel_table } if ( rdma_nl_put_driver_u32 ( msg , "ird" , ep -> ird ) ) { err_cancel_table } if ( rdma_nl_put_driver_u32 ( msg , "emss" , ep -> emss ) ) { err_cancel_table } if ( ! ep -> parent_ep && rdma_nl_put_driver_u32 ( msg , "atid" , ep -> atid ) ) { err_cancel_table } } nla_nest_end ( msg , table_attr ) ; return 0 ; err_cancel_table nla_nest_cancel ( msg , table_attr ) ; err_free_uep kfree ( uep ) ; return - EMSGSIZE ; } 