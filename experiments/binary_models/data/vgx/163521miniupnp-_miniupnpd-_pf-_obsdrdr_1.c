static int delete_nat_rule ( const char * ifname , unsigned short iport , int proto , in_addr_t iaddr ) { int i , n ; struct pfioc_rule pr ; UNUSED ( ifname ) ; if ( dev < 0 ) { syslog ( LOG_ERR , "pf device is not open" ) ; return - 1 ; } strlcpy ( pr . anchor , anchor_name , MAXPATHLEN ) ; pr . rule . action = PF_NAT ; pr . rule . action = PF_PASS ; pr . rule . direction = PF_OUT ; if ( ioctl ( dev , DIOCGETRULES , & pr ) < 0 ) { syslog ( LOG_ERR , "ioctl(dev, DIOCGETRULES, ...): %m" ) ; error } n = pr . nr ; for ( i = 0 ; i < n ; i ++ ) { pr . nr = i ; if ( ioctl ( dev , DIOCGETRULE , & pr ) < 0 ) { syslog ( LOG_ERR , "ioctl(dev, DIOCGETRULE): %m" ) ; error } syslog ( LOG_DEBUG , "%2d port=%hu proto=%d addr=%8x    %8x" , i , ntohs ( pr . rule . src . port [ 0 ] ) , pr . rule . proto , pr . rule . src . addr . v . a . addr . v4 . s_addr , iaddr ) ; if ( iport == ntohs ( pr . rule . src . port [ 0 ] ) && pr . rule . proto == proto && iaddr == pr . rule . src . addr . v . a . addr . v4 . s_addr ) { pr . action = PF_CHANGE_GET_TICKET ; if ( ioctl ( dev , DIOCCHANGERULE , & pr ) < 0 ) { syslog ( LOG_ERR , "ioctl(dev, DIOCCHANGERULE, ...) PF_CHANGE_GET_TICKET: %m" ) ; error } pr . action = PF_CHANGE_REMOVE ; pr . nr = i ; if ( ioctl ( dev , DIOCCHANGERULE , & pr ) < 0 ) { syslog ( LOG_ERR , "ioctl(dev, DIOCCHANGERULE, ...) PF_CHANGE_REMOVE: %m" ) ; error } return 0 ; } } syslog ( LOG_NOTICE , "could not find nat rule to delete iport=%hu addr=%8x" , iport , ntohl ( iaddr ) ) ; error return - 1 ; } 