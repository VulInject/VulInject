__nis_mapping_item_t * buildLvalue ( __nis_mapping_rlhs_t * rl , __nis_value_t * * rval , int * numItems ) { __nis_value_t * val , * r ; __nis_mapping_item_t * item = 0 ; int i , n , ni = 0 , nv = 0 ; int repeat ; if ( rl == 0 ) { return ( 0 ) ; } if ( rval != 0 ) { r = * rval ; repeat = r -> repeat ; } else { r = 0 ; } for ( i = 0 ; i < rl -> numElements ; i ++ ) { __nis_mapping_element_t * e = & rl -> element [ i ] ; __nis_mapping_item_t * olditem , * tmpitem = 0 ; __nis_value_t * * tmp ; switch ( e -> type ) { case me_item : tmpitem = cloneItem ( & e -> element . item ) ; break ; case me_match : tmp = matchMappingItem ( e -> element . match . fmt , r , & nv , 0 , 0 ) ; if ( tmp != 0 ) { freeValue ( r , 1 ) ; val = 0 ; for ( n = 0 ; n < nv ; n ++ ) { r = concatenateValues ( val , tmp [ n ] ) ; freeValue ( val , 1 ) ; freeValue ( tmp [ n ] , 1 ) ; val = r ; if ( val == 0 ) { for ( n ++ ; n < nv ; n ++ ) { freeValue ( tmp [ n ] , 1 ) ; } break ; } } free ( tmp ) ; if ( rval != 0 ) { if ( repeat && val != 0 ) { val -> repeat = repeat ; } * rval = val ; } for ( n = 0 ; n < e -> element . match . numItems ; n ++ ) { olditem = item ; item = concatenateMappingItem ( item , ni , & e -> element . match . item [ n ] ) ; freeMappingItem ( olditem , ni ) ; if ( item == 0 ) { ni = 0 ; break ; } ni ++ ; } } break ; case me_print : case me_split : case me_extract : default : break ; } if ( tmpitem != 0 ) { olditem = item ; item = concatenateMappingItem ( item , ni , tmpitem ) ; freeMappingItem ( olditem , ni ) ; freeMappingItem ( tmpitem , 1 ) ; ni ++ ; if ( item == 0 ) { ni = 0 ; break ; } } } if ( numItems != 0 ) { * numItems = ni ; } return ( item ) ; } 