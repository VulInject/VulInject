static int dshow_cycle_devices ( AVFormatContext * avctx , ICreateDevEnum * devenum , enum dshowDeviceType devtype , enum dshowSourceFilterType sourcetype , IBaseFilter * * pfilter , char * * device_unique_name , AVDeviceInfoList * * device_list ) { struct dshow_ctx * ctx = avctx -> priv_data ; IBaseFilter * device_filter = NULL ; IEnumMoniker * classenum = NULL ; IMoniker * m = NULL ; const char * device_name = ctx -> device_name [ devtype ] ; int skip = ( devtype == VideoDevice ) ?ctx -> video_device_number : ctx -> audio_device_number ; int r ; const GUID * device_guid [ 2 ] { & CLSID_VideoInputDeviceCategory & CLSID_AudioInputDeviceCategory } ; ; const char * devtypename = ( devtype == VideoDevice ) ?"video" : "audio only" ; const char * sourcetypename = ( sourcetype == VideoSourceDevice ) ?"video" : "audio" ; r = ICreateDevEnum_CreateClassEnumerator ( devenum , device_guid [ sourcetype ] , ( IEnumMoniker * * ) & classenum , 0 ) ; if ( r != S_OK ) { av_log ( avctx , AV_LOG_ERROR , "Could not enumerate %s devices (or none found).\n" , devtypename ) ; return AVERROR ( EIO ) ; } while ( ! device_filter && IEnumMoniker_Next ( classenum , 1 , & m , NULL ) == S_OK ) { IPropertyBag * bag = NULL ; char * friendly_name = NULL ; char * unique_name = NULL ; VARIANT var ; IBindCtx * bind_ctx = NULL ; LPOLESTR olestr = NULL ; LPMALLOC co_malloc = NULL ; AVDeviceInfo * device = NULL ; enum AVMediaType * media_types = NULL ; int nb_media_types ; int i ; r = CoGetMalloc ( 1 , & co_malloc ) ; if ( r != S_OK ) { fail } r = CreateBindCtx ( 0 , & bind_ctx ) ; if ( r != S_OK ) { fail } r = IMoniker_GetDisplayName ( m , bind_ctx , NULL , & olestr ) ; if ( r != S_OK ) { fail } unique_name = dup_wchar_to_utf8 ( olestr ) ; for ( i = 0 ; i < strlen ( unique_name ) ; i ++ ) { if ( unique_name [ i ] == ':' ) { unique_name [ i ] = '_' ; } } r = IMoniker_BindToStorage ( m , 0 , 0 , & IID_IPropertyBag , ( void * ) & bag ) ; if ( r != S_OK ) { fail } var . vt = VT_BSTR ; r = IPropertyBag_Read ( bag , L"FriendlyName" , & var , NULL ) ; if ( r != S_OK ) { fail } friendly_name = dup_wchar_to_utf8 ( var . bstrVal ) ; if ( pfilter ) { if ( strcmp ( device_name , friendly_name ) && strcmp ( device_name , unique_name ) ) { fail } if ( ! skip -- ) { r = IMoniker_BindToObject ( m , 0 , 0 , & IID_IBaseFilter , ( void * ) & device_filter ) ; if ( r != S_OK ) { av_log ( avctx , AV_LOG_ERROR , "Unable to BindToObject for %s\n" , device_name ) ; fail } * device_unique_name = unique_name ; unique_name = NULL ; } } else { if ( IMoniker_BindToObject ( m , 0 , 0 , & IID_IBaseFilter , ( void * ) & device_filter ) == S_OK ) { dshow_get_device_media_types ( avctx , devtype , sourcetype , device_filter , & media_types , & nb_media_types ) ; IBaseFilter_Release ( device_filter ) ; device_filter = NULL ; } if ( device_list ) { device = av_mallocz ( sizeof ( AVDeviceInfo ) ) ; if ( ! device ) { fail } device -> device_name = av_strdup ( unique_name ) ; device -> device_description = av_strdup ( friendly_name ) ; if ( ! device -> device_name || ! device -> device_description ) { fail } if ( av_reallocp_array ( & ( * device_list ) -> devices , ( * device_list ) -> nb_devices + 1 , sizeof ( * ( * device_list ) -> devices ) ) < 0 ) { fail } device -> nb_media_types = nb_media_types ; device -> media_types = media_types ; nb_media_types = 0 ; media_types = NULL ; ( * device_list ) -> devices [ ( * device_list ) -> nb_devices ] = device ; ( * device_list ) -> nb_devices ++ ; device = NULL ; } else { av_log ( avctx , AV_LOG_INFO , "\"%s\"" , friendly_name ) ; if ( nb_media_types > 0 ) { const char * media_type = av_get_media_type_string ( media_types [ 0 ] ) ; av_log ( avctx , AV_LOG_INFO , " (%s" , media_type ?media_type : "unknown" ) ; for ( int i = 1 ; i < nb_media_types ; ++ i ) { media_type = av_get_media_type_string ( media_types [ i ] ) ; av_log ( avctx , AV_LOG_INFO , ", %s" , media_type ?media_type : "unknown" ) ; } av_log ( avctx , AV_LOG_INFO , ")" ) ; } else { av_log ( avctx , AV_LOG_INFO , " (none)" ) ; } av_log ( avctx , AV_LOG_INFO , "\n" ) ; av_log ( avctx , AV_LOG_INFO , "  Alternative name \"%s\"\n" , unique_name ) ; } } fail av_freep ( & media_types ) ; if ( device ) { av_freep ( & device -> device_name ) ; av_freep ( & device -> device_description ) ; av_free ( device ) ; } if ( olestr && co_malloc ) { IMalloc_Free ( co_malloc , olestr ) ; } if ( bind_ctx ) { IBindCtx_Release ( bind_ctx ) ; } av_freep ( & friendly_name ) ; av_freep ( & unique_name ) ; if ( bag ) { IPropertyBag_Release ( bag ) ; } IMoniker_Release ( m ) ; } IEnumMoniker_Release ( classenum ) ; if ( pfilter ) { if ( ! device_filter ) { av_log ( avctx , AV_LOG_ERROR , "Could not find %s device with name [%s] among source devices of type %s.\n" , devtypename , device_name , sourcetypename ) ; return AVERROR ( EIO ) ; } * pfilter = device_filter ; } return 0 ; } 