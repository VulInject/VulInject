int pvrdma_query_qp ( struct ib_qp * ibqp , struct ib_qp_attr * attr , int attr_mask , struct ib_qp_init_attr * init_attr ) { struct pvrdma_dev * dev = to_vdev ( ibqp -> device ) ; struct pvrdma_qp * qp = to_vqp ( ibqp ) ; union pvrdma_cmd_req req ; union pvrdma_cmd_resp rsp ; struct pvrdma_cmd_query_qp * cmd = & req . query_qp ; struct pvrdma_cmd_query_qp_resp * resp = & rsp . query_qp_resp ; int ret = 0 ; mutex_lock ( & qp -> mutex ) ; if ( qp -> state == IB_QPS_RESET ) { attr -> qp_state = IB_QPS_RESET ; out } cmd -> hdr . cmd = PVRDMA_CMD_QUERY_QP ; cmd -> qp_handle = qp -> qp_handle ; cmd -> attr_mask = ib_qp_attr_mask_to_pvrdma ( attr_mask ) ; ret = pvrdma_cmd_post ( dev , & req , & rsp , PVRDMA_CMD_QUERY_QP_RESP ) ; if ( ret < 0 ) { dev_warn ( & dev -> pdev -> dev , "could not query queuepair, error: %d\n" , ret ) ; out } attr -> qp_state = pvrdma_qp_state_to_ib ( resp -> attrs . qp_state ) ; attr -> cur_qp_state = pvrdma_qp_state_to_ib ( resp -> attrs . cur_qp_state ) ; attr -> path_mtu = pvrdma_mtu_to_ib ( resp -> attrs . path_mtu ) ; attr -> path_mig_state = pvrdma_mig_state_to_ib ( resp -> attrs . path_mig_state ) ; attr -> qkey = resp -> attrs . qkey ; attr -> rq_psn = resp -> attrs . rq_psn ; attr -> sq_psn = resp -> attrs . sq_psn ; attr -> dest_qp_num = resp -> attrs . dest_qp_num ; attr -> qp_access_flags = pvrdma_access_flags_to_ib ( resp -> attrs . qp_access_flags ) ; attr -> pkey_index = resp -> attrs . pkey_index ; attr -> alt_pkey_index = resp -> attrs . alt_pkey_index ; attr -> en_sqd_async_notify = resp -> attrs . en_sqd_async_notify ; attr -> sq_draining = resp -> attrs . sq_draining ; attr -> max_rd_atomic = resp -> attrs . max_rd_atomic ; attr -> max_dest_rd_atomic = resp -> attrs . max_dest_rd_atomic ; attr -> min_rnr_timer = resp -> attrs . min_rnr_timer ; attr -> port_num = resp -> attrs . port_num ; attr -> timeout = resp -> attrs . timeout ; attr -> retry_cnt = resp -> attrs . retry_cnt ; attr -> rnr_retry = resp -> attrs . rnr_retry ; attr -> alt_port_num = resp -> attrs . alt_port_num ; attr -> alt_timeout = resp -> attrs . alt_timeout ; pvrdma_qp_cap_to_ib ( & attr -> cap , & resp -> attrs . cap ) ; pvrdma_ah_attr_to_rdma ( & attr -> ah_attr , & resp -> attrs . ah_attr ) ; pvrdma_ah_attr_to_rdma ( & attr -> alt_ah_attr , & resp -> attrs . alt_ah_attr ) ; qp -> state = attr -> qp_state ; ret = 0 ; out attr -> cur_qp_state = attr -> qp_state ; init_attr -> event_handler = qp -> ibqp . event_handler ; init_attr -> qp_context = qp -> ibqp . qp_context ; init_attr -> send_cq = qp -> ibqp . send_cq ; init_attr -> recv_cq = qp -> ibqp . recv_cq ; init_attr -> srq = qp -> ibqp . srq ; init_attr -> xrcd = NULL ; init_attr -> cap = attr -> cap ; init_attr -> sq_sig_type = 0 ; init_attr -> qp_type = qp -> ibqp . qp_type ; init_attr -> create_flags = 0 ; init_attr -> port_num = qp -> port ; mutex_unlock ( & qp -> mutex ) ; return ret ; } 