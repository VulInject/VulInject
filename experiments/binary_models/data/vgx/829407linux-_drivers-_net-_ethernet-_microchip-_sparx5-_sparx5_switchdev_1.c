static int sparx5_handle_port_mdb_add ( struct net_device * dev , struct notifier_block * nb , const struct switchdev_obj_port_mdb * v ) { struct sparx5_port * port = netdev_priv ( dev ) ; struct sparx5 * spx5 = port -> sparx5 ; struct sparx5_mdb_entry * entry ; bool is_host , is_new ; int err , i ; u16 vid ; is_host = netif_is_bridge_master ( v -> obj . orig_dev ) ; if ( ! br_vlan_enabled ( spx5 -> hw_bridge_dev ) ) { vid = 1 ; } else { vid = v -> vid ; } is_new = false ; entry = sparx5_mdb_get_entry ( spx5 , v -> addr , vid ) ; if ( ! entry ) { err = sparx5_alloc_mdb_entry ( spx5 , v -> addr , vid , & entry ) ; is_new = true ; if ( err ) { return err ; } } mutex_lock ( & spx5 -> mdb_lock ) ; if ( is_new && ether_addr_is_ip_mcast ( v -> addr ) ) { for ( i = 0 ; i < SPX5_PORTS ; i ++ ) { if ( spx5 -> ports [ i ] && spx5 -> ports [ i ] -> is_mrouter ) { sparx5_pgid_update_mask ( spx5 -> ports [ i ] , entry -> pgid_idx , true ) ; } } } if ( is_host && ! entry -> cpu_copy ) { sparx5_cpu_copy_ena ( spx5 , entry -> pgid_idx , true ) ; entry -> cpu_copy = true ; } if ( ! is_host ) { sparx5_pgid_update_mask ( port , entry -> pgid_idx , true ) ; set_bit ( port -> portno , entry -> port_mask ) ; } mutex_unlock ( & spx5 -> mdb_lock ) ; sparx5_mact_learn ( spx5 , entry -> pgid_idx , entry -> addr , entry -> vid ) ; return 0 ; } 