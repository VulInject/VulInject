static int polaris10_populate_single_memory_level ( struct pp_hwmgr * hwmgr , uint32_t clock , struct SMU74_Discrete_MemoryLevel * mem_level ) { struct smu7_hwmgr * data = ( smu7_hwmgr * ) ( hwmgr -> backend ) ; struct phm_ppt_v1_information * table_info = ( phm_ppt_v1_information * ) ( hwmgr -> pptable ) ; int result = 0 ; struct cgs_display_info info = { 0 0 NULL } ; uint32_t mclk_stutter_mode_threshold = 40000 ; cgs_get_active_displays_info ( hwmgr -> device , & info ) ; if ( table_info -> vdd_dep_on_mclk ) { result = polaris10_get_dependency_volt_by_clk ( hwmgr , table_info -> vdd_dep_on_mclk , clock , & mem_level -> MinVoltage , & mem_level -> MinMvdd ) ; PP_ASSERT_WITH_CODE ( 0 , "can not find MinVddc voltage value from memory " "VDDC voltage dependency table" , ) } mem_level -> MclkFrequency = clock ; mem_level -> EnabledForThrottle = 1 ; mem_level -> EnabledForActivity = 0 ; mem_level -> UpHyst = 0 ; mem_level -> DownHyst = 100 ; mem_level -> VoltageDownHyst = 0 ; mem_level -> ActivityLevel = ( uint16_t ) data -> mclk_activity_target ; mem_level -> StutterEnable = false ; mem_level -> DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW ; data -> display_timing . num_existing_displays = info . display_count ; if ( mclk_stutter_mode_threshold && ( clock <= mclk_stutter_mode_threshold ) && ( SMUM_READ_FIELD ( hwmgr -> device , DPG_PIPE_STUTTER_CONTROL , STUTTER_ENABLE ) & 0x1 ) ) { mem_level -> StutterEnable = true ; } if ( ! result ) { CONVERT_FROM_HOST_TO_SMC_UL ( mem_level -> MinMvdd , NULL ) ; CONVERT_FROM_HOST_TO_SMC_UL ( mem_level -> MclkFrequency ) ; CONVERT_FROM_HOST_TO_SMC_US ( mem_level -> ActivityLevel ) ; CONVERT_FROM_HOST_TO_SMC_UL ( mem_level -> MinVoltage ) ; } return result ; } 