static void bs_split_update_hevc_linf ( BSSplitIn * pctx , BSSplitOut * c_opid ) { u32 i ; u32 max_lid = c_opid -> max_layer_id ; u32 max_tid = c_opid -> max_temporal_id ; u32 min_lid = 0 ; u32 min_tid = 0 ; for ( i = 0 ; i < gf_list_count ( pctx -> opids ) ; i ++ ) { BSSplitOut * an_out = gf_list_get ( pctx -> opids , i ) ; if ( max_lid < an_out -> max_layer_id ) { continue ; } if ( max_lid == an_out -> max_layer_id ) { if ( min_tid < an_out -> max_temporal_id ) { min_tid = an_out -> max_temporal_id ; } continue ; } if ( min_lid < an_out -> max_layer_id ) { min_lid = an_out -> max_layer_id ; } } if ( pctx -> max_layers ) { if ( max_lid >= pctx -> max_layers ) { max_lid = pctx -> max_layers - 1 ; } } else { if ( max_lid >= 63 ) { max_lid = 63 ; } } if ( pctx -> max_sublayers ) { if ( max_tid > pctx -> max_sublayers ) { max_tid = pctx -> max_sublayers ; } } else { if ( max_tid > 7 ) { max_tid = 7 ; } } u32 nb_layers = ( max_lid - min_lid ) ; if ( ! nb_layers ) { nb_layers = 1 ; min_lid = 0 ; } else { min_lid ++ ; } GF_BitStream * bs = gf_bs_new ( NULL , 0 , GF_BITSTREAM_WRITE ) ; gf_bs_write_int ( bs , 0 , 2 ) ; gf_bs_write_int ( bs , nb_layers , 6 ) ; for ( i = 0 ; i < nb_layers ; i ++ ) { gf_bs_write_int ( bs , 0 , 4 ) ; gf_bs_write_int ( bs , min_lid + i , 6 ) ; gf_bs_write_int ( bs , min_tid + 1 , 3 ) ; gf_bs_write_int ( bs , max_tid , 3 ) ; gf_bs_write_int ( bs , 0 , 1 ) ; gf_bs_write_int ( bs , 0xFF , 7 ) ; } u8 * data ; u32 data_size ; gf_bs_get_content ( bs , & data , & data_size ) ; gf_bs_del ( bs ) ; gf_filter_pid_set_info_str ( c_opid -> opid , "hevc:linf" , & PROP_DATA_NO_COPY ( data , data_size ) ) ; } 