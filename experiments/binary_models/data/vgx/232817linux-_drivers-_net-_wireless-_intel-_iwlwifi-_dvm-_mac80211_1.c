static int iwlagn_mac_change_interface ( struct ieee80211_hw * hw , struct ieee80211_vif * vif , enum nl80211_iftype newtype , bool newp2p ) { struct iwl_priv * priv = IWL_MAC80211_GET_DVM ( hw ) ; struct iwl_rxon_context * ctx , * tmp ; enum nl80211_iftype newviftype = newtype ; u32 interface_modes ; int err ; IWL_DEBUG_MAC80211 ( priv , "enter\n" ) ; newtype = ieee80211_iftype_p2p ( newtype , newp2p ) ; mutex_lock ( & priv -> mutex ) ; ctx = iwl_rxon_ctx_from_vif ( vif ) ; if ( ctx -> ctxid != IWL_RXON_CTX_BSS ) { err = - EBUSY ; out } if ( ! ctx -> vif || ! iwl_is_ready_rf ( priv ) ) { err = - EBUSY ; out } interface_modes = ctx -> interface_modes | ctx -> exclusive_interface_modes ; if ( ! ( interface_modes & BIT ( newtype ) ) ) { err = - EBUSY ; out } if ( ctx -> exclusive_interface_modes & BIT ( newtype ) ) { for_each_context ( , ) { if ( ! tmp -> is_active ) { continue ; } err = - EBUSY ; out } } iwl_teardown_interface ( priv , vif , true ) ; vif -> type = newviftype ; vif -> p2p = newp2p ; err = iwl_setup_interface ( priv , ctx ) ; WARN_ON ( err ) ; err = 0 ; out mutex_unlock ( & priv -> mutex ) ; IWL_DEBUG_MAC80211 ( priv , "leave\n" ) ; return err ; } 