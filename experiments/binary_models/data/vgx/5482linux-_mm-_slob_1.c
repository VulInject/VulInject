static void slob_free ( void * block , int size ) { struct slab * sp ; slob_t * prev , * next , * b = ( slob_t * ) block ; slobidx_t units ; unsigned long flags ; struct list_head * slob_list ; BUG_ON ( ! size ) ; sp = virt_to_slab ( block ) ; units = SLOB_UNITS ( size ) ; spin_lock_irqsave ( & slob_lock , flags ) ; if ( sp -> units + units == SLOB_UNITS ( PAGE_SIZE ) ) { if ( slob_page_free ( sp ) ) { clear_slob_page_free ( sp ) ; } spin_unlock_irqrestore ( & slob_lock , flags ) ; __folio_clear_slab ( slab_folio ( sp ) ) ; slob_free_pages ( b , 0 ) ; return ; } if ( ! slob_page_free ( sp ) ) { sp -> units = units ; sp -> freelist = b ; set_slob ( b , units , ( void * ) ( ( unsigned long ) ( b + SLOB_UNITS ( PAGE_SIZE ) ) & PAGE_MASK ) ) ; if ( size < SLOB_BREAK1 ) { slob_list = & free_slob_small ; } if ( size < SLOB_BREAK2 ) { slob_list = & free_slob_medium ; } else { slob_list = & free_slob_large ; } set_slob_page_free ( sp , slob_list ) ; out } sp -> units += units ; if ( b < ( slob_t * ) sp -> freelist ) { if ( b + units == sp -> freelist ) { units += slob_units ( sp -> freelist ) ; sp -> freelist = slob_next ( sp -> freelist ) ; } set_slob ( b , units , sp -> freelist ) ; sp -> freelist = b ; } else { prev = sp -> freelist ; next = slob_next ( prev ) ; while ( b > next ) { prev = next ; next = slob_next ( prev ) ; } if ( ! slob_last ( prev ) && b + units == next ) { units += slob_units ( next ) ; set_slob ( b , units , slob_next ( next ) ) ; } else { set_slob ( b , units , next ) ; } if ( prev + slob_units ( prev ) == b ) { units = slob_units ( b ) + slob_units ( prev ) ; set_slob ( prev , units , slob_next ( b ) ) ; } else { set_slob ( prev , slob_units ( prev ) , b ) ; } } out spin_unlock_irqrestore ( & slob_lock , flags ) ; } 