static int ips_monitor ( void * data ) { struct ips_driver * ips = data ; unsigned long seqno_timestamp , expire , last_msecs , last_sample_period ; int i ; u32 * cpu_samples , * mchp_samples , old_cpu_power ; u16 * mcp_samples , * ctv1_samples , * ctv2_samples , * mch_samples ; u8 cur_seqno , last_seqno ; mcp_samples = kcalloc ( IPS_SAMPLE_COUNT , sizeof ( u16 ) , GFP_KERNEL ) ; ctv1_samples = kcalloc ( IPS_SAMPLE_COUNT , sizeof ( u16 ) , GFP_KERNEL ) ; ctv2_samples = kcalloc ( IPS_SAMPLE_COUNT , sizeof ( u16 ) , GFP_KERNEL ) ; mch_samples = kcalloc ( IPS_SAMPLE_COUNT , sizeof ( u16 ) , GFP_KERNEL ) ; cpu_samples = kcalloc ( IPS_SAMPLE_COUNT , sizeof ( u32 ) , GFP_KERNEL ) ; mchp_samples = kcalloc ( IPS_SAMPLE_COUNT , sizeof ( u32 ) , GFP_KERNEL ) ; if ( ! mcp_samples || ! ctv1_samples || ! ctv2_samples || ! mch_samples || ! cpu_samples || ! mchp_samples ) { dev_err ( ips -> dev , "failed to allocate sample array, ips disabled\n" ) ; kfree ( mcp_samples ) ; kfree ( ctv2_samples ) ; kfree ( mch_samples ) ; kfree ( cpu_samples ) ; kfree ( mchp_samples ) ; return - ENOMEM ; } last_seqno = ( thm_readl ( THM_ITV ) & ITV_ME_SEQNO_MASK ) >> ITV_ME_SEQNO_SHIFT ; seqno_timestamp = get_jiffies_64 ( ) ; old_cpu_power = thm_readl ( THM_CEC ) ; schedule_timeout_interruptible ( msecs_to_jiffies ( IPS_SAMPLE_PERIOD ) ) ; for ( i = 0 ; i < IPS_SAMPLE_COUNT ; i ++ ) { u32 mchp , cpu_power ; u16 val ; mcp_samples [ i ] = read_ptv ( ips ) ; val = read_ctv ( ips , 0 ) ; ctv1_samples [ i ] = val ; val = read_ctv ( ips , 1 ) ; ctv2_samples [ i ] = val ; val = read_mgtv ( ips ) ; mch_samples [ i ] = val ; cpu_power = get_cpu_power ( ips , & old_cpu_power , IPS_SAMPLE_PERIOD ) ; cpu_samples [ i ] = cpu_power ; if ( ips -> read_mch_val ) { mchp = ips -> read_mch_val ( ) ; mchp_samples [ i ] = mchp ; } schedule_timeout_interruptible ( msecs_to_jiffies ( IPS_SAMPLE_PERIOD ) ) ; if ( kthread_should_stop ( ) ) { break ; } } ips -> mcp_avg_temp = calc_avg_temp ( ips , mcp_samples ) ; ips -> ctv1_avg_temp = calc_avg_temp ( ips , ctv1_samples ) ; ips -> ctv2_avg_temp = calc_avg_temp ( ips , ctv2_samples ) ; ips -> mch_avg_temp = calc_avg_temp ( ips , mch_samples ) ; ips -> cpu_avg_power = calc_avg_power ( ips , cpu_samples ) ; ips -> mch_avg_power = calc_avg_power ( ips , mchp_samples ) ; kfree ( mcp_samples ) ; kfree ( ctv1_samples ) ; kfree ( ctv2_samples ) ; kfree ( mch_samples ) ; kfree ( cpu_samples ) ; kfree ( mchp_samples ) ; wake_up_process ( ips -> adjust ) ; old_cpu_power = thm_readl ( THM_CEC ) ; schedule_timeout_interruptible ( msecs_to_jiffies ( IPS_SAMPLE_PERIOD ) ) ; last_sample_period = IPS_SAMPLE_PERIOD ; timer_setup ( & ips -> timer , monitor_timeout , TIMER_DEFERRABLE ) ; { u32 cpu_val , mch_val ; u16 val ; val = read_ptv ( ips ) ; ips -> mcp_avg_temp = update_average_temp ( ips -> mcp_avg_temp , val ) ; val = read_ctv ( ips , 0 ) ; ips -> ctv1_avg_temp = update_average_temp ( ips -> ctv1_avg_temp , val ) ; cpu_val = get_cpu_power ( ips , & old_cpu_power , last_sample_period ) ; ips -> cpu_avg_power = update_average_power ( ips -> cpu_avg_power , cpu_val ) ; if ( ips -> second_cpu ) { val = read_ctv ( ips , 1 ) ; ips -> ctv2_avg_temp = update_average_temp ( ips -> ctv2_avg_temp , val ) ; } val = read_mgtv ( ips ) ; ips -> mch_avg_temp = update_average_temp ( ips -> mch_avg_temp , val ) ; if ( ips -> read_mch_val ) { mch_val = ips -> read_mch_val ( ) ; ips -> mch_avg_power = update_average_power ( ips -> mch_avg_power , mch_val ) ; } cur_seqno = ( thm_readl ( THM_ITV ) & ITV_ME_SEQNO_MASK ) >> ITV_ME_SEQNO_SHIFT ; if ( cur_seqno == last_seqno && time_after ( jiffies , seqno_timestamp + HZ ) ) { dev_warn ( ips -> dev , "ME failed to update for more than 1s, likely hung\n" ) ; } else { seqno_timestamp = get_jiffies_64 ( ) ; last_seqno = cur_seqno ; } last_msecs = jiffies_to_msecs ( jiffies ) ; expire = jiffies + msecs_to_jiffies ( IPS_SAMPLE_PERIOD ) ; __set_current_state ( TASK_INTERRUPTIBLE ) ; mod_timer ( & ips -> timer , expire ) ; schedule ( ) ; last_sample_period = jiffies_to_msecs ( jiffies ) - last_msecs ; if ( ! last_sample_period ) { last_sample_period = 1 ; } } ! kthread_should_stop ( ) ; del_timer_sync ( & ips -> timer ) ; dev_dbg ( ips -> dev , "ips-monitor thread stopped\n" ) ; return 0 ; } 