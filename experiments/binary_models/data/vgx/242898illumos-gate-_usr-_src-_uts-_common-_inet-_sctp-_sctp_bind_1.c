int sctp_bind_del ( sctp_t * sctp , const void * addrs , uint32_t addrcnt , boolean_t caller_hold_lock ) { int error = 0 ; boolean_t do_asconf = B_FALSE ; uchar_t * ulist = NULL ; int usize = 0 ; sctp_stack_t * sctps = sctp -> sctp_sctps ; conn_t * connp = sctp -> sctp_connp ; if ( ! caller_hold_lock ) { RUN_SCTP ( sctp ) ; } if ( sctp -> sctp_state > SCTPS_ESTABLISHED || ( sctp -> sctp_connp -> conn_state_flags & CONN_CLOSING ) ) { if ( ! caller_hold_lock ) { WAKE_SCTP ( sctp ) ; } return ( EINVAL ) ; } if ( sctp -> sctp_state > SCTPS_LISTEN ) { if ( ! sctps -> sctps_addip_enabled || ! sctp -> sctp_understands_asconf || ! sctp -> sctp_understands_addip ) { if ( ! caller_hold_lock ) { WAKE_SCTP ( sctp ) ; } return ( EINVAL ) ; } do_asconf = B_TRUE ; } if ( sctp -> sctp_nsaddrs == 1 || addrcnt >= sctp -> sctp_nsaddrs ) { if ( ! caller_hold_lock ) { WAKE_SCTP ( sctp ) ; } return ( EINVAL ) ; } if ( cl_sctp_unlisten != NULL && ! do_asconf && sctp -> sctp_state > SCTPS_BOUND ) { usize = sizeof ( in6_addr_t ) * addrcnt ; ulist = kmem_alloc ( usize , KM_SLEEP ) ; } error = sctp_del_ip ( sctp , addrs , addrcnt , ulist , usize ) ; if ( error != 0 ) { if ( ulist != NULL ) { kmem_free ( ulist , usize ) ; } if ( ! caller_hold_lock ) { WAKE_SCTP ( sctp ) ; } return ( error ) ; } if ( ulist != NULL ) { ASSERT ( cl_sctp_unlisten != NULL ) ; * cl_sctp_unlisten ( connp -> conn_family , ulist , addrcnt , connp -> conn_lport ) ; } if ( ! caller_hold_lock ) { WAKE_SCTP ( sctp ) ; } return ( error ) ; } 