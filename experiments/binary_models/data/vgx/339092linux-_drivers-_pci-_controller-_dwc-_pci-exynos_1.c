static int exynos_pcie_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct exynos_pcie * ep ; struct device_node * np = dev -> of_node ; int ret ; ep = devm_kzalloc ( dev , sizeof ( * ep ) , GFP_KERNEL ) ; ep -> pci . dev = dev ; ep -> pci . ops = & dw_pcie_ops ; ep -> phy = devm_of_phy_get ( dev , np , NULL ) ; if ( IS_ERR ( ep -> phy ) ) { return PTR_ERR ( ep -> phy ) ; } ep -> elbi_base = devm_platform_ioremap_resource_byname ( pdev , "elbi" ) ; if ( IS_ERR ( ep -> elbi_base ) ) { return PTR_ERR ( ep -> elbi_base ) ; } ep -> clk = devm_clk_get ( dev , "pcie" ) ; if ( IS_ERR ( ep -> clk ) ) { dev_err ( dev , "Failed to get pcie rc clock\n" ) ; return PTR_ERR ( ep -> clk ) ; } ep -> bus_clk = devm_clk_get ( dev , "pcie_bus" ) ; if ( IS_ERR ( ep -> bus_clk ) ) { dev_err ( dev , "Failed to get pcie bus clock\n" ) ; return PTR_ERR ( ep -> bus_clk ) ; } ep -> supplies [ 0 ] . supply = "vdd18" ; ep -> supplies [ 1 ] . supply = "vdd10" ; ret = devm_regulator_bulk_get ( dev , ARRAY_SIZE ( ep -> supplies ) , ep -> supplies ) ; if ( ret ) { return ret ; } ret = exynos_pcie_init_clk_resources ( ep ) ; if ( ret ) { return ret ; } ret = regulator_bulk_enable ( ARRAY_SIZE ( ep -> supplies ) , ep -> supplies ) ; if ( ret ) { return ret ; } platform_set_drvdata ( pdev , ep ) ; ret = exynos_add_pcie_port ( ep , pdev ) ; if ( ret < 0 ) { fail_probe } return 0 ; fail_probe phy_exit ( ep -> phy ) ; exynos_pcie_deinit_clk_resources ( ep ) ; regulator_bulk_disable ( ARRAY_SIZE ( ep -> supplies ) , ep -> supplies ) ; return ret ; } 