unsigned int nf_nat_inet_fn ( void * priv , struct sk_buff * skb , const struct nf_hook_state * state ) { struct nf_conn * ct ; enum ip_conntrack_info ctinfo ; struct nf_conn_nat * nat ; enum nf_nat_manip_type maniptype = HOOK2MANIP ( state -> hook ) ; ct = nf_ct_get ( skb , & ctinfo ) ; if ( ! ct || in_vrf_postrouting ( state ) ) { return NF_ACCEPT ; } nat = nfct_nat ( ct ) ; switch ( ctinfo ) { case IP_CT_RELATED : case IP_CT_RELATED_REPLY : case IP_CT_NEW : if ( ! nf_nat_initialized ( ct , maniptype ) ) { struct nf_nat_lookup_hook_priv * lpriv = priv ; struct nf_hook_entries * e = rcu_dereference ( lpriv -> entries ) ; unsigned int ret ; int i ; if ( ! e ) { null_bind } for ( i = 0 ; i < e -> num_hook_entries ; i ++ ) { ret = e -> hooks [ i ] . hook ( e -> hooks [ i ] . priv , skb , state ) ; if ( nf_nat_initialized ( ct , maniptype ) ) { do_nat } } null_bind ret = nf_nat_alloc_null_binding ( ct , state -> hook ) ; if ( ret != NF_ACCEPT ) { return ret ; } } else { pr_debug ( "Already setup manip %s for ct %p (status bits 0x%lx)\n" , maniptype == NF_NAT_MANIP_SRC ?"SRC" : "DST" , ct , ct -> status ) ; if ( nf_nat_oif_changed ( state -> hook , ctinfo , nat , state -> out ) ) { oif_changed } } break ; default : WARN_ON ( ctinfo != IP_CT_ESTABLISHED && ctinfo != IP_CT_ESTABLISHED_REPLY ) ; if ( nf_nat_oif_changed ( state -> hook , ctinfo , nat , state -> out ) ) { oif_changed } } do_nat return nf_nat_packet ( ct , ctinfo , state -> hook , skb ) ; oif_changed nf_ct_kill_acct ( ct , ctinfo , skb ) ; return NF_DROP ; } 