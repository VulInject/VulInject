int app_ruby_kemi_export_libs ( void ) { ksr_ruby_export_t * _sr_crt_R_KSRMethods = NULL ; sr_kemi_module_t * emods = NULL ; int emods_size = 0 ; int i ; int k ; int n ; int m ; char rmname [ 128 ] ; _sr_R_KSRMethods = malloc ( SR_RUBY_KSR_METHODS_SIZE * sizeof ( ksr_ruby_export_t ) ) ; if ( _sr_R_KSRMethods == NULL ) { LM_ERR ( "no more pkg memory\n" ) ; return 0 ; } memset ( _sr_R_KSRMethods , 0 , SR_RUBY_KSR_METHODS_SIZE * sizeof ( ksr_ruby_export_t ) ) ; emods_size = sr_kemi_modules_size_get ( ) ; emods = sr_kemi_modules_get ( ) ; n = 0 ; _sr_crt_R_KSRMethods = _sr_R_KSRMethods ; if ( emods_size == 0 || emods [ 0 ] . kexp == NULL ) { LM_ERR ( "no kemi exports registered\n" ) ; return 0 ; } _ksr_mKSR = rb_define_module ( "KSR" ) ; for ( i = 0 ; emods [ 0 ] . kexp [ i ] . func != NULL ; i ++ ) { LM_DBG ( "exporting KSR.%s(...)\n" , emods [ 0 ] . kexp [ i ] . fname . s ) ; _sr_crt_R_KSRMethods [ i ] . mname = "" ; _sr_crt_R_KSRMethods [ i ] . fname = emods [ 0 ] . kexp [ i ] . fname . s ; _sr_crt_R_KSRMethods [ i ] . func = sr_kemi_ruby_export_associate ( & emods [ 0 ] . kexp [ i ] ) ; if ( _sr_crt_R_KSRMethods [ i ] . func == NULL ) { LM_ERR ( "failed to associate kemi function with ruby export\n" ) ; _sr_R_KSRMethods = NULL ; return 0 ; } rb_define_singleton_method ( _ksr_mKSR , _sr_crt_R_KSRMethods [ i ] . fname , _sr_crt_R_KSRMethods [ i ] . func , - 1 ) ; n ++ ; } m = 0 ; if ( _app_ruby_proc_xval_mode == 0 ) { _ksr_mSMD [ m ] = rb_define_module_under ( _ksr_mKSR , "PV" ) ; for ( i = 0 ; _sr_kemi_pv_R_Map [ i ] . fname != 0 ; i ++ ) { LM_DBG ( "exporting KSR.PV.%s(...)\n" , _sr_kemi_pv_R_Map [ i ] . fname ) ; rb_define_singleton_method ( _ksr_mSMD [ m ] , _sr_kemi_pv_R_Map [ i ] . fname , _sr_kemi_pv_R_Map [ i ] . func , - 1 ) ; } LM_DBG ( "initialized kemi sub-module: KSR.PV\n" ) ; m ++ ; } _ksr_mSMD [ m ] = rb_define_module_under ( _ksr_mKSR , "X" ) ; for ( i = 0 ; _sr_kemi_x_R_Map [ i ] . fname != 0 ; i ++ ) { LM_DBG ( "exporting KSR.X.%s(...)\n" , _sr_kemi_x_R_Map [ i ] . fname ) ; rb_define_singleton_method ( _ksr_mSMD [ m ] , _sr_kemi_x_R_Map [ i ] . fname , _sr_kemi_x_R_Map [ i ] . func , - 1 ) ; } LM_DBG ( "initialized kemi sub-module: KSR.X\n" ) ; m ++ ; if ( emods_size > 1 ) { for ( k = 1 ; k < emods_size ; k ++ ) { if ( ( _app_ruby_proc_xval_mode == 0 ) && emods [ k ] . kexp [ 0 ] . mname . len == 2 && strncasecmp ( emods [ k ] . kexp [ 0 ] . mname . s , "pv" , 2 ) == 0 ) { LM_DBG ( "skipping external pv sub-module\n" ) ; continue ; } n ++ ; _sr_crt_R_KSRMethods = _sr_R_KSRMethods + n ; ksr_app_ruby_toupper ( emods [ k ] . kexp [ 0 ] . mname . s , rmname ) ; _ksr_mSMD [ m ] = rb_define_module_under ( _ksr_mKSR , rmname ) ; for ( i = 0 ; emods [ k ] . kexp [ i ] . func != NULL ; i ++ ) { _sr_crt_R_KSRMethods [ i ] . mname = emods [ k ] . kexp [ 0 ] . mname . s ; _sr_crt_R_KSRMethods [ i ] . fname = emods [ k ] . kexp [ i ] . fname . s ; _sr_crt_R_KSRMethods [ i ] . func = sr_kemi_ruby_export_associate ( & emods [ k ] . kexp [ i ] ) ; LM_DBG ( "exporting KSR.%s.%s(...)\n" , rmname , emods [ k ] . kexp [ i ] . fname . s ) ; if ( _sr_crt_R_KSRMethods [ i ] . func == NULL ) { LM_ERR ( "failed to associate kemi function with func export\n" ) ; free ( _sr_R_KSRMethods ) ; _sr_R_KSRMethods = NULL ; return 0 ; } rb_define_singleton_method ( _ksr_mSMD [ m ] , _sr_crt_R_KSRMethods [ i ] . fname , _sr_crt_R_KSRMethods [ i ] . func , - 1 ) ; n ++ ; } m ++ ; LM_DBG ( "initialized kemi sub-module: KSR.%s\n" , rmname ) ; } } LM_DBG ( "module 'KSR' has been initialized\n" ) ; return 1 ; } 