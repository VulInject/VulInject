void gincostestimate ( PlannerInfo * root , IndexPath * path , double loop_count , Cost * indexStartupCost , Cost * indexTotalCost , Selectivity * indexSelectivity , double * indexCorrelation , double * indexPages ) { IndexOptInfo * index = path -> indexinfo ; List * indexQuals = get_quals_from_indexclauses ( path -> indexclauses ) ; List * selectivityQuals ; double numPages = index -> pages , numTuples = index -> tuples ; double numEntryPages , numDataPages , numPendingPages , numEntries ; GinQualCounts counts ; bool matchPossible ; bool fullIndexScan ; double partialScale ; double entryPagesFetched , dataPagesFetched , dataPagesFetchedBySel ; double qual_op_cost , qual_arg_cost , spc_random_page_cost , outer_scans ; Cost descentCost ; Relation indexRel ; GinStatsData ginStats ; ListCell * lc ; int i ; if ( ! index -> hypothetical ) { indexRel = index_open ( index -> indexoid , NoLock ) ; ginGetStats ( indexRel , & ginStats ) ; index_close ( indexRel , NoLock ) ; } else { memset ( & ginStats , 0 , sizeof ( ginStats ) ) ; } if ( ginStats . nPendingPages < numPages ) { numPendingPages = ginStats . nPendingPages ; } else { numPendingPages = 0 ; } if ( numPages > 0 && ginStats . nTotalPages <= numPages && ginStats . nTotalPages > numPages / 4 && ginStats . nEntryPages > 0 && ginStats . nEntries > 0 ) { double scale = numPages / ginStats . nTotalPages ; numEntryPages = ceil ( ginStats . nEntryPages * scale ) ; numDataPages = ceil ( ginStats . nDataPages * scale ) ; numEntries = ceil ( ginStats . nEntries * scale ) ; numEntryPages = Min ( numEntryPages , numPages - numPendingPages ) ; numDataPages = Min ( numDataPages , numPages - numPendingPages - numEntryPages ) ; } else { numPages = Max ( numPages , 10 ) ; numEntryPages = floor ( ( numPages - numPendingPages ) * 0.90 ) ; numDataPages = numPages - numPendingPages - numEntryPages ; numEntries = floor ( numEntryPages * 100 ) ; } if ( numEntries < 1 ) { numEntries = 1 ; } selectivityQuals = add_predicate_to_index_quals ( index , indexQuals ) ; * indexSelectivity = clauselist_selectivity ( root , selectivityQuals , index -> rel -> relid , JOIN_INNER , NULL ) ; get_tablespace_page_costs ( index -> reltablespace , & spc_random_page_cost , NULL ) ; * indexCorrelation = 0.0 ; memset ( & counts , 0 , sizeof ( counts ) ) ; matchPossible = true ; ( lc path -> indexclauses ; ) { IndexClause * iclause = lfirst_node ( IndexClause , lc ) ; ListCell * lc2 ; ( lc2 iclause -> indexquals ; ) { RestrictInfo * rinfo = lfirst_node ( RestrictInfo , lc2 ) ; Expr * clause = rinfo -> clause ; if ( IsA ( clause , OpExpr ) ) { matchPossible = gincost_opexpr ( root , index , iclause -> indexcol , ( OpExpr * ) clause , & counts ) ; if ( ! matchPossible ) { break ; } } if ( IsA ( clause , ScalarArrayOpExpr ) ) { matchPossible = gincost_scalararrayopexpr ( root , index , iclause -> indexcol , ( ScalarArrayOpExpr * ) clause , numEntries , & counts ) ; if ( ! matchPossible ) { break ; } } else { elog ( ERROR , "unsupported GIN indexqual type: %d" , ( int ) nodeTag ( clause ) ) ; } } } if ( ! matchPossible ) { * indexStartupCost = 0 ; * indexTotalCost = 0 ; * indexSelectivity = 0 ; return ; } fullIndexScan = false ; for ( i = 0 ; i < index -> nkeycolumns ; i ++ ) { if ( counts . attHasFullScan [ i ] && ! counts . attHasNormalScan [ i ] ) { fullIndexScan = true ; break ; } } if ( fullIndexScan || indexQuals == NIL ) { counts . partialEntries = 0 ; counts . exactEntries = numEntries ; counts . searchEntries = numEntries ; } outer_scans = loop_count ; entryPagesFetched = numPendingPages ; entryPagesFetched += ceil ( counts . searchEntries * rint ( pow ( numEntryPages , 0.15 ) ) ) ; partialScale = counts . partialEntries / numEntries ; partialScale = Min ( partialScale , 1.0 ) ; entryPagesFetched += ceil ( numEntryPages * partialScale ) ; dataPagesFetched = ceil ( numDataPages * partialScale ) ; * indexStartupCost = 0 ; * indexTotalCost = 0 ; if ( numEntries > 1 ) { descentCost = ceil ( log ( numEntries ) / log ( 2.0 ) ) * cpu_operator_cost ; * indexStartupCost += descentCost * counts . searchEntries ; * indexTotalCost += counts . arrayScans * descentCost * counts . searchEntries ; } * indexStartupCost += entryPagesFetched * DEFAULT_PAGE_CPU_MULTIPLIER * cpu_operator_cost ; * indexTotalCost += entryPagesFetched * counts . arrayScans * DEFAULT_PAGE_CPU_MULTIPLIER * cpu_operator_cost ; * indexStartupCost += DEFAULT_PAGE_CPU_MULTIPLIER * cpu_operator_cost * dataPagesFetched ; * indexTotalCost += dataPagesFetched * ( counts . arrayScans - 1 ) * DEFAULT_PAGE_CPU_MULTIPLIER * cpu_operator_cost ; if ( outer_scans > 1 || counts . arrayScans > 1 ) { entryPagesFetched *= outer_scans * counts . arrayScans ; entryPagesFetched = index_pages_fetched ( entryPagesFetched , ( BlockNumber ) numEntryPages , numEntryPages , root ) ; entryPagesFetched /= outer_scans ; dataPagesFetched *= outer_scans * counts . arrayScans ; dataPagesFetched = index_pages_fetched ( dataPagesFetched , ( BlockNumber ) numDataPages , numDataPages , root ) ; dataPagesFetched /= outer_scans ; } * indexStartupCost += ( entryPagesFetched + dataPagesFetched ) * spc_random_page_cost ; dataPagesFetched = ceil ( numDataPages * counts . exactEntries / numEntries ) ; dataPagesFetchedBySel = ceil ( * indexSelectivity * ( numTuples / ( BLCKSZ / 3 ) ) ) ; if ( dataPagesFetchedBySel > dataPagesFetched ) { dataPagesFetched = dataPagesFetchedBySel ; } * indexStartupCost += DEFAULT_PAGE_CPU_MULTIPLIER * cpu_operator_cost * counts . searchEntries ; * indexTotalCost += dataPagesFetched * counts . arrayScans * DEFAULT_PAGE_CPU_MULTIPLIER * cpu_operator_cost ; if ( outer_scans > 1 || counts . arrayScans > 1 ) { dataPagesFetched *= outer_scans * counts . arrayScans ; dataPagesFetched = index_pages_fetched ( dataPagesFetched , ( BlockNumber ) numDataPages , numDataPages , root ) ; dataPagesFetched /= outer_scans ; } * indexTotalCost += * indexStartupCost + dataPagesFetched * spc_random_page_cost ; qual_arg_cost = index_other_operands_eval_cost ( root , indexQuals ) ; qual_op_cost = cpu_operator_cost * list_length ( indexQuals ) ; * indexStartupCost += qual_arg_cost ; * indexTotalCost += qual_arg_cost ; * indexTotalCost += ( counts . searchEntries * counts . arrayScans ) * ( qual_op_cost ) ; * indexTotalCost += ( numTuples * * indexSelectivity ) * ( cpu_index_tuple_cost ) ; * indexPages = dataPagesFetched ; } 