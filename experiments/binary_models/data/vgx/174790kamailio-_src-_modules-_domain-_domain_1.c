int reload_tables ( void ) { db_key_t cols [ 4 ] ; db1_res_t * res = NULL ; db_row_t * row ; struct domain_list * * new_hash_table ; int i ; short type ; str did , domain , name , value ; int_str val ; if ( * hash_table == hash_table_1 ) { hash_table_free ( hash_table_2 ) ; new_hash_table = hash_table_2 ; } else { hash_table_free ( hash_table_1 ) ; new_hash_table = hash_table_1 ; } cols [ 0 ] = & did_col ; cols [ 1 ] = & name_col ; cols [ 2 ] = & type_col ; cols [ 3 ] = & value_col ; if ( domain_db_init ( & d_db_url ) < 0 ) { LM_ERR ( "unable to open database connection\n" ) ; return - 1 ; } if ( domain_dbf . use_table ( db_handle , & domain_attrs_table ) < 0 ) { LM_ERR ( "error while trying to use domain_attrs table\n" ) ; err } if ( domain_dbf . query ( db_handle , NULL , 0 , NULL , cols , 0 , 4 , 0 , & res ) < 0 ) { LM_ERR ( "error while querying database\n" ) ; err } row = RES_ROWS ( res ) ; LM_DBG ( "number of rows in domain_attrs table: %d\n" , RES_ROW_N ( res ) ) ; for ( i = 0 ; i < RES_ROW_N ( res ) ; i ++ ) { row = RES_ROWS ( res ) + i ; if ( ( VAL_NULL ( ROW_VALUES ( row ) ) == 1 ) || ( VAL_TYPE ( ROW_VALUES ( row ) ) != DB1_STRING ) ) { LM_ERR ( "did at row<%u>is null or not string\n" , i ) ; err } did . s = ( char * ) VAL_STRING ( ROW_VALUES ( row ) ) ; did . len = strlen ( did . s , NULL ) ; if ( did . len == 0 ) { LM_ERR ( "did at row<%u>is empty string\n" , i ) ; err } if ( ( VAL_NULL ( ROW_VALUES ( row ) + 1 ) == 1 ) || ( VAL_TYPE ( ROW_VALUES ( row ) + 1 ) != DB1_STRING ) ) { LM_ERR ( "name at row<%u>is null or not string\n" , i ) ; err } name . s = ( char * ) VAL_STRING ( ROW_VALUES ( row ) + 1 ) ; name . len = strlen ( name . s ) ; if ( name . len == 0 ) { LM_ERR ( "name at row<%u>is empty string\n" , i ) ; err } if ( ( VAL_NULL ( ROW_VALUES ( row ) + 2 ) == 1 ) || ( ( VAL_TYPE ( ROW_VALUES ( row ) + 2 ) != DB1_INT ) && ( VAL_TYPE ( ROW_VALUES ( row ) + 2 ) != DB1_BIGINT ) ) ) { LM_ERR ( "type at row<%u>is null or not int\n" , i ) ; err } if ( VAL_TYPE ( ROW_VALUES ( row ) + 2 ) == DB1_BIGINT ) { type = ( int ) VAL_BIGINT ( ROW_VALUES ( row ) + 2 ) ; } else { type = ( int ) VAL_INT ( ROW_VALUES ( row ) + 2 ) ; } if ( ( type != 0 ) && ( type != 2 ) ) { LM_ERR ( "unknown type<%d>at row<%u>\n" , type , i ) ; err } if ( ( VAL_NULL ( ROW_VALUES ( row ) + 3 ) == 1 ) || ( VAL_TYPE ( ROW_VALUES ( row ) + 3 ) != DB1_STRING ) ) { LM_ERR ( "value at row<%u>is null or not string\n" , i ) ; err } value . s = ( char * ) VAL_STRING ( ROW_VALUES ( row ) + 3 ) ; value . len = strlen ( value . s ) ; if ( type == 0 ) { if ( str2slong ( & value , & val . n ) == - 1 ) { LM_ERR ( "value at row<%u>is invalid long int\n" , i ) ; err } } else { val . s = value ; } if ( type == 0 ) { LM_DBG ( "inserting<did/name/type/value>=<%s/%s/%d/%ld>into " "attribute list\n" , did . s , name . s , type , val . n ) ; } else { LM_DBG ( "inserting<did/name/type/value>=<%s/%s/%d/%s>into " "attribute list\n" , did . s , name . s , type , val . s . s ) ; } if ( hash_table_attr_install ( new_hash_table , & did , & name , type , & val ) == - 1 ) { LM_ERR ( "could not install attribute into hash table\n" ) ; err } } domain_dbf . free_result ( db_handle , res ) ; res = NULL ; cols [ 0 ] = & domain_col ; cols [ 1 ] = & did_col ; if ( domain_dbf . use_table ( db_handle , & domain_table ) < 0 ) { LM_ERR ( "error while trying to use domain table\n" ) ; err } if ( domain_dbf . query ( db_handle , NULL , 0 , NULL , cols , 0 , 2 , 0 , & res ) < 0 ) { LM_ERR ( "error while querying database\n" ) ; err } row = RES_ROWS ( res ) ; LM_DBG ( "number of rows in domain table: %d\n" , RES_ROW_N ( res ) ) ; for ( i = 0 ; i < RES_ROW_N ( res ) ; i ++ ) { row = RES_ROWS ( res ) + i ; if ( ( VAL_NULL ( ROW_VALUES ( row ) ) == 1 ) || ( VAL_TYPE ( ROW_VALUES ( row ) ) != DB1_STRING ) ) { LM_ERR ( "domain at row<%u>is null or not string\n" , i ) ; err } domain . s = ( char * ) VAL_STRING ( ROW_VALUES ( row ) ) ; domain . len = strlen ( domain . s ) ; if ( domain . len == 0 ) { LM_ERR ( "domain at row<%u>is empty string\n" , i ) ; err } if ( ( VAL_NULL ( ROW_VALUES ( row ) + 1 ) != 1 ) && ( VAL_TYPE ( ROW_VALUES ( row ) + 1 ) != DB1_STRING ) ) { LM_ERR ( "did at row<%u>is not null or string\n" , i ) ; err } if ( VAL_NULL ( ROW_VALUES ( row ) + 1 ) == 1 ) { did . s = domain . s ; did . len = domain . len ; } else { did . s = ( char * ) VAL_STRING ( ROW_VALUES ( row ) + 1 ) ; did . len = strlen ( did . s ) ; if ( did . len == 0 ) { LM_ERR ( "did at row<%u>is empty string\n" , i ) ; err } } LM_DBG ( "inserting<did/domain>=<%s/%s>into hash table\n" , did . s , domain . s ) ; if ( hash_table_install ( new_hash_table , & did , & domain ) == - 1 ) { LM_ERR ( "could not install domain into hash table\n" ) ; domain_dbf . free_result ( db_handle , res ) ; err } } domain_dbf . free_result ( db_handle , res ) ; res = NULL ; * hash_table = new_hash_table ; domain_db_close ( ) ; return 1 ; err domain_dbf . free_result ( db_handle , res ) ; res = NULL ; domain_db_close ( ) ; return - 1 ; } 