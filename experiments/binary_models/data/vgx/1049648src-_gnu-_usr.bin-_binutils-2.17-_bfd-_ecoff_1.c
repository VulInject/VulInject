_bfd_ecoff_slurp_armap ( ) { char nextname [ 17 ] ; unsigned int i ; struct areltdata * mapdata ; bfd_size_type parsed_size ; char * raw_armap ; struct artdata * ardata ; unsigned int count ; char * raw_ptr ; struct symdef * symdef_ptr ; char * stringbase ; bfd_size_type amt ; i = bfd_bread ( ( void * ) nextname , ( bfd_size_type ) 16 , abfd ) ; if ( i != 16 ) { return FALSE ; } if ( bfd_seek ( abfd , ( file_ptr ) - 16 , SEEK_CUR ) != 0 ) { return FALSE ; } if ( strneq ( nextname , "/               " , 16 ) ) { return bfd_slurp_armap ( abfd ) ; } if ( ! strneq ( nextname , ecoff_backend ( abfd ) -> armap_start , ARMAP_START_LENGTH ) || nextname [ ARMAP_HEADER_MARKER_INDEX ] != ARMAP_MARKER || ( nextname [ ARMAP_HEADER_ENDIAN_INDEX ] != ARMAP_BIG_ENDIAN && nextname [ ARMAP_HEADER_ENDIAN_INDEX ] != ARMAP_LITTLE_ENDIAN ) || nextname [ ARMAP_OBJECT_MARKER_INDEX ] != ARMAP_MARKER || ( nextname [ ARMAP_OBJECT_ENDIAN_INDEX ] != ARMAP_BIG_ENDIAN && nextname [ ARMAP_OBJECT_ENDIAN_INDEX ] != ARMAP_LITTLE_ENDIAN ) || ! strneq ( nextname + ARMAP_END_INDEX , ARMAP_END , sizeof ARMAP_END - 1 ) ) { bfd_has_map ( abfd ) = FALSE ; return TRUE ; } if ( ( ( nextname [ ARMAP_HEADER_ENDIAN_INDEX ] == ARMAP_BIG_ENDIAN ) ^ ( bfd_header_big_endian ( abfd ) ) ) || ( ( nextname [ ARMAP_OBJECT_ENDIAN_INDEX ] == ARMAP_BIG_ENDIAN ) ^ ( bfd_big_endian ( abfd ) ) ) ) { bfd_set_error ( bfd_error_wrong_format ) ; return FALSE ; } ardata = bfd_ardata ( abfd ) ; mapdata = ( areltdata * ) _bfd_read_ar_hdr ( abfd ) ; if ( mapdata == NULL ) { return FALSE ; } parsed_size = mapdata -> parsed_size ; bfd_release ( abfd , ( void * ) mapdata ) ; raw_armap = bfd_alloc ( abfd , parsed_size ) ; if ( raw_armap == NULL ) { return FALSE ; } if ( bfd_bread ( ( void * ) raw_armap , parsed_size , abfd ) != parsed_size ) { if ( bfd_get_error ( ) != bfd_error_system_call ) { bfd_set_error ( bfd_error_malformed_archive ) ; } bfd_release ( abfd , ( void * ) raw_armap ) ; return FALSE ; } ardata -> tdata = ( void * ) raw_armap ; count = H_GET_32 ( abfd , raw_armap ) ; ardata -> symdef_count = 0 ; ardata -> cache = NULL ; stringbase = raw_armap + count * 8 + 8 ; { unsigned int hlog ; hlog = 0 ; for ( i = 1 ; i < count ; i <<= 1 ) { hlog ++ ; } BFD_ASSERT ( i == count ) ; raw_ptr = raw_armap + 4 ; for ( i = 0 ; i < count ; i ++ , raw_ptr += 8 ) { unsigned int name_offset , file_offset ; unsigned int hash , rehash , srch ; name_offset = H_GET_32 ( abfd , raw_ptr ) ; file_offset = H_GET_32 ( abfd , ( raw_ptr + 4 ) ) ; if ( file_offset == 0 ) { continue ; } hash = ecoff_armap_hash ( stringbase + name_offset , & rehash , count , hlog ) ; if ( hash == i ) { continue ; } for ( srch = ( hash + rehash ) & ( count - 1 ) ; srch != hash && srch != i ; srch = ( srch + rehash ) & ( count - 1 ) ) { BFD_ASSERT ( H_GET_32 ( abfd , ( raw_armap + 8 + srch * 8 ) ) != 0 ) ; } BFD_ASSERT ( srch == i ) ; } } raw_ptr = raw_armap + 4 ; for ( i = 0 ; i < count ; i ++ , raw_ptr += 8 ) { if ( H_GET_32 ( abfd , ( raw_ptr + 4 ) ) != 0 ) { ++ ardata -> symdef_count ; } } amt = ardata -> symdef_count ; amt *= sizeof ( symdef ) ; symdef_ptr = bfd_alloc ( abfd , amt ) ; if ( ! symdef_ptr ) { return FALSE ; } ardata -> symdefs = ( carsym * ) symdef_ptr ; raw_ptr = raw_armap + 4 ; for ( i = 0 ; i < count ; i ++ , raw_ptr += 8 ) { unsigned int name_offset , file_offset ; file_offset = H_GET_32 ( abfd , ( raw_ptr + 4 ) ) ; if ( file_offset == 0 ) { continue ; } name_offset = H_GET_32 ( abfd , raw_ptr ) ; symdef_ptr -> s . name = stringbase + name_offset ; symdef_ptr -> file_offset = file_offset ; ++ symdef_ptr ; } ardata -> first_file_filepos = bfd_tell ( abfd ) ; ardata -> first_file_filepos += ardata -> first_file_filepos % 2 ; bfd_has_map ( abfd ) = TRUE ; return TRUE ; } 