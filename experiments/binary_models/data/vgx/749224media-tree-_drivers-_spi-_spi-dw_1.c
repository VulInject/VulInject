int dw_spi_add_host ( struct device * dev , struct dw_spi * dws ) { struct spi_master * master ; int ret ; BUG_ON ( dws == NULL ) ; master = spi_alloc_master ( dev , 0 ) ; dws -> master = master ; dws -> type = SSI_MOTO_SPI ; dws -> dma_inited = 0 ; dws -> dma_addr = ( dma_addr_t ) ( dws -> paddr + DW_SPI_DR ) ; ret = request_irq ( dws -> irq , dw_spi_irq , IRQF_SHARED , dev_name ( dev ) , master ) ; if ( ret < 0 ) { dev_err ( dev , "can not get IRQ\n" ) ; err_free_master } master -> mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP ; master -> bits_per_word_mask = SPI_BPW_MASK ( 8 ) | SPI_BPW_MASK ( 16 ) ; master -> bus_num = dws -> bus_num ; master -> num_chipselect = dws -> num_cs ; master -> setup = dw_spi_setup ; master -> cleanup = dw_spi_cleanup ; master -> set_cs = dw_spi_set_cs ; master -> transfer_one = dw_spi_transfer_one ; master -> handle_err = dw_spi_handle_err ; master -> max_speed_hz = dws -> max_freq ; master -> dev . of_node = dev -> of_node ; master -> flags = SPI_MASTER_GPIO_SS ; spi_hw_init ( dev , dws ) ; if ( dws -> dma_ops && dws -> dma_ops -> dma_init ) { ret = dws -> dma_ops -> dma_init ( dws ) ; if ( ret ) { dev_warn ( dev , "DMA init failed\n" ) ; dws -> dma_inited = 0 ; } else { master -> can_dma = dws -> dma_ops -> can_dma ; } } spi_master_set_devdata ( master , dws ) ; ret = devm_spi_register_master ( dev , master ) ; if ( ret ) { dev_err ( & master -> dev , "problem registering spi master\n" ) ; err_dma_exit } dw_spi_debugfs_init ( dws ) ; return 0 ; err_dma_exit if ( dws -> dma_ops && dws -> dma_ops -> dma_exit ) { dws -> dma_ops -> dma_exit ( dws ) ; } spi_enable_chip ( dws , 0 ) ; free_irq ( dws -> irq , master ) ; err_free_master spi_master_put ( master ) ; return ret ; } 