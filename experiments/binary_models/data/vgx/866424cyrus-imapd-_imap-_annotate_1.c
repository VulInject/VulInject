EXPORTED int annotate_state_store ( annotate_state_t * state , struct entryattlist * l ) { int r = 0 ; struct entryattlist * e = l ; struct attvaluelist * av ; annotate_state_start ( state , NULL ) ; while ( e ) { int attribs ; const annotate_entrydesc_t * desc = NULL ; struct annotate_entry_list * nentry = NULL ; r = find_desc_store ( state , e -> entry , & desc ) ; if ( r ) { cleanup } if ( ( desc -> proxytype != PROXY_ONLY ) || proxy_store_func ) { nentry = _annotate_state_add_entry ( state , desc , e -> entry ) ; } attribs = desc -> attribs ; av = e -> attvalues ; while ( av ) { if ( ! strcmp ( av -> attrib , "value.shared" ) ) { if ( ! ( attribs & ATTRIB_VALUE_SHARED ) ) { r = IMAP_PERMISSION_DENIED ; cleanup } r = annotate_canon_value ( & av -> value , desc -> type ) ; if ( r ) { cleanup } if ( nentry ) { buf_init_ro ( & nentry -> shared , av -> value . s , av -> value . len ) ; nentry -> have_shared = 1 ; } } if ( ! strcmp ( av -> attrib , "content-type.shared" ) || ! strcmp ( av -> attrib , "content-type.priv" ) ) { syslog ( LOG_WARNING , "annotatemore_store: client used " "deprecated attribute \"%s\", ignoring" , av -> attrib ) ; } if ( ! strcmp ( av -> attrib , "value.priv" ) ) { if ( ! ( attribs & ATTRIB_VALUE_PRIV ) ) { r = IMAP_PERMISSION_DENIED ; cleanup } r = annotate_canon_value ( & av -> value , desc -> type ) ; if ( r ) { cleanup } if ( nentry ) { buf_init_ro ( & nentry -> priv , av -> value . s , av -> value . len ) ; nentry -> have_priv = 1 ; } } else { r = IMAP_PERMISSION_DENIED ; cleanup } av = av -> next ; } e = e -> next ; } if ( state -> which == ANNOTATION_SCOPE_SERVER ) { r = _annotate_store_entries ( state ) ; } if ( state -> which == ANNOTATION_SCOPE_MAILBOX ) { if ( proxy_store_func ) { r = annotate_state_need_mbentry ( state ) ; if ( r ) { cleanup } assert ( state -> mbentry ) ; } else { assert ( state -> mailbox ) ; } r = _annotate_store_entries ( state ) ; if ( r ) { cleanup } state -> count ++ ; if ( proxy_store_func && state -> mbentry -> server && ! hash_lookup ( state -> mbentry -> server , & state -> server_table ) ) { hash_insert ( state -> mbentry -> server , ( void * ) 0xDEADBEEF , & state -> server_table ) ; } if ( ! r && ! state -> count ) { r = IMAP_MAILBOX_NONEXISTENT ; } if ( proxy_store_func ) { if ( ! r ) { struct proxy_rock prock = { NULL NULL } ; prock . mbox_pat = state -> mbentry -> ext_name ; prock . entryatts = l ; hash_enumerate ( & state -> server_table , store_proxy , & prock ) ; } } } if ( state -> which == ANNOTATION_SCOPE_MESSAGE ) { r = _annotate_store_entries ( state ) ; if ( r ) { cleanup } } cleanup annotate_state_finish ( state ) ; return r ; } rename_rock { struct mailbox * oldmailbox ; struct mailbox * newmailbox ; const char * olduserid ; const char * newuserid ; uint32_t olduid ; uint32_t newuid ; int copy ; } 