static nrf_dfu_res_code_t nrf_dfu_postvalidate ( dfu_init_command_t * p_init ) { uint32_t err_code ; nrf_dfu_res_code_t res_code = NRF_DFU_RES_CODE_SUCCESS ; nrf_dfu_bank_t * p_bank ; switch ( p_init -> hash . hash_type ) { case DFU_HASH_TYPE_SHA256 : hash_data . p_le_data = & hash [ 0 ] ; hash_data . len = sizeof ( hash ) ; err_code = nrf_crypto_hash_compute ( NRF_CRYPTO_HASH_ALG_SHA256 , ( uint8_t * ) m_firmware_start_addr , m_firmware_size_req , & hash_data ) ; if ( err_code != NRF_SUCCESS ) { res_code = NRF_DFU_RES_CODE_OPERATION_FAILED ; } if ( memcmp ( & hash_data . p_le_data [ 0 ] , & p_init -> hash . hash . bytes [ 0 ] , 32 ) != 0 ) { NRF_LOG_INFO ( "Hash failure\r\n" ) ; res_code = NRF_DFU_RES_CODE_INVALID_OBJECT ; } break ; default : res_code = NRF_DFU_RES_CODE_OPERATION_FAILED ; break ; } if ( s_dfu_settings . bank_current == NRF_DFU_CURRENT_BANK_0 ) { NRF_LOG_INFO ( "Current bank is bank 0\r\n" ) ; p_bank = & s_dfu_settings . bank_0 ; } if ( s_dfu_settings . bank_current == NRF_DFU_CURRENT_BANK_1 ) { NRF_LOG_INFO ( "Current bank is bank 1\r\n" ) ; p_bank = & s_dfu_settings . bank_1 ; } else { NRF_LOG_INFO ( "Internal error, invalid current bank\r\n" ) ; return NRF_DFU_RES_CODE_OPERATION_FAILED ; } if ( res_code == NRF_DFU_RES_CODE_SUCCESS ) { NRF_LOG_INFO ( "Successfully run the postvalidation check!\r\n" ) ; switch ( p_init -> type ) { case DFU_FW_TYPE_APPLICATION : p_bank -> bank_code = NRF_DFU_BANK_VALID_APP ; break ; case DFU_FW_TYPE_SOFTDEVICE : p_bank -> bank_code = NRF_DFU_BANK_VALID_SD ; s_dfu_settings . sd_size = p_init -> sd_size ; break ; case DFU_FW_TYPE_BOOTLOADER : p_bank -> bank_code = NRF_DFU_BANK_VALID_BL ; break ; case DFU_FW_TYPE_SOFTDEVICE_BOOTLOADER : p_bank -> bank_code = NRF_DFU_BANK_VALID_SD_BL ; s_dfu_settings . sd_size = p_init -> sd_size ; break ; default : res_code = NRF_DFU_RES_CODE_OPERATION_FAILED ; break ; } if ( p_init -> has_is_debug == false || p_init -> is_debug == false ) { switch ( p_init -> type ) { case DFU_FW_TYPE_APPLICATION : s_dfu_settings . app_version = p_init -> fw_version ; break ; case DFU_FW_TYPE_BOOTLOADER : case DFU_FW_TYPE_SOFTDEVICE_BOOTLOADER : s_dfu_settings . bootloader_version = p_init -> fw_version ; break ; default : break ; } } p_bank -> image_crc = s_dfu_settings . progress . firmware_image_crc ; p_bank -> image_size = m_firmware_size_req ; } else { p_bank -> bank_code = NRF_DFU_BANK_INVALID ; p_bank -> image_crc = 0 ; p_bank -> image_size = 0 ; } memset ( s_dfu_settings . init_command , 0xFF , DFU_SIGNED_COMMAND_SIZE ) ; s_dfu_settings . write_offset = 0 ; while ( nrf_dfu_settings_write ( on_dfu_complete ) == NRF_ERROR_BUSY ) { nrf_delay_us ( 100 * 1000 ) ; nrf_dfu_wait ( ) ; } return res_code ; } 