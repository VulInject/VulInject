static int userfaultfd_unregister ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_range uffdio_unregister ; unsigned long new_flags ; bool found ; unsigned long start , end , vma_end ; const void __user * buf = ( void __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_unregister , buf , sizeof ( uffdio_unregister ) ) ) { out } ret = validate_range ( mm , uffdio_unregister . start , uffdio_unregister . len ) ; if ( ret ) { out } start = uffdio_unregister . start ; end = start + uffdio_unregister . len ; ret = - ENOMEM ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) { out_unlock } ret = - EINVAL ; if ( vma -> vm_start >= end ) { out_unlock } if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) { out_unlock } } found = false ; ret = - EINVAL ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( ! vma_can_userfault ( cur ) ) { out_unlock } found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) { prev = vma ; } ret = 0 ; { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; if ( ! vma -> vm_userfaultfd_ctx . ctx ) { skip } if ( vma -> vm_start > start ) { start = vma -> vm_start ; } vma_end = min ( end , vma -> vm_end ) ; if ( userfaultfd_missing ( vma ) ) { struct userfaultfd_wake_range range ; range . start = start ; range . len = vma_end - start ; wake_userfault ( vma -> vm_userfaultfd_ctx . ctx , & range ) ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) { vma = prev ; next } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) { break ; } } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) { break ; } } next vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; skip prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } vma && vma -> vm_start < end ; out_unlock up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; out return ret ; } 