static MagickBooleanType ReadHEICExifProfile ( Image * image , struct heif_image_handle * image_handle , ExceptionInfo * exception ) { heif_item_id id ; int count ; size_t length ; StringInfo * exif_profile ; struct heif_error error ; count = heif_image_handle_get_list_of_metadata_block_IDs ( image_handle , "Exif" , & id , 1 ) ; if ( count != 1 ) { return ( MagickTrue ) ; } length = heif_image_handle_get_metadata_size ( image_handle , id ) ; if ( length <= 8 ) { return ( MagickTrue ) ; } if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) { ThrowBinaryException ( CorruptImageError , "InsufficientImageDataInFile" , image -> filename ) ; } exif_profile = AcquireStringInfo ( length ) ; error = heif_image_handle_get_metadata ( image_handle , id , GetStringInfoDatum ( exif_profile ) ) ; if ( ( IsHEIFSuccess ( image , & error , exception ) != MagickFalse ) && ( length > 4 ) ) { StringInfo * snippet = SplitStringInfo ( exif_profile , 4 ) ; unsigned char * datum ; unsigned int offset = 0 ; datum = GetStringInfoDatum ( snippet ) ; offset |= ( unsigned int ) ( * ( datum ++ ) ) << 24 ; offset |= ( unsigned int ) ( * ( datum ++ ) ) << 16 ; offset |= ( unsigned int ) ( * ( datum ++ ) ) << 8 ; offset |= ( unsigned int ) ( * ( datum ++ ) ) << 0 ; snippet = DestroyStringInfo ( snippet ) ; length = GetStringInfoLength ( exif_profile ) ; datum = GetStringInfoDatum ( exif_profile , NULL ) ; if ( ( length > 2 ) && ( ( memcmp ( datum , "\xff\xd8" , 2 ) == 0 ) || ( memcmp ( datum , "\xff\xe1" , 2 ) == 0 ) ) && memcmp ( datum + length - 2 , "\xff\xd9" , 2 ) == 0 ) { SetStringInfoLength ( exif_profile , length - 2 ) ; } if ( offset < GetStringInfoLength ( exif_profile ) ) { ( void ) DestroyStringInfo ( SplitStringInfo ( exif_profile , offset ) ) ; ( void ) SetImageProfile ( image , "exif" , exif_profile ) ; } } exif_profile = DestroyStringInfo ( exif_profile ) ; return ( MagickTrue ) ; } 