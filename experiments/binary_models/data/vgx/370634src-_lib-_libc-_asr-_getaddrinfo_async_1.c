static int addrinfo_from_pkt ( struct asr_query * as , char * pkt , size_t pktlen ) { struct asr_unpack p ; struct asr_dns_header h ; struct asr_dns_query q ; struct asr_dns_rr rr ; int i ; { struct sockaddr sa ; struct sockaddr_in sain ; struct sockaddr_in6 sain6 ; } , u char buf [ MAXDNAME ] , * c ; _asr_unpack_init ( & p , pkt , pktlen ) ; _asr_unpack_header ( & p , & h ) ; for ( ; h . qdcount ; h . qdcount -- ) { _asr_unpack_query ( & p , & q ) ; } for ( i = 0 ; i < h . ancount ; i ++ ) { _asr_unpack_rr ( & p , & rr ) ; if ( rr . rr_type != q . q_type || rr . rr_class != q . q_class ) { continue ; } if ( rr . rr_type == T_A ) { u . sain . sin_len = sizeof u . sain ; u . sain . sin_family = AF_INET ; u . sain . sin_addr = rr . rr . in_a . addr ; u . sain . sin_port = 0 ; } if ( rr . rr_type == T_AAAA ) { u . sain6 . sin6_len = sizeof u . sain6 ; u . sain6 . sin6_family = AF_INET6 ; u . sain6 . sin6_addr = rr . rr . in_aaaa . addr6 ; u . sain6 . sin6_port = 0 ; } else { continue ; } if ( as -> as . ai . hints . ai_flags & AI_CANONNAME ) { _asr_strdname ( rr . rr_dname , buf , sizeof buf ) ; buf [ strlen ( buf ) - 1 ] = '\0' ; c = res_hnok ( buf ) ?buf : NULL ; } if ( as -> as . ai . hints . ai_flags & AI_FQDN ) { c = as -> as . ai . fqdn ; } else { c = NULL ; } if ( addrinfo_add ( as , & u . sa , c ) ) { return ( - 1 ) ; } } return ( 0 ) ; } 