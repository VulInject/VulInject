int pfctl_rules ( int dev , char * filename , int opts , int optimize , char * anchorname , struct pfr_buffer * trans ) { struct pfr_buffer * t , buf ; struct pfctl pf ; struct pf_ruleset * rs ; struct pfr_table trs ; char * path = NULL ; int osize ; char * p ; RB_INIT ( & pf_anchors ) ; memset ( & pf_main_anchor , 0 , sizeof ( pf_main_anchor ) ) ; pf_init_ruleset ( & pf_main_anchor . ruleset ) ; if ( trans == NULL ) { bzero ( & buf , sizeof ( buf ) ) ; buf . pfrb_type = PFRB_TRANS ; t = & buf ; osize = 0 ; } else { t = trans ; osize = t -> pfrb_size ; } memset ( & trs , 0 , sizeof ( trs ) ) ; if ( ( path = calloc ( 1 , PATH_MAX ) ) == NULL ) { ERRX ( "pfctl_rules: calloc" ) ; } if ( strlcpy ( trs . pfrt_anchor , anchorname , sizeof ( trs . pfrt_anchor ) ) >= sizeof ( trs . pfrt_anchor ) ) { ERRX ( "pfctl_rules: strlcpy" ) ; } pf . dev = dev ; pf . opts = opts ; pf . optimize = optimize ; if ( ( pf . anchor = calloc ( 1 , sizeof ( * pf . anchor ) ) ) == NULL ) { ERRX ( "pfctl_rules: calloc" ) ; } rs = & pf . anchor -> ruleset ; pf_init_ruleset ( rs ) ; rs -> anchor = pf . anchor ; if ( strlcpy ( pf . anchor -> path , anchorname , sizeof ( pf . anchor -> path ) ) >= sizeof ( pf . anchor -> path ) ) { errx ( 1 , "%s: strlcpy" , __func__ ) ; } if ( ( p = strrchr ( anchorname , '/' ) ) != NULL ) { if ( strlen ( p ) == 1 ) { errx ( 1 , "%s: bad anchor name %s" , __func__ , anchorname ) ; } } else { p = anchorname ; } if ( strlcpy ( pf . anchor -> name , p , sizeof ( pf . anchor -> name ) ) >= sizeof ( pf . anchor -> name ) ) { errx ( 1 , "%s: strlcpy" , __func__ ) ; } pf . astack [ 0 ] = pf . anchor ; pf . asd = 0 ; pf . trans = t ; pfctl_init_options ( & pf ) ; if ( ( opts & PF_OPT_NOACTION ) == 0 ) { if ( pfctl_ruleset_trans ( & pf , anchorname , pf . anchor ) ) { ERRX ( "pfctl_rules" ) ; } pf . astack [ 0 ] -> ruleset . tticket = pfctl_get_ticket ( t , PF_TRANS_TABLE , anchorname ) ; } if ( parse_config ( filename , & pf ) < 0 ) { if ( ( opts & PF_OPT_NOACTION ) == 0 ) { ERRX ( "Syntax error in config file: " "pf rules not loaded" ) ; } else { _error } } if ( ! anchorname [ 0 ] && ( pfctl_check_qassignments ( & pf . anchor -> ruleset ) || pfctl_load_queues ( & pf ) ) ) { if ( ( opts & PF_OPT_NOACTION ) == 0 ) { ERRX ( "Unable to load queues into kernel" ) ; } else { _error } } if ( pfctl_load_ruleset ( & pf , path , rs , 0 ) ) { if ( ( opts & PF_OPT_NOACTION ) == 0 ) { ERRX ( "Unable to load rules into kernel" ) ; } else { _error } } free ( path ) ; path = NULL ; if ( trans == NULL ) { if ( pfctl_load_anchors ( dev , & pf , t ) == - 1 ) { ERRX ( "load anchors" ) ; } pfctl_clear_queues ( & qspecs ) ; pfctl_clear_queues ( & rootqs ) ; if ( ( opts & PF_OPT_NOACTION ) == 0 ) { if ( ! anchorname [ 0 ] && pfctl_load_options ( & pf ) ) { _error } if ( pfctl_trans ( dev , t , DIOCXCOMMIT , osize ) ) { ERR ( "DIOCXCOMMIT" ) ; } } } return ( 0 ) ; _error if ( trans == NULL ) { if ( ( opts & PF_OPT_NOACTION ) == 0 ) { if ( pfctl_trans ( dev , t , DIOCXROLLBACK , osize ) ) { err ( 1 , "DIOCXROLLBACK" ) ; } } exit ( 1 ) ; } else { free ( path ) ; return ( - 1 ) ; } } 