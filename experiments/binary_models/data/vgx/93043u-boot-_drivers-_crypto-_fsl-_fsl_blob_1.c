int blob_decap ( u8 * key_mod , u8 * src , u8 * dst , u32 len ) { int ret , size , i = 0 ; u32 * desc ; if ( ! IS_ALIGNED ( ( uintptr_t ) key_mod , ARCH_DMA_MINALIGN ) || ! IS_ALIGNED ( ( uintptr_t ) src , ARCH_DMA_MINALIGN ) || ! IS_ALIGNED ( ( uintptr_t ) dst , ARCH_DMA_MINALIGN ) ) { puts ( "Error: blob_decap: Address arguments are not aligned!\n" ) ; return - EINVAL ; } printf ( "\nDecapsulating blob to get data\n" ) ; desc = malloc_cache_aligned ( sizeof ( int ) * MAX_CAAM_DESCSIZE ) ; if ( ! desc ) { debug ( "Not enough memory for descriptor allocation\n" ) ; return - ENOMEM ; } size = ALIGN ( 16 , ARCH_DMA_MINALIGN ) ; flush_dcache_range ( ( unsigned long ) key_mod , ( unsigned long ) key_mod + size ) ; size = ALIGN ( BLOB_SIZE ( len ) , ARCH_DMA_MINALIGN ) ; flush_dcache_range ( ( unsigned long ) src , ( unsigned long ) src + size ) ; inline_cnstr_jobdesc_blob_decap ( desc , key_mod , src , dst , len ) ; debug ( "Descriptor dump:\n" ) ; for ( i = 0 ; i < 14 ; i ++ ) { debug ( "Word[%d]: %08x\n" , i , * ( desc + i ) ) ; } size = ALIGN ( sizeof ( int ) * MAX_CAAM_DESCSIZE , ARCH_DMA_MINALIGN ) ; flush_dcache_range ( ( unsigned long ) desc , ( unsigned long ) desc + size ) ; flush_dcache_range ( ( unsigned long ) dst , ( unsigned long ) dst + size ) ; ret = run_descriptor_jr ( desc ) ; if ( ret ) { size = ALIGN ( len , ARCH_DMA_MINALIGN ) ; flush_dcache_range ( ( unsigned long ) dst , ( unsigned long ) dst + size ) ; printf ( "Error in blob decapsulation: %d\n" , ret ) ; } else { size = ALIGN ( len , ARCH_DMA_MINALIGN ) ; invalidate_dcache_range ( ( unsigned long ) dst , ( unsigned long ) dst + size ) ; puts ( "Blob decapsulation successful.\n" ) ; } free ( desc ) ; return ret ; } 