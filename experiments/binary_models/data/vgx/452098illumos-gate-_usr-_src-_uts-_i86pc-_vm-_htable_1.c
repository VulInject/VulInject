htable_t * htable_create ( hat_t * hat , uintptr_t vaddr , level_t level , htable_t * shared ) { uint_t h ; level_t l ; uintptr_t base ; htable_t * ht ; htable_t * higher = NULL ; htable_t * new = NULL ; if ( level ( 0 || level ) TOP_LEVEL ( hat ) ) { panic ( "htable_create(): level %d out of range\n" , level ) ; } ht = NULL ; for ( l = TOP_LEVEL ( hat ) ; l >= level ; -- l ) { new = NULL ; if ( l == TOP_LEVEL ( hat ) ) { base = 0 ; } else { base = vaddr & LEVEL_MASK ( l + 1 ) ; } h = HTABLE_HASH ( hat , base , l ) ; try_again HTABLE_ENTER ( h ) ; if ( l == TOP_LEVEL ( hat ) ) { ht = hat -> hat_htable ; } else { for ( ht = hat -> hat_ht_hash [ h ] ; ht ; ht = ht -> ht_next ) { ASSERT ( ht -> ht_hat == hat ) ; if ( ht -> ht_vaddr == base && ht -> ht_level == l ) { break ; } } } if ( ht != NULL ) { if ( l == level && shared && ht -> ht_shares && ht -> ht_shares != shared ) { panic ( "htable shared from wrong place " "found htable=%p shared=%p" , ( void * ) ht , ( void * ) shared ) ; } ++ ht -> ht_busy ; HTABLE_EXIT ( h ) ; if ( new ) { htable_free ( new ) ; } if ( higher != NULL ) { htable_release ( higher ) ; } higher = ht ; } if ( new == NULL ) { HTABLE_EXIT ( h ) ; new = htable_alloc ( hat , base , l , l == level ?shared : NULL ) ; try_again } else { ht = new ; if ( higher != NULL ) { link_ptp ( higher , ht , base ) ; ht -> ht_parent = higher ; } ht -> ht_next = hat -> hat_ht_hash [ h ] ; ASSERT ( ht -> ht_prev == NULL ) ; if ( hat -> hat_ht_hash [ h ] ) { hat -> hat_ht_hash [ h ] -> ht_prev = ht ; } hat -> hat_ht_hash [ h ] = ht ; HTABLE_EXIT ( h ) ; higher = ht ; if ( l == level && shared ) { ( void ) htable_lookup ( shared -> ht_hat , shared -> ht_vaddr , shared -> ht_level ) ; HATSTAT_INC ( hs_htable_shared , NULL ) ; } } } return ( ht ) ; } 