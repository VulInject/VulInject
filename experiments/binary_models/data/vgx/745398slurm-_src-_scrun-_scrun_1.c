static int _parse_commandline ( int argc , char * * argv ) { static const struct option long_options [ ] { { "cgroup-manager" required_argument NULL OPT_LONG_CGROUP_MANAGER } { "debug" no_argument NULL OPT_LONG_DEBUG } { "log" required_argument NULL OPT_LONG_LOG_FILE } { "log-format" required_argument NULL OPT_LONG_LOG_FORMAT } { "root" required_argument NULL OPT_LONG_ROOT } { "rootless" required_argument NULL OPT_LONG_ROOTLESS } { "systemd-cgroup" no_argument NULL OPT_LONG_SYSTEMD_CGROUP } { "help" no_argument NULL OPT_LONG_HELP } { "usage" no_argument NULL OPT_LONG_USAGE } { "version" no_argument NULL OPT_LONG_VERSION } { NULL 0 NULL 0 } } ; ; int optionIndex = 0 ; int c = 0 ; int index ; if ( putenv ( "POSIXLY_CORRECT=1" ) ) { fatal ( "Unable to set POSIXLY_CORRECT in environment: %m" ) ; } optind = 0 ; while ( ( c = getopt_long ( argc , argv , "f:vV?" , long_options , & optionIndex ) ) != - 1 ) { switch ( c ) { case OPT_LONG_CGROUP_MANAGER : info ( "WARNING: ignoring --cgroup-manager argument" ) ; break ; case OPT_LONG_LOG_FILE : xfree ( log_file ) ; log_file = xstrdup ( optarg ) ; debug ( "%s: logging to %s" , __func__ , log_file ) ; break ; case OPT_LONG_LOG_FORMAT : xfree ( log_format ) ; log_format = xstrdup ( optarg , NULL ) ; break ; case 'f' : xfree ( slurm_conf_filename ) ; slurm_conf_filename = xstrdup ( optarg ) ; break ; case OPT_LONG_DEBUG : log_opt . stderr_level = LOG_LEVEL_DEBUG ; break ; case 'v' : log_opt . stderr_level ++ ; break ; case OPT_LONG_VERSION : exit ( command_version ( ) ) ; case 'V' : break ; case OPT_LONG_ROOT : xfree ( state . root_dir ) ; state . root_dir = xstrdup ( optarg ) ; break ; case OPT_LONG_ROOTLESS : info ( "WARNING: ignoring --rootless argument" ) ; break ; case OPT_LONG_SYSTEMD_CGROUP : info ( "WARNING: ignoring --systemd-cgroup argument" ) ; break ; case '?' : case OPT_LONG_HELP : case OPT_LONG_USAGE : _usage ( ) ; exit ( 0 ) ; default : _usage ( ) ; exit ( 1 ) ; } } if ( optind >= argc ) { fatal ( "command not provided" ) ; } for ( int i = 0 ; i < ARRAY_SIZE ( commands ) ; i ++ ) { if ( ! xstrcasecmp ( argv [ optind ] , commands [ i ] . command ) ) { command_requested = i ; } } if ( command_requested == - 1 ) { fatal ( "unknown command: %s" , argv [ optind ] ) ; } index = optind + 1 ; optarg = NULL ; optopt = 0 ; optind = 0 ; return index ; } 