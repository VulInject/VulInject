static int btf_dumper_int ( const struct btf_type * t , __u8 bit_offset , const void * data , json_writer_t * jw , bool is_plain_text ) { __u32 * int_type ; __u32 nr_bits ; int_type = ( __u32 * ) ( t + 1 ) ; nr_bits = BTF_INT_BITS ( * int_type ) ; if ( bit_offset || BTF_INT_OFFSET ( * int_type ) || BITS_PER_BYTE_MASKED ( nr_bits ) ) { btf_dumper_int_bits ( * int_type , bit_offset , data , jw , is_plain_text ) ; return 0 ; } if ( nr_bits == 128 ) { return 0 ; } switch ( BTF_INT_ENCODING ( * int_type ) ) { case 0 : if ( BTF_INT_BITS ( * int_type ) == 64 ) { jsonw_printf ( jw , "%llu" , * ( __u64 * ) data ) ; } if ( BTF_INT_BITS ( * int_type ) == 32 ) { jsonw_printf ( jw , "%u" , * ( __u32 * ) data ) ; } if ( BTF_INT_BITS ( * int_type ) == 16 ) { jsonw_printf ( jw , "%hu" , * ( __u16 * ) data ) ; } if ( BTF_INT_BITS ( * int_type ) == 8 ) { jsonw_printf ( jw , "%hhu" , * ( __u8 * ) data ) ; } else { btf_dumper_int_bits ( * int_type , bit_offset , data , jw , is_plain_text ) ; } break ; case BTF_INT_SIGNED : if ( BTF_INT_BITS ( * int_type ) == 64 ) { jsonw_printf ( jw , "%lld" , * ( long long * ) data ) ; } if ( BTF_INT_BITS ( * int_type ) == 32 ) { jsonw_printf ( jw , "%d" , * ( int * ) data ) ; } if ( BTF_INT_BITS ( * int_type ) == 16 ) { jsonw_printf ( jw , "%hd" , * ( short * ) data ) ; } if ( BTF_INT_BITS ( * int_type ) == 8 ) { jsonw_printf ( jw , "%hhd" , * ( char * ) data ) ; } else { btf_dumper_int_bits ( * int_type , bit_offset , data , jw , is_plain_text ) ; } break ; case BTF_INT_CHAR : if ( isprint ( * ( char * ) data ) ) { jsonw_printf ( jw , "\"%c\"" , * ( char * ) data ) ; } if ( is_plain_text ) { jsonw_printf ( jw , "0x%hhx" , * ( char * ) data ) ; } else { jsonw_printf ( jw , "\"\\u00%02hhx\"" , * ( char * ) data ) ; } break ; case BTF_INT_BOOL : jsonw_bool ( jw , * ( bool * ) data ) ; break ; default : return - EINVAL ; } return 0 ; } 