struct VAR1 * FUN1 ( struct VAR2 * VAR3 , const VAR4 * VAR5 , gfp_t VAR6 ) { struct VAR7 * VAR8 = VAR3 -> VAR8 ; struct VAR9 * VAR10 = & VAR8 -> VAR10 ; struct VAR1 * VAR11 ; int VAR12 ; VAR11 = FUN2 ( sizeof ( * VAR11 ) + VAR10 -> VAR13 , VAR6 ) ; if ( ! VAR11 ) { return VAR14 ; } if ( FUN3 ( VAR10 , VAR15 ) ) { VAR11 -> VAR16 = FUN4 ( VAR17 ) ; if ( ! VAR11 -> VAR16 ) { free } } FUN5 ( & VAR11 -> VAR18 ) ; FUN5 ( & VAR11 -> VAR19 ) ; FUN6 ( & VAR11 -> VAR20 , VAR21 ) ; FUN6 ( & VAR11 -> VAR22 . VAR23 , VAR24 ) ; FUN7 ( & VAR11 -> VAR22 . VAR25 ) ; if ( FUN8 ( & VAR3 -> VAR26 ) ) { VAR11 -> VAR27 = FUN2 ( sizeof ( * VAR11 -> VAR27 ) , VAR6 ) ; if ( ! VAR11 -> VAR27 ) { free } FUN5 ( & VAR11 -> VAR27 -> VAR28 ) ; if ( FUN8 ( & VAR3 -> VAR26 ) && ! VAR3 -> VAR29 . VAR27 . VAR30 ) { FUN9 ( & VAR11 -> VAR27 -> VAR31 ) ; } VAR11 -> VAR27 -> VAR32 = VAR33 ; } memcpy ( VAR11 -> VAR5 , VAR5 , VAR34 ) ; memcpy ( VAR11 -> VAR11 . VAR5 , VAR5 , VAR34 ) ; VAR11 -> VAR11 . VAR35 = VAR8 -> VAR10 . VAR35 ; VAR11 -> VAR8 = VAR8 ; VAR11 -> VAR3 = VAR3 ; VAR11 -> VAR36 . VAR37 = VAR38 ; FUN10 ( & VAR11 -> VAR36 . VAR39 ) ; VAR11 -> VAR40 = VAR41 ; VAR11 -> VAR42 = VAR43 ; VAR11 -> VAR44 = FUN11 ( ) ; FUN12 ( & VAR11 -> VAR45 . signal ) ; for ( VAR12 = 0 ; VAR12 < FUN13 ( VAR11 -> VAR45 . VAR46 ) ; VAR12 ++ ) { FUN12 ( & VAR11 -> VAR45 . VAR46 [ VAR12 ] ) ; } if ( VAR8 -> VAR47 -> VAR48 ) { void * VAR49 ; int VAR50 = sizeof ( VAR51 ) + FUN14 ( VAR10 -> VAR52 , sizeof ( void * ) ) ; VAR49 = FUN15 ( FUN13 ( VAR11 -> VAR11 . VAR53 ) , VAR50 , VAR6 ) ; if ( ! VAR49 ) { free } for ( VAR12 = 0 ; VAR12 < FUN13 ( VAR11 -> VAR11 . VAR53 ) ; VAR12 ++ ) { struct VAR51 * VAR53 = VAR49 + VAR12 * VAR50 ; FUN16 ( VAR3 , VAR11 , VAR53 , VAR12 ) ; } } if ( FUN17 ( VAR8 , VAR11 , VAR6 ) ) { VAR54 } for ( VAR12 = 0 ; VAR12 < VAR55 ; VAR12 ++ ) { VAR11 -> VAR56 [ VAR12 ] = VAR12 ; } for ( VAR12 = 0 ; VAR12 < VAR57 ; VAR12 ++ ) { FUN18 ( & VAR11 -> VAR58 [ VAR12 ] ) ; FUN18 ( & VAR11 -> VAR59 [ VAR12 ] ) ; } for ( VAR12 = 0 ; VAR12 < VAR55 ; VAR12 ++ ) { VAR11 -> VAR60 [ VAR12 ] = FUN19 ( VAR61 ) ; } VAR11 -> VAR11 . VAR62 = VAR63 ; if ( VAR3 -> VAR26 . VAR64 == VAR65 || VAR3 -> VAR26 . VAR64 == VAR66 ) { struct VAR67 * VAR68 ; u8 VAR69 ; VAR68 = FUN20 ( VAR3 ) ; if ( ! VAR68 ) { VAR54 } VAR69 = ( VAR68 -> VAR70 . VAR71 & VAR72 ) >> VAR73 ; switch ( VAR69 ) { case VAR74 : VAR11 -> VAR75 = VAR63 ; break ; case VAR76 : VAR11 -> VAR75 = VAR77 ; break ; case VAR78 : VAR11 -> VAR75 = VAR79 ; break ; default : FUN21 ( 1 ) ; } } VAR11 -> VAR11 . VAR80 = VAR81 ; FUN22 ( VAR3 , "" , VAR11 -> VAR11 . VAR5 ) ; return VAR11 ; free_txq if ( VAR11 -> VAR11 . VAR53 [ 0 ] ) { FUN23 ( FUN24 ( VAR11 -> VAR11 . VAR53 [ 0 ] ) ) ; } free FUN23 ( VAR11 -> VAR27 ) ; FUN23 ( VAR11 ) ; return NULL ; }