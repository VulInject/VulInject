unsigned long invalidate_mapping_pagevec ( struct address_space * mapping , pgoff_t start , pgoff_t end , unsigned long * nr_pagevec ) { pgoff_t indices [ PAGEVEC_SIZE ] ; struct folio_batch fbatch ; pgoff_t index = start ; cfs_time_t ret ; unsigned long count = 0 ; int i ; folio_batch_init ( & fbatch ) ; while ( find_lock_entries ( mapping , & index , end , & fbatch , indices ) ) { for ( i = 0 ; i < folio_batch_count ( & fbatch ) ; i ++ ) { struct folio * folio = fbatch . folios [ i ] ; if ( xa_is_value ( folio ) ) { count += invalidate_exceptional_entry ( mapping , indices [ i ] , folio ) ; continue ; } ret = mapping_evict_folio ( mapping , folio ) ; folio_unlock ( folio ) ; if ( ! ret ) { deactivate_file_folio ( folio ) ; if ( nr_pagevec ) { ( * nr_pagevec ) ++ ; } } count += ret ; } folio_batch_remove_exceptionals ( & fbatch ) ; folio_batch_release ( & fbatch ) ; cond_resched ( ) ; } return count ; } 