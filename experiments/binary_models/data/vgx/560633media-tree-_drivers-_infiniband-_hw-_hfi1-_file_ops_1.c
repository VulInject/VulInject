static long hfi1_file_ioctl ( struct file * fp , unsigned int cmd , unsigned long arg ) { struct hfi1_filedata * fd = fp -> private_data ; struct hfi1_ctxtdata * uctxt = fd -> uctxt ; struct hfi1_user_info uinfo ; struct hfi1_tid_info tinfo ; int ret = 0 ; unsigned long addr ; int uval = 0 ; cfs_time_t ul_uval = 0 ; u16 uval16 = 0 ; hfi1_cdbg ( IOCTL , "IOCTL recv: 0x%x" , cmd ) ; if ( cmd != HFI1_IOCTL_ASSIGN_CTXT && cmd != HFI1_IOCTL_GET_VERS && ! uctxt ) { return - EINVAL ; } switch ( cmd ) { case HFI1_IOCTL_ASSIGN_CTXT : if ( uctxt ) { return - EINVAL ; } if ( copy_from_user ( & uinfo , ( hfi1_user_info __user * ) arg , sizeof ( uinfo ) ) ) { return - EFAULT ; } ret = assign_ctxt ( fd , & uinfo ) ; break ; case HFI1_IOCTL_CTXT_INFO : ret = get_ctxt_info ( fd , ( void __user * ) ( unsigned long ) arg , sizeof ( hfi1_ctxt_info ) ) ; break ; case HFI1_IOCTL_USER_INFO : ret = get_base_info ( fd , ( void __user * ) ( unsigned long ) arg , sizeof ( hfi1_base_info ) ) ; break ; case HFI1_IOCTL_CREDIT_UPD : if ( uctxt ) { sc_return_credits ( uctxt -> sc ) ; } break ; case HFI1_IOCTL_TID_UPDATE : if ( copy_from_user ( & tinfo , ( hfi11_tid_info __user * ) arg , sizeof ( tinfo ) ) ) { return - EFAULT ; } ret = hfi1_user_exp_rcv_setup ( fd , & tinfo ) ; if ( ! ret ) { addr = arg + offsetof ( hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) + sizeof ( tinfo . length ) ) ) { ret = - EFAULT ; } } break ; case HFI1_IOCTL_TID_FREE : if ( copy_from_user ( & tinfo , ( hfi11_tid_info __user * ) arg , sizeof ( tinfo ) ) ) { return - EFAULT ; } ret = hfi1_user_exp_rcv_clear ( fd , & tinfo ) ; if ( ret ) { break ; } addr = arg + offsetof ( hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) ) ) { ret = - EFAULT ; } break ; case HFI1_IOCTL_TID_INVAL_READ : if ( copy_from_user ( & tinfo , ( hfi11_tid_info __user * ) arg , sizeof ( tinfo ) ) ) { return - EFAULT ; } ret = hfi1_user_exp_rcv_invalid ( fd , & tinfo ) ; if ( ret ) { break ; } addr = arg + offsetof ( hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) ) ) { ret = - EFAULT ; } break ; case HFI1_IOCTL_RECV_CTRL : ret = get_user ( uval , ( int __user * ) arg ) ; if ( ret != 0 ) { return - EFAULT ; } ret = manage_rcvq ( uctxt , fd -> subctxt , uval ) ; break ; case HFI1_IOCTL_POLL_TYPE : ret = get_user ( uval , ( int __user * ) arg ) ; if ( ret != 0 ) { return - EFAULT ; } uctxt -> poll_type = ( typeof ( uctxt -> poll_type ) ) uval ; break ; case HFI1_IOCTL_ACK_EVENT : ret = get_user ( ul_uval , ( unsigned long __user * ) arg ) ; if ( ret != 0 ) { return - EFAULT ; } ret = user_event_ack ( uctxt , fd -> subctxt , ul_uval ) ; break ; case HFI1_IOCTL_SET_PKEY : ret = get_user ( uval16 , ( u16 __user * ) arg ) ; if ( ret != 0 ) { return - EFAULT ; } if ( HFI1_CAP_IS_USET ( PKEY_CHECK ) ) { ret = set_ctxt_pkey ( uctxt , fd -> subctxt , uval16 ) ; } else { return - EPERM ; } break ; case HFI1_IOCTL_CTXT_RESET : { struct send_context * sc ; struct hfi1_devdata * dd ; if ( ! uctxt || ! uctxt -> dd || ! uctxt -> sc ) { return - EINVAL ; } dd = uctxt -> dd ; sc = uctxt -> sc ; wait_event_interruptible_timeout ( sc -> halt_wait , ( sc -> flags & SCF_HALTED ) , msecs_to_jiffies ( SEND_CTXT_HALT_TIMEOUT ) ) ; if ( ! ( sc -> flags & SCF_HALTED ) ) { return - ENOLCK ; } if ( sc -> flags & SCF_FROZEN ) { wait_event_interruptible_timeout ( dd -> event_queue , ! ( ACCESS_ONCE ( dd -> flags ) & HFI1_FROZEN ) , msecs_to_jiffies ( SEND_CTXT_HALT_TIMEOUT ) ) ; if ( dd -> flags & HFI1_FROZEN ) { return - ENOLCK ; } if ( dd -> flags & HFI1_FORCED_FREEZE ) { return - ENODEV ; } sc_disable ( sc ) ; ret = sc_enable ( sc ) ; hfi1_rcvctrl ( dd , HFI1_RCVCTRL_CTXT_ENB , uctxt -> ctxt ) ; } else { ret = sc_restart ( sc ) ; } if ( ! ret ) { sc_return_credits ( sc ) ; } break ; } case HFI1_IOCTL_GET_VERS : uval = HFI1_USER_SWVERSION ; if ( put_user ( uval , ( int __user * ) arg ) ) { return - EFAULT ; } break ; default : return - EINVAL ; } return ret ; } 