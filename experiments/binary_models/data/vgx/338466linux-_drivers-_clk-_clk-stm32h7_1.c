static struct clk_hw * clk_register_stm32_pll ( struct device * dev , const char * name , const char * parent , unsigned long flags , const struct st32h7_pll_cfg * cfg , spinlock_t * lock ) { struct stm32_pll_obj * pll ; struct clk_init_data init = { NULL } ; struct clk_hw * hw ; int ret ; struct stm32_fractional_divider * div = NULL ; struct stm32_ready_gate * rgate ; pll = kmalloc ( sizeof ( * pll ) , GFP_KERNEL ) ; if ( ! pll ) { return ERR_PTR ( - ENOMEM ) ; } init . name = name ; init . ops = & pll_ops ; init . flags = flags ; init . parent_names = & parent ; init . num_parents = 1 ; pll -> hw . init = & init ; hw = & pll -> hw ; rgate = & pll -> rgate ; rgate -> bit_rdy = cfg -> bit_idx + 1 ; rgate -> gate . lock = lock ; rgate -> gate . reg = base + RCC_CR ; rgate -> gate . bit_idx = cfg -> bit_idx ; div = & pll -> div ; div -> flags = 0 ; div -> mreg = base + RCC_PLLCKSELR ; div -> mshift = cfg -> divm ; div -> mwidth = 6 ; div -> nreg = base + cfg -> offset_divr ; div -> nshift = 0 ; div -> nwidth = 9 ; div -> freg_status = base + RCC_PLLCFGR ; div -> freg_bit = cfg -> bit_frac_en ; div -> freg_value = base + cfg -> offset_frac ; div -> fshift = 3 ; div -> fwidth = 13 ; div -> lock = lock ; ret = clk_hw_register ( dev , hw ) ; if ( ret ) { kfree ( pll ) ; hw = ERR_PTR ( ret ) ; } return hw ; } 