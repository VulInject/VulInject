int __s_api_parse_map ( char * cp , char * * sid , char * * origA , char * * * mapA ) { char * sptr , * dptr , * * mapp ; int i , max ; * sid = NULL ; * origA = NULL ; * mapA = NULL ; sptr = cp ; dptr = strchr ( sptr , COLONTOK ) ; i = dptr - sptr + 1 ; * sid = ( char * ) malloc ( i ) ; if ( * sid == NULL ) { return ( NS_HASH_RC_NO_MEMORY ) ; } ( void ) strlcpy ( * sid , sptr , i ) ; sptr = dptr + 1 ; dptr = strchr ( sptr , TOKENSEPARATOR ) ; if ( dptr == NULL ) { free ( * sid ) ; * sid = NULL ; return ( NS_HASH_RC_SYNTAX_ERROR ) ; } i = dptr - sptr + 1 ; * origA = ( char * ) malloc ( i ) ; if ( * origA == NULL ) { free ( * sid ) ; * sid = NULL ; return ( NS_HASH_RC_NO_MEMORY ) ; } ( void ) strlcpy ( * origA , sptr , i ) ; sptr = dptr + 1 ; max = 1 ; for ( dptr = sptr ; * dptr ; dptr ++ ) { if ( * dptr == SPACETOK ) { max ++ ; while ( * ( dptr + 1 ) == SPACETOK ) { dptr ++ ; } } } * mapA = ( char * * ) calloc ( max + 1 , sizeof ( char * ) ) ; if ( * mapA == NULL ) { free ( * sid ) ; * sid = NULL ; free ( * origA ) ; * origA = NULL ; return ( NS_HASH_RC_NO_MEMORY ) ; } mapp = * mapA ; while ( * sptr ) { while ( * sptr == SPACETOK ) { sptr ++ ; } dptr = sptr ; while ( * dptr && * dptr != SPACETOK ) { dptr ++ ; } i = dptr - sptr + 1 ; * mapp = ( char * ) malloc ( i ) ; if ( * mapp == NULL ) { free ( * sid ) ; * sid = NULL ; free ( * origA ) ; * origA = NULL ; __s_api_free2dArray ( * mapA ) ; * mapA = NULL ; return ( NS_HASH_RC_NO_MEMORY ) ; } ( void ) strlcpy ( * mapp , sptr , i ) ; mapp ++ ; sptr = dptr ; } return ( NS_HASH_RC_SUCCESS ) ; } 