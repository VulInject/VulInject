static int mlxsw_sp_qevent_mall_replace ( struct mlxsw_sp * mlxsw_sp , struct mlxsw_sp_qevent_block * qevent_block , struct tc_cls_matchall_offload * f ) { struct mlxsw_sp_mall_entry * mall_entry ; struct flow_action_entry * act ; int err ; if ( ! list_empty ( & qevent_block -> mall_entry_list ) ) { NL_SET_ERR_MSG ( f -> common . extack , "At most one filter supported" ) ; return - EOPNOTSUPP ; } if ( f -> rule -> action . num_entries != 1 ) { NL_SET_ERR_MSG ( f -> common . extack , "Only singular actions supported" ) ; return - EOPNOTSUPP ; } if ( f -> common . chain_index ) { NL_SET_ERR_MSG ( f -> common . extack , "Only chain 0 is supported" ) ; return - EOPNOTSUPP ; } if ( f -> common . protocol != htons ( ETH_P_ALL ) ) { NL_SET_ERR_MSG ( f -> common . extack , "Protocol matching not supported" ) ; return - EOPNOTSUPP ; } act = & f -> rule -> action . entries [ 0 ] ; if ( ! ( act -> hw_stats & FLOW_ACTION_HW_STATS_DISABLED ) ) { NL_SET_ERR_MSG ( f -> common . extack , "HW counters not supported on qevents" ) ; return - EOPNOTSUPP ; } mall_entry = kmalloc ( sizeof ( * mall_entry ) , GFP_KERNEL ) ; if ( ! mall_entry ) { return - ENOMEM ; } mall_entry -> cookie = f -> cookie ; if ( act -> id == FLOW_ACTION_MIRRED ) { mall_entry -> type = MLXSW_SP_MALL_ACTION_TYPE_MIRROR ; mall_entry -> mirror . to_dev = act -> dev ; } if ( act -> id == FLOW_ACTION_TRAP ) { mall_entry -> type = MLXSW_SP_MALL_ACTION_TYPE_TRAP ; } else { NL_SET_ERR_MSG ( f -> common . extack , "Unsupported action" ) ; err = - EOPNOTSUPP ; err_unsupported_action } list_add_tail ( & mall_entry -> list , & qevent_block -> mall_entry_list ) ; err = mlxsw_sp_qevent_block_configure ( qevent_block , f -> common . extack ) ; if ( err ) { err_block_configure } return 0 ; err_block_configure list_del ( & mall_entry -> list ) ; err_unsupported_action kfree ( mall_entry ) ; return err ; } 