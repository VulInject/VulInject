static void recv_mgmt_msg_work_handler ( struct work_struct * work ) { struct hinic_mgmt_msg_handle_work * mgmt_work = container_of ( work , hinic_mgmt_msg_handle_work , work ) ; struct hinic_pf_to_mgmt * pf_to_mgmt = mgmt_work -> pf_to_mgmt ; struct pci_dev * pdev = pf_to_mgmt -> hwif -> pdev ; u8 * buf_out = pf_to_mgmt -> mgmt_ack_buf ; struct hinic_mgmt_cb * mgmt_cb ; unsigned long cb_state ; u16 out_size = 0 ; if ( mgmt_work -> mod >= HINIC_MOD_MAX ) { dev_err ( & pdev -> dev , "Unknown MGMT MSG module = %d\n" , mgmt_work -> mod ) ; kfree ( mgmt_work -> msg ) ; kfree ( mgmt_work ) ; return ; } mgmt_cb = & pf_to_mgmt -> mgmt_cb [ mgmt_work -> mod ] ; cb_state = cmpxchg ( & mgmt_cb -> state , HINIC_MGMT_CB_ENABLED , HINIC_MGMT_CB_ENABLED | HINIC_MGMT_CB_RUNNING ) ; if ( cb_state == HINIC_MGMT_CB_ENABLED && mgmt_cb -> cb ) { mgmt_cb -> cb ( mgmt_cb -> handle , mgmt_work -> cmd , mgmt_work -> msg , mgmt_work -> msg_len , buf_out , & out_size ) ; } else { dev_err ( & pdev -> dev , "No MGMT msg handler, mod: %d, cmd: %d\n" , mgmt_work -> mod , mgmt_work -> cmd ) ; } mgmt_cb -> state &= ~ HINIC_MGMT_CB_RUNNING ; if ( ! mgmt_work -> async_mgmt_to_pf ) { msg_to_mgmt_async ( pf_to_mgmt , mgmt_work -> mod , mgmt_work -> cmd , buf_out , out_size , MGMT_RESP , mgmt_work -> msg_id ) ; } kfree ( mgmt_work -> msg ) ; kfree ( mgmt_work ) ; } 