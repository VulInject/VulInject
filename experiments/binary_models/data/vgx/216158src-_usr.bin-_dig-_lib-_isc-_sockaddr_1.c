isc_result_t isc_sockaddr_totext ( const struct sockaddr_storage * sockaddr , isc_buffer_t * target ) { struct sockaddr_in * sin ; struct sockaddr_in6 * sin6 ; char pbuf [ sizeof ( "65000" ) ] ; unsigned int plen ; isc_region_t avail ; char tmp [ NI_MAXHOST ] ; REQUIRE ( sockaddr != NULL ) ; switch ( sockaddr -> ss_family ) { case AF_INET : sin = ( sockaddr_in * ) sockaddr ; sprintf ( pbuf , "%u" , ntohs ( sin -> sin_port ) ) ; break ; case AF_INET6 : sin6 = ( sockaddr_in6 * ) sockaddr ; snprintf ( pbuf , sizeof ( pbuf ) , "%u" , ntohs ( sin6 -> sin6_port ) ) ; break ; default : return ( ISC_R_FAILURE ) ; } plen = strlen ( pbuf ) ; INSIST ( plen < sizeof ( pbuf ) ) ; if ( getnameinfo ( ( sockaddr * ) sockaddr , sockaddr -> ss_len , tmp , sizeof ( tmp ) , NULL , 0 , NI_NUMERICHOST | NI_NUMERICSERV ) != 0 ) { return ( ISC_R_FAILURE ) ; } if ( strlen ( tmp ) > isc_buffer_availablelength ( target ) ) { return ( ISC_R_NOSPACE ) ; } isc_buffer_putmem ( target , tmp , strlen ( tmp ) ) ; if ( 1 + plen + 1 > isc_buffer_availablelength ( target ) ) { return ( ISC_R_NOSPACE ) ; } isc_buffer_putmem ( target , ( const unsigned char * ) "#" , 1 ) ; isc_buffer_putmem ( target , ( const unsigned char * ) pbuf , plen ) ; isc_buffer_availableregion ( target , & avail ) ; INSIST ( avail . length >= 1 ) ; avail . base [ 0 ] = '\0' ; return ( ISC_R_SUCCESS ) ; } 