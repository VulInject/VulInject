static int pwm_backlight_probe ( struct platform_device * pdev ) { struct platform_pwm_backlight_data * data = dev_get_platdata ( & pdev -> dev ) ; struct platform_pwm_backlight_data defdata ; struct backlight_properties props ; struct backlight_device * bl ; struct device_node * node = pdev -> dev . of_node ; struct pwm_bl_data * pb ; struct pwm_args pargs ; int ret ; if ( ! data ) { ret = pwm_backlight_parse_dt ( & pdev -> dev , & defdata ) ; if ( ret < 0 ) { dev_err ( & pdev -> dev , "failed to find platform data\n" ) ; return ret ; } data = & defdata ; } if ( data -> init ) { ret = data -> init ( & pdev -> dev ) ; if ( ret < 0 ) { return ret ; } } pb = devm_kzalloc ( & pdev -> dev , sizeof ( * pb ) , GFP_KERNEL ) ; if ( ! pb ) { ret = - ENOMEM ; err_alloc } if ( data -> levels ) { unsigned int i ; for ( i = 0 ; i <= data -> max_brightness ; i ++ ) { if ( data -> levels [ i ] > pb -> scale ) { pb -> scale = data -> levels [ i ] ; } } pb -> levels = data -> levels ; } else { pb -> scale = data -> max_brightness ; } pb -> notify = data -> notify ; pb -> notify_after = data -> notify_after ; pb -> check_fb = data -> check_fb ; pb -> exit = data -> exit ; pb -> dev = & pdev -> dev ; pb -> enabled = false ; pb -> enable_gpio = devm_gpiod_get_optional ( & pdev -> dev , "enable" , GPIOD_ASIS ) ; if ( IS_ERR ( pb -> enable_gpio ) ) { ret = PTR_ERR ( pb -> enable_gpio ) ; err_alloc } if ( ! pb -> enable_gpio && gpio_is_valid ( data -> enable_gpio ) ) { ret = devm_gpio_request_one ( & pdev -> dev , data -> enable_gpio , GPIOF_OUT_INIT_HIGH , "enable" ) ; if ( ret < 0 ) { dev_err ( & pdev -> dev , "failed to request GPIO#%d: %d\n" , data -> enable_gpio , ret ) ; err_alloc } pb -> enable_gpio = gpio_to_desc ( data -> enable_gpio ) ; } if ( pb -> enable_gpio && gpiod_get_direction ( pb -> enable_gpio ) != GPIOF_DIR_OUT ) { gpiod_direction_output ( pb -> enable_gpio , 1 ) ; } pb -> power_supply = devm_regulator_get ( & pdev -> dev , "power" ) ; if ( IS_ERR ( pb -> power_supply ) ) { ret = PTR_ERR ( pb -> power_supply , NULL ) ; err_alloc } pb -> pwm = devm_pwm_get ( & pdev -> dev , NULL ) ; if ( IS_ERR ( pb -> pwm ) && PTR_ERR ( pb -> pwm ) != - EPROBE_DEFER && ! node ) { dev_err ( & pdev -> dev , "unable to request PWM, trying legacy API\n" ) ; pb -> legacy = true ; pb -> pwm = pwm_request ( data -> pwm_id , "pwm-backlight" ) ; } if ( IS_ERR ( pb -> pwm ) ) { ret = PTR_ERR ( pb -> pwm ) ; if ( ret != - EPROBE_DEFER ) { dev_err ( & pdev -> dev , "unable to request PWM\n" ) ; } err_alloc } dev_dbg ( & pdev -> dev , "got pwm for backlight\n" ) ; pwm_apply_args ( pb -> pwm ) ; pwm_get_args ( pb -> pwm , & pargs ) ; pb -> period = pargs . period ; if ( ! pb -> period && ( data -> pwm_period_ns > 0 ) ) { pb -> period = data -> pwm_period_ns ; } pb -> lth_brightness = data -> lth_brightness * ( pb -> period / pb -> scale ) ; memset ( & props , 0 , sizeof ( backlight_properties ) ) ; props . type = BACKLIGHT_RAW ; props . max_brightness = data -> max_brightness ; bl = backlight_device_register ( dev_name ( & pdev -> dev ) , & pdev -> dev , pb , & pwm_backlight_ops , & props ) ; if ( IS_ERR ( bl ) ) { dev_err ( & pdev -> dev , "failed to register backlight\n" ) ; ret = PTR_ERR ( bl ) ; if ( pb -> legacy ) { pwm_free ( pb -> pwm ) ; } err_alloc } if ( data -> dft_brightness > data -> max_brightness ) { dev_warn ( & pdev -> dev , "invalid default brightness level: %u, using %u\n" , data -> dft_brightness , data -> max_brightness ) ; data -> dft_brightness = data -> max_brightness ; } bl -> props . brightness = data -> dft_brightness ; bl -> props . power = pwm_backlight_initial_power_state ( pb ) ; backlight_update_status ( bl ) ; platform_set_drvdata ( pdev , bl ) ; return 0 ; err_alloc if ( data -> exit ) { data -> exit ( & pdev -> dev ) ; } return ret ; } 