TmEcode NFQSetVerdict ( Packet * p ) { int iter = 0 ; NFQQueueVars * t = g_nfq_q + p -> nfq_v . nfq_index ; if ( PKT_IS_PSEUDOPKT ( p ) ) { return TM_ECODE_OK ; } NFQMutexLock ( t ) ; if ( t -> qh == NULL ) { NFQMutexUnlock ( t ) ; return TM_ECODE_OK ; } uint32_t verdict = GetVerdict ( p ) ; UpdateCounters ( t , p ) ; int ret = NFQVerdictCacheAdd ( t , p , verdict ) ; if ( ret == 0 ) { NFQMutexUnlock ( t ) ; return TM_ECODE_OK ; } { switch ( nfq_config . mode ) { default : case NFQ_ACCEPT_MODE : case NFQ_ROUTE_MODE : if ( p -> flags & PKT_MARK_MODIFIED ) { if ( p -> flags & PKT_STREAM_MODIFIED ) { ret = nfq_set_verdict2 ( t -> qh , p -> nfq_v . id , verdict , p -> nfq_v . mark , GET_PKT_LEN ( p ) , GET_PKT_DATA ( p ) ) ; } else { ret = nfq_set_verdict2 ( t -> qh , p -> nfq_v . id , verdict , p -> nfq_v . mark , 0 , NULL ) ; } if ( p -> flags & PKT_STREAM_MODIFIED ) { ret = nfq_set_verdict_mark ( t -> qh , p -> nfq_v . id , verdict , htonl ( p -> nfq_v . mark ) , GET_PKT_LEN ( p ) , GET_PKT_DATA ( p ) ) ; } else { ret = nfq_set_verdict_mark ( t -> qh , p -> nfq_v . id , verdict , htonl ( p -> nfq_v . mark ) , 0 , NULL ) ; } } else { if ( p -> flags & PKT_STREAM_MODIFIED ) { ret = nfq_set_verdict ( t -> qh , p -> nfq_v . id , verdict , GET_PKT_LEN ( p ) , GET_PKT_DATA ( p ) ) ; } else { ret = nfq_set_verdict ( t -> qh , p -> nfq_v . id , verdict , 0 , NULL ) ; } } break ; case NFQ_REPEAT_MODE : if ( p -> flags & PKT_STREAM_MODIFIED ) { ret = nfq_set_verdict2 ( t -> qh , p -> nfq_v . id , verdict , ( nfq_config . mark & nfq_config . mask ) | ( p -> nfq_v . mark & ~ nfq_config . mask ) , GET_PKT_LEN ( p ) , GET_PKT_DATA ( p ) ) ; } else { ret = nfq_set_verdict2 ( t -> qh , p -> nfq_v . id , verdict , ( nfq_config . mark & nfq_config . mask ) | ( p -> nfq_v . mark & ~ nfq_config . mask ) , 0 , NULL ) ; } if ( p -> flags & PKT_STREAM_MODIFIED ) { ret = nfq_set_verdict_mark ( t -> qh , p -> nfq_v . id , verdict , htonl ( ( nfq_config . mark & nfq_config . mask ) | ( p -> nfq_v . mark & ~ nfq_config . mask ) ) , GET_PKT_LEN ( p ) , GET_PKT_DATA ( p ) ) ; } else { ret = nfq_set_verdict_mark ( t -> qh , p -> nfq_v . id , verdict , htonl ( ( nfq_config . mark & nfq_config . mask ) | ( p -> nfq_v . mark & ~ nfq_config . mask ) ) , 0 , NULL ) ; } break ; } } ( ret < 0 ) && ( iter ++ < NFQ_VERDICT_RETRY_TIME ) ; NFQMutexUnlock ( t ) ; if ( ret < 0 ) { SCLogWarning ( "nfq_set_verdict of %p failed %" PRId32 ": %s" , p , ret , strerror ( errno ) ) ; return TM_ECODE_FAILED ; } return TM_ECODE_OK ; } 