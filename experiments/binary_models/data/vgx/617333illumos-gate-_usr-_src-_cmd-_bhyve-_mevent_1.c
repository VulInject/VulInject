void mevent_dispatch ( void ) { struct kevent changelist [ MEVENT_MAX ] ; struct kevent eventlist [ MEVENT_MAX ] ; struct mevent * pipev ; int numev ; struct mevent * pipev ; int ret ; cap_rights_t rights ; mevent_tid = pthread_self ( ) ; mevent_set_name ( ) ; pthread_once ( & mevent_once , mevent_init ) ; ret = pipe ( mevent_pipefd ) ; if ( ret < 0 ) { perror ( "pipe" ) ; exit ( 0 ) ; } cap_rights_init ( & rights , CAP_EVENT , CAP_READ , CAP_WRITE ) ; if ( caph_rights_limit ( mevent_pipefd [ 0 ] , & rights ) == - 1 ) { errx ( EX_OSERR , "Unable to apply rights for sandbox" ) ; } if ( caph_rights_limit ( mevent_pipefd [ 1 ] , & rights ) == - 1 ) { errx ( EX_OSERR , "Unable to apply rights for sandbox" ) ; } pipev = mevent_add ( mevent_pipefd [ 0 ] , EVF_READ , mevent_pipe_read , NULL ) ; for ( ; ; ) { numev = mevent_build ( changelist ) ; if ( numev ) { ret = kevent ( mfd , changelist , numev , NULL , 0 , NULL ) ; if ( ret == - 1 ) { perror ( "Error return from kevent change" ) ; } } ret = kevent ( mfd , NULL , 0 , eventlist , MEVENT_MAX , NULL ) ; if ( ret == - 1 && errno != EINTR ) { perror ( "Error return from kevent monitor" ) ; } mevent_handle ( eventlist , ret ) ; port_event_t pev ; mevent_update_pending ( ) ; ret = port_get ( mfd , & pev , NULL ) ; if ( ret != 0 ) { if ( errno != EINTR ) { perror ( "Error return from port_get" ) ; } continue ; } mevent_handle_pe ( & pev ) ; } } 