static void do_prom_report ( struct timeval now ) { struct buf report = BUF_INITIALIZER ; int fd , i , r ; int64_t last_updated ; fd = open ( prom_report_fname , O_RDWR | O_CREAT , S_IRUSR | S_IWUSR ) ; if ( fd == - 1 ) { syslog ( LOG_ERR , "open(%s): %m - %s" , prom_report_fname , "disabling master prometheus report until next reload" ) ; prom_enabled = 0 ; return ; } r = lock_setlock ( fd , 1 , 1 , prom_report_fname ) ; if ( r == - 1 ) { if ( errno != EWOULDBLOCK ) { syslog ( LOG_ERR , "lock_setlock(%s): %m - %s" , prom_report_fname , "disabling master prometheus report until next reload" ) ; prom_enabled = 0 ; } return ; } syslog ( LOG_DEBUG , "updating prometheus report for master process" ) ; last_updated = now_ms ( ) ; buf_printf ( & report , "# HELP %s %s\n" , "cyrus_master_ready_workers" , "The number of ready workers" ) ; buf_appendcstr ( & report , "# TYPE cyrus_master_ready_workers gauge\n" ) ; for ( i = 0 ; i < nservices ; i ++ ) { const struct service * s = & Services [ i ] ; buf_printf ( & report , "cyrus_master_ready_workers{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %d %" PRId64 "\n" , s -> ready_workers , last_updated ) ; } for ( i = 0 ; i < nwaitdaemons ; i ++ ) { const struct service * s = & WaitDaemons [ i ] ; buf_printf ( & report , "cyrus_master_ready_workers{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %d %" PRId64 "\n" , s -> ready_workers , last_updated ) ; } buf_printf ( & report , "# HELP %s %s\n" , "cyrus_master_forks_total" , "The number of children spawned" ) ; buf_appendcstr ( & report , "# TYPE cyrus_master_forks_total counter\n" ) ; for ( i = 0 ; i < nservices ; i ++ ) { const struct service * s = & Services [ i ] ; buf_printf ( & report , "cyrus_master_forks_total{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %d %" PRId64 "\n" , s -> nforks , last_updated ) ; } for ( i = 0 ; i < nwaitdaemons ; i ++ ) { const struct service * s = & WaitDaemons [ i ] ; buf_printf ( & report , "cyrus_master_forks_total{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %d %" PRId64 "\n" , s -> nforks , last_updated ) ; } buf_printf ( & report , "# HELP %s %s\n" , "cyrus_master_active_children" , "The number of children servicing clients" ) ; buf_appendcstr ( & report , "# TYPE cyrus_master_active_children gauge\n" ) ; for ( i = 0 ; i < nservices ; i ++ ) { const struct service * s = & Services [ i ] ; buf_printf ( & report , "cyrus_master_active_children{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %d %" PRId64 "\n" , s -> nactive , last_updated ) ; } for ( i = 0 ; i < nwaitdaemons ; i ++ ) { const struct service * s = & WaitDaemons [ i ] ; buf_printf ( & report , "cyrus_master_active_children{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %d %" PRId64 "\n" , s -> nactive , last_updated ) ; } buf_printf ( & report , "# HELP %s %s\n" , "cyrus_master_max_children" , "The maximum number of child processes" ) ; buf_appendcstr ( & report , "# TYPE cyrus_master_max_children gauge\n" ) ; for ( i = 0 ; i < nservices ; i ++ ) { const struct service * s = & Services [ i ] ; buf_printf ( & report , "cyrus_master_max_children{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %d %" PRId64 "\n" , s -> max_workers , last_updated ) ; } for ( i = 0 ; i < nwaitdaemons ; i ++ ) { const struct service * s = & WaitDaemons [ i ] ; buf_printf ( & report , "cyrus_master_max_children{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %d %" PRId64 "\n" , s -> max_workers , last_updated ) ; } buf_printf ( & report , "# HELP %s %s\n" , "cyrus_master_forks_per_second" , "The rate at which we're spawning children" ) ; buf_appendcstr ( & report , "# TYPE cyrus_master_forks_per_second gauge\n" ) ; for ( i = 0 ; i < nservices ; i ++ ) { const struct service * s = & Services [ i ] ; buf_printf ( & report , "cyrus_master_forks_per_second{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %g %" PRId64 "\n" , s -> forkrate , last_updated ) ; } for ( i = 0 ; i < nwaitdaemons ; i ++ ) { const struct service * s = & WaitDaemons [ i ] ; buf_printf ( & report , "cyrus_master_forks_per_second{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %g %" PRId64 "\n" , s -> forkrate , last_updated ) ; } buf_printf ( & report , "# HELP %s %s\n" , "cyrus_master_max_forks_per_second" , "The maximum rate at which we will spawn children" ) ; buf_appendcstr ( & report , "# TYPE cyrus_master_max_forks_per_second gauge\n" ) ; for ( i = 0 ; i < nservices ; i ++ ) { const struct service * s = & Services [ i ] ; buf_printf ( & report , "cyrus_master_max_forks_per_second{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %u %" PRId64 "\n" , s -> maxforkrate , last_updated ) ; } for ( i = 0 ; i < nwaitdaemons ; i ++ ) { const struct service * s = & WaitDaemons [ i ] ; buf_printf ( & report , "cyrus_master_max_forks_per_second{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %u %" PRId64 "\n" , s -> maxforkrate , last_updated ) ; } buf_printf ( & report , "# HELP %s %s\n" , "cyrus_master_ready_fails_total" , "The number of failures in READY state" ) ; buf_appendcstr ( & report , "# TYPE cyrus_master_ready_fails_total counter\n" ) ; for ( i = 0 ; i < nservices ; i ++ ) { const struct service * s = & Services [ i ] ; buf_printf ( & report , "cyrus_master_ready_fails_total{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %d %" PRId64 "\n" , s -> nreadyfails , last_updated ) ; } for ( i = 0 ; i < nwaitdaemons ; i ++ ) { const struct service * s = & WaitDaemons [ i ] ; buf_printf ( & report , "cyrus_master_ready_fails_total{service=\"%s\",family=\"%s\"}" , s -> name , s -> familyname ) ; buf_printf ( & report , " %d %" PRId64 "\n" , s -> nreadyfails , last_updated ) ; } retry_write ( fd , buf_cstring ( & report ) , buf_len ( & report ) ) ; if ( ftruncate ( fd , buf_len ( & report ) ) ) { syslog ( LOG_ERR , "IOERROR: failed to truncate prom file %s: %m" , prom_report_fname ) ; } lock_unlock ( fd , prom_report_fname ) ; close ( fd ) ; prom_prev_report = now ; buf_free ( & report ) ; } 