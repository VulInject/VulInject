fixup_segment ( , ) { int seg_reloc_count = 0 ; valueT add_number ; fragS * fragP ; segT add_symbol_segment = absolute_section ; if ( fixP != NULL && abs_section_sym == NULL ) { abs_section_sym = section_symbol ( absolute_section ) ; } if ( linkrelax && TC_LINKRELAX_FIXUP ( this_segment ) ) { for ( ; fixP ; fixP = fixP -> fx_next ) { if ( ! fixP -> fx_done ) { if ( fixP -> fx_addsy == NULL ) { fixP -> fx_addsy = abs_section_sym ; } symbol_mark_used_in_reloc ( fixP -> fx_addsy ) ; if ( fixP -> fx_subsy != NULL ) { symbol_mark_used_in_reloc ( fixP -> fx_subsy ) ; } seg_reloc_count ++ ; } } TC_ADJUST_RELOC_COUNT ( fixP , seg_reloc_count ) ; return seg_reloc_count ; } for ( ; fixP ; fixP = fixP -> fx_next ) { fprintf ( stderr , "\nprocessing fixup:\n" ) ; print_fixup ( fixP ) ; fragP = fixP -> fx_frag ; know ( fragP ) ; TC_VALIDATE_FIX ( fixP , this_segment , skip ) ; add_number = fixP -> fx_offset ; if ( fixP -> fx_addsy != NULL && symbol_mri_common_p ( fixP -> fx_addsy ) ) { add_number += S_GET_VALUE ( fixP -> fx_addsy ) ; fixP -> fx_offset = add_number ; fixP -> fx_addsy = symbol_get_value_expression ( fixP -> fx_addsy ) -> X_add_symbol ; } if ( fixP -> fx_addsy != NULL ) { add_symbol_segment = S_GET_SEGMENT ( fixP -> fx_addsy ) ; } if ( fixP -> fx_subsy != NULL ) { segT sub_symbol_segment ; resolve_symbol_value ( fixP -> fx_subsy ) ; sub_symbol_segment = S_GET_SEGMENT ( fixP -> fx_subsy ) ; if ( fixP -> fx_addsy != NULL && sub_symbol_segment == add_symbol_segment && ! TC_FORCE_RELOCATION_SUB_SAME ( fixP , add_symbol_segment ) ) { add_number += S_GET_VALUE ( fixP -> fx_addsy ) ; add_number -= S_GET_VALUE ( fixP -> fx_subsy ) ; fixP -> fx_offset = add_number ; fixP -> fx_addsy = NULL ; fixP -> fx_subsy = NULL ; fixP -> fx_pcrel = 0 ; } if ( sub_symbol_segment == absolute_section && ! TC_FORCE_RELOCATION_SUB_ABS ( fixP ) ) { add_number -= S_GET_VALUE ( fixP -> fx_subsy ) ; fixP -> fx_offset = add_number ; fixP -> fx_subsy = NULL ; } if ( sub_symbol_segment == this_segment && ! TC_FORCE_RELOCATION_SUB_LOCAL ( fixP ) ) { add_number -= S_GET_VALUE ( fixP -> fx_subsy ) ; fixP -> fx_offset = ( add_number + fixP -> fx_dot_value + fixP -> fx_frag -> fr_address ) ; if ( 0 || 1 || ! fixP -> fx_pcrel ) { add_number += MD_PCREL_FROM_SECTION ( fixP , this_segment ) ; } fixP -> fx_subsy = NULL ; fixP -> fx_pcrel = 1 ; } if ( ! TC_VALIDATE_FIX_SUB ( fixP ) ) { as_bad_where ( fixP -> fx_file , fixP -> fx_line , _ ( "can't resolve `%s' {%s section} - `%s' {%s section}" ) , fixP -> fx_addsy ?S_GET_NAME ( fixP -> fx_addsy ) : "0" , segment_name ( add_symbol_segment ) , S_GET_NAME ( fixP -> fx_subsy ) , segment_name ( sub_symbol_segment ) ) ; } } if ( fixP -> fx_addsy ) { if ( add_symbol_segment == this_segment && ! TC_FORCE_RELOCATION_LOCAL ( fixP ) ) { add_number += S_GET_VALUE ( fixP -> fx_addsy ) ; fixP -> fx_offset = add_number ; if ( fixP -> fx_pcrel ) { add_number -= MD_PCREL_FROM_SECTION ( fixP , this_segment ) ; } fixP -> fx_addsy = NULL ; fixP -> fx_pcrel = 0 ; } if ( add_symbol_segment == absolute_section && ! TC_FORCE_RELOCATION_ABS ( fixP ) ) { add_number += S_GET_VALUE ( fixP -> fx_addsy ) ; fixP -> fx_offset = add_number ; fixP -> fx_addsy = NULL ; } if ( add_symbol_segment != undefined_section && ! bfd_is_com_section ( add_symbol_segment ) && MD_APPLY_SYM_VALUE ( fixP ) ) { add_number += S_GET_VALUE ( fixP -> fx_addsy ) ; } } if ( fixP -> fx_pcrel ) { add_number -= MD_PCREL_FROM_SECTION ( fixP , this_segment ) ; if ( ! fixP -> fx_done && fixP -> fx_addsy == NULL ) { fixP -> fx_addsy = abs_section_sym ; } } if ( ! fixP -> fx_done ) { md_apply_fix ( fixP , & add_number , this_segment ) ; } if ( ! fixP -> fx_done ) { ++ seg_reloc_count ; if ( fixP -> fx_addsy == NULL ) { fixP -> fx_addsy = abs_section_sym ; } symbol_mark_used_in_reloc ( fixP -> fx_addsy ) ; if ( fixP -> fx_subsy != NULL ) { symbol_mark_used_in_reloc ( fixP -> fx_subsy ) ; } } if ( ! fixP -> fx_bit_fixP && ! fixP -> fx_no_overflow && fixP -> fx_size != 0 ) { if ( fixP -> fx_size < sizeof ( valueT ) ) { valueT mask ; mask = 0 ; mask -- ; mask <<= fixP -> fx_size * 8 - ( fixP -> fx_signed ?1 : 0 ) ; if ( ( add_number & mask ) != 0 && ( add_number & mask ) != mask ) { char buf [ 50 ] , buf2 [ 50 ] ; sprint_value ( buf , fragP -> fr_address + fixP -> fx_where ) ; if ( add_number > 1000 ) { sprint_value ( buf2 , add_number ) ; } else { sprintf ( buf2 , "%ld" , ( long ) add_number ) ; } as_bad_where ( fixP -> fx_file , fixP -> fx_line , _ ( "value of %s too large for field of %d bytes at %s" ) , buf2 , fixP -> fx_size , buf ) ; } } if ( ! flag_signed_overflow_ok && fixP -> fx_size == 2 && add_number > 0x7fff ) { as_bad_where ( fixP -> fx_file , fixP -> fx_line , _ ( "signed .word overflow; switch may be too large; %ld at 0x%lx" ) , ( long ) add_number , ( long ) ( fragP -> fr_address + fixP -> fx_where ) ) ; } } skip ATTRIBUTE_UNUSED_LABEL ; fprintf ( stderr , "result:\n" ) ; print_fixup ( fixP ) ; } TC_ADJUST_RELOC_COUNT ( fixP , seg_reloc_count ) ; return seg_reloc_count ; } 