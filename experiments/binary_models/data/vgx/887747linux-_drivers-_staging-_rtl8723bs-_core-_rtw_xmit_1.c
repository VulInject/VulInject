void wakeup_sta_to_xmit ( struct adapter * padapter , struct sta_info * psta ) { u8 update_mask = 0 , wmmps_ac = 0 ; struct sta_info * psta_bmc ; struct list_head * xmitframe_plist , * xmitframe_phead , * tmp ; struct xmit_frame * pxmitframe = NULL ; struct sta_priv * pstapriv = & padapter -> stapriv ; struct xmit_priv * pxmitpriv = & padapter -> xmitpriv ; psta_bmc = rtw_get_bcmc_stainfo ( padapter ) ; spin_lock_bh ( & pxmitpriv -> lock ) ; xmitframe_phead = get_list_head ( & psta -> sleep_q ) ; list_for_each_safe ( , , ) { pxmitframe = list_entry ( xmitframe_plist , xmit_frame , list ) ; list_del_init ( & pxmitframe -> list ) ; switch ( pxmitframe -> attrib . priority ) { case 1 : case 2 : wmmps_ac = psta -> uapsd_bk & BIT ( 1 ) ; break ; case 4 : case 5 : wmmps_ac = psta -> uapsd_vi & BIT ( 1 ) ; break ; case 6 : case 7 : wmmps_ac = psta -> uapsd_vo & BIT ( 1 ) ; break ; case 0 : case 3 : default : wmmps_ac = psta -> uapsd_be & BIT ( 1 ) ; break ; } psta -> sleepq_len -- ; if ( psta -> sleepq_len > 0 ) { pxmitframe -> attrib . mdata = 1 ; } else { pxmitframe -> attrib . mdata = 0 ; } if ( wmmps_ac ) { psta -> sleepq_ac_len -- ; if ( psta -> sleepq_ac_len > 0 ) { pxmitframe -> attrib . mdata = 1 ; pxmitframe -> attrib . eosp = 0 ; } else { pxmitframe -> attrib . mdata = 0 ; pxmitframe -> attrib . eosp = 1 ; } } rtw_hal_xmitframe_enqueue ( padapter , pxmitframe ) ; } if ( psta -> sleepq_len == 0 ) { if ( pstapriv -> tim_bitmap & BIT ( psta -> aid ) ) { update_mask = BIT ( 0 ) ; } pstapriv -> tim_bitmap &= ~ BIT ( psta -> aid ) ; if ( psta -> state & WIFI_SLEEP_STATE ) { psta -> state ^= WIFI_SLEEP_STATE ; } if ( psta -> state & WIFI_STA_ALIVE_CHK_STATE ) { psta -> expire_to = pstapriv -> expire_to ; psta -> state ^= WIFI_STA_ALIVE_CHK_STATE ; } pstapriv -> sta_dz_bitmap &= ~ BIT ( psta -> aid ) ; } if ( ! psta_bmc ) { _exit } if ( ( pstapriv -> sta_dz_bitmap & 0xfffe ) == 0x0 ) { xmitframe_phead = get_list_head ( & psta_bmc -> sleep_q ) ; list_for_each_safe ( , , ) { pxmitframe = list_entry ( xmitframe_plist , xmit_frame , list ) ; list_del_init ( & pxmitframe -> list ) ; psta_bmc -> sleepq_len -- ; if ( psta_bmc -> sleepq_len > 0 ) { pxmitframe -> attrib . mdata = 1 ; } else { pxmitframe -> attrib . mdata = 0 ; } pxmitframe -> attrib . triggered = 1 ; rtw_hal_xmitframe_enqueue ( padapter , pxmitframe ) ; } if ( psta_bmc -> sleepq_len == 0 ) { if ( pstapriv -> tim_bitmap & BIT ( 0 ) ) { update_mask |= BIT ( 1 ) ; } pstapriv -> tim_bitmap &= ~ BIT ( 0 ) ; pstapriv -> sta_dz_bitmap &= ~ BIT ( 0 ) ; } } _exit spin_unlock_bh ( & pxmitpriv -> lock ) ; if ( update_mask ) { update_beacon ( padapter , WLAN_EID_TIM , NULL , true ) ; } } 