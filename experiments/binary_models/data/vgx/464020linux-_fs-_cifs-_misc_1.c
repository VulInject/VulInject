void cifs_close_deferred_file ( struct cifsInodeInfo * cifs_inode ) { struct cifsFileInfo * cfile = NULL ; struct file_list * tmp_list , * tmp_next_list ; struct list_head file_head ; if ( cifs_inode == NULL ) { return ; } INIT_LIST_HEAD ( & file_head ) ; spin_lock ( & cifs_inode -> open_file_lock ) ; list_for_each_entry ( , , ) { if ( delayed_work_pending ( & cfile -> deferred ) ) { if ( cancel_delayed_work ( & cfile -> deferred ) ) { cifs_del_deferred_close ( cfile ) ; tmp_list = kmalloc ( sizeof ( file_list ) , GFP_ATOMIC ) ; if ( tmp_list == NULL ) { break ; } tmp_list -> cfile = cfile ; list_add_tail ( & tmp_list -> list , & file_head ) ; } } } spin_unlock ( & cifs_inode -> open_file_lock ) ; list_for_each_entry_safe ( , , , ) { _cifsFileInfo_put ( tmp_list -> cfile , true , false ) ; list_del ( & tmp_list -> list ) ; } } 