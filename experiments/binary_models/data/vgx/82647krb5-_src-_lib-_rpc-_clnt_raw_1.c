static enum clnt_stat clntraw_call ( CLIENT * h , rpcproc_t proc , xdrproc_t xargs , void * argsp , xdrproc_t xresults , void * resultsp , struct timeval timeout ) { struct clntraw_private * clp = clntraw_private ; XDR * xdrs = & clp -> xdr_stream ; struct rpc_msg msg ; enum clnt_stat status ; struct rpc_err error ; long procl = proc ; call_again xdrs -> x_op = XDR_ENCODE ; XDR_SETPOS ( xdrs , 0 ) ; clp -> u . mashl_rpcmsg . rm_xid ++ ; if ( ( ! XDR_PUTBYTES ( xdrs , clp -> u . mashl_callmsg , clp -> mcnt ) ) || ( ! XDR_PUTLONG ( xdrs , & procl ) ) || ( ! AUTH_MARSHALL ( h -> cl_auth , xdrs ) ) || ( ! * xargs ( xdrs , argsp ) ) ) { return ( RPC_CANTENCODEARGS ) ; } ( void ) XDR_GETPOS ( xdrs ) ; svc_getreq ( 1 ) ; xdrs -> x_op = XDR_DECODE ; XDR_SETPOS ( xdrs , 0 ) ; msg . acpted_rply . ar_verf = gssrpc__null_auth ; msg . acpted_rply . ar_results . where = resultsp ; msg . acpted_rply . ar_results . proc = xresults ; if ( ! xdr_replymsg ( xdrs , & msg ) ) { enum xdr_op op = xdrs -> x_op ; xdrs -> x_op = XDR_FREE ; xdr_replymsg ( xdrs , & msg ) ; xdrs -> x_op = op ; return ( RPC_CANTDECODERES ) ; } gssrpc__seterr_reply ( & msg , & error ) ; status = error . re_status ; if ( status == RPC_SUCCESS ) { if ( ! AUTH_VALIDATE ( h -> cl_auth , & msg . acpted_rply . ar_verf ) ) { status = RPC_AUTHERROR ; } } else { if ( AUTH_REFRESH ( h -> cl_auth , & msg ) ) { call_again } } if ( status == RPC_SUCCESS ) { if ( ! AUTH_VALIDATE ( h -> cl_auth , & msg . acpted_rply . ar_verf ) ) { status = RPC_AUTHERROR ; } if ( msg . acpted_rply . ar_verf . oa_base != NULL ) { xdrs -> x_op = XDR_FREE ; ( void ) xdr_opaque_auth ( xdrs , & ( msg . acpted_rply . ar_verf ) ) ; } } return ( status ) ; } 