static int stress ( struct uffd_stats * uffd_stats ) { unsigned long cpu ; pthread_t locking_threads [ nr_cpus ] ; pthread_t uffd_threads [ nr_cpus ] ; pthread_t background_threads [ nr_cpus ] ; for ( cpu = 0 ; cpu < nr_cpus ; cpu ++ ) { if ( pthread_create ( & locking_threads [ cpu ] , & attr , locking_thread , ( void * ) cpu ) ) { return 1 ; } if ( bounces & BOUNCE_POLL ) { if ( pthread_create ( & uffd_threads [ cpu ] , & attr , uffd_poll_thread , ( void * ) & uffd_stats [ cpu ] ) ) { return 1 ; } } else { if ( pthread_create ( & uffd_threads [ cpu ] , & attr , uffd_read_thread , ( void * ) & uffd_stats [ cpu ] ) ) { return 1 ; } pthread_mutex_lock ( & uffd_read_mutex ) ; } if ( pthread_create ( & background_threads [ cpu ] , & attr , background_thread , ( void * ) cpu ) ) { return 1 ; } } for ( cpu = 0 ; cpu < nr_cpus ; cpu ++ ) { if ( pthread_join ( background_threads [ cpu ] , NULL ) ) { return 1 ; } } uffd_test_ops -> release_pages ( area_src ) ; finished = 1 ; for ( cpu = 0 ; cpu < nr_cpus ; cpu ++ ) { if ( pthread_join ( locking_threads [ cpu ] , NULL ) ) { return 1 ; } } for ( cpu = 0 ; cpu < nr_cpus ; cpu ++ ) { char c ; if ( bounces & BOUNCE_POLL ) { if ( write ( pipefd [ cpu * 2 + 1 ] , & c , 1 ) != 1 ) { err ( "pipefd write error" ) ; } if ( pthread_join ( uffd_threads [ cpu ] , ( void * ) & uffd_stats [ cpu ] ) ) { return 1 ; } } else { if ( pthread_cancel ( uffd_threads [ cpu ] ) ) { return 1 ; } if ( pthread_join ( uffd_threads [ cpu ] , NULL ) ) { return 1 ; } } } return 0 ; } sigjmp_buf jbuf , * sigbuf ; static void sighndl ( int sig , siginfo_t * siginfo , void * ptr ) { if ( sig == SIGBUS ) { if ( sigbuf ) { siglongjmp ( * sigbuf , 1 ) ; } abort ( ) ; } } 