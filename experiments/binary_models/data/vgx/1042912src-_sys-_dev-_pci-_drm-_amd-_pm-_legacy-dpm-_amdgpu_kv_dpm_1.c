static int kv_populate_acp_table ( struct amdgpu_device * adev ) { struct kv_power_info * pi = kv_get_pi ( adev ) ; struct amdgpu_clock_voltage_dependency_table * table = & adev -> pm . dpm . dyn_state . acp_clock_voltage_dependency_table ; struct atom_clock_dividers dividers ; int ret ; u32 i ; pi -> acp_level_count = 0 ; for ( i = 0 ; i < table -> count ; i ++ ) { pi -> acp_level [ i ] . Frequency = cpu_to_be32 ( table -> entries [ i ] . clk ) ; pi -> acp_level [ i ] . MinVoltage = cpu_to_be16 ( table -> entries [ i ] . v ) ; ret = amdgpu_atombios_get_clock_dividers ( adev , COMPUTE_ENGINE_PLL_PARAM , table -> entries [ i ] . clk , false , & dividers ) ; if ( ret ) { return ret ; } pi -> acp_level [ i ] . Divider = ( u8 ) dividers . post_div ; pi -> acp_level_count ++ ; } ret = amdgpu_kv_copy_bytes_to_smc ( adev , pi -> dpm_table_start + offsetof ( SMU7_Fusion_DpmTable , AcpLevelCount ) , ( u8 * ) & pi -> acp_level_count , sizeof ( u8 ) , pi -> sram_end ) ; if ( ret ) { return ret ; } pi -> acp_interval = 1 ; ret = amdgpu_kv_copy_bytes_to_smc ( adev , pi -> dpm_table_start + offsetof ( SMU7_Fusion_DpmTable , ACPInterval ) , ( u8 * ) & pi -> acp_interval , sizeof ( u8 ) , pi -> sram_end ) ; if ( ret ) { return ret ; } ret = amdgpu_kv_copy_bytes_to_smc ( adev , pi -> dpm_table_start + offsetof ( SMU7_Fusion_DpmTable , AcpLevel ) , ( u8 * ) & pi -> acp_level , sizeof ( SMU7_Fusion_ExtClkLevel ) * SMU7_MAX_LEVELS_ACP , pi -> sram_end ) ; if ( ret ) { return ret ; } return ret ; } 