int main ( int argc , char * * argv ) { krb5_principal client , server ; krb5_ccache ccache ; krb5_creds in_creds , * creds ; krb5_ticket * ticket ; krb5_flags options = 0 ; char * name ; int c ; check ( krb5_init_context ( & ctx ) ) ; while ( ( c = getopt ( argc , argv , "ft" ) ) != - 1 ) { switch ( c ) { case 'f' : options |= KRB5_GC_FORWARDABLE ; break ; case 't' : options |= KRB5_GC_NO_TRANSIT_CHECK ; break ; default : abort ( ) ; } } argc -= optind ; argv += optind ; assert ( argc == 2 ) ; check ( krb5_parse_name ( ctx , argv [ 1 ] , & server ) ) ; if ( strcmp ( argv [ 0 ] , "unknown" ) == 0 ) { server -> type = KRB5_NT_UNKNOWN ; } if ( strcmp ( argv [ 0 ] , "principal" ) == 0 ) { server -> type = KRB5_NT_PRINCIPAL ; } if ( strcmp ( argv [ 0 ] , "srv-inst" ) == 0 ) { server -> type = KRB5_NT_SRV_INST ; } if ( strcmp ( argv [ 0 ] , "srv-hst" ) == 0 ) { server -> type = KRB5_NT_SRV_HST ; } else { abort ( ) ; } check ( krb5_cc_default ( ctx , & ccache ) ) ; check ( krb5_cc_get_principal ( ctx , ccache , & client ) ) ; memset ( & in_creds , 0 , sizeof ( in_creds ) ) ; in_creds . client = client ; in_creds . server = server ; check ( krb5_get_credentials ( ctx , options , ccache , & in_creds , & creds ) ) ; check ( krb5_decode_ticket ( & creds -> ticket , & ticket ) ) ; check ( krb5_unparse_name ( ctx , ticket -> server , & name ) ) ; printf ( "%s\n" , name ) ; krb5_free_ticket ( ctx , ticket ) ; krb5_free_unparsed_name ( ctx , name ) ; krb5_free_creds ( ctx , creds ) ; krb5_free_principal ( ctx , client ) ; krb5_free_principal ( ctx , server ) ; krb5_cc_close ( ctx , ccache ) ; return 0 ; } 