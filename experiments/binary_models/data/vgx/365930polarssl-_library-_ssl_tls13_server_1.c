static int ssl_tls13_parse_key_exchange_modes_ext ( mbedtls_ssl_context * ssl , const unsigned char * buf , const unsigned char * end ) { const unsigned char * p = buf ; size_t ke_modes_len ; int ke_modes ; MBEDTLS_SSL_CHK_BUF_READ_PTR ( p , end , 1 ) ; ke_modes_len = * p ++ ; if ( ke_modes_len > 2 ) { MBEDTLS_SSL_PEND_FATAL_ALERT ( MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER , MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER ) ; return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE ; } MBEDTLS_SSL_CHK_BUF_READ_PTR ( p , end , ke_modes_len ) ; while ( ke_modes_len -- != 0 ) { switch ( * p ++ ) { case MBEDTLS_SSL_TLS1_3_PSK_MODE_PURE : ke_modes |= MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK ; MBEDTLS_SSL_DEBUG_MSG ( 3 , ( "Found PSK KEX MODE" ) ) ; break ; case MBEDTLS_SSL_TLS1_3_PSK_MODE_ECDHE : ke_modes |= MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_EPHEMERAL ; MBEDTLS_SSL_DEBUG_MSG ( 3 , ( "Found PSK_EPHEMERAL KEX MODE" ) ) ; break ; default : MBEDTLS_SSL_PEND_FATAL_ALERT ( MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER , MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER ) ; return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER ; } } ssl -> handshake -> tls13_kex_modes = ke_modes ; return 0 ; } 