static int mov_write_chan_tag ( AVFormatContext * s , AVIOContext * pb , MOVTrack * track ) { uint32_t layout_tag , bitmap , * channel_desc ; int64_t pos = avio_tell ( pb ) ; int num_desc , ret ; if ( track -> multichannel_as_mono ) { return 0 ; } ret = ff_mov_get_channel_layout_tag ( track -> par , & layout_tag , & bitmap , & channel_desc ) ; if ( ret < 0 ) { if ( ret == AVERROR ( ENOSYS ) ) { av_log ( s , AV_LOG_WARNING , "not writing 'chan' tag due to " "lack of channel information\n" ) ; ret = 0 ; } return ret ; } if ( layout_tag == MOV_CH_LAYOUT_MONO && track -> mono_as_fc > 0 ) { av_assert0 ( ! channel_desc ) ; channel_desc = av_malloc ( sizeof ( * channel_desc ) ) ; if ( ! channel_desc ) { return AVERROR ( ENOMEM ) ; } layout_tag = 0 ; bitmap = 0 ; * channel_desc = 3 ; } num_desc = layout_tag ?0 : track -> par -> ch_layout . nb_channels ; avio_wb32 ( pb , 0 ) ; ffio_wfourcc ( pb , "chan" ) ; avio_w8 ( pb , 0 ) ; avio_wb24 ( pb , 0 ) ; avio_wb32 ( pb , layout_tag ) ; avio_wb32 ( pb , bitmap ) ; avio_wb32 ( pb , num_desc ) ; for ( int i = 0 ; i < num_desc ; i ++ ) { avio_wb32 ( pb , channel_desc [ i ] ) ; avio_wb32 ( pb , 0 ) ; avio_wl32 ( pb , 0 ) ; avio_wl32 ( pb , 0 ) ; avio_wl32 ( pb , 0 ) ; } return update_size ( pb , pos ) ; } 