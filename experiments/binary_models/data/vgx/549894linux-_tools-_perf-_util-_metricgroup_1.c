static int parse_groups ( struct evlist * perf_evlist , const char * str , bool metric_no_group , bool metric_no_merge , const char * user_requested_cpu_list , bool system_wide , struct perf_pmu * fake_pmu , struct rblist * metric_events_list , const struct pmu_metrics_table * table ) { struct evlist * combined_evlist = NULL ; LIST_HEAD ( metric_list ) ; struct metric * m ; bool tool_events [ PERF_TOOL_MAX ] { false } ; ; int ret ; if ( metric_events_list -> nr_entries == 0 ) { metricgroup__rblist_init ( metric_events_list ) ; } ret = metricgroup__add_metric_list ( str , metric_no_group , user_requested_cpu_list , system_wide , & metric_list , table ) ; if ( ret ) { out } list_sort ( NULL , & metric_list , metric_list_cmp ) ; if ( ! metric_no_merge ) { struct expr_parse_ctx * combined = NULL ; find_tool_events ( & metric_list , tool_events ) ; ret = build_combined_expr_ctx ( & metric_list , & combined ) ; if ( ! ret && combined && hashmap__size ( combined -> ids ) ) { ret = parse_ids ( metric_no_merge , fake_pmu , combined , NULL , true , tool_events , & combined_evlist ) ; } if ( combined ) { expr__ctx_free ( combined ) ; } if ( ret ) { out } } list_for_each_entry ( , , ) { struct metric_event * me ; struct evsel * * metric_events ; struct evlist * metric_evlist = NULL ; struct metric * n ; struct metric_expr * expr ; if ( combined_evlist && m -> has_constraint ) { metric_evlist = combined_evlist ; } if ( ! metric_no_merge ) { list_for_each_entry ( , , ) { if ( m == n ) { break ; } if ( n -> evlist == NULL ) { continue ; } if ( ( ! m -> modifier && n -> modifier ) || ( m -> modifier && ! n -> modifier ) || ( m -> modifier && n -> modifier && strcmp ( m -> modifier , n -> modifier ) ) ) { continue ; } if ( expr__subset_of_ids ( n -> pctx , m -> pctx ) ) { pr_debug ( "Events in '%s' fully contained within '%s'\n" , m -> metric_name , n -> metric_name ) ; metric_evlist = n -> evlist ; break ; } } } if ( ! metric_evlist ) { ret = parse_ids ( metric_no_merge , fake_pmu , m -> pctx , m -> modifier , m -> has_constraint , tool_events , & m -> evlist ) ; if ( ret ) { out } metric_evlist = m -> evlist ; } ret = setup_metric_events ( m -> pctx -> ids , metric_evlist , & metric_events ) ; if ( ret ) { pr_debug ( "Cannot resolve IDs for %s: %s\n" , m -> metric_name , m -> metric_expr ) ; out } me = metricgroup__lookup ( metric_events_list , metric_events [ 0 ] , true ) ; expr = malloc ( sizeof ( metric_expr ) ) ; if ( ! expr ) { ret = - ENOMEM ; out } expr -> metric_refs = m -> metric_refs ; m -> metric_refs = NULL ; expr -> metric_expr = m -> metric_expr ; if ( m -> modifier ) { char * tmp ; if ( asprintf ( & tmp , "%s:%s" , m -> metric_name , m -> modifier ) < 0 ) { expr -> metric_name = NULL ; } else { expr -> metric_name = tmp ; } } else { expr -> metric_name = strdup ( m -> metric_name ) ; } if ( ! expr -> metric_name ) { ret = - ENOMEM ; free ( metric_events ) ; out } expr -> metric_unit = m -> metric_unit ; expr -> metric_events = metric_events ; expr -> runtime = m -> pctx -> sctx . runtime ; list_add ( & expr -> nd , & me -> head ) ; } if ( combined_evlist ) { evlist__splice_list_tail ( perf_evlist , & combined_evlist -> core . entries ) ; evlist__delete ( combined_evlist ) ; } list_for_each_entry ( , , ) { if ( m -> evlist ) { evlist__splice_list_tail ( perf_evlist , & m -> evlist -> core . entries ) ; } } out metricgroup__free_metrics ( & metric_list ) ; return ret ; } 