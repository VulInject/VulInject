static void eib_rb_ctl_setup_ud_channel ( eib_t * ss , eib_vnic_t * vnic ) { eib_chan_t * chan = vnic -> vn_ctl_chan ; ibt_status_t ret ; if ( chan -> ch_chan ) { chan -> ch_tear_down = B_TRUE ; if ( ( ret = ibt_flush_channel ( chan -> ch_chan ) ) != IBT_SUCCESS ) { EIB_DPRINTF_WARN ( ss -> ei_instance , "eib_rb_ctl_setup_ud_channel: " "ibt_flush_channel() failed, ret=%d" , ret ) ; } mutex_enter ( & chan -> ch_tx_lock ) ; while ( chan -> ch_tx_posted > 0 ) { cv_wait ( & chan -> ch_tx_cv , & chan -> ch_tx_lock ) ; } mutex_exit ( & chan -> ch_tx_lock ) ; mutex_enter ( & chan -> ch_rx_lock ) ; while ( chan -> ch_rx_posted > 0 ) { cv_wait ( & chan -> ch_rx_cv , & chan -> ch_rx_lock ) ; } mutex_exit ( & chan -> ch_rx_lock ) ; if ( ( ret = ibt_free_channel ( chan -> ch_chan ) ) != IBT_SUCCESS ) { EIB_DPRINTF_WARN ( ss -> ei_instance , "eib_rb_ctl_setup_ud_channel: " "ibt_free_channel() failed, ret=%d" , ret ) ; } chan -> ch_alloc_mp = B_FALSE ; chan -> ch_ip_hdr_align = 0 ; chan -> ch_rwqe_bktsz = 0 ; chan -> ch_lwm_rwqes = 0 ; chan -> ch_max_rwqes = 0 ; chan -> ch_max_swqes = 0 ; chan -> ch_qpn = 0 ; chan -> ch_chan = NULL ; } } 