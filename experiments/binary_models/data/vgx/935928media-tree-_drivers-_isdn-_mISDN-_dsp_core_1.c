module_param ( dtmfthreshold , uint , S_IRUGO | S_IWUSR ) ; MODULE_LICENSE ( "GPL" ) ; spinlock_t dsp_lock ; struct list_head dsp_ilist ; struct list_head conf_ilist ; int dsp_debug ; int dsp_options ; int dsp_poll , dsp_tics ; static void dsp_rx_off_member ( struct dsp * dsp ) { struct mISDN_ctrl_req cq ; int rx_off = 1 ; if ( ! dsp -> features_rx_off ) { return ; } if ( ! dsp -> rx_disabled ) { rx_off = 0 ; } if ( dsp -> dtmf . software ) { rx_off = 0 ; } if ( dsp -> echo . software ) { rx_off = 0 ; } if ( dsp -> conf && dsp -> conf -> software ) { rx_off = 0 ; } if ( rx_off == dsp -> rx_is_off ) { return ; } if ( ! dsp -> ch . peer ) { if ( dsp_debug & DEBUG_DSP_CORE ) { printk ( KERN_DEBUG "%s: no peer, no rx_off\n" , __func__ ) ; } return ; } cq . op = MISDN_CTRL_RX_OFF ; cq . p1 = rx_off ; if ( dsp -> ch . peer -> ctrl ( dsp -> ch . peer , CONTROL_CHANNEL , & cq ) ) { printk ( KERN_DEBUG "%s: 2nd CONTROL_CHANNEL failed\n" , __func__ ) ; return ; } dsp -> rx_is_off = rx_off ; if ( dsp_debug & DEBUG_DSP_CORE ) { printk ( KERN_DEBUG "%s: %s set rx_off = %d\n" , __func__ , dsp -> name , rx_off ) ; } } 