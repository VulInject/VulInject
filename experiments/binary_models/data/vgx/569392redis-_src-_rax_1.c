int raxSeek ( raxIterator * it , const char * op , unsigned char * ele , size_t len ) { int eq = 0 , lt = 0 , gt = 0 , first = 0 , last = 0 ; it -> stack . items = 0 ; it -> flags |= RAX_ITER_JUST_SEEKED ; it -> flags &= ~ RAX_ITER_EOF ; it -> key_len = 0 ; it -> node = NULL ; if ( op [ 0 ] == '>' ) { gt = 1 ; if ( op [ 1 ] == '=' ) { eq = 1 ; } } if ( op [ 0 ] == '<' ) { lt = 1 ; if ( op [ 1 ] == '=' ) { eq = 1 ; } } if ( op [ 0 ] == '=' ) { eq = 1 ; } if ( op [ 0 ] == '^' ) { first = 1 ; } if ( op [ 0 ] == '$' ) { last = 1 ; } else { errno = 0 ; return 0 ; } if ( it -> rt -> numele == 0 ) { it -> flags |= RAX_ITER_EOF ; return 1 ; } if ( first ) { return raxSeek ( it , ">=" , NULL , 0 ) ; } if ( last ) { it -> node = it -> rt -> head ; assert ( it -> node -> iskey ) ; it -> data = raxGetData ( it -> node ) ; return 1 ; } int splitpos = 0 ; size_t i = raxLowWalk ( it -> rt , ele , len , & it -> node , NULL , & splitpos , & it -> stack ) ; if ( it -> stack . oom ) { return 0 ; } if ( eq && i == len && ( ! it -> node -> iscompr || splitpos == 0 ) && it -> node -> iskey ) { if ( ! raxIteratorAddChars ( it , ele , len ) ) { return 0 ; } it -> data = raxGetData ( it -> node ) ; } if ( lt || gt ) { raxIteratorAddChars ( it , ele , i - splitpos ) ; debugf ( "After initial seek: i=%d len=%d key=%.*s\n" , ( int ) i , ( int ) len , ( int ) it -> key_len , it -> key ) ; if ( i != len && ! it -> node -> iscompr ) { if ( ! raxIteratorAddChars ( it , ele + i , 1 ) ) { return 0 ; } debugf ( "Seek normal node on mismatch: %.*s\n" , ( int ) it -> key_len , ( char * ) it -> key ) ; it -> flags &= ~ RAX_ITER_JUST_SEEKED ; if ( lt && ! raxIteratorPrevStep ( it , 1 ) ) { return 0 ; } if ( gt && ! raxIteratorNextStep ( it , 1 ) ) { return 0 ; } it -> flags |= RAX_ITER_JUST_SEEKED ; } if ( i != len && it -> node -> iscompr ) { debugf ( "Compressed mismatch: %.*s\n" , ( int ) it -> key_len , ( char * ) it -> key ) ; int nodechar = it -> node -> data [ splitpos ] ; int keychar = ele [ i ] ; it -> flags &= ~ RAX_ITER_JUST_SEEKED ; if ( gt ) { if ( nodechar > keychar ) { if ( ! raxIteratorNextStep ( it , 0 ) ) { return 0 ; } } else { if ( ! raxIteratorAddChars ( it , it -> node -> data , it -> node -> size ) ) { return 0 ; } if ( ! raxIteratorNextStep ( it , 1 ) ) { return 0 ; } } } if ( lt ) { if ( nodechar < keychar ) { if ( ! raxSeekGreatest ( it ) ) { return 0 ; } it -> data = raxGetData ( it -> node ) ; } else { if ( ! raxIteratorAddChars ( it , it -> node -> data , it -> node -> size ) ) { return 0 ; } if ( ! raxIteratorPrevStep ( it , 1 ) ) { return 0 ; } } } it -> flags |= RAX_ITER_JUST_SEEKED ; } else { debugf ( "No mismatch: %.*s\n" , ( int ) it -> key_len , ( char * ) it -> key ) ; it -> flags &= ~ RAX_ITER_JUST_SEEKED ; if ( it -> node -> iscompr && it -> node -> iskey && splitpos && lt ) { it -> data = raxGetData ( it -> node ) ; } else { if ( gt && ! raxIteratorNextStep ( it , 0 ) ) { return 0 ; } if ( lt && ! raxIteratorPrevStep ( it , 0 ) ) { return 0 ; } } it -> flags |= RAX_ITER_JUST_SEEKED ; } } else { it -> flags |= RAX_ITER_EOF ; return 1 ; } return 1 ; } 