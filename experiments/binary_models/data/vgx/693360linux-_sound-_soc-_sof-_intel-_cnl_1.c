static void cnl_ipc_host_done ( struct snd_sof_dev * sdev ) static void cnl_ipc_dsp_done ( struct snd_sof_dev * sdev ) irqreturn_t cnl_ipc4_irq_thread ( int irq , void * context ) { struct sof_ipc4_msg notification_data = { { 0 } } ; struct snd_sof_dev * sdev = context ; bool ack_received = false ; bool ipc_irq = false ; u32 hipcida , hipctdr ; hipcida = snd_sof_dsp_read ( sdev , HDA_DSP_BAR , CNL_DSP_REG_HIPCIDA ) ; hipctdr = snd_sof_dsp_read ( sdev , HDA_DSP_BAR , CNL_DSP_REG_HIPCTDR ) ; if ( hipcida & CNL_DSP_REG_HIPCIDA_DONE ) { snd_sof_dsp_update_bits ( sdev , HDA_DSP_BAR , CNL_DSP_REG_HIPCCTL , CNL_DSP_REG_HIPCCTL_DONE , 0 ) ; cnl_ipc_dsp_done ( sdev ) ; ipc_irq = true ; ack_received = true ; } if ( hipctdr & CNL_DSP_REG_HIPCTDR_BUSY ) { u32 hipctdd = snd_sof_dsp_read ( sdev , HDA_DSP_BAR , CNL_DSP_REG_HIPCTDD ) ; u32 primary = hipctdr & CNL_DSP_REG_HIPCTDR_MSG_MASK ; u32 extension = hipctdd & CNL_DSP_REG_HIPCTDD_MSG_MASK ; if ( primary & SOF_IPC4_MSG_DIR_MASK ) { if ( likely ( sdev -> fw_state == SOF_FW_BOOT_COMPLETE ) ) { struct sof_ipc4_msg * data = sdev -> ipc -> msg . reply_data ; data -> primary = primary ; data -> extension = extension ; spin_lock_irq ( & sdev -> ipc_lock ) ; snd_sof_ipc_get_reply ( sdev ) ; cnl_ipc_host_done ( sdev ) ; snd_sof_ipc_reply ( sdev , data -> primary ) ; spin_unlock_irq ( & sdev -> ipc_lock ) ; } else { dev_dbg_ratelimited ( sdev -> dev , "IPC reply before FW_READY: %#x|%#x\n" , primary , extension ) ; } } else { notification_data . primary = primary ; notification_data . extension = extension ; sdev -> ipc -> msg . rx_data = & notification_data ; snd_sof_ipc_msgs_rx ( sdev ) ; cnl_ipc_host_done ( sdev ) ; } ipc_irq = true ; } if ( ! ipc_irq ) { dev_dbg_ratelimited ( sdev -> dev , "nothing to do in IPC IRQ thread\n" ) ; } if ( ack_received ) { struct sof_intel_hda_dev * hdev = sdev -> pdata -> hw_pdata ; if ( hdev -> delayed_ipc_tx_msg ) { cnl_ipc4_send_msg ( sdev , hdev -> delayed_ipc_tx_msg ) ; } } return IRQ_HANDLED ; } 