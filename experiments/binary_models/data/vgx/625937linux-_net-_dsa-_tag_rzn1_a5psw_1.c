static struct sk_buff * a5psw_tag_rcv ( struct sk_buff * skb , struct net_device * dev ) { struct a5psw_tag * tag ; int port ; if ( unlikely ( ! pskb_may_pull ( skb , A5PSW_TAG_LEN ) ) ) { dev_warn_ratelimited ( & dev -> dev , "Dropping packet, cannot pull\n" ) ; return NULL ; } tag = dsa_etype_header_pos_rx ( skb ) ; if ( tag -> ctrl_tag != htons ( ETH_P_DSA_A5PSW ) ) { dev_warn_ratelimited ( & dev -> dev , "Dropping packet due to invalid TAG marker\n" ) ; return NULL ; } port = FIELD_GET ( A5PSW_CTRL_DATA_PORT , ntohs ( tag -> ctrl_data ) ) ; skb -> dev = dsa_master_find_slave ( dev , 0 , port ) ; if ( ! skb -> dev ) { return NULL ; } skb_pull_rcsum ( skb , A5PSW_TAG_LEN ) ; dsa_strip_etype_header ( skb , A5PSW_TAG_LEN ) ; dsa_default_offload_fwd_mark ( skb , NULL ) ; return skb ; } static const struct dsa_device_ops a5psw_netdev_ops = { . name = A5PSW_NAME . proto = DSA_TAG_PROTO_RZN1_A5PSW . xmit = a5psw_tag_xmit . rcv = a5psw_tag_rcv . needed_headroom = A5PSW_TAG_LEN } ; 