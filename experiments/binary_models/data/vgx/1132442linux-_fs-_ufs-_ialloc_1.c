static void ufs2_init_inodes_chunk ( struct super_block * sb , struct ufs_cg_private_info * ucpi , struct ufs_cylinder_group * ucg ) { struct buffer_head * bh ; struct ufs_sb_private_info * uspi = UFS_SB ( sb ) -> s_uspi ; sector_t beg = uspi -> s_sbbase + ufs_inotofsba ( ucpi -> c_cgx * uspi -> s_ipg + fs32_to_cpu ( sb , ucg -> cg_u . cg_u2 . cg_initediblk ) ) ; sector_t end = beg + uspi -> s_fpb ; UFSD ( "ENTER cgno %d\n" , ucpi -> c_cgx ) ; for ( ; beg < end ; ++ beg ) { bh = sb_getblk ( sb , beg ) ; lock_buffer ( bh ) ; memset ( bh -> b_data , 0 , sb -> s_blocksize ) ; set_buffer_uptodate ( bh ) ; mark_buffer_dirty ( bh ) ; unlock_buffer ( bh ) ; if ( sb -> s_flags & SB_SYNCHRONOUS ) { sync_dirty_buffer ( bh ) ; } brelse ( bh ) ; } fs32_add ( sb , & ucg -> cg_u . cg_u2 . cg_initediblk , uspi -> s_inopb ) ; ubh_mark_buffer_dirty ( UCPI_UBH ( ucpi ) ) ; if ( sb -> s_flags & SB_SYNCHRONOUS ) { ubh_sync_block ( UCPI_UBH ( ucpi ) ) ; } UFSD ( "EXIT\n" ) ; } struct inode * ufs_new_inode ( struct inode * dir , umode_t mode ) { struct super_block * sb ; struct ufs_sb_info * sbi ; struct ufs_sb_private_info * uspi ; struct ufs_cg_private_info * ucpi ; struct ufs_cylinder_group * ucg ; struct inode * inode ; struct timespec64 ts ; unsigned cg , bit , i , j , start ; struct ufs_inode_info * ufsi ; int err = - ENOSPC ; UFSD ( "ENTER\n" ) ; sb = dir -> i_sb ; inode = new_inode ( sb ) ; if ( ! inode ) { return ERR_PTR ( - ENOMEM ) ; } ufsi = UFS_I ( inode ) ; sbi = UFS_SB ( sb ) ; uspi = sbi -> s_uspi ; mutex_lock ( & sbi -> s_lock ) ; i = ufs_inotocg ( dir -> i_ino ) ; if ( sbi -> fs_cs ( i ) . cs_nifree ) { cg = i ; cg_found } for ( j = 1 ; j < uspi -> s_ncg ; j <<= 1 ) { i += j ; if ( i >= uspi -> s_ncg ) { i -= uspi -> s_ncg ; } if ( sbi -> fs_cs ( i ) . cs_nifree ) { cg = i ; cg_found } } i = ufs_inotocg ( dir -> i_ino ) + 1 ; for ( j = 2 ; j < uspi -> s_ncg ; j ++ ) { i ++ ; if ( i >= uspi -> s_ncg ) { i = 0 ; } if ( sbi -> fs_cs ( i ) . cs_nifree ) { cg = i ; cg_found } } failed cg_found ucpi = ufs_load_cylinder ( sb , cg ) ; if ( ! ucpi ) { err = - EIO ; failed } ucg = ubh_get_ucg ( UCPI_UBH ( ucpi ) ) ; if ( ! ufs_cg_chkmagic ( sb , ucg ) ) { ufs_panic ( sb , "ufs_new_inode" , "internal error, bad cg magic number" ) ; } start = ucpi -> c_irotor ; bit = ubh_find_next_zero_bit ( UCPI_UBH ( ucpi ) , ucpi -> c_iusedoff , uspi -> s_ipg , start ) ; if ( ! ( bit < uspi -> s_ipg ) ) { bit = ubh_find_first_zero_bit ( UCPI_UBH ( ucpi ) , ucpi -> c_iusedoff , start ) ; if ( ! ( bit < start ) ) { ufs_error ( sb , "ufs_new_inode" , "cylinder group %u corrupted - error in inode bitmap\n" , cg ) ; err = - EIO ; failed } } UFSD ( "start = %u, bit = %u, ipg = %u\n" , start , bit , uspi -> s_ipg ) ; if ( ubh_isclr ( UCPI_UBH ( ucpi ) , ucpi -> c_iusedoff , bit ) ) { ubh_setbit ( UCPI_UBH ( ucpi ) , ucpi -> c_iusedoff , bit ) ; } else { ufs_panic ( sb , "ufs_new_inode" , "internal error" ) ; err = - EIO ; failed } if ( uspi -> fs_magic == UFS2_MAGIC ) { u32 initediblk = fs32_to_cpu ( sb , ucg -> cg_u . cg_u2 . cg_initediblk ) ; if ( bit + uspi -> s_inopb > initediblk && initediblk < fs32_to_cpu ( sb , ucg -> cg_u . cg_u2 . cg_niblk ) ) { ufs2_init_inodes_chunk ( sb , ucpi , ucg ) ; } } fs32_sub ( sb , & ucg -> cg_cs . cs_nifree , 1 ) ; uspi -> cs_total . cs_nifree -- ; fs32_sub ( sb , & sbi -> fs_cs ( cg ) . cs_nifree , 1 ) ; if ( S_ISDIR ( mode ) ) { fs32_add ( sb , & ucg -> cg_cs . cs_ndir , 1 ) ; uspi -> cs_total . cs_ndir ++ ; fs32_add ( sb , & sbi -> fs_cs ( cg ) . cs_ndir , 1 ) ; } ubh_mark_buffer_dirty ( USPI_UBH ( uspi ) ) ; ubh_mark_buffer_dirty ( UCPI_UBH ( ucpi ) ) ; if ( sb -> s_flags & SB_SYNCHRONOUS ) { ubh_sync_block ( UCPI_UBH ( ucpi ) ) ; } ufs_mark_sb_dirty ( sb ) ; inode -> i_ino = cg * uspi -> s_ipg + bit ; inode_init_owner ( & nop_mnt_idmap , inode , dir , mode ) ; inode -> i_blocks = 0 ; inode -> i_generation = 0 ; inode -> i_mtime = inode -> i_atime = inode -> i_ctime = current_time ( inode ) ; ufsi -> i_flags = UFS_I ( dir ) -> i_flags ; ufsi -> i_lastfrag = 0 ; ufsi -> i_shadow = 0 ; ufsi -> i_osync = 0 ; ufsi -> i_oeftflag = 0 ; ufsi -> i_dir_start_lookup = 0 ; memset ( & ufsi -> i_u1 , 0 , sizeof ( ufsi -> i_u1 ) ) ; if ( insert_inode_locked ( inode ) < 0 ) { err = - EIO ; failed } mark_inode_dirty ( inode ) ; if ( uspi -> fs_magic == UFS2_MAGIC ) { struct buffer_head * bh ; struct ufs2_inode * ufs2_inode ; bh = sb_bread ( sb , uspi -> s_sbbase + ufs_inotofsba ( inode -> i_ino ) ) ; if ( ! bh ) { ufs_warning ( sb , "ufs_read_inode" , "unable to read inode %lu\n" , inode -> i_ino ) ; err = - EIO ; fail_remove_inode } lock_buffer ( bh ) ; ufs2_inode = ( ufs2_inode * ) bh -> b_data ; ufs2_inode += ufs_inotofsbo ( inode -> i_ino ) ; ktime_get_real_ts64 ( & ts ) ; ufs2_inode -> ui_birthtime = cpu_to_fs64 ( sb , ts . tv_sec ) ; ufs2_inode -> ui_birthnsec = cpu_to_fs32 ( sb , ts . tv_nsec ) ; mark_buffer_dirty ( bh ) ; unlock_buffer ( bh ) ; if ( sb -> s_flags & SB_SYNCHRONOUS ) { sync_dirty_buffer ( bh ) ; } brelse ( bh ) ; } mutex_unlock ( & sbi -> s_lock ) ; UFSD ( "allocating inode %lu\n" , inode -> i_ino ) ; UFSD ( "EXIT\n" ) ; return inode ; fail_remove_inode mutex_unlock ( & sbi -> s_lock ) ; clear_nlink ( inode ) ; discard_new_inode ( inode ) ; UFSD ( "EXIT (FAILED): err %d\n" , err ) ; return ERR_PTR ( err ) ; failed mutex_unlock ( & sbi -> s_lock ) ; make_bad_inode ( inode ) ; iput ( inode ) ; UFSD ( "EXIT (FAILED): err %d\n" , err ) ; return ERR_PTR ( err ) ; } 