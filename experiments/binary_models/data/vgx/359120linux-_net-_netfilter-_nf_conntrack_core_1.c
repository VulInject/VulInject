static struct nf_conn * get_next_corpse ( int * iter ( struct nf_conn * i , void * data ) , const struct nf_ct_iter_data * iter_data , unsigned int * bucket ) { struct nf_conntrack_tuple_hash * h ; struct nf_conn * ct ; struct hlist_nulls_node * n ; spinlock_t * lockp ; for ( ; * bucket < nf_conntrack_htable_size ; ( * bucket ) ++ ) { struct hlist_nulls_head * hslot = & nf_conntrack_hash [ * bucket ] ; if ( hlist_nulls_empty ( hslot ) ) { continue ; } lockp = & nf_conntrack_locks [ * bucket % CONNTRACK_LOCKS ] ; local_bh_disable ( ) ; nf_conntrack_lock ( lockp ) ; hlist_nulls_for_each_entry ( , , , ) { if ( NF_CT_DIRECTION ( h ) != IP_CT_DIR_REPLY ) { continue ; } ct = nf_ct_tuplehash_to_ctrack ( h ) ; if ( iter_data -> net && ! net_eq ( iter_data -> net , nf_ct_net ( ct ) ) ) { continue ; } if ( iter ( ct , iter_data -> data ) ) { found } } spin_unlock ( lockp ) ; local_bh_enable ( ) ; cond_resched ( ) ; } return NULL ; found atomic_inc ( & ct -> ct_general . use ) ; spin_unlock ( lockp ) ; local_bh_enable ( ) ; return ct ; } 