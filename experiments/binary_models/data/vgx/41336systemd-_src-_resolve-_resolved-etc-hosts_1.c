static int parse_line ( EtcHosts * hosts , unsigned nr , const char * line ) { _cleanup_free_ char * address_str = NULL ; struct in_addr_data address = { } ; bool found = false ; EtcHostsItemByAddress * item ; int r ; assert ( hosts ) ; assert ( line ) ; r = extract_first_word ( & line , & address_str , NULL , EXTRACT_RELAX ) ; if ( r < 0 ) { return log_error_errno ( r , "/etc/hosts:%u: failed to extract address: %m" , nr ) ; } assert ( r > 0 ) ; r = in_addr_ifindex_from_string_auto ( address_str , & address . family , & address . address , NULL ) ; if ( r < 0 ) { log_warning_errno ( r , "/etc/hosts:%u: address '%s' is invalid, ignoring: %m" , nr , address_str ) ; return 0 ; } r = in_addr_data_is_null ( & address ) ; if ( r < 0 ) { log_warning_errno ( r , "/etc/hosts:%u: address '%s' is invalid, ignoring: %m" , nr , address_str ) ; return 0 ; } if ( r > 0 ) { item = NULL ; } else { item = hashmap_get ( hosts -> by_address , & address ) ; if ( ! item ) { _cleanup_ ( ) EtcHostsItemByAddress * new_item = NULL ; new_item = new ( EtcHostsItemByAddress , 1 ) ; * new_item = ( EtcHostsItemByAddress ) { . address = address } ; r = hashmap_ensure_put ( & hosts -> by_address , & by_address_hash_ops , & new_item -> address , new_item ) ; if ( r < 0 ) { return log_oom ( ) ; } item = TAKE_PTR ( new_item ) ; } } for ( ; ; ) { _cleanup_free_ char * name = NULL ; EtcHostsItemByName * bn ; r = extract_first_word ( & line , & name , NULL , EXTRACT_RELAX ) ; if ( r < 0 ) { return log_error_errno ( r , "/etc/hosts:%u: couldn't extract hostname: %m" , nr ) ; } if ( r == 0 ) { break ; } r = dns_name_is_valid_ldh ( name ) ; if ( r <= 0 ) { if ( r < 0 ) { log_warning_errno ( r , "/etc/hosts:%u: Failed to check the validity of hostname \"%s\", ignoring: %m" , nr , name ) ; } else { log_warning ( "/etc/hosts:%u: hostname \"%s\" is not valid, ignoring." , nr , name ) ; } continue ; } found = true ; if ( ! item ) { r = set_ensure_consume ( & hosts -> no_address , & dns_name_hash_ops_free , TAKE_PTR ( name ) ) ; if ( r < 0 ) { return log_oom ( ) ; } continue ; } bn = hashmap_get ( hosts -> by_name , name ) ; if ( ! bn ) { _cleanup_ ( ) EtcHostsItemByName * new_item = NULL ; _cleanup_free_ char * name_copy = NULL ; name_copy = strdup ( name ) ; if ( ! name_copy ) { return log_oom ( ) ; } new_item = new ( EtcHostsItemByName , 1 ) ; if ( ! new_item ) { return log_oom ( ) ; } * new_item = ( EtcHostsItemByName ) { . name = TAKE_PTR ( name_copy ) } ; r = hashmap_ensure_put ( & hosts -> by_name , & by_name_hash_ops , new_item -> name , new_item ) ; if ( r < 0 ) { return log_oom ( ) ; } bn = TAKE_PTR ( new_item ) ; } if ( ! set_contains ( bn -> addresses , & address ) ) { _cleanup_free_ struct in_addr_data * address_copy = NULL ; address_copy = newdup ( in_addr_data , & address , 1 ) ; if ( ! address_copy ) { return log_oom ( ) ; } r = set_ensure_consume ( & bn -> addresses , & in_addr_data_hash_ops_free , TAKE_PTR ( address_copy ) ) ; if ( r < 0 ) { return log_oom ( ) ; } } r = set_ensure_consume ( & item -> names , & dns_name_hash_ops_free , TAKE_PTR ( name ) ) ; if ( r < 0 ) { return log_oom ( ) ; } } if ( ! found ) { log_warning ( "/etc/hosts:%u: line is missing any valid hostnames" , nr ) ; } return 0 ; } 