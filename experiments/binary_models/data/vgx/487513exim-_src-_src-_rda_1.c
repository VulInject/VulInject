if ( f . system_filtering ) { int hn = 0 ; header_line * h = header_list ; for ( ; ; ) { int n ; if ( read ( fd , & n , sizeof ( int ) ) != sizeof ( int ) ) { DISASTER } if ( n < 0 ) { break ; } while ( hn < n ) { hn ++ ; if ( ! ( h = h -> next ) ) { DISASTER_NO_HEADER } } h -> type = htype_old ; } for ( ; ; ) { uschar * s ; int type ; if ( ! rda_read_string ( fd , & s ) ) { DISASTER } if ( read ( fd , & type , sizeof ( type ) ) != sizeof ( type ) ) { DISASTER } header_add ( type , "%s" , s ) ; } } if ( read ( fd , filter_n , sizeof ( filter_n ) ) != sizeof ( filter_n ) ) { DISASTER } if ( yield == FF_DELIVERED || yield == FF_NOTDELIVERED || yield == FF_FAIL || yield == FF_FREEZE ) { address_item * * nextp = generated ; for ( ; ; ) { int i , reply_options ; address_item * addr ; uschar * recipient ; uschar * expandn [ EXPAND_MAXN + 2 ] ; if ( ! rda_read_string ( fd , & recipient ) ) { DISASTER } if ( ! recipient ) { break ; } addr = deliver_make_addr ( recipient , FALSE ) ; * nextp = addr ; nextp = & ( addr -> next ) ; if ( read ( fd , & addr -> mode , sizeof ( addr -> mode ) ) != sizeof ( addr -> mode ) || read ( fd , & addr -> flags , sizeof ( addr -> flags ) ) != sizeof ( addr -> flags ) || ! rda_read_string ( fd , & addr -> prop . errors_address ) || read ( fd , & i , sizeof ( i ) ) != sizeof ( i ) ) { DISASTER } addr -> prop . ignore_error = ( i != 0 ) ; for ( i = 0 ; i < EXPAND_MAXN + 1 ; i ++ ) { uschar * temp ; if ( ! rda_read_string ( fd , & temp ) ) { DISASTER } if ( i == 0 ) { filter_thisaddress = temp ; } expandn [ i ] = temp ; if ( temp == NULL ) { break ; } } if ( i > 0 ) { addr -> pipe_expandn = store_get ( ( i + 1 ) * sizeof ( uschar * ) , GET_UNTAINTED ) ; addr -> pipe_expandn [ i ] = NULL ; while ( -- i >= 0 ) { addr -> pipe_expandn [ i ] = expandn [ i ] ; } } if ( read ( fd , & reply_options , sizeof ( int ) ) != sizeof ( int ) ) { DISASTER } if ( ( reply_options & REPLY_EXISTS ) != 0 ) { addr -> reply = store_get ( sizeof ( reply_item ) , GET_UNTAINTED ) ; addr -> reply -> file_expand = ( reply_options & REPLY_EXPAND ) != 0 ; addr -> reply -> return_message = ( reply_options & REPLY_RETURN ) != 0 ; if ( read ( fd , & ( addr -> reply -> expand_forbid ) , sizeof ( int ) ) != sizeof ( int ) || read ( fd , & ( addr -> reply -> once_repeat ) , sizeof ( time_t ) ) != sizeof ( time_t ) || ! rda_read_string ( fd , & addr -> reply -> to ) || ! rda_read_string ( fd , & addr -> reply -> cc ) || ! rda_read_string ( fd , & addr -> reply -> bcc ) || ! rda_read_string ( fd , & addr -> reply -> from ) || ! rda_read_string ( fd , & addr -> reply -> reply_to ) || ! rda_read_string ( fd , & addr -> reply -> subject ) || ! rda_read_string ( fd , & addr -> reply -> headers ) || ! rda_read_string ( fd , & addr -> reply -> text ) || ! rda_read_string ( fd , & addr -> reply -> file ) || ! rda_read_string ( fd , & addr -> reply -> logfile ) || ! rda_read_string ( fd , & addr -> reply -> oncelog ) ) { DISASTER } } } } WAIT_EXIT while ( ( rc = wait ( & status ) ) != pid ) { if ( rc < 0 && errno == ECHILD ) { log_write ( 0 , LOG_MAIN , "redirection process %d vanished unexpectedly" , pid ) ; FINAL_EXIT } } DEBUG ( ) debug_printf ( "rda_interpret: subprocess yield=%d error=%s\n" , yield , * error ) ; if ( had_disaster ) { * error = string_sprintf ( "internal problem in %s: failure to transfer " "data from subprocess: status=%04x%s%s%s" , rname , status , readerror , * error ?US ": error=" : US "" , * error ?* error : US "" ) ; log_write ( 0 , LOG_MAIN | LOG_PANIC , "%s" , * error ) ; } if ( status != 0 ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , "internal problem in %s: unexpected status " "%04x from redirect subprocess (but data correctly received)" , rname , status ) ; } FINAL_EXIT ( void ) close ( fd ) ; signal ( SIGCHLD , oldsignal ) ; return yield ; DISASTER_NO_HEADER readerror = US " readerror=bad header identifier" ; had_disaster = TRUE ; yield = FF_ERROR ; WAIT_EXIT DISASTER readerror = string_sprintf ( " readerror='%s'" , strerror ( errno ) ) ; had_disaster = TRUE ; yield = FF_ERROR ; WAIT_EXIT 