static struct msg_digest * iketcp_read_packet ( struct iface_endpoint * * ifp , struct logger * logger ) { struct logger from_logger = logger_from ( logger , & ( * ifp ) -> iketcp_remote_endpoint ) ; logger = & from_logger ; switch ( ( * ifp ) -> iketcp_state ) { case IKETCP_ACCEPTED : { dbg_iketcp ( * ifp , "reading IKETCP prefix" ) ; const uint8_t iketcp [ ] IKE_IN_TCP_PREFIX ; ; uint8_t buf [ sizeof ( iketcp ) ] ; ssize_t len = read ( ( * ifp ) -> fd , buf , sizeof ( buf ) ) ; if ( len < 0 ) { int e = errno ; llog_iketcp ( RC_LOG_SERIOUS , logger , ( * ifp ) , e , "error reading 'IKETCP' prefix; closing socket: " ) ; iketcp_shutdown ( ifp ) ; return NULL ; } if ( len != sizeof ( buf ) ) { llog_iketcp ( RC_LOG_SERIOUS , logger , ( * ifp ) , 0 , "reading 'IKETCP' prefix returned %zd bytes but expecting %zu; closing socket" , len , sizeof ( buf ) ) ; iketcp_shutdown ( ifp ) ; return NULL ; } dbg_iketcp ( * ifp , "verifying IKETCP prefix" ) ; if ( ! memeq ( buf , iketcp , len ) ) { llog_iketcp ( RC_LOG_SERIOUS , logger , ( * ifp ) , 0 , "prefix did not match 'IKETCP'; closing socket" ) ; iketcp_shutdown ( ifp ) ; return NULL ; } if ( impair . tcp_skip_setsockopt_espintcp ) { llog_iketcp ( RC_LOG , logger , ( * ifp ) , 0 , "IMPAIR: skipping setsockopt(ESPINTCP)" ) ; } else { dbg_iketcp ( * ifp , "enabling ESPINTCP" ) ; if ( setsockopt ( ( * ifp ) -> fd , IPPROTO_TCP , TCP_ULP , "espintcp" , sizeof ( "espintcp" ) ) ) { int e = errno ; llog_iketcp ( RC_LOG , logger , * ifp , e , "closing socket; setsockopt(%d, SOL_TCP, TCP_ULP, \"espintcp\") failed: " , ( * ifp ) -> fd ) ; iketcp_shutdown ( ifp ) ; return NULL ; } } if ( kernel_ops -> poke_ipsec_policy_hole != NULL && ! kernel_ops -> poke_ipsec_policy_hole ( ( * ifp ) -> fd , address_type ( & ( * ifp ) -> ip_dev -> id_address ) , logger ) ) { iketcp_shutdown ( ifp ) ; return NULL ; } ( * ifp ) -> iketcp_state = IKETCP_PREFIX_RECEIVED ; return NULL ; } case IKETCP_PREFIX_RECEIVED : { struct msg_digest * md = read_espintcp_packet ( "first packet" , ifp , logger ) ; dbg_iketcp ( * ifp , "first packet ok; switch to enabled (release endpoint)" ) ; ( * ifp ) -> iketcp_state = IKETCP_ENABLED ; stop_iketcp_timeout ( "first packet" , * ifp ) ; iface_endpoint_delref ( ifp ) ; return md ; } case IKETCP_ENABLED : return read_espintcp_packet ( "packet" , ifp , logger ) ; case IKETCP_STOPPED : { char bytes [ 10 ] ; ssize_t size = read ( ( * ifp ) -> fd , & bytes , sizeof ( bytes ) ) ; if ( size < 0 ) { llog_iketcp ( RC_LOG , logger , * ifp , errno , "drain failed: " ) ; } else { dbg_iketcp ( * ifp , "drained %zd bytes" , size ) ; } return NULL ; } } bad_case ( ( * ifp ) -> iketcp_state ) ; } 