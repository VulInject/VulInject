static int handle_bmsg ( struct mISDNchannel * ch , struct sk_buff * skb ) { struct bchannel * bch = container_of ( ch , bchannel , ch ) ; struct hfc_multi * hc = bch -> hw ; int ret = - EINVAL ; struct mISDNhead * hh = mISDN_HEAD_P ( skb ) ; unsigned long flags ; switch ( hh -> prim ) { case PH_DATA_REQ : spin_lock_irqsave ( & hc -> lock , flags ) ; ret = bchannel_senddata ( bch , skb ) ; if ( ret > 0 ) { hfcmulti_tx ( hc , bch -> slot ) ; ret = 0 ; HFC_outb_nodebug ( hc , R_FIFO , 0 ) ; HFC_wait_nodebug ( hc ) ; } spin_unlock_irqrestore ( & hc -> lock , flags ) ; return ret ; case PH_ACTIVATE_REQ : if ( debug & DEBUG_HFCMULTI_MSG ) { printk ( KERN_DEBUG "%s: PH_ACTIVATE ch %d (0..32)\n" , __func__ , bch -> slot ) ; } spin_lock_irqsave ( & hc -> lock , flags ) ; if ( ! test_and_set_bit ( FLG_ACTIVE , & bch -> Flags ) ) { hc -> chan [ bch -> slot ] . txpending = 0 ; ret = mode_hfcmulti ( hc , bch -> slot , ch -> protocol , hc -> chan [ bch -> slot ] . slot_tx , hc -> chan [ bch -> slot ] . bank_tx , hc -> chan [ bch -> slot ] . slot_rx , hc -> chan [ bch -> slot ] . bank_rx ) ; if ( ! ret ) { if ( ch -> protocol == ISDN_P_B_RAW && ! hc -> dtmf && test_bit ( HFC_CHIP_DTMF , & hc -> chip ) ) { hc -> dtmf = 1 ; if ( debug & DEBUG_HFCMULTI_DTMF ) { printk ( KERN_DEBUG "%s: start dtmf decoder\n" , __func__ ) ; } HFC_outb ( hc , R_DTMF , hc -> hw . r_dtmf | V_RST_DTMF ) ; } } } else { ret = 0 ; } spin_unlock_irqrestore ( & hc -> lock , flags ) ; if ( ! ret ) { _queue_data ( ch , PH_ACTIVATE_IND , MISDN_ID_ANY , 0 , NULL , GFP_KERNEL ) ; } break ; case PH_CONTROL_REQ : spin_lock_irqsave ( & hc -> lock , flags ) ; switch ( hh -> id ) { case HFC_SPL_LOOP_ON : if ( debug & DEBUG_HFCMULTI_MSG ) { printk ( KERN_DEBUG "%s: HFC_SPL_LOOP_ON (len = %d)\n" , __func__ , skb -> len ) ; } ret = 0 ; break ; case HFC_SPL_LOOP_OFF : if ( debug & DEBUG_HFCMULTI_MSG ) { printk ( KERN_DEBUG "%s: HFC_SPL_LOOP_OFF\n" , __func__ ) ; } ret = 0 ; break ; default : printk ( KERN_ERR "%s: unknown PH_CONTROL_REQ info %x\n" , __func__ , hh -> id ) ; ret = - EINVAL ; } spin_unlock_irqrestore ( & hc -> lock , flags ) ; break ; case PH_DEACTIVATE_REQ : deactivate_bchannel ( bch ) ; _queue_data ( ch , PH_DEACTIVATE_IND , MISDN_ID_ANY , 0 , NULL , GFP_KERNEL ) ; ret = 0 ; break ; } if ( ! ret ) { dev_kfree_skb ( skb ) ; } return ret ; } 