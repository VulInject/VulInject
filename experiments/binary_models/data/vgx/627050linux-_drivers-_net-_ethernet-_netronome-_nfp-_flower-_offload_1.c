static int nfp_flower_del_offload ( struct nfp_app * app , struct net_device * netdev , struct flow_cls_offload * flow ) { struct nfp_flower_priv * priv = app -> priv ; struct nfp_fl_ct_map_entry * ct_map_ent ; struct netlink_ext_ack * extack = NULL ; struct nfp_fl_payload * nfp_flow ; struct nfp_port * port = NULL ; int err ; extack = flow -> common . extack ; if ( nfp_netdev_is_nfp_repr ( netdev ) ) { port = nfp_port_from_netdev ( netdev ) ; } ct_map_ent = rhashtable_lookup_fast ( & priv -> ct_map_table , & flow -> cookie , nfp_ct_map_params ) ; if ( ct_map_ent ) { err = nfp_fl_ct_del_flow ( ct_map_ent ) ; return err ; } nfp_flow = nfp_flower_search_fl_table ( app , flow -> cookie , netdev ) ; if ( ! nfp_flow ) { NL_SET_ERR_MSG_MOD ( extack , "invalid entry: cannot remove flow that does not exist" ) ; return - ENOENT ; } err = nfp_modify_flow_metadata ( app , nfp_flow ) ; if ( err ) { err_free_merge_flow } if ( nfp_flow -> nfp_tun_ipv4_addr ) { nfp_tunnel_del_ipv4_off ( app , nfp_flow -> nfp_tun_ipv4_addr ) ; } if ( nfp_flow -> nfp_tun_ipv6 ) { nfp_tunnel_put_ipv6_off ( app , nfp_flow -> nfp_tun_ipv6 ) ; } if ( ! nfp_flow -> in_hw ) { err = 0 ; err_free_merge_flow } if ( nfp_flow -> pre_tun_rule . dev ) { if ( priv -> flower_ext_feats & NFP_FL_FEATS_DECAP_V2 ) { struct nfp_predt_entry * predt ; predt = nfp_flow -> pre_tun_rule . predt ; if ( predt ) { spin_lock_bh ( & priv -> predt_lock ) ; nfp_tun_unlink_and_update_nn_entries ( app , predt ) ; list_del ( & predt -> list_head ) ; spin_unlock_bh ( & priv -> predt_lock ) ; kfree ( predt ) ; } } else { err = nfp_flower_xmit_pre_tun_del_flow ( app , nfp_flow ) ; } } else { err = nfp_flower_xmit_flow ( app , nfp_flow , NFP_FLOWER_CMSG_TYPE_FLOW_DEL ) ; } err_free_merge_flow nfp_flower_del_linked_merge_flows ( app , nfp_flow ) ; if ( port ) { port -> tc_offload_cnt -- ; } kfree ( nfp_flow -> mask_data ) ; kfree ( nfp_flow -> unmasked_data ) ; WARN_ON_ONCE ( rhashtable_remove_fast ( & priv -> flow_table , & nfp_flow -> fl_node , nfp_flower_table_params ) ) ; kfree_rcu ( nfp_flow , rcu ) ; return err ; } 