enum pkcs11_rc step_asymm_operation ( struct pkcs11_session * session , enum processing_func function , enum processing_step step , uint32_t ptypes , TEE_Param * params ) { enum pkcs11_rc rc = PKCS11_CKR_GENERAL_ERROR ; TEE_Result res = TEE_ERROR_GENERIC ; void * in_buf = NULL ; void * in2_buf = NULL ; void * out_buf = NULL ; void * hash_buf = NULL ; int in_size = 0 ; uint32_t in2_size = 0 ; size_t out_size = 0 ; size_t hash_size = 0 ; TEE_Attribute * tee_attrs = NULL ; size_t tee_attrs_count = 0 ; bool output_data = false ; struct active_processing * proc = session -> processing ; struct rsa_aes_key_wrap_processing_ctx * rsa_aes_ctx = NULL ; struct rsa_oaep_processing_ctx * rsa_oaep_ctx = NULL ; struct rsa_pss_processing_ctx * rsa_pss_ctx = NULL ; struct eddsa_processing_ctx * eddsa_ctx = NULL ; size_t sz = 0 ; if ( TEE_PARAM_TYPE_GET ( ptypes , 1 ) == TEE_PARAM_TYPE_MEMREF_INPUT ) { in_buf = params [ 1 ] . memref . buffer ; in_size = params [ 1 ] . memref . size ; if ( in_size && ! in_buf ) { return PKCS11_CKR_ARGUMENTS_BAD ; } } if ( TEE_PARAM_TYPE_GET ( ptypes , 2 ) == TEE_PARAM_TYPE_MEMREF_INPUT ) { in2_buf = params [ 2 ] . memref . buffer ; in2_size = params [ 2 ] . memref . size ; if ( in2_size && ! in2_buf ) { return PKCS11_CKR_ARGUMENTS_BAD ; } } if ( TEE_PARAM_TYPE_GET ( ptypes , 2 ) == TEE_PARAM_TYPE_MEMREF_OUTPUT ) { out_buf = params [ 2 ] . memref . buffer ; out_size = params [ 2 ] . memref . size ; if ( out_size && ! out_buf ) { return PKCS11_CKR_ARGUMENTS_BAD ; } } if ( TEE_PARAM_TYPE_GET ( ptypes , 3 ) != TEE_PARAM_TYPE_NONE ) { return PKCS11_CKR_ARGUMENTS_BAD ; } switch ( step ) { case PKCS11_FUNC_STEP_ONESHOT : case PKCS11_FUNC_STEP_UPDATE : case PKCS11_FUNC_STEP_FINAL : break ; default : return PKCS11_CKR_GENERAL_ERROR ; } switch ( proc -> mecha_type ) { case PKCS11_CKM_RSA_PKCS_PSS : case PKCS11_CKM_SHA1_RSA_PKCS_PSS : case PKCS11_CKM_SHA224_RSA_PKCS_PSS : case PKCS11_CKM_SHA256_RSA_PKCS_PSS : case PKCS11_CKM_SHA384_RSA_PKCS_PSS : case PKCS11_CKM_SHA512_RSA_PKCS_PSS : tee_attrs = TEE_Malloc ( sizeof ( TEE_Attribute ) , TEE_USER_MEM_HINT_NO_FILL_ZERO ) ; if ( ! tee_attrs ) { rc = PKCS11_CKR_DEVICE_MEMORY ; out } rsa_pss_ctx = proc -> extra_ctx ; TEE_InitValueAttribute ( & tee_attrs [ tee_attrs_count ] , TEE_ATTR_RSA_PSS_SALT_LENGTH , rsa_pss_ctx -> salt_len , 0 ) ; tee_attrs_count ++ ; break ; case PKCS11_CKM_EDDSA : eddsa_ctx = proc -> extra_ctx ; tee_attrs = TEE_Malloc ( 2 * sizeof ( TEE_Attribute ) , TEE_USER_MEM_HINT_NO_FILL_ZERO ) ; if ( ! tee_attrs ) { rc = PKCS11_CKR_DEVICE_MEMORY ; out } if ( eddsa_ctx -> flag ) { TEE_InitValueAttribute ( & tee_attrs [ tee_attrs_count ] , TEE_ATTR_EDDSA_PREHASH , 0 , 0 ) ; tee_attrs_count ++ ; } if ( eddsa_ctx -> ctx_len > 0 ) { TEE_InitRefAttribute ( & tee_attrs [ tee_attrs_count ] , TEE_ATTR_EDDSA_CTX , eddsa_ctx -> ctx , eddsa_ctx -> ctx_len ) ; tee_attrs_count ++ ; } break ; case PKCS11_CKM_RSA_PKCS_OAEP : rsa_oaep_ctx = proc -> extra_ctx ; if ( ! rsa_oaep_ctx -> source_data_len ) { break ; } tee_attrs = TEE_Malloc ( sizeof ( TEE_Attribute ) , TEE_USER_MEM_HINT_NO_FILL_ZERO ) ; if ( ! tee_attrs ) { rc = PKCS11_CKR_DEVICE_MEMORY ; out } TEE_InitRefAttribute ( & tee_attrs [ tee_attrs_count ] , TEE_ATTR_RSA_OAEP_LABEL , rsa_oaep_ctx -> source_data , rsa_oaep_ctx -> source_data_len ) ; tee_attrs_count ++ ; break ; case PKCS11_CKM_RSA_AES_KEY_WRAP : rsa_aes_ctx = proc -> extra_ctx ; if ( ! rsa_aes_ctx -> source_data_len ) { break ; } tee_attrs = TEE_Malloc ( sizeof ( TEE_Attribute ) , TEE_USER_MEM_HINT_NO_FILL_ZERO ) ; if ( ! tee_attrs ) { rc = PKCS11_CKR_DEVICE_MEMORY ; out } TEE_InitRefAttribute ( & tee_attrs [ tee_attrs_count ] , TEE_ATTR_RSA_OAEP_LABEL , rsa_aes_ctx -> source_data , rsa_aes_ctx -> source_data_len ) ; tee_attrs_count ++ ; break ; default : break ; } if ( step == PKCS11_FUNC_STEP_UPDATE ) { switch ( proc -> mecha_type ) { case PKCS11_CKM_ECDSA_SHA1 : case PKCS11_CKM_ECDSA_SHA224 : case PKCS11_CKM_ECDSA_SHA256 : case PKCS11_CKM_ECDSA_SHA384 : case PKCS11_CKM_ECDSA_SHA512 : case PKCS11_CKM_MD5_RSA_PKCS : case PKCS11_CKM_SHA1_RSA_PKCS : case PKCS11_CKM_SHA224_RSA_PKCS : case PKCS11_CKM_SHA256_RSA_PKCS : case PKCS11_CKM_SHA384_RSA_PKCS : case PKCS11_CKM_SHA512_RSA_PKCS : case PKCS11_CKM_SHA1_RSA_PKCS_PSS : case PKCS11_CKM_SHA224_RSA_PKCS_PSS : case PKCS11_CKM_SHA256_RSA_PKCS_PSS : case PKCS11_CKM_SHA384_RSA_PKCS_PSS : case PKCS11_CKM_SHA512_RSA_PKCS_PSS : assert ( proc -> tee_hash_op_handle != TEE_HANDLE_NULL ) ; TEE_DigestUpdate ( proc -> tee_hash_op_handle , in_buf , in_size ) ; rc = PKCS11_CKR_OK ; break ; default : rc = PKCS11_CKR_GENERAL_ERROR ; break ; } out } switch ( proc -> mecha_type ) { case PKCS11_CKM_ECDSA_SHA1 : case PKCS11_CKM_ECDSA_SHA224 : case PKCS11_CKM_ECDSA_SHA256 : case PKCS11_CKM_ECDSA_SHA384 : case PKCS11_CKM_ECDSA_SHA512 : case PKCS11_CKM_MD5_RSA_PKCS : case PKCS11_CKM_SHA1_RSA_PKCS : case PKCS11_CKM_SHA224_RSA_PKCS : case PKCS11_CKM_SHA256_RSA_PKCS : case PKCS11_CKM_SHA384_RSA_PKCS : case PKCS11_CKM_SHA512_RSA_PKCS : case PKCS11_CKM_SHA1_RSA_PKCS_PSS : case PKCS11_CKM_SHA224_RSA_PKCS_PSS : case PKCS11_CKM_SHA256_RSA_PKCS_PSS : case PKCS11_CKM_SHA384_RSA_PKCS_PSS : case PKCS11_CKM_SHA512_RSA_PKCS_PSS : assert ( proc -> tee_hash_op_handle != TEE_HANDLE_NULL ) ; hash_size = TEE_ALG_GET_DIGEST_SIZE ( proc -> tee_hash_algo ) ; hash_buf = TEE_Malloc ( hash_size , 0 ) ; if ( ! hash_buf ) { return PKCS11_CKR_DEVICE_MEMORY ; } res = TEE_DigestDoFinal ( proc -> tee_hash_op_handle , in_buf , in_size , hash_buf , & hash_size ) ; rc = tee2pkcs_error ( res ) ; if ( rc != PKCS11_CKR_OK ) { out } break ; default : break ; } switch ( proc -> mecha_type ) { case PKCS11_CKM_ECDSA : sz = ecdsa_get_input_max_byte_size ( proc -> tee_op_handle ) ; if ( ! in_size || ! sz ) { rc = PKCS11_CKR_FUNCTION_FAILED ; out } if ( in_size > sz ) { in_size = sz ; } if ( function == PKCS11_FUNCTION_VERIFY && in2_size != 2 * sz ) { rc = PKCS11_CKR_SIGNATURE_LEN_RANGE ; out } break ; case PKCS11_CKM_ECDSA_SHA1 : case PKCS11_CKM_ECDSA_SHA224 : case PKCS11_CKM_ECDSA_SHA256 : case PKCS11_CKM_ECDSA_SHA384 : case PKCS11_CKM_ECDSA_SHA512 : sz = ecdsa_get_input_max_byte_size ( proc -> tee_op_handle ) ; if ( ! sz ) { rc = PKCS11_CKR_FUNCTION_FAILED ; out } if ( function == PKCS11_FUNCTION_VERIFY && in2_size != 2 * sz ) { rc = PKCS11_CKR_SIGNATURE_LEN_RANGE ; out } break ; case PKCS11_CKM_RSA_PKCS : case PKCS11_CKM_MD5_RSA_PKCS : case PKCS11_CKM_SHA1_RSA_PKCS : case PKCS11_CKM_SHA224_RSA_PKCS : case PKCS11_CKM_SHA256_RSA_PKCS : case PKCS11_CKM_SHA384_RSA_PKCS : case PKCS11_CKM_SHA512_RSA_PKCS : case PKCS11_CKM_RSA_PKCS_PSS : case PKCS11_CKM_SHA1_RSA_PKCS_PSS : case PKCS11_CKM_SHA224_RSA_PKCS_PSS : case PKCS11_CKM_SHA256_RSA_PKCS_PSS : case PKCS11_CKM_SHA384_RSA_PKCS_PSS : case PKCS11_CKM_SHA512_RSA_PKCS_PSS : sz = rsa_get_input_max_byte_size ( proc -> tee_op_handle ) ; if ( ! sz ) { rc = PKCS11_CKR_FUNCTION_FAILED ; out } if ( function == PKCS11_FUNCTION_VERIFY && in2_size != sz ) { rc = PKCS11_CKR_SIGNATURE_LEN_RANGE ; out } break ; default : break ; } switch ( proc -> mecha_type ) { case PKCS11_CKM_ECDSA : case PKCS11_CKM_EDDSA : case PKCS11_CKM_RSA_PKCS : case PKCS11_CKM_RSA_PKCS_OAEP : case PKCS11_CKM_RSA_PKCS_PSS : switch ( function ) { case PKCS11_FUNCTION_ENCRYPT : res = TEE_AsymmetricEncrypt ( proc -> tee_op_handle , tee_attrs , tee_attrs_count , in_buf , in_size , out_buf , & out_size ) ; output_data = true ; rc = tee2pkcs_error ( res ) ; if ( rc == PKCS11_CKR_ARGUMENTS_BAD ) { rc = PKCS11_CKR_DATA_LEN_RANGE ; } break ; case PKCS11_FUNCTION_DECRYPT : res = TEE_AsymmetricDecrypt ( proc -> tee_op_handle , tee_attrs , tee_attrs_count , in_buf , in_size , out_buf , & out_size ) ; output_data = true ; rc = tee2pkcs_error ( res ) ; if ( rc == PKCS11_CKR_ARGUMENTS_BAD ) { rc = PKCS11_CKR_ENCRYPTED_DATA_LEN_RANGE ; } break ; case PKCS11_FUNCTION_SIGN : res = TEE_AsymmetricSignDigest ( proc -> tee_op_handle , tee_attrs , tee_attrs_count , in_buf , in_size , out_buf , & out_size ) ; output_data = true ; rc = tee2pkcs_error ( res ) ; break ; case PKCS11_FUNCTION_VERIFY : res = TEE_AsymmetricVerifyDigest ( proc -> tee_op_handle , tee_attrs , tee_attrs_count , in_buf , in_size , in2_buf , in2_size ) ; rc = tee2pkcs_error ( res ) ; break ; default : TEE_Panic ( function ) ; break ; } break ; case PKCS11_CKM_ECDSA_SHA1 : case PKCS11_CKM_ECDSA_SHA224 : case PKCS11_CKM_ECDSA_SHA256 : case PKCS11_CKM_ECDSA_SHA384 : case PKCS11_CKM_ECDSA_SHA512 : case PKCS11_CKM_MD5_RSA_PKCS : case PKCS11_CKM_SHA1_RSA_PKCS : case PKCS11_CKM_SHA224_RSA_PKCS : case PKCS11_CKM_SHA256_RSA_PKCS : case PKCS11_CKM_SHA384_RSA_PKCS : case PKCS11_CKM_SHA512_RSA_PKCS : case PKCS11_CKM_SHA1_RSA_PKCS_PSS : case PKCS11_CKM_SHA224_RSA_PKCS_PSS : case PKCS11_CKM_SHA256_RSA_PKCS_PSS : case PKCS11_CKM_SHA384_RSA_PKCS_PSS : case PKCS11_CKM_SHA512_RSA_PKCS_PSS : switch ( function ) { case PKCS11_FUNCTION_SIGN : res = TEE_AsymmetricSignDigest ( proc -> tee_op_handle , tee_attrs , tee_attrs_count , hash_buf , hash_size , out_buf , & out_size ) ; output_data = true ; rc = tee2pkcs_error ( res ) ; break ; case PKCS11_FUNCTION_VERIFY : res = TEE_AsymmetricVerifyDigest ( proc -> tee_op_handle , tee_attrs , tee_attrs_count , hash_buf , hash_size , in2_buf , in2_size ) ; rc = tee2pkcs_error ( res ) ; break ; default : TEE_Panic ( function ) ; break ; } break ; default : TEE_Panic ( proc -> mecha_type ) ; break ; } out if ( output_data && ( rc == PKCS11_CKR_OK || rc == PKCS11_CKR_BUFFER_TOO_SMALL ) ) { switch ( TEE_PARAM_TYPE_GET ( ptypes , 2 ) ) { case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : params [ 2 ] . memref . size = out_size ; break ; default : rc = PKCS11_CKR_GENERAL_ERROR ; break ; } } TEE_Free ( hash_buf ) ; TEE_Free ( tee_attrs ) ; return rc ; } 