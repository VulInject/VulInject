static struct Body * pgp_decrypt_part ( struct Body * a , struct State * s , FILE * fp_out , struct Body * p ) { if ( ! a || ! s || ! fp_out || ! p ) { return in ; } char buf [ 1024 ] { 0 } ; ; FILE * fp_pgp_in = NULL , * fp_pgp_out = NULL , * fp_pgp_tmp = NULL ; struct Body * tattach = NULL ; pid_t pid ; int rv ; struct Buffer * pgptmpfile = mutt_buffer_pool_get ( ) ; FILE * fp_pgp_err = mutt_file_mkstemp ( ) ; if ( ! fp_pgp_err ) { mutt_perror ( _ ( "Can't create temporary file" ) ) ; cleanup } mutt_buffer_mktemp ( pgptmpfile ) ; fp_pgp_tmp = mutt_file_fopen ( mutt_buffer_string ( pgptmpfile ) , "w" ) ; if ( ! fp_pgp_tmp ) { mutt_perror ( mutt_buffer_string ( pgptmpfile ) ) ; mutt_file_fclose ( & fp_pgp_err ) ; cleanup } if ( ! mutt_file_seek ( s -> fp_in , a -> offset , SEEK_SET ) ) { mutt_file_fclose ( & fp_pgp_tmp ) ; mutt_file_fclose ( & fp_pgp_err ) ; cleanup } mutt_file_copy_bytes ( s -> fp_in , fp_pgp_tmp , a -> length ) ; mutt_file_fclose ( & fp_pgp_tmp ) ; pid = pgp_invoke_decrypt ( & fp_pgp_in , & fp_pgp_out , NULL , - 1 , - 1 , fileno ( fp_pgp_err ) , mutt_buffer_string ( pgptmpfile ) ) ; if ( pid == - 1 ) { mutt_file_fclose ( & fp_pgp_err ) ; unlink ( mutt_buffer_string ( pgptmpfile ) ) ; if ( s -> flags & MUTT_DISPLAY ) { state_attach_puts ( s , _ ( "[-- Error: could not create a PGP subprocess --]\n\n" ) ) ; } cleanup } if ( ! pgp_use_gpg_agent ( ) ) { fputs ( PgpPass , fp_pgp_in ) ; } fputc ( '\n' , fp_pgp_in ) ; mutt_file_fclose ( & fp_pgp_in ) ; while ( fgets ( buf , sizeof ( buf ) - 1 , fp_pgp_out ) ) { size_t len = mutt_str_len ( buf ) ; if ( ( len > 1 ) && ( buf [ len - 2 ] == '\r' ) ) { strcpy ( buf + len - 2 , "\n" ) ; } fputs ( buf , fp_out ) ; } mutt_file_fclose ( & fp_pgp_out ) ; rv = filter_wait ( pid ) ; const bool c_pgp_use_gpg_agent = cs_subset_bool ( NeoMutt -> sub , "pgp_use_gpg_agent" ) ; if ( c_pgp_use_gpg_agent ) { mutt_need_hard_redraw ( ) ; } mutt_file_unlink ( mutt_buffer_string ( pgptmpfile ) ) ; fflush ( fp_pgp_err ) ; rewind ( fp_pgp_err ) ; if ( pgp_check_decryption_okay ( fp_pgp_err ) < 0 ) { mutt_error ( _ ( "Decryption failed" ) ) ; pgp_class_void_passphrase ( ) ; mutt_file_fclose ( & fp_pgp_err ) ; cleanup } if ( s -> flags & MUTT_DISPLAY ) { rewind ( fp_pgp_err ) ; if ( ( pgp_copy_checksig ( fp_pgp_err , s -> fp_out ) == 0 ) && ! rv ) { p -> goodsig = true ; } else { p -> goodsig = false ; } state_attach_puts ( s , _ ( "[-- End of PGP output --]\n\n" ) ) ; } mutt_file_fclose ( & fp_pgp_err ) ; fflush ( fp_out ) ; rewind ( fp_out ) ; if ( fgetc ( fp_out ) == EOF ) { mutt_error ( _ ( "Decryption failed" ) ) ; pgp_class_void_passphrase ( ) ; cleanup } rewind ( fp_out ) ; const long size = mutt_file_get_size_fp ( fp_out ) ; if ( size == 0 ) { cleanup } tattach = mutt_read_mime_header ( fp_out , 0 ) ; if ( tattach ) { tattach -> length = size - tattach -> offset ; mutt_parse_part ( fp_out , tattach ) ; } cleanup mutt_buffer_pool_release ( & pgptmpfile ) ; return tattach ; } 