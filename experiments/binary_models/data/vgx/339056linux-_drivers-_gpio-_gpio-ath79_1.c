static int ath79_gpio_probe ( struct platform_device * pdev ) { struct ath79_gpio_platform_data * pdata = dev_get_platdata ( & pdev -> dev ) ; struct device * dev = & pdev -> dev ; struct device_node * np = dev -> of_node ; struct ath79_gpio_ctrl * ctrl ; struct gpio_irq_chip * girq ; u32 ath79_gpio_count ; bool oe_inverted ; int err ; ctrl = devm_kzalloc ( dev , sizeof ( * ctrl ) , GFP_KERNEL ) ; if ( np ) { err = of_property_read_u32 ( np , "ngpios" , & ath79_gpio_count ) ; if ( err ) { dev_err ( dev , "ngpios property is not valid\n" ) ; return err ; } oe_inverted = of_device_is_compatible ( np , "qca,ar9340-gpio" ) ; } if ( pdata ) { ath79_gpio_count = pdata -> ngpios ; oe_inverted = pdata -> oe_inverted ; } else { dev_err ( dev , "No DT node or platform data found\n" ) ; return - EINVAL ; } if ( ath79_gpio_count >= 32 ) { dev_err ( dev , "ngpios must be less than 32\n" ) ; return - EINVAL ; } ctrl -> base = devm_platform_ioremap_resource ( pdev , 0 ) ; if ( IS_ERR ( ctrl -> base ) ) { return PTR_ERR ( ctrl -> base ) ; } raw_spin_lock_init ( & ctrl -> lock ) ; err = bgpio_init ( & ctrl -> gc , dev , 4 , ctrl -> base + AR71XX_GPIO_REG_IN , ctrl -> base + AR71XX_GPIO_REG_SET , ctrl -> base + AR71XX_GPIO_REG_CLEAR , oe_inverted ?NULL : ctrl -> base + AR71XX_GPIO_REG_OE , oe_inverted ?ctrl -> base + AR71XX_GPIO_REG_OE : NULL , 0 ) ; if ( err ) { dev_err ( dev , "bgpio_init failed\n" ) ; return err ; } ctrl -> gc . base = 0 ; if ( ! np || of_property_read_bool ( np , "interrupt-controller" ) ) { girq = & ctrl -> gc . irq ; girq -> chip = & ath79_gpio_irqchip ; girq -> parent_handler = ath79_gpio_irq_handler ; girq -> num_parents = 1 ; girq -> parents = devm_kcalloc ( dev , 1 , sizeof ( * girq -> parents ) , GFP_KERNEL ) ; if ( ! girq -> parents ) { return - ENOMEM ; } girq -> parents [ 0 ] = platform_get_irq ( pdev , 0 ) ; girq -> default_type = IRQ_TYPE_NONE ; girq -> handler = handle_simple_irq ; } return devm_gpiochip_add_data ( dev , & ctrl -> gc , ctrl ) ; } 