int xlator_take_kvpair ( const Meta_info meta_info , const int token , char * value ) { char * p ; char * subv = NULL ; char * key = Keywords [ token - FIRST_TOKEN ] . key ; Curline = meta_info . mi_line_number ; seterrline ( Curline , meta_info . mi_filename , key , value ) ; errlog ( TRACING , "take_kvpair called. ext_cnt=%d token=%d key=%s value=%s" , meta_info . mi_ext_cnt , token , key , value ) ; if ( Curfun == NULL ) { errlog ( INPUT | ERROR , "Error: Keyword found outside " "an interface specification block, line %d" , Curline ) ; return ( XLATOR_NONFATAL ) ; } switch ( token ) { case XLATOR_KW_VERSION : if ( meta_info . mi_ext_cnt != 0 ) { return ( XLATOR_SUCCESS ) ; } errlog ( TRACING , "Version found. Setting Version to %s" , value ) ; Has_Version = 1 ; p = strrchr ( value , '\n' ) ; if ( p ) { while ( p >= value && isspace ( * p ) ) { * p = '\0' ; -- p ; } } switch ( version_sanity ( value , & subv ) ) { case VS_OK : break ; case VS_INVARCH : errlog ( INPUT | ERROR , "Error: Invalid architecture " "string found in spec or version file: %s" , subv ) ; return ( XLATOR_NONFATAL ) ; case VS_INVVERS : errlog ( INPUT | ERROR , "Error: Invalid version string " "in spec or version file: %s" , subv ) ; free ( subv ) ; return ( XLATOR_NONFATAL ) ; case VS_INVALID : errlog ( INPUT | ERROR , "Error: Invalid version and " "architecture string in spec or version file" ": %s" , subv ) ; free ( subv ) ; return ( XLATOR_NONFATAL ) ; default : errlog ( FATAL , "Error: bad return value from " "version_sanity()! This should never happen!" ) ; } errlog ( TRACING , "Version_Arch=%d" , Version_Arch ) ; Iface . IF_version = getversion ( value ) ; break ; case XLATOR_KW_ARCH : if ( meta_info . mi_ext_cnt != 0 ) { return ( XLATOR_SUCCESS ) ; } if ( value [ 0 ] != '\0' ) { Supported_Arch = 0 ; if ( set_supported_arch ( value ) ) { errlog ( INPUT | ERROR , "Error: Unable to parse Arch line" ) ; return ( XLATOR_NONFATAL ) ; } } else { errlog ( INPUT | ERROR , "Error: Empty Arch line." ) ; } if ( Supported_Arch == 0 ) { errlog ( INPUT | ERROR , "Error: Unknown architecture defined in Arch line" ) ; } errlog ( TRACING , "Interface %s supports the following architectures: " "%s\tSupported_Arch=%d" , Curfun , value , Supported_Arch ) ; break ; case XLATOR_KW_BINDING : p = strrchr ( value , '\n' ) ; if ( p ) { while ( p >= value && isspace ( * p ) ) { * p = '\0' ; -- p ; } } if ( value [ 0 ] != '\0' ) { if ( strcmp ( value , "direct" ) == 0 ) { Iface . IF_binding = DIRECT ; } if ( strcmp ( value , "nodirect" ) == 0 ) { Iface . IF_binding = NODIRECT ; } if ( strcmp ( value , "protected" ) == 0 ) { Iface . IF_binding = PROTECTED ; } else { errlog ( INPUT | ERROR , "Error: Invalid binding value: %s" , value ) ; } } else { errlog ( INPUT | ERROR , "Error: Empty Binding line." ) ; } errlog ( TRACING , "Interface %s has binding value: " "%s" , Curfun , value ) ; break ; case XLATOR_KW_FILTER : case XLATOR_KW_AUXILIARY : if ( meta_info . mi_ext_cnt != 0 ) { return ( XLATOR_SUCCESS ) ; } errlog ( TRACING , "Filter[token=%d] found. Setting Filter to %s" , token , value ) ; p = strrchr ( value , '\n' ) ; if ( p ) { while ( p >= value && isspace ( * p ) ) { * p = '\0' ; -- p ; } } errlog ( TRACING , "Version_Arch=%d" , Version_Arch ) ; if ( token == XLATOR_KW_FILTER ) { Iface . IF_filter = getfilter ( value ) ; } if ( token == XLATOR_KW_AUXILIARY ) { Iface . IF_auxiliary = getfilter ( value ) ; } break ; default : errlog ( INPUT | ERROR , "Error: Unrecognized keyword snuck in!" "\tThis is a programmer error: %s" , key ) ; return ( XLATOR_NONFATAL ) ; } return ( XLATOR_SUCCESS ) ; } 