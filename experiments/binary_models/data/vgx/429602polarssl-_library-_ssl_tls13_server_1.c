static int ssl_tls13_parse_pre_shared_key_ext ( mbedtls_ssl_context * ssl , const unsigned char * pre_shared_key_ext , const unsigned char * pre_shared_key_ext_end , const unsigned char * ciphersuites , const unsigned char * ciphersuites_end ) { int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED ; const unsigned char * identities = pre_shared_key_ext ; const unsigned char * p_identity_len ; size_t identities_len ; const unsigned char * identities_end ; const unsigned char * binders ; const unsigned char * p_binder_len ; size_t binders_len ; const unsigned char * binders_end ; int matched_identity = - 1 ; int identity_id = - 1 ; MBEDTLS_SSL_DEBUG_BUF ( 3 , "pre_shared_key extension" , pre_shared_key_ext , pre_shared_key_ext_end - pre_shared_key_ext ) ; MBEDTLS_SSL_CHK_BUF_READ_PTR ( identities , pre_shared_key_ext_end , 7 + 2 ) ; identities_len = MBEDTLS_GET_UINT16_BE ( identities , 0 ) ; p_identity_len = identities + 2 ; MBEDTLS_SSL_CHK_BUF_READ_PTR ( p_identity_len , pre_shared_key_ext_end , identities_len ) ; identities_end = p_identity_len + identities_len ; binders = identities_end ; MBEDTLS_SSL_CHK_BUF_READ_PTR ( binders , pre_shared_key_ext_end , 33 + 2 ) ; binders_len = MBEDTLS_GET_UINT16_BE ( binders , 0 ) ; p_binder_len = binders + 2 ; MBEDTLS_SSL_CHK_BUF_READ_PTR ( p_binder_len , pre_shared_key_ext_end , binders_len ) ; binders_end = p_binder_len + binders_len ; ret = ssl -> handshake -> update_checksum ( ssl , pre_shared_key_ext , identities_end - pre_shared_key_ext ) ; if ( 0 != ret ) { MBEDTLS_SSL_DEBUG_RET ( 1 , ( "update_checksum" ) , ret ) ; return ret ; } while ( p_identity_len < identities_end && p_binder_len < binders_end ) { const unsigned char * identity ; size_t identity_len ; uint32_t obfuscated_ticket_age ; const unsigned char * binder ; size_t binder_len ; int psk_type ; uint16_t cipher_suite ; const mbedtls_ssl_ciphersuite_t * ciphersuite_info ; mbedtls_ssl_session session ; mbedtls_ssl_session_init ( & session ) ; MBEDTLS_SSL_CHK_BUF_READ_PTR ( p_identity_len , identities_end , 2 + 1 + 4 ) ; identity_len = MBEDTLS_GET_UINT16_BE ( p_identity_len , 0 ) ; identity = p_identity_len + 2 ; MBEDTLS_SSL_CHK_BUF_READ_PTR ( identity , identities_end , identity_len + 4 ) ; obfuscated_ticket_age = MBEDTLS_GET_UINT32_BE ( identity , identity_len ) ; p_identity_len += identity_len + 6 ; MBEDTLS_SSL_CHK_BUF_READ_PTR ( p_binder_len , binders_end , 1 + 32 ) ; binder_len = * p_binder_len ; binder = p_binder_len + 1 ; MBEDTLS_SSL_CHK_BUF_READ_PTR ( binder , binders_end , binder_len ) ; p_binder_len += binder_len + 1 ; identity_id ++ ; ret = ssl_tls13_offered_psks_check_identity_match ( ssl , identity , identity_len , obfuscated_ticket_age , & psk_type , & session ) ; if ( ret != SSL_TLS1_3_OFFERED_PSK_MATCH ) { continue ; } MBEDTLS_SSL_DEBUG_MSG ( 4 , ( "found matched identity" ) ) ; switch ( psk_type ) { case MBEDTLS_SSL_TLS1_3_PSK_EXTERNAL : ret = ssl_tls13_select_ciphersuite_for_psk ( ssl , ciphersuites , ciphersuites_end , & cipher_suite , & ciphersuite_info ) ; break ; case MBEDTLS_SSL_TLS1_3_PSK_RESUMPTION : ret = ssl_tls13_select_ciphersuite_for_resumption ( ssl , ciphersuites , ciphersuites_end , & session , & cipher_suite , & ciphersuite_info ) ; if ( ret != 0 ) { mbedtls_ssl_session_free ( & session ) ; } ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE ; break ; default : return MBEDTLS_ERR_SSL_INTERNAL_ERROR ; } if ( ret != 0 ) { MBEDTLS_SSL_PEND_FATAL_ALERT ( MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR , MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE ) ; MBEDTLS_SSL_DEBUG_RET ( 2 , "ssl_tls13_select_ciphersuite" , ret ) ; return ret ; } ret = ssl_tls13_offered_psks_check_binder_match ( ssl , binder , binder_len , psk_type , mbedtls_psa_translate_md ( ciphersuite_info -> mac ) ) ; if ( ret != SSL_TLS1_3_OFFERED_PSK_MATCH ) { mbedtls_ssl_session_free ( & session ) ; MBEDTLS_SSL_DEBUG_MSG ( 3 , ( "Invalid binder." ) ) ; MBEDTLS_SSL_DEBUG_RET ( 1 , "ssl_tls13_offered_psks_check_binder_match" , ret ) ; MBEDTLS_SSL_PEND_FATAL_ALERT ( MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR , MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE ) ; return ret ; } matched_identity = identity_id ; ssl -> handshake -> ciphersuite_info = ciphersuite_info ; ssl -> session_negotiate -> ciphersuite = cipher_suite ; MBEDTLS_SSL_DEBUG_MSG ( 2 , ( "overwrite ciphersuite: %04x - %s" , cipher_suite , ciphersuite_info -> name ) ) ; if ( psk_type == MBEDTLS_SSL_TLS1_3_PSK_RESUMPTION ) { ret = ssl_tls13_session_copy_ticket ( ssl -> session_negotiate , & session ) ; mbedtls_ssl_session_free ( & session ) ; if ( ret != 0 ) { return ret ; } } } if ( p_identity_len != identities_end || p_binder_len != binders_end ) { MBEDTLS_SSL_DEBUG_MSG ( 3 , ( "pre_shared_key extension decode error" ) ) ; MBEDTLS_SSL_PEND_FATAL_ALERT ( MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR , MBEDTLS_ERR_SSL_DECODE_ERROR ) ; return MBEDTLS_ERR_SSL_DECODE_ERROR ; } ret = ssl -> handshake -> update_checksum ( ssl , identities_end , ( size_t ) ( binders_end - identities_end ) ) ; if ( 0 != ret ) { MBEDTLS_SSL_DEBUG_RET ( 1 , ( "update_checksum" ) , ret ) ; return ret ; } if ( matched_identity == - 1 ) { MBEDTLS_SSL_DEBUG_MSG ( 3 , ( "No matched PSK or ticket." ) ) ; return MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY ; } ssl -> handshake -> selected_identity = ( uint16_t ) matched_identity ; MBEDTLS_SSL_DEBUG_MSG ( 3 , ( "Pre shared key found" ) ) ; return 0 ; } 