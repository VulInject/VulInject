stf_status ikev2_derive_child_keys ( struct state * st , enum phase1_role role ) { struct v2prf_stuff childsacalc ; struct state * pst ; enum ikev2_trans_type_prf alg ; chunk_t ikeymat , rkeymat ; struct ipsec_proto_info * ipi = & st -> st_esp ; kernel_alg_esp_info ( & ipi -> attrs . transattrs . ei , ipi -> attrs . transattrs . encrypt , ipi -> attrs . transattrs . enckeylen , ipi -> attrs . transattrs . integ_hash ) ; pst = st ; if ( st && st -> st_clonedfrom ) { pst = state_with_serialno ( st -> st_clonedfrom ) ; } alg = pst -> st_oakley . prf_hash ; childsacalc . prf_hasher = ike_alg_get_prf ( alg ) ; if ( ! childsacalc . prf_hasher ) { DBG ( DBG_CONTROL , DBG_log ( "unsupported prf+ algorithm %d" , alg ) ) ; return STF_FAIL ; } DBG ( DBG_CRYPT , DBG_log ( "%s: using %s for prf+ (SA #%ld cloned from #%ld)" , __FUNCTION__ , childsacalc . prf_hasher ?childsacalc . prf_hasher -> common . name : "n/a" , st -> st_serialno , st -> st_clonedfrom ) ) ; DBG ( , 256 "SA #%lu IKE alg: %s" "SA #%lu ESP alg: %s" "SA #%lu IKE alg: %s" "SA #%lu ESP alg: %s" ) setchunk ( childsacalc . ni , st -> st_ni . ptr , st -> st_ni . len ) ; setchunk ( childsacalc . nr , st -> st_nr . ptr , st -> st_nr . len ) ; DBG ( , "childsacalc.ni" "childsacalc.nr" ) childsacalc . spii . len = 0 ; childsacalc . spir . len = 0 ; childsacalc . counter [ 0 ] = 1 ; childsacalc . skeyseed = & st -> st_skey_d ; st -> st_esp . present = TRUE ; st -> st_esp . keymat_len = st -> st_esp . attrs . transattrs . ei . enckeylen + st -> st_esp . attrs . transattrs . ei . authkeylen ; DBG ( DBG_CRYPT , DBG_log ( "%s: my role is %s" , __FUNCTION__ , ROLE_NAME ( role ) ) ) ; v2genbytes ( & ikeymat , st -> st_esp . keymat_len , "initiator keys" , & childsacalc ) ; v2genbytes ( & rkeymat , st -> st_esp . keymat_len , "responder keys" , & childsacalc ) ; if ( role != INITIATOR ) { DBG ( , "our  keymat" "peer keymat" ) st -> st_esp . our_keymat = ikeymat . ptr ; st -> st_esp . peer_keymat = rkeymat . ptr ; } else { DBG ( , "our  keymat" "peer keymat" ) st -> st_esp . peer_keymat = ikeymat . ptr ; st -> st_esp . our_keymat = rkeymat . ptr ; } return STF_OK ; } 