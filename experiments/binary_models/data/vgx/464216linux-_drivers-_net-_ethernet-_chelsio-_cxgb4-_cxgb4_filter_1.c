int __cxgb4_set_filter ( struct net_device * dev , int ftid , struct ch_filter_specification * fs , struct filter_ctx * ctx ) { struct adapter * adapter = netdev2adap ( dev ) ; unsigned int max_fidx , fidx , chip_ver ; int iq , ret , filter_id = ftid ; struct filter_entry * f , * tab ; u32 iconf ; chip_ver = CHELSIO_CHIP_VERSION ( adapter -> params . chip ) ; if ( fs -> hash ) { if ( is_hashfilter ( adapter ) ) { return cxgb4_set_hash_filter ( dev , fs , ctx ) ; } netdev_err ( dev , "%s: Exact-match filters only supported with Hash Filter configuration\n" , __func__ ) ; return - EINVAL ; } max_fidx = adapter -> tids . nftids + adapter -> tids . nhpftids ; fill_default_mask ( fs ) ; ret = validate_filter ( dev , fs ) ; if ( ret ) { return ret ; } iq = get_filter_steerq ( dev , fs ) ; if ( iq < 0 ) { return iq ; } if ( fs -> prio ) { tab = & adapter -> tids . hpftid_tab [ 0 ] ; } else { tab = & adapter -> tids . ftid_tab [ 0 ] ; filter_id = ftid - adapter -> tids . nhpftids ; } if ( fs -> type == 0 ) { if ( chip_ver < CHELSIO_T6 ) { fidx = filter_id & ~ 0x3 ; } else { fidx = filter_id & ~ 0x1 ; } if ( fidx != filter_id && tab [ fidx ] . fs . type ) { f = & tab [ fidx ] ; if ( f -> valid ) { dev_err ( adapter -> pdev_dev , "Invalid location. IPv6 requires 4 slots and is occupying slots %u to %u\n" , fidx , fidx + 3 ) ; return - EINVAL ; } } } else { if ( chip_ver < CHELSIO_T6 ) { if ( filter_id & 0x3 ) { dev_err ( adapter -> pdev_dev , "Invalid location. IPv6 must be aligned on a 4-slot boundary\n" ) ; return - EINVAL ; } for ( fidx = filter_id + 1 ; fidx < filter_id + 4 ; fidx ++ ) { f = & tab [ fidx ] ; if ( f -> valid ) { dev_err ( adapter -> pdev_dev , "Invalid location.  IPv6 requires 4 slots and an IPv4 filter exists at %u\n" , fidx ) ; return - EBUSY ; } } } else { if ( filter_id & 0x1 ) { return - EINVAL ; } fidx = filter_id + 1 ; f = & tab [ fidx ] ; if ( f -> valid ) { pr_err ( "%s: IPv6 filter requires 2 indices. IPv4 filter already present at %d. Please remove IPv4 filter first.\n" , __func__ , fidx ) ; return - EBUSY ; } } } f = & tab [ filter_id ] ; if ( f -> valid ) { return - EBUSY ; } if ( fs -> prio ) { fidx = filter_id + adapter -> tids . hpftid_base ; ret = cxgb4_set_hpftid ( & adapter -> tids , filter_id , fs -> type ?PF_INET6 : PF_INET ) ; } else { fidx = filter_id + adapter -> tids . ftid_base ; ret = cxgb4_set_ftid ( & adapter -> tids , filter_id , fs -> type ?PF_INET6 : PF_INET , chip_ver ) ; } if ( ret ) { return ret ; } ret = writable_filter ( f ) ; if ( ret ) { free_tid } if ( is_t6 ( adapter -> params . chip ) && fs -> type && ipv6_addr_type ( ( const in6_addr * ) fs -> val . lip ) != IPV6_ADDR_ANY ) { ret = cxgb4_clip_get ( dev , ( const u32 * ) & fs -> val . lip , 1 ) ; if ( ret ) { free_tid } } f -> fs = * fs ; f -> fs . iq = iq ; f -> dev = dev ; iconf = adapter -> params . tp . ingress_config ; if ( iconf & VNIC_F ) { f -> fs . val . ovlan = ( fs -> val . pf << 13 ) | fs -> val . vf ; f -> fs . mask . ovlan = ( fs -> mask . pf << 13 ) | fs -> mask . vf ; f -> fs . val . ovlan_vld = fs -> val . pfvf_vld ; f -> fs . mask . ovlan_vld = fs -> mask . pfvf_vld ; } if ( iconf & USE_ENC_IDX_F ) { if ( f -> fs . val . encap_vld ) { struct port_info * pi = netdev_priv ( f -> dev ) ; static const u8 match_all_mac [ ] { 0 0 0 0 0 0 } ; ; ret = t4_alloc_encap_mac_filt ( adapter , pi -> viid , match_all_mac , match_all_mac , f -> fs . val . vni , f -> fs . mask . vni , 0 , 1 , 1 ) ; if ( ret < 0 ) { free_tid } f -> fs . val . ovlan = ret ; f -> fs . mask . ovlan = 0x1ff ; f -> fs . val . ovlan_vld = 1 ; f -> fs . mask . ovlan_vld = 1 ; } } f -> ctx = ctx ; f -> tid = fidx ; ret = set_filter_wr ( adapter , ftid ) ; if ( ret ) { free_tid } return ret ; free_tid if ( f -> fs . prio ) { cxgb4_clear_hpftid ( & adapter -> tids , filter_id , fs -> type ?PF_INET6 : PF_INET ) ; } else { cxgb4_clear_ftid ( & adapter -> tids , filter_id , fs -> type ?PF_INET6 : PF_INET , chip_ver ) ; } clear_filter ( adapter , f ) ; return ret ; } 