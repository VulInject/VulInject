static void bwmode_update_check ( struct adapter * padapter , struct ndis_802_11_var_ie * pIE ) { unsigned char new_bwmode ; unsigned char new_ch_offset ; struct HT_info_element * pHT_info ; struct mlme_priv * pmlmepriv = & padapter -> mlmepriv ; struct mlme_ext_priv * pmlmeext = & padapter -> mlmeextpriv ; struct mlme_ext_info * pmlmeinfo = & pmlmeext -> mlmext_info ; struct registry_priv * pregistrypriv = & padapter -> registrypriv ; struct ht_priv * phtpriv = & pmlmepriv -> htpriv ; if ( ! phtpriv ) { return ; } if ( pIE -> Length > sizeof ( HT_info_element ) ) { return ; } pHT_info = ( HT_info_element * ) pIE -> data ; if ( ( pHT_info -> infos [ 0 ] & BIT ( 2 ) ) && pregistrypriv -> cbw40_enable ) { new_bwmode = HT_CHANNEL_WIDTH_40 ; switch ( pHT_info -> infos [ 0 ] & 0x3 ) { case 1 : new_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER ; break ; case 3 : new_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER ; break ; default : new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE ; break ; } } else { new_bwmode = HT_CHANNEL_WIDTH_20 ; new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE ; } if ( ( new_bwmode != pmlmeext -> cur_bwmode ) || ( new_ch_offset != pmlmeext -> cur_ch_offset ) ) { pmlmeinfo -> bwmode_updated = true ; pmlmeext -> cur_bwmode = new_bwmode ; pmlmeext -> cur_ch_offset = new_ch_offset ; HT_info_handler ( padapter , pIE ) ; } else { pmlmeinfo -> bwmode_updated = false ; } if ( pmlmeinfo -> bwmode_updated ) { struct sta_info * psta ; struct wlan_bssid_ex * cur_network = & pmlmeinfo -> network ; struct sta_priv * pstapriv = & padapter -> stapriv ; psta = rtw_get_stainfo ( pstapriv , cur_network -> MacAddress ) ; if ( psta ) { struct ht_priv * phtpriv_sta = & psta -> htpriv ; if ( phtpriv_sta -> ht_option ) { phtpriv_sta -> bwmode = pmlmeext -> cur_bwmode ; phtpriv_sta -> ch_offset = pmlmeext -> cur_ch_offset ; } else { phtpriv_sta -> bwmode = HT_CHANNEL_WIDTH_20 ; phtpriv_sta -> ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE ; } } } } 