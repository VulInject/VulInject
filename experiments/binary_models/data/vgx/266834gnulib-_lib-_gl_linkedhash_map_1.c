gl_linkedhash_getremove ( , , ) { size_t hashcode = ( map -> hashcode_fn != NULL ?map -> hashcode_fn ( key ) : ( size_t ) ( uintptr_t ) key ) ; size_t bucket = hashcode % map -> table_size ; gl_mapkey_equals_fn equals = map -> base . equals_fn ; gl_list_node_t * nodep ; for ( nodep = ( gl_list_node_t * ) & map -> table [ bucket ] ; * nodep != NULL ; nodep = ( gl_list_node_t * ) & ( * nodep ) -> h . hash_next ) { gl_list_node_t node = * nodep ; if ( node -> h . hashcode == hashcode && ( equals != NULL ?equals ( key , node -> key ) : key == node -> key ) ) { * oldvaluep = node -> value ; * nodep = ( gl_list_node_t ) node -> h . hash_next ; { gl_list_node_t prev = node -> prev ; gl_list_node_t next = node -> next ; ASYNCSAFE ( ) prev -> next = next ; next -> prev = prev ; } map -> count -- ; if ( map -> base . kdispose_fn != NULL ) { map -> base . kdispose_fn ( node -> key ) ; } return true ; } } return false ; } 