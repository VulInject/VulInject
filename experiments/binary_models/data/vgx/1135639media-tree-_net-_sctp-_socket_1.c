static int sctp_send_asconf_add_ip ( struct sock * sk , struct sockaddr * addrs , int addrcnt ) { struct net * net = sock_net ( sk ) ; struct sctp_sock * sp ; struct sctp_endpoint * ep ; struct sctp_association * asoc ; struct sctp_bind_addr * bp ; struct sctp_chunk * chunk ; struct sctp_sockaddr_entry * laddr ; union sctp_addr * addr ; union sctp_addr saveaddr ; void * addr_buf ; struct sctp_af * af ; struct list_head * p ; int i ; int retval = 0 ; if ( ! net -> sctp . addip_enable ) { return retval ; } sp = sctp_sk ( sk ) ; ep = sp -> ep ; pr_debug ( "%s: sk:%p, addrs:%p, addrcnt:%d\n" , __func__ , sk , addrs , addrcnt ) ; list_for_each_entry ( , , ) { if ( ! asoc -> peer . asconf_capable ) { continue ; } if ( asoc -> peer . addip_disabled_mask & SCTP_PARAM_ADD_IP ) { continue ; } if ( ! sctp_state ( asoc , ESTABLISHED ) ) { continue ; } addr_buf = addrs ; for ( i = 0 ; i < addrcnt ; i ++ ) { addr = addr_buf ; af = sctp_get_af_specific ( addr -> v4 . sin_family ) ; if ( ! af ) { retval = - EINVAL ; out } if ( sctp_assoc_lookup_laddr ( asoc , addr ) ) { break ; } addr_buf += af -> sockaddr_len ; } bp = & asoc -> base . bind_addr ; p = bp -> address_list . next ; laddr = list_entry ( p , sctp_sockaddr_entry , list ) ; chunk = sctp_make_asconf_update_ip ( asoc , & laddr -> a , addrs , addrcnt , SCTP_PARAM_ADD_IP ) ; if ( ! chunk ) { retval = - ENOMEM ; out } addr_buf = addrs ; for ( i = 0 ; i < addrcnt ; i ++ ) { addr = addr_buf ; af = sctp_get_af_specific ( addr -> v4 . sin_family ) ; memcpy ( & saveaddr , addr , af -> sockaddr_len ) ; retval = sctp_add_bind_addr ( bp , & saveaddr , sizeof ( saveaddr ) , SCTP_ADDR_NEW , GFP_ATOMIC ) ; addr_buf += af -> sockaddr_len ; } if ( asoc -> src_out_of_asoc_ok ) { struct sctp_transport * trans ; list_for_each_entry ( , , ) { sctp_transport_dst_release ( trans ) ; trans -> cwnd = min ( 4 * asoc -> pathmtu , max_t ( __u32 , 2 * asoc -> pathmtu , 4380 ) ) ; trans -> ssthresh = asoc -> peer . i . a_rwnd ; trans -> rto = asoc -> rto_initial ; sctp_max_rto ( asoc , trans ) ; trans -> rtt = trans -> srtt = trans -> rttvar = 0 ; sctp_transport_route ( trans , NULL , sctp_sk ( asoc -> base . sk ) ) ; } } retval = sctp_send_asconf ( asoc , chunk ) ; } out return retval ; } 