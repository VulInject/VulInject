static SplitVar * SplitToVariants ( IspellDict * Conf , SPNode * snode , SplitVar * orig , char * word , int wordlen , int startpos , int minpos ) { SplitVar * var = NULL ; SPNodeData * StopLow , * StopHigh , * StopMiddle = NULL ; SPNode * node = ( snode ) ?snode : Conf -> Dictionary ; int level = ( snode ) ?minpos : startpos ; int lenaff ; CMPDAffix * caff ; char * notprobed ; int compoundflag = 0 ; check_stack_depth ( ) ; notprobed = ( char * ) palloc ( wordlen ) ; var = CopyVar ( orig , 1 ) ; while ( level < wordlen ) { caff = Conf -> CompoundAffix ; while ( level > startpos && ( lenaff = CheckCompoundAffixes ( & caff , word + level , wordlen - level , ( node ) ?true : false ) ) >= 0 ) { char buf [ MAXNORMLEN ] ; char * * subres ; lenaff = level - startpos + lenaff ; if ( ! notprobed [ startpos + lenaff - 1 ] ) { continue ; } if ( level + lenaff - 1 <= minpos ) { continue ; } if ( lenaff >= MAXNORMLEN ) { continue ; } if ( lenaff > 0 ) { memcpy ( buf , word + startpos , lenaff ) ; } buf [ lenaff ] = '\0' ; if ( level == 0 ) { compoundflag = FF_COMPOUNDBEGIN ; } if ( level == wordlen - 1 ) { compoundflag = FF_COMPOUNDLAST ; } else { compoundflag = FF_COMPOUNDMIDDLE ; } subres = NormalizeSubWord ( Conf , buf , compoundflag ) ; if ( subres ) { SplitVar * new = CopyVar ( var , 0 ) ; SplitVar * ptr = var ; char * * sptr = subres ; notprobed [ startpos + lenaff - 1 ] = 0 ; while ( * sptr ) { AddStem ( new , * sptr ) ; sptr ++ ; } pfree ( subres ) ; while ( ptr -> next ) { ptr = ptr -> next ; } ptr -> next = SplitToVariants ( Conf , NULL , new , word , wordlen , startpos + lenaff , startpos + lenaff ) ; pfree ( new -> stem ) ; pfree ( new ) ; } } if ( ! node ) { break ; } StopLow = node -> data ; StopHigh = node -> data + node -> length ; while ( StopLow < StopHigh ) { StopMiddle = StopLow + ( ( StopHigh - StopLow ) >> 1 ) ; if ( StopMiddle -> val == ( ( uint8 * ) ( word ) ) [ level ] ) { break ; } if ( StopMiddle -> val < ( ( uint8 * ) ( word ) ) [ level ] ) { StopLow = StopMiddle + 1 ; } else { StopHigh = StopMiddle ; } } if ( StopLow < StopHigh ) { if ( startpos == 0 ) { compoundflag = FF_COMPOUNDBEGIN ; } if ( level == wordlen - 1 ) { compoundflag = FF_COMPOUNDLAST ; } else { compoundflag = FF_COMPOUNDMIDDLE ; } if ( StopMiddle -> isword && ( StopMiddle -> compoundflag & compoundflag ) && notprobed [ level ] ) { if ( level > minpos ) { if ( wordlen == level + 1 ) { AddStem ( var , pnstrdup ( word + startpos , wordlen - startpos ) ) ; pfree ( notprobed ) ; return var ; } else { SplitVar * ptr = var ; while ( ptr -> next ) { ptr = ptr -> next ; } ptr -> next = SplitToVariants ( Conf , node , var , word , wordlen , startpos , level ) ; level ++ ; AddStem ( var , pnstrdup ( word + startpos , level - startpos ) ) ; node = Conf -> Dictionary ; startpos = level ; continue ; } } } node = StopMiddle -> node ; } else { node = NULL ; } level ++ ; } AddStem ( var , pnstrdup ( word + startpos , wordlen - startpos ) ) ; pfree ( notprobed ) ; return var ; } 