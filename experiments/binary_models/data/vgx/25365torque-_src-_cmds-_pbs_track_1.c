int parse_commandline_opts ( int argc , char * * argv , std :: string & tmpAdopteeID , std :: string & tmpJobID , int & DoBackground ) { int ArgIndex ; int NumErrs = 0 ; while ( ( ArgIndex = getopt ( argc , argv , GETOPT_ARGS ) ) != EOF ) { switch ( ArgIndex ) { case 'a' : if ( DoBackground == 1 ) { NumErrs ++ ; break ; } tmpAdopteeID = optarg ; break ; case 'b' : if ( tmpAdopteeID . size ( ) != 0 ) { NumErrs ++ ; break ; } DoBackground = 1 ; break ; case 'j' : tmpJobID = optarg ; break ; default : NumErrs ++ ; break ; } } if ( ( NumErrs > 0 ) || ( ( optind >= argc ) && ( tmpAdopteeID . size ( ) == 0 ) ) || ( ( tmpJobID . size ( ) == 0 ) && ( tmpAdopteeID . size ( ) == 0 ) ) || ( ( tmpAdopteeID . size ( ) > 0 ) && ( tmpJobID . size ( ) == '\0' ) ) ) { fprintf ( stdout , "NumErrs %d tmpJobID len %d tmpAdopteeID len %d\n" , NumErrs , ( int ) tmpJobID . size ( ) , ( int ) tmpAdopteeID . size ( ) ) ; fprintf ( stdout , "argc %d argv[0] %s argv[1]%s argv[2] %s" , argc , argv [ 0 ] , argv [ 1 ] , argv [ 2 ] ) ; static char Usage [ ] "USAGE: pbs_track -j<JOBID>[-b] -- a.out arg1 arg2 ... argN\n" " OR    pbs_track -j<JOBID>-a<PID>\n" ; ; fprintf ( stderr , "%s" , Usage ) ; return 2 ; } return PBSE_NONE ; } int adopt_process ( char * JobID , const std :: string & tmpAdopteeID ) { int rc ; int adoptee_pid ; adoptee_pid = strtol ( tmpAdopteeID . c_str ( ) , NULL , 10 ) ; if ( errno == ERANGE || tmpAdopteeID . find_first_not_of ( "0123456789" ) != std :: string :: npos ) { fprintf ( stderr , "Invalid PID to adopt: %s\n" , tmpAdopteeID . c_str ( ) ) ; return PBSE_RMBADPARAM ; } rc = tm_adopt ( JobID , TM_ADOPT_JOBID , adoptee_pid ) ; return rc ; } int fork_process ( int argc , char * * argv , int DoBackground , int & this_pid , char * JobID , char * * Args ) { int aindex = 0 ; int rc = - 100 ; aindex = 0 ; for ( ; optind < argc ; optind ++ ) { Args [ aindex ++ ] = strdup ( argv [ optind ] ) ; printf ( "Got arg: %s\n" , Args [ aindex - 1 ] ) ; } this_pid = 1 ; if ( DoBackground == 1 ) { printf ( "FORKING!\n" ) ; this_pid = fork ( ) ; } if ( ( DoBackground == 0 ) || ( this_pid == 0 ) ) { rc = tm_adopt ( JobID , TM_ADOPT_JOBID , getpid ( ) ) ; } if ( this_pid > 0 ) { fclose ( stdin ) ; fclose ( stdout ) ; fclose ( stderr ) ; } if ( this_pid < 0 ) { fprintf ( stderr , "pbs_track: could not fork (%d:%s)\n" , errno , strerror ( errno ) ) ; } return rc ; } int handle_adoption_results ( int rc , int DoBackground , int this_pid , char * JobID , std :: string tmpAdopteeID , char * * Args ) { if ( ( DoBackground == 0 ) || ( this_pid == 0 ) || tmpAdopteeID . size ( ) > 0 ) { switch ( rc ) { case TM_SUCCESS : fprintf ( stderr , "Success!\n" ) ; break ; case TM_ENOTFOUND : fprintf ( stderr , "pbs_track: MOM could not find job %s\n" , JobID ) ; break ; case TM_ESYSTEM : case TM_ENOTCONNECTED : fprintf ( stderr , "pbs_track: error occurred while trying to communication with pbs_mom: %s (%d)\n" , pbse_to_txt ( rc ) , rc ) ; break ; case TM_EPERM : fprintf ( stderr , "pbs_track: permission denied: %s (%d)\n" , pbse_to_txt ( rc ) , rc ) ; break ; default : fprintf ( stderr , "pbs_track: unexpected error %s (%d) occurred\n" , pbse_to_txt ( rc ) , rc ) ; break ; } if ( rc != TM_SUCCESS ) { return - 1 ; } if ( tmpAdopteeID . size ( ) == 0 && execvp ( Args [ 0 ] , Args ) == - 1 ) { fprintf ( stderr , "execvp failed with error %d, message:\n%s\n" , errno , strerror ( errno ) ) ; return errno ; } } return 0 ; } int main ( int argc , char * * argv ) { char * Args [ MAXARGS ] ; int rc ; int this_pid ; std :: string tmpJobID ; std :: string tmpAdopteeID ; char JobID [ PBS_MAXCLTJOBID ] ; std :: vector ( std :: string ) id_list ; std :: string server_name ; int DoBackground = 0 ; rc = parse_commandline_opts ( argc , argv , tmpAdopteeID , tmpJobID , DoBackground ) ; if ( rc ) { exit ( rc ) ; } if ( getenv ( NO_SERVER_SUFFIX ) != NULL ) { snprintf ( JobID , sizeof ( JobID ) , "%s" , tmpJobID . c_str ( ) ) ; } else { if ( get_server_and_job_ids ( tmpJobID . c_str ( ) , id_list , server_name ) ) { fprintf ( stderr , "pbs_track: illegally formed job identifier: '%s'\n" , JobID ) ; exit ( 1 ) ; } } if ( tmpAdopteeID . size ( ) > 0 ) { for ( size_t i = 0 ; i < id_list . size ( ) ; i ++ ) { snprintf ( JobID , sizeof ( JobID ) , "%s" , id_list [ i ] . c_str ( ) ) ; if ( ( rc = adopt_process ( JobID , tmpAdopteeID ) ) != PBSE_UNKJOBID ) { break ; } } if ( rc == PBSE_RMBADPARAM ) { return 1 ; } } else { rc = fork_process ( argc , argv , DoBackground , this_pid , JobID , Args ) ; } rc = handle_adoption_results ( rc , DoBackground , this_pid , JobID , tmpAdopteeID , Args ) ; exit ( rc ) ; } 