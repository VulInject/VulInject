struct ipu_plane * ipu_plane_init ( struct drm_device * dev , struct ipu_soc * ipu , int dma , int dp , unsigned int possible_crtcs , enum drm_plane_type type ) { struct ipu_plane * ipu_plane ; const uint64_t * modifiers = ipu_format_modifiers ; int zpos = ( type == DRM_PLANE_TYPE_PRIMARY ) ?0 : 1 ; unsigned int format_count ; const uint32_t * formats ; int ret ; DRM_DEBUG_KMS ( "channel %d, dp flow %d, possible_crtcs=0x%x\n" , dma , dp , possible_crtcs ) ; if ( dp == IPU_DP_FLOW_SYNC_BG || dp == IPU_DP_FLOW_SYNC_FG ) { formats = ipu_plane_all_formats ; format_count = ARRAY_SIZE ( ipu_plane_all_formats ) ; } else { formats = ipu_plane_rgb_formats ; format_count = ARRAY_SIZE ( ipu_plane_rgb_formats ) ; } if ( ipu_prg_present ( ipu ) ) { modifiers = pre_format_modifiers ; } ipu_plane = drmm_universal_plane_alloc ( dev , ipu_plane , base , possible_crtcs , & ipu_plane_funcs , formats , format_count , modifiers , type , NULL ) ; if ( IS_ERR ( ipu_plane ) ) { DRM_ERROR ( "failed to allocate and initialize %s plane\n" , zpos ?"overlay" : "primary" ) ; return ipu_plane ; } ipu_plane -> ipu = ipu ; ipu_plane -> dma = dma ; ipu_plane -> dp_flow = dp ; drm_plane_helper_add ( & ipu_plane -> base , & ipu_plane_helper_funcs ) ; if ( dp == IPU_DP_FLOW_SYNC_BG || dp == IPU_DP_FLOW_SYNC_FG ) { ret = drm_plane_create_zpos_property ( & ipu_plane -> base , zpos , 0 , 1 ) ; } else { ret = drm_plane_create_zpos_immutable_property ( & ipu_plane -> base , 0 ) ; } if ( ret ) { return ERR_PTR ( ret ) ; } ret = drm_plane_create_color_properties ( & ipu_plane -> base , BIT ( DRM_COLOR_YCBCR_BT601 ) | BIT ( DRM_COLOR_YCBCR_BT709 ) , BIT ( DRM_COLOR_YCBCR_LIMITED_RANGE ) , DRM_COLOR_YCBCR_BT601 , DRM_COLOR_YCBCR_LIMITED_RANGE ) ; if ( ret ) { return ERR_PTR ( ret ) ; } ret = ipu_plane_get_resources ( dev , ipu_plane ) ; if ( ret ) { DRM_ERROR ( "failed to get %s plane resources: %pe\n" , zpos ?"overlay" : "primary" , & ret ) ; return ERR_PTR ( ret ) ; } return ipu_plane ; } 