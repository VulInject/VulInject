xstormy16_elf_relax_section ( , , , ) { struct relax_plt_data relax_plt_data ; bfd * ibfd ; * again = FALSE ; if ( info -> relocatable ) { return TRUE ; } if ( dynobj != elf_hash_table ( info ) -> dynobj || strcmp ( splt -> name , ".plt" ) != 0 ) { return TRUE ; } relax_plt_data . splt = splt ; relax_plt_data . again = again ; elf_link_hash_traverse ( elf_hash_table ( info ) , xstormy16_relax_plt_check , & relax_plt_data ) ; for ( ibfd = info -> input_bfds ; ibfd ; ibfd = ibfd -> link_next ) { bfd_vma * local_plt_offsets = elf_local_got_offsets ( ibfd ) ; Elf_Internal_Shdr * symtab_hdr ; Elf_Internal_Sym * isymbuf = NULL ; unsigned int idx ; if ( ! local_plt_offsets ) { continue ; } symtab_hdr = & elf_tdata ( ibfd ) -> symtab_hdr ; if ( symtab_hdr -> sh_info != 0 ) { isymbuf = ( Elf_Internal_Sym * ) symtab_hdr -> contents ; if ( isymbuf == NULL ) { isymbuf = bfd_elf_get_elf_syms ( ibfd , symtab_hdr , symtab_hdr -> sh_info , 0 , NULL , NULL , NULL ) ; } if ( isymbuf == NULL ) { return FALSE ; } } for ( idx = 0 ; idx < symtab_hdr -> sh_info ; ++ idx ) { Elf_Internal_Sym * isym ; asection * tsec ; bfd_vma address ; if ( local_plt_offsets [ idx ] == ( bfd_vma ) - 1 ) { continue ; } isym = & isymbuf [ idx ] ; if ( isym -> st_shndx == SHN_UNDEF ) { continue ; } if ( isym -> st_shndx == SHN_ABS ) { tsec = bfd_abs_section_ptr ; } if ( isym -> st_shndx == SHN_COMMON ) { tsec = bfd_com_section_ptr ; } else { tsec = bfd_section_from_elf_index ( ibfd , isym -> st_shndx ) ; } address = ( tsec -> output_section -> vma + tsec -> output_offset + isym -> st_value ) ; if ( address <= 0xffff ) { local_plt_offsets [ idx ] = - 1 ; splt -> size -= 4 ; * again = TRUE ; } } if ( isymbuf != NULL && symtab_hdr -> contents != ( unsigned char * ) isymbuf ) { if ( ! info -> keep_memory ) { free ( isymbuf ) ; } else { symtab_hdr -> contents = ( unsigned char * ) isymbuf ; } } } if ( * again && splt -> size > 0 ) { bfd_vma entry = 0 ; elf_link_hash_traverse ( elf_hash_table ( info ) , xstormy16_relax_plt_realloc , & entry ) ; for ( ibfd = info -> input_bfds ; ibfd ; ibfd = ibfd -> link_next ) { bfd_vma * local_plt_offsets = elf_local_got_offsets ( ibfd ) ; unsigned int nlocals = elf_tdata ( ibfd ) -> symtab_hdr . sh_info ; unsigned int idx ; if ( ! local_plt_offsets ) { continue ; } for ( idx = 0 ; idx < nlocals ; ++ idx ) { if ( local_plt_offsets [ idx ] != ( bfd_vma ) - 1 ) { local_plt_offsets [ idx ] = entry ; entry += 4 ; } } } } return TRUE ; } 