static int rwpcp ( struct pcnode * pcp , struct uio * uio , enum uio_rw rw , int ioflag ) { struct vnode * vp = PCTOV ( pcp ) ; struct pcfs * fsp ; daddr_t bn ; int n ; offset_t off ; caddr_t base ; int mapon , pagecreate ; int newpage ; int error = 0 ; rlim64_t limit = uio -> uio_llimit ; int oresid = uio -> uio_resid ; if ( vp -> v_vfsp -> vfs_flag & VFS_UNMOUNTED ) { return ( EIO ) ; } PC_DPRINTF4 ( 5 , "rwpcp pcp=%p off=%lld resid=%ld size=%u\n" , ( void * ) pcp , uio -> uio_loffset , uio -> uio_resid , pcp -> pc_size ) ; ASSERT ( rw == UIO_READ || rw == UIO_WRITE ) ; ASSERT ( vp -> v_type == VREG ) ; if ( uio -> uio_loffset < 0 ) { return ( EINVAL ) ; } if ( limit == RLIM64_INFINITY || limit > MAXOFFSET_T ) { limit = MAXOFFSET_T ; } if ( uio -> uio_loffset >= limit && rw == UIO_WRITE ) { proc_t * p = ttoproc ( curthread ) ; mutex_enter ( & p -> p_lock ) ; ( void ) rctl_action ( rctlproc_legacy [ RLIMIT_FSIZE ] , p -> p_rctls , p , RCA_UNSAFE_SIGINFO ) ; mutex_exit ( & p -> p_lock ) ; return ( EFBIG ) ; } if ( uio -> uio_loffset >= UINT32_MAX ) { return ( EFBIG ) ; } if ( uio -> uio_resid == 0 ) { return ( 0 ) ; } if ( limit > UINT32_MAX ) { limit = UINT32_MAX ; } fsp = VFSTOPCFS ( vp -> v_vfsp ) ; if ( fsp -> pcfs_flags & PCFS_IRRECOV ) { return ( EIO ) ; } { off = uio -> uio_loffset & MAXBMASK ; mapon = ( int ) ( uio -> uio_loffset & MAXBOFFSET ) ; n = MIN ( MAXBSIZE - mapon , uio -> uio_resid ) ; if ( rw == UIO_READ ) { offset_t diff ; diff = pcp -> pc_size - uio -> uio_loffset ; if ( diff <= 0 ) { return ( 0 ) ; } if ( diff < n ) { n = ( int ) diff ; } } if ( rw == UIO_WRITE && uio -> uio_loffset + n >= limit ) { if ( uio -> uio_loffset >= limit ) { error = EFBIG ; break ; } n = ( int ) ( limit - uio -> uio_loffset ) ; } uio_prefaultpages ( ( long ) n , uio ) ; base = segmap_getmap ( segkmap , vp , ( u_offset_t ) off ) ; pagecreate = 0 ; newpage = 0 ; if ( rw == UIO_WRITE ) { if ( uio -> uio_loffset + n > pcp -> pc_size ) { uint_t ncl , lcn ; ncl = ( uint_t ) howmany ( ( offset_t ) pcp -> pc_size , fsp -> pcfs_clsize ) ; if ( uio -> uio_loffset > pcp -> pc_size && ncl < ( uint_t ) howmany ( uio -> uio_loffset , fsp -> pcfs_clsize ) ) { lcn = pc_lblkno ( fsp , uio -> uio_loffset ) ; error = pc_balloc ( pcp , ( daddr_t ) lcn , 1 , & bn ) ; ncl = lcn + 1 ; } if ( ! error && ncl < ( uint_t ) howmany ( uio -> uio_loffset + n , fsp -> pcfs_clsize ) ) { error = pc_balloc ( pcp , ( daddr_t ) pc_lblkno ( fsp , uio -> uio_loffset + n - 1 ) , 0 , & bn ) ; } pcp -> pc_flags |= PC_CHG ; if ( error ) { pc_cluster32_t ncl ; int nerror ; nerror = pc_fileclsize ( fsp , pcp -> pc_scluster , & ncl ) ; if ( nerror ) { PC_DPRINTF1 ( 2 , "cluster chain " "corruption, " "scluster=%d\n" , pcp -> pc_scluster ) ; pcp -> pc_size = 0 ; pcp -> pc_flags |= PC_INVAL ; error = nerror ; ( void ) segmap_release ( segkmap , base , 0 ) ; break ; } pcp -> pc_size = fsp -> pcfs_clsize * ncl ; if ( error == ENOSPC && ( pcp -> pc_size - uio -> uio_loffset ) > 0 ) { PC_DPRINTF3 ( 2 , "rwpcp ENOSPC " "off=%lld n=%d size=%d\n" , uio -> uio_loffset , n , pcp -> pc_size ) ; n = ( int ) ( pcp -> pc_size - uio -> uio_loffset ) ; } else { PC_DPRINTF1 ( 1 , "rwpcp error1=%d\n" , error ) ; ( void ) segmap_release ( segkmap , base , 0 ) ; break ; } } else { pcp -> pc_size = ( uint_t ) ( uio -> uio_loffset + n ) ; } if ( mapon == 0 ) { newpage = segmap_pagecreate ( segkmap , base , ( size_t ) n , 0 ) ; pagecreate = 1 ; } } if ( n == MAXBSIZE ) { newpage = segmap_pagecreate ( segkmap , base , ( size_t ) n , 0 ) ; pagecreate = 1 ; } } error = uiomove ( base + mapon , ( size_t ) n , rw , uio ) ; if ( pagecreate && uio -> uio_loffset < roundup ( off + mapon + n , PAGESIZE ) ) { offset_t nzero , nmoved ; nmoved = uio -> uio_loffset - ( off + mapon ) ; nzero = roundup ( mapon + n , PAGESIZE ) - nmoved ; ( void ) kzero ( base + mapon + nmoved , ( size_t ) nzero ) ; } if ( newpage ) { segmap_pageunlock ( segkmap , base , ( size_t ) n , rw == UIO_WRITE ?S_WRITE : S_READ ) ; } if ( error ) { PC_DPRINTF1 ( 1 , "rwpcp error2=%d\n" , error ) ; if ( rw == UIO_WRITE ) { ( void ) segmap_release ( segkmap , base , SM_INVAL ) ; } else { ( void ) segmap_release ( segkmap , base , 0 ) ; } } else { uint_t flags = 0 ; if ( rw == UIO_READ ) { if ( n + mapon == MAXBSIZE || uio -> uio_loffset == pcp -> pc_size ) { flags = SM_DONTNEED ; } } if ( ioflag & ( FSYNC | FDSYNC ) ) { flags = SM_WRITE ; } if ( n + mapon == MAXBSIZE ) { flags = SM_WRITE | SM_ASYNC | SM_DONTNEED ; } error = segmap_release ( segkmap , base , flags ) ; } } error == 0 && uio -> uio_resid > 0 && n != 0 ; if ( oresid != uio -> uio_resid ) { error = 0 ; } return ( error ) ; } 