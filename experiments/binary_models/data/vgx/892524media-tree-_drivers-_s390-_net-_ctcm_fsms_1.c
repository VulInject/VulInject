static void ctcmpc_chx_send_sweep ( fsm_instance * fsm , int event , void * arg ) { struct channel * ach = arg ; struct net_device * dev = ach -> netdev ; struct ctcm_priv * priv = dev -> ml_priv ; struct mpc_group * grp = priv -> mpcg ; struct channel * wch = priv -> channel [ CTCM_WRITE ] ; struct channel * rch = priv -> channel [ CTCM_READ ] ; struct sk_buff * skb ; struct th_sweep * header ; int rc = 0 ; cfs_time_t saveflags = 0 ; CTCM_PR_DEBUG ( "ctcmpc enter: %s(): cp=%i ch=0x%p id=%s\n" , __func__ , smp_processor_id ( ) , ach , ach -> id ) ; if ( grp -> in_sweep == 0 ) { done } CTCM_PR_DBGDATA ( "%s: 1: ToVTAM_th_seq= %08x\n" , __func__ , wch -> th_seq_num ) ; CTCM_PR_DBGDATA ( "%s: 1: FromVTAM_th_seq= %08x\n" , __func__ , rch -> th_seq_num ) ; if ( fsm_getstate ( wch -> fsm ) != CTC_STATE_TXIDLE ) { fsm_addtimer ( & wch -> sweep_timer , 200 , CTC_EVENT_RSWEEP_TIMER , wch ) ; done } skb = skb_dequeue ( & wch -> sweep_queue ) ; if ( ! skb ) { done } if ( set_normalized_cda ( & wch -> ccw [ 4 ] , skb -> data ) ) { grp -> in_sweep = 0 ; ctcm_clear_busy_do ( dev ) ; dev_kfree_skb_any ( skb ) ; fsm_event ( grp -> fsm , MPCG_EVENT_INOP , dev ) ; done } else { atomic_inc ( & skb -> users ) ; skb_queue_tail ( & wch -> io_queue , skb ) ; } wch -> ccw [ 4 ] . count = skb -> len ; header = ( th_sweep * ) skb -> data ; switch ( header -> th . th_ch_flag ) { case TH_SWEEP_REQ : grp -> sweep_req_pend_num -- ; break ; case TH_SWEEP_RESP : grp -> sweep_rsp_pend_num -- ; break ; } header -> sw . th_last_seq = wch -> th_seq_num ; CTCM_CCW_DUMP ( ( char * ) & wch -> ccw [ 3 ] , sizeof ( ccw1 ) * 3 ) ; CTCM_PR_DBGDATA ( "%s: sweep packet\n" , __func__ ) ; CTCM_D3_DUMP ( ( char * ) header , TH_SWEEP_LENGTH ) ; fsm_addtimer ( & wch -> timer , CTCM_TIME_5_SEC , CTC_EVENT_TIMER , wch ) ; fsm_newstate ( wch -> fsm , CTC_STATE_TX ) ; spin_lock_irqsave ( get_ccwdev_lock ( wch -> cdev ) , saveflags ) ; wch -> prof . send_stamp = jiffies ; rc = ccw_device_start ( wch -> cdev , & wch -> ccw [ 3 ] , ( unsigned long ) wch , 0xff , 0 ) ; spin_unlock_irqrestore ( get_ccwdev_lock ( wch -> cdev ) , saveflags ) ; if ( ( grp -> sweep_req_pend_num == 0 ) && ( grp -> sweep_rsp_pend_num == 0 ) ) { grp -> in_sweep = 0 ; rch -> th_seq_num = 0x00 ; wch -> th_seq_num = 0x00 ; ctcm_clear_busy_do ( dev ) ; } CTCM_PR_DBGDATA ( "%s: To-/From-VTAM_th_seq = %08x/%08x\n" , __func__ , wch -> th_seq_num , rch -> th_seq_num ) ; if ( rc != 0 ) { ctcm_ccw_check_rc ( wch , rc , "send sweep" ) ; } done return ; } 