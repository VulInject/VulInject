struct clk * at91_clk_register_programmable ( void __iomem * base , const char * name , const char * const * parent_names , u8 num_parents , u8 id , const struct clk_programmable_layout * layout , const u32 * clk_mux_table , const u32 * mux_table ) { struct clk_programmable * prog ; struct clk * clk ; u32 val , tmp ; int ret ; if ( ! base || ! name || ! parent_names || ! num_parents || ! layout || ! clk_mux_table || ! mux_table || id > PROG_ID_MAX ) { return ERR_PTR ( - EINVAL ) ; } prog = kzalloc ( sizeof ( * prog ) , GFP_KERNEL ) ; prog -> id = id ; prog -> layout = layout ; prog -> base = base ; prog -> clk_mux_table = clk_mux_table ; prog -> mux_table = mux_table ; prog -> num_parents = num_parents ; pmc_read ( prog -> base , AT91_PMC_PCKR ( prog -> id ) , & tmp ) ; val = tmp & prog -> layout -> css_mask ; if ( layout -> have_slck_mck && ( tmp & AT91_PMC_CSSMCK_MCK ) && ! val ) { ret = PROG_MAX_RM9200_CSS + 1 ; } else { ret = at91_clk_mux_val_to_index ( prog -> mux_table , prog -> num_parents , val ) ; } if ( ret < 0 ) { kfree ( prog ) ; return ERR_PTR ( ret ) ; } clk = & prog -> clk ; clk -> flags = CLK_GET_RATE_NOCACHE ; ret = clk_register ( clk , UBOOT_DM_CLK_AT91_PROG , name , parent_names [ ret ] ) ; if ( ret ) { kfree ( prog ) ; clk = ERR_PTR ( ret ) ; } return clk ; } 