static int _step_connect ( const char * directory , const char * nodename , slurm_step_id_t * step_id ) { int fd ; int len ; struct sockaddr_un addr ; char * name = NULL , * pos = NULL ; uint32_t stepid = step_id -> step_id ; xstrfmtcatat ( name , & pos , "%s/%s_%u.%u" , directory , nodename , step_id -> job_id , stepid ) ; if ( step_id -> step_het_comp != NO_VAL ) { xstrfmtcatat ( name , & pos , ".%u" , step_id -> step_het_comp ) ; } if ( strlen ( name ) >= sizeof ( addr . sun_path ) ) { error ( "%s: Unix socket path '%s' is too long. (%ld>%ld)" , __func__ , name , ( long int ) ( strlen ( name ) + 1 ) , ( long int ) sizeof ( addr . sun_path ) ) ; xfree ( name ) ; return - 1 ; } if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 ) { error ( "%s: socket() failed for %s: %m" , __func__ , name ) ; xfree ( name ) ; return - 1 ; } addr . sun_family = AF_UNIX ; strlcpy ( addr . sun_path , name , sizeof ( addr . sun_path ) ) ; len = strlen ( addr . sun_path ) + 1 + sizeof ( addr . sun_family ) ; if ( connect ( fd , ( sockaddr * ) & addr , len ) < 0 ) { debug ( "%s: connect() failed for %s: %m" , __func__ , name ) ; if ( errno == ECONNREFUSED && running_in_slurmd ( ) ) { _handle_stray_socket ( name ) ; if ( step_id -> step_id == SLURM_BATCH_SCRIPT ) { _handle_stray_script ( directory , step_id -> job_id ) ; } } xfree ( name ) ; close ( fd ) ; return - 1 ; } xfree ( name ) ; return fd ; } 