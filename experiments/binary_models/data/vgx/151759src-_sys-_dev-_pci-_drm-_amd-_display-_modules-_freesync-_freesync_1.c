static void determine_flip_interval_workaround_req ( struct mod_vrr_params * in_vrr , unsigned int curr_time_stamp_in_us ) { in_vrr -> flip_interval . vsync_to_flip_in_us = curr_time_stamp_in_us - in_vrr -> flip_interval . v_update_timestamp_in_us ; if ( in_vrr -> flip_interval . flip_interval_workaround_active && in_vrr -> flip_interval . vsyncs_between_flip ( VSYNCS_BETWEEN_FLIP_THRESHOLD && in_vrr -> flip_interval . vsync_to_flip_in_us ) FREESYNC_VSYNC_TO_FLIP_DELTA_IN_US ) { in_vrr -> flip_interval . program_flip_interval_workaround = true ; in_vrr -> flip_interval . flip_interval_workaround_active = false ; } else { if ( in_vrr -> flip_interval . vsyncs_between_flip >= VSYNCS_BETWEEN_FLIP_THRESHOLD && in_vrr -> flip_interval . vsync_to_flip_in_us < FREESYNC_VSYNC_TO_FLIP_DELTA_IN_US ) { in_vrr -> flip_interval . flip_interval_detect_counter ++ ; if ( in_vrr -> flip_interval . flip_interval_detect_counter > FREESYNC_CONSEC_FLIP_AFTER_VSYNC ) { in_vrr -> flip_interval . program_flip_interval_workaround = true ; in_vrr -> flip_interval . flip_interval_workaround_active = true ; } } else { in_vrr -> flip_interval . flip_interval_detect_counter = 0 ; } } in_vrr -> flip_interval . vsyncs_between_flip = 0 ; } 