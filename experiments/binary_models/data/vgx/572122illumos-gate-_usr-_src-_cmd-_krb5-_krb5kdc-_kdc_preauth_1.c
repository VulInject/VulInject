static krb5_error_code etype_info_helper ( krb5_context context , krb5_kdc_req * request , krb5_db_entry * client , krb5_db_entry * server , krb5_pa_data * pa_data , int etype_info2 ) { krb5_etype_info_entry * * entry = 0 ; krb5_key_data * client_key ; krb5_error_code retval ; krb5_data * scratch ; krb5_enctype db_etype ; int i = 0 ; int start = 0 ; int seen_des = 0 ; entry = malloc ( ( client -> n_key_data * 2 + 1 ) * sizeof ( krb5_etype_info_entry * ) ) ; if ( entry == NULL ) { return ENOMEM ; } entry [ 0 ] = NULL ; while ( 1 ) { retval = krb5_dbe_search_enctype ( context , client , & start , - 1 , - 1 , 0 , & client_key ) ; if ( retval == KRB5_KDB_NO_MATCHING_KEY ) { break ; } if ( retval ) { cleanup } db_etype = client_key -> key_data_type [ 0 ] ; if ( db_etype == ENCTYPE_DES_CBC_MD4 ) { db_etype = ENCTYPE_DES_CBC_MD5 ; } if ( request_contains_enctype ( context , request , db_etype ) ) { assert ( etype_info2 || ! enctype_requires_etype_info_2 ( db_etype ) ) ; if ( ( retval = _make_etype_info_entry ( context , request , client_key , db_etype , & entry [ i ] , etype_info2 ) ) != 0 ) { cleanup } entry [ i + 1 ] = 0 ; i ++ ; } if ( ! seen_des ) { switch ( db_etype ) { case ENCTYPE_DES_CBC_MD5 : db_etype = ENCTYPE_DES_CBC_CRC ; break ; case ENCTYPE_DES_CBC_CRC : db_etype = ENCTYPE_DES_CBC_MD5 ; break ; default : continue ; } if ( request_contains_enctype ( context , request , db_etype ) ) { if ( ( retval = _make_etype_info_entry ( context , request , client_key , db_etype , & entry [ i ] , etype_info2 ) ) != 0 ) { cleanup } entry [ i + 1 ] = 0 ; i ++ ; } seen_des ++ ; } } if ( etype_info2 ) { retval = encode_krb5_etype_info2 ( ( krb5_etype_info_entry * const * ) entry , & scratch ) ; } else { retval = encode_krb5_etype_info ( ( krb5_etype_info_entry * const * ) entry , & scratch ) ; } if ( retval ) { cleanup } pa_data -> contents = ( unsigned char * ) scratch -> data ; pa_data -> length = scratch -> length ; retval = 0 ; cleanup if ( entry ) { krb5_free_etype_info ( context , entry ) ; } return retval ; } 