__maybe_unused static void * dp_fill ( void * buf , struct udevice * dev ) { if ( ! dev || ! dev -> driver ) { return buf ; } switch ( device_get_uclass_id ( dev ) ) { case UCLASS_ROOT : case UCLASS_SIMPLE_BUS : { struct efi_device_path_vendor * vdp = buf ; * vdp = ROOT ; return & vdp [ 1 ] ; } case UCLASS_ETH : { struct efi_device_path_mac_addr * dp = dp_fill ( buf , dev -> parent ) ; struct eth_pdata * pdata = dev_get_plat ( dev ) ; dp -> dp . type = DEVICE_PATH_TYPE_MESSAGING_DEVICE ; dp -> dp . sub_type = DEVICE_PATH_SUB_TYPE_MSG_MAC_ADDR ; dp -> dp . length = sizeof ( * dp ) ; memcpy ( & dp -> mac , & pdata -> enetaddr , ARP_HLEN ) ; dp -> if_type = 1 ; return & dp [ 1 ] ; } case UCLASS_BLK : switch ( dev -> parent -> uclass -> uc_drv -> id ) { case UCLASS_HOST : { struct efi_device_path_vendor * dp ; struct blk_desc * desc = dev_get_uclass_plat ( dev ) ; dp_fill ( buf , dev -> parent ) ; dp = buf ; ++ dp ; dp -> dp . type = DEVICE_PATH_TYPE_HARDWARE_DEVICE ; dp -> dp . sub_type = DEVICE_PATH_SUB_TYPE_VENDOR ; dp -> dp . length = sizeof ( * dp ) + 1 ; memcpy ( & dp -> guid , & efi_guid_host_dev , sizeof ( efi_guid_t ) ) ; dp -> vendor_data [ 0 ] = desc -> devnum ; return & dp -> vendor_data [ 1 ] ; } case UCLASS_VIRTIO : { struct efi_device_path_vendor * dp ; struct blk_desc * desc = dev_get_uclass_plat ( dev ) ; dp_fill ( buf , dev -> parent ) ; dp = buf ; ++ dp ; dp -> dp . type = DEVICE_PATH_TYPE_HARDWARE_DEVICE ; dp -> dp . sub_type = DEVICE_PATH_SUB_TYPE_VENDOR ; dp -> dp . length = sizeof ( * dp ) + 1 ; memcpy ( & dp -> guid , & efi_guid_virtio_dev , sizeof ( efi_guid_t ) ) ; dp -> vendor_data [ 0 ] = desc -> devnum ; return & dp -> vendor_data [ 1 ] ; } case UCLASS_IDE : { struct efi_device_path_atapi * dp = dp_fill ( buf , dev -> parent ) ; struct blk_desc * desc = dev_get_uclass_plat ( dev ) ; dp -> dp . type = DEVICE_PATH_TYPE_MESSAGING_DEVICE ; dp -> dp . sub_type = DEVICE_PATH_SUB_TYPE_MSG_ATAPI ; dp -> dp . length = sizeof ( * dp ) ; dp -> logical_unit_number = desc -> devnum ; dp -> primary_secondary = IDE_BUS ( desc -> devnum ) ; dp -> slave_master = desc -> devnum % ( CONFIG_SYS_IDE_MAXDEVICE / CONFIG_SYS_IDE_MAXBUS ) ; return & dp [ 1 ] ; } case UCLASS_SCSI : { struct efi_device_path_scsi * dp = dp_fill ( buf , dev -> parent ) ; struct blk_desc * desc = dev_get_uclass_plat ( dev ) ; dp -> dp . type = DEVICE_PATH_TYPE_MESSAGING_DEVICE ; dp -> dp . sub_type = DEVICE_PATH_SUB_TYPE_MSG_SCSI ; dp -> dp . length = sizeof ( * dp ) ; dp -> logical_unit_number = desc -> lun ; dp -> target_id = desc -> target ; return & dp [ 1 ] ; } case UCLASS_MMC : { struct efi_device_path_sd_mmc_path * sddp = dp_fill ( buf , dev -> parent ) ; struct blk_desc * desc = dev_get_uclass_plat ( dev ) ; sddp -> dp . type = DEVICE_PATH_TYPE_MESSAGING_DEVICE ; sddp -> dp . sub_type = is_sd ( desc ) ?DEVICE_PATH_SUB_TYPE_MSG_SD : DEVICE_PATH_SUB_TYPE_MSG_MMC ; sddp -> dp . length = sizeof ( * sddp ) ; sddp -> slot_number = dev_seq ( dev ) ; return & sddp [ 1 ] ; } case UCLASS_AHCI : { struct efi_device_path_sata * dp = dp_fill ( buf , dev -> parent ) ; struct blk_desc * desc = dev_get_uclass_plat ( dev ) ; dp -> dp . type = DEVICE_PATH_TYPE_MESSAGING_DEVICE ; dp -> dp . sub_type = DEVICE_PATH_SUB_TYPE_MSG_SATA ; dp -> dp . length = sizeof ( * dp ) ; dp -> hba_port = desc -> devnum ; dp -> port_multiplier_port = 0xffff ; dp -> logical_unit_number = desc -> lun ; return & dp [ 1 ] ; } case UCLASS_NVME : { struct efi_device_path_nvme * dp = dp_fill ( buf , dev -> parent ) ; u32 ns_id ; dp -> dp . type = DEVICE_PATH_TYPE_MESSAGING_DEVICE ; dp -> dp . sub_type = DEVICE_PATH_SUB_TYPE_MSG_NVME ; dp -> dp . length = sizeof ( * dp ) ; nvme_get_namespace_id ( dev , & ns_id , dp -> eui64 ) ; memcpy ( & dp -> ns_id , & ns_id , sizeof ( ns_id ) ) ; return & dp [ 1 ] ; } default : debug ( "%s(%u) %s: unhandled parent class: %s (%u)\n" , __FILE__ , __LINE__ , __func__ , dev -> name , dev -> parent -> uclass -> uc_drv -> id ) ; return dp_fill ( buf , dev -> parent ) ; } case UCLASS_MMC : { struct efi_device_path_sd_mmc_path * sddp = dp_fill ( buf , dev -> parent ) ; struct mmc * mmc = mmc_get_mmc_dev ( dev ) ; struct blk_desc * desc = mmc_get_blk_desc ( mmc ) ; sddp -> dp . type = DEVICE_PATH_TYPE_MESSAGING_DEVICE ; sddp -> dp . sub_type = is_sd ( desc ) ?DEVICE_PATH_SUB_TYPE_MSG_SD : DEVICE_PATH_SUB_TYPE_MSG_MMC ; sddp -> dp . length = sizeof ( * sddp ) ; sddp -> slot_number = dev_seq ( dev ) ; return & sddp [ 1 ] ; } case UCLASS_MASS_STORAGE : case UCLASS_USB_HUB : { struct efi_device_path_usb_class * udp = dp_fill ( buf , dev -> parent ) ; struct usb_device * udev = dev_get_parent_priv ( dev ) ; struct usb_device_descriptor * desc = & udev -> descriptor ; udp -> dp . type = DEVICE_PATH_TYPE_MESSAGING_DEVICE ; udp -> dp . sub_type = DEVICE_PATH_SUB_TYPE_MSG_USB_CLASS ; udp -> dp . length = sizeof ( * udp ) ; udp -> vendor_id = desc -> idVendor ; udp -> product_id = desc -> idProduct ; udp -> device_class = desc -> bDeviceClass ; udp -> device_subclass = desc -> bDeviceSubClass ; udp -> device_protocol = desc -> bDeviceProtocol ; return & udp [ 1 ] ; } default : log_debug ( "unhandled device class: %s (%s)\n" , dev -> name , dev_get_uclass_name ( dev ) ) ; return dp_fill ( buf , dev -> parent ) ; } } 