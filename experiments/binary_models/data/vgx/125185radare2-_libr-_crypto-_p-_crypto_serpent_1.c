static bool update ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 ) { const int VAR6 = ( VAR7 - ( VAR5 % VAR7 ) ) % VAR7 ; const int VAR8 = VAR5 + VAR6 ; const int VAR9 = VAR8 / VAR7 ; int VAR10 , VAR11 ; VAR3 * const VAR12 = calloc ( 4 , VAR8 / 4 ) ; if ( ! VAR12 ) { return false ; } VAR13 * const VAR14 = calloc ( 4 , VAR8 / 4 ) ; if ( ! VAR14 ) { return false ; } VAR13 * const VAR15 = calloc ( 4 , VAR8 / 4 ) ; if ( ! VAR15 ) { free ( VAR12 ) ; free ( VAR14 ) ; return false ; } for ( VAR11 = 0 ; VAR11 < VAR5 / 4 ; VAR11 ++ ) { VAR14 [ VAR11 ] = FUN1 ( VAR4 + 4 * VAR11 ) ; } if ( VAR5 & 0x3 ) { ut8 VAR16 [ 4 ] { 0 } ; ; memcpy ( VAR16 , VAR4 + ( VAR5 & ~ 0x3 ) , VAR5 & 0x3 ) ; VAR14 [ VAR5 / 4 ] = FUN1 ( VAR16 ) ; } struct VAR17 * VAR18 = VAR2 -> VAR19 ; if ( ! VAR18 ) { FUN2 ( "" ) ; free ( VAR12 ) ; free ( VAR14 ) ; free ( VAR15 ) ; return false ; } if ( VAR2 -> VAR20 == 0 ) { for ( VAR10 = 0 ; VAR10 < VAR9 ; VAR10 ++ ) { const int VAR21 = ( VAR7 * VAR10 ) / 4 ; FUN3 ( VAR18 , VAR14 + VAR21 , VAR15 + VAR21 ) ; } } if ( VAR2 -> VAR20 > 0 ) { for ( VAR10 = 0 ; VAR10 < VAR9 ; VAR10 ++ ) { const int VAR21 = ( VAR7 * VAR10 ) / 4 ; FUN4 ( VAR18 , VAR14 + VAR21 , VAR15 + VAR21 ) ; } } int VAR22 ; for ( VAR11 = 0 ; VAR11 < VAR8 / 4 ; VAR11 ++ ) { VAR22 = 4 * VAR11 ; VAR12 [ VAR22 ] = VAR15 [ VAR11 ] & 0xff ; VAR12 [ VAR22 + 1 ] = ( VAR15 [ VAR11 ] >> 8 ) & 0xff ; VAR12 [ VAR22 + 2 ] = ( VAR15 [ VAR11 ] >> 16 ) & 0xff ; VAR12 [ VAR22 + 3 ] = ( VAR15 [ VAR11 ] >> 24 ) & 0xff ; } FUN5 ( VAR2 , VAR12 , VAR8 ) ; free ( VAR12 ) ; free ( VAR14 ) ; free ( VAR15 ) ; return true ; }