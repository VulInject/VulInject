static void CalculateWatermarksAndDRAMSpeedChangeSupport ( struct display_mode_lib * mode_lib , unsigned int PrefetchMode , double DCFCLK , double ReturnBW , double UrgentLatency , double ExtraLatency , double SOCCLK , double DCFCLKDeepSleep , unsigned int DETBufferSizeY [ ] , unsigned int DETBufferSizeC [ ] , unsigned int SwathHeightY [ ] , unsigned int SwathHeightC [ ] , double SwathWidthY [ ] , double SwathWidthC [ ] , unsigned int DPPPerPlane [ ] , double BytePerPixelDETY [ ] , double BytePerPixelDETC [ ] , bool UnboundedRequestEnabled , unsigned int CompressedBufferSizeInkByte , enum clock_change_support * DRAMClockChangeSupport , double * StutterExitWatermark , double * StutterEnterPlusExitWatermark , double * Z8StutterExitWatermark , double * Z8StutterEnterPlusExitWatermark ) { struct vba_vars_st * v = & mode_lib -> vba ; double EffectiveLBLatencyHidingY ; double EffectiveLBLatencyHidingC ; double LinesInDETY [ DC__NUM_DPP__MAX ] ; int LinesInDETC ; unsigned int LinesInDETYRoundedDownToSwath [ DC__NUM_DPP__MAX ] ; unsigned int LinesInDETCRoundedDownToSwath ; double FullDETBufferingTimeY ; double FullDETBufferingTimeC ; double ActiveDRAMClockChangeLatencyMarginY ; double ActiveDRAMClockChangeLatencyMarginC ; double WritebackDRAMClockChangeLatencyMargin ; double PlaneWithMinActiveDRAMClockChangeMargin ; double SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank ; double WritebackDRAMClockChangeLatencyHiding ; double TotalPixelBW = 0.0 ; int k , j ; v -> UrgentWatermark = UrgentLatency + ExtraLatency ; dml_print ( "DML::%s: UrgentLatency = %f\n" , __func__ , UrgentLatency ) ; dml_print ( "DML::%s: ExtraLatency = %f\n" , __func__ , ExtraLatency ) ; dml_print ( "DML::%s: UrgentWatermark = %f\n" , __func__ , v -> UrgentWatermark ) ; v -> DRAMClockChangeWatermark = v -> DRAMClockChangeLatency + v -> UrgentWatermark ; dml_print ( "DML::%s: v->DRAMClockChangeLatency = %f\n" , __func__ , v -> DRAMClockChangeLatency ) ; dml_print ( "DML::%s: DRAMClockChangeWatermark = %f\n" , __func__ , v -> DRAMClockChangeWatermark ) ; v -> TotalActiveWriteback = 0 ; for ( k = 0 ; k < v -> NumberOfActivePlanes ; ++ k ) { if ( v -> WritebackEnable [ k ] == true ) { v -> TotalActiveWriteback = v -> TotalActiveWriteback + 1 ; } } if ( v -> TotalActiveWriteback <= 1 ) { v -> WritebackUrgentWatermark = v -> WritebackLatency ; } else { v -> WritebackUrgentWatermark = v -> WritebackLatency + v -> WritebackChunkSize * 1024.0 / 32.0 / SOCCLK ; } if ( v -> TotalActiveWriteback <= 1 ) { v -> WritebackDRAMClockChangeWatermark = v -> DRAMClockChangeLatency + v -> WritebackLatency ; } else { v -> WritebackDRAMClockChangeWatermark = v -> DRAMClockChangeLatency + v -> WritebackLatency + v -> WritebackChunkSize * 1024.0 / 32.0 / SOCCLK ; } for ( k = 0 ; k < v -> NumberOfActivePlanes ; ++ k ) { TotalPixelBW = TotalPixelBW + DPPPerPlane [ k ] * ( SwathWidthY [ k ] * BytePerPixelDETY [ k ] * v -> VRatio [ k ] + SwathWidthC [ k ] * BytePerPixelDETC [ k ] * v -> VRatioChroma [ k ] ) / ( v -> HTotal [ k ] / v -> PixelClock [ k ] ) ; } for ( k = 0 ; k < v -> NumberOfActivePlanes ; ++ k ) { double EffectiveDETBufferSizeY = DETBufferSizeY [ k ] ; v -> LBLatencyHidingSourceLinesY = dml_min ( ( double ) v -> MaxLineBufferLines , dml_floor ( v -> LineBufferSize / v -> LBBitPerPixel [ k ] / ( SwathWidthY [ k ] / dml_max ( v -> HRatio [ k ] , 1.0 ) ) , 1 ) ) - ( v -> vtaps [ k ] - 1 ) ; v -> LBLatencyHidingSourceLinesC = dml_min ( ( double ) v -> MaxLineBufferLines , dml_floor ( v -> LineBufferSize / v -> LBBitPerPixel [ k ] / ( SwathWidthC [ k ] / dml_max ( v -> HRatioChroma [ k ] , 1.0 ) ) , 1 ) ) - ( v -> VTAPsChroma [ k ] - 1 ) ; EffectiveLBLatencyHidingY = v -> LBLatencyHidingSourceLinesY / v -> VRatio [ k ] * ( v -> HTotal [ k ] / v -> PixelClock [ k ] ) ; EffectiveLBLatencyHidingC = v -> LBLatencyHidingSourceLinesC / v -> VRatioChroma [ k ] * ( v -> HTotal [ k ] / v -> PixelClock [ k ] ) ; if ( UnboundedRequestEnabled ) { EffectiveDETBufferSizeY = EffectiveDETBufferSizeY + CompressedBufferSizeInkByte * 1024 * SwathWidthY [ k ] * BytePerPixelDETY [ k ] * v -> VRatio [ k ] / ( v -> HTotal [ k ] / v -> PixelClock [ k ] ) / TotalPixelBW ; } LinesInDETY [ k ] = ( double ) EffectiveDETBufferSizeY / BytePerPixelDETY [ k ] / SwathWidthY [ k ] ; LinesInDETYRoundedDownToSwath [ k ] = dml_floor ( LinesInDETY [ k ] , SwathHeightY [ k ] ) ; FullDETBufferingTimeY = LinesInDETYRoundedDownToSwath [ k ] * ( v -> HTotal [ k ] / v -> PixelClock [ k ] ) / v -> VRatio [ k ] ; if ( BytePerPixelDETC [ k ] > 0 ) { LinesInDETC = v -> DETBufferSizeC [ k ] / BytePerPixelDETC [ k ] / SwathWidthC [ k ] ; LinesInDETCRoundedDownToSwath = dml_floor ( LinesInDETC , SwathHeightC [ k ] ) ; FullDETBufferingTimeC = LinesInDETCRoundedDownToSwath * ( v -> HTotal [ k ] / v -> PixelClock [ k ] ) / v -> VRatioChroma [ k ] ; } else { LinesInDETC = 0 ; FullDETBufferingTimeC = 999999 ; } ActiveDRAMClockChangeLatencyMarginY = EffectiveLBLatencyHidingY + FullDETBufferingTimeY - ( ( double ) v -> DSTXAfterScaler [ k ] / v -> HTotal [ k ] + v -> DSTYAfterScaler [ k ] ) * v -> HTotal [ k ] / v -> PixelClock [ k ] - v -> UrgentWatermark - v -> DRAMClockChangeWatermark ; if ( v -> NumberOfActivePlanes > 1 ) { ActiveDRAMClockChangeLatencyMarginY = ActiveDRAMClockChangeLatencyMarginY - ( 1 - 1.0 / v -> NumberOfActivePlanes ) * SwathHeightY [ k ] * v -> HTotal [ k ] / v -> PixelClock [ k ] / v -> VRatio [ k ] ; } if ( BytePerPixelDETC [ k ] > 0 ) { ActiveDRAMClockChangeLatencyMarginC = EffectiveLBLatencyHidingC + FullDETBufferingTimeC - ( ( double ) v -> DSTXAfterScaler [ k ] / v -> HTotal [ k ] + v -> DSTYAfterScaler [ k ] ) * v -> HTotal [ k ] / v -> PixelClock [ k ] - v -> UrgentWatermark - v -> DRAMClockChangeWatermark ; if ( v -> NumberOfActivePlanes > 1 ) { ActiveDRAMClockChangeLatencyMarginC = ActiveDRAMClockChangeLatencyMarginC - ( 1 - 1.0 / v -> NumberOfActivePlanes ) * SwathHeightC [ k ] * v -> HTotal [ k ] / v -> PixelClock [ k ] / v -> VRatioChroma [ k ] ; } v -> ActiveDRAMClockChangeLatencyMargin [ k ] = dml_min ( ActiveDRAMClockChangeLatencyMarginY , ActiveDRAMClockChangeLatencyMarginC ) ; } else { v -> ActiveDRAMClockChangeLatencyMargin [ k ] = ActiveDRAMClockChangeLatencyMarginY ; } if ( v -> WritebackEnable [ k ] == true ) { WritebackDRAMClockChangeLatencyHiding = v -> WritebackInterfaceBufferSize * 1024 / ( v -> WritebackDestinationWidth [ k ] * v -> WritebackDestinationHeight [ k ] / ( v -> WritebackSourceHeight [ k ] * v -> HTotal [ k ] / v -> PixelClock [ k ] ) * 4 ) ; if ( v -> WritebackPixelFormat [ k ] == dm_444_64 ) { WritebackDRAMClockChangeLatencyHiding = WritebackDRAMClockChangeLatencyHiding / 2 ; } WritebackDRAMClockChangeLatencyMargin = WritebackDRAMClockChangeLatencyHiding - v -> WritebackDRAMClockChangeWatermark ; v -> ActiveDRAMClockChangeLatencyMargin [ k ] = dml_min ( v -> ActiveDRAMClockChangeLatencyMargin [ k ] , WritebackDRAMClockChangeLatencyMargin ) ; } } v -> MinActiveDRAMClockChangeMargin = 999999 ; PlaneWithMinActiveDRAMClockChangeMargin = 0 ; for ( k = 0 ; k < v -> NumberOfActivePlanes ; ++ k ) { if ( v -> ActiveDRAMClockChangeLatencyMargin [ k ] < v -> MinActiveDRAMClockChangeMargin ) { v -> MinActiveDRAMClockChangeMargin = v -> ActiveDRAMClockChangeLatencyMargin [ k ] ; if ( v -> BlendingAndTiming [ k ] == k ) { PlaneWithMinActiveDRAMClockChangeMargin = k ; } else { for ( j = 0 ; j < v -> NumberOfActivePlanes ; ++ j ) { if ( v -> BlendingAndTiming [ k ] == j ) { PlaneWithMinActiveDRAMClockChangeMargin = j ; } } } } } v -> MinActiveDRAMClockChangeLatencySupported = v -> MinActiveDRAMClockChangeMargin + v -> DRAMClockChangeLatency ; SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 999999 ; for ( k = 0 ; k < v -> NumberOfActivePlanes ; ++ k ) { if ( ! ( ( k == PlaneWithMinActiveDRAMClockChangeMargin ) && ( v -> BlendingAndTiming [ k ] == k ) ) && ! ( v -> BlendingAndTiming [ k ] == PlaneWithMinActiveDRAMClockChangeMargin ) && v -> ActiveDRAMClockChangeLatencyMargin [ k ] < SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank ) { SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = v -> ActiveDRAMClockChangeLatencyMargin [ k ] ; } } v -> TotalNumberOfActiveOTG = 0 ; for ( k = 0 ; k < v -> NumberOfActivePlanes ; ++ k ) { if ( v -> BlendingAndTiming [ k ] == k ) { v -> TotalNumberOfActiveOTG = v -> TotalNumberOfActiveOTG + 1 ; } } if ( v -> MinActiveDRAMClockChangeMargin > 0 && PrefetchMode == 0 ) { * DRAMClockChangeSupport = dm_dram_clock_change_vactive ; } if ( ( v -> SynchronizedVBlank == true || v -> TotalNumberOfActiveOTG == 1 || SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank > 0 ) && PrefetchMode == 0 ) { * DRAMClockChangeSupport = dm_dram_clock_change_vblank ; } else { * DRAMClockChangeSupport = dm_dram_clock_change_unsupported ; } * StutterExitWatermark = v -> SRExitTime + ExtraLatency + 10 / DCFCLKDeepSleep ; * StutterEnterPlusExitWatermark = ( v -> SREnterPlusExitTime + ExtraLatency + 10 / DCFCLKDeepSleep ) ; * Z8StutterExitWatermark = v -> SRExitZ8Time + ExtraLatency + 10 / DCFCLKDeepSleep ; * Z8StutterEnterPlusExitWatermark = v -> SREnterPlusExitZ8Time + ExtraLatency + 10 / DCFCLKDeepSleep ; dml_print ( "DML::%s: StutterExitWatermark = %f\n" , __func__ , * StutterExitWatermark ) ; dml_print ( "DML::%s: StutterEnterPlusExitWatermark = %f\n" , __func__ , * StutterEnterPlusExitWatermark ) ; dml_print ( "DML::%s: Z8StutterExitWatermark = %f\n" , __func__ , * Z8StutterExitWatermark ) ; dml_print ( "DML::%s: Z8StutterEnterPlusExitWatermark = %f\n" , __func__ , * Z8StutterEnterPlusExitWatermark ) ; } 