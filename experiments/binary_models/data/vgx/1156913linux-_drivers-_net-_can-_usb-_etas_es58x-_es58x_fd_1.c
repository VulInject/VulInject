static int es58x_fd_enable_channel ( struct es58x_priv * priv ) { struct es58x_device * es58x_dev = priv -> es58x_dev ; struct net_device * netdev = es58x_dev -> netdev [ priv -> channel_idx ] ; struct es58x_fd_tx_conf_msg tx_conf_msg = { 0 } ; u32 ctrlmode ; int conf_len = 0 ; es58x_fd_convert_bittiming ( & tx_conf_msg . nominal_bittiming , & priv -> can . bittiming ) ; ctrlmode = priv -> can . ctrlmode ; if ( ctrlmode & CAN_CTRLMODE_3_SAMPLES ) { tx_conf_msg . samples_per_bit = ES58X_SAMPLES_PER_BIT_THREE ; } else { tx_conf_msg . samples_per_bit = ES58X_SAMPLES_PER_BIT_ONE ; } tx_conf_msg . sync_edge = ES58X_SYNC_EDGE_SINGLE ; tx_conf_msg . physical_layer = ES58X_PHYSICAL_LAYER_HIGH_SPEED ; tx_conf_msg . echo_mode = ES58X_ECHO_ON ; if ( ctrlmode & CAN_CTRLMODE_LISTENONLY ) { tx_conf_msg . ctrlmode |= ES58X_FD_CTRLMODE_PASSIVE ; } else { tx_conf_msg . ctrlmode |= ES58X_FD_CTRLMODE_ACTIVE ; } if ( ctrlmode & CAN_CTRLMODE_FD_NON_ISO ) { tx_conf_msg . ctrlmode |= ES58X_FD_CTRLMODE_FD_NON_ISO ; tx_conf_msg . canfd_enabled = 1 ; } if ( ctrlmode & CAN_CTRLMODE_FD ) { tx_conf_msg . ctrlmode |= ES58X_FD_CTRLMODE_FD ; tx_conf_msg . canfd_enabled = 1 ; } if ( tx_conf_msg . canfd_enabled ) { es58x_fd_convert_bittiming ( & tx_conf_msg . data_bittiming , & priv -> can . data_bittiming ) ; if ( can_tdc_is_enabled ( & priv -> can ) ) { tx_conf_msg . tdc_enabled = 1 ; tx_conf_msg . tdco = cpu_to_le16 ( priv -> can . tdc . tdco ) ; tx_conf_msg . tdcf = cpu_to_le16 ( priv -> can . tdc . tdcf ) ; } conf_len = ES58X_FD_CANFD_CONF_LEN ; } else { conf_len = ES58X_FD_CAN_CONF_LEN ; } return es58x_send_msg ( es58x_dev , es58x_fd_cmd_type ( netdev ) , ES58X_FD_CAN_CMD_ID_ENABLE_CHANNEL , & tx_conf_msg , conf_len , priv -> channel_idx ) ; } 