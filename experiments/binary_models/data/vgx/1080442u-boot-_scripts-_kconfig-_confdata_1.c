int conf_read ( const char * name ) { struct symbol * sym ; int conf_unsaved = 0 ; int i ; sym_set_change_count ( 0 ) ; if ( conf_read_simple ( name , S_DEF_USER ) ) { sym_calc_value ( modules_sym , NULL ) ; return 1 ; } sym_calc_value ( modules_sym ) ; for_all_symbols ( , ) { sym_calc_value ( sym ) ; if ( sym_is_choice ( sym ) || ( sym -> flags & SYMBOL_NO_WRITE ) ) { continue ; } if ( sym_has_value ( sym ) && ( sym -> flags & SYMBOL_WRITE ) ) { switch ( sym -> type ) { case S_BOOLEAN : case S_TRISTATE : if ( sym -> def [ S_DEF_USER ] . tri != sym_get_tristate_value ( sym ) ) { break ; } if ( ! sym_is_choice ( sym ) ) { continue ; } default : if ( ! strcmp ( sym -> curr . val , sym -> def [ S_DEF_USER ] . val ) ) { continue ; } break ; } } if ( ! sym_has_value ( sym ) && ! ( sym -> flags & SYMBOL_WRITE ) ) { continue ; } conf_unsaved ++ ; } for_all_symbols ( , ) { if ( sym_has_value ( sym ) && ! sym_is_choice_value ( sym ) ) { if ( sym -> visible == no && ! conf_unsaved ) { sym -> flags &= ~ SYMBOL_DEF_USER ; } switch ( sym -> type ) { case S_STRING : case S_INT : case S_HEX : if ( sym_string_within_range ( sym , sym -> def [ S_DEF_USER ] . val ) ) { break ; } sym -> flags &= ~ ( SYMBOL_VALID | SYMBOL_DEF_USER ) ; conf_unsaved ++ ; break ; default : break ; } } } sym_add_change_count ( conf_warnings || conf_unsaved ) ; return 0 ; } 