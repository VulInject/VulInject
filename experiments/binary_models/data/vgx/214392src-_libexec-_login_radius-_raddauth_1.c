void rad_request ( u_char id , char * name , char * password , int port , char * vector , char * state ) { auth_hdr_t auth ; int i , len , secretlen , total_length , p ; struct sockaddr_in sin ; u_char md5buf [ MAXSECRETLEN + AUTH_VECTOR_LEN ] , digest [ AUTH_VECTOR_LEN ] , pass_buf [ AUTH_PASS_LEN ] , * pw , * ptr ; u_int length ; in_addr_t ipaddr ; MD5_CTX context ; memset ( & auth , 0 , sizeof ( auth ) ) ; auth . code = PW_AUTHENTICATION_REQUEST ; auth . id = id ; memcpy ( auth . vector , vector , AUTH_VECTOR_LEN ) ; total_length = AUTH_HDR_LEN ; ptr = auth . data ; * ptr ++ = PW_USER_NAME ; length = strlen ( name ) ; if ( length > MAXPWNETNAM ) { length = MAXPWNETNAM ; } * ptr ++ = length + 2 ; memcpy ( ptr , name , length ) ; ptr += length ; total_length += length + 2 ; length = strlen ( password ) ; if ( length > AUTH_PASS_LEN ) { length = AUTH_PASS_LEN ; } p = ( length + AUTH_VECTOR_LEN - 1 ) / AUTH_VECTOR_LEN ; * ptr ++ = PW_PASSWORD ; * ptr ++ = p * AUTH_VECTOR_LEN + 2 ; strlcpy ( ( char * ) pass_buf , password , sizeof ( pass_buf ) ) ; secretlen = strlen ( auth_secret ) ; memcpy ( md5buf , auth_secret , secretlen ) ; memcpy ( md5buf + secretlen , auth . vector , AUTH_VECTOR_LEN ) ; total_length += 2 ; pw = pass_buf ; while ( p -- > 0 ) { MD5Init ( & context ) ; MD5Update ( & context , md5buf , secretlen + AUTH_VECTOR_LEN ) ; MD5Final ( digest , & context ) ; for ( i = 0 ; i < AUTH_VECTOR_LEN ; ++ i ) { * ptr = digest [ i ] ^ * pw ; md5buf [ secretlen + i ] = * ptr ++ ; * pw ++ = '\0' ; } total_length += AUTH_VECTOR_LEN ; } explicit_bzero ( pass_buf , strlen ( pass_buf ) ) ; * ptr ++ = PW_CLIENT_ID ; * ptr ++ = sizeof ( in_addr_t ) + 2 ; ipaddr = gethost ( ) ; memcpy ( ptr , & ipaddr , sizeof ( in_addr_t ) ) ; ptr += sizeof ( in_addr_t ) ; total_length += sizeof ( in_addr_t ) + 2 ; * ptr ++ = PW_CLIENT_PORT_ID ; * ptr ++ = sizeof ( in_addr_t ) + 2 ; port = htonl ( port ) ; memcpy ( ptr , & port , sizeof ( int ) ) ; ptr += sizeof ( int ) ; total_length += sizeof ( int ) + 2 ; if ( ( state != NULL ) && ( strlen ( state ) > 0 ) ) { len = strlen ( state ) ; * ptr ++ = PW_STATE ; * ptr ++ = len + 2 ; memcpy ( ptr , state , len ) ; ptr += len ; total_length += len + 2 ; } auth . length = htons ( total_length ) ; memset ( & sin , 0 , sizeof ( sin ) ) ; sin . sin_family = AF_INET ; sin . sin_addr . s_addr = auth_server ; sin . sin_port = radius_port ; if ( sendto ( sockfd , & auth , total_length , 0 , ( sockaddr * ) & sin , sizeof ( sin ) ) == - 1 ) { err ( 1 , NULL ) ; } } 