R_API void r_core_link_stroff ( RCore * core , RAnalFunction * fcn ) { RAnalBlock * bb ; RListIter * it ; RAnalOp aop = { 0 } ; bool ioCache = r_config_get_b ( core -> config , "io.cache" ) ; bool stack_set = false ; bool resolved = false ; const char * varpfx ; int dbg_follow = r_config_get_i ( core -> config , "dbg.follow" ) ; Sdb * TDB = core -> anal -> sdb_types ; REsil * esil ; int iotrap = r_config_get_i ( core -> config , "esil.iotrap" ) ; int stacksize = r_config_get_i ( core -> config , "esil.stack.depth" ) ; unsigned int addrsize = r_config_get_i ( core -> config , "esil.addr.size" ) ; const char * pc_name = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; const char * sp_name = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_SP ) ; RRegItem * pc = r_reg_get ( core -> anal -> reg , pc_name , - 1 ) ; if ( ! fcn ) { return ; } if ( ! ( esil = r_esil_new ( stacksize , iotrap , addrsize ) ) ) { return ; } r_esil_setup ( esil , core -> anal , 0 , 0 , 0 ) ; int i , ret , bsize = R_MAX ( 64 , core -> blocksize ) ; const int mininstrsz = r_anal_archinfo ( core -> anal , R_ANAL_ARCHINFO_MIN_OP_SIZE ) ; const int maxinstrsz = r_anal_archinfo ( core -> anal , R_ANAL_ARCHINFO_MAX_OP_SIZE ) ; const int minopcode = R_MAX ( 1 , mininstrsz ) ; ut8 * buf = malloc ( bsize ) ; if ( ! buf ) { r_esil_free ( esil ) ; return ; } r_reg_arena_push ( core -> anal -> reg ) ; r_debug_reg_sync ( core -> dbg , R_REG_TYPE_ALL , true ) ; ut64 spval = r_reg_getv ( esil -> anal -> reg , sp_name ) ; if ( spval ) { RRegItem * sp = r_reg_get ( esil -> anal -> reg , sp_name , - 1 ) ; ut64 curpc = r_reg_getv ( esil -> anal -> reg , pc_name ) ; int stacksz = r_core_get_stacksz ( core , fcn -> addr , curpc ) ; if ( stacksz > 0 ) { r_reg_arena_zero ( esil -> anal -> reg ) ; r_reg_set_value ( esil -> anal -> reg , sp , spval + stacksz ) ; } } else { r_core_cmd0 ( core , "aeim" ) ; stack_set = true ; } r_config_set_b ( core -> config , "io.cache" , true ) ; r_config_set_i ( core -> config , "dbg.follow" , 0 ) ; ut64 oldoff = core -> offset ; r_cons_break_push ( NULL , NULL ) ; r_list_sort ( fcn -> bbs , bb_cmpaddr ) ; r_list_foreach ( , , ) { ut64 at = bb -> addr ; ut64 to = bb -> addr + bb -> size ; r_reg_set_value ( esil -> anal -> reg , pc , at ) ; for ( i = 0 ; at < to ; i ++ ) { if ( r_cons_is_breaked ( ) ) { beach } if ( at < bb -> addr ) { break ; } if ( i >= ( bsize - maxinstrsz ) ) { i = 0 ; } if ( ! i ) { r_io_read_at ( core -> io , at , buf , bsize ) ; } ret = r_anal_op ( core -> anal , & aop , at , buf + i , bsize - i , R_ARCH_OP_MASK_VAL ) ; if ( ret <= 0 ) { i += minopcode ; at += minopcode ; r_anal_op_fini ( & aop ) ; continue ; } i += ret - 1 ; at += ret ; int index = 0 ; if ( aop . ireg ) { index = r_reg_getv ( esil -> anal -> reg , aop . ireg ) * aop . scale ; } int src_imm = - 1 , dst_imm = - 1 ; ut64 src_addr = UT64_MAX ; ut64 dst_addr = UT64_MAX ; RAnalValue * src = NULL ; r_vector_foreach ( , ) { if ( src && src -> reg && src -> reg -> name ) { src_addr = r_reg_getv ( esil -> anal -> reg , src -> reg -> name ) + index ; src_imm = src -> delta ; } } RAnalValue * dst = r_vector_at ( & aop . dsts , 0 ) ; if ( dst && dst -> reg && dst -> reg -> name ) { dst_addr = r_reg_getv ( esil -> anal -> reg , dst -> reg -> name ) + index ; dst_imm = dst -> delta ; } RAnalVar * var = r_anal_get_used_function_var ( core -> anal , aop . addr ) ; if ( false ) { r_anal_op_fini ( & aop ) ; continue ; } char * slink = r_type_link_at ( TDB , src_addr ) ; char * vlink = r_type_link_at ( TDB , src_addr + src_imm ) ; char * dlink = r_type_link_at ( TDB , dst_addr ) ; if ( vlink && var && var -> kind != 'r' ) { if ( r_type_kind ( TDB , vlink ) == R_TYPE_UNION ) { varpfx = "union" ; } else { varpfx = "struct" ; } if ( strcmp ( var -> name , vlink ) && ! resolved ) { resolved = true ; r_anal_var_set_type ( var , varpfx ) ; r_anal_var_rename ( var , vlink , false ) ; } } if ( slink ) { set_offset_hint ( core , & aop , slink , src_addr , at - ret , src_imm ) ; } if ( dlink ) { set_offset_hint ( core , & aop , dlink , dst_addr , at - ret , dst_imm ) ; } if ( r_anal_op_nonlinear ( aop . type ) ) { r_reg_set_value ( esil -> anal -> reg , pc , at ) ; set_retval ( core , at - ret ) ; } else { r_core_esil_step ( core , UT64_MAX , NULL , NULL , false ) ; } free ( dlink ) ; free ( vlink ) ; free ( slink ) ; r_anal_op_fini ( & aop ) ; } } beach r_core_cmd0 ( core , "wc-*" ) ; r_config_set_b ( core -> config , "io.cache" , ioCache ) ; r_config_set_i ( core -> config , "dbg.follow" , dbg_follow ) ; if ( stack_set ) { r_core_cmd0 ( core , "aeim-" ) ; } r_core_seek ( core , oldoff , true ) ; r_esil_free ( esil ) ; r_reg_arena_pop ( core -> anal -> reg ) ; r_core_cmd0 ( core , ".ar*" ) ; r_cons_break_pop ( ) ; free ( buf ) ; } 