static int prn_writefile ( FILE * ) static int prn_puts ( const char * ) static ssize_t prn_read ( char * , size_t ) static struct lp_printer * lp ; static struct prnstate * prn ; void printer ( int debug , int verbose , const char * name ) { struct sigaction sa ; struct passwd * pw ; struct lp_queue q ; int fd , jobidx , qstate , r , reload , retry ; char buf [ 64 ] , curr [ 1024 ] ; log_init ( debug , LOG_LPR ) ; log_setverbose ( verbose ) ; snprintf ( buf , sizeof ( buf ) , "printer:%s" , name ) ; log_procinit ( buf ) ; setproctitle ( "%s" , buf ) ; if ( ( lpd_hostname = malloc ( HOST_NAME_MAX + 1 ) ) == NULL ) { fatal ( "%s: malloc" , __func__ ) ; } gethostname ( lpd_hostname , HOST_NAME_MAX + 1 ) ; if ( ! debug ) { if ( setsid ( ) == - 1 ) { fatal ( "%s: setsid" , __func__ ) ; } } if ( ( lp = calloc ( 1 , sizeof ( * lp ) ) ) == NULL ) { fatal ( "%s: calloc" , __func__ ) ; } if ( lp_getprinter ( lp , name ) == - 1 ) { exit ( 1 ) ; } if ( ! debug ) { fd = open ( LP_LF ( lp ) , O_WRONLY | O_APPEND ) ; if ( fd == - 1 ) { fatal ( "%s: open: %s" , __func__ , LP_LF ( lp ) ) ; } if ( fd != STDERR_FILENO ) { if ( dup2 ( fd , STDERR_FILENO ) == - 1 ) { fatalx ( "%s: dup2" , __func__ ) ; } ( void ) close ( fd ) ; } } if ( ( pw = getpwnam ( LPD_USER ) ) == NULL ) { fatalx ( "unknown user " LPD_USER ) ; } if ( setgroups ( 1 , & pw -> pw_gid ) || setresgid ( pw -> pw_gid , pw -> pw_gid , pw -> pw_gid ) || setresuid ( pw -> pw_uid , pw -> pw_uid , pw -> pw_uid ) ) { fatal ( "cannot drop privileges" ) ; } if ( ( prn = calloc ( 1 , sizeof ( * prn ) ) ) == NULL ) { fatal ( "%s: calloc" , __func__ ) ; } prn -> pfd = - 1 ; prn -> ofd = - 1 ; sa . sa_handler = sighandler ; sa . sa_flags = SA_RESTART ; sigemptyset ( & sa . sa_mask ) ; sigaddset ( & sa . sa_mask , SIGINT ) ; sigaction ( SIGHUP , & sa , NULL ) ; sigaction ( SIGINT , & sa , NULL ) ; sigaction ( SIGQUIT , & sa , NULL ) ; sigaction ( SIGTERM , & sa , NULL ) ; if ( lp_lock ( lp ) == - 1 ) { if ( errno == EWOULDBLOCK ) { log_debug ( "already locked" ) ; exit ( 0 ) ; } fatalx ( "cannot open lock file" ) ; } switch ( lp -> lp_type ) { case PRN_LOCAL : pledge ( "stdio rpath wpath cpath flock getpw tty proc exec" , NULL ) ; break ; case PRN_NET : pledge ( "stdio rpath wpath cpath inet flock dns getpw proc exec" , NULL ) ; break ; case PRN_LPR : pledge ( "stdio rpath wpath cpath inet flock dns getpw" , NULL ) ; break ; } memset ( & q , 0 , sizeof ( q ) ) ; jobidx = 0 ; reload = 1 ; retry = 0 ; curr [ 0 ] = '\0' ; for ( ; ; ) { if ( lp_getqueuestate ( lp , 1 , & qstate ) == - 1 ) { fatalx ( "cannot get queue state" ) ; } if ( qstate & LPQ_PRINTER_DOWN ) { log_debug ( "printing disabled" ) ; break ; } if ( qstate & LPQ_QUEUE_UPDATED ) { log_debug ( "queue updated" ) ; if ( reload == 0 ) { lp_clearqueue ( & q ) ; } reload = 1 ; } if ( reload || q . count == 0 ) { if ( lp_readqueue ( lp , & q ) == - 1 ) { fatalx ( "cannot read queue" ) ; } jobidx = 0 ; reload = 0 ; } if ( q . count <= jobidx ) { log_debug ( "queue empty" ) ; break ; } if ( prn -> pfd == - 1 ) { prn_open ( ) ; lp_clearqueue ( & q ) ; reload = 1 ; continue ; } if ( strcmp ( curr , q . cfname [ jobidx ] ) ) { retry = 0 ; } else { strlcpy ( curr , q . cfname [ jobidx ] , sizeof ( curr ) ) ; } lp_setcurrtask ( lp , q . cfname [ jobidx ] ) ; if ( lp -> lp_type == PRN_LPR ) { r = sendjob ( q . cfname [ jobidx ] , retry ) ; } else { r = printjob ( q . cfname [ jobidx ] , retry ) ; } lp_setcurrtask ( lp , NULL ) ; switch ( r ) { case JOB_OK : log_info ( "job %s %s successfully" , q . cfname [ jobidx ] , ( lp -> lp_type == PRN_LPR ) ?"relayed" : "printed" ) ; break ; case JOB_AGAIN : retry ++ ; continue ; case JOB_IGNORE : break ; case JOB_ERROR : log_warnx ( "job %s could not be printed" , q . cfname [ jobidx ] ) ; break ; } curr [ 0 ] = '\0' ; jobidx ++ ; retry = 0 ; } if ( prn -> pfd != - 1 ) { if ( prn -> count ) { prn_formfeed ( ) ; if ( lp -> lp_tr ) { prn_puts ( lp -> lp_tr ) ; } } prn_close ( ) ; } exit ( 0 ) ; } 