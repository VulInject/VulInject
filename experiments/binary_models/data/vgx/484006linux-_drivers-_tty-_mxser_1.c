static int mxser_activate ( struct tty_port * port , struct tty_struct * tty ) { struct mxser_port * info = container_of ( port , mxser_port , port ) ; unsigned long flags ; int ret ; ret = tty_port_alloc_xmit_buf ( port ) ; spin_lock_irqsave ( & info -> slock , flags ) ; if ( ! info -> type ) { set_bit ( TTY_IO_ERROR , & tty -> flags ) ; spin_unlock_irqrestore ( & info -> slock , flags ) ; ret = 0 ; err_free_xmit } mxser_disable_and_clear_FIFO ( info ) ; if ( inb ( info -> ioaddr + UART_LSR ) == 0xff ) { spin_unlock_irqrestore ( & info -> slock , flags ) ; if ( capable ( CAP_SYS_ADMIN ) ) { set_bit ( TTY_IO_ERROR , & tty -> flags ) ; return 0 ; } ret = - ENODEV ; err_free_xmit } ( void ) inb ( info -> ioaddr + UART_LSR ) ; ( void ) inb ( info -> ioaddr + UART_RX ) ; ( void ) inb ( info -> ioaddr + UART_IIR ) ; ( void ) inb ( info -> ioaddr + UART_MSR ) ; outb ( UART_LCR_WLEN8 , info -> ioaddr + UART_LCR ) ; info -> MCR = UART_MCR_DTR | UART_MCR_RTS ; outb ( info -> MCR , info -> ioaddr + UART_MCR ) ; info -> IER = UART_IER_MSI | UART_IER_RLSI | UART_IER_RDI ; if ( info -> board -> must_hwid ) { info -> IER |= MOXA_MUST_IER_EGDAI ; } outb ( info -> IER , info -> ioaddr + UART_IER ) ; ( void ) inb ( info -> ioaddr + UART_LSR ) ; ( void ) inb ( info -> ioaddr + UART_RX ) ; ( void ) inb ( info -> ioaddr + UART_IIR ) ; ( void ) inb ( info -> ioaddr + UART_MSR ) ; clear_bit ( TTY_IO_ERROR , & tty -> flags ) ; kfifo_reset ( & port -> xmit_fifo ) ; mxser_change_speed ( tty , NULL ) ; spin_unlock_irqrestore ( & info -> slock , flags ) ; return 0 ; err_free_xmit tty_port_free_xmit_buf ( port ) ; return ret ; } 