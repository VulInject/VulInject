void * octcib_establish ( void * cookie , int node , int idx , int level , int * func ( void * ) , void * arg , const char * name ) { struct octcib_intrhand * cih ; struct octcib_softc * sc = cookie ; uint64_t en ; uint32_t * cells ; uint32_t bit , type ; int flags , len , s ; flags = ( level & IPL_MPSAFE ) ?CIH_MPSAFE : 0 ; level &= ~ IPL_MPSAFE ; if ( level > CIB_HIGHIPL ) { return in ; } len = OF_getproplen ( node , "interrupts" ) ; if ( len / ( sizeof ( uint32_t ) * 2 ) <= idx || len % ( sizeof ( uint32_t ) * 2 ) != 0 ) { return NULL ; } cells = malloc ( len , M_TEMP , M_NOWAIT ) ; if ( cells == NULL ) { return NULL ; } OF_getpropintarray ( node , "interrupts" , cells , len ) ; bit = cells [ idx * 2 ] ; type = cells [ idx * 2 + 1 ] ; free ( cells , M_TEMP , len ) ; if ( bit >= sc -> sc_maxbits ) { return NULL ; } if ( type != 4 ) { flags |= CIH_EDGE ; } cih = malloc ( sizeof ( * cih ) , M_DEVBUF , M_NOWAIT ) ; if ( cih == NULL ) { return NULL ; } cih -> cih_func = func ; cih -> cih_arg = arg ; cih -> cih_bit = bit ; cih -> cih_flags = flags ; cih -> cih_irq = CIB_IRQNUM ( sc , bit ) ; cih -> cih_sc = sc ; s = splhigh ( ) ; evcount_attach ( & cih -> cih_count , name , & cih -> cih_irq ) ; LIST_INSERT_HEAD ( & sc -> sc_bits [ bit ] , cih , cih_list ) ; en = CIB_EN_RD ( sc ) ; en |= 1ul << bit ; CIB_EN_WR ( sc , en ) ; splx ( s ) ; return cih ; } 