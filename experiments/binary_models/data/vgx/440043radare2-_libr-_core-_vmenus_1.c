R_API bool r_core_visual_esil ( RCore * core , const char * input ) { const int nbits = sizeof ( ut64 ) * 8 ; int analopType ; char * word = NULL ; int x = 0 ; char * ginput = NULL ; RAnalOp analop ; ut8 buf [ sizeof ( ut64 ) ] ; unsigned int addrsize = r_config_get_i ( core -> config , "esil.addr.size" ) ; if ( input && ! * input ) { input = NULL ; } if ( input && * input == '?' ) { eprintf ( "Usage: aev [esil-expression]    # same as VbE\n" ) ; return false ; } if ( core -> blocksize < sizeof ( ut64 ) ) { return false ; } r_reg_arena_push ( core -> anal -> reg ) ; REsil * esil = r_esil_new ( 20 , 0 , addrsize ) ; r_esil_setup ( esil , core -> anal , false , false , false ) ; r_esil_set_pc ( esil , core -> offset ) ; char * expr = NULL ; bool refresh = false ; for ( ; ; ) { R_FREE ( expr ) ; r_cons_clear00 ( ) ; if ( refresh ) { x = 0 ; refresh = false ; } if ( input ) { expr = strdup ( input ) ; } else { RAnalOp asmop ; memcpy ( buf , core -> block , sizeof ( ut64 ) ) ; ( void ) r_asm_disassemble ( core -> rasm , & asmop , buf , sizeof ( ut64 ) ) ; analop . type = - 1 ; ( void ) r_anal_op ( core -> anal , & analop , core -> offset , buf , sizeof ( ut64 ) , R_ARCH_OP_MASK_ESIL ) ; analopType = analop . type & R_ANAL_OP_TYPE_MASK ; r_cons_printf ( "r2's esil debugger:\n\n" ) ; const char * vi = r_config_get ( core -> config , "cmd.vprompt" ) ; if ( R_STR_ISNOTEMPTY ( vi ) ) { r_core_cmd0 ( core , vi ) ; } r_cons_printf ( "addr: 0x%08" PFMT64x "\n" , core -> offset ) ; r_cons_printf ( "pos: %d\n" , x ) ; { char * op_hex = r_asm_op_get_hex ( & asmop ) ; char * res = r_print_hexpair ( core -> print , op_hex , - 1 ) ; r_cons_printf ( "hex: %s\n" Color_RESET , res ) ; free ( res ) ; free ( op_hex ) ; } char * op = colorize_asm_string ( core , r_asm_op_get_asm ( & asmop ) , analopType , core -> offset ) ; r_cons_printf ( Color_RESET "asm: %s\n" Color_RESET , op ) ; free ( op ) ; expr = strdup ( r_strbuf_get ( & analop . esil ) ) ; r_asm_op_fini ( & asmop ) ; } { r_cons_printf ( Color_RESET "esil: %s\n" Color_RESET , expr ) ; int wp = wordpos ( expr , x ) ; char * pas = strdup ( r_str_pad ( ' ' , wp ?wp + 1 : 0 ) ) ; int wp2 = wordpos ( expr , x + 1 ) ; free ( word ) ; word = r_str_ndup ( expr + ( wp ?( wp + 1 ) : 0 ) , ( wp2 - wp ) - ( wp ?1 : 0 ) ) ; if ( wp == wp2 ) { refresh = true ; } const char * pad = r_str_pad ( '-' , wp2 - ( ( wp > 0 ) ?wp + 1 : 0 ) ) ; r_cons_printf ( Color_RESET "      %s%s\n" Color_RESET , pas , pad ) ; free ( pas ) ; } r_cons_printf ( "esil regs:\n" ) ; showreg ( esil , "$$" , "address" ) ; showreg ( esil , "$z" , "zero" ) ; showreg ( esil , "$b" , "borrow" ) ; showreg ( esil , "$c" , "carry" ) ; showreg ( esil , "$o" , "overflow" ) ; showreg ( esil , "$p" , "parity" ) ; showreg ( esil , "$r" , "regsize" ) ; showreg ( esil , "$s" , "sign" ) ; showreg ( esil , "$d" , "delay" ) ; showreg ( esil , "$j" , "jump" ) ; r_cons_printf ( "regs:\n" ) ; char * r = r_core_cmd_str ( core , "dr=" ) ; if ( r ) { r_cons_printf ( "%s" , r ) ; free ( r ) ; } r_cons_printf ( "esil stack:\n" ) ; r_esil_dumpstack ( esil ) ; if ( ! input ) { r_anal_op_fini ( & analop ) ; } r_cons_newline ( ) ; r_cons_visual_flush ( ) ; int ch = r_cons_readchar ( ) ; if ( ch == - 1 || ch == 4 ) { break ; } ch = r_cons_arrow_to_hjkl ( ch ) ; switch ( ch ) { case 'Q' : case 'q' : beach case 'n' : case 'P' : x = 0 ; r_esil_free ( esil ) ; esil = r_esil_new ( 20 , 0 , addrsize ) ; esil -> anal = core -> anal ; r_core_cmd0 ( core , "so+1" ) ; r_esil_set_pc ( esil , core -> offset ) ; break ; case 'N' : case 'p' : x = 0 ; r_esil_free ( esil ) ; esil = r_esil_new ( 20 , 0 , addrsize ) ; esil -> anal = core -> anal ; r_core_cmd0 ( core , "so-1" ) ; r_esil_set_pc ( esil , core -> offset ) ; break ; case '=' : { r_core_visual_showcursor ( core , true ) ; const char * buf = NULL ; const char * cmd = r_config_get ( core -> config , "cmd.vprompt" ) ; r_line_set_prompt ( "cmd.vprompt>" ) ; I -> line -> contents = strdup ( cmd ) ; buf = r_line_readline ( ) ; I -> line -> contents = NULL ; ( void ) r_config_set ( core -> config , "cmd.vprompt" , buf ) ; r_core_visual_showcursor ( core , false ) ; } break ; case 'e' : { char * s = r_cons_input ( "esil: " ) ; free ( ginput ) ; if ( * s ) { input = s ; ginput = s ; } else { ginput = NULL ; input = NULL ; free ( s ) ; } } break ; case 'o' : { char * s = r_cons_input ( "offset: " ) ; r_core_cmdf ( core , "s %s" , s ) ; free ( s ) ; } break ; case 's' : x = R_MIN ( x + 1 , nbits - 1 ) ; r_esil_runword ( esil , word ) ; break ; case 'S' : R_LOG_WARN ( "TODO: esil step back :D" ) ; r_sys_usleep ( 500 ) ; break ; case 'r' : case 'h' : x = 0 ; break ; case '?' : r_cons_clear00 ( ) ; r_cons_printf ( "Vd1?: Visual Bit Editor Help:\n\n" " q     - quit the bit editor\n" " h/r   - reset / go back (reinitialize esil state)\n" " s     - esil step in\n" " o     - specify offset to seek\n" " e     - type a new esil expression to debug\n" " j/k   - toggle bit value (same as space key)\n" " n/p   - go next/prev instruction\n" " =     - enter cmd.vprompt command\n" " :     - enter command\n" ) ; r_cons_flush ( ) ; r_cons_any_key ( NULL ) ; break ; case ':' : r_cons_show_cursor ( true ) ; r_cons_set_raw ( 0 ) ; while ( 1 ) { char cmd [ 1024 ] ; * cmd = 0 ; r_line_set_prompt ( ":>" ) ; if ( r_cons_fgets ( cmd , sizeof ( cmd ) , 0 , NULL ) < 0 ) { cmd [ 0 ] = '\0' ; } r_core_cmd0 ( core , cmd ) ; if ( ! * cmd ) { break ; } r_cons_flush ( ) ; } r_cons_show_cursor ( false ) ; r_cons_set_raw ( 1 ) ; r_cons_clear ( ) ; break ; } } beach free ( expr ) ; r_reg_arena_pop ( core -> anal -> reg ) ; r_esil_free ( esil ) ; free ( word ) ; free ( ginput ) ; return true ; } 