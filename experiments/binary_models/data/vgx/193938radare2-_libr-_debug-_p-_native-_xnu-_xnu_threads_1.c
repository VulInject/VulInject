static int xnu_update_thread_list ( RDebug * dbg ) { thread_array_t thread_list = NULL ; unsigned int thread_count = 0 ; xnu_thread_t * thread ; kern_return_t kr ; task_t task ; int i ; if ( ! dbg -> threads ) { dbg -> threads = r_list_newf ( ( RListFree ) & xnu_thread_free ) ; if ( ! dbg -> threads ) { return false ; } } task = pid_to_task ( dbg -> pid ) ; kr = task_threads ( task , & thread_list , & thread_count ) ; if ( kr != KERN_SUCCESS ) { R_LOG_ERROR ( "Failed to get list of task's threads" ) ; return false ; } if ( r_list_empty ( dbg -> threads ) ) { for ( i = 0 ; i < thread_count ; i ++ ) { thread = xnu_get_thread_with_info ( dbg , thread_list [ i ] ) ; if ( ! thread ) { R_LOG_ERROR ( "Failed to fill_thread" ) ; continue ; } if ( ! r_list_append ( dbg -> threads , thread ) ) { R_LOG_ERROR ( "Failed to add thread to list" ) ; xnu_thread_free ( thread ) ; } } } else { RListIter * iter , * iter2 ; r_list_foreach_safe ( , , , ) { bool flag = true ; for ( i = 0 ; i < thread_count ; i ++ ) { if ( thread -> port == thread_list [ i ] ) { flag = false ; break ; } } if ( flag ) { r_list_delete ( dbg -> threads , iter ) ; } else { xnu_update_thread_info ( dbg , thread ) ; } } for ( i = 0 ; i < thread_count ; i ++ ) { xnu_thread_t * t ; iter = r_list_find ( dbg -> threads , & thread_list [ i ] , ( RListComparator ) & thread_find ) ; if ( iter ) { kr = mach_port_deallocate ( mach_task_self ( ) , thread_list [ i ] ) ; if ( kr != KERN_SUCCESS ) { R_LOG_ERROR ( "Failed to deallocate port" ) ; } continue ; } t = xnu_get_thread_with_info ( dbg , thread_list [ i ] ) ; r_list_append ( dbg -> threads , t ) ; } } ( void ) vm_deallocate ( mach_task_self ( ) , ( mach_vm_address_t ) thread_list , thread_count * sizeof ( thread_t ) ) ; return true ; } 