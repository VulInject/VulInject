build_script ( ) { const struct unw_table_entry * e = NULL ; struct unw_script * script = NULL ; struct unw_labeled_state * ls , * next ; unsigned long ip = info -> ip ; struct unw_state_record sr ; struct unw_table * table , * prev ; struct unw_reg_info * r ; struct unw_insn insn ; u8 * dp , * desc_end ; u64 hdr ; int i ; STAT ( , ) STAT ( ) for ( r = sr . curr . reg ; r < sr . curr . reg + UNW_NUM_REGS ; ++ r ) { r -> when = UNW_WHEN_NEVER ; } sr . pr_val = info -> pr ; UNW_DPRINT ( 3 , "unwind.%s: ip 0x%lx\n" , __func__ , ip ) ; script = script_new ( ip ) ; if ( ! script ) { UNW_DPRINT ( 0 , "unwind.%s: failed to create unwind script\n" , __func__ ) ; STAT ( unw . stat . script . build_time += ia64_get_itc ( ) - start ) ; return NULL ; } unw . cache [ info -> prev_script ] . hint = script - unw . cache ; STAT ( parse_start = ia64_get_itc ( ) ) ; prev = NULL ; for ( table = unw . tables ; table ; table = table -> next ) { if ( ip >= table -> start && ip < table -> end ) { if ( prev && prev != unw . tables ) { prev -> next = table -> next ; table -> next = unw . tables -> next ; unw . tables -> next = table ; } e = lookup ( table , ip - table -> segment_base ) ; break ; } prev = table ; } if ( ! e ) { UNW_DPRINT ( 1 , "unwind.%s: no unwind info for ip=0x%lx (prev ip=0x%lx)\n" , __func__ , ip , unw . cache [ info -> prev_script ] . ip ) ; sr . curr . reg [ UNW_REG_RP ] . where = UNW_WHERE_BR ; sr . curr . reg [ UNW_REG_RP ] . when = - 1 ; sr . curr . reg [ UNW_REG_RP ] . val = 0 ; compile_reg ( & sr , UNW_REG_RP , script ) ; script_finalize ( script , & sr ) ; STAT ( unw . stat . script . parse_time += ia64_get_itc ( ) - parse_start ) ; STAT ( unw . stat . script . build_time += ia64_get_itc ( ) - start ) ; return script ; } sr . when_target = ( 3 * ( ( ip & ~ 0xfUL ) - ( table -> segment_base + e -> start_offset ) ) / 16 + ( ip & 0xfUL ) ) ; hdr = * ( u64 * ) ( table -> segment_base + e -> info_offset ) ; dp = ( u8 * ) ( table -> segment_base + e -> info_offset + 8 ) ; desc_end = dp + 8 * UNW_LENGTH ( hdr ) ; while ( ! sr . done && dp < desc_end ) { dp = unw_decode ( dp , sr . in_body , & sr ) ; } if ( sr . when_target > sr . epilogue_start ) { sr . curr . reg [ UNW_REG_PSP ] . val = 0 ; sr . curr . reg [ UNW_REG_PSP ] . where = UNW_WHERE_NONE ; sr . curr . reg [ UNW_REG_PSP ] . when = UNW_WHEN_NEVER ; for ( r = sr . curr . reg ; r < sr . curr . reg + UNW_NUM_REGS ; ++ r ) { if ( ( r -> where == UNW_WHERE_PSPREL && r -> val <= 0x10 ) || r -> where == UNW_WHERE_SPREL ) { r -> val = 0 ; r -> where = UNW_WHERE_NONE ; r -> when = UNW_WHEN_NEVER ; } } } script -> flags = sr . flags ; if ( sr . curr . reg [ UNW_REG_RP ] . when >= sr . when_target ) { sr . curr . reg [ UNW_REG_RP ] . where = UNW_WHERE_BR ; sr . curr . reg [ UNW_REG_RP ] . when = - 1 ; sr . curr . reg [ UNW_REG_RP ] . val = sr . return_link_reg ; UNW_DPRINT ( 1 , "unwind.%s: using default for rp at ip=0x%lx where=%d val=0x%lx\n" , __func__ , ip , sr . curr . reg [ UNW_REG_RP ] . where , sr . curr . reg [ UNW_REG_RP ] . val ) ; } UNW_DPRINT ( 1 , "unwind.%s: state record for func 0x%lx, t=%u:\n" , __func__ , table -> segment_base + e -> start_offset , sr . when_target ) ; for ( r = sr . curr . reg ; r < sr . curr . reg + UNW_NUM_REGS ; ++ r ) { if ( r -> where != UNW_WHERE_NONE || r -> when != UNW_WHEN_NEVER ) { UNW_DPRINT ( 1 , "  %s<- " , unw . preg_name [ r - sr . curr . reg ] ) ; switch ( r -> where ) { case UNW_WHERE_GR : UNW_DPRINT ( 1 , "r%lu" , r -> val ) ; break ; case UNW_WHERE_FR : UNW_DPRINT ( 1 , "f%lu" , r -> val ) ; break ; case UNW_WHERE_BR : UNW_DPRINT ( 1 , "b%lu" , r -> val ) ; break ; case UNW_WHERE_SPREL : UNW_DPRINT ( 1 , "[sp+0x%lx]" , r -> val ) ; break ; case UNW_WHERE_PSPREL : UNW_DPRINT ( 1 , "[psp+0x%lx]" , r -> val ) ; break ; case UNW_WHERE_NONE : UNW_DPRINT ( 1 , "%s+0x%lx" , unw . preg_name [ r - sr . curr . reg ] , r -> val ) ; break ; default : UNW_DPRINT ( 1 , "BADWHERE(%d)" , r -> where ) ; break ; } UNW_DPRINT ( 1 , "\t\t%d\n" , r -> when ) ; } } STAT ( unw . stat . script . parse_time += ia64_get_itc ( ) - parse_start ) ; if ( sr . when_target > sr . curr . reg [ UNW_REG_PSP ] . when && ( sr . curr . reg [ UNW_REG_PSP ] . where == UNW_WHERE_NONE ) && sr . curr . reg [ UNW_REG_PSP ] . val != 0 ) { insn . opc = UNW_INSN_ADD ; insn . dst = offsetof ( unw_frame_info , psp ) / 8 ; insn . val = sr . curr . reg [ UNW_REG_PSP ] . val ; script_emit ( script , insn ) ; } if ( sr . when_target < sr . curr . reg [ UNW_REG_PRI_UNAT_GR ] . when ) { i = UNW_REG_PRI_UNAT_MEM ; } if ( sr . when_target < sr . curr . reg [ UNW_REG_PRI_UNAT_MEM ] . when ) { i = UNW_REG_PRI_UNAT_GR ; } if ( sr . curr . reg [ UNW_REG_PRI_UNAT_MEM ] . when > sr . curr . reg [ UNW_REG_PRI_UNAT_GR ] . when ) { i = UNW_REG_PRI_UNAT_MEM ; } else { i = UNW_REG_PRI_UNAT_GR ; } compile_reg ( & sr , i , script ) ; for ( i = UNW_REG_BSP ; i < UNW_NUM_REGS ; ++ i ) { compile_reg ( & sr , i , script ) ; } STAT ( parse_start = ia64_get_itc ( ) ) ; for ( ls = sr . labeled_states ; ls ; ls = next ) { next = ls -> next ; free_state_stack ( & ls -> saved_state ) ; free_labeled_state ( ls ) ; } free_state_stack ( & sr . curr ) ; STAT ( unw . stat . script . parse_time += ia64_get_itc ( ) - parse_start ) ; script_finalize ( script , & sr ) ; STAT ( unw . stat . script . build_time += ia64_get_itc ( ) - start ) ; return script ; } 