__must_check int __media_pipeline_start ( struct media_pad * pad , struct media_pipeline * pipe ) { struct media_device * mdev = pad -> graph_obj . mdev ; struct media_pipeline_pad * err_ppad ; struct media_pipeline_pad * ppad ; int ret ; lockdep_assert_held ( & mdev -> graph_mutex ) ; if ( pipe -> start_count ) { pipe -> start_count ++ ; return 0 ; } ret = media_pipeline_populate ( pipe , pad ) ; if ( ret ) { return ret ; } list_for_each_entry ( , , ) { struct media_pad * pad = ppad -> pad ; struct media_entity * entity = pad -> entity ; bool has_enabled_link = false ; bool has_link = false ; struct media_link * link ; dev_dbg ( mdev -> dev , "Validating pad '%s':%u\n" , pad -> entity -> name , pad -> index ) ; if ( pad -> pipe ) { dev_dbg ( mdev -> dev , "Failed to start pipeline: pad '%s':%u busy\n" , pad -> entity -> name , pad -> index ) ; ret = - EBUSY ; error } for_each_media_entity_data_link ( , ) { if ( link -> sink != pad && link -> source != pad ) { continue ; } if ( link -> flags & MEDIA_LNK_FL_ENABLED ) { has_enabled_link = true ; } has_link = true ; if ( ! ( link -> flags & MEDIA_LNK_FL_ENABLED ) ) { continue ; } if ( link -> sink != pad ) { continue ; } if ( ! entity -> ops || ! entity -> ops -> link_validate ) { continue ; } ret = entity -> ops -> link_validate ( link ) ; if ( ret ) { dev_dbg ( mdev -> dev , "Link '%s':%u ->'%s':%u failed validation: %d\n" , link -> source -> entity -> name , link -> source -> index , link -> sink -> entity -> name , link -> sink -> index , ret ) ; error } dev_dbg ( mdev -> dev , "Link '%s':%u ->'%s':%u is valid\n" , link -> source -> entity -> name , link -> source -> index , link -> sink -> entity -> name , link -> sink -> index ) ; } if ( ( pad -> flags & MEDIA_PAD_FL_MUST_CONNECT ) && has_link && ! has_enabled_link ) { dev_dbg ( mdev -> dev , "Pad '%s':%u must be connected by an enabled link\n" , pad -> entity -> name , pad -> index ) ; ret = - ENOLINK ; error } pad -> pipe = pipe ; } pipe -> start_count ++ ; return 0 ; error list_for_each_entry ( , , ) { if ( err_ppad == ppad ) { break ; } err_ppad -> pad -> pipe = NULL ; } media_pipeline_cleanup ( pipe ) ; return ret ; } 