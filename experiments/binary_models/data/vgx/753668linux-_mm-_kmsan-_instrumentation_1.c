( __msan_metadata_ptr_for_store_n ) ; shadow_origin_ptr __msan_metadata_ptr_for_load_ # # size ( void * addr ) ; shadow_origin_ptr __msan_metadata_ptr_for_load_ # # size ( ) { return get_shadow_origin_ptr ( addr , size , false ) ; } ; EXPORT_SYMBOL ( __msan_metadata_ptr_for_load_ # # size ) ; shadow_origin_ptr __msan_metadata_ptr_for_store_ # # size ( void * addr ) ; shadow_origin_ptr __msan_metadata_ptr_for_store_ # # size ( ) { return get_shadow_origin_ptr ( addr , size , true ) ; } ; EXPORT_SYMBOL ( ) DECLARE_METADATA_PTR_GETTER ( 1 ) ; DECLARE_METADATA_PTR_GETTER ( 2 ) ; DECLARE_METADATA_PTR_GETTER ( 4 ) ; DECLARE_METADATA_PTR_GETTER ( 8 ) ; void __msan_instrument_asm_store ( void * addr , uintptr_t size ) void __msan_instrument_asm_store ( void * addr , uintptr_t size ) { unsigned long ua_flags ; if ( ! kmsan_enabled ) { return ; } ua_flags = user_access_save ( ) ; if ( size > 512 ) { WARN_ONCE ( 1 , "assembly store size too big: %ld\n" , size ) ; size = 8 ; } if ( is_bad_asm_addr ( addr , size , true ) ) { user_access_restore ( ua_flags , NULL ) ; return ; } kmsan_internal_unpoison_memory ( addr , size , false ) ; user_access_restore ( ua_flags ) ; } 