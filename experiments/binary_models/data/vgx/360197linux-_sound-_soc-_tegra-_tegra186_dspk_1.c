static int tegra186_dspk_hw_params ( struct snd_pcm_substream * substream , struct snd_pcm_hw_params * params , struct snd_soc_dai * dai ) { struct tegra186_dspk * dspk = snd_soc_dai_get_drvdata ( dai ) ; unsigned int channels , srate , dspk_clk ; struct device * dev = dai -> dev ; struct tegra_cif_conf cif_conf ; unsigned int max_th ; int err ; channels = params_channels ( params ) ; cif_conf . audio_ch = channels ; switch ( dspk -> ch_sel ) { case DSPK_CH_SELECT_LEFT : case DSPK_CH_SELECT_RIGHT : cif_conf . client_ch = 1 ; break ; case DSPK_CH_SELECT_STEREO : cif_conf . client_ch = 2 ; break ; default : dev_err ( dev , "Invalid DSPK client channels\n" ) ; return - EINVAL ; } cif_conf . client_bits = TEGRA_ACIF_BITS_24 ; switch ( params_format ( params ) ) { case SNDRV_PCM_FORMAT_S16_LE : cif_conf . audio_bits = TEGRA_ACIF_BITS_16 ; break ; case SNDRV_PCM_FORMAT_S32_LE : cif_conf . audio_bits = TEGRA_ACIF_BITS_32 ; break ; default : dev_err ( dev , "unsupported format!\n" ) ; return - EOPNOTSUPP ; } srate = params_rate ( params ) ; max_th = ( TEGRA186_DSPK_RX_FIFO_DEPTH / cif_conf . audio_ch ) - 1 ; if ( dspk -> rx_fifo_th > max_th ) { dspk -> rx_fifo_th = max_th ; } cif_conf . threshold = dspk -> rx_fifo_th ; cif_conf . mono_conv = dspk -> mono_to_stereo ; cif_conf . stereo_conv = dspk -> stereo_to_mono ; tegra_set_cif ( dspk -> regmap , TEGRA186_DSPK_RX_CIF_CTRL , & cif_conf ) ; dspk_clk = ( DSPK_OSR_FACTOR << dspk -> osr_val ) * srate * DSPK_CLK_RATIO ; err = clk_set_rate ( dspk -> clk_dspk , dspk_clk ) ; if ( err ) { dev_err ( dev , "can't set DSPK clock rate %u, err: %d\n" , dspk_clk , err ) ; return err ; } regmap_update_bits ( dspk -> regmap , TEGRA186_DSPK_CORE_CTRL , TEGRA186_DSPK_OSR_MASK | TEGRA186_DSPK_CHANNEL_SELECT_MASK | TEGRA186_DSPK_CTRL_LRSEL_POLARITY_MASK , ( dspk -> osr_val << DSPK_OSR_SHIFT ) | ( ( dspk -> ch_sel + 1 ) << CH_SEL_SHIFT ) | ( dspk -> lrsel << LRSEL_POL_SHIFT ) ) ; return 0 ; } 