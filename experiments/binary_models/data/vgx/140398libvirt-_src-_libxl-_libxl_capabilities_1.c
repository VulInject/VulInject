static int libxlCapsInitNuma ( libxl_ctx * ctx , virCaps * caps ) { libxl_numainfo * numa_info = NULL ; libxl_cputopology * cpu_topo = NULL ; int nr_nodes = 0 , nr_cpus = 0 , nr_distances = 0 ; virCapsHostNUMACellCPU * * cpus = NULL ; virNumaDistance * distances = NULL ; int * nr_cpus_node = NULL ; int i ; int ret = - 1 ; numa_info = libxl_get_numainfo ( ctx , & nr_nodes ) ; if ( numa_info == NULL || nr_nodes == 0 ) { virReportError ( VIR_ERR_INTERNAL_ERROR , "%s" , _ ( "libxl_get_numainfo failed" ) ) ; cleanup } cpu_topo = libxl_get_cpu_topology ( ctx , & nr_cpus ) ; if ( cpu_topo == NULL || nr_cpus == 0 ) { virReportError ( VIR_ERR_INTERNAL_ERROR , "%s" , _ ( "libxl_get_cpu_topology failed" ) ) ; cleanup } cpus = g_new0 ( virCapsHostNUMACellCPU * , nr_nodes ) ; nr_cpus_node = g_new0 ( int , nr_nodes ) ; for ( i = 0 ; i < nr_cpus ; i ++ ) { int node = cpu_topo [ i ] . node ; if ( cpu_topo [ i ] . core == LIBXL_CPUTOPOLOGY_INVALID_ENTRY ) { continue ; } nr_cpus_node [ node ] ++ ; if ( nr_cpus_node [ node ] == 1 ) { cpus [ node ] = g_new0 ( virCapsHostNUMACellCPU , 1 ) ; } else { VIR_REALLOC_N ( cpus [ node ] , nr_cpus_node [ node ] ) ; } cpus [ node ] [ nr_cpus_node [ node ] - 1 ] . id = i ; cpus [ node ] [ nr_cpus_node [ node ] - 1 ] . socket_id = cpu_topo [ i ] . socket ; cpus [ node ] [ nr_cpus_node [ node ] - 1 ] . core_id = cpu_topo [ i ] . core ; cpus [ node ] [ nr_cpus_node [ node ] - 1 ] . die_id = 0 ; cpus [ node ] [ nr_cpus_node [ node ] - 1 ] . siblings = virBitmapNew ( nr_cpus ) ; } for ( i = 0 ; i < nr_cpus ; i ++ ) { int node = cpu_topo [ i ] . node ; size_t j ; if ( cpu_topo [ i ] . core == LIBXL_CPUTOPOLOGY_INVALID_ENTRY ) { continue ; } for ( j = 0 ; j < nr_cpus_node [ node ] ; j ++ ) { if ( cpus [ node ] [ j ] . socket_id == cpu_topo [ i ] . socket && cpus [ node ] [ j ] . core_id == cpu_topo [ i ] . core ) { ignore_value ( virBitmapSetBit ( cpus [ node ] [ j ] . siblings , i ) ) ; } } } caps -> host . numa = virCapabilitiesHostNUMANew ( ) ; for ( i = 0 ; i < nr_nodes ; i ++ ) { if ( numa_info [ i ] . size == LIBXL_NUMAINFO_INVALID_ENTRY ) { continue ; } nr_distances = numa_info [ i ] . num_dists ; if ( nr_distances ) { size_t j ; distances = g_new0 ( virNumaDistance , nr_distances ) ; for ( j = 0 ; j < nr_distances ; j ++ ) { distances [ j ] . cellid = j ; distances [ j ] . value = numa_info [ i ] . dists [ j ] ; } } virCapabilitiesHostNUMAAddCell ( caps -> host . numa , i , numa_info [ i ] . size / 1024 , nr_cpus_node [ i ] , & cpus [ i ] , nr_distances , & distances , 0 , NULL , NULL ) ; cpus [ i ] = NULL ; } ret = 0 ; cleanup if ( ret != 0 ) { for ( i = 0 ; cpus && i < nr_nodes ; i ++ ) { VIR_FREE ( cpus [ i ] ) ; } if ( caps -> host . numa ) { g_clear_pointer ( & caps -> host . numa , virCapabilitiesHostNUMAUnref ) ; } VIR_FREE ( distances ) ; } VIR_FREE ( cpus ) ; VIR_FREE ( nr_cpus_node ) ; libxl_cputopology_list_free ( cpu_topo , nr_cpus ) ; libxl_numainfo_list_free ( numa_info , nr_nodes ) ; return ret ; } 