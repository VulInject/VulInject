int asn1parse_main ( int argc , char * * argv ) { int i , j , ret = 1 ; long num , tmplen ; BIO * in = NULL , * out = NULL , * b64 = NULL , * derout = NULL ; char * str = NULL ; const char * errstr = NULL ; unsigned char * tmpbuf ; const unsigned char * ctmpbuf ; BUF_MEM * buf = NULL ; ASN1_TYPE * at = NULL ; if ( pledge ( "stdio cpath wpath rpath" , NULL ) == - 1 ) { perror ( "pledge" ) ; exit ( 1 ) ; } asn1pars_config . informat = FORMAT_PEM ; if ( ( asn1pars_config . osk = sk_OPENSSL_STRING_new_null ( ) ) == NULL ) { BIO_printf ( bio_err , "Memory allocation failure\n" ) ; end } if ( options_parse ( argc , argv , asn1pars_options , NULL , NULL ) != 0 ) { asn1pars_usage ( ) ; return ( 1 ) ; } in = BIO_new ( BIO_s_file ( ) ) ; out = BIO_new ( BIO_s_file ( ) ) ; if ( ( in == NULL ) || ( out == NULL ) ) { ERR_print_errors ( bio_err ) ; end } BIO_set_fp ( out , stdout , BIO_NOCLOSE | BIO_FP_TEXT ) ; if ( asn1pars_config . oidfile != NULL ) { if ( BIO_read_filename ( in , asn1pars_config . oidfile ) <= 0 ) { BIO_printf ( bio_err , "problems opening %s\n" , asn1pars_config . oidfile ) ; ERR_print_errors ( bio_err ) ; end } OBJ_create_objects ( in ) ; } if ( asn1pars_config . infile == NULL ) { BIO_set_fp ( in , stdin , BIO_NOCLOSE ) ; } else { if ( BIO_read_filename ( in , asn1pars_config . infile ) <= 0 ) { perror ( asn1pars_config . infile ) ; end } } if ( asn1pars_config . derfile ) { if ( ! ( derout = BIO_new_file ( asn1pars_config . derfile , "wb" ) ) ) { BIO_printf ( bio_err , "problems opening %s\n" , asn1pars_config . derfile ) ; ERR_print_errors ( bio_err ) ; end } } if ( ( buf = BUF_MEM_new ( ) ) == NULL ) { end } if ( ! BUF_MEM_grow ( buf , BUFSIZ * 8 ) ) { end } if ( asn1pars_config . genstr || asn1pars_config . genconf ) { num = do_generate ( bio_err , asn1pars_config . genstr , asn1pars_config . genconf , buf ) ; if ( num < 0 ) { ERR_print_errors ( bio_err ) ; end } } else { if ( asn1pars_config . informat == FORMAT_PEM ) { BIO * tmp ; if ( ( b64 = BIO_new ( BIO_f_base64 ( ) ) ) == NULL ) { end } BIO_push ( b64 , in ) ; tmp = in ; in = b64 ; b64 = tmp ; } num = 0 ; for ( ; ; ) { if ( ! BUF_MEM_grow ( buf , ( int ) num + BUFSIZ ) ) { end } i = BIO_read ( in , & ( buf -> data [ num ] ) , BUFSIZ ) ; if ( i <= 0 ) { break ; } num += i ; } } str = buf -> data ; if ( sk_OPENSSL_STRING_num ( asn1pars_config . osk ) ) { tmpbuf = ( unsigned char * ) str ; tmplen = num ; for ( i = 0 ; i < sk_OPENSSL_STRING_num ( asn1pars_config . osk ) ; i ++ ) { ASN1_TYPE * atmp ; int typ ; j = strtonum ( sk_OPENSSL_STRING_value ( asn1pars_config . osk , i ) , 1 , INT_MAX , & errstr ) ; if ( errstr ) { BIO_printf ( bio_err , "'%s' is an invalid number: %s\n" , sk_OPENSSL_STRING_value ( asn1pars_config . osk , i ) , errstr ) ; continue ; } tmpbuf += j ; tmplen -= j ; atmp = at ; ctmpbuf = tmpbuf ; at = d2i_ASN1_TYPE ( NULL , & ctmpbuf , tmplen ) ; ASN1_TYPE_free ( atmp ) ; if ( ! at ) { BIO_printf ( bio_err , "Error parsing structure\n" ) ; ERR_print_errors ( bio_err ) ; end } typ = ASN1_TYPE_get ( at ) ; if ( ( typ == V_ASN1_OBJECT ) || ( typ == V_ASN1_NULL ) ) { BIO_printf ( bio_err , "Can't parse %s type\n" , typ == V_ASN1_NULL ?"NULL" : "OBJECT" ) ; ERR_print_errors ( bio_err ) ; end } tmpbuf = at -> value . asn1_string -> data ; tmplen = at -> value . asn1_string -> length ; } str = ( char * ) tmpbuf ; num = tmplen ; } if ( asn1pars_config . offset >= num ) { BIO_printf ( bio_err , "Error: offset too large\n" ) ; end } num -= asn1pars_config . offset ; if ( ( asn1pars_config . length == 0 ) || ( ( long ) asn1pars_config . length > num ) ) { asn1pars_config . length = ( unsigned int ) num ; } if ( derout ) { if ( BIO_write ( derout , str + asn1pars_config . offset , asn1pars_config . length ) != ( int ) asn1pars_config . length ) { BIO_printf ( bio_err , "Error writing output\n" ) ; ERR_print_errors ( bio_err ) ; end } } if ( ! asn1pars_config . noout && ! ASN1_parse_dump ( out , ( unsigned char * ) & ( str [ asn1pars_config . offset ] ) , asn1pars_config . length , asn1pars_config . indent , asn1pars_config . dump ) ) { ERR_print_errors ( bio_err ) ; end } ret = 0 ; end BIO_free ( derout ) ; BIO_free ( in ) ; BIO_free_all ( out ) ; BIO_free ( b64 ) ; if ( ret != 0 ) { ERR_print_errors ( bio_err ) ; } BUF_MEM_free ( buf ) ; ASN1_TYPE_free ( at ) ; sk_OPENSSL_STRING_free ( asn1pars_config . osk ) ; OBJ_cleanup ( ) ; return ( ret ) ; } 