static int iowarrior_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( interface ) ; struct iowarrior * dev = NULL ; struct usb_host_interface * iface_desc ; int retval = - ENOMEM ; int res ; dev = kzalloc ( sizeof ( iowarrior ) , GFP_KERNEL ) ; if ( ! dev ) { return retval ; } atomic_set ( & dev -> intr_idx , 0 ) ; atomic_set ( & dev -> read_idx , 0 ) ; spin_lock_init ( & dev -> intr_idx_lock ) ; atomic_set ( & dev -> overflow_flag , 0 ) ; init_waitqueue_head ( & dev -> read_wait ) ; atomic_set ( & dev -> write_busy , 0 ) ; init_waitqueue_head ( & dev -> write_wait ) ; dev -> udev = udev ; dev -> interface = interface ; iface_desc = interface -> cur_altsetting ; dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ; res = usb_find_last_int_in_endpoint ( iface_desc , & dev -> int_in_endpoint ) ; if ( res ) { dev_err ( & interface -> dev , "no interrupt-in endpoint found\n" ) ; retval = res ; error } if ( dev -> product_id == USB_DEVICE_ID_CODEMERCS_IOW56 ) { res = usb_find_last_int_out_endpoint ( iface_desc , & dev -> int_out_endpoint ) ; if ( res ) { dev_err ( & interface -> dev , "no interrupt-out endpoint found\n" ) ; retval = res ; error } } dev -> report_size = usb_endpoint_maxp ( dev -> int_in_endpoint ) ; if ( ( dev -> interface -> cur_altsetting -> desc . bInterfaceNumber == 0 ) && ( dev -> product_id == USB_DEVICE_ID_CODEMERCS_IOW56 ) ) { dev -> report_size = 7 ; } dev -> int_in_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> int_in_urb ) { error } dev -> int_in_buffer = kmalloc ( dev -> report_size , GFP_KERNEL ) ; if ( ! dev -> int_in_buffer ) { error } usb_fill_int_urb ( dev -> int_in_urb , dev -> udev , usb_rcvintpipe ( dev -> udev , dev -> int_in_endpoint -> bEndpointAddress ) , dev -> int_in_buffer , dev -> report_size , iowarrior_callback , dev , dev -> int_in_endpoint -> bInterval ) ; dev -> read_queue = kmalloc ( ( ( dev -> report_size + 1 ) * MAX_INTERRUPT_BUFFER ) , GFP_KERNEL ) ; if ( ! dev -> read_queue ) { error } memset ( dev -> chip_serial , 0x00 , sizeof ( dev -> chip_serial ) ) ; usb_string ( udev , udev -> descriptor . iSerialNumber , dev -> chip_serial , sizeof ( dev -> chip_serial ) ) ; if ( strlen ( dev -> chip_serial ) != 8 ) { memset ( dev -> chip_serial , 0x00 , sizeof ( dev -> chip_serial ) ) ; } if ( dev -> interface -> cur_altsetting -> desc . bInterfaceNumber == 0 ) { usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , 0x0A , USB_TYPE_CLASS | USB_RECIP_INTERFACE , 0 , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; } dev -> present = 1 ; usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & iowarrior_class ) ; if ( retval ) { dev_err ( & interface -> dev , "Not able to get a minor for this device.\n" ) ; usb_set_intfdata ( interface , NULL ) ; error } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , "IOWarrior product=0x%x, serial=%s interface=%d " "now attached to iowarrior%d\n" , dev -> product_id , dev -> chip_serial , iface_desc -> desc . bInterfaceNumber , dev -> minor - IOWARRIOR_MINOR_BASE ) ; return retval ; error iowarrior_delete ( dev ) ; return retval ; } 