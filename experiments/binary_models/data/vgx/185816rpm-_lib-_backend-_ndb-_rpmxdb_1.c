static int rpmxdbReadHeader ( rpmxdb xdb , int rw ) { struct xdb_slot * slot ; unsigned int slotnpages , pagesize , generation , usergeneration ; unsigned int page , * lastfreep ; unsigned char * pageptr ; struct xdb_slot * slots , * * usedslots , * lastslot ; unsigned int nslots ; unsigned int usedblobpages ; int i , nused , slotno ; struct stat stb ; if ( xdb -> mapped ) { if ( le2ha ( xdb -> mapped + XDB_OFFSET_GENERATION ) == xdb -> generation ) { if ( rw && ! xdb -> mappedrw ) { unmapheader ( xdb ) ; if ( mapheader ( xdb , xdb -> slotnpages , rw ) ) { return RPMRC_FAIL ; } } return RPMRC_OK ; } unmapheader ( xdb ) ; } if ( fstat ( xdb -> fd , & stb ) ) { return RPMRC_FAIL ; } if ( rpmxdbReadHeaderRaw ( xdb , & generation , & slotnpages , & pagesize , & usergeneration ) ) { return RPMRC_FAIL ; } if ( stb . st_size % pagesize != 0 ) { return RPMRC_FAIL ; } xdb -> pagesize = pagesize ; if ( mapheader ( xdb , slotnpages , rw ) ) { return RPMRC_FAIL ; } xdb -> firstfree = 0 ; nslots = slotnpages * ( pagesize / SLOT_SIZE ) - SLOT_START + 1 ; slots = xcalloc ( nslots + 1 , sizeof ( xdb_slot ) ) ; usedslots = xcalloc ( nslots + 1 , sizeof ( xdb_slot * ) ) ; nused = 0 ; slotno = 1 ; slot = slots + 1 ; usedblobpages = 0 ; lastfreep = & xdb -> firstfree ; for ( page = 0 , pageptr = xdb -> mapped ; page < slotnpages ; page ++ , pageptr += pagesize ) { unsigned int o ; for ( o = page ?0 : SLOT_START * SLOT_SIZE ; o < pagesize ; o += SLOT_SIZE , slotno ++ , slot ++ ) { unsigned char * pp = pageptr + o ; slot -> slotno = slotno ; slot -> subtag = le2ha ( pp ) ; if ( ( slot -> subtag & 0x00ffffff ) != SLOT_MAGIC ) { free ( slots ) ; unmapheader ( xdb ) ; return RPMRC_FAIL ; } slot -> subtag = ( slot -> subtag >> 24 ) & 255 ; slot -> blobtag = le2ha ( pp + 4 ) ; slot -> startpage = le2ha ( pp + 8 ) ; slot -> pagecnt = le2ha ( pp + 12 ) ; if ( slot -> pagecnt == 0 && slot -> startpage ) { slot -> startpage = slotnpages ; } if ( ! slot -> startpage ) { * lastfreep = slotno ; lastfreep = & slot -> next ; } else { usedslots [ nused ++ ] = slot ; usedblobpages += slot -> pagecnt ; } } } if ( nused > 1 ) { qsort ( usedslots , nused , sizeof ( * usedslots ) , usedslots_cmp ) ; } slots [ 0 ] . pagecnt = slotnpages ; lastslot = slots ; for ( i = 0 ; i < nused ; i ++ , lastslot = slot ) { slot = usedslots [ i ] ; if ( lastslot -> startpage + lastslot -> pagecnt > slot -> startpage ) { free ( slots ) ; free ( usedslots ) ; unmapheader ( xdb ) ; return RPMRC_FAIL ; } lastslot -> next = slot -> slotno ; slot -> prev = lastslot -> slotno ; } lastslot -> next = nslots ; slots [ nslots ] . slotno = nslots ; slots [ nslots ] . prev = lastslot -> slotno ; slots [ nslots ] . startpage = stb . st_size / pagesize ; free ( usedslots ) ; if ( xdb -> slots ) { for ( i = 1 , slot = xdb -> slots + i ; i < xdb -> nslots ; i ++ , slot ++ ) { if ( slot -> startpage && ( slot -> mapped || slot -> mapcallback ) ) { struct xdb_slot * nslot ; if ( i >= nslots || ! slots [ i ] . startpage || slots [ i ] . blobtag != slot -> blobtag || slots [ i ] . subtag != slot -> subtag ) { if ( slot -> mapped ) { unmapslot ( xdb , slot ) ; slot -> mapcallback ( xdb , slot -> mapcallbackdata , 0 , 0 ) ; } continue ; } nslot = slots + i ; if ( slot -> mapcallback ) { nslot -> mapflags = slot -> mapflags ; nslot -> mapcallback = slot -> mapcallback ; nslot -> mapcallbackdata = slot -> mapcallbackdata ; } if ( slot -> startpage != nslot -> startpage || slot -> pagecnt != nslot -> pagecnt ) { if ( slot -> mapped ) { unmapslot ( xdb , slot ) ; } if ( nslot -> mapcallback ) { if ( nslot -> pagecnt ) { mapslot ( xdb , nslot ) ; nslot -> mapcallback ( xdb , nslot -> mapcallbackdata , nslot -> mapped , nslot -> mapped ?nslot -> pagecnt * xdb -> pagesize : 0 ) ; } else { nslot -> mapcallback ( xdb , nslot -> mapcallbackdata , 0 , 0 ) ; } } } else { nslot -> mapped = slot -> mapped ; } } } free ( xdb -> slots ) ; } xdb -> slots = slots ; xdb -> nslots = nslots ; xdb -> generation = generation ; xdb -> slotnpages = slotnpages ; xdb -> usergeneration = usergeneration ; xdb -> usedblobpages = usedblobpages ; return RPMRC_OK ; } 