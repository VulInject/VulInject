memcache_request_dissector ( , , , , , , ) { const guchar * next_token ; int tokenlen ; guint16 flags ; guint32 expiration ; guint32 bytes ; guint64 cas ; gchar response_chars [ 21 ] ; tokenlen = get_token_len ( line , lineend , & next_token ) ; proto_tree_add_item ( tree , hf_command , tvb , offset , tokenlen , ENC_ASCII ) ; offset += ( int ) ( next_token - line ) ; line = next_token ; switch ( opcode ) { case OP_SET : case OP_ADD : case OP_REPLACE : case OP_APPEND : case OP_PREPEND : case OP_CAS : tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return - 1 ; } dissect_key ( tvb , pinfo , tree , offset , tokenlen , opcode , TRUE ) ; offset += ( int ) ( next_token - line ) ; line = next_token ; tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 || tokenlen > 5 ) { return - 1 ; } memcpy ( response_chars , line , tokenlen ) ; response_chars [ tokenlen ] = '\0' ; flags = ( guint16 ) strtoul ( response_chars , NULL , 10 ) ; proto_tree_add_uint ( tree , hf_flags , tvb , offset , tokenlen , flags ) ; offset += ( int ) ( next_token - line ) ; line = next_token ; tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 || tokenlen > 10 ) { return - 1 ; } memcpy ( response_chars , line , tokenlen ) ; response_chars [ tokenlen ] = '\0' ; expiration = ( guint32 ) strtoul ( response_chars , NULL , 10 ) ; proto_tree_add_uint ( tree , hf_expiration , tvb , offset , tokenlen , expiration ) ; offset += ( int ) ( next_token - line ) ; line = next_token ; tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 || tokenlen > 10 ) { return - 1 ; } memcpy ( response_chars , line , tokenlen ) ; response_chars [ tokenlen ] = '\0' ; bytes = ( guint32 ) strtoul ( response_chars , NULL , 10 ) ; proto_tree_add_uint ( tree , hf_value_length , tvb , offset , tokenlen , bytes ) ; offset += ( int ) ( next_token - line ) ; line = next_token ; if ( opcode == OP_CAS ) { tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 || tokenlen > 20 ) { return - 1 ; } memcpy ( response_chars , line , tokenlen ) ; response_chars [ tokenlen ] = '\0' ; cas = ( guint64 ) strtoul ( response_chars , NULL , 10 ) ; proto_tree_add_uint64 ( tree , hf_cas , tvb , offset , tokenlen , cas ) ; offset += ( int ) ( next_token - line ) ; line = next_token ; } tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen != 0 ) { if ( tokenlen == 7 && strncmp ( line , "noreply" , 7 ) == 0 ) { proto_tree_add_item ( tree , hf_noreply , tvb , offset , tokenlen , ENC_ASCII ) ; } offset += ( int ) ( next_token - line ) ; } offset += 2 ; offset = content_data_dissector ( tvb , pinfo , tree , offset , bytes , opcode ) ; if ( offset == - 1 ) { return offset ; } break ; case OP_INCREMENT : case OP_DECREMENT : tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return - 1 ; } dissect_key ( tvb , pinfo , tree , offset , tokenlen , opcode , TRUE ) ; offset += ( int ) ( next_token - line ) ; line = next_token ; tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return - 1 ; } proto_tree_add_item ( tree , hf_value , tvb , offset , tokenlen , ENC_ASCII ) ; offset += ( int ) ( next_token - line ) ; line = next_token ; tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return offset ; } if ( tokenlen == 7 && strncmp ( line , "noreply" , 7 ) == 0 ) { proto_tree_add_item ( tree , hf_noreply , tvb , offset , tokenlen , ENC_ASCII ) ; offset += ( int ) ( next_token - line ) ; line = next_token ; } else { return - 1 ; } tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return offset ; } else { return - 1 ; } break ; case OP_DELETE : tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return - 1 ; } dissect_key ( tvb , pinfo , tree , offset , tokenlen , opcode , TRUE ) ; offset += ( int ) ( next_token - line ) ; line = next_token ; tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return offset ; } if ( tokenlen <= 10 ) { if ( tokenlen == 7 && strncmp ( line , "noreply" , 7 ) == 0 ) { proto_tree_add_item ( tree , hf_noreply , tvb , offset , tokenlen , ENC_ASCII ) ; } else { memcpy ( response_chars , line , tokenlen ) ; response_chars [ tokenlen ] = '\0' ; expiration = ( guint32 ) strtoul ( response_chars , NULL , 10 ) ; proto_tree_add_uint ( tree , hf_expiration , tvb , offset , tokenlen , expiration ) ; } offset += ( int ) ( next_token - line ) ; line = next_token ; } else { return - 1 ; } tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return offset ; } else { return - 1 ; } break ; case OP_GET : case OP_GETS : while ( tokenlen != 0 ) { tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return offset ; } dissect_key ( tvb , pinfo , tree , offset , tokenlen , opcode , TRUE ) ; offset += ( int ) ( next_token - line ) ; line = next_token ; } break ; case OP_STAT : tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return offset ; } else { proto_tree_add_item ( tree , hf_subcommand , tvb , offset , tokenlen , ENC_ASCII ) ; offset += ( int ) ( next_token - line ) ; line = next_token ; } tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return offset ; } else { return - 1 ; } break ; case OP_FLUSH : tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return offset ; } if ( tokenlen <= 10 ) { if ( tokenlen == 7 && strncmp ( line , "noreply" , 7 ) == 0 ) { proto_tree_add_item ( tree , hf_noreply , tvb , offset , tokenlen , ENC_ASCII ) ; } else { memcpy ( response_chars , line , tokenlen ) ; response_chars [ tokenlen ] = '\0' ; expiration = ( guint32 ) strtoul ( response_chars , NULL , 10 ) ; proto_tree_add_uint ( tree , hf_expiration , tvb , offset , tokenlen , expiration ) ; } offset += ( int ) ( next_token - line ) ; line = next_token ; } else { return - 1 ; } tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return offset ; } if ( tokenlen == 7 && strncmp ( line , "noreply" , 7 ) == 0 ) { proto_tree_add_item ( tree , hf_noreply , tvb , offset , tokenlen , ENC_ASCII ) ; offset += ( int ) ( next_token - line ) ; } else { return - 1 ; } break ; case OP_VERBOSE : break ; case OP_VERSION : case OP_QUIT : tokenlen = get_token_len ( line , lineend , & next_token ) ; if ( tokenlen == 0 ) { return offset ; } else { return - 1 ; } default : break ; } return offset ; } 