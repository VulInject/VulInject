cairo_type1_font_subset_write_private_dict ( , ) { cairo_status_t status ; const char * p , * subrs , * charstrings , * array_start , * array_end , * dict_start , * dict_end ; const char * lenIV_start , * lenIV_end , * closefile_token ; char buffer [ 32 ] , * lenIV_str , * subr_count_end , * glyph_count_end ; int ret , lenIV , length ; const cairo_scaled_font_backend_t * backend ; unsigned int i ; int glyph , j ; font -> lenIV = 4 ; if ( ( lenIV_start = find_token ( font -> cleartext , font -> cleartext_end , "/lenIV" ) ) != NULL ) { lenIV_start += 6 ; lenIV_end = find_token ( lenIV_start , font -> cleartext_end , "def" ) ; if ( lenIV_end == NULL ) { return CAIRO_INT_STATUS_UNSUPPORTED ; } lenIV_str = _cairo_malloc ( lenIV_end - lenIV_start + 1 ) ; if ( unlikely ( lenIV_str == NULL ) ) { return _cairo_error ( CAIRO_STATUS_NO_MEMORY ) ; } strncpy ( lenIV_str , lenIV_start , lenIV_end - lenIV_start ) ; lenIV_str [ lenIV_end - lenIV_start ] = 0 ; ret = sscanf ( lenIV_str , "%d" , & lenIV ) ; if ( unlikely ( ret <= 0 ) ) { return CAIRO_INT_STATUS_UNSUPPORTED ; } if ( unlikely ( lenIV < 0 ) ) { return CAIRO_INT_STATUS_UNSUPPORTED ; } font -> lenIV = lenIV ; } subrs = find_token ( font -> cleartext , font -> cleartext_end , "/Subrs" ) ; if ( subrs == NULL ) { font -> subset_subrs = FALSE ; p = font -> cleartext ; array_start = NULL ; skip_subrs } p = subrs + strlen ( "/Subrs" ) ; font -> num_subrs = strtol ( p , & subr_count_end , 10 ) ; if ( subr_count_end == p ) { return CAIRO_INT_STATUS_UNSUPPORTED ; } if ( font -> num_subrs <= 0 ) { return CAIRO_INT_STATUS_UNSUPPORTED ; } font -> subrs = calloc ( font -> num_subrs , sizeof ( font -> subrs [ 0 ] ) ) ; if ( unlikely ( font -> subrs == NULL ) ) { return _cairo_error ( CAIRO_STATUS_NO_MEMORY ) ; } array_start = find_token ( subr_count_end , font -> cleartext_end , "dup" ) ; if ( array_start == NULL ) { return CAIRO_INT_STATUS_UNSUPPORTED ; } status = cairo_type1_font_for_each_subr ( font , array_start , font -> cleartext_end , cairo_type1_font_subset_build_subr_list , & array_end ) ; if ( unlikely ( status ) ) { return status ; } p = array_end ; skip_subrs charstrings = find_token ( p , font -> cleartext_end , "/CharStrings" ) ; if ( charstrings == NULL ) { return CAIRO_INT_STATUS_UNSUPPORTED ; } p = charstrings + strlen ( "/CharStrings" ) ; strtol ( p , & glyph_count_end , 10 ) ; if ( p == glyph_count_end ) { return CAIRO_INT_STATUS_UNSUPPORTED ; } for ( p = glyph_count_end ; p < font -> cleartext_end ; p ++ ) { if ( * p == '/' ) { break ; } } if ( p == font -> cleartext_end ) { return CAIRO_INT_STATUS_UNSUPPORTED ; } dict_start = p ; status = cairo_type1_font_subset_for_each_glyph ( font , dict_start , font -> cleartext_end , cairo_type1_font_subset_build_glyph_list , & dict_end ) ; if ( unlikely ( status ) ) { return status ; } font -> glyphs = _cairo_array_index ( & font -> glyphs_array , 0 ) ; font -> glyph_names = _cairo_array_index ( & font -> glyph_names_array , 0 ) ; font -> base . num_glyphs = _cairo_array_num_elements ( & font -> glyphs_array ) ; font -> subset_index_to_glyphs = calloc ( font -> base . num_glyphs , sizeof font -> subset_index_to_glyphs [ 0 ] ) ; if ( unlikely ( font -> subset_index_to_glyphs == NULL ) ) { return _cairo_error ( CAIRO_STATUS_NO_MEMORY ) ; } backend = font -> scaled_font_subset -> scaled_font -> backend ; if ( ! backend -> index_to_glyph_name ) { return CAIRO_INT_STATUS_UNSUPPORTED ; } for ( i = 0 ; i < font -> scaled_font_subset -> num_glyphs ; i ++ ) { unsigned long index ; status = backend -> index_to_glyph_name ( font -> scaled_font_subset -> scaled_font , font -> glyph_names , font -> base . num_glyphs , font -> scaled_font_subset -> glyphs [ i ] , & index ) ; if ( unlikely ( status ) ) { return status ; } cairo_type1_font_subset_use_glyph ( font , index ) ; } for ( j = 0 ; j < font -> num_glyphs ; j ++ ) { glyph = font -> subset_index_to_glyphs [ j ] ; font -> build_stack . sp = 0 ; font -> ps_stack . sp = 0 ; status = cairo_type1_font_subset_parse_charstring ( font , glyph , font -> glyphs [ glyph ] . encrypted_charstring , font -> glyphs [ glyph ] . encrypted_charstring_length ) ; if ( unlikely ( status ) ) { return status ; } } for ( j = 0 ; j < MIN ( font -> num_subrs , 5 ) ; j ++ ) { font -> subrs [ j ] . used = TRUE ; } closefile_token = find_token ( dict_end , font -> cleartext_end , "closefile" ) ; if ( closefile_token == NULL ) { return CAIRO_INT_STATUS_UNSUPPORTED ; } status = cairo_type1_font_subset_write_header ( font , name ) ; if ( unlikely ( status ) ) { return status ; } font -> base . header_size = _cairo_output_stream_get_position ( font -> output ) ; if ( font -> subset_subrs ) { status = cairo_type1_font_subset_write_encrypted ( font , font -> cleartext , array_start - font -> cleartext ) ; if ( unlikely ( status ) ) { return status ; } status = cairo_type1_font_for_each_subr ( font , array_start , font -> cleartext_end , write_used_subrs , & p ) ; if ( unlikely ( status ) ) { return status ; } } else { p = font -> cleartext ; } status = cairo_type1_font_subset_write_encrypted ( font , p , charstrings - p ) ; if ( unlikely ( status ) ) { return status ; } length = snprintf ( buffer , sizeof buffer , "/CharStrings %d" , font -> num_glyphs ) ; status = cairo_type1_font_subset_write_encrypted ( font , buffer , length ) ; if ( unlikely ( status ) ) { return status ; } status = cairo_type1_font_subset_write_encrypted ( font , glyph_count_end , dict_start - glyph_count_end ) ; if ( unlikely ( status ) ) { return status ; } status = cairo_type1_font_subset_for_each_glyph ( font , dict_start , font -> cleartext_end , write_used_glyphs , & p ) ; if ( unlikely ( status ) ) { return status ; } status = cairo_type1_font_subset_write_encrypted ( font , p , closefile_token - p + strlen ( "closefile" ) + 1 ) ; if ( unlikely ( status ) ) { return status ; } if ( font -> hex_encode ) { _cairo_output_stream_write ( font -> output , "\n" , 1 ) ; } return CAIRO_STATUS_SUCCESS ; } 