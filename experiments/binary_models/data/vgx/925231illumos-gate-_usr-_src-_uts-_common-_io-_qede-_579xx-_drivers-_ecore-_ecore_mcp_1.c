enum _ecore_status_t ecore_mcp_reset ( struct ecore_hwfn * p_hwfn , struct ecore_ptt * p_ptt ) { u32 seq = ++ p_hwfn -> mcp_info -> drv_mb_seq ; u32 delay = CHIP_MCP_RESP_ITER_US ; u32 org_mcp_reset_seq , cnt = 0 ; enum _ecore_status_t rc = ECORE_SUCCESS ; if ( CHIP_REV_IS_EMUL ( p_hwfn -> p_dev ) ) { delay = EMUL_MCP_RESP_ITER_US ; } rc = ecore_mcp_mb_lock ( p_hwfn , DRV_MSG_CODE_MCP_RESET ) ; org_mcp_reset_seq = ecore_rd ( p_hwfn , p_ptt , MISCS_REG_GENERIC_POR_0 ) ; DRV_MB_WR ( p_hwfn , p_ptt , drv_mb_header , ( DRV_MSG_CODE_MCP_RESET | seq ) ) ; { OSAL_UDELAY ( delay ) ; } ( org_mcp_reset_seq == ecore_rd ( p_hwfn , p_ptt , MISCS_REG_GENERIC_POR_0 ) ) && ( cnt ++ < ECORE_MCP_RESET_RETRIES ) ; if ( org_mcp_reset_seq != ecore_rd ( p_hwfn , p_ptt , MISCS_REG_GENERIC_POR_0 ) ) { DP_VERBOSE ( p_hwfn , ECORE_MSG_SP , "MCP was reset after %d usec\n" , cnt * delay ) ; } else { DP_ERR ( p_hwfn , "Failed to reset MCP\n" ) ; rc = ECORE_AGAIN ; } ecore_mcp_mb_unlock ( p_hwfn , DRV_MSG_CODE_MCP_RESET ) ; return rc ; } 