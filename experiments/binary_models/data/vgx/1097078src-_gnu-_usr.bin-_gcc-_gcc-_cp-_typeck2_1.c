build_functional_cast ( , ) tree exp ; tree parms ; { tree type ; if ( exp == error_mark_node || parms == error_mark_node ) { return error_mark_node ; } if ( TREE_CODE ( exp ) == IDENTIFIER_NODE ) { if ( IDENTIFIER_HAS_TYPE_VALUE ( exp ) ) { type = IDENTIFIER_TYPE_VALUE ( exp ) ; } else { type = lookup_name ( exp , 1 ) ; if ( ! type || TREE_CODE ( type ) != TYPE_DECL ) { error ( "`%T' fails to be a typedef or built-in type" , exp ) ; return error_mark_node ; } type = TREE_TYPE ( type ) ; } } if ( TREE_CODE ( exp ) == TYPE_DECL ) { type = TREE_TYPE ( exp ) ; } else { type = exp ; } if ( processing_template_decl ) { return build_min ( CAST_EXPR , type , parms ) ; } if ( ! IS_AGGR_TYPE ( type ) ) { if ( parms == NULL_TREE ) { parms = integer_zero_node ; } else { if ( TREE_CHAIN ( parms ) != NULL_TREE ) { pedwarn ( "initializer list being treated as compound expression" ) ; } parms = build_compound_expr ( parms , NULL ) ; } return build_c_cast ( type , parms ) ; } if ( ! complete_type_or_else ( type , NULL_TREE ) ) { return error_mark_node ; } if ( abstract_virtuals_error ( NULL_TREE , type ) ) { return error_mark_node ; } if ( parms && TREE_CHAIN ( parms ) == NULL_TREE ) { return build_c_cast ( type , TREE_VALUE ( parms ) ) ; } if ( parms == NULL_TREE && ! TYPE_NEEDS_CONSTRUCTING ( type ) && TYPE_HAS_DEFAULT_CONSTRUCTOR ( type ) ) { exp = build ( CONSTRUCTOR , type , NULL_TREE , NULL_TREE ) ; return get_target_expr ( exp ) ; } exp = build_special_member_call ( NULL_TREE , complete_ctor_identifier , parms , TYPE_BINFO ( type ) , LOOKUP_NORMAL ) ; if ( exp == error_mark_node ) { return error_mark_node ; } return build_cplus_new ( type , exp ) ; } 