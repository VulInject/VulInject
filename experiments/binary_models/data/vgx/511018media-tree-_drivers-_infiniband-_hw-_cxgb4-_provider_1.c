static int c4iw_mmap ( struct ib_ucontext * context , struct vm_area_struct * vma ) { int len = vma -> vm_end - vma -> vm_start ; u32 key = vma -> vm_pgoff << PAGE_SHIFT ; struct c4iw_rdev * rdev ; int ret = 0 ; struct c4iw_mm_entry * mm ; struct c4iw_ucontext * ucontext ; u64 addr ; pr_debug ( "%s pgoff 0x%lx key 0x%x len %d\n" , __func__ , vma -> vm_pgoff , key , len ) ; if ( vma -> vm_start & ( PAGE_SIZE - 1 ) ) { return - EINVAL ; } rdev = & ( to_c4iw_dev ( context -> device ) -> rdev ) ; ucontext = to_c4iw_ucontext ( context ) ; mm = remove_mmap ( ucontext , key , len ) ; addr = mm -> addr ; kfree ( mm ) ; if ( ( addr >= pci_resource_start ( rdev -> lldi . pdev , 0 ) ) && ( addr < ( pci_resource_start ( rdev -> lldi . pdev , 0 ) + pci_resource_len ( rdev -> lldi . pdev , 0 ) ) ) ) { vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; ret = io_remap_pfn_range ( vma , vma -> vm_start , addr >> PAGE_SHIFT , len , vma -> vm_page_prot ) ; } if ( ( addr >= pci_resource_start ( rdev -> lldi . pdev , 2 ) ) && ( addr < ( pci_resource_start ( rdev -> lldi . pdev , 2 ) + pci_resource_len ( rdev -> lldi . pdev , 2 ) ) ) ) { if ( addr >= rdev -> oc_mw_pa ) { vma -> vm_page_prot = t4_pgprot_wc ( vma -> vm_page_prot ) ; } else { if ( ! is_t4 ( rdev -> lldi . adapter_type ) ) { vma -> vm_page_prot = t4_pgprot_wc ( vma -> vm_page_prot ) ; } else { vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; } } ret = io_remap_pfn_range ( vma , vma -> vm_start , addr >> PAGE_SHIFT , len , vma -> vm_page_prot ) ; } else { ret = remap_pfn_range ( vma , vma -> vm_start , addr >> PAGE_SHIFT , len , vma -> vm_page_prot ) ; } return ret ; } 