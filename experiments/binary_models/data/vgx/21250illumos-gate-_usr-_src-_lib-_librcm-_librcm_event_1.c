static void door_service ( void * cookie , char * args , size_t alen , door_desc_t * ddp , uint_t ndid ) { nvlist_t * nvl ; int nvl_size = 0 ; char rbuf [ BUF_THRESHOLD ] ; door_cookie_t * cook = ( door_cookie_t * ) cookie ; uint64_t seq_num = 0 ; if ( alen == sizeof ( uint64_t ) ) { free_door_result ( cookie , * ( uint64_t * ) ( void * ) args ) ; ( void ) door_return ( NULL , 0 , NULL , 0 ) ; } * cook -> door_func ( ( void * * ) & args , & alen ) ; if ( args == NULL ) { dprint ( "null results returned from door_func().\n" ) ; ( void ) door_return ( NULL , 0 , NULL , 0 ) ; } nvl = ( nvlist_t * ) ( void * ) args ; args = NULL ; alen = 0 ; if ( errno = nvlist_size ( nvl , & nvl_size , NV_ENCODE_NATIVE ) ) { nvlist_free ( nvl ) ; dprint ( "failure to sizeup door results: %s\n" , strerror ( errno ) ) ; ( void ) door_return ( NULL , 0 , NULL , 0 ) ; } if ( nvl_size > BUF_THRESHOLD ) { ( void ) mutex_lock ( & cook -> door_lock ) ; cook -> seq_num ++ ; seq_num = cook -> seq_num ; ( void ) mutex_unlock ( & cook -> door_lock ) ; ( void ) nvlist_add_uint64 ( nvl , RCM_SEQ_NUM , seq_num ) ; } if ( errno = nvlist_pack ( nvl , & args , & alen , NV_ENCODE_NATIVE , 0 ) ) { nvlist_free ( nvl ) ; dprint ( "failure to pack door results: %s\n" , strerror ( errno ) ) ; ( void ) door_return ( NULL , 0 , NULL , 0 ) ; } nvlist_free ( nvl ) ; if ( alen <= BUF_THRESHOLD ) { bcopy ( args , rbuf , alen ) ; ( void ) free ( args ) ; args = rbuf ; } else { add_door_result ( cook , args , seq_num ) ; } ( void ) door_return ( args , alen , NULL , 0 ) ; } 