static int read_symbols ( struct elf * elf ) { struct section * symtab ; struct symbol * sym ; struct list_head * entry , * tmp ; int symbols_nr , i ; symtab = find_section_by_name ( elf , ".symtab" ) ; if ( ! symtab ) { WARN ( "missing symbol table" ) ; return - 1 ; } symbols_nr = symtab -> sh . sh_size / symtab -> sh . sh_entsize ; for ( i = 0 ; i < symbols_nr ; i ++ ) { sym = malloc ( sizeof ( * sym ) ) ; if ( ! sym ) { perror ( "malloc" ) ; return - 1 ; } sym -> idx = i ; if ( ! gelf_getsym ( symtab -> elf_data , i , & sym -> sym ) ) { perror ( "gelf_getsym" ) ; err } sym -> name = elf_strptr ( elf -> elf , symtab -> sh . sh_link , sym -> sym . st_name ) ; if ( ! sym -> name ) { perror ( "elf_strptr" ) ; err } sym -> type = GELF_ST_TYPE ( sym -> sym . st_info ) ; sym -> bind = GELF_ST_BIND ( sym -> sym . st_info ) ; if ( sym -> sym . st_shndx > SHN_UNDEF && sym -> sym . st_shndx < SHN_LORESERVE ) { sym -> sec = find_section_by_index ( elf , sym -> sym . st_shndx ) ; if ( ! sym -> sec ) { WARN ( "couldn't find section for symbol %s" , sym -> name ) ; err } if ( sym -> type == STT_SECTION ) { sym -> name = sym -> sec -> name ; sym -> sec -> sym = sym ; } } else { sym -> sec = find_section_by_index ( elf , 0 ) ; } sym -> offset = sym -> sym . st_value ; sym -> len = sym -> sym . st_size ; entry = & sym -> sec -> symbol_list ; list_for_each_prev ( , ) { struct symbol * s ; s = list_entry ( tmp , symbol , list ) ; if ( sym -> offset > s -> offset ) { entry = tmp ; break ; } if ( sym -> offset == s -> offset && sym -> len >= s -> len ) { entry = tmp ; break ; } } list_add ( & sym -> list , entry ) ; hash_add ( sym -> sec -> symbol_hash , & sym -> hash , sym -> idx ) ; } return 0 ; err free ( sym ) ; return - 1 ; } 