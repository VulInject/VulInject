static int tonga_populate_all_graphic_levels ( struct pp_hwmgr * hwmgr ) { struct smu7_hwmgr * data = ( smu7_hwmgr * ) ( hwmgr -> backend ) ; struct tonga_smumgr * smu_data = ( tonga_smumgr * ) ( hwmgr -> smu_backend ) ; struct phm_ppt_v1_information * pptable_info = ( phm_ppt_v1_information * ) ( hwmgr -> pptable ) ; struct smu7_dpm_table * dpm_table = & data -> dpm_table ; struct phm_ppt_v1_pcie_table * pcie_table = pptable_info -> pcie_table ; uint8_t pcie_entry_count = ( uint8_t ) data -> dpm_table . pcie_speed_table . count ; uint32_t level_array_address = smu_data -> smu7_data . dpm_table_start + offsetof ( SMU72_Discrete_DpmTable , GraphicsLevel ) ; uint32_t level_array_size = sizeof ( SMU72_Discrete_GraphicsLevel ) * SMU72_MAX_LEVELS_GRAPHICS ; SMU72_Discrete_GraphicsLevel * levels = smu_data -> smc_state_table . GraphicsLevel ; uint32_t i , max_entry ; uint8_t highest_pcie_level_enabled = 0 ; uint8_t lowest_pcie_level_enabled = 0 , mid_pcie_level_enabled = 0 ; uint8_t count = 0 ; int result = 0 ; for ( i = 0 ; i < dpm_table -> sclk_table . count ; i ++ ) { result = tonga_populate_single_graphic_level ( hwmgr , dpm_table -> sclk_table . dpm_levels [ i ] . value , & ( smu_data -> smc_state_table . GraphicsLevel [ i ] ) ) ; if ( result != 0 ) { return result ; } if ( i > 1 ) { smu_data -> smc_state_table . GraphicsLevel [ i ] . DeepSleepDivId = 0 ; } } smu_data -> smc_state_table . GraphicsLevel [ 0 ] . EnabledForActivity = 1 ; if ( dpm_table -> sclk_table . count > 1 ) { smu_data -> smc_state_table . GraphicsLevel [ dpm_table -> sclk_table . count - 1 ] . DisplayWatermark = PPSMC_DISPLAY_WATERMARK_HIGH ; } smu_data -> smc_state_table . GraphicsDpmLevelCount = ( uint8_t ) dpm_table -> sclk_table . count ; data -> dpm_level_enable_mask . sclk_dpm_enable_mask = phm_get_dpm_level_enable_mask_value ( & dpm_table -> sclk_table ) ; if ( pcie_table != NULL ) { PP_ASSERT_WITH_CODE ( 1 , "There must be 1 or more PCIE levels defined in PPTable." , ) max_entry = pcie_entry_count - 1 ; for ( i = 0 ; i < dpm_table -> sclk_table . count ; i ++ ) { smu_data -> smc_state_table . GraphicsLevel [ i ] . pcieDpmLevel = ( uint8_t ) ( ( i < max_entry ) ?i : max_entry ) ; } } else { if ( 0 == data -> dpm_level_enable_mask . pcie_dpm_enable_mask ) { pr_err ( "Pcie Dpm Enablemask is 0 !" ) ; } while ( data -> dpm_level_enable_mask . pcie_dpm_enable_mask && ( ( data -> dpm_level_enable_mask . pcie_dpm_enable_mask & ( 1 << ( highest_pcie_level_enabled + 1 ) ) ) != 0 ) ) { highest_pcie_level_enabled ++ ; } while ( data -> dpm_level_enable_mask . pcie_dpm_enable_mask && ( ( data -> dpm_level_enable_mask . pcie_dpm_enable_mask & ( 1 << lowest_pcie_level_enabled ) ) == 0 ) ) { lowest_pcie_level_enabled ++ ; } while ( ( count < highest_pcie_level_enabled ) && ( ( data -> dpm_level_enable_mask . pcie_dpm_enable_mask & ( 1 << ( lowest_pcie_level_enabled + 1 + count ) ) ) == 0 ) ) { count ++ ; } mid_pcie_level_enabled = ( lowest_pcie_level_enabled + 1 + count ) < highest_pcie_level_enabled ?( lowest_pcie_level_enabled + 1 + count ) : highest_pcie_level_enabled ; for ( i = 2 ; i < dpm_table -> sclk_table . count ; i ++ ) { smu_data -> smc_state_table . GraphicsLevel [ i ] . pcieDpmLevel = highest_pcie_level_enabled ; } smu_data -> smc_state_table . GraphicsLevel [ 0 ] . pcieDpmLevel = lowest_pcie_level_enabled ; smu_data -> smc_state_table . GraphicsLevel [ 1 ] . pcieDpmLevel = mid_pcie_level_enabled ; } result = smu7_copy_bytes_to_smc ( hwmgr , level_array_address , ( uint8_t * ) levels , ( uint32_t ) level_array_size , SMC_RAM_END ) ; return result ; } 