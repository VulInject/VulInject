static int __init txx9dmac_chan_probe ( struct platform_device * pdev ) { struct txx9dmac_chan_platform_data * cpdata = dev_get_platdata ( & pdev -> dev ) ; struct platform_device * dmac_dev = cpdata -> dmac_dev ; struct txx9dmac_platform_data * pdata = dev_get_platdata ( & dmac_dev -> dev ) ; struct txx9dmac_chan * dc ; int err ; int ch = pdev -> id % TXX9_DMA_MAX_NR_CHANNELS ; int irq ; dc = devm_kzalloc ( & pdev -> dev , sizeof ( * dc ) , GFP_KERNEL ) ; if ( ! dc ) { return - ENOMEM ; } dc -> dma . dev = & pdev -> dev ; dc -> dma . device_alloc_chan_resources = txx9dmac_alloc_chan_resources ; dc -> dma . device_free_chan_resources = txx9dmac_free_chan_resources ; dc -> dma . device_terminate_all = txx9dmac_terminate_all ; dc -> dma . device_tx_status = txx9dmac_tx_status ; dc -> dma . device_issue_pending = txx9dmac_issue_pending ; if ( pdata && pdata -> memcpy_chan == ch ) { dc -> dma . device_prep_dma_memcpy = txx9dmac_prep_dma_memcpy ; dma_cap_set ( DMA_MEMCPY , dc -> dma . cap_mask ) ; } else { dc -> dma . device_prep_slave_sg = txx9dmac_prep_slave_sg ; dma_cap_set ( DMA_SLAVE , dc -> dma . cap_mask ) ; dma_cap_set ( DMA_PRIVATE , dc -> dma . cap_mask ) ; } INIT_LIST_HEAD ( & dc -> dma . channels ) ; dc -> ddev = platform_get_drvdata ( dmac_dev , NULL ) ; if ( dc -> ddev -> irq < 0 ) { irq = platform_get_irq ( pdev , 0 ) ; if ( irq < 0 ) { return irq ; } tasklet_setup ( & dc -> tasklet , txx9dmac_chan_tasklet ) ; dc -> irq = irq ; err = devm_request_irq ( & pdev -> dev , dc -> irq , txx9dmac_chan_interrupt , 0 , dev_name ( & pdev -> dev ) , dc ) ; if ( err ) { return err ; } } else { dc -> irq = - 1 ; } dc -> ddev -> chan [ ch ] = dc ; dc -> chan . device = & dc -> dma ; list_add_tail ( & dc -> chan . device_node , & dc -> chan . device -> channels ) ; dma_cookie_init ( & dc -> chan ) ; if ( is_dmac64 ( dc ) ) { dc -> ch_regs = & __txx9dmac_regs ( dc -> ddev ) -> CHAN [ ch ] ; } else { dc -> ch_regs = & __txx9dmac_regs32 ( dc -> ddev ) -> CHAN [ ch ] ; } spin_lock_init ( & dc -> lock ) ; INIT_LIST_HEAD ( & dc -> active_list ) ; INIT_LIST_HEAD ( & dc -> queue ) ; INIT_LIST_HEAD ( & dc -> free_list ) ; txx9dmac_reset_chan ( dc ) ; platform_set_drvdata ( pdev , dc ) ; err = dma_async_device_register ( & dc -> dma ) ; if ( err ) { return err ; } dev_dbg ( & pdev -> dev , "TXx9 DMA Channel (dma%d%s%s)\n" , dc -> dma . dev_id , dma_has_cap ( DMA_MEMCPY , dc -> dma . cap_mask ) ?" memcpy" : "" , dma_has_cap ( DMA_SLAVE , dc -> dma . cap_mask ) ?" slave" : "" ) ; return 0 ; } 