int mptcp_subflow_init_cookie_req ( struct request_sock * req , const struct sock * sk_listener , struct sk_buff * skb ) { struct mptcp_subflow_context * listener = mptcp_subflow_ctx ( sk_listener ) ; struct mptcp_subflow_request_sock * subflow_req = mptcp_subflow_rsk ( req ) ; struct mptcp_options_received mp_opt ; bool opt_mp_capable , opt_mp_join ; int err ; subflow_init_req ( req , sk_listener ) ; mptcp_get_options ( skb , & mp_opt ) ; opt_mp_capable = ! ! ( mp_opt . suboptions & OPTIONS_MPTCP_MPC ) ; opt_mp_join = ! ! ( mp_opt . suboptions & OPTIONS_MPTCP_MPJ ) ; if ( opt_mp_capable && opt_mp_join ) { return - EINVAL ; } if ( opt_mp_capable && listener -> request_mptcp ) { if ( mp_opt . sndr_key == 0 ) { return - EINVAL ; } subflow_req -> local_key = mp_opt . rcvr_key ; err = mptcp_token_new_request ( req ) ; if ( err ) { return err ; } subflow_req -> ssn_offset = TCP_SKB_CB ( skb ) -> seq - 1 ; } if ( opt_mp_join && listener -> request_mptcp ) { if ( ! mptcp_token_join_cookie_init_state ( subflow_req , skb ) ) { return - EINVAL ; } subflow_req -> mp_join = 1 ; subflow_req -> ssn_offset = TCP_SKB_CB ( skb ) -> seq - 1 ; } return 0 ; } 