static void nvmet_passthru_execute_cmd ( struct nvmet_req * req ) { struct nvme_ctrl * ctrl = nvmet_req_subsys ( req ) -> passthru_ctrl ; struct request_queue * q = ctrl -> admin_q ; struct nvme_ns * ns ; struct request * rq = NULL ; unsigned int timeout ; u32 effects ; u16 status ; int ret ; if ( likely ( req -> sq -> qid != 0 ) ) { u32 nsid = le32_to_cpu ( req -> cmd -> common . nsid ) ; ns = nvme_find_get_ns ( ctrl , nsid ) ; if ( unlikely ( ! ns ) ) { pr_err ( "failed to get passthru ns nsid:%u\n" , nsid ) ; status = NVME_SC_INVALID_NS | NVME_SC_DNR ; out } q = ns -> queue ; timeout = nvmet_req_subsys ( req ) -> io_timeout ; } else { timeout = nvmet_req_subsys ( req ) -> admin_timeout ; } rq = blk_mq_alloc_request ( q , nvme_req_op ( req -> cmd ) , 0 ) ; if ( IS_ERR ( rq ) ) { status = NVME_SC_INTERNAL ; out_put_ns } nvme_init_request ( rq , req -> cmd ) ; if ( timeout ) { rq -> timeout = timeout ; } if ( req -> sg_cnt ) { ret = nvmet_passthru_map_sg ( req , rq ) ; if ( unlikely ( ret ) ) { status = NVME_SC_INTERNAL ; out_put_req } } effects = nvme_command_effects ( ctrl , ns , req -> cmd -> common . opcode ) ; if ( req -> p . use_workqueue || ( effects & ~ ( NVME_CMD_EFFECTS_CSUPP | NVME_CMD_EFFECTS_LBCC ) ) ) { INIT_WORK ( & req -> p . work , nvmet_passthru_execute_cmd_work ) ; req -> p . rq = rq ; queue_work ( nvmet_wq , & req -> p . work ) ; } else { rq -> end_io = nvmet_passthru_req_done ; rq -> end_io_data = req ; blk_execute_rq_nowait ( rq , false ) ; } if ( ns ) { nvme_put_ns ( ns ) ; } return ; out_put_req blk_mq_free_request ( rq ) ; out_put_ns if ( ns ) { nvme_put_ns ( ns ) ; } out nvmet_req_complete ( req , status ) ; } 