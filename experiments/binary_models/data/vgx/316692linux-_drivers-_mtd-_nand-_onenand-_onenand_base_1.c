static int onenand_lock_user_prot_reg ( struct mtd_info * mtd , loff_t from , size_t len ) { struct onenand_chip * this = mtd -> priv ; u_char * buf = FLEXONENAND ( this ) ?this -> page_buf : this -> oob_buf ; int retlen ; int ret ; unsigned int otp_lock_offset = ONENAND_OTP_LOCK_OFFSET ; memset ( buf , 0xff , FLEXONENAND ( this ) ?this -> writesize : mtd -> oobsize ) ; from = 0 ; len = FLEXONENAND ( this ) ?mtd -> writesize : 16 ; if ( FLEXONENAND ( this ) ) { otp_lock_offset = FLEXONENAND_OTP_LOCK_OFFSET ; } if ( otp == 1 ) { buf [ otp_lock_offset ] = 0xFC ; } if ( otp == 2 ) { buf [ otp_lock_offset ] = 0xF3 ; } if ( otp == 3 ) { buf [ otp_lock_offset ] = 0xF0 ; } if ( otp != 0 ) { printk ( KERN_DEBUG "[OneNAND] Invalid option selected for OTP\n" ) ; } ret = onenand_otp_walk ( mtd , from , len , & retlen , buf , do_otp_lock , MTD_OTP_USER ) ; return ret ?: retlen ; } 