static int decode_frame ( AVCodecContext * avctx , AVFrame * frame , int * got_frame_ptr , AVPacket * pkt ) { GetBitContext gb ; int16_t pcm_data [ 2 ] ; uint32_t samples ; int8_t channel_hint [ 2 ] ; int ret , chan ; int channels = 1 ; if ( ( ret = init_get_bits8 ( & gb , pkt -> data , pkt -> size ) ) < 0 ) { return ret ; } samples = get_bits_long ( & gb , 32 ) ; if ( samples == 0xffffffff ) { skip_bits_long ( & gb , 32 ) ; samples = get_bits_long ( & gb , 32 ) ; } if ( samples > pkt -> size * 2 ) { return AVERROR_INVALIDDATA ; } channel_hint [ 0 ] = get_sbits ( & gb , 8 ) ; if ( channel_hint [ 0 ] & 0x80 ) { channel_hint [ 0 ] = ~ channel_hint [ 0 ] ; channels = 2 ; } av_channel_layout_uninit ( & avctx -> ch_layout ) ; av_channel_layout_default ( & avctx -> ch_layout , channels ) ; pcm_data [ 0 ] = get_sbits ( & gb , 16 ) ; if ( channels > 1 ) { channel_hint [ 1 ] = get_sbits ( & gb , 8 ) ; pcm_data [ 1 ] = get_sbits ( & gb , 16 ) ; } frame -> nb_samples = samples ; if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) { return ret ; } for ( chan = 0 ; chan < channels ; chan ++ ) { uint16_t * dest = ( uint16_t * ) frame -> data [ 0 ] + chan ; int step_index = channel_hint [ chan ] ; int output = pcm_data [ chan ] ; int sample ; for ( sample = 0 ; sample < samples ; sample ++ ) { int lookup_size , lookup , highbit , lowbits ; step_index = av_clip ( step_index , 0 , 88 ) ; lookup_size = size_table [ step_index ] ; lookup = get_bits ( & gb , lookup_size ) ; highbit = 1 << ( lookup_size - 1 ) ; lowbits = highbit - 1 ; if ( lookup & highbit ) { lookup ^= highbit ; } else { highbit = 0 ; } if ( lookup == lowbits ) { output = get_sbits ( & gb , 16 ) ; } else { int predict_index , diff ; predict_index = ( lookup << ( 7 - lookup_size ) ) | ( step_index << 6 ) ; predict_index = av_clip ( predict_index , 0 , 5785 ) ; diff = predict_table [ predict_index ] ; if ( lookup ) { diff += ff_adpcm_step_table [ step_index ] >> ( lookup_size - 1 ) ; } if ( highbit ) { diff = - diff ; } output = av_clip_int16 ( output + diff ) ; } * dest = output ; dest += channels ; step_index += step_index_tables [ lookup_size - 2 ] [ lookup ] ; } } * got_frame_ptr = 1 ; return pkt -> size ; } const FFCodec ff_adpcm_vima_decoder = { . p . name = "adpcm_vima" CODEC_LONG_NAME ( "LucasArts VIMA audio" ) . p . type = AVMEDIA_TYPE_AUDIO . p . id = AV_CODEC_ID_ADPCM_VIMA . init = decode_init FF_CODEC_DECODE_CB ( decode_frame ) . p . capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF } ; 