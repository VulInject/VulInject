get_local_syms ( , , ) { unsigned int bfd_indx ; Elf_Internal_Sym * local_syms , * * all_local_syms ; int stub_changed = 0 ; struct elf32_hppa_link_hash_table * htab = hppa_link_hash_table ( info ) ; bfd_size_type amt = sizeof ( Elf_Internal_Sym * ) * htab -> bfd_count ; all_local_syms = bfd_zmalloc ( amt ) ; htab -> all_local_syms = all_local_syms ; for ( bfd_indx = 0 ; input_bfd != NULL ; input_bfd = input_bfd -> link_next , bfd_indx ++ ) { Elf_Internal_Shdr * symtab_hdr ; symtab_hdr = & elf_tdata ( input_bfd ) -> symtab_hdr ; if ( symtab_hdr -> sh_info == 0 ) { continue ; } local_syms = ( Elf_Internal_Sym * ) symtab_hdr -> contents ; if ( local_syms == NULL ) { local_syms = bfd_elf_get_elf_syms ( input_bfd , symtab_hdr , symtab_hdr -> sh_info , 0 , NULL , NULL , NULL ) ; symtab_hdr -> contents = ( unsigned char * ) local_syms ; } if ( local_syms == NULL ) { return - 1 ; } all_local_syms [ bfd_indx ] = local_syms ; if ( info -> shared && htab -> multi_subspace ) { struct elf_link_hash_entry * * sym_hashes ; struct elf_link_hash_entry * * end_hashes ; unsigned int symcount ; symcount = ( symtab_hdr -> sh_size / sizeof ( Elf32_External_Sym ) - symtab_hdr -> sh_info ) ; sym_hashes = elf_sym_hashes ( input_bfd ) ; end_hashes = sym_hashes + symcount ; for ( ; sym_hashes < end_hashes ; sym_hashes ++ ) { struct elf32_hppa_link_hash_entry * hash ; hash = ( elf32_hppa_link_hash_entry * ) * sym_hashes ; while ( hash -> elf . root . type == bfd_link_hash_indirect || hash -> elf . root . type == bfd_link_hash_warning ) { hash = ( ( elf32_hppa_link_hash_entry * ) hash -> elf . root . u . i . link ) ; } if ( ( hash -> elf . root . type == bfd_link_hash_defined || hash -> elf . root . type == bfd_link_hash_defweak ) && hash -> elf . type == STT_FUNC && hash -> elf . root . u . def . section -> output_section != NULL && ( hash -> elf . root . u . def . section -> output_section -> owner == output_bfd ) && hash -> elf . root . u . def . section -> owner == input_bfd && ( hash -> elf . elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR ) && ! ( hash -> elf . elf_link_hash_flags & ELF_LINK_FORCED_LOCAL ) && ELF_ST_VISIBILITY ( hash -> elf . other ) == STV_DEFAULT ) { asection * sec ; const char * stub_name ; struct elf32_hppa_stub_hash_entry * stub_entry ; sec = hash -> elf . root . u . def . section ; stub_name = hash -> elf . root . root . string ; stub_entry = hppa_stub_hash_lookup ( & htab -> stub_hash_table , stub_name , FALSE , FALSE ) ; if ( stub_entry == NULL ) { stub_entry = hppa_add_stub ( stub_name , sec , htab ) ; if ( ! stub_entry ) { return - 1 ; } stub_entry -> target_value = hash -> elf . root . u . def . value ; stub_entry -> target_section = hash -> elf . root . u . def . section ; stub_entry -> stub_type = hppa_stub_export ; stub_entry -> h = hash ; stub_changed = 1 ; } else { * _bfd_error_handler ( _ ( "%s: duplicate export stub %s" ) , bfd_archive_filename ( input_bfd ) , stub_name ) ; } } } } } return stub_changed ; } bfd_boolean elf32_hppa_size_stubs ( bfd * output_bfd , bfd * stub_bfd , struct bfd_link_info * info , bfd_boolean multi_subspace , bfd_signed_vma group_size , asection * * add_stub_section ( const char * , asection * ) , void * layout_sections_again ( void ) ) { bfd_size_type stub_group_size ; bfd_boolean stubs_always_before_branch ; bfd_boolean stub_changed ; struct elf32_hppa_link_hash_table * htab = hppa_link_hash_table ( info ) ; htab -> stub_bfd = stub_bfd ; htab -> multi_subspace = multi_subspace ; htab -> add_stub_section = add_stub_section ; htab -> layout_sections_again = layout_sections_again ; stubs_always_before_branch = group_size < 0 ; if ( group_size < 0 ) { stub_group_size = - group_size ; } else { stub_group_size = group_size ; } if ( stub_group_size == 1 ) { if ( stubs_always_before_branch ) { stub_group_size = 7680000 ; if ( htab -> has_17bit_branch || htab -> multi_subspace ) { stub_group_size = 240000 ; } if ( htab -> has_12bit_branch ) { stub_group_size = 7500 ; } } else { stub_group_size = 6971392 ; if ( htab -> has_17bit_branch || htab -> multi_subspace ) { stub_group_size = 217856 ; } if ( htab -> has_12bit_branch ) { stub_group_size = 6808 ; } } } group_sections ( htab , stub_group_size , stubs_always_before_branch ) ; switch ( get_local_syms ( output_bfd , info -> input_bfds , info ) ) { default : if ( htab -> all_local_syms ) { error_ret_free_local } return FALSE ; case 0 : stub_changed = FALSE ; break ; case 1 : stub_changed = TRUE ; break ; } while ( 1 ) { bfd * input_bfd ; unsigned int bfd_indx ; asection * stub_sec ; for ( input_bfd = info -> input_bfds , bfd_indx = 0 ; input_bfd != NULL ; input_bfd = input_bfd -> link_next , bfd_indx ++ ) { Elf_Internal_Shdr * symtab_hdr ; asection * section ; Elf_Internal_Sym * local_syms ; symtab_hdr = & elf_tdata ( input_bfd ) -> symtab_hdr ; if ( symtab_hdr -> sh_info == 0 ) { continue ; } local_syms = htab -> all_local_syms [ bfd_indx ] ; for ( section = input_bfd -> sections ; section != NULL ; section = section -> next ) { Elf_Internal_Rela * internal_relocs , * irelaend , * irela ; if ( ( section -> flags & SEC_RELOC ) == 0 || section -> reloc_count == 0 ) { continue ; } if ( section -> output_section == NULL || section -> output_section -> owner != output_bfd ) { continue ; } internal_relocs = _bfd_elf_link_read_relocs ( input_bfd , section , NULL , NULL , info -> keep_memory ) ; if ( internal_relocs == NULL ) { error_ret_free_local } irela = internal_relocs ; irelaend = irela + section -> reloc_count ; for ( ; irela < irelaend ; irela ++ ) { unsigned int r_type , r_indx ; enum elf32_hppa_stub_type stub_type ; struct elf32_hppa_stub_hash_entry * stub_entry ; asection * sym_sec ; bfd_vma sym_value ; bfd_vma destination ; struct elf32_hppa_link_hash_entry * hash ; char * stub_name ; const asection * id_sec ; r_type = ELF32_R_TYPE ( irela -> r_info ) ; r_indx = ELF32_R_SYM ( irela -> r_info ) ; if ( r_type >= ( unsigned int ) R_PARISC_UNIMPLEMENTED ) { bfd_set_error ( bfd_error_bad_value ) ; error_ret_free_internal if ( elf_section_data ( section ) -> relocs == NULL ) { free ( internal_relocs ) ; } error_ret_free_local } if ( r_type != ( unsigned int ) R_PARISC_PCREL12F && r_type != ( unsigned int ) R_PARISC_PCREL17F && r_type != ( unsigned int ) R_PARISC_PCREL22F ) { continue ; } sym_sec = NULL ; sym_value = 0 ; destination = 0 ; hash = NULL ; if ( r_indx < symtab_hdr -> sh_info ) { Elf_Internal_Sym * sym ; Elf_Internal_Shdr * hdr ; sym = local_syms + r_indx ; hdr = elf_elfsections ( input_bfd ) [ sym -> st_shndx ] ; sym_sec = hdr -> bfd_section ; if ( ELF_ST_TYPE ( sym -> st_info ) != STT_SECTION ) { sym_value = sym -> st_value ; } destination = ( sym_value + irela -> r_addend + sym_sec -> output_offset + sym_sec -> output_section -> vma ) ; } else { int e_indx ; e_indx = r_indx - symtab_hdr -> sh_info ; hash = ( ( elf32_hppa_link_hash_entry * ) elf_sym_hashes ( input_bfd ) [ e_indx ] ) ; while ( hash -> elf . root . type == bfd_link_hash_indirect || hash -> elf . root . type == bfd_link_hash_warning ) { hash = ( ( elf32_hppa_link_hash_entry * ) hash -> elf . root . u . i . link ) ; } if ( hash -> elf . root . type == bfd_link_hash_defined || hash -> elf . root . type == bfd_link_hash_defweak ) { sym_sec = hash -> elf . root . u . def . section ; sym_value = hash -> elf . root . u . def . value ; if ( sym_sec -> output_section != NULL ) { destination = ( sym_value + irela -> r_addend + sym_sec -> output_offset + sym_sec -> output_section -> vma ) ; } } if ( hash -> elf . root . type == bfd_link_hash_undefweak ) { if ( ! info -> shared ) { continue ; } } if ( hash -> elf . root . type == bfd_link_hash_undefined ) { if ( ! ( info -> unresolved_syms_in_objects == RM_IGNORE && ( ELF_ST_VISIBILITY ( hash -> elf . other ) == STV_DEFAULT ) && hash -> elf . type != STT_PARISC_MILLI ) ) { continue ; } } else { bfd_set_error ( bfd_error_bad_value ) ; error_ret_free_internal } } stub_type = hppa_type_of_stub ( section , irela , hash , destination , info ) ; if ( stub_type == hppa_stub_none ) { continue ; } id_sec = htab -> stub_group [ section -> id ] . link_sec ; stub_name = hppa_stub_name ( id_sec , sym_sec , hash , irela ) ; if ( ! stub_name ) { error_ret_free_internal } stub_entry = hppa_stub_hash_lookup ( & htab -> stub_hash_table , stub_name , FALSE , FALSE ) ; if ( stub_entry != NULL ) { free ( stub_name ) ; continue ; } stub_entry = hppa_add_stub ( stub_name , section , htab ) ; if ( stub_entry == NULL ) { free ( stub_name ) ; error_ret_free_internal } stub_entry -> target_value = sym_value ; stub_entry -> target_section = sym_sec ; stub_entry -> stub_type = stub_type ; if ( info -> shared ) { if ( stub_type == hppa_stub_import ) { stub_entry -> stub_type = hppa_stub_import_shared ; } if ( stub_type == hppa_stub_long_branch ) { stub_entry -> stub_type = hppa_stub_long_branch_shared ; } } stub_entry -> h = hash ; stub_changed = TRUE ; } if ( elf_section_data ( section ) -> relocs == NULL ) { free ( internal_relocs ) ; } } } if ( ! stub_changed ) { break ; } for ( stub_sec = htab -> stub_bfd -> sections ; stub_sec != NULL ; stub_sec = stub_sec -> next ) { stub_sec -> _raw_size = 0 ; stub_sec -> _cooked_size = 0 ; } bfd_hash_traverse ( & htab -> stub_hash_table , hppa_size_one_stub , htab ) ; * htab -> layout_sections_again ( ) ; stub_changed = FALSE ; } free ( htab -> all_local_syms ) ; return TRUE ; error_ret_free_local free ( htab -> all_local_syms ) ; return FALSE ; } 