static int spmc_sp_add_sp_region ( struct sp_mem * smem , struct ffa_address_range * mem_reg , struct sp_session * owner_sp , uint8_t highest_permission ) { struct sp_ctx * sp_ctx = NULL ; uint64_t va = READ_ONCE ( mem_reg -> address ) ; int res = FFA_OK ; uint64_t region_len = READ_ONCE ( mem_reg -> page_count ) * SMALL_PAGE_SIZE ; struct mobj * mobj = NULL ; sp_ctx = to_sp_ctx ( owner_sp -> ts_sess . ctx ) ; while ( region_len ) { size_t len = region_len ; struct sp_mem_map_region * region = NULL ; uint16_t prot = 0 ; size_t offs = 0 ; mobj = vm_get_mobj ( & sp_ctx -> uctx , va , & len , & prot , & offs ) ; if ( ( highest_permission & FFA_MEM_ACC_RW ) && ! ( prot & TEE_MATTR_UW ) ) { res = FFA_DENIED ; err } if ( ( highest_permission & FFA_MEM_ACC_EXE ) && ! ( prot & TEE_MATTR_UX ) ) { res = FFA_DENIED ; err } region = calloc ( 1 , sizeof ( * region ) ) ; region -> mobj = mobj ; region -> page_offset = offs ; region -> page_count = len / SMALL_PAGE_SIZE ; if ( ! sp_has_exclusive_access ( region , & sp_ctx -> uctx ) ) { free ( region ) ; res = FFA_DENIED ; err } va += len ; region_len -= len ; SLIST_INSERT_HEAD ( & smem -> regions , region , link ) ; } return FFA_OK ; err mobj_put ( mobj ) ; return res ; } 