static int nf_tables_newset ( struct net * net , struct sock * nlsk , struct sk_buff * skb , const struct nlmsghdr * nlh , const struct nlattr * const nla [ ] ) { const struct nfgenmsg * nfmsg = nlmsg_data ( nlh ) ; u8 genmask = nft_genmask_next ( net ) ; const struct nft_set_ops * ops ; struct nft_af_info * afi ; struct nft_table * table ; struct nft_set * set ; struct nft_ctx ctx ; char name [ NFT_SET_MAXNAMELEN ] ; unsigned int size ; bool create ; u64 timeout ; u32 ktype , dtype , flags , policy , gc_int , objtype ; struct nft_set_desc desc ; unsigned char * udata ; u16 udlen ; int err ; if ( nla [ NFTA_SET_TABLE ] == NULL || nla [ NFTA_SET_NAME ] == NULL || nla [ NFTA_SET_KEY_LEN ] == NULL || nla [ NFTA_SET_ID ] == NULL ) { return - EINVAL ; } ktype = NFT_DATA_VALUE ; if ( nla [ NFTA_SET_KEY_TYPE ] != NULL ) { ktype = ntohl ( nla_get_be32 ( nla [ NFTA_SET_KEY_TYPE ] ) ) ; if ( ( ktype & NFT_DATA_RESERVED_MASK ) == NFT_DATA_RESERVED_MASK ) { return - EINVAL ; } } desc . klen = ntohl ( nla_get_be32 ( nla [ NFTA_SET_KEY_LEN ] ) ) ; if ( desc . klen == 0 || desc . klen > NFT_DATA_VALUE_MAXLEN ) { return - EINVAL ; } flags = 0 ; if ( nla [ NFTA_SET_FLAGS ] != NULL ) { flags = ntohl ( nla_get_be32 ( nla [ NFTA_SET_FLAGS ] ) ) ; if ( flags & ~ ( NFT_SET_ANONYMOUS | NFT_SET_CONSTANT | NFT_SET_INTERVAL | NFT_SET_TIMEOUT | NFT_SET_MAP | NFT_SET_EVAL | NFT_SET_OBJECT ) ) { return - EINVAL ; } if ( ( flags & ( NFT_SET_MAP | NFT_SET_EVAL | NFT_SET_OBJECT ) ) == ( NFT_SET_MAP | NFT_SET_EVAL | NFT_SET_OBJECT ) ) { return - EOPNOTSUPP ; } } dtype = 0 ; if ( nla [ NFTA_SET_DATA_TYPE ] != NULL ) { if ( ! ( flags & NFT_SET_MAP ) ) { return - EINVAL ; } dtype = ntohl ( nla_get_be32 ( nla [ NFTA_SET_DATA_TYPE ] ) ) ; if ( ( dtype & NFT_DATA_RESERVED_MASK ) == NFT_DATA_RESERVED_MASK && dtype != NFT_DATA_VERDICT ) { return - EINVAL ; } if ( dtype != NFT_DATA_VERDICT ) { if ( nla [ NFTA_SET_DATA_LEN ] == NULL ) { return - EINVAL ; } desc . dlen = ntohl ( nla_get_be32 ( nla [ NFTA_SET_DATA_LEN ] ) ) ; if ( desc . dlen == 0 || desc . dlen > NFT_DATA_VALUE_MAXLEN ) { return - EINVAL ; } } else { desc . dlen = sizeof ( nft_verdict ) ; } } if ( flags & NFT_SET_MAP ) { return - EINVAL ; } if ( nla [ NFTA_SET_OBJ_TYPE ] != NULL ) { if ( ! ( flags & NFT_SET_OBJECT ) ) { return - EINVAL ; } objtype = ntohl ( nla_get_be32 ( nla [ NFTA_SET_OBJ_TYPE ] ) ) ; if ( objtype == NFT_OBJECT_UNSPEC || objtype > NFT_OBJECT_MAX ) { return - EINVAL ; } } if ( flags & NFT_SET_OBJECT ) { return - EINVAL ; } else { objtype = NFT_OBJECT_UNSPEC ; } timeout = 0 ; if ( nla [ NFTA_SET_TIMEOUT ] != NULL ) { if ( ! ( flags & NFT_SET_TIMEOUT ) ) { return - EINVAL ; } timeout = msecs_to_jiffies ( be64_to_cpu ( nla_get_be64 ( nla [ NFTA_SET_TIMEOUT ] ) ) ) ; } gc_int = 0 ; if ( nla [ NFTA_SET_GC_INTERVAL ] != NULL ) { if ( ! ( flags & NFT_SET_TIMEOUT ) ) { return - EINVAL ; } gc_int = ntohl ( nla_get_be32 ( nla [ NFTA_SET_GC_INTERVAL ] ) ) ; } policy = NFT_SET_POL_PERFORMANCE ; if ( nla [ NFTA_SET_POLICY ] != NULL ) { policy = ntohl ( nla_get_be32 ( nla [ NFTA_SET_POLICY ] ) ) ; } if ( nla [ NFTA_SET_DESC ] != NULL ) { err = nf_tables_set_desc_parse ( & ctx , & desc , nla [ NFTA_SET_DESC ] ) ; if ( err < 0 ) { return err ; } } create = nlh -> nlmsg_flags & NLM_F_CREATE ?true : false ; afi = nf_tables_afinfo_lookup ( net , nfmsg -> nfgen_family , create ) ; if ( IS_ERR ( afi ) ) { return PTR_ERR ( afi ) ; } table = nf_tables_table_lookup ( afi , nla [ NFTA_SET_TABLE ] , genmask ) ; if ( IS_ERR ( table ) ) { return PTR_ERR ( table ) ; } nft_ctx_init ( & ctx , net , skb , nlh , afi , table , NULL , nla ) ; set = nf_tables_set_lookup ( table , nla [ NFTA_SET_NAME ] , genmask ) ; if ( IS_ERR ( set ) ) { if ( PTR_ERR ( set ) != - ENOENT ) { return PTR_ERR ( set ) ; } } else { if ( nlh -> nlmsg_flags & NLM_F_EXCL ) { return - EEXIST ; } if ( nlh -> nlmsg_flags & NLM_F_REPLACE ) { return - EOPNOTSUPP ; } return 0 ; } if ( ! ( nlh -> nlmsg_flags & NLM_F_CREATE ) ) { return - ENOENT ; } ops = nft_select_set_ops ( nla , & desc , policy ) ; if ( IS_ERR ( ops ) ) { return PTR_ERR ( ops ) ; } udlen = 0 ; if ( nla [ NFTA_SET_USERDATA ] ) { udlen = nla_len ( nla [ NFTA_SET_USERDATA ] ) ; } size = 0 ; if ( ops -> privsize != NULL ) { size = ops -> privsize ( nla ) ; } err = - ENOMEM ; set = kzalloc ( sizeof ( * set ) + size + udlen , GFP_KERNEL ) ; if ( set == NULL ) { err1 } nla_strlcpy ( name , nla [ NFTA_SET_NAME ] , sizeof ( set -> name ) ) ; err = nf_tables_set_alloc_name ( & ctx , set , name ) ; if ( err < 0 ) { err2 } udata = NULL ; if ( udlen ) { udata = set -> data + size ; nla_memcpy ( udata , nla [ NFTA_SET_USERDATA ] , udlen ) ; } INIT_LIST_HEAD ( & set -> bindings ) ; set -> ops = ops ; set -> ktype = ktype ; set -> klen = desc . klen ; set -> dtype = dtype ; set -> objtype = objtype ; set -> dlen = desc . dlen ; set -> flags = flags ; set -> size = desc . size ; set -> policy = policy ; set -> udlen = udlen ; set -> udata = udata ; set -> timeout = timeout ; set -> gc_int = gc_int ; err = ops -> init ( set , & desc , nla ) ; if ( err < 0 ) { err2 } err = nft_trans_set_add ( & ctx , NFT_MSG_NEWSET , set ) ; if ( err < 0 ) { err3 } list_add_tail_rcu ( & set -> list , & table -> sets ) ; table -> use ++ ; return 0 ; err3 ops -> destroy ( set ) ; err2 kfree ( set ) ; err1 module_put ( ops -> owner ) ; return err ; } 