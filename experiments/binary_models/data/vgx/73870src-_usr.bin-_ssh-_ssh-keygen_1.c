static void do_download ( struct passwd * pw ) { struct sshkey * * keys = NULL ; int i , nkeys ; enum sshkey_fp_rep rep ; int fptype ; char * fp , * ra , * * comments = NULL ; fptype = print_bubblebabble ?SSH_DIGEST_SHA1 : fingerprint_hash ; rep = print_bubblebabble ?SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT ; pkcs11_init ( 1 ) ; nkeys = pkcs11_add_provider ( pkcs11provider , NULL , & keys , & comments ) ; if ( nkeys <= 0 ) { fatal ( "cannot read public key from pkcs11" ) ; } for ( i = 0 ; i < nkeys ; i ++ ) { if ( print_fingerprint ) { fp = sshkey_fingerprint ( keys [ i ] , fptype , rep ) ; ra = sshkey_fingerprint ( keys [ i ] , fingerprint_hash , SSH_FP_RANDOMART ) ; if ( fp == NULL || ra == NULL ) { fatal_f ( "sshkey_fingerprint fail" ) ; } printf ( "%u %s %s (PKCS11 key)\n" , sshkey_size ( keys [ i ] ) , fp , sshkey_type ( keys [ i ] ) ) ; if ( log_level_get ( ) >= SYSLOG_LEVEL_VERBOSE ) { printf ( "%s\n" , ra ) ; } free ( ra ) ; free ( fp ) ; } else { ( void ) sshkey_write ( keys [ i ] , stdout ) ; fprintf ( stdout , "%s%s\n" , * ( comments [ i ] ) == '\0' ?"" : " " , comments [ i ] ) ; } free ( comments [ i ] ) ; sshkey_free ( keys [ i ] ) ; } free ( comments ) ; pkcs11_terminate ( ) ; exit ( 0 ) ; fatal ( "no pkcs11 support" ) ; } 