int ccm_mode_encrypt_contiguous_blocks ( ccm_ctx_t * ctx , char * data , size_t length , crypto_data_t * out , size_t block_size , int * encrypt_block ( const void * , const uint8_t * , uint8_t * ) , void * copy_block ( uint8_t * , uint8_t * ) , void * xor_block ( uint8_t * , uint8_t * ) ) { size_t remainder = length ; size_t need ; uint8_t * datap = ( uint8_t * ) data ; uint8_t * blockp ; uint8_t * lastp ; void * iov_or_mp ; offset_t offset ; uint8_t * out_data_1 ; uint8_t * out_data_2 ; size_t out_data_1_len ; uint64_t counter ; uint8_t * mac_buf ; if ( length + ctx -> ccm_remainder_len < block_size ) { bcopy ( datap , ( uint8_t * ) ctx -> ccm_remainder + ctx -> ccm_remainder_len , length ) ; ctx -> ccm_remainder_len += length ; ctx -> ccm_copy_to = datap ; return ( CRYPTO_SUCCESS ) ; } lastp = ( uint8_t * ) ctx -> ccm_cb ; if ( out != NULL ) { crypto_init_ptrs ( out , & iov_or_mp , & offset ) ; } mac_buf = ( uint8_t * ) ctx -> ccm_mac_buf ; { if ( ctx -> ccm_remainder_len > 0 ) { need = block_size - ctx -> ccm_remainder_len ; bcopy ( datap , & ( ( uint8_t * ) ctx -> ccm_remainder ) [ ctx -> ccm_remainder_len ] , need ) ; blockp = ( uint8_t * ) ctx -> ccm_remainder ; } else { blockp = datap ; } xor_block ( blockp , mac_buf ) ; encrypt_block ( ctx -> ccm_keysched , mac_buf , mac_buf ) ; encrypt_block ( ctx -> ccm_keysched , ( uint8_t * ) ctx -> ccm_cb , ( uint8_t * ) ctx -> ccm_tmp ) ; lastp = ( uint8_t * ) ctx -> ccm_tmp ; counter = ntohll ( ctx -> ccm_cb [ 1 ] & ctx -> ccm_counter_mask ) ; counter = htonll ( counter + 1 ) ; counter &= ctx -> ccm_counter_mask ; ctx -> ccm_cb [ 1 ] = ( ctx -> ccm_cb [ 1 ] & ~ ( ctx -> ccm_counter_mask ) ) | counter ; xor_block ( blockp , lastp ) ; ctx -> ccm_processed_data_len += block_size ; if ( out == NULL ) { if ( ctx -> ccm_remainder_len > 0 ) { bcopy ( blockp , ctx -> ccm_copy_to , ctx -> ccm_remainder_len ) ; bcopy ( blockp + ctx -> ccm_remainder_len , datap , need ) ; } } else { crypto_get_ptrs ( out , & iov_or_mp , & offset , & out_data_1 , & out_data_1_len , & out_data_2 , block_size ) ; if ( out_data_1_len == block_size ) { copy_block ( lastp , out_data_1 ) ; } else { bcopy ( lastp , out_data_1 , out_data_1_len ) ; if ( out_data_2 != NULL ) { bcopy ( lastp + out_data_1_len , out_data_2 , block_size - out_data_1_len ) ; } } out -> cd_offset += block_size ; } if ( ctx -> ccm_remainder_len != 0 ) { datap += need ; ctx -> ccm_remainder_len = 0 ; } else { datap += block_size ; } remainder = ( size_t ) & data [ length ] - ( size_t ) datap ; if ( remainder > 0 && remainder < block_size ) { bcopy ( datap , ctx -> ccm_remainder , remainder ) ; ctx -> ccm_remainder_len = remainder ; ctx -> ccm_copy_to = datap ; out } ctx -> ccm_copy_to = NULL ; } remainder > 0 ; out return ( CRYPTO_SUCCESS ) ; } 