static int SigParseOptions ( DetectEngineCtx * de_ctx , Signature * s , char * optstr , char * output , size_t output_size ) { SigTableElmt * st = NULL ; char * optname ; char * optvalue = NULL ; while ( isblank ( * optstr ) ) { optstr ++ ; } char * optend = optstr ; for ( ; ; ) { optend = strchr ( optend , ';' ) ; if ( optend == NULL ) { SCLogError ( "no terminating \";\" found" ) ; error } if ( optend > optstr && * ( optend - 1 ) == '\\' ) { optend ++ ; } else { break ; } } * ( optend ++ ) = '\0' ; char * optvalptr = strchr ( optstr , ':' ) ; if ( optvalptr ) { * ( optvalptr ++ ) = '\0' ; for ( size_t i = strlen ( optvalptr ) ; i > 0 ; i -- ) { if ( isblank ( optvalptr [ i - 1 ] ) ) { optvalptr [ i - 1 ] = '\0' ; } else { break ; } } optvalue = optvalptr ; } for ( size_t i = strlen ( optstr ) ; i > 0 ; i -- ) { if ( isblank ( optstr [ i - 1 ] ) ) { optstr [ i - 1 ] = '\0' ; } else { break ; } } optname = optstr ; st = SigTableGet ( optname ) ; if ( st == NULL || st -> Setup == NULL ) { SCLogError ( "unknown rule keyword '%s'." , optname ) ; error } if ( ! ( st -> flags & ( SIGMATCH_NOOPT | SIGMATCH_OPTIONAL_OPT ) ) ) { if ( optvalue == NULL || strlen ( optvalue ) == 0 ) { SCLogError ( "invalid formatting or malformed option to %s keyword: '%s'" , optname , optstr ) ; error } } if ( st -> flags & SIGMATCH_NOOPT ) { if ( optvalue && strlen ( optvalue ) ) { SCLogError ( "unexpected option to %s keyword: '%s'" , optname , optstr ) ; error } } s -> init_data -> negated = false ; if ( st -> flags & SIGMATCH_INFO_DEPRECATED ) { if ( st -> alternative == 0 ) { SCLogWarning ( "keyword '%s' is deprecated " "and will be removed soon. See %s" , st -> name , URL ) ; } else { SCLogWarning ( "keyword '%s' is deprecated " "and will be removed soon. Use '%s' instead. " "See %s" , st -> name , sigmatch_table [ st -> alternative ] . name , URL ) ; } } int setup_ret = 0 ; if ( optvalue != NULL && strlen ( optvalue ) > 0 ) { size_t ovlen = strlen ( optvalue ) ; char * ptr = optvalue ; while ( ovlen > 0 ) { if ( ! isblank ( * ptr ) ) { break ; } ptr ++ ; ovlen -- ; } if ( ovlen == 0 ) { SCLogError ( "invalid formatting or malformed option to %s keyword: \'%s\'" , optname , optstr ) ; error } if ( ( st -> flags & SIGMATCH_HANDLE_NEGATION ) && * ptr == '!' ) { s -> init_data -> negated = true ; ptr ++ ; ovlen -- ; } while ( ovlen > 0 ) { if ( ! isblank ( * ptr ) ) { break ; } ptr ++ ; ovlen -- ; } if ( ovlen == 0 ) { SCLogError ( "invalid formatting or malformed option to %s keyword: \'%s\'" , optname , optstr ) ; error } if ( st -> flags & SIGMATCH_QUOTES_MANDATORY && ovlen && * ptr != '"' ) { SCLogError ( "invalid formatting to %s keyword: " "value must be double quoted \'%s\'" , optname , optstr ) ; error } if ( ( st -> flags & ( SIGMATCH_QUOTES_OPTIONAL | SIGMATCH_QUOTES_MANDATORY ) ) && ovlen && * ptr == '"' ) { for ( ; ovlen > 0 ; ovlen -- ) { if ( isblank ( ptr [ ovlen - 1 ] ) ) { ptr [ ovlen - 1 ] = '\0' ; } else { break ; } } if ( ovlen && ptr [ ovlen - 1 ] != '"' ) { SCLogError ( "bad option value formatting (possible missing semicolon) " "for keyword %s: \'%s\'" , optname , optvalue ) ; error } if ( ovlen > 1 ) { ptr ++ ; ovlen -- ; ptr [ ovlen - 1 ] = '\0' ; ovlen -- ; } if ( ovlen == 0 ) { SCLogError ( "bad input " "for keyword %s: \'%s\'" , optname , optvalue ) ; error } } else { if ( * ptr == '"' ) { SCLogError ( "quotes on %s keyword that doesn't support them: \'%s\'" , optname , optstr ) ; error } } setup_ret = st -> Setup ( de_ctx , s , ptr ) ; } else { setup_ret = st -> Setup ( de_ctx , s , NULL ) ; } if ( setup_ret < 0 ) { SCLogDebug ( "\"%s\" failed to setup" , st -> name ) ; if ( setup_ret == - 2 ) { enum DetectKeywordId idx = SigTableGetIndex ( st ) ; if ( de_ctx -> sm_types_silent_error [ idx ] == false ) { de_ctx -> sm_types_silent_error [ idx ] = true ; return - 1 ; } return - 2 ; } return setup_ret ; } s -> init_data -> negated = false ; if ( strlen ( optend ) > 0 ) { strlcpy ( output , optend , output_size ) ; return 1 ; } return 0 ; error return - 1 ; } 