int __iptunnel_pull_header ( struct sk_buff * skb , int hdr_len , __be16 inner_proto , bool raw_proto , bool xnet ) { skb_pull_rcsum ( skb , hdr_len ) ; if ( ! raw_proto && inner_proto == htons ( ETH_P_TEB ) ) { struct ethhdr * eh ; if ( unlikely ( ! pskb_may_pull ( skb , ETH_HLEN ) ) ) { return - ENOMEM ; } eh = ( ethhdr * ) skb -> data ; if ( likely ( eth_proto_is_802_3 ( eh -> h_proto ) ) ) { skb -> protocol = eh -> h_proto ; } else { skb -> protocol = htons ( ETH_P_802_2 ) ; } } else { skb -> protocol = inner_proto ; } skb_clear_hash_if_not_l4 ( skb ) ; skb -> vlan_tci = 0 ; skb_set_queue_mapping ( skb , 0 ) ; skb_scrub_packet ( skb , xnet ) ; return iptunnel_pull_offloads ( skb ) ; } 