CK_RV C_Sign ( CK_SESSION_HANDLE hSession , CK_BYTE_PTR pData , CK_ULONG ulDataLen , CK_BYTE_PTR pSignature , CK_ULONG_PTR pulSignatureLen ) { CK_RV rv ; kernel_session_t * session_p ; boolean_t ses_lock_held = B_FALSE ; crypto_sign_t sign ; int r ; if ( ! kernel_initialized ) { return ( CKR_CRYPTOKI_NOT_INITIALIZED ) ; } rv = handle2session ( hSession , & session_p ) ; if ( pulSignatureLen == NULL ) { rv = CKR_ARGUMENTS_BAD ; clean_exit } ( void ) pthread_mutex_lock ( & session_p -> session_mutex ) ; ses_lock_held = B_TRUE ; if ( ! ( session_p -> sign . flags & CRYPTO_OPERATION_ACTIVE ) ) { REFRELE ( session_p , ses_lock_held ) ; return ( CKR_OPERATION_NOT_INITIALIZED ) ; } if ( session_p -> sign . flags & CRYPTO_OPERATION_UPDATE ) { REFRELE ( session_p , ses_lock_held ) ; return ( CKR_FUNCTION_FAILED ) ; } if ( session_p -> sign . flags & CRYPTO_EMULATE ) { if ( ( ulDataLen < SLOT_THRESHOLD ( session_p ) ) || ( ulDataLen > SLOT_HMAC_MAX_INDATA_LEN ( session_p ) ) ) { session_p -> sign . flags |= CRYPTO_EMULATE_USING_SW ; ( void ) pthread_mutex_unlock ( & session_p -> session_mutex ) ; ses_lock_held = B_FALSE ; rv = do_soft_hmac_sign ( get_spp ( & session_p -> sign ) , pData , ulDataLen , pSignature , pulSignatureLen , OP_SINGLE ) ; done } else { free_soft_ctx ( get_sp ( & session_p -> sign ) , OP_SIGN ) ; } } sign . cs_session = session_p -> k_session ; ( void ) pthread_mutex_unlock ( & session_p -> session_mutex ) ; ses_lock_held = B_FALSE ; sign . cs_datalen = ulDataLen ; sign . cs_databuf = ( char * ) pData ; sign . cs_signlen = * pulSignatureLen ; sign . cs_signbuf = ( char * ) pSignature ; while ( ( r = ioctl ( kernel_fd , CRYPTO_SIGN , & sign ) ) < 0 ) { if ( errno != EINTR ) { break ; } } if ( r < 0 ) { rv = CKR_FUNCTION_FAILED ; } else { rv = crypto2pkcs11_error_number ( sign . cs_return_value ) ; } if ( rv == CKR_OK || rv == CKR_BUFFER_TOO_SMALL ) { * pulSignatureLen = sign . cs_signlen ; } done if ( ( rv == CKR_BUFFER_TOO_SMALL ) || ( rv == CKR_OK && pSignature == NULL ) ) { REFRELE ( session_p , ses_lock_held ) ; return ( rv ) ; } clean_exit ( void ) pthread_mutex_lock ( & session_p -> session_mutex ) ; ses_lock_held = B_TRUE ; REINIT_OPBUF ( & session_p -> sign ) ; session_p -> sign . flags = 0 ; REFRELE ( session_p , ses_lock_held ) ; return ( rv ) ; } 