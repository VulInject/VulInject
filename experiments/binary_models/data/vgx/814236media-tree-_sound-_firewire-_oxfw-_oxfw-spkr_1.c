int snd_oxfw_add_spkr ( struct snd_oxfw * oxfw , bool is_lacie ) { static const struct snd_kcontrol_new controls [ ] { { . iface = SNDRV_CTL_ELEM_IFACE_MIXER . name = "PCM Playback Switch" . info = snd_ctl_boolean_mono_info . get = spkr_mute_get . put = spkr_mute_put } { . iface = SNDRV_CTL_ELEM_IFACE_MIXER . name = "PCM Playback Volume" . info = spkr_volume_info . get = spkr_volume_get . put = spkr_volume_put } } ; ; struct fw_spkr * spkr ; unsigned int i , first_ch ; int err ; spkr = kzalloc ( sizeof ( fw_spkr ) , GFP_KERNEL ) ; oxfw -> spec = spkr ; if ( is_lacie ) { spkr -> mixer_channels = 1 ; spkr -> mute_fb_id = 0x01 ; spkr -> volume_fb_id = 0x01 ; } else { spkr -> mixer_channels = 6 ; spkr -> mute_fb_id = 0x01 ; spkr -> volume_fb_id = 0x02 ; } err = avc_audio_feature_volume ( oxfw -> unit , spkr -> volume_fb_id , & spkr -> volume_min , 0 , CTL_MIN , CTL_READ ) ; if ( err < 0 ) { return err ; } err = avc_audio_feature_volume ( oxfw -> unit , spkr -> volume_fb_id , & spkr -> volume_max , 0 , CTL_MAX , CTL_READ ) ; if ( err < 0 ) { return err ; } err = avc_audio_feature_mute ( oxfw -> unit , spkr -> mute_fb_id , & spkr -> mute , CTL_READ ) ; if ( err < 0 ) { return err ; } first_ch = spkr -> mixer_channels == 1 ?0 : 1 ; for ( i = 0 ; i < spkr -> mixer_channels ; ++ i ) { err = avc_audio_feature_volume ( oxfw -> unit , spkr -> volume_fb_id , & spkr -> volume [ i ] , first_ch + i , CTL_CURRENT , CTL_READ ) ; if ( err < 0 ) { return err ; } } for ( i = 0 ; i < ARRAY_SIZE ( controls ) ; ++ i ) { err = snd_ctl_add ( oxfw -> card , snd_ctl_new1 ( & controls [ i ] , oxfw ) ) ; if ( err < 0 ) { return err ; } } return 0 ; } 