static uint8_t FUN1 ( VAR1 * VAR2 , ptrdiff_t VAR3 , uint_t VAR4 , uint_t VAR5 ) { struct VAR6 * VAR7 ; clock_t VAR8 ; VAR9 * VAR10 ; VAR7 = FUN2 ( VAR2 ) ; FUN3 ( VAR7 -> VAR11 ) ; while ( VAR7 -> VAR12 != VAR13 && ! VAR14 ) { FUN4 ( VAR7 -> VAR15 , VAR7 -> VAR11 ) ; } VAR7 -> VAR12 = VAR16 ; VAR7 -> VAR17 = ( VAR7 -> VAR17 + VAR18 ) & VAR19 ; VAR10 = & VAR7 -> VAR20 [ 0 ] ; * VAR10 ++ = VAR21 | VAR7 -> VAR17 | VAR5 ; switch ( VAR5 ) { case VAR22 : * VAR10 ++ = VAR4 & 0x7f ; if ( VAR4 >= 0x80 ) { VAR7 -> VAR20 [ 0 ] |= VAR23 ; } case VAR24 : if ( FUN5 ( VAR3 ) != 0 ) { * VAR10 ++ = FUN5 ( VAR3 ) ; VAR7 -> VAR20 [ 0 ] |= VAR25 ; } * VAR10 ++ = FUN6 ( VAR3 ) ; case VAR26 : break ; } FUN7 ( VAR7 ) ; VAR8 = FUN8 ( ) ; VAR7 -> VAR27 = VAR8 + FUN9 ( VAR28 / 1000 ) ; while ( ! FUN10 ( VAR7 ) ) { if ( FUN8 ( ) > VAR7 -> VAR27 ) { break ; } ( void ) FUN11 ( VAR7 -> VAR15 , VAR7 -> VAR11 , FUN9 ( VAR29 / 1000 ) , VAR30 ) ; } FUN12 ( VAR7 ) ; FUN3 ( VAR7 -> VAR31 ) ; while ( VAR10 > VAR7 -> VAR20 ) { FUN13 ( VAR7 , VAR32 , * -- VAR10 ) ; } FUN14 ( VAR7 -> VAR31 ) ; VAR8 = FUN8 ( ) ; VAR7 -> VAR27 = VAR8 + FUN9 ( VAR33 / 1000 ) ; VAR7 -> VAR34 = 0 ; VAR7 -> VAR35 = VAR36 ; VAR7 -> VAR12 = VAR37 ; while ( VAR7 -> VAR12 == VAR37 ) { if ( FUN11 ( VAR7 -> VAR15 , VAR7 -> VAR11 , FUN9 ( VAR38 / 1000 ) , VAR30 ) == - 1 ) { FUN12 ( VAR7 ) ; } } VAR4 = VAR7 -> VAR35 ; if ( FUN15 ( VAR7 ) ) { VAR4 = VAR36 ; FUN16 ( VAR2 ) = VAR39 ; } if ( VAR7 -> VAR12 != VAR40 ) { if ( VAR7 -> VAR34 != 0 ) { FUN16 ( VAR2 ) = VAR7 -> VAR34 ; } else { FUN16 ( VAR2 ) = VAR41 ; } } VAR7 -> VAR42 = 0 ; VAR7 -> VAR12 = VAR13 ; FUN17 ( VAR7 -> VAR15 ) ; FUN14 ( VAR7 -> VAR11 ) ; return ( VAR4 ) ; }