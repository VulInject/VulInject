cs = AICast_GetCastState ( client ) ; ent = & g_entities [ client ] ; trap_AAS_SetCurrentWorld ( cs -> aasWorldIndex ) ; trap_EA_ResetInput ( client , NULL ) ; cs -> aiFlags &= ~ AIFL_VIEWLOCKED ; ent -> client -> ps . eFlags &= ~ ( EF_NOSWINGANGLES | EF_MONSTER_EFFECT | EF_MONSTER_EFFECT2 | EF_MONSTER_EFFECT3 ) ; if ( ent -> aiCharacter == AICHAR_ZOMBIE ) { if ( COM_BitCheck ( ent -> client -> ps . weapons , WP_MONSTER_ATTACK1 ) ) { cs -> aiFlags |= AIFL_NO_FLAME_DAMAGE ; SET_FLAMING_ZOMBIE ( ent -> s , 1 ) ; } else { SET_FLAMING_ZOMBIE ( ent -> s , 0 ) ; } } if ( ent -> health <= 0 || cs -> revivingTime || cs -> rebirthTime ) { if ( cs -> revivingTime && cs -> revivingTime < level . time ) { ent -> client -> ps . pm_type = PM_NORMAL ; cs -> revivingTime = 0 ; } if ( cs -> rebirthTime && cs -> rebirthTime < level . time ) { vec3_t mins , maxs ; int touch [ 10 ] , numTouch ; float oldmaxZ ; oldmaxZ = ent -> r . maxs [ 2 ] ; AIChar_SetBBox ( ent , cs ) ; VectorAdd ( ent -> r . currentOrigin , ent -> r . mins , mins ) ; VectorAdd ( ent -> r . currentOrigin , ent -> r . maxs , maxs ) ; trap_UnlinkEntity ( ent ) ; numTouch = trap_EntitiesInBox ( mins , maxs , touch , 10 ) ; if ( numTouch ) { for ( i = 0 ; i < numTouch ; i ++ ) { if ( g_entities [ touch [ i ] ] . r . contents & MASK_PLAYERSOLID ) { break ; } } if ( i == numTouch ) { numTouch = 0 ; } } if ( numTouch == 0 ) { ent -> health = ent -> client -> ps . stats [ STAT_HEALTH ] = ent -> client -> ps . stats [ STAT_MAX_HEALTH ] = ( ( cs -> attributes [ STARTING_HEALTH ] - 50 ) > 30 ?( cs -> attributes [ STARTING_HEALTH ] - 50 ) : 30 ) ; ent -> r . contents = CONTENTS_BODY ; ent -> clipmask = MASK_PLAYERSOLID ; ent -> takedamage = qtrue ; ent -> waterlevel = 0 ; ent -> watertype = 0 ; ent -> flags = 0 ; ent -> die = AICast_Die ; ent -> client -> ps . eFlags &= ~ EF_DEAD ; ent -> s . eFlags &= ~ EF_DEAD ; cs -> rebirthTime = 0 ; cs -> deathTime = 0 ; cs -> revivingTime = level . time + BG_AnimScriptEvent ( & ent -> client -> ps , ANIM_ET_REVIVE , qfalse , qtrue ) ; } else { ent -> r . maxs [ 2 ] = oldmaxZ ; ent -> client -> ps . maxs [ 2 ] = ent -> r . maxs [ 2 ] ; } trap_LinkEntity ( ent ) ; } if ( cs -> aiCharacter == AICHAR_ZOMBIE && ! ent -> r . contents ) { ent -> client -> ps . eFlags |= EF_MONSTER_EFFECT2 ; } if ( ent -> health > GIB_HEALTH && cs -> deathTime && cs -> deathTime < ( level . time - 3000 ) ) { cs -> deathTime = 0 ; ent -> r . svFlags &= ~ SVF_BROADCAST ; } return ; } if ( cs -> secondDeadTime ) { BG_UpdateConditionValue ( cs -> entityNum , ANIM_COND_SECONDLIFE , qtrue , qfalse ) ; } else { BG_UpdateConditionValue ( cs -> entityNum , ANIM_COND_SECONDLIFE , qfalse , qfalse ) ; } if ( ent -> health <= 0.25 * cs -> attributes [ STARTING_HEALTH ] ) { BG_UpdateConditionValue ( cs -> entityNum , ANIM_COND_HEALTH_LEVEL , 3 , qfalse ) ; } if ( ent -> health <= 0.5 * cs -> attributes [ STARTING_HEALTH ] ) { BG_UpdateConditionValue ( cs -> entityNum , ANIM_COND_HEALTH_LEVEL , 2 , qfalse ) ; } else { BG_UpdateConditionValue ( cs -> entityNum , ANIM_COND_HEALTH_LEVEL , 1 , qfalse ) ; } cs -> speedScale = 1.0 ; cs -> actionFlags = 0 ; BotAI_GetClientState ( client , & ( cs -> bs -> cur_ps ) ) ; animIndex = BG_GetAnimScriptAnimation ( cs -> entityNum , ent -> client -> ps . aiState , ANIM_MT_WALK ) ; if ( animIndex >= 0 ) { anim = BG_GetAnimationForIndex ( cs -> entityNum , animIndex ) ; cs -> attributes [ WALKING_SPEED ] = anim -> moveSpeed ; } animIndex = BG_GetAnimScriptAnimation ( cs -> entityNum , ent -> client -> ps . aiState , ANIM_MT_WALKCR ) ; if ( animIndex >= 0 ) { anim = BG_GetAnimationForIndex ( cs -> entityNum , animIndex ) ; cs -> attributes [ CROUCHING_SPEED ] = anim -> moveSpeed ; } animIndex = BG_GetAnimScriptAnimation ( cs -> entityNum , ent -> client -> ps . aiState , ANIM_MT_RUN ) ; if ( animIndex >= 0 ) { anim = BG_GetAnimationForIndex ( cs -> entityNum , animIndex ) ; cs -> attributes [ RUNNING_SPEED ] = anim -> moveSpeed ; } ent -> client -> ps . crouchSpeedScale = cs -> attributes [ CROUCHING_SPEED ] / cs -> attributes [ RUNNING_SPEED ] ; ent -> client -> ps . eFlags &= ~ EF_HEADLOOK ; if ( cs -> bs -> enemy >= 0 ) { ent -> client -> ps . eFlags &= ~ EF_STAND_IDLE2 ; } if ( cs -> leaderNum >= 0 && g_entities [ cs -> leaderNum ] . health <= 0 ) { cs -> leaderNum = - 1 ; } { trace_t tr ; vec3_t org ; trap_Trace ( & tr , cs -> bs -> cur_ps . origin , cs -> bs -> cur_ps . mins , cs -> bs -> cur_ps . maxs , cs -> bs -> cur_ps . origin , cs -> entityNum , CONTENTS_SOLID ) ; while ( tr . startsolid ) { VectorCopy ( cs -> bs -> cur_ps . origin , org ) ; org [ 0 ] += 96 * crandom ( ) ; org [ 1 ] += 96 * crandom ( ) ; org [ 2 ] += 16 * crandom ( ) ; trap_Trace ( & tr , org , cs -> bs -> cur_ps . mins , cs -> bs -> cur_ps . maxs , org , cs -> entityNum , CONTENTS_SOLID ) ; G_SetOrigin ( & g_entities [ cs -> entityNum ] , org ) ; VectorCopy ( org , g_entities [ cs -> entityNum ] . client -> ps . origin ) ; } } for ( i = 0 ; i < 3 ; i ++ ) { cs -> bs -> viewangles [ i ] = AngleMod ( cs -> bs -> viewangles [ i ] + SHORT2ANGLE ( cs -> bs -> cur_ps . delta_angles [ i ] ) ) ; } cs -> bs -> ltime += thinktime ; cs -> bs -> thinktime = thinktime ; VectorCopy ( cs -> bs -> cur_ps . origin , cs -> bs -> origin ) ; VectorCopy ( cs -> bs -> cur_ps . origin , cs -> bs -> eye ) ; cs -> bs -> eye [ 2 ] += cs -> bs -> cur_ps . viewheight ; cs -> bs -> areanum = BotPointAreaNum ( cs -> bs -> origin ) ; cs -> bs -> flags = 0 ; if ( cs -> bs -> enemy >= 0 && g_entities [ cs -> bs -> enemy ] . health <= 0 ) { cs -> bs -> enemy = - 1 ; } if ( cs -> movestateType == MSTYPE_TEMPORARY ) { cs -> movestate = MS_DEFAULT ; cs -> movestateType = MSTYPE_NONE ; } if ( ( cs -> bs -> attackcrouch_time > trap_AAS_Time ( ) ) && ( ( cs -> lastAttackCrouch > level . time - 500 ) || ( cs -> thinkFuncChangeTime < level . time - 1000 ) ) ) { if ( VectorLength ( cs -> bs -> cur_ps . velocity ) || ( cs -> lastWeaponFired < level . time - 2000 ) || ( cs -> aiFlags & AIFL_ATTACK_CROUCH ) ) { cs -> lastAttackCrouch = level . time ; trap_EA_Crouch ( cs -> bs -> client ) ; } } AICast_UpdateBattleInventory ( cs , cs -> bs -> enemy ) ; if ( ! ( COM_BitCheck ( cs -> bs -> cur_ps . weapons , cs -> bs -> weaponnum ) ) || ! AICast_GotEnoughAmmoForWeapon ( cs , cs -> bs -> weaponnum ) ) { AICast_ChooseWeapon ( cs , qfalse ) ; } if ( cs -> aiState == AISTATE_QUERY ) { AICast_QueryThink ( cs ) ; } if ( cs -> pauseTime < level . time ) { AICast_ProcessAIFunctions ( cs , thinktime ) ; trap_EA_SelectWeapon ( cs -> bs -> client , cs -> bs -> weaponnum ) ; cs -> castScriptStatusCurrent = cs -> castScriptStatus ; AICast_ScriptRun ( cs , qfalse ) ; } if ( cs -> movestateType != MSTYPE_NONE ) { switch ( cs -> movestate ) { case MS_WALK : cs -> actionFlags |= CASTACTION_WALK ; break ; case MS_CROUCH : trap_EA_Crouch ( cs -> entityNum ) ; break ; default : break ; } } for ( i = 0 ; i < 3 ; i ++ ) { cs -> bs -> viewangles [ i ] = AngleMod ( cs -> bs -> viewangles [ i ] - SHORT2ANGLE ( cs -> bs -> cur_ps . delta_angles [ i ] ) ) ; } 