static void post_process ( Cmd_Info * cmd_info , file_state_t * state ) { Aliste idx ; section_info_table * sinfo ; Word * grpdata , * ngrpdata ; int64_t sno , sno2 ; Word i , j , num ; if ( ! CHK_OPT ( cmd_info , SHF_GROUP_MOVE | SHF_GROUP_DEL ) ) { return ; } if ( CHK_OPT ( cmd_info , SHF_GROUP_DEL ) ) { Word grpcnt ; int deleted = 0 ; for ( APLIST_TRAVERSE ( cmd_info -> sh_groups , idx , sinfo ) ; ) { if ( sinfo -> secno == ( GElf_Word ) DELETED ) { continue ; } num = ( sinfo -> shdr ) . sh_size / sizeof ( Word ) ; grpcnt = 0 ; grpdata = ( Word * ) ( sinfo -> data -> d_buf ) ; for ( i = 1 ; i < num ; i ++ ) { if ( state -> sec_table [ grpdata [ i ] ] . secno != ( GElf_Word ) DELETED ) { grpcnt ++ ; } } if ( grpcnt == 0 ) { sinfo -> secno = ( GElf_Word ) DELETED ; ( cmd_info -> no_of_delete ) ++ ; deleted = 1 ; } } if ( deleted ) { section_info_table * sinfo ; sno = 1 ; sno2 = 1 ; while ( state -> sec_table [ sno ] . scn != ( Elf_Scn * ) - 1 ) { sinfo = & state -> sec_table [ sno ] ; if ( sinfo -> secno != ( GElf_Word ) DELETED ) { sinfo -> secno = sno2 ++ ; } sno ++ ; } } } for ( APLIST_TRAVERSE ( cmd_info -> sh_groups , idx , sinfo ) ; ) { if ( sinfo -> secno == ( GElf_Word ) DELETED ) { continue ; } num = ( sinfo -> shdr ) . sh_size / sizeof ( Word ) ; if ( ( sinfo -> mdata = malloc ( sizeof ( Elf_Data ) ) ) == NULL ) { error_message ( MALLOC_ERROR , PLAIN_ERROR , NULL , prog ) ; mcs_exit ( FAILURE ) ; } * ( sinfo -> mdata ) = * ( sinfo -> data ) ; if ( ( ngrpdata = sinfo -> mdata -> d_buf = malloc ( sinfo -> data -> d_size ) ) == NULL ) { error_message ( MALLOC_ERROR , PLAIN_ERROR , NULL , prog ) ; mcs_exit ( FAILURE ) ; } grpdata = ( Word * ) ( sinfo -> data -> d_buf ) ; ngrpdata [ 0 ] = grpdata [ 0 ] ; j = 1 ; for ( i = 1 ; i < num ; i ++ ) { if ( state -> sec_table [ grpdata [ i ] ] . secno != ( GElf_Word ) DELETED ) { ngrpdata [ j ++ ] = state -> sec_table [ grpdata [ i ] ] . secno ; } } sinfo -> mdata -> d_size = j * sizeof ( Word ) ; sinfo -> data = sinfo -> mdata ; } cmd_info -> sh_groups = NULL ; } 