ecma_builtin_array_prototype_object_sort ( , , ) { if ( ! ecma_is_value_undefined ( arg1 ) && ! ecma_op_is_callable ( arg1 ) ) { return ecma_raise_type_error ( ECMA_ERR_MSG ( "Compare function is not callable" ) ) ; } ecma_length_t len ; ecma_value_t len_value = ecma_op_object_get_length ( obj_p , & len ) ; if ( ECMA_IS_VALUE_ERROR ( len_value ) ) { return len_value ; } ecma_collection_t * array_index_props_p = ecma_new_collection ( ) ; for ( uint32_t i = 0 ; i < len ; i ++ ) { ecma_string_t * prop_name_p = ecma_new_ecma_string_from_uint32 ( i ) ; ecma_property_descriptor_t prop_desc ; ecma_value_t get_desc = ecma_op_object_get_own_property_descriptor ( obj_p , prop_name_p , & prop_desc ) ; if ( ECMA_IS_VALUE_ERROR ( get_desc ) ) { ecma_deref_ecma_string ( prop_name_p ) ; return get_desc ; } if ( ecma_is_value_true ( get_desc ) ) { ecma_ref_ecma_string ( prop_name_p ) ; ecma_collection_push_back ( array_index_props_p , ecma_make_string_value ( prop_name_p ) ) ; ecma_free_property_descriptor ( & prop_desc ) ; continue ; } } uint32_t defined_prop_count = array_index_props_p -> item_count ; ecma_value_t ret_value = ECMA_VALUE_ERROR ; uint32_t copied_num = 0 ; JMEM_DEFINE_LOCAL_ARRAY ( values_buffer , defined_prop_count , ecma_value_t ) ; ecma_value_t * buffer_p = array_index_props_p -> buffer_p ; for ( uint32_t i = 0 ; i < array_index_props_p -> item_count ; i ++ ) { ecma_string_t * property_name_p = ecma_get_string_from_value ( buffer_p [ i ] ) ; uint32_t index = ecma_string_get_array_index ( property_name_p ) ; JERRY_ASSERT ( index != ECMA_STRING_NOT_ARRAY_INDEX ) ; if ( index >= len ) { break ; } ecma_value_t index_value = ecma_op_object_get ( obj_p , property_name_p ) ; if ( ECMA_IS_VALUE_ERROR ( index_value ) ) { clean_up } values_buffer [ copied_num ++ ] = index_value ; } JERRY_ASSERT ( copied_num == defined_prop_count ) ; if ( copied_num > 1 ) { const ecma_builtin_helper_sort_compare_fn_t sort_cb = & ecma_builtin_array_prototype_object_sort_compare_helper ; ecma_value_t sort_value = ecma_builtin_helper_array_merge_sort_helper ( values_buffer , ( uint32_t ) ( copied_num ) , arg1 , sort_cb , NULL ) ; if ( ECMA_IS_VALUE_ERROR ( sort_value ) ) { clean_up } ecma_free_value ( sort_value ) ; } for ( uint32_t index = 0 ; index < copied_num ; index ++ ) { ecma_value_t put_value = ecma_op_object_put_by_index ( obj_p , index , values_buffer [ index ] , true ) ; if ( ECMA_IS_VALUE_ERROR ( put_value ) ) { clean_up } } ret_value = ECMA_VALUE_EMPTY ; clean_up for ( uint32_t index = 0 ; index < copied_num ; index ++ ) { ecma_free_value ( values_buffer [ index ] ) ; } JMEM_FINALIZE_LOCAL_ARRAY ( values_buffer ) ; if ( ECMA_IS_VALUE_ERROR ( ret_value ) ) { ecma_collection_free ( array_index_props_p ) ; return ret_value ; } JERRY_ASSERT ( ecma_is_value_empty ( ret_value ) ) ; ecma_value_t * buffer_p = array_index_props_p -> buffer_p ; for ( uint32_t i = 0 ; i < array_index_props_p -> item_count ; i ++ ) { ecma_string_t * property_name_p = ecma_get_string_from_value ( buffer_p [ i ] ) ; uint32_t index = ecma_string_get_array_index ( property_name_p ) ; JERRY_ASSERT ( index != ECMA_STRING_NOT_ARRAY_INDEX ) ; if ( index >= copied_num && index < len ) { ecma_value_t del_value = ecma_op_object_delete ( obj_p , property_name_p , true ) ; if ( ECMA_IS_VALUE_ERROR ( del_value ) ) { ecma_collection_free ( array_index_props_p ) ; return del_value ; } } } ecma_collection_free ( array_index_props_p ) ; return ecma_copy_value ( this_arg ) ; } 