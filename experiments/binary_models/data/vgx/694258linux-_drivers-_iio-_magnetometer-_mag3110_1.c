static int mag3110_probe ( struct i2c_client * client ) { const struct i2c_device_id * id = i2c_client_get_device_id ( client ) ; struct mag3110_data * data ; struct iio_dev * indio_dev ; int ret ; indio_dev = devm_iio_device_alloc ( & client -> dev , sizeof ( * data ) ) ; if ( ! indio_dev ) { return - ENOMEM ; } data = iio_priv ( indio_dev ) ; data -> vdd_reg = devm_regulator_get ( & client -> dev , "vdd" ) ; if ( IS_ERR ( data -> vdd_reg ) ) { return dev_err_probe ( & client -> dev , PTR_ERR ( data -> vdd_reg ) , "failed to get VDD regulator!\n" ) ; } data -> vddio_reg = devm_regulator_get ( & client -> dev , "vddio" ) ; if ( IS_ERR ( data -> vddio_reg ) ) { return dev_err_probe ( & client -> dev , PTR_ERR ( data -> vddio_reg ) , "failed to get VDDIO regulator!\n" ) ; } ret = regulator_enable ( data -> vdd_reg ) ; if ( ret ) { dev_err ( & client -> dev , "failed to enable VDD regulator!\n" ) ; return ret ; } ret = regulator_enable ( data -> vddio_reg ) ; if ( ret ) { dev_err ( & client -> dev , "failed to enable VDDIO regulator!\n" ) ; disable_regulator_vdd } ret = i2c_smbus_read_byte_data ( client , MAG3110_WHO_AM_I ) ; if ( ret < 0 ) { disable_regulators } if ( ret != MAG3110_DEVICE_ID ) { ret = - ENODEV ; disable_regulators } data -> client = client ; mutex_init ( & data -> lock ) ; i2c_set_clientdata ( client , indio_dev ) ; indio_dev -> info = & mag3110_info ; indio_dev -> name = id -> name ; indio_dev -> modes = INDIO_DIRECT_MODE ; indio_dev -> channels = mag3110_channels ; indio_dev -> num_channels = ARRAY_SIZE ( mag3110_channels ) ; indio_dev -> available_scan_masks = mag3110_scan_masks ; data -> ctrl_reg1 = MAG3110_CTRL_DR_DEFAULT << MAG3110_CTRL_DR_SHIFT ; data -> sleep_val = mag3110_calculate_sleep ( data ) ; if ( data -> sleep_val < 40 ) { data -> ctrl_reg1 |= MAG3110_CTRL_AC ; } ret = mag3110_change_config ( data , MAG3110_CTRL_REG1 , data -> ctrl_reg1 ) ; if ( ret < 0 ) { disable_regulators } ret = i2c_smbus_write_byte_data ( client , MAG3110_CTRL_REG2 , MAG3110_CTRL_AUTO_MRST_EN ) ; if ( ret < 0 ) { standby_on_error } ret = iio_triggered_buffer_setup ( indio_dev , NULL , mag3110_trigger_handler , NULL ) ; if ( ret < 0 ) { standby_on_error } ret = iio_device_register ( indio_dev ) ; if ( ret < 0 ) { buffer_cleanup } return 0 ; buffer_cleanup iio_triggered_buffer_cleanup ( indio_dev , NULL ) ; standby_on_error mag3110_standby ( iio_priv ( indio_dev ) ) ; disable_regulators regulator_disable ( data -> vddio_reg ) ; disable_regulator_vdd regulator_disable ( data -> vdd_reg ) ; return ret ; } 