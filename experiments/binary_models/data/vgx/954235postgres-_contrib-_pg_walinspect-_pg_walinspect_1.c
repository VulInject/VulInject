static void GetWALFPIInfo ( FunctionCallInfo fcinfo , XLogReaderState * record ) { int block_id ; ReturnSetInfo * rsinfo = ( ReturnSetInfo * ) fcinfo -> resultinfo ; for ( block_id = 0 ; block_id <= XLogRecMaxBlockId ( record ) ; block_id ++ ) { PGAlignedBlock buf ; Page page ; bytea * raw_page ; BlockNumber blk ; RelFileLocator rnode ; ForkNumber fork ; Datum values [ PG_GET_WAL_FPI_INFO_COLS ] { 0 } ; ; bool nulls [ PG_GET_WAL_FPI_INFO_COLS ] { 0 } ; ; int i = 0 ; if ( ! XLogRecHasBlockImage ( record , block_id ) ) { continue ; } page = ( Page ) buf . data ; if ( ! RestoreBlockImage ( record , block_id , page ) ) { ereport ( ERROR , ( errcode ( ERRCODE_INTERNAL_ERROR ) , errmsg_internal ( "%s" , record -> errormsg_buf ) ) ) ; } ( void ) XLogRecGetBlockTagExtended ( record , block_id , & rnode , & fork , & blk , NULL ) ; values [ i ++ ] = LSNGetDatum ( record -> ReadRecPtr ) ; values [ i ++ ] = ObjectIdGetDatum ( rnode . spcOid ) ; values [ i ++ ] = ObjectIdGetDatum ( rnode . dbOid ) ; values [ i ++ ] = ObjectIdGetDatum ( rnode . relNumber ) ; values [ i ++ ] = Int64GetDatum ( ( int64 ) blk ) ; if ( fork >= 0 && fork <= MAX_FORKNUM ) { values [ i ++ ] = CStringGetTextDatum ( forkNames [ fork ] ) ; } else { ereport ( ERROR , ( errcode ( ERRCODE_INTERNAL_ERROR ) , errmsg_internal ( "invalid fork number: %u" , fork ) ) ) ; } raw_page = ( bytea * ) palloc ( BLCKSZ + VARHDRSZ ) ; SET_VARSIZE ( raw_page , BLCKSZ + VARHDRSZ ) ; memcpy ( VARDATA ( raw_page ) , page , BLCKSZ ) ; values [ i ++ ] = PointerGetDatum ( raw_page ) ; Assert ( i == PG_GET_WAL_FPI_INFO_COLS ) ; tuplestore_putvalues ( rsinfo -> setResult , rsinfo -> setDesc , values , nulls ) ; } } 