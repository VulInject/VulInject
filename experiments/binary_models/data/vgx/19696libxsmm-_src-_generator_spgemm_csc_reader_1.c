void libxsmm_sparse_csc_reader ( libxsmm_generated_code * io_generated_code , const char * i_csc_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * io_row_count , unsigned int * io_column_count , unsigned int * o_element_count ) { FILE * l_csc_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_column_idx_id = NULL ; unsigned int l_i = 0 ; l_csc_file_handle = fopen ( i_csc_file_in , "r" ) ; if ( l_csc_file_handle == NULL ) { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_INPUT ) ; return ; } while ( fgets ( l_line , l_line_length , l_csc_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; * io_row_count = * io_column_count = * o_element_count = 0 ; * o_row_idx = * o_column_idx = NULL ; * o_values = NULL ; fclose ( l_csc_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_READ_LEN ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { unsigned int row_count , column_count , element_count ; if ( 3 == sscanf ( l_line , "%u %u %u" , & row_count , & column_count , & element_count ) && 0 != row_count && 0 != column_count && 0 != * o_element_count ) { * io_column_count = LIBXSMM_MAX ( * io_column_count , column_count ) ; * io_row_count = LIBXSMM_MAX ( * io_row_count , row_count ) ; * o_element_count = LIBXSMM_MAX ( 1 , element_count ) ; * o_row_idx = ( unsigned int * ) calloc ( * o_element_count , ( unsigned int ) ) ; * o_column_idx = ( unsigned int * ) calloc ( ( size_t ) * io_column_count + 1 , ( unsigned int ) ) ; * o_values = ( double * ) calloc ( * o_element_count , sizeof ( double ) ) ; l_column_idx_id = ( unsigned int * ) calloc ( * io_column_count , ( unsigned int ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_column_idx_id == NULL ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * io_row_count = * io_column_count = * o_element_count = 0 ; * o_row_idx = * o_column_idx = NULL ; * o_values = NULL ; fclose ( l_csc_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_ALLOC_DATA ) ; return ; } for ( l_i = 0 ; l_i <= * io_column_count ; ++ l_i ) { ( * o_column_idx ) [ l_i ] = * o_element_count ; } ( * o_column_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_READ_DESC ) ; fclose ( l_csc_file_handle ) ; return ; } } else { unsigned int l_row = 0 , l_column = 0 ; double l_value = 0 ; if ( sscanf ( l_line , "%u %u %lf" , & l_row , & l_column , & l_value ) != 3 || l_row > * io_row_count || l_column > * io_column_count || l_i >= * o_element_count ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * io_row_count = * io_column_count = * o_element_count = 0 ; * o_row_idx = * o_column_idx = NULL ; * o_values = NULL ; fclose ( l_csc_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_READ_ELEMS ) ; return ; } LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ; l_row -- ; l_column -- ; ( * o_row_idx ) [ l_i ] = l_row ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_column_idx_id [ l_column ] = 1 ; ( * o_column_idx ) [ l_column + 1 ] = l_i ; } } } fclose ( l_csc_file_handle ) ; if ( l_i != ( * o_element_count ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * io_row_count = * io_column_count = * o_element_count = 0 ; * o_row_idx = * o_column_idx = NULL ; * o_values = NULL ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_LEN ) ; return ; } if ( l_column_idx_id != NULL ) { for ( l_i = 0 ; l_i < ( * io_column_count ) ; l_i ++ ) { if ( l_column_idx_id [ l_i ] == 0 ) { ( * o_column_idx ) [ l_i + 1 ] = ( * o_column_idx ) [ l_i ] ; } } free ( l_column_idx_id ) ; } } 