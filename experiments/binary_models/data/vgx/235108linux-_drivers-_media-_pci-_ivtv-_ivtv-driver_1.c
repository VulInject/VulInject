static int FUN1 ( struct VAR1 * VAR2 , const struct VAR3 * VAR4 ) { int VAR5 = 0 ; int VAR6 ; struct VAR7 * VAR8 ; VAR8 = FUN2 ( sizeof ( VAR7 ) , VAR9 ) ; if ( VAR8 == NULL ) { return - VAR10 ; } VAR8 -> VAR2 = VAR2 ; VAR8 -> VAR11 = FUN3 ( & VAR8 -> VAR12 , "" , & VAR13 ) ; VAR5 = FUN4 ( & VAR2 -> VAR14 , & VAR8 -> VAR12 ) ; if ( VAR5 ) { return VAR5 ; } FUN5 ( "" , VAR8 -> VAR11 ) ; FUN6 ( VAR8 ) ; if ( VAR8 -> VAR15 . VAR16 == - 1 ) { VAR5 = - VAR17 ; VAR18 } if ( FUN7 ( VAR8 ) ) { VAR5 = - VAR10 ; VAR18 } VAR5 = FUN8 ( & VAR8 -> VAR19 , 50 ) ; if ( VAR5 ) { VAR18 } VAR8 -> VAR12 . VAR20 = & VAR8 -> VAR19 . VAR21 ; VAR8 -> VAR19 . VAR22 = & VAR23 ; VAR8 -> VAR19 . VAR24 = VAR8 ; VAR8 -> VAR19 . VAR25 = VAR26 ; FUN9 ( "" , ( VAR27 ) VAR8 -> VAR28 ) ; VAR5 = FUN10 ( VAR8 , VAR2 , VAR4 ) ; if ( VAR5 == - VAR29 ) { VAR30 } if ( VAR5 == - VAR31 ) { VAR32 } FUN9 ( "" , ( VAR27 ) VAR8 -> VAR28 + VAR33 , VAR34 ) ; VAR8 -> VAR35 = FUN11 ( VAR8 -> VAR28 + VAR33 , VAR34 ) ; if ( ! VAR8 -> VAR35 ) { FUN12 ( "" ) ; FUN12 ( "" ) ; FUN12 ( "" ) ; FUN12 ( "" ) ; VAR5 = - VAR10 ; VAR32 } if ( VAR8 -> VAR36 ) { FUN9 ( "" , ( VAR27 ) VAR8 -> VAR28 + VAR37 , VAR38 ) ; VAR8 -> VAR39 = FUN11 ( VAR8 -> VAR28 + VAR37 , VAR38 ) ; if ( ! VAR8 -> VAR39 ) { FUN12 ( "" ) ; FUN12 ( "" ) ; FUN12 ( "" ) ; FUN12 ( "" ) ; VAR5 = - VAR10 ; VAR32 } } else { VAR8 -> VAR39 = VAR8 -> VAR35 ; } FUN9 ( "" , ( VAR27 ) VAR8 -> VAR28 + VAR40 , VAR41 ) ; VAR8 -> VAR42 = FUN11 ( VAR8 -> VAR28 + VAR40 , VAR41 ) ; if ( ! VAR8 -> VAR42 ) { FUN12 ( "" ) ; FUN12 ( "" ) ; FUN12 ( "" ) ; FUN12 ( "" ) ; VAR5 = - VAR10 ; VAR43 } VAR5 = FUN13 ( VAR8 ) ; if ( VAR5 ) { VAR43 } FUN9 ( "" ) ; if ( FUN14 ( VAR8 ) ) { FUN12 ( "" ) ; VAR43 } if ( VAR8 -> VAR44 -> VAR45 & VAR46 ) { FUN15 ( VAR8 ) ; } if ( VAR8 -> VAR44 -> VAR47 ) { FUN5 ( "" , VAR8 -> VAR44 -> VAR47 ) ; } if ( VAR8 -> VAR44 -> VAR48 == 0 ) { VAR5 = - VAR17 ; VAR49 } if ( VAR8 -> VAR50 == 0 ) { VAR8 -> VAR50 = VAR51 ; } if ( VAR8 -> VAR15 . VAR52 == - 1 ) { int VAR53 ; for ( VAR53 = 0 ; VAR53 < VAR54 ; VAR53 ++ ) { if ( ( VAR8 -> VAR50 & VAR8 -> VAR44 -> VAR55 [ VAR53 ] . VAR50 ) == 0 ) { continue ; } VAR8 -> VAR15 . VAR52 = VAR8 -> VAR44 -> VAR55 [ VAR53 ] . VAR52 ; break ; } } if ( VAR8 -> VAR15 . VAR52 == - 1 && VAR8 -> VAR44 -> VAR55 [ 0 ] . VAR50 ) { VAR8 -> VAR50 = VAR8 -> VAR44 -> VAR55 [ 0 ] . VAR50 ; if ( VAR8 -> VAR50 & VAR56 ) { VAR8 -> VAR50 = VAR57 | VAR58 ; } if ( VAR8 -> VAR50 & VAR59 ) { VAR8 -> VAR50 = VAR51 ; } if ( VAR8 -> VAR50 & VAR60 ) { VAR8 -> VAR50 = VAR61 ; } VAR8 -> VAR15 . VAR52 = VAR8 -> VAR44 -> VAR55 [ 0 ] . VAR52 ; } if ( VAR8 -> VAR15 . VAR62 == - 1 ) { VAR8 -> VAR15 . VAR62 = ( VAR8 -> VAR44 -> VAR63 . VAR64 != 0 ) ; } FUN16 ( VAR8 ) ; FUN17 ( VAR8 ) ; if ( VAR8 -> VAR50 & VAR65 ) { VAR8 -> VAR66 = 1 ; VAR8 -> VAR67 = 1 ; } else { VAR8 -> VAR68 = 1 ; VAR8 -> VAR69 = 1 ; } VAR8 -> VAR70 . VAR71 = 720 ; VAR8 -> VAR70 . VAR72 = VAR8 -> VAR69 ?576 : 480 ; VAR8 -> VAR70 . VAR73 = VAR8 -> VAR70 . VAR71 ; VAR8 -> VAR70 . VAR74 = VAR8 -> VAR70 . VAR72 ; FUN18 ( & VAR8 -> VAR19 , VAR8 -> VAR68 ) ; VAR8 -> VAR75 [ VAR76 ] = 0x08000 ; VAR8 -> VAR75 [ VAR77 ] = 0x01200 ; VAR8 -> VAR75 [ VAR78 ] = 0x10000 ; VAR8 -> VAR75 [ VAR79 ] = 0x10000 ; VAR8 -> VAR75 [ VAR80 ] = 0x08000 ; VAR8 -> VAR81 . VAR82 = 1456 ; VAR6 = VAR8 -> VAR81 . VAR82 * ( VAR8 -> VAR66 ?24 : 36 ) / 2 ; VAR8 -> VAR75 [ VAR83 ] = VAR6 ; VAR8 -> VAR75 [ VAR84 ] = sizeof ( VAR85 ) * 36 ; if ( VAR8 -> VAR15 . VAR62 > 0 ) { VAR8 -> VAR86 |= VAR87 ; } if ( VAR8 -> VAR15 . VAR52 > - 1 ) { struct tuner_setup VAR88 ; VAR88 . VAR89 = VAR90 ; VAR88 . VAR91 = VAR8 -> VAR15 . VAR52 ; VAR88 . VAR92 = VAR93 ; if ( VAR8 -> VAR15 . VAR62 > 0 ) { VAR88 . VAR92 |= VAR94 ; } VAR88 . VAR95 = ( VAR88 . VAR91 == VAR96 ) ?VAR97 : NULL ; FUN19 ( VAR8 , VAR52 , VAR98 , & VAR88 ) ; if ( VAR88 . VAR91 == VAR96 ) { static struct xc2028_ctrl VAR99 = { . VAR100 = VAR101 . VAR102 = 64 } ; struct v4l2_priv_tun_config VAR103 = { . VAR52 = VAR8 -> VAR15 . VAR52 . VAR24 = & VAR99 } ; FUN19 ( VAR8 , VAR52 , VAR104 , & VAR103 ) ; } } VAR8 -> VAR105 = VAR8 -> VAR50 ; if ( VAR8 -> VAR86 & VAR106 ) { struct VAR107 * VAR21 = VAR8 -> VAR12 . VAR20 ; VAR8 -> VAR108 = FUN20 ( VAR21 , & VAR109 , VAR110 , 0 , 0 , 0 , 0 ) ; VAR8 -> VAR111 = FUN20 ( VAR21 , & VAR109 , VAR112 , 0 , 0 , 0 , 0 ) ; VAR8 -> VAR113 = FUN21 ( VAR21 , & VAR109 , VAR114 , VAR115 , 1 << VAR116 , VAR117 ) ; VAR8 -> VAR118 = FUN21 ( VAR21 , & VAR109 , VAR119 , VAR115 , 1 << VAR116 , VAR120 ) ; if ( VAR21 -> VAR121 ) { VAR5 = VAR21 -> VAR121 ; VAR49 } FUN22 ( 2 , & VAR8 -> VAR108 ) ; FUN22 ( 2 , & VAR8 -> VAR113 ) ; FUN19 ( VAR8 , VAR122 , VAR123 , VAR8 -> VAR50 ) ; FUN23 ( VAR8 , VAR124 , VAR122 , VAR125 , 0 ) ; } FUN24 ( VAR8 , 0xffffffff ) ; VAR5 = FUN25 ( VAR8 -> VAR2 -> VAR126 , VAR127 , VAR128 , VAR8 -> VAR12 . VAR129 , ( void * ) VAR8 ) ; if ( VAR5 ) { FUN12 ( "" , VAR5 ) ; VAR49 } VAR5 = FUN26 ( VAR8 ) ; if ( VAR5 ) { FUN12 ( "" , VAR5 ) ; VAR130 } VAR5 = FUN27 ( VAR8 ) ; if ( VAR5 ) { FUN12 ( "" , VAR5 ) ; VAR131 } FUN5 ( "" , VAR8 -> VAR132 ) ; FUN28 ( VAR8 ) ; return 0 ; free_streams FUN29 ( VAR8 ) ; free_irq FUN30 ( VAR8 -> VAR2 -> VAR126 , ( void * ) VAR8 ) ; free_i2c FUN31 ( & VAR8 -> VAR19 . VAR21 ) ; FUN32 ( VAR8 ) ; free_io FUN33 ( VAR8 ) ; free_mem FUN34 ( VAR8 -> VAR28 , VAR34 ) ; FUN34 ( VAR8 -> VAR28 + VAR40 , VAR41 ) ; if ( VAR8 -> VAR36 ) { FUN34 ( VAR8 -> VAR28 + VAR37 , VAR38 ) ; } free_worker FUN35 ( VAR8 -> VAR133 ) ; err if ( VAR5 == 0 ) { VAR5 = - VAR17 ; } FUN12 ( "" , VAR5 ) ; FUN36 ( & VAR8 -> VAR12 ) ; FUN37 ( VAR8 ) ; return VAR5 ; }