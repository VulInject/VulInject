static int cdns3_gadget_ep_disable ( struct usb_ep * ep ) { struct cdns3_endpoint * priv_ep ; struct cdns3_request * priv_req ; struct cdns3_device * priv_dev ; struct usb_request * request ; unsigned long flags ; int ret = 0 ; u32 ep_cfg ; int val ; if ( ! ep ) { pr_err ( "usbss: invalid parameters\n" ) ; return - EINVAL ; } priv_ep = ep_to_cdns3_ep ( ep ) ; priv_dev = priv_ep -> cdns3_dev ; if ( dev_WARN_ONCE ( priv_dev -> dev , ! ( priv_ep -> flags & EP_ENABLED ) , "%s is already disabled\n" , priv_ep -> name ) ) { return 0 ; } spin_lock_irqsave ( & priv_dev -> lock , flags ) ; trace_cdns3_gadget_ep_disable ( priv_ep ) ; cdns3_select_ep ( priv_dev , ep -> desc -> bEndpointAddress ) ; ep_cfg = readl ( & priv_dev -> regs -> ep_cfg ) ; ep_cfg &= ~ EP_CFG_ENABLE ; writel ( ep_cfg , & priv_dev -> regs -> ep_cfg ) ; readl_poll_timeout_atomic ( & priv_dev -> regs -> ep_sts , val , ! ( val & EP_STS_DBUSY ) , 1 , 10 ) ; writel ( EP_CMD_EPRST , & priv_dev -> regs -> ep_cmd ) ; readl_poll_timeout_atomic ( & priv_dev -> regs -> ep_cmd , val , ! ( val & ( EP_CMD_CSTALL | EP_CMD_EPRST ) ) , 1 , 1000 ) ; if ( unlikely ( ret ) ) { dev_err ( priv_dev -> dev , "Timeout: %s resetting failed.\n" , priv_ep -> name ) ; } while ( ! list_empty ( & priv_ep -> pending_req_list ) ) { request = cdns3_next_request ( & priv_ep -> pending_req_list ) ; cdns3_gadget_giveback ( priv_ep , to_cdns3_request ( request ) , - ESHUTDOWN ) ; } while ( ! list_empty ( & priv_ep -> wa2_descmiss_req_list ) ) { priv_req = cdns3_next_priv_request ( & priv_ep -> wa2_descmiss_req_list ) ; cdns3_gadget_ep_free_request ( & priv_ep -> endpoint , & priv_req -> request ) ; list_del_init ( & priv_req -> list ) ; -- priv_ep -> wa2_counter ; } while ( ! list_empty ( & priv_ep -> deferred_req_list ) ) { request = cdns3_next_request ( & priv_ep -> deferred_req_list ) ; cdns3_gadget_giveback ( priv_ep , to_cdns3_request ( request ) , - ESHUTDOWN ) ; } priv_ep -> descmis_req = NULL ; ep -> desc = NULL ; priv_ep -> flags &= ~ EP_ENABLED ; priv_ep -> use_streams = false ; spin_unlock_irqrestore ( & priv_dev -> lock , flags ) ; return ret ; } 