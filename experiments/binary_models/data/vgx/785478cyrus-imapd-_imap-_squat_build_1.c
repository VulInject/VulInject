static int dump_index_trie_words ( SquatIndex * index , int first_char , int * result_offset ) { SquatSearchIndex * old_index = index -> old_index ; SquatWriteBuffer * buf = index -> index_buffers + first_char ; int num_words = index -> total_num_words [ first_char ] ; WordDocEntry * doc_table ; char const * word_list_ptr ; int r = SQUAT_OK ; char const * word_ptr ; int existing = 0 ; if ( old_index && squat_count_docs ( old_index , first_char , & existing ) != SQUAT_OK ) { return ( SQUAT_ERR ) ; } doc_table = ( WordDocEntry * ) xmalloc ( sizeof ( WordDocEntry ) * ( num_words + existing ) ) ; index -> word_doc_allocator = doc_table ; if ( old_index ) { r = squat_scan ( old_index , first_char , add_word_callback , index ) ; if ( r != SQUAT_OK ) { r = SQUAT_ERR ; cleanup } } word_list_ptr = mmap ( NULL , buf -> total_output_bytes , PROT_READ , MAP_SHARED , buf -> fd , 0 ) ; if ( word_list_ptr == MAP_FAILED ) { squat_set_last_error ( SQUAT_ERR_SYSERR , NULL ) ; r = SQUAT_ERR ; cleanup } word_ptr = word_list_ptr ; while ( num_words > 0 ) { int doc_ID = ( int ) squat_decode_I ( & word_ptr ) ; int doc_words = ( int ) squat_decode_I ( & word_ptr ) ; num_words -= doc_words ; while ( doc_words > 0 ) { if ( add_word_to_trie ( index , word_ptr , doc_ID ) != SQUAT_OK ) { r = SQUAT_ERR ; cleanup_map } word_ptr += SQUAT_WORD_SIZE - 1 ; doc_words -- ; } } assert ( word_ptr - word_list_ptr == buf -> total_output_bytes ) ; r = write_trie_word_data ( index , index -> doc_word_table , SQUAT_WORD_SIZE - 1 , result_offset ) ; cleanup_map if ( munmap ( ( void * ) word_list_ptr , buf -> total_output_bytes ) != 0 && r == SQUAT_OK ) { squat_set_last_error ( SQUAT_ERR_SYSERR ) ; r = SQUAT_ERR ; } cleanup free ( doc_table ) ; return r ; } 