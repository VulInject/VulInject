static void sbd_dev_configure ( sbd_handle_t * hp ) { int n , unit ; int32_t pass , devnum ; dev_info_t * dip ; sbd_devlist_t * devlist ; sbdp_handle_t * hdp ; sbd_comp_type_t nodetype ; sbd_board_t * sbp = SBDH2BD ( hp -> h_sbd ) ; pass = 1 ; hdp = sbd_get_sbdp_handle ( sbp , hp ) ; while ( ( devlist = sbd_get_attach_devlist ( hp , & devnum , pass ) ) != NULL ) { int err ; err = sbd_pre_attach_devlist ( hp , devlist , devnum ) ; if ( err < 0 ) { break ; } if ( err > 0 ) { pass ++ ; continue ; } for ( n = 0 ; n < devnum ; n ++ ) { sbderror_t * ep ; ep = & devlist [ n ] . dv_error ; SBD_SET_ERRNO ( ep , 0 ) ; SBD_SET_ERR ( ep , 0 ) ; dip = devlist [ n ] . dv_dip ; nodetype = sbd_get_devtype ( hp , dip ) ; unit = sbdp_get_unit_num ( hdp , dip ) ; if ( unit < 0 ) { SBD_GET_PERR ( hdp -> h_err , SBD_HD2ERR ( hp ) ) ; break ; } switch ( nodetype ) { case SBD_COMP_MEM : sbd_attach_mem ( hp , ep ) ; if ( SBD_GET_ERR ( ep ) == ESBD_CPUONLINE ) { FREESTRUCT ( devlist , sbd_devlist_t , MAX_MEM_UNITS_PER_BOARD ) ; return ; } break ; case SBD_COMP_CPU : sbd_attach_cpu ( hp , ep , dip , unit ) ; break ; case SBD_COMP_IO : sbd_attach_io ( hp , ep , dip , unit ) ; break ; default : SBD_SET_ERRNO ( ep , ENOTTY ) ; break ; } if ( sbd_set_err_in_hdl ( hp , ep ) == 0 ) { continue ; } } err = sbd_post_attach_devlist ( hp , devlist , devnum ) ; if ( err < 0 ) { break ; } pass ++ ; } sbd_release_sbdp_handle ( hdp ) ; } 