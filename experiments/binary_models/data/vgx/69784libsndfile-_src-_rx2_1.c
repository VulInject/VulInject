int rx2_open ( SF_PRIVATE * psf ) { static const char * marker_type [ 4 ] { "Original Enabled" "Enabled Hidden" "Additional/PencilTool" "Disabled" } ; ; BUF_UNION ubuf ; int error , marker , length , glob_offset , slce_count , frames ; int sdat_length = 0 , slce_total = 0 ; int n_channels ; psf_binheader_readf ( psf , "Epm4" , 0 , & marker , & length ) ; if ( marker != CAT_MARKER ) { psf_log_printf ( psf , "length : %d\n" , length ) ; return - 1000 ; } if ( length != psf -> filelength - 8 ) { psf_log_printf ( psf , "%M : %d (should be %d)\n" , marker , length , psf -> filelength - 8 ) ; } else { psf_log_printf ( psf , "%M : %d\n" , marker , length ) ; } psf_binheader_readf ( psf , "m" , & marker ) ; psf_log_printf ( psf , "%M" , marker ) ; psf_binheader_readf ( psf , "m" , & marker ) ; psf_log_printf ( psf , "%M\n" , marker ) ; psf_binheader_readf ( psf , "E4" , & glob_offset ) ; glob_offset += 0x14 ; psf_binheader_readf ( psf , "p" , 0x30 ) ; length = 0 ; psf_binheader_readf ( psf , "1" , & length ) ; if ( length >= SIGNED_SIZEOF ( ubuf . cbuf ) ) { psf_log_printf ( psf , "  Text : %d *** Error : Too sf_count_t!\n" ) ; return - 1001 ; } psf_binheader_readf ( psf , "b" , ubuf . cbuf , length ) ; psf_log_printf ( psf , " Text : \"%s\"\n" , ubuf . cbuf ) ; if ( glob_offset & 1 ) { glob_offset ++ ; } psf_binheader_readf ( psf , "p" , glob_offset ) ; slce_count = 0 ; while ( 1 ) { psf_binheader_readf ( psf , "m" , & marker ) ; if ( marker != SLCE_MARKER && slce_count > 0 ) { psf_log_printf ( psf , "   SLCE count : %d\n" , slce_count ) ; slce_count = 0 ; } switch ( marker ) { case GLOB_MARKER : psf_binheader_readf ( psf , "E4" , & length ) ; psf_log_printf ( psf , " %M : %d\n" , marker , length ) ; psf_binheader_readf ( psf , "j" , length ) ; break ; case RECY_MARKER : psf_binheader_readf ( psf , "E4" , & length ) ; psf_log_printf ( psf , " %M : %d\n" , marker , length ) ; psf_binheader_readf ( psf , "j" , ( length + 1 ) & 0xFFFFFFFE ) ; break ; case CAT_MARKER : psf_binheader_readf ( psf , "E4" , & length ) ; psf_log_printf ( psf , " %M : %d\n" , marker , length ) ; break ; case DEVL_MARKER : psf_binheader_readf ( psf , "mE4" , & marker , & length ) ; psf_log_printf ( psf , "  DEVL%M : %d\n" , marker , length ) ; if ( length & 1 ) { length ++ ; } psf_binheader_readf ( psf , "j" , length ) ; break ; case EQ_MARKER : case COMP_MARKER : psf_binheader_readf ( psf , "E4" , & length ) ; psf_log_printf ( psf , "   %M : %d\n" , marker , length ) ; if ( length & 1 ) { length ++ ; } psf_binheader_readf ( psf , "j" , length ) ; break ; case SLCL_MARKER : psf_log_printf ( psf , "  %M\n    (Offset, Next Offset, Type)\n" , marker ) ; slce_count = 0 ; break ; case SLCE_MARKER : { int len [ 4 ] , indx ; psf_binheader_readf ( psf , "E4444" , & len [ 0 ] , & len [ 1 ] , & len [ 2 ] , & len [ 3 ] ) ; indx = ( ( len [ 3 ] & 0x0000FFFF ) >> 8 ) & 3 ; if ( len [ 2 ] == 1 ) { if ( indx != 1 ) { indx = 3 ; } psf_log_printf ( psf , "   %M : (%6d, ?: 0x%X, %s)\n" , marker , len [ 1 ] , ( len [ 3 ] & 0xFFFF0000 ) >> 16 , marker_type [ indx ] ) ; } else { slce_total += len [ 2 ] ; psf_log_printf ( psf , "   %M : (%6d, SLCE_next_ofs:%d, ?: 0x%X, %s)\n" , marker , len [ 1 ] , len [ 2 ] , ( len [ 3 ] & 0xFFFF0000 ) >> 16 , marker_type [ indx ] ) ; } slce_count ++ ; } break ; case SINF_MARKER : psf_binheader_readf ( psf , "E4" , & length ) ; psf_log_printf ( psf , " %M : %d\n" , marker , length ) ; psf_binheader_readf ( psf , "E2" , & n_channels ) ; n_channels = ( n_channels & 0x0000FF00 ) >> 8 ; psf_log_printf ( psf , "  Channels    : %d\n" , n_channels ) ; psf_binheader_readf ( psf , "E44" , & psf -> sf . samplerate , & frames ) ; psf -> sf . frames = frames ; psf_log_printf ( psf , "  Sample Rate : %d\n" , psf -> sf . samplerate ) ; psf_log_printf ( psf , "  Frames      : %D\n" , psf -> sf . frames ) ; psf_binheader_readf ( psf , "E4" , & length ) ; psf_log_printf ( psf , "  ??????????? : %d\n" , length ) ; psf_binheader_readf ( psf , "E4" , & length ) ; psf_log_printf ( psf , "  ??????????? : %d\n" , length ) ; break ; case SDAT_MARKER : psf_binheader_readf ( psf , "E4" , & length ) ; sdat_length = length ; psf -> dataoffset = psf_binheader_readf ( psf , NULL ) ; if ( psf -> dataoffset + length != psf -> filelength ) { psf_log_printf ( psf , " %M : %d (should be %d)\n" , marker , length , psf -> dataoffset + psf -> filelength ) ; } else { psf_log_printf ( psf , " %M : %d\n" , marker , length ) ; } break ; default : psf_log_printf ( psf , "Unknown marker : 0x%X %M" , marker , marker ) ; return - 1003 ; break ; } if ( marker == SDAT_MARKER ) { break ; } } puts ( psf -> parselog . buf ) ; puts ( "-----------------------------------" ) ; printf ( "SDAT length  : %d\n" , sdat_length ) ; printf ( "SLCE count   : %d\n" , slce_count ) ; if ( slce_count == 0 && slce_total == 1 ) { slce_total = frames ; } printf ( "SLCE samples : %d\n" , slce_total ) ; printf ( "Comp Ratio   : %f:1\n" , ( 2.0 * slce_total * n_channels ) / sdat_length ) ; puts ( " " ) ; psf -> parselog . buf [ 0 ] = 0 ; psf -> endian = SF_ENDIAN_BIG ; psf -> datalength = psf -> filelength - psf -> dataoffset ; if ( psf_fseek ( psf , psf -> dataoffset , SEEK_SET ) ) { return SFE_BAD_SEEK ; } psf -> sf . format = ( SF_FORMAT_REX2 | SF_FORMAT_DWVW_12 ) ; psf -> sf . channels = 1 ; psf -> bytewidth = 2 ; psf -> blockwidth = psf -> sf . channels * psf -> bytewidth ; if ( ( error = dwvw_init ( psf , 16 ) ) ) { return error ; } psf -> container_close = rx2_close ; if ( ! psf -> sf . frames && psf -> blockwidth ) { psf -> sf . frames = psf -> datalength / psf -> blockwidth ; } return 0 ; } 