static h2o_iovec_t on_extra_status ( void * unused , h2o_globalconf_t * _conf , h2o_req_t * req ) { h2o_iovec_t ret ; char current_time [ H2O_TIMESTR_LOG_LEN + 1 ] , restart_time [ H2O_TIMESTR_LOG_LEN + 1 ] ; const char * generation ; time_t now = time ( NULL ) ; h2o_time2str_log ( current_time , now ) ; h2o_time2str_log ( restart_time , conf . launch_time ) ; if ( ( generation = getenv ( "SERVER_STARTER_GENERATION" ) ) == NULL ) { generation = "null" ; } ret . base = h2o_mem_alloc_pool ( & req -> pool , char , BUFSIZE ) ; ret . len = snprintf ( ret . base , BUFSIZE , ",\n" " \"server-version\": \"" H2O_VERSION "\",\n" " \"openssl-version\": \"%s\",\n" " \"current-time\": \"%s\",\n" " \"restart-time\": \"%s\",\n" " \"uptime\": %" PRIu64 ",\n" " \"generation\": %s,\n" " \"connections\": %d,\n" " \"max-connections\": %d,\n" " \"soft-connection-limit\": %d,\n" " \"soft-connection-limit.min-age\": %d,\n" " \"listeners\": %zu,\n" " \"worker-threads\": %zu,\n" " \"num-sessions\": %lu" , OpenSSL_version ( OPENSSL_VERSION ) , current_time , restart_time , ( uint64_t ) ( now - conf . launch_time ) , generation , num_connections ( 0 ) , conf . max_connections , conf . soft_connection_limit , conf . soft_connection_limit_min_age , conf . num_listeners , conf . thread_map . size , num_sessions ( 0 ) ) ; assert ( ret . len < BUFSIZE ) ; struct extra_status_jemalloc_cb_arg arg ; size_t sz , allocated , active , metadata , resident , mapped ; uint64_t epoch = 1 ; void malloc_stats_print ( void ( * write_cb ) ( void * , const char * ) , void * cbopaque , const char * opts ) ; int mallctl ( const char * name , void * oldp , size_t * oldlenp , void * newp , size_t newlen ) ; arg . outbuf = h2o_iovec_init ( alloca ( BUFSIZE - ret . len ) , BUFSIZE - ret . len ) ; arg . err = 0 ; arg . written = snprintf ( arg . outbuf . base , arg . outbuf . len , ",\n" " \"jemalloc\": {\n" "   \"jemalloc-raw\": \"" ) ; malloc_stats_print ( extra_status_jemalloc_cb , & arg , "ga" ) ; arg . written += snprintf ( & arg . outbuf . base [ arg . written ] , arg . outbuf . len - arg . written , "\"" ) ; if ( arg . written + 1 >= arg . outbuf . len ) { jemalloc_err } sz = sizeof ( epoch ) ; mallctl ( "epoch" , & epoch , & sz , & epoch , sz ) ; sz = sizeof ( size_t ) ; if ( ! mallctl ( "stats.allocated" , & allocated , & sz , NULL , 0 ) && ! mallctl ( "stats.active" , & active , & sz , NULL , 0 ) && ! mallctl ( "stats.metadata" , & metadata , & sz , NULL , 0 ) && ! mallctl ( "stats.resident" , & resident , & sz , NULL , 0 ) && ! mallctl ( "stats.mapped" , & mapped , & sz , NULL , 0 ) ) { arg . written += snprintf ( & arg . outbuf . base [ arg . written ] , arg . outbuf . len - arg . written , ",\n" "   \"allocated\": %zu,\n" "   \"active\": %zu,\n" "   \"metadata\": %zu,\n" "   \"resident\": %zu,\n" "   \"mapped\": %zu }" , allocated , active , metadata , resident , mapped ) ; } if ( arg . written + 1 >= arg . outbuf . len ) { jemalloc_err } strncpy ( & ret . base [ ret . len ] , arg . outbuf . base , arg . written ) ; ret . base [ ret . len + arg . written ] = '\0' ; ret . len += arg . written ; return ret ; jemalloc_err ret . base [ ret . len ] = '\0' ; return ret ; } 