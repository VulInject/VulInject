static int filter_frame ( AVFilterLink * inlink , AVFrame * ref ) { AVFilterContext * ctx = inlink -> dst ; SendCmdContext * s = ctx -> priv ; int64_t ts ; int i , j , ret ; if ( ref -> pts == AV_NOPTS_VALUE ) { end } ts = av_rescale_q ( ref -> pts , inlink -> time_base , AV_TIME_BASE_Q ) ; for ( i = 0 ; i < s -> nb_intervals ; i ++ ) { Interval * interval = & s -> intervals [ i ] ; int flags = 0 ; if ( ! interval -> enabled && WITHIN_INTERVAL ( ts , interval -> start_ts , interval -> end_ts ) ) { flags += COMMAND_FLAG_ENTER ; interval -> enabled = 1 ; } if ( interval -> enabled && ! WITHIN_INTERVAL ( ts , interval -> start_ts , interval -> end_ts ) ) { flags += COMMAND_FLAG_LEAVE ; interval -> enabled = 0 ; } if ( interval -> enabled ) { flags += COMMAND_FLAG_EXPR ; } if ( flags ) { AVBPrint pbuf ; av_log ( ctx , AV_LOG_VERBOSE , "[%s] interval #%d start_ts:%f end_ts:%f ts:%f\n" , make_command_flags_str ( & pbuf , flags ) , interval -> index , ( double ) interval -> start_ts / 1000000 , ( double ) interval -> end_ts / 1000000 , ( double ) ts / 1000000 ) ; for ( j = 0 ; flags && j < interval -> nb_commands ; j ++ ) { Command * cmd = & interval -> commands [ j ] ; char * cmd_arg = cmd -> arg ; char buf [ 1024 ] ; if ( cmd -> flags & flags ) { if ( cmd -> flags & COMMAND_FLAG_EXPR ) { double var_values [ VAR_VARS_NB ] , res ; double start = TS2T ( interval -> start_ts , AV_TIME_BASE_Q ) ; double end = TS2T ( interval -> end_ts , AV_TIME_BASE_Q ) ; double current = TS2T ( ref -> pts , inlink -> time_base ) ; var_values [ VAR_N ] = inlink -> frame_count_in ; var_values [ VAR_POS ] = ref -> pkt_pos == - 1 ?NAN : ref -> pkt_pos ; var_values [ VAR_PTS ] = TS2D ( ref -> pts ) ; var_values [ VAR_T ] = current ; var_values [ VAR_TS ] = start ; var_values [ VAR_TE ] = end ; var_values [ VAR_TI ] = ( current - start ) / ( end - start ) ; var_values [ VAR_W ] = ref -> width ; var_values [ VAR_H ] = ref -> height ; if ( ( ret = av_expr_parse_and_eval ( & res , cmd -> arg , var_names , var_values , NULL , NULL , NULL , NULL , NULL , 0 , NULL ) ) < 0 ) { av_log ( ctx , AV_LOG_ERROR , "Invalid expression '%s' for command argument.\n" , cmd -> arg ) ; return AVERROR ( EINVAL ) ; } cmd_arg = av_asprintf ( "%g" , res ) ; if ( ! cmd_arg ) { av_frame_free ( & ref ) ; return AVERROR ( ENOMEM ) ; } } av_log ( ctx , AV_LOG_VERBOSE , "Processing command #%d target:%s command:%s arg:%s\n" , cmd -> index , cmd -> target , cmd -> command , cmd_arg ) ; ret = avfilter_graph_send_command ( inlink -> graph , cmd -> target , cmd -> command , cmd_arg , buf , sizeof ( buf ) , AVFILTER_CMD_FLAG_ONE ) ; av_log ( ctx , AV_LOG_VERBOSE , "Command reply for command #%d: ret:%s res:%s\n" , cmd -> index , av_err2str ( ret ) , buf ) ; if ( cmd -> flags & COMMAND_FLAG_EXPR ) { av_freep ( & cmd_arg ) ; } } } } } end switch ( inlink -> type ) { case AVMEDIA_TYPE_VIDEO : case AVMEDIA_TYPE_AUDIO : return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , ref ) ; } return AVERROR ( ENOSYS ) ; } 