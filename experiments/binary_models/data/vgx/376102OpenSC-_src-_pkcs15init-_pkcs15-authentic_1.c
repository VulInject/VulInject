static int authentic_pkcs15_new_file ( struct sc_profile * profile , struct sc_card * card , unsigned int type , unsigned int num , struct sc_file * * out ) { struct sc_context * ctx = card -> ctx ; struct sc_file * file ; const char * t_name = NULL ; int rv ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , "type %X; num %i" , type , num ) ; switch ( type ) { case SC_PKCS15_TYPE_PRKEY_RSA : t_name = "template-private-key" ; break ; case SC_PKCS15_TYPE_PUBKEY_RSA : t_name = "template-public-key" ; break ; case SC_PKCS15_TYPE_CERT : t_name = "template-certificate" ; break ; case SC_PKCS15_TYPE_DATA_OBJECT : t_name = "template-public-data" ; break ; default : LOG_TEST_RET ( ctx , SC_ERROR_NOT_SUPPORTED , "Profile template not supported" ) ; } sc_log ( ctx , "df_info path '%s'" , sc_print_path ( & profile -> df_info -> file -> path ) ) ; rv = sc_profile_get_file ( profile , t_name , & file ) ; LOG_TEST_RET ( ctx , rv , "Error when getting file from template" ) ; sc_log ( ctx , "file(type:%X), path(type:%X,path:%s)" , file -> type , file -> path . type , sc_print_path ( & file -> path ) ) ; file -> id = ( file -> id & 0xFF00 ) | ( num & 0xFF ) ; if ( file -> type != SC_FILE_TYPE_BSO ) { if ( file -> path . len == 0 ) { file -> path . type = SC_PATH_TYPE_FILE_ID ; file -> path . len = 2 ; } file -> path . value [ file -> path . len - 2 ] = ( file -> id >> 8 ) & 0xFF ; file -> path . value [ file -> path . len - 1 ] = file -> id & 0xFF ; file -> path . count = - 1 ; } sc_log ( ctx , "file(size:%" SC_FORMAT_LEN_SIZE_T "u,type:%i/%i,id:%04X), path(type:%X,'%s')" , file -> size , file -> type , file -> ef_structure , file -> id , file -> path . type , sc_print_path ( & file -> path ) ) ; if ( out ) { * out = file ; } else { sc_file_free ( file ) ; } LOG_FUNC_RETURN ( ctx , SC_SUCCESS ) ; } 