int btrfs_dev_replace_start ( struct btrfs_fs_info * fs_info , const char * tgtdev_name , u64 srcdevid , const char * srcdev_name , int read_src ) { struct btrfs_root * root = fs_info -> dev_root ; struct btrfs_trans_handle * trans ; struct btrfs_dev_replace * dev_replace = & fs_info -> dev_replace ; int ret ; struct btrfs_device * tgt_device = NULL ; struct btrfs_device * src_device = NULL ; mutex_lock ( & fs_info -> volume_mutex ) ; ret = btrfs_find_device_by_devspec ( fs_info , srcdevid , srcdev_name , & src_device ) ; if ( ret ) { mutex_unlock ( & fs_info -> volume_mutex ) ; return ret ; } ret = btrfs_init_dev_replace_tgtdev ( fs_info , tgtdev_name , src_device , & tgt_device ) ; mutex_unlock ( & fs_info -> volume_mutex ) ; trans = btrfs_attach_transaction ( root ) ; if ( ! IS_ERR ( trans ) ) { ret = btrfs_commit_transaction ( trans ) ; if ( ret ) { return ret ; } } if ( PTR_ERR ( trans ) != - ENOENT ) { return PTR_ERR ( trans ) ; } btrfs_dev_replace_lock ( dev_replace , 1 ) ; switch ( dev_replace -> replace_state ) { case BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED : case BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED : break ; case BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED : ret = BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED ; leave } dev_replace -> cont_reading_from_srcdev_mode = read_src ; WARN_ON ( ! src_device ) ; dev_replace -> srcdev = src_device ; WARN_ON ( ! tgt_device ) ; dev_replace -> tgtdev = tgt_device ; btrfs_info_in_rcu ( fs_info , "dev_replace from %s (devid %llu) to %s started" , src_device -> missing ?"<missing disk>" : rcu_str_deref ( src_device -> name ) , src_device -> devid , rcu_str_deref ( tgt_device -> name ) ) ; dev_replace -> replace_state = BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED ; dev_replace -> time_started = get_seconds ( ) ; dev_replace -> cursor_left = 0 ; dev_replace -> committed_cursor_left = 0 ; dev_replace -> cursor_left_last_write_of_item = 0 ; dev_replace -> cursor_right = 0 ; dev_replace -> is_valid = 1 ; dev_replace -> item_needs_writeback = 1 ; atomic64_set ( & dev_replace -> num_write_errors , 0 ) ; atomic64_set ( & dev_replace -> num_uncorrectable_read_errors , 0 ) ; btrfs_dev_replace_unlock ( dev_replace , 1 ) ; ret = btrfs_sysfs_add_device_link ( tgt_device -> fs_devices , tgt_device ) ; if ( ret ) { btrfs_err ( fs_info , "kobj add dev failed %d" , ret ) ; } btrfs_wait_ordered_roots ( fs_info , - 1 , 0 , ( u64 ) - 1 ) ; trans = btrfs_start_transaction ( root , 0 ) ; if ( IS_ERR ( trans ) ) { ret = PTR_ERR ( trans ) ; btrfs_dev_replace_lock ( dev_replace , 1 ) ; leave } ret = btrfs_commit_transaction ( trans ) ; WARN_ON ( ret ) ; ret = btrfs_scrub_dev ( fs_info , src_device -> devid , 0 , btrfs_device_get_total_bytes ( src_device ) , & dev_replace -> scrub_progress , 0 , 1 ) ; ret = btrfs_dev_replace_finishing ( fs_info , ret ) ; if ( ret == - EINPROGRESS ) { ret = BTRFS_IOCTL_DEV_REPLACE_RESULT_SCRUB_INPROGRESS ; } else { WARN_ON ( ret ) ; } return ret ; leave dev_replace -> srcdev = NULL ; dev_replace -> tgtdev = NULL ; btrfs_dev_replace_unlock ( dev_replace , 1 ) ; btrfs_destroy_dev_replace_tgtdev ( fs_info , tgt_device ) ; return ret ; } 