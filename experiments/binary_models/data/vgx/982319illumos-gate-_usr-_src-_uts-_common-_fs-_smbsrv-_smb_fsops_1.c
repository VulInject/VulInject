int smb_fsop_aclread ( smb_request_t * sr , cred_t * cr , smb_node_t * snode , smb_fssd_t * fs_sd ) { int error = 0 ; int flags = 0 ; int access = 0 ; acl_t * acl ; ASSERT ( cr , NULL ) ; if ( SMB_IS_STREAM ( snode ) != NULL ) { return ( EINVAL ) ; } if ( SMB_TREE_HAS_ACCESS ( sr , ACE_READ_ACL ) == 0 ) { return ( EACCES ) ; } if ( sr -> fid_ofile ) { if ( fs_sd -> sd_secinfo & SMB_DACL_SECINFO ) { access = READ_CONTROL ; } if ( fs_sd -> sd_secinfo & SMB_SACL_SECINFO ) { access |= ACCESS_SYSTEM_SECURITY ; } error = smb_ofile_access ( sr -> fid_ofile , cr , access ) ; if ( error != NT_STATUS_SUCCESS ) { return ( EACCES ) ; } } if ( smb_tree_has_feature ( sr -> tid_tree , SMB_TREE_ACEMASKONACCESS ) ) { flags = ATTR_NOACLCHECK ; } error = smb_vop_acl_read ( snode -> vp , & acl , flags , sr -> tid_tree -> t_acltype , cr ) ; if ( error != 0 ) { return ( error ) ; } error = acl_translate ( acl , _ACL_ACE_ENABLED , smb_node_is_dir ( snode ) , fs_sd -> sd_uid , fs_sd -> sd_gid ) ; if ( error == 0 ) { smb_fsacl_split ( acl , & fs_sd -> sd_zdacl , & fs_sd -> sd_zsacl , fs_sd -> sd_secinfo ) ; } acl_free ( acl ) ; return ( error ) ; } 