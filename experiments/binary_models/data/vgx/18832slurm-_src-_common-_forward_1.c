void * _forward_thread ( void * arg ) { forward_msg_t * fwd_msg = ( forward_msg_t * ) arg ; forward_struct_t * fwd_struct = fwd_msg -> fwd_struct ; buf_t * buffer = init_buf ( BUF_SIZE ) ; List ret_list = NULL ; int fd = - 1 ; ret_data_info_t * ret_data_info = NULL ; char * name = NULL ; hostlist_t hl = hostlist_create ( fwd_msg -> header . forward . nodelist ) ; slurm_addr_t addr ; char * buf = NULL ; int steps = 0 ; int start_timeout = fwd_msg -> timeout ; while ( ( name = hostlist_shift ( hl ) ) ) { if ( slurm_conf_get_addr ( name , & addr , fwd_msg -> header . flags ) == SLURM_ERROR ) { error ( "forward_thread: can't find address for host " "%s, check slurm.conf" , name ) ; slurm_mutex_lock ( & fwd_struct -> forward_mutex ) ; mark_as_failed_forward ( & fwd_struct -> ret_list , name , SLURM_UNKNOWN_FORWARD_ADDR ) ; if ( hostlist_count ( hl ) > 0 ) { slurm_mutex_unlock ( & fwd_struct -> forward_mutex ) ; continue ; } cleanup } if ( ( fd = slurm_open_msg_conn ( & addr ) ) < 0 ) { error ( "forward_thread to %s (%pA): %m" , name , & addr ) ; slurm_mutex_lock ( & fwd_struct -> forward_mutex ) ; mark_as_failed_forward ( & fwd_struct -> ret_list , name , SLURM_COMMUNICATIONS_CONNECTION_ERROR ) ; free ( name ) ; if ( hostlist_count ( hl ) > 0 ) { slurm_mutex_unlock ( & fwd_struct -> forward_mutex ) ; _forward_msg_internal ( hl , NULL , fwd_struct , & fwd_msg -> header , 0 , hostlist_count ( hl ) ) ; continue ; } cleanup } buf = hostlist_ranged_string_xmalloc ( hl ) ; xfree ( fwd_msg -> header . forward . nodelist ) ; fwd_msg -> header . forward . nodelist = buf ; fwd_msg -> header . forward . cnt = hostlist_count ( hl ) ; info ( "sending %d forwards (%s) to %s" , fwd_msg -> header . forward . cnt , fwd_msg -> header . forward . nodelist , name ) ; if ( fwd_msg -> header . forward . nodelist [ 0 ] ) { debug3 ( "forward: send to %s along with %s" , name , fwd_msg -> header . forward . nodelist ) ; } else { debug3 ( "forward: send to %s " , name ) ; } pack_header ( & fwd_msg -> header , buffer ) ; if ( remaining_buf ( buffer ) < fwd_struct -> buf_len ) { int new_size = buffer -> processed + fwd_struct -> buf_len ; new_size += 1024 ; xrealloc_nz ( buffer -> head , new_size ) ; buffer -> size = new_size ; } if ( fwd_struct -> buf_len ) { memcpy ( & buffer -> head [ buffer -> processed ] , fwd_struct -> buf , fwd_struct -> buf_len ) ; buffer -> processed += fwd_struct -> buf_len ; } if ( slurm_msg_sendto ( fd , get_buf_data ( buffer ) , get_buf_offset ( buffer ) ) < 0 ) { error ( "forward_thread: slurm_msg_sendto: %m" ) ; slurm_mutex_lock ( & fwd_struct -> forward_mutex ) ; mark_as_failed_forward ( & fwd_struct -> ret_list , name , errno ) ; free ( name ) ; if ( hostlist_count ( hl ) > 0 ) { FREE_NULL_BUFFER ( buffer ) ; buffer = init_buf ( fwd_struct -> buf_len ) ; slurm_mutex_unlock ( & fwd_struct -> forward_mutex ) ; close ( fd ) ; fd = - 1 ; _forward_msg_internal ( hl , NULL , fwd_struct , & fwd_msg -> header , 0 , hostlist_count ( hl ) ) ; continue ; } cleanup } if ( ( fwd_msg -> header . msg_type == REQUEST_SHUTDOWN ) || ( fwd_msg -> header . msg_type == REQUEST_RECONFIGURE ) || ( fwd_msg -> header . msg_type == REQUEST_REBOOT_NODES ) ) { slurm_mutex_lock ( & fwd_struct -> forward_mutex ) ; ret_data_info = xmalloc ( sizeof ( ret_data_info_t ) ) ; list_push ( fwd_struct -> ret_list , ret_data_info ) ; ret_data_info -> node_name = xstrdup ( name ) ; free ( name ) ; while ( ( name = hostlist_shift ( hl ) ) ) { ret_data_info = xmalloc ( sizeof ( ret_data_info_t ) ) ; list_push ( fwd_struct -> ret_list , ret_data_info ) ; ret_data_info -> node_name = xstrdup ( name ) ; free ( name ) ; } cleanup } if ( fwd_msg -> header . forward . cnt > 0 ) { if ( ! fwd_msg -> header . forward . tree_width ) { fwd_msg -> header . forward . tree_width = slurm_conf . tree_width ; } steps = ( fwd_msg -> header . forward . cnt + 1 ) / fwd_msg -> header . forward . tree_width ; fwd_msg -> timeout = slurm_conf . msg_timeout * 1000 * steps ; steps ++ ; fwd_msg -> timeout += ( start_timeout * steps ) ; } ret_list = slurm_receive_resp_msgs ( fd , steps , fwd_msg -> timeout ) ; if ( ! ret_list || ( fwd_msg -> header . forward . cnt != 0 && list_count ( ret_list ) <= 1 ) ) { slurm_mutex_lock ( & fwd_struct -> forward_mutex ) ; mark_as_failed_forward ( & fwd_struct -> ret_list , name , errno ) ; free ( name ) ; FREE_NULL_LIST ( ret_list ) ; if ( hostlist_count ( hl ) > 0 ) { FREE_NULL_BUFFER ( buffer ) ; buffer = init_buf ( fwd_struct -> buf_len ) ; slurm_mutex_unlock ( & fwd_struct -> forward_mutex ) ; close ( fd ) ; fd = - 1 ; continue ; } cleanup } if ( ( fwd_msg -> header . forward . cnt + 1 ) != list_count ( ret_list ) ) { ListIterator itr = NULL ; char * tmp = NULL ; int first_node_found = 0 ; hostlist_iterator_t host_itr = hostlist_iterator_create ( hl ) ; error ( "We shouldn't be here.  We forwarded to %d " "but only got %d back" , ( fwd_msg -> header . forward . cnt + 1 ) , list_count ( ret_list ) ) ; while ( ( tmp = hostlist_next ( host_itr ) ) ) { int node_found = 0 ; itr = list_iterator_create ( ret_list ) ; while ( ( ret_data_info = list_next ( itr ) ) ) { if ( ! ret_data_info -> node_name ) { first_node_found = 1 ; ret_data_info -> node_name = xstrdup ( name ) ; } if ( ! xstrcmp ( tmp , ret_data_info -> node_name ) ) { node_found = 1 ; break ; } } list_iterator_destroy ( itr ) ; if ( ! node_found ) { slurm_mutex_lock ( & fwd_struct -> forward_mutex ) ; mark_as_failed_forward ( & fwd_struct -> ret_list , tmp , SLURM_COMMUNICATIONS_CONNECTION_ERROR ) ; slurm_mutex_unlock ( & fwd_struct -> forward_mutex ) ; } free ( tmp ) ; } hostlist_iterator_destroy ( host_itr ) ; if ( ! first_node_found ) { slurm_mutex_lock ( & fwd_struct -> forward_mutex ) ; mark_as_failed_forward ( & fwd_struct -> ret_list , name , SLURM_COMMUNICATIONS_CONNECTION_ERROR ) ; slurm_mutex_unlock ( & fwd_struct -> forward_mutex ) ; } } break ; } slurm_mutex_lock ( & fwd_struct -> forward_mutex ) ; if ( ret_list ) { while ( ( ret_data_info = list_pop ( ret_list ) ) != NULL ) { if ( ! ret_data_info -> node_name ) { ret_data_info -> node_name = xstrdup ( name ) ; } list_push ( fwd_struct -> ret_list , ret_data_info ) ; debug3 ( "got response from %s" , ret_data_info -> node_name ) ; } FREE_NULL_LIST ( ret_list ) ; } free ( name ) ; cleanup if ( ( fd >= 0 ) && close ( fd ) < 0 ) { error ( "close(%d): %m" , fd ) ; } hostlist_destroy ( hl ) ; destroy_forward ( & fwd_msg -> header . forward ) ; FREE_NULL_BUFFER ( buffer ) ; slurm_cond_signal ( & fwd_struct -> notify ) ; slurm_mutex_unlock ( & fwd_struct -> forward_mutex ) ; xfree ( fwd_msg ) ; return ( NULL ) ; } 