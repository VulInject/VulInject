static void llc_shdlc_sm_work ( struct work_struct * work ) { struct llc_shdlc * shdlc = container_of ( work , llc_shdlc , sm_work ) ; int r ; pr_debug ( "\n" ) ; mutex_lock ( & shdlc -> state_mutex ) ; switch ( shdlc -> state ) { case SHDLC_DISCONNECTED : skb_queue_purge ( & shdlc -> rcv_q ) ; skb_queue_purge ( & shdlc -> send_q ) ; skb_queue_purge ( & shdlc -> ack_pending_q ) ; break ; case SHDLC_CONNECTING : if ( shdlc -> hard_fault ) { llc_shdlc_connect_complete ( shdlc , shdlc -> hard_fault ) ; break ; } if ( shdlc -> connect_tries ++ < 5 ) { r = llc_shdlc_connect_initiate ( shdlc ) ; } else { r = - ETIME ; } if ( r < 0 ) { llc_shdlc_connect_complete ( shdlc , r ) ; } else { mod_timer ( & shdlc -> connect_timer , jiffies + msecs_to_jiffies ( SHDLC_CONNECT_VALUE_MS ) ) ; shdlc -> state = SHDLC_NEGOTIATING ; } break ; case SHDLC_NEGOTIATING : if ( timer_pending ( & shdlc -> connect_timer ) == 0 ) { shdlc -> state = SHDLC_CONNECTING ; schedule_work ( & shdlc -> sm_work ) ; } llc_shdlc_handle_rcv_queue ( shdlc , NULL ) ; if ( shdlc -> hard_fault ) { llc_shdlc_connect_complete ( shdlc , shdlc -> hard_fault ) ; break ; } break ; case SHDLC_HALF_CONNECTED : case SHDLC_CONNECTED : llc_shdlc_handle_rcv_queue ( shdlc ) ; llc_shdlc_handle_send_queue ( shdlc ) ; if ( shdlc -> t1_active && timer_pending ( & shdlc -> t1_timer ) == 0 ) { pr_debug ( "Handle T1(send ack) elapsed (T1 now inactive)\n" ) ; shdlc -> t1_active = false ; r = llc_shdlc_send_s_frame ( shdlc , S_FRAME_RR , shdlc -> nr ) ; if ( r < 0 ) { shdlc -> hard_fault = r ; } } if ( shdlc -> t2_active && timer_pending ( & shdlc -> t2_timer ) == 0 ) { pr_debug ( "Handle T2(retransmit) elapsed (T2 inactive)\n" ) ; shdlc -> t2_active = false ; llc_shdlc_requeue_ack_pending ( shdlc ) ; llc_shdlc_handle_send_queue ( shdlc ) ; } if ( shdlc -> hard_fault ) { shdlc -> llc_failure ( shdlc -> hdev , shdlc -> hard_fault ) ; } break ; default : break ; } mutex_unlock ( & shdlc -> state_mutex ) ; } 