static int gfx_v9_0_sw_init ( void * handle ) { int i , r ; struct amdgpu_ring * ring ; struct amdgpu_kiq * kiq ; struct amdgpu_device * adev = ( amdgpu_device * ) handle ; r = amdgpu_irq_add_id ( adev , AMDGPU_IH_CLIENTID_GRBM_CP , 178 , & adev -> gfx . kiq . irq ) ; if ( r ) { return r ; } r = amdgpu_irq_add_id ( adev , AMDGPU_IH_CLIENTID_GRBM_CP , 181 , & adev -> gfx . eop_irq ) ; if ( r ) { return r ; } r = amdgpu_irq_add_id ( adev , AMDGPU_IH_CLIENTID_GRBM_CP , 184 , & adev -> gfx . priv_reg_irq ) ; if ( r ) { return r ; } r = amdgpu_irq_add_id ( adev , AMDGPU_IH_CLIENTID_GRBM_CP , 185 , & adev -> gfx . priv_inst_irq ) ; if ( r ) { return r ; } adev -> gfx . gfx_current_status = AMDGPU_GFX_NORMAL_MODE ; gfx_v9_0_scratch_init ( adev ) ; r = gfx_v9_0_init_microcode ( adev ) ; if ( r ) { DRM_ERROR ( "Failed to load gfx firmware!\n" ) ; return r ; } r = gfx_v9_0_mec_init ( adev , NULL ) ; if ( r ) { DRM_ERROR ( "Failed to init MEC BOs!\n" ) ; return r ; } for ( i = 0 ; i < adev -> gfx . num_gfx_rings ; i ++ ) { ring = & adev -> gfx . gfx_ring [ i ] ; ring -> ring_obj = NULL ; sprintf ( ring -> name , "gfx" ) ; ring -> use_doorbell = true ; ring -> doorbell_index = AMDGPU_DOORBELL64_GFX_RING0 << 1 ; r = amdgpu_ring_init ( adev , ring , 1024 , & adev -> gfx . eop_irq , AMDGPU_CP_IRQ_GFX_EOP ) ; if ( r ) { return r ; } } for ( i = 0 ; i < adev -> gfx . num_compute_rings ; i ++ ) { unsigned irq_type ; if ( ( i >= 32 ) || ( i >= AMDGPU_MAX_COMPUTE_RINGS ) ) { DRM_ERROR ( "Too many (%d) compute rings!\n" , i ) ; break ; } ring = & adev -> gfx . compute_ring [ i ] ; ring -> ring_obj = NULL ; ring -> use_doorbell = true ; ring -> doorbell_index = ( AMDGPU_DOORBELL64_MEC_RING0 + i ) << 1 ; ring -> me = 1 ; ring -> pipe = i / 8 ; ring -> queue = i % 8 ; ring -> eop_gpu_addr = adev -> gfx . mec . hpd_eop_gpu_addr + ( i * MEC_HPD_SIZE ) ; sprintf ( ring -> name , "comp_%d.%d.%d" , ring -> me , ring -> pipe , ring -> queue ) ; irq_type = AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE0_EOP + ring -> pipe ; r = amdgpu_ring_init ( adev , ring , 1024 , & adev -> gfx . eop_irq , irq_type ) ; if ( r ) { return r ; } } if ( amdgpu_sriov_vf ( adev ) ) { r = gfx_v9_0_kiq_init ( adev ) ; if ( r ) { DRM_ERROR ( "Failed to init KIQ BOs!\n" ) ; return r ; } kiq = & adev -> gfx . kiq ; r = gfx_v9_0_kiq_init_ring ( adev , & kiq -> ring , & kiq -> irq ) ; if ( r ) { return r ; } r = gfx_v9_0_compute_mqd_sw_init ( adev ) ; if ( r ) { return r ; } } r = amdgpu_bo_create_kernel ( adev , adev -> gds . mem . gfx_partition_size , PAGE_SIZE , AMDGPU_GEM_DOMAIN_GDS , & adev -> gds . gds_gfx_bo , NULL , NULL ) ; if ( r ) { return r ; } r = amdgpu_bo_create_kernel ( adev , adev -> gds . gws . gfx_partition_size , PAGE_SIZE , AMDGPU_GEM_DOMAIN_GWS , & adev -> gds . gws_gfx_bo , NULL , NULL ) ; if ( r ) { return r ; } r = amdgpu_bo_create_kernel ( adev , adev -> gds . oa . gfx_partition_size , PAGE_SIZE , AMDGPU_GEM_DOMAIN_OA , & adev -> gds . oa_gfx_bo , NULL , NULL ) ; if ( r ) { return r ; } adev -> gfx . ce_ram_size = 0x8000 ; gfx_v9_0_gpu_early_init ( adev ) ; r = gfx_v9_0_ngg_init ( adev ) ; if ( r ) { return r ; } return 0 ; } 