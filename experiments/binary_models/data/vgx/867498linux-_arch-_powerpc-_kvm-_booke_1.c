int kvm_arch_vcpu_ioctl_set_guest_debug ( struct kvm_vcpu * vcpu , struct kvm_guest_debug * dbg ) { struct debug_reg * dbg_reg ; int n , b = 0 , w = 0 ; int ret = 0 ; vcpu_load ( vcpu ) ; if ( ! ( dbg -> control & KVM_GUESTDBG_ENABLE ) ) { vcpu -> arch . dbg_reg . dbcr0 = 0 ; vcpu -> guest_debug = 0 ; kvm_guest_protect_msr ( vcpu , MSR_DE , false ) ; out } kvm_guest_protect_msr ( vcpu , MSR_DE , true ) ; vcpu -> guest_debug = dbg -> control ; vcpu -> arch . dbg_reg . dbcr0 = 0 ; if ( vcpu -> guest_debug & KVM_GUESTDBG_SINGLESTEP ) { vcpu -> arch . dbg_reg . dbcr0 |= DBCR0_IDM | DBCR0_IC ; } dbg_reg = & ( vcpu -> arch . dbg_reg ) ; dbg_reg -> dbcr1 = 0 ; dbg_reg -> dbcr2 = 0 ; dbg_reg -> dbcr1 = DBCR1_IAC1US | DBCR1_IAC2US | DBCR1_IAC3US | DBCR1_IAC4US ; dbg_reg -> dbcr2 = DBCR2_DAC1US | DBCR2_DAC2US ; ret = - EINVAL ; for ( n = 0 ; n < ( KVMPPC_BOOKE_IAC_NUM + KVMPPC_BOOKE_DAC_NUM ) ; n ++ ) { uint64_t addr = dbg -> arch . bp [ n ] . addr ; uint32_t type = dbg -> arch . bp [ n ] . type ; if ( type == KVMPPC_DEBUG_NONE ) { continue ; } if ( type & ~ ( KVMPPC_DEBUG_WATCH_READ | KVMPPC_DEBUG_WATCH_WRITE | KVMPPC_DEBUG_BREAKPOINT ) ) { out } if ( type & KVMPPC_DEBUG_BREAKPOINT ) { if ( kvmppc_booke_add_breakpoint ( dbg_reg , addr , b ++ ) ) { out } } else { if ( kvmppc_booke_add_watchpoint ( dbg_reg , addr , type , w ++ ) ) { out } } } ret = 0 ; out vcpu_put ( vcpu ) ; return ret ; } 