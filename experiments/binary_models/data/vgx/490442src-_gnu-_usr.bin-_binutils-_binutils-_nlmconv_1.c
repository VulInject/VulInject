alpha_mangle_relocs ( , , , , , ) { long old_reloc_count ; arelent * * old_relocs ; register arelent * * relocs ; old_reloc_count = * reloc_count_ptr ; old_relocs = * relocs_ptr ; relocs = ( arelent * * ) xmalloc ( ( old_reloc_count + 3 ) * sizeof ( arelent * ) ) ; * relocs_ptr = relocs ; if ( nlm_alpha_backend_data ( outbfd ) -> lita_address == 0 ) { bfd * inbfd ; asection * lita_section ; inbfd = insec -> owner ; lita_section = bfd_get_section_by_name ( inbfd , _LITA ) ; if ( lita_section != ( asection * ) NULL ) { nlm_alpha_backend_data ( outbfd ) -> lita_address = bfd_get_section_vma ( inbfd , lita_section ) ; nlm_alpha_backend_data ( outbfd ) -> lita_size = bfd_section_size ( inbfd , lita_section ) ; } else { nlm_alpha_backend_data ( outbfd ) -> lita_address = 4 ; } * relocs = ( arelent * ) xmalloc ( sizeof ( arelent ) ) ; ( * relocs ) -> sym_ptr_ptr = bfd_abs_section_ptr -> symbol_ptr_ptr ; ( * relocs ) -> address = nlm_alpha_backend_data ( outbfd ) -> lita_address ; ( * relocs ) -> addend = nlm_alpha_backend_data ( outbfd ) -> lita_size + 1 ; ( * relocs ) -> howto = & nlm32_alpha_nw_howto ; ++ relocs ; ++ ( * reloc_count_ptr ) ; } if ( nlm_alpha_backend_data ( outbfd ) -> gp == 0 ) { nlm_alpha_backend_data ( outbfd ) -> gp = bfd_ecoff_get_gp_value ( insec -> owner ) ; } * relocs = ( arelent * ) xmalloc ( sizeof ( arelent ) ) ; ( * relocs ) -> sym_ptr_ptr = bfd_abs_section_ptr -> symbol_ptr_ptr ; ( * relocs ) -> address = nlm_alpha_backend_data ( outbfd ) -> gp ; ( * relocs ) -> addend = 0 ; ( * relocs ) -> howto = & nlm32_alpha_nw_howto ; ++ relocs ; ++ ( * reloc_count_ptr ) ; memcpy ( relocs , old_relocs , ( size_t ) old_reloc_count * sizeof ( arelent * ) ) ; relocs [ old_reloc_count ] = ( arelent * ) NULL ; if ( insec -> output_offset != 0 ) { register bfd_size_type i ; for ( i = 0 ; i < ( bfd_size_type ) old_reloc_count ; i ++ , relocs ++ ) { ( * relocs ) -> address += insec -> output_offset ; } } } powerpc_stub { struct powerpc_stub * next ; asymbol * start ; asymbol * reloc ; unsigned int toc_index ; } static struct powerpc_stub * powerpc_stubs ; static unsigned long powerpc_stub_insns [ ] { 0x81820000 0x90410014 0x800c0000 0x804c0004 0x7c0903a6 0x4e800420 0 0xc8000 0 } ; ; ( sizeof powerpc_stub_insns / sizeof powerpc_stub_insns [ 0 ] ) static bfd_size_type powerpc_initial_got_size ; static void powerpc_build_stubs ( bfd * inbfd , bfd * outbfd ATTRIBUTE_UNUSED , asymbol * * * symbols_ptr , long * symcount_ptr ) { asection * stub_sec ; asection * got_sec ; unsigned int got_base ; long i ; long symcount ; long stubcount ; stub_sec = bfd_make_section ( inbfd , ".stubs" ) ; if ( stub_sec == ( asection * ) NULL || ! bfd_set_section_flags ( inbfd , stub_sec , ( SEC_CODE | SEC_RELOC | SEC_ALLOC | SEC_LOAD ) ) || ! bfd_set_section_alignment ( inbfd , stub_sec , 2 ) ) { bfd_fatal ( ".stubs" ) ; } got_sec = bfd_get_section_by_name ( inbfd , ".got" ) ; if ( got_sec == ( asection * ) NULL ) { got_sec = bfd_make_section ( inbfd , ".got" ) ; if ( got_sec == ( asection * ) NULL || ! bfd_set_section_flags ( inbfd , got_sec , ( SEC_DATA | SEC_RELOC | SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS ) ) || ! bfd_set_section_alignment ( inbfd , got_sec , 2 ) ) { bfd_fatal ( ".got" ) ; } } powerpc_initial_got_size = bfd_section_size ( inbfd , got_sec ) ; got_base = powerpc_initial_got_size ; got_base = ( got_base + 3 ) & ~ 3 ; stubcount = 0 ; symcount = * symcount_ptr ; for ( i = 0 ; i < symcount ; i ++ ) { asymbol * sym ; asymbol * newsym ; char * newname ; struct powerpc_stub * item ; sym = ( * symbols_ptr ) [ i ] ; if ( bfd_asymbol_name ( sym ) [ 0 ] != '.' || ! bfd_is_und_section ( bfd_get_section ( sym ) ) ) { continue ; } newsym = ( asymbol * ) xmalloc ( sizeof ( asymbol ) ) ; * newsym = * sym ; newname = ( char * ) xmalloc ( strlen ( bfd_asymbol_name ( sym ) ) ) ; strcpy ( newname , bfd_asymbol_name ( sym ) + 1 ) ; newsym -> name = newname ; sym -> section = stub_sec ; sym -> value = stubcount * POWERPC_STUB_SIZE ; sym -> flags = BSF_LOCAL | BSF_DYNAMIC ; item = ( powerpc_stub * ) xmalloc ( sizeof ( powerpc_stub ) ) ; item -> start = sym ; item -> reloc = newsym ; item -> toc_index = got_base + stubcount * POWERPC_STUB_TOC_ENTRY_SIZE ; item -> next = powerpc_stubs ; powerpc_stubs = item ; ++ stubcount ; } if ( stubcount > 0 ) { asymbol * * s ; struct powerpc_stub * l ; * symbols_ptr = ( asymbol * * ) xrealloc ( ( char * ) * symbols_ptr , ( ( symcount + stubcount ) * sizeof ( asymbol ) ) ) ; * symcount_ptr += stubcount ; s = & ( * symbols_ptr ) [ symcount ] ; for ( l = powerpc_stubs ; l != ( powerpc_stub * ) NULL ; l = l -> next ) { * s ++ = l -> reloc ; } if ( ! bfd_set_section_size ( inbfd , stub_sec , stubcount * POWERPC_STUB_SIZE ) || ! bfd_set_section_size ( inbfd , got_sec , ( got_base + ( stubcount * POWERPC_STUB_TOC_ENTRY_SIZE ) ) ) ) { bfd_fatal ( _ ( "stub section sizes" ) ) ; } } } 