static int ef100_pci_walk_xilinx_table ( struct efx_nic * efx , u64 offset , struct ef100_func_ctl_window * result ) { u64 current_entry = offset ; int rc = 0 ; while ( true ) { u32 id = ef100_pci_get_bar_bits ( efx , current_entry , ENTRY_FORMAT ) ; u32 last = ef100_pci_get_bar_bits ( efx , current_entry , ENTRY_LAST ) ; u32 rev = ef100_pci_get_bar_bits ( efx , current_entry , ENTRY_REV ) ; u32 entry_size ; entry_size = ef100_pci_get_bar_bits ( efx , current_entry , ENTRY_SIZE ) ; netif_dbg ( efx , probe , efx -> net_dev , "Seen Xilinx table entry 0x%x size 0x%x at 0x%llx in BAR[%d]\n" , id , entry_size , current_entry , efx -> mem_bar ) ; if ( entry_size < sizeof ( u32 ) * 2 ) { netif_err ( efx , probe , efx -> net_dev , "Xilinx table entry too short len=0x%x\n" , entry_size ) ; return - EINVAL ; } switch ( id ) { case ESE_GZ_CFGBAR_ENTRY_EF100 : if ( rev != ESE_GZ_CFGBAR_ENTRY_REV_EF100 || entry_size < ESE_GZ_CFGBAR_ENTRY_SIZE_EF100 ) { netif_err ( efx , probe , efx -> net_dev , "Bad length or rev for EF100 entry in Xilinx capabilities table. entry_size=%d rev=%d.\n" , entry_size , rev ) ; return - EINVAL ; } rc = ef100_pci_parse_ef100_entry ( efx , current_entry , result ) ; if ( rc ) { return rc ; } break ; case ESE_GZ_CFGBAR_ENTRY_CONT_CAP_ADDR : if ( rev != 0 || entry_size < ESE_GZ_CFGBAR_CONT_CAP_MIN_LENGTH ) { netif_err ( efx , probe , efx -> net_dev , "Bad length or rev for continue entry in Xilinx capabilities table. entry_size=%d rev=%d.\n" , entry_size , rev ) ; return - EINVAL ; } rc = ef100_pci_parse_continue_entry ( efx , current_entry , result ) ; if ( rc ) { return rc ; } break ; default : break ; } if ( last ) { return 0 ; } current_entry += entry_size ; if ( ef100_pci_does_bar_overflow ( efx , efx -> mem_bar , current_entry ) ) { netif_err ( efx , probe , efx -> net_dev , "Xilinx table overrun at position=0x%llx.\n" , current_entry ) ; return - EINVAL ; } } } 