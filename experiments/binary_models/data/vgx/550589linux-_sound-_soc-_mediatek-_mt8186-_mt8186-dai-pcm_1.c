static int mtk_dai_pcm_hw_params ( struct snd_pcm_substream * substream , struct snd_pcm_hw_params * params , struct snd_soc_dai * dai ) { struct mtk_base_afe * afe = snd_soc_dai_get_drvdata ( dai ) ; struct mt8186_afe_private * afe_priv = afe -> platform_priv ; struct snd_soc_dapm_widget * p = snd_soc_dai_get_widget_playback ( dai ) ; struct snd_soc_dapm_widget * c = snd_soc_dai_get_widget_capture ( dai ) ; int pcm_id = dai -> id ; struct mtk_afe_pcm_priv * pcm_priv = afe_priv -> dai_priv [ pcm_id ] ; unsigned int rate = params_rate ( params ) ; unsigned int rate_reg = mt8186_rate_transform ( afe -> dev , rate , dai -> id ) ; snd_pcm_format_t format = params_format ( params ) ; unsigned int data_width = snd_pcm_format_width ( format ) ; unsigned int wlen_width = snd_pcm_format_physical_width ( format ) ; unsigned int pcm_con = 0 ; dev_dbg ( afe -> dev , "%s(), id %d, stream %d, widget active p %d, c %d\n" , __func__ , dai -> id , substream -> stream , p -> active , c -> active ) ; dev_dbg ( afe -> dev , "%s(), rate %d, rate_reg %d, data_width %d, wlen_width %d\n" , __func__ , rate , rate_reg , data_width , wlen_width ) ; switch ( dai -> id ) { case MT8186_DAI_PCM : pcm_con |= AUD_TX_LCH_RPT_NO_REPEAT << PCM_TX_LCH_RPT_SFT ; pcm_con |= AUD_VBT_16K_MODE_DISABLE << PCM_VBT_16K_MODE_SFT ; pcm_con |= AUD_EXT_MODEM_SELECT_EXTERNAL << PCM_EXT_MODEM_SFT ; pcm_con |= AUD_PCM_ONE_BCK_CYCLE_SYNC << PCM_SYNC_TYPE_SFT ; pcm_con |= AUD_BT_MODE_DUAL_MIC_ON_TX << PCM_BT_MODE_SFT ; pcm_con |= AUD_PCM_AFIFO_AFIFO << PCM_BYP_ASRC_SFT ; pcm_con |= AUD_PCM_CLOCK_MASTER_MODE << PCM_SLAVE_SFT ; pcm_con |= 0 << PCM_SYNC_LENGTH_SFT ; pcm_con |= rate_reg << PCM_MODE_SFT ; pcm_con |= pcm_priv -> fmt << PCM_FMT_SFT ; if ( data_width > 16 ) { pcm_con |= AUD_PCM_24BIT_PCM_24_BITS << PCM_24BIT_SFT ; } else { pcm_con |= AUD_PCM_24BIT_PCM_16_BITS << PCM_24BIT_SFT ; } if ( wlen_width > 16 ) { pcm_con |= AUD_PCM_WLEN_PCM_64_BCK_CYCLES << PCM_WLEN_SFT ; } else { pcm_con |= AUD_PCM_WLEN_PCM_32_BCK_CYCLES << PCM_WLEN_SFT ; } pcm_con |= pcm_priv -> lck_invert << PCM_SYNC_OUT_INV_SFT ; pcm_con |= pcm_priv -> bck_invert << PCM_BCLK_OUT_INV_SFT ; regmap_update_bits ( afe -> regmap , PCM_INTF_CON1 , 0xfffffffe , pcm_con ) ; break ; default : dev_err ( afe -> dev , "%s(), id %d not support\n" , __func__ , dai -> id ) ; return - EINVAL ; } return 0 ; } 