static int activate ( AVFilterContext * ctx ) { AVFilterLink * inlink = ctx -> inputs [ 0 ] ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; AudioDelayContext * s = ctx -> priv ; AVFrame * frame = NULL ; int ret , status ; int64_t pts ; FF_FILTER_FORWARD_STATUS_BACK ( outlink , inlink ) ; if ( s -> padding ) { int nb_samples = FFMIN ( s -> padding , 2048 ) ; frame = ff_get_audio_buffer ( outlink , nb_samples ) ; s -> padding -= nb_samples ; av_samples_set_silence ( frame -> extended_data , 0 , frame -> nb_samples , outlink -> ch_layout . nb_channels , frame -> format ) ; frame -> pts = s -> next_pts ; if ( s -> next_pts != AV_NOPTS_VALUE ) { s -> next_pts += av_rescale_q ( nb_samples , ( AVRational ) { 1 outlink -> sample_rate } , outlink -> time_base ) ; } return ff_filter_frame ( outlink , frame ) ; } ret = ff_inlink_consume_frame ( inlink , & frame ) ; if ( ret < 0 ) { return ret ; } if ( ret > 0 ) { return filter_frame ( inlink , frame ) ; } if ( ff_inlink_acknowledge_status ( inlink , & status , & pts ) ) { if ( status == AVERROR_EOF ) { s -> eof = 1 ; } } if ( s -> eof && s -> max_delay ) { int nb_samples = FFMIN ( s -> max_delay , 2048 ) ; frame = ff_get_audio_buffer ( outlink , nb_samples ) ; if ( ! frame ) { return AVERROR ( ENOMEM ) ; } s -> max_delay -= nb_samples ; av_samples_set_silence ( frame -> extended_data , 0 , frame -> nb_samples , outlink -> ch_layout . nb_channels , frame -> format ) ; frame -> pts = s -> next_pts ; return filter_frame ( inlink , frame ) ; } if ( s -> eof && s -> max_delay == 0 ) { ff_outlink_set_status ( outlink , AVERROR_EOF , s -> next_pts ) ; return 0 ; } if ( ! s -> eof ) { FF_FILTER_FORWARD_WANTED ( outlink , inlink ) ; } return FFERROR_NOT_READY ; } 