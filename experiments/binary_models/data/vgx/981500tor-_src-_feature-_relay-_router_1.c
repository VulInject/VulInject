int init_keys ( void ) { char * keydir ; const char * mydesc ; crypto_pk_t * prkey ; char digest [ DIGEST_LEN ] ; char v3_digest [ DIGEST_LEN ] ; const or_options_t * options = get_options ( ) ; dirinfo_type_t type ; time_t now = time ( NULL ) ; dir_server_t * ds ; int v3_digest_set = 0 ; authority_cert_t * cert = NULL ; if ( ! server_mode ( options ) && ! ( options -> command == CMD_KEY_EXPIRATION ) ) { return init_keys_client ( ) ; } if ( init_keys_common ( ) < 0 ) { return - 1 ; } if ( create_keys_directory ( options ) < 0 ) { return - 1 ; } if ( authdir_mode_v3 ( options ) ) { if ( init_v3_authority_keys ( ) < 0 ) { log_err ( LD_GENERAL , "We're configured as a V3 authority, but we " "were unable to load our v3 authority keys and certificate! " "Use tor-gencert to generate them. Dying." ) ; return - 1 ; } cert = get_my_v3_authority_cert ( ) ; if ( cert ) { if ( crypto_pk_get_digest ( get_my_v3_authority_cert ( ) -> identity_key , v3_digest ) < 0 ) { log_err ( LD_BUG , "Couldn't compute my v3 authority identity key " "digest." ) ; return - 1 ; } v3_digest_set = 1 ; } } keydir = get_keydir_fname ( "secret_id_key" ) ; log_info ( LD_GENERAL , "Reading/making identity key \"%s\"..." , keydir ) ; bool created = false ; prkey = init_key_from_file ( keydir , 1 , LOG_ERR , & created ) ; tor_free ( keydir ) ; if ( ! prkey ) { return - 1 ; } if ( created ) { log_new_relay_greeting ( ) ; } set_server_identity_key ( prkey ) ; if ( public_server_mode ( options ) ) { set_client_identity_key ( crypto_pk_dup_key ( prkey ) ) ; } else { if ( ! ( prkey = crypto_pk_new ( ) ) ) { return - 1 ; } if ( crypto_pk_generate_key ( prkey ) ) { crypto_pk_free ( prkey ) ; return - 1 ; } set_client_identity_key ( prkey ) ; } const int new_signing_key = load_ed_keys ( options , now ) ; if ( new_signing_key < 0 ) { return - 1 ; } keydir = get_keydir_fname ( "secret_onion_key" ) ; log_info ( LD_GENERAL , "Reading/making onion key \"%s\"..." , keydir ) ; prkey = init_key_from_file ( keydir , 1 , LOG_ERR , & created ) ; if ( created ) { log_new_relay_greeting ( ) ; } tor_free ( keydir ) ; if ( ! prkey ) { return - 1 ; } set_onion_key ( prkey ) ; if ( options -> command == CMD_RUN_TOR ) { or_state_t * state = get_or_state ( ) ; if ( state -> LastRotatedOnionKey > 100 && state -> LastRotatedOnionKey < now ) { onionkey_set_at = state -> LastRotatedOnionKey ; } else { state -> LastRotatedOnionKey = onionkey_set_at = now ; or_state_mark_dirty ( state , options -> AvoidDiskWrites ?time ( NULL ) + 3600 : 0 ) ; } } keydir = get_keydir_fname ( "secret_onion_key.old" ) ; if ( ! lastonionkey && file_status ( keydir ) == FN_FILE ) { prkey = init_key_from_file ( keydir , 0 , LOG_ERR , 0 ) ; if ( prkey ) { lastonionkey = prkey ; } } tor_free ( keydir ) ; { int r ; keydir = get_keydir_fname ( "secret_onion_key_ntor" ) ; r = init_curve25519_keypair_from_file ( & curve25519_onion_key , keydir , 1 , LOG_ERR , "onion" ) ; tor_free ( keydir ) ; if ( r < 0 ) { return - 1 ; } keydir = get_keydir_fname ( "secret_onion_key_ntor.old" ) ; if ( fast_mem_is_zero ( ( const char * ) last_curve25519_onion_key . pubkey . public_key , CURVE25519_PUBKEY_LEN ) && file_status ( keydir ) == FN_FILE ) { init_curve25519_keypair_from_file ( & last_curve25519_onion_key , keydir , 0 , LOG_ERR , "onion" ) ; } tor_free ( keydir ) ; } if ( router_initialize_tls_context ( ) < 0 ) { log_err ( LD_GENERAL , "Error initializing TLS context" ) ; return - 1 ; } if ( generate_ed_link_cert ( options , now , new_signing_key > 0 ) < 0 ) { log_err ( LD_GENERAL , "Couldn't make link cert" ) ; return - 1 ; } mydesc = router_get_my_descriptor ( ) ; if ( authdir_mode_v3 ( options ) ) { const char * m = NULL ; routerinfo_t * ri ; if ( dirserv_add_own_fingerprint ( get_server_identity_key ( ) , get_master_identity_key ( ) ) ) { log_err ( LD_GENERAL , "Error adding own fingerprint to set of relays" ) ; return - 1 ; } if ( mydesc ) { was_router_added_t added ; ri = router_parse_entry_from_string ( mydesc , NULL , 1 , 0 , NULL , NULL ) ; if ( ! ri ) { log_err ( LD_GENERAL , "Generated a routerinfo we couldn't parse." ) ; return - 1 ; } added = dirserv_add_descriptor ( ri , & m , "self" ) ; if ( ! WRA_WAS_ADDED ( added ) ) { if ( ! WRA_WAS_OUTDATED ( added ) ) { log_err ( LD_GENERAL , "Unable to add own descriptor to directory: %s" , m ?m : "<unknown error>" ) ; return - 1 ; } else { log_info ( LD_GENERAL , "Couldn't add own descriptor to directory " "after key init: %s This is usually not a problem." , m ?m : "<unknown error>" ) ; } } } } if ( router_write_fingerprint ( 0 , 0 ) ) { log_err ( LD_FS , "Error writing fingerprint to file" ) ; return - 1 ; } if ( ! public_server_mode ( options ) && router_write_fingerprint ( 1 , 0 ) ) { log_err ( LD_FS , "Error writing hashed fingerprint to file" ) ; return - 1 ; } if ( router_write_fingerprint ( 0 , 1 ) ) { log_err ( LD_FS , "Error writing ed25519 identity to file" ) ; return - 1 ; } if ( ! public_server_mode ( options ) ) { router_announce_bridge_status_page ( ) ; } if ( ! authdir_mode ( options ) ) { return 0 ; } if ( dirserv_load_fingerprint_file ( ) < 0 ) { log_err ( LD_GENERAL , "Error loading fingerprints" ) ; return - 1 ; } crypto_pk_get_digest ( get_server_identity_key ( ) , digest ) ; type = ( ( options -> V3AuthoritativeDir ?( V3_DIRINFO | MICRODESC_DIRINFO | EXTRAINFO_DIRINFO ) : NO_DIRINFO ) | ( options -> BridgeAuthoritativeDir ?BRIDGE_DIRINFO : NO_DIRINFO ) ) ; ds = router_get_trusteddirserver_by_digest ( digest ) ; if ( ! ds ) { tor_addr_port_t ipv6_orport ; routerconf_find_ipv6_or_ap ( options , & ipv6_orport ) ; ds = trusted_dir_server_new ( options -> Nickname , NULL , routerconf_find_dir_port ( options , 0 ) , routerconf_find_or_port ( options , AF_INET ) , & ipv6_orport , digest , v3_digest , type , 0.0 ) ; if ( ! ds ) { log_err ( LD_GENERAL , "We want to be a directory authority, but we " "couldn't add ourselves to the authority list. Failing." ) ; return - 1 ; } dir_server_add ( ds ) ; } if ( ds -> type != type ) { log_warn ( LD_DIR , "Configured authority type does not match authority " "type in DirAuthority list.  Adjusting. (%d v %d)" , type , ds -> type ) ; ds -> type = type ; } if ( v3_digest_set && ( ds -> type & V3_DIRINFO ) && tor_memneq ( v3_digest , ds -> v3_identity_digest , DIGEST_LEN ) ) { log_warn ( LD_DIR , "V3 identity key does not match identity declared in " "DirAuthority line.  Adjusting." ) ; memcpy ( ds -> v3_identity_digest , v3_digest , DIGEST_LEN ) ; } if ( cert ) { log_info ( LD_DIR , "adding my own v3 cert" ) ; if ( trusted_dirs_load_certs_from_string ( cert -> cache_info . signed_descriptor_body , TRUSTED_DIRS_CERTS_SRC_SELF , 0 , NULL ) < 0 ) { log_warn ( LD_DIR , "Unable to parse my own v3 cert! Failing." ) ; return - 1 ; } } return 0 ; } 