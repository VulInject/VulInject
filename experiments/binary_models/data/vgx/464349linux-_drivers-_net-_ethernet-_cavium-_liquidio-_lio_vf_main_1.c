static void liquidio_destroy_nic_device ( struct octeon_device * oct , int ifidx ) { struct net_device * netdev = oct -> props [ ifidx ] . netdev ; struct octeon_device_priv * oct_priv = ( octeon_device_priv * ) oct -> priv ; struct napi_struct * napi , * n ; struct lio * lio ; if ( ! netdev ) { dev_err ( & oct -> pci_dev -> dev , "%s No netdevice ptr for index %d\n" , __func__ , ifidx ) ; return ; } lio = GET_LIO ( netdev ) ; dev_dbg ( & oct -> pci_dev -> dev , "NIC device cleanup\n" ) ; if ( atomic_read ( & lio -> ifstate ) & LIO_IFSTATE_RUNNING ) { liquidio_stop ( netdev ) ; } if ( oct -> props [ lio -> ifidx ] . napi_enabled == 1 ) { list_for_each_entry_safe ( , , , ) napi_disable ( napi ) ; oct -> props [ lio -> ifidx ] . napi_enabled = 0 ; oct -> droq [ 0 ] -> ops . poll_mode = 0 ; } list_for_each_entry_safe ( , , , ) netif_napi_del ( napi ) ; tasklet_enable ( & oct_priv -> droq_tasklet ) ; if ( atomic_read ( & lio -> ifstate ) & LIO_IFSTATE_REGISTERED ) { unregister_netdev ( netdev ) ; } cleanup_rx_oom_poll_fn ( netdev ) ; cleanup_link_status_change_wq ( netdev ) ; lio_delete_glists ( lio ) ; oct -> props [ ifidx ] . gmxport = - 1 ; oct -> props [ ifidx ] . netdev = NULL ; } 