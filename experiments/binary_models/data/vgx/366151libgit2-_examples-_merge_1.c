int lg2_merge ( git_repository * repo , int argc , char * * argv ) { struct merge_options opts ; git_index * index ; git_repository_state_t state ; git_merge_analysis_t analysis ; git_merge_preference_t preference ; const char * path = "." ; int err = 0 ; merge_options_init ( & opts ) ; parse_options ( & path , & opts , argc , argv ) ; state = git_repository_state ( repo ) ; if ( state != GIT_REPOSITORY_STATE_NONE ) { fprintf ( stderr , "repository is in unexpected state %d\n" , state ) ; cleanup } err = resolve_heads ( repo , & opts ) ; if ( err != 0 ) { cleanup } err = git_merge_analysis ( & analysis , & preference , repo , ( const git_annotated_commit * * ) opts . annotated , opts . annotated_count ) ; check_lg2 ( err , "merge analysis failed" , NULL ) ; if ( analysis & GIT_MERGE_ANALYSIS_UP_TO_DATE ) { printf ( "Already up-to-date\n" ) ; return 0 ; } if ( analysis & GIT_MERGE_ANALYSIS_UNBORN || ( analysis & GIT_MERGE_ANALYSIS_FASTFORWARD && ! ( preference & GIT_MERGE_PREFERENCE_NO_FASTFORWARD ) ) ) { const git_oid * target_oid ; if ( analysis & GIT_MERGE_ANALYSIS_UNBORN ) { printf ( "Unborn\n" ) ; } else { printf ( "Fast-forward\n" ) ; } target_oid = git_annotated_commit_id ( opts . annotated [ 0 ] ) ; assert ( opts . annotated_count == 1 ) ; return perform_fastforward ( repo , target_oid , ( analysis & GIT_MERGE_ANALYSIS_UNBORN ) ) ; } if ( analysis & GIT_MERGE_ANALYSIS_NORMAL ) { git_merge_options merge_opts = GIT_MERGE_OPTIONS_INIT ; git_checkout_options checkout_opts = GIT_CHECKOUT_OPTIONS_INIT ; merge_opts . flags = 0 ; merge_opts . file_flags = GIT_MERGE_FILE_STYLE_DIFF3 ; checkout_opts . checkout_strategy = GIT_CHECKOUT_FORCE | GIT_CHECKOUT_ALLOW_CONFLICTS ; if ( preference & GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY ) { printf ( "Fast-forward is preferred, but only a merge is possible\n" ) ; return - 1 ; } err = git_merge ( repo , ( const git_annotated_commit * * ) opts . annotated , opts . annotated_count , & merge_opts , & checkout_opts ) ; check_lg2 ( err , "merge failed" , NULL ) ; } check_lg2 ( git_repository_index ( & index , repo ) , "failed to get repository index" , NULL ) ; if ( git_index_has_conflicts ( index ) ) { output_conflicts ( index ) ; } if ( ! opts . no_commit ) { create_merge_commit ( repo , index , & opts ) ; printf ( "Merge made\n" ) ; } cleanup free ( ( char * * ) opts . heads ) ; return 0 ; } 