int arm_spe_process_auxtrace_info ( union perf_event * event , struct perf_session * session ) { struct perf_record_auxtrace_info * auxtrace_info = & event -> auxtrace_info ; size_t min_sz = sizeof ( u64 ) * ARM_SPE_AUXTRACE_PRIV_MAX ; struct perf_record_time_conv * tc = & session -> time_conv ; const char * cpuid = perf_env__cpuid ( session -> evlist -> env ) ; u64 midr = strtol ( cpuid , NULL , 16 ) ; struct arm_spe * spe ; int err ; if ( auxtrace_info -> header . size < sizeof ( perf_record_auxtrace_info ) + min_sz ) { return - EINVAL ; } spe = zalloc ( sizeof ( arm_spe ) ) ; if ( ! spe ) { return - ENOMEM ; } err = auxtrace_queues__init ( & spe -> queues ) ; if ( err ) { err_free } spe -> session = session ; spe -> machine = & session -> machines . host ; spe -> auxtrace_type = auxtrace_info -> type ; spe -> pmu_type = auxtrace_info -> priv [ ARM_SPE_PMU_TYPE ] ; spe -> midr = midr ; spe -> timeless_decoding = arm_spe__is_timeless_decoding ( spe ) ; spe -> tc . time_shift = tc -> time_shift ; spe -> tc . time_mult = tc -> time_mult ; spe -> tc . time_zero = tc -> time_zero ; if ( event_contains ( * tc , time_cycles ) ) { spe -> tc . time_cycles = tc -> time_cycles ; spe -> tc . time_mask = tc -> time_mask ; spe -> tc . cap_user_time_zero = tc -> cap_user_time_zero ; spe -> tc . cap_user_time_short = tc -> cap_user_time_short ; } spe -> auxtrace . process_event = arm_spe_process_event ; spe -> auxtrace . process_auxtrace_event = arm_spe_process_auxtrace_event ; spe -> auxtrace . flush_events = arm_spe_flush ; spe -> auxtrace . free_events = arm_spe_free_events ; spe -> auxtrace . free = arm_spe_free ; spe -> auxtrace . evsel_is_auxtrace = arm_spe_evsel_is_auxtrace ; session -> auxtrace = & spe -> auxtrace ; arm_spe_print_info ( & auxtrace_info -> priv [ 0 ] ) ; if ( dump_trace ) { return 0 ; } if ( session -> itrace_synth_opts && session -> itrace_synth_opts -> set ) { spe -> synth_opts = * session -> itrace_synth_opts ; } else { itrace_synth_opts__set_default ( & spe -> synth_opts , false ) ; } err = arm_spe_synth_events ( spe , session ) ; if ( err ) { err_free_queues } err = auxtrace_queues__process_index ( & spe -> queues , session ) ; if ( err ) { err_free_queues } if ( spe -> queues . populated ) { spe -> data_queued = true ; } return 0 ; err_free_queues auxtrace_queues__free ( & spe -> queues ) ; session -> auxtrace = NULL ; err_free return err ; } 