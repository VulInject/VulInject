int seccomp_restrict_namespaces ( unsigned long retain ) { uint32_t arch ; int r ; if ( DEBUG_LOGGING ) { _cleanup_free_ char * s = NULL ; ( void ) namespace_flags_to_string ( retain , & s ) ; log_debug ( "Restricting namespace to: %s." , strna ( s ) ) ; } if ( FLAGS_SET ( retain , NAMESPACE_FLAGS_ALL ) ) { return 0 ; } SECCOMP_FOREACH_LOCAL_ARCH ( ) { _cleanup_ ( ) scmp_filter_ctx seccomp = NULL ; log_debug ( "Operating on architecture: %s" , seccomp_arch_to_string ( arch ) ) ; r = seccomp_init_for_arch ( & seccomp , arch , SCMP_ACT_ALLOW ) ; r = seccomp_rule_add_exact ( seccomp , SCMP_ACT_ERRNO ( ENOSYS ) , SCMP_SYS ( clone3 ) , 0 ) ; if ( r < 0 ) { log_debug_errno ( r , "Failed to add clone3() rule for architecture %s, ignoring: %m" , seccomp_arch_to_string ( arch ) ) ; } if ( ( retain & NAMESPACE_FLAGS_ALL ) == 0 ) { r = seccomp_rule_add_exact ( seccomp , SCMP_ACT_ERRNO ( EPERM ) , SCMP_SYS ( setns ) , 0 ) ; } else { r = seccomp_rule_add_exact ( seccomp , SCMP_ACT_ERRNO ( EPERM ) , SCMP_SYS ( setns ) , 1 , SCMP_A1 ( SCMP_CMP_EQ , 0 ) ) ; } if ( r < 0 ) { log_debug_errno ( r , "Failed to add setns() rule for architecture %s, skipping: %m" , seccomp_arch_to_string ( arch ) ) ; continue ; } for ( unsigned i = 0 ; namespace_info [ i ] . proc_name ; i ++ ) { unsigned long f ; f = namespace_info [ i ] . clone_flag ; if ( FLAGS_SET ( retain , f ) ) { log_debug ( "Permitting %s." , namespace_info [ i ] . proc_name ) ; continue ; } log_debug ( "Blocking %s." , namespace_info [ i ] . proc_name ) ; r = seccomp_rule_add_exact ( seccomp , SCMP_ACT_ERRNO ( EPERM ) , SCMP_SYS ( unshare ) , 1 , SCMP_A0 ( SCMP_CMP_MASKED_EQ , f , f ) ) ; if ( r < 0 ) { log_debug_errno ( r , "Failed to add unshare() rule for architecture %s, skipping: %m" , seccomp_arch_to_string ( arch ) ) ; break ; } if ( ! IN_SET ( arch , SCMP_ARCH_S390 , SCMP_ARCH_S390X ) ) { r = seccomp_rule_add_exact ( seccomp , SCMP_ACT_ERRNO ( EPERM ) , SCMP_SYS ( clone ) , 1 , SCMP_A0 ( SCMP_CMP_MASKED_EQ , f , f ) ) ; } else { r = seccomp_rule_add_exact ( seccomp , SCMP_ACT_ERRNO ( EPERM ) , SCMP_SYS ( clone ) , 1 , SCMP_A1 ( SCMP_CMP_MASKED_EQ , f , f ) ) ; } if ( r < 0 ) { log_debug_errno ( r , "Failed to add clone() rule for architecture %s, skipping: %m" , seccomp_arch_to_string ( arch ) ) ; break ; } if ( ( retain & NAMESPACE_FLAGS_ALL ) != 0 ) { r = seccomp_rule_add_exact ( seccomp , SCMP_ACT_ERRNO ( EPERM ) , SCMP_SYS ( setns ) , 1 , SCMP_A1 ( SCMP_CMP_MASKED_EQ , f , f ) ) ; if ( r < 0 ) { log_debug_errno ( r , "Failed to add setns() rule for architecture %s, skipping: %m" , seccomp_arch_to_string ( arch ) ) ; break ; } } } if ( r < 0 ) { continue ; } r = seccomp_load ( seccomp ) ; if ( ERRNO_IS_SECCOMP_FATAL ( r ) ) { return r ; } if ( r < 0 ) { log_debug_errno ( r , "Failed to install namespace restriction rules for architecture %s, skipping: %m" , seccomp_arch_to_string ( arch ) ) ; } } return 0 ; } 