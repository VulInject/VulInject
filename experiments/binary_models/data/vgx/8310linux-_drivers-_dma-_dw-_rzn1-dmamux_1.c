static void * rzn1_dmamux_route_allocate ( struct of_phandle_args * dma_spec , struct of_dma * ofdma ) { struct platform_device * pdev = of_find_device_by_node ( ofdma -> of_node ) ; struct rzn1_dmamux_data * dmamux = platform_get_drvdata ( pdev ) ; struct rzn1_dmamux_map * map ; unsigned int dmac_idx , chan , val ; u32 mask ; int ret ; if ( dma_spec -> args_count != RNZ1_DMAMUX_NCELLS ) { return ERR_PTR ( - EINVAL ) ; } map = kmalloc ( sizeof ( * map ) , GFP_KERNEL ) ; if ( ! map ) { return ERR_PTR ( - ENOMEM ) ; } chan = dma_spec -> args [ 0 ] ; map -> req_idx = dma_spec -> args [ 4 ] ; val = dma_spec -> args [ 5 ] ; dma_spec -> args_count -= 2 ; if ( chan >= RZN1_DMAMUX_LINES_PER_CTLR ) { dev_err ( & pdev -> dev , "Invalid DMA request line: %u\n" , chan ) ; ret = - EINVAL ; free_map } if ( map -> req_idx >= RZN1_DMAMUX_MAX_LINES || ( map -> req_idx % RZN1_DMAMUX_LINES_PER_CTLR ) != chan ) { dev_err ( & pdev -> dev , "Invalid MUX request line: %u\n" , map -> req_idx ) ; ret = - EINVAL ; free_map } dmac_idx = map -> req_idx >= RZN1_DMAMUX_LINES_PER_CTLR ?1 : 0 ; dma_spec -> np = of_parse_phandle ( ofdma -> of_node , "dma-masters" , dmac_idx ) ; if ( ! dma_spec -> np ) { dev_err ( & pdev -> dev , "Can't get DMA master\n" ) ; ret = - EINVAL ; free_map } dev_dbg ( & pdev -> dev , "Mapping DMAMUX request %u to DMAC%u request %u\n" , map -> req_idx , dmac_idx , chan ) ; if ( test_and_set_bit ( map -> req_idx , dmamux -> used_chans ) ) { ret = - EBUSY ; free_map } mask = BIT ( map -> req_idx ) ; ret = r9a06g032_sysctrl_set_dmamux ( mask , val ?mask : 0 ) ; if ( ret ) { clear_bitmap } return map ; clear_bitmap clear_bit ( map -> req_idx , dmamux -> used_chans ) ; free_map kfree ( map ) ; return ERR_PTR ( ret ) ; } static const struct of_device_id rzn1_dmac_match [ ] { { . compatible = "renesas,rzn1-dma" } { } } ; ; 