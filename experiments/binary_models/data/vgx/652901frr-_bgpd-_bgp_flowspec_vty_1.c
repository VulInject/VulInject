void route_vty_out_flowspec ( struct vty * vty , const struct prefix * p , struct bgp_path_info * path , int display , json_object * json_paths ) { struct attr * attr ; char return_string [ BGP_FLOWSPEC_STRING_DISPLAY_MAX ] ; char * s1 = NULL , * s2 = NULL ; json_object * json_nlri_path ; json_object * json_ecom_path = NULL ; json_object * json_time_path = NULL ; char timebuf [ BGP_UPTIME_LEN ] ; struct ecommunity * ipv6_ecomm = NULL ; if ( p == NULL || p -> family != AF_FLOWSPEC ) { return ; } if ( json_paths ) { if ( display == NLRI_STRING_FORMAT_JSON ) { json_nlri_path = json_object_new_object ( ) ; } else { json_nlri_path = json_paths ; } } if ( display == NLRI_STRING_FORMAT_LARGE && path ) { vty_out ( vty , "BGP flowspec entry: (flags 0x%x)\n" , path -> flags ) ; } bgp_fs_nlri_get_string ( ( unsigned char * ) p -> u . prefix_flowspec . ptr , p -> u . prefix_flowspec . prefixlen , return_string , display , json_nlri_path , family2afi ( p -> u . prefix_flowspec . family ) ) ; if ( display == NLRI_STRING_FORMAT_LARGE ) { vty_out ( vty , "%s" , return_string ) ; } if ( display == NLRI_STRING_FORMAT_DEBUG ) { vty_out ( vty , "%s" , return_string ) ; } if ( display == NLRI_STRING_FORMAT_MIN ) { vty_out ( vty , " %-30s" , return_string ) ; } if ( json_paths && display == NLRI_STRING_FORMAT_JSON ) { json_object_array_add ( json_paths , json_nlri_path ) ; } if ( ! path ) { return ; } if ( path -> attr ) { ipv6_ecomm = bgp_attr_get_ipv6_ecommunity ( path -> attr ) ; } if ( path -> attr && ( bgp_attr_get_ecommunity ( path -> attr ) || ipv6_ecomm ) ) { attr = path -> attr ; if ( bgp_attr_get_ecommunity ( attr ) ) { s1 = ecommunity_ecom2str ( bgp_attr_get_ecommunity ( attr ) , ECOMMUNITY_FORMAT_ROUTE_MAP , 0 ) ; } if ( ipv6_ecomm ) { s2 = ecommunity_ecom2str ( ipv6_ecomm , ECOMMUNITY_FORMAT_ROUTE_MAP , 0 ) ; } if ( ! s1 && ! s2 ) { return ; } if ( display == NLRI_STRING_FORMAT_LARGE ) { vty_out ( vty , "\t%s%s%s\n" , s1 ?s1 : "" , s2 && s1 ?" " : "" , s2 ?s2 : "" ) ; } if ( display == NLRI_STRING_FORMAT_MIN ) { vty_out ( vty , "%s%s" , s1 ?s1 : "" , s2 ?s2 : "" ) ; } if ( json_paths ) { json_ecom_path = json_object_new_object ( ) ; if ( s1 ) { json_object_string_add ( json_ecom_path , "ecomlist" , s1 ) ; } if ( s2 ) { json_object_string_add ( json_ecom_path , "ecom6list" , s2 ) ; } if ( display == NLRI_STRING_FORMAT_JSON ) { json_object_array_add ( json_paths , json_ecom_path ) ; } } if ( display == NLRI_STRING_FORMAT_LARGE ) { char local_buff [ INET6_ADDRSTRLEN ] ; local_buff [ 0 ] = '\0' ; if ( p -> u . prefix_flowspec . family == AF_INET && attr -> nexthop . s_addr != INADDR_ANY ) { inet_ntop ( AF_INET , & attr -> nexthop . s_addr , local_buff , sizeof ( local_buff ) ) ; } if ( p -> u . prefix_flowspec . family == AF_INET6 && attr -> mp_nexthop_len != 0 && attr -> mp_nexthop_len != BGP_ATTR_NHLEN_IPV4 && attr -> mp_nexthop_len != BGP_ATTR_NHLEN_VPNV4 ) { inet_ntop ( AF_INET6 , & attr -> mp_nexthop_global , local_buff , sizeof ( local_buff ) ) ; } if ( local_buff [ 0 ] != '\0' ) { vty_out ( vty , "\tNLRI NH %s\n" , local_buff ) ; } } XFREE ( MTYPE_ECOMMUNITY_STR , s1 ) ; XFREE ( MTYPE_ECOMMUNITY_STR , s2 ) ; } peer_uptime ( path -> uptime , timebuf , BGP_UPTIME_LEN , 0 , NULL ) ; if ( display == NLRI_STRING_FORMAT_LARGE ) { vty_out ( vty , "\treceived for %8s\n" , timebuf ) ; } if ( json_paths ) { json_time_path = json_object_new_object ( ) ; json_object_string_add ( json_time_path , "time" , timebuf ) ; if ( display == NLRI_STRING_FORMAT_JSON ) { json_object_array_add ( json_paths , json_time_path ) ; } } if ( display == NLRI_STRING_FORMAT_LARGE ) { struct bgp_path_info_extra * extra = bgp_path_info_extra_get ( path ) ; bool list_began = false ; if ( extra -> bgp_fs_pbr && listcount ( extra -> bgp_fs_pbr ) ) { struct listnode * node ; struct bgp_pbr_match_entry * bpme ; struct bgp_pbr_match * bpm ; struct list * list_bpm ; list_bpm = list_new ( ) ; vty_out ( vty , "\tinstalled in PBR" ) ; for ( ALL_LIST_ELEMENTS_RO ( extra -> bgp_fs_pbr , node , bpme ) ; ) { bpm = bpme -> backpointer ; if ( listnode_lookup ( list_bpm , bpm ) ) { continue ; } listnode_add ( list_bpm , bpm ) ; if ( ! list_began ) { vty_out ( vty , " (" ) ; list_began = true ; } else { vty_out ( vty , ", " ) ; } vty_out ( vty , "%s" , bpm -> ipset_name ) ; } list_delete ( & list_bpm ) ; } if ( extra -> bgp_fs_iprule && listcount ( extra -> bgp_fs_iprule ) ) { struct listnode * node ; struct bgp_pbr_rule * bpr ; if ( ! list_began ) { vty_out ( vty , "\tinstalled in PBR" ) ; } for ( ALL_LIST_ELEMENTS_RO ( extra -> bgp_fs_iprule , node , bpr ) ; ) { if ( ! bpr -> action ) { continue ; } if ( ! list_began ) { vty_out ( vty , " (" ) ; list_began = true ; } else { vty_out ( vty , ", " ) ; } vty_out ( vty , "-ipv4-rule %d action lookup %u-" , bpr -> priority , bpr -> action -> table_id ) ; } } if ( list_began ) { vty_out ( vty , ")\n" ) ; } else { vty_out ( vty , "\tnot installed in PBR\n" ) ; } } } 