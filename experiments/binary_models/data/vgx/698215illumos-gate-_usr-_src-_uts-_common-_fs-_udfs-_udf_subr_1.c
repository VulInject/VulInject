void ud_flushi ( int32_t flag ) { struct ud_inode * ip , * lip ; struct vnode * vp ; int cheap = flag & SYNC_ATTR ; int32_t index ; union ihead * ih ; mutex_enter ( & ud_icache_lock ) ; for ( index = 0 ; index < UD_HASH_SZ ; index ++ ) { ih = & ud_ihead [ index ] ; lip = NULL ; for ( ip = ih -> ih_chain [ 0 ] , lip = NULL ; ip && ip != ( ud_inode * ) ih ; ip = ip -> i_forw ) { int flag = ip -> i_flag ; vp = ITOV ( ip ) ; if ( ( flag & IREF ) == 0 || ( ! vn_has_cached_data ( vp ) && ( ( flag & ( IMOD | IACC | IUPD | ICHG ) ) == 0 ) ) || ( vp -> v_vfsp == NULL ) || vn_is_readonly ( vp ) ) { continue ; } VN_HOLD ( vp ) ; if ( lip != NULL ) { ITIMES ( lip ) ; VN_RELE ( ITOV ( lip ) ) ; } lip = ip ; if ( cheap || IS_SWAPVP ( vp ) ) { ud_iupdat ( ip , 0 ) ; } else { ( void ) ud_syncip ( ip , B_ASYNC , I_SYNC ) ; } rw_exit ( & ip -> i_contents ) ; } if ( lip != NULL ) { ITIMES ( lip ) ; VN_RELE ( ITOV ( lip ) ) ; } } mutex_exit ( & ud_icache_lock ) ; } 