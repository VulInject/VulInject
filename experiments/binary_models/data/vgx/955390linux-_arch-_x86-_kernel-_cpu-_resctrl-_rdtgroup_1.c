static int mkdir_rdt_prepare ( struct kernfs_node * parent_kn , const char * name , umode_t mode , enum rdt_group_type rtype , struct rdtgroup * * r ) { struct rdtgroup * prdtgrp , * rdtgrp ; struct kernfs_node * kn ; uint files = 0 ; int ret ; prdtgrp = rdtgroup_kn_lock_live ( parent_kn ) ; if ( ! prdtgrp ) { ret = - ENODEV ; out_unlock } if ( rtype == RDTMON_GROUP && ( prdtgrp -> mode == RDT_MODE_PSEUDO_LOCKSETUP || prdtgrp -> mode == RDT_MODE_PSEUDO_LOCKED ) ) { ret = - EINVAL ; rdt_last_cmd_puts ( "Pseudo-locking in progress\n" ) ; out_unlock } rdtgrp = kmalloc ( sizeof ( * rdtgrp ) , GFP_KERNEL ) ; if ( ! rdtgrp ) { ret = - ENOSPC ; rdt_last_cmd_puts ( "Kernel out of memory\n" ) ; out_unlock } * r = rdtgrp ; rdtgrp -> mon . parent = prdtgrp ; rdtgrp -> type = rtype ; INIT_LIST_HEAD ( & rdtgrp -> mon . crdtgrp_list ) ; kn = kernfs_create_dir ( parent_kn , name , mode , rdtgrp ) ; if ( IS_ERR ( kn ) ) { ret = PTR_ERR ( kn ) ; rdt_last_cmd_puts ( "kernfs create error\n" ) ; out_free_rgrp } rdtgrp -> kn = kn ; kernfs_get ( kn ) ; ret = rdtgroup_kn_set_ugid ( kn ) ; if ( ret ) { rdt_last_cmd_puts ( "kernfs perm error\n" ) ; out_destroy } files = RFTYPE_BASE | BIT ( RF_CTRLSHIFT + rtype ) ; ret = rdtgroup_add_files ( kn , files ) ; if ( ret ) { rdt_last_cmd_puts ( "kernfs fill error\n" ) ; out_destroy } if ( rdt_mon_capable ) { ret = alloc_rmid ( ) ; if ( ret < 0 ) { rdt_last_cmd_puts ( "Out of RMIDs\n" ) ; out_destroy } rdtgrp -> mon . rmid = ret ; ret = mkdir_mondata_all ( kn , rdtgrp , & rdtgrp -> mon . mon_data_kn ) ; if ( ret ) { rdt_last_cmd_puts ( "kernfs subdir error\n" ) ; out_idfree } } kernfs_activate ( kn ) ; return 0 ; out_idfree free_rmid ( rdtgrp -> mon . rmid ) ; out_destroy kernfs_put ( rdtgrp -> kn ) ; kernfs_remove ( rdtgrp -> kn ) ; out_free_rgrp kfree ( rdtgrp ) ; out_unlock rdtgroup_kn_unlock ( parent_kn ) ; return ret ; } 