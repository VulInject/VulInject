static str cpl_302_reason = str_init ( "Moved temporarily" ) ; { if ( ( char * ) ( _ptr_ ) > ( _intr_ ) -> script . len + ( _intr_ ) -> script . s ) { LM_ERR ( "overflow detected ip=%p ptr=%p in " "func. %s, line %d\n" , ( _intr_ ) -> ip , _ptr_ , __FILE__ , __LINE__ ) ; _error_ } } 0 ; { if ( ( char * ) ( ( _intr_ ) -> ip + ( _len_ ) ) > ( _intr_ ) -> script . len + ( _intr_ ) -> script . s ) { LM_ERR ( "overflow detected ip=%p offset=%d in " "func. %s, line %d\n" , ( _intr_ ) -> ip , _len_ , __FILE__ , __LINE__ ) ; _error_ } } while ( 0 ) { ( ( NR_OF_KIDS ( _node_ ) == 0 ) ?DEFAULT_ACTION : ( _node_ ) + KID_OFFSET ( _node_ , 0 ) ) ; } { check_overflow_by_ptr ( ( _p_ ) + BASIC_ATTR_SIZE , _intr_ , _error_ ) ; _code_ = ntohs ( * ( ( unsigned short * ) ( _p_ ) ) ) ; _n_ = ntohs ( * ( ( unsigned short * ) ( ( _p_ ) + 2 ) ) ) ; ( _p_ ) += 4 ; } 0 ; { if ( ( ( int ) ( _len_ ) ) - ( _FIXUP_ ) <= 0 ) { LM_ERR ( "%s:%d: attribute is an empty string\n" , __FILE__ , __LINE__ ) ; _error_ } else { check_overflow_by_ptr ( ( _p_ ) + ( _len_ ) , _intr_ , _error_ ) ; _s_ = _p_ ; ( _p_ ) += ( _len_ ) + 1 * ( ( ( _len_ ) & 0x0001 ) == 1 ) ; ( _len_ ) -= ( _FIXUP_ ) ; } } while ( 0 ) { struct cpl_interpreter * new_cpl_interpreter ( struct sip_msg * msg , str * script ) { struct cpl_interpreter * intr = 0 ; intr = ( cpl_interpreter * ) shm_malloc ( sizeof ( cpl_interpreter ) ) ; if ( ! intr ) { LM_ERR ( "no more shm free memory!\n" ) ; error } intr -> script . s = script -> s ; intr -> script . len = script -> len ; intr -> recv_time = time ( 0 ) ; intr -> ip = script -> s ; intr -> msg = msg ; if ( NODE_TYPE ( intr -> ip ) != CPL_NODE ) { LM_ERR ( "first node is not CPL!!\n" ) ; error } return intr ; error return 0 ; } } 