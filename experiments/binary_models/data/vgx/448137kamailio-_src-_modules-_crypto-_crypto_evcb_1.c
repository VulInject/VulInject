int crypto_nio_received ( sr_event_param_t * evp ) { int ret ; crypto_env_t evenv ; EVP_CIPHER_CTX * de = NULL ; str dtext ; str * obuf ; memset ( & evenv , 0 , sizeof ( crypto_env_t ) ) ; evenv . evp = evp ; ret = crypto_exec_evroute ( & evenv , _crypto_rts . netio , & _crypto_kevcb_netio , & _crypto_rts . netio_name ) ; LM_DBG ( "sent event callback - ret:%d - flags:%d\n" , ret , evenv . mflags ) ; if ( ! ( evenv . mflags & CRYPTO_NIO_DECRYPT ) ) { done } LM_DBG ( "decrypting\n" ) ; de = EVP_CIPHER_CTX_new ( ) ; if ( de == NULL ) { LM_ERR ( "cannot get new cipher context\n" ) ; return - 1 ; } if ( crypto_aes_init ( ( unsigned char * ) _crypto_netio_key . s , _crypto_netio_key . len , ( unsigned char * ) crypto_get_salt ( ) , NULL , NULL , de ) ) { EVP_CIPHER_CTX_free ( de ) ; LM_ERR ( "couldn't initialize AES cipher\n" ) ; return - 1 ; } obuf = ( str * ) evp -> data ; dtext . len = obuf -> len ; dtext . s = ( char * ) crypto_aes_decrypt ( de , ( unsigned char * ) obuf -> s , & dtext . len ) ; if ( dtext . s == NULL ) { EVP_CIPHER_CTX_free ( de ) ; LM_ERR ( "AES decryption failed\n" ) ; return - 1 ; } if ( dtext . len >= BUF_SIZE ) { LM_ERR ( "new buffer overflow (%d)\n" , dtext . len ) ; EVP_CIPHER_CTX_free ( de ) ; return - 1 ; } obuf -> len = dtext . len ; memcpy ( obuf -> s , dtext . s , obuf -> len ) ; obuf -> s [ obuf -> len ] = '\0' ; EVP_CIPHER_CTX_cleanup ( de ) ; EVP_CIPHER_CTX_free ( de ) ; free ( dtext . s ) ; done return 0 ; } 