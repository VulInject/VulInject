static int dos_menu_cb ( fdisk_context * * cxt0 , const menu * menu __attribute__ ( ( __unused__ ) ) , const menu_entry * ent ) ( fdisk_context * cxt = * cxt0 , int rc = 0 , DBG ( MENU , ul_debug ( "enter DOS menu" ) ) , ( ! ent -> expert ) { switch ( ent -> key ) { case 'a' : { size_t n rc = fdisk_ask_partnum ( cxt , & n , FALSE ) if ( ! rc ) { rc = fdisk_toggle_partition_flag ( cxt , n , DOS_FLAG_ACTIVE ) ; } } break ; } ; case 'b' : { fdisk_context * bsd = fdisk_new_nested_context ( cxt , "bsd" ) if ( ! bsd ) { return - ENOMEM ; } } if ( ! fdisk_has_label ( bsd ) ) { rc = fdisk_create_disklabel ( bsd , "bsd" ) ; } } if ( rc ) { fdisk_unref_context ( bsd ) ; } else { * cxt0 = cxt = bsd fdisk_info ( cxt , _ ( "Entering nested BSD disklabel." ) ) } ; ) ; 'c' : toggle_dos_compatibility_flag ( cxt ) ; break ; rc ; ( ent -> key ) { case 'b' : { size_t n rc = fdisk_ask_partnum ( cxt , & n , FALSE ) if ( ! rc ) { rc = fdisk_dos_move_begin ( cxt , n ) ; } } break ; } ; case 'i' : rc = fdisk_set_disklabel_id ( cxt ) ; break ; case 'M' : if ( fdisk_get_parent ( cxt ) ) { * cxt0 = fdisk_get_parent ( cxt ) ; fdisk_info ( cxt , _ ( "Leaving nested disklabel." ) ) ; } break ; case 'F' : rc = fdisk_dos_fix_chs ( cxt ) ; if ( rc ) { fdisk_info ( cxt , _ ( "C/H/S values fixed." ) ) ; } else { fdisk_info ( cxt , _ ( "Nothing to do. C/H/S values are correct already." ) ) ; } break ; rc ; 