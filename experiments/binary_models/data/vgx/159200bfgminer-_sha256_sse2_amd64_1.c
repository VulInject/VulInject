bool scanhash_sse2_64 ( struct thr_info * const thr , struct work * const work , uint32_t max_nonce , uint32_t * last_nonce , uint32_t nonce ) { const uint8_t * const pmidstate = work -> midstate ; uint8_t * pdata = work -> data ; const uint32_t * const phash1 = hash1_init ; uint8_t * const phash = work -> hash ; uint32_t * hash32 = ( uint32_t * ) phash ; uint32_t * nNonce_p = ( uint32_t * ) ( pdata + 76 ) ; uint32_t m_midstate [ 8 ] , m_w [ 16 ] , m_w1 [ 16 ] ; __m128i m_4w [ 64 ] __attribute__ ( ( aligned ( 0x100 ) ) ) ; __m128i m_4hash [ 64 ] __attribute__ ( ( aligned ( 0x100 ) ) ) ; __m128i m_4hash1 [ 64 ] __attribute__ ( ( aligned ( 0x100 ) ) ) ; __m128i offset ; int i ; pdata += 64 ; { __m128i m ; uint32_t i [ 4 ] ; } , mi memcpy ( m_midstate , pmidstate , sizeof ( m_midstate ) ) ; memcpy ( m_w , pdata , sizeof ( m_w ) ) ; memcpy ( m_w1 , phash1 , sizeof ( m_w1 ) ) ; for ( i = 0 ; i < 16 ; i ++ ) { m_4w [ i ] = _mm_set1_epi32 ( m_w [ i ] ) ; } for ( i = 0 ; i < 16 ; i ++ ) { m_4hash1 [ i ] = _mm_set1_epi32 ( m_w1 [ i ] ) ; } for ( i = 0 ; i < 64 ; i ++ ) { sha256_consts_m128i [ i ] = _mm_set1_epi32 ( g_sha256_k [ i ] ) ; } offset = _mm_set_epi32 ( 0x3 , 0x2 , 0x1 , 0x0 ) ; for ( ; ; ) { int j ; m_4w [ 3 ] = _mm_add_epi32 ( offset , _mm_set1_epi32 ( nonce ) ) ; sha256_sse2_64_new ( m_4hash , m_4hash1 , m_4w , m_midstate ) ; for ( j = 0 ; j < 4 ; j ++ ) { mi . m = m_4hash [ 7 ] ; if ( unlikely ( mi . i [ j ] == 0 ) ) { break ; } } if ( unlikely ( j != 4 ) ) { for ( i = 0 ; i < 8 ; i ++ ) { mi . m = m_4hash [ i ] ; * ( uint32_t * ) & ( phash ) [ i * 4 ] = mi . i [ j ] ; } if ( unlikely ( hash32 [ 7 ] == 0 ) ) { nonce += j ; * last_nonce = nonce + 1 ; * nNonce_p = nonce ; return true ; } } if ( unlikely ( ( nonce >= max_nonce ) || thr -> work_restart ) ) { * last_nonce = nonce ; return false ; } nonce += 4 ; } } 