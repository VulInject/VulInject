static int iscsit_task_reassign_prepare_write ( struct iscsi_tmr_req * tmr_req , struct iscsit_conn * conn ) { struct iscsit_cmd * cmd = tmr_req -> ref_cmd ; struct iscsi_pdu * pdu = NULL ; struct iscsi_r2t * r2t = NULL , * r2t_tmp ; int first_incomplete_r2t = 1 , i = 0 ; if ( cmd -> unsolicited_data ) { iscsit_task_reassign_prepare_unsolicited_dataout ( cmd , conn ) ; } if ( ! tmr_req -> exp_data_sn ) { drop_unacknowledged_r2ts } spin_lock_bh ( & cmd -> r2t_lock ) ; if ( list_empty ( & cmd -> cmd_r2t_list ) ) { spin_unlock_bh ( & cmd -> r2t_lock ) ; return - 1 ; } list_for_each_entry ( , , ) { if ( r2t -> seq_complete ) { continue ; } if ( r2t -> recovery_r2t ) { continue ; } if ( conn -> sess -> sess_ops -> DataSequenceInOrder ) { if ( ! first_incomplete_r2t ) { cmd -> r2t_offset -= r2t -> xfer_len ; next } if ( conn -> sess -> sess_ops -> DataPDUInOrder ) { cmd -> data_sn = 0 ; cmd -> r2t_offset -= ( r2t -> xfer_len - cmd -> next_burst_len ) ; first_incomplete_r2t = 0 ; next } cmd -> data_sn = 0 ; cmd -> r2t_offset -= r2t -> xfer_len ; for ( i = 0 ; i < cmd -> pdu_count ; i ++ ) { pdu = & cmd -> pdu_list [ i ] ; if ( pdu -> status != ISCSI_PDU_RECEIVED_OK ) { continue ; } if ( ( pdu -> offset >= r2t -> offset ) && ( pdu -> offset < ( r2t -> offset + r2t -> xfer_len ) ) ) { cmd -> next_burst_len -= pdu -> length ; cmd -> write_data_done -= pdu -> length ; pdu -> status = ISCSI_PDU_NOT_RECEIVED ; } } first_incomplete_r2t = 0 ; } else { struct iscsi_seq * seq ; seq = iscsit_get_seq_holder ( cmd , r2t -> offset , r2t -> xfer_len ) ; if ( ! seq ) { spin_unlock_bh ( & cmd -> r2t_lock ) ; return - 1 ; } cmd -> write_data_done -= ( seq -> offset - seq -> orig_offset ) ; seq -> data_sn = 0 ; seq -> offset = seq -> orig_offset ; seq -> next_burst_len = 0 ; seq -> status = DATAOUT_SEQUENCE_WITHIN_COMMAND_RECOVERY ; cmd -> seq_send_order -- ; if ( conn -> sess -> sess_ops -> DataPDUInOrder ) { next } for ( i = 0 ; i < seq -> pdu_count ; i ++ ) { pdu = & cmd -> pdu_list [ i + seq -> pdu_start ] ; if ( pdu -> status != ISCSI_PDU_RECEIVED_OK ) { continue ; } pdu -> status = ISCSI_PDU_NOT_RECEIVED ; } } next cmd -> outstanding_r2ts -- ; } spin_unlock_bh ( & cmd -> r2t_lock ) ; drop_unacknowledged_r2ts cmd -> cmd_flags &= ~ ICF_SENT_LAST_R2T ; cmd -> r2t_sn = tmr_req -> exp_data_sn ; spin_lock_bh ( & cmd -> r2t_lock ) ; list_for_each_entry_safe ( , , , ) { if ( r2t -> r2t_sn < tmr_req -> exp_data_sn ) { continue ; } if ( r2t -> seq_complete ) { pr_err ( "Initiator is requesting R2Ts from" " R2TSN: 0x%08x, but R2TSN: 0x%08x, Offset: %u," " Length: %u is already complete." "   BAD INITIATOR ERL=2 IMPLEMENTATION!\n" , tmr_req -> exp_data_sn , r2t -> r2t_sn , r2t -> offset , r2t -> xfer_len ) ; spin_unlock_bh ( & cmd -> r2t_lock ) ; return - 1 ; } if ( r2t -> recovery_r2t ) { iscsit_free_r2t ( r2t , cmd ) ; continue ; } if ( conn -> sess -> sess_ops -> DataSequenceInOrder ) { cmd -> r2t_offset -= r2t -> xfer_len ; } else { cmd -> seq_send_order -- ; } cmd -> outstanding_r2ts -- ; iscsit_free_r2t ( r2t , cmd ) ; } spin_unlock_bh ( & cmd -> r2t_lock ) ; return 0 ; } 