void __init kernel_randomize_memory ( void ) { size_t i ; unsigned long vaddr_start , vaddr ; unsigned long rand , memory_tb ; struct rnd_state rand_state ; unsigned long remain_entropy ; unsigned long vmemmap_size ; vaddr_start = pgtable_l5_enabled ( ) ?__PAGE_OFFSET_BASE_L5 : __PAGE_OFFSET_BASE_L4 ; vaddr = vaddr_start ; BUILD_BUG_ON ( vaddr_start >= vaddr_end ) ; BUILD_BUG_ON ( vaddr_end != CPU_ENTRY_AREA_BASE ) ; BUILD_BUG_ON ( vaddr_end > __START_KERNEL_map ) ; kaslr_regions [ 0 ] . size_tb = 1 << ( MAX_PHYSMEM_BITS - TB_SHIFT ) ; kaslr_regions [ 1 ] . size_tb = VMALLOC_SIZE_TB ; BUG_ON ( kaslr_regions [ 0 ] . base != & page_offset_base ) ; memory_tb = DIV_ROUND_UP ( max_pfn << PAGE_SHIFT , 1UL << TB_SHIFT ) + CONFIG_RANDOMIZE_MEMORY_PHYSICAL_PADDING ; if ( memory_tb < kaslr_regions [ 0 ] . size_tb ) { kaslr_regions [ 0 ] . size_tb = memory_tb ; } vmemmap_size = ( kaslr_regions [ 0 ] . size_tb << ( TB_SHIFT - PAGE_SHIFT ) ) * sizeof ( page ) ; kaslr_regions [ 2 ] . size_tb = DIV_ROUND_UP ( vmemmap_size , 1UL << TB_SHIFT ) ; remain_entropy = vaddr_end - vaddr_start ; for ( i = 0 ; i < ARRAY_SIZE ( kaslr_regions ) ; i ++ ) { remain_entropy -= get_padding ( & kaslr_regions [ i ] ) ; } prandom_seed_state ( & rand_state , kaslr_get_random_long ( "Memory" ) ) ; for ( i = 0 ; i < ARRAY_SIZE ( kaslr_regions ) ; i ++ ) { unsigned long entropy ; entropy = remain_entropy / ( ARRAY_SIZE ( kaslr_regions ) - i ) ; prandom_bytes_state ( & rand_state , & rand , sizeof ( rand ) ) ; entropy = ( rand % ( entropy + 1 ) ) & PUD_MASK ; vaddr += entropy ; * kaslr_regions [ i ] . base = vaddr ; vaddr += get_padding ( & kaslr_regions [ i ] ) ; vaddr = round_up ( vaddr + 1 , PUD_SIZE ) ; remain_entropy -= entropy ; } } 