int yp_write_binding ( int udpport , int tcpport ) { char path [ PATH_MAX ] ; struct ypbind_resp ybr ; int iov [ 3 ] ; struct in_addr bindaddr ; u_short ypbind , ypserv_tcp , ypserv_udp ; ssize_t total ; int fd ; snprintf ( path , sizeof path , "%s/%s.%ld" , BINDINGDIR , env -> sc_domainname , YPVERS ) ; fd = open ( path , O_CREAT | O_SHLOCK | O_RDWR | O_TRUNC , 0644 ) ; if ( fd == - 1 ) { ( void ) mkdir ( BINDINGDIR , 0755 ) ; fd = open ( path , O_CREAT | O_SHLOCK | O_RDWR | O_TRUNC , 0644 ) ; if ( fd == - 1 ) { return - 1 ; } } if ( fchmod ( fd , 0644 ) == - 1 ) { return - 1 ; } iov [ 0 ] . iov_base = ( caddr_t ) & ypbind ; iov [ 0 ] . iov_len = sizeof ypbind ; iov [ 1 ] . iov_base = ( caddr_t ) & ybr ; iov [ 1 ] . iov_len = sizeof ybr ; iov [ 2 ] . iov_base = ( caddr_t ) & ypserv_tcp ; iov [ 2 ] . iov_len = sizeof ypserv_tcp ; bindaddr . s_addr = htonl ( INADDR_LOOPBACK ) ; ypserv_tcp = htons ( tcpport ) ; ypserv_udp = htons ( udpport ) ; ypbind = 0 ; memset ( & ybr , 0 , sizeof ybr ) ; ybr . ypbind_status = YPBIND_SUCC_VAL ; memmove ( & ybr . ypbind_resp_u . ypbind_bindinfo . ypbind_binding_addr , & bindaddr , sizeof ( ybr . ypbind_resp_u . ypbind_bindinfo . ypbind_binding_addr ) ) ; memmove ( & ybr . ypbind_resp_u . ypbind_bindinfo . ypbind_binding_port , & ypserv_udp , sizeof ( ybr . ypbind_resp_u . ypbind_bindinfo . ypbind_binding_port ) ) ; total = iov [ 0 ] . iov_len + iov [ 1 ] . iov_len + iov [ 2 ] . iov_len ; if ( writev ( fd , iov , sizeof ( iov ) / sizeof ( iov [ 0 ] ) ) != total ) { close ( fd ) ; unlink ( path ) ; return - 1 ; } return 0 ; } 