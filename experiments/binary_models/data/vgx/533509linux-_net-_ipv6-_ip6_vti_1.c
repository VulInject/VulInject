static netdev_tx_t vti6_tnl_xmit ( struct sk_buff * skb , struct net_device * dev ) { struct ip6_tnl * t = netdev_priv ( dev ) ; struct flowi fl ; int ret ; if ( ! pskb_inet_may_pull ( skb ) ) { tx_err } memset ( & fl , 0 , sizeof ( fl ) ) ; switch ( skb -> protocol ) { case htons ( ETH_P_IPV6 ) : if ( ( t -> parms . proto != IPPROTO_IPV6 && t -> parms . proto != 0 ) || vti6_addr_conflict ( t , ipv6_hdr ( skb ) ) ) { tx_err } xfrm_decode_session ( skb , & fl , AF_INET6 ) ; break ; case htons ( ETH_P_IP ) : xfrm_decode_session ( skb , & fl , AF_INET ) ; memset ( IPCB ( skb ) , 0 , sizeof ( * IPCB ( skb ) ) ) ; break ; default : tx_err } fl . flowi_mark = be32_to_cpu ( t -> parms . o_key ) ; ret = vti6_xmit ( skb , dev , & fl ) ; if ( ret < 0 ) { tx_err } return NETDEV_TX_OK ; tx_err DEV_STATS_INC ( dev , tx_errors ) ; DEV_STATS_INC ( dev , tx_dropped ) ; kfree_skb ( skb ) ; return NETDEV_TX_OK ; } 