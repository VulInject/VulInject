static void xpc_process_connect ( struct xpc_channel * ch , unsigned long * irq_flags ) { enum xp_retval ret ; lockdep_assert_held ( & ch -> lock ) ; if ( ! ( ch -> flags & XPC_C_OPENREQUEST ) || ! ( ch -> flags & XPC_C_ROPENREQUEST ) ) { return ; } DBUG_ON ( ! ( ch -> flags & XPC_C_CONNECTING ) ) ; if ( ! ( ch -> flags & XPC_C_SETUP ) ) { spin_unlock_irqrestore ( & ch -> lock , * irq_flags ) ; ret = xpc_arch_ops . setup_msg_structures ( ch ) ; spin_lock_irqsave ( & ch -> lock , * irq_flags ) ; if ( ret != xpSuccess ) { XPC_DISCONNECT_CHANNEL ( ch , ret , irq_flags ) ; } else { ch -> flags |= XPC_C_SETUP ; } if ( ch -> flags & XPC_C_DISCONNECTING ) { return ; } } if ( ! ( ch -> flags & XPC_C_OPENREPLY ) ) { ch -> flags |= XPC_C_OPENREPLY ; xpc_arch_ops . send_chctl_openreply ( ch , irq_flags ) ; } if ( ! ( ch -> flags & XPC_C_ROPENREPLY ) ) { return ; } if ( ! ( ch -> flags & XPC_C_OPENCOMPLETE ) ) { ch -> flags |= ( XPC_C_OPENCOMPLETE | XPC_C_CONNECTED ) ; xpc_arch_ops . send_chctl_opencomplete ( ch , irq_flags ) ; } dev_info ( xpc_chan , "channel %d to partition %d connected\n" , ch -> number , ch -> partid ) ; ch -> flags = ( XPC_C_CONNECTED | XPC_C_SETUP ) ; } 