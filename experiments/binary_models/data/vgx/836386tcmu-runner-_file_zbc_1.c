static int zbc_report_zones ( struct tcmu_device * dev , struct tcmulib_cmd * cmd ) { struct zbc_dev * zdev = tcmur_dev_get_private ( dev ) ; uint8_t * cdb = cmd -> cdb ; struct zbc_zone * zone ; struct iovec * iovec = cmd -> iovec ; size_t iov_cnt = cmd -> iov_cnt ; bool partial = cdb [ 14 ] & ZBC_RO_PARTIAL ; uint8_t ro = cdb [ 14 ] & ( ~ ZBC_RO_PARTIAL ) ; unsigned int nr_zones = 0 ; uint8_t data [ 64 ] ; uint32_t val32 ; uint64_t lba , val64 ; size_t len ; switch ( ro ) { case ZBC_RO_ALL : case ZBC_RO_EMPTY : case ZBC_RO_IMP_OPEN : case ZBC_RO_EXP_OPEN : case ZBC_RO_CLOSED : case ZBC_RO_FULL : case ZBC_RO_READONLY : case ZBC_RO_OFFLINE : case ZBC_RO_RWP_RECOMMENDED : case ZBC_RO_NON_SEQ : case ZBC_RO_NOT_WP : break ; default : return tcmu_sense_set_data ( cmd -> sense_buf , ILLEGAL_REQUEST , ASC_INVALID_FIELD_IN_CDB ) ; } lba = tcmu_cdb_get_lba ( cdb ) ; if ( lba >= zdev -> capacity ) { return tcmu_sense_set_data ( cmd -> sense_buf , ILLEGAL_REQUEST , ASC_LBA_OUT_OF_RANGE ) ; } len = tcmu_cdb_get_xfer_length ( cdb ) ; if ( len > 64 ) { len -= 64 ; } else { len = 0 ; } zone = zbc_get_zone ( zdev , lba , false ) ; while ( lba < zdev -> capacity ) { if ( zbc_should_report_zone ( zone , ro ) ) { if ( partial && len < 64 ) { break ; } if ( len > 64 ) { len -= 64 ; } else { len = 0 ; } nr_zones ++ ; } lba = zone -> start + zone -> len ; zone ++ ; } val32 = htobe32 ( nr_zones * 64 ) ; memcpy ( & data [ 0 ] , & val32 , 4 ) ; val64 = htobe64 ( zdev -> capacity - 1 ) ; memcpy ( & data [ 8 ] , & val64 , 8 ) ; len = tcmu_memcpy_into_iovec ( iovec , iov_cnt , data , 64 ) ; if ( len < 64 ) { out } len = tcmu_iovec_length ( iovec , iov_cnt ) ; lba = tcmu_cdb_get_lba ( cdb ) ; zone = zbc_get_zone ( zdev , lba , false ) ; while ( lba < zdev -> capacity && len >= 64 ) { if ( zbc_should_report_zone ( zone , ro ) ) { memset ( data , 0 , sizeof ( data ) ) ; data [ 0 ] = zone -> type & 0x0f ; data [ 1 ] = ( zone -> cond << 4 ) & 0xf0 ; if ( zone -> reset ) { data [ 1 ] |= 0x01 ; } if ( zone -> non_seq ) { data [ 1 ] |= 0x02 ; } val64 = htobe64 ( zone -> len ) ; memcpy ( & data [ 8 ] , & val64 , 8 ) ; val64 = htobe64 ( zone -> start ) ; memcpy ( & data [ 16 ] , & val64 , 8 ) ; val64 = htobe64 ( zone -> wp ) ; memcpy ( & data [ 24 ] , & val64 , 8 ) ; tcmu_memcpy_into_iovec ( iovec , iov_cnt , data , 64 ) ; len -= 64 ; } lba = zone -> start + zone -> len ; zone ++ ; } out return TCMU_STS_OK ; } 