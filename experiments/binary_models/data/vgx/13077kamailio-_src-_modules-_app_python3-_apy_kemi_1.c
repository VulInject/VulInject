PyObject * init_KSR ( void ) { PyMethodDef * _sr_crt_KSRMethods = NULL ; sr_kemi_module_t * emods = NULL ; int emods_size = 0 ; int i ; int k ; int m ; int n ; char mname [ 128 ] ; if ( faked_msg_init ( ) < 0 ) { LM_ERR ( "failed to init local faked sip msg\n" ) ; return NULL ; } _sr_KSRMethods = malloc ( SR_APY_KSR_METHODS_SIZE * sizeof ( PyMethodDef ) ) ; if ( _sr_KSRMethods == NULL ) { LM_ERR ( "no more pkg memory\n" ) ; return NULL ; } _sr_apy_ksr_modules_list = malloc ( SR_APY_KSR_MODULES_SIZE * sizeof ( PyObject * ) ) ; if ( _sr_apy_ksr_modules_list == NULL ) { LM_ERR ( "no more pkg memory\n" ) ; return NULL ; } memset ( _sr_KSRMethods , 0 , SR_APY_KSR_METHODS_SIZE * sizeof ( PyMethodDef ) ) ; memset ( _sr_apy_ksr_modules_list , 0 , SR_APY_KSR_MODULES_SIZE * sizeof ( PyObject * ) ) ; emods_size = sr_kemi_modules_size_get ( ) ; emods = sr_kemi_modules_get ( ) ; n = 0 ; _sr_crt_KSRMethods = _sr_KSRMethods ; if ( emods_size == 0 || emods [ 0 ] . kexp == NULL ) { LM_DBG ( "exporting KSR.%s(...)\n" , _sr_apy_kemi_test [ 0 ] . fname . s ) ; _sr_crt_KSRMethods [ 0 ] . ml_name = _sr_apy_kemi_test [ 0 ] . fname . s ; _sr_crt_KSRMethods [ 0 ] . ml_meth = sr_apy_kemi_export_associate ( & _sr_apy_kemi_test [ 0 ] ) ; _sr_crt_KSRMethods [ 0 ] . ml_flags = METH_VARARGS ; _sr_crt_KSRMethods [ 0 ] . ml_doc = NAME " exported function" ; } else { for ( i = 0 ; emods [ 0 ] . kexp [ i ] . func != NULL ; i ++ ) { LM_DBG ( "exporting KSR.%s(...)\n" , emods [ 0 ] . kexp [ i ] . fname . s ) ; _sr_crt_KSRMethods [ i ] . ml_name = emods [ 0 ] . kexp [ i ] . fname . s ; _sr_crt_KSRMethods [ i ] . ml_meth = sr_apy_kemi_export_associate ( & emods [ 0 ] . kexp [ i ] ) ; if ( _sr_crt_KSRMethods [ i ] . ml_meth == NULL ) { LM_ERR ( "failed to associate kemi function with python export\n" ) ; _sr_KSRMethods = NULL ; return NULL ; } _sr_crt_KSRMethods [ i ] . ml_flags = METH_VARARGS ; _sr_crt_KSRMethods [ i ] . ml_doc = NAME " exported function" ; n ++ ; } } KSR_moduledef . m_methods = _sr_crt_KSRMethods ; _sr_apy_ksr_module = PyModule_Create ( & KSR_moduledef ) ; Py_INCREF ( _sr_apy_ksr_module ) ; m = 0 ; _sr_apy_ksr_modules_list [ m ] = PyModule_Create ( & KSR_x_moduledef ) ; PyModule_AddObject ( _sr_apy_ksr_module , "x" , _sr_apy_ksr_modules_list [ m ] ) ; Py_INCREF ( _sr_apy_ksr_modules_list [ m ] ) ; m ++ ; if ( emods_size > 1 ) { for ( k = 1 ; k < emods_size ; k ++ ) { n ++ ; _sr_crt_KSRMethods = _sr_KSRMethods + n ; snprintf ( mname , 128 , "KSR.%s" , emods [ k ] . kexp [ 0 ] . mname . s ) ; for ( i = 0 ; emods [ k ] . kexp [ i ] . func != NULL ; i ++ ) { LM_DBG ( "exporting %s.%s(...)\n" , mname , emods [ k ] . kexp [ i ] . fname . s ) ; _sr_crt_KSRMethods [ i ] . ml_name = emods [ k ] . kexp [ i ] . fname . s ; _sr_crt_KSRMethods [ i ] . ml_meth = sr_apy_kemi_export_associate ( & emods [ k ] . kexp [ i ] ) ; if ( _sr_crt_KSRMethods [ i ] . ml_meth == NULL ) { LM_ERR ( "failed to associate kemi function with python export\n" ) ; free ( _sr_KSRMethods ) ; _sr_KSRMethods = NULL ; return NULL ; } _sr_crt_KSRMethods [ i ] . ml_flags = METH_VARARGS ; _sr_crt_KSRMethods [ i ] . ml_doc = NAME " exported function" ; n ++ ; } LM_DBG ( "initializing kemi sub-module: %s (%s)\n" , mname , emods [ k ] . kexp [ 0 ] . mname . s ) ; PyModuleDef * mmodule = malloc ( sizeof ( PyModuleDef ) ) ; memset ( mmodule , 0 , sizeof ( PyModuleDef ) ) ; mmodule -> m_name = strndup ( mname , 127 ) ; mmodule -> m_methods = _sr_crt_KSRMethods ; mmodule -> m_size = - 1 ; _sr_apy_ksr_modules_list [ m ] = PyModule_Create ( mmodule ) ; PyModule_AddObject ( _sr_apy_ksr_module , emods [ k ] . kexp [ 0 ] . mname . s , _sr_apy_ksr_modules_list [ m ] ) ; Py_INCREF ( _sr_apy_ksr_modules_list [ m ] ) ; m ++ ; } } LM_DBG ( "module 'KSR' has been initialized\n" ) ; return _sr_apy_ksr_module ; } 