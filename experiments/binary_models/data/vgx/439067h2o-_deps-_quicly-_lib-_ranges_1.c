int quicly_ranges_subtract ( quicly_ranges_t * ranges , uint64_t start , uint64_t end ) { size_t shrink_from , slot ; assert ( start <= end ) ; if ( start == end ) { return 0 ; } if ( ranges -> num_ranges == 0 ) { return 0 ; } if ( end <= ranges -> ranges [ 0 ] . start ) { return 0 ; } if ( ranges -> ranges [ ranges -> num_ranges - 1 ] . end <= start ) { return 0 ; } for ( slot = 0 ; ranges -> ranges [ slot ] . end < start ; ++ slot ) { } if ( end <= ranges -> ranges [ slot ] . end ) { if ( start <= ranges -> ranges [ slot ] . start ) { ranges -> ranges [ slot ] . start = end ; } if ( end == ranges -> ranges [ slot ] . end ) { ranges -> ranges [ slot ] . end = start ; } else { int ret ; if ( ( ret = insert_at ( ranges , end , ranges -> ranges [ slot ] . end , slot + 1 ) ) != 0 ) { return ret ; } ranges -> ranges [ slot ] . end = start ; return 0 ; } if ( ranges -> ranges [ slot ] . start == ranges -> ranges [ slot ] . end ) { quicly_ranges_drop_by_range_indices ( ranges , slot , slot + 1 ) ; } return 0 ; } if ( start <= ranges -> ranges [ slot ] . start ) { shrink_from = slot ; } else { ranges -> ranges [ slot ] . end = start ; shrink_from = slot + 1 ; } for ( ++ slot ; slot != ranges -> num_ranges ; ++ slot ) { if ( end <= ranges -> ranges [ slot ] . start ) { break ; } if ( end < ranges -> ranges [ slot ] . end ) { ranges -> ranges [ slot ] . start = end ; break ; } } if ( shrink_from != slot ) { quicly_ranges_drop_by_range_indices ( ranges , shrink_from , slot ) ; } return 0 ; } 