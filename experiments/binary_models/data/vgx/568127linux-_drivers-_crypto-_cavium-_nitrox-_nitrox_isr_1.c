int nitrox_sriov_register_interupts ( struct nitrox_device * ndev ) { struct pci_dev * pdev = ndev -> pdev ; struct nitrox_q_vector * qvec ; int vec , cpu ; int ret ; ndev -> iov . msix . entry = NON_RING_MSIX_BASE ; ret = pci_enable_msix_exact ( pdev , & ndev -> iov . msix , NR_NON_RING_VECTORS ) ; if ( ret ) { dev_err ( DEV ( ndev ) , "failed to allocate nps-core-int%d\n" , NON_RING_MSIX_BASE ) ; return ret ; } qvec = kcalloc ( NR_NON_RING_VECTORS , sizeof ( * qvec ) , GFP_KERNEL ) ; if ( ! qvec ) { pci_disable_msix ( pdev , NULL ) ; return - ENOMEM ; } qvec -> ndev = ndev ; ndev -> qvec = qvec ; ndev -> num_vecs = NR_NON_RING_VECTORS ; snprintf ( qvec -> name , IRQ_NAMESZ , "nitrox-core-int%d" , NON_RING_MSIX_BASE ) ; vec = ndev -> iov . msix . vector ; ret = request_irq ( vec , nps_core_int_isr , 0 , qvec -> name , qvec ) ; if ( ret ) { dev_err ( DEV ( ndev ) , "irq failed for nitrox-core-int%d\n" , NON_RING_MSIX_BASE ) ; iov_irq_fail } cpu = num_online_cpus ( ) ; irq_set_affinity_hint ( vec , get_cpu_mask ( cpu ) ) ; tasklet_init ( & qvec -> resp_tasklet , nps_core_int_tasklet , ( unsigned long ) qvec ) ; qvec -> valid = true ; return 0 ; iov_irq_fail nitrox_sriov_unregister_interrupts ( ndev ) ; return ret ; } 