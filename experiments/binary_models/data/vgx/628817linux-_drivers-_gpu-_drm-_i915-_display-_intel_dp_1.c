static int intel_dp_dsc_compute_params ( struct intel_encoder * encoder , struct intel_crtc_state * crtc_state ) { struct drm_i915_private * i915 = to_i915 ( encoder -> base . dev ) ; struct intel_dp * intel_dp = enc_to_intel_dp ( encoder ) ; struct drm_dsc_config * vdsc_cfg = & crtc_state -> dsc . config ; u8 line_buf_depth ; int ret ; vdsc_cfg -> rc_model_size = DSC_RC_MODEL_SIZE_CONST ; vdsc_cfg -> pic_height = crtc_state -> hw . adjusted_mode . crtc_vdisplay ; if ( vdsc_cfg -> pic_height % 8 == 0 ) { vdsc_cfg -> slice_height = 8 ; } if ( vdsc_cfg -> pic_height % 4 == 0 ) { vdsc_cfg -> slice_height = 4 ; } else { vdsc_cfg -> slice_height = 2 ; } ret = intel_dsc_compute_params ( crtc_state ) ; vdsc_cfg -> dsc_version_major = ( intel_dp -> dsc_dpcd [ DP_DSC_REV - DP_DSC_SUPPORT ] & DP_DSC_MAJOR_MASK ) >> DP_DSC_MAJOR_SHIFT ; vdsc_cfg -> dsc_version_minor = min ( intel_dp_source_dsc_version_minor ( intel_dp ) , intel_dp_sink_dsc_version_minor ( intel_dp ) ) ; vdsc_cfg -> convert_rgb = intel_dp -> dsc_dpcd [ DP_DSC_DEC_COLOR_FORMAT_CAP - DP_DSC_SUPPORT ] & DP_DSC_RGB ; line_buf_depth = drm_dp_dsc_sink_line_buf_depth ( intel_dp -> dsc_dpcd ) ; if ( ! line_buf_depth ) { drm_dbg_kms ( & i915 -> drm , "DSC Sink Line Buffer Depth invalid\n" ) ; return - EINVAL ; } if ( vdsc_cfg -> dsc_version_minor == 2 ) { vdsc_cfg -> line_buf_depth = ( line_buf_depth == DSC_1_2_MAX_LINEBUF_DEPTH_BITS ) ?DSC_1_2_MAX_LINEBUF_DEPTH_VAL : line_buf_depth ; } else { vdsc_cfg -> line_buf_depth = ( line_buf_depth > DSC_1_1_MAX_LINEBUF_DEPTH_BITS ) ?DSC_1_1_MAX_LINEBUF_DEPTH_BITS : line_buf_depth ; } vdsc_cfg -> block_pred_enable = intel_dp -> dsc_dpcd [ DP_DSC_BLK_PREDICTION_SUPPORT - DP_DSC_SUPPORT ] & DP_DSC_BLK_PREDICTION_IS_SUPPORTED ; return drm_dsc_compute_rc_parameters ( vdsc_cfg ) ; } 