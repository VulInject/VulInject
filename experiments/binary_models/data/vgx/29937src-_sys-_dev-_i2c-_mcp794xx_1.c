int mcprtc_clock_write ( struct mcprtc_softc * sc , struct clock_ymdhms * dt ) { uint8_t regs [ MCP794XX_NRTC_REGS ] ; uint8_t cmd = MCP794XX_SC ; uint8_t oscoff , oscbit ; uint8_t reg ; int error , i ; regs [ 0 ] = TOBCD ( dt -> dt_sec , NULL ) ; regs [ 1 ] = TOBCD ( dt -> dt_min ) ; regs [ 2 ] = TOBCD ( dt -> dt_hour ) ; regs [ 3 ] = TOBCD ( dt -> dt_wday ) | MCP794XX_DW_VBATEN ; regs [ 4 ] = TOBCD ( dt -> dt_day ) ; regs [ 5 ] = TOBCD ( dt -> dt_mon ) ; regs [ 6 ] = TOBCD ( dt -> dt_year - 2000 ) ; if ( sc -> sc_extosc ) { oscoff = MCP794XX_CR ; oscbit = MCP794XX_CR_EXTOSC ; } else { oscoff = MCP794XX_SC ; oscbit = MCP794XX_SC_ST ; } reg = mcprtc_reg_read ( sc , oscoff ) ; reg &= ~ oscbit ; mcprtc_reg_write ( sc , oscoff , reg ) ; for ( i = 0 ; i < 10 ; i ++ ) { reg = mcprtc_reg_read ( sc , MCP794XX_DW ) ; if ( ( reg & MCP794XX_DW_OSCRUN ) == 0 ) { break ; } delay ( 10 ) ; } if ( i == 10 ) { error = EIO ; fail } iic_acquire_bus ( sc -> sc_tag , I2C_F_POLL ) ; error = iic_exec ( sc -> sc_tag , I2C_OP_WRITE_WITH_STOP , sc -> sc_addr , & cmd , sizeof ( cmd ) , regs , MCP794XX_NRTC_REGS , I2C_F_POLL ) ; iic_release_bus ( sc -> sc_tag , I2C_F_POLL ) ; reg = mcprtc_reg_read ( sc , oscoff ) ; reg |= oscbit ; mcprtc_reg_write ( sc , oscoff , reg ) ; fail if ( error ) { printf ( "%s: can't write RTC\n" , sc -> sc_dev . dv_xname ) ; return error ; } return 0 ; } 