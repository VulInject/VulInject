static long qxl_fence_wait ( struct dma_fence * fence , bool intr , signed long timeout ) { struct qxl_device * qdev ; struct qxl_release * release ; int count = 0 , sc = 0 ; bool have_drawable_releases ; unsigned long cur , end = jiffies + timeout ; qdev = container_of ( fence -> lock , qxl_device , release_lock ) ; release = container_of ( fence , qxl_release , base ) ; have_drawable_releases = release -> type == QXL_RELEASE_DRAWABLE ; retry sc ++ ; if ( dma_fence_is_signaled ( fence ) ) { signaled } qxl_io_notify_oom ( qdev ) ; for ( count = 0 ; count < 11 ; count ++ ) { if ( dma_fence_is_signaled ( fence ) ) { signaled } } if ( dma_fence_is_signaled ( fence ) ) { signaled } if ( have_drawable_releases || sc < 4 ) { if ( sc > 2 ) { usleep_range ( 500 , 1000 ) ; } if ( time_after ( jiffies , end ) ) { return 0 ; } if ( have_drawable_releases && sc > 300 ) { DMA_FENCE_WARN ( fence , "failed to wait on release %llu " "after spincount %d\n" , fence -> context & ~ 0xf0000000 , sc ) ; signaled } retry } signaled cur = jiffies ; if ( time_after ( cur , end ) ) { return 0 ; } return end - cur ; } static const struct dma_fence_ops qxl_fence_ops = { . get_driver_name = qxl_get_driver_name . get_timeline_name = qxl_get_timeline_name . enable_signaling = qxl_nop_signaling . wait = qxl_fence_wait } ; 