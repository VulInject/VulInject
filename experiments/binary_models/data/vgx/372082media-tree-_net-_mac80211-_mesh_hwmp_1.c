static void mesh_queue_preq ( struct mesh_path * mpath , u8 flags ) { struct ieee80211_sub_if_data * sdata = mpath -> sdata ; struct ieee80211_if_mesh * ifmsh = & sdata -> u . mesh ; struct mesh_preq_queue * preq_node ; preq_node = kmalloc ( sizeof ( mesh_preq_queue ) , GFP_ATOMIC ) ; if ( ! preq_node ) { mhwmp_dbg ( sdata , "could not allocate PREQ node\n" ) ; return ; } spin_lock_bh ( & ifmsh -> mesh_preq_queue_lock ) ; if ( ifmsh -> preq_queue_len == MAX_PREQ_QUEUE_LEN ) { spin_unlock_bh ( & ifmsh -> mesh_preq_queue_lock ) ; if ( printk_ratelimit ( ) ) { mhwmp_dbg ( sdata , "PREQ node queue full\n" ) ; } return ; } spin_lock ( & mpath -> state_lock ) ; if ( mpath -> flags & MESH_PATH_REQ_QUEUED ) { spin_unlock ( & mpath -> state_lock ) ; spin_unlock_bh ( & ifmsh -> mesh_preq_queue_lock ) ; kfree ( preq_node ) ; return ; } memcpy ( preq_node -> dst , mpath -> dst , ETH_ALEN ) ; preq_node -> flags = flags ; mpath -> flags |= MESH_PATH_REQ_QUEUED ; spin_unlock ( & mpath -> state_lock ) ; list_add_tail ( & preq_node -> list , & ifmsh -> preq_queue . list ) ; ++ ifmsh -> preq_queue_len ; spin_unlock_bh ( & ifmsh -> mesh_preq_queue_lock ) ; if ( time_after ( jiffies , ifmsh -> last_preq + min_preq_int_jiff ( sdata ) ) ) { ieee80211_queue_work ( & sdata -> local -> hw , & sdata -> work ) ; } if ( time_before ( jiffies , ifmsh -> last_preq ) ) { ifmsh -> last_preq = jiffies - min_preq_int_jiff ( sdata ) - 1 ; ieee80211_queue_work ( & sdata -> local -> hw , & sdata -> work ) ; } else { mod_timer ( & ifmsh -> mesh_path_timer , ifmsh -> last_preq + min_preq_int_jiff ( sdata ) ) ; } } 